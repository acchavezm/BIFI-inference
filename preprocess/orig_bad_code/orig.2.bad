X = input ( ) <NEWLINE> if 399 < X < 600 : <NEWLINE> <INDENT> print ( 8 ) <NEWLINE> <DEDENT> if 599 < X < 800 : <NEWLINE> <INDENT> print ( 7 ) <NEWLINE> <DEDENT> if 799 < X < 1000 : <NEWLINE> <INDENT> print ( 6 ) <NEWLINE> <DEDENT> if 999 < X < 1200 : <NEWLINE> <INDENT> print ( 5 ) <NEWLINE> <DEDENT> if 1199 < X < 1400 : <NEWLINE> <INDENT> print ( 4 ) <NEWLINE> <DEDENT> if 1399 < X < 1600 : <NEWLINE> <INDENT> print ( 3 ) <NEWLINE> <DEDENT> if 1599 < X < 1800 : <NEWLINE> <INDENT> print ( 2 ) <NEWLINE> <DEDENT> if 1799 < X < 2000 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT>
x = input ( ) <NEWLINE> if 400 <= x and x < 600 : <NEWLINE> <INDENT> rank = 8 <NEWLINE> <DEDENT> elif 600 <= x and x < 800 : <NEWLINE> <INDENT> rank = 7 <NEWLINE> <DEDENT> elif 800 <= x and x < 1000 : <NEWLINE> <INDENT> rank = 6 <NEWLINE> <DEDENT> elif 1000 <= x and x < 1200 : <NEWLINE> <INDENT> rank = 5 <NEWLINE> <DEDENT> elif 1200 <= x and x < 1400 : <NEWLINE> <INDENT> rank = 4 <NEWLINE> <DEDENT> elif 1400 <= x and x < 1600 : <NEWLINE> <INDENT> rank = 3 <NEWLINE> <DEDENT> elif 1600 <= x and x < 1800 : <NEWLINE> <INDENT> rank = 2 <NEWLINE> <DEDENT> elif 1800 <= x and x < 2000 : <NEWLINE> <INDENT> rank = 1 <NEWLINE> <DEDENT> print ( rank ) <NEWLINE>
X = int ( input ( ) ) <NEWLINE> <NL> cnt = 1 <NEWLINE> <NL> a = X - 400 / 200 <NEWLINE> for i in range ( .7 ) : <NEWLINE> <INDENT> if 7 <= a < 8 : <NEWLINE> <INDENT> print ( cnt ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> if n < 600 : <NEWLINE> <INDENT> ans = 8 <NEWLINE> <DEDENT> elif n < 800 : <NEWLINE> <INDENT> ans = 7 <NEWLINE> <DEDENT> elif n < 1000 : <NEWLINE> <INDENT> ans = 6 <NEWLINE> <DEDENT> elif n < 1200 : <NEWLINE> <INDENT> ans = 5 <NEWLINE> <DEDENT> elif n < 1400 : <NEWLINE> <INDENT> ans = 4 <NEWLINE> <DEDENT> elif n < 1600 : <NEWLINE> <INDENT> ans = 3 <NEWLINE> <DEDENT> elif n < 1800 : <NEWLINE> <INDENT> ans = 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = 1 <NEWLINE> <DEDENT> print ( str ( ans ) + <STRING> ) <NEWLINE> n = int ( input ( ) ) <NEWLINE> if n < 600 : <NEWLINE> <INDENT> ans = 8 <NEWLINE> <DEDENT> elif n < 800 : <NEWLINE> <INDENT> ans = 7 <NEWLINE> <DEDENT> elif n < 1000 : <NEWLINE> <INDENT> ans = 6 <NEWLINE> <DEDENT> elif n < 1200 : <NEWLINE> <INDENT> ans = 5 <NEWLINE> <DEDENT> elif n < 1400 : <NEWLINE> <INDENT> ans = 4 <NEWLINE> <DEDENT> elif n < 1600 : <NEWLINE> <INDENT> ans = 3 <NEWLINE> <DEDENT> elif n < 1800 : <NEWLINE> <INDENT> ans = 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
def resolve ( ) : <NEWLINE> <INDENT> X = int ( input ( ) ) <NEWLINE> if 400 <= x < 600 : <NEWLINE> <INDENT> print ( 8 ) ; return <NEWLINE> <DEDENT> elif 600 <= x < 800 : <NEWLINE> <INDENT> print ( 7 ) ; return <NEWLINE> <DEDENT> elif 800 <= x < 1000 : <NEWLINE> <INDENT> print ( 6 ) ; return <NEWLINE> <DEDENT> elif 1000 <= x < 1200 : <NEWLINE> <INDENT> print ( 5 ) ; return <NEWLINE> <DEDENT> elif 1200 <= x < 1400 : <NEWLINE> <INDENT> print ( 4 ) ; return <NEWLINE> <DEDENT> elif 1400 <= x < 1600 : <NEWLINE> <INDENT> print ( 3 ) ; return <NEWLINE> <DEDENT> elif 1600 <= x < 1800 : <NEWLINE> <INDENT> print ( 2 ) ; return <NEWLINE> <DEDENT> elif 1800 <= x < 2000 : <NEWLINE> <INDENT> print ( 1 ) ; return <NEWLINE> <DEDENT> <DEDENT> resolve ( ) <NEWLINE>
X = int ( input ( ) ) <NEWLINE> <NL> lst = [ [ 400 , 599 , 8 ] , [ 600 , 799 , 7 ] , [ 800 , 999 , 6 ] , [ 1000 , 1199 , 5 ] , [ 1200 , 1399 , 4 ] , [ 1400 , 1599 , 3 ] , [ 1600 , 1799 , 2 ] , [ 1800 , 1999 , 1 ] ] <NEWLINE> <NL> def Kyu ( X ) : <NEWLINE> <NL> <INDENT> for i in lst : <NEWLINE> <INDENT> if i [ 0 ] <= X <= i [ 1 ] : <NEWLINE> <INDENT> result = i [ 2 ] <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( result ) <NEWLINE>
X = input ( ) <NEWLINE> <NL> if 400 <= X <= 599 : <NEWLINE> <INDENT> print ( 8 ) <NEWLINE> <DEDENT> if 600 <= X <= 799 : <NEWLINE> <INDENT> print ( 7 ) <NEWLINE> <DEDENT> if 800 <= X <= 999 : <NEWLINE> <INDENT> print ( 6 ) <NEWLINE> <DEDENT> if 1000 <= X <= 1199 : <NEWLINE> <INDENT> print ( 5 ) <NEWLINE> <DEDENT> if 1200 <= X <= 1399 : <NEWLINE> <INDENT> print ( 4 ) <NEWLINE> <DEDENT> if 1400 <= X <= 1599 : <NEWLINE> <INDENT> print ( 3 ) <NEWLINE> <DEDENT> if 1600 <= X <= 1799 : <NEWLINE> <INDENT> print ( 2 ) <NEWLINE> <DEDENT> if 1800 <= X <= 1999 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT>
X = int ( input ( ) ) <NEWLINE> for key , value in enumerate ( rate_sec ) : <NEWLINE> <INDENT> if X < value : <NEWLINE> <INDENT> print ( 8 - key ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT>
X = int ( input ( ) ) <NEWLINE> <NL> if X >= 400 amd x <= 599 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif X >= 600 amd x <= 799 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif X >= 800 amd x <= 999 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif X >= 1000 amd x <= 1199 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif X >= 1200 amd x <= 1399 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif X >= 1400 amd x <= 1599 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif X >= 1600 amd x <= 1799 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif X >= 1800 amd x <= 1999 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> A = sorted ( A , reverse = True ) <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> print ( A [ i ] ) <NEWLINE> ans += A [ i ] <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
x = int ( input ( ) ) <NEWLINE> <NL> if 400 <= x and x <= 599 : <NEWLINE> <INDENT> print ( 8 ) <NEWLINE> <DEDENT> elif : <NEWLINE> <INDENT> 600 <= x and x <= 799 : <NEWLINE> print ( 7 ) <NEWLINE> <DEDENT> elif : <NEWLINE> <INDENT> 800 <= x and x <= 999 : <NEWLINE> print ( 6 ) <NEWLINE> <DEDENT> elif : <NEWLINE> <INDENT> 1000 <= x and x <= 1199 : <NEWLINE> print ( 5 ) <NEWLINE> <DEDENT> elif : <NEWLINE> <INDENT> 1200 <= x and x <= 1399 : <NEWLINE> print ( 4 ) <NEWLINE> <DEDENT> elif : <NEWLINE> <INDENT> 1400 <= x and x <= 1599 : <NEWLINE> print ( 3 ) <NEWLINE> <DEDENT> elif : <NEWLINE> <INDENT> 1600 <= x and x <= 1799 : <NEWLINE> print ( 2 ) <NEWLINE> <DEDENT> elif : <NEWLINE> <INDENT> 1800 <= x and x <= 1999 : <NEWLINE> print ( 1 ) <NEWLINE> <DEDENT>
X = input ( ) <NEWLINE> if X >= 400 and X <= 599 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> if X >= 600 and X <= 799 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> if X >= 800 and X <= 999 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> if X >= 1000 and X <= 1199 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> if X >= 1200 and X <= 1399 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> if X >= 1400 and X <= 1599 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> if X >= 1600 and X <= 1799 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> if X >= 1800 and X <= 1999 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
x = input ( int ( ) ) <NEWLINE> for i in range ( 2 , 10 ) : <NEWLINE> <INDENT> if 200 * i <= x < 200 * ( i + 1 ) - 1 : <NEWLINE> <INDENT> pprint ( 10 - i ) <NEWLINE> <DEDENT> <DEDENT>
x = int ( input ( ) ) <NEWLINE> <NL> if 400 <= x and x <= 599 : <NEWLINE> <INDENT> return 8 <NEWLINE> <DEDENT> elif 600 <= x and x <= 799 : <NEWLINE> <INDENT> return 7 <NEWLINE> <DEDENT> elif 800 <= x and x <= 999 : <NEWLINE> <INDENT> return 6 <NEWLINE> <DEDENT> elif 1000 <= x and x <= 1199 : <NEWLINE> <INDENT> return 5 <NEWLINE> <DEDENT> elif 1200 <= x and x <= 1399 : <NEWLINE> <INDENT> return 4 <NEWLINE> <DEDENT> elif 1400 <= x and x <= 1599 : <NEWLINE> <INDENT> return 3 <NEWLINE> <DEDENT> elif 1600 <= x and x <= 1799 : <NEWLINE> <INDENT> return 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT>
X = int ( input ( ) ) <NEWLINE> <NL> if 400 <= X < 600 : <NEWLINE> <INDENT> print ( 8 ) <NEWLINE> <DEDENT> elif 600 <= x < 800 : <NEWLINE> <INDENT> print ( 7 ) <NEWLINE> <DEDENT> elif 800 <= x < 1000 : <NEWLINE> <INDENT> print ( 6 ) <NEWLINE> <DEDENT> elif 1000 <= x < 1200 : <NEWLINE> <INDENT> print ( 5 ) <NEWLINE> <DEDENT> elif 1200 <= x < 1400 : <NEWLINE> <INDENT> print ( 4 ) <NEWLINE> <DEDENT> elif 1400 <= x < 1600 : <NEWLINE> <INDENT> print ( 3 ) <NEWLINE> <DEDENT> elif 1600 <= x < 1800 : <NEWLINE> <INDENT> print ( 2 ) <NEWLINE> <DEDENT> elif 1800 <= x < 2000 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT>
X = int ( input ( ) ) <NEWLINE> <NL> if x < 400 : <NEWLINE> <INDENT> print ( 8 ) <NEWLINE> <DEDENT> elif 400 <= X <= 599 : <NEWLINE> <INDENT> print ( 8 ) <NEWLINE> <DEDENT> elif 600 <= X <= 799 : <NEWLINE> <INDENT> print ( 7 ) <NEWLINE> <DEDENT> elif 800 <= X <= 999 : <NEWLINE> <INDENT> prnit ( 6 ) <NEWLINE> <DEDENT> elif 1000 <= X <= 1199 : <NEWLINE> <INDENT> print ( 5 ) <NEWLINE> <DEDENT> elif 1200 <= X <= 1399 : <NEWLINE> <INDENT> print ( 4 ) <NEWLINE> <DEDENT> elif 1400 <= X <= 1599 : <NEWLINE> <INDENT> print ( 3 ) <NEWLINE> <DEDENT> elif 1600 <= X <= 1799 : <NEWLINE> <INDENT> print ( 2 ) <NEWLINE> <DEDENT> elif 1800 <= X <= 1999 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT>
1 print ( 10 - int ( input ( ) ) // 200 ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> if n >= 1800 : print ( 1 ) <NEWLINE> elif n >= 1600 : print ( 2 ) <NEWLINE> elif n >= 1400 : print ( 3 ) <NEWLINE> elif n >= 1200 : print ( 4 ) <NEWLINE> elif n >= 1000 : print ( 5 ) <NEWLINE> elif n >= 800 : print ( 6 ) <NEWLINE> elif n >= 600 : print ( 7 ) <NEWLINE> elif n >= 400 : : print ( 8 ) <NEWLINE>
x = input ( ) <NEWLINE> if x = < 599 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif x = < 799 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif x = < 999 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif x = < 1199 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif x = < 1399 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif x = < 1599 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif x = < 1799 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b , c = input1 <NEWLINE> k = int ( input ( ) ) <NEWLINE> <NL> for i in range ( k ) : <NEWLINE> <INDENT> if a >= b : <NEWLINE> <INDENT> b *= 2 <NEWLINE> <DEDENT> elif b >= c : <NEWLINE> <INDENT> c *= 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> c *= 2 <NEWLINE> <NL> <DEDENT> <DEDENT> if a < b < c : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> red , green , blue = map ( int , input ( ) . split ( ) ) <NEWLINE> K = int ( input ( ) ) <NEWLINE> <NL> while ( K > 0 ) : <NEWLINE> <INDENT> if green <= red : <NEWLINE> <INDENT> green *= 2 <NEWLINE> K -= 1 <NEWLINE> continue <NEWLINE> <DEDENT> if blue <= green : <NEWLINE> <INDENT> blue *= 2 <NEWLINE> K -= 1 <NEWLINE> continue <NEWLINE> <DEDENT> if judge ( red , green , blue ) : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> if judge ( red , green , blue ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> k = int ( input ( ) ) <NEWLINE> while True : <NEWLINE> <INDENT> if b <= a : <NEWLINE> <INDENT> b = b * 2 <NEWLINE> k += - 1 <NEWLINE> if k == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( 1 ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> while True : <NEWLINE> <INDENT> if c <= b : <NEWLINE> <INDENT> c = c * 2 <NEWLINE> k += - 1 <NEWLINE> if k == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( 1 ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> d = int ( input ( ) ) <NEWLINE> count = 0 <NEWLINE> while True : <NEWLINE> <INDENT> if a < b : <NEWLINE> <INDENT> if b < c : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> c *= 2 <NEWLINE> count += 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> b *= 2 <NEWLINE> count += 1 <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> if count <= k else <STRING> ) <NEWLINE>
R , G , B , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <NL> <NL> for _ in range ( K ) : <NEWLINE> <INDENT> if R < G : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> G *= 2 <NEWLINE> continue <NEWLINE> <NL> <DEDENT> if G < B : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> B *= 2 <NEWLINE> continue <NEWLINE> <NL> <DEDENT> <DEDENT> if R < G < B : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = int ( input ( ) ) <NEWLINE> for i in b : <NEWLINE> <INDENT> if list [ 0 ] >= list [ 1 ] : <NEWLINE> <INDENT> list [ 1 ] = list [ 1 ] * 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if list [ 1 ] >= list [ 2 ] : <NEWLINE> <INDENT> list [ 2 ] = list [ 2 ] * 2 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if list [ 0 ] < list [ 1 ] < list [ 2 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> n = int ( input ( ) ) <NEWLINE> <NL> k = n <NEWLINE> <NL> if a < b < c : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <NL> <DEDENT> if a < b and b >= c : <NEWLINE> <INDENT> while b >= c and k >= 1 : <NEWLINE> <INDENT> c = 2 * c <NEWLINE> k -= 1 <NEWLINE> if b >= c and k == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> if b < c and k >= 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if a >= b : <NEWLINE> <INDENT> while a >= b and k >= 1 : <NEWLINE> <INDENT> b = 2 * b <NEWLINE> k -= 1 <NEWLINE> if a >= b and k == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> if a < b and b >= c and k == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> if a < b < c : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> if a < b and b >= c and k >= 1 : <NEWLINE> <INDENT> while b >= c and k >= 1 : <NEWLINE> <INDENT> c = 2 * c <NEWLINE> k -= 1 <NEWLINE> if b >= c and k == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> if b < c and k >= 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT>
A , B , C = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> K = input ( ) <NEWLINE> <NL> while ( A > B ) : <NEWLINE> <INDENT> K -= 1 <NEWLINE> if K == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> B = B * 2 <NEWLINE> <NL> <DEDENT> while ( B > C ) : <NEWLINE> <INDENT> C = C * 2 <NEWLINE> if K == 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> K -= 1 <NEWLINE> if K == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT>
[ a , b , c ] = [ int ( x ) for x in input ( ) . split ( <STRING> ) ] <NEWLINE> k = int ( input ( ) ) <NEWLINE> a_b_flg = False if a >= b else True <NEWLINE> b_c_flg = False if b >= c else True <NEWLINE> <NL> for kdx in range ( 0 , k ) : <NEWLINE> <INDENT> if not a_b_flg : <NEWLINE> <INDENT> b = b * 2 <NEWLINE> <DEDENT> elif not b_c_flg : <NEWLINE> <INDENT> c = c * 2 <NEWLINE> <DEDENT> a_b_flg = False if a >= b else True <NEWLINE> b_c_flg = False if b >= c else True <NEWLINE> if a_b_flgw and b_c_flg : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if not ( a_b_flgw and b_c_flg ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> k = int ( input ( ) ) <NEWLINE> <NL> while k > 0 : <NEWLINE> <INDENT> if a >= b : <NEWLINE> <INDENT> b *= 2 <NEWLINE> k -= 1 <NEWLINE> <DEDENT> else <NEWLINE> <INDENT> c *= 2 <NEWLINE> k -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if b > a and c > b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
A , B , C = int ( input ( ) . split ( ) ) <NEWLINE> print ( A ) <NEWLINE>
a , b , c = map ( int , input ( ) ) <NEWLINE> k = int ( input ( ) ) <NEWLINE> <NL> n = 0 <NEWLINE> while b <= a : <NEWLINE> <INDENT> b = b * 2 <NEWLINE> n += 1 <NEWLINE> <DEDENT> while c <= b : <NEWLINE> <INDENT> c = c * 2 <NEWLINE> n += 1 <NEWLINE> <DEDENT> if n <= k : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
A , B , C = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> for _ in range ( K ) : <NEWLINE> <INDENT> if A >= B : <NEWLINE> <INDENT> B *= 2 <NEWLINE> <DEDENT> elif B >= C : <NEWLINE> <INDENT> C *= 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> C *= 2 <NEWLINE> <NL> <DEDENT> <DEDENT> if ( B > A ) and ( C > B ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> k = int ( input ( ) ) <NEWLINE> count = 0 <NEWLINE> <NL> while a [ 1 ] <= a [ 0 ] : <NEWLINE> <INDENT> a [ 1 ] = a [ 1 ] * 2 <NEWLINE> count += 1 <NEWLINE> <DEDENT> while a [ 2 ] <= a [ 1 ] : <NEWLINE> <INDENT> a [ 2 ] = a [ 2 ] * 2 <NEWLINE> count += 1 <NEWLINE> <NL> <DEDENT> if count > k : <NEWLINE> <INDENT> print ( no ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( yes ) <NEWLINE> <DEDENT>
while B <= A : <NEWLINE> <INDENT> B = B * 2 <NEWLINE> N = N + 1 <NEWLINE> <NL> <DEDENT> while C <= B : <NEWLINE> <INDENT> C = C * 2 <NEWLINE> N = N + 1 <NEWLINE> <NL> <DEDENT> if K >= N : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
A = int ( input ( ) ) <NEWLINE> B = int ( input ( ) ) <NEWLINE> C = int ( input ( ) ) <NEWLINE> K = int ( input ( ) ) <NEWLINE> j = 0 <NEWLINE> if A >= ( 2 ** K ) * B : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> while A >= ( 2 ** j ) * B : <NEWLINE> <INDENT> j += 1 <NEWLINE> <DEDENT> if ( 2 ** j ) * B >= ( 2 ** ( K - j ) ) * C : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> k = int ( input ( ) ) <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> if a > b : <NEWLINE> <INDENT> b = b * 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if b > c : <NEWLINE> <INDENT> c = c * 2 <NEWLINE> <DEDENT> else : <NEWLINE> <NL> <DEDENT> <DEDENT> if a < b and b < c : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b , c = int ( input ( ) ) <NEWLINE> <NL> <NL> k = int ( input ( ) ) <NEWLINE> <NL> ans = <STRING> <NEWLINE> for i in range ( k + 1 ) : <NEWLINE> <INDENT> if a < b < c : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if a >= b : <NEWLINE> <INDENT> b *= 2 <NEWLINE> <DEDENT> elif b >= c : <NEWLINE> <INDENT> c *= 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> c *= 2 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> print ( a ) <NEWLINE>
a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> k = int ( input ( ) ) <NEWLINE> <NL> if a < b and b < c : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> while k == 0 : <NEWLINE> <INDENT> if a >= b : <NEWLINE> <INDENT> b *= 2 <NEWLINE> k -= 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> b >= c : <NEWLINE> c *= 2 <NEWLINE> k -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if a < b and b < c : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT>
a , b , c = map ( input ( ) . split ( ) ) <NEWLINE> num = int ( input ( ) ) <NEWLINE> cot = 0 <NEWLINE> for x in range ( num ) : <NEWLINE> <INDENT> if a >= b and c >= a : <NEWLINE> <INDENT> b = b * 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> c = c * 2 <NEWLINE> <DEDENT> <DEDENT> if b > a and c > b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> points = [ ] <NEWLINE> for i in range ( K , N + 1 ) : <NEWLINE> <INDENT> point = 1 <NEWLINE> for k in range ( K ) : <NEWLINE> <INDENT> point *= A [ i - k - 1 ] <NEWLINE> <DEDENT> points . append ( point ) <NEWLINE> if i > K : <NEWLINE> <INDENT> if points [ i - K ] > points [ i - 1 - K ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT>
a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> k = int ( input ( ) ) <NEWLINE> count = 0 <NEWLINE> while a >= b : <NEWLINE> <INDENT> count += 1 <NEWLINE> b *= 2 <NEWLINE> <DEDENT> while b >= c : <NEWLINE> <INDENT> count += 1 <NEWLINE> c *= 2 <NEWLINE> <DEDENT> return ( [ <STRING> , <STRING> ] [ count <= k ] ) <NEWLINE>
import sys <NEWLINE> import math <NEWLINE> import fractions <NEWLINE> from collections import defaultdict <NEWLINE> stdin = sys . stdin <NEWLINE> <NL> ns = lambda : stdin . readline ( ) . rstrip ( ) <NEWLINE> ni = lambda : int ( stdin . readline ( ) . rstrip ( ) ) <NEWLINE> nm = lambda : map ( int , stdin . readline ( ) . split ( ) ) <NEWLINE> nl = lambda : list ( map ( int , stdin . readline ( ) . split ( ) ) ) <NEWLINE> <NL> A , B , C = nm ( ) <NEWLINE> K = int ( input ( ) ) <NEWLINE> <NL> count = 0 <NEWLINE> while ( B < A ) : <NEWLINE> <INDENT> B *= 2 <NEWLINE> count += 1 <NEWLINE> <DEDENT> while ( C < B ) : <NEWLINE> <INDENT> C *= 2 <NEWLINE> count += 1 <NEWLINE> <NL> <DEDENT> print ( <STRING> if K < c else <STRING> ) <NEWLINE> <NL> <NL> <NL> <NL>
a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> k = int ( input ( ) ) <NEWLINE> <NL> cnt = 0 <NEWLINE> <NL> while a >= b : <NEWLINE> <INDENT> b *= 2 <NEWLINE> cnt += 1 <NEWLINE> <NL> while b >= c : <NEWLINE> <INDENT> c *= 2 <NEWLINE> cnt += 1 <NEWLINE> <NL> if cnt <= k : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT>
<NL> def Msol_B ( ) : <NEWLINE> <INDENT> a , b , c = np . array ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> K = int ( input ( ) ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> import math <NEWLINE> <NL> if a > b : <NEWLINE> <INDENT> b_a = abs ( math . log2 ( b / a ) ) + 1 <NEWLINE> <COMMENT> <NL> b *= math . pow ( 2 , math . floor ( b_a ) ) <NEWLINE> if b > c : <NEWLINE> <INDENT> c_b = abs ( math . log2 ( c / b ) ) + 1 <NEWLINE> if math . floor ( b_a ) + math . floor ( c_b ) <= K : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <NL> <NL> <NL> <DEDENT> <DEDENT> Msol_B ( ) <NEWLINE>
a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> k = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> <NL> for i in range ( k ) : <NEWLINE> <INDENT> if a < b * ( 2 ** i ) < c * ( 2 ** ( k - i ) ) : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += 0 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( Yes if ans >= 1 else No ) <NEWLINE>
a , b , c = list ( map ( int , input ( ) . split ) ) <NEWLINE> k = int ( input ( ) ) <NEWLINE> while k != 0 : <NEWLINE> <INDENT> if b < a : <NEWLINE> <INDENT> b *= 2 <NEWLINE> <DEDENT> elif c < b : <NEWLINE> <INDENT> c *= 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> k -= 1 <NEWLINE> <DEDENT> if ( b > a ) and ( c > b ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> k = int ( input ( ) ) <NEWLINE> <NL> for _ in range ( k ) : <NEWLINE> <INDENT> if b = < a : <NEWLINE> <INDENT> b *= 2 <NEWLINE> <DEDENT> elif c = < b : <NEWLINE> <INDENT> c *= 2 <NEWLINE> <NL> <DEDENT> <DEDENT> if a < b and b < c : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> k = int ( input ( ) ) <NEWLINE> <NL> cnt = 0 <NEWLINE> while a > b : <NEWLINE> <INDENT> b *= 2 <NEWLINE> cnt += 1 <NEWLINE> <NL> <DEDENT> while b > c : <NEWLINE> <INDENT> c * = 2 <NEWLINE> cnt += 1 <NEWLINE> <NL> <DEDENT> if cnt <= k : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> k = int ( input ( ) ) <NEWLINE> <NL> while k > 0 : <NEWLINE> <INDENT> if a > b : <NEWLINE> <INDENT> b *= 2 <NEWLINE> k -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> while k > 0 : <NEWLINE> <INDENT> if b > c : <NEWLINE> <INDENT> c *= 2 <NEWLINE> k -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if a < b and b < c : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
<INDENT> A , B , C = map ( int , input ( ) . split ( ) ) <NEWLINE> <DEDENT> K = int ( input ( ) ) <NEWLINE> a = K <NEWLINE> while A < B : <NEWLINE> <INDENT> B *= 2 <NEWLINE> a -= 1 <NEWLINE> <NL> <DEDENT> while B < C : <NEWLINE> <INDENT> C *= 2 <NEWLINE> a -= 1 <NEWLINE> <NL> <DEDENT> if a >= 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
( b1 , g1 , r1 ) = input ( ) . split ( ) <NEWLINE> ( b , g , r ) = ( int ( b1 ) , int ( g1 ) , int ( r1 ) ) <NEWLINE> k = int ( input ( ) ) <NEWLINE> flg = 0 <NEWLINE> for i in range ( K ) : <NEWLINE> <INDENT> if ( b > g > r ) : <NEWLINE> <INDENT> flg = 1 <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if not g > r : <NEWLINE> <INDENT> g *= 2 <NEWLINE> <DEDENT> elif not b > b : <NEWLINE> <INDENT> b *= 2 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if flg == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <NL> <NL> <DEDENT>
a , b , c = map ( int , input ( ) ) <NEWLINE> k = int ( input ( ) ) <NEWLINE> for i in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> if a >= b >= c or a >= c >= b : <NEWLINE> <INDENT> c = c * 2 <NEWLINE> <DEDENT> elif b >= a >= c or b >= c >= a : <NEWLINE> <INDENT> c = c * 2 <NEWLINE> <DEDENT> elif c >= b > a : <NEWLINE> <INDENT> c = c * 2 <NEWLINE> <DEDENT> elif c > b == a : <NEWLINE> <INDENT> b = b * 2 <NEWLINE> <DEDENT> elif c > a >= b : <NEWLINE> <INDENT> b = b * 2 <NEWLINE> <DEDENT> <DEDENT> if c > b > a : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b , c = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> k = int ( input ( ) ) <NEWLINE> <NL> ans = False <NEWLINE> <NL> for i in range ( k ) : <NEWLINE> <INDENT> if c <= b : <NEWLINE> <INDENT> c *= 2 <NEWLINE> elif b <= a : <NEWLINE> b *= 2 <NEWLINE> else : <NEWLINE> ans = True <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if ans : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = list ( map ( int , input ( ) ) ) <NEWLINE> k = int ( input ( ) ) <NEWLINE> <NL> for i in range ( k ) : <NEWLINE> <INDENT> if N [ 1 ] <= N [ 0 ] : <NEWLINE> <INDENT> N [ 1 ] = N [ 1 ] * 2 <NEWLINE> <DEDENT> elif N [ 2 ] <= N [ 0 ] : <NEWLINE> <INDENT> N [ 2 ] = N [ 2 ] * 2 <NEWLINE> <NL> <DEDENT> <DEDENT> if N [ 1 ] >= N [ 0 ] and N [ 2 ] >= N [ 0 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
li = int ( input ( ) . split ( ) ) <NEWLINE> a = int ( input ( ) ) <NEWLINE> magic = 0 <NEWLINE> for i in range ( 0 , 3 ) : <NEWLINE> <INDENT> if li [ 0 ] >= li [ 1 ] : <NEWLINE> <INDENT> li [ 1 ] = li [ 1 ] * 2 <NEWLINE> magic = magic + 1 <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( 0 , 3 ) : <NEWLINE> <INDENT> if li [ 1 ] >= li [ 2 ] : <NEWLINE> <INDENT> li [ 2 ] = li [ 2 ] * 2 <NEWLINE> magic = magic + 1 <NEWLINE> <DEDENT> <DEDENT> if a >= magic : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
abc = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a , b , c = abc [ 0 ] , abc [ 1 ] , abc [ 2 ] <NEWLINE> k = int ( input ( ) ) <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> if a < b < c : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> elif b < a < c : <NEWLINE> <INDENT> b *= 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> c *= 2 : <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in range ( n - k ) : <NEWLINE> <INDENT> if a [ i + k ] > a [ i ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
A , B , C = int ( input ( ) ) , int ( input ( ) ) , int ( input ( ) ) <NEWLINE> K = int ( input ( ) ) <NEWLINE> for _ in range ( K ) : <NEWLINE> <INDENT> if A >= B : <NEWLINE> <INDENT> B = 2 * B <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> C = 2 * C <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if C > B > A : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
A , B , C = map ( int , input ( ) ) <NEWLINE> K = int ( input ( ) ) <NEWLINE> if A > ( B + C ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b , c = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> k = int ( input ( ) ) <NEWLINE> f = False <NEWLINE> for conb in list ( itertools . combinations_with_replacement ( [ 0 , 1 , 2 ] , k ) ) : <NEWLINE> <INDENT> a_i = conb . count ( 0 ) <NEWLINE> b_i = conb . count ( 1 ) <NEWLINE> c_i = conb . count ( 2 ) <NEWLINE> <NL> if ( a * ( 2 ** a_i ) < b * ( 2 ** b_i ) ) and ( b * ( 2 ** b_i ) < c * ( 2 ** c_i ) ) : <NEWLINE> <INDENT> f = True <NEWLINE> <NL> <DEDENT> <DEDENT> if f : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
cnt = 0 <NEWLINE> while red >= green : <NEWLINE> <INDENT> green *= 2 <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> while green >= blue : <NEWLINE> <INDENT> blue *= 2 <NEWLINE> cnt += 1 <NEWLINE> <NL> <DEDENT> if cnt <= k : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b , c , k = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = 0 <NEWLINE> <NL> while ( 1 ) : <NEWLINE> <INDENT> if ( b <= a ) : <NEWLINE> <INDENT> b = b * 2 <NEWLINE> ans += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> while ( 1 ) : <NEWLINE> <INDENT> if ( c <= b ) : <NEWLINE> <INDENT> c = c * 2 <NEWLINE> ans += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> if ( ans > k ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> k = int ( input ( ) ) <NEWLINE> <NL> i = 0 <NEWLINE> while a >= b : <NEWLINE> <INDENT> a *= 2 <NEWLINE> i += 1 <NEWLINE> <DEDENT> while b >= c : <NEWLINE> <INDENT> b *= 2 <NEWLINE> i += 1 <NEWLINE> <DEDENT> print ( <STRING> if i <= k else <STRING> ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> k = int ( input ( ) ) <NEWLINE> <NL> whle k > 0 : <NEWLINE> <INDENT> if a >= b : <NEWLINE> <INDENT> b *= 2 <NEWLINE> <DEDENT> elif b >= c : <NEWLINE> <INDENT> c *= 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( 0 ) <NEWLINE> <DEDENT> k -= 1 <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE>
a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> k = int ( input ( ) ) <NEWLINE> B = b <NEWLINE> for n in range ( k ) : <NEWLINE> <INDENT> if a > b : <NEWLINE> <INDENT> b = b * 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> e = b / B <NEWLINE> f = e // 2 <NEWLINE> for m in range ( k - f ) : <NEWLINE> <INDENT> if b > c : <NEWLINE> <INDENT> c = c * 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> if b > a and c > b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
7 2 5 <NEWLINE> 3 <NEWLINE>
a = list ( map , input ( ) . split ( ) ) <NEWLINE> k = int ( input ( ) ) <NEWLINE> while a [ 0 ] >= a [ 1 ] : <NEWLINE> <INDENT> k -= 1 <NEWLINE> a [ 1 ] *= 2 <NEWLINE> <DEDENT> while a [ 1 ] >= a [ 2 ] : <NEWLINE> <INDENT> k -= 1 <NEWLINE> a [ 2 ] *= 2 <NEWLINE> <DEDENT> if k >= 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
from sys import stdin <NEWLINE> nii = lambda : map ( int , stdin . readline ( ) . split ( ) ) <NEWLINE> lnii = lambda : list ( map ( int , stdin . readline ( ) . split ( ) ) ) <NEWLINE> <NL> n , k = nii ( ) <NEWLINE> a = lnii ( ) <NEWLINE> <NL> for i in range ( k , n ) : <NEWLINE> <INDENT> old = a [ i - k ] <NEWLINE> new = a [ i ] <NEWLINE> if old < p : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in range ( K + 1 , N + 1 ) : <NEWLINE> <INDENT> print ( <STRING> ) if A [ i - K ] < A [ i ] else print ( <STRING> ) <NEWLINE> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ int ( input ( ) ) for _ in range ( N ) ] <NEWLINE> <NL> for i in range ( K ) : <NEWLINE> <INDENT> if A [ i ] < A [ i + 3 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> from math import ceil , floor , sqrt , sin , cos , pi <NEWLINE> from itertools import accumulate , permutations , combinations <NEWLINE> from fractions import gcd <COMMENT> <NEWLINE> from collections import deque , Counter <NEWLINE> from operator import itemgetter <NEWLINE> from heapq import heappop , heappush <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> def lcm ( x , y ) : return ( ( x * y ) // gcd ( x , y ) ) <COMMENT> <NEWLINE> <COMMENT> <NL> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> rui = [ 1 ] <NEWLINE> t = 1 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> t *= a [ i ] <NEWLINE> if i < k : <NEWLINE> <INDENT> rui += [ t ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> t = t // a [ i - k ] <NEWLINE> rui += [ t ] <NEWLINE> if rui [ i + 1 ] > rui [ i ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT>
n = list ( map ( int , input ( ) . strip ( ) . split ( ) ) ) <NEWLINE> m = list ( map ( int , input ( ) . strip ( ) . split ( ) ) ) <NEWLINE> for i in range ( n [ 0 ] - n [ 1 ] ) : <NEWLINE> <INDENT> if ( m [ i + k ] > m [ i ] ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> scores = input ( ) . split ( ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> scores [ i ] = int ( scores [ i ] ) <NEWLINE> <DEDENT> new = K <NEWLINE> old = 0 <NEWLINE> for new < N : <NEWLINE> <INDENT> if scores [ new ] > scores [ old ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> new += 1 <NEWLINE> old += 1 <NEWLINE> <DEDENT>
from fractions import gcd <NEWLINE> from collections import Counter , deque , defaultdict <NEWLINE> from heapq import heappush , heappop , heappushpop , heapify , heapreplace , merge <NEWLINE> from bisect import bisect_left , bisect_right , bisect , insort_left , insort_right , insort <NEWLINE> from itertools import accumulate , product , permutations , combinations <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> cumprod = [ ] <NEWLINE> <NL> for i in range ( K , N ) : <NEWLINE> <INDENT> prev_score = 1 <NEWLINE> curr_score = 1 <NEWLINE> for j in range ( i - K , i + 1 ) : <NEWLINE> <INDENT> if j == i - K : <NEWLINE> <INDENT> prev_score *= A [ j ] <NEWLINE> <DEDENT> elif j == i : <NEWLINE> <INDENT> curr_score *= A [ j ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> prev_score *= A [ j ] <NEWLINE> curr_score *= A [ j ] <NEWLINE> <NL> <DEDENT> <DEDENT> if prev_score < curr_score : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n , k = int ( input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i in range ( n - k - 1 ) : <NEWLINE> <INDENT> ab = a [ i ] * a [ k - 1 + i ] <NEWLINE> aa = a [ i + 1 ] * a [ k + i ] <NEWLINE> if aa > ab : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <NL> <NL> <NL> <NL> <NL> <DEDENT> <DEDENT>
import sys , re , os <NEWLINE> from collections import deque , defaultdict , Counter <NEWLINE> from math import ceil , sqrt , hypot , factorial , pi , sin , cos , radians <NEWLINE> from itertools import permutations , combinations , product , accumulate <NEWLINE> from operator import itemgetter , mul <NEWLINE> from copy import deepcopy <NEWLINE> from string import ascii_lowercase , ascii_uppercase , digits <NEWLINE> from fractions import gcd <NEWLINE> from bisect import bisect , bisect_left , bisect_right <NEWLINE> <NL> def input ( ) : return sys . stdin . readline ( ) . strip ( ) <NEWLINE> def INT ( ) : return int ( input ( ) ) <NEWLINE> def MAP ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def S_MAP ( ) : return map ( str , input ( ) . split ( ) ) <NEWLINE> def LIST ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> def S_LIST ( ) : return list ( map ( str , input ( ) . split ( ) ) ) <NEWLINE> <NL> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> INF = float ( <STRING> ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> N , K = MAP ( ) <NEWLINE> A = LIST ( ) <NEWLINE> <NL> <COMMENT> <NL> <NL> B = [ ] <NEWLINE> tmp = 1 <NEWLINE> for a in A [ : K ] : <NEWLINE> <INDENT> tmp *= a <NEWLINE> <DEDENT> for i in range ( N - K ) : <NEWLINE> <INDENT> tmp2 = tmp / A [ i ] * A [ K + i ] <NEWLINE> if tmp < tmp2 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <COMMENT> <NL> <DEDENT> tmp = tmp2 <NEWLINE> <DEDENT>
n , k = map ( int , Input . split ( ) ) <NEWLINE> a = list ( map ( int , Input . split ( ) ) ) <NEWLINE> for i in range ( n - k ) : <NEWLINE> <INDENT> if a [ i ] < a [ i + k ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> lst_1 = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <COMMENT> <NL> lst_2 = [ ] <NEWLINE> for i in range ( n - k + 1 ) : <NEWLINE> <INDENT> temp = 1 <NEWLINE> temp = lst_1 [ i + k ] / lst_1 [ i ] <NEWLINE> lst_2 . append ( temp ) <NEWLINE> <DEDENT> print ( lst_2 ) <NEWLINE> for i in range ( len ( lst_2 ) - 1 ) : <NEWLINE> <INDENT> if lst_2 [ i ] < lst_2 [ i + 1 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : print ( <STRING> ) <NEWLINE> <DEDENT>
from sys import stdin , stdout <NEWLINE> from numba import njit <NEWLINE> @ njit <NEWLINE> def fn ( i ) : <NEWLINE> <INDENT> return pro [ i ] // ( pro [ i - k ] if i - k >= 0 else 1 ) <NEWLINE> <DEDENT> n , k = map ( int , stdin . readline ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , stdin . readline ( ) . split ( ) ) ) <NEWLINE> pro = [ a [ 0 ] ] <NEWLINE> for v in a [ 1 : ] : <NEWLINE> <INDENT> pro += [ pro [ - 1 ] * v ] <NEWLINE> <DEDENT> for i in range ( k , n ) : <NEWLINE> <COMMENT> <NL> <INDENT> if fn ( i ) > fn ( i - 1 ) : print ( <STRING> ) <NEWLINE> else : print ( <STRING> ) <NEWLINE> <DEDENT>
import math <NEWLINE> A , B , C = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> K = int ( input ( ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> i = math . floor ( A / ( B + 1 ) ) <NEWLINE> K -= i <NEWLINE> B = B * ( 2 ** i ) <NEWLINE> j = math . floor ( B / ( C + 1 ) ) <NEWLINE> K -= j <NEWLINE> C = C * ( 2 ** j ) <NEWLINE> if K >= 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
<COMMENT> <NL> n , k = input ( ) . split ( ) <NEWLINE> n = int ( n ) <NEWLINE> k = int ( k ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for j in range ( n ) : <NEWLINE> <INDENT> if l [ k + j ] > l [ j ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> if k + j == n - 1 : <NEWLINE> break <NEWLINE> <NL> <NL> <NL> <NL> <NL> <DEDENT> <DEDENT>
A , B , C = map ( int , input ( ) . split ( ) ) <NEWLINE> K = int ( input ( ) ) <NEWLINE> <NL> <NL> def combinations ( k ) : <NEWLINE> <INDENT> result = [ ] <NEWLINE> for a in range ( k + 1 ) : <NEWLINE> <INDENT> for b in range ( k + 1 ) : <NEWLINE> <INDENT> for c in range ( k + 1 ) : <NEWLINE> <INDENT> if a + b + c <= k : <NEWLINE> <INDENT> result . append ( [ a , b , c ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> return result <NEWLINE> <NL> <NL> <DEDENT> def magic ( A , B , C , K ) : <NEWLINE> <INDENT> if A < B < C : <NEWLINE> <INDENT> return True <NEWLINE> <NL> <DEDENT> for l in combinations ( K ) : <NEWLINE> <INDENT> a , b , c = A , B , C <NEWLINE> a_count , b_count , c_count = l <NEWLINE> if a_count > 0 : <NEWLINE> <INDENT> a *= 2 * a_count <NEWLINE> <DEDENT> if b_count > 0 : <NEWLINE> <INDENT> b *= 2 * b_count <NEWLINE> <DEDENT> if c_count > 0 : <NEWLINE> <INDENT> c *= 2 * c_count <NEWLINE> <NL> <DEDENT> if a < b < c : <NEWLINE> <INDENT> return True <NEWLINE> <NL> <DEDENT> <DEDENT> return False <NEWLINE> <NL> <NL> <DEDENT> if ( magic ( A , B , C , K ) ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> lis = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> if lis [ i ] < lis [ i + k ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i in range ( n - k + 1 ) : <NEWLINE> <INDENT> if a [ i ] < a [ i + k ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> answers = [ <STRING> if A [ i ] > A [ i - K ] else <STRING> for i in range ( K , N ) ] <NEWLINE> print ( <STRING> . join ( answers ) ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 8 ) <NEWLINE> def ii ( ) : return int ( sys . stdin . readline ( ) ) <NEWLINE> def mi ( ) : return map ( int , sys . stdin . readline ( ) . split ( ) ) <NEWLINE> def li ( ) : return list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) <NEWLINE> def li2 ( N ) : return [ list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) for i in range ( N ) ] <NEWLINE> def dp2 ( ini , i , j ) : return [ [ ini ] * i for i2 in range ( j ) ] <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> N = ii ( ) <NEWLINE> A = li ( ) <NEWLINE> <NL> yen = 1000 <NEWLINE> kabu = 0 <NEWLINE> <NL> for i in range ( 1 , N ) : <NEWLINE> <INDENT> if A [ i ] > A [ i - 1 ] : <NEWLINE> <INDENT> kabu = ( yen // A [ i - 1 ] ) <NEWLINE> yen = kabu * A [ i ] + ( yen - kabu * A [ i - 1 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( yen ) <NEWLINE>
<NL> n , k = [ int ( x ) for x in input ( ) . strip ( ) . split ( ) ] <NEWLINE> arr = [ int ( x ) for x in input ( ) . strip ( ) . split ( ) ] <NEWLINE> arr = [ math . log ( x ) for x in arr ] <NEWLINE> <NL> <NL> last = 0 <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> last += arr [ i ] <NEWLINE> <NL> <DEDENT> for i in range ( k , len ( arr ) ) : <NEWLINE> <INDENT> curr = ( last + arr [ i ] ) - arr [ i - k ] <NEWLINE> if curr > last : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> last = curr <NEWLINE> <NL> <DEDENT>
<COMMENT> <NL> import sys , <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> N , K = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i in range ( K , N ) : <NEWLINE> <INDENT> if A [ i ] > A [ i - K ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT>
N , K = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in range ( N - K ) : <NEWLINE> <INDENT> if A [ i ] < A [ i + K + 1 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
from operator import mul <NEWLINE> from functools import reduce <NEWLINE> <NL> n , k = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> r = [ 0 ] * ( n - k + 1 ) <NEWLINE> for i in range ( n - k + 1 ) : <NEWLINE> <INDENT> if a [ i + k ] > a [ i ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
N , K = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> A = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> <NL> for x in range ( K , N ) : <NEWLINE> <INDENT> if a [ x ] > a [ x - K ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in range ( K + 1 ) : <NEWLINE> <INDENT> if A [ i + K ] > A [ i ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
N , K = list ( map ( int , input ( ) . strip ( ) . split ( ) ) ) <NEWLINE> A = list ( map ( int , input ( ) . strip ( ) . split ( ) ) ) <NEWLINE> <NL> for n in range ( N - K ) : <NEWLINE> <INDENT> Tgt1 = A [ n ] <NEWLINE> Tgt2 = A [ K + n + 1 ] <NEWLINE> if Tgt1 < Tgt2 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in range ( k , n + 1 ) : <NEWLINE> <INDENT> if a [ i ] > a [ i - k ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> import numpy as np <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> <NL> AA = [ int ( a ) for a in input ( ) . split ( ) ] <NEWLINE> c = 0 <NEWLINE> updwn = [ None ] * ( n - 1 ) <NEWLINE> for a in AA : <NEWLINE> <INDENT> if c == 0 : <NEWLINE> <INDENT> c += 1 <NEWLINE> base = a <NEWLINE> continue <NEWLINE> <DEDENT> if a - base >= 0 : <NEWLINE> <INDENT> updwn [ c - 1 ] = True <NEWLINE> base = a <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> updwn [ c - 1 ] = False <NEWLINE> base = a <NEWLINE> <DEDENT> c += 1 <NEWLINE> <DEDENT> updwn += [ False , False ] <NEWLINE> base = False <NEWLINE> total = 1000 <NEWLINE> stock = 0 <NEWLINE> if n == 2 : <NEWLINE> <INDENT> if updwn [ 0 ] == True : <NEWLINE> <INDENT> total += ( total // AA [ 0 ] ) * ( AA [ 1 ] - AA [ 0 ] ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( n - 1 ) : <NEWLINE> <INDENT> if updwn [ i ] == True and base == False : <NEWLINE> <INDENT> tdcost = AA [ i ] <NEWLINE> stock = total // tdcost <NEWLINE> base_cost = tdcost <NEWLINE> <DEDENT> elif updwn [ i ] == True and updwn [ i + 1 ] == False : <NEWLINE> <INDENT> tdcost = AA [ i + 1 ] <NEWLINE> total += ( tdcost - base_cost ) * stock <NEWLINE> stock = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> base = updwn [ i ] <NEWLINE> <DEDENT> <DEDENT> print ( total ) <NEWLINE>
<COMMENT> <NL> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in range ( n - k ) : <NEWLINE> <INDENT> if a [ i ] < s [ i + 1 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a_li = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in range ( k , n ) : <NEWLINE> <INDENT> if a_li [ i - k ] < a_li [ i ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a_li = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in range ( k , n ) : <NEWLINE> <INDENT> if a_li [ i - k ] < a_li [ i ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> int main ( ) { <NEWLINE> <INDENT> int a , b , c , num , eq = 0 ; <NEWLINE> scanf ( <STRING> , & a , & b , & c ) ; <NEWLINE> scanf ( <STRING> , & num ) ; <NEWLINE> for ( int i = 0 ; i < num ; + + i ) { <NEWLINE> if ( a >= b & & c >= a ) <NEWLINE> <INDENT> b = b * 2 ; <NEWLINE> <NL> <DEDENT> else <NEWLINE> <INDENT> c = c * 2 ; <NEWLINE> <DEDENT> } <NEWLINE> if ( b > a & & c > b ) <NEWLINE> <INDENT> printf ( <STRING> ) ; <NEWLINE> <DEDENT> else <NEWLINE> <INDENT> printf ( <STRING> ) ; <NEWLINE> <NL> <DEDENT> // / printf ( <STRING> , a , b , c ) ; <NEWLINE> printf ( <STRING> ) ; <NEWLINE> <NL> return 0 ; <NEWLINE> <DEDENT> } <NEWLINE>
r , g , b = map ( int , input ( ) . split ( ) ) <NEWLINE> t = 0 <NEWLINE> while r >= g : g *= 2 ; t += 1 <NEWLINE> while g >= b : b *= 2 ; t += 1 <NEWLINE> print ( <STRING> if t > int ( input ( ) ) else <STRING> ) <NEWLINE>
from copy import deepcopy <NEWLINE> <NL> nk = input ( ) . split ( ) <NEWLINE> n = int ( nk [ 0 ] ) <NEWLINE> k = int ( nk [ 1 ] ) <NEWLINE> ajs = input ( ) . split ( ) <NEWLINE> ajs = np . array ( [ int ( aj ) for aj in ajs ] ) <NEWLINE> <NL> ak_current = ajs [ : k ] . cumprod ( ) [ - 1 ] <NEWLINE> <NL> for i in range ( k , n ) : <NEWLINE> <INDENT> ak_tmp = deepcopy ( ak_current ) <NEWLINE> ak_tmp = ak_tmp * ajs [ i ] / ajs [ i - k ] <NEWLINE> <NL> if ak_tmp > ak_current : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> ak_current = ak_tmp <NEWLINE> <DEDENT>
N = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> n = N [ 0 ] <NEWLINE> k = N [ 1 ] <NEWLINE> for i in range ( k + 1 ) : <NEWLINE> <INDENT> if A [ i ] < A [ k + i ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i in range ( k , n ) ; <NEWLINE> <INDENT> if a [ i ] > a [ i - k ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
<INDENT> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in range ( k , n ) : <NEWLINE> <INDENT> if a [ i - k ] < a [ i ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> m = 1000 <NEWLINE> k = 0 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> if A [ i ] <= m and A [ i ] == min ( A ) and i != n - 1 : <NEWLINE> <COMMENT> <NL> <INDENT> k = m // A [ i ] <NEWLINE> m = m - A [ i ] * k <NEWLINE> <DEDENT> elif A [ i ] < m and A [ i ] < max ( A [ i : : ] ) and i != n - 1 : <NEWLINE> <COMMENT> <NL> <INDENT> k = m // A [ i ] <NEWLINE> m = m - A [ i ] * k <NEWLINE> <DEDENT> elif 0 < k and A [ i ] == max ( A ) : <NEWLINE> <COMMENT> <NL> <INDENT> m = m + A [ i ] * k <NEWLINE> k = 0 <NEWLINE> <DEDENT> elif 0 < k and A [ i ] != min ( A [ i : : ] ) : <NEWLINE> <COMMENT> <NL> <INDENT> m = m + A [ i ] * k <NEWLINE> k = 0 <NEWLINE> <DEDENT> elif 0 < k and A [ i ] == max ( A [ i : : ] ) <NEWLINE> <COMMENT> <NL> <INDENT> m = m + A [ i ] * k <NEWLINE> k = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> pass <NEWLINE> <NL> <DEDENT> <DEDENT> print ( m ) <NEWLINE>
import itertools <NEWLINE> def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a_compact = [ ] <NEWLINE> sabun = [ ] <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> sabun . append ( a [ i ] - a [ i - 1 ] ) <NEWLINE> <DEDENT> for i , kabuka in enumerate ( a ) : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> a_compact . append ( kabuka ) <NEWLINE> <DEDENT> elif i == len ( a ) - 1 : <NEWLINE> <INDENT> if a [ - 2 ] != a [ - 1 ] : <NEWLINE> <INDENT> acom . append ( kabuka ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if sabun [ i - 1 ] != 0 : <NEWLINE> <INDENT> check = sabun [ i - 1 ] * sabun [ i ] <NEWLINE> if check <= 0 : <NEWLINE> <INDENT> a_compact . append ( kabuka ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> sabun_compact = [ ] <NEWLINE> <NL> for i in range ( 1 , len ( a_compact ) ) : <NEWLINE> <INDENT> sabun_compact . append ( a_compact [ i ] - a_compact [ i - 1 ] ) <NEWLINE> <DEDENT> money = 1000 <NEWLINE> kabu = 0 <NEWLINE> for i , s in enumerate ( sabun_compact ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <INDENT> if s > 0 : <NEWLINE> <INDENT> kabu = money // a_compact [ i ] <NEWLINE> money -= a_compact [ i ] * kabu <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> money += a_compact [ i ] * kabu <NEWLINE> kabu = 0 <NEWLINE> <DEDENT> <DEDENT> money += a_compact [ - 1 ] * kabu <NEWLINE> print ( money ) <NEWLINE> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N = int ( intput ( ) ) <NEWLINE> stocks = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> curr = 1000 <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> if stocks [ i ] < stocks [ i + 1 ] : <NEWLINE> <INDENT> cnt = curr // stocks [ i ] <NEWLINE> <DEDENT> curr += cnt * ( stocks [ i + 1 ] - stocks [ i ] ) <NEWLINE> <DEDENT> print ( curr ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in range ( n - 1 ) : <NEWLINE> <INDENT> if a [ i ] < a [ i + 1 ] : <NEWLINE> <INDENT> money += ( a [ i + 1 ] - a [ i ] ) * ( money // a [ i ] ) <NEWLINE> <DEDENT> <DEDENT> print ( money ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> money = 1000 <NEWLINE> stock = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> money += stock * a [ i ] <NEWLINE> stock = 0 <NEWLINE> <NL> if a [ i ] < a [ i + 1 ] : <NEWLINE> <INDENT> stock = money // a [ i ] <NEWLINE> money %= a [ i ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( money ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> money = 1000 <NEWLINE> cab = 0 <NEWLINE> lowprice = A [ 0 ] <NEWLINE> check = True <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> if ( lowprice > A [ i ] ) : <NEWLINE> <INDENT> lowprice = A [ i ] <NEWLINE> check = True <NEWLINE> <DEDENT> elif ( lowprice < A [ i ] and check == True ) : <NEWLINE> <INDENT> high_price = A [ i ] <NEWLINE> if ( i <= N - 1 ) : <NEWLINE> <INDENT> if ( high_price > A [ i + 1 ] ) : <NEWLINE> <INDENT> cab = money // lowprice <NEWLINE> money -= ( lowprice * cab ) <NEWLINE> money += ( high_price * cab ) <NEWLINE> cab = 0 <NEWLINE> check = False <NEWLINE> lowprice = high_price <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> cab = money // lowprice <NEWLINE> money -= ( lowprice * cab ) <NEWLINE> money += ( high_price * cab ) <NEWLINE> cab = 0 <NEWLINE> check = False <NEWLINE> lowprice = high_price <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> print ( money ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> money = 1000 <NEWLINE> stock = 0 <NEWLINE> <NL> for i in range ( N - 1 ) : <NEWLINE> <INDENT> if A [ i + 1 ] > a [ i ] : <NEWLINE> <INDENT> if money >= A [ i ] : <NEWLINE> <INDENT> n = money // A [ i ] <NEWLINE> stock += n <NEWLINE> money -= A [ i ] * n <NEWLINE> <DEDENT> <DEDENT> elif A [ i + 1 ] == A [ i ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if stock > 1 : <NEWLINE> <INDENT> money += stock * A [ i ] <NEWLINE> stock = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if stock > 0 : <NEWLINE> <INDENT> money += stock * A [ - 1 ] <NEWLINE> <NL> <DEDENT> print ( money ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> syoji = 1000 <NEWLINE> kabu = 0 <NEWLINE> kai = 0 <NEWLINE> uri = 0 <NEWLINE> if N == 1 : <NEWLINE> <INDENT> print ( syoji ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> sw = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if i < N - 1 and kabu == 0 and A [ i ] < A [ i + 1 ] : <NEWLINE> <INDENT> for j in range ( i + 1 , N ) : <NEWLINE> <INDENT> if sw == 1 and uri >= A [ j ] : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> elif A [ i ] < A [ j ] : <NEWLINE> <INDENT> uri = A [ j ] <NEWLINE> sw = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if sw == 1 : <NEWLINE> <INDENT> kabu = syoji // A [ i ] <NEWLINE> <INDENT> syoji = syoji - ( num - 1 ) * A [ i ] <NEWLINE> kai = A [ i ] <NEWLINE> sw = 0 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> elif kabu > 0 and A [ i ] == uri : <NEWLINE> <INDENT> syoji = syoji + kabu * A [ i ] <NEWLINE> kabu = 0 <NEWLINE> uri = 0 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> print ( syoji ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> money = 1000 <NEWLINE> stock = 0 <NEWLINE> if A [ 0 ] < A [ 1 ] : <NEWLINE> <INDENT> stock = int ( money / A [ 0 ] ) <NEWLINE> money = money - A [ i ] * stock <NEWLINE> <DEDENT> for i in range ( 1 , N - 1 ) : <NEWLINE> <INDENT> if A [ i - 1 ] < A [ i ] : <NEWLINE> <INDENT> money = money + A [ i ] * stock <NEWLINE> stock = 0 <NEWLINE> <DEDENT> if A [ i ] < A [ i + 1 ] : <NEWLINE> <INDENT> stock = int ( money / A [ i ] ) <NEWLINE> money = money - A [ i ] * stock <NEWLINE> <DEDENT> <DEDENT> money = money + A [ N - 1 ] * stock <NEWLINE> print ( money ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = [ 0 for i in range ( N - 1 ) ] <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> if A [ i ] < A [ i + 1 ] : <NEWLINE> <INDENT> B [ i ] = 1 <NEWLINE> <DEDENT> <DEDENT> B = [ 0 ] + B <NEWLINE> money = 1000 <NEWLINE> tmp = 0 <NEWLINE> up = [ ] <NEWLINE> down = [ ] <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> if B [ i ] == 0 and B [ i + 1 ] == 1 : <NEWLINE> <INDENT> up . append ( i ) <NEWLINE> <DEDENT> if B [ i ] == 1 and B [ i + 1 ] == 0 : <NEWLINE> <INDENT> down . append ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> if up : <NEWLINE> <INDENT> if down == [ ] : <NEWLINE> <INDENT> down . append ( N - 1 ) <NEWLINE> <DEDENT> if down != [ ] and down [ - 1 ] < up [ - 1 ] : <NEWLINE> <INDENT> down . append ( N - 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( len ( up ) ) : <NEWLINE> <INDENT> k = bisect . bisect_left ( down , up [ i ] ) <NEWLINE> print ( k ) <NEWLINE> money += ( A [ down [ k ] ] - A [ up [ i ] ] ) * ( money // A [ up [ i ] ] ) <NEWLINE> <DEDENT> print ( money ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> values = [ int ( s ) for s in input ( ) . split ( ) ] <NEWLINE> rest = 1000 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if rest >= 1000 : <NEWLINE> <INDENT> if values [ i ] >= values [ i + 1 ] : <NEWLINE> <INDENT> have = values [ i ] // rest <NEWLINE> rest = values [ i ] % rest <NEWLINE> <DEDENT> <DEDENT> elif value != 0 : <NEWLINE> <INDENT> rest += values [ i ] * have <NEWLINE> <DEDENT> <DEDENT> print ( rest ) <NEWLINE>
from sys import stdin <NEWLINE> N = int ( stdin . readline ( ) . rstrip ( ) ) <NEWLINE> A = [ int ( x ) for x in stdin . readline ( ) . rstrip ( ) . split ( ) ] <NEWLINE> <NL> money = 1000 <NEWLINE> stock = 0 <NEWLINE> if A [ 0 ] < A [ 1 ] : <NEWLINE> <INDENT> stock += ( money // A [ 0 ] ) <NEWLINE> money %= A [ 0 ] <NEWLINE> <NL> <DEDENT> tmp = A [ 0 ] <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> if tmp < A [ i ] : <NEWLINE> <INDENT> if i == N - 1 : <NEWLINE> <INDENT> money += ( stock * A [ i ] ) <NEWLINE> <DEDENT> if A [ i ] < A [ i + 1 ] : <NEWLINE> <INDENT> tmp = A [ i ] <NEWLINE> continue <NEWLINE> <DEDENT> money += ( stock * A [ i ] ) <NEWLINE> stock = 0 <NEWLINE> tmp = A [ i ] <NEWLINE> <DEDENT> elif tmp > A [ i ] : <NEWLINE> <INDENT> if i == N - 1 : <NEWLINE> <INDENT> money += ( stock * A [ i ] ) <NEWLINE> break <NEWLINE> <DEDENT> if A [ i ] > A [ i + 1 ] : <NEWLINE> <INDENT> tmp = A [ i ] <NEWLINE> continue <NEWLINE> <DEDENT> stock += ( money // A [ i ] ) <NEWLINE> money %= A [ i ] <NEWLINE> tmp = A [ i ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( max ( money , 1000 ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> I = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> num = 1000 <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> if I [ i ] < I [ i + 1 ] : <NEWLINE> <INDENT> p = num // I [ i ] ) <NEWLINE> num -= p * I [ i ] <NEWLINE> num += p * I [ i + 1 ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( num ) <NEWLINE>
days = int ( input ( ) ) <NEWLINE> vals = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> has = 1000 <NEWLINE> for i in range ( days - 1 ) <NEWLINE> <INDENT> if vals [ i ] <= vals [ i + 1 ] : <NEWLINE> <INDENT> can , has = divmod ( has , vals [ i ] ) <NEWLINE> has += can * ( vals [ i + 1 ] ) <NEWLINE> <DEDENT> <DEDENT> return has <NEWLINE> <NL>
N = int ( input ( ) ) <NEWLINE> <NL> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> money = 1000 <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> t = money + ( A [ i + 1 ] - A [ i ] ) * ( money // A [ i ] ) <NEWLINE> money = max ( money , t ) <NEWLINE> <NL> <DEDENT> print ( money ) <NEWLINE>
orz <NEWLINE>
a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> d = 1 <NEWLINE> kabu = 0 <NEWLINE> ans = 1000 <NEWLINE> while d <= n - 1 : <NEWLINE> <INDENT> if a [ d ] > a [ d - 1 ] : <NEWLINE> <INDENT> f = ans // a [ d - 1 ] <NEWLINE> kabu += f <NEWLINE> ans = ans - a [ d - 1 ] * f <NEWLINE> <DEDENT> if a [ d ] < a [ d - 1 ] : <NEWLINE> <INDENT> ans += kabu * a [ d - 1 ] <NEWLINE> kabu = 0 <NEWLINE> <DEDENT> d += 1 <NEWLINE> <DEDENT> ans += kabu * a [ n - 1 ] <NEWLINE> print ( ans ) <NEWLINE> <NL>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> mon = 1000 <NEWLINE> kai = 0 <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> if a [ i ] > a [ i + 1 ] and a [ i + 1 ] > a [ i + 2 ] : <NEWLINE> <INDENT> mon += kai * a [ i ] <NEWLINE> kai = 0 <NEWLINE> <DEDENT> elif a [ i ] < a [ i + 1 ] and a [ i + 1 ] < a [ i + 2 ] : <NEWLINE> <INDENT> kai = int ( mon / a [ i ] ) <NEWLINE> mon -= kai * a [ i ] <NEWLINE> <NL> <DEDENT> <DEDENT> mon += kai * a [ n - 1 ] <NEWLINE> <NL> print ( mon ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> dp = [ 0 ] * N <NEWLINE> dp [ 0 ] = 1000 <NEWLINE> <NL> for i in range ( 1 , N ) : <NEWLINE> <INDENT> dp [ i ] = dp [ i - 1 ] <NEWLINE> for j in range ( i - 1 ) : <NEWLINE> <INDENT> V = dp [ j ] // A [ j ] <NEWLINE> W = dp [ j ] + ( A [ i ] - A [ j ] ) * V <NEWLINE> dp [ i ] = max ( dp [ i ] , W ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( dp [ N ] ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> money = 1000 <NEWLINE> ticket = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <COMMENT> <NL> <INDENT> if A [ i ] < A [ i + 1 ] : <NEWLINE> <INDENT> money -= ( money // A [ i ] ) * A [ i ] <NEWLINE> ticket += money // A [ i ] <NEWLINE> <DEDENT> elif A [ i ] == A [ i + 1 ] : <NEWLINE> <INDENT> pass <NEWLINE> <COMMENT> <NL> <DEDENT> else : <NEWLINE> <INDENT> money += A [ i ] * ticket <NEWLINE> ticket = 0 <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 1000 <NEWLINE> kabu = 0 <NEWLINE> flag = 0 <NEWLINE> <NL> for i in range ( n - 1 ) : <NEWLINE> <INDENT> if a [ i ] < a [ i + 1 ] : <NEWLINE> <INDENT> if flag <= 0 : <NEWLINE> <INDENT> kabu = int ( ans / a [ i ] ) <NEWLINE> ans -= ( kabu * a [ i ] ) <NEWLINE> <COMMENT> <NL> <DEDENT> flag = 1 <NEWLINE> <DEDENT> elif a [ i ] > a [ i + 1 ] : <NEWLINE> <INDENT> if flag > 0 : <NEWLINE> <INDENT> ans += ( kabu * a [ i ] ) <NEWLINE> <COMMENT> <NL> <DEDENT> flag = - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if flag > 0 : <NEWLINE> <INDENT> flag = 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> flag = - 2 <NEWLINE> <DEDENT> <DEDENT> if i == ( n - 2 ) and flag > 0 : <NEWLINE> <INDENT> ans += ( kabu * a [ i + 1 ] ) <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> print ( ans ) n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 1000 <NEWLINE> kabu = 0 <NEWLINE> flag = 0 <NEWLINE> <NL> for i in range ( n - 1 ) : <NEWLINE> <INDENT> if a [ i ] < a [ i + 1 ] : <NEWLINE> <INDENT> if flag <= 0 : <NEWLINE> <INDENT> kabu = int ( ans / a [ i ] ) <NEWLINE> ans -= ( kabu * a [ i ] ) <NEWLINE> <COMMENT> <NL> <DEDENT> flag = 1 <NEWLINE> <DEDENT> elif a [ i ] > a [ i + 1 ] : <NEWLINE> <INDENT> if flag > 0 : <NEWLINE> <INDENT> ans += ( kabu * a [ i ] ) <NEWLINE> <COMMENT> <NL> <DEDENT> flag = - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if flag > 0 : <NEWLINE> <INDENT> flag = 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> flag = - 2 <NEWLINE> <DEDENT> <DEDENT> if i == ( n - 2 ) and flag > 0 : <NEWLINE> <INDENT> ans += ( kabu * a [ i + 1 ] ) <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> M = 1000 <NEWLINE> S = 0 <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> M += S * A [ i ] <NEWLINE> S = 0 <NEWLINE> if A [ i + 1 ] >= A [ i ] : <NEWLINE> <INDENT> tmp = M // A [ i ] <NEWLINE> M = tmp * A [ i ] <NEWLINE> S += tmp <NEWLINE> <DEDENT> <DEDENT> M += S * A [ i ] <NEWLINE> S = 0 <NEWLINE> print ( M ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> money = 1000 <NEWLINE> <NL> for i in range ( n - 1 ) : <NEWLINE> <INDENT> s = 0 <NEWLINE> if a [ i ] < a [ i + 1 ] : <NEWLINE> <INDENT> s = money / a [ i ] : <NEWLINE> <DEDENT> money += ( a [ i + 1 ] - a [ i ] ) * s <NEWLINE> <DEDENT> print ( money ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = input ( ) . split ( ) <NEWLINE> <NL> money = 1000 <NEWLINE> stock = 0 <NEWLINE> pivot = [ ] <NEWLINE> flag = 0 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> pivot . append ( int ( a [ i + 1 ] ) - int ( a [ i ] ) ) <NEWLINE> <NL> <DEDENT> pivot . append ( - 1 ) <NEWLINE> pivot . append ( - 1 ) <NEWLINE> <NL> i = 0 <NEWLINE> <NL> for j in range ( n ) : <NEWLINE> <INDENT> if ( pivot [ j ] > 0 ) : <NEWLINE> <INDENT> i = j <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> flag = - 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if ( flag != - 1 ) : <NEWLINE> <INDENT> stock = int ( money // ( int ( a [ i ] ) ) ) <NEWLINE> money = int ( money % ( int ( a [ i ] ) ) ) <NEWLINE> <NL> <DEDENT> i += 1 <NEWLINE> if ( flag != - 1 ) : <NEWLINE> <INDENT> while ( i < n ) : <NEWLINE> <INDENT> if ( i == n - 1 ) : <NEWLINE> <INDENT> if ( pivot [ i ] > 0 ) : <NEWLINE> <INDENT> money = money + stock * int ( a [ i + 1 ] ) <NEWLINE> stock = 0 <NEWLINE> <DEDENT> break <NEWLINE> <NL> <DEDENT> elif ( pivot [ i ] < 0 ) : <NEWLINE> <INDENT> while ( pivot [ i + 1 ] <= 0 and flag != - 1 ) : <NEWLINE> <INDENT> if ( i == n - 2 ) : <NEWLINE> <INDENT> flag = - 1 <NEWLINE> <DEDENT> i += 1 <NEWLINE> <DEDENT> if ( flag != - 1 ) : <NEWLINE> <INDENT> stock = int ( money // ( int ( a [ i + 1 ] ) ) ) <NEWLINE> money = int ( money % ( int ( a [ i + 1 ] ) ) ) <NEWLINE> i += 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> while ( pivot [ i + 1 ] >= 0 and flag != - 1 ) : <NEWLINE> <INDENT> if ( i == n - 2 ) : <NEWLINE> <INDENT> flag = - 1 <NEWLINE> <DEDENT> i += 1 <NEWLINE> <DEDENT> money = money + stock * int ( a [ i + 1 ] ) <NEWLINE> stock = 0 <NEWLINE> i += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( money ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a_cur = a [ 0 ] <NEWLINE> <NL> m = 1000 <NEWLINE> s = 0 <NEWLINE> <NL> for i in range ( 1 , n ) : <NEWLINE> <INDENT> a_next = a [ i ] <NEWLINE> elif a_cur < a_next : <NEWLINE> <COMMENT> <NL> <INDENT> s = m // a_cur <NEWLINE> m += s * ( a_next - a_cur ) <NEWLINE> a_cur = a_next <NEWLINE> if s > 0 : <NEWLINE> <INDENT> m += s * a [ - 1 ] <NEWLINE> print ( m ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> M = 1000 <NEWLINE> X = 0 <NEWLINE> <NL> for i in range ( N - 1 ) : <NEWLINE> <INDENT> if A [ i ] < A [ i + 1 ] : <NEWLINE> <INDENT> X = int ( M / A [ i ] ) <NEWLINE> M = int ( M - X * A [ i ] ) <NEWLINE> <NL> M = M + X * A [ i + 1 ] <NEWLINE> <DEDENT> X = 0 <NEWLINE> <NL> <DEDENT> print ( int ( M ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> arr = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> cur = 1000 <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> p = 0 <NEWLINE> if arr [ i ] < arr [ i + 1 ] : <NEWLINE> <INDENT> p = cur // a [ i ] <NEWLINE> <DEDENT> cur += ( arr [ i + 1 ] - arr [ i ] ) * cur <NEWLINE> <DEDENT> print ( cur ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> values = np . array ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> kabu = 0 <NEWLINE> money = 1000 <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> if values [ i ] < values [ i + 1 ] : <NEWLINE> <INDENT> kabu = money // values [ i ] <NEWLINE> money += ( values [ i + 1 ] - values [ i ] ) * kabu <NEWLINE> <NL> <DEDENT> <DEDENT> print ( money ) <NEWLINE>
<NL> N = int ( input ( ) ) <NEWLINE> A = list ( [ int ( x ) for x in input ( ) . split ( ) ] ) <NEWLINE> <NL> max_money = 1000 <NEWLINE> stock = 0 <NEWLINE> <NL> for i in range ( N - 1 ) : <NEWLINE> <INDENT> if A [ i ] < A [ i + 1 ] : <NEWLINE> <INDENT> stock += money // A [ i ] <NEWLINE> money -= A [ i ] * stock <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> money += stock * A [ i ] <NEWLINE> stock = 0 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> print ( max_money ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a_list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> current = 1000 <NEWLINE> kabu = 0 <NEWLINE> for i in range ( n - 1 ) print ( current ) <NEWLINE> <INDENT> if a_list [ i ] < a_list [ i + 1 ] : <NEWLINE> <INDENT> kabu += current // a_list [ i ] <NEWLINE> current = current % a_list [ i ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> current += a_list [ i ] * kabu <NEWLINE> kabu = 0 <NEWLINE> <DEDENT> <DEDENT> current += a_list [ - 1 ] * kabu <NEWLINE> print ( current ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> slst = [ ] <NEWLINE> llst = [ ] <NEWLINE> stmp = 201 <NEWLINE> ltmp = 0 <NEWLINE> for i in a : <NEWLINE> <INDENT> if stmp >= i : <NEWLINE> <INDENT> stmp = i <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> slst . append ( stmp ) <NEWLINE> stmp = i <NEWLINE> <NL> <DEDENT> <DEDENT> for i in reversed ( a ) : <NEWLINE> <INDENT> if ltmp <= i : <NEWLINE> <INDENT> ltmp = i <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> llst . insert ( 0 , ltmp ) <NEWLINE> ltmp = i <NEWLINE> <NL> <DEDENT> <DEDENT> total = 1000 <NEWLINE> for i in range ( len ( slst ) ) : <NEWLINE> <INDENT> cnt = total // slst [ i ] <NEWLINE> total -= ( slst [ i ] * cnt ) <NEWLINE> total += ( llst [ i ] * cnt ) <NEWLINE> <NL> <DEDENT> print ( total ) N = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> slst = [ ] <NEWLINE> llst = [ ] <NEWLINE> stmp = 201 <NEWLINE> ltmp = 0 <NEWLINE> for i in a : <NEWLINE> <INDENT> if stmp >= i : <NEWLINE> <INDENT> stmp = i <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> slst . append ( stmp ) <NEWLINE> stmp = i <NEWLINE> <NL> <DEDENT> <DEDENT> for i in reversed ( a ) : <NEWLINE> <INDENT> if ltmp <= i : <NEWLINE> <INDENT> ltmp = i <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> llst . insert ( 0 , ltmp ) <NEWLINE> ltmp = i <NEWLINE> <NL> <DEDENT> <DEDENT> total = 1000 <NEWLINE> for i in range ( len ( slst ) ) : <NEWLINE> <INDENT> cnt = total // slst [ i ] <NEWLINE> total -= ( slst [ i ] * cnt ) <NEWLINE> total += ( llst [ i ] * cnt ) <NEWLINE> <NL> <DEDENT> print ( total ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> my_money = 1000 <NEWLINE> stock = 0 <NEWLINE> <NL> ls = [ ] <NEWLINE> if A [ 0 ] < A [ 1 ] : <NEWLINE> <INDENT> ls . append ( A [ 0 ] ) <NEWLINE> <DEDENT> for i in range ( 1 , N - 1 ) : <NEWLINE> <INDENT> if A [ i ] == A [ i - 1 ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> elif A [ i - 1 ] < A [ i ] <= A [ i + 1 ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> elif A [ i - 1 ] > A [ i ] >= A [ i + 1 ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> ls . append ( A [ i ] ) <NEWLINE> <DEDENT> if A [ - 1 ] > A [ - 2 ] : <NEWLINE> <INDENT> ls . append ( A [ - 1 ] ) <NEWLINE> <NL> <DEDENT> if ls == [ ] : <NEWLINE> <INDENT> print ( 1000 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i , j in enumerate ( ls_1 ) : <NEWLINE> <INDENT> if i % 2 == 0 : <NEWLINE> <INDENT> stock += my_money // j <NEWLINE> my_money %= j <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> my_money += stock * j <NEWLINE> stock = 0 <NEWLINE> <DEDENT> <DEDENT> print ( my_money ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) ) ) <NEWLINE> <NL> money = 1000 <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> if a [ i ] < a [ i + 1 ] : <NEWLINE> <INDENT> money += ( a [ i + 1 ] - a [ i ] ) * ( money // a [ i ] ) <NEWLINE> <DEDENT> <DEDENT> print ( money ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> from fractions import gcd <NEWLINE> from itertools import combinations , permutations , accumulate <COMMENT> <NEWLINE> <COMMENT> <NL> from collections import deque , defaultdict , Counter <NEWLINE> import decimal <NEWLINE> import re <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> import sys <NEWLINE> sys . setrecursionlimit ( 10000000 ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <COMMENT> <NL> def readInts ( ) : <NEWLINE> <INDENT> return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <DEDENT> def I ( ) : <NEWLINE> <INDENT> return int ( input ( ) ) <NEWLINE> <DEDENT> n = I ( ) <NEWLINE> A = readInts ( ) <NEWLINE> lis = [ ] <NEWLINE> prv = - 1 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if prv != A [ i ] : <NEWLINE> <INDENT> lis . append ( A [ i ] ) <NEWLINE> prv = A [ i ] <NEWLINE> <DEDENT> <DEDENT> def dfs ( money , kabu , now ) : <NEWLINE> <INDENT> if now == len ( lis ) : <NEWLINE> <INDENT> global ans <NEWLINE> ans = max ( money , ans ) <NEWLINE> return <NEWLINE> <DEDENT> if kabu != 0 : <NEWLINE> <INDENT> if now + 1 == len ( lis ) : <NEWLINE> <INDENT> dfs ( money + kabu * lis [ now ] , 0 , now + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if lis [ now ] > lis [ now + 1 ] : <NEWLINE> <INDENT> dfs ( money + kabu * lis [ now ] , 0 , now + 1 ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if money // lis [ now ] >= 1 : <NEWLINE> <INDENT> if now + 1 == len ( lis ) : <NEWLINE> <INDENT> dfs ( money - lis [ now ] * ( money // lis [ now ] ) , money // lis [ now ] , now + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if lis [ now ] < lis [ now + 1 ] : <NEWLINE> <INDENT> dfs ( money - lis [ now ] * ( money // lis [ now ] ) , money // lis [ now ] , now + 1 ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> dfs ( money , kabu , now + 1 ) <NEWLINE> <DEDENT> ans = 1000 <NEWLINE> dfs ( 1000 , 0 , 0 ) <NEWLINE> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> syozi = 1000 <NEWLINE> kabu = 0 <NEWLINE> <NL> for i in range ( N - 1 ) : <NEWLINE> <COMMENT> <NL> <INDENT> if A [ i ] < A [ i + 1 ] : <NEWLINE> <INDENT> kabu = syozi // A [ i ] <NEWLINE> syozi = int ( syozi % A [ i ] ) <NEWLINE> <DEDENT> elif A [ i ] > A [ i + 1 ] : <NEWLINE> <INDENT> syozi += A [ i ] * kabu <NEWLINE> kabu = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> pass <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> if A [ N - 2 ] < A [ N - 1 ] : <NEWLINE> <INDENT> syozi += A [ N - 1 ] * kabu <NEWLINE> kabu = 0 <NEWLINE> <NL> <DEDENT> print ( syozi ) <NEWLINE>
<COMMENT> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <COMMENT> <NL> <NL> kabu = 0 <NEWLINE> money = 1000 <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> if A [ i ] < A [ i + 1 ] : <NEWLINE> <INDENT> mod , money = divmod ( money , A [ i ] ) <NEWLINE> kabu += mod <NEWLINE> <DEDENT> if A [ i ] > A [ i + 1 ] <NEWLINE> <INDENT> money = money + A [ i + 1 ] * kabu <NEWLINE> kabu = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> money = money + A [ N - 1 ] * kabu <NEWLINE> print ( money ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) ) ) <NEWLINE> <NL> money = 1000 <NEWLINE> stock = 0 <NEWLINE> <NL> for i in range ( n - 1 ) : <NEWLINE> <INDENT> if a [ i + 1 ] > a [ i ] : <NEWLINE> <INDENT> stock = money // a [ i ] <NEWLINE> money = money - stock * a [ i ] + stock * a [ i + 1 ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( money ) <NEWLINE>
N = int ( input ( ) ) <COMMENT> <NEWLINE> Input = [ int ( input ( ) ) for i in range ( N ) ] <COMMENT> <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> j = i + 1 <NEWLINE> <NL> Stock = 0 <NEWLINE> Money = 1000 <NEWLINE> <NL> if j = 1 : <NEWLINE> <INDENT> if Input [ i ] < Input [ i + 1 ] : <NEWLINE> <INDENT> Stock = Money // Input [ i ] <NEWLINE> Money = Money % Input [ i ] <NEWLINE> <NL> <DEDENT> break <NEWLINE> <NL> <DEDENT> if j = N : <NEWLINE> <INDENT> if Stock != 0 : <NEWLINE> <INDENT> money = money + Stock * Input [ i ] <NEWLINE> <DEDENT> break <NEWLINE> <NL> <DEDENT> if Input [ i - 1 ] < Input [ i ] : <NEWLINE> <INDENT> money = money + Stock * Input [ i ] <NEWLINE> <NL> <DEDENT> if Input [ i + 1 ] > Input [ i ] : <NEWLINE> <INDENT> Stock = Money // Input [ i ] <NEWLINE> Money = Money % Input [ i ] <NEWLINE> <NL> <NL> <DEDENT> <DEDENT>
import sys <NEWLINE> input = sys . stdin . buffer . readline <NEWLINE> from numba import njit <NEWLINE> import numpy as np <NEWLINE> INF = 10 ** 18 <NEWLINE> <NL> @ njit ( <STRING> ) <NEWLINE> def solve ( N , XYP ) : <NEWLINE> <INDENT> X = XYP [ : , 0 ] <NEWLINE> Y = XYP [ : , 1 ] <NEWLINE> <NL> def calcCost ( sign , A ) : <NEWLINE> <INDENT> ret = np . ones ( ( 1 << N , N ) , dtype = np . int64 ) * INF <NEWLINE> for state in range ( 1 << N ) : <NEWLINE> <INDENT> useA = [ a for i , a in enumerate ( A ) if ( state & ( 1 << i ) ) != 0 ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> xyp = XYP [ i ] <NEWLINE> cost = abs ( xyp [ sign ] ) <NEWLINE> for z in useA : <NEWLINE> <INDENT> cost = min ( cost , abs ( xyp [ sign ] - z ) ) <NEWLINE> <DEDENT> ret [ state ] [ i ] = cost * xyp [ 2 ] <NEWLINE> <DEDENT> <DEDENT> return ret <NEWLINE> <NL> <DEDENT> costX = calcCost ( 0 , X ) <NEWLINE> costY = calcCost ( 1 , Y ) <NEWLINE> ans = np . ones ( N + 1 , dtype = np . int64 ) * INF <NEWLINE> <NL> for state in range ( pow ( 3 , N ) ) : <NEWLINE> <INDENT> stateX = 0 <NEWLINE> stateY = 0 <NEWLINE> M = N <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> state , r = divmod ( state , 3 ) <NEWLINE> stateX <<= 1 <NEWLINE> stateY <<= 1 <NEWLINE> if r == 0 : M -= 1 <NEWLINE> if r == 1 : stateX |= 1 <NEWLINE> if r == 2 : stateY |= 1 <NEWLINE> <NL> <DEDENT> cx , cy = costX [ stateX ] , costY [ stateY ] <NEWLINE> cost = np . minimum ( cx , cy ) . sum ( ) <NEWLINE> ans [ M ] = min ( ans [ M ] , cost ) <NEWLINE> <NL> <DEDENT> for a in ans : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <NL> <DEDENT> <DEDENT> def sol ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> XYP = np . asarray ( [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( N ) ] ) <NEWLINE> solve ( N , XYP ) <NEWLINE> <NL> <DEDENT> sol ( ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <NL> import sys <NEWLINE> import numpy as np <NEWLINE> <NL> read = sys . stdin . buffer . read <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> readlines = sys . stdin . buffer . readlines <NEWLINE> <NL> def resolve ( ) : <NEWLINE> <INDENT> X , Y , P = XYP [ : : 3 ] , XYP [ 1 : : 3 ] , XYP [ 2 : : 3 ] <NEWLINE> N = len ( X ) <NEWLINE> X_cost = np . empty ( ( 1 << N , N ) , np . int64 ) <NEWLINE> X_cost [ 0 ] = np . abs ( X ) * P <NEWLINE> for n in range ( N ) : <NEWLINE> <INDENT> B = 1 << n <NEWLINE> X_cost [ B : 2 * B ] = np . minimum ( X_cost [ : B ] , np . abs ( ( X - X [ n ] ) * P ) ) <NEWLINE> <COMMENT> <NL> <DEDENT> Y_cost = np . empty ( ( 1 << N , N ) , np . int64 ) <NEWLINE> Y_cost [ 0 ] = np . abs ( Y ) * P <NEWLINE> for n in range ( N ) : <NEWLINE> <INDENT> B = 1 << n <NEWLINE> Y_cost [ B : 2 * B ] = np . minimum ( Y_cost [ : B ] , np . abs ( ( Y - Y [ n ] ) * P ) ) <NEWLINE> <COMMENT> <NL> <DEDENT> popcount = np . zeros ( 1 << N , np . int64 ) <NEWLINE> for n in range ( N ) : <NEWLINE> <INDENT> popcount [ 1 << n : 1 << n + 1 ] = popcount [ : 1 << n ] + 1 <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> INF = 10 ** 18 <NEWLINE> ans = np . full ( N + 1 , INF , np . int64 ) <NEWLINE> for s in range ( 1 << N ) : <NEWLINE> <INDENT> size = popcount [ s ] <NEWLINE> t = s <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> while True : <NEWLINE> <INDENT> u = s ^ t <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> cost = ( np . minimum ( X_cost [ t ] , Y_cost [ u ] ) ) . sum ( ) <NEWLINE> ans [ size ] = min ( ans [ size ] , cost ) <NEWLINE> if t == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> t = ( t - 1 ) & s <NEWLINE> <DEDENT> <DEDENT> return ans <NEWLINE> <NL> <DEDENT> if sys . argv [ - 1 ] == <STRING> : <NEWLINE> <INDENT> import numba <NEWLINE> from numba . pycc import CC <NEWLINE> i8 = numba . int64 <NEWLINE> cc = CC ( <STRING> ) <NEWLINE> <NL> def cc_export ( f , signature ) : <NEWLINE> <INDENT> cc . export ( f . __name__ , signature ) ( f ) <NEWLINE> return numba . njit ( f ) <NEWLINE> <NL> <DEDENT> resolve = cc_export ( resolve , ( i8 [ : ] , ) ) <NEWLINE> cc . compile ( ) <NEWLINE> <NL> <DEDENT> from my_module import resolve <NEWLINE> <NL> N = int ( readline ( ) ) <NEWLINE> XYP = np . array ( read ( ) . split ( ) , np . int64 ) <NEWLINE> <NL> ans = resolve ( ) <NEWLINE> print ( <STRING> . join ( map ( str , ans . tolist ( ) ) ) ) <NEWLINE>
import sys <NEWLINE> import numpy as np <NEWLINE> <NL> read = sys . stdin . buffer . read <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> readlines = sys . stdin . buffer . readlines <NEWLINE> <NL> def main ( XYP ) : <NEWLINE> <INDENT> X , Y , P = XYP [ : : 3 ] , XYP [ 1 : : 3 ] , XYP [ 2 : : 3 ] <NEWLINE> N = len ( X ) <NEWLINE> dp = np . empty ( ( 3 ** N , N ) , np . int32 ) <COMMENT> <NEWLINE> dp [ 0 ] = np . minimum ( np . abs ( X ) , np . abs ( Y ) ) <NEWLINE> size = np . empty ( 3 ** N , np . int32 ) <NEWLINE> size [ 0 ] = 0 <NEWLINE> for n in range ( N ) : <NEWLINE> <INDENT> B = 3 ** n <NEWLINE> DX = np . abs ( X - X [ n ] ) <NEWLINE> DY = np . abs ( Y - Y [ n ] ) <NEWLINE> dp [ B : 2 * B ] = np . minimum ( dp [ : B ] , DX ) <NEWLINE> dp [ 2 * B : 3 * B ] = np . minimum ( dp [ : B ] , DY ) <NEWLINE> size [ B : 2 * B ] = size [ : B ] + 1 <NEWLINE> size [ 2 * B : 3 * B ] = size [ : B ] + 1 <NEWLINE> <DEDENT> ans = np . full ( N + 1 , 10 ** 18 , np . int64 ) <NEWLINE> for s in range ( 3 ** N ) : <NEWLINE> <INDENT> n = size [ s ] <NEWLINE> ans [ n ] = min ( ans [ n ] , ( P * dp [ s ] ) . sum ( ) ) <NEWLINE> <DEDENT> return ans <NEWLINE> <NL> <DEDENT> if sys . argv [ - 1 ] == <STRING> : <NEWLINE> <INDENT> import numba <NEWLINE> from numba . pycc import CC <NEWLINE> i8 = numba . int64 <NEWLINE> cc = CC ( <STRING> ) <NEWLINE> <NL> def cc_export ( f , signature ) : <NEWLINE> <INDENT> cc . export ( f . __name__ , signature ) ( f ) <NEWLINE> return numba . njit ( f ) <NEWLINE> <NL> <DEDENT> main = cc_export ( main , ( i8 [ : ] , ) ) <NEWLINE> cc . compile ( ) <NEWLINE> <NL> <DEDENT> from my_module import main <NEWLINE> <NL> N = int ( readline ( ) ) <NEWLINE> XYP = np . array ( read ( ) . split ( ) , np . int64 ) <NEWLINE> <NL> ans = main ( XYP ) <NEWLINE> print ( <STRING> . join ( map ( str , ans . tolist ( ) ) ) ) <NEWLINE>
import numpy as np <NEWLINE> from numba import njit <NEWLINE> import sys <NEWLINE> <NL> read = sys . stdin . buffer . read <NEWLINE> <NL> <NL> @ njit <NEWLINE> def solve ( inp ) : <NEWLINE> <INDENT> INF = 10 ** 18 <NEWLINE> <NL> n = inp [ 0 ] <NEWLINE> x = inp [ 1 : : 3 ] <NEWLINE> y = inp [ 2 : : 3 ] <NEWLINE> p = inp [ 3 : : 3 ] <NEWLINE> <NL> ver = np . empty ( ( 1 << n , n ) , np . int64 ) <NEWLINE> ver [ 0 ] = np . abs ( x ) * p <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> bt = 1 << i <NEWLINE> ver [ bt : 2 * bt ] = np . minimum ( ver [ : bt ] , np . abs ( x - x [ i ] ) * p ) <NEWLINE> <NL> <DEDENT> hor = np . empty ( ( 1 << n , n ) , np . int64 ) <NEWLINE> hor [ 0 ] = np . abs ( y ) * p <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> bt = 1 << i <NEWLINE> hor [ bt : 2 * bt ] = np . minimum ( hor [ : bt ] , np . abs ( y - y [ i ] ) * p ) <NEWLINE> <NL> <DEDENT> ans = [ INF ] * ( n + 1 ) <NEWLINE> for i in range ( 3 ** n ) : <NEWLINE> <INDENT> vi = 0 <NEWLINE> hi = 0 <NEWLINE> cnt = 0 <NEWLINE> pow2 = 1 <NEWLINE> pow3 = i <NEWLINE> while pow3 : <NEWLINE> <INDENT> r = pow3 % 3 <NEWLINE> pow3 //= 3 <NEWLINE> if r == 1 : <NEWLINE> <INDENT> vi += pow2 <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> elif r == 2 : <NEWLINE> <INDENT> hi += pow2 <NEWLINE> cnt += 1 <NEWLINE> <NL> <DEDENT> pow2 *= 2 <NEWLINE> <NL> <DEDENT> score = np . minimum ( ver [ vi ] , hor [ hi ] ) . sum ( ) <NEWLINE> ans [ cnt ] = min ( ans [ cnt ] , score ) <NEWLINE> <NL> <DEDENT> return ans <NEWLINE> <NL> <NL> <DEDENT> inp = np . array ( read ( ) . split ( ) , np . int64 ) <NEWLINE> ans = solve ( inp ) <NEWLINE> print ( * ans , sep = <STRING> ) <NEWLINE>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> import numpy as np <NEWLINE> from numba import njit <NEWLINE> <NL> <NL> def read ( ) : <NEWLINE> <INDENT> N = int ( input ( ) . strip ( ) ) <NEWLINE> XYP = np . empty ( ( N , 3 ) , dtype = np . int32 ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> XYP [ i ] = np . fromstring ( input ( ) . strip ( ) , sep = <STRING> ) <NEWLINE> <DEDENT> return N , XYP <NEWLINE> <NL> <NL> <DEDENT> @ njit <NEWLINE> def solve ( N , XYP , INF = 10 ** 18 ) : <NEWLINE> <INDENT> ans = np . full ( N + 1 , INF , dtype = np . int64 ) <NEWLINE> vcost = np . zeros ( ( N , 2 ** N ) , dtype = np . int32 ) <NEWLINE> hcost = np . zeros ( ( N , 2 ** N ) , dtype = np . int32 ) <NEWLINE> <NL> <COMMENT> <NL> for intptn in range ( 2 ** N ) : <NEWLINE> <INDENT> for i in range ( N ) : <NEWLINE> <INDENT> xi , yi , pi = XYP [ i ] <NEWLINE> v = abs ( xi ) <NEWLINE> h = abs ( yi ) <NEWLINE> for j in range ( N ) : <NEWLINE> <INDENT> xj , yj , pj = XYP [ j ] <NEWLINE> if ( intptn >> j ) & 1 == 1 : <NEWLINE> <INDENT> v = min ( v , abs ( xj - xi ) ) <NEWLINE> h = min ( h , abs ( yj - yi ) ) <NEWLINE> <DEDENT> <DEDENT> vcost [ i , intptn ] += v <NEWLINE> hcost [ i , intptn ] += h <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> for intptn in range ( 3 ** N ) : <NEWLINE> <COMMENT> <NL> <INDENT> p , intvptn , inthptn = intptn , 0 , 0 <NEWLINE> u = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if p % 3 == 1 : <NEWLINE> <INDENT> intvptn += 1 << ( N - i - 1 ) <NEWLINE> u += 1 <NEWLINE> <DEDENT> elif p % 3 == 2 : <NEWLINE> <INDENT> inthptn += 1 << ( N - i - 1 ) <NEWLINE> u += 1 <NEWLINE> <DEDENT> p //= 3 <NEWLINE> <DEDENT> s = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> s += min ( vcost [ i , intvptn ] , hcost [ i , inthptn ] ) * XYP [ i , 2 ] <NEWLINE> <DEDENT> ans [ u ] = min ( ans [ u ] , s ) <NEWLINE> <NL> <DEDENT> return ans <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> inputs = read ( ) <NEWLINE> ans = solve ( * inputs ) <NEWLINE> for a in ans : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <DEDENT> <DEDENT>
I = N = 9 ** 9 <NEWLINE> P , M , L , R , U = <STRING> , <STRING> , [ ] , [ ] , [ ] <NEWLINE> for t in [ * open ( 0 ) ] [ 1 : ] : * z , u = t . split ( ) ; exec ( u + <STRING> ) <NEWLINE> for * A , S , D in ( D , U , * <STRING> ) , ( L , R , * <STRING> ) , ( U , R , P , M ) , ( L , D , P , M ) , ( L , U , M , P ) , ( D , R , M , P ) : <NEWLINE> <INDENT> n = p = - I <NEWLINE> for x , y , r in eval ( <STRING> ) : <NEWLINE> <INDENT> if r : n , p = x , y <NEWLINE> elif x == n : N = min ( N , y - p ) <NEWLINE> <DEDENT> <DEDENT> print ( N % I * 5 or <STRING> ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> XYU = [ tuple ( input ( ) . split ( ) ) for _ in range ( N ) ] <NEWLINE> U = [ ] <NEWLINE> R = [ ] <NEWLINE> D = [ ] <NEWLINE> L = [ ] <NEWLINE> for x , y , u in XYU : <NEWLINE> <INDENT> x , y = int ( x ) , int ( y ) <NEWLINE> if u == <STRING> : <NEWLINE> <INDENT> U . append ( ( x , y ) ) <NEWLINE> <DEDENT> elif u == <STRING> : <NEWLINE> <INDENT> D . append ( ( x , y ) ) <NEWLINE> <DEDENT> elif u == <STRING> : <NEWLINE> <INDENT> L . append ( ( x , y ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> R . append ( ( x , y ) ) <NEWLINE> <DEDENT> <DEDENT> r = 10 ** 9 <NEWLINE> def z ( A ) : <NEWLINE> <INDENT> global r <NEWLINE> A . sort ( ) <NEWLINE> n = p = - 10 ** 9 <NEWLINE> for k , c , a in A : <NEWLINE> <INDENT> if k != n : <NEWLINE> <INDENT> if a == 1 : <NEWLINE> <INDENT> n = k <NEWLINE> p = c <NEWLINE> <DEDENT> continue <NEWLINE> <DEDENT> if a == 1 : <NEWLINE> <INDENT> p = c <NEWLINE> continue <NEWLINE> <DEDENT> if ( c - p ) * 5 < ans : <NEWLINE> <INDENT> ans = ( c - p ) * 5 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> z ( [ ( x , y , 1 ) for x , y in U ] + [ ( x , y , - 1 ) for x , y in D ] ) <NEWLINE> z ( [ ( y , x , 1 ) for x , y in R ] + [ ( y , x , - 1 ) for x , y in L ] ) <NEWLINE> z ( [ ( x + y , x - y , 1 ) for x , y in R ] + [ ( x + y , x - y , - 1 ) for x , y in U ] ) <NEWLINE> z ( [ ( x + y , x - y , 1 ) for x , y in D ] + [ ( x + y , x - y , - 1 ) for x , y in L ] ) <NEWLINE> z ( [ ( x - y , x + y , 1 ) for x , y in U ] + [ ( x - y , x + y , - 1 ) for x , y in L ] ) <NEWLINE> z ( [ ( x - y , x + y , 1 ) for x , y in R ] + [ ( x - y , x + y , - 1 ) for x , y in D ] ) <NEWLINE> print ( <STRING> if r >= 10 ** 9 else r ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> <NL> planes = { <NEWLINE> <INDENT> <STRING> : [ ] , <NEWLINE> <STRING> : [ ] , <NEWLINE> <STRING> : [ ] , <NEWLINE> <STRING> : [ ] <NEWLINE> <DEDENT> } <NEWLINE> <NL> for _ in range ( N ) : <NEWLINE> <INDENT> x , y , t = input ( ) . split ( ) <NEWLINE> x , y = int ( x ) , int ( y ) <NEWLINE> planes [ t ] . append ( ( x , y ) ) <NEWLINE> <NL> <DEDENT> BIG = 10 ** 18 <NEWLINE> <NL> def time ( ps ) : <NEWLINE> <INDENT> sort ( ps ) <NEWLINE> ans = BIG <NEWLINE> for i in range ( len ( ps ) - 1 ) : <NEWLINE> <INDENT> y1 , x1 , t1 = ps [ i ] <NEWLINE> y2 , x2 , t2 = ps [ i + 1 ] <NEWLINE> <NL> if y1 != y2 : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <DEDENT> if t1 == 1 and t2 = - 1 : <NEWLINE> <INDENT> ans = min ( ans , x2 - x1 ) <NEWLINE> <DEDENT> <DEDENT> return 5 * ans <NEWLINE> <NL> <NL> <DEDENT> ud = [ ( x , y , 1 ) for x , y in planes [ <STRING> ] ] + [ ( x , y , - 1 ) for x , y in planes [ <STRING> ] ] <NEWLINE> lr = [ ( y , x , 1 ) for x , y in planes [ <STRING> ] ] + [ ( y , x , - 1 ) for x , y in planes [ <STRING> ] ] <NEWLINE> <NL> ur = [ ( x + y , y - x , 1 ) for x , y in planes [ <STRING> ] ] + [ ( x + y , y - x , - 1 ) for x , y in planes [ <STRING> ] ] <NEWLINE> ul = [ ( x - y , y + x , 1 ) for x , y in planes [ <STRING> ] ] + [ ( x - y , y + x , - 1 ) for x , y in planes [ <STRING> ] ] <NEWLINE> rd = [ ( x - y , y + x , 1 ) for x , y in planes [ <STRING> ] ] + [ ( x - y , y + x , - 1 ) for x , y in planes [ <STRING> ] ] <NEWLINE> ld = [ ( x + y , y - x , 1 ) for x , y in planes [ <STRING> ] ] + [ ( x + y , y - x , - 1 ) for x , y in planes [ <STRING> ] ] <NEWLINE> <NL> ans = min ( time ( ud ) , time ( lr ) , time ( ur ) , time ( ul ) , time ( rd ) , time ( ld ) ) <NEWLINE> if ans >= BIG : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <NL> <DEDENT>
min = int ( input ( ) ) <NEWLINE> max = int ( input ( ) ) + 1 <NEWLINE> power = int ( input ( ) ) <NEWLINE> <NL> count = 0 <NEWLINE> for i in range ( min , max ) : <NEWLINE> <INDENT> if i % power == 0 : <NEWLINE> <INDENT> count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
L = int ( input ( ) ) <NEWLINE> R = int ( input ( ) ) <NEWLINE> d = int ( input ( ) ) <NEWLINE> a = L // d <NEWLINE> b = R // d <NEWLINE> c = L % d <NEWLINE> if c == 0 : <NEWLINE> <INDENT> print ( b - a + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( b - a ) <NEWLINE> <DEDENT>
L , R , d = ( int ( x ) for x in input ( ) . split ( ) ) <NEWLINE> <NL> te = R - L + 1 <NEWLINE> num = 0 <NEWLINE> <NL> for i in range ( te ) : <NEWLINE> <INDENT> if L % d == 0 : <NEWLINE> <INDENT> num += 1 <NEWLINE> L += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> L += 1 <NEWLINE> <NL> <DEDENT> print ( i ) <NEWLINE> <NL> <DEDENT> print ( num <NEWLINE>
a = int ( input ( ) ) <NEWLINE> b = int ( input ( ) ) <NEWLINE> c = int ( input ( ) ) <NEWLINE> <NL> print ( b / c - ( a - 1 ) / c ) <NEWLINE>
L , R , D = map ( int , input ( ) . split ( ) ) <NEWLINE> ANS = 0 <NEWLINE> if L % d == 0 : <NEWLINE> <INDENT> ANS = 1 <NEWLINE> <NL> <DEDENT> ANS += ( R - L ) // d <NEWLINE> print ( ANS ) <NEWLINE>
a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in range ( a [ 0 , a [ 1 ] + 1 ] ) : <NEWLINE> <INDENT> if i % a [ 2 ] == 0 : <NEWLINE> <INDENT> counter += 1 <NEWLINE> <DEDENT> <DEDENT> print ( counter ) <NEWLINE>
<NL> <NL> l , r , d = map ( input ( ) . split ( ) , int ) <NEWLINE> ans = 0 <NEWLINE> <NL> for i = range ( l , r + 1 ) : <NEWLINE> <INDENT> if ( i % d == 0 ) ans += 1 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
L , R , d = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> compteur = 0 <NEWLINE> <NL> for i in range ( L , R + 1 ) : <NEWLINE> <INDENT> if i % d == 0 : <NEWLINE> <INDENT> k += 1 <NEWLINE> <DEDENT> <DEDENT>
L = int ( input ( <STRING> ) ) <NEWLINE> R = int ( input ( <STRING> ) ) <NEWLINE> d = int ( input ( <STRING> ) ) <NEWLINE> count = 0 <NEWLINE> for I in range ( L , R + 1 ) : <NEWLINE> <INDENT> if ( I % d == 0 ) : <NEWLINE> <INDENT> count = count + 1 <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
l , r , d = map ( int , input ( ) . split ( ) ) <NEWLINE> c = 0 <NEWLINE> for i in range ( l , r + 1 ) : <NEWLINE> <INDENT> if i % d = 0 : <NEWLINE> <INDENT> c += 1 <NEWLINE> <DEDENT> <DEDENT> print ( c ) <NEWLINE>
a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> 2 <NEWLINE> if a [ 0 ] <= 100 and a [ 1 ] <= 100 and a [ 2 ] <= 100 and a [ 0 ] <= a [ 1 ] : <NEWLINE> 3 <NEWLINE> <INDENT> b = a [ 1 ] - a [ 0 ] <NEWLINE> <DEDENT> 4 <NEWLINE> <INDENT> if b % a [ 2 ] > 0 : <NEWLINE> <DEDENT> 5 <NEWLINE> <INDENT> print ( int ( b / a [ 2 ] ) ) <NEWLINE> <DEDENT> 6 <NEWLINE> <NL> 7 <NEWLINE> <INDENT> else : <NEWLINE> <DEDENT> 8 <NEWLINE> <INDENT> print ( int ( b / a [ 2 ] ) + 1 ) <NEWLINE> <DEDENT>
L , R , d = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> minumum = math . ceil ( L / d ) <NEWLINE> maximum = R // d <NEWLINE> <NL> if maximum - minumum >= 0 : <NEWLINE> <INDENT> print ( maximum - minumum + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT>
L , R , d = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> result = 0 <NEWLINE> for i in range ( L , R + 1 ) : <NEWLINE> <INDENT> if i % d == 0 : <NEWLINE> <INDENT> result += 1 <NEWLINE> <DEDENT> <DEDENT> print ( result ) L , R , d = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> result = 0 <NEWLINE> for i in range ( L , R + 1 ) : <NEWLINE> <INDENT> if i % d == 0 : <NEWLINE> <INDENT> result += 1 <NEWLINE> <DEDENT> <DEDENT> print ( result ) <NEWLINE>
L , R , d = input ( ) . split ( ) <NEWLINE> L = int ( L ) <NEWLINE> R = int ( R ) <NEWLINE> d = int ( d ) <NEWLINE> cnt = 0 <NEWLINE> for t in Range ( L , R + 1 ) : <NEWLINE> <INDENT> if t % d == 0 : <NEWLINE> <INDENT> cnt = cnt + 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
import numpy <NEWLINE> import math <NEWLINE> <NL> L , R , d = input ( ) . split ( ) <NEWLINE> <NL> N = R / d <NEWLINE> <NL> n = 0 <COMMENT> <NEWLINE> y = math . floor ( L * 10 ** n ) / ( 10 ** n ) <NEWLINE> <NL> print ( math . floor ( y ) ) <NEWLINE>
result = 0 <NEWLINE> for n in range ( L , R + 1 ) : <NEWLINE> <INDENT> if n % D == 0 : <NEWLINE> <INDENT> result += 1 <NEWLINE> <DEDENT> <DEDENT> print ( result ) <NEWLINE>
l , r , d = map ( int , input ( ) . split ( ) ) <NEWLINE> var = l // d <NEWLINE> var1 = r // d <NEWLINE> ans = var1 - var <NEWLINE> if l % d == 0 : <NEWLINE> ans += 1 <NEWLINE> print ( ans ) <NEWLINE>
import sys <NEWLINE> L , R , d = int ( sys . stdin . readline ( ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> result = 0 <NEWLINE> for index in range ( L , R + 1 ) : <NEWLINE> <INDENT> if index % d == 0 : <NEWLINE> <INDENT> result += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( result ) <NEWLINE> <NL> <NL>
l , r , d = map ( int , input . split ( ) ) <NEWLINE> print ( ( l - r + 1 ) // d ) <NEWLINE>
l . r . d = map ( int , input ( ) . split ( ) ) <NEWLINE> cnt = 0 <NEWLINE> for i in ( l , r + 1 ) : <NEWLINE> <INDENT> if i % d == 0 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
L = int ( input ( ) ) <NEWLINE> R = int ( input ( ) ) <NEWLINE> d = int ( input ( ) ) <NEWLINE> count = int ( 0 ) <NEWLINE> for i in range ( L , R ) : <NEWLINE> <INDENT> if i % d == 0 : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
l , r , d = map ( int , input ( ) . split ( ) ) <NEWLINE> count = 0 <NEWLINE> for i int range ( l , r + 1 ) : <NEWLINE> <INDENT> if i % d == 0 : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
L , R , d = input ( ) <NEWLINE> count = 0 <NEWLINE> for i in range ( int ( L ) + 1 , int ( R ) + 1 ) : <NEWLINE> <INDENT> if i % int ( d ) == 0 : <NEWLINE> <INDENT> count = count + 1 <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
N , M , L = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( ( M // L - ( N - 1 ) // L ) <NEWLINE>
a = int ( input ( ) ) <NEWLINE> b = int ( input ( ) ) <NEWLINE> c = int ( input ( ) ) <NEWLINE> <NL> top = b // c <NEWLINE> if a % c == 0 : <NEWLINE> <INDENT> bottom = a // c - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> bottom = a // c <NEWLINE> <NL> <DEDENT> print ( top - bottom ) <NEWLINE>
L , R = map ( int , input ( ) . split ( ) ) <NEWLINE> d = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for n in range ( L , R + 1 ) : <NEWLINE> <INDENT> if n % d == 0 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
l , r , d = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> count = 0 <NEWLINE> for i range ( l , r + 1 ) : <NEWLINE> <INDENT> if i % d == 0 : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
li = input ( ) . split ( ) <NEWLINE> count = 0 <NEWLINE> for num in range ( li [ 0 ] , li [ 1 ] + 1 ) : <NEWLINE> <INDENT> if num % li [ 2 ] == 0 : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
l , r , d = map ( int , input ( . split ( ) ) ) <NEWLINE> c = 0 <NEWLINE> for i in range ( l , r + 1 ) : <NEWLINE> <INDENT> if i % d == 0 : <NEWLINE> <INDENT> c += 1 <NEWLINE> <DEDENT> <DEDENT> print ( c ) <NEWLINE>
L . R , d = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( L , R + 1 ) : <NEWLINE> <INDENT> if i % d == 0 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
L , R , d = [ int ( digit ) for digit in input ( ) ] <NEWLINE> c = 0 <NEWLINE> <NL> for i in range ( L , R + 1 ) : <NEWLINE> <INDENT> if i % d == 0 : <NEWLINE> <INDENT> c += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( c ) <NEWLINE>
L = int ( input ( ) ) <NEWLINE> R = int ( input ( ) ) <NEWLINE> d = int ( input ( ) ) <NEWLINE> i = 0 <NEWLINE> for x in range ( L , R + 1 ) : <NEWLINE> <INDENT> if x % 2 == 0 : <NEWLINE> <INDENT> i += 1 <NEWLINE> <DEDENT> <DEDENT> print ( i ) <NEWLINE>
l , r , d = map ( int , input ( ) ) <NEWLINE> print ( r // d - ( l - 1 ) // d ) <NEWLINE>
L R d = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( L , R + 1 ) : <NEWLINE> <INDENT> if i % d == 0 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
l , r , d = input ( ) . split ( ) <NEWLINE> print ( r // d - ( l - 1 ) // d ) <NEWLINE>
l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> d = int ( input ( ) ) <NEWLINE> <NL> l = l // d <NEWLINE> r = r // d <NEWLINE> <NL> print ( r - l ) <NEWLINE>
L , R , d = int ( input ( ) . split ( ) ) <NEWLINE> counter = 0 <NEWLINE> for i in range ( R + 1 - L ) : <NEWLINE> <INDENT> num = i + L <NEWLINE> if num % d == 0 : <NEWLINE> <INDENT> counter += 1 <NEWLINE> <DEDENT> <DEDENT> print ( counter ) <NEWLINE>
L , R = map ( int , input ( ) . split ( ) ) <NEWLINE> d = input ( ) <NEWLINE> <NL> for L in range ( R ) : <NEWLINE> <INDENT> if ( i % d == 0 ) cnt + + <NEWLINE> <NL> <DEDENT> print ( cnt ) <NEWLINE>
import math <NEWLINE> <NL> t = int ( input ( ) ) <NEWLINE> r = int ( input ( ) ) <NEWLINE> s = int ( input ( ) ) <NEWLINE> print ( r // s - ( t - 1 ) // s ) <NEWLINE>
l , R , d = map ( int , input ( ) ) . split ( ) <NEWLINE> <NL> a = 0 <NEWLINE> for i in range ( l , R ) : <NEWLINE> <INDENT> if i % d == 0 : <NEWLINE> <INDENT> a = a + 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( a ) <NEWLINE>
import math <NEWLINE> <NL> L , R , d = map ( int , input ( ) . parse ( ) ) <NEWLINE> <NL> num = 0 <NEWLINE> start_d = int ( math . ceil ( L / d ) ) <NEWLINE> end_d = int ( math . floor ( R / d ) ) <NEWLINE> <NL> print ( end_d - start_d + 1 ) <NEWLINE>
a , b , c = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> print int ( b / c ) - int ( a / c + 0.999 ) + 1 <NEWLINE>
l , r , d = map ( int , input ( ) . split ( ) ) <NEWLINE> for x in range ( l , r + 1 ) : <NEWLINE> <INDENT> if x % d == 0 : <NEWLINE> <INDENT> c = c + 1 <NEWLINE> <DEDENT> <DEDENT> print ( c ) <NEWLINE>
l , r , d = map ( int , input ( ) . split ( ) ) <NEWLINE> if l > r : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ( r - l ) // d ) <NEWLINE> <DEDENT>
l , r , d = map ( input ( ) . split ( <STRING> ) ) <NEWLINE> c = 0 <NEWLINE> for i in range ( l , r + 1 , 1 ) : <NEWLINE> <INDENT> if i % d == 0 : <NEWLINE> <INDENT> c += 1 <NEWLINE> <DEDENT> <DEDENT> print ( c ) <NEWLINE>
L , R , d = input ( ) . split ( ) <NEWLINE> <NL> L = int ( ) <NEWLINE> R = int ( ) <NEWLINE> d = int ( ) <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> for i in range ( L , R + 1 ) : <NEWLINE> <INDENT> if i % d == 0 : <NEWLINE> <INDENT> ans = ans + 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> <NL> for n in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> ans = 0 <NEWLINE> for x in range ( 1 , 15 ) : <NEWLINE> <INDENT> for y in range ( x , 20 ) : <NEWLINE> <INDENT> for z in range ( y , 35 ) : <NEWLINE> <INDENT> f = x ** 2 + y ** 2 + z ** 2 + x * y + x * z + y * z <NEWLINE> if f == n : <NEWLINE> <INDENT> if x == y == z : <NEWLINE> <INDENT> ans = 1 <NEWLINE> <DEDENT> elif ( x == y ) or ( y == z ) : <NEWLINE> <INDENT> ans = 3 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = 6 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
a = input ( ) <NEWLINE> b = map ( int , input ( ) . split ( ) ) <NEWLINE> c = list ( b ) <NEWLINE> i = 0 <NEWLINE> j = 1 <NEWLINE> <NL> for k in c : <NEWLINE> <INDENT> if j % 2 == 1 and int ( k ) % 2 == 1 : <NEWLINE> <INDENT> i += 1 <NEWLINE> <DEDENT> j += 1 <NEWLINE> <DEDENT> print ( i ) <NEWLINE>
L , R , d = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( R // d - ( L - 1 ) // d ) ac <NEWLINE>
import math <NEWLINE> import itertools as p <NEWLINE> l = int ( input ( ) ) <NEWLINE> r = int ( input ( ) ) <NEWLINE> d = int ( input ( ) ) <NEWLINE> count = 0 <NEWLINE> for i in range ( l , r + 1 ) : <NEWLINE> <INDENT> if i % d == 0 : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
L , R , d = map ( int , input ( ) . split ( ) ) <NEWLINE> count = 0 <NEWLINE> for L in range ( L , M ) : <NEWLINE> <INDENT> if ( L % 2 == 0 ) : <NEWLINE> <INDENT> count += 1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
list = list ( map ( int , inout ( ) . split ( ) ) ) <NEWLINE> large = list [ 1 ] // list [ 2 ] <NEWLINE> small = list [ 0 ] // list [ 2 ] <NEWLINE> amari = list [ 0 ] % list [ 2 ] <NEWLINE> if amari == 0 : <NEWLINE> <INDENT> print ( large - small + 1 ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> print ( large - small ) <NEWLINE> <DEDENT>
l , r , d = map ( int . input ( ) . split ( ) ) <NEWLINE> print ( r // d - ( l - 1 ) // d ) <NEWLINE>
a = int ( input ( ) ) <NEWLINE> b = int ( input ( ) ) <NEWLINE> c = int ( input ( ) ) <NEWLINE> l = [ ] <NEWLINE> <NL> for i in range ( a , b + 1 ) : <NEWLINE> <INDENT> if i % c == 0 : <NEWLINE> <INDENT> l . append ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( len ( l ) ) <NEWLINE>
, r , d = map ( int , input ( ) . split ( ) ) <NEWLINE> cnt = 0 <NEWLINE> for i in range ( l , r + 1 ) : <NEWLINE> <INDENT> if i % d == 0 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
L , R , d = ( input ( ) . split ( ) ) <NEWLINE> count = 0 <NEWLINE> for i range ( L , R + 1 ) : <NEWLINE> <INDENT> if i % d == 0 : <NEWLINE> <INDENT> count = count + 1 <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
numbers = map ( int , input ( ) . split ( ) ) <NEWLINE> number_list = [ i + numbers [ 0 ] for i in range ( numbers [ 1 ] - numbers [ 0 ] ) ] <NEWLINE> count = 0 <NEWLINE> for i in numbers_list : <NEWLINE> <INDENT> if number_list % numbers [ 2 ] == 0 : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
l , d , r = map ( int , input ( ) . split ( ) ) <NEWLINE> def div ( n ) : <NEWLINE> <INDENT> return True if n % r == 0 else False <NEWLINE> <DEDENT> print ( len ( filter ( div , range ( l , d + 1 ) ) ) ) <NEWLINE>
S = int ( input ( ) . split ( ) ) <NEWLINE> counter = 0 <NEWLINE> for _ in range ( S [ 0 ] , S [ 1 ] ) : <NEWLINE> <INDENT> if _ % S [ 2 ] == 0 : <NEWLINE> <INDENT> counter += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( counter ) <NEWLINE>
l , r , n = map ( int , input ( ) ) <NEWLINE> count = 0 <NEWLINE> for i in range ( l , r + 1 ) : <NEWLINE> <INDENT> if i % n == 0 : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
import numpy as np <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> <NL> ans = np . zeros ( int ( N ) ) <NEWLINE> <NL> if N < 10001 and N > 3 : <NEWLINE> <INDENT> maxa = int ( np . sqrt ( N - 2 ) ) <NEWLINE> for x in range ( 1 , maxa ) : <NEWLINE> <INDENT> for y in range ( 1 , x ) : <NEWLINE> <INDENT> for z in range ( 1 , y ) : <NEWLINE> <INDENT> p = x * x + y * y + z * z + x * y + y * z + z * x <NEWLINE> if p < N + 1 : <NEWLINE> <INDENT> ans [ p - 1 ] += 6 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for x in range ( 1 , maxa ) : <NEWLINE> <INDENT> for y in range ( 1 , x ) : <NEWLINE> <INDENT> p = x * x * 3 + y * y + x * y * 2 <NEWLINE> if p < N + 1 : <NEWLINE> <INDENT> ans [ p - 1 ] += 3 <NEWLINE> <DEDENT> p = y * y * 3 + x * x + x * y * 2 <NEWLINE> if p < N + 1 : <NEWLINE> <INDENT> ans [ p - 1 ] += 3 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for x in range ( 1 , maxa ) : <NEWLINE> <INDENT> p = x * x * 6 <NEWLINE> if p < N + 1 : <NEWLINE> <INDENT> ans [ p - 1 ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for x in range ( 0 , N ) : <NEWLINE> <INDENT> print ( int ( ans [ x ] ) ) <NEWLINE> <DEDENT>
l , r , d = map ( int , split ( ) ) <NEWLINE> sum = 0 <NEWLINE> for i in range ( l , r + 1 ) : <NEWLINE> <INDENT> if i % 2 == 0 : <NEWLINE> <INDENT> sum += 1 <NEWLINE> <DEDENT> <DEDENT> print ( sum ) <NEWLINE>
l , r , d = map ( int , input ( ) . split ( ) ) <NEWLINE> aa = // d <NEWLINE> bb = ( l - 1 ) // d <NEWLINE> print ( aa - bb ) <NEWLINE>
l , r , d = map ( int ( input ( ) ) . split ( ) ) <NEWLINE> print ( r // d - ( l - 1 ) // d ) <NEWLINE>
L , R , d = list ( map ( int , ( input ( ) . split ( ) ) ) ) <NEWLINE> if ( ( R // d - L // d ) == 99 ) : <NEWLINE> <INDENT> print ( 100 ) <NEWLINE> <DEDENT> elif ( ( ( R // d - L // d ) == 0 ) ) <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( R // d - L // d ) <NEWLINE> <DEDENT>
import math <NEWLINE> import collections <NEWLINE> import fractions <NEWLINE> import itertools <NEWLINE> import functools <NEWLINE> import operator <NEWLINE> <NL> def solve ( ) : <NEWLINE> <INDENT> l , r , d = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( l , r + 1 ) : <NEWLINE> <INDENT> if i % d == 0 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> priht ( ans ) <NEWLINE> return 0 <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> solve ( ) <NEWLINE> <NL> <DEDENT>
import sys <NEWLINE> read = sys . stdin . read <NEWLINE> readline = sys . stdin . readline <NEWLINE> readlines = sys . stdin . readlines <NEWLINE> from math import sqrt <NEWLINE> from collections import defaultdict <NEWLINE> def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> n2 = int ( sqrt ( n ) + 1 ) <NEWLINE> d1 = defaultdict ( int ) <NEWLINE> <NL> for i1 in range ( 1 , n2 ) : <NEWLINE> <INDENT> for i2 in range ( 1 , n2 ) : <NEWLINE> <INDENT> for i3 in range ( 1 , n2 ) : <NEWLINE> <COMMENT> <NL> <INDENT> p = i1 ** 2 + i2 ** 2 + i3 ** 2 + i1 * i2 + i2 * i3 + i1 * i3 <NEWLINE> d1 [ p ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for j1 in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> print ( d1 [ j1 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
L , R , d = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> count = 0 <NEWLINE> for i in range ( L , R + 1 ) : <NEWLINE> <INDENT> if i % d == 0 : <NEWLINE> <INDENT> count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> return count <NEWLINE>
L , R , d = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( L , R + 1 ) : <NEWLINE> <INDENT> if i % d = 0 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> a , b , c = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> kotae1 = math . floor ( b / c ) <NEWLINE> kotae2 = math . floor ( a / c ) <NEWLINE> ans = kotae1 - kotae2 <NEWLINE> if ( c == 1 ) : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if ( a == c ) : <NEWLINE> ans += 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> a , b , d = map ( int , input ( ) . split ( ) ) <NEWLINE> c = 0 <NEWLINE> for i in range ( l , r + 1 ) : <NEWLINE> <INDENT> if i % d == 0 : <NEWLINE> <INDENT> c += 1 <NEWLINE> <DEDENT> <DEDENT> print ( c ) <NEWLINE>
l , r , d = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( r // d - ( l - 1 ) // d ) ) <NEWLINE>
def solve ( L , R , d ) : <NEWLINE> <INDENT> count = 0 <NEWLINE> for i in range ( L , R + 1 ) : <NEWLINE> <INDENT> if i % d == 0 : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> return count <NEWLINE> <DEDENT> L , R , D = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( solve ( L , R , d ) ) <NEWLINE>
l , r , k = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i inrange ( l , r + 1 ) : <NEWLINE> <INDENT> if i // k == 0 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
l , r , d = map ( int , input . split ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( l , r + 1 ) : <NEWLINE> <INDENT> if i % d == 0 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> a = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( 0 , N + 1 , 2 ) : <NEWLINE> <INDENT> print ( a [ i ] ) <NEWLINE> if a [ i ] % 2 != 0 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> ans = 0 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> if ( i + 1 ) % 2 == 1 and a [ i ] % 2 == 1 : <NEWLINE> <INDENT> c += 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> n , * a = map ( int , read ( ) . split ( ) ) <NEWLINE> r = 0 <NEWLINE> for i1 , ae in enumerate ( a ) : <NEWLINE> <INDENT> if ( i1 + 1 ) & 1 and ae & 1 : <NEWLINE> <INDENT> r += 1 <NEWLINE> <DEDENT> <DEDENT> print ( r ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> arr = [ int ( j ) for j in input ( ) . split ( ) ] <NEWLINE> count = 0 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if i % 2 == 1 & & arr [ i - 1 ] % 2 == 1 : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> row = list ( map ( int , input ( ) . strip ( ) . split ( ) ) ) <NEWLINE> count = 0 <NEWLINE> for i range ( 0 , N , 2 ) : <NEWLINE> <INDENT> if row [ i ] % 2 == 0 : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> lst = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> count = 0 <NEWLINE> <NL> for i in range ( 1 , n + 1 , 2 ) : <NEWLINE> <INDENT> if lst [ i ] % 2 == 0 : <NEWLINE> <INDENT> count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 0 , n , 2 ) : <NEWLINE> <INDENT> if a [ i ] % 2 == 1 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = input ( ) <NEWLINE> a = 0 <NEWLINE> for i in range ( 0 , int ( N ) , 2 ) : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> if s % 2 != 0 : <NEWLINE> <INDENT> a = a + 1 <NEWLINE> <DEDENT> <DEDENT> print ( a ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> li = [ ] <NEWLINE> for i in input ( ) . split ( ) : <NEWLINE> <INDENT> li . append ( int ( i ) ) <NEWLINE> <NL> <DEDENT> a = 1 <NEWLINE> count = 0 <NEWLINE> for i in li : <NEWLINE> <INDENT> if a % 2 == 1 and li % 2 == 1 : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> a += 1 <NEWLINE> <DEDENT> print ( count ) <NEWLINE>
<NL> N = 15 <NEWLINE> input = input ( ) <NEWLINE> <NL> masu = [ int ( r ) for r in input . split ( ) ] <NEWLINE> ans = [ ] <NEWLINE> <NL> for i in range ( 1 , N + 1 , 2 ) : <NEWLINE> <NL> <INDENT> if masu [ i - 1 ] % 2 == 1 and i % 2 == 1 : <NEWLINE> <INDENT> ans . append ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( len ( ans ) ) <NEWLINE>
<COMMENT> <NL> range = int ( input ( ) ) <NEWLINE> input = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> count = 0 <NEWLINE> for i in range ( range ) : <NEWLINE> <INDENT> if ( i + 1 ) % 2 == 1 and list [ i ] % 2 == 1 : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> arr = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c = 0 <NEWLINE> for i in range n : <NEWLINE> <INDENT> if i % 2 != 0 and arr [ i ] % 2 != 0 : <NEWLINE> <INDENT> c += 1 <NEWLINE> <DEDENT> <DEDENT> print ( c ) <NEWLINE>
N N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> for a in range ( 0 , len ( A ) , 2 ) : <NEWLINE> <INDENT> if A [ a ] % 2 == 1 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> ai = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> <NL> <NL> c = 0 <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> if i % 2 == 1 and a [ i ] % 2 == 1 : <NEWLINE> <INDENT> c += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( c ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> count = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if i % 2 == 0 and A [ i ] % 2 == 1 : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> arr = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> s = 0 <NEWLINE> for i in range ( 0 , n , 2 ) : <NEWLINE> <INDENT> if arr [ i ] % 2 : ans += 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> table = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> num = 0 <NEWLINE> for i in table : <NEWLINE> <INDENT> if i % 2 == 1 and ( table [ i ] ) % 2 == 1 : <NEWLINE> <INDENT> num += 1 <NEWLINE> <DEDENT> print ( num ) <NEWLINE> <DEDENT>
x = int ( input ( ) ) <NEWLINE> c = [ i for i in range ( 1 , x + 1 ) ] <NEWLINE> l = map ( int , input ( ) . split ( ) ) <NEWLINE> count = 0 <NEWLINE> for i , j in zip ( c , l ) : <NEWLINE> <INDENT> if i % 2 == 1 and j % 2 == 1 : <NEWLINE> <INDENT> count += 1 a <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> res = 0 <NEWLINE> for i in range ( 1 , n + 1 , 2 ) : <NEWLINE> <INDENT> if a [ i ] % 2 != 0 : <NEWLINE> <INDENT> res += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( res ) <NEWLINE>
A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c = 0 <NEWLINE> for i in range ( 0 , len ( A ) , 2 ) : <NEWLINE> <INDENT> if A [ i ] % 2 = 1 : <NEWLINE> <INDENT> c += 1 <NEWLINE> <DEDENT> <DEDENT> print ( c ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> z = list ( int ( input ( ) . split ( ) ) ) <NEWLINE> odd = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if i % 2 == 1 : <NEWLINE> <INDENT> if int ( z [ i ] ) % 2 == 1 : <NEWLINE> <INDENT> odd += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( odd ) <NEWLINE>
<INDENT> = int ( input ( ) ) <NEWLINE> <DEDENT> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> print ( len ( [ i for i , ai in enumerate ( a ) if i % 2 and ai % 2 ] ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if i % 2 == 0 and a [ i ] % 2 == 1 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> count = 0 <NEWLINE> for i in range ( 0 , n .2 ) : <NEWLINE> <INDENT> if a [ i ] % 2 == 1 : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) ) ) <NEWLINE> count = 0 <NEWLINE> for i in range ( 0 , n , 2 ) : <NEWLINE> <INDENT> if a [ i ] % 2 == 1 : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if ( i + 1 ) % 2 == 1 and a [ i ] % 2 == 1 : <NEWLINE> <INDENT> c += 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> c = 0 <NEWLINE> cc = 0 <NEWLINE> for i in a : <NEWLINE> <INDENT> c += 1 <NEWLINE> <INDENT> if c % 2 == 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if i % 2 != 0 : <NEWLINE> <INDENT> cc += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( cc ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> l = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( 0 , n , 2 ) : <NEWLINE> <INDENT> if l [ i ] % 2 == 1 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if ( i + 1 ) % 2 == 1 and a [ i ] % 2 == 1 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> import itertools <NEWLINE> import numpy as np <NEWLINE> <NL> t = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> num = 0 <NEWLINE> for i in range ( t ) : <NEWLINE> <INDENT> if i % 2 == 0 and g_all [ i ] % 2 == 1 : <NEWLINE> <INDENT> num += 1 <NEWLINE> <DEDENT> <DEDENT> print ( num ) <NEWLINE>
<COMMENT> <NL> import math <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> <COMMENT> <NL> ai = input ( ) . split ( <STRING> ) <NEWLINE> <COMMENT> <NL> num = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if i % 2 == 0 : <NEWLINE> <INDENT> if int ( ai [ i * 2 ] ) % 2 == 1 : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <INDENT> num += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( num ) <NEWLINE>
<COMMENT> <NL> def abc173_a ( lines ) : <NEWLINE> <INDENT> N = int ( lines [ 0 ] ) <NEWLINE> values = map ( int , lines [ 1 ] . split ( <STRING> ) ) <NEWLINE> answer = 0 <NEWLINE> tmp = list ( ) <NEWLINE> for value in values : <NEWLINE> <INDENT> tmp . append ( value ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> print ( <STRING> ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if i % 2 != 0 : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if tmp [ i ] % 2 != 0 : <NEWLINE> <INDENT> answer += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return [ answer ] <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> def get_input_lines ( lines_count ) : <NEWLINE> <INDENT> lines = list ( ) <NEWLINE> for _ in range ( lines_count ) : <NEWLINE> <INDENT> lines . append ( input ( ) ) <NEWLINE> <DEDENT> return lines <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> def get_testdata ( pattern ) : <NEWLINE> <INDENT> if pattern == 1 : <NEWLINE> <INDENT> lines_input = [ <STRING> , <STRING> ] <NEWLINE> lines_export = [ 2 ] <NEWLINE> <DEDENT> elif pattern == 2 : <NEWLINE> <INDENT> lines_input = [ <STRING> , <STRING> ] <NEWLINE> lines_export = [ 3 ] <NEWLINE> <DEDENT> return lines_input , lines_export <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> def get_mode ( ) : <NEWLINE> <INDENT> import sys <NEWLINE> args = sys . argv <NEWLINE> if len ( args ) == 1 : <NEWLINE> <INDENT> mode = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> mode = int ( args [ 1 ] ) <NEWLINE> <DEDENT> return mode <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> mode = get_mode ( ) <NEWLINE> if mode == 0 : <NEWLINE> <INDENT> lines_input = get_input_lines ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> lines_input , lines_export = get_testdata ( mode ) <NEWLINE> <NL> <DEDENT> lines_result = abc173_a ( lines_input ) <NEWLINE> <NL> for line_result in lines_result : <NEWLINE> <INDENT> print ( line_result ) <NEWLINE> <NL> <DEDENT> if mode > 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> print ( <STRING> ) <NEWLINE> print ( <STRING> ) <NEWLINE> if lines_result == lines_export : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in range ( a ) : <NEWLINE> <INDENT> if ( i + 1 ) * a [ i ] % 2 != 1 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> numList = list ( ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> numList . append ( int ( input ( ) ) ) <NEWLINE> <DEDENT> sum , ctr = 0 , 1 <NEWLINE> for i in numList : <NEWLINE> <INDENT> if i == 0 : continue <NEWLINE> elif i % 2 != 0 and ctr % 2 != 0 : <NEWLINE> <INDENT> sum = sum + 1 <NEWLINE> <DEDENT> ctr = ctr + 1 <NEWLINE> <DEDENT> print ( sum ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c = 0 <NEWLINE> for i in range ( 1 , len ( a ) + 1 , 2 ) : <NEWLINE> <INDENT> if a [ i ] % 2 == 1 : <NEWLINE> <INDENT> c += 1 <NEWLINE> <DEDENT> <DEDENT> print ( c ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> m = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if i % 2 == 0 and l [ i ] % 2 != 0 : <NEWLINE> <INDENT> m . append ( l [ i ] ) <NEWLINE> <DEDENT> <DEDENT> print ( count ( m ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> a = [ int ( a ) for i , a in enumerate ( input ( ) . split ( ) ) if i % 2 == 0 ] <NEWLINE> ans = [ i for i in a if a % 2 == 1 ] <NEWLINE> print ( len ( ans ) ) <NEWLINE>
mass = int ( input ( ) ) <NEWLINE> number = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> cnt = 0 <NEWLINE> <NL> for i in mass : <NEWLINE> <INDENT> if ( i + 1 ) % 2 != 0 and number [ i ] % 2 != 0 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
<INDENT> = int ( input ( ) ) <NEWLINE> <DEDENT> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> cnt = 0 <NEWLINE> for i in range ( 0 , N ) : <NEWLINE> <INDENT> if ( i + 1 ) % 2 != 0 and a [ i ] % 2 != 0 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
n = input ( ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> count = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if i % 2 == 1 and l [ i ] % 2 == 1 : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
n = int ( input ) <NEWLINE> L = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> count = 0 <NEWLINE> for i in range ( 1 , n + 1 , 2 ) : <NEWLINE> <INDENT> if ( L [ i - 1 ] % 2 == 0 ) : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 0 , n , 2 ) : <NEWLINE> <INDENT> if a [ i ] & 1 : <NEWLINE> ans += 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> res = 0 <NEWLINE> for i in range ( 1 , len ( A ) + 1 , 2 ) : <NEWLINE> <INDENT> res += A [ i ] % 2 <NEWLINE> <DEDENT> print ( res ) <NEWLINE>
n = int ( input ( ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> cnt = 0 <NEWLINE> for i in range ( len ( a ) ) : <NEWLINE> <INDENT> if ( i + 1 ) % 2 != 0 and a [ i ] % 2 != 0 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> arr = list ( int , input ( ) . split ( ) ) <NEWLINE> arr = arr [ : : 2 ] <NEWLINE> def odd ( n ) : return ( n % 2 == 1 ) <NEWLINE> lst = filter ( odd , arr ) <NEWLINE> print ( len ( lst ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> masu = [ int ( x ) for x in input ( ) . split ( <STRING> ) ] <NEWLINE> c = 0 <NEWLINE> for i in range ( 0 , N , 2 ) <NEWLINE> <INDENT> if masu [ i ] % 2 != 0 : <NEWLINE> <INDENT> c += 1 <NEWLINE> <DEDENT> <DEDENT> print ( c ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> a = list ( int , map ( input ( ) . split ( ) ) <NEWLINE> i = 0 <NEWLINE> for z in range ( N ) <NEWLINE> <INDENT> for x , y in enumerate a : <NEWLINE> <INDENT> b = x + 1 <NEWLINE> if b % 2 != 0 and y % 2 != 0 : <NEWLINE> i += 1 <NEWLINE> <DEDENT> <DEDENT> print ( i ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> cnt = 0 <NEWLINE> <NL> for t in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> if t % 2 != 0 and A [ t ] % 2 != 0 : <NEWLINE> <INDENT> cnt = cnt + 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
import numpy as np <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = np . array ( li , <NEWLINE> A = A . reshape ( ( int ( N / 2 ) , 2 ) ) [ : , 0 ] if N % 2 == 0 else np . append ( A , 2 , 100 ) . reshape ( ( int ( ( N + 1 ) / 2 ) , 2 ) ) [ : , 0 ] <NEWLINE> print ( ( A % 2 == 1 ) . sum ( ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if i % 2 == 0 AND A [ i ] % 2 == 1 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
def solve ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> cnt = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if i % 2 == 0 and a [ i ] % 2 == 1 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> solve ( ) <NEWLINE> <DEDENT>
N = map ( int , input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> counter = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> print ( a [ i ] ) <NEWLINE> <DEDENT>
N = int ( input ( ) . rstrip ( ) ) <NEWLINE> a = input ( ) . rstrip ( ) . split ( <STRING> ) <NEWLINE> num = 0 <NEWLINE> for i in range ( 0 , N , 1 ) : <NEWLINE> <INDENT> if a [ i ] % 2 == 1 : <NEWLINE> <INDENT> num += 1 <NEWLINE> <DEDENT> <DEDENT> print ( num ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> ans = [ 0 for _ in range ( 10050 ) ] <NEWLINE> <NL> for i in range ( 1 , 105 ) : <NEWLINE> <INDENT> for j in range ( 1 , 105 ) : <NEWLINE> <INDENT> for k in range ( 1 , 105 ) : <NEWLINE> <INDENT> v = i * i + j * j + k * k + i * j + j * k + k * i ; <NEWLINE> <NL> if v < 10050 : <NEWLINE> ans [ v ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> print ( ans [ i + 1 ] ) <NEWLINE> <DEDENT>
max_number = int ( input ( ) ) <NEWLINE> list_numbers = [ i + 1 for i in range ( max_number ) ] <NEWLINE> count = 0 <NEWLINE> for i in list_numbers : <NEWLINE> <INDENT> count = 0 <NEWLINE> for x in range ( 1 , 100 ) : <NEWLINE> <INDENT> for y in range ( 1 , 100 ) : <NEWLINE> <INDENT> for z in range ( 1 , 100 ) : <NEWLINE> <INDENT> tot = x ** 2 + y ** 2 + z ** 2 + x * y + y * z + z * x <NEWLINE> if ( tot == i ) : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> cnt = [ 0 for i in range ( 10001 ) ] <NEWLINE> <NL> for x in range ( 1 , 101 ) : <NEWLINE> <INDENT> for y in range ( 1 , 105 ) : <NEWLINE> <INDENT> for z in range ( 1 , 105 ) : <NEWLINE> <INDENT> ans = x ** 2 + y ** 2 + z ** 2 + x * y + y * z + z * x <NEWLINE> if ans <= 10000 : <NEWLINE> <INDENT> cnt [ ans ] += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> print ( cnt [ i ] ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> ans = [ 0 for _ in range ( 10050 ) ] <NEWLINE> for i in range ( 1 , 105 ) : <NEWLINE> <INDENT> for j in range ( 1 , 105 ) : <NEWLINE> <INDENT> for k in range ( 1 , 105 ) : <NEWLINE> <INDENT> v = i * i + j * j + k * k + i * j + j * k + k * i ; <NEWLINE> if v < 10050 : <NEWLINE> ans [ v ] += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> print ( ans [ i + 1 ] ) <NEWLINE> <DEDENT>
def foo ( x , y , z ) : <NEWLINE> <INDENT> return x * ( x + y ) + y * ( y + z ) + z * ( z + x ) <NEWLINE> <NL> <DEDENT> N = int ( input ( ) ) <NEWLINE> <NL> F = [ 0 for i in range ( N ) ] <NEWLINE> <NL> for i in range ( 1 , N // 6 + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , N // 6 + 1 ) : <NEWLINE> <INDENT> for k in range ( 1 , N // 6 + 1 ) : <NEWLINE> <INDENT> X = foo ( i , j , k ) <NEWLINE> F [ X ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for i in F : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT>
<COMMENT> <NL> import sys <NEWLINE> <NL> from sys import stdin <NEWLINE> input = lambda : stdin . readline ( ) . rstrip ( ) <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> <NL> l = [ 0 ] * N <NEWLINE> for x in range ( 1 , 100 ) : <NEWLINE> <INDENT> for y in range ( 1 , 100 ) : <NEWLINE> <INDENT> for z in range ( 1 , 100 ) : <NEWLINE> <INDENT> v = x ** 2 + y ** 2 + z ** 2 + x * y + y * z + z * x <NEWLINE> if v <= N : <NEWLINE> <INDENT> l [ v - 1 ] = l [ v - 1 ] + 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> import matplotlib . pyplot as plt <NEWLINE> <NL> for i in l : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> <NL> for x in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> for i in range ( 1 , 100 ) : <NEWLINE> <INDENT> for j in range ( 1 , 100 ) : <NEWLINE> <INDENT> for k in range ( 1 , 100 ) : <NEWLINE> <INDENT> if ( i + j + k ) ** 2 - ( i * j + i * k + j * k ) == x : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> <NL> lis = [ ] <NEWLINE> <NL> for k in range ( 1 , 101 ) : <NEWLINE> <INDENT> for l in range ( 1 , 101 ) : <NEWLINE> <INDENT> for m in range ( 1 , 101 ) : <NEWLINE> <INDENT> lis . append ( k ** 2 + l ** 2 + m ** 2 + k * l + l * m + m * k ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for p in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> print ( lis . count ( p ) ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> arr = [ 0 ] * ( N + 2 ) <NEWLINE> <NL> for x in range ( 1 , 151 ) : <NEWLINE> <INDENT> for y in range ( 1 , 151 ) : <NEWLINE> <INDENT> for z in range ( 1 , 151 ) : <NEWLINE> <INDENT> n = x ** 2 + y ** 2 + z ** 2 + x * y + y * z + x * z <NEWLINE> if n <= N : <NEWLINE> <INDENT> arr [ n ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> print ( arr [ i ] ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> <NL> ans = [ 0 ] * ( N + 1 ) <NEWLINE> for x in range ( 1 , 101 ) : <NEWLINE> <INDENT> for y in range ( 1 , 101 ) : <NEWLINE> <INDENT> for z in range ( 1 , 101 ) : <NEWLINE> <INDENT> n = x ^ 2 + y ^ 2 + z ^ 2 + xy + yz + zx <NEWLINE> if n <= N : <NEWLINE> <INDENT> ans [ n ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for i in range ( 1 , N ) : <NEWLINE> <INDENT> print ( ans [ i ] ) <NEWLINE> <DEDENT>
L = [ ] <NEWLINE> i = 0 <NEWLINE> while i < 10000 : <NEWLINE> <INDENT> L . append ( 0 ) <NEWLINE> i += 1 <NEWLINE> <DEDENT> for x0 in range ( 1 , 100 ) : <NEWLINE> <INDENT> for y0 in range ( 1 , 100 ) : <NEWLINE> <INDENT> for z0 in range ( 1 , 100 ) : <NEWLINE> <INDENT> p = x0 ** 2 + y0 ** 2 + z0 ** 2 + x0 * y0 + y0 * z0 + z0 * x0 <NEWLINE> if p < 10001 : <NEWLINE> <INDENT> L [ p ] += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> N = int ( input ( ) ) <NEWLINE> for i in range ( 0 , N ) : <NEWLINE> <INDENT> print ( L [ i ] ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> num = [ 0 ] * 1000 <NEWLINE> <NL> for x in range ( 1 , 100 ) : <NEWLINE> <INDENT> for y in range ( 1 , 100 ) : <NEWLINE> <INDENT> for z in range ( 1 , 100 ) : <NEWLINE> <INDENT> a = x ** 2 + y ** 2 + z ** 2 + x * y + y * z + z * x - 1 <NEWLINE> if a <= 1001 : <NEWLINE> <INDENT> num [ a ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> num = num [ : n ] <NEWLINE> <NL> for i in num : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> <NL> <NL> def calc ( c ) : <NEWLINE> <INDENT> g = 0 <NEWLINE> for x in range ( 1 , 101 ) : <NEWLINE> <INDENT> for y in range ( 1 , 101 ) : <NEWLINE> <INDENT> for z in range ( 1 , 101 ) : <NEWLINE> <INDENT> if ( x * x ) + ( y * y ) + ( z * z ) + x * y + y * z + x * z == c : <NEWLINE> <INDENT> g += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> return g <NEWLINE> <NL> <NL> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> print ( calc ( i ) ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> ans = [ 0 for _in range ( 10050 ) ] <NEWLINE> <INDENT> for i in range ( 1 , 105 ) : <NEWLINE> <INDENT> for j in range ( 1 , 105 ) : <NEWLINE> <INDENT> for k in range ( 1 , 105 ) : <NEWLINE> <INDENT> v = i * i + j * j + k * k + i * j + j * k + k * i ; <NEWLINE> <INDENT> if v < 10050 : <NEWLINE> <INDENT> ans [ v ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> print ( ans [ i + 1 ] ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> <NL> def input ( ) : return sys . stdin . readline ( ) . strip ( ) <NEWLINE> def I ( ) : return int ( input ( ) ) <NEWLINE> def LI ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> def IR ( n ) : return [ I ( ) for i in range ( n ) ] <NEWLINE> def LIR ( n ) : return [ LI ( ) for i in range ( n ) ] <NEWLINE> def SR ( n ) : return [ S ( ) for i in range ( n ) ] <NEWLINE> def S ( ) : return input ( ) <NEWLINE> def LS ( ) : return input ( ) . split ( ) <NEWLINE> <NL> <NL> INF = float ( <STRING> ) <NEWLINE> <NL> <NL> n = I ( ) <NEWLINE> cnt = [ 0 ] * 10001 <NEWLINE> r_n = int ( math . sqrt ( n ) ) + 1 <NEWLINE> for x in range ( 1 , r_n ) : <NEWLINE> <INDENT> for y in range ( 1 , r_n ) : <NEWLINE> <INDENT> for z in range ( 1 , r_n ) : <NEWLINE> <INDENT> v = x ** 2 + y ** 2 + z ** 2 + x * y + y * z + z * x <NEWLINE> if v <= n : <NEWLINE> <INDENT> cnt [ v ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> print ( cnt [ i ] ) <NEWLINE> <DEDENT>
<NL> import itertools <NEWLINE> import math <NEWLINE> <NL> def main ( ) : <NEWLINE> <NL> <INDENT> input_lines_n = input ( ) <NEWLINE> n = int ( input_lines_n ) <NEWLINE> xyz_max = 100 <NEWLINE> <NL> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> ans = 0 <NEWLINE> cnt = 0 <NEWLINE> for x , y , z in itertools . product ( range ( xyz_max ) , range ( xyz_max ) , range ( xyz_max ) ) : <NEWLINE> <INDENT> if x > 0 and y > 0 and z > 0 : <NEWLINE> <COMMENT> <NL> <INDENT> ans = ( x + y + z ) ** 2 - ( x * y + y * z + z * x ) <NEWLINE> if ans == i : <NEWLINE> <INDENT> cnt = cnt + 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> cnt = [ 0 for i in range ( 10001 ) ] <NEWLINE> <NL> for x in range ( 1 , 101 ) : <NEWLINE> <INDENT> for y in range ( 1 , 105 ) : <NEWLINE> <INDENT> for z in range ( 1 , 105 ) : <NEWLINE> <INDENT> ans = x ** 2 + y ** 2 + z ** 2 + x * y + y * z + z * x <NEWLINE> if ans <= 10000 : <NEWLINE> <INDENT> cnt [ ans ] += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> print ( cnt [ i ] ) <NEWLINE> <DEDENT>
def f ( N ) : <NEWLINE> <INDENT> global table <NEWLINE> for x , y , z in combinations_with_replacement ( range ( 1 , 100 ) , 3 ) : <NEWLINE> <INDENT> n = x ** 2 + y ** 2 + z ** 2 + x * y + y * z + z * x <NEWLINE> if n > N : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if x == y == z : <NEWLINE> <INDENT> table [ n ] = 1 <NEWLINE> <DEDENT> elif x == y or y == z or z == x : <NEWLINE> <INDENT> table [ n ] = 3 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> table [ n ] = 6 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> N = int ( input ( ) ) <NEWLINE> table = [ 0 for _ in range ( N + 1 ) ] <NEWLINE> f ( N ) <NEWLINE> for n in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> print ( table [ n ] ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> X = str ( input ( ) ) <NEWLINE> <NL> V = [ 1 ] * 200000 <NEWLINE> for i in range ( 2 , 200001 ) : <NEWLINE> <INDENT> a = i <NEWLINE> b = str ( bin ( i ) ) <NEWLINE> C = 0 <NEWLINE> for j in range ( 0 , len ( b ) ) : <NEWLINE> <INDENT> if b [ j ] == <STRING> : <NEWLINE> <INDENT> C += 1 <NEWLINE> <DEDENT> <DEDENT> d = a % C <NEWLINE> if d == 0 : <NEWLINE> <INDENT> V [ i - 1 ] = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> V [ i - 1 ] = V [ d - 1 ] + 1 <NEWLINE> <NL> <DEDENT> <DEDENT> c = 0 <NEWLINE> for i in range ( 0 , len ( X ) ) : <NEWLINE> <INDENT> if X [ i ] == <STRING> : <NEWLINE> <INDENT> c += 1 <NEWLINE> <DEDENT> <DEDENT> length = len ( X ) <NEWLINE> <NL> binaryA = [ ] <NEWLINE> for i in range ( 0 , length ) : <NEWLINE> <INDENT> binaryA . append ( 2 ** i ) <NEWLINE> <NL> <DEDENT> for i in range ( 0 , length ) : <NEWLINE> <INDENT> e = c <NEWLINE> if X [ i ] == <STRING> : <NEWLINE> <INDENT> e += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> e -= 1 <NEWLINE> <DEDENT> a = int ( X , base = 2 ) ^ binaryA [ length - 1 - i ] <NEWLINE> if a == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> d = a % e <NEWLINE> if d == 0 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( V [ d - 1 ] + 1 ) <NEWLINE> <DEDENT> <DEDENT>
import math <NEWLINE> n = int ( input ( ) ) <NEWLINE> l = [ 0 for i in range ( n ) ] <NEWLINE> p = min ( 101 , math . sqrt ( n ) + 1 ) <NEWLINE> for x in range ( 1 , p ) : <NEWLINE> <INDENT> for y in range ( 1 , p ) : <NEWLINE> <INDENT> for z in range ( 1 , p ) : <NEWLINE> <INDENT> s = x ** 2 + y ** 2 + z ** 2 + x * y + y * z + z * x ; <NEWLINE> if s <= n : <NEWLINE> <INDENT> l [ s - 1 ] += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> print ( l [ i ] ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> <NL> counts = [ 0 ] * 10001 <NEWLINE> for i in range ( 1 , 311 ) : <NEWLINE> <INDENT> for j in range ( 1 , i + 1 ) : <NEWLINE> <INDENT> for k in range ( 1 , j + 1 ) : <NEWLINE> <INDENT> result = i ** 2 + j ** 2 + k ** 2 + i * j + j * k + k * i <NEWLINE> if result > 10000 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if i == j and j == k : <NEWLINE> <INDENT> counts [ result ] += 1 <NEWLINE> <DEDENT> elif i == j or j == k : <NEWLINE> <INDENT> counts [ result ] += 3 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> counts [ result ] += 6 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for n in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> print ( counts [ n ] ) <NEWLINE> <DEDENT>
import math <NEWLINE> from queue import PriorityQueue <NEWLINE> from sys import stdin , stdout <NEWLINE> from collections import defaultdict <NEWLINE> <NL> def solve ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> ans = [ 0 for _ in range ( 20005 ) ] <NEWLINE> for i in range ( 1 , 101 ) : <NEWLINE> <INDENT> for j in range ( 1 , 101 ) : <NEWLINE> <INDENT> for k in range ( 1 , 101 ) : <NEWLINE> <INDENT> v = i * i + j * j + k * k + i * j + k * j + k * i <NEWLINE> ans [ v ] += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> print ( ans [ i + 1 ] ) <NEWLINE> <NL> <NL> <NL> <NL> <NL> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <INDENT> solve ( ) <NEWLINE> <DEDENT> main ( ) <NEWLINE>
from sys import stdin <NEWLINE> data = int ( stdin . readline ( ) . rstrip ( ) ) <NEWLINE> <NL> list = [ ] <NEWLINE> for x in range ( 1 , 10 ** 2 ) : <NEWLINE> <INDENT> for y in range ( 1 , 10 ** 2 ) : <NEWLINE> <INDENT> for z in range ( 1 , 10 ** 2 ) : <NEWLINE> <INDENT> list . append ( x ** 2 + y ** 2 + z ** 2 + x * y + y * z + z * x ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for i in range ( 1 , data + 1 ) : <NEWLINE> <INDENT> print ( list . count ( i ) ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> ans = [ 0 for _ in range ( 10050 ) ] <NEWLINE> <NL> for x in range ( 1 , 100 + 1 ) : <NEWLINE> <INDENT> for y in range ( 1 , 100 + 1 ) : <NEWLINE> <INDENT> for z in range ( 1 , 100 + 1 ) : <NEWLINE> <INDENT> tmp = x ** 2 + y ** 2 + z ** 2 + x * y + y * z + z * x <NEWLINE> ans [ v ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> print ( ans [ i + 1 ] ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> list = [ ] * ( N + 1 ) <NEWLINE> <NL> M = int ( ( N - 2 ) ** 0.5 ) <NEWLINE> for x in range ( 1 , M + 1 ) : <NEWLINE> <INDENT> for y in range ( 1 , M + 1 ) : <NEWLINE> <INDENT> for z in range ( 1 , M + 1 ) : <NEWLINE> <INDENT> p = ( x + y ) * ( x + z ) + y ** 2 + z ** 2 <NEWLINE> if p > N : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> list [ p ] = list [ p ] + 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> print ( list [ i ] ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> def func ( n ) : <NEWLINE> <INDENT> ret = 0 <NEWLINE> for i in range ( p ) : <NEWLINE> <INDENT> for j in range ( p ) : <NEWLINE> <INDENT> for k in range ( p ) : <NEWLINE> <INDENT> if ( i + j ) ** 2 + ( j + k ) ** 2 + ( k + i ) ** 2 == 2 * p : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> print ( func ( i ) ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> l = [ ] <NEWLINE> for x in range ( 1 , 101 ) : <NEWLINE> <INDENT> for y in range ( 1 , 101 ) : <NEWLINE> <INDENT> for z in range ( 1 , 101 ) : <NEWLINE> <INDENT> l . append ( x ** 2 + y ** 2 + z ** 2 + x * y + y * z + z * x ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> print ( sum ( i == j for j in l ) ) <NEWLINE> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> ans = [ 0 for _ in range ( 10050 ) ] <NEWLINE> for i in range ( 1 , 105 ) : <NEWLINE> <INDENT> for j in range ( 1 , 105 ) : <NEWLINE> <INDENT> for k in range ( 1 , 105 ) : <NEWLINE> <INDENT> v = i * i + j * j + k * k + i * j + j * k + k * i ; <NEWLINE> if v < 10050 : <NEWLINE> <INDENT> ans [ v ] += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for i in range ( n ) : <NEWLINE> print ( ans [ i + 1 ] ) <NEWLINE>
from math import sqrt <NEWLINE> N = int ( input ( ) ) <NEWLINE> ans = [ 0 ] * N <NEWLINE> <NL> for x in range ( 1 , int ( sqrt ( n ) ) + 1 ) : <NEWLINE> <INDENT> for y in range ( 1 , int ( sqrt ( n ) ) + 1 ) : <NEWLINE> <INDENT> for z in range ( 1 , int ( sqrt ( n ) ) + 1 ) : <NEWLINE> <INDENT> n = x ** 2 + y ** 2 + z ** 2 + x * y + y * z + z * x <NEWLINE> if ans < n : <NEWLINE> <INDENT> ans [ n ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for a in ans : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> cnt = [ 0 for i in range ( 10001 ) ] <NEWLINE> <NL> for x in range ( 1 , 105 ) : <NEWLINE> <INDENT> for y in range ( 1 , 105 ) : <NEWLINE> <INDENT> for z in range ( 1 , 105 ) : <NEWLINE> <INDENT> ans = x ** 2 + y ** 2 + z ** 2 + x * y + y * z + z * x <NEWLINE> if ans <= 10000 : <NEWLINE> <INDENT> cnt [ ans ] += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> print ( cnt [ i ] ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> <NL> def input ( ) : return sys . stdin . readline ( ) . strip ( ) <NEWLINE> def I ( ) : return int ( input ( ) ) <NEWLINE> def LI ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> def IR ( n ) : return [ I ( ) for i in range ( n ) ] <NEWLINE> def LIR ( n ) : return [ LI ( ) for i in range ( n ) ] <NEWLINE> def SR ( n ) : return [ S ( ) for i in range ( n ) ] <NEWLINE> def S ( ) : return input ( ) <NEWLINE> def LS ( ) : return input ( ) . split ( ) <NEWLINE> <NL> <NL> INF = float ( <STRING> ) <NEWLINE> <NL> <NL> n = I ( ) <NEWLINE> cnt = [ 0 ] * 10001 <NEWLINE> for x in range ( 1 , r_n ) : <NEWLINE> <INDENT> for y in range ( 1 , r_n ) : <NEWLINE> <INDENT> for z in range ( 1 , r_n ) : <NEWLINE> <INDENT> v = x ** 2 + y ** 2 + z ** 2 + x * y + y * z + z * x <NEWLINE> if v <= n : <NEWLINE> <INDENT> cnt [ v ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> print ( cnt [ i ] ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = [ 0 ] * 10001 <NEWLINE> for i in range ( 101 ) : <NEWLINE> <INDENT> for j in range ( 101 ) : <NEWLINE> <INDENT> for k in range ( 101 ) : <NEWLINE> <INDENT> v = i ** 2 + j ** 2 + k ** 2 + i * j + j * k + k * i <NEWLINE> if v <= 10001 : <NEWLINE> <INDENT> a [ v ] += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for m in range ( n ) : <NEWLINE> <INDENT> print ( a [ m + 1 ] ) <NEWLINE> <DEDENT>
import collections <NEWLINE> import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> ans = [ 0 ] * n <NEWLINE> tmp = [ ] <NEWLINE> <COMMENT> <NL> for x in range ( 1 , int ( n ** 0.5 ) + 1 ) : <NEWLINE> <INDENT> for y in range ( 1 , int ( n ** 0.5 ) + 1 ) : <NEWLINE> <INDENT> for z in range ( 1 , int ( n ** 0.5 ) + 1 ) <NEWLINE> <INDENT> tmp . append ( x ** 2 + y ** 2 + z ** 2 + x * y + y * z + z * x ) <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> cnt = collections . Counter ( tmp ) <NEWLINE> <COMMENT> <NL> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> print ( cnt [ i ] ) <NEWLINE> <DEDENT>
from collections import Counter <NEWLINE> n = int ( input ( ) ) <NEWLINE> ans_list = [ 0 ] * ( 10 ** 4 ) <NEWLINE> for i in range ( 1 , 100 ) : <NEWLINE> <INDENT> for j in range ( 1 , 100 ) : <NEWLINE> <INDENT> for k in range ( 1 , 100 ) : <NEWLINE> <INDENT> ans = i ** 2 + j ** 2 + k ** 2 + i * j + j * k + k * i <NEWLINE> ans_list [ ans - 1 ] += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> for i in ans_list [ : n ] : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT>
import sys <NEWLINE> import math <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> <NL> def readstr ( ) : <NEWLINE> <INDENT> return input ( ) . strip ( ) <NEWLINE> <NL> <NL> <DEDENT> def readint ( ) : <NEWLINE> <INDENT> return int ( input ( ) ) <NEWLINE> <NL> <NL> <DEDENT> def readnums ( ) : <NEWLINE> <INDENT> return map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <NL> <DEDENT> def readstrs ( ) : <NEWLINE> <INDENT> return input ( ) . split ( ) <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> N = readint ( ) <NEWLINE> <NL> ans = { i : 0 for i in range ( 1 , N + 1 ) } <NEWLINE> for i in range ( 3 , 101 ) : <NEWLINE> <INDENT> for j in range ( 1 , i ) : <NEWLINE> <INDENT> for k in range ( 1 , i ) : <NEWLINE> <INDENT> l = i - j - k <NEWLINE> if l <= 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> v = j ** 2 + k ** 2 + l ** 2 + j * k + k * l + j * l <NEWLINE> ans [ v ] += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> print ( ans [ i ] ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> import math <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> <NL> <NL> count = [ 0 ] * 10050 <NEWLINE> for j in range ( 1 , 105 ) : <NEWLINE> <INDENT> for k in range ( 1 , 105 ) : <NEWLINE> <INDENT> for l in range ( 1 , 105 ) : <NEWLINE> <INDENT> v = ( j + k + l ) ** 2 - ( j * k + k * l + l * j ) <NEWLINE> if v <= 10050 : <NEWLINE> <INDENT> count [ v ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for i in range ( 1 , N ) : <NEWLINE> <INDENT> print ( count [ i ] ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> ans = [ 0 ] * ( n + 1 ) <NEWLINE> for x in range ( 1 , n ** 0.5 + 1 ) : <NEWLINE> <INDENT> for y in range ( 1 , n ** 0.5 + 1 ) : <NEWLINE> <INDENT> for z in range ( 1 , n ** 0.5 + 1 ) : <NEWLINE> <INDENT> if x ** 2 + y ** 2 + z ** 2 + x * y + y * z + z * x <= n : <NEWLINE> <INDENT> ans [ x ** 2 + y ** 2 + z ** 2 + x * y + y * z + z * x ] += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( * ans [ 1 : ] , sep = <STRING> ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> for l in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> ans = 0 <NEWLINE> for i in range ( 1 , 101 ) : <NEWLINE> <INDENT> for j in range ( 1 , 101 ) : <NEWLINE> <INDENT> for k in range ( 1 , 101 ) : <NEWLINE> <INDENT> f = i * i + j * j + k * k + i * j + j * k + k * i <NEWLINE> if f == l : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = [ 0 ] * ( 10 ** 5 ) <NEWLINE> for i in range ( 1 , 1000 ) : <NEWLINE> <INDENT> for j in range ( 1 , 1000 ) : <NEWLINE> <INDENT> for k in range ( 1 , 101 ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> a [ i * i + j * j + k * k + i * j + j * k + i * k ] += 1 <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> print ( a [ i ] ) <NEWLINE> <DEDENT>
<STRING> <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> import math ; from collections import * <NEWLINE> import sys ; from functools import reduce <NEWLINE> <NL> <COMMENT> <NL> <NL> def get_ints ( ) : return map ( int , input ( ) . strip ( ) . split ( ) ) <NEWLINE> def get_list ( ) : return list ( get_ints ( ) ) <NEWLINE> def get_string ( ) : return list ( input ( ) . strip ( ) . split ( ) ) <NEWLINE> def printxsp ( * args ) : return print ( * args , end = <STRING> ) <NEWLINE> def printsp ( * args ) : return print ( * args , end = <STRING> ) <NEWLINE> <NL> DIRECTIONS = [ [ 0 , 1 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , - 1 ] ] <COMMENT> <NEWLINE> NEIGHBOURS = [ ( i , j ) for i in range ( - 1 , 2 ) for j in range ( - 1 , 2 ) if ( i != 0 or j != 0 ) ] <NEWLINE> <NL> OrdUnicode_a = ord ( <STRING> ) ; OrdUnicode_A = ord ( <STRING> ) <NEWLINE> CAPS_ALPHABETS = { chr ( i + OrdUnicode_A ) : i for i in range ( 26 ) } <NEWLINE> SMOL_ALPHABETS = { chr ( i + OrdUnicode_a ) : i for i in range ( 26 ) } <NEWLINE> <NL> MOD_JOHAN = int ( 1e9 ) + 7 ; MOD_LIGHT = 998244353 ; INFINITY = float ( <STRING> ) <NEWLINE> MAXN_EYEPATCH = int ( 1e5 ) + 1 ; MAXN_FULLMETAL = 501 <NEWLINE> <NL> sys . stdin = open ( <STRING> , <STRING> ) ; sys . stdout = open ( <STRING> , <STRING> ) <NEWLINE> <NL> <COMMENT> <NL> n = int ( input ( ) ) <NEWLINE> ans = [ 0 ] * ( n + 1 ) <NEWLINE> i = 1 <NEWLINE> while i * i * i < n : <NEWLINE> <INDENT> i += 1 <NEWLINE> <DEDENT> n0001 = i + 1 <NEWLINE> for i in range ( 1 , n0001 ) : <NEWLINE> <INDENT> for j in range ( 1 , n0001 ) : <NEWLINE> <INDENT> for k in range ( 1 , n0001 ) : <NEWLINE> <INDENT> e = ( i ** 2 ) + ( j ** 2 ) + ( i * j ) + ( k ** 2 ) + ( j * k ) + ( i * k ) <NEWLINE> if e <= n : <NEWLINE> <COMMENT> <NL> <INDENT> ans [ e ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( * ans [ 1 : ] , sep = <STRING> ) <NEWLINE> <NL> <NL> <NL> <NL> <STRING> <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> lis = [ 0 ] * ( 10000 + 1 ) <NEWLINE> <NL> s = n ** 0.5 <NEWLINE> <NL> for i in range ( 1 , s ) : <NEWLINE> <INDENT> for j in range ( 1 , s ) : <NEWLINE> <INDENT> for k in range ( 1 , s ) : <NEWLINE> <INDENT> t = i ** 2 + j ** 2 + k ** 2 + i * j + j * k + i * k <NEWLINE> tmp = [ i , j , k ] <NEWLINE> <NL> if t <= 10001 : <NEWLINE> <INDENT> if len ( set ( tmp ) ) == 1 : <NEWLINE> <INDENT> lis [ t - 1 ] = 1 <NEWLINE> <DEDENT> elif len ( set ( tmp ) ) == 2 : <NEWLINE> <INDENT> lis [ t - 1 ] = 3 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> lis [ t - 1 ] = 6 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> print ( lis [ i ] ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> ans = [ 0 ] * 10050 <NEWLINE> <NL> for x in range ( 1 , 500 ) : <NEWLINE> <INDENT> for y in range ( 1 , 500 ) : <NEWLINE> <INDENT> for z in range ( 1 , 500 ) : <NEWLINE> <NL> <INDENT> f = x ** 2 + y ** 2 + z ** 2 + x * y + y * z + z * x <NEWLINE> <NL> if f < 10000 : <NEWLINE> <INDENT> ans [ f - 1 ] = ans [ f - 1 ] + 1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> print ( ans [ i ] ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) n = int ( input ( ) ) <NEWLINE> ans = [ 0 ] * 10001 <NEWLINE> <NL> for x in range ( 1 , 101 ) : <NEWLINE> <INDENT> for y in range ( 1 , 101 ) : <NEWLINE> <INDENT> for z in range ( 1 , 101 ) : <NEWLINE> <INDENT> mul = x * x + y * y + z * z + x * y + y * z + z * x <NEWLINE> if mul <= 10000 : <NEWLINE> <INDENT> ans [ mul ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> print ( ans [ i ] ) <NEWLINE> <NL> <NL> <DEDENT>
n = int ( input ( ) ) <NEWLINE> ans = [ 0 ] * ( n + 1 ) <NEWLINE> <NL> f = int ( math . sqrt ( n ) ) + 1 <NEWLINE> for x in range ( 1 , f ) : <NEWLINE> <INDENT> for y in range ( 1 , f ) : <NEWLINE> <INDENT> for z in range ( 1 , f ) : <NEWLINE> <INDENT> v = ( x ** 2 ) + ( y ** 2 ) + ( z ** 2 ) + ( x * y ) + ( y * z ) + ( z * x ) <NEWLINE> if v < n + 1 : <NEWLINE> <INDENT> ans [ v ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> print ( ans [ i + 1 ] ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> <NL> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> count = 0 <NEWLINE> if i < 6 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif i == 6 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for j in range ( 1 , 101 ) : <NEWLINE> <INDENT> for k in range ( 1 , 101 ) : <NEWLINE> <INDENT> for l in range ( 1 , 101 ) : <NEWLINE> <INDENT> if ( j ** 2 + k ** 2 + l ** 2 + j * k + k * l + l * j ) == i : <NEWLINE> <INDENT> count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE> <DEDENT> <DEDENT>
NN = int ( input ( ) ) <NEWLINE> A = [ 0 ] * N <NEWLINE> for x in range ( 1 , 101 ) : <NEWLINE> <INDENT> for y in range ( 1 , 101 ) : <NEWLINE> <INDENT> for z in range ( 1 , 101 ) : <NEWLINE> <INDENT> if x ** 2 + y ** 2 + z ** 2 + x * y + y * z + z * x <= N : <NEWLINE> <INDENT> A [ x ** 2 + y ** 2 + z ** 2 + x * y + y * z + z * x - 1 ] += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> print ( A [ i ] ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> ans = [ 0 ] <NEWLINE> for i in range ( 1 , 105 ) : <NEWLINE> <INDENT> for j in range ( 1 , 105 ) : <NEWLINE> <INDENT> for k in range ( 1 , 105 ) : <NEWLINE> <INDENT> v = i * i + j * j + k * k + i * j + j * k + k * i ; <NEWLINE> if v < 10050 : <NEWLINE> <COMMENT> <NL> <INDENT> ans [ v ] += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> print ( ans [ i + 1 ] ) <NEWLINE> <DEDENT>
n = 10000 <NEWLINE> ans = { } <NEWLINE> for x in range ( 1 , 100 ) : <NEWLINE> <INDENT> for y in range ( 1 , 100 ) : <NEWLINE> <INDENT> for z in range ( 1 , 100 ) : <NEWLINE> <INDENT> i = x ** 2 + y ** 2 + z ** 2 + x * y + y * z + z * x <NEWLINE> <INDENT> ans . setdefault ( i , 0 ) <NEWLINE> ans [ i ] += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> print ( ans [ i ] ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> def f ( a , b , c ) : <NEWLINE> <INDENT> return a ** 2 + b ** 2 + c ** 2 + a * b + b * c + c * a <NEWLINE> <NL> <DEDENT> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> if i < 6 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x , y , z = 0 , 0 , 0 <NEWLINE> ans = 0 <NEWLINE> while True : <NEWLINE> <INDENT> x += 1 <NEWLINE> y = 0 <NEWLINE> z = 0 <NEWLINE> if f ( x , y , z ) > i : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> while True : <NEWLINE> <INDENT> y += 1 <NEWLINE> z = 1 <NEWLINE> s = f ( x , y , z ) <NEWLINE> if s > i : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> while s <= i : <NEWLINE> <INDENT> if s == i : <NEWLINE> <INDENT> ans += 1 <NEWLINE> break <NEWLINE> <DEDENT> z += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <DEDENT> <DEDENT>
ans = [ 0 ] * ( N + 1 ) <NEWLINE> <NL> for i in range ( 1 , int ( N ** 0.5 ) + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , int ( N ** 0.5 ) + 2 ) : <NEWLINE> <INDENT> for k in range ( 1 , int ( N ** 0.5 ) + 2 ) : <NEWLINE> <INDENT> f = i * i + j * j + k * k + i * j + j * k + k * i <NEWLINE> if f <= N : <NEWLINE> <INDENT> ans [ f ] += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( * ans [ 1 : ] , sep = <STRING> ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> from numba import jit <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> <NL> loops = 0 <NEWLINE> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> @ jit ( <STRING> , cache = True ) <NEWLINE> def calc ( x , y , z ) : <NEWLINE> <INDENT> return x ** 2 + y ** 2 + z ** 2 + x * y + y * z + z * x <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> p_eq = [ 0 ] * ( 100 + 1 ) <NEWLINE> for xyz in range ( 1 , 100 + 1 ) : <NEWLINE> <INDENT> p_eq [ xyz ] = calc ( xyz , xyz , xyz ) <NEWLINE> <NL> <DEDENT> p_ne = [ ] <NEWLINE> for x in range ( 1 , 100 ) : <NEWLINE> <INDENT> for y in range ( 1 , 100 ) : <NEWLINE> <INDENT> if x + y > 100 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for z in range ( 1 , 100 ) : <NEWLINE> <INDENT> if x + y + z > 100 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> res = calc ( x , y , z ) <NEWLINE> p_ne . append ( res ) <NEWLINE> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> res = [ None ] * ( N + 1 ) <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> if i in p_eq : <NEWLINE> <INDENT> res [ i ] = 1 <NEWLINE> <DEDENT> elif i in p_ne : <NEWLINE> <INDENT> res [ i ] = 3 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> res [ i ] = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> for s in res [ 1 : ] : <NEWLINE> <INDENT> print ( s ) <NEWLINE> <COMMENT> <NL> <DEDENT>
import sys <NEWLINE> from math import ceil , floor , sqrt , sin , cos , pi <NEWLINE> from itertools import accumulate , permutations , combinations <NEWLINE> from fractions import gcd <COMMENT> <NEWLINE> from collections import deque , Counter <NEWLINE> from operator import itemgetter <NEWLINE> from heapq import heappop , heappush <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> def lcm ( x , y ) : return ( ( x * y ) // gcd ( x , y ) ) <COMMENT> <NEWLINE> <COMMENT> <NL> <NL> N = int ( input ( ) ) <NEWLINE> x = 0 <NEWLINE> ans = [ 0 for _ in range ( N ) ] <NEWLINE> maxv = ceil ( sqrt ( N ) ) + 1 <NEWLINE> for x in range ( 1 , maxv ) : <NEWLINE> <INDENT> for y in range ( 1 , maxv ) : <NEWLINE> <INDENT> for z in range ( 1 , maxv ) : <NEWLINE> <INDENT> f = x * x + y * y + z * z + x * y + y * z + z * x - 1 <NEWLINE> if f > N : continue <NEWLINE> ans [ f ] += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> print ( ans [ i ] ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> <NL> tmp = [ ] <NEWLINE> num = [ 0 ] * ( 10 ** 9 ) <NEWLINE> for i in range ( 1 , 10 ** 2 + 1 ) : <NEWLINE> <INDENT> tmp . append ( i ** 2 ) <NEWLINE> <NL> <DEDENT> for x in tmp : <NEWLINE> <INDENT> xx = int ( x ** 0.5 ) <NEWLINE> for y in tmp : <NEWLINE> <INDENT> yy = int ( y ** 0.5 ) <NEWLINE> for z in tmp : <NEWLINE> <INDENT> zz = int ( z ** 0.5 ) <NEWLINE> ans = x + y + z + xx * yy + yy * zz + zz * xx <NEWLINE> num [ ans ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> print ( num [ i ] ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> d = dict ( { i : 0 for i in range ( 1 , n + 1 ) } ) <NEWLINE> for s in range ( 3 , 501 ) : <NEWLINE> <INDENT> for x in range ( 1 , s + 1 - 2 ) : <NEWLINE> <INDENT> for y in range ( 1 , s + 1 - x - 1 ) : <NEWLINE> <INDENT> z = s - x - y <NEWLINE> if x < y or y < z : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> v = x ** 2 + y ** 2 + z ** 2 + x * y + y * z + z * x <NEWLINE> if not v in d : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if x == y == z : <NEWLINE> <INDENT> d [ v ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d [ v ] += 3 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for k in d . keys ( ) : <NEWLINE> <INDENT> print ( d [ k ] ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> ls = [ 0 ] * ( N + 2 ) <NEWLINE> <NL> for i in range ( 1 , 151 ) : <NEWLINE> <INDENT> for j in range ( 1 , 151 ) : <NEWLINE> <INDENT> for k in range ( 1 , 151 ) : <NEWLINE> <INDENT> t = i ** 2 + j ** 2 + k ** 2 + i * j + j * k + k * i <NEWLINE> if t <= N : <NEWLINE> <INDENT> ls [ t ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for p in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> print ( ls [ p ] ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> ans = [ 0 ] ( N + 1 ) <NEWLINE> for i in range ( 1 , 101 ) : <NEWLINE> <INDENT> for j in range ( 1 , 101 ) : <NEWLINE> <INDENT> for k in range ( 1 , 101 ) : <NEWLINE> <INDENT> n = i * i + j * j + k * k + i * j + j * k + k * i <NEWLINE> if n <= N : <NEWLINE> <INDENT> ans [ n ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( * ans [ 1 : ] , sep = <STRING> ) <NEWLINE> <NL>
<NL> N = int ( input ( ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> num = np . zeros ( 10 ** 4 + 1 ) <NEWLINE> for x in range ( 1 , 100 ) : <NEWLINE> <INDENT> for y in range ( 1 , 100 ) : <NEWLINE> <INDENT> for z in range ( 1 , 100 ) : <NEWLINE> <INDENT> ans = x ** 2 + y ** 2 + z ** 2 + x * y + y * z + z * x <NEWLINE> if ans < 10 ** 4 + 1 : <NEWLINE> <INDENT> num [ ans ] += 1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> print ( int ( num [ i + 1 ] ) ) <NEWLINE> <DEDENT>
def solve ( ) : <NEWLINE> <INDENT> dp = [ 0 ] * ( n + 2 ) <NEWLINE> for x in range ( 1 , 151 ) : <NEWLINE> <INDENT> for y in range ( 1 , 151 ) : <NEWLINE> <INDENT> for z in range ( 1 , 151 ) : <NEWLINE> <INDENT> a = x ** 2 + y ** 2 + z ** 2 + x * y + y * z + z * x <NEWLINE> if a <= n : <NEWLINE> <INDENT> dp [ a ] += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> print ( dp [ i ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> solve ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> <NL> x , y , z = 1 , 1 , 1 <NEWLINE> <NL> def is_true ( x , y , z , i ) : <NEWLINE> <INDENT> if x ** 2 + y ** 2 + z ** 2 + x * y + y * z + z * x == i : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> return False <NEWLINE> <NL> <DEDENT> loop = int ( N ** ( 1 / 2 ) ) <NEWLINE> <NL> for i in range ( 5 ) : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> print ( 1 ) <NEWLINE> <NL> for i in range ( 7 , N + 1 ) : <NEWLINE> <INDENT> a = 0 <NEWLINE> b = 0 <NEWLINE> c = 0 <NEWLINE> if i <NEWLINE> for ai in range ( loop ) : <NEWLINE> <INDENT> for bi in range ( loop ) : <NEWLINE> <INDENT> for ci in range ( loop ) : <NEWLINE> <INDENT> X = x + a <NEWLINE> Y = y + b <NEWLINE> Z = z + c <NEWLINE> if is_true ( X , Y , Z , i ) : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = [ ] <NEWLINE> for i in range ( 1 , 46 ) : <NEWLINE> <INDENT> for j in range ( 1 , 46 ) : <NEWLINE> <INDENT> for k in range ( 1 , 46 ) : <NEWLINE> <INDENT> A . append ( i ** 2 + j ** 2 + k ** 2 + i * j + i * k + j * k ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> A = sorted ( A ) <NEWLINE> B = [ 0 ] * N <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if A [ i ] == A [ i - 1 ] : <NEWLINE> <INDENT> B [ A [ i ] ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> B [ A [ i ] ] = 1 <NEWLINE> <DEDENT> <DEDENT> [ print ( i ) for i in B ] <NEWLINE>
n = int ( input ( ) ) <NEWLINE> ans = [ 0 for i in range ( 10050 ) ] <NEWLINE> for i in range ( 1 , 105 ) : <NEWLINE> <INDENT> for j in range ( 1 , 105 ) : <NEWLINE> <INDENT> for k in range ( 1 , 105 ) : <NEWLINE> <INDENT> v = i * i + j * j + k * k + i * j + i * k + j * k <NEWLINE> if v < 10050 : <NEWLINE> <INDENT> ans [ v ] += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> print ( a [ i + 1 ] ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> s = [ 0 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 3 , 0 , 0 , 0 , 0 , 0 , 3 , 3 , 0 , 0 , 0 , 0 , 0 , 1 , 6 , 0 , 3 , 0 , 0 , 0 , 0 , 0 , 3 , 3 , 6 , 0 , 0 , 3 , 0 , 0 , 0 , 0 , 3 , 3 , 6 , 0 , 6 , 0 , 0 , 0 , 3 , 0 , 0 , 1 , 6 , 0 , 6 , 6 , 0 , 0 , 6 , 0 , 0 , 0 , 0 , 3 , 3 , 3 , 6 , 0 , 6 , 3 , 6 , 0 , 0 , 0 , 6 , 0 , 0 , 0 , 3 , 3 , 9 , 0 , 6 , 3 , 6 , 0 , 3 , 6 , 0 , 0 , 0 , 0 , 6 , 1 , 6 , 0 , 6 , 6 , 0 , 3 , 12 , 0 , 6 , 0 , 0 , 3 , 6 , 0 , 0 , 0 , 3 , 3 , 12 , 0 , 6 , 3 , 6 , 0 , 3 , 6 , 9 , 0 , 6 , 0 , 0 , 0 , 3 , 6 , 3 , 3 , 6 , 0 , 6 , 3 , 12 , 0 , 3 , 6 , 6 , 0 , 6 , 0 , 6 , 3 , 6 , 0 , 0 , 1 , 6 , 3 , 12 , 6 , 0 , 0 , 12 , 0 , 6 , 0 , 6 , 6 , 12 , 0 , 0 , 6 , 0 , 0 , 6 , 0 , 12 , 3 , 6 , 0 , 6 , 3 , 9 , 6 , 3 , 6 , 6 , 0 , 6 , 0 , 6 , 0 , 15 , 6 , 0 , 0 , 6 , 0 , 3 , 3 , 12 , 0 , 12 , 6 , 6 , 0 , 3 , 6 , 6 , 3 , 12 , 0 , 6 , 0 , 9 , 6 , 0 , 0 , 6 , 3 , 12 , 1 , 6 , 6 , 6 , 6 , 0 , 0 , 18 , 0 , 12 , 0 , 3 , 6 , 12 , 0 , 0 , 6 , 3 , 6 , 12 , 0 , 12 , 0 , 0 , 0 , 9 , 3 , 9 , 6 , 12 , 3 , 12 , 0 , 3 , 6 , 6 , 0 , 12 , 0 , 12 , 0 , 9 , 9 , 0 , 0 , 6 , 3 , 6 , 3 , 12 , 6 , 9 , 3 , 6 , 0 , 12 , 3 , 6 , 3 , 9 , 6 , 12 , 6 , 6 , 0 , 6 , 0 , 9 , 6 , 6 , 0 , 12 , 3 , 6 , 0 , 9 , 6 , 6 , 1 , 6 , 0 , 21 , 12 , 6 , 0 , 12 , 0 , 12 , 0 , 0 , 6 , 15 , 6 , 0 , 6 , 12 , 0 , 12 , 0 , 12 , 0 , 0 , 0 , 12 , 0 , 12 , 12 , 3 , 3 , 18 , 3 , 6 , 3 , 6 , 6 , 9 , 9 , 18 , 0 , 6 , 0 , 12 , 0 , 9 , 6 , 0 , 3 , 12 , 3 , 6 , 6 , 12 , 6 , 6 , 0 , 0 , 0 , 15 , 3 , 18 , 3 , 18 , 3 , 12 , 6 , 3 , 6 , 9 , 0 , 12 , 0 , 12 , 0 , 18 , 12 , 0 , 0 , 12 , 3 , 6 , 0 , 6 , 6 , 9 , 6 , 0 , 0 , 18 , 1 , 18 , 3 , 12 , 6 , 6 , 6 , 12 , 0 , 15 , 6 , 12 , 6 , 18 , 0 , 0 , 6 , 0 , 9 , 12 , 0 , 18 , 0 , 6 , 3 , 12 , 0 , 12 , 12 , 0 , 0 , 12 , 0 , 3 , 6 , 12 , 6 , 18 , 9 , 18 , 0 , 9 , 6 , 18 , 0 , 6 , 0 , 6 , 3 , 27 , 6 , 6 , 6 , 6 , 3 , 6 , 0 , 12 , 6 , 9 , 0 , 6 , 0 , 18 , 0 , 9 , 9 , 15 , 3 , 12 , 6 , 6 , 3 , 9 , 6 , 12 , 12 , 18 , 0 , 18 , 0 , 6 , 6 , 21 , 6 , 0 , 0 , 6 , 3 , 15 , 6 , 12 , 6 , 18 , 0 , 0 , 0 , 12 , 6 , 6 , 3 , 6 , 4 , 18 , 6 , 12 , 6 , 3 , 9 , 30 , 0 , 18 , 0 , 6 , 6 , 12 , 6 , 6 , 9 , 12 , 0 , 18 , 6 , 18 , 0 , 6 , 0 , 12 , 0 , 6 , 12 , 6 , 3 , 18 , 0 , 6 , 6 , 6 , 6 , 15 , 3 , 24 , 0 , 6 , 3 , 18 , 0 , 12 , 6 , 12 , 6 , 24 , 0 , 15 , 18 , 9 , 6 , 0 , 0 , 18 , 3 , 6 , 0 , 15 , 12 , 12 , 6 , 6 , 0 , 18 , 0 , 6 , 3 , 12 , 0 , 12 , 6 , 6 , 9 , 9 , 6 , 24 , 3 , 24 , 0 , 9 , 12 , 6 , 6 , 12 , 0 , 12 , 0 , 21 , 9 , 15 , 6 , 12 , 3 , 18 , 3 , 12 , 6 , 12 , 6 , 0 , 0 , 12 , 0 , 12 , 6 , 24 , 0 , 6 , 12 , 6 , 1 , 9 , 6 , 12 , 6 , 24 , 0 , 18 , 3 , 12 , 6 , 6 , 12 , 24 , 0 , 12 , 6 , 15 , 6 , 18 , 0 , 18 , 0 , 0 , 0 , 18 , 9 , 21 , 12 , 0 , 6 , 18 , 0 , 9 , 6 , 6 , 6 , 12 , 0 , 12 , 0 , 9 , 9 , 27 , 6 , 6 , 3 , 18 , 6 , 21 , 6 , 6 , 12 , 12 , 0 , 12 , 0 , 24 , 12 , 0 , 0 , 24 , 3 , 24 , 6 , 12 , 12 , 18 , 0 , 0 , 0 , 12 , 0 , 18 , 3 , 15 , 6 , 12 , 9 , 6 , 0 , 15 , 6 , 9 , 12 , 24 , 0 , 12 , 3 , 6 , 6 , 21 , 6 , 18 , 3 , 18 , 0 , 21 , 12 , 15 , 6 , 6 , 0 , 12 , 3 , 12 , 9 , 18 , 9 , 12 , 6 , 6 , 6 , 24 , 0 , 18 , 3 , 24 , 0 , 6 , 6 , 0 , 6 , 9 , 6 , 6 , 4 , 30 , 0 , 18 , 12 , 9 , 6 , 24 , 0 , 18 , 0 , 9 , 12 , 21 , 6 , 6 , 12 , 12 , 0 , 18 , 0 , 21 , 15 , 12 , 0 , 12 , 6 , 12 , 12 , 18 , 0 , 18 , 0 , 6 , 0 , 9 , 12 , 18 , 6 , 30 , 0 , 0 , 0 , 24 , 6 , 9 , 3 , 12 , 6 , 30 , 3 , 6 , 12 , 6 , 12 , 12 , 0 , 36 , 0 , 6 , 3 , 27 , 12 , 12 , 6 , 6 , 6 , 24 , 0 , 12 , 6 , 12 , 0 , 18 , 0 , 18 , 15 , 18 , 3 , 18 , 6 , 12 , 6 , 6 , 12 , 3 , 6 , 6 , 0 , 12 , 3 , 39 , 3 , 12 , 12 , 12 , 3 , 18 , 0 , 21 , 12 , 21 , 6 , 18 , 0 , 12 , 0 , 9 , 9 , 12 , 9 , 24 , 9 , 12 , 6 , 12 , 6 , 33 , 0 , 6 , 0 , 18 , 0 , 9 , 15 , 12 , 6 , 24 , 6 , 6 , 3 , 15 , 6 , 15 , 12 , 18 , 0 , 18 , 1 , 18 , 6 , 12 , 6 , 6 , 0 , 24 , 6 , 24 , 12 , 18 , 6 , 24 , 0 , 6 , 6 , 12 , 15 , 24 , 0 , 24 , 6 , 6 , 0 , 18 , 0 , 15 , 18 , 12 , 0 , 24 , 0 , 12 , 6 , 12 , 12 , 18 , 6 , 24 , 0 , 0 , 6 , 24 , 3 , 12 , 0 , 12 , 6 , 30 , 9 , 6 , 12 , 24 , 12 , 12 , 0 , 15 , 18 , 12 , 0 , 18 , 0 , 24 , 6 , 15 , 6 , 18 , 3 , 18 , 3 , 12 , 6 , 24 , 12 , 12 , 12 , 6 , 0 , 36 , 0 , 18 , 3 , 6 , 12 , 6 , 9 , 12 , 0 , 3 , 12 , 36 , 0 , 30 , 0 , 12 , 0 , 18 , 6 , 12 , 9 , 12 , 6 , 24 , 3 , 18 , 12 , 15 , 9 , 24 , 0 , 18 , 6 , 18 , 9 , 18 , 12 , 6 , 6 , 24 , 3 , 24 , 0 , 12 , 12 , 12 , 0 , 6 , 0 , 27 , 12 , 18 , 3 , 30 , 3 , 18 , 6 , 0 , 12 , 15 , 6 , 18 , 0 , 24 , 0 , 9 , 6 , 9 , 12 , 18 , 7 , 24 , 0 , 24 , 12 , 15 , 12 , 24 , 0 , 24 , 0 , 6 , 9 , 30 , 9 , 6 , 6 , 0 , 9 , 33 , 12 , 36 , 0 , 12 , 0 , 18 , 0 , 6 , 21 , 12 , 6 , 36 , 6 , 0 , 3 , 18 , 6 , 12 , 6 , 24 , 0 , 12 , 3 , 24 , 6 , 9 , 12 , 6 , 6 , 30 , 6 , 18 , 12 , 9 , 9 , 12 , 0 , 30 , 3 , 18 , 3 , 27 , 6 , 30 , 12 , 12 , 0 , 24 , 0 , 27 , 12 , 6 , 0 , 24 , 3 , 18 , 18 , 9 , 6 , 18 , 0 , 12 , 3 , 33 , 18 , 12 , 9 , 6 , 0 , 12 , 6 , 30 , 0 , 24 , 12 , 12 , 0 , 30 , 6 , 6 , 6 , 0 , 6 , 24 , 0 , 12 , 0 , 18 , 15 , 33 , 6 , 30 , 15 , 18 , 0 , 9 , 12 , 24 , 9 , 12 , 0 , 18 , 6 , 27 , 18 , 15 , 6 , 18 , 3 , 24 , 0 , 6 , 6 , 36 , 12 , 18 , 0 , 12 , 3 , 30 , 3 , 12 , 6 , 12 , 15 , 6 , 0 , 18 , 12 , 15 , 9 , 30 , 0 , 18 , 6 , 12 , 12 , 18 , 6 , 6 , 3 , 24 , 1 , 27 , 12 , 18 , 6 , 18 , 0 , 24 , 0 , 18 , 15 , 15 , 21 , 30 , 6 , 12 , 12 , 18 , 0 , 30 , 6 , 24 , 0 , 6 , 0 , 18 , 6 , 36 , 12 , 6 , 6 , 36 , 0 , 6 , 12 , 12 , 12 , 24 , 0 , 30 , 0 , 9 , 6 , 18 , 0 , 18 , 12 , 12 , 6 , 24 , 6 , 9 , 15 , 12 , 0 , 12 , 6 , 30 , 9 , 18 , 0 , 42 , 3 , 18 , 6 , 12 , 18 , 33 , 12 , 12 , 0 , 18 , 0 , 21 , 12 , 12 , 12 , 24 , 6 , 30 , 0 , 27 , 18 , 6 , 12 , 6 , 0 , 24 , 0 , 18 , 15 , 30 , 0 , 18 , 12 , 6 , 0 , 21 , 6 , 21 , 12 , 24 , 0 , 30 , 0 , 6 , 6 , 6 , 12 , 24 , 0 , 30 , 12 , 9 , 12 , 21 , 3 , 24 , 0 , 12 , 3 , 21 , 18 , 9 , 18 , 18 , 6 , 30 , 3 , 42 , 6 , 21 , 6 , 30 , 0 , 6 , 3 , 24 , 9 , 36 , 6 , 6 , 9 , 12 , 6 , 18 , 12 , 33 , 9 , 12 , 0 , 24 , 9 , 9 , 6 , 3 , 18 , 36 , 6 , 18 , 0 , 24 , 6 , 6 , 6 , 18 , 0 , 12 , 0 , 30 , 3 , 39 , 12 , 12 , 7 , 18 , 0 , 15 , 18 , 18 , 9 , 36 , 0 , 24 , 6 , 6 , 18 , 30 , 0 , 18 , 9 , 18 , 3 , 24 , 6 , 21 , 12 , 24 , 0 , 30 , 3 , 33 , 24 , 12 , 6 , 18 , 6 , 6 , 6 , 18 , 6 , 18 , 12 , 18 , 0 , 24 , 6 , 36 , 3 , 18 , 6 , 0 , 12 , 30 , 0 , 9 , 24 , 18 , 0 , 24 , 0 , 18 , 0 , 0 , 12 , 30 , 15 , 30 , 6 , 18 , 3 , 30 , 0 , 24 , 18 , 12 , 0 , 36 , 3 , 24 , 12 , 15 , 18 , 18 , 6 , 24 , 3 , 24 , 12 , 18 , 12 , 24 , 0 , 0 , 6 , 39 , 6 , 24 , 3 , 18 , 3 , 42 , 6 , 12 , 12 , 15 , 9 , 30 , 0 , 12 , 0 , 18 , 6 , 18 , 12 , 24 , 15 , 12 , 0 , 12 , 12 , 30 , 12 , 12 , 0 , 18 , 0 , 15 , 15 , 18 , 18 , 30 , 3 , 24 , 12 , 9 , 6 , 48 , 0 , 18 , 0 , 30 , 0 , 21 , 6 , 12 , 12 , 24 , 12 , 18 , 3 , 48 , 24 , 6 , 6 , 18 , 0 , 36 , 0 , 12 , 15 , 27 , 6 , 12 , 12 , 18 , 6 , 27 , 6 , 12 , 9 , 18 , 0 , 24 , 6 , 18 , 18 , 21 , 0 , 36 , 0 , 12 , 0 , 18 , 12 , 21 , 18 , 24 , 0 , 12 , 1 , 18 , 9 , 21 , 18 , 6 , 9 , 42 , 3 , 36 , 12 , 12 , 12 , 30 , 0 , 12 , 6 , 21 , 12 , 36 , 6 , 24 , 9 , 12 , 6 , 12 , 12 , 24 , 12 , 18 , 0 , 42 , 0 , 15 , 6 , 15 , 15 , 42 , 6 , 30 , 6 , 12 , 12 , 18 , 12 , 18 , 0 , 6 , 6 , 36 , 0 , 30 , 18 , 6 , 0 , 6 , 0 , 30 , 18 , 18 , 0 , 42 , 0 , 18 , 6 , 15 , 18 , 24 , 0 , 12 , 6 , 36 , 9 , 33 , 12 , 12 , 12 , 18 , 0 , 36 , 0 , 21 , 21 , 15 , 18 , 18 , 15 , 18 , 0 , 18 , 6 , 42 , 6 , 24 , 0 , 18 , 3 , 42 , 6 , 18 , 12 , 12 , 12 , 18 , 0 , 15 , 12 , 18 , 12 , 36 , 0 , 30 , 12 , 3 , 21 , 18 , 0 , 30 , 6 , 24 , 0 , 27 , 12 , 18 , 12 , 6 , 0 , 12 , 0 , 36 , 15 , 15 , 3 , 36 , 12 , 18 , 6 , 30 , 6 , 33 , 12 , 12 , 0 , 12 , 6 , 24 , 6 , 54 , 18 , 12 , 3 , 36 , 9 , 9 , 12 , 12 , 18 , 36 , 0 , 6 , 0 , 21 , 15 , 27 , 9 , 24 , 12 , 30 , 6 , 24 , 6 , 27 , 18 , 12 , 0 , 30 , 0 , 21 , 12 , 18 , 6 , 30 , 0 , 18 , 0 , 21 , 18 , 21 , 6 , 30 , 0 , 24 , 3 , 6 , 6 , 15 , 27 , 12 , 10 , 42 , 6 , 36 , 12 , 12 , 6 , 24 , 0 , 24 , 6 , 12 , 12 , 48 , 6 , 18 , 12 , 0 , 3 , 51 , 6 , 30 , 6 , 24 , 0 , 24 , 0 , 30 , 21 , 15 , 12 , 24 , 9 , 18 , 6 , 18 , 12 , 30 , 9 , 24 , 0 , 18 , 0 , 27 , 18 , 9 , 6 , 18 , 9 , 54 , 0 , 18 , 24 , 21 , 18 , 12 , 0 , 24 , 0 , 12 , 0 , 30 , 9 , 30 , 12 , 6 , 9 , 24 , 6 , 15 , 15 , 18 , 0 , 30 , 3 , 33 , 18 , 21 , 12 , 42 , 3 , 30 , 6 , 6 , 24 , 27 , 6 , 12 , 0 , 24 , 3 , 42 , 6 , 42 , 9 , 12 , 6 , 18 , 6 , 24 , 12 , 12 , 12 , 54 , 0 , 6 , 12 , 18 , 6 , 18 , 18 , 30 , 12 , 30 , 0 , 18 , 0 , 27 , 18 , 24 , 0 , 18 , 0 , 15 , 24 , 21 , 6 , 24 , 3 , 36 , 6 , 6 , 6 , 45 , 21 , 18 , 0 , 18 , 6 , 33 , 3 , 18 , 0 , 24 , 15 , 30 , 0 , 30 , 24 , 12 , 6 , 36 , 0 , 24 , 3 , 21 , 24 , 18 , 15 , 30 , 3 , 12 , 6 , 42 , 12 , 12 , 12 , 6 , 0 , 54 , 6 , 30 , 15 , 24 , 18 , 24 , 6 , 12 , 0 , 9 , 6 , 30 , 0 , 48 , 0 , 24 , 0 , 15 , 12 , 39 , 12 , 24 , 6 , 24 , 6 , 15 , 30 , 12 , 6 , 24 , 0 , 24 , 3 , 24 , 12 , 24 , 6 , 6 , 18 , 12 , 4 , 54 , 6 , 21 , 18 , 18 , 0 , 36 , 6 , 24 , 9 , 30 , 12 , 24 , 9 , 36 , 6 , 12 , 18 , 42 , 3 , 30 , 0 , 6 , 9 , 21 , 6 , 12 , 30 , 30 , 6 , 30 , 0 , 27 , 12 , 9 , 18 , 30 , 0 , 36 , 0 , 18 , 9 , 42 , 6 , 24 , 12 , 0 , 6 , 51 , 12 , 24 , 12 , 12 , 0 , 18 , 6 , 12 , 18 , 6 , 6 , 36 , 3 , 54 , 9 , 18 , 6 , 27 , 12 , 18 , 0 , 30 , 0 , 39 , 9 , 18 , 18 , 12 , 9 , 30 , 6 , 21 , 12 , 27 , 18 , 24 , 0 , 12 , 0 , 42 , 18 , 42 , 6 , 24 , 15 , 18 , 0 , 24 , 12 , 45 , 12 , 6 , 0 , 54 , 0 , 15 , 21 , 6 , 6 , 30 , 6 , 18 , 12 , 24 , 18 , 30 , 6 , 36 , 0 , 12 , 3 , 24 , 12 , 18 , 18 , 18 , 12 , 24 , 0 , 33 , 12 , 27 , 6 , 42 , 0 , 18 , 6 , 9 , 15 , 30 , 6 , 30 , 6 , 12 , 6 , 18 , 6 , 33 , 15 , 30 , 0 , 36 , 3 , 27 , 21 , 33 , 24 , 30 , 9 , 24 , 0 , 12 , 18 , 33 , 6 , 6 , 0 , 18 , 3 , 57 , 12 , 24 , 18 , 30 , 9 , 18 , 0 , 18 , 12 , 27 , 12 , 36 , 0 , 36 , 6 , 12 , 6 , 27 , 12 , 30 , 9 , 24 , 6 , 39 , 18 , 12 , 24 , 12 , 0 , 30 , 0 , 30 , 6 , 15 , 15 , 18 , 3 , 24 , 18 , 9 , 12 , 30 , 9 , 30 , 0 , 18 , 6 , 42 , 18 , 30 , 0 , 6 , 10 , 48 , 0 , 24 , 12 , 12 , 18 , 48 , 0 , 30 , 3 , 30 , 15 , 18 , 6 , 24 , 18 , 18 , 0 , 42 , 6 , 36 , 15 , 24 , 0 , 42 , 12 , 21 , 24 , 12 , 12 , 24 , 0 , 12 , 6 , 18 , 18 , 60 , 6 , 30 , 0 , 12 , 0 , 24 , 0 , 12 , 18 , 30 , 15 , 42 , 0 , 33 , 30 , 6 , 6 , 12 , 0 , 42 , 3 , 27 , 6 , 33 , 12 , 36 , 12 , 18 , 0 , 30 , 6 , 18 , 12 , 12 , 0 , 18 , 6 , 15 , 27 , 27 , 6 , 42 , 6 , 36 , 9 , 18 , 30 , 33 , 9 , 30 , 0 , 6 , 6 , 54 , 6 , 36 , 24 , 24 , 0 , 30 , 3 , 12 , 6 , 21 , 24 , 30 , 0 , 24 , 0 , 24 , 12 , 42 , 9 , 42 , 21 , 12 , 12 , 27 , 12 , 27 , 6 , 12 , 0 , 48 , 6 , 12 , 18 , 12 , 12 , 36 , 6 , 30 , 0 , 24 , 0 , 42 , 12 , 12 , 0 , 36 , 0 , 24 , 15 , 21 , 21 , 18 , 6 , 12 , 9 , 36 , 18 , 18 , 15 , 42 , 0 , 18 , 6 , 9 , 18 , 48 , 12 , 30 , 9 , 24 , 3 , 33 , 6 , 18 , 18 , 18 , 0 , 36 , 3 , 54 , 24 , 3 , 12 , 36 , 9 , 36 , 6 , 30 , 12 , 36 , 12 , 24 , 0 , 18 , 6 , 24 , 6 , 42 , 0 , 24 , 18 , 18 , 0 , 9 , 30 , 39 , 12 , 42 , 0 , 36 , 0 , 12 , 12 , 21 , 12 , 18 , 12 , 24 , 6 , 45 , 6 , 18 , 24 , 18 , 0 , 36 , 0 , 42 , 15 , 18 , 6 , 24 , 6 , 12 , 12 , 18 , 12 , 30 , 6 , 18 , 0 , 30 , 1 , 30 , 9 , 57 , 9 , 12 , 9 , 48 , 6 , 21 , 24 , 18 , 12 , 66 , 0 , 18 , 6 , 9 , 24 , 24 , 24 , 30 , 12 , 18 , 0 , 48 , 6 , 24 , 18 , 18 , 0 , 24 , 3 , 27 , 18 , 24 , 12 , 36 , 6 , 48 , 6 , 15 , 18 , 42 , 6 , 24 , 0 , 12 , 12 , 36 , 6 , 6 , 24 , 12 , 3 , 48 , 0 , 48 , 18 , 0 , 12 , 18 , 0 , 36 , 6 , 18 , 9 , 54 , 15 , 12 , 12 , 6 , 6 , 39 , 6 , 24 , 18 , 42 , 0 , 30 , 0 , 33 , 18 , 24 , 18 , 18 , 9 , 18 , 0 , 15 , 18 , 54 , 0 , 36 , 0 , 24 , 0 , 48 , 24 , 15 , 18 , 18 , 12 , 42 , 9 , 24 , 12 , 36 , 21 , 30 , 0 , 36 , 12 , 24 , 3 , 30 , 0 , 48 , 15 , 12 , 6 , 15 , 18 , 18 , 18 , 24 , 0 , 30 , 0 , 24 , 24 , 18 , 9 , 72 , 0 , 30 , 6 , 21 , 18 , 30 , 6 , 24 , 0 , 0 , 6 , 24 , 18 , 42 , 12 , 6 , 15 , 36 , 0 , 30 , 18 , 30 , 12 , 24 , 0 , 6 , 0 , 18 , 12 , 54 , 9 , 36 , 9 , 36 , 9 , 30 , 6 , 27 , 27 , 24 , 0 , 54 , 6 , 21 , 18 , 21 , 6 , 36 , 15 , 36 , 3 , 30 , 12 , 6 , 18 , 30 , 0 , 18 , 6 , 54 , 0 , 30 , 21 , 36 , 9 , 30 , 6 , 30 , 24 , 24 , 6 , 30 , 0 , 36 , 12 , 9 , 24 , 24 , 12 , 18 , 9 , 30 , 0 , 48 , 12 , 24 , 12 , 12 , 0 , 48 , 0 , 18 , 12 , 24 , 24 , 30 , 6 , 18 , 12 , 21 , 12 , 24 , 0 , 66 , 0 , 12 , 0 , 30 , 9 , 24 , 24 , 18 , 13 , 42 , 3 , 18 , 18 , 27 , 24 , 24 , 0 , 30 , 6 , 15 , 18 , 39 , 12 , 12 , 9 , 36 , 12 , 54 , 12 , 42 , 18 , 6 , 0 , 36 , 0 , 51 , 18 , 12 , 0 , 66 , 12 , 24 , 0 , 6 , 24 , 51 , 12 , 24 , 0 , 24 , 0 , 33 , 6 , 18 , 18 , 30 , 6 , 42 , 3 , 18 , 30 , 15 , 15 , 30 , 0 , 30 , 6 , 30 , 12 , 48 , 12 , 24 , 12 , 12 , 9 , 36 , 6 , 36 , 6 , 12 , 0 , 30 , 0 , 24 , 21 , 24 , 15 , 42 , 12 , 24 , 6 , 9 , 18 , 15 , 9 , 42 , 0 , 24 , 12 , 66 , 12 , 30 , 24 , 6 , 9 , 54 , 0 , 36 , 12 , 21 , 12 , 36 , 0 , 24 , 3 , 24 , 15 , 36 , 6 , 30 , 24 , 12 , 6 , 33 , 6 , 39 , 21 , 30 , 0 , 42 , 6 , 12 , 30 , 30 , 18 , 36 , 0 , 48 , 3 , 36 , 12 , 30 , 18 , 18 , 0 , 24 , 0 , 30 , 6 , 33 , 21 , 24 , 6 , 18 , 12 , 24 , 12 , 12 , 15 , 48 , 0 , 24 , 6 , 21 , 21 , 60 , 6 , 24 , 12 , 18 , 0 , 30 , 12 , 15 , 12 , 24 , 0 , 24 , 3 , 60 , 27 , 18 , 12 , 30 , 3 , 24 , 9 , 21 , 12 , 60 , 18 , 24 , 0 , 24 , 9 , 33 , 6 , 36 , 12 , 24 , 15 , 42 , 6 , 27 , 36 , 27 , 6 , 42 , 0 , 42 , 6 , 12 , 15 , 15 , 24 , 42 , 18 , 12 , 0 , 33 , 6 , 21 , 18 , 24 , 0 , 48 , 3 , 36 , 9 , 24 , 24 , 30 , 6 , 36 , 0 , 39 , 18 , 60 , 6 , 18 , 0 , 12 , 6 , 21 , 27 , 30 , 0 , 18 , 6 , 42 , 6 , 42 , 18 , 24 , 9 , 48 , 0 , 6 , 6 , 18 , 18 , 18 , 6 , 18 , 15 , 30 , 4 , 60 , 12 , 30 , 30 , 18 , 0 , 36 , 0 , 27 , 18 , 30 , 18 , 48 , 9 , 30 , 12 , 18 , 6 , 42 , 9 , 48 , 0 , 18 , 6 , 42 , 6 , 30 , 24 , 12 , 3 , 36 , 0 , 36 , 36 , 15 , 18 , 30 , 0 , 66 , 0 , 12 , 18 , 42 , 9 , 24 , 15 , 18 , 12 , 54 , 6 , 18 , 21 , 36 , 0 , 30 , 6 , 24 , 24 , 12 , 6 , 24 , 9 , 36 , 12 , 6 , 12 , 45 , 12 , 36 , 0 , 36 , 0 , 48 , 3 , 24 , 18 , 12 , 24 , 36 , 0 , 30 , 12 , 30 , 21 , 30 , 0 , 6 , 15 , 18 , 15 , 66 , 12 , 42 , 3 , 12 , 0 , 39 , 12 , 30 , 12 , 18 , 0 , 54 , 6 , 30 , 24 , 9 , 12 , 60 , 12 , 30 , 12 , 30 , 24 , 24 , 18 , 30 , 0 , 36 , 0 , 27 , 9 , 45 , 18 , 24 , 12 , 24 , 0 , 36 , 24 , 12 , 6 , 60 , 0 , 18 , 0 , 24 , 15 , 51 , 9 , 24 , 12 , 30 , 12 , 27 , 18 , 51 , 18 , 24 , 0 , 36 , 6 , 27 , 27 , 12 , 30 , 36 , 6 , 30 , 0 , 12 , 6 , 42 , 0 , 18 , 0 , 18 , 0 , 48 , 12 , 45 , 24 , 6 , 15 , 42 , 6 , 12 , 18 , 27 , 9 , 54 , 0 , 42 , 3 , 33 , 12 , 15 , 12 , 54 , 18 , 30 , 6 , 36 , 18 , 21 , 30 , 18 , 0 , 48 , 3 , 30 , 18 , 36 , 6 , 18 , 0 , 18 , 12 , 57 , 24 , 42 , 6 , 24 , 0 , 18 , 12 , 36 , 18 , 30 , 12 , 36 , 3 , 78 , 0 , 24 , 6 , 6 , 36 , 42 , 0 , 24 , 0 , 21 , 15 , 33 , 6 , 42 , 18 , 12 , 3 , 30 , 12 , 30 , 27 , 24 , 0 , 42 , 12 , 39 , 12 , 30 , 12 , 30 , 15 , 30 , 6 , 12 , 24 , 54 , 6 , 24 , 0 , 18 , 6 , 33 , 12 , 18 , 24 , 24 , 7 , 30 , 0 , 60 , 24 , 21 , 12 , 30 , 0 , 48 , 6 , 18 , 15 , 39 , 12 , 18 , 18 , 18 , 0 , 48 , 12 , 54 , 18 , 42 , 0 , 30 , 0 , 15 , 30 , 27 , 18 , 72 , 0 , 30 , 15 , 12 , 12 , 30 , 18 , 36 , 0 , 6 , 3 , 60 , 15 , 24 , 18 , 6 , 18 , 54 , 6 , 21 , 24 , 24 , 12 , 30 , 0 , 30 , 6 , 30 , 15 , 54 , 6 , 48 , 12 , 30 , 12 , 36 , 0 , 24 , 3 , 24 , 0 , 54 , 6 , 18 , 30 , 15 , 6 , 42 , 9 , 36 , 0 , 21 , 30 , 15 , 12 , 12 , 0 , 24 , 3 , 72 , 0 , 51 , 39 , 24 , 12 , 30 , 3 , 33 , 18 , 15 , 12 , 42 , 0 , 30 , 12 , 27 , 24 , 51 , 12 , 42 , 12 , 18 , 3 , 42 , 12 , 39 , 18 , 12 , 0 , 30 , 0 , 24 , 21 , 21 , 21 , 30 , 6 , 66 , 12 , 12 , 6 , 69 , 21 , 30 , 0 , 24 , 6 , 45 , 12 , 12 , 18 , 42 , 12 , 18 , 0 , 39 , 30 , 33 , 12 , 54 , 0 , 12 , 0 , 12 , 18 , 36 , 9 , 30 , 9 , 24 , 9 , 60 , 12 , 30 , 12 , 12 , 0 , 42 , 9 , 42 , 18 , 45 , 24 , 42 , 6 , 12 , 9 , 24 , 6 , 30 , 12 , 42 , 0 , 30 , 6 , 15 , 15 , 30 , 12 , 18 , 12 , 54 , 6 , 21 , 30 , 12 , 33 , 60 , 0 , 48 , 0 , 30 , 15 , 42 , 6 , 24 , 24 , 30 , 0 , 36 , 18 , 33 , 18 , 12 , 0 , 60 , 0 , 72 , 15 , 12 , 9 , 30 , 12 , 24 , 15 , 21 , 24 , 51 , 12 , 24 , 0 , 24 , 6 , 12 , 6 , 33 , 24 , 36 , 9 , 54 , 6 , 27 , 24 , 30 , 6 , 48 , 0 , 24 , 3 , 36 , 27 , 42 , 15 , 18 , 18 , 12 , 6 , 54 , 6 , 30 , 15 , 36 , 0 , 12 , 12 , 18 , 24 , 21 , 18 , 30 , 3 , 60 , 0 , 33 , 12 , 36 , 18 , 48 , 0 , 24 , 1 , 39 , 12 , 24 , 18 , 24 , 9 , 66 , 6 , 48 , 24 , 12 , 12 , 42 , 0 , 24 , 6 , 18 , 12 , 63 , 6 , 36 , 24 , 18 , 0 , 39 , 12 , 39 , 24 , 24 , 0 , 54 , 6 , 15 , 24 , 15 , 24 , 48 , 3 , 36 , 12 , 12 , 24 , 39 , 18 , 36 , 0 , 42 , 6 , 42 , 6 , 60 , 24 , 12 , 18 , 18 , 0 , 45 , 6 , 6 , 6 , 72 , 0 , 30 , 6 , 24 , 9 , 36 , 12 , 24 , 9 , 30 , 15 , 36 , 18 , 33 , 24 , 6 , 0 , 54 , 0 , 33 , 36 , 18 , 24 , 36 , 6 , 18 , 6 , 24 , 18 , 75 , 6 , 18 , 0 , 18 , 0 , 48 , 9 , 36 , 18 , 42 , 9 , 30 , 0 , 27 , 36 , 24 , 15 , 42 , 0 , 42 , 18 , 36 , 12 , 18 , 12 , 72 , 9 , 24 , 0 , 54 , 18 , 21 , 24 , 12 , 0 , 60 , 0 , 24 , 24 , 39 , 12 , 42 , 18 , 30 , 6 , 9 , 12 , 48 , 12 , 30 , 0 , 18 , 12 , 36 , 15 , 48 , 18 , 18 , 3 , 42 , 6 , 42 , 18 , 18 , 24 , 54 , 0 , 36 , 0 , 24 , 36 , 42 , 0 , 12 , 27 , 30 , 6 , 60 , 6 , 30 , 24 , 12 , 0 , 36 , 3 , 42 , 12 , 18 , 12 , 36 , 9 , 30 , 0 , 15 , 18 , 33 , 12 , 54 , 0 , 30 , 6 , 33 , 21 , 27 , 30 , 42 , 12 , 54 , 9 , 42 , 24 , 27 , 6 , 36 , 0 , 24 , 12 , 24 , 12 , 45 , 24 , 12 , 6 , 30 , 12 , 69 , 12 , 42 , 12 , 30 , 0 , 24 , 0 , 42 , 18 , 24 , 15 , 60 , 9 , 48 , 18 , 18 , 24 , 27 , 12 , 36 , 0 , 30 , 0 , 54 , 9 , 30 , 18 , 24 , 15 , 48 , 0 , 24 , 24 , 45 , 24 , 24 , 0 , 18 , 6 , 36 , 9 , 54 , 15 , 24 , 12 , 12 , 6 , 18 , 12 , 54 , 18 , 12 , 0 , 60 , 3 , 48 , 30 , 12 , 18 , 60 , 6 , 24 , 3 , 36 , 12 , 33 , 12 , 36 , 0 , 36 , 6 , 36 , 3 , 33 , 24 , 12 , 13 , 42 , 12 , 27 , 18 , 30 , 12 , 54 , 0 , 30 , 12 , 21 , 39 , 54 , 6 , 54 , 18 , 18 , 0 , 33 , 12 , 36 , 36 , 36 , 0 , 30 , 0 , 42 , 33 , 18 , 18 , 36 , 12 , 30 , 3 , 30 , 12 , 66 , 6 , 30 , 0 , 18 , 12 , 63 , 18 , 24 , 6 , 30 , 12 , 48 , 9 , 6 , 24 , 30 , 12 , 42 , 0 , 72 , 0 , 30 , 12 , 48 , 3 , 24 , 15 , 12 , 12 , 66 , 18 , 9 , 36 , 12 , 0 , 54 , 0 , 54 , 18 , 15 , 30 , 36 , 6 , 12 , 0 , 21 , 18 , 54 , 12 , 30 , 0 , 6 , 0 , 36 , 15 , 60 , 18 , 18 , 15 , 48 , 6 , 27 , 24 , 21 , 12 , 54 , 0 , 54 , 9 , 12 , 24 , 48 , 12 , 48 , 15 , 54 , 6 , 36 , 6 , 39 , 24 , 24 , 0 , 24 , 3 , 33 , 24 , 18 , 18 , 66 , 12 , 18 , 12 , 30 , 12 , 75 , 15 , 36 , 0 , 30 , 9 , 24 , 6 , 21 , 24 , 24 , 12 , 60 , 0 , 66 , 36 , 12 , 18 , 36 , 0 , 24 , 6 , 30 , 18 , 39 , 18 , 30 , 12 , 24 , 9 , 30 , 6 , 36 , 18 , 18 , 0 , 54 , 12 , 33 , 24 , 36 , 6 , 66 , 0 , 30 , 6 , 12 , 12 , 33 , 24 , 54 , 0 , 18 , 3 , 60 , 3 , 30 , 24 , 24 , 21 , 48 , 0 , 18 , 30 , 51 , 12 , 18 , 0 , 30 , 12 , 33 , 15 , 18 , 12 , 30 , 27 , 24 , 0 , 48 , 12 , 45 , 6 , 30 , 0 , 72 , 0 , 51 , 18 , 27 , 27 , 54 , 9 , 48 , 12 , 27 , 30 , 36 , 18 , 18 , 0 , 42 , 3 , 36 , 9 , 45 , 30 , 6 , 6 , 36 , 3 , 51 , 24 , 24 , 18 , 72 , 0 , 18 , 6 , 9 , 36 , 42 , 0 , 36 , 9 , 30 , 12 , 60 , 30 , 24 , 15 , 24 , 0 , 36 , 6 , 30 , 27 , 27 , 18 , 42 , 12 , 48 , 0 , 42 , 0 , 33 , 24 , 24 , 0 , 30 , 0 , 42 , 12 , 48 , 9 , 36 , 9 , 24 , 6 , 27 , 36 , 12 , 9 , 60 , 0 , 30 , 12 , 15 , 18 , 42 , 18 , 36 , 18 , 24 , 7 , 48 , 12 , 54 , 24 , 30 , 0 , 78 , 0 , 18 , 18 , 27 , 24 , 24 , 6 , 30 , 12 , 33 , 18 , 60 , 15 , 54 , 0 , 12 , 12 , 36 , 12 , 36 , 24 , 30 , 18 , 54 , 0 , 18 , 18 , 18 , 24 , 84 , 0 , 54 , 0 , 27 , 15 , 42 , 6 , 36 , 12 , 18 , 9 , 54 , 6 , 30 , 30 , 24 , 0 , 30 , 9 , 60 , 30 , 36 , 6 , 42 , 12 , 30 , 6 , 6 , 30 , 60 , 0 , 18 , 0 , 24 , 9 , 51 , 18 , 24 , 33 , 30 , 0 , 42 , 12 , 60 , 18 , 18 , 36 , 18 , 0 , 24 , 0 , 18 , 9 , 78 , 12 , 48 , 24 , 12 , 0 , 48 , 6 , 12 , 18 , 42 , 0 , 48 , 0 , 30 , 27 , 18 , 6 , 48 , 3 , 66 , 21 , 18 , 18 , 33 , 12 , 48 , 0 , 30 , 6 , 63 , 21 , 18 , 36 , 24 , 15 , 60 , 6 , 36 , 30 , 36 , 0 , 48 , 0 , 48 , 3 , 36 , 30 , 42 , 18 , 24 , 24 , 12 , 6 , 21 , 6 , 72 , 12 , 36 , 0 , 60 , 6 , 12 , 18 , 15 , 24 , 60 , 9 , 30 , 0 , 39 , 30 , 54 , 12 , 18 , 0 , 18 , 3 , 60 , 9 , 57 , 24 , 6 , 18 , 48 , 6 , 60 , 18 , 18 , 9 , 48 , 0 , 24 , 12 , 18 , 18 , 39 , 6 , 42 , 15 , 36 , 6 , 36 , 18 , 18 , 30 , 18 , 0 , 42 , 6 , 39 , 27 , 27 , 18 , 48 , 12 , 42 , 12 , 24 , 18 , 27 , 9 , 30 , 0 , 24 , 9 , 81 , 12 , 72 , 12 , 30 , 6 , 36 , 0 , 33 , 42 , 39 , 30 , 42 , 0 , 12 , 3 , 12 , 6 , 24 , 18 , 48 , 12 , 48 , 3 , 63 , 24 , 24 , 27 , 30 , 0 , 78 , 6 , 36 , 18 , 36 , 30 , 30 , 12 , 36 , 12 , 30 , 6 , 60 , 12 , 48 , 0 , 24 , 0 , 36 , 21 , 30 , 24 , 30 , 12 , 48 , 0 , 36 , 12 , 24 , 27 , 36 , 0 , 42 , 12 , 27 , 24 , 54 , 6 , 18 , 12 , 48 , 0 , 30 , 6 , 72 , 24 , 12 , 0 , 30 , 3 , 45 , 24 , 0 , 18 , 78 , 15 , 18 , 18 , 39 , 18 , 39 , 9 , 36 , 0 , 24 , 6 , 39 , 12 , 30 , 18 , 30 , 16 , 48 , 0 , 36 , 30 , 12 , 12 , 60 , 0 , 42 , 3 , 24 , 21 , 84 , 33 , 30 , 12 , 18 , 18 , 48 , 12 , 36 , 12 , 30 , 0 , 48 , 9 , 42 , 36 , 42 , 6 , 48 , 3 , 42 , 0 , 33 , 24 , 30 , 12 , 36 , 0 , 36 , 6 , 54 , 12 , 30 , 30 , 6 , 21 , 66 , 0 , 39 , 24 , 36 , 24 , 36 , 0 , 24 , 12 , 30 , 15 , 54 , 12 , 78 , 30 , 6 , 0 , 33 , 12 , 27 , 30 , 30 , 0 , 36 , 6 , 18 , 36 , 36 , 6 , 66 , 3 , 60 , 6 , 18 , 30 , 42 , 0 , 12 , 0 , 36 , 6 , 54 , 6 , 33 , 24 , 24 , 12 , 54 , 0 , 42 , 12 , 15 , 12 , 60 , 0 , 30 , 0 , 21 , 18 , 75 , 18 , 48 , 18 , 18 , 15 , 30 , 24 , 42 , 33 , 36 , 0 , 30 , 6 , 45 , 24 , 9 , 30 , 36 , 3 , 54 , 15 , 24 , 18 , 63 , 18 , 42 , 0 , 24 , 0 , 75 , 6 , 30 , 9 , 30 , 15 , 42 , 12 , 33 , 36 , 21 , 24 , 60 , 0 , 54 , 9 , 30 , 30 , 48 , 12 , 18 , 12 , 24 , 0 , 66 , 12 , 24 , 18 , 36 , 0 , 72 , 6 , 36 , 15 , 27 , 27 , 30 , 6 , 12 , 18 , 24 , 6 , 78 , 15 , 42 , 0 , 12 , 6 , 27 , 24 , 51 , 18 , 36 , 12 , 60 , 3 , 51 , 30 , 12 , 24 , 36 , 0 , 30 , 0 , 48 , 12 , 21 , 6 , 36 , 24 , 54 , 6 , 42 , 6 , 36 , 36 , 6 , 0 , 54 , 12 , 27 , 15 , 18 , 18 , 66 , 6 , 42 , 0 , 15 , 30 , 63 , 12 , 48 , 0 , 36 , 3 , 63 , 12 , 36 , 30 , 18 , 9 , 48 , 3 , 48 , 36 , 30 , 12 , 42 , 0 , 72 , 6 , 36 , 30 , 30 , 12 , 24 , 12 , 6 , 15 , 75 , 18 , 30 , 6 , 36 , 0 , 24 , 0 , 18 , 36 , 48 , 18 , 60 , 18 , 60 , 12 , 33 , 12 , 33 , 15 , 72 , 0 , 18 , 9 , 54 , 15 , 21 , 30 , 36 , 12 , 30 , 0 , 42 , 24 , 48 , 18 , 36 , 0 , 24 , 6 , 18 , 15 , 81 , 12 , 12 , 27 , 36 , 12 , 30 , 6 , 36 , 18 , 24 , 0 , 48 , 6 , 36 , 36 , 27 , 6 , 48 , 9 , 36 , 3 , 36 , 36 , 36 , 24 , 30 , 0 , 24 , 1 , 42 , 6 , 66 , 27 , 24 , 18 , 48 , 12 , 51 , 18 , 24 , 18 , 84 , 0 , 24 , 6 , 12 , 9 , 63 , 18 , 48 , 9 , 30 , 0 , 36 , 12 , 33 , 24 , 30 , 0 , 72 , 0 , 42 , 48 , 36 , 18 , 42 , 12 , 42 , 15 , 24 , 12 , 60 , 15 , 24 , 0 , 12 , 21 , 72 , 3 , 42 , 30 , 24 , 18 , 36 , 6 , 42 , 18 , 30 , 12 , 42 , 0 , 48 , 12 , 12 , 24 , 24 , 18 , 66 , 6 , 24 , 0 , 93 , 12 , 51 , 30 , 12 , 0 , 54 , 6 , 18 , 27 , 24 , 24 , 36 , 12 , 30 , 0 , 45 , 18 , 60 , 6 , 54 , 0 , 24 , 0 , 51 , 24 , 21 , 18 , 30 , 6 , 72 , 6 , 6 , 18 , 21 , 36 , 42 , 0 , 48 , 12 , 27 , 24 , 36 , 6 , 30 , 27 , 30 , 6 , 39 , 18 , 51 , 36 , 30 , 0 , 42 , 0 , 66 , 18 , 36 , 6 , 66 , 9 , 24 , 12 , 24 , 24 , 78 , 12 , 36 , 0 , 36 , 12 , 60 , 15 , 42 , 24 , 6 , 15 , 54 , 0 , 33 , 30 , 21 , 30 , 42 , 0 , 54 , 0 , 24 , 9 , 60 , 9 , 36 , 24 , 24 , 6 , 66 , 12 , 48 , 18 , 54 , 0 , 30 , 0 , 30 , 39 , 30 , 18 , 48 , 6 , 42 , 12 , 33 , 24 , 33 , 12 , 60 , 0 , 18 , 6 , 42 , 24 , 42 , 24 , 6 , 12 , 72 , 6 , 42 , 30 , 18 , 9 , 30 , 0 , 24 , 15 , 30 , 18 , 60 , 12 , 54 , 15 , 24 , 0 , 48 , 24 , 33 , 12 , 36 , 0 , 66 , 6 , 36 , 18 , 21 , 30 , 72 , 3 , 24 , 9 , 27 , 30 , 30 , 18 , 42 , 0 , 42 , 0 , 72 , 6 , 39 , 42 , 24 , 18 , 60 , 3 , 24 , 18 , 36 , 18 , 30 , 0 , 54 , 6 , 27 , 33 , 60 , 12 , 24 , 24 , 18 , 18 , 30 , 12 , 21 , 33 , 48 , 0 , 78 , 12 , 78 , 12 , 30 , 12 , 42 , 12 , 48 , 0 , 24 , 12 , 75 , 18 , 24 , 0 , 18 , 0 , 33 , 24 , 30 , 21 , 42 , 15 , 30 , 12 , 39 , 30 , 51 , 12 , 54 , 0 , 36 , 12 , 18 , 12 , 48 , 24 , 78 , 18 , 18 , 6 , 78 , 6 , 24 , 30 , 12 , 0 , 42 , 0 , 45 , 18 , 15 , 27 , 42 , 0 , 54 , 18 , 36 , 18 , 36 , 6 , 48 , 0 , 30 , 12 , 36 , 21 , 45 , 6 , 24 , 7 , 54 , 0 , 27 , 42 , 33 , 24 , 72 , 0 , 42 , 0 , 48 , 24 , 45 , 18 , 18 , 15 , 36 , 15 , 66 , 6 , 66 , 30 , 18 , 0 , 48 , 0 , 27 , 39 , 30 , 18 , 66 , 27 , 12 , 12 , 18 , 24 , 60 , 6 , 66 , 0 , 42 , 0 , 42 , 6 , 33 , 21 , 36 , 12 , 42 , 6 , 21 , 36 , 33 , 21 , 48 , 0 , 66 , 12 , 6 , 18 , 75 , 24 , 36 , 12 , 18 , 0 , 81 , 12 , 42 , 30 , 36 , 0 , 24 , 0 , 30 , 30 , 30 , 6 , 60 , 9 , 60 , 6 , 24 , 30 , 30 , 6 , 30 , 0 , 30 , 12 , 75 , 18 , 30 , 24 , 24 , 15 , 78 , 0 , 42 , 24 , 18 , 30 , 42 , 0 , 30 , 12 , 21 , 12 , 48 , 9 , 60 , 21 , 30 , 12 , 24 , 24 , 39 , 21 , 24 , 0 , 54 , 3 , 39 , 30 , 33 , 24 , 72 , 12 , 60 , 0 , 18 , 24 , 57 , 12 , 24 , 0 , 24 , 3 , 90 , 9 , 12 , 21 , 36 , 12 , 30 , 18 , 84 , 24 , 30 , 9 , 60 , 0 , 36 , 18 , 18 , 24 , 78 , 18 , 24 , 18 , 48 , 6 , 24 , 0 , 45 , 30 , 24 , 0 , 66 , 3 , 60 , 36 , 21 , 42 , 42 , 6 , 30 , 6 , 33 , 12 , 60 , 21 , 36 , 0 , 6 , 6 , 36 , 15 , 36 , 30 , 48 , 21 , 48 , 0 , 39 , 36 , 36 , 6 , 54 , 0 , 66 , 3 , 18 , 18 , 33 , 24 , 36 , 18 , 30 , 9 , 66 , 6 , 15 , 36 , 24 , 0 , 96 , 6 , 30 , 12 , 42 , 6 , 36 , 6 , 36 , 9 , 27 , 36 , 42 , 12 , 42 , 0 , 18 , 6 , 51 , 12 , 78 , 18 , 30 , 9 , 54 , 12 , 39 , 24 , 24 , 33 , 66 , 0 , 36 , 9 , 45 , 33 , 36 , 12 , 18 , 27 , 36 , 0 , 78 , 12 , 48 , 24 , 30 , 0 , 42 , 9 , 48 , 21 , 18 , 9 , 60 , 12 , 54 , 6 , 21 , 24 , 72 , 3 , 66 , 0 , 18 , 18 , 33 , 12 , 21 , 36 , 36 , 6 , 36 , 6 , 60 , 36 , 36 , 18 , 48 , 0 , 24 , 0 , 30 , 24 , 87 , 24 , 24 , 27 , 42 , 6 , 60 , 18 , 66 , 6 , 18 , 0 , 36 , 6 , 39 , 36 , 30 , 18 , 36 , 9 , 30 , 0 , 18 , 18 , 51 , 12 , 48 , 0 , 54 , 0 , 48 , 18 , 36 , 30 , 36 , 30 , 66 , 3 , 12 , 18 , 15 , 39 , 60 , 0 , 24 , 12 , 66 , 6 , 54 , 12 , 48 , 6 , 18 , 7 , 30 , 24 , 48 , 18 , 30 , 0 , 84 , 0 , 30 , 48 , 12 , 15 , 60 , 9 , 42 , 18 , 42 , 18 , 42 , 18 , 48 , 0 , 30 , 9 , 48 , 21 , 69 , 36 , 12 , 12 , 48 , 0 , 57 , 18 , 24 , 24 , 66 , 0 , 36 , 6 , 24 , 21 , 69 , 6 , 54 , 12 , 30 , 18 , 72 , 18 , 30 , 30 , 18 , 0 , 42 , 0 , 42 , 42 , 12 , 18 , 42 , 6 , 54 , 9 , 42 , 12 , 72 , 18 , 24 , 0 , 24 , 3 , 78 , 0 , 24 , 24 , 30 , 15 , 60 , 6 , 42 , 30 , 39 , 21 , 36 , 0 , 54 , 12 , 27 , 24 , 42 , 24 , 72 , 21 , 30 , 0 , 48 , 18 , 24 , 30 , 12 , 0 , 30 , 3 , 24 , 15 , 72 , 33 , 42 , 6 , 24 , 24 , 12 , 24 , 66 , 12 , 60 , 0 , 24 , 6 , 63 , 12 , 42 , 18 , 24 , 18 , 84 , 6 , 30 , 24 , 24 , 6 , 90 , 0 , 72 , 6 , 21 , 24 , 30 , 18 , 18 , 30 , 24 , 6 , 66 , 18 , 54 , 18 , 36 , 0 , 36 , 12 , 60 , 27 , 30 , 18 , 90 , 18 , 18 , 0 , 18 , 24 , 48 , 24 , 30 , 0 , 36 , 6 , 36 , 18 , 66 , 36 , 30 , 3 , 66 , 3 , 57 , 48 , 12 , 18 , 36 , 0 , 48 , 6 , 36 , 21 , 48 , 0 , 60 , 12 , 36 , 12 , 72 , 0 , 36 , 30 , 30 , 0 , 48 , 0 , 33 , 30 , 48 , 9 , 54 , 9 , 36 , 24 , 18 , 30 , 42 , 18 , 54 , 0 , 12 , 0 , 54 , 12 , 21 , 24 , 30 , 21 , 72 , 0 , 66 , 24 , 27 , 18 , 36 , 0 , 24 , 0 , 45 , 24 , 78 , 0 , 42 , 21 , 24 , 12 , 39 , 30 , 54 , 30 , 24 , 0 , 84 , 15 , 24 , 24 , 9 , 30 , 54 , 9 , 48 , 6 , 33 , 18 , 57 , 18 , 30 , 0 , 60 , 3 , 54 , 27 , 33 , 30 , 36 , 24 , 42 , 0 , 54 , 18 , 39 , 24 , 54 , 0 , 60 , 18 , 24 , 15 , 75 , 12 , 24 , 12 , 42 , 0 , 39 , 12 , 36 , 36 , 36 , 0 , 30 , 3 , 66 , 42 , 15 , 24 , 72 , 12 , 48 , 12 , 42 , 12 , 48 , 15 , 24 , 0 , 18 , 18 , 60 , 6 , 60 , 18 , 36 , 9 , 24 , 6 , 27 , 36 , 30 , 24 , 90 , 0 , 60 , 3 , 21 , 18 , 54 , 24 , 48 , 18 , 18 , 12 , 51 , 24 , 39 , 18 , 18 , 0 , 72 , 12 , 42 , 21 , 36 , 24 , 36 , 6 , 36 , 0 , 33 , 18 , 42 , 0 , 60 , 0 , 18 , 6 , 42 , 21 , 39 , 39 , 36 , 13 , 84 , 6 , 24 , 18 , 30 , 24 , 78 , 0 , 36 , 3 , 54 , 39 , 51 , 18 , 30 , 21 , 24 , 3 , 60 , 12 , 87 , 42 , 30 , 0 , 36 , 6 , 30 , 15 , 36 , 12 , 54 , 18 , 42 , 12 , 27 , 24 , 84 , 15 , 42 , 0 , 18 , 9 , 54 , 18 , 30 , 30 , 48 , 12 , 72 , 0 , 54 , 42 , 9 , 12 , 36 , 0 , 60 , 0 , 27 , 21 , 78 , 18 , 42 , 30 , 30 , 6 , 54 , 6 , 30 , 18 , 24 , 0 , 60 , 12 , 42 , 36 , 48 , 24 , 54 , 6 , 36 , 15 , 12 , 48 , 21 , 12 , 30 , 0 , 36 , 0 , 102 , 6 , 18 , 12 , 24 , 9 , 60 , 12 , 48 , 24 , 33 , 30 , 66 , 0 , 30 , 12 , 30 , 15 , 60 , 12 , 54 , 36 , 30 , 0 , 36 , 6 , 72 , 18 , 36 , 0 , 54 , 0 , 30 , 36 , 9 , 15 , 60 , 0 , 60 , 15 , 39 , 12 , 63 , 18 , 42 , 0 , 30 , 18 , 60 , 21 , 57 , 30 , 0 , 18 , 54 , 3 , 75 , 30 , 48 , 24 , 42 , 0 , 24 , 12 , 36 , 42 , 57 , 9 , 48 , 9 , 36 , 6 , 45 , 12 , 24 , 48 , 54 , 0 , 66 , 0 , 45 , 33 , 30 , 18 , 54 , 18 , 36 , 0 , 36 , 6 , 54 , 30 , 54 , 0 , 36 , 0 , 66 , 12 , 42 , 21 , 24 , 18 , 48 , 6 , 21 , 48 , 42 , 12 , 60 , 0 , 84 , 12 , 0 , 12 , 54 , 24 , 36 , 18 , 18 , 12 , 81 , 18 , 33 , 18 , 12 , 0 , 66 , 3 , 66 , 6 , 33 , 48 , 48 , 6 , 24 , 24 , 36 , 18 , 60 , 6 , 36 , 0 , 24 , 6 , 39 , 21 , 42 , 18 , 42 , 12 , 60 , 0 , 24 , 30 , 33 , 36 , 72 , 0 , 30 , 0 , 36 , 36 , 42 , 12 , 36 , 15 , 24 , 15 , 75 , 30 , 63 , 27 , 24 , 0 , 42 , 6 , 63 , 30 , 18 , 12 , 108 , 9 , 48 , 12 , 24 , 12 , 72 , 18 , 30 , 0 , 54 , 6 , 30 , 9 , 63 , 27 , 48 , 15 , 36 , 6 , 48 , 36 , 18 , 12 , 54 , 0 , 42 , 9 , 36 , 36 , 63 , 18 , 36 , 24 , 36 , 0 , 75 , 6 , 63 , 24 , 36 , 0 , 48 , 6 , 27 , 39 , 30 , 18 , 30 , 9 , 54 , 18 , 36 , 18 , 39 , 21 , 66 , 0 , 30 , 0 , 54 , 18 , 42 , 36 , 12 , 24 , 108 , 0 , 30 , 24 , 42 , 12 , 48 , 0 , 24 , 0 , 15 , 9 , 48 , 18 , 66 , 24 , 24 , 12 , 54 , 12 , 36 , 21 , 54 , 0 , 54 , 18 , 45 , 42 , 36 , 24 , 42 , 3 , 36 , 0 , 42 , 48 , 42 , 12 , 36 , 0 , 36 , 1 , 60 , 18 , 36 , 18 , 36 , 15 , 54 , 9 , 60 , 30 , 24 , 21 , 48 , 0 , 24 , 18 , 24 , 18 , 90 , 6 , 72 , 15 , 36 , 9 , 48 , 6 , 36 , 42 , 48 , 0 , 78 , 3 , 54 , 27 , 18 , 36 , 48 , 15 , 54 , 12 , 30 , 24 , 84 , 12 , 18 , 0 , 18 , 12 , 105 , 12 , 24 , 30 , 30 , 18 , 36 , 0 , 60 , 30 , 27 , 12 , 48 , 0 , 90 , 6 , 18 , 18 , 33 , 21 , 42 , 24 , 24 , 12 , 45 , 24 , 60 , 36 , 36 , 0 , 66 , 6 , 27 , 15 , 42 , 24 , 60 , 12 , 18 , 9 , 30 , 18 , 84 , 12 , 72 , 0 , 12 , 6 , 42 , 21 , 45 , 12 , 18 , 9 , 96 , 12 , 21 , 30 , 30 , 24 , 66 , 0 , 48 , 12 , 42 , 18 , 36 , 18 , 24 , 24 , 24 , 0 , 30 , 12 , 27 , 42 , 18 , 0 , 72 , 0 , 84 , 27 , 54 , 15 , 102 , 12 , 36 , 6 , 39 , 36 , 36 , 15 , 36 , 0 , 30 , 15 , 57 , 12 , 57 , 42 , 30 , 9 , 60 , 6 , 27 , 42 , 27 , 30 , 36 , 0 , 54 , 6 , 24 , 21 , 78 , 12 , 42 , 18 , 18 , 12 , 84 , 18 , 54 , 18 , 48 , 0 , 66 , 12 , 15 , 36 , 30 , 18 , 72 , 9 , 66 , 0 , 27 , 18 , 24 , 6 , 78 , 0 , 42 , 6 , 81 , 27 , 27 , 36 , 24 , 24 , 48 , 0 , 72 , 18 , 39 , 30 , 42 , 0 , 18 , 18 , 30 , 24 , 78 , 6 , 18 , 18 , 36 , 0 , 48 , 30 , 84 , 6 , 18 , 0 , 54 , 0 , 42 , 36 , 12 , 30 , 90 , 12 , 48 , 18 , 24 , 18 , 21 , 18 , 48 , 0 , 60 , 0 , 60 , 6 , 30 , 42 , 24 , 18 , 66 , 0 , 27 , 36 , 24 , 18 , 54 , 0 , 48 , 6 , 30 , 18 , 90 , 15 , 42 , 9 , 48 , 18 , 42 , 6 , 45 , 24 , 36 , 0 , 48 , 0 , 78 , 39 , 27 , 12 , 42 , 27 , 48 , 6 , 45 , 18 , 72 , 36 , 48 , 0 , 18 , 9 , 66 , 9 , 54 , 33 , 18 , 18 , 66 , 12 , 39 , 36 , 45 , 12 , 72 , 0 , 48 , 12 , 21 , 39 , 33 , 18 , 60 , 18 , 36 , 0 , 78 , 18 , 39 , 36 , 24 , 0 , 30 , 0 , 30 , 30 , 54 , 21 , 66 , 6 , 30 , 21 , 39 , 18 , 60 , 15 , 72 , 0 , 30 , 18 , 45 , 12 , 39 , 18 , 60 , 6 , 66 , 15 , 36 , 30 , 12 , 18 , 60 , 0 , 60 , 0 , 18 , 33 , 57 , 18 , 24 , 24 , 42 , 6 , 66 , 12 , 81 , 42 , 18 , 0 , 36 , 6 , 42 , 18 , 24 , 24 , 72 , 0 , 18 , 0 , 30 , 30 , 87 , 18 , 36 , 0 , 42 , 3 , 45 , 12 , 36 , 42 , 24 , 25 , 30 , 6 , 72 , 24 , 18 , 18 , 60 , 0 , 102 , 12 , 42 , 12 , 90 , 12 , 24 , 27 , 24 , 12 , 69 , 24 , 30 , 18 , 42 , 0 , 48 , 0 , 42 , 45 , 39 , 15 , 60 , 18 , 30 , 12 , 33 , 24 , 72 , 18 , 36 , 0 , 24 , 12 , 51 , 24 , 39 , 36 , 24 , 6 , 120 , 0 , 72 , 24 , 30 , 30 , 30 , 0 , 24 , 12 , 72 , 18 , 54 , 3 , 84 , 30 , 30 , 21 , 42 , 24 , 30 , 18 , 30 , 0 , 54 , 0 , 36 , 30 , 24 , 30 , 72 , 9 , 72 , 6 , 30 , 24 , 36 , 24 , 30 , 0 , 30 , 0 , 90 , 12 , 48 , 27 , 24 , 6 , 54 , 12 , 39 , 36 , 18 , 18 , 78 , 0 , 36 , 12 , 18 , 39 , 66 , 6 , 54 , 18 , 36 , 0 , 54 , 18 , 42 , 12 , 30 , 0 , 78 , 0 , 48 , 45 , 27 , 36 , 36 , 9 , 54 , 15 , 6 , 12 , 99 , 15 , 48 , 0 , 24 , 3 , 60 , 12 , 45 , 36 , 36 , 30 , 24 , 12 , 57 , 30 , 42 , 18 , 54 , 0 , 36 , 6 , 45 , 24 , 63 , 30 , 60 , 12 , 42 , 6 , 102 , 18 , 30 , 33 , 18 , 0 , 84 , 12 , 54 , 24 , 39 , 12 , 42 , 0 , 36 , 0 , 54 , 24 , 60 , 12 , 42 , 0 , 48 , 6 , 30 , 9 , 93 , 24 , 18 , 21 , 60 , 6 , 21 , 36 , 18 , 54 , 102 , 0 , 30 , 18 , 36 , 21 , 48 , 12 , 30 , 27 , 42 , 3 , 54 , 12 , 66 , 36 , 36 , 0 , 48 , 9 , 45 , 33 , 30 , 9 , 84 , 18 , 30 , 12 , 33 , 36 , 51 , 12 , 54 , 0 , 36 , 18 , 42 , 12 , 30 , 36 , 24 , 9 , 72 , 0 , 48 , 30 , 36 , 6 , 78 , 0 , 42 , 0 , 18 , 24 , 63 , 21 , 36 , 18 , 24 , 15 , 66 , 0 , 42 , 27 , 54 , 0 , 30 , 9 , 51 , 45 , 45 , 24 , 48 , 12 , 72 , 12 , 33 , 24 , 39 , 30 , 66 , 0 , 18 , 6 , 69 , 12 , 36 , 24 , 36 , 18 , 90 , 6 , 60 , 24 , 36 , 27 , 36 , 0 , 60 , 18 , 33 , 21 , 84 , 12 , 36 , 30 , 18 , 0 , 33 , 24 , 51 , 30 , 24 , 0 , 84 , 0 , 57 , 33 , 36 , 21 , 84 , 12 , 30 , 12 , 33 , 36 , 63 , 18 , 24 , 0 , 30 , 6 , 90 , 21 , 66 , 30 , 30 , 24 , 36 , 0 , 54 , 12 , 51 , 18 , 78 , 0 , 36 , 0 , 18 , 18 , 54 , 21 , 48 , 12 , 66 , 18 , 21 , 18 , 33 , 21 , 42 , 0 , 66 , 6 , 48 , 54 , 21 , 30 , 66 , 12 , 66 , 0 , 24 , 24 , 63 , 24 , 36 , 0 , 42 , 3 , 60 , 18 , 30 , 6 , 36 , 9 , 54 , 6 , 72 , 48 , 36 , 15 , 54 , 0 , 30 , 27 , 12 , 18 , 60 , 12 , 66 , 15 , 48 , 10 , 84 , 12 , 39 , 42 , 12 , 0 , 66 , 6 , 24 , 18 , 21 , 36 , 54 , 24 , 24 , 12 , 51 , 18 , 66 , 12 , 90 , 0 , 18 , 6 , 87 , 15 , 75 , 24 , 30 , 15 , 60 , 0 , 24 , 42 , 24 , 24 , 48 , 0 , 84 , 6 , 51 , 39 , 60 , 12 , 18 , 30 , 36 , 12 , 60 , 12 , 60 , 48 , 36 , 0 , 54 , 6 , 42 , 12 , 6 , 18 , 78 , 6 , 48 , 12 , 12 , 36 , 84 , 0 , 48 , 0 , 54 , 3 , 48 , 18 , 45 , 51 , 54 , 6 , 72 , 6 , 51 , 30 , 45 , 30 , 48 , 0 , 36 , 6 , 36 , 15 , 78 , 24 , 42 , 24 , 24 , 0 , 90 , 18 , 36 , 24 , 24 , 0 , 36 , 0 , 36 , 30 , 30 , 30 , 66 , 6 , 78 , 21 , 30 , 12 , 21 , 15 , 60 , 0 , 36 , 12 , 66 , 21 , 36 , 24 , 30 , 18 , 60 , 9 , 54 , 48 , 24 , 18 , 48 , 0 , 30 , 6 , 42 , 18 , 81 , 18 , 54 , 27 , 24 , 12 , 30 , 18 , 84 , 30 , 24 , 0 , 102 , 9 , 42 , 42 , 36 , 24 , 90 , 3 , 30 , 0 , 60 , 30 , 42 , 18 , 24 , 0 , 18 , 0 , 78 , 12 , 42 , 27 , 42 , 18 , 66 , 18 , 45 , 18 , 42 , 9 , 84 , 0 , 54 , 6 , 15 , 54 , 63 , 18 , 54 , 24 , 24 , 9 , 57 , 24 , 45 , 54 , 36 , 0 , 60 , 0 , 66 , 27 , 33 , 18 , 30 , 9 , 60 , 24 , 30 , 12 , 54 , 21 , 24 , 0 , 12 , 18 , 108 , 15 , 66 , 12 , 30 , 27 , 66 , 0 , 36 , 30 , 36 , 24 , 66 , 0 , 60 , 0 , 9 , 24 , 54 , 12 , 90 , 15 , 42 , 0 , 51 , 30 , 18 , 30 , 48 , 0 , 84 , 9 , 48 , 21 , 54 , 30 , 24 , 18 , 36 , 12 , 45 , 18 , 96 , 6 , 30 , 0 , 30 , 9 , 30 , 24 , 42 , 24 , 24 , 15 , 66 , 6 , 69 , 36 , 15 , 15 , 84 , 0 , 36 , 15 , 48 , 27 , 45 , 18 , 42 , 30 , 36 , 0 , 66 , 6 , 72 , 30 , 48 , 0 , 42 , 3 , 51 , 39 , 30 , 33 , 78 , 12 , 24 , 18 , 30 , 18 , 105 , 21 , 72 , 0 , 42 , 12 , 39 , 18 , 27 , 42 , 24 , 6 , 66 , 3 , 60 , 42 , 30 , 30 , 60 , 0 , 54 , 6 , 54 , 24 , 57 , 6 , 54 , 6 , 24 , 24 , 54 , 12 , 57 , 27 , 42 , 0 , 48 , 6 , 36 , 27 , 57 , 12 , 84 , 12 , 60 , 0 , 12 , 30 , 54 , 24 , 48 , 0 , 18 , 3 , 105 , 36 , 48 , 42 , 24 , 18 , 48 , 6 , 30 , 36 , 45 , 42 , 42 , 0 , 54 , 9 , 36 , 12 , 48 , 12 , 54 , 30 , 30 , 6 , 48 , 6 , 51 , 18 , 36 , 0 , 102 , 6 , 18 , 30 , 33 , 24 , 48 , 18 , 60 , 12 , 60 , 30 , 45 , 12 , 36 , 0 , 54 , 12 , 60 , 6 , 48 , 54 , 12 , 13 , 60 , 0 , 72 , 18 , 24 , 6 , 90 , 0 , 48 , 12 , 15 , 42 , 96 , 18 , 36 , 18 , 36 , 6 , 78 , 24 , 48 , 18 , 30 , 0 , 48 , 18 , 78 , 42 , 24 , 30 , 60 , 6 , 60 , 12 , 18 , 12 , 42 , 30 , 42 , 0 , 24 , 0 , 81 , 9 , 54 , 18 , 60 , 33 , 48 , 0 , 27 , 54 , 51 , 27 , 90 , 0 , 60 , 18 , 24 , 18 , 54 , 24 , 36 , 12 , 42 , 0 , 87 , 24 , 33 , 18 , 24 , 0 , 96 , 0 , 87 , 36 , 30 , 15 , 42 , 12 , 36 , 24 , 24 , 36 , 42 , 21 , 48 , 0 , 30 , 6 , 42 , 18 , 48 , 24 , 24 , 18 , 84 , 3 , 36 , 42 , 42 , 36 , 72 , 0 , 54 , 6 , 30 , 15 , 60 , 6 , 78 , 30 , 24 , 6 , 72 , 6 , 66 , 45 , 24 , 0 , 42 , 21 , 36 , 30 , 36 , 18 , 48 , 12 , 30 , 0 , 39 , 24 , 102 , 18 , 36 , 0 , 12 , 6 , 54 , 6 , 30 , 33 , 66 , 21 , 90 , 3 , 78 , 36 , 9 , 18 , 36 , 0 , 84 , 0 , 30 , 30 , 93 , 24 , 30 , 24 , 30 , 15 , 63 , 12 , 48 , 30 , 54 , 0 , 48 , 0 , 54 , 42 , 42 , 30 , 78 , 0 , 36 , 24 , 39 , 24 , 60 , 12 , 78 , 0 , 60 , 6 , 51 , 30 , 36 , 36 , 30 , 18 , 60 , 0 , 30 , 30 , 51 , 24 , 60 , 0 , 42 , 3 , 24 , 9 , 54 , 21 , 24 , 33 , 30 , 24 , 66 , 24 , 69 , 18 , 30 , 0 , 102 , 15 , 54 , 24 , 15 , 30 , 120 , 6 , 30 , 3 , 51 , 24 , 54 , 12 , 30 , 0 , 36 , 6 , 36 , 12 , 90 , 42 , 12 , 12 , 60 , 12 , 60 , 24 , 42 , 12 , 90 , 0 , 24 , 12 , 42 , 30 , 30 , 6 , 78 , 21 , 42 , 0 , 54 , 24 , 27 , 54 , 24 , 0 , 66 , 6 , 45 , 30 , 12 , 30 , 42 , 12 , 84 , 15 , 36 , 18 , 84 , 24 , 36 , 0 , 30 , 18 , 72 , 18 , 60 , 24 , 48 , 12 , 54 , 6 , 36 , 54 , 42 , 12 , 42 , 0 , 60 , 0 , 51 , 48 , 54 , 9 , 36 , 27 , 24 , 6 , 84 , 18 , 48 , 30 , 42 , 0 , 78 , 0 , 48 , 27 , 27 , 48 , 42 , 18 , 36 , 0 , 39 , 18 , 99 , 24 , 102 , 0 , 18 , 0 , 48 , 18 , 72 , 15 , 36 , 12 , 84 , 12 , 24 , 12 , 30 , 39 , 84 , 0 , 36 , 12 , 39 , 39 , 63 , 24 , 42 , 24 , 66 , 6 , 72 , 18 , 18 , 24 , 30 , 0 , 60 , 6 , 48 , 42 , 36 , 15 , 78 , 6 , 48 , 30 , 12 , 36 , 54 , 12 , 36 , 0 , 42 , 6 , 45 , 6 , 69 , 24 , 72 , 21 , 48 , 0 , 57 , 48 , 12 , 24 , 48 , 0 , 48 , 3 , 48 , 15 , 78 , 24 , 60 , 18 , 12 , 12 , 111 , 24 , 54 , 24 , 24 , 0 , 48 , 6 , 36 , 33 , 42 , 6 , 54 , 9 , 72 , 18 , 27 , 30 , 30 , 12 , 54 , 0 , 66 , 4 , 78 , 21 , 24 , 54 , 18 , 24 , 54 , 6 , 60 , 24 , 54 , 21 , 78 , 0 , 36 , 18 , 54 , 30 , 66 , 18 , 48 , 30 , 24 , 0 , 42 , 12 , 99 , 36 , 30 , 0 , 90 , 6 , 18 , 30 , 30 , 24 , 78 , 6 , 66 , 9 , 24 , 42 , 78 , 30 , 42 , 0 , 18 , 12 , 102 , 6 , 33 , 24 , 18 , 12 , 66 , 9 , 54 , 24 , 24 , 36 , 84 , 0 , 60 , 6 , 39 , 15 , 78 , 12 , 42 , 21 , 42 , 18 , 42 , 18 , 18 , 42 , 24 , 0 , 48 , 3 , 105 , 51 , 42 , 30 , 42 , 18 , 72 , 0 , 24 , 24 , 102 , 6 , 36 , 0 , 36 , 9 , 99 , 12 , 48 , 21 , 48 , 18 , 42 , 6 , 36 , 42 , 18 , 12 , 78 , 0 , 48 , 30 , 30 , 18 , 36 , 30 , 42 , 9 , 42 , 6 , 60 , 12 , 39 , 30 , 24 , 0 , 78 , 0 , 48 , 30 , 39 , 27 , 102 , 24 , 30 , 12 , 51 , 12 , 66 , 9 , 48 , 0 , 30 , 18 , 45 , 39 , 87 , 30 , 36 , 9 , 72 , 0 , 60 , 24 , 30 , 36 , 54 , 0 , 48 , 0 , 45 , 36 , 45 , 18 , 42 , 27 , 60 , 9 , 66 , 12 , 78 , 42 , 18 , 0 , 60 , 6 , 60 , 33 , 36 , 24 , 96 , 12 , 18 , 12 , 12 , 36 , 72 , 0 , 78 , 0 , 36 , 6 , 60 , 24 , 27 , 51 , 42 , 24 , 84 , 12 , 57 , 48 , 30 , 24 , 42 , 0 , 60 , 12 , 24 , 18 , 96 , 12 , 30 , 30 , 30 , 0 , 93 , 18 , 48 , 18 , 60 , 0 , 48 , 6 , 54 , 36 , 30 , 12 , 42 , 9 , 60 , 18 , 12 , 24 , 69 , 6 , 60 , 0 , 54 , 6 , 33 , 15 , 60 , 36 , 30 , 18 , 90 , 3 , 72 , 24 , 54 , 54 , 42 , 0 , 18 , 9 , 60 , 30 , 84 , 18 , 48 , 24 , 12 , 6 , 66 , 36 , 24 , 27 , 24 , 0 , 42 , 12 , 39 , 42 , 27 , 18 , 108 , 9 , 78 , 0 , 48 , 12 , 54 , 30 , 30 , 0 , 36 , 0 , 48 , 12 , 75 , 39 , 30 , 6 , 42 , 9 , 66 , 30 , 33 , 18 , 96 , 0 , 48 , 18 , 39 , 36 , 102 , 12 , 54 , 18 , 24 , 9 , 45 , 24 , 72 , 30 , 36 , 0 , 78 , 6 , 63 , 36 , 36 , 21 , 60 , 9 , 36 , 12 , 54 , 24 , 78 , 27 , 42 , 0 , 42 , 18 , 60 , 9 , 24 , 24 , 54 , 39 , 84 , 0 , 27 , 36 , 39 , 12 , 84 , 0 , 66 , 0 , 21 , 30 , 30 , 42 , 66 , 18 , 18 , 18 , 78 , 12 , 48 , 42 , 36 , 0 , 90 , 6 , 48 , 33 , 39 , 24 , 48 , 15 , 54 , 15 , 54 , 24 , 48 , 18 , 60 , 0 , 24 , 0 , 48 , 24 , 78 , 24 , 36 , 9 , 90 , 12 , 42 , 24 , 30 , 45 , 54 , 0 , 66 , 12 , 24 , 12 , 60 , 6 , 48 , 33 , 48 , 0 , 60 , 6 , 51 , 54 , 12 , 0 , 30 , 0 , 69 , 21 , 42 , 15 , 72 , 15 , 48 , 21 , 33 , 36 , 96 , 6 , 30 , 0 , 54 , 6 , 87 , 30 , 42 , 30 , 36 , 13 , 42 , 6 , 84 , 48 , 18 , 18 , 72 , 0 , 54 , 12 , 30 , 30 , 75 , 24 , 36 , 24 , 42 , 18 , 78 , 12 , 36 , 30 , 72 , 0 , 48 , 6 , 33 , 36 , 57 , 36 , 66 , 6 , 54 , 0 , 27 , 36 , 66 , 12 , 90 , 0 , 24 , 3 , 96 , 24 , 27 , 24 , 18 , 24 , 108 , 12 , 42 , 48 , 24 , 18 , 30 , 0 , 54 , 18 , 48 , 12 , 75 , 18 , 90 , 21 , 36 , 12 , 72 , 12 , 45 , 24 , 24 , 0 , 114 , 0 , 27 , 30 , 39 , 33 , 48 , 12 , 54 , 12 , 18 , 42 , 45 , 27 , 48 , 0 , 48 , 6 , 90 , 9 , 60 , 42 , 36 , 12 , 48 , 0 , 36 , 42 , 42 , 18 , 78 , 0 , 30 , 6 , 24 , 33 , 78 , 9 , 84 , 30 , 18 , 15 , 63 , 18 , 51 , 30 , 48 , 0 , 72 , 6 , 36 , 51 , 24 , 30 , 48 , 21 , 96 , 6 , 24 , 6 , 93 , 12 , 48 , 0 , 18 , 6 , 69 , 18 , 36 , 18 , 24 , 18 , 24 , 6 , 54 , 36 , 51 , 33 , 96 , 0 , 36 , 15 , 27 , 30 , 54 , 30 , 42 , 12 , 36 , 0 , 117 , 36 , 54 , 36 , 24 , 0 , 96 , 3 , 72 , 36 , 57 , 27 , 54 , 6 , 54 , 21 , 36 , 12 , 66 , 33 , 60 , 0 , 30 , 24 , 24 , 15 , 63 , 30 , 42 , 24 , 78 , 9 , 39 , 30 , 24 , 24 , 138 , 0 , 42 , 0 , 54 , 24 , 57 , 12 , 30 , 24 , 42 , 18 , 54 , 6 , 60 , 33 , 24 , 0 , 72 , 6 , 84 , 24 , 42 , 6 , 66 , 15 , 36 , 0 , 42 , 48 , 51 , 18 , 66 , 0 , 60 , 3 , 60 , 12 , 60 , 57 , 42 , 9 , 72 , 12 , 60 , 42 , 27 , 24 , 60 , 0 , 42 , 18 , 24 , 30 , 48 , 30 , 36 , 18 , 30 , 9 , 78 , 12 , 51 , 18 , 30 , 0 , 60 , 0 , 12 , 57 , 51 , 18 , 78 , 6 , 102 , 12 , 30 , 24 , 48 , 27 , 36 , 0 , 30 , 12 , 126 , 6 , 27 , 36 , 30 , 18 , 66 , 0 , 60 , 30 , 48 , 36 , 48 , 0 , 24 , 6 , 39 , 24 , 96 , 12 , 90 , 33 , 36 , 6 , 39 , 6 , 90 , 27 , 36 , 0 , 60 , 12 , 45 , 42 , 30 , 30 , 72 , 12 , 36 , 9 , 39 , 36 , 69 , 24 , 48 , 0 , 36 , 6 , 66 , 15 , 72 , 39 , 36 , 27 , 54 , 18 , 57 , 30 , 42 , 12 , 60 , 0 , 84 , 24 , 36 , 27 , 72 , 12 , 48 , 21 , 60 , 0 , 51 , 30 , 27 , 30 , 90 , 0 , 78 , 0 , 42 , 57 , 12 , 30 , 48 , 18 , 42 , 6 , 48 , 24 , 90 , 15 , 42 , 0 , 12 , 15 , 84 , 24 , 72 , 18 , 48 , 21 , 66 , 3 , 54 , 42 , 30 , 24 , 48 , 0 , 36 , 18 , 27 , 12 , 42 , 9 , 108 , 18 , 36 , 12 , 96 , 24 , 21 , 30 , 24 , 0 , 96 , 9 , 54 , 18 , 75 , 30 , 54 , 18 , 36 , 0 , 39 , 18 , 84 , 18 , 42 , 0 , 24 , 6 , 54 , 18 , 57 , 42 , 24 , 9 , 84 , 18 , 48 , 42 , 27 , 30 , 78 , 0 , 60 , 0 , 30 , 48 , 36 , 6 , 30 , 36 , 6 , 10 , 78 , 12 , 51 , 48 , 48 , 0 , 90 , 0 , 75 , 9 , 42 , 24 , 48 , 15 , 72 , 12 , 33 , 42 , 108 , 12 , 54 , 0 , 54 , 18 , 51 , 42 , 36 , 48 , 48 , 12 , 72 , 0 , 42 , 18 , 45 , 30 , 66 , 0 , 78 , 3 , 36 , 15 , 78 , 30 , 30 , 30 , 30 , 15 , 102 , 12 , 54 , 18 , 30 , 0 , 36 , 6 , 81 , 48 , 12 , 24 , 108 , 6 , 78 , 18 , 24 , 36 , 33 , 18 , 30 , 0 , 30 , 0 , 108 , 21 , 54 , 42 , 18 , 18 , 90 , 6 , 30 , 48 , 69 , 36 , 48 , 0 , 24 , 15 , 24 , 15 , 84 , 24 , 114 , 6 , 30 , 0 , 48 , 6 , 60 , 42 , 24 , 0 , 102 , 12 , 42 , 42 , 27 , 21 , 78 , 9 , 42 , 24 , 51 , 24 , 42 , 12 , 48 , 0 , 60 , 12 , 66 , 6 , 42 , 24 , 30 , 24 , 42 , 0 , 78 , 24 , 54 , 12 , 66 , 0 , 30 , 6 , 24 , 51 , 99 , 18 , 60 , 24 , 42 , 18 , 54 , 6 , 45 , 60 , 36 , 0 , 54 , 6 , 39 , 39 , 39 , 30 , 66 , 18 , 72 , 0 , 51 , 24 , 102 , 12 , 54 , 0 , 24 , 0 , 102 , 12 , 48 , 24 , 42 , 36 , 60 , 0 , 12 , 48 , 18 , 12 , 54 , 0 , 84 , 18 , 39 , 9 , 84 , 30 , 66 , 18 , 48 , 15 , 72 , 48 , 39 , 42 , 48 , 0 , 60 , 0 , 84 , 30 , 45 , 33 , 54 , 6 , 54 , 30 , 33 , 30 , 90 , 6 , 54 , 0 , 24 , 6 , 72 , 27 , 78 , 12 , 24 , 15 , 66 , 0 , 54 , 36 , 21 , 42 , 114 , 0 , 60 , 3 , 30 , 33 , 54 , 27 , 30 , 33 , 60 , 6 , 54 , 12 , 48 , 33 , 36 , 0 , 42 , 12 , 45 , 39 , 24 , 36 , 96 , 18 , 24 , 12 , 33 , 18 , 99 , 18 , 66 , 0 , 36 , 0 , 51 , 24 , 30 , 30 , 36 , 15 , 84 , 6 , 102 , 48 , 48 , 18 , 60 , 0 , 72 , 12 , 36 , 42 , 60 , 12 , 24 , 21 , 30 , 0 , 54 , 18 , 60 , 18 , 42 , 0 , 66 , 6 , 24 , 24 , 54 , 15 , 78 , 12 , 42 , 27 , 27 , 30 , 51 , 27 , 78 , 0 , 48 , 6 , 120 , 27 , 48 , 42 , 24 , 12 , 54 , 6 , 54 , 24 , 48 , 36 , 66 , 0 , 78 , 9 , 57 , 21 , 48 , 18 , 54 , 33 , 24 , 30 , 84 , 18 , 45 , 33 , 30 , 0 , 126 , 9 , 36 , 30 , 27 , 30 , 66 , 18 , 54 , 0 , 36 , 42 , 48 , 6 , 42 , 0 , 54 , 6 , 57 , 12 , 84 , 54 , 48 , 6 , 60 , 6 , 63 , 18 , 42 , 36 , 78 , 0 , 24 , 24 , 33 , 24 , 105 , 24 , 66 , 27 , 48 , 0 , 48 , 30 , 60 , 30 , 54 , 0 , 42 , 3 , 75 , 48 , 24 , 12 , 66 , 12 , 96 , 6 , 30 , 12 , 87 , 21 , 36 , 0 , 30 , 24 , 69 , 12 , 57 , 30 , 48 , 24 , 54 , 0 , 42 , 54 , 24 , 24 , 72 , 0 , 60 , 0 , 48 , 24 , 69 , 24 , 42 , 18 , 36 , 12 , 66 , 24 , 36 , 42 , 18 , 0 , 78 , 9 , 48 , 36 , 42 , 42 , 36 , 12 , 36 , 21 , 78 , 18 , 48 , 12 , 102 , 0 , 18 , 12 , 54 , 24 , 45 , 27 , 42 , 13 , 108 , 12 , 39 , 24 , 42 , 27 , 102 , 0 , 60 , 6 , 39 , 24 , 54 , 12 , 54 , 24 , 24 , 0 , 114 , 24 , 63 , 48 , 30 , 0 , 48 , 6 , 69 , 36 , 18 , 12 , 72 , 6 , 48 , 18 , 33 , 54 , 117 , 12 , 42 , 0 , 66 , 12 , 48 , 6 , 54 , 36 , 42 , 21 , 102 , 6 , 48 , 54 , 33 , 30 , 48 , 0 , 72 , 0 , 30 , 24 , 75 , 24 , 84 , 30 , 30 , 0 , 72 , 18 , 30 , 42 , 54 , 0 , 60 , 12 , 36 , 45 , 42 , 12 , 96 , 6 , 66 , 0 , 12 , 36 , 78 , 36 , 42 , 0 , 36 , 0 , 78 , 24 , 48 , 24 , 18 , 30 , 90 , 15 , 96 , 18 , 27 , 21 , 54 , 0 , 24 , 21 , 48 , 27 , 84 , 18 , 48 , 42 , 36 , 6 , 66 , 12 , 108 , 12 , 42 , 0 , 48 , 9 , 27 , 60 , 21 , 36 , 84 , 6 , 36 , 18 , 42 , 18 , 54 , 18 , 60 , 0 , 60 , 15 , 72 , 9 , 99 , 42 , 12 , 12 , 60 , 0 , 57 , 42 , 18 , 18 , 78 , 0 , 42 , 6 , 36 , 36 , 63 , 9 , 42 , 15 , 30 , 18 , 78 , 6 , 24 , 48 , 42 , 0 , 102 , 12 , 75 , 45 , 42 , 30 , 84 , 24 , 66 , 9 , 24 , 30 , 90 , 24 , 42 , 0 , 24 , 3 , 84 , 21 , 84 , 33 , 66 , 24 , 36 , 6 , 36 , 48 , 51 , 18 , 72 , 0 , 66 , 18 , 54 , 30 , 24 , 18 , 48 , 18 , 30 , 0 , 102 , 12 , 45 , 36 , 24 , 0 , 102 , 3 , 42 , 15 , 42 , 54 , 54 , 21 , 66 , 24 , 66 , 30 , 102 , 3 , 66 , 0 , 48 , 12 , 24 , 30 , 45 , 36 , 54 , 6 , 78 , 9 , 48 , 24 , 39 , 36 , 96 , 0 , 66 , 6 , 27 , 27 , 60 , 30 , 18 , 30 , 48 , 12 , 90 , 24 , 60 , 36 , 6 , 0 , 42 , 12 , 78 , 36 , 36 , 24 , 114 , 6 , 60 , 0 , 18 , 6 , 69 , 18 , 84 , 0 , 36 , 6 , 48 , 6 , 39 , 24 , 42 , 24 , 54 , 6 , 72 , 48 , 36 , 42 , 60 , 0 , 48 , 0 , 36 , 18 , 138 , 24 , 30 , 30 , 42 , 18 , 75 , 18 , 48 , 18 , 24 , 0 , 78 , 0 , 78 , 57 , 60 , 9 , 48 , 9 , 36 , 30 , 30 , 42 , 42 , 39 , 84 , 0 , 24 , 12 , 87 , 27 , 30 , 42 , 24 , 24 , 90 , 0 , 36 , 24 , 60 , 36 , 84 , 0 , 42 , 0 , 30 , 21 , 87 , 12 , 72 , 24 , 42 , 12 , 60 , 30 , 72 , 21 , 60 , 0 , 96 , 12 , 30 , 42 , 39 , 18 , 66 , 12 , 84 , 12 , 63 , 42 , 42 , 24 , 42 , 0 , 18 , 6 , 78 , 15 , 75 , 45 , 54 , 12 , 54 , 6 , 84 , 30 , 30 , 18 , 54 , 0 , 42 , 24 , 39 , 27 , 96 , 18 , 42 , 21 , 48 , 0 , 54 , 18 , 33 , 36 , 66 , 0 , 84 , 0 , 75 , 48 , 30 , 42 , 54 , 12 , 54 , 15 , 42 , 30 , 96 , 18 , 42 , 0 , 18 , 6 , 123 , 15 , 48 , 24 , 48 , 39 , 42 , 6 , 21 , 54 , 45 , 12 , 60 , 0 , 90 , 12 , 30 , 36 , 45 , 18 , 72 , 21 , 78 , 12 , 30 , 12 , 60 , 30 , 18 , 0 , 78 , 6 , 60 , 36 , 33 , 18 , 60 , 12 , 30 , 0 , 60 , 18 , 90 , 30 , 54 , 0 , 36 , 1 , 78 , 27 , 84 , 30 , 18 , 15 , 102 , 9 , 27 , 30 , 24 , 57 , 90 , 0 , 42 , 9 , 48 , 42 , 42 , 12 , 72 , 27 , 48 , 9 , 108 , 18 , 48 , 48 , 18 , 0 , 84 , 6 , 66 , 24 , 48 , 21 , 114 , 6 , 78 , 24 , 30 , 30 , 42 , 18 , 60 , 0 , 18 , 12 , 63 , 9 , 51 , 66 , 48 , 15 , 54 , 0 , 66 , 60 , 36 , 18 , 48 , 0 , 66 , 6 , 36 , 30 , 96 , 9 , 36 , 30 , 30 , 24 , 93 , 24 , 72 , 24 , 66 , 0 , 60 , 24 , 48 , 30 , 24 , 30 , 72 , 6 , 60 , 12 , 30 , 12 , 93 , 18 , 72 , 0 , 30 , 0 , 81 , 30 , 36 , 48 , 36 , 30 , 90 , 6 , 54 , 24 , 57 , 24 , 36 , 0 , 54 , 18 , 36 , 24 , 78 , 18 , 72 , 33 , 12 , 0 , 51 , 30 , 48 , 24 , 42 , 0 , 90 , 3 , 78 , 30 , 30 , 27 , 138 , 6 , 30 , 18 , 36 , 24 , 75 , 24 , 12 , 0 , 54 , 12 , 42 , 18 , 84 , 36 , 30 , 18 , 66 , 6 , 45 , 36 , 36 , 48 , 114 , 0 , 24 , 6 , 30 , 21 , 108 , 15 , 48 , 18 , 36 , 18 , 57 , 24 , 63 , 42 , 54 , 0 , 78 , 6 , 81 , 36 , 18 , 24 , 42 , 18 , 120 , 0 , 24 , 24 , 66 , 12 , 54 , 0 , 48 , 12 , 66 , 18 , 42 , 36 , 48 , 18 , 72 , 6 , 48 , 48 , 33 , 6 , 102 , 0 , 54 , 24 , 39 , 54 , 60 , 12 , 90 , 18 , 36 , 3 , 111 , 24 , 51 , 48 , 42 , 0 , 90 , 0 , 45 , 36 , 54 , 48 , 54 , 24 , 18 , 18 , 51 , 18 , 72 , 0 , 54 , 0 , 18 , 12 , 54 , 36 , 57 , 18 , 42 , 18 , 120 , 0 , 63 , 42 , 27 , 36 , 48 , 0 , 54 , 6 , 39 , 30 , 81 , 18 , 72 , 33 , 54 , 9 , 72 , 12 , 54 , 54 , 24 , 0 , 54 , 15 , 75 , 24 , 60 , 12 , 78 , 6 , 30 , 12 , 39 , 54 , 72 , 6 , 54 , 0 , 72 , 6 , 78 , 12 , 54 , 39 , 30 , 15 , 48 , 6 , 57 , 48 , 18 , 24 , 90 , 0 , 90 , 18 , 42 , 24 , 39 , 42 , 24 , 30 , 42 , 0 , 84 , 6 , 66 , 30 , 30 , 0 , 30 , 0 , 27 , 42 , 39 , 33 , 90 , 24 , 84 , 18 , 51 , 36 , 69 , 24 , 54 , 0 , 42 , 18 , 87 , 33 , 51 , 18 , 42 , 9 , 126 , 9 , 84 , 36 , 66 , 18 , 54 , 0 , 36 , 0 , 66 , 12 , 48 , 15 , 54 , 30 , 18 , 18 , 60 , 18 , 96 , 54 , 42 , 0 , 102 , 0 , 27 , 36 , 30 , 36 , 108 , 15 , 54 , 0 , 24 , 36 , 60 , 24 , 66 , 0 , 30 , 0 , 54 , 15 , 75 , 48 , 36 , 18 , 48 , 24 , 36 , 36 , 54 , 15 , 108 , 0 , 84 , 18 ] <NEWLINE> <INDENT> return s [ : n ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( * main ( ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> dp = [ 0 for i in range ( n + 1 ) ] <NEWLINE> maxn = 201 <NEWLINE> for x in range ( 1 , maxn ) : <NEWLINE> <INDENT> for y in range ( 1 , maxn ) : <NEWLINE> <INDENT> for z in range ( 1 , maxn ) : <NEWLINE> <INDENT> p = ( x + y + z ) ** 2 <NEWLINE> p -= ( x * y + y * z + z * x ) <NEWLINE> if p <= n : <NEWLINE> <INDENT> dp [ p ] += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for i in dp [ 1 : : ] : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT>
from itertools import ( <NEWLINE> <INDENT> accumulate , <COMMENT> <NEWLINE> groupby , <COMMENT> <NEWLINE> permutations , <COMMENT> <NEWLINE> combinations , <COMMENT> <NEWLINE> product , <COMMENT> <NEWLINE> combinations_with_replacement , <COMMENT> <NEWLINE> <DEDENT> ) <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> <NL> ans = [ 0 ] * ( 10 ** 9 ) <NEWLINE> <NL> for i , j , k in product ( list ( range ( 1 , 101 ) ) , repeat = 3 ) : <NEWLINE> <INDENT> tmp = i ** 2 + j ** 2 + k ** 2 + i * j + j * k + k * i <NEWLINE> ans [ tmp ] += 1 <NEWLINE> <NL> <DEDENT> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> print ( ans [ i ] ) <NEWLINE> <DEDENT>
ls = ls ~ [ 0 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 3 , 0 , 0 , 0 , 0 , 0 , 3 , 3 , 0 , 0 , 0 , 0 , 0 , 1 , 6 , 0 , 3 , 0 , 0 , 0 , 0 , 0 , 3 , 3 , 6 , 0 , 0 , 3 , 0 , 0 , 0 , 0 , 3 , 3 , 6 , 0 , 6 , 0 , 0 , 0 , 3 , 0 , 0 , 1 , 6 , 0 , 6 , 6 , 0 , 0 , 6 , 0 , 0 , 0 , 0 , 3 , 3 , 3 , 6 , 0 , 6 , 3 , 6 , 0 , 0 , 0 , 6 , 0 , 0 , 0 , 3 , 3 , 9 , 0 , 6 , 3 , 6 , 0 , 3 , 6 , 0 , 0 , 0 , 0 , 6 , 1 , 6 , 0 , 6 , 6 , 0 , 3 , 12 , 0 , 6 , 0 , 0 , 3 , 6 , 0 , 0 , 0 , 3 , 3 , 12 , 0 , 6 , 3 , 6 , 0 , 3 , 6 , 9 , 0 , 6 , 0 , 0 , 0 , 3 , 6 , 3 , 3 , 6 , 0 , 6 , 3 , 12 , 0 , 3 , 6 , 6 , 0 , 6 , 0 , 6 , 3 , 6 , 0 , 0 , 1 , 6 , 3 , 12 , 6 , 0 , 0 , 12 , 0 , 6 , 0 , 6 , 6 , 12 , 0 , 0 , 6 , 0 , 0 , 6 , 0 , 12 , 3 , 6 , 0 , 6 , 3 , 9 , 6 , 3 , 6 , 6 , 0 , 6 , 0 , 6 , 0 , 15 , 6 , 0 , 0 , 6 , 0 , 3 , 3 , 12 , 0 , 12 , 6 , 6 , 0 , 3 , 6 , 6 , 3 , 12 , 0 , 6 , 0 , 9 , 6 , 0 , 0 , 6 , 3 , 12 , 1 , 6 , 6 , 6 , 6 , 0 , 0 , 18 , 0 , 12 , 0 , 3 , 6 , 12 , 0 , 0 , 6 , 3 , 6 , 12 , 0 , 12 , 0 , 0 , 0 , 9 , 3 , 9 , 6 , 12 , 3 , 12 , 0 , 3 , 6 , 6 , 0 , 12 , 0 , 12 , 0 , 9 , 9 , 0 , 0 , 6 , 3 , 6 , 3 , 12 , 6 , 9 , 3 , 6 , 0 , 12 , 3 , 6 , 3 , 9 , 6 , 12 , 6 , 6 , 0 , 6 , 0 , 9 , 6 , 6 , 0 , 12 , 3 , 6 , 0 , 9 , 6 , 6 , 1 , 6 , 0 , 21 , 12 , 6 , 0 , 12 , 0 , 12 , 0 , 0 , 6 , 15 , 6 , 0 , 6 , 12 , 0 , 12 , 0 , 12 , 0 , 0 , 0 , 12 , 0 , 12 , 12 , 3 , 3 , 18 , 3 , 6 , 3 , 6 , 6 , 9 , 9 , 18 , 0 , 6 , 0 , 12 , 0 , 9 , 6 , 0 , 3 , 12 , 3 , 6 , 6 , 12 , 6 , 6 , 0 , 0 , 0 , 15 , 3 , 18 , 3 , 18 , 3 , 12 , 6 , 3 , 6 , 9 , 0 , 12 , 0 , 12 , 0 , 18 , 12 , 0 , 0 , 12 , 3 , 6 , 0 , 6 , 6 , 9 , 6 , 0 , 0 , 18 , 1 , 18 , 3 , 12 , 6 , 6 , 6 , 12 , 0 , 15 , 6 , 12 , 6 , 18 , 0 , 0 , 6 , 0 , 9 , 12 , 0 , 18 , 0 , 6 , 3 , 12 , 0 , 12 , 12 , 0 , 0 , 12 , 0 , 3 , 6 , 12 , 6 , 18 , 9 , 18 , 0 , 9 , 6 , 18 , 0 , 6 , 0 , 6 , 3 , 27 , 6 , 6 , 6 , 6 , 3 , 6 , 0 , 12 , 6 , 9 , 0 , 6 , 0 , 18 , 0 , 9 , 9 , 15 , 3 , 12 , 6 , 6 , 3 , 9 , 6 , 12 , 12 , 18 , 0 , 18 , 0 , 6 , 6 , 21 , 6 , 0 , 0 , 6 , 3 , 15 , 6 , 12 , 6 , 18 , 0 , 0 , 0 , 12 , 6 , 6 , 3 , 6 , 4 , 18 , 6 , 12 , 6 , 3 , 9 , 30 , 0 , 18 , 0 , 6 , 6 , 12 , 6 , 6 , 9 , 12 , 0 , 18 , 6 , 18 , 0 , 6 , 0 , 12 , 0 , 6 , 12 , 6 , 3 , 18 , 0 , 6 , 6 , 6 , 6 , 15 , 3 , 24 , 0 , 6 , 3 , 18 , 0 , 12 , 6 , 12 , 6 , 24 , 0 , 15 , 18 , 9 , 6 , 0 , 0 , 18 , 3 , 6 , 0 , 15 , 12 , 12 , 6 , 6 , 0 , 18 , 0 , 6 , 3 , 12 , 0 , 12 , 6 , 6 , 9 , 9 , 6 , 24 , 3 , 24 , 0 , 9 , 12 , 6 , 6 , 12 , 0 , 12 , 0 , 21 , 9 , 15 , 6 , 12 , 3 , 18 , 3 , 12 , 6 , 12 , 6 , 0 , 0 , 12 , 0 , 12 , 6 , 24 , 0 , 6 , 12 , 6 , 1 , 9 , 6 , 12 , 6 , 24 , 0 , 18 , 3 , 12 , 6 , 6 , 12 , 24 , 0 , 12 , 6 , 15 , 6 , 18 , 0 , 18 , 0 , 0 , 0 , 18 , 9 , 21 , 12 , 0 , 6 , 18 , 0 , 9 , 6 , 6 , 6 , 12 , 0 , 12 , 0 , 9 , 9 , 27 , 6 , 6 , 3 , 18 , 6 , 21 , 6 , 6 , 12 , 12 , 0 , 12 , 0 , 24 , 12 , 0 , 0 , 24 , 3 , 24 , 6 , 12 , 12 , 18 , 0 , 0 , 0 , 12 , 0 , 18 , 3 , 15 , 6 , 12 , 9 , 6 , 0 , 15 , 6 , 9 , 12 , 24 , 0 , 12 , 3 , 6 , 6 , 21 , 6 , 18 , 3 , 18 , 0 , 21 , 12 , 15 , 6 , 6 , 0 , 12 , 3 , 12 , 9 , 18 , 9 , 12 , 6 , 6 , 6 , 24 , 0 , 18 , 3 , 24 , 0 , 6 , 6 , 0 , 6 , 9 , 6 , 6 , 4 , 30 , 0 , 18 , 12 , 9 , 6 , 24 , 0 , 18 , 0 , 9 , 12 , 21 , 6 , 6 , 12 , 12 , 0 , 18 , 0 , 21 , 15 , 12 , 0 , 12 , 6 , 12 , 12 , 18 , 0 , 18 , 0 , 6 , 0 , 9 , 12 , 18 , 6 , 30 , 0 , 0 , 0 , 24 , 6 , 9 , 3 , 12 , 6 , 30 , 3 , 6 , 12 , 6 , 12 , 12 , 0 , 36 , 0 , 6 , 3 , 27 , 12 , 12 , 6 , 6 , 6 , 24 , 0 , 12 , 6 , 12 , 0 , 18 , 0 , 18 , 15 , 18 , 3 , 18 , 6 , 12 , 6 , 6 , 12 , 3 , 6 , 6 , 0 , 12 , 3 , 39 , 3 , 12 , 12 , 12 , 3 , 18 , 0 , 21 , 12 , 21 , 6 , 18 , 0 , 12 , 0 , 9 , 9 , 12 , 9 , 24 , 9 , 12 , 6 , 12 , 6 , 33 , 0 , 6 , 0 , 18 , 0 , 9 , 15 , 12 , 6 , 24 , 6 , 6 , 3 , 15 , 6 , 15 , 12 , 18 , 0 , 18 , 1 , 18 , 6 , 12 , 6 , 6 , 0 , 24 , 6 , 24 , 12 , 18 , 6 , 24 , 0 , 6 , 6 , 12 , 15 , 24 , 0 , 24 , 6 , 6 , 0 , 18 , 0 , 15 , 18 , 12 , 0 , 24 , 0 , 12 , 6 , 12 , 12 , 18 , 6 , 24 , 0 , 0 , 6 , 24 , 3 , 12 , 0 , 12 , 6 , 30 , 9 , 6 , 12 , 24 , 12 , 12 , 0 , 15 , 18 , 12 , 0 , 18 , 0 , 24 , 6 , 15 , 6 , 18 , 3 , 18 , 3 , 12 , 6 , 24 , 12 , 12 , 12 , 6 , 0 , 36 , 0 , 18 , 3 , 6 , 12 , 6 , 9 , 12 , 0 , 3 , 12 , 36 , 0 , 30 , 0 , 12 , 0 , 18 , 6 , 12 , 9 , 12 , 6 , 24 , 3 , 18 , 12 , 15 , 9 , 24 , 0 , 18 , 6 , 18 , 9 , 18 , 12 , 6 , 6 , 24 , 3 , 24 , 0 , 12 , 12 , 12 , 0 , 6 , 0 , 27 , 12 , 18 , 3 , 30 , 3 , 18 , 6 , 0 , 12 , 15 , 6 , 18 , 0 , 24 , 0 , 9 , 6 , 9 , 12 , 18 , 7 , 24 , 0 , 24 , 12 , 15 , 12 , 24 , 0 , 24 , 0 , 6 , 9 , 30 , 9 , 6 , 6 , 0 , 9 , 33 , 12 , 36 , 0 , 12 , 0 , 18 , 0 , 6 , 21 , 12 , 6 , 36 , 6 , 0 , 3 , 18 , 6 , 12 , 6 , 24 , 0 , 12 , 3 , 24 , 6 , 9 , 12 , 6 , 6 , 30 , 6 , 18 , 12 , 9 , 9 , 12 , 0 , 30 , 3 , 18 , 3 , 27 , 6 , 30 , 12 , 12 , 0 , 24 , 0 , 27 , 12 , 6 , 0 , 24 , 3 , 18 , 18 , 9 , 6 , 18 , 0 , 12 , 3 , 33 , 18 , 12 , 9 , 6 , 0 , 12 , 6 , 30 , 0 , 24 , 12 , 12 , 0 , 30 , 6 , 6 , 6 , 0 , 6 , 24 , 0 , 12 , 0 , 18 , 15 , 33 , 6 , 30 , 15 , 18 , 0 , 9 , 12 , 24 , 9 , 12 , 0 , 18 , 6 , 27 , 18 , 15 , 6 , 18 , 3 , 24 , 0 , 6 , 6 , 36 , 12 , 18 , 0 , 12 , 3 , 30 , 3 , 12 , 6 , 12 , 15 , 6 , 0 , 18 , 12 , 15 , 9 , 30 , 0 , 18 , 6 , 12 , 12 , 18 , 6 , 6 , 3 , 24 , 1 , 27 , 12 , 18 , 6 , 18 , 0 , 24 , 0 , 18 , 15 , 15 , 21 , 30 , 6 , 12 , 12 , 18 , 0 , 30 , 6 , 24 , 0 , 6 , 0 , 18 , 6 , 36 , 12 , 6 , 6 , 36 , 0 , 6 , 12 , 12 , 12 , 24 , 0 , 30 , 0 , 9 , 6 , 18 , 0 , 18 , 12 , 12 , 6 , 24 , 6 , 9 , 15 , 12 , 0 , 12 , 6 , 30 , 9 , 18 , 0 , 42 , 3 , 18 , 6 , 12 , 18 , 33 , 12 , 12 , 0 , 18 , 0 , 21 , 12 , 12 , 12 , 24 , 6 , 30 , 0 , 27 , 18 , 6 , 12 , 6 , 0 , 24 , 0 , 18 , 15 , 30 , 0 , 18 , 12 , 6 , 0 , 21 , 6 , 21 , 12 , 24 , 0 , 30 , 0 , 6 , 6 , 6 , 12 , 24 , 0 , 30 , 12 , 9 , 12 , 21 , 3 , 24 , 0 , 12 , 3 , 21 , 18 , 9 , 18 , 18 , 6 , 30 , 3 , 42 , 6 , 21 , 6 , 30 , 0 , 6 , 3 , 24 , 9 , 36 , 6 , 6 , 9 , 12 , 6 , 18 , 12 , 33 , 9 , 12 , 0 , 24 , 9 , 9 , 6 , 3 , 18 , 36 , 6 , 18 , 0 , 24 , 6 , 6 , 6 , 18 , 0 , 12 , 0 , 30 , 3 , 39 , 12 , 12 , 7 , 18 , 0 , 15 , 18 , 18 , 9 , 36 , 0 , 24 , 6 , 6 , 18 , 30 , 0 , 18 , 9 , 18 , 3 , 24 , 6 , 21 , 12 , 24 , 0 , 30 , 3 , 33 , 24 , 12 , 6 , 18 , 6 , 6 , 6 , 18 , 6 , 18 , 12 , 18 , 0 , 24 , 6 , 36 , 3 , 18 , 6 , 0 , 12 , 30 , 0 , 9 , 24 , 18 , 0 , 24 , 0 , 18 , 0 , 0 , 12 , 30 , 15 , 30 , 6 , 18 , 3 , 30 , 0 , 24 , 18 , 12 , 0 , 36 , 3 , 24 , 12 , 15 , 18 , 18 , 6 , 24 , 3 , 24 , 12 , 18 , 12 , 24 , 0 , 0 , 6 , 39 , 6 , 24 , 3 , 18 , 3 , 42 , 6 , 12 , 12 , 15 , 9 , 30 , 0 , 12 , 0 , 18 , 6 , 18 , 12 , 24 , 15 , 12 , 0 , 12 , 12 , 30 , 12 , 12 , 0 , 18 , 0 , 15 , 15 , 18 , 18 , 30 , 3 , 24 , 12 , 9 , 6 , 48 , 0 , 18 , 0 , 30 , 0 , 21 , 6 , 12 , 12 , 24 , 12 , 18 , 3 , 48 , 24 , 6 , 6 , 18 , 0 , 36 , 0 , 12 , 15 , 27 , 6 , 12 , 12 , 18 , 6 , 27 , 6 , 12 , 9 , 18 , 0 , 24 , 6 , 18 , 18 , 21 , 0 , 36 , 0 , 12 , 0 , 18 , 12 , 21 , 18 , 24 , 0 , 12 , 1 , 18 , 9 , 21 , 18 , 6 , 9 , 42 , 3 , 36 , 12 , 12 , 12 , 30 , 0 , 12 , 6 , 21 , 12 , 36 , 6 , 24 , 9 , 12 , 6 , 12 , 12 , 24 , 12 , 18 , 0 , 42 , 0 , 15 , 6 , 15 , 15 , 42 , 6 , 30 , 6 , 12 , 12 , 18 , 12 , 18 , 0 , 6 , 6 , 36 , 0 , 30 , 18 , 6 , 0 , 6 , 0 , 30 , 18 , 18 , 0 , 42 , 0 , 18 , 6 , 15 , 18 , 24 , 0 , 12 , 6 , 36 , 9 , 33 , 12 , 12 , 12 , 18 , 0 , 36 , 0 , 21 , 21 , 15 , 18 , 18 , 15 , 18 , 0 , 18 , 6 , 42 , 6 , 24 , 0 , 18 , 3 , 42 , 6 , 18 , 12 , 12 , 12 , 18 , 0 , 15 , 12 , 18 , 12 , 36 , 0 , 30 , 12 , 3 , 21 , 18 , 0 , 30 , 6 , 24 , 0 , 27 , 12 , 18 , 12 , 6 , 0 , 12 , 0 , 36 , 15 , 15 , 3 , 36 , 12 , 18 , 6 , 30 , 6 , 33 , 12 , 12 , 0 , 12 , 6 , 24 , 6 , 54 , 18 , 12 , 3 , 36 , 9 , 9 , 12 , 12 , 18 , 36 , 0 , 6 , 0 , 21 , 15 , 27 , 9 , 24 , 12 , 30 , 6 , 24 , 6 , 27 , 18 , 12 , 0 , 30 , 0 , 21 , 12 , 18 , 6 , 30 , 0 , 18 , 0 , 21 , 18 , 21 , 6 , 30 , 0 , 24 , 3 , 6 , 6 , 15 , 27 , 12 , 10 , 42 , 6 , 36 , 12 , 12 , 6 , 24 , 0 , 24 , 6 , 12 , 12 , 48 , 6 , 18 , 12 , 0 , 3 , 51 , 6 , 30 , 6 , 24 , 0 , 24 , 0 , 30 , 21 , 15 , 12 , 24 , 9 , 18 , 6 , 18 , 12 , 30 , 9 , 24 , 0 , 18 , 0 , 27 , 18 , 9 , 6 , 18 , 9 , 54 , 0 , 18 , 24 , 21 , 18 , 12 , 0 , 24 , 0 , 12 , 0 , 30 , 9 , 30 , 12 , 6 , 9 , 24 , 6 , 15 , 15 , 18 , 0 , 30 , 3 , 33 , 18 , 21 , 12 , 42 , 3 , 30 , 6 , 6 , 24 , 27 , 6 , 12 , 0 , 24 , 3 , 42 , 6 , 42 , 9 , 12 , 6 , 18 , 6 , 24 , 12 , 12 , 12 , 54 , 0 , 6 , 12 , 18 , 6 , 18 , 18 , 30 , 12 , 30 , 0 , 18 , 0 , 27 , 18 , 24 , 0 , 18 , 0 , 15 , 24 , 21 , 6 , 24 , 3 , 36 , 6 , 6 , 6 , 45 , 21 , 18 , 0 , 18 , 6 , 33 , 3 , 18 , 0 , 24 , 15 , 30 , 0 , 30 , 24 , 12 , 6 , 36 , 0 , 24 , 3 , 21 , 24 , 18 , 15 , 30 , 3 , 12 , 6 , 42 , 12 , 12 , 12 , 6 , 0 , 54 , 6 , 30 , 15 , 24 , 18 , 24 , 6 , 12 , 0 , 9 , 6 , 30 , 0 , 48 , 0 , 24 , 0 , 15 , 12 , 39 , 12 , 24 , 6 , 24 , 6 , 15 , 30 , 12 , 6 , 24 , 0 , 24 , 3 , 24 , 12 , 24 , 6 , 6 , 18 , 12 , 4 , 54 , 6 , 21 , 18 , 18 , 0 , 36 , 6 , 24 , 9 , 30 , 12 , 24 , 9 , 36 , 6 , 12 , 18 , 42 , 3 , 30 , 0 , 6 , 9 , 21 , 6 , 12 , 30 , 30 , 6 , 30 , 0 , 27 , 12 , 9 , 18 , 30 , 0 , 36 , 0 , 18 , 9 , 42 , 6 , 24 , 12 , 0 , 6 , 51 , 12 , 24 , 12 , 12 , 0 , 18 , 6 , 12 , 18 , 6 , 6 , 36 , 3 , 54 , 9 , 18 , 6 , 27 , 12 , 18 , 0 , 30 , 0 , 39 , 9 , 18 , 18 , 12 , 9 , 30 , 6 , 21 , 12 , 27 , 18 , 24 , 0 , 12 , 0 , 42 , 18 , 42 , 6 , 24 , 15 , 18 , 0 , 24 , 12 , 45 , 12 , 6 , 0 , 54 , 0 , 15 , 21 , 6 , 6 , 30 , 6 , 18 , 12 , 24 , 18 , 30 , 6 , 36 , 0 , 12 , 3 , 24 , 12 , 18 , 18 , 18 , 12 , 24 , 0 , 33 , 12 , 27 , 6 , 42 , 0 , 18 , 6 , 9 , 15 , 30 , 6 , 30 , 6 , 12 , 6 , 18 , 6 , 33 , 15 , 30 , 0 , 36 , 3 , 27 , 21 , 33 , 24 , 30 , 9 , 24 , 0 , 12 , 18 , 33 , 6 , 6 , 0 , 18 , 3 , 57 , 12 , 24 , 18 , 30 , 9 , 18 , 0 , 18 , 12 , 27 , 12 , 36 , 0 , 36 , 6 , 12 , 6 , 27 , 12 , 30 , 9 , 24 , 6 , 39 , 18 , 12 , 24 , 12 , 0 , 30 , 0 , 30 , 6 , 15 , 15 , 18 , 3 , 24 , 18 , 9 , 12 , 30 , 9 , 30 , 0 , 18 , 6 , 42 , 18 , 30 , 0 , 6 , 10 , 48 , 0 , 24 , 12 , 12 , 18 , 48 , 0 , 30 , 3 , 30 , 15 , 18 , 6 , 24 , 18 , 18 , 0 , 42 , 6 , 36 , 15 , 24 , 0 , 42 , 12 , 21 , 24 , 12 , 12 , 24 , 0 , 12 , 6 , 18 , 18 , 60 , 6 , 30 , 0 , 12 , 0 , 24 , 0 , 12 , 18 , 30 , 15 , 42 , 0 , 33 , 30 , 6 , 6 , 12 , 0 , 42 , 3 , 27 , 6 , 33 , 12 , 36 , 12 , 18 , 0 , 30 , 6 , 18 , 12 , 12 , 0 , 18 , 6 , 15 , 27 , 27 , 6 , 42 , 6 , 36 , 9 , 18 , 30 , 33 , 9 , 30 , 0 , 6 , 6 , 54 , 6 , 36 , 24 , 24 , 0 , 30 , 3 , 12 , 6 , 21 , 24 , 30 , 0 , 24 , 0 , 24 , 12 , 42 , 9 , 42 , 21 , 12 , 12 , 27 , 12 , 27 , 6 , 12 , 0 , 48 , 6 , 12 , 18 , 12 , 12 , 36 , 6 , 30 , 0 , 24 , 0 , 42 , 12 , 12 , 0 , 36 , 0 , 24 , 15 , 21 , 21 , 18 , 6 , 12 , 9 , 36 , 18 , 18 , 15 , 42 , 0 , 18 , 6 , 9 , 18 , 48 , 12 , 30 , 9 , 24 , 3 , 33 , 6 , 18 , 18 , 18 , 0 , 36 , 3 , 54 , 24 , 3 , 12 , 36 , 9 , 36 , 6 , 30 , 12 , 36 , 12 , 24 , 0 , 18 , 6 , 24 , 6 , 42 , 0 , 24 , 18 , 18 , 0 , 9 , 30 , 39 , 12 , 42 , 0 , 36 , 0 , 12 , 12 , 21 , 12 , 18 , 12 , 24 , 6 , 45 , 6 , 18 , 24 , 18 , 0 , 36 , 0 , 42 , 15 , 18 , 6 , 24 , 6 , 12 , 12 , 18 , 12 , 30 , 6 , 18 , 0 , 30 , 1 , 30 , 9 , 57 , 9 , 12 , 9 , 48 , 6 , 21 , 24 , 18 , 12 , 66 , 0 , 18 , 6 , 9 , 24 , 24 , 24 , 30 , 12 , 18 , 0 , 48 , 6 , 24 , 18 , 18 , 0 , 24 , 3 , 27 , 18 , 24 , 12 , 36 , 6 , 48 , 6 , 15 , 18 , 42 , 6 , 24 , 0 , 12 , 12 , 36 , 6 , 6 , 24 , 12 , 3 , 48 , 0 , 48 , 18 , 0 , 12 , 18 , 0 , 36 , 6 , 18 , 9 , 54 , 15 , 12 , 12 , 6 , 6 , 39 , 6 , 24 , 18 , 42 , 0 , 30 , 0 , 33 , 18 , 24 , 18 , 18 , 9 , 18 , 0 , 15 , 18 , 54 , 0 , 36 , 0 , 24 , 0 , 48 , 24 , 15 , 18 , 18 , 12 , 42 , 9 , 24 , 12 , 36 , 21 , 30 , 0 , 36 , 12 , 24 , 3 , 30 , 0 , 48 , 15 , 12 , 6 , 15 , 18 , 18 , 18 , 24 , 0 , 30 , 0 , 24 , 24 , 18 , 9 , 72 , 0 , 30 , 6 , 21 , 18 , 30 , 6 , 24 , 0 , 0 , 6 , 24 , 18 , 42 , 12 , 6 , 15 , 36 , 0 , 30 , 18 , 30 , 12 , 24 , 0 , 6 , 0 , 18 , 12 , 54 , 9 , 36 , 9 , 36 , 9 , 30 , 6 , 27 , 27 , 24 , 0 , 54 , 6 , 21 , 18 , 21 , 6 , 36 , 15 , 36 , 3 , 30 , 12 , 6 , 18 , 30 , 0 , 18 , 6 , 54 , 0 , 30 , 21 , 36 , 9 , 30 , 6 , 30 , 24 , 24 , 6 , 30 , 0 , 36 , 12 , 9 , 24 , 24 , 12 , 18 , 9 , 30 , 0 , 48 , 12 , 24 , 12 , 12 , 0 , 48 , 0 , 18 , 12 , 24 , 24 , 30 , 6 , 18 , 12 , 21 , 12 , 24 , 0 , 66 , 0 , 12 , 0 , 30 , 9 , 24 , 24 , 18 , 13 , 42 , 3 , 18 , 18 , 27 , 24 , 24 , 0 , 30 , 6 , 15 , 18 , 39 , 12 , 12 , 9 , 36 , 12 , 54 , 12 , 42 , 18 , 6 , 0 , 36 , 0 , 51 , 18 , 12 , 0 , 66 , 12 , 24 , 0 , 6 , 24 , 51 , 12 , 24 , 0 , 24 , 0 , 33 , 6 , 18 , 18 , 30 , 6 , 42 , 3 , 18 , 30 , 15 , 15 , 30 , 0 , 30 , 6 , 30 , 12 , 48 , 12 , 24 , 12 , 12 , 9 , 36 , 6 , 36 , 6 , 12 , 0 , 30 , 0 , 24 , 21 , 24 , 15 , 42 , 12 , 24 , 6 , 9 , 18 , 15 , 9 , 42 , 0 , 24 , 12 , 66 , 12 , 30 , 24 , 6 , 9 , 54 , 0 , 36 , 12 , 21 , 12 , 36 , 0 , 24 , 3 , 24 , 15 , 36 , 6 , 30 , 24 , 12 , 6 , 33 , 6 , 39 , 21 , 30 , 0 , 42 , 6 , 12 , 30 , 30 , 18 , 36 , 0 , 48 , 3 , 36 , 12 , 30 , 18 , 18 , 0 , 24 , 0 , 30 , 6 , 33 , 21 , 24 , 6 , 18 , 12 , 24 , 12 , 12 , 15 , 48 , 0 , 24 , 6 , 21 , 21 , 60 , 6 , 24 , 12 , 18 , 0 , 30 , 12 , 15 , 12 , 24 , 0 , 24 , 3 , 60 , 27 , 18 , 12 , 30 , 3 , 24 , 9 , 21 , 12 , 60 , 18 , 24 , 0 , 24 , 9 , 33 , 6 , 36 , 12 , 24 , 15 , 42 , 6 , 27 , 36 , 27 , 6 , 42 , 0 , 42 , 6 , 12 , 15 , 15 , 24 , 42 , 18 , 12 , 0 , 33 , 6 , 21 , 18 , 24 , 0 , 48 , 3 , 36 , 9 , 24 , 24 , 30 , 6 , 36 , 0 , 39 , 18 , 60 , 6 , 18 , 0 , 12 , 6 , 21 , 27 , 30 , 0 , 18 , 6 , 42 , 6 , 42 , 18 , 24 , 9 , 48 , 0 , 6 , 6 , 18 , 18 , 18 , 6 , 18 , 15 , 30 , 4 , 60 , 12 , 30 , 30 , 18 , 0 , 36 , 0 , 27 , 18 , 30 , 18 , 48 , 9 , 30 , 12 , 18 , 6 , 42 , 9 , 48 , 0 , 18 , 6 , 42 , 6 , 30 , 24 , 12 , 3 , 36 , 0 , 36 , 36 , 15 , 18 , 30 , 0 , 66 , 0 , 12 , 18 , 42 , 9 , 24 , 15 , 18 , 12 , 54 , 6 , 18 , 21 , 36 , 0 , 30 , 6 , 24 , 24 , 12 , 6 , 24 , 9 , 36 , 12 , 6 , 12 , 45 , 12 , 36 , 0 , 36 , 0 , 48 , 3 , 24 , 18 , 12 , 24 , 36 , 0 , 30 , 12 , 30 , 21 , 30 , 0 , 6 , 15 , 18 , 15 , 66 , 12 , 42 , 3 , 12 , 0 , 39 , 12 , 30 , 12 , 18 , 0 , 54 , 6 , 30 , 24 , 9 , 12 , 60 , 12 , 30 , 12 , 30 , 24 , 24 , 18 , 30 , 0 , 36 , 0 , 27 , 9 , 45 , 18 , 24 , 12 , 24 , 0 , 36 , 24 , 12 , 6 , 60 , 0 , 18 , 0 , 24 , 15 , 51 , 9 , 24 , 12 , 30 , 12 , 27 , 18 , 51 , 18 , 24 , 0 , 36 , 6 , 27 , 27 , 12 , 30 , 36 , 6 , 30 , 0 , 12 , 6 , 42 , 0 , 18 , 0 , 18 , 0 , 48 , 12 , 45 , 24 , 6 , 15 , 42 , 6 , 12 , 18 , 27 , 9 , 54 , 0 , 42 , 3 , 33 , 12 , 15 , 12 , 54 , 18 , 30 , 6 , 36 , 18 , 21 , 30 , 18 , 0 , 48 , 3 , 30 , 18 , 36 , 6 , 18 , 0 , 18 , 12 , 57 , 24 , 42 , 6 , 24 , 0 , 18 , 12 , 36 , 18 , 30 , 12 , 36 , 3 , 78 , 0 , 24 , 6 , 6 , 36 , 42 , 0 , 24 , 0 , 21 , 15 , 33 , 6 , 42 , 18 , 12 , 3 , 30 , 12 , 30 , 27 , 24 , 0 , 42 , 12 , 39 , 12 , 30 , 12 , 30 , 15 , 30 , 6 , 12 , 24 , 54 , 6 , 24 , 0 , 18 , 6 , 33 , 12 , 18 , 24 , 24 , 7 , 30 , 0 , 60 , 24 , 21 , 12 , 30 , 0 , 48 , 6 , 18 , 15 , 39 , 12 , 18 , 18 , 18 , 0 , 48 , 12 , 54 , 18 , 42 , 0 , 30 , 0 , 15 , 30 , 27 , 18 , 72 , 0 , 30 , 15 , 12 , 12 , 30 , 18 , 36 , 0 , 6 , 3 , 60 , 15 , 24 , 18 , 6 , 18 , 54 , 6 , 21 , 24 , 24 , 12 , 30 , 0 , 30 , 6 , 30 , 15 , 54 , 6 , 48 , 12 , 30 , 12 , 36 , 0 , 24 , 3 , 24 , 0 , 54 , 6 , 18 , 30 , 15 , 6 , 42 , 9 , 36 , 0 , 21 , 30 , 15 , 12 , 12 , 0 , 24 , 3 , 72 , 0 , 51 , 39 , 24 , 12 , 30 , 3 , 33 , 18 , 15 , 12 , 42 , 0 , 30 , 12 , 27 , 24 , 51 , 12 , 42 , 12 , 18 , 3 , 42 , 12 , 39 , 18 , 12 , 0 , 30 , 0 , 24 , 21 , 21 , 21 , 30 , 6 , 66 , 12 , 12 , 6 , 69 , 21 , 30 , 0 , 24 , 6 , 45 , 12 , 12 , 18 , 42 , 12 , 18 , 0 , 39 , 30 , 33 , 12 , 54 , 0 , 12 , 0 , 12 , 18 , 36 , 9 , 30 , 9 , 24 , 9 , 60 , 12 , 30 , 12 , 12 , 0 , 42 , 9 , 42 , 18 , 45 , 24 , 42 , 6 , 12 , 9 , 24 , 6 , 30 , 12 , 42 , 0 , 30 , 6 , 15 , 15 , 30 , 12 , 18 , 12 , 54 , 6 , 21 , 30 , 12 , 33 , 60 , 0 , 48 , 0 , 30 , 15 , 42 , 6 , 24 , 24 , 30 , 0 , 36 , 18 , 33 , 18 , 12 , 0 , 60 , 0 , 72 , 15 , 12 , 9 , 30 , 12 , 24 , 15 , 21 , 24 , 51 , 12 , 24 , 0 , 24 , 6 , 12 , 6 , 33 , 24 , 36 , 9 , 54 , 6 , 27 , 24 , 30 , 6 , 48 , 0 , 24 , 3 , 36 , 27 , 42 , 15 , 18 , 18 , 12 , 6 , 54 , 6 , 30 , 15 , 36 , 0 , 12 , 12 , 18 , 24 , 21 , 18 , 30 , 3 , 60 , 0 , 33 , 12 , 36 , 18 , 48 , 0 , 24 , 1 , 39 , 12 , 24 , 18 , 24 , 9 , 66 , 6 , 48 , 24 , 12 , 12 , 42 , 0 , 24 , 6 , 18 , 12 , 63 , 6 , 36 , 24 , 18 , 0 , 39 , 12 , 39 , 24 , 24 , 0 , 54 , 6 , 15 , 24 , 15 , 24 , 48 , 3 , 36 , 12 , 12 , 24 , 39 , 18 , 36 , 0 , 42 , 6 , 42 , 6 , 60 , 24 , 12 , 18 , 18 , 0 , 45 , 6 , 6 , 6 , 72 , 0 , 30 , 6 , 24 , 9 , 36 , 12 , 24 , 9 , 30 , 15 , 36 , 18 , 33 , 24 , 6 , 0 , 54 , 0 , 33 , 36 , 18 , 24 , 36 , 6 , 18 , 6 , 24 , 18 , 75 , 6 , 18 , 0 , 18 , 0 , 48 , 9 , 36 , 18 , 42 , 9 , 30 , 0 , 27 , 36 , 24 , 15 , 42 , 0 , 42 , 18 , 36 , 12 , 18 , 12 , 72 , 9 , 24 , 0 , 54 , 18 , 21 , 24 , 12 , 0 , 60 , 0 , 24 , 24 , 39 , 12 , 42 , 18 , 30 , 6 , 9 , 12 , 48 , 12 , 30 , 0 , 18 , 12 , 36 , 15 , 48 , 18 , 18 , 3 , 42 , 6 , 42 , 18 , 18 , 24 , 54 , 0 , 36 , 0 , 24 , 36 , 42 , 0 , 12 , 27 , 30 , 6 , 60 , 6 , 30 , 24 , 12 , 0 , 36 , 3 , 42 , 12 , 18 , 12 , 36 , 9 , 30 , 0 , 15 , 18 , 33 , 12 , 54 , 0 , 30 , 6 , 33 , 21 , 27 , 30 , 42 , 12 , 54 , 9 , 42 , 24 , 27 , 6 , 36 , 0 , 24 , 12 , 24 , 12 , 45 , 24 , 12 , 6 , 30 , 12 , 69 , 12 , 42 , 12 , 30 , 0 , 24 , 0 , 42 , 18 , 24 , 15 , 60 , 9 , 48 , 18 , 18 , 24 , 27 , 12 , 36 , 0 , 30 , 0 , 54 , 9 , 30 , 18 , 24 , 15 , 48 , 0 , 24 , 24 , 45 , 24 , 24 , 0 , 18 , 6 , 36 , 9 , 54 , 15 , 24 , 12 , 12 , 6 , 18 , 12 , 54 , 18 , 12 , 0 , 60 , 3 , 48 , 30 , 12 , 18 , 60 , 6 , 24 , 3 , 36 , 12 , 33 , 12 , 36 , 0 , 36 , 6 , 36 , 3 , 33 , 24 , 12 , 13 , 42 , 12 , 27 , 18 , 30 , 12 , 54 , 0 , 30 , 12 , 21 , 39 , 54 , 6 , 54 , 18 , 18 , 0 , 33 , 12 , 36 , 36 , 36 , 0 , 30 , 0 , 42 , 33 , 18 , 18 , 36 , 12 , 30 , 3 , 30 , 12 , 66 , 6 , 30 , 0 , 18 , 12 , 63 , 18 , 24 , 6 , 30 , 12 , 48 , 9 , 6 , 24 , 30 , 12 , 42 , 0 , 72 , 0 , 30 , 12 , 48 , 3 , 24 , 15 , 12 , 12 , 66 , 18 , 9 , 36 , 12 , 0 , 54 , 0 , 54 , 18 , 15 , 30 , 36 , 6 , 12 , 0 , 21 , 18 , 54 , 12 , 30 , 0 , 6 , 0 , 36 , 15 , 60 , 18 , 18 , 15 , 48 , 6 , 27 , 24 , 21 , 12 , 54 , 0 , 54 , 9 , 12 , 24 , 48 , 12 , 48 , 15 , 54 , 6 , 36 , 6 , 39 , 24 , 24 , 0 , 24 , 3 , 33 , 24 , 18 , 18 , 66 , 12 , 18 , 12 , 30 , 12 , 75 , 15 , 36 , 0 , 30 , 9 , 24 , 6 , 21 , 24 , 24 , 12 , 60 , 0 , 66 , 36 , 12 , 18 , 36 , 0 , 24 , 6 , 30 , 18 , 39 , 18 , 30 , 12 , 24 , 9 , 30 , 6 , 36 , 18 , 18 , 0 , 54 , 12 , 33 , 24 , 36 , 6 , 66 , 0 , 30 , 6 , 12 , 12 , 33 , 24 , 54 , 0 , 18 , 3 , 60 , 3 , 30 , 24 , 24 , 21 , 48 , 0 , 18 , 30 , 51 , 12 , 18 , 0 , 30 , 12 , 33 , 15 , 18 , 12 , 30 , 27 , 24 , 0 , 48 , 12 , 45 , 6 , 30 , 0 , 72 , 0 , 51 , 18 , 27 , 27 , 54 , 9 , 48 , 12 , 27 , 30 , 36 , 18 , 18 , 0 , 42 , 3 , 36 , 9 , 45 , 30 , 6 , 6 , 36 , 3 , 51 , 24 , 24 , 18 , 72 , 0 , 18 , 6 , 9 , 36 , 42 , 0 , 36 , 9 , 30 , 12 , 60 , 30 , 24 , 15 , 24 , 0 , 36 , 6 , 30 , 27 , 27 , 18 , 42 , 12 , 48 , 0 , 42 , 0 , 33 , 24 , 24 , 0 , 30 , 0 , 42 , 12 , 48 , 9 , 36 , 9 , 24 , 6 , 27 , 36 , 12 , 9 , 60 , 0 , 30 , 12 , 15 , 18 , 42 , 18 , 36 , 18 , 24 , 7 , 48 , 12 , 54 , 24 , 30 , 0 , 78 , 0 , 18 , 18 , 27 , 24 , 24 , 6 , 30 , 12 , 33 , 18 , 60 , 15 , 54 , 0 , 12 , 12 , 36 , 12 , 36 , 24 , 30 , 18 , 54 , 0 , 18 , 18 , 18 , 24 , 84 , 0 , 54 , 0 , 27 , 15 , 42 , 6 , 36 , 12 , 18 , 9 , 54 , 6 , 30 , 30 , 24 , 0 , 30 , 9 , 60 , 30 , 36 , 6 , 42 , 12 , 30 , 6 , 6 , 30 , 60 , 0 , 18 , 0 , 24 , 9 , 51 , 18 , 24 , 33 , 30 , 0 , 42 , 12 , 60 , 18 , 18 , 36 , 18 , 0 , 24 , 0 , 18 , 9 , 78 , 12 , 48 , 24 , 12 , 0 , 48 , 6 , 12 , 18 , 42 , 0 , 48 , 0 , 30 , 27 , 18 , 6 , 48 , 3 , 66 , 21 , 18 , 18 , 33 , 12 , 48 , 0 , 30 , 6 , 63 , 21 , 18 , 36 , 24 , 15 , 60 , 6 , 36 , 30 , 36 , 0 , 48 , 0 , 48 , 3 , 36 , 30 , 42 , 18 , 24 , 24 , 12 , 6 , 21 , 6 , 72 , 12 , 36 , 0 , 60 , 6 , 12 , 18 , 15 , 24 , 60 , 9 , 30 , 0 , 39 , 30 , 54 , 12 , 18 , 0 , 18 , 3 , 60 , 9 , 57 , 24 , 6 , 18 , 48 , 6 , 60 , 18 , 18 , 9 , 48 , 0 , 24 , 12 , 18 , 18 , 39 , 6 , 42 , 15 , 36 , 6 , 36 , 18 , 18 , 30 , 18 , 0 , 42 , 6 , 39 , 27 , 27 , 18 , 48 , 12 , 42 , 12 , 24 , 18 , 27 , 9 , 30 , 0 , 24 , 9 , 81 , 12 , 72 , 12 , 30 , 6 , 36 , 0 , 33 , 42 , 39 , 30 , 42 , 0 , 12 , 3 , 12 , 6 , 24 , 18 , 48 , 12 , 48 , 3 , 63 , 24 , 24 , 27 , 30 , 0 , 78 , 6 , 36 , 18 , 36 , 30 , 30 , 12 , 36 , 12 , 30 , 6 , 60 , 12 , 48 , 0 , 24 , 0 , 36 , 21 , 30 , 24 , 30 , 12 , 48 , 0 , 36 , 12 , 24 , 27 , 36 , 0 , 42 , 12 , 27 , 24 , 54 , 6 , 18 , 12 , 48 , 0 , 30 , 6 , 72 , 24 , 12 , 0 , 30 , 3 , 45 , 24 , 0 , 18 , 78 , 15 , 18 , 18 , 39 , 18 , 39 , 9 , 36 , 0 , 24 , 6 , 39 , 12 , 30 , 18 , 30 , 16 , 48 , 0 , 36 , 30 , 12 , 12 , 60 , 0 , 42 , 3 , 24 , 21 , 84 , 33 , 30 , 12 , 18 , 18 , 48 , 12 , 36 , 12 , 30 , 0 , 48 , 9 , 42 , 36 , 42 , 6 , 48 , 3 , 42 , 0 , 33 , 24 , 30 , 12 , 36 , 0 , 36 , 6 , 54 , 12 , 30 , 30 , 6 , 21 , 66 , 0 , 39 , 24 , 36 , 24 , 36 , 0 , 24 , 12 , 30 , 15 , 54 , 12 , 78 , 30 , 6 , 0 , 33 , 12 , 27 , 30 , 30 , 0 , 36 , 6 , 18 , 36 , 36 , 6 , 66 , 3 , 60 , 6 , 18 , 30 , 42 , 0 , 12 , 0 , 36 , 6 , 54 , 6 , 33 , 24 , 24 , 12 , 54 , 0 , 42 , 12 , 15 , 12 , 60 , 0 , 30 , 0 , 21 , 18 , 75 , 18 , 48 , 18 , 18 , 15 , 30 , 24 , 42 , 33 , 36 , 0 , 30 , 6 , 45 , 24 , 9 , 30 , 36 , 3 , 54 , 15 , 24 , 18 , 63 , 18 , 42 , 0 , 24 , 0 , 75 , 6 , 30 , 9 , 30 , 15 , 42 , 12 , 33 , 36 , 21 , 24 , 60 , 0 , 54 , 9 , 30 , 30 , 48 , 12 , 18 , 12 , 24 , 0 , 66 , 12 , 24 , 18 , 36 , 0 , 72 , 6 , 36 , 15 , 27 , 27 , 30 , 6 , 12 , 18 , 24 , 6 , 78 , 15 , 42 , 0 , 12 , 6 , 27 , 24 , 51 , 18 , 36 , 12 , 60 , 3 , 51 , 30 , 12 , 24 , 36 , 0 , 30 , 0 , 48 , 12 , 21 , 6 , 36 , 24 , 54 , 6 , 42 , 6 , 36 , 36 , 6 , 0 , 54 , 12 , 27 , 15 , 18 , 18 , 66 , 6 , 42 , 0 , 15 , 30 , 63 , 12 , 48 , 0 , 36 , 3 , 63 , 12 , 36 , 30 , 18 , 9 , 48 , 3 , 48 , 36 , 30 , 12 , 42 , 0 , 72 , 6 , 36 , 30 , 30 , 12 , 24 , 12 , 6 , 15 , 75 , 18 , 30 , 6 , 36 , 0 , 24 , 0 , 18 , 36 , 48 , 18 , 60 , 18 , 60 , 12 , 33 , 12 , 33 , 15 , 72 , 0 , 18 , 9 , 54 , 15 , 21 , 30 , 36 , 12 , 30 , 0 , 42 , 24 , 48 , 18 , 36 , 0 , 24 , 6 , 18 , 15 , 81 , 12 , 12 , 27 , 36 , 12 , 30 , 6 , 36 , 18 , 24 , 0 , 48 , 6 , 36 , 36 , 27 , 6 , 48 , 9 , 36 , 3 , 36 , 36 , 36 , 24 , 30 , 0 , 24 , 1 , 42 , 6 , 66 , 27 , 24 , 18 , 48 , 12 , 51 , 18 , 24 , 18 , 84 , 0 , 24 , 6 , 12 , 9 , 63 , 18 , 48 , 9 , 30 , 0 , 36 , 12 , 33 , 24 , 30 , 0 , 72 , 0 , 42 , 48 , 36 , 18 , 42 , 12 , 42 , 15 , 24 , 12 , 60 , 15 , 24 , 0 , 12 , 21 , 72 , 3 , 42 , 30 , 24 , 18 , 36 , 6 , 42 , 18 , 30 , 12 , 42 , 0 , 48 , 12 , 12 , 24 , 24 , 18 , 66 , 6 , 24 , 0 , 93 , 12 , 51 , 30 , 12 , 0 , 54 , 6 , 18 , 27 , 24 , 24 , 36 , 12 , 30 , 0 , 45 , 18 , 60 , 6 , 54 , 0 , 24 , 0 , 51 , 24 , 21 , 18 , 30 , 6 , 72 , 6 , 6 , 18 , 21 , 36 , 42 , 0 , 48 , 12 , 27 , 24 , 36 , 6 , 30 , 27 , 30 , 6 , 39 , 18 , 51 , 36 , 30 , 0 , 42 , 0 , 66 , 18 , 36 , 6 , 66 , 9 , 24 , 12 , 24 , 24 , 78 , 12 , 36 , 0 , 36 , 12 , 60 , 15 , 42 , 24 , 6 , 15 , 54 , 0 , 33 , 30 , 21 , 30 , 42 , 0 , 54 , 0 , 24 , 9 , 60 , 9 , 36 , 24 , 24 , 6 , 66 , 12 , 48 , 18 , 54 , 0 , 30 , 0 , 30 , 39 , 30 , 18 , 48 , 6 , 42 , 12 , 33 , 24 , 33 , 12 , 60 , 0 , 18 , 6 , 42 , 24 , 42 , 24 , 6 , 12 , 72 , 6 , 42 , 30 , 18 , 9 , 30 , 0 , 24 , 15 , 30 , 18 , 60 , 12 , 54 , 15 , 24 , 0 , 48 , 24 , 33 , 12 , 36 , 0 , 66 , 6 , 36 , 18 , 21 , 30 , 72 , 3 , 24 , 9 , 27 , 30 , 30 , 18 , 42 , 0 , 42 , 0 , 72 , 6 , 39 , 42 , 24 , 18 , 60 , 3 , 24 , 18 , 36 , 18 , 30 , 0 , 54 , 6 , 27 , 33 , 60 , 12 , 24 , 24 , 18 , 18 , 30 , 12 , 21 , 33 , 48 , 0 , 78 , 12 , 78 , 12 , 30 , 12 , 42 , 12 , 48 , 0 , 24 , 12 , 75 , 18 , 24 , 0 , 18 , 0 , 33 , 24 , 30 , 21 , 42 , 15 , 30 , 12 , 39 , 30 , 51 , 12 , 54 , 0 , 36 , 12 , 18 , 12 , 48 , 24 , 78 , 18 , 18 , 6 , 78 , 6 , 24 , 30 , 12 , 0 , 42 , 0 , 45 , 18 , 15 , 27 , 42 , 0 , 54 , 18 , 36 , 18 , 36 , 6 , 48 , 0 , 30 , 12 , 36 , 21 , 45 , 6 , 24 , 7 , 54 , 0 , 27 , 42 , 33 , 24 , 72 , 0 , 42 , 0 , 48 , 24 , 45 , 18 , 18 , 15 , 36 , 15 , 66 , 6 , 66 , 30 , 18 , 0 , 48 , 0 , 27 , 39 , 30 , 18 , 66 , 27 , 12 , 12 , 18 , 24 , 60 , 6 , 66 , 0 , 42 , 0 , 42 , 6 , 33 , 21 , 36 , 12 , 42 , 6 , 21 , 36 , 33 , 21 , 48 , 0 , 66 , 12 , 6 , 18 , 75 , 24 , 36 , 12 , 18 , 0 , 81 , 12 , 42 , 30 , 36 , 0 , 24 , 0 , 30 , 30 , 30 , 6 , 60 , 9 , 60 , 6 , 24 , 30 , 30 , 6 , 30 , 0 , 30 , 12 , 75 , 18 , 30 , 24 , 24 , 15 , 78 , 0 , 42 , 24 , 18 , 30 , 42 , 0 , 30 , 12 , 21 , 12 , 48 , 9 , 60 , 21 , 30 , 12 , 24 , 24 , 39 , 21 , 24 , 0 , 54 , 3 , 39 , 30 , 33 , 24 , 72 , 12 , 60 , 0 , 18 , 24 , 57 , 12 , 24 , 0 , 24 , 3 , 90 , 9 , 12 , 21 , 36 , 12 , 30 , 18 , 84 , 24 , 30 , 9 , 60 , 0 , 36 , 18 , 18 , 24 , 78 , 18 , 24 , 18 , 48 , 6 , 24 , 0 , 45 , 30 , 24 , 0 , 66 , 3 , 60 , 36 , 21 , 42 , 42 , 6 , 30 , 6 , 33 , 12 , 60 , 21 , 36 , 0 , 6 , 6 , 36 , 15 , 36 , 30 , 48 , 21 , 48 , 0 , 39 , 36 , 36 , 6 , 54 , 0 , 66 , 3 , 18 , 18 , 33 , 24 , 36 , 18 , 30 , 9 , 66 , 6 , 15 , 36 , 24 , 0 , 96 , 6 , 30 , 12 , 42 , 6 , 36 , 6 , 36 , 9 , 27 , 36 , 42 , 12 , 42 , 0 , 18 , 6 , 51 , 12 , 78 , 18 , 30 , 9 , 54 , 12 , 39 , 24 , 24 , 33 , 66 , 0 , 36 , 9 , 45 , 33 , 36 , 12 , 18 , 27 , 36 , 0 , 78 , 12 , 48 , 24 , 30 , 0 , 42 , 9 , 48 , 21 , 18 , 9 , 60 , 12 , 54 , 6 , 21 , 24 , 72 , 3 , 66 , 0 , 18 , 18 , 33 , 12 , 21 , 36 , 36 , 6 , 36 , 6 , 60 , 36 , 36 , 18 , 48 , 0 , 24 , 0 , 30 , 24 , 87 , 24 , 24 , 27 , 42 , 6 , 60 , 18 , 66 , 6 , 18 , 0 , 36 , 6 , 39 , 36 , 30 , 18 , 36 , 9 , 30 , 0 , 18 , 18 , 51 , 12 , 48 , 0 , 54 , 0 , 48 , 18 , 36 , 30 , 36 , 30 , 66 , 3 , 12 , 18 , 15 , 39 , 60 , 0 , 24 , 12 , 66 , 6 , 54 , 12 , 48 , 6 , 18 , 7 , 30 , 24 , 48 , 18 , 30 , 0 , 84 , 0 , 30 , 48 , 12 , 15 , 60 , 9 , 42 , 18 , 42 , 18 , 42 , 18 , 48 , 0 , 30 , 9 , 48 , 21 , 69 , 36 , 12 , 12 , 48 , 0 , 57 , 18 , 24 , 24 , 66 , 0 , 36 , 6 , 24 , 21 , 69 , 6 , 54 , 12 , 30 , 18 , 72 , 18 , 30 , 30 , 18 , 0 , 42 , 0 , 42 , 42 , 12 , 18 , 42 , 6 , 54 , 9 , 42 , 12 , 72 , 18 , 24 , 0 , 24 , 3 , 78 , 0 , 24 , 24 , 30 , 15 , 60 , 6 , 42 , 30 , 39 , 21 , 36 , 0 , 54 , 12 , 27 , 24 , 42 , 24 , 72 , 21 , 30 , 0 , 48 , 18 , 24 , 30 , 12 , 0 , 30 , 3 , 24 , 15 , 72 , 33 , 42 , 6 , 24 , 24 , 12 , 24 , 66 , 12 , 60 , 0 , 24 , 6 , 63 , 12 , 42 , 18 , 24 , 18 , 84 , 6 , 30 , 24 , 24 , 6 , 90 , 0 , 72 , 6 , 21 , 24 , 30 , 18 , 18 , 30 , 24 , 6 , 66 , 18 , 54 , 18 , 36 , 0 , 36 , 12 , 60 , 27 , 30 , 18 , 90 , 18 , 18 , 0 , 18 , 24 , 48 , 24 , 30 , 0 , 36 , 6 , 36 , 18 , 66 , 36 , 30 , 3 , 66 , 3 , 57 , 48 , 12 , 18 , 36 , 0 , 48 , 6 , 36 , 21 , 48 , 0 , 60 , 12 , 36 , 12 , 72 , 0 , 36 , 30 , 30 , 0 , 48 , 0 , 33 , 30 , 48 , 9 , 54 , 9 , 36 , 24 , 18 , 30 , 42 , 18 , 54 , 0 , 12 , 0 , 54 , 12 , 21 , 24 , 30 , 21 , 72 , 0 , 66 , 24 , 27 , 18 , 36 , 0 , 24 , 0 , 45 , 24 , 78 , 0 , 42 , 21 , 24 , 12 , 39 , 30 , 54 , 30 , 24 , 0 , 84 , 15 , 24 , 24 , 9 , 30 , 54 , 9 , 48 , 6 , 33 , 18 , 57 , 18 , 30 , 0 , 60 , 3 , 54 , 27 , 33 , 30 , 36 , 24 , 42 , 0 , 54 , 18 , 39 , 24 , 54 , 0 , 60 , 18 , 24 , 15 , 75 , 12 , 24 , 12 , 42 , 0 , 39 , 12 , 36 , 36 , 36 , 0 , 30 , 3 , 66 , 42 , 15 , 24 , 72 , 12 , 48 , 12 , 42 , 12 , 48 , 15 , 24 , 0 , 18 , 18 , 60 , 6 , 60 , 18 , 36 , 9 , 24 , 6 , 27 , 36 , 30 , 24 , 90 , 0 , 60 , 3 , 21 , 18 , 54 , 24 , 48 , 18 , 18 , 12 , 51 , 24 , 39 , 18 , 18 , 0 , 72 , 12 , 42 , 21 , 36 , 24 , 36 , 6 , 36 , 0 , 33 , 18 , 42 , 0 , 60 , 0 , 18 , 6 , 42 , 21 , 39 , 39 , 36 , 13 , 84 , 6 , 24 , 18 , 30 , 24 , 78 , 0 , 36 , 3 , 54 , 39 , 51 , 18 , 30 , 21 , 24 , 3 , 60 , 12 , 87 , 42 , 30 , 0 , 36 , 6 , 30 , 15 , 36 , 12 , 54 , 18 , 42 , 12 , 27 , 24 , 84 , 15 , 42 , 0 , 18 , 9 , 54 , 18 , 30 , 30 , 48 , 12 , 72 , 0 , 54 , 42 , 9 , 12 , 36 , 0 , 60 , 0 , 27 , 21 , 78 , 18 , 42 , 30 , 30 , 6 , 54 , 6 , 30 , 18 , 24 , 0 , 60 , 12 , 42 , 36 , 48 , 24 , 54 , 6 , 36 , 15 , 12 , 48 , 21 , 12 , 30 , 0 , 36 , 0 , 102 , 6 , 18 , 12 , 24 , 9 , 60 , 12 , 48 , 24 , 33 , 30 , 66 , 0 , 30 , 12 , 30 , 15 , 60 , 12 , 54 , 36 , 30 , 0 , 36 , 6 , 72 , 18 , 36 , 0 , 54 , 0 , 30 , 36 , 9 , 15 , 60 , 0 , 60 , 15 , 39 , 12 , 63 , 18 , 42 , 0 , 30 , 18 , 60 , 21 , 57 , 30 , 0 , 18 , 54 , 3 , 75 , 30 , 48 , 24 , 42 , 0 , 24 , 12 , 36 , 42 , 57 , 9 , 48 , 9 , 36 , 6 , 45 , 12 , 24 , 48 , 54 , 0 , 66 , 0 , 45 , 33 , 30 , 18 , 54 , 18 , 36 , 0 , 36 , 6 , 54 , 30 , 54 , 0 , 36 , 0 , 66 , 12 , 42 , 21 , 24 , 18 , 48 , 6 , 21 , 48 , 42 , 12 , 60 , 0 , 84 , 12 , 0 , 12 , 54 , 24 , 36 , 18 , 18 , 12 , 81 , 18 , 33 , 18 , 12 , 0 , 66 , 3 , 66 , 6 , 33 , 48 , 48 , 6 , 24 , 24 , 36 , 18 , 60 , 6 , 36 , 0 , 24 , 6 , 39 , 21 , 42 , 18 , 42 , 12 , 60 , 0 , 24 , 30 , 33 , 36 , 72 , 0 , 30 , 0 , 36 , 36 , 42 , 12 , 36 , 15 , 24 , 15 , 75 , 30 , 63 , 27 , 24 , 0 , 42 , 6 , 63 , 30 , 18 , 12 , 108 , 9 , 48 , 12 , 24 , 12 , 72 , 18 , 30 , 0 , 54 , 6 , 30 , 9 , 63 , 27 , 48 , 15 , 36 , 6 , 48 , 36 , 18 , 12 , 54 , 0 , 42 , 9 , 36 , 36 , 63 , 18 , 36 , 24 , 36 , 0 , 75 , 6 , 63 , 24 , 36 , 0 , 48 , 6 , 27 , 39 , 30 , 18 , 30 , 9 , 54 , 18 , 36 , 18 , 39 , 21 , 66 , 0 , 30 , 0 , 54 , 18 , 42 , 36 , 12 , 24 , 108 , 0 , 30 , 24 , 42 , 12 , 48 , 0 , 24 , 0 , 15 , 9 , 48 , 18 , 66 , 24 , 24 , 12 , 54 , 12 , 36 , 21 , 54 , 0 , 54 , 18 , 45 , 42 , 36 , 24 , 42 , 3 , 36 , 0 , 42 , 48 , 42 , 12 , 36 , 0 , 36 , 1 , 60 , 18 , 36 , 18 , 36 , 15 , 54 , 9 , 60 , 30 , 24 , 21 , 48 , 0 , 24 , 18 , 24 , 18 , 90 , 6 , 72 , 15 , 36 , 9 , 48 , 6 , 36 , 42 , 48 , 0 , 78 , 3 , 54 , 27 , 18 , 36 , 48 , 15 , 54 , 12 , 30 , 24 , 84 , 12 , 18 , 0 , 18 , 12 , 105 , 12 , 24 , 30 , 30 , 18 , 36 , 0 , 60 , 30 , 27 , 12 , 48 , 0 , 90 , 6 , 18 , 18 , 33 , 21 , 42 , 24 , 24 , 12 , 45 , 24 , 60 , 36 , 36 , 0 , 66 , 6 , 27 , 15 , 42 , 24 , 60 , 12 , 18 , 9 , 30 , 18 , 84 , 12 , 72 , 0 , 12 , 6 , 42 , 21 , 45 , 12 , 18 , 9 , 96 , 12 , 21 , 30 , 30 , 24 , 66 , 0 , 48 , 12 , 42 , 18 , 36 , 18 , 24 , 24 , 24 , 0 , 30 , 12 , 27 , 42 , 18 , 0 , 72 , 0 , 84 , 27 , 54 , 15 , 102 , 12 , 36 , 6 , 39 , 36 , 36 , 15 , 36 , 0 , 30 , 15 , 57 , 12 , 57 , 42 , 30 , 9 , 60 , 6 , 27 , 42 , 27 , 30 , 36 , 0 , 54 , 6 , 24 , 21 , 78 , 12 , 42 , 18 , 18 , 12 , 84 , 18 , 54 , 18 , 48 , 0 , 66 , 12 , 15 , 36 , 30 , 18 , 72 , 9 , 66 , 0 , 27 , 18 , 24 , 6 , 78 , 0 , 42 , 6 , 81 , 27 , 27 , 36 , 24 , 24 , 48 , 0 , 72 , 18 , 39 , 30 , 42 , 0 , 18 , 18 , 30 , 24 , 78 , 6 , 18 , 18 , 36 , 0 , 48 , 30 , 84 , 6 , 18 , 0 , 54 , 0 , 42 , 36 , 12 , 30 , 90 , 12 , 48 , 18 , 24 , 18 , 21 , 18 , 48 , 0 , 60 , 0 , 60 , 6 , 30 , 42 , 24 , 18 , 66 , 0 , 27 , 36 , 24 , 18 , 54 , 0 , 48 , 6 , 30 , 18 , 90 , 15 , 42 , 9 , 48 , 18 , 42 , 6 , 45 , 24 , 36 , 0 , 48 , 0 , 78 , 39 , 27 , 12 , 42 , 27 , 48 , 6 , 45 , 18 , 72 , 36 , 48 , 0 , 18 , 9 , 66 , 9 , 54 , 33 , 18 , 18 , 66 , 12 , 39 , 36 , 45 , 12 , 72 , 0 , 48 , 12 , 21 , 39 , 33 , 18 , 60 , 18 , 36 , 0 , 78 , 18 , 39 , 36 , 24 , 0 , 30 , 0 , 30 , 30 , 54 , 21 , 66 , 6 , 30 , 21 , 39 , 18 , 60 , 15 , 72 , 0 , 30 , 18 , 45 , 12 , 39 , 18 , 60 , 6 , 66 , 15 , 36 , 30 , 12 , 18 , 60 , 0 , 60 , 0 , 18 , 33 , 57 , 18 , 24 , 24 , 42 , 6 , 66 , 12 , 81 , 42 , 18 , 0 , 36 , 6 , 42 , 18 , 24 , 24 , 72 , 0 , 18 , 0 , 30 , 30 , 87 , 18 , 36 , 0 , 42 , 3 , 45 , 12 , 36 , 42 , 24 , 25 , 30 , 6 , 72 , 24 , 18 , 18 , 60 , 0 , 102 , 12 , 42 , 12 , 90 , 12 , 24 , 27 , 24 , 12 , 69 , 24 , 30 , 18 , 42 , 0 , 48 , 0 , 42 , 45 , 39 , 15 , 60 , 18 , 30 , 12 , 33 , 24 , 72 , 18 , 36 , 0 , 24 , 12 , 51 , 24 , 39 , 36 , 24 , 6 , 120 , 0 , 72 , 24 , 30 , 30 , 30 , 0 , 24 , 12 , 72 , 18 , 54 , 3 , 84 , 30 , 30 , 21 , 42 , 24 , 30 , 18 , 30 , 0 , 54 , 0 , 36 , 30 , 24 , 30 , 72 , 9 , 72 , 6 , 30 , 24 , 36 , 24 , 30 , 0 , 30 , 0 , 90 , 12 , 48 , 27 , 24 , 6 , 54 , 12 , 39 , 36 , 18 , 18 , 78 , 0 , 36 , 12 , 18 , 39 , 66 , 6 , 54 , 18 , 36 , 0 , 54 , 18 , 42 , 12 , 30 , 0 , 78 , 0 , 48 , 45 , 27 , 36 , 36 , 9 , 54 , 15 , 6 , 12 , 99 , 15 , 48 , 0 , 24 , 3 , 60 , 12 , 45 , 36 , 36 , 30 , 24 , 12 , 57 , 30 , 42 , 18 , 54 , 0 , 36 , 6 , 45 , 24 , 63 , 30 , 60 , 12 , 42 , 6 , 102 , 18 , 30 , 33 , 18 , 0 , 84 , 12 , 54 , 24 , 39 , 12 , 42 , 0 , 36 , 0 , 54 , 24 , 60 , 12 , 42 , 0 , 48 , 6 , 30 , 9 , 93 , 24 , 18 , 21 , 60 , 6 , 21 , 36 , 18 , 54 , 102 , 0 , 30 , 18 , 36 , 21 , 48 , 12 , 30 , 27 , 42 , 3 , 54 , 12 , 66 , 36 , 36 , 0 , 48 , 9 , 45 , 33 , 30 , 9 , 84 , 18 , 30 , 12 , 33 , 36 , 51 , 12 , 54 , 0 , 36 , 18 , 42 , 12 , 30 , 36 , 24 , 9 , 72 , 0 , 48 , 30 , 36 , 6 , 78 , 0 , 42 , 0 , 18 , 24 , 63 , 21 , 36 , 18 , 24 , 15 , 66 , 0 , 42 , 27 , 54 , 0 , 30 , 9 , 51 , 45 , 45 , 24 , 48 , 12 , 72 , 12 , 33 , 24 , 39 , 30 , 66 , 0 , 18 , 6 , 69 , 12 , 36 , 24 , 36 , 18 , 90 , 6 , 60 , 24 , 36 , 27 , 36 , 0 , 60 , 18 , 33 , 21 , 84 , 12 , 36 , 30 , 18 , 0 , 33 , 24 , 51 , 30 , 24 , 0 , 84 , 0 , 57 , 33 , 36 , 21 , 84 , 12 , 30 , 12 , 33 , 36 , 63 , 18 , 24 , 0 , 30 , 6 , 90 , 21 , 66 , 30 , 30 , 24 , 36 , 0 , 54 , 12 , 51 , 18 , 78 , 0 , 36 , 0 , 18 , 18 , 54 , 21 , 48 , 12 , 66 , 18 , 21 , 18 , 33 , 21 , 42 , 0 , 66 , 6 , 48 , 54 , 21 , 30 , 66 , 12 , 66 , 0 , 24 , 24 , 63 , 24 , 36 , 0 , 42 , 3 , 60 , 18 , 30 , 6 , 36 , 9 , 54 , 6 , 72 , 48 , 36 , 15 , 54 , 0 , 30 , 27 , 12 , 18 , 60 , 12 , 66 , 15 , 48 , 10 , 84 , 12 , 39 , 42 , 12 , 0 , 66 , 6 , 24 , 18 , 21 , 36 , 54 , 24 , 24 , 12 , 51 , 18 , 66 , 12 , 90 , 0 , 18 , 6 , 87 , 15 , 75 , 24 , 30 , 15 , 60 , 0 , 24 , 42 , 24 , 24 , 48 , 0 , 84 , 6 , 51 , 39 , 60 , 12 , 18 , 30 , 36 , 12 , 60 , 12 , 60 , 48 , 36 , 0 , 54 , 6 , 42 , 12 , 6 , 18 , 78 , 6 , 48 , 12 , 12 , 36 , 84 , 0 , 48 , 0 , 54 , 3 , 48 , 18 , 45 , 51 , 54 , 6 , 72 , 6 , 51 , 30 , 45 , 30 , 48 , 0 , 36 , 6 , 36 , 15 , 78 , 24 , 42 , 24 , 24 , 0 , 90 , 18 , 36 , 24 , 24 , 0 , 36 , 0 , 36 , 30 , 30 , 30 , 66 , 6 , 78 , 21 , 30 , 12 , 21 , 15 , 60 , 0 , 36 , 12 , 66 , 21 , 36 , 24 , 30 , 18 , 60 , 9 , 54 , 48 , 24 , 18 , 48 , 0 , 30 , 6 , 42 , 18 , 81 , 18 , 54 , 27 , 24 , 12 , 30 , 18 , 84 , 30 , 24 , 0 , 102 , 9 , 42 , 42 , 36 , 24 , 90 , 3 , 30 , 0 , 60 , 30 , 42 , 18 , 24 , 0 , 18 , 0 , 78 , 12 , 42 , 27 , 42 , 18 , 66 , 18 , 45 , 18 , 42 , 9 , 84 , 0 , 54 , 6 , 15 , 54 , 63 , 18 , 54 , 24 , 24 , 9 , 57 , 24 , 45 , 54 , 36 , 0 , 60 , 0 , 66 , 27 , 33 , 18 , 30 , 9 , 60 , 24 , 30 , 12 , 54 , 21 , 24 , 0 , 12 , 18 , 108 , 15 , 66 , 12 , 30 , 27 , 66 , 0 , 36 , 30 , 36 , 24 , 66 , 0 , 60 , 0 , 9 , 24 , 54 , 12 , 90 , 15 , 42 , 0 , 51 , 30 , 18 , 30 , 48 , 0 , 84 , 9 , 48 , 21 , 54 , 30 , 24 , 18 , 36 , 12 , 45 , 18 , 96 , 6 , 30 , 0 , 30 , 9 , 30 , 24 , 42 , 24 , 24 , 15 , 66 , 6 , 69 , 36 , 15 , 15 , 84 , 0 , 36 , 15 , 48 , 27 , 45 , 18 , 42 , 30 , 36 , 0 , 66 , 6 , 72 , 30 , 48 , 0 , 42 , 3 , 51 , 39 , 30 , 33 , 78 , 12 , 24 , 18 , 30 , 18 , 105 , 21 , 72 , 0 , 42 , 12 , 39 , 18 , 27 , 42 , 24 , 6 , 66 , 3 , 60 , 42 , 30 , 30 , 60 , 0 , 54 , 6 , 54 , 24 , 57 , 6 , 54 , 6 , 24 , 24 , 54 , 12 , 57 , 27 , 42 , 0 , 48 , 6 , 36 , 27 , 57 , 12 , 84 , 12 , 60 , 0 , 12 , 30 , 54 , 24 , 48 , 0 , 18 , 3 , 105 , 36 , 48 , 42 , 24 , 18 , 48 , 6 , 30 , 36 , 45 , 42 , 42 , 0 , 54 , 9 , 36 , 12 , 48 , 12 , 54 , 30 , 30 , 6 , 48 , 6 , 51 , 18 , 36 , 0 , 102 , 6 , 18 , 30 , 33 , 24 , 48 , 18 , 60 , 12 , 60 , 30 , 45 , 12 , 36 , 0 , 54 , 12 , 60 , 6 , 48 , 54 , 12 , 13 , 60 , 0 , 72 , 18 , 24 , 6 , 90 , 0 , 48 , 12 , 15 , 42 , 96 , 18 , 36 , 18 , 36 , 6 , 78 , 24 , 48 , 18 , 30 , 0 , 48 , 18 , 78 , 42 , 24 , 30 , 60 , 6 , 60 , 12 , 18 , 12 , 42 , 30 , 42 , 0 , 24 , 0 , 81 , 9 , 54 , 18 , 60 , 33 , 48 , 0 , 27 , 54 , 51 , 27 , 90 , 0 , 60 , 18 , 24 , 18 , 54 , 24 , 36 , 12 , 42 , 0 , 87 , 24 , 33 , 18 , 24 , 0 , 96 , 0 , 87 , 36 , 30 , 15 , 42 , 12 , 36 , 24 , 24 , 36 , 42 , 21 , 48 , 0 , 30 , 6 , 42 , 18 , 48 , 24 , 24 , 18 , 84 , 3 , 36 , 42 , 42 , 36 , 72 , 0 , 54 , 6 , 30 , 15 , 60 , 6 , 78 , 30 , 24 , 6 , 72 , 6 , 66 , 45 , 24 , 0 , 42 , 21 , 36 , 30 , 36 , 18 , 48 , 12 , 30 , 0 , 39 , 24 , 102 , 18 , 36 , 0 , 12 , 6 , 54 , 6 , 30 , 33 , 66 , 21 , 90 , 3 , 78 , 36 , 9 , 18 , 36 , 0 , 84 , 0 , 30 , 30 , 93 , 24 , 30 , 24 , 30 , 15 , 63 , 12 , 48 , 30 , 54 , 0 , 48 , 0 , 54 , 42 , 42 , 30 , 78 , 0 , 36 , 24 , 39 , 24 , 60 , 12 , 78 , 0 , 60 , 6 , 51 , 30 , 36 , 36 , 30 , 18 , 60 , 0 , 30 , 30 , 51 , 24 , 60 , 0 , 42 , 3 , 24 , 9 , 54 , 21 , 24 , 33 , 30 , 24 , 66 , 24 , 69 , 18 , 30 , 0 , 102 , 15 , 54 , 24 , 15 , 30 , 120 , 6 , 30 , 3 , 51 , 24 , 54 , 12 , 30 , 0 , 36 , 6 , 36 , 12 , 90 , 42 , 12 , 12 , 60 , 12 , 60 , 24 , 42 , 12 , 90 , 0 , 24 , 12 , 42 , 30 , 30 , 6 , 78 , 21 , 42 , 0 , 54 , 24 , 27 , 54 , 24 , 0 , 66 , 6 , 45 , 30 , 12 , 30 , 42 , 12 , 84 , 15 , 36 , 18 , 84 , 24 , 36 , 0 , 30 , 18 , 72 , 18 , 60 , 24 , 48 , 12 , 54 , 6 , 36 , 54 , 42 , 12 , 42 , 0 , 60 , 0 , 51 , 48 , 54 , 9 , 36 , 27 , 24 , 6 , 84 , 18 , 48 , 30 , 42 , 0 , 78 , 0 , 48 , 27 , 27 , 48 , 42 , 18 , 36 , 0 , 39 , 18 , 99 , 24 , 102 , 0 , 18 , 0 , 48 , 18 , 72 , 15 , 36 , 12 , 84 , 12 , 24 , 12 , 30 , 39 , 84 , 0 , 36 , 12 , 39 , 39 , 63 , 24 , 42 , 24 , 66 , 6 , 72 , 18 , 18 , 24 , 30 , 0 , 60 , 6 , 48 , 42 , 36 , 15 , 78 , 6 , 48 , 30 , 12 , 36 , 54 , 12 , 36 , 0 , 42 , 6 , 45 , 6 , 69 , 24 , 72 , 21 , 48 , 0 , 57 , 48 , 12 , 24 , 48 , 0 , 48 , 3 , 48 , 15 , 78 , 24 , 60 , 18 , 12 , 12 , 111 , 24 , 54 , 24 , 24 , 0 , 48 , 6 , 36 , 33 , 42 , 6 , 54 , 9 , 72 , 18 , 27 , 30 , 30 , 12 , 54 , 0 , 66 , 4 , 78 , 21 , 24 , 54 , 18 , 24 , 54 , 6 , 60 , 24 , 54 , 21 , 78 , 0 , 36 , 18 , 54 , 30 , 66 , 18 , 48 , 30 , 24 , 0 , 42 , 12 , 99 , 36 , 30 , 0 , 90 , 6 , 18 , 30 , 30 , 24 , 78 , 6 , 66 , 9 , 24 , 42 , 78 , 30 , 42 , 0 , 18 , 12 , 102 , 6 , 33 , 24 , 18 , 12 , 66 , 9 , 54 , 24 , 24 , 36 , 84 , 0 , 60 , 6 , 39 , 15 , 78 , 12 , 42 , 21 , 42 , 18 , 42 , 18 , 18 , 42 , 24 , 0 , 48 , 3 , 105 , 51 , 42 , 30 , 42 , 18 , 72 , 0 , 24 , 24 , 102 , 6 , 36 , 0 , 36 , 9 , 99 , 12 , 48 , 21 , 48 , 18 , 42 , 6 , 36 , 42 , 18 , 12 , 78 , 0 , 48 , 30 , 30 , 18 , 36 , 30 , 42 , 9 , 42 , 6 , 60 , 12 , 39 , 30 , 24 , 0 , 78 , 0 , 48 , 30 , 39 , 27 , 102 , 24 , 30 , 12 , 51 , 12 , 66 , 9 , 48 , 0 , 30 , 18 , 45 , 39 , 87 , 30 , 36 , 9 , 72 , 0 , 60 , 24 , 30 , 36 , 54 , 0 , 48 , 0 , 45 , 36 , 45 , 18 , 42 , 27 , 60 , 9 , 66 , 12 , 78 , 42 , 18 , 0 , 60 , 6 , 60 , 33 , 36 , 24 , 96 , 12 , 18 , 12 , 12 , 36 , 72 , 0 , 78 , 0 , 36 , 6 , 60 , 24 , 27 , 51 , 42 , 24 , 84 , 12 , 57 , 48 , 30 , 24 , 42 , 0 , 60 , 12 , 24 , 18 , 96 , 12 , 30 , 30 , 30 , 0 , 93 , 18 , 48 , 18 , 60 , 0 , 48 , 6 , 54 , 36 , 30 , 12 , 42 , 9 , 60 , 18 , 12 , 24 , 69 , 6 , 60 , 0 , 54 , 6 , 33 , 15 , 60 , 36 , 30 , 18 , 90 , 3 , 72 , 24 , 54 , 54 , 42 , 0 , 18 , 9 , 60 , 30 , 84 , 18 , 48 , 24 , 12 , 6 , 66 , 36 , 24 , 27 , 24 , 0 , 42 , 12 , 39 , 42 , 27 , 18 , 108 , 9 , 78 , 0 , 48 , 12 , 54 , 30 , 30 , 0 , 36 , 0 , 48 , 12 , 75 , 39 , 30 , 6 , 42 , 9 , 66 , 30 , 33 , 18 , 96 , 0 , 48 , 18 , 39 , 36 , 102 , 12 , 54 , 18 , 24 , 9 , 45 , 24 , 72 , 30 , 36 , 0 , 78 , 6 , 63 , 36 , 36 , 21 , 60 , 9 , 36 , 12 , 54 , 24 , 78 , 27 , 42 , 0 , 42 , 18 , 60 , 9 , 24 , 24 , 54 , 39 , 84 , 0 , 27 , 36 , 39 , 12 , 84 , 0 , 66 , 0 , 21 , 30 , 30 , 42 , 66 , 18 , 18 , 18 , 78 , 12 , 48 , 42 , 36 , 0 , 90 , 6 , 48 , 33 , 39 , 24 , 48 , 15 , 54 , 15 , 54 , 24 , 48 , 18 , 60 , 0 , 24 , 0 , 48 , 24 , 78 , 24 , 36 , 9 , 90 , 12 , 42 , 24 , 30 , 45 , 54 , 0 , 66 , 12 , 24 , 12 , 60 , 6 , 48 , 33 , 48 , 0 , 60 , 6 , 51 , 54 , 12 , 0 , 30 , 0 , 69 , 21 , 42 , 15 , 72 , 15 , 48 , 21 , 33 , 36 , 96 , 6 , 30 , 0 , 54 , 6 , 87 , 30 , 42 , 30 , 36 , 13 , 42 , 6 , 84 , 48 , 18 , 18 , 72 , 0 , 54 , 12 , 30 , 30 , 75 , 24 , 36 , 24 , 42 , 18 , 78 , 12 , 36 , 30 , 72 , 0 , 48 , 6 , 33 , 36 , 57 , 36 , 66 , 6 , 54 , 0 , 27 , 36 , 66 , 12 , 90 , 0 , 24 , 3 , 96 , 24 , 27 , 24 , 18 , 24 , 108 , 12 , 42 , 48 , 24 , 18 , 30 , 0 , 54 , 18 , 48 , 12 , 75 , 18 , 90 , 21 , 36 , 12 , 72 , 12 , 45 , 24 , 24 , 0 , 114 , 0 , 27 , 30 , 39 , 33 , 48 , 12 , 54 , 12 , 18 , 42 , 45 , 27 , 48 , 0 , 48 , 6 , 90 , 9 , 60 , 42 , 36 , 12 , 48 , 0 , 36 , 42 , 42 , 18 , 78 , 0 , 30 , 6 , 24 , 33 , 78 , 9 , 84 , 30 , 18 , 15 , 63 , 18 , 51 , 30 , 48 , 0 , 72 , 6 , 36 , 51 , 24 , 30 , 48 , 21 , 96 , 6 , 24 , 6 , 93 , 12 , 48 , 0 , 18 , 6 , 69 , 18 , 36 , 18 , 24 , 18 , 24 , 6 , 54 , 36 , 51 , 33 , 96 , 0 , 36 , 15 , 27 , 30 , 54 , 30 , 42 , 12 , 36 , 0 , 117 , 36 , 54 , 36 , 24 , 0 , 96 , 3 , 72 , 36 , 57 , 27 , 54 , 6 , 54 , 21 , 36 , 12 , 66 , 33 , 60 , 0 , 30 , 24 , 24 , 15 , 63 , 30 , 42 , 24 , 78 , 9 , 39 , 30 , 24 , 24 , 138 , 0 , 42 , 0 , 54 , 24 , 57 , 12 , 30 , 24 , 42 , 18 , 54 , 6 , 60 , 33 , 24 , 0 , 72 , 6 , 84 , 24 , 42 , 6 , 66 , 15 , 36 , 0 , 42 , 48 , 51 , 18 , 66 , 0 , 60 , 3 , 60 , 12 , 60 , 57 , 42 , 9 , 72 , 12 , 60 , 42 , 27 , 24 , 60 , 0 , 42 , 18 , 24 , 30 , 48 , 30 , 36 , 18 , 30 , 9 , 78 , 12 , 51 , 18 , 30 , 0 , 60 , 0 , 12 , 57 , 51 , 18 , 78 , 6 , 102 , 12 , 30 , 24 , 48 , 27 , 36 , 0 , 30 , 12 , 126 , 6 , 27 , 36 , 30 , 18 , 66 , 0 , 60 , 30 , 48 , 36 , 48 , 0 , 24 , 6 , 39 , 24 , 96 , 12 , 90 , 33 , 36 , 6 , 39 , 6 , 90 , 27 , 36 , 0 , 60 , 12 , 45 , 42 , 30 , 30 , 72 , 12 , 36 , 9 , 39 , 36 , 69 , 24 , 48 , 0 , 36 , 6 , 66 , 15 , 72 , 39 , 36 , 27 , 54 , 18 , 57 , 30 , 42 , 12 , 60 , 0 , 84 , 24 , 36 , 27 , 72 , 12 , 48 , 21 , 60 , 0 , 51 , 30 , 27 , 30 , 90 , 0 , 78 , 0 , 42 , 57 , 12 , 30 , 48 , 18 , 42 , 6 , 48 , 24 , 90 , 15 , 42 , 0 , 12 , 15 , 84 , 24 , 72 , 18 , 48 , 21 , 66 , 3 , 54 , 42 , 30 , 24 , 48 , 0 , 36 , 18 , 27 , 12 , 42 , 9 , 108 , 18 , 36 , 12 , 96 , 24 , 21 , 30 , 24 , 0 , 96 , 9 , 54 , 18 , 75 , 30 , 54 , 18 , 36 , 0 , 39 , 18 , 84 , 18 , 42 , 0 , 24 , 6 , 54 , 18 , 57 , 42 , 24 , 9 , 84 , 18 , 48 , 42 , 27 , 30 , 78 , 0 , 60 , 0 , 30 , 48 , 36 , 6 , 30 , 36 , 6 , 10 , 78 , 12 , 51 , 48 , 48 , 0 , 90 , 0 , 75 , 9 , 42 , 24 , 48 , 15 , 72 , 12 , 33 , 42 , 108 , 12 , 54 , 0 , 54 , 18 , 51 , 42 , 36 , 48 , 48 , 12 , 72 , 0 , 42 , 18 , 45 , 30 , 66 , 0 , 78 , 3 , 36 , 15 , 78 , 30 , 30 , 30 , 30 , 15 , 102 , 12 , 54 , 18 , 30 , 0 , 36 , 6 , 81 , 48 , 12 , 24 , 108 , 6 , 78 , 18 , 24 , 36 , 33 , 18 , 30 , 0 , 30 , 0 , 108 , 21 , 54 , 42 , 18 , 18 , 90 , 6 , 30 , 48 , 69 , 36 , 48 , 0 , 24 , 15 , 24 , 15 , 84 , 24 , 114 , 6 , 30 , 0 , 48 , 6 , 60 , 42 , 24 , 0 , 102 , 12 , 42 , 42 , 27 , 21 , 78 , 9 , 42 , 24 , 51 , 24 , 42 , 12 , 48 , 0 , 60 , 12 , 66 , 6 , 42 , 24 , 30 , 24 , 42 , 0 , 78 , 24 , 54 , 12 , 66 , 0 , 30 , 6 , 24 , 51 , 99 , 18 , 60 , 24 , 42 , 18 , 54 , 6 , 45 , 60 , 36 , 0 , 54 , 6 , 39 , 39 , 39 , 30 , 66 , 18 , 72 , 0 , 51 , 24 , 102 , 12 , 54 , 0 , 24 , 0 , 102 , 12 , 48 , 24 , 42 , 36 , 60 , 0 , 12 , 48 , 18 , 12 , 54 , 0 , 84 , 18 , 39 , 9 , 84 , 30 , 66 , 18 , 48 , 15 , 72 , 48 , 39 , 42 , 48 , 0 , 60 , 0 , 84 , 30 , 45 , 33 , 54 , 6 , 54 , 30 , 33 , 30 , 90 , 6 , 54 , 0 , 24 , 6 , 72 , 27 , 78 , 12 , 24 , 15 , 66 , 0 , 54 , 36 , 21 , 42 , 114 , 0 , 60 , 3 , 30 , 33 , 54 , 27 , 30 , 33 , 60 , 6 , 54 , 12 , 48 , 33 , 36 , 0 , 42 , 12 , 45 , 39 , 24 , 36 , 96 , 18 , 24 , 12 , 33 , 18 , 99 , 18 , 66 , 0 , 36 , 0 , 51 , 24 , 30 , 30 , 36 , 15 , 84 , 6 , 102 , 48 , 48 , 18 , 60 , 0 , 72 , 12 , 36 , 42 , 60 , 12 , 24 , 21 , 30 , 0 , 54 , 18 , 60 , 18 , 42 , 0 , 66 , 6 , 24 , 24 , 54 , 15 , 78 , 12 , 42 , 27 , 27 , 30 , 51 , 27 , 78 , 0 , 48 , 6 , 120 , 27 , 48 , 42 , 24 , 12 , 54 , 6 , 54 , 24 , 48 , 36 , 66 , 0 , 78 , 9 , 57 , 21 , 48 , 18 , 54 , 33 , 24 , 30 , 84 , 18 , 45 , 33 , 30 , 0 , 126 , 9 , 36 , 30 , 27 , 30 , 66 , 18 , 54 , 0 , 36 , 42 , 48 , 6 , 42 , 0 , 54 , 6 , 57 , 12 , 84 , 54 , 48 , 6 , 60 , 6 , 63 , 18 , 42 , 36 , 78 , 0 , 24 , 24 , 33 , 24 , 105 , 24 , 66 , 27 , 48 , 0 , 48 , 30 , 60 , 30 , 54 , 0 , 42 , 3 , 75 , 48 , 24 , 12 , 66 , 12 , 96 , 6 , 30 , 12 , 87 , 21 , 36 , 0 , 30 , 24 , 69 , 12 , 57 , 30 , 48 , 24 , 54 , 0 , 42 , 54 , 24 , 24 , 72 , 0 , 60 , 0 , 48 , 24 , 69 , 24 , 42 , 18 , 36 , 12 , 66 , 24 , 36 , 42 , 18 , 0 , 78 , 9 , 48 , 36 , 42 , 42 , 36 , 12 , 36 , 21 , 78 , 18 , 48 , 12 , 102 , 0 , 18 , 12 , 54 , 24 , 45 , 27 , 42 , 13 , 108 , 12 , 39 , 24 , 42 , 27 , 102 , 0 , 60 , 6 , 39 , 24 , 54 , 12 , 54 , 24 , 24 , 0 , 114 , 24 , 63 , 48 , 30 , 0 , 48 , 6 , 69 , 36 , 18 , 12 , 72 , 6 , 48 , 18 , 33 , 54 , 117 , 12 , 42 , 0 , 66 , 12 , 48 , 6 , 54 , 36 , 42 , 21 , 102 , 6 , 48 , 54 , 33 , 30 , 48 , 0 , 72 , 0 , 30 , 24 , 75 , 24 , 84 , 30 , 30 , 0 , 72 , 18 , 30 , 42 , 54 , 0 , 60 , 12 , 36 , 45 , 42 , 12 , 96 , 6 , 66 , 0 , 12 , 36 , 78 , 36 , 42 , 0 , 36 , 0 , 78 , 24 , 48 , 24 , 18 , 30 , 90 , 15 , 96 , 18 , 27 , 21 , 54 , 0 , 24 , 21 , 48 , 27 , 84 , 18 , 48 , 42 , 36 , 6 , 66 , 12 , 108 , 12 , 42 , 0 , 48 , 9 , 27 , 60 , 21 , 36 , 84 , 6 , 36 , 18 , 42 , 18 , 54 , 18 , 60 , 0 , 60 , 15 , 72 , 9 , 99 , 42 , 12 , 12 , 60 , 0 , 57 , 42 , 18 , 18 , 78 , 0 , 42 , 6 , 36 , 36 , 63 , 9 , 42 , 15 , 30 , 18 , 78 , 6 , 24 , 48 , 42 , 0 , 102 , 12 , 75 , 45 , 42 , 30 , 84 , 24 , 66 , 9 , 24 , 30 , 90 , 24 , 42 , 0 , 24 , 3 , 84 , 21 , 84 , 33 , 66 , 24 , 36 , 6 , 36 , 48 , 51 , 18 , 72 , 0 , 66 , 18 , 54 , 30 , 24 , 18 , 48 , 18 , 30 , 0 , 102 , 12 , 45 , 36 , 24 , 0 , 102 , 3 , 42 , 15 , 42 , 54 , 54 , 21 , 66 , 24 , 66 , 30 , 102 , 3 , 66 , 0 , 48 , 12 , 24 , 30 , 45 , 36 , 54 , 6 , 78 , 9 , 48 , 24 , 39 , 36 , 96 , 0 , 66 , 6 , 27 , 27 , 60 , 30 , 18 , 30 , 48 , 12 , 90 , 24 , 60 , 36 , 6 , 0 , 42 , 12 , 78 , 36 , 36 , 24 , 114 , 6 , 60 , 0 , 18 , 6 , 69 , 18 , 84 , 0 , 36 , 6 , 48 , 6 , 39 , 24 , 42 , 24 , 54 , 6 , 72 , 48 , 36 , 42 , 60 , 0 , 48 , 0 , 36 , 18 , 138 , 24 , 30 , 30 , 42 , 18 , 75 , 18 , 48 , 18 , 24 , 0 , 78 , 0 , 78 , 57 , 60 , 9 , 48 , 9 , 36 , 30 , 30 , 42 , 42 , 39 , 84 , 0 , 24 , 12 , 87 , 27 , 30 , 42 , 24 , 24 , 90 , 0 , 36 , 24 , 60 , 36 , 84 , 0 , 42 , 0 , 30 , 21 , 87 , 12 , 72 , 24 , 42 , 12 , 60 , 30 , 72 , 21 , 60 , 0 , 96 , 12 , 30 , 42 , 39 , 18 , 66 , 12 , 84 , 12 , 63 , 42 , 42 , 24 , 42 , 0 , 18 , 6 , 78 , 15 , 75 , 45 , 54 , 12 , 54 , 6 , 84 , 30 , 30 , 18 , 54 , 0 , 42 , 24 , 39 , 27 , 96 , 18 , 42 , 21 , 48 , 0 , 54 , 18 , 33 , 36 , 66 , 0 , 84 , 0 , 75 , 48 , 30 , 42 , 54 , 12 , 54 , 15 , 42 , 30 , 96 , 18 , 42 , 0 , 18 , 6 , 123 , 15 , 48 , 24 , 48 , 39 , 42 , 6 , 21 , 54 , 45 , 12 , 60 , 0 , 90 , 12 , 30 , 36 , 45 , 18 , 72 , 21 , 78 , 12 , 30 , 12 , 60 , 30 , 18 , 0 , 78 , 6 , 60 , 36 , 33 , 18 , 60 , 12 , 30 , 0 , 60 , 18 , 90 , 30 , 54 , 0 , 36 , 1 , 78 , 27 , 84 , 30 , 18 , 15 , 102 , 9 , 27 , 30 , 24 , 57 , 90 , 0 , 42 , 9 , 48 , 42 , 42 , 12 , 72 , 27 , 48 , 9 , 108 , 18 , 48 , 48 , 18 , 0 , 84 , 6 , 66 , 24 , 48 , 21 , 114 , 6 , 78 , 24 , 30 , 30 , 42 , 18 , 60 , 0 , 18 , 12 , 63 , 9 , 51 , 66 , 48 , 15 , 54 , 0 , 66 , 60 , 36 , 18 , 48 , 0 , 66 , 6 , 36 , 30 , 96 , 9 , 36 , 30 , 30 , 24 , 93 , 24 , 72 , 24 , 66 , 0 , 60 , 24 , 48 , 30 , 24 , 30 , 72 , 6 , 60 , 12 , 30 , 12 , 93 , 18 , 72 , 0 , 30 , 0 , 81 , 30 , 36 , 48 , 36 , 30 , 90 , 6 , 54 , 24 , 57 , 24 , 36 , 0 , 54 , 18 , 36 , 24 , 78 , 18 , 72 , 33 , 12 , 0 , 51 , 30 , 48 , 24 , 42 , 0 , 90 , 3 , 78 , 30 , 30 , 27 , 138 , 6 , 30 , 18 , 36 , 24 , 75 , 24 , 12 , 0 , 54 , 12 , 42 , 18 , 84 , 36 , 30 , 18 , 66 , 6 , 45 , 36 , 36 , 48 , 114 , 0 , 24 , 6 , 30 , 21 , 108 , 15 , 48 , 18 , 36 , 18 , 57 , 24 , 63 , 42 , 54 , 0 , 78 , 6 , 81 , 36 , 18 , 24 , 42 , 18 , 120 , 0 , 24 , 24 , 66 , 12 , 54 , 0 , 48 , 12 , 66 , 18 , 42 , 36 , 48 , 18 , 72 , 6 , 48 , 48 , 33 , 6 , 102 , 0 , 54 , 24 , 39 , 54 , 60 , 12 , 90 , 18 , 36 , 3 , 111 , 24 , 51 , 48 , 42 , 0 , 90 , 0 , 45 , 36 , 54 , 48 , 54 , 24 , 18 , 18 , 51 , 18 , 72 , 0 , 54 , 0 , 18 , 12 , 54 , 36 , 57 , 18 , 42 , 18 , 120 , 0 , 63 , 42 , 27 , 36 , 48 , 0 , 54 , 6 , 39 , 30 , 81 , 18 , 72 , 33 , 54 , 9 , 72 , 12 , 54 , 54 , 24 , 0 , 54 , 15 , 75 , 24 , 60 , 12 , 78 , 6 , 30 , 12 , 39 , 54 , 72 , 6 , 54 , 0 , 72 , 6 , 78 , 12 , 54 , 39 , 30 , 15 , 48 , 6 , 57 , 48 , 18 , 24 , 90 , 0 , 90 , 18 , 42 , 24 , 39 , 42 , 24 , 30 , 42 , 0 , 84 , 6 , 66 , 30 , 30 , 0 , 30 , 0 , 27 , 42 , 39 , 33 , 90 , 24 , 84 , 18 , 51 , 36 , 69 , 24 , 54 , 0 , 42 , 18 , 87 , 33 , 51 , 18 , 42 , 9 , 126 , 9 , 84 , 36 , 66 , 18 , 54 , 0 , 36 , 0 , 66 , 12 , 48 , 15 , 54 , 30 , 18 , 18 , 60 , 18 , 96 , 54 , 42 , 0 , 102 , 0 , 27 , 36 , 30 , 36 , 108 , 15 , 54 , 0 , 24 , 36 , 60 , 24 , 66 , 0 , 30 , 0 , 54 , 15 , 75 , 48 , 36 , 18 , 48 , 24 , 36 , 36 , 54 , 15 , 108 , 0 , 84 , 18 ] <NEWLINE> N = int ( input ( ) ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> print ( ls [ i ] ) <NEWLINE> <DEDENT>
from collections import defaultdict <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> <NL> <NL> def fun ( x , y , z ) : <NEWLINE> <INDENT> return x ** 2 + y ** 2 + z ** 2 + x * y + y * z + z * x <NEWLINE> <NL> <DEDENT> res = defaultdict ( int ) <NEWLINE> <NL> for x in range ( 1 , 50 ) : <NEWLINE> <INDENT> for y in range ( 1 , 50 ) : <NEWLINE> <INDENT> for z in range ( 1 , 50 ) : <NEWLINE> <INDENT> dict [ fun ( x , y , z ) ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for n in range ( 1 , N ) : <NEWLINE> <INDENT> print ( dict [ n ] ) <NEWLINE> <NL> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = [ 0 ] * ( n + 1 ) <NEWLINE> for n in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> for i in range ( 1 , 102 ) : <NEWLINE> <INDENT> for j in range ( 1 , 102 ) : <NEWLINE> <INDENT> for k in range ( 1 , 102 ) : <NEWLINE> <INDENT> if n == ( i * i + j * j + k * k + i * j + j * k + i * k ) : <NEWLINE> <INDENT> a [ n ] += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for x in a [ 1 : ] : <NEWLINE> <INDENT> print ( x ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> ans = [ 0 for _ in range ( 10050 ) ] <NEWLINE> for i in range ( 1 , 105 ) : <NEWLINE> <INDENT> for j in range ( 1 , 105 ) : <NEWLINE> <INDENT> for k in range ( 1 , 105 ) : <NEWLINE> <INDENT> v = i * i + j * j + k * k + i * j + j * k + k * i ; <NEWLINE> if v < 10050 : <NEWLINE> <INDENT> ans [ v ] += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for i in range ( n ) : <NEWLINE> print ( ans [ i + 1 ] ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> ans = [ 0 ] * n <NEWLINE> tmp = [ ] <NEWLINE> <NL> for x in range ( 1 , int ( n ** 0.5 ) + 1 ) : <NEWLINE> <INDENT> for y in range ( 1 , int ( n ** 0.5 ) + 1 ) : <NEWLINE> <INDENT> for z in range ( 1 , int ( n ** 0.5 ) + 1 ) : <NEWLINE> <INDENT> tmp . append ( x ** 2 + y ** 2 + z ** 2 + x * y + y * z + z * x ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> cnt = collections . Counter ( tmp ) <NEWLINE> <NL> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> print ( cnt [ i ] ) <NEWLINE> <NL> <DEDENT>
<NL> import math <NEWLINE> def func ( x , y , z ) : <NEWLINE> <INDENT> ans = x ** 2 + y ** 2 + z ** 2 + x * y + y * z + z * x <NEWLINE> return ans <NEWLINE> <NL> <DEDENT> N = int ( input ( ) ) <NEWLINE> array_N = [ 0 ] * N <NEWLINE> root_n = round ( math . sqrt ( n + 1 ) ) <NEWLINE> <NL> for x in range ( 1 , root_n ) : <NEWLINE> <INDENT> for y in range ( 1 , root_n ) : <NEWLINE> <INDENT> for z in range ( 1 , root_n ) : <NEWLINE> <INDENT> if func ( x , y , z ) <= N : <NEWLINE> <INDENT> array_N [ func ( x , y , z ) - 1 ] = array_N [ func ( x , y , z ) - 1 ] + 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> print ( array_N [ i ] ) <NEWLINE> <DEDENT>
n = I ( ) <NEWLINE> dp = [ 0 ] * ( 500000 ) <NEWLINE> for x in range ( 1 , 101 ) : <NEWLINE> <INDENT> for y in range ( 1 , 101 ) : <NEWLINE> <INDENT> for z in range ( 1 , 101 ) : <NEWLINE> <INDENT> pe = x ** 2 + y ** 2 + z ** 2 + x * y + y * z + z * x <NEWLINE> dp [ pe ] += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( * dp [ 1 : n + 1 ] , sep = <STRING> ) <NEWLINE>
import sys <NEWLINE> si = sys . stdin . readline <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> n = int ( si ( ) ) <NEWLINE> ans = [ 0 for _ in range ( n + 1 ) ] <NEWLINE> for x in range ( 1 , 100 ) : <NEWLINE> <INDENT> for y in range ( 1 , 100 ) : <NEWLINE> <INDENT> for z in range ( 1 , 100 ) : <NEWLINE> <INDENT> v = ( ( x + y + z ) ** 2 + x ** 2 + y ** 2 + z ** 2 ) // 2 <NEWLINE> if v > 10000 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> ans [ v ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> print ( ans [ i + 1 ] ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> ans = [ 0 ] * 10000 <NEWLINE> for i in range ( 1 , 101 ) : <NEWLINE> <INDENT> for j in range ( 1 , 101 ) : <NEWLINE> <INDENT> for k in range ( 1 , 101 ) : <NEWLINE> <INDENT> v = i * i + j * j + k * k + i * j + j * k + k * i <NEWLINE> if v < 10050 : <NEWLINE> <INDENT> ans [ v ] += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> print ( ans [ i + 1 ] ) <NEWLINE> <DEDENT>
from collections import defaultdict <NEWLINE> N = int ( input ( ) ) <NEWLINE> d = defaultdict ( int ) <NEWLINE> for x in range ( 1 , 101 ) : <NEWLINE> <INDENT> for y in range ( 1 , 101 ) : <NEWLINE> <INDENT> for z in range ( 1 , 101 ) : <NEWLINE> <INDENT> n = x * x + y * y + z * z + x * y + y * z + z * x <NEWLINE> <INDENT> d [ n ] += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> print ( d [ i ] ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> r = [ 0 ] * N <NEWLINE> for i in range ( 1 , 100 ) : <NEWLINE> <INDENT> for j in range ( 1 , 100 ) : <NEWLINE> <INDENT> for k in range ( 1 , 100 ) : <NEWLINE> <INDENT> v = i * i + j * j + k * k + i * j + i * k + k * j <NEWLINE> if v <= 10000 <NEWLINE> r [ v - 1 ] += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( * r , sep = <STRING> ) <NEWLINE>
a = int ( input ( ) ) <NEWLINE> b = math . floor ( a ** 0.5 ) + 1 <NEWLINE> <NL> x = [ ] <NEWLINE> for i in range ( 1 , b ) : <NEWLINE> <INDENT> for j in range ( 1 , b ) : <NEWLINE> <INDENT> for k in range ( 1 , b ) : <NEWLINE> <INDENT> l = i ** 2 + j ** 2 + k ** 2 + i * j + j * k + k * i <NEWLINE> x . append ( l ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> t = [ 0 ] * a <NEWLINE> for i in range ( 0 , len ( x ) ) : <NEWLINE> <INDENT> if x [ i ] <= a : <NEWLINE> <INDENT> t [ x [ i ] ] = t [ x [ i ] ] + 1 <NEWLINE> <NL> <DEDENT> <DEDENT> for i in t : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> arr = [ 0 ] * 10100 <NEWLINE> for i in range ( 1 , 110 ) : <NEWLINE> <INDENT> for j in range ( 1 , 110 ) : <NEWLINE> <INDENT> for k in range ( 1 , 110 ) : <NEWLINE> <INDENT> s = i * i + j * j + k * k + i * j + j * k + k * i ; <NEWLINE> if s < 10100 : <NEWLINE> <INDENT> ans [ s ] += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> print ( arr [ i + 1 ] ) <NEWLINE> <DEDENT>
ans = [ ] <NEWLINE> n = int ( input ( ) ) <NEWLINE> for nn in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> aa = 0 <NEWLINE> for i in range ( 1 , 101 ) : <NEWLINE> <INDENT> for j in range ( i , 101 ) : <NEWLINE> <INDENT> for k in range ( j , 101 ) : <NEWLINE> <INDENT> if ( i + j + k ) ** 2 - ( i * j + j * k + k * i ) == nn : <NEWLINE> <INDENT> ll = len ( set ( [ i , j , k ] ) ) <NEWLINE> if ll == 1 : <NEWLINE> <INDENT> aa += 1 <NEWLINE> <DEDENT> elif ll == 2 : <NEWLINE> <INDENT> aa += 3 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> aa += 6 <NEWLINE> <DEDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> ans . append ( aa ) <NEWLINE> <DEDENT> for aa in ans : <NEWLINE> <INDENT> print ( aa ) <NEWLINE> <DEDENT>
import math <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> a = [ 0 ] * 10001 <NEWLINE> for i in range ( 1 , 100 ) : <NEWLINE> <INDENT> for j in range ( 1 , 100 ) : <NEWLINE> <INDENT> for k in range ( 1 , 100 ) : <NEWLINE> <INDENT> ans = ( ( i + j ) ** 2 + ( j + k ) ** 2 + ( k + i ) ** 2 ) // 2 <NEWLINE> a [ ans ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> print ( a [ i ] ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> ls = [ 0 ] * n <NEWLINE> xyz = [ 1 , 1 , 1 ] <NEWLINE> p = 6 <NEWLINE> cnt = 0 <NEWLINE> while p <= n : <NEWLINE> <INDENT> if x == y and x == z : <NEWLINE> <INDENT> ls [ p - 1 ] = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ls [ p - 1 ] = 3 <NEWLINE> <DEDENT> xyz [ cnt % 3 ] += 1 <NEWLINE> p = xyz [ 0 ] ** 2 + xyz [ 1 ] ** 2 + xyz [ 2 ] ** 2 + xyz [ 0 ] * xyz [ 1 ] + xyz [ 1 ] * xyz [ 2 ] + xyz [ 0 ] * xyz [ 2 ] <NEWLINE> <DEDENT> for i in ls : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> <NL> cnt = [ 0 ] * 6 * 10000 + 1 <NEWLINE> <NL> for x in range ( 1 , 100 ) : <NEWLINE> <INDENT> for y in range ( 1 , 100 ) : <NEWLINE> <INDENT> for z in range ( 1 , 100 ) : <NEWLINE> <INDENT> cnt [ x ** 2 + y ** 2 + z ** 2 + x * y + y * z + z * x ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> print ( cnt [ i ] ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> def sq ( n ) : <NEWLINE> <INDENT> c = 0 <NEWLINE> A = [ 0 for j in range ( n + 1 ) ] <NEWLINE> for i in range ( n // 2 ) : <NEWLINE> <INDENT> p = ( i + 1 ) ** 2 <NEWLINE> if p > n : <NEWLINE> <INDENT> for j in range ( i ** 2 , n + 1 ) : <NEWLINE> <INDENT> A [ j ] = i <NEWLINE> <DEDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for j in range ( i ** 2 , p ) : <NEWLINE> <INDENT> A [ j ] = i <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return A <NEWLINE> <DEDENT> A = sq ( N ) <NEWLINE> L = [ 0 for j in range ( N + 1 ) ] <NEWLINE> for x in range ( 1 , a + 1 ) : <NEWLINE> <INDENT> for y in range ( 1 , a + 1 ) : <NEWLINE> <INDENT> for z in range ( a + 1 ) : <NEWLINE> <INDENT> p = x ** 2 + y ** 2 + z ** 2 + x * y + y * z + z * x <NEWLINE> if p <= N : <NEWLINE> <INDENT> L [ p ] = L [ p ] + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for l in L : <NEWLINE> <INDENT> print ( l ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> ans = [ 0 for _ in range ( 10000 ) ] <NEWLINE> for x in range ( 1 , 100 ) : <NEWLINE> <INDENT> for y in range ( 1 , 100 ) : <NEWLINE> <INDENT> for z in range ( 1 , 100 ) : <NEWLINE> <INDENT> v = x ** 2 + y ** 2 + z ** 2 + x * y + y * z + z * x <NEWLINE> if v < 10050 : <NEWLINE> <INDENT> ans [ v ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> print ( ans [ i ] ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> lst = [ 0 ] * 10020 <NEWLINE> for i in range ( 1 , 45 ) : <NEWLINE> <INDENT> for j in range ( 1 , i + 1 ) : <NEWLINE> <INDENT> for k in range ( 1 , j + 1 ) : <NEWLINE> <INDENT> temp = i ** 2 + j ** 2 + k ** 2 + i * j + j * k + k * i <NEWLINE> if i == j and j == k : <NEWLINE> <INDENT> lst [ temp ] += 1 <NEWLINE> <DEDENT> elif i == j and j != k : <NEWLINE> <INDENT> lst [ temp ] += 3 <NEWLINE> <DEDENT> elif j == k and k != i : <NEWLINE> <INDENT> lst [ temp ] += 3 <NEWLINE> <DEDENT> elif k == i and i != j : <NEWLINE> <INDENT> lst [ temp ] += 3 <NEWLINE> <DEDENT> elif i != j and j != k : <NEWLINE> <INDENT> lst [ temp ] += 6 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for p in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> print ( lst [ p ] ) <NEWLINE> <DEDENT>
n = int ( ipnut ( ) ) <NEWLINE> cnt = [ 0 ] * 10001 <NEWLINE> for x in range ( 1 , 101 ) : <NEWLINE> <INDENT> for y in range ( 1 , 101 ) : <NEWLINE> <INDENT> for z in range ( 1 , 101 ) : <NEWLINE> <INDENT> v = x * x + y * y + z * z + x * y + y * z + z * x <NEWLINE> if v <= n : <NEWLINE> <INDENT> cnt [ v ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> print ( cnt [ i ] ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> ans = [ 0 ] * ( n + 1 ) <NEWLINE> <NL> for x in range ( 1 , 101 ) : <NEWLINE> <INDENT> for y in range ( 1 , 101 ) : <NEWLINE> <INDENT> for z in range ( 1 , 101 ) : <NEWLINE> <INDENT> n = x ** 2 + y ** 2 + z ** 2 + x * y + y * z + z * x <NEWLINE> if n <= N : <NEWLINE> <INDENT> ans [ n ] += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( * ans [ 1 : ] , sep = <STRING> ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> ans = [ ] <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> a = 0 <NEWLINE> for x in range ( 1 , 100 ) : <NEWLINE> <INDENT> for y in range ( 1 , x + 1 ) : <NEWLINE> <INDENT> for z in range ( 1 , y + 1 ) : <NEWLINE> <INDENT> if x ** 2 + y ** 2 + z ** 2 + x * y + y * z + z * x == i : <NEWLINE> <INDENT> if x == y and y == z : <NEWLINE> <INDENT> a += 1 <NEWLINE> <DEDENT> elif x == y or y == z : <NEWLINE> <INDENT> a += 3 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a += 6 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> ans . append ( a ) <NEWLINE> <DEDENT> for i in ans : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT>
from numba import jit <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> <NL> @ jit <NEWLINE> def f ( ) : <NEWLINE> <INDENT> ret = [ 0 ] * 10000 <NEWLINE> <NL> for i in range ( 1 , 200 ) : <NEWLINE> <INDENT> for j in range ( 1 , 200 ) : <NEWLINE> <INDENT> for k in range ( 1 , 200 ) : <NEWLINE> <INDENT> z = i ** 2 + j ** 2 + k ** 2 + i * j + j * k + k * i <NEWLINE> if z < 10000 : <NEWLINE> <INDENT> ret [ z ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> return ret <NEWLINE> <NL> <NL> <DEDENT> ans = f ( ) <NEWLINE> <NL> for x in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> print ( ans [ x ] ) <NEWLINE> <DEDENT>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> listx = list ( range ( 1 , 101 - 2 ) ) <NEWLINE> for x in listx : <NEWLINE> <INDENT> for y in range ( 1 , 101 - x + 1 ) : <NEWLINE> <INDENT> for z in range ( 1 , 101 - x - y + 1 ) : <NEWLINE> <INDENT> if i == x ** 2 + y ** 2 + z ** 2 + x * y + y * z + z * x : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> a = [ 0 ] * N <NEWLINE> for i in range ( 1 , 100 ) : <NEWLINE> <INDENT> for j in range ( 1 , 100 ) : <NEWLINE> <INDENT> for k in range ( 1 , 100 ) : <NEWLINE> <INDENT> n = i * i + j * j + k * k + i * j + i * k + j * k <NEWLINE> if ( n > N ) : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> a [ n - 1 ] += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> print ( a [ i ] ) <NEWLINE> <DEDENT>
N = input ( ) <NEWLINE> <NL> res = { i + 1 : 0 for i in range ( N ) } <NEWLINE> <NL> for i in range ( int ( sqrt ( N ) ) ) : <NEWLINE> <INDENT> for j in range ( int ( sqrt ( N ) ) ) : <NEWLINE> <INDENT> for k in range ( int ( sqrt ( N ) ) ) : <NEWLINE> <INDENT> n = i ** 2 + j ** 2 + k ** 2 + i * j + j * k + k * i <NEWLINE> if n in res : <NEWLINE> <INDENT> res [ n ] += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for r in res . values ( ) : <NEWLINE> <INDENT> print ( r ) <NEWLINE> <DEDENT>
n = 10 ** 4 <NEWLINE> ans = [ 0 ] * 10 ** 4 <NEWLINE> for x in range ( 1 , 101 ) : <NEWLINE> <INDENT> for y in range ( 1 , 101 ) : <NEWLINE> <INDENT> for z in range ( 1 , 101 ) : <NEWLINE> <INDENT> a = ( x + y + z ) ** 2 - ( x * y + y * z + z * x ) <NEWLINE> if a <= N : <NEWLINE> <INDENT> ans [ a - 1 ] += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for i in range ( int ( input ( ) ) ) : <NEWLINE> <INDENT> print ( ans [ i ] ) <NEWLINE> <DEDENT>
import math <NEWLINE> N = int ( input ( ) ) <NEWLINE> fn = { i + 1 : 0 for i in range ( N ) } <NEWLINE> rtN = int ( math . sqrt ( N ) ) + 1 <NEWLINE> <NL> def n ( x , y , z ) : <NEWLINE> <INDENT> return x ** 2 + y ** 2 + z ** 2 + x * y + y * z + z * x <NEWLINE> <NL> <DEDENT> for x in range ( 1 , rtN ) : <NEWLINE> <INDENT> for y in range ( 1 , rtN ) : <NEWLINE> <INDENT> for z in range ( 1 , rtN ) : <NEWLINE> <INDENT> n_ = n ( x , y , z ) <NEWLINE> try : <NEWLINE> <INDENT> f [ n_ ] += 1 <NEWLINE> <DEDENT> except KeyError : <NEWLINE> <INDENT> pass <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for k in fn . values ( ) : <NEWLINE> <INDENT> print ( k ) <NEWLINE> <DEDENT>
import math <NEWLINE> <NL> def f ( x , y , z ) : <NEWLINE> <INDENT> return ( x ** 2 + y ** 2 + z ** 2 + x * y + y * z + z * x ) <NEWLINE> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> fs = [ 0 ] * n <NEWLINE> <NL> lim = math . floor ( math . sqrt ( n ) ) <NEWLINE> rng = range ( 2 , lim ) <NEWLINE> <NL> for ( x in rng ) : <NEWLINE> <INDENT> for ( y in rng ) : <NEWLINE> <INDENT> for ( z in rng ) : <NEWLINE> <INDENT> v = f ( x , y , z ) <NEWLINE> if v <= n : <NEWLINE> <INDENT> fs [ v - 1 ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for ( i in range ( n ) ) : <NEWLINE> <INDENT> print ( fs [ i ] ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> cs = [ 0 ] * N <NEWLINE> for i in range ( 1 , 130 ) : <NEWLINE> <INDENT> for j in range ( 1 , 130 ) : <NEWLINE> <INDENT> for k in range ( 1 , 130 ) : <NEWLINE> <INDENT> temp = i ** 2 + j ** 2 + k ** 2 + i * j + j * k + k * i <NEWLINE> if temp = < N and temp > 0 : <NEWLINE> <INDENT> cs [ temp - 1 ] += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> print ( cs [ i ] ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> <NL> def popcount ( x : int ) : <NEWLINE> <INDENT> return bin ( x ) . count ( <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> N = int ( sys . stdin . readline ( ) . rstrip ( ) ) <NEWLINE> X = sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> <NL> Xdec = int ( X , 2 ) <NEWLINE> <NL> <COMMENT> <NL> if Xdec == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> return <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> md = popcount ( Xdec ) <NEWLINE> md_p , md_m = md + 1 , md - 1 <NEWLINE> <NL> tmp_p = Xdec % md_p <NEWLINE> if md_m == 0 : <NEWLINE> <INDENT> tmp_m = Xdec % md_m <NEWLINE> <NL> <DEDENT> for i in range ( 0 , N , 1 ) : <NEWLINE> <INDENT> if X [ i ] == <STRING> : <COMMENT> <NEWLINE> <INDENT> if md_m == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> x_m = pow ( 2 , ( N - 1 - i ) , md_m ) <NEWLINE> tmp = ( tmp_m - x_m ) % md_m <NEWLINE> <NL> <DEDENT> if X [ i ] == <STRING> : <COMMENT> <NEWLINE> <INDENT> x_p = pow ( 2 , ( N - 1 - i ) , md_p ) <NEWLINE> tmp = ( tmp_p + x_p ) % md_p <NEWLINE> <NL> <DEDENT> cnt = 1 <NEWLINE> while tmp : <NEWLINE> <NL> <INDENT> tmp = tmp % popcount ( tmp ) <NEWLINE> cnt += 1 <NEWLINE> <NL> <DEDENT> print ( cnt ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> main ( ) <NEWLINE>
n = input ( ) <NEWLINE> x = int ( input ( ) , 2 ) <NEWLINE> <NL> def popcount ( n ) : <NEWLINE> <INDENT> return n . count ( <STRING> ) <NEWLINE> <NL> <DEDENT> def popcount2 ( n ) : <NEWLINE> <INDENT> ans = 0 <NEWLINE> while n : <NEWLINE> <INDENT> ans += n % 2 <NEWLINE> n //= 2 <NEWLINE> <DEDENT> return ans <NEWLINE> <NL> <DEDENT> pops = popcount ( x ) <NEWLINE> x_pop_p = x % ( pops + 1 ) <NEWLINE> try : <NEWLINE> <INDENT> x_pop_m = x % ( pops - 1 ) <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> x_pop_m = 0 <NEWLINE> <DEDENT> for i in reversed ( range ( 0 , n ) ) : <NEWLINE> <INDENT> bit = x ^ ( 1 << i ) <NEWLINE> if bit == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> continue <NEWLINE> <DEDENT> if x & ( 1 << i ) : <NEWLINE> <INDENT> tmp = ( x_pop_m - pow ( 2 , i , ( pops - 1 ) ) ) % ( pops - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> tmp = ( x_pop_p + pow ( 2 , i , ( pops + 1 ) ) ) % ( pops + 1 ) <NEWLINE> <DEDENT> if tmp == 0 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> continue <NEWLINE> <DEDENT> cnt = 2 <NEWLINE> tmp %= popcount ( tmp ) <NEWLINE> while tmp > 0 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> if tmp == 0 : <NEWLINE> <INDENT> print ( cnt - 1 ) <NEWLINE> continue <NEWLINE> <DEDENT> tmp %= popcount ( tmp ) <NEWLINE> <DEDENT> print ( cnt ) <NEWLINE> <DEDENT>
<COMMENT> <NL> s = input ( ) <NEWLINE> x = int ( s , base = 2 ) <NEWLINE> popcount = s . count ( <STRING> ) <NEWLINE> y_zero = x % ( popcount + 1 ) <NEWLINE> if popcount > 1 : <NEWLINE> <INDENT> y_one = x % ( popcount - 1 ) <NEWLINE> <DEDENT> dp = [ - 1 ] * n <NEWLINE> dp [ 0 ] = 0 <NEWLINE> <NL> <NL> def calc ( y ) : <NEWLINE> <INDENT> if dp [ y ] != - 1 : <NEWLINE> <INDENT> return dp [ y ] <NEWLINE> <DEDENT> dp [ y ] = 1 + calc ( y % bin ( y ) . count ( <STRING> ) ) <NEWLINE> return dp [ y ] <NEWLINE> <NL> <NL> <DEDENT> ans = [ 0 ] * n <NEWLINE> rem_zero = 1 <NEWLINE> if popcount > 1 : <NEWLINE> <INDENT> rem_one = popcount - 2 <NEWLINE> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> if s [ n - 1 - i ] == <STRING> : <NEWLINE> <INDENT> ans [ n - 1 - i ] = 1 + calc ( ( y_zero + rem_zero ) % ( popcount + 1 ) ) <NEWLINE> <DEDENT> elif popcount > 1 : <NEWLINE> <INDENT> ans [ n - 1 - i ] = 1 + calc ( ( y_one + rem_one ) % ( popcount - 1 ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans [ n - 1 - i ] = 0 <NEWLINE> <DEDENT> rem_zero = rem_zero * 2 % ( popcount + 1 ) <NEWLINE> if popcount > 1 : <NEWLINE> <INDENT> rem_one = rem_one * 2 % ( popcount - 1 ) <NEWLINE> <DEDENT> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> print ( ans [ i ] ) <NEWLINE> <DEDENT>
from numba import njit <NEWLINE> <NL> <COMMENT> <NL> def popcount ( n ) : <NEWLINE> <INDENT> a = 0 <NEWLINE> while n != 0 : <NEWLINE> <INDENT> a += n & 1 <NEWLINE> n >>= 1 <NEWLINE> <DEDENT> return a <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> def fun ( n ) : <NEWLINE> <INDENT> ops = 0 <NEWLINE> while n : <NEWLINE> <INDENT> pc = popcount ( n ) <NEWLINE> n %= pc <NEWLINE> ops += 1 <NEWLINE> <DEDENT> return ops <NEWLINE> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> xs = list ( map ( int , input ( ) ) ) <NEWLINE> <NL> from functools import reduce <NEWLINE> sm = reduce ( lambda x , y : x * 2 + y , xs ) <NEWLINE> pc = xs . count ( 1 ) <NEWLINE> <NL> <COMMENT> <NL> mp = sm % ( pc + 1 ) <NEWLINE> mm = sm % ( pc - 1 ) if pc > 0 else 0 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> df = 1 if xs [ i ] == 0 else - 1 <NEWLINE> pci = pc + df <NEWLINE> if pci == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> continue <NEWLINE> <NL> <DEDENT> rest = pow ( 2 , n - i - 1 , pci ) <NEWLINE> <NL> if xs [ i ] == 0 : <NEWLINE> <INDENT> smi = ( mp + rest ) % pci <NEWLINE> print ( 1 + fun ( smi ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> smi = ( mm - rest ) % pci <NEWLINE> print ( 1 + fun ( smi ) ) <NEWLINE> <NL> <DEDENT> <DEDENT>
from sys import setrecursionlimit <NEWLINE> setrecursionlimit ( 10 ** 6 ) <NEWLINE> <NL> <NL> def popcount ( n ) : <NEWLINE> <INDENT> return bin ( n ) . count ( <STRING> ) <NEWLINE> <NL> <DEDENT> cache = [ - 1 ] * ( 2 * 10 ** 5 + 1 ) <NEWLINE> <NL> <NL> def f ( n ) : <NEWLINE> <INDENT> if cache [ n ] != - 1 : <NEWLINE> <INDENT> return cache [ n ] <NEWLINE> <DEDENT> return f ( n % popcount ( n ) ) + 1 <NEWLINE> <NL> <DEDENT> def g ( n , m ) : <NEWLINE> <INDENT> if n < 60 : <NEWLINE> <INDENT> return ( 1 << n ) % m <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> t = n // 2 <NEWLINE> return g ( t , m ) * g ( n - t , m ) % m <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> N = int ( input ( ) ) <NEWLINE> X = input ( ) <NEWLINE> <NL> c = X . count ( <STRING> ) <NEWLINE> t1 = [ 0 ] * N <NEWLINE> t2 = [ 0 ] * N <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> n = N - 1 - i <NEWLINE> t1 [ i ] = g ( n , c - 1 ) <NEWLINE> t2 [ i ] = g ( n , c + 1 ) <NEWLINE> <NL> <DEDENT> x1 , x2 = 0 , 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if X [ i ] == <STRING> : <NEWLINE> <INDENT> x1 += t1 [ i ] <NEWLINE> x2 += t2 [ i ] <NEWLINE> <NL> <DEDENT> <DEDENT> result = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if X [ i ] == <STRING> : <NEWLINE> <INDENT> n = x1 - t1 [ i ] <NEWLINE> n %= c - 1 <NEWLINE> <DEDENT> elif X [ i ] == <STRING> : <NEWLINE> <INDENT> n = x2 + t2 [ i ] <NEWLINE> n %= c + 1 <NEWLINE> <DEDENT> result . append ( f ( n ) + 1 ) <NEWLINE> <DEDENT> print ( * result , sep = <STRING> ) <NEWLINE>
def solve ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> X = input ( ) <NEWLINE> x = sum ( map ( int , list ( X ) ) ) <NEWLINE> dp = [ 0 ] * N <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> dp [ i ] = dp [ i % sum ( map ( int , list ( bin ( i ) [ 2 : ] ) ) ) ] + 1 <NEWLINE> <DEDENT> cnt = 0 <NEWLINE> if x == 1 : <NEWLINE> <INDENT> cnt1 = 0 <NEWLINE> <DEDENT> elif x > 1 : <NEWLINE> <INDENT> for i in range ( N ) : <NEWLINE> <INDENT> cnt1 += int ( X [ - i - 1 ] ) * pow ( 2 , i , x - 1 ) <NEWLINE> cnt1 %= x - 1 <NEWLINE> <DEDENT> <DEDENT> cnt2 = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> cnt2 += int ( X [ - i - 1 ] ) * pow ( 2 , i , x + 1 ) <NEWLINE> cnt2 %= x + 1 <NEWLINE> <NL> <DEDENT> ans = [ 0 ] * N <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if X [ i ] == <STRING> : <NEWLINE> <INDENT> if x == 1 : <NEWLINE> <INDENT> ans [ i ] = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> num = ( cnt1 - pow ( 2 , N - i - 1 , x - 1 ) ) % ( x - 1 ) <NEWLINE> ans [ i ] = dp [ num ] + 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> num = ( cnt2 + pow ( 2 , N - i - 1 , x + 1 ) ) % ( x + 1 ) <NEWLINE> ans [ i ] = dp [ num ] + 1 <NEWLINE> <DEDENT> <DEDENT> return ans <NEWLINE> <DEDENT> print ( * solve ( ) , sep = <STRING> ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> x = input ( ) <NEWLINE> pop = x . count ( <STRING> ) <NEWLINE> lst1 = [ 1 ] <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> lst1 . append ( lst1 [ - 1 ] * 2 % ( pop + 1 ) ) <NEWLINE> <DEDENT> lst1 . reverse ( ) <NEWLINE> num1 = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if x [ i ] == <STRING> : <NEWLINE> <INDENT> num1 += lst [ i ] <NEWLINE> num1 %= ( pop + 1 ) <NEWLINE> <DEDENT> <DEDENT> if pop == 1 or pop == 2 : <NEWLINE> <INDENT> lst2 = [ 0 ] * n <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> lst2 = [ 1 ] <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> lst2 . append ( lst2 [ - 1 ] * 2 % ( pop - 1 ) ) <NEWLINE> <DEDENT> lst . reverse ( ) <NEWLINE> num2 = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if x [ i ] == <STRING> : <NEWLINE> <INDENT> num2 += lst2 [ i ] <NEWLINE> num2 %= ( pop - 1 ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> x2 = int ( x , 2 ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if x [ i ] == <STRING> : <NEWLINE> <INDENT> if pop == 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> continue <NEWLINE> <DEDENT> elif pop == 2 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> num = num2 - lst2 [ i ] <NEWLINE> num %= ( pop - 1 ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> num = num1 + lst1 [ i ] <NEWLINE> num %= ( pop + 1 ) <NEWLINE> <DEDENT> count = 1 <NEWLINE> while num : <NEWLINE> <INDENT> num %= bin ( num ) . count ( <STRING> ) <NEWLINE> count += 1 <NEWLINE> <DEDENT> print ( count ) <NEWLINE> <DEDENT>
import sys <NEWLINE> import numpy as np <NEWLINE> import numba <NEWLINE> from numba import njit <NEWLINE> i8 = numba . int64 <NEWLINE> <NL> read = sys . stdin . buffer . read <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> readlines = sys . stdin . buffer . readlines <NEWLINE> <NL> @ njit ( ( i8 , ) , cache = True ) <NEWLINE> def popcount ( n ) : <NEWLINE> <INDENT> ret = 0 <NEWLINE> while n : <NEWLINE> <INDENT> ret += n & 1 <NEWLINE> n >>= 1 <NEWLINE> <DEDENT> return ret <NEWLINE> <NL> <NL> <DEDENT> @ njit ( ( i8 , ) , cache = True ) <NEWLINE> def f ( n ) : <NEWLINE> <INDENT> t = 0 <NEWLINE> while n : <NEWLINE> <INDENT> t += 1 <NEWLINE> n %= popcount ( n ) <NEWLINE> <DEDENT> return t <NEWLINE> <NL> <DEDENT> @ njit ( ( i8 [ : ] , ) , cache = True ) <NEWLINE> def main ( X ) : <NEWLINE> <NL> <INDENT> popX = X . sum ( ) <NEWLINE> MOD1 = popX + 1 <NEWLINE> MOD2 = popX - 1 <NEWLINE> if popX == 1 : <NEWLINE> <INDENT> MOD2 = 1 <NEWLINE> <DEDENT> pow1 = np . ones_like ( X ) <NEWLINE> pow2 = np . ones_like ( X ) <NEWLINE> for n in range ( 1 , len ( X ) ) : <NEWLINE> <INDENT> pow1 [ n ] = 2 * pow1 [ n - 1 ] % MOD1 <NEWLINE> pow2 [ n ] = 2 * pow2 [ n - 1 ] % MOD2 <NEWLINE> <NL> <DEDENT> X1 , X2 = 0 , 0 <NEWLINE> for x in X : <NEWLINE> <INDENT> X1 = ( 2 * X1 + x ) % MOD1 <NEWLINE> X2 = ( 2 * X2 + x ) % MOD2 <NEWLINE> <NL> <DEDENT> ans = np . empty ( N , np . int64 ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> x = X [ N - 1 - i ] <NEWLINE> if x == 0 : <NEWLINE> <INDENT> nxt = ( X1 + pow1 [ i ] ) % ( popX + 1 ) <NEWLINE> ans [ i ] = 1 + f ( nxt ) <NEWLINE> <DEDENT> elif x == 1 : <NEWLINE> <INDENT> if popX == 1 : <NEWLINE> <INDENT> ans [ i ] = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> nxt = ( X2 - pow2 [ i ] ) % ( popX - 1 ) <NEWLINE> ans [ i ] = 1 + f ( nxt ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return ans [ : : - 1 ] <NEWLINE> <NL> <DEDENT> N = int ( readline ( ) ) <NEWLINE> X = np . array ( list ( read ( ) . rstrip ( ) ) , np . int64 ) - ord ( <STRING> ) <NEWLINE> ans = main ( X ) <NEWLINE> print ( <STRING> . join ( map ( str , ans . tolist ( ) ) ) ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> x = input ( ) <NEWLINE> z = <STRING> * n <NEWLINE> o = <STRING> * n <NEWLINE> X = int ( x , 2 ) <NEWLINE> <NL> if ( n = 1 and x == <STRING> ) : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> if ( z == x ) : <NEWLINE> <INDENT> u = n - 1 <NEWLINE> d = n - 1 <NEWLINE> <DEDENT> elif ( o == x ) : <NEWLINE> <INDENT> u = 1 <NEWLINE> d = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> tmp = len ( list ( filter ( lambda x : x == <STRING> , x ) ) ) <NEWLINE> u = tmp + 1 <NEWLINE> d = tmp - 1 <NEWLINE> <NL> <NL> <DEDENT> def popcount ( i ) : <NEWLINE> <INDENT> return i % len ( list ( filter ( lambda x : x == <STRING> , format ( i , <STRING> ) ) ) ) <NEWLINE> <NL> <NL> <DEDENT> def solve ( i , count ) : <NEWLINE> <INDENT> if ( i <= 2 * 10 ** 5 and ans [ i ] != 0 ) : <NEWLINE> <INDENT> return count + ans [ i ] <NEWLINE> <DEDENT> elif ( i == 0 ) : <NEWLINE> <INDENT> return count <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return solve ( popcount ( i ) , count + 1 ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def solve2 ( i , div ) : <NEWLINE> <INDENT> if ( i <= 2 * 10 ** 5 ) : <NEWLINE> <INDENT> return ans [ i ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return ans [ i % div ] + 1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> ans = [ 0 ] * ( 2 * 10 ** 5 + 4 ) <NEWLINE> _u = ( 2 * 10 ** 5 ) // u <NEWLINE> U = X % u + ( u * _u ) + u <NEWLINE> if ( d != 0 ) : <NEWLINE> <INDENT> _d = ( 2 * 10 ** 5 ) // d <NEWLINE> D = X % d + ( d * _d ) * 2 + d * 2 <NEWLINE> <DEDENT> Us = [ 0 ] * ( 2 * 10 ** 5 ) <NEWLINE> Ds = [ 0 ] * ( 2 * 10 ** 5 ) <NEWLINE> for i in range ( 1 , 2 * 10 ** 5 + 4 ) : <NEWLINE> <INDENT> ans [ i ] = solve ( i , 0 ) <NEWLINE> <DEDENT> Us [ 0 ] = 1 % u <NEWLINE> if ( d != 0 ) : <NEWLINE> <INDENT> Ds [ 0 ] = 1 % d <NEWLINE> <DEDENT> for i in range ( 1 , 2 * 10 ** 5 ) : <NEWLINE> <INDENT> Us [ i ] = ( Us [ i - 1 ] * 2 ) % u <NEWLINE> if ( d != 0 ) : <NEWLINE> <INDENT> Ds [ i ] = ( Ds [ i - 1 ] * 2 ) % d <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> if ( x [ i ] == <STRING> ) : <NEWLINE> <INDENT> print ( solve2 ( U + Us [ n - i - 1 ] , u ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if ( d == 0 ) : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( solve2 ( D - Ds [ n - i - 1 ] , d ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
from functools import lru_cache <NEWLINE> <NL> <NL> def popcnt ( x ) : <NEWLINE> <INDENT> return bin ( x ) . count ( <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> @ lru_cache ( maxsize = None ) <NEWLINE> def rec ( n ) : <NEWLINE> <INDENT> if n == 0 : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return rec ( n % popcnt ( n ) ) + 1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> n = int ( input ( ) ) <NEWLINE> x = int ( input ( ) , 2 ) <NEWLINE> <NL> <COMMENT> <NL> cnt = popcnt ( arr ) <NEWLINE> init_big = x % ( cnt + 1 ) <NEWLINE> if cnt == 1 : <NEWLINE> <INDENT> init_small = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> init_small = x % ( cnt - 1 ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> result = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if not ( x >> i ) & 1 : <NEWLINE> <INDENT> result . append ( ( init_big + pow ( 2 , i , cnt + 1 ) ) % ( cnt + 1 ) ) <NEWLINE> <DEDENT> elif arr == 1 << i or cnt - 1 == 0 : <NEWLINE> <INDENT> result . append ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> result . append ( ( init_small - pow ( 2 , i , cnt - 1 ) ) % ( cnt - 1 ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> ans = [ ] <NEWLINE> for x in result [ : : - 1 ] : <NEWLINE> <INDENT> ans . append ( rec ( x ) + 1 ) <NEWLINE> <NL> <DEDENT> print ( * ans , sep = <STRING> ) <NEWLINE>
t = int ( input ( ) ) <NEWLINE> import heapq <NEWLINE> for _ in range ( t ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> L = [ ] ; R = [ ] <NEWLINE> ans = 0 <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> ki , li , ri = map ( int , input ( ) . split ( ) ) <NEWLINE> dif = li - ri <NEWLINE> if dif >= 0 : <NEWLINE> <INDENT> L . append ( ( ki - 1 , dif ) ) <NEWLINE> ans += ri <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> R . append ( ( n - ki - 1 , - dif ) ) <NEWLINE> ans += li <NEWLINE> <DEDENT> <DEDENT> L . sort ( ) ; R . sort ( ) <NEWLINE> hL = [ ] <NEWLINE> hR = [ ] <NEWLINE> for i in range ( len ( L ) ) : <NEWLINE> <INDENT> if L [ i ] [ 0 ] >= len ( hL ) : <NEWLINE> <INDENT> heapq . heappush ( hL , L [ i ] [ 1 ] ) <NEWLINE> <DEDENT> elif L [ i ] [ 0 ] = len ( hL ) - 1 : <NEWLINE> <INDENT> heapq . heappushpop ( hL , L [ i ] [ 1 ] ) <NEWLINE> <DEDENT> <DEDENT> for i in range ( len ( R ) ) : <NEWLINE> <INDENT> if R [ i ] [ 0 ] >= len ( hR ) : <NEWLINE> <INDENT> heapq . heappush ( hR , R [ i ] [ 1 ] ) <NEWLINE> <DEDENT> elif R [ i ] [ 0 ] == len ( hR ) - 1 : <NEWLINE> <INDENT> heapq . heappushpop ( hR , R [ i ] [ 1 ] ) <NEWLINE> <DEDENT> <DEDENT> print ( ans + sum ( hL ) + sum ( hR ) ) <NEWLINE> <NL> <DEDENT>
import heapq as hp <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> t = int ( input ( ) ) <NEWLINE> for i in range ( t ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> <COMMENT> <NL> lef = [ [ ] for i in range ( n + 1 ) ] <NEWLINE> rig = [ [ ] for i in range ( n + 1 ) ] <NEWLINE> a = [ ] <NEWLINE> hp . heapify ( a ) <NEWLINE> ans = 0 <NEWLINE> lefcnt = 0 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> k , l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> if ( l >= r ) : <NEWLINE> <INDENT> ans += r <NEWLINE> lefcnt += 1 <NEWLINE> tmp = l - r <NEWLINE> lef [ k ] . append ( tmp ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += l <NEWLINE> tmp = r - l <NEWLINE> rig [ n - k ] . append ( tmp ) <NEWLINE> <DEDENT> <DEDENT> for i in range ( lefcnt , 0 , - 1 ) : <NEWLINE> <INDENT> for j in lef [ i ] : <NEWLINE> <INDENT> hp . heappush ( a , - j ) <NEWLINE> <DEDENT> if ( a ) : <NEWLINE> <INDENT> tmp = hp . heappop ( a ) * ( - 1 ) <NEWLINE> ans += tmp <NEWLINE> <NL> <DEDENT> <DEDENT> a = [ ] <NEWLINE> hp . heapify ( a ) <NEWLINE> for i in range ( n - lencnt , 0 , - 1 ) : <NEWLINE> <INDENT> for j in rig [ i ] : <NEWLINE> <INDENT> hp . heappush ( a , - j ) <NEWLINE> <DEDENT> if ( a ) : <NEWLINE> <INDENT> tmp = hp . heappop ( a ) * ( - 1 ) <NEWLINE> ans += tmp <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> print ( str ( math . ceil ( N ) - ( N ) ) ) <NEWLINE>
N = int ( input ) <NEWLINE> a = 1000 - N <NEWLINE> print ( a ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> if ( n % 1000 == 0 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> n_str = str ( n ) <NEWLINE> <INDENT> g = n_str [ 0 ] <NEWLINE> print ( ( n + 1 ) * 1000 - n ) <NEWLINE> <DEDENT> <DEDENT>
N = input ( ) <NEWLINE> A = 0 if N % 1000 == 0 else 1000 - N % 1000 <NEWLINE> print ( A ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> if 0 <= N <= 1000 : <NEWLINE> <INDENT> print ( 1000 - N ) <NEWLINE> <DEDENT> elif 1001 <= N <= 2000 : <NEWLINE> <INDENT> print ( 2000 - N ) <NEWLINE> <DEDENT> elif 2001 <= N <= 3000 : <NEWLINE> <INDENT> print ( 3000 - N ) <NEWLINE> <DEDENT> elif 3001 <= N <= 4000 : <NEWLINE> <INDENT> print ( 4000 - N ) <NEWLINE> <DEDENT> elif 4001 <= N <= 5000 : <NEWLINE> <INDENT> print ( 5000 - N ) <NEWLINE> <DEDENT> elif 5001 <= N <= 6000 : <NEWLINE> <INDENT> print ( 6000 - N ) <NEWLINE> <DEDENT> elif 6001 <= N <= 7000 <NEWLINE> <INDENT> print ( 7000 - N ) <NEWLINE> <DEDENT> elif 7001 <= N <= 8000 : <NEWLINE> <INDENT> print ( 8000 - N ) <NEWLINE> <DEDENT> elif 8001 <= N <= 9000 : <NEWLINE> <INDENT> print ( 9000 - N ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 10000 - N ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> print ( n - ( n % 1000 ) ) % 1000 <NEWLINE>
n = int ( input ( ) ) <NEWLINE> if n % 1000 == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 2000 - int ( <STRING> + str ( n [ : - 3 ] ) ) ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> <NL> if n % 1000 == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> tmp = n // 1000 + 1 <NEWLINE> print ( tmp - n ) <NEWLINE> <DEDENT>
import math <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> if N % 1000 == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> elif N < 1000 : <NEWLINE> <INDENT> N = 1000 - N <NEWLINE> print ( N ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> N = ( math . ceil ( money / 1000 ) ) * 1000 - N <NEWLINE> print ( N ) <NEWLINE> <NL> <DEDENT>
from collections import deque , defaultdict , Counter <NEWLINE> from math import floor , ceil , sqrt , hypot , factorial , pi , sin , cos , radians <NEWLINE> from itertools import accumulate , permutations , combinations , product <NEWLINE> from operator import itemgetter , mul <NEWLINE> from copy import deepcopy <NEWLINE> from string import ascii_lowercase , ascii_uppercase , digits <NEWLINE> from bisect import bisect , bisect_left <NEWLINE> from fractions import gcd <NEWLINE> from heapq import heappush , heappop <NEWLINE> from functools import reduce <NEWLINE> def input ( ) : return sys . stdin . readline ( ) . strip ( ) <NEWLINE> def INT ( ) : return int ( input ( ) ) <NEWLINE> def MAP ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def LIST ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> def ZIP ( n ) : return zip ( * ( MAP ( ) for _ in range ( n ) ) ) <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> INF = float ( <STRING> ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> N = INT ( ) <NEWLINE> a = N % 1000 <NEWLINE> if 0 <= N < 1000 : <NEWLINE> <INDENT> print ( N ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT>
if N % 1000 = 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> else : <NEWLINE> <INDENT> print ( 1000 - N % 1000 ) <NEWLINE> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> if N % 1000 = 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 1000 - ( N % 1000 ) ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> result = n % 1000 <NEWLINE> <NL> pirnt ( result ) <NEWLINE>
<NL> taka = input ( ) <NEWLINE> remainder = taka % 1000 <NEWLINE> ans = 1000 - remainder <NEWLINE>
n = int ( input ( ) ) <NEWLINE> if n % 1000 = 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 1000 - n % 1000 ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> <NL> if n % 1000 == 0 : <NEWLINE> <INDENT> return n // 1000 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return 1000 - n % 1000 <NEWLINE> <DEDENT>
import math <NEWLINE> def main ( ) : <NEWLINE> <INDENT> with open ( <STRING> , <STRING> ) as r : <NEWLINE> <INDENT> args = list ( r . readlines ( ) ) <NEWLINE> <DEDENT> N = int ( args [ 0 ] ) <NEWLINE> use = math . ceil ( N / 1000 ) <NEWLINE> print ( 1000 * use - N ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
a = int ( input ( ) ) <NEWLINE> b = 0 <NEWLINE> while b = < a : <NEWLINE> <INDENT> b += 1000 <NEWLINE> <DEDENT> print ( b - a ) <NEWLINE>
import sys <NEWLINE> from functools import lru_cache , cmp_to_key <NEWLINE> from heapq import merge , heapify , heappop , heappush <NEWLINE> from math import * <NEWLINE> from collections import defaultdict as dd , deque , Counter as C <NEWLINE> from itertools import combinations as comb , permutations as perm <NEWLINE> from bisect import bisect_left as bl , bisect_right as br , bisect <NEWLINE> from time import perf_counter <NEWLINE> from fractions import Fraction <NEWLINE> <COMMENT> <NL> sys . setrecursionlimit ( int ( pow ( 10 , 6 ) ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> mod = int ( pow ( 10 , 9 ) + 7 ) <NEWLINE> mod2 = 998244353 <NEWLINE> def data ( ) : return sys . stdin . readline ( ) . strip ( ) <NEWLINE> def out ( * var , end = <STRING> ) : sys . stdout . write ( <STRING> . join ( map ( str , var ) ) + end ) <NEWLINE> def L ( ) : return list ( sp ( ) ) <NEWLINE> def sl ( ) : return list ( ssp ( ) ) <NEWLINE> def sp ( ) : return map ( int , data ( ) . split ( ) ) <NEWLINE> def ssp ( ) : return map ( str , data ( ) . split ( ) ) <NEWLINE> def l1d ( n , val = 0 ) : return [ val for i in range ( n ) ] <NEWLINE> def l2d ( n , m , val = 0 ) : return [ l1d ( n , val ) for j in range ( m ) ] <NEWLINE> <NL> <COMMENT> <NL> <NL> t = 1 <NEWLINE> <COMMENT> <NL> for _ in range ( t ) : <NEWLINE> <INDENT> n = L ( ) [ 0 ] <NEWLINE> print ( 1000 - N % 1000 ) <NEWLINE> <DEDENT>
n = 1000 <NEWLINE> while N > n : <NEWLINE> <INDENT> n = + 1000 <NEWLINE> <DEDENT> print ( N - n ) <NEWLINE>
N = int ( iput ( ) ) <NEWLINE> print ( N % 1000 ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = 0 if N % 1000 == 0 else A = 1000 - N % 1000 <NEWLINE> print ( A ) <NEWLINE>
input_line = input ( ) <NEWLINE> a = input_line % 1000 <NEWLINE> if a == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 1000 - a ) <NEWLINE> <DEDENT>
n = 1 <NEWLINE> turi = 1000 * n <NEWLINE> <NL> while N < 1000 * n : <NEWLINE> <INDENT> if N < 1000 * n : <NEWLINE> <INDENT> return turi = 1000 * n - N <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> n += 1 <NEWLINE> <DEDENT> <DEDENT>
N = int <NEWLINE> a = ( N / 1000 - int ( N / 1000 ) ) * 1000 <NEWLINE> print ( a ) <NEWLINE>
a = input ( ) <NEWLINE> b = int ( a ) <NEWLINE> c = b % 1000 <NEWLINE> if c = 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> else print ( c ) <NEWLINE> <DEDENT>
money = input ( ) <NEWLINE> <NL> oturi = 1000 - money % 1000 <NEWLINE> <NL> print ( oturi ) <NEWLINE>
import sys <NEWLINE> <NL> N = sys . args [ 1 ] <NEWLINE> <NL> for i in range ( 10 ) : <NEWLINE> <INDENT> if 1000 * i >= N : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> return 1000 * i - N <NEWLINE>
for i in range ( 10 ) : <NEWLINE> <INDENT> if N > 1000 : <NEWLINE> <INDENT> N -= 1000 <NEWLINE> <DEDENT> if N < 1000 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( 1000 - N ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> a = 1000 - N % 1000 <NEWLINE> if a = 1000 : <NEWLINE> <INDENT> a = 0 <NEWLINE> <DEDENT> print ( a ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> if N % 1000 == 0 : <NEWLINE> print ( 0 ) <NEWLINE> else <NEWLINE> print ( N % 1000 ) <NEWLINE>
N = input ( ) <NEWLINE> remainder = N % 1000 <NEWLINE> if remainder == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 1000 - remainder ) <NEWLINE> <DEDENT>
<INDENT> N = int ( input ( ) ) <NEWLINE> print ( 1000 - ( N % 1000 ) ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> print ( print ( 0 if n % 1000 == 0 else 1000 * ( ( n // 1000 ) + 1 ) - n ) <NEWLINE>
N = input ( ) <NEWLINE> turi = N % 1000 <NEWLINE> if turi != 0 : <NEWLINE> <INDENT> turi = 1000 - turi <NEWLINE> <DEDENT> print ( turi ) <NEWLINE>
print ( ( 1000 - ( int ( input ) % 1000 ) ) % 1000 ) <NEWLINE>
<NL> N = input ( ) <NEWLINE> if N % 1000 == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <INDENT> sen = N // 1000 <NEWLINE> <COMMENT> <NL> sen2 = sen * 1000 <NEWLINE> <COMMENT> <NL> atai = N - sen2 <NEWLINE> <COMMENT> <NL> print ( atai ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> N = input ( ) <NEWLINE> return N % 1000 <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
print ( abs ( - ( N % 1000 ) ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> print ( 1000 - ( input % 1000 ) ) <NEWLINE>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> N = input ( ) <NEWLINE> <NL> print ( 1000 - N % 1000 ) <NEWLINE>
def N ( n ) : <NEWLINE> <INDENT> if n % 1000 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif n % 1000 != 0 : <NEWLINE> <INDENT> return n % 1000 <NEWLINE> <DEDENT> <DEDENT> N ( n ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> x = int ( input ( ) ) <NEWLINE> <INDENT> y = x % 1000 <NEWLINE> return y <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> print ( ( n // 1000 + 1 ) * 1000 - n ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> if ( N % 1000 == 0 ) : <NEWLINE> <INDENT> m = ( int ( N / 1000 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> m = ( int ( N / 1000 ) <NEWLINE> <DEDENT> change = 1000 * m - N <NEWLINE> print ( change ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> print ( a = n // 1000 ) <NEWLINE>
N = input ( ) <NEWLINE> otsuri = N % 1000 <NEWLINE> if otsuri > 0 <NEWLINE> <INDENT> orsuri = 1000 - otsuri <NEWLINE> <DEDENT> print ( otsuri ) <NEWLINE>
print ( int ( input ( ) % 1000 ) <NEWLINE>
n = input ( ) <NEWLINE> <COMMENT> <NL> print ( 1000 - ( n % 1000 ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> x = int ( input ( ) ) <NEWLINE> print ( 1000 * x - n ) <NEWLINE>
money = int ( input ( ) ) <NEWLINE> if ( ceil ( money / 1000.0 ) == floor ( money / 1000.0 ) ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif ( ceil ( money / 1000.0 ) > floor ( money / 1000.0 ) ) : <NEWLINE> <INDENT> print ( money % 1000 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 1000 - ( money % 1000 ) ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> print ( n - ( - n // 1000 ) * 1000 <NEWLINE>
N = input ( ) <NEWLINE> N = N % 1000 <NEWLINE> ans = 1000 - N if not N else 0 <NEWLINE> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> print ( 1000 - N % 1000 if N % 1000 != 0 else 0 ) a <NEWLINE>
N = int ( input ( ) ) <NEWLINE> minn = 1000 <NEWLINE> if N < 1 or N > 10000 <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif N % 1000 == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( 1000 , 10001 , 1000 ) : <NEWLINE> <INDENT> if N < i : <NEWLINE> <INDENT> print ( i - N ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> ans = ( 10000 - n ) % 1000 <NEWLINE> <NL> print ( ans <NEWLINE>
N = int ( input ( ) ) <NEWLINE> <NL> if N % 1000 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif : <NEWLINE> <INDENT> print ( ( 1000 - ( N % 1000 ) ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> <NL> x %= 1000 <NEWLINE> <NL> Otsuri = 1000 - x <NEWLINE> <NL> print ( Otsuri ) <NEWLINE>
x = int ( input ( <STRING> ) ) <NEWLINE> if x % 1000 = 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 1000 - x % 1000 ) <NEWLINE> <DEDENT>
a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> l = sorted ( [ a , b , c ] ) <NEWLINE> <NL> s = sum ( l [ : 2 ] ) <NEWLINE> print ( s ) <NEWLINE>
int a = input ( ) <NEWLINE> print ( ( 1000 - ( a % 1000 ) ) % 1000 ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> if n % 1000 == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> elif : <NEWLINE> <INDENT> print ( 1000 - n % 1000 ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> for i in range ( 11 ) : <NEWLINE> <INDENT> x = i * 1000 <NEWLINE> if x = > n : <NEWLINE> <INDENT> print ( x - n ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT>
print ( ( 1000 - input ( ) % 1000 ) % 1000 ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> if n % 1000 == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <NL> <DEDENT> else <NEWLINE> <INDENT> print ( 1000 - n % 1000 ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> <NL> if n % 1000 == 0 : <NEWLINE> <INDENT> a = n / 1000 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> int ( a ) = n / 1000 + 1 <NEWLINE> <NL> <DEDENT> b = a * 1000 <NEWLINE> answer = int ( b - n ) <NEWLINE> <NL> print ( answer ) <NEWLINE>
print ( 1000 - int ( input ( ) ) % 1000 ) % 1000 <NEWLINE>
cost = input ( ) [ 0 ] <NEWLINE> dvi , mod = dvimod ( int ( cost ) , 1000 ) <NEWLINE> bills = dvi + 1 <NEWLINE> change = bills - mod <NEWLINE> print ( change ) <NEWLINE>
def = input ( N ) <NEWLINE> while N < 1000 : <NEWLINE> <INDENT> N -= 1000 <NEWLINE> <DEDENT> return N <NEWLINE>
<NL> N = int ( input ( ) ) <NEWLINE> if N % 1000 == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE>
n = int ( input ( ) ) <NEWLINE> rem = n % 1000 <NEWLINE> if rem != 0 : <NEWLINE> <INDENT> return 1000 - rem <NEWLINE> <DEDENT> return 0 <NEWLINE>
N = input ( ) <NEWLINE> answer = N % 1000 <NEWLINE> print ( answer ) <NEWLINE>
int ( input ( n ) ) <NEWLINE> print ( n % 1000 ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> otsuri = 1000 - ( n % 1000 ) <NEWLINE> if otsuri == 1000 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( osturi ) <NEWLINE> <DEDENT>
input1 = input ( ) <NEWLINE> result = 1000 - int ( input1 ) % 1000 <NEWLINE> if result == 1000 : <NEWLINE> <INDENT> print 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> result <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> <NL> if N % 1000 == 0 : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> elif : <NEWLINE> <INDENT> ans = N % 1000 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
<NL> n = int ( input ( ) ) <NEWLINE> if n % 1000 == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = math . ceil ( n / 1000 ) <NEWLINE> ans = int ( x * 1000 ) - n <NEWLINE> print ( ans ) <NEWLINE> <NL> <DEDENT>
n = input ( ) <NEWLINE> n = n [ - 3 : ] <NEWLINE> if n == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( str ( 1000 - int ( n ) ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> n = N % 1000 <NEWLINE> if n == 0 ; <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else ; <NEWLINE> <INDENT> print ( 1000 - n ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> res = n % 1000 <NEWLINE> if res : <NEWLINE> <INDENT> return 1000 - res <NEWLINE> <DEDENT> return 0 <NEWLINE>
n = input ( ) <NEWLINE> n = 1000 - n <NEWLINE> while n < 0 : <NEWLINE> <INDENT> n += 1000 <NEWLINE> <DEDENT> print ( n ) <NEWLINE>
x = ( 1000 - N % 1000 ) % 1000 <NEWLINE> <NL> print ( x ) <NEWLINE>
v <NEWLINE>
a = input ( ) . rstrip ( ) <NEWLINE> ans = a % 1000 <NEWLINE> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> x = 0 <NEWLINE> <NL> whlie True : <NEWLINE> <INDENT> if n % 1000 == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> n += 1 <NEWLINE> x += 1 <NEWLINE> <NL> <DEDENT> print ( x ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = 0 <NEWLINE> for i in range ( 0 , 10 ) : <NEWLINE> <INDENT> i = i + 1 <NEWLINE> A = i + <STRING> <NEWLINE> if N <= A : <NEWLINE> <INDENT> print ( A - N ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT>
a = int ( input ( ) ) % 1000 <NEWLINE> if a = 0 : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 1000 - a ) <NEWLINE> <NL> <DEDENT>
n = int ( input ( ) ) <NEWLINE> <NL> if n % 1000 = 0 : <NEWLINE> <INDENT> print ( n / 1000 ) <NEWLINE> <DEDENT> else <NEWLINE> <INDENT> print ( n / 1000 + 1 ) <NEWLINE> <NL> <DEDENT>
N = int ( input ( ) ) <NEWLINE> if N % 1000 == 0 ; <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else ; <NEWLINE> <INDENT> print ( 1000 * ( N // 1000 + 1 ) - N ) <NEWLINE> <DEDENT>
x = input ( ) <NEWLINE> if x % 1000 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else <NEWLINE> <INDENT> x = 1000 - x <NEWLINE> print ( <STRING> ) <NEWLINE> <DEDENT>
price = int ( input ( ) ) <NEWLINE> <NL> comma_price = math . ceil ( price / 1000 ) <NEWLINE> comma_price *= comma_price <NEWLINE> <NL> print ( comma_price - price ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> satu = n // 1000 <NEWLINE> if n n % 1000 == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> quit ( ) <NEWLINE> <DEDENT> ans = 1000 * ( satu + 1 ) - n <NEWLINE> print ( ans ) <NEWLINE>
N = input ( ) <NEWLINE> <NL> print ( N % 1000 ) <NEWLINE>
a = int ( input ( ) ) <NEWLINE> if a = < 1000 : <NEWLINE> <INDENT> b = a // 1000 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> b = a // 1000 + 1 <NEWLINE> <DEDENT> print ( b * 1000 - a ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> print ( 1000 * math . ceil ( N / 1000 ) - N ) <NEWLINE>
N = input ( ) <NEWLINE> if len ( N ) > 3 : <NEWLINE> <INDENT> i = ( int ( N [ : - 3 ] ) + 1 ) * 1000 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> i = N <NEWLINE> <NL> <DEDENT> j = i - int ( N ) <NEWLINE> <NL> elif j > 999 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( j ) <NEWLINE> <DEDENT>
a = input ( ) <NEWLINE> <NL> <NL> amari = a % 1000 <NEWLINE> otsuri = 1000 - amari <NEWLINE> print ( otsuri ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> print ( ( 10000 - n ) % 1000 ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> if k % 1000 == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <NL> <INDENT> k = int ( N / 1000 ) + 1 <NEWLINE> <INDENT> print ( 1000 * k - N ) <NEWLINE> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> thousand = 1000 * M <NEWLINE> thousand - N < 1000 <NEWLINE> print ( M ) <NEWLINE>
a = input ( ) <NEWLINE> <NL> mod = a % 1000 <NEWLINE> <NL> b = mod - 1000 <NEWLINE> <NL> c = abs ( b ) <NEWLINE> <NL> print ( c ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> if n >= 1000 : <NEWLINE> <INDENT> n = int ( str ( n [ 1 : ] ) ) <NEWLINE> <NL> <DEDENT> if n > 0 : <NEWLINE> <INDENT> ans = 1000 - n <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
print ( int ( input ( ) % 1000 ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> b = N % 1000 <NEWLINE> if b = 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 1000 - b ) <NEWLINE> <DEDENT>
in = int ( input ( ) ) <NEWLINE> print ( int ( in % 1000 ) ) <NEWLINE>
<INDENT> m = int ( input ( ) ) <NEWLINE> while m > 1000 : <NEWLINE> <INDENT> m -= 1000 <NEWLINE> <DEDENT> print ( 1000 - m ) <NEWLINE> <DEDENT>
mai = n // 1000 <NEWLINE> mai += 1 <NEWLINE> if mai * 1000 - n == 1000 : <NEWLINE> <INDENT> print ( ( mai - 1 ) * 1000 - n ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( mai * 1000 - n ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> <NL> a = N // 1000 <NEWLINE> <NL> if 1000 * a != N : <NEWLINE> print ( 1000 * ( a + 1 ) - N ) <NEWLINE> <NL> else : <NEWLINE> print ( 0 ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> if n % 1000 != 0 : <NEWLINE> <INDENT> print ( min ( 1000 - ( n % 1000 ) ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
x = int ( input ( ) ) <NEWLINE> x = 1000 - x % 1000 <NEWLINE> if ( x == 1000 ) : <NEWLINE> <INDENT> x = 0 <NEWLINE> <DEDENT> return ( x ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> if ( n % 1000 == 0 ) : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ( math . ceil ( n / 1000 ) * 1000 ) - n ) <NEWLINE> <DEDENT>
N = input ( ) <NEWLINE> <NL> while N > 0 : <NEWLINE> <INDENT> OTURI = 1000 - N <NEWLINE> N -= 1000 <NEWLINE> <NL> <DEDENT> print ( OTURI ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> n = int ( input ( ) ) <NEWLINE> <COMMENT> <NL> s = [ input ( ) for i in range ( n ) ] <NEWLINE> <COMMENT> <NL> C0 = s . count ( <STRING> ) <NEWLINE> C1 = s . count ( <STRING> ) <NEWLINE> C2 = s . count ( <STRING> ) <NEWLINE> C3 = s . count ( <STRING> ) <NEWLINE> <COMMENT> <NL> print ( <STRING> . format ( C0 ) ) <NEWLINE> print ( <STRING> . format ( C1 ) ) <NEWLINE> print ( <STRING> . format ( C2 ) ) <NEWLINE> print ( <STRING> . format ( C3 ) ) <NEWLINE>
N = input ( ) <NEWLINE> final = 1000 - N % 1000 <NEWLINE> if final == 1000 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( final ) <NEWLINE> <DEDENT>
N = input ( ) <NEWLINE> <NL> print ( 1000 - N % 1000 ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> print ( ( ( n + 999 ) // 1000 ) * 1000 - N ) <NEWLINE>
n = int ( stdin . readline ( ) . rstrip ( ) ) <NEWLINE> ans = 1000 - n % 1000 <NEWLINE> if ans == 1000 : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
N = map ( int , input ( ) ) <NEWLINE> x = 0 <NEWLINE> while x < N : <NEWLINE> <INDENT> x = x + 1000 <NEWLINE> <DEDENT> print ( x - N ) <NEWLINE>
N = input ( ) <NEWLINE> R = N % 1000 <NEWLINE> if R == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( abs ( R - 1000 ) ) <NEWLINE> <DEDENT>
import math <NEWLINE> import tensorflow as tf <NEWLINE> N = int ( input ( ) ) <COMMENT> <NEWLINE> <NL> number_of_bills = N / 1000 <NEWLINE> change = number_of_bills * 1000 - N <NEWLINE> if change < 0 : <NEWLINE> <INDENT> change += 1000 <NEWLINE> <DEDENT> print ( str ( int ( change ) ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> rest = N // 1000 <NEWLINE> return 1000 - rest <NEWLINE>
print ( - int ( input ( ) % 1000 ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> a = N // 1000 <NEWLINE> if N % 1000 = 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 1000 * ( a + 1 ) - N ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> k = 1000 <NEWLINE> for i in range ( 1 , 10001 ) : <NEWLINE> <INDENT> if n > k : <NEWLINE> <INDENT> k = k * i <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> prinr ( k - n ) <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT>
a = int ( input ( ) ) % 1000 <NEWLINE> if a = 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 1000 - a ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> <NL> a = n % 1000 <NEWLINE> b = 1000 - a <NEWLINE> if b = 1000 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( b ) <NEWLINE> <DEDENT>
s = int ( input ( ) ) <NEWLINE> change = s % 1000 <NEWLINE> if change == 0 : <NEWLINE> <INDENT> print ( 0 ) : <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 1000 - change ) <NEWLINE> <DEDENT>
<COMMENT> <NL> n = int ( input ( ) ) <NEWLINE> n = str ( n ) <NEWLINE> if len ( n ) = > 3 : <NEWLINE> <INDENT> p = n [ - 3 ] + n [ - 2 ] + n [ - 1 ] <NEWLINE> <DEDENT> if len ( n ) == 2 : <NEWLINE> <INDENT> p = n [ - 2 ] + n [ - 1 ] <NEWLINE> <DEDENT> if len ( n ) == 1 : <NEWLINE> <INDENT> p = n [ - 1 ] <NEWLINE> <DEDENT> print ( int ( p ) ) <NEWLINE>
N = input ( ) <NEWLINE> o = 1000 - ( N % 1000 ) <NEWLINE> print ( o ) <NEWLINE>
n = input ( ) <NEWLINE> t = len ( n ) <NEWLINE> if t < 4 : <NEWLINE> <INDENT> print ( 1000 - int ( n ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> k , p = int ( n [ 0 ] ) , int ( n [ 1 ] ) <NEWLINE> if p != 0 : <NEWLINE> <INDENT> print ( ( k + 1 ) * 1000 - int ( n ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 <NEWLINE> <DEDENT> <DEDENT>
n = input ( ) <NEWLINE> a = n % 1000 <NEWLINE> a = 1000 - a <NEWLINE> print ( a ) <NEWLINE>
import sys <NEWLINE> from operator import itemgetter <NEWLINE> <NL> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> def ii ( ) : return int ( input ( ) ) <NEWLINE> def mi ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def lmi ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> def lmif ( n ) : return [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ] <NEWLINE> def ss ( ) : return input ( ) . split ( ) <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> n = ii <NEWLINE> ans = 1000 - n % 1000 <NEWLINE> print ( ans ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE>
<NL> def f ( y ) : <NEWLINE> <NL> <INDENT> if 1 <= y <= 999 : <NEWLINE> <INDENT> print ( 1000 - y ) <NEWLINE> <DEDENT> elif 1000 <= y <= 10000 : <NEWLINE> <INDENT> b = int ( y / 100 ) <NEWLINE> c = int ( str ( b ) [ 1 ] ) <NEWLINE> g = 9 - c <NEWLINE> h = int ( y / 10 ) <NEWLINE> i = int ( str ( h ) [ 2 ] ) <NEWLINE> <NL> if y % 1000 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif y % 500 == 0 and x % 1000 != 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif y % 100 == 0 and x % 500 != 0 : <NEWLINE> <INDENT> f = 10 - c <NEWLINE> print ( f * 100 ) <NEWLINE> <DEDENT> elif y % 10 == 0 and x % 100 != 0 : <NEWLINE> <INDENT> j = 10 - i <NEWLINE> print ( g * 100 + j * 10 ) <NEWLINE> <DEDENT> elif y % 10 != 0 : <NEWLINE> <INDENT> k = int ( str ( y ) [ 3 ] ) <NEWLINE> l = 9 - i <NEWLINE> m = 10 - k <NEWLINE> print ( g * 100 + l * 10 + m ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> y = input ( ) <NEWLINE> x = f ( int ( y ) ) <NEWLINE> <NL> <NL> <NL> <NL>
money = int ( input ( ) ) <NEWLINE> while money > 1000 <NEWLINE> <INDENT> money -= 1000 <NEWLINE> <DEDENT> print ( 1000 - money ) <NEWLINE>
N = input ( ) <NEWLINE> <NL> if N < 1000 : <NEWLINE> <INDENT> out = 1000 - N <NEWLINE> <DEDENT> elif N % 1000 < 500 : <NEWLINE> <INDENT> out = N % 1000 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> out = 1000 - N % 1000 <NEWLINE> <NL> <DEDENT> print ( out ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> <NL> if N % 1000 = 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 1000 - ( N % 1000 ) ) <NEWLINE> <DEDENT>
N = 0 <NEWLINE> try : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> if N == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ( ( N - 1 ) / 1000 ) + 1 ) * 1000 - N ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> pay == ( N % 1000 ) <NEWLINE> if ( pay = 0 ) : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 1000 - pay ) <NEWLINE> <DEDENT>
n = input ( ) <NEWLINE> for i in range ( 11 ) : <NEWLINE> <INDENT> if 1000 * i >= n : <NEWLINE> <INDENT> print ( n - 1000 * i ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> cnt = 1000 <NEWLINE> <NL> while true : <NEWLINE> <INDENT> if cnt > N : <NEWLINE> <INDENT> print ( N - cnt ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cnt += 1000 <NEWLINE> <DEDENT> <DEDENT> break <NEWLINE>
N = int ( input ( ) ) <NEWLINE> a = 0 <NEWLINE> if N < 1000 : <NEWLINE> <INDENT> print ( N ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> while 1 : <NEWLINE> <INDENT> if a * 1000 - N >= 0 : <NEWLINE> <INDENT> prit ( a * 1000 - N ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
n = input ( ) <NEWLINE> x = n // 1000 <NEWLINE> print ( n - x * 1000 ) <NEWLINE>
n = int ( input ( ) ) % 1000 <NEWLINE> print ( n is 0 0 else 1000 - n ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> maisu = math . floor ( ( n + 1000 - 1 ) / 1000 ) <NEWLINE> val = maisu * 1000 - n <NEWLINE> <NL> print ( val ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> for i in range ( 10 ) + 1 : <NEWLINE> <INDENT> if n < i * 1000 : <NEWLINE> <INDENT> print ( i * 1000 - n ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT>
n = input ( ) <NEWLINE> print ( ( 1000 - n % 1000 ) % 1000 ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> if ( N % 1000 ) != 0 : <NEWLINE> <INDENT> ans = 1000 - N % 1000 <NEWLINE> <DEDENT> elif : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> if n % 1000 == 0 : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> return 1000 - ( n % 1000 ) <NEWLINE>
N = input ( ) <NEWLINE> print ( ( 10000 - N ) % 1000 ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> return N % 1000 <NEWLINE>
<NL> <COMMENT> <NL> <NL> using namespace std ; <NEWLINE> typedef long long int ll ; <NEWLINE> <NL> int main ( ) { <NEWLINE> <INDENT> ios : : sync_with_stdio ( 0 ) ; <NEWLINE> cin . tie ( 0 ) ; <NEWLINE> <NL> <DEDENT> ll n ; <NEWLINE> cin >> n ; <NEWLINE> <NL> n = n % 1000 ; <NEWLINE> if ( n > 0 ) n = 1000 - n ; <NEWLINE> cout << n ; <NEWLINE> <NL> <NL> <NL> } <NEWLINE>
n = int ( input ( ) ) <NEWLINE> print ( n - ( math . floor ( n - 1 / 1000 ) + 1 ) * 1000 ) <NEWLINE>
n = input ( ) <NEWLINE> print ( 999 - ( ( n - 1 ) % 1000 ) ) <NEWLINE>
a = int ( input ( ) ) <NEWLINE> b = a % 1000 <NEWLINE> if b == 0 : c = 0 <NEWLINE> else : c = 1000 - b n <NEWLINE> print ( str ( c ) ) <NEWLINE>
N = int ( Input ( ) ) <NEWLINE> print ( N % 1000 ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> print ( ( n // 1000 ) + 1 ) * 1000 - n ) <NEWLINE>
n = input ( ) <NEWLINE> a , b = divmod ( n , 1000 ) <NEWLINE> print ( b ) <NEWLINE>
n = input ( ) <NEWLINE> l = [ 1000 , 2000 , 3000 , 4000 , 5000 , 6000 , 7000 , 8000 , 9000 , 10000 ] <NEWLINE> for i in l : <NEWLINE> <INDENT> if n <= i : <NEWLINE> <INDENT> r = i <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> result = r - n <NEWLINE> print ( result ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = 1000 <NEWLINE> while a < n : <NEWLINE> <INDENT> a = a + 1000 <NEWLINE> print ( a - n ) <NEWLINE> <DEDENT>
N = int . input ( ) <NEWLINE> if N % 1000 == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 1000 - ( N % 1000 ) ) <NEWLINE> <NL> <DEDENT>
N = int ( input ( ) ) <NEWLINE> <NL> for i in 11 : <NEWLINE> <INDENT> x = 1000 * i - N <NEWLINE> if x < 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> exit ( ) <NEWLINE> <DEDENT> <DEDENT> ans = x % 1000 <NEWLINE> print ( ans ) <NEWLINE>
N = input ( ) <NEWLINE> remainder = N % 1000 <NEWLINE> print ( remainder ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> if 1000 - N % 1000 > 0 : <NEWLINE> <INDENT> print ( 1000 - N % 1000 ) <NEWLINE> <DEDENT> else print ( 0 ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> x = N / 1000 <NEWLINE> if N / 1000 %= 0 : <NEWLINE> <INDENT> x = int ( x ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = int ( x ) + 1 <NEWLINE> <DEDENT> y = 1000 * x <NEWLINE> print ( y - N ) <NEWLINE>
<COMMENT> <NL> import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> print ( input % 1000 ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = 10000 - N <NEWLINE> while True == True : <NEWLINE> <INDENT> A = A - 1000 <NEWLINE> <INDENT> if A < 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( A + 1000 ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> if n % 10 ** 3 != 0 : <NEWLINE> <INDENT> return 1000 - n % 10 ** 3 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT>
n = eval ( input ( ) ) <NEWLINE> t = ( n // 1000 ) + 1 <NEWLINE> f = 1000 * t - n <NEWLINE> pring ( f ) <NEWLINE>
a = 0 <NEWLINE> while N >= 1000 : <NEWLINE> <INDENT> N = N - 1000 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a += N <NEWLINE> <DEDENT> print ( a ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> print ( ( 1000 - n % 1000 ) % 1000 ) ) <NEWLINE>
n = input ( ) <NEWLINE> a = n % 1000 <NEWLINE> if a == 1000 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> print ( 0 if a % 1000 == 0 else 1000 - a % 1000 ) <NEWLINE>
N = int ( open ( 0 ) . read ( ) ) <NEWLINE> m = N % 1000 <NEWLINE> if m == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 1000 - m ) <NEWLINE> <DEDENT> | <NEWLINE>
n = int ( input ( ) ) <NEWLINE> for i in range ( 1000 , 10001 , 1000 ) : <NEWLINE> <INDENT> num = i - n <NEWLINE> if num >= 0 : <NEWLINE> <INDENT> print ( num ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> Na = N % 1000 <NEWLINE> if Na = 0 : <NEWLINE> <INDENT> print ( Na ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 1000 - Na ) <NEWLINE> <DEDENT>
N = int ( input ) <NEWLINE> quotient = N // 1000 <NEWLINE> for i in range ( quotient + 1 ) : <NEWLINE> <INDENT> N = N - 1000 <NEWLINE> if N <= 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> print ( abs ( N ) ) <NEWLINE>
pritn ( - int ( input ( ) ) % 1000 ) <NEWLINE>
a = int ( input ( ) ) <NEWLINE> if a == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> return <NEWLINE> <DEDENT> r = 1000 - ( a % 1000 ) <NEWLINE> print ( r ) <NEWLINE>
<COMMENT> <NL> <NL> price = int ( print ( ) ) <NEWLINE> surpus = price % 1000 <NEWLINE> return surpus <NEWLINE>
print ( 1000 - int ( input ( ) ) % 1000 if int ( input ( ) ) % 1000 else 0 ) <NEWLINE> <NL>
N = int ( input ( ) ) <NEWLINE> if N % 1000 = 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a = N % 1000 <NEWLINE> print ( 1000 - a ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> <NL> ACcount = 0 <NEWLINE> WAcount = 0 <NEWLINE> TLEcount = 0 <NEWLINE> REcount = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> S = input ( ) <NEWLINE> <NL> if S == <STRING> : <NEWLINE> <INDENT> ACcount = ACcount + 1 <NEWLINE> <DEDENT> elif S == <STRING> : <NEWLINE> <INDENT> WAcount = WAcount + 1 <NEWLINE> <DEDENT> elif S == <STRING> : <NEWLINE> <INDENT> TLEcount = TLEcount + 1 <NEWLINE> <DEDENT> elif S == <STRING> : <NEWLINE> <INDENT> REcount = REcount + 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> , ACcount ) <NEWLINE> print ( <STRING> , WAcount ) <NEWLINE> print ( <STRING> , TLEcount ) <NEWLINE> print ( <STRING> , REcount ) <NEWLINE>
a = input ( int ( ) ) <NEWLINE> b = a % 1000 <NEWLINE> if b >> 0 : <NEWLINE> <INDENT> print ( 1000 - b ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT>
N = input ( ) <NEWLINE> M = int ( N ) <NEWLINE> <NL> def cal ( a ) : <NEWLINE> <INDENT> return a % 1000 <NEWLINE> <NL> <NL> <DEDENT> if M = 1000 <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <NL> <NL> <DEDENT> else : <NEWLINE> <INDENT> print ( 1000 - cal ( M ) ) <NEWLINE> <NL> <NL> <DEDENT>
N = int ( input ( ) ) <NEWLINE> amari = N % 1000 <NEWLINE> if amari == 0 : <NEWLINE> <INDENT> print ( amari ) <NEWLINE> <DEDENT> elif : <NEWLINE> <INDENT> print ( 1000 - amari ) <NEWLINE> <DEDENT>
N = int ( input ) <NEWLINE> for i in range ( 11 ) : <NEWLINE> <INDENT> money = i * 1000 <NEWLINE> if money - N >= 0 : <NEWLINE> <INDENT> print ( money - N ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = N - 1000 * ( N // 1000 ) <NEWLINE> B = ( ( N // 1000 ) + 1 ) * 1000 - N <NEWLINE> if A <= B : <NEWLINE> <INDENT> return A <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return B <NEWLINE> <DEDENT>
n = input ( ) <NEWLINE> k = 0 <NEWLINE> while k < n : <NEWLINE> <INDENT> k += 1000 <NEWLINE> <DEDENT> print ( k - n ) <NEWLINE>
n = list ( int ( input ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> if len ( n ) == 5 : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( 1000 , 10000 , 1000 ) : <NEWLINE> <INDENT> if i - n == 1000 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> elif i - n < 1000 : <NEWLINE> <INDENT> ans = i <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> a = 1000 - N % 1000 <NEWLINE> if a == 1000 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( a <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> x = ( n // 1000 ) + 1 <NEWLINE> if n % 1000 = 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( x * 1000 - n ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> <NL> a = math . ceil ( N / 1000 ) <NEWLINE> <NL> b = 1000 * a - N <NEWLINE> <NL> print ( b ) <NEWLINE>
cash = int ( input ( ) ) <NEWLINE> <NL> n = 0 <NEWLINE> paid = 0 <NEWLINE> while paid < cash : <NEWLINE> <INDENT> paid = 1000 * n <NEWLINE> <NL> <DEDENT> print ( paid - cash ) <NEWLINE> <NL>
s = int ( input ( ) ) <NEWLINE> for i in range ( 1 , 10 ) : <NEWLINE> <INDENT> if ( 1000 * i ) > s : <NEWLINE> <INDENT> return print ( ( 1000 * i ) - s ) <NEWLINE> <DEDENT> <DEDENT>
a = input ( ) <NEWLINE> print ( a % 1000 ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> if n % 1000 == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> v = n // 1000 <NEWLINE> <INDENT> print ( ( v + 1 ) * 1000 - n ) <NEWLINE> <DEDENT> <DEDENT>
n = input ( ) <NEWLINE> if n % 1000 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 1000 - n % 1000 ) <NEWLINE> <DEDENT>
s = int ( input ( ) ) <NEWLINE> <NL> a = s % 1000 <NEWLINE> <NL> if a == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> elif : <NEWLINE> <INDENT> print ( 10 - a ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> H , W , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> a = [ list ( input ( ) ) for _ in range ( H ) ] <COMMENT> <NEWLINE> <COMMENT> <NL> print ( a ) <NEWLINE> count = 0 <NEWLINE> ans = 0 <NEWLINE> for i in range ( 2 ** W ) : <COMMENT> <NEWLINE> <INDENT> for j in range ( 2 ** H ) : <COMMENT> <NEWLINE> <INDENT> count = 0 <NEWLINE> for s in range ( H ) : <NEWLINE> <INDENT> for t in range ( W ) : <NEWLINE> <INDENT> if ( i >> s ) & 1 and ( j >> t ) & 1 and a [ s ] [ t ] == <STRING> : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> if count == K : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
input_yen = int ( input ( ) ) <NEWLINE> unit_yen = 1000 <NEWLINE> <NL> required_bill = int ( float ( input_yen ) / unit_yen ) * unit_yen <NEWLINE> return required_bill - input_yen <NEWLINE>
n = int ( input ( ) ) <NEWLINE> if k % 1000 != 0 : print ( ( k + 1 ) * 1000 - n ) <NEWLINE> else : print ( 0 ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> if N % 1000 != 0 : <NEWLINE> <INDENT> maisu = N // 1000 + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> maisu = N // 1000 <NEWLINE> <DEDENT> print ( maisu * 1000 - k ) <NEWLINE>
if int ( input ( ) ) % 1000 == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 1000 - ( ( int ( input ( ) ) ) % 1000 ) ) <NEWLINE> <DEDENT>
if N % 1000 == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 1000 - N % 1000 ) <NEWLINE> <DEDENT>
<NL> a = money % 1000 <NEWLINE> if a > 0 : <NEWLINE> <INDENT> change = 1000 - a <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> change = 0 <NEWLINE> <DEDENT> print ( change ) <NEWLINE>
a = input ( ) <NEWLINE> print ( a % 1000 ) <NEWLINE>
print ( 1000 - ( int ( input ( ) ) % 1000 ) ) % 1000 <NEWLINE>
money1 = int ( input ( ) ) <NEWLINE> if money1 % 1000 != 0 : <NEWLINE> <INDENT> money2 = 1000 - ( money1 % 1000 ) <NEWLINE> else : <NEWLINE> money2 = 0 <NEWLINE> <DEDENT> print ( str ( money2 ) ) <NEWLINE>
N = input ( ) <NEWLINE> <NL> answer = 1000 - ( N % 1000 ) <NEWLINE> <NL> print ( answer ) <NEWLINE>
n = input ( ) <NEWLINE> if len ( n ) < 3 : <NEWLINE> <INDENT> print ( 1000 - int ( n ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> hasuu = n [ len ( n ) - 3 : ] <NEWLINE> if hasuu == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 1000 - int ( hasuu ) <NEWLINE> <DEDENT> <DEDENT>
n = input ( ) <NEWLINE> while n > 0 : <NEWLINE> <INDENT> n -= 1000 <NEWLINE> <DEDENT> print ( abs ( n ) ) <NEWLINE>
print ( int ( int ( input ( ) / 1000 + 1 ) * 1000 - N ) <NEWLINE>
N = int ( input ( ) <NEWLINE> if N % 1000 == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 1000 - ( N % 1000 ) ) <NEWLINE> <DEDENT>
n = int ( input ) <NEWLINE> if n % 1000 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> print ( 1000 - ( n % 1000 ) ) <NEWLINE>
print ( 1000 - N % 1000 ) <NEWLINE>
<INDENT> n = int ( input ( ) ) <NEWLINE> <INDENT> n %= 1000 <NEWLINE> <NL> if n == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 1000 - n ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def resolve ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> while n > 0 : <NEWLINE> <INDENT> n = n - 1000 <NEWLINE> <NL> <DEDENT> print ( abs ( n ) ) <NEWLINE> <DEDENT> resolvea ( ) <NEWLINE>
return 1000 - ( int ( input ( ) ) % 1000 ) <NEWLINE>
input_num = int ( input ( ) ) <NEWLINE> <NL> n_surplus = input_num % 1000 <NEWLINE> <NL> if n_surplus == 0 : <NEWLINE> <INDENT> print ( n_surplus ) <NEWLINE> else : <NEWLINE> <INDENT> print ( 1000 - n_surplus ) <NEWLINE> <NL> <DEDENT> <DEDENT>
print ( 100000 - int ( input ( ) . split ( ) ) % 1000 ) <NEWLINE>
import math <NEWLINE> <NL> price = input ( ) <NEWLINE> payment = math . ceil ( float ( price ) / 1000 ) * 1000 <NEWLINE> result = payment - price <NEWLINE> print ( int ( result ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S = [ ] <NEWLINE> for _ in range ( N ) : S . append ( input ( ) ) ) <NEWLINE> <NL> print ( <STRING> , S . count ( <STRING> ) ) <NEWLINE> print ( <STRING> , S . count ( <STRING> ) ) <NEWLINE> print ( <STRING> , S . count ( <STRING> ) ) <NEWLINE> print ( <STRING> , S . count ( <STRING> ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a , b , c , d = 0 , 0 , 0 , 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if str ( input ( ) ) == <STRING> : a += 1 <NEWLINE> elif str ( input ( ) ) == <STRING> : b += 1 <NEWLINE> elif str ( input ( ) ) == <STRING> : c += 1 <NEWLINE> else : d += 1 <NEWLINE> <DEDENT> print ( <STRING> , <STRING> , a ) <NEWLINE> print ( <STRING> , <STRING> , b ) <NEWLINE> print ( <STRING> , <STRING> , c ) <NEWLINE> print ( <STRING> , <STRING> , d ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> judge = list ( input ( ) for _ in range ( n ) ) <NEWLINE> ac , wa , tle , re = 0 <NEWLINE> for i in judge : <NEWLINE> <INDENT> if i == <STRING> : <NEWLINE> <INDENT> ac = ac + 1 <NEWLINE> <DEDENT> elif i == <STRING> : <NEWLINE> <INDENT> wa = wa + 1 <NEWLINE> <DEDENT> elif i == <STRING> : <NEWLINE> <INDENT> tle = tle + 1 <NEWLINE> <DEDENT> elif i == <STRING> : <NEWLINE> <INDENT> re = re + 1 <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> + str ( ac ) ) <NEWLINE> print ( <STRING> + str ( wa ) ) <NEWLINE> print ( <STRING> + str ( tle ) ) <NEWLINE> print ( <STRING> + str ( re ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> ac = wa = tle = re = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> m = int ( input ( ) ) <NEWLINE> if m == <STRING> : <NEWLINE> <INDENT> ac += 1 <NEWLINE> <DEDENT> elif m == <STRING> : <NEWLINE> <INDENT> wa += 1 <NEWLINE> <DEDENT> elif m == <STRING> : <NEWLINE> <INDENT> tle += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> re += 1 <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> , ac ) <NEWLINE> print ( <STRING> , wa ) <NEWLINE> print ( <STRING> , tle ) <NEWLINE> print ( <STRING> , re ) <NEWLINE>
ru = int ( input ( ) ) <NEWLINE> <NL> a = [ input ( ) for i in range ( ru ) ] <NEWLINE> <NL> <NL> print ( <STRING> + a . count ( <STRING> ) ) <NEWLINE> print ( <STRING> + a . count ( <STRING> ) ) <NEWLINE> print ( <STRING> + a . count ( <STRING> ) ) <NEWLINE> print ( <STRING> + a . count ( <STRING> ) ) <NEWLINE>
number = int ( input ( ) ) <NEWLINE> <NL> ac = 0 <NEWLINE> wa = 0 <NEWLINE> tle = 0 <NEWLINE> re = 0 <NEWLINE> for i in range ( number ) : <NEWLINE> <INDENT> character = input ( ) <NEWLINE> if character == <STRING> : <NEWLINE> <INDENT> ac += 1 <NEWLINE> <DEDENT> if character == <STRING> : <NEWLINE> <INDENT> wa += 1 <NEWLINE> <DEDENT> if character == <STRING> : <NEWLINE> <INDENT> tle += 1 <NEWLINE> <DEDENT> if character == <STRING> : <NEWLINE> <INDENT> re += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> + ac ) <NEWLINE> print ( <STRING> + wa ) <NEWLINE> print ( <STRING> + tle ) <NEWLINE> print ( <STRING> + re ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> S . append ( input ( ) ) <NEWLINE> <NL> <DEDENT> A = S . count ( <STRING> ) <NEWLINE> B = S . count ( <STRING> ) <NEWLINE> C = S . count ( <STRING> ) <NEWLINE> D = S . count ( <STRING> ) <NEWLINE> <NL> print ( <STRING> + A ) <NEWLINE> print ( <STRING> + B ) <NEWLINE> print ( <STRING> + C ) <NEWLINE> print ( <STRING> + D ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> c0 = 0 <NEWLINE> c1 = 0 <NEWLINE> c2 = 0 <NEWLINE> c3 = 0 <NEWLINE> for i in ragne ( n ) : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> if s == <STRING> : <NEWLINE> <INDENT> c0 += 1 <NEWLINE> <DEDENT> elif s == <STRING> : <NEWLINE> <INDENT> c1 += 1 <NEWLINE> <DEDENT> elif s == <STRING> : <NEWLINE> <INDENT> c2 += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> c3 += 1 <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> print ( <STRING> ) <NEWLINE> print ( <STRING> ) <NEWLINE> print ( <STRING> ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> <NL> for i in range ( 0 , N ) : <NEWLINE> <INDENT> val = input ( ) <NEWLINE> if val : <NEWLINE> <INDENT> S . append ( val ) <NEWLINE> <DEDENT> <DEDENT> AC = S . count ( <STRING> ) <NEWLINE> WA = S . count ( <STRING> ) <NEWLINE> TLE = S . count ( <STRING> ) <NEWLINE> RE = S . count ( <STRING> ) <NEWLINE> <NL> print ( <STRING> , end = <STRING> ) <NEWLINE> print ( AC ) <NEWLINE> print ( <STRING> , end = <STRING> ) <NEWLINE> print ( WA ) <NEWLINE> print ( <STRING> , end = <STRING> ) <NEWLINE> print ( TLE ) <NEWLINE> print ( <STRING> , end = <STRING> ) <NEWLINE> print ( RE ) <NEWLINE>
from collections import Counter <NEWLINE> lst = [ ] <NEWLINE> for i in range ( int ( input ( ) ) ) : <NEWLINE> <INDENT> lst . append ( input ( ) ) <NEWLINE> <DEDENT> dic = dict ( Counter ( lst ) ) <NEWLINE> for i in [ <STRING> , <STRING> , <STRING> , <STRING> ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( <STRING> ) ) <NEWLINE> d = dict ( ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> x = input ( <STRING> ) <NEWLINE> if not x in d : <NEWLINE> <INDENT> d [ x ] = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d [ x ] = d [ x ] + 1 <NEWLINE> <DEDENT> <DEDENT> for k , v in d . items ( ) <NEWLINE> <INDENT> print ( k , <STRING> , v ) <NEWLINE> <DEDENT>
<COMMENT> <NL> N = int ( input ( ) ) <NEWLINE> S = list ( input ( ) for i in range ( N ) ) <NEWLINE> a = 0 <NEWLINE> b = 0 <NEWLINE> c = 0 <NEWLINE> d = 0 <NEWLINE> for i in S : <NEWLINE> <INDENT> if i == <STRING> : <NEWLINE> <INDENT> a += 1 <NEWLINE> <DEDENT> elif i == <STRING> : <NEWLINE> <INDENT> b += 1 <NEWLINE> <DEDENT> elif i == <STRING> : <NEWLINE> <INDENT> c += 1 <NEWLINE> <DEDENT> elif i == <STRING> : <NEWLINE> <INDENT> d += 1 <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> + str ( a ) ) <NEWLINE> print ( <STRING> + str ( b ) ) <NEWLINE> print ( <STRING> + str ( c ) ) <NEWLINE> print ( <STRING> + str ( d ) ) <NEWLINE> AC x 3 <NEWLINE> WA x 1 <NEWLINE> TLE x 2 <NEWLINE> RE x 0 <NEWLINE>
n = int ( input ( ) ) <NEWLINE> c0 = 0 <NEWLINE> c1 = 0 <NEWLINE> c2 = 0 <NEWLINE> c3 = 0 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> test = input ( ) <NEWLINE> if test == <STRING> : <NEWLINE> <INDENT> c0 += 1 <NEWLINE> <DEDENT> elif test == <STRING> : <NEWLINE> <INDENT> c1 += 1 <NEWLINE> <DEDENT> elif test == <STRING> : <NEWLINE> <INDENT> c2 += 1 <NEWLINE> <DEDENT> elif test == <STRING> : <NEWLINE> <INDENT> c3 += 1 <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> , c0 ) <NEWLINE> print ( <STRING> , c1 ) <NEWLINE> print ( <STRING> , c2 ) <NEWLINE> ptint ( <STRING> , c3 ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> ac = 0 <NEWLINE> wa = 0 <NEWLINE> tle = 0 <NEWLINE> re = 0 <NEWLINE> for m in range ( n ) : <NEWLINE> <INDENT> a = input ( ) <NEWLINE> if a == <STRING> : <NEWLINE> <INDENT> ac = ac + 1 <NEWLINE> <DEDENT> elif a == <STRING> : <NEWLINE> <INDENT> wa = wa + 1 <NEWLINE> <DEDENT> elif a == <STRING> : <NEWLINE> <INDENT> tle = tle + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> re = re + 1 <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> % ac ) <NEWLINE> print ( <STRING> % wa ) <NEWLINE> print ( <STRING> % tle ) <NEWLINE> print ( <STRING> % re ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> AC = 0 <NEWLINE> WA = 0 <NEWLINE> TLE = 0 <NEWLINE> RE = 0 <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> a = input ( ) <NEWLINE> if a = <STRING> : <NEWLINE> <INDENT> AC += 1 <NEWLINE> <DEDENT> elif a = <STRING> : <NEWLINE> <INDENT> WA += 1 <NEWLINE> <DEDENT> elif a = <STRING> : <NEWLINE> <INDENT> TLE += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> RE += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> + AC ) <NEWLINE> print ( <STRING> + WA ) <NEWLINE> print ( <STRING> + TLE ) <NEWLINE> print ( <STRING> + RE ) <NEWLINE>
n = int ( ( <NEWLINE>
d = { AC : 0 ; WA : 0 ; TLE : 0 ; RE : 0 } <NEWLINE> for i in range ( int ( input ( ) ) ) : d [ input ( ) ] += 1 <NEWLINE> for i in d : print ( i + <STRING> , d [ i ] ) <NEWLINE>
N = int ( input ) <NEWLINE> S = [ input ( ) for i in range ( n ) ] <NEWLINE> for v in [ <STRING> , <STRING> , <STRING> , <STRING> ] : <NEWLINE> <INDENT> print ( <STRING> . format ( v , s . count ( v ) ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> ac = 0 <NEWLINE> wa = 0 <NEWLINE> tle = 0 <NEWLINE> re = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> if ( s == <STRING> ) : <NEWLINE> <INDENT> ac += 1 <NEWLINE> <DEDENT> elif ( s == <STRING> ) : <NEWLINE> <INDENT> wa += 1 <NEWLINE> <DEDENT> elif ( s == <STRING> ) : <NEWLINE> <INDENT> tle += 1 <NEWLINE> <DEDENT> elif ( s == <STRING> ) : <NEWLINE> <INDENT> re += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> + ac ) <NEWLINE> print ( <STRING> + wa ) <NEWLINE> print ( <STRING> + tle ) <NEWLINE> print ( <STRING> + re ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> cnt_ac = 0 <NEWLINE> cnt_tle = 0 <NEWLINE> cnt_wa = 0 <NEWLINE> cnt_re = 0 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> if input ( ) == <STRING> : <NEWLINE> <INDENT> cnt_ac += 1 <NEWLINE> <DEDENT> elif input ( ) == <STRING> : <NEWLINE> <INDENT> cnt_tle += 1 <NEWLINE> <DEDENT> elif input ( ) == <STRING> : <NEWLINE> <INDENT> cnt_wa += 1 <NEWLINE> <DEDENT> elif input ( ) == <STRING> : <NEWLINE> <INDENT> cnt_re += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> + cnt_ac ) <NEWLINE> print ( <STRING> + cnt_wa ) <NEWLINE> print ( <STRING> + cnt_tle ) <NEWLINE> print ( <STRING> + cnt_re ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> n = int ( input ( ) ) <NEWLINE> s = [ input ( ) for _ in range ( n ) ] <NEWLINE> ac = 0 <NEWLINE> wa = 0 <NEWLINE> tle = 0 <NEWLINE> re = 0 <NEWLINE> <NL> for i in s : <NEWLINE> <INDENT> if i == <STRING> : <NEWLINE> <INDENT> ac += 1 <NEWLINE> <DEDENT> elif i == <STRING> : <NEWLINE> <INDENT> wa += 1 <NEWLINE> <DEDENT> elif i == <STRING> : <NEWLINE> <INDENT> tle += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> re += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> + <STRING> , end = <STRING> ) <NEWLINE> print ( ac ) <NEWLINE> print ( <STRING> + <STRING> , end = <STRING> ) <NEWLINE> print ( wa ) <NEWLINE> print ( <STRING> + <STRING> , end = <STRING> ) <NEWLINE> print ( tle ) <NEWLINE> print ( <STRING> + <STRING> , end = <STRING> ) <NEWLINE> print ( re ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> n = int ( input ( ) ) <NEWLINE> s = [ input ( ) for _ in range ( n ) ] <NEWLINE> ac = 0 <NEWLINE> wa = 0 <NEWLINE> tle = 0 <NEWLINE> re = 0 <NEWLINE> <NL> for i in s : <NEWLINE> <INDENT> if i == <STRING> : <NEWLINE> <INDENT> ac += 1 <NEWLINE> <DEDENT> elif i == <STRING> : <NEWLINE> <INDENT> wa += 1 <NEWLINE> <DEDENT> elif i == <STRING> : <NEWLINE> <INDENT> tle += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> re += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> + <STRING> , end = <STRING> ) <NEWLINE> print ( ac ) <NEWLINE> print ( <STRING> + <STRING> , end = <STRING> ) <NEWLINE> print ( wa ) <NEWLINE> print ( <STRING> + <STRING> , end = <STRING> ) <NEWLINE> print ( tle ) <NEWLINE> print ( <STRING> + <STRING> , end = <STRING> ) <NEWLINE> print ( re ) <NEWLINE>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> d = { <STRING> : 0 , <STRING> : 0 , <STRING> : 0 , <STRING> : 0 } <NEWLINE> <NL> for _ in range ( N ) : <NEWLINE> <INDENT> d [ input ( ) ] += 1 <NEWLINE> <NL> <DEDENT> for s in [ <STRING> , <STRING> , <STRING> , <STRING> ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
listSi = [ 0 , 0 , 0 , 0 ] <NEWLINE> i = int ( input ( ) ) <NEWLINE> while ( i = input ( ) ) : <NEWLINE> <INDENT> if i == <STRING> : <NEWLINE> <INDENT> listSi [ 0 ] += 1 <NEWLINE> <DEDENT> elif i == <STRING> : <NEWLINE> <INDENT> listSi [ 1 ] += 1 <NEWLINE> <DEDENT> elif i == <STRING> : <NEWLINE> <INDENT> listSi [ 2 ] += 1 <NEWLINE> <DEDENT> elif i == <STRING> : <NEWLINE> <INDENT> listSi [ 3 ] += 1 <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> print ( <STRING> ) <NEWLINE> print ( <STRING> ) <NEWLINE> print ( <STRING> ) <NEWLINE>
t = int ( input ( ) ) <NEWLINE> wlist = [ 0 ] * 4 <NEWLINE> for i in range ( t ) : <NEWLINE> <INDENT> w = input ( ) <NEWLINE> if w == <STRING> : <NEWLINE> <INDENT> wlist [ 0 ] += 1 <NEWLINE> <DEDENT> elif w == <STRING> : <NEWLINE> <INDENT> wlist [ 1 ] += 1 <NEWLINE> <DEDENT> elif w == <STRING> : <NEWLINE> <INDENT> wlist [ 2 ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> wlist [ 3 ] += 1 <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> + wlist [ 0 ] ) <NEWLINE> print ( <STRING> + wlist [ 1 ] ) <NEWLINE> print ( <STRING> + wlist [ 2 ] ) <NEWLINE> print ( <STRING> + wlist [ 3 ] ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> c0 , c1 , c2 , c3 = [ 0 for i in range ( 4 ) ] <NEWLINE> for j in range ( n ) : <NEWLINE> <INDENT> judge = input ( ) <NEWLINE> c0 += 1 if judge == <STRING> else c1 += 1 if judge == <STRING> else c2 += 1 if judge == <STRING> else c3 += 1 <NEWLINE> <NL> <DEDENT> print ( <STRING> + str ( c0 ) ) <NEWLINE> print ( <STRING> + str ( c1 ) ) <NEWLINE> print ( <STRING> + str ( c2 ) ) <NEWLINE> print ( <STRING> + str ( c3 ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> p = [ ] <NEWLINE> AC = 0 <NEWLINE> WA = 0 <NEWLINE> TLE = 0 <NEWLINE> RE = 0 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> p . append ( input ( ) ) <NEWLINE> <NL> <DEDENT> for j in p : <NEWLINE> <INDENT> if j == <STRING> : <NEWLINE> <INDENT> AC += 1 <NEWLINE> <DEDENT> elif j == <STRING> : <NEWLINE> <INDENT> WA += 1 <NEWLINE> <DEDENT> elif j == <STRING> : <NEWLINE> <INDENT> TLE += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> RE += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> + AC ) <NEWLINE> print ( <STRING> + WA ) <NEWLINE> print ( <STRING> + TLE ) <NEWLINE> print ( <STRING> + RE ) <NEWLINE> <NL> <NL> <NL>
N = int ( input ( ) ) <NEWLINE> var = [ str ( input ( ) ) for i in range ( N ) ] <NEWLINE> judges = [ <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> for j in judges : <NEWLINE> <INDENT> print ( <STRING> . format ( j , ( np . array ( var ) == j ) . sum ( ) ) ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> l = [ input ( ) for i in range ( num ) ] <NEWLINE> print ( <STRING> , l . count ( <STRING> ) ) <NEWLINE> print ( <STRING> , l . count ( <STRING> ) ) <NEWLINE> print ( <STRING> , l . count ( <STRING> ) ) <NEWLINE> print ( <STRING> , l . count ( <STRING> ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = [ 0 , 0 , 0 , 0 ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> if s == <STRING> : <NEWLINE> <INDENT> a [ 0 ] += 1 <NEWLINE> <DEDENT> elif s == <STRING> : <NEWLINE> <INDENT> a [ 1 ] += 1 <NEWLINE> <DEDENT> elif s == <STRING> : <NEWLINE> <INDENT> a [ 2 ] += 1 <NEWLINE> <DEDENT> elif : <NEWLINE> <INDENT> a [ 3 ] += 1 <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> print ( a [ 0 ] ) <NEWLINE> print ( <STRING> , end = <STRING> ) <NEWLINE> print ( a [ 1 ] ) <NEWLINE> print ( <STRING> , end = <STRING> ) <NEWLINE> print ( a [ 2 ] ) <NEWLINE> print ( <STRING> , end = <STRING> ) <NEWLINE> print ( a [ 3 ] ) <NEWLINE>
a = [ ] <NEWLINE> w = [ ] <NEWLINE> t = [ ] <NEWLINE> r = [ ] <NEWLINE> n = int ( input ( ) ) <NEWLINE> s = list ( input ( ) . split ( ) ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> a . append ( s [ i ] ) <NEWLINE> <DEDENT> elif s [ i ] == <STRING> : <NEWLINE> <INDENT> w . append ( s [ i ] ) <NEWLINE> <DEDENT> elif s [ i ] == <STRING> : <NEWLINE> <INDENT> t . append ( s [ i ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> r . append ( s [ i ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> , sum ( a ) ) <NEWLINE> print ( <STRING> , sum ( w ) ) <NEWLINE> print ( <STRING> , sum ( t ) ) <NEWLINE> print ( <STRING> , sum ( r ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> ac = 0 <NEWLINE> wa = 0 <NEWLINE> tle = 0 <NEWLINE> re = 0 <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> if <STRING> == s : <NEWLINE> <INDENT> ac += 1 <NEWLINE> <DEDENT> elif <STRING> == s : <NEWLINE> <INDENT> wa += 1 <NEWLINE> <DEDENT> elif <STRING> == s : <NEWLINE> <INDENT> tle += 1 <NEWLINE> <DEDENT> elif <STRING> == s : <NEWLINE> <INDENT> re += 1 <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> , x , ac ) <NEWLINE> print ( <STRING> , x , wa ) <NEWLINE> print ( <STRING> , x , tle ) <NEWLINE> print ( <STRING> , x , re ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> s = [ input ( ) for v in range ( N ) ] <NEWLINE> for v in [ <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> <INDENT> print ( <STRING> . format ( v , s . count ( v ) ) ) <NEWLINE> <DEDENT>
import sys <NEWLINE> N = int ( input ( ) ) <NEWLINE> base = [ <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> array = [ input ( ) for a in range ( N ) if input ( ) in base ] <NEWLINE> <NL> if not ( 1 <= N <= 10 ** 5 ) : sys . exit ( ) <NEWLINE> <NL> for I in base : <NEWLINE> <INDENT> print ( I + <STRING> + str ( array . count ( I ) ) ) <NEWLINE> <DEDENT>
rmap = { <NEWLINE> <INDENT> <STRING> : 0 , <NEWLINE> <STRING> : 0 , <NEWLINE> <STRING> : 0 , <NEWLINE> <STRING> : 0 , <NEWLINE> <DEDENT> } <NEWLINE> <NL> output_order = [ <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> <NL> N - int ( input ( ) ) <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> rmap [ input ( ) ] += 1 <NEWLINE> <NL> <DEDENT> for k in output_order : <NEWLINE> <INDENT> print ( <STRING> . format ( k , rmap [ k ] ) ) <NEWLINE> <DEDENT>
cases = int ( input ( ) ) <NEWLINE> <NL> account = { <STRING> : 0 , <STRING> : 0 , <STRING> : 0 , <STRING> : 0 } <NEWLINE> <NL> while - - cases > 0 : <NEWLINE> <INDENT> + + account [ input ( ) ] <NEWLINE> <NL> <DEDENT> print ( <STRING> + account [ <STRING> ] ) <NEWLINE> print ( <STRING> + account [ <STRING> ] ) <NEWLINE> print ( <STRING> + account [ <STRING> ] ) <NEWLINE> print ( <STRING> + account [ <STRING> ] ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> l = [ input ( ) for _ in range ( num ) ] <NEWLINE> print ( <STRING> , l . count ( <STRING> ) ) <NEWLINE> print ( <STRING> , l . count ( <STRING> ) ) <NEWLINE> print ( <STRING> , l . count ( <STRING> ) ) <NEWLINE> print ( <STRING> , l . count ( <STRING> ) ) <NEWLINE>
import os <NEWLINE> import sys <NEWLINE> from collections import defaultdict , Counter <NEWLINE> from itertools import product , permutations , combinations , accumulate <NEWLINE> from operator import itemgetter <NEWLINE> from bisect import bisect_left , bisect <NEWLINE> from heapq import heappop , heappush , heapify <NEWLINE> from math import ceil , floor , sqrt , gcd <NEWLINE> from copy import deepcopy <NEWLINE> from functools import reduce <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> lists = [ ] <NEWLINE> ans = [ 0 ] * 4 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> if not s in lists : <NEWLINE> <INDENT> lists . append ( s ) <NEWLINE> <NL> <NL> <DEDENT> if s == <STRING> : <NEWLINE> <INDENT> ans [ 0 ] += 1 <NEWLINE> <DEDENT> elif s == <STRING> : <NEWLINE> <INDENT> ans [ 1 ] += 1 <NEWLINE> <DEDENT> elif s == <STRING> : <NEWLINE> <INDENT> ans [ 2 ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans [ 3 ] += 1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> for i in range ( ans ) : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> print ( <STRING> , ans [ i ] ) <NEWLINE> <DEDENT> elif i == 1 : <NEWLINE> <INDENT> print ( <STRING> , ans [ i ] ) <NEWLINE> <DEDENT> elif i == 2 : <NEWLINE> <INDENT> print ( <STRING> , ans [ i ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> , ans [ i ] ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> s = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> s . append ( input ( ) ) <NEWLINE> <DEDENT> print ( <STRING> + s . count ( <STRING> ) ) <NEWLINE> print ( <STRING> + s . count ( <STRING> ) ) <NEWLINE> print ( <STRING> + s . count ( <STRING> ) ) <NEWLINE> print ( <STRING> + s . count ( <STRING> ) ) <NEWLINE>
nums = int ( input ( ) ) <NEWLINE> <NL> S = { <STRING> : 0 , <STRING> : 0 , <STRING> : 0 , <STRING> : 0 } <NEWLINE> <NL> for i in nums : <NEWLINE> <INDENT> input_str = input ( ) <NEWLINE> if input_str in S : <NEWLINE> <INDENT> S [ input_str ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> % S [ <STRING> ] ) <NEWLINE> print ( <STRING> % S [ <STRING> ] ) <NEWLINE> print ( <STRING> % S [ <STRING> ] ) <NEWLINE> print ( <STRING> % S [ <STRING> ] ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> ac = 0 <NEWLINE> wa = 0 <NEWLINE> tle = 0 <NEWLINE> re = 0 <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> if s == <STRING> : <NEWLINE> <INDENT> a += 1 <NEWLINE> <DEDENT> elif s == <STRING> : <NEWLINE> <INDENT> wa += 1 <NEWLINE> <DEDENT> elif s == <STRING> : <NEWLINE> <INDENT> tle += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> re += 1 <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> , ac ) <NEWLINE> print ( <STRING> , wa ) <NEWLINE> print ( <STRING> , tle ) <NEWLINE> print ( <STRING> , re ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> <NL> AC = 0 <NEWLINE> WA = 0 <NEWLINE> TLE = 0 <NEWLINE> RE = 0 <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> ans = input ( ) <NEWLINE> <NL> if ans = <STRING> : <NEWLINE> <INDENT> AC += 1 <NEWLINE> <NL> <DEDENT> elif ans = <STRING> : <NEWLINE> <INDENT> WA += 1 <NEWLINE> <NL> <DEDENT> elif ans = <STRING> : <NEWLINE> <INDENT> TLE += 1 <NEWLINE> <NL> <DEDENT> elif ans = <STRING> : <NEWLINE> <INDENT> RE += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> , AC ) <NEWLINE> print ( <STRING> , WA ) <NEWLINE> print ( <STRING> , TLE ) <NEWLINE> print ( <STRING> , RE ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S = [ int ( input ( ) ) for _ in range ( N ) ] <NEWLINE> <NL> AC = 0 <NEWLINE> WA = 0 <NEWLINE> TLE = 0 <NEWLINE> RE = 0 <NEWLINE> <NL> for i in S : <NEWLINE> <INDENT> if i == <STRING> : <NEWLINE> <INDENT> AC += 1 <NEWLINE> <DEDENT> elif i == <STRING> : <NEWLINE> <INDENT> WA += 1 <NEWLINE> <DEDENT> elif i == <STRING> : <NEWLINE> <INDENT> TLE += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> RE += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> , AC ) <NEWLINE> print ( <STRING> , WA ) <NEWLINE> print ( <STRING> , TLE ) <NEWLINE> print ( <STRING> , RE ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> stat2id = { <NEWLINE> <INDENT> <STRING> : 0 , <NEWLINE> <STRING> : 1 , <NEWLINE> <STRING> : 2 , <NEWLINE> <STRING> : 3 , <NEWLINE> <DEDENT> } <NEWLINE> id2stat = { i : s for s , i in stat2id . items ( ) } <NEWLINE> count = [ 0 for _ in range ( 4 ) ] <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> count [ s ] += 1 <NEWLINE> <DEDENT> for i , c in enumerate ( count ) : <NEWLINE> <INDENT> print ( id2stat [ i ] , <STRING> , c ) <NEWLINE> <DEDENT>
a = int ( input ( ) ) <NEWLINE> b = [ input ( ) for i in range ( a ) ] <NEWLINE> c = [ AC , WA , TLE , RE ] <NEWLINE> for value in c : <NEWLINE> <INDENT> print ( <STRING> . format ( value , b . count ( value ) ) ) <NEWLINE> <DEDENT>
print ( N ) <NEWLINE> <NL> S = [ input ( ) for i in range ( N ) ] <NEWLINE> print ( S ) <NEWLINE> <NL> ac = 0 <NEWLINE> wa = 0 <NEWLINE> tle = 0 <NEWLINE> re = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if S [ i ] == <STRING> : <NEWLINE> <INDENT> ac += 1 <NEWLINE> <DEDENT> elif S [ i ] == <STRING> : <NEWLINE> <INDENT> wa += 1 <NEWLINE> <DEDENT> elif S [ i ] == <STRING> : <NEWLINE> <INDENT> tle += 1 <NEWLINE> <DEDENT> elif S [ i ] == <STRING> : <NEWLINE> <INDENT> re += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> , ac ) <NEWLINE> print ( <STRING> , wa ) <NEWLINE> print ( <STRING> , tle ) <NEWLINE> print ( <STRING> , re ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> <NL> <NL> ansAC = 0 <NEWLINE> ansWA = 0 <NEWLINE> ansTLE = 0 <NEWLINE> ansRE = 0 <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> S = input ( ) <NEWLINE> if S == <STRING> : <NEWLINE> <INDENT> ansAC += 1 <NEWLINE> <DEDENT> elif S == <STRING> : <NEWLINE> <INDENT> ansTLE += 1 <NEWLINE> <DEDENT> elif S == <STRING> : <NEWLINE> <INDENT> ansWA += 1 <NEWLINE> <DEDENT> elif S == <STRING> : <NEWLINE> <INDENT> ansRE += 1 <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> + ansAC ) <NEWLINE> print ( <STRING> + ansWA ) <NEWLINE> print ( <STRING> + ansTLE ) <NEWLINE> print ( <STRING> + ansRE ) <NEWLINE>
import math <NEWLINE> import collections <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> S = [ int ( input ( ) ) for _ in range ( N ) ] <NEWLINE> <NL> A = collections . Counter ( S ) <NEWLINE> <NL> print ( <STRING> + A [ <STRING> ] ) <NEWLINE> print ( <STRING> + A [ <STRING> ] ) <NEWLINE> print ( <STRING> + A [ <STRING> ] ) <NEWLINE> print ( <STRING> + A [ <STRING> ] ) <NEWLINE> <NL> <NL> <NL> <DEDENT> main ( ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> ac , tle , wa , re = 0 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> s [ i - 1 ] = input ( ) <NEWLINE> <NL> <NL> if s [ i - 1 ] == <STRING> : <NEWLINE> <INDENT> ac = ac + 1 <NEWLINE> <DEDENT> elif s [ i - 1 ] == <STRING> <NEWLINE> <INDENT> tle = tle + 1 <NEWLINE> <DEDENT> elif s [ i - 1 ] == <STRING> <NEWLINE> <INDENT> wa = wa + 1 <NEWLINE> <DEDENT> elif s [ i - 1 ] == <STRING> <NEWLINE> <INDENT> re = re + 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> + ac ) <NEWLINE> print ( <STRING> + wa ) <NEWLINE> print ( <STRING> + tle ) <NEWLINE> print ( <STRING> + re ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = [ int ( input ( ) ) for i in range ( n ) ] <NEWLINE> <NL> print ( <STRING> + str ( s . count ( <STRING> ) ) ) <NEWLINE> print ( <STRING> + str ( s . count ( <STRING> ) ) ) <NEWLINE> print ( <STRING> + str ( s . count ( <STRING> ) ) ) <NEWLINE> print ( <STRING> + str ( s . count ( <STRING> ) ) ) <NEWLINE>
N = int ( N ) <NEWLINE> S = [ input ( ) for i in range ( N ) ] <NEWLINE> <NL> A = S . count ( <STRING> ) <NEWLINE> B = S . count ( <STRING> ) <NEWLINE> C = S . count ( <STRING> ) <NEWLINE> D = S . count ( <STRING> ) <NEWLINE> <NL> print ( <STRING> , A ) <NEWLINE> print ( <STRING> , B ) <NEWLINE> print ( <STRING> , C ) <NEWLINE> print ( <STRING> , D ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> C_0 = 0 <NEWLINE> C_1 = 0 <NEWLINE> C_2 = 0 <NEWLINE> C_3 = 0 <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> if input ( ) == <STRING> : <NEWLINE> <INDENT> C_0 += 1 <NEWLINE> <DEDENT> elif input ( ) == <STRING> : <NEWLINE> <INDENT> C_1 += 1 <NEWLINE> <DEDENT> elif input ( ) == <STRING> : <NEWLINE> <INDENT> C_2 += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> C_3 += 1 <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> . format ( C_0 ) ) <NEWLINE> print ( <STRING> . format ( C_1 ) ) <NEWLINE> print ( <STRING> . format ( C_2 ) ) <NEWLINE> print ( <STRING> . format ( C_3 ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> C0 = 0 <NEWLINE> C1 = 0 <NEWLINE> C2 = 0 <NEWLINE> C3 = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if input ( ) == <STRING> : <NEWLINE> <INDENT> C0 += 1 <NEWLINE> <DEDENT> elif input ( ) == <STRING> : <NEWLINE> <INDENT> C1 += 1 <NEWLINE> <DEDENT> elif input ( ) == <STRING> : <NEWLINE> <INDENT> C2 += 1 <NEWLINE> <DEDENT> elif input ( ) == <STRING> : <NEWLINE> <INDENT> C3 += 1 <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> , C0 ) <NEWLINE> print ( <STRING> , C1 ) <NEWLINE> print ( <STRING> , C2 ) <NEWLINE> print ( <STRING> , C3 ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> AC = 0 <NEWLINE> WA = 0 <NEWLINE> TLE = 0 <NEWLINE> RE = 0 <NEWLINE> <NL> for k in range ( N ) : <NEWLINE> <INDENT> K = input ( ) <NEWLINE> if K == <STRING> : <NEWLINE> <INDENT> AC = AC + 1 <NEWLINE> <DEDENT> elif K == <STRING> : <NEWLINE> <INDENT> WA = WA + 1 <NEWLINE> <DEDENT> elif K == <STRING> : <NEWLINE> <INDENT> TLE = TLE + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> RE = RE + 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> + AC ) <NEWLINE> print ( <STRING> + RE ) <NEWLINE> print ( <STRING> + TLE ) <NEWLINE> print ( <STRING> + RE ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = [ str ( i ) for _ in range ( n ) ] <NEWLINE> for i in ( <STRING> , <STRING> , <STRING> , <STRING> ) : <NEWLINE> <INDENT> print ( <STRING> . format ( i , s . count ( i ) ) <NEWLINE> <DEDENT>
count_ac = 0 <NEWLINE> count_wa = 0 <NEWLINE> count_tle = 0 <NEWLINE> count_re = 0 <NEWLINE> n = int ( input ( ) ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> d = input ( ) <NEWLINE> if s == <STRING> : <NEWLINE> <INDENT> count_ac += 1 <NEWLINE> <DEDENT> elif s == <STRING> : <NEWLINE> <INDENT> count_wa += 1 <NEWLINE> <DEDENT> elif s == <STRING> : <NEWLINE> <INDENT> count_tle += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> count_re += 1 <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> + str ( count_wa ) ) <NEWLINE> print ( <STRING> + str ( count_ac ) ) <NEWLINE> print ( <STRING> + str ( count_tle ) ) <NEWLINE> print ( <STRING> + str ( count_re ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> ac_counter = 0 <NEWLINE> wa_counter = 0 <NEWLINE> tle_counter = 0 <NEWLINE> re_counter = 0 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> str = input ( ) <NEWLINE> if str == <STRING> : <NEWLINE> <INDENT> ac_counter += 1 <NEWLINE> <DEDENT> elif str == <STRING> : <NEWLINE> <INDENT> wa_counter += 1 <NEWLINE> <DEDENT> elif str == <STRING> : <NEWLINE> <INDENT> tle_counter += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> re_counter += 1 <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> + str ( ac_counter ) ) <NEWLINE> print ( <STRING> + str ( wa_counter ) ) <NEWLINE> print ( <STRING> + str ( tle_counter ) ) <NEWLINE> print ( <STRING> + str ( re_counter ) ) <NEWLINE>
x = [ input ( ) for i in range ( N ) ] <NEWLINE> AC = 0 <NEWLINE> WA = 0 <NEWLINE> TLE = 0 <NEWLINE> RE = 0 <NEWLINE> for t in range ( N ) : <NEWLINE> <INDENT> if x [ t ] == <STRING> : <NEWLINE> <INDENT> AC += 1 <NEWLINE> <DEDENT> elif x [ t ] == <STRING> : <NEWLINE> <INDENT> WA += 1 <NEWLINE> <DEDENT> elif x [ t ] == <STRING> : <NEWLINE> <INDENT> TLE += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> RE += 1 <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> , AC ) <NEWLINE> print ( <STRING> , WA ) <NEWLINE> print ( <STRING> , TLE ) <NEWLINE> print ( <STRING> , RE ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> SAC = 0 <NEWLINE> SWA = 0 <NEWLINE> STLE = 0 <NEWLINE> SRE = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> tmp = imput ( ) <NEWLINE> if tmp == <STRING> : <NEWLINE> <INDENT> SAC += 1 <NEWLINE> <DEDENT> elif tmp == <STRING> : <NEWLINE> <INDENT> SWA += 1 <NEWLINE> <DEDENT> elif tmp == <STRING> : <NEWLINE> <INDENT> STLE += 1 <NEWLINE> <DEDENT> elif tmp == <STRING> : <NEWLINE> <INDENT> SRE += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> + str ( SAC ) ) <NEWLINE> print ( <STRING> + str ( SWA ) ) <NEWLINE> print ( <STRING> + str ( STLE ) ) <NEWLINE> print ( <STRING> + str ( SRE ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> ac , wa , tle , re = 0 , 0 , 0 , 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> hoge = input ( ) <NEWLINE> if ( hoge = <STRING> ) : <NEWLINE> <INDENT> ac += 1 <NEWLINE> <DEDENT> elif ( hoge = <STRING> ) : <NEWLINE> <INDENT> wa += 1 <NEWLINE> <DEDENT> elif ( hoge = <STRING> ) : <NEWLINE> <INDENT> tle += 1 <NEWLINE> <DEDENT> elif ( hoge = <STRING> ) : <NEWLINE> <INDENT> re += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> + ac ) <NEWLINE> print ( <STRING> + wa ) <NEWLINE> print ( <STRING> + tle ) <NEWLINE> print ( <STRING> + re ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S = [ input ( ) for _ in range ( N ) ] <NEWLINE> <NL> a = 0 <NEWLINE> w = 0 <NEWLINE> t = 0 <NEWLINE> r = 0 <NEWLINE> <NL> for i range ( N ) : <NEWLINE> <INDENT> if S [ i ] == <STRING> : <NEWLINE> <INDENT> a += 1 <NEWLINE> <DEDENT> elif S [ i ] == <STRING> : <NEWLINE> <INDENT> w += 1 <NEWLINE> <DEDENT> elif S [ i ] == <STRING> : <NEWLINE> <INDENT> t += 1 <NEWLINE> <DEDENT> elif S [ i ] == <STRING> : <NEWLINE> <INDENT> r += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> + str ( a ) ) <NEWLINE> print ( <STRING> + str ( w ) ) <NEWLINE> print ( <STRING> + str ( t ) ) <NEWLINE> print ( <STRING> + str ( r ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> ac = 0 <NEWLINE> wa = 0 <NEWLINE> tle = 0 <NEWLINE> re = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if input ( ) == <STRING> : <NEWLINE> <INDENT> ac += 1 <NEWLINE> <DEDENT> elif input ( ) == <STRING> : <NEWLINE> <INDENT> wa += 1 <NEWLINE> <DEDENT> elif input ( ) == <STRING> : <NEWLINE> <INDENT> tle += 1 <NEWLINE> <DEDENT> elif input ( ) == <STRING> : <NEWLINE> <INDENT> re += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> , ac ) <NEWLINE> print ( <STRING> , wa ) <NEWLINE> print ( <STRING> , tle ) <NEWLINE> print ( <STRING> , re ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> ac = wa = tle = re = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> if s = <STRING> : <NEWLINE> <INDENT> ac += 1 <NEWLINE> <DEDENT> elif s = <STRING> : <NEWLINE> <INDENT> wa += 1 <NEWLINE> <DEDENT> elif s = <STRING> : <NEWLINE> <INDENT> tle += 1 <NEWLINE> <DEDENT> elif s = <STRING> : <NEWLINE> <INDENT> re += 1 <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> , ac ) <NEWLINE> print ( <STRING> , wa ) <NEWLINE> print ( <STRING> , tle ) <NEWLINE> print ( <STRING> , re ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> s . append ( int ( input ( ) ) ) <NEWLINE> <DEDENT> print ( <STRING> , s . count ( <STRING> ) ) <NEWLINE> print ( <STRING> , s . count ( <STRING> ) ) <NEWLINE> print ( <STRING> , s . count ( <STRING> ) ) <NEWLINE> print ( <STRING> , s . count ( <STRING> ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> inp = [ ] <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> inp . append ( int ( input ( ) ) ) <NEWLINE> <NL> <DEDENT> c0 = N . count ( <STRING> ) <NEWLINE> c1 = N . count ( <STRING> ) <NEWLINE> c2 = N . count ( <STRING> ) <NEWLINE> c3 = N . count ( <STRING> ) <NEWLINE> <NL> print ( <STRING> + str ( c0 ) ) <NEWLINE> print ( <STRING> + str ( c1 ) ) <NEWLINE> print ( <STRING> + str ( c2 ) ) <NEWLINE> print ( <STRING> + str ( c3 ) ) <NEWLINE>
import collections <NEWLINE> <COMMENT> <NL> import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> arr = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> dic = collections . Counter ( arr ) <NEWLINE> <NL> for s in ( <STRING> , <STRING> , <STRING> , <STRING> ) : <NEWLINE> <INDENT> print ( s + <STRING> + str ( dic [ s ] ) ) <NEWLINE> <DEDENT>
arr = [ ] <NEWLINE> n = int ( input ( ) ) <NEWLINE> while n > 0 : <NEWLINE> <INDENT> arr . append ( input ( ) ) <NEWLINE> n -= 1 <NEWLINE> <DEDENT> print ( <STRING> + arr . count ( <STRING> ) ) <NEWLINE> print ( <STRING> + arr . count ( <STRING> ) ) <NEWLINE> print ( <STRING> + arr . count ( <STRING> ) ) <NEWLINE> print ( <STRING> + arr . count ( <STRING> ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> mydict = { <STRING> : 0 , <STRING> : 0 , <STRING> : 0 , <STRING> : 0 } <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> mydict [ input ( ) ] += 1 <NEWLINE> <DEDENT> printlist = [ <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> for p in printlist : <NEWLINE> <INDENT> print ( <STRING> . format ( p , mydict [ p ] ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> c_0 = 0 <NEWLINE> c_1 = 0 <NEWLINE> c_2 = 0 <NEWLINE> c_3 = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> s_i = input ( ) <NEWLINE> if s_i == <STRING> : <NEWLINE> <INDENT> c_0 = c_0 + 1 <NEWLINE> <DEDENT> elif s_i == <STRING> : <NEWLINE> <INDENT> c_1 = c_1 + 1 <NEWLINE> <DEDENT> elif s_i == <STRING> : <NEWLINE> <INDENT> c_2 = c_2 + 1 <NEWLINE> <DEDENT> elif s_i == <STRING> : <NEWLINE> <INDENT> c_3 = c_3 + 1 <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> + c_0 ) <NEWLINE> print ( <STRING> + c_1 ) <NEWLINE> print ( <STRING> + c_2 ) <NEWLINE> print ( <STRING> + c_3 ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> array = [ ] <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> array . append ( int ( input ( ) ) ) <NEWLINE> <DEDENT> AC = 0 <NEWLINE> WA = 0 <NEWLINE> TLE = 0 <NEWLINE> RE = 0 <NEWLINE> for test in array : <NEWLINE> <INDENT> if <STRING> == test : <NEWLINE> <INDENT> AC += 1 <NEWLINE> <DEDENT> elif <STRING> == test : <NEWLINE> <INDENT> WA += 1 <NEWLINE> <DEDENT> elif <STRING> == test : <NEWLINE> <INDENT> TLE += 1 <NEWLINE> <DEDENT> elif <STRING> == test : <NEWLINE> <INDENT> RE += 1 <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> print ( <STRING> ) <NEWLINE> print ( <STRING> ) <NEWLINE> print ( <STRING> ) <NEWLINE>
n , * s = map ( int , open ( 0 ) . read ( ) . split ( ) ) <NEWLINE> <NL> c0 = s . count ( <STRING> ) <NEWLINE> c1 = s . count ( <STRING> ) <NEWLINE> c2 = s . count ( <STRING> ) <NEWLINE> c3 = n - ( c0 + c1 + c2 ) <NEWLINE> <NL> print ( <STRING> + str ( c0 ) , <STRING> + str ( c1 ) , sep = <STRING> ) <NEWLINE> print ( <STRING> + str ( c2 ) , <STRING> + str ( c3 ) , sep = <STRING> ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> AC = 0 <NEWLINE> WA = 0 <NEWLINE> TLE = 0 <NEWLINE> RE = 0 <NEWLINE> for i in range ( 0 , N ) : <NEWLINE> <INDENT> j = str ( input ( ) ) <NEWLINE> if j = <STRING> : <NEWLINE> <INDENT> AC += 1 <NEWLINE> <DEDENT> elif j = <STRING> : <NEWLINE> <INDENT> WA += 1 <NEWLINE> <DEDENT> elif j = <STRING> : <NEWLINE> <INDENT> TLE += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> RE += 1 <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> . format ( AC ) ) <NEWLINE> print ( <STRING> . format ( WA ) ) <NEWLINE> print ( <STRING> . format ( TLE ) ) <NEWLINE> print ( <STRING> . format ( RE ) ) <NEWLINE>
from collections import Counter <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> s = [ input ( ) for _ in range ( n ) ] <NEWLINE> counter = Counter ( s ) <NEWLINE> <COMMENT> <NL> <NL> for key in output : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> <NL> ac = 0 <NEWLINE> wa = 0 <NEWLINE> tle = 0 <NEWLINE> re = 0 <NEWLINE> <NL> for _ in range ( n ) : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> if s = <STRING> : <NEWLINE> <INDENT> ac += 1 <NEWLINE> <DEDENT> elif s == <STRING> : <NEWLINE> <INDENT> wa += 1 <NEWLINE> <DEDENT> elif s == <STRING> : <NEWLINE> <INDENT> tle += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> re += re <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> . format ( ac ) ) <NEWLINE> print ( <STRING> . format ( wa ) ) <NEWLINE> print ( <STRING> . format ( tle ) ) <NEWLINE> print ( <STRING> . format ( re ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> x0 , x1 , x2 , x3 = 0 , 0 , 0 , 0 <NEWLINE> <NL> for i in range ( N ) <NEWLINE> <INDENT> Si = input ( ) <NEWLINE> <INDENT> if Si == <STRING> : <NEWLINE> <INDENT> x0 = x0 + 1 <NEWLINE> <NL> <DEDENT> elif Si == <STRING> : <NEWLINE> <INDENT> x1 = x1 + 1 <NEWLINE> <NL> <DEDENT> elif Si == <STRING> : <NEWLINE> <INDENT> x2 = x2 + 1 <NEWLINE> <NL> <DEDENT> else Si == <STRING> : <NEWLINE> <INDENT> x3 = x3 + 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> str ( x0 ) ) <NEWLINE> print ( <STRING> str ( x1 ) ) <NEWLINE> print ( <STRING> str ( x2 ) ) <NEWLINE> print ( <STRING> str ( x3 ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> <NL> AC = 0 <NEWLINE> WA = 0 <NEWLINE> TLE = 0 <NEWLINE> RE = 0 <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> if ( s == <STRING> ) : <NEWLINE> <INDENT> AC += 1 <NEWLINE> <DEDENT> elif ( s == <STRING> ) : <NEWLINE> <INDENT> WA += 1 <NEWLINE> <DEDENT> elif ( s == <STRING> ) : <NEWLINE> <INDENT> TLE += 1 <NEWLINE> <DEDENT> elif ( s == <STRING> ) : <NEWLINE> <INDENT> RE += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> . format ( AC ) ) <NEWLINE> print ( <STRING> . format ( WA ) <NEWLINE> print ( <STRING> . format ( TLE ) ) <NEWLINE> print ( <STRING> . format ( RE ) ) <NEWLINE> <NL> <NL>
n = int ( input ( ) ) <NEWLINE> s = [ input ( ) for i in range ( n ) ] <NEWLINE> <NL> AC = s . count ( <STRING> ) <NEWLINE> WA = s . count ( <STRING> ) <NEWLINE> TLE = s . count ( <STRING> ) <NEWLINE> RE = s . count ( <STRING> ) <NEWLINE> <NL> AC2 = <STRING> + str ( AC ) <NEWLINE> WA2 = <STRING> + str ( WA ) <NEWLINE> TLE2 = <STRING> + str ( TLE ) <NEWLINE> RE2 = <STRING> + str ( RE ) <NEWLINE> x <NEWLINE> list = [ AC2 , WA2 , TLE2 , RE2 ] <NEWLINE> list_n = <STRING> . join ( list ) <NEWLINE> print ( list_n ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> list_judge = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> list_judge . append ( str ( input ( ) ) ) <NEWLINE> <NL> <DEDENT> print ( <STRING> , acnum = list_judge . count ( <STRING> ) ) <NEWLINE> print ( <STRING> , wanum = list_judge . count ( <STRING> ) ) <NEWLINE> print ( <STRING> , tlenum = list_judge . count ( <STRING> ) ) <NEWLINE> print ( <STRING> , renum = list_judge . count ( <STRING> ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S = [ input ( ) for i in range ( N ) ] <NEWLINE> for v in [ <STRING> , <STRING> , <STRING> , <STRING> ] : <NEWLINE> <INDENT> print ( <STRING> . format ( v , s . count ( v ) ) ) <NEWLINE> <DEDENT>
from collections import deque <NEWLINE> import math <NEWLINE> import os <NEWLINE> import random <NEWLINE> import re <NEWLINE> import sys <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> s = input ( ) . split ( ) <NEWLINE> <INDENT> n = int ( s [ 0 ] ) <NEWLINE> d = { <STRING> : 0 , <STRING> : 0 , <STRING> : 0 , <STRING> : 0 } <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> s = input ( ) . split ( ) <NEWLINE> d [ s [ 0 ] ] += 1 <NEWLINE> <DEDENT> for i in d : <NEWLINE> <INDENT> print ( i , <STRING> , d [ i ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> main ( ) <NEWLINE> <STRING> <NEWLINE> <NL> <NL>
n = int ( input ( ) ) <NEWLINE> s = [ input ( ) for _ in range ( n ) ] <NEWLINE> c = collections . Counter ( s ) <NEWLINE> <NL> print ( <STRING> , c [ <STRING> ] ) <NEWLINE> print ( <STRING> , c [ <STRING> ] ) <NEWLINE> print ( <STRING> , c [ <STRING> ] ) <NEWLINE> print ( <STRING> , c [ <STRING> ] ) <NEWLINE>
from math import floor , ceil , sqrt , factorial , log <NEWLINE> from collections import Counter , deque <NEWLINE> from functools import reduce <NEWLINE> import numpy as np <NEWLINE> import itertools <NEWLINE> def S ( ) : return input ( ) <NEWLINE> def I ( ) : return int ( input ( ) ) <NEWLINE> def MS ( ) : return map ( str , input ( ) . split ( ) ) <NEWLINE> def MI ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def FLI ( ) : return [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> def LS ( ) : return list ( MS ( ) ) <NEWLINE> def LI ( ) : return list ( MI ( ) ) <NEWLINE> def LLS ( ) : return [ list ( map ( str , l . split ( ) ) ) for l in input ( ) ] <NEWLINE> def LLI ( ) : return [ list ( map ( int , l . split ( ) ) ) for l in input ( ) ] <NEWLINE> def LLSN ( n : int ) : return [ LS ( ) for _ in range ( n ) ] <NEWLINE> def LLIN ( n : int ) : return [ LI ( ) for _ in range ( n ) ] <NEWLINE> <NL> N = I ( ) <NEWLINE> c0 , c1 , c2 , c3 = 0 , 0 , 0 , 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if S ( ) == <STRING> : <NEWLINE> <INDENT> c0 += 1 <NEWLINE> <DEDENT> elif S ( ) == <STRING> : <NEWLINE> <INDENT> c1 += 1 <NEWLINE> <DEDENT> elif S ( ) == <STRING> : <NEWLINE> <INDENT> c2 += 1 <NEWLINE> <DEDENT> elif S ( ) == <STRING> : <NEWLINE> <INDENT> c3 += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> + c0 ) <NEWLINE> print ( <STRING> + c1 ) <NEWLINE> print ( <STRING> + c2 ) <NEWLINE> print ( <STRING> + c3 ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> <NL> ac , wa , tle , re = 0 , 0 , 0 , 0 <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> S = int ( input ( ) ) <NEWLINE> if S == <STRING> : <NEWLINE> <INDENT> ac += 1 <NEWLINE> <DEDENT> elif S == <STRING> : <NEWLINE> <INDENT> wa += 1 <NEWLINE> <DEDENT> elif S == <STRING> : <NEWLINE> <INDENT> tle += 1 <NEWLINE> <DEDENT> elif S == <STRING> : <NEWLINE> <INDENT> re += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> % ac ) <NEWLINE> print ( <STRING> % wa ) <NEWLINE> print ( <STRING> % tle ) <NEWLINE> print ( <STRING> % re ) <NEWLINE>
import sys <NEWLINE> N = int ( input ( ) ) <NEWLINE> s = [ ] <NEWLINE> for l in sys . stdin : <NEWLINE> <INDENT> s . append ( int ( l ) ) <NEWLINE> <NL> <DEDENT> a = s . count ( <STRING> ) <NEWLINE> b = s . count ( <STRING> ) <NEWLINE> c = s . count ( <STRING> ) <NEWLINE> d = s . count ( <STRING> ) <NEWLINE> <NL> print ( <STRING> + <STRING> + str ( a ) ) <NEWLINE> print ( <STRING> + <STRING> + str ( b ) ) <NEWLINE> print ( <STRING> + <STRING> + str ( c ) ) <NEWLINE> print ( <STRING> + <STRING> + str ( d ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> verdict = { <STRING> : 0 , <STRING> : 0 , <STRING> : 0 , <STRING> : 0 } <NEWLINE> <NL> for _ in range ( n ) : <NEWLINE> <INDENT> S = input ( ) <NEWLINE> verdict [ S . upper ( ) ] += 1 <NEWLINE> <DEDENT> for i , j in verdict : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a , b , c , d = 0 , 0 , 0 , 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> if s == <STRING> : <NEWLINE> <INDENT> a += 1 <NEWLINE> <DEDENT> elif s == <STRING> : <NEWLINE> <INDENT> b += 1 <NEWLINE> <DEDENT> elif s == <STRING> : <NEWLINE> <INDENT> c += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d += 1 <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> a ) <NEWLINE> print ( <STRING> b ) <NEWLINE> print ( <STRING> c ) <NEWLINE> print ( <STRING> d ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> test_case = [ input ( ) for _ in range ( N ) ] <NEWLINE> a = test_case . count ( <STRING> ) <NEWLINE> b = test_case . count ( <STRING> ) <NEWLINE> c = test_case . count ( <STRING> ) <NEWLINE> d = test_case . count ( <STRING> ) <NEWLINE> print ( <STRING> + a ) <NEWLINE> print ( <STRING> + b ) <NEWLINE> print ( <STRING> + c ) <NEWLINE> print ( <STRING> + d ) <NEWLINE>
AC = 0 <NEWLINE> WA = 0 <NEWLINE> TLE = 0 <NEWLINE> RE = 0 <NEWLINE> from collections import defaultdict <NEWLINE> d = defaultdict ( 0 ) <NEWLINE> print ( d [ 1 ] ) <NEWLINE> N = int ( input ( ) ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> <DEDENT>
verdicts = { <STRING> : 0 , <STRING> : 0 , <STRING> : 0 , <STRING> : 0 } <NEWLINE> <NL> v = input ( ) <NEWLINE> while v : <NEWLINE> <INDENT> verdicts [ v ] += 1 <NEWLINE> v = input ( ) <NEWLINE> <NL> <DEDENT> for v , f in verdicts . items ( ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> s = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> s += [ input ( ) ] <NEWLINE> <DEDENT> c0 = s . count ( <STRING> ) <NEWLINE> c1 = s . count ( <STRING> ) <NEWLINE> c2 = s . count ( <STRING> ) <NEWLINE> c3 = s . count ( <STRING> ) <NEWLINE> print ( <STRING> + str ( c0 ) ) <NEWLINE> print ( <STRING> + str ( c1 ) ) <NEWLINE> print ( <STRING> + str ( c2 ) ) <NEWLINE> print ( <STRING> + str ( c3 ) ) 6 <NEWLINE>
N = int ( input ( ) ) <NEWLINE> a = [ input ( ) for i in range ( N ) ] <NEWLINE> c0 = a . count ( <STRING> ) <NEWLINE> c1 = a . count ( <STRING> ) <NEWLINE> c2 = a . count ( <STRING> ) <NEWLINE> c3 = a . count ( <STRING> ) <NEWLINE> print ( <STRING> + c0 ) <NEWLINE> print ( <STRING> + c1 ) <NEWLINE> print ( <STRING> + c2 ) <NEWLINE> print ( <STRING> + c3 ) <NEWLINE>
Ss = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> Ss . append ( input ( ) ) <NEWLINE> <NL> <DEDENT> C0 , C1 , C2 , C3 = 0 , 0 , 0 , 0 <NEWLINE> for S in Ss : <NEWLINE> <INDENT> if S == <STRING> : <NEWLINE> <INDENT> C0 += 1 <NEWLINE> <DEDENT> elif S == <STRING> : <NEWLINE> <INDENT> C1 += 1 <NEWLINE> <DEDENT> elif S == <STRING> : <NEWLINE> <INDENT> C2 += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> C3 += 1 <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> . format ( C0 ) ) <NEWLINE> print ( <STRING> . format ( C1 ) ) <NEWLINE> print ( <STRING> . format ( C2 ) ) <NEWLINE> print ( <STRING> . format ( C3 ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a , b , c , d = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> e = input ( ) <NEWLINE> if e == <STRING> : <NEWLINE> <INDENT> a += 1 <NEWLINE> <DEDENT> elif e == <STRING> : <NEWLINE> <INDENT> b += 1 <NEWLINE> <DEDENT> elif e == <STRING> : <NEWLINE> <INDENT> c += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> + str ( a ) + <STRING> + <STRING> + str ( b ) + <STRING> <NEWLINE> <INDENT> + <STRING> + str ( c ) + <STRING> + <STRING> + str ( d ) ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> s = [ input ( ) for i in range ( n ) ] <NEWLINE> print ( <STRING> , s . count ( <STRING> ) ) <NEWLINE> print ( <STRING> , a . count ( <STRING> ) ) <NEWLINE> print ( <STRING> , a . count ( <STRING> <NEWLINE>
n = int ( input ( ) ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> S [ i ] = input ( ) <NEWLINE> <NL> <DEDENT> ac = 0 <NEWLINE> wa = 0 <NEWLINE> tle = 0 <NEWLINE> re = 0 <NEWLINE> <NL> <NL> for i in range ( n ) : <NEWLINE> <INDENT> if S [ i ] == <STRING> : <NEWLINE> <INDENT> ac += 1 <NEWLINE> <DEDENT> elif S [ i ] == <STRING> : <NEWLINE> <INDENT> wa += 1 <NEWLINE> <DEDENT> elif S [ i ] == <STRING> : <NEWLINE> <INDENT> tle += 1 <NEWLINE> <DEDENT> elif S [ i ] == <STRING> : <NEWLINE> <INDENT> re += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> , ac ) <NEWLINE> print ( <STRING> , wa ) <NEWLINE> print ( <STRING> , tle ) <NEWLINE> print ( <STRING> , re ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> s = [ input ( ) for i in range ( N ) ] <NEWLINE> <NL> print ( <STRING> + <STRING> AC <STRING> ) <NEWLINE> print ( <STRING> + <STRING> WA <STRING> ) <NEWLINE> print ( <STRING> + <STRING> TLE <STRING> ) <NEWLINE> print ( <STRING> + <STRING> RE <STRING> ) <NEWLINE>
l = [ ] <NEWLINE> for i in range ( int ( input ( ) ) : <NEWLINE> <INDENT> l . append ( input ( ) ) <NEWLINE> <DEDENT> ac = 0 <NEWLINE> wa = 0 <NEWLINE> tle = 0 <NEWLINE> re = 0 <NEWLINE> for i in l : <NEWLINE> <INDENT> if i == <STRING> : <NEWLINE> <INDENT> ac += 1 <NEWLINE> <DEDENT> if i == <STRING> : <NEWLINE> <INDENT> tle += 1 <NEWLINE> <DEDENT> if i == <STRING> : <NEWLINE> <INDENT> wa += 1 <NEWLINE> <DEDENT> if i == <STRING> : <NEWLINE> <INDENT> re += 1 <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> + str ( ac ) ) <NEWLINE> print ( <STRING> + str ( wa ) ) <NEWLINE> print ( <STRING> + str ( tle ) ) <NEWLINE> print ( <STRING> + str ( re ) ) <NEWLINE> <NL>
N = input ( ) <NEWLINE> <NL> N = N . splitlines ( ) <NEWLINE> <NL> N_num = int ( N [ 0 ] ) <NEWLINE> <NL> AC_num = 0 <NEWLINE> WA_num = 0 <NEWLINE> TLE_num = 0 <NEWLINE> RE_num = 0 <NEWLINE> <NL> for i in range ( N_num ) : <NEWLINE> <COMMENT> <NL> <NL> <INDENT> if <STRING> == N [ i + 1 ] : <NEWLINE> <INDENT> AC_num += 1 <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> elif <STRING> == N [ i + 1 ] : <NEWLINE> <INDENT> WA_num += 1 <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> elif <STRING> == N [ i + 1 ] : <NEWLINE> <INDENT> TLE_num += 1 <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> else <STRING> == N [ i + 1 ] : <NEWLINE> <INDENT> RE_num += 1 <NEWLINE> <COMMENT> <NL> <NL> <NL> <DEDENT> <DEDENT> print ( <STRING> . format ( AC_num ) ) <NEWLINE> print ( <STRING> . format ( WA_num ) ) <NEWLINE> print ( <STRING> . format ( TLE_num ) ) <NEWLINE> print ( <STRING> . format ( RE_num ) ) <NEWLINE>
n = int ( input ( ) ) ; s = [ ] <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> s . append ( input ( ) ) <NEWLINE> <NL> <DEDENT> dic = { <STRING> : 0 , <NEWLINE> <INDENT> <STRING> : 0 , <NEWLINE> <STRING> : 0 , <NEWLINE> <STRING> : 0 } <NEWLINE> <NL> <DEDENT> for res in s : <NEWLINE> <INDENT> dic [ s ] += 1 <NEWLINE> <NL> <DEDENT> for k in dic : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
from collections import Counter <NEWLINE> n = int ( input ( ) ) <NEWLINE> s = [ input ( ) for i in range ( n ) ] <NEWLINE> <NL> c = Counter ( s ) <NEWLINE> <NL> for k in [ <STRING> , <STRING> , <STRING> , <STRING> ] : <NEWLINE> <INDENT> if k in c : <NEWLINE> <INDENT> print ( <STRING> . format ( k , c [ k ] ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> . format ( k , c [ k ] ) ) <NEWLINE> <DEDENT> <DEDENT>
from collectinos import defaultdict <NEWLINE> d = defaultdict ( int ) <NEWLINE> N = int ( input ( ) ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> d [ input ( ) ] += 1 <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> print ( <STRING> ) <NEWLINE> print ( <STRING> ) <NEWLINE> print ( <STRING> ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> import collections <NEWLINE> co = collections . Counter ( ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> co [ input ( ) ] += 1 <NEWLINE> <DEDENT> print ( <STRING> AC <STRING> ) <NEWLINE> print ( <STRING> WA <STRING> ) <NEWLINE> print ( <STRING> TLE <STRING> ) <NEWLINE> print ( <STRING> RE <STRING> ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> AC = 0 <NEWLINE> WA = 0 <NEWLINE> TLE = 0 <NEWLINE> RE = 0 <NEWLINE> for i in range ( 0 , n ) : <NEWLINE> <INDENT> if <STRING> : AC += 1 <NEWLINE> else if <STRING> : WA += 1 <NEWLINE> else if <STRING> : TLE += 1 <NEWLINE> else if <STRING> : RE += 1 <NEWLINE> <DEDENT> print ( <STRING> + str ( AC ) ) <NEWLINE> print ( <STRING> + str ( WA ) ) <NEWLINE> print ( <STRING> + str ( TLE ) ) <NEWLINE> print ( <STRING> + str ( RE ) ) <NEWLINE>
l = int ( input ( ) ) <NEWLINE> n = [ ] <NEWLINE> for i in range ( l ) : <NEWLINE> <INDENT> n . append ( input ( ) ) <NEWLINE> <DEDENT> ac = 0 <NEWLINE> wa = 0 <NEWLINE> tle = 0 <NEWLINE> re = 0 <NEWLINE> for i in n : <NEWLINE> <INDENT> if i == <STRING> : <NEWLINE> <INDENT> ac += 1 <NEWLINE> <DEDENT> elif i == <STRING> : <NEWLINE> <INDENT> wa += 1 <NEWLINE> <DEDENT> elif i == TLE : <NEWLINE> <INDENT> tle += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> re += 1 <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> + str ( ac ) ) <NEWLINE> print ( <STRING> + str ( wa ) ) <NEWLINE> print ( <STRING> + str ( tle ) ) <NEWLINE> print ( <STRING> + str ( RE ) ) <NEWLINE>
from collections import defaultdict as dc <NEWLINE> d = dc ( lambda : 0 ) <NEWLINE> st = [ <STRING> . <STRING> , <STRING> , <STRING> ] <NEWLINE> for n in range ( int ( input ( ) ) ) : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> <INDENT> d [ s ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> for n in st : <NEWLINE> <INDENT> print ( n , <STRING> , d [ n ] ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> <NL> d = { } <NEWLINE> <NL> for _ in range ( n ) : <NEWLINE> <INDENT> s = str ( input ( ) ) <NEWLINE> if s not in d : <NEWLINE> <INDENT> d [ s ] = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d [ s ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> . format ( d [ <STRING> ] , d [ <STRING> ] , d [ <STRING> ] , d [ <STRING> ] ) ) <NEWLINE>
num = int ( input ) <NEWLINE> count = { <STRING> : 0 , <STRING> : 0 , <STRING> : 0 , <STRING> : 0 } <NEWLINE> <NL> for i in range ( num ) : <NEWLINE> <INDENT> word = input ( ) <NEWLINE> for ( key , n ) in count . items ( ) : <NEWLINE> <INDENT> if word == key : <NEWLINE> <INDENT> n += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for ( key , n ) in count . items ( ) : <NEWLINE> <INDENT> print ( key + <STRING> + str ( n ) ) <NEWLINE> <DEDENT>
MB_TLE = 0 <NEWLINE> MB_WA = 0 <NEWLINE> MB_RE = o <NEWLINE> MB_AC = 0 <NEWLINE> n = int ( input ( ) ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ch = input ( ) <NEWLINE> if ( ch == <STRING> ) : <NEWLINE> <INDENT> MB_TLE += 1 <NEWLINE> <DEDENT> if ( ch == <STRING> ) : <NEWLINE> <INDENT> MB_WA += 1 <NEWLINE> <DEDENT> if ( ch == <STRING> ) : <NEWLINE> <INDENT> MB_RE += 1 <NEWLINE> <DEDENT> if ( ch == <STRING> ) : <NEWLINE> <INDENT> MB_AC += 1 <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> , MB_TLE ) <NEWLINE> print ( <STRING> , MB_WA ) <NEWLINE> print ( <STRING> , MB_RE ) <NEWLINE> print ( <STRING> , MB_AC ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> l . append ( input ( ) ) <NEWLINE> <DEDENT> a = 0 <NEWLINE> b = 0 <NEWLINE> c = 0 <NEWLINE> d = 0 <NEWLINE> for i in l : <NEWLINE> <INDENT> if i == <STRING> : <NEWLINE> <INDENT> a += 1 <NEWLINE> <DEDENT> elif i == <STRING> : <NEWLINE> <INDENT> b += 1 <NEWLINE> <DEDENT> elif i == <STRING> : <NEWLINE> <INDENT> c += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d += 1 <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> , a ) <NEWLINE> print ( <STRING> , b ) <NEWLINE> print ( <STRING> , c ) <NEWLINE> print ( <STRING> , d ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> for s in range ( N ) : <NEWLINE> <INDENT> print ( <STRING> , <STRING> , s . count ( <STRING> ) ) <NEWLINE> print ( <STRING> , <STRING> , s . count ( <STRING> ) ) <NEWLINE> print ( <STRING> , <STRING> , s . count ( <STRING> ) ) <NEWLINE> print ( <STRING> , <STRING> , s . count ( <STRING> ) ) <NEWLINE> <DEDENT>
ac , wa , tle , re = 0 , 0 , 0 , 0 <NEWLINE> for _ in range ( int ( input ( ) ) : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> <INDENT> if s == <STRING> : <NEWLINE> <INDENT> ac += 1 <NEWLINE> <DEDENT> elif s == <STRING> : <NEWLINE> <INDENT> wa += 1 <NEWLINE> <DEDENT> elif s == <STRING> : <NEWLINE> <INDENT> tle += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> re += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> . format ( ac ) ) <NEWLINE> print ( <STRING> . format ( wa ) ) <NEWLINE> print ( <STRING> . format ( tle ) ) <NEWLINE> print ( <STRING> . format ( re ) ) <NEWLINE>
AC_Count = WA_Count = TLE_Count = RE_Count = 0 <NEWLINE> for _ in range ( int ( input ( ) ) ) : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> if s == <STRING> : <NEWLINE> <INDENT> AC_Count += 1 <NEWLINE> <DEDENT> elif s == <STRING> : <NEWLINE> <INDENT> WA_Count += 1 <NEWLINE> <DEDENT> elif s == <STRING> : <NEWLINE> <INDENT> TLE_Count += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> RE_Count += 1 <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> + <STRING> + AC_count ) <NEWLINE> print ( <STRING> + <STRING> + WA_count ) <NEWLINE> print ( <STRING> + <STRING> + TLE_count ) <NEWLINE> print ( <STRING> + <STRING> + RE_count ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = 0 <NEWLINE> w = 0 <NEWLINE> t = 0 <NEWLINE> r = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> code = input ( ) <NEWLINE> if code == <STRING> : <NEWLINE> <INDENT> a += 1 <NEWLINE> <DEDENT> elif code == <STRING> : <NEWLINE> <INDENT> w += 1 <NEWLINE> <DEDENT> elif code == <STRING> : <NEWLINE> <INDENT> t += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> r += 1 <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> a ) <NEWLINE> print ( <STRING> w ) <NEWLINE> print ( <STRING> t ) <NEWLINE> print ( <STRING> r ) <NEWLINE>
import sys <NEWLINE> input ( ) <NEWLINE> d = dict . fromkeys ( <STRING> . split ( ) , 0 ) <NEWLINE> for ln in sys . stdin : <NEWLINE> <INDENT> d [ ln . strip ( ) ] += 1 <NEWLINE> <DEDENT> for k , v in ct . items ( ) : <NEWLINE> <INDENT> print ( k , <STRING> , v ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> str_list = [ input ( ) for _ in range ( n ) ] <NEWLINE> <NL> <NL> a = 0 <NEWLINE> b = 0 <NEWLINE> c = 0 <NEWLINE> d = 0 <NEWLINE> <NL> for i in range ( 1 , n ) : <NEWLINE> <INDENT> if str_list [ i ] == <STRING> : <NEWLINE> <INDENT> a += 1 <NEWLINE> <DEDENT> elif str_list [ i ] == <STRING> : <NEWLINE> <INDENT> b += 1 <NEWLINE> <DEDENT> elif str_list [ i ] == <STRING> : <NEWLINE> <INDENT> c += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> + a ) <NEWLINE> print ( <STRING> + b ) <NEWLINE> print ( <STRING> + c ) <NEWLINE> print ( <STRING> + d ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> ac = 0 <NEWLINE> wa = 0 <NEWLINE> tle = 0 <NEWLINE> re = 0 <NEWLINE> <NL> for _ in range ( n ) : <NEWLINE> <INDENT> x = input ( ) <NEWLINE> if x == <STRING> : <NEWLINE> <INDENT> ac += 1 <NEWLINE> <DEDENT> elif x == <STRING> : <NEWLINE> <INDENT> wa += 1 <NEWLINE> <DEDENT> elif x == <STRING> : <NEWLINE> <INDENT> tle += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> re += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> , ac ) <NEWLINE> print ( <STRING> , waz ) <NEWLINE> print ( <STRING> , tle ) <NEWLINE> print ( <STRING> , re ) <NEWLINE>
re = 0 <NEWLINE> tle = 0 <NEWLINE> wa = 0 <NEWLINE> ac = 0 <NEWLINE> ip = [ ] <NEWLINE> n = int ( input ( ) ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ip . append ( input ( ) ) <NEWLINE> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> if ip [ i ] == <STRING> : <NEWLINE> <INDENT> ac = ac + 1 <NEWLINE> <DEDENT> if ip [ i ] == <STRING> : <NEWLINE> <INDENT> tle = tle + 1 <NEWLINE> <DEDENT> if ip [ i ] == <STRING> : <NEWLINE> <INDENT> wa = wa + 1 <NEWLINE> <DEDENT> if ip [ i ] == <STRING> : <NEWLINE> <INDENT> re = re + 1 <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> + ac ) <NEWLINE> print ( <STRING> + wa ) <NEWLINE> print ( <STRING> + tle ) <NEWLINE> print ( <STRING> + re ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S = [ input ( ) for i in range ( N ) ] <NEWLINE> for v in [ <STRING> , <STRING> , <STRING> , <STRING> ] : <NEWLINE> <INDENT> print ( <STRING> . format ( v , s . count ( v ) ) ) <NEWLINE> <DEDENT>
x = int ( input ( <STRING> ) ) <NEWLINE> y = [ 0 ] * x <NEWLINE> for i in range ( x ) : <NEWLINE> <INDENT> y [ i ] = input ( <STRING> ) <NEWLINE> <DEDENT> a = 0 <NEWLINE> w = 0 <NEWLINE> t = 0 <NEWLINE> r = 0 <NEWLINE> for i in range ( x ) : <NEWLINE> <INDENT> if y [ i ] == AC : <NEWLINE> <INDENT> a = a + 1 <NEWLINE> <DEDENT> elif y [ i ] == WA : <NEWLINE> <INDENT> w = w + 1 <NEWLINE> <DEDENT> elif y [ i ] == TLE : <NEWLINE> <INDENT> t = t + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> r = r + 1 <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> . format ( a , w , t , r ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> <NL> ac = 0 <NEWLINE> wa = 0 <NEWLINE> tle = 0 <NEWLINE> re = 0 <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> <NL> if s == <STRING> : <NEWLINE> ac += 1 <NEWLINE> else if s == <STRING> : <NEWLINE> <INDENT> wa += 1 <NEWLINE> <DEDENT> else if s == <STRING> : <NEWLINE> <INDENT> tle += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> re += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> + ac ) <NEWLINE> print ( <STRING> + wa ) <NEWLINE> print ( <STRING> + tle ) <NEWLINE> print ( <STRING> + re ) <NEWLINE>
a , b , c , d = 0 , 0 , 0 , 0 <NEWLINE> N = int ( input ( ) ) <NEWLINE> S = [ input ( ) for _ in range ( N ) ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if S [ i ] == <STRING> : <NEWLINE> <INDENT> a = a + 1 <NEWLINE> <DEDENT> elif S [ i ] == <STRING> : <NEWLINE> <INDENT> b = b + 1 <NEWLINE> <DEDENT> elif S [ i ] == <STRING> : <NEWLINE> <INDENT> c = c + 1 <NEWLINE> <DEDENT> elif S [ i ] == <STRING> : <NEWLINE> <INDENT> d = d + 1 <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> + str ( a ) ) <NEWLINE> print ( <STRING> + str ( b ) ) <NEWLINE> print ( <STRING> + str ( c ) ) <NEWLINE> print ( <STRING> + str ( ( d ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S = [ input ( ) for i in range ( N ) ] <NEWLINE> <NL> ac = S . count ( <STRING> ) <NEWLINE> wa = S . count ( <STRING> ) <NEWLINE> tle = S . count ( <STRING> ) <NEWLINE> re = S . count ( <STRING> ) <NEWLINE> <NL> print ( <STRING> , ac ( ) ) <NEWLINE> print ( <STRING> , wa ) <NEWLINE> print ( <STRING> , tle ) <NEWLINE> print ( <STRING> , re ) <NEWLINE>
input_n = input ( ) <NEWLINE> N = int ( input_n ) <NEWLINE> <NL> check_list = [ <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> count_list = [ 0 , 0 , 0 , 0 ] <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> flag = 0 <NEWLINE> Si = input ( ) <NEWLINE> while flag < 4 : <NEWLINE> <INDENT> if Si == check_list [ flag ] : <NEWLINE> <INDENT> count_list [ flag ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> flag += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> + count_list [ 0 ] ) <NEWLINE> print ( <STRING> + count_list [ 1 ] ) <NEWLINE> print ( <STRING> + count_list [ 2 ] ) <NEWLINE> print ( <STRING> + count_list [ 3 ] ) <NEWLINE>
import datetime <NEWLINE> import string <NEWLINE> import re <NEWLINE> import math <NEWLINE> <NL> aDic = { <STRING> : 0 , <STRING> : 0 , <STRING> : 0 , <STRING> : 0 } <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> aDic [ input ( ) ] += 1 <NEWLINE> <NL> <DEDENT> for page in aDic : <NEWLINE> <INDENT> print ( page + <STRING> + str ( aDic [ page ] ) ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> dic = { <STRING> : 0 , <STRING> : 0 , <STRING> : 0 , <STRING> : 0 } <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> dic [ s ] += 1 <NEWLINE> <DEDENT> for k , v in dic . items ( ) : <NEWLINE> <INDENT> print ( <STRING> . format ( k , v ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> s = [ input ( ) for i in range ( n ) ] <NEWLINE> for v in [ <STRING> , <STRING> , <STRING> , <STRING> ] : <NEWLINE> <INDENT> print ( v , <STRING> , a . count ( v ) ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> l = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a = input ( ) <NEWLINE> l . append ( a ) <NEWLINE> <DEDENT> print ( <STRING> } <NEWLINE> print ( <STRING> } <NEWLINE> print ( <STRING> } <NEWLINE> print ( <STRING> } <NEWLINE>
taka_h , taka_a , aoki_h , aoki_a = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> while True : <NEWLINE> <INDENT> aoki_h -= taka_a <NEWLINE> taka_h -= aoki_a <NEWLINE> if ( aoki_h <= 0 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> elif ( taka_h <= 0 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> Ss = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> Ss . append ( int ( input ( ) ) ) <NEWLINE> <NL> <DEDENT> C0 , C1 , C2 , C3 = 0 , 0 , 0 , 0 <NEWLINE> for S in Ss : <NEWLINE> <INDENT> if S == <STRING> : <NEWLINE> <INDENT> C0 += 1 <NEWLINE> <DEDENT> elif S == <STRING> : <NEWLINE> <INDENT> C1 += 1 <NEWLINE> <DEDENT> elif S == <STRING> : <NEWLINE> <INDENT> C2 += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> C3 += 1 <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> . format ( C0 ) ) <NEWLINE> print ( <STRING> . format ( C1 ) ) <NEWLINE> print ( <STRING> . format ( C2 ) ) <NEWLINE> print ( <STRING> . format ( C3 ) ) <NEWLINE>
1 N = int ( input ( ) ) <NEWLINE> 2 s = [ input ( ) for i in range ( N ) ] <NEWLINE> 3 for v in [ <STRING> , <STRING> , <STRING> , <STRING> ] : <NEWLINE> 4 print ( <STRING> . format ( v , s . count ( v ) ) ) <NEWLINE>
IN = iter ( Input . split ( <STRING> ) ) . __next__ <NEWLINE> def input ( ) : <NEWLINE> <INDENT> return IN ( ) <NEWLINE> <NL> <NL> <COMMENT> <NL> <NL> <NL> <NL> <NL> <NL> <DEDENT> N = int ( input ( ) ) <NEWLINE> S = list ( input ( ) for _ in range ( N ) ) <NEWLINE> <NL> ac = 0 <NEWLINE> wa = 0 <NEWLINE> tle = 0 <NEWLINE> re = 0 <NEWLINE> <NL> for s in S : <NEWLINE> <INDENT> if s == <STRING> : <NEWLINE> <INDENT> ac += 1 <NEWLINE> <DEDENT> elif s == <STRING> : <NEWLINE> <INDENT> wa += 1 <NEWLINE> <DEDENT> elif s == <STRING> : <NEWLINE> <INDENT> tle += 1 <NEWLINE> <DEDENT> elif s == <STRING> : <NEWLINE> <INDENT> re += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> , ac ) <NEWLINE> print ( <STRING> , wa ) <NEWLINE> print ( <STRING> , tle ) <NEWLINE> print ( <STRING> , re ) <NEWLINE>
x = int ( input ( ) ) <NEWLINE> cac = 0 <NEWLINE> cwa = 0 <NEWLINE> tle = 0 <NEWLINE> cre = 0 <NEWLINE> <NL> for i in range ( 0 , x ) : <NEWLINE> <INDENT> moji = input ( ) <NEWLINE> if ( moji == <STRING> ) : <NEWLINE> <INDENT> cac += 1 <NEWLINE> <DEDENT> if ( moji == <STRING> ) : <NEWLINE> <INDENT> cwa += 1 <NEWLINE> <DEDENT> if ( moji == <STRING> ) : <NEWLINE> <INDENT> ctle += 1 <NEWLINE> <DEDENT> if ( moji == <STRING> ) : <NEWLINE> <INDENT> cre += 1 <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> , cac ) <NEWLINE> print ( <STRING> , cwa ) <NEWLINE> print ( <STRING> , ctle ) <NEWLINE> print ( <STRING> , cre ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = 0 <NEWLINE> w = 0 <NEWLINE> t = 0 <NEWLINE> r = 0 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> ans = input ( ) <NEWLINE> <NL> if ans == <STRING> : <NEWLINE> <INDENT> a += 1 <NEWLINE> <DEDENT> elif ans == <STRING> : <NEWLINE> <INDENT> w += 1 <NEWLINE> <DEDENT> elif ams == <STRING> : <NEWLINE> <INDENT> t += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> r += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> + str ( a ) ) <NEWLINE> print ( <STRING> + str ( w ) ) <NEWLINE> print ( <STRING> + str ( t ) ) <NEWLINE> print ( <STRING> + str ( r ) ) <NEWLINE> <NL>
wa = 0 <NEWLINE> tle = 0 <NEWLINE> re = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> if s == <STRING> : <NEWLINE> <INDENT> ac += 1 <NEWLINE> <DEDENT> elif s == <STRING> : <NEWLINE> <INDENT> wa += 1 <NEWLINE> <DEDENT> elif s == <STRING> : <NEWLINE> <INDENT> tle += 1 <NEWLINE> <DEDENT> elif s == <STRING> : <NEWLINE> <INDENT> re += 1 <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> + str ( ac ) ) <NEWLINE> print ( <STRING> + str ( wa ) ) <NEWLINE> print ( <STRING> + str ( tle ) ) <NEWLINE> print ( <STRING> + str ( re ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S = [ ] * N <NEWLINE> AC = 0 <NEWLINE> WA = 0 <NEWLINE> TLE = 0 <NEWLINE> RE = 0 <NEWLINE> <NL> for n in range ( N ) : <NEWLINE> <INDENT> S [ n ] = input ( ) <NEWLINE> if S [ n ] == <STRING> : <NEWLINE> <INDENT> AC += AC <NEWLINE> <DEDENT> elif S [ n ] == <STRING> : <NEWLINE> <INDENT> WA += WA <NEWLINE> <DEDENT> elif S [ n ] == <STRING> : <NEWLINE> <INDENT> TLE += TLE <NEWLINE> <DEDENT> elif S [ n ] == <STRING> : <NEWLINE> <INDENT> RE += RE <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> . format ( AC , WA , TLE , RE ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> <NL> result = { } <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> result [ s ] = result . get ( s , 0 ) + 1 <NEWLINE> <NL> <DEDENT> print ( <STRING> ) <NEWLINE> print ( <STRING> ) <NEWLINE> print ( <STRING> ) <NEWLINE> print ( <STRING> ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> <NL> import collections <NEWLINE> l = [ ] <NEWLINE> for n in range ( N ) : <NEWLINE> <INDENT> S = input ( ) <NEWLINE> l . append ( S ) <NEWLINE> <NL> <DEDENT> c = collections . Counter ( l ) <NEWLINE> <NL> <NL> print ( <STRING> + c [ <STRING> ] ) <NEWLINE> print ( <STRING> + c [ <STRING> ] ) <NEWLINE> print ( <STRING> + c [ <STRING> ] ) <NEWLINE> print ( <STRING> + c [ <STRING> ] ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> hist = { <STRING> : 0 , <STRING> : 0 , <STRING> : 0 , <STRING> : 0 } <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> tc = input ( ) <NEWLINE> <INDENT> hist [ tc ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> for k in [ <STRING> , <STRING> , <STRING> , <STRING> ] : <NEWLINE> <INDENT> print ( <STRING> , flush = True ) <NEWLINE> <NL> <DEDENT>
a = int ( input ( ) ) <NEWLINE> c [ <STRING> ] = c [ <STRING> ] = c [ <STRING> ] = c [ <STRING> ] = 0 <NEWLINE> for _ in range ( a ) : <NEWLINE> <INDENT> c [ input ( ) ] += 1 <NEWLINE> <DEDENT> print ( <STRING> , en = <STRING> ) <NEWLINE> print ( c [ <STRING> ] ) <NEWLINE> <NL> print ( <STRING> , en = <STRING> ) <NEWLINE> print ( c [ <STRING> ] ) <NEWLINE> <NL> print ( <STRING> , en = <STRING> ) <NEWLINE> print ( c [ <STRING> ] ) <NEWLINE> <NL> print ( <STRING> , en = <STRING> ) <NEWLINE> print ( c [ <STRING> ] ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> judge = { <STRING> : 0 , <STRING> : 0 , <STRING> : 0 , <STRING> : 0 } <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> judge [ i ] += 1 <NEWLINE> <NL> <DEDENT> for j in judge : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> S = [ str ( input ( ) ) for i in range ( N ) ] <NEWLINE> <NL> ac = 0 <NEWLINE> wa = 0 <NEWLINE> tle = 0 <NEWLINE> re = 0 <NEWLINE> for i in S : <NEWLINE> <INDENT> if i == <STRING> : <NEWLINE> <INDENT> ac += 1 <NEWLINE> <DEDENT> elif i == <STRING> : <NEWLINE> <INDENT> wa += 1 <NEWLINE> <DEDENT> elif i = <STRING> : <NEWLINE> <INDENT> tle += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> re += 1 <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> + str ( ac ) ) <NEWLINE> print ( <STRING> + str ( wa ) ) <NEWLINE> print ( <STRING> + str ( tle ) ) <NEWLINE> print ( <STRING> + str ( re ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> a = 0 <NEWLINE> b = 0 <NEWLINE> c = 0 <NEWLINE> d = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if input ( ) == <STRING> : <NEWLINE> <INDENT> a += 1 <NEWLINE> <DEDENT> elif input ( ) == <STRING> : <NEWLINE> <INDENT> b += 1 <NEWLINE> <DEDENT> elif input ( ) == <STRING> : <NEWLINE> <INDENT> c += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d += 1 <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> , a ) <NEWLINE> print ( <STRING> , b ) <NEWLINE> print ( <STRING> , c ) <NEWLINE> print ( <STRING> , d ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> ac = 0 <NEWLINE> wa = 0 <NEWLINE> tle = 0 <NEWLINE> re = 0 <NEWLINE> while True : <NEWLINE> <INDENT> ia = input ( ) <NEWLINE> if ia == <STRING> : <NEWLINE> <INDENT> ac += 1 <NEWLINE> <DEDENT> elif ia == <STRING> : <NEWLINE> <INDENT> wa += 1 <NEWLINE> <DEDENT> elif ia == <STRING> : <NEWLINE> <INDENT> tle += 1 <NEWLINE> <DEDENT> elif ia == <STRING> : <NEWLINE> <INDENT> re += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
loop = int ( input ( ) ) <NEWLINE> ac = 0 <NEWLINE> wa = 0 <NEWLINE> tle = 0 <NEWLINE> re = 0 <NEWLINE> <NL> for _ in range ( loop ) : <NEWLINE> <INDENT> judge = input ( ) <NEWLINE> if judge == <STRING> : <NEWLINE> <INDENT> ac += 1 <NEWLINE> <DEDENT> elif judge == <STRING> : <NEWLINE> <INDENT> wa += 1 <NEWLINE> <DEDENT> elif judge == <STRING> : <NEWLINE> <INDENT> tle += 1 <NEWLINE> <DEDENT> elif judge == <STRING> : <NEWLINE> <NL> <DEDENT> print ( <STRING> . format ( ac ) ) <NEWLINE> print ( <STRING> . format ( wa ) ) <NEWLINE> print ( <STRING> . format ( tle ) ) <NEWLINE> print ( <STRING> . format ( re ) ) <NEWLINE>
<NL> def b ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> AC = 0 <NEWLINE> WA = 0 <NEWLINE> TLE = 0 <NEWLINE> RE = 0 <NEWLINE> while n : <NEWLINE> <INDENT> n -= 1 <NEWLINE> if input ( ) == <STRING> : <NEWLINE> <INDENT> AC += 1 <NEWLINE> <DEDENT> elif input ( ) == <STRING> : <NEWLINE> <INDENT> WA += 1 <NEWLINE> <DEDENT> elif input ( ) == <STRING> : <NEWLINE> <INDENT> TLE += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> RE += 1 <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> % AC ) <NEWLINE> print ( <STRING> % WA ) <NEWLINE> print ( <STRING> % TLE ) <NEWLINE> print ( <STRING> % RE ) <NEWLINE> <DEDENT> b ( ) <NEWLINE> <NL>
from collections imort Counter <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> s = [ input ( ) for _ in range ( n ) ] <NEWLINE> counter = Counter ( s ) <NEWLINE> output = [ <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> <NL> for key in output : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
m = int ( input ( ) ) <NEWLINE> <NL> d = [ input ( ) fot i in range ( m ) ] <NEWLINE> <NL> print ( <STRING> , d . count ( <STRING> ) ) <NEWLINE> print ( <STRING> , d . count ( <STRING> ) ) <NEWLINE> print ( <STRING> , d . count ( <STRING> ) ) <NEWLINE> print ( <STRING> , d . count ( <STRING> ) ) <NEWLINE>
N , * s = map ( open ( 0 ) . read ( ) . split ( ) ) <NEWLINE> for v in ( <STRING> , <STRING> , <STRING> , <STRING> ) : <NEWLINE> <INDENT> print ( <STRING> . format ( v , s . count ( v ) ) ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> a , b , c , d = 0 , 0 , 0 , 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> A = input ( ) <NEWLINE> if A == <STRING> : <NEWLINE> <INDENT> a += 1 <NEWLINE> <DEDENT> elif A == <STRING> : <NEWLINE> <INDENT> b += 1 <NEWLINE> <DEDENT> elif A == <STRING> : <NEWLINE> <INDENT> c += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d += 1 <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> a ) <NEWLINE> print ( <STRING> b ) <NEWLINE> print ( <STRING> c ) <NEWLINE> print ( <STRING> d ) <NEWLINE>
count = input ( ) <NEWLINE> a = 0 <NEWLINE> b = 0 <NEWLINE> c = 0 <NEWLINE> d = 0 <NEWLINE> while count : <NEWLINE> <INDENT> val = input ( ) <NEWLINE> if val == <STRING> : <NEWLINE> <INDENT> a += 1 <NEWLINE> <DEDENT> elif val == <STRING> : <NEWLINE> <INDENT> b += 1 <NEWLINE> <DEDENT> elif val == <STRING> : <NEWLINE> <INDENT> c += 1 <NEWLINE> <DEDENT> elif val == <STRING> : <NEWLINE> <INDENT> d += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> + str ( a ) ) <NEWLINE> print ( <STRING> + str ( b ) ) <NEWLINE> print ( <STRING> + str ( c ) ) <NEWLINE> print ( <STRING> + str ( d ) ) <NEWLINE>
from collections import Counter <NEWLINE> <NL> a = int ( input ( ) ) <NEWLINE> b = [ input ( ) for _ in range ( a ) ] <NEWLINE> for v in [ <STRING> , <STRING> , <STRING> , <STRING> ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> d = { AC : 0 , RE : 0 , WA : 0 , TLE : 0 } <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> s = input ( ) . strip ( ) <NEWLINE> d [ s ] = d [ s ] + 1 <NEWLINE> <DEDENT> print ( <STRING> + str ( d [ AC ] ) ) <NEWLINE> print ( <STRING> + str ( d [ WA ] ) ) <NEWLINE> print ( <STRING> + str ( d [ TLE ] ) ) <NEWLINE> print ( <STRING> + str ( d [ RE ] ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> ac , wa , tle , re = 0 , 0 , 0 , 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> str = input ( str ( ) ) <NEWLINE> if str == <STRING> : <NEWLINE> <INDENT> ac = ac + 1 <NEWLINE> <DEDENT> elif str == <STRING> : <NEWLINE> <INDENT> wa = wa + 1 <NEWLINE> <DEDENT> elif str == <STRING> : <NEWLINE> <INDENT> tle = tle + 1 <NEWLINE> <DEDENT> elif str == <STRING> : <NEWLINE> <INDENT> re = re + 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> , ac ) <NEWLINE> print ( <STRING> , wa ) <NEWLINE> print ( <STRING> , tle ) <NEWLINE> print ( <STRING> , re ) <NEWLINE>
zn = int ( input ( ) ) <NEWLINE> a = 0 <NEWLINE> b = 0 <NEWLINE> c = 0 <NEWLINE> d = 0 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> S = str ( input ( ) ) <NEWLINE> if S == <STRING> : <NEWLINE> <INDENT> a += 1 <NEWLINE> <DEDENT> elif S == <STRING> : <NEWLINE> <INDENT> b += 1 <NEWLINE> <DEDENT> elif S == <STRING> : <NEWLINE> <INDENT> c += 1 <NEWLINE> <DEDENT> elif S == <STRING> : <NEWLINE> <INDENT> d += 1 <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> + str ( a ) ) <NEWLINE> print ( <STRING> + str ( b ) ) <NEWLINE> print ( <STRING> + str ( c ) ) <NEWLINE> print ( <STRING> + str ( d ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> s = [ input ( ) i for in range ( N ) ] <NEWLINE> for v in [ <STRING> , <STRING> , <STRING> , <STRING> ] : <NEWLINE> <INDENT> print ( <STRING> . format ( v , s . count ( v ) ) ) <NEWLINE> <DEDENT>
<NL> def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> cases = dict ( ) <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> cases [ s ] = cases . get ( s , 0 ) + 1 <NEWLINE> <NL> <DEDENT> results = [ <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> <NL> for r in results : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) . rstrip ( ) ) <NEWLINE> s = [ str ( input ( ) . rstrip ( ) z ) for i in range ( n ) ] <NEWLINE> for v in [ <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> ac = 0 <NEWLINE> wa = 0 <NEWLINE> tle = 0 <NEWLINE> re = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> S = input ( ) <NEWLINE> if S == AC : <NEWLINE> <INDENT> ac += 1 <NEWLINE> <DEDENT> elif S == <STRING> : <NEWLINE> <INDENT> wa += 1 <NEWLINE> <DEDENT> elif S == <STRING> : <NEWLINE> <INDENT> tle += 1 <NEWLINE> <DEDENT> elif S == <STRING> : <NEWLINE> <INDENT> re += 1 <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> print ( <STRING> ) <NEWLINE> print ( <STRING> ) <NEWLINE> print ( <STRING> ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S = [ input ( ) for i in range ( N ) ] <NEWLINE> <NL> ac = 0 <NEWLINE> wa = 0 <NEWLINE> tle = 0 <NEWLINE> re = 0 <NEWLINE> for s in S : <NEWLINE> <INDENT> if s == <STRING> : ac += 1 <NEWLINE> elif s == <STRING> : wa += 1 <NEWLINE> elif s == <STRING> : tle += 1 <NEWLINE> elif s == <STRING> : re += 1 <NEWLINE> <NL> <DEDENT> print ( <STRING> + ac ) <NEWLINE> print ( <STRING> + wa ) <NEWLINE> print ( <STRING> + tle ) <NEWLINE> print ( <STRING> + re ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> li = [ 0 ] * 4 <NEWLINE> for _ in n : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> if s == <STRING> : <NEWLINE> <INDENT> li [ 0 ] += 1 <NEWLINE> <DEDENT> elif s == <STRING> : <NEWLINE> <INDENT> li [ 1 ] += 1 <NEWLINE> <DEDENT> elif s == <STRING> : <NEWLINE> <INDENT> li [ 2 ] += 1 <NEWLINE> <DEDENT> elif s == <STRING> : <NEWLINE> <INDENT> li [ 3 ] += 1 <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> , li [ 0 ] ) <NEWLINE> print ( <STRING> , li [ 1 ] ) <NEWLINE> print ( <STRING> , li [ 2 ] ) <NEWLINE> print ( <STRING> , li [ 3 ] ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> list = { <STRING> = 0 , <STRING> = 0 , <STRING> = 0 , <STRING> = 0 } <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> words = input ( ) <NEWLINE> list [ words ] += 1 <NEWLINE> <NL> <DEDENT> print ( <STRING> + str ( list [ <STRING> ] ) ) <NEWLINE> print ( <STRING> + str ( list [ <STRING> ] ) ) <NEWLINE> print ( <STRING> + str ( list [ <STRING> ] ) ) <NEWLINE> print ( <STRING> + str ( list [ <STRING> ] ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> from collections import Counter <NEWLINE> A = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> A . append ( int ( input ( ) ) ) <NEWLINE> <DEDENT> C = Counter ( A ) <NEWLINE> print ( <STRING> ) <NEWLINE>
n = input ( ) <NEWLINE> lol = [ ] <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> lol . append ( input ( ) ) <NEWLINE> <DEDENT> print ( <STRING> , lol . count ( <STRING> ) ) <NEWLINE> print ( <STRING> , lol . count ( <STRING> ) ) <NEWLINE> print ( <STRING> , lol . count ( <STRING> ) ) <NEWLINE> print ( <STRING> , lol . count ( <STRING> ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> l = [ input ( ) for _ in range ( N ) ] <NEWLINE> ch = { <STRING> : 0 , <STRING> : 0 , <STRING> : 0 , <STRING> : 0 } <NEWLINE> <NL> for key , value in ch . items ( ) : <NEWLINE> <INDENT> ch [ key ] = l . count ( key ) <NEWLINE> <NL> <DEDENT> for key , value in ch . items ( ) : <NEWLINE> <INDENT> print ( key + <STRING> + value ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> a = 0 <NEWLINE> w = 0 <NEWLINE> t = 0 <NEWLINE> r = 0 <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> if input ( ) == <STRING> : <NEWLINE> <INDENT> a += 1 <NEWLINE> <DEDENT> elif input ( ) == <STRING> : <NEWLINE> <INDENT> w += 1 <NEWLINE> <DEDENT> elif input ( ) == <STRING> : <NEWLINE> <INDENT> t += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> r += 1 <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> + str ( a ) ) <NEWLINE> print ( <STRING> + str ( w ) ) <NEWLINE> print ( <STRING> + str ( t ) ) <NEWLINE> print ( <STRING> + str ( r ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> s = [ input ( ) for i in range ( N ) ] <NEWLINE> for v in [ <STRING> , <STRING> , <STRING> , <STRING> ] : <NEWLINE> print ( <STRING> . format ( v , s . count ( v ) ) ) <NEWLINE>
C0 = 0 <NEWLINE> C1 = 0 <NEWLINE> C2 = 0 <NEWLINE> C3 = 0 <NEWLINE> N = int ( input ( ) ) <NEWLINE> S = list ( range ( N ) ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> S [ i ] = input ( ) <NEWLINE> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> if S [ i ] == AC : <NEWLINE> <INDENT> C0 += 1 <NEWLINE> <DEDENT> elif S [ i ] == WA : <NEWLINE> <INDENT> C1 += 1 <NEWLINE> <DEDENT> elif S [ i ] == TLE : <NEWLINE> <INDENT> C2 += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> C3 += 1 <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> , <STRING> , C0 ) <NEWLINE> print ( <STRING> , <STRING> , C1 ) <NEWLINE> print ( <STRING> , <STRING> , C2 ) <NEWLINE> print ( <STRING> , <STRING> , C3 ) <NEWLINE>
case = input ( ) <NEWLINE> import numpy as np <NEWLINE> case = np . array ( case ) <NEWLINE> for i in range ( len ( case ) ) : <NEWLINE> <INDENT> AC = 0 <NEWLINE> WA = 0 <NEWLINE> TLE = 0 <NEWLINE> RE = 0 <NEWLINE> others = 0 <NEWLINE> if case [ i ] == <STRING> : <NEWLINE> <INDENT> AC += 1 <NEWLINE> <DEDENT> elif case [ i ] == <STRING> : <NEWLINE> <INDENT> WA += 1 <NEWLINE> <DEDENT> elif case [ i ] == <STRING> : <NEWLINE> <INDENT> TLE += 1 <NEWLINE> <DEDENT> elif case [ i ] == <STRING> : <NEWLINE> <INDENT> RE += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> others += 1 <NEWLINE> <DEDENT> return AC , WA , TLE , RE , others <NEWLINE> <DEDENT> print ( <STRING> + <STRING> + AC ) <NEWLINE> print ( <STRING> + <STRING> + WA ) <NEWLINE> print ( <STRING> + <STRING> + TLE ) <NEWLINE> print ( <STRING> + <STRING> + RE ) <NEWLINE>
N = input ( ) <NEWLINE> result = [ ] <NEWLINE> for i in range ( 0 , ( N ) ) : <NEWLINE> <INDENT> A = input ( ) <NEWLINE> if A : <NEWLINE> <INDENT> result . append ( A ) <NEWLINE> <DEDENT> <DEDENT> AC = result . count ( <STRING> ) <NEWLINE> WA = result . count ( <STRING> ) <NEWLINE> TLE = result . count ( <STRING> ) <NEWLINE> RE = result . count ( <STRING> ) <NEWLINE> print ( <STRING> ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = list ( int ( input ( ) ) for i in range ( n ) ) <NEWLINE> print ( <STRING> , s . count ( <STRING> ) ) <NEWLINE> print ( <STRING> , s . count ( <STRING> ) ) <NEWLINE> print ( <STRING> , s . count ( <STRING> ) ) <NEWLINE> print ( <STRING> , s . count ( <STRING> ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> st = [ input ( ) for i in range ( N ) ] <NEWLINE> print ( <STRING> + str ( st . count ( <STRING> ) ) ) <NEWLINE> print ( <STRING> + str ( st . count ( <STRING> ) ) ) <NEWLINE> print ( <STRING> + str ( st . count ( <STRING> ) ) ) <NEWLINE> print ( <STRING> + str ( st . count ( <STRING> ) ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> 2 s = [ input ( ) for i in range ( N ) ] <NEWLINE> 3 for v in [ <STRING> , <STRING> , <STRING> , <STRING> ] : <NEWLINE> 4 print ( <STRING> . format ( v , s . count ( v ) ) ) <NEWLINE>
n = int ( intput ( ) ) <NEWLINE> a = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a . append ( input ( ) ) <NEWLINE> <DEDENT> print ( <STRING> + str ( a . count ( <STRING> ) ) ) <NEWLINE> print ( <STRING> + str ( a . count ( <STRING> ) ) ) <NEWLINE> print ( <STRING> + str ( a . count ( <STRING> ) ) ) <NEWLINE> print ( <STRING> + str ( a . count ( <STRING> ) ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> list = [ ] <NEWLINE> c1 , c2 , c3 , c4 = 0 , 0 , 0 , 0 <NEWLINE> for i in n : <NEWLINE> <INDENT> list . append ( input ( ) ) <NEWLINE> <DEDENT> for j in n : <NEWLINE> <INDENT> if list [ j ] == <STRING> : <NEWLINE> <INDENT> c1 = c1 + 1 <NEWLINE> <DEDENT> if list [ j ] == <STRING> : <NEWLINE> <INDENT> c2 = c2 + 1 <NEWLINE> <DEDENT> if list [ j ] == <STRING> : <NEWLINE> <INDENT> c3 = c3 + 1 <NEWLINE> <DEDENT> if list [ j ] == <STRING> : <NEWLINE> <INDENT> c4 = c4 + 1 <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> ac = 0 <NEWLINE> wa = 0 <NEWLINE> tle = 0 <NEWLINE> re = 0 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> num = str ( input ( ) ) <NEWLINE> if num == <STRING> : <NEWLINE> <INDENT> ac += 1 <NEWLINE> <DEDENT> elif num == <STRING> : <NEWLINE> <INDENT> wa += 1 <NEWLINE> <DEDENT> elif num == <STRING> : <NEWLINE> <INDENT> tle += 1 <NEWLINE> <DEDENT> else num == <STRING> : <NEWLINE> <INDENT> re += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> . format ( ac ) ) <NEWLINE> print ( <STRING> . format ( wa ) ) <NEWLINE> print ( <STRING> . format ( tle ) ) <NEWLINE> print ( <STRING> . format ( re ) ) <NEWLINE>
from collections import Counter <NEWLINE> li = [ ] <NEWLINE> for i in range ( int ( input ( ) ) : <NEWLINE> <INDENT> li . append ( input ( ) ) <NEWLINE> <DEDENT> d = Counter ( li ) <NEWLINE> print ( <STRING> , <STRING> , d [ <STRING> ] ) <NEWLINE> print ( <STRING> , <STRING> , d [ <STRING> ] ) <NEWLINE> print ( <STRING> , <STRING> , d [ <STRING> ] ) <NEWLINE> print ( <STRING> , <STRING> , d [ <STRING> ] ) <NEWLINE>
1 N = int ( input ( ) ) <NEWLINE> 2 s = [ input ( ) for i in range ( N ) ] <NEWLINE> 3 for v in [ <STRING> , <STRING> , <STRING> , <STRING> ] : <NEWLINE> 4 print ( <STRING> . format ( v , s . count ( v ) ) ) <NEWLINE>
defB ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> s = [ list ( map ( str , input ( ) . split ( ) ) ) for i in range ( n ) ] <NEWLINE> import collections <NEWLINE> c = collections . Counter ( s ) <NEWLINE> ret_l = [ <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> for t in ret_l : <NEWLINE> <INDENT> print ( t + <STRING> + str ( c [ t ] ) ) <NEWLINE> <DEDENT> <DEDENT> B ( ) <NEWLINE>
k = [ <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> n = int ( input ( ) ) <NEWLINE> ans = { } <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> r = input ( ) <NEWLINE> ans [ r ] = ans . get ( r , 0 ) + 1 <NEWLINE> <DEDENT> for r in k : <NEWLINE> <INDENT> print ( r , <STRING> , ans [ r ] . get ( r , 0 ) ) <NEWLINE> <DEDENT>
cnt = { <STRING> : 0 , <STRING> : 0 , <STRING> : 0 , <STRING> : 0 } <NEWLINE> for i in range ( int ( input ( ) ) : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> cnt [ s ] += 1 <NEWLINE> <DEDENT> for i in [ <STRING> , <STRING> , <STRING> , <STRING> ] : <NEWLINE> <INDENT> print ( <STRING> <NEWLINE> <NL> <DEDENT>
n = int ( input ( ) ) <NEWLINE> inp = { } <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a = input ( ) <NEWLINE> if inp . get ( a ) is None : <NEWLINE> <INDENT> inp [ a ] = 0 <NEWLINE> <DEDENT> inp [ a ] += 1 <NEWLINE> <NL> print ( <STRING> ) <NEWLINE> print ( <STRING> ) <NEWLINE> print ( <STRING> ) <NEWLINE> print ( <STRING> ) <NEWLINE> <DEDENT>
import sys <NEWLINE> from collections import defaultdict <NEWLINE> from typing import Callable <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> readline : Callable [ [ ] , str ] = sys . stdin . readline <NEWLINE> <NL> memory : defaultdict = defaultdict ( int ) <NEWLINE> <NL> n : int = int ( readline ( ) . rstrip ( ) ) <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> s : str = readline ( ) . rstrip ( ) <NEWLINE> memory [ s ] += 1 <NEWLINE> <NL> <DEDENT> for judge in ( <STRING> , <STRING> , <STRING> , <STRING> ) ; <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> <NL> ans = [ 0 ] * 4 <NEWLINE> for n in range ( n ) : <NEWLINE> <INDENT> C = input ( ) <NEWLINE> if C = <STRING> : <NEWLINE> <INDENT> ans [ 0 ] += 1 <NEWLINE> <DEDENT> elif C = <STRING> : <NEWLINE> <INDENT> ans [ 1 ] += 1 <NEWLINE> <DEDENT> elif C = <STRING> : <NEWLINE> <INDENT> ans [ 2 ] += 1 <NEWLINE> <DEDENT> elif C = <STRING> : <NEWLINE> <INDENT> ans [ 3 ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> . format ( ans [ 0 ] ) ) <NEWLINE> print ( <STRING> . format ( ans [ 1 ] ) ) <NEWLINE> print ( <STRING> . format ( ans [ 2 ] ) ) <NEWLINE> print ( <STRING> . format ( ans [ 3 ] ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> word = input ( ) <NEWLINE> <INDENT> if word == <STRING> : <NEWLINE> <INDENT> AC += 1 <NEWLINE> <DEDENT> if word == <STRING> : <NEWLINE> <INDENT> WA += 1 <NEWLINE> <DEDENT> if word == <STRING> : <NEWLINE> <INDENT> TLE += 1 <NEWLINE> <DEDENT> if word == <STRING> : <NEWLINE> <INDENT> RE += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> + AC ) <NEWLINE> print ( <STRING> + WA ) <NEWLINE> print ( <STRING> + TLE ) <NEWLINE> print ( <STRING> + RE ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = 0 <NEWLINE> b = 0 <NEWLINE> c = 0 <NEWLINE> d = 0 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> S = str ( input ( ) ) <NEWLINE> if S == <STRING> : <NEWLINE> <INDENT> a += 1 <NEWLINE> <DEDENT> if S == <STRING> : <NEWLINE> <INDENT> b += 1 <NEWLINE> <DEDENT> if S == <STRING> : <NEWLINE> <INDENT> c += 1 <NEWLINE> <DEDENT> if S == <STRING> : <NEWLINE> <INDENT> d += 1 <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> + str ( a ) <NEWLINE> print ( <STRING> + str ( b ) ) <NEWLINE> print ( <STRING> + str ( c ) ) <NEWLINE> print ( <STRING> + str ( d ) ) <NEWLINE>
<NL> <NL> <NL> N = int ( input ( ) ) <NEWLINE> cnt = [ 0 ] * 4 <NEWLINE> for n in range ( N ) : <NEWLINE> <INDENT> s = int ( input ( ) ) <NEWLINE> if s == <STRING> : <NEWLINE> <INDENT> cnt [ 0 ] += 1 <NEWLINE> <DEDENT> elif s == <STRING> : <NEWLINE> <INDENT> cnt [ 1 ] += 1 <NEWLINE> <DEDENT> elif s == <STRING> : <NEWLINE> <INDENT> cnt [ 2 ] += 1 <NEWLINE> <DEDENT> elif s == <STRING> : <NEWLINE> <INDENT> cnt [ 3 ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> , cnt [ 0 ] ) <NEWLINE> print ( <STRING> , cnt [ 1 ] ) <NEWLINE> print ( <STRING> , cnt [ 2 ] ) <NEWLINE> print ( <STRING> , cnt [ 3 ] ) <NEWLINE> <NL>
def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> AC = 0 <NEWLINE> WA = 0 <NEWLINE> TLE = 0 <NEWLINE> RE = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> St = input ( ) <NEWLINE> if St == <STRING> : <NEWLINE> <INDENT> AC += 1 <NEWLINE> <DEDENT> elif St == <STRING> : <NEWLINE> <INDENT> WA += 1 <NEWLINE> <DEDENT> elif St == <STRING> : <NEWLINE> <INDENT> TLE += 1 <NEWLINE> <DEDENT> elif St == <STRING> : <NEWLINE> <INDENT> RE += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <NL> <DEDENT> print ( <STRING> + str ( AC ) ) <NEWLINE> print ( <STRING> + str ( WA ) ) <NEWLINE> print ( <STRING> + str ( TLE ) ) <NEWLINE> print ( <STRING> + str ( RE ) ) <NEWLINE> <DEDENT> main ( ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> C0 = 0 <NEWLINE> C1 = 0 <NEWLINE> C2 = 0 <NEWLINE> C3 = 0 <NEWLINE> <NL> for A in N : <NEWLINE> <INDENT> str = input ( ) <NEWLINE> if str == <STRING> : <NEWLINE> <INDENT> C0 += 1 <NEWLINE> <DEDENT> if str == <STRING> : <NEWLINE> <INDENT> C1 += 1 <NEWLINE> <DEDENT> if str == <STRING> : <NEWLINE> <INDENT> C2 += 1 <NEWLINE> <DEDENT> if str == <STRING> : <NEWLINE> <INDENT> C3 += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> + str ( C0 ) ) <NEWLINE> print ( <STRING> + str ( C1 ) ) <NEWLINE> print ( <STRING> + str ( C2 ) ) <NEWLINE> print ( <STRING> + str ( C3 ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> ac = 0 <NEWLINE> wa = 0 <NEWLINE> tle = 0 <NEWLINE> re = 0 <NEWLINE> for i range ( n ) : <NEWLINE> <INDENT> x = input ( ) <NEWLINE> if x == <STRING> : <NEWLINE> <INDENT> ac += 1 <NEWLINE> <DEDENT> if x == <STRING> : <NEWLINE> <INDENT> wa += 1 <NEWLINE> <DEDENT> if x == <STRING> : <NEWLINE> <INDENT> tle += 1 <NEWLINE> <DEDENT> if x == <STRING> : <NEWLINE> <INDENT> re += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> . format ( ac ) ) <NEWLINE> print ( <STRING> . format ( wa ) ) <NEWLINE> print ( <STRING> . format ( tle ) ) <NEWLINE> print ( <STRING> . format ( re ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> AC = 0 <NEWLINE> WA = 0 <NEWLINE> TLE = 0 <NEWLINE> RE = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> tmp = input ( ) <NEWLINE> if ( tmp == <STRING> ) : <NEWLINE> <INDENT> AC += 1 <NEWLINE> <DEDENT> if ( tmp == <STRING> ) : <NEWLINE> <INDENT> WA += 1 <NEWLINE> <DEDENT> if ( tmp == <STRING> ) : <NEWLINE> <INDENT> TLE += 1 <NEWLINE> <DEDENT> if ( tmp == <STRING> ) <NEWLINE> <INDENT> RE += 1 <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> + str ( AC ) ) <NEWLINE> print ( <STRING> + str ( WA ) ) <NEWLINE> print ( <STRING> + str ( TLE ) ) <NEWLINE> print ( <STRING> + str ( RE ) ) <NEWLINE>
a = [ input ( ) for _ in range ( int ( input ( ) ) ) ] <NEWLINE> print ( <STRING> . format ( a . count ( <STRING> ) ) <NEWLINE> print ( <STRING> . format ( a . count ( <STRING> ) ) <NEWLINE> print ( <STRING> . format ( a . count ( <STRING> ) ) <NEWLINE> print ( <STRING> . format ( a . count ( <STRING> ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = [ input ( ) ) for i in range ( n ) ] <NEWLINE> <NL> c0 , c1 , c2 , c3 = 0 , 0 , 0 , 0 <NEWLINE> <NL> for output in a : <NEWLINE> <INDENT> if output == <STRING> : <NEWLINE> <INDENT> c0 += 1 <NEWLINE> <DEDENT> elif output == <STRING> : <NEWLINE> <INDENT> c1 += 1 <NEWLINE> <DEDENT> elif output == <STRING> : <NEWLINE> <INDENT> c2 += 1 <NEWLINE> <DEDENT> elif output == <STRING> : <NEWLINE> <INDENT> c3 += 1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> print ( <STRING> . format ( c0 ) ) <NEWLINE> print ( <STRING> . format ( c1 ) ) <NEWLINE> print ( <STRING> . format ( c2 ) ) <NEWLINE> print ( <STRING> . format ( c3 ) ) <NEWLINE>
L = [ ] <NEWLINE> for i in range ( int ( input ) ) : <NEWLINE> <INDENT> l . append ( input ( ) ) <NEWLINE> <DEDENT> for j in [ <STRING> , <STRING> , <STRING> , <STRING> ] : <NEWLINE> <INDENT> print ( L . count ( j ) ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> judge_list = [ ] <NEWLINE> judge = [ <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> judge_list . append ( str ( input ( ) ) ) <NEWLINE> <DEDENT> for k in judge : <NEWLINE> <INDENT> judge_dict [ k ] = judge_list . count ( k ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> print ( <STRING> ) <NEWLINE> print ( <STRING> ) <NEWLINE> print ( <STRING> ) <NEWLINE>
n = input ( ) <NEWLINE> <NL> s = [ input ( ) for _ in range ( n ) ] <NEWLINE> <NL> print ( <STRING> , s . count ( <STRING> ) ) <NEWLINE> print ( <STRING> , s . count ( <STRING> ) ) <NEWLINE> print ( <STRING> , s . count ( <STRING> ) ) <NEWLINE> print ( <STRING> , s . count ( <STRING> ) ) <NEWLINE>
count = { <STRING> : 0 , <STRING> : 0 , <STRING> : 0 , <STRING> : 0 } <NEWLINE> n = int ( input ) <NEWLINE> for i in range ( 0 , n ) : <NEWLINE> <INDENT> count [ input ( ) ] += 1 <NEWLINE> <DEDENT> ptrint ( <STRING> + str ( count [ <STRING> ] ) ) <NEWLINE> ptrint ( <STRING> + str ( count [ <STRING> ] ) ) <NEWLINE> ptrint ( <STRING> + str ( count [ <STRING> ] ) ) <NEWLINE> ptrint ( <STRING> + str ( count [ <STRING> ] ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> x = list ( ) <NEWLINE> for i in range n : <NEWLINE> <INDENT> x . append ( input ( ) ) <NEWLINE> <DEDENT> print ( <STRING> , x . count ( <STRING> ) ) <NEWLINE> print ( <STRING> , x . count ( <STRING> ) ) <NEWLINE> print ( <STRING> , x . count ( <STRING> ) ) <NEWLINE> print ( <STRING> , x . count ( <STRING> ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> ACs = 0 <NEWLINE> WAs = 0 <NEWLINE> TLEs = 0 <NEWLINE> REs = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> result = input ( ) <NEWLINE> if result == <STRING> : <NEWLINE> <INDENT> ACs += 1 <NEWLINE> <DEDENT> elif result == <STRING> : <NEWLINE> <INDENT> WAs += 1 <NEWLINE> <DEDENT> elif result == <STRING> : <NEWLINE> <INDENT> TLEs += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> REs += 1 <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> + ACs ) <NEWLINE> print ( <STRING> + WAs ) <NEWLINE> print ( <STRING> + TLEs ) <NEWLINE> print ( <STRING> + REs ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> list = [ 0 , 0 , 0 , 0 ] <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> judge = input ( ) <NEWLINE> if judge == = <STRING> : <NEWLINE> <INDENT> list [ 0 ] += 1 <NEWLINE> <DEDENT> elif judge == = <STRING> : <NEWLINE> <INDENT> list [ 1 ] += 1 <NEWLINE> <DEDENT> elif judge == = <STRING> : <NEWLINE> <INDENT> list [ 2 ] += 1 <NEWLINE> <DEDENT> elif judge == = <STRING> : <NEWLINE> <INDENT> list [ 3 ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> . format ( list [ 0 ] ) ) <NEWLINE> print ( <STRING> . format ( list [ 1 ] ) ) <NEWLINE> print ( <STRING> . format ( list [ 2 ] ) ) <NEWLINE> print ( <STRING> . format ( list [ 3 ] ) ) <NEWLINE>
N = [ ] <NEWLINE> L = [ input ( ) for i in range ( N ) ] <NEWLINE> <NL> print ( <STRING> + <STRING> + str ( L . count ( <STRING> ) ) ) <NEWLINE> print ( <STRING> + <STRING> + str ( L . count ( <STRING> ) ) ) <NEWLINE> print ( <STRING> + <STRING> + str ( L . count ( <STRING> ) ) ) <NEWLINE> print ( <STRING> + <STRING> + str ( L . count ( <STRING> ) ) ) <NEWLINE>
h , w , k = map ( int , input ( ) . split ( ) ) <NEWLINE> board = [ list ( input ( ) ) for _ in range ( h ) ] <NEWLINE> ans = 0 <NEWLINE> for paint_h in range ( 2 ** h ) : <NEWLINE> <INDENT> for paint_w in range ( 2 ** w ) : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> for i in range ( h ) : <NEWLINE> <INDENT> for j in range ( w ) : <NEWLINE> <INDENT> if ( paint_h >> i ) & 1 == 0 and ( paint_w >> j ) & 1 == 0 : <NEWLINE> <INDENT> if board [ i ] [ j ] == <STRING> : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if cnk == l : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <NL> <NL> h , w , k = [ int ( x ) for x in input . split ( ) ] <NEWLINE> ans = 0 <NEWLINE> <NL> grid = [ ] <NEWLINE> <NL> for i in range ( h ) : <NEWLINE> <INDENT> grid . append ( input . split ( ) ) <NEWLINE> <NL> <DEDENT> black = 0 <NEWLINE> <NL> for maskRow in range ( 0 , 1 << h ) : <NEWLINE> <INDENT> for maskCol in range ( 0 , 1 << w ) : <NEWLINE> <INDENT> black = 0 <NEWLINE> for i in range ( h ) : <NEWLINE> <INDENT> for j in range ( w ) : <NEWLINE> <INDENT> if ( maskRow >> i ) & 1 == 0 and ( maskCol >> j ) & 1 == 0 and grid [ i ] [ j ] == <STRING> : <NEWLINE> <INDENT> black += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if black == k : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from itertools import product <NEWLINE> H , W , K = map ( int , input ( ) . split ( ) ) <NEWLINE> c = [ list ( input ( ) ) for _ in range ( H ) ] <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> for row_bit in product ( range ( 2 ) , repeat = H ) : <NEWLINE> <INDENT> for col_bit in product ( range ( 2 ) , repeat = H ) : <NEWLINE> <INDENT> count = 0 <NEWLINE> for h in range ( H ) : <NEWLINE> <INDENT> for w in range ( W ) : <NEWLINE> <INDENT> if c [ h ] [ w ] == <STRING> and ( row_bit [ h ] == 0 and col_bit [ w ] == 0 ) : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if count == K : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
h , w , k = map ( int , input ( ) . split ( ) ) <NEWLINE> c = [ input ( ) for _ in range ( h ) ] <NEWLINE> <NL> count = 0 <NEWLINE> for binh in range ( 2 ** h ) : <NEWLINE> <INDENT> for binw in range ( 2 ** w ) : <NEWLINE> <INDENT> redh , redw = bin ( binh ) [ 2 : ] , bin ( binw ) [ 2 : ] <COMMENT> <NEWLINE> squares = [ list ( row ) for row in c ] <NEWLINE> for rh in redh : <NEWLINE> <INDENT> for wh in range ( w ) : <NEWLINE> <INDENT> squares [ rh ] [ wh ] = <STRING> <NEWLINE> <DEDENT> <DEDENT> for rw in redw : <NEWLINE> <INDENT> for hw in range ( h ) : <NEWLINE> <INDENT> squares [ rw ] [ hw ] = <STRING> <NEWLINE> <DEDENT> <DEDENT> count += sum ( row . count ( <STRING> ) for row in squares ) == k <NEWLINE> <NL> <DEDENT> <DEDENT> print ( k ) <NEWLINE>
import copy <NEWLINE> s = 0 <NEWLINE> a = 0 <NEWLINE> H , W , K = map ( int , input ( ) . split ( ) ) <NEWLINE> L = [ [ 0 for j in range ( W ) ] for i in range ( H ) ] <NEWLINE> for i in range ( H ) : <NEWLINE> <INDENT> c = list ( input ( ) . split ( ) ) <NEWLINE> L [ i ] = c <NEWLINE> <DEDENT> for i in range ( 2 ** ( H + W ) ) : <NEWLINE> <INDENT> c = bin ( i ) [ 2 : ] <NEWLINE> T = copy . deepcopy ( L ) <NEWLINE> for k in range ( len ( c ) ) : <NEWLINE> <INDENT> if c [ k ] is None : <NEWLINE> <INDENT> print ( c , k ) <NEWLINE> <DEDENT> if c [ k ] == <STRING> and k < H : <NEWLINE> <INDENT> T [ k ] = [ 0 ] * W <NEWLINE> <DEDENT> if c [ k ] == <STRING> and k >= H : <NEWLINE> <INDENT> for n in range ( H ) : <NEWLINE> <INDENT> T [ n ] [ k - H ] = 0 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> for j in range ( H * W ) : <NEWLINE> <INDENT> if j % W == 0 : <NEWLINE> <INDENT> if T [ ( j // W ) - 1 ] [ - 1 ] == <STRING> : <NEWLINE> <INDENT> a += 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if T [ j // W ] [ ( j % W ) - 1 ] == <STRING> : <NEWLINE> <INDENT> a += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if a == K : <NEWLINE> <INDENT> s += 1 <NEWLINE> <DEDENT> a = 0 <NEWLINE> <DEDENT> print ( s ) <NEWLINE>
H , W , K = map ( int , input ( ) . split ( ) ) <NEWLINE> lis = [ ] <NEWLINE> ans = 0 <NEWLINE> for i in range ( H ) : <NEWLINE> <INDENT> lis . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <DEDENT> for i in range ( 1 << H ) : <NEWLINE> <INDENT> for j in range ( 1 << W ) : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> for p in range ( H ) : <NEWLINE> <INDENT> for q in range ( W ) : <NEWLINE> <INDENT> if ( i >> p ) & 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if ( j >> q ) & 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if lis [ p ] [ q ] == <STRING> : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if cnt == K : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
h , w , k = map ( int , input ( ) . split ( ) ) <NEWLINE> grid = [ input ( ) for _ in range ( h ) ] <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 << h ) : <NEWLINE> <INDENT> for j in range ( 1 << w ) : <NEWLINE> <INDENT> count = 0 <NEWLINE> for x in range ( h ) : <NEWLINE> <INDENT> if i >> n & i : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> for y in range ( w ) : <NEWLINE> <INDENT> if j >> m & 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if grid [ x ] [ y ] == <STRING> : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if count == k : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import numpy as np <NEWLINE> import copy <NEWLINE> <NL> H , W , K = map ( int , input ( ) . split ( ) ) <NEWLINE> if H == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif W = 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d = list ( map ( str , input ( ) . split ( ) ) ) <NEWLINE> X = list ( d [ 0 ] ) <NEWLINE> for i in range ( H - 1 ) : <NEWLINE> <INDENT> d = list ( map ( str , input ( ) . split ( ) ) ) <NEWLINE> d = list ( d [ 0 ] ) <NEWLINE> X = np . vstack ( ( X , d ) ) <NEWLINE> <NL> <DEDENT> black = 0 <NEWLINE> for i in range ( X . shape [ 0 ] ) : <NEWLINE> <INDENT> for j in range ( X . shape [ 1 ] ) : <NEWLINE> <INDENT> if X [ i , j ] == <STRING> : <NEWLINE> <INDENT> black += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> t = 0 <NEWLINE> s1 = <STRING> + str ( H ) + <STRING> <NEWLINE> s2 = <STRING> + str ( W ) + <STRING> <NEWLINE> for i in range ( 2 ** H ) : <NEWLINE> <INDENT> for j in range ( 2 ** W ) : <NEWLINE> <NL> <INDENT> XX = copy . copy ( X ) <NEWLINE> black_xx = black <NEWLINE> HH = format ( i , s1 ) <NEWLINE> WW = format ( j , s2 ) <NEWLINE> <NL> for ii in range ( H ) : <NEWLINE> <INDENT> if HH [ ii ] == <STRING> : <NEWLINE> <INDENT> for iii in range ( W ) : <NEWLINE> <INDENT> if XX [ ii , iii ] == <STRING> : <NEWLINE> <INDENT> black_xx -= 1 <NEWLINE> XX [ ii , iii ] = <STRING> <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for jj in range ( W ) : <NEWLINE> <INDENT> if WW [ jj ] == <STRING> : <NEWLINE> <INDENT> for jjj in range ( H ) : <NEWLINE> <INDENT> if XX [ jjj , jj ] == <STRING> : <NEWLINE> <INDENT> black_xx -= 1 <NEWLINE> XX [ jjj , jj ] = <STRING> <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if black_xx == K : <NEWLINE> <INDENT> t += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( t ) <NEWLINE> <DEDENT>
<INDENT> h0 , w0 , k0 = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> buf = { } <NEWLINE> for i in range ( h0 ) : <NEWLINE> <INDENT> buf [ 1 << i ] = { 1 << j for j , x in enumerate ( input ( ) ) if x == <STRING> } <NEWLINE> <DEDENT> found = 0 <NEWLINE> for i in range ( 1 , 1 << h0 ) : <NEWLINE> <INDENT> idx = { } <NEWLINE> for k , v in buf . items ( ) : <NEWLINE> <INDENT> if k & i == 0 : continue <NEWLINE> for v in vs : idx [ v ] = idx . get ( v , 0 ) + 1 <NEWLINE> <DEDENT> for j in range ( 1 , 1 << w0 ) : <NEWLINE> <INDENT> n = sum ( [ v for k , v in idx . items ( ) if k & j ] ) <NEWLINE> if n == k0 : found += 1 <NEWLINE> <DEDENT> <DEDENT> print ( found ) <NEWLINE> <DEDENT>
H , W , K = map ( int , input ( ) . split ( ) ) <NEWLINE> G = [ list ( input ( ) ) for _ in range ( H ) ] <NEWLINE> for rows in range ( 2 ** H ) : <NEWLINE> <INDENT> for cols in range ( 2 ** W ) : <NEWLINE> <INDENT> black = 0 <NEWLINE> for i in range ( H ) : <NEWLINE> <INDENT> if rows >> i & 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> for j in range ( W ) : <NEWLINE> <INDENT> if cols >> j & 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if G [ i ] [ j ] == <STRING> : <NEWLINE> <INDENT> black += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if black == K : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
H , W , K = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> C = [ ] * H <NEWLINE> ans = 0 <NEWLINE> for i in range ( H ) : <NEWLINE> <INDENT> C [ i ] = list ( input ( ) ) <NEWLINE> <DEDENT> for paint_h in range ( 2 ** H ) : <NEWLINE> <INDENT> for paint_w in range ( 2 ** W ) : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> for i in range ( H ) : <NEWLINE> <INDENT> for j in range ( W ) : <NEWLINE> <INDENT> if ( paint_h << i ) & 1 == 0 and ( paint_w << j ) & 1 == 0 : <NEWLINE> <INDENT> if C [ i ] [ j ] == <STRING> : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if cnt == K : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
h , w , k = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> for _ in range ( h ) : <NEWLINE> <INDENT> c = list ( input ( ) ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> <NL> for i in range ( h ) : <NEWLINE> <INDENT> for j in range ( w ) : <NEWLINE> <INDENT> count = 0 <NEWLINE> for m in range ( h ) : <NEWLINE> <INDENT> for l in range ( w ) : <NEWLINE> <INDENT> if ( i >> m ) & 1 == 0 and ( j >> l ) & 1 == 0 and c [ m ] [ l ] == <STRING> : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if count == k : ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from itertools import product <NEWLINE> <NL> h , w , k = map ( int , input ( ) . split ( ) ) <NEWLINE> c = [ list ( input ( ) ) for _ in range ( h ) ] <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> for row_bit in product ( range ( 2 ) , repeat = h ) : <NEWLINE> <INDENT> for col_bit in product ( range ( 2 ) , repeat = w ) : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> for row in range ( h ) : <NEWLINE> <INDENT> for col in range ( w ) : <NEWLINE> <INDENT> if c [ row ] [ col ] == <STRING> and ( row_bit [ row ] and col_bit [ col ] ) : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if cnt == k : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import itertools <NEWLINE> <NL> h , w , k = map ( int , input ( ) . split ( ) ) <NEWLINE> c = [ list ( input ( ) ) for _ in range ( h ) ] <NEWLINE> r = [ ] <NEWLINE> s = 0 <NEWLINE> ans = 0 <NEWLINE> for i in c : <NEWLINE> <INDENT> s += i . count ( <STRING> ) <NEWLINE> <DEDENT> if s == k : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> quit ( ) <NEWLINE> <DEDENT> for i in range ( w ) : <NEWLINE> <INDENT> row = [ ] <NEWLINE> for j in range ( h ) : <NEWLINE> <INDENT> if c [ j ] [ i ] == <STRING> and <NEWLINE> row . append ( c [ j ] [ i ] ) <NEWLINE> <DEDENT> r . append ( row ) <NEWLINE> <DEDENT> re = c + r <NEWLINE> for i in range ( 1 , len ( re ) ) : <NEWLINE> <INDENT> combs = itertools . combinations ( re , i ) <NEWLINE> for j in list ( combs ) : <NEWLINE> <INDENT> if ( s - sum ( j ) ) == k : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import itertools <NEWLINE> import numpy as np <NEWLINE> <NL> N , W , K = map ( int , input ( ) . split ( ) ) <NEWLINE> g_all = np . array ( [ list ( input ( ) ) for i in range ( N ) ] ) <NEWLINE> <NL> K_all = np . count_nonzero ( g_all == <STRING> ) <NEWLINE> count = 0 <NEWLINE> <NL> def dfs ( i , g ) : <NEWLINE> <INDENT> if ( i < N ) : <NEWLINE> <INDENT> g [ i , : ] = [ <STRING> ] * W <NEWLINE> else : <NEWLINE> <INDENT> g [ : , i - N ] = [ <STRING> ] * N <NEWLINE> return g <NEWLINE> <NL> <DEDENT> g = g_all <NEWLINE> <NL> for L in range ( 2 ** ( N + W ) ) : <NEWLINE> <INDENT> g = g_all . copy ( ) <NEWLINE> for i in range ( N + W ) : <NEWLINE> <INDENT> if ( i < N ) : <NEWLINE> <INDENT> if ( ( L >> i ) & 1 ) : <NEWLINE> <INDENT> g [ i , : ] = [ <STRING> ] * W <NEWLINE> else : <NEWLINE> <INDENT> if ( ( L >> i ) & 1 ) : <NEWLINE> <INDENT> g [ : , i - N ] = [ <STRING> ] * N <NEWLINE> if np . count_nonzero ( g == <STRING> ) == K : <NEWLINE> <INDENT> count += 1 <NEWLINE> print ( count ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT>
hlst10 = [ j for j in range ( 2 ** h ) ] <NEWLINE> hlst2 = [ format ( k , <STRING> . format ( h ) ) for k in hlst10 ] <NEWLINE> <COMMENT> <NL> <NL> wlst10 = [ l for l in range ( 2 ** w ) ] <NEWLINE> wlst2 = [ format ( m , <STRING> . format ( w ) ) for m in wlst10 ] <NEWLINE> <COMMENT> <NL> <NL> ans = 0 <NEWLINE> for o in hlst10 : <NEWLINE> <INDENT> for p in wlst10 : <NEWLINE> <INDENT> black = 0 <NEWLINE> nowhlst = hlst2 [ o ] <NEWLINE> nowwlst = wlst2 [ p ] <NEWLINE> for q in range ( h ) : <NEWLINE> <INDENT> for r in range ( w ) : <NEWLINE> <INDENT> if nowhlst [ q ] == <STRING> and nowwlst [ r ] == <STRING> and test [ q ] [ r ] == <STRING> : <NEWLINE> <INDENT> black += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if black == n : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
h , w , k = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> masu = [ input ( ) for _ in range ( h ) ] <NEWLINE> ans = 0 <NEWLINE> for mark_h in range ( 2 ** h ) : <NEWLINE> <INDENT> for mark_w in range ( 2 ** w ) : <NEWLINE> <INDENT> black = 0 <NEWLINE> for i in range ( h ) : <NEWLINE> <INDENT> for j in range ( w ) : <NEWLINE> <INDENT> if ( mark_h >> i ) & 1 == 1 and ( mark_w >> j ) & 1 == 1 : <NEWLINE> <INDENT> if c [ i ] [ j ] == <STRING> : <NEWLINE> <INDENT> black += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if black = k : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import itertools <NEWLINE> <NL> H , W , K = map ( int , input ( ) . split ( ) ) <NEWLINE> c = [ [ <STRING> for j in range ( 6 ) ] for i in range ( 6 ) ] <NEWLINE> for i in range ( H ) : <NEWLINE> <INDENT> tmp = str ( input ( ) ) <NEWLINE> for j in range ( len ( tmp ) ) : <NEWLINE> <INDENT> c [ i ] [ j ] = tmp [ j ] <NEWLINE> <NL> <DEDENT> <DEDENT> hp = list ( itertools . product ( [ 0 , 1 ] , repeat = H ) ) <NEWLINE> wp = list ( itertools . product ( [ 0 , 1 ] , repeat = W ) ) <NEWLINE> <NL> hl = [ ] <NEWLINE> for elem in hp : <NEWLINE> <INDENT> hl . append ( [ i for i , x in enumerate ( list ( elem ) ) if x == 1 ] ) <NEWLINE> <DEDENT> wl = [ ] <NEWLINE> for elem in wp : <NEWLINE> <INDENT> wl . append ( [ i for i , x in enumerate ( list ( elem ) ) if x == 1 <NEWLINE> <NL> <DEDENT> def func ( hli , wli , c ) : <NEWLINE> <INDENT> tmp = 0 <NEWLINE> for i in range ( len ( hli ) ) : <NEWLINE> <INDENT> for j in range ( len ( wli ) ) : <NEWLINE> <INDENT> if c [ hli [ i ] ] [ wli [ j ] ] == <STRING> : <NEWLINE> <INDENT> tmp += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> return tmp <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for hli in hl : <NEWLINE> <INDENT> for wli in wl : <NEWLINE> <INDENT> if func ( hli , wli , c ) == K : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
h , w , k = map ( int , input ( ) . split ( ) ) <NEWLINE> c = [ list ( input ( ) ) for i in range ( h ) ] <NEWLINE> d = 0 <NEWLINE> for i in range ( 2 ** h ) : <NEWLINE> <INDENT> for j in range ( 2 ** w ) : <NEWLINE> <INDENT> i = bin ( i ) [ 2 : ] <NEWLINE> j = bin ( j ) [ 2 : ] <NEWLINE> i = <STRING> * ( h - len ( i ) ) + i <NEWLINE> j = <STRING> * ( j - len ( j ) ) + j <NEWLINE> p = 0 <NEWLINE> for s in range ( h ) : <NEWLINE> <INDENT> for t in range ( w ) : <NEWLINE> <INDENT> if i [ s ] == j [ t ] == 0 and c [ s ] [ t ] == <STRING> : <NEWLINE> <INDENT> p += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if p == k <NEWLINE> d += 1 <NEWLINE> <DEDENT> <DEDENT> print ( d ) <NEWLINE>
import numpy as np <NEWLINE> <NL> h , w , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ input ( ) for _ in range ( h ) ] <NEWLINE> b = [ ] <NEWLINE> for i in a : <NEWLINE> <INDENT> b += [ [ 1 if j == <STRING> else 0 for j in i ] ] <NEWLINE> <DEDENT> c = np . array ( b ) <NEWLINE> print ( c ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 2 ** ( h * w ) ) : <NEWLINE> <INDENT> for j in range ( h * w ) : <NEWLINE> <INDENT> d = c . copy ( ) <NEWLINE> if ( ( i >> j ) & 1 ) : <NEWLINE> <INDENT> if j <= h : <NEWLINE> <INDENT> d [ j ] = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d [ : , j - h ] = 0 <NEWLINE> <DEDENT> <DEDENT> if np . sum ( d ) == k : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
h , w , k = map ( int , input ( ) . split ( ) ) <NEWLINE> c = [ input ( i ) for i in range ( h ) ] <NEWLINE> ans = 0 <NEWLINE> for p_h in range ( 2 ** h ) : <NEWLINE> <INDENT> for p_w in range ( 2 ** w ) : <NEWLINE> <INDENT> black = 0 <NEWLINE> for i in range ( h ) : <NEWLINE> <INDENT> for j in range ( w ) : <NEWLINE> <INDENT> if ( p_h >> i ) & 1 == 0 and ( p_w >> j ) & 1 == 0 : <NEWLINE> <INDENT> if c [ i ] [ j ] == <STRING> <NEWLINE> <INDENT> black += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if black == k : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
h , w , k = map ( int , input ( ) . split ( ) ) <NEWLINE> X = [ [ 1 if a == <STRING> else 0 for a in input ( ) ] for _ in range ( H ) <NEWLINE> ans = 0 <NEWLINE> for ii in range ( 1 << h ) : <NEWLINE> <INDENT> for jj in range ( 1 << w ) : <NEWLINE> <INDENT> if sum ( [ sum ( [ X [ i ] [ j ] for j in range ( w ) if jj >> j & 1 ] ) for i in range ( h ) if ii >> i & 1 ] ) == k : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL>
import sys <NEWLINE> def LI ( ) : return list ( map ( int , sys . stdin . buffer . readline ( ) . split ( ) ) ) <NEWLINE> def I ( ) : return int ( sys . stdin . buffer . readline ( ) ) <NEWLINE> def LS ( ) : return sys . stdin . buffer . readline ( ) . rstrip ( ) . decode ( <STRING> ) . split ( ) <NEWLINE> def S ( ) : return sys . stdin . buffer . readline ( ) . rstrip ( ) . decode ( <STRING> ) <NEWLINE> def IR ( n ) : return [ I ( ) for i in range ( n ) ] <NEWLINE> def LIR ( n ) : return [ LI ( ) for i in range ( n ) ] <NEWLINE> def SR ( n ) : return [ S ( ) for i in range ( n ) ] <NEWLINE> def LSR ( n ) : return [ LS ( ) for i in range ( n ) ] <NEWLINE> def SRL ( n ) : return [ list ( S ( ) ) for i in range ( n ) ] <NEWLINE> def MSRL ( n ) : return [ [ int ( j ) for j in list ( S ( ) ) ] for i in range ( n ) ] <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> A <NEWLINE> H , W , K = LI ( ) <NEWLINE> c = SRL ( H ) <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> for i in range ( 2 ** H ) : <NEWLINE> <INDENT> seen = [ ] <NEWLINE> for n in range ( H ) : <NEWLINE> <INDENT> if ( ( i >> n ) & 1 ) : <NEWLINE> <INDENT> seen . append ( c [ n ] ) <NEWLINE> <DEDENT> <DEDENT> for j in range ( 2 ** W ) : <NEWLINE> <INDENT> count = 0 <NEWLINE> for m in range ( W ) : <NEWLINE> <INDENT> if ( ( j >> m ) & 1 ) : <NEWLINE> <INDENT> for l in range ( len ( seen ) ) : <NEWLINE> <INDENT> if seen [ l ] [ m ] == <STRING> : <NEWLINE> <INDENT> count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if count == K : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> from itertools import product <NEWLINE> <NL> H , W , K = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> c = [ list ( input ( ) ) for _ in range ( h ) ] <NEWLINE> ans = 0 <NEWLINE> <NL> for row_bit in product ( range ( 2 ) , repeat = H ) : <NEWLINE> <INDENT> for col_bit in product ( range ( 2 ) , repeat = W ) : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> for row in range ( H ) : <NEWLINE> <INDENT> for col in range ( W ) : <NEWLINE> <INDENT> if c [ row ] [ col ] = <STRING> and ( row_bit [ row ] and col_bit [ col ] ) : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if cnt == K : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
H , W , K = map ( int , input ( ) . split ( ) ) <NEWLINE> C = [ input ( ) for i in range ( H ) ] <NEWLINE> <NL> ans = 0 <NEWLINE> for i in 2 ** H : <NEWLINE> <INDENT> for j in 2 ** W : <NEWLINE> <INDENT> tmp = 0 <NEWLINE> for ii in range ( H ) : <NEWLINE> <INDENT> for jj in range ( W ) : <NEWLINE> <NL> <INDENT> if C [ ii ] [ jj ] == <STRING> and ( i >> ii ) == 0 and ( j >> jj ) == 0 : <NEWLINE> <INDENT> tmp += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if tmp == K : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import itertools <NEWLINE> <NL> import numpy as np <NEWLINE> <NL> <NL> def _run ( H , W , K , C ) : <NEWLINE> <INDENT> input = np . zeros ( [ H , W ] , dtype = np . int8 ) <NEWLINE> for h in range ( H ) : <NEWLINE> <INDENT> for w in range ( W ) : <NEWLINE> <INDENT> if C [ h ] [ w ] == <STRING> : <NEWLINE> <INDENT> input [ h , w ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> count = 0 <NEWLINE> for r in itertools . product ( * [ [ 0 , 1 ] for _ in range ( H + W ) ] ) : <NEWLINE> <INDENT> copy_input = input . copy ( ) <NEWLINE> for h in range ( H ) : <NEWLINE> <INDENT> if r [ h ] == 1 : <NEWLINE> <INDENT> copy_input [ h ] = 0 <NEWLINE> <DEDENT> <DEDENT> for w in range ( W ) : <NEWLINE> <INDENT> if r [ H + w ] == 1 : <NEWLINE> <INDENT> copy_input [ : , w ] = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> if np . sum ( copy_input ) == K : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE> <NL> <NL> <DEDENT> def _main ( ) : <NEWLINE> <INDENT> H , W , K = map ( int , input ( ) . split ( ) ) <NEWLINE> C = [ ] <NEWLINE> for _ in range ( H ) : <NEWLINE> <INDENT> C . append ( list ( map ( str , input ( ) . split ( ) ) ) ) <NEWLINE> <DEDENT> _run ( H , W , K , C ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> _main ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> import itertools <NEWLINE> import numpy as np <NEWLINE> <NL> rm = lambda : map ( int , sys . stdin . readline ( ) . split ( ) ) <NEWLINE> <NL> h , w , k = rm ( ) <NEWLINE> cnt = 0 <NEWLINE> def f ( x ) : <NEWLINE> <INDENT> if x == <STRING> : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> <DEDENT> li = np . array ( [ np . array ( list ( map ( f , sys . stdin . readline ( ) . split ( ) ) ) ) for _ in range ( h ) ] ) <NEWLINE> lih = list ( itertools . product ( list ( range ( 2 ) ) , repeat = h ) ) <NEWLINE> liw = list ( itertools . product ( list ( range ( 2 ) ) , repeat = w ) ) <NEWLINE> <NL> for i in lih : <NEWLINE> <INDENT> a = list ( itertools . compress ( li , i ) ) <NEWLINE> a . T ( ) <NEWLINE> for j in liw : <NEWLINE> <INDENT> b = list ( itertools . compress ( a , j ) ) <NEWLINE> if np . sum ( b ) == k : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
import copy <NEWLINE> H , W , K = list ( map ( int , input ( ) . rstrip ( ) . split ( <STRING> ) ) ) <NEWLINE> MASU = [ list ( input ( ) ) for _ in range ( H ) ] <NEWLINE> H2_li = [ ] <NEWLINE> W2_li = [ ] <NEWLINE> C_black = 0 <NEWLINE> for i in range ( 2 ** H ) : <NEWLINE> <INDENT> H2 = [ ] <NEWLINE> for j in range ( H ) : <NEWLINE> <INDENT> if ( ( i >> j ) & 1 ) : H2 . append ( 1 ) <NEWLINE> else : H2 . append ( 0 ) <NEWLINE> <DEDENT> H2_li . append ( H2 ) <NEWLINE> <DEDENT> for i in range ( 2 ** W ) : <NEWLINE> <INDENT> W2 = [ ] <NEWLINE> for j in range ( W ) : <NEWLINE> <INDENT> if ( ( i >> j ) & 1 ) : W2 . append ( 1 ) <NEWLINE> else : W2 . append ( 0 ) <NEWLINE> <DEDENT> W2_li . append ( W2 ) <NEWLINE> <NL> <DEDENT> for h2 in H2_li : <NEWLINE> <INDENT> for w2 in W2_li : <NEWLINE> <INDENT> masu = copy . deepcopy ( MASU ) <NEWLINE> for i , h in enumerate ( h2 ) : <NEWLINE> <INDENT> if h == 1 : <NEWLINE> <INDENT> masu [ i ] = [ <STRING> ] * H <NEWLINE> <DEDENT> <DEDENT> for i , w in enumerate ( w2 ) : <NEWLINE> <INDENT> if w == 1 : <NEWLINE> <INDENT> for k in range ( H ) : <NEWLINE> <INDENT> masu [ k ] [ i ] = <STRING> <NEWLINE> <DEDENT> <DEDENT> <DEDENT> count = 0 <NEWLINE> for h in range ( H ) : <NEWLINE> <INDENT> for w in range ( W ) : <NEWLINE> <INDENT> if masu [ h ] [ w ] == <STRING> : count += 1 <NEWLINE> <DEDENT> <DEDENT> if count == K : C_black += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( C_black ) <NEWLINE>
import numpy as np <NEWLINE> import copy <NEWLINE> import itertools <NEWLINE> h = int ( input ( ) ) <NEWLINE> w = int ( input ( ) ) <NEWLINE> k = int ( input ( ) ) <NEWLINE> s = [ list ( input ( ) ) for i in range ( h ) ] <NEWLINE> data = np . zeros ( h * w ) . reshape ( h , w ) <NEWLINE> for i in range ( h ) : <NEWLINE> <INDENT> for j in range ( w ) : <NEWLINE> <INDENT> if s [ i ] [ j ] == <STRING> : <NEWLINE> <INDENT> data [ i ] [ j ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> ans = 0 <NEWLINE> <COMMENT> <NL> if np . sum ( data == 1 ) == k : <NEWLINE> <INDENT> ans = 1 <NEWLINE> <COMMENT> <NL> <DEDENT> if k == 0 : <NEWLINE> <INDENT> ans = 1 <NEWLINE> <NL> <DEDENT> a = list ( ) <NEWLINE> b = list ( ) <NEWLINE> for i in range ( 1 , h ) : <NEWLINE> <INDENT> a += list ( itertools . combinations ( range ( h ) , i ) ) <NEWLINE> <DEDENT> for i in range ( 1 , w ) : <NEWLINE> <INDENT> b += list ( itertools . combinations ( range ( w ) , i ) ) <NEWLINE> <NL> <DEDENT> for i in a : <NEWLINE> <INDENT> for j in b : <NEWLINE> <INDENT> temp = data . copy ( ) <NEWLINE> temp [ i , : ] = 2 <NEWLINE> temp [ : , j ] = 2 <NEWLINE> if np . sum ( temp == 1 ) == k : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for i in a : <NEWLINE> <INDENT> temp = data . copy ( ) <NEWLINE> temp [ i , : ] = 2 <NEWLINE> if np . sum ( temp == 1 ) == k : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> for j in b : <NEWLINE> <INDENT> temp = data . copy ( ) <NEWLINE> temp [ : , j ] = 2 <NEWLINE> if np . sum ( temp == 1 ) == k : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import itertools <NEWLINE> <NL> h , w , k = map ( int , input ( ) . split ( ) ) <NEWLINE> s = 0 <NEWLINE> l = [ ] <NEWLINE> for _ in range ( h ) : <NEWLINE> <INDENT> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> s += a . count ( <STRING> ) <NEWLINE> l . append ( a ) <NEWLINE> <DEDENT> if ( k > s ) : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = 0 <NEWLINE> for pair in itertools . combinations ( [ 0 , 1 ] , h + w ) : <NEWLINE> <INDENT> hx = pair [ : h ] <NEWLINE> wx = pair [ h + 1 : ] <NEWLINE> if ( sum ( wx ) == 0 ) : <NEWLINE> <INDENT> ans = ans + 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
import sys <NEWLINE> from itertools import combinations <NEWLINE> <COMMENT> <NL> DEBUG = False <NEWLINE> if DEBUG : <NEWLINE> <INDENT> f = open ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> f = sys . stdin <NEWLINE> <DEDENT> WHITE = <STRING> <NEWLINE> BLACK = <STRING> <NEWLINE> def count_black ( H_index , W_index ) : <NEWLINE> <INDENT> count_tmp = 0 <NEWLINE> for H_entries in H_index : <NEWLINE> <INDENT> for _ in H_entries : <NEWLINE> <INDENT> if _ == H_index : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> for W_entries in W_index : <NEWLINE> <INDENT> for __ in W_entries : <NEWLINE> <INDENT> if __ == W_index : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> <DEDENT> if S [ _ ] [ __ ] == BLACK : <NEWLINE> <INDENT> count_tmp += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> return count_tmp <NEWLINE> <DEDENT> ans = 0 <NEWLINE> H , W , K = map ( int , f . readline ( ) . split ( ) ) <NEWLINE> S = [ f . readline ( ) . strip ( ) for _ in range ( H ) ] <NEWLINE> H_indices = [ _ for _ in range ( 0 , H ) ] <NEWLINE> W_indices = [ _ for _ in range ( 0 , W ) ] <NEWLINE> combi_list_H = [ ( - 1 ) ] <NEWLINE> combi_list_W = [ ( - 1 ) ] <NEWLINE> for _ in range ( 1 , H ) : <NEWLINE> <INDENT> combi_list_H . extend ( list ( combinations ( H_indices , _ ) ) ) <NEWLINE> <DEDENT> for _ in range ( 1 , W ) : <NEWLINE> <INDENT> combi_list_W . extend ( list ( combinations ( W_indices , _ ) ) ) <NEWLINE> <DEDENT> for _ in combi_list_H : <NEWLINE> <INDENT> for __ in combi_list_W : <NEWLINE> <INDENT> if count_black ( _ , __ ) == 5 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> f . close ( ) <NEWLINE>
import numpy as np <NEWLINE> import itertools <NEWLINE> <NL> h , w , k = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> <NL> cells = [ ] <NEWLINE> for _ in range ( h ) : <NEWLINE> <INDENT> cells . append ( list ( input ( ) ) ) <NEWLINE> <DEDENT> cells = np . asarray ( cells ) <NEWLINE> <NL> n_choice = 0 <NEWLINE> for n_target_rows in range ( h + 1 ) : <NEWLINE> <INDENT> target_rows = list ( itertools . combinations ( range ( h ) , n_target_rows ) ) <NEWLINE> <NL> for n_target_clms in range ( w + 1 ) : <NEWLINE> <INDENT> target_clms = list ( itertools . combinations ( range ( w ) , n_target_clms ) ) <NEWLINE> <NL> for rows in target_rows : <NEWLINE> <INDENT> row_converted_cells = cells . copy ( ) <NEWLINE> row_converted_cells [ rows , : ] = <STRING> * w <NEWLINE> <NL> for clms in target_clms : <NEWLINE> <INDENT> clm_converted_cells = row_converted_cells . copy ( ) <NEWLINE> clm_converted_cells [ : , clms ] = <STRING> <NEWLINE> n_black = np . count_nonzero ( clm_converted_cells == <STRING> ) <NEWLINE> <NL> if n_black == k : <NEWLINE> <INDENT> n_choice += <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( n_choice ) <NEWLINE>
import numpy as np <NEWLINE> <NL> h , w , k = map ( int , input ( ) . split ( ) ) <NEWLINE> grid = np . array ( [ list ( map ( str , input ( ) . rstrip ( ) ) ) for _ in range ( h ) ] ) <NEWLINE> <NL> ans = 0 <NEWLINE> for i in np . array ( list ( product ( [ 0 , 1 ] , repeat = h ) ) , np . bool ) : <NEWLINE> <INDENT> for j in np . array ( list ( product ( [ 0 , 1 ] , repeat = w ) ) , np . bool ) : <NEWLINE> <INDENT> if np . any ( i ) and np . any ( j ) : <NEWLINE> <INDENT> arr = grid [ i ] . copy ( ) <NEWLINE> arr = arr [ : , j ] <NEWLINE> arr = arr . flatten ( ) <NEWLINE> if np . where ( arr == <STRING> ) [ 0 ] . shape [ 0 ] == k : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
h , w , k = map ( int , input ( ) . split ( ) ) <NEWLINE> c = [ ] <NEWLINE> <COMMENT> <NL> hk = [ ] <NEWLINE> for i in range ( h ) : <NEWLINE> <INDENT> kki = 0 <NEWLINE> hwi = list ( map ( str , input ( ) . split ( ) ) ) <NEWLINE> hw = [ ] <NEWLINE> for j in range ( w ) : <NEWLINE> <INDENT> if hwi [ j ] == <STRING> : <NEWLINE> <INDENT> hw . append ( 1 ) <NEWLINE> kki += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> hw . append ( 0 ) <NEWLINE> <DEDENT> <DEDENT> c . append ( hw ) <NEWLINE> hk . append ( kki ) <NEWLINE> <DEDENT> kk = sum ( hk ) <NEWLINE> ans = 0 <NEWLINE> <COMMENT> <NL> for i in range ( 2 ** h ) : <NEWLINE> <COMMENT> <NL> <INDENT> wk = [ 0 ] <NEWLINE> wk *= w <NEWLINE> for j in range ( h ) : <NEWLINE> <INDENT> if ( i >> j & 1 ) : <NEWLINE> <COMMENT> <NL> <INDENT> for l in range ( w ) : <NEWLINE> <INDENT> wk [ l ] += c [ j ] [ l ] <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> for j in range ( 2 ** w ) : <NEWLINE> <INDENT> ansi = 0 <NEWLINE> for l in range ( w ) : <NEWLINE> <INDENT> if ( j >> l & 1 ) : <NEWLINE> <INDENT> ansi += wk [ l ] <NEWLINE> <DEDENT> <DEDENT> if ansi == k : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import numpy as np <NEWLINE> H , W , K = map ( int , input ( ) . split ( ) ) <NEWLINE> ll = [ ] <NEWLINE> for h in range ( H ) : <NEWLINE> <INDENT> l = [ ] <NEWLINE> for s in input ( ) : <NEWLINE> <INDENT> if s == <STRING> : <NEWLINE> <INDENT> l . append ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> l . append ( 1 ) <NEWLINE> <DEDENT> <DEDENT> ll . append ( l ) <NEWLINE> <DEDENT> cnt = 0 <NEWLINE> for bh in range ( 2 ** H ) : <NEWLINE> <INDENT> for bw in range ( 2 ** W ) : <NEWLINE> <INDENT> nn = np . asarray ( ll ) <NEWLINE> k = 0 <NEWLINE> for h in range ( H ) : <NEWLINE> <INDENT> if ( bh & 2 ** h ) >> h == 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> nn [ h ] = np . array ( [ 0 ] * W ) <NEWLINE> <DEDENT> for w in range ( W ) : <NEWLINE> <INDENT> if ( bw & 2 ** w ) >> w == 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> nn [ : , w ] = np . array ( [ 0 ] * W ) <NEWLINE> <DEDENT> for h in range ( H ) : <NEWLINE> <INDENT> for w in range ( W ) : <NEWLINE> <INDENT> k += nn [ h ] [ w ] <NEWLINE> <DEDENT> <DEDENT> if k == K : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
h , w , k = map ( int , input ( ) . split ( ) ) <NEWLINE> p = [ list ( str ( input ( ) ) ) for _ in range ( h ) ] <NEWLINE> bl = p . count ( <STRING> ) <NEWLINE> bl = bl - k <NEWLINE> ee = list ( range ( h ) ) <NEWLINE> q = list ( range ( w ) ) <NEWLINE> kotae = 0 <NEWLINE> pp = [ ] <NEWLINE> qq = [ ] <NEWLINE> for i in range ( h + 1 ) : <NEWLINE> <INDENT> pp += list ( itertools . combinations ( ee , i ) ) <NEWLINE> <DEDENT> for i in range ( w + 1 ) : <NEWLINE> <INDENT> qq += list ( itertools . combinations ( q , i ) ) <NEWLINE> <DEDENT> for i in pp : <NEWLINE> <INDENT> for j in qq : <NEWLINE> <INDENT> ans = 0 <NEWLINE> for zz in range ( h ) : <NEWLINE> <INDENT> for ww in range ( w ) : <NEWLINE> <INDENT> if zz not in i : <NEWLINE> <INDENT> if ww not in j : <NEWLINE> <INDENT> if p [ zz ] [ ww ] == <STRING> : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if ans == k : <NEWLINE> <INDENT> kotae += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( kotae ) <NEWLINE>
h , w , k = map ( int , input ( ) . split ( ) ) <NEWLINE> mark = [ input ( ) for _ in range ( h ) ] <NEWLINE> ans = 0 <NEWLINE> <NL> for bit_h in range ( 1 << h ) : <NEWLINE> <INDENT> i_list = [ ] <NEWLINE> for i in range ( h ) : <NEWLINE> <INDENT> if bit_h & 1 : <NEWLINE> <INDENT> i_list . append ( i ) <NEWLINE> <DEDENT> bit_h >>= 1 <NEWLINE> <DEDENT> for bit_w in range ( 1 << w ) : <NEWLINE> <INDENT> count = 0 <NEWLINE> j_list = [ ] <NEWLINE> for j in range ( w ) : <NEWLINE> <INDENT> if bit_w & 1 : <NEWLINE> <INDENT> j_list . append ( bit_w & 1 ) <NEWLINE> <DEDENT> bit_w >>= 1 <NEWLINE> <DEDENT> for i in i_list : <NEWLINE> <INDENT> for j in j_list : <NEWLINE> <INDENT> if mark [ i ] [ j ] = <STRING> : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if count == k : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
H , W , K = map ( int , input ( ) . split ( ) ) <NEWLINE> c = [ input ( ) for i in range ( H ) ] <NEWLINE> max_num = count_num ( c ) <NEWLINE> <NL> ans = 0 <NEWLINE> for h in range ( 2 ** H ) : <NEWLINE> <INDENT> for w in range ( 2 ** W ) : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> for i in range ( H ) : <NEWLINE> <INDENT> for j in range ( W ) : <NEWLINE> <INDENT> if ( h >> i ) & 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if ( w >> j ) & 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if c [ i ] [ j ] == <STRING> <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if cnt == K : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> from io import StringIO <NEWLINE> import unittest <NEWLINE> <NL> a = input ( ) . rstrip ( ) . split ( <STRING> ) <NEWLINE> <NL> H = int ( a [ 0 ] ) <COMMENT> <NEWLINE> W = int ( a [ 1 ] ) <COMMENT> <NEWLINE> K = int ( a [ 2 ] ) <COMMENT> <NEWLINE> <NL> m = [ ] <NEWLINE> for i in range ( H ) : <NEWLINE> <INDENT> n = list ( input ( ) ) <NEWLINE> m . append ( n ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> ans = 0 <NEWLINE> <NL> for maskR in range ( 1 << H ) : <NEWLINE> <INDENT> for maskC in range ( 1 << W ) : <NEWLINE> <INDENT> black = 0 <NEWLINE> for i in range ( H ) : <NEWLINE> <INDENT> for j in range ( W ) : <NEWLINE> <INDENT> if ( maskR >> i & 1 ) == 0 and ( maskL >> j & 1 ) == 0 and m [ i ] [ j ] == <STRING> : <NEWLINE> <INDENT> black += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if black == k : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import itertools <NEWLINE> <NL> H , W , K = map ( int , input ( ) . split ( ) ) <NEWLINE> C = [ ] <NEWLINE> <NL> for i in range ( H ) : <NEWLINE> <INDENT> C . append ( input ( ) ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> <NL> for i in range ( H + 1 ) : <NEWLINE> <INDENT> for j in range ( W + 1 ) : <NEWLINE> <INDENT> for m in itertools . combinations ( list ( range ( H ) ) , i ) : <NEWLINE> <INDENT> for n in itertools . combinations ( list ( range ( W ) ) , j ) : <NEWLINE> <INDENT> count = 0 <NEWLINE> for a in m : <NEWLINE> <INDENT> for b in n : <NEWLINE> <INDENT> if ( C [ b ] [ a ] == <STRING> ) : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if ( count == K ) : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from collections import Counter <NEWLINE> import copy <NEWLINE> from itertools import combinations <NEWLINE> <NL> <NL> def A ( x ) : <NEWLINE> <INDENT> return 1000 - x % 1000 if x % 1000 != 0 else 0 <NEWLINE> <NL> <NL> <DEDENT> def B ( n , ss ) : <NEWLINE> <INDENT> keys_values = Counter ( ss ) <NEWLINE> orders = [ <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> for order in orders : <NEWLINE> <INDENT> if order in keys_values : <NEWLINE> <INDENT> print ( <STRING> . format ( order , keys_values [ order ] ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> . format ( order , 0 ) ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> def _get_num_black ( c_list , r_list , h , w , g ) : <NEWLINE> <INDENT> num_black = 0 <NEWLINE> for i in range ( h ) : <NEWLINE> <INDENT> if i in r_list : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> for j in range ( w ) : <NEWLINE> <INDENT> if j in c_list : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> num_black += ( 1 if g [ i ] [ j ] == <STRING> else 0 ) <NEWLINE> <DEDENT> <DEDENT> return num_black <NEWLINE> <NL> <NL> <DEDENT> def C ( h , w , k , g ) : <NEWLINE> <INDENT> num_choice = 0 <NEWLINE> for i in range ( k + 1 ) : <NEWLINE> <INDENT> for j in range ( k - i + 1 ) : <NEWLINE> <INDENT> for c_list in list ( combinations ( range ( w ) , j ) ) : <NEWLINE> <INDENT> for r_list in list ( combinations ( range ( h ) , i ) ) : <NEWLINE> <INDENT> if _get_num_black ( c_list , r_list , h , w , g ) == k : <NEWLINE> <INDENT> num_choice += 1 <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> return num_choice <NEWLINE> <NL> <NL> <DEDENT> def C2 ( H , W , K , g ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> c = [ ] <NEWLINE> for i in range ( H ) : <NEWLINE> <INDENT> c . append ( [ ] ) <NEWLINE> for j in range ( W ) : <NEWLINE> <INDENT> c [ i ] . append ( g [ i ] [ j ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for h in range ( H + 1 ) : <NEWLINE> <INDENT> for w in range ( W + 1 ) : <NEWLINE> <INDENT> for h2 in combinations ( list ( range ( H ) ) , h ) : <NEWLINE> <INDENT> for w2 in combinations ( list ( range ( W ) ) , w ) : <NEWLINE> <INDENT> paint = copy . deepcopy ( c ) <NEWLINE> for h3 in h2 : <NEWLINE> <INDENT> for i in range ( W ) : <NEWLINE> <INDENT> paint [ h3 ] [ i ] = <STRING> <NEWLINE> <DEDENT> <DEDENT> for i in range ( H ) : <NEWLINE> <INDENT> for w3 in w2 : <NEWLINE> <INDENT> paint [ i ] [ w3 ] = <STRING> <NEWLINE> <DEDENT> <DEDENT> count_black = 0 <NEWLINE> for i in range ( H ) : <NEWLINE> <INDENT> count_black += paint [ i ] . count ( <STRING> ) <NEWLINE> <COMMENT> <NL> <DEDENT> if count_black == K : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> return ans <NEWLINE> <NL> <NL> <DEDENT> def C3 ( h , w , k , g ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> num_choice = 0 <NEWLINE> for i in range ( h + 1 ) : <NEWLINE> <INDENT> for j in range ( w + 1 ) : <NEWLINE> <INDENT> for h2 in combinations ( list ( range ( h ) ) , i ) : <NEWLINE> <INDENT> for w2 in combinations ( list ( range ( w ) ) , j ) : <NEWLINE> <INDENT> if _get_num_black ( w2 , h2 , h , w , g ) == k : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> return num_choice <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> h , w , k = map ( int , input ( ) . split ( ) ) <NEWLINE> g = [ ] <NEWLINE> for i in range ( h ) : <NEWLINE> <INDENT> g . append ( input ( ) ) <NEWLINE> <DEDENT> print ( C3 ( h , w , k , g ) ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import itertools <NEWLINE> from typing import List <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> h , w , k = map ( int , input ( ) . split ( ) ) <NEWLINE> c = [ ] <NEWLINE> for _ in range ( h ) : <NEWLINE> <INDENT> c . append ( input ( ) . split ( ) ) <NEWLINE> <NL> <DEDENT> print ( hv ( c , h , w , k ) ) <NEWLINE> <NL> <NL> <DEDENT> def hv ( c : List [ List [ str ] ] , h : int , w : int , k : int ) -> int : <NEWLINE> <INDENT> ret = 0 <NEWLINE> for comb_h in itertools . product ( ( False , True ) , repeat = h ) : <NEWLINE> <INDENT> for comb_w in itertools . product ( ( False , True ) , repeat = w ) : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> for i in range ( h ) : <NEWLINE> <INDENT> for j in range ( w ) : <NEWLINE> <INDENT> if comb_h [ i ] and comb_w [ j ] and c [ i ] [ j ] == <STRING> : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if cnt == k : <NEWLINE> <INDENT> ret += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return ret <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
H , W , K = map ( int , input ( ) . split ( ) ) <NEWLINE> fi = [ ] <NEWLINE> for _ in range ( H ) : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> fi . append ( s ) <NEWLINE> <DEDENT> a = 1 << H <NEWLINE> b = 1 << W <NEWLINE> total = 0 <NEWLINE> <NL> for i in range ( a * b ) : <NEWLINE> <INDENT> lh = list ( ) <NEWLINE> lw = list ( ) <NEWLINE> <NL> for j in range ( h ) : <NEWLINE> <INDENT> if i & ( 1 << j ) : <NEWLINE> <INDENT> lh . append ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> lh . append ( 0 ) <NEWLINE> <DEDENT> <DEDENT> for j in range ( W ) : <NEWLINE> <INDENT> if i & ( 1 << ( j + H ) ) : <NEWLINE> <INDENT> lw . append ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> lw . append ( 0 ) <NEWLINE> <NL> <DEDENT> <DEDENT> cnt = 0 <NEWLINE> for j in range ( H ) : <NEWLINE> <INDENT> for l in range ( W ) : <NEWLINE> <INDENT> if lh [ j ] == 1 or lw [ j ] == 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if fi [ j ] [ l ] == <STRING> : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if cnt == K : <NEWLINE> <INDENT> total += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( total ) <NEWLINE>
<COMMENT> <NL> <INDENT> for i in range ( H + 1 ) : <NEWLINE> <INDENT> for iconb in comb ( range ( H ) , i ) : <NEWLINE> <INDENT> for j in range ( W + 1 ) : <NEWLINE> <INDENT> for jconb in comb ( range ( W ) , j ) : <NEWLINE> <INDENT> cells = np . copy ( original ) <NEWLINE> cells [ iconb , : ] = <STRING> <NEWLINE> cells [ : , jconb ] = <STRING> <NEWLINE> black = np . count_nonzero ( cells == <STRING> ) <NEWLINE> <COMMENT> <NL> if black == K : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
h , w , k = map ( int , input ( ) . split ( ) ) <NEWLINE> c = [ list ( input ( ) ) for _ in range ( h ) ] <NEWLINE> kaito = 0 <NEWLINE> <NL> def kako ( a , b ) : <NEWLINE> <INDENT> global h , w <NEWLINE> d = [ 0 ] * ( h - len ( a ) ) <NEWLINE> e = [ 0 ] * ( w - len ( b ) ) <NEWLINE> d . append ( a ) <NEWLINE> e . append ( b ) <NEWLINE> a = d <NEWLINE> b = e <NEWLINE> <NL> <DEDENT> def hantei ( a , b ) : <NEWLINE> <INDENT> global k , kaito , h , w <NEWLINE> ans = 0 <NEWLINE> for i in range ( h ) : <NEWLINE> <INDENT> for j in range ( w ) : <NEWLINE> <INDENT> if a [ i ] == <STRING> and b [ j ] == <STRING> and c [ i ] [ j ] == <STRING> : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if ans == k : <NEWLINE> <INDENT> kaito += 1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> for i in range ( 2 ** h ) : <NEWLINE> <INDENT> for j in range ( 2 ** w ) : <NEWLINE> <INDENT> a = list ( bin ( i ) ) <NEWLINE> b = list ( bin ( j ) ) <NEWLINE> a = a [ 2 : ] <NEWLINE> b = b [ 2 : ] <NEWLINE> kako ( a , b ) <NEWLINE> hantei ( a , b ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( kaito ) <NEWLINE> <NL> <NL> <NL> <NL>
import itertools <NEWLINE> import numpy as np <NEWLINE> <NL> H , W , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> temp = [ ] <NEWLINE> for _ in range ( H ) : <NEWLINE> <INDENT> C = list ( input ( ) ) <NEWLINE> A = [ c . replace ( <STRING> , <STRING> ) for c in C ] <NEWLINE> A = [ a . replace ( <STRING> , <STRING> ) for a in A ] <NEWLINE> A = list ( map ( lambda x : int ( x ) , A ) ) <NEWLINE> temp . append ( A ) <NEWLINE> <NL> <DEDENT> C = np . array ( temp ) <NEWLINE> <NL> count = 0 <NEWLINE> l = [ 0 , 1 ] <NEWLINE> wide = itertools . product ( 1 , repeat = W ) <NEWLINE> for w in wide : <NEWLINE> <INDENT> height = itertools . product ( 1 , repeat = H ) <NEWLINE> for h in height : <NEWLINE> <INDENT> copy_C = C . copy ( ) <NEWLINE> for num , i in enumerate ( w ) : <NEWLINE> <INDENT> if i == 1 : <NEWLINE> <INDENT> copy_C [ : , num - 1 ] = 0 <NEWLINE> <DEDENT> for num2 , j in enumerate ( h ) : <NEWLINE> <INDENT> if j == 1 : <NEWLINE> <INDENT> copy_C [ num2 - 1 , : ] = 0 <NEWLINE> <DEDENT> <DEDENT> if copy_C . sum ( ) == K : <NEWLINE> <INDENT> count = count + 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
<INDENT> h , w , k = map ( int , input ( ) . split ( ) ) <NEWLINE> board = [ list ( input ( ) ) for i in range ( h ) ] <NEWLINE> ans = 0 <NEWLINE> for paint_h in range ( 2 ** h ) : <NEWLINE> <INDENT> for paint_w in range ( 2 ** w ) : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> for i in range ( h ) : <NEWLINE> <INDENT> for j in range ( w ) : <NEWLINE> <INDENT> if ( paint_h >> i ) & 1 == 0 and ( paint_w >> j ) & 1 == 0 : <NEWLINE> <INDENT> if board [ i ] [ j ] == <STRING> : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> if cnt == k : <NEWLINE> ans += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
H , W , K = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c = [ ] <NEWLINE> for i in range ( H ) : <NEWLINE> <INDENT> c . append ( list ( input ( ) ) ) <NEWLINE> <DEDENT> ans = 0 <NEWLINE> H_pattern , W_pattern = 2 ** H , 2 ** W <NEWLINE> for i in range ( 0 , H_pattern ) : <NEWLINE> <INDENT> for j in range ( 0 , W_pattern ) : <NEWLINE> <INDENT> H_active , W_active = list ( bin ( H_pattern , i ) [ 2 : ] . zfill ( H ) ) , list ( bin ( W_pattern , j ) . zfill ( H ) ) <NEWLINE> count = 0 <NEWLINE> for k , arr in enumerate ( c ) : <NEWLINE> <INDENT> for l , item in enumerate ( arr ) : <NEWLINE> <INDENT> if H_active [ k ] == <STRING> and W_active [ l ] == <STRING> and item == <STRING> : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if count == K : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL>
import numpy as np <NEWLINE> import itertools <NEWLINE> <NL> H , W , K = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c = [ input ( ) . split ( ) for l in range ( H ) ] <NEWLINE> b = [ ] <NEWLINE> d = [ ] <NEWLINE> for m in range ( len ( c ) ) : <NEWLINE> <INDENT> for item in c [ m ] : <NEWLINE> <INDENT> item_mod = item . replace ( <STRING> , <STRING> ) <NEWLINE> item_mod = item_mod . replace ( <STRING> , <STRING> ) <NEWLINE> b . append ( item_mod ) <NEWLINE> <DEDENT> d . append ( b ) <NEWLINE> b = [ ] <NEWLINE> <NL> <DEDENT> C_arr = np . array ( d , dtype = <STRING> ) <NEWLINE> C_arr = C_arr . reshape ( ( H , W ) ) <NEWLINE> <NL> In = np . array ( list ( itertools . product ( [ 0 , 1 ] , repeat = H ) ) ) <NEWLINE> Out = np . array ( list ( itertools . product ( [ 0 , 1 ] , repeat = W ) ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( 2 ** H ) : <NEWLINE> <INDENT> for j in range ( 2 ** W ) : <NEWLINE> <INDENT> In_matrix = np . diag ( In [ i ] ) <NEWLINE> Out_matrix = np . diag ( Out [ j ] ) <NEWLINE> <NL> In_C = np . dot ( In_matrix , C_arr ) <NEWLINE> In_C_Out = np . dot ( In_C , Out_matrix ) <NEWLINE> <NL> ICO = In_C_Out . flatten ( ) <NEWLINE> ICO = ICO . tolist ( ) <NEWLINE> <NL> if ICO . count ( 1 ) == K : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
h , w , k = map ( int , input ( ) . split ( ) ) <NEWLINE> c = [ ] <NEWLINE> for i in range ( h ) : <NEWLINE> <INDENT> c . append ( list ( map ( str , input ( ) . split ( ) ) ) ) <NEWLINE> <DEDENT> ans = 0 <NEWLINE> for j in range ( 1 << h ) : <NEWLINE> <INDENT> for k in range ( 1 << w ) : <NEWLINE> <INDENT> black = 0 <NEWLINE> for m in range ( h ) : <NEWLINE> <INDENT> for n in range ( w ) : <NEWLINE> <INDENT> if ( ( j >> m ) & 1 ) == 0 and ( ( k >> n ) & 1 ) == 0 and c [ m ] [ n ] == <STRING> : <NEWLINE> <INDENT> black += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if black == k : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import numpy as np <NEWLINE> <NL> H , W , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> C = np . frombuffer ( read ( ) , dtype = <STRING> ) . reshape ( H , - 1 ) <NEWLINE> print ( C ) <NEWLINE>
h , w , k = map ( int , input ( ) . split ( ) ) <NEWLINE> matrix = [ ] <NEWLINE> for i in range ( h ) : <NEWLINE> <INDENT> s = list ( input ( ) ) <NEWLINE> matrix . append ( s ) <NEWLINE> <DEDENT> hlist = [ ] <NEWLINE> for i in range ( h ) : <NEWLINE> <INDENT> hlist . append ( i ) <NEWLINE> <DEDENT> wlist = [ ] <NEWLINE> for i in range ( w ) : <NEWLINE> <INDENT> wlist . append ( i ) <NEWLINE> <DEDENT> rows = [ ] <NEWLINE> cols = [ ] <NEWLINE> for i in range ( h + 1 ) : <NEWLINE> <INDENT> obj = itertools . combinations ( hlist , i ) <NEWLINE> rows += list ( obj ) <NEWLINE> <DEDENT> for i in range ( w + 1 ) : <NEWLINE> <INDENT> obj = itertools . combinations ( wlist , i ) <NEWLINE> cols += list ( obj ) <NEWLINE> <DEDENT> ans = 0 <NEWLINE> for i in rows : <NEWLINE> <INDENT> for j in cols : <NEWLINE> <INDENT> count = 0 <NEWLINE> for a in range ( h ) : <NEWLINE> <INDENT> for b in range ( w ) : <NEWLINE> <INDENT> if ( matrix [ a ] [ b ] == <STRING> and a not in i and b not in j ) : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if ( count == k ) : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from itertools import product <NEWLINE> h , w , k = map ( int , input ( ) . split ( ) ) <NEWLINE> idxs = [ ] <NEWLINE> cols = [ 0 ] * w <NEWLINE> al = 0 <NEWLINE> <NL> def nir ( x ) : <NEWLINE> <INDENT> if x == <STRING> : return 1 <NEWLINE> else : return 0 <NEWLINE> <NL> <DEDENT> for _ in range ( h ) : <NEWLINE> <INDENT> tmp = list ( map ( nir , list ( input ( ) ) ) ) <NEWLINE> idxs . append ( sum ( tmp ) ) <NEWLINE> al += sum ( tmp ) <NEWLINE> for q in range ( w ) : <NEWLINE> <INDENT> cols [ q ] += tmp [ q ] <NEWLINE> <NL> <DEDENT> <DEDENT> for bits in product ( ( 0 , 1 ) , repeat = h + w ) : <NEWLINE>
H , W , K = map ( int , input ( ) . split ( ) ) <NEWLINE> C = [ list ( input ( ) . split ( ) ) for _ in range ( H ) ] <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> ans = 0 <NEWLINE> import itertools <NEWLINE> tf = ( <STRING> , <STRING> ) <NEWLINE> for l in itertools . product ( tf , repeat = ( H + W ) ) : <NEWLINE> <INDENT> L = list ( l ) <NEWLINE> <DEDENT> black = 0 <NEWLINE> for i in range ( 2 ** ( H + W ) ) : <NEWLINE> <INDENT> for j in range ( H ) : <NEWLINE> <INDENT> for k in range ( W ) : <NEWLINE> <INDENT> if l [ i ] [ j ] == <STRING> and l [ i ] [ H + k ] == <STRING> and C [ j ] [ k ] == <STRING> : <NEWLINE> <INDENT> black += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if black == K : <NEWLINE> <INDENT> ans += 1 <NEWLINE> black = 0 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
h , w , k = map ( int , input ( ) . split ( ) ) <NEWLINE> c = [ list ( input ( ) ) for i in range ( h ) ] <NEWLINE> ans = 0 <NEWLINE> for p_h in range ( 2 ** h ) : <NEWLINE> <INDENT> for p_w in range ( 2 ** w ) : <NEWLINE> <INDENT> black = 0 <NEWLINE> for i in range ( h ) : <NEWLINE> <INDENT> for j in range ( w ) : <NEWLINE> <INDENT> if ( p_h >> i ) & 1 == 0 and ( p_w >> j ) &= = 0 : <NEWLINE> <INDENT> if c [ i ] [ j ] == <STRING> : <NEWLINE> <INDENT> black += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if black == k : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
H , W , K = map ( int , input ( ) . split ( ) ) <NEWLINE> C = [ input ( ) for i in range ( H ) ] <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 << H ) : <NEWLINE> <INDENT> for j in range ( 1 << W ) : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> for m in range ( H ) : <NEWLINE> <INDENT> for n in range ( W ) : <NEWLINE> <INDENT> if ( ( i >> m ) & 1 ) : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if ( ( j >> n ) & 1 ) : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if C [ m ] [ n ] == <STRING> : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if cnt == K : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> elif cnt != K : <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import numpy as np <NEWLINE> H , W , K = map ( int , input ( ) . split ( ) ) <NEWLINE> c = [ input ( ) . split ( ) for l in range ( H ) ] <NEWLINE> <NL> def count_mat ( ) : <NEWLINE> <INDENT> c1 = c . count ( <STRING> ) <NEWLINE> return c1 <NEWLINE> <NL> <DEDENT> num = 0 <NEWLINE> while c1 > K : <NEWLINE> <INDENT> for i in range ( H ) <NEWLINE> for j in range ( W ) <NEWLINE> c = np . delete ( c , i , j ) <NEWLINE> num += 1 <NEWLINE> <NL> print ( num ) <NEWLINE> <DEDENT>
H , W , K = map ( int , ( input ( ) . split ( ) ) ) <NEWLINE> board = [ list ( input ( ) . split ( ) ) for _ in range ( H ) ] <NEWLINE> ans = 0 <NEWLINE> for paint_H in range ( 2 ** H ) : <NEWLINE> <INDENT> for paint_W in range ( 2 ** W ) : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> for i in range ( H ) : <NEWLINE> <INDENT> for j in range ( W ) : <NEWLINE> <INDENT> if ( paint_H >> i ) & 1 == 0 and ( paint_W >> j ) & 1 == 0 : <NEWLINE> <INDENT> if board [ i ] [ j ] == <STRING> : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if cnt == K : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
H , W , K = map ( int , input ( ) . split ( ) ) <NEWLINE> state = np . zeros ( ( H , W ) , dtype = int ) <NEWLINE> for h in range ( H ) : <NEWLINE> <INDENT> hlist = input ( ) <NEWLINE> for w in range ( W ) : <NEWLINE> <INDENT> if hlist [ w ] == <STRING> : <NEWLINE> <INDENT> state [ h ] [ w ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> startb = np . sum ( state ) <NEWLINE> count = 0 <NEWLINE> <NL> if startb < K : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> h_l = 2 ** H <NEWLINE> w_l = 2 ** W <NEWLINE> for h in range ( h_l ) : <NEWLINE> <INDENT> for w in range ( w_l ) : <NEWLINE> <INDENT> t1 = [ int ( i ) for i in list ( str ( bin ( h ) ) [ 2 : ] ) ] <NEWLINE> t2 = np . zeros ( H - len ( t1 ) , dtype = int ) <NEWLINE> wflag = np . append ( t2 , t1 ) <NEWLINE> state_t = state * np . array ( [ wflag ] * W ) . T <NEWLINE> <NL> t1 = [ int ( i ) for i in list ( str ( bin ( w ) ) [ 2 : ] ) ] <NEWLINE> t2 = np . zeros ( W - len ( t1 ) , dtype = int ) <NEWLINE> hflag = np . append ( t2 , t1 ) <NEWLINE> state_t = state_t * np . array ( [ hflag ] * H ) <NEWLINE> <NL> if np . sum ( state_t ) == K : <NEWLINE> <INDENT> count = count + 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE> <DEDENT>
h , w , k = map ( int , input ( ) . split ( ) ) <NEWLINE> c = [ ] <NEWLINE> for cnt in range ( h ) : <NEWLINE> <INDENT> c . append ( input ( ) ) <NEWLINE> <NL> <DEDENT> black_num = 0 <NEWLINE> temp_list = [ ] <NEWLINE> row_bit = [ ] <NEWLINE> line_bit = [ ] <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> if 1 == 2 : <NEWLINE> <NL> else : <NEWLINE> <INDENT> for i in range ( 2 ** h ) : <NEWLINE> <INDENT> temp_bit = [ 0 ] * h <NEWLINE> <NL> for j in range ( h ) : <NEWLINE> <INDENT> if ( ( i >> j ) & 1 ) : <NEWLINE> <INDENT> temp_bit [ h - 1 - j ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> row_bit . append ( temp_bit ) <NEWLINE> <NL> <DEDENT> for i in range ( 2 ** w ) : <NEWLINE> <INDENT> temp_bit = [ 0 ] * w <NEWLINE> <NL> for j in range ( w ) : <NEWLINE> <INDENT> if ( ( i >> j ) & 1 ) : <NEWLINE> <INDENT> temp_bit [ w - 1 - j ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> line_bit . append ( temp_bit ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> for cnt_row in range ( 2 ** h ) : <NEWLINE> <INDENT> for cnt_line in range ( 2 ** w ) : <NEWLINE> <INDENT> temp_list = [ ] <NEWLINE> black_num = 0 <NEWLINE> for cnt_h in range ( h ) : <NEWLINE> <INDENT> if row_bit [ cnt_row ] [ cnt_h ] == 0 : <NEWLINE> <COMMENT> <NL> <INDENT> for cnt_w in range ( w ) : <NEWLINE> <INDENT> if line_bit [ cnt_line ] [ cnt_w ] == 0 : <NEWLINE> <COMMENT> <NL> <INDENT> if c [ cnt_h ] [ cnt_w ] == <STRING> : <NEWLINE> <INDENT> black_num += 1 <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if black_num == k : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT>
import copy <NEWLINE> H , W , K = map ( int , input ( ) . split ( ) ) <NEWLINE> L = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( H ) ] <NEWLINE> ans = 0 <NEWLINE> for i in range ( 2 ** H ) : <NEWLINE> <INDENT> for j in range ( 2 ** W ) : <NEWLINE> <INDENT> C = copy . deepcopy ( L ) <NEWLINE> for k range ( H ) : <NEWLINE> <INDENT> if ( i >> k & 1 ) : <NEWLINE> <INDENT> C [ k ] = [ <STRING> ] * W <NEWLINE> <DEDENT> <DEDENT> for l range ( W ) : <NEWLINE> <INDENT> if ( j >> l & 1 ) : <NEWLINE> <INDENT> for m range ( H ) : <NEWLINE> <INDENT> C [ l ] [ m ] = <STRING> <NEWLINE> <DEDENT> <DEDENT> <DEDENT> count = 0 <NEWLINE> for i in range ( H ) : <NEWLINE> <INDENT> for j in range ( W ) : <NEWLINE> <INDENT> if C [ i ] [ j ] == <STRING> : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if count == K : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
row , col , num = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> tmp_l = [ ] <NEWLINE> board = [ ] <NEWLINE> for i in range ( row ) : <NEWLINE> <INDENT> str = input ( ) <NEWLINE> for j in range ( col ) : <NEWLINE> <INDENT> if str [ j ] == <STRING> : <NEWLINE> <INDENT> tmp_l . append ( 0 ) <NEWLINE> <DEDENT> if str [ j ] == <STRING> : <NEWLINE> <INDENT> tmp_l . append ( 1 ) <NEWLINE> <DEDENT> <DEDENT> board . append ( tmp_l ) <NEWLINE> tmp_l = [ ] <NEWLINE> <NL> <DEDENT> onoff = [ ] <NEWLINE> bi = [ 32 , 16 , 8 , 4 , 2 , 1 ] <NEWLINE> for i in range ( 64 ) : <NEWLINE> <INDENT> tmp = i <NEWLINE> for j in bi : <NEWLINE> <INDENT> tmp_l . insert ( 0 , int ( tmp / j ) ) <NEWLINE> tmp = tmp % j <NEWLINE> <DEDENT> onoff . append ( tmp_l ) <NEWLINE> tmp_l = [ ] <NEWLINE> <NL> <DEDENT> count = 0 <NEWLINE> ans = 0 <NEWLINE> for i in range ( 2 ** row ) : <NEWLINE> <INDENT> for j in range ( 2 ** col ) : <NEWLINE> <INDENT> for k in range ( row ) : <NEWLINE> <INDENT> if onoff [ i ] [ k ] == 1 : <NEWLINE> <INDENT> for l in range ( col ) : <NEWLINE> <INDENT> if onoff [ j ] [ l ] == 1 : <NEWLINE> <INDENT> if board [ l ] [ k ] == 1 : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if count == num : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> count = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> def input2 ( ) : <NEWLINE> <INDENT> return map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <DEDENT> H , W , K = input2 ( ) <NEWLINE> c = [ list ( input ( ) ) for _ in range ( H ) ] <NEWLINE> <NL> ans = 0 <NEWLINE> print ( c ) <NEWLINE> <NL> for row_line in product ( range ( 2 ) , repeat = H ) : <COMMENT> <NEWLINE> <INDENT> for col_line in product ( range ( 2 ) , repeat = W ) : <COMMENT> <NEWLINE> <COMMENT> <NL> <INDENT> cnt = 0 <NEWLINE> for row in range ( H ) : <NEWLINE> <INDENT> for col in range ( W ) : <NEWLINE> <INDENT> if c [ row ] [ col ] == <STRING> and row_line [ row ] == 0 and col_line [ col ] == 0 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if cnt == K : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
h , w , k = map ( int , input ( ) . split ( ) ) <NEWLINE> dot = [ list ( input ( ) ) for i in range ( h ) ] <NEWLINE> ans = 0 <NEWLINE> for i in range ( 2 ** h ) : <NEWLINE> <INDENT> for j in range ( 2 ** w ) : <NEWLINE> <NL> <INDENT> count = 0 <NEWLINE> <NL> for ii in range ( h ) : <NEWLINE> <INDENT> for jj in range ( w ) : <NEWLINE> <INDENT> if ( i >> ii ) == 0 & ( j >> jj ) == 0 : <NEWLINE> <INDENT> if dot [ i ] [ j ] == <STRING> : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if count == k : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> <NL> def count ( arr , k , H , W ) : <NEWLINE> <NL> <INDENT> num_ans = 0 <NEWLINE> <NL> for col in kumiawase ( arr ) : <NEWLINE> <INDENT> countlist = [ 0 ] * H <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> for i in range ( len ( col ) ) : <NEWLINE> <INDENT> count = 0 <NEWLINE> for j in range ( len ( col [ 0 ] ) ) : <NEWLINE> <INDENT> if col [ i ] [ j ] == 1 : <NEWLINE> <INDENT> countlist [ j ] = countlist [ j ] + 1 <NEWLINE> <COMMENT> <NL> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> for x in kumiawase ( countlist ) : <NEWLINE> <INDENT> if sum ( x ) == k : <NEWLINE> <INDENT> num_ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( num_ans ) <NEWLINE> <NL> <DEDENT> def kumiawase ( list ) : <NEWLINE> <COMMENT> <NL> <NL> <INDENT> returnlist = [ ] <NEWLINE> num_kumi = 2 ** len ( list ) <NEWLINE> for i in range ( num_kumi ) : <NEWLINE> <INDENT> tmplist = [ ] <NEWLINE> for j in range ( len ( list ) ) : <NEWLINE> <INDENT> if ( i >> j ) % 2 == 1 : <NEWLINE> <INDENT> tmplist . append ( list [ j ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> returnlist . append ( tmplist ) <NEWLINE> <NL> <DEDENT> return returnlist <NEWLINE> <NL> <NL> <DEDENT> def printarr ( arr ) : <NEWLINE> <INDENT> for i in range ( len ( arr ) ) : <NEWLINE> <INDENT> for j in range ( len ( arr [ 0 ] ) ) : <NEWLINE> <INDENT> print ( arr [ i ] [ j ] , end = <STRING> ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> H , W , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> arr = [ ] <NEWLINE> count_H = [ ] <NEWLINE> total = 0 <NEWLINE> for i in range ( H ) : <NEWLINE> <INDENT> list = [ ] <NEWLINE> inp = input ( ) <NEWLINE> for j in range ( W ) : <NEWLINE> <INDENT> num = 0 <NEWLINE> if <STRING> == inp [ j ] : <NEWLINE> <INDENT> list . append ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> list . append ( 1 ) <NEWLINE> num += 1 <NEWLINE> total += 1 <NEWLINE> <DEDENT> <DEDENT> arr . append ( list ) <NEWLINE> count_H . append ( num ) <NEWLINE> <NL> <DEDENT> count_W = [ ] <NEWLINE> for i in range ( W ) : <NEWLINE> <INDENT> num = 0 <NEWLINE> for j in range ( H ) : <NEWLINE> <INDENT> num += 1 <NEWLINE> <DEDENT> count_W . append ( num ) <NEWLINE> <NL> <COMMENT> <NL> <NL> <NL> <DEDENT> count ( arr , K , H , W ) <NEWLINE> <DEDENT>
from itertools import product <NEWLINE> <NL> h , w , k = map ( int , input ( ) . split ( ) ) <NEWLINE> c = [ list ( input ( ) . split ( ) ) for _ in range ( h ) ] <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> for row_bit in product ( range ( 2 ) , repeat = h ) : <NEWLINE> <INDENT> for col_bit in product ( range ( 2 ) , repeat = w ) : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> for row in range ( h ) : <NEWLINE> <INDENT> for col in range ( w ) : <NEWLINE> <INDENT> if ( c [ row ] [ col ] == <STRING> ) and ( ( row_bit [ row ] == 0 ) and ( col_bit [ col ] == 0 ) ) : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if cnt == k : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> H , W , K = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ ] <NEWLINE> for i in range ( H ) : <NEWLINE> <INDENT> a . append ( sys . stdin . read ( ) ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in range ( 2 ** H ) : <NEWLINE> <INDENT> for j in range ( 2 ** W ) : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> for s in range ( H ) : <NEWLINE> <INDENT> for t in range ( W ) : <NEWLINE> <INDENT> if ( i >> s ) & 1 and ( j >> t ) & 1 and a [ s ] [ t ] == <STRING> : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if cnt == K : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import heapq <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ) ) <NEWLINE> a . sort ( reverse = True ) <NEWLINE> <NL> ans = 0 <NEWLINE> heap = [ ] <NEWLINE> heapq . heappush ( heap , - a [ 0 ] ) <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> tmp = heapq . heappop ( heap ) <NEWLINE> tmp *= - 1 <NEWLINE> ans += tmp <NEWLINE> heapq . heappush ( heap , - a [ i ] ) <NEWLINE> heapq . heappush ( heap , - a [ i ] ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> A . sort ( reversed = True ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> ans += A [ ( i + 1 ) // 2 ] <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) . sort ( reverse = True ) <NEWLINE> <NL> if len ( A ) <= 2 : <NEWLINE> <INDENT> print ( sum ( A ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = A [ 0 ] + 2 * sum ( A [ 1 : math . floor ( n / 2 ) ] ) + ( N % 2 ) * A [ math . floor [ n / 2 ] ] <NEWLINE> print ( ans ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) . sorted ( ) <NEWLINE> <NL> len_A = len ( A ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , len_A - 1 ) : <NEWLINE> <INDENT> ans += A [ len_A - 1 - int ( i / 2 ) ] <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
input ( ) print ( sum ( sorted ( map ( int , input ( ) . split ( ) ) ) [ 1 : ] ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int . input ( ) . split ( ) ) ) <NEWLINE> a . sort ( reverse = True ) <NEWLINE> ans = 0 <NEWLINE> x = n <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> ans += a [ i // 2 ] <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> ans = A [ N ] <NEWLINE> cnt = 1 <NEWLINE> i = 1 <NEWLINE> <NL> while cnt <= N : <NEWLINE> <INDENT> ans += 2 * A [ N - i ] <NEWLINE> i += 1 <NEWLINE> cnt += 2 <NEWLINE> <NL> <DEDENT> if N != cnt : <NEWLINE> <INDENT> ans -= A [ N - i ] <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
n = int ( inpput ( ) ) <NEWLINE> a = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> a . sort ( reverse = True ) <NEWLINE> ans = 0 <NEWLINE> ans += a [ 0 ] <NEWLINE> for i in range ( 2 , n ) : <NEWLINE> <INDENT> ans += min ( a [ i - 1 ] , a [ i - 2 ] ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a . sort ( reverse = True ) <NEWLINE> ans = 0 <NEWLINE> if n % 2 == 0 : <NEWLINE> <INDENT> for i in range ( 1 , n // 2 ) : <NEWLINE> <INDENT> ans += 2 * a [ i ] <NEWLINE> <DEDENT> ans += ans [ 0 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( 1 , n // 2 ) : <NEWLINE> <INDENT> ans += 2 * a [ i ] <NEWLINE> <DEDENT> ans += a [ n // 2 ] <NEWLINE> ans += a [ 0 ] <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import bisect <NEWLINE> import statistics <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = list ( ( int ( x ) for x in input ( ) . split ( ) ) ) <NEWLINE> <NL> a . sort ( ) <NEWLINE> incl = [ ] <NEWLINE> score = 0 <NEWLINE> <NL> for i in range ( len ( a ) ) : <NEWLINE> <INDENT> ain = a . pop ( ) <NEWLINE> incl . append ( ain ) <NEWLINE> if i == 0 : continue <NEWLINE> if ( len ( incl ) % 2 == 1 ) : <NEWLINE> <INDENT> score += incl [ int ( len ( incl ) ) / 2 ] <NEWLINE> <DEDENT> else : <NEWLINE> <COMMENT> <NL> <INDENT> score += incl [ int ( len ( incl ) / 2 ) - 1 ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( score ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> A = sorted ( A , reverse = True ) <NEWLINE> ans = a [ 0 ] <NEWLINE> if n == 2 : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a = a [ 1 ] <NEWLINE> for i in range ( N - 2 ) : <NEWLINE> <INDENT> idx = i // 2 <NEWLINE> ans += a [ idx ] <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
import math <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> Asrt = sorted ( A , reverse = True ) <NEWLINE> <NL> <NL> num = math . ceil ( N / 2 ) <NEWLINE> <NL> a = Asrt ( [ : num ] ) <NEWLINE> <NL> if N % 2 == 0 : <COMMENT> <NEWLINE> <INDENT> print ( sum ( a ) * 2 - a [ 0 ] ) <NEWLINE> <DEDENT> else : <COMMENT> <NEWLINE> <INDENT> print ( sum ( a ) * 2 - a [ 0 ] - a [ - 1 ] ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map , ( int , input ( ) . split ( ) ) ) <NEWLINE> a . sort ( ) <NEWLINE> c = int ( a [ - 1 ] ) <NEWLINE> if n % 2 == 0 : <NEWLINE> <INDENT> n1 = n // 2 - 1 <NEWLINE> for i in range ( n1 ) : <NEWLINE> <INDENT> a1 = int ( a [ n - 2 - i ] ) <NEWLINE> c += a1 * 2 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> n2 = n // 2 <NEWLINE> a3 = int ( a [ n - n2 - 1 ] ) <NEWLINE> c += a3 <NEWLINE> for i in range ( n2 - 1 ) : <NEWLINE> <INDENT> a2 = int ( a [ n - 2 - i ] ) <NEWLINE> c += a2 * 2 <NEWLINE> <DEDENT> <DEDENT> print ( c ) <NEWLINE>
from collections import deque <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A . sort ( reversre = True ) <NEWLINE> ans = 0 <NEWLINE> d = deque ( A [ 0 ] ) <NEWLINE> for x in A [ 1 : ] : <NEWLINE> <INDENT> ans += d . popleft ( ) <NEWLINE> d . append ( x ) <NEWLINE> d . append ( x ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a_list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a_list . sort ( reverse = True ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 0 , n - 1 ) : <NEWLINE> <INDENT> ans += A [ ( i + 1 ) // 2 ] <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = map ( int , input ( ) . split ( ) ) <NEWLINE> a = sorted ( a ) <NEWLINE> <NL> result = 0 <NEWLINE> spots = [ a . pop ( ) ] <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> next = a . pop ( ) <NEWLINE> result += spots [ i ] <NEWLINE> spots . append ( next ) <NEWLINE> spots . append ( next ) <NEWLINE> <NL> <DEDENT> print ( result ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A = sorted ( A , reverse = True ) <NEWLINE> <NL> L = len ( P ) // 2 <NEWLINE> <NL> if len ( A ) % 2 == 0 : <NEWLINE> <COMMENT> <NL> <INDENT> ans = sum ( A [ : L ] ) + sum ( A [ 1 : L ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <COMMENT> <NL> <INDENT> ans = sum ( A [ : L ] ) + sum ( A [ 1 : L + 1 ] ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a . sort ( ) <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> ans += a [ n - int ( i / 2 ) ] <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = sorted ( b , reverse = True ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ans += b [ ( i + 1 ) // 2 ] <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> import numpy as np <NEWLINE> <NL> read = sys . stdin . read <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> a = np . array ( readline ( ) . split ( ) , dtype = np . int64 ) <NEWLINE> a . sort ( ) <NEWLINE> a = a [ : : - 1 ] <NEWLINE> m = - ( - n // 2 ) <NEWLINE> ans = np . sum ( a [ : m ] ) * 2 - a [ 0 ] if n % 2 == 0 else np . sum ( a [ : m ] ) * 2 - a [ 0 ] - a [ m ] <NEWLINE> print ( ans ) <NEWLINE>
total = 0 <NEWLINE> <NL> for _ in range ( int ( input ( ) ) ) <NEWLINE> <INDENT> list1 = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for ele in range ( 0 , len ( list1 ) ) : <NEWLINE> <INDENT> total = total + list1 [ ele ] <NEWLINE> <DEDENT> print ( total - min ( list1 ) ) <NEWLINE> <DEDENT>
import sys <NEWLINE> import math <NEWLINE> import collections <NEWLINE> import heapq <NEWLINE> <NL> def set_debug ( debug_mode = False ) : <NEWLINE> <INDENT> if debug_mode : <NEWLINE> <INDENT> fin = open ( <STRING> , <STRING> ) <NEWLINE> sys . stdin = fin <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def int_input ( ) : <NEWLINE> <INDENT> return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> set_debug ( True ) <NEWLINE> <NL> <COMMENT> <NL> t = 1 <NEWLINE> <NL> for ti in range ( 1 , t + 1 ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> <NL> A = int_input ( ) <NEWLINE> <NL> A . sort ( reverse = True ) <NEWLINE> <NL> res = sum ( A [ : - 1 ] ) <NEWLINE> <NL> print ( res ) <NEWLINE> <NL> <DEDENT> <DEDENT>
import math <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = sorted ( a ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> ans += b [ n - ( math . floor ( i / 2 ) ) ] <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
from collections import deque <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = sorted ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> q = deque ( ) <NEWLINE> a = a . pop ( ) <NEWLINE> b = a . pop ( ) <NEWLINE> ans = a + b <NEWLINE> q . append ( ( a , b ) ) <NEWLINE> q . append ( ( a , b ) ) <NEWLINE> while A : <NEWLINE> <INDENT> c = A . pop ( ) <NEWLINE> a , b = q . popleft ( ) <NEWLINE> ans += min ( a , b ) <NEWLINE> q . append ( ( a , c ) ) <NEWLINE> q . append ( ( c , b ) ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> arr = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> arr = sorted ( ans , reverse = True ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> ans += arr [ i // 2 ] <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> A . append ( int ( input ( ) ) ) <NEWLINE> <DEDENT> print ( sum ( A ) - min ( A ) ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> from queue import Queue <NEWLINE> from queue import LifoQueue as Stack <NEWLINE> from math import sqrt , floor , ceil , log2 , log10 , pi <NEWLINE> from fractions import gcd <NEWLINE> from itertools import permutations , combinations <NEWLINE> from operator import itemgetter <NEWLINE> from functools import cmp_to_key <NEWLINE> <NL> <NL> INF = 1001001001 <NEWLINE> __MOD__ = ( 10 ** 9 ) + 7 <NEWLINE> yn = <STRING> <NEWLINE> judge = False <NEWLINE> cnt = 0 <NEWLINE> ans = None <NEWLINE> <NL> <NL> def lcm ( a , b ) : <NEWLINE> <INDENT> return ( a * b ) // gcd ( a , b ) <NEWLINE> <NL> <DEDENT> def intinput ( ) : <NEWLINE> <INDENT> return int ( input ( ) ) <NEWLINE> <NL> <DEDENT> def mulinputs ( ) : <NEWLINE> <INDENT> return map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <DEDENT> def lineinputs ( func = intinput ) : <NEWLINE> <INDENT> datas = [ ] <NEWLINE> while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> datas . append ( func ( ) ) <NEWLINE> <DEDENT> except EOFError : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> return datas <NEWLINE> <NL> <DEDENT> class ModInt ( ) : <NEWLINE> <INDENT> def __init__ ( self , x ) : <NEWLINE> <INDENT> self . __x = ( x % __MOD__ ) <NEWLINE> <DEDENT> def __add__ ( self , other ) : <NEWLINE> <INDENT> if type ( other ) == int : <NEWLINE> <INDENT> other = self . __class__ ( other ) <NEWLINE> return int ( self . __class__ ( ( self . __x + other . __x ) % __MOD__ ) ) <NEWLINE> <DEDENT> elif type ( other ) == ModInt : <NEWLINE> <INDENT> return self . __class__ ( ( self . __x + other . __x ) % __MOD__ ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> raise Exception ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> def __radd__ ( self , other ) : <NEWLINE> <INDENT> if type ( other ) == int : <NEWLINE> <INDENT> other = self . __class__ ( other ) <NEWLINE> return int ( self . __class__ ( ( other . __x + self . __x ) % __MOD__ ) ) <NEWLINE> <DEDENT> elif type ( other ) == ModInt : <NEWLINE> <INDENT> return self . __class__ ( ( other . __x + self . __x ) % __MOD__ ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> raise Exception ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> def __sub__ ( self , other ) : <NEWLINE> <INDENT> if type ( other ) == int : <NEWLINE> <INDENT> other = self . __class__ ( other ) <NEWLINE> return int ( self . __class__ ( ( self . __x - other . __x ) % __MOD__ ) ) <NEWLINE> <DEDENT> elif type ( other ) == ModInt : <NEWLINE> <INDENT> return self . __class__ ( ( self . __x - other . __x ) % __MOD__ ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> raise Exception ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> def __rsub__ ( self , other ) : <NEWLINE> <INDENT> if type ( other ) == int : <NEWLINE> <INDENT> other = self . __class__ ( other ) <NEWLINE> return int ( self . __class__ ( ( other . __x - self . __x ) % __MOD__ ) ) <NEWLINE> <DEDENT> elif type ( other ) == ModInt : <NEWLINE> <INDENT> return self . __class__ ( ( other . __x - self . __x ) % __MOD__ ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> raise Exception ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> def __mul__ ( self , other ) : <NEWLINE> <INDENT> if type ( other ) == int : <NEWLINE> <INDENT> other = self . __class__ ( other ) <NEWLINE> return int ( self . __class__ ( ( self . __x * other . __x ) % __MOD__ ) ) <NEWLINE> <DEDENT> elif type ( other ) == ModInt : <NEWLINE> <INDENT> return self . __class__ ( ( self . __x * other . __x ) % __MOD__ ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> raise Exception ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> def __rmul__ ( self , other ) : <NEWLINE> <INDENT> if type ( other ) == int : <NEWLINE> <INDENT> other = self . __class__ ( other ) <NEWLINE> return int ( self . __class__ ( ( other . __x * self . __x ) % __MOD__ ) ) <NEWLINE> <DEDENT> elif type ( other ) == ModInt : <NEWLINE> <INDENT> return self . __class__ ( ( other . __x * self . __x ) % __MOD__ ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> raise Exception ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> def __truediv__ ( self , other ) : <NEWLINE> <INDENT> if type ( other ) == int : <NEWLINE> <INDENT> other = self . __class__ ( other ) <NEWLINE> return int ( self . __class__ ( ( self . __x * other . __modinv ( ) ) % __MOD__ ) ) <NEWLINE> <DEDENT> elif type ( other ) == ModInt : <NEWLINE> <INDENT> return self . __class__ ( ( self . __x * other . __modinv ( ) ) % __MOD__ ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> raise Exception ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> def __rtruediv__ ( self , other ) : <NEWLINE> <INDENT> if type ( other ) == int : <NEWLINE> <INDENT> other = self . __class__ ( other ) <NEWLINE> return int ( self . __class__ ( ( other . __x * self . __modinv ( ) ) % __MOD__ ) ) <NEWLINE> <DEDENT> elif type ( other ) == ModInt : <NEWLINE> <INDENT> return self . __class__ ( ( other . __x * self . __modinv ( ) ) % __MOD__ ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> raise Exception ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> def __pow__ ( self , other ) : <NEWLINE> <INDENT> if type ( other ) == int : <NEWLINE> <INDENT> other = self . __class__ ( other ) <NEWLINE> return int ( self . __class__ ( pow ( self . __x , other . __x , __MOD__ ) ) ) <NEWLINE> <DEDENT> elif type ( other ) == ModInt : <NEWLINE> <INDENT> return self . __class__ ( pow ( self . __x , other . __x , __MOD__ ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> raise Exception ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> def __rpow__ ( self , other ) : <NEWLINE> <INDENT> if type ( other ) == int : <NEWLINE> <INDENT> other = self . __class__ ( other ) <NEWLINE> return int ( self . __class__ ( pow ( other . __x , self . __x , __MOD__ ) ) ) <NEWLINE> <DEDENT> elif type ( other ) == ModInt : <NEWLINE> <INDENT> return self . __class__ ( pow ( other . __x , self . __x , __MOD__ ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> raise Exception ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> def __modinv ( self , m = __MOD__ ) : <NEWLINE> <INDENT> a = self . __x <NEWLINE> if a == 0 : <NEWLINE> <INDENT> raise ZeroDivisionError ( ) <NEWLINE> <DEDENT> if gcd ( a , m ) != 1 : <NEWLINE> <INDENT> raise Exception ( <STRING> % a ) <NEWLINE> <DEDENT> b , u , v = m , 1 , 0 <NEWLINE> while b != 0 : <NEWLINE> <INDENT> t = a // b ; <NEWLINE> a -= t * b <NEWLINE> a , b = b , a <NEWLINE> u -= t * v <NEWLINE> u , v = v , u <NEWLINE> <DEDENT> u %= m <NEWLINE> if u < 0 : <NEWLINE> <INDENT> u += m <NEWLINE> <DEDENT> return u <NEWLINE> <DEDENT> def __int__ ( self ) : <NEWLINE> <INDENT> return self . __x <NEWLINE> <DEDENT> def __str__ ( self ) : <NEWLINE> <INDENT> return str ( self . __x ) <NEWLINE> <NL> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> N = intinput ( ) <NEWLINE> a_arr = list ( mulinputs ( ) ) <NEWLINE> l = len ( a_arr ) <NEWLINE> is_odd = l % 2 <NEWLINE> a_arr . sort ( reverse = True ) <NEWLINE> <NL> <COMMENT> <NL> ans = a_arr . pop ( 0 ) <NEWLINE> for _ in range ( int ( l // 2 ) - 1 ) : <NEWLINE> <INDENT> ans += ( a_arr . pop ( 0 ) * 2 ) <NEWLINE> <DEDENT> if is_odd : <NEWLINE> <INDENT> ans += a_arr . pop ( 0 ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> A . sort ( reverse = True ) <NEWLINE> <NL> ans = 0 <NEWLINE> ans += A [ 0 ] <NEWLINE> for i in range ( 1 , N - 1 ) : <NEWLINE> <INDENT> ans += A [ tmp ] <NEWLINE> if i % 2 == 0 : <NEWLINE> <INDENT> tmp += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> A . sort ( ) <NEWLINE> A . reverse ( ) <NEWLINE> <NL> list = [ ] <NEWLINE> ans = 0 <NEWLINE> list . append ( A [ 0 ] ) <NEWLINE> for i in range ( len ( A ) ) : <NEWLINE> <INDENT> ans += list [ i ] <NEWLINE> list . append ( A [ i + 1 ] ) <NEWLINE> list . append ( A [ i + 1 ] ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> ls = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ls . sort ( reserved = True ) <NEWLINE> ans = ls [ 0 ] <NEWLINE> pls = [ ls . pop ( 0 ) , ls . pop ( 0 ) ] <COMMENT> <NEWLINE> cnt = 0 <COMMENT> <NEWLINE> scnt = 0 <COMMENT> <NEWLINE> <NL> for i in ls : <NEWLINE> <INDENT> pls . append ( i ) <NEWLINE> ans += pls [ cnt + 1 ] <NEWLINE> if scnt == 0 : <NEWLINE> <INDENT> scnt = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> scnt = 0 <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> A = sorted ( A , reverse = True ) <NEWLINE> <NL> la = len ( A ) <NEWLINE> <NL> for i in range ( la - 1 ) : <NEWLINE> <INDENT> ans += A [ i ] <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
a = int ( input ( ) ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b . sort ( reverse = True ) <NEWLINE> if a % 2 == 0 : <NEWLINE> <INDENT> print ( sum ( b [ : a // 2 - 1 ] * 2 - b [ 0 ] ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( sum ( b [ : a // 2 + 1 ] * 2 - b [ 0 ] - b [ a // 2 ] ) <NEWLINE> <DEDENT>
4 <NEWLINE> 2 2 1 3 <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = input ( ) . split ( ) <NEWLINE> a = [ 0 for i in range ( n + 1 ) ] <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> a [ i ] = int ( a [ i - 1 ] ) <NEWLINE> <NL> <DEDENT> a [ 0 ] = 1000000000 <NEWLINE> <NL> m = floor ( ( n - 2 ) / 2 ) <NEWLINE> <NL> a = sorted ( a , reverse = True ) <NEWLINE> comfort = a [ 1 ] <NEWLINE> if ( n == 2 ) : <NEWLINE> <INDENT> print ( comfort ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if ( n % 2 == 0 ) : <NEWLINE> <INDENT> for i in range ( 2 , m + 2 ) : <NEWLINE> <INDENT> comfort += ( 2 * a [ i ] ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( 2 , m + 2 ) : <NEWLINE> <INDENT> comfort += ( 2 * a [ i ] ) <NEWLINE> <NL> <DEDENT> comfort += a [ m + 2 ] <NEWLINE> <NL> <NL> <DEDENT> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> friendliness = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> friendliness . sort ( reversed = True ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ans += friendliness [ i // 2 + 1 ] <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> A . sort ( Reverse = True ) <NEWLINE> <NL> print ( A . sum - A [ - 1 ] ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> A . sort ( reverse = True ) <NEWLINE> ans = 0 <NEWLINE> <NL> if N % 2 == 1 : <NEWLINE> <INDENT> k = ( N + 1 ) / 2 <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> ans += A [ i ] * 2 <NEWLINE> <DEDENT> ans -= A [ 0 ] <NEWLINE> ans -= A [ k ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> k = N / 2 <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> ans += A [ i ] * 2 <NEWLINE> <DEDENT> ans -= A [ 0 ] <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> a = sorted ( list ( map ( int , input ( ) . split ( ) ) ) , reverse = True ) <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> for i in range ( n - 1 ) : <NEWLINE> <INDENT> ans += a [ ( i + 1 ) // 2 ] <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
heapq . heapify ( b ) <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a . sort ( reverse = True ) <NEWLINE> a = deque ( a ) <NEWLINE> <NL> heapq . heappush ( b , - 1 * a . popleft ( ) ) <NEWLINE> ans = 0 <NEWLINE> <NL> while len ( a ) > 0 : <NEWLINE> <INDENT> temp = a . popleft ( ) <NEWLINE> point = - 1 * heapq . heappop ( b ) <NEWLINE> ans += point <NEWLINE> heapq . heappush ( b , - 1 * temp ) <NEWLINE> heapq . heappush ( b , - 1 * temp ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
import numpy as np <NEWLINE> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> if N == K : <NEWLINE> <INDENT> ans0 = 1 <NEWLINE> for a in A [ 0 : N ] : <NEWLINE> <INDENT> ans0 *= a <NEWLINE> ans0 %= MOD <NEWLINE> <DEDENT> print ( ans0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> A = sorted ( A ) <NEWLINE> if ( K % 2 == 1 and A [ - 1 ] < 0 ) : <NEWLINE> <INDENT> ans1 = 1 <NEWLINE> for a in A [ N - K : N ] : <NEWLINE> <INDENT> ans1 *= a <NEWLINE> ans1 %= MOD <NEWLINE> <DEDENT> print ( ans1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> A = sorted ( A , key = lambda x : abs ( x ) , reverse = True ) <NEWLINE> AA = [ np . sign ( i ) for i in A ] <NEWLINE> <NL> ansA = 1 <NEWLINE> for a in A [ 0 : K ] : <NEWLINE> <INDENT> ansA *= a <NEWLINE> ansA %= MOD <NEWLINE> <DEDENT> ansAA = AA [ 0 : K ] . count ( - 1 ) % 2 <NEWLINE> if ansA == 0 or ansAA == 0 : <NEWLINE> <INDENT> print ( ansA ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> while ansA > 0 : <NEWLINE> <INDENT> ansA -= MOD <NEWLINE> <NL> <DEDENT> B1 = A [ 0 : K ] <NEWLINE> B2 = sorted ( A [ K : N ] ) <NEWLINE> Bp = [ i for i in A [ 0 : K ] if i > 0 ] <NEWLINE> Bm = [ i for i in A [ 0 : K ] if i < 0 ] <NEWLINE> <NL> if B2 [ 0 ] > 0 : B2 . insert ( 0 , 0 ) <NEWLINE> if B2 [ - 1 ] < 0 : B2 . insert ( - 1 , 0 ) <NEWLINE> if not Bp : Bp . insert ( 0 , B1 [ - 1 ] ) <NEWLINE> if not Bm : Bm . insert ( 0 , B1 [ 0 ] ) <NEWLINE> <NL> <COMMENT> <NL> <NL> B1 . remove ( Bp [ - 1 ] ) <NEWLINE> B1 . append ( min ( B2 [ 0 ] , 0 ) ) <NEWLINE> <COMMENT> <NL> ansB = 1 <NEWLINE> for a in B1 [ 0 : K ] : <NEWLINE> <INDENT> ansB *= a <NEWLINE> ansB %= MOD <NEWLINE> <NL> <DEDENT> C1 = A [ 0 : K ] <NEWLINE> C1 . remove ( Bm [ - 1 ] ) <NEWLINE> C1 . append ( max ( B2 [ - 1 ] , 0 ) ) <NEWLINE> <NL> ansC = 1 <NEWLINE> for a in C1 [ 0 : K ] : <NEWLINE> <INDENT> ansC *= a <NEWLINE> ansC %= MOD <NEWLINE> <NL> <DEDENT> if abs ( Bp [ - 1 ] * B2 [ - 1 ] ) - abs ( Bm [ 0 ] * B2 [ 0 ] ) = > 0 : <NEWLINE> <INDENT> print ( ansC ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> else : print ( ansB ) <NEWLINE> <NL> <COMMENT> <NL>
<COMMENT> <NL> mod = 10 ** 9 + 7 <NEWLINE> def multarray ( x ) : <NEWLINE> <INDENT> ret = 1 <NEWLINE> for i in x : <NEWLINE> <INDENT> ret *= i <NEWLINE> ret %= mod <NEWLINE> <DEDENT> return ret <NEWLINE> <NL> <DEDENT> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <COMMENT> <NL> if n == k : <NEWLINE> <INDENT> print ( multarray ( a ) ) <NEWLINE> exit ( ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> ap , am = [ ] , [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if a [ i ] >= 0 : <NEWLINE> <INDENT> ap . append ( a [ i ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> am . append ( a [ i ] ) <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> ap . sort ( reverse = True ) <NEWLINE> am . sort ( ) <NEWLINE> <NL> <COMMENT> <NL> if len ( am ) == 0 : <NEWLINE> <INDENT> print ( multarray ( ap [ : k ] ) ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> if len ( ap ) == 0 : <NEWLINE> <INDENT> if k % 2 == 0 : <NEWLINE> <INDENT> print ( multarray ( am [ : k ] ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( multarray ( am [ : : - 1 ] [ : k ] ) ) <NEWLINE> <DEDENT> exit ( ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> apm2 = [ ] <NEWLINE> for i in range ( len ( am ) // 2 ) : <NEWLINE> <INDENT> apm2 . append ( ( am [ 2 * i ] * am [ 2 * i + 1 ] , 0 ) ) <NEWLINE> <DEDENT> for i in range ( len ( ap ) // 2 ) : <NEWLINE> <INDENT> apm2 . append ( ( ap [ 2 * i ] * ap [ 2 * i + 1 ] , 1 ) ) <NEWLINE> <DEDENT> apm2 . sort ( reverse = True ) <NEWLINE> <NL> <COMMENT> <NL> if k % 2 == 0 : <NEWLINE> <INDENT> print ( multarray ( apm2 [ : k // 2 ] ) ) <NEWLINE> exit ( ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> p = 0 <NEWLINE> ans = [ ] <NEWLINE> for i in range ( k // 2 ) : <NEWLINE> <INDENT> p += ( 2 * apm2 [ i ] [ 1 ] ) <NEWLINE> ans . append ( apm2 [ i ] [ 0 ] ) <NEWLINE> <NL> <DEDENT> ans_cand = [ ] <NEWLINE> <COMMENT> <NL> if p != len ( ap ) : <NEWLINE> <INDENT> ans_cand . append ( multarray ( ans ) * ap [ p ] % mod ) <NEWLINE> <COMMENT> <NL> <DEDENT> if p != 0 : <NEWLINE> <COMMENT> <NL> <INDENT> check_i = ans . index ( ap [ p - 1 ] * ap [ p - 2 ] ) <NEWLINE> <COMMENT> <NL> ans [ check_i ] = ap [ p - 2 ] <NEWLINE> ans . append ( apm2 [ k // 2 ] [ 0 ] ) <NEWLINE> ans_cand . append ( multarray ( ans ) ) <NEWLINE> <DEDENT> print ( max ( ans_cand ) ) <NEWLINE>
from heapq import heappush , heappop <NEWLINE> <NL> <NL> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A = sorted ( A , reverse = True ) <NEWLINE> <NL> MOD = 10 ** 9 + 7 <NEWLINE> <NL> <COMMENT> <NL> if N == K : <NEWLINE> <INDENT> ans = 1 <NEWLINE> for i in range ( K ) : <NEWLINE> <INDENT> ans *= A [ i ] <NEWLINE> ans %= MOD <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <COMMENT> <NL> <DEDENT> elif max ( A ) < 0 and K % 2 == 1 : <NEWLINE> <INDENT> ans = 1 <NEWLINE> for i in range ( K ) : <NEWLINE> <INDENT> ans *= A [ i ] <NEWLINE> ans %= MOD <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <DEDENT> else : <NEWLINE> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <INDENT> if K % 2 == 1 : <NEWLINE> <INDENT> ans = A . pop ( 0 ) <COMMENT> <NEWLINE> n = ( K - 1 ) // 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = 1 <NEWLINE> n = K // 2 <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> A = sorted ( A , key = lambda x : abs ( x ) , reverse = True ) <NEWLINE> <NL> <COMMENT> <NL> cand = [ ] <COMMENT> <NEWLINE> <NL> BIGINT = 10 ** 9 + 1 <COMMENT> <NEWLINE> tmp1 = BIGINT <NEWLINE> tmp2 = BIGINT <NEWLINE> for a in A : <NEWLINE> <INDENT> if a >= 0 : <NEWLINE> <INDENT> if tmp1 == BIGINT : <NEWLINE> <INDENT> tmp1 = A <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> heappush ( cand , - tmp1 * a ) <NEWLINE> tmp1 = BIGINT <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if tmp2 == BIGINT : <NEWLINE> <INDENT> tmp2 = a <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> heappush ( cand , - tmp2 * a ) <NEWLINE> tmp2 = BIGINT <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> ans *= - heappop ( cand ) <NEWLINE> ans %= MOD <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
from collections import deque <NEWLINE> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> a . sort ( reverse = True ) <NEWLINE> ans = 1 <NEWLINE> plus = [ ] <NEWLINE> minus = [ ] <NEWLINE> <NL> if n == k : <NEWLINE> <INDENT> for i in range ( n ) : <NEWLINE> <INDENT> ans *= a [ i ] <NEWLINE> ans %= mod <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> if a [ i ] >= 0 : <NEWLINE> <INDENT> plus . append ( a [ i ] ) <NEWLINE> <DEDENT> elif a [ i ] < 0 : <NEWLINE> <INDENT> minus . append ( a [ i ] ) <NEWLINE> <DEDENT> <DEDENT> if not plus and k % 2 == 1 : <NEWLINE> <INDENT> minus . sort ( reverse = True ) <NEWLINE> for i in minus : <NEWLINE> <INDENT> ans *= minus <NEWLINE> ans %= mod <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> plus . sort ( reverse = True ) <NEWLINE> minus . sort ( ) <NEWLINE> plus = deque ( plus ) <NEWLINE> minus = deque ( minus ) <NEWLINE> cou = [ ] <NEWLINE> while True : <NEWLINE> <INDENT> if len ( cou ) == k : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> elif len ( cou ) == k - 1 : <NEWLINE> <INDENT> cou . append ( plus . popleft ( ) ) <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if len ( plus ) >= 2 and len ( minus ) >= 2 : <NEWLINE> <INDENT> p1 = plus . popleft ( ) <NEWLINE> p2 = plus . popleft ( ) <NEWLINE> m1 = minus . popleft ( ) <NEWLINE> m2 = minus . popleft ( ) <NEWLINE> if p1 * p2 > m1 * m2 : <NEWLINE> <INDENT> cou . append ( p1 ) <NEWLINE> cou . append ( p2 ) <NEWLINE> minus . appendleft ( m2 ) <NEWLINE> minus . appendleft ( m1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cou . append ( m1 ) <NEWLINE> cou . append ( m2 ) <NEWLINE> plus . appendleft ( p2 ) <NEWLINE> plus . appendleft ( p1 ) <NEWLINE> <DEDENT> <DEDENT> elif len ( plus ) < 2 : <NEWLINE> <INDENT> m1 = minus . popleft ( ) <NEWLINE> m2 = minus . popleft ( ) <NEWLINE> cou . append ( m1 ) <NEWLINE> cou . append ( m2 ) <NEWLINE> <DEDENT> elif len ( minus ) < 2 : <NEWLINE> <INDENT> p1 = plus . popleft ( ) <NEWLINE> p2 = plus . popleft ( ) <NEWLINE> cou . append ( p1 ) <NEWLINE> cou . append ( p2 ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for i in cou : <NEWLINE> <INDENT> ans *= cou <NEWLINE> ans %= mod <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
def resolve ( ) : <NEWLINE> <INDENT> from bisect import bisect_left <NEWLINE> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> m = bisect_left ( a , 0 ) <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> if m == 0 : <NEWLINE> <INDENT> ans = 1 <NEWLINE> for i in a [ - k : ] : <NEWLINE> <INDENT> ans = ( ans * i ) % MOD <NEWLINE> <DEDENT> <DEDENT> elif m == n : <NEWLINE> <INDENT> ans = 1 <NEWLINE> if k % 2 == 0 : <NEWLINE> <INDENT> for i in a [ : k ] : <NEWLINE> <INDENT> ans = ( ans * i ) % MOD <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for i in a [ - k : ] : <NEWLINE> <INDENT> ans = ( ans * i ) % MOD <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> cal = 1 <NEWLINE> i = ( m // 2 ) * 2 <NEWLINE> for j in a [ : i ] : <NEWLINE> <INDENT> cal = ( cal * j ) % MOD <NEWLINE> <DEDENT> if k - i > 0 : <NEWLINE> <INDENT> for j in a [ - ( k - i ) : ] : <NEWLINE> <INDENT> cal = ( cal * j ) % MOD <NEWLINE> <DEDENT> <DEDENT> ans = cal <NEWLINE> for i in range ( ( m // 2 ) * 2 - 2 , - 2 , - 2 ) : <NEWLINE> <INDENT> if k - i > n - m : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for j in a [ i - 2 : i ] : <NEWLINE> <INDENT> cal = ( cal * pow ( j , MOD - 2 , MOD ) ) % MOD <NEWLINE> <DEDENT> if k - i >= 0 : <NEWLINE> <INDENT> if - ( k - i ) + 2 == 0 : <NEWLINE> <INDENT> for j in a [ - ( k - i ) : ] : <NEWLINE> cal = ( cal * j ) % MOD <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for j in a [ - ( k - i ) : - ( k - i ) + 2 ] : <NEWLINE> <INDENT> cal = ( cal * j ) % MOD <NEWLINE> <DEDENT> <DEDENT> <DEDENT> ans = max ( ans , cal ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> resolve ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> Q = 10 ** 9 + 7 <NEWLINE> def main ( ) : <NEWLINE> <INDENT> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if K == 1 : <NEWLINE> <INDENT> print ( max ( A ) ) <NEWLINE> return <NEWLINE> <DEDENT> positive = 0 <NEWLINE> zero = 0 <NEWLINE> negative = 0 <NEWLINE> for a in A : <NEWLINE> <INDENT> if a > 0 : <NEWLINE> <INDENT> positive += 1 <NEWLINE> <DEDENT> elif a == 0 : <NEWLINE> <INDENT> zero += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> negative += 1 <NEWLINE> <DEDENT> <DEDENT> if positive + negative < K : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> return <NEWLINE> <DEDENT> if positive == 0 : <NEWLINE> <INDENT> if K % 2 == 1 : <NEWLINE> <INDENT> if zero > 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> return <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> A . sort ( reverse = True ) <NEWLINE> ans = 1 <NEWLINE> for a in A [ : K ] : <NEWLINE> <INDENT> ans *= a <NEWLINE> ans %= Q <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> return <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> A . sort ( ) <NEWLINE> ans = 1 <NEWLINE> for a in A [ : K ] : <NEWLINE> <INDENT> ans *= a <NEWLINE> ans %= Q <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> return <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> if negative <= 1 : <NEWLINE> <INDENT> A . sort ( reverse = True ) <NEWLINE> ans = 1 <NEWLINE> for a in A [ : K ] : <NEWLINE> <INDENT> ans *= a <NEWLINE> ans %= Q <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> return <NEWLINE> <DEDENT> if K == negative + positive : <NEWLINE> <INDENT> if negative % 2 == 1 : <NEWLINE> <INDENT> if zero > 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> return <NEWLINE> <DEDENT> <DEDENT> ans = 1 <NEWLINE> for a in A : <NEWLINE> <INDENT> if a != 0 : <NEWLINE> <INDENT> ans *= a <NEWLINE> ans %= Q <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> B = [ ( abs ( a ) , a ) for a in A ] <NEWLINE> B . sort ( reverse = True ) <NEWLINE> minus = False <NEWLINE> minus_value = 0 <NEWLINE> plus_value = 0 <NEWLINE> ans = 1 <NEWLINE> for b in B [ : K ] : <NEWLINE> <INDENT> ans *= b [ 0 ] <NEWLINE> ans %= Q <NEWLINE> if b [ 1 ] < 0 : <NEWLINE> <INDENT> minus = not minus <NEWLINE> minus_value = b [ 0 ] <NEWLINE> <DEDENT> elif b [ 1 ] > 0 : <NEWLINE> <INDENT> plus_value = b [ 0 ] <NEWLINE> <DEDENT> <DEDENT> if minus : <NEWLINE> <INDENT> ans_plus = ans_minus = ans <NEWLINE> plus_replaced_value = 0 <NEWLINE> minus_replaced_value = 0 <NEWLINE> if minus_value > 0 <NEWLINE> <INDENT> for b in B [ K : ] : <NEWLINE> <INDENT> if b [ 1 ] > 0 : <NEWLINE> <INDENT> ans_plus = ans * pow ( minus_value , Q - 2 , Q ) % Q * b [ 0 ] % Q <NEWLINE> plus_replaced_value = plus_value * b [ 0 ] <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if plus_value > 0 <NEWLINE> <INDENT> for b in B [ K : ] : <NEWLINE> <INDENT> if b [ 1 ] < 0 : <NEWLINE> <INDENT> ans_minus = ans * pow ( plus_value , Q - 2 , Q ) % Q * b [ 0 ] % Q <NEWLINE> minus_replaced_value = minus_value * b [ 0 ] <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if plus_replaced_value == 0 and minus_replaced_value == 0 : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> elif plus_replaced_value < minus_replaced_value : <NEWLINE> <INDENT> ans = ans_minus <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = ans_plus <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> p = [ ] <NEWLINE> m = [ ] <NEWLINE> z = 0 <NEWLINE> a . sort ( reverse = True ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if a [ i ] > 0 : <NEWLINE> <INDENT> p . append ( a [ i ] ) <NEWLINE> <DEDENT> elif a [ i ] == 0 : <NEWLINE> <INDENT> z += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> m . append ( a [ i ] ) <NEWLINE> <DEDENT> <DEDENT> nump = len ( p ) <NEWLINE> numm = len ( m ) <NEWLINE> ans = 1 <NEWLINE> if nump + numm < k : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> elif numm < 2 and nump >= k : <NEWLINE> <INDENT> for i in range ( k ) : <NEWLINE> <INDENT> ans *= p [ i ] <NEWLINE> ans %= 10 ** 9 + 7 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <DEDENT> elif 2 * ( numm // 2 ) + nump < k : <COMMENT> <NEWLINE> <INDENT> if z != 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( n ) : <NEWLINE> <INDENT> a [ i ] = abs ( a [ i ] ) <NEWLINE> <DEDENT> a . sort ( ) <NEWLINE> ans = - 1 <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> ans *= a [ i ] <NEWLINE> ans %= 10 ** 9 + 7 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <DEDENT> <DEDENT> elif nump == 0 : <COMMENT> <NEWLINE> <INDENT> if z != 0 and k % 2 == 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> elif z != 0 and numm < k : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if k % 2 == 0 : <NEWLINE> <INDENT> m . sort ( ) <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> ans *= m [ i ] <NEWLINE> ans %= 10 ** 9 + 7 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> m . sort ( reverse = True ) <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> ans *= m [ i ] <NEWLINE> ans %= 10 ** 9 + 7 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if k % 2 == 1 : <NEWLINE> <INDENT> ans *= p [ 0 ] <NEWLINE> p = [ 1 : ] <NEWLINE> <DEDENT> m . sort ( ) <NEWLINE> p . sort ( reverse = True ) <NEWLINE> nump = ( nump - 1 ) // 2 <NEWLINE> numm = numm // 2 <NEWLINE> nump1 = 0 <NEWLINE> nump2 = 0 <NEWLINE> numm1 = 0 <NEWLINE> numm2 = 0 <NEWLINE> for i in range ( k // 2 ) : <NEWLINE> <INDENT> if nump2 == nump : <NEWLINE> <INDENT> nump1 = - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> nump1 = p [ nump2 * 2 ] * p [ nump2 * 2 + 1 ] <NEWLINE> <DEDENT> if numm2 == numm : <NEWLINE> <INDENT> numm1 = - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> numm1 = m [ numm2 * 2 ] * m [ numm2 * 2 + 1 ] <NEWLINE> <DEDENT> if numm1 >= nump1 : <NEWLINE> <INDENT> num = numm1 <NEWLINE> numm2 += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> num = nump1 <NEWLINE> nump2 += 1 <NEWLINE> <DEDENT> ans *= num <NEWLINE> ans %= 10 ** 9 + 7 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> M = 10 ** 9 + 7 <NEWLINE> n , k , * a = map ( int , open ( 0 ) . read ( ) . split ( ) ) <NEWLINE> x , y = [ ] , [ ] <NEWLINE> for i in a : <NEWLINE> <INDENT> if i > 0 : x += i , <NEWLINE> if i < 0 : y += i , <NEWLINE> <DEDENT> if len ( x ) + len ( y ) < k or k % 2 and not x and len ( y ) < n : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> break <NEWLINE> <DEDENT> if k % 2 and not x : <NEWLINE> <INDENT> c = 1 <NEWLINE> for i in sorted ( y ) [ - k : ] : <NEWLINE> <INDENT> c = c * i % M <NEWLINE> <DEDENT> print ( c ) <NEWLINE> break <NEWLINE> <DEDENT> x = sorted ( x ) [ : : - 1 ] [ : k ] <NEWLINE> i = len ( x ) <NEWLINE> y . sort ( ) <NEWLINE> m = len ( y ) <NEWLINE> j = k - i <NEWLINE> if j % 2 : <NEWLINE> <INDENT> x = x [ : - 1 ] <NEWLINE> i -= 1 <NEWLINE> j += 1 <NEWLINE> <DEDENT> x += y [ : j ] <NEWLINE> if len ( x ) != k : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> break <NEWLINE> <DEDENT> while i > 1 and j + 1 < m and x [ i - 1 ] * x [ i - 2 ] < y [ j ] * y [ j + 1 ] : <NEWLINE> <INDENT> x [ i - 1 ] , x [ i - 2 ] = y [ j ] , y [ j + 1 ] <NEWLINE> i -= 2 <NEWLINE> j += 2 <NEWLINE> <DEDENT> c = 1 <NEWLINE> for i in x : <NEWLINE> <INDENT> c = c * i % M <NEWLINE> <DEDENT> print ( c ) <NEWLINE> <DEDENT> main ( ) <NEWLINE>
mod = 10 ** 9 + 7 <NEWLINE> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> A = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> p = 1 <NEWLINE> m = 0 <NEWLINE> ans = 1 <NEWLINE> cnt = 0 <NEWLINE> <NL> while cnt < K - 1 : <NEWLINE> <INDENT> if A [ m ] * A [ m + 1 ] > A [ - p ] * A [ - p - 1 ] : <NEWLINE> <INDENT> ans *= A [ ni ] * A [ n + 1 ] % mod <NEWLINE> m += 2 <NEWLINE> cnt += 2 <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> ans *= A [ - p ] % mod <NEWLINE> p += 1 <NEWLINE> cnt += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if cnt == k - 1 : <NEWLINE> <INDENT> ans *= A [ - p ] % mod <NEWLINE> <NL> <DEDENT> if A [ - 1 ] < 0 and K % 2 == 1 : <NEWLINE> <INDENT> ans = 1 <NEWLINE> for i in A [ N - K : ] : <NEWLINE> <INDENT> ans *= i % mod <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
MOD = 10 ** 9 + 7 <NEWLINE> def main ( ) : <NEWLINE> <INDENT> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if max ( A ) < 0 and K % 2 == 1 : <NEWLINE> <INDENT> A . sort ( reverse = True ) <NEWLINE> ans = 1 <NEWLINE> for i in range ( K ) : <NEWLINE> <INDENT> ans = ans * A [ i ] % MOD <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <DEDENT> elif K == N : <NEWLINE> <INDENT> ans = 1 <NEWLINE> for i in A : <NEWLINE> <INDENT> ans = ans * i % MOD <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> A_p = [ ] <NEWLINE> A_m = [ ] <NEWLINE> for i in A : <NEWLINE> <INDENT> if i >= 0 : A_p . append ( i ) <NEWLINE> else : A_m . append ( i ) <NEWLINE> <DEDENT> A_p . sort ( reverse = True ) <NEWLINE> A_m . sort ( ) <NEWLINE> num = 0 <NEWLINE> ans = 1 <NEWLINE> posi_p = 0 <NEWLINE> posi_m = 0 <NEWLINE> sign = 0 <NEWLINE> while ( num < K ) : <NEWLINE> <INDENT> if posi_m == len ( A_m ) and posi_p < len ( A_p ) : <NEWLINE> <INDENT> ans = ans * A_p [ posi_p ] % MOD <NEWLINE> posi_p += 1 <NEWLINE> num += 1 <NEWLINE> <DEDENT> elif posi_p = len ( A_p ) and posi_m < len ( A_M ) : <NEWLINE> <INDENT> ans = ans * A_m [ posi_m ] % MOD <NEWLINE> sign += 1 <NEWLINE> posi_m += 1 <NEWLINE> num += 1 <NEWLINE> <DEDENT> elif A_p [ posi_p ] >= abs ( A_m [ posi_m ] ) : <NEWLINE> <INDENT> ans = ans * A_p [ posi_p ] % MOD <NEWLINE> posi_p += 1 <NEWLINE> num += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = ans * A_m [ posi_m ] % MOD <NEWLINE> sign += 1 <NEWLINE> posi_m += 1 <NEWLINE> num += 1 <NEWLINE> <DEDENT> if num == K and sign % 2 == 1 : <NEWLINE> <INDENT> if posi_m == len ( A_m ) : <NEWLINE> <INDENT> ans = ans * pow ( A_m [ posi_m - 1 ] , MOD - 2 , MOD ) % MOD <NEWLINE> ans = ans * A_p [ posi_p ] % MOD <NEWLINE> <DEDENT> elif posi_p == len ( A_p ) : <NEWLINE> <INDENT> ans = ans * pow ( A_p [ posi_p - 1 ] , MOD - 2 , MOD ) <NEWLINE> ans = ans * A_m [ posi_m ] % MOD <NEWLINE> <DEDENT> elif A_p [ posi_p ] * A_p [ posi_p - 1 ] >= A_m [ posi_m ] * A [ posi_m - 1 ] : <NEWLINE> <INDENT> ans = ans * pow ( A_m [ posi_m - 1 ] , MOD - 2 , MOD ) % MOD <NEWLINE> ans = ans * A_p [ posi_p ] % MOD <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = ans * pow ( A_p [ posi_p - 1 ] , MOD - 2 , MOD ) % MOD <NEWLINE> ans = ans * A_m [ posi_m ] % MOD <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans % MOD ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> MOD = 10 ** 9 + 7 <NEWLINE> <NL> def read_int ( ) : <NEWLINE> <INDENT> line = sys . stdin . readline ( ) . rstrip ( <STRING> ) <NEWLINE> return int ( line ) <NEWLINE> <NL> <DEDENT> def read_int_list ( ) : <NEWLINE> <INDENT> line = sys . stdin . readline ( ) . rstrip ( <STRING> ) <NEWLINE> return [ int ( e ) for e in line . split ( <STRING> ) ] <NEWLINE> <NL> <DEDENT> def sign ( n ) : <NEWLINE> <INDENT> if n > 0 : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> if n < 0 : <NEWLINE> <INDENT> return - 1 <NEWLINE> <DEDENT> return 0 <NEWLINE> <NL> <DEDENT> def prod ( A , K , add , remove ) : <NEWLINE> <INDENT> prod = 1 <NEWLINE> for i in range ( K ) : <NEWLINE> <INDENT> if i == remove : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> prod *= abs ( A [ i ] ) <NEWLINE> prod %= MOD <NEWLINE> <DEDENT> if add != None : <NEWLINE> <INDENT> prod *= abs ( A [ add ] ) <NEWLINE> prod %= MOD <NEWLINE> <DEDENT> return prod <NEWLINE> <NL> <DEDENT> N , K = read_int_list ( ) <NEWLINE> A = read_int_list ( ) <NEWLINE> <NL> A . sort ( key = lambda i : - abs ( i ) ) <NEWLINE> <NL> last_plus = None <NEWLINE> last_minus = None <NEWLINE> sig = 1 <NEWLINE> for i in range ( K ) : <NEWLINE> <INDENT> sig *= sign ( A [ i ] ) <NEWLINE> if A [ i ] > 0 : <NEWLINE> <INDENT> last_plus = i <NEWLINE> <DEDENT> if A [ i ] < 0 : <NEWLINE> <INDENT> last_minus = i <NEWLINE> <DEDENT> <DEDENT> remove_plus = None <NEWLINE> add_plus = None <NEWLINE> remove_minus = None <NEWLINE> add_minus = None <NEWLINE> if sig < 0 : <NEWLINE> <INDENT> for i in range ( K , N ) : <NEWLINE> <INDENT> if A [ i ] > 0 and last_minus != None and remove_minus == None : <NEWLINE> <INDENT> remove_minus = last_minus <NEWLINE> add_minus = i <NEWLINE> sig = 1 <NEWLINE> <DEDENT> elif A [ i ] < 0 and last_plus != None and remove_plus == None : <NEWLINE> <INDENT> remove_plus = last_plus <NEWLINE> add_plus = i <NEWLINE> sig = 1 <NEWLINE> <DEDENT> elif A [ i ] == 0 : <NEWLINE> <INDENT> sig = 0 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if sig == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> elif sig > 0 : <NEWLINE> <INDENT> if remove_plus != None and remove_minus != None : <NEWLINE> <INDENT> if abs ( A [ remove_plus ] / A [ add_plus ] ) > abs ( A [ remove_minus ] / A [ add_minus ] ) : <NEWLINE> <INDENT> ap = prod ( A , K , add_minus , remove_minus ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ap = prod ( A , K , add_plus , remove_plus ) <NEWLINE> <DEDENT> <DEDENT> elif remove_plus != None : <NEWLINE> <INDENT> ap = prod ( A , K , add_plus , remove_plus ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ap = prod ( A , K , add_minus , remove_minus ) <NEWLINE> <DEDENT> print ( ap ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ap = prod ( A [ : : - 1 ] , K , None , None ) <NEWLINE> print ( ( MOD - ap ) % MOD ) <NEWLINE> <DEDENT> import sys <NEWLINE> <NL> MOD = 10 ** 9 + 7 <NEWLINE> <NL> def read_int ( ) : <NEWLINE> <INDENT> line = sys . stdin . readline ( ) . rstrip ( <STRING> ) <NEWLINE> return int ( line ) <NEWLINE> <NL> <DEDENT> def read_int_list ( ) : <NEWLINE> <INDENT> line = sys . stdin . readline ( ) . rstrip ( <STRING> ) <NEWLINE> return [ int ( e ) for e in line . split ( <STRING> ) ] <NEWLINE> <NL> <DEDENT> def sign ( n ) : <NEWLINE> <INDENT> if n > 0 : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> if n < 0 : <NEWLINE> <INDENT> return - 1 <NEWLINE> <DEDENT> return 0 <NEWLINE> <NL> <DEDENT> def prod ( A , K , add , remove ) : <NEWLINE> <INDENT> prod = 1 <NEWLINE> for i in range ( K ) : <NEWLINE> <INDENT> if i == remove : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> prod *= abs ( A [ i ] ) <NEWLINE> prod %= MOD <NEWLINE> <DEDENT> if add != None : <NEWLINE> <INDENT> prod *= abs ( A [ add ] ) <NEWLINE> prod %= MOD <NEWLINE> <DEDENT> return prod <NEWLINE> <NL> <DEDENT> N , K = read_int_list ( ) <NEWLINE> A = read_int_list ( ) <NEWLINE> <NL> A . sort ( key = lambda i : - abs ( i ) ) <NEWLINE> <NL> last_plus = None <NEWLINE> last_minus = None <NEWLINE> sig = 1 <NEWLINE> for i in range ( K ) : <NEWLINE> <INDENT> sig *= sign ( A [ i ] ) <NEWLINE> if A [ i ] > 0 : <NEWLINE> <INDENT> last_plus = i <NEWLINE> <DEDENT> if A [ i ] < 0 : <NEWLINE> <INDENT> last_minus = i <NEWLINE> <DEDENT> <DEDENT> remove_plus = None <NEWLINE> add_plus = None <NEWLINE> remove_minus = None <NEWLINE> add_minus = None <NEWLINE> if sig < 0 : <NEWLINE> <INDENT> for i in range ( K , N ) : <NEWLINE> <INDENT> if A [ i ] > 0 and last_minus != None and remove_minus == None : <NEWLINE> <INDENT> remove_minus = last_minus <NEWLINE> add_minus = i <NEWLINE> sig = 1 <NEWLINE> <DEDENT> elif A [ i ] < 0 and last_plus != None and remove_plus == None : <NEWLINE> <INDENT> remove_plus = last_plus <NEWLINE> add_plus = i <NEWLINE> sig = 1 <NEWLINE> <DEDENT> elif A [ i ] == 0 : <NEWLINE> <NL> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if sig == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> elif sig > 0 : <NEWLINE> <INDENT> if remove_plus != None and remove_minus != None : <NEWLINE> <INDENT> if abs ( A [ remove_plus ] / A [ add_plus ] ) > abs ( A [ remove_minus ] / A [ add_minus ] ) : <NEWLINE> <INDENT> ap = prod ( A , K , add_minus , remove_minus ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ap = prod ( A , K , add_plus , remove_plus ) <NEWLINE> <DEDENT> <DEDENT> elif remove_plus != None : <NEWLINE> <INDENT> ap = prod ( A , K , add_plus , remove_plus ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ap = prod ( A , K , add_minus , remove_minus ) <NEWLINE> <DEDENT> print ( ap ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ap = prod ( A [ : : - 1 ] , K , None , None ) <NEWLINE> print ( ( MOD - ap ) % MOD ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> mod = 10 ** 9 + 7 <NEWLINE> <NL> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if N == K : <NEWLINE> <INDENT> ans = 1 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> ans *= A [ i ] <NEWLINE> ans %= mod <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> plus = [ ] <NEWLINE> minus = [ ] <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> if A [ i ] < 0 : <NEWLINE> <INDENT> minus . append ( A [ i ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> plus . append ( A [ i ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> if len ( minus ) == N : <NEWLINE> <INDENT> minus = minus . sort ( reverse = True ) <NEWLINE> ans = 1 <NEWLINE> for i in range ( K ) : <NEWLINE> <INDENT> ans *= A [ i ] <NEWLINE> ans %= mod <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> plus = plus . sort ( reverse = True ) <NEWLINE> minus = minus . sort ( ) <NEWLINE> <NL> ans = 1 <NEWLINE> flag = 0 <NEWLINE> if K % 2 == 1 : <NEWLINE> <INDENT> flag = 1 <NEWLINE> K -= 1 <NEWLINE> ans *= plus [ 0 ] <NEWLINE> <NL> <DEDENT> n_plus = [ ( plus [ i + flag ] * plus [ i + flag + 1 ] ) % mod for i in range ( ( len ( plus ) - flag ) // 2 ) ] <NEWLINE> n_minus = [ ( minus [ i ] * minus [ i + 1 ] ) % mod for i in range ( len ( minus ) // 2 ) ] <NEWLINE> <NL> p = 0 <NEWLINE> m = 0 <NEWLINE> for i in range ( K // 2 ) : <NEWLINE> <INDENT> if p == len ( n_plus ) : <NEWLINE> <INDENT> ans *= n_minus [ m ] <NEWLINE> ans %= mod <NEWLINE> m += 1 <NEWLINE> <DEDENT> elif m == len ( n_minus ) : <NEWLINE> <INDENT> ans *= n_plus [ p ] <NEWLINE> ans %= mod <NEWLINE> p += 1 <NEWLINE> <DEDENT> elif n_plus [ p ] > n_minus [ m ] : <NEWLINE> <INDENT> ans *= n_plus [ p ] <NEWLINE> ans %= mod <NEWLINE> p += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans *= n_minus [ m ] <NEWLINE> ans %= mod <NEWLINE> m += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> A1 = [ ] <NEWLINE> A2 = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if A [ i ] > 0 : <NEWLINE> <INDENT> A1 . append ( A [ i ] ) <NEWLINE> <DEDENT> if A [ i ] < 0 : <NEWLINE> <INDENT> A2 . append ( - A [ i ] ) <NEWLINE> <DEDENT> <DEDENT> A1 . sort ( reverse = True ) <NEWLINE> A2 . sort ( reverse = True ) <NEWLINE> ans = 1 <NEWLINE> if max ( A ) < 0 : <NEWLINE> <INDENT> if K % 2 == 0 : <NEWLINE> <INDENT> for i in range ( K ) : <NEWLINE> <INDENT> ans = ( ans * A2 [ i ] ) % mod <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> A2 . sort ( ) <NEWLINE> for i in range ( K ) : <NEWLINE> <INDENT> ans = ( ans * A2 [ i ] ) % mod <NEWLINE> ans = ( mod - ans ) % mod <NEWLINE> <DEDENT> <DEDENT> <DEDENT> elif max ( A ) == 0 : <NEWLINE> <INDENT> if K % 2 == 1 : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if len ( A2 ) >= K : <NEWLINE> <INDENT> for i in range ( K ) : <NEWLINE> <INDENT> ans = ( ans * A2 [ i ] ) % mod <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> A3 = [ ] <NEWLINE> for i in range ( len ( A2 ) // 2 ) : <NEWLINE> <INDENT> A3 . append ( A2 [ 2 * i ] * A2 [ 2 * i + 1 ] ) <NEWLINE> <DEDENT> A4 = [ ] <NEWLINE> A5 = [ ] <NEWLINE> for i in range ( len ( A1 ) // 2 ) : <NEWLINE> <INDENT> A4 . append ( A1 [ 2 * i ] * A1 [ 2 * i + 1 ] ) <NEWLINE> <DEDENT> for i in range ( ( len ( A1 ) - 1 ) // 2 ) : <NEWLINE> <INDENT> A5 . append ( A1 [ 2 * i + 1 ] * A1 [ 2 * i + 2 ] ) <NEWLINE> <DEDENT> if len ( A1 ) + 2 * len ( A3 ) < K : <NEWLINE> <INDENT> if N == K : <NEWLINE> <INDENT> for i in range ( N ) : <NEWLINE> <INDENT> ans = ( ans * A [ i ] ) % mod <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if K % 2 == 0 : <NEWLINE> <INDENT> A6 = A3 + A4 <NEWLINE> A6 . sort ( reverse = True ) <NEWLINE> for i in range ( K // 2 ) : <NEWLINE> <INDENT> ans = ( ans * A6 [ i ] ) % mod <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> A6 = A3 + A5 <NEWLINE> A6 . sort ( reverse = True ) <NEWLINE> ans = A1 [ 0 ] <NEWLINE> for i in range ( ( K - 1 ) // 2 ) : <NEWLINE> <INDENT> ans = ( ans * A6 [ i ] ) % mod <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
with open ( <STRING> ) as f : <NEWLINE> <INDENT> n , k = map ( int , f . readline ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , f . readline ( ) . split ( ) ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> mod = 10 ** 9 + 7 <NEWLINE> print ( n , k ) <NEWLINE> <NL> mia , pla = [ ] , [ ] <NEWLINE> for ai in a : <NEWLINE> <INDENT> if ai < 0 : <NEWLINE> <INDENT> mia . append ( ai ) <NEWLINE> <DEDENT> elif ai >= 0 : <NEWLINE> <INDENT> pla . append ( ai ) <NEWLINE> <DEDENT> <DEDENT> mia . sort ( reverse = True ) <NEWLINE> pla . sort ( ) <NEWLINE> <NL> cnt = 1 <NEWLINE> if len ( pla ) == 0 and k % 2 == 1 : <NEWLINE> <INDENT> for i in mia [ : k ] : <NEWLINE> <INDENT> cnt = cnt * i % mod <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> while k > 0 : <NEWLINE> <INDENT> if k == 1 or len ( mia ) <= 1 : <NEWLINE> <INDENT> if len ( pla ) == 0 : <NEWLINE> <INDENT> cnt = cnt * mia . pop ( ) % mod <NEWLINE> <DEDENT> elif len ( pla ) > 0 : <NEWLINE> <INDENT> cnt = cnt * pla . pop ( ) % mod <NEWLINE> <DEDENT> k -= 1 <NEWLINE> <DEDENT> elif len ( pla ) <= 1 : <NEWLINE> <INDENT> if k == 1 : <NEWLINE> <INDENT> cnt = cnt * pla . pop ( ) % mod <NEWLINE> k -= 1 <NEWLINE> <DEDENT> elif k > 1 : <NEWLINE> <INDENT> cnt = cnt * mia . pop ( ) * mia . pop ( ) % mod <NEWLINE> k -= 2 <NEWLINE> <DEDENT> <DEDENT> elif len ( pla ) >= 2 and len ( mia ) >= 2 : <NEWLINE> <INDENT> if pla [ - 1 ] * pla [ - 2 ] > mia [ - 1 ] * mia [ - 2 ] : <NEWLINE> <INDENT> cnt = cnt * pla . pop ( ) % mod <NEWLINE> k -= 1 <NEWLINE> <DEDENT> elif pla [ - 1 ] * pla [ - 2 ] <= mia [ - 1 ] * mia [ - 2 ] : <NEWLINE> <INDENT> cnt = cnt * mia . pop ( ) * mia . pop ( ) % mod <NEWLINE> k -= 2 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
mod = 10 ** 9 + 7 <NEWLINE> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> p = 1 <NEWLINE> n = 0 <NEWLINE> ans = 1 <NEWLINE> cnt = 0 <NEWLINE> while cnt < K - 1 : <NEWLINE> <INDENT> if A [ n ] * A [ n + 1 ] > A [ - p ] * A [ - p - 1 ] : <NEWLINE> <INDENT> ans = ans * A [ n ] * A [ n + 1 ] % mod <NEWLINE> n += 2 <NEWLINE> cnt += 2 <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> ans = ans * A [ - p ] % mod <NEWLINE> p += 1 <NEWLINE> cnt += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if i == K - 1 : <NEWLINE> <INDENT> ans = ans * A [ - p ] % mod <NEWLINE> <NL> <DEDENT> if A [ - 1 ] < 0 and K % 2 == 1 : <NEWLINE> <INDENT> ans = 1 <NEWLINE> for i in A [ N - K : ] : <NEWLINE> <INDENT> ans = ans * cnt % mod <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
plus = [ ] <NEWLINE> minus = [ ] <NEWLINE> zero = 0 <NEWLINE> ans = 1 <NEWLINE> <NL> for i in a : <NEWLINE> <INDENT> if i > 0 : <NEWLINE> <INDENT> plus . append ( i ) <NEWLINE> <DEDENT> elif i < 0 : <NEWLINE> <INDENT> minus . append ( - i ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> zero += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> plus . sort ( ) <NEWLINE> minus . sort ( ) <NEWLINE> p_l = len ( plus ) <NEWLINE> m_l = len ( minus ) <NEWLINE> cnt = 0 <NEWLINE> <NL> if k == 1 : <NEWLINE> <INDENT> print ( max ( a ) ) <NEWLINE> <DEDENT> elif zero > n - k : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> elif zero == n - k : <NEWLINE> <INDENT> for i in plus : <NEWLINE> <INDENT> ans = ( i * ans ) % num <NEWLINE> <DEDENT> for j in minus : <NEWLINE> <INDENT> ans = ( ans * j ) % num <NEWLINE> <DEDENT> if m_l % 2 == 0 : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - ans % num ) <NEWLINE> <DEDENT> <DEDENT> elif len ( plus ) == 0 : <NEWLINE> <INDENT> if k % 2 == 0 : <NEWLINE> <INDENT> for j in range ( k ) : <NEWLINE> <INDENT> ans = ans * ( minus [ - ( j + 1 ) ] ) % num <NEWLINE> <DEDENT> print ( ans % num ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for j in range ( k ) : <NEWLINE> <INDENT> ans = ans * ( minus [ j ] ) % num <NEWLINE> <DEDENT> print ( - ans % num ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( k ) : <NEWLINE> <INDENT> if p_l > 1 and m_l > 1 : <NEWLINE> <INDENT> if plus [ - 1 ] >= minus [ - 1 ] : <NEWLINE> <INDENT> ans = ans * plus . pop ( ) % num <NEWLINE> p_l -= 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = ans * minus . pop ( ) % num <NEWLINE> cnt += 1 <NEWLINE> m_l -= 1 <NEWLINE> <DEDENT> <DEDENT> elif m_l == 1 : <NEWLINE> <INDENT> if cnt % 2 == 1 : <NEWLINE> <INDENT> ans = ans * minus . pop ( ) % num <NEWLINE> m_l -= 1 <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = ans * plus . pop ( ) % num <NEWLINE> p_l -= 1 <NEWLINE> <DEDENT> <DEDENT> elif p_l == 1 : <NEWLINE> <INDENT> if k - i - 1 % 2 == 0 : <NEWLINE> <INDENT> ans = ans * plus . pop ( ) % num <NEWLINE> p_l -= 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = ans * minus . pop ( ) % num <NEWLINE> cnt += 1 <NEWLINE> m_l -= 1 <NEWLINE> <DEDENT> <DEDENT> elif p_l == 0 : <NEWLINE> <INDENT> ans = ans * minus . pop ( ) % num <NEWLINE> m_l -= 1 <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> elif m_l == 0 : <NEWLINE> <INDENT> ans = ans * plus . pop ( ) % num <NEWLINE> p_l -= 1 <NEWLINE> <DEDENT> <DEDENT> if cnt % 2 == 0 : <NEWLINE> <INDENT> print ( ans % num ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - ans % num ) <NEWLINE> <DEDENT> <DEDENT>
MOD = 10 ** 9 + 7 <NEWLINE> <NL> n , k = [ int ( _ ) for _ in input ( ) . split ( ) ] <NEWLINE> <NL> a = [ int ( _ ) for _ in input ( ) . split ( ) ] <NEWLINE> <NL> m = list ( filter ( lambda x : x < 0 , a ) ) <NEWLINE> p = list ( filter ( lambda x : x > 0 , a ) ) <NEWLINE> <NL> m . sort ( ) <NEWLINE> p . sort ( reverse = True ) <NEWLINE> <NL> <NL> if len ( p ) + len ( m ) < k : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> if len ( p ) + len ( m ) == k : <NEWLINE> <INDENT> ans = 1 <NEWLINE> for p_ in p : <NEWLINE> <INDENT> ans = ( ans * p_ ) % MOD <NEWLINE> <DEDENT> for q_ in m : <NEWLINE> <INDENT> ans = ( ans * q_ ) % MOD <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> if len ( p ) == 0 and k % 2 == 1 : <NEWLINE> <INDENT> ans = 1 <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> ans = ( ans * m [ - i - 1 ] ) % MOD <NEWLINE> <DEDENT> if 0 in a : <NEWLINE> <INDENT> ans *= 0 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> i , j = 0 , 0 <NEWLINE> if k % 2 == 1 : <NEWLINE> <INDENT> d = p . pop ( - 1 ) <NEWLINE> <DEDENT> m . append ( 0 ) <NEWLINE> m . append ( 0 ) <NEWLINE> p . append ( 0 ) <NEWLINE> p . append ( 0 ) <NEWLINE> <COMMENT> <NL> ans = 1 <NEWLINE> for c in range ( k // 2 ) : <NEWLINE> <COMMENT> <NL> <INDENT> if m [ i ] * m [ i + 1 ] >= p [ j ] * p [ j + 1 ] : <NEWLINE> <INDENT> ans = ( ans * m [ i ] * m [ i + 1 ] ) % MOD <NEWLINE> i += 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = ( ans * p [ j ] * p [ j + 1 ] ) % MOD <NEWLINE> j += 2 <NEWLINE> <NL> <DEDENT> <DEDENT> if k % 2 == 1 : <NEWLINE> <INDENT> ans = ( ans * max ( p [ j ] , d ) ) % MOD <NEWLINE> <NL> <NL> <DEDENT> if ans > MOD : <NEWLINE> <INDENT> ans -= MOD <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> <NL> n , k = [ int ( _ ) for _ in input ( ) . split ( ) ] <NEWLINE> <NL> a = [ int ( _ ) for _ in input ( ) . split ( ) ] <NEWLINE> <NL> m = list ( filter ( lambda x : x < 0 , a ) ) <NEWLINE> p = list ( filter ( lambda x : x > 0 , a ) ) <NEWLINE> <NL> m . sort ( ) <NEWLINE> p . sort ( reverse = True ) <NEWLINE> <NL> <NL> if len ( p ) + len ( m ) < k : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> if len ( p ) + len ( m ) == k : <NEWLINE> <INDENT> ans = 1 <NEWLINE> for p_ in p : <NEWLINE> <INDENT> ans = ( ans * p_ ) % MOD <NEWLINE> <DEDENT> for q_ in m : <NEWLINE> <INDENT> ans = ( ans * q_ ) % MOD <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> if len ( p ) == 0 and k % 2 == 1 : <NEWLINE> <INDENT> ans = 1 <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> ans = ( ans * m [ - i - 1 ] ) % MOD <NEWLINE> <DEDENT> if 0 in a : <NEWLINE> <INDENT> ans *= 0 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> i , j = 0 , 0 <NEWLINE> if k % 2 == 1 : <NEWLINE> <INDENT> d = p . pop ( - 1 ) <NEWLINE> <DEDENT> m . append ( 0 ) <NEWLINE> m . append ( 0 ) <NEWLINE> p . append ( 0 ) <NEWLINE> p . append ( 0 ) <NEWLINE> <COMMENT> <NL> ans = 1 <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> <NL> n , k = [ int ( _ ) for _ in input ( ) . split ( ) ] <NEWLINE> <NL> a = [ int ( _ ) for _ in input ( ) . split ( ) ] <NEWLINE> <NL> m = list ( filter ( lambda x : x < 0 , a ) ) <NEWLINE> p = list ( filter ( lambda x : x > 0 , a ) ) <NEWLINE> <NL> m . sort ( ) <NEWLINE> p . sort ( reverse = True ) <NEWLINE> <NL> <NL> if len ( p ) + len ( m ) < k : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> if len ( p ) + len ( m ) == k : <NEWLINE> <INDENT> ans = 1 <NEWLINE> for p_ in p : <NEWLINE> <INDENT> ans = ( ans * p_ ) % MOD <NEWLINE> <DEDENT> for q_ in m : <NEWLINE> <INDENT> ans = ( ans * q_ ) % MOD <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> if len ( p ) == 0 and k % 2 == 1 : <NEWLINE> <INDENT> ans = 1 <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> ans = ( ans * m [ - i - 1 ] ) % MOD <NEWLINE> <DEDENT> if 0 in a : <NEWLINE> <INDENT> ans *= 0 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> i , j = 0 , 0 <NEWLINE> if k % 2 == 1 : <NEWLINE> <INDENT> d = p . pop ( - 1 ) <NEWLINE> <DEDENT> m . append ( 0 ) <NEWLINE> m . append ( 0 ) <NEWLINE> p . append ( 0 ) <NEWLINE> p . append ( 0 ) <NEWLINE> <COMMENT> <NL> ans = 1 <NEWLINE> for c in range ( k // 2 ) : <NEWLINE> <COMMENT> <NL> <INDENT> if m [ i ] * m [ i + 1 ] >= p [ j ] * p [ j + 1 ] : <NEWLINE> <INDENT> ans = ( ans * m [ i ] * m [ i + 1 ] ) % MOD <NEWLINE> i += 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = ( ans * p [ j ] * p [ j + 1 ] ) % MOD <NEWLINE> j += 2 <NEWLINE> <NL> <DEDENT> <DEDENT> if k % 2 == 1 : <NEWLINE> <INDENT> ans = ( ans * max ( p [ j ] , d ) ) % MOD <NEWLINE> <NL> <NL> <DEDENT> if ans > MOD : <NEWLINE> <INDENT> ans -= MOD <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> for c in range ( k // 2 ) : <NEWLINE> <COMMENT> <NL> <INDENT> if m [ i ] * m [ i + 1 ] >= p [ j ] * p [ j + 1 ] : <NEWLINE> <INDENT> ans = ( ans * m [ i ] * m [ i + 1 ] ) % MOD <NEWLINE> i += 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = ( ans * p [ j ] * p [ j + 1 ] ) % MOD <NEWLINE> j += 2 <NEWLINE> <NL> <DEDENT> <DEDENT> if k % 2 == 1 : <NEWLINE> <INDENT> ans = ( ans * max ( p [ j ] , d ) ) % MOD <NEWLINE> <NL> <NL> <DEDENT> if ans > MOD : <NEWLINE> <INDENT> ans -= MOD <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> import sys <NEWLINE> def input ( ) : return sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> ans = 1 <NEWLINE> <NL> def answer ( a ) : <NEWLINE> <INDENT> ans = 1 <NEWLINE> for x in a : <NEWLINE> <INDENT> ans *= x <NEWLINE> ans %= mod <NEWLINE> <DEDENT> return ans <NEWLINE> <NL> <DEDENT> if n == k : <NEWLINE> <INDENT> print ( answer ( a ) ) <NEWLINE> return <NEWLINE> <DEDENT> a . sort ( reverse = True , key = lambda x : abs ( x ) ) <NEWLINE> if sum ( x < 0 for x in a [ : k ] ) % 2 == 0 : <NEWLINE> <INDENT> print ( answer ( a [ : k ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if all ( x < 0 for x in a ) : <NEWLINE> <INDENT> print ( answer ( a [ - k : ] ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> x1 , y1 = min ( [ x for x in a [ : k ] if x > 0 ] ) , min ( [ x for x in a [ k : ] if x < 0 ] ) <NEWLINE> <DEDENT> except ValueError : <NEWLINE> <INDENT> x1 , y1 = 1 , 0 <NEWLINE> <DEDENT> try : <NEWLINE> <INDENT> x2 , y2 = max ( [ x for x in a [ : k ] if x < 0 ] ) , max ( [ x for x in a [ k : ] if x >= 0 ] ) <NEWLINE> <DEDENT> except ValueError : <NEWLINE> <INDENT> x2 , y2 = 1 , 0 <NEWLINE> <DEDENT> if abs ( x2 * y1 ) > abs ( x1 * y2 ) : <NEWLINE> <INDENT> a [ a . index ( x1 ) ] = y1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a [ a . index ( x2 ) ] = y2 <NEWLINE> <DEDENT> print ( answer ( a [ : k ] ) ) <NEWLINE> <NL> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> mod = 1000000007 <NEWLINE> <NL> zeros = [ ] <NEWLINE> pluss = [ ] <NEWLINE> minuss = [ ] <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> if A [ i ] > 0 : <NEWLINE> <INDENT> pluss . append ( A [ i ] ) <NEWLINE> <DEDENT> elif A [ i ] == 0 : <NEWLINE> <INDENT> zeros . append ( A [ i ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> minuss . append ( A [ i ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> pluss = sorted ( pluss , reverse = True ) <NEWLINE> minuss = sorted ( minuss ) <NEWLINE> <NL> if len ( pluss ) + ( min ( len ( minuss ) , K ) // 2 ) * 2 >= K : <NEWLINE> <INDENT> answer_type = 1 <NEWLINE> <DEDENT> elif len ( zeros ) > 0 : <NEWLINE> <INDENT> answer_type = 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> answer_type = 3 <NEWLINE> <NL> <NL> <DEDENT> rest = K <NEWLINE> if answer_type == 1 : <NEWLINE> <INDENT> plus_now = 0 <NEWLINE> minus_now = 0 <NEWLINE> minus_counter = 0 <NEWLINE> answer = 1 <NEWLINE> for i in range ( K ) : <NEWLINE> <INDENT> if plus_now < len ( pluss ) : <NEWLINE> <INDENT> plus_target = pluss [ plus_now ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> plus_target = - 1000000000000 <NEWLINE> <NL> <DEDENT> if minus_now < len ( minuss ) : <NEWLINE> <INDENT> minus_target = - minuss [ minus_now ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> minus_target = - 1000000000000 <NEWLINE> <NL> <DEDENT> if plus_target >= minus_target : <NEWLINE> <INDENT> answer = ( answer * plus_target ) % mod <NEWLINE> plus_now += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> answer = ( answer * minus_target ) % mod <NEWLINE> minus_now += 1 <NEWLINE> minus_counter += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if minus_counter % 2 == 1 : <NEWLINE> <INDENT> <STRING> <NEWLINE> if minus_now >= len ( minuss ) or plus_now == 0 : <NEWLINE> <INDENT> answer = answer * pow ( - minuss [ minus_now - 1 ] , mod - 2 , mod ) <NEWLINE> answer = ( answer * pluss [ plus_now ] ) % mod <NEWLINE> <DEDENT> elif plus_now >= len ( pluss ) or minus_now == 0 : <NEWLINE> <INDENT> answer = answer * pow ( pluss [ plus_now - 1 ] , mod - 2 , mod ) <NEWLINE> answer = ( answer * - minuss [ minus_now ] ) % mod <NEWLINE> <DEDENT> <STRING> <NEWLINE> elif pluss [ plus_now ] * pluss [ plus_now - 1 ] > - minuss [ minus_now ] * ( - minuss [ minus_now - 1 ] ) : <NEWLINE> <INDENT> answer = answer * pow ( - minuss [ minus_now - 1 ] , mod - 2 , mod ) <NEWLINE> answer = ( answer * pluss [ plus_now ] ) % mod <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> answer = answer * pow ( pluss [ plus_now - 1 ] , mod - 2 , mod ) <NEWLINE> answer = ( answer * - minuss [ minus_now ] ) % mod <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> elif answer_type == 2 : <NEWLINE> <INDENT> answer = 0 <NEWLINE> <DEDENT> elif answer_type == 3 : <NEWLINE> <INDENT> minuss = sorted ( minuss , reverse = True ) <NEWLINE> pluss = sorted ( pluss ) <NEWLINE> plus_now = 0 <NEWLINE> minus_now = 0 <NEWLINE> answer = 1 <NEWLINE> for i in range ( K ) : <NEWLINE> <INDENT> if plus_now < len ( pluss ) : <NEWLINE> <INDENT> plus_target = pluss [ plus_now ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> plus_target = 10000000000000 <NEWLINE> <NL> <DEDENT> if minus_now < len ( minuss ) : <NEWLINE> <INDENT> minus_target = - minuss [ minus_now ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> minus_target = 10000000000000 <NEWLINE> <NL> <DEDENT> if plus_target <= minus_target : <NEWLINE> <INDENT> answer = ( answer * plus_target ) % mod <NEWLINE> plus_now += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> answer = ( answer * minus_target ) % mod <NEWLINE> minus_now += 1 <NEWLINE> <DEDENT> <DEDENT> answer = answer * - 1 <NEWLINE> <DEDENT> print ( answer % mod ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> A_neg = [ ] <NEWLINE> A_pos = [ ] <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> if A [ i ] <= 0 : <NEWLINE> <INDENT> A_neg . append ( - A [ i ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> A_pos . append ( A [ i ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> A_neg . sort ( reverse = True ) <NEWLINE> A_pos . sort ( reverse = True ) <NEWLINE> <NL> ans = 1 <NEWLINE> <NL> if K == N : <NEWLINE> <INDENT> for i in range ( N ) : <NEWLINE> <INDENT> ans *= ( A [ i ] % 1000000007 ) <NEWLINE> ans %= 1000000007 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> elif K % 2 == 1 and len ( A_pos ) == 0 : <NEWLINE> <INDENT> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> ans *= ( ( - A_neg [ - i ] ) % 1000000007 ) <NEWLINE> ans %= 1000000007 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> if K % 2 == 1 : <NEWLINE> <INDENT> ans *= A_pos . pop ( 0 ) <NEWLINE> K -= 1 <NEWLINE> <DEDENT> buf = [ ] <NEWLINE> if len ( len ( A_pos ) >= 2 ) : <NEWLINE> <INDENT> for i in range ( len ( A_pos ) // 2 ) : <NEWLINE> <INDENT> buf . append ( A_pos [ 2 * i ] * A_pos [ 2 * i + 1 ] ) <NEWLINE> <DEDENT> <DEDENT> if len ( len ( A_pos ) >= 2 ) : <NEWLINE> <INDENT> for i in range ( len ( A_neg ) // 2 ) : <NEWLINE> <INDENT> buf . append ( A_neg [ 2 * i ] * A_neg [ 2 * i + 1 ] ) <NEWLINE> <DEDENT> <DEDENT> buf . sort ( reverse = True ) <NEWLINE> for i in range ( K // 2 ) : <NEWLINE> <INDENT> ans *= ( buf [ i ] % 1000000007 ) <NEWLINE> ans %= 1000000007 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT>
MOD = 10 ** 9 + 7 <NEWLINE> <NL> N , K = mii ( ) <NEWLINE> A = lmii ( ) <NEWLINE> <NL> S = [ ] <NEWLINE> T = [ ] <NEWLINE> <NL> for a in A : <NEWLINE> <INDENT> if a < 0 : <NEWLINE> <INDENT> T . append ( a ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> S . append ( a ) <NEWLINE> <NL> <DEDENT> <DEDENT> lenS = len ( S ) <NEWLINE> lenT = len ( T ) <NEWLINE> <NL> ok = False <NEWLINE> if lenS > 0 : <NEWLINE> <INDENT> if N == K : <NEWLINE> <INDENT> ok = lenT % 2 == 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ok = True <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> ok = K % 2 == 0 <NEWLINE> <NL> <DEDENT> ans = 1 <NEWLINE> if not ok : <NEWLINE> <INDENT> A . sort ( key = lambda x : abs ( x ) ) <NEWLINE> for i in range ( K ) : <NEWLINE> <INDENT> ans *= A [ i ] <NEWLINE> ans %= MOD <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> S . sort ( ) <NEWLINE> T . sort ( reverse = True ) <NEWLINE> if K % 2 == 1 : <NEWLINE> <INDENT> ans *= S . pop ( ) <NEWLINE> <DEDENT> P = [ ] <NEWLINE> while len ( S ) >= 2 : <NEWLINE> <INDENT> x = S . pop ( ) <NEWLINE> x *= S . pop ( ) <NEWLINE> P . append ( x ) <NEWLINE> <DEDENT> while len ( T ) >= 2 : <NEWLINE> <INDENT> x = T . pop ( ) <NEWLINE> x *= T . pop ( ) <NEWLINE> P . append ( x ) <NEWLINE> <DEDENT> P . sort ( reverse = True ) <NEWLINE> for i in range ( K // 2 ) : <NEWLINE> <INDENT> ans *= P [ i ] <NEWLINE> ans %= MOD <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> mod = 10 ** 9 + 7 <NEWLINE> def multarray ( x ) : <NEWLINE> <INDENT> ret = 1 <NEWLINE> for i in x : <NEWLINE> <INDENT> ret *= i <NEWLINE> ret %= mod <NEWLINE> <DEDENT> return ret <NEWLINE> <NL> <DEDENT> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if n == k : <NEWLINE> <INDENT> print ( multarray ( a ) ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> ap , am = [ ] , [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if a [ i ] >= 0 : <NEWLINE> <INDENT> ap . append ( a [ i ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> am . append ( a [ i ] ) <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> ap . sort ( reverse = True ) <NEWLINE> am . sort ( ) <NEWLINE> <NL> if len ( am ) == 0 : <NEWLINE> <INDENT> print ( multarray ( ap [ : k ] ) ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> if len ( ap ) == 0 : <NEWLINE> <INDENT> if k % 2 == 0 : <NEWLINE> <INDENT> print ( multarray ( am [ : k ] ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( multarray ( am [ : : - 1 ] [ : k ] ) ) <NEWLINE> <DEDENT> exit ( ) <NEWLINE> <NL> <DEDENT> apm2 = [ ] <NEWLINE> for i in range ( len ( am ) // 2 ) : <NEWLINE> <INDENT> apm2 . append ( ( am [ 2 * i ] * am [ 2 * i + 1 ] , 0 ) ) <NEWLINE> <DEDENT> for i in range ( len ( ap ) // 2 ) : <NEWLINE> <INDENT> apm2 . append ( ( ap [ 2 * i ] * ap [ 2 * i + 1 ] , 1 ) ) <NEWLINE> <DEDENT> apm2 . sort ( reverse = True ) <NEWLINE> <NL> <COMMENT> <NL> p = 0 <NEWLINE> ans = [ ] <NEWLINE> for i in range ( k // 2 ) : <NEWLINE> <INDENT> p += ( 2 * apm2 [ i ] [ 1 ] ) <NEWLINE> ans . append ( apm2 [ i ] [ 0 ] ) <NEWLINE> <NL> <DEDENT> if k % 2 == 0 : <NEWLINE> <INDENT> print ( multarray ( ans ) ) <NEWLINE> exit ( ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> ans_cand = [ ] <NEWLINE> <COMMENT> <NL> if p != len ( ap ) <NEWLINE> <INDENT> ans_cand . append ( multarray ( ans ) * ap [ p ] % mod ) <NEWLINE> <DEDENT> if p >= 2 : <NEWLINE> <COMMENT> <NL> <INDENT> check_i = ans . index ( ap [ p - 1 ] * ap [ p - 2 ] ) <NEWLINE> <COMMENT> <NL> ans [ check_i ] = ap [ p - 2 ] <NEWLINE> ans . append ( apm2 [ k // 2 ] [ 0 ] ) <NEWLINE> ans_cand . append ( multarray ( ans ) ) <NEWLINE> <DEDENT> print ( max ( ans_cand ) ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> aa = list ( map ( np . int64 , input ( ) . split ( ) ) ) <NEWLINE> import numpy as np <NEWLINE> aa = np . array ( aa ) <NEWLINE> <NL> def mul ( dd ) : <NEWLINE> <INDENT> mod = 10 ** 9 + 7 <NEWLINE> ret = 1 <NEWLINE> for d in dd : <NEWLINE> <INDENT> ret = ( ret * d ) % mod <NEWLINE> <DEDENT> return ret <NEWLINE> <NL> <DEDENT> def sol ( aa , n , k ) : <NEWLINE> <INDENT> mod = 10 ** 9 + 7 <NEWLINE> aap = aa [ aa > 0 ] <NEWLINE> aam = aa [ aa < 0 ] <NEWLINE> if n == k : <NEWLINE> <INDENT> return mul ( aa ) <NEWLINE> <DEDENT> if len ( aap ) + 2 * ( len ( aam ) // 2 ) < k : <NEWLINE> <INDENT> return 0 <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> if len ( aam ) == n : <NEWLINE> <INDENT> aam . sort ( ) <NEWLINE> if k % 2 == 1 : <NEWLINE> <INDENT> return mul ( aam [ : k ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return mul ( aam [ - k : ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> aap = aa [ aa >= 0 ] <NEWLINE> aap . sort ( ) <NEWLINE> aap = aap [ : : - 1 ] <NEWLINE> aam . sort ( ) <NEWLINE> <NL> ret = 1 <NEWLINE> if k % 2 > 0 : <NEWLINE> <INDENT> k = k - 1 <NEWLINE> ret *= aap [ 0 ] <NEWLINE> aap = aap [ 1 : ] <NEWLINE> <NL> <DEDENT> aap2 = [ ( aap [ 2 * i ] * aap [ 2 * i + 1 ] ) % mod for i in range ( len ( aap ) // 2 ) ] <NEWLINE> aam2 = [ ( aam [ 2 * i ] * aam [ 2 * i + 1 ] ) % mod for i in range ( len ( aam ) // 2 ) ] <NEWLINE> aap2 . extend ( aam2 ) <NEWLINE> aap2 . sort ( reverse = True ) <NEWLINE> return ( ret * mul ( aap2 [ : k // 2 ] ) ) % mod <NEWLINE> <DEDENT> print ( sol ( aa , n , k ) ) <NEWLINE>
<COMMENT> <NL> N = int ( input ( ) ) <NEWLINE> X = [ 0 ] * N <NEWLINE> ans = 0 <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> x , y = x - 1 , y - 1 <NEWLINE> if x > y : x , y = y , x <NEWLINE> ans += ( y - x ) * ( N - y + x + 1 ) <NEWLINE> X [ x ] += 1 <NEWLINE> X [ y ] += 1 <NEWLINE> <DEDENT> for i , x in enumerate ( X ) : <NEWLINE> <INDENT> ans += ( i + 1 ) * ( N - i ) * ( 2 - x ) <NEWLINE> <DEDENT> print ( ans // 2 ) 0 <NEWLINE>
N = int ( input ( ) ) <NEWLINE> V = 0 <NEWLINE> E = 0 <NEWLINE> for i in range ( N + 1 ) : <NEWLINE> <INDENT> V += i * ( N - i + 1 ) <NEWLINE> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if a > b : <NEWLINE> <INDENT> a , b = b , a <NEWLINE> <DEDENT> E += a * ( N - b + 1 ) <NEWLINE> <DEDENT> ans = V - E <NEWLINE> print ( ans ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> E = [ 0 ] * N <NEWLINE> for _ in range ( N - 1 ) : <NEWLINE> <INDENT> u , v = map ( int , input ( ) . split ( ) ) <NEWLINE> u , v = u - 1 , v - 1 <NEWLINE> if u > v : <NEWLINE> <INDENT> u , v = v , u <NEWLINE> <DEDENT> E [ v ] += 1 <NEWLINE> <DEDENT> t = 0 <NEWLINE> U = [ 0 ] * N <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> t += E [ i ] <NEWLINE> U [ i ] = t <NEWLINE> <NL> <DEDENT> t = n * ( n + 1 ) * ( n + 2 ) // 6 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> t += U [ i ] * i - U [ i ] * ( N - i ) <NEWLINE> <DEDENT> return t <NEWLINE> <NL> <DEDENT> print ( main ( ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> <NL> edge_list = [ ] <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> u , v = map ( int , input ( ) . split ( ) ) <NEWLINE> edge_list . append ( edge ( u - 1 , v - 1 ) ) <NEWLINE> <NL> <DEDENT> ver_num = int ( N * ( N + 1 ) * ( N + 2 ) / 6 ) <NEWLINE> <NL> edge_num = 0 <NEWLINE> for e in edge_list : <NEWLINE> <INDENT> edge_num += ( N + 1 - ( e . max ( ) + 1 ) ) * ( e . min ( ) + 1 ) <NEWLINE> <NL> <DEDENT> print ( ver_num - edge_num ) <NEWLINE>
mod = 10 ** 9 + 7 <NEWLINE> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> arr = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> arr = sorted ( arr , reverse = True , key = lambda x : abs ( x ) ) <COMMENT> <NEWLINE> if k == n : <COMMENT> <NEWLINE> <INDENT> ans = 1 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ans *= arr [ i ] <NEWLINE> ans %= mod <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if k % 2 == 1 and max ( arr ) < 0 : <COMMENT> <NEWLINE> <INDENT> ans = 1 <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> ans *= arr [ n - 1 - i ] <NEWLINE> ans %= mod <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = 1 <NEWLINE> cnt = 0 <NEWLINE> for i in range ( k ) : <COMMENT> <NEWLINE> <INDENT> if arr [ i ] < 0 : <COMMENT> <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> ans *= arr [ i ] <NEWLINE> ans %= mod <NEWLINE> <DEDENT> if cnt % 2 == 0 : <COMMENT> <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT> else : <COMMENT> <NEWLINE> <INDENT> min_plus = - 1 <NEWLINE> min_minus = 1 <NEWLINE> for i in range ( k ) : <COMMENT> <NEWLINE> <INDENT> if arr [ i ] >= 0 : <NEWLINE> <INDENT> min_plus = arr [ i ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> min_minus = arr [ i ] <NEWLINE> <DEDENT> <DEDENT> max_plus = - 1 <NEWLINE> max_minus = 1 <NEWLINE> for i in range ( k , n ) : <COMMENT> <NEWLINE> <INDENT> if arr [ i ] >= 0 and max_plus == - 1 : <NEWLINE> <INDENT> max_plus = arr [ i ] <NEWLINE> <DEDENT> if arr [ i ] < 0 and max_minus == 1 : <NEWLINE> <INDENT> max_minus = arr [ i ] <NEWLINE> <DEDENT> <DEDENT> if min_plus == - 1 : <COMMENT> <NEWLINE> <INDENT> arr . remove ( min_minus ) <NEWLINE> ans = 1 <NEWLINE> for i in range ( k - 1 ) : <NEWLINE> <INDENT> ans *= arr [ i ] <NEWLINE> ans %= mod <NEWLINE> <DEDENT> ans *= max_plus <NEWLINE> ans %= mod <NEWLINE> <DEDENT> elif min_minus == 1 : <COMMENT> <NEWLINE> <INDENT> arr . remove ( min_plus ) <NEWLINE> ans = 1 <NEWLINE> for i in range ( k - 1 ) : <NEWLINE> <INDENT> ans *= arr [ i ] <NEWLINE> ans %= mod <NEWLINE> <DEDENT> ans *= max_minus <NEWLINE> ans %= mod <NEWLINE> <DEDENT> elif min_plus * max_plus >= min_minus * max_minus : <COMMENT> <NEWLINE> <INDENT> arr . remove ( min_minus ) <NEWLINE> ans = 1 <NEWLINE> for i in range ( k - 1 ) : <NEWLINE> <INDENT> ans *= arr [ i ] <NEWLINE> ans %= mod <NEWLINE> <DEDENT> ans *= max_plus <NEWLINE> ans %= mod <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> arr . remove ( min_plus ) <NEWLINE> ans = 1 <NEWLINE> for i in range ( k - 1 ) : <NEWLINE> <INDENT> ans *= arr [ i ] <NEWLINE> ans %= mod <NEWLINE> <DEDENT> ans *= max_minus <NEWLINE> ans %= mod <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> ans = n * ( n + 1 ) * ( n + 2 ) // 6 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> if x > y : <NEWLINE> <INDENT> y , x = x , y <NEWLINE> <DEDENT> ans -= x * ( n - y + 1 ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> A = sorted ( A ) <NEWLINE> if N == K : <NEWLINE> <INDENT> ans0 = 1 <NEWLINE> for a in A [ 0 : N ] : <NEWLINE> <INDENT> ans0 *= a <NEWLINE> ans0 %= MOD <NEWLINE> <DEDENT> print ( ans0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> if K % 2 == 1 and A [ - 1 ] < 0 : <NEWLINE> <INDENT> ans0 = 1 <NEWLINE> for a in A [ N - K : N ] : <NEWLINE> <INDENT> ans0 *= a <NEWLINE> ans0 %= MOD <NEWLINE> <DEDENT> print ( ans0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> ansA = 1 <NEWLINE> for a in A [ 0 : K ] : <NEWLINE> <INDENT> ansA *= a <NEWLINE> ansA %= MOD <NEWLINE> <NL> <DEDENT> A = sorted ( A , reverse = True ) <NEWLINE> ansB = 1 <NEWLINE> for a in A [ 0 : K ] : <NEWLINE> <INDENT> ansB *= a <NEWLINE> ansB %= MOD <NEWLINE> <NL> <DEDENT> A = sorted ( A , key = lambda x : abs ( x ) , reverse = True ) <NEWLINE> ansC = 1 <NEWLINE> for a in A [ 0 : K ] : <NEWLINE> <INDENT> ansC *= a <NEWLINE> ansC %= MOD <NEWLINE> <NL> <DEDENT> ansD = 1 <NEWLINE> for a in A [ 0 : K - 1 ] : <NEWLINE> <INDENT> ansD *= a <NEWLINE> ansD %= MOD <NEWLINE> <DEDENT> B = sorted ( A [ K - 1 : N ] ) <NEWLINE> <NL> if ansD > 0 : ansD *= B [ - 1 ] <NEWLINE> elif ansD < 0 : ansD *= B [ 0 ] <NEWLINE> <NL> <NL> if 0 in B : ansE = 0 <NEWLINE> else : ansE = ansD <NEWLINE> <COMMENT> <NL> print ( max ( ansA , ansB , ansC , ansD , ansE ) % MOD ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> ans = n * ( n + 1 ) * ( n + 2 ) // 6 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if b < a : <NEWLINE> <INDENT> a , b = b , a <NEWLINE> <DEDENT> ans -= a * ( n - b + 1 ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> <NL> import numpy as np <NEWLINE> from numba import njit <NEWLINE> <NL> <NL> @ njit ( <STRING> , cache = True ) <NEWLINE> def solve ( inp ) : <NEWLINE> <INDENT> def bitree_sum ( bit , t , i ) : <NEWLINE> <INDENT> s = 0 <NEWLINE> while i > 0 : <NEWLINE> <INDENT> s += bit [ t , i ] <NEWLINE> i ^= i & - i <NEWLINE> <DEDENT> return s <NEWLINE> <NL> <DEDENT> def bitree_add ( bit , n , t , i , x ) : <NEWLINE> <INDENT> while i <= n : <NEWLINE> <INDENT> bit [ t , i ] += x <NEWLINE> i += i & - i <NEWLINE> <NL> <DEDENT> <DEDENT> def bitree_lower_bound ( bit , n , d , t , x ) : <NEWLINE> <INDENT> sum_ = 0 <NEWLINE> pos = 0 <NEWLINE> for i in range ( d , - 1 , - 1 ) : <NEWLINE> <INDENT> k = pos + ( 1 << i ) <NEWLINE> if k <= n and sum_ + bit [ t , k ] < x : <NEWLINE> <INDENT> sum_ += bit [ t , k ] <NEWLINE> pos += 1 << i <NEWLINE> <DEDENT> <DEDENT> return pos + 1 <NEWLINE> <NL> <DEDENT> def initial_score ( d , ccc , sss ) : <NEWLINE> <INDENT> bit_n = d + 3 <NEWLINE> bit = np . zeros ( ( 26 , bit_n ) , dtype = np . int64 ) <NEWLINE> INF = 10 ** 18 <NEWLINE> for t in range ( 26 ) : <NEWLINE> <INDENT> bitree_add ( bit , bit_n , t , bit_n - 1 , INF ) <NEWLINE> <NL> <DEDENT> ttt = np . zeros ( d , dtype = np . int64 ) <NEWLINE> last = np . full ( 26 , - 1 , dtype = np . int64 ) <NEWLINE> score = 0 <NEWLINE> <NL> for i in range ( d ) : <NEWLINE> <INDENT> best_t = 0 <NEWLINE> best_diff = - INF <NEWLINE> costs = ccc * ( i - last ) <NEWLINE> costs_sum = costs . sum ( ) <NEWLINE> <NL> for t in range ( 26 ) : <NEWLINE> <INDENT> tmp_diff = sss [ i , t ] - costs_sum + costs [ t ] <NEWLINE> if best_diff < tmp_diff : <NEWLINE> <INDENT> best_t = t <NEWLINE> best_diff = tmp_diff <NEWLINE> <DEDENT> <DEDENT> ttt [ i ] = best_t <NEWLINE> last [ best_t ] = i <NEWLINE> score += best_diff <NEWLINE> bitree_add ( bit , bit_n , best_t , i + 2 , 1 ) <NEWLINE> <NL> <DEDENT> return bit , score , ttt <NEWLINE> <NL> <DEDENT> def calculate_score ( d , ccc , sss , ttt ) : <NEWLINE> <INDENT> last = np . full ( 26 , - 1 , dtype = np . int64 ) <NEWLINE> score = 0 <NEWLINE> <NL> for i in range ( d ) : <NEWLINE> <INDENT> t = ttt [ i ] <NEWLINE> last [ t ] = i <NEWLINE> score += sss [ i , t ] - ( ccc * ( i - last ) ) . sum ( ) <NEWLINE> <NL> <DEDENT> return score <NEWLINE> <NL> <DEDENT> def pinpoint_change ( bit , bit_n , bit_d , d , ccc , sss , ttt , permissible ) : <NEWLINE> <INDENT> cd = np . random . randint ( 0 , d ) <NEWLINE> ct = np . random . randint ( 0 , 26 ) <NEWLINE> while ttt [ cd ] == ct : <NEWLINE> <INDENT> ct = np . random . randint ( 0 , 26 ) <NEWLINE> <NL> <DEDENT> diff = 0 <NEWLINE> t = ttt [ cd ] <NEWLINE> k = bitree_sum ( bit , t , cd + 2 ) <NEWLINE> c = bitree_lower_bound ( bit , bit_n , bit_d , t , k - 1 ) - 2 <NEWLINE> e = bitree_lower_bound ( bit , bit_n , bit_d , t , k + 1 ) - 2 <NEWLINE> b = ccc [ t ] <NEWLINE> diff -= b * ( cd - c ) * ( e - cd ) <NEWLINE> diff -= sss [ cd , t ] <NEWLINE> <NL> k = bitree_sum ( bit , ct , cd + 2 ) <NEWLINE> c = bitree_lower_bound ( bit , bit_n , bit_d , ct , k ) - 2 <NEWLINE> e = bitree_lower_bound ( bit , bit_n , bit_d , ct , k + 1 ) - 2 <NEWLINE> b = ccc [ ct ] <NEWLINE> diff += b * ( cd - c ) * ( e - cd ) <NEWLINE> diff += sss [ cd , ct ] <NEWLINE> <NL> if diff > permissible : <NEWLINE> <INDENT> bitree_add ( bit , bit_n , t , cd + 2 , - 1 ) <NEWLINE> bitree_add ( bit , bit_n , ct , cd + 2 , 1 ) <NEWLINE> ttt [ cd ] = ct <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> diff = 0 <NEWLINE> <NL> <DEDENT> return diff <NEWLINE> <NL> <DEDENT> def swap_change ( bit , bit_n , bit_d , d , ccc , sss , ttt , permissible ) : <NEWLINE> <INDENT> cd1 = np . random . randint ( 0 , d - 1 ) <NEWLINE> cd2 = cd1 + 1 <NEWLINE> ct1 = ttt [ cd1 ] <NEWLINE> ct2 = ttt [ cd2 ] <NEWLINE> if ct1 == ct2 : <NEWLINE> <INDENT> return 0 <NEWLINE> <NL> <DEDENT> diff = 0 <NEWLINE> k = bitree_sum ( bit , ct1 , cd1 + 2 ) <NEWLINE> c = bitree_lower_bound ( bit , bit_n , bit_d , ct1 , k - 1 ) - 2 <NEWLINE> e = bitree_lower_bound ( bit , bit_n , bit_d , ct1 , k + 1 ) - 2 <NEWLINE> diff += ccc [ ct1 ] * ( e + c - cd1 - cd2 ) <NEWLINE> k = bitree_sum ( bit , ct2 , cd2 + 2 ) <NEWLINE> c = bitree_lower_bound ( bit , bit_n , bit_d , ct2 , k - 1 ) - 2 <NEWLINE> e = bitree_lower_bound ( bit , bit_n , bit_d , ct2 , k + 1 ) - 2 <NEWLINE> diff -= ccc [ ct2 ] * ( e + c - cd1 - cd2 ) <NEWLINE> diff -= sss [ cd1 , ct1 ] + sss [ cd2 , ct2 ] <NEWLINE> diff += sss [ cd1 , ct2 ] + sss [ cd2 , ct1 ] <NEWLINE> <NL> if diff > permissible : <NEWLINE> <INDENT> bitree_add ( bit , bit_n , ct1 , cd1 + 2 , - 1 ) <NEWLINE> bitree_add ( bit , bit_n , ct1 , cd2 + 2 , 1 ) <NEWLINE> bitree_add ( bit , bit_n , ct2 , cd1 + 2 , 1 ) <NEWLINE> bitree_add ( bit , bit_n , ct2 , cd2 + 2 , - 1 ) <NEWLINE> ttt [ cd1 ] = ct2 <NEWLINE> ttt [ cd2 ] = ct1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> diff = 0 <NEWLINE> <NL> <DEDENT> return diff <NEWLINE> <NL> <DEDENT> d = inp [ 0 ] <NEWLINE> ccc = inp [ 1 : 27 ] <NEWLINE> sss = np . zeros ( ( d , 26 ) , dtype = np . int64 ) <NEWLINE> for r in range ( d ) : <NEWLINE> <INDENT> sss [ r ] = inp [ 27 + r * 26 : 27 + ( r + 1 ) * 26 ] <NEWLINE> <NL> <DEDENT> bit , score , ttt = initial_score ( d , ccc , sss ) <NEWLINE> bit_n = d + 3 <NEWLINE> bit_d = int ( np . log2 ( bit_n ) ) <NEWLINE> loop = 6 * 10 ** 6 <NEWLINE> permissible_min = - 3000.0 <NEWLINE> method_border = 0.5 <NEWLINE> best_score = score <NEWLINE> best_ttt = ttt . copy ( ) <NEWLINE> <NL> for lp in range ( loop ) : <NEWLINE> <INDENT> permissible = ( 1 - lp / loop ) * permissible_min <NEWLINE> if np . random . random ( ) < method_border : <NEWLINE> <INDENT> diff = pinpoint_change ( bit , bit_n , bit_d , d , ccc , sss , ttt , permissible ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> diff = swap_change ( bit , bit_n , bit_d , d , ccc , sss , ttt , permissible ) <NEWLINE> <DEDENT> score += diff <NEWLINE> <NL> <COMMENT> <NL> <NL> if score > best_score : <NEWLINE> <INDENT> best_score = score <NEWLINE> best_ttt = ttt . copy ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> return best_ttt + 1 <NEWLINE> <NL> <NL> <DEDENT> inp = np . fromstring ( sys . stdin . read ( ) , dtype = np . int64 , sep = <STRING> ) <NEWLINE> ans = solve ( inp ) <NEWLINE> print ( <STRING> . join ( map ( str , ans ) ) ) <NEWLINE>
D = int ( input ( ) ) <NEWLINE> c = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> S = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( D ) ] <NEWLINE> <COMMENT> <NL> SUM = 0 <NEWLINE> last = [ 0 ] * 28 <NEWLINE> for d in range ( 1 , D + 1 ) : <NEWLINE> <INDENT> i = S [ d ] . index ( max ( S [ d ] ) ) <NEWLINE> print ( i ) <NEWLINE> <DEDENT>
d = int ( input ( ) ) <NEWLINE> * c , = map ( int , input ( ) . split ( ) ) <NEWLINE> s = [ ] <NEWLINE> for _ in range ( d ) : <NEWLINE> <INDENT> * si , = map ( int , input ( ) . split ( ) ) <NEWLINE> s . append ( si ) <NEWLINE> <COMMENT> <NL> <DEDENT> last = [ - 1 ] * 26 <NEWLINE> <NL> ss = 0 <NEWLINE> for i in range ( d ) : <NEWLINE> <INDENT> ind = - 1 <NEWLINE> smx = - 10 ** 10 <NEWLINE> for j in range ( 26 ) : <NEWLINE> <INDENT> ssj = ss + s [ j ] [ t [ j ] ] <NEWLINE> for j in range ( 26 ) : <NEWLINE> <INDENT> if k != j : <NEWLINE> <INDENT> ssj -= c [ k ] * ( i - last [ k ] ) <NEWLINE> <DEDENT> <DEDENT> if smx < ssj : <NEWLINE> <INDENT> smx = max ( ss , smx ) <NEWLINE> ind = j <NEWLINE> <DEDENT> <DEDENT> last [ ind ] = i <NEWLINE> ss = smx <NEWLINE> print ( j ) <NEWLINE> <NL> <NL> <DEDENT>
<NL> <NL> D = int ( input ( ) ) <NEWLINE> C = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> S = [ ] <NEWLINE> N = 26 <NEWLINE> for d in range ( D ) : <NEWLINE> <INDENT> S += [ list ( map ( int , input ( ) . split ( ) ) ) ] <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> myans = [ d % N for d in range ( D ) ] <NEWLINE> print ( myans ) <NEWLINE> <NL> def estimate ( mylist ) : <NEWLINE> <INDENT> mycost = 0 <NEWLINE> dayflag = [ 0 for n in range ( N ) ] <NEWLINE> for d in range ( 1 , D + 1 ) : <NEWLINE> <INDENT> mycontest = mylist [ d - 1 ] <NEWLINE> mycost += S [ d - 1 ] [ mycontest ] <NEWLINE> dayflag [ mycontest ] = d <NEWLINE> <COMMENT> <NL> for i in range ( 26 ) : <NEWLINE> <INDENT> mycost -= C [ mycontest ] * ( d - dayflag [ i ] ) <NEWLINE> <DEDENT> <DEDENT> return mycost <NEWLINE> <NL> <DEDENT> import random <NEWLINE> import copy <NEWLINE> times = 10 ** 4 <NEWLINE> bestcost = 0 <NEWLINE> random . seed ( 1 ) <NEWLINE> for i in range ( times ) : <NEWLINE> <INDENT> a = random . randrange ( D ) <NEWLINE> b = random . randrange ( D ) <NEWLINE> mylist = copy . deepcopy ( myans ) <NEWLINE> <COMMENT> <NL> mylist [ a ] = myans [ b ] <NEWLINE> mylist [ b ] = myans [ a ] <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> mycost = estimate ( mylist ) <NEWLINE> if bestcost < mycost : <NEWLINE> <INDENT> bestcost = mycost <NEWLINE> myans = mylist <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> for d in range ( N ) : <NEWLINE> <INDENT> print ( myans [ d ] + 1 ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> import sys <NEWLINE> read = sys . stdin . buffer . read <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> <NL> from numba import njit <NEWLINE> <NL> <NL> def getInputs ( ) : <NEWLINE> <INDENT> D = int ( readline ( ) ) <NEWLINE> CS = np . array ( read ( ) . split ( ) , np . int32 ) <NEWLINE> C = CS [ : 26 ] <NEWLINE> S = CS [ 26 : ] . reshape ( ( - 1 , 26 ) ) <NEWLINE> return D , C , S <NEWLINE> <NL> <NL> <DEDENT> @ njit ( <STRING> , cache = True ) <NEWLINE> def _compute_score1 ( D , C , S , out ) : <NEWLINE> <INDENT> score = 0 <NEWLINE> last = np . zeros ( 26 , np . int32 ) <NEWLINE> for d in range ( len ( out ) ) : <NEWLINE> <INDENT> i = out [ d ] <NEWLINE> score += S [ d , i ] <NEWLINE> last [ i ] = d + 1 <NEWLINE> score -= np . sum ( C * ( d + 1 - last ) ) <NEWLINE> <DEDENT> return last , score <NEWLINE> <NL> <NL> <DEDENT> def _update_score ( ) : <NEWLINE> <INDENT> pass <NEWLINE> <NL> <DEDENT> @ njit ( <STRING> , cache = True ) <NEWLINE> def _ramdom_update ( D , C , S , out , score ) : <NEWLINE> <INDENT> d = np . random . randint ( 0 , D ) <NEWLINE> q = np . random . randint ( 0 , 26 ) <NEWLINE> p = out [ d ] <NEWLINE> out [ d ] = q <NEWLINE> <NL> last , new_score = _compute_score1 ( D , C , S , out ) <NEWLINE> if score < new_score : <NEWLINE> <INDENT> score = new_score <NEWLINE> <NL> <DEDENT> return out , last , score <NEWLINE> <NL> <NL> <NL> <DEDENT> def _random_swap ( ) : <NEWLINE> <INDENT> pass <NEWLINE> <NL> <NL> <DEDENT> def step1 ( D , C , S ) : <NEWLINE> <INDENT> out = [ ] <NEWLINE> LAST = 0 <NEWLINE> for d in range ( D ) : <NEWLINE> <INDENT> max_score = - 10000000 <NEWLINE> best_i = 0 <NEWLINE> <NL> for i in range ( 26 ) : <NEWLINE> <INDENT> out . append ( i ) <NEWLINE> last , score = _compute_score1 ( D , C , S , np . array ( out , np . int32 ) ) <NEWLINE> if max_score < score : <NEWLINE> <INDENT> max_score = score <NEWLINE> LAST = last <NEWLINE> best_i = i <NEWLINE> <DEDENT> out . pop ( ) <NEWLINE> <NL> <DEDENT> out . append ( best_i ) <NEWLINE> <NL> <DEDENT> return np . array ( out ) , LAST , max_score <NEWLINE> <NL> <NL> <DEDENT> def step2 ( D , C , S , out , score ) : <NEWLINE> <INDENT> for _ in range ( 10 ** 4 ) : <NEWLINE> <INDENT> out . dtype = np . int32 <NEWLINE> out , last , score = _ramdom_update ( D , C , S , out , score ) <NEWLINE> <DEDENT> return out , last , score <NEWLINE> <NL> <NL> <DEDENT> def output ( out ) : <NEWLINE> <INDENT> out += 1 <NEWLINE> print ( <STRING> . join ( out . astype ( str ) . tolist ( ) ) ) <NEWLINE> <NL> <NL> <DEDENT> D , C , S = getInputs ( ) <NEWLINE> out , _ , score = step1 ( D , C , S ) <NEWLINE> out , _ , score = step2 ( D , C , S , out , score ) <NEWLINE> output ( out ) <NEWLINE> <COMMENT> <NL> <NEWLINE>
<COMMENT> <NL> import numpy as np <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> D = int ( input ( ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> C = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <COMMENT> <NL> c = np . zeros ( 365 ) <NEWLINE> l = np . zeros ( [ 26 , 365 ] ) <NEWLINE> T = [ ] <NEWLINE> for i in range ( D ) : <NEWLINE> <INDENT> S = map ( int , input ( ) . split ( ) ) <NEWLINE> t = max ( S ) <NEWLINE> T . append ( S . index ( t ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> for s in T : <NEWLINE> <INDENT> print ( s ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> import copy <NEWLINE> D = int ( input ( ) ) <NEWLINE> c_list = np . array ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> s_list = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( D ) ] <NEWLINE> last_d_list = np . array ( [ 0 ] * 26 ) <NEWLINE> s_max_list = [ np . argmax ( s_row ) for s_row in s_list ] <NEWLINE> <NL> for day , s_row in enumerate ( s_list ) : <NEWLINE> <INDENT> choice_d = None <NEWLINE> max_reward = - 1 <NEWLINE> for i , last_d in enumerate ( last_d_list ) : <NEWLINE> <INDENT> reward = s_row [ i ] + ( last_d + 1 ) * c_list [ i ] <COMMENT> <NEWLINE> next_max_reward = - 1 <NEWLINE> for j , new_last_d in enumerate ( last_d_list ) : <NEWLINE> <INDENT> if j != i : <NEWLINE> <INDENT> next_reward = s_list [ day + 1 ] [ j ] + ( new_last_d + 2 ) * c_list [ j ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> next_reward = s_list [ day + 1 ] [ j ] + c_list [ j ] <NEWLINE> <DEDENT> if next_reward > next_max_reward : <NEWLINE> <INDENT> next_max_reward = next_reward <NEWLINE> <DEDENT> <DEDENT> reward += next_max_reward <NEWLINE> if reward > max_reward : <NEWLINE> <INDENT> max_reward = reward <NEWLINE> choice_d = i <NEWLINE> <DEDENT> <DEDENT> last_d_list += 1 <NEWLINE> last_d_list [ choice_d ] = 0 <NEWLINE> <NL> print ( choice_d + 1 ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> import time <NEWLINE> import random <NEWLINE> import collections <NEWLINE> import bisect <NEWLINE> <NL> start = time . time ( ) <NEWLINE> <NL> def insert ( list , n ) : <NEWLINE> <INDENT> bisect . insort ( list , n ) <NEWLINE> return list <NEWLINE> <NL> <DEDENT> def read_input ( ) : <NEWLINE> <INDENT> D = int ( input ( ) ) <NEWLINE> c = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> s = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( D ) ] <NEWLINE> return D , c , s <NEWLINE> <DEDENT> D , c , s = read_input ( ) <NEWLINE> <NL> c = np . array ( c ) <NEWLINE> s = np . array ( s ) <NEWLINE> tests = np . argmax ( s , axis = 1 ) <NEWLINE> <NL> def get_dates_for_tests ( tests ) : <NEWLINE> <INDENT> dates_for_tests = [ list ( [ - 1 ] ) for _ in range ( 26 ) ] <NEWLINE> for i , t in enumerate ( tests ) : <NEWLINE> <INDENT> dates_for_tests [ t ] . append ( i ) <NEWLINE> <DEDENT> for t in range ( 26 ) : <NEWLINE> <INDENT> dates_for_tests [ t ] . append ( D ) <NEWLINE> <DEDENT> return dates_for_tests <NEWLINE> <NL> <DEDENT> dates_for_tests = get_dates_for_tests ( tests ) <NEWLINE> <NL> def get_score ( tests ) : <NEWLINE> <INDENT> dates_for_tests = get_dates_for_tests ( tests ) <NEWLINE> score = 0 <NEWLINE> d = np . zeros ( 26 , dtype = np . int64 ) <NEWLINE> for selected , S in zip ( tests , s ) : <NEWLINE> <INDENT> d += 1 <NEWLINE> d [ selected ] = 0 <NEWLINE> score += S [ selected ] - ( c * d ) . sum ( ) <NEWLINE> <DEDENT> return score <NEWLINE> <NL> <DEDENT> def score_diff ( date , test ) : <NEWLINE> <COMMENT> <NL> <INDENT> before = tests [ date ] <NEWLINE> if test == before : <NEWLINE> <INDENT> return 0 , None , None <NEWLINE> <DEDENT> pos_diff = s [ date , test ] - s [ date , before ] <NEWLINE> new_index = bisect . bisect_left ( dates_for_tests [ test ] , date , 1 ) <NEWLINE> new_diff = c [ test ] * ( dates_for_tests [ test ] [ new_index ] - date ) * ( date - dates_for_tests [ test ] [ new_index - 1 ] ) <NEWLINE> <NL> old_index = bisect . bisect_left ( dates_for_tests [ before ] , date , 1 ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> old_diff = c [ before ] * ( dates_for_tests [ before ] [ old_index + 1 ] - date ) * ( date - dates_for_tests [ before ] [ old_index - 1 ] ) <NEWLINE> <NL> total_diff = pos_diff + new_diff - old_diff <NEWLINE> <COMMENT> <NL> return total_diff , new_index , old_index <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> while time . time ( ) < start + 1.8 : <NEWLINE> <INDENT> t = time . time ( ) <NEWLINE> for date in range ( D ) : <NEWLINE> <INDENT> for test in range ( 26 ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> <INDENT> total_diff , new_index , old_index = score_diff ( date , test ) <NEWLINE> to_update = total_diff > 0 <NEWLINE> if t < start + 1.6 and total_diff > - 5000 : <NEWLINE> <INDENT> to_update += random . randrange ( 5 ) == 0 <NEWLINE> <DEDENT> if to_update : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <INDENT> del dates_for_tests [ tests [ date ] ] [ old_index ] <NEWLINE> insert ( dates_for_tests [ test ] , date ) <NEWLINE> tests [ date ] = test <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for t in tests : <NEWLINE> <INDENT> print ( t + 1 ) <NEWLINE> <DEDENT>
D = int ( input ( ) ) <NEWLINE> c_list = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> s_list = [ ] <NEWLINE> for i in range ( D ) : <NEWLINE> <INDENT> s_list . append ( list ( map ( int , input ( ) . split ( <STRING> ) ) ) ) <NEWLINE> <DEDENT> for day in range ( D ) : <NEWLINE> <INDENT> print ( random . randrange ( 26 ) + 1 ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <DEDENT>
<NL> D = int ( input ( ) ) <NEWLINE> <COMMENT> <NL> <NL> last = [ 0 for i in range ( 26 ) ] <NEWLINE> s = [ [ 0 for j in range ( 26 ) ] for i in range ( D ) ] <NEWLINE> c = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> result = [ ] <NEWLINE> total = 0 <NEWLINE> <COMMENT> <NL> for i in range ( D ) : <NEWLINE> <INDENT> a = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> for j , k in enumerate ( a ) : <NEWLINE> <COMMENT> <NL> <INDENT> s [ i ] [ j ] = int ( k ) <NEWLINE> <COMMENT> <NL> <DEDENT> score_max = 0 <NEWLINE> score_index = 0 <NEWLINE> for j in range ( 26 ) : <NEWLINE> <NL> <INDENT> if j == 0 : <NEWLINE> <INDENT> score_max = s [ i ] [ j ] + ( i + 1 - last [ j ] ) * c [ j ] <COMMENT> <NEWLINE> for k in range ( 26 ) : <NEWLINE> <INDENT> score_max -= ( i + 1 - last [ k ] ) * c [ k ] <NEWLINE> <DEDENT> score_index = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> score = s [ i ] [ j ] + ( i + 1 - last [ j ] ) * c [ j ] <NEWLINE> for k in range ( 26 ) : <NEWLINE> <INDENT> score -= ( i + 1 - last [ k ] ) * c [ k ] <NEWLINE> <NL> <DEDENT> if score_max < score : <NEWLINE> <INDENT> score_max = score <NEWLINE> score_index = j <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> result . append ( score_index ) <NEWLINE> <COMMENT> <NL> last [ score_index ] = i + 1 <NEWLINE> toral += score <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> for i in range ( D ) : <NEWLINE> <COMMENT> <NL> <INDENT> print ( result [ i ] + 1 ) <NEWLINE> <DEDENT>
from sys import stdin <NEWLINE> <COMMENT> <NL> d = int ( stdin . readline ( ) . rstrip ( ) ) <NEWLINE> c = list ( map ( int , stdin . readline ( ) . rstrip ( ) . split ( ) ) ) <NEWLINE> <COMMENT> <NL> s = [ list ( map ( int , stdin . readline ( ) . rstrip ( ) . split ( ) ) ) for i in range ( d ) ] <NEWLINE> t = [ int ( stdin . readline ( ) . rstrip ( ) ) for j in range ( d ) ] <NEWLINE> m = int ( stdin . readline ( ) . rstrip ( ) ) <NEWLINE> <COMMENT> <NL> for j in range ( m ) : <NEWLINE> <INDENT> dq = list ( map ( int , stdin . readline ( ) . rstrip ( ) . split ( ) ) ) <NEWLINE> res = 0 <NEWLINE> last = [ 0 for i in range ( 26 ) ] <NEWLINE> <COMMENT> <NL> t [ dq [ 0 ] - 1 ] = dq [ 1 ] <NEWLINE> for day in range ( d ) : <NEWLINE> <INDENT> res += s [ day ] [ t [ day ] - 1 ] <NEWLINE> last [ t [ day ] - 1 ] = day + 1 <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> combined1 = [ x * ( day + 1 - y ) for ( x , y ) in zip ( c , last ) ] <NEWLINE> res -= sum ( combined1 ) <NEWLINE> <COMMENT> <NL> <DEDENT> print ( res ) <NEWLINE> <DEDENT>
<COMMENT> <NL> from random import randint <NEWLINE> d = int ( input ( ) ) <NEWLINE> c = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> s = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( d ) ] <NEWLINE> for i in range ( d ) : s . append ( s [ i ] [ : ] ) <NEWLINE> for i in range ( d ) : s . append ( s [ i ] [ : ] ) <NEWLINE> def xyz ( ) : <NEWLINE> <INDENT> start = randint ( 0 , d - 1 ) <NEWLINE> ans = [ 0 ] * d <NEWLINE> score = 0 <NEWLINE> for i in range ( start , start + d , 26 ) : <NEWLINE> <INDENT> dd = set ( ) <NEWLINE> uu = set ( ) <NEWLINE> h = [ ] <NEWLINE> for j in range ( i , i + 26 ) : <NEWLINE> <INDENT> for k in range ( 26 ) : <NEWLINE> <INDENT> h . append ( [ s [ j ] [ k ] , j , k ] ) <NEWLINE> <DEDENT> <DEDENT> h . sort ( reverse = 1 ) <NEWLINE> for t , j , k in h : <NEWLINE> <INDENT> if j in dd or k in uu : continue <NEWLINE> score += t <NEWLINE> ans [ j ] = k <NEWLINE> dd . add ( j ) <NEWLINE> uu . add ( k ) <NEWLINE> <DEDENT> <DEDENT> return [ score , ans ] <NEWLINE> <DEDENT> score , ans = xyz ( ) <NEWLINE> for i in range ( 40 ) : <NEWLINE> <INDENT> ss , aa = xyz ( ) <NEWLINE> if ss > score : <NEWLINE> <INDENT> score , ans = ss , aa <NEWLINE> <DEDENT> <DEDENT> for i in ans : print ( i + 1 ) <NEWLINE>
import random <NEWLINE> d = int ( input ( ) ) <NEWLINE> c = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> s = [ ] <NEWLINE> for i in range ( d ) : <NEWLINE> <INDENT> s = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> print ( 1 + s . index ( max ( x ) ) ) <NEWLINE> <DEDENT>
<STRING> <NEWLINE> import numpy as np <NEWLINE> import sys <NEWLINE> import random <NEWLINE> <NL> input = sys . stdin . readline <NEWLINE> <NL> <NL> contest_types = 26 <NEWLINE> days = int ( input ( ) ) <NEWLINE> cs = list ( map ( int , input ( ) . strip ( ) . split ( ) ) ) <NEWLINE> ss = [ list ( map ( int , input ( ) . strip ( ) . split ( ) ) ) for _ in range ( days ) ] <NEWLINE> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> <COMMENT> <NL> def calc_contest_dict ( ts ) : <NEWLINE> <INDENT> contest_dict = [ [ - 1 , days ] for _ in range ( contest_types ) ] <NEWLINE> for d , t in enumerate ( ts ) : <NEWLINE> <INDENT> contest_dict [ t ] . append ( d ) <NEWLINE> <NL> <DEDENT> for contest_days in contest_dict : <NEWLINE> <INDENT> contest_days . sort ( ) <NEWLINE> <NL> <DEDENT> return contest_dict <NEWLINE> <NL> <NL> <DEDENT> def count_block ( contest_days ) : <NEWLINE> <INDENT> block = 0 <NEWLINE> for i in range ( len ( contest_days ) - 1 ) : <NEWLINE> <INDENT> period = contest_days [ i + 1 ] - contest_days [ i ] <NEWLINE> block += period * ( period - 1 ) // 2 <NEWLINE> <DEDENT> return block <NEWLINE> <NL> <NL> <DEDENT> def calc_score ( cs , ss , ts ) : <NEWLINE> <INDENT> contest_dict = calc_contest_dict ( ts ) <NEWLINE> <COMMENT> <NL> satisfaction = 0 <NEWLINE> <COMMENT> <NL> for d , t in enumerate ( ts ) : <NEWLINE> <INDENT> satisfaction += ss [ d ] [ t ] <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> for t , contest_days in enumerate ( contest_dict ) : <NEWLINE> <INDENT> decrease = cs [ t ] * count_block ( contest_days ) <NEWLINE> satisfaction -= decrease <NEWLINE> <NL> <DEDENT> return satisfaction <NEWLINE> <NL> <NL> <DEDENT> def greedy ( ) : <NEWLINE> <INDENT> last_days = np . array ( [ - 1 ] * contest_types , dtype = np . int32 ) <NEWLINE> results = [ 0 ] * days <NEWLINE> <NL> for d in range ( days ) : <NEWLINE> <INDENT> max_diff = - 1e9 <NEWLINE> max_c_type = None <NEWLINE> for t in range ( contest_types ) : <NEWLINE> <INDENT> diff = ss [ d ] [ t ] - np . sum ( cs * ( d - last_days ) ) + cs [ t ] * ( d - last_days [ t ] ) <NEWLINE> <NL> if diff > max_diff : <NEWLINE> <INDENT> max_diff = diff <NEWLINE> max_c_type = t <NEWLINE> <NL> <DEDENT> <DEDENT> results [ d ] = max_c_type <NEWLINE> <NL> <DEDENT> return results <NEWLINE> <NL> <NL> <DEDENT> ts = greedy ( ) <NEWLINE> best_score = calc_score ( cs , ss , ts ) <NEWLINE> contest_dict = calc_contest_dict ( ts ) <NEWLINE> best_ts = ts <NEWLINE> <NL> for i in range ( 100000 ) : <NEWLINE> <INDENT> d , q = random . randint ( 0 , days - 1 ) , random . randint ( 0 , contest_types - 1 ) <NEWLINE> old_t = ts [ d ] <NEWLINE> new_t = q <NEWLINE> old_decrease = cs [ old_t ] * count_block ( contest_dict [ old_t ] ) + cs [ new_t ] * count_block ( contest_dict [ new_t ] ) <NEWLINE> ts [ d ] = new_t <NEWLINE> contest_dict = calc_contest_dict ( ts ) <NEWLINE> open_diff = ss [ d ] [ new_t ] - ss [ d ] [ old_t ] <NEWLINE> <NL> new_decrease = cs [ old_t ] * count_block ( contest_dict [ old_t ] ) + cs [ new_t ] * count_block ( contest_dict [ new_t ] ) <NEWLINE> <NL> diff = open_diff + old_decrease - new_decrease <NEWLINE> <NL> if best_score + diff > best_score : <NEWLINE> <INDENT> best_score = best_score + diff <NEWLINE> print ( best_score ) <NEWLINE> <DEDENT> else : <NEWLINE> <COMMENT> <NL> <INDENT> ts [ d ] = old_t <NEWLINE> <NL> <NL> <NL> <DEDENT> <DEDENT>
import random <NEWLINE> import copy <NEWLINE> import numpy as np <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> D = int ( input ( ) ) <NEWLINE> c = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> s = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( D ) ] <NEWLINE> <NL> t = [ 0 ] * D <NEWLINE> <NL> <COMMENT> <NL> penalty = np . array ( c ) <NEWLINE> for i in range ( D ) : <NEWLINE> <INDENT> ind = 0 <NEWLINE> tmp = 0 <NEWLINE> for j in range ( 26 ) : <NEWLINE> <INDENT> if penalty [ j ] + s [ i ] [ j ] > tmp : <NEWLINE> <INDENT> tmp = penalty [ j ] + s [ i ] [ j ] <NEWLINE> ind = j <NEWLINE> <DEDENT> <DEDENT> penalty [ ind ] = 0 <NEWLINE> t [ i ] = ind + 1 <NEWLINE> for j in range ( 26 ) : <NEWLINE> <INDENT> penalty [ j ] += c [ j ] <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> ans = calc ( s , c , t ) <NEWLINE> rand = list ( range ( 365 ) ) <NEWLINE> for i in range ( 1000 ) : <NEWLINE> <INDENT> swap = random . sample ( rand , 2 ) <NEWLINE> t [ swap [ 0 ] ] , t [ swap [ 1 ] ] = t [ swap [ 1 ] ] , t [ swap [ 0 ] ] <NEWLINE> tmp = calc ( s , c , t ) <NEWLINE> if tmp < ans : <NEWLINE> <COMMENT> <NL> <INDENT> t [ swap [ 0 ] ] , t [ swap [ 1 ] ] = t [ swap [ 1 ] ] , t [ swap [ 0 ] ] <NEWLINE> <NL> <DEDENT> <DEDENT> return t <NEWLINE> <NL> <NL> <DEDENT> def output ( t ) : <NEWLINE> <INDENT> for tt in t : <NEWLINE> <INDENT> print ( tt ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def calc ( s , c , t ) : <NEWLINE> <INDENT> d = [ 0 ] * 26 <NEWLINE> <NL> ans = 0 <NEWLINE> days = 0 <NEWLINE> for tt in t : <NEWLINE> <INDENT> for i in range ( 26 ) : <NEWLINE> <INDENT> d [ i ] += 1 <NEWLINE> <DEDENT> d [ tt - 1 ] = 0 <NEWLINE> ans += s [ days ] [ tt - 1 ] <NEWLINE> for i in range ( 26 ) : <NEWLINE> <INDENT> ans -= d [ i ] * c [ i ] <NEWLINE> <DEDENT> days += 1 <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> return ans <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> t = main ( ) <NEWLINE> output ( t ) <NEWLINE> <DEDENT>
<COMMENT> <NL> import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> import numpy as np <NEWLINE> from numba import njit <NEWLINE> <NL> <NL> def read ( ) : <NEWLINE> <INDENT> D = int ( input ( ) . strip ( ) ) <NEWLINE> C = np . fromstring ( input ( ) . strip ( ) , dtype = np . int32 , sep = <STRING> ) <NEWLINE> S = np . empty ( ( D , 26 ) , dtype = np . int32 ) <NEWLINE> for i in range ( D ) : <NEWLINE> <INDENT> s = np . fromstring ( input ( ) . strip ( ) , dtype = np . int32 , sep = <STRING> ) <NEWLINE> S [ i , : ] = s [ : ] <NEWLINE> <DEDENT> M = 1000000 <NEWLINE> RD = np . random . randint ( D , size = ( M , ) , dtype = np . int32 ) <NEWLINE> RQ = np . random . randint ( 26 , size = ( M , ) , dtype = np . int32 ) <NEWLINE> DQ = np . stack ( [ RD , RQ ] ) . T <NEWLINE> COND = np . random . randint ( 2 , size = ( M , ) , dtype = np . bool ) <NEWLINE> SA_COND = np . random . uniform ( size = ( M , ) ) <NEWLINE> return D , C , S , M , DQ , COND , SA_COND <NEWLINE> <NL> <NL> <DEDENT> @ njit <NEWLINE> def diff_satisfaction ( C , S , d , p , last ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> v = 0 <NEWLINE> for i in range ( 26 ) : <NEWLINE> <INDENT> v -= C [ i ] * ( d - last [ i ] ) <NEWLINE> <DEDENT> v += C [ p ] * ( d - last [ p ] ) <NEWLINE> v += S [ d , p ] <NEWLINE> return v <NEWLINE> <NL> <NL> <NL> <DEDENT> @ njit <NEWLINE> def evaluate ( D , C , S , d , p , last , k = 13 ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> v = diff_satisfaction ( C , S , d , p , last ) <NEWLINE> for e in range ( d + 1 , min ( d + k , D ) ) : <NEWLINE> <INDENT> for i in range ( 26 ) : <NEWLINE> <INDENT> v -= C [ i ] * ( e - last [ i ] ) <NEWLINE> <DEDENT> v += C [ p ] * ( d - last [ p ] ) <NEWLINE> <DEDENT> return v <NEWLINE> <NL> <NL> <DEDENT> @ njit <NEWLINE> def greedy_fine ( D , C , S ) : <NEWLINE> <INDENT> T = np . zeros ( D , dtype = np . int32 ) <NEWLINE> last = - np . ones ( 26 , dtype = np . int32 ) <NEWLINE> cumsat = 0 <NEWLINE> for d in range ( D ) : <NEWLINE> <NL> <INDENT> max_p = 0 <NEWLINE> max_e = - 999999999 <NEWLINE> <NL> <COMMENT> <NL> for p in range ( 26 ) : <NEWLINE> <INDENT> e = evaluate ( D , C , S , d , p , last , k = 8 ) <NEWLINE> <NL> if e > max_e : <NEWLINE> <INDENT> max_p = p <NEWLINE> max_e = e <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> cumsat += diff_satisfaction ( C , S , d , max_p , last ) <NEWLINE> T [ d ] = max_p <NEWLINE> last [ max_p ] = d <NEWLINE> <DEDENT> return cumsat , T <NEWLINE> <NL> <NL> <DEDENT> @ njit <NEWLINE> def update ( D , C , S , T , d , q , cumsat ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> p = T [ d ] <NEWLINE> dp1 , dq1 = - 1 , - 1 <NEWLINE> dp3 , dq3 = D , D <NEWLINE> for i in range ( 0 , d ) : <NEWLINE> <INDENT> if T [ i ] == p : <NEWLINE> <INDENT> dp1 = i <NEWLINE> <DEDENT> if T [ i ] == q : <NEWLINE> <INDENT> dq1 = i <NEWLINE> <DEDENT> <DEDENT> for i in range ( D - 1 , d , - 1 ) : <NEWLINE> <INDENT> if T [ i ] == p : <NEWLINE> <INDENT> dp3 = i <NEWLINE> <DEDENT> if T [ i ] == q : <NEWLINE> <INDENT> dq3 = i <NEWLINE> <DEDENT> <DEDENT> cumsat = cumsat - S [ d , p ] + S [ d , q ] - C [ p ] * ( dp3 - d ) * ( d - dp1 ) + C [ q ] * ( dq3 - d ) * ( d - dq1 ) <NEWLINE> return cumsat <NEWLINE> <NL> <NL> <DEDENT> @ njit <NEWLINE> def swap ( D , C , S , T , d0 , p0 , d1 , p1 , cumsat ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> cumsat = update ( D , C , S , T , d0 , p1 , cumsat ) <NEWLINE> cumsat = update ( D , C , S , T , d1 , p0 , cumsat ) <NEWLINE> return cumsat <NEWLINE> <NL> <NL> <DEDENT> @ njit <NEWLINE> def greedy ( D , C , S ) : <NEWLINE> <INDENT> T = np . zeros ( D , dtype = np . int32 ) <NEWLINE> last = - np . ones ( 26 , dtype = np . int32 ) <NEWLINE> cumsat = 0 <NEWLINE> for d in range ( D ) : <NEWLINE> <INDENT> max_p = 0 <NEWLINE> max_diff = - 999999999 <NEWLINE> <NL> <COMMENT> <NL> for p in range ( 26 ) : <NEWLINE> <INDENT> diff = diff_satisfaction ( C , S , d , p , last ) <NEWLINE> if diff > max_diff : <NEWLINE> <INDENT> max_p = p <NEWLINE> max_diff = diff <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> cumsat += max_diff <NEWLINE> T [ d ] = max_p <NEWLINE> last [ max_p ] = d <NEWLINE> <DEDENT> return cumsat , T <NEWLINE> <NL> <NL> <DEDENT> @ njit <NEWLINE> def sa_proba ( delta , t ) : <NEWLINE> <INDENT> if delta >= 0 : <NEWLINE> <INDENT> return 1.0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return np . exp ( delta / t ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> @ njit <NEWLINE> def solve ( D , C , S , M , DQ , COND , SA_COND ) : <NEWLINE> <INDENT> cumsat , T = greedy ( D , C , S ) <NEWLINE> <COMMENT> <NL> SA_T0 = 2e3 <NEWLINE> <COMMENT> <NL> SA_T1 = 6e2 <NEWLINE> <COMMENT> <NL> SA_STEP = 100 <NEWLINE> <NL> t = SA_T0 <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> if i % SA_STEP == 0 : <NEWLINE> <INDENT> f = i / M <NEWLINE> t = ( SA_T0 ** ( 1.0 - f ) ) * ( SA_T1 ** f ) <NEWLINE> <DEDENT> d , q = DQ [ i , : ] <NEWLINE> if COND [ i ] >= 1 : <NEWLINE> <INDENT> newsat = update ( D , C , S , T , d , q , cumsat ) <NEWLINE> <COMMENT> <NL> if sa_proba ( newsat - cumsat , t ) > SA_COND [ i ] : <NEWLINE> <INDENT> cumsat = newsat <NEWLINE> T [ d ] = q <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> d0 , d1 = d , min ( d + 1 + q // 2 , D - 1 ) <NEWLINE> newsat = swap ( D , C , S , T , d0 , T [ d0 ] , d1 , T [ d1 ] , cumsat ) <NEWLINE> <COMMENT> <NL> if sa_proba ( newsat - cumsat , t ) > SA_COND [ i ] : <NEWLINE> <INDENT> cumsat = newsat <NEWLINE> T [ d1 ] , T [ d0 ] = T [ d0 ] , T [ d1 ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> for a in T : <NEWLINE> <INDENT> print ( a + 1 ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> inputs = read ( ) <NEWLINE> outputs = solve ( * inputs ) <NEWLINE> if outputs is not None : <NEWLINE> <INDENT> print ( <STRING> % str ( outputs ) ) <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> import numpy as np <NEWLINE> from numba import njit <NEWLINE> <NL> <NL> def read ( ) : <NEWLINE> <INDENT> D = int ( input ( ) . strip ( ) ) <NEWLINE> C = np . fromstring ( input ( ) . strip ( ) , dtype = np . int32 , sep = <STRING> ) <NEWLINE> S = np . empty ( ( D , 26 ) , dtype = np . int32 ) <NEWLINE> for i in range ( D ) : <NEWLINE> <INDENT> s = np . fromstring ( input ( ) . strip ( ) , dtype = np . int32 , sep = <STRING> ) <NEWLINE> S [ i , : ] = s [ : ] <NEWLINE> <DEDENT> M = 50000 <NEWLINE> RD = np . random . randint ( D , size = ( M , ) , dtype = np . int32 ) <NEWLINE> RQ = np . random . randint ( 26 , size = ( M , ) , dtype = np . int32 ) <NEWLINE> DQ = np . stack ( [ RD , RQ ] ) . T <NEWLINE> COND = np . random . randint ( 2 , size = ( M , ) , dtype = np . bool ) <NEWLINE> return D , C , S , M , DQ , COND <NEWLINE> <NL> <NL> <DEDENT> @ njit <NEWLINE> def diff_satisfaction ( C , S , d , p , last ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> v = 0 <NEWLINE> for i in range ( 26 ) : <NEWLINE> <INDENT> v -= C [ i ] * ( d - last [ i ] ) <NEWLINE> <DEDENT> v += C [ p ] * ( d - last [ p ] ) <NEWLINE> v += S [ d , p ] <NEWLINE> return v <NEWLINE> <NL> <NL> <NL> <DEDENT> @ njit <NEWLINE> def evaluate ( D , C , S , d , p , last , k = 13 ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> v = diff_satisfaction ( C , S , d , p , last ) <NEWLINE> for e in range ( d + 1 , min ( d + k , D ) ) : <NEWLINE> <INDENT> for i in range ( 26 ) : <NEWLINE> <INDENT> v -= C [ i ] * ( e - last [ i ] ) <NEWLINE> <DEDENT> v += C [ p ] * ( d - last [ p ] ) <NEWLINE> <DEDENT> return v <NEWLINE> <NL> <NL> <DEDENT> @ njit <NEWLINE> def greedy_fine ( D , C , S ) : <NEWLINE> <INDENT> T = np . zeros ( D , dtype = np . int32 ) <NEWLINE> last = - np . ones ( 26 , dtype = np . int32 ) <NEWLINE> cumsat = 0 <NEWLINE> for d in range ( D ) : <NEWLINE> <NL> <INDENT> max_p = 0 <NEWLINE> max_e = - 999999999 <NEWLINE> <NL> <COMMENT> <NL> for p in range ( 26 ) : <NEWLINE> <INDENT> e = evaluate ( D , C , S , d , p , last , k = 8 ) <NEWLINE> <NL> if e > max_e : <NEWLINE> <INDENT> max_p = p <NEWLINE> max_e = e <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> cumsat += diff_satisfaction ( C , S , d , max_p , last ) <NEWLINE> T [ d ] = max_p <NEWLINE> last [ max_p ] = d <NEWLINE> <DEDENT> return cumsat , T <NEWLINE> <NL> <NL> <DEDENT> @ njit <NEWLINE> def update ( D , C , S , T , d , q , cumsat ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> p = T [ d ] <NEWLINE> dp1 , dq1 = - 1 , - 1 <NEWLINE> dp3 , dq3 = D , D <NEWLINE> for i in range ( 0 , d ) : <NEWLINE> <INDENT> if T [ i ] == p : <NEWLINE> <INDENT> dp1 = i <NEWLINE> <DEDENT> if T [ i ] == q : <NEWLINE> <INDENT> dq1 = i <NEWLINE> <DEDENT> <DEDENT> for i in range ( D - 1 , d , - 1 ) : <NEWLINE> <INDENT> if T [ i ] == p : <NEWLINE> <INDENT> dp3 = i <NEWLINE> <DEDENT> if T [ i ] == q : <NEWLINE> <INDENT> dq3 = i <NEWLINE> <DEDENT> <DEDENT> cumsat = cumsat - S [ d , p ] + S [ d , q ] - C [ p ] * ( dp3 - d ) * ( d - dp1 ) + C [ q ] * ( dq3 - d ) * ( d - dq1 ) <NEWLINE> return cumsat <NEWLINE> <NL> <NL> <DEDENT> @ njit <NEWLINE> def swap ( D , C , S , T , d , q , cumsat ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> d0 , d1 = d , min ( d + q , D - 1 ) <NEWLINE> q0 , q1 = T [ d0 ] , T [ d1 ] <NEWLINE> cumsat = update ( D , C , S , T , d0 , q0 , cumsat ) <NEWLINE> cumsat = update ( D , C , S , T , d1 , q1 , cumsat ) <NEWLINE> return cumsat <NEWLINE> <NL> <NL> <DEDENT> @ njit <NEWLINE> def greedy ( D , C , S ) : <NEWLINE> <INDENT> T = np . zeros ( D , dtype = np . int32 ) <NEWLINE> last = - np . ones ( 26 , dtype = np . int32 ) <NEWLINE> cumsat = 0 <NEWLINE> for d in range ( D ) : <NEWLINE> <INDENT> max_p = 0 <NEWLINE> max_diff = - 999999999 <NEWLINE> <NL> <COMMENT> <NL> for p in range ( 26 ) : <NEWLINE> <INDENT> diff = diff_satisfaction ( C , S , d , p , last ) <NEWLINE> if diff > max_diff : <NEWLINE> <INDENT> max_p = p <NEWLINE> max_diff = diff <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> cumsat += max_diff <NEWLINE> T [ d ] = max_p <NEWLINE> last [ max_p ] = d <NEWLINE> <DEDENT> return cumsat , T <NEWLINE> <NL> <NL> <DEDENT> @ njit <NEWLINE> def solve ( D , C , S , M , DQ , COND ) : <NEWLINE> <INDENT> cumsat , T = greedy_fine ( D , C , S ) <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> d , q = DQ [ i , : ] <NEWLINE> if COND [ i ] : <NEWLINE> <INDENT> newsat = update ( D , C , S , T , d , q , cumsat ) <NEWLINE> <DEDENT> else : <NEWLINE> <COMMENT> <NL> <INDENT> newsat = swap ( D , C , S , T , d , ( q + 1 ) // 2 , cumsat ) <NEWLINE> <DEDENT> if newsat > cumsat : <NEWLINE> <INDENT> cumsat = newsat <NEWLINE> T [ d ] = q <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> for t in T : <NEWLINE> <INDENT> print ( t + 1 ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> inputs = read ( ) <NEWLINE> outputs = solve ( * inputs ) <NEWLINE> if outputs is not None : <NEWLINE> <INDENT> print ( <STRING> % str ( outputs ) ) <NEWLINE> <DEDENT> <DEDENT>
D = int ( input ( ) ) <NEWLINE> C = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> S = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( D ) ] <NEWLINE> A = [ 0 for i in range ( 26 ) ] <NEWLINE> ans = 0 <NEWLINE> for i in range ( D ) : <NEWLINE> <INDENT> t = int ( input ( ) ) <NEWLINE> A [ t - 1 ] = i + 1 <NEWLINE> c = 0 <NEWLINE> for j in range ( 26 ) : <NEWLINE> <INDENT> c += C [ j ] * ( i + 1 - A [ j ] ) <NEWLINE> <DEDENT> ans += S [ i ] [ t - 1 ] - c <NEWLINE> print ( ans ) <NEWLINE> <DEDENT>
import random <NEWLINE> <NL> for i in range ( 365 ) : <NEWLINE> <INDENT> print ( random . randint ( 1 , 26 ) <NEWLINE> <DEDENT>
from time import time <NEWLINE> stime = time ( ) <NEWLINE> <NL> from copy import copy <NEWLINE> from random import randint <NEWLINE> <NL> def get_fav_contest ( s , t ) : <NEWLINE> <INDENT> s = copy ( s ) <NEWLINE> t = copy ( t ) <NEWLINE> dc = 0 <NEWLINE> d = len ( t ) <NEWLINE> for i in range ( 1 , d ) : <NEWLINE> <INDENT> dc += s [ i ] [ t [ i ] ] <NEWLINE> ca [ t [ i ] ] = i <NEWLINE> dc -= sum ( [ c [ i2 ] * ( i - ca [ i2 ] ) for i2 in range ( 1 , 27 ) ] ) <NEWLINE> <DEDENT> return dc <NEWLINE> <NL> <DEDENT> d = int ( input ( ) ) <NEWLINE> c = [ 0 ] + list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> <NL> s = [ [ ] ] + [ [ 0 ] + list ( map ( int , input ( ) . split ( <STRING> ) ) ) for _ in range ( d ) ] <NEWLINE> <NL> t = 0 <COMMENT> <NEWLINE> tl = [ 0 ] <NEWLINE> <NL> ca = [ 0 ] * ( 1 + 26 ) <COMMENT> <NEWLINE> cat = [ ] <COMMENT> <NEWLINE> cat2 = [ ] <NEWLINE> <NL> for i in range ( 1 , d + 1 ) : <NEWLINE> <INDENT> cat = [ 0 ] <NEWLINE> for i2 in range ( 1 , 27 ) : <NEWLINE> <INDENT> cat2 = copy ( ca ) <NEWLINE> cat2 [ i2 ] = i <NEWLINE> cat . append ( s [ i ] [ i2 ] + sum ( c [ i3 ] * ( i - ca [ i3 ] ) for i3 in range ( 1 , 27 ) ) ) <NEWLINE> <DEDENT> t = cat . index ( max ( cat ) ) <NEWLINE> ca [ t ] = i <NEWLINE> tl . append ( t ) <NEWLINE> <NL> <DEDENT> default_t = get_fav_contest ( s , tl ) <NEWLINE> <NL> ch = 0 <COMMENT> <NEWLINE> temp1 = 0 <COMMENT> <NEWLINE> while time ( ) - stime < 2 : <NEWLINE> <INDENT> ch = randint ( 1 , 365 ) <NEWLINE> temp1 = tl [ ch ] <NEWLINE> tl [ ch ] = randint ( 1 , 26 ) <NEWLINE> if get_fav_contest ( s , tl ) < default_t : <NEWLINE> <INDENT> tl [ ch ] = temp1 <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> . join ( map ( str , tl [ 1 : ] ) ) ) <NEWLINE>
import numpy as np <NEWLINE> <NL> D = int ( input ( ) ) <NEWLINE> c = np . array ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <COMMENT> <NL> s = [ [ ] for i in range ( D ) ] <NEWLINE> for i in range ( D ) : <NEWLINE> <INDENT> s [ i ] = np . array ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <COMMENT> <NL> <DEDENT> v = 0 <NEWLINE> cc = np . array ( [ 0 ] * 26 ) <NEWLINE> last = np . array ( [ - 1 ] * 26 ) <NEWLINE> for d in range ( D ) : <NEWLINE> <INDENT> cc += c <NEWLINE> av = s [ d ] - sum ( cc ) + cc <NEWLINE> av2 = av + cc * ( D - d - 1 ) + c * ( D - d - 1 ) ( D - d ) // 2 <NEWLINE> m = max ( av2 ) <NEWLINE> for t in range ( 26 ) : <NEWLINE> <INDENT> if av2 [ t ] == m : <NEWLINE> <INDENT> cc [ t ] = 0 <NEWLINE> v += av [ t ] <NEWLINE> print ( t + 1 ) <NEWLINE> break <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT>
D = int ( input ( ) ) <NEWLINE> c = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> s = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( D ) ] <NEWLINE> <NL> for i in range ( D ) : <NEWLINE> <INDENT> print ( i % 26 + 1 ) : <NEWLINE> <DEDENT>
def resolve ( ) : <NEWLINE> <INDENT> D = int ( input ( ) ) <NEWLINE> C = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> S = [ ] <NEWLINE> for i in range ( D ) : <NEWLINE> <INDENT> S . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <DEDENT> last_d = [ ] <NEWLINE> score = 0 <NEWLINE> t = 0 <NEWLINE> <NL> for i in range ( len ( C ) ) : <NEWLINE> <INDENT> t = max ( t , C [ i ] ) <NEWLINE> <NL> <DEDENT> for d in range ( D ) : <NEWLINE> <INDENT> score += S [ d ] [ t [ d ] - 1 ] <NEWLINE> last_d . append ( t [ d ] - 1 ) <NEWLINE> for i in range ( len ( C ) ) : <NEWLINE> <INDENT> if i in last_d : <NEWLINE> <INDENT> score -= C [ i ] * last_d [ : : - 1 ] . index ( i ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> score -= C [ i ] * ( d + 1 ) <NEWLINE> <DEDENT> <DEDENT> print ( score ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> resolve ( ) <NEWLINE> <DEDENT>
from bisect import bisect_left <NEWLINE> from random import randint <NEWLINE> from time import time <NEWLINE> <NL> start = time ( ) <NEWLINE> <NL> D = int ( input ( ) ) <NEWLINE> * C , = map ( int , input ( ) . split ( ) ) <NEWLINE> S = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( D ) ] <NEWLINE> T = [ randint ( 1 , 26 ) for _ in range ( D ) ] <NEWLINE> <NL> days = [ [ 0 ] for _ in range ( 26 ) ] <NEWLINE> <NL> def init ( ) : <NEWLINE> <INDENT> global T , days <NEWLINE> score = 0 <NEWLINE> last = [ 0 ] * 26 <NEWLINE> for d , t in enumerate ( T , 1 ) : <NEWLINE> <INDENT> score += S [ d - 1 ] [ t - 1 ] <NEWLINE> last [ t - 1 ] = d <NEWLINE> for c , l in zip ( C , last ) : score -= c * ( d - l ) <NEWLINE> days [ t - 1 ] . append ( d ) <NEWLINE> <DEDENT> for i in range ( 26 ) : days [ i ] . append ( D + 1 ) <NEWLINE> return score <NEWLINE> <NL> <DEDENT> def diff ( d , q ) : <NEWLINE> <INDENT> global T , C , S , days <NEWLINE> dif = 0 <NEWLINE> p = T [ d - 1 ] <NEWLINE> dif += S [ d - 1 ] [ q - 1 ] - S [ d - 1 ] [ p - 1 ] <NEWLINE> <NL> idx_p = bisect_left ( days [ p - 1 ] , d ) <NEWLINE> bef_p , aft_p = days [ p - 1 ] [ idx_p - 1 ] , days [ p - 1 ] [ idx_p + 1 ] <NEWLINE> del days [ p - 1 ] [ idx_p ] <NEWLINE> <NL> idx_q = bisect_left ( days [ q - 1 ] , d ) <NEWLINE> bef_q , aft_q = days [ q - 1 ] [ idx_q - 1 ] , days [ q - 1 ] [ idx_q ] <NEWLINE> days [ q - 1 ] . insert ( idx_q , d ) <NEWLINE> dif += C [ q - 1 ] * ( d - bef_q ) * ( aft_q - d ) - C [ p - 1 ] * ( d - bef_p ) * ( aft_p - d ) <NEWLINE> <NL> <NL> <NL> return dif <NEWLINE> <NL> <DEDENT> score = init ( ) <NEWLINE> while time ( ) - start < 1.8 : <NEWLINE> <INDENT> d , q = randint ( 1 , D ) , randint ( 1 , 26 ) <NEWLINE> dif = diff ( d , q ) <NEWLINE> if dif > 0 : <NEWLINE> <INDENT> T [ d - 1 ] = q <NEWLINE> score += dif <NEWLINE> <DEDENT> <DEDENT> print ( * T , sep = <STRING> ) <NEWLINE>
import sys <NEWLINE> import random <NEWLINE> import time <NEWLINE> import numpy as np <NEWLINE> <NL> readline = sys . stdin . readline <NEWLINE> readall = sys . stdin . read <NEWLINE> ns = lambda : readline ( ) . rstrip ( ) <NEWLINE> ni = lambda : int ( readline ( ) . rstrip ( ) ) <NEWLINE> nm = lambda : map ( int , readline ( ) . split ( ) ) <NEWLINE> nl = lambda : list ( map ( int , readline ( ) . split ( ) ) ) <NEWLINE> prn = lambda x : print ( * x , sep = <STRING> ) <NEWLINE> <NL> def prob ( e1 , e2 , T ) : <NEWLINE> <INDENT> if e2 < e1 : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return np . exp ( ( e1 - e2 ) / T ) <NEWLINE> <NL> <DEDENT> <DEDENT> def solve ( ) : <NEWLINE> <INDENT> D = ni ( ) <NEWLINE> c = nl ( ) <NEWLINE> s = [ nl ( ) for _ in range ( D ) ] <NEWLINE> m = 26 <NEWLINE> start = time . time ( ) <NEWLINE> dT = 0.995 <NEWLINE> T = 10000 <NEWLINE> <NL> def calc ( sche , m = 26 ) : <NEWLINE> <INDENT> last = [ - 1 ] * m <NEWLINE> ans = 0 <NEWLINE> for i in range ( D ) : <NEWLINE> <INDENT> t = sche [ i ] <NEWLINE> ans += s [ i ] [ t ] <NEWLINE> last [ t ] = i <NEWLINE> for j in range ( m ) : <NEWLINE> <INDENT> ans -= c [ j ] * ( i - last [ j ] ) <NEWLINE> <DEDENT> <DEDENT> return ans <NEWLINE> <NL> <DEDENT> def change ( d , q , sc ) : <NEWLINE> <INDENT> b = sche [ d ] <NEWLINE> fq , bq = - 1 , D <NEWLINE> fb , bb = - 1 , D <NEWLINE> for i in range ( d ) : <NEWLINE> <INDENT> if sche [ i ] == q : <NEWLINE> <INDENT> fq = i <NEWLINE> <DEDENT> if sche [ i ] == b : <NEWLINE> <INDENT> fb = i <NEWLINE> <DEDENT> <DEDENT> for i in range ( D - 1 , d , - 1 ) : <NEWLINE> <INDENT> if sche [ i ] == q : <NEWLINE> <INDENT> bq = i <NEWLINE> <DEDENT> if sche [ i ] == b : <NEWLINE> <INDENT> bb = i <NEWLINE> <DEDENT> <DEDENT> sc += ( ( bb - d ) * ( bb - d - 1 ) // 2 + ( d - fb ) * ( d - fb - 1 ) // 2 ) * c [ b ] <NEWLINE> sc += ( ( bq - fq ) * ( bq - fq - 1 ) // 2 ) * c [ q ] <NEWLINE> sc -= s [ d ] [ b ] <NEWLINE> sc -= ( ( bq - d ) * ( bq - d - 1 ) // 2 + ( d - fq ) * ( d - fq - 1 ) // 2 ) * c [ q ] <NEWLINE> sc -= ( ( bb - fb ) * ( bb - fb - 1 ) // 2 ) * c [ b ] <NEWLINE> sc += s [ d ] [ q ] <NEWLINE> return sc <NEWLINE> <NL> <DEDENT> sche = [ random . randint ( 0 , m - 1 ) for _ in range ( D ) ] <NEWLINE> sc = calc ( sche ) <NEWLINE> for _ in range ( 15 ) : <NEWLINE> <INDENT> a = [ random . randint ( 0 , m - 1 ) for _ in range ( D ) ] <NEWLINE> nsc = calc ( a ) <NEWLINE> if sc < nsc : <NEWLINE> <INDENT> sche = a <NEWLINE> sc = nsc <NEWLINE> <DEDENT> <DEDENT> bestst = sche <NEWLINE> best = sc <NEWLINE> <NL> while time . time ( ) - start < 1.8 : <NEWLINE> <INDENT> for _ in range ( 300 ) : <NEWLINE> <INDENT> d = random . randint ( 0 , D - 1 ) <NEWLINE> q = random . randint ( 0 , m - 1 ) <NEWLINE> nsc = change ( d , q , sc ) <NEWLINE> if best < nsc : <NEWLINE> <INDENT> bestst = sche [ : ] <NEWLINE> best = sc <NEWLINE> <DEDENT> if random . random ( ) < prob ( sc , nsc , T ) : <NEWLINE> <INDENT> sche [ d ] = q <NEWLINE> sc = nsc <NEWLINE> <DEDENT> <DEDENT> T *= dt <NEWLINE> <DEDENT> prn ( [ 1 + x for x in bestst ] ) <NEWLINE> <NL> return <NEWLINE> <NL> <DEDENT> solve ( ) <NEWLINE>
D = int ( input ( ) ) <NEWLINE> c = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> s = [ ] <NEWLINE> for i in range ( D ) : <NEWLINE> <INDENT> s . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> <DEDENT> def last ( d , la ) : <NEWLINE> <INDENT> s = 0 <NEWLINE> <NL> for i in range ( 26 ) : <NEWLINE> <INDENT> if la [ i ] == 0 and i == d : <NEWLINE> <INDENT> s += c [ i ] * ( d - la [ i ] - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s += c [ i ] * ( d - la [ i ] ) <NEWLINE> <DEDENT> <DEDENT> return s <NEWLINE> <NL> <DEDENT> lastday = [ 0 ] * 26 <NEWLINE> a = 0 <NEWLINE> <NL> for d in range ( D ) : <NEWLINE> <NL> <INDENT> eff = s [ d ] [ 0 ] - last ( d + 1 , lastday ) <NEWLINE> ret = 0 <NEWLINE> for t in range ( 26 ) : <NEWLINE> <INDENT> bef = lastday [ t ] <NEWLINE> <COMMENT> <NL> <NL> now = s [ d ] [ t ] - last ( d + 1 , lastday ) <NEWLINE> if eff < now : <NEWLINE> <INDENT> eff = now <NEWLINE> ret = t <NEWLINE> <NL> <DEDENT> lastday [ t ] = bef <NEWLINE> <NL> <DEDENT> lastday [ ret ] = d + 1 <NEWLINE> a += eff <NEWLINE> print ( ret + 1 <NEWLINE> <DEDENT>
D = int ( input ( ) ) <NEWLINE> c = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> s = [ ] <NEWLINE> for i in range ( D ) : <NEWLINE> <INDENT> s . append ( [ int ( j ) for j in input ( ) . split ( ) ] ) <NEWLINE> <NL> <DEDENT> for i , s_i in enumerate ( s ) : <NEWLINE> <INDENT> print ( s . index ( max ( s_i ) ) ) <NEWLINE> <DEDENT>
d = int ( input ( ) ) <NEWLINE> c = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> s = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( d ) ] <NEWLINE> <NL> def calc_score ( day , contest , last ) : <NEWLINE> <INDENT> t_last = last [ : ] <NEWLINE> t_last [ contest ] = day + 1 <NEWLINE> <NL> contest_score = s [ day ] [ contest ] <NEWLINE> score = contest_score <NEWLINE> <NL> dis = 0 <NEWLINE> for i in range ( 26 ) : <NEWLINE> <INDENT> dis += c [ i ] * ( ( day + 1 ) - t_last [ i ] ) <NEWLINE> <DEDENT> score -= dis <NEWLINE> <NL> return score <NEWLINE> <NL> <DEDENT> score = 0 <NEWLINE> last = [ 0 for i in range ( 26 ) ] <NEWLINE> <NL> for day in range ( d ) : <NEWLINE> <INDENT> best_score = 0 <NEWLINE> best_contest = - 1 <NEWLINE> for contest in range ( 26 ) : <NEWLINE> <INDENT> t_score = calc_score ( day , contest , last ) <NEWLINE> if t_score > best_score : <NEWLINE> <INDENT> best_score = t_score <NEWLINE> best_contest = contest <NEWLINE> <NL> <DEDENT> <DEDENT> last [ best_contest ] = day + 1 <NEWLINE> score += best_score <NEWLINE> <COMMENT> <NL> print ( best_contest + 1 <NEWLINE> <DEDENT>
import random <NEWLINE> import copy <NEWLINE> <NL> def cal ( x ) : <NEWLINE> <INDENT> Manzoku = 0 <NEWLINE> l = [ 0 ] * 26 <NEWLINE> for d in range ( D ) : <NEWLINE> <INDENT> l [ x [ d ] - 1 ] = d <NEWLINE> Manzoku += s [ d ] [ x [ d ] - 1 ] <NEWLINE> for i in range ( 26 ) : <NEWLINE> <INDENT> Manzoku -= c [ i ] * ( d - l [ i ] ) <NEWLINE> <DEDENT> <DEDENT> return Manzoku <NEWLINE> <NL> <DEDENT> D = int ( input ( ) ) <NEWLINE> c = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> s = [ ] <NEWLINE> t = [ ] <NEWLINE> for i in range ( D ) : <NEWLINE> <INDENT> s . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <DEDENT> l = [ 0 ] * 26 <NEWLINE> <NL> max = 0 <NEWLINE> target = 0 <NEWLINE> deg = 0 <NEWLINE> <COMMENT> <NL> for d in range ( D ) : <NEWLINE> <INDENT> degsum = 0 <NEWLINE> max = 0 <NEWLINE> for i in range ( 26 ) : <NEWLINE> <INDENT> degsum += c [ i ] * ( d - l [ i ] ) <NEWLINE> <DEDENT> for i in range ( 26 ) : <NEWLINE> <INDENT> w = degsum - c [ i ] * ( d - l [ i ] ) - s [ d ] [ i ] <NEWLINE> if max < - w : <NEWLINE> <INDENT> max = - w <NEWLINE> target = i <NEWLINE> <DEDENT> <DEDENT> t . append ( target + 1 ) <NEWLINE> l [ target ] = d <NEWLINE> <NL> <DEDENT> mManzoku = cal ( t ) <NEWLINE> for i in range ( 100000 ) : <NEWLINE> <INDENT> rd = int ( random . random ( ) * D ) <NEWLINE> ri = int ( random . random ( ) * 26 ) <NEWLINE> t1 = copy . deepcopy ( t ) <NEWLINE> t1 [ d ] = ri + 1 <NEWLINE> n = cal ( t1 ) <NEWLINE> if mManzoku < n : <NEWLINE> <INDENT> t = copy . deepcopy ( t1 ) <NEWLINE> mManzoku = n <NEWLINE> <NL> <DEDENT> <DEDENT> print ( mManzoku ) <NEWLINE> for i in range ( D ) : <NEWLINE> <INDENT> print ( t [ i ] ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> ans = 0 <NEWLINE> D = int ( input ( ) ) <NEWLINE> C = np . array ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> last_day = np . array ( [ - 1 for _ in range ( 26 ) ] ) <NEWLINE> score = np . array ( [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( D ) ] ) <NEWLINE> <NL> for day in range ( D ) : <NEWLINE> <INDENT> today_point = C * ( day - last_day ) <NEWLINE> S_today = sum ( today_point ) <NEWLINE> for k in range ( 26 ) : <NEWLINE> <INDENT> today_point [ k ] = score [ day ] [ k ] - S_today + today_point [ k ] <NEWLINE> <NL> <DEDENT> if day != D - 1 : <NEWLINE> <INDENT> max_score = - 1 * float ( <STRING> ) <NEWLINE> for k in range ( 26 ) : <NEWLINE> <INDENT> nday_point = C * ( ( day + 1 ) - last_day ) <NEWLINE> S_nday = sum ( nday_point ) - C [ k ] * ( day - last_day [ k ] ) <NEWLINE> <NL> for i in range ( 26 ) : <NEWLINE> <INDENT> if k != i : <NEWLINE> <INDENT> nday_point [ i ] = score [ day + 1 ] [ i ] - S_nday + nday_point [ i ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> nday_point [ i ] = score [ day + 1 ] [ i ] - S_nday + C [ i ] <NEWLINE> <NL> <DEDENT> if today_point [ k ] + nday_point [ i ] > max_score : <NEWLINE> <INDENT> max_score = today_point [ k ] + nday_point [ i ] <NEWLINE> idx = k <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> idx = np . argmax ( today_point ) <NEWLINE> <NL> <DEDENT> last_day [ idx ] = day <NEWLINE> output [ day ] = idx + 1 <NEWLINE> <DEDENT> print ( * output ) <NEWLINE>
v <NEWLINE>
import random <NEWLINE> D = int ( input ( ) ) <NEWLINE> C = np . array ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> S = [ ] <NEWLINE> for _ in range ( D ) : <NEWLINE> <INDENT> S . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> <NL> <NL> <DEDENT> for i in range ( D ) : <NEWLINE> <INDENT> print ( random . randint ( 1 , 26 ) ) <NEWLINE> <DEDENT>
import random <NEWLINE> import time <NEWLINE> import copy <NEWLINE> <NL> def down_score ( d , c , last_d , score ) : <NEWLINE> <INDENT> sum = 0 <NEWLINE> for i in range ( 26 ) : <NEWLINE> <INDENT> sum = sum + c [ i ] * ( d - last_d [ i ] ) <NEWLINE> <NL> <DEDENT> return int ( score - sum ) <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> D = int ( input ( ) ) <NEWLINE> <NL> c = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> s = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( D ) ] <NEWLINE> <NL> start = time . time ( ) <NEWLINE> <NL> last_d = [ 0 for i in range ( 26 ) ] <NEWLINE> ans = [ ] <NEWLINE> score1 = 0 <NEWLINE> <NL> for i in range ( D ) : <NEWLINE> <INDENT> max = 0 <NEWLINE> idx = 0 <NEWLINE> for j in range ( 26 ) : <NEWLINE> <INDENT> if max < ( s [ i ] [ j ] + c [ j ] * ( i - last_d [ j ] ) * ( i - last_d [ j ] + 1 ) / 2 ) and c [ j ] != 0 : <NEWLINE> <INDENT> max = s [ i ] [ j ] + c [ j ] * ( i - last_d [ j ] ) * ( i - last_d [ j ] + 1 ) / 2 <NEWLINE> idx = j <NEWLINE> <DEDENT> elif max == ( s [ i ] [ j ] + c [ j ] * ( i - last_d [ j ] ) * ( i - last_d [ j ] + 1 ) / 2 ) and c [ j ] * ( i - last_d [ j ] ) * ( i - last_d [ j ] + 1 ) / 2 > c [ idx ] * ( i - last_d [ idx ] ) * ( i - last_d [ idx ] + 1 ) / 2 and c [ j ] != 0 : <NEWLINE> <INDENT> idx = j <NEWLINE> <NL> <DEDENT> <DEDENT> last_d [ idx ] = i + 1 <NEWLINE> score1 += s [ i ] [ idx ] <NEWLINE> score1 = down_score ( i + 1 , c , last_d , score1 ) <NEWLINE> <NL> ans . append ( idx ) <NEWLINE> <NL> <DEDENT> while time . time ( ) - start < 1.9 : <NEWLINE> <INDENT> cp = ans . copy ( ) <NEWLINE> last_d = [ 0 for i in range ( 26 ) ] <NEWLINE> score2 = 0 <NEWLINE> idx1 = random . randint ( 0 , 25 ) <NEWLINE> idx2 = random . randint ( 0 , 25 ) <NEWLINE> <NL> if random . randint ( 0 , 1 ) : <NEWLINE> <INDENT> d1 = random . randint ( 0 , D ) <NEWLINE> d2 = random . randint ( 0 , D ) <NEWLINE> <NL> if random . randint ( 0 , 1 ) : <NEWLINE> <INDENT> ans [ d1 ] = idx1 <NEWLINE> <DEDENT> elif random . randint ( 0 , 1 ) : <NEWLINE> <INDENT> ans [ d1 ] = idx1 <NEWLINE> ans [ d2 ] = idx2 <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> elif random . randint ( 0 , 1 ) : <NEWLINE> <INDENT> d1 = random . randint ( 0 , D - 8 ) <NEWLINE> d2 = random . randint ( d1 + 1 , d1 + 7 ) <NEWLINE> tmp1 = ans [ d1 ] <NEWLINE> tmp2 = ans [ d2 ] <NEWLINE> if random . randint ( 0 , 1 ) : <NEWLINE> <INDENT> ans [ d1 ] = tmp2 <NEWLINE> ans [ d2 ] = tmp1 <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> d1 = random . randint ( 0 , D - 11 ) <NEWLINE> d2 = random . randint ( d1 + 1 , d1 + 5 ) <NEWLINE> d3 = random . randint ( d2 + 1 , d2 + 5 ) <NEWLINE> tmp1 = ans [ d1 ] <NEWLINE> tmp2 = ans [ d2 ] <NEWLINE> tmp3 = ans [ d3 ] <NEWLINE> if random . randint ( 0 , 1 ) : <NEWLINE> <INDENT> ans [ d1 ] = tmp2 <NEWLINE> ans [ d2 ] = tmp3 <NEWLINE> ans [ d3 ] = tmp1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans [ d1 ] = tmp3 <NEWLINE> ans [ d2 ] = tmp1 <NEWLINE> ans [ d3 ] = tmp2 <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( D ) : <NEWLINE> <INDENT> score2 += s [ i ] [ ans [ i ] ] <NEWLINE> last_d [ ans [ i ] ] = i + 1 <NEWLINE> score2 = down_score ( i + 1 , c , last_d , score2 ) <NEWLINE> <NL> <DEDENT> if score1 > score2 : <NEWLINE> <INDENT> ans = cp . copy ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> score1 = score2 <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( D ) : <NEWLINE> <INDENT> print ( ans [ i ] + 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
d = int ( input ( ) ) <NEWLINE> c = { } <NEWLINE> s = [ ] <NEWLINE> C = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i in range ( 26 ) : <NEWLINE> <INDENT> c [ i ] = C [ i ] <NEWLINE> <DEDENT> for i in range ( d ) : <NEWLINE> <INDENT> s . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> <DEDENT> t = 0 <NEWLINE> while t < 365 : <NEWLINE> <INDENT> for i in range ( 26 ) : <NEWLINE> <INDENT> if t < 365 : <NEWLINE> <INDENT> t += 1 <NEWLINE> a = - 1 <NEWLINE> b = 0 <NEWLINE> for j in range ( 26 ) : <NEWLINE> <INDENT> if b < s [ t ] [ j ] : <NEWLINE> <INDENT> a = j <NEWLINE> b = s [ t ] [ j ] <NEWLINE> <DEDENT> <DEDENT> print ( a + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break ; <NEWLINE> <DEDENT> if t < 365 : <NEWLINE> <INDENT> t += 1 <NEWLINE> print ( 26 - i ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break ; <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
<COMMENT> <NL> import random <NEWLINE> random . seed ( 0 ) <NEWLINE> <NL> D = int ( input ( ) ) <NEWLINE> C = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> list_S = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( D ) ] <NEWLINE> <NL> answer = [ ] <NEWLINE> L = [ 0 for _ in range ( 26 ) ] <NEWLINE> for S in list_S : <NEWLINE> <INDENT> contest_index = - 1 <NEWLINE> contest_manzoku = - 10 ** 9 <NEWLINE> for i in range ( 26 ) : <NEWLINE> <INDENT> i_manzoku = S [ i ] + C [ i ] + L [ i ] <NEWLINE> if i_manzoku > contest_manzoku : <NEWLINE> <INDENT> contest_index = i <NEWLINE> contest_manzoku = i_manzoku <NEWLINE> <DEDENT> <DEDENT> answer . append ( contest_index ) <NEWLINE> for i in range ( 26 ) : <NEWLINE> <INDENT> if i == contest_index : <NEWLINE> <INDENT> L [ i ] = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> L [ i ] += C [ i ] <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> def manzoku ( A ) : <NEWLINE> <INDENT> score = 0 <NEWLINE> L = [ 0 for _ in range ( 26 ) ] <NEWLINE> for i in range ( D ) : <NEWLINE> <INDENT> contest_index = A [ i ] <NEWLINE> for j in range ( 26 ) : <NEWLINE> <INDENT> if j == contest_index : <NEWLINE> <INDENT> L [ j ] = 0 <NEWLINE> score += S [ i ] [ contest_index ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> L [ j ] += C [ j ] <NEWLINE> score -= L [ j ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return score <NEWLINE> <NL> <DEDENT> manzoku_now = manzoku ( answer ) <NEWLINE> answer_tmp = [ answer [ i ] for i in range ( D ) ] <NEWLINE> for j in range ( 365 ) : <NEWLINE> <INDENT> day = j % D <NEWLINE> contest = random . randrange ( 26 ) <NEWLINE> answer_tmp = [ answer [ i ] for i in range ( D ) ] <NEWLINE> answer_tmp [ day ] = contest <NEWLINE> manzoku_tmp = manzoku ( answer_tmp ) <NEWLINE> if manzoku_now < manzoku_tmp : <NEWLINE> <INDENT> manzoku_now = manzoku_tmp <NEWLINE> answer [ day ] = contest <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> answer_tmp [ day ] = answer [ day ] <NEWLINE> <NL> <DEDENT> <DEDENT> for index in answer : <NEWLINE> <INDENT> print ( index + 1 ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <NL> d = int ( input ( ) ) <NEWLINE> <NL> C = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> CB = [ 0 for i in range ( len ( C ) ) ] <NEWLINE> <NL> c = sum ( C ) <NEWLINE> <NL> total = 0 <NEWLINE> <NL> <COMMENT> <NL> L = [ ] <NEWLINE> <NL> for i in range ( d ) : <NEWLINE> <INDENT> L . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> <COMMENT> <NL> <NL> <DEDENT> T = [ ] <NEWLINE> <NL> for i in range ( d ) : <NEWLINE> <INDENT> T . append ( int ( input ( ) ) ) <NEWLINE> <NL> <COMMENT> <NL> <NL> <DEDENT> def cnt ( CB , t ) : <NEWLINE> <INDENT> for i in range ( len ( CB ) ) : <NEWLINE> <INDENT> if i != t - 1 : <NEWLINE> <INDENT> CB [ i ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> CB [ i ] = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> return CB <NEWLINE> <NL> <DEDENT> def sumA ( C , CB ) : <NEWLINE> <INDENT> a = 0 <NEWLINE> for i in range ( len ( CB ) ) : <NEWLINE> <INDENT> a += CB [ i ] * C [ i ] <NEWLINE> <DEDENT> return a <NEWLINE> <NL> <DEDENT> for i in range ( len ( T ) ) : <NEWLINE> <INDENT> CB = cnt ( CB , T [ i ] ) <NEWLINE> total += L [ i ] [ T [ i ] - 1 ] - sumA ( C , CB ) <NEWLINE> print ( total ) <NEWLINE> <NL> <NL> <NL> <DEDENT>
import os <NEWLINE> import sys <NEWLINE> <NL> import numpy as np <NEWLINE> <NL> <NL> def solve ( inp ) : <NEWLINE> <INDENT> def bitree_sum ( bit , t , i ) : <NEWLINE> <INDENT> s = 0 <NEWLINE> while i > 0 : <NEWLINE> <INDENT> s += bit [ t , i ] <NEWLINE> i ^= i & - i <NEWLINE> <DEDENT> return s <NEWLINE> <NL> <DEDENT> def bitree_add ( bit , n , t , i , x ) : <NEWLINE> <INDENT> while i <= n : <NEWLINE> <INDENT> bit [ t , i ] += x <NEWLINE> i += i & - i <NEWLINE> <NL> <DEDENT> <DEDENT> def bitree_lower_bound ( bit , n , d , t , x ) : <NEWLINE> <INDENT> sum_ = 0 <NEWLINE> pos = 0 <NEWLINE> for i in range ( d , - 1 , - 1 ) : <NEWLINE> <INDENT> k = pos + ( 1 << i ) <NEWLINE> if k <= n and sum_ + bit [ t , k ] < x : <NEWLINE> <INDENT> sum_ += bit [ t , k ] <NEWLINE> pos += 1 << i <NEWLINE> <DEDENT> <DEDENT> return pos + 1 <NEWLINE> <NL> <DEDENT> def initial_score ( d , ccc , sss ) : <NEWLINE> <INDENT> bit_n = d + 3 <NEWLINE> bit = np . zeros ( ( 26 , bit_n ) , dtype = np . int64 ) <NEWLINE> INF = 10 ** 18 <NEWLINE> for t in range ( 26 ) : <NEWLINE> <INDENT> bitree_add ( bit , bit_n , t , bit_n - 1 , INF ) <NEWLINE> <NL> <DEDENT> ttt = np . zeros ( d , dtype = np . int64 ) <NEWLINE> last = np . full ( 26 , - 1 , dtype = np . int64 ) <NEWLINE> score = 0 <NEWLINE> <NL> for i in range ( d ) : <NEWLINE> <INDENT> best_t = 0 <NEWLINE> best_diff = - INF <NEWLINE> costs = ccc * ( i - last ) <NEWLINE> costs_sum = costs . sum ( ) <NEWLINE> <NL> for t in range ( 26 ) : <NEWLINE> <INDENT> tmp_diff = sss [ i , t ] - costs_sum + costs [ t ] <NEWLINE> if best_diff < tmp_diff : <NEWLINE> <INDENT> best_t = t <NEWLINE> best_diff = tmp_diff <NEWLINE> <DEDENT> <DEDENT> ttt [ i ] = best_t <NEWLINE> last [ best_t ] = i <NEWLINE> score += best_diff <NEWLINE> bitree_add ( bit , bit_n , best_t , i + 2 , 1 ) <NEWLINE> <NL> <DEDENT> return bit , score , ttt <NEWLINE> <NL> <DEDENT> def calculate_score ( d , ccc , sss , ttt ) : <NEWLINE> <INDENT> last = np . full ( 26 , - 1 , dtype = np . int64 ) <NEWLINE> score = 0 <NEWLINE> <NL> for i in range ( d ) : <NEWLINE> <INDENT> t = ttt [ i ] <NEWLINE> last [ t ] = i <NEWLINE> score += sss [ i , t ] - ( ccc * ( i - last ) ) . sum ( ) <NEWLINE> <NL> <DEDENT> return score <NEWLINE> <NL> <DEDENT> def pinpoint_change ( bit , bit_n , bit_d , d , ccc , sss , ttt , permissible ) : <NEWLINE> <INDENT> cd = np . random . randint ( 0 , d ) <NEWLINE> ct = np . random . randint ( 0 , 26 ) <NEWLINE> while ttt [ cd ] == ct : <NEWLINE> <INDENT> ct = np . random . randint ( 0 , 26 ) <NEWLINE> <NL> <DEDENT> diff = 0 <NEWLINE> t = ttt [ cd ] <NEWLINE> k = bitree_sum ( bit , t , cd + 2 ) <NEWLINE> c = bitree_lower_bound ( bit , bit_n , bit_d , t , k - 1 ) - 2 <NEWLINE> e = bitree_lower_bound ( bit , bit_n , bit_d , t , k + 1 ) - 2 <NEWLINE> b = ccc [ t ] <NEWLINE> diff -= b * ( cd - c ) * ( e - cd ) <NEWLINE> diff -= sss [ cd , t ] <NEWLINE> <NL> k = bitree_sum ( bit , ct , cd + 2 ) <NEWLINE> c = bitree_lower_bound ( bit , bit_n , bit_d , ct , k ) - 2 <NEWLINE> e = bitree_lower_bound ( bit , bit_n , bit_d , ct , k + 1 ) - 2 <NEWLINE> b = ccc [ ct ] <NEWLINE> diff += b * ( cd - c ) * ( e - cd ) <NEWLINE> diff += sss [ cd , ct ] <NEWLINE> <NL> if diff > permissible : <NEWLINE> <INDENT> bitree_add ( bit , bit_n , t , cd + 2 , - 1 ) <NEWLINE> bitree_add ( bit , bit_n , ct , cd + 2 , 1 ) <NEWLINE> ttt [ cd ] = ct <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> diff = 0 <NEWLINE> <NL> <DEDENT> return diff <NEWLINE> <NL> <DEDENT> def swap_change ( bit , bit_n , bit_d , d , ccc , sss , ttt , permissible ) : <NEWLINE> <INDENT> cd1 = np . random . randint ( 0 , d - 1 ) <NEWLINE> cd2 = cd1 + 1 <NEWLINE> ct1 = ttt [ cd1 ] <NEWLINE> ct2 = ttt [ cd2 ] <NEWLINE> if ct1 == ct2 : <NEWLINE> <INDENT> return 0 <NEWLINE> <NL> <DEDENT> diff = 0 <NEWLINE> k = bitree_sum ( bit , ct1 , cd1 + 2 ) <NEWLINE> c = bitree_lower_bound ( bit , bit_n , bit_d , ct1 , k - 1 ) - 2 <NEWLINE> e = bitree_lower_bound ( bit , bit_n , bit_d , ct1 , k + 1 ) - 2 <NEWLINE> diff += ccc [ ct1 ] * ( e + c - cd1 - cd2 ) <NEWLINE> k = bitree_sum ( bit , ct2 , cd2 + 2 ) <NEWLINE> c = bitree_lower_bound ( bit , bit_n , bit_d , ct2 , k - 1 ) - 2 <NEWLINE> e = bitree_lower_bound ( bit , bit_n , bit_d , ct2 , k + 1 ) - 2 <NEWLINE> diff -= ccc [ ct2 ] * ( e + c - cd1 - cd2 ) <NEWLINE> diff -= sss [ cd1 , ct1 ] + sss [ cd2 , ct2 ] <NEWLINE> diff += sss [ cd1 , ct2 ] + sss [ cd2 , ct1 ] <NEWLINE> <NL> if diff > permissible : <NEWLINE> <INDENT> bitree_add ( bit , bit_n , ct1 , cd1 + 2 , - 1 ) <NEWLINE> bitree_add ( bit , bit_n , ct1 , cd2 + 2 , 1 ) <NEWLINE> bitree_add ( bit , bit_n , ct2 , cd1 + 2 , 1 ) <NEWLINE> bitree_add ( bit , bit_n , ct2 , cd2 + 2 , - 1 ) <NEWLINE> ttt [ cd1 ] = ct2 <NEWLINE> ttt [ cd2 ] = ct1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> diff = 0 <NEWLINE> <NL> <DEDENT> return diff <NEWLINE> <NL> <DEDENT> d = inp [ 0 ] <NEWLINE> ccc = inp [ 1 : 27 ] <NEWLINE> sss = np . zeros ( ( d , 26 ) , dtype = np . int64 ) <NEWLINE> for r in range ( d ) : <NEWLINE> <INDENT> sss [ r ] = inp [ 27 + r * 26 : 27 + ( r + 1 ) * 26 ] <NEWLINE> <NL> <DEDENT> bit , score , ttt = initial_score ( d , ccc , sss ) <NEWLINE> bit_n = d + 3 <NEWLINE> bit_d = int ( np . log2 ( bit_n ) ) <NEWLINE> loop = 6 * 10 ** 6 <NEWLINE> permissible_min = - 2000.0 <NEWLINE> method_border = 0.9 <NEWLINE> best_score = score <NEWLINE> best_ttt = ttt . copy ( ) <NEWLINE> <NL> for lp in range ( loop ) : <NEWLINE> <INDENT> permissible = ( 1 - lp / loop ) * permissible_min <NEWLINE> if np . random . random ( ) < method_border : <NEWLINE> <INDENT> diff = pinpoint_change ( bit , bit_n , bit_d , d , ccc , sss , ttt , permissible ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> diff = swap_change ( bit , bit_n , bit_d , d , ccc , sss , ttt , permissible ) <NEWLINE> <DEDENT> score += diff <NEWLINE> <NL> <COMMENT> <NL> <NL> if score > best_score : <NEWLINE> <INDENT> best_score = score <NEWLINE> best_ttt = ttt . copy ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> return best_ttt + 1 <NEWLINE> <NL> <NL> <DEDENT> if sys . argv [ - 1 ] == <STRING> : <NEWLINE> <INDENT> from numba . pycc import CC <NEWLINE> <NL> cc = CC ( <STRING> ) <NEWLINE> cc . export ( <STRING> , <STRING> ) ( solve ) <NEWLINE> cc . compile ( ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> if os . name == <STRING> : <NEWLINE> <COMMENT> <NL> <INDENT> from my_module import solve <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> from numba import njit <NEWLINE> <NL> solve = njit ( <STRING> , cache = True ) ( solve ) <NEWLINE> print ( <STRING> , file = sys . stderr ) <NEWLINE> <NL> <DEDENT> inp = np . fromstring ( sys . stdin . read ( ) , dtype = np . int64 , sep = <STRING> ) <NEWLINE> ans = solve ( inp ) <NEWLINE> print ( <STRING> . join ( map ( str , ans ) ) ) <NEWLINE>
import sys <NEWLINE> from random import randint <NEWLINE> from datetime import datetime <NEWLINE> <NL> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> def ii ( ) : return int ( input ( ) ) <NEWLINE> def mi ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def lmi ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> def lmif ( n ) : return [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ] <NEWLINE> <NL> def randomize ( n ) : <NEWLINE> <INDENT> return [ randint ( 1 , 26 ) for _ in range ( n ) ] <NEWLINE> <NL> <DEDENT> def get_now ( ) : <NEWLINE> <INDENT> dt = datetime . now ( ) <NEWLINE> return dt . second + dt . microsecond / 1000000 <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> start = get_now ( ) <NEWLINE> end = get_now ( ) <NEWLINE> <COMMENT> <NL> D = ii ( ) <NEWLINE> <COMMENT> <NL> C = lmi ( ) <NEWLINE> <COMMENT> <NL> S = lmif ( D ) <NEWLINE> <COMMENT> <NL> T = [ randomize ( D ) ] <NEWLINE> <NL> def scoring ( ) : <NEWLINE> <COMMENT> <NL> <INDENT> last = [ 0 ] * 26 <NEWLINE> score = 0 <NEWLINE> for i in range ( D ) : <NEWLINE> <INDENT> score += S [ i ] [ T [ i ] - 1 ] <NEWLINE> last [ T [ i ] - 1 ] = i + 1 <NEWLINE> for j in range ( 26 ) : <NEWLINE> <INDENT> score -= C [ j ] * ( i + 1 - last [ j ] ) <NEWLINE> <DEDENT> <DEDENT> return score <NEWLINE> <NL> <DEDENT> max_score = scoring ( ) <NEWLINE> <COMMENT> <NL> ans = T . copy ( ) <NEWLINE> <COMMENT> <NL> while end - start < 1.95 : <NEWLINE> <INDENT> idx , value = randint ( 0 , D - 1 ) , randint ( 1 , 26 ) <NEWLINE> old = T [ idx ] <NEWLINE> T [ idx ] = value <NEWLINE> score = scoring ( ) <NEWLINE> if max_score < score : <NEWLINE> <INDENT> ans = T . copy ( ) <NEWLINE> max_score = score <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> T [ idx ] = old <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> end = get_now ( ) <NEWLINE> <DEDENT> print ( * ans , sep = <STRING> ) <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE>
import os <NEWLINE> import sys <NEWLINE> <NL> import numpy as np <NEWLINE> <NL> <NL> def solve ( inp ) : <NEWLINE> <INDENT> def bitree_sum ( bit , t , i ) : <NEWLINE> <INDENT> s = 0 <NEWLINE> while i > 0 : <NEWLINE> <INDENT> s += bit [ t , i ] <NEWLINE> i ^= i & - i <NEWLINE> <DEDENT> return s <NEWLINE> <NL> <DEDENT> def bitree_add ( bit , n , t , i , x ) : <NEWLINE> <INDENT> while i <= n : <NEWLINE> <INDENT> bit [ t , i ] += x <NEWLINE> i += i & - i <NEWLINE> <NL> <DEDENT> <DEDENT> def bitree_lower_bound ( bit , n , d , t , x ) : <NEWLINE> <INDENT> sum_ = 0 <NEWLINE> pos = 0 <NEWLINE> for i in range ( d , - 1 , - 1 ) : <NEWLINE> <INDENT> k = pos + ( 1 << i ) <NEWLINE> if k <= n and sum_ + bit [ t , k ] < x : <NEWLINE> <INDENT> sum_ += bit [ t , k ] <NEWLINE> pos += 1 << i <NEWLINE> <DEDENT> <DEDENT> return pos + 1 <NEWLINE> <NL> <DEDENT> def initial_score ( d , ccc , sss , ttt ) : <NEWLINE> <INDENT> bit_n = d + 3 <NEWLINE> bit = np . zeros ( ( 26 , bit_n ) , dtype = np . int64 ) <NEWLINE> INF = 10 ** 18 <NEWLINE> for t in range ( 26 ) : <NEWLINE> <INDENT> bitree_add ( bit , bit_n , t , bit_n - 1 , INF ) <NEWLINE> <NL> <DEDENT> last = np . full ( 26 , - 1 , dtype = np . int64 ) <NEWLINE> score = 0 <NEWLINE> <NL> for i in range ( d ) : <NEWLINE> <INDENT> t = ttt [ i ] <NEWLINE> score += sss [ i , t ] <NEWLINE> for u in range ( 26 ) : <NEWLINE> <INDENT> if u == t : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> score -= ccc [ u ] * ( i - last [ u ] ) <NEWLINE> <DEDENT> last [ t ] = i <NEWLINE> bitree_add ( bit , bit_n , t , i + 2 , 1 ) <NEWLINE> <NL> <DEDENT> return bit , score <NEWLINE> <NL> <DEDENT> def update_score ( bit , bit_n , bit_d , ccc , sss , ttt , d , q ) : <NEWLINE> <INDENT> diff = 0 <NEWLINE> t = ttt [ d ] <NEWLINE> k = bitree_sum ( bit , t , d + 2 ) <NEWLINE> c = bitree_lower_bound ( bit , bit_n , bit_d , t , k - 1 ) - 2 <NEWLINE> e = bitree_lower_bound ( bit , bit_n , bit_d , t , k + 1 ) - 2 <NEWLINE> b = ccc [ t ] <NEWLINE> diff -= b * ( d - c ) * ( e - d ) <NEWLINE> diff -= sss [ d , t ] <NEWLINE> <NL> k = bitree_sum ( bit , q , d + 2 ) <NEWLINE> c = bitree_lower_bound ( bit , bit_n , bit_d , q , k ) - 2 <NEWLINE> e = bitree_lower_bound ( bit , bit_n , bit_d , q , k + 1 ) - 2 <NEWLINE> b = ccc [ q ] <NEWLINE> diff += b * ( d - c ) * ( e - d ) <NEWLINE> diff += sss [ d , q ] <NEWLINE> <NL> return diff <NEWLINE> <NL> <DEDENT> d = inp [ 0 ] <NEWLINE> ccc = inp [ 1 : 27 ] <NEWLINE> sss = np . zeros ( ( d , 26 ) , dtype = np . int64 ) <NEWLINE> for r in range ( d ) : <NEWLINE> <INDENT> sss [ r ] = inp [ 27 + r * 26 : 27 + ( r + 1 ) * 26 ] <NEWLINE> <NL> <DEDENT> ttt = np . random . choice ( 26 , d ) + 1 <NEWLINE> <NL> bit , score = initial_score ( d , ccc , sss , ttt ) <NEWLINE> bit_n = d + 3 <NEWLINE> bit_d = int ( np . log2 ( bit_n ) ) <NEWLINE> <NL> for _ in range ( 10 ** 5 ) : <NEWLINE> <INDENT> cd = np . random . randint ( 0 , d ) <NEWLINE> ct = np . random . randint ( 0 , 26 ) <NEWLINE> diff = update_score ( bit , bit_n , bit_d , ccc , sss , ttt , cd , ct ) <NEWLINE> if diff > 0 : <NEWLINE> <INDENT> score += diff <NEWLINE> bitree_add ( bit , bit_n , ttt [ cd ] - 1 , cd + 2 , - 1 ) <NEWLINE> bitree_add ( bit , bit_n , ct , cd + 2 , 1 ) <NEWLINE> ttt [ cd ] = ct + 1 <NEWLINE> <NL> <DEDENT> <DEDENT> return ttt <NEWLINE> <NL> <NL> <DEDENT> if sys . argv [ - 1 ] == <STRING> : <NEWLINE> <INDENT> from numba . pycc import CC <NEWLINE> <NL> cc = CC ( <STRING> ) <NEWLINE> cc . export ( <STRING> , <STRING> ) ( solve ) <NEWLINE> cc . compile ( ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> if os . name == <STRING> : <NEWLINE> <COMMENT> <NL> <INDENT> from my_module import solve <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> from numba import njit <NEWLINE> <NL> solve = njit ( <STRING> , cache = True ) ( solve ) <NEWLINE> print ( <STRING> , file = sys . stderr ) <NEWLINE> <NL> <DEDENT> inp = np . fromstring ( sys . stdin . read ( ) , dtype = np . int64 , sep = <STRING> ) <NEWLINE> ans = solve ( inp ) <NEWLINE> print ( <STRING> . join ( map ( str , ans ) ) ) <NEWLINE>
<COMMENT> <NL> import time <NEWLINE> s__ = time . time ( ) <NEWLINE> limit = 1.9 <NEWLINE> <COMMENT> <NL> <NL> from numba import njit <NEWLINE> import numpy as np <NEWLINE> <NL> d = int ( input ( ) ) <NEWLINE> cs = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> cs = np . array ( cs , dtype = np . int64 ) <NEWLINE> sm = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( d ) ] <NEWLINE> sm = np . array ( sm , dtype = np . int64 ) <NEWLINE> <NL> @ njit ( <STRING> , cache = True ) <NEWLINE> def total_satisfaction ( ts , d ) : <NEWLINE> <INDENT> ls = np . zeros ( 26 , dtype = np . int64 ) <NEWLINE> s = 0 <NEWLINE> for i in range ( d ) : <NEWLINE> <INDENT> t = ts [ i ] <NEWLINE> t -= 1 <NEWLINE> s += sm [ i ] [ t ] <NEWLINE> ls [ t ] = i + 1 <NEWLINE> <NL> dv = cs * ( ( i + 1 ) - ls ) <NEWLINE> s -= dv . sum ( ) <NEWLINE> <DEDENT> return s <NEWLINE> <NL> <DEDENT> @ njit ( <STRING> , cache = True ) <NEWLINE> def greedy ( ) : <NEWLINE> <INDENT> ts = np . array ( [ 0 ] * d , dtype = np . int64 ) <NEWLINE> for i in range ( d ) : <NEWLINE> <INDENT> mx = - 1e10 <NEWLINE> mxt = None <NEWLINE> for t in range ( 1 , 26 + 1 ) : <NEWLINE> <INDENT> ts [ i ] = t <NEWLINE> s = total_satisfaction ( ts , i + 1 ) <NEWLINE> if s > mx : <NEWLINE> <INDENT> mx = s <NEWLINE> mxt = t <NEWLINE> <DEDENT> <DEDENT> ts [ i ] = mxt <NEWLINE> <DEDENT> return ts <NEWLINE> <NL> <DEDENT> @ njit ( <STRING> , cache = True ) <NEWLINE> def loop ( mxsc , ts ) : <NEWLINE> <INDENT> it = 200 <NEWLINE> rds = np . random . randint ( 0 , 6 , ( it , ) ) <NEWLINE> rdd = np . random . randint ( 1 , d , ( it , ) ) <NEWLINE> rdq = np . random . randint ( 1 , 26 , ( it , ) ) <NEWLINE> rdx = np . random . randint ( 1 , 12 , ( it , ) ) <NEWLINE> rdy = np . random . randint ( 1 , 12 , ( it , ) ) <NEWLINE> c1 = 0 <NEWLINE> c2 = 3 <NEWLINE> for i in range ( it ) : <NEWLINE> <INDENT> bk1 = 0 <NEWLINE> bk2 = 0 <NEWLINE> bk3 = 0 <NEWLINE> if rds [ 0 ] <= c1 : <NEWLINE> <COMMENT> <NL> <INDENT> di = rdd [ i ] <NEWLINE> qi = rdq [ i ] <NEWLINE> <NL> bk1 = ts [ di ] <NEWLINE> ts [ di ] = qi <NEWLINE> <DEDENT> elif rds [ 0 ] <= c2 : <NEWLINE> <COMMENT> <NL> <INDENT> di = rdd [ i ] <NEWLINE> xi = rdx [ i ] <NEWLINE> if di + xi >= d : <NEWLINE> <INDENT> xi = di - xi <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> xi = di + xi <NEWLINE> <NL> <DEDENT> bk1 = ts [ di ] <NEWLINE> bk2 = ts [ xi ] <NEWLINE> ts [ di ] = bk2 <NEWLINE> ts [ xi ] = bk1 <NEWLINE> <DEDENT> else : <NEWLINE> <COMMENT> <NL> <INDENT> di = rdd [ i ] <NEWLINE> xi = rdx [ i ] <NEWLINE> if di + xi >= d : <NEWLINE> <INDENT> xi = di - xi <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> xi = di + xi <NEWLINE> <DEDENT> yi = rdy [ i ] <NEWLINE> if xi + yi >= d : <NEWLINE> <INDENT> yi = xi - yi <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> yi = xi + yi <NEWLINE> <NL> <DEDENT> bk1 = ts [ di ] <NEWLINE> bk2 = ts [ xi ] <NEWLINE> bk3 = ts [ yi ] <NEWLINE> ts [ di ] = bk2 <NEWLINE> ts [ xi ] = bk3 <NEWLINE> ts [ yi ] = bk1 <NEWLINE> <NL> <DEDENT> sc = total_satisfaction ( ts , d ) <NEWLINE> <NL> if sc > mxsc : <NEWLINE> <COMMENT> <NL> <INDENT> mxsc = sc <NEWLINE> <DEDENT> else : <NEWLINE> <COMMENT> <NL> <INDENT> if rds [ 0 ] <= c1 : <NEWLINE> <INDENT> ts [ di ] = bk1 <NEWLINE> <DEDENT> elif rds [ 0 ] <= c2 : <NEWLINE> <INDENT> ts [ di ] = bk1 <NEWLINE> ts [ xi ] = bk2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ts [ di ] = bk1 <NEWLINE> ts [ xi ] = bk2 <NEWLINE> ts [ yi ] = bk3 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> return mxsc <NEWLINE> <NL> <DEDENT> ts = greedy ( ) <NEWLINE> mxsc = total_satisfaction ( ts , d ) <NEWLINE> mxbk = mxsc <NEWLINE> <NL> s_ = time . time ( ) <NEWLINE> mxsc = loop ( mxsc , ts ) <NEWLINE> e_ = time . time ( ) <NEWLINE> <NL> consume = s_ - s__ <NEWLINE> elapsed = e_ - s_ <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> if consume < limit : <NEWLINE> <INDENT> lp = int ( ( limit - consume ) / elapsed ) <NEWLINE> <COMMENT> <NL> for _ in range ( lp ) : <NEWLINE> <INDENT> mxsc = loop ( mxsc , ts ) <NEWLINE> <NL> <DEDENT> <DEDENT> for t in ts : print ( t ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL>
import random <NEWLINE> <NL> D = int ( input ( ) ) <NEWLINE> C = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> S = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( D ) ] <NEWLINE> L = [ 0 for i in range ( 26 ) ] <NEWLINE> T = [ int ( input ( ) ) for i in range ( D ) ] <NEWLINE> <NL> def calc ( T ) : <NEWLINE> <INDENT> score = 0 <NEWLINE> for d in range ( D ) : <NEWLINE> <INDENT> score += S [ d ] [ T [ d ] - 1 ] <NEWLINE> <NL> L [ T [ d ] - 1 ] = d + 1 <NEWLINE> down = 0 <NEWLINE> for i in range ( 26 ) : <NEWLINE> <INDENT> down += C [ i ] * ( ( d + 1 ) - L [ i ] ) <NEWLINE> <NL> <DEDENT> score -= down <NEWLINE> <DEDENT> return score <NEWLINE> <NL> <DEDENT> max_score = 0 <NEWLINE> bestT = [ ] <NEWLINE> <NL> for i in range ( 10 ) : <NEWLINE> <INDENT> T = [ random . randrange ( 1 , 26 ) for i in range ( D ) ] <NEWLINE> score = calc ( T ) <NEWLINE> if score > max_score : <NEWLINE> <INDENT> bestT = T <NEWLINE> max_score = score <NEWLINE> <NL> <DEDENT> <DEDENT> for t in T : <NEWLINE> <INDENT> print ( t ) <NEWLINE> <DEDENT>
D = int ( input ( ) ) <NEWLINE> c = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> s = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( D ) ] <NEWLINE> a = 0 <NEWLINE> c = 0 <NEWLINE> for i in range ( 26 ) : <NEWLINE> <INDENT> b = 0 <NEWLINE> for j in range ( D ) : <NEWLINE> <INDENT> b += s [ i ] [ j ] <NEWLINE> <DEDENT> b -= c [ i ] * ( D - 1 ) <NEWLINE> if a <= b : <NEWLINE> <INDENT> c = i <NEWLINE> <DEDENT> <DEDENT> for i in range ( D ) : <NEWLINE> <INDENT> if i != D - 1 : <NEWLINE> <INDENT> print ( c + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> p = 0 <NEWLINE> q = 0 <NEWLINE> for j in range ( 26 ) : <NEWLINE> <INDENT> if p <= s [ D - 1 ] [ j ] : <NEWLINE> <INDENT> p = s [ D - 1 ] [ j ] <NEWLINE> q = j <NEWLINE> <DEDENT> <DEDENT> print ( j + 1 ) <NEWLINE> <DEDENT> <DEDENT>
import random <NEWLINE> <NL> def AtCoderContestScheduling ( ) : <NEWLINE> <NL> <INDENT> Day = int ( input ( ) ) <NEWLINE> value_A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> SatisfactionLevel = [ 0 ] * 26 <NEWLINE> <NL> for num in range ( Day ) : <NEWLINE> <NL> <INDENT> value_B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if num == 0 : <NEWLINE> <INDENT> SatisfactionLevel = [ x + y for ( x , y ) in zip ( SatisfactionLevel , value_B ) ] <NEWLINE> SumA = sum ( value_A ) <NEWLINE> SatisfactionLevel = [ x - SumA + y for ( x , y ) in zip ( SatisfactionLevel , value_A ) ] <NEWLINE> <NL> print ( SatisfactionLevel . index ( max ( SatisfactionLevel ) ) + 1 ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> SatisfactionLevel = [ x + y for ( x , y ) in zip ( SatisfactionLevel , value_B ) ] <NEWLINE> value_A_1 = value_A [ value_A . index ( max ( value_A ) ) ] = 0 <NEWLINE> SumA = sum ( value_A ) <NEWLINE> SatisfactionLevel = [ x - ( num + 1 ) * SumA + 2 * y + z for ( x , y , z ) in zip ( SatisfactionLevel , value_A , value_A_1 ) ] <NEWLINE> <NL> print ( SatisfactionLevel . index ( max ( SatisfactionLevel ) ) + 1 ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> AtCoderContestScheduling ( ) <NEWLINE> <NL> <NL> <DEDENT>
import numpy <NEWLINE> <NL> <NL> d = int ( input ( ) ) <NEWLINE> c = numpy . array ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> s = [ ] <NEWLINE> for i in range ( d ) : <NEWLINE> <INDENT> s . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> <DEDENT> result = [ ] <NEWLINE> past = numpy . array ( [ 0 ] * 26 ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( d ) : <NEWLINE> <INDENT> past += 1 <NEWLINE> t = int ( input ( ) ) <NEWLINE> past [ t - 1 ] = 0 <NEWLINE> ans += sum ( past * - c ) + s [ i ] [ t - 1 ] <NEWLINE> print ( ans ) <NEWLINE> <DEDENT>
import random <NEWLINE> for i in range ( 365 ) : <NEWLINE> <INDENT> print ( randint ( 1 , 26 ) ) <NEWLINE> <DEDENT>
for i in range ( D ) : <NEWLINE> <INDENT> print ( i % 26 + 1 ) <NEWLINE> <DEDENT>
D = int ( input ( ) ) <NEWLINE> N = 26 <NEWLINE> c = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> last = [ 0 for i in range ( N ) ] <NEWLINE> bias = 1.5 <NEWLINE> <NL> for i in range ( D ) : <NEWLINE> <INDENT> s_d = [ int ( j ) for j in input ( ) . split ( ) ] <NEWLINE> d_score = - 1 <NEWLINE> ans = - 1 <NEWLINE> for j in range ( N ) : <NEWLINE> <INDENT> last_day = ( i + 1 - last [ j ] ) * bias <NEWLINE> arg = s_d [ j ] + c [ j ] * last_day <NEWLINE> if d_score < arg : <NEWLINE> <INDENT> d_score = arg <NEWLINE> ans = j + 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> test += s_d [ ans - 1 ] <NEWLINE> last [ ans - 1 ] = i + 1 <NEWLINE> <DEDENT>
from random import randint <NEWLINE> <NL> D = int ( input ( ) ) <NEWLINE> C = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> S = [ [ int ( i ) for i in input ( ) . split ( ) ] for j in range ( D ) ] <NEWLINE> <NL> def score_calc ( T ) : <NEWLINE> <INDENT> total = 0 <NEWLINE> last = [ 0 ] * 26 <NEWLINE> for i in range ( 1 , D + 1 ) : <NEWLINE> <INDENT> t = T [ i - 1 ] <NEWLINE> total += S [ i - 1 ] [ t - 1 ] <NEWLINE> last [ t - 1 ] = i <NEWLINE> for j in range ( 26 ) : <NEWLINE> <INDENT> total -= C [ j ] * ( i - last [ j ] ) <NEWLINE> <DEDENT> <DEDENT> return total <NEWLINE> <NL> <DEDENT> total = 0 <NEWLINE> last = [ 0 ] * 26 <NEWLINE> ans = [ ] <NEWLINE> for i in range ( 1 , D + 1 ) : <NEWLINE> <INDENT> score = [ 0 ] * 26 <NEWLINE> for t in range ( 26 ) : <NEWLINE> <INDENT> score [ t ] += S [ i - 1 ] [ t ] <NEWLINE> for j in range ( 26 ) : <NEWLINE> <INDENT> if j != t : <NEWLINE> <INDENT> score [ t ] -= C [ j ] * ( i - last [ j ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> total += max ( score ) <NEWLINE> last [ score . index ( max ( score ) ) ] = i <NEWLINE> ans . append ( score . index ( max ( score ) ) + 1 ) <NEWLINE> <NL> <DEDENT> N = 1000 <NEWLINE> Q = [ [ randint ( 0 , 364 ) , randint ( 0 , 25 ) ] for i in range ( N ) ] <NEWLINE> for d , q in Q : <NEWLINE> <INDENT> old = ans [ d ] <NEWLINE> ans [ d ] = q + 1 <NEWLINE> if score_calc ( ans ) > total : <NEWLINE> <INDENT> total = score_calc ( ans ) : <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans [ d ] = old <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( D ) : <NEWLINE> <INDENT> print ( ans [ i ] ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> <COMMENT> <NL> <NL> from collections import defaultdict <NEWLINE> from heapq import heappush , heappop <NEWLINE> import sys <NEWLINE> import numpy as np <NEWLINE> from random import random <NEWLINE> <NL> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> input = sys . stdin . buffer . readline <NEWLINE> INF = 10 ** 9 + 1 <COMMENT> <NEWLINE> <NL> <NL> def debug ( * x ) : <NEWLINE> <INDENT> print ( * x ) <NEWLINE> <NL> <NL> <DEDENT> def solve ( D , CS , S ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> for i in range ( D ) : <NEWLINE> <INDENT> print ( S [ i ] . argmax ( ) + 1 ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def solve2 ( D , CS , S ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> last = [ - 1 ] * 26 <NEWLINE> for i in range ( D ) : <NEWLINE> <INDENT> dscore = np . zeros ( 26 ) <NEWLINE> for j in range ( 26 ) : <NEWLINE> <INDENT> dscore [ j ] += S [ i , j ] <NEWLINE> dscore [ j ] -= sum ( CS [ k ] * ( i - last [ k ] ) <NEWLINE> <INDENT> for k in range ( 26 ) if j != k ) <NEWLINE> <NL> <DEDENT> <DEDENT> j = dscore . argmax ( ) <NEWLINE> print ( j + 1 ) <NEWLINE> last [ j ] = i <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def solve3 ( D , CS , S ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> from time import perf_counter <NEWLINE> time = perf_counter ( ) <NEWLINE> <NL> bestscore = 0 <NEWLINE> bestanswer = None <NEWLINE> while perf_counter ( ) - time < 1.5 : <NEWLINE> <INDENT> answer = [ ] <NEWLINE> last = [ - 1 ] * 26 <NEWLINE> for i in range ( D ) : <NEWLINE> <INDENT> dscore = np . zeros ( 26 ) <NEWLINE> if random ( ) > 0.9 : <NEWLINE> <NL> <INDENT> for j in range ( 26 ) : <NEWLINE> <INDENT> dscore [ j ] += S [ i , j ] <NEWLINE> dscore [ j ] -= sum ( CS [ k ] * ( i - last [ k ] ) <NEWLINE> <INDENT> for k in range ( 26 ) if j != k ) <NEWLINE> <NL> <DEDENT> <DEDENT> j = dscore . argmax ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> j = int ( random ( ) * 26 ) <NEWLINE> <DEDENT> answer . append ( j + 1 ) <NEWLINE> last [ j ] = i <NEWLINE> <DEDENT> s = calcScore ( answer , D , CS , S ) <NEWLINE> if s > bestscore : <NEWLINE> <INDENT> bestscore = s <NEWLINE> bestanswer = answer <NEWLINE> <DEDENT> <DEDENT> print ( * answer , sep = <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> def solve4 ( D , CS , S ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> from time import perf_counter <NEWLINE> time = perf_counter ( ) <NEWLINE> <NL> bestscore = 0 <NEWLINE> bestanswer = None <NEWLINE> ORIG_S = S . astype ( np . float ) <NEWLINE> while perf_counter ( ) - time < 1.5 : <NEWLINE> <INDENT> answer = [ ] <NEWLINE> last = [ - 1 ] * 26 <NEWLINE> k1 = random ( ) <NEWLINE> k2 = random ( ) * k1 <NEWLINE> S = ORIG_S . copy ( ) <NEWLINE> S [ : - 1 ] += k1 * ORIG_S [ 1 : ] <NEWLINE> S [ : - 2 ] += k2 * ORIG_S [ 2 : ] <NEWLINE> for i in range ( D ) : <NEWLINE> <INDENT> dscore = np . zeros ( 26 ) <NEWLINE> for j in range ( 26 ) : <NEWLINE> <INDENT> dscore [ j ] += S [ i , j ] <NEWLINE> dscore [ j ] -= sum ( CS [ k ] * ( i - last [ k ] ) <NEWLINE> <INDENT> for k in range ( 26 ) if j != k ) <NEWLINE> <NL> <DEDENT> <DEDENT> j = dscore . argmax ( ) <NEWLINE> answer . append ( j + 1 ) <NEWLINE> last [ j ] = i <NEWLINE> <DEDENT> s = calcScore ( answer , D , CS , S ) <NEWLINE> if s > bestscore : <NEWLINE> <INDENT> bestscore = s <NEWLINE> bestanswer = answer <NEWLINE> <DEDENT> <DEDENT> print ( * answer , sep = <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> def calcScore ( answer , D , CS , S ) : <NEWLINE> <INDENT> last = [ - 1 ] * 26 <NEWLINE> score = 0 <NEWLINE> for i in range ( D ) : <NEWLINE> <INDENT> j = answer [ i ] - 1 <NEWLINE> score += S [ i , j ] <NEWLINE> last [ j ] = i <NEWLINE> score -= sum ( CS [ j ] * ( i - last [ j ] ) for j in range ( 26 ) ) <NEWLINE> <DEDENT> return score <NEWLINE> <NL> <NL> <DEDENT> def solve ( ) : <NEWLINE> <INDENT> pass <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> D = int ( input ( ) ) <NEWLINE> CS = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> S = np . int16 ( read ( ) . split ( ) ) <NEWLINE> S = S . reshape ( ( D , 26 ) ) <NEWLINE> <NL> <COMMENT> <NL> solve ( D , CS , S ) <NEWLINE> <NL> <NL> <DEDENT> T = <STRING> <NEWLINE> <NL> OUT = <STRING> <NEWLINE> <NL> <NL> def _test ( ) : <NEWLINE> <INDENT> import doctest <NEWLINE> doctest . testmod ( ) <NEWLINE> as_input ( T ) <NEWLINE> main ( ) <NEWLINE> <NL> <NL> <DEDENT> def as_input ( s ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> import io <NEWLINE> global read , input <NEWLINE> f = io . StringIO ( s . strip ( ) ) <NEWLINE> input = f . readline <NEWLINE> read = f . read <NEWLINE> <NL> <NL> <DEDENT> USE_NUMBA = False <NEWLINE> if ( USE_NUMBA and sys . argv [ - 1 ] == <STRING> ) or sys . argv [ - 1 ] == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> from numba . pycc import CC <NEWLINE> cc = CC ( <STRING> ) <NEWLINE> cc . export ( <STRING> , solve . __doc__ . strip ( ) . split ( ) [ 0 ] ) ( solve ) <NEWLINE> cc . compile ( ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> input = sys . stdin . buffer . readline <NEWLINE> read = sys . stdin . buffer . read <NEWLINE> <NL> if ( USE_NUMBA and sys . argv [ - 1 ] != <STRING> ) or sys . argv [ - 1 ] == <STRING> : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <INDENT> from my_module import solve <COMMENT> <NEWLINE> <DEDENT> elif sys . argv [ - 1 ] == <STRING> : <NEWLINE> <INDENT> _test ( ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> elif sys . argv [ - 1 ] != <STRING> and len ( sys . argv ) == 2 : <NEWLINE> <COMMENT> <NL> <INDENT> input_as_file = open ( sys . argv [ 1 ] ) <NEWLINE> input = input_as_file . buffer . readline <NEWLINE> read = input_as_file . buffer . read <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE> <DEDENT>
answerL = [ ] <NEWLINE> for i in range ( D ) : <NEWLINE> <INDENT> listS = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> maxi = min ( listS ) <NEWLINE> target = listS . index ( maxi ) <NEWLINE> answerL . append ( target + 1 ) <NEWLINE> <DEDENT> for ans in answerL : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
import random <NEWLINE> <NL> ans = [ random . randint ( 1 , 26 ) for i in range ( D ) ] <NEWLINE> print ( <STRING> . join ( map ( str , ans ) ) ) <NEWLINE>
import sys <NEWLINE> import numpy as np <NEWLINE> import numba <NEWLINE> from numba import njit <NEWLINE> <NL> read = sys . stdin . buffer . read <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> readlines = sys . stdin . buffer . readlines <NEWLINE> <NL> i4 = numba . int32 <NEWLINE> <NL> def get_input ( ) : <NEWLINE> <INDENT> D = int ( readline ( ) ) <NEWLINE> C = np . array ( readline ( ) . split ( ) , np . int32 ) <NEWLINE> S = np . array ( [ readline ( ) . split ( ) for _ in range ( D ) ] , np . int32 ) <NEWLINE> return D , C , S <NEWLINE> <NL> <DEDENT> @ njit ( ( i4 , i4 [ : ] , i4 [ : , : ] , i4 [ : ] ) , cache = True ) <NEWLINE> def first_computation ( D , C , S , T ) : <NEWLINE> <INDENT> x = 0 <NEWLINE> last = np . zeros ( ( 26 , D ) , np . int32 ) <NEWLINE> for d in range ( D ) : <NEWLINE> <INDENT> if d : <NEWLINE> <INDENT> last [ : , d ] = last [ : , d - 1 ] <NEWLINE> <DEDENT> i = T [ d ] <NEWLINE> x += S [ d , i ] <NEWLINE> last [ i , d ] = d + 1 <NEWLINE> for i in range ( 26 ) : <NEWLINE> <INDENT> x -= C [ i ] * ( d + 1 - last [ i , d ] ) <NEWLINE> <DEDENT> <DEDENT> return last , x <NEWLINE> <NL> <DEDENT> @ njit ( ( i4 , i4 [ : ] , i4 [ : , : ] , i4 [ : ] , i4 [ : , : ] , i4 , i4 ) , cache = True ) <NEWLINE> def difference_update ( D , C , S , T , last_day , d , q ) : <NEWLINE> <INDENT> p = T [ d ] <NEWLINE> T [ d ] = q <NEWLINE> x = S [ d , q ] - S [ d , p ] <NEWLINE> <NL> i = np . searchsorted ( last_day [ p ] , d + 1 ) <NEWLINE> d_p = last_day [ p , i - 1 ] if i >= 1 else 0 <NEWLINE> coef = 0 <NEWLINE> for k in range ( d , D ) : <NEWLINE> <INDENT> if last_day [ p , k ] == d + 1 : <NEWLINE> <COMMENT> <NL> <INDENT> coef += d_p - d - 1 <NEWLINE> last_day [ p , k ] = d_p <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> x += coef * C [ p ] <NEWLINE> <NL> coef = 0 <NEWLINE> for k in range ( d , D ) : <NEWLINE> <INDENT> if last_day [ q , k ] < d + 1 : <NEWLINE> <INDENT> coef += ( d + 1 - last_day [ q , k ] ) <NEWLINE> last_day [ q , k ] = d + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> x += coef * C [ q ] <NEWLINE> return x <NEWLINE> <NL> <DEDENT> def output ( T ) : <NEWLINE> <INDENT> T += 1 <NEWLINE> print ( * T , sep = <STRING> ) <NEWLINE> <NL> <DEDENT> @ njit ( ( i4 , i4 [ : ] , i4 [ : , : ] , i4 [ : ] , i4 [ : , : ] ) , cache = True ) <NEWLINE> def random_update ( D , C , S , T , last_days ) : <NEWLINE> <INDENT> d = np . random . randint ( 0 , D , 1 ) [ 0 ] <NEWLINE> p = T [ d ] <NEWLINE> xcum = 0 <NEWLINE> for q in range ( 26 ) : <NEWLINE> <INDENT> if p == q : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> xcum += difference_update ( D , C , S , T , last_days , d , q ) <NEWLINE> if xcum > 0 : <NEWLINE> <INDENT> return q , xcum <NEWLINE> <DEDENT> <DEDENT> difference_update ( D , C , S , T , last_days , d , p ) <NEWLINE> return p , 0 <NEWLINE> <NL> <DEDENT> @ njit ( ( i4 , i4 [ : ] , i4 [ : , : ] , i4 [ : ] , i4 [ : , : ] ) , cache = True ) <NEWLINE> def main ( D , C , S , T , last_days ) : <NEWLINE> <INDENT> x = 0 <NEWLINE> for _ in range ( 5 * 10 ** 5 ) : <NEWLINE> <INDENT> x += random_update ( D , C , S , T , last_days ) [ 1 ] <NEWLINE> <DEDENT> return T , x <NEWLINE> <NL> <DEDENT> def first_strategy ( D , C , S ) : <NEWLINE> <INDENT> T = np . empty ( D , np . int32 ) <NEWLINE> for d in range ( D ) : <NEWLINE> <INDENT> T [ d ] = d % 26 <NEWLINE> <DEDENT> return T <NEWLINE> <NL> <DEDENT> D , C , S = get_input ( ) <NEWLINE> <NL> T = first_strategy ( D , C , S ) <NEWLINE> last_days , score = first_computation ( D , C , S , T ) <NEWLINE> <NL> T , x = main ( D , C , S , T , last_days ) <NEWLINE> <NL> output ( T ) <NEWLINE>
import time <NEWLINE> import random <NEWLINE> <NL> timestart = time . time ( ) <NEWLINE> D = int ( input ( ) ) <NEWLINE> c = list ( map ( int , input ( ) . rstrip ( ) . split ( <STRING> ) ) ) <NEWLINE> s = [ ] <NEWLINE> ta = [ ] <NEWLINE> ta_buf = [ ] <NEWLINE> <NL> man = 0 <NEWLINE> man_buf = 0 <NEWLINE> kankaku = [ 0 for i in range ( 27 ) ] <NEWLINE> for i in range ( D ) : <NEWLINE> <INDENT> s . append ( list ( map ( int , input ( ) . rstrip ( ) . split ( <STRING> ) ) ) ) <NEWLINE> <NL> <DEDENT> for i in range ( D ) : <NEWLINE> <INDENT> p = 0 <NEWLINE> t = 0 <NEWLINE> for i2 in range ( 26 ) : <NEWLINE> <INDENT> if p < s [ i ] [ i2 ] + c [ i2 ] * kankaku [ i2 ] * ( kankaku [ i2 ] * 2 ) // 2 : <NEWLINE> <INDENT> p = s [ i ] [ i2 ] + c [ i2 ] * kankaku [ i2 ] * ( kankaku [ i2 ] * 2 ) // 2 <NEWLINE> t = i2 + 1 <NEWLINE> <DEDENT> <DEDENT> kankaku [ t - 1 ] = - 1 <NEWLINE> ta . append ( t ) <NEWLINE> for i in range ( 26 ) : <NEWLINE> <INDENT> kankaku [ i ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> t . append ( - 1 ) <NEWLINE> for i in range ( D ) : <NEWLINE> <INDENT> man += s [ i ] [ ta [ i ] ] <NEWLINE> last [ ta [ i ] ] = i + 1 <NEWLINE> for i2 in range ( 26 ) : <NEWLINE> <INDENT> man -= ( i + 1 - last [ i2 ] ) * c [ i2 ] <NEWLINE> <NL> <DEDENT> <DEDENT> while timestart + 1.900 > time . time ( ) : <NEWLINE> <INDENT> for i in range ( D ) : <NEWLINE> <INDENT> ta_buf [ i ] = ta [ i ] <NEWLINE> <DEDENT> a = randint ( 0 , 360 ) <NEWLINE> b = a + randint ( 1 , 4 ) <NEWLINE> ta_buf [ a ] , ta_buf [ b ] = ta_buf [ b ] , ta_buf [ a ] <NEWLINE> <NL> for i in range ( D ) : <NEWLINE> <INDENT> man_buf += s [ i ] [ ta_buf [ i ] ] <NEWLINE> last [ ta_buf [ i ] ] = i + 1 <NEWLINE> for i2 in range ( 26 ) : <NEWLINE> <INDENT> man_buf -= ( i + 1 - last [ i2 ] ) * c [ i2 ] <NEWLINE> <NL> <DEDENT> <DEDENT> if man_buf > man : <NEWLINE> <INDENT> man = man_buf <NEWLINE> for i in range ( D ) : <NEWLINE> <INDENT> ta [ i ] = ta_buf [ i ] <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for i in range ( D ) : <NEWLINE> <INDENT> print ( ta [ i ] + 1 ) <NEWLINE> <DEDENT>
import random <NEWLINE> for _ in range ( 365 ) : <NEWLINE> <INDENT> print ( random . randint ( 1 : 26 ) ) <NEWLINE> <DEDENT>
d = int ( input ( ) ) <NEWLINE> c = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i in range ( d ) : <NEWLINE> <INDENT> s = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> num = max ( s ) <NEWLINE> print ( l . index ( num ) + 1 ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> <NL> D = int ( input ( ) ) <NEWLINE> C = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for d in D : <NEWLINE> <INDENT> S = np . array ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> print ( np . argmax ( S ) + 1 ) <NEWLINE> <DEDENT>
d = int ( input ( ) ) <NEWLINE> C = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> S = [ ] <NEWLINE> for i in range ( d ) : <NEWLINE> <INDENT> S . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <DEDENT> T = [ ] <NEWLINE> for i in range ( d ) : <NEWLINE> <INDENT> t = int ( input ( ) ) - 1 <NEWLINE> T . append ( t ) <NEWLINE> <NL> <NL> <DEDENT> Last = [ 0 ] * 26 <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( d ) : <NEWLINE> <INDENT> t = T [ i ] <NEWLINE> temp = S [ i ] [ t ] <NEWLINE> for j in range ( 26 ) : <NEWLINE> <INDENT> if j == t : <NEWLINE> <INDENT> Last [ j ] = i + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> temp -= C [ j ] * ( i + 1 - Last [ j ] ) <NEWLINE> <DEDENT> <DEDENT> ans += temp <NEWLINE> print ( ans ) <NEWLINE> <NL> <DEDENT>
import sys <NEWLINE> import numpy as np <NEWLINE> from operator import mul <NEWLINE> read = sys . stdin . buffer . read <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> readlines = sys . stdin . buffer . readlines <NEWLINE> <NL> d = int ( readline ( ) ) <NEWLINE> c = list ( map ( int , readline ( ) . split ( ) ) ) <NEWLINE> s = [ ] <NEWLINE> for _ in range ( d ) : <NEWLINE> <INDENT> add = list ( map ( int , readline ( ) . split ( ) ) ) <NEWLINE> s . append ( add ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> day = 0 <NEWLINE> satisfy = 0 <NEWLINE> sumC = sum ( c ) <NEWLINE> count = np . zeros ( 26 ) <NEWLINE> <NL> for i in range ( d ) : <NEWLINE> <COMMENT> <NL> <INDENT> tarLis = s [ day ] <NEWLINE> tar = max ( tarLis ) <NEWLINE> t = tarLis . index ( t ) + 1 <NEWLINE> print ( t ) <NEWLINE> day += 1 <NEWLINE> <STRING> <NEWLINE> <DEDENT>
d = int ( input ( ) ) <NEWLINE> for i in range ( d ) : <NEWLINE> <INDENT> print ( 26 % i + 1 ) <NEWLINE> <DEDENT>
for i in <STRING> * 365 : print ( i % 26 + 1 ) <NEWLINE>
d = int ( input ( ) ) <NEWLINE> <NL> c = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> sd = np . zeros ( ( d , 26 ) , dtype = np . int ) <NEWLINE> for i in range ( d ) : <NEWLINE> <INDENT> s = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> s_array = np . array ( s ) <NEWLINE> sd [ i , : ] = s_array <NEWLINE> <NL> <DEDENT> pp = np . zeros ( 26 , dtype = np . int ) <NEWLINE> <NL> for i in range ( d ) : <NEWLINE> <INDENT> pp += c <NEWLINE> pp_max = np . argmax ( pp ) + 1 <NEWLINE> pp_max_val = np . max ( pp ) <NEWLINE> print ( np . sum ( pp ) , pp_max , pp_max_val ) <NEWLINE> sd_max = np . argmax ( sd [ i , : ] ) + 1 <NEWLINE> sd_max_val = np . max ( sd [ i , : ] ) <NEWLINE> print ( sd_max , sd_max_val ) <NEWLINE> if np . sum ( pp ) >= sd_max_val : <NEWLINE> <INDENT> t = pp_max <NEWLINE> pp [ pp_max - 1 ] = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> t = sd_max <NEWLINE> <DEDENT> print ( t ) <NEWLINE> <DEDENT>
d = int ( input ( ) ) <NEWLINE> c = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> s = [ ] <NEWLINE> for i in range ( d ) : <NEWLINE> <INDENT> s . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <DEDENT> last = [ 0 ] * 26 <NEWLINE> <NL> for day in range ( 1 , d + 1 ) : <NEWLINE> <INDENT> co = [ ] <NEWLINE> dla = [ ] <NEWLINE> down = 0 <NEWLINE> for ( i , j ) in zip ( last , c ) : <NEWLINE> <INDENT> down += ( day - i ) * j <NEWLINE> <DEDENT> for ( i , j ) in zip ( last , c ) : <NEWLINE> <INDENT> dla . append ( down - ( j * ( day - i ) ) ) <NEWLINE> <DEDENT> for con in range ( 26 ) : <NEWLINE> <INDENT> co . append ( s [ day ] [ con ] - dla [ con ] * c [ con ] ) <NEWLINE> <DEDENT> choice = co . index ( max ( co ) ) <NEWLINE> last [ choice ] = day <NEWLINE> print ( choice + 1 ) <NEWLINE> <DEDENT>
import sys <NEWLINE> import heapq <NEWLINE> from typing import List , Tuple , Dict <NEWLINE> from dataclasses import dataclass , field <NEWLINE> <NL> import scipy <NEWLINE> import numpy as np <NEWLINE> from numba import jit <NEWLINE> <NL> D = int ( input ( ) ) <COMMENT> <NEWLINE> C = np . array ( list ( map ( int , input ( ) . split ( ) ) ) , dtype = <STRING> ) <COMMENT> <NEWLINE> S = np . array ( [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( D ) ] , dtype = <STRING> ) <COMMENT> <NEWLINE> <NL> <NL> @ dataclass ( ) <NEWLINE> class Node : <NEWLINE> <INDENT> value : int <NEWLINE> plan : List [ int ] <NEWLINE> last : List [ int ] <NEWLINE> <NL> def __lt__ ( self , other ) -> bool : <NEWLINE> <INDENT> return self . value > other . value <COMMENT> <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def calc_last ( plan : List [ int ] ) -> List [ int ] : <NEWLINE> <INDENT> res = [ 0 for _ in range ( 26 ) ] <NEWLINE> <NL> for d , p in enumerate ( plan ) : <NEWLINE> <INDENT> res [ p - 1 ] = d + 1 <NEWLINE> <NL> <DEDENT> return res <NEWLINE> <NL> <NL> <DEDENT> def calc_satisfaction ( plan : List [ int ] ) -> int : <NEWLINE> <INDENT> assert len ( plan ) == D <NEWLINE> res = 0 <NEWLINE> last = [ 0 for _ in range ( 26 ) ] <NEWLINE> <NL> for d in range ( D ) : <NEWLINE> <INDENT> p = plan [ d ] - 1 <NEWLINE> res += S [ d ] [ p ] <NEWLINE> last [ p ] = d + 1 <NEWLINE> <NL> for i in range ( 26 ) : <NEWLINE> <INDENT> res -= C [ i ] * ( d + 1 - last [ i ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> return res <NEWLINE> <NL> <NL> <DEDENT> def calc_score ( plan : List [ int ] ) -> int : <NEWLINE> <INDENT> return max ( 10 ** 6 + calc_satisfaction ( plan ) , 0 ) <NEWLINE> <NL> <NL> <DEDENT> def calc_dissatisfaction ( d : int , last : List [ int ] ) -> int : <NEWLINE> <INDENT> return sum ( [ C [ i ] * ( d - last [ i ] ) for i in range ( 26 ) ] ) <NEWLINE> <NL> <NL> <DEDENT> CAPACITY = 26 <NEWLINE> <NL> queue : List [ Node ] = [ Node ( 0 , [ ] , [ 0 for _ in range ( 26 ) ] ) ] <NEWLINE> for d in range ( D ) : <NEWLINE> <INDENT> next_queue : List [ Node ] = [ ] <NEWLINE> <NL> heapq . heapify ( queue ) <NEWLINE> cnt = 0 <NEWLINE> while queue and cnt < CAPACITY : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> node = heapq . heappop ( queue ) <NEWLINE> dis = calc_dissatisfaction ( d + 1 , node . last ) <NEWLINE> <NL> for i in range ( 26 ) : <NEWLINE> <INDENT> s = S [ d ] [ i ] + C [ i ] * ( d + 1 - node . last [ i ] ) - dis <NEWLINE> <NL> next_queue . append ( <NEWLINE> <INDENT> Node ( <NEWLINE> <INDENT> node . value + s , <NEWLINE> node . plan + [ i + 1 ] , <NEWLINE> node . last [ : i ] + [ d + 1 ] + node . last [ i + 1 : ] <NEWLINE> <DEDENT> ) , <NEWLINE> <DEDENT> ) <NEWLINE> <NL> <DEDENT> <DEDENT> queue = next_queue <NEWLINE> <NL> <DEDENT> res_node = heapq . heappop ( queue ) <NEWLINE> print ( res_node , file = sys . stderr ) <NEWLINE> print ( <STRING> . join ( map ( str , res_node . plan ) ) ) <NEWLINE>
import random <NEWLINE> import time <NEWLINE> import copy <NEWLINE> start = time . time ( ) <NEWLINE> d = int ( input ( ) ) <NEWLINE> c = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> cli = [ ] <NEWLINE> for i in range ( d + 1 ) : <NEWLINE> <INDENT> ch = [ ] <NEWLINE> for j in c : <NEWLINE> <INDENT> ch . append ( i * j ) <NEWLINE> <DEDENT> cli . append ( ch ) <NEWLINE> <DEDENT> s = [ ] <NEWLINE> solution = [ ] <NEWLINE> last = [ 0 ] * 26 <NEWLINE> sco = 0 <NEWLINE> for i in range ( d ) : <NEWLINE> <INDENT> s . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <DEDENT> for day in range ( 1 , d + 1 ) : <NEWLINE> <INDENT> man = [ ] <NEWLINE> for i in range ( 26 ) : <NEWLINE> <INDENT> man . append ( s [ day - 1 ] [ i ] + last [ i ] * c [ i ] ) <NEWLINE> <DEDENT> con = man . index ( max ( man ) ) <NEWLINE> sco += s [ day - 1 ] [ con ] <NEWLINE> last [ con ] = day <NEWLINE> for ( i , j ) in zip ( last , range ( 26 ) ) : <NEWLINE> <INDENT> sco -= cli [ i ] [ j ] <NEWLINE> <DEDENT> solution . append ( con ) <NEWLINE> <COMMENT> <NL> <DEDENT> while time . time ( ) - start < 8 : <NEWLINE> <INDENT> sc = 0 <NEWLINE> sol = copy . deepcopy ( solution ) <NEWLINE> for x in [ random . randrange ( d ) for i in range ( 3 ) ] : <NEWLINE> <INDENT> sol [ x ] = random . randrange ( 26 ) <NEWLINE> <DEDENT> last = [ 0 ] * 26 <NEWLINE> for ( day , i ) in zip ( range ( 1 , d + 1 ) , sol ) : <NEWLINE> <INDENT> sc += s [ day - 1 ] [ i ] <NEWLINE> last [ i ] = day <NEWLINE> for ( i , j ) in zip ( last , range ( 26 ) ) : <NEWLINE> <INDENT> sc -= cli [ i ] [ j ] <NEWLINE> <DEDENT> <DEDENT> if sc > sco : <NEWLINE> <INDENT> solution = copy . deepcopy ( sol ) <NEWLINE> sco = sc <NEWLINE> <DEDENT> <DEDENT> for i in solution : <NEWLINE> <INDENT> print ( i + 1 ) <NEWLINE> <COMMENT> <NL> <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> import sys <NEWLINE> read = sys . stdin . buffer . read <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> <NL> from numba import njit <NEWLINE> <NL> <NL> def getInputs ( ) : <NEWLINE> <INDENT> D = int ( readline ( ) ) <NEWLINE> CS = np . array ( read ( ) . split ( ) , np . int32 ) <NEWLINE> C = CS [ : 26 ] <NEWLINE> S = CS [ 26 : ] . reshape ( ( - 1 , 26 ) ) <NEWLINE> return D , C , S <NEWLINE> <NL> <NL> <DEDENT> def _compute_score ( output ) : <NEWLINE> <INDENT> last = np . zeros ( ( 26 , ) ) <NEWLINE> for d in range ( len ( output ) ) : <NEWLINE> <INDENT> last [ output [ d ] ] = d + 1 <NEWLINE> score = S [ d ] [ output [ d ] ] - np . sum ( C * ( d + 1 - last ) ) <NEWLINE> <NL> <DEDENT> return score <NEWLINE> <NL> <NL> <DEDENT> def solve ( ) : <NEWLINE> <INDENT> output = [ ] <NEWLINE> <COMMENT> <NL> for _ in range ( D ) : <NEWLINE> <INDENT> max_score = float ( <STRING> ) <NEWLINE> best_i = 0 <NEWLINE> for i in range ( 26 ) : <NEWLINE> <INDENT> output . append ( i ) <NEWLINE> score = _compute_score ( output ) <NEWLINE> if max_score < score : <NEWLINE> <INDENT> max_score = score <NEWLINE> best_i = i + 1 <NEWLINE> <DEDENT> output . pop ( ) <NEWLINE> <DEDENT> output . append ( best_i ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> return output <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> D , C , S = getInputs ( ) <NEWLINE> ans = solve ( ) <NEWLINE> print ( <STRING> . join ( map ( str , ans ) ) ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> from collections import defaultdict <NEWLINE> from heapq import heappush , heappop <NEWLINE> import sys <NEWLINE> import numpy as np <NEWLINE> from random import random <NEWLINE> from time import perf_counter <NEWLINE> <NL> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> input = sys . stdin . buffer . readline <NEWLINE> INF = 10 ** 9 + 1 <COMMENT> <NEWLINE> <NL> <NL> def debug ( * x ) : <NEWLINE> <INDENT> print ( * x , file = sys . stderr ) <NEWLINE> <NL> <NL> <DEDENT> def solve ( D , CS , S ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> time = perf_counter ( ) <NEWLINE> <NL> answer = [ ] <NEWLINE> last = [ - 1 ] * 26 <NEWLINE> for i in range ( D ) : <NEWLINE> <INDENT> dscore = np . zeros ( 26 ) <NEWLINE> for j in range ( 26 ) : <NEWLINE> <INDENT> dscore [ j ] += S [ i , j ] <NEWLINE> dscore [ j ] -= sum ( CS [ k ] * ( i - last [ k ] ) <NEWLINE> <INDENT> for k in range ( 26 ) if j != k ) <NEWLINE> <NL> <DEDENT> <DEDENT> j = dscore . argmax ( ) <NEWLINE> answer . append ( j + 1 ) <NEWLINE> last [ j ] = i <NEWLINE> <DEDENT> s = calcScore ( answer , D , CS , S ) <NEWLINE> <NL> bestscore = s <NEWLINE> bestanswer = answer <NEWLINE> <NL> ORIG_S = S . astype ( np . float ) <NEWLINE> while perf_counter ( ) - time < 1.5 * 100 : <NEWLINE> <INDENT> answer = [ ] <NEWLINE> last = [ - 1 ] * 26 <NEWLINE> k1 = random ( ) * 0.05 <NEWLINE> k2 = random ( ) * k1 <NEWLINE> S = ORIG_S . copy ( ) <NEWLINE> S [ : - 1 ] = ( S [ : - 1 ] + k1 * ORIG_S [ 1 : ] ) / ( 1 + k1 ) <NEWLINE> S [ : - 2 ] = ( S [ : - 2 ] + k2 * ORIG_S [ 2 : ] ) / ( 1 + k2 ) <NEWLINE> for i in range ( D ) : <NEWLINE> <INDENT> dscore = np . zeros ( 26 ) <NEWLINE> for j in range ( 26 ) : <NEWLINE> <INDENT> dscore [ j ] += S [ i , j ] <NEWLINE> dscore [ j ] -= sum ( CS [ k ] * ( i - last [ k ] ) <NEWLINE> <INDENT> for k in range ( 26 ) if j != k ) <NEWLINE> <NL> <DEDENT> <DEDENT> j = dscore . argmax ( ) <NEWLINE> answer . append ( j + 1 ) <NEWLINE> last [ j ] = i <NEWLINE> <DEDENT> s = calcScore ( answer , D , CS , ORIG_S ) <NEWLINE> if s > bestscore : <NEWLINE> <INDENT> debug ( <STRING> , k1 , k2 ) <NEWLINE> bestscore = s <NEWLINE> bestanswer = answer <NEWLINE> <DEDENT> <DEDENT> print ( * bestanswer , sep = <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> def calcScore ( answer , D , CS , S ) : <NEWLINE> <INDENT> last = [ - 1 ] * 26 <NEWLINE> score = 0 <NEWLINE> for i in range ( D ) : <NEWLINE> <INDENT> j = answer [ i ] - 1 <NEWLINE> score += S [ i , j ] <NEWLINE> last [ j ] = i <NEWLINE> score -= sum ( CS [ j ] * ( i - last [ j ] ) for j in range ( 26 ) ) <NEWLINE> <DEDENT> return score <NEWLINE> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> D = int ( input ( ) ) <NEWLINE> CS = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> S = np . int16 ( read ( ) . split ( ) ) <NEWLINE> S = S . reshape ( ( D , 26 ) ) <NEWLINE> <NL> <COMMENT> <NL> solve ( D , CS , S ) <NEWLINE> <NL> <NL> <DEDENT> T = <STRING> <NEWLINE> <NL> OUT = <STRING> <NEWLINE> <NL> <NL> def _test ( ) : <NEWLINE> <INDENT> import doctest <NEWLINE> doctest . testmod ( ) <NEWLINE> as_input ( T ) <NEWLINE> main ( ) <NEWLINE> <NL> <NL> <DEDENT> def as_input ( s ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> import io <NEWLINE> global read , input <NEWLINE> f = io . StringIO ( s . strip ( ) ) <NEWLINE> input = f . readline <NEWLINE> read = f . read <NEWLINE> <NL> <NL> <DEDENT> USE_NUMBA = False <NEWLINE> if ( USE_NUMBA and sys . argv [ - 1 ] == <STRING> ) or sys . argv [ - 1 ] == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> from numba . pycc import CC <NEWLINE> cc = CC ( <STRING> ) <NEWLINE> cc . export ( <STRING> , solve . __doc__ . strip ( ) . split ( ) [ 0 ] ) ( solve ) <NEWLINE> cc . compile ( ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> input = sys . stdin . buffer . readline <NEWLINE> read = sys . stdin . buffer . read <NEWLINE> <NL> if ( USE_NUMBA and sys . argv [ - 1 ] != <STRING> ) or sys . argv [ - 1 ] == <STRING> : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <INDENT> from my_module import solve <COMMENT> <NEWLINE> <DEDENT> elif sys . argv [ - 1 ] == <STRING> : <NEWLINE> <INDENT> _test ( ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> elif sys . argv [ - 1 ] != <STRING> and len ( sys . argv ) == 2 : <NEWLINE> <COMMENT> <NL> <INDENT> input_as_file = open ( sys . argv [ 1 ] ) <NEWLINE> input = input_as_file . buffer . readline <NEWLINE> read = input_as_file . buffer . read <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE> <DEDENT>
import random <NEWLINE> import time <NEWLINE> import copy <NEWLINE> import math <NEWLINE> start = time . time ( ) <NEWLINE> d = int ( input ( ) ) <NEWLINE> c = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> s = [ ] <NEWLINE> cli = [ ] <NEWLINE> for i in range ( d + 1 ) : <NEWLINE> <INDENT> ch = [ ] <NEWLINE> for j in c : <NEWLINE> <INDENT> ch . append ( i * j ) <NEWLINE> <DEDENT> cli . append ( ch ) <NEWLINE> <DEDENT> for i in range ( d ) : <NEWLINE> <INDENT> s . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <DEDENT> last = [ 0 ] * 26 <NEWLINE> score = 0 <NEWLINE> solution = [ ] <NEWLINE> for day in range ( 1 , d + 1 ) : <NEWLINE> <INDENT> co = [ ] <NEWLINE> dla = [ ] <NEWLINE> down = 0 <NEWLINE> for ( i , j ) in zip ( last , c ) : <NEWLINE> <INDENT> down += ( day - i ) * j <NEWLINE> <DEDENT> for ( i , j ) in zip ( last , c ) : <NEWLINE> <INDENT> dla . append ( down - ( j * ( day - i ) ) ) <NEWLINE> <DEDENT> for con in range ( 26 ) : <NEWLINE> <INDENT> co . append ( s [ day - 1 ] [ con ] - dla [ con ] ) <NEWLINE> <DEDENT> choice = co . index ( max ( co ) ) <NEWLINE> score += co [ choice ] <NEWLINE> last [ choice ] = day <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> solution . append ( choice ) <NEWLINE> <COMMENT> <NL> <DEDENT> stemp = 4000 <NEWLINE> etemp = 100 <NEWLINE> def tem ( ) <NEWLINE> <INDENT> return stemp - ( ( stemp - etemp ) * ( time . time ( ) - start ) / 1.9 ) <NEWLINE> <DEDENT> while time . time ( ) - start < 1.9 : <NEWLINE> <NL> <INDENT> sc = 0 <NEWLINE> sol = copy . deepcopy ( solution ) <NEWLINE> for x in [ random . randrange ( d ) for i in range ( 1 ) ] : <NEWLINE> <INDENT> sol [ x ] = random . randrange ( 26 ) <NEWLINE> <DEDENT> last = [ 0 ] * 26 <NEWLINE> for ( day , i ) in zip ( range ( 1 , d + 1 ) , sol ) : <NEWLINE> <INDENT> sc += s [ day - 1 ] [ i ] <NEWLINE> last [ i ] = day <NEWLINE> for ( i , j ) in zip ( last , range ( 26 ) ) : <NEWLINE> <INDENT> sc -= cli [ day - i ] [ j ] <NEWLINE> <DEDENT> <DEDENT> try : <NEWLINE> <INDENT> prob = math . exp ( ( sc - score ) / tem ( ) ) <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> prob = 0 <NEWLINE> <COMMENT> <NL> <DEDENT> if prob > random . random ( ) : <NEWLINE> <INDENT> solution = copy . deepcopy ( sol ) <NEWLINE> score = sc <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> for i in solution : <NEWLINE> <INDENT> print ( i + 1 ) <NEWLINE> <COMMENT> <NL> <DEDENT>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> D = int ( input ( ) ) <NEWLINE> C = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> S = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( D ) ] <NEWLINE> t = [ int ( input ( ) ) for i in range ( D ) ] <NEWLINE> <NL> for i in range ( D ) : <NEWLINE> <INDENT> print ( 13 ) <NEWLINE> <DEDENT>
D = int ( input ( ) ) <COMMENT> <NEWLINE> c = list ( map ( int , input ( ) . split ( ) ) ) <COMMENT> <NEWLINE> s = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( D ) ] <COMMENT> <NEWLINE> <NL> t = [ ] <NEWLINE> for d in range ( D ) : <NEWLINE> <INDENT> t . append ( s . index ( max ( s [ d ] ) ) + 1 ) <NEWLINE> <NL> <DEDENT> for i in range ( D ) : <NEWLINE> <INDENT> print ( t [ i ] ) <NEWLINE> <DEDENT>
for i in range ( d ) : <NEWLINE> <INDENT> print ( i % 26 + 1 ) <NEWLINE> <DEDENT>
from typing import List <NEWLINE> <NL> <NL> def read_data ( file_name : str ) : <NEWLINE> <INDENT> satisfactions_list = list ( ) <NEWLINE> with open ( file_name , <STRING> ) as file : <NEWLINE> <INDENT> days = int ( file . readline ( ) . rstrip ( ) ) <NEWLINE> satisfaction_decreases = [ int ( c ) for c in file . readline ( ) . rstrip ( ) . split ( <STRING> ) ] <NEWLINE> for i in range ( days ) : <NEWLINE> <INDENT> satisfactions_list . append ( [ int ( c ) for c in file . readline ( ) . rstrip ( ) . split ( <STRING> ) ] ) <NEWLINE> <DEDENT> <DEDENT> return days , satisfaction_decreases , satisfactions_list <NEWLINE> <NL> <NL> <DEDENT> class Contest : <NEWLINE> <INDENT> def __init__ ( self , _type : int , satisfactions : List [ int ] , satisfaction_decrease : int ) : <NEWLINE> <INDENT> self . satisfaction = 0 <NEWLINE> self . type = _type <NEWLINE> self . satisfactions = satisfactions <NEWLINE> self . satisfaction_decrease = - satisfaction_decrease <NEWLINE> <NL> <DEDENT> def __getitem__ ( self , key : int ) : <NEWLINE> <INDENT> return self . satisfactions [ key - 1 ] <NEWLINE> <NL> <DEDENT> def __str__ ( self ) : <NEWLINE> <INDENT> return str ( self . type ) <NEWLINE> <NL> <DEDENT> def __repr__ ( self ) : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <NL> <DEDENT> def get_satisfaction_increase ( self , day ) : <NEWLINE> <INDENT> return self [ day ] - ( self . satisfaction + self . satisfaction_decrease ) <NEWLINE> <NL> <DEDENT> def winner ( self , day ) : <NEWLINE> <INDENT> self . satisfaction += self [ day ] <NEWLINE> <NL> <DEDENT> def loser ( self ) : <NEWLINE> <INDENT> self . satisfaction += self . satisfaction_decrease <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def get_best ( contests : List [ Contest ] , day : int ) : <NEWLINE> <COMMENT> <NL> <INDENT> best = contests [ 0 ] <NEWLINE> for contest in contests : <NEWLINE> <INDENT> if contest . get_satisfaction_increase ( day ) > best . get_satisfaction_increase ( day ) : <NEWLINE> <INDENT> best = contest <NEWLINE> <DEDENT> <DEDENT> return best <NEWLINE> <NL> <NL> <DEDENT> def main ( file_name = <STRING> ) : <NEWLINE> <INDENT> contests = list ( ) <NEWLINE> days , satisfaction_decreases , satisfactions_list = read_data ( file_name ) <NEWLINE> picks = list ( ) <NEWLINE> <NL> for ( _type , ( satisfactions , satisfaction_decrease ) ) in enumerate ( zip ( zip ( * satisfactions_list ) , satisfaction_decreases ) , start = 1 ) : <NEWLINE> <INDENT> contests . append ( Contest ( _type , satisfactions , satisfaction_decrease ) ) <NEWLINE> <NL> <DEDENT> for day in range ( days ) : <NEWLINE> <INDENT> best = get_best ( contests , day + 1 ) <NEWLINE> for contest in contests : <NEWLINE> <INDENT> if contest . type == best . type : <NEWLINE> <INDENT> contest . winner ( day + 1 ) <NEWLINE> picks . append ( contest ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> contest . loser ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> return <STRING> . join ( [ str ( pick ) for pick in picks ] ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> print ( main ( ) ) <NEWLINE> <DEDENT>
import random <NEWLINE> D = int ( input ( ) ) <NEWLINE> c = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> s = [ ] <NEWLINE> for i in range ( D ) : <NEWLINE> <INDENT> s . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <DEDENT> t = [ 0 ] * D <NEWLINE> def my_index ( l , x , d , default = False ) : <NEWLINE> <INDENT> if x in l : <NEWLINE> <INDENT> return l . index ( x ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return d <NEWLINE> <DEDENT> <DEDENT> def last ( d , i ) : <NEWLINE> <INDENT> a = t [ : d ] <NEWLINE> a . reverse ( ) <NEWLINE> day = - 1 * ( my_index ( a , i , d ) ) + d <NEWLINE> return day <NEWLINE> <DEDENT> score = 0 <NEWLINE> score_v = 0 <NEWLINE> for i in range ( 50 ) : <NEWLINE> <INDENT> t_old = t <NEWLINE> d_change = random . randint ( 1 , D ) <NEWLINE> q_change = random . randint ( 1 , 26 ) <NEWLINE> t [ d_change ] = q_change <NEWLINE> for d in range ( 1 , D + 1 ) : <NEWLINE> <INDENT> score_v += s [ d - 1 ] [ t [ d - 1 ] - 1 ] <NEWLINE> for i in range ( 1 , 27 ) : <NEWLINE> <INDENT> score_v -= c [ i - 1 ] * ( d - last ( d , i ) ) <NEWLINE> if score_v > score : <NEWLINE> <INDENT> score = score_v <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> t = t_old <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for i in range ( D ) : <NEWLINE> <INDENT> print ( t [ i ] ) <NEWLINE> <DEDENT>
<COMMENT> <NL> import time <NEWLINE> s__ = time . time ( ) <NEWLINE> limit = 1.9 <NEWLINE> <COMMENT> <NL> <NL> from numba import njit <NEWLINE> import numpy as np <NEWLINE> <NL> d = int ( input ( ) ) <NEWLINE> cs = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> cs = np . array ( cs , dtype = np . int64 ) <NEWLINE> sm = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( d ) ] <NEWLINE> sm = np . array ( sm , dtype = np . int64 ) <NEWLINE> <NL> @ njit ( <STRING> , cache = True ) <NEWLINE> def total_satisfaction ( ts , d ) : <NEWLINE> <INDENT> ls = np . zeros ( 26 , dtype = np . int64 ) <NEWLINE> s = 0 <NEWLINE> for i in range ( d ) : <NEWLINE> <INDENT> t = ts [ i ] <NEWLINE> t -= 1 <NEWLINE> s += sm [ i ] [ t ] <NEWLINE> ls [ t ] = i + 1 <NEWLINE> <NL> dv = cs * ( ( i + 1 ) - ls ) <NEWLINE> s -= dv . sum ( ) <NEWLINE> <DEDENT> return s <NEWLINE> <NL> <DEDENT> @ njit ( <STRING> , cache = True ) <NEWLINE> def loop ( mxsc , ts , tmpr ) : <NEWLINE> <INDENT> it = 100 <NEWLINE> rds = np . random . randint ( 0 , 4 , ( it , ) ) <NEWLINE> rdd = np . random . randint ( 1 , d , ( it , ) ) <NEWLINE> rdq = np . random . randint ( 1 , 26 , ( it , ) ) <NEWLINE> rdx = np . random . randint ( 1 , 12 , ( it , ) ) <NEWLINE> for i in range ( it ) : <NEWLINE> <INDENT> bk1 = 0 <NEWLINE> bk2 = 0 <NEWLINE> if rds [ 0 ] == 0 : <NEWLINE> <COMMENT> <NL> <INDENT> di = rdd [ i ] <NEWLINE> qi = rdq [ i ] <NEWLINE> <NL> bk1 = ts [ di ] <NEWLINE> ts [ di ] = qi <NEWLINE> <DEDENT> else : <NEWLINE> <COMMENT> <NL> <INDENT> di = rdd [ i ] <NEWLINE> xi = rdx [ i ] <NEWLINE> if di + xi >= d : <NEWLINE> <INDENT> xi = di - xi <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> xi = di + xi <NEWLINE> <NL> <DEDENT> bk1 = ts [ di ] <NEWLINE> bk2 = ts [ xi ] <NEWLINE> ts [ di ] = bk2 <NEWLINE> ts [ xi ] = bk1 <NEWLINE> <NL> <DEDENT> sc = total_satisfaction ( ts , d ) <NEWLINE> <NL> delta = sc - mxsc <NEWLINE> if delta > 0 : <NEWLINE> <COMMENT> <NL> <INDENT> mxsc = sc <NEWLINE> <DEDENT> else : <NEWLINE> <COMMENT> <NL> <INDENT> exp = np . exp ( delta / tmpr ) <NEWLINE> <COMMENT> <NL> r = np . random . random ( ) <NEWLINE> if r <= exp : <NEWLINE> <COMMENT> <NL> <INDENT> mxsc = sc <NEWLINE> <DEDENT> else : <NEWLINE> <COMMENT> <NL> <INDENT> if rds [ 0 ] == 0 : <NEWLINE> <INDENT> ts [ di ] = bk1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ts [ di ] = bk1 <NEWLINE> ts [ xi ] = bk2 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> return mxsc <NEWLINE> <NL> <DEDENT> @ njit ( <STRING> , cache = True ) <NEWLINE> def greedy ( ) : <NEWLINE> <INDENT> ts = np . array ( [ 0 ] * d , dtype = np . int64 ) <NEWLINE> for i in range ( d ) : <NEWLINE> <INDENT> mx = - 1e10 <NEWLINE> mxt = None <NEWLINE> for t in range ( 1 , 26 + 1 ) : <NEWLINE> <INDENT> ts [ i ] = t <NEWLINE> s = total_satisfaction ( ts , i + 1 ) <NEWLINE> if s > mx : <NEWLINE> <INDENT> mx = s <NEWLINE> mxt = t <NEWLINE> <DEDENT> <DEDENT> ts [ i ] = mxt <NEWLINE> <DEDENT> return ts <NEWLINE> <NL> <DEDENT> ts = greedy ( ) <NEWLINE> <COMMENT> <NL> mxsc = total_satisfaction ( ts , d ) <NEWLINE> mxbk = mxsc <NEWLINE> <NL> <COMMENT> <NL> t0 = 2e3 <NEWLINE> t1 = 6e2 <NEWLINE> <NL> s_ = time . time ( ) <NEWLINE> mxsc = loop ( mxsc , ts , t0 ) <NEWLINE> e_ = time . time ( ) <NEWLINE> <NL> consume = s_ - s__ <NEWLINE> elapsed = e_ - s_ <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> if consume < limit : <NEWLINE> <INDENT> lp = int ( ( limit - consume ) / elapsed ) <NEWLINE> for i in range ( lp ) : <NEWLINE> <INDENT> t = i / lp <NEWLINE> tmpr = np . power ( t0 , 1 - t ) * np . power ( t1 , t ) <NEWLINE> mxsc = loop ( mxsc , ts , tmpr ) <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> for t in ts : print ( t ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL>
d = int ( input ( ) ) <NEWLINE> a = [ ] <NEWLINE> for x in range ( d + 1 ) : <NEWLINE> <INDENT> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a . append ( b ) <NEWLINE> <NL> <DEDENT> for n in range ( d ) : <NEWLINE> <INDENT> print ( random . randint ( 1 : 27 ) ) <NEWLINE> <DEDENT>
day = [ 0 for i in range ( 26 ) ] <NEWLINE> for i in range ( d ) : <NEWLINE> <INDENT> s . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <DEDENT> ans = 0 <NEWLINE> num = 1 <NEWLINE> for i in s : <NEWLINE> <INDENT> max_index = - 1 <NEWLINE> large = 0 <NEWLINE> for j in range ( 26 ) : <NEWLINE> <INDENT> if large < i [ j ] : <NEWLINE> <INDENT> large = i [ j ] <NEWLINE> if not max_index == - 1 : <NEWLINE> <INDENT> ans -= c [ max_index ] * ( num - day [ max_index ] ) <NEWLINE> <DEDENT> max_index = j <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans -= c [ j ] * ( num - day [ j ] ) <NEWLINE> <DEDENT> <DEDENT> day [ max_index ] = num <NEWLINE> ans += large <NEWLINE> print ( max_index + 1 ) <NEWLINE> num += 1 <NEWLINE> <DEDENT>
import os <NEWLINE> import sys <NEWLINE> <NL> import numpy as np <NEWLINE> <NL> <NL> def solve ( inp ) : <NEWLINE> <INDENT> def bitree_sum ( bit , t , i ) : <NEWLINE> <INDENT> s = 0 <NEWLINE> while i > 0 : <NEWLINE> <INDENT> s += bit [ t , i ] <NEWLINE> i ^= i & - i <NEWLINE> <DEDENT> return s <NEWLINE> <NL> <DEDENT> def bitree_add ( bit , n , t , i , x ) : <NEWLINE> <INDENT> while i <= n : <NEWLINE> <INDENT> bit [ t , i ] += x <NEWLINE> i += i & - i <NEWLINE> <NL> <DEDENT> <DEDENT> def bitree_lower_bound ( bit , n , d , t , x ) : <NEWLINE> <INDENT> sum_ = 0 <NEWLINE> pos = 0 <NEWLINE> for i in range ( d , - 1 , - 1 ) : <NEWLINE> <INDENT> k = pos + ( 1 << i ) <NEWLINE> if k <= n and sum_ + bit [ t , k ] < x : <NEWLINE> <INDENT> sum_ += bit [ t , k ] <NEWLINE> pos += 1 << i <NEWLINE> <DEDENT> <DEDENT> return pos + 1 <NEWLINE> <NL> <DEDENT> def initial_score ( d , ccc , sss , ttt ) : <NEWLINE> <INDENT> bit_n = d + 3 <NEWLINE> bit = np . zeros ( ( 26 , bit_n ) , dtype = np . int64 ) <NEWLINE> INF = 10 ** 18 <NEWLINE> for t in range ( 26 ) : <NEWLINE> <INDENT> bitree_add ( bit , bit_n , t , bit_n - 1 , INF ) <NEWLINE> <NL> <DEDENT> last = np . full ( 26 , - 1 , dtype = np . int64 ) <NEWLINE> score = 0 <NEWLINE> <NL> for i in range ( d ) : <NEWLINE> <INDENT> t = ttt [ i ] <NEWLINE> score += sss [ i , t ] <NEWLINE> for u in range ( 26 ) : <NEWLINE> <INDENT> if u == t : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> score -= ccc [ u ] * ( i - last [ u ] ) <NEWLINE> <DEDENT> last [ t ] = i <NEWLINE> bitree_add ( bit , bit_n , t , i + 2 , 1 ) <NEWLINE> <NL> <DEDENT> return bit , score <NEWLINE> <NL> <DEDENT> def update_score ( bit , bit_n , bit_d , ccc , sss , ttt , d , q ) : <NEWLINE> <INDENT> diff = 0 <NEWLINE> t = ttt [ d ] <NEWLINE> k = bitree_sum ( bit , t , d + 2 ) <NEWLINE> c = bitree_lower_bound ( bit , bit_n , bit_d , t , k - 1 ) - 2 <NEWLINE> e = bitree_lower_bound ( bit , bit_n , bit_d , t , k + 1 ) - 2 <NEWLINE> b = ccc [ t ] <NEWLINE> diff -= b * ( d - c ) * ( e - d ) <NEWLINE> diff -= sss [ d , t ] <NEWLINE> <NL> k = bitree_sum ( bit , q , d + 2 ) <NEWLINE> c = bitree_lower_bound ( bit , bit_n , bit_d , q , k ) - 2 <NEWLINE> e = bitree_lower_bound ( bit , bit_n , bit_d , q , k + 1 ) - 2 <NEWLINE> b = ccc [ q ] <NEWLINE> diff += b * ( d - c ) * ( e - d ) <NEWLINE> diff += sss [ d , q ] <NEWLINE> <NL> return diff <NEWLINE> <NL> <DEDENT> d = inp [ 0 ] <NEWLINE> ccc = inp [ 1 : 27 ] <NEWLINE> sss = np . zeros ( ( d , 26 ) , dtype = np . int64 ) <NEWLINE> for r in range ( d ) : <NEWLINE> <INDENT> sss [ r ] = inp [ 27 + r * 26 : 27 + ( r + 1 ) * 26 ] <NEWLINE> <NL> <DEDENT> ttt = np . random . choice ( 26 , d ) <NEWLINE> <NL> bit , score = initial_score ( d , ccc , sss , ttt ) <NEWLINE> bit_n = d + 3 <NEWLINE> bit_d = int ( np . log2 ( bit_n ) ) <NEWLINE> <NL> for _ in range ( 10 ** 7 ) : <NEWLINE> <INDENT> cd = np . random . randint ( 0 , d ) <NEWLINE> ct = np . random . randint ( 0 , 26 ) <NEWLINE> diff = update_score ( bit , bit_n , bit_d , ccc , sss , ttt , cd , ct ) <NEWLINE> if diff > 0 : <NEWLINE> <INDENT> score += diff <NEWLINE> bitree_add ( bit , bit_n , ttt [ cd ] , cd + 2 , - 1 ) <NEWLINE> bitree_add ( bit , bit_n , ct , cd + 2 , 1 ) <NEWLINE> ttt [ cd ] = ct <NEWLINE> <NL> <DEDENT> <DEDENT> return ttt + 1 <NEWLINE> <NL> <NL> <DEDENT> if sys . argv [ - 1 ] == <STRING> : <NEWLINE> <INDENT> from numba . pycc import CC <NEWLINE> <NL> cc = CC ( <STRING> ) <NEWLINE> cc . export ( <STRING> , <STRING> ) ( solve ) <NEWLINE> cc . compile ( ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> if os . name == <STRING> : <NEWLINE> <COMMENT> <NL> <INDENT> from my_module import solve <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> from numba import njit <NEWLINE> <NL> solve = njit ( <STRING> , cache = True ) ( solve ) <NEWLINE> print ( <STRING> , file = sys . stderr ) <NEWLINE> <NL> <DEDENT> inp = np . fromstring ( sys . stdin . read ( ) , dtype = np . int64 , sep = <STRING> ) <NEWLINE> ans = solve ( inp ) <NEWLINE> print ( <STRING> . join ( map ( str , ans ) ) ) <NEWLINE>
5 <NEWLINE> 86 90 69 51 2 96 71 47 88 34 45 46 89 34 31 38 97 84 41 80 14 4 50 83 7 82 <NEWLINE> 19771 12979 18912 10432 10544 12928 13403 3047 10527 9740 8100 92 2856 14730 1396 15905 6534 4650 11469 3628 8433 2994 10899 16396 18355 11424 <NEWLINE> 6674 17707 13855 16407 12232 2886 11908 1705 5000 1537 10440 10711 4917 10770 17272 15364 19277 18094 3929 3705 7169 6159 18683 15410 9092 4570 <NEWLINE> 6878 4239 19925 1799 375 9563 3445 5658 19857 11401 6997 6498 19933 3848 2426 2146 19745 16880 17773 18359 3921 14172 16730 11157 5439 256 <NEWLINE> 8633 15862 15303 10749 18499 7792 10317 5901 9395 11433 3514 3959 5202 19850 19469 9790 5653 784 18500 10552 17975 16615 7852 197 8471 7452 <NEWLINE> 19855 17918 7990 10572 4333 438 9140 9104 12622 4985 12319 4028 19922 12132 16259 17476 2976 547 19195 19830 16285 4806 4471 9457 2864 2192 <NEWLINE>
D = int ( input ( ) ) <NEWLINE> c = list ( map ( int , input ( ) . rstrip ( ) . split ( <STRING> ) ) ) <NEWLINE> s = [ ] <NEWLINE> for i in range ( D ) : <NEWLINE> <INDENT> a . append ( list ( map ( int , input ( ) . rstrip ( ) . split ( <STRING> ) ) ) ) <NEWLINE> <NL> <DEDENT> p = 0 <NEWLINE> t = 0 <NEWLINE> for i in range ( D ) : <NEWLINE> <INDENT> for i2 in range ( 26 ) : <NEWLINE> <INDENT> if p < S [ i ] [ i2 ] : <NEWLINE> <INDENT> p = s [ i ] [ i2 ] <NEWLINE> t = i2 <NEWLINE> <DEDENT> <DEDENT> print ( t ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> TYPE_NUM = 26 <NEWLINE> <NL> def resolve ( ) : <NEWLINE> <NL> <INDENT> inp = sys . stdin . readlines ( ) <NEWLINE> D = int ( inp [ 0 ] ) <NEWLINE> c = np . array ( list ( map ( int , inp [ 1 ] . split ( <STRING> ) ) ) ) <NEWLINE> s = [ ] <NEWLINE> last = np . zeros ( TYPE_NUM , dtype = int ) <NEWLINE> types = [ ] <NEWLINE> <NL> for i in range ( 2 , len ( inp ) ) : <NEWLINE> <INDENT> s . append ( list ( map ( int , inp [ i ] . split ( <STRING> ) ) ) ) <NEWLINE> <DEDENT> s = np . array ( s , dtype = int ) <NEWLINE> <NL> for d in range ( D ) : <NEWLINE> <INDENT> opt_delta_satis = - 10 ** 32 <NEWLINE> opt_idx = 0 <NEWLINE> for idx in range ( TYPE_NUM ) : <NEWLINE> <INDENT> val = s [ d , idx ] <NEWLINE> org = last [ idx ] <NEWLINE> last [ idx ] = d + 1 <NEWLINE> temp_delta_satis = np . sum ( - c * ( d + 1 - last ) ) + val <NEWLINE> if opt_delta_satis < temp_delta_satis : <NEWLINE> <INDENT> opt_delta_satis = temp_delta_satis <NEWLINE> opt_idx = idx <NEWLINE> <DEDENT> last [ idx ] = org <NEWLINE> <DEDENT> types . append ( opt_idx + 1 ) <NEWLINE> <DEDENT> print ( * types , sep = <STRING> ) <NEWLINE> <NL> <DEDENT> resolve ( ) <NEWLINE>
D = input ( ) <NEWLINE> c = list ( map ( int , list ( input ( ) ) ) ) <NEWLINE> for i in range ( 365 ) : <NEWLINE> <INDENT> s = list ( map ( int , list ( input ( ) ) ) ) <NEWLINE> <DEDENT> for i in range ( 365 ) : <NEWLINE> <INDENT> print ( s . index ( max ( s ) ) + 1 ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> <NL> d = int ( input ( ) ) <NEWLINE> c = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> s = [ ] <NEWLINE> for i in range ( d ) : <NEWLINE> <INDENT> s . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> <DEDENT> for i in range ( d ) : <NEWLINE> <INDENT> if i % 26 = 0 : <NEWLINE> <INDENT> a = np . argmax ( s [ 0 ] ) <NEWLINE> <DEDENT> print ( ( i + a ) % 26 + 1 ) <NEWLINE> <DEDENT>
<COMMENT> <NL> def scoring ( last_ , c , s , t , d , score ) : <NEWLINE> <COMMENT> <NL> <INDENT> score = s [ d ] [ t ] <NEWLINE> k = 8 <NEWLINE> <NL> for i in range ( len ( c ) ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <INDENT> score -= k * c [ i ] * ( d - last_ [ i ] ) + c * ( k * ( k + 1 ) ) / 2 <NEWLINE> <DEDENT> return score <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> score = 0 <NEWLINE> D = int ( input ( ) ) <NEWLINE> c = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> s = [ ] <NEWLINE> for i in range ( D ) : <NEWLINE> <INDENT> s . append ( [ int ( i ) for i in input ( ) . split ( ) ] ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> last = [ [ 0 for i in range ( len ( c ) ) ] for j in range ( D + 1 ) ] <COMMENT> <NEWLINE> <NL> ans = [ ] <NEWLINE> for d in range ( D ) : <NEWLINE> <COMMENT> <NL> <INDENT> last_dummy = last [ d ] [ : ] <NEWLINE> score = 0 <NEWLINE> t_d = 0 <NEWLINE> for t in range ( len ( c ) ) : <NEWLINE> <INDENT> last_dummy2 = last_dummy [ : ] <NEWLINE> last_dummy2 [ t ] = d + 1 <NEWLINE> if score < scoring ( last_dummy2 , c , s , t , d , score ) : <NEWLINE> <INDENT> score = scoring ( last_dummy2 , c , s , t , d , score ) <NEWLINE> <NL> t_d = t <NEWLINE> <NL> <DEDENT> <DEDENT> ans . append ( t_d ) <NEWLINE> last [ d ] [ t_d ] = d + 1 <NEWLINE> <NL> <NL> <COMMENT> <NL> for i in range ( len ( c ) ) : <NEWLINE> <INDENT> last [ d + 1 ] [ i ] = last [ d ] [ i ] <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> [ print ( ans [ i ] + 1 ) for i in range ( D ) ] <NEWLINE> <NL> <NL> <NL>
from time import time <NEWLINE> from random import randint <NEWLINE> <NL> from numba import njit <NEWLINE> from numpy import int64 <NEWLINE> <NL> @ njit ( <STRING> ) <NEWLINE> def func ( s , x ) : <NEWLINE> <INDENT> last = [ 0 ] * 26 <NEWLINE> score = 0 <NEWLINE> for i , v in enumerate ( x , 1 ) : <NEWLINE> <INDENT> last [ v ] = i <NEWLINE> c = 0 <NEWLINE> for j in range ( 26 ) : <NEWLINE> <INDENT> c += s [ j ] * ( last [ j ] - i ) <NEWLINE> <DEDENT> score = score + s [ i * 26 + v ] - c <NEWLINE> <DEDENT> return score <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> start = time ( ) <NEWLINE> d , * s = map ( int , open ( 0 ) . read ( ) . split ( ) ) <NEWLINE> s = int64 ( s ) <NEWLINE> x = int64 ( ( [ * range ( 26 ) ] * 15 ) [ : d ] ) <NEWLINE> M = func ( s , x ) <NEWLINE> while time ( ) - start < 1.7 : <NEWLINE> <INDENT> y = x . copy ( ) <NEWLINE> y [ randint ( 0 , d - 1 ) ] = randint ( 0 , 25 ) <NEWLINE> t = func ( s , y ) <NEWLINE> if t > M : <NEWLINE> <INDENT> M = t <NEWLINE> x = y <NEWLINE> <DEDENT> <DEDENT> print ( * x , sep = <STRING> ) <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE>
d = int ( input ( ) ) <NEWLINE> c = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> s = np . array ( [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( d ) ] ) <NEWLINE> <NL> init = s . argmax ( axis = 1 ) + 1 <NEWLINE> <NL> for i in range ( d ) : <NEWLINE> <INDENT> print ( init [ i ] ) <NEWLINE> <DEDENT>
def read_input ( filename ) : <NEWLINE> <INDENT> filein = open ( filename , <STRING> ) <NEWLINE> D = int ( filein . readline ( ) ) <NEWLINE> C = filein . readline ( ) . split ( ) <NEWLINE> C = [ int ( i ) for i in C ] <NEWLINE> S = [ list ( map ( int , filein . readline ( ) . split ( ) ) ) for x in range ( D ) ] <NEWLINE> T = [ int ( filein . readline ( ) ) for x in range ( D ) ] <NEWLINE> return D , C , S , T <NEWLINE> <NL> <NL> <DEDENT> def scoring ( S , D , T , C ) : <NEWLINE> <INDENT> res = [ ] <NEWLINE> last = [ 0 for _ in range ( 26 ) ] <NEWLINE> final = 0 <NEWLINE> for i in range ( D ) : <NEWLINE> <INDENT> dec = 0 <NEWLINE> for j in range ( 26 ) : <NEWLINE> <INDENT> for loc , val in enumerate ( T [ : i + 1 ] ) : <NEWLINE> <INDENT> if val == j + 1 : <NEWLINE> <INDENT> last [ j ] = loc + 1 <NEWLINE> <DEDENT> <DEDENT> dec += C [ j ] * ( i - last [ j ] + 1 ) <NEWLINE> <DEDENT> final += S [ i ] [ T [ i ] - 1 ] - dec <NEWLINE> res . append ( final ) <NEWLINE> <DEDENT> return res <NEWLINE> <NL> <NL> <DEDENT> D , C , S , T = read_input ( <STRING> ) <NEWLINE> res = scoring ( S , D , T , C ) <NEWLINE> for x in res : <NEWLINE> <INDENT> print ( x ) <NEWLINE> <DEDENT>
D = int ( input ( ) ) <NEWLINE> c = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> s = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( D ) ] <NEWLINE> t = [ int ( input ( ) ) for _ in range ( D ) ] <NEWLINE> <NL> v = 0 <NEWLINE> last = [ 0 for _ in range ( 26 ) ] <NEWLINE> <NL> for i in range ( D ) : <NEWLINE> <INDENT> last [ t [ i ] - 1 ] = i + 1 <NEWLINE> v += s [ i ] [ t [ i ] - 1 ] <NEWLINE> for j in range ( 26 ) : <NEWLINE> <INDENT> v -= c [ j ] * ( d - last [ j ] ) <NEWLINE> <DEDENT> print ( v ) <NEWLINE> <DEDENT>
D = int ( input ( ) ) <NEWLINE> c_list = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> s_list = [ ] <NEWLINE> for i in range ( d ) : <NEWLINE> <INDENT> s_list . append ( list ( map ( int , input ( ) . split ( <STRING> ) ) ) ) <NEWLINE> <DEDENT> t_list = [ ] <NEWLINE> for j in range ( d ) : <NEWLINE> <INDENT> t_list . append ( int ( input ( ) ) ) <NEWLINE> <DEDENT> last_list = [ 0 for k in range ( 26 ) ] <NEWLINE> score = 0 <NEWLINE> for day in range ( D ) : <NEWLINE> <INDENT> point = 0 <NEWLINE> point += s_list [ day ] [ t_list [ day ] ] <NEWLINE> last_list [ t_list [ day ] ] = day + 1 <NEWLINE> for c in c_list : <NEWLINE> <INDENT> point -= c * ( ( day + 1 ) - last_list [ t_list [ day ] ] ) <NEWLINE> <DEDENT> if ( point > 1000000 ) : <NEWLINE> <INDENT> score += point + 1000000 <NEWLINE> <DEDENT> <DEDENT> print ( score ) <NEWLINE>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> def I ( ) : return int ( input ( ) ) <NEWLINE> def MI ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def LI ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> d = I ( ) <NEWLINE> contest = LI ( ) <NEWLINE> mylist = [ LI ( ) for i in range ( 26 ) ] <NEWLINE> day = [ 0 ] * 26 <NEWLINE> result = 0 <NEWLINE> for i in range ( d ) : <NEWLINE> <INDENT> temp = I ( ) <NEWLINE> result += mylist [ i ] [ temp - 1 ] <NEWLINE> day = [ j + 1 for j in day ] <NEWLINE> day [ temp - 1 ] = 0 <NEWLINE> for k in range ( 26 ) : <NEWLINE> <INDENT> result -= day [ k ] * contest [ k ] <NEWLINE> <DEDENT> print ( result ) <NEWLINE> <DEDENT>
import sys <NEWLINE> import math <NEWLINE> from collections import deque <NEWLINE> from collections import defaultdict <NEWLINE> from copy import deepcopy <NEWLINE> from itertools import accumulate <COMMENT> <NEWLINE> def input ( ) : return sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> from functools import lru_cache <COMMENT> <NEWLINE> def choice_contest ( c , data , last , held , day , contest ) : <NEWLINE> <INDENT> contest -= 1 <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> last = [ i + 1 for i in last ] <NEWLINE> <COMMENT> <NL> last [ contest ] = 0 <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> if not contest in held : <NEWLINE> <INDENT> held . append ( contest ) <NEWLINE> <COMMENT> <NL> <DEDENT> d_satis = [ last [ i ] * c [ i ] for i in range ( 26 ) ] <NEWLINE> <COMMENT> <NL> return [ int ( data [ day ] [ contest ] ) - sum ( d_satis ) , last , held ] <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> d = int ( input ( ) ) <NEWLINE> c = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> data = [ input ( ) . split ( ) for _ in range ( d ) ] <NEWLINE> last = [ 0 ] * 26 <NEWLINE> held = [ ] <COMMENT> <NEWLINE> ans = 0 <NEWLINE> for i in range ( d ) : <NEWLINE> <INDENT> s , last , held = choice_contest ( c , data , last , held , i , contest = int ( input ( ) ) ) <NEWLINE> ans += s <NEWLINE> print ( ans ) <NEWLINE> <DEDENT> return 0 <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) import sys <NEWLINE> <DEDENT> import math <NEWLINE> from collections import deque <NEWLINE> from collections import defaultdict <NEWLINE> from copy import deepcopy <NEWLINE> from itertools import accumulate <COMMENT> <NEWLINE> def input ( ) : return sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> from functools import lru_cache <COMMENT> <NEWLINE> def choice_contest ( c , data , last , held , day , contest ) : <NEWLINE> <INDENT> contest -= 1 <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> last = [ i + 1 for i in last ] <NEWLINE> <COMMENT> <NL> last [ contest ] = 0 <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> if not contest in held : <NEWLINE> <INDENT> held . append ( contest ) <NEWLINE> <COMMENT> <NL> <DEDENT> d_satis = [ last [ i ] * c [ i ] for i in range ( 26 ) ] <NEWLINE> <COMMENT> <NL> return [ int ( data [ day ] [ contest ] ) - sum ( d_satis ) , last , held ] <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> d = int ( input ( ) ) <NEWLINE> c = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> data = [ input ( ) . split ( ) for _ in range ( d ) ] <NEWLINE> last = [ 0 ] * 26 <NEWLINE> held = [ ] <COMMENT> <NEWLINE> ans = 0 <NEWLINE> for i in range ( d ) : <NEWLINE> <INDENT> s , last , held = choice_contest ( c , data , last , held , i , contest = int ( input ( ) ) ) <NEWLINE> ans += s <NEWLINE> print ( ans ) <NEWLINE> <DEDENT> return 0 <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> <NL> d = int ( input ( ) ) <COMMENT> <NEWLINE> C = list ( map ( int , input ( ) . split ( ) ) ) <COMMENT> <NEWLINE> S = [ ] <COMMENT> <NEWLINE> T = [ ] <COMMENT> <NEWLINE> L = [ 0 ] * 26 <COMMENT> <NEWLINE> <NL> for _ in range ( d ) : <NEWLINE> <INDENT> S . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <COMMENT> <NEWLINE> <NL> <DEDENT> for _ in range ( d ) : <NEWLINE> <INDENT> T . append ( int ( input ( ) ) ) <NEWLINE> <NL> <DEDENT> print ( <STRING> , S ) <NEWLINE> print ( <STRING> , T ) <NEWLINE> <NL> sat = 0 <NEWLINE> S = np . array ( S ) <NEWLINE> print ( <STRING> , S . shape ) <NEWLINE> <NL> for i in range ( d ) : <NEWLINE> <INDENT> con_type = T [ i ] <NEWLINE> print ( i ) <NEWLINE> print ( <STRING> , con_type ) <NEWLINE> complain = 0 <NEWLINE> for j in range ( 26 ) : <NEWLINE> <INDENT> complain = complain + C [ j ] * ( d - L [ j ] ) <NEWLINE> <DEDENT> L [ con_type ] = d <COMMENT> <NEWLINE> <NL> sat = sat + S [ d ] [ con_type ] - complain <NEWLINE> sat = max ( 10 ^ 6 + sat , 0 ) <NEWLINE> <NL> print ( sat ) <NEWLINE> <NL> <DEDENT>
D = map ( int , input ( ) . split ( ) ) <NEWLINE> c = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> s = [ ] <NEWLINE> for _ in range ( D ) : <NEWLINE> <INDENT> s . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> <DEDENT> lasts = [ 0 for i in range ( len ( c ) ) ] <NEWLINE> ans = 0 <NEWLINE> for d in range ( 1 , D + 1 ) : <NEWLINE> <INDENT> t = int ( input ( ) ) - 1 <NEWLINE> lasts [ t ] = d <NEWLINE> ans += s [ d ] [ t ] <NEWLINE> for i in range ( len ( c ) ) : <NEWLINE> <INDENT> ans -= c [ i ] * ( d - lasts [ i ] ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import os <NEWLINE> import sys <NEWLINE> <NL> import numpy as np <NEWLINE> <NL> <NL> def bitree_sum ( bit , t , i ) : <NEWLINE> <INDENT> s = 0 <NEWLINE> while i > 0 : <NEWLINE> <INDENT> s += bit [ t , i ] <NEWLINE> i ^= i & - i <NEWLINE> <DEDENT> return s <NEWLINE> <NL> <NL> <DEDENT> def bitree_add ( bit , n , t , i , x ) : <NEWLINE> <INDENT> while i <= n : <NEWLINE> <INDENT> bit [ t , i ] += x <NEWLINE> i += i & - i <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def bitree_lower_bound ( bit , n , d , t , x ) : <NEWLINE> <INDENT> sum_ = 0 <NEWLINE> pos = 0 <NEWLINE> for i in range ( d , - 1 , - 1 ) : <NEWLINE> <INDENT> k = pos + ( 1 << i ) <NEWLINE> if k <= n and sum_ + bit [ t , k ] < x : <NEWLINE> <INDENT> sum_ += bit [ t , k ] <NEWLINE> pos += 1 << i <NEWLINE> <DEDENT> <DEDENT> return pos + 1 <NEWLINE> <NL> <NL> <DEDENT> def initial_score ( d , ccc , sss , ttt ) : <NEWLINE> <INDENT> bit_n = d + 2 <NEWLINE> bit = np . zeros ( ( 26 , bit_n ) , dtype = np . int64 ) <NEWLINE> INF = 10 ** 18 <NEWLINE> for t in range ( 26 ) : <NEWLINE> <INDENT> bitree_add ( bit , bit_n , t , bit_n - 1 , INF ) <NEWLINE> <NL> <DEDENT> last = np . full ( 26 , - 1 , dtype = np . int64 ) <NEWLINE> score = 0 <NEWLINE> <NL> for i in range ( d ) : <NEWLINE> <INDENT> t = ttt [ i ] <NEWLINE> score += sss [ i , t ] <NEWLINE> for u in range ( 26 ) : <NEWLINE> <INDENT> if u == t : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> score -= ccc [ u ] * ( i - last [ u ] ) <NEWLINE> <DEDENT> last [ t ] = i <NEWLINE> bitree_add ( bit , bit_n , t , i + 1 , 1 ) <NEWLINE> <NL> <DEDENT> return bit , score <NEWLINE> <NL> <NL> <DEDENT> def update_score ( bit , bit_n , bit_d , ccc , sss , ttt , d , q ) : <NEWLINE> <INDENT> diff = 0 <NEWLINE> t = ttt [ d ] <NEWLINE> bitree_add ( bit , bit_n , t , d + 1 , - 1 ) <NEWLINE> k = bitree_sum ( bit , t , d + 1 ) <NEWLINE> c = bitree_lower_bound ( bit , bit_n , bit_d , t , k ) - 1 <NEWLINE> e = bitree_lower_bound ( bit , bit_n , bit_d , t , k + 1 ) - 1 <NEWLINE> b = ccc [ t ] <NEWLINE> diff -= b * ( d - c + 1 ) * ( e - d ) <NEWLINE> diff -= sss [ d , t ] <NEWLINE> <NL> k = bitree_sum ( bit , q , d + 1 ) <NEWLINE> c = bitree_lower_bound ( bit , bit_n , bit_d , q , k ) - 1 <NEWLINE> e = bitree_lower_bound ( bit , bit_n , bit_d , q , k + 1 ) - 1 <NEWLINE> b = ccc [ q ] <NEWLINE> diff += b * ( d - c + 1 ) * ( e - d ) <NEWLINE> diff += sss [ d , q ] <NEWLINE> <NL> ttt [ d ] = q <NEWLINE> <NL> return diff <NEWLINE> <NL> <NL> <DEDENT> def solve ( inp ) : <NEWLINE> <INDENT> d = inp [ 0 ] <NEWLINE> ccc = inp [ 1 : 27 ] <NEWLINE> sss = np . zeros ( ( d , 26 ) , dtype = np . int64 ) <NEWLINE> for r in range ( d ) : <NEWLINE> <INDENT> sss [ r ] = inp [ 27 + r * 26 : 27 + ( r + 1 ) * 26 ] <NEWLINE> <DEDENT> ttt = inp [ 27 + d * 26 : 27 + d * 27 ] - 1 <NEWLINE> m = inp [ 27 + d * 27 ] <NEWLINE> ddd = inp [ 28 + d * 27 : : 2 ] - 1 <NEWLINE> qqq = inp [ 29 + d * 27 : : 2 ] - 1 <NEWLINE> <NL> bit , score = initial_score ( d , ccc , sss , ttt ) <NEWLINE> bit_n = d + 2 <NEWLINE> bit_d = int ( np . log2 ( bit_n ) ) <NEWLINE> <NL> buf = np . zeros ( m , dtype = np . int64 ) <NEWLINE> <NL> for i in range ( m ) : <NEWLINE> <INDENT> diff = update_score ( bit , bit_n , bit_d , ccc , sss , ttt , ddd [ i ] , qqq [ i ] ) <NEWLINE> score += diff <NEWLINE> buf [ i ] = score <NEWLINE> <NL> <DEDENT> return buf <NEWLINE> <NL> <NL> <DEDENT> if sys . argv [ - 1 ] == <STRING> : <NEWLINE> <INDENT> from numba . pycc import CC <NEWLINE> <NL> cc = CC ( <STRING> ) <NEWLINE> cc . export ( <STRING> , <STRING> ) ( bitree_sum ) <NEWLINE> cc . export ( <STRING> , <STRING> ) ( bitree_add ) <NEWLINE> cc . export ( <STRING> , <STRING> ) ( bitree_lower_bound ) <NEWLINE> cc . export ( <STRING> , <STRING> ) ( initial_score ) <NEWLINE> cc . export ( <STRING> , <STRING> ) ( update_score ) <NEWLINE> cc . export ( <STRING> , <STRING> ) ( solve ) <NEWLINE> cc . compile ( ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> if os . name == <STRING> : <NEWLINE> <COMMENT> <NL> <INDENT> from my_module import bitree_sum , bitree_add , bitree_lower_bound , initial_score , update_socer , solve <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> from numba import njit <NEWLINE> <NL> bitree_sum = njit ( <STRING> , cache = True ) ( bitree_sum ) <NEWLINE> bitree_add = njit ( <STRING> , cache = True ) ( bitree_add ) <NEWLINE> bitree_lower_bound = njit ( <STRING> , cache = True ) ( bitree_lower_bound ) <NEWLINE> initial_score = njit ( <STRING> , cache = True ) ( initial_score ) <NEWLINE> update_score = njit ( <STRING> , cache = True ) ( update_score ) <NEWLINE> solve = njit ( <STRING> , cache = True ) ( solve ) <NEWLINE> print ( <STRING> , file = sys . stderr ) <NEWLINE> <NL> <DEDENT> inp = np . fromstring ( sys . stdin . read ( ) , dtype = np . int64 , sep = <STRING> ) <NEWLINE> ans = solve ( inp ) <NEWLINE> print ( <STRING> . join ( map ( str , ans ) ) ) <NEWLINE>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> import numpy as np <NEWLINE> from numba import njit <NEWLINE> <NL> <NL> def read ( ) : <NEWLINE> <INDENT> D = int ( input ( ) . strip ( ) ) <NEWLINE> <COMMENT> <NL> C = np . fromstring ( input ( ) . strip ( ) , dtype = np . int32 , sep = <STRING> ) <NEWLINE> <COMMENT> <NL> S = np . empty ( ( D , 26 ) , dtype = np . int32 ) <NEWLINE> for i in range ( D ) : <NEWLINE> <INDENT> s = np . fromstring ( input ( ) . strip ( ) , dtype = np . int32 , sep = <STRING> ) <NEWLINE> S [ i , : ] = s [ : ] <NEWLINE> <COMMENT> <NL> <DEDENT> T = np . array ( [ int ( input ( ) . strip ( ) ) for i in range ( D ) ] , dtype = np . int32 ) <NEWLINE> T -= 1 <NEWLINE> <COMMENT> <NL> M = int ( input ( ) . strip ( ) ) <NEWLINE> <COMMENT> <NL> DQ = np . empty ( ( M , 2 ) , dtype = np . int32 ) <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> dq = np . fromstring ( input ( ) . strip ( ) , dtype = np . int32 , sep = <STRING> ) <NEWLINE> DQ [ i , : ] = dq [ : ] <NEWLINE> <DEDENT> DQ -= 1 <NEWLINE> return D , C , S , T , M , DQ <NEWLINE> <NL> <NL> <DEDENT> @ njit <NEWLINE> def satisfaction ( d , C , S , T , last ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> v = 0 <NEWLINE> <COMMENT> <NL> p = T [ d ] <NEWLINE> v += S [ d , p ] <NEWLINE> last [ p ] = d <NEWLINE> <COMMENT> <NL> for i in range ( 26 ) : <NEWLINE> <INDENT> v -= C [ i ] * ( d - last [ i ] ) <NEWLINE> <DEDENT> return v <NEWLINE> <NL> <NL> <DEDENT> @ njit <NEWLINE> def change_schedule ( D , C , S , T , d , q , cumsat ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> p = T [ d ] <NEWLINE> dp1 , dp3 , dq1 , dq3 = - 1 , D , - 1 , D <NEWLINE> for i in range ( 0 , d ) : <NEWLINE> <INDENT> if T [ i ] == p : <NEWLINE> <INDENT> dp1 = i <NEWLINE> <DEDENT> if T [ i ] == q : <NEWLINE> <INDENT> dq1 = i <NEWLINE> <DEDENT> <DEDENT> for i in range ( d + 1 , D ) : <NEWLINE> <INDENT> if T [ i ] == p : <NEWLINE> <INDENT> dp3 = i <NEWLINE> <DEDENT> if T [ i ] == q : <NEWLINE> <INDENT> dq3 = i <NEWLINE> <DEDENT> <DEDENT> cumsat = cumsat - S [ d , p ] + S [ d , q ] - C [ p ] * ( dp3 - d ) * ( d - dp1 ) + C [ q ] * ( dq3 - d ) * ( d - dq1 ) <NEWLINE> return cumsat <NEWLINE> <NL> <DEDENT> @ njit <NEWLINE> def solve ( D , C , S , T , M , DQ ) : <NEWLINE> <COMMENT> <NL> <INDENT> last = - np . ones ( 26 , dtype = np . int32 ) <NEWLINE> <COMMENT> <NL> cumsat = 0 <NEWLINE> <COMMENT> <NL> for d in range ( D ) : <NEWLINE> <INDENT> sat = satisfaction ( d , C , S , T , last ) <NEWLINE> cumsat += sat <NEWLINE> <DEDENT> for d , q in DQ : <NEWLINE> <INDENT> cumsat = change_schedule ( D , C , S , T , d , q , cumsat ) <NEWLINE> T [ d ] = q <NEWLINE> print ( cumsat ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> inputs = read ( ) <NEWLINE> outputs = solve ( * inputs ) <NEWLINE> if outputs is not None : <NEWLINE> <INDENT> print ( <STRING> % str ( outputs ) ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> print ( a + a * a + a * a * a ) <NEWLINE>
str1 = list ( input ( ) ) <NEWLINE> str2 = list ( input ( ) ) <NEWLINE> count = 0 <NEWLINE> for i in range ( len ( str1 ) ) : <NEWLINE> <INDENT> if str1 [ i ] != str2 [ i ] : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
a = input ( ) <NEWLINE> print ( a + a ** 2 + a ** 3 ) <NEWLINE>
a = input ( ) <NEWLINE> n = 2 <NEWLINE> m = 3 <NEWLINE> print ( a + a ** n + a ** m ) <NEWLINE>
num = input ( ) <NEWLINE> print ( num + num ** 2 + num ** 3 ) <NEWLINE>
a = int ( input ( ) ) <NEWLINE> print ( a + a ** 2 + a ** * 3 ) <NEWLINE>
a = int ( input ( ) ) <NEWLINE> <NL> ans = a ( 1 + a + a ** 2 ) <NEWLINE> print ( int ( ans ) ) <NEWLINE>
print ( int ( a + a ** 2 + a ** 3 ) ) <NEWLINE>
a = int ( input ( ) ) <NEWLINE> return a + a ** 2 + a ** 3 <NEWLINE>
s = input ( ) <NEWLINE> <NL> int a = s * s * s + s * s + s <NEWLINE> <NL> <INDENT> return <NEWLINE> <DEDENT>
from sys import stdin <NEWLINE> a = stdin . readline ( ) . rstrip ( ) <NEWLINE> print ( a + a ** 2 + a ** 3 ) <NEWLINE>
a = int ( input ( ) ) <NEWLINE> <NL> print ( round ( a * a * a + a * a + a ) <NEWLINE>
print ( a + a * a + a * a * a ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> print ( ( a ) + ( a * a ) + ( a ** 3 ) ) <NEWLINE>
a = input ( ) <NEWLINE> a + a ** 2 + a ** 3 = A <NEWLINE> print ( A ) <NEWLINE>
def calc ( int : a ) -> int : <NEWLINE> <INDENT> return a + a ** 2 + a ** 3 <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> a = int ( input ( ) ) <NEWLINE> print ( calc ( a ) ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> a = int ( sys . stdin . readline ( ) ) <NEWLINE> <NL> print ( a + a * a + a * a * a <NEWLINE>
a = int ( raw_input ( ) ) <NEWLINE> print ( a + a ** 2 + a ** 3 ) <NEWLINE>
a = input ( ) <NEWLINE> print ( a + a ** 2 + a ** 3 ) <NEWLINE>
int b <NEWLINE> b = a + a ^ 2 + a ^ 3 <NEWLINE> return b <NEWLINE>
a = input ( ) <NEWLINE> ans = a + ( a ** 2 ) + ( a ** 3 ) <NEWLINE> print ( ans ) <NEWLINE>
A = input ( ) <NEWLINE> <NL> print ( A + A ** 2 + A ** 3 ) <NEWLINE>
a = int ( ( input ( ) ) <NEWLINE> print ( a + a ** 2 + a ** 3 ) <NEWLINE>
a = input ( ) <NEWLINE> print ( a + a ** 2 + a ** 3 ) <NEWLINE>
a = input ( ) <NEWLINE> b = a + a * a + a * a * a <NEWLINE> print ( int ( b ) ) <NEWLINE>
S = input ( ) <NEWLINE> T = input ( ) <NEWLINE> <NL> count = 0 <NEWLINE> for i in range ( len ( S ) ) : <NEWLINE> <INDENT> if S [ i ] != T [ i ] : <NEWLINE> <INDENT> count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( count ) <NEWLINE> <NL>
a = int ( input ( ) ) <NEWLINE> print ( a + ( a ** 2 ) + ( a ** * 3 ) ) <NEWLINE>
a = int ( input ( ) ) <NEWLINE> input ( a + a * a + a ** 3 ) <NEWLINE>
def calc ( n ) : <NEWLINE> <INDENT> s = n + n ** 2 + n ** 3 <NEWLINE> res = int ( s ) <NEWLINE> return res <NEWLINE> <DEDENT> for i in range ( int ( input ( ) ) ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> print ( calc ( n ) ) <NEWLINE> <DEDENT>
a = n <NEWLINE> print ( a + a ** 2 + a ** 3 ) <NEWLINE>
a = input ( ) <NEWLINE> print ( a + ( a ** 2 ) + ( a ** 3 ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = 0 <NEWLINE> for i in range ( 1 , 4 ) : <NEWLINE> <INDENT> s += a ** i <NEWLINE> <DEDENT>
a = int ( input ( ) ) <NEWLINE> b = a ** a <NEWLINE> print ( int ( a + b + a * b ) <NEWLINE>
a = int ( input ( ) ) <NEWLINE> ans = a + a ** 2 + a ** * 3 <NEWLINE> print ( ans ) <NEWLINE>
a = input ( ) <NEWLINE> print ( a + ( a * a ) + ( a * a * a ) ) <NEWLINE>
d = int ( input ( ) ) <NEWLINE> print ( int ( d + d ** 2 + d ** * 3 ) ) <NEWLINE>
a = input ( ) <NEWLINE> print ( a + a ** 2 + a ** 3 ) <NEWLINE>
a = input ( ) <NEWLINE> first_a = a <NEWLINE> second_a = a ** 2 <NEWLINE> third_a = a ** 3 <NEWLINE> sum_a = first_a + second_a + third_a <NEWLINE>
a = int ( input ( ) ) <NEWLINE> value = a + ( a * a ) + ( a * a * a * ) <NEWLINE> print ( value ) <NEWLINE>
a = input ( ) <NEWLINE> a = int ( N ) <NEWLINE> <NL> print ( a + a * a + a * a * a ) <NEWLINE>
a = int ( intput ( ) ) <NEWLINE> print ( a + a ^ 2 + a ^ 3 ) <NEWLINE>
a = input ( ) <NEWLINE> print ( a + a * a + a * a * a ) <NEWLINE>
a = input ( ) <NEWLINE> print ( a + a * a + a * a * a ) <NEWLINE>
print ( a + a ** 2 + a ** 3 ) <NEWLINE>
a = input ( ) <NEWLINE> print ( a + a * a + a * a * a ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> a = int ( input ( ) ) <NEWLINE> answer = a + a ** 2 + a ** 3 <NEWLINE> print ( answer ) <NEWLINE> <NL> <DEDENT> if __name__ = <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
a = int ( input ( ) ) <NEWLINE> print ( int ( a + ( a ** 2 ) + ( a ** 3 ) ) <NEWLINE>
a = int ( input ( ) ) <NEWLINE> print ( a * a ** 2 * a ** * 3 ) <NEWLINE>
s = str ( input ( ) ) <NEWLINE> t = str ( input ( ) ) <NEWLINE> count = 0 <NEWLINE> <NL> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> if s [ i ] != t [ i ] : <NEWLINE> <INDENT> count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
a = int ( input ( ) ) <NEWLINE> print ( a + a ** + a ** * ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> print ( a + a ** 2 + a ** 3 ) <NEWLINE>
int a <NEWLINE> int x <NEWLINE> x = a + ( a * a ) + ( a * a * a ) <NEWLINE> ptint ( x ) <NEWLINE>
a - int ( input ( ) ) <NEWLINE> <NL> print ( a + a ** 2 + a ** 3 ) <NEWLINE>
a = input ( ) <NEWLINE> print ( a + a ** 2 + a ** 3 ) <NEWLINE>
a = int ( input ) <NEWLINE> b = a + a ^ 2 * a ^ 3 <NEWLINE> print ( b ) <NEWLINE>
a = int ( input ( ) ) <NEWLINE> print ( a + a ** 2 + a ** * a ) <NEWLINE>
a = int ( input ( ) ) <NEWLINE> print ( a + a ** 2 + a ** * 3 ) <NEWLINE>
N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A . append ( 10 ** 9 + 1 ) <NEWLINE> B . append ( 10 ** 9 + 1 ) <NEWLINE> <NL> Ac = 0 <NEWLINE> Bc = 0 <NEWLINE> Time = 0 <NEWLINE> for _ in range ( N + M ) : <NEWLINE> <INDENT> if A [ Ac ] > B [ Bc ] : <NEWLINE> <INDENT> Time += B [ Bc ] <NEWLINE> Bc += 1 <NEWLINE> if Time > K : <NEWLINE> <INDENT> Bc -= 1 <NEWLINE> Time -= B [ Bc ] <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> Time += A [ Ac ] <NEWLINE> Ac += 1 <NEWLINE> if Time > K : <NEWLINE> <INDENT> Ac -= 1 <NEWLINE> Time -= A [ Ac ] <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( Ac + Bc ) <NEWLINE>
a = input ( ) <NEWLINE> <NL> print ( a + pow ( a , 2 ) + pow ( a , 3 ) ) <NEWLINE>
a = input ( ) <NEWLINE> <NL> print ( int ( a + a ** 2 + a ** 3 ) ) <NEWLINE>
a = int ( intput ( ) ) <NEWLINE> <NL> print ( a + a * a + a * a * a ) <NEWLINE>
N = 10 ** 8 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> b = 0 <NEWLINE> <NL> <DEDENT> a = int ( input ( ) ) <NEWLINE> print ( a + a ** 2 + a ** 3 ) <NEWLINE>
input = int ( input ( ) ) <NEWLINE> print ( a + a ** 2 + a ** 3 ) <NEWLINE>
A = int ( input ( ) ) <NEWLINE> print ( a + a ** 2 + a ** 3 ) <NEWLINE>
2 import sys <NEWLINE> import math <NEWLINE> import itertools as it <NEWLINE> def I ( ) : return int ( sys . stdin . readline ( ) . replace ( <STRING> , <STRING> ) ) <NEWLINE> def I2 ( ) : return map ( int , sys . stdin . readline ( ) . replace ( <STRING> , <STRING> ) . split ( ) ) <NEWLINE> def S ( ) : return str ( sys . stdin . readline ( ) . replace ( <STRING> , <STRING> ) ) <NEWLINE> def L ( ) : return list ( sys . stdin . readline ( ) . replace ( <STRING> , <STRING> ) ) <NEWLINE> def Intl ( ) : return [ int ( k ) for k in sys . stdin . readline ( ) . replace ( <STRING> , <STRING> ) . split ( ) ] <NEWLINE> def Lx ( k ) : return list ( map ( lambda x : int ( x ) * - k , sys . stdin . readline ( ) . replace ( <STRING> , <STRING> ) . split ( ) ) ) <NEWLINE> <NL> if __name__ == <STRING> : <NEWLINE> <INDENT> a = I ( ) <NEWLINE> print ( a + a ** 2 + a ** 3 ) <NEWLINE> <DEDENT>
a = int ( input ( ) ) <NEWLINE> print ( round ( ( a * ( a - ( - 1 + math . sqrt ( 3 ) * ( 1j ) ) / 2 ) * ( a - ( - 1 - math . sqrt ( 3 ) * ( 1j ) ) / 2 ) ) . real ) ) <NEWLINE>
a = int ( input ( ) ) <NEWLINE> print ( a + a * a ) + ( a * a * a ) <NEWLINE>
int = int ( input ( ) ) <NEWLINE> print ( a * a * a + a * a + a ) <NEWLINE>
num v = input ( <STRING> ) <NEWLINE> sum1 = num + num ^ 2 + num ^ 3 <NEWLINE>
a = input ( <STRING> ) <NEWLINE> print ( a + ( a ** 2 ) + ( a ** 3 ) ) <NEWLINE>
a = input ( ) <NEWLINE> print ( a + a ** 2 + a ** 3 ) <NEWLINE>
a = input ( ) <NEWLINE> <NL> print ( a + a ** 2 + a ** 3 ) <NEWLINE>
def main ( a ) : <NEWLINE> <INDENT> return a + a ** 2 + a ** 3 <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> a = input ( ) <NEWLINE> print ( main ( a ) ) <NEWLINE> <DEDENT>
import argparse <NEWLINE> <NL> parser = argparse . ArgumentParser ( ) <NEWLINE> <NL> parser . add_argument ( <STRING> , metavar = <STRING> , type = int ) <NEWLINE> <NL> args = parser . parse_args ( ) <NEWLINE> <NL> a = args . input <NEWLINE> <NL> print ( <STRING> . format ( a + a * a + a * a * a ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> print ( int ( a + a ** 2 + a ** 3 ) ) <NEWLINE>
a = int ( inupt ( ) ) <NEWLINE> print ( a + a * a + a * a * a ) <NEWLINE>
a = input ( ) <NEWLINE> print ( a + a * a + a * a * a ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> print ( a + a ** 2 + a ** 3 ) <NEWLINE>
a = int ( input ( ) ) <NEWLINE> print ( a + a ** 2 + a ** * 3 ) <NEWLINE>
a = str ( input ( ) ) <NEWLINE> s = a + a ** 2 + a ** 3 <NEWLINE> print ( s ) <NEWLINE>
a = input ( ) <NEWLINE> print ( a + a ** 2 + a ** 3 ) <NEWLINE>
a = int ( input ( ) ) <NEWLINE> print ( a + a ** 2 + a ** 3 <NEWLINE>
a = input ( ) <NEWLINE> print ( a + a ** 2 + a ** 3 ) <NEWLINE>
a = int ( input ( ) ) <NEWLINE> ans = a + a * a + a * a * a <NEWLINE> print ( ans ) a = int ( input ( ) ) <NEWLINE>
number = int ( intput ( ) ) <NEWLINE> print ( number + number ** 2 + number ** 3 ) <NEWLINE>
a = input ( ) <NEWLINE> <NL> print ( a + a * a + a * a * a ) <NEWLINE>
a = int ( input ( ) ) <NEWLINE> print ( a + a ** 2 + a ** * 3 ) <NEWLINE>
a = int ( input ( ) ) <NEWLINE> print ( a ( 1 + a + a * a ) ) <NEWLINE>
a = int ( a ) <NEWLINE> x = a + a ** 2 + a ** 3 <NEWLINE> print ( x ) <NEWLINE>
a = int ( input ( ) ) print ( a + a * a + a ** 3 ) <NEWLINE>
a = int ( input ( ) ) <NEWLINE> print ( sum ( a + a ** 2 + a ** 3 ) ) <NEWLINE>
a = int ( input ( <STRING> ) ) <NEWLINE> n1 = int ( <STRING> % a ) <NEWLINE> n2 = int ( <STRING> % ( a , a ) ) <NEWLINE> n3 = int ( <STRING> % ( a , a , a ) ) <NEWLINE> print ( n1 + n2 + n3 <NEWLINE>
a = int ( input ( ) ) <NEWLINE> ans = a * ( 1 + a + a * a * ) <NEWLINE> print ( ans ) <NEWLINE>
a = int ( input ( ) ) <NEWLINE> print ( int ( a + a ^ 2 + a3 ) ) <NEWLINE>
a = input ( ) <NEWLINE> print ( a + a * a + a * a * a ) <NEWLINE>
a = input ( ) <NEWLINE> print ( a + a ** 2 + a ** 3 ) <NEWLINE>
a = int ( input ) <NEWLINE> print ( a + a ** 2 + a ** 3 ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> print ( a ^ 3 + a ^ 2 + a ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> print ( a * ( 1 + a + a * a ) ) <NEWLINE>
A = int ( input ( ) ) <NEWLINE> <NL> print ( a + a ** 2 + a ** 3 ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> import sys <NEWLINE> def input ( ) : return sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> a = int ( input ( ) ) <NEWLINE> for i in range ( 3 ) : <NEWLINE> <INDENT> ans += a ** ( i + 1 ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
a = int ( input ( ) ) <NEWLINE> ) <NEWLINE> a = int ( a ** 3 ) <NEWLINE> print ( a ) <NEWLINE> <NL>
N = int ( input ( ) ) <NEWLINE> print ( a + a ** 2 + a ** 3 ) <NEWLINE>
a = int ( input ( ) ) <NEWLINE> res = sum ( a + ( a ** 2 ) + ( a ** 3 ) ) <NEWLINE> print ( res ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> print ( a + a * a + a * a * a ) <NEWLINE>
val = input ( ) <NEWLINE> <NL> res = val + val ** 2 + val ** 3 <NEWLINE> <NL> print ( res . astype ( int ) ) <NEWLINE>
a = int ( input ) <NEWLINE> print ( a + a ** 2 + a ** 3 ) <NEWLINE>
a = int ( input ( ) ) <NEWLINE> total = a + a ** 2 + a ** 3 <NEWLINE> ptint ( total ) <NEWLINE>
a = input ( ) <NEWLINE> ans = a + a ^ 2 + a ^ 3 <NEWLINE> print ans <NEWLINE>
N = int ( input ( ) ) <NEWLINE> print ( N + N ** 2 + N ** * 3 ) <NEWLINE>
a = input ( ) <NEWLINE> print ( a + a * a + a * a * a ) <NEWLINE>
a = input ( ) <NEWLINE> <NL> x = a + ( a * a ) + ( a * a * a ) <NEWLINE> <NL> print ( x ) <NEWLINE>
a = int ( input ( ) ) <NEWLINE> if 1 <= a <= 10 : <NEWLINE> print ( a + a ** 2 + a ** 3 ) <NEWLINE>
import sys <NEWLINE> <COMMENT> <NL> import math <NEWLINE> import collections <NEWLINE> <COMMENT> <NL> import bisect <NEWLINE> import itertools <NEWLINE> import fractions <NEWLINE> <COMMENT> <NL> import copy <NEWLINE> <COMMENT> <NL> import decimal <NEWLINE> <COMMENT> <NL> import queue <NEWLINE> <NL> <COMMENT> <NL> <NL> sys . setrecursionlimit ( 10000001 ) <NEWLINE> INF = 10 ** 16 <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> <COMMENT> <NL> <NL> ni = lambda : int ( sys . stdin . readline ( ) ) <NEWLINE> ns = lambda : map ( int , sys . stdin . readline ( ) . split ( ) ) <NEWLINE> na = lambda : list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> <COMMENT> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> i = nis ( ) <NEWLINE> print ( i + i ** 2 + i ** 3 ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> print ( a + a * a + a * a * a ) <NEWLINE>
<NL> def function ( a ) : <NEWLINE> <INDENT> return a + a ** 2 + a ** * 3 <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> a = int ( input ( ) ) <NEWLINE> function ( a ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> def answer ( ) : <NEWLINE> <INDENT> N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <NL> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> a , b = [ 0 ] , [ 0 ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> a . append ( a [ i ] + A [ i ] ) <NEWLINE> <DEDENT> for i in range ( M ) : <NEWLINE> <INDENT> b . append ( b [ i ] + B [ i ] ) <NEWLINE> <NL> <DEDENT> ans , j = 0 , M <NEWLINE> for i in range ( N + 1 ) : <NEWLINE> <INDENT> if a [ i ] > K : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> while b [ j ] > K - a [ i ] : <NEWLINE> <INDENT> j -= 1 <NEWLINE> <DEDENT> ans = max ( ans , i + j ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> answer ( ) <NEWLINE> <DEDENT>
N = 10 ** 7 <NEWLINE> <NL> <NL> def f ( x ) : <NEWLINE> <INDENT> return x <NEWLINE> <NL> <NL> <DEDENT> M = 10 ** 5 <NEWLINE> arr = list ( range ( M ) ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> t = ( i + i * i - i ) % M <COMMENT> <NEWLINE> b = arr [ t ] <COMMENT> <NEWLINE> b = f ( b ) <COMMENT> <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> a = int ( input ( ) ) <NEWLINE> print ( a + a ** 2 + a ** 3 ) <NEWLINE>
n = int ( intput ( ) ) <NEWLINE> <NL> print ( n + n ** n + n ** * n ) <NEWLINE>
a = input ( ) <NEWLINE> print ( a + a ** 2 + a ** 3 ) <NEWLINE>
a = input ( ) <NEWLINE> my_result = a + a * a + a * a * a <NEWLINE> print ( my_result ) <NEWLINE>
a = int ( input ( ) ) <NEWLINE> b = a ** 2 <NEWLINE> c = a ** * 3 <NEWLINE> print ( a + b + c ) <NEWLINE>
a = input ( ) <NEWLINE> print ( a + a * a + a * a * a ) <NEWLINE>
print ( int ( a + a ^ 2 + a ^ 3 ) ) <NEWLINE>
ソースコード <NEWLINE> <NL> Copy <NEWLINE> Copy <NEWLINE> def a172 ( a ) : <NEWLINE> <NL> <INDENT> return a + a ** 2 + a ** 3 <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> a = int ( input ( ) ) <NEWLINE> print ( a172 ( a ) ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
S = str ( input ( ) ) <NEWLINE> T = str ( input ( ) ) <NEWLINE> length = len ( S ) <NEWLINE> listS = list ( S ) <NEWLINE> listT = list ( T ) <NEWLINE> num = len ( T ) <NEWLINE> res = 0 <NEWLINE> for i in range ( length ) : <NEWLINE> <INDENT> if ( listS [ num - 1 ] != listT [ num - 1 ] ) : <NEWLINE> <INDENT> res += 1 <NEWLINE> <DEDENT> num -= 1 <NEWLINE> <DEDENT> print ( res ) <NEWLINE>
a = int ( inut ( ) ) <NEWLINE> <NL> print ( a ** 3 + a ** 2 + a ) <NEWLINE>
a = input ( ) <NEWLINE> print ( int ( a + a ** 2 + a ** 3 ) ) <NEWLINE>
num = input ( ) <NEWLINE> <NL> answer = num + num * num + num * num * num <NEWLINE> <NL> print ( answer ) <NEWLINE>
a = input ( ) <NEWLINE> print ( 1 + a ** 2 + a ** 3 ) <NEWLINE>
<INDENT> a = int ( input ( ) ) <NEWLINE> sum = int ( a + a * a + a * a * a ) <NEWLINE> print ( sum ) <NEWLINE> <DEDENT>
num = int ( input ( ) ) <NEWLINE> print ( num + num * mum + num ** 3 ) <NEWLINE>
a = input ( ) <NEWLINE> print ( a + a ** 2 + a ** 3 ) <NEWLINE>
a + a ** 2 + a ** 10 <NEWLINE>
a = int ( input ( ) ) <NEWLINE> B = 0 <NEWLINE> C = 0 <NEWLINE> D = 0 <NEWLINE> B = A <NEWLINE> C = a * a <NEWLINE> D = a * a * a <NEWLINE> print ( B + C + D ) <NEWLINE>
a = int ( input ( ) ) <NEWLINE> print ( a + pow ( a , 2 ) + pow ( a , 3 ) <NEWLINE>
a = input ( ) <NEWLINE> print ( a + a ** 2 + a ** 3 ) <NEWLINE>
a = input ( ) <NEWLINE> print ( a + a ** 2 + a ** 3 ) <NEWLINE>
s = input ( ) <NEWLINE> t = input ( ) <NEWLINE> n = len ( s ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if s [ i ] != t [ i ] : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
a = input ( ) <NEWLINE> x = a + a * a + a * a * a <NEWLINE> print ( x ) <NEWLINE>
a , b = [ input ( ) for i in range ( 2 ) ] <NEWLINE> <NL> count = 0 <NEWLINE> out = 0 <NEWLINE> if a == b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> c = list ( a ) <NEWLINE> d = list ( b ) <NEWLINE> for i in c : <NEWLINE> <INDENT> if i == d [ count ] : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> out = out + 1 <NEWLINE> <DEDENT> count = count + 1 <NEWLINE> <DEDENT> print ( str ( out ) ) <NEWLINE> <DEDENT>
input = int ( raw_input ( ) ) <NEWLINE> print ( input + input ** 2 + input ** 3 ) <NEWLINE>
a = input ( ) <NEWLINE> <NL> print ( a + a ** 2 + a ** 3 ) <NEWLINE>
<STRING> <NEWLINE> <NL> import sys <NEWLINE> from bisect import * <NEWLINE> from math import floor , sqrt , ceil , factorial as F , gcd , pi <NEWLINE> from itertools import chain , combinations , permutations , accumulate <NEWLINE> from collections import Counter , defaultdict , OrderedDict , deque <NEWLINE> from array import array <NEWLINE> INT_MAX = sys . maxsize <NEWLINE> INT_MIN = - ( sys . maxsize ) - 1 <NEWLINE> mod = 1000000007 <NEWLINE> ch = <STRING> <NEWLINE> lcm = lambda a , b : ( a * b ) // gcd ( a , b ) <NEWLINE> setbit = lambda x : bin ( x ) [ 2 : ] . count ( <STRING> ) <NEWLINE> input = lambda : sys . stdin . readline ( ) <NEWLINE> <NL> def solve ( ) : <NEWLINE> <INDENT> n = int ( sys . stdin . readline ( ) ) <NEWLINE> print ( a + a ** 2 + a ** 3 ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> sys . stdin = open ( <STRING> , <STRING> ) <NEWLINE> sys . stdout = open ( <STRING> , <STRING> ) <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> solve ( ) <NEWLINE> <NL> <DEDENT>
n = int ( input ( ) ) <NEWLINE> p = a + a ** 2 + a ** 3 <NEWLINE> print ( p ) <NEWLINE>
a = input ( ) <NEWLINE> print ( a + a ** 2 + a ** 3 ) <NEWLINE>
print ( a + ( a * a ) + ( a * a * a ) ) <NEWLINE>
a = input ( ) <NEWLINE> print ( a + a * a + a * a * a ) <NEWLINE>
a = int , input ( ) <NEWLINE> b = a + ( a ** 2 ) + a ** 3 <NEWLINE> print ( <STRING> , b ) <NEWLINE>
a = input ( ) <NEWLINE> b = a * a * a + a * a + a <NEWLINE> print ( b ) <NEWLINE>
a = input ( ) <NEWLINE> print ( a + a ^ 2 + a ^ 3 ) <NEWLINE>
a = int ( imput ) <NEWLINE> print ( a ( 1 + a ( 1 + a ) ) ) <NEWLINE>
num = input ( ) <NEWLINE> print ( num + ( num * num ) + ( num * num * num ) ) <NEWLINE>
a = input ( ) <NEWLINE> print ( a + a ** 2 + a ** 3 ) <NEWLINE>
print ( a + a ** 2 + a ** 3 ) <NEWLINE>
a = input ( ) <NEWLINE> print ( a + a ** 2 + a ** 3 ) <NEWLINE>
<NL> <INDENT> a = int ( input ( ) ) <NEWLINE> <NL> print ( a + a * a + a * a * a ) <NEWLINE> <DEDENT>
num = int ( input ( ) ) <NEWLINE> print ( a + a * a + a * a * a ) <NEWLINE>
a = int ( input ( ) <NEWLINE> print ( a + a ** 2 + a ** 3 ) <NEWLINE>
a = int ( input ) <NEWLINE> n = a + a * a + a * a * a <NEWLINE> print ( n ) <NEWLINE>
def solve ( string ) : <NEWLINE> <INDENT> a = int ( string ) <NEWLINE> return str ( a + a ** 2 + a ** 3 ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> import sys <NEWLINE> print ( solve ( sys . stdin . read ( ) . strip ( ) ) ) <NEWLINE> <DEDENT> ~ ~ ~ ~ ~ <NEWLINE>
a = int ( input ) <NEWLINE> <NL> ans = a + a ** 2 + a ** 3 <NEWLINE> <NL> print ( ans ) <NEWLINE>
print ( str ( a + a * a + a * a * a ) ) <NEWLINE>
ubkookoookyfyut <NEWLINE>
a = int ( intput ( ) ) <NEWLINE> ans = a * ( 1 + a * ( 1 + a ) ) <NEWLINE> print ( ans ) <NEWLINE>
<INDENT> a = input ( int ( ) ) <NEWLINE> <DEDENT> print ( a + a ** 2 + a ** 3 ) <NEWLINE>
n = input ( ) <NEWLINE> print ( n + n ** 2 + n ** 3 ) <NEWLINE>
a = int ( input ( ) ) <NEWLINE> print ( a + a ** 2 + a ** * 3 ) <NEWLINE>
s = input ( ) <NEWLINE> print ( s + s ** 2 + s ** 3 ) <NEWLINE>
a = int ( input ) <NEWLINE> ans = a + a * a + a * a * a <NEWLINE> print ( ans ) <NEWLINE>
a = input ( ) <NEWLINE> print ( int ( a + a ^ 2 + a ^ 3 ) ) <NEWLINE>
a = ( int ( x ) for x in input ( ) . split ( ) ) <NEWLINE> <NL> print ( a + a * a + a * a * a ) <NEWLINE>
S = input ( ) <NEWLINE> T = input ( ) <NEWLINE> <NL> count = 0 <NEWLINE> for i in range ( len ( S ) ) : <NEWLINE> <INDENT> if S [ i ] != T [ i ] : <NEWLINE> <INDENT> count = count + 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
x = input ( ) <NEWLINE> print ( x + ( int ) ( pow ( x , 2 ) + ( int ) ( pow ( x , 3 ) ) ) <NEWLINE>
a = input ( ) <NEWLINE> b = a ** 3 + a ** 2 + a <NEWLINE> print ( b ) <NEWLINE>
a = input ( ) <NEWLINE> x = a + a * a + a * a * a <NEWLINE> print ( a ) <NEWLINE>
x = int ( import ( ) ) <NEWLINE> print ( x + x * x + x * x * x ) <NEWLINE>
a = input ( ) <NEWLINE> print ( int ( a + a ** 2 + a ** 3 ) ) <NEWLINE>
a = map ( int , input ( ) ) <NEWLINE> print ( a + a ** 2 + a ** 3 ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> print ( a + a ** 2 + a ** 3 ) <NEWLINE>
a = input ( ) <NEWLINE> print ( a + a * a + a * a * a ) <NEWLINE>
a = int ( input ( ) ) <NEWLINE> <NL> ans = a + a * a + a * a * a <NEWLINE> <NL> return ans <NEWLINE>
def A ( x ) : <NEWLINE> <INDENT> return x + x ** 2 + x ** 3 <NEWLINE> <NL> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> print ( A ( input ( ) ) ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
a = input ( ) <NEWLINE> <NL> print ( a + a * a + a * a * a ) <NEWLINE>
a = input ( ) <NEWLINE> print ( a + a * a + a * a * a ) <NEWLINE>
import re <NEWLINE> import sys <NEWLINE> S = input ( ) <NEWLINE> T = input ( ) <NEWLINE> w = 0 <NEWLINE> if not re . match ( <STRING> , S ) or not re . match ( <STRING> , T ) or len ( S ) != len ( T ) or ( 10 ** 5 * 2 ) < len ( S ) : <NEWLINE> <INDENT> sys . exit ( ) <NEWLINE> <DEDENT> if S != T : <NEWLINE> <INDENT> i = 0 <NEWLINE> for l in S : <NEWLINE> <INDENT> if l != T [ i ] : <NEWLINE> <INDENT> w = w + 1 <NEWLINE> <DEDENT> i = i + 1 <NEWLINE> <DEDENT> <DEDENT> print ( w ) <NEWLINE>
S = input ( ) <NEWLINE> T = input ( ) <NEWLINE> <NL> count = 0 <NEWLINE> <NL> for i in range ( len ( S ) + 1 ) : <NEWLINE> <INDENT> if S [ i ] != T [ i ] : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> print ( T [ i ] ) <NEWLINE> <DEDENT> print ( count ) <NEWLINE>
S = input ( ) <NEWLINE> T = input ( ) <NEWLINE> differnce = 0 <NEWLINE> for i in range ( len ( S ) ) : <NEWLINE> <INDENT> if S [ i ] != T [ i ] : <NEWLINE> <INDENT> difference += 1 <NEWLINE> <DEDENT> <DEDENT> print ( difference ) <NEWLINE>
S , T = input ( ) . split ( ) <NEWLINE> <NL> leng = len ( S ) <NEWLINE> count = 0 <NEWLINE> for i in range ( len ( S ) ) : <NEWLINE> <INDENT> if S [ i ] != T [ i ] : <NEWLINE> <INDENT> count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
S = input ( ) <NEWLINE> T = input ( ) <NEWLINE> count = 0 <NEWLINE> for i in range ( len ( S ) ) : <NEWLINE> <INDENT> if S [ i ] != T [ i ] : <NEWLINE> <INDENT> count + + <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
S = input ( ) <NEWLINE> T = input ( ) <NEWLINE> ans = 0 <NEWLINE> for i , ch in enumerate ( S ) : <NEWLINE> <INDENT> if ch != T [ i ] : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> return ans <NEWLINE>
s = input ( ) <NEWLINE> t = input ( ) <NEWLINE> <NL> count = 0 <NEWLINE> for i in range ( s ) : <NEWLINE> <INDENT> if s [ i ] != t [ i ] : <NEWLINE> <INDENT> count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
S = input ( ) <NEWLINE> T = input ( ) <NEWLINE> <NL> for i in S : <NEWLINE> <INDENT> if S [ i ] != T [ i ] : <NEWLINE> <INDENT> i += 1 <NEWLINE> <DEDENT> <DEDENT> print ( i ) <NEWLINE>
S = input ( ) . strip ( ) <NEWLINE> T = input ( ) . strip ( ) <NEWLINE> count = 0 <NEWLINE> for i in len ( S ) : <NEWLINE> <INDENT> if S [ i ] == T [ i ] : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
s = str ( input ( ) ) <NEWLINE> t = str ( input ( ) ) <NEWLINE> c = 0 <NEWLINE> for i in len ( s ) : <NEWLINE> <INDENT> if ( s [ i ] != t [ i ] ) : <NEWLINE> <INDENT> c += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( c ) <NEWLINE>
s , t = input ( ) . split ( ) <NEWLINE> x = zip ( s , t ) <NEWLINE> y = [ ] <NEWLINE> for i , j in x : <NEWLINE> <INDENT> if i == j : <NEWLINE> <INDENT> y . append ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> y . append ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> print ( y . count ( <STRING> ) ) <NEWLINE>
S = list ( input ( ) ) <NEWLINE> T = list ( input ( ) ) <NEWLINE> a = len ( S ) <NEWLINE> change_time = 0 <NEWLINE> <NL> for i in a : <NEWLINE> <INDENT> if ( S [ i ] == T [ i ] ) <NEWLINE> continue <NEWLINE> <NL> else : <NEWLINE> S [ i ] = T [ i ] <NEWLINE> change_time += 1 <NEWLINE> <NL> <NL> <DEDENT> print ( change_time ) <NEWLINE>
S = list ( input ( ) ) <NEWLINE> T = list ( input ( ) ) <NEWLINE> cnt = 0 <NEWLINE> for t in range ( 0 , int ( len ( S ) ) - 1 ) : <NEWLINE> <INDENT> if S [ t ] != T [ t ] : <NEWLINE> <INDENT> cnt + + <NEWLINE> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
a = list ( input ( ) ) <NEWLINE> b = list ( input ( ) ) <NEWLINE> n = 0 <NEWLINE> for c , d in zip ( a , b ) : <NEWLINE> <INDENT> if c != d : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT>
s = input ( ) <NEWLINE> t = input ( ) <NEWLINE> <NL> int t = 0 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> if ( s [ i ] != t [ i ] ) : <NEWLINE> <INDENT> t += 1 ; <NEWLINE> <DEDENT> <DEDENT> print ( t ) <NEWLINE> <NL> <NL>
S , T = list ( input ( ) . split ( ) ) <NEWLINE> count = 0 <NEWLINE> for i in range ( len ( S ) ) : <NEWLINE> <INDENT> if S [ i ] != T [ i ] : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
s = input ( ) <NEWLINE> s1 = input ( ) <NEWLINE> c = 0 ; <NEWLINE> for i in range ( len ( s1 ) ) : <NEWLINE> <INDENT> if ( s1 [ i ] != s [ i ] ) : <NEWLINE> <INDENT> c + + ; <NEWLINE> <DEDENT> <DEDENT> print ( c ) <NEWLINE>
S = input ( ) <NEWLINE> T = input ( ) <NEWLINE> count = 0 <NEWLINE> for i in range ( len ( S ) ) : <NEWLINE> <INDENT> if S [ i ] != T [ i ] : <NEWLINE> <INDENT> T [ i ] = S [ i ] <NEWLINE> count += 1 <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
x = 0 <NEWLINE> s = input ( ) <NEWLINE> t = input ( ) <NEWLINE> y = len ( s ) <NEWLINE> for i in range ( y ) <NEWLINE> <INDENT> if s [ i ] == t [ i ] : <NEWLINE> <INDENT> x += 1 <NEWLINE> <DEDENT> i += 1 <NEWLINE> <DEDENT> print ( x ) <NEWLINE>
s = intput ( ) <NEWLINE> ss = intput ( ) <NEWLINE> c = 0 <NEWLINE> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> if ( s [ i ] != ss [ i ] ) : <NEWLINE> <INDENT> c += 1 <NEWLINE> <DEDENT> <DEDENT> print ( c ) <NEWLINE>
s = input ( ) . split ( ) <NEWLINE> t = input ( ) . split ( ) <NEWLINE> c = 0 <NEWLINE> <NL> for i in rangea ( len ( s ) ) : <NEWLINE> <INDENT> if s [ i ] != t [ i ] : <NEWLINE> <INDENT> c += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( str ( c ) ) <NEWLINE>
s = input ( ) <NEWLINE> t = input ( ) <NEWLINE> <NL> s_len = len ( s ) <NEWLINE> count = 0 <NEWLINE> for i in range ( s ) : <NEWLINE> <INDENT> if s [ i ] != t [ i ] : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
S = input ( ) <NEWLINE> T = input ( ) <NEWLINE> N = len ( S ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if not S [ i ] == T [ i ] : <NEWLINE> <INDENT> S [ i ] = T [ i ] <NEWLINE> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
a = input ( ) <NEWLINE> b = input ( ) <NEWLINE> ans = 0 <NEWLINE> for i , j in a , b : <NEWLINE> <INDENT> if i != j : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
s = str ( input ( ) ) <NEWLINE> t = str ( input ( ) ) <NEWLINE> length = len ( s ) <NEWLINE> count = 0 <NEWLINE> for i in range ( s ) : <NEWLINE> <INDENT> if s [ i ] == t [ i ] : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
S = input ( ) <NEWLINE> T = input ( ) <NEWLINE> counter = 0 <NEWLINE> <NL> while ( S != T ) : <NEWLINE> <INDENT> for i in range ( len ( S ) ) : <NEWLINE> <INDENT> if S [ i ] != T [ i ] : <NEWLINE> <INDENT> S [ i ] = T [ i ] <NEWLINE> counter = counter + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> pass <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( counter ) <NEWLINE>
a , b = input ( ) . split ( ) <NEWLINE> count = 0 <NEWLINE> for i in range ( len ( a ) ) : <NEWLINE> <INDENT> if ( a [ i ] != b [ i ] ) : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
s = list ( input ( ) ) <NEWLINE> t = list ( input ( ) ) <NEWLINE> print ( sum ( [ 1 for x , y in zip ( s , t ) if x != y ] ) <NEWLINE>
<NL> a = input ( ) <NEWLINE> b = input ( ) <NEWLINE> i = 0 <NEWLINE> good = 0 <NEWLINE> while ( i < len ( a ) ) : <NEWLINE> <INDENT> if ( a [ i ] != b [ i ] ) : <NEWLINE> <INDENT> good += 1 <NEWLINE> i += 1 <NEWLINE> <DEDENT> <DEDENT> print ( good ) <NEWLINE>
s = input ( ) <NEWLINE> t = input ( ) <NEWLINE> <NL> count = 0 <NEWLINE> <NL> for i in ronge ( len ( s ) ) : <NEWLINE> <INDENT> if s [ i ] != t [ i ] : <NEWLINE> <INDENT> count = count + 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
s = input ( ) <NEWLINE> t = input ( ) <NEWLINE> u = 0 <NEWLINE> <NL> if s == t : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> if s [ i ] != t [ i ] : <NEWLINE> <INDENT> u += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> path <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( u ) <NEWLINE>
S = input ( ) <NEWLINE> T = input ( ) <NEWLINE> <NL> n = 1 <NEWLINE> <NL> for a in range len ( S ) <NEWLINE> <NL> if S [ a ] = T [ a ] : <NEWLINE> <INDENT> n += 1 <NEWLINE> <NL> <DEDENT> return n <NEWLINE>
s = input ( ) <NEWLINE> t = input ( ) <NEWLINE> count = 0 <NEWLINE> for i in s : <NEWLINE> <INDENT> if s [ i ] != t [ i ] : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
ソースコード <NEWLINE> <NL> Copy <NEWLINE> Copy <NEWLINE> S = input ( ) <NEWLINE> T = input ( ) <NEWLINE> count = 0 <NEWLINE> if S == T : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( len ( S ) ) : <NEWLINE> <INDENT> if S [ i ] != T [ i ] : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> t = input ( ) <NEWLINE> count = 0 <NEWLINE> for i in len ( s ) : <NEWLINE> <INDENT> if s [ i ] != t [ i ] : <NEWLINE> <INDENT> count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
s = input ( ) <NEWLINE> t = input ( ) <NEWLINE> <NL> result = 0 <NEWLINE> for i , v in enumerate ( s ) : <NEWLINE> <INDENT> if t [ i ] != = v : <NEWLINE> <INDENT> result += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( result ) <NEWLINE>
s = input ( ) <NEWLINE> t = input ( ) <NEWLINE> <NL> sl = list ( s ) <NEWLINE> tl = list ( t ) <NEWLINE> <NL> count = 0 <NEWLINE> <NL> for ( a , b ) in zip ( sl , tl ) : <NEWLINE> <INDENT> if a != b : <NEWLINE> <INDENT> count + + <NEWLINE> <NL> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
s = input ( ) <NEWLINE> t = input ( ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( s ) : <NEWLINE> <INDENT> if s [ i ] != t [ i ] : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
a = input ( ) <NEWLINE> b = input ( ) <NEWLINE> count = 0 <NEWLINE> for i in a : <NEWLINE> <INDENT> if b [ i ] != a [ i ] : <NEWLINE> <INDENT> b [ i ] = a [ i ] <NEWLINE> count += 1 <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
S = list ( input ( ) ) <NEWLINE> T = list ( input ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( len ( S ) ) : <NEWLINE> <INDENT> if s [ i ] != T [ i ] : ans += 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
s = input ( ) <NEWLINE> t = input ( ) <NEWLINE> <NL> count = 0 <NEWLINE> <NL> for i in range ( s ) : <NEWLINE> <INDENT> if s [ i ] != t [ i ] : <NEWLINE> <INDENT> count += 1 <NEWLINE> <NL> print ( count ) <NEWLINE> <DEDENT> <DEDENT>
def minchange ( s , t ) : <NEWLINE> <INDENT> m = len ( s ) <NEWLINE> n = len ( t ) <NEWLINE> if n != m : <NEWLINE> <INDENT> return - 1 <NEWLINE> <DEDENT> cnt = [ 0 ] * 256 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> cnt [ ord ( t [ i ] ) ] += 1 <NEWLINE> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> cnt [ ord ( s [ i ] ) ] -= 1 <NEWLINE> <DEDENT> for i in range ( 256 ) : <NEWLINE> <INDENT> if cnt [ i ] : <NEWLINE> <INDENT> return - 1 <NEWLINE> <DEDENT> <DEDENT> res = 0 <NEWLINE> i = n - 1 <NEWLINE> j = n - 1 <NEWLINE> while i >= 0 : <NEWLINE> <INDENT> while i >= 0 and s [ i ] != t [ i ] : <NEWLINE> <INDENT> i -= 1 <NEWLINE> res += 1 <NEWLINE> <DEDENT> if i >= 0 : <NEWLINE> <INDENT> i -= 1 <NEWLINE> j -= 1 <NEWLINE> <DEDENT> <DEDENT> return res <NEWLINE> <DEDENT> s = input ( ) <NEWLINE> t = input ( ) <NEWLINE> print ( str ( minchange ( s , t ) ) <NEWLINE> <NL> <NL>
import sys <NEWLINE> import os <NEWLINE> f = open ( <STRING> , <STRING> ) <NEWLINE> sys . stdin = f <NEWLINE> S = input ( ) <NEWLINE> T = input ( ) <NEWLINE> n = len ( S ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if ( S [ i ] != T [ i ] ) : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
a = int ( input ( ) ) <NEWLINE> <NL> print ( a + a ** 2 + a ** 3 ) <NEWLINE>
import sys <NEWLINE> s = sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> t = sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> <NL> count = 0 <NEWLINE> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> if s [ i ] != s [ t ] : <NEWLINE> <INDENT> count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
s = input ( ) <NEWLINE> t = input ( ) <NEWLINE> <NL> num = 0 <NEWLINE> for ind , s in enumerate ( A ) : <NEWLINE> <INDENT> if A [ ind ] != B [ ind ] : <NEWLINE> <INDENT> num = num + 1 <NEWLINE> <DEDENT> <DEDENT> print ( num ) <NEWLINE>
S = input ( ) <NEWLINE> T = input ( ) <NEWLINE> tmp = 0 <NEWLINE> for i in range ( len ( S ) ) : <NEWLINE> <INDENT> if S [ i ] == T [ i ] : <NEWLINE> <INDENT> pass : <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> tmp += 1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> print ( tmp ) <NEWLINE>
a = int ( input ( ) ) <NEWLINE> print ( a + a ** 2 + a ** 3 ) <NEWLINE>
s = input ( ) <NEWLINE> t = input ( ) <NEWLINE> count = 0 <NEWLINE> for k in range ( a ) : <NEWLINE> <INDENT> if s [ k ] != t [ k ] : <NEWLINE> <INDENT> count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
S = list ( input ( ) ) <NEWLINE> T = list ( input ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> for i in range ( len ( S ) ) : <NEWLINE> <INDENT> ans += ( S [ i ] = T [ i ] ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
s = str ( input ( ) ) <NEWLINE> t = str ( input ( ) ) <NEWLINE> count = 0 <NEWLINE> <NL> for i in len ( s ) : <NEWLINE> <INDENT> if s [ i ] != t [ i ] : <NEWLINE> <INDENT> count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
s = str ( input ( ) ) <NEWLINE> t = str ( input ( ) ) <NEWLINE> count = 0 <NEWLINE> for i range ( len ( s ) ) : <NEWLINE> <INDENT> if s [ i ] == t [ i ] : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
s = input ( ) <NEWLINE> t = input ( ) <NEWLINE> s = input ( ) <NEWLINE> a = [ int ( c ) for c in s ] <NEWLINE> b = [ int ( d ) for d in t ] <NEWLINE> ans = 0 <NEWLINE> for i in range ( len ( a ) ) : <NEWLINE> <INDENT> if ( a [ i ] != b [ i ] ) : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
t = input ( ) <NEWLINE> i = 0 <NEWLINE> ans = 0 <NEWLINE> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> if s [ i ] != t [ i ] : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
S = input ( ) <NEWLINE> T = input ( ) <NEWLINE> a = o <NEWLINE> for i in len ( S ) : <NEWLINE> <INDENT> if S [ i ] != T [ i ] : <NEWLINE> <INDENT> a += 1 <NEWLINE> <DEDENT> <DEDENT> print ( a ) <NEWLINE>
S = input ( ) <NEWLINE> T = input ( ) <NEWLINE> cnt = 0 <NEWLINE> for i in range ( len ( S ) ) : <NEWLINE> <INDENT> if S [ i ] != T [ i ] : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> prrint ( cnt ) <NEWLINE>
from sys import stdin , stdout <NEWLINE> LI = lambda : list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> MAP = lambda : map ( int , input ( ) . split ( ) ) <NEWLINE> IN = lambda : int ( input ( ) ) <NEWLINE> S = lambda : input ( ) <NEWLINE> import math <NEWLINE> def p ( a ) : print ( <STRING> . join ( list ( map ( str , a ) ) ) ) <NEWLINE> from collections import Counter <NEWLINE> <NL> s = S ( ) <NEWLINE> t = t ( ) <NEWLINE> x = 0 <NEWLINE> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> if s [ i ] != t [ i ] : x += 1 <NEWLINE> <DEDENT> print ( x ) <NEWLINE>
s , t = input ( ) . split ( ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> if s [ i ] != t [ i ] : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
S = input ( ) <NEWLINE> T = input ( ) <NEWLINE> for i in range ( len ( S ) ) : <NEWLINE> <INDENT> if ( S [ i ] != T [ i ] ) : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( str ( ans ) ) <NEWLINE>
def distance ( x , y ) : <NEWLINE> <INDENT> return ( x ** 2 + y ** 2 ) ** ( 1 / 2 ) <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> n , d = map ( int , input ( ) . split ( ) ) <NEWLINE> xy_lst = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ] <NEWLINE> count = 0 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> x = xy_lst [ i ] [ 0 ] <NEWLINE> y = xy_lst [ i ] [ 1 ] <NEWLINE> if distance ( x , y ) <= d : <NEWLINE> <INDENT> count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( count ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
a = int ( input ( ) ) <NEWLINE> print ( a + a * a + a * a * a ) <NEWLINE>
S = input ( ) <NEWLINE> T = input ( ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( len ( S ) ) : <NEWLINE> <INDENT> if S [ i ] != T [ i ] : : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
S = input ( ) <NEWLINE> T = input ( ) <NEWLINE> ans = 0 <NEWLINE> <NL> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> if ( s [ i ] != t [ i ] ) : <NEWLINE> <INDENT> ans = ans + 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
S = input ( ) <NEWLINE> T = input ( ) <NEWLINE> print ( sum ( s != t for s , t in zip ( S , T ) ) <NEWLINE>
ret = 0 <NEWLINE> S = input ( ) <NEWLINE> T = input ( ) <NEWLINE> print ( len [ S [ i ] for i in range ( len ( S ) ) if S [ i ] != T [ i ] ] ) <NEWLINE>
a = input ( ) <NEWLINE> b = input ( ) <NEWLINE> <NL> answer = 0 <NEWLINE> i = 0 <NEWLINE> while i < len ( a ) : <NEWLINE> <INDENT> if a [ i ] != b [ i ] : <NEWLINE> <INDENT> answer = answer + 1 <NEWLINE> i = i + 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( answer ) <NEWLINE>
s = input ( ) <NEWLINE> t = input ( ) <NEWLINE> o = 0 <NEWLINE> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> if s [ i ] != t [ i ] : <NEWLINE> <INDENT> o += 1 <NEWLINE> <DEDENT> <DEDENT> print ( o ) <NEWLINE>
def B ( ) : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> t = input ( ) <NEWLINE> count = 0 <NEWLINE> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> if s [ i ] != t [ i ] : <NEWLINE> <INDENT> count = count + 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE> B ( ) <NEWLINE>
S = list ( input ( ) ) <NEWLINE> T = list ( input ( ) ) <NEWLINE> count = 0 <NEWLINE> <NL> for i in range ( len ( S ) ) : <NEWLINE> <INDENT> if S [ i ] != T [ i ] : <NEWLINE> count += 1 <NEWLINE> <NL> <DEDENT> print ( count ) <NEWLINE>
S = input ( ) <NEWLINE> T = input ( ) <NEWLINE> <NL> c = 0 <NEWLINE> for i in range ( len ( S ) ) : <NEWLINE> <INDENT> if S [ i ] != T [ i ] : <NEWLINE> <INDENT> C += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( c ) <NEWLINE>
s , t = input ( ) . split ( ) <NEWLINE> u = 0 <NEWLINE> for i in range ( 0 , len ( s ) ) : <NEWLINE> <INDENT> if s [ i ] != t [ i ] : <NEWLINE> <INDENT> u += 1 <NEWLINE> <DEDENT> <DEDENT> print ( u ) <NEWLINE>
ST = input ( ) . split ( ) <NEWLINE> S = list ( S ) <NEWLINE> T = list ( T ) <NEWLINE> for i in S : <NEWLINE> <INDENT> if ( S [ i ] != T [ i ] ) : <NEWLINE> <INDENT> count + + <NEWLINE> <NL> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
S , T = input ( ) . split ( ) <NEWLINE> cnt = 0 <NEWLINE> for i in range ( len ( S ) ) : <NEWLINE> <INDENT> if S [ i ] != T [ i ] : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
S = input ( ) <NEWLINE> T = input ( ) <NEWLINE> aa = 0 <NEWLINE> for s , t in zip ( S , T ) : <NEWLINE> <INDENT> if s != t : <NEWLINE> <INDENT> a += 1 <NEWLINE> <DEDENT> <DEDENT> print ( a ) <NEWLINE>
s = input ( ) <NEWLINE> t - input ( ) <NEWLINE> def hamming_dist ( str1 , str2 ) : <NEWLINE> <INDENT> ans = 0 <NEWLINE> a , b = len ( str1 ) , len ( str2 ) <NEWLINE> if a > b : <NEWLINE> <INDENT> ans = a - b <NEWLINE> length = b <NEWLINE> <DEDENT> elif a < b : <NEWLINE> <INDENT> ans = b - a <NEWLINE> length = a <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> length = a <NEWLINE> <DEDENT> for i in range ( length ) : <NEWLINE> <INDENT> if str1 [ i ] != str2 [ i ] : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> return ans <NEWLINE> <DEDENT> print ( hamming_dist ( s , t ) ) <NEWLINE>
s = input ( ) <NEWLINE> a = [ str ( c ) for c in s ] <NEWLINE> t = input ( ) <NEWLINE> b = [ str ( c ) for c in s ] <NEWLINE> <NL> c = 0 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> if a [ i ] == b [ i ] : <NEWLINE> <INDENT> c += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( n - c ) <NEWLINE>
S = input ( ) <NEWLINE> T = input ( ) <NEWLINE> W = 0 <NEWLINE> for i in range ( len ( S ) ) : <NEWLINE> <INDENT> if S [ i ] != T [ i ] : <NEWLINE> <INDENT> w += 1 <NEWLINE> <DEDENT> <DEDENT> print ( W ) <NEWLINE>
S = str ( input ( ) ) <NEWLINE> T = str ( input ( ) ) <NEWLINE> sum = 0 <NEWLINE> <NL> for i in range ( len ( S ) ) : <NEWLINE> <INDENT> if S [ i ] != T [ i ] : <NEWLINE> <INDENT> sum + + <NEWLINE> <NL> <DEDENT> <DEDENT> print ( sum ) <NEWLINE>
from sys import stdin <NEWLINE> s = stdin . readline ( ) <NEWLINE> t = sdtin . readline ( ) <NEWLINE> count = 0 <NEWLINE> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> if s [ i ] != t [ i ] : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
s = input ( ) <NEWLINE> b = input ( ) <NEWLINE> c = 0 <NEWLINE> for i in len ( s ) : <NEWLINE> <INDENT> if s [ i ] != b [ i ] : <NEWLINE> <INDENT> c = c + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> <DEDENT> print ( c ) <NEWLINE>
S , T = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> cnt = 0 <NEWLINE> for s , t in zip ( S , T ) : <NEWLINE> <INDENT> if s != t : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
S = input ( ) <NEWLINE> T = input ( ) <NEWLINE> count = 0 <NEWLINE> for i in len ( S ) : <NEWLINE> <INDENT> if S [ i ] != T [ i ] : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE> <NL>
def b172 ( slist , tlist ) : <NEWLINE> <NL> <INDENT> ans = 0 <NEWLINE> <NL> for s , t in slist , tlist : <NEWLINE> <INDENT> if s != t : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> return ans <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> slist = list ( str ( input ( ) ) ) <NEWLINE> tlist = list ( str ( input ( ) ) ) <NEWLINE> print ( b172 ( slist , tlist ) ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
s = list ( map ( str , input ( ) . split ( ) ) ) <NEWLINE> t = list ( map ( str , input ( ) . split ( ) ) ) <NEWLINE> count = 0 <NEWLINE> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> if ( s [ i ] == t [ i ] ) : <NEWLINE> <INDENT> count + + <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
try : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> t = input ( ) <NEWLINE> count = 0 <NEWLINE> for i in range ( len ( s ) ) : <NEWLINE> if not s [ i ] == t [ i ] : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> print ( count ) <NEWLINE> <DEDENT> except EOFError : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> t = input ( ) <NEWLINE> n = 0 <NEWLINE> for i in s : <NEWLINE> <INDENT> for j in t : <NEWLINE> <INDENT> if i != j : <NEWLINE> <INDENT> i = j <NEWLINE> n += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return n <NEWLINE>
S = str ( input ( ) ) <NEWLINE> T = str ( input ( ) ) <NEWLINE> n = 0 <NEWLINE> <NL> for i in len ( S ) : <NEWLINE> <INDENT> if S [ i ] != T [ i ] : <NEWLINE> <INDENT> n += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( n ) <NEWLINE>
S = input ( ) <NEWLINE> T = input ( ) <NEWLINE> print ( sum ( x != y for x , y in zip ( S , T ) ) <NEWLINE>
S = input ( ) <NEWLINE> T = input ( ) <NEWLINE> <NL> count = 0 <NEWLINE> for i in range ( len ( S ) ) : <NEWLINE> <INDENT> if S [ i ] == T [ i ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> S [ i ] = T [ i ] <NEWLINE> count += 1 <NEWLINE> <DEDENT> <DEDENT> return count <NEWLINE>
word1 = list ( input ( ) ) <NEWLINE> word2 = list ( input2 ( ) ) <NEWLINE> i = 0 <NEWLINE> for i , j in word1 , word2 : <NEWLINE> <INDENT> if i != J : <NEWLINE> <INDENT> i + + <NEWLINE> <DEDENT> <DEDENT> print ( i ) <NEWLINE>
s = input ( ) <NEWLINE> t = input ( ) <NEWLINE> <NL> cnt = 0 <NEWLINE> for i in range ( ) : <NEWLINE> <INDENT> if s [ i ] != t [ i ] : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
S = input ( ) <NEWLINE> T = input ( ) <NEWLINE> <NL> ret = 0 <NEWLINE> for i in len ( S ) : <NEWLINE> <INDENT> if S [ i ] != T [ i ] : <NEWLINE> <INDENT> ret += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ret ) <NEWLINE>
s = input ( ) <NEWLINE> t = input ( ) <NEWLINE> c = 0 <NEWLINE> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> if s [ i ] != t [ i ] : <NEWLINE> <INDENT> c += 1 <NEWLINE> <DEDENT> <DEDENT> print ( c ) <NEWLINE>
print ( sum ( [ s != t for s , t in zip ( input ( ) . split ( ) ) ] ) ) <NEWLINE>
S = input ( ) <NEWLINE> T = input ( ) <NEWLINE> cout = 0 <NEWLINE> for i in len ( S ) : <NEWLINE> <INDENT> if S [ i ] != T [ i ] : <NEWLINE> <INDENT> cout = cout + 1 <NEWLINE> <DEDENT> <DEDENT> print ( cout ) <NEWLINE>
import sys <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> <NL> s , t = map ( str , readline ( ) . split ( ) ) <NEWLINE> <NL> count = 0 <NEWLINE> for idx , i in enumerate ( s ) : <NEWLINE> <INDENT> if s [ idx ] != t [ idx ] : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
s , t , count = input ( ) , input ( ) , 0 <NEWLINE> <NL> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> if s [ i ] != t [ i ] : <NEWLINE> <INDENT> count + + <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
S = input ( ) <NEWLINE> T = input ( ) <NEWLINE> k = len ( T ) <NEWLINE> m = 0 <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> if S [ k ] == T [ k ] : <NEWLINE> <INDENT> m = m <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> S [ k ] = T [ k ] <NEWLINE> m += 1 <NEWLINE> <DEDENT> <DEDENT> print ( m ) <NEWLINE>
S = input ( ) <NEWLINE> T = input ( ) <NEWLINE> count = 0 <NEWLINE> for s , t in S , T : <NEWLINE> <INDENT> if s != t : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
a = o <NEWLINE> S = list ( input ( ) ) <NEWLINE> T = list ( input ( ) ) <NEWLINE> for i in range ( len ( S ) ) : <NEWLINE> <INDENT> if S [ i ] != T [ i ] : <NEWLINE> <INDENT> a = a + 1 <NEWLINE> <DEDENT> <DEDENT> print ( a ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> p . sort ( ) <NEWLINE> res = 0 <NEWLINE> for x in p [ : K ] : <NEWLINE> <INDENT> res += x <NEWLINE> <NL> <DEDENT> print ( res ) <NEWLINE>
s = input ( ) <NEWLINE> t = input ( ) <NEWLINE> cnt = 0 <NEWLINE> for i in len ( s ) : <NEWLINE> <INDENT> if s [ i ] != t [ i ] : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
s = input ( ) <NEWLINE> t = input ( ) <NEWLINE> <NL> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> if s [ i ] is not t [ i ] : <NEWLINE> <INDENT> i + + <NEWLINE> <NL> <DEDENT> <DEDENT> print ( i ) <NEWLINE>
[ s , t ] = input ( ) . split ( ) ; <NEWLINE> cnt = 0 ; <NEWLINE> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> if s [ i ] != t [ i ] : <NEWLINE> <INDENT> cnt = cnt + 1 ; <NEWLINE> <DEDENT> <DEDENT> print ( cnt ) ; <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> S = input ( ) <NEWLINE> T = input ( ) <NEWLINE> count = 0 <NEWLINE> for i in len ( S ) : <NEWLINE> <INDENT> if S [ i ] != T [ i ] : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> t = input ( ) <NEWLINE> ans = 0 , cnt = 0 <NEWLINE> for check in s : <NEWLINE> <INDENT> if t [ cnt ] == check : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += 1 <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
a = [ input ( ) for i in range ( 2 ) ] <NEWLINE> P = a [ 0 ] <NEWLINE> S = a [ 1 ] <NEWLINE> count = 0 <NEWLINE> for t in range ( 0 , len ( P ) - 1 ) : <NEWLINE> <INDENT> if P [ t ] != S [ t ] : <NEWLINE> <INDENT> count = count + + <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
S = input ( ) <NEWLINE> t = input ( ) <NEWLINE> cnt = 0 <NEWLINE> <NL> if s == t : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> if s [ i ] != t [ i ] : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
a = list ( input ( ) ) <NEWLINE> b = list ( input ( ) ) <NEWLINE> <NL> for i , con in enumerate ( b ) : <NEWLINE> <INDENT> if i == a [ i ] : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE> <NL>
print ( sum ( a != b for a , b in zip ( input ( ) , input ( ) ) ) <NEWLINE>
cnt = 0 <NEWLINE> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> if s [ i ] != t [ i ] : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
s = input ( ) <NEWLINE> t = input ( ) <NEWLINE> <NL> ans = 0 : <NEWLINE> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> if s [ i ] != t [ i ] : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
m = input ( ) <NEWLINE> n = input ( ) <NEWLINE> count = 0 ; <NEWLINE> for i in range ( len ( m ) ) <NEWLINE> <INDENT> if m [ i ] != n [ i ] : <NEWLINE> <INDENT> count + = 1 <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
s = input ( ) <NEWLINE> t = input ( ) <NEWLINE> result = len ( [ _ for a , b in zip ( s , t ) if a != b ] ) <NEWLINE> print ( result ) <NEWLINE>
s = input ( ) <NEWLINE> t = input ( ) <NEWLINE> print ( sum ( [ 1 for index , char in enumerate ( s ) if p [ index ] != char ] ) ) <NEWLINE>
s = input ( ) <NEWLINE> t = input ( ) <NEWLINE> <NL> count = 0 <NEWLINE> <NL> for i in range ( len ( s ) ) <NEWLINE> if s [ i ] != t [ i ] : <NEWLINE> <INDENT> count += 1 <NEWLINE> <NL> <DEDENT> print ( count ) <NEWLINE>
s = list ( input ( ) ) <NEWLINE> t = list ( input ( ) ) <NEWLINE> u = len ( s ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( u ) : <NEWLINE> <INDENT> if s [ u ] != t [ u ] : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
def solve ( string ) : <NEWLINE> <INDENT> s , t = string . split ( ) <NEWLINE> return str ( len ( s ) - sum ( _s == _t for _s , _t in zip ( s , t ) ) pass <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> import sys <NEWLINE> print ( solve ( sys . stdin . read ( ) . strip ( ) ) ) <NEWLINE> <DEDENT>
S = string ( input ( ) ) <NEWLINE> T = string ( input ( ) ) <NEWLINE> num = 0 <NEWLINE> for i in range ( len ( S ) ) : <NEWLINE> <INDENT> if S [ i ] != T [ i ] : <NEWLINE> <INDENT> num = num + 1 <NEWLINE> <DEDENT> <DEDENT> print ( num ) <NEWLINE>
a = input ( ) <NEWLINE> b = input ( ) <NEWLINE> cnt = 0 <NEWLINE> for i in range ( len ( a ) ) : <NEWLINE> <INDENT> if a [ i ] != b [ i ] : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
S = input ( ) <NEWLINE> T = input ( ) <NEWLINE> <NL> print ( sum ( s != t for s , t zip ( S , T ) ) ) <NEWLINE>
<COMMENT> <NL> <NL> S = input ( ) <NEWLINE> T = input ( ) <NEWLINE> <NL> res = set ( ) <NEWLINE> for ss , tt in zip ( S , T ) : <NEWLINE> <INDENT> if ss != tt : <NEWLINE> <INDENT> set [ ss ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( len ( res ) ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 2147483647 ) <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> S = int ( input ( ) ) <NEWLINE> T = int ( input ( ) ) <NEWLINE> count = 0 <NEWLINE> for i in range ( len ( S ) ) : <NEWLINE> <INDENT> if ( S [ i ] != T [ i ] ) : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> print ( len ( T ) - count ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
s = list ( input ( ) ) <NEWLINE> t = list ( input ( ) ) <NEWLINE> for m in range ( len ( m ) ) : <NEWLINE> <INDENT> if m >= 2 * 10 ** 5 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> elif s != t : <NEWLINE> <INDENT> print ( s [ m ] ) <NEWLINE> <DEDENT> <DEDENT>
S = int ( input ( ) ) <NEWLINE> T = int ( input ( ) ) <NEWLINE> count = 0 ; <NEWLINE> for i in range ( 0 , len ( S ) ) : <NEWLINE> <INDENT> if ( T [ i ] != S [ i ] ) : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
ans = 0 <NEWLINE> x , y = input ( ) . split ( ) <NEWLINE> for i in range ( len ( x ) ) : <NEWLINE> <INDENT> if x [ i ] != y [ i ] : <NEWLINE> <INDENT> ans = ans + 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
= input ( ) <NEWLINE> T = input ( ) <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( len ( S ) ) : <NEWLINE> <INDENT> if S [ i ] != T [ i ] : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
S = input ( ) <NEWLINE> T = input ( ) <NEWLINE> <NL> cout = 0 <NEWLINE> for i in range ( len ( S ) ) : <NEWLINE> <INDENT> if S [ i ] != T [ i ] : <NEWLINE> <INDENT> count = count + 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
S = input ( ) <NEWLINE> T = input ( ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( S ) : <NEWLINE> <INDENT> if S [ i + 1 ] == T [ i + 1 ] : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
S = str ( input ( ) ) <NEWLINE> T = str ( input ( ) ) <NEWLINE> <NL> count = 0 <NEWLINE> for i in range ( i , len ( S ) ) : <NEWLINE> <INDENT> if S [ i ] != T [ i ] : <NEWLINE> <INDENT> count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
s = iuput ( ) <NEWLINE> t = input ( ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> if s [ i ] == t [ i ] : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
S = input ( ) <NEWLINE> T = input ( ) <NEWLINE> cnt = 0 <NEWLINE> for x , y in S , T : <NEWLINE> <INDENT> if x != y : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
S = input ( ) <NEWLINE> T = input ( ) <NEWLINE> k = 0 <NEWLINE> for i in range ( len ( S ) ) <NEWLINE> <INDENT> if S [ i ] != T [ i ] : <NEWLINE> <INDENT> k += 1 <NEWLINE> <DEDENT> <DEDENT> print ( k ) <NEWLINE>
s , t = map ( list , input ( ) . split ( ) ) <NEWLINE> k = [ ] <NEWLINE> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> k . append ( s [ i ] == t [ i ] ) <NEWLINE> <DEDENT> print ( len ( s ) - sum ( k ) ) <NEWLINE>
count = 0 <NEWLINE> a = input ( ) <NEWLINE> b = input ( ) <NEWLINE> <NL> for i in len ( a ) : <NEWLINE> <INDENT> if a [ i ] != b [ i ] : <NEWLINE> <INDENT> count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
A = input ( ) <NEWLINE> <NL> A = A . splitlines ( ) <NEWLINE> <NL> change_num = 0 <NEWLINE> <NL> Num = len ( A [ 0 ] ) <NEWLINE> <NL> S = list ( A [ 0 ] ) <NEWLINE> T = list ( A [ 1 ] ) <NEWLINE> <NL> for i in range ( Num ) : <NEWLINE> <INDENT> if S [ i ] is not T [ i ] : <NEWLINE> <INDENT> change_num += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( change_num ) <NEWLINE>
a1 = input ( ) <NEWLINE> a2 = input ( ) <NEWLINE> t = 0 <NEWLINE> <NL> for i in range ( len ( a1 ) ) : <NEWLINE> <INDENT> if a1 [ i ] != a2 [ i ] : <NEWLINE> <INDENT> a += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( a ) <NEWLINE>
s , t = input ( ) <NEWLINE> if s == t : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> count = 0 <NEWLINE> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> if s [ i ] != t [ i ] : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
S = input ( ) <NEWLINE> T = input ( ) <NEWLINE> <NL> S = list ( S ) <NEWLINE> T = list ( T ) <NEWLINE> <NL> i = 0 <NEWLINE> j = 0 <NEWLINE> <NL> while j < len ( S ) : <NEWLINE> <INDENT> if S [ j ] = T [ j ] : <NEWLINE> <INDENT> i = i <NEWLINE> j += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> i += 1 <NEWLINE> j += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( i ) <NEWLINE>
k = list ( input ( ) ) <NEWLINE> m = list ( input ( ) ) <NEWLINE> ams = 0 <NEWLINE> for i in ( len ( k ) ) : <NEWLINE> <INDENT> if ( k [ i ] != m [ i ] ) : <NEWLINE> <INDENT> ams += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ams ) <NEWLINE>
s = input ( ) <NEWLINE> t = input ( ) <NEWLINE> l = len ( s ) <NEWLINE> count = 0 <NEWLINE> if ( s == t ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( l ) : <NEWLINE> <INDENT> if ( s [ i ] == t [ i ] ) : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
S = input ( ) <NEWLINE> T = input ( ) <NEWLINE> <NL> j = 0 <NEWLINE> for i in S : <NEWLINE> <INDENT> if i != T [ j ] : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> j += 1 <NEWLINE> <NL> <DEDENT> print ( count ) <NEWLINE>
s = input ( ) <NEWLINE> t = input ( ) <NEWLINE> <NL> for i in range ( s . size ( ) ) : <NEWLINE> <INDENT> if s [ i ] != t [ i ] : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
S = input ( ) <NEWLINE> T = input ( ) <NEWLINE> sum = 0 <NEWLINE> for i in range ( len ( S ) ) : <NEWLINE> <INDENT> if S [ i - 1 ] < > T [ i - 1 ] : <NEWLINE> <INDENT> sum = sum + 1 <NEWLINE> <DEDENT> <DEDENT> print ( sum ) <NEWLINE>
S = input ( ) <NEWLINE> T = input ( ) <NEWLINE> count = 0 <NEWLINE> for i in [ 0 : len ( S ) ] : <NEWLINE> <INDENT> if S [ i ] != T [ i ] : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
<COMMENT> <NL> import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> def I ( ) : return int ( input ( ) ) <NEWLINE> def MI ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def LI ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> s = input ( ) . rstrip ( ) <NEWLINE> t = intput ( ) . rstrip ( ) <NEWLINE> result = 0 <NEWLINE> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> if s [ i ] != t [ i ] : <NEWLINE> <INDENT> result += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( result ) <NEWLINE>
S = input ( ) <NEWLINE> T = input ( ) <NEWLINE> <NL> count = 0 <NEWLINE> for ( s , t ) in map ( S , T ) : <NEWLINE> <INDENT> if s != t : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
S = input ( ) <NEWLINE> T = input ( ) <NEWLINE> aa = 0 <NEWLINE> for i in range ( length ( S ) ) : <NEWLINE> <INDENT> if S [ i ] != T [ i ] : <NEWLINE> <INDENT> aa += 1 <NEWLINE> <DEDENT> <DEDENT> print ( aa ) <NEWLINE> <NL>
L = map ( str , input ( ) . split ( ) ) <NEWLINE> <NL> s = L [ 0 ] <NEWLINE> S = list ( s ) <NEWLINE> t = L [ 1 ] <NEWLINE> T = list ( t ) <NEWLINE> <NL> N = len [ S ] - 1 <NEWLINE> i = 0 <NEWLINE> <NL> while N != i : <NEWLINE> <INDENT> if S [ i ] != T [ i ] : <NEWLINE> <INDENT> S [ i ] = T [ i ] <NEWLINE> <DEDENT> i += 1 <NEWLINE> <NL> <DEDENT> print ( i + 1 ) <NEWLINE>
s = input ( ) <NEWLINE> t = input ( ) <NEWLINE> a = 0 <NEWLINE> for x in range ( s ) : <NEWLINE> <INDENT> if s [ x ] != t [ x ] : <NEWLINE> <INDENT> a += 1 <NEWLINE> <DEDENT> <DEDENT> print ( a ) <NEWLINE>
a = input ( ) <NEWLINE> b = input ( ) <NEWLINE> <NL> cnt = 0 <NEWLINE> <NL> i = 0 <NEWLINE> <NL> while ( i < len ( a ) ) : <NEWLINE> <INDENT> if ( a [ i ] != b [ i ] ) : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> cnt += 1 <NEWLINE> <NL> <DEDENT> print ( cnt ) <NEWLINE>
a = str ( input ( ) ) <NEWLINE> b = str ( input ( ) ) <NEWLINE> c = 0 <NEWLINE> for i in range ( len ( a ) ) : <NEWLINE> <INDENT> if a [ i ] == b [ i ] : <NEWLINE> <INDENT> c += 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> b [ i ] = a [ i ] <NEWLINE> c += 1 <NEWLINE> <DEDENT> <DEDENT> print ( c ) <NEWLINE>
s , t = input ( ) , split ( ) <NEWLINE> a = 0 <NEWLINE> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> if s [ i ] == t [ i ] : <NEWLINE> <INDENT> a = a + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a = a + 0 <NEWLINE> <DEDENT> <DEDENT> print ( a ) <NEWLINE>
input1 = input ( ) <NEWLINE> input2 = input ( ) <NEWLINE> <NL> def match ( x , y ) : <NEWLINE> <INDENT> i = 0 <NEWLINE> if x is y : <NEWLINE> <INDENT> i = 1 <NEWLINE> <DEDENT> return i <NEWLINE> <NL> <DEDENT> result_list = map ( match , input1 , input2 ) <NEWLINE> print ( result_list . count ( 0 ) ) <NEWLINE>
s = input ( ) <NEWLINE> t = input ( ) <NEWLINE> <NL> ans = 0 <NEWLINE> i = 0 <NEWLINE> while i < len ( s ) : <NEWLINE> <INDENT> if s [ i ] == t [ i ] : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
a = list ( input ( ) . split ( ) ) <NEWLINE> s = a [ 0 ] <NEWLINE> t = a [ 1 ] <NEWLINE> <NL> s = list ( s ) <NEWLINE> t = list ( t ) <NEWLINE> time = 0 <NEWLINE> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> if s [ i ] != t [ i ] : <NEWLINE> <INDENT> s [ i ] = t [ i ] <NEWLINE> time += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( time ) <NEWLINE>
S = input ( ) <NEWLINE> T = input ( ) <NEWLINE> cnt = 0 <NEWLINE> for i in len ( S ) : <NEWLINE> <INDENT> if ( S [ i ] == T [ i ] ) : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
s = input ( ) <NEWLINE> t = input ( ) <NEWLINE> n = len ( s ) <NEWLINE> s . split ( ) <NEWLINE> t . split ( ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if s [ i ] != t [ i ] : <NEWLINE> <INDENT> s [ i ] = t [ i ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
s = input ( ) <NEWLINE> t = input ( ) <NEWLINE> count = 0 <NEWLINE> for i in len ( s ) : <NEWLINE> <INDENT> if s [ i ] != t [ i ] : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
s , t = map ( input ( ) . split ( ) ) <NEWLINE> c = 0 <NEWLINE> <NL> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> if s [ i ] != t [ i ] : <NEWLINE> <INDENT> c += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( c ) <NEWLINE>
a = input ( ) <NEWLINE> b = input ( ) <NEWLINE> c = 0 <NEWLINE> for i in range ( a ) : <NEWLINE> <INDENT> if ( a [ i ] != b [ i ] ) : <NEWLINE> <INDENT> c = c + 1 <NEWLINE> <DEDENT> <DEDENT> print ( c ) <NEWLINE>
s = str ( input ( ) ) <NEWLINE> t = str ( input ( ) ) <NEWLINE> <NL> count = 0 <NEWLINE> <NL> for i in range s : <NEWLINE> <INDENT> if s [ i ] != t [ i ] <NEWLINE> count += 1 <NEWLINE> <NL> <DEDENT> print ( count ) <NEWLINE>
N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A . reverse ( ) <NEWLINE> B . reverse ( ) <NEWLINE> <NL> t = 0 <NEWLINE> cnt = 0 <NEWLINE> c1 , c2 = A . pop ( ) , B . pop ( ) <NEWLINE> while True : <NEWLINE> <NL> <INDENT> if t >= K or ( t + c1 > K and t + c2 > K ) : <NEWLINE> <INDENT> break <NEWLINE> <NL> <NL> <DEDENT> if ( t + c1 <= K and t + c2 <= K ) : <NEWLINE> <INDENT> l1 = [ c1 ] <NEWLINE> sum_1 = c1 <NEWLINE> for a in A [ - 1 ] : <NEWLINE> <INDENT> if t + a <= K : <NEWLINE> <INDENT> l1 . append ( a ) <NEWLINE> sum_1 += a <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> l2 = [ c2 ] <NEWLINE> sum_2 = c2 <NEWLINE> for b in B [ - 1 ] : <NEWLINE> <INDENT> if t + b <= K : <NEWLINE> <INDENT> l2 . append ( b ) <NEWLINE> sum_2 += b <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> if sum_1 <= sum_2 : <NEWLINE> <INDENT> t += sum_1 <NEWLINE> cnt += len ( l1 ) <NEWLINE> for i in range ( len ( l1 ) - 1 ) : <NEWLINE> <INDENT> A . pop ( ) <NEWLINE> <DEDENT> c1 = A . pop ( ) if bool ( A ) else 100000000000 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> t += sum_2 <NEWLINE> cnt += len ( l2 ) <NEWLINE> for i in range ( len ( l2 ) - 1 ) : <NEWLINE> <INDENT> B . pop ( ) <NEWLINE> <DEDENT> c2 = B . pop ( ) if bool ( B ) else 100000000000 <NEWLINE> <NL> <DEDENT> <DEDENT> elif t + c1 <= K : <NEWLINE> <NL> <INDENT> t += c1 <NEWLINE> cnt += 1 <NEWLINE> c1 = A . pop ( ) if bool ( A ) else 100000000000 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if t + c2 <= K : <NEWLINE> <INDENT> t += c2 <NEWLINE> cnt += 1 <NEWLINE> c2 = B . pop ( ) if bool ( B ) else 100000000000 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
from bisect import bisect <NEWLINE> from collections import deque <NEWLINE> <NL> N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in range ( 1 , len ( A ) + 1 ) : <NEWLINE> <INDENT> A [ i ] += A [ i - 1 ] <NEWLINE> <DEDENT> for i in range ( 1 , len ( B ) + 1 ) : <NEWLINE> <INDENT> B [ i ] += B [ i - 1 ] <NEWLINE> <NL> <DEDENT> indexB = len ( B ) - 1 <NEWLINE> results = [ 0 ] <NEWLINE> for i in range ( len ( A ) ) : <NEWLINE> <INDENT> time = A [ i ] <NEWLINE> if time > K : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> enable_for_b = K - time <NEWLINE> results . append ( i + bisect ( B , enable_for_b ) ) <NEWLINE> <NL> <DEDENT> print ( max ( results ) ) <NEWLINE>
n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> s = 0 <NEWLINE> ac = 0 <NEWLINE> bc = 0 <NEWLINE> max = 0 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> s = s + a [ i ] <NEWLINE> ac = ac + 1 <NEWLINE> if s > k : <NEWLINE> <INDENT> s = s - a [ i ] <NEWLINE> ac = ac - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> for i in range ( m ) : <NEWLINE> <INDENT> s = s + b [ i ] <NEWLINE> bc = bc + 1 <NEWLINE> if s > k : <NEWLINE> <INDENT> s = s - b [ i ] <NEWLINE> bc = bc - 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> max = ac + bc <NEWLINE> <NL> flag = 0 <NEWLINE> while flag == 0 & & ac != 0 : <NEWLINE> <INDENT> ac = ac - 1 <NEWLINE> s = s - a [ ac ] <NEWLINE> while s <= k : <NEWLINE> <INDENT> bc = bc + 1 <NEWLINE> if bc > m : <NEWLINE> <INDENT> flag = 1 <NEWLINE> break <NEWLINE> <DEDENT> s = s + b [ bc - 1 ] <NEWLINE> <DEDENT> bc = bc - 1 <NEWLINE> if flag == 0 : <NEWLINE> <INDENT> s = s - b [ bc - 1 ] <NEWLINE> <NL> <DEDENT> if max < ac + bc : <NEWLINE> <INDENT> max = ac + bc <NEWLINE> <NL> <DEDENT> <DEDENT> print ( max ) <NEWLINE>
N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> Asum = [ 0 ] <NEWLINE> Bsum = [ 0 ] <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> Asum . append ( Asum [ - 1 ] + A [ i ] ) <NEWLINE> <NL> <DEDENT> for i in range ( M ) : <NEWLINE> <INDENT> Bsum . append ( Bsum [ - 1 ] + B [ i ] ) <NEWLINE> <NL> <DEDENT> m = 0 <NEWLINE> j = M <NEWLINE> <NL> for i in range ( len ( Asum ) ) : <NEWLINE> <INDENT> if Asum [ i ] > K : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> elif Asum [ i ] + Bsum [ j ] <= K and m < i + j : <NEWLINE> <INDENT> m = i + j <NEWLINE> <DEDENT> elif : <NEWLINE> <INDENT> j -= 1 <NEWLINE> <DEDENT> <DEDENT> print ( m ) <NEWLINE>
import sys <NEWLINE> from collections import deque <NEWLINE> N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = deque ( [ int ( i ) for i in input ( ) . split ( ) ] ) <NEWLINE> B = deque ( [ int ( i ) for i in input ( ) . split ( ) ] ) <NEWLINE> if sum ( A ) + sum ( B ) <= K : <NEWLINE> <INDENT> print ( N + M ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> cur = 0 <NEWLINE> ans = 0 <NEWLINE> while cur < K and ans < N + M : <NEWLINE> <INDENT> if len ( A ) != 0 and len ( B ) != 0 : <NEWLINE> <INDENT> a = A . popleft ( ) <NEWLINE> b = B . popleft ( ) <NEWLINE> if a <= b : <NEWLINE> <INDENT> cur += a <NEWLINE> if cur > K : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> B . appendleft ( b ) <NEWLINE> ans += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cur += b <NEWLINE> if cur > K : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> A . appendleft ( a ) <NEWLINE> ans += 1 <NEWLINE> <DEDENT> <DEDENT> elif len ( A ) == 0 : <NEWLINE> <INDENT> b = B . popleft ( ) <NEWLINE> cur += b <NEWLINE> if cur > K : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> ans += 1 <NEWLINE> <DEDENT> elif len ( B ) == 0 : <NEWLINE> <INDENT> a = A . popleft ( ) <NEWLINE> cur += a <NEWLINE> if cur > K : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> from collections import deque <NEWLINE> N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = deque ( [ int ( i ) for i in input ( ) . split ( ) ] ) <NEWLINE> B = deque ( [ int ( i ) for i in input ( ) . split ( ) ] ) <NEWLINE> <NL> num = 0 <NEWLINE> cur1 , cur2 = 0 , 0 <NEWLINE> while cur1 < N and cur2 < M and num < K : <NEWLINE> <INDENT> if A [ cur1 ] <= B [ cur2 ] : <NEWLINE> <INDENT> num += A [ cur1 ] <NEWLINE> cur1 += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> num += B [ cur2 ] <NEWLINE> cur2 += 1 <NEWLINE> <DEDENT> <DEDENT> amari = N - cur1 - cur2 <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> a , b = [ 0 ] , [ 0 ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> a . append ( a [ i ] + A [ i ] ) <NEWLINE> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> b . append ( b [ i ] + B [ i ] ) <NEWLINE> <NL> <DEDENT> ans , j = 0 , M <NEWLINE> for i in range ( N + 1 ) : <NEWLINE> <INDENT> if a [ i ] > K : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> while b [ j ] > K - a [ i ] : <NEWLINE> <INDENT> j -= 1 <NEWLINE> <DEDENT> ans = max ( ans , i + j ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c = [ 0 ] <NEWLINE> d = [ 0 ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> c . append ( a [ i ] + c [ i ] ) <NEWLINE> <DEDENT> for i in range ( m ) : <NEWLINE> <INDENT> d . append ( b [ i ] + d [ i ] ) <NEWLINE> <DEDENT> e = 0 <NEWLINE> for i in range ( n + 1 ) : <NEWLINE> <INDENT> if a [ i ] > k : <NEWLINE> <INDENT> break ; <NEWLINE> <DEDENT> while b [ m ] > k - a [ i ] : <NEWLINE> <INDENT> m -= 1 <NEWLINE> <DEDENT> e = max ( e , i + m ) <NEWLINE> <DEDENT> print ( e ) <NEWLINE>
n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ map ( int , input ( ) . split ( ) ) ] <NEWLINE> b = [ map ( int , input ( ) . split ( ) ) ] <NEWLINE> <NL> aa , bb = [ 0 ] , [ 0 ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> aa . append ( aa [ i ] + a [ i ] ) <NEWLINE> <DEDENT> for i in range ( m ) : <NEWLINE> <INDENT> bb . append ( bb [ i ] + b [ i ] ) <NEWLINE> <DEDENT> ans , j = 0 , m <NEWLINE> for i in range ( n + 1 ) : <NEWLINE> <INDENT> if aa [ i ] > k : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> while b [ j ] > k - aa [ i ] : <NEWLINE> <INDENT> j -= 1 <NEWLINE> <DEDENT> ans = max ( ans , i + j ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> Nnums = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> Mnums = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> Nmax = len ( Nnums ) <NEWLINE> Mmax = len ( Mnums ) <NEWLINE> Nsum = 0 <NEWLINE> Ncnt = 0 <NEWLINE> <NL> <COMMENT> <NL> for Ni , Nl in enumerate ( Nnums ) : <NEWLINE> <INDENT> Nsum += Nl <NEWLINE> Ncnt = Ni <NEWLINE> if Nsum > K : <NEWLINE> <INDENT> Nsum -= Nl <NEWLINE> Ncnt = Ni - 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> chkSum = Nsum <NEWLINE> chkCnt = Ncnt + 1 <NEWLINE> AnsCnt = Ncnt + 1 <NEWLINE> <NL> <COMMENT> <NL> for Mi , Ml in enumerate ( Mnums ) : <NEWLINE> <INDENT> chkSum += Ml <NEWLINE> chkCnt += 1 <NEWLINE> if ( chkSum > K ) : <NEWLINE> <INDENT> if <NEWLINE> while chkSum > K : <NEWLINE> <INDENT> if not Ncnt < 0 : <NEWLINE> <INDENT> chkSum -= Nnums [ Ncnt ] <NEWLINE> chkCnt -= 1 <NEWLINE> Ncnt -= 1 <NEWLINE> <DEDENT> elif : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if ( AnsCnt < chkCnt ) : <NEWLINE> <INDENT> AnsCnt = chkCnt <NEWLINE> <NL> <DEDENT> if ( Ncnt < 0 ) : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( AnsCnt ) <NEWLINE>
n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> p , q = [ 0 ] , [ 0 ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> p . append ( p [ i ] + a [ i ] ) <NEWLINE> <DEDENT> for i in range ( m ) : <NEWLINE> <INDENT> q . append ( q [ i ] + b [ i ] ) <NEWLINE> <NL> <DEDENT> j , ans = m , 0 <NEWLINE> for i in range ( N + 1 ) : <NEWLINE> <INDENT> if a [ i ] > k : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> while b [ j ] > k - a [ i ] : <NEWLINE> <INDENT> j -= 1 <NEWLINE> <NL> <DEDENT> ans = max ( ans , i + j ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> A = [ 0 ] <NEWLINE> B = [ 0 ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> A . append ( A [ i ] + a [ i ] ) <NEWLINE> <DEDENT> for i in range ( M ) : <NEWLINE> <INDENT> B . append ( B [ i ] + b [ i ] ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> j = M <NEWLINE> for n in range ( N + 1 ) : <NEWLINE> <INDENT> while B [ j ] > K - A [ n ] : <NEWLINE> <INDENT> j -= 1 <NEWLINE> <DEDENT> ans = max ( ans , n + j ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
from itertools import accumulate <NEWLINE> <NL> n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> A = [ 0 ] + A <NEWLINE> A = list ( accumulate ( A ) ) <NEWLINE> <NL> B = [ 0 ] + B <NEWLINE> B = list ( accumulate ( B ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> b_cnt = m <NEWLINE> for a_cnt in range ( n + 1 ) : <NEWLINE> <INDENT> if a_cnt > k : continue <NEWLINE> <NL> while A [ a_cnt ] + B [ b_cnt ] > k : <NEWLINE> <INDENT> b_cnt -= 1 <NEWLINE> <DEDENT> ans = max ( ans , a_cnt + b_cnt ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> def LI ( ) : return list ( map ( int , sys . stdin . buffer . readline ( ) . split ( ) ) ) <NEWLINE> def I ( ) : return int ( sys . stdin . buffer . readline ( ) ) <NEWLINE> def LS ( ) : return sys . stdin . buffer . readline ( ) . rstrip ( ) . decode ( <STRING> ) . split ( ) <NEWLINE> def S ( ) : return sys . stdin . buffer . readline ( ) . rstrip ( ) . decode ( <STRING> ) <NEWLINE> def IR ( n ) : return [ I ( ) for i in range ( n ) ] <NEWLINE> def LIR ( n ) : return [ LI ( ) for i in range ( n ) ] <NEWLINE> def SR ( n ) : return [ S ( ) for i in range ( n ) ] <NEWLINE> def LSR ( n ) : return [ LS ( ) for i in range ( n ) ] <NEWLINE> def SRL ( n ) : return [ list ( S ( ) ) for i in range ( n ) ] <NEWLINE> def MSRL ( n ) : return [ [ int ( j ) for j in list ( S ( ) ) ] for i in range ( n ) ] <NEWLINE> <NL> mod = 10 ** 9 + 7 <NEWLINE> <NL> N , M , K = LS ( ) <NEWLINE> desk = LSR ( 2 ) <NEWLINE> a , b = [ 0 ] , [ 0 ] <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> for i in range ( N ) : <NEWLINE> <INDENT> a . append ( a [ i ] + desk [ 0 ] [ i ] ) <NEWLINE> <DEDENT> for j in range ( M ) : <NEWLINE> <INDENT> b . append ( b [ j ] + desk [ 1 ] [ j ] ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> ans , j = 0 , M <NEWLINE> <NL> for i in range ( N + 1 ) : <NEWLINE> <INDENT> if a > K : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> while b [ j ] > K - a [ i ] : <NEWLINE> <INDENT> j -= 1 <NEWLINE> <DEDENT> ans = max ( ans , i + j ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
a . append ( <STRING> ) <NEWLINE> b . append ( <STRING> ) <NEWLINE> a [ n ] = int ( a [ n ] ) <NEWLINE> b [ m ] = int ( b [ m ] ) <NEWLINE> <NL> x = 0 <NEWLINE> y = 0 <NEWLINE> ans = 0 <NEWLINE> time = 0 <NEWLINE> <NL> for i in range ( n + m ) : <NEWLINE> <INDENT> if a [ x ] <= b [ y ] : <NEWLINE> <INDENT> time += a [ x ] <NEWLINE> if time > k : <NEWLINE> <INDENT> time -= a [ x ] <NEWLINE> print ( ans ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> x += 1 <NEWLINE> ans += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> time += b [ y ] <NEWLINE> if time > k : <NEWLINE> <INDENT> time -= b [ y ] <NEWLINE> print ( ans ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> y += 1 <NEWLINE> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL>
n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> arr1 = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> arr2 = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> acum1 = [ 0 ] <NEWLINE> <NL> <COMMENT> <NL> for i in range ( n ) : <NEWLINE> <INDENT> acum1 . append ( acum [ - 1 ] + arr1 [ i ] ) <NEWLINE> <NL> <DEDENT> acum2 = [ 0 ] <NEWLINE> <NL> for i in range ( m ) : <NEWLINE> <INDENT> acum2 . append ( acum2 [ - 1 ] + arr2 [ i ] ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in range ( n + 1 ) : <NEWLINE> <INDENT> if acum1 [ i ] > k : <NEWLINE> <INDENT> break <NEWLINE> while acum2 [ j ] > k - acum1 [ i ] and j > 0 : <NEWLINE> j -= 1 <NEWLINE> <INDENT> ans = max ( ans , i + j ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> A = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> B = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> ans = 0 <NEWLINE> ai = 0 <NEWLINE> bi = 0 <NEWLINE> t = 0 <NEWLINE> while t < k and ( ai < len ( A ) or bi < len ( B ) ) : <NEWLINE> <INDENT> if ai < len ( A ) and bi < len ( B ) : <NEWLINE> <INDENT> a = A [ ai ] <NEWLINE> b = B [ bi ] <NEWLINE> if a < b : <NEWLINE> <INDENT> ai += 1 <NEWLINE> t += a <NEWLINE> if t = < k : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> bi += 1 <NEWLINE> t += b <NEWLINE> if t = < k : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> elif ai < len ( A ) : <NEWLINE> <INDENT> ai += 1 <NEWLINE> t += A [ ai ] <NEWLINE> if t = < k : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> bi += 1 <NEWLINE> t += B [ bi ] <NEWLINE> if t = < k : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL>
N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = [ 0 ] * ( N + 1 ) <NEWLINE> b = [ 0 ] * ( M + 1 ) <NEWLINE> X = 0 <NEWLINE> Y = 0 <NEWLINE> cnt = 0 <NEWLINE> for n in range ( N ) : <NEWLINE> <INDENT> a [ n + 1 ] = a [ n ] + A [ n ] <NEWLINE> <DEDENT> for n in range ( M ) : <NEWLINE> <INDENT> b [ n + 1 ] = b [ n ] + B [ n ] <NEWLINE> <DEDENT> ans , j = 0 , M <NEWLINE> for i in range ( N + 1 ) : <NEWLINE> <INDENT> if a [ i ] > K : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> while b [ j ] > K - a [ i ] : <NEWLINE> <INDENT> j -= 1 <NEWLINE> ans = max ( ans , i + j ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> import bisect <NEWLINE> import heapq <NEWLINE> import itertools <NEWLINE> import math <NEWLINE> from collections import Counter , defaultdict , deque <NEWLINE> from copy import deepcopy <NEWLINE> from decimal import Decimal <NEWLINE> from math import gcd <NEWLINE> from operator import add , itemgetter , mul , xor <NEWLINE> def cmb ( n , r , mod ) : <NEWLINE> <INDENT> bunshi = 1 <NEWLINE> bunbo = 1 <NEWLINE> for i in range ( r ) : <NEWLINE> <INDENT> bunbo = bunbo * ( i + 1 ) % mod <NEWLINE> bunshi = bunshi * ( n - i ) % mod <NEWLINE> <DEDENT> return ( bunshi * pow ( bunbo , mod - 2 , mod ) ) % mod <NEWLINE> <DEDENT> mod = 10 ** 9 + 7 <NEWLINE> def I ( ) : return int ( input ( ) ) <NEWLINE> def LI ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> def MI ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def LLI ( n ) : return [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ] <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> n , m , k = MI ( ) <NEWLINE> a = deque ( LI ( ) ) <NEWLINE> b = deque ( LI ( ) ) <NEWLINE> ans = 0 <NEWLINE> while k > 0 and len ( a ) + len ( b ) > 0 : <NEWLINE> <INDENT> if len ( a ) > 0 : <NEWLINE> <INDENT> book = a . popleft ( ) <NEWLINE> <DEDENT> if len ( a ) == 0 : <NEWLINE> <INDENT> book = 10 ** 10 <NEWLINE> <DEDENT> if len ( b ) > 0 : <NEWLINE> <INDENT> book2 = b . popleft ( ) <NEWLINE> <DEDENT> if len ( b ) == 0 : <NEWLINE> <INDENT> book2 = 10 ** 10 <NEWLINE> <DEDENT> if book < book2 : <NEWLINE> <INDENT> k -= book <NEWLINE> if k > 0 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> if book > book2 <NEWLINE> <INDENT> k -= book2 <NEWLINE> if k > 0 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> a_sum = [ 0 ] <NEWLINE> b_sum = [ 0 ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a_sum . append ( a_sum [ i ] + a [ i ] ) <NEWLINE> <DEDENT> for i in range ( m ) : <NEWLINE> <INDENT> b_sum . append ( b_sum [ j ] + b [ j ] ) <NEWLINE> <NL> <DEDENT> ans , j = 0 , m <NEWLINE> for i in range ( n + 1 ) : <NEWLINE> <INDENT> if a_sum [ i ] > k : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> while b_sum [ i ] > k - a_sum [ i ] : <NEWLINE> <INDENT> j -= 1 <NEWLINE> <DEDENT> ans = max ( ans , i + j ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> a , b = [ 0 ] , [ 0 ] <NEWLINE> for i in range ( N ) : <NEWLINE> a . append ( a [ i ] + A [ i ] ) <NEWLINE> for i in range ( M ) : <NEWLINE> b . append ( b [ i ] + B [ i ] ) <NEWLINE> <NL> ans , j = 0 , M <NEWLINE> for i in range ( N + 1 ) : <NEWLINE> if a [ i ] > K : <NEWLINE> break <NEWLINE> while b [ j ] > K - a [ i ] : <NEWLINE> j -= 1 <NEWLINE> ans = max ( ans , i + j ) <NEWLINE> print ( ans ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> a , b = [ 0 ] , [ 0 ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> a . append ( a [ i ] + A [ i ] ) <NEWLINE> <DEDENT> for i in range ( M ) : <NEWLINE> <INDENT> a . append ( b [ i ] + B [ i ] ) <NEWLINE> <NL> <DEDENT> ans , j = 0 , M <NEWLINE> for i in range ( N + 1 ) : <NEWLINE> <INDENT> if a [ i ] > K : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> while a [ i ] + b [ j ] > K : <NEWLINE> <INDENT> j -= 1 <NEWLINE> <NL> <DEDENT> ans = max ( ans , i + j ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> read = sys . stdin . buffer . read <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> readlines = sys . stdin . buffer . readlines <NEWLINE> <NL> n , m , k = map ( int , readline ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , readline ( ) . split ( ) ) ) <NEWLINE> b = list ( map ( int , readline ( ) . split ( ) ) ) <NEWLINE> <NL> sa = [ 0 ] * ( n + 1 ) <NEWLINE> sb = [ 0 ] * ( m + 1 ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> sa [ i + 1 ] = sa [ i ] + a [ i ] <NEWLINE> <DEDENT> for i in range ( m ) : <NEWLINE> <INDENT> sb [ i + 1 ] = sb [ i ] + b [ i ] <NEWLINE> <NL> <DEDENT> isb = m <NEWLINE> ans = 0 <NEWLINE> for isa in range ( n + 1 ) : <NEWLINE> <INDENT> if sa [ isa ] > k : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> while isb > 0 and sa [ isa ] + sb [ isb ] > K : <NEWLINE> <INDENT> isb -= 1 <NEWLINE> <DEDENT> ans = max ( ans , isa + isb ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
import numpy as np <NEWLINE> N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> A_array = np . array ( A ) <NEWLINE> B_array = np . array ( B ) <NEWLINE> A_cum = np . cumsum ( A_array ) <NEWLINE> B_cum = np . cumsum ( B_array ) <NEWLINE> for i in range ( len ( A_cum ) ) : <NEWLINE> <INDENT> k = A_cum [ i ] <NEWLINE> if k > K : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> a = 0 <NEWLINE> b = len ( B_cum ) - 1 <NEWLINE> print ( B_check ) <NEWLINE> while b - a != 0 : <NEWLINE> <INDENT> c = int ( round ( ( a + b ) / 2 ) ) <NEWLINE> if B_check [ c ] < 0 : <NEWLINE> <INDENT> b = c <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a = c <NEWLINE> <DEDENT> if b - a == 1 : <NEWLINE> <INDENT> if B_check [ b ] < 0 : <NEWLINE> <INDENT> b = a <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a = b <NEWLINE> <DEDENT> <DEDENT> <DEDENT> check = i + b + 2 <NEWLINE> if check > ans : <NEWLINE> <INDENT> ans = check <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> b = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> <NL> maxv = 0 <NEWLINE> acum = [ 0 ] * ( n + 1 ) <NEWLINE> bcum = [ 0 ] * ( m + 1 ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> acum [ i + 1 ] = acum [ i ] + a [ i ] <NEWLINE> <DEDENT> for i in range ( m ) : <NEWLINE> <INDENT> bcum [ i + 1 ] = bcum [ i ] + b [ i ] <NEWLINE> <NL> <DEDENT> for i in range ( n + 1 ) : <NEWLINE> <INDENT> if acum [ i ] > k : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> maxv = max ( maxv , i + bisect_right ( bcum , k - acum [ i ] ) - 1 ) <NEWLINE> <DEDENT> print ( maxv ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> using namespace std ; <NEWLINE> using ll = long long ; <NEWLINE> using P = pair < int , int > ; <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> int N , M ; <NEWLINE> int K = 0 ; <NEWLINE> int res = 0 ; <NEWLINE> <NL> int A [ MAX_N ] ; <NEWLINE> int B [ MAX_M ] ; <NEWLINE> <NL> <NL> int main ( int argc , const char * argv [ ] ) { <NEWLINE> <NL> <INDENT> cin >> N >> M >> K ; <NEWLINE> <NL> rep ( i , N ) { <NEWLINE> <INDENT> int a ; <NEWLINE> cin >> a ; <NEWLINE> if ( i == 0 ) A [ i ] = a ; <NEWLINE> else A [ i ] = A [ i - 1 ] + a ; <NEWLINE> <DEDENT> } <NEWLINE> <NL> rep ( i , M ) { <NEWLINE> <INDENT> int b ; <NEWLINE> cin >> b ; <NEWLINE> if ( i == 0 ) B [ i ] = b ; <NEWLINE> else B [ i ] = B [ i - 1 ] + b ; <NEWLINE> <DEDENT> } <NEWLINE> <NL> int a = 0 ; <NEWLINE> for ( int i = 0 ; i < N ; i + + ) { <NEWLINE> <INDENT> if ( A [ i ] > K ) continue ; <NEWLINE> <NL> a = i + 1 ; <NEWLINE> <DEDENT> } <NEWLINE> int b = M ; <NEWLINE> for ( int j = M - 1 ; j >= 0 ; j - - ) { <NEWLINE> <INDENT> if ( B [ j ] <= K - A [ a ] ) { <NEWLINE> <INDENT> res = max ( res , a + b ) ; <NEWLINE> break ; <NEWLINE> <DEDENT> } <NEWLINE> b - - ; <NEWLINE> <DEDENT> } <NEWLINE> <NL> cout << res << endl ; <NEWLINE> <NL> return 0 ; <NEWLINE> <DEDENT> } <NEWLINE>
n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> aindex = n + 1 <NEWLINE> bindex = m + 1 <NEWLINE> acumsum = [ 0 ] <NEWLINE> bcumsum = [ 0 ] <NEWLINE> <NL> ab = 0 <NEWLINE> for aa in range ( n ) : <NEWLINE> <INDENT> ab += a [ aa ] <NEWLINE> acumsum . append ( ab ) <COMMENT> <NEWLINE> if ab > k : <NEWLINE> <INDENT> aindex = aa <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> ab = 0 <NEWLINE> for bb in range ( m ) : <NEWLINE> <INDENT> ab += b [ bb ] <NEWLINE> bcumsum . append ( ab ) <NEWLINE> if ab > k : <NEWLINE> <INDENT> bindex = bb <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> j = m <NEWLINE> for i in range ( n + 1 ) : <NEWLINE> <INDENT> if acumsum [ i ] > k : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> while bcumsum [ j ] > k - acumsum [ i ] : <NEWLINE> <INDENT> j -= 1 <NEWLINE> <DEDENT> ans = max ( ans , i + j ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
n , m , k = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> import numpy as np <NEWLINE> import bisect <NEWLINE> a = np . cumsum ( a ) <NEWLINE> b = np . cumsum ( b ) <NEWLINE> ans = 0 <NEWLINE> r = m <NEWLINE> for i in range ( n + 1 ) : <NEWLINE> <INDENT> if a [ i ] > k : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> while a [ i ] + b [ r ] > k : <NEWLINE> <INDENT> r -= 1 <NEWLINE> <DEDENT> ans = max ( ans , i + r ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> max_count = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a_sum = sum ( a [ : i + 1 ] ) <NEWLINE> for j in range ( m ) : <NEWLINE> <INDENT> b_sum = sum ( b [ : j + 1 ] ) <NEWLINE> if ( a_sum + b_sum <= k ) & & ( a_sum + b_sum > max_count ) : <NEWLINE> <INDENT> max_count = i + j + 2 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( max_count ) <NEWLINE>
from collections import deque <NEWLINE> n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> a , b = [ 0 ] , [ 0 ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a . append ( a [ i ] + A [ i ] ) <NEWLINE> <DEDENT> for i in range ( m ) : <NEWLINE> <INDENT> b . append ( b [ i ] + B [ i ] ) <NEWLINE> <DEDENT> ans , j = 0 , m <NEWLINE> for i in range ( N + 1 ) : <NEWLINE> <INDENT> if a [ i ] > k : break <NEWLINE> while b [ j ] > k - a [ i ] : <NEWLINE> <INDENT> j -= 1 <NEWLINE> <DEDENT> ans = max ( ans , i + j ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int . input ( ) . split ( ) ) ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> a [ i ] += a [ i - 1 ] <NEWLINE> <DEDENT> for i in range ( 1 , m ) : <NEWLINE> <INDENT> b [ i ] += b [ i - 1 ] <NEWLINE> <DEDENT> ans = - 100 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( m ) : <NEWLINE> <INDENT> if ( a [ i ] + b [ j ] >= k ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> ans = max ( ans , a [ i ] + b [ j ] ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from itertools import accumulate <NEWLINE> <NL> N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( accumulate ( int ( i ) for i in input ( ) . split ( ) , initial = 0 ) ) <NEWLINE> b = list ( accumulate ( int ( i ) for i in input ( ) . split ( ) , initial = 0 ) ) <NEWLINE> <NL> cnt = 0 <NEWLINE> best0 = M <NEWLINE> for i in range ( N + 1 ) : <NEWLINE> <INDENT> ai = a [ i ] <NEWLINE> for j in range ( best0 , - 1 , - 1 ) : <NEWLINE> <INDENT> bj = b [ j ] <NEWLINE> if ai + bj <= K : <NEWLINE> <INDENT> cnt = max ( cnt , i + j ) <NEWLINE> best0 = j <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ 0 ] + list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = [ 0 ] + list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for a in A : <NEWLINE> <INDENT> A [ a ] += A [ a + 1 ] <NEWLINE> <NL> <DEDENT> for b in B : <NEWLINE> <INDENT> B [ b ] += B [ b + 1 ] <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> op = m <NEWLINE> for i in range ( n + 1 ) : <NEWLINE> <INDENT> if A [ i ] > k : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> while A [ i ] + B [ op ] > k : <NEWLINE> <INDENT> op -= 1 <NEWLINE> <NL> <DEDENT> ans = max ( ans , i + op ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
[ n , m , k ] = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> <NL> a = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> b = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> <NL> if sum ( a ) + sum ( b ) <= k : <NEWLINE> <INDENT> print ( n + m ) <NEWLINE> <NL> <NL> <DEDENT> else : <NEWLINE> <INDENT> if sum ( a ) < sum ( b ) : <NEWLINE> <INDENT> small = a <NEWLINE> big = b <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> small = b <NEWLINE> big = a <NEWLINE> <NL> <COMMENT> <NL> <NL> <DEDENT> if sum ( small ) == k : <NEWLINE> <INDENT> print ( len ( small ) ) <NEWLINE> <NL> <NL> <DEDENT> if sum ( small ) < k : <NEWLINE> <INDENT> count = 0 <NEWLINE> while sum ( small ) < k : <NEWLINE> <INDENT> small . append ( big . pop ( 0 ) ) <NEWLINE> count += 1 <NEWLINE> <NL> <DEDENT> print ( len ( small ) + count ) <NEWLINE> <NL> <DEDENT> elif sum ( small ) > k : <NEWLINE> <COMMENT> <NL> <INDENT> while len ( small ) > 0 and sum ( small ) > k : <NEWLINE> <INDENT> small . pop ( 0 ) <NEWLINE> <DEDENT> count = 0 <NEWLINE> while len ( small ) > 0 and sum ( small ) <= k : <NEWLINE> <INDENT> small . append ( big . pop ( 0 ) ) <NEWLINE> if sum ( small ) > k : <NEWLINE> <INDENT> small . pop ( ) <NEWLINE> <DEDENT> count += 1 <NEWLINE> <DEDENT> print ( len ( small ) ) <NEWLINE> <COMMENT> <NL> <NL> <NL> <NL> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <NL> <NL> <COMMENT> <NL> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> <NL> <NL> <DEDENT> <DEDENT>
import numpy as np <NEWLINE> import sys <NEWLINE> read = sys . stdin . buffer . read <NEWLINE> <NL> <NL> N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> AB = np . array ( read ( ) . split ( ) , np . int32 ) <NEWLINE> A = [ 0 ] + np . cumsum ( AB [ : N ] ) . tolist ( ) <NEWLINE> B = [ 0 ] + np . cumsum ( AB [ N : ] ) . tolist ( ) <NEWLINE> assert ( N == len ( A ) - 1 ) and ( M == len ( B ) - 1 ) <NEWLINE> <NL> left = 0 <NEWLINE> for i , b in enumerate ( B ) : <NEWLINE> <INDENT> if b > K : <NEWLINE> <INDENT> left = i - 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> ans = 0 <NEWLINE> if A [ - 1 ] + B [ - 1 ] <= K : <NEWLINE> <INDENT> ans = N + M <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( len ( A ) ) : <NEWLINE> <INDENT> if A [ i ] > K : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> while A [ i ] + B [ left ] > K : <NEWLINE> <INDENT> left -= 1 <NEWLINE> <NL> <DEDENT> ans = max ( ans , left + i ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a , b = [ 0 ] , [ 0 ] <NEWLINE> for i in range ( N ) : <NEWLINE> a . append ( a [ i ] + A [ i ] ) <NEWLINE> for i in range ( M ) : <NEWLINE> b . append ( b [ i ] + B [ i ] ) <NEWLINE> ans , j = 0 , M <NEWLINE> for i in range ( N + 1 ) : <NEWLINE> if a [ i ] > K : <NEWLINE> break <NEWLINE> while b [ j ] > K - a [ i ] : <NEWLINE> j -= 1 <NEWLINE> ans = max ( ans , i + j ) <NEWLINE> print ( ans ) <NEWLINE>
n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> ln = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> lm = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> def csum ( l , ll ) : <NEWLINE> <INDENT> s = 0 <NEWLINE> res = [ 0 ] * ll <NEWLINE> for i in range ( ll ) : <NEWLINE> <INDENT> s += l [ i ] <NEWLINE> res [ i ] = s <NEWLINE> <DEDENT> return res <NEWLINE> <NL> <DEDENT> csln = csum ( ln , n ) <NEWLINE> cslm = csum ( lm , m ) <NEWLINE> <NL> import numpy as np <NEWLINE> <NL> lk = [ k - x for x in csln if k - x >= 0 ] <NEWLINE> res = np . searchsorted ( np . array ( cslm ) , np . array ( lk ) , side = <STRING> ) . <NEWLINE> rmax = 0 <NEWLINE> for i , j in zip ( range ( 1 , len ( lk ) + 1 ) , res ) : <NEWLINE> <INDENT> rmax = max ( rmax , i + j ) <NEWLINE> <DEDENT> print ( int ( rmax ) ) <NEWLINE>
<COMMENT> <NL> from numba import njit <NEWLINE> <NL> <NL> @ njit <NEWLINE> def solve ( N ) : <NEWLINE> <INDENT> res = 0 <NEWLINE> for a in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> for b in range ( 1 , N // a + 1 ) : <NEWLINE> <INDENT> res += a * b <NEWLINE> <DEDENT> <DEDENT> return res <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> print ( solve ( N ) ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> f = open ( <STRING> ) <NEWLINE> n , m , k = map ( int , f . readline ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , f . readline ( ) . split ( ) ) ) <NEWLINE> b = list ( map ( int , f . readline ( ) . split ( ) ) ) <NEWLINE> <NL> a_sum = [ 0 ] <NEWLINE> b_sum = [ 0 ] <NEWLINE> cnt = 0 <NEWLINE> best_b = m <NEWLINE> confirm = ( ) <NEWLINE> <NL> for i in a : <NEWLINE> <INDENT> a_sum . append ( i + a_sum [ - 1 ] ) <NEWLINE> <NL> <DEDENT> for i in b : <NEWLINE> <INDENT> b_sum . append ( i + b_sum [ - 1 ] ) <NEWLINE> <NL> <DEDENT> for a_idx in range ( n + 1 ) : <NEWLINE> <INDENT> if a_sum [ a_idx ] > k : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for b_idx in reversed ( range ( best_b + 1 ) ) : <NEWLINE> <INDENT> if b_sum [ b_idx ] + a_sum [ a_idx ] <= k : <NEWLINE> <COMMENT> <NL> <INDENT> cnt = max ( cnt , a_idx + b_idx ) <NEWLINE> best_b = b_idx <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
<NL> N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> max = 0 <NEWLINE> <NL> A . insert ( 0 , 0 ) <NEWLINE> A = numpy . cumsum ( A ) <NEWLINE> B . insert ( 0 , 0 ) <NEWLINE> B = numpy . cumsum ( B ) <NEWLINE> <NL> ans , j = 0 , M <NEWLINE> for i in range ( N + 1 ) : <NEWLINE> <INDENT> if a [ i ] > K : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> while b [ j ] > K - a [ i ] : <NEWLINE> <INDENT> j -= 1 <NEWLINE> <NL> <DEDENT> ans = max ( ans , i + j ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> N , M , K = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <COMMENT> <NL> a , b = [ 0 ] , [ 0 ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> a . append ( a [ i ] + A [ i ] ) <NEWLINE> <DEDENT> for j in range ( M ) : <NEWLINE> <INDENT> b . append ( b [ i ] + B [ i ] ) <NEWLINE> <NL> <DEDENT> ans , j = 0 , M <NEWLINE> for i in range ( N + 1 ) : <NEWLINE> <INDENT> if a [ i ] > K : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> while b [ j ] > K - a [ i ] : <NEWLINE> <INDENT> j -= 1 <NEWLINE> <DEDENT> ans = max ( ans , i + j ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> prog = 0 <NEWLINE> a_idx = 0 <NEWLINE> b_idx = 0 <NEWLINE> <NL> while a_idx < n : <NEWLINE> <INDENT> if a [ a_idx ] + prog > k : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> prog += a [ a_idx ] <NEWLINE> a_idx += 1 <NEWLINE> <NL> <DEDENT> if a_idx == n : <NEWLINE> <INDENT> while b_idx < m : <NEWLINE> <INDENT> if b [ b_idx ] + prog > k : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> prog += b [ b_idx ] <NEWLINE> b_idx += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> mx = a_idx + b_idx <NEWLINE> <NL> if mx == n + m : <NEWLINE> <INDENT> print ( mx ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> for i in range ( a_idx ) : <NEWLINE> <INDENT> while b [ b_idx ] + prog <= k or b_idx < m : <NEWLINE> <INDENT> prog += b [ b_idx ] <NEWLINE> b_idx += 1 <NEWLINE> <DEDENT> if a_idx + b_idx > mx : <NEWLINE> <INDENT> mx = a_idx + b_idx <NEWLINE> <DEDENT> if b_idx == m : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> a_idx -= 1 <NEWLINE> prog -= a [ a_idx ] <NEWLINE> <NL> <DEDENT> print ( mx ) <NEWLINE>
N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> times_a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> times_b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> read_time = 0 <NEWLINE> read_time_a = [ 0 ] <NEWLINE> read_time_b = [ 0 ] <NEWLINE> for i in range ( len ( times_a ) ) : <NEWLINE> <INDENT> read_time_a . append ( read_time_a [ i ] + times_a [ i ] ) <NEWLINE> <DEDENT> for i in range ( len ( times_b ) ) : <NEWLINE> <INDENT> read_time_b . append ( read_time_b [ i ] + times_b [ i ] ) <NEWLINE> <DEDENT> count = 0 <NEWLINE> for i in range ( N + 1 ) : <NEWLINE> <INDENT> t = read_time_a [ i ] <NEWLINE> l = 0 <NEWLINE> r = len ( read_time_b ) <NEWLINE> while l + 1 < r : <NEWLINE> <INDENT> c = ( l + r ) // 2 <NEWLINE> if t + read_time_b [ c ] <= K : <NEWLINE> <INDENT> l = c <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> r = c <NEWLINE> <DEDENT> <DEDENT> if read_time_a [ i ] + read_time_b [ l ] <= K : <NEWLINE> <INDENT> ans = max ( ans , i + l ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n , m , k = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> a , b = [ 0 ] , [ 0 ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a . apppend ( a [ i ] + A [ i ] ) <NEWLINE> <NL> <DEDENT> for i in range ( m ) : <NEWLINE> <INDENT> b . append ( b [ i ] + B [ i ] ) <NEWLINE> <NL> <DEDENT> ans , j = 0 , m <NEWLINE> <NL> for i in range ( n + 1 ) : <NEWLINE> <INDENT> if a [ i ] > k : <NEWLINE> <INDENT> break <NEWLINE> while b [ j ] > k - a [ i ] : <NEWLINE> j -= 1 <NEWLINE> <NL> ans = max ( ans , i + j ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL>
<COMMENT> <NL> N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> a = [ 0 ] <NEWLINE> b = [ 0 ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> a . append ( a [ i ] + A [ i ] ) <NEWLINE> <DEDENT> for j in range ( M ) : <NEWLINE> <INDENT> b . append ( b [ j ] + B [ j ] ) <NEWLINE> <DEDENT> ans = 0 <NEWLINE> l = M <NEWLINE> for k in range ( N + 1 ) : <NEWLINE> <INDENT> if a [ k ] > K : <NEWLINE> <INDENT> break : <NEWLINE> <DEDENT> while b [ l ] > K - a [ k ] : <NEWLINE> <INDENT> l -= 1 <NEWLINE> <DEDENT> ans = max ( ans , k + l ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
N , M , K = map ( int , input ( ) . split ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> a = [ 0 ] <NEWLINE> b = [ 0 ] <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> a . append ( a [ i ] + A [ i ] ) <NEWLINE> <NL> <DEDENT> for j in range ( M ) : <NEWLINE> <INDENT> b . append ( b [ i ] + B [ i ] ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> j = M <NEWLINE> <NL> for i in range ( N + 1 ) : <NEWLINE> <INDENT> if a [ i ] > K : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> while b [ j ] > K - a [ i ] : <NEWLINE> <INDENT> j -= 1 <NEWLINE> <DEDENT> ans = max ( i + j , ans ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
<NL> N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A_list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B_list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> A_list . insert ( 0 , 0 ) <NEWLINE> B_list . insert ( 0 , 0 ) <NEWLINE> B_cumsum = np . cumsum ( B_list ) <NEWLINE> <NL> time = B_cumsum [ - 1 ] <NEWLINE> ans , j = 0 , M <NEWLINE> <NL> for i in range ( N + 1 ) : <NEWLINE> <INDENT> if ( time > K ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> while ( j > 0 and time > K ) : <NEWLINE> <INDENT> time -= B_list [ j ] <NEWLINE> j -= 1 <NEWLINE> <NL> <DEDENT> ans = max ( ans , i + j ) <NEWLINE> time += A_list [ i ] <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> a , b = [ 0 ] , [ 0 ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> a . append ( a [ i ] + A [ i ] ) <NEWLINE> <DEDENT> for i in range ( M ) : <NEWLINE> <INDENT> b . append ( b [ i ] + B [ i ] ) <NEWLINE> <NL> <DEDENT> ans , j = 0 , M <NEWLINE> for i in range ( N + 1 ) : <NEWLINE> <INDENT> if a [ i ] > K : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> while b [ j ] > K - a [ i ] : <NEWLINE> <INDENT> j -= 1 <NEWLINE> ans = max ( ans , i + j ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> a = [ 0 ] <NEWLINE> b = [ 0 ] <NEWLINE> aa = 0 <NEWLINE> bb = 0 <NEWLINE> for i in A : <NEWLINE> <INDENT> aa += i <NEWLINE> a . append ( aa ) <NEWLINE> <DEDENT> for j in B : <NEWLINE> <INDENT> bb += j <NEWLINE> b . append ( bb ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> cnt = 0 <NEWLINE> lb = len ( b ) - 1 <NEWLINE> for i in range ( len ( a ) ) : <NEWLINE> <INDENT> cnt = a [ i ] <NEWLINE> if ( cnt > K ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for j in reversed ( range ( lb ) ) : <NEWLINE> <INDENT> tmp = cnt + b [ j ] <NEWLINE> if ( tmp > K ) : <NEWLINE> <INDENT> lb = j <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = max ( i + j , ans ) <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> sum_A = [ 0 ] <NEWLINE> sum_B = [ 0 ] <NEWLINE> for n in range ( N ) : <NEWLINE> <INDENT> sum_A . append ( sum_A [ n ] + A [ n ] ) <NEWLINE> <DEDENT> for m in range ( M ) : <NEWLINE> <INDENT> sum_B . append ( sum_B [ m ] + B [ m ] ) <NEWLINE> <NL> <DEDENT> max_j = M <NEWLINE> max_book = 0 <NEWLINE> for i in range ( N + 1 ) : <NEWLINE> <COMMENT> <NL> <INDENT> if sum_A > K : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for j in range ( max_j , - 1 , - 1 ) : <NEWLINE> <INDENT> if sum_A [ i ] + sum_B [ j ] <= K : <NEWLINE> <INDENT> max_j = j <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> max_j = 0 <NEWLINE> <NL> <DEDENT> max_book = max ( max_book , i + max_j ) <NEWLINE> <NL> <DEDENT> print ( max_book ) <NEWLINE>
import sys <NEWLINE> n , m , k = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in range ( 1 , n ) : <NEWLINE> <INDENT> a [ i ] += a [ i - 1 ] <NEWLINE> <DEDENT> for i in range ( 1 , m ) : <NEWLINE> <INDENT> b [ i ] += b [ i - 1 ] <NEWLINE> <DEDENT> a_max = 0 <NEWLINE> for i in range ( n , 0 , - 1 ) <NEWLINE> <INDENT> if a [ i - 1 ] <= k : <NEWLINE> <INDENT> a_max = i <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> b_max = 0 <NEWLINE> for i in range ( m , 0 , - 1 ) <NEWLINE> <INDENT> if a [ i - 1 ] <= k : <NEWLINE> <INDENT> b_max = i <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for i in range ( a_max , 0 , - 1 ) : <NEWLINE> <INDENT> p = 0 <NEWLINE> q = 0 <NEWLINE> if a [ i - 1 ] <= k : <NEWLINE> <INDENT> p = a [ i - 1 ] <NEWLINE> q = i <NEWLINE> <DEDENT> for j in range ( b_max , 0 , - 1 ) : <NEWLINE> <INDENT> if p + b [ j - 1 ] <= k : <NEWLINE> <INDENT> ans = max ( ans , q + j ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> a , b = [ 0 ] , [ 0 ] <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> a . append ( a [ i ] + A [ i ] ) <NEWLINE> b . append ( b [ i ] + B [ i ] ) <NEWLINE> <NL> <DEDENT> ans , j = 0 , M <NEWLINE> for i in range ( N + 1 ) : <NEWLINE> <INDENT> if a [ i ] > K : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> while b [ j ] > K - a [ i ] : <NEWLINE> <INDENT> j -= 1 <NEWLINE> <DEDENT> ans = max ( ans , i + j ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = [ 0 ] <NEWLINE> b = [ 0 ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> a . append ( a [ i ] + A [ i ] ) <NEWLINE> <DEDENT> for i in range ( M ) : <NEWLINE> <INDENT> b . append ( b [ i ] + B [ i ] ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> j = M <NEWLINE> for i in range ( N + 1 ) : <NEWLINE> <INDENT> if a [ i ] > K : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> while b [ i ] > K - a [ i ] : <NEWLINE> <INDENT> j -= 1 <NEWLINE> <DEDENT> ans = max ( ans , i + j ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> a , b = [ 0 ] , [ 0 ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a . append ( a [ i ] + A [ i ] ) <NEWLINE> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> b . append ( b [ i ] + B [ i ] ) <NEWLINE> <NL> <DEDENT> ans , j = 0 , m <NEWLINE> for i in range ( n + 1 ) : <NEWLINE> <INDENT> if a [ i ] > k : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> while b [ j ] > k - a [ i ] : <NEWLINE> <INDENT> j -= 1 <NEWLINE> <DEDENT> ans = max ( ans , i + j ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n , m , k = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = sum ( B ) <NEWLINE> ka = k <NEWLINE> i = m <NEWLINE> re = 0 <NEWLINE> for a in A : <NEWLINE> <INDENT> if ka < 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> while ka < b and i > 0 : <NEWLINE> <INDENT> b -= B [ i ] <NEWLINE> i -= 1 <NEWLINE> <DEDENT> ka -= a <NEWLINE> re += 1 <NEWLINE> <NL> <DEDENT> print ( re + i ) <NEWLINE>
N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> sum_A = [ 0 ] <NEWLINE> for i , a in enumerate ( A , 1 ) : <NEWLINE> <INDENT> tmp = sum_A [ i - 1 ] + a <NEWLINE> if tmp <= K : <NEWLINE> <INDENT> sum_A . append ( tmp ) <NEWLINE> mark_A = i <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> sum_B = [ 0 ] <NEWLINE> for i , b in enumerate ( B , 1 ) : <NEWLINE> <INDENT> tmp = sum_B [ i - 1 ] + b <NEWLINE> if tmp <= K : <NEWLINE> <INDENT> sum_B . append ( tmp ) <NEWLINE> mark_B = i <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> ans = 0 <NEWLINE> j = M <NEWLINE> <NL> for i , a in enumerate ( sum_A ) : <NEWLINE> <INDENT> while sum_B [ j ] > K - a : <NEWLINE> <INDENT> j -= 1 <NEWLINE> <NL> <DEDENT> ans = max ( ans , i + j ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> def input2 ( ) : <NEWLINE> <INDENT> return map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <DEDENT> n , m , k = input2 ( ) <NEWLINE> A = input_array ( ) <NEWLINE> B = input_array ( ) <NEWLINE> <NL> ca = 0 <NEWLINE> cb = 0 <NEWLINE> count = 0 <NEWLINE> SUM = 0 <NEWLINE> for i in range ( n + m ) : <NEWLINE> <INDENT> if ca >= n : <NEWLINE> <INDENT> SUM += B [ cb ] <NEWLINE> cb += 1 <NEWLINE> <DEDENT> elif cb >= m : <NEWLINE> <INDENT> SUM += A [ ca ] <NEWLINE> ca += 1 <NEWLINE> <DEDENT> elif A [ ca ] <= B [ cb ] : <NEWLINE> <INDENT> SUM += A [ ca ] <NEWLINE> ca += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> SUM += B [ cb ] <NEWLINE> cb += 1 <NEWLINE> <NL> <DEDENT> if SUM > k : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> cum_a = [ ] <NEWLINE> total = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> total += a [ i ] <NEWLINE> if total > k : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> cum_a . append ( total ) <NEWLINE> <NL> <DEDENT> cum_b = [ ] <NEWLINE> total = 0 <NEWLINE> for j in range ( m ) : <NEWLINE> <INDENT> total += b [ j ] <NEWLINE> if total > k : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> cum_b . append ( total ) <NEWLINE> <DEDENT> lim_a = len ( cum_a ) <NEWLINE> lim_b = len ( cum_b ) <NEWLINE> idx = 0 <NEWLINE> ans = lim_a <NEWLINE> for l in range ( 1 , lim_a + 1 ) : <NEWLINE> <INDENT> for idx in range ( lim_b ) : <NEWLINE> <INDENT> if k >= cum_a [ - l ] + cum [ idx ] : <NEWLINE> <INDENT> ans = max ( ans , lim_a - l + idx + 2 ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A = [ 0 ] + A <NEWLINE> B = [ 0 ] + B <NEWLINE> <NL> from itertools import accumulate <NEWLINE> <NL> AA = list ( accumulate ( A ) ) <NEWLINE> BB = list ( accumulate ( B ) ) <NEWLINE> a , b = 0 , 0 <NEWLINE> <NL> import bisect <NEWLINE> for i in range ( N + 1 ) : <NEWLINE> <INDENT> a = i <NEWLINE> b = bisect . bisect_right ( BB , K - AA [ i ] ) - 1 <NEWLINE> if b == - 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> count = max ( count , a + b ) <NEWLINE> <DEDENT> print ( count ) <NEWLINE>
def resolve ( ) : <NEWLINE> <INDENT> import numpy as np <NEWLINE> <NL> N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> A_cumsum = np . cumsum ( A ) <NEWLINE> B_cumsum = np . cumsum ( B ) <NEWLINE> <NL> ans = 0 <NEWLINE> j = M <NEWLINE> for i in range ( N + 1 ) : <NEWLINE> <INDENT> if A_cumsum [ i ] > K : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> while A_cumsum [ i ] + B_cumsum [ j ] > K : <NEWLINE> <INDENT> j -= 1 <NEWLINE> <NL> <DEDENT> ans = max ( ans , i + j ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> resolve ( ) <NEWLINE>
N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> a , b = [ 0 ] , [ 0 ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> a . append ( a [ i ] + A [ i ] ) <NEWLINE> <DEDENT> for i in range ( M ) : <NEWLINE> <INDENT> b . append ( a [ i ] + A [ i ] ) <NEWLINE> <NL> <DEDENT> ans , j = o , M <NEWLINE> <NL> for i in range ( N + 1 ) : <NEWLINE> <INDENT> if a [ i ] > K : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> while b [ j ] > K - a [ i ] : <NEWLINE> <INDENT> j -= 1 <NEWLINE> <DEDENT> ans = max ( ans , i + j ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( input ( ) . split ( ) ) <NEWLINE> B = list ( input ( ) . split ( ) ) <NEWLINE> <NL> a = 0 ; b = 0 <NEWLINE> cnt = 0 <NEWLINE> while a < len ( A ) and b < len ( B ) and K > 0 : <NEWLINE> <INDENT> a_ = A [ a ] <NEWLINE> b_ = B [ b ] <NEWLINE> <NL> if a_ > K and b_ > K : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> if a_ < b_ and a_ <= K : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> K -= a_ <NEWLINE> <INDENT> a += 1 <NEWLINE> <DEDENT> elif a_ >= b_ and b_ <= K : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> K -= b_ <NEWLINE> b += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
import itertools <NEWLINE> def main ( ) : <NEWLINE> <INDENT> n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> b = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> ia = n - 1 <NEWLINE> res = n <NEWLINE> ib = 0 <NEWLINE> time = sum ( a ) <NEWLINE> <NL> while ( ia >= 0 and ib < m ) : <NEWLINE> <NL> <INDENT> if ( time > k ) : <NEWLINE> <INDENT> time -= ( a [ ia ] ) <NEWLINE> res -= 1 <NEWLINE> ia -= 1 <NEWLINE> elif ( time + b [ ib ] <= k ) : <NEWLINE> time += ( b [ ib ] ) <NEWLINE> res += 1 <NEWLINE> ib += 1 <NEWLINE> else : <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( res ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
<NL> n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> x = [ 0 ] <NEWLINE> <NL> y = [ 0 ] <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> x . append ( x [ i ] + a [ i ] ) <NEWLINE> <NL> <DEDENT> for i in range ( m ) : <NEWLINE> <INDENT> y . append ( y [ i ] + b [ i ] ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> <NL> cnt = m <NEWLINE> <NL> for i in range ( n + 1 ) : <NEWLINE> <NL> <INDENT> if x [ i ] < 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> while y [ cnt ] > k - x [ i ] : <NEWLINE> <INDENT> cnt -= 1 <NEWLINE> <NL> <DEDENT> ans = max ( ans , cnt + i ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> a , b = [ 0 ] , [ 0 ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> a . append ( a [ i ] + A [ i ] ) <NEWLINE> <DEDENT> for i in range ( M ) : <NEWLINE> <INDENT> b . append ( b [ i ] + B [ i ] ) <NEWLINE> <NL> <DEDENT> ans , j = 0 , M <NEWLINE> for i in range ( N + 1 ) : <NEWLINE> <INDENT> if a [ i ] > K : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> while b [ j ] > K - a [ i ] : <NEWLINE> <INDENT> j -= 1 <NEWLINE> ans = max ( ans , i + j ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> <NL> readline = sys . stdin . readline <NEWLINE> readlines = sys . stdin . readlines <NEWLINE> ns = lambda : readline ( ) . rstrip ( ) <COMMENT> <NEWLINE> ni = lambda : int ( readline ( ) . rstrip ( ) ) <COMMENT> <NEWLINE> nm = lambda : map ( int , readline ( ) . split ( ) ) <COMMENT> <NEWLINE> nl = lambda : list ( map ( int , readline ( ) . split ( ) ) ) <COMMENT> <NEWLINE> <NL> n , m , k = nm ( ) <NEWLINE> a = nl ( ) <NEWLINE> b = nl ( ) <NEWLINE> ans = 0 <NEWLINE> sum_a = [ 0 ] * ( n + 1 ) <NEWLINE> sum_b = [ 0 ] * ( m + 1 ) <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> sum_a [ i ] = sum_a [ i - 1 ] + a [ i - 1 ] <NEWLINE> <DEDENT> for i in range ( 1 , m + 1 ) : <NEWLINE> <INDENT> sum_b [ i ] = sum_b [ i - 1 ] + b [ i - 1 ] <NEWLINE> <DEDENT> ans = 0 <NEWLINE> bef_j = m <NEWLINE> for i in range ( n + 1 ) : <NEWLINE> <INDENT> if sum_a [ i ] >= k : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for j in range ( m + 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> if sum_a [ i ] + sum_b [ j ] <= k : <NEWLINE> <INDENT> ans = max ( ans , i + j ) <NEWLINE> bef_j = j <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> a , b = [ 0 ] , [ 0 ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> a . append ( a [ i ] + A [ i ] <NEWLINE> <DEDENT> for i in range ( M ) : <NEWLINE> <INDENT> b . append ( b [ i ] + B [ i ] ) <NEWLINE> <NL> <DEDENT> ans , j = 0 , M <NEWLINE> for i in range ( N + 1 ) : <NEWLINE> <INDENT> if a [ i ] > K : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> while b [ j ] > K - a [ i ] : <NEWLINE> <INDENT> j -= 1 <NEWLINE> ans = max ( ans , i + j ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import bisect <NEWLINE> <NL> N , M , K = input ( ) . split ( ) <NEWLINE> <NL> desk1 = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> desk2 = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> max_time = int ( K ) <NEWLINE> item1 = [ 0 ] <NEWLINE> item2 = [ 0 ] <NEWLINE> for i in desk1 : <NEWLINE> <INDENT> item1 . append ( item1 [ - 1 ] + i ) <NEWLINE> <DEDENT> for i in desk2 : <NEWLINE> <INDENT> item2 . append ( item2 [ - 1 ] + i ) <NEWLINE> <NL> <DEDENT> ret = 0 <NEWLINE> for i , t in enumerate ( item1 ) : <NEWLINE> <INDENT> remain_time = max_time - t <NEWLINE> if remain_time > 0 : <NEWLINE> <INDENT> j = bisect . bisect ( item2 , remain_time ) - 1 <NEWLINE> if j < 0 : <NEWLINE> <INDENT> j = 0 <NEWLINE> <DEDENT> ret = max ( ret , i + j ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ret = max ( ret , i ) <NEWLINE> <DEDENT> <DEDENT> print ( ret ) import bisect <NEWLINE> <NL> N , M , K = input ( ) . split ( ) <NEWLINE> <NL> desk1 = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> desk2 = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> max_time = int ( K ) <NEWLINE> item1 = [ 0 ] <NEWLINE> item2 = [ 0 ] <NEWLINE> for i in desk1 : <NEWLINE> <INDENT> item1 . append ( item1 [ - 1 ] + i ) <NEWLINE> <DEDENT> for i in desk2 : <NEWLINE> <INDENT> item2 . append ( item2 [ - 1 ] + i ) <NEWLINE> <NL> <DEDENT> ret = 0 <NEWLINE> for i , t in enumerate ( item1 ) : <NEWLINE> <INDENT> remain_time = max_time - t <NEWLINE> if remain_time > 0 : <NEWLINE> <INDENT> j = bisect . bisect ( item2 , remain_time ) - 1 <NEWLINE> if j < 0 : <NEWLINE> <INDENT> j = 0 <NEWLINE> <DEDENT> ret = max ( ret , i + j ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ret = max ( ret , i ) <NEWLINE> <DEDENT> <DEDENT> print ( ret ) <NEWLINE>
N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> a , b = [ 0 ] , [ 0 ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> a . append ( a [ i ] + A [ i ] ) <NEWLINE> <DEDENT> for i in range ( M ) : <NEWLINE> <INDENT> b . append ( b [ i ] + B [ i ] ) <NEWLINE> <NL> <DEDENT> ans , j = 0 , M <NEWLINE> for i in range ( N + 1 ) : <NEWLINE> <INDENT> if a [ i ] > K : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> while b [ j ] > K - a [ i ] : <NEWLINE> <INDENT> j -= 1 <NEWLINE> ans = max ( ans , i + j ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> c = [ 0 ] <NEWLINE> d = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> d += a [ i ] <NEWLINE> c . append ( d ) <NEWLINE> <NL> <DEDENT> e = [ 0 ] <NEWLINE> f = 0 <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> f += b [ i ] <NEWLINE> e . append ( f ) <NEWLINE> <NL> <NL> <DEDENT> ans = 0 <NEWLINE> j = q - 1 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if c [ i ] > k : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> while c [ i ] + e [ j ] > k : <NEWLINE> <INDENT> j -= 1 <NEWLINE> <DEDENT> <DEDENT> ans = max ( i + j , ans ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
import numpy as np <NEWLINE> import scipy . sparse as sps <NEWLINE> import scipy . misc as spm <NEWLINE> import collections as col <NEWLINE> import functools as func <NEWLINE> import itertools as ite <NEWLINE> import fractions as frac <NEWLINE> import math as ma <NEWLINE> from math import cos , sin , tan , sqrt <NEWLINE> import cmath as cma <NEWLINE> import copy as cp <NEWLINE> import sys <NEWLINE> import re <NEWLINE> import bisect as bs <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> EPS = sys . float_info . epsilon <NEWLINE> PI = np . pi ; EXP = np . e ; INF = np . inf <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> <NL> def sinput ( ) : return sys . stdin . readline ( ) . strip ( ) <NEWLINE> def iinput ( ) : return int ( sinput ( ) ) <NEWLINE> def imap ( ) : return map ( int , sinput ( ) . split ( ) ) <NEWLINE> def fmap ( ) : return map ( float , sinput ( ) . split ( ) ) <NEWLINE> def iarr ( n = 0 ) : <NEWLINE> <INDENT> if n : return [ 0 for _ in range ( n ) ] <NEWLINE> else : return list ( imap ( ) ) <NEWLINE> <DEDENT> def farr ( ) : return list ( fmap ( ) ) <NEWLINE> def sarr ( n = 0 ) : <NEWLINE> <INDENT> if n : return [ <STRING> for _ in range ( n ) ] <NEWLINE> else : return sinput ( ) . split ( ) <NEWLINE> <DEDENT> def adj ( n ) : return [ [ ] for _ in range ( n ) ] <NEWLINE> <NL> def meguru ( ok , ng ) : <NEWLINE> <INDENT> while abs ( ok - ng ) > 1 : <NEWLINE> <INDENT> mid = ( ok + ng ) // 2 <NEWLINE> if isOK ( mid ) : ok = mid <NEWLINE> else : ng = mid <NEWLINE> <DEDENT> return ok <NEWLINE> <NL> <DEDENT> def isOK ( num ) : return bcum [ num ] <= tb <NEWLINE> <NL> n , m , k = imap ( ) <NEWLINE> a , b = iarr ( ) , iarr ( ) <NEWLINE> acum , bcum = np . array ( a ) . cumsum ( ) , np . array ( b ) . cumsum ( ) <NEWLINE> <NL> anss = [ ] <NEWLINE> for i in range ( n + 1 ) : <NEWLINE> <INDENT> ans = i + 1 <NEWLINE> ta = 0 if i == n + 1 else acum [ i ] <NEWLINE> if ta > k : continue <NEWLINE> else : tb = k - ta <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> ans += bs . bisect_right ( bcum , tb ) <NEWLINE> anss . append ( ans ) <NEWLINE> <DEDENT> ans = max ( anss ) if anss else 0 <NEWLINE> print ( ans ) <NEWLINE>
N , M , K = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> if ab_min > K : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> while True : <NEWLINE> <INDENT> K = K - min ( A [ 0 ] , B [ 0 ] ) <NEWLINE> if K < 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> ans += 1 <NEWLINE> if min ( A [ 0 ] , B [ 0 ] ) == A [ 0 ] : <NEWLINE> <INDENT> A . pop ( 0 ) <NEWLINE> if A == [ ] : <NEWLINE> <INDENT> A . append ( 10 ** 9 + 1 ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> B . pop ( 0 ) <NEWLINE> if B == [ ] : <NEWLINE> <INDENT> B . append ( 10 ** 9 + 1 ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> N , M , K = [ int ( s ) for s in input ( ) . split ( ) ] <NEWLINE> A = [ int ( s ) for s in input ( ) . split ( ) ] <NEWLINE> B = [ int ( s ) for s in input ( ) . split ( ) ] <NEWLINE> i = 0 <NEWLINE> j = M - 1 <NEWLINE> <NL> B_SUM = [ 0 ] * M <NEWLINE> B_SUM [ 0 ] = B [ 0 ] <NEWLINE> <NL> max_book = 0 <NEWLINE> <NL> for i in range ( 1 , M ) : <NEWLINE> <INDENT> B_SUM [ i ] = B [ i ] + B_SUM [ i - 1 ] <NEWLINE> if B_SUM [ i ] <= K : <NEWLINE> <INDENT> max_book = i + 1 <NEWLINE> <NL> <DEDENT> <DEDENT> A_SUM = 0 <NEWLINE> <NL> b_index = M - 1 <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> A_SUM += A [ i ] <NEWLINE> while ( b_index >= 0 ) : <NEWLINE> <INDENT> B_SUM [ b_index ] <NEWLINE> if A_SUM + B_SUM <= K : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> b_index -= 1 <NEWLINE> <DEDENT> max_book = max ( max_book , b_index + 1 + i + 1 ) <NEWLINE> <NL> <DEDENT> print ( max_book ) <NEWLINE>
N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a , b = [ 0 ] , [ 0 ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> a . append ( a [ i ] + A [ i ] ) <NEWLINE> <DEDENT> for i in range ( M ) : <NEWLINE> <INDENT> b . append ( b [ i ] + B [ i ] ) <NEWLINE> <DEDENT> ans , j = 0 , M <NEWLINE> for i in range ( N + 1 ) : <NEWLINE> <INDENT> if a [ i ] > K : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> while b [ j ] > K - a [ i ] : <NEWLINE> <INDENT> j -= 1 <NEWLINE> <DEDENT> ans = max ( ans , i + j ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL>
for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> A_ls [ i ] += A_ls [ i - 1 ] <NEWLINE> <DEDENT> for i in range ( 1 , M + 1 ) : <NEWLINE> <INDENT> B_ls [ i ] += B_ls [ i - 1 ] <NEWLINE> <NL> <DEDENT> b_cnt , rst = M , 0 <NEWLINE> for a_cnt in range ( N + 1 ) : <NEWLINE> <INDENT> if A_ls [ a_cnt ] > K : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> while A_ls [ a_cnt ] + B_ls [ b_cnt ] > K : <NEWLINE> <INDENT> b_cnt -= 1 <NEWLINE> <DEDENT> rst = max ( rst , a_cnt + b_cnt ) <NEWLINE> <DEDENT> print ( rst ) <NEWLINE>
N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> import numpy as np <NEWLINE> <NL> a = [ ] <NEWLINE> flag = True <NEWLINE> while flag : <NEWLINE> <INDENT> if A [ 0 ] >= K or B [ 0 ] >= K : <NEWLINE> <INDENT> flag = False <NEWLINE> <DEDENT> elif not A and not B : <NEWLINE> <INDENT> flag = False <NEWLINE> <DEDENT> elif not A : <NEWLINE> <INDENT> a . append ( B [ 0 ] ) <NEWLINE> B = B [ 1 : ] <NEWLINE> <DEDENT> elif not B : <NEWLINE> <INDENT> a . append ( A [ 0 ] ) <NEWLINE> A = A [ 1 : ] <NEWLINE> <DEDENT> elif A [ 0 ] <= B [ 0 ] : <NEWLINE> <INDENT> a . append ( A [ 0 ] ) <NEWLINE> A = A [ 1 : ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a . append ( B [ 0 ] ) <NEWLINE> B = B [ 1 : ] <NEWLINE> <NL> <DEDENT> <DEDENT> res = np . cumsum ( a ) <NEWLINE> r = list ( res ) <NEWLINE> <NL> cnt = 0 <NEWLINE> for i in r : <NEWLINE> <INDENT> if i <= K : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> count = 0 <NEWLINE> ar = [ 0 ] * ( N ) <NEWLINE> br = [ 0 ] * ( M ) <NEWLINE> <NL> ar [ 0 ] = A [ 0 ] <NEWLINE> for i , v in enumerate ( A ) : <NEWLINE> <INDENT> ar [ i + 1 ] = ar [ i ] + v <NEWLINE> <NL> <DEDENT> br [ 0 ] = B [ 0 ] <NEWLINE> for i , v in enumerate ( B ) : <NEWLINE> <INDENT> br [ i + 1 ] = br [ i ] + v <NEWLINE> <NL> <DEDENT> max_read = 0 <NEWLINE> j = M <NEWLINE> for i in range ( N + 1 ) : <NEWLINE> <INDENT> rest = K - ar [ i ] <NEWLINE> if rest <= 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> while br [ j ] > K - ar [ i ] : <NEWLINE> <INDENT> j -= 1 <NEWLINE> <NL> <DEDENT> max_read = max ( max_read , i + j ) <NEWLINE> <NL> <DEDENT> print ( max_read ) <NEWLINE>
<COMMENT> <NL> n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> an = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> bn = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> suma = [ 0 ] <NEWLINE> sumb = [ 0 ] <NEWLINE> a = 0 <NEWLINE> b = 0 <NEWLINE> for i in an : <NEWLINE> <INDENT> a += i <NEWLINE> suma . append ( a ) <NEWLINE> <DEDENT> for i in bn : <NEWLINE> <INDENT> b += i <NEWLINE> sumb . append ( b ) <NEWLINE> <NL> <DEDENT> res = [ 0 ] <NEWLINE> for j in range ( n + 1 ) : <NEWLINE> <INDENT> if k - suma [ j ] < 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for l in range ( m + 1 ) : <NEWLINE> <INDENT> if k - suma [ j ] - sumb [ l ] > 0 : <NEWLINE> res . append ( j + l ) <NEWLINE> <DEDENT> <DEDENT> print ( max ( res ) ) <NEWLINE>
N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> a , b = [ 0 ] , [ 0 ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> a . append ( a [ i ] + A [ i ] ) <NEWLINE> <DEDENT> for i in range ( M ) : <NEWLINE> <INDENT> b . append ( b [ i ] + B [ i ] ) <NEWLINE> <NL> <DEDENT> ans , j = 0 , M <NEWLINE> for i in range ( N + 1 ) : <NEWLINE> <INDENT> a [ i ] > K : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> while b [ j ] > K - a [ i ] : <NEWLINE> <INDENT> j -= 1 <NEWLINE> <DEDENT> ans = max ( ans , i + j ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> from itertools import accumulate <NEWLINE> <NL> N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = [ 0 ] + list ( accumulate ( A ) ) <NEWLINE> b = [ 0 ] + list ( accumulate ( B ) ) <NEWLINE> ans , j = 0 , M <NEWLINE> for i in range ( N + 1 ) : <NEWLINE> <INDENT> if i > K : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> while b [ j ] > K - a [ i ] : <NEWLINE> <INDENT> j -= 1 <NEWLINE> <DEDENT> ans = max ( ans , i + j ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c = 0 <NEWLINE> import numpy as np <NEWLINE> A = np . array ( A ) . cumsum ( ) <NEWLINE> B = np . array ( B ) . cumsum ( ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> d = K - A [ i ] <NEWLINE> if d >= 0 : <NEWLINE> <INDENT> for j in reversed ( range ( M ) ) : <NEWLINE> <INDENT> if d >= B [ j ] : <NEWLINE> <INDENT> if c < i + j + 2 : <NEWLINE> <INDENT> c = i + j + 2 <NEWLINE> <DEDENT> M = j + 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if d < B [ 0 ] : <NEWLINE> <INDENT> c = i + 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for j in reverse ( range ( M ) ) : <NEWLINE> <INDENT> if K - B [ j ] >= 0 : <NEWLINE> <INDENT> if c < j + 1 : <NEWLINE> <INDENT> c = j + 1 <NEWLINE> <DEDENT> break <NEWLINE> <DEDENT> <DEDENT> break <NEWLINE> <DEDENT> <DEDENT> print ( c ) <NEWLINE>
from collections import deque <NEWLINE> <NL> N , M , K = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> consumptions_A = [ 0 ] <NEWLINE> for Ai in A : <NEWLINE> <INDENT> consumptions_A . append ( consumptions_A + Ai ) <NEWLINE> <NL> <DEDENT> consumptions_B = [ ] <NEWLINE> for Bi in B : <NEWLINE> <INDENT> consumptions_B . append ( consumptions_B + Bi ) <NEWLINE> <NL> <DEDENT> answer = 0 <NEWLINE> j = M <NEWLINE> for i in range ( len ( consumptions_A ) ) : <NEWLINE> <INDENT> if ( consumptions_A [ i ] > K ) : break <NEWLINE> <NL> remaining_time = K - consumptions_A [ i ] <NEWLINE> while consumptions_B [ j ] > remaining_time : <NEWLINE> <INDENT> j -= 1 <NEWLINE> <NL> <DEDENT> num_books = i + j <NEWLINE> answer = max ( answer , num_books ) <NEWLINE> <NL> <DEDENT> print ( answer ) <NEWLINE>
N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a , b = [ 0 ] , [ 0 ] <NEWLINE> for i in range ( N ) : <NEWLINE> a . append ( a [ i ] + A [ i ] ) <NEWLINE> for i in range ( M ) : <NEWLINE> b . append ( b [ i ] + B [ i ] ) <NEWLINE> ans , j = 0 , M <NEWLINE> for i in range ( N + 1 ) : <NEWLINE> if a [ i ] > K : <NEWLINE> break <NEWLINE> while b [ j ] > K - a [ i ] : <NEWLINE> j -= 1 <NEWLINE> ans = max ( ans , i + j ) <NEWLINE> print ( ans ) <NEWLINE>
n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input . split ( ) ) ) <NEWLINE> <NL> a , b = [ 0 ] , [ 0 ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a . append ( a [ i ] + A [ i ] ) <NEWLINE> <DEDENT> for j in range ( m ) : <NEWLINE> <INDENT> b . append ( b [ i ] + B [ i ] ) <NEWLINE> <NL> <DEDENT> ans , j = 0 , m <NEWLINE> for i in range ( n + 1 ) : <NEWLINE> <INDENT> if a [ i ] > k : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> while b [ j ] > k - a [ i ] : <NEWLINE> <INDENT> j -= 1 <NEWLINE> <DEDENT> ans = max ( ans , i + j ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> from sys import stdin <NEWLINE> <NL> <COMMENT> <NL> from itertools import accumulate <NEWLINE> from bisect import bisect_right <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> def _li ( ) : <NEWLINE> <INDENT> return list ( map ( int , stdin . readline ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> <DEDENT> def _li_ ( ) : <NEWLINE> <INDENT> return list ( map ( lambda x : int ( x ) - 1 , stdin . readline ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> <DEDENT> def _lf ( ) : <NEWLINE> <INDENT> return list ( map ( float , stdin . readline ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> <DEDENT> def _ls ( ) : <NEWLINE> <INDENT> return stdin . readline ( ) . split ( ) <NEWLINE> <NL> <NL> <DEDENT> def _i ( ) : <NEWLINE> <INDENT> return int ( stdin . readline ( ) ) <NEWLINE> <NL> <NL> <DEDENT> def _f ( ) : <NEWLINE> <INDENT> return float ( stdin . readline ( ) ) <NEWLINE> <NL> <NL> <DEDENT> def _s ( ) : <NEWLINE> <INDENT> return stdin . readline ( ) [ : - 1 ] <NEWLINE> <NL> <NL> <DEDENT> def search ( cum1 , cum2 , iter_max , limit ) : <NEWLINE> <INDENT> ans = 0 <NEWLINE> for i in range ( iter_max ) : <NEWLINE> <INDENT> if cum1 [ i ] > limit : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> cand = bisect_right ( cum2 , limit - cum1 [ i ] ) <NEWLINE> ans = max ( i + 1 + cand , ans ) <NEWLINE> <DEDENT> return ans <NEWLINE> <NL> <NL> <DEDENT> N , M , K = _li ( ) <NEWLINE> A_list = _li ( ) <NEWLINE> B_list = _li ( ) <NEWLINE> <NL> cum_a = list ( accumulate ( A_list ) ) <NEWLINE> cum_b = list ( accumulate ( B_list ) ) <NEWLINE> <NL> if cum_a [ 0 ] < cum_b [ 0 ] : <NEWLINE> <INDENT> print ( search ( cum_a , cum_b , N ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( search ( cum_b , cum_a , M ) ) <NEWLINE> <DEDENT>
n , m , K = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <COMMENT> <NL> sa = [ 0 ] <NEWLINE> sb = [ 0 ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> sa . append ( sa [ i ] + a [ i ] ) <NEWLINE> <DEDENT> for i in range ( m ) : <NEWLINE> <INDENT> sb . append ( sb [ i ] + b [ i ] ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> ans = 0 <NEWLINE> for i in range ( n + 1 ) : <NEWLINE> <INDENT> if a [ i ] > k : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> while b [ m ] > k - a [ i ] : <NEWLINE> <INDENT> m -= 1 <NEWLINE> <DEDENT> ans = max ( ans , i + m ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
from bisect import bisect_right <NEWLINE> from numpy import cumsum <NEWLINE> from sys import stdin <NEWLINE> input = stdin . readline <NEWLINE> n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = numpy . cumsum ( a ) <NEWLINE> b = numpy . cumsum ( b ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( len ( a ) ) : <NEWLINE> <INDENT> x = k - a [ i ] <NEWLINE> y = bisect . bisect_right ( b , x ) <NEWLINE> if ans < y + i + 1 : <NEWLINE> <INDENT> ans = y + i + 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a_sum , b_sum = [ 0 ] , [ 0 ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a_sum . append ( a_sum [ i ] + a [ i ] ) <NEWLINE> <DEDENT> for i in range ( m ) : <NEWLINE> <INDENT> b_sum . append ( b_sum [ i ] + b [ i ] ) <NEWLINE> <DEDENT> ans , j = 0 , m <NEWLINE> for i in range ( n + 1 ) : <NEWLINE> <INDENT> if a_sum [ i ] > k : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> while b_sum [ j ] > k - a_sum [ i ] : <NEWLINE> <INDENT> j = - 1 <NEWLINE> <DEDENT> ans = max ( ans , i + j ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ea = [ 0 ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ea . append ( ea [ i ] + a [ i ] ) <NEWLINE> <DEDENT> eb = [ 0 ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> eb . append ( eb [ i ] + b [ i ] ) <NEWLINE> <DEDENT> tb = m <NEWLINE> p = 0 <NEWLINE> if n < m : <NEWLINE> <INDENT> ea , eb = eb , ea <NEWLINE> n , m = m , n <NEWLINE> <DEDENT> for i in range ( n + 1 ) : <NEWLINE> <INDENT> while ea [ i ] + eb [ tb ] > k : <NEWLINE> <INDENT> if tb == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> tb -= 1 <NEWLINE> <DEDENT> if ea [ i ] + eb [ tb ] <= k : <NEWLINE> <INDENT> p = max ( i + tb , p ) <NEWLINE> <DEDENT> <DEDENT> print ( p ) <NEWLINE>
n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> A = [ 0 ] , B = [ 0 ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> A . append ( A [ i ] + a [ i ] ) <NEWLINE> <DEDENT> for i in range ( m ) : <NEWLINE> <INDENT> B . append ( B [ i ] + b [ i ] ) <NEWLINE> <NL> <DEDENT> ans , j = 0 , m <NEWLINE> for i in range ( n + 1 ) : <NEWLINE> <INDENT> if A [ i ] > k : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> while B [ j ] > k - A [ i ] : <NEWLINE> <INDENT> j -= 1 <NEWLINE> <DEDENT> ans = max ( ans , i + j ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> l = [ 0 for i in range ( n + 1 ) ] <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <NL> <INDENT> for j in range ( i , n + 1 , i ) : <NEWLINE> <NL> <INDENT> l [ j ] += 1 <NEWLINE> <DEDENT> <DEDENT> c = 0 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> c += i * l [ i ] <NEWLINE> <NL> <DEDENT> print ( c ) <NEWLINE>
<COMMENT> <NL> import sys <NEWLINE> from itertools import accumulate <NEWLINE> import numba <NEWLINE> import numpy as np <NEWLINE> <NL> <NL> def debug ( * x ) : <NEWLINE> <INDENT> print ( * x ) <NEWLINE> <NL> <NL> <DEDENT> @ numba . njit <NEWLINE> def solve ( N , M , K , sA , sB ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> <NL> last_can_read = 0 <NEWLINE> for i in range ( N + 1 ) : <NEWLINE> <INDENT> for j in range ( M + 1 ) : <NEWLINE> <INDENT> if sA [ i ] + sB [ j ] <= K : <NEWLINE> <INDENT> if last_can_read < i + j : <NEWLINE> <INDENT> last_can_read = i + j <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( last_can_read ) <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> AS = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> BS = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> sA = np . array ( [ 0 ] + list ( accumulate ( AS ) ) ) <NEWLINE> sB = np . array ( [ 0 ] + list ( accumulate ( BS ) ) ) <NEWLINE> <COMMENT> <NL> solve ( N , M , K , sA , sB ) <NEWLINE> <NL> <NL> <DEDENT> def _test ( ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> import doctest <NEWLINE> as_input ( <STRING> ) <NEWLINE> main ( ) <NEWLINE> doctest . testmod ( ) <NEWLINE> <NL> <NL> <DEDENT> def as_input ( s ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> import io <NEWLINE> global read , input <NEWLINE> f = io . StringIO ( s . strip ( ) ) <NEWLINE> input = f . readline <NEWLINE> read = f . read <NEWLINE> <NL> <NL> <DEDENT> USE_NUMBA = False <NEWLINE> if ( USE_NUMBA and sys . argv [ - 1 ] == <STRING> ) or sys . argv [ - 1 ] == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> from numba . pycc import CC <NEWLINE> cc = CC ( <STRING> ) <NEWLINE> cc . export ( <STRING> , solve . __doc__ . strip ( ) . split ( ) [ 0 ] ) ( solve ) <NEWLINE> cc . compile ( ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> input = sys . stdin . buffer . readline <NEWLINE> read = sys . stdin . buffer . read <NEWLINE> <NL> if ( USE_NUMBA and sys . argv [ - 1 ] != <STRING> ) or sys . argv [ - 1 ] == <STRING> : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <INDENT> from my_module import solve <COMMENT> <NEWLINE> <DEDENT> elif sys . argv [ - 1 ] == <STRING> : <NEWLINE> <INDENT> _test ( ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> elif sys . argv [ - 1 ] != <STRING> and len ( sys . argv ) == 2 : <NEWLINE> <COMMENT> <NL> <INDENT> input_as_file = open ( sys . argv [ 1 ] ) <NEWLINE> input = input_as_file . buffer . readline <NEWLINE> read = input_as_file . buffer . read <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE> <DEDENT>
from fractions import gcd <NEWLINE> from collections import Counter , deque , defaultdict <NEWLINE> from heapq import heappush , heappop , heappushpop , heapify , heapreplace , merge <NEWLINE> from bisect import bisect_left , bisect_right , bisect , insort_left , insort_right , insort <NEWLINE> from itertools import accumulate , product , permutations , combinations <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = deque ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> B = deque ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> time = 0 <NEWLINE> res = 0 <NEWLINE> same_flag = False <NEWLINE> <NL> while True : <NEWLINE> <INDENT> if len ( A ) != 0 : <NEWLINE> <INDENT> tmp1 = A [ 0 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> tmp1 = 10 ** 10 <NEWLINE> <NL> <DEDENT> if len ( B ) != 0 : <NEWLINE> <INDENT> tmp2 = B [ 0 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> tmp2 = 10 ** 10 <NEWLINE> <NL> <DEDENT> if time + tmp1 > K and time + tmp2 > K : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> if tmp1 == 10 ** 10 and tmp2 == 10 ** 10 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> elif tmp1 < tmp2 : <NEWLINE> <INDENT> tmp_time = A . popleft ( ) <NEWLINE> time += tmp_time <NEWLINE> res += 1 <NEWLINE> <DEDENT> elif tmp1 == tmp2 : <NEWLINE> <INDENT> sumA = sum ( A [ 1 : ] ) <NEWLINE> sumB = sum ( B [ 1 : ] ) <NEWLINE> <NL> if same_flag : <NEWLINE> <INDENT> tmp_time = A . popleft ( ) <NEWLINE> time += tmp_time <NEWLINE> res += 1 <NEWLINE> <DEDENT> elif sumA < sumB : <NEWLINE> <INDENT> tmp_time = A . popleft ( ) <NEWLINE> time += tmp_time <NEWLINE> res += 1 <NEWLINE> <DEDENT> elif sumA > sumB : <NEWLINE> <INDENT> tmp_time = B . popleft ( ) <NEWLINE> time += tmp_time <NEWLINE> res += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> tmp_time = A . popleft ( ) <NEWLINE> time += tmp_time <NEWLINE> res += 1 <NEWLINE> same_flag = True <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> tmp_time = B . popleft ( ) <NEWLINE> time += tmp_time <NEWLINE> res += 1 <NEWLINE> <NL> <DEDENT> if time > K : <NEWLINE> <INDENT> time -= tmp_time <NEWLINE> res -= 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( res ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
from itertools import accumulate <NEWLINE> from bisect import bisect <NEWLINE> <NL> n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ * accumulate ( map ( int , input ( ) . split ( ) ) , initial = 0 ) ] <NEWLINE> b = [ * accumulate ( map ( int , input ( ) . split ( ) ) , initial = 0 ) ] <NEWLINE> ans = 0 <NEWLINE> for i , x in enumerate ( a ) : <NEWLINE> <INDENT> if x <= k : <NEWLINE> <INDENT> ans = max ( i - 1 + bisect ( b , k - x ) ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> sa = [ 0 ] <NEWLINE> sb = [ 0 ] <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> sa . append ( sa [ i ] + a [ i ] ) <NEWLINE> <NL> <DEDENT> for i in range ( m ) : <NEWLINE> <INDENT> sb . append ( sb [ i ] + b [ i ] ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> j = m <NEWLINE> <NL> <COMMENT> <NL> for i in in range ( n + 1 ) : <NEWLINE> <INDENT> if sa [ i ] > k : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> while sa [ i ] + sb [ j ] > k : <NEWLINE> <INDENT> j -= 1 <NEWLINE> <DEDENT> ans = max ( ans , i + j ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = deque ( [ int ( a ) for a in input ( ) . split ( ) ] ) <NEWLINE> B = deque ( [ int ( b ) for b in input ( ) . split ( ) ] ) <NEWLINE> Bsum = sum ( B ) <NEWLINE> ans = Asum = 0 <NEWLINE> idx_b = len ( B ) - 1 <NEWLINE> <NL> A . appendleft ( 0 ) <NEWLINE> <NL> for i in range ( len ( A ) ) : <NEWLINE> <INDENT> Asum += A [ i ] <NEWLINE> <NL> for j in range ( idx_b + 1 ) : <NEWLINE> <INDENT> if Asum + Bsum > K : <NEWLINE> <INDENT> if idx_b >= 0 : <NEWLINE> <INDENT> Bsum -= B [ idx_b ] <NEWLINE> idx_b -= 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> if Asum + Bsum <= K : <NEWLINE> <INDENT> ans = max ( ans , i + ( idx_b + 1 ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
5 4 1 <NEWLINE> 1000000000 1000000000 1000000000 1000000000 1000000000 <NEWLINE> 1000000000 1000000000 1000000000 1000000000 <NEWLINE>
N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> a , b = [ 0 ] , [ 0 ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> a . append ( a [ i ] + A [ i ] ) <NEWLINE> <DEDENT> for i in range ( M ) : <NEWLINE> <INDENT> b . append ( b [ i ] + B [ i ] ) <NEWLINE> <NL> <DEDENT> ans , j = 0 , M <NEWLINE> for i in range ( N + 1 ) : <NEWLINE> <INDENT> if a [ i ] > K : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> while b [ j ] > k - a [ i ] : <NEWLINE> <INDENT> j -= 1 <NEWLINE> <DEDENT> ans = max ( ans , i + j ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> while k > 0 : <NEWLINE> <INDENT> i , j = 0 <NEWLINE> if a [ i ] <= b [ j ] : <NEWLINE> <INDENT> k -= a [ i ] <NEWLINE> if k >= 0 <NEWLINE> <INDENT> i += 1 <NEWLINE> ans += 1 <NEWLINE> if i >= n : <NEWLINE> <INDENT> for o in range ( j , m ) : <NEWLINE> <INDENT> if k >= b [ o ] : <NEWLINE> <INDENT> k -= b [ o ] <NEWLINE> ans += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> k -= b [ o ] <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> k -= b [ j ] <NEWLINE> if k >= 0 <NEWLINE> <INDENT> j += 1 <NEWLINE> ans += 1 <NEWLINE> if j >= m : <NEWLINE> <INDENT> for p in range ( i , n ) : <NEWLINE> <INDENT> if k >= a [ p ] : <NEWLINE> <INDENT> k -= a [ p ] <NEWLINE> ans += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> k -= a [ p ] <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> a_pre , b_pre = [ 0 ] , [ 0 ] <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> a_pre . append ( a_pre [ i ] + a [ i ] ) <NEWLINE> <NL> <DEDENT> for i in range ( m ) : <NEWLINE> <INDENT> b_pre . append ( b_pre [ i ] + b [ i ] ) <NEWLINE> <NL> <DEDENT> ans , j = 0 , m <NEWLINE> for i in range ( n + 1 ) : <NEWLINE> <INDENT> if a_pre [ i ] > k : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> while b [ j ] > k - a [ i ] : <NEWLINE> <INDENT> j -= 1 <NEWLINE> <NL> <DEDENT> ans = max ( ans , i + j ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> import itertools <NEWLINE> n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> j = m <NEWLINE> <NL> aa = [ 0 ] + list ( itertools . accumulate ( a ) ) <NEWLINE> bb = [ 0 ] + list ( itertools . accumulate ( b ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> <COMMENT> <NL> for i , a_item in enumerate ( a ) : <NEWLINE> <INDENT> if a_item > k : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> while a_item + b [ j ] > k : <NEWLINE> <INDENT> j -= 1 <NEWLINE> <DEDENT> ans = max ( i + j , ans ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> import math <NEWLINE> import sys <NEWLINE> <NL> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> <NL> <NL> def binary_research ( start , end , function ) : <NEWLINE> <INDENT> if start == end : <NEWLINE> <INDENT> return start <NEWLINE> <DEDENT> middle = math . ceil ( ( start + end ) / 2 ) <NEWLINE> if function ( middle , k , a_sum , b_sum ) : <NEWLINE> <INDENT> start = middle <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> end = middle - 1 <NEWLINE> <DEDENT> return binary_research ( start , end , function ) <NEWLINE> <NL> <NL> <COMMENT> <NL> <NL> <DEDENT> n , m , k = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> a = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> b = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> a_sum = [ 0 ] <NEWLINE> b_sum = [ 0 ] <NEWLINE> for book in a : <NEWLINE> <INDENT> a_sum . append ( a_sum [ - 1 ] + book ) <NEWLINE> <DEDENT> for book in b : <NEWLINE> <INDENT> b_sum . append ( b_sum [ - 1 ] + book ) <NEWLINE> <NL> <NL> <DEDENT> def can_read ( num , k , a_sum , b_sum ) : <NEWLINE> <INDENT> min_read_time = 1000000000000 <NEWLINE> sentou = <NEWLINE> for i in range ( max ( 0 , num - m ) , min ( num + 1 , n + 1 ) ) : <NEWLINE> <INDENT> a_num = i <NEWLINE> b_num = num - i <NEWLINE> min_read_time = min ( min_read_time , a_sum [ a_num ] + b_sum [ b_num ] ) <NEWLINE> <DEDENT> if min_read_time <= k : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> return False <NEWLINE> <NL> <NL> <DEDENT> start = 0 <NEWLINE> end = n + m <NEWLINE> <NL> print ( binary_research ( start , end , can_read ) ) <NEWLINE>
a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> la = [ 0 ] <NEWLINE> lb = [ 0 ] <NEWLINE> mx = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> la . append ( la [ i ] + a [ i ] ) <NEWLINE> <DEDENT> for j in range ( m ) : <NEWLINE> <INDENT> lb . append ( lb [ j ] + b [ j ] ) <NEWLINE> <DEDENT> for l in range ( len ( la ) ) : <NEWLINE> <INDENT> if la [ l ] > k : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> cnt = l <NEWLINE> q = 0 <NEWLINE> p = 0 <NEWLINE> while la [ l ] + p <= k : <NEWLINE> <INDENT> q += 1 <NEWLINE> if q == len ( lb ) : <NEWLINE> <INDENT> cnt += len ( lb ) - 1 <NEWLINE> break <NEWLINE> <DEDENT> p = lb [ q ] <NEWLINE> <DEDENT> if cnt == l : <NEWLINE> <INDENT> cnt += q - 1 <NEWLINE> <DEDENT> if cnt > mx : <NEWLINE> <INDENT> mx = cnt <NEWLINE> <DEDENT> <DEDENT> print ( mx ) <NEWLINE>
from collections import deque <NEWLINE> <NL> N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = deque ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> B = deque ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> if sum ( A ) + sum ( B ) < K : <NEWLINE> <INDENT> print ( N + M ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> <NL> while K > 0 : <NEWLINE> <INDENT> if len ( A ) != 0 : <NEWLINE> <COMMENT> <NL> <INDENT> if len ( B ) == 0 or sum ( A ) <= sum ( B ) : <NEWLINE> <INDENT> if A [ 0 ] <= K : <NEWLINE> <INDENT> K -= A . popleft ( ) <NEWLINE> ans += 1 <NEWLINE> continue <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if len ( B ) != 0 : <NEWLINE> <COMMENT> <NL> <INDENT> if len ( A ) == 0 or sum ( A ) >= sum ( B ) : <NEWLINE> <INDENT> if B [ 0 ] <= K : <NEWLINE> <INDENT> K -= B . popleft ( ) <NEWLINE> ans += 1 <NEWLINE> continue <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> a , b = [ 0 ] , [ 0 ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> a . append ( a [ i ] + A [ i ] ) <NEWLINE> <NL> <DEDENT> for i in range ( M ) : <NEWLINE> <INDENT> b . append ( b [ i ] + B [ i ] ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> ans = 0 <NEWLINE> j = M <NEWLINE> <NL> for i in range ( N + 1 ) : <NEWLINE> <INDENT> if a [ i ] > k : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> while b [ j ] + a [ i ] > K : <NEWLINE> <INDENT> j -= 1 <NEWLINE> <DEDENT> ans = max ( ans , i + j ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE> <NL>
import sys <NEWLINE> import numpy as np <NEWLINE> import math <NEWLINE> import collections <NEWLINE> from collections import deque <NEWLINE> from functools import reduce <NEWLINE> <NL> <COMMENT> <NL> n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a_t , b_t = [ 0 ] , [ 0 ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a_t . append ( a_t [ i ] + a [ i ] ) <NEWLINE> <DEDENT> for i in range ( m ) : <NEWLINE> <INDENT> b_t . append ( b_t [ i ] + b [ i ] ) <NEWLINE> <DEDENT> ans = 0 <NEWLINE> j = m <NEWLINE> for i in range ( n + 1 ) : <NEWLINE> <INDENT> if ( a [ i ] > k ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> while ( a_t [ i ] + b_t [ j ] > k ) : <NEWLINE> <INDENT> j -= 1 <NEWLINE> <DEDENT> ans = max ( ans , i + j ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL>
<NL> a = [ 0 ] <NEWLINE> b = [ 0 ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a . append ( a [ i ] + A [ i ] ) <NEWLINE> <DEDENT> for j in range ( m ) : <NEWLINE> <INDENT> b . append ( b [ j ] + B [ j ] ) <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> ans = 0 <NEWLINE> j = m <NEWLINE> for i in range ( n + 1 ) : <NEWLINE> <INDENT> if a [ i ] > k : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> while ( k - a [ i ] ) < b [ j ] : <NEWLINE> <INDENT> j -= 1 <NEWLINE> if j == - 1 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> ans = max ( ans , i + j ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A , B = [ 0 ] , [ 0 ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> A . append ( A [ i ] + a [ i ] ) <NEWLINE> <DEDENT> for i in range ( m ) : <NEWLINE> <INDENT> B . append ( B [ i ] + b [ i ] ) <NEWLINE> <DEDENT> ans , j = 0 , m <NEWLINE> for i in range ( n + 1 ) : <NEWLINE> <INDENT> if a [ i ] > k : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> while b [ j ] > k - a [ i ] : <NEWLINE> <INDENT> j -= 1 <NEWLINE> <DEDENT> ans = max ( ans , i + j ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a_list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b_list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> from itertools import accumulate <NEWLINE> sum_a_list = list ( accumulate ( [ 0 ] + a_list ) ) <NEWLINE> sum_b_list = list ( accumulate ( [ 0 ] + b_list ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> b_idx = 0 <NEWLINE> for a_idx in range ( n + 1 ) : <NEWLINE> <INDENT> if sum_a_list [ a_idx ] > k : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <DEDENT> time_rest = k - sum_a_list [ a_idx ] <NEWLINE> b_idx = bisect . bisect_left ( sum_b_list , time_rest ) <NEWLINE> <NL> ans = max ( ans , a_idx + b_idx ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
N , M , K = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> As = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> Bs = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> cnt = 0 <NEWLINE> time = 0 <NEWLINE> while time <= K : <NEWLINE> <INDENT> if As and Bs : <NEWLINE> <INDENT> if As [ 0 ] > Bs [ 0 ] : <NEWLINE> <INDENT> p = Bs . pop ( 0 ) <NEWLINE> <DEDENT> elif Bs [ 0 ] >= As [ 0 ] : <NEWLINE> <INDENT> p = As . pop ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if As : <NEWLINE> <INDENT> p = As . pop ( 0 ) <NEWLINE> <DEDENT> elif Bs : <NEWLINE> <INDENT> p = Bs . pop ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> time += p <NEWLINE> if time > K : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> cnt += 1 <NEWLINE> <NL> <DEDENT> print ( cnt ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> from queue import Queue <NEWLINE> from queue import LifoQueue as Stack <NEWLINE> from math import sqrt , floor , ceil , log2 , log10 , pi <NEWLINE> from fractions import gcd <NEWLINE> from itertools import permutations , combinations <NEWLINE> from operator import itemgetter <NEWLINE> from functools import cmp_to_key <NEWLINE> <NL> <NL> INF = 1001001001 <NEWLINE> __MOD__ = ( 10 ** 9 ) + 7 <NEWLINE> yn = <STRING> <NEWLINE> judge = False <NEWLINE> cnt = 0 <NEWLINE> ans = None <NEWLINE> <NL> <NL> def lcm ( a , b ) : <NEWLINE> <INDENT> return ( a * b ) // gcd ( a , b ) <NEWLINE> <NL> <DEDENT> def intinput ( ) : <NEWLINE> <INDENT> return int ( input ( ) ) <NEWLINE> <NL> <DEDENT> def mulinputs ( ) : <NEWLINE> <INDENT> return map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <DEDENT> def lineinputs ( func = intinput ) : <NEWLINE> <INDENT> datas = [ ] <NEWLINE> while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> datas . append ( func ( ) ) <NEWLINE> <DEDENT> except EOFError : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> return datas <NEWLINE> <NL> <DEDENT> class ModInt ( ) : <NEWLINE> <INDENT> def __init__ ( self , x ) : <NEWLINE> <INDENT> self . __x = ( x % __MOD__ ) <NEWLINE> <DEDENT> def __add__ ( self , other ) : <NEWLINE> <INDENT> if type ( other ) == int : <NEWLINE> <INDENT> other = self . __class__ ( other ) <NEWLINE> return int ( self . __class__ ( ( self . __x + other . __x ) % __MOD__ ) ) <NEWLINE> <DEDENT> elif type ( other ) == ModInt : <NEWLINE> <INDENT> return self . __class__ ( ( self . __x + other . __x ) % __MOD__ ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> raise Exception ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> def __radd__ ( self , other ) : <NEWLINE> <INDENT> if type ( other ) == int : <NEWLINE> <INDENT> other = self . __class__ ( other ) <NEWLINE> return int ( self . __class__ ( ( other . __x + self . __x ) % __MOD__ ) ) <NEWLINE> <DEDENT> elif type ( other ) == ModInt : <NEWLINE> <INDENT> return self . __class__ ( ( other . __x + self . __x ) % __MOD__ ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> raise Exception ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> def __sub__ ( self , other ) : <NEWLINE> <INDENT> if type ( other ) == int : <NEWLINE> <INDENT> other = self . __class__ ( other ) <NEWLINE> return int ( self . __class__ ( ( self . __x - other . __x ) % __MOD__ ) ) <NEWLINE> <DEDENT> elif type ( other ) == ModInt : <NEWLINE> <INDENT> return self . __class__ ( ( self . __x - other . __x ) % __MOD__ ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> raise Exception ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> def __rsub__ ( self , other ) : <NEWLINE> <INDENT> if type ( other ) == int : <NEWLINE> <INDENT> other = self . __class__ ( other ) <NEWLINE> return int ( self . __class__ ( ( other . __x - self . __x ) % __MOD__ ) ) <NEWLINE> <DEDENT> elif type ( other ) == ModInt : <NEWLINE> <INDENT> return self . __class__ ( ( other . __x - self . __x ) % __MOD__ ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> raise Exception ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> def __mul__ ( self , other ) : <NEWLINE> <INDENT> if type ( other ) == int : <NEWLINE> <INDENT> other = self . __class__ ( other ) <NEWLINE> return int ( self . __class__ ( ( self . __x * other . __x ) % __MOD__ ) ) <NEWLINE> <DEDENT> elif type ( other ) == ModInt : <NEWLINE> <INDENT> return self . __class__ ( ( self . __x * other . __x ) % __MOD__ ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> raise Exception ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> def __rmul__ ( self , other ) : <NEWLINE> <INDENT> if type ( other ) == int : <NEWLINE> <INDENT> other = self . __class__ ( other ) <NEWLINE> return int ( self . __class__ ( ( other . __x * self . __x ) % __MOD__ ) ) <NEWLINE> <DEDENT> elif type ( other ) == ModInt : <NEWLINE> <INDENT> return self . __class__ ( ( other . __x * self . __x ) % __MOD__ ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> raise Exception ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> def __truediv__ ( self , other ) : <NEWLINE> <INDENT> if type ( other ) == int : <NEWLINE> <INDENT> other = self . __class__ ( other ) <NEWLINE> return int ( self . __class__ ( ( self . __x * other . __modinv ( ) ) % __MOD__ ) ) <NEWLINE> <DEDENT> elif type ( other ) == ModInt : <NEWLINE> <INDENT> return self . __class__ ( ( self . __x * other . __modinv ( ) ) % __MOD__ ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> raise Exception ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> def __rtruediv__ ( self , other ) : <NEWLINE> <INDENT> if type ( other ) == int : <NEWLINE> <INDENT> other = self . __class__ ( other ) <NEWLINE> return int ( self . __class__ ( ( other . __x * self . __modinv ( ) ) % __MOD__ ) ) <NEWLINE> <DEDENT> elif type ( other ) == ModInt : <NEWLINE> <INDENT> return self . __class__ ( ( other . __x * self . __modinv ( ) ) % __MOD__ ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> raise Exception ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> def __pow__ ( self , other ) : <NEWLINE> <INDENT> if type ( other ) == int : <NEWLINE> <INDENT> other = self . __class__ ( other ) <NEWLINE> return int ( self . __class__ ( pow ( self . __x , other . __x , __MOD__ ) ) ) <NEWLINE> <DEDENT> elif type ( other ) == ModInt : <NEWLINE> <INDENT> return self . __class__ ( pow ( self . __x , other . __x , __MOD__ ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> raise Exception ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> def __rpow__ ( self , other ) : <NEWLINE> <INDENT> if type ( other ) == int : <NEWLINE> <INDENT> other = self . __class__ ( other ) <NEWLINE> return int ( self . __class__ ( pow ( other . __x , self . __x , __MOD__ ) ) ) <NEWLINE> <DEDENT> elif type ( other ) == ModInt : <NEWLINE> <INDENT> return self . __class__ ( pow ( other . __x , self . __x , __MOD__ ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> raise Exception ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> def __modinv ( self , m = __MOD__ ) : <NEWLINE> <INDENT> a = self . __x <NEWLINE> if a == 0 : <NEWLINE> <INDENT> raise ZeroDivisionError ( ) <NEWLINE> <DEDENT> if gcd ( a , m ) != 1 : <NEWLINE> <INDENT> raise Exception ( <STRING> % a ) <NEWLINE> <DEDENT> b , u , v = m , 1 , 0 <NEWLINE> while b != 0 : <NEWLINE> <INDENT> t = a // b ; <NEWLINE> a -= t * b <NEWLINE> a , b = b , a <NEWLINE> u -= t * v <NEWLINE> u , v = v , u <NEWLINE> <DEDENT> u %= m <NEWLINE> if u < 0 : <NEWLINE> <INDENT> u += m <NEWLINE> <DEDENT> return u <NEWLINE> <DEDENT> def __int__ ( self ) : <NEWLINE> <INDENT> return self . __x <NEWLINE> <DEDENT> def __str__ ( self ) : <NEWLINE> <INDENT> return str ( self . __x ) <NEWLINE> <NL> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> N , M , K = mulinputs ( ) <NEWLINE> an = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> bm = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> <COMMENT> <NL> ans , aidx , bidx = 0 , 0 , 0 <NEWLINE> while True : <NEWLINE> <INDENT> if ainx == len ( an ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if ans + an [ aidx ] <= K : <NEWLINE> <INDENT> ans += an [ aidx ] <NEWLINE> aidx += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> while True : <NEWLINE> <INDENT> if bidx = len ( bm ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if ans + bm [ bidx ] <= K : <NEWLINE> <INDENT> ans += bm [ bidx ] <NEWLINE> bidx += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> ansidx = aidx + bidx <NEWLINE> while aidx > 0 : <NEWLINE> <INDENT> aidx -= 1 <NEWLINE> ans -= an [ aidx ] <NEWLINE> while True : <NEWLINE> <INDENT> if bidx == len ( bm ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if ans + bm [ bidx ] <= K : <NEWLINE> <INDENT> ans += bm [ bidx ] <NEWLINE> bidx += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> ansidx = max ( ansidx , aidx + bidx ) <NEWLINE> <DEDENT> print ( ansidx ) <NEWLINE> <DEDENT>
N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> a , b = [ 0 ] , [ 0 ] <NEWLINE> for i in range ( N ) : <NEWLINE> a . append ( a [ i ] + A [ i ] ) <NEWLINE> for i in range ( M ) : <NEWLINE> b . append ( b [ i ] + B [ i ] ) <NEWLINE> <NL> ans , j = 0 , M <NEWLINE> for i in range ( N + 1 ) : <NEWLINE> if a [ i ] > K : <NEWLINE> break <NEWLINE> while b [ j ] > K - a [ i ] : <NEWLINE> j -= 1 <NEWLINE> ans = max ( ans , i + j ) <NEWLINE> print ( ans ) <NEWLINE>
/ usr / bin / env python3 <NEWLINE> import sys <NEWLINE> <NL> <NL> N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a , b = [ 0 ] , [ 0 ] <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> a . append ( a [ i ] + A [ i ] ) <NEWLINE> <DEDENT> for i in range ( M ) : <NEWLINE> <INDENT> b . append ( b [ i ] + B [ i ] ) <NEWLINE> <DEDENT> ans , j = 0 , M <NEWLINE> for i in range ( N + 1 ) : <NEWLINE> <INDENT> if a [ i ] > K : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> while b [ j ] > K - a [ i ] : <NEWLINE> <INDENT> j -= 1 <NEWLINE> <DEDENT> ans = max ( ans , i + j ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> asum = [ 0 ] <NEWLINE> bsum = [ 0 ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> asum . append ( asum [ - 1 ] + a [ i ] ) <NEWLINE> <DEDENT> for i in range ( m ) : <NEWLINE> <INDENT> bsum . append ( bsum [ - 1 + b [ i ] ] ) <NEWLINE> <DEDENT> ans = 0 <NEWLINE> for i in range ( n + 1 ) : <NEWLINE> <INDENT> if asum [ i ] > 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> while asum [ i ] + bsum [ m ] > 0 and m > 0 : <NEWLINE> <INDENT> m -= 1 <NEWLINE> <DEDENT> ans = ( ans , i + m ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> B = [ int ( j ) for j in input ( ) . split ( ) ] <NEWLINE> <NL> a , b = [ 0 ] , [ 0 ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> a . append [ a [ i ] + A [ i ] ] <NEWLINE> <DEDENT> for i in range ( M ) : <NEWLINE> <INDENT> b . append [ b [ i ] + B [ i ] ] <NEWLINE> <NL> <DEDENT> ans , j = 0 , M <NEWLINE> for i in range ( N + 1 ) : <NEWLINE> <INDENT> if a [ i ] > K : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> while b [ j ] > K - a [ i ] : <NEWLINE> <INDENT> j -= 1 <NEWLINE> <DEDENT> ans = max ( ans , i + j ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE> <NL>
n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> arr1 = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> arr2 = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> acum1 = [ 0 ] <NEWLINE> <NL> <COMMENT> <NL> for i in range ( n ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <INDENT> acum1 . append ( acum [ - 1 ] + arr1 [ i ] ) <NEWLINE> <NL> <DEDENT> acum2 = [ 0 ] <NEWLINE> <NL> for i in range ( m ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <INDENT> acum2 . append ( acum2 [ - 1 ] + arr2 [ i ] ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in range ( n + 1 ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <INDENT> if acum1 [ i ] > k : <NEWLINE> <INDENT> break <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> while acum2 [ j ] > k - acum1 [ i ] and j > 0 : <NEWLINE> j -= 1 <NEWLINE> <INDENT> ans = max ( ans , i + j ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = [ 0 ] <NEWLINE> b = [ 0 ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> a . append ( a [ i ] + A [ i ] ) <NEWLINE> <DEDENT> for i in range ( M ) : <NEWLINE> <INDENT> b . append ( b [ i ] + B [ i ] ) <NEWLINE> <DEDENT> ans , j = 0 , M <NEWLINE> for i in range ( N + 1 ) : <NEWLINE> <INDENT> if a [ i ] > K : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> while b [ j ] > K - a [ i ] : <NEWLINE> <INDENT> j -= 1 <NEWLINE> <DEDENT> ans = max ( ans , i + j ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import bisect <NEWLINE> n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in range ( 1 , n ) : <NEWLINE> <INDENT> a [ i ] += a [ i - 1 ] <NEWLINE> <DEDENT> for i in range ( 1 , m ) : <NEWLINE> <INDENT> b [ i ] += b [ i - 1 ] <NEWLINE> <NL> <DEDENT> I = bisect . bisect_right ( a , k ) <NEWLINE> ans = bisect . bisect_right ( b , k ) <NEWLINE> li = list ( range ( I ) ) <NEWLINE> li = li [ : : - 1 ] <NEWLINE> for i in li : <NEWLINE> <INDENT> tmp = bisect . bisect_right ( b , k - a [ i ] ) <NEWLINE> if a [ i ] + b [ tmp - 1 ] <= k & & tmp != 0 : <NEWLINE> <INDENT> ans = max ( ans , i + tmp + 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a , b = [ 0 ] , [ 0 ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> a . append ( a [ i ] + A [ i ] ) <NEWLINE> <DEDENT> for i in range ( M ) : <NEWLINE> <INDENT> b . append ( b [ i ] + B [ i ] ) <NEWLINE> <DEDENT> ans , j = 0 , M <NEWLINE> for i in range ( N + 1 ) : <NEWLINE> <INDENT> if a [ i ] > K : <NEWLINE> break <NEWLINE> while b [ j ] > K - a [ i ] : <NEWLINE> <INDENT> j -= 1 <NEWLINE> <DEDENT> ans = max ( ans , i + j ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
<NL> <NL> import sys <NEWLINE> import math <NEWLINE> import itertools <NEWLINE> import collections <NEWLINE> <NL> def solve ( N , M , K , A , B ) : <NEWLINE> <INDENT> accumA = [ 0 , A . pop ( 0 ) ] <NEWLINE> accumB = [ 0 , B . pop ( 0 ) ] <NEWLINE> for a in A : <NEWLINE> <INDENT> accumA . append ( accumA [ - 1 ] + a ) <NEWLINE> <DEDENT> for b in B : <NEWLINE> <INDENT> accumB . append ( accumB [ - 1 ] + b ) <NEWLINE> <DEDENT> ans = 0 <NEWLINE> j = M <NEWLINE> for i in range ( N + 1 ) : <NEWLINE> <INDENT> if a [ i ] > K : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> while b [ j ] > K - a [ i ] : <NEWLINE> <INDENT> j -= 1 <NEWLINE> <DEDENT> ans = max ( ans , i + j ) <NEWLINE> <DEDENT> return ans <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <COMMENT> <NL> print ( solve ( N , M , K , A , B ) ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <NL> <NL> <DEDENT>
N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a , b = [ 0 ] , [ 0 ] <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> a . append ( a [ i ] + A [ i ] ) <NEWLINE> <DEDENT> for i in range ( M ) : <NEWLINE> <INDENT> b . append ( b [ i ] + B [ i ] ) <NEWLINE> <DEDENT> ans , j = 0 , M <NEWLINE> for i in range ( N + 1 ) : <NEWLINE> <INDENT> if a [ i ] > K : <NEWLINE> break <NEWLINE> while b [ j ] > K - a [ i ] : <NEWLINE> <INDENT> j -= 1 <NEWLINE> <DEDENT> ans = max ( ans , i + j ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <COMMENT> <NL> A_min = [ 0 ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> A_min . append ( A_min [ i ] + A [ i ] ) <NEWLINE> <DEDENT> B_min = [ 0 ] <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> B_min . append ( B_min [ i ] + B [ i ] ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> ans = 0 <NEWLINE> B_len = len ( B_min ) <NEWLINE> for i in range ( len ( A_min ) ) : <NEWLINE> <INDENT> if A_min [ i ] > K : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> while true : <NEWLINE> <INDENT> if B_min [ B_len ] > K - A_min [ i ] : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> ans = max ( ans , i + B_len ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<INDENT> N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a , b = [ 0 ] , [ 0 ] <NEWLINE> for i in range ( N ) : <NEWLINE> a . append ( a [ i ] + A [ i ] ) <NEWLINE> for i in range ( M ) : <NEWLINE> b . append ( b [ i ] + B [ i ] ) <NEWLINE> <NL> ans , j = 0 , M <NEWLINE> <DEDENT> for i in range ( N + 1 ) : <NEWLINE> <INDENT> if a [ i ] > K : <NEWLINE> <INDENT> break <NEWLINE> while b [ j ] > K - a [ i ] : <NEWLINE> <DEDENT> j -= 1 <NEWLINE> <DEDENT> ans = max ( ans , i + j ) <NEWLINE> print ( ans ) <NEWLINE>
import numpy <NEWLINE> <NL> n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> li_a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> li_b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> li_A = numpy . cumsum ( li_a ) <NEWLINE> li_B = numpy . cumsum ( li_b ) <NEWLINE> <NL> ans , j = 0 , m <NEWLINE> for i in range ( n + 1 ) : <NEWLINE> <INDENT> if li_A [ i ] > k : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> while li_B [ j ] + li_A [ i ] > k : <NEWLINE> <INDENT> j -= 1 <NEWLINE> <DEDENT> ans = max ( ans , i + j ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> totalA = [ 0 ] <NEWLINE> totalB = [ 0 ] <NEWLINE> sumA = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> sumA += A [ 0 ] <NEWLINE> totalA . append ( sumA ) <NEWLINE> <DEDENT> sumB = 0 <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> sumB += B [ 0 ] <NEWLINE> totalB . append ( sumB ) <NEWLINE> <NL> <DEDENT> iA = N <NEWLINE> iB = 0 <NEWLINE> countMax = 0 <NEWLINE> while iA >= 0 : <NEWLINE> <INDENT> if totalA [ iA ] + totalB [ iB ] > K : <NEWLINE> <INDENT> iA -= 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if iB < M : <NEWLINE> <INDENT> countMax = max ( countMax , iA + iB ) <NEWLINE> iB += 1 <NEWLINE> <DEDENT> <DEDENT> elif iA == N and iB == M : <NEWLINE> <INDENT> countMax = max ( countMax , iA + iB ) <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( countMax ) <NEWLINE> <NL>
n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> a [ i ] += a [ i - 1 ] <NEWLINE> <DEDENT> for i in range ( 1 , m ) : <NEWLINE> <INDENT> b [ i ] += b [ i - 1 ] <NEWLINE> <DEDENT> a = [ 0 ] + a <NEWLINE> b = [ 0 ] + b <NEWLINE> <NL> ans = 0 <NEWLINE> ALL = 0 <NEWLINE> from bisect import bisect <NEWLINE> for i in range ( n + 1 ) : <NEWLINE> <INDENT> ALL = a [ i ] <NEWLINE> if ALL > k : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : idx = bisect ( b , k - ALL ) <NEWLINE> <COMMENT> <NL> <INDENT> ans = max ( ans , i + idx - 1 ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> a , b = [ 0 ] , [ 0 ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> a . append ( a [ i ] + A [ i ] ) <NEWLINE> <DEDENT> for i in range ( M ) : <NEWLINE> <INDENT> b . append ( b [ i ] + B [ i ] ) <NEWLINE> <NL> <DEDENT> v , j = 0 , M <NEWLINE> <NL> for i in range ( N + 1 ) : <NEWLINE> <INDENT> if a [ i ] > K : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> while b [ j ] > K - a [ i ] : <NEWLINE> <INDENT> j -= 1 <NEWLINE> <DEDENT> v = max ( b , i + j ) <NEWLINE> <NL> <DEDENT> print ( v ) <NEWLINE> <NL>
N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> import numpy as np <NEWLINE> a = np . array ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> b = np . array ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> a_s = a . cumsum ( ) <NEWLINE> b_s = b . cumsum ( ) <NEWLINE> an = 0 <NEWLINE> ans = 0 <NEWLINE> while an < N and a_s [ an ] <= K : <NEWLINE> <INDENT> bn = 0 <NEWLINE> while bn < M and a_s [ an ] + b_s [ bn ] <= K : <NEWLINE> bn += 1 <NEWLINE> if an + bn + 1 > ans : <NEWLINE> ans = an + bn + 1 <NEWLINE> an += 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> a = [ 0 ] <NEWLINE> b = [ 0 ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> a . appned ( a [ i ] + A [ i ] ) <NEWLINE> <DEDENT> for i in range ( M ) : <NEWLINE> <INDENT> b . append ( b [ i ] + B [ i ] ) <NEWLINE> <NL> <DEDENT> ans , j = 0 , M <NEWLINE> for i in range ( len ( A ) ) : <NEWLINE> <INDENT> if a [ i ] > K : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> while B [ j ] > K - a [ i ] : <NEWLINE> <INDENT> j -= 1 <NEWLINE> <DEDENT> ans = max ( ans , i + j ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
def ii ( ) : return int ( input ( ) ) <NEWLINE> def iim ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def iil ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> import numpy as np <NEWLINE> <NL> n , m , k = iim ( ) <NEWLINE> a = iil ( ) <NEWLINE> cuma = np . cumsum ( a ) <NEWLINE> b = iil ( ) <NEWLINE> cumb = np . cumsum ( b ) <NEWLINE> <NL> best = m <NEWLINE> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if cuma [ i ] > k : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> while b [ best ] > k - a [ i ] : <NEWLINE> <INDENT> best -= 1 <NEWLINE> <DEDENT> ans = max ( ans , best + i ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import bisect <NEWLINE> <NL> N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> a = [ 0 ] <NEWLINE> b = [ 0 ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> a += [ a [ i ] + A [ i ] ] <NEWLINE> <DEDENT> for i in range ( M ) : <NEWLINE> <INDENT> b += [ b [ i ] + B [ i ] ] <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in range ( N + 1 ) : <NEWLINE> <INDENT> if A [ i ] <= K : <NEWLINE> <INDENT> ans = max ( ans , i + bisect . bisect_right ( b , K - a [ i ] ) - 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n , m , k = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> a_list = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> b_list = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> a_sum = 0 <NEWLINE> b_sum = sum ( b_list ) <NEWLINE> <NL> j = m <NEWLINE> best = 0 <NEWLINE> for i , a in enumerate ( a_list ) : <NEWLINE> <INDENT> a_sum += a <NEWLINE> if a_sum > k : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> while ( ( a_sum + b_sum ) > k ) & ( j >= 0 ) : <NEWLINE> <INDENT> b_sum -= b_list [ j ] <NEWLINE> j -= 1 <NEWLINE> <NL> <DEDENT> best = max ( best , i + j + 2 ) <NEWLINE> <NL> <NL> <NL> <DEDENT> print ( best ) <NEWLINE>
import itertools <NEWLINE> import bisect <NEWLINE> N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> A_ = list ( itertools . accumulate ( A ) ) <NEWLINE> B_ = list ( itertools . accumulate ( B ) ) <NEWLINE> <NL> <NL> l = len ( A_ ) <NEWLINE> ans = max ( ans , bisect . bisect_right ( B_ , K ) ) <NEWLINE> for idx , i in enumerate ( A_ ) : <NEWLINE> <INDENT> if i <= K : <NEWLINE> <INDENT> ans = max ( idx + 1 + bisect . bisect_right ( B_ , K - i ) , ans ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = [ 0 ] <NEWLINE> b = [ 0 ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a . append ( a [ i ] + A [ i ] ) <NEWLINE> <DEDENT> for i in range ( m ) : <NEWLINE> <INDENT> b . append ( b [ i ] + B [ i ] ) <NEWLINE> <DEDENT> ans = 0 <NEWLINE> j = m <NEWLINE> for i in range ( n + 1 ) : <NEWLINE> <INDENT> if a [ 0 ] > k : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> while b [ j ] > k - a [ i ] : <NEWLINE> <INDENT> j -= 1 <NEWLINE> <DEDENT> ans = max ( ans , i + j ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
from sys import stdin <NEWLINE> nii = lambda : map ( int , stdin . readline ( ) . split ( ) ) <NEWLINE> lnii = lambda : list ( map ( int , stdin . readline ( ) . split ( ) ) ) <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> <NL> def eratosthenes ( lim ) : <NEWLINE> <INDENT> is_p = [ 2 ] * lim <NEWLINE> <NL> is_p [ 0 ] = 0 <NEWLINE> is_p [ 1 ] = 1 <NEWLINE> <NL> for i in range ( 2 , lim ) : <NEWLINE> <INDENT> for j in range ( i * 2 , lim , i ) : <NEWLINE> <INDENT> is_p [ j ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> return is_p <NEWLINE> <NL> <DEDENT> lim = n + 1 <NEWLINE> is_p = eratosthenes ( lim ) <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> ans += i * is_p [ i ] <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
from itertools import accumulate <NEWLINE> from bisect import bisect_right <NEWLINE> <NL> n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> b = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> <COMMENT> <NL> a_cum = list ( accumulate ( a ) ) <NEWLINE> b_cum = list ( accumulate ( b ) ) <NEWLINE> <NL> ans = [ 0 ] <NEWLINE> for i in range ( n + 1 ) : <NEWLINE> <INDENT> c = bisect_right ( b , k - a [ i ] ) - 1 <NEWLINE> if c != - 1 : <NEWLINE> <INDENT> ans . append ( c + i ) <NEWLINE> <DEDENT> <DEDENT> print ( max ( ans ) ) <NEWLINE>
<NL> import bisect <NEWLINE> import numpy <NEWLINE> <NL> n , m , k = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> b = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> <NL> cost_a = numpy . insert ( numpy . cumsum ( a ) , 0 , 0 ) <NEWLINE> cost_b = numpy . insert ( numpy . cumsum ( b ) , 0 , 0 ) <NEWLINE> <NL> ans = 0 <NEWLINE> j = len ( cost_b ) - 1 <NEWLINE> for i in range ( len ( cost_a ) ) : <NEWLINE> <INDENT> for j in range ( j , 0 , - 1 ) : <NEWLINE> <INDENT> if cost_a [ i ] + cost_b [ j ] <= k : <NEWLINE> <INDENT> ans = i + j if ans < i + j else ans <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> [ root @ local <NEWLINE>
n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> x , y = [ 0 ] , [ 0 ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> x . append ( a [ i ] + x [ i ] ) <NEWLINE> <DEDENT> for j in range ( m ) : <NEWLINE> <INDENT> y . append ( b [ j ] + y [ j ] ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> j = m <NEWLINE> for i in range ( N + 1 ) : <NEWLINE> <INDENT> if x [ i ] > k : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> while y [ j ] > k - x [ i ] : <NEWLINE> <INDENT> j -= 1 <NEWLINE> <DEDENT> ans = max <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
from sys import stdin , stdout <NEWLINE> input = stdin . readline <NEWLINE> print = stdout . write <NEWLINE> n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a , b = [ 0 ] , [ 0 ] <NEWLINE> a += list ( map ( int , input ( ) . split ( ) ) ) , <NEWLINE> b += list ( map ( int , input ( ) . split ( ) ) ) , <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> a [ i ] += a [ i - 1 ] <NEWLINE> <DEDENT> for i in range ( 1 , m + 1 ) : <NEWLINE> <INDENT> b [ i ] += b [ i - 1 ] <NEWLINE> <DEDENT> i , j , z = 0 , m , 0 <NEWLINE> while i <= n and a [ i ] <= k : <NEWLINE> <INDENT> while b [ j ] > k - a [ i ] : <NEWLINE> <INDENT> j -= 1 <NEWLINE> <DEDENT> z = max ( z , i + j ) <NEWLINE> i += 1 <NEWLINE> <DEDENT> print ( str ( z ) ) <NEWLINE>
import itertools <NEWLINE> import functools <NEWLINE> import math <NEWLINE> from collections import Counter <NEWLINE> from itertools import combinations <NEWLINE> import re <NEWLINE> <NL> <NL> <NL> def main_sum ( ) : <NEWLINE> <INDENT> N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> A_len = len ( A ) <NEWLINE> maxB = len ( B ) <NEWLINE> <NL> Asum = [ 0 ] * ( 200000 + 1 ) <NEWLINE> <NL> maxA = 0 <NEWLINE> <NL> add = 0 <NEWLINE> for i in range ( 1 , A_len + 1 ) : <NEWLINE> <INDENT> add += A [ i - 1 ] <NEWLINE> Asum [ i ] = add <NEWLINE> if add <= K : <NEWLINE> <INDENT> maxA = i + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> ans = maxA <NEWLINE> prevmax = 0 <NEWLINE> Bsum = 0 <NEWLINE> for i in reversed ( range ( maxA ) ) : <NEWLINE> <INDENT> for j in range ( prevmax , maxB ) : <NEWLINE> <INDENT> Bsum += B [ j ] <NEWLINE> if Asum [ i ] + Bsum <= K : <NEWLINE> <INDENT> if ans < i + ( j + 1 ) : <NEWLINE> <INDENT> ans = i + ( j + 1 ) <NEWLINE> prevmax = j <NEWLINE> <NL> <DEDENT> if j == maxB - 1 <NEWLINE> <INDENT> print ( ans ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> main_sum ( ) <NEWLINE>
import bisect <NEWLINE> <NL> N , M , K = map ( int , inp ( ) . split ( ) ) <NEWLINE> list_a = list ( map ( int , inp ( ) . split ( ) ) ) <NEWLINE> list_b = list ( map ( int , inp ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> totaltame_a = [ 0 ] <NEWLINE> for a in list_a : <NEWLINE> <INDENT> temp_a = totaltame_a [ - 1 ] + a <NEWLINE> if temp_a > K : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> totaltame_a . append ( temp_a ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> totaltime_b = [ 0 ] <NEWLINE> for b in list_b : <NEWLINE> <INDENT> totaltime_b . append ( totaltime_b [ - 1 ] + b ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> <NL> for i in range ( len ( totaltame_a ) ) : <NEWLINE> <INDENT> Kb = K - totaltame_a [ i ] <NEWLINE> j = bisect . bisect_right ( totaltime_b , Kb ) - 1 <NEWLINE> if i + j > ans : <NEWLINE> <INDENT> ans = i + j <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> pass <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = A [ 0 ] <NEWLINE> A2 = [ a ] <NEWLINE> b = B [ 0 ] <NEWLINE> B2 = [ b ] <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> a += A [ i ] <NEWLINE> A2 . append ( a ) <NEWLINE> <NL> <DEDENT> for i in range ( 1 , m ) : <NEWLINE> <INDENT> b += B [ i ] <NEWLINE> B2 . append ( b ) <NEWLINE> <DEDENT> max = - 2 <NEWLINE> for ia , aa in enumerate ( A2 ) : <NEWLINE> <INDENT> for ib , bb in enumerate ( B2 ) : <NEWLINE> <INDENT> if aa + bb > k : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if ia + ib > max : <NEWLINE> <NL> <INDENT> max = ia + ib <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( max + 2 ) <NEWLINE> <NL> <NL> <DEDENT> def answer ( ) : <NEWLINE> <INDENT> N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <NL> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> a , b = [ 0 ] , [ 0 ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> a . append ( a [ i ] + A [ i ] ) <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> b . append ( b [ i ] + B [ i ] ) <NEWLINE> <NL> <DEDENT> ans , j = 0 , M <NEWLINE> for i in range ( N + 1 ) : <NEWLINE> if a [ i ] > K : <NEWLINE> break <NEWLINE> while b [ j ] > K - a [ i ] : <NEWLINE> j -= 1 <NEWLINE> ans = max ( ans , i + j ) <NEWLINE> print ( ans ) <NEWLINE> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> answer ( ) <NEWLINE> <DEDENT>
N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> a , b = [ 0 ] , [ 0 ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a . append ( a [ i ] + A [ i ] ) <NEWLINE> <DEDENT> for i in range ( m ) : <NEWLINE> <INDENT> b . append ( b [ i ] + B [ i ] ) <NEWLINE> <NL> <DEDENT> ans , j = 0 , M <NEWLINE> <NL> for i in range ( N + 1 ) : <NEWLINE> <INDENT> if a [ i ] > K : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> while b [ j ] > K - a [ i ] : <NEWLINE> <INDENT> j -= 1 <NEWLINE> <DEDENT> ans = max ( ans , i + j ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> a , b = [ 0 ] , [ 0 ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> a . append ( a [ i ] + A [ i ] ) <NEWLINE> <DEDENT> for i in range ( M ) : <NEWLINE> <INDENT> b . append ( b [ i ] + B [ i ] ) <NEWLINE> <NL> <DEDENT> ans , j = 0 , M <NEWLINE> for i in range ( N + 1 ) : <NEWLINE> <INDENT> if a [ i ] > K : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> while b [ j ] > K - a [ i ] : <NEWLINE> <INDENT> j -= 1 <NEWLINE> <DEDENT> ans = max ( ans , i + j ) <NEWLINE> print ( ans ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> indb = M - 1 <NEWLINE> now = sum ( B ) <NEWLINE> count = M <NEWLINE> while now > K : <NEWLINE> <INDENT> now -= B [ indb ] <NEWLINE> count -= 1 <NEWLINE> indb -= 1 <NEWLINE> <NL> <DEDENT> ans = count <NEWLINE> <NL> for a in A : <NEWLINE> <INDENT> count += 1 <NEWLINE> now += a <NEWLINE> <NL> while now > K and indb >= 0 : <NEWLINE> <INDENT> now -= B [ indb ] <NEWLINE> count -= 1 <NEWLINE> indb -= 1 <NEWLINE> <NL> <DEDENT> if now <= K : <NEWLINE> <INDENT> if ans < count : <NEWLINE> <INDENT> ans = count <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name __ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> aa , bb = [ 0 ] , [ 0 ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> aa . append ( aa [ - 1 ] + a [ i ] ) <NEWLINE> <DEDENT> for i in range ( m ) : <NEWLINE> <INDENT> bb . append ( bb [ - 1 ] + b [ i ] ) <NEWLINE> <DEDENT> ans , j = 0 , m <NEWLINE> for i in range ( n + 1 ) : <NEWLINE> <INDENT> if a [ i ] > k : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> while b [ j ] > k - a [ i ] : <NEWLINE> <INDENT> j -= 1 <NEWLINE> <DEDENT> ans = max ( ans , i + j ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
from bisect import bisect_right <NEWLINE> <NL> N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <COMMENT> <NL> a_sum = [ 0 ] <NEWLINE> b_sum = [ 0 ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> a_sum . append ( a_sum [ i ] + a [ i ] ) <NEWLINE> <DEDENT> for i in range ( M ) : <NEWLINE> <INDENT> b_sum . append ( b_sum [ i ] + b [ i ] ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> <COMMENT> <NL> for i in range ( N + 1 ) : <NEWLINE> <INDENT> cntA = i <COMMENT> <NEWLINE> rest = K - a_sum [ i ] <COMMENT> <NEWLINE> if rest < 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> cntB = bisect_right ( b_sum , rest ) - 1 <COMMENT> <NEWLINE> ans = max ( ans , cntA + cntB ) <NEWLINE> print ( ans ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 2147483647 ) <NEWLINE> <NL> N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> Asum = [ ] <NEWLINE> Bsum = [ ] <NEWLINE> count = 0 <NEWLINE> for p in A : <NEWLINE> <INDENT> count += p <NEWLINE> Asum . append ( count ) <NEWLINE> <DEDENT> count = 0 <NEWLINE> for p in B : <NEWLINE> <INDENT> count += p <NEWLINE> Bsum . append ( count ) <NEWLINE> <DEDENT> best = 0 <NEWLINE> Blast = M - 1 <NEWLINE> for t in range ( N ) : <NEWLINE> <INDENT> if Asum ( t ) > K : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if best < t + 1 : <NEWLINE> <INDENT> best = t + 1 <NEWLINE> <DEDENT> for s in reversed ( range ( 0 , Blast + 1 ) ) : <NEWLINE> <INDENT> if Asum [ t ] + Bsum [ s ] <= K : <NEWLINE> <INDENT> if best < t + 1 + s + 1 : <NEWLINE> <INDENT> best = t + 1 + s + 1 <NEWLINE> <DEDENT> Blast = s <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( best ) <NEWLINE> <NL>
N = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> <NL> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> Y = N // j <NEWLINE> ans += Y * ( Y + 1 ) * j / 2 <NEWLINE> <NL> <DEDENT> print ( int ( ans ) ) <NEWLINE>
primes = [ 2 ] <NEWLINE> li = [ [ ] , [ ] ] <NEWLINE> f_ans = [ 0 ] <NEWLINE> def f ( x ) : <NEWLINE> <INDENT> if x == 1 : <NEWLINE> <INDENT> f_ans . append ( 1 ) <NEWLINE> return 1 <NEWLINE> <DEDENT> if x == 2 : <NEWLINE> <INDENT> f_ans . append ( 2 ) <NEWLINE> return 2 <NEWLINE> <DEDENT> flag = True <NEWLINE> for i in range ( len ( primes ) ) : <NEWLINE> <INDENT> if x % primes [ i ] == 0 : <NEWLINE> <INDENT> tmp = li [ x // primes [ i ] ] [ : ] <NEWLINE> tmp [ i ] += 1 <NEWLINE> li . append ( tmp ) <NEWLINE> f_ans . append ( f_ans [ x // primes [ i ] ] // tmp [ i ] * ( tmp [ i ] + 1 ) ) <NEWLINE> return f_ans ( x ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> li . append ( [ 0 ] * len ( primes ) + [ 1 ] ) <NEWLINE> f_ans . append ( 2 ) <NEWLINE> primes . append ( x ) <NEWLINE> return 2 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> n = int ( input ( ) ) <NEWLINE> sum = 0 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> sum += i * f ( i ) <NEWLINE> <DEDENT> print ( sum ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for j in range ( N ) : <NEWLINE> <INDENT> N_j = N // j <NEWLINE> ans += j * ( 1 + N_j ) * N_j // 2 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> <NL> ans = sum ( [ j * ( N // j ) * ( N // j + 1 ) / 2 for j in range ( N ) ] ) <NEWLINE> <NL> print ( ans ) <NEWLINE>
import math <NEWLINE> k = int ( input ( ) ) <NEWLINE> an = 0 <NEWLINE> for i in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> li = [ ] <NEWLINE> cnt = 1 <NEWLINE> num = i <NEWLINE> if i == 1 : <NEWLINE> <INDENT> lis . append ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for j in range ( 2 , math . ceil ( math . sqrt ( i ) ) + 1 ) : <NEWLINE> <INDENT> while num % j == 0 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> num //= j <NEWLINE> <DEDENT> if cnt != 1 : <NEWLINE> <INDENT> li . append ( cnt ) <NEWLINE> cnt = 1 <NEWLINE> <DEDENT> <DEDENT> if num != 1 : <NEWLINE> <INDENT> li . append ( 2 ) <NEWLINE> <DEDENT> ans = 1 <NEWLINE> for nu in li : <NEWLINE> <INDENT> ans *= nu <NEWLINE> <DEDENT> an += ans <NEWLINE> <DEDENT> <DEDENT> print ( an ) <NEWLINE>
n = int ( imput ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> i = i + 1 <NEWLINE> a = i <NEWLINE> y = n // i <NEWLINE> <NL> ans += ( i * y * ( y + 1 ) / 2 ) <NEWLINE> <NL> <NL> <NL> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> cnts = [ k * d * ( d + 1 ) // 2 for k in range ( 1 , n // 2 ) ] <NEWLINE> print ( sum ( cnts ) + ( n // 2 ) * d * ( d + 1 ) // 2 ) <NEWLINE>
<COMMENT> <NL> import sympy <NEWLINE> n = int ( input ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> ans += i * sympy . divisors ( i ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> def g ( n ) : <NEWLINE> <INDENT> return n * ( n + 1 ) // 2 <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in range ( 1 , n + 1 ) <NEWLINE> <INDENT> ans += i * g ( n // i ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> <NL> def primes ( n ) : <NEWLINE> <INDENT> is_prime = [ True ] * ( n + 1 ) <NEWLINE> is_prime [ 0 ] = False <NEWLINE> is_prime [ 1 ] = False <NEWLINE> for i in range ( 2 , int ( n ** 0.5 ) + 1 ) : <NEWLINE> <INDENT> if not is_prime [ i ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> for j in range ( i * 2 , n + 1 , i ) : <NEWLINE> <INDENT> is_prime [ j ] = False <NEWLINE> <DEDENT> <DEDENT> return [ i for i in range ( n + 1 ) if is_prime [ i ] ] <NEWLINE> <NL> <NL> <DEDENT> def prime_factrize ( n ) : <NEWLINE> <INDENT> prime_list = primes ( n ) <NEWLINE> s = int ( math . sqrt ( n ) ) + 1 <NEWLINE> l = [ 0 ] * s <NEWLINE> for x in prime_list : <NEWLINE> <INDENT> if x ** 2 > n : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> while n % x == 0 : <NEWLINE> <INDENT> n // x <NEWLINE> l [ x ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> return l <NEWLINE> <NL> <DEDENT> def yakusuu ( n ) : <NEWLINE> <INDENT> l = prime_factrize ( n ) <NEWLINE> res = 1 <NEWLINE> <NL> for i in l : <NEWLINE> <INDENT> res *= ( i + 1 ) <NEWLINE> <NL> <DEDENT> return res <NEWLINE> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> y = yakusuu ( i ) <NEWLINE> ans += i * y <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> j = N // i <NEWLINE> ans += i * j * ( j + 1 ) / 2 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) . strip ( ) ) <NEWLINE> a = 0 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> a += i * ( ( n // i ) * ( n // i + 1 ) // 2 ) <NEWLINE> print ( a ) <NEWLINE> <DEDENT>
from numba import njit <NEWLINE> import numpy as np <NEWLINE> <NL> @ njit ( <STRING> ) <NEWLINE> def solve ( n ) : <NEWLINE> <INDENT> s = np . ones ( n + 1 , dtype = np . int64 ) <NEWLINE> ans = 1 <NEWLINE> for i in range ( 2 , n + 1 ) : <NEWLINE> <INDENT> for j in range ( i , n + 1 , i ) : <NEWLINE> <INDENT> s [ j ] += 1 <NEWLINE> <DEDENT> ans += ( i * s [ i ] ) <NEWLINE> <DEDENT> <DEDENT> n = int ( input ( ) ) <NEWLINE> print ( solve ( n ) ) <NEWLINE>
from numba import njit <NEWLINE> <NL> @ njit ( <STRING> ) <NEWLINE> def solve ( n ) : <NEWLINE> <INDENT> s = [ 1 ] * ( n + 1 ) <NEWLINE> ans = 1 <NEWLINE> for i in range ( 2 , n + 1 ) : <NEWLINE> <INDENT> for j in range ( i , n + 1 , i ) : <NEWLINE> <INDENT> s [ j ] += 1 <NEWLINE> <DEDENT> ans += ( i * s [ i ] ) <NEWLINE> return ans <NEWLINE> <DEDENT> <DEDENT> n = int ( input ( ) ) <NEWLINE> print ( solve ( n ) ) <NEWLINE>
<COMMENT> <NL> from numba import njit <NEWLINE> <NL> <NL> @ njit <NEWLINE> def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> res = 0 <NEWLINE> for a in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> for b in range ( 1 , N // a + 1 ) : <NEWLINE> <INDENT> res += a * b <NEWLINE> <DEDENT> <DEDENT> print ( res ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> sum = 0 <NEWLINE> for k in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> y = n // i <NEWLINE> sum += y * ( y + 1 ) * i // 2 <NEWLINE> <DEDENT> print ( sum ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> a = 0 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> x , y = i , ( n // i ) * i <NEWLINE> a += ( ( n // i ) * ( x + y ) // 2 ) <NEWLINE> <DEDENT> print ( a ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> ssum = 0 <NEWLINE> start = time . time ( ) <NEWLINE> for k in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> X = int ( N / k ) <NEWLINE> ssum += k * X * ( X + 1 ) / 2 <NEWLINE> <DEDENT> print ( int ( ssum ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> for i in rabge ( 1 , n + 1 ) : <NEWLINE> <INDENT> num = n // i <NEWLINE> ans += i * num * ( num + 1 ) / 2 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
import numpy as np <NEWLINE> from numba import njit <NEWLINE> <NL> @ njit <NEWLINE> def solve ( ) : <NEWLINE> <NL> <INDENT> n = int ( input ( ) ) <NEWLINE> <NL> divisors = np . zeros ( n + 1 , np . int64 ) <NEWLINE> <NL> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> for j in range ( i , n + 1 , i ) : <NEWLINE> <INDENT> divisors [ j ] += 1 <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for k in range ( n + 1 ) : <NEWLINE> <INDENT> ans += ( k * divisors [ k ] ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> solve ( ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> y = n // i <NEWLINE> ans += y * ( y + 1 ) * i // 2 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import numpy as np <NEWLINE> from numba import njit <NEWLINE> <NL> <NL> @ njit ( <STRING> , cache = True ) <NEWLINE> def solve ( n , div ) : <NEWLINE> <INDENT> for i in range ( 2 , n + 1 ) : <NEWLINE> <INDENT> div [ i : : i ] += 1 <NEWLINE> <DEDENT> return ( div * np . arange ( n + 1 ) ) . sum ( ) <NEWLINE> <NL> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> div = np . ones ( n + 1 , dtype = np . int32 ) <NEWLINE> print ( solve ( n , div ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> print ( sum ( n / i * ( n / i + 1 ) / 2 * i for i in range ( 1 , n + 1 ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> def cal ( n ) : <NEWLINE> <INDENT> return n * ( n + 1 ) // 2 <NEWLINE> <DEDENT> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> x = N // i <NEWLINE> ans += i * ( x * ( x + 1 ) // 2 ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> import numpy <NEWLINE> div = np . zeros ( N + 1 , np . int64 ) <NEWLINE> for n in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> for m in range ( n , N + 1 , n ) : <NEWLINE> <INDENT> div [ m ] += m <NEWLINE> <DEDENT> <DEDENT> print ( sum ( div ) ) <NEWLINE>
from numba import njit <NEWLINE> <NL> @ njit <NEWLINE> def func ( N ) : <NEWLINE> <INDENT> dp = [ 1 for _ in range ( N + 1 ) ] <NEWLINE> for i in range ( 2 , N + 1 ) : <NEWLINE> <INDENT> for j in range ( i , N + 1 , i ) : <NEWLINE> <INDENT> dp [ j ] += 1 <NEWLINE> <DEDENT> <DEDENT> return dp <NEWLINE> <NL> <DEDENT> N = int ( input ( ) ) <NEWLINE> dp = func ( N ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> ans += i * dp [ i ] <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> import numpy as np <NEWLINE> from numba import jit <NEWLINE> read = sys . stdin . buffer . read <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> readlines = sys . stdin . buffer . readlines <NEWLINE> @ jit ( cache = True ) <NEWLINE> def solve ( n ) : <NEWLINE> <INDENT> a = np . zeros ( N + 1 , np . int64 ) <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> a [ i : : i ] += 1 <NEWLINE> <DEDENT> ans = 0 <NEWLINE> for i in range ( N + 1 ) : <NEWLINE> <INDENT> ans += i * a [ i ] <NEWLINE> <DEDENT> return ans <NEWLINE> <NL> <DEDENT> N = int ( readline ( ) ) <NEWLINE> print ( solve ( N ) ) <NEWLINE>
import sys , os , math , bisect , itertools , collections , heapq , queue <NEWLINE> <COMMENT> <NL> from decimal import Decimal <NEWLINE> from collections import defaultdict , deque <NEWLINE> <NL> <COMMENT> <NL> <NL> sys . setrecursionlimit ( 10000000 ) <NEWLINE> <NL> ii = lambda : int ( sys . stdin . buffer . readline ( ) . rstrip ( ) ) <NEWLINE> il = lambda : list ( map ( int , sys . stdin . buffer . readline ( ) . split ( ) ) ) <NEWLINE> fl = lambda : list ( map ( float , sys . stdin . buffer . readline ( ) . split ( ) ) ) <NEWLINE> iln = lambda n : [ int ( sys . stdin . buffer . readline ( ) . rstrip ( ) ) for _ in range ( n ) ] <NEWLINE> <NL> iss = lambda : sys . stdin . buffer . readline ( ) . decode ( ) . rstrip ( ) <NEWLINE> sl = lambda : list ( map ( str , sys . stdin . buffer . readline ( ) . decode ( ) . split ( ) ) ) <NEWLINE> isn = lambda n : [ sys . stdin . buffer . readline ( ) . decode ( ) . rstrip ( ) for _ in range ( n ) ] <NEWLINE> <NL> lcm = lambda x , y : ( x * y ) // math . gcd ( x , y ) <NEWLINE> <COMMENT> <NL> <NL> MOD = 10 ** 9 + 7 <NEWLINE> MAX = float ( <STRING> ) <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> if os . getenv ( <STRING> ) : <NEWLINE> <INDENT> sys . stdin = open ( <STRING> , <STRING> ) <NEWLINE> <NL> <DEDENT> N , M , K = il ( ) <NEWLINE> A = il ( ) <NEWLINE> SA = [ 0 ] * ( N + 1 ) <NEWLINE> for n in range ( N ) : <NEWLINE> <INDENT> SA [ n + 1 ] = A [ n ] + SA [ n ] <NEWLINE> <DEDENT> B = il ( ) <NEWLINE> SB = [ 0 ] * ( M + 1 ) <NEWLINE> for m in range ( M ) : <NEWLINE> <INDENT> SB [ m + 1 ] = B [ m ] + SB [ m ] <NEWLINE> <NL> <DEDENT> ret = 0 <NEWLINE> for n in range ( N + 1 ) : <NEWLINE> <INDENT> for m in range ( M + 1 ) : <NEWLINE> <INDENT> if SA [ n ] + SB [ m ] <= K : <NEWLINE> <INDENT> ret = max ( ret , n + m ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ret ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
<NL> N = int ( input ( ) ) <NEWLINE> print ( sum ( i * ( N // i ) * ( N // i + 1 ) // 2 for i in range ( 1 , N + 1 ) ) <NEWLINE>
import sys <NEWLINE> import numba <NEWLINE> <NL> read = sys . stdin . buffer . read <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> readlines = sys . stdin . buffer . readlines <NEWLINE> <NL> @ numba . njit <NEWLINE> def main ( N ) : <NEWLINE> <INDENT> x = 0 <NEWLINE> for a in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> for b in range ( 1 , N // a + 1 ) : <NEWLINE> <INDENT> x += a * b <NEWLINE> <DEDENT> <DEDENT> return x <NEWLINE> <NL> <DEDENT> from my_module import main <NEWLINE> <NL> N = int ( read ( ) ) <NEWLINE> print ( main ( N ) ) <NEWLINE>
from numba import njit <NEWLINE> import numpy as np <NEWLINE> <NL> <NL> @ njit ( <STRING> ) <NEWLINE> def solve ( n ) : <NEWLINE> <INDENT> ans = 1 <NEWLINE> res = np . ones ( n + 1 , dtype = np . int64 ) <NEWLINE> for i in range ( 2 , n + 1 ) : <NEWLINE> <INDENT> res [ i : : i ] += 1 <NEWLINE> res [ i ] *= i <NEWLINE> ans += res [ i ] <NEWLINE> <DEDENT> return ans <NEWLINE> <NL> <NL> <DEDENT> N = int ( input ( ) ) <NEWLINE> print ( solve ( N ) ) <NEWLINE>
import numpy as np <NEWLINE> from numba import njit <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> <NL> <NL> @ njit <NEWLINE> def f ( n ) : <NEWLINE> <INDENT> cnt = np . zeros ( n + 1 , np . int32 ) <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> cnt [ i : : i ] += 1 <NEWLINE> <NL> <DEDENT> return ( cnt * np . arange ( n + 1 ) ) . sum ( ) <NEWLINE> <NL> <NL> <DEDENT> ans = f ( n ) <NEWLINE> print ( ans ) <NEWLINE>
s = 0 <NEWLINE> q = int ( n ** .5 ) <NEWLINE> for i in range ( 1 , int ( n ** .5 ) + 1 ) : <NEWLINE> <INDENT> x = n // i <NEWLINE> s += i * ( x * ( x + 1 ) ) / 2 <NEWLINE> if x ** 2 != n : <NEWLINE> <INDENT> y = max ( n // ( i + 1 ) , q ) <NEWLINE> s += ( i * ( i + 1 ) // 2 ) * ( ( x * ( x + 1 ) // 2 ) - ( y * ( y + 1 ) // 2 ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( int ( s ) ) <NEWLINE>
def solve ( n ) : <NEWLINE> <INDENT> ans = n * ( n + 1 ) - 1 <COMMENT> <NEWLINE> <NL> i = 2 <NEWLINE> while i * i <= n : <NEWLINE> <INDENT> num = n // i <NEWLINE> min_i = i * i <NEWLINE> max_i = i * num <NEWLINE> ans += ( num - i + 1 ) * ( min_i + max_i ) <COMMENT> <NEWLINE> ans -= min_i <NEWLINE> i += 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> return True <NEWLINE> <NL> <DEDENT> if __name__ = <STRING> : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> solve ( n ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> <NL> def solve ( ) : <NEWLINE> <NL> <INDENT> n = int ( input ( ) ) <NEWLINE> <NL> divisors = np . zeros ( n + 1 , np . int64 ) <NEWLINE> <NL> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> for j in range ( i , n + 1 , i ) : <NEWLINE> <INDENT> divisors [ j ] += 1 <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for k in range ( n + 1 ) : <NEWLINE> <INDENT> ans += ( k * divisors [ k ] ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> from numba import jit <NEWLINE> <NL> @ jit <NEWLINE> solve ( ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> nu = n // i <NEWLINE> ans += nu * ( nu + 1 ) * i // 2 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
def multiple_sum ( x , n ) : <NEWLINE> <COMMENT> <NL> <INDENT> k = n // x <NEWLINE> return x * ( k + 1 ) * k // 2 <NEWLINE> <NL> <NL> <DEDENT> def solve ( N : int ) : <NEWLINE> <INDENT> ans = 0 <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> ans += multiple_sum ( i , N ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> return <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> def iterate_tokens ( ) : <NEWLINE> <INDENT> for line in sys . stdin : <NEWLINE> <INDENT> for word in line . split ( ) : <NEWLINE> <INDENT> yield word <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> tokens = iterate_tokens ( ) <NEWLINE> N = int ( next ( tokens ) ) <COMMENT> <NEWLINE> solve ( N ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <NL> <COMMENT> <NL> <NL> N = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> n = N // i <COMMENT> <NEWLINE> cnt = ( n * ( 2 * i + ( n - 1 ) * i ) ) // 2 <COMMENT> <NEWLINE> ans += cnt <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <COMMENT> <NL> <NL> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> ans += ( n // i ) * ( int ( n / i ) + 1 ) ) // 2 * i ; <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> res = 0 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> k = n // i <NEWLINE> res += i * ( k * ( k + 1 ) // 2 ) <NEWLINE> <DEDENT> print res <NEWLINE>
import numpy as np <NEWLINE> from numba import * <NEWLINE> <NL> @ njit ( <STRING> , cache = True ) <NEWLINE> def solve ( x , nums , count ) : <NEWLINE> <INDENT> for i in range ( 2 , x + 1 ) : <NEWLINE> <INDENT> count [ np . arange ( i , x + 1 , i ) ] += 1 <NEWLINE> <DEDENT> count [ 0 ] = 0 <NEWLINE> return int ( np . sum ( nums * count ) ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> x = int ( input ( ) ) <NEWLINE> nums = np . arange ( x + 1 , dtype = np . int64 ) <NEWLINE> count = np . ones ( x + 1 , dtype = np . int64 ) <NEWLINE> print ( solve ( x , nums , count ) ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for X in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> Y = n // X <NEWLINE> ans += Y * ( Y + 1 ) // 2 * X <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import numba <NEWLINE> @ numba . njit ( <STRING> , cache = True ) <NEWLINE> def m ( n ) : <NEWLINE> <INDENT> return sum ( m * ( ( n // m ) ** 2 + n // m - m ** 2 ) for m in range ( 1 , int ( n ** .5 ) + 1 ) ) <NEWLINE> <NL> <DEDENT> print ( m ( int ( input ( ) ) ) ) <NEWLINE>
N = input ( ) <NEWLINE> N = int ( N ) <NEWLINE> sum = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> sum += ( i + 1 ) * ( 1 + N // ( i + 1 ) ) ( N // ( i + 1 ) ) / 2 <NEWLINE> <DEDENT> print ( sum ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> ans += ( ( n // i ) * ( 2 * i + ( n // i ) - 1 ) * i ) ) // 2 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> x = math . floor ( n / i ) <NEWLINE> ans += ( x * ( x + 1 ) * i ) / 2 <NEWLINE> <DEDENT> print ( int ( ans ) ) <NEWLINE>
1 N = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> Limit = N // i <NEWLINE> ans += int ( Limit * ( Limit + 1 ) * i / 2 ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import numpy as np <NEWLINE> from numba import njit <NEWLINE> <NL> @ njit ( <STRING> , cache = True ) <NEWLINE> def solve ( x ) : <NEWLINE> <INDENT> count = np . ones ( x + 1 , dtype = np . int8 ) <NEWLINE> for i in range ( 2 , x + 1 ) : <NEWLINE> <INDENT> for j in range ( i , x + 1 , i ) <NEWLINE> <INDENT> count [ j ] += 1 <NEWLINE> <DEDENT> <DEDENT> return int ( np . sum ( np . arange ( x + 1 ) * count ) ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> x = int ( input ( ) ) <NEWLINE> print ( solve ( x ) ) <NEWLINE> <DEDENT>
import sys <NEWLINE> import numpy as np <NEWLINE> <NL> read = sys . stdin . buffer . read <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> readlines = sys . stdin . buffer . readlines <NEWLINE> <NL> def main ( N ) : <NEWLINE> <INDENT> div = np . zeros ( N + 1 , np . int64 ) <NEWLINE> for n in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> div [ : : n ] += 1 <NEWLINE> <DEDENT> div *= np . arange ( N + 1 ) <NEWLINE> return div . sum ( ) <NEWLINE> <NL> <DEDENT> if sys . argv [ - 1 ] == <STRING> : <NEWLINE> <INDENT> import numba <NEWLINE> from numba . pycc import CC <NEWLINE> i8 = numba . int64 <NEWLINE> cc = CC ( <STRING> ) <NEWLINE> <NL> def cc_export ( f , signature ) : <NEWLINE> <INDENT> cc . export ( f . __name__ , signature ) ( f ) <NEWLINE> return numba . njit ( f ) <NEWLINE> <NL> <DEDENT> main = cc_export ( main , ( i8 , ) ) <NEWLINE> cc . compile ( ) <NEWLINE> <NL> <DEDENT> from my_module import main <NEWLINE> <NL> N = int ( read ( ) ) <NEWLINE> print ( main ( N ) ) <NEWLINE>
mod = 10 ** 9 + 7 <NEWLINE> fact = [ 1 ] <NEWLINE> for i in range ( 1 , 5 * 10 ** 5 + 1 ) : <NEWLINE> <INDENT> fact . append ( ( fact [ - 1 ] * i ) % mod ) <NEWLINE> <DEDENT> revfact = [ 1 ] <NEWLINE> for i in range ( 1 , 5 * 10 ** 5 + 1 ) : <NEWLINE> <INDENT> revfact . append ( pow ( fact [ i ] , mod - 2 , mod ) ) <NEWLINE> <DEDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> patternA = ( fact [ m ] * revfact [ n ] * revfact [ m - n ] * fact [ n ] ) % mod <NEWLINE> patternB = 0 <NEWLINE> for i in range ( n + 1 ) : <NEWLINE> <INDENT> tmp = ( fact [ n ] * revfact [ i ] * revfact [ n - i ] ) * ( fact [ m - i ] * revfact [ n - i ] * revfact [ m - n ] ) * fact [ n - i ] <NEWLINE> if i % 2 == 0 : <NEWLINE> <INDENT> patternB += tmp <NEWLINE> patternB %= mod <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> patternB -= tmp <NEWLINE> patternB %= mod <NEWLINE> <DEDENT> <DEDENT> print ( ( patternA * patternB ) % mod ) <NEWLINE>
MOD = 10 ** 9 + 7 <NEWLINE> MAX = 5 * 10 ** 6 + 1 <NEWLINE> <NL> fact = [ 0 for _ in range ( MAX ) ] <NEWLINE> factinv = [ 0 for _ in range ( MAX ) ] <NEWLINE> <NL> fact [ 0 ] = 1 <NEWLINE> for k in range ( 1 , MAX ) : <NEWLINE> <INDENT> fact [ k ] = fact [ k - 1 ] * k <NEWLINE> fact [ k ] %= MOD <NEWLINE> <NL> <DEDENT> factinv [ MAX - 1 ] = pow ( fact [ MAX - 1 ] , MOD - 2 , MOD ) <NEWLINE> for k in range ( MAX - 1 , 0 , - 1 ) : <NEWLINE> <INDENT> factinv [ k - 1 ] = fact [ k ] * k <NEWLINE> factinv [ k - 1 ] %= MOD <NEWLINE> <NL> <DEDENT> def nCk ( n , k ) : <NEWLINE> <INDENT> return fact [ n ] * factinv [ k ] * factinv [ n - k ] % MOD <NEWLINE> <NL> <DEDENT> def nPk ( n , k ) : <NEWLINE> <INDENT> return fact [ n ] * factinv [ n - k ] % MOD <NEWLINE> <NL> <DEDENT> n , m = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> for k in range ( n + 1 ) : <NEWLINE> <INDENT> tmp = nCk ( n , k ) * nPk ( m , k ) * nPk ( m - k , n - k ) * nPk ( m - k , n - k ) % MOD <NEWLINE> if k % 2 : ans += tmp <NEWLINE> else : ans -= tmp <NEWLINE> ans %= MOD <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> alst = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if n == 2 : <NEWLINE> <INDENT> if sum ( alst ) % 2 != 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> elif alst [ 0 ] < alst [ 1 ] : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ( alst [ 0 ] - alst [ 1 ] ) // 2 ) <NEWLINE> <DEDENT> exit ( ) <NEWLINE> <NL> <DEDENT> if alst . count ( 1 ) == n : <NEWLINE> <INDENT> if n % 2 == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> exit ( ) <NEWLINE> <NL> <DEDENT> if alst . count ( 1 ) == n - 1 : <NEWLINE> <INDENT> if n % 2 == 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> exit ( ) <NEWLINE> <NL> <DEDENT> xor = 0 <NEWLINE> for num in alst [ 2 : ] : <NEWLINE> <INDENT> xor ^= num <NEWLINE> <DEDENT> total = alst [ 0 ] + alst [ 1 ] <NEWLINE> if xor > total : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> diff = total - xor <NEWLINE> if diff % 2 == 1 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> if alst [ 0 ] == 1 : <NEWLINE> <INDENT> if xor == alst [ 0 ] ^ alst [ 1 ] : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> exit ( ) <NEWLINE> <NL> <DEDENT> diff //= 2 <NEWLINE> total_bin = format ( total , <STRING> ) <NEWLINE> diff_bin = format ( diff , <STRING> ) <NEWLINE> xor_bin = format ( xor , <STRING> ) <NEWLINE> i = len ( total_bin ) <NEWLINE> ans = 0 <NEWLINE> for j in range ( i , 0 , - 1 ) : <NEWLINE> <INDENT> if j <= len ( diff_bin ) : <NEWLINE> <INDENT> if diff_bin [ - j ] == <STRING> : <NEWLINE> <INDENT> ans += 2 ** ( j - 1 ) <NEWLINE> continue <NEWLINE> <DEDENT> <DEDENT> <DEDENT> for j in range ( i , 0 , - 1 ) : <NEWLINE> <INDENT> if j <= len ( diff_bin ) : <NEWLINE> <INDENT> if diff_bin [ - j ] == <STRING> : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> <DEDENT> if j <= len ( xor_bin ) : <NEWLINE> <INDENT> if xor_bin [ - j ] == <STRING> : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> <DEDENT> if ans + 2 ** ( j - 1 ) < alst [ 0 ] : <NEWLINE> <INDENT> ans += 2 ** ( j - 1 ) <NEWLINE> <DEDENT> <DEDENT> if ans == 0 or ans >= alst [ 0 ] : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( alst [ 0 ] - ans ) <NEWLINE> <DEDENT>
MAX = 5 * ( 10 ** 5 ) <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> def inv ( p ) : <NEWLINE> <INDENT> q = MOD - 2 <NEWLINE> res = 1 <NEWLINE> while q : <NEWLINE> <INDENT> if q % 2 == 1 : <NEWLINE> <INDENT> res = ( res * p ) % MOD <NEWLINE> <DEDENT> p = ( p * p ) % MOD <NEWLINE> q //= 2 <NEWLINE> <DEDENT> return res <NEWLINE> <NL> <DEDENT> _fact = [ 0 ] * ( MAX + 1 ) <NEWLINE> _inv = [ 0 ] * ( MAX + 1 ) <NEWLINE> _fact [ 0 ] = 1 <NEWLINE> _inv [ 0 ] = 1 <NEWLINE> for k in range ( 1 , MAX + 1 ) : <NEWLINE> <INDENT> _fact [ k ] = _fact [ k - 1 ] * k % MOD <NEWLINE> _inv [ k ] = inv ( _fact [ k ] ) <NEWLINE> <NL> <DEDENT> def P ( m , n ) : <NEWLINE> <INDENT> return _fact [ m ] * _inv [ m - n ] % MOD <NEWLINE> <NL> <DEDENT> def C ( m , n ) : <NEWLINE> <INDENT> return _fact [ m ] * _inv [ m - n ] * _inv [ n ] % MOD <NEWLINE> <NL> <DEDENT> def solve ( n , m ) : <NEWLINE> <INDENT> res = 0 <NEWLINE> for k in range ( n + 1 ) : <NEWLINE> <INDENT> sign = 1 - 2 * ( k % 2 ) <NEWLINE> cur = sign * C ( n , k ) * P ( m , k ) * ( P ( m - k , n - k ) ** 2 ) <NEWLINE> res = ( res + cur ) % MOD <NEWLINE> <DEDENT> return res <NEWLINE> <NL> <DEDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( solve ( n , m ) ) <NEWLINE>
max_fact = 5 * 10 ** 5 <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> f = [ 1 ] * ( max_fact + 1 ) <NEWLINE> for idx in range ( 2 , max_fact + 1 ) : <NEWLINE> <INDENT> f [ idx ] = f [ idx - 1 ] * idx <NEWLINE> f [ idx ] %= mod <NEWLINE> <DEDENT> fi = [ pow ( f [ - 1 ] , mod - 2 , mod ) ] <NEWLINE> for idx in range ( max_fact , 0 , - 1 ) : <NEWLINE> <INDENT> fi += [ fi [ - 1 ] * idx % mod ] <NEWLINE> <DEDENT> fi = fi [ : : - 1 ] <NEWLINE> <NL> def factorial ( self , n ) : <NEWLINE> <INDENT> return f [ n ] <NEWLINE> <NL> <DEDENT> def factorial_inverse ( self , n ) : <NEWLINE> <INDENT> return fi [ n ] <NEWLINE> <NL> <DEDENT> def combination ( self , n , r ) : <NEWLINE> <INDENT> return f [ n ] * fi [ r ] * fi [ n - r ] % mod <NEWLINE> <NL> <DEDENT> def permutation ( self , n , r ) : <NEWLINE> <INDENT> return f [ n ] * fi [ n - r ] % mod <NEWLINE> <NL> <DEDENT> def homogeneous_product ( self , n , r ) : <NEWLINE> <INDENT> return f [ n + r - 1 ] * fi [ r ] * fi [ n - 1 ] % mod <NEWLINE> <NL> <NL> <DEDENT> comb = combination <NEWLINE> perm = permutation <NEWLINE> <NL> N , M = [ int ( _ ) for _ in input ( ) . split ( ) ] <NEWLINE> ans = 0 <NEWLINE> for p in range ( N + 1 ) : <NEWLINE> <INDENT> ans += ( - 1 ) ** p * comb ( N , p ) * perm ( M - p , N - p ) <NEWLINE> ans %= mod <NEWLINE> <DEDENT> ans *= perm ( M , N ) <NEWLINE> ans %= mod <NEWLINE> print ( ans ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> mod = 10 ** 9 + 7 <NEWLINE> <NL> fact = [ 1 ] <NEWLINE> for i in range ( 1 , 5 * 10 ** 5 + 1 ) : <NEWLINE> <INDENT> fact . append ( ( fact [ - 1 ] * i ) % mod ) <NEWLINE> <NL> <DEDENT> revfact = [ 1 ] <NEWLINE> for i in range ( 1 , 5 * 10 ** 5 + 1 ) : <NEWLINE> <INDENT> revfact . append ( pow ( fact [ i ] , mod - 2 , mod ) ) <NEWLINE> <NL> <DEDENT> A = ( fact [ m ] * revfact [ n ] * revfact [ m - n ] * fact [ n ] ) % mod <NEWLINE> B = 0 <NEWLINE> for i in range ( n + 1 ) : <NEWLINE> <INDENT> tmp = ( fact [ n ] * revfact [ i ] * revfact [ n - i ] ) * ( fact [ m - i ] * revfact [ n - i ] * revfact [ m - n ] ) * fact [ n - i ] <NEWLINE> if i % 2 == 0 : <NEWLINE> <INDENT> B += tmp <NEWLINE> B %= mod <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> B -= tmp <NEWLINE> B %= mod <NEWLINE> <DEDENT> <DEDENT> print ( ( A * B ) % mod ) <NEWLINE>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> sys . setrecursionlimit ( 10 ** 8 ) <NEWLINE> from itertools import accumulate <NEWLINE> from itertools import permutations <NEWLINE> from itertools import combinations <NEWLINE> from collections import defaultdict <NEWLINE> from collections import Counter <NEWLINE> import fractions <NEWLINE> import math <NEWLINE> from collections import deque <NEWLINE> from bisect import bisect_left <NEWLINE> from bisect import bisect_right <NEWLINE> from bisect import insort_left <NEWLINE> import itertools <NEWLINE> from heapq import heapify <NEWLINE> from heapq import heappop <NEWLINE> from heapq import heappush <NEWLINE> import heapq <NEWLINE> from copy import deepcopy <NEWLINE> from decimal import Decimal <NEWLINE> alf = list ( <STRING> ) <NEWLINE> ALF = list ( <STRING> ) <NEWLINE> <COMMENT> <NL> INF = float ( <STRING> ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> fac = [ 1 , 1 ] <NEWLINE> inv = [ 0 , 1 ] <NEWLINE> finv = [ 1 , 1 ] <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> fac = [ 1 , 1 ] <NEWLINE> inv = [ 0 , 1 ] <NEWLINE> finv = [ 1 , 1 ] <NEWLINE> for i in range ( 2 , M + 1 ) : <NEWLINE> <INDENT> fac . append ( fac [ - 1 ] * i % MOD ) <NEWLINE> inv . append ( MOD - inv [ MOD % i ] * ( MOD // i ) % MOD ) <NEWLINE> finv . append ( finv [ - 1 ] * inv [ - 1 ] % MOD ) <NEWLINE> <DEDENT> def comb_mod ( n , r , m ) : <COMMENT> <NEWLINE> <INDENT> if ( n < 0 or r < 0 or n < r ) : return 0 <NEWLINE> r = min ( r , n - r ) <NEWLINE> return fac [ n ] * finv [ n - r ] * finv [ r ] % m <NEWLINE> <NL> <DEDENT> def chofuku ( n , r ) : <COMMENT> <NEWLINE> <INDENT> return comb_mod ( n + r - 1 , r ) <NEWLINE> <NL> <DEDENT> def narabekae ( n , r , m ) : <COMMENT> <NEWLINE> <INDENT> return fac [ n ] * finv [ n - r ] % m <NEWLINE> <DEDENT> ans = 0 <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> if i % 2 == 1 : <NEWLINE> <INDENT> flag = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> flag = - 1 <NEWLINE> <DEDENT> s = flag * comb_mod ( N , i , MOD ) * nPr ( M - i , N - i , MOD ) <NEWLINE> ans += s <NEWLINE> if ans > MOD : <NEWLINE> <INDENT> ans %= MOD <NEWLINE> <DEDENT> <DEDENT> ans1 = 1 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> ans1 *= ( M - i ) <NEWLINE> ans1 %= MOD <NEWLINE> <DEDENT> ans2 = ( ans1 * ans1 ) % MOD <NEWLINE> ans3 = ( ans * nPr ( M , N , MOD ) ) % MOD <NEWLINE> print ( ( ans2 - ans3 ) % MOD ) <NEWLINE>
<COMMENT> <NL> def main ( ) : <NEWLINE> <INDENT> import sys <NEWLINE> imput = sys . stdin . readline <NEWLINE> if sys . argv [ - 1 ] == <STRING> : <NEWLINE> import numba <NEWLINE> from numba . pycc import CC <NEWLINE> i8 = numba . int64 <NEWLINE> cc = CC ( <STRING> ) <NEWLINE> <NL> def cc_export ( f , signature ) : <NEWLINE> <INDENT> cc . export ( f . __name__ , signature ) ( f ) <NEWLINE> return numba . njit ( f ) <NEWLINE> <NL> <DEDENT> fact_table = cc_export ( fact_table , ( i8 , i8 ) ) <NEWLINE> main = cc_export ( main , ( i8 , i8 , i8 ) ) <NEWLINE> cc . compile ( ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <COMMENT> <NL> mod = pow ( 10 , 9 ) + 7 <NEWLINE> <NL> n_ = 5 * pow ( 10 , 5 ) + 5 <NEWLINE> fun = [ 1 ] * ( n_ + 1 ) <NEWLINE> for i in range ( 1 , n_ + 1 ) : <NEWLINE> <INDENT> fun [ i ] = fun [ i - 1 ] * i % mod <NEWLINE> <DEDENT> rev = [ 1 ] * ( n_ + 1 ) <NEWLINE> rev [ n_ ] = pow ( fun [ n_ ] , mod - 2 , mod ) <NEWLINE> for i in range ( n_ - 1 , 0 , - 1 ) : <NEWLINE> <INDENT> rev [ i ] = rev [ i + 1 ] * ( i + 1 ) % mod <NEWLINE> <DEDENT> def cmb ( n , r ) : <NEWLINE> <INDENT> if n < 0 or r < 0 or r > n : return 0 <NEWLINE> return fun [ n ] * rev [ r ] % mod * rev [ n - r ] % mod <NEWLINE> <DEDENT> def perm ( n , r ) : <NEWLINE> <INDENT> if n < 0 or r < 0 or r > n : return 0 <NEWLINE> return fun [ n ] * rev [ n - r ] % mod <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> import math <NEWLINE> answer = 0 <NEWLINE> for i in range ( n + 1 ) : <NEWLINE> <INDENT> temp = perm ( n , i ) * cmb ( m , i ) * pow ( perm ( m - i , n - i ) , 2 ) <NEWLINE> temp %= mod <NEWLINE> if i % 2 == 0 : <NEWLINE> <INDENT> answer += temp <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> answer -= temp <NEWLINE> <DEDENT> <DEDENT> print ( answer % mod ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> <NL> def solve ( ls ) : <NEWLINE> <INDENT> import math <NEWLINE> <NL> x , y , * ls = ls <NEWLINE> z = x + y <NEWLINE> s = 0 <NEWLINE> for a in ls : <NEWLINE> <INDENT> s ^= a <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> if ( z - s ) < 0 or ( z - s ) % 2 == 1 : <NEWLINE> <INDENT> return - 1 <NEWLINE> <NL> <DEDENT> t = ( z - s ) // 2 <NEWLINE> s_t = s & t <NEWLINE> <NL> if s_t > 0 or t > x : <NEWLINE> <INDENT> return - 1 <NEWLINE> <NL> <DEDENT> a = t <NEWLINE> b = t <NEWLINE> first_set = math . floor ( math . log2 ( s ) ) <NEWLINE> for i in range ( first_set + 1 ) [ : : - 1 ] : <NEWLINE> <INDENT> k = 1 << i <NEWLINE> if s & k : <NEWLINE> <INDENT> if ( a | k ) <= x : <COMMENT> <NEWLINE> <INDENT> a = a | k <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> b = b | k <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return x - a <NEWLINE> <NL> <NL> <DEDENT> def main ( istr , ostr ) : <NEWLINE> <INDENT> n = int ( istr . readline ( ) . strip ( ) ) <NEWLINE> ls = list ( map ( int , istr . readline ( ) . strip ( ) . split ( ) ) ) <NEWLINE> result = solve ( ls ) <NEWLINE> print ( result , file = ostr ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> import sys <NEWLINE> <NL> main ( sys . stdin , sys . stdout ) <NEWLINE> <DEDENT>
a = str ( input ( ) ) <NEWLINE> <NL> if a . islower ( ) == True : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( A ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> s = <STRING> <NEWLINE> while n > 0 : n -= 1 ; s += chr ( 97 + n % 26 ) ; n //= 26 <NEWLINE> print ( s [ : : - 1 ] ) <NEWLINE>
alpha = str ( input ( ) ) <NEWLINE> if str . isupper ( alpha ) = True : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import sys <NEWLINE> import math <NEWLINE> import collections <NEWLINE> <NL> def set_debug ( debug_mode = False ) : <NEWLINE> <INDENT> if debug_mode : <NEWLINE> <INDENT> fin = open ( <STRING> , <STRING> ) <NEWLINE> sys . stdin = fin <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def int_input ( ) : <NEWLINE> <INDENT> return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <COMMENT> <NL> <NL> <INDENT> t = input ( ) <NEWLINE> <NL> if t . is_upper ( ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> if N == N . upper ( ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
α = ( input ( ) ) <NEWLINE> if α = <STRING> or <STRING> or <STRING> or <STRING> or <STRING> or <STRING> or <STRING> or <STRING> or <STRING> or <STRING> or <STRING> or <STRING> or <STRING> or <STRING> or <STRING> or <STRING> or <STRING> or <STRING> or <STRING> or <STRING> or <STRING> or <STRING> or <STRING> or <STRING> or <STRING> or <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import sys <NEWLINE> print ( <STRING> ) if str . isupper ( sys . argv [ 1 ] ) else print ( <STRING> ) <NEWLINE>
s = input ( ) <NEWLINE> if s . lowercase ( ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> int main ( ) { <NEWLINE> <INDENT> char a ; <NEWLINE> scanf ( <STRING> , & a ) ; <NEWLINE> if ( isupper ( a ) == 0 ) { <NEWLINE> <INDENT> printf ( <STRING> ) ; <NEWLINE> <DEDENT> } else { <NEWLINE> <INDENT> printf ( <STRING> ) ; <NEWLINE> <DEDENT> } <NEWLINE> return 0 ; <NEWLINE> <DEDENT> } <NEWLINE>
a = str . input ( ) <NEWLINE> if a . isupper : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> from math import floor , ceil , sqrt , factorial , log , gcd <NEWLINE> from heapq import heappop , heappush , heappushpop <NEWLINE> from collections import Counter , defaultdict , deque <NEWLINE> from itertools import accumulate , permutations , combinations , product , combinations_with_replacement <NEWLINE> from bisect import bisect_left , bisect_right <NEWLINE> from copy import deepcopy <NEWLINE> from operator import itemgetter <NEWLINE> from fractions import gcd <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> inf = float ( <STRING> ) <NEWLINE> ninf = - float ( <STRING> ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> import numpy as np <NEWLINE> from scipy . sparse . csgraph import shortest_path , floyd_warshall , dijkstra , bellman_ford , johnson <NEWLINE> from scipy . sparse import csr_matrix <NEWLINE> <NL> <NL> <COMMENT> <NL> def ii ( ) : return int ( sys . stdin . readline ( ) . rstrip ( ) ) <COMMENT> <NEWLINE> def mii ( ) : return map ( int , sys . stdin . readline ( ) . rstrip ( ) . split ( ) ) <NEWLINE> def limii ( ) : return list ( mii ( ) ) <COMMENT> <NEWLINE> def lin ( n : int ) : return [ ii ( ) for _ in range ( n ) ] <NEWLINE> def llint ( n : int ) : return [ limii ( ) for _ in range ( n ) ] <NEWLINE> <COMMENT> <NL> def ss ( ) : return sys . stdin . readline ( ) . rstrip ( ) <COMMENT> <NEWLINE> def mss ( ) : return sys . stdin . readline ( ) . rstrip ( ) . split ( ) <NEWLINE> def limss ( ) : return list ( mss ( ) ) <COMMENT> <NEWLINE> def lst ( n : int ) : return [ ss ( ) for _ in range ( n ) ] <NEWLINE> def llstr ( n : int ) : return [ limss ( ) for _ in range ( n ) ] <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> a = ii ( ) <NEWLINE> <NL> if 65 <= ord ( a ) <= 90 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
lpha = input ( ) <NEWLINE> cap = [ <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> if ( alpha in cap ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
from sys import stdin <NEWLINE> <NL> str = stdin . readline ( ) . rstrip ( ) <NEWLINE> <NL> if str . islower ( ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> from sys import stdin <NEWLINE> <NL> <DEDENT> str = stdin . readline ( ) . rstrip ( ) <NEWLINE> <NL> if str . islower ( ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> <NEWLINE> <DEDENT>
TN = input ( ) <NEWLINE> list = [ a , b , c , d , e , f , g , h , i , j , k , l , m , n , o , p , q , r , s , t , u , v , w , x , y , z ] <NEWLINE> if TN not in list : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a = input ( ) <NEWLINE> if a . str . isupper ( ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
def freq ( my_list ) : <NEWLINE> <INDENT> count = { } <NEWLINE> for i in my_list : <NEWLINE> <INDENT> count [ i ] = count . get ( i , 0 ) + 1 <NEWLINE> <DEDENT> return count <NEWLINE> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> s , f = sum ( l ) , freq ( l ) <NEWLINE> for _ in range ( int ( input ( ) ) ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> if x in f : <NEWLINE> <INDENT> v = f [ x ] <NEWLINE> if y in f : <NEWLINE> <INDENT> f [ y ] += v <NEWLINE> f . pop ( x ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> f [ y ] = f . pop ( x ) <NEWLINE> <DEDENT> s += ( y - x ) * v <NEWLINE> <DEDENT> print ( s ) <NEWLINE> <DEDENT>
α = int ( input ( ) ) <NEWLINE> if α . isupper ( ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> x = ord ( s [ 0 ] ) <NEWLINE> if x >= 65 and x <= 90 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else if x >= 97 and x <= 122 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = input ( ) <NEWLINE> <NL> if N . isupper ( ) == true : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a = str ( input ( ) ) <NEWLINE> if a . isupper ( ) == True : <NEWLINE> <INDENT> print ( A ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> using namespace std ; <NEWLINE> <NL> int main ( ) <NEWLINE> { <NEWLINE> <INDENT> char a ; <NEWLINE> cin >> a ; <NEWLINE> if ( isupper ( a ) ) cout << <STRING> ; <NEWLINE> else <NEWLINE> <INDENT> cout << <STRING> ; <NEWLINE> <DEDENT> <DEDENT> } <NEWLINE>
a = input ( ) <NEWLINE> <NL> if a . isupper ( ) : <NEWLINE> <INDENT> print ( A ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> if s . isupper ( ) { <NEWLINE> <INDENT> print ( <STRING> ) } else { <NEWLINE> print ( <STRING> ) } <NEWLINE> <DEDENT>
a = str ( input ( ) ) <NEWLINE> oomoji = [ <STRING> ] <NEWLINE> komoji = [ <STRING> ] <NEWLINE> <NL> if a . isupper ( ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> a ) <NEWLINE> <DEDENT>
if input ( ) islower ( ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
if a . isupper ( ) == True : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
if input ( ) . issuper ( ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
IN = input ( ) <NEWLINE> if IN . isupper ( ) : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT>
D = input ( ) <NEWLINE> <INDENT> if D . isupper ( ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
a = input ( ) <NEWLINE> if a . isupper ( ) = True : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> print ( <STRING> if s = s . lower ( ) else <STRING> ) <NEWLINE>
c = input ( ) <NEWLINE> print ( <STRING> if ord ( <STRING> ) <= ord ( A ) <= ord ( <STRING> ) else <STRING> ) <NEWLINE>
alp = str ( input ( ) ) <NEWLINE> print <STRING> if alp . isupper ( ) == True else print <STRING> <NEWLINE>
x = intput ( ) <NEWLINE> if <STRING> <= x <= <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
Print ( <STRING> if str . isupper ( input ( ) ) else <STRING> ) <NEWLINE>
a = input ( ) <NEWLINE> if a . isUpper ( ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a = input ( ) <NEWLINE> print ( <STRING> ) if c . isupper ( ) is True else print ( <STRING> ) <NEWLINE>
if input ( ) . isUpper ( ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> a = int ( input ( ) ) <NEWLINE> print ( a ) <NEWLINE>
X = int ( input ( ) ) <NEWLINE> <NL> if X == X . lower ( ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <NL> <DEDENT>
a = input ( ) <NEWLINE> if ord ( a ) >= <STRING> and ord ( a ) <= <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a = int ( input ( ) ) <NEWLINE> <NL> if a . islower ( ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> n = input ( ) <NEWLINE> a = ord ( n ) <NEWLINE> if a > 96 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <NL> <DEDENT>
al = str ( input ( ) ) <NEWLINE> if al . isupper ( ) = true : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
x = input ( ) <NEWLINE> <NL> if s . is_super : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
print ( <STRING> [ isupper ( input ( ) [ 0 ] ) ] ) <NEWLINE>
val = input ( ) <NEWLINE> if val in <STRING> : <NEWLINE> <INDENT> ans = a <NEWLINE> <DEDENT> else <NEWLINE> <INDENT> ans = A <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
a = input ( ) <NEWLINE> if a == a . upeer ( ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a = input ( ) <NEWLINE> <NL> if ( s . islower ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
if input ( ) . upper ( ) == input ( ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> eList = [ <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> n = N <NEWLINE> mod = N <NEWLINE> numList = [ ] <NEWLINE> <NL> while n > 0 : <NEWLINE> <INDENT> n , mod = divmod ( n , 26 ) <NEWLINE> if mod != 0 : <NEWLINE> <INDENT> numList . insert ( 0 , mod - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> numList . insert ( 0 , 25 ) <NEWLINE> n -= 1 <NEWLINE> <DEDENT> <DEDENT> for num in numList : <NEWLINE> <INDENT> ans += eList [ num ] <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
x = str ( input ( ) ) <NEWLINE> if x . isupper ( ) == True : <NEWLINE> <INDENT> print ( A ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <DEDENT>
a = input ( ) <NEWLINE> <NL> if True == a . isupper ( ) : <NEWLINE> <INDENT> Print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
alph = input ( ) <NEWLINE> TF = alph . islower ( ) <NEWLINE> if TF == true : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
x = input ( ) <NEWLINE> <NL> ans = x . islower ( ) <NEWLINE> <NL> <COMMENT> <NL> if ans == false : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
x = input ( ) <NEWLINE> if x . isUpper ( ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
x = input ( ) <NEWLINE> if x . isupper ( ) is True : <NEWLINE> <INDENT> print ( A ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <DEDENT>
<INDENT> a = input ( ) <NEWLINE> <DEDENT> print ( <STRING> if a . isupper ( ) else <STRING> ) <NEWLINE>
import sys <NEWLINE> import math <NEWLINE> def II ( ) : <NEWLINE> <INDENT> return int ( sys . stdin . readline ( ) ) <NEWLINE> <NL> <DEDENT> def LI ( ) : <NEWLINE> <INDENT> return list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) <NEWLINE> <NL> <DEDENT> def MI ( ) : <NEWLINE> <INDENT> return map ( int , sys . stdin . readline ( ) . split ( ) ) <NEWLINE> <NL> <DEDENT> def SI ( ) : <NEWLINE> <INDENT> return sys . stdin . readline ( ) . strip ( ) <NEWLINE> <DEDENT> s = SI ( ) <NEWLINE> if s . isLower ( ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> D = input ( ) <NEWLINE> <NL> if str . isupper ( D ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
N = input ( ) <NEWLINE> for i in range ( 65 , 90 ) : <NEWLINE> <INDENT> if i == ord ( N ) : <NEWLINE> <INDENT> A += 1 <NEWLINE> <DEDENT> <DEDENT> for i in range ( 97 , 123 ) : <NEWLINE> <INDENT> if i == ord ( N ) : <NEWLINE> <INDENT> a += 1 <NEWLINE> <DEDENT> <DEDENT> if A == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> if a == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a = input ( ) <NEWLINE> <NL> if ( isupper ( a ) ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
{ <NEWLINE> <INDENT> <STRING> : [ <NEWLINE> <INDENT> { <NEWLINE> <INDENT> <STRING> : <STRING> , <NEWLINE> <STRING> : 6 , <NEWLINE> <STRING> : { } , <NEWLINE> <STRING> : [ <NEWLINE> <INDENT> { <NEWLINE> <INDENT> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : [ <NEWLINE> <INDENT> <STRING> , <NEWLINE> <STRING> <NEWLINE> <DEDENT> ] <NEWLINE> <DEDENT> } <NEWLINE> <DEDENT> ] , <NEWLINE> <STRING> : [ <NEWLINE> <INDENT> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> <NEWLINE> <DEDENT> ] <NEWLINE> <DEDENT> } , <NEWLINE> { <NEWLINE> <INDENT> <STRING> : <STRING> , <NEWLINE> <STRING> : null , <NEWLINE> <STRING> : { } , <NEWLINE> <STRING> : [ ] , <NEWLINE> <STRING> : [ ] <NEWLINE> <DEDENT> } , <NEWLINE> { <NEWLINE> <INDENT> <STRING> : <STRING> , <NEWLINE> <STRING> : null , <NEWLINE> <STRING> : { } , <NEWLINE> <STRING> : [ ] , <NEWLINE> <STRING> : [ ] <NEWLINE> <DEDENT> } <NEWLINE> <DEDENT> ] , <NEWLINE> <STRING> : { <NEWLINE> <INDENT> <STRING> : { <NEWLINE> <INDENT> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> <NEWLINE> <DEDENT> } , <NEWLINE> <STRING> : { <NEWLINE> <INDENT> <STRING> : { <NEWLINE> <INDENT> <STRING> : <STRING> , <NEWLINE> <STRING> : 3 <NEWLINE> <DEDENT> } , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> <NEWLINE> <DEDENT> } <NEWLINE> <DEDENT> } , <NEWLINE> <STRING> : 4 , <NEWLINE> <STRING> : 4 <NEWLINE> <DEDENT> } <NEWLINE>
in = input ( ) <NEWLINE> <NL> if in . isupper ( ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> input_list = sys . stdin . readlines ( ) <NEWLINE> <NL> count = 1 <NEWLINE> get_count = 0 <NEWLINE> get_value_count = 0 <NEWLINE> for i in input_list : <NEWLINE> <INDENT> get_values = i . split ( ) <NEWLINE> if count == 1 : <NEWLINE> <INDENT> get_value_count = int ( get_values [ 0 ] ) <NEWLINE> get_count = int ( get_values [ 1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if get_value_count == 1 : <NEWLINE> <INDENT> print ( get_values [ 0 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> get_values . sort ( ) <NEWLINE> count_value = 1 <NEWLINE> p = 0 <NEWLINE> for c in get_values : <NEWLINE> <INDENT> if count_value > get_count : <NEWLINE> <INDENT> print ( str ( p ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> p = p + int ( c ) <NEWLINE> <DEDENT> count_value = count_value + 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> count = count + 1 <NEWLINE> <DEDENT>
f = str ( input ( ) ) <NEWLINE> if f . islower == True : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( A ) <NEWLINE> <DEDENT>
print ( <STRING> if s . islower ( ) else <STRING> ) <NEWLINE>
N , K = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> P = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> def bubblesort ( l ) : <NEWLINE> <INDENT> for index in range ( len ( l ) - 1 , 0 , - 1 ) : <NEWLINE> <INDENT> for low in range ( index ) : <NEWLINE> <INDENT> if l [ low ] > l [ low + 1 ] : <NEWLINE> <INDENT> tmp = l [ low + 1 ] <NEWLINE> l [ low + 1 ] = l [ low ] <NEWLINE> l [ low ] = tmp <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return l <NEWLINE> <NL> <DEDENT> bubblesort ( P ) <NEWLINE> sum = 0 <NEWLINE> for i in range ( K ) : <NEWLINE> <INDENT> sum = sum + P [ i ] <NEWLINE> <DEDENT> print ( sum ) <NEWLINE>
N = input ( ) <NEWLINE> A = [ A , B , C , D , E , F , G , H , I , J , K , L , M , N , O , P , Q , R , S , T , U , V , W , X , Y , Z ] <NEWLINE> if N in A : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
S = input ( ) <NEWLINE> if ( S . isupper ( ) ) : <NEWLINE> <INDENT> printf ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> printf ( <STRING> ) <NEWLINE> <DEDENT>
L = set ( <STRING> , <STRING> ) <NEWLINE> print ( L ) <NEWLINE>
a = input ( ) <NEWLINE> if a >= <STRING> & & a <= <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> if a >= <STRING> & & a <= <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> <NL> if s in [ <STRING> ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif s in [ <STRING> ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE>
print ( <STRING> [ int ( ord ( input ( ) ) > 95 ) ) <NEWLINE>
letter = input ( ) <NEWLINE> <NL> if letter . isUpper ( ) == True : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a = input ( ) <NEWLINE> s = int ( ord ( a ) <NEWLINE> <NL> if 65 <= s and s <= 90 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif 97 <= s and s <= 122 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a = inputs ( ) <NEWLINE> if a . isupper ( ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a = input ( ) <NEWLINE> if ord ( a ) < ord ( <STRING> ) : <NEWLINE> <INDENT> print ( A ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> import sys <NEWLINE> <NL> s2nn = lambda s : [ int ( c ) for c in s . split ( <STRING> ) ] <NEWLINE> ss2nn = lambda ss : [ int ( s ) for s in list ( ss ) ] <NEWLINE> ss2nnn = lambda ss : [ s2nn ( s ) for s in list ( ss ) ] <NEWLINE> i2s = lambda : sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> i2n = lambda : int ( i2s ( ) ) <NEWLINE> i2nn = lambda : s2nn ( i2s ( ) ) <NEWLINE> ii2ss = lambda n : [ i2s ( ) for _ in range ( n ) ] <NEWLINE> ii2nn = lambda n : ss2nn ( ii2ss ( n ) ) <NEWLINE> ii2nnn = lambda n : ss2nnn ( ii2ss ( n ) ) <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> a = i2s <NEWLINE> print ( <STRING> if a . isupper ( ) else <STRING> ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE>
alpha = input ( ) <NEWLINE> if alpha . isupper ( ) == True : <NEWLINE> <INDENT> print ( aplha . lower ( ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( alpha . upper ( ) ) <NEWLINE> <DEDENT>
def func ( x ) : <NEWLINE> <INDENT> if ord ( x ) - ord ( <STRING> ) >= 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <INDENT> letter = raw_input ( ) <NEWLINE> func ( letter ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
a = input ( ) <NEWLINE> ans = upper ( a ) <NEWLINE> if a == ans : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import re <NEWLINE> if len ( re . finall ( <STRING> , input ( ) ) == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
c = input ( ) <NEWLINE> if c = c . lower ( ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT>
import re <NEWLINE> <NL> a = input ( ) <NEWLINE> if re . match ( <STRING> , a ) is not None : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT>
s = str ( input ( ) ) <NEWLINE> if s . isupper ( ) = True : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
x = input ( ) <NEWLINE> print ( <STRING> ) if isupper ( x ) else print ( <STRING> ) <NEWLINE>
a = input ( ) <NEWLINE> if a = a . upper ( ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a = input ( ) <NEWLINE> if a . isupper ( ) : <NEWLINE> <INDENT> print ( A ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <DEDENT>
alf = input ( ) <NEWLINE> if alf . islower ( ) : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( A ) <NEWLINE> <DEDENT>
α = int ( input ( ) ) <NEWLINE> <NL> if α == α . upper ( ) : <NEWLINE> <INDENT> return print ( <STRING> ) <NEWLINE> <DEDENT> elif α == α . lower ( ) : <NEWLINE> <INDENT> return print ( <STRING> ) <NEWLINE> <DEDENT>
data_a = [ ABCDEFGHIJKLMNOPQRSTUVWXYZ ] <NEWLINE> data_b = [ abcdefghijklmnopqrstuvwxyz ] <NEWLINE> <NL> n = input ( ) <NEWLINE> <NL> if n in data_a : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
if ( input ( ) . isupper ( ) ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else if ( input ( ) . islower ( ) ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
<NL> def test ( a ) : <NEWLINE> <INDENT> if tmp . isupper ( ) : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> test ( input ( ) ) <NEWLINE>
c = input ( ) <NEWLINE> if <STRING> <= c & & c <= <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
ch = input ( ) <NEWLINE> if ch == a or ch == b or ch == c or ch == d or ch == e or ch == f or ch == g or ch == h : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <DEDENT> elif ch == i or ch == j or ch == k or ch == l or ch == m or ch == n or ch == o : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <DEDENT> elif ch == p or ch == q or ch == r or ch == s or ch == t or ch == u or ch == v : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <DEDENT> elif ch == w or ch == x or ch == y or ch == z : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <DEDENT> else <NEWLINE> <INDENT> print ( b ) <NEWLINE> <DEDENT>
IN = input ( ) <NEWLINE> if str . isupper ( IN ) : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT>
alpha = input ( ) <NEWLINE> <NL> upper = [ A , B , C , D , E , F , G , H , I , J , K , L , M , N , O , P , Q , R , S , T , U , V , W , X , Y , Z ] <NEWLINE> lower = [ a , b , c , d , e , f , g , h , i , j , k , l , m , n , o , p , q , r , s , t , u , v , w , x , y , z ] <NEWLINE> <NL> if alpha in upper : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = input ( ) <NEWLINE> <NL> s = abcdefghijklmnopqrstuvwxyz <NEWLINE> <NL> if n in s : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
m = input ( ) <NEWLINE> x = ord ( m ) <NEWLINE> if x >= 97 and x <= 122 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> <NEWLINE> <DEDENT>
a = input ( ) <NEWLINE> if a . ispper ( ) == True : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
A = input ( ) <NEWLINE> print ( <STRING> ) if A . issuper ( ) else print ( <STRING> ) <NEWLINE>
alpga = input ( ) <NEWLINE> if alpha == isupper ( ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = input ( ) <NEWLINE> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <NL> <STRING> <NEWLINE> <NL> if N . isupper ( ) : <NEWLINE> <INDENT> print ( A ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( B ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a_list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> <NL> for i in range ( q ) : <NEWLINE> <INDENT> b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> newlist = a_list <NEWLINE> for j in range ( n ) : <NEWLINE> <INDENT> if newlist [ j ] == b : <NEWLINE> <INDENT> newlist [ j ] = c <NEWLINE> ans = sum ( newlist ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
imports sys <NEWLINE> <NL> c = sys . stdin . readline ( ) <NEWLINE> <NL> if ord ( c ) >= <STRING> and ord ( c ) <= <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a = int ( input ( ) ) <NEWLINE> <NL> print ( <STRING> if ( a . isupper ) else <STRING> ) <NEWLINE>
n = input ( ) <NEWLINE> if n . isuper ( ) == true : <NEWLINE> <INDENT> print ( n . lower ( ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( n . upper ( ) ) <NEWLINE> <DEDENT>
alpha = input ( ) <NEWLINE> if alpha . isupper ( ) : <NEWLINE> <INDENT> output = A <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> output = a <NEWLINE> <NL> <DEDENT> print ( output ) <NEWLINE>
a = input ( ) <NEWLINE> if a in <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
str alpha = input ( ) <NEWLINE> if ( alpha . isupper ( ) ) { <NEWLINE> <INDENT> print ( A ) <NEWLINE> <DEDENT> } else { <NEWLINE> <INDENT> print ( a ) <NEWLINE> <DEDENT> } <NEWLINE>
a = str ( input ( ) ) <NEWLINE> <NL> if str . isupper ( ) == True : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT>
a = input ( ) <NEWLINE> <NL> if a . isupper ( ) == True : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a . islower ( ) == True : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> a = int ( input ( ) ) <NEWLINE> <NL> if a . islower : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a . upper : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
chr = input ( ) <NEWLINE> <NL> print ord ( chr ) <NEWLINE>
a = str ( input ( ) ) <NEWLINE> if a = str . isupper ( ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
<COMMENT> <NL> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> b = [ ] <NEWLINE> c = [ ] <NEWLINE> <NL> bc = [ map ( int , input ( ) . split ( ) ) for _ in range ( q ) ] <NEWLINE> b , c = [ list ( i ) for i in zip ( * bc ) ] <NEWLINE> <NL> dic = { } <NEWLINE> for aa in a : <NEWLINE> <INDENT> dic [ aa ] = dic . get ( aa , 0 ) + 1 <NEWLINE> <NL> <DEDENT> s = sum ( a ) <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> if b [ i ] not in dic : <NEWLINE> <INDENT> print ( str ( s ) ) <NEWLINE> continue <NEWLINE> <DEDENT> s += ( c [ i ] - b [ i ] ) * dic [ b [ i ] ] <NEWLINE> dic [ c [ i ] ] = dic . get ( c [ i ] , 0 ) + dic [ b [ i ] ] <NEWLINE> del dic [ b [ i ] ] <NEWLINE> print ( s ) <NEWLINE> <DEDENT>
a = input ( ) <NEWLINE> big = range ( <STRING> , <STRING> ) <NEWLINE> <NL> if big . include ( a ) : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT>
a = str ( input ( ) ) <NEWLINE> if a . islower ( ) == True : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( A ) <NEWLINE> <DEDENT>
a = str ( input ( ) ) <NEWLINE> if a = ( <STRING> - <STRING> ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a = ( <STRING> - <STRING> ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a = input ( ) <NEWLINE> <NL> if a . isUpper ( ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> ans = <STRING> s . isupper ( ) else <STRING> <NEWLINE> print ( ans ) <NEWLINE> <NL> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
A = [ ord ( i ) for i in range ( chr ( a ) , chr ( z ) + 1 ) ] <NEWLINE> a = input ( ) <NEWLINE> if a in A : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
if α . isupper ( ) = True : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a = input ( ) <NEWLINE> if 0 <= ord ( a ) - ord ( <STRING> ) <= 26 : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> if 0 <= ord ( a ) - ord ( <STRING> ) <= 26 : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT>
x = input ( ) <NEWLINE> <NL> if x . islower ( ) : <NEWLINE> <INDENT> an = x . upper ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> an = x . lower ( ) <NEWLINE> <NL> print ( an ) <NEWLINE> <DEDENT>
a = input ( ) <NEWLINE> li = [ q , w , e , r , t , y , u , i , o , p , a , s , d , f , g , h , j , k , l , z , x , c , v , b , n , m ] <NEWLINE> if a in li : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> if s . isuper ( ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
if input ( ) in <STRING> : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> x = input ( ) <NEWLINE> print ( <STRING> if ord ( x ) < 97 else <STRING> ) <NEWLINE>
A = input ( ) <NEWLINE> <NL> B = A . Upper ( ) <NEWLINE> <NL> if A == B : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import re <NEWLINE> import sys <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> args = sys . argv <NEWLINE> alpha = args [ 1 ] <NEWLINE> <NL> if ( re . compile ( <STRING> ) . search ( alpha ) ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> print ( ord_s . swapcase ) <NEWLINE>
s = raw_input ( ) <NEWLINE> if s . islower ( ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <NL> <NL> <DEDENT>
print ( α ) <NEWLINE>
x = input ( ) <NEWLINE> <NL> if <STRING> <= x and x <= <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = input ( ) <NEWLINE> if ( N . lower ( ) = N ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
α = input ( ) <NEWLINE> if str . isupper ( ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
alph = input ( ) <NEWLINE> if ( alpha . isupper ( ) ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
x = input ( ) <NEWLINE> if X . isupper ( ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
c = str ( input ( ) ) <NEWLINE> <NL> if c . lowercase ( ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> a = int ( input ( ) ) <NEWLINE> <COMMENT> <NL> b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> <COMMENT> <NL> s = input ( ) <NEWLINE> <COMMENT> <NL> print ( <STRING> . format ( a + b + c , s ) ) <NEWLINE>
s = input ( ) <NEWLINE> if 65 <= ord ( s ) <= 90 : <NEWLINE> <INDENT> print ( A ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <DEDENT>
if ( a . isupper ( ) == True ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> else : <NEWLINE> print ( <STRING> ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> if s . issupper == True : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> if s . isupps = input ( ) <NEWLINE> if s . isupper ( ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> if n . islower ( ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
c = input ( ) <NEWLINE> if ( c . isupper ( ) == True ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
letter = input ( ) <NEWLINE> <NL> if letter == letter . upper ( ) : <NEWLINE> <INDENT> print ( A ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( B ) <NEWLINE> <DEDENT>
if __name__ == <STRING> : <NEWLINE> <COMMENT> <NL> <INDENT> x = input ( ) <NEWLINE> if x == x . upper ( ) <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
a = input ( ) <NEWLINE> if a . upper ( ) == a <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> a = input ( ) <NEWLINE> <NL> if ord ( <STRING> ) <= ord ( a ) <= ord ( <STRING> ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> main ( ) <NEWLINE>
X = input ( ) <NEWLINE> if X . isupper ( ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE>
a = input ( <STRING> ) <NEWLINE> <NL> if a . isupper ( ) : dfdf <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> res = n % 26 <NEWLINE> <NL> A = [ <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <NEWLINE> <INDENT> <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> <NL> <DEDENT> ans = [ ] <NEWLINE> while n // 26 > 0 : <NEWLINE> <INDENT> res = n % 26 <NEWLINE> if res % 26 != 0 : <NEWLINE> <INDENT> ans . append ( A [ res - 1 ] ) <NEWLINE> <DEDENT> elif res % 26 == 0 : <NEWLINE> <INDENT> ans . append ( A [ 25 ] ) <NEWLINE> <DEDENT> n = n // 26 <NEWLINE> <NL> <DEDENT> if res != 0 : <NEWLINE> <INDENT> ans . append ( A [ res - 1 ] ) <NEWLINE> <DEDENT> elif res == 0 : <NEWLINE> <INDENT> ans . append ( A [ 25 ] ) <NEWLINE> <DEDENT> print ( * ans [ : : - 1 ] , sep = <STRING> ) <NEWLINE>
M = int ( input ( ) ) <NEWLINE> if M == M . upper ( ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a = input ( ) <NEWLINE> print ( <STRING> a . isupper ( ) else <STRING> ) <NEWLINE>
inpt = input ( ) <NEWLINE> cap = { Q , W , E , R , T , Y , U , I , O , P , A , S , D , F , G , H , J , K , L , Z , X , C , V , B , N , M } <NEWLINE> if inpt in cap : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
alpha = input ( ) <NEWLINE> <NL> if alpha in string . ascii_lowercase : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> alpha = [ <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> ans = <STRING> <NEWLINE> <NL> while N > 0 : <NEWLINE> <INDENT> N -= 1 <NEWLINE> index = N % 26 <NEWLINE> ans = alpha [ index ] + ans <NEWLINE> N = N // 26 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
a = input ( ) <NEWLINE> if a == type . lower ( ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a == type . upper ( ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a = input ( ) <NEWLINE> if a . islower ( ) : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( A ) <NEWLINE> <DEDENT>
alpha = input ( ) <NEWLINE> a = [ A , B , C , D , E , F , G , H , I , J , K , L , M , N , O , P , Q , R , S , T , U , V , W , X , Y , Z ] <NEWLINE> <NL> if alpha in a : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
str = str ( input ( ) ) <NEWLINE> if str . isupper ( ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> if ord ( <STRING> ) > 90 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a - input ( ) <NEWLINE> <NL> if a . islower ( ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
if input ( ) . isupper == true : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a = input ( α ) <NEWLINE> b = a . isupper ( ) <NEWLINE> print ( b ) <NEWLINE> if b == True : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
str = input ( ) <NEWLINE> if str . isupper ( ) == TRUE : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a = input ( ) <NEWLINE> if a . isupper ( ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
ch = input ( ) <NEWLINE> if ( ch >= <STRING> & & ch <= <STRING> ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> else : <NEWLINE> print ( <STRING> ) <NEWLINE> <DEDENT>
x = input ( ) <NEWLINE> <NL> if x in [ a , b , c , d , e , f , g , h , i , j , k , l , m , n , o , p , q , r , s , t , u , v , w , x , y , z ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a = int ( input ( ) ) <NEWLINE> if a . isupper ( ) = True : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = str ( input ( ) ) <NEWLINE> dai = [ Q , W , E , R , T , Y , U , I , O , P , A , S , D , F , G , H , J , K , L , Z , X , C , V , B , N , M ] <NEWLINE> syou = [ q , w , e , r , t , y , u , i , o , p , a , s , d , f , g , h , j , k , l , z , x , c , v , b , n , m ] <NEWLINE> if n in dai : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
x = str ( input ( ) ) <NEWLINE> <NL> if x . isupper ( ) = True : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N , K = input ( ) . split ( ) <NEWLINE> <NL> P = [ int ( p ) for p in input ( ) . split ( ) ] <NEWLINE> <NL> P . sort ( ) <NEWLINE> <NL> for q in range ( int ( K ) ) : <NEWLINE> <INDENT> X = X + int ( q ) <NEWLINE> <NL> <DEDENT> print ( X ) <NEWLINE>
num , select = map ( int , input ( ) ) <NEWLINE> l = list ( map ( int , input ( ) ) ) <NEWLINE> <NL> sum = 0 <NEWLINE> l = l . sort ( ) <NEWLINE> for i in l : <NEWLINE> <INDENT> sum += l [ i ] <NEWLINE> <NL> <DEDENT> print ( sum ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> p . sort ( ) <NEWLINE> print ( sum ( p [ 0 : K - 1 ] ) <NEWLINE>
n , k = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> l . sort ( ) <NEWLINE> s = 0 <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> s += l [ i ] <NEWLINE> <DEDENT> print ( s ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> p = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> p . sort ( ) <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> s += p [ i ] <NEWLINE> <DEDENT> print ( s ) <NEWLINE>
<COMMENT> <NL> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> p = sorted ( list ( map ( int , inout ( ) . split ( ) ) ) ) <NEWLINE> print ( sum ( p [ : k ] ) ) <NEWLINE>
N , K = int ( input ( ) . split ( ) ) <NEWLINE> juice = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> juice . append ( list ( input ( ) . split ( ) ) ) <NEWLINE> <DEDENT> juice . sort ( ) <NEWLINE> print ( sum ( juice [ 0 : K ] ) ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> arr = list ( map ( int , input ( ) . split ( ) ) <NEWLINE> arr . sort ( ) <NEWLINE> print ( sum ( arr [ : m ] ) ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> p = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> print ( sum [ : k ] ) <NEWLINE>
n , k = input ( ) . split ( ) <NEWLINE> print ( sum ( sorted ( [ int ( i ) for i in input ( ) . split ( ) ] ) [ : k ] ) ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) . sort ( ) <NEWLINE> print ( sum ( a [ : k ] ) ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> p = sorted ( [ int ( input ( ) ) for i in range ( n ) ] ) <NEWLINE> count = 0 <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> count = count + p [ i ] <NEWLINE> <DEDENT> print ( count ) <NEWLINE>
N , K = map ( N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> l = sorted ( l ) <NEWLINE> res = 0 <NEWLINE> for i in range ( K ) : <NEWLINE> <INDENT> res += l [ i ] <NEWLINE> <DEDENT> print ( res ) <NEWLINE>
n , k = map ( input ( ) . split ( ) ) <NEWLINE> p = list ( int , map ( input ( ) . split ( ) ) ) <NEWLINE> p . sort ( ) <NEWLINE> print ( sum ( p [ : k ] ) ) <NEWLINE>
n , k = map ( int , input ( ) . sprit ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . sprit ( ) ) ) <NEWLINE> a . sort ( ) <NEWLINE> b = 0 <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> b += a [ i ] <NEWLINE> <DEDENT> print ( b ) <NEWLINE>
nn , kk = map ( int , input . split ( ) ) <NEWLINE> num_value = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> num_value . sort ( ) <NEWLINE> gokei = 0 <NEWLINE> for i in range ( kk ) : <NEWLINE> <INDENT> gokei = gokei + num_value [ i ] <NEWLINE> <DEDENT> print ( gokei ) <NEWLINE> <NL>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> s = map ( int , input ( ) . split ( ) ) <NEWLINE> s . sort ( ) <NEWLINE> print ( sum ( s [ : k ] ) ) <NEWLINE>
n . k = map ( int , input ( ) . split ( ) ) <NEWLINE> lis = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> mi = min ( lis ) <NEWLINE> ans += mi <NEWLINE> lis . remove ( mi ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
_ , k = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( sum ( sorted ( list ( map ( int , input ( ) , split ( ) ) ) ) [ : k ] ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> K = int ( input ( ) ) <NEWLINE> value = [ ] <NEWLINE> sum = 0 <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> value . append ( int ( input ( ) ) ) <NEWLINE> <DEDENT> newValue = sorted ( value ) <NEWLINE> <NL> for j in range ( K ) : <NEWLINE> <INDENT> sum = sum + newValue [ j ] <NEWLINE> <NL> <DEDENT> print ( sum ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) <NEWLINE> p . sort ( ) <NEWLINE> s = sum ( p [ : k ] ) <NEWLINE> print ( s ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> fruit = list ( input ( ) . split ( ) ) <NEWLINE> price = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> price2 = sorted ( price ) <NEWLINE> i = 0 <NEWLINE> sum = 0 <NEWLINE> while ( i < K ) : <NEWLINE> <INDENT> sum += price2 [ i ] <NEWLINE> i += 1 <NEWLINE> <NL> <DEDENT> print ( sum ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> p . sort ( ) <NEWLINE> if len ( p ) >= 3 : <NEWLINE> <INDENT> print ( p [ 0 ] + p [ 1 ] + p [ 2 ] ) <NEWLINE> <DEDENT> else if len ( p ) == 2 : <NEWLINE> <INDENT> print ( p [ 0 ] + p [ 1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( p [ 0 ] ) <NEWLINE> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> p = sorted ( list ( map ( int , ipupt ( ) . split ( ) ) ) ) <NEWLINE> print ( sum ( p [ : k ] ) ) <NEWLINE>
import numpy as np <NEWLINE> n , k = list ( map ( int , input ( ) . rstrip ( ) . split ( ) ) ) <NEWLINE> p = list ( map ( int , input ( ) . rstrip ( ) . splist ( ) ) ) <NEWLINE> p = np . sort ( np . array ( p ) ) <NEWLINE> <NL> print ( np . sum ( p [ : k ] ) ) <NEWLINE>
import sys <NEWLINE> def order ( p ) : <NEWLINE> <INDENT> return ( sorted ( p ) ) <NEWLINE> <DEDENT> def Mix_Juice ( p ) : <NEWLINE> <INDENT> p [ 1 ] = K <NEWLINE> a = order ( p [ 2 : ] ) <NEWLINE> b = 0 <NEWLINE> for i in range ( 0 , K ) : <NEWLINE> <INDENT> b = b + a [ i ] <NEWLINE> <DEDENT> return b <NEWLINE> <DEDENT> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> Mix_Juice ( p ) <NEWLINE>
N , K = ( int ( i ) for i in input ( ) . split ( ) ) <NEWLINE> p = [ input ( ) . split ( ) ] <NEWLINE> <NL> sp = sorted ( p ) <NEWLINE> print ( sum ( sp [ : K ] ) ) <NEWLINE>
N , K = map ( int , input ( ) ) <NEWLINE> P = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> print ( sum ( P [ : K ] ) ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> p . sort ( ) <NEWLINE> price = 0 <NEWLINE> <NL> for p in range ( k ) : <NEWLINE> <INDENT> price += p [ k ] <NEWLINE> <NL> <DEDENT> print ( price ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> p = list [ ] <NEWLINE> ans = 0 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> p [ i ] = int ( input ( ) ) <NEWLINE> <NL> <DEDENT> p . sort ( ) <NEWLINE> <NL> for i in range ( k ) : <NEWLINE> <INDENT> ans += p [ i ] <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
m , k = map ( int , input ( . split ( ) ) ) <NEWLINE> array = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> array . sort ( ) <NEWLINE> print ( sum ( array [ : k ] ) ) <NEWLINE>
n , k = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> prices = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> prices = sorted ( prices ) <NEWLINE> <NL> print ( sum ( prices [ : k ] ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> print ( sum ( sorted ( p ) [ : K ] ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> p . sort ( ) <NEWLINE> print ( sum ( p [ : K ] ) <NEWLINE>
inputs = [ input ( ) for i in range ( 2 ) ] <NEWLINE> <NL> N = inputs [ 0 ] . split ( ) [ 0 ] <NEWLINE> K = inputs [ 0 ] . split ( ) [ 1 ] <NEWLINE> p = [ int ( pn ) for pn in inputs [ 1 ] . split ( ) ] <NEWLINE> <NL> ans = sum ( p . sort ( ) [ 0 : K ] ) <NEWLINE> print ( ans ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> plist = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> plist . sort ( ) <NEWLINE> ans = 0 <NEWLINE> for i in rangr ( k ) : <NEWLINE> <INDENT> ans += plist [ i ] <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> k = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> asr = sorted ( a ) <NEWLINE> del asr [ 0 : n - k ] <NEWLINE> ans = sum ( asr ) <NEWLINE> print ( str ( ans ) ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> p = sorted ( list ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> ans += p [ i ] <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> l1 = list ( map ( int . input ( ) . split ( ) ) ) <NEWLINE> l1 . sort ( ) <NEWLINE> price = 0 <NEWLINE> count = 0 <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> if count = k : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if l1 [ i ] != l1 [ i + 1 ] : <NEWLINE> <INDENT> price += l1 [ i ] <NEWLINE> count += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( price ) <NEWLINE>
N = input ( ) <NEWLINE> K = input ( ) <NEWLINE> lists = [ ] <NEWLINE> B = 0 <NEWLINE> <NL> for i in range ( int ( N ) ) : <NEWLINE> <INDENT> A = input ( ) <NEWLINE> lists . append ( int ( A ) ) <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> lists . sort ( ) <NEWLINE> <COMMENT> <NL> <NL> for j in range ( int ( K ) ) : <NEWLINE> <INDENT> B += int ( lists [ j ] ) <NEWLINE> <NL> <DEDENT> print ( B ) <NEWLINE>
a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b . sort ( ) <NEWLINE> c = 0 <NEWLINE> for i in b [ a [ 1 ] ] : <NEWLINE> <INDENT> c += b [ i ] <NEWLINE> return c <NEWLINE> <DEDENT> print ( c ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> p2 = p . sort ( ) <NEWLINE> print ( sum ( p2 [ : k ] ) ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> li = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> total = 0 <NEWLINE> <NL> for _ in range ( K ) : <NEWLINE> <INDENT> total += min ( li ) <NEWLINE> li = li . remove ( min ( li ) ) <NEWLINE> <NL> <DEDENT> print ( total ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> p . sort ( ) <NEWLINE> <NL> ans = p [ : k ] . sum ( ) <NEWLINE> <NL> print ( ans ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> prices = list ( map ( input ( ) . split ( ) ) ) <NEWLINE> print ( sum ( sorted ( prices [ : k ] ) ) ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> price = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> priceN = sorted ( price ) <NEWLINE> total = 0 <NEWLINE> for i in range ( K ) : <NEWLINE> <INDENT> total += priceN [ i ] <NEWLINE> <DEDENT> price ( total ) <NEWLINE>
N , K = map ( int , input ( ) ) <NEWLINE> <NL> p = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> print ( sum ( p [ : K ] ) ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> <COMMENT> <NL> x = list ( input ( ) . split ( ) ) for i in range ( n ) <NEWLINE> x . sort ( ) <NEWLINE> print ( sum ( list [ 0 : k ] ) ) <NEWLINE>
_ , k = input ( ) . split ( ) <NEWLINE> <NL> prices = list ( input ( ) . split ( ) . map ( lambda x : int ( x ) ) ) <NEWLINE> <NL> prices . sort ( ) <NEWLINE> <NL> sum = 0 <NEWLINE> for i in range ( int ( k ) ) : <NEWLINE> <INDENT> sum += prices [ i ] <NEWLINE> <DEDENT> print ( sum ) <NEWLINE>
a , b = ( int ( x ) for x in input ( ) . split ( ) ) <NEWLINE> num_list = list ( map ( int , input ( ) . split ( ) ) ) . sort ( ) <NEWLINE> ans = 0 <NEWLINE> <NL> for i in range ( b ) : <NEWLINE> <INDENT> ans += num_list [ i ] <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> p - list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> p = sorted ( p , key = int ) <NEWLINE> print ( sum ( p [ : 2 ] ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> k = int ( input ( ) ) <NEWLINE> price = [ ] <NEWLINE> cost = 0 <NEWLINE> for p in range ( n ) : <NEWLINE> <INDENT> p = int ( input ( ) ) <NEWLINE> price . append ( p ) <NEWLINE> <NL> <DEDENT> price . sort ( ) <NEWLINE> del price [ k : ] <NEWLINE> for p in price : <NEWLINE> <INDENT> cost += p <NEWLINE> <NL> <DEDENT> print ( cost ) <NEWLINE>
n , k = [ int ( j ) for j in input ( ) . split ( <STRING> ) ] <NEWLINE> p = input ( ) . split ( <STRING> ) <NEWLINE> <NL> p . sort ( ) <NEWLINE> sum = 0 <NEWLINE> <NL> for i in range ( 0 , k ) : <NEWLINE> <INDENT> sum += int ( p [ i ] ) <NEWLINE> <NL> <DEDENT> return sum <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> p = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> x = int ( input ( ) ) <NEWLINE> p . append ( x ) <NEWLINE> <DEDENT> p . sort ( ) <NEWLINE> y = 0 <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> y = y + p [ i ] <NEWLINE> <DEDENT> print ( y ) <NEWLINE>
S = list ( map ( int , input ( ) . strip ( ) . split ( ) ) ) <NEWLINE> N = S [ 0 ] <NEWLINE> K = S [ 1 ] <NEWLINE> p = list ( map ( int , input ( ) . strip ( ) . split ( ) ) ) <NEWLINE> lists = [ ] <NEWLINE> for l in range ( K ) : <NEWLINE> <INDENT> lists . append ( min ( p ) ) <NEWLINE> lists . drop ( min ( p ) ) <NEWLINE> <NL> <DEDENT> print ( sum ( lists ) ) <NEWLINE>
a , b = map ( int , input ( ) ) <NEWLINE> c = [ ] <NEWLINE> c = input ( ) . split ( ) <NEWLINE> d = c . sorted ( ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( b ) : <NEWLINE> <INDENT> ans += c [ i ] <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> p . sort ( ) <NEWLINE> for i , v in enumerate ( p ) : <NEWLINE> <INDENT> ans += v <NEWLINE> if i == 2 : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n , k = input ( ) . split ( ) ; print ( sum ( sorted ( int , input ( ) . split ( ) ) [ : int ( k ) ] ) ) <NEWLINE>
n , k = input ( ) . split ( ) <NEWLINE> num_list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> num_list . sort ( ) <NEWLINE> ans = 0 <NEWLINE> <NL> for i in range ( k ) : <NEWLINE> <INDENT> ans += num_list [ i ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> price = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> price . sort ( reverse = True ) <NEWLINE> price_N = price [ : K ] <NEWLINE> j = 0 <NEWLINE> for i in price_K : <NEWLINE> <INDENT> j += i <NEWLINE> <DEDENT> print ( j ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> c = [ ] <NEWLINE> for _ in range ( a ) : <NEWLINE> <INDENT> c . append ( int ( input ( ) ) ) <NEWLINE> <DEDENT> sort ( c ) <NEWLINE> print ( sum ( c [ 0 : b ] ) ) <NEWLINE>
N , K = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> <NL> sort ( p ) <NEWLINE> print ( sum ( p [ : K ] ) ) <NEWLINE> <NL> <NL>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> prices = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> print ( sum ( prices . sort ( ) [ : K ] ) ) <NEWLINE>
n , k = tuple ( map ( int , input . split ( ) ) ) <NEWLINE> l = list [ map ( int , input . split ( ) ) ] <NEWLINE> s = sum ( l . sort ( ) . [ : k ] ) <NEWLINE> print ( s ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> K = int ( input ( ) ) <NEWLINE> p = [ ] <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> x = int ( input ( ) ) <NEWLINE> p . append ( x ) <NEWLINE> <NL> <DEDENT> p . sort ( ) <NEWLINE> <NL> y = 0 <NEWLINE> <NL> for i in range ( K ) : <NEWLINE> <INDENT> y += p [ i ] <NEWLINE> <NL> <DEDENT> print ( y ) <NEWLINE>
N , K = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> price_list = input ( ) . split ( ) <NEWLINE> <NL> price_list . sort ( ) <NEWLINE> <NL> answer = 0 <NEWLINE> <NL> for i in range ( K ) : <NEWLINE> <INDENT> answer += price_list [ i ] <NEWLINE> <NL> <DEDENT> print ( answer ) <NEWLINE>
a = input ( ) . split ( <STRING> ) <NEWLINE> b = input ( ) . split ( <STRING> ) . sort ( ) <NEWLINE> sum = 0 <NEWLINE> for i in a [ 1 ] : <NEWLINE> <INDENT> sum += i <NEWLINE> <DEDENT> print ( sum ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> P = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> sorted_p = sorted ( P ) <NEWLINE> ans = sum ( sorted_p [ : k ] ) <NEWLINE> print ( ans ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( <NEWLINE> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> p . sort ( ) <NEWLINE> print ( sum ( p [ : K ] <NEWLINE>
n , k = int ( input ( ) ) <NEWLINE> list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> list . sort ( ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> ans += list [ i ] <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
N , K = map ( int , input . split ( ) ) <NEWLINE> p = map ( int , input . split ( ) ) <NEWLINE> <NL> print ( sum ( sorted ( p ) [ : K ] <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> p = input ( ) . split ( ) <NEWLINE> <NL> p . sort ( ) <NEWLINE> print ( sum ( p [ 0 : k ] ) ) <NEWLINE>
n , k = mapt ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> p = mapt ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> print ( sum ( sorted ( p ) [ : 3 ] ) ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> pList = map ( int , input ( ) . split ( ) ) <NEWLINE> list . sort ( pList ) <NEWLINE> score = 0 <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> score += pList [ i ] <NEWLINE> <DEDENT> print ( score ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> li = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> newlist = sorted ( li ) <NEWLINE> price = 0 <NEWLINE> for a in range ( k ) : <NEWLINE> <INDENT> count += newlist [ a ] <NEWLINE> <NL> <DEDENT> print ( count ) <NEWLINE>
N , K = input ( ) . split ( ) <NEWLINE> p = sorted ( [ list ( map ( int , input ( ) . split ( ) ) ) ] ) <NEWLINE> res = 0 <NEWLINE> for x in range ( K ) : <NEWLINE> <INDENT> res += p [ x ] <NEWLINE> <DEDENT> print ( res ) <NEWLINE>
n , k = ( int ( x ) for x in input . split ( ) ) <NEWLINE> array = list ( map ( int , input ( ) . strip ( ) . split ( ) ) ) <NEWLINE> print ( <STRING> ) <NEWLINE> print ( sum ( array [ 0 : k ] ) ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> x = list ( map ( int , input ( ) ) ) <NEWLINE> x . sorted ( ) <NEWLINE> o = 0 <NEWLINE> for i in range ( b ) : <NEWLINE> <INDENT> o = O + x [ i ] <NEWLINE> <DEDENT> print ( o ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> lol = [ int ( n ) for n in input ( ) . split ( ) ] <NEWLINE> lol . sort ( ) <NEWLINE> print ( sum ( lol [ : k ] ) ) <NEWLINE>
N , K = tuple ( map ( int , input . split ( <STRING> ) ) ) <NEWLINE> cont = list ( map ( int , input . split ( <STRING> ) ) ) <NEWLINE> print ( sum ( cont [ : K ] ) ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) <NEWLINE> p . sort ( ) <NEWLINE> ans = sum ( p [ : k ] ) <NEWLINE> print ( ans ) <NEWLINE>
N , M = map ( int , input ( ) . splilt ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . splilt ( ) ) ) <NEWLINE> print ( sum ( sorted ( p ) [ : M ] ) ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> p = input ( ) <NEWLINE> x = p . split ( ) <NEWLINE> l = int ( x ) <NEWLINE> <NL> if n == len ( l ) : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return <NEWLINE> <NL> <DEDENT> for i in range ( k ) : <NEWLINE> <INDENT> shukei += min ( l ) <NEWLINE> l . remove ( min ( l ) ) <NEWLINE> <NL> <DEDENT> print ( shukei ) <NEWLINE>
k , n = map ( int , input ( ) . split ( ) ) <NEWLINE> prices = list ( int , input ( ) . split ( ) ) . sort ( ) <NEWLINE> total = sum ( prices [ : n ] ) <NEWLINE> print ( total ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ps = p . sort ( ) <NEWLINE> ans = 0 <NEWLINE> <NL> for i in range ( k ) : <NEWLINE> <INDENT> ans += ps [ i ] <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> s = 0 <NEWLINE> sort ( p ) <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> s += p [ i ] <NEWLINE> <NL> <DEDENT> print ( s ) <NEWLINE>
N , K = map ( int , input ( ) ) <NEWLINE> aa = list ( map ( int , input ( ) ) ) <NEWLINE> aa . sort ( ) <NEWLINE> aaa = aa [ : K ] <NEWLINE> print ( sum ( aaa ) ) <NEWLINE>
N , K = int ( input ( ) ) , int ( input ( ) ) <NEWLINE> P = [ int ( v ) for v in input ( ) . split ( ) ] <NEWLINE> <NL> print ( sum ( sorted ( P ) [ : K ] ) ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> fruits = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> mix = [ ] <NEWLINE> <NL> for mix in range ( k ) : <NEWLINE> <INDENT> mix . append ( min ( fruits ) ) <NEWLINE> fruits . remove ( min ( fruits ) ) <NEWLINE> <NL> <DEDENT> print ( sum ( mix ) ) <NEWLINE>
n , k = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> arr = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> arr . sort ( ) <NEWLINE> print ( sum ( arr [ : k ] ) <NEWLINE>
import collections <NEWLINE> <NL> s = [ int ( i ) for i in input ( ) . split ( <STRING> ) ] <NEWLINE> print ( s ) <NEWLINE> p = [ int ( i ) for i in input ( ) . split ( <STRING> ) ] <NEWLINE> print ( p ) <NEWLINE> a = [ ] <NEWLINE> p . sort ( ) <NEWLINE> print ( p ) <NEWLINE> <NL> for i in range ( 0 , s [ 1 ] ) : <NEWLINE> <INDENT> a = p [ i ] <NEWLINE> <DEDENT> b = [ int ( b ) for b in a ] <NEWLINE> print ( sum ( b ) ) <NEWLINE>
n , k = int ( input ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> p . sort ( ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> ans += p [ i ] <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> p . sort ( ) <NEWLINE> print ( sum ( p [ : k ] ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> p = p . sort ( ) <NEWLINE> price = 0 <NEWLINE> for idx in range ( K ) : <NEWLINE> <INDENT> price = price + p [ idx ] <NEWLINE> <DEDENT> print ( price ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> l . sort ( ) <NEWLINE> print ( sum ( l [ : k ] ) <NEWLINE>
n , k = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> price_arr = list ( map ( int , input . split ( ) ) ) <NEWLINE> price_arr . sort ( ) <NEWLINE> sum = 0 <NEWLINE> for i in range ( 0 , k ) : <NEWLINE> <INDENT> sum += price_arr [ i ] <NEWLINE> <DEDENT> print ( sum ) <NEWLINE>
init = input ( ) . split ( ) <NEWLINE> N = int ( init [ 0 ] ) <NEWLINE> K = int ( init [ 1 ] ) <NEWLINE> <NL> prices = [ int ( input ( ) ) for i in range ( N ) ] <NEWLINE> prices . sort ( ) <NEWLINE> <NL> sum = 0 <NEWLINE> for i , ele in enumerate ( prices ) : <NEWLINE> <INDENT> if i >= K : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else <NEWLINE> <INDENT> sum = sum + ele <NEWLINE> <DEDENT> <DEDENT> print ( sum ) <NEWLINE>
n , k = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> values = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> print ( sum ( sorted ( values ) [ : k ] ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> s = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> s = s . sort ( ) <NEWLINE> for _ in range ( m ) : <NEWLINE> <INDENT> ans += s [ _ ] <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> p = p . sort ( ) <NEWLINE> print ( sum ( p [ : k ] ) ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> p . sort ( ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( K ) : <NEWLINE> <INDENT> ans += p [ i ] <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
5 3 <NEWLINE> 50 100 80 120 80 <NEWLINE>
n , k = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> p = lilst ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> p . sort ( ) <NEWLINE> <NL> print ( sum ( p [ : k ] ) ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ) <NEWLINE> p . sort ( reverse = True ) <NEWLINE> print ( sum ( p [ : K ] ) ) <NEWLINE>
n , k = map ( int , input ( ) . split ) <NEWLINE> l = list ( map ( int , input ( ) . split ) ) <NEWLINE> l . sort ( ) <NEWLINE> print ( sum ( l [ : k ] ) ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> print ( sum ( sorted ( p ) [ : N ] ) ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> p = list ( map ( imt , input ( ) . split ( ) ) ) <NEWLINE> p . sort ( ) <NEWLINE> print ( sum ( p [ : k ] ) ) <NEWLINE>
N , K = list ( int ( t ) for t in input ( ) . split ( ) ) <NEWLINE> price = list ( int ( t ) for t in input ( ) . split ( ) ) <NEWLINE> price . sort ( ) <NEWLINE> total = sum ( price [ 0 , K ] ) <NEWLINE> print ( total ) <NEWLINE>
N , K = input ( ) . split ( ) <NEWLINE> p = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> p . sort ( ) <NEWLINE> print ( sum ( p [ : K + 1 ] ) ) <NEWLINE>
n , k = [ int ( i ) in input ( ) . split ( ) ] <NEWLINE> p = [ int ( i ) in input ( ) . split ( ) ] <NEWLINE> p . sort ( ) <NEWLINE> print ( sum ( p [ : k ] ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> prices = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> prices = prices . sorted ( ) <NEWLINE> <NL> answer = 0 <NEWLINE> for i in range ( 0 , k , 1 ) : <NEWLINE> <INDENT> answer = answer + prices [ i ] <NEWLINE> <DEDENT> print ( answer ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> LIst_1 = sorted ( list ( map ( int , input ( ) . split ( ) ) ) , reverse = True ) <NEWLINE> K = K + 1 <NEWLINE> ans = sum ( List_1 [ : K ] ) <NEWLINE>
nk = input ( ) . split ( ) <NEWLINE> n = int ( nk [ 0 ] ) <NEWLINE> k = int ( nk [ 1 ] ) <NEWLINE> data = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> data2 = data . sort ( ) <NEWLINE> s = 0 <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> s += data2 [ i ] <NEWLINE> <DEDENT> print ( s ) <NEWLINE>
<NL> import sys <NEWLINE> import math <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> <NL> def inlt ( ) : <NEWLINE> <INDENT> return ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> <NL> <DEDENT> n , k = inlt ( ) <NEWLINE> p = inlt ( ) <NEWLINE> p = math . sort ( p ) <NEWLINE> print ( sum ( p [ : k ] ) ) <NEWLINE> <NL> <NL>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> p = sorted ( list ( int ( input ( ) ) for _ in range ( n ) ) ) <NEWLINE> print ( sum ( p [ 0 : k ] ) ) <NEWLINE>
number = input ( ) . split ( <STRING> ) <NEWLINE> N = int ( number [ 0 ] ) <NEWLINE> K = int ( number [ 1 ] ) <NEWLINE> <NL> numbers = input ( ) . split ( <STRING> ) <NEWLINE> numbers . sotr ( ) <NEWLINE> <NL> a = 0 <NEWLINE> <NL> for i in range ( K ) : <NEWLINE> <INDENT> a += numbers [ i ] <NEWLINE> <DEDENT> print ( a ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) <NEWLINE> a . sort ( ) <NEWLINE> print ( sum ( a [ : k ] ) ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> p . sort ( ) <NEWLINE> <NL> temp = 0 <NEWLINE> for i in p [ : k ] : <NEWLINE> <INDENT> temp += i <NEWLINE> <DEDENT> print ( temp ) <NEWLINE>
n , k = input ( ) . split ( ) <NEWLINE> n = int ( n ) <NEWLINE> k = int ( k ) <NEWLINE> listnum = [ ] <NEWLINE> newlist = [ ] <NEWLINE> sumnum = 0 <NEWLINE> for a in range ( n ) : <NEWLINE> <INDENT> listnum . append ( int ( input ( ) ) <NEWLINE> <DEDENT> newlist = sorted ( listnum ) <NEWLINE> for b in range ( k ) : <NEWLINE> <INDENT> sumnum = sumnum + list [ 0 ] <NEWLINE> <DEDENT> print ( sumnum ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> from fractions import gcd <NEWLINE> from itertools import combinations , permutations , accumulate <COMMENT> <NEWLINE> <COMMENT> <NL> from collections import deque , defaultdict , Counter <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> import sys <NEWLINE> sys . setrecursionlimit ( 10000000 ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <COMMENT> <NL> def readInts ( ) : <NEWLINE> <INDENT> return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <DEDENT> def I ( ) : <NEWLINE> <INDENT> return int ( input ( ) ) <NEWLINE> <DEDENT> n , k = readInts ( ) <NEWLINE> A = readInts ( ) <NEWLINE> mi = float ( <STRING> ) <NEWLINE> for pa in combinations ( A , k ) : <NEWLINE> <INDENT> nya = sum ( pa ) <NEWLINE> mi = min ( mi , nya ) <NEWLINE> <DEDENT> print ( mi ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> fruits = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> return sorted ( fruit ) [ : K ] <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a . sort ( ) <NEWLINE> print ( sum [ : k ] ) <NEWLINE>
K = int ( input ( ) ) <NEWLINE> N = int ( input ( ) ) <NEWLINE> li = [ ] <NEWLINE> for i in range ( 0 , K ) : <NEWLINE> <INDENT> fruit = int ( input ( ) ) <NEWLINE> li . append ( fruit ) <NEWLINE> li . sort ( ) <NEWLINE> sum1 = 0 <NEWLINE> for i in range ( 0 , N ) : <NEWLINE> <INDENT> sum1 = sum1 + li [ i ] <NEWLINE> <DEDENT> print ( sum1 ) <NEWLINE> <DEDENT>
import math <NEWLINE> n = int ( input ( ) ) <NEWLINE> print ( math . ceil ( n / 1000 ) * 1000 - n ) <NEWLINE>
N , K = map ( int , input . split ( ) ) <NEWLINE> p = list ( int , input ( ) . split ( ) ) <NEWLINE> B = 0 <NEWLINE> p . sort ( ) <NEWLINE> K = K - 1 <NEWLINE> for i in range ( 0 , K ) : <NEWLINE> <INDENT> B = B + p [ i ] <NEWLINE> i = i + 1 <NEWLINE> <NL> <DEDENT> print ( B ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> P = list ( map ( int , input ( ) . split ( ) ) ) . sort ( ) <NEWLINE> print ( sum ( P [ : K ] ) ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> p = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> p . append ( int ( input ( ) ) ) <NEWLINE> <DEDENT> p . sort ( ) <NEWLINE> <NL> price = 0 <NEWLINE> if N > 0 : <NEWLINE> <INDENT> for j in range ( 3 ) : <NEWLINE> <INDENT> price += p [ j ] <NEWLINE> <DEDENT> <DEDENT> print ( price ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> K = int ( input ( ) ) <NEWLINE> <NL> price = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> price . sort ( ) <NEWLINE> <NL> part = price [ 0 : K ] <NEWLINE> <NL> print ( sum ( part ) ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
a = input ( ) <NEWLINE> l = a . split ( <STRING> ) <NEWLINE> n = int ( l [ 0 ] ) <NEWLINE> k = int ( l [ 1 ] ) <NEWLINE> f = input ( ) <NEWLINE> fruits = int ( f . split ( <STRING> ) ) <NEWLINE> for d in range ( 0 , len ( fruits ) ) : <NEWLINE> <INDENT> fruits [ d ] = int ( fruits [ d ] ) <NEWLINE> <DEDENT> ans = 0 <NEWLINE> b = 0 <NEWLINE> while ( b < k ) : <NEWLINE> <INDENT> g = max ( fruits ) <NEWLINE> ans += g <NEWLINE> fruits . remove ( g ) <NEWLINE> b += 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import itertools <NEWLINE> import sys <NEWLINE> from typing import Callable , List , NoReturn <NEWLINE> <NL> <NL> def main ( ) -> NoReturn : <NEWLINE> <INDENT> readline : Callable [ [ ] , str ] = sys . stdin . readline <NEWLINE> n , k = map ( int , readline ( ) . rstrip ( ) . split ( ) ) <COMMENT> <NEWLINE> p : List [ int ] = [ int ( _ ) for _ in readline ( ) . rstrip ( ) . split ( ) ] <NEWLINE> <NL> print ( sum ( p . sort ( ) [ : k ] ) ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N , K = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> P = list ( map ( int , input ( ) . spllit ( <STRING> ) ) ) <NEWLINE> if ( k == 1 ) : <NEWLINE> <INDENT> print ( min ( P ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> res = [ ] <NEWLINE> for i in range ( K ) : <NEWLINE> <INDENT> res [ i ] . append ( min ( P ) ) <NEWLINE> P . remove ( min ( P ) ) <NEWLINE> <DEDENT> print ( sum ( res ) ) <NEWLINE> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> n = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> m = n . sort ( ) <NEWLINE> print ( sum ( m [ 0 : K ] ) ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> p . sort ( ) <NEWLINE> print ( sum ( p [ 0 : k ] ) <NEWLINE>
n , k = input ( ) . split ( ) <NEWLINE> lists = list ( input ( ) . split ( ) ) <NEWLINE> for i in range ( int ( n ) ) : <NEWLINE> <INDENT> lists [ i ] = int ( lists [ i ] ) <NEWLINE> <DEDENT> lists . sort ( ) <NEWLINE> for i in range ( int ( k ) ) : <NEWLINE> <INDENT> sum_fruit = sum_fruit + int ( lists . pop ( 0 ) ) <NEWLINE> <DEDENT> print ( str ( sum_fruit ) ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> price = [ int ( input ( ) ) for _ in range ( N ) ] <NEWLINE> price . sort ( ) <NEWLINE> print ( sum ( price [ : 3 ] ) ) <NEWLINE>
n , k = input ( ) . split ( <STRING> ) <NEWLINE> n = int ( n ) <NEWLINE> k = int ( k ) <NEWLINE> a = input . split ( <STRING> ) <NEWLINE> a = sorted ( a ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> ans += int ( a [ i ] ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> l . sort ( ) <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> ans = ans + l [ k ] <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> N = a [ 0 ] <NEWLINE> K = a [ 1 ] <NEWLINE> <NL> p . sort ( ) <NEWLINE> <NL> g = 0 <NEWLINE> for k in range ( K ) <NEWLINE> <INDENT> g = g + p [ k ] <NEWLINE> <DEDENT> print ( g ) <NEWLINE>
l = map ( int , open ( 0 ) . read ( ) . split ( ) ) ; print ( sum ( sorted ( l [ 2 : ] ) [ : l [ 1 ] ] ) ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> p = sorted ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> print ( sum ( [ : k ] ) ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> p . sort ( ) <NEWLINE> <NL> print ( sum ( p [ 0 : K ] ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> c = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> d = c . sort ( ) <NEWLINE> print ( d ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 0 , b ) : <NEWLINE> <INDENT> ans += d [ i ] <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
N . K = map ( int , input ( ) . split ( ) ) <NEWLINE> P = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> print ( sum ( P [ : K ] ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> k = int ( input ( ) ) <NEWLINE> lst = [ ] <NEWLINE> result = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> lst . append ( int ( input ( ) ) ) <NEWLINE> <DEDENT> for i in range ( k ) : <NEWLINE> <INDENT> temp = min ( lst ) <NEWLINE> result . append ( temp ) <NEWLINE> lst . remove ( temp ) <NEWLINE> <DEDENT> print ( sum ( result ) ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> p . sort ( ) <NEWLINE> <NL> i = 0 <NEWLINE> price = 0 <NEWLINE> while i < k : <NEWLINE> <INDENT> price += p [ i ] <NEWLINE> i + + <NEWLINE> <NL> <DEDENT> print ( price ) <NEWLINE>
n , k = map ( int , input ( ) . split ) <NEWLINE> <NL> s = input ( ) . rstrip ( ) . split ( <STRING> ) <NEWLINE> st = [ ] <NEWLINE> <NL> for i in range ( 0 , n ) : <NEWLINE> <INDENT> a = int ( s [ i ] ) <NEWLINE> st . append ( a ) <NEWLINE> <NL> <DEDENT> new_st = sorted ( st ) <NEWLINE> sum = 0 <NEWLINE> for j in range ( 0 , k ) : <NEWLINE> <INDENT> sum += new_st [ j ] <NEWLINE> <NL> <DEDENT> print ( sum ) <NEWLINE>
N , K = input ( ) . split ( ) <NEWLINE> N = int ( N ) <NEWLINE> K = int ( K ) <NEWLINE> a = [ ] <NEWLINE> a = [ int ( a ) for a in input ( ) . split ( ) ] <NEWLINE> a . sort ( ) <NEWLINE> print ( sum ( a [ 0 : K - 1 ] ) <NEWLINE>
n , k = map ( int , input ( ) ) <NEWLINE> l = sorted ( [ int ( x ) for x in input ( ) . split ( ) ] ) <NEWLINE> <NL> print ( sum ( l [ : k ] ) ) <NEWLINE>
import functools <NEWLINE> n , k = int ( input ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> p . sort ( ) <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> cost += p [ i ] <NEWLINE> <DEDENT> print ( cost ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> K = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A . sort ( ) <NEWLINE> print ( sum ( A [ 0 : K ] ) ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> p = list ( map ( int ( input ( ) . split ( ) ) ) <NEWLINE> p . sort ( ) <NEWLINE> q = p [ : k ] <NEWLINE> print ( sum ( q ) ) <NEWLINE>
n = input ( ) <NEWLINE> m = n . split ( ) <NEWLINE> for i in range ( 0 , len ( m ) ) : <NEWLINE> <INDENT> m [ i ] = int ( m [ i ] ) <NEWLINE> <DEDENT> a = m [ 0 ] <NEWLINE> b = m [ 1 ] <NEWLINE> m = m [ 2 : ] <NEWLINE> p = 0 <NEWLINE> for i in range ( a - b , a ) : <NEWLINE> <INDENT> p = p + int ( m [ i ] ) <NEWLINE> <DEDENT> print ( int ( p ) ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a . sort ( ) <NEWLINE> print ( sum ( p [ : k ] ) ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> P = list ( map ( input ( ) . split ( ) ) ) <NEWLINE> <NL> P . sort ( ) <NEWLINE> price = 0 <NEWLINE> for i in range ( K ) : <NEWLINE> <INDENT> price += P [ i ] <NEWLINE> <NL> <DEDENT> print ( price ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> pr = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> pr . sort ( ) <NEWLINE> <NL> print ( sum ( pr [ 0 : k ] ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> price = list ( map ( int , input ( ) , split ( ) ) ) <NEWLINE> <NL> price . sort ( ) <NEWLINE> <NL> for p in range ( 1 , K ) : <NEWLINE> <INDENT> ans += price [ p ] <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
def resolve ( ) : <NEWLINE> <INDENT> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> listA = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> listA . sort ( ) <NEWLINE> c = sum ( listA [ : k ] ) <NEWLINE> print ( c <NEWLINE> <DEDENT> resolve ( ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> p = list ( input ( ) . split ( ) ) <NEWLINE> p . sort ( ) <NEWLINE> print ( sum ( p [ 0 : n ] ) ) <NEWLINE>
n , k = inpl ( ) <NEWLINE> p = inpl ( ) <NEWLINE> p = sorted ( p ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ans += p [ i ] <NEWLINE> if i + 1 == k : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n , k = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> print ( sum ( sorted ( p ) [ : k ] ) <NEWLINE>
a , b = input ( ) <NEWLINE> listA = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> listA . sort ( ) <NEWLINE> all = 0 <NEWLINE> <NL> for i in range ( b ) : <NEWLINE> <INDENT> all = all + list [ i ] <NEWLINE> <NL> <DEDENT> print ( all ) <NEWLINE>
N , K = input ( ) . split ( ) <NEWLINE> p = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> p_ascending = p . sort ( ) <NEWLINE> total = 0 <NEWLINE> for i in p_ascending [ 0 , int ( K ) ] : <NEWLINE> <INDENT> total += i <NEWLINE> <NL> <DEDENT> print ( total ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> p = map ( int , input ( ) . split ( ) ) <NEWLINE> newlist = sorted ( p , reverse = False ) <NEWLINE> ans_list = [ ] <NEWLINE> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> ans . append ( newlist [ i - 1 ] ) <NEWLINE> <DEDENT> print ( sum ( ans_list ) ) <NEWLINE>
N = input ( ) <NEWLINE> <NL> s = <STRING> <NEWLINE> ans = <STRING> <NEWLINE> n , m = 0 , 0 <NEWLINE> <NL> for i in range ( 1 , 1000 ) : <NEWLINE> <INDENT> m += 26 ** i <NEWLINE> if N <= m : <NEWLINE> <INDENT> n = i <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> a , b = divmod ( N , 26 ) <NEWLINE> N = a <NEWLINE> if b == 0 : <NEWLINE> <INDENT> ans += s [ 25 ] <NEWLINE> N -= 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += s [ b - 1 ] <NEWLINE> <NL> <DEDENT> <DEDENT> ans1 = <STRING> . join ( list ( reversed ( ans ) ) ) <NEWLINE> print ( ans1 ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> s = <STRING> <NEWLINE> for i in range ( 11 ) : <NEWLINE> <INDENT> if N != 0 : <NEWLINE> <INDENT> n -= 1 <NEWLINE> s += chr ( ord ( <STRING> ) + N % 26 ) <NEWLINE> n //= 26 <NEWLINE> <DEDENT> <DEDENT> print ( s [ : : - 1 ] ) <NEWLINE>
import sys <NEWLINE> import numpy as np <NEWLINE> import math <NEWLINE> from collections import deque <NEWLINE> from functools import reduce <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> az = <STRING> <NEWLINE> cnt = 12 <NEWLINE> ret = [ ] <NEWLINE> ama = n % 26 <NEWLINE> na = n <NEWLINE> for i in range ( 12 , 0 , - 1 ) : <NEWLINE> <INDENT> if 26 ** ( i - 1 ) > n : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> sho = na // ( 26 ** i ) <NEWLINE> if sho > 0 : <NEWLINE> <INDENT> ret . append ( az [ sho - 1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if len ( ret ) > 0 : <NEWLINE> <INDENT> ret . append ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> na -= sho * ( 26 ** i ) <NEWLINE> <DEDENT> if ( ret [ 0 ] == <STRING> ) : <NEWLINE> <INDENT> del ret [ 0 ] <NEWLINE> <DEDENT> re = <STRING> . join ( ret ) <NEWLINE> print ( re ) <NEWLINE> <NL>
N = int ( input ( ) ) <NEWLINE> ans = <STRING> <NEWLINE> for i in range ( 1 , 99 ) : <NEWLINE> if N <= 26 ** i : <NEWLINE> N -= 1 <NEWLINE> for j in range ( i ) : <NEWLINE> ans += chr ( ord ( <STRING> ) + N % 26 ) <NEWLINE> N //= 26 <NEWLINE> break <NEWLINE> else : <NEWLINE> N -= 26 ** i <NEWLINE> print ( ans [ : : - 1 ] ) <COMMENT> <NEWLINE>
def xxx ( n ) : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> i = 1 <NEWLINE> <NL> while True : <NEWLINE> <INDENT> if n <= 26 ** i : <NEWLINE> <INDENT> n -= 1 <NEWLINE> for j in range ( i ) : <NEWLINE> <INDENT> ans = char ( ord ( <STRING> ) + n % 26 ) + ans <NEWLINE> n //= 26 <NEWLINE> <DEDENT> return ans <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> n -= 26 ** i <NEWLINE> i += 1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> N = int ( input ( ) ) <NEWLINE> print ( xxx ( N ) ) <NEWLINE>
def xxx ( n ) : <NEWLINE> <INDENT> alpha = <STRING> <NEWLINE> ans = <STRING> <NEWLINE> i = 0 <NEWLINE> <NL> while True : <NEWLINE> <INDENT> if n <= 26 ** i : <NEWLINE> <INDENT> n -= 1 <NEWLINE> while N > 0 : <NEWLINE> <INDENT> ans = alpha [ N % 26 - 1 ] + ans <NEWLINE> N //= 26 <NEWLINE> <DEDENT> return ans <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> n -= 26 ** i <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> N = int ( input ( ) ) <NEWLINE> print ( xxx ( N ) ) <NEWLINE>
<COMMENT> <NL> from numba import njit , void , i8 <NEWLINE> <NL> <NL> def get_input ( ) -> int : <NEWLINE> <INDENT> <STRING> <NEWLINE> N = int ( input ( ) ) <NEWLINE> <NL> return N <NEWLINE> <NL> <NL> <DEDENT> @ njit ( void ( i8 ) ) <NEWLINE> def main ( N : int ) -> None : <NEWLINE> <INDENT> <STRING> <NEWLINE> <COMMENT> <NL> ans = <STRING> <NEWLINE> while N > 0 : <NEWLINE> <INDENT> N -= 1 <NEWLINE> ans += chr ( ord ( <STRING> ) + N % 26 ) <NEWLINE> N //= 26 <NEWLINE> <DEDENT> ans = ans [ : : - 1 ] <NEWLINE> <NL> <COMMENT> <NL> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> N = get_input ( ) <NEWLINE> main ( N ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> ans = <STRING> <NEWLINE> <INDENT> for i in range ( 1 , 99 ) : <NEWLINE> <INDENT> if N <= 26 ** i : <NEWLINE> <INDENT> N -= 1 <NEWLINE> for j in range ( i ) : <NEWLINE> <INDENT> ans += chr ( ord ( <STRING> ) + N % 26 ) <NEWLINE> N //= 26 <NEWLINE> <DEDENT> <DEDENT> break <NEWLINE> else : <NEWLINE> <DEDENT> N -= 26 ** i <NEWLINE> <DEDENT> print ( ans [ : : - 1 ] ) <NEWLINE>
list = [ 0 , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> num_list = [ 0 ] <NEWLINE> for i in range ( 1 , 15 ) : <NEWLINE> <INDENT> num_list . append ( 26 ** i + num_list [ i - 1 ] ) <NEWLINE> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> i = 0 <NEWLINE> while True : <NEWLINE> <INDENT> if num_list [ i ] >= n : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> i += 1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> word = [ ] <NEWLINE> for j in range ( i , 0 , - 1 ) : <NEWLINE> <INDENT> x = n // 26 ** ( j - 1 ) <NEWLINE> elif x == 27 : <NEWLINE> <INDENT> word . append ( 26 ) <NEWLINE> n = n - 26 ** ( j - 1 ) * ( n // 26 ** ( j - 1 ) ) + 26 ** ( j - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> word . append ( x ) <NEWLINE> n = n - 26 ** ( j - 1 ) * ( n // 26 ** ( j - 1 ) ) <NEWLINE> <DEDENT> <DEDENT> while 0 in word : <NEWLINE> <INDENT> p = word . index ( 0 ) <NEWLINE> word [ p - 1 ] = word [ p - 1 ] - 1 <NEWLINE> word [ p ] = 26 <NEWLINE> <DEDENT> h = <STRING> <NEWLINE> for k in range ( len ( word ) ) : <NEWLINE> <INDENT> h += str ( list [ word [ k ] ] ) <NEWLINE> <DEDENT> print ( h ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> x = <STRING> <NEWLINE> a = n <NEWLINE> s = <STRING> <NEWLINE> if n <= 26 : <NEWLINE> <INDENT> print ( x [ n - 1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> while a > 26 : <NEWLINE> <INDENT> s += x [ ( a % 26 ) - 1 ] <NEWLINE> if a // 26 < 26 and a % 26 == 0 : <NEWLINE> <INDENT> a = a // 26 - 1 <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a = a // 26 <NEWLINE> <DEDENT> <DEDENT> s += x [ a % 26 - 1 ] <NEWLINE> print ( s [ : : - 1 ] <NEWLINE> <DEDENT>
= int ( input ( ) ) <NEWLINE> Al = [ <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> s = <STRING> <NEWLINE> M = [ 26 ** i for i in range ( 12 ) ] <NEWLINE> S = [ ] <NEWLINE> k = 0 <NEWLINE> for i in range ( 11 ) : <NEWLINE> <INDENT> k = k + M [ i ] <NEWLINE> if N < k : <NEWLINE> <INDENT> m = k - M [ i ] <NEWLINE> N = N - m <NEWLINE> L = [ 0 ] <NEWLINE> n = 0 <NEWLINE> for j in range ( 1 , i + 1 ) : <NEWLINE> <INDENT> L . append ( N % M [ j ] ) <NEWLINE> s = Al [ ( L [ j ] - L [ j - 1 ] ) // M [ j - 1 ] ] + s <NEWLINE> <DEDENT> break <NEWLINE> <DEDENT> <DEDENT> print ( s ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = <STRING> <NEWLINE> def fn ( n ) : <NEWLINE> <INDENT> if ( n <= 26 ) : <NEWLINE> <INDENT> return s [ n - 1 ] <NEWLINE> <DEDENT> return f ( n - 1 ) // 26 + s [ f ( n - 1 ) % 26 ] <NEWLINE> <NL> <DEDENT> print ( f ( n ) ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> def Base_10_to_n ( X , n ) : <NEWLINE> <INDENT> if ( int ( X / n ) ) : <NEWLINE> <INDENT> return Base_10_to_n ( int ( X / n ) , n ) + <STRING> + str ( X % n ) <NEWLINE> <DEDENT> return str ( X % n ) <NEWLINE> <COMMENT> <NL> <NL> <COMMENT> <NL> <DEDENT> import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> N = int ( input ( ) ) <NEWLINE> <NL> <COMMENT> <NL> x26 = Base_10_to_n ( N - 1 , 26 ) <NEWLINE> x26_list = x26 . split ( ) <NEWLINE> int_str = [ <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> <NL> <COMMENT> <NL> if x26_list [ 0 ] == <STRING> : <NEWLINE> <INDENT> del x26_list [ 0 ] <NEWLINE> <DEDENT> ans = <STRING> <NEWLINE> for i in range ( len ( x26_list ) - 1 ) : <NEWLINE> <INDENT> a = x26_list [ i ] <NEWLINE> x = int_str [ int ( a ) - 1 ] <NEWLINE> ans += x <NEWLINE> <DEDENT> ans += int_str [ int ( x26_list [ - 1 ] ) ] <NEWLINE> ans_list = list ( ans ) <NEWLINE> <NL> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> ans = <STRING> <NEWLINE> while N > 0 : <NEWLINE> N -= 1 <NEWLINE> ans += chr ( ord ( <STRING> ) + N % 26 ) <NEWLINE> N //= 26 <NEWLINE> print ( ans [ : : - 1 ] ) <NEWLINE>
i = input ( ) <NEWLINE> ans = <STRING> <NEWLINE> <NL> while i = 0 : <NEWLINE> <INDENT> nexti = i // 26 <NEWLINE> mod = i % 26 <NEWLINE> <INDENT> if mod = 0 : <NEWLINE> nextans = <STRING> + ans <NEWLINE> nextii = nexti - 1 <NEWLINE> <INDENT> nexti = nextii <NEWLINE> <DEDENT> elif mod = 1 : <NEWLINE> nextans = <STRING> + ans <NEWLINE> elif mod = 2 : <NEWLINE> nextans = <STRING> + ans <NEWLINE> elif mod = 3 : <NEWLINE> nextans = <STRING> + ans <NEWLINE> elif mod = 4 : <NEWLINE> nextans = <STRING> + ans <NEWLINE> elif mod = 5 : <NEWLINE> nextans = <STRING> + ans <NEWLINE> elif mod = 6 : <NEWLINE> nextans = <STRING> + ans <NEWLINE> elif mod = 7 : <NEWLINE> nextans = <STRING> + ans <NEWLINE> elif mod = 8 : <NEWLINE> nextans = <STRING> + ans <NEWLINE> elif mod = 9 : <NEWLINE> nextans = <STRING> + ans <NEWLINE> elif mod = 10 : <NEWLINE> nextans = <STRING> + ans <NEWLINE> elif mod = 11 : <NEWLINE> nextans = <STRING> + ans <NEWLINE> elif mod = 12 : <NEWLINE> nextans = <STRING> + ans <NEWLINE> elif mod = 13 : <NEWLINE> nextans = <STRING> + ans <NEWLINE> elif mod = 14 : <NEWLINE> nextans = <STRING> + ans <NEWLINE> elif mod = 15 : <NEWLINE> nextans = <STRING> + ans <NEWLINE> elif mod = 16 : <NEWLINE> nextans = <STRING> + ans <NEWLINE> elif mod = 17 : <NEWLINE> nextans = <STRING> + ans <NEWLINE> elif mod = 18 : <NEWLINE> nextans = <STRING> + ans <NEWLINE> elif mod = 19 : <NEWLINE> nextans = <STRING> + ans <NEWLINE> elif mod = 20 : <NEWLINE> nextans = <STRING> + ans <NEWLINE> elif mod = 21 : <NEWLINE> nextans = <STRING> + ans <NEWLINE> elif mod = 22 : <NEWLINE> nextans = <STRING> + ans <NEWLINE> elif mod = 23 : <NEWLINE> nextans = <STRING> + ans <NEWLINE> elif mod = 24 : <NEWLINE> nextans = <STRING> + ans <NEWLINE> elif mod = 25 : <NEWLINE> nextans = <STRING> + ans <NEWLINE> <DEDENT> ans = nextans <NEWLINE> i = nexti <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> f = [ ] <NEWLINE> <NL> if n > 26 : <NEWLINE> <INDENT> while n : <NEWLINE> <INDENT> n -= 1 <NEWLINE> n , r = divmod ( n , 26 ) <NEWLINE> f += [ r ] <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> f += [ n ] <NEWLINE> <NL> <DEDENT> g = <STRING> <NEWLINE> s = string . ascii_lowercase <NEWLINE> f . reverse ( ) <NEWLINE> for i in f : <NEWLINE> <INDENT> g += s [ i ] <NEWLINE> <NL> <DEDENT> print ( g ) <NEWLINE>
N = int ( input ( ) ) ans = <STRING> whileN > 0 : <NEWLINE> N -= 1 <NEWLINE> ans += chr ( ord ( <STRING> ) + N % 26 ) N //= 26 <NEWLINE> print ( ans [ : : - 1 ] ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> for i in range ( 11 ) : <NEWLINE> <INDENT> p = 0 <NEWLINE> q = 0 <NEWLINE> p = n % 26 <NEWLINE> if n == 0 and p == 0 : <NEWLINE> <INDENT> l2 [ i ] = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> l2 [ i ] = l [ p ] <NEWLINE> if p == 0 : <NEWLINE> <INDENT> q = n - 26 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> q = n - p <NEWLINE> <DEDENT> n = q // 26 <NEWLINE> <DEDENT> <DEDENT> print ( l2 [ 10 ] + l2 [ 9 ] + l2 [ 8 ] + l2 [ 7 ] + l2 [ 6 ] + l2 [ 5 ] + l2 [ 4 ] + l2 [ 3 ] + l2 [ 2 ] + l2 [ 1 ] + l2 [ 0 ] ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> <COMMENT> <NL> <NL> alp = [ chr ( ord ( <STRING> ) + i ) for i in range ( 26 ) ] <NEWLINE> lst = [ 0 ] * 11 <NEWLINE> <NL> for i in range ( 11 ) : <NEWLINE> <INDENT> if n >= 26 ** ( 10 - i ) : <NEWLINE> <INDENT> a , n = divmod ( n , 26 ** ( 10 - i ) ) <NEWLINE> lst [ i ] = alp [ a - 1 ] <NEWLINE> <NL> <DEDENT> <DEDENT> switch = 0 <NEWLINE> for i in range ( 10 ) : <NEWLINE> <INDENT> if lst [ i ] == 0 : <NEWLINE> <INDENT> if switch == 0 : <NEWLINE> <INDENT> lst . remove ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> lst [ i ] = <STRING> <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> switch = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> . join ( lst ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> alph = { key + 1 : val for key , val in enumerate ( <STRING> ) } <NEWLINE> alph [ 0 ] = <STRING> <NEWLINE> answer = <STRING> <NEWLINE> while N >= 1 : <NEWLINE> <INDENT> answer = alph [ N % 26 ] + answer <NEWLINE> if N == 26 : <NEWLINE> <INDENT> break <NEWLINE> N //= 26 <NEWLINE> <NL> print ( answer ) <NEWLINE> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> ans = <STRING> <NEWLINE> while N > 0 : <NEWLINE> N -= 1 <NEWLINE> ans += chr ( ord ( <STRING> ) + N % 26 ) <NEWLINE> N //= 26 <NEWLINE> print ( ans [ : : - 1 ] ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> <NL> d = { ( i - 97 + 1 ) : chr ( i ) % 26 for i in range ( 97 , 97 + 26 ) } <NEWLINE> <COMMENT> <NL> <NL> l = [ ] <NEWLINE> <NL> while n > 0 : <NEWLINE> <INDENT> tmp = n % 26 <NEWLINE> l . append ( tmp ) <NEWLINE> if tmp == 0 : <NEWLINE> <INDENT> n = n // 26 - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> n //= 26 <NEWLINE> <NL> <DEDENT> <DEDENT> ans = <STRING> <NEWLINE> <NL> for i in l [ : : - 1 ] : <NEWLINE> <INDENT> ans += d [ i ] <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> ans = <STRING> <NEWLINE> for i in range ( 1 , 99 ) : <NEWLINE> <INDENT> if N <= 26 ** i : <NEWLINE> <INDENT> N -= 1 <NEWLINE> for j in range ( i ) : <NEWLINE> <INDENT> ans += chr ( ord ( <STRING> ) + N % 26 ) <NEWLINE> N //= 26 <NEWLINE> <DEDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> N -= 26 ** i <NEWLINE> <DEDENT> <DEDENT> print ( ans [ : : - 1 ] ) <NEWLINE>
def main ( ) : <NEWLINE> <COMMENT> <NL> <INDENT> N = int ( input ( ) ) <NEWLINE> l = list ( <STRING> ) <NEWLINE> <NL> name = [ ] <NEWLINE> n = N <NEWLINE> while n >= 26 : <NEWLINE> <INDENT> mod = n % 26 <NEWLINE> if mod != 0 : <NEWLINE> <INDENT> n //= 26 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> n //= 26 <NEWLINE> n -= 1 <NEWLINE> <DEDENT> name . append ( l [ mod ] ) <NEWLINE> <DEDENT> if mod != 0 : <NEWLINE> <INDENT> name . append ( l [ n ] ) <NEWLINE> <DEDENT> name = [ name [ n ] for n in reversed ( range ( len ( name ) ) ) ] <NEWLINE> print ( <STRING> . join ( name ) ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> ans = <STRING> <NEWLINE> whileN > 0 : <NEWLINE> <INDENT> N -= 1 <NEWLINE> ans += chr ( ord ( <STRING> ) + N % 26 ) <NEWLINE> N //= 26 <NEWLINE> <DEDENT> print ( ans [ : : - 1 ] ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> chars = <STRING> <NEWLINE> <NL> n_rem = n <NEWLINE> ans = <STRING> <NEWLINE> <NL> while True : <NEWLINE> <INDENT> x = n_rem % 26 <NEWLINE> if x == 0 : <NEWLINE> <INDENT> x = 26 <NEWLINE> <DEDENT> ans += chars [ x ] <NEWLINE> <NL> n_rem -= x <NEWLINE> <NL> if n_rem == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> n_rem //= = 26 <NEWLINE> <NL> <DEDENT> print ( ans [ : : - 1 ] ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = <STRING> <NEWLINE> name = <STRING> <NEWLINE> while n >= 26 : <NEWLINE> <INDENT> name . append ( a [ n % 26 ] ) <NEWLINE> n //= 26 <NEWLINE> <DEDENT> name . append ( a [ n ] ) <NEWLINE> print ( name ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> keta = 1 <NEWLINE> a = 26 <NEWLINE> while N > a : <NEWLINE> <INDENT> a *= 26 <NEWLINE> keta += 1 <NEWLINE> <DEDENT> ans = <STRING> <NEWLINE> for i in range ( keta - 1 , 0 , - 1 ) : <NEWLINE> <INDENT> a = N // ( 26 ** i ) - 1 <NEWLINE> N = N % ( 26 ** i ) <NEWLINE> ans += chr ( ord ( <STRING> ) + a ) <NEWLINE> <DEDENT> ans += chr ( ord ( <STRING> ) + N // ( 26 ** i ) ) <NEWLINE> print ( ans ) <NEWLINE>
n = input ( ) <NEWLINE> <NL> def num2alpha ( num ) : <NEWLINE> <INDENT> if num <= 26 : <NEWLINE> <INDENT> return chr ( 96 + num ) <NEWLINE> <DEDENT> elif num % 26 == 0 : <NEWLINE> <INDENT> return num2alpha ( num // 26 - 1 ) + chr ( 122 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return num2alpha ( num // 26 ) + chr ( 96 + num % 26 ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> print ( num2alpha ( n ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> ans = <STRING> <NEWLINE> while N > 26 : <NEWLINE> <INDENT> N , mod = divmod ( N , 26 ) <NEWLINE> if mod == 0 : mod = 26 <NEWLINE> ans += chr ( 96 + mod ) <NEWLINE> if N < 27 : break <NEWLINE> <DEDENT> ans += chr ( 96 + mod ) <NEWLINE> print ( ans [ : : - 1 ] ) <NEWLINE>
aalphabets = [ <STRING> ] + [ s for s in <STRING> ] <NEWLINE> <NL> s = int ( input ( ) ) <NEWLINE> <NL> nums = [ ] <NEWLINE> <NL> while s > 0 : <NEWLINE> <INDENT> nums . append ( ( s - 1 ) % 26 + 1 ) <NEWLINE> s = ( s - 1 ) // 26 <NEWLINE> <NL> <DEDENT> res = <STRING> <NEWLINE> <NL> for _ in range ( len ( nums ) ) : <NEWLINE> <INDENT> res = res + alphabets [ nums . pop ( ) ] <NEWLINE> <NL> <DEDENT> print ( res ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> ans = <STRING> <NEWLINE> while n > 0 : <NEWLINE> <INDENT> n = n - 1 <NEWLINE> s += chr ( ord ( <STRING> ) + ( n ) % 26 ) <NEWLINE> n //= 26 <NEWLINE> <DEDENT> ans = ans [ : : - 1 ] <NEWLINE> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> ans = <STRING> <NEWLINE> while N > 0 : <NEWLINE> <INDENT> N -= 1 <NEWLINE> ans += chr ( ord ( <STRING> ) + N % 26 ) N //= 26 <NEWLINE> <DEDENT> print ( ans [ : : - 1 ] ) <NEWLINE>
import sys <NEWLINE> <NL> def main ( n ) : <NEWLINE> <INDENT> c = <STRING> <NEWLINE> m = { } <NEWLINE> for i in range ( 0 , 26 ) : <NEWLINE> <INDENT> m [ i + 1 ] = c [ i ] <NEWLINE> <NL> <DEDENT> s = <STRING> <NEWLINE> while n > 0 : <NEWLINE> <INDENT> s = m [ ( n % 26 ) ] + s <NEWLINE> n /= 26 <NEWLINE> <DEDENT> return s <NEWLINE> <NL> <DEDENT> n = int ( sys . stdin . readline ( ) . strip ( ) ) <NEWLINE> print ( main ( n ) ) <NEWLINE>
import string <NEWLINE> <NL> <COMMENT> <NL> N = int ( input ( ) ) <NEWLINE> n_digits = len ( str ( 1000000000000001 ) ) <NEWLINE> letters = string . ascii_lowercase <NEWLINE> <NL> x = N <NEWLINE> ans = [ ] <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> while True : <NEWLINE> <INDENT> x -= 1 <NEWLINE> mod = x % 26 <NEWLINE> <COMMENT> <NL> x = x // 26 <NEWLINE> <NL> ans . append ( mod ) <NEWLINE> if div == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> ans = ans [ : : - 1 ] <NEWLINE> print ( <STRING> . join ( [ letters [ v ] for v in ans ] ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> chars = <STRING> <COMMENT> <NEWLINE> <NL> n_rem = n <COMMENT> <NEWLINE> res = <STRING> <NEWLINE> while True : <NEWLINE> <INDENT> x = n_rem % 26 <NEWLINE> if x == 0 : <NEWLINE> <INDENT> x = 26 <NEWLINE> <DEDENT> res += chars [ x ] <NEWLINE> n_rem -= x <NEWLINE> <NL> if n_rem == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> n_rem //= 26 <NEWLINE> <DEDENT> print ( res [ : : - 1 ] ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> <NL> S = [ <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> <NL> for j in range ( 0 , 1000000 ) : <NEWLINE> <INDENT> for i in range ( 0 , 26 ) : <NEWLINE> <INDENT> S . append ( S [ j ] + chr ( 96 + i ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( S [ N ] ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = [ ] <NEWLINE> while n > 0 : <NEWLINE> <INDENT> b = n % 26 <NEWLINE> if b == 0 : <NEWLINE> <INDENT> b = 26 <NEWLINE> t = 1 <NEWLINE> <DEDENT> c = lambda b : chr ( b + 64 ) <NEWLINE> a . append ( c ( b ) ) <NEWLINE> n //= 26 <NEWLINE> if t == 1 : <NEWLINE> <INDENT> n -= 1 <NEWLINE> t = 0 <NEWLINE> <DEDENT> <DEDENT> d = len ( a ) <NEWLINE> e = [ ] <NEWLINE> for i in range ( d ) : <NEWLINE> <INDENT> e . append ( a [ - 1 - i ] ) <NEWLINE> <DEDENT> ans = <STRING> . join ( e ) <NEWLINE> ans = ans . lower ( ) <NEWLINE> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = <STRING> <NEWLINE> <NL> if n == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> if n == 26 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> while n > 0 : <NEWLINE> <INDENT> if n % 26 == 1 : <NEWLINE> <INDENT> a += <STRING> <NEWLINE> <DEDENT> elif n % 26 == 2 : <NEWLINE> <INDENT> a += <STRING> <NEWLINE> <DEDENT> elif n % 26 == 3 : <NEWLINE> <INDENT> a += <STRING> <NEWLINE> <DEDENT> elif n % 26 == 4 : <NEWLINE> <INDENT> a += <STRING> <NEWLINE> <DEDENT> elif n % 26 == 5 : <NEWLINE> <INDENT> a += <STRING> <NEWLINE> <DEDENT> elif n % 26 == 6 : <NEWLINE> <INDENT> a += <STRING> <NEWLINE> <DEDENT> elif n % 26 == 7 : <NEWLINE> <INDENT> a += <STRING> <NEWLINE> <DEDENT> elif n % 26 == 8 : <NEWLINE> <INDENT> a += <STRING> <NEWLINE> <DEDENT> elif n % 26 == 9 : <NEWLINE> <INDENT> a += <STRING> <NEWLINE> <DEDENT> elif n % 26 == 10 : <NEWLINE> <INDENT> a += <STRING> <NEWLINE> <DEDENT> elif n % 26 == 11 : <NEWLINE> <INDENT> a += <STRING> <NEWLINE> <DEDENT> elif n % 26 == 12 : <NEWLINE> <INDENT> a += <STRING> <NEWLINE> <DEDENT> elif n % 26 == 13 : <NEWLINE> <INDENT> a += <STRING> <NEWLINE> <DEDENT> elif n % 26 == 14 : <NEWLINE> <INDENT> a += <STRING> <NEWLINE> <DEDENT> elif n % 26 == 15 : <NEWLINE> <INDENT> a += <STRING> <NEWLINE> <DEDENT> elif n % 26 == 16 : <NEWLINE> <INDENT> a += <STRING> <NEWLINE> <DEDENT> elif n % 26 == 17 : <NEWLINE> <INDENT> a += <STRING> <NEWLINE> <DEDENT> elif n % 26 == 18 : <NEWLINE> <INDENT> a += <STRING> <NEWLINE> <DEDENT> elif n % 26 == 19 : <NEWLINE> <INDENT> a += <STRING> <NEWLINE> <DEDENT> elif n % 26 == 20 : <NEWLINE> <INDENT> a += <STRING> <NEWLINE> <DEDENT> elif n % 26 == 21 : <NEWLINE> <INDENT> a += <STRING> <NEWLINE> <DEDENT> elif n % 26 == 22 : <NEWLINE> <INDENT> a += <STRING> <NEWLINE> <DEDENT> elif n % 26 == 23 : <NEWLINE> <INDENT> a += <STRING> <NEWLINE> <DEDENT> elif n % 26 == 24 : <NEWLINE> <INDENT> a += <STRING> <NEWLINE> <DEDENT> elif n % 26 == 25 : <NEWLINE> <INDENT> a += <STRING> <NEWLINE> <DEDENT> elif n % 26 == 0 : <NEWLINE> <INDENT> a += <STRING> <NEWLINE> n -= 26 <NEWLINE> <DEDENT> n = int ( n / 26 ) <NEWLINE> a = a [ : : - 1 ] <NEWLINE> print ( a ) <NEWLINE> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> <NL> s = 1 <NEWLINE> while N > 26 ** s : <NEWLINE> <INDENT> N -= 26 ** s <NEWLINE> s += 1 <NEWLINE> <NL> <DEDENT> ans = <STRING> <NEWLINE> N -= 1 <NEWLINE> for i in range ( s ) : <NEWLINE> <INDENT> ans += chr ( ord ( <STRING> ) + ord ( N % 26 ) ) <NEWLINE> N = N // 26 <NEWLINE> <NL> <DEDENT> print ( ans [ : : - 1 ] ) <NEWLINE>
s = <STRING> <NEWLINE> m = <STRING> <NEWLINE> while n : <NEWLINE> <COMMENT> <NL> <INDENT> if ( n % 26 == 0 ) : <NEWLINE> <INDENT> m += <STRING> <NEWLINE> else : <NEWLINE> <INDENT> m += s [ ( n % 26 ) - 1 ] <NEWLINE> n = ( n // 26 ) <NEWLINE> <COMMENT> <NL> m = m [ : : - 1 ] <NEWLINE> print ( m ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> ans = <STRING> <NEWLINE> while n > 0 : <NEWLINE> <INDENT> n -= 1 <NEWLINE> ans += chr ( ord ( <STRING> ) + ans % 26 ) <NEWLINE> n //= 26 <NEWLINE> <DEDENT> print ( ans [ : : - 1 ] ) <NEWLINE>
def resolve ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> flag = 0 <NEWLINE> name = [ ] <NEWLINE> if n < 27 : <NEWLINE> <INDENT> print ( chr ( i + 96 ) ) <NEWLINE> return <NEWLINE> <DEDENT> while n > 0 : <NEWLINE> <INDENT> c = n % 26 <NEWLINE> name . append ( c ) <NEWLINE> n //= 26 <NEWLINE> if n == 1 : <NEWLINE> <INDENT> flag = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> . join ( [ chr ( i + 96 ) for i in reversed ( name ) ] ) ) <NEWLINE> <NL> <DEDENT> resolve ( ) <NEWLINE>
from string import ascii_lowercase <NEWLINE> N = int ( input ( ) ) <NEWLINE> <NL> k = [ 0 , 26 ] <NEWLINE> for i in range ( 1 , 13 ) : <NEWLINE> <INDENT> k . append ( 26 * ( k [ i ] + 1 ) ) <NEWLINE> <NL> for i in range ( 13 ) : <NEWLINE> <INDENT> if k [ i ] + 1 <= N <= k [ i + 1 ] : <NEWLINE> <INDENT> n = N - ( k [ i ] + 1 ) <NEWLINE> for j in range ( i , - 1 , - 1 ) : <NEWLINE> <INDENT> print ( ascii_lowercase [ ( n // 26 ** j ) % 26 ] , end = <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT>
def base_convert ( nl , ibase , obase ) : <NEWLINE> <INDENT> o = [ ] <NEWLINE> while any ( nl ) : <NEWLINE> <INDENT> c = 0 <NEWLINE> for i in range ( len ( nl ) ) : <NEWLINE> <INDENT> c = c * ibase + nl [ i ] <NEWLINE> nl [ i ] , c = divmod ( c , obase ) <NEWLINE> <DEDENT> o . append ( c ) <NEWLINE> <DEDENT> o . reverse ( ) <NEWLINE> return o <NEWLINE> <NL> <DEDENT> def convertList ( lst ) : <NEWLINE> <INDENT> rev_lst = list ( reversed ( lst ) ) <NEWLINE> for i , num in enumerate ( rev_lst ) : <NEWLINE> <INDENT> if i < len ( rev_lst ) - 1 : <NEWLINE> <INDENT> if num <= 0 : <NEWLINE> <INDENT> rev_lst [ i + 1 ] = rev_lst [ i + 1 ] - 1 <NEWLINE> rev_lst [ i ] = rev_lst [ i ] + 26 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return list ( reversed ( rev_lst ) ) <NEWLINE> <NL> <DEDENT> N = input ( ) <NEWLINE> N = list ( map ( int , [ i for i in N ] ) ) <NEWLINE> lst = base_convert ( N , 10 , 26 ) <NEWLINE> lst_converted = convertList ( lst ) <NEWLINE> ans = <STRING> . join ( [ dict1 [ i ] for i in lst_converted ] ) <NEWLINE> print ( ans ) <NEWLINE>
N = input ( ) <NEWLINE> N = int ( N ) <NEWLINE> name = [ <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> <NL> S = 1 <NEWLINE> i = 0 <NEWLINE> Sum = 0 <NEWLINE> while Sum < N : <NEWLINE> <INDENT> S *= 26 <NEWLINE> Sum += S <NEWLINE> i = i + 1 <NEWLINE> <NL> <DEDENT> ans = [ ] <NEWLINE> for j in range ( i ) : <NEWLINE> <INDENT> N = N - 1 <NEWLINE> <INDENT> r = N % 26 <NEWLINE> ans . insert ( 0 , name [ r ] ) <NEWLINE> N = N // 26 <NEWLINE> <NL> <DEDENT> <DEDENT> ans = <STRING> . join ( ans ) <NEWLINE> print ( ans ) <NEWLINE> <NL> <NL>
N = int ( input ( ) ) <NEWLINE> alphabet = list ( <STRING> ) <NEWLINE> result = <STRING> <NEWLINE> while N > 0 : <NEWLINE> <INDENT> result = alphabet [ N % 26 ] + result <NEWLINE> if N % 26 == 0 : <NEWLINE> <INDENT> N -= 1 <NEWLINE> N //= 26 <NEWLINE> <DEDENT> <DEDENT> print ( result ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <NL> import sys <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> ans = <STRING> <NEWLINE> while N > 0 : <NEWLINE> N -= 1 <NEWLINE> ans += chr ( ord ( <STRING> ) + N % 26 ) <NEWLINE> N //= 26 <NEWLINE> print ( ans [ : : - 1 ] ) <NEWLINE>
import math <NEWLINE> n = int ( input ( ) ) <NEWLINE> <NL> al = [ chr ( ord ( <STRING> ) + i ) for i in range ( 26 ) ] <NEWLINE> <NL> <NL> <NL> ans = [ ] <NEWLINE> mod = 1 <NEWLINE> cnt = 0 <NEWLINE> while cnt >= 1 : <NEWLINE> <INDENT> k = math . floor ( n / 26 ) <NEWLINE> ans . append ( al [ k % 26 - 1 ] ) <NEWLINE> <NL> <DEDENT> print ( int ( <STRING> . join ( ans [ : : - 1 ] ) ) ) <NEWLINE>
abc171c <NEWLINE> n = int ( input ( ) ) <NEWLINE> s = <STRING> <NEWLINE> while n : <NEWLINE> <INDENT> n -= 1 <NEWLINE> s += chr ( n % 26 + 97 ) <NEWLINE> n //= 26 <NEWLINE> <DEDENT> print ( s [ : : - 1 ] ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> lis = [ chr ( i ) for i in range ( 97 , 97 + 26 ) ] <NEWLINE> ans = <STRING> <NEWLINE> while N > 0 : <NEWLINE> <INDENT> N -= 1 <NEWLINE> ans += lis [ N % 26 ] <NEWLINE> N = N // 26 <NEWLINE> <DEDENT> print ( ans [ : : - 1 ] <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = <STRING> <NEWLINE> while n : <NEWLINE> <INDENT> n -= 1 <NEWLINE> s = chr ( 97 + total % 26 ) + s <NEWLINE> n //= 26 <NEWLINE> <NL> <DEDENT> print ( s ) <NEWLINE>
import string <NEWLINE> def main ( ) : <NEWLINE> <INDENT> a = string . ascii_lowercase <NEWLINE> list = [ ] <NEWLINE> num = int ( input ( ) ) <NEWLINE> <NL> while ( num >= 0 ) : <NEWLINE> <INDENT> list . append ( num % 26 ) <NEWLINE> num = num // 26 <NEWLINE> <NL> <DEDENT> ans = [ ] <NEWLINE> for i in range ( 1 , len ( list ) + 1 ) : <NEWLINE> <INDENT> ans . append ( a [ list [ len ( list ) - i ] - 1 ] ) <NEWLINE> <NL> <DEDENT> print ( <STRING> . join ( ans ) ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> l = [ ] <NEWLINE> while n : <NEWLINE> <INDENT> N -= 1 <NEWLINE> l . append ( chr ( 97 + ( n % 26 ) ) ) <NEWLINE> n //= 26 <NEWLINE> <NL> <DEDENT> print ( <STRING> . join ( l [ : : - 1 ] ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> ans = [ ] <NEWLINE> <NL> s == 0 <NEWLINE> while 1 : <NEWLINE> <INDENT> if s == 1 and n < 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> s = 1 <NEWLINE> if n % 26 == 0 : <NEWLINE> <INDENT> ans . append ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans . append ( n % 26 ) <NEWLINE> <DEDENT> n -= n % 26 <NEWLINE> n = n // 26 <NEWLINE> <DEDENT> for i in range ( len ( ans ) ) : <NEWLINE> <INDENT> if i != len ( ans ) - 1 : <NEWLINE> <INDENT> if ans [ i ] <= 0 : <NEWLINE> <INDENT> ans [ i + 1 ] -= 1 <NEWLINE> ans [ i ] += 26 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if ans [ i ] <= 0 : <NEWLINE> <INDENT> del ans [ i ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> ans = ans [ : : - 1 ] <NEWLINE> for i in range ( len ( ans ) ) : <NEWLINE> <INDENT> print ( chr ( 96 + ans [ i ] ) , end = <STRING> ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> ans = <STRING> <NEWLINE> <NL> al = [ <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <NEWLINE> <INDENT> <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> <NL> <DEDENT> while n > 0 : <NEWLINE> <INDENT> tmp = n % 26 <NEWLINE> if tmp > 0 : <NEWLINE> <INDENT> ans += al [ tmp - 1 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += <STRING> <NEWLINE> n -= 1 <NEWLINE> <DEDENT> n /= 26 <NEWLINE> if n == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans [ : : - 1 ] ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> ans = <STRING> <NEWLINE> <NL> for i in range ( 1 , 99 ) : <NEWLINE> <INDENT> if n <= 26 ** i : <NEWLINE> <INDENT> n -= 1 <NEWLINE> for j in range ( i ) : <NEWLINE> <INDENT> ans += chr ( ord ( <STRING> ) + N % 26 ) <NEWLINE> n //= 26 <NEWLINE> <DEDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> n -= 26 ** i <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans [ : : - 1 ] ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> chars = <STRING> ) <NEWLINE> N_rem = N <NEWLINE> res = <STRING> <NEWLINE> while True : <NEWLINE> <INDENT> x = N_rem % 26 <NEWLINE> if x == 0 : <NEWLINE> <INDENT> x = 26 <NEWLINE> <DEDENT> res += chars [ x ] <NEWLINE> N_rem -= x <NEWLINE> if N - rem == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> N_rem //= 26 <NEWLINE> <DEDENT> print ( res [ : : - 1 ] ) <NEWLINE>
al = [ chr ( ord ( <STRING> ) + i ) for i in range ( 26 ) ] <NEWLINE> n = int ( input ( ) ) <NEWLINE> s = <STRING> <NEWLINE> while n : <NEWLINE> <INDENT> s += al [ a % 26 - 1 ] <NEWLINE> n = ( n - 1 ) // 26 <NEWLINE> <DEDENT> print ( s [ : : - 1 ] ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> alpha = [ <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> <NL> def find_name ( tmp_N , p , keta , alpha ) : <NEWLINE> <INDENT> if keta == 1 : <NEWLINE> <INDENT> for i in range ( len ( alpha ) ) : <NEWLINE> <COMMENT> <NL> <INDENT> if tmp_N + ( i + 1 ) == N : <NEWLINE> <INDENT> p . append ( i ) <NEWLINE> return p <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( len ( alpha ) ) : <NEWLINE> <COMMENT> <NL> <INDENT> if tmp_N + 26 ** ( keta - 1 ) * i + 1 <= N <= tmp_N + 26 ** ( keta - 1 ) * ( i + 1 ) : <NEWLINE> <COMMENT> <NL> <INDENT> p . append ( i ) <NEWLINE> tmp_N = tmp_N + 26 ** ( keta - 1 ) * i <NEWLINE> keta -= 1 <NEWLINE> return find_name ( tmp_N , p , keta , alpha ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> keta = 1 <NEWLINE> while 1 : <NEWLINE> <INDENT> tmp_N = 26 ** ( keta - 1 ) <NEWLINE> if tmp_N + 26 ** ( keta - 1 ) + 1 <= N <= tmp_N + 26 ** keta : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> keta += 1 <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> tmp_N = 0 <NEWLINE> if keta == 1 : <NEWLINE> <INDENT> tmp_N = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> tmp_N = 26 ** ( keta - 1 ) <NEWLINE> <COMMENT> <NL> <DEDENT> p = [ ] <NEWLINE> p = find_name ( tmp_N , p , keta , alpha ) <NEWLINE> out = <STRING> <NEWLINE> <COMMENT> <NL> for i in range ( len ( p ) ) : <NEWLINE> <INDENT> out += alpha [ p [ i ] ] <NEWLINE> <DEDENT> print ( out ) <NEWLINE> <NL>
<NL> def main ( ) : <NEWLINE> <INDENT> import collections <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A_s = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> Q = int ( input ( ) ) <NEWLINE> <NL> summ = sum ( A_s ) <NEWLINE> CNT_A = collections . Counter ( A_s ) <NEWLINE> <NL> <NL> for i in range ( Q ) : <NEWLINE> <INDENT> before , after = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> tmp_cnt = CNT_A [ before ] <NEWLINE> <NL> if ( tmp_cnt > 0 ) : <NEWLINE> <INDENT> tmp_before = CNT_A [ before ] * ( after - before ) <NEWLINE> summ += tmp_before <NEWLINE> <NL> N_before = CNT_A [ before ] <NEWLINE> <NL> del CNT_A [ before ] <NEWLINE> N_after = CNT_A [ after ] <NEWLINE> <NL> if ( N_after > 0 ) : <NEWLINE> <INDENT> CNT_A [ after ] = N_after + N_before <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> CNT_A [ after ] = N_before <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> print ( summ ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> <NL> s = [ ] <NEWLINE> k = 0 <NEWLINE> while N > 0 : <NEWLINE> <INDENT> l = N % 26 // 一番下のけた <NEWLINE> s . insert ( 0 , chr ( ord ( <STRING> ) + l - 1 ) ) <NEWLINE> N = N // 26 <NEWLINE> k += 1 <NEWLINE> <NL> <DEDENT> print ( s ) <NEWLINE> print ( join ( s ) ) <NEWLINE>
x = int ( input ( ) ) <NEWLINE> <NL> alphbet = lambda c : chr ( c + 64 ) <NEWLINE> <NL> def Base_10_to_n ( X , n ) : <NEWLINE> <INDENT> X_dumy = X <NEWLINE> out = [ ] <NEWLINE> while X_dumy > 0 : <NEWLINE> <INDENT> out . append ( X_dumy % n ) <NEWLINE> X_dumy = int ( X_dumy / n ) <NEWLINE> <DEDENT> return out <NEWLINE> <DEDENT> out = Base_10_to_n ( x , 26 ) . reverse ( ) <NEWLINE> print ( <STRING> . join ( alphbet ( i ) for i in out ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> ans = <STRING> <NEWLINE> <NL> while N > 0 : <NEWLINE> <INDENT> N -= 1 <NEWLINE> ans += chr ( ord ( <STRING> ) + N % 26 ) . lower ( ) <NEWLINE> N = N // 26 <NEWLINE> <INDENT> print ( ans [ : : - 1 ] ) <NEWLINE> <DEDENT> <DEDENT>
def resolve ( ) : <NEWLINE> <COMMENT> <NL> <INDENT> from collections import deque <NEWLINE> S = <STRING> <NEWLINE> N = int ( input ( ) ) <NEWLINE> tmp = N <NEWLINE> A = deque ( ) <NEWLINE> <NL> while True : <NEWLINE> <INDENT> N , a = divmod ( N , 26 ) <NEWLINE> A . append ( a ) <NEWLINE> if N == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> print ( N , a , file = sys . stderr ) <NEWLINE> if tmp % 26 == 0 : <NEWLINE> <INDENT> A . pop ( ) <NEWLINE> <DEDENT> for a in reversed ( A ) : <NEWLINE> <INDENT> print ( S [ a - 1 ] , end = <STRING> ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> <NL> <DEDENT> resolve ( ) <NEWLINE>
<INDENT> a_list = [ chr ( ord ( <STRING> ) + i ) for i in range ( 26 ) ] <NEWLINE> <DEDENT> n = int ( input ( ) ) <NEWLINE> <NL> l_list = [ ] <NEWLINE> ans = <STRING> <NEWLINE> while n > 0 : <NEWLINE> <NL> <INDENT> if n % 26 == 0 : <NEWLINE> <INDENT> l_list . append ( 25 ) <NEWLINE> n = n // 26 - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> l_list . append ( n % 26 ) <NEWLINE> n = n // 26 <NEWLINE> <DEDENT> <DEDENT> l_list = l_list [ : : - 1 ] <NEWLINE> for i in l_list : <NEWLINE> <INDENT> ans += a_list [ i ] <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
1 N = int ( input ( ) ) <NEWLINE> 2 ans = <STRING> <NEWLINE> 3 while N > 0 : <NEWLINE> 4 N -= 1 <NEWLINE> 5 ans += chr ( ord ( <STRING> ) + N % 26 ) <NEWLINE> 6 N //= 26 <NEWLINE> 7 print ( ans [ : : - 1 ] ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> alphabet = [ chr ( i ) for i in range ( 97 , 97 + 26 ) ] <NEWLINE> <NL> n = 1 <NEWLINE> s = 26 <NEWLINE> for i in range ( 1 , 12 ) : <NEWLINE> <INDENT> if N <= s : <NEWLINE> <INDENT> n = i <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s += 26 ** ( i + 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> s = 0 <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> s += 26 ** i <NEWLINE> <NL> <DEDENT> N = N - s - 1 <NEWLINE> if N == 0 : <NEWLINE> <INDENT> Ans = <STRING> <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> Ans += <STRING> <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> while N > 0 : <NEWLINE> <INDENT> L . append ( N % 26 ) <NEWLINE> N = N // 26 <NEWLINE> <NL> <DEDENT> Ans = <STRING> <NEWLINE> for x in reversed ( L ) : <NEWLINE> <INDENT> Ans += alphabet [ x ] <NEWLINE> <DEDENT> <DEDENT> print ( Ans ) <NEWLINE>
import string <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> alphabets = string . ascii_lowercase <NEWLINE> answer = [ ] <NEWLINE> while n >= 1 : <NEWLINE> <INDENT> n -= 1 <NEWLINE> <INDENT> answer . append ( alphabets [ n % 26 ] ) <NEWLINE> n = n // 26 <NEWLINE> <DEDENT> <DEDENT> ans = <STRING> . join ( list ( reversed ( answer ) ) ) <NEWLINE> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> <NL> ans = <STRING> <NEWLINE> <NL> while N > 0 : <NEWLINE> <INDENT> N -= 1 <NEWLINE> ans += chr ( ord ( <STRING> ) + N % 26 ) <NEWLINE> <INDENT> N = N // 26 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans [ : : - 1 ] ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> ans = <STRING> <NEWLINE> <NL> for i in range ( 1 , 99 ) : <NEWLINE> <INDENT> if N <= 26 ** i : <NEWLINE> <INDENT> N -= 1 <NEWLINE> for j in range ( i ) : <NEWLINE> <INDENT> ans += chr ( ord ( <STRING> ) + N % 26 ) <NEWLINE> N //= 26 <NEWLINE> <DEDENT> break <NEWLINE> else : <NEWLINE> N -= 26 ** i <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans [ : : - 1 ] ) <COMMENT> <NEWLINE>
N = int ( input ( ) ) <NEWLINE> 2 ans = <STRING> <NEWLINE> 3 while N > 0 : <NEWLINE> 4 N -= 1 <NEWLINE> 5 ans += chr ( ord ( <STRING> ) + N % 26 ) <NEWLINE> 6 N //= 26 <NEWLINE> 7 print ( ans [ : : - 1 ] ) <NEWLINE>
def solve ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> k = 1 <NEWLINE> while N > pow ( 26 , k ) : <NEWLINE> <INDENT> N -= pow ( 26 , k ) <NEWLINE> k += 1 <NEWLINE> <DEDENT> ans = <STRING> <NEWLINE> N -= 1 <NEWLINE> for i in range ( k , 1 , - 1 ) : <NEWLINE> <INDENT> ans += chr ( ord ( <STRING> ) + N // pow ( 26 , i - 1 ) ) <NEWLINE> N %= pow ( 26 , i - 1 ) <NEWLINE> <DEDENT> ans += chr ( ord ( <STRING> ) + N % pow ( 26 , i ) ) <NEWLINE> return ans <NEWLINE> <DEDENT> print ( solve ( ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> ans = <STRING> <NEWLINE> <NL> while True : <NEWLINE> <INDENT> if N <= 26 ** i : <NEWLINE> <INDENT> N -= 1 <NEWLINE> for j i in range ( N ) : <NEWLINE> <INDENT> ans += chr ( ord ( <STRING> ) + N % 26 ) <NEWLINE> N //= 26 <NEWLINE> <DEDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> N -= 26 ** i <NEWLINE> <DEDENT> <DEDENT> print ( ans [ : : - 1 ] ) <NEWLINE>
def run ( n ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> _base_array = string . ascii_lowercase <NEWLINE> results = [ ] <NEWLINE> while n > 0 : <NEWLINE> <INDENT> results . append ( _base_array [ n % 26 - 1 ] ) <NEWLINE> if n % 26 == 0 : <NEWLINE> <INDENT> n = n // 26 - 1 <NEWLINE> continue <NEWLINE> <DEDENT> n = n // 26 <NEWLINE> <NL> <DEDENT> print ( <STRING> . join ( results [ : : - 1 ] ) ) <NEWLINE> <NL> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> run ( n ) <NEWLINE> <DEDENT>
x = input ( ) <NEWLINE> <NL> def converter ( x ) : <NEWLINE> <INDENT> if x <= 26 : <NEWLINE> <INDENT> y = chr ( x + 96 ) <NEWLINE> <DEDENT> elif x % 26 == 0 : <NEWLINE> <INDENT> y = converter ( x // 26 ) + converter ( 26 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> y = converter ( x // 26 ) + converter ( x % 26 ) <NEWLINE> <DEDENT> return y <NEWLINE> <NL> <DEDENT> name = converter ( x ) <NEWLINE> <NL> print ( name ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> ans = [ ] <NEWLINE> while n != 0 : <NEWLINE> <INDENT> o = chr ( n % 26 + 96 ) <NEWLINE> ans . append ( o ) <NEWLINE> n //= 26 <NEWLINE> <DEDENT> ans = reversed ( ans ) <NEWLINE> print ( <STRING> . join ( ans ) ) n = int ( input ( ) ) <NEWLINE> ans = [ ] <NEWLINE> while n != 0 : <NEWLINE> <INDENT> o = chr ( n % 26 + 96 ) <NEWLINE> ans . append ( o ) <NEWLINE> n //= 26 <NEWLINE> <DEDENT> ans = reversed ( ans ) <NEWLINE> print ( <STRING> . join ( ans ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> name = <STRING> <NEWLINE> while N > 0 : <NEWLINE> <INDENT> N -= 1 <NEWLINE> ans += chr ( ord ( <STRING> ) + N % 26 ) <NEWLINE> N = N // 26 <NEWLINE> <DEDENT> print ( name [ : : - 1 ] ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> def change ( ) : <COMMENT> <NEWLINE> <NL> p = [ ] <NEWLINE> while n > 0 : <NEWLINE> <INDENT> a = n % 26 <NEWLINE> p . append ( a ) <NEWLINE> n = n // 26 <NEWLINE> <NL> <DEDENT> for i in range ( len ( p ) ) : <NEWLINE> <INDENT> p [ i ] = change ( p [ i ] ) <NEWLINE> <NL> <DEDENT> p . reverse ( ) <NEWLINE> <NL> b = <STRING> <NEWLINE> <NL> for i in range ( len ( p ) ) : <NEWLINE> <INDENT> b += p [ i ] <NEWLINE> <NL> <DEDENT> print ( b ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> def alpha2num ( alpha ) : <NEWLINE> <INDENT> num = 0 <NEWLINE> for index , item in enumerate ( list ( alpha ) ) : <NEWLINE> <INDENT> num += pow ( 26 , len ( alpha ) - index - 1 ) * ( ord ( item ) - ord ( <STRING> ) + 1 ) <NEWLINE> <DEDENT> return num <NEWLINE> <DEDENT> if 1 <= n <= 26 : <NEWLINE> <INDENT> n = n <NEWLINE> print ( alpha2num ( n ) ) <NEWLINE> <DEDENT> elif 27 <= n <= 702 : <NEWLINE> <INDENT> n -= 26 <NEWLINE> print ( alpha2num ( n ) ) <NEWLINE> <DEDENT> elif 703 <= n <= 18278 : <NEWLINE> <INDENT> n -= 702 <NEWLINE> print ( alpha2num ( n ) ) <NEWLINE> <DEDENT> elif 18279 <= n <= 475254 : <NEWLINE> <INDENT> n -= 18278 <NEWLINE> print ( alpha2num ( n ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> n -= 475254 <NEWLINE> print ( alpha2num ( n ) ) <NEWLINE> <DEDENT>
def num2alpha ( num ) : <NEWLINE> <INDENT> if num <= 26 : <NEWLINE> <INDENT> return chr ( 64 + num ) <NEWLINE> <DEDENT> elif num % 26 == 0 : <NEWLINE> <INDENT> return num2alpha ( num // 26 - 1 ) + chr ( 90 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return num2alpha ( num // 26 ) + chr ( 64 + num % 26 ) <NEWLINE> <NL> <DEDENT> <DEDENT> N = int ( input ( ) ) <NEWLINE> input ( num2alpha ( N ) . lower ( ) ) <NEWLINE>
n = input ( ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> ans = <STRING> <NEWLINE> for i in range ( 1 , 99 ) : <NEWLINE> <INDENT> if N <= 26 ** i : <NEWLINE> <INDENT> N -= 1 <NEWLINE> for j in range ( i ) : <NEWLINE> <INDENT> ans += chr ( ord ( <STRING> ) + N % 26 ) <NEWLINE> N //= 26 <NEWLINE> <DEDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> N -= 26 ** i <NEWLINE> <DEDENT> <DEDENT> print ( ans [ : : - 1 ] ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> abc = <STRING> <NEWLINE> s = <STRING> <NEWLINE> while n > 0 : <NEWLINE> <INDENT> n -= 1 <NEWLINE> n , mod = divmod ( n , 26 ) <NEWLINE> s += a [ mod ] <NEWLINE> <DEDENT> print ( s [ : : - 1 ] ) <NEWLINE>
n = int ( input ( ) ) - 1 <NEWLINE> j = 26 <NEWLINE> while j <= n : <NEWLINE> <INDENT> n -= j <NEWLINE> j *= 26 <NEWLINE> <DEDENT> j /= 26 <NEWLINE> ret = <STRING> <NEWLINE> while j : <NEWLINE> <INDENT> ret += <STRING> [ n // j ] <NEWLINE> n %= j <NEWLINE> j /= 26 <NEWLINE> <DEDENT> print ( ret ) <NEWLINE>
<COMMENT> <NL> import bisect <NEWLINE> alphabet = <STRING> <NEWLINE> n = int ( input ( ) ) <NEWLINE> cnt = 0 <NEWLINE> amari = [ ] <NEWLINE> <NL> <COMMENT> <NL> niroku = [ 1 ] <NEWLINE> for i in range ( 1 , 15 ) : <NEWLINE> <INDENT> a = niroku [ - 1 ] <NEWLINE> niroku . append ( a + 26 ** i ) <NEWLINE> <NL> <DEDENT> idx = bisect . bisect_left ( niroku , n ) <NEWLINE> <NL> n = n - niroku [ idx - 1 ] + 1 <NEWLINE> z_cnt = idx - 1 <NEWLINE> <COMMENT> <NL> while n // 26 > 0 : <NEWLINE> <INDENT> n_before = n <NEWLINE> amari . append ( str ( n % 26 ) ) <NEWLINE> a = n % 26 <NEWLINE> n = n // 26 <NEWLINE> cnt += 1 <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> if int ( <STRING> . join ( amari ) ) != 0 : <NEWLINE> <INDENT> amari . append ( str ( n ) ) <NEWLINE> <DEDENT> amari . reverse ( ) <NEWLINE> <COMMENT> <NL> result = [ ] <NEWLINE> <NL> for i in range ( len ( amari ) ) : <NEWLINE> <INDENT> result . append ( alphabet [ int ( amari [ i ] ) - 1 ] ) <NEWLINE> <NL> <DEDENT> for i in range ( z_cnt ) : <NEWLINE> <INDENT> result [ i ] = <STRING> <NEWLINE> <NL> <DEDENT> print ( <STRING> . join ( result ) ) <NEWLINE>
<NL> <INDENT> k = 0 <NEWLINE> <DEDENT> ans = [ ] <NEWLINE> while k < 1 : <NEWLINE> <INDENT> if num <= 26 : <NEWLINE> <INDENT> ans . append ( ( chr ( 96 + num ) ) ) <NEWLINE> k = 1 <NEWLINE> <DEDENT> elif num % 26 == 0 : <NEWLINE> <INDENT> num = ( num // 26 - 1 ) <NEWLINE> ans . append ( ( chr ( 96 + 26 ) ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans . append ( ( chr ( 96 + num % 26 ) ) ) <NEWLINE> num = ( num // 26 ) <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( len ( ans ) - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> print ( ans [ i ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans [ i ] , end = <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
p = [ pow ( 26 , i ) for i in range ( 17 ) ] <NEWLINE> num = [ 0 for i in range ( 17 ) ] <NEWLINE> chars = [ <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> for i in range ( 17 ) : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if i == 1 : <NEWLINE> <INDENT> num [ i ] = 26 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> num [ i ] = num [ i - 1 ] + p [ i ] <NEWLINE> <DEDENT> <DEDENT> n = int ( input ( ) ) <NEWLINE> ans = <STRING> <NEWLINE> l = 0 <NEWLINE> while n > nums [ l ] : <NEWLINE> <INDENT> l += 1 <NEWLINE> <DEDENT> x = n - nums [ l - 1 ] - 1 <NEWLINE> for _ in range ( l ) : <NEWLINE> <INDENT> c = chr ( ord ( <STRING> ) + x % 26 ) <NEWLINE> ans = c + ans <NEWLINE> x //= 26 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n = input ( ) <NEWLINE> chars = <STRING> <NEWLINE> n_rem = n <NEWLINE> ans = <STRING> <NEWLINE> <NL> while True : <NEWLINE> <INDENT> x = n_rem % 26 <NEWLINE> if x == 0 : <NEWLINE> <INDENT> x = 26 <NEWLINE> <DEDENT> ans += chars [ x ] <NEWLINE> n_rem -= x <NEWLINE> if n_rem == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> n_rem //= 26 <NEWLINE> <DEDENT> print ( ans [ : : - 1 ] ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = <STRING> <NEWLINE> while n > 0 : <NEWLINE> <INDENT> n -= 1 <NEWLINE> ans += chr ( ord ( <STRING> ) + n % 26 ) <NEWLINE> n //= 26 <NEWLINE> <NL> <DEDENT> print ( ans [ : : - 1 ] ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> while n >= 0 : <NEWLINE> <INDENT> n = n - 1 <COMMENT> <NEWLINE> z += chr ( n % 26 + ord ( <STRING> ) ) <NEWLINE> n = n // 26 <NEWLINE> <DEDENT> print ( z [ : : - 1 ] ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> resposta = <STRING> <NEWLINE> <NL> while n > 26 : <NEWLINE> <INDENT> resposta += alfabeto [ ( n % 26 ) - 1 ] <NEWLINE> n = ( n // 26 ) <NEWLINE> <NL> <NL> <DEDENT> resposta += alfabeto [ ( n % 26 ) - 1 ] <NEWLINE> resposta = resposta [ : : - 1 ] <NEWLINE> <NL> print ( resposta ) <NEWLINE>
n = input ( ) <NEWLINE> name = <STRING> <NEWLINE> <NL> while ( True ) : <NEWLINE> <INDENT> i = n % 26 <NEWLINE> n = <STRING> [ i ] <NEWLINE> name = n + name <NEWLINE> <NL> n = ( n - i ) / 26 <NEWLINE> if ( n == 0 ) : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( name ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> ans = <STRING> <NEWLINE> while N > 0 : <NEWLINE> <INDENT> N -= 1 <NEWLINE> ans += chr ( ord ( <STRING> + N % 26 ) ) <NEWLINE> N //= 26 <NEWLINE> <DEDENT> print ( ans [ : : - 1 ] ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> <NL> def num2alpha ( num ) : <NEWLINE> <INDENT> if num <= 26 : <NEWLINE> <INDENT> return chr ( 64 + num ) <NEWLINE> <DEDENT> elif num % 26 == 0 : <NEWLINE> <INDENT> return num2alpha ( num // 26 - 1 ) + chr ( 90 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return num2alpha ( num // 26 ) + chr ( 64 + num % 26 ) <NEWLINE> <NL> <DEDENT> <DEDENT> return num2alpha ( N ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> m = n <NEWLINE> <NL> count = 0 <NEWLINE> for i in range ( 1 , 100 ) : <NEWLINE> <INDENT> if n >= 26 ** i : <NEWLINE> <INDENT> n = n - 26 ** i <NEWLINE> count += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> a = [ ] <NEWLINE> b = list ( <STRING> ) <NEWLINE> <COMMENT> <NL> count2 = 0 <NEWLINE> while 1 : <NEWLINE> <COMMENT> <NL> <INDENT> count2 = n // ( 26 ** count ) <NEWLINE> n = n % 26 ** count <NEWLINE> if n < 26 ** count : <NEWLINE> <INDENT> a . append ( count2 ) <NEWLINE> <DEDENT> count -= 1 <NEWLINE> if count == 0 : <NEWLINE> <INDENT> a . append ( n - 1 ) <NEWLINE> break <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> x = [ b [ a [ i ] ] for i in range ( len ( a ) ) ] <NEWLINE> print ( <STRING> . join ( x ) ) <NEWLINE> <NL>
<COMMENT> <NL> <INDENT> N = int ( input ( ) ) <NEWLINE> ans = resolver ( N ) <NEWLINE> <NL> print ( ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> num = 0 <NEWLINE> ans = <STRING> <NEWLINE> for i in range ( 1 , 9 ) : <NEWLINE> <INDENT> if 26 ** i > N : <NEWLINE> <INDENT> N -= 1 <NEWLINE> for j in range ( i ) : <NEWLINE> <INDENT> ans += chr ( ord ( <STRING> ) + N % 26 ) <NEWLINE> N //= 26 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> N -= 26 ** i <NEWLINE> <DEDENT> <DEDENT> print ( ans [ : : - 1 ] ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> ans = <STRING> <NEWLINE> while N > 0 : <NEWLINE> N -= 1 <NEWLINE> ans += chr ( ord ( <STRING> ) + N % 26 ) <NEWLINE> N //= 26 <NEWLINE> print ( ans [ : : - 1 ] ) <NEWLINE>
n = int ( input ( ) ) - 1 <NEWLINE> if n != 0 : <NEWLINE> <INDENT> res = [ ] <NEWLINE> for b in reversed ( basis ) : <NEWLINE> <INDENT> res . append ( n // b ) <NEWLINE> n = n % b <NEWLINE> <NL> <DEDENT> ans = [ ] <NEWLINE> flag = False <NEWLINE> for x in res : <NEWLINE> <INDENT> if x != 0 : <NEWLINE> <INDENT> flag = True <NEWLINE> <DEDENT> if flag : <NEWLINE> <INDENT> ans . append ( chr ( ord ( <STRING> ) + x ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> . join ( ans ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> ans = <STRING> <NEWLINE> while n > 0 : <NEWLINE> <INDENT> n -= 1 <NEWLINE> ans += chr ( ord ( <STRING> ) + N % 26 ) <NEWLINE> n //= 26 <NEWLINE> print ( ans [ : : - 1 ] ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> ans = [ <STRING> ] <NEWLINE> <NL> quo = n <NEWLINE> rem = 0 <NEWLINE> <NL> while True : <NEWLINE> <INDENT> rem = quo % 26 <NEWLINE> quo = quo // 26 <NEWLINE> if rem == 0 : <NEWLINE> <INDENT> ans . insert ( 0 , <STRING> ) <NEWLINE> if quo < 2 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <NL> if quo == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( * ans , sep = <STRING> ) <NEWLINE>
for _ in range ( int ( input ( ) ) ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> d = [ <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> a = <STRING> <NEWLINE> while n : <NEWLINE> <INDENT> n -= 1 <NEWLINE> a = d [ n % 26 ] + a <NEWLINE> n //= 26 <NEWLINE> <DEDENT> print ( a ) <NEWLINE> <DEDENT>
import math <NEWLINE> from decimal import Decimal <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> <NL> res = <STRING> <NEWLINE> <NL> alp = <STRING> <NEWLINE> <NL> while N > 0 : <NEWLINE> <INDENT> if N > 26 : <NEWLINE> <NL> <INDENT> NN = N // 26 <NEWLINE> m = N - NN * 26 <NEWLINE> N = N // 26 <NEWLINE> <COMMENT> <NL> res = alp [ m ] + res <NEWLINE> <DEDENT> else : <NEWLINE> <COMMENT> <NL> <INDENT> res = alp [ m ] + res <NEWLINE> N = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( res ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> ans = <STRING> <NEWLINE> <NL> while num > 0 : <NEWLINE> <INDENT> N -= 1 <NEWLINE> ans += chr ( ord ( <STRING> ) + N % 26 ) <NEWLINE> N //= 26 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> k = [ ] <NEWLINE> def a ( i ) : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> return 26 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return i <NEWLINE> <DEDENT> <DEDENT> while n > 26 : <NEWLINE> <INDENT> k += [ chr ( 96 + a ( n % 26 ) ) ] <NEWLINE> if n % 26 == 0 : <NEWLINE> <INDENT> n = n // 26 - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> n //= 26 <NEWLINE> <DEDENT> <DEDENT> k += [ chr ( 96 + a ( n ) ) ] <NEWLINE> print ( z + 1 , <STRING> . join ( k [ : : - 1 ] ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> ans = <STRING> <NEWLINE> for i in range ( 1 , 99 ) : <NEWLINE> <INDENT> if N <= 26 ** i : <NEWLINE> N -= 1 <NEWLINE> for j in range ( i ) : <NEWLINE> ans += chr ( ord ( <STRING> ) + N % 26 ) <NEWLINE> N //= 26 <NEWLINE> break <NEWLINE> else : <NEWLINE> N -= 26 ** i <NEWLINE> print ( ans [ : : - 1 ] ) <COMMENT> <NEWLINE> <DEDENT>
num = int ( input ( ) ) <NEWLINE> ans = <STRING> <NEWLINE> while num > 26 : <NEWLINE> <INDENT> num , rest = divmod ( num , 26 ) <NEWLINE> ans += s [ rest - 1 ] <NEWLINE> <COMMENT> <NL> <DEDENT> ans += s [ num - 1 ] <NEWLINE> print ( ans [ : : - 1 ] ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> chars = <STRING> ) <NEWLINE> res = <STRING> <NEWLINE> n_rem = N <NEWLINE> while True : <NEWLINE> <INDENT> x = n_rem % 26 <NEWLINE> if x == 0 : <NEWLINE> <INDENT> x = 26 <NEWLINE> <DEDENT> res += chars [ x ] <NEWLINE> n_rem -= x <NEWLINE> if n_rem == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> n_rem //= 26 <NEWLINE> <DEDENT> print ( res [ : : - 1 ] ) <NEWLINE> <NL>
n = input ( ) <NEWLINE> <NL> data = [ <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> <NL> q , mod = divmod ( n - 1 , 26 ) <NEWLINE> print ( q , mod ) <NEWLINE> answer = data [ mod ] <NEWLINE> <NL> while q >= 1 : <NEWLINE> <INDENT> q , mod = divmod ( q - 1 , 26 ) <NEWLINE> print ( q , mod ) <NEWLINE> answer = data [ mod ] + answer <NEWLINE> <NL> <DEDENT> print ( answer ) <NEWLINE> <NL>
strings = sorted ( a ) <NEWLINE> N = int ( input ( ) ) <NEWLINE> <NL> <NL> set_index = <STRING> <NEWLINE> while N > 0 : <NEWLINE> <INDENT> N -= 1 <NEWLINE> index = ( N % 26 ) + ord ( <STRING> ) <NEWLINE> set_index += chr ( index ) <NEWLINE> N //= 26 <NEWLINE> <DEDENT> print ( set_index [ : : - 1 ] ) <NEWLINE>
<NL> n = int ( input ( ) ) <NEWLINE> <NL> <NL> def num2alpha ( num ) : <NEWLINE> <INDENT> if num <= 26 : <NEWLINE> <INDENT> return chr ( 64 + num ) <NEWLINE> <DEDENT> elif num % 26 == 0 : <NEWLINE> <INDENT> return num2alpha ( num // 26 - 1 ) + chr ( 90 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return num2alpha ( num // 26 ) + chr ( 64 + num % 26 ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> print ( num2alpha ( n ) . lower ( ) ) <NEWLINE> z <NEWLINE>
N = int ( input ( ) ) <NEWLINE> eList = [ <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> n = N <NEWLINE> mod = N <NEWLINE> numList = [ ] <NEWLINE> <NL> while n > 0 : <NEWLINE> <INDENT> n , mod = divmod ( n , 26 ) <NEWLINE> if mod != 0 : <NEWLINE> <INDENT> numList . insert ( 0 , mod - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> numList . insert ( 0 , 25 ) <NEWLINE> n -= 1 <NEWLINE> <DEDENT> <DEDENT> for num in numList : <NEWLINE> <INDENT> ans += eList [ num ] <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> import sys <NEWLINE> <NL> N = int ( sys . stdin . readline ( ) ) <NEWLINE> <NL> <NL> def Base_10_to_n ( X , n ) : <NEWLINE> <INDENT> m = chr ( X % n + ord ( <STRING> ) ) <NEWLINE> if ( X // n ) : <NEWLINE> <INDENT> return Base_10_to_n ( X // n - 1 , n ) + m <NEWLINE> <DEDENT> return m <NEWLINE> <NL> <DEDENT> print ( N ) print ( Base_10_to_n ( N - 1 , 26 ) ) <NEWLINE>
<NL> <COMMENT> <NL> <COMMENT> <NL> from math import pow <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> def no_of_characters ( M ) : <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <INDENT> k = 1 <NEWLINE> <NL> <COMMENT> <NL> while ( True ) : <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <INDENT> if ( pow ( 2 , k + 1 ) - 2 < M ) : <NEWLINE> <INDENT> k += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> return k <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> def print_string ( M ) : <NEWLINE> <NL> <COMMENT> <NL> <INDENT> k = no_of_characters ( M ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> N = M - ( pow ( 2 , k ) - 2 ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> while ( k > 0 ) : <NEWLINE> <INDENT> num = pow ( 2 , k - 1 ) <NEWLINE> <NL> if ( num >= N ) : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> N -= num <NEWLINE> <DEDENT> k -= 1 <NEWLINE> <NL> <DEDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> M = input ( ) <NEWLINE> print_string ( M ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> name = [ ] <NEWLINE> <NL> while n > 0 : <NEWLINE> <INDENT> n -= 1 <NEWLINE> name . append ( alp [ n % 26 ] ) <NEWLINE> n //= 26 <NEWLINE> <NL> <DEDENT> name . reverse ( ) <NEWLINE> <NL> print ( * name , sep = <STRING> ) <NEWLINE>
import numpy as np <NEWLINE> import scipy . sparse as sps <NEWLINE> import scipy . misc as spm <NEWLINE> import collections as col <NEWLINE> import functools as func <NEWLINE> import itertools as ite <NEWLINE> import fractions as frac <NEWLINE> import math as ma <NEWLINE> from math import cos , sin , tan , sqrt <NEWLINE> import cmath as cma <NEWLINE> import copy as cp <NEWLINE> import sys <NEWLINE> import re <NEWLINE> import bisect as bs <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> EPS = sys . float_info . epsilon <NEWLINE> PI = np . pi ; EXP = np . e ; INF = np . inf <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> <NL> def sinput ( ) : return sys . stdin . readline ( ) . strip ( ) <NEWLINE> def iinput ( ) : return int ( sinput ( ) ) <NEWLINE> def imap ( ) : return map ( int , sinput ( ) . split ( ) ) <NEWLINE> def fmap ( ) : return map ( float , sinput ( ) . split ( ) ) <NEWLINE> def iarr ( n = 0 ) : <NEWLINE> <INDENT> if n : return [ 0 for _ in range ( n ) ] <NEWLINE> else : return list ( imap ( ) ) <NEWLINE> <DEDENT> def farr ( ) : return list ( fmap ( ) ) <NEWLINE> def sarr ( n = 0 ) : <NEWLINE> <INDENT> if n : return [ <STRING> for _ in range ( n ) ] <NEWLINE> else : return sinput ( ) . split ( ) <NEWLINE> <DEDENT> def barr ( n ) : return [ False for _ in range ( n ) ] <NEWLINE> def adj ( n ) : return [ [ ] for _ in range ( n ) ] <NEWLINE> <NL> n = iinput ( ) <NEWLINE> ch = [ <STRING> ] + [ chr ( i ) for i in range ( ord ( <STRING> ) , ord ( <STRING> ) + 25 ) ] <NEWLINE> <NL> def cnt26 ( num ) : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> while 1 : <NEWLINE> <INDENT> if 26 ** cnt > num : return cnt - 1 <NEWLINE> else : cnt += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> s = <STRING> <NEWLINE> dig = cnt26 ( n ) <NEWLINE> while dig >= 1 : <NEWLINE> <INDENT> div , mod = divmod ( n , 26 ** dig ) <NEWLINE> <COMMENT> <NL> n = mod <NEWLINE> s += ch [ div ] <NEWLINE> dig -= 1 <NEWLINE> <DEDENT> s += ch [ mod ] <NEWLINE> print ( s ) <NEWLINE>
import sys <NEWLINE> import itertools <NEWLINE> import resource <NEWLINE> xrange = lambda stop : iter ( itertools . count ( ) . next , stop ) <NEWLINE> sys . setrecursionlimit ( 1000000 ) <NEWLINE> ys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> resource . setrlimit ( resource . RLIMIT_STACK , ( - 1 , - 1 ) ) <NEWLINE> n = int ( input ( ) ) <NEWLINE> <NL> chars = { 1 : <STRING> , 2 : <STRING> , 3 : <STRING> , 4 : <STRING> , 5 : <STRING> , 6 : <STRING> , 7 : <STRING> , 8 : <STRING> , 9 : <STRING> , 10 : <STRING> , 11 : <STRING> , 12 : <STRING> , 13 : <STRING> , 14 : <STRING> , 15 : <STRING> , 16 : <STRING> , 17 : <STRING> , 18 : <STRING> , 19 : <STRING> , 20 : <STRING> , 21 : <STRING> , 22 : <STRING> , 23 : <STRING> , 24 : <STRING> , 25 : <STRING> , 26 : <STRING> } <NEWLINE> <NL> if n <= 26 : <NEWLINE> <INDENT> print ( chars [ n ] ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <NL> <NL> <DEDENT> def Base_10_to_26 ( X ) : <NEWLINE> <INDENT> if ( X // 26 ) : <NEWLINE> <INDENT> return Base_10_to_26 ( int ( X // 26 ) ) + chars [ int ( X % 26 ) ] <NEWLINE> <DEDENT> return chars [ int ( X % n ) ] <NEWLINE> <NL> <DEDENT> print ( Base_10_to_26 ( n ) ) <NEWLINE>
def print_ans ( num ) : <NEWLINE> <COMMENT> <NL> <INDENT> base = 26 <NEWLINE> <NL> checker = True <NEWLINE> ind = 1 <NEWLINE> while checker : <NEWLINE> <INDENT> if num > base ** ind : <NEWLINE> <INDENT> ind += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> checker = False <NEWLINE> ind -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> pre_ans_num = [ ] <NEWLINE> for i in range ( ind ) : <NEWLINE> <INDENT> ind_2 = ind - i <NEWLINE> quot = num // base ** ind_2 <NEWLINE> pre_ans_num . append ( quot ) <NEWLINE> num = num % base ** ind_2 <NEWLINE> <DEDENT> pre_ans_num . append ( num ) <NEWLINE> <NL> ans = <STRING> <NEWLINE> <NL> <COMMENT> <NL> pre_ans_num2 = pre_ans_num . copy ( ) <NEWLINE> for i , ans_num in enumerate ( pre_ans_num ) : <NEWLINE> <COMMENT> <NL> <INDENT> pre_ans_num2 [ i - 1 ] += - 1 <NEWLINE> <NL> <DEDENT> for n in pre_ans_num2 : <NEWLINE> <INDENT> if n == 0 : <NEWLINE> <INDENT> ans += <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> order = ord ( <STRING> ) + n - 1 <NEWLINE> ans += chr ( order ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> a = str ( input ( ) ) <NEWLINE> print_ans ( a ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> ans = <STRING> <NEWLINE> <NL> while N > 26 : <NEWLINE> <INDENT> tmp = N % 26 <NEWLINE> txt = <STRING> if tmp == 0 else chr ( tmp + 96 ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> ans += txt <NEWLINE> <COMMENT> <NL> N //= 26 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> txt = <STRING> if tmp == 0 else chr ( tmp + 96 ) <NEWLINE> ans += txt <NEWLINE> <NL> <DEDENT> print ( ans [ : : - 1 ] ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A . sort ( ) <NEWLINE> d = np . zeros ( A [ - 1 ] + 1 , dtype = np . unit64 ) <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> a = A [ i ] <NEWLINE> a1 = A [ i - 1 ] <NEWLINE> if a != a1 : <NEWLINE> <INDENT> if a != a1 : <NEWLINE> <INDENT> d [ a : : a ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d [ a ] += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( np . count_nonzero ( d [ A ] == 1 ) ) <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> arr = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> su = sum ( arr ) <NEWLINE> <NL> q = int ( input ( ) ) <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> <INDENT> si = su - b + c <NEWLINE> print ( si ) <NEWLINE> <DEDENT> <DEDENT>
if __name__ == <STRING> : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> a = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> q = int ( input ( ) ) <NEWLINE> key = [ i for i in range ( 10 ** 5 + 1 ) ] <NEWLINE> val = [ 0 ] * ( 10 ** 5 + 1 ) <NEWLINE> dict = dict ( zip ( key , val ) ) <NEWLINE> dict . update ( collections . Counter ( a ) ) <NEWLINE> ans = sum ( a ) <NEWLINE> <NL> for i in range ( q ) : <NEWLINE> <INDENT> b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = ans - b * dict [ b ] + c * dict [ b ] <NEWLINE> count = dict [ b ] <NEWLINE> dict [ b ] = 0 <NEWLINE> dict [ c ] += count <NEWLINE> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT>
A = [ 0 ] * ( 10 ** 5 + 1 ) <NEWLINE> for i in a : <NEWLINE> <INDENT> A [ i ] += 1 <NEWLINE> <NL> <DEDENT> for bc in BC : <NEWLINE> <INDENT> diff = bc [ 1 ] - bc [ 0 ] <NEWLINE> SUM += diff * A [ bc [ 0 ] ] <NEWLINE> A [ bc [ 1 ] ] += A [ bc [ 0 ] ] <NEWLINE> A [ bc [ 0 ] ] -= A [ bc [ 0 ] ] <NEWLINE> print ( SUM ) <NEWLINE> <DEDENT>
n = int ( input ( <STRING> ) ) <NEWLINE> ain = input ( <STRING> ) . split ( <STRING> ) <NEWLINE> a = { 1 : 0 , } <NEWLINE> c = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> c += [ int ( ain [ i ] ) ] <NEWLINE> <DEDENT> s = sum ( c ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if ( c [ i ] in a ) : <NEWLINE> <INDENT> a [ c [ i ] ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a [ c [ i ] ] = 1 <NEWLINE> <DEDENT> <DEDENT> q = int ( input ( <STRING> ) ) <NEWLINE> c = [ ] <NEWLINE> listb = [ ] <NEWLINE> listc = [ ] <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> c = + [ input ( <STRING> ) . split ( <STRING> ) ] <NEWLINE> listb += [ int ( c [ i ] [ 0 ] ) ] <NEWLINE> listc += [ int ( c [ i ] [ 1 ] ) ] <NEWLINE> if ( listb [ i ] in a and a [ listb [ i ] ] != 0 ) : <NEWLINE> <INDENT> s += ( listc [ i ] - listb [ i ] ) * a [ listb [ i ] ] <NEWLINE> if ( listc [ i ] in a ) : <NEWLINE> <INDENT> a [ listc [ i ] ] += a [ listb [ i ] ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a [ listc [ i ] ] = a [ listb [ i ] ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( s ) <NEWLINE> <NL> <NL> <NL> <DEDENT>
from collections import Counter <NEWLINE> <NL> def Replacing ( ) : <NEWLINE> <NL> <INDENT> Num = int ( input ( ) ) <NEWLINE> <NL> value_A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> Sum = sum ( value_A ) <NEWLINE> Counter_value = Counter ( value_A ) <NEWLINE> <NL> NumB = int ( input ( ) ) <NEWLINE> <NL> for i in range ( NumB ) : <NEWLINE> <INDENT> value_B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> Sum += ( value_B [ 1 ] - value_B [ 0 ] ) * Counter_value ( value_B [ 0 ] ) <NEWLINE> Counter_value [ value_B [ 1 ] ] += Counter_value [ value_B [ 0 ] ] <NEWLINE> Counter_value [ value_B [ 0 ] ] = 0 <NEWLINE> <NL> print ( Sum ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> Replacing ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = sum ( a ) <NEWLINE> <COMMENT> <NL> q = int ( input ( ) ) <NEWLINE> import collections <NEWLINE> cc = collections . Counter ( a ) <NEWLINE> <COMMENT> <NL> for i in range ( q ) : <NEWLINE> <INDENT> b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> tmp = cc [ b ] <NEWLINE> cc [ b ] = 0 <NEWLINE> s = s - b * tmp + c * tmp <NEWLINE> cc [ c ] += tmp <NEWLINE> print ( s ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> S = sum ( A ) <NEWLINE> L = [ 0 ] * 100001 <NEWLINE> for i in A : <NEWLINE> <INDENT> L [ i ] += 1 <NEWLINE> <DEDENT> Q = int ( input ( ) ) <NEWLINE> for i in range ( Q ) : <NEWLINE> <INDENT> B , C = map ( int , input ( ) . split ( ) ) <NEWLINE> S += ( C - B ) * L [ B ] <NEWLINE> L [ C ] += Ct [ B ] <NEWLINE> L [ B ] = 0 <NEWLINE> print ( S ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> Q = int ( input ( ) ) <NEWLINE> B = [ ] <NEWLINE> for i in range ( Q ) : <NEWLINE> <INDENT> B . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <DEDENT> sum = int ( 0 ) <NEWLINE> AA = [ int ( 0 ) ] <NEWLINE> for i in range ( 100000 ) : <NEWLINE> <INDENT> AA . append ( int ( 0 ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> sum = int ( 0 ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> sum += A [ i ] <NEWLINE> <DEDENT> for i in range ( Q ) : <NEWLINE> <INDENT> AA [ ( B [ i ] [ 0 ] ) ] = A . count ( int ( ( B [ i ] [ 0 ] ) ) ) <NEWLINE> A . replace ( B [ i ] [ 0 ] , B [ i ] [ 1 ] ) <NEWLINE> <COMMENT> <NL> sum = sum + B [ i ] [ 1 ] * AA [ ( B [ i ] [ 0 ] ) ] - B [ i ] [ 0 ] * AA [ ( B [ i ] [ 0 ] ) ] <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> print ( sum ) <NEWLINE> <DEDENT>
from collections import Counter <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> Q = int ( input ( ) ) <NEWLINE> B = [ ] <NEWLINE> C = [ ] <NEWLINE> for _ in range ( Q ) : <NEWLINE> <INDENT> b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> B . append ( b ) <NEWLINE> C . append ( c ) <NEWLINE> <NL> <DEDENT> counter = Counter ( A ) <NEWLINE> ans = 0 <NEWLINE> for num , count in counter . items ( ) : <NEWLINE> <INDENT> ans += num * count <NEWLINE> <NL> <DEDENT> for i in range ( Q ) : <NEWLINE> <INDENT> if B [ i ] in counter : <NEWLINE> <INDENT> ans += counter [ B [ i ] ] * C [ i ] - counter [ B [ i ] ] * B [ i ] <NEWLINE> counter [ C [ i ] ] = counter [ C [ i ] ] + counter . pop ( [ B [ i ] ] ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> sums = sum ( a ) <NEWLINE> d = { } <NEWLINE> <NL> for i in a : <NEWLINE> <INDENT> if i in d : <NEWLINE> <INDENT> d [ i ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d [ i ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( q ) : <NEWLINE> <INDENT> b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> if b in d : <NEWLINE> <INDENT> sums += d [ b ] * ( c - b ) <NEWLINE> if c in d : <NEWLINE> <INDENT> d [ c ] += d [ b ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d [ c ] = d [ b ] <NEWLINE> d [ b ] = 0 <NEWLINE> <DEDENT> <DEDENT> print ( sums ) <NEWLINE> <DEDENT>
for i in range ( n ) : <NEWLINE> <INDENT> key = lst [ i ] <NEWLINE> if key not in dic : <NEWLINE> <INDENT> dic [ key ] = 0 <NEWLINE> <DEDENT> dic [ key ] += 1 <NEWLINE> <COMMENT> <NL> <DEDENT> sum = 0 <NEWLINE> for key , value in dic . items ( ) : <NEWLINE> <INDENT> sum += key * value <NEWLINE> <NL> <DEDENT> m = int ( input ( ) ) <NEWLINE> for _ in range ( m ) : <NEWLINE> <INDENT> lst_s = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> number = dic . get ( lst_s [ 0 ] ) <NEWLINE> if number is not None : <NEWLINE> <INDENT> if lst_s [ 1 ] in dic : <NEWLINE> <INDENT> dic [ lst_s [ 1 ] ] += number <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dic [ lst_s [ 1 ] ] = number <NEWLINE> <DEDENT> sum += lst_s [ 1 ] * number <NEWLINE> sum -= lst_s [ 0 ] * number <NEWLINE> dic . pop ( lst_s [ 0 ] ) <NEWLINE> <DEDENT> print ( sum ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> bc = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( q ) ] <NEWLINE> temp = [ 0 ] * ( 10 ** 5 + 1 ) <NEWLINE> <NL> for i in a : <NEWLINE> <INDENT> temp [ i ] += 1 <NEWLINE> <DEDENT> ans = sum ( a ) <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> b , c = bc [ i ] [ 0 ] , bc [ i ] [ 1 ] <NEWLINE> ans = ans - temp [ b ] * b + temp [ b ] * c <NEWLINE> print ( sum ( temp ) ) <NEWLINE> temp [ c ] += tremp [ b ] <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> m = { } <NEWLINE> tot = 0 <NEWLINE> for a in map ( int , input ( ) . split ( ) ) : <NEWLINE> <INDENT> tot += m <NEWLINE> if a not in m : <NEWLINE> <INDENT> m [ a ] = 0 <NEWLINE> <DEDENT> m [ a ] += 1 <NEWLINE> <DEDENT> q = int ( input ( ) ) <NEWLINE> for step in range ( q ) : <NEWLINE> <INDENT> b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> if c not in m : <NEWLINE> <INDENT> m [ c ] = 0 <NEWLINE> <DEDENT> if b in m : <NEWLINE> <INDENT> m [ c ] += m [ b ] <NEWLINE> tot += m [ b ] * ( c - b ) <NEWLINE> m [ b ] = 0 <NEWLINE> <DEDENT> print ( tot ) <NEWLINE> <NL> <DEDENT>
n = int ( input ( ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <COMMENT> <NL> q = int ( input ( ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> bc = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( q ) ] <NEWLINE> <COMMENT> <NL> a_count = collections . Counter ( a ) <NEWLINE> a_list = dict ( list ( a_count . items ( ) ) ) <NEWLINE> <COMMENT> <NL> total = sum ( a ) <NEWLINE> for b , c in bc : <NEWLINE> <INDENT> if b in a_list : <NEWLINE> <INDENT> total += ( c - b ) * a_list [ b ] <NEWLINE> num = a_list [ b ] <NEWLINE> a_list [ b ] = 0 <NEWLINE> if c in a_list : <NEWLINE> <INDENT> a_list [ c ] += num <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a_list [ c ] = num <NEWLINE> <NL> <DEDENT> <DEDENT> print ( total ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> s = sum ( a ) <NEWLINE> x = [ 0 ] * 100001 <NEWLINE> for i in a : <NEWLINE> <INDENT> x [ i ] += 1 <NEWLINE> <NL> <DEDENT> q = int ( input ( ) ) <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> b , c = map ( int ( input ( ) . split ( ) ) ) <NEWLINE> s -= b * x [ b ] <NEWLINE> s += c * x [ c ] <NEWLINE> x [ c ] += x [ b ] <NEWLINE> x [ b ] = 0 <NEWLINE> print ( s ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> query = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( q ) ] <NEWLINE> <NL> all_sum = sum ( a ) <NEWLINE> <NL> cnt = { } <NEWLINE> for i in a : <NEWLINE> <INDENT> if i not in cnt : <NEWLINE> <INDENT> cnt [ a ] = 0 <NEWLINE> <DEDENT> cnt [ a ] += 1 <NEWLINE> <NL> <DEDENT> for ( b , c ) in query : <NEWLINE> <INDENT> if b in cnt : <NEWLINE> <INDENT> all_sum -= b * cnt [ b ] <NEWLINE> all_sum += c * cnt [ b ] <NEWLINE> if c not in cnt : <NEWLINE> <INDENT> cnt [ c ] = 0 <NEWLINE> <DEDENT> cnt [ c ] += cnt [ b ] <NEWLINE> cnt [ b ] = 0 <NEWLINE> <DEDENT> print ( all_sum ) <NEWLINE> <DEDENT>
<NL> import collections <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> cnt = collections . defaultdict ( int ) <NEWLINE> for var in a : <NEWLINE> <INDENT> cnt [ var ] += 1 <NEWLINE> <NL> <DEDENT> sum_a = sum [ a ] <NEWLINE> <NL> q = int ( input ( ) ) <NEWLINE> for _ in range ( q ) : <NEWLINE> <INDENT> b , c = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> diff = ( c - b ) * cnt [ b ] <NEWLINE> sum_a += diff <NEWLINE> print ( sum_a ) <NEWLINE> cnt [ c ] += cnt [ b ] <NEWLINE> cnt [ b ] = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import bisect , collections , copy , heapq , itertools , math , string <NEWLINE> import numpy as np <NEWLINE> from numba import njit <NEWLINE> import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> <NL> def _S ( ) : return sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> def I ( ) : return int ( sys . stdin . readline ( ) . rstrip ( ) ) <NEWLINE> def LI ( ) : return list ( map ( int , sys . stdin . readline ( ) . rstrip ( ) . split ( ) ) ) <NEWLINE> def LS ( ) : return list ( sys . stdin . readline ( ) . rstrip ( ) . split ( ) ) <NEWLINE> <NL> N = I ( ) <NEWLINE> _A = LI ( ) <NEWLINE> A = np . array ( _A , dtype = <STRING> ) <NEWLINE> Q = I ( ) <NEWLINE> BC = [ LI ( ) for _ in range ( Q ) ] <NEWLINE> <COMMENT> <NL> <NL> def convert ( a , mapping ) : <NEWLINE> <INDENT> for i in range ( N ) : <NEWLINE> <INDENT> if a [ i ] == mapping [ 0 ] : <NEWLINE> <INDENT> a [ i ] = mapping [ 1 ] <NEWLINE> <DEDENT> <DEDENT> return a <NEWLINE> <NL> <DEDENT> for i in range ( Q ) : <NEWLINE> <INDENT> A = convert ( A , BC [ i ] ) <NEWLINE> print ( A . sum ( ) ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NEWLINE> <DEDENT>
R = lambda : map ( int , input ( ) . split ( ) ) <NEWLINE> R ( ) <NEWLINE> a = [ 0 ] * 100001 <NEWLINE> s = 0 <NEWLINE> for x in R ( ) : <NEWLINE> <INDENT> s += x <NEWLINE> a [ x ] += 1 <NEWLINE> <DEDENT> q , = R ( ) <NEWLINE> for _ in range ( q ) : <NEWLINE> <INDENT> b , c = R ( ) <NEWLINE> s += ( c - b ) * a [ b ] <NEWLINE> print ( s ) <NEWLINE> a [ c ] += d [ b ] <NEWLINE> a [ b ] = 0 <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> import sys <NEWLINE> def input ( ) : return sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> import numpy as np <NEWLINE> A . sort ( ) <NEWLINE> ans = sum ( A ) <NEWLINE> from bisect import bisect_left , bisect_right <NEWLINE> from collections import Counter <NEWLINE> count = Counter ( A ) <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> k = count [ b ] <NEWLINE> if k != 0 <NEWLINE> <INDENT> count [ c ] += count . pop ( b ) <NEWLINE> <DEDENT> ans += ( c - b ) * k <NEWLINE> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> summary = sum ( A ) <NEWLINE> d = { } <NEWLINE> for a in A : <NEWLINE> <INDENT> if a in d : <NEWLINE> <INDENT> d [ a ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d [ a ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> Q = int ( input ( ) ) <NEWLINE> for _ in range ( Q ) : <NEWLINE> <INDENT> B , C = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if B not in d : <NEWLINE> <INDENT> b = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> b = d [ B ] <NEWLINE> d [ B ] = 0 <NEWLINE> <DEDENT> if C in d : <NEWLINE> <INDENT> d [ C ] += b <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d [ C ] = b <NEWLINE> <DEDENT> summary = summary + b * ( C - B ) <NEWLINE> print ( summary ) <NEWLINE> <DEDENT>
form collections import Counter <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> Q = int ( input ( ) ) <NEWLINE> counter = Counter ( A ) <NEWLINE> sum_res = sum ( A ) <NEWLINE> for i in range ( Q ) : <NEWLINE> <INDENT> b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> sum_res -= counter [ b ] * b <NEWLINE> sum_res += counter [ b ] * c <NEWLINE> counter [ c ] += counter [ b ] <NEWLINE> counter [ b ] = 0 <NEWLINE> print ( sum_res ) <NEWLINE> <DEDENT>
import collections <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> dic = collections . Counter ( a ) <NEWLINE> sum_list = [ x * y for ( x , y ) in dic . items ( ) ] <NEWLINE> sum = sum ( sum_list ) <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> if b in dic : <NEWLINE> <INDENT> b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( sum - ( b - c ) * dic [ b ] ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> d = dict ( ) <NEWLINE> s = 0 <NEWLINE> for num in a : <NEWLINE> <INDENT> if num in d : <NEWLINE> <INDENT> d [ num ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d [ num ] = 1 <NEWLINE> <DEDENT> s += num <NEWLINE> <DEDENT> for i in range ( q ) : <NEWLINE> <INDENT> B , C = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if B in d : <NEWLINE> <INDENT> if C in d : <NEWLINE> <INDENT> d [ C ] += d [ B ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d [ C ] = d [ B ] <NEWLINE> <DEDENT> s += ( C - B ) * d [ B ] <NEWLINE> s [ B ] = 0 <NEWLINE> <DEDENT> print ( s ) <NEWLINE> <DEDENT>
import collections <NEWLINE> n = int ( input ( ) ) <NEWLINE> arr = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> cnt = collections . defaultdict ( int ) <NEWLINE> for val in arr : <NEWLINE> <INDENT> cnt [ val ] += 1 <NEWLINE> <DEDENT> sums = sum ( arr ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> for _ in range ( q ) : <NEWLINE> <INDENT> b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> diff = ( c - b ) * ( cnt [ b ] ) <NEWLINE> sums += diff <NEWLINE> print ( sums ) <NEWLINE> cnt [ c ] += nt [ b ] <NEWLINE> cnt [ b ] = 0 <NEWLINE> <DEDENT>
import sys <NEWLINE> from math import ceil , floor , sqrt , sin , cos , pi <NEWLINE> from itertools import accumulate , permutations , combinations <NEWLINE> from fractions import gcd <COMMENT> <NEWLINE> from collections import deque , Counter <NEWLINE> from operator import itemgetter <NEWLINE> from heapq import heappop , heappush <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> def lcm ( x , y ) : return ( ( x * y ) // gcd ( x , y ) ) <COMMENT> <NEWLINE> <COMMENT> <NL> <NL> lin = [ 0 for i in range ( 10 ** 5 ) ] <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> for x in a : <NEWLINE> <INDENT> ans += x <NEWLINE> lin [ x ] += 1 <NEWLINE> <DEDENT> q = int ( input ( ) ) <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> ans += ( c - b ) * lin [ b ] <NEWLINE> print ( ans ) <NEWLINE> lin [ c ] += lin [ b ] <NEWLINE> lin [ b ] = 0 <NEWLINE> <DEDENT>
import collections <NEWLINE> <NL> n = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> q = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> CNT = collections . Counter ( A ) <NEWLINE> ANS = [ ] <NEWLINE> ans = sum ( A ) <NEWLINE> <NL> for i in range ( q ) : <NEWLINE> <INDENT> b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> t = CNT [ b ] <NEWLINE> ans += ( c - b ) * t <NEWLINE> ANS . append ( ans ) <NEWLINE> CNT [ c ] += t <NEWLINE> CNT [ b ] = 0 <NEWLINE> <NL> <DEDENT> for i in ANS : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT>
<COMMENT> <NL> l = lambda : list ( map ( int , input ( ) . split ( ) . strip ( ) ) ) <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = l <NEWLINE> t = [ 0 ] * ( 10 ** 5 + 1 ) <NEWLINE> s = 0 <NEWLINE> for i in a : <NEWLINE> <INDENT> s += i <NEWLINE> t [ i ] += 1 <NEWLINE> <DEDENT> q = int ( input ( ) ) <NEWLINE> for _ in range ( q ) : <NEWLINE> <INDENT> b , c = l <NEWLINE> s += ( c - b ) * t [ b ] <NEWLINE> t [ c ] += t [ b ] <NEWLINE> t [ b ] = 0 <NEWLINE> print ( s ) <NEWLINE> <DEDENT>
H , W , K = map ( int , input ( ) . split ( ) ) <NEWLINE> c = [ list ( input ( ) ) for i in range ( H ) ] <NEWLINE> b = 0 <NEWLINE> for i in range ( H ) : <NEWLINE> <INDENT> b += c [ i ] . count ( <STRING> ) <NEWLINE> <DEDENT> if b == K : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> a = K - b <NEWLINE> count = 0 <NEWLINE> hc = [ ] <NEWLINE> wc = [ ] <NEWLINE> for i in range ( 2 ** H ) : <NEWLINE> <INDENT> h = [ <STRING> ] * H <NEWLINE> for j in range ( H ) : <NEWLINE> <INDENT> if ( ( i >> j ) & 1 ) : <NEWLINE> <INDENT> h [ H - 1 - j ] = <STRING> <NEWLINE> <DEDENT> <DEDENT> hc . append ( h ) <NEWLINE> <DEDENT> for i in range ( 2 ** W ) : <NEWLINE> <INDENT> w = [ <STRING> ] * W <NEWLINE> for j in range ( W ) : <NEWLINE> <INDENT> if ( ( i >> j ) & 1 ) : <NEWLINE> <INDENT> w [ W - 1 - j ] = <STRING> <NEWLINE> <DEDENT> <DEDENT> wc . append ( w ) <NEWLINE> <NL> <DEDENT> for k in range ( len ( hc ) ) : <NEWLINE> <INDENT> for l in range ( len ( wc ) ) : <NEWLINE> <INDENT> c1 = list ( c ) <NEWLINE> for m in range ( H ) : <NEWLINE> <INDENT> if hc [ k ] [ m ] == <STRING> : <NEWLINE> <INDENT> c1 [ m ] = <STRING> <NEWLINE> <DEDENT> for n in range ( W ) : <NEWLINE> <INDENT> if wc [ l ] [ n ] == <STRING> and c1 [ m ] [ n ] == <STRING> : <NEWLINE> <INDENT> c1 [ m ] [ n ] = c1 [ m ] [ n ] . replace ( <STRING> , <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> for i in range ( H ) : <NEWLINE> <INDENT> b += c1 [ i ] . count ( <STRING> ) <NEWLINE> print ( c1 ) <NEWLINE> <DEDENT> if b == a : <NEWLINE> <INDENT> count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE> <NL> <NL>
a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> dic = { } <NEWLINE> for i in range ( len ( a ) ) : <NEWLINE> <INDENT> dic . setdefault ( a [ i ] , 1 ) <NEWLINE> dic [ a [ i ] ] += 1 <NEWLINE> <DEDENT> answer = sum ( a ) <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> dic . setdefault ( b , 0 ) <NEWLINE> dic . setdefault ( c , 0 ) <NEWLINE> dic [ c ] += dic [ b ] <NEWLINE> answer = answer + dic [ b ] * c - dic [ b ] * b <NEWLINE> dic [ b ] = 0 <NEWLINE> print ( answer ) <NEWLINE> <DEDENT>
from collections import Counter <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c = Counter ( A ) <NEWLINE> S = sum ( A ) <NEWLINE> <NL> for _ in range ( int ( input ( ) ) ) : <NEWLINE> <INDENT> p , q = map ( int , input ( ) . split ( ) ) <NEWLINE> k = count [ p ] <NEWLINE> count [ p ] = 0 <NEWLINE> count [ q ] += k <NEWLINE> S += ( q - p ) * k <NEWLINE> print ( S ) <NEWLINE> <DEDENT>
from collections import Counter <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c = Counter ( A ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> s = sum ( a ) <NEWLINE> for _ in range ( q ) : <NEWLINE> <INDENT> b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> s -= C [ b ] * b <NEWLINE> s += C [ b ] * c <NEWLINE> C [ c ] += c [ b ] <NEWLINE> c [ b ] = 0 <NEWLINE> print ( s ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
def sum_dict ( d , sum , b , c ) : <NEWLINE> <INDENT> val = 0 <NEWLINE> if b in d : <NEWLINE> <INDENT> val = d [ b ] <NEWLINE> sum -= ( b * val ) <NEWLINE> del d [ b ] <NEWLINE> d [ c ] = d . get ( c , 0 ) + val <NEWLINE> sum += ( c * val ) <NEWLINE> <DEDENT> return sum , d <NEWLINE> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> a = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> d = { } <NEWLINE> for i in a : <NEWLINE> <INDENT> d [ i ] = d . get ( i , 0 ) + 1 <NEWLINE> <DEDENT> s = sum ( a ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> s , d = sum_dict ( d , b , c ) <NEWLINE> print ( s ) <NEWLINE> <DEDENT>
from collections import Counter <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> Q = int ( input ( ) ) <NEWLINE> su = sum ( A ) <NEWLINE> print ( counter ) <NEWLINE> lis = { } <NEWLINE> for i in range ( Q ) : <NEWLINE> <INDENT> B , C = map ( int , input ( ) . split ( ) ) <NEWLINE> su -= B * counter [ B ] <NEWLINE> su += C * counter [ B ] <NEWLINE> counter [ C ] += counter [ B ] <NEWLINE> counter [ B ] = 0 <NEWLINE> print ( su ) <NEWLINE> <DEDENT>
def resolve ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> Q = int ( input ( ) ) <NEWLINE> <NL> C = Counter ( A ) <NEWLINE> ANS = 0 <NEWLINE> for i in C : <NEWLINE> <INDENT> ANS += i * C [ i ] <NEWLINE> <NL> <DEDENT> for _ in range ( Q ) : <NEWLINE> <INDENT> B , X = map ( int , input ( ) . split ( ) ) <NEWLINE> ANS += X * C [ B ] <NEWLINE> C [ X ] += C [ B ] <NEWLINE> <NL> ANS -= B * C [ B ] <NEWLINE> del ( C [ B ] ) <NEWLINE> print ( ANS ) <NEWLINE> <NL> <DEDENT> <DEDENT> resolve ( ) <NEWLINE>
from collections import Counter <NEWLINE> <NL> import sys <NEWLINE> <NL> readline = sys . stdin . buffer . readline <NEWLINE> <NL> def solver ( int N , list A , int Q , list BC ) : <NEWLINE> <INDENT> d = Counter ( A ) <NEWLINE> <NL> sub_s = sum ( A ) <NEWLINE> <NL> for b , c in BC : <NEWLINE> <INDENT> sub_s += d [ b ] * ( c - b ) <NEWLINE> d [ c ] += d [ b ] <NEWLINE> d [ b ] = 0 <NEWLINE> <NL> print ( sub_s ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def run ( ) : <NEWLINE> <INDENT> N = int ( readline ( ) ) <NEWLINE> A = list ( map ( int , readline ( ) . split ( ) ) ) <NEWLINE> <NL> Q = int ( readline ( ) ) <NEWLINE> BC = [ list ( map ( int , readline ( ) . split ( ) ) ) for _ in range ( Q ) ] <NEWLINE> <NL> solver ( N , A , Q , BC ) <NEWLINE> <NL> <DEDENT> run ( ) <NEWLINE>
from collections import Counter <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> <NL> for i in range ( q ) : <NEWLINE> <INDENT> B , C = map ( int , input ( ) . split ( ) ) <NEWLINE> b . append ( B ) <NEWLINE> c . append ( C ) <NEWLINE> <NL> <DEDENT> cnt = Counter ( a ) <NEWLINE> <NL> s = sum ( cnt ) <NEWLINE> <NL> for i in range ( q ) : <NEWLINE> <INDENT> b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> s = s - b * cnt [ b ] <NEWLINE> s = s + c * cnt [ b ] <NEWLINE> cnt [ c ] += cnt [ b ] <NEWLINE> cnt [ b ] = 0 <NEWLINE> print ( s ) <NEWLINE> <DEDENT>
<INDENT> aList [ b - 1 ] = 0 <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> Q = int ( input ( ) ) <NEWLINE> BC = [ map ( int , input ( ) . split ( ) ) for _ in range ( Q ) ] <NEWLINE> B , C = [ i for i in zip ( * BC ) ] <NEWLINE> <COMMENT> <NL> <NL> dic = { } <NEWLINE> for a in A : <NEWLINE> <INDENT> dic [ a ] = dic . get ( a , 0 ) + 1 <NEWLINE> <NL> <DEDENT> ans = sum ( A ) <NEWLINE> for q in range ( Q ) : <NEWLINE> <INDENT> bc = C ( q ) - B ( q ) <NEWLINE> ans = ans + bc * dic . get ( B ( q ) , 0 ) <NEWLINE> dic [ C ( q ) ] = dic . get ( C ( q ) , 0 ) + dic . get ( B ( q ) , 0 ) <NEWLINE> dic [ B ( q ) ] = 0 <NEWLINE> print ( ans ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> num_count = [ 0 ] * ( 10 ** 5 + 1 ) <NEWLINE> tmp_sum = sum ( A ) <NEWLINE> for i in A : <NEWLINE> <INDENT> num_count [ i ] += 1 <NEWLINE> <NL> <DEDENT> for q in range ( int ( input ( ) ) : <NEWLINE> <INDENT> B , C = map ( int , input ( ) . split ( ) ) <NEWLINE> gain = C * ( num_count [ B ] ) <NEWLINE> loss = B * ( num_count [ B ] ) <NEWLINE> num_count [ C ] += num_count [ B ] <NEWLINE> num_count [ B ] = 0 <NEWLINE> tmp_sum = tmp_sum + gain - loss <NEWLINE> print ( tmp_sum ) <NEWLINE> <DEDENT>
import sys <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> <NL> from collections import Counter <NEWLINE> <NL> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , readline ( ) . split ( ) ) ) <NEWLINE> Q = int ( input ( ) ) <NEWLINE> <NL> S = sum ( A ) <NEWLINE> C = Counter ( A ) <NEWLINE> <NL> ans = [ ] <NEWLINE> for _ in range ( Q ) : <NEWLINE> <INDENT> b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> count = C [ b ] <NEWLINE> S += ( c - b ) * count <NEWLINE> C [ b ] , C [ c ] = 0 , C [ c ] + count <NEWLINE> ans . append ( S ) <NEWLINE> <NL> <DEDENT> print ( <STRING> . join ( map ( str , ans ) ) ) <NEWLINE>
from collections import defaultdict <NEWLINE> from numba import jit <NEWLINE> from collections import Counter <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> arr = defaultdict ( int ) <NEWLINE> for k , v in Counter ( a ) . items ( ) : <NEWLINE> <INDENT> arr [ k ] = v <NEWLINE> <DEDENT> q = int ( input ( ) ) <NEWLINE> bc = [ ] <NEWLINE> for _ in range ( q ) : <NEWLINE> <INDENT> b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> bc . append ( ( b , c ) ) <NEWLINE> <NL> <NL> <DEDENT> @ jit ( <STRING> ) <NEWLINE> def solve ( n , arr , bc ) : <NEWLINE> <INDENT> for b , c in bc : <NEWLINE> <INDENT> arr [ c ] += arr [ b ] <NEWLINE> arr [ b ] = 0 <NEWLINE> print ( sum ( [ x * y for x , y in arr . items ( ) ] ) ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> solve ( n , arr , bc ) <NEWLINE>
from collections import Counter <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> <NL> ans = sum ( a ) <NEWLINE> A = Counter ( a ) . most_common ( ) <NEWLINE> d = [ 0 ] * 10 ** 5 + 10 <NEWLINE> for i in range ( len ( A ) ) : <NEWLINE> <INDENT> d [ A [ i ] [ 0 ] ] = A [ i ] [ 1 ] <NEWLINE> <NL> <DEDENT> B = [ ] <NEWLINE> C = [ ] <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> B . append ( b ) <NEWLINE> C . append ( c ) <NEWLINE> <NL> <DEDENT> for i in range ( q ) : <NEWLINE> <INDENT> d [ C [ i ] ] += d [ B [ i ] ] <NEWLINE> cnt = d [ B [ i ] ] <NEWLINE> ans += ( C [ i ] - B [ i ] ) * cnt <NEWLINE> print ( ans ) <NEWLINE> d [ B [ i ] ] = 0 <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> input = sys . stdin . readline <NEWLINE> from math import floor , sqrt , factorial , hypot , log <COMMENT> <NEWLINE> from heapq import heappop , heappush , heappushpop <NEWLINE> from collections import Counter , defaultdict , deque <NEWLINE> from itertools import accumulate , permutations , combinations , product , combinations_with_replacement <NEWLINE> from bisect import bisect_left , bisect_right <NEWLINE> from copy import deepcopy <NEWLINE> from fractions import gcd <NEWLINE> from random import randint <NEWLINE> <NL> <NL> def ceil ( a , b ) : return ( a + b - 1 ) // b <NEWLINE> <NL> <NL> inf = float ( <STRING> ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> <NL> def pprint ( * A ) : <NEWLINE> <INDENT> for a in A : print ( * a , sep = <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> def INT_ ( n ) : return int ( n ) - 1 <NEWLINE> <NL> <NL> def MI ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <NL> def MF ( ) : return map ( float , input ( ) . split ( ) ) <NEWLINE> <NL> <NL> def MI_ ( ) : return map ( INT_ , input ( ) . split ( ) ) <NEWLINE> <NL> <NL> def LI ( ) : return list ( MI ( ) ) <NEWLINE> <NL> <NL> def LI_ ( ) : return [ int ( x ) - 1 for x in input ( ) . split ( ) ] <NEWLINE> <NL> <NL> def LF ( ) : return list ( MF ( ) ) <NEWLINE> <NL> <NL> def LIN ( n : int ) : return [ I ( ) for _ in range ( n ) ] <NEWLINE> <NL> <NL> def LLIN ( n : int ) : return [ LI ( ) for _ in range ( n ) ] <NEWLINE> <NL> <NL> def LLIN_ ( n : int ) : return [ LI_ ( ) for _ in range ( n ) ] <NEWLINE> <NL> <NL> def LLI ( ) : return [ list ( map ( int , l . split ( ) ) ) for l in input ( ) ] <NEWLINE> <NL> <NL> def I ( ) : return int ( input ( ) ) <NEWLINE> <NL> <NL> def F ( ) : return float ( input ( ) ) <NEWLINE> <NL> <NL> def ST ( ) : return input ( ) . replace ( <STRING> , <STRING> ) <NEWLINE> <NL> import numpy as np <NEWLINE> from collections import Counter <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> N = I ( ) <NEWLINE> A = LI ( ) <NEWLINE> Q = I ( ) <NEWLINE> act_list = LLIN ( Q ) <NEWLINE> cnt = Counter ( A ) <NEWLINE> <COMMENT> <NL> for z in act_list : <NEWLINE> <INDENT> ans = 0 <NEWLINE> b_num = cnt [ z [ 0 ] ] <NEWLINE> cnt [ z [ 0 ] ] = 0 <NEWLINE> cnt [ z [ 1 ] ] = cnt [ z [ 1 ] ] + b_num <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> for k , v in cnt . items ( ) : <NEWLINE> <INDENT> ans = ans + k * v <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <NL> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> Q = int ( input ( ) ) <NEWLINE> <NL> table = [ 0 ] * 100001 <NEWLINE> <NL> c = 0 <NEWLINE> s = 0 <NEWLINE> <NL> for i in A : <NEWLINE> <INDENT> table [ i ] += 1 <NEWLINE> s += i <NEWLINE> <NL> <DEDENT> print ( su , s ) <NEWLINE> <NL> for i in range ( Q ) : <NEWLINE> <INDENT> B , C = map ( int , input ( ) . split ( ) ) <NEWLINE> c = table [ B ] <NEWLINE> s += ( C - B ) * c <NEWLINE> table [ C ] += table [ B ] <NEWLINE> table [ B ] = 0 <NEWLINE> print ( s ) <NEWLINE> <DEDENT>
from collections import Counter <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> s = sum ( a ) <NEWLINE> d = Counter ( a ) <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> if b in d : <NEWLINE> <INDENT> l = d [ b ] <NEWLINE> d [ b ] = 0 <NEWLINE> d [ c ] += l <NEWLINE> s += ( c - b ) * l <NEWLINE> print ( s ) <NEWLINE> <DEDENT> else : print ( s ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> num = [ 0 ] * ( 10 ** 5 + 1 ) <NEWLINE> ans = sum ( a ) <NEWLINE> for i in a : <NEWLINE> <INDENT> num [ i ] += 1 <NEWLINE> <DEDENT> for i in range ( q ) : <NEWLINE> <INDENT> b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = ans + ( c - b ) * num [ b - 1 ] [ 0 ] <NEWLINE> num [ c - 1 ] [ 0 ] += num [ b - 1 ] [ 0 ] <NEWLINE> num [ b - 1 ] [ 0 ] = 0 <NEWLINE> print ( ans ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> Q = int ( input ( ) ) <NEWLINE> <NL> base = sum ( A ) <NEWLINE> <NL> from collections import Counter <NEWLINE> <NL> ad = Counter ( A ) <NEWLINE> <NL> for _ in range ( Q ) : <NEWLINE> <INDENT> b , c = map ( int . input ( ) . split ( ) ) <NEWLINE> if ad [ b ] != 0 : <NEWLINE> <INDENT> base += ( c - b ) * ad [ b ] <NEWLINE> ad [ c ] += ad [ b ] <NEWLINE> ad [ b ] = 0 <NEWLINE> <DEDENT> print ( base ) <NEWLINE> <DEDENT>
<COMMENT> <NL> import sys <NEWLINE> <NL> <NL> def solve ( N : int , a : <STRING> ) : <NEWLINE> <INDENT> from functools import reduce <NEWLINE> assert N % 2 == 0 <NEWLINE> b = reduce ( lambda a , b : a ^ b , a ) <NEWLINE> return [ aa ^ b for aa in a ] <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> def iterate_tokens ( ) : <NEWLINE> <INDENT> for line in sys . stdin : <NEWLINE> <INDENT> for word in line . split ( ) : <NEWLINE> <INDENT> yield word <NEWLINE> <DEDENT> <DEDENT> <DEDENT> tokens = iterate_tokens ( ) <NEWLINE> N = int ( next ( tokens ) ) <COMMENT> <NEWLINE> a = [ int ( next ( tokens ) ) for _ in range ( N ) ] <COMMENT> <NEWLINE> print ( * solve ( N , a ) ) <NEWLINE> <NL> <DEDENT> def test ( ) : <NEWLINE> <INDENT> import doctest <NEWLINE> doctest . testmod ( ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <COMMENT> <NL> <INDENT> main ( ) <NEWLINE> <COMMENT> <NL> <DEDENT> import sys <NEWLINE> <NL> <NL> def solve ( N : int , a : <STRING> ) : <NEWLINE> <INDENT> from functools import reduce <NEWLINE> assert N % 2 == 0 <NEWLINE> b = reduce ( lambda a , b : a ^ b , a ) <NEWLINE> return [ aa ^ b for aa in a ] <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> def iterate_tokens ( ) : <NEWLINE> <INDENT> for line in sys . stdin : <NEWLINE> <INDENT> for word in line . split ( ) : <NEWLINE> <INDENT> yield word <NEWLINE> <DEDENT> <DEDENT> <DEDENT> tokens = iterate_tokens ( ) <NEWLINE> N = int ( next ( tokens ) ) <COMMENT> <NEWLINE> a = [ int ( next ( tokens ) ) for _ in range ( N ) ] <COMMENT> <NEWLINE> print ( * solve ( N , a ) ) <NEWLINE> <NL> <DEDENT> def test ( ) : <NEWLINE> <INDENT> import doctest <NEWLINE> doctest . testmod ( ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <COMMENT> <NL> <INDENT> main ( ) <NEWLINE> <DEDENT>
import array <NEWLINE> from functools import reduce <NEWLINE> from operator import xor <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = array . array ( <STRING> , map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> Q = array . array ( <STRING> , [ 0 ] ) * N <NEWLINE> <NL> array . array ( <STRING> , ( A [ n ] for n in range ( N ) if n != i ) ) <NEWLINE> <NL> R = reduce ( xor , A ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> print ( R ^ A [ i ] ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = input ( ) . split ( <STRING> ) <NEWLINE> <NL> s = a [ 0 ] <NEWLINE> <NL> for num in a [ 1 : ] : <NEWLINE> <INDENT> s ^= num <NEWLINE> <NL> <DEDENT> ans = [ 0 ] * n <NEWLINE> <NL> for i , num in enumerate ( a ) : <NEWLINE> <INDENT> ans [ i ] = s ^ num <NEWLINE> <NL> <DEDENT> print ( * ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> Q = int ( input ( ) ) <NEWLINE> L = len ( A ) <NEWLINE> S = sum ( A ) <NEWLINE> <NL> for i in range ( Q ) : <NEWLINE> <INDENT> ans = 0 <NEWLINE> B , C = map ( int , input ( ) . split ( ) ) <NEWLINE> for j in range ( L ) : <NEWLINE> <INDENT> if A [ j ] == B : <NEWLINE> <INDENT> A [ j ] = C <NEWLINE> S += ( C - B ) <NEWLINE> <DEDENT> <DEDENT> ans = S <NEWLINE> print ( ans ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> arr = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> xors = 0 <NEWLINE> for val in arr : <NEWLINE> <INDENT> xors ^= val <NEWLINE> <DEDENT> ans = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ans . append ( xros ^ arr [ i ] ) <NEWLINE> <NL> <DEDENT> print ( * ans ) <NEWLINE>
n = int ( input ( <STRING> ) ) <NEWLINE> a = [ ] <NEWLINE> ans = [ 1 ] <NEWLINE> ain = input ( <STRING> ) . split ( <STRING> ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a += [ int ( ain [ i ] ) ] <NEWLINE> <DEDENT> s = a [ 1 ] <NEWLINE> for i in range ( n - 2 ) : <NEWLINE> <INDENT> s ^= a [ i + 2 ] <NEWLINE> <DEDENT> ans [ 0 ] = s <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> s = s ^ a [ i ] <NEWLINE> s ^= a [ i + 1 ] <NEWLINE> ans += s <NEWLINE> <DEDENT> print ( <STRING> . join ( ans ) ) <NEWLINE> <NL> <NL> <NL>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A = A + A <NEWLINE> ans = [ 0 ] * N <NEWLINE> a = 0 <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> a ^= A [ i ] <NEWLINE> <DEDENT> ans [ N - 1 ] = a <NEWLINE> W = N - 1 <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> remove = A [ i ] <NEWLINE> addition = A [ i + W ] <NEWLINE> a = remove ^ a ^ addition <NEWLINE> ans [ i ] = a <NEWLINE> <NL> <DEDENT> print ( <STRING> . join ( [ str ( i ) for i in ans ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> count = 0 <NEWLINE> for i in A : <NEWLINE> <INDENT> count ^= x <NEWLINE> <DEDENT> for i in range ( len ( A ) ) : <NEWLINE> <INDENT> A [ i ] ^= count <NEWLINE> <NL> <NL> <NL> <DEDENT> print ( * A ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> arr = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i in arr : <NEWLINE> <INDENT> total ^= i <NEWLINE> <DEDENT> for i in arr : <NEWLINE> <INDENT> print ( total ^ i , end = <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = a [ 0 ] <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> ans = ans ^ a [ i ] <NEWLINE> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> print ( ans ^ i , ende = <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> alist = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> allh = alist [ 0 ] ^ alist [ 1 ] <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> allh = allh ^ alist [ i + 2 ] <NEWLINE> <NL> <DEDENT> outlist = [ ] <NEWLINE> for a in alist : <NEWLINE> <INDENT> outlist . append ( str ( allh ^ a ) ) <NEWLINE> outlist . append ( <STRING> ) <NEWLINE> <DEDENT> outlist . pop ( ) <NEWLINE> print ( <STRING> . join ( outlist ) ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> p = max ( a ) <NEWLINE> m = len ( bin ( p ) ) - 2 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> b = len ( bin ( a [ i ] ) ) - 2 <NEWLINE> ans = 0 <NEWLINE> for j in range ( b ) : <NEWLINE> <INDENT> if a [ i ] >> j & 1 == 1 : <NEWLINE> <INDENT> if j == m - 1 or j == 0 : <NEWLINE> <INDENT> ans += pow ( 2 , j ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if j == m - 1 or j == 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> ans += pow ( 2 , j ) <NEWLINE> <DEDENT> <DEDENT> print ( ans , end = <STRING> ) <NEWLINE> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> su = 0 <NEWLINE> <NL> for i in range ( 1 , n ) : <NEWLINE> <INDENT> su ^= a [ i ] <NEWLINE> <NL> <DEDENT> ans = [ su ] <NEWLINE> <NL> for i in range ( n - 1 ) : <NEWLINE> <INDENT> su = su ^ a [ i ] ^ a [ i + 1 ] <NEWLINE> ans . append ( su ) <NEWLINE> <NL> <DEDENT> print ( * su ) <NEWLINE>
import numpy as np <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = np . array ( a , dtype = np . int64 ) <NEWLINE> b = [ ( ( a >> i ) & 1 ) . sum ( ) for i in range ( 21 ) ] <NEWLINE> li = [ ] <NEWLINE> for i in a : <NEWLINE> <INDENT> c = np . array ( [ ( ( i >> j ) & 1 ) for j in range ( 21 ) ] , dtype = np . int64 ) <NEWLINE> d = b - c <NEWLINE> point = 0 <NEWLINE> for i in range ( 31 ) : <NEWLINE> <INDENT> if d [ i ] % 2 == 1 : <NEWLINE> <INDENT> point += 2 ** ( i ) <NEWLINE> <DEDENT> <DEDENT> li . append ( point ) <NEWLINE> <NL> <DEDENT> print ( * li ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> total = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> total = total ^ a [ i ] <NEWLINE> <NL> <DEDENT> result = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> result . append ( total ^ a [ i ] ) <NEWLINE> <DEDENT> L = <STRING> . join ( result ) <NEWLINE> print ( L ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> lis = [ ] <NEWLINE> for a in A : <NEWLINE> <INDENT> stra = str ( a ) <NEWLINE> S = <STRING> <NEWLINE> i = 0 <NEWLINE> for s in stra : <NEWLINE> <INDENT> s = 0 | ( a >> i ) <NEWLINE> if i % 2 == 0 : <NEWLINE> <INDENT> S = s + S <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if s == <STRING> : <NEWLINE> <INDENT> S = <STRING> + S <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> S = <STRING> + S <NEWLINE> <DEDENT> <DEDENT> i += 1 <NEWLINE> <DEDENT> lis . append ( int ( S ) ) <NEWLINE> <DEDENT> print ( * S ) <NEWLINE>
import numpy as np <NEWLINE> n = int ( input ( ) ) <NEWLINE> * a , = map ( int , input ( ) . split ( ) ) <NEWLINE> x = 0 <NEWLINE> for ai in a : <NEWLINE> <INDENT> x ^= ai <NEWLINE> <NL> <DEDENT> ans = [ ai ^ x for ai in ans ] <NEWLINE> print ( * ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> x = 0 <NEWLINE> for i in a : <NEWLINE> <INDENT> x ^= i <NEWLINE> <DEDENT> print ( * list ( map ( lamda y : x ^ y , a ) ) ) <NEWLINE>
import sys <NEWLINE> from typing import Callable , List , NoReturn <NEWLINE> <NL> import numpy as np <NEWLINE> <NL> <NL> def main ( ) -> NoReturn : <NEWLINE> <INDENT> readline : Callable [ [ ] , str ] = sys . stdin . readline <NEWLINE> n : int = int ( readline ( ) . rstrip ( ) ) <NEWLINE> a : np . ndarray = np . array ( tuple ( int ( _ ) for _ in readline ( ) . rstrip ( ) . split ( ) ) ) <NEWLINE> <NL> xor_all : int = 0 <NEWLINE> for a_n in a : <NEWLINE> <INDENT> xor_all ^= a_n <NEWLINE> <NL> <DEDENT> values = np . bitwise_xor ( a , xor_all ) <NEWLINE> print ( <STRING> . join ( values ) ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
k = int ( input ( ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> s = int ( input ( ) ) <NEWLINE> <NL> mod = 10 ** 9 + 7 <NEWLINE> n = k + s <NEWLINE> <NL> <NL> def _fac_inv ( _n , _mod ) : <NEWLINE> <INDENT> _fac = [ 1 ] * ( _n + 1 ) <NEWLINE> _inv = [ 1 ] * ( _n + 1 ) <NEWLINE> for i in range ( _n ) : <NEWLINE> <INDENT> _fac [ i + 1 ] = _fac [ i ] * ( i + 1 ) % _mod <NEWLINE> <DEDENT> _inv [ _n ] = pow ( _fac [ _n ] , _mod - 2 , _mod ) <NEWLINE> for i in range ( _n , 0 , - 1 ) : <NEWLINE> <INDENT> _inv [ i - 1 ] = _inv [ i ] * i % _mod <NEWLINE> <NL> <DEDENT> return _fac , _inv <NEWLINE> <NL> <NL> <DEDENT> fac , inv = _fac_inv ( n , mod ) <NEWLINE> <NL> n25 = [ 1 ] <NEWLINE> n26 = [ 1 ] <NEWLINE> for _ in range ( n - s ) : <NEWLINE> <INDENT> n25 . append ( ( n25 [ - 1 ] * 25 ) % mod ) <NEWLINE> n26 . append ( ( n26 [ - 1 ] * 26 ) % mod ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> <NL> for i in range ( s , n + 1 ) : <NEWLINE> <INDENT> ans = ( ans + fac [ i - 1 ] * inv [ s - 1 ] * inv [ i - s ] * n25 [ i - s ] * n26 [ n - i ] ) % mod <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> import numpy as np <NEWLINE> readline = sys . stdin . readline <NEWLINE> <NL> MOD = 10 ** 9 + 7 <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> def fact_table ( N , MOD ) : <NEWLINE> <INDENT> inv = np . empty ( N , np . int64 ) <NEWLINE> inv [ 0 ] = 0 <NEWLINE> inv [ 1 ] = 1 <NEWLINE> for n in range ( 2 , N ) : <NEWLINE> <INDENT> q , r = divmod ( MOD , n ) <NEWLINE> inv [ n ] = inv [ r ] * ( - q ) % MOD <NEWLINE> <DEDENT> fact = np . empty ( N , np . int64 ) <NEWLINE> fact [ 0 ] = 1 <NEWLINE> for n in range ( 1 , N ) : <NEWLINE> <INDENT> fact [ n ] = n * fact [ n - 1 ] % MOD <NEWLINE> <DEDENT> fact_inv = np . empty ( N , np . int64 ) <NEWLINE> fact_inv [ 0 ] = 1 <NEWLINE> for n in range ( 1 , N ) : <NEWLINE> <INDENT> fact_inv [ n ] = fact_inv [ n - 1 ] * inv [ n ] % MOD <NEWLINE> <DEDENT> return fact , fact_inv , inv <NEWLINE> <NL> <DEDENT> fac , finv , inv = fact_table ( 2_000_010 , MOD ) <NEWLINE> K = int ( readline ( ) ) <NEWLINE> N = len ( readline ( ) ) <NEWLINE> f = np . zeros ( K + 1 , np . int64 ) <NEWLINE> f = fac [ N - 1 : K + N ] * finv [ N - 1 ] % MOD * finv [ : K + 1 ] % MOD <NEWLINE> <NL> x = 1 <NEWLINE> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> x = ( x * 25 ) % MOD <NEWLINE> f [ i ] = f [ i ] * x % MOD <NEWLINE> <DEDENT> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> f [ i ] += f [ i - 1 ] * 26 <NEWLINE> f [ i ] %= MOD <NEWLINE> <NL> <DEDENT> print ( f [ - 1 ] ) <NEWLINE> <NL> <NL> <DEDENT> import numba <NEWLINE> from numba . pycc import CC <NEWLINE> i8 = numba . from_dtype ( np . int64 ) <NEWLINE> signature = ( i8 , i8 , i8 ) <NEWLINE> <NL> main ( ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> mod = 10 ** 9 + 7 <NEWLINE> k = int ( input ( ) ) <NEWLINE> n = len ( input ( ) ) <NEWLINE> <NL> @ njit ( i8 [ : ] ( i8 , i8 ) , cache = True ) <NEWLINE> def num_calc ( n , mod ) : <NEWLINE> <INDENT> fact = np . ones ( n + 1 , dtype = np . int64 ) <NEWLINE> for i in range ( 2 , n + 1 ) : <NEWLINE> <INDENT> fact [ i ] = fact [ i - 1 ] * i % mod <NEWLINE> <DEDENT> return fact <NEWLINE> <NL> <DEDENT> @ njit ( i8 [ : ] ( i8 , i8 ) , cache = True ) <NEWLINE> def num_calc2 ( k , mod ) : <NEWLINE> <INDENT> power = np . ones ( k + 1 , dtype = np . int64 ) <NEWLINE> for i in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> power [ i ] = power [ i - 1 ] * 25 % mod <NEWLINE> <DEDENT> return power <NEWLINE> <NL> <DEDENT> @ njit ( i8 ( i8 , i8 , i8 ) , cache = True ) <NEWLINE> def pow ( n , k , mod = 10 ** 9 + 7 ) : <NEWLINE> <INDENT> l , now = np . ones ( 64 , np . int64 ) , 1 <NEWLINE> l [ 0 ] = n <NEWLINE> for i in range ( 1 , 64 ) : <NEWLINE> <INDENT> l [ i ] = l [ i - 1 ] * l [ i - 1 ] % mod <NEWLINE> <DEDENT> for i in range ( 64 ) : <NEWLINE> <INDENT> if k & 1 : <NEWLINE> <INDENT> now = now * l [ i ] % mod <NEWLINE> <DEDENT> k >>= 1 <NEWLINE> <DEDENT> return now <NEWLINE> <NL> <DEDENT> fact = num_calc ( n + k , mod ) <NEWLINE> nk = fact [ n + k ] <NEWLINE> fact = fact [ n + k : n - 1 : - 1 ] * fact [ : k + 1 ] % mod <NEWLINE> power = ( num_calc2 ( k , mod ) * nk ) % mod <NEWLINE> <NL> print ( sum ( [ pow ( i , mod - 2 , mod ) * j for i , j in zip ( fact , power ) ] ) % mod ) <NEWLINE> <NL> <NL> <DEDENT> main ( ) <NEWLINE>
import sys <NEWLINE> import numpy as np <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> <NL> MOD = 10 ** 9 + 7 <NEWLINE> <NL> <NL> def main ( K , N , MOD ) : <NEWLINE> <INDENT> def cumprod ( A , mod = MOD ) : <NEWLINE> <INDENT> L = len ( A ) <NEWLINE> Lsq = int ( L ** .5 + 1 ) <NEWLINE> A = np . resize ( A , Lsq ** 2 ) . reshape ( Lsq , Lsq ) <NEWLINE> for n in range ( 1 , Lsq ) : <NEWLINE> <INDENT> A [ : , n ] *= A [ : , n - 1 ] <NEWLINE> A [ : , n ] %= mod <NEWLINE> <DEDENT> for n in range ( 1 , Lsq ) : <NEWLINE> <INDENT> A [ n ] *= A [ n - 1 , - 1 ] <NEWLINE> A [ n ] %= mod <NEWLINE> <DEDENT> return A . ravel ( ) [ : L ] <NEWLINE> <NL> <DEDENT> def make_fact ( U , mod = MOD ) : <NEWLINE> <INDENT> x = np . arange ( U , dtype = np . int64 ) <NEWLINE> x [ 0 ] = 1 <NEWLINE> fact = cumprod ( x , mod ) <NEWLINE> x = np . arange ( U , 0 , - 1 , dtype = np . int64 ) <NEWLINE> x [ 0 ] = pow ( int ( fact [ - 1 ] ) , mod - 2 , mod ) <NEWLINE> fact_inv = cumprod ( x , mod ) [ : : - 1 ] <NEWLINE> fact . flags . writeable = False <NEWLINE> fact_inv . flags . writeable = False <NEWLINE> return fact , fact_inv <NEWLINE> <NL> <DEDENT> fac , finv = make_fact ( 2_000_010 , MOD ) <NEWLINE> f = np . zeros ( K + 1 , np . int64 ) <NEWLINE> f = fac [ N - 1 : K + N ] * finv [ N - 1 ] % MOD * finv [ : K + 1 ] % MOD <NEWLINE> <NL> x = 1 <NEWLINE> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> x = ( x * 25 ) % MOD <NEWLINE> f [ i ] = f [ i ] * x % MOD <NEWLINE> <DEDENT> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> f [ i ] += f [ i - 1 ] * 26 <NEWLINE> f [ i ] %= MOD <NEWLINE> <DEDENT> return f [ - 1 ] <NEWLINE> <NL> <NL> <DEDENT> if sys . argv [ - 1 ] == <STRING> : <NEWLINE> <INDENT> import numba <NEWLINE> from numba . pycc import CC <NEWLINE> i8 = numba . from_dtype ( np . int64 ) <NEWLINE> signature = ( i8 , i8 , i8 ) <NEWLINE> cc = CC ( <STRING> ) <NEWLINE> cc . export ( <STRING> , signature ) ( main ) <NEWLINE> cc . compile ( ) <NEWLINE> <NL> <DEDENT> from my_module import main <NEWLINE> K = int ( readline ( ) ) <NEWLINE> N = len ( readline ( ) ) <NEWLINE> print ( main ( K , N , MOD ) ) <NEWLINE>
def calc_inv ( n , mod_n ) : <NEWLINE> <INDENT> inv_li = [ 0 ] * ( n + 2 ) <NEWLINE> inv_li [ 0 ] = 0 <NEWLINE> inv_li [ 1 ] = 1 <NEWLINE> for i in range ( 2 , n + 2 ) : <NEWLINE> <INDENT> q , r = divmod ( mod_n , i ) <NEWLINE> inv_li [ i ] = - inv_li [ r ] * q % mod_n <NEWLINE> <DEDENT> return inv_li <NEWLINE> <NL> <NL> <DEDENT> MOD = 10 ** 9 + 7 <NEWLINE> inv = calc_inv ( max ( K , 26 ) + 10 , MOD ) <NEWLINE> <NL> K = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> s_len = len ( S ) <NEWLINE> <NL> <NL> ans = 0 <NEWLINE> p = pow ( 26 , K , MOD ) <NEWLINE> <NL> for i in range ( 1 , K + 2 ) : <NEWLINE> <INDENT> ans = ( ans + p % MOD ) % MOD <NEWLINE> p = p * ( s_len + i - 1 ) * inv [ i ] * 25 * inv [ 26 ] % MOD <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> <NL> K = int ( sys . stdin . readline ( ) ) <NEWLINE> S = sys . stdin . readline ( ) . rstrip ( <STRING> ) <NEWLINE> <NL> <COMMENT> <NL> N_MAX = 10 ** 6 <COMMENT> <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> <NL> inv = [ 0 ] * ( N_MAX + 2 ) <NEWLINE> inv [ 0 ] = 0 <COMMENT> <NEWLINE> inv [ 1 ] = 1 <NEWLINE> <NL> for i in range ( 2 , N_MAX + 2 ) : <NEWLINE> <INDENT> q , r = divmod ( MOD , i ) <NEWLINE> inv [ i ] = - inv [ r ] * q % MOD <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> ans = 0 <NEWLINE> <NL> ln = len ( S ) <NEWLINE> <NL> p = pow ( 26 , K , MOD ) <NEWLINE> <NL> st = time . time ( ) <NEWLINE> for i in range ( 1 , K + 2 ) : <NEWLINE> <NL> <INDENT> ans += p % MOD <NEWLINE> ans %= MOD <NEWLINE> <NL> <COMMENT> <NL> p = p * ( ln + i - 1 ) * inv [ i ] * 25 * inv [ 26 ] % MOD <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> en = time . time ( ) <NEWLINE> <NL> print ( ans ) <NEWLINE>
K = int ( input ( ) ) <NEWLINE> L = len ( input ( ) ) <NEWLINE> m = 10 ** 9 + 7 <NEWLINE> from numba import * <NEWLINE> @ njit ( cache = 1 ) <NEWLINE> def f ( ) : <NEWLINE> <INDENT> max_n = 2 * 10 ** 6 <NEWLINE> fac = [ 1 ] * ( max_n + 1 ) <NEWLINE> inv = [ 1 ] * ( max_n + 1 ) <NEWLINE> ifac = [ 1 ] * ( max_n + 1 ) <NEWLINE> for n in range ( 2 , max_n + 1 ) : <NEWLINE> <INDENT> fac [ n ] = ( fac [ n - 1 ] * n ) % m <NEWLINE> inv [ n ] = m - inv [ m % n ] * ( m // n ) % m <NEWLINE> ifac [ n ] = ( ifac [ n - 1 ] * inv [ n ] ) % m <NEWLINE> <DEDENT> return fac , inv , ifac <NEWLINE> <DEDENT> fac , inv , ifac = f ( ) <NEWLINE> def comb ( n , k ) : <NEWLINE> <INDENT> if n < k or n < 0 or k < 0 : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> return ( fac [ n ] * ifac [ k ] * ifac [ n - k ] ) % m <NEWLINE> <DEDENT> d = [ 1 ] * ( K + 1 ) <NEWLINE> d2 = [ 1 ] * ( K + 1 ) <NEWLINE> for i in range ( K ) : <NEWLINE> <INDENT> d [ i + 1 ] = d [ i ] * 25 % m <NEWLINE> d2 [ i + 1 ] = d2 [ i ] * 26 % m <NEWLINE> <DEDENT> print ( sum ( [ comb ( L + i - 1 , i ) * d [ i ] * d2 [ K - i ] % m for i in range ( K + 1 ) ] ) % m ) <NEWLINE>
MAX = 10 ** 6 <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> <NL> fac = [ 0 ] * MAX <NEWLINE> finv = [ 0 ] * MAX <NEWLINE> inv = [ 0 ] * MAX <NEWLINE> <NL> def comb_init ( ) : <NEWLINE> <INDENT> fac [ 0 ] = fac [ 1 ] = 1 <NEWLINE> finv [ 0 ] = finv [ 1 ] = 1 <NEWLINE> inv [ 1 ] = 1 <NEWLINE> for i in range ( 2 , MAX ) : <NEWLINE> <INDENT> fac [ i ] = fac [ i - 1 ] * i % MOD <NEWLINE> inv [ i ] = MOD - inv [ MOD % i ] * ( MOD // i ) % MOD <NEWLINE> finv [ i ] = finv [ i - 1 ] * inv [ i ] % MOD <NEWLINE> <NL> <DEDENT> <DEDENT> def comb ( n , k ) : <NEWLINE> <INDENT> if n < k : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> if n < 0 or k < 0 : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> return fac [ n ] * ( finv [ k ] * finv [ n - k ] % MOD ) % MOD <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> k = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> n = len ( s ) <NEWLINE> comb_init ( ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( k + 1 ) : <NEWLINE> <INDENT> val = comb ( i + n - 1 , n - 1 ) <NEWLINE> val *= pow ( 25 , i , MOD ) <NEWLINE> val %= MOD <NEWLINE> val *= pow ( 26 , k - i , MOD ) <NEWLINE> val %= MOD <NEWLINE> ans += val <NEWLINE> ans %= MOD <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
x = int ( input ( ) ) <NEWLINE> x = i <NEWLINE> if x > 90 : <NEWLINE> <INDENT> x = x - 90 <NEWLINE> <DEDENT> ans = 0 <NEWLINE> a = 360 <NEWLINE> while True : <NEWLINE> <INDENT> if a % x == 0 : <NEWLINE> <INDENT> ans += a // x <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> rem = a % x <NEWLINE> ans += a // x <NEWLINE> a -= rem <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
X = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> K = 1 <NEWLINE> direct = X <NEWLINE> while True : <NEWLINE> <NL> <INDENT> if direct % 360 = 0 <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> direct += X <NEWLINE> K += 1 <NEWLINE> <NL> <DEDENT> print ( K ) <NEWLINE>
X = int ( input ( ) ) <NEWLINE> B = 0 <NEWLINE> C = 0 <NEWLINE> for i in range ( 0 , 360 ) : <NEWLINE> <INDENT> B = B + X <NEWLINE> C = B % 360 <NEWLINE> K = K + 1 <NEWLINE> if C == 0 : <NEWLINE> <INDENT> print ( K ) <NEWLINE> break <NEWLINE> <NL> <NL> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> var = 1 <NEWLINE> if n % 360 == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> while True : <NEWLINE> <INDENT> if ( n * var ) % 360 == 0 : <NEWLINE> <INDENT> print ( var ) <NEWLINE> <INDENT> exit ( ) <NEWLINE> var += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> p = 1 <NEWLINE> if 360 // n == 0 : <NEWLINE> <INDENT> print ( 360 // n ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> while true : <NEWLINE> if n * p % 360 == 0 : <NEWLINE> <INDENT> print ( n ) <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> n += 1 <NEWLINE> <DEDENT> <DEDENT>
import math <NEWLINE> <NL> x = int ( input ( ) ) <NEWLINE> g = math . gdc ( x , 360 ) <NEWLINE> print ( 360 // g ) <NEWLINE>
x = int ( input ( ) ) <NEWLINE> <NL> def lcm ( x , y ) : <NEWLINE> <INDENT> return ( x * y ) // math . gcd ( x , y ) <NEWLINE> <NL> <DEDENT> print ( lcm ( x , 360 ) // x ) <NEWLINE>
import math <NEWLINE> <NL> x = float ( input ( ) ) <NEWLINE> <NL> if 360 % x == 0 : <NEWLINE> <INDENT> print ( math . floor ( k ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( math . ceil ( k ) ) <NEWLINE> <DEDENT>
x = int ( input ( ) ) <NEWLINE> for i in range ( 100000 ) : <NEWLINE> <INDENT> if x * i % 360 == 0 : <NEWLINE> <INDENT> print ( i ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> print ( int ( 360 / math . gcd ( n , 360 ) ) ) <NEWLINE>
X = int ( input ( ) ) <NEWLINE> <NL> K = 1 <NEWLINE> y = X % 360 <NEWLINE> while y != 0 : <NEWLINE> <INDENT> K += 1 <NEWLINE> y = ( y + X ) % 360 <NEWLINE> <COMMENT> <NL> <DEDENT> print ( k ) <NEWLINE> <NL>
import numpy as np <NEWLINE> <NL> rotate = int ( input ( ) ) <NEWLINE> <NL> x = 0 <NEWLINE> y = 1 <NEWLINE> heading = 0 <NEWLINE> <NL> count = 1 <NEWLINE> <NL> while x != 0 and y != 0 : <NEWLINE> <INDENT> heading += rotate <NEWLINE> x += cos ( np . deg2rad ( heading ) ) <NEWLINE> y += sin ( np . deg2rad ( heading ) ) <NEWLINE> count + + <NEWLINE> <NL> <DEDENT> print ( count ) <NEWLINE>
from math import gcd <NEWLINE> print ( 360 // gcd ( 360 , int ( input ( ) ) ) <NEWLINE>
x = int ( input ( ) ) <NEWLINE> s = x * 360 / math . gcd ( x , 360 ) <NEWLINE> print ( s / x ) <NEWLINE>
print ( 360 / X ) <NEWLINE>
X = int ( input ( ) ) <NEWLINE> k = 1 <NEWLINE> n = 1 <NEWLINE> <NL> while true : <NEWLINE> <INDENT> ans = 360 * n % X <NEWLINE> if ans == 0 : <NEWLINE> <INDENT> print ( 360 * n / X ) <NEWLINE> break ; <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> n += 1 <NEWLINE> <DEDENT> <DEDENT>
import math <NEWLINE> tol = 1e-6 <NEWLINE> ans = 1 <NEWLINE> cur = [ 0 , 0 ] <NEWLINE> cur [ 0 ] += math . cos ( ans * math . pi / x ) <NEWLINE> cur [ 1 ] += math . sin ( ans * math . pi / x ) <NEWLINE> while cur [ 0 ] ** 2 + cur [ 1 ] ** 2 > tol : <NEWLINE> <INDENT> ans += 1 <NEWLINE> cur [ 0 ] += math . cos ( ans * math . pi / x ) <NEWLINE> cur [ 1 ] += math . sin ( ans * math . pi / x ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
X = int ( input ) <NEWLINE> print ( 360 / x ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> <NL> def mi ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def ii ( ) : return int ( input ( ) ) <NEWLINE> def isp ( ) : return input ( ) . split ( ) <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> X = ii ( ) <NEWLINE> print ( 360 // math . gcd ( X , 360 ) ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
45 tokabaguruna <NEWLINE>
a = 360 / n <NEWLINE> b = a - 360 // n <NEWLINE> print ( int ( n * 360 / math . gcd ( n , 360 ) / n ) ) <NEWLINE>
x = int ( input ( ) ) <NEWLINE> for i in range ( 1 , 361 ) : <NEWLINE> <INDENT> if 360 * i % x == = 0 : <NEWLINE> <INDENT> print ( 360 * i // x ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( 360 ) <NEWLINE> <DEDENT>
import math <NEWLINE> <NL> x = list ( map ( int , input ( ) ) ) <NEWLINE> <NL> print ( 360 * x / gcd ( 360 , x ) ) <NEWLINE> <NL>
X = int ( input ( ) ) <NEWLINE> import math <NEWLINE> print ( 360 * X // math . gcd ( 360 , X ) <NEWLINE>
X = int ( input ( ) ) <NEWLINE> rad = 90 <NEWLINE> cnt = 0 <NEWLINE> <NL> while True : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> if rad == 360 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> rad += X <NEWLINE> rad = rad if rad < 360 else rad = 360 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> X = int ( input ( ) ) <NEWLINE> <NL> for i in range ( 10 ** 5 ) : <NEWLINE> <INDENT> t += X <NEWLINE> if t % 360 == 0 : <NEWLINE> <INDENT> return i + 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( main ( ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> print ( ceil ( 360 / n ) ) <NEWLINE>
print ( 360 // input ( ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> print ( int ( 360 / math . gcd ( n , 360 ) ) ) <NEWLINE>
x = int ( input ( ) ) <NEWLINE> k = 360 % x <NEWLINE> j = 360 // x <NEWLINE> v = k <NEWLINE> while 360 % k != 0 : <NEWLINE> <INDENT> k = 360 % k <NEWLINE> v += k <NEWLINE> <DEDENT> v1 = 360 // v <NEWLINE> print ( j * v1 ) <NEWLINE>
X = int ( input ( ) ) <NEWLINE> if 360 % K == 0 : <NEWLINE> <INDENT> K = 360 // X <NEWLINE> print ( K ) <NEWLINE> <DEDENT> elif 360 % K != 0 : <NEWLINE> <INDENT> K = 2 * 360 // ( 180 - X ) <NEWLINE> print ( K ) <NEWLINE> <DEDENT>
max_test = 100000 <NEWLINE> for i in range ( max_test ) : <NEWLINE> <INDENT> if i * X % 360 == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> return I + 1 <NEWLINE>
x = int ( input ( ) ) <NEWLINE> print ( int ( math . ceil ( 360 / x ) ) ) <NEWLINE>
a , b , c , d , e = ( int ( x ) for i in input ( ) . split ( ) ) <NEWLINE> if a == 0 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> if b == 0 : <NEWLINE> <INDENT> print ( 2 ) <NEWLINE> <DEDENT> if c == 0 : <NEWLINE> <INDENT> print ( 3 ) <NEWLINE> <DEDENT> if d == 0 : <NEWLINE> <INDENT> print ( 4 ) <NEWLINE> <DEDENT> if e == 0 : <NEWLINE> <INDENT> print ( 5 ) <NEWLINE> <DEDENT>
x = list ( int , input ( ) . split ( ) ) <NEWLINE> for i in range ( 5 ) : <NEWLINE> <INDENT> if x [ i ] == 0 : <NEWLINE> <INDENT> print ( i ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT>
x = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i in range ( len ( x ) ) : <NEWLINE> <INDENT> if x [ i ] == 0 : <NEWLINE> <INDENT> print ( x + 1 ) <NEWLINE> <DEDENT> <DEDENT>
i = input ( ) <NEWLINE> p = i . index ( 0 ) + 1 <NEWLINE> print ( p ) <NEWLINE>
x = list ( map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> for i in range ( 5 ) : <NEWLINE> <INDENT> if x [ i ] == 0 : <NEWLINE> <INDENT> print ( i + 1 ) <NEWLINE> <DEDENT> <DEDENT>
a = input ( ) <NEWLINE> j = 1 <NEWLINE> for i in a : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> print ( j ) <NEWLINE> j + + <NEWLINE> <DEDENT> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> from operator import itemgetter <NEWLINE> import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> X = list ( map ( int , input ( ) . split ) ) <NEWLINE> for i in range ( X ) : <NEWLINE> <INDENT> if X [ i ] == 0 : <NEWLINE> <INDENT> print ( i + 1 ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> main ( ) <NEWLINE>
x_list = [ input ( ) ] <NEWLINE> for i in range ( 5 ) : <NEWLINE> <INDENT> if x_list [ i ] == 0 : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT> <DEDENT>
rint ( 15 - sum ( list ( map ( int , input ( ) . split ( ) ) ) ) ) <NEWLINE>
ind = 1 <NEWLINE> for i in a : <NEWLINE> <INDENT> if i == <STRING> : <NEWLINE> <INDENT> print ( ind ) <NEWLINE> break <NEWLINE> <DEDENT> ind += 1 <NEWLINE> <DEDENT>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 8 ) <NEWLINE> def line_to_int ( ) : return int ( sys . stdin . readline ( ) ) <NEWLINE> def line_to_each_int ( ) : return map ( int , sys . stdin . readline ( ) . split ( ) ) <NEWLINE> def line_to_list ( ) : return list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) <NEWLINE> def line_to_list_in_iteration ( N ) : return [ list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) for i in range ( N ) ] <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> n , k = line_to_each_int ( ) <NEWLINE> p = line_to_list ( ) <NEWLINE> <NL> p = sorted ( p ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> ans += p [ i ] <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
a = int ( input ( ) ) <NEWLINE> a = a . split ( <STRING> ) <NEWLINE> c = 0 <NEWLINE> for i in a : <NEWLINE> <INDENT> c += 1 <NEWLINE> if i == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> print ( c ) <NEWLINE>
D = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in D : <NEWLINE> <INDENT> if D [ i ] == 0 : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> <NL> x = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( x . index ( 0 ) + 1 ) <NEWLINE>
x = map ( int , input ( ) . split ( ) ) <NEWLINE> for i in range ( len ( x ) ) : <NEWLINE> <INDENT> if x [ i ] == 0 : <NEWLINE> <INDENT> print ( i + 1 ) <NEWLINE> <DEDENT> <DEDENT>
X = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> print ( A . index ( 0 ) + 1 ) <NEWLINE>
lst = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> for i in range ( lst ) : <NEWLINE> <INDENT> if lst [ i ] == 0 : <NEWLINE> <INDENT> ans = i + 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from bisect import bisect_left , bisect_right <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a . sort ( ) <NEWLINE> m = a [ - 1 ] <NEWLINE> c = [ 0 ] * ( m + 1 ) <NEWLINE> <NL> for ai in a : <NEWLINE> <INDENT> for i in range ( ai , m + 1 , ai ) : <NEWLINE> <INDENT> if bisect_right ( a , i ) - bisect_left ( a , i ) == 1 : <NEWLINE> <INDENT> c [ i ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( c . count ( 1 ) ) <NEWLINE>
a = input ( ) <NEWLINE> b = a . split ( <STRING> ) <NEWLINE> for i in len ( b ) : <NEWLINE> <INDENT> if b [ i ] == <STRING> : <NEWLINE> <INDENT> print ( i + 1 ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT>
x = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> x_l = [ 1 , 2 , 3 , 4 , 5 ] <NEWLINE> <NL> for i in range ( ren ( x_l ) ) : <NEWLINE> <INDENT> if x_l [ i ] != x [ i ] : <NEWLINE> <INDENT> print ( i + 1 ) <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> a = map ( int , sys . stdin . readline ( ) . rstrip ( ) . split ( <STRING> ) ) <NEWLINE> <NL> for i in range ( len ( a ) ) : <NEWLINE> <INDENT> if a [ i ] == 0 : <NEWLINE> <INDENT> print ( i + 1 ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT>
a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> print ( a . index ( <STRING> ) ) <NEWLINE>
x = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 5 ) : <NEWLINE> <INDENT> if x [ i ] == 0 : <NEWLINE> <INDENT> ans = i + 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
X = list ( int , input ( ) . split ( ) ) <NEWLINE> <NL> for i , x in enumerate ( X ) : <NEWLINE> <INDENT> if x == 0 : <NEWLINE> <INDENT> print ( i + 1 ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT>
<NL> def main ( ) : <NEWLINE> <INDENT> a = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 5 ) : <NEWLINE> <INDENT> ans += a [ i ] <NEWLINE> <DEDENT> print ( 15 - ans ) <NEWLINE> <DEDENT> main ( ) <NEWLINE>
X = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if X [ 0 ] == 0 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> elif X [ 1 ] == 0 : <NEWLINE> <INDENT> print ( 2 ) <NEWLINE> <DEDENT> elif X [ 2 ] == 0 : <NEWLINE> <INDENT> print ( 3 ) <NEWLINE> <DEDENT> elif X [ 3 ] == 0 : <NEWLINE> <INDENT> print ( 4 ) <NEWLINE> else : <NEWLINE> print ( 5 ) <NEWLINE> <DEDENT>
n = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> x = s . index ( 0 ) <NEWLINE> print ( x + 1 ) <NEWLINE>
X = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if X [ 0 ] == 0 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> elif X [ 1 ] == 0 : <NEWLINE> <INDENT> print ( 2 ) <NEWLINE> elif X [ 2 ] == 0 : <NEWLINE> print ( 3 ) <NEWLINE> elif X [ 3 ] == 0 : <NEWLINE> print ( 4 ) <NEWLINE> else : <NEWLINE> print ( 5 ) <NEWLINE> <DEDENT> <DEDENT>
x = [ ] <NEWLINE> z = 1 <NEWLINE> while z != 6 : <NEWLINE> <INDENT> print ( <STRING> + z , <STRING> ) <NEWLINE> x . append ( input ( ) ) <NEWLINE> z += 1 <NEWLINE> <DEDENT> y = 0 <NEWLINE> for i in x : <NEWLINE> <INDENT> if x [ y ] == <STRING> : <NEWLINE> <INDENT> print ( y + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> y += 1 <NEWLINE> <DEDENT>
x1 = input ( ) <NEWLINE> x2 = input ( ) <NEWLINE> x3 = input ( ) <NEWLINE> x4 = input ( ) <NEWLINE> x5 = input ( ) <NEWLINE> <NL> if ( x1 == 0 ) : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> if ( x2 == 0 ) : <NEWLINE> <INDENT> print ( 2 ) <NEWLINE> <DEDENT> if ( x3 == 0 ) : <NEWLINE> <INDENT> print ( 3 ) <NEWLINE> <DEDENT> if ( x4 == 0 ) : <NEWLINE> <INDENT> print ( 4 ) <NEWLINE> <DEDENT> if ( x5 == 0 ) : <NEWLINE> <INDENT> print ( 5 ) <NEWLINE> <DEDENT>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> c = 1 <NEWLINE> for i in range ( 0 , a + 1 ) : <NEWLINE> <INDENT> if 2 * i + 4 * ( a - i ) == b : <NEWLINE> <INDENT> c = 0 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if c == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = 5 <NEWLINE> Si = n ( n + 1 ) / 2 <NEWLINE> lst = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> Sr = sum ( lst ) <NEWLINE> print ( Si - Sr ) <NEWLINE>
user_input = input ( ) <NEWLINE> user_input = user_input . split ( ) <NEWLINE> for i in range ( len ( user_input ) ) : <NEWLINE> <INDENT> if user_input [ i ] == <STRING> : <NEWLINE> <INDENT> print ( i + 1 ) <NEWLINE> <DEDENT> <DEDENT>
for num in range ( 0 , 5 , 1 ) : <NEWLINE> <INDENT> x = int ( input ( ) ) <NEWLINE> if x == 0 : <NEWLINE> <INDENT> print ( num + 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> <NL> a = sys . stdin . read ( ) <NEWLINE> for i , v in enumerate ( map ( int , a . split ) , 1 ) : <NEWLINE> <INDENT> if v == 0 : <NEWLINE> <INDENT> print ( i ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT>
p = input ( ) <NEWLINE> <NL> a = <STRING> <NEWLINE> <NL> b = a % 10 <NEWLINE> c = a % 100 <NEWLINE> d = a % 1000 <NEWLINE> e = a % 10000 <NEWLINE> <NL> <NL> if a % 10 == 0 : <NEWLINE> print ( 5 ) <NEWLINE> elif ( a - b ) % 100 == 0 : <NEWLINE> print ( 4 ) <NEWLINE> elif ( a - c ) % 1000 == 0 : <NEWLINE> print ( 3 ) <NEWLINE> elif ( a - d ) % 10000 == 0 : <NEWLINE> print ( 2 ) <NEWLINE> else : <NEWLINE> print ( 1 ) <NEWLINE>
<COMMENT> <NL> <NL> import sys , copy , bisect , itertools , heapq , math <NEWLINE> from heapq import heappop , heappush , heapify <NEWLINE> from collections import Counter , defaultdict <NEWLINE> <NL> <NL> x = S_LIST ( ) <NEWLINE> <NL> <NL> print ( x . index ( <STRING> ) + 1 ) <NEWLINE>
<COMMENT> <NL> a , b , c , d , e = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> suuji_list = [ <STRING> , a , b , c , d , e ] <NEWLINE> <NL> print ( list . index ( 0 ) ) <NEWLINE>
lst = [ ] <NEWLINE> <NL> for i in range ( 5 ) : <NEWLINE> <INDENT> element = int ( input ( ) ) <NEWLINE> lst . append ( element ) <NEWLINE> <NL> <DEDENT> n = lst . index ( 0 ) <NEWLINE> print ( n + 1 ) <NEWLINE> <NL>
l = list ( map ( int , input ( ) . split ( ) ) <NEWLINE> for i in range ( len ( l ) ) : <NEWLINE> <INDENT> if l [ i ] == 0 : <NEWLINE> <INDENT> print ( i + 1 ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT>
X = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i in range ( len ( X ) ) : <NEWLINE> <INDENT> if X [ i - 1 ] = 0 : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT> <DEDENT>
x = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> for i in range ( 5 ) : <NEWLINE> <INDENT> if x [ i ] == 0 : <NEWLINE> <INDENT> print ( i + 1 ) <NEWLINE> <DEDENT> <DEDENT>
rt = list ( map ( in ( t , input ( ) . split ( ) ) ) <NEWLINE> for i in range ( 0 , 4 ) : <NEWLINE> <INDENT> if ( rt [ i ] == 0 ) : <NEWLINE> <INDENT> print ( i + 1 ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT>
a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> print ( aa . index ( 0 ) ) <NEWLINE>
a = map . int ( input ( ) . split ( ) ) <NEWLINE> print ( 15 - sum ( a ) ) <NEWLINE>
nums = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = - 1 <NEWLINE> for i in nums : <NEWLINE> <INDENT> if nums [ i ] == 0 : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT> <DEDENT>
a = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> for i in range ( 0 , a . len ( ) ) : <NEWLINE> <INDENT> if a [ i ] == 0 : <NEWLINE> <INDENT> print ( i + 1 ) <NEWLINE> <DEDENT> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> input_number = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i in input : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> print ( i ) <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
a = [ int ( _ ) for _ in inpur ( ) . split ( ) ] <NEWLINE> print ( a . index ( 0 ) + 1 ) <NEWLINE>
a , b , c , d , e = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <NL> if a == 0 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> elif b == 0 : <NEWLINE> print ( 2 ) <NEWLINE> elif c == 0 : <NEWLINE> print ( 3 ) <NEWLINE> elif d == 0 : <NEWLINE> print ( 4 ) <NEWLINE> else : <NEWLINE> print ( 5 ) <NEWLINE> <DEDENT>
l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c = collections . Counter ( l ) <NEWLINE> def j ( n ) : <NEWLINE> <INDENT> judge = 1 <NEWLINE> for k in c . keys ( ) : <NEWLINE> <INDENT> if n % k == 0 : <NEWLINE> <INDENT> if n != k : <NEWLINE> <INDENT> judge = 0 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return judge <NEWLINE> <DEDENT> count = 0 <NEWLINE> if len ( list ( c . keys ( ) ) ) == 1 : <NEWLINE> <INDENT> print ( count ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for k in c . keys ( ) : <NEWLINE> <INDENT> if j ( k ) == 1 : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> X , N = map ( int , input ( ) . split ( ) ) <NEWLINE> P = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if X < 1 or 100 < X : <NEWLINE> <INDENT> sys . exit ( ) <NEWLINE> <DEDENT> if N < 0 or 100 < N : <NEWLINE> <INDENT> sys . exit ( ) <NEWLINE> <DEDENT> if N == 0 : <NEWLINE> <INDENT> print ( X ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> P_number = len ( P ) <NEWLINE> if P_number < 1 or 100 < P_number : <NEWLINE> <INDENT> sys . exit ( ) <NEWLINE> <NL> <DEDENT> res1 = 100 <NEWLINE> res2 = 100 <NEWLINE> res0 = 0 <NEWLINE> i = 0 <NEWLINE> j = 0 <NEWLINE> while i <= N : <NEWLINE> <INDENT> if ( X - i ) not in P : <NEWLINE> <INDENT> res1 = ( X - i ) <NEWLINE> break <NEWLINE> <DEDENT> i += 1 <NEWLINE> <DEDENT> while j <= N : <NEWLINE> <INDENT> if ( X + j ) not in P : <NEWLINE> <INDENT> res2 = ( X + j ) <NEWLINE> break <NEWLINE> <DEDENT> j += 1 <NEWLINE> <DEDENT> if i > j : <NEWLINE> <INDENT> res0 = res2 <NEWLINE> <DEDENT> elif j > i : <NEWLINE> <INDENT> res0 = res1 <NEWLINE> <DEDENT> elif i == j : <NEWLINE> <INDENT> res0 = res1 <NEWLINE> <DEDENT> print ( res0 ) <NEWLINE>
a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> print ( a . find ( 0 ) + 1 ) <NEWLINE>
x = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i in range ( 0 , len ( x ) ) : <NEWLINE> <INDENT> if x [ i ] == 0 : <NEWLINE> <INDENT> print ( i + 1 ) <NEWLINE> return <NEWLINE> <DEDENT> <DEDENT>
list1 = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> for i in range ( 1 , 5 ) : <NEWLINE> <INDENT> if list1 [ i - 1 ] != i : <NEWLINE> <INDENT> return ( i ) <NEWLINE> <DEDENT> <DEDENT>
a , b , c , d , e = int ( input ( ) , split ( ) ) <NEWLINE> if ( a == 0 ) : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> elif ( b == 0 ) : <NEWLINE> <INDENT> print ( 2 ) <NEWLINE> <DEDENT> elif ( c == 0 ) : <NEWLINE> <INDENT> print ( 3 ) <NEWLINE> <DEDENT> elif ( d == 0 ) : <NEWLINE> <INDENT> print ( 4 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 5 ) <NEWLINE> <DEDENT>
x = list ( map ( int , input ( ) . split ) ) <NEWLINE> for i in x : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT> <DEDENT>
x = [ int ( v ) for v in input ( ) . rstrip ( ) . split ( ) <NEWLINE> i = x . index ( 0 ) <NEWLINE> print ( i + 1 ) <NEWLINE>
; <NEWLINE>
A , B , C , D , E = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if A = 0 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> elif B = 0 : <NEWLINE> <INDENT> print ( 2 ) <NEWLINE> <DEDENT> elif C = 0 : <NEWLINE> <INDENT> print ( 3 ) <NEWLINE> <DEDENT> elif D = 0 : <NEWLINE> <INDENT> print ( 4 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 5 ) <NEWLINE> <DEDENT>
lis = list ( map ( int , input ( ) , split ( ) ) ) <NEWLINE> <NL> print ( lis . index ( 0 ) + 1 ) <NEWLINE>
l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i in range ( 5 ) : <NEWLINE> <INDENT> if l [ i ] == 0 : <NEWLINE> <INDENT> print ( i + 1 ) <NEWLINE> eixt ( ) <NEWLINE> <DEDENT> <DEDENT>
x = ( list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> x = sum ( x ) <NEWLINE> ans = 15 - x <NEWLINE> print ( ans ) <NEWLINE>
X = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in len ( 5 ) : <NEWLINE> <INDENT> if X [ i ] == 0 : <NEWLINE> <INDENT> print ( i + 1 ) <NEWLINE> <DEDENT> <DEDENT>
X = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i in range ( X ) : <NEWLINE> <INDENT> if X [ i ] == 0 : <NEWLINE> <INDENT> print ( i + 1 ) <NEWLINE> <DEDENT> <DEDENT>
X = list ( map ( int , input ( ) , split ( ) ) <NEWLINE> <NL> for i in X : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> print ( i + 1 ) <NEWLINE> <DEDENT> <DEDENT>
x = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in range ( % ) : <NEWLINE> <INDENT> if x [ i ] == 0 : <NEWLINE> <INDENT> print ( i + 1 ) <NEWLINE> <DEDENT> <DEDENT>
N = list ( map ( int , input ( ) . splti ( ) ) ) ] <NEWLINE> print ( 15 - n [ 0 1 ] - n [ 1 ] - n [ 2 ] - n [ 3 ] - n [ 4 ] ) <NEWLINE>
num = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> count = 0 <NEWLINE> for i in num : <NEWLINE> <INDENT> if i = 0 : <NEWLINE> <INDENT> count += 1 <NEWLINE> print ( count ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT>
lst = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for e in range ( len ( lst ) ) : <NEWLINE> <INDENT> if lst [ e ] == 0 ; <NEWLINE> <INDENT> print ( lst [ e ] + 1 ) <NEWLINE> <DEDENT> <DEDENT>
p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> x = p . get ( 0 ) <NEWLINE> print ( x ) <NEWLINE>
A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i in range ( 1 , 6 ) : <NEWLINE> <INDENT> if A [ i ] == 0 : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT> <DEDENT>
A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> k = A . find ( 0 ) <NEWLINE> print ( k + 1 ) <NEWLINE>
a = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> for i in range ( 5 ) : <NEWLINE> <INDENT> if a [ i ] == 0 : <NEWLINE> <INDENT> print ( i + 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT>
l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in range ( len ( l ) ) : <NEWLINE> <INDENT> if l [ i ] == 0 : <NEWLINE> <INDENT> return i <NEWLINE> <NL> <NL> <DEDENT> <DEDENT>
x = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i in range ( len ( x ) ) : <NEWLINE> <INDENT> if x [ i ] == 0 : <NEWLINE> <INDENT> print ( i + 1 ) <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> from collections import deque <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> def S ( ) : return sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> def SL ( ) : return map ( str , sys . stdin . readline ( ) . rstrip ( ) . split ( ) ) <NEWLINE> def I ( ) : return int ( sys . stdin . readline ( ) . rstrip ( ) ) <NEWLINE> def IL ( ) : return map ( int , sys . stdin . readline ( ) . rstrip ( ) . split ( ) ) <NEWLINE> def LS ( ) : return list ( sys . stdin . readline ( ) . rstrip ( ) . split ( ) ) <NEWLINE> def LI ( ) : return list ( map ( int , sys . stdin . readline ( ) . rstrip ( ) . split ( ) ) ) <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> x = LS ( ) <NEWLINE> for i in len ( x ) : <NEWLINE> <INDENT> if x [ i ] == <STRING> : <NEWLINE> <INDENT> print ( i ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> return <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
print ( input ( ) . split ( ) . find ( <STRING> ) + 1 ) <NEWLINE>
x = str ( input ( ) ) <NEWLINE> if x [ n ] == 0 : <NEWLINE> <INDENT> print ( n ) <NEWLINE> <DEDENT>
a , b , c , d , e = map ( int , input ( ) split ( ) ) <NEWLINE> if a == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif b == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif c == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif d == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a = [ ] <NEWLINE> a = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> <NL> ans = list . index ( 0 ) + 1 <NEWLINE> print ( ans ) <NEWLINE>
x = [ 0 ] <NEWLINE> for i in range ( 1 , 6 ) : <NEWLINE> <INDENT> x . append ( int ( input ( <STRING> ) ) ) <NEWLINE> <DEDENT> for j in range ( 1 , 5 ) : <NEWLINE> <INDENT> if x [ j ] == 0 : <NEWLINE> <INDENT> print ( j ) <NEWLINE> <DEDENT> <DEDENT>
x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> a = y - 2 * x <NEWLINE> if a < 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a > x : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a % 2 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
lists = [ int ( x ) for x in range ( 1 , 6 ) ] <NEWLINE> for i in range ( 1 , len ( list ) + 1 ) : <NEWLINE> <INDENT> if list [ i ] == 0 : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT> <DEDENT>
x = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in x : <NEWLINE> <INDENT> if x [ i ] == 0 : <NEWLINE> <INDENT> print ( i + 1 ) <NEWLINE> <DEDENT> <DEDENT>
A , B , C , D , E = map ( int , input ( ) . split ( ) ) <NEWLINE> if A == 0 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> elif B == 0 : <NEWLINE> <INDENT> print ( 2 ) <NEWLINE> <DEDENT> elif C == 0 : <NEWLINE> <INDENT> print ( 3 ) <NEWLINE> <DEDENT> elif D == 0 : <NEWLINE> <INDENT> print ( 4 ) <NEWLINE> <DEDENT> else E == 0 : <NEWLINE> <INDENT> print ( 5 ) <NEWLINE> <DEDENT>
X = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i in range ( 5 ) : <NEWLINE> <INDENT> if X [ i ] = 0 : <NEWLINE> <INDENT> print ( i + 1 ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT>
a , b , c , d , e = map ( int , input ( ) . split ( ) ) <NEWLINE> for i in 5 : <NEWLINE> <INDENT> if i * 1 == 0 : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT> <DEDENT>
for i in range ( 5 ) : <NEWLINE> <INDENT> n = input ( ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> print ( i + 1 ) <NEWLINE> <DEDENT> <DEDENT>
s = input ( ) . split ( ) <NEWLINE> print ( s . index [ <STRING> ] ) <NEWLINE>
A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> print ( l . index ( 0 ) + 1 ) <NEWLINE>
x = list ( map ( int , input ( ) ) ) <NEWLINE> for i in range ( 5 ) : <NEWLINE> <INDENT> if x [ i ] == 0 : <NEWLINE> <INDENT> print ( i + 1 ) <NEWLINE> <DEDENT> <DEDENT>
num_list = input ( ) . split ( ) <NEWLINE> <NL> i = 0 <NEWLINE> while True : <NEWLINE> <INDENT> if num_list [ i ] == 0 : <NEWLINE> <INDENT> print ( i + 1 ) <NEWLINE> break <NEWLINE> <DEDENT> i += 1 <NEWLINE> <DEDENT>
arr = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> for i , a in enumerate ( arr , 1 ) : <NEWLINE> <INDENT> if a == 0 : <NEWLINE> <INDENT> return i <NEWLINE> <DEDENT> <DEDENT>
arr = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i range ( 5 ) : <NEWLINE> <INDENT> if arr [ i ] == 0 : <NEWLINE> <INDENT> print ( i + 1 ) <NEWLINE> <DEDENT> <DEDENT>
x = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in x : <NEWLINE> <INDENT> if x [ i ] == 0 : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT> <DEDENT>
p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in range ( 5 ) : <NEWLINE> <INDENT> if p [ i ] == 0 : <NEWLINE> <INDENT> x = i <NEWLINE> <NL> print ( x ) <NEWLINE> <DEDENT> <DEDENT>
L = [ int ( x ) for x in input ( ) . split ( <STRING> ) <NEWLINE> print ( L . index ( 0 ) + 1 ) <NEWLINE>
L1 = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i in range ( len ( l1 ) ) : <NEWLINE> <INDENT> if l1 [ i ] == 0 : <NEWLINE> <INDENT> print ( i + 1 ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT>
x , y = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> if 4 * x >= y and ( y % 4 == 0 or ( y % 2 == 0 and ( y - 2 ) % 4 == 0 ) ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
data = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> p = data . find ( 0 ) <NEWLINE> print ( p + 1 ) <NEWLINE>
a = [ int ( i ) for i in input ( ) ] <NEWLINE> <NL> for i , j in enumerate ( a ) : <NEWLINE> <INDENT> if j == 0 : <NEWLINE> <INDENT> print ( i + 1 ) <NEWLINE> <DEDENT> <DEDENT>
a , b , c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if ( a == 0 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> elif ( b == 0 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> elif ( c == 0 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> elif ( d == 0 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if n [ i ] == 0 : <NEWLINE> <INDENT> print ( i ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> <NL> input = sys . stdin . readline <NEWLINE> <NL> A = [ int ( input ( ) ) for _ in range ( 5 ) ] <NEWLINE> <NL> for i , a in enumerate ( A ) : <NEWLINE> <INDENT> if a == 0 : <NEWLINE> <INDENT> print ( i ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT>
x = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for k in range ( 5 ) <NEWLINE> <INDENT> if x [ k ] == 0 : <NEWLINE> <INDENT> print ( k + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> <DEDENT>
g = [ ] <NEWLINE> a , b , c , d , e = map ( int , input ( ) . split ( ) ) <NEWLINE> for i in a , b , c , d , e , f : <NEWLINE> <INDENT> g . append ( i ) <NEWLINE> <DEDENT> print ( g . index ( 0 ) + 1 ) <NEWLINE>
num = list ( input ( ) . split ( ) ) <NEWLINE> for i in range ( 6 ) : <NEWLINE> <INDENT> if num [ i ] == <STRING> : <NEWLINE> <INDENT> print ( int ( str ( i + 1 ) ) ) <NEWLINE> <DEDENT> <DEDENT>
x1 , x2 , x3 , x4 , x5 = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if x1 == 0 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> elif x2 == 0 : <NEWLINE> <INDENT> print ( 2 ) <NEWLINE> <DEDENT> elif x3 == 0 : <NEWLINE> <INDENT> print ( 3 ) <NEWLINE> <DEDENT> elif x4 == 0 : <NEWLINE> <INDENT> print ( 4 ) <NEWLINE> <DEDENT> elif x5 == 0 : <NEWLINE>
a = input ( ) . split ( <STRING> ) <NEWLINE> m = len ( a ) <NEWLINE> b = 0 <NEWLINE> while b < m : <NEWLINE> <INDENT> if a [ b ] == <STRING> <NEWLINE> print ( b ) <NEWLINE> b = b + 1 <NEWLINE> <DEDENT>
x = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans_ind = 0 <NEWLINE> for i in range ( 5 ) : <NEWLINE> <INDENT> if x [ i ] == 0 : <NEWLINE> <INDENT> ans_ind = i + 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans_ind ) <NEWLINE> <NL> x = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans_ind = 0 <NEWLINE> for i in range ( 5 ) : <NEWLINE> <INDENT> if x [ i ] == 0 : <NEWLINE> <INDENT> ans_ind = i + 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans_ind ) <NEWLINE> <NL>
N = map ( int . input ( ) . split ( ) ) <NEWLINE> for x , n in enumarate ( N , 1 ) : <NEWLINE> <INDENT> if n == 0 : <NEWLINE> <INDENT> print ( x ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT>
a = input ( ) . sprit ( ) <NEWLINE> x = 0 <NEWLINE> for n in a : <NEWLINE> <INDENT> x += 1 <NEWLINE> if n == <STRING> : <NEWLINE> <INDENT> aa = x <NEWLINE> <DEDENT> <DEDENT> print ( aa ) <NEWLINE>
vs = map ( int , input ( ) . split ( ) ) <NEWLINE> for i in range ( len ( vs ) ) : <NEWLINE> <INDENT> if vs [ i ] == 0 : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT> <DEDENT>
a = input ( ) <NEWLINE> x = int ( a ) <NEWLINE> <NL> for i , k in x : <NEWLINE> <INDENT> if k == 0 : <NEWLINE> <INDENT> print ( i ) <NEWLINE> break ; <NEWLINE> <DEDENT> <DEDENT>
x = map ( int , input ( ) . split ( ) ) <NEWLINE> for i in range ( 5 ) : <NEWLINE> <INDENT> if x [ i ] == 0 : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT> <DEDENT>
A = list [ map ( int , input ( ) . split ( ) ) ] <NEWLINE> count = 0 <NEWLINE> for a in A : <NEWLINE> <INDENT> count += 1 <NEWLINE> if a == 0 : <NEWLINE> <INDENT> print ( count ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT>
x = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> num = 0 <NEWLINE> <NL> for i in range ( 5 ) : <NEWLINE> <INDENT> num += 1 <NEWLINE> <INDENT> if x [ i ] == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( num ) <NEWLINE>
x = list ( map ( int , input ( ) ) ) <NEWLINE> if x [ 0 ] == 0 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> elif x [ 1 ] == 0 : <NEWLINE> <INDENT> print ( 2 ) <NEWLINE> <DEDENT> elif x [ 2 ] == 0 : <NEWLINE> <INDENT> print ( 3 ) <NEWLINE> <DEDENT> elif x [ 3 ] == 0 : <NEWLINE> <INDENT> print ( 4 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 5 ) <NEWLINE> <DEDENT>
X = map ( int , input ( ) . split ( ) ) <NEWLINE> for i in range ( len ( X ) ) : <NEWLINE> <INDENT> if X [ i ] == 0 : <NEWLINE> <INDENT> print ( i + 1 ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT>
a = list ( map ( int , input ( ) ) ) <NEWLINE> for i in range ( 5 ) : <NEWLINE> <INDENT> if a [ i ] == 0 : <NEWLINE> <INDENT> print ( i + 1 ) <NEWLINE> <DEDENT> <DEDENT>
l = list ( map ( input ( ) . split ( ) ) ) <NEWLINE> print ( l . index ( 0 ) + 1 ) <NEWLINE>
x = int ( input ( ) ) <NEWLINE> x = list ( x ) <NEWLINE> <NL> for idx in range ( len ( x ) ) : <NEWLINE> <INDENT> if x [ idx ] == 0 : <NEWLINE> <INDENT> print ( idx + 1 ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT>
n = list ( map ( int , input ( ) ) ) <NEWLINE> p = sum ( n ) <NEWLINE> f = 15 <NEWLINE> ans = ( f - p ) <NEWLINE> print ( ans ) <NEWLINE>
a = list ( input ( ) ) <NEWLINE> <NL> for i in len ( a ) : <NEWLINE> <INDENT> if 0 == a [ i ] : <NEWLINE> <INDENT> print ( i ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT>
List = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = - 1 <NEWLINE> for x in range ( 5 ) : <NEWLINE> <INDENT> if ( List [ x ] == 0 ) : <NEWLINE> <INDENT> ans = x + 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
a = map ( int , input ( ) . split ( ) ) <NEWLINE> for i in range ( len ( a ) ) : <NEWLINE> <INDENT> if a [ i ] != i : <NEWLINE> <INDENT> print ( a [ i ] ) <NEWLINE> <DEDENT> <DEDENT>
a = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> for i in range ( len ( a ) ) : <NEWLINE> <INDENT> if a [ i ] == 0 : <NEWLINE> <INDENT> print ( i + 1 ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT>
a , b , c , d , e = map ( int , input ( ) . split ( ) ) <NEWLINE> if a = 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif b = 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif c = 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif d = 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT>
arr = input ( ) . spilt ( ) <NEWLINE> arr = int ( arr ) <NEWLINE> print ( 15 - sum ( arr ) ) <NEWLINE>
a = map ( int , input ( ) . split ( ) ) <NEWLINE> for i in range ( 1 , 6 ) : <NEWLINE> <INDENT> if a [ i - 1 ] == 0 : <NEWLINE> <INDENT> print ( i ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT>
arr = map ( int , input ( ) . split ( ) ) <NEWLINE> for i in range ( len ( arr ) ) : <NEWLINE> <INDENT> if ( arr [ i ] == 0 ) : <NEWLINE> <INDENT> print ( i + 1 ) <NEWLINE> <DEDENT> <DEDENT>
x = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in range ( len ( x ) ) : <NEWLINE> <INDENT> if x [ i ] == 0 : <NEWLINE> <INDENT> print ( i + 1 ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> <NL> for i in N : <NEWLINE> <INDENT> if A [ i ] == 0 : <NEWLINE> <INDENT> print int ( i ) <NEWLINE> <DEDENT> <DEDENT>
a , b , c , d , e = map ( int , input ( ) . split ( ) ) <NEWLINE> list = [ a , b , c , d , e ] <NEWLINE> for i in list ( ) : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> print ( list . index ( i ) + 1 ) <NEWLINE> <DEDENT> <DEDENT>
a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> print ( str ( a . index ( 0 ) ) + 1 ) <NEWLINE>
li = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i , j in enumerate ( li ) : <NEWLINE> <INDENT> if j == 0 : <NEWLINE> <INDENT> echo i + 1 <NEWLINE> <DEDENT> <DEDENT>
r = 1 <NEWLINE> for i in range ( input ( ) . split ( <STRING> ) ) : <NEWLINE> <INDENT> r ^= int ( i ) <NEWLINE> <DEDENT> print ( r ) <NEWLINE>
c = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c = str ( c ) <NEWLINE> c = c . find ( 0 ) <NEWLINE> print ( c ) <NEWLINE>
x = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if x [ i ] == 0 : <NEWLINE> <INDENT> print ( i + 1 ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT>
a , b , c , d , e = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if a = 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> if b = 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> if c = 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> if d = 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> if e = 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <NL> <NL> <DEDENT>
<COMMENT> <NL> import sys , io , os , time <NEWLINE> from collections import defaultdict <NEWLINE> from collections import OrderedDict <NEWLINE> from collections import deque <NEWLINE> from itertools import combinations <NEWLINE> from itertools import permutations <NEWLINE> import bisect , math , heapq <NEWLINE> alphabet = <STRING> <NEWLINE> <NL> input = sys . stdin . readline <NEWLINE> <NL> <COMMENT> <NL> <NL> x = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i in range ( x ) : <NEWLINE> <INDENT> if x [ i ] == 0 : <NEWLINE> <INDENT> print ( i + 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <DEDENT> <DEDENT>
nums = input ( ) . split ( ) <NEWLINE> <NL> if nums [ 0 ] = <STRING> <NEWLINE> print ( 1 ) <NEWLINE> <NL> elif nums [ 1 ] = <STRING> <NEWLINE> print ( 2 ) <NEWLINE> <NL> elif nums [ 2 ] = <STRING> <NEWLINE> print ( 3 ) <NEWLINE> <NL> elif nums [ 3 ] = <STRING> <NEWLINE> print ( 4 ) <NEWLINE> <NL> elif nums [ 4 ] = <STRING> <NEWLINE> print ( 5 ) <NEWLINE>
A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in range ( A ) : <NEWLINE> <INDENT> if A [ i ] == i + 1 : <NEWLINE> <INDENT> print ( i + 1 ) <NEWLINE> <DEDENT> <DEDENT>
x1 = int ( input ( ) ) <NEWLINE> x2 = int ( input ( ) ) <NEWLINE> x3 = int ( input ( ) ) <NEWLINE> x4 = int ( input ( ) ) <NEWLINE> x5 = int ( input ( ) ) <NEWLINE> if x1 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> if x2 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> if x3 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> if x4 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> if x5 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
l = list ( map ( int , input . split ( <STRING> ) ) ) <NEWLINE> print ( l . index ( <STRING> ) + 1 ) <NEWLINE>
a = list ( map ( , int , input ( ) . split ( ) ) ) <NEWLINE> n = len ( a ) <NEWLINE> print ( ( n * ( n + 1 ) // 2 ) - sum ( a ) ) <NEWLINE>
return input ( ) . strip ( ) . split ( ) . index ( <STRING> ) + 1 <NEWLINE>
a , b , c , d , e = map ( int , input ( ) . split ( ) ) <NEWLINE> if a = 0 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> elif b = 0 : <NEWLINE> <INDENT> print ( 2 ) <NEWLINE> <DEDENT> elif c = 0 : <NEWLINE> <INDENT> print ( 3 ) <NEWLINE> <DEDENT> elif d = 0 : <NEWLINE> <INDENT> print ( 4 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 5 ) <NEWLINE> <DEDENT>
l = map ( int , input ( ) . split ( ) ) <NEWLINE> for i in range ( 5 ) : <NEWLINE> <INDENT> if not i + 1 == l [ i ] : <NEWLINE> <INDENT> print ( i + 1 ) <NEWLINE> <DEDENT> <DEDENT>
lst = [ ] <NEWLINE> str = input ( ) <NEWLINE> lst = str . split ( <STRING> ) <NEWLINE> i = lst . index ( 0 ) <NEWLINE> print ( i + 1 ) <NEWLINE>
X = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for int i range 5 : <NEWLINE> <INDENT> if X [ i ] == 0 : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT> <DEDENT>
a = [ ] <NEWLINE> a = int ( input ( ) . split ( ) ) <NEWLINE> for i in a : <NEWLINE> <INDENT> if a [ i ] == 0 : <NEWLINE> <INDENT> print ( i + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> X = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i in range ( 5 ) : <NEWLINE> <INDENT> if X [ i ] == 0 : <NEWLINE> <INDENT> print ( i + 1 ) <NEWLINE> break <NEWLINE> <NL> <NL> <COMMENT> <NL> <NL> <NL> <DEDENT> <DEDENT> x = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> print ( x . index ( 0 ) + 1 ) <NEWLINE> <NL>
x = list ( map ( int , inpt ( ) . split ( ) ) ) <NEWLINE> for i in range ( 5 ) : <NEWLINE> <INDENT> if x [ i ] == 0 : <NEWLINE> <INDENT> ans = i <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
l = list ( int , input ( ) ) <NEWLINE> <NL> for i in range ( 5 ) : <NEWLINE> <INDENT> if l [ i ] == 0 : <NEWLINE> <INDENT> print ( i + 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT>
x = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i , el in enumerate ( x ) : <NEWLINE> <INDENT> if el == 0 : <NEWLINE> <INDENT> print ( i + 1 ) <NEWLINE> <DEDENT> <DEDENT>
l = list ( map ( int , input ( ) ) ) <NEWLINE> print ( l . index ( 0 ) ) <NEWLINE>
n = list ( map ( int , input . split ( ) ) ) <NEWLINE> for i in range ( len ( n ) ) : <NEWLINE> <INDENT> if ( n [ i ] == 0 ) : <NEWLINE> <INDENT> cout << i + 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT>
x = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( x . index ( 0 ) + 1 ) <NEWLINE>
p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> count = 1 <NEWLINE> for item in p : <NEWLINE> <INDENT> if item == 0 : <NEWLINE> <INDENT> return count <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> count += 1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT>
ans = 0 <NEWLINE> for i in range ( 5 ) : <NEWLINE> <INDENT> if int ( input ( ) ) == 0 : <NEWLINE> <INDENT> ans = i + 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
X = map ( int , input ( ) . split ( ) ) <NEWLINE> for i in range ( 5 ) : <NEWLINE> <INDENT> if X [ i ] != i : <NEWLINE> <INDENT> print ( i + 1 ) <NEWLINE> <DEDENT> <DEDENT>
l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> c = 0 <NEWLINE> for x in l : <NEWLINE> <INDENT> if x == 0 : <NEWLINE> <INDENT> print ( c ) <NEWLINE> <DEDENT> c + + <NEWLINE> <DEDENT>
l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in range ( 5 ) : <NEWLINE> <INDENT> if l [ i ] == 0 <NEWLINE> <INDENT> print ( i + 1 ) <NEWLINE> <DEDENT> <DEDENT>
a = input ( ) . split ( <STRING> ) <NEWLINE> cnt = 0 <NEWLINE> for i , ai in enumerate ( a ) : <NEWLINE> <INDENT> if ai == 0 <NEWLINE> return i + 1 <NEWLINE> <DEDENT>
x = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in range ( x ) : <NEWLINE> <INDENT> if x [ i ] == 0 : <NEWLINE> <INDENT> print ( i + 1 ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT>
a = input ( ) <NEWLINE> a = a . split ( ) <NEWLINE> <NL> n = 1 <NEWLINE> <NL> for x in a : <NEWLINE> <INDENT> if n == int ( x ) : <NEWLINE> <INDENT> n = n + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( n ) <NEWLINE> end <NEWLINE> <DEDENT> <DEDENT>
n = input ( ) . split ( ) <NEWLINE> x = n . find ( <STRING> ) <NEWLINE> <NL> print ( int ( x ) + 1 ) <NEWLINE>
N = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i in N : <NEWLINE> <INDENT> if N [ i ] == 0 : <NEWLINE> <INDENT> print ( i + 1 ) <NEWLINE> <DEDENT> <DEDENT>
A = list [ map ( int , input ( ) . split ( ) ) ] <NEWLINE> <NL> print ( A . index ( 0 ) + 1 ) <NEWLINE>
data = list ( map ( int , input ( ) ) ) <NEWLINE> <NL> _sum = sum ( data ) <NEWLINE> <NL> print ( 15 - _sum ) <NEWLINE>
import sys <NEWLINE> line = sys . stdin . readlines ( ) [ 0 ] . rstrip ( <STRING> ) <NEWLINE> print ( line . split ( <STRING> ) . index ( <STRING> , 1 ) ) <NEWLINE>
x1 , x2 , x3 , x4 , x5 = int ( input ( ) . split ( ) ) <NEWLINE> x = [ ] <NEWLINE> x . append ( x1 ) <NEWLINE> x . append ( x2 ) <NEWLINE> x . append ( x3 ) <NEWLINE> x . append ( x4 ) <NEWLINE> x . append ( x5 ) <NEWLINE> ans = 0 <NEWLINE> for i , j in enumerate ( x ) : <NEWLINE> <INDENT> if i + 1 != j : <NEWLINE> <INDENT> ans = j <NEWLINE> <DEDENT> <DEDENT> print ( type ( 0 2 3 4 5 ) , j ) <NEWLINE>
nums = [ int ( x ) for x in input ( ) ] <NEWLINE> <NL> for i in range ( 5 ) : <NEWLINE> <INDENT> if nums [ i ] == 0 : <NEWLINE> <INDENT> print ( i + 1 ) <NEWLINE> exit ( 0 ) <NEWLINE> <DEDENT> <DEDENT>
l = list ( ) . split ( ) <NEWLINE> print ( 1 + l . index ( <STRING> ) ) <NEWLINE>
A = Input ( ) <NEWLINE> A = A . split ( ) <NEWLINE> <NL> B = [ ] <NEWLINE> for x in A : <NEWLINE> <INDENT> y = int ( x ) <NEWLINE> B . append ( y ) <NEWLINE> <NL> <DEDENT> c = [ 1 , 2 , 3 , 4 , 5 ] <NEWLINE> for x in range ( len ( B ) ) : <NEWLINE> <INDENT> if B [ x ] != c [ x ] : <NEWLINE> <INDENT> z = x + 1 <NEWLINE> print ( z ) <NEWLINE> <DEDENT> <DEDENT>
x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if x * 4 < y : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> elif y / 2 < x : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> elif y % 2 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
x = list ( map ( int , input ( ) . stlip ( ) ) ) <NEWLINE> for i in range ( 5 ) : <NEWLINE> <INDENT> if x [ i ] == 0 : <NEWLINE> <INDENT> print ( i + 1 ) <NEWLINE> <DEDENT> <DEDENT>
a , b , c = input ( ) . split ( ) <NEWLINE> print ( <STRING> . format ( c , a , b ) ) <NEWLINE>
C <NEWLINE>
def solve ( ) : <NEWLINE> <INDENT> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i in range ( 5 ) : <NEWLINE> <INDENT> if ( l [ i ] == 0 ) { <NEWLINE> <INDENT> print ( i + 1 ) <NEWLINE> <DEDENT> } <NEWLINE> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> solve ( ) <NEWLINE> <DEDENT>
x = list ( input ( ) . split ( ) ) <NEWLINE> print ( 15 - sum ( x ) ) <NEWLINE>
lists = list ( input . split ( ) ) <NEWLINE> counter = 0 <NEWLINE> for i in lists : <NEWLINE> <INDENT> if i == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> counter = counter + 1 <NEWLINE> <DEDENT> print ( str ( counter ) ) <NEWLINE>
x = list ( map ( int , input ( ) . split ( ) ) ) <COMMENT> <NEWLINE> <NL> for i in range ( x ) : <NEWLINE> <INDENT> if x [ i ] is 0 : <NEWLINE> <INDENT> print ( i + 1 ) <NEWLINE> <DEDENT> <DEDENT>
xs = map ( int , input ( ) . split ( ) ) <NEWLINE> for i in range ( len ( xs ) ) : <NEWLINE> <INDENT> if xs [ i ] == 0 : <NEWLINE> <INDENT> print ( i + 1 ) <NEWLINE> <DEDENT> <DEDENT>
x = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> n = len ( x ) <NEWLINE> <NL> for _ in range ( n ) : <NEWLINE> <INDENT> if x [ i ] == 0 : <NEWLINE> <INDENT> print ( i + 1 ) <NEWLINE> <DEDENT> <DEDENT>
lis = list ( input ( ) . split ( ) ) <NEWLINE> <NL> for i , x in enumerate ( lis ) : <NEWLINE> <INDENT> if x == 0 : <NEWLINE> <INDENT> a = i <NEWLINE> <DEDENT> <DEDENT> print a <NEWLINE>
a = input ( ) <NEWLINE> l = a . split ( <STRING> ) <NEWLINE> b = l . index ( <STRING> ) <NEWLINE> print ( b + 1 ) <NEWLINE>
x = inpl ( ) <NEWLINE> for i in range ( 5 ) : <NEWLINE> <INDENT> if x [ i ] == 0 : <NEWLINE> <INDENT> print ( i + 1 ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT>
a , b , c , d , e = map ( int , input ( ) . split ( ) ) <NEWLINE> r = o <NEWLINE> if a = 0 : <NEWLINE> <INDENT> r = a <NEWLINE> else if b = 0 : <NEWLINE> <INDENT> r = b <NEWLINE> <DEDENT> else if c = 0 : <NEWLINE> <INDENT> r = c <NEWLINE> <DEDENT> else if d = 0 : <NEWLINE> <INDENT> r = d <NEWLINE> <DEDENT> else if e = 0 : <NEWLINE> <INDENT> r = e <NEWLINE> <DEDENT> <DEDENT> print ( r ) <NEWLINE>
list_sunuke = [ ] <NEWLINE> list_m = [ ] <NEWLINE> <NL> for i in range ( 5 ) : <NEWLINE> <INDENT> list_sunuke . append ( input ( ) ) <NEWLINE> <NL> <DEDENT> for i in range ( 5 ) : <NEWLINE> <INDENT> list_m . append ( i + 1 ) <NEWLINE> <NL> <DEDENT> for i in range ( 5 ) : <NEWLINE> <INDENT> if list_sunuke [ i ] != list_m [ i ] : <NEWLINE> <INDENT> print ( list_m [ i ] ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT>
print ( list ( map ( int , input ( ) . split ( ) ) . index ( 0 ) + 1 ) <NEWLINE>
from sys import stdin <NEWLINE> <NL> X = stdin . readline ( ) . strip ( ) . split ( <STRING> ) <NEWLINE> <NL> n = 0 <NEWLINE> for i in range ( len ( X ) ) : <NEWLINE> <INDENT> if X [ i ] == <STRING> : <NEWLINE> <INDENT> n = i + 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print n <NEWLINE>
x1 = int ( input ( ) ) <NEWLINE> x2 = int ( input ( ) ) <NEWLINE> x3 = int ( input ( ) ) <NEWLINE> x4 = int ( input ( ) ) <NEWLINE> x5 = int ( input ( ) ) <NEWLINE> <NL> l = [ x1 , x2 , x3 , x4 , x5 ] <NEWLINE> print ( l . index ( 0 ) + 1 ) <NEWLINE>
arr = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> i = 1 <NEWLINE> for num in arr : <NEWLINE> <INDENT> if ( num == 0 ) : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> i + + ; <NEWLINE> <DEDENT> <DEDENT>
a1 = input ( ) <NEWLINE> a2 = input ( ) <NEWLINE> a3 = input ( ) <NEWLINE> a4 = input ( ) <NEWLINE> a5 = input ( ) <NEWLINE> if a1 == 0 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> if a2 == 0 : <NEWLINE> <INDENT> print ( 2 ) <NEWLINE> <DEDENT> if a3 == 0 : <NEWLINE> <INDENT> print ( 3 ) <NEWLINE> <DEDENT> if a4 == 0 : <NEWLINE> <INDENT> print ( 4 ) <NEWLINE> <DEDENT> if a5 == 0 : <NEWLINE> <INDENT> print ( 5 ) <NEWLINE> <DEDENT>
v_list = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> for i in len ( v_list ) : <NEWLINE> <INDENT> if v_list [ i ] == 0 : <NEWLINE> <INDENT> print ( i + 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT>
a , b , c , d , e = int ( input ( ) . split ( ) ) <NEWLINE> 0 2 3 4 5 <NEWLINE> print ( 15 - a - b - c - d - e ) <NEWLINE>
a = [ ] <NEWLINE> a = int ( input ( ) . split ( ) ) <NEWLINE> for i in range ( 4 ) : <NEWLINE> <INDENT> if a [ i ] == 0 : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> pass <NEWLINE> <NL> <DEDENT> <DEDENT>
a = map ( int , input ( ) . split ( ) ) <NEWLINE> for i in range ( 0 , 4 ) : <NEWLINE> <INDENT> if a [ i ] == 0 : <NEWLINE> <INDENT> print ( i + 1 ) <NEWLINE> <DEDENT> <DEDENT>
for i in range ( 5 ) : <NEWLINE> <INDENT> if int ( input ( ) ) == 0 : <NEWLINE> <INDENT> print ( i + 1 ) <NEWLINE> <DEDENT> <DEDENT>
from sys import stdin , stdout <NEWLINE> import sys <NEWLINE> import bisect <NEWLINE> INF = 1e9 <NEWLINE> def get_int ( ) : return int ( stdin . readline ( ) . strip ( ) ) <NEWLINE> def get_ints ( ) : return map ( int , stdin . readline ( ) . strip ( ) . split ( ) ) <NEWLINE> def get_array ( ) : return list ( map ( int , stdin . readline ( ) . strip ( ) . split ( ) ) ) <NEWLINE> def get_string ( ) : return stdin . readline ( ) . strip ( ) <NEWLINE> def op ( c ) : return stdout . write ( c ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> x = get_array ( ) <NEWLINE> for i in range ( len ( x ) : <NEWLINE> <INDENT> if x [ i ] == 0 : <NEWLINE> <INDENT> print ( i + 1 ) <NEWLINE> <DEDENT> <DEDENT>
nums = [ int ( e ) for e in input ( ) . split ( ) ] <NEWLINE> for i in range ( 5 ) : <NEWLINE> <INDENT> if not xs [ i ] == i : <NEWLINE> <INDENT> print ( i ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT>
n = map ( int , input ( ) . split ( ) ) <NEWLINE> for i in range ( 5 ) : <NEWLINE> <INDENT> if n [ i ] == 0 : <NEWLINE> <INDENT> print ( i + 1 ) <NEWLINE> <DEDENT> exit ( ) <NEWLINE> <DEDENT>
xs = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> print ( xs . index ( 0 ) + 1 ) 1 <NEWLINE>
<INDENT> x = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> print ( x . index ( 0 ) + 1 ) <NEWLINE> <DEDENT>
a = list ( map ( int , input ( ) ) ) <NEWLINE> print ( sum ( range ( 1 , 5 + 1 ) ) - sum ( a ) ) <NEWLINE>
A = map ( int , input ( ) . split ( ) ) <NEWLINE> for i in range ( 5 ) : <NEWLINE> <INDENT> if ( A [ i ] == 0 ) : <NEWLINE> <INDENT> print ( i + 1 ) <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
x_ = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in range ( x_ ) : <NEWLINE> <INDENT> if x_ [ i ] == 0 : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> print ( sys . split ( ) . index ( <STRING> ) + 1 ) <NEWLINE>
lst = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in lst : <NEWLINE> <INDENT> i == 0 : <NEWLINE> <INDENT> print ( i ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT>
def function ( ar ) : <NEWLINE> <INDENT> print ( ( ar . index ( 0 ) ) + 1 ) <NEWLINE> <NL> <DEDENT> if __name__ == __ <STRING> __ : <NEWLINE> <INDENT> ar = list ( map ( int , input ( ) . rstrip ( ) . split ( ) ) ) <NEWLINE> function ( ar ) <NEWLINE> <DEDENT>
x = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> print ( x . index ( <STRING> ) + 1 ) <NEWLINE>
x = map ( int , input ( ) . split ( ) ) <NEWLINE> i = 0 <NEWLINE> while ( x [ i ] != 0 ) : <NEWLINE> <INDENT> i += 1 <NEWLINE> <DEDENT> print ( i ) <NEWLINE>
X = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> count = 0 <NEWLINE> for I in X : <NEWLINE> <INDENT> if I == 0 : <NEWLINE> <INDENT> print ( count ) : <NEWLINE> exit <NEWLINE> <DEDENT> count + + <NEWLINE> <DEDENT>
nums = input ( ) . split ( ) <NEWLINE> <NL> if nums [ 0 ] == <STRING> : <NEWLINE> print ( 1 ) <NEWLINE> <NL> elif nums [ 1 ] == <STRING> : <NEWLINE> print ( 2 ) <NEWLINE> <NL> elif nums [ 2 ] == <STRING> : <NEWLINE> print ( 3 ) <NEWLINE> <NL> elif nums [ 3 ] == <STRING> : <NEWLINE> print ( 4 ) <NEWLINE> <NL> elif nums [ 4 ] == <STRING> : <NEWLINE> print ( 5 ) <NEWLINE>
a = input ( ) . split ( ) <NEWLINE> for i in range ( 4 ) : <NEWLINE> <INDENT> if a [ i ] = 0 : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT> <DEDENT>
a , b , c , d , e = ( int ( x ) in input ( ) . split ( ) ) <NEWLINE> list = [ a , b , c , d , e ] <NEWLINE> for num in list : <NEWLINE> <INDENT> if num = 1 : <NEWLINE> <INDENT> print ( ( list . index ( num ) ) + 1 ) <NEWLINE> <DEDENT> <DEDENT>
x , n = map ( int , input ( ) . split ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = 0 <NEWLINE> ans = <STRING> <NEWLINE> p . sort ( ) <NEWLINE> print ( p ) <NEWLINE> while ans == <STRING> : <NEWLINE> <INDENT> if len ( p ) == 0 : <NEWLINE> <INDENT> ans = x <NEWLINE> <DEDENT> elif x - a not in p : <NEWLINE> <INDENT> ans = x - a <NEWLINE> <DEDENT> elif x + a not in p : <NEWLINE> <INDENT> ans = x + a <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
ar = input ( ) . split ( ) <NEWLINE> <INDENT> print ( ar . index ( <STRING> ) + 1 ) <NEWLINE> <DEDENT>
def run ( x , n , num_array ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if len ( num_array ) == 0 : <NEWLINE> <INDENT> print ( x ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> i = 1 <NEWLINE> while True : <NEWLINE> <INDENT> if x - i not in num_array : <NEWLINE> <INDENT> print ( x - i ) <NEWLINE> return <NEWLINE> <DEDENT> if x + i not in num_array : <NEWLINE> <INDENT> print ( x + i ) <NEWLINE> return <NEWLINE> <DEDENT> i += 1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> x , n = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> num_array = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> run ( x , n , num_array ) <NEWLINE> <DEDENT>
x = map ( lambda x : int ( x ) , input ( ) . split ( <STRING> ) ) <NEWLINE> <NL> for i in range ( 1 , 6 ) : <NEWLINE> <INDENT> if i != x [ i - 1 ] : <NEWLINE> <INDENT> print ( i ) <NEWLINE> exit ( 0 ) <NEWLINE> <DEDENT> <DEDENT>
X = map ( int , input ( ) . split ( ) ) <NEWLINE> for i in range ( 1 , 6 ) : <NEWLINE> <INDENT> if X [ i ] == 0 : <NEWLINE> <INDENT> print ( i ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT>
X = int ( input ( ) ) <NEWLINE> Y = int ( input ( ) ) <NEWLINE> <NL> crain = ( 4 * X - Y ) / 2 <NEWLINE> if crain . is_integer ( ) and crain > 0 : <NEWLINE> <INDENT> crain = int ( crain ) <NEWLINE> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
x = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i in range ( x ) : <NEWLINE> <INDENT> if x [ i ] == 0 : <NEWLINE> <INDENT> print ( i + 1 ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT>
x = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> i = 1 <NEWLINE> while i <= len ( x ) : <NEWLINE> <NL> <INDENT> if x [ i ] == 0 : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <NL> <DEDENT> i += 1 <NEWLINE> <DEDENT>
a = input ( ) . split ( <STRING> ) <NEWLINE> m = len ( a ) <NEWLINE> b = 0 <NEWLINE> while b < m : <NEWLINE> <INDENT> if a [ b ] == <STRING> : <NEWLINE> <INDENT> print ( b ) <NEWLINE> <DEDENT> m = m + 1 <NEWLINE> <DEDENT>
n = input ( ) . spilt ( ) <NEWLINE> for i , j in range ( n ) : <NEWLINE> <INDENT> if j == <STRING> : <NEWLINE> <INDENT> print ( i + 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT>
x = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> for i in range ( 0 , len ( x ) ) : <NEWLINE> <INDENT> if x [ i ] == 0 : <NEWLINE> <INDENT> print ( i + 1 ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT>
a = list ( map ( int , input ( ) . split ( ) ) <NEWLINE> i = 0 <NEWLINE> for i in len ( a ) : <NEWLINE> <INDENT> if a [ i ] == 0 : <NEWLINE> print ( i + 1 ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> <NL> huga = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in range ( len [ huga ] ) : <NEWLINE> <INDENT> if huga [ i ] == 0 : <NEWLINE> <INDENT> print ( huga [ i ] ) <NEWLINE> <DEDENT> <DEDENT>
s = list ( map ( int , input ( ) . split ( ) ) <NEWLINE> for i in range ( 5 ) : <NEWLINE> <INDENT> if s [ i ] == 0 : <NEWLINE> <INDENT> print ( i + 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> <DEDENT>
l = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( l . index ( 0 ) ) <NEWLINE>
x = list ( map ( int , input . split ( ) ) ) <NEWLINE> print ( x . index ( 0 ) ) <NEWLINE>
li = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> for i in range ( 5 ) : <NEWLINE> <INDENT> if li [ i ] == 0 : <NEWLINE> <INDENT> print ( i + 1 ) <NEWLINE> <INDENT> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
a , b , c , d , e = map ( int , input ( ) . split ( ) ) ) <NEWLINE> if ( a == 0 ) : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> if ( b == 0 ) : <NEWLINE> <INDENT> print ( 2 ) <NEWLINE> <DEDENT> if ( c == 0 ) : <NEWLINE> <INDENT> print ( 3 ) <NEWLINE> <DEDENT> if ( d == 0 ) : <NEWLINE> <INDENT> print ( 4 ) <NEWLINE> <DEDENT> if ( e == 0 ) : <NEWLINE> <INDENT> print ( 5 ) <NEWLINE> <DEDENT>
list = map ( int , input ( ) . split ( ) ) <NEWLINE> for i in range ( 5 ) : <NEWLINE> <INDENT> if list [ i ] == 0 : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> for i , n in enumerate ( list ( map ( int , input ( ) . split ( ) ) ) ) : <NEWLINE> <INDENT> if n == 0 : <NEWLINE> <INDENT> return i + 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> def main ( args ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <INDENT> ans = [ 1 , 2 , 3 , 4 , 5 ] <NEWLINE> given = [ int ( i ) for i in args ] <NEWLINE> <NL> for i in range ( len ( ans ) ) : <NEWLINE> <INDENT> if ans [ i ] != given [ i ] : <NEWLINE> <INDENT> print ( ans [ i ] ) <NEWLINE> return 0 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> main ( sys . argv ) <NEWLINE>
x = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i in x : <NEWLINE> <INDENT> if x [ i ] == 0 : <NEWLINE> <INDENT> print ( i + 1 ) <NEWLINE> <DEDENT> <DEDENT>
for i in range ( 1 , 6 ) : <NEWLINE> <INDENT> if ( x ( i ) == 0 ) : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT> <DEDENT>
arr = [ int ( x ) for x in input ( ) ] <NEWLINE> c = 1 <NEWLINE> for i in arr : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> print ( c ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> c += 1 <NEWLINE> <DEDENT> <DEDENT>
<INDENT> x = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <DEDENT> print ( x . index ( 0 ) + 1 ) <NEWLINE>
x , y = map ( int , input ( ) . solit ( ) ) <NEWLINE> if 2 * x <= y and y % 2 == 0 and 4 * x >= y : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
x , y = int ( input ( ) . split ( ) ) <NEWLINE> <NL> if x * 4 > y and y < x * 2 and y % 2 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if ( y %= = 0 ) and ( 2 * x <= y <= 4 * x ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <NL> ha = input ( ) <NEWLINE> kita = ha . split ( <STRING> ) <NEWLINE> x = int ( kita [ 0 ] ) <NEWLINE> y = int ( kita [ 1 ] ) <NEWLINE> ifAshi = False <NEWLINE> <NL> for i in range ( x ) : <NEWLINE> <INDENT> if ( x = 1 ) : <NEWLINE> <INDENT> if ( y == 2 or y == 4 ) : <NEWLINE> <INDENT> ifAshi = True <NEWLINE> <DEDENT> <DEDENT> if ( ( y - 2 * i ) % 4 == 0 ) : <NEWLINE> <INDENT> if ( ( x - i ) == ( ( y - 2 * i ) / 4 ) ) : <NEWLINE> <INDENT> ifAshi = True <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if ( ifAshi ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
X , Y = map ( int , input ( ) . split ( ) ) <NEWLINE> a = ( 4 * X - Y ) // 2 <NEWLINE> if a . is_integer ( ) and a >= 0 and a <= 100 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
[ x , y ] = [ x forx in map ( int , input ( ) . split ( <STRING> ) ) ] <NEWLINE> flg = - 1 <NEWLINE> if y % 2 == 1 : <NEWLINE> <INDENT> flg = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( 0 , x ) : <NEWLINE> <INDENT> if i * 2 + ( x - i ) * 4 == y : <NEWLINE> <INDENT> flg = 0 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if flg == 1 or flg == - 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
X , Y = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = <STRING> <NEWLINE> <NL> for i in X : <NEWLINE> <INDENT> j = X - i <NEWLINE> if ( i * 2 + j * 4 ) == Y : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
X , Y = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> for i in range ( X + 1 ) : <NEWLINE> <INDENT> if 2 * i + 4 * ( X - i ) == Y : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> if i == X : <NEWLINE> <INDENT> prinnt ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> answer = <STRING> <NEWLINE> <NL> for i in range ( x + 1 ) : <NEWLINE> <INDENT> b = x - i <NEWLINE> if a * 2 + b * 4 == y : <NEWLINE> <INDENT> answer = <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> print ( answer ) <NEWLINE>
def nums ( X , Y ) : <NEWLINE> <INDENT> B = ( X * 4 - Y ) / ( 4 - 2 ) <NEWLINE> <INDENT> D = X - B <NEWLINE> if B + D == X and Y == ( B * 2 + D * 4 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
X , Y = map ( int , input ( ) . split ( ) ) <NEWLINE> for a in range ( 1 , X ) : <NEWLINE> <INDENT> if 2 * a + 4 * ( x - a ) == Y : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
X , Y = map ( int , input ( ) . split ( ) ) <NEWLINE> A = x <NEWLINE> B = 0 <NEWLINE> if Y % 2 != 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> quit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> while A >= 0 : <NEWLINE> <INDENT> C = A * 2 + B * 4 <NEWLINE> if C == Y : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> quit ( ) <NEWLINE> A -= 1 <NEWLINE> B += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
x , y = map ( int input ( ) . split ( ) ) <NEWLINE> a = - y + 4 x <NEWLINE> b = y - 2 x <NEWLINE> if ( a % 2 == 0 and b % 2 == 0 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
x , y = int ( input ( ) ) <NEWLINE> flag = 0 <NEWLINE> for i in range ( x + 1 ) : <NEWLINE> <INDENT> if ( y - 2 * i ) % 4 == 0 and ( y - 2 * i ) // 4 == x - i : <NEWLINE> <INDENT> flag += 1 <NEWLINE> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if flag == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> f = False <NEWLINE> for i in range ( x + 1 ) : <NEWLINE> <INDENT> for j in range ( x + 1 ) : <NEWLINE> <INDENT> if ( y == ( i * 2 + j * 4 ) ) : <NEWLINE> <INDENT> if ( x == i + j ) : <NEWLINE> <INDENT> f = True <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if f : <NEWLINE> <INDENT> breakif f : <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
x , y = map ( int , input ( ) , split ( ) ) <NEWLINE> <NL> if y % 2 == 0 and y >= x * 2 and y <= x * 4 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
ans = <STRING> <NEWLINE> foots = 2 * X <NEWLINE> for tsuru in range ( X + 1 ) : <NEWLINE> <INDENT> if foots == Y : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <DEDENT> foots += 2 <NEWLINE> <NL> <NL> <DEDENT> print ( ans ) <NEWLINE>
from collections import deque , defaultdict <NEWLINE> from math import ceil , floor , inf , sqrt , factorial , gcd , log2 <NEWLINE> from copy import deepcopy <NEWLINE> ii1 = lambda : int ( stdin . readline ( ) . strip ( ) ) <NEWLINE> is1 = lambda : stdin . readline ( ) . strip ( ) <NEWLINE> iia = lambda : list ( map ( int , stdin . readline ( ) . strip ( ) . split ( ) ) ) <NEWLINE> isa = lambda : stdin . readline ( ) . strip ( ) . split ( ) <NEWLINE> mod = 1000000007 <NEWLINE> ani , total = iia ( ) <NEWLINE> if 0 <= ( 4 * ani - total ) <= 2 * ani : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> if 2 * x <= y <= 4 x and y % 2 = 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
anim , leg = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> <NL> y = ( leg - 2 anim ) / 2 <NEWLINE> x = ( 4 anim - leg ) / 2 <NEWLINE> <NL> if isinstance ( y , float ) or isinstance ( x , float ) or y < 0 or x < 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> def func ( x , y ) : <NEWLINE> <INDENT> if y % 2 == 1 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> if 4 * x < y : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return True <NEWLINE> <NL> <DEDENT> <DEDENT> if func ( x , y ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE>
xin = input ( ) . split ( ) <NEWLINE> x = list ( map ( int , xin ) ) <NEWLINE> <NL> a = x [ 0 ] * 2 - x [ 1 ] / 2 <NEWLINE> b = - x [ 0 ] / 2 + x [ 1 ] / 2 <NEWLINE> <NL> if a >= 0 and b >= 0 : <NEWLINE> <INDENT> if ( a . isinteger ( ) and b . isinteger ( ) ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else ; <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT>
X , Y = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> for i in range ( X + 1 ) : <NEWLINE> <INDENT> for j in range ( X + 1 ) : <NEWLINE> <INDENT> if int ( i ) + int ( j ) < X + 1 : <NEWLINE> <INDENT> if ( ( ( 2 * i ) + ( 3 * j ) ) == Y ) or ( ( ( 2 * j ) + ( 3 * i ) ) == Y ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
<COMMENT> <NL> if y > x * 4 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <COMMENT> <NL> <DEDENT> elif y < x * 2 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <COMMENT> <NL> <DEDENT> elif y % 2 == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> for i in range ( 0 , x + 1 ) : <NEWLINE> <INDENT> if y == 2 * i + 4 * ( x - i ) : <NEWLINE> <INDENT> print ( Yes ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if i == x : <NEWLINE> <INDENT> print ( No ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
XY = input ( ) <NEWLINE> X = int , ( XY . split ( [ 0 ] ) ) <NEWLINE> Y = int , ( XY . split ( [ 1 ] ) ) <NEWLINE> <NL> for i in range ( X + 1 ) : <NEWLINE> <INDENT> if 2 * i + 4 * ( X - i ) == Y : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
a = y // 4 <NEWLINE> if 2 * ( x - a ) == y - 4 * a : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
number = input ( ) <NEWLINE> list = number . split ( ) <NEWLINE> if int ( list [ 1 ] ) % 3 == 0 or int ( list [ 0 ] ) * 4 < int ( list [ 1 ] ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a = 0 <NEWLINE> for i in range ( int ( list [ 0 ] ) ) : <NEWLINE> <INDENT> a = i <NEWLINE> n = i + 1 <NEWLINE> n2 = int ( list [ 0 ] - n ) <NEWLINE> if n * 2 + n2 * 4 == int ( list [ 1 ] ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if a == int ( list [ 0 ] ) - 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
try : <NEWLINE> <INDENT> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> f = 2 * i + 4 * ( N - i ) <NEWLINE> if f == M : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> except EOFError as error : <NEWLINE>
x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> a = int ( input ( ) ) <NEWLINE> ans = 2 * a + 4 ( x - a ) <NEWLINE> if ans == y : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
x , y = map ( intinput ( ) split ( ) ) <NEWLINE> a = 4 x - y <NEWLINE> if a / 2 = a % 2 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
from numba import jit <NEWLINE> <NL> <NL> @ jit <NEWLINE> def solve ( X , Y , Z ) : <NEWLINE> <INDENT> while X >= 0 : <NEWLINE> <INDENT> if 2 * X + 4 * Z == Y : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> elif 2 * X + 4 * Z < Y : <NEWLINE> <INDENT> X -= 1 <NEWLINE> Z += 1 <NEWLINE> <DEDENT> <DEDENT> return False <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> X , Y = map ( int , input ( ) . split ( ) ) <NEWLINE> Z = 0 <NEWLINE> <NL> if solve ( X , Y , Z ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> for i in range ( X ) : <NEWLINE> <INDENT> for j in range ( X ) : <NEWLINE> <INDENT> if 2 * i + 4 * j == Y : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if y % 2 == 0 and x * 2 = < y <= x * 4 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
l = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> for i in range ( l [ 0 ] + 1 ) : <NEWLINE> <INDENT> r = ( i * 2 + ( l [ 0 ] - i ) * 4 <NEWLINE> if r == l [ 1 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if i == l [ 0 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
a , b = [ int ( x ) for x in input ( ) . split ( <STRING> ) ] <NEWLINE> x = ( b - 2 a ) / 2 <NEWLINE> y = ( 4 a - b ) / 2 <NEWLINE> print ( <STRING> if x > 0 and y > 0 and x % 1 == 0.0 and y % 1 == 0.0 else <STRING> ) <NEWLINE>
x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> for i in range ( x ) : <NEWLINE> <INDENT> if 2 * i + 4 * ( x - i ) == y : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
X , Y = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = <STRING> <NEWLINE> for a in range ( X + 1 ) : <NEWLINE> <INDENT> b = X - a <NEWLINE> if 2 * a + 4 * b == Y : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <DEDENT> <DEDENT> 7 print ( ans ) <NEWLINE>
x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> r = 4 * x <NEWLINE> if r >= y y >= 2 * x and ( r - y ) % 2 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> c = 0 <NEWLINE> for i in range ( 0 , x + 1 ) : <NEWLINE> <INDENT> if y > 50 : <NEWLINE> <INDENT> c += 1 <NEWLINE> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> if y == 2 * ( x - i ) + 4 * i : <NEWLINE> <INDENT> c += 1 <NEWLINE> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> elif y == 2 * x + 4 * ( x - i ) : <NEWLINE> <INDENT> c += 1 <NEWLINE> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if c == 0 <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
if y % 2 == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( x + 1 ) : <NEWLINE> <INDENT> foot = i * 2 + ( x - i ) * 4 <NEWLINE> if foot == y : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n , legs = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> <NL> x = ( legs - 2 * n ) / 2 <NEWLINE> y = ( 4 * n - legs ) / 2 <NEWLINE> <NL> if X % 1 == 0 and y % 1 == 0 and x > 0 and y > 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> if ( ( y - ( 2 * x ) ) % 2 == 0 ) & ( x - ( ( y - ( 2 * x ) ) / 2 ) ) > 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
X , Y = map ( int , input ( ) . split ( ) ) <NEWLINE> if 2 * X < Y < 4 * X : <NEWLINE> <INDENT> elif Y % 2 != 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
x = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> def func ( x ) : <NEWLINE> <INDENT> for i in range ( x [ 0 ] + 1 ) : <NEWLINE> <INDENT> for j in range ( x [ 0 ] + 1 ) : <NEWLINE> <INDENT> if i + j > x [ 0 ] : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> elif i * 2 + j * 4 == x [ 2 ] or j * 2 + i * 4 == x [ 2 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> return <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> return <NEWLINE> <DEDENT> func ( x ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> x = int ( input ( ) ) <NEWLINE> y = int ( input ( ) ) <NEWLINE> l = list ( ) <NEWLINE> l . append ( 2 * x ) <NEWLINE> for i in range ( 1 , x + 1 ) : <NEWLINE> <INDENT> l . append ( 2 * x + i * 2 ) <NEWLINE> <DEDENT> if y in l : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
x , y = input ( ) . split ( ) <NEWLINE> x = int ( x ) <NEWLINE> y = int ( y ) <NEWLINE> for c in range ( 1 , x ) : <NEWLINE> <INDENT> t = x - c <NEWLINE> if 2 * c + 4 * t == y : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
x , n = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if n == 0 : <NEWLINE> <INDENT> print ( x ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> pn = [ int ( num ) for num in input ( ) . split ( ) ] <NEWLINE> answers = { } <NEWLINE> for i in range ( 0 , 101 ) : <NEWLINE> <INDENT> if not i in pn : <NEWLINE> <INDENT> answers [ i ] = abs ( i - x ) <NEWLINE> <DEDENT> <DEDENT> print ( min ( answers , key = answers . get ) ) <NEWLINE> <DEDENT>
x , y = input ( ) . split ( <STRING> ) <NEWLINE> x = int ( x ) <NEWLINE> <INDENT> y = int ( y ) <NEWLINE> <DEDENT> print ( <STRING> if 2 * x <= y and y <= 4 * x and y % 2 == 0 else <STRING> ) <NEWLINE>
x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> if y >= 2 * x and y <= 4 * x and y % 2 == 0 <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
X , Y = map ( int , input ( ) . split ( ) ) <NEWLINE> if Y % 2 == 0 and X * 4 >= Y and X * 2 <= Y : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> count = 0 <NEWLINE> <NL> for a in range ( x + 1 ) : <NEWLINE> <INDENT> b = x - a <NEWLINE> if y = a * 2 + b * 4 : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> if count == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
X , Y = map ( int , input ( ) . split ) <NEWLINE> ans = <STRING> <NEWLINE> for a in range ( X + 1 ) : <NEWLINE> <INDENT> b = X - a <NEWLINE> if 2 * a + 4 * b == Y : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
flag = True <NEWLINE> for a in range ( 101 ) : <NEWLINE> <INDENT> if 2 * a + 4 * ( x - a ) == y : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> flag = False <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if flag : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> for i in range ( x + 1 ) : <NEWLINE> <INDENT> if 4 * i + ( x - i ) * 2 = y : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
x , y = map ( int , input ( ) . sprit ( ) ) <NEWLINE> k = <STRING> <NEWLINE> for i in range ( x + 1 ) : <NEWLINE> <INDENT> b = x - i <NEWLINE> if i * 4 + b * 2 == y : <NEWLINE> <INDENT> k = <STRING> <NEWLINE> <DEDENT> <DEDENT> print ( k ) <NEWLINE>
x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> a = ( 4 x - y ) / 2 <NEWLINE> b = ( - 2 x + y ) / 2 <NEWLINE> if a % 1 == 0 and 0 <= aand b % 1 == 0 and 0 <= b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
X , Y = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if ( X >= Y or Y % 2 or Y > 4 * X or Y < 2 * X ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif ( Y <= 4 * X and Y >= 2 * X ) <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
X , Y = map ( int , input ( ) . split ( ) ) <NEWLINE> 2 ans = <STRING> <NEWLINE> 3 for a in range ( X + 1 ) : <NEWLINE> 4 b = X - a <NEWLINE> 5 if 2 * a + 4 * b == Y : <NEWLINE> 6 ans = <STRING> <NEWLINE> 7 print ( ans ) <NEWLINE>
n = input ( ) <NEWLINE> x , y = n . split ( ) <NEWLINE> c = ( 4 * int ( x ) - int ( y ) ) / 2 <NEWLINE> t = int ( x ) - c <NEWLINE> print ( z ) <NEWLINE> if c . is_integer and 100 >= c >= 0 and 100 >= t >= 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> for i in range ( i + 1 ) : <NEWLINE> <INDENT> if 4 * i + 2 * ( x - i ) == y : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
x = int ( input ( ) ) <NEWLINE> y = int ( input ( ) ) <NEWLINE> <NL> if ( y - 2 * x ) / 2 <= x : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
X , Y = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> for i in range ( X + 1 ) : <NEWLINE> <INDENT> if Y == ( 2 * i + 4 * ( X - T ) ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
X , Y = input ( ) . split ( ) <NEWLINE> v = Y - ( 2 * X ) <NEWLINE> if v < 0 or v % 2 == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
X , Y = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> crain = ( 4 * X - Y ) / 2 <NEWLINE> turtle = ( Y - 2 * X ) / 2 <NEWLINE> <NL> if ( crain . is_integer ( ) and crain >= 0 ) and ( turtle . is_integer ( ) and turtle >= 0 ) : n * 2 ) ) <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> na , nl = ( int ( i ) for i in input ( ) . split ( ) ) <NEWLINE> nc = ( 4 * na - nl ) / 2 <NEWLINE> <NL> pos = nc == int ( nc ) and nc >= 0 and nc <= x <NEWLINE> <NL> if pos : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> main ( ) <NEWLINE>
X , Y = map ( input ( ) . split ( ) ) <COMMENT> <NEWLINE> <NL> crane_legs = 2 <NEWLINE> turtle_legs = 4 <NEWLINE> <NL> answer = <STRING> <NEWLINE> <NL> for i in range ( X + 1 ) : <COMMENT> <NEWLINE> <INDENT> remaining = X - i <COMMENT> <NEWLINE> if crane_legs * i + turtle_legs * remaining == Y : <NEWLINE> <INDENT> answer = <STRING> <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> print ( answer ) <NEWLINE>
x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> crain = ( 4 * x - y ) / 2 <NEWLINE> if y >= 2 x and y <= 4 x and y % 2 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
X , Y = map ( int , input ( ) . split ( ) ) ans = <STRING> <NEWLINE> for a in range ( X + 1 ) : <NEWLINE> b = X - a <NEWLINE> if 2 * a + 4 * b == Y : <NEWLINE> ans = <STRING> print ( ans ) <NEWLINE>
x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> for i in range ( n + 1 ) : <NEWLINE> <INDENT> if i * 4 + ( n - i ) * 2 == y : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import sys <NEWLINE> x , y = map ( int , input ( ) . split ( ) ) if y % x != 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> if 2 ** x >= y : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
nums = input ( ) . split ( ) <NEWLINE> [ X , Y ] = list ( map ( int , nums ) ) <NEWLINE> <NL> if Y <= 4 * X & & Y >= 2 * X : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> if 2 * x <= y and y <= 4 * x and y & 2 = 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> c = 0 <NEWLINE> <NL> while x >= 0 : <NEWLINE> <INDENT> if c * 2 + x * 4 == y : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> c += 1 <NEWLINE> x -= 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( No ) <NEWLINE> <NL> <DEDENT> print ( Yes ) <NEWLINE>
import sys <NEWLINE> <NL> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> for i in range ( x + 1 ) : <NEWLINE> <INDENT> for j in range ( x + i ) : <NEWLINE> <INDENT> if i * 2 + j * 4 == y and i + j == X : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
import sys <NEWLINE> readline = sys . stdin . readline <NEWLINE> <NL> def solve ( ) : <NEWLINE> <INDENT> X , Y = map ( int , readline ( ) . split ( ) ) <NEWLINE> <NL> Y - X * 2 = a <NEWLINE> <NL> if a >= 0 and a % 2 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> solve ( ) <NEWLINE>
x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> if x * 2 > y : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if y % 2 == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if x * 4 < y : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> if 2 x <= y <= 4 x and y % 2 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
x , y = map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ymax = 4 * x <NEWLINE> ymin = 2 * x <NEWLINE> <NL> if y >= ymin and y <= ymax and y % 2 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> for i in range ( 0 : x + 1 ) : <NEWLINE> <INDENT> rest = y - 2 * i <NEWLINE> if rest % 4 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> ans = 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if ans == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
X = int ( ( input ( ) . split ( ) ) [ 0 ] ) <NEWLINE> Y = int ( ( input ( ) . split ( ) ) [ 1 ] ) <NEWLINE> c = ( 4 * X - Y ) / 2 <NEWLINE> t = ( Y - 2 * X ) / 2 <NEWLINE> if c >= 0 and int ( c ) == c : <NEWLINE> <INDENT> if t >= 0 and int ( t ) == t : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
X , Y = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> ans = <STRING> <NEWLINE> if a in range ( X + 1 ) : <NEWLINE> <INDENT> b = X - a <NEWLINE> if 2 * a + 4 * b == Y : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
x , y = map ( int , input ( ) split ( ) ) <NEWLINE> <NL> <NL> if i in range ( x ) : <NEWLINE> <INDENT> if y == 4 x - 2 a : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
y <NEWLINE> XY = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if 2 * XY [ 0 ] - XY [ 1 ] / 2 == 0 and - XY [ 0 ] + XY [ 1 ] / 2 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> if 2 * XY [ 0 ] - XY [ 1 ] / 2 >= 0 and - XY [ 0 ] + XY [ 1 ] / 2 >= 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
X , Y = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if ( Y % 2 == 1 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif ( Y > ( X * 4 ) ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> yes = False <NEWLINE> for i in range ( 1 , X + 1 ) : <NEWLINE> <INDENT> fNum = i <NEWLINE> tNum = X - i <NEWLINE> if ( ( fNum * 4 ) + ( tNum * 2 ) == Y ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> yes = True <NEWLINE> <DEDENT> <DEDENT> if not ( false ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
listt = input ( ) . split ( ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> doubutsu = int ( listt [ 0 ] ) <NEWLINE> ashi = int ( listt [ 1 ] ) <NEWLINE> <NL> kame = ( ashi - 2 * doubutsu ) / 2 <NEWLINE> tsuru = doubutsu - kame <NEWLINE> <NL> if type ( kame ) == int and type ( tsuru ) == int : <NEWLINE> <INDENT> if kame >= 0 and tsuru >= 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif kame == 0 and tsuru == 0 ; <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( <STRING> if x * 2 <= y <= x * 4 and x % 2 = 0 else <STRING> ) <NEWLINE>
x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> flag = 0 <NEWLINE> for i in range ( 100 ) : <NEWLINE> <INDENT> for j in range ( 100 ) : <NEWLINE> <INDENT> if i + j == x and i * 2 + j * 4 = y : <NEWLINE> <INDENT> flag = 1 <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if flag == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> ans = <STRING> <NEWLINE> for i range ( x + 1 ) : <NEWLINE> <INDENT> if ( x * 2 + ( x - i ) * 4 ) == y : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
X , Y = [ int ( ) , input ( ) . split ( ) ] <NEWLINE> <NL> if X % 2 == 0 and 2 * X < Y < 4 * X : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
C , T = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <COMMENT> <NL> result = <STRING> <NEWLINE> for a in range ( C + 1 ) : <NEWLINE> b = C - a <NEWLINE> <NL> <COMMENT> <NL> if 2 * a + 4 * b == T : <NEWLINE> <INDENT> result = <STRING> <NEWLINE> <NL> <DEDENT> print ( result ) <NEWLINE>
n , t = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> m = 0 <NEWLINE> while m < n + 1 : <NEWLINE> <INDENT> if m * 4 + ( n - m ) * 2 == t : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <NL> m += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if m == ( n + 1 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> X = a [ 1 ] <NEWLINE> Y = a [ 2 ] <NEWLINE> <NL> if ( Y - 2 * X ) % 2 == 0 and ( Y - 2 * X ) >= 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
<INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> for i in range ( x + 1 ) : <NEWLINE> <INDENT> if 4 * i + 2 * ( x - i ) == y : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
X , Y = map ( int , input ( ) . split ( ) ) <NEWLINE> if y % 2 == 0 : <NEWLINE> <INDENT> y = Y // 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( 0 ) <NEWLINE> <NL> <DEDENT> if x < y < 2 * x : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT>
q = 0 <NEWLINE> for a in range ( x + 1 ) : <NEWLINE> <INDENT> s = 0 <NEWLINE> s += a * 2 <NEWLINE> s += ( x - a ) * 4 <NEWLINE> if s == y : <NEWLINE> <INDENT> q = 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if q == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
X , Y = map ( int , input . split ( ) ) <NEWLINE> <NL> if ( Y % 2 == 0 and 2 * X <= Y <= 4 * X ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b = ( int ( x ) for x in input ( ) . split ( ) ) <NEWLINE> lista = [ ] <NEWLINE> listb = [ ] <NEWLINE> for numa in range ( a + 1 ) : <NEWLINE> <INDENT> lista . append ( numa * 2 ) <NEWLINE> <DEDENT> for numb in range ( a + 1 ) : <NEWLINE> <INDENT> listb . append ( numb * 4 ) <NEWLINE> <DEDENT> listb . reverse ( ) <NEWLINE> count = 0 <NEWLINE> combined1 = [ x + y for ( x , y ) in ( lista , listb ) ] <NEWLINE> for num in combined1 : <NEWLINE> <INDENT> if num == b : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> if count > 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
X , Y = input ( ) . split ( ) <NEWLINE> <NL> if ( Y % 2 == 0 ) and ( 4 * X >= Y >= 2 * X ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> for i in range ( a ) : <NEWLINE> <INDENT> if ( a - i ) * 2 + ( i ) * 4 == b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if i == a - 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
<INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> for i in range ( x + 1 ) : <NEWLINE> <INDENT> if ( ( i * 2 + ( x - i ) * 4 ) == y ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> break <NEWLINE> else : <NEWLINE> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT>
from math import gcd <NEWLINE> <NL> from math import factorial as f <NEWLINE> <NL> from math import ceil , floor , sqrt <NEWLINE> import math <NEWLINE> <NL> import bisect <NEWLINE> import re <NEWLINE> import heapq <NEWLINE> <NL> <NL> from copy import deepcopy <NEWLINE> import itertools <NEWLINE> from itertools import permutations <NEWLINE> <NL> from sys import exit <NEWLINE> <NL> ii = lambda : int ( input ( ) ) <NEWLINE> mi = lambda : map ( int , input ( ) . split ( ) ) <NEWLINE> li = lambda : list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> yes = <STRING> <NEWLINE> no = <STRING> <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> x , y = mi ( ) <NEWLINE> flag = False <NEWLINE> for i in range ( x + 1 ) : <NEWLINE> <INDENT> if i * 2 + ( x - i ) * 4 == y : <NEWLINE> <INDENT> flag = True <NEWLINE> <DEDENT> <DEDENT> if flag : <NEWLINE> <INDENT> print ( yes ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( no ) <NEWLINE> <NL> <NL> <NL> <DEDENT> <DEDENT> main ( ) <NEWLINE> <NL> <NL> j <NEWLINE>
input_line = input ( ) . split ( <STRING> ) <NEWLINE> X = int ( input_line [ 0 ] ) <NEWLINE> Y = int ( input_line [ 1 ] ) <NEWLINE> Pat = 0 <NEWLINE> for i in range ( X + 1 ) : <NEWLINE> <INDENT> C = i <NEWLINE> T = X - i <NEWLINE> Cf = C * 2 <NEWLINE> Tf = T * 4 <NEWLINE> F = Cf + Tf <NEWLINE> if Y == F : <NEWLINE> <INDENT> Pat = Pat + 1 <NEWLINE> <DEDENT> <DEDENT> if Pat >= 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <NL> <NL> <NL> <DEDENT>
X , Y = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = <STRING> <NEWLINE> for a in range ( X + 1 ) : <NEWLINE> <INDENT> b = X - a <NEWLINE> if 2 * a + 4 * b == Y : <NEWLINE> ans = <STRING> <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( <STRING> if y % 2 == 0 and x * 2 <= y <= x * 4 ) <NEWLINE>
X , Y = map ( int , input ( ) . split ( ) ) <NEWLINE> if y % 2 == 0 and 2 * X <= Y and Y <= 4 * X : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
2 100 <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> <INDENT> for i in range ( a ) : <NEWLINE> <INDENT> for j in range ( b ) : <NEWLINE> <INDENT> if i + j = a and i * 2 + 4 * j = b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT>
turu = 2 <NEWLINE> kame = 4 <NEWLINE> flag = 0 <NEWLINE> <NL> for x in range ( a + 1 ) : <NEWLINE> <INDENT> for y in range ( a + 1 ) : <NEWLINE> <INDENT> if turu * x + kame * y == b and x + y <= a : <NEWLINE> <INDENT> flag += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if flag == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> print ( a . index ( 0 ) + 1 ) <NEWLINE>
import sys <NEWLINE> X , Y = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> for x in range ( 0 , X + 1 ) : <NEWLINE> <INDENT> if 2 * x + 4 * ( X - x ) == Y : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> <NEWLINE>
n , m = [ int ( n ) for n in input ( ) . split ( ) ] <NEWLINE> if ( m > ( n * 4 ) or m < ( n * 2 ) ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if ( m % 2 == 0 ) : <NEWLINE> <INDENT> print ( <STRING> ) : <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
X , Y = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if Y % 2 == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if 2 X <= Y <= 4 * X : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
X , Y = map ( int , input ( ) . split ( ) ) <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <DEDENT> for a in range ( X + 1 ) : <NEWLINE> <INDENT> b = X - a <NEWLINE> if 2 * a + 4 * b == Y : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
x , y = int ( input ( ) . split ( ) ) <NEWLINE> <NL> max_num = 4 * x <NEWLINE> min_num = 2 * x <NEWLINE> <NL> if y % 2 == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif ( min_num <= y ) and ( max_num >= y ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
X = int ( input ( ) ) <NEWLINE> Y = int ( input ( ) ) <NEWLINE> <NL> if Y % 2 == 0 and Y - 2 * X >= 0 and 4 * X - Y >= 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
X , Y = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> for i in range ( X + 1 ) : <NEWLINE> <INDENT> if 2 * i + 4 ( X - i ) == Y : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = <STRING> <NEWLINE> if a in range ( x + 1 ) : <NEWLINE> <INDENT> b = x - a <NEWLINE> a * 2 + b * 4 == y : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
num = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> X = num [ 0 ] <NEWLINE> Y = num [ 1 ] <NEWLINE> ans = <STRING> <NEWLINE> for i in range ( X + 1 ) : <NEWLINE> <INDENT> if 4 * X - 2 * i == Y : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> braek ; <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> z = 0 <NEWLINE> for a in range ( x + 1 ) : <NEWLINE> <INDENT> for b in range ( x - a + 1 ) : <NEWLINE> <INDENT> if 2 * a + 4 * b == y : <NEWLINE> <INDENT> z += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if z = 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
<INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> <DEDENT> if y % 2 == 0 and ( x * 2 <= y <= x * 4 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> for i in range ( 0 , x + 1 ) : <NEWLINE> <INDENT> a . append ( 2 * i + 4 * ( 3 - i ) ) <NEWLINE> <DEDENT> print ( <STRING> if y in a else <STRING> ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> c = 1 <NEWLINE> for i in range ( 0 , a ) : <NEWLINE> <INDENT> for k in range ( 0. a - i ) : <NEWLINE> <INDENT> if 2 * i + 4 * k == b : <NEWLINE> <INDENT> c = 0 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if c == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> for i in range ( x + 1 ) : <NEWLINE> <INDENT> 2 * i + 4 * ( x - i ) == y : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
x , y = map ( int , input ( ) ) . split ( ) ) <NEWLINE> tr , km , flag = 0 , 0 , 0 <NEWLINE> for i in range ( x ) : <NEWLINE> <INDENT> tr += 1 <NEWLINE> for l in range ( x - tr ) : <NEWLINE> <INDENT> km += 1 <NEWLINE> if tr + km == y : <NEWLINE> <INDENT> flag = 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if frag == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else flag == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
X , Y = map ( int , input ( ) . split ( ) ) <NEWLINE> k = Y / 2 <NEWLINE> q = y / 4 <NEWLINE> if q <= X and X <= k : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
x , y = input ( ) . split ( ) <NEWLINE> <NL> for kame in range ( 0 , x + 1 ) : <NEWLINE> <INDENT> tsuru = x - kame <NEWLINE> legs = kame * 4 + tsuru * 2 <NEWLINE> if legs == y : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
X = input ( ) <NEWLINE> Y = input ( ) <NEWLINE> T = false <NEWLINE> for i in range ( 1 , X + 1 ) : <NEWLINE> <INDENT> p = X - i <NEWLINE> J = 2 * i + 4 * p <NEWLINE> if J = Y : <NEWLINE> <INDENT> T = true <NEWLINE> <DEDENT> <DEDENT> if T == true : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> else print ( <STRING> ) <NEWLINE> <DEDENT>
X = int ( input ( ) ) <NEWLINE> Y = int ( input ( ) ) <NEWLINE> flag = 0 <NEWLINE> for crane in range ( X + 1 ) : <NEWLINE> <INDENT> if ( Y - crane * 2 - ( X - crane ) * 4 ) == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> flag = 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if flag == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
x , y = int ( map , input ( ) . split ( ) ) <NEWLINE> <NL> if ( 2 * x <= y <= 4 * x and y % 2 == 0 and x <= 50 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> if __name__ == <STRING> : <NEWLINE> <INDENT> for line in sys . stdin : <NEWLINE> <INDENT> anis , legs = line . split ( <STRING> ) <NEWLINE> if legs % 2 == 1 or legs > anis * 4 or legs < anis * 2 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> def equation ( numLeg , numAnim ) : <NEWLINE> <INDENT> for numCrane in range ( 0 , numAnim ) : <NEWLINE> <INDENT> numTurt = numAnim - numCrane <NEWLINE> totalLeg = 4 * numTurt + 2 * numCrane <NEWLINE> if totalLeg == numLeg : <NEWLINE> <INDENT> return [ numTurt , numCrane ] <NEWLINE> <DEDENT> <DEDENT> return [ None , None ] <NEWLINE> <COMMENT> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> x , y = int ( input ( ) ) . split ( ) <NEWLINE> cranes , turtles = equation ( y , x ) <NEWLINE> if turtles == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> <NL> X , Y = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = <STRING> <NEWLINE> if X > 100 or Y > 100 : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> if Y > X * 4 or Y < X * 2 : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> if Y % 2 == 1 : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> for a in range ( X + 1 ) : <NEWLINE> <INDENT> b = X - a <NEWLINE> if 2 * a + 4 * b == Y : <NEWLINE> ans = <STRING> <NEWLINE> print ( ans ) <NEWLINE> <DEDENT>
i = input ( ) . split ( ) <NEWLINE> i = [ int ( j ) for j in i ] <NEWLINE> <NL> flg = 0 <NEWLINE> for a in range ( i [ 0 ] ) : <NEWLINE> <INDENT> if 2 * a + 4 * b == i [ 1 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> flg = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if flg == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> a = 0 <NEWLINE> for i in range ( x + 1 ) : <NEWLINE> <INDENT> if 2 * i + 4 * ( x - i ) == y : <NEWLINE> <INDENT> a = 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if a = 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> ans = <STRING> <NEWLINE> <NL> for i in range ( x + 1 ) : <NEWLINE> <INDENT> j = x - a <NEWLINE> if ( j * 2 + i * 4 == y ) : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
X , Y = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> for i in range ( X ) : <NEWLINE> <INDENT> if Y - ( 4 * ( ( i + 1 ) == ( X - ( i + 1 ) ) * 2 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if Y == 2 or Y == 4 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = <STRING> <NEWLINE> for a in range ( x + 1 ) : <NEWLINE> <INDENT> b = x - a <NEWLINE> if 2 * a + 4 * b == Y : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
x , y = map ( int , input . split ( ) ) <NEWLINE> if y % 2 == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif x * 4 < y : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif x * 2 > y : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b = map ( int , input ( ) . split ( ) ) ) <NEWLINE> if ( b % ( 2 * a ) == 0 or b % ( 4 * a ) == 0 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
X , Y = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = <STRING> <NEWLINE> for a in range ( X + 1 ) : <NEWLINE> <INDENT> b = X - a <NEWLINE> <INDENT> if 2 * a + 4 * b == Y : <NEWLINE> ans = <STRING> <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
X , Y = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> <NL> ans = <STRING> <NEWLINE> for x in range ( X + 1 ) : <NEWLINE> <INDENT> if 2 * x + 4 * ( X - x ) == y : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> z = 0 <NEWLINE> <NL> for i in range ( x ) : <NEWLINE> <INDENT> if i * 2 + ( x - i ) * 4 != = y : <NEWLINE> <INDENT> z = z <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> z = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if z == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
X , Y = map ( int , input ( ) . split ( ) ) <NEWLINE> a = Y % 4 <NEWLINE> b = a / 2 <NEWLINE> c = int ( Y / 4 ) <NEWLINE> if a % 2 != 0 , b + c > X : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a = 34 <NEWLINE> <NL> if a == int <NEWLINE> print ( 6 ) <NEWLINE>
def abc2 ( x , y ) : <NEWLINE> <INDENT> if y % 2 != 0 : <NEWLINE> <INDENT> return print ( <STRING> ) <NEWLINE> <DEDENT> kame = ( y // 2 ) - x <NEWLINE> if ( kame >= 0 ) & ( kame <= x ) : <NEWLINE> <INDENT> return print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> abs2 ( x , y ) <NEWLINE>
s = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if Y - 2 * X >= 0 and ( Y - 2 * X ) % 2 == 0 : <NEWLINE> <INDENT> a = int ( ( Y - 2 * X ) // 2 ) <NEWLINE> if X - a >= 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> n = l [ 0 ] <NEWLINE> legs = l [ 1 ] <NEWLINE> ( 2 * a ) + ( 2 * ( n - a ) ) == legs <NEWLINE> if ( l [ 1 ] % 2 != 0 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> if ( l [ 1 ] % 2 == 0 and l [ 0 ] * 4 >= l [ 1 ] ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
print ( <STRING> if ( lambda x : x [ 0 ] * 2 <= x [ 1 ] <= x * 4 ) ( list ( map ( int , input ( ) . split ( ) ) ) ) else <STRING> ) <NEWLINE>
x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = False <NEWLINE> <NL> for i in range ( 101 ) : <NEWLINE> <INDENT> for j in range ( 101 ) : <NEWLINE> <INDENT> if i + j == x and 2 * i + 4 * j == y : <NEWLINE> ans = True <NEWLINE> <NL> <DEDENT> <DEDENT> if ans : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> for a in range ( x + 1 ) : <NEWLINE> <INDENT> tem = 2 * a + 4 * ( x - a ) <NEWLINE> if ( tem == y ) : <NEWLINE> <COMMENT> <NL> <INDENT> print ( <STRING> ) <NEWLINE> exit ( 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
X , Y = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = <STRING> <NEWLINE> for a in range ( X + 1 ) : <NEWLINE> <INDENT> b = X - a <NEWLINE> if 2 * a + 4 * b == Y : <NEWLINE> <INDENT> ans = <STRING> print ( ans ) <NEWLINE> <NL> <DEDENT> <DEDENT>
x , y = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> flg = true <NEWLINE> for i in range ( x ) : <NEWLINE> <INDENT> if 2 * i + 4 * ( x - i ) == y : <NEWLINE> <INDENT> print ( <STRING> ) : <NEWLINE> flg = False <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if flg : print ( <STRING> ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if a * 2 == b or a * 4 == b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif b % 2 == 0 and y - 2 * a >= 0 and 4 * a - b >= 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
x , y = input ( ) . split ( ) <NEWLINE> if y % 2 == 1 or x * 2 > y or x * 4 < y : <NEWLINE> <INDENT> a = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a = <STRING> <NEWLINE> <DEDENT> print ( a ) <NEWLINE>
X , Y = map ( int , input ( ) . split ( ) ) <NEWLINE> a = 0 <NEWLINE> for i in range ( X + 1 ) : <NEWLINE> <INDENT> if 2 * i + 4 * ( X - i ) == Y : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> a += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if a == X <NEWLINE> <NL> <NL> if a == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> MM = input ( ) . split ( ) <NEWLINE> total = 1 <NEWLINE> for i in MM : <NEWLINE> <INDENT> total = total * int ( i ) <NEWLINE> <NL> if total > 10 ** 18 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> for i in MM : <NEWLINE> <INDENT> if int ( i ) == 0 : <NEWLINE> <INDENT> total = 0 <NEWLINE> <DEDENT> <DEDENT> if total > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( total ) <NEWLINE> <DEDENT>
a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if ( a [ 0 ] * 4 ) >= a [ 1 ] and ( a [ 0 ] * 2 ) <= a [ 1 ] and A [ 1 ] % 2 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
x , y = int ( input ( ) . split ( ) ) <NEWLINE> if y % 2 == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif 2 * x <= y <= 4 * x : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> if ( y - x ) > = x : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT>
<INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> <DEDENT> b = y / 2 - x <NEWLINE> a = x - b <NEWLINE> if a >= 0 and b >= 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
X , Y = map ( int , input ( ) . split ( ) ) <NEWLINE> Ans = <STRING> <NEWLINE> if Y % 2 = 0 : <NEWLINE> <INDENT> if 2 * X <= Y and Y <= 4 * X : <NEWLINE> <INDENT> Ans = <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> print ( Ans ) <NEWLINE>
X , Y = map ( int , input ( ) . split ( ) ) <NEWLINE> A = <STRING> <NEWLINE> for a in range ( X + 1 ) : <NEWLINE> <INDENT> B = X - 1 <NEWLINE> if 2 * a + 4 * B == Y <NEWLINE> <INDENT> A = <STRING> <NEWLINE> <DEDENT> <DEDENT> print ( A ) <NEWLINE>
x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if y % 2 == 0 : <NEWLINE> <INDENT> turu = y // 2 - x <NEWLINE> kame = 2 * x - y // 2 <NEWLINE> if turu >= 0 and kame >= 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
X , Y = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if ( 1 <= X <= 100 ) and ( 1 <= Y <= 100 ) : <NEWLINE> <INDENT> if isinstance ( ( Y - X ) / 2 , int ) and isinstance ( ( Y - X ) / - 2 , int ) <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
X , Y = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = <STRING> <NEWLINE> for a in range ( X + 1 ) : <NEWLINE> <INDENT> b = X - a <NEWLINE> if 2 * a + 4 * b == Y : <NEWLINE> ans = <STRING> <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
x = input ( ) <NEWLINE> y = input ( ) <NEWLINE> if 2 * x <= y <= 4 * x and y % 2 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
for a in range ( x + 1 ) : <NEWLINE> <INDENT> b = x - a <NEWLINE> if ( 2 * a + 4 * b ) == y : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> flag = False <NEWLINE> for i in range ( x + 1 ) : <NEWLINE> <INDENT> yi = 2 * i + 4 ( x - i ) <NEWLINE> if y == yi : <NEWLINE> <INDENT> flag = True <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> ) if flag else print ( <STRING> ) <NEWLINE>
X , Y = [ int ( x ) for x in stdin . readline ( ) . rstrip ( ) . split ( ) ] <NEWLINE> if Y % 2 == 0 : <NEWLINE> <INDENT> Z = Y / X <NEWLINE> if 2 <= Z <= 4 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a = list ( input ( ) . split ( <STRING> ) ) <NEWLINE> animal = int ( a [ 0 ] ) <NEWLINE> foot = int ( a [ 1 ] ) <NEWLINE> <NL> saisyo = 2 * animal <NEWLINE> saidai = 4 * animal <NEWLINE> <NL> if ( foot % 2 = 0 ) and ( saisyo <= foot <= saidai ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if ( 4 * a [ 0 ] - a [ 1 ] ) % 2 == 0 and 2 * t >= ( 4 * a [ 0 ] - a [ 1 ] ) >= 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
x , y = map ( int , input ( ) . strip ( ) . split ( ) ) <NEWLINE> <NL> if x * 4 < b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif y % 2 != 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
input_line = input ( ) . split ( ) <NEWLINE> <NL> for i in range ( input_line [ 1 ] ) : <NEWLINE> <INDENT> print ( input_line [ 0 ] ) <NEWLINE> <DEDENT>
X , Y = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <NL> <COMMENT> <NL> <NL> for i in range ( X ) : <NEWLINE> <INDENT> if 2 * i == 4 * X - Y and i != 0 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> elif 2 * ( i + 1 ) == Y : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> elif 4 * ( X - i ) == Y : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if ans > 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
x , y = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> <NL> <COMMENT> <NL> leg_turtle = 4 <NEWLINE> leg_clane = 2 <NEWLINE> <NL> if y > x * leg_turtle : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> elif y < leg_clane * x : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <NL> <DEDENT> import pulp <NEWLINE> <NL> <COMMENT> <NL> problem = pulp . LpProblem ( <STRING> , pulp . LpMaximize ) <NEWLINE> <NL> <COMMENT> <NL> clane = pulp . LpVariable ( <STRING> , 0 , 100 , <STRING> ) <NEWLINE> turtle = pulp . LpVariable ( <STRING> , 0 , 100 , <STRING> ) <NEWLINE> <NL> <COMMENT> <NL> problem += 2 * clane + 4 * turtle <NEWLINE> <NL> <COMMENT> <NL> problem += clane + turtle == x <NEWLINE> problem += 2 * clane + 4 * turtle <= y <NEWLINE> <NL> <COMMENT> <NL> status = problem . solve ( ) <NEWLINE> <COMMENT> <NL> c = clane . value ( ) <NEWLINE> t = turtle . value ( ) <NEWLINE> res_1 = 2 * c + 4 * t <NEWLINE> res_2 = c + t <NEWLINE> <COMMENT> <NL> if res_1 == y and res_2 == x : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
x , n = map ( int , , input ( ) . split ( ) ) <NEWLINE> a = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> print ( x ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( 100 ) : <NEWLINE> <INDENT> aa = x - i <NEWLINE> if aa not in a : <NEWLINE> <INDENT> print ( aa ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> bb = x + i <NEWLINE> if bb not in a : <NEWLINE> <INDENT> print ( bb ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT>
X , N = map ( int , input ( ) . split ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> if N == 0 : <NEWLINE> <INDENT> print ( X ) <NEWLINE> <NL> <DEDENT> for i in range ( 102 ) : <NEWLINE> <INDENT> if X - i not in p : <NEWLINE> <INDENT> print ( x - i ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> if X + i not in p : <NEWLINE> <INDENT> print ( x + i ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT>
x , n = map ( int , input ( ) . split ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> i = 0 <NEWLINE> if n == 0 : <NEWLINE> <INDENT> print ( x ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( 101 ) <NEWLINE> <INDENT> if not x - i in p : <NEWLINE> <INDENT> print ( x - i ) <NEWLINE> break <NEWLINE> <DEDENT> elif not x + i in p : <NEWLINE> <INDENT> print ( x + i ) <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> i += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
import sys <NEWLINE> <NL> X , N = map ( int , input ( ) . split ( ) ) <NEWLINE> P = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> NL = [ i for i in range ( - 1000 , 1000 ) if i == X or i not in P ] <NEWLINE> <NL> if len ( P ) == 0 : <NEWLINE> <INDENT> print ( X ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> idx = NL . index ( X ) <NEWLINE> if abs ( NL [ idx + 1 ] ) - X >= abs ( NL [ idx - 1 ] ) - X ) : <NEWLINE> <INDENT> print ( NL [ idx - 1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( NL [ idx + 1 ] ) <NEWLINE> <DEDENT>
x , n = map ( int , input ( ) . split ( ) ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> print ( x ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> q = [ True ] * 101 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> q [ p [ i ] ] = False <NEWLINE> <DEDENT> d_min = 10 ** 3 <NEWLINE> for j in range ( 1 , 102 ) : <NEWLINE> <INDENT> if q [ j ] : <NEWLINE> <INDENT> d = abs ( x - j ) <NEWLINE> if d_min > d : <NEWLINE> <INDENT> ans = j <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
x , n = map ( int , input ( ) . split ( ) ) <NEWLINE> p = map ( int , intput ( ) . split ( ) ) <NEWLINE> <NL> m = - 1 <NEWLINE> for a in p : <NEWLINE> <INDENT> if m == - 1 or ( abs ( a - x ) < abs ( m - x ) ) or ( abs ( a - x ) == abs ( m - x ) and a < m ) : <NEWLINE> <INDENT> m = a <NEWLINE> <NL> <DEDENT> <DEDENT> print ( m ) <NEWLINE>
x , n = map ( int , input ( ) . split ( ) ) <NEWLINE> a = set ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> print ( min ( i for i in range ( 102 ) if i not in a , key = lambda y : abs ( x - y ) ) ) <NEWLINE>
<COMMENT> <NL> def input2 ( ) : <NEWLINE> <INDENT> return map ( int , input ( ) . split ( ) ) <NEWLINE> <DEDENT> x , n = input2 ( ) <NEWLINE> p = sorted ( input_array ( ) ) <NEWLINE> q = [ 0 ] * 102 <NEWLINE> result = [ 10000 , - 1 ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> q [ p [ i ] ] = 1 <NEWLINE> <DEDENT> for i in range ( 102 ) : <NEWLINE> <INDENT> if q [ i ] == 0 : <NEWLINE> <INDENT> num = abs ( i - x ) <NEWLINE> if num < result [ 0 ] : <NEWLINE> <INDENT> result = [ num , i ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( result [ 1 ] ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> import copy <NEWLINE> <NL> num , quantity = map ( int , input ( ) . split ( ) ) <NEWLINE> nums = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> nums . sort ( ) <NEWLINE> <NL> if quantity == 0 : <NEWLINE> <INDENT> print ( num ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> i = 0 <NEWLINE> <NL> minus_num = copy . copy ( num ) <NEWLINE> plus_num = copy . copy ( num ) <NEWLINE> <NL> while i < len ( nums ) <NEWLINE> <INDENT> if num not in nums : <NEWLINE> <INDENT> print ( num ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> if minus_num not in nums : <NEWLINE> <INDENT> print ( minus_num ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> if plus_num not in nums : <NEWLINE> <INDENT> print ( plus_num ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> minus_num = minus_num - 1 <NEWLINE> plus_num = plus_num + 1 <NEWLINE> i = i + 1 <NEWLINE> <NL> <DEDENT> <DEDENT> main ( ) <NEWLINE>
X , N = map ( int , input ( ) . split ( ) ) <NEWLINE> if N == 0 : <NEWLINE> <INDENT> print ( X ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> P = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = list ( range ( 10000000 ) ) <NEWLINE> ab = 101 <NEWLINE> an = [ ] <NEWLINE> for i in range ( - 1. N ) : <NEWLINE> <INDENT> a . remove ( P [ i ] ) <NEWLINE> a = a <NEWLINE> <DEDENT> for j in range ( 101 - N ) : <NEWLINE> <INDENT> ab = min ( ab , abs ( X - a [ j ] ) ) <NEWLINE> <DEDENT> if X - ab in a : <NEWLINE> <INDENT> print ( X - ab ) <NEWLINE> <DEDENT> elif X + ab in a : <NEWLINE> <INDENT> print ( X + ab ) <NEWLINE> <NL> <NL> <NL> <DEDENT> <DEDENT>
X , N = map ( int , input ( ) . split ( ) ) <NEWLINE> i = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if X not in i : <NEWLINE> <INDENT> print ( X ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> n = 1 <NEWLINE> while n <= N + 1 : <NEWLINE> <INDENT> if X - n not in i : <NEWLINE> <INDENT> print ( X - n ) <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if X + n not in i : <NEWLINE> <INDENT> print ( X + n ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT>
import sys <NEWLINE> <NL> x , n = map ( int , input ( ) . split ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> list_p = [ i for i in range ( - 1 , 102 ) ] <NEWLINE> t = x <NEWLINE> num = x <NEWLINE> <NL> if ( x == n ) : <NEWLINE> <INDENT> print ( x - 1 ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> for i in p : <NEWLINE> <INDENT> list_p [ i + 1 ] = - 2 <NEWLINE> <NL> <DEDENT> for i in range ( len ( list_p ) ) : <NEWLINE> <INDENT> if ( list_p [ i ] == - 2 ) : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if ( abs ( list_p [ i ] - x ) <= t ) : <NEWLINE> <INDENT> if ( abs ( list_p [ i ] - x ) != t ) : <NEWLINE> <INDENT> t = abs ( list_p [ i ] - x ) <NEWLINE> num = list_p [ i ] <NEWLINE> <DEDENT> elif : <NEWLINE> <INDENT> t = abs ( list_p [ i ] - x ) : <NEWLINE> num = min ( num , list_p [ i ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( num ) <NEWLINE>
X , N = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if N == 0 : <NEWLINE> <INDENT> print ( X ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if N == 1 : <NEWLINE> <INDENT> if p [ 0 ] == X : <NEWLINE> <INDENT> print ( X - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( X ) <NEWLINE> <NL> <DEDENT> <DEDENT> MAX = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if MAX < X - p [ i ] : <NEWLINE> <INDENT> MAX = X - p [ i ] <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( MAX ) : <NEWLINE> <INDENT> if X - i not in p : <NEWLINE> <INDENT> ans = X - i <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> for i in range ( MAX ) : <NEWLINE> <INDENT> if X + i not in p : <NEWLINE> <INDENT> ans = min ( X - ans , ans - X ) + X <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
x , n = map ( int , input ( ) . split ( ) ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> print ( x ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> p = np . array ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> for i in range ( 100 ) : <NEWLINE> <INDENT> if not x - i in p : <NEWLINE> <INDENT> print ( x - i ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> elif not x + i in p : <NEWLINE> <INDENT> print ( x + i ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT>
import numpy as np <NEWLINE> <NL> <NL> def main ( X , N , a ) : <NEWLINE> <INDENT> a . append ( 10000000000 ) <NEWLINE> a . append ( - 10000000000 ) <NEWLINE> a . sort ( ) <NEWLINE> maxn = a [ 0 ] - 1 <NEWLINE> for i in range ( len ( a ) - 1 ) : <NEWLINE> <NL> <INDENT> if a [ i ] >= X : <NEWLINE> <INDENT> if a [ i + 1 ] - a [ i ] > 1 : <NEWLINE> <INDENT> if X - maxn > a [ i ] + 1 - X <NEWLINE> maxn = a [ i ] + 1 <NEWLINE> break <NEWLINE> <DEDENT> if X - maxn < a [ i ] - X : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if a [ i + 1 ] - a [ i ] > 1 : <NEWLINE> <INDENT> if a [ i + 1 ] > X and a [ i ] < X : <NEWLINE> <INDENT> maxn = X <NEWLINE> break <NEWLINE> <DEDENT> maxn = a [ i + 1 ] - 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> return maxn <NEWLINE> <NL> <NL> <DEDENT> X , N = map ( int , input ( ) . split ( ) ) <NEWLINE> try : <NEWLINE> <INDENT> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> a = [ ] <NEWLINE> <DEDENT> print ( main ( X , N , a ) ) <NEWLINE>
x , n , * P = map ( int , open ( 0 ) . read ( ) . split ( ) ) <NEWLINE> P = set ( P ) <NEWLINE> for i in range ( 51 ) : <NEWLINE> <INDENT> Q = { x - i , x + i } - P <NEWLINE> if Q : <NEWLINE> print ( min ( Q ) ) <NEWLINE> break <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> def Forbidden_List ( x , n , p ) : <NEWLINE> <INDENT> k = [ abs ( s - x ) for s in p ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if i not in k : <NEWLINE> <INDENT> return 10 - i <NEWLINE> <DEDENT> <DEDENT> return 10 - n <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> input = sys . stdin . readline <NEWLINE> <NL> inp1 = input ( ) . rstrip ( ) . split ( ) <NEWLINE> x , n = int ( inp1 [ 0 ] ) , int ( inp1 [ 1 ] ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> print ( x ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> inp2 = input ( ) . rstrip ( ) . split ( ) <NEWLINE> <INDENT> p = list ( map ( int , inp2 ) ) <NEWLINE> <NL> print ( Forbidden_List ( x , n , p ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
X , N = map ( int , input ( ) . split ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i in range ( 101 ) : <NEWLINE> <INDENT> if X - i not in p : <NEWLINE> <INDENT> print ( x - i ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> elif X + i not in p : <NEWLINE> <INDENT> print ( x + i ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT>
import math <NEWLINE> input_a = input ( ) . split ( <STRING> ) <NEWLINE> X = int ( input_a [ 0 ] ) <NEWLINE> N = int ( input_a [ 1 ] ) <NEWLINE> dis = X + 3 <NEWLINE> if N != 0 : <NEWLINE> <INDENT> array = input ( ) . split ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> array = [ 0 , 0 ] <NEWLINE> <NL> <DEDENT> num = X <NEWLINE> num2 = - 100 <NEWLINE> for i in range ( N + 1 ) : <NEWLINE> <NL> <NL> <INDENT> if str ( num ) not in array : <NEWLINE> <INDENT> dis = abs ( X - num ) <NEWLINE> num2 = X - dis <NEWLINE> num1 = num <NEWLINE> if str ( num2 ) not in array : <NEWLINE> <INDENT> numa = min ( [ num , num2 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> numa = num1 <NEWLINE> <DEDENT> break <NEWLINE> <DEDENT> num = num + 1 <NEWLINE> <NL> <NL> <DEDENT> num = X <NEWLINE> i = 0 <NEWLINE> for i in range ( dis ) : <NEWLINE> <NL> <INDENT> if str ( num ) not in array : <NEWLINE> <NL> <INDENT> dis2 = abs ( X - num ) <NEWLINE> num3 = X + dis2 <NEWLINE> <NL> if str ( num3 ) not in array : <NEWLINE> <INDENT> numb = min ( [ num , num3 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> numb = num <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> num = num - 1 <NEWLINE> <NL> <DEDENT> if dis < dis2 : <NEWLINE> <INDENT> print ( numa ) <NEWLINE> <DEDENT> elif dis == dis2 : <NEWLINE> <INDENT> print ( numb ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( numb ) <NEWLINE> <DEDENT>
<COMMENT> <NL> x , n = map ( int , input ( ) . split ( ) ) <NEWLINE> aa = 0 <NEWLINE> if n == 0 : <NEWLINE> <INDENT> aa = 1 <NEWLINE> <DEDENT> if aa == 0 : <NEWLINE> <INDENT> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> p . sort ( ) <NEWLINE> i = 0 <NEWLINE> flg = 0 <NEWLINE> dis = [ ] <NEWLINE> while flg == 0 : <NEWLINE> <INDENT> if i > 100 : <NEWLINE> <INDENT> flg = 1 <NEWLINE> <DEDENT> if i in p : <NEWLINE> <INDENT> dis . append ( 5000 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dis . append ( abs ( x - i ) ) <NEWLINE> <DEDENT> i += 1 <NEWLINE> <DEDENT> for i in dis : <NEWLINE> <INDENT> if dis [ i ] == min ( dis ) : <NEWLINE> <INDENT> print ( i ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( x ) <NEWLINE> <DEDENT>
a , b = input ( ) . split ( ) <NEWLINE> pp = input ( ) . split ( ) <NEWLINE> a = int ( a ) <NEWLINE> b = int ( b ) <NEWLINE> p = [ ] <NEWLINE> for pa in pp : <NEWLINE> <INDENT> p . append ( int ( pa ) ) <NEWLINE> <DEDENT> x = 0 <NEWLINE> y = - 1 <NEWLINE> while : <NEWLINE> <INDENT> if a + x not in p : <NEWLINE> <INDENT> aa = a + x <NEWLINE> break <NEWLINE> <DEDENT> elif a + y not in p : <NEWLINE> <INDENT> aa = a + y <NEWLINE> break <NEWLINE> <DEDENT> x += 1 <NEWLINE> y += - 1 <NEWLINE> <DEDENT> print ( aa ) <NEWLINE>
x , n = map ( int , input ( ) . split ( ) ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> print ( x ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> P = list ( map ( int , input ( ) . split ( ) ) <NEWLINE> for i in range ( 0 , 102 ) : <NEWLINE> <INDENT> if x - i not in P or x + i not in P : <NEWLINE> <INDENT> if x - i not in P : <NEWLINE> <INDENT> print ( x - i ) <NEWLINE> exit ( 0 ) <NEWLINE> <DEDENT> if x + i not in P : <NEWLINE> <INDENT> print ( x + i ) <NEWLINE> exit ( 0 ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT>
s = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> t = 0 <NEWLINE> h = 0 <NEWLINE> a = s . pop ( 0 ) <NEWLINE> b = s . pop ( 0 ) <NEWLINE> print ( a ) <NEWLINE> print ( b ) <NEWLINE> d = 0 <NEWLINE> if b == 0 : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( a + 1 , a + 2 + b ) : <NEWLINE> <INDENT> c = 1 <NEWLINE> for k in range ( 0 , b ) : <NEWLINE> <INDENT> if i == s [ k ] : <NEWLINE> <INDENT> c = 0 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if c == 1 : <NEWLINE> <INDENT> t = i <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> for i in range ( a - 1 , a - 2 - b , - 1 ) : <NEWLINE> <INDENT> c = 1 <NEWLINE> for k in range ( 0 , b ) : <NEWLINE> <INDENT> if i == s [ k ] : <NEWLINE> <INDENT> c = 0 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if c == 1 : <NEWLINE> <INDENT> h = i <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if abs ( t - a ) >= abs ( h - a ) : <NEWLINE> <INDENT> print ( h ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( t ) <NEWLINE> <DEDENT> <DEDENT>
for i in range ( 100 ) : <NEWLINE> <INDENT> plus_abs = X + i <NEWLINE> minus_abs = X - i <NEWLINE> <NL> for j in range ( N ) : <NEWLINE> <INDENT> if plus_abs == int ( list2 [ j ] ) : <NEWLINE> <INDENT> plus_abs = 1000 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> for k in range ( N ) : <NEWLINE> <INDENT> if minus_abs == int ( list2 [ k ] ) : <NEWLINE> <INDENT> minus_abs = 1000 <NEWLINE> <NL> <DEDENT> <DEDENT> if plus_abs != 1000 or minus_abs != 1000 : <NEWLINE> <INDENT> if plus_abs >= minus_abs : <NEWLINE> <INDENT> result = minus_abs <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> result = plus_abs <NEWLINE> <NL> <DEDENT> print ( result ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT>
x , n = map ( int , input ( ) . split ( ) ) <NEWLINE> r = [ i - x for i in map ( int , input ( ) ) ] <NEWLINE> for i in range ( 100 ) : <NEWLINE> <INDENT> if not - ( i + 1 ) in r : <NEWLINE> <INDENT> print ( x - i - 1 ) <NEWLINE> break <NEWLINE> <DEDENT> elif not i + 1 in r : <NEWLINE> <INDENT> print ( x + i + 1 ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT>
x , n = map ( int , input ( ) . split ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if n == 0 : <NEWLINE> <INDENT> print ( x ) <NEWLINE> <NL> <DEDENT> p = set ( p ) <NEWLINE> else : <NEWLINE> <INDENT> _x = x <NEWLINE> x_ = x <NEWLINE> while True : <NEWLINE> <INDENT> _x -= 1 <NEWLINE> x_ += 1 <NEWLINE> if _x not in p : <NEWLINE> <INDENT> print ( _x ) <NEWLINE> break <NEWLINE> <DEDENT> if x_ not in p : <NEWLINE> <INDENT> print ( x_ ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
try : <NEWLINE> <INDENT> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> p = [ ] <NEWLINE> <NL> <NL> <DEDENT> l = [ 0 ] * 100 <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> l [ abs ( p [ i ] - X ) ] += 1 <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> if N == 0 : <NEWLINE> <INDENT> print ( X ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( N ) : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> if l [ 0 ] == 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( X ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if l [ i ] == 0 : <NEWLINE> <INDENT> print ( X - i ) <NEWLINE> break <NEWLINE> <DEDENT> elif l [ i ] == 1 : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> p_index = p . index ( X - i ) <NEWLINE> print ( X + i ) <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> print ( X - i ) <NEWLINE> <DEDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT>
X , N = map ( int , input ( ) . split ( ) ) <NEWLINE> num_list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if ( len ( num_list ) == 0 ) or X not in num_list : <NEWLINE> <INDENT> print ( X ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d = 1 <NEWLINE> while True : <NEWLINE> if X - d not in num_list : <NEWLINE> <INDENT> print ( X - d ) <NEWLINE> break <NEWLINE> elif X + d not in num_list : <NEWLINE> print ( X + d ) <NEWLINE> break <NEWLINE> else : <NEWLINE> d += 1 <NEWLINE> <DEDENT> <DEDENT>
X , N = map ( int , input ( ) . split ( ) ) <NEWLINE> LP = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> LP . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> <DEDENT> if N == 0 : <NEWLINE> <INDENT> print ( X ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( 100 ) : <NEWLINE> <INDENT> ans = X - i <NEWLINE> if ans not in LP : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dans = X + i <NEWLINE> if dans not in LP : <NEWLINE> <INDENT> print ( dans ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT>
X , N = map ( int , input ( ) . split ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> dif = 1 <NEWLINE> <NL> if ( X not in p ) : <NEWLINE> <INDENT> print ( X ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> while True : <NEWLINE> <INDENT> if ( X - dif not in p ) : <NEWLINE> <INDENT> dif = dif * ( - 1 ) <NEWLINE> break <NEWLINE> <DEDENT> elif ( X + dif not in p ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dif = dif + 1 <NEWLINE> print ( X + dif ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> from queue import Queue <NEWLINE> from queue import LifoQueue as Stack <NEWLINE> from math import sqrt , floor , ceil , log2 , log10 , pi <NEWLINE> from fractions import gcd <NEWLINE> from itertools import permutations , combinations <NEWLINE> from operator import itemgetter <NEWLINE> from functools import cmp_to_key <NEWLINE> <NL> <NL> INF = 1001001001 <NEWLINE> __MOD__ = ( 10 ** 9 ) + 7 <NEWLINE> yn = <STRING> <NEWLINE> judge = False <NEWLINE> cnt = 0 <NEWLINE> ans = None <NEWLINE> <NL> <NL> def lcm ( a , b ) : <NEWLINE> <INDENT> return ( a * b ) // gcd ( a , b ) <NEWLINE> <NL> <DEDENT> def intinput ( ) : <NEWLINE> <INDENT> return int ( input ( ) ) <NEWLINE> <NL> <DEDENT> def mulinputs ( ) : <NEWLINE> <INDENT> return map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <DEDENT> def lineinputs ( func = intinput ) : <NEWLINE> <INDENT> datas = [ ] <NEWLINE> while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> datas . append ( func ( ) ) <NEWLINE> <DEDENT> except EOFError : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> return datas <NEWLINE> <NL> <DEDENT> class ModInt ( ) : <NEWLINE> <INDENT> def __init__ ( self , x ) : <NEWLINE> <INDENT> self . __x = ( x % __MOD__ ) <NEWLINE> <DEDENT> def __add__ ( self , other ) : <NEWLINE> <INDENT> if type ( other ) == int : <NEWLINE> <INDENT> other = self . __class__ ( other ) <NEWLINE> return int ( self . __class__ ( ( self . __x + other . __x ) % __MOD__ ) ) <NEWLINE> <DEDENT> elif type ( other ) == ModInt : <NEWLINE> <INDENT> return self . __class__ ( ( self . __x + other . __x ) % __MOD__ ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> raise Exception ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> def __radd__ ( self , other ) : <NEWLINE> <INDENT> if type ( other ) == int : <NEWLINE> <INDENT> other = self . __class__ ( other ) <NEWLINE> return int ( self . __class__ ( ( other . __x + self . __x ) % __MOD__ ) ) <NEWLINE> <DEDENT> elif type ( other ) == ModInt : <NEWLINE> <INDENT> return self . __class__ ( ( other . __x + self . __x ) % __MOD__ ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> raise Exception ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> def __sub__ ( self , other ) : <NEWLINE> <INDENT> if type ( other ) == int : <NEWLINE> <INDENT> other = self . __class__ ( other ) <NEWLINE> return int ( self . __class__ ( ( self . __x - other . __x ) % __MOD__ ) ) <NEWLINE> <DEDENT> elif type ( other ) == ModInt : <NEWLINE> <INDENT> return self . __class__ ( ( self . __x - other . __x ) % __MOD__ ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> raise Exception ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> def __rsub__ ( self , other ) : <NEWLINE> <INDENT> if type ( other ) == int : <NEWLINE> <INDENT> other = self . __class__ ( other ) <NEWLINE> return int ( self . __class__ ( ( other . __x - self . __x ) % __MOD__ ) ) <NEWLINE> <DEDENT> elif type ( other ) == ModInt : <NEWLINE> <INDENT> return self . __class__ ( ( other . __x - self . __x ) % __MOD__ ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> raise Exception ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> def __mul__ ( self , other ) : <NEWLINE> <INDENT> if type ( other ) == int : <NEWLINE> <INDENT> other = self . __class__ ( other ) <NEWLINE> return int ( self . __class__ ( ( self . __x * other . __x ) % __MOD__ ) ) <NEWLINE> <DEDENT> elif type ( other ) == ModInt : <NEWLINE> <INDENT> return self . __class__ ( ( self . __x * other . __x ) % __MOD__ ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> raise Exception ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> def __rmul__ ( self , other ) : <NEWLINE> <INDENT> if type ( other ) == int : <NEWLINE> <INDENT> other = self . __class__ ( other ) <NEWLINE> return int ( self . __class__ ( ( other . __x * self . __x ) % __MOD__ ) ) <NEWLINE> <DEDENT> elif type ( other ) == ModInt : <NEWLINE> <INDENT> return self . __class__ ( ( other . __x * self . __x ) % __MOD__ ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> raise Exception ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> def __truediv__ ( self , other ) : <NEWLINE> <INDENT> if type ( other ) == int : <NEWLINE> <INDENT> other = self . __class__ ( other ) <NEWLINE> return int ( self . __class__ ( ( self . __x * other . __modinv ( ) ) % __MOD__ ) ) <NEWLINE> <DEDENT> elif type ( other ) == ModInt : <NEWLINE> <INDENT> return self . __class__ ( ( self . __x * other . __modinv ( ) ) % __MOD__ ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> raise Exception ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> def __rtruediv__ ( self , other ) : <NEWLINE> <INDENT> if type ( other ) == int : <NEWLINE> <INDENT> other = self . __class__ ( other ) <NEWLINE> return int ( self . __class__ ( ( other . __x * self . __modinv ( ) ) % __MOD__ ) ) <NEWLINE> <DEDENT> elif type ( other ) == ModInt : <NEWLINE> <INDENT> return self . __class__ ( ( other . __x * self . __modinv ( ) ) % __MOD__ ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> raise Exception ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> def __pow__ ( self , other ) : <NEWLINE> <INDENT> if type ( other ) == int : <NEWLINE> <INDENT> other = self . __class__ ( other ) <NEWLINE> return int ( self . __class__ ( pow ( self . __x , other . __x , __MOD__ ) ) ) <NEWLINE> <DEDENT> elif type ( other ) == ModInt : <NEWLINE> <INDENT> return self . __class__ ( pow ( self . __x , other . __x , __MOD__ ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> raise Exception ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> def __rpow__ ( self , other ) : <NEWLINE> <INDENT> if type ( other ) == int : <NEWLINE> <INDENT> other = self . __class__ ( other ) <NEWLINE> return int ( self . __class__ ( pow ( other . __x , self . __x , __MOD__ ) ) ) <NEWLINE> <DEDENT> elif type ( other ) == ModInt : <NEWLINE> <INDENT> return self . __class__ ( pow ( other . __x , self . __x , __MOD__ ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> raise Exception ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> def __modinv ( self , m = __MOD__ ) : <NEWLINE> <INDENT> a = self . __x <NEWLINE> if a == 0 : <NEWLINE> <INDENT> raise ZeroDivisionError ( ) <NEWLINE> <DEDENT> if gcd ( a , m ) != 1 : <NEWLINE> <INDENT> raise Exception ( <STRING> % a ) <NEWLINE> <DEDENT> b , u , v = m , 1 , 0 <NEWLINE> while b != 0 : <NEWLINE> <INDENT> t = a // b ; <NEWLINE> a -= t * b <NEWLINE> a , b = b , a <NEWLINE> u -= t * v <NEWLINE> u , v = v , u <NEWLINE> <DEDENT> u %= m <NEWLINE> if u < 0 : <NEWLINE> <INDENT> u += m <NEWLINE> <DEDENT> return u <NEWLINE> <DEDENT> def __int__ ( self ) : <NEWLINE> <INDENT> return self . __x <NEWLINE> <DEDENT> def __str__ ( self ) : <NEWLINE> <INDENT> return str ( self . __x ) <NEWLINE> <NL> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> X , N = mulinputs ( ) <NEWLINE> ps = set ( mulinputs ( ) ) <NEWLINE> <NL> mins = [ [ ] for _ in range ( 100 ) ] <NEWLINE> <NL> m = INF <NEWLINE> for p in range ( 1 , 101 ) : <NEWLINE> <INDENT> if p in ps : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> tmp = abs ( X - p ) <NEWLINE> if tmp < m : <NEWLINE> <INDENT> m = tmp <NEWLINE> mins [ m ] . append ( p ) <NEWLINE> <DEDENT> elif tmp == m : <NEWLINE> <INDENT> mins [ m ] . append ( p ) <NEWLINE> <NL> <DEDENT> <DEDENT> mins [ m ] . sort ( ) <NEWLINE> <COMMENT> <NL> if mins [ m ] is not None : <NEWLINE> <INDENT> print ( mins [ m ] [ 0 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( X ) <NEWLINE> <DEDENT> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i in range ( n + 1 ) : <NEWLINE> <INDENT> for x in [ 1 , - 1 ] : <NEWLINE> <INDENT> y = n + x * i <NEWLINE> if y not in a : <NEWLINE> <INDENT> print ( y ) <NEWLINE> exit ( 1 ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
X , N = map ( int , input ( ) . split ( ) ) <NEWLINE> if N == 0 : <NEWLINE> <INDENT> print ( X ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> X_u = X - 1 <NEWLINE> X_l = X + 1 <NEWLINE> while judge : <NEWLINE> <INDENT> X_u += 1 <NEWLINE> X_l -= 1 <NEWLINE> if X_u not in p and X_l not in p : <NEWLINE> <INDENT> print ( X_l ) <NEWLINE> break <NEWLINE> <DEDENT> elif X_u not in p : <NEWLINE> <INDENT> print ( X_u ) <NEWLINE> break <NEWLINE> <DEDENT> elif X_l not in p : <NEWLINE> <INDENT> print ( X_l ) <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if X_u == X_l : <NEWLINE> <INDENT> p . remove ( X_u ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> p . remove ( X_u ) <NEWLINE> p . remove ( X_l ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT>
s = [ ] <NEWLINE> x , n = map ( int , input ( ) . split ( ) ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> print ( x ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> s = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> slist = sorted ( s ) <NEWLINE> <NL> for i in range ( 0 , 1000 ) : <NEWLINE> <INDENT> for j in range ( n ) : <NEWLINE> <INDENT> if slist [ j ] == x - i : <NEWLINE> <INDENT> flaga = 1 <NEWLINE> <DEDENT> if slist [ j ] == x + i : <NEWLINE> <INDENT> flagb = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if flaga = 1 and flagb = 1 : <NEWLINE> <INDENT> flaga = 0 <NEWLINE> flagb = 0 <NEWLINE> <DEDENT> elif flagb == 0 : <NEWLINE> <INDENT> print ( x - i ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> elif flaga == 0 : <NEWLINE> <INDENT> print ( x + i ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> li = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> count = 0 <NEWLINE> <NL> for i in range ( 100 ) : <NEWLINE> <INDENT> for j in range ( n ) : <NEWLINE> <INDENT> if i == j : pass <NEWLINE> elif li [ i ] % li [ j ] == 0 : break <NEWLINE> elif j == n - 1 : count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
x , n = map ( int , input ( ) . split ( ) ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i in b : <NEWLINE> <INDENT> a [ i ] = 1 <NEWLINE> <DEDENT> t = 1 <NEWLINE> ans = 0 <NEWLINE> while 1 : <NEWLINE> <INDENT> if x - t not in b : <NEWLINE> <INDENT> ans = x - t <NEWLINE> break <NEWLINE> <DEDENT> if x + t not in b : <NEWLINE> <INDENT> ans = x + t <NEWLINE> break <NEWLINE> <DEDENT> t += 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
x , n = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ ] <NEWLINE> if n != 0 : a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> tmp = 114514 <NEWLINE> ret = - 114514 <NEWLINE> for i in range ( - 10 , 110 ) : <NEWLINE> <INDENT> if not i in a and abs ( x - i ) < tmp <NEWLINE> ret = i <NEWLINE> tmp = abs ( x - i ) <NEWLINE> <DEDENT> print ( ret ) <NEWLINE>
x , n = map ( int , input ( ) . split ( ) ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> print ( x ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> l1 = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> l2 = list ( range ( 1 , 100 ) ) <NEWLINE> diff = set ( l1 ) ^ set ( l2 ) <NEWLINE> diff = list ( diff ) <NEWLINE> def sorting ( numbers_array ) : <NEWLINE> return sorted ( numbers_array , key = abs ) <NEWLINE> <NL> sl = map ( lambda a : a - x , diff ) <NEWLINE> print ( sorting ( sl ) [ 0 ] ) <NEWLINE> <DEDENT>
if n == 0 : <NEWLINE> <INDENT> print ( x ) <NEWLINE> quit ( ) <NEWLINE> <DEDENT> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if x not in p : <NEWLINE> <INDENT> print ( x ) <NEWLINE> quit ( ) <NEWLINE> <DEDENT> p . sort ( ) <NEWLINE> ans = [ ] <NEWLINE> <COMMENT> <NL> for i in range ( p [ 0 ] , p [ - 1 ] + 1 ) : <NEWLINE> <INDENT> if i not in p : <NEWLINE> <INDENT> ans . append ( i ) <NEWLINE> <DEDENT> <DEDENT> ans . append ( 100000000 ) <NEWLINE> for i in range ( len ( ans ) ) : <NEWLINE> <INDENT> if ans [ i ] > x : <NEWLINE> <INDENT> if abs ( x - ans [ max ( i - 1 , 0 ) ] ) <= abs ( x - ans [ i ] ) : <NEWLINE> <INDENT> print ( ans [ max ( i - 1 , 0 ) ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans [ i ] ) <NEWLINE> <DEDENT> quit ( ) <NEWLINE> <DEDENT> <DEDENT>
import numpy as np <NEWLINE> x , n = map ( int , input ( ) . split ( ) ) <NEWLINE> num_list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> num_list = sorted ( num_list ) <NEWLINE> num_100 = list ( range ( 1 , 101 ) ) <NEWLINE> <NL> for num in num_list : <NEWLINE> <INDENT> numbers = num_100 . remove ( num ) <NEWLINE> <NL> <DEDENT> numbers1 = np . array ( numbers ) <NEWLINE> numbers2 = numbers - x <NEWLINE> numbers3 = np . abs ( numbers ) <NEWLINE> min_index = numbers . argmin ( ) <NEWLINE> print ( numbers1 [ min_index ] ) <NEWLINE>
x , n = map ( int , input ( ) . split ( ) ) <NEWLINE> lst = [ int ( input ( ) ) for _ in range ( n ) ] <NEWLINE> a = 100 <NEWLINE> b = 0 <NEWLINE> <NL> for i in range ( 1 , 102 ) : <NEWLINE> <INDENT> if i in lst : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <DEDENT> if a > abs ( x - i ) : <NEWLINE> <INDENT> a = abs ( x - i ) <NEWLINE> b = i <NEWLINE> <NL> <DEDENT> <DEDENT> print ( i ) <NEWLINE>
x , n = map ( int , input ( ) . split ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> flg = false <NEWLINE> t = x <NEWLINE> while flg == False : <NEWLINE> <INDENT> if t in l : <NEWLINE> <INDENT> t -= 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = t <NEWLINE> flg = True <NEWLINE> <DEDENT> <DEDENT> flg = False <NEWLINE> t = x <NEWLINE> while flg == False : <NEWLINE> <INDENT> if t in l : <NEWLINE> <INDENT> t += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if abs ( x - ans ) > abs ( x - t ) : <NEWLINE> <INDENT> ans = t <NEWLINE> <DEDENT> flg = True <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = input ( ) . split ( ) <NEWLINE> n = [ int ( i ) for i in n ] <NEWLINE> m = input ( ) . split ( ) <NEWLINE> m = [ int ( i ) for i in m ] <NEWLINE> <NL> ans_1 = n [ 0 ] <NEWLINE> ans_2 = n [ 0 ] <NEWLINE> <NL> ans = [ ] <NEWLINE> while True : <NEWLINE> <INDENT> if n [ 1 ] == 0 : <NEWLINE> <INDENT> ans . append ( 0 ) <NEWLINE> <NL> <DEDENT> ans_1 += 1 <NEWLINE> ans_2 -= 1 <NEWLINE> if not ans_1 in m : <NEWLINE> <INDENT> ans . append ( ans_1 ) <NEWLINE> <NL> <DEDENT> elif not ans_2 in m : <NEWLINE> <INDENT> ans . append ( ans_2 ) <NEWLINE> <NL> <DEDENT> if len ( ans ) > 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( min ( ans ) ) <NEWLINE>
a = input ( ) . split ( ) <NEWLINE> if a [ 1 ] == <STRING> : <NEWLINE> <INDENT> print ( a [ 0 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> number_list = input ( ) . split ( ) <NEWLINE> n = 1 <NEWLINE> number = int ( a [ 0 ] ) <NEWLINE> while True : <NEWLINE> <INDENT> num = number + n <NEWLINE> num2 = number - n <NEWLINE> if str ( num ) not in number_list or str ( num2 ) not in number_list : <NEWLINE> <INDENT> if str ( num ) in number_list : <NEWLINE> <INDENT> print ( num2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( num1 ) <NEWLINE> <DEDENT> break <NEWLINE> <DEDENT> n += 1 <NEWLINE> <DEDENT> <DEDENT>
x , N = map ( int , input ( ) . split ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> min = 10000 <NEWLINE> temp = 0 <NEWLINE> <NL> for i in range ( - 1000 , 1000 ) : <NEWLINE> <INDENT> temp = abs ( X - i ) <NEWLINE> <NL> if temp < min and i not in p : <NEWLINE> <INDENT> min = temp <NEWLINE> <NL> <DEDENT> <DEDENT> print ( min ) <NEWLINE>
x , n = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if n == 0 : <NEWLINE> <INDENT> print ( x ) <NEWLINE> <DEDENT> p = list ( range ( n ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> p_2 = list ( range ( n ) ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> p_2 [ i ] = x - p [ i ] <NEWLINE> <NL> <DEDENT> for i in range ( 100 ) : <NEWLINE> <INDENT> h = p_2 . count ( i ) <NEWLINE> h_2 = p_2 . count ( - i ) <NEWLINE> if h == 0 and h_2 != 0 : <NEWLINE> <INDENT> print ( x - i ) <NEWLINE> break <NEWLINE> elif h != 0 and h_2 == 0 : <NEWLINE> print ( x + i ) <NEWLINE> break <NEWLINE> <DEDENT> elif h == 0 and h_2 == 0 : <NEWLINE> <INDENT> print ( x - i ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT>
X , N = map ( int , input ( ) . split ( ) ) <NEWLINE> p = [ ] <NEWLINE> if N > 0 : <NEWLINE> <INDENT> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> L = [ abs ( X - i ) for i in P ] <NEWLINE> l = min ( L ) <NEWLINE> if X - l in P : <NEWLINE> <INDENT> print ( X - l ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( X + l ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( X ) <NEWLINE> <DEDENT>
x , n = map ( int , input ( ) . split ( ) ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> print ( x ) <NEWLINE> <DEDENT> if n != 0 : <NEWLINE> <INDENT> i = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> <NL> <DEDENT> if x not in i : <NEWLINE> <INDENT> print ( x ) <NEWLINE> break <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> p = 1 <NEWLINE> while True : <NEWLINE> <INDENT> z = x - p <NEWLINE> if z not in i : <NEWLINE> <INDENT> print ( z ) <NEWLINE> break <NEWLINE> <NL> <DEDENT> z = x + p <NEWLINE> if z not in i : <NEWLINE> <INDENT> print ( z ) <NEWLINE> break <NEWLINE> <NL> <DEDENT> p = p + 1 <NEWLINE> <DEDENT> <DEDENT>
X , N = map ( int , input ( ) . split ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> i = 0 <NEWLINE> <NL> if X not in p : <NEWLINE> <INDENT> print ( X ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> while True : <NEWLINE> <INDENT> i += 1 <NEWLINE> if X - i not in p : <NEWLINE> <INDENT> print ( X - i ) <NEWLINE> <DEDENT> if X + i not in p : <NEWLINE> <INDENT> print ( X + i ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
import numpy as np <NEWLINE> x , n = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if n == 0 : <NEWLINE> <INDENT> print ( x ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> P = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> l = list ( range ( 2 * x ) ) <NEWLINE> result = list ( set ( l ) - set ( P ) ) <NEWLINE> abs = list ( np . abs ( np . array ( result ) - x ) ) <NEWLINE> abs . remove ( 0 ) <NEWLINE> min = min ( abs ) <NEWLINE> print ( abs ) <NEWLINE> print ( result [ abs . index ( min ) ] ) <NEWLINE> <DEDENT>
d = { i : 1 for i in p } <NEWLINE> idx = X <NEWLINE> while True : <NEWLINE> <INDENT> if d . get ( idx ) is None : <NEWLINE> <INDENT> ans_plus = idx <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> idx += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> idx = X <NEWLINE> while True : <NEWLINE> <INDENT> if d . get ( idx ) is None : <NEWLINE> <INDENT> ans_minus = idx <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> idx -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if abs ( X - ans_plus ) < abs ( X - ans_minus ) : <NEWLINE> <INDENT> print ( ans_plus ) <NEWLINE> <DEDENT> elif abs ( X - ans_plus ) > abs ( X - ans_minus ) : <NEWLINE> <INDENT> print ( ans_minus ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans_minus ) <NEWLINE> <DEDENT>
def abc170_c_1 ( ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> def solve ( ) : <NEWLINE> <INDENT> x , n = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> return x <NEWLINE> <NL> <DEDENT> p = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> <NL> search_range_min = min ( min ( p ) , x ) - 1 <NEWLINE> search_range_max = max ( max ( p ) , x ) + 1 <NEWLINE> search_values = [ i for i in range ( search_range_min , search_range_max + 1 ) if i not in p ] <NEWLINE> <NL> <COMMENT> <NL> ans = min ( search_values , key = lambda a : ( abs ( a - x ) ) , x ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> return ans <NEWLINE> <NL> <DEDENT> print ( solve ( ) ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> abc170_c_1 ( ) <NEWLINE> <DEDENT>
X , N = map ( int , input ( ) . split ( ) ) <NEWLINE> if N == 0 : <NEWLINE> <INDENT> print ( X ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if p . count ( X ) == 0 : <NEWLINE> <INDENT> print ( X ) <NEWLINE> exit ( ) <NEWLINE> <NL> <NL> <DEDENT> l = list ( range ( 0 , 102 ) ) <COMMENT> <NEWLINE> flist = [ ] <NEWLINE> for i in range ( len ( l ) ) : <NEWLINE> <INDENT> if p . count ( l [ i ] ) == 0 : <NEWLINE> <INDENT> flist . append ( l [ i ] ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> flist . append ( X ) <NEWLINE> anslist = sorted ( flist ) <NEWLINE> t = anslist . index ( X ) <NEWLINE> <NL> dist1 = anslist [ t ] - anslist [ t - 1 ] <COMMENT> <NEWLINE> dist2 = anslist [ t + 1 ] - anslist [ t ] <COMMENT> <NEWLINE> <INDENT> if dist1 <= dist2 : <NEWLINE> <INDENT> print ( anslist [ t - 1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( anslist [ t + 1 ] ) <NEWLINE> <DEDENT> <DEDENT>
X , N = map ( int , input ( ) . split ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if N == 0 : <NEWLINE> <INDENT> print ( X ) <NEWLINE> break <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( 100 ) : <NEWLINE> if ( X - ( i + 1 ) ) and ( X + i + 1 ) in p : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <DEDENT> elif ( X - i - 1 ) not in p : <NEWLINE> <INDENT> print ( X - i - 1 ) <NEWLINE> break <NEWLINE> <NL> <DEDENT> elif ( X + i + 1 ) not in p : <NEWLINE> <INDENT> print ( X + i + 1 ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT>
X , N = int ( input ( ) . split ( ) ) <NEWLINE> list = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> <NL> min_num = 150 <NEWLINE> <NL> for a in range ( X - N - 2 , X + N + 3 ) : <NEWLINE> <INDENT> counter = 0 <NEWLINE> A = abs ( X - a ) <NEWLINE> for b in list : <NEWLINE> <INDENT> if a == b : <NEWLINE> <INDENT> counter = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> <DEDENT> if counter == 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if A == abs ( X - a ) : <NEWLINE> <INDENT> min_num = ( a , min_num ) <NEWLINE> <DEDENT> elif A > abs ( X - a ) : <NEWLINE> <INDENT> min_num = a <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( min_num ) <NEWLINE>
n , x = map ( int , input ( ) . split ( ) ) <NEWLINE> p = set ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( 1 , 102 ) : <NEWLINE> <INDENT> if i in p : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if i < x : <NEWLINE> <INDENT> ans = i <NEWLINE> <DEDENT> elif x - ans > i - x : <NEWLINE> <INDENT> ans = i <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
X , N = map ( int , input ( ) . split ( ) ) <NEWLINE> P = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> P_sub_abs = [ abs ( i - X ) for i in P ] <NEWLINE> if ( P_sub_abs . count ( 0 ) == 0 ) : <NEWLINE> <INDENT> print ( X ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> for i in range ( 1 , 100 ) : <NEWLINE> <INDENT> if ( P_sub_abs . count ( i ) == 1 ) : <NEWLINE> <INDENT> list = [ X - i , X + i ] <NEWLINE> list . remove ( P [ P_sub_abs . index ( i ) ] ) <NEWLINE> print ( list [ 0 ] ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> elif ( P_sub_abs . count ( i ) == 0 ) : <NEWLINE> <INDENT> print ( X - i ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT>
IN = iter ( Input . split ( <STRING> ) ) . __next__ <NEWLINE> def input ( ) : <NEWLINE> <INDENT> return IN ( ) <NEWLINE> <NL> <COMMENT> <NL> <NL> <DEDENT> x , n = map ( int , input ( ) . split ( ) ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> print ( x ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> P = set ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> d_min = 1000 <NEWLINE> ans = 1000 <NEWLINE> for num in range ( - 1 , 102 ) : <NEWLINE> <INDENT> if num in P : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <DEDENT> d = abs ( x - num ) <NEWLINE> if d < d_min : <NEWLINE> <INDENT> d_min = d <NEWLINE> ans = num <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
if n != 0 : <NEWLINE> <INDENT> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <DEDENT> result = x <NEWLINE> if n != 0 : <NEWLINE> <INDENT> for i in range ( 0 , 1000 ) : <NEWLINE> <INDENT> if not ( x - i ) in p : <NEWLINE> <INDENT> print ( x - i ) <NEWLINE> break <NEWLINE> <DEDENT> if not ( x + i ) in p : <NEWLINE> <INDENT> print ( x + i ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( x ) <NEWLINE> <DEDENT>
X , N , * P = map ( int , open ( 0 ) . read ( ) . split ( ) ) <NEWLINE> if P != [ ] : <NEWLINE> <INDENT> P = sorted ( list ( map ( int , P . split ( ) ) ) , reverse = True ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( X ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> min_diff = 101 <NEWLINE> min_val = 101 <NEWLINE> <NL> if N == 100 : <NEWLINE> <INDENT> if X <= 50 : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = 101 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( 100 , - 1 , - 1 ) : <NEWLINE> <COMMENT> <NL> <INDENT> if not i in P : <NEWLINE> <INDENT> if abs ( X - i ) <= min_diff and min_val > i : <NEWLINE> <INDENT> min_diff = abs ( X - i ) <NEWLINE> min_val = i <NEWLINE> <DEDENT> <DEDENT> <DEDENT> ans = min_val <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
X , N = map ( int , input ( ) . split ( ) ) <NEWLINE> p = list ( input ( ) . split ( ) ) <NEWLINE> <NL> ans_enable = [ True ] * 102 <NEWLINE> for pi in p : <NEWLINE> <INDENT> ans_enable [ pi ] = False <NEWLINE> <NL> <DEDENT> diff = 0 <NEWLINE> <NL> check_ok = ans_enable [ X ] <NEWLINE> <NL> ans_small = True <NEWLINE> <NL> while not check_ok : <NEWLINE> <INDENT> diff += 1 <NEWLINE> if ans_enable [ X - diff ] : <NEWLINE> <INDENT> check_ok = True <NEWLINE> ans_small = True <NEWLINE> <DEDENT> elif ans_enable [ X + diff ] : <NEWLINE> <INDENT> check_ok = True <NEWLINE> ans_small = False <NEWLINE> <NL> <DEDENT> <DEDENT> print ( X - diff if ans_small else X + diff ) <NEWLINE>
import sys <NEWLINE> x , n = map ( int , input ( ) . split ( ) ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> print ( x ) <NEWLINE> exit ( 1 ) <NEWLINE> <DEDENT> p = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> k = 0 <NEWLINE> while x in p : <NEWLINE> <INDENT> if not x - k in p : <NEWLINE> <INDENT> print ( x - k ) <NEWLINE> exit ( 1 ) <NEWLINE> <DEDENT> elif not x + k in p : <NEWLINE> <INDENT> print ( x + k ) <NEWLINE> exit ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> k += 1 <NEWLINE> continue <NEWLINE> <DEDENT> <DEDENT> print ( x ) <NEWLINE>
x , N = map ( int , input ( ) . split ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 101 <NEWLINE> if x in p : <NEWLINE> <INDENT> for i in range ( 102 ) : <NEWLINE> <INDENT> if i in p : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> ans = min ( ans , abs ( p [ i ] - x ) ) <NEWLINE> <DEDENT> if x + ans in p : <NEWLINE> <INDENT> ans *= - 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> print ( x + ans ) <NEWLINE>
x , n = map ( int , input ( ) . split ( ) ) <NEWLINE> P = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> i = 0 <NEWLINE> while True : <NEWLINE> <INDENT> ans = x - i <NEWLINE> if ans in P : <NEWLINE> <INDENT> ans = x + i <NEWLINE> if ans in P : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> break <NEWLINE> <DEDENT> i = i + 1 <NEWLINE> <DEDENT>
x , n = map ( int , input ( ) . split ( ) ) <NEWLINE> p_str = input ( ) . split ( ) <COMMENT> <NEWLINE> list = [ ] <NEWLINE> for i in p_str : <NEWLINE> <INDENT> p = int ( i ) <NEWLINE> list . append ( p ) <NEWLINE> <NL> <DEDENT> if not x in list : <NEWLINE> <INDENT> print ( x ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( 101 ) : <NEWLINE> <INDENT> y = x - i <NEWLINE> if not y in list : <NEWLINE> <INDENT> print ( y ) <NEWLINE> break <NEWLINE> z = x + i <NEWLINE> <DEDENT> if not z in list : <NEWLINE> <INDENT> print ( z ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
if __name__ == <STRING> : <NEWLINE> <COMMENT> <NL> <INDENT> X , N = map ( int , ( input ( ) . split ( <STRING> ) ) ) <NEWLINE> if N > 0 : <NEWLINE> <INDENT> P = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> P_max = max ( P ) <NEWLINE> P_min = min ( P ) <NEWLINE> if X in P : <NEWLINE> <INDENT> for i in range ( 0 , 100 ) : <NEWLINE> <INDENT> if ( X - i ) not in P : <NEWLINE> <INDENT> print ( X - i ) <NEWLINE> break <NEWLINE> <NL> <DEDENT> elif ( X + i ) not in P : <NEWLINE> <INDENT> print ( X + i ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> elif X not in P : <NEWLINE> <INDENT> print ( X ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( X ) <NEWLINE> <DEDENT> <DEDENT>
X , N = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if N != 0 : <NEWLINE> <INDENT> P = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> L = X <NEWLINE> L = X <NEWLINE> for _ in range ( N // 2 ) : <NEWLINE> <INDENT> L = L - 1 <NEWLINE> H = H + 1 <NEWLINE> if L not in P : <NEWLINE> <INDENT> print ( L ) <NEWLINE> break <NEWLINE> <DEDENT> if H not in P : <NEWLINE> <INDENT> print ( H ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( X ) <NEWLINE> <DEDENT>
x , n = map ( int , input ( ) . split ( ) ) <NEWLINE> p = sorted ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if p == [ ] : <NEWLINE> <INDENT> print ( x ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a = p [ - 1 ] <NEWLINE> d = [ ] <NEWLINE> e = 0 <NEWLINE> E = 0 <NEWLINE> b = 1000 <NEWLINE> c = 0 <NEWLINE> for i in range ( a ) : <NEWLINE> <INDENT> d += [ e ] <NEWLINE> e += 1 <NEWLINE> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> d . remove ( p [ E ] ) <NEWLINE> E += 1 <NEWLINE> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> b = min ( ( abs , x - d [ c ] ) , b ) <NEWLINE> c += 1 <NEWLINE> <DEDENT> if ( x - b ) in d : <NEWLINE> <INDENT> print ( x - b ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( x + b ) <NEWLINE> <DEDENT> <DEDENT>
X , N = map ( int , input ( ) . split ( ) ) <NEWLINE> P = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if P . len == 0 : <NEWLINE> <INDENT> print ( X ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( 1 , 100 ) : <NEWLINE> <INDENT> if P . count ( X - i ) == 0 : <NEWLINE> <INDENT> print ( X - i ) <NEWLINE> break <NEWLINE> <DEDENT> elif P . count ( X + 1 ) == 0 : <NEWLINE> <INDENT> print ( X + 1 ) <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> ans = <STRING> <NEWLINE> check = <STRING> <NEWLINE> <NL> while N != 0 : <NEWLINE> <INDENT> N -= 1 <NEWLINE> ans += check [ N % 26 ] <NEWLINE> N = N // 26 <NEWLINE> <NL> <DEDENT> print ( ans [ : : - 1 ] ) <NEWLINE> <STRING> <NEWLINE> <NL> <NL>
x , n = input ( ) . split ( ) <NEWLINE> x , n = int ( x ) , int ( n ) <NEWLINE> <NL> a = input ( ) . split ( ) <NEWLINE> for i in range ( len ( a ) ) : <NEWLINE> <INDENT> a [ i ] = int ( a [ i ] ) <NEWLINE> <NL> <DEDENT> if x not in a : <NEWLINE> <INDENT> print ( x ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> sa = 1 <NEWLINE> while True : <NEWLINE> <INDENT> if x - sa not in a : <NEWLINE> <INDENT> print ( x - sa ) <NEWLINE> break <NEWLINE> <DEDENT> if x + sa not in a : <NEWLINE> <INDENT> print ( x + sa ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
x , n = map ( int , input ( ) . split ( ) ) <NEWLINE> lst = set ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> df = 0 <NEWLINE> while True : <NEWLINE> <INDENT> if not ( x + df ) in lst : print ( x + df ) <NEWLINE> df = - df <NEWLINE> if not ( x + df ) in lst : print ( x + df ) <NEWLINE> df = - df <NEWLINE> df += 1 <NEWLINE> <DEDENT>
XN = input ( ) . split ( ) <NEWLINE> X = int ( XN [ 0 ] ) <NEWLINE> N = int ( XN [ 1 ] ) <NEWLINE> if N == 0 : <NEWLINE> <INDENT> print ( X ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> p = input . split ( ) <NEWLINE> A = [ None ] * N <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> A [ i ] = abs ( int ( p [ i ] ) - X ) <NEWLINE> <DEDENT> j = 0 <NEWLINE> while j in A : <NEWLINE> <INDENT> j += 1 <NEWLINE> <DEDENT> if j == 1 : <NEWLINE> <INDENT> print ( X - j ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if A . count ( j - 1 ) == 2 : <NEWLINE> <INDENT> print ( X - j ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if str ( X - ( j - 1 ) ) in p : <NEWLINE> <INDENT> print ( X + ( j - 1 ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( X - ( j - 1 ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT>
import collections <NEWLINE> x , n = map ( int , input ( ) . split ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> v = collections . Counter ( l ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> print ( x ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( 101 ) : <NEWLINE> <INDENT> if x not in v : <NEWLINE> <INDENT> ans = x <NEWLINE> break <NEWLINE> <NL> <DEDENT> if x + 1 not in v : <NEWLINE> <INDENT> ans = x + 1 <NEWLINE> break <NEWLINE> <DEDENT> if x - 1 not in v : <NEWLINE> <INDENT> ans = x - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT>
( X , N ) = map ( int , input ( ) . split ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if N == 0 : <NEWLINE> <INDENT> print ( X ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range N : <NEWLINE> <INDENT> if ( X - i ) not in p : <NEWLINE> <INDENT> print ( X - i ) <NEWLINE> break <NEWLINE> <DEDENT> elif ( X + i ) not in p : <NEWLINE> <INDENT> print ( X + i ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
X , N = map ( int , input ( ) . split ( ) ) <NEWLINE> p_list = set ( [ int ( i ) for i in input ( ) . split ( ) ] ) <NEWLINE> set_all = set ( np . arange ( - 100 , 101 ) ) <NEWLINE> ex_list = set_all - p_list <NEWLINE> ex_list = list ( ex_list ) <NEWLINE> diff_list = [ np . abs ( i - X ) for i in ex_list ] <NEWLINE> min_index = np . argmin ( diff_list ) <NEWLINE> print ( ex_list [ min_index ] ) <NEWLINE>
X , N = map ( int , input ( ) . split ( ) ) <NEWLINE> if ( N == 0 | | N == 100 ) : <NEWLINE> <INDENT> print ( X ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> p . sort ( ) <NEWLINE> q = list ( range ( 1 , max ( p ) + 1 ) ) <NEWLINE> <NL> for i in p : <NEWLINE> <INDENT> q . remove ( i ) <NEWLINE> <NL> <DEDENT> Z = 1000 <NEWLINE> ans = - 1 <NEWLINE> for i in q : <NEWLINE> <INDENT> if ( abs ( X - i ) < Z ) : <NEWLINE> <INDENT> Z = abs ( X - i ) <NEWLINE> ans = i <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
import sys <NEWLINE> import os <NEWLINE> f = open ( <STRING> , <STRING> ) <NEWLINE> sys . stdin = f <NEWLINE> <NL> X , N = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> if N == 0 : <NEWLINE> <INDENT> print ( X ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> P_ls = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> diff , rst = - 1 , 0 <NEWLINE> for i in range ( 101 , - 1 , - 1 ) : <NEWLINE> <INDENT> if i not in P_ls : <NEWLINE> <INDENT> if diff == - 1 : <NEWLINE> <INDENT> diff = abs ( X - i ) <NEWLINE> rst = i <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> diff = min ( diff , abs ( X - i ) ) <NEWLINE> if diff == abs ( X - i ) : <NEWLINE> <INDENT> rst = i <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( rst ) <NEWLINE> <DEDENT>
x , n = ( int ( x ) for x in input ( ) . split ( ) ) <NEWLINE> p = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> <NL> result = 100 <NEWLINE> <NL> l = list ( range ( 0 , 6 ) ) <NEWLINE> <NL> <NL> <NL> if len ( p ) == 0 : <NEWLINE> <INDENT> kotae = x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( len ( p ) ) : <NEWLINE> <NL> <INDENT> l [ p [ i ] ] = 200 <NEWLINE> <NL> <NL> <DEDENT> for i in reversed ( range ( len ( l ) ) ) : <NEWLINE> <NL> <NL> <NL> <INDENT> if l [ i ] != 200 : <NEWLINE> <NL> <INDENT> if result >= abs ( l [ i ] - x ) : <NEWLINE> <INDENT> result = abs ( l [ i ] - x ) <NEWLINE> <NL> kotae = l [ i ] <NEWLINE> <NL> <NL> <NL> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( kotae ) <NEWLINE>
X , N = map ( int , input ( ) . split ( ) ) <NEWLINE> P = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <COMMENT> <NL> all_l = [ i for i in range ( 0 , 101 ) ] <NEWLINE> <NL> <COMMENT> <NL> for p in P : <NEWLINE> <INDENT> all_l . remove ( p ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> kouho = x <NEWLINE> for i in range ( 200 ) : <NEWLINE> <INDENT> kouho1 = x - i <NEWLINE> kouho2 = x + i <NEWLINE> if kouho1 not in P : <NEWLINE> <INDENT> print ( x - i ) <NEWLINE> break <NEWLINE> <DEDENT> elif kouho2 not in P : <NEWLINE> <DEDENT>
class int ( int ) : <NEWLINE> <INDENT> def times ( self , callback ) : <NEWLINE> <INDENT> for times in range ( 0 , self ) : <NEWLINE> <INDENT> callback ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> class list ( list ) : <NEWLINE> <INDENT> def maps ( self , callback ) : <NEWLINE> <INDENT> return list ( map ( callback , self ) ) <NEWLINE> <NL> <DEDENT> def each ( self , callback ) : <NEWLINE> <INDENT> list ( map ( callback , self ) ) <NEWLINE> return self <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> def each_with_index ( self , callback ) : <NEWLINE> <INDENT> list ( map ( callback , self , range ( 0 , len ( self ) ) ) ) <NEWLINE> return self <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> target , length = input ( ) . split ( ) <NEWLINE> target = int ( target ) <NEWLINE> length = int ( length ) <NEWLINE> nums = list ( input ( ) . split ( ) ) <NEWLINE> <NL> def convert ( arg ) : <NEWLINE> <INDENT> return int ( arg ) <NEWLINE> <DEDENT> nums = nums . maps ( convert ) <NEWLINE> <NL> for i in range ( 0 , 101 ) : <NEWLINE> <COMMENT> <NL> <INDENT> a = target - i <COMMENT> <NEWLINE> if a not in num : <NEWLINE> <INDENT> print ( a ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> b = target + i <COMMENT> <NEWLINE> if b not in nums : <NEWLINE> <INDENT> print ( b ) <NEWLINE> exit ( ) <NEWLINE> <NL> <COMMENT> <NL> <NEWLINE> <DEDENT> <DEDENT>
ans = None <NEWLINE> for r in range ( 100 ) : <NEWLINE> <INDENT> for i in [ - r , r ] : <NEWLINE> <INDENT> if ( X + i ) not in p : <NEWLINE> <INDENT> ans = X + i <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if ans is not None : <NEWLINE> <INDENT> break <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
X , N = map ( int , input ( ) . split ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if N == 0 : <NEWLINE> <INDENT> print ( X ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for k in range ( 0 , 51 ) : <NEWLINE> <INDENT> if not X - k in p : <NEWLINE> <INDENT> print ( X - k ) <NEWLINE> break <NEWLINE> <DEDENT> elif not X + k in p_list : <NEWLINE> <INDENT> print ( X + k ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
X , N = map ( int , input ( ) . split ( ) ) <NEWLINE> P = map ( list , int ( input . split ( ) ) ) <NEWLINE> direction = - 1 <NEWLINE> i = 0 <NEWLINE> while True : <NEWLINE> <INDENT> dist = i * direction <NEWLINE> <NL> if not ( dist + X in P ) : <NEWLINE> <INDENT> print ( dist + X ) <NEWLINE> break <NEWLINE> <DEDENT> i += 1 <NEWLINE> if direction < 0 : direction = 1 <NEWLINE> else : direction = - 1 <NEWLINE> <DEDENT>
<COMMENT> <NL> x , n = int ( input ( ) ) . split ( ) <NEWLINE> p = int ( [ ] ) . split ( ) <NEWLINE> length = len ( p ) <NEWLINE> <NL> <COMMENT> <NL> def closestnum ( p , length ) : <NEWLINE> <INDENT> return p [ min ( range ( length ) ) ] <NEWLINE> <COMMENT> <NL> <DEDENT> for x not in p : <NEWLINE> <INDENT> print ( round ( closestnum ( p , length ) ) ) <NEWLINE> <NL> <NL> <DEDENT>
import sys <NEWLINE> if n == 0 : <NEWLINE> <INDENT> print ( x ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> x , n = map ( int , input ( ) . split ( ) ) <NEWLINE> lst = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i in range ( 250 ) : <NEWLINE> <INDENT> if x - i not in lst : <NEWLINE> <INDENT> print ( x + i ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> if x + i not in lst : <NEWLINE> <INDENT> print ( x + i ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT>
x , n = map ( int , input ( ) . split ( ) ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> print ( x ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> flag = 0 <NEWLINE> i = 0 <NEWLINE> while flag == 0 : <NEWLINE> <INDENT> continueflag = 0 <NEWLINE> for j in a : <NEWLINE> <INDENT> if j == x - i : <NEWLINE> <INDENT> continueflag = 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if continueflag == 0 : <NEWLINE> <INDENT> print ( x - i ) <NEWLINE> break <NEWLINE> <NL> <DEDENT> for j in a : <NEWLINE> <INDENT> if j == x + i : <NEWLINE> <INDENT> continueflag = 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if continueflag == 0 : <NEWLINE> <INDENT> print ( x + i ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> i = i + 1 <NEWLINE> <NL> <DEDENT>
X , N = map ( int , input ( ) . split ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for d in range ( X + 1 ) : <NEWLINE> <INDENT> for s in [ - 1 , + 1 ] : <NEWLINE> <INDENT> a = X + s * d <NEWLINE> <DEDENT> <DEDENT> if p . count ( a ) == 0 : <NEWLINE> print ( a ) <NEWLINE> exit ( 0 ) <NEWLINE>
X , N = map ( int , input ( ) . split ( ) ) <NEWLINE> if N == 0 : <NEWLINE> <INDENT> print ( X ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> P = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i in range ( 1 , 102 ) : <NEWLINE> <INDENT> if ( X - i ) not in P : <NEWLINE> <INDENT> print ( X - i ) <NEWLINE> break <NEWLINE> <DEDENT> elif ( X + i ) not in P : <NEWLINE> <INDENT> print ( X + i ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( X ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT>
def serch_1 ( b , x ) : <NEWLINE> <INDENT> i = 1 <NEWLINE> an = 0 <NEWLINE> while 1 : <NEWLINE> <INDENT> if b . count ( x + i ) == 0 : <NEWLINE> <INDENT> an = x + i <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> i = i + 1 <NEWLINE> <DEDENT> <DEDENT> return an <NEWLINE> <NL> <DEDENT> def serch_2 ( b , x ) : <NEWLINE> <INDENT> i = 1 <NEWLINE> an = 0 <NEWLINE> while 1 : <NEWLINE> <INDENT> if b . count ( x - i ) == 0 : <NEWLINE> <INDENT> an = x - i <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> i = i + 1 <NEWLINE> <DEDENT> <DEDENT> return an <NEWLINE> <DEDENT> def hikaku ( a , b , x ) : <NEWLINE> <INDENT> if abs ( a - x ) >= abs ( b - x ) : <NEWLINE> <INDENT> return b <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return a <NEWLINE> <DEDENT> <DEDENT> x = int ( input ( ) ) <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> print ( serch_1 ( a , x ) , serch_2 ( a , x ) ) <NEWLINE> if a . count ( x ) == 0 : <NEWLINE> <INDENT> print ( x ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( hikaku ( serch_1 ( a , x ) , serch_2 ( a , x ) , x ) ) <NEWLINE> <NL> <DEDENT>
class int ( int ) : <NEWLINE> <INDENT> def times ( self , callback ) : <NEWLINE> <INDENT> for times in range ( 0 , self ) : <NEWLINE> <INDENT> callback ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> class list ( list ) : <NEWLINE> <INDENT> def maps ( self , callback ) : <NEWLINE> <INDENT> return list ( map ( callback , self ) ) <NEWLINE> <NL> <DEDENT> def each ( self , callback ) : <NEWLINE> <INDENT> list ( map ( callback , self ) ) <NEWLINE> return self <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> def each_with_index ( self , callback ) : <NEWLINE> <INDENT> list ( map ( callback , self , range ( 0 , len ( self ) ) ) ) <NEWLINE> return self <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> target , length = input ( ) . split ( ) <NEWLINE> target = int ( target ) <NEWLINE> length = int ( length ) <NEWLINE> nums = list ( input ( ) . split ( ) ) <NEWLINE> <NL> def convert ( arg ) : <NEWLINE> <INDENT> return int ( arg ) <NEWLINE> <DEDENT> nums = nums . maps ( convert ) <NEWLINE> <NL> for i in range ( 0 , 101 ) : <NEWLINE> <INDENT> a = target - i <NEWLINE> if a not in nums : <NEWLINE> <INDENT> print ( a ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> a = target + u <NEWLINE> if b not in nums : <NEWLINE> <INDENT> print ( b ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT>
from _typeshed import ReadableBuffer <NEWLINE> import sys <NEWLINE> def LI ( ) : return list ( map ( int , sys . stdin . buffer . readline ( ) . split ( ) ) ) <NEWLINE> def I ( ) : return int ( sys . stdin . buffer . readline ( ) ) <NEWLINE> def LS ( ) : return sys . stdin . buffer . readline ( ) . rstrip ( ) . decode ( <STRING> ) . split ( ) <NEWLINE> def S ( ) : return sys . stdin . buffer . readline ( ) . rstrip ( ) . decode ( <STRING> ) <NEWLINE> def IR ( n ) : return [ I ( ) for i in range ( n ) ] <NEWLINE> def LIR ( n ) : return [ LI ( ) for i in range ( n ) ] <NEWLINE> def SR ( n ) : return [ S ( ) for i in range ( n ) ] <NEWLINE> def LSR ( n ) : return [ LS ( ) for i in range ( n ) ] <NEWLINE> def SRL ( n ) : return [ list ( S ( ) ) for i in range ( n ) ] <NEWLINE> def MSRL ( n ) : return [ [ int ( j ) for j in list ( S ( ) ) ] for i in range ( n ) ] <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> X , N = LI ( ) <NEWLINE> P = LI ( ) . sort ( ) <NEWLINE> <NL> <COMMENT> <NL> <NL> if N == 0 : <NEWLINE> <INDENT> print ( X ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> elif ( X not in P ) and ( N != 0 ) : <NEWLINE> <INDENT> print ( X ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> while X in P : <NEWLINE> <INDENT> X = X - 1 <NEWLINE> <DEDENT> print ( X ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT>
X , N = input ( ) . split ( ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( 1 , 102 ) : <NEWLINE> <INDENT> if abs ( X - i ) < abs ( ans - i ) and i not in p and i != X : <NEWLINE> <INDENT> ans = i <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
X , N = map ( int , input ( ) . split ( ) ) <NEWLINE> P = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> table = [ 0 ] * 102 <NEWLINE> ans = X <NEWLINE> dist = 102 <NEWLINE> <NL> for p in range ( P ) : <NEWLINE> <INDENT> table [ p ] = 1 <NEWLINE> <NL> <DEDENT> for i in range ( 102 ) : <NEWLINE> <INDENT> if table [ i ] == 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if abs ( i - X ) < dist : <NEWLINE> <INDENT> ans = i <NEWLINE> dist = abs ( i - X ) <NEWLINE> <DEDENT> elif abs ( i - X ) == dist : <NEWLINE> <INDENT> ans = min ( i , ans ) <NEWLINE> <DEDENT> <DEDENT>
<INDENT> x , n = map ( int , input ( ) . split ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 9999999999 <NEWLINE> lists = [ ] <NEWLINE> if n == 0 : <NEWLINE> <INDENT> print ( x ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> for i in range ( - 1000 , 1000 ) : <NEWLINE> <INDENT> if not i in p : <NEWLINE> <INDENT> lists . append ( i ) <NEWLINE> <DEDENT> <DEDENT> for i in lists : <NEWLINE> <INDENT> if ans > abs ( x - i ) : <NEWLINE> <INDENT> ans = abs ( x - i ) <NEWLINE> m = i <NEWLINE> <NL> <DEDENT> <DEDENT> print ( m ) <NEWLINE> <DEDENT>
import math <NEWLINE> <NL> X , N = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <COMMENT> <NL> <NL> if N == 0 : <NEWLINE> <INDENT> print ( X ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> if X < minimum or maximum < X : <NEWLINE> <INDENT> print ( X ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> answer = 1 <NEWLINE> for candidate in range ( 1 , 100 + 1 ) : <NEWLINE> <INDENT> if candidate in p : continue <NEWLINE> <NL> diff_candidate = abs ( X - candidate ) <NEWLINE> diff_answer = abs ( X - answer ) <NEWLINE> <NL> if diff_candidate == diff_answer : <NEWLINE> <INDENT> answer = min ( candidate , answer ) <NEWLINE> <DEDENT> elif diff_candidate < diff_answer : <NEWLINE> <INDENT> answer = candidate <NEWLINE> <NL> <DEDENT> <DEDENT> print ( answer ) <NEWLINE>
xn = input ( ) . split ( ) <NEWLINE> data = input ( ) . split ( ) <NEWLINE> data_2 = [ ] <NEWLINE> <NL> x = xn [ 0 ] <COMMENT> <NEWLINE> data . sort ( ) <COMMENT> <NEWLINE> <NL> <COMMENT> <NL> <NL> a = x - 1 <NEWLINE> while True : <NEWLINE> <COMMENT> <NL> <INDENT> for i in range ( len ( data ) ) : <NEWLINE> <INDENT> if data [ i ] == a : <NEWLINE> <INDENT> a = a - 1 <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> data_2 . append ( a ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if a == data_2 [ 0 ] : <NEWLINE> <INDENT> break <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> b = x + 1 <NEWLINE> while True : <NEWLINE> <COMMENT> <NL> <INDENT> for i in range ( len ( data ) ) : <NEWLINE> <INDENT> if data [ i ] == a : <NEWLINE> <INDENT> a = a + 1 <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> data_2 . append ( a ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if b == data_2 [ 1 ] : <NEWLINE> <INDENT> break <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> if a < b : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( b ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <COMMENT> <NL> X , N = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if N == 0 : <NEWLINE> <INDENT> print ( X ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> arr = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> mainasu = X <NEWLINE> purasu = X <NEWLINE> <NL> def saiki ( ) : <NEWLINE> <INDENT> mainasu - 1 <NEWLINE> purasu + 1 <NEWLINE> if X in arr : <NEWLINE> <INDENT> if mainasu in arr : <NEWLINE> <INDENT> if purasu in arr : <NEWLINE> <INDENT> saiki ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( purasu ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( mainasu ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( X ) <NEWLINE> <NL> <DEDENT> <DEDENT> saiki ( ) <NEWLINE>
X , N = map ( int , input ( ) . split ( ) ) <NEWLINE> if N == 0 : <NEWLINE> <INDENT> print ( X ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> p . sort ( ) <NEWLINE> <NL> diff_1 = abs ( X - p [ - 1 ] ) <NEWLINE> diff_2 = abs ( X - p [ 0 ] ) <NEWLINE> diff = max ( diff_1 , diff_2 ) <NEWLINE> <NL> for x in range ( 0 , diff + 1 ) : <NEWLINE> <INDENT> if X - x not in p <NEWLINE> <INDENT> print ( X - x ) <NEWLINE> break <NEWLINE> <DEDENT> if X + x not in p <NEWLINE> <INDENT> print ( X + x ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
x , n = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> p = [ int ( input ( ) ) for i in range ( n ) ] <NEWLINE> s = 1000000000 <NEWLINE> <NL> for i in range ( 1 , 101 ) : <NEWLINE> <INDENT> if i in p : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> s = min ( abs ( x - i ) , s ) <NEWLINE> <NL> <NL> <DEDENT> if not x - s in p : <NEWLINE> <INDENT> print ( x - s ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( x + s ) <NEWLINE> <DEDENT>
x , n = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a . append ( input ( ) ) <NEWLINE> <DEDENT> c = - 1 <NEWLINE> b = 0 <NEWLINE> d = 101 <NEWLINE> e = 0 <NEWLINE> for w in range ( 103 ) : <NEWLINE> <INDENT> if c not in a : <NEWLINE> <INDENT> b = abs ( x - c ) <NEWLINE> if b < d : <NEWLINE> <INDENT> d = b <NEWLINE> e = c <NEWLINE> c += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> c += 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> c += 1 <NEWLINE> <DEDENT> <DEDENT> print ( e ) <NEWLINE>
P = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> P = sorted ( P ) <NEWLINE> x = bisect_left ( P , X ) <NEWLINE> if x >= len ( P ) : <NEWLINE> <INDENT> print ( X ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> if P [ x ] != X : <NEWLINE> <INDENT> print ( X ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> A = X <NEWLINE> B = X <NEWLINE> while True : <NEWLINE> <INDENT> A -= 1 <NEWLINE> B += 1 <NEWLINE> x1 = bisect_left ( P , A ) <NEWLINE> x2 = bisect_left ( P , B ) <NEWLINE> <NL> if x1 < len ( P ) and P [ x1 ] != A : <NEWLINE> <INDENT> print ( A ) <NEWLINE> break <NEWLINE> <NL> <DEDENT> if x2 < len ( P ) and P [ x2 ] != B : <NEWLINE> <INDENT> print ( B ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> x , n = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if ( n == 0 ) : <NEWLINE> <INDENT> print ( x ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> a = [ i for i in range ( - 110 , 210 ) ] <NEWLINE> <NL> for j in p : <NEWLINE> <INDENT> d = a . index ( j ) <NEWLINE> a . pop ( d ) <NEWLINE> <NL> <DEDENT> a . append ( x ) <NEWLINE> a = set ( a . sort ( ) ) <NEWLINE> <NL> idx_x = a . index ( x ) <NEWLINE> <NL> if ( idx_x == 0 ) : <NEWLINE> <INDENT> print ( a [ idx_x + 1 ] ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> if ( idx_x == len ( a ) - 1 ) : <NEWLINE> <INDENT> print ( a [ - 2 ] ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> lesser = a [ idx_x - 1 ] <NEWLINE> greater = a [ idx_x + 1 ] <NEWLINE> <NL> dl = abs ( x - lesser ) <NEWLINE> dg = abs ( greater - x ) <NEWLINE> <NL> if ( dl <= dg ) : <NEWLINE> <INDENT> print ( lesser ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( greater ) <NEWLINE> <DEDENT>
x , n = map ( int , input ( ) split ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i in range ( 101 ) : <NEWLINE> <INDENT> if x - i not in p : <NEWLINE> <INDENT> print ( x - i ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> elif x + i not in p : <NEWLINE> <INDENT> print ( x + i ) <NEWLINE> <DEDENT> exit ( ) <NEWLINE> <DEDENT>
X , N = map ( int , input ( ) . split ( ) ) <NEWLINE> P = [ int ( input ( ) ) for i in range ( N ) ] <NEWLINE> <NL> L = sorted ( [ abs ( X - p ) for p in P ] ) <NEWLINE> if 0 not in L : <NEWLINE> <INDENT> print ( X ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> DL = list ( set ( [ x for x in L if L . count ( x ) > 1 ] ) ) <NEWLINE> <NL> ans_abs = 1 <NEWLINE> for i , x in enumerate ( DL ) : <NEWLINE> <INDENT> if x == i + 1 : <NEWLINE> <INDENT> ans_abs += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> if X - ans_abs in P : <NEWLINE> <INDENT> print ( X + ans_abs ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( X - ans_abs ) <NEWLINE> <DEDENT>
x , n = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if not n : <NEWLINE> <INDENT> print ( x ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> dic = { } <NEWLINE> for ll in l : dic [ ll ] = 1 <NEWLINE> i = 0 <NEWLINE> while true : <NEWLINE> <INDENT> if not dic . get ( x - i , 0 ) : <NEWLINE> <INDENT> print ( x - i ) <NEWLINE> break <NEWLINE> <DEDENT> elif not dic . get ( x + i , 0 ) : <NEWLINE> <INDENT> print ( x + i ) <NEWLINE> break <NEWLINE> <DEDENT> i += 1 <NEWLINE> <DEDENT> <DEDENT>
import numpy as np <NEWLINE> <COMMENT> <NL> <NL> def getVar ( ) : <NEWLINE> <INDENT> return map ( int , input ( ) . split ( ) ) <NEWLINE> <DEDENT> def getArray ( ) : <NEWLINE> <INDENT> return np . array ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> <DEDENT> ( X , N ) = getVar ( ) <NEWLINE> p = getArray ( ) <NEWLINE> <NL> if ( len ( p ) == 0 ) : <NEWLINE> <INDENT> print ( X ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> subp = p - X <NEWLINE> i = 0 <NEWLINE> while ( True ) : <NEWLINE> <INDENT> if ( not i in subp ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> print ( X - i ) <NEWLINE> <DEDENT>
X , N = map ( int , input ( ) . split ( ) ) <NEWLINE> P = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> value = float ( <STRING> ) <NEWLINE> if ( N == 0 ) : <NEWLINE> <INDENT> print ( X ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> ans_value = 100 <NEWLINE> for i in range ( - 1 , 102 ) : <NEWLINE> <INDENT> if ( i not in P ) : <NEWLINE> <INDENT> if ( abs ( X - i ) < value ) : <NEWLINE> <INDENT> value = abs ( X - i ) <NEWLINE> ans_value = i <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans_value ) <NEWLINE> <NL> X , N = map ( int , input ( ) . split ( ) ) <NEWLINE> P = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> value = float ( <STRING> ) <NEWLINE> if ( N == 0 ) : <NEWLINE> <INDENT> print ( X ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> ans_value = 100 <NEWLINE> for i in range ( - 1 , 102 ) : <NEWLINE> <INDENT> if ( i not in P ) : <NEWLINE> <INDENT> if ( abs ( X - i ) < value ) : <NEWLINE> <INDENT> value = abs ( X - i ) <NEWLINE> ans_value = i <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans_value ) <NEWLINE> <NL>
x , n = map ( int , input ( ) . split ( ) ) <NEWLINE> a = set ( map , int ( input ( ) . split ( ) ) ) <NEWLINE> print ( min ( [ i for i in range ( 102 ) if i not in a ] , key = lambda y : abs ( x - y ) ) ) <NEWLINE>
from sys import stdin <NEWLINE> X , Y = [ int ( x ) for x in stdin . readline ( ) . rstrip ( ) . split ( ) ] <NEWLINE> P = [ int ( x ) for x in stdin . readline ( ) . rstrip ( ) . split ( ) ] <NEWLINE> tmp = 10 ** 9 + 7 <NEWLINE> P = set ( list ( range ( 0 , 101 ) ) ) - set ( P ) <NEWLINE> P . sort ( reverse = True ) <NEWLINE> <NL> <NL> ans = 0 <NEWLINE> for i in P : <NEWLINE> <INDENT> if abs ( i - X ) <= tmp : <NEWLINE> <INDENT> ans = i <NEWLINE> tmp = abs ( i - X ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if b > 0 : <NEWLINE> <INDENT> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( a ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> n = a <NEWLINE> m = a <NEWLINE> <NL> for i in range ( b ) : <NEWLINE> <INDENT> print ( n ) <NEWLINE> print ( m ) <NEWLINE> print ( <STRING> ) <NEWLINE> if n in p : a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> <DEDENT> if b > 0 : <NEWLINE> <INDENT> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( a ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> n = a <NEWLINE> m = a <NEWLINE> <NL> for i in range ( b ) : <NEWLINE> <INDENT> if n in p : <NEWLINE> <INDENT> n = n - 1 <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> if n < 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> print ( n ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> if m in p : <NEWLINE> <INDENT> m = m + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( m ) <NEWLINE> exit ( ) <NEWLINE> <NL> <NL> <NL> n = n - 1 <NEWLINE> if n < 1 : <NEWLINE> <INDENT> n = 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( n ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> if m in p : <NEWLINE> <INDENT> m = m + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( m ) <NEWLINE> exit ( ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT>
n , x = map ( int , input ( ) . split ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> p = 0 <NEWLINE> if x == 0 : <NEWLINE> <INDENT> print ( n ) <NEWLINE> <DEDENT> elif n not in l : <NEWLINE> <INDENT> print ( n ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( 101 ) : <NEWLINE> <INDENT> if abs ( x - i ) > abs ( x - p ) and i not in p : <NEWLINE> <INDENT> p = i <NEWLINE> <DEDENT> <DEDENT> print ( p ) <NEWLINE> <DEDENT>
X , N = map ( int , input ( ) . split ( ) ) <NEWLINE> * P , = map ( int , input ( ) . split ( ) ) <NEWLINE> cand = set ( range ( 101 ) ) - set ( P ) <NEWLINE> ans , temp = None , 10 ** 10 <NEWLINE> for c in cand : <NEWLINE> <INDENT> t = abs ( X - c ) <NEWLINE> if t < temp : <NEWLINE> <INDENT> temp = t ; ans = min ( ans , c ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import collections <NEWLINE> x , n = map ( int , input ( ) . split ( ) ) <NEWLINE> P = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> PX = list ( map ( lambda p : p - x , P ) ) <NEWLINE> CPX = collections . Counter ( PX ) <NEWLINE> ans = 0 <NEWLINE> <NL> for i in range ( 100 ) : <NEWLINE> <INDENT> elif CPX [ - i ] == 0 : <NEWLINE> <INDENT> ans = x - i <NEWLINE> break <NEWLINE> <DEDENT> elif CPX [ i ] == 0 : <NEWLINE> <INDENT> ans = x + i <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
num_input = [ input ( ) for i in range ( 2 ) ] <NEWLINE> x = int ( num_input [ 0 ] . split ( ) [ 0 ] ) <NEWLINE> n = int ( num_input [ 0 ] . split ( ) [ 1 ] ) <NEWLINE> <NL> num_list = [ int ( n ) for n in num_input [ 1 ] . split ( ) ] <NEWLINE> num_list . sort ( ) <NEWLINE> <NL> ans = x <NEWLINE> <NL> if n != 0 and n != 1 and n != 100 : <NEWLINE> <INDENT> if x in num_list : <NEWLINE> <INDENT> index = num_list . index ( x ) <NEWLINE> <NL> value_left = x - 1 <NEWLINE> value_right = x + 1 <NEWLINE> <NL> if index != 0 : <NEWLINE> <INDENT> index_left = index - 1 <NEWLINE> <DEDENT> if index != n - 1 : <NEWLINE> <INDENT> index_right = index + 1 <NEWLINE> <NL> <DEDENT> if index == 0 : <NEWLINE> <INDENT> ans = x - 1 <NEWLINE> <DEDENT> elif index == n - 1 : <NEWLINE> <INDENT> if num_list [ index - 1 ] == x - 1 : <NEWLINE> <INDENT> ans = x + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = x - 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( n ) : <NEWLINE> <INDENT> if num_list [ index_left ] != value_left : <NEWLINE> <INDENT> ans = value_left <NEWLINE> break <NEWLINE> <DEDENT> elif num_list [ index_right ] != value_right : <NEWLINE> <INDENT> ans = value_right <NEWLINE> break <NEWLINE> <DEDENT> if index_left != 0 : <NEWLINE> <INDENT> index_left = index_left - 1 <NEWLINE> <DEDENT> if index_right != n : <NEWLINE> <INDENT> index_right = index_right + 1 <NEWLINE> <DEDENT> value_left = value_left - 1 <NEWLINE> value_right = value_right + 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if n == 1 <NEWLINE> <INDENT> ans = x - 1 <NEWLINE> <NL> <DEDENT> if n == 100 : <NEWLINE> <INDENT> if x <= 50 : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> if x > 50 : <NEWLINE> <INDENT> ans = 101 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> <NL> X , N = ( int ( x ) for x in input ( ) . split ( ) ) <NEWLINE> if N != 0 : <NEWLINE> <INDENT> p = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( X ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> i = 0 <NEWLINE> ans = X <NEWLINE> flag = False <NEWLINE> while True : <NEWLINE> <INDENT> if X + i in p : continue <NEWLINE> ans = X + i <NEWLINE> flag = True <NEWLINE> if X - i in p : continue <NEWLINE> ans = X - i <NEWLINE> flag = True <NEWLINE> if flag : break <NEWLINE> i += 1 <NEWLINE> <DEDENT> pritn ( ans ) <NEWLINE>
x , n = map ( int , input ( ) . split ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if n == 0 : <NEWLINE> <INDENT> ans = x <NEWLINE> <NL> <DEDENT> d = float ( <STRING> ) <NEWLINE> <NL> for i in range ( n + 1 ) : <NEWLINE> <INDENT> tmpx = x + 1 + n // 2 - i <NEWLINE> if not tmpx in p : <NEWLINE> <INDENT> tmpd = abs ( x - tmpx ) <NEWLINE> if d >= tmpd : <NEWLINE> <INDENT> d = tmpd <NEWLINE> if ans >= tmpx : <NEWLINE> <INDENT> ans = tmpx <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL>
def resolve ( ) : <NEWLINE> <INDENT> X , N = map ( int , input ( ) . split ( ) ) <NEWLINE> P = [ int ( input ( ) ) for _ in range ( N ) ] <NEWLINE> if X in P : <NEWLINE> <INDENT> for j in range ( N ) : <NEWLINE> <INDENT> if X + j in P : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( X + j ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> if X - j in P : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( X - j ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( X ) <NEWLINE> <DEDENT> <DEDENT> resolve ( ) <NEWLINE>
X , N = map ( int , input ( ) . split ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if N == 0 : <NEWLINE> <INDENT> print ( X ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for k in range ( 0 , 58 ) : <NEWLINE> <INDENT> if not X - k in p : <NEWLINE> <INDENT> print ( X - k ) <NEWLINE> break <NEWLINE> <DEDENT> elif not X + k in p_list : <NEWLINE> <INDENT> print ( X + k ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
<COMMENT> <NL> X , N = map ( int , input ( ) . split ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A = list ( range ( 1 , X + 1 ) ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> A . remove ( p [ i ] ) <NEWLINE> <NL> <DEDENT> D = 101 <NEWLINE> ans = 0 <NEWLINE> for j in range ( len ( A ) ) : <NEWLINE> <INDENT> if D >= abs ( X - A [ j ] ) : <NEWLINE> <INDENT> D = abs ( X - A [ j ] ) <NEWLINE> ans = A [ j ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
def inp ( ) : <NEWLINE> <INDENT> ls = set ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> return ls <NEWLINE> <DEDENT> x , n = map ( int , input ( ) . split ( ) ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> print ( x ) <NEWLINE> exit ( 0 ) <NEWLINE> <DEDENT> ls = inp ( ) <NEWLINE> ls . sort ( ) <NEWLINE> ans = 0 <NEWLINE> d = float ( <STRING> ) <NEWLINE> for i in range ( 1 , 102 ) : <NEWLINE> <INDENT> if i in ls : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> tmp = abs ( x - i ) <NEWLINE> if tmp < d : <NEWLINE> <INDENT> d = tmp <NEWLINE> ans = i <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<NL> X , N = map ( int , input ( ) . split ( ) ) <NEWLINE> if N != 0 : <NEWLINE> <INDENT> P = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> for diff in range ( 0 , 102 ) : <NEWLINE> <INDENT> if X - diff not in P : <NEWLINE> <INDENT> print ( X - diff ) <NEWLINE> break <NEWLINE> <DEDENT> elif X + diff not in P : <NEWLINE> <INDENT> print ( X + diff ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( N ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> X , N = map ( int , input ( ) . split ( ) ) <NEWLINE> if N != 0 : <NEWLINE> <INDENT> P = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> for diff in range ( 0 , 102 ) : <NEWLINE> <INDENT> if X - diff not in P : <NEWLINE> <INDENT> print ( X - diff ) <NEWLINE> break <NEWLINE> <DEDENT> elif X + diff not in P : <NEWLINE> <INDENT> print ( X + diff ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( X ) <NEWLINE> <DEDENT>
X , N = map ( int , input ( ) . split ( ) ) <NEWLINE> if N > 0 : <NEWLINE> <INDENT> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A = [ 0 ] * N <NEWLINE> ok == 0 <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> A [ i ] = abs ( l [ i ] - X ) <NEWLINE> <NL> <DEDENT> S = A . count ( 0 ) <NEWLINE> if S == 0 : <NEWLINE> <INDENT> print ( X ) <NEWLINE> ok = 1 <NEWLINE> <NL> <DEDENT> if ok == 0 : <NEWLINE> <INDENT> for i in range ( 1 , 101 ) : <NEWLINE> <INDENT> S = A . count ( i ) <NEWLINE> if S == 0 : <NEWLINE> <INDENT> print ( X - 1 ) <NEWLINE> break <NEWLINE> <DEDENT> if S == 1 : <NEWLINE> <INDENT> if l . count ( X - i ) == 0 : <NEWLINE> <INDENT> print ( X - i ) <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( X + i ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> pass <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( X ) <NEWLINE> <DEDENT>
x , n , * a = map ( int , open ( 0 ) . read ( ) . split ( ) ) <NEWLINE> b = [ 1 ] * 101 <NEWLINE> for i in a : <NEWLINE> <INDENT> b [ i ] = 0 <NEWLINE> <DEDENT> c = 1000 <NEWLINE> ans = n <NEWLINE> for i in range ( 102 ) : <NEWLINE> <INDENT> if b [ i ] and c > abs ( x - i ) : <NEWLINE> <INDENT> c = abs ( x - i ) <NEWLINE> ans = i <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
X , N = map ( int , input ( ) . split ( ) ) <NEWLINE> if N != 0 : <NEWLINE> <INDENT> plist = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> print ( plist ) <NEWLINE> <COMMENT> <NL> maxN = 100 <NEWLINE> Anslist = [ i for i in range ( X + 1 ) ] <NEWLINE> <COMMENT> <NL> for i in range ( len ( plist ) ) : <NEWLINE> <INDENT> Anslist . remove ( plist [ i ] ) <NEWLINE> <DEDENT> Anslist . remove ( 0 ) <NEWLINE> <COMMENT> <NL> <NL> ans = 0 <NEWLINE> min = 100 <NEWLINE> for i in range ( len ( Anslist ) ) : <NEWLINE> <INDENT> if min > abs ( X - Anslist [ i ] ) : <NEWLINE> <INDENT> min = abs ( X - Anslist [ i ] ) <NEWLINE> ans = Anslist [ i ] <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <DEDENT> else : print ( X ) <NEWLINE>
X , N = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> if N == 0 : <NEWLINE> <INDENT> print ( X ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> p = input ( ) . split ( <STRING> ) <NEWLINE> p = [ int ( i ) for i in p ] <NEWLINE> if X not in p : <NEWLINE> <INDENT> print ( X ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> num_list = [ int ( i ) for i in range ( 102 ) ] <NEWLINE> [ num_list . remove ( p [ i ] ) for i in range ( N ) ] <NEWLINE> tmp = [ 0 ] * int ( len ( num_list ) ) <NEWLINE> <NL> <NL> for i in range ( len ( num_list ) ) : <NEWLINE> <INDENT> tmp [ i ] = abs ( num_list [ i ] - X ) <NEWLINE> <NL> <DEDENT> ans = tmp . index ( min [ tmp ] ) <NEWLINE> <NL> print ( num_list [ ans ] ) <NEWLINE>
from sys import exit <NEWLINE> <NL> x , n = map ( int , input ( ) . split ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for d in range ( x + 1 ) : <COMMENT> <NEWLINE> <INDENT> for d in [ - 1 , 1 ] : <NEWLINE> <INDENT> a = x + i * s <NEWLINE> if not a in p : <NEWLINE> <INDENT> print ( a ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> using namespace std ; <NEWLINE> <NL> int main ( ) { <NEWLINE> <INDENT> int X , N ; cin >> X >> N ; <NEWLINE> if ( N == 0 ) { cout << X << endl ; return 0 ; } <NEWLINE> vector < int > p ( N ) ; <NEWLINE> rep ( i , 0 , N ) cin >> p [ i ] ; <NEWLINE> sort ( p . begin ( ) , p . end ( ) ) ; <NEWLINE> int ans = 0 ; <NEWLINE> int check = INT_MAX ; <NEWLINE> rep_eq ( i , p [ 0 ] , p [ N - 1 ] ) { <NEWLINE> <INDENT> bool check_flag = true ; <NEWLINE> rep ( j , 0 , N ) { <NEWLINE> <INDENT> if ( i == p [ j ] ) { check_flag = false ; break ; } <NEWLINE> <DEDENT> } <NEWLINE> if ( check_flag ) { <NEWLINE> <INDENT> if ( abs ( X - i ) < check ) { check = abs ( X - i ) ; ans = i ; } <NEWLINE> <DEDENT> } <NEWLINE> <DEDENT> } <NEWLINE> cout << ans << endl ; <NEWLINE> return 0 ; <NEWLINE> <DEDENT> } <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> x , n = map ( int , input ( ) . split ( ) ) <NEWLINE> p_lst = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if n == 0 : <NEWLINE> <INDENT> minimum = x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if x not in p_lst : <NEWLINE> <INDENT> minimum = x <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> lst = [ ] <NEWLINE> flag = False <NEWLINE> <NL> while True : <NEWLINE> <INDENT> x1 = x <NEWLINE> x2 = x <NEWLINE> x1 += 1 <NEWLINE> x2 -= 1 <NEWLINE> <NL> if x1 not in p_lst : <NEWLINE> <INDENT> lst . append ( x1 ) <NEWLINE> flag = True <NEWLINE> <DEDENT> if x2 not in p_lst : <NEWLINE> <INDENT> lst . append ( x2 ) <NEWLINE> flag = True <NEWLINE> <NL> <DEDENT> if flag : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> minimum = min ( lst ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( minimum ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
X , N = map ( int , input ( ) . split ( ) ) <NEWLINE> if not N == 0 : <NEWLINE> <INDENT> p_l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <DEDENT> if N == 0 : <NEWLINE> <INDENT> print ( X ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> a = b = X <NEWLINE> while True : <NEWLINE> <INDENT> if a in p_l and b in p_l : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if not a in p_l : <NEWLINE> <INDENT> if not b in p_l : <NEWLINE> <INDENT> if a > b : <NEWLINE> <INDENT> print ( b ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( a ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( a ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> elif not b in p_l : <NEWLINE> <INDENT> if not a in p_l : <NEWLINE> <INDENT> if a > b : <NEWLINE> <INDENT> print ( b ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( a ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( b ) <NEWLINE> <DEDENT> a += 1 <NEWLINE> b -= 1 <NEWLINE> <DEDENT>
x , n = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in range ( x + 1 ) : <NEWLINE> <INDENT> for s in [ - 1 , + 1 ] : <NEWLINE> <INDENT> a = x + s * d <NEWLINE> if a not in p : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
X , N = map ( int , input ( ) . split ( ) ) <NEWLINE> P = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> sortP = sorted ( P ) <NEWLINE> if N == 0 : <NEWLINE> <INDENT> print ( X ) <NEWLINE> <DEDENT> elif sortP [ 0 ] > X : <NEWLINE> <INDENT> print ( sortP [ 0 ] - 1 ) <NEWLINE> <DEDENT> elif sortP [ N - 1 ] < X : <NEWLINE> <INDENT> print ( sortP [ N - 1 ] + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for n in range ( sortP [ 0 ] , sortP [ N - 1 ] + 2 ) : <NEWLINE> <INDENT> if n in sortP : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if n == X : <NEWLINE> <INDENT> print ( X ) <NEWLINE> <DEDENT> elif n > X : <NEWLINE> <INDENT> if X - a <= n - X : <NEWLINE> <INDENT> print ( a ) <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( n ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> a = n <NEWLINE> <DEDENT> <DEDENT>
X , N = map ( int , input ( ) . split ( ) ) <NEWLINE> if N == 0 : <NEWLINE> <INDENT> print ( X ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> if N == 0 : <NEWLINE> <INDENT> print ( X ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> if p . count ( X ) == 0 : <NEWLINE> <INDENT> print ( X ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> for a in range ( 1000 ) : <NEWLINE> <INDENT> if p . count ( X - a ) == 0 : <NEWLINE> <INDENT> print ( X - a ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> elif p . count ( X + a ) == 0 : <NEWLINE> <INDENT> print ( X + a ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> x , n = map ( int , input ( ) . split ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . strip ( ) . split ( ) ) ) <NEWLINE> print ( p ) <NEWLINE> ans = 0 <NEWLINE> if n == 0 : <NEWLINE> <INDENT> print ( x ) <NEWLINE> <DEDENT> elif x not in p : <NEWLINE> <INDENT> print ( x ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( 102 ) : <NEWLINE> <INDENT> if i not in p : <NEWLINE> if abs ( x - i ) < abs ( x - ans ) : <NEWLINE> <INDENT> ans = i <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = set ( a ) <NEWLINE> for i in range ( 101 ) : <NEWLINE> <NL> <INDENT> if x - i not in a : <NEWLINE> <INDENT> print ( x - i ) <NEWLINE> exit ( ) <NEWLINE> elif x + i not in a : <NEWLINE> print ( x + i ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT>
x , n = map ( int , input ( ) . split ( ) ) <NEWLINE> p = list ( map ( int , inpot ( ) . split ( ) ) ) <NEWLINE> for d in range ( x + 1 ) : <NEWLINE> <INDENT> for s in [ - 1 , + 1 ] : <NEWLINE> <INDENT> a = x + s * d <NEWLINE> if p . count ( a ) == 0 : <NEWLINE> <INDENT> print ( a ) <NEWLINE> exit ( 0 ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
x , n = map ( int , input ( ) . split ( ) ) <NEWLINE> p = list ( map ( int , input . split ( ) ) ) <NEWLINE> i = 0 <NEWLINE> ans = 0 <NEWLINE> while True : <NEWLINE> <INDENT> if ( x - 1 in p ) : <NEWLINE> <INDENT> if ( x + 1 in p ) : <NEWLINE> <INDENT> None <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = x + 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> ans = x - 1 <NEWLINE> break <NEWLINE> <DEDENT> i += 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL>
X , N = map ( int , input ( ) . split ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for d in range ( X + 1 ) : <NEWLINE> <INDENT> for s in [ - 1 , + 1 ] : a = X + s * d <NEWLINE> <INDENT> if p . count ( a ) == 0 : <NEWLINE> <INDENT> print ( a ) <NEWLINE> exit ( 0 ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
import numpy as np <NEWLINE> X , N = map ( int , input ( ) . split ( ) ) <NEWLINE> p = np . array ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> ans = np . array ( [ X , X ] ) <NEWLINE> while True : <NEWLINE> <INDENT> for x in ans : <NEWLINE> if x not in p : <NEWLINE> <INDENT> print ( x ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> ans += [ - 1 , 1 ] <NEWLINE> <NL> <DEDENT>
X , N = map ( int , input ( ) . split ( ) ) <NEWLINE> if N == 0 : <NEWLINE> <INDENT> print ( X ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> P = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> i = 0 <NEWLINE> while 1 : <NEWLINE> <INDENT> for d in [ - 1 , + 1 ] : <NEWLINE> <INDENT> if not X + i * d in P : <NEWLINE> <INDENT> print ( X + i * d ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> i += 1 <NEWLINE> <DEDENT>
x , n = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = x <NEWLINE> judge = True <NEWLINE> if ( n != 0 ) : <NEWLINE> <INDENT> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = x <NEWLINE> judge = False <NEWLINE> <NL> <DEDENT> if ( judge ) : <NEWLINE> <INDENT> check = True <NEWLINE> s_list = [ ] <NEWLINE> l_list = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( n ) : <NEWLINE> <INDENT> if ( x - i == p [ j ] ) : <NEWLINE> <INDENT> check = False <NEWLINE> <DEDENT> <DEDENT> if ( check ) : <NEWLINE> <INDENT> s_list . append ( x - i ) <NEWLINE> <DEDENT> check = True <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( n ) : <NEWLINE> <INDENT> if ( x + i == p [ j ] ) : <NEWLINE> <INDENT> check = False <NEWLINE> <DEDENT> <DEDENT> if ( check ) : <NEWLINE> <INDENT> l_list . append ( x + i ) <NEWLINE> <DEDENT> check = True <NEWLINE> <DEDENT> if ( l_list == [ ] and s_list == [ ] ) : <NEWLINE> <INDENT> ans = x - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if ( abs ( x - min ( l_list ) ) > abs ( x - max ( s_list ) ) ) : <NEWLINE> <INDENT> ans = max ( s_list ) <NEWLINE> <DEDENT> elif ( abs ( x - min ( l_list ) ) == abs ( x - max ( s_list ) ) ) : <NEWLINE> <INDENT> ans = max ( s_list ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = min ( l_list ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
XX , N = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> if N == 0 : <NEWLINE> <INDENT> print ( X ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> p = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> c = - 1 <NEWLINE> for i in range ( 100 ) : <NEWLINE> <INDENT> if i + 1 not in p : <NEWLINE> <INDENT> if abs ( X - ( i + 1 ) ) < abs ( X - c ) : <NEWLINE> <INDENT> c = i + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( c ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT>
temp1 = input ( ) . split ( <STRING> ) <NEWLINE> temp1 = [ int ( i ) for i in temp1 ] <NEWLINE> x = temp1 [ 0 ] <NEWLINE> n = temp1 [ 1 ] <NEWLINE> <NL> if not n == 0 : <NEWLINE> <INDENT> temp2 = input ( ) . split ( <STRING> ) <NEWLINE> temp2 = [ int ( i ) for i in temp2 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> temp2 = [ ] <NEWLINE> <NL> <DEDENT> counter = 1 <NEWLINE> while True : <NEWLINE> <INDENT> if n == 0 : <NEWLINE> <INDENT> print ( x ) <NEWLINE> break <NEWLINE> <NL> <DEDENT> mx = x - counter <NEWLINE> px = x + counter <NEWLINE> <NL> if not mx in pn : <NEWLINE> <INDENT> print ( mx ) <NEWLINE> break <NEWLINE> <DEDENT> if not px in pn : <NEWLINE> <INDENT> print ( px ) <NEWLINE> break <NEWLINE> <NL> <DEDENT> counter += 1 <NEWLINE> <DEDENT>
if N == 0 : <NEWLINE> <INDENT> P = [ ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> P = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> <NL> <DEDENT> for i in range ( 100 ) : <NEWLINE> <INDENT> q = X - i <NEWLINE> if q not in P : <NEWLINE> <INDENT> print ( q ) <NEWLINE> break <NEWLINE> <DEDENT> q = X + i <NEWLINE> if q not in P : <NEWLINE> <INDENT> print ( q ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT>
X , N = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ map ( int , input ( ) . split ( ) ) ] <NEWLINE> a = 0 <NEWLINE> while True : <NEWLINE> <INDENT> if X - a in A : <NEWLINE> <INDENT> if X + a in A : <NEWLINE> a += 1 <NEWLINE> else : <NEWLINE> <INDENT> print ( X + a ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( X - a ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <NL> num = int ( input ( ) ) <NEWLINE> <NL> qm = 1000000000000001 <NEWLINE> <NL> alf = [ chr ( i ) for i in range ( 97 , 97 + 26 ) ] <NEWLINE> <COMMENT> <NL> <NL> ans = [ ] <NEWLINE> f = False <NEWLINE> <NL> for i in reversed ( range ( 12 ) ) : <NEWLINE> <INDENT> if ( num - num // 26 ) // 26 ** i >= 1 : <NEWLINE> <INDENT> f = True <NEWLINE> <NL> <DEDENT> if f : <NEWLINE> <INDENT> ans . append ( alf [ ( num - i ) // 26 ** i - 1 ] ) <NEWLINE> num = num % 26 ** i <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> . join ( ans ) ) <NEWLINE>
x , n = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if n == 0 : <NEWLINE> <INDENT> p = set ( [ ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <DEDENT> p = list ( map ( int , str . split ( ) ) ) <NEWLINE> a = list ( set ( range ( 201 ) ) - set ( p ) ) <NEWLINE> abs_diff = [ abs ( i - x ) for i in a ] <NEWLINE> min_abs_diff = min ( abs_diff ) <NEWLINE> for i , j in zip ( a , abs_diff ) : <NEWLINE> <INDENT> if j == min_abs_diff : <NEWLINE> <INDENT> print ( i ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT>
x , n = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> if n != 0 : <NEWLINE> <NL> <INDENT> p = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> <NL> p_ = [ abs ( x - n ) for n in p ] <NEWLINE> <NL> m_p_ = p_ . index ( min ( p_ ) ) <NEWLINE> <NL> start = p [ m_p_ ] <NEWLINE> <NL> for v in range ( 100 ) : <NEWLINE> <INDENT> a = start - v - 1 <NEWLINE> if a not in p : <NEWLINE> <INDENT> ans = a <NEWLINE> <DEDENT> b = start + v + 1 <NEWLINE> if b not in p : <NEWLINE> <INDENT> if ans > b : <NEWLINE> <INDENT> ans = b <NEWLINE> <DEDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> ans = x <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> X , N = map ( int , input ( ) . split ( ) ) <NEWLINE> if ( N == 0 ) : <NEWLINE> <INDENT> print ( 100 ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> p = list ( map ( int , input ( ) ) ) <NEWLINE> <NL> n_ans = 1 <NEWLINE> sa = 100 <NEWLINE> for k in range ( 1 , 100 , 1 ) : <NEWLINE> <INDENT> if ( k in p ) : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if ( abs ( k - X ) < sa ) : <NEWLINE> <INDENT> n_ans = k <NEWLINE> sa = abs ( k - X ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> print ( n_ans ) <NEWLINE>
x , n = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> <NL> if n = 0 : <NEWLINE> <INDENT> print ( x ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> P = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> <NL> before = x <NEWLINE> after = x <NEWLINE> while True : <NEWLINE> <INDENT> if before not in P : <NEWLINE> <INDENT> print ( before ) <NEWLINE> break <NEWLINE> <DEDENT> elif after not in P : <NEWLINE> <INDENT> print ( after ) <NEWLINE> break <NEWLINE> <DEDENT> before -= 1 <NEWLINE> after += 1 <NEWLINE> <DEDENT>
x , n = map ( int , input ( ) . split ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> table = [ 0 for i in range ( 100 ) ] <NEWLINE> for i in p : <NEWLINE> <INDENT> table [ i - 1 ] = 1 <NEWLINE> <NL> <DEDENT> mx = 10000 <NEWLINE> ans = mx <NEWLINE> dis = mx <NEWLINE> for i in range ( len ( table ) ) : <NEWLINE> <INDENT> idx = 99 - i <NEWLINE> if ( table [ idx ] == 0 ) and ( dis >= abs ( idx + 1 - x ) ) : <NEWLINE> <INDENT> ans = idx + 1 <NEWLINE> dis = abs ( idx + 1 - x ) <NEWLINE> <DEDENT> <DEDENT> if ans == mx : <NEWLINE> <INDENT> if 50 >= x <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 101 ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> input = sys . stdin . readline <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> x , n = map ( int , input ( ) . rstrip ( ) . split ( ) ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> print ( x ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> p = list ( map ( int , input ( ) . rstrip ( ) . split ( ) ) ) <NEWLINE> if x > max ( p ) : <NEWLINE> <INDENT> print ( x ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> p_x = set ( range ( min ( p ) , max ( p ) + 1 ) ) <NEWLINE> p_temp = set ( p ) <NEWLINE> p_diff = p_x - p_temp <NEWLINE> p_temp = list ( p_diff ) . sort ( ) <NEWLINE> p_dir = [ ] <NEWLINE> <NL> <DEDENT> for i in range ( len ( p_temp ) ) : <NEWLINE> <INDENT> p_dir . append ( abs ( p_temp [ i ] - x ) ) <NEWLINE> <DEDENT> print ( p_temp [ p_dir . index ( min ( p_dir ) ) ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
x , n = map ( int , input ( ) . split ( ) ) <NEWLINE> P = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if not P : <NEWLINE> <INDENT> print ( x ) <NEWLINE> exit ( 0 ) <NEWLINE> <DEDENT> for i in range ( x , 102 ) : <NEWLINE> <INDENT> if i not in P : <NEWLINE> <INDENT> upper = i <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> upper = 102 <NEWLINE> <DEDENT> <DEDENT> for i in range ( x , - 1 , - 1 ) : <NEWLINE> <INDENT> if i not in P : <NEWLINE> <INDENT> lower = i <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> lower = 0 <NEWLINE> <DEDENT> <DEDENT> print ( lower if x - lower <= upper - x else upper ) <NEWLINE>
import sys <NEWLINE> x , n = map ( int , input ( ) . split ( ) ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> print ( x ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> if x == 1 : <NEWLINE> <INDENT> print ( 0 ) : <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <NL> <DEDENT> if n == 100 : <NEWLINE> <INDENT> if x <= 50 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 101 ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> nun_list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> answer = 0 <NEWLINE> <NL> for i in range ( 0 , 210 ) : <NEWLINE> <INDENT> if nun_list . __contains__ ( i ) : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if abs ( x - answer ) >= abs ( x - i ) : <NEWLINE> <INDENT> if abs ( x - answer ) == abs ( x - i ) : <NEWLINE> <INDENT> if answer > i : <NEWLINE> <INDENT> answer = i <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> answer = i <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if abs ( x - answer ) <= abs ( x - 0 ) : <NEWLINE> <INDENT> print ( answer ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> a_list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> num_array = np . zeros ( max ( a_list ) , dtype = np . int8 ) <NEWLINE> for a in a_list : <NEWLINE> <INDENT> num_array [ a : : a ] += 1 <NEWLINE> <NL> <DEDENT> count = 0 <NEWLINE> for a in a_list : <NEWLINE> <INDENT> if num_array [ a ] == 1 : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
from sys import stdin <NEWLINE> from sys import setrecursionlimit <NEWLINE> from collections import Counter <NEWLINE> from numba import jit <NEWLINE> <NL> setrecursionlimit ( 10 ** 7 ) <NEWLINE> <NL> n = int ( stdin . readline ( ) . rstrip ( ) ) <NEWLINE> a = list ( map ( int , stdin . readline ( ) . rstrip ( ) . split ( ) ) ) <NEWLINE> a . sort ( ) <NEWLINE> c = Counter ( a ) <NEWLINE> <NL> se = set ( ) <NEWLINE> <NL> @ jit <NEWLINE> def make_divisors ( n ) : <NEWLINE> <INDENT> lower_divisors , upper_divisors = [ ] , [ ] <NEWLINE> i = 1 <NEWLINE> while i * i <= n : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> lower_divisors . append ( i ) <NEWLINE> if i != n // i : <NEWLINE> <INDENT> upper_divisors . append ( n // i ) <NEWLINE> <DEDENT> <DEDENT> i += 1 <NEWLINE> <DEDENT> return lower_divisors + upper_divisors [ : : - 1 ] <NEWLINE> <NL> <DEDENT> for i in a : <NEWLINE> <INDENT> k = make_divisors ( i ) <NEWLINE> flag = True <NEWLINE> for j in k : <NEWLINE> <INDENT> if j in se : <NEWLINE> <INDENT> flag = False <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if flag : <NEWLINE> <INDENT> se . add ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> point = len ( se ) <NEWLINE> <NL> for i in se : <NEWLINE> <INDENT> if c [ i ] > 1 : <NEWLINE> <INDENT> point -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( point ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = sorted ( [ int ( i ) for i in input ( ) . split ( ) ] ) <NEWLINE> cnt_d = [ 0 ] * ( max ( a ) + 1 ) <NEWLINE> cnt_nd = 0 <NEWLINE> for ai in a : <NEWLINE> <INDENT> if cnt_d [ ai ] >= 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cnt_d [ ai ] += 1 <NEWLINE> cnt_nd += 1 <NEWLINE> <DEDENT> multi = 2 <NEWLINE> while ai * multi <= max_a : <NEWLINE> <INDENT> cnt_d [ ai * multi ] += 1 <NEWLINE> multi += 1 <NEWLINE> <DEDENT> <DEDENT> print ( cnt_nd ) <NEWLINE>
from collections import Counter <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> A_set = set ( A ) <NEWLINE> A_dict = Counter ( A ) <NEWLINE> A_dict . sort ( ) <NEWLINE> <NL> for key , count in A_dict . items ( ) : <NEWLINE> <INDENT> if count > 1 : <NEWLINE> <INDENT> A_set . discard ( key ) <NEWLINE> continue <NEWLINE> <NL> <DEDENT> k = key * 2 <NEWLINE> <NL> if key in A_set : <NEWLINE> <INDENT> while k <= max ( A ) : <NEWLINE> <INDENT> A_set . discard ( k ) <NEWLINE> k += key <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( len ( A_set ) ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import math <NEWLINE> import sys <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a . sort ( ) <NEWLINE> M = max ( a ) <NEWLINE> p = [ ] <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> p . append ( [ j for j in range ( a [ i ] , M + 1 , a [ i ] ) ] ) <NEWLINE> <DEDENT> print ( len ( set ( set ( a ) - set ( p ) ) ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a_max = max ( a ) <NEWLINE> lst = [ 0 ] * ( a_max + 1 ) <NEWLINE> cnt = 0 <NEWLINE> for i in a : <NEWLINE> <INDENT> if lst [ i ] > 1 : <COMMENT> <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> for j in range ( a_max // i + 1 ) : <COMMENT> <NEWLINE> <INDENT> lst [ i * j ] += 1 <NEWLINE> <DEDENT> lst [ 1 : : i ] += 1 <NEWLINE> <DEDENT> for i in a : <NEWLINE> <INDENT> if lst [ i ] == 1 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
import sys <NEWLINE> n = int ( sys . stdin . readline ( ) . rstrip ( <STRING> ) ) <NEWLINE> a = [ int ( s ) for s in sys . stdin . readline ( ) . rstrip ( <STRING> ) . split ( ) ] <NEWLINE> a . sort ( ) <NEWLINE> a_true = [ True ] * n <NEWLINE> a_set = set ( a ) <NEWLINE> if 1 in a or len ( a_set ) == 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a_max = a [ n - 1 ] <NEWLINE> i = 0 <NEWLINE> while a [ i ] * 2 <= a_max : <NEWLINE> <INDENT> while i < n - 1 : <NEWLINE> <INDENT> if a [ i ] == a [ i + 1 ] : <NEWLINE> <INDENT> a_true [ i ] = False <NEWLINE> a_true [ i + 1 ] = False <NEWLINE> <DEDENT> i += 1 <NEWLINE> <DEDENT> for j in range ( i + 1 , n ) : <NEWLINE> <INDENT> if a [ j ] % a [ i ] == 0 : <NEWLINE> <INDENT> a_true [ j ] = False <NEWLINE> <DEDENT> <DEDENT> i += 1 <NEWLINE> <DEDENT> while i < n - 1 : <NEWLINE> <INDENT> if a [ i ] == a [ i + 1 ] : <NEWLINE> <INDENT> a_true [ i ] = False <NEWLINE> a_true [ i + 1 ] = False <NEWLINE> <DEDENT> i += 1 <NEWLINE> <DEDENT> print ( len ( [ i for i in range ( 0 , n ) if a_true [ i ] ] ) ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> nun_list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> count = 0 <NEWLINE> hoge = len ( nun_list ) - 1 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if is_prime ( nun_list [ i - 1 ] ) : <NEWLINE> <INDENT> count += 1 <NEWLINE> continue <NEWLINE> <DEDENT> tmp = 0 <NEWLINE> for j in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if i != j : <NEWLINE> <INDENT> if nun_list [ i - 1 ] % nun_list [ j - 1 ] == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> tmp += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if tmp == hoge : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE> <NL> def is_prime ( n ) : <NEWLINE> <INDENT> for i in range ( 2 , n + 1 ) : <NEWLINE> <INDENT> if i * i > n : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if n % i == 0 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> <DEDENT> return n != 1 <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = [ int ( x ) for x in input ( ) . split ( <STRING> ) ] <NEWLINE> Amax = max ( A ) <NEWLINE> dp = np . ones ( Amax , dtype = bool ) <NEWLINE> appear = np . zeros ( Amax , dtype = int ) <NEWLINE> for a in A : <NEWLINE> <INDENT> appear [ a - 1 ] += 1 <NEWLINE> <NL> <DEDENT> for i in range ( 1 , len ( dp ) + 1 ) : <NEWLINE> <INDENT> if not dp [ i - 1 ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if appear [ i - 1 ] != 0 : <NEWLINE> <INDENT> j = 2 <NEWLINE> while j * i <= Amax : <NEWLINE> <INDENT> dp [ j * i - 1 ] = False <NEWLINE> j += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> count = 0 <NEWLINE> for a in A : <NEWLINE> <INDENT> if appear [ a - 1 ] > 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> count += dp [ a - 1 ] <NEWLINE> <DEDENT> <DEDENT> print ( count - len ( dup_set ) ) <NEWLINE>
from math import ceil <NEWLINE> <NL> X , N = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> l = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> l2 = [ abs ( int ( x ) - X ) for x in l ] <NEWLINE> l2 . sort ( ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if ceil ( i / 2 ) != l2 [ i ] : <NEWLINE> <INDENT> t = ceil ( i / 2 ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if X - t in l : <NEWLINE> <INDENT> print ( X + t ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( X - t ) <NEWLINE> <DEDENT>
from numba import jit <NEWLINE> <NL> @ jit ( cache = True ) <NEWLINE> def solve ( i , j , a ) : <NEWLINE> <INDENT> k = False <NEWLINE> sc = 0 <NEWLINE> for c in a : <NEWLINE> <INDENT> if c > j : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> elif c > j // 2 and c < j : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> elif c == j : <NEWLINE> <INDENT> sc += 1 <NEWLINE> if sc >= 2 : <NEWLINE> <INDENT> k = True <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if j % c == 0 : <NEWLINE> <INDENT> k = True <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return k <NEWLINE> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> a = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> ans = 0 <NEWLINE> for i , j in enumerate ( a ) : <NEWLINE> <INDENT> if solve ( i , j , a ) : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from collections import Counter <NEWLINE> n = int ( input ( ) ) <NEWLINE> A = sorted ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> c = Counter ( A ) <NEWLINE> <NL> yes_or_no = [ 1 for i in range ( A [ n - 1 ] ) ] <NEWLINE> <NL> for a in A : <NEWLINE> <INDENT> t = a * 2 <NEWLINE> while t <= A [ n - 1 ] : <NEWLINE> <INDENT> yes_or_no [ t ] = 0 <NEWLINE> t += a <NEWLINE> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for a in A : <NEWLINE> <INDENT> if c [ a ] == 1 and yes_or_no [ a ] == 1 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> L = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> L . sort ( reverse = True ) <NEWLINE> count = 0 <NEWLINE> for n in np . array ( range ( N ) ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> if n != N - 1 : <NEWLINE> <INDENT> L_s = L [ n + 1 : ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> L_s = L [ n : ] <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> for l_s in L_s : <NEWLINE> <INDENT> print ( l_s ) <NEWLINE> if L [ n ] % l_s == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
import sys <NEWLINE> import numpy as np <NEWLINE> <NL> <NL> def solve ( sequence ) : <NEWLINE> <NL> <INDENT> sequence . sort ( ) <NEWLINE> <NL> max_v = sequence [ - 1 ] <NEWLINE> <NL> dp = [ True ] * ( max_v + 1 ) <NEWLINE> <NL> previous = - 1 <NEWLINE> for v in sequence : <NEWLINE> <INDENT> if v == previous : <NEWLINE> <INDENT> dp [ v ] = False <NEWLINE> continue <NEWLINE> <NL> <DEDENT> previous = v <NEWLINE> <NL> if not dp [ v ] : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <DEDENT> for iv in range ( 2 * v , max_v + 1 , v ) : <NEWLINE> <INDENT> dp [ iv ] = False <NEWLINE> <NL> <DEDENT> <DEDENT> count = 0 <NEWLINE> for v in sequence : <NEWLINE> <INDENT> if dp [ v ] : <NEWLINE> <INDENT> count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> return count <NEWLINE> <NL> <NL> <DEDENT> if sys . argv [ - 1 ] == <STRING> : <NEWLINE> <INDENT> from numba . pycc import CC <NEWLINE> cc = CC ( <STRING> ) <NEWLINE> cc . export ( <STRING> , <STRING> ) ( solve ) <NEWLINE> cc . compile ( ) <NEWLINE> exit ( ) <NEWLINE> <NL> <NL> <DEDENT> from my_module import solve <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> sequence = np . array ( input ( ) . split ( ) , np . int64 ) <NEWLINE> print ( solve ( sequence ) ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
a = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a . sort ( ) <NEWLINE> <NL> d_num = a <NEWLINE> <NL> div = [ ] <NEWLINE> a_set = list ( set ( a ) ) <NEWLINE> flag = False <NEWLINE> if len ( a_set ) == 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( len ( a_set ) ) : <NEWLINE> <INDENT> flag = False <NEWLINE> for j in range ( len ( div ) ) : <NEWLINE> <INDENT> if ( a_set [ i ] % div [ j ] == 0 ) : <NEWLINE> <INDENT> d_num -= 1 <NEWLINE> flag = True <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if flag == False : <NEWLINE> <INDENT> div . append ( a_set [ i ] ) <NEWLINE> <DEDENT> <DEDENT> print ( 1 ) <NEWLINE> <DEDENT>
def main ( ) <NEWLINE> <INDENT> N = input ( ) <NEWLINE> A = sorted ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> M = A [ - 1 ] + 1 <NEWLINE> B = [ 0 ] * M <NEWLINE> for i in A : <NEWLINE> <INDENT> B [ i ] += 1 <NEWLINE> if B [ i ] == 1 : <NEWLINE> <INDENT> for j in range ( i * 2 , M , i ) : <NEWLINE> <INDENT> B [ j ] = 2 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( B . count ( 1 ) ) <NEWLINE> <DEDENT> main ( ) <NEWLINE>
import numpy as np <NEWLINE> from numba import njit <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = np . array ( list ( map ( int , input ( ) . split ( ) ) ) , np . int32 ) <NEWLINE> <NL> @ njit ( cache = True ) <NEWLINE> def solve ( ) : <NEWLINE> <INDENT> m = np . zeros ( 10 ** 6 + 1 ) <NEWLINE> for i in a : <NEWLINE> <INDENT> if m [ i ] == 1 : <NEWLINE> <INDENT> m [ i ] = 2 <NEWLINE> continue <NEWLINE> <DEDENT> m [ : : i ] += 1 <NEWLINE> <DEDENT> ans = 0 <NEWLINE> for i in a : <NEWLINE> <INDENT> if m [ i ] == 1 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> solve ( ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A . sort ( ) <NEWLINE> <COMMENT> <NL> multiple = [ 0 ] * ( A [ - 1 ] + 1 ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> now = A [ i ] <NEWLINE> while ( now <= A [ - 1 ] ) : <NEWLINE> <INDENT> multiple [ now ] += 1 <NEWLINE> now += now <NEWLINE> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if ( multiple [ A [ i ] ] == 1 ) : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> array = list ( map ( int , input ( ) . strip ( ) . split ( ) ) ) <NEWLINE> array . sort ( ) <NEWLINE> ans = 0 <NEWLINE> a = [ True ] * array [ N - 1 ] <NEWLINE> i = 0 <NEWLINE> before = 0 <NEWLINE> for i in array : <NEWLINE> <INDENT> j = 2 * i <NEWLINE> if i == before : <NEWLINE> <INDENT> array [ i ] == False <NEWLINE> <DEDENT> while j < array [ N - 1 ] : <NEWLINE> <INDENT> array [ j ] == False <NEWLINE> j += i <NEWLINE> <DEDENT> before = i <NEWLINE> <DEDENT> for i in array : <NEWLINE> <INDENT> if array [ i ] == True : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from collections import deque <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> A . sort ( ) <NEWLINE> d = deque ( ) <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> if A [ i ] != A [ i + 1 ] : <NEWLINE> <INDENT> d . append ( A [ i ] ) <NEWLINE> <DEDENT> <DEDENT> if A [ N - 1 ] != A [ N - 2 ] : <NEWLINE> <INDENT> d . append ( A [ N - 1 ] ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> max_A = max ( A ) <NEWLINE> ban = [ 0 ] * max_A <NEWLINE> while len ( d ) : <NEWLINE> <INDENT> num = d . popleft ( ) <NEWLINE> if ban [ num ] != 1 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> ban_num = num <NEWLINE> while ban_num <= max_A : <NEWLINE> <INDENT> ban [ ban_num ] = 1 <NEWLINE> ban_num += num <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> sa = set ( ) <NEWLINE> for ai in a : <NEWLINE> <INDENT> if ai in sa : <NEWLINE> <INDENT> sa . discard ( ai ) <NEWLINE> continue <NEWLINE> <DEDENT> sa . add ( ai ) <NEWLINE> <NL> <DEDENT> if len ( sa ) == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> a = list ( sa ) <NEWLINE> a . sort ( ) <NEWLINE> <NL> <COMMENT> <NL> <NL> import fractions <NEWLINE> def lcm ( a , b ) : <NEWLINE> <INDENT> return a * b // fractions . gcd ( a , b ) <NEWLINE> <NL> <DEDENT> ans = 1 <NEWLINE> l = 1 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if lcm ( a [ i ] , l ) < a [ i ] * l : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> l = lcm ( a [ i ] , l ) <NEWLINE> ans += 1 <NEWLINE> <DEDENT> print ( ans , l ) <NEWLINE> <NL> <NL>
from collections import Counter <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> C = Counter ( A ) . most_common ( ) <NEWLINE> <NL> MAXN = max ( A ) <NEWLINE> B = [ False ] * ( MAXN + 1 ) <NEWLINE> for c in C : <NEWLINE> <INDENT> B [ c [ 0 ] ] = True <NEWLINE> <DEDENT> ans = 0 <NEWLINE> for i in range ( MAXN + 1 ) : <NEWLINE> <INDENT> if B [ i ] : <NEWLINE> <INDENT> if C [ i ] == 1 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> B [ i : : i ] = [ False ] * ( MAXN // i ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> n = max ( A ) <NEWLINE> dp = [ True for i in range ( n + 1 ) ] <NEWLINE> p = 2 <NEWLINE> while ( p * p <= n ) : <NEWLINE> <COMMENT> <NL> <INDENT> if ( prime [ p ] == True ) : <NEWLINE> <COMMENT> <NL> <INDENT> for i in range ( p * p , n + 1 , p ) : <NEWLINE> <INDENT> prime [ i ] = False <NEWLINE> p += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for num in A : <NEWLINE> <INDENT> if dp [ num ] : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> a = sorted ( [ int ( i ) for i in input ( ) . split ( ) ] ) <NEWLINE> table = [ True for i in range ( max ( a ) ) ] <NEWLINE> res = 0 <NEWLINE> amax = max ( a ) <NEWLINE> dup = 0 <NEWLINE> <NL> for i in a : <NEWLINE> <INDENT> if table [ i - 1 ] : <NEWLINE> <INDENT> if i not in res : <NEWLINE> <INDENT> res . append ( i ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dup += 1 <NEWLINE> continue <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> for j in range ( i * 2 , amax , i ) : <NEWLINE> <INDENT> table [ j - 1 ] = False <NEWLINE> <DEDENT> <DEDENT> print ( len ( res ) - dup ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <NL> <DEDENT>
from collections import Counter <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c = Counter ( a ) <NEWLINE> dp = [ True ] * ( 10 ** 6 + 1 ) <NEWLINE> s = list ( set ( a ) ) <NEWLINE> for x in s : <NEWLINE> <INDENT> e = x * 2 <NEWLINE> while e <= 10 ** 6 : <NEWLINE> <INDENT> dp [ e ] = False <NEWLINE> e += x <NEWLINE> <DEDENT> <DEDENT> ret = 0 <NEWLINE> for x in a : <NEWLINE> <INDENT> if c [ x ] == 1 and dp [ x ] == True : <NEWLINE> <INDENT> ret += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> A . sort ( ) <NEWLINE> cnt = [ 0 ] * ( A [ - 1 ] + 1 ) <NEWLINE> <NL> for a in A : <NEWLINE> <INDENT> cnt [ : : a ] += 1 <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for a in A : <NEWLINE> <INDENT> if cnt [ a ] == 1 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import numpy as np <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A . sort ( ) <NEWLINE> d = np . zeros ( A [ - 1 ] + 1 , dtype = np . unit64 ) <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> a = A [ i ] <NEWLINE> a1 = A [ i - 1 ] <NEWLINE> if a != a1 : <NEWLINE> <INDENT> d [ a : : a ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d [ a ] += 1 <NEWLINE> <DEDENT> <DEDENT> print ( np . count_nonzero ( d [ A ] == 1 ) ) <NEWLINE> <NL> <DEDENT> print ( main ( ) ) <NEWLINE>
from numba import njit , int32 <NEWLINE> import numpy as np <NEWLINE> <NL> <NL> @ njit ( int32 ( int32 [ : ] , int32 [ : ] ) ) <NEWLINE> def main ( A , B ) : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <NL> for a in A : <NEWLINE> <INDENT> B [ a ] += 1 <NEWLINE> <NL> <DEDENT> for a in set ( A ) : <NEWLINE> <INDENT> v = 2 * a <NEWLINE> while v <= 10 ** 6 : <NEWLINE> <INDENT> B [ v ] += 1 <NEWLINE> v += a <NEWLINE> <NL> <DEDENT> <DEDENT> for a in A : <NEWLINE> <INDENT> if B [ a ] == 1 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> return ans <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> A = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> B = [ 0 ] * ( 10 ** 6 + 1 ) <NEWLINE> ans = main ( np . array ( A ) , np . array ( B ) ) <NEWLINE> print ( ans ) <NEWLINE> <DEDENT>
import collections <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> _ = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> A . sort ( ) <NEWLINE> <NL> sames = 0 <NEWLINE> C = collections . Counter ( A ) <NEWLINE> for v in C . values ( ) : <NEWLINE> <INDENT> if v > 1 : <NEWLINE> <INDENT> sames += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> a_max = A [ - 1 ] <NEWLINE> dp = [ True ] * a_max <NEWLINE> A = set ( A ) <NEWLINE> <NL> if dp [ a - 1 ] : <NEWLINE> <INDENT> tmp_a = a * 2 <NEWLINE> while tmp_a < a_max + 1 : <NEWLINE> <INDENT> dp [ tmp_a - 1 ] = False <NEWLINE> tmp_a += a <NEWLINE> <NL> <DEDENT> <DEDENT> r = 0 <NEWLINE> for a in A : <NEWLINE> <INDENT> if dp [ a - 1 ] : <NEWLINE> <INDENT> r += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( r - sames ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
from collections import Counter <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = Counter ( list ( map ( int , input ( ) . split ( <STRING> ) ) ) ) <NEWLINE> ans = 0 <NEWLINE> L = [ 1 ] * ( 10 ** 6 + 1 ) <NEWLINE> for i in sorted ( A . keys ( ) ) : <NEWLINE> <INDENT> if A [ i ] > 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> ans += L [ i ] <NEWLINE> for j in ( i , 10 ** 6 + 1 , i ) : <NEWLINE> <INDENT> L [ j ] = 0 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<NL> def is_prime ( n ) : <NEWLINE> <INDENT> if n == 1 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> for i in range ( 2 , int ( n ** 0.5 ) + 1 ) : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> <DEDENT> return True <NEWLINE> <NL> <NL> <DEDENT> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> D = defaultdict ( int ) <NEWLINE> for a in A : <NEWLINE> <INDENT> D [ a ] += 1 <NEWLINE> <NL> <DEDENT> L = [ ] <NEWLINE> for k , v in D . items ( ) : <NEWLINE> <INDENT> if v > 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> L . append ( k ) <NEWLINE> <NL> <DEDENT> if len ( L ) == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> L . sort ( ) <NEWLINE> <NL> ans = set ( ) <NEWLINE> for n in L : <NEWLINE> <INDENT> if is_prime ( n ) : <NEWLINE> <INDENT> ans . add ( n ) <NEWLINE> <DEDENT> flg = True <NEWLINE> for s in ans : <NEWLINE> <INDENT> if n % s == 0 : <NEWLINE> <INDENT> flg = False <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if flg is False : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> ans . add ( n ) <NEWLINE> <NL> <DEDENT> print ( len ( ans ) ) <NEWLINE>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> <NL> AList = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> AList . sort ( ) <NEWLINE> <NL> dp = [ 0 ] * ( AList [ - 1 ] + 1 ) <NEWLINE> <NL> for i in AList : <NEWLINE> <INDENT> dp [ i ] += 1 <NEWLINE> <NL> if dp [ i ] == 1 : <NEWLINE> <INDENT> for p in range ( 2 * i , len ( dp ) , i ) : <NEWLINE> <INDENT> dp [ j ] += 2 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( dp . count ( 1 ) ) <NEWLINE>
import numpy as np <NEWLINE> from numba import njit <NEWLINE> <NL> <NL> n = int ( input ( ) ) <NEWLINE> a = np . array ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> ans = 0 <NEWLINE> <NL> @ njit <NEWLINE> def check ( ans ) : <NEWLINE> <INDENT> for i in range ( n ) : <NEWLINE> <INDENT> temp = a [ i ] <NEWLINE> count = np . count_nonzero ( temp % a == 0 ) <NEWLINE> if count == 1 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> return ans <NEWLINE> <NL> <DEDENT> ans = check ( ans ) <NEWLINE> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a . sort ( ) <NEWLINE> maxa = max ( a ) <NEWLINE> <NL> dp = { i : 0 for i in range ( 1 , dp + 1 ) } <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if dp [ a [ i ] ] == 1 : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <DEDENT> if i == n - 1 or a [ i ] != a [ i + 1 ] : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> prime += a [ i ] <NEWLINE> while prime <= maxa : <NEWLINE> <INDENT> dp [ prime ] = 1 <NEWLINE> prime += a [ i ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> A , = map ( int , input ( ) . split ( ) ) <NEWLINE> maxA = max ( A ) <NEWLINE> <COMMENT> <NL> C = { a : 0 for a in A } <NEWLINE> for a in A : <NEWLINE> <INDENT> C [ a ] += 1 <NEWLINE> <COMMENT> <NL> <DEDENT> D = { a : 0 for a in A } <NEWLINE> for a in A : <NEWLINE> <INDENT> if C [ a ] > 0 : <NEWLINE> <INDENT> t = 2 <NEWLINE> while a * t <= maxA : <NEWLINE> <INDENT> D [ a * t ] = 1 <NEWLINE> t += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for a in A : <NEWLINE> <INDENT> if C [ a ] == 1 and D [ a ] == 0 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import numpy as np <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> <COMMENT> <NL> from numba import njit , i8 <NEWLINE> <NL> <NL> def sieve ( N , A , dp ) : <NEWLINE> <INDENT> for i in range ( N ) : <NEWLINE> <INDENT> now = A [ i ] <NEWLINE> M = A [ - 1 ] // now <NEWLINE> for j in range ( 2 , M + 1 ) : <NEWLINE> <INDENT> dp [ now * j - 1 ] = False <NEWLINE> <DEDENT> <DEDENT> return dp <NEWLINE> <NL> <NL> <DEDENT> def cnt ( N , A , dp ) : <NEWLINE> <INDENT> skip = 0 <NEWLINE> res = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> now = A [ i ] <NEWLINE> if skip == now : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if i != N - 1 : <NEWLINE> <INDENT> if now == A [ i + 1 ] : <NEWLINE> <INDENT> skip = now <NEWLINE> continue <NEWLINE> <DEDENT> <DEDENT> if dp [ now - 1 ] : <NEWLINE> <INDENT> res += 1 <NEWLINE> <DEDENT> <DEDENT> return res <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> A = sorted ( A ) <NEWLINE> A = np . array ( A ) <NEWLINE> <NL> dp = np . array ( [ True for i in range ( A [ - 1 ] ) ] ) <NEWLINE> <COMMENT> <NL> dp = sieve ( N , A , dp ) <NEWLINE> <COMMENT> <NL> <NL> res = cnt ( N , A , dp ) <NEWLINE> <NL> print ( res ) <NEWLINE> <NL> <NL> <NL> <DEDENT> main ( ) <NEWLINE>
M = 10 ** 6 + 5 <NEWLINE> N = int ( input ( ) ) <NEWLINE> A_ref = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A = set ( M ) <NEWLINE> for i in A_ref : <NEWLINE> <INDENT> A . add ( i ) <NEWLINE> <DEDENT> cnt = [ 0 ] * M <NEWLINE> for i in A : <NEWLINE> <INDENT> for j in range ( 0 , M , i ) : <NEWLINE> <INDENT> cnt [ j ] += 1 <NEWLINE> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for i in A : <NEWLINE> <INDENT> if ( cnt [ i ] == 1 ) : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> key = max ( A ) + 1 <COMMENT> <NEWLINE> B = [ 0 ] * key <COMMENT> <NEWLINE> for a in A : <NEWLINE> <INDENT> for b in range ( a , key , a ) : <NEWLINE> B [ b ] += 1 <COMMENT> <NEWLINE> <DEDENT> ans = 0 <NEWLINE> for a in A : <NEWLINE> <INDENT> if B [ a ] == 1 : <COMMENT> <NEWLINE> ans += 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
c = [ 0 ] * 8 ** 7 <NEWLINE> for a in [ * open ( i : = 0 ) ] [ 1 ] . split ( ) : c [ int ( a ) ] += 1 <NEWLINE> while i < 1e6 : <NEWLINE> <INDENT> i += 1 ; j = i <NEWLINE> while j < 1e6 : j += i ; c [ j ] *= c [ i ] < 1 <NEWLINE> <DEDENT> print ( c . count ( 1 ) ) <NEWLINE>
from numba import jit <NEWLINE> from numba . typed import List <NEWLINE> import numpy as np <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> As = np . array ( list ( map ( int , input ( ) . split ( <STRING> ) ) ) ) <NEWLINE> <NL> <NL> @ jit <NEWLINE> def test ( As ) : <NEWLINE> <INDENT> num_i = 0 <NEWLINE> num_j = 0 <NEWLINE> not_divisible = 0 <NEWLINE> for num_i , Ai in enumerate ( As ) : <NEWLINE> <INDENT> for num_j , Aj in enumerate ( As ) : <NEWLINE> <INDENT> if num_i == num_j : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if Ai % Aj == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> not_divisible += 1 <NEWLINE> <DEDENT> <DEDENT> print ( not_divisible ) <NEWLINE> <NL> <DEDENT> test ( As ) <NEWLINE>
import numba <NEWLINE> from numba import njit , b1 , i4 , i8 , f8 <NEWLINE> import numpy as np <COMMENT> <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = np . array ( [ int ( x ) for x in input ( ) . split ( ) ] , dtype = np . int32 ) <NEWLINE> <NL> <NL> @ njit ( ( i4 [ : ] , ) , cache = True ) <NEWLINE> def main ( A ) : <NEWLINE> <INDENT> count = np . zeros ( 10 ** 6 + 10 , np . int32 ) <NEWLINE> for x in A : <NEWLINE> <INDENT> count [ : : x ] += 1 <NEWLINE> <DEDENT> ret = 0 <NEWLINE> for x in A : <NEWLINE> <INDENT> ret += count [ x ] == 1 <NEWLINE> <DEDENT> return ret <NEWLINE> <NL> <NL> <DEDENT> print ( main ( A ) ) <NEWLINE>
import sys <NEWLINE> import numpy as np <NEWLINE> from numba as njit <NEWLINE> <NL> <NL> @ njit <NEWLINE> def solve ( A ) : <NEWLINE> <INDENT> count = np . zeros ( 10 ** 6 + 10 , np . int32 ) <NEWLINE> for x in A : <NEWLINE> <INDENT> if count [ x ] > 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> count [ : : x ] += 1 <NEWLINE> <DEDENT> <DEDENT> ret = 0 <NEWLINE> for x in A : <NEWLINE> <INDENT> if count [ x ] == 1 : <NEWLINE> <INDENT> rep += 1 <NEWLINE> <DEDENT> <DEDENT> return ret <NEWLINE> <NL> <NL> <DEDENT> A = np . array ( read ( ) . split ( ) , np . int32 ) <NEWLINE> print ( solve ( A ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a_lst = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> index_lst = [ 0 ] * ( a_max + 1 ) <NEWLINE> <NL> for ai in a_lst : <NEWLINE> <INDENT> for multi in range ( ai , a_max + 1 , ai ) : <NEWLINE> <INDENT> index_lst [ multi ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for ai in a_lst : <NEWLINE> <INDENT> if index_lst [ ai ] == 1 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from numba import njit , int32 , int64 <NEWLINE> from numba . typed import Dict <NEWLINE> <NL> @ njit <NEWLINE> def solve ( B ) : <NEWLINE> <INDENT> A = Dict . empty ( <NEWLINE> <INDENT> key_type = int64 , <NEWLINE> value_type = int64 ) <NEWLINE> <DEDENT> for b in B : <NEWLINE> <INDENT> A [ b ] = A . get ( b , 0 ) + 1 <NEWLINE> <DEDENT> r = 0 <NEWLINE> if 1 in A : <NEWLINE> <INDENT> if A [ 1 ] == 1 : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> return 0 <NEWLINE> <DEDENT> for a , v in A . items ( ) : <NEWLINE> <INDENT> if v > 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> i = 2 <NEWLINE> while i * i <= a : <NEWLINE> <INDENT> if a % i == 0 : <NEWLINE> <INDENT> if i in A : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if a // i in A : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> i += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> r += 1 <NEWLINE> <DEDENT> <DEDENT> return r <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> return solve ( A ) <NEWLINE> <NL> <DEDENT> print ( main ( ) ) <NEWLINE> <NL>
n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A . sort ( ) <NEWLINE> <NL> ac = A . count ( 1 ) <NEWLINE> if ac == 1 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> if ac >= 2 : <NEWLINE> <INDENT> print ( 0 ) : <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> num = [ 0 ] * 1000005 <NEWLINE> for a in A : <NEWLINE> <INDENT> num [ a ] += 1 <NEWLINE> <NL> <DEDENT> b = [ False ] * 1000005 <NEWLINE> seen = [ False ] * 1000005 <NEWLINE> cnt = 0 <NEWLINE> A = list ( set ( A ) ) <NEWLINE> A . sort ( ) <NEWLINE> for a in A : <NEWLINE> <INDENT> if seen [ a ] : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <DEDENT> seen [ a ] = True <NEWLINE> if b [ a ] == False : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> if num [ a ] > 1 : <NEWLINE> <INDENT> cnt -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( a , 1000005 , a ) : <NEWLINE> <INDENT> b [ i ] = True <NEWLINE> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
_ , * a = map ( int , open ( <STRING> ) . read ( ) . split ( ) ) <NEWLINE> a . sort ( ) <NEWLINE> m = - ~ a [ - 1 ] <NEWLINE> c = [ 0 ] * m <NEWLINE> for i in a : <NEWLINE> <INDENT> c [ i ] += 1 <NEWLINE> if c [ i ] > 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> for j in range ( i * 2 , m , i ) : <NEWLINE> <INDENT> c [ j ] = 2 <NEWLINE> <DEDENT> <DEDENT> print ( sum ( c [ i ] for i in a ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> m = max ( a ) <NEWLINE> alsit = [ 0 ] * ( m + 1 ) <NEWLINE> for i in a : <NEWLINE> <INDENT> for j in range ( i , m + 1 , i ) : <NEWLINE> <INDENT> alist [ j ] += 1 <NEWLINE> <DEDENT> <DEDENT> cnt = 0 <NEWLINE> for i in a : <NEWLINE> <INDENT> if alist [ i ] == 1 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
import sys <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> <NL> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A = [ x for x in set ( A ) if A . count ( x ) == 1 ] <NEWLINE> if len ( A ) <= 1 : <NEWLINE> <INDENT> print ( len ( A ) ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> A = np . array ( sorted ( A ) ) <NEWLINE> B = np . array ( [ A [ 0 ] ] ) <NEWLINE> <NL> for i in range ( len ( A ) - 1 ) : <NEWLINE> <INDENT> if np . all ( A [ i + 1 ] % B != 0 ) : <NEWLINE> <INDENT> B = np . append ( B , A [ i + 1 ] ) <NEWLINE> <DEDENT> <DEDENT> print ( len ( B ) ) <NEWLINE>
n , a = int ( input ( ) ) , map ( int , input ( ) . split ( ) ) <NEWLINE> a . sort ( ) <NEWLINE> <NL> max_a = a [ - 1 ] <NEWLINE> ans = [ 0 ] * ( max_a + 1 ) <NEWLINE> <NL> for i in a : <NEWLINE> <INDENT> ans [ i ] += 1 <NEWLINE> <DEDENT> for i in set ( a ) : <NEWLINE> <INDENT> if ans [ i ] : <NEWLINE> <INDENT> for j in range ( i * 2 , len ( ans ) , i ) : <NEWLINE> <INDENT> ans [ j ] = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans . count ( 1 ) ) <NEWLINE>
def func ( n , a ) : <NEWLINE> <INDENT> mx = max ( a ) <NEWLINE> x = [ 0 ] * ( mx + 1 ) <COMMENT> <NEWLINE> for i in a : <NEWLINE> <INDENT> x [ i ] += 1 <NEWLINE> <DEDENT> for i in range ( 1 , mx + 1 ) : <NEWLINE> <INDENT> if x [ i ] != 0 : <NEWLINE> <INDENT> for j in range ( 2 * i , mx + 1 , i ) : <NEWLINE> <INDENT> x [ j ] = 0 <NEWLINE> <DEDENT> <DEDENT> if x [ i ] > 1 : <NEWLINE> <INDENT> x [ i ] = 0 <NEWLINE> <DEDENT> <DEDENT> return sum ( x ) <COMMENT> <NEWLINE> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> f ( n , a ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> * A , = map ( int , input ( ) . split ( ) ) <NEWLINE> <COMMENT> <NL> C = { a : 0 for a in A } <NEWLINE> for a in A : <NEWLINE> <INDENT> C [ a ] += 1 <NEWLINE> <COMMENT> <NL> <DEDENT> D = { a : 0 for a in A } <NEWLINE> for a in A : <NEWLINE> <INDENT> if C [ a ] > 0 : <NEWLINE> <INDENT> tmp = 2 <NEWLINE> while a * tmp <= maxA : <NEWLINE> <INDENT> D [ a * tmp ] = 1 <NEWLINE> tmp += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for a in A : <NEWLINE> <INDENT> if C [ a ] == 1 and D [ a ] == 0 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from numba import njit <NEWLINE> import numpy as np <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> @ njit <NEWLINE> def main ( A ) : <NEWLINE> <INDENT> count = np . zeros ( 10 ** 6 + 10 , np . int32 ) <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> a = A [ i ] <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> count [ : : a ] += 1 <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> ans += count [ A [ i ] ] == 1 <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> return ans <NEWLINE> <NL> <NL> <NL> <DEDENT> print ( main ( np . array ( A , np . int32 ) ) ) <NEWLINE>
import numpy as np <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> <COMMENT> <NL> from numba import njit , i8 <NEWLINE> <NL> <NL> @ njit ( i8 [ : ] ( i8 , i8 , i8 [ : ] ) ) <NEWLINE> def sieve ( N , A , dp ) : <NEWLINE> <INDENT> for i in range ( N ) : <NEWLINE> <INDENT> now = A [ i ] <NEWLINE> M = A [ - 1 ] // now <NEWLINE> for j in range ( 2 , M + 1 ) : <NEWLINE> <INDENT> dp [ now * j - 1 ] = False <NEWLINE> <DEDENT> <DEDENT> return dp <NEWLINE> <NL> <NL> <DEDENT> @ njit ( i8 ( i8 , i8 , i8 [ : ] ) ) <NEWLINE> def cnt ( N , A , dp ) : <NEWLINE> <INDENT> skip = 0 <NEWLINE> res = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> now = A [ i ] <NEWLINE> if skip == now : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if i != N - 1 : <NEWLINE> <INDENT> if now == A [ i + 1 ] : <NEWLINE> <INDENT> skip = now <NEWLINE> continue <NEWLINE> <DEDENT> <DEDENT> if dp [ now - 1 ] : <NEWLINE> <INDENT> res += 1 <NEWLINE> <DEDENT> <DEDENT> return res <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> A = sorted ( A ) <NEWLINE> A = np . array ( A ) <NEWLINE> <NL> dp = np . array ( [ True for i in range ( A [ - 1 ] ) ] ) <NEWLINE> <COMMENT> <NL> dp = sieve ( N , A , dp ) <NEWLINE> <COMMENT> <NL> <NL> res = cnt ( N , A , dp ) <NEWLINE> <NL> print ( res ) <NEWLINE> <NL> <NL> <NL> <DEDENT> main ( ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> S = set ( A ) <NEWLINE> M = max ( S ) <NEWLINE> A . sort ( ) <NEWLINE> <NL> for a in A : <NEWLINE> <INDENT> if a == pre_a : <NEWLINE> <INDENT> S . discard ( a ) <NEWLINE> <DEDENT> if a in S : <NEWLINE> <INDENT> j = a * 2 <NEWLINE> while j <= M : <NEWLINE> <INDENT> S . discard ( j ) <NEWLINE> j += a <NEWLINE> <DEDENT> <DEDENT> pre_a = a <NEWLINE> <DEDENT> print ( len ( S ) ) <NEWLINE>
import sys <NEWLINE> <NL> read = sys . stdin . buffer . read <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> <NL> <NL> def f ( a ) : <NEWLINE> <INDENT> for i in range ( n - 1 ) : <NEWLINE> <INDENT> b [ i ] = a [ i ] % a [ i + 1 ] <NEWLINE> <DEDENT> return b <NEWLINE> <NL> <NL> <DEDENT> n , * a = map ( int , read ( ) . split ( ) ) <NEWLINE> <NL> b = [ 0 ] * n <NEWLINE> <NL> a = sorted ( a , reverse = True ) <NEWLINE> z = 0 <NEWLINE> <NL> while a [ len ( a ) ] == 0 : <NEWLINE> <INDENT> a = f ( a ) <NEWLINE> z += 1 <NEWLINE> <NL> <DEDENT> print ( z - 1 ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> from collections import Counter <NEWLINE> n , * a = map ( int , open ( 0 ) . read ( ) . split ( ) ) <NEWLINE> x = Counter ( a ) <NEWLINE> <NL> y = [ k for k , v in x . items ( ) if v == 1 ] <NEWLINE> if len ( y ) == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> z = sorted ( y ) <NEWLINE> <NL> if x . get ( 1 ) > 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> if x . get ( 1 ) == 1 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> l = z [ - 1 ] <NEWLINE> m = [ 0 ] * ( l + 1 ) <NEWLINE> for i in z : <NEWLINE> <INDENT> if m [ i ] == 0 : <NEWLINE> <INDENT> m [ i ] = 1 <NEWLINE> <DEDENT> j = l // i <NEWLINE> for k in range ( 2 , j + 1 ) : <NEWLINE> <INDENT> m [ i * k ] = - 1 <NEWLINE> <NL> <DEDENT> <DEDENT> ans = m . count ( 1 ) <NEWLINE> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
from collections import Counter <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if n == 1 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> a . sort ( ) <NEWLINE> if a [ 0 ] == 1 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> c = Counter ( a ) <NEWLINE> a = list ( set ( a ) ) <NEWLINE> dp = [ 0 ] * ( 10 + 1 ) <NEWLINE> <NL> for x in a : <NEWLINE> <INDENT> t = x * 2 <NEWLINE> while t <= 10 : <NEWLINE> <INDENT> dp [ t ] = 1 <NEWLINE> t += x <NEWLINE> <NL> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for x in a : <NEWLINE> <INDENT> if ( c [ x ] == 1 ) & ( dp [ x ] == 0 ) : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from collections import deque <NEWLINE> n = int ( input ( ) ) <NEWLINE> L = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> L . append ( input ( ) ) <NEWLINE> <NL> <DEDENT> ANS = [ <STRING> ] <NEWLINE> d = deque ( ) <NEWLINE> d . append ( <STRING> ) <NEWLINE> <NL> for i in range ( 1 , n ) : <NEWLINE> <INDENT> if L [ i ] == <STRING> : <NEWLINE> <INDENT> d . pop ( ) <NEWLINE> t = d . pop ( ) <NEWLINE> ANS . append ( t ) <NEWLINE> d . append ( t ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s = L [ i ] [ 6 : ] <NEWLINE> ANS . append ( s ) <NEWLINE> d . append ( s ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> for i in ANS : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) + [ 10 ** 7 ] <NEWLINE> <NL> A . sort ( ) <NEWLINE> e = np . zeros ( 10 ** 6 + 1 ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if e [ A [ i ] ] == 0 : <NEWLINE> <INDENT> e [ : : A [ i ] ] = 1 <COMMENT> <NEWLINE> <COMMENT> <NL> if A [ i ] != A [ i + 1 ] : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from collections import Counter <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> s = sorted ( set ( a ) ) <NEWLINE> c = Counter ( a ) <NEWLINE> t = [ 0 ] * ( 10 ** 6 + 1 ) <NEWLINE> for i in a : <NEWLINE> <INDENT> for j in range ( i , 10 ** 6 + 1 , i ) : <NEWLINE> <INDENT> t [ j ] += 1 <NEWLINE> <DEDENT> <DEDENT> print ( len ( i for i in a if t [ i ] == 1 and c [ i ] == 1 ) ) <NEWLINE> <NL>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> import sys <NEWLINE> <NL> s2nn = lambda s : [ int ( c ) for c in s . split ( <STRING> ) ] <NEWLINE> ss2nn = lambda ss : [ int ( s ) for s in list ( ss ) ] <NEWLINE> ss2nnn = lambda ss : [ s2nn ( s ) for s in list ( ss ) ] <NEWLINE> i2s = lambda : sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> i2n = lambda : int ( i2s ( ) ) <NEWLINE> i2nn = lambda : s2nn ( i2s ( ) ) <NEWLINE> ii2ss = lambda n : [ i2s ( ) for _ in range ( n ) ] <NEWLINE> ii2nn = lambda n : ss2nn ( ii2ss ( n ) ) <NEWLINE> ii2nnn = lambda n : ss2nnn ( ii2ss ( n ) ) <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> N = i2n ( ) <NEWLINE> A = sorted ( int ( c ) for c in i2s ( ) . split ( <STRING> ) ) <NEWLINE> max_ = A [ - 1 ] <NEWLINE> B = { } <NEWLINE> if N == 1 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> return <NEWLINE> <DEDENT> if A [ 0 ] == A [ 1 ] : <NEWLINE> <INDENT> B [ A [ i ] ] = 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> B [ A [ i ] ] = 1 <NEWLINE> <DEDENT> for i in range ( 1 , N - 1 ) : <NEWLINE> <INDENT> if A [ i - 1 ] == A [ i ] or A [ i + 1 ] == A [ i ] : <NEWLINE> <INDENT> B [ A [ i ] ] = 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> B [ A [ i ] ] = 1 <NEWLINE> <DEDENT> <DEDENT> if A [ - 2 ] == A [ - 1 ] : <NEWLINE> <INDENT> B [ A [ i ] ] = 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> B [ A [ i ] ] = 1 <NEWLINE> <DEDENT> for b in B : <NEWLINE> <INDENT> if B [ b ] == 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if B [ b ] == 2 : <NEWLINE> <INDENT> B [ b ] = 0 <NEWLINE> <DEDENT> for i in range ( 2 , max_ // b + 1 ) : <NEWLINE> <INDENT> if b * i in B : <NEWLINE> <INDENT> B [ b * i ] = 0 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> res = 0 <NEWLINE> for v in B . values ( ) : <NEWLINE> <INDENT> if v : <NEWLINE> <INDENT> res += 1 <NEWLINE> <DEDENT> <DEDENT> print ( res ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> from queue import Queue <NEWLINE> from queue import LifoQueue as Stack <NEWLINE> from math import sqrt , floor , ceil , log2 , log10 , pi <NEWLINE> from fractions import gcd <NEWLINE> from itertools import permutations , combinations <NEWLINE> from operator import itemgetter <NEWLINE> from functools import cmp_to_key <NEWLINE> <NL> <COMMENT> <NL> <NL> <NL> INF = 1001001001 <NEWLINE> __MOD__ = ( 10 ** 9 ) + 7 <NEWLINE> yn = <STRING> <NEWLINE> judge = False <NEWLINE> cnt = 0 <NEWLINE> ans = None <NEWLINE> <NL> <NL> def lcm ( a , b ) : <NEWLINE> <INDENT> return ( a * b ) // gcd ( a , b ) <NEWLINE> <NL> <DEDENT> def intinput ( ) : <NEWLINE> <INDENT> return int ( input ( ) ) <NEWLINE> <NL> <DEDENT> def mulinputs ( ) : <NEWLINE> <INDENT> return map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <DEDENT> def lineinputs ( func = intinput ) : <NEWLINE> <INDENT> datas = [ ] <NEWLINE> while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> datas . append ( func ( ) ) <NEWLINE> <DEDENT> except EOFError : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> return datas <NEWLINE> <NL> <DEDENT> class ModInt ( ) : <NEWLINE> <INDENT> def __init__ ( self , x ) : <NEWLINE> <INDENT> self . __x = ( x % __MOD__ ) <NEWLINE> <DEDENT> def __add__ ( self , other ) : <NEWLINE> <INDENT> if type ( other ) == int : <NEWLINE> <INDENT> other = self . __class__ ( other ) <NEWLINE> return int ( self . __class__ ( ( self . __x + other . __x ) % __MOD__ ) ) <NEWLINE> <DEDENT> elif type ( other ) == ModInt : <NEWLINE> <INDENT> return self . __class__ ( ( self . __x + other . __x ) % __MOD__ ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> raise Exception ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> def __radd__ ( self , other ) : <NEWLINE> <INDENT> if type ( other ) == int : <NEWLINE> <INDENT> other = self . __class__ ( other ) <NEWLINE> return int ( self . __class__ ( ( other . __x + self . __x ) % __MOD__ ) ) <NEWLINE> <DEDENT> elif type ( other ) == ModInt : <NEWLINE> <INDENT> return self . __class__ ( ( other . __x + self . __x ) % __MOD__ ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> raise Exception ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> def __sub__ ( self , other ) : <NEWLINE> <INDENT> if type ( other ) == int : <NEWLINE> <INDENT> other = self . __class__ ( other ) <NEWLINE> return int ( self . __class__ ( ( self . __x - other . __x ) % __MOD__ ) ) <NEWLINE> <DEDENT> elif type ( other ) == ModInt : <NEWLINE> <INDENT> return self . __class__ ( ( self . __x - other . __x ) % __MOD__ ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> raise Exception ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> def __rsub__ ( self , other ) : <NEWLINE> <INDENT> if type ( other ) == int : <NEWLINE> <INDENT> other = self . __class__ ( other ) <NEWLINE> return int ( self . __class__ ( ( other . __x - self . __x ) % __MOD__ ) ) <NEWLINE> <DEDENT> elif type ( other ) == ModInt : <NEWLINE> <INDENT> return self . __class__ ( ( other . __x - self . __x ) % __MOD__ ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> raise Exception ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> def __mul__ ( self , other ) : <NEWLINE> <INDENT> if type ( other ) == int : <NEWLINE> <INDENT> other = self . __class__ ( other ) <NEWLINE> return int ( self . __class__ ( ( self . __x * other . __x ) % __MOD__ ) ) <NEWLINE> <DEDENT> elif type ( other ) == ModInt : <NEWLINE> <INDENT> return self . __class__ ( ( self . __x * other . __x ) % __MOD__ ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> raise Exception ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> def __rmul__ ( self , other ) : <NEWLINE> <INDENT> if type ( other ) == int : <NEWLINE> <INDENT> other = self . __class__ ( other ) <NEWLINE> return int ( self . __class__ ( ( other . __x * self . __x ) % __MOD__ ) ) <NEWLINE> <DEDENT> elif type ( other ) == ModInt : <NEWLINE> <INDENT> return self . __class__ ( ( other . __x * self . __x ) % __MOD__ ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> raise Exception ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> def __truediv__ ( self , other ) : <NEWLINE> <INDENT> if type ( other ) == int : <NEWLINE> <INDENT> other = self . __class__ ( other ) <NEWLINE> return int ( self . __class__ ( ( self . __x * other . __modinv ( ) ) % __MOD__ ) ) <NEWLINE> <DEDENT> elif type ( other ) == ModInt : <NEWLINE> <INDENT> return self . __class__ ( ( self . __x * other . __modinv ( ) ) % __MOD__ ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> raise Exception ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> def __rtruediv__ ( self , other ) : <NEWLINE> <INDENT> if type ( other ) == int : <NEWLINE> <INDENT> other = self . __class__ ( other ) <NEWLINE> return int ( self . __class__ ( ( other . __x * self . __modinv ( ) ) % __MOD__ ) ) <NEWLINE> <DEDENT> elif type ( other ) == ModInt : <NEWLINE> <INDENT> return self . __class__ ( ( other . __x * self . __modinv ( ) ) % __MOD__ ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> raise Exception ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> def __pow__ ( self , other ) : <NEWLINE> <INDENT> if type ( other ) == int : <NEWLINE> <INDENT> other = self . __class__ ( other ) <NEWLINE> return int ( self . __class__ ( pow ( self . __x , other . __x , __MOD__ ) ) ) <NEWLINE> <DEDENT> elif type ( other ) == ModInt : <NEWLINE> <INDENT> return self . __class__ ( pow ( self . __x , other . __x , __MOD__ ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> raise Exception ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> def __rpow__ ( self , other ) : <NEWLINE> <INDENT> if type ( other ) == int : <NEWLINE> <INDENT> other = self . __class__ ( other ) <NEWLINE> return int ( self . __class__ ( pow ( other . __x , self . __x , __MOD__ ) ) ) <NEWLINE> <DEDENT> elif type ( other ) == ModInt : <NEWLINE> <INDENT> return self . __class__ ( pow ( other . __x , self . __x , __MOD__ ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> raise Exception ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> def __modinv ( self , m = __MOD__ ) : <NEWLINE> <INDENT> a = self . __x <NEWLINE> if a == 0 : <NEWLINE> <INDENT> raise ZeroDivisionError ( ) <NEWLINE> <DEDENT> if gcd ( a , m ) != 1 : <NEWLINE> <INDENT> raise Exception ( <STRING> % a ) <NEWLINE> <DEDENT> b , u , v = m , 1 , 0 <NEWLINE> while b != 0 : <NEWLINE> <INDENT> t = a // b ; <NEWLINE> a -= t * b <NEWLINE> a , b = b , a <NEWLINE> u -= t * v <NEWLINE> u , v = v , u <NEWLINE> <DEDENT> u %= m <NEWLINE> if u < 0 : <NEWLINE> <INDENT> u += m <NEWLINE> <DEDENT> return u <NEWLINE> <DEDENT> def __int__ ( self ) : <NEWLINE> <INDENT> return self . __x <NEWLINE> <DEDENT> def __str__ ( self ) : <NEWLINE> <INDENT> return str ( self . __x ) <NEWLINE> <NL> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> N = intinput ( ) <NEWLINE> datas = list ( mulinputs ( ) ) <NEWLINE> <NL> <NL> ds = set ( datas ) <NEWLINE> if len ( ds ) <= 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> ds = list ( ds ) <NEWLINE> ds . sort ( ) <NEWLINE> if ds [ 0 ] == 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> p = [ ] <NEWLINE> <COMMENT> <NL> l = len ( ds ) <NEWLINE> for _ in range ( sqrt ( l ) ) : <NEWLINE> <INDENT> tmp = ds . pop ( 0 ) <NEWLINE> if not ds : <NEWLINE> <INDENT> p . append ( tmp ) <NEWLINE> break <NEWLINE> <DEDENT> ds = [ d for d in ds if d % tmp != 0 ] <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> p . append ( tmp ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> print ( len ( p ) ) <NEWLINE> <DEDENT>
import math <NEWLINE> import collections <NEWLINE> import fractions <NEWLINE> import itertools <NEWLINE> <NL> def solve ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> arr = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> arr . sort ( ) <NEWLINE> s = set ( ) <NEWLINE> cnt = collections . Counter ( arr ) <NEWLINE> for i in ragne ( n ) : <NEWLINE> <INDENT> if arr [ i ] in s : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> elif cnt [ arr [ i ] ] >= 2 : <NEWLINE> <INDENT> s . add ( arr [ i ] ) <NEWLINE> <DEDENT> for j in range ( 2 , 10 ** 6 // arr [ i ] + 1 ) : <NEWLINE> <INDENT> s . add ( arr [ i ] * j ) <NEWLINE> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for i in arr : <NEWLINE> <INDENT> if i in s == False : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> return 0 <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> solve ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> nums = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> nums . sort ( ) <NEWLINE> ans = 0 <NEWLINE> cnt = { } <NEWLINE> flag = [ 0 ] * 1000005 <NEWLINE> for i in range ( 1 , len ( nums ) ) : <NEWLINE> <INDENT> cnt [ i ] = cnt . get ( i , 0 ) + 1 <NEWLINE> <NL> <NL> <DEDENT> for i in nums : <NEWLINE> <INDENT> if flag [ i ] == 0 and cnt [ i ] == 1 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> for j in range ( i * 2 , 1000000 , i ) : <NEWLINE> <INDENT> flag [ j ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> As = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> As . sort ( ) <NEWLINE> amax = max ( As ) + 1 <NEWLINE> lis = [ True ] * amax <NEWLINE> ans = 0 <NEWLINE> <NL> for i in range ( N - 1 ) : <NEWLINE> <INDENT> if lis [ As [ i ] ] : <NEWLINE> <INDENT> for j in range ( As [ i ] , amax , As [ i ] ) : <NEWLINE> <INDENT> lis [ j ] = False <NEWLINE> <DEDENT> if a [ i ] < a [ i + 1 ] : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if lis [ - 1 ] : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> return ans <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <COMMENT> <NL> <INDENT> print ( main ( ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> * A , = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> C = { a : 0 for a in A } <NEWLINE> <NL> for a in A : <NEWLINE> <INDENT> C [ a ] = C [ a ] + 1 <NEWLINE> <NL> <DEDENT> maxA = max ( A ) <NEWLINE> <NL> D = { a : 0 for a in A } <NEWLINE> <NL> for a in A : <NEWLINE> <INDENT> t = 2 <NEWLINE> while a * t <= maxA : <NEWLINE> <INDENT> D [ a * t ] += 1 <NEWLINE> t = t + 1 <NEWLINE> <NL> <DEDENT> <DEDENT> counter = 0 <NEWLINE> for a in A : <NEWLINE> <INDENT> if C [ a ] == 1 and D [ a ] == 0 : <NEWLINE> <INDENT> counter = counter + 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( counter ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> cnt = [ 0 ] * ( 10 ** 6 ) <NEWLINE> <NL> for elem in a : <NEWLINE> <INDENT> if elem not in cnt : <NEWLINE> <INDENT> cnt [ elem ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> unique = [ ] <NEWLINE> <NL> for i in range ( ( 10 ** 6 ) + 1 ) : <NEWLINE> <INDENT> if cnt [ i ] == 1 : <NEWLINE> <INDENT> unique . append ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> cnt = [ 0 ] * ( ( 10 ** 6 ) + 1 ) <NEWLINE> <NL> for elem in unique : <NEWLINE> <INDENT> for m in range ( elem * 2 , ( 10 ** 6 ) + 1 , elem ) : <NEWLINE> <INDENT> cnt [ m ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> ans = 0 <NEWLINE> <NL> a = list ( set ( a ) ) <NEWLINE> <NL> for elem in a : <NEWLINE> <INDENT> if cnt [ elem ] == 0 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import collections <NEWLINE> def check ( val ) : <NEWLINE> <INDENT> flag = 1 <NEWLINE> for v in range ( 2 , int ( val ** 0.5 + 1 ) ) : <NEWLINE> <INDENT> if ( val % v == 0 ) : <NEWLINE> <INDENT> if ( v in x or val // v in x ) : <NEWLINE> <INDENT> flag = 0 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if ( flag ) : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> count = 0 <NEWLINE> x = collections . Counter ( a ) <NEWLINE> if ( 1 in x ) : <NEWLINE> <INDENT> if ( x [ 1 ] == 1 ) : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for each in a : <NEWLINE> <INDENT> if ( x [ each ] == 1 ) : <NEWLINE> <INDENT> check ( each ) <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE> <NL> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a . sort ( reverse = True ) <NEWLINE> p = 0 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> j = i + 1 <NEWLINE> while j < n : <NEWLINE> <INDENT> if i == j : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> elif a [ i ] % a [ j ] == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> if j == n - 1 : <NEWLINE> <INDENT> p += 1 <NEWLINE> j += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( p ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> <NL> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> rcnt = 0 <NEWLINE> length = len ( A ) <NEWLINE> def length ( n , * A ) : <NEWLINE> <NL> <INDENT> for i in range ( length ) : <NEWLINE> <INDENT> if A [ i ] == A [ i + 1 ] : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> if cnt == N : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( length ) : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> for j in range ( length ) : <NEWLINE> <INDENT> if A [ i ] % A [ j ] != 0 and A [ i ] != A [ j ] : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> if cnt == N - 1 : <NEWLINE> <INDENT> rcnt += 1 <NEWLINE> <DEDENT> <DEDENT> print ( rcnt ) <NEWLINE> <DEDENT> length ( * A ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> A = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> max_dp = max ( A ) + 1 <NEWLINE> dp = [ 0 ] * max_dp <NEWLINE> <NL> for a in A : <NEWLINE> <INDENT> if dp [ a ] >= 2 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> dp [ a ] += 1 <NEWLINE> for i in range ( a << 1 , max_dp , a ) : <NEWLINE> <INDENT> dp += 2 <NEWLINE> <DEDENT> <DEDENT> print ( np . sum ( dp == 1 ) ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> readlines = sys . stdin . buffer . readlines <NEWLINE> read = sys . stdin . buffer . read <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> INF = float ( <STRING> ) <NEWLINE> <NL> import collections <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> cA = collections . Counter ( A ) <NEWLINE> <NL> LIM = 10 ** 6 + 10 <NEWLINE> <COMMENT> <NL> <NL> A . sort ( ) <NEWLINE> dp = [ 1 ] * LIM <NEWLINE> <NL> for i in set ( A ) : <NEWLINE> <INDENT> s = i * 2 <NEWLINE> while s <= LIM : <NEWLINE> <INDENT> dp [ s ] = 0 <NEWLINE> s += i <NEWLINE> <NL> <DEDENT> <DEDENT> ans = 0 <NEWLINE> <COMMENT> <NL> for a in A : <NEWLINE> <COMMENT> <NL> <INDENT> if dp [ a ] and cA [ a ] == 1 : <NEWLINE> <COMMENT> <NL> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from collections import Counter <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> C = Counter ( A ) <NEWLINE> <NL> A = set ( A ) <NEWLINE> <NL> MAX_A = 10 ** 6 <NEWLINE> <NL> X = [ 0 ] * ( MAX_A + 1 ) <NEWLINE> <NL> for a in A : <NEWLINE> <INDENT> for i in range ( a , MAX_A + 1 , a ) : <NEWLINE> <INDENT> X [ i ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> ans = len ( [ a for a in A if ( X [ 1 ] == 1 ) and ( C [ a ] == 1 ) ] ) <NEWLINE> <NL> print ( ans ) <NEWLINE>
from collections import Counter <NEWLINE> import bisect <NEWLINE> n = int ( input ( ) ) <COMMENT> <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <COMMENT> <NEWLINE> cnt = Counter ( a ) <COMMENT> <NEWLINE> a . sort ( ) <COMMENT> <NEWLINE> ans = 0 <NEWLINE> mx = 10 ** 6 <NEWLINE> p = [ 0 ] * ( mx + 1 ) <NEWLINE> for i in a : <NEWLINE> <INDENT> if p [ a ] == 0 : <NEWLINE> <INDENT> for j in range ( mx + 1 ) : <NEWLINE> <INDENT> x = i * j <NEWLINE> if x > mx : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> p [ x ] = 1 <COMMENT> <NEWLINE> <DEDENT> if cnt [ a ] == 1 : <NEWLINE> <INDENT> ans += 1 <COMMENT> <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> n , * A = map ( int , f . read ( ) . split ( ) ) <NEWLINE> A . sort ( ) <NEWLINE> n = A [ - 1 ] <NEWLINE> isPrime = [ True ] * ( n + 1 ) <NEWLINE> prep = 0 <NEWLINE> for i in A : <NEWLINE> <INDENT> if prep == i : <NEWLINE> <INDENT> isPrime [ prep ] = False <NEWLINE> continue <NEWLINE> <DEDENT> if isPrime [ i ] : <NEWLINE> <INDENT> for j in range ( i * 2 , n + 1 , i ) : <NEWLINE> <INDENT> isPrime [ j ] = False <NEWLINE> <DEDENT> <DEDENT> prep = i <NEWLINE> <NL> <DEDENT> prep = res = 0 <NEWLINE> for i in A : <NEWLINE> <INDENT> if prep == i : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if isPrime [ i ] : <NEWLINE> <INDENT> res += 1 <NEWLINE> <DEDENT> prep = i <NEWLINE> <DEDENT> print ( res ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> arr = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> d = { } <NEWLINE> for x in arr : <NEWLINE> <INDENT> d [ x ] = d . get ( x , 0 ) + 1 <NEWLINE> <NL> <DEDENT> mxN = 10 ** 6 + 1 <NEWLINE> rp = [ True ] * mxN <NEWLINE> <NL> <NL> for i in range ( 2 , len ( rp ) ) : <NEWLINE> <INDENT> if i not in d or not rp [ i ] : continue <NEWLINE> for j in range ( i + i , mxN , i ) : <NEWLINE> <INDENT> if j in d : rp [ j ] = False <NEWLINE> <NL> <COMMENT> <NL> <NL> <NL> <NL> <DEDENT> <DEDENT> for k , v in d . items ( ) : <NEWLINE> <INDENT> if v > 1 : rp [ k ] = False <NEWLINE> <NL> <DEDENT> ans = sum ( [ ( 1 if rp [ x ] else 0 ) for x in cset ] ) <NEWLINE> print ( ans ) <NEWLINE> <NL> <NL> <NL>
import sys <NEWLINE> readline = sys . stdin . readline <NEWLINE> <NL> import numpy as np <NEWLINE> from collections import Counter <NEWLINE> <NL> <NL> N = int ( input ( ) ) <NEWLINE> A = np . array ( readline ( ) . split ( ) ) <NEWLINE> count = Counter ( A ) <NEWLINE> A = np . array ( [ <NEWLINE> <INDENT> a for a , c in count . items ( ) if c == 1 <NEWLINE> <DEDENT> ] ) <NEWLINE> <NL> if len ( A ) != 0 : <NEWLINE> <INDENT> A = np . sort ( A ) <NEWLINE> <NL> <DEDENT> i = 0 <NEWLINE> while True : <NEWLINE> <INDENT> if len ( A ) == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> pre = A <NEWLINE> a = A [ i ] <NEWLINE> A = np . delete ( A , np . where ( ( A % a == 0 ) & ( A != a ) ) ) <NEWLINE> i += 1 <NEWLINE> if i >= len ( A ) : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( len ( A ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = sorted ( ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> A_Max = A [ - 1 ] <NEWLINE> B = [ True ] * A_Max + 1 <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> if B [ A [ i ] ] : <NEWLINE> <INDENT> for j in range ( 2 , A_Max ) : <NEWLINE> <INDENT> if A [ i ] * j > A_Max : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> B [ A [ i ] * j ] = False <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if B [ A [ i ] ] : <NEWLINE> <INDENT> B [ A [ i ] ] = False <NEWLINE> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL>
find / - name pip <NEWLINE>
import sys <NEWLINE> read = sys . stdin . readline <NEWLINE> import time <NEWLINE> import math <NEWLINE> import itertools as it <NEWLINE> def inp ( ) : <NEWLINE> <INDENT> return int ( input ( ) ) <NEWLINE> <DEDENT> def inpl ( ) : <NEWLINE> <INDENT> return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <DEDENT> st = time . perf_counter ( ) <NEWLINE> <COMMENT> <NL> <NL> N = inp ( ) <NEWLINE> A = inpl ( ) <NEWLINE> A . sort ( ) <NEWLINE> dp = [ False ] * 1001001 <NEWLINE> nt = - 1 <NEWLINE> for i in A : <NEWLINE> <INDENT> if i != nt : <NEWLINE> <INDENT> dp [ i ] = True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dp [ i ] = False <NEWLINE> <DEDENT> nt = i <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> mx = A [ N - 1 ] <NEWLINE> for i in A : <NEWLINE> <INDENT> if dp [ i ] : <NEWLINE> <INDENT> ans += 1 <NEWLINE> j = i <NEWLINE> while j <= 1001001 : <NEWLINE> <INDENT> dp [ j ] = False <NEWLINE> j += i <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <COMMENT> <NL> ed = time . perf_counter ( ) <NEWLINE> print ( <STRING> , ed - st , file = sys . stderr ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = sorted ( a ) <NEWLINE> <NL> max_a = a [ - 1 ] <NEWLINE> dp = [ True ] * max_a <NEWLINE> <NL> for i in a : <NEWLINE> <INDENT> x = 1 <NEWLINE> while i * x <= max_a : <NEWLINE> <INDENT> dp [ i * x ] = False <NEWLINE> x += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for i in a : <NEWLINE> <INDENT> if dp [ i ] : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> MAXX = 10 ** 6 + 5 <NEWLINE> num = np . array ( input ( ) . split ( ) , np . int32 ) [ : ] <NEWLINE> mark = np . zeros ( MAXX , np . int32 ) <NEWLINE> <NL> num = np . sort ( num ) <NEWLINE> for n in num : <NEWLINE> <INDENT> if mark [ n : : n ] < 2 : <NEWLINE> <INDENT> mark [ n : : n ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> count = 0 <NEWLINE> for n in num : <NEWLINE> <INDENT> if mark [ n ] == 1 : <NEWLINE> <INDENT> count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
import sys <NEWLINE> import numpy as np <NEWLINE> input = lambda : sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = sorted ( [ i for i in a if a . count ( i ) == 1 ] ) <NEWLINE> a = np . array ( a ) <NEWLINE> ans = [ ] <NEWLINE> if let ( set ( a ) ) == 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> return <NEWLINE> <DEDENT> while a != [ ] : <NEWLINE> <INDENT> ans . append ( a [ 0 ] ) <NEWLINE> a = a [ a % a [ 0 ] != 0 ] <NEWLINE> <DEDENT> print ( len ( ans ) + 1 ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
<NL> def make_divisors ( n ) : <NEWLINE> <INDENT> lower_divisors , upper_divisors = [ ] , [ ] <NEWLINE> i = 1 <NEWLINE> while i * i <= n : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> lower_divisors . append ( i ) <NEWLINE> if i != n // i : <NEWLINE> <INDENT> upper_divisors . append ( n // i ) <NEWLINE> <DEDENT> <DEDENT> i += 1 <NEWLINE> <DEDENT> return lower_divisors [ 1 : ] + upper_divisors [ : : - 1 ] <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> N = int ( input ( ) ) <NEWLINE> As = list ( map ( int , ( input ( ) . split ( ) ) ) ) <NEWLINE> <NL> As . sort ( ) <NEWLINE> print ( As ) <NEWLINE> <NL> warusu = set ( ) <NEWLINE> ans = 0 <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> for A1 in As : <NEWLINE> <INDENT> for A2 in sorted ( As , reverse = True ) : <NEWLINE> <INDENT> if A2 % A1 == 0 : <NEWLINE> <INDENT> As . remove ( A1 ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> print ( len ( As ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> w = max ( b ) <NEWLINE> a = [ 0 ] * w <NEWLINE> for i in b : <NEWLINE> <INDENT> x = i <NEWLINE> while x < w : <NEWLINE> <INDENT> a [ x ] = 1 <NEWLINE> x += i <NEWLINE> <DEDENT> <DEDENT> for i in b : <NEWLINE> <INDENT> if a [ i ] == 0 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT>
from sys import stdin <NEWLINE> <NL> n = [ int ( x ) for x in stdin . readline ( ) . rstrip ( ) . split ( ) ] <NEWLINE> P = [ int ( x ) for x in stdin . readline ( ) . rstrip ( ) . split ( ) ] <NEWLINE> <NL> rest_lists = [ ] <NEWLINE> <NL> P . sort ( ) <NEWLINE> <NL> def return_filtered ( div , rl ) : <NEWLINE> <INDENT> new = [ ] <NEWLINE> protect = True <NEWLINE> for tgt in rl : <NEWLINE> <INDENT> if protect and tgt == div : <NEWLINE> <INDENT> new . append ( tgt ) <NEWLINE> protect = False <NEWLINE> <DEDENT> elif tgt == div and len ( new ) > 0 : <NEWLINE> <INDENT> new . pop ( ) <NEWLINE> <DEDENT> elif not tgt % div == 0 : <NEWLINE> <INDENT> new . append ( tgt ) <NEWLINE> <DEDENT> <DEDENT> print ( new ) <NEWLINE> return new <NEWLINE> <NL> <DEDENT> new_list = P <NEWLINE> k = 0 <NEWLINE> while True : <NEWLINE> <INDENT> if len ( new_list ) == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> k += 1 <NEWLINE> if 1 + k > len ( new_list ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> new_list = return_filtered ( new_list [ 1 + k ] , new_list ) <NEWLINE> <NL> <DEDENT> print ( len ( new_list ) ) <NEWLINE>
from collections import Counter <NEWLINE> from numba import jit <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) . strip ( ) ) <NEWLINE> L = list ( map ( int , input ( ) . strip ( ) . split ( ) ) ) <NEWLINE> seen = Counter ( ) <NEWLINE> <NL> <NL> for x in L : <NEWLINE> <INDENT> seen [ x ] += 1 <NEWLINE> <DEDENT> @ jit <NEWLINE> def loop ( ) : <NEWLINE> <INDENT> ans = 0 <NEWLINE> for x in L : <NEWLINE> <INDENT> if seen [ x ] > 1 or x != 1 and 1 in seen : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <DEDENT> tmp = 2 <NEWLINE> while tmp ** 2 <= x : <NEWLINE> <INDENT> if x % tmp == 0 and ( tmp in seen or x / tmp in seen ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> tmp += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> return ans <NEWLINE> <DEDENT> print ( loop ( ) ) <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> if <STRING> == __name__ : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A . sort ( ) <NEWLINE> d = { } <NEWLINE> n = A [ - 1 ] <NEWLINE> def makePrimeChecker ( n ) : <NEWLINE> <INDENT> isPrime = [ True ] * ( n + 1 ) <NEWLINE> isPrime [ 0 ] = False <NEWLINE> isPrime [ 1 ] = False <NEWLINE> i = 0 <NEWLINE> for j in A : <NEWLINE> <INDENT> if i == j : <NEWLINE> <INDENT> d [ i ] = 1 <NEWLINE> <DEDENT> i = j <NEWLINE> if i > 10 ** 3 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if isPrime [ i ] : <NEWLINE> <INDENT> for j in range ( i * i , n + 1 , i ) : <NEWLINE> <INDENT> isPrime [ j ] = False <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return isPrime <NEWLINE> <DEDENT> P = makePrimeChecker ( n ) <NEWLINE> i = 0 <NEWLINE> ans = 0 <NEWLINE> for j in A : <NEWLINE> <INDENT> if i == j : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> i = j <NEWLINE> if P [ i ] : <NEWLINE> <INDENT> if d [ i ] == 0 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from numba import njit <NEWLINE> <NL> <NL> @ njit ( cache = True ) <NEWLINE> def fact ( x ) : <NEWLINE> <INDENT> i = 1 <NEWLINE> while i * i <= x : <NEWLINE> <INDENT> if x % i == 0 : <NEWLINE> <INDENT> yield i <NEWLINE> yield x // i <NEWLINE> <DEDENT> i += 1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> a = tuple ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> c = [ 0 ] * ( max ( a ) + 1 ) <NEWLINE> <NL> for e in a : <NEWLINE> <INDENT> c [ e ] += 1 <NEWLINE> <NL> <DEDENT> ans = n <NEWLINE> for e in a : <NEWLINE> <INDENT> c [ e ] -= 1 <NEWLINE> for fct in fact ( e ) : <NEWLINE> <INDENT> if c [ fct ] : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> c [ e ] += 1 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a . sort ( ) <NEWLINE> dp = [ 0 ] * ( 1000000 + 1 ) <NEWLINE> cnt = 0 <NEWLINE> for i in range ( len ( a ) ) : <NEWLINE> <INDENT> if dp [ a [ i ] ] == 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> while ( a [ i ] * j <= a [ - 1 ] ) : <NEWLINE> <INDENT> dp [ a [ i ] * j ] = 1 <NEWLINE> j += 1 <NEWLINE> <DEDENT> if i != len ( a ) - 1 and a [ i + 1 ] == a [ i ] : <NEWLINE> <INDENT> dp [ a [ i ] ] = 1 <NEWLINE> continue <NEWLINE> <DEDENT> cnt += 1 <NEWLINE> dp [ a [ i ] ] = 1 <NEWLINE> j = 2 <NEWLINE> <DEDENT> print ( cnt ) <NEWLINE>
import sys <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , sys . stdin . readline ( ) [ : - 1 ] ) ) <NEWLINE> <NL> A . sort ( ) <NEWLINE> if len ( A ) == 1 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> sys . exit ( 0 ) <NEWLINE> <DEDENT> elif A [ 0 ] == A [ - 1 ] : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> sys . exit ( 0 ) <NEWLINE> <DEDENT> elif A [ 0 ] == 1 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> sys . exit ( 0 ) <NEWLINE> <NL> <NL> <DEDENT> d = [ ] <NEWLINE> <NL> for i in range ( len ( A ) ) : <NEWLINE> <INDENT> flag = True <NEWLINE> for j in d : <NEWLINE> <INDENT> if A [ i ] % j == 0 : <NEWLINE> <INDENT> flag = False <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if flag : <NEWLINE> <INDENT> d . append ( A [ i ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( len ( d ) ) <NEWLINE>
import sys <NEWLINE> import numpy as np <NEWLINE> <NL> read = sys . stdin . buffer . read <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> readlines = sys . stdin . buffer . readlines <NEWLINE> <NL> U = 10 ** 6 + 10 <NEWLINE> <NL> def main ( A , primes ) : <NEWLINE> <INDENT> B = np . zeros ( U + 1 , np . int64 ) <NEWLINE> for x in A : <NEWLINE> <INDENT> B [ x ] += 1 <NEWLINE> <DEDENT> for p in primes : <NEWLINE> <INDENT> for i in range ( U // p + 1 ) : <NEWLINE> <INDENT> B [ p * i ] += B [ i ] <NEWLINE> <DEDENT> <DEDENT> ret = 0 <NEWLINE> for x in A : <NEWLINE> <INDENT> ret += B [ x ] == 1 <NEWLINE> <DEDENT> return ret <NEWLINE> <NL> <DEDENT> if sys . argv [ - 1 ] == <STRING> : <NEWLINE> <INDENT> from numba . pycc import CC <NEWLINE> cc = CC ( <STRING> ) <NEWLINE> cc . export ( <STRING> , <STRING> ) ( main ) <NEWLINE> cc . compile ( ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> from my_module import main <NEWLINE> <NL> def prime_table ( N ) : <NEWLINE> <INDENT> is_prime = np . zeros ( N , np . int64 ) <NEWLINE> is_prime [ 2 : 3 ] = 1 <NEWLINE> is_prime [ 3 : : 2 ] = 1 <NEWLINE> for p in range ( 3 , N , 2 ) : <NEWLINE> <INDENT> if p * p >= N : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if is_prime [ p ] : <NEWLINE> <INDENT> is_prime [ p * p : : p + p ] = 0 <NEWLINE> <DEDENT> <DEDENT> return is_prime , np . where ( is_prime ) [ 0 ] <NEWLINE> <NL> <DEDENT> A = np . array ( read ( ) . split ( ) , np . int64 ) [ 1 : ] <NEWLINE> _ , primes = prime_table ( U ) <NEWLINE> <NL> print ( solve ( A , primes ) ) <NEWLINE>
<COMMENT> <NL> <NL> <NL> n = int ( input ( ) ) <NEWLINE> lis = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> lis . sort ( ) <NEWLINE> MAX = lis [ - 1 ] <NEWLINE> lis2 = [ 0 ] * MAX <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> ans = 0 <NEWLINE> <NL> for num in lis : <NEWLINE> <INDENT> for i in range ( num , MAX , num ) : <NEWLINE> <INDENT> lis2 [ i ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> for j in set ( lis ) : <NEWLINE> <INDENT> if lis2 [ j ] == 1 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> D = [ 0 ] * ( 10 ** 6 + 1 ) <NEWLINE> for i in A : <NEWLINE> <COMMENT> <NL> <INDENT> D [ i ] += 1 <NEWLINE> <NL> <DEDENT> U = [ ] <NEWLINE> for i in range ( 10 ** 6 + 1 ) : <NEWLINE> <COMMENT> <NL> <INDENT> if D [ i ] == 1 : <NEWLINE> <INDENT> U . append ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> A = list ( set ( A ) ) <NEWLINE> <NL> T = [ 0 ] * ( max ( A ) + 1 ) <NEWLINE> for i in A : <NEWLINE> <COMMENT> <NL> <INDENT> for j in range ( 2 * i , 10 ** 6 + 1 , i ) : <NEWLINE> <INDENT> T [ j ] = 1 <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for i in U : <NEWLINE> <INDENT> if T [ i ] == 0 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<NL> <INDENT> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> A = sorted ( A ) <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> Ai = A [ i ] <NEWLINE> is_divisible = False <NEWLINE> for j in range ( i ) : <NEWLINE> <INDENT> Aj = A [ j ] <NEWLINE> if Aj ** 2 > Ai : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if Ai % Aj == 0 : <NEWLINE> <INDENT> is_divisible = True <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if not is_divisible : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import copy <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A . sort ( ) <NEWLINE> B = copy . copy ( A ) <NEWLINE> cnt = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if A . count ( A [ i ] ) > 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> for j in range ( len ( B ) ) : <NEWLINE> <INDENT> if 2 * B [ j ] > A [ i ] : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> break <NEWLINE> <DEDENT> if A [ i ] % B [ j ] == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if j <NEWLINE> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> A = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> Max = max ( A ) <NEWLINE> cnt_dict = collections . Counter ( A ) <NEWLINE> <COMMENT> <NL> Dict = { a : True for a in A } <NEWLINE> for a in A : <NEWLINE> <INDENT> times = 2 <NEWLINE> while a * times <= Max : <NEWLINE> <INDENT> Dict [ a * times ] = False <NEWLINE> times += 1 <NEWLINE> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for a in A : <NEWLINE> <INDENT> if cnt_dict [ a ] == 1 and Dict [ a ] : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> <COMMENT> <NL> rm = 0 <NEWLINE> for i in A : <NEWLINE> <INDENT> if A . count ( i ) != 1 : <NEWLINE> <INDENT> rm += 1 <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> T = [ 0 ] * ( 10 ** 6 + 1 ) <NEWLINE> for i in A : <NEWLINE> <INDENT> j = 1 <NEWLINE> while ( i * j <= 10 ** 6 ) : <NEWLINE> <INDENT> T [ i * j ] += 1 <NEWLINE> j += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> ans = - len ( rmlst ) <NEWLINE> for i in A : <NEWLINE> <INDENT> if T [ i ] == 1 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> <NL> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> b = sorted ( list ( A ) ) <NEWLINE> dp = [ 0 ] * ( max ( A ) + 4 ) <NEWLINE> <NL> m_a = max ( A ) <NEWLINE> for i in b : <NEWLINE> <INDENT> dp [ i ] += 1 <NEWLINE> if dp [ i ] == 1 : <NEWLINE> <INDENT> for j in range ( i * 2 , m_a , i ) : <NEWLINE> <INDENT> dp [ j * i ] += 100 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( dp . count ( 1 ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> from collections import Counter <NEWLINE> c = Counter ( A ) <NEWLINE> sorted_key = sorted ( c . keys ( ) , reverse = True ) <NEWLINE> res = [ 0 ] * len ( sorted_key ) <NEWLINE> ans = n <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> for key in sorted_key : <NEWLINE> <INDENT> if c [ key ] > 1 : <NEWLINE> <INDENT> ans -= c [ key ] <NEWLINE> continue <NEWLINE> <DEDENT> for j in range ( len ( sorted_key ) - 1 , i , - 1 ) : <NEWLINE> <COMMENT> <NL> <INDENT> if ( key / sorted_key [ j ] >= 1 ) and ( key % sorted_key [ j ] ) == 0 : <NEWLINE> <COMMENT> <NL> <INDENT> ans -= c [ key ] <NEWLINE> <COMMENT> <NL> break <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> <STRING> <NEWLINE> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( sorted ( a ) ) <NEWLINE> big = a [ n - 1 ] <NEWLINE> mark = [ 0 ] * big <NEWLINE> for x in a : <NEWLINE> <INDENT> mark [ x ] += 1 <NEWLINE> if mark [ x ] > 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> for j in range ( x * 2 , big + 1 , x ) : <NEWLINE> <INDENT> mark [ j ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for x in a : <NEWLINE> <INDENT> if mark [ x ] == 1 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> setA = set ( A ) <NEWLINE> result = 0 <NEWLINE> <NL> if N == 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( N ) : <NEWLINE> <INDENT> tmp = A [ i ] <NEWLINE> A [ i ] = 0 <NEWLINE> setA = set ( A ) <NEWLINE> A [ i ] = tmp <NEWLINE> if 1 in setA : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <DEDENT> for a in setA : <NEWLINE> <INDENT> if A [ i ] % a == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> result += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( result ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> n , * a = map ( int , open ( 0 ) . read ( ) . split ( ) ) <NEWLINE> if n == 1 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> m = max ( a ) + 1 <NEWLINE> l = [ 0 ] * m <NEWLINE> for i in a : <NEWLINE> <INDENT> for j in range ( i , m , i ) : <NEWLINE> <INDENT> l [ j ] += 2 <NEWLINE> <DEDENT> l [ i ] -= 1 <NEWLINE> <NL> <DEDENT> ans = sum ( a [ i ] == - 1 for i in a ) <NEWLINE> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
from copy import deepcopy <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> if len ( set ( A ) ) == 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> search_list = deepcopy ( A ) <NEWLINE> ans = 0 <NEWLINE> <NL> tmp = min ( search_list ) <NEWLINE> smax = int ( max ( search_list ) ** 0.5 ) + 1 <NEWLINE> <NL> while search_list : <NEWLINE> <INDENT> ans += 1 <NEWLINE> search_list = [ i for i in search_list if i % tmp != 0 ] <NEWLINE> tmp = min ( search_list ) <NEWLINE> if tmp < smax : <NEWLINE> <INDENT> ans += len ( search_list ) <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> from numba import njit <NEWLINE> <NL> @ njit ( cache = True ) <NEWLINE> def solve ( a , n ) : <NEWLINE> <INDENT> ava = [ 0 ] * a [ - 1 ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( n ) : <NEWLINE> <INDENT> if a [ j ] % a [ i ] == 0 and ava [ a [ j ] - 1 ] < 2 : <NEWLINE> <INDENT> ava [ a [ j ] - 1 ] += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return ava . count ( 1 ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> n = int ( sys . stdin . readline ( ) . rstrip ( ) ) <NEWLINE> a = list ( map ( int , sys . stdin . readline ( ) . rstrip ( ) . split ( ) ) ) <NEWLINE> a . sort ( ) <NEWLINE> print ( solve ( a , n ) ) <NEWLINE> <DEDENT>
import collections <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> arr = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> arr = sorted ( arr ) <NEWLINE> s = set ( ) <NEWLINE> cnt = collections . Counter ( arr ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> if arr [ i ] in s : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if cnt [ arr [ i ] ] >= 2 : <NEWLINE> <INDENT> s . add ( arr [ i ] ) <NEWLINE> <DEDENT> for j in range ( 2 , 10 ** 6 // arr [ i ] + 1 ) : <NEWLINE> <INDENT> s . add ( arr [ i ] * j ) <NEWLINE> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if arr [ i ] in s : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> ans += 1 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE> import collections <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> arr = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> arr = sorted ( arr ) <NEWLINE> s = set ( ) <NEWLINE> cnt = collections . Counter ( arr ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> if arr [ i ] in s : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if cnt [ arr [ i ] ] >= 2 : <NEWLINE> <INDENT> s . add ( arr [ i ] ) <NEWLINE> <DEDENT> for j in range ( 2 , 10 ** 6 // arr [ i ] + 1 ) : <NEWLINE> <INDENT> s . add ( arr [ i ] * j ) <NEWLINE> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if arr [ i ] in s : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> ans += 1 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
def ii ( ) : return int ( input ( ) ) <NEWLINE> def iim ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def iil ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> from collections import deque <NEWLINE> <NL> <NL> def bfs ( xg , yg ) : <NEWLINE> <INDENT> queue = deque ( [ ( xs , ys , 0 ) ] ) <NEWLINE> while queue : <NEWLINE> <INDENT> x , y , dep = queue . popleft ( ) <NEWLINE> l = [ ] <NEWLINE> for xx , yy in [ ( 1 , 0 ) , ( 0 , 1 ) , ( - 1 , 0 ) , ( 0 , - 1 ) ] : <NEWLINE> <INDENT> for i in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> nx , ny = x + xx * i , y + yy * i <NEWLINE> if cord [ ny ] [ nx ] == <STRING> : <NEWLINE> <INDENT> l . append ( ( nx , ny ) ) <NEWLINE> <DEDENT> elif cord [ ny ] [ nx ] < dep + 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> for nx , ny in l : <NEWLINE> <INDENT> if cord [ ny ] [ nx ] == <STRING> : <NEWLINE> <INDENT> cord [ ny ] [ nx ] = dep + 1 <NEWLINE> if ( nx , ny ) == ( xg , yg ) : <NEWLINE> <INDENT> return dep + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> queue . append ( ( nx , ny , dep + 1 ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> return - 1 <NEWLINE> <NL> <DEDENT> h , w , k = iim ( ) <NEWLINE> ys , xs , yg , xg = iim ( ) <NEWLINE> <NL> cord = [ [ <STRING> ] * ( w + 2 ) ] <NEWLINE> for i in range ( h ) : <NEWLINE> <INDENT> cord . append ( [ <STRING> ] + list ( input ( ) ) + [ <STRING> ] ) <NEWLINE> <DEDENT> cord . append ( [ <STRING> ] * ( w + 2 ) ) <NEWLINE> cord [ ys ] [ xs ] = <STRING> <NEWLINE> <NL> print ( bfs ( xg , yg ) ) <NEWLINE>
from collections import deque <NEWLINE> h , w , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a , b , c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> a -= 1 <NEWLINE> b -= 1 <NEWLINE> c -= 1 <NEWLINE> d -= 1 <NEWLINE> maze = [ input ( ) for _ in range ( h ) ] <NEWLINE> dx = [ 1 , - 1 , 0 , 0 ] <NEWLINE> dy = [ 0 , 0 1 , - 1 ] <NEWLINE> depth = [ [ float ( <STRING> ) for _ in range ( w ) ] for _ in range ( h ) ] <NEWLINE> dq = deque ( [ b , a ] ) <NEWLINE> depth [ a ] [ b ] = 0 <NEWLINE> while dq : <NEWLINE> <INDENT> x , y == dq . popleft ( ) <NEWLINE> if x == d and y == c : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for i in range ( 4 ) : <NEWLINE> <INDENT> nx , ny , K = x , y , k <NEWLINE> while K : <NEWLINE> <INDENT> K -= 1 <NEWLINE> nx += dx [ i ] <NEWLINE> ny += dy [ i ] <NEWLINE> if 0 <= nx <= w - 1 and 0 <= ny <= h - 1 and maze [ nx ] [ ny ] != <STRING> and depth [ nx ] [ ny ] > depth [ y ] [ x ] : <NEWLINE> <INDENT> if depth [ ny ] [ nx ] == depth [ y ] [ x ] + 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> depth [ ny ] [ nx ] = depth [ y ] [ x ] + 1 <NEWLINE> dq . append ( ( nx , ny ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( depth [ c ] [ d ] if depth [ c ] [ d ] != float ( <STRING> ) else - 1 ) <NEWLINE> <NL> <NL>
import sys <NEWLINE> from collections import deque <NEWLINE> <NL> <NL> def bfs ( x1 , y1 , d ) : <NEWLINE> <INDENT> q = deque ( [ ] ) <NEWLINE> q . append ( ( d , x1 , y1 ) ) <NEWLINE> M [ x1 ] [ y1 ] = d <NEWLINE> <NL> while q : <NEWLINE> <INDENT> d , x1 , y1 = q . popleft ( ) <NEWLINE> <NL> if [ x1 , y1 ] == [ xg , yg ] : <NEWLINE> <INDENT> print ( d ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> for dx , dy in ( ( 0 , 1 ) , ( 1 , 0 ) , ( 0 , - 1 ) , ( - 1 , 0 ) ) : <NEWLINE> <INDENT> for k in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> x2 = x1 + dx * k <NEWLINE> y2 = y1 + dy * k <NEWLINE> if m [ x2 ] [ y2 ] == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if x2 < 0 or x2 >= H : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if y2 < 0 or y2 >= W : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if M [ x2 ] [ y2 ] < d + 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if M [ x2 ] [ y2 ] == d + 1 : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <DEDENT> q . append ( ( d + 1 , x2 , y2 ) ) <NEWLINE> M [ x2 ] [ y2 ] = d + 1 <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> print ( - 1 ) <NEWLINE> <NL> <NL> <DEDENT> H , W , K = map ( int , sys . stdin . readline ( ) . strip ( ) . split ( ) ) <NEWLINE> xs , ys , xg , yg = map ( int , sys . stdin . readline ( ) . strip ( ) . split ( ) ) <NEWLINE> xg -= 1 <NEWLINE> yg -= 1 <NEWLINE> <NL> m = [ ] <NEWLINE> for _ in range ( H ) : <NEWLINE> <INDENT> m . append ( list ( map ( str , sys . stdin . readline ( ) . strip ( ) ) ) ) <NEWLINE> <NL> <DEDENT> M = [ [ - 1 ] * W for _ in range ( H ) ] <NEWLINE> <NL> bfs ( xs - 1 , ys - 1 , 0 ) <NEWLINE>
<NL> def main ( ) : <NEWLINE> <INDENT> h , w , k = map ( int , input ( ) . split ( ) ) <NEWLINE> x1 , y1 , x2 , y2 = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <COMMENT> <NL> c = [ [ <STRING> ] * ( w + 2 ) ] <NEWLINE> for _ in range ( h ) : <NEWLINE> <INDENT> i = input ( ) <NEWLINE> l = [ <STRING> ] <NEWLINE> for j in i : <NEWLINE> <INDENT> l . append ( j ) <NEWLINE> <DEDENT> l . append ( <STRING> ) <NEWLINE> c . append ( l ) <NEWLINE> <DEDENT> c . append ( [ <STRING> ] * ( w + 2 ) ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> seen = [ [ - 1 ] * ( w + 2 ) for _ in range ( h + 2 ) ] <NEWLINE> <NL> <COMMENT> <NL> todo = [ ( 0 , x1 , y1 , 0 ) ] <NEWLINE> heapq . heapify ( todo ) <NEWLINE> <NL> <COMMENT> <NL> dx = [ - 1 , 0 , 1 , 0 ] <NEWLINE> dy = [ 0 , 1 , 0 , - 1 ] <NEWLINE> <NL> while len ( todo ) > 0 : <NEWLINE> <INDENT> cost , xi , yi , direction = heapq . heappop ( todo ) <NEWLINE> <NL> <COMMENT> <NL> if seen [ xi ] [ yi ] != - 1 : <NEWLINE> <INDENT> if ( seen [ xi ] [ yi ] + k - 1 ) // k * k > cost : <NEWLINE> <INDENT> xj , yj = xi + dx [ direction ] , yi + dy [ direction ] <NEWLINE> if c [ xj ] [ yj ] == <STRING> : <NEWLINE> <INDENT> heapq . heappush ( todo , ( cost + 1 , xj , yj , direction ) ) <NEWLINE> <DEDENT> <DEDENT> continue <NEWLINE> <DEDENT> seen [ xi ] [ yi ] = cost <NEWLINE> <NL> <COMMENT> <NL> if xi == x2 and yi == y2 : <NEWLINE> <INDENT> print ( ( cost + k - 1 ) // k ) <NEWLINE> exit ( ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> for j in range ( 4 ) : <NEWLINE> <INDENT> xj , yj = xi + dx [ j ] , yi + dy [ j ] <NEWLINE> if c [ xj ] [ yj ] == <STRING> : <NEWLINE> <INDENT> if j == direction : <NEWLINE> <INDENT> if seen [ xj ] [ yj ] == - 1 or ( seen [ xj ] [ yj ] + k - 1 ) // k * k > cost : <NEWLINE> <INDENT> heapq . heappush ( todo , ( cost + 1 , xj , yj , j ) ) <NEWLINE> <DEDENT> <DEDENT> elif seen [ xj ] [ yj ] == - 1 : <NEWLINE> <INDENT> heapq . heappush ( todo , ( ( cost + k - 1 ) // k * k + 1 , xj , yj , j ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( - 1 ) <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE>
<COMMENT> <NL> from heapq import heappop , heappush <NEWLINE> import sys <NEWLINE> input = sys . stdin . buffer . readline <NEWLINE> INF = 10 ** 10 <NEWLINE> <COMMENT> <NL> <NL> try : <NEWLINE> <INDENT> profile <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> def profile ( f ) : return f <NEWLINE> <NL> <DEDENT> DEBUG = True <NEWLINE> if DEBUG : <NEWLINE> <INDENT> def dp ( * x ) : <COMMENT> <NEWLINE> <INDENT> print ( * x ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> def dp ( * x ) : pass <NEWLINE> <NL> <NL> <DEDENT> @ profile <NEWLINE> def main ( H , W , K , x1 , y1 , x2 , y2 , mapdata ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <INDENT> start = ( x1 , y1 ) <NEWLINE> goal = x2 * W + y2 <NEWLINE> <NL> distances = { } <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> key = ( x1 * W + y1 ) * 5 + 0 <NEWLINE> distances [ key ] = ( 0 , 0 ) <NEWLINE> <NL> shortest_path = { } <NEWLINE> shortest_path [ key ] = 0 <NEWLINE> <NL> queue = [ ( ( 0 , 0 ) , key ) ] <NEWLINE> DIRS = [ ( 1 , 0 ) , ( - 1 , 0 ) , ( 0 , 1 ) , ( 0 , - 1 ) ] <NEWLINE> while queue : <NEWLINE> <INDENT> ( d , frac ) , pos_dir = heappop ( queue ) <NEWLINE> pos , direction = divmod ( pos_dir , 5 ) <NEWLINE> x , y = divmod ( pos , W ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> dist = distances . get ( pos_dir , INF ) <NEWLINE> if dist < ( d , frac ) : <NEWLINE> <COMMENT> <NL> <INDENT> continue <NEWLINE> <DEDENT> if pos == goal : <NEWLINE> <INDENT> break <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> dx , dy = DIRS [ direction ] <NEWLINE> nx = x + dx <NEWLINE> ny = y + dy <NEWLINE> <COMMENT> <NL> if mapdata [ nx * W + ny ] : <NEWLINE> <INDENT> if frac == 0 : <NEWLINE> <INDENT> newd = d + 1 <NEWLINE> newfrac = - K + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> newd = d <NEWLINE> newfrac = frac + 1 <NEWLINE> <DEDENT> newdist = ( newd , newfrac ) <NEWLINE> to = ( nx * W + ny ) * 5 + direction <NEWLINE> <NL> if distances . get ( to , ( INF , 0 ) ) > newdist : <NEWLINE> <COMMENT> <NL> <INDENT> distances [ to ] = newdist <NEWLINE> heappush ( queue , ( newdist , to ) ) <NEWLINE> shortest_path [ to ] = pos_dir <NEWLINE> <NL> <DEDENT> <DEDENT> if direction < 2 : <NEWLINE> <COMMENT> <NL> <INDENT> dir = 2 <NEWLINE> nx = x <NEWLINE> ny = y + 1 <NEWLINE> if mapdata [ nx * W + ny ] : <NEWLINE> <INDENT> newdist = ( d + 1 , - K + 1 ) <NEWLINE> <NL> to = ( nx * W + ny ) * 5 + dir <NEWLINE> if distances . get ( to , ( INF , 0 ) ) > newdist : <NEWLINE> <COMMENT> <NL> <INDENT> distances [ to ] = newdist <NEWLINE> heappush ( queue , ( newdist , to ) ) <NEWLINE> shortest_path [ to ] = pos_dir <NEWLINE> <NL> <DEDENT> <DEDENT> dir = 3 <NEWLINE> nx = x <NEWLINE> ny = y - 1 <NEWLINE> if mapdata [ nx * W + ny ] : <NEWLINE> <INDENT> newdist = ( d + 1 , - K + 1 ) <NEWLINE> <NL> to = ( nx * W + ny ) * 5 + dir <NEWLINE> if distances . get ( to , ( INF , 0 ) ) > newdist : <NEWLINE> <COMMENT> <NL> <INDENT> distances [ to ] = newdist <NEWLINE> heappush ( queue , ( newdist , to ) ) <NEWLINE> shortest_path [ to ] = pos_dir <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <COMMENT> <NL> <INDENT> dir = 0 <NEWLINE> nx = x + 1 <NEWLINE> ny = y <NEWLINE> if mapdata [ nx * W + ny ] : <NEWLINE> <INDENT> newdist = ( d + 1 , - K + 1 ) <NEWLINE> <NL> to = ( nx * W + ny ) * 5 + dir <NEWLINE> if distances . get ( to , ( INF , 0 ) ) > newdist : <NEWLINE> <COMMENT> <NL> <INDENT> distances [ to ] = newdist <NEWLINE> heappush ( queue , ( newdist , to ) ) <NEWLINE> shortest_path [ to ] = pos_dir <NEWLINE> <NL> <DEDENT> <DEDENT> dir = 1 <NEWLINE> nx = x - 1 <NEWLINE> ny = y <NEWLINE> if mapdata [ nx * W + ny ] : <NEWLINE> <INDENT> newdist = ( d + 1 , - K + 1 ) <NEWLINE> <NL> to = ( nx * W + ny ) * 5 + dir <NEWLINE> if distances . get ( to , ( INF , 0 ) ) > newdist : <NEWLINE> <COMMENT> <NL> <INDENT> distances [ to ] = newdist <NEWLINE> heappush ( queue , ( newdist , to ) ) <NEWLINE> shortest_path [ to ] = pos_dir <NEWLINE> <NL> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> dist = min ( [ <NEWLINE> <INDENT> distances . get ( goal * 5 , ( INF , 0 ) ) , <NEWLINE> distances . get ( goal * 5 + 1 , ( INF , 0 ) ) , <NEWLINE> distances . get ( goal * 5 + 2 , ( INF , 0 ) ) , <NEWLINE> distances . get ( goal * 5 + 3 , ( INF , 0 ) ) , <NEWLINE> <DEDENT> ] ) <NEWLINE> if dist [ 0 ] == INF : <NEWLINE> <COMMENT> <NL> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( dist [ 0 ] ) <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> if sys . argv [ - 1 ] == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> from numba . pycc import CC <NEWLINE> cc = CC ( <STRING> ) <NEWLINE> cc . export ( <STRING> , <STRING> ) ( main ) <NEWLINE> <COMMENT> <NL> cc . compile ( ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> H , W , K = map ( int , input ( ) . split ( ) ) <NEWLINE> x1 , y1 , x2 , y2 = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> from my_module import main <NEWLINE> import numpy as np <NEWLINE> C = np . zeros ( ( H + 2 , W + 2 ) , np . bool_ ) <NEWLINE> data = np . frombuffer ( <NEWLINE> <INDENT> sys . stdin . buffer . read ( ) , <NEWLINE> <STRING> ) <NEWLINE> <COMMENT> <NL> <DEDENT> data = data . reshape ( H , - 1 ) <NEWLINE> <COMMENT> <NL> data = data [ : , : W ] == <STRING> <NEWLINE> <COMMENT> <NL> C [ 1 : - 1 , 1 : - 1 ] = data <NEWLINE> C = C . ravel ( ) <NEWLINE> H += 2 <NEWLINE> W += 2 <NEWLINE> <NL> main ( H , W , K , x1 , y1 , x2 , y2 , C ) <NEWLINE> <DEDENT>
<COMMENT> <NL> import sys <NEWLINE> def input ( ) : return sys . stdin . readline ( ) . strip ( ) <NEWLINE> def INT ( ) : return int ( input ( ) ) <NEWLINE> def MAP ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def LIST ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> def ZIP ( n ) : return [ LIST ( ) for _ in range ( n ) ] <NEWLINE> <NL> @ profile <NEWLINE> def main ( ) : <NEWLINE> <INDENT> from heapq import heappush , heappop , heapify <NEWLINE> H , W , K = MAP ( ) <NEWLINE> HH = max ( H , W ) + 2 <NEWLINE> x1 , y1 , x2 , y2 = LIST ( ) <NEWLINE> c = [ [ - 1 ] + [ 0 if c == <STRING> else - 1 for c in input ( ) ] + [ - 1 ] <NEWLINE> <INDENT> for i in range ( H ) ] <NEWLINE> <DEDENT> c = [ [ - 1 ] * ( W + 2 ) ] + c + [ [ - 1 ] * ( W + 2 ) ] <NEWLINE> <NL> <COMMENT> <NL> stack = [ ] <NEWLINE> heappush ( stack , ( 0 , x1 , y1 , 0 ) ) <NEWLINE> heappush ( stack , ( 0 , x1 , y1 , 1 ) ) <NEWLINE> heappush ( stack , ( 0 , x1 , y1 , 2 ) ) <NEWLINE> heappush ( stack , ( 0 , x1 , y1 , 3 ) ) <NEWLINE> DX = ( 1 , 0 , - 1 , 0 ) <NEWLINE> DY = ( 0 , 1 , 0 , - 1 ) <NEWLINE> while stack : <NEWLINE> <INDENT> new_stack = [ ] <NEWLINE> while stack : <NEWLINE> <INDENT> curr , x , y , d = heappop ( stack ) <NEWLINE> dx , dy = DX [ d ] , DY [ d ] <NEWLINE> flag = True <NEWLINE> a = curr + 1 <NEWLINE> for k in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> xx , yy = x + k * dx , y + k * dy <NEWLINE> if c [ xx ] [ yy ] == 0 : <NEWLINE> <INDENT> b = c [ xx + DX [ ( d - 1 ) % 4 ] ] [ yy + DY [ ( d - 1 ) % 4 ] ] <NEWLINE> if b == 0 or b == a + 1 : <NEWLINE> <INDENT> heappush ( new_stack , ( a , xx , yy , ( d - 1 ) % 4 ) ) <NEWLINE> <DEDENT> b = c [ xx + DX [ ( d + 1 ) % 4 ] ] [ yy + DY [ ( d + 1 ) % 4 ] ] <NEWLINE> if b == 0 or b == a + 1 : <NEWLINE> <INDENT> heappush ( new_stack , ( a , xx , yy , ( d + 1 ) % 4 ) ) <NEWLINE> <DEDENT> c [ xx ] [ yy ] = a <NEWLINE> <DEDENT> elif c [ xx ] [ yy ] != a : <NEWLINE> <INDENT> flag = False <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if flag : <NEWLINE> <INDENT> heappush ( new_stack , ( a , xx , yy , d ) ) <NEWLINE> <DEDENT> if c [ x2 ] [ y2 ] > 0 : <NEWLINE> <INDENT> print ( c [ x2 ] [ y2 ] , flush = True ) <NEWLINE> exit ( 0 ) <NEWLINE> <DEDENT> <DEDENT> stack = new_stack <NEWLINE> <NL> <DEDENT> print ( - 1 ) <NEWLINE> return <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
def resolve ( ) : <NEWLINE> <INDENT> H , W , K = map ( int , input ( ) . split ( ) ) <NEWLINE> ys , xs , yg , xg = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> board = [ [ <STRING> ] * ( W + 2 ) ] <NEWLINE> for i in range ( H ) : <NEWLINE> <INDENT> board . append ( [ <STRING> ] + list ( input ( ) ) + [ <STRING> ] ) <NEWLINE> <DEDENT> board . append ( [ <STRING> ] * ( W + 2 ) ) <NEWLINE> board [ ys ] [ xs ] = <STRING> <NEWLINE> <NL> queue = deque ( [ ( xs , ys , 0 ) ] ) <NEWLINE> while queue : <NEWLINE> <INDENT> x , y , dep = queue . popleft ( ) <NEWLINE> l = [ ] <NEWLINE> f1 = True <NEWLINE> f2 = True <NEWLINE> f3 = True <NEWLINE> f4 = True <NEWLINE> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> if f1 : <NEWLINE> <INDENT> if board [ y ] [ x + i ] == <STRING> : <NEWLINE> <INDENT> l . append ( ( x + i , y ) ) <NEWLINE> <DEDENT> elif board [ y ] [ x + i ] == <STRING> or board [ y ] [ x + i ] != dep + 1 : <NEWLINE> <INDENT> f1 = False <NEWLINE> <DEDENT> <DEDENT> if f2 : <NEWLINE> <INDENT> if board [ y ] [ x - i ] == <STRING> : <NEWLINE> <INDENT> l . append ( ( x - i , y ) ) <NEWLINE> <DEDENT> elif board [ y ] [ x - i ] == <STRING> or board [ y ] [ x - i ] != dep + 1 : <NEWLINE> <INDENT> f2 = False <NEWLINE> <DEDENT> <DEDENT> if f3 : <NEWLINE> <INDENT> if board [ y + i ] [ x ] == <STRING> : <NEWLINE> <INDENT> l . append ( ( x , y + i ) ) <NEWLINE> <DEDENT> elif board [ y + i ] [ x ] == <STRING> or board [ y + i ] [ x ] != dep + 1 : <NEWLINE> <INDENT> f3 = False <NEWLINE> <DEDENT> <DEDENT> if f4 : <NEWLINE> <INDENT> if board [ y - i ] [ x ] == <STRING> : <NEWLINE> <INDENT> l . append ( ( x , y - i ) ) <NEWLINE> <DEDENT> elif board [ y - i ] [ x ] == <STRING> or board [ y - i ] [ x ] != dep + 1 : <NEWLINE> <INDENT> f4 = False <NEWLINE> <DEDENT> <DEDENT> if not ( f1 or f2 or f3 or f4 ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> for nx , ny in l : <NEWLINE> <INDENT> if board [ ny ] [ nx ] == <STRING> : <NEWLINE> <INDENT> board [ ny ] [ nx ] = dep + 1 <NEWLINE> if ( nx , ny ) == ( xg , yg ) : <NEWLINE> <INDENT> print ( dep + 1 ) <NEWLINE> return <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> queue . append ( ( nx , ny , dep + 1 ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( - 1 ) <NEWLINE> return <NEWLINE> <DEDENT> resolve ( ) <NEWLINE>
from collections import deque <NEWLINE> from heapq import heappop , heappush <NEWLINE> <NL> import numpy as np <NEWLINE> <NL> from numba import njit <NEWLINE> <NL> <NL> @ njit ( <STRING> ) <NEWLINE> def reachable ( field , h2 , w2 , k ) : <NEWLINE> <COMMENT> <NL> <INDENT> hw = h2 * w2 <NEWLINE> up = np . full ( hw , - 1 , dtype = np . int64 ) <NEWLINE> dw = np . full ( hw , - 1 , dtype = np . int64 ) <NEWLINE> lf = np . full ( hw , - 1 , dtype = np . int64 ) <NEWLINE> rg = np . full ( hw , - 1 , dtype = np . int64 ) <NEWLINE> lf_tmp = - 1 <NEWLINE> for i in range ( w2 , hw - w2 ) : <NEWLINE> <INDENT> if field [ i ] : <NEWLINE> <INDENT> if lf_tmp == - 1 : <NEWLINE> <INDENT> lf_tmp = i <NEWLINE> <DEDENT> lf [ i ] = max ( lf_tmp , i - k ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> lf_tmp = - 1 <NEWLINE> <DEDENT> <DEDENT> rg_tmp = - 1 <NEWLINE> for i in range ( hw - w2 , w2 - 1 , - 1 ) : <NEWLINE> <INDENT> if field [ i ] : <NEWLINE> <INDENT> if rg_tmp == - 1 : <NEWLINE> <INDENT> rg_tmp = i <NEWLINE> <DEDENT> rg [ i ] = min ( rg_tmp , i + k ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> rg_tmp = - 1 <NEWLINE> <DEDENT> <DEDENT> wk = w2 * k <NEWLINE> for j in range ( 1 , w2 ) : <NEWLINE> <INDENT> up_tmp = - 1 <NEWLINE> for i in range ( j , hw , w2 ) : <NEWLINE> <INDENT> if field [ i ] : <NEWLINE> <INDENT> if up_tmp == - 1 : <NEWLINE> <INDENT> up_tmp = i <NEWLINE> <DEDENT> up [ i ] = max ( up_tmp , i - wk ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> up_tmp = - 1 <NEWLINE> <DEDENT> <DEDENT> dw_tmp = 0 <NEWLINE> for i in range ( hw - w2 + j , w2 - 1 , - w2 ) : <NEWLINE> <INDENT> if field [ i ] : <NEWLINE> <INDENT> if dw_tmp == - 1 : <NEWLINE> <INDENT> dw_tmp = i <NEWLINE> <DEDENT> dw [ i ] = min ( dw_tmp , i + wk ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dw_tmp = - 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return up , dw , lf , rg <NEWLINE> <NL> <NL> <DEDENT> def solve ( h2 , w2 , k , field , x1 , y1 , x2 , y2 ) : <NEWLINE> <INDENT> s = x1 * w2 + y1 <NEWLINE> t = x2 * w2 + y2 <NEWLINE> up , dw , lf , rg = reachable ( field , h2 , w2 , k ) <NEWLINE> <NL> INF = 10 ** 18 <NEWLINE> ans = [ [ INF , INF ] for _ in field ] <NEWLINE> ans [ s ] [ 0 ] = ans [ s ] [ 1 ] = 0 <NEWLINE> <NL> q = [ ( 0 , s ) ] <NEWLINE> while q : <NEWLINE> <INDENT> cost , v = heappop ( q ) <NEWLINE> if v == t : <NEWLINE> <INDENT> return cost <NEWLINE> <DEDENT> nc = cost + 1 <NEWLINE> <NL> for u in range ( up [ v ] , v , w2 ) : <NEWLINE> <INDENT> if ans [ u ] [ 0 ] <= nc : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> ans [ u ] [ 0 ] = nc <NEWLINE> heappush ( q , ( nc , u ) ) <NEWLINE> <NL> <DEDENT> for u in range ( dw [ v ] , v , - w2 ) : <NEWLINE> <INDENT> if ans [ u ] [ 0 ] <= nc : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> ans [ u ] [ 0 ] = nc <NEWLINE> heappush ( q , ( nc , u ) ) <NEWLINE> <NL> <DEDENT> for u in range ( lf [ v ] , v , 1 ) : <NEWLINE> <INDENT> if ans [ u ] [ 1 ] <= nc : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> ans [ u ] [ 1 ] = nc <NEWLINE> heappush ( q , ( nc , u ) ) <NEWLINE> <NL> <DEDENT> for u in range ( rg [ v ] , v , - 1 ) : <NEWLINE> <INDENT> if ans [ u ] [ 1 ] <= nc : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> ans [ u ] [ 1 ] = nc <NEWLINE> heappush ( q , ( nc , u ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> return - 1 <NEWLINE> <NL> <NL> <DEDENT> h , w , k = map ( int , input ( ) . split ( ) ) <NEWLINE> x1 , y1 , x2 , y2 = map ( int , input ( ) . split ( ) ) <NEWLINE> h2 = h + 2 <NEWLINE> w2 = w + 2 <NEWLINE> <NL> field_tmp = [ input ( ) for _ in range ( h ) ] <NEWLINE> field = [ 0 ] * w2 <NEWLINE> for row in field_tmp : <NEWLINE> <INDENT> field . append ( 0 ) <NEWLINE> field . extend ( map ( <STRING> . index , row ) ) <NEWLINE> field . append ( 0 ) <NEWLINE> <DEDENT> field . extend ( [ 0 ] * w2 ) <NEWLINE> field = np . array ( field , dtype = np . int8 ) <NEWLINE> print ( solve ( h2 , w2 , k , field , x1 , y1 , x2 , y2 ) ) <NEWLINE>
from collections import deque <NEWLINE> import sys <NEWLINE> <NL> <NL> def bfs ( xs , ys , d ) : <NEWLINE> <INDENT> queue = deque ( ( xs , ys , d ) ) <NEWLINE> M [ xs ] [ ys ] = d <NEWLINE> while queue : <NEWLINE> <COMMENT> <NL> <INDENT> x1 , y1 , d = queue . popleft ( ) <COMMENT> <NEWLINE> if [ x1 , y1 ] == [ xg , yg ] : <COMMENT> <NEWLINE> <INDENT> return <NEWLINE> <NL> <DEDENT> for dx , dy in ( ( 1 , 0 ) , ( - 1 , 0 ) , ( 0 , 1 ) , ( 0 , - 1 ) ) : <NEWLINE> <INDENT> for k in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> x2 = x1 + dx * k <NEWLINE> y2 = y1 + dy * k <NEWLINE> <NL> if ( 0 <= x2 < H ) and ( 0 <= y2 < W ) : <NEWLINE> <INDENT> if m [ x2 ] [ y2 ] == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> elif M [ x2 ] [ y2 ] == - 1 : <COMMENT> <NEWLINE> <INDENT> M [ x2 ] [ y2 ] = d + 1 <NEWLINE> queue . append ( ( x2 , y2 ) ) <COMMENT> <NEWLINE> <DEDENT> elif M [ x2 ] [ y2 ] < d + 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> H , W , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <COMMENT> <NL> xs , ys , xg , yg = map ( int , input ( ) . split ( ) ) <NEWLINE> xs , ys , xg , yg = xs - 1 , ys - 1 , xg - 1 , yg - 1 <NEWLINE> <NL> m = [ ] <NEWLINE> for i in range ( H ) : <NEWLINE> <INDENT> m . append ( list ( map ( str , sys . stdin . readline ( ) . strip ( ) ) ) ) <NEWLINE> <NL> <DEDENT> M = [ [ - 1 ] * W for i in range ( H ) ] <NEWLINE> <NL> bfs ( xs , ys , 0 ) <NEWLINE> <NL> print ( M [ xg ] [ yg ] ) <NEWLINE>
from collections import deque <NEWLINE> import sys <NEWLINE> <NL> N_MAX = 200000 + 5 <NEWLINE> <NL> H , W , K = map ( int , input ( ) . split ( ) ) <NEWLINE> sth , stw , glh , glw = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> INF = 10 ** 6 * K <NEWLINE> <NL> dp = [ [ INF for _ in range ( W + 2 ) ] for _ in range ( H + 2 ) ] <NEWLINE> <NL> dp [ 0 ] = [ - 1 ] * ( W + 2 ) <NEWLINE> dp [ H + 1 ] = [ - 1 ] * ( W + 2 ) <NEWLINE> for h in range ( 1 , H + 1 ) : <NEWLINE> <INDENT> s = sys . stdin . readline ( ) <NEWLINE> dp [ h ] [ 0 ] = - 1 <NEWLINE> dp [ h ] [ W + 1 ] = - 1 <NEWLINE> for w in range ( 1 , W + 1 ) : <NEWLINE> <INDENT> if s [ w - 1 ] == <STRING> : <NEWLINE> <INDENT> dp [ h ] [ w ] = - 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> dp [ sth ] [ stw ] = 0 <NEWLINE> <NL> <NL> <COMMENT> <NL> XY = { ( 1 , 0 ) , ( - 1 , 0 ) , ( 0 , 1 ) , ( 0 , - 1 ) } <NEWLINE> <NL> <NL> def bfs ( sth , stw , glh , glw ) : <NEWLINE> <INDENT> next_q = deque ( ) <NEWLINE> next_q . append ( ( sth , stw ) ) <NEWLINE> <NL> while len ( next_q ) != 0 : <NEWLINE> <COMMENT> <NL> <INDENT> h , w = next_q . popleft ( ) <NEWLINE> for dh , dw in XY : <NEWLINE> <INDENT> for sk in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> hs , ws = h + dh * sk , w + dw * sk <NEWLINE> if dp [ hs ] [ ws ] == - 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if dp [ hs ] [ ws ] == INF : <NEWLINE> <INDENT> next_q . append ( ( hs , ws ) ) <NEWLINE> dp [ hs ] [ ws ] = dp [ h ] [ w ] + 1 <NEWLINE> <DEDENT> elif dp [ hs ] [ ws ] <= dp [ h ] [ w ] : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <INDENT> break <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <INDENT> bfs ( sth , stw , glh , glw ) <NEWLINE> <NL> if dp [ glh , glw ] == INF : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( dp [ glh , glw ] ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
s = int ( input ( ) ) <NEWLINE> print ( s [ : 3 ] . lower ( ) ) <NEWLINE>
def adana ( <STRING> ) : <NEWLINE> <INDENT> return S [ 0 : 3 ] <NEWLINE> <DEDENT>
s = list ( input ( ) ) <NEWLINE> print ( <STRING> . join ( li [ 0 : 2 ] ) ) <NEWLINE>
import random <NEWLINE> <NL> def name ( ) : <NEWLINE> <INDENT> S = input ( <STRING> ) <NEWLINE> <NL> if len ( S ) > 20 : <NEWLINE> <INDENT> return name ( ) <NEWLINE> <NL> <DEDENT> if len ( S ) < 3 : <NEWLINE> <INDENT> return name ( ) <NEWLINE> <NL> <DEDENT> if s . isupper ( ) == True : <NEWLINE> <INDENT> return name ( ) <NEWLINE> <NL> <DEDENT> if s . isalpha ( ) == False : <NEWLINE> <INDENT> return name ( ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> l = list ( S ) <NEWLINE> x = random . randint ( 0 , len ( s ) - 3 ) <NEWLINE> y = l [ x ] <NEWLINE> z = l . index ( y ) <NEWLINE> print ( y + l [ z + 1 ] + l [ z + 2 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> name ( ) <NEWLINE>
import argparse <NEWLINE> <NL> parser = argparse . ArgumentParser ( ) <NEWLINE> parser . add_argument ( <STRING> ) <NEWLINE> arg = parser . parse_args ( ) <NEWLINE> print ( arg . name [ : 3 ] ) <NEWLINE>
def first_three ( str ) : <NEWLINE> <INDENT> return str [ : 3 ] if len ( str ) > 3 else str <NEWLINE> <NL> val = input ( ) <NEWLINE> print ( first_three ( val ) ) <NEWLINE> <DEDENT>
S = input ( ) <NEWLINE> return s [ 0 : 3 ] <NEWLINE>
<INDENT> print ( input ( ) [ : 3 ] ) <NEWLINE> <DEDENT>
import fileinput <NEWLINE> <NL> lines = list ( fileinput . input ( ) ) <NEWLINE> <NL> for x in lines ( ) : <NEWLINE> <INDENT> print ( x [ : 3 ] ) <NEWLINE> <DEDENT>
a , s , d = input ( ) <NEWLINE> <NL> print ( a , s , d ) <NEWLINE>
print ( input ( ) . split ( ) . index ( <STRING> ) + 1 ) <NEWLINE>
S = input ( ) <NEWLINE> print ( S [ 0 ] S [ 1 ] S [ 2 ] ) <NEWLINE>
a = input ( str ( a ) ) <NEWLINE> <NL> print ( a [ 0 : 2 ] ) <NEWLINE>
s = input ( ) <NEWLINE> print ( input ( ) [ : 3 ] ) <NEWLINE>
S = input ( ) <NEWLINE> print ( S [ ; 2 ] ) <NEWLINE>
print ( input [ : 3 ] ) <NEWLINE>
a = input ( ) <NEWLINE> <COMMENT> <NL> print ( str [ 0 : 2 ] ) <NEWLINE>
str = input ( ) <NEWLINE> <NL> str_length = len ( str ) <NEWLINE> <NL> import randum <NEWLINE> <NL> start_num = randum . randint ( 0 , str_length - 3 ) <NEWLINE> <NL> print ( str [ start_num : start_num + 2 ] ) <NEWLINE>
<COMMENT> <NL> s = input ( ) <NEWLINE> <NL> return s [ 0 : 3 ] <NEWLINE>
import random <NEWLINE> S = input ( ) <NEWLINE> <NL> A = random . randint ( 0 , len ( S ) - 2 ) <NEWLINE> <NL> print ( S [ A ] + S [ A + 1 ] + S [ A + 2 ] ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> name = input ( ) <NEWLINE> print ( name ) <NEWLINE> <NL> <NL> <NL> <NL> <DEDENT> if __name__ == <STRING> <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import math <NEWLINE> import os <NEWLINE> import random <NEWLINE> import re <NEWLINE> import sys <NEWLINE> import collections <NEWLINE> import itertools <NEWLINE> <NL> def solution ( data ) : <NEWLINE> <INDENT> return data [ : 3 ] <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> a = input ( ) <NEWLINE> <NL> print ( solution ( a ) ) <NEWLINE> <DEDENT>
a = map ( str , input ( ) ) <NEWLINE> print ( a [ 0 : 3 ] ) <NEWLINE>
import random <NEWLINE> S = input ( ) <NEWLINE> rand = random . randrange ( 0 , len ( S ) - 1 ) <NEWLINE> print ( S [ rand ] + S [ rand + 1 ] + S [ rand + 2 ] ) <NEWLINE>
S = list ( input ( ) ) <NEWLINE> print ( String ( S [ 0 : 3 ] ) ) <NEWLINE>
S = int ( input ( ) ) <NEWLINE> ans = S [ 0 : 3 ] <NEWLINE> print ( ans ) <NEWLINE>
print ( S [ 0 : 3 ] ) <NEWLINE>
print input <NEWLINE>
S = input ( ) <NEWLINE> <NL> print ( s [ 0 : 3 ] ) <NEWLINE>
name = input ( ) <NEWLINE> print ( name ( : 2 ) ) <NEWLINE>
str = S <NEWLINE> <NL> print ( str [ 0 : 2 ] ) <NEWLINE>
import sys <NEWLINE> A , V = map ( int ( input ( ) ) ) <NEWLINE> B , W = map ( int ( input ( ) ) ) <NEWLINE> T = int ( input ( ) ) <NEWLINE> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> if V == W : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> elif W < V : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> distance_AB = abs ( A - B ) <NEWLINE> speed_AB = abs ( V - W ) <NEWLINE> <NL> if speed_AB * T < distance_AB : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <NL> <DEDENT>
if a >= 0 and b >= 0 : <NEWLINE> <INDENT> if a + v * t >= b + w * t : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> elif a < 0 and b >= 0 : <NEWLINE> <INDENT> if - a + v * t >= b + w * t : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if v * t - w * t >= - ( a - b ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> <NL> a , v = map ( int , inpu ( ) . split ( ) ) <NEWLINE> b , w = map ( int , inpu ( ) . split ( ) ) <NEWLINE> t = int ( input ( ) ) <NEWLINE> if ( a == b ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( 0 ) <NEWLINE> <DEDENT> if ( v <= w ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( 0 ) <NEWLINE> <DEDENT> res = abs ( a - b ) / ( v - w ) <NEWLINE> if ( res > t ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> sys . exit ( 0 ) <NEWLINE>
A , V = map ( int , input ( ) . split ( ) ) <NEWLINE> 1 2 <NEWLINE> B , W = map ( int , input ( ) . split ( ) ) <NEWLINE> 3 1 <NEWLINE> T = int ( input ( ) ) <NEWLINE> 3 <NEWLINE> <NL> if V <= W : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if abs ( ( B - A ) ) / ( V - W ) <= T : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
a , v = list ( map ( long , input ( ) . split ( ) ) ) <NEWLINE> b , w = list ( map ( long , input ( ) . split ( ) ) ) <NEWLINE> t = long ( input ( ) ) <NEWLINE> <NL> if a == b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> elif b > a : <NEWLINE> <INDENT> if v <= w : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> if b - a <= t * ( v - w ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if w <= v : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> if a - b <= t * ( w - v ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
a_now , a_speed = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> b_now , b_speed = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> t = int ( input ( ) ) <NEWLINE> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> if ( a_now < b_now and a_speed <= b_speed ) : <NEWLINE> <COMMENT> <NL> <INDENT> caught = <STRING> <NEWLINE> <DEDENT> elif ( a_now > b_now and a_speed >= b_speed ) : <NEWLINE> <COMMENT> <NL> <INDENT> caught = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> diff = abs ( a_now - b_now ) <NEWLINE> speed = abs ( a_speed - b_speed ) <NEWLINE> <COMMENT> <NL> if ( diff == 0 ) : <NEWLINE> <INDENT> caught = <STRING> <NEWLINE> <DEDENT> elif ( speed == 0 ) : <NEWLINE> <COMMENT> <NL> <INDENT> caught = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> q = diff / speed <NEWLINE> <COMMENT> <NL> if ( q <= t ) <NEWLINE> <INDENT> caught = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> caught = <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( caught ) <NEWLINE>
( A , V ) = map ( lambda a : double ( a ) , input ( ) . split ( ) ) <NEWLINE> ( B , W ) = map ( lambda a : double ( a ) , input ( ) . split ( ) ) <NEWLINE> T = double ( input ( ) ) <NEWLINE> <NL> D = abs ( A - B ) <NEWLINE> X = abs ( V - W ) <NEWLINE> <NL> if ( X * T >= D ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT>
if A == B : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif A < B : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if A + V * T >= B + W * T : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> <NL> A , V = map ( int , input ( ) . split ( ) ) <NEWLINE> B , W = map ( int , input ( ) . split ( ) ) <NEWLINE> T = int ( input ( ) ) <NEWLINE> if V <= W : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> if 0 < abs ( ( B - A ) // ( V - W ) ) <= T : <NEWLINE> <INDENT> print ( <STRING> ) import sys <NEWLINE> <NL> <DEDENT> A , V = map ( int , input ( ) . split ( ) ) <NEWLINE> B , W = map ( int , input ( ) . split ( ) ) <NEWLINE> T = int ( input ( ) ) <NEWLINE> if V <= W : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> t = abs ( B - A ) % ( V - W ) <NEWLINE> if 0 < abs ( ( B - A ) // ( V - W ) ) <= T : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT>
A_V = input ( ) . split ( <STRING> ) <NEWLINE> B_W = input ( ) . split ( <STRING> ) <NEWLINE> T = int ( input ( ) ) <NEWLINE> A = int ( A_V [ 0 ] ) <NEWLINE> V = int ( A_V [ 1 ] ) <NEWLINE> B = int ( B_W [ 0 ] ) <NEWLINE> W = int ( B_W [ 1 ] ) <NEWLINE> dA = A + V * T <NEWLINE> dB = B + W * T <NEWLINE> ndA = A - V * T <NEWLINE> ndB = B - W * T <NEWLINE> if ( dA < dB ) : <NEWLINE> <INDENT> if ( ndA > ndB ) <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
if ( V < W ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif ( abs ( A - B ) > T * ( V - W ) ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , v = map ( int , input ( ) . split ( ) ) <NEWLINE> b , w = map ( int , input ( ) . split ( ) ) <NEWLINE> t = int ( input ( ) ) <NEWLINE> if v * t >= abs ( b - a ) + W * t : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
A , V = map ( int , input ( ) . split ( ) ) <NEWLINE> B , W = map ( int , input ( ) . split ( ) ) <NEWLINE> T = int ( input ( ) ) <NEWLINE> if A < B : <NEWLINE> <INDENT> if A + V * T >= B + W * T : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> if A = B : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> if A > B : <NEWLINE> <INDENT> if A - V * T <= B - W * T : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
a , v = map ( int , input ( ) . split ( ) ) <NEWLINE> b , w = map ( int , input ( ) . split ( ) ) <NEWLINE> t = int ( input ( ) ) <NEWLINE> if a == b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> c += 1 <NEWLINE> <DEDENT> if a * b < 0 : <NEWLINE> <INDENT> d = a + b <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d = a - b <NEWLINE> <DEDENT> if d < 0 : <NEWLINE> <INDENT> d = - d <NEWLINE> <DEDENT> if v > w : <NEWLINE> <INDENT> d2 = v - w <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d2 = w - v <NEWLINE> <DEDENT> if ( v > w ) and ( d2 * t < d ) and c == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif v <= w and c == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif c == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
<COMMENT> <NL> B , W = map ( int , input ( ) . split ( ) ) <NEWLINE> T = int ( input ( ) ) <NEWLINE> <NL> if abs ( A - B ) < abs ( W - V ) * T : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
A , V = map ( int , input ( ) . split ( ) ) <NEWLINE> B , W = map ( int , input ( ) . split ( ) ) <NEWLINE> T = int ( input ( ) ) <NEWLINE> if B - A + > ( W - V ) * T : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import sys <NEWLINE> a , v = map ( int , sys . stdin . readline ( ) . rstrip ( <STRING> ) . split ( ) ) <NEWLINE> b , w = map ( int , sys . stdin . readline ( ) . rstrip ( <STRING> ) . split ( ) ) <NEWLINE> t = int ( sys . stdin . readline ( ) . rstrip ( <STRING> ) ) <NEWLINE> between = abs ( b - a ) <NEWLINE> speed = w - v <NEWLINE> if between <= speed * t <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
x1 , v1 = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> x2 , v2 = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> t = int ( input ( ) ) <NEWLINE> <NL> if v1 == v2 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s = abs ( x2 - x1 ) / ( v1 - v2 ) <NEWLINE> if s <= T : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
a , v = map ( int , input ( ) . split ( ) ) <NEWLINE> b , w = map ( int , input ( ) . split ( ) ) <NEWLINE> t = int ( input ( ) ) <NEWLINE> <NL> if v <= w : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if abs ( b - a ) <= ( v - w ) : <NEWLINE> if abs ( b - a ) % ( v - w ) == 0 and abs ( b - a ) // ( v - w ) <= t : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
A , V = map ( int , input ( ) , split ( ) ) <NEWLINE> B , W = map ( int , input ( ) , split ( ) ) <NEWLINE> T = input ( ) <NEWLINE> if ( V <= W ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif ( T < abs ( A - B ) / ( V - W ) ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
if v <= w : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif ( b - a ) % ( v - w ) == 0 and ( b - a ) // ( v - w ) + 1 > t : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif - ( - ( b - a ) // ( v - w ) ) > t : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
A , V = map ( int , input ( ) . split ( ) ) <NEWLINE> B , W = map ( int , input ( ) . split ( ) ) <NEWLINE> T = int ( input ( ) ) <NEWLINE> <NL> if V <= W : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> s = V - W <NEWLINE> if D < s * T : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import copy <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> A , V = map ( int , input ( ) . split ( ) ) <NEWLINE> B , W = map ( int , input ( ) . split ( ) ) <NEWLINE> T = int ( input ( ) ) <NEWLINE> <NL> if V <= W : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif ( abs ( A - B ) / ( V - W ) ) <= t : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> main ( ) <NEWLINE>
A , V = map ( int , input ( ) . split ( ) ) <NEWLINE> B , W = map ( int , input ( ) . split ( ) ) <NEWLINE> D = abs ( A - B ) <NEWLINE> S = V - W <NEWLINE> if V - W <= 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if D / S > T : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
a , v = map ( int , input ( ) . split ( ) ) <NEWLINE> b , w = map ( int , input ( ) . split ( ) ) <NEWLINE> t = int ( input ( ) ) <NEWLINE> if v <= w : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> elif 1 <= ( ( b - a ) / ( v - w ) ) <= t : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
a , v = map ( int , input ( ) . split ( ) ) <NEWLINE> b , w = map ( int , input ( ) . split ( ) ) <NEWLINE> t = int ( input ( ) ) <NEWLINE> first_distance = abs ( b - a ) <NEWLINE> speed = v - w <NEWLINE> t_position = first_distance - speed * t <NEWLINE> if t_position <= 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : a <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import math <NEWLINE> <NL> def a ( ) : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> print ( s [ : 3 ] ) <NEWLINE> <NL> <NL> <DEDENT> def b ( ) : <NEWLINE> <INDENT> a , v = map ( int , input ( ) . split ( ) ) <NEWLINE> b , w = map ( int , input ( ) . split ( ) ) <NEWLINE> t = int ( input ( ) ) <NEWLINE> if v > w : <NEWLINE> <INDENT> if abs ( a - b ) / ( v - w ) <= t <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def c ( ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <NL> <NL> <DEDENT> def d ( ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> b ( ) <NEWLINE>
a , v = map ( int , input ( ) . split ( ) ) <NEWLINE> b , w = map ( int , input ( ) . split ( ) ) <NEWLINE> t = int ( input ( ) ) <NEWLINE> if a > b : <NEWLINE> <INDENT> x = a - v + t <NEWLINE> y = b - w * t <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = a + v * t <NEWLINE> y = b + w * t <NEWLINE> if abs ( x ) >= abs ( y ) or abs ( x ) = 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
a , v = map ( int , input ( ) . split ( ) ) <NEWLINE> b , w = map ( int , input ( ) . split ( ) ) <NEWLINE> t = int ( input ( ) ) <NEWLINE> <NL> if v == w : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> elif ( a > b ) and ( v >= m ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> for i in range ( 1 , t + 1 ) : <NEWLINE> <INDENT> oni = a + ( v * i ) <NEWLINE> child = c + ( w * i ) <NEWLINE> if oni >= child : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
A , V = map ( int , input ( ) . split ( ) ) <NEWLINE> B , W = map ( int , input ( ) . split ( ) ) <NEWLINE> T = int ( input ( ) ) <NEWLINE> if B + W * T = < A + V * T or B < A : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
A , V = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> B , W = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> print ( <STRING> if V > W and abs ( A - B ) <= T * ( V - W ) else <STRING> ) <NEWLINE>
import sys <NEWLINE> <NL> A , V = [ int ( x ) for x in input ( ) . strip ( ) . split ( <STRING> ) ] <NEWLINE> B , W = [ int ( x ) for x in input ( ) . strip ( ) . split ( <STRING> ) ] <NEWLINE> T = int ( input ( ) . strip ( ) ) <NEWLINE> <NL> if V <= W : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( 0 ) <NEWLINE> <NL> <DEDENT> distance = abs ( A - B ) <NEWLINE> diff = abs ( V - W ) <NEWLINE> <NL> t , distance = divmod ( df , diff ) <NEWLINE> if t > T : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( 0 ) <NEWLINE> <DEDENT> if distance == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( 0 ) <NEWLINE> <NL> <DEDENT> distance = abs ( distance - V - W ) <NEWLINE> T -= t <NEWLINE> t , distance = divmod ( df , diff ) <NEWLINE> if distance == 0 and t <= T : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( 0 ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> sys . exit ( 0 ) <NEWLINE> <NL>
A , V = map ( int , input ( ) . split ( ) ) <NEWLINE> B , W = map ( int , input ( ) . split ( ) ) <NEWLINE> T = int ( input ( ) ) <NEWLINE> <NL> if A > B and A - V * T = < B - W * T : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif A < B and A + V * T >= B + W * T : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , v = map ( int , input ( ) . split ( ) ) <NEWLINE> b , w = map ( int , input ( ) . split ( ) ) <NEWLINE> t = int ( input ( ) ) <NEWLINE> d = abs ( a - b ) <NEWLINE> s = v - w <NEWLINE> if s > 0 d / s <= t : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
b , w = map ( int , input ( ) . split ( ) ) <NEWLINE> t = int ( input ( ) ) <NEWLINE> if v <= w : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dis = abs ( b - a ) <NEWLINE> sp = abs ( v - w ) <NEWLINE> if 0 < dis / sp <= t : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
a , v = map ( int , input ( ) . split ( ) ) <NEWLINE> b , w = map ( int , input ( ) . split ( ) ) <NEWLINE> t = int ( input ( ) ) <NEWLINE> <NL> if ( w >= v ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else if ( abs ( b - a ) / ( v - w ) > t ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , v = map ( int , input ( ) . split ( ) ) <NEWLINE> b , w == map ( int , input ( ) . split ( ) ) <NEWLINE> t = int ( input ( ) ) <NEWLINE> d = abs ( a - b ) <NEWLINE> if d <= ( v - w ) * t : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
A , V = map ( int , input ( ) . split ( ) ) <NEWLINE> B , W = map ( int , input ( ) . split ( ) ) <NEWLINE> T = int ( input ( ) ) <NEWLINE> <NL> if A < B : <NEWLINE> <INDENT> if ( A + V * T >= B + W * T ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if ( A + V * T <= B + W * T ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> else : <NEWLINE> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
a , v = map ( int , input ( ) . split ( ) ) <NEWLINE> b , w = map ( int , input ( ) . split ( ) ) <NEWLINE> t = int ( input ( ) ) <NEWLINE> <NL> ans = <STRING> <NEWLINE> if v > w : <NEWLINE> <INDENT> f = v - w <NEWLINE> hoge = hoge ( a - b ) <NEWLINE> if f * t >= hoge : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL>
A , V = map ( int , input ( ) . split ( ) ) <NEWLINE> B , W = map ( int , input ( ) . split ( ) ) <NEWLINE> T = int ( input ( ) ) <NEWLINE> if A > B : <NEWLINE> <INDENT> result = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if V - W > 0 : <NEWLINE> <INDENT> if B - A - T * ( V - W ) <= 0 : <NEWLINE> <INDENT> if <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> result = <STRING> <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> result = <STRING> <NEWLINE> <DEDENT> <DEDENT> print ( result ) <NEWLINE>
AV = input ( ) . split ( ) <NEWLINE> BW = input ( ) . split ( ) <NEWLINE> T = int ( input ( ) ) <NEWLINE> <NL> if ( int ( AV [ 0 ] ) > int ( BW [ 0 ] ) ) : <NEWLINE> <INDENT> T *= - 1 <NEWLINE> <NL> <DEDENT> a = int ( AV [ 0 ] ) + int ( AV [ 1 ] ) * T <NEWLINE> b = int ( BW [ 0 ] ) + int ( BW [ 1 ] ) * T <NEWLINE> <NL> if ( T >= 0 & & a >= b ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif ( T <= 0 & & a >= b ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
A , V = map ( int , input ( ) . split ( ) ) <NEWLINE> B , W = map ( int , input ( ) . split ( ) ) <NEWLINE> T = input ( ) <NEWLINE> <NL> a = A <COMMENT> <NEWLINE> b = B <COMMENT> <NEWLINE> <NL> for i in range ( 1 , T + 1 , 1 ) : <NEWLINE> <INDENT> a += V <NEWLINE> b += W <NEWLINE> <NL> if a == b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if ( a != b ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
ca = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> b = [ int ( j ) for j in input ( ) . split ( ) ] <NEWLINE> t = int ( input ( ) ) <NEWLINE> <NL> if ( a [ 0 ] < b [ 0 ] ) & ( b [ 1 ] * t + ( b [ 0 ] - a [ 0 ] ) - a [ 1 ] * t ) < 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif ( a [ 0 ] > b [ 0 ] ) & ( b [ 1 ] * t + ( a [ 0 ] - b [ 0 ] ) - a [ 1 ] * t ) < 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , v = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> b , w = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> t = int ( input ( ) ) <NEWLINE> print ( <STRING> ) if a + ( v * t ) >= b + ( w * ) or a >= b else print ( <STRING> ) <NEWLINE>
i = ( input ( ) . split ( ) ) <NEWLINE> j = ( input ( ) . split ( ) ) <NEWLINE> k = ( input ( ) ) <NEWLINE> <NL> A = int ( i [ 0 ] ) <NEWLINE> V = int ( i [ 1 ] ) <NEWLINE> B = int ( j [ 0 ] ) <NEWLINE> W = int ( j [ 1 ] ) <NEWLINE> T = int ( k ) <NEWLINE> <NL> print ( B ) <NEWLINE> <NL> if B >= A : <NEWLINE> <INDENT> if ( B - A ) + W * T <= V * T : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else ( B - A ) + W * T > V * T : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> if B < A : <NEWLINE> <INDENT> if ( A - B ) + W * T <= V * T : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else ( A - B ) + W * T > V * T : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
A , V = map ( int , input ( ) . split ( ) ) <NEWLINE> B , W = map ( int , input ( ) . split ( ) ) <NEWLINE> T = int ( input ( ) ) <NEWLINE> <NL> if ( A < B ) : <NEWLINE> <INDENT> if ( B + W * T <= A + V * T ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> elif ( B < A ) : <NEWLINE> <INDENT> if ( A - V * T <= B - W * T ) : <NEWLINE> print ( <STRING> ) <NEWLINE> else : <NEWLINE> print ( <STRING> ) <NEWLINE> <DEDENT>
a , v = map ( float , input ( ) . split ( ) ) <NEWLINE> b , w = map ( float , input ( ) . split ( ) ) <NEWLINE> t = float ( input ( ) ) <NEWLINE> <NL> if a < b : <NEWLINE> <INDENT> if b + w * t <= a + v * t : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if a - v * t <= b - w * t : <NEWLINE> print ( <STRING> ) <NEWLINE> else : <NEWLINE> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b , v , w , t = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> d = abs ( b - a ) <NEWLINE> p = v - w <NEWLINE> i = 0 <NEWLINE> for i in range ( t + 1 ) : <NEWLINE> <INDENT> if v <= w : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif p * i == d : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
A , V = map ( int , input ( ) . split ( ) ) <NEWLINE> B , W = map ( int , input ( ) . split ( ) ) <NEWLINE> T = int ( input ( ) ) <NEWLINE> <NL> if V <= W : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> import sys <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> if A + V * t >= B + W * t : <NEWLINE> <INDENT> if 1 <= t and t <= T : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
P = [ ] <NEWLINE> S = [ ] <NEWLINE> for i in range ( 2 ) : <NEWLINE> <INDENT> pp , ss = map ( int , input ( ) . split ( ) ) <NEWLINE> P . append ( pp ) <NEWLINE> S . append ( ss ) <NEWLINE> <NL> <DEDENT> A = P [ 0 ] <NEWLINE> V = S [ 0 ] <NEWLINE> B = P [ 1 ] <NEWLINE> W = S [ 1 ] <NEWLINE> T = int ( input ( ) ) <NEWLINE> <NL> def run ( ) : <NEWLINE> <INDENT> if A < B : <NEWLINE> <INDENT> c = ( B + W * T ) - ( A + V * T ) <NEWLINE> if c <= 0 : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> <DEDENT> elif A > B : <NEWLINE> <INDENT> c = ( A - V * T ) - ( B - W * T ) <NEWLINE> if c <= 0 : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( run ( ) ) <NEWLINE>
A , V = map ( int , input ( ) . split ( ) ) <NEWLINE> B , W = map ( int , input ( ) . split ( ) ) <NEWLINE> T = int ( input ( ) ) <NEWLINE> <NL> x = A + V * T <NEWLINE> y = B + W * T <NEWLINE> <NL> if X >= y : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
oni_x , oni_speed = map ( int , input ( ) . split ( ) ) <NEWLINE> chi_x , chi_speed = map ( int , input ( ) . split ( ) ) <NEWLINE> time = int ( input ( ) ) <NEWLINE> ans = False <NEWLINE> <NL> <NL> if oni_speed > chi_speed : <NEWLINE> <INDENT> sa = abs ( oni_x , chi_x ) <NEWLINE> sa_speed = oni_speed - chi_speed <NEWLINE> if sa_speed * time >= sa : <NEWLINE> <INDENT> ans = True <NEWLINE> <NL> <DEDENT> <DEDENT> if ans : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , v , b , w , t = int ( input ( ) . split ( ) ) <NEWLINE> <NL> print ( <STRING> ) <NEWLINE>
A , V = map ( int , input ( ) . split ( ) ) <NEWLINE> B , W = map ( int , input ( ) . split ( ) ) <NEWLINE> T = int ( input ( ) ) <NEWLINE> if A < B and V <= W : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif B < A and W <= V : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if A + V * i >= 0 : <NEWLINE> <INDENT> if A + V * i >= B + W * i : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> elif A + V * i < 0 : <NEWLINE> <INDENT> if abs ( A + V * i ) <= abs ( B + W * i ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
A , V = ( int ( x ) for x in input ( ) . split ( ) ) <NEWLINE> B , W = ( int ( x ) for xin input ( ) . split ( ) ) <NEWLINE> T = int ( input ( ) ) <NEWLINE> <NL> if V > W and abs ( A - B ) / ( V - W ) <= T : <NEWLINE> <INDENT> Flag = True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> Flag = False <NEWLINE> <NL> <DEDENT> if Flag : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
A , V = map ( int , input ( ) . split ( ) ) <NEWLINE> B , W = map ( int , input ( ) . split ( ) ) <NEWLINE> dist = abs ( A - B ) <NEWLINE> diff = V - W <NEWLINE> if dist > diff * T : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
A , V = map ( int , input ( ) . split ( ) ) <NEWLINE> B , W = map ( int , input ( ) . split ( ) ) <NEWLINE> T = int ( input ( ) ) <NEWLINE> <NL> if abs ( A - B ) = < V * T - W * T : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , v = map ( int , input ( ) ) <NEWLINE> b , w = map ( int , input ( ) ) <NEWLINE> t = int ( input ( ) ) <NEWLINE> if v <= w : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> q = abs ( a - b ) / abs ( v - w ) <NEWLINE> if abs ( a - b ) * t <= abs ( v - w ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
a , v = map ( int , input ( ) . split ( ) ) <NEWLINE> b , w = a , v = map ( int , input ( ) . split ( ) ) <NEWLINE> t = int ( input ( ) ) <NEWLINE> flg = 0 <NEWLINE> for i in range ( t ) : <NEWLINE> <INDENT> a += v <NEWLINE> b += w <NEWLINE> if ( a == b ) : <NEWLINE> <INDENT> flg = 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if ( flg == 1 ) : print ( <STRING> ) <NEWLINE> else : print ( <STRING> ) <NEWLINE>
a , v = map ( int , input ( ) . split ( ) ) <NEWLINE> b , w = map ( int , input ( ) . split ( ) ) <NEWLINE> t = int ( input ( ) ) <NEWLINE> <NL> kyori = abs ( a - b ) <NEWLINE> sokudo = v - w <NEWLINE> <NL> if kyori = < t * sokudo : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> import math <NEWLINE> A , V = int ( input ( ) . split ( ) ) <NEWLINE> B , W = int ( input ( ) . split ( ) ) <NEWLINE> T = int ( input ( ) ) <NEWLINE> <NL> dis = abs ( A - B ) <NEWLINE> dis1 = ( V - W ) * T <NEWLINE> if dis <= dis1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , v = map ( int , input ( ) . split ( ) ) <NEWLINE> b , w = map ( int , input ( ) . split ( ) ) <NEWLINE> t = int ( input ( ) ) <NEWLINE> <NL> if a > b : <NEWLINE> <INDENT> muki = - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> muki = 1 <NEWLINE> <NL> <DEDENT> at = a + v * muki * t <NEWLINE> bt = b + w * muki * t <NEWLINE> <NL> if muki : <NEWLINE> <INDENT> if at >= bt : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if at = < bt : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
A , V , B , W , T = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> kyori = abs ( A - B ) <NEWLINE> dif = V - W <NEWLINE> if dif > 0 : <NEWLINE> <INDENT> if kyori / dif <= T : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , v = map ( int , input ( ) . split ( ) ) <NEWLINE> b , w = map ( int , input ( ) . split ( ) ) <NEWLINE> t = int ( input ( ) ) <NEWLINE> <NL> if v > w : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <INDENT> if abs ( a - b ) <= ( v - w ) * t <NEWLINE> <COMMENT> <NL> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
if b - a > 0 : <NEWLINE> <INDENT> b_f = min ( b + t * w , 10 ** 9 ) <NEWLINE> a_f = min ( a + t * v , 10 ** 9 ) <NEWLINE> if b_f > a_f : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> b_f = max ( b - t * w , - 10 ** 9 ) <NEWLINE> a_f = max ( a - t * v , - 10 ** 9 ) <NEWLINE> if b_f < a_f : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> a , v = map ( int , input ( ) . split ( ) ) <NEWLINE> b , w = map ( int , input ( ) . split ( ) ) <NEWLINE> t = int ( input ( ) ) <NEWLINE> distance = abs ( a - b ) if a >= b else abs ( b - a ) <NEWLINE> ve = v - w <NEWLINE> if ve <= 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> return <NEWLINE> <DEDENT> if distance <= ve * t : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> return <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <INDENT> return <NEWLINE> <NL> <NL> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> main ( ) <NEWLINE>
import sys <NEWLINE> a , v = map ( int , input ( ) . split ( ) ) <NEWLINE> b , w = map ( int , input ( ) . split ( ) ) <NEWLINE> t = int ( input ( ) ) <NEWLINE> if v <= w : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d = abs ( a - b ) <NEWLINE> s = v - w <NEWLINE> if d <= ts : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
a_index , a_v = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b_index , b_v = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> t = int ( input ( ) . split ( ) ) <NEWLINE> <NL> d = abs ( b_index - a_index ) <NEWLINE> d_v = abs ( b_v - a_v ) <NEWLINE> <NL> if d == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif d_v != 0 and d / d_v <= t : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
def tag ( a , b , v , w , t ) : <NEWLINE> <INDENT> if w >= v : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> elif w == v : <NEWLINE> <INDENT> res = a + ( v * ( t + 1 ) ) - b ( w + t ) <NEWLINE> if res > - 1 : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> return <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> res = a + ( v * t ) - b ( w + t ) <NEWLINE> if res > - 1 : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> return <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> a , v = map ( int , input ( ) . split ( ) ) <NEWLINE> b , w = map ( int , input ( ) . split ( ) ) <NEWLINE> t = int ( input ( ) ) <NEWLINE> print ( tag ( a , b , v , w , t ) ) <NEWLINE> <DEDENT>
a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c = int ( input ( ) ) <NEWLINE> <NL> aa = a [ 0 ] + a [ 1 ] * c <NEWLINE> bb = b [ 0 ] + b [ 1 ] * c <NEWLINE> d = aa - bb <NEWLINE> e = a [ 1 ] - b [ 1 ] <NEWLINE> <NL> if aa > bb : <NEWLINE> <INDENT> if d % e == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> elif aa = bb : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
A , V = map ( int , input ( ) . split ( ) ) <NEWLINE> B , W = map ( int , input ( ) . split ( ) ) <NEWLINE> T = int ( input ( ) ) <NEWLINE> <NL> if W >= V and A != B : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( 0 ) <NEWLINE> <NL> <DEDENT> if A * B < 0 : <NEWLINE> <INDENT> if ( abs ( A ) + abs ( B ) ) // ( V - W ) <= T : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else <NEWLINE> <INDENT> if abs ( abs ( A ) - abs ( B ) ) // ( V - W ) <= T : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
a , v = map ( int , input ( ) . split ( ) ) <NEWLINE> b , w = map ( int , input ( ) . split ( ) ) <NEWLINE> t = int ( input ( ) ) <NEWLINE> <NL> dis = abs ( a - b ) <NEWLINE> sub = w - v <NEWLINE> <NL> if ( - ( sub * t ) >= dis ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE>
A , V = map ( int , input ( ) . split ( ) ) <NEWLINE> B , W = map ( int , input ( ) . split ( ) ) <NEWLINE> T = int ( input ( ) ) <NEWLINE> <NL> lange = abs ( A - B ) <NEWLINE> s = V - W <NEWLINE> <NL> res = 0 <NEWLINE> <NL> if s > 0 : <NEWLINE> <INDENT> tmp = lange / s <NEWLINE> if tmp . float . is_integer ( ) and tmp <= T : <NEWLINE> <INDENT> res = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if ( res == 0 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> c , d == map ( int , input ( ) . split ( ) ) <NEWLINE> e = int ( input ( ) ) <NEWLINE> if abs ( a - c ) > e * abs ( b - d ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , v = map ( int , input ( ) . split ( ) ) <NEWLINE> b , w = map ( int , input ( ) . split ( ) ) <NEWLINE> t = input ( ) <NEWLINE> <NL> if abs ( t * ( w - v ) ) >= abs ( b - a ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , v = map ( int , input ( ) . split ( ) ) <NEWLINE> b , w = map ( int , input ( ) . split ( ) ) <NEWLINE> t = int ( input ( ) ) <NEWLINE> l = b - a <NEWLINE> s = v - w <NEWLINE> <NL> <INDENT> print ( <STRING> if l <= s * t else <STRING> ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> a , v = map ( int , input ( ) . split ( ) ) <NEWLINE> b , w = map ( int , input ( ) . split ( ) ) <NEWLINE> t = int ( input ( ) ) <NEWLINE> ans = True <NEWLINE> <NL> a_can_plus = min ( a + v * t , 10 ** 8 ) <NEWLINE> a_can_minus = max ( a - v * t , - 10 ** 8 ) <NEWLINE> b_can_plus = min ( b + w * t , 10 ** 8 ) <NEWLINE> b_can_minus = max ( b - w * t , - 10 ** 8 ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> if v - w < 0 : <NEWLINE> <INDENT> ans = False <NEWLINE> <DEDENT> elif ( v - w ) * t >= abs ( a - b ) : <NEWLINE> <INDENT> ans = True <NEWLINE> <DEDENT> elif a > b : <NEWLINE> <INDENT> if b_can_minus < a_can_minus : <NEWLINE> ans = False <NEWLINE> else : <NEWLINE> ans = True <NEWLINE> <DEDENT> elif a < b : <NEWLINE> <INDENT> if a_can_plus < b_can_plus : <NEWLINE> <INDENT> ans = False <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = True <NEWLINE> <NL> <DEDENT> <DEDENT> if ans : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> main ( ) <NEWLINE>
import numpy as np <NEWLINE> <NL> A , V = map ( int , input ( ) . split ( ) ) <NEWLINE> B , W = map ( int , input ( ) . split ( ) ) <NEWLINE> T = int ( input ( ) ) <NEWLINE> <NL> if V <= W : print ( <STRING> ) <NEWLINE> elif : np . abs ( A - B ) / ( V - W ) <= T : print ( <STRING> ) <NEWLINE> else : print ( <STRING> ) <NEWLINE>
A , V = map ( int , input ( ) . split ( ) ) <NEWLINE> B , W = map ( int , input ( ) . split ( ) ) <NEWLINE> t = input ( ) <NEWLINE> T = int ( t ) <NEWLINE> <NL> if ( B - A ) + ( V - W ) T <= 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , v = map ( int , input ( ) . split ( ) ) <NEWLINE> b , w = map ( int , input ( ) . split ( ) ) <NEWLINE> t = int ( input ( ) ) <NEWLINE> <NL> s = abs ( b - a ) <NEWLINE> y = ( v - w ) <NEWLINE> <NL> if y <= 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> m = s % y <NEWLINE> u = s // y <NEWLINE> if m == 0 and u <= t <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
a , v = list ( map ( int , input ( <STRING> ) . split ( ) ) ) <NEWLINE> b , w = list ( map ( int , input ( <STRING> ) . split ( ) ) ) <NEWLINE> t = int ( input ( <STRING> ) ) <NEWLINE> <NL> l = abs ( a - b ) <NEWLINE> <NL> if ( v - w ) * t >= l : <NEWLINE> <INDENT> Print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> Print ( <STRING> ) <NEWLINE> <DEDENT>
A = input ( <STRING> ) <NEWLINE> V = input ( <STRING> ) <NEWLINE> B = input ( <STRING> ) <NEWLINE> W = input ( <STRING> ) <NEWLINE> T = input ( <STRING> ) <NEWLINE> <NL> A = int ( A ) <NEWLINE> V = int ( V ) <NEWLINE> B = int ( B ) <NEWLINE> W = int ( W ) <NEWLINE> T = int ( T ) <NEWLINE> <NL> if ( V - W ) * T >= A - B : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> def input_one_number ( ) : <NEWLINE> <INDENT> return int ( input ( ) ) <NEWLINE> <NL> <DEDENT> def input_multiple_number ( ) : <NEWLINE> <INDENT> return map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <DEDENT> def input_multiple_number_as_list ( ) : <NEWLINE> <INDENT> return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> <DEDENT> A , V = input_multiple_number ( ) <NEWLINE> B , W = input_multiple_number ( ) <NEWLINE> T = input_one_number ( ) <NEWLINE> <NL> D = abs ( B - A ) <NEWLINE> v = W - V <NEWLINE> <NL> if D - v * T > 0 or : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT>
import sys <NEWLINE> a , v = map ( int , input ( ) . split ( ) ) <NEWLINE> b , w = map ( int , input ( ) . split ( ) ) <NEWLINE> t = int ( input ( ) ) <NEWLINE> if a = b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> if a < b and a + v * t >= b + w * t : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a > b and a - v * t < b - w * t : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
A , V = map ( int , input ( ) . split ( ) ) <NEWLINE> B , W = map ( int , input ( ) . split ( ) ) <NEWLINE> T = int ( input ( ) ) <NEWLINE> <NL> ans = <STRING> <NEWLINE> <NL> if ( A < B ) : <NEWLINE> <INDENT> if ( A + V * T >= B + W * T ) : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <DEDENT> <DEDENT> elif ( A > B ) : <NEWLINE> <INDENT> if ( A + ( - 1 ) * V * T = < B + ( - 1 ) * W * T ) : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N , S = map ( int , input ( ) . split ( ) ) <NEWLINE> n , s = map ( int , input ( ) . split ( ) ) <NEWLINE> T = int ( input ( ) ) <NEWLINE> <NL> if ( N - n ) % ( S - s ) == 0 and N + S * T >= n + s * t : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
A , V = map ( int , input ( ) . split ( ) ) <NEWLINE> B , W = map ( int , input ( ) . split ( ) ) <NEWLINE> T = int ( input ( ) ) <NEWLINE> <NL> A_sum = A + V * T <NEWLINE> B_sum = B + W * T <NEWLINE> <NL> if B > A : <NEWLINE> <INDENT> if A_sum >= B_sum : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if A_sum <= B_sum <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
a , v = map ( int , input ( ) . split ( ) ) <NEWLINE> b , w = map ( int , input ( ) . split ( ) ) <NEWLINE> t = int ( input ( ) ) <NEWLINE> <NL> M = max ( a , b ) <NEWLINE> m = min ( a , b ) <NEWLINE> <NL> if ( v - w ) * t > M - n : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , v = ( int ( x ) for x in input ( ) . split ( ) ) <NEWLINE> b , w = ( int ( x ) for x in input ( ) . split ( ) ) <NEWLINE> t = int ( input ( ) ) <NEWLINE> <NL> distance = abs ( a - b ) <NEWLINE> sa = v - w <NEWLINE> <NL> if sa == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif distance % sa == 0 and distance = < t * sa : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , c = map ( int , input ( ) . split ( ) ) <NEWLINE> b , d = map ( int , input ( ) . split ( ) ) <NEWLINE> t = map ( int , input ( ) . split ( ) ) <NEWLINE> if c <= d : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif abs ( a - b ) <= ( c - d ) * t : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
info_A = input ( ) . split ( ) <NEWLINE> info_B = input ( ) . split ( ) <NEWLINE> T = int ( input ( ) ) <NEWLINE> win = <STRING> <NEWLINE> <NL> A = int ( info_A [ 0 ] ) <COMMENT> <NEWLINE> V = int ( info_A [ 1 ] ) <COMMENT> <NEWLINE> B = int ( info_B [ 0 ] ) <COMMENT> <NEWLINE> W = int ( info_B [ 1 ] ) <COMMENT> <NEWLINE> <NL> <COMMENT> <NL> if W >= V : <NEWLINE> <INDENT> win = <STRING> <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <COMMENT> <NL> <INDENT> k = ( B - A ) / ( V - W ) <NEWLINE> if k <= T and 0 < k and ( k * 10 ) % 10 == 0 <NEWLINE> <INDENT> win = <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> if win == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
A , V = map ( int , input ( ) . split ( ) ) <NEWLINE> B , W = map ( int , input ( ) . split ( ) ) <NEWLINE> T = int ( input ( ) <NEWLINE> dist = abs ( A - B ) <NEWLINE> vec = V - W <NEWLINE> print ( <STRING> if vec * T >= dist else <STRING> ) <NEWLINE>
stdin = [ input ( ) for i in range ( 3 ) ] <NEWLINE> line = stdin [ 0 ] . split ( <STRING> ) <NEWLINE> A = int ( line [ 0 ] ) <NEWLINE> V = int ( line [ 1 ] ) <NEWLINE> line = stdin [ 1 ] . split ( <STRING> ) <NEWLINE> B = int ( line [ 0 ] ) <NEWLINE> W = int ( line [ 1 ] ) <NEWLINE> T = int ( stdin [ 2 ] ) <NEWLINE> length = 0 <NEWLINE> if B < A : <NEWLINE> <INDENT> length = B - A <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> length = A - B <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if ( V - W ) * T < length : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
a , v = map ( int , input ( ) . split ( ) ) <NEWLINE> b , w = map ( int , input ( ) . split ( ) ) <NEWLINE> t = input ( int ( ) ) <NEWLINE> <NL> if w >= v : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> elif abs ( a - b ) / abs ( v - w ) <= t : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , v = map ( int , input ( ) . split ( ) ) <NEWLINE> b , w = map ( int , input ( ) . split ( ) ) <NEWLINE> t = int ( input ( ) ) <NEWLINE> if abs ( b - a ) - ( v - w ) * t <= 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> ekes : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , v = map ( int , input ( ) . split ( ) ) <NEWLINE> b , w = map ( int , input ( ) . split ( ) ) <NEWLINE> t = int ( input ( ) ) <NEWLINE> <NL> p = abs ( a - b ) <NEWLINE> u = v - w <NEWLINE> if d - u * t <= 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
A , V = map ( int , input ( ) . split ( ) ) <NEWLINE> B , W = map ( int , input ( ) . split ( ) ) <NEWLINE> T = int ( input ( ) ) <NEWLINE> <NL> for i in range ( 1 , T + 1 ) : <NEWLINE> <INDENT> if i * ( V - W ) >= B - A : print ( <STRING> ) break <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE>
a , v = map ( int , input ( ) . split ( ) ) <NEWLINE> b , w = map ( int , input ( ) . split ( ) ) <NEWLINE> t = int ( input ( ) ) <NEWLINE> z = ( v * t ) + a <NEWLINE> y = ( w * t ) + b <NEWLINE> if w >= v : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> if z - y >= 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
<NL> def main ( ) : <NEWLINE> <INDENT> A , V = map ( int , input ( ) . split ( ) ) <NEWLINE> B , W = map ( int , input ( ) . split ( ) ) <NEWLINE> T = int ( input ( ) ) <NEWLINE> <COMMENT> <NL> <NL> if ( ) <NEWLINE> <NL> if ( ( V - W ) * T - abs ( B - A ) >= 0 ) : <NEWLINE> <INDENT> return print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return print ( <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
A , V = map ( int , input ( ) . split ( ) ) <NEWLINE> B , W = map ( int , input ( ) . split ( ) ) <NEWLINE> T = int ( input ( ) ) <NEWLINE> if A >= B <NEWLINE> <INDENT> if A + V * T >= B + W * T : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if V >= W : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif A + V * T >= B + W * T : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
A , V , B , W , T = map ( int , input ( ) . split ( ) ) <NEWLINE> if abs ( B - A ) > ( V - W ) * T : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import sys <NEWLINE> import numpy as np <NEWLINE> from numba import njit <NEWLINE> <NL> read = sys . stdin . buffer . read <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> readlines = sys . stdin . buffer . readlines <NEWLINE> <NL> def update ( A ) : <NEWLINE> <INDENT> N = len ( A ) <NEWLINE> B = np . zeros_like ( A ) <NEWLINE> for i , x in enumerate ( A ) : <NEWLINE> <INDENT> l = max ( 0 , i - x ) <NEWLINE> r = min ( N - 1 , i + x ) <NEWLINE> B [ l ] += 1 <NEWLINE> if r + 1 < N : <NEWLINE> <INDENT> B [ r + 1 ] -= 1 <NEWLINE> <DEDENT> <DEDENT> B = np . cumsum ( B ) <NEWLINE> return B <NEWLINE> <NL> <DEDENT> N , K = map ( int , readline ( ) . split ( ) ) <NEWLINE> A = np . array ( read ( ) . split ( ) , np . int64 ) <NEWLINE> <NL> K = min ( K , 100 ) <NEWLINE> for _ in range ( K ) : <NEWLINE> <INDENT> A = update ( A ) <NEWLINE> <DEDENT> print ( <STRING> . join ( A . astype ( str ) ) ) <NEWLINE>
import numpy as np <NEWLINE> from numba import jit <NEWLINE> @ jit ( cache = True ) <NEWLINE> def solve ( n , k , A ) : <NEWLINE> <INDENT> l , r = 0 , 0 <NEWLINE> for ki in range ( k ) : <NEWLINE> <INDENT> B = np . zeros ( n + 1 , dtype = np . int64 ) <NEWLINE> for i , j in enumerate ( A ) : <NEWLINE> <INDENT> l = max ( 0 , i - j ) <NEWLINE> r = min ( n , i + j + 1 ) <NEWLINE> B [ l ] += 1 <NEWLINE> B [ r ] -= 1 <NEWLINE> <DEDENT> A = np . cumsum ( B [ : - 1 ] ) <NEWLINE> np . delete ( A , n - 1 ) <NEWLINE> <DEDENT> return A <NEWLINE> <NL> <DEDENT> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A = np . array ( A ) <NEWLINE> x = solve ( n , k , A ) <NEWLINE> print ( * x ) <NEWLINE>
from numba import njit <NEWLINE> <NL> @ njit <NEWLINE> def calc ( A ) : <NEWLINE> <INDENT> B = [ 0 ] * len ( A ) <NEWLINE> for i in range ( len ( A ) ) : <NEWLINE> <INDENT> B [ max ( 0 , i - A [ i ] ) ] += 1 <NEWLINE> if i + A [ i ] + 1 < len ( A ) : <NEWLINE> <INDENT> B [ i + A [ i ] + 1 ] -= 1 <NEWLINE> <DEDENT> <DEDENT> for i in range ( 1 , len ( B ) ) : <NEWLINE> <INDENT> B [ i ] = B [ i - 1 ] + B [ i ] <NEWLINE> <DEDENT> return B <NEWLINE> <NL> <DEDENT> import sys <NEWLINE> readline = sys . stdin . readline <NEWLINE> <NL> N , K = map ( int , readline ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , readline ( ) . split ( ) ) ) <NEWLINE> <NL> for i in range ( K ) : <NEWLINE> <INDENT> A = calc ( A ) <NEWLINE> if len ( set ( A ) ) == 1 and A [ 0 ] == N : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> print ( * A ) <NEWLINE>
import numpy as np <NEWLINE> from numba import jit <NEWLINE> <NL> @ jit ( <STRING> , cashe = True ) <NEWLINE> def solve ( n , k , A ) : <NEWLINE> <INDENT> l , r = 0 , 0 <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> B = np . zeros ( n + 1 , dtype = np . int64 ) <NEWLINE> for x , y in enumerate ( list ( A ) ) : <NEWLINE> <INDENT> l = max ( 0 , x - y ) <NEWLINE> r = min ( n , x + y + 1 ) <NEWLINE> B [ l ] += 1 <NEWLINE> B [ r ] -= 1 <NEWLINE> <DEDENT> A = np . cumsum ( B [ : - 1 ] ) <NEWLINE> if A [ A == n ] . size == n : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> return A <NEWLINE> <DEDENT> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A = np . array ( a ) <NEWLINE> X = solve ( n , k , A ) <NEWLINE> print ( * X , sep = <STRING> ) <NEWLINE>
import sys <NEWLINE> from itertools import accumulate <NEWLINE> from numba import njit <NEWLINE> <NL> readline = sys . stdin . readline <NEWLINE> readall = sys . stdin . read <NEWLINE> ns = lambda : readline ( ) . rstrip ( ) <NEWLINE> ni = lambda : int ( readline ( ) . rstrip ( ) ) <NEWLINE> nm = lambda : map ( int , readline ( ) . split ( ) ) <NEWLINE> nl = lambda : list ( map ( int , readline ( ) . split ( ) ) ) <NEWLINE> prn = lambda x : print ( * x , sep = <STRING> ) <NEWLINE> <NL> @ njit ( cache = True ) <NEWLINE> def solve ( n , k , a ) : <NEWLINE> <INDENT> if n == 0 : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> for _ in range ( k ) : <NEWLINE> <INDENT> b = [ 0 ] * n <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if i > a [ i ] : <NEWLINE> <INDENT> b [ i - a [ i ] ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> b [ 0 ] += 1 <NEWLINE> <DEDENT> if i + a [ i ] + 1 < n : <NEWLINE> <INDENT> b [ i + a [ i ] + 1 ] -= 1 <NEWLINE> <DEDENT> <DEDENT> a = list ( accumulate ( b ) ) <NEWLINE> if min ( a ) >= n : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> print ( * a ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> solve ( 0 , 0 , 0 ) <NEWLINE> n , k = nm ( ) <NEWLINE> a = nl ( ) <NEWLINE> solve ( n , k , a ) <NEWLINE>
import sys <NEWLINE> import numpy as np <NEWLINE> from numba import njit <NEWLINE> <NL> read = sys . stdin . read <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> sys . setrecursionlimit ( 10 ** 8 ) <NEWLINE> INF = float ( <STRING> ) <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> <NL> <NL> @ njit ( <STRING> , cache = True ) <NEWLINE> def func ( n , k , A ) : <NEWLINE> <INDENT> for _ in range ( k ) : <NEWLINE> <INDENT> B = np . zeros ( n + 1 , np . int64 ) <NEWLINE> for i , a in enumerate ( A ) : <NEWLINE> <INDENT> B [ max ( 0 , i - a ) ] += 1 <NEWLINE> B [ min ( i + a + 1 , n ) ] -= 1 <NEWLINE> <DEDENT> A = B . cumsum ( ) [ : - 1 ] <NEWLINE> <DEDENT> return A <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> N , K = map ( int , readline ( ) . split ( ) ) <NEWLINE> A = np . array ( readline ( ) . split ( ) , np . int64 ) <NEWLINE> ans = func ( N , K , A ) <NEWLINE> print ( * ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> from numba import njit <NEWLINE> <COMMENT> <NL> <NL> @ njit ( cache = True ) <NEWLINE> def main ( N , K , A ) : <NEWLINE> <INDENT> A = np . array ( A , dtype = int ) <NEWLINE> for k in range ( K ) : <NEWLINE> <COMMENT> <NL> <INDENT> B = np . zeros ( N + 1 , dtype = int ) <NEWLINE> for x in range ( N ) : <NEWLINE> <INDENT> minimum = max ( 0 , x - A [ x ] ) <NEWLINE> maximum = min ( N , x + A [ x ] + 1 ) <NEWLINE> <COMMENT> <NL> B [ minimum ] += 1 <NEWLINE> B [ maximum ] -= 1 <NEWLINE> A = np . cumsum ( B ) [ : - 1 ] <NEWLINE> <DEDENT> if np . all ( A == N ) : <NEWLINE> <COMMENT> <NL> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> . join ( [ str ( i ) for i in A ] ) ) <NEWLINE> <NL> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> N , K = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> main ( N , K , A ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> from numba import jit <NEWLINE> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = np . array ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> @ jit <NEWLINE> for j in range ( 1 , min ( k + 1 , 50 ) ) : <NEWLINE> <INDENT> tmp = np . zeros ( n + 1 , dtype = np . int64 ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> tmp [ max ( 0 , i - a [ i ] ) ] += 1 <NEWLINE> tmp [ min ( i + a [ i ] + 1 , n ) ] -= 1 <NEWLINE> <DEDENT> tmp = np . cumsum ( tmp ) <NEWLINE> a = tmp [ : n ] <NEWLINE> <DEDENT> print ( * a ) <NEWLINE>
import numpy as np <NEWLINE> from numba import njit <NEWLINE> <NL> @ njit ( cache = True ) <NEWLINE> def light ( n , a_list ) : <NEWLINE> <INDENT> outcome = np . zeros ( n + 1 , dtype = np . int64 ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> outcome [ max ( 0 , i - a_list [ i ] ) ] += 1 <NEWLINE> outcome [ min ( n , i + a_list [ i ] + 1 ) ] -= 1 <NEWLINE> <DEDENT> outcome = np . cumsum ( outcome ) [ : - 1 ] <NEWLINE> return outcome <NEWLINE> <NL> <DEDENT> for _ in range ( k ) : <NEWLINE> <INDENT> if min ( a ) == n : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> a = light ( n , a ) <NEWLINE> <NL> <DEDENT> [ print ( aa , end = <STRING> ) for aa in a ] <NEWLINE>
import numpy as np <NEWLINE> from numba import njit <NEWLINE> <NL> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = np . array ( a ) <NEWLINE> <NL> @ njit <NEWLINE> def light ( a_list ) : <NEWLINE> <INDENT> outcome = np . array ( [ 0 ] * ( n + 1 ) ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> outcome [ max ( 0 , i - a_list [ i ] ) ] += 1 <NEWLINE> outcome [ min ( n , i + a_list [ i ] + 1 ) ] -= 1 <NEWLINE> <DEDENT> outcome = np . cumsum ( outcome ) [ : - 1 ] <NEWLINE> return outcome <NEWLINE> <NL> <DEDENT> for _ in range ( k ) : <NEWLINE> <INDENT> if sum ( a ) >= n * n : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> a = light ( a ) <NEWLINE> <NL> <DEDENT> [ print ( aa , end = <STRING> ) for aa in a ] <NEWLINE>
import sys <NEWLINE> import numpy as np <NEWLINE> from numba import njit <NEWLINE> <NL> <NL> read = sys . stdin . buffer . read <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> readlines = sys . stdin . buffer . readlines <NEWLINE> <NL> def update ( A ) : <NEWLINE> <INDENT> N = len ( A ) <NEWLINE> B = np . zeros_like ( A ) <NEWLINE> for i , x in enumerate ( A ) : <NEWLINE> <INDENT> l = max ( 0 , i - x ) <NEWLINE> r = min ( N - 1 , i + x ) <NEWLINE> B [ l ] += 1 <NEWLINE> if r + 1 < N : <NEWLINE> <INDENT> B [ r + 1 ] -= 1 <NEWLINE> <DEDENT> <DEDENT> B = np . cumsum ( B ) <NEWLINE> return B <NEWLINE> <NL> <NL> <DEDENT> N , K = map ( int , readline ( ) . split ( ) ) <NEWLINE> A = np . array ( read ( ) . split ( ) , np . int64 ) <NEWLINE> <NL> K = min ( K , 100 ) <NEWLINE> for _ in range ( K ) : <NEWLINE> <INDENT> A = update ( A ) <NEWLINE> <DEDENT> print ( <STRING> . join ( A . astype ( str ) ) ) <NEWLINE>
import numpy as np <NEWLINE> from numba import jit <NEWLINE> @ jit <NEWLINE> def main ( ) : <NEWLINE> <INDENT> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A = np . array ( a ) <NEWLINE> l , r = 0 , 0 <NEWLINE> for i in range ( min ( 41 , k ) ) : <NEWLINE> <INDENT> B = np . zeros ( n + 1 , dtype = np . int64 ) <NEWLINE> for x , y in enumerate ( list ( A ) ) : <NEWLINE> <INDENT> l = max ( 0 , x - y ) <NEWLINE> r = min ( n , x + y + 1 ) <NEWLINE> B [ l ] += 1 <NEWLINE> B [ r ] -= 1 <NEWLINE> <DEDENT> A = np . cumsum ( B [ : - 1 ] ) <NEWLINE> <DEDENT> print ( * A , sep = <STRING> ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> from numba import njit <NEWLINE> <NL> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = np . array ( list ( map ( int , input ( ) . split ( ) ) ) , dtype = np . int64 ) <NEWLINE> <NL> @ njit <NEWLINE> def imos ( a ) : <NEWLINE> <INDENT> b = np . zeros ( n + 1 , dtype = np . int64 ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> l = max ( 0 , i - a [ i ] ) <NEWLINE> r = min ( i + a [ i ] + 1 , n ) <NEWLINE> b [ l ] += 1 <NEWLINE> if r <= n - 1 : b [ r ] -= 1 <NEWLINE> <NL> <DEDENT> b = np . cumsum ( b ) [ : - 1 ] <NEWLINE> return b <NEWLINE> <NL> <DEDENT> for q in range ( k ) : <NEWLINE> <INDENT> a = imos ( a ) <NEWLINE> if np . min ( a ) == N : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( * a ) <NEWLINE>
import numpy as np <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> <COMMENT> <NL> from numba import njit , i8 <NEWLINE> <NL> <NL> @ njit ( i8 [ : ] ( i8 , i8 , i8 [ : ] , i8 , i8 ) ) <NEWLINE> def loop ( N , K , A , left , right ) : <NEWLINE> <INDENT> for j in range ( K ) : <NEWLINE> <INDENT> B = np . zeros_like ( A ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> left = i - A [ i ] <NEWLINE> right = i + A [ i ] + 1 <NEWLINE> if left < 0 : <NEWLINE> <INDENT> left = 0 <NEWLINE> <DEDENT> if right > N : <NEWLINE> <INDENT> right = N <NEWLINE> <DEDENT> B [ left : right ] += 1 <NEWLINE> <DEDENT> A = B <NEWLINE> <DEDENT> return A <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A = np . array ( A ) <NEWLINE> <NL> if K >= 41 : <NEWLINE> <INDENT> M = 41 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> M = K <NEWLINE> <NL> <DEDENT> res = loop ( N , M , A , 0 , 0 ) <NEWLINE> <NL> print ( * res ) <NEWLINE> <NL> <NL> <NL> <DEDENT> main ( ) <NEWLINE>
import numpy as np <NEWLINE> from numba import njit <NEWLINE> <NL> N , K = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> a = np . array ( A , dtype = int ) <NEWLINE> <NL> <NL> fin = [ N ] * N <NEWLINE> <NL> def calc_b ( a ) : <NEWLINE> <INDENT> b = np . zeros ( N , dtype = np . int64 ) <NEWLINE> for i , _a in enumerate ( a ) : <NEWLINE> <INDENT> l = max ( 0 , i - _a ) <NEWLINE> r = min ( N - 1 , i + _a ) <NEWLINE> <NL> <COMMENT> <NL> b [ l ] += 1 <NEWLINE> if r + 1 < N : <NEWLINE> <INDENT> b [ r + 1 ] -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> b = np . cumsum ( b ) <NEWLINE> <COMMENT> <NL> return b <NEWLINE> <NL> <NL> <DEDENT> for k in range ( min ( K , 100 ) ) : <NEWLINE> <COMMENT> <NL> <INDENT> a = calc_b ( a ) <NEWLINE> if all ( a == fin ) : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> a = [ str ( _ ) for _ in a ] <NEWLINE> print ( <STRING> . join ( a ) ) <NEWLINE> <COMMENT> <NL> <NEWLINE>
import numpy as np <NEWLINE> from numba import jit <NEWLINE> @ jit ( cache = True ) <NEWLINE> <NL> def solve ( n , k , A ) : <NEWLINE> <INDENT> l , r = 0 , 0 <NEWLINE> for ki in range ( k ) : <NEWLINE> <INDENT> B = np . zeros ( n + 1 , dtype = int ) <NEWLINE> for i , j in enumerate ( A ) : <NEWLINE> <INDENT> l = max ( 0 , i - j ) <NEWLINE> r = min ( n , i + j + 1 ) <NEWLINE> B [ l ] += 1 <NEWLINE> B [ r ] -= 1 <NEWLINE> <DEDENT> A = np . cumsum ( B [ : - 1 ] ) <NEWLINE> if A [ A == n ] . size == n : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> return A <NEWLINE> <NL> <DEDENT> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> x = solve ( n , k , A ) <NEWLINE> print ( * x ) <NEWLINE> <NL>
import numpy as np <NEWLINE> from numba import njit <NEWLINE> <NL> @ njit <NEWLINE> def solve ( n , k , l ) : <NEWLINE> <INDENT> if k >= 50 : <NEWLINE> <INDENT> k = 50 <NEWLINE> <NL> <DEDENT> dp = [ [ 0 , 0 ] ] <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> dp += [ [ 0 ] * 2 ] <NEWLINE> <NL> <DEDENT> ans = l [ : ] <NEWLINE> <NL> for i in range ( k ) : <NEWLINE> <INDENT> for j in range ( n ) : <NEWLINE> <INDENT> tmp = ans [ j ] <NEWLINE> dp [ j ] [ 0 ] = ( j + 1 - tmp ) <NEWLINE> dp [ j ] [ 1 ] = ( j + 1 + tmp ) <NEWLINE> <NL> <DEDENT> ans = [ 0 ] * n <NEWLINE> <NL> for x in range ( n ) : <NEWLINE> <INDENT> for y in range ( n ) : <NEWLINE> <INDENT> if dp [ y ] [ 0 ] <= x + 1 <= dp [ y ] [ 1 ] : <NEWLINE> <INDENT> ans [ x ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> return ans <NEWLINE> <NL> <DEDENT> <DEDENT> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> print ( * solve ( n , k , l ) ) <NEWLINE> <NL>
import numpy as np <NEWLINE> from numba import njit <NEWLINE> <NL> @ njit <NEWLINE> def main ( ) : <NEWLINE> <NL> <INDENT> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for k in range ( K ) : <NEWLINE> <INDENT> B = [ 0 ] * ( N + 1 ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> a = A [ i ] <NEWLINE> start = max ( 0 , i - a ) <NEWLINE> end = min ( N , i + a + 1 ) <NEWLINE> B [ start ] += 1 <NEWLINE> B [ end ] -= 1 <NEWLINE> <DEDENT> B = np . array ( B ) <NEWLINE> A = np . cumsum ( B ) [ : N ] <NEWLINE> if A . min ( ) == N : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> print ( * A ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> from numba import njit <NEWLINE> <NL> @ njit ( <STRING> , cache = True ) <NEWLINE> def fn ( N , K , A ) : <NEWLINE> <INDENT> for _ in range ( 0 , min ( 42 , K ) ) : <NEWLINE> <INDENT> B = np . zeros ( N , dtype = np . int64 ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> l = max ( 0 , i - A [ i ] ) <NEWLINE> r = min ( N - 1 , i + A [ i ] ) <NEWLINE> B [ l ] += 1 <NEWLINE> if ( r + 1 < N ) : <NEWLINE> <INDENT> B [ r + 1 ] -= 1 <NEWLINE> <DEDENT> <DEDENT> A = np . cumsum ( B ) <NEWLINE> if ( np . all ( A == N ) ) : <NEWLINE> <INDENT> break ; <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A = np . array ( A , dtype = np . int64 ) <NEWLINE> A = fn ( N , K , A ) <NEWLINE> print ( <STRING> . join ( [ str ( item ) for item in A ] ) ) <NEWLINE>
from numba import jit <NEWLINE> import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> <NL> @ jit <NEWLINE> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for _ in range ( K ) : <NEWLINE> <INDENT> B = [ 0 ] * ( N + 1 ) <NEWLINE> for i , a in enumerate ( A ) : <NEWLINE> <INDENT> B [ max ( 0 , i - a ) ] += 1 <NEWLINE> B [ min ( N , i + a + 1 ) ] -= 1 <NEWLINE> <DEDENT> for j in range ( 1 , N ) : <NEWLINE> <INDENT> B [ j ] += B [ j - 1 ] <NEWLINE> <DEDENT> if A == B [ : - 1 ] : <NEWLINE> <INDENT> A = B [ : - 1 ] <NEWLINE> break <NEWLINE> <DEDENT> A = B [ : - 1 ] <NEWLINE> <NL> <DEDENT> ans = <STRING> . join ( list ( map ( str , A ) ) ) <NEWLINE> print ( ans ) <NEWLINE>
import numpy as np <NEWLINE> from numba import njit <NEWLINE> <NL> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> A_list = np . array ( [ 0 ] + list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> @ njit <NEWLINE> def update ( A_list ) : <NEWLINE> <NL> <INDENT> for j in range ( K ) : <NEWLINE> <INDENT> new_A = np . zeros ( N + 2 , dtype = np . int64 ) <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <COMMENT> <NL> <INDENT> mi = i - A_list [ i ] <NEWLINE> ma = i + A_list [ i ] <NEWLINE> if mi < 0 : <NEWLINE> <INDENT> mi = 0 <NEWLINE> <DEDENT> if ma > N : <NEWLINE> <INDENT> ma = N <NEWLINE> <COMMENT> <NL> <DEDENT> new_A [ mi ] += 1 <NEWLINE> new_A [ ma + 1 ] -= 1 <NEWLINE> <NL> <DEDENT> A_list = np . cumsum ( new_A ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> return ( A_list ) <NEWLINE> <NL> <DEDENT> A_list = update ( A_list ) <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> print ( A_list [ i ] , end = <STRING> ) <NEWLINE> <DEDENT>
from numba import njit <NEWLINE> <NL> @ njit <NEWLINE> def solve ( ) : <NEWLINE> <INDENT> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if k >= 50 : <NEWLINE> <INDENT> k = 50 <NEWLINE> <NL> <DEDENT> dp = [ [ 0 ] * 2 for i in range ( n ) ] <NEWLINE> <NL> ans = l [ : ] <NEWLINE> <NL> for i in range ( k ) : <NEWLINE> <INDENT> for j in range ( n ) : <NEWLINE> <INDENT> tmp = ans [ j ] <NEWLINE> dp [ j ] [ 0 ] = ( j + 1 - tmp ) <NEWLINE> dp [ j ] [ 1 ] = ( j + 1 + tmp ) <NEWLINE> <NL> <DEDENT> ans = [ 0 ] * n <NEWLINE> <NL> for x in range ( n ) : <NEWLINE> <INDENT> for y in range ( n ) : <NEWLINE> <INDENT> if dp [ y ] [ 0 ] <= x + 1 <= dp [ y ] [ 1 ] : <NEWLINE> <INDENT> ans [ x ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> return ans <NEWLINE> <NL> <DEDENT> <DEDENT> print ( * solve ( ) ) <NEWLINE> <NL>
import sys <NEWLINE> import copy <NEWLINE> from numba import njit <NEWLINE> <NL> def I ( ) : return int ( sys . stdin . readline ( ) . rstrip ( ) ) <NEWLINE> def LI ( ) : return list ( map ( int , sys . stdin . readline ( ) . rstrip ( ) . split ( ) ) ) <NEWLINE> def LS ( ) : return list ( sys . stdin . readline ( ) . rstrip ( ) . split ( ) ) <NEWLINE> <NL> @ njit ( <STRING> , cache = True ) <NEWLINE> def main ( N , K , A ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> <INDENT> for k in range ( K ) : <NEWLINE> <INDENT> B = [ 0 ] * N <NEWLINE> for i , a in enumerate ( A ) : <NEWLINE> <COMMENT> <NL> <INDENT> if a == 0 : <NEWLINE> <INDENT> B [ i ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <INDENT> for p in range ( i - a , i + a + 1 ) : <NEWLINE> <COMMENT> <NL> <INDENT> if p >= 0 and p < N : <NEWLINE> <INDENT> B [ p ] += 1 <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if k < K - 1 : <NEWLINE> <INDENT> A = B <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> return B <NEWLINE> <NL> <NL> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> N , K = LI ( ) [ : ] <NEWLINE> A = LI ( ) <NEWLINE> B = main ( N , K , A ) <NEWLINE> print ( B ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> from numba import njit <NEWLINE> <NL> <NL> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = np . array ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> def update ( a ) : <NEWLINE> <INDENT> b = np . zeros_like ( a ) <NEWLINE> for i , x in enumerate ( a ) : <NEWLINE> <INDENT> l = max ( 0 , i - x ) <NEWLINE> r = min ( n - 1 , i + x ) <NEWLINE> b [ l ] += 1 <NEWLINE> if r + 1 < n : <NEWLINE> <INDENT> b [ r + 1 ] -= 1 <NEWLINE> <DEDENT> <DEDENT> b = np . cumsum ( b ) <NEWLINE> return b <NEWLINE> <DEDENT> k = min ( k , 100 ) <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> a = update ( a ) <NEWLINE> <DEDENT> print ( <STRING> . join ( a . astype ( str ) ) ) <NEWLINE>
@ njit <NEWLINE> def solve ( ) : <NEWLINE> <INDENT> import sys <NEWLINE> readline = sys . stdin . readline <NEWLINE> <NL> N , K = map ( int , readline ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , readline ( ) . split ( ) ) ) <NEWLINE> def calc ( A ) : <NEWLINE> <INDENT> B = [ 0 ] * len ( A ) <NEWLINE> for i in range ( len ( A ) ) : <NEWLINE> <INDENT> B [ max ( 0 , i - A [ i ] ) ] += 1 <NEWLINE> if i + A [ i ] + 1 < len ( A ) : <NEWLINE> <INDENT> B [ i + A [ i ] + 1 ] -= 1 <NEWLINE> <DEDENT> <DEDENT> for i in range ( 1 , len ( B ) ) : <NEWLINE> <INDENT> B [ i ] = B [ i - 1 ] + B [ i ] <NEWLINE> <DEDENT> return B <NEWLINE> <NL> <DEDENT> for i in range ( K ) : <NEWLINE> <INDENT> A = calc ( A ) <NEWLINE> if len ( set ( A ) ) == 1 and A [ 0 ] == N : <NEWLINE> <INDENT> print ( * A ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( * A ) <NEWLINE> <NL> <DEDENT> <DEDENT> solve ( ) <NEWLINE>
import numpy as np <NEWLINE> from numba import njit <NEWLINE> <NL> N , K = list ( map ( int , input ( ) . strip ( ) . split ( ) ) ) <NEWLINE> A = np . array ( input ( ) . strip ( ) . split ( ) , dtype = int ) <NEWLINE> <NL> @ njit <NEWLINE> def calc ( A , step ) : <NEWLINE> <INDENT> b = np . array ( [ 0 ] * N ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> left = int ( max ( 0 , i - A [ i ] ) ) <NEWLINE> right = int ( min ( N - 1 , i + A [ i ] ) ) <NEWLINE> b [ left : right + 1 ] += 1 <NEWLINE> <NL> <DEDENT> if A is not b and step < K : <NEWLINE> <INDENT> step += 1 <NEWLINE> A = b . copy ( ) <NEWLINE> return calc ( A , step ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return b . copy ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> ans = calc ( A , 1 ) <NEWLINE> ans = [ str ( x ) for x in ans ] <NEWLINE> print ( <STRING> . join ( ans ) ) <NEWLINE>
import sys <NEWLINE> import numpy as np <NEWLINE> from numba import njit <NEWLINE> <NL> <NL> read = sys . stdin . buffer . read <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> readlines = sys . stdin . buffer . readlines <NEWLINE> <NL> def update ( A ) : <NEWLINE> <INDENT> N = len ( A ) <NEWLINE> B = np . zeros_like ( A ) <NEWLINE> for i , x in enumerate ( A ) : <NEWLINE> <INDENT> l = max ( 0 , i - x ) <NEWLINE> r = min ( N - 1 , i + x ) <NEWLINE> B [ l ] += 1 <NEWLINE> if r + 1 < N : <NEWLINE> <INDENT> B [ r + 1 ] -= 1 <NEWLINE> <DEDENT> <DEDENT> B = np . cumsum ( B ) <NEWLINE> return B <NEWLINE> <NL> <NL> <DEDENT> N , K = map ( int , readline ( ) . split ( ) ) <NEWLINE> A = np . array ( read ( ) . split ( ) , np . int64 ) <NEWLINE> <NL> for _ in range ( K ) : <NEWLINE> <INDENT> A = update ( A ) <NEWLINE> if np . all ( A == N ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> . join ( A . astype ( str ) ) ) <NEWLINE>
import sys <NEWLINE> import numpy as np <NEWLINE> from numba import njit <NEWLINE> <NL> read = sys . stdin . buffer . read <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> readlines = sys . stdin . buffer . readlines <NEWLINE> <NL> def update ( A ) : <NEWLINE> <INDENT> N = len ( A ) <NEWLINE> B = np . zeros_like ( A ) <NEWLINE> for i , x in enumerate ( A ) : <NEWLINE> <INDENT> l = max ( 0 , i - x ) <NEWLINE> r = min ( N - 1 , i + x ) <NEWLINE> B [ l ] += 1 <NEWLINE> if r + 1 < N : <NEWLINE> <INDENT> B [ r + 1 ] -= 1 <NEWLINE> <DEDENT> <DEDENT> B = np . cumsum ( B ) <NEWLINE> return B <NEWLINE> <NL> <DEDENT> N , K = map ( int , readline ( ) . split ( ) ) <NEWLINE> A = np . array ( read ( ) . split ( ) , np . int64 ) <NEWLINE> <NL> K = min ( K , 100 ) <NEWLINE> for _ in range ( K ) : <NEWLINE> <INDENT> A = update ( A ) <NEWLINE> <DEDENT> print ( <STRING> . join ( A . astype ( str ) ) ) <NEWLINE>
import numpy as np <NEWLINE> from numba import jit <NEWLINE> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = np . array ( a , np . int64 ) <NEWLINE> <NL> @ njit ( <STRING> , cache = True ) <NEWLINE> def imo ( a ) : <NEWLINE> <INDENT> imos = np . zeros ( n + 1 , np . int64 ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> imos [ max ( 0 , i - a [ i ] ) ] += 1 <NEWLINE> imos [ min ( n , i + a [ i ] + 1 ) ] -= 1 <NEWLINE> <NL> <DEDENT> immo = np . zeros ( n + 1 , np . int64 ) <NEWLINE> immo = np . cumsum ( imos ) <NEWLINE> return immo [ : n ] <NEWLINE> <NL> <NL> <DEDENT> for _ in range ( min ( k , 41 ) ) : <NEWLINE> <INDENT> a = imo ( a ) <NEWLINE> <NL> <DEDENT> print ( * a ) <NEWLINE>
import sys <NEWLINE> import numpy as np <NEWLINE> from numba import njit <NEWLINE> <NL> <NL> read = sys . stdin . buffer . read <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> readlines = sys . stdin . buffer . readlines <NEWLINE> <NL> @ njit ( <STRING> , cache = True ) <NEWLINE> def update ( A ) : <NEWLINE> <INDENT> N = len ( A ) <NEWLINE> B = np . zeros_like ( A ) <NEWLINE> for i , x in enumerate ( A ) : <NEWLINE> <INDENT> l = max ( 0 , i - x ) <NEWLINE> r = min ( N - 1 , i + x ) <NEWLINE> B [ l ] += 1 <NEWLINE> if r + 1 < N : <NEWLINE> <INDENT> B [ r + 1 ] -= 1 <NEWLINE> <DEDENT> <DEDENT> B = np . cumsum ( B ) <NEWLINE> return B <NEWLINE> <NL> <NL> <DEDENT> N , K = map ( int , readline ( ) . split ( ) ) <NEWLINE> A = np . array ( read ( ) . split ( ) , np . int64 ) <NEWLINE> <NL> k = min ( K , 100 ) <NEWLINE> for _ in range ( K ) : <NEWLINE> <INDENT> A = update ( A ) <NEWLINE> <DEDENT> print ( <STRING> . join ( A . astype ( str ) ) ) <NEWLINE>
from numba import jit <NEWLINE> <NL> <NL> def solve ( N , K , A ) : <NEWLINE> <INDENT> for _ in range ( K ) : <NEWLINE> <INDENT> imos = [ 0 ] * ( N + 1 ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> left = max ( 0 , i - A [ i ] ) <NEWLINE> right = min ( N - 1 , i + A [ i ] ) + 1 <NEWLINE> imos [ left ] += 1 <NEWLINE> imos [ right ] += - 1 <NEWLINE> <NL> <DEDENT> next_A = [ 0 ] * N <NEWLINE> next_A [ 0 ] = imos [ 0 ] <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> next_A [ i ] = next_A [ i - 1 ] + imos [ i ] <NEWLINE> <NL> <DEDENT> if A == next_A : <NEWLINE> <INDENT> return A <NEWLINE> <DEDENT> A = next_A <NEWLINE> <DEDENT> return A <NEWLINE> <NL> <NL> <DEDENT> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> print ( <STRING> . join ( [ str ( x ) for x in solve ( N , K , A ) ] ) ) <NEWLINE>
import numpy as np <NEWLINE> from numba import jit <NEWLINE> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = np . array ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> @ jit <COMMENT> <NEWLINE> def imo ( a , n ) : <NEWLINE> <INDENT> imos = np . zeros ( n + 1 ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> imos [ max ( 0 , i - a [ i ] ) ] += 1 <NEWLINE> imos [ min ( n , i + a [ i ] ) + 1 ] -= 1 <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> immo = np . zeros ( n + 1 ) <NEWLINE> immo = np . cumsum ( imos ) <NEWLINE> <NL> return immo [ : n ] <NEWLINE> <NL> <NL> <DEDENT> for _ in range ( min [ K , 41 ] ) : <NEWLINE> <INDENT> A = imo ( A , N ) <NEWLINE> <NL> <DEDENT> print ( * A ) <NEWLINE>
import numpy as np <NEWLINE> import sys <NEWLINE> from numba import njit <NEWLINE> <NL> read = sys . stdin . buffer . read <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> readlines = sys . stdin . buffer . readlines <NEWLINE> <NL> @ njit ( <STRING> , cache = True ) <NEWLINE> def main ( prev , remain , q , v , w , vq , lq ) : <NEWLINE> <INDENT> dp = np . zeros ( ( 2 ** prev + 1 , 10 ** 5 + 1 ) , np . int32 ) <NEWLINE> for i in range ( 1 , 2 ** prev + 1 ) : <NEWLINE> <INDENT> vi = v [ i ] <NEWLINE> wi = w [ i ] <NEWLINE> dp [ i ] = dp [ i // 2 ] <NEWLINE> for j in range ( wi , 10 ** 5 + 1 ) : <NEWLINE> <INDENT> dp [ i ] [ j ] = max ( dp [ i ] [ j ] , dp [ i // 2 ] [ j - wi ] + vi ) <NEWLINE> <DEDENT> <DEDENT> for i in range ( q ) : <NEWLINE> <INDENT> V , L = vq [ i ] , lq [ i ] <NEWLINE> if V <= 2 ** prev : <NEWLINE> <INDENT> print ( dp [ V ] [ L ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = 0 <NEWLINE> for j in range ( 2 ** remain ) : <NEWLINE> <INDENT> cur = V <NEWLINE> curw = 0 <NEWLINE> curv = 0 <NEWLINE> while cur > 2 ** prev : <NEWLINE> <INDENT> if j & 1 : <NEWLINE> <INDENT> curv += v [ cur ] <NEWLINE> curw += w [ cur ] <NEWLINE> <DEDENT> cur //= 2 <NEWLINE> j >>= 1 <NEWLINE> <DEDENT> if curw <= L : <NEWLINE> <INDENT> ans = max ( ans , dp [ cur ] [ L - curw ] + curv ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> n = int ( readline ( ) ) <NEWLINE> stdin = np . array ( read ( ) . split ( ) , np . int32 ) <NEWLINE> v = np . zeros ( n + 1 , np . int32 ) <NEWLINE> w = np . zeros ( n + 1 , np . int32 ) <NEWLINE> v [ 1 : ] = stdin [ : 2 * n : 2 ] <NEWLINE> w [ 1 : ] = stdin [ 1 : 2 * n : 2 ] <NEWLINE> q = stdin [ 2 * n ] <NEWLINE> query = stdin [ 2 * n + 1 : ] <NEWLINE> vq = query [ : : 2 ] <NEWLINE> lq = query [ 1 : : 2 ] <NEWLINE> k = 0 <NEWLINE> num = 1 <NEWLINE> while num < n : <NEWLINE> <INDENT> k += 1 <NEWLINE> num *= 2 <NEWLINE> <DEDENT> prev = k // 2 <NEWLINE> remain = k - k // 2 <NEWLINE> main ( prev , remain , q , v , w , vq , lq ) <NEWLINE>
import sys <NEWLINE> import numpy as np <NEWLINE> <NL> read = sys . stdin . buffer . read <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> readlines = sys . stdin . buffer . readlines <NEWLINE> <NL> A = 256 <NEWLINE> <NL> def main ( N , V , W , v , L ) : <NEWLINE> <INDENT> def precompute ( N , V , W ) : <NEWLINE> <INDENT> U = 10 ** 5 + 10 <NEWLINE> dp = np . zeros ( ( A , U ) , np . int32 ) <NEWLINE> for v in range ( 1 , min ( A , N + 1 ) ) : <NEWLINE> <INDENT> p = v // 2 <NEWLINE> dp [ v ] = dp [ p ] <NEWLINE> dp [ v , W [ v ] : ] = np . maximum ( dp [ v , W [ v ] : ] , dp [ p , : - W [ v ] ] + V [ v ] ) <NEWLINE> for i in range ( 1 , U ) : <NEWLINE> <INDENT> dp [ v ] [ i ] = max ( dp [ v ] [ i ] , dp [ v ] [ i - 1 ] ) <NEWLINE> <DEDENT> <DEDENT> return dp <NEWLINE> <NL> <DEDENT> dp = precompute ( N , V , W ) <NEWLINE> values = np . empty ( A , np . int32 ) <NEWLINE> weights = np . empty ( A , np . int32 ) <NEWLINE> <NL> def solve ( i , lim , values , weights , dp ) : <NEWLINE> <INDENT> if i < A : <NEWLINE> <INDENT> return dp [ i ] [ lim ] <NEWLINE> <DEDENT> values [ 0 ] = 0 <NEWLINE> weights [ 0 ] = 0 <NEWLINE> p = 0 <NEWLINE> while i >= A : <NEWLINE> <INDENT> for j in range ( 1 << p ) : <NEWLINE> <INDENT> values [ j + ( 1 << p ) ] = values [ j ] + V [ i ] <NEWLINE> weights [ j + ( 1 << p ) ] = weights [ j ] + W [ i ] <NEWLINE> <DEDENT> p += 1 <NEWLINE> i >>= 1 <NEWLINE> <DEDENT> best = 0 <NEWLINE> for n in range ( 1 << p ) : <NEWLINE> <INDENT> if weights [ n ] > lim : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> x = dp [ i ] [ lim - weights [ n ] ] + values [ n ] <NEWLINE> best = max ( best , x ) <NEWLINE> <DEDENT> return best <NEWLINE> <NL> <DEDENT> Q = len ( v ) <NEWLINE> for i in range ( Q ) : <NEWLINE> <INDENT> x = solve ( v [ i ] , L [ i ] , values , weights , dp ) <NEWLINE> print ( x ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if sys . argv [ - 1 ] == <STRING> : <NEWLINE> <INDENT> from numba . pycc import CC <NEWLINE> cc = CC ( <STRING> ) <NEWLINE> cc . export ( <STRING> , <STRING> ) ( main ) <NEWLINE> cc . compile ( ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> from my_module import main <NEWLINE> <NL> N = int ( readline ( ) ) <NEWLINE> stdin = np . array ( read ( ) . split ( ) , np . int32 ) <NEWLINE> V = np . zeros ( N + 1 , np . int32 ) <NEWLINE> W = np . zeros ( N + 1 , np . int32 ) <NEWLINE> V [ 1 : ] = stdin [ : N + N : 2 ] <NEWLINE> W [ 1 : ] = stdin [ 1 : N + N : 2 ] <NEWLINE> query = stdin [ N + N + 1 : ] <NEWLINE> v , L = query [ : : 2 ] . copy ( ) , query [ 1 : : 2 ] . copy ( ) <NEWLINE> <NL> main ( N , V , W , v , L ) <NEWLINE>
import sys <NEWLINE> import numpy as np <NEWLINE> <NL> read = sys . stdin . buffer . read <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> readlines = sys . stdin . buffer . readlines <NEWLINE> <NL> <NL> def main ( N , V , W , v , L ) : <NEWLINE> <INDENT> def precompute ( N , V , W ) : <NEWLINE> <INDENT> U = 10 ** 5 + 10 <NEWLINE> dp = np . zeros ( ( 1024 , U ) , np . int32 ) <NEWLINE> for v in range ( 1 , min ( 1024 , N + 1 ) ) : <NEWLINE> <INDENT> p = v // 2 <NEWLINE> dp [ v ] = dp [ p ] <NEWLINE> dp [ v , W [ v ] : ] = np . maximum ( dp [ v , W [ v ] : ] , dp [ p , : - W [ v ] ] + V [ v ] ) <NEWLINE> for i in range ( 1 , U ) : <NEWLINE> <INDENT> dp [ v ] [ i ] = max ( dp [ v ] [ i ] , dp [ v ] [ i - 1 ] ) <NEWLINE> <DEDENT> <DEDENT> return dp <NEWLINE> <NL> <DEDENT> dp = precompute ( N , V , W ) <NEWLINE> values = np . empty ( 1024 , np . int32 ) <NEWLINE> weights = np . empty ( 1024 , np . int32 ) <NEWLINE> <NL> def solve ( i , lim , values , weights , dp ) : <NEWLINE> <INDENT> if i < 1024 : <NEWLINE> <INDENT> return dp [ i ] [ lim ] <NEWLINE> <DEDENT> values [ 0 ] = 0 <NEWLINE> weights [ 0 ] = 0 <NEWLINE> p = 0 <NEWLINE> while i >= 1024 : <NEWLINE> <INDENT> for j in range ( 1 << p ) : <NEWLINE> <INDENT> values [ j + ( 1 << p ) ] = values [ j ] + V [ i ] <NEWLINE> weights [ j + ( 1 << p ) ] = weights [ j ] + W [ i ] <NEWLINE> <DEDENT> p += 1 <NEWLINE> i >>= 1 <NEWLINE> <DEDENT> best = 0 <NEWLINE> for n in range ( 1 << p ) : <NEWLINE> <INDENT> if weights [ n ] > lim : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> x = dp [ i ] [ lim - weights [ n ] ] + values [ n ] <NEWLINE> best = max ( best , x ) <NEWLINE> <DEDENT> return best <NEWLINE> <NL> <DEDENT> Q = len ( v ) <NEWLINE> for i in range ( Q ) : <NEWLINE> <INDENT> x = solve ( v [ i ] , L [ i ] , values , weights , dp ) <NEWLINE> print ( x ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if sys . argv [ - 1 ] == <STRING> : <NEWLINE> <INDENT> from numba . pycc import CC <NEWLINE> cc = CC ( <STRING> ) <NEWLINE> cc . export ( <STRING> , <STRING> ) ( main ) <NEWLINE> cc . compile ( ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> from my_module import main <NEWLINE> <NL> N = int ( readline ( ) ) <NEWLINE> stdin = np . array ( read ( ) . split ( ) , np . int32 ) <NEWLINE> V = np . zeros ( N + 1 , np . int32 ) <NEWLINE> W = np . zeros ( N + 1 , np . int32 ) <NEWLINE> V [ 1 : ] = stdin [ : N + N : 2 ] <NEWLINE> W [ 1 : ] = stdin [ 1 : N + N : 2 ] <NEWLINE> query = stdin [ N + N + 1 : ] <NEWLINE> v , L = query [ : : 2 ] , query [ 1 : : 2 ] <NEWLINE> <NL> main ( N , V , W , v , L ) <NEWLINE>
import sys <NEWLINE> import numpy as np <NEWLINE> from numba import njit <NEWLINE> <NL> read = sys . stdin . buffer . read <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> readlines = sys . stdin . buffer . readlines <NEWLINE> <NL> A = 2 <NEWLINE> <NL> <COMMENT> <NL> @ njit ( <STRING> , cache = True ) <NEWLINE> def precompute ( N , V , W ) : <NEWLINE> <INDENT> U = 10 ** 5 + 10 <NEWLINE> dp = np . zeros ( ( A , U ) , np . int32 ) <NEWLINE> for v in range ( 1 , min ( A , N ) ) : <NEWLINE> <INDENT> p = v // 2 <NEWLINE> dp [ v ] = dp [ p ] <NEWLINE> dp [ v , W [ v ] : ] = np . maximum ( dp [ v , W [ v ] : ] , dp [ p , : - W [ v ] ] + V [ v ] ) <NEWLINE> for i in range ( 1 , U ) : <NEWLINE> <INDENT> dp [ v ] [ i ] = max ( dp [ v ] [ i ] , dp [ v ] [ i - 1 ] ) <NEWLINE> <DEDENT> <DEDENT> return dp <NEWLINE> <NL> <DEDENT> @ njit ( <STRING> , cache = True ) <NEWLINE> def main ( N , V , W , v , L ) : <NEWLINE> <INDENT> dp = precompute ( N , V , W ) <NEWLINE> values = np . empty ( 1024 , np . int32 ) <NEWLINE> weights = np . empty ( 1024 , np . int32 ) <NEWLINE> <NL> def solve ( i , lim , values , weights ) : <NEWLINE> <INDENT> if i < A : <NEWLINE> <INDENT> return dp [ i ] [ lim ] <NEWLINE> <DEDENT> values [ 0 ] = 0 <NEWLINE> weights [ 0 ] = 0 <NEWLINE> p = 0 <NEWLINE> while i >= A : <NEWLINE> <INDENT> for j in range ( 1 << p ) : <NEWLINE> <INDENT> values [ j + ( 1 << p ) ] = values [ j ] + V [ i ] <NEWLINE> weights [ j + ( 1 << p ) ] = weights [ j ] + W [ i ] <NEWLINE> <DEDENT> p += 1 <NEWLINE> i >>= 1 <NEWLINE> <DEDENT> best = 0 <NEWLINE> for n in range ( 1 << p ) : <NEWLINE> <INDENT> if weights [ n ] > lim : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> x = dp [ i ] [ lim - weights [ n ] ] + values [ n ] <NEWLINE> best = max ( best , x ) <NEWLINE> <DEDENT> return best <NEWLINE> <NL> <DEDENT> Q = len ( v ) <NEWLINE> for i in range ( Q ) : <NEWLINE> <INDENT> x = solve ( v [ i ] , L [ i ] , values , weights ) <NEWLINE> print ( x ) <NEWLINE> <NL> <DEDENT> <DEDENT> N = int ( readline ( ) ) <NEWLINE> stdin = np . array ( read ( ) . split ( ) , np . int32 ) <NEWLINE> V = np . zeros ( N + 1 , np . int32 ) <NEWLINE> W = np . zeros ( N + 1 , np . int32 ) <NEWLINE> V [ 1 : ] = stdin [ : N + N : 2 ] <NEWLINE> W [ 1 : ] = stdin [ 1 : N + N : 2 ] <NEWLINE> query = stdin [ N + N + 1 : ] <NEWLINE> v , L = query [ : : 2 ] , query [ 1 : : 2 ] <NEWLINE> <NL> main ( N , V , W , v , L ) <NEWLINE>
import sys <NEWLINE> import numpy as np <NEWLINE> from numba import njit <NEWLINE> <NL> input = sys . stdin . buffer . readline <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> vws = [ tuple ( map ( int , input ( ) . split ( ) ) ) for _ in range ( N ) ] <NEWLINE> <NL> n = min ( 2 ** 10 , N ) <NEWLINE> vws_arr = np . array ( vws , np . int32 ) <NEWLINE> <NL> dp = np . zeros ( ( n , 10 ** 5 + 1 ) , np . int32 ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> v , w = vws [ i ] <NEWLINE> dp [ i ] = dp [ ( i - 1 ) // 2 ] <NEWLINE> dp [ i , w : ] = np . maximum ( dp [ ( i - 1 ) // 2 , : - w ] + v , dp [ i , w : ] ) <NEWLINE> <NL> <NL> <DEDENT> @ njit ( <STRING> , cache = True ) <NEWLINE> def func ( vs , ws , L , dp_ ) : <NEWLINE> <INDENT> values = np . zeros ( 1 << len ( vs ) , np . int32 ) <NEWLINE> weights = np . zeros ( 1 << len ( vs ) , np . int32 ) <NEWLINE> for i in range ( len ( vs ) ) : <NEWLINE> <INDENT> for bits in range ( 1 << len ( vs ) ) : <NEWLINE> <INDENT> if bits & ( 1 << i ) : <NEWLINE> <INDENT> values [ bits ] += vs [ i ] <NEWLINE> weights [ bits ] += ws [ i ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> mask = ( weights <= L ) <NEWLINE> return np . amax ( dp_ [ L - weights [ mask ] ] + values [ mask ] ) <NEWLINE> <NL> <DEDENT> Q = int ( input ( ) ) <NEWLINE> for _ in range ( Q ) : <NEWLINE> <INDENT> V , L = map ( int , input ( ) . split ( ) ) <NEWLINE> V -= 1 <NEWLINE> if V < n : <NEWLINE> <INDENT> print ( dp [ V , L ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> Vs = [ ] <NEWLINE> while V >= n : <NEWLINE> <INDENT> Vs . append ( V ) <NEWLINE> V = ( V - 1 ) // 2 <NEWLINE> <DEDENT> vs = vws_arr [ Vs , 0 ] <NEWLINE> ws = vws_arr [ Vs , 1 ] <NEWLINE> print ( func ( vs , ws , L , dp [ V ] ) ) <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> import numpy as np <NEWLINE> <NL> read = sys . stdin . buffer . read <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> readlines = sys . stdin . buffer . readlines <NEWLINE> <NL> @ njit ( <STRING> , cache = True ) <NEWLINE> def main ( A , B , C ) : <NEWLINE> <INDENT> counts = np . zeros ( 1 << 18 , np . int32 ) <NEWLINE> popcount = np . zeros ( 1 << B , np . int32 ) <NEWLINE> for i in range ( B ) : <NEWLINE> <INDENT> popcount [ 1 << i : 1 << i + 1 ] = popcount [ : 1 << i ] + 1 <NEWLINE> <NL> <DEDENT> answer = 0 <NEWLINE> for i in range ( 1 << B ) : <NEWLINE> <INDENT> k = popcount [ i ] <NEWLINE> t = 0 <NEWLINE> for x in A & i : <NEWLINE> <INDENT> n = counts [ x ] <NEWLINE> counts [ x ] += 1 <NEWLINE> t -= C [ n ] <NEWLINE> t += C [ n + 1 ] <NEWLINE> <DEDENT> for x in A & i : <NEWLINE> <INDENT> counts [ x ] = 0 <NEWLINE> <DEDENT> if k & 1 : <NEWLINE> <INDENT> t = - t <NEWLINE> <DEDENT> answer += t <NEWLINE> <DEDENT> return answer <NEWLINE> <NL> <DEDENT> if sys . argv [ - 1 ] == <STRING> : <NEWLINE> <INDENT> from numba . pycc import CC <NEWLINE> cc = CC ( <STRING> ) <NEWLINE> cc . export ( <STRING> , <STRING> ) ( main ) <NEWLINE> cc . compile ( ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> from my_module import main <NEWLINE> <NL> N , K , S , T = map ( int , readline ( ) . split ( ) ) <NEWLINE> A = np . array ( readline ( ) . split ( ) , np . int32 ) <NEWLINE> <NL> def convert_problem ( S , T , A ) : <NEWLINE> <INDENT> ng = np . zeros ( len ( A ) , np . bool ) <NEWLINE> B = np . zeros_like ( A ) <NEWLINE> n = 0 <NEWLINE> for i in range ( 18 ) : <NEWLINE> <INDENT> s , t = ( S >> i ) & 1 , ( T >> i ) & 1 <NEWLINE> if ( s , t ) == ( 0 , 0 ) : <NEWLINE> <INDENT> ng |= ( ( A >> i ) & 1 ) == 1 <NEWLINE> <DEDENT> elif ( s , t ) == ( 1 , 1 ) : <NEWLINE> <INDENT> ng |= ( ( A >> i ) & 1 ) == 0 <NEWLINE> <DEDENT> elif ( s , t ) == ( 1 , 0 ) : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> B += ( ( A >> i ) & 1 ) << n <NEWLINE> n += 1 <NEWLINE> <DEDENT> <DEDENT> return B [ ~ ng ] , n <NEWLINE> <NL> <DEDENT> A , B = convert_problem ( S , T , A ) <NEWLINE> <NL> C = np . zeros ( ( 100 , 100 ) , np . int64 ) <NEWLINE> C [ 0 , 0 ] = 1 <NEWLINE> for n in range ( 1 , 100 ) : <NEWLINE> <INDENT> C [ n , : - 1 ] += C [ n - 1 , : - 1 ] <NEWLINE> C [ n , 1 : ] += C [ n - 1 , : - 1 ] <NEWLINE> <DEDENT> C = C [ : , 1 : K + 1 ] . sum ( axis = 1 ) <NEWLINE> <NL> print ( main ( A , B , C ) ) <NEWLINE>
t = int ( input ( ) ) <NEWLINE> for _ in range ( t ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> s = input ( ) <NEWLINE> b = [ ] <NEWLINE> for i in range ( n ) [ : : - 1 ] : <NEWLINE> <INDENT> for e in b : <NEWLINE> <INDENT> a [ i ] = min ( a [ i ] , a [ i ] ^ e ) <NEWLINE> <DEDENT> if a [ i ] : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> b += a [ i ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> <DEDENT>
I = input <NEWLINE> n = int <NEWLINE> for i in range ( n ( input ( ) ) ) : <NEWLINE> <INDENT> I ( ) ; t = [ ] ; x = 0 <NEWLINE> for i , j in zip ( map ( n , I ( ) . split ( ) [ : : - 1 ] ) , I ( ) [ : : - 1 ] ) : <NEWLINE> <INDENT> [ i ^= k * ( i ^ k < i ) for k in t ] ; j = n ( j ) ; t += [ i * ( j ^ 1 ) ] ; x |= ( i > 0 ) & j <NEWLINE> <DEDENT> print ( x ) <NEWLINE> <DEDENT>
3 <NEWLINE> 2 <NEWLINE> 1 2 <NEWLINE> 10 <NEWLINE> 2 <NEWLINE> 1 1 <NEWLINE> 10 <NEWLINE> 6 <NEWLINE> 2 3 4 5 6 7 <NEWLINE> 111000 <NEWLINE>
import sys <NEWLINE> import numpy as np <NEWLINE> from numba import njit <NEWLINE> <NL> read = sys . stdin . buffer . read <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> readlines = sys . stdin . buffer . readlines <NEWLINE> <NL> @ njit ( <STRING> , cache = True ) <NEWLINE> def f ( S , T ) : <NEWLINE> <INDENT> m , x , M = 0 , 0 , 0 <NEWLINE> for i in range ( len ( S ) ) : <NEWLINE> <INDENT> if S [ i ] == - 1 : <NEWLINE> <INDENT> x -= 1 <NEWLINE> <DEDENT> elif S [ i ] == 1 : <NEWLINE> <INDENT> x += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if x - 1 + T [ i ] >= m : <NEWLINE> <INDENT> x -= 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x += 1 <NEWLINE> <DEDENT> <DEDENT> m = min ( m , x ) <NEWLINE> M = max ( M , x ) <NEWLINE> <DEDENT> return M - m <NEWLINE> <NL> <DEDENT> S = np . array ( list ( read ( ) . rstrip ( ) . decode ( ) ) , <STRING> ) <NEWLINE> <NL> Si = np . zeros ( len ( S ) , np . int32 ) <NEWLINE> Si [ S == <STRING> ] = - 1 <NEWLINE> Si [ S == <STRING> ] = 1 <NEWLINE> S = Si <NEWLINE> <NL> T = S . copy ( ) <NEWLINE> T [ S == 0 ] = 1 <NEWLINE> T = np . cumsum ( T ) <NEWLINE> T = np . minimum . accumulate ( T [ : : - 1 ] ) [ : : - 1 ] - T <NEWLINE> print ( f ( S , T ) ) <NEWLINE>
from numba import njit <NEWLINE> s = input ( ) <NEWLINE> <NL> @ njit <NEWLINE> def test ( c ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <INDENT> a , b = 0 , c <NEWLINE> ok = True <NEWLINE> discrete = False <COMMENT> <NEWLINE> for si in s : <NEWLINE> <INDENT> if si == <STRING> : <NEWLINE> <INDENT> if a == b == c : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> a += 1 <NEWLINE> b += 1 <NEWLINE> if b > c : <NEWLINE> <INDENT> b = c - 1 if discrete else c <NEWLINE> <DEDENT> <DEDENT> elif si == <STRING> : <NEWLINE> <INDENT> if a == b == 0 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> a -= 1 <NEWLINE> b -= 1 <NEWLINE> if a < 0 : <NEWLINE> <INDENT> a = 1 if discrete else 0 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if a == b == 0 : <NEWLINE> <INDENT> a = b = 1 <NEWLINE> <DEDENT> elif a == b == c : <NEWLINE> <INDENT> a = b = c - 1 <NEWLINE> <DEDENT> elif a == b : <NEWLINE> <INDENT> discrete = True <NEWLINE> a -= 1 <NEWLINE> b += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a -= 1 <NEWLINE> b += 1 <NEWLINE> if a < 0 : <NEWLINE> <INDENT> a = 1 if discrete else 0 <NEWLINE> <DEDENT> if b > c : <NEWLINE> <INDENT> b = c - 1 if discrete else c <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> return True <NEWLINE> <NL> <NL> <DEDENT> l , r = 0 , len ( s ) <NEWLINE> while r - l > 1 : <NEWLINE> <INDENT> c = ( l + r ) // 2 <NEWLINE> if test ( c ) : <NEWLINE> <INDENT> r = c <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> l = c <NEWLINE> <DEDENT> <DEDENT> print ( r ) <NEWLINE>
a = int ( input ( ) ) <NEWLINE> b = int ( input ( ) ) <NEWLINE> print ( a * b ) <NEWLINE>
a = int ( input ( ) ) <NEWLINE> b = int ( input ( ) ) <NEWLINE> print ( a * b ) <NEWLINE>
a , b = input ( ) . split ( ) <NEWLINE> print ( a * b ) <NEWLINE>
a = int ( input ( ) ) <NEWLINE> b = int ( input ( ) ) <NEWLINE> <NL> print ( a * b ) <NEWLINE>
a , b = input ( ) . split ( ) <NEWLINE> print ( a * b ) <NEWLINE>
a , b = map ( int , input ( ) . split ) <NEWLINE> print ( a * b ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> purint ( N * M ) <NEWLINE>
a = lsit ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> print ( a [ 0 ] * a [ 1 ] ) <NEWLINE>
A , B = input ( ) . split ; <NEWLINE> A - int ( A ) ; <NEWLINE> B = int ( B ) ; <NEWLINE> print ( A * B ) ; <NEWLINE>
a , b = input ( ) . split ( ) <NEWLINE> print ( a * b ) <NEWLINE>
a , b = int ( input ( ) ) <NEWLINE> print ( a * b ) <NEWLINE>
a , b = map ( input . split ( ) ) <NEWLINE> print ( a * b ) <NEWLINE>
A B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> print ( A * B ) <NEWLINE>
a , b = int ( input ( ) . split ( ) ) <NEWLINE> print ( a * b ) <NEWLINE>
a , b = map ( int , input ( ) , split ( ) ) <NEWLINE> print ( a * b ) <NEWLINE>
a , b = map ( int , input . split ( ) ) <NEWLINE> print ( a * b ) <NEWLINE>
def product ( a , b ) : <NEWLINE> <INDENT> return a * b <NEWLINE> <NL> <DEDENT> a = int ( input ( ) ) <NEWLINE> b = int ( input ( ) ) <NEWLINE> print ( product ( a , b ) ) <NEWLINE>
a , b = map ( int , input ( ) . supkit ( ) ) <NEWLINE> print ( a * b ) <NEWLINE>
def solve ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 1 <NEWLINE> <NL> for i in a : <NEWLINE> <INDENT> ans *= i <NEWLINE> if ans > int ( 1e18 ) : return - 1 <NEWLINE> <NL> <NL> <DEDENT> return ans <NEWLINE> <NL> <NL> <DEDENT> print ( solve ( ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> for i in a : <NEWLINE> <INDENT> ans = ans * i <NEWLINE> if ans == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
A = int ( input ( ) ) <NEWLINE> B = int ( input ( ) ) <NEWLINE> print ( A * B ) <NEWLINE>
A = int ( input ( ) ) <NEWLINE> B = int ( input ( ) ) <NEWLINE> <NL> print ( A * B ) <NEWLINE>
A = int ( input ( ) ) <NEWLINE> B = int ( input ( ) ) <NEWLINE> print ( A * B ) <NEWLINE>
a = input ( ) <NEWLINE> b = input ( ) <NEWLINE> <NL> print ( a * b ) <NEWLINE>
a , b = int ( input ( ) ) , int ( input ( ) ) <NEWLINE> print ( a * b ) <NEWLINE>
A , B = map ( int , input . split ( ) ) <NEWLINE> print ( A * B ) <NEWLINE>
A , B = input ( ) <NEWLINE> C = A * B <NEWLINE> print ( C ) ; <NEWLINE>
a , b = map ( int , input ( ) ) <NEWLINE> print ( a * b ) <NEWLINE>
num1 = input ( ) <NEWLINE> num1 = int ( num1 ) <NEWLINE> num2 = input ( ) <NEWLINE> num2 = int ( num2 ) <NEWLINE> print ( num1 * num2 ) <NEWLINE>
A = input ( ) <NEWLINE> B = input ( ) <NEWLINE> <NL> print ( A * B ) <NEWLINE>
int A = input ( ) <NEWLINE> int B = input ( ) <NEWLINE> <NL> print ( A * B ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = 1 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> B = B * A [ i ] <NEWLINE> if B > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( B ) <NEWLINE>
print ( a ) <NEWLINE> print ( b ) <NEWLINE> <NL> answer = a * b <NEWLINE> <NL> print ( answer ) <NEWLINE>
A , B = map ( int , input ( ) ) <NEWLINE> A = A * B <NEWLINE> print ( int ( A ) ) <NEWLINE>
A , B = input . split ( ) <NEWLINE> A = int ( A ) <NEWLINE> B = int ( B * 100 ) <NEWLINE> print ( int ( A * B / 100 ) ) <NEWLINE>
print ( int ( input ( ) ) * int ( input ( ) ) ) <NEWLINE>
a , b = input ( ) . split ( ) <NEWLINE> print ( int ( a * b ) ) <NEWLINE>
A = int ( input ( ) ) <NEWLINE> B = int ( input ( ) ) <NEWLINE> print ( A * B ) <NEWLINE>
<INDENT> a , b = ( int ( x ) for x in input ( ) . split ( ) ) <NEWLINE> <NL> print ( a * b ) <NEWLINE> <NL> <NL> <NL> <DEDENT>
A , B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> print ( A * B <NEWLINE>
print ( int ( input ( ) ) * int ( input ( ) ) ) <NEWLINE>
A , B = list ( map ( int , inpuut ( ) . split ( ) ) ) <NEWLINE> print ( A * B ) <NEWLINE>
a , b = input ( ) . split ( ) <NEWLINE> print ( a * b ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> <INDENT> ... : print ( a * b ) <NEWLINE> <DEDENT>
a , b = int ( input ( ) . split ( ) ) <NEWLINE> print ( a * b ) <NEWLINE>
a , b = int ( input ( ) . split ( ) ) <NEWLINE> print ( str ( a * b ) ) <NEWLINE>
a = int ( input ( ) ) <NEWLINE> b = int ( input ( ) ) <NEWLINE> print ( a * b ) <NEWLINE>
import numpy <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> val = numpy . prod ( A ) <NEWLINE> <NL> if val > 10 ** 18 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( val ) <NEWLINE> <DEDENT>
a = int ( input ( ) ) <NEWLINE> b = int ( input ( ) ) <NEWLINE> c = a * b <NEWLINE> print ( c ) <NEWLINE>
print ( int ( input ( ) ) * int ( input ( ) ) ) <NEWLINE>
A , B = map ( input , input . split ( ) ) <NEWLINE> return A * B <NEWLINE>
a = input ( ) <NEWLINE> b = input ( ) <NEWLINE> <NL> print ( int ( a ) * int ( b ) ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> pirnt ( n * m ) <NEWLINE>
x = int ( input ( ) ) <NEWLINE> <NL> for i in range ( x , 0 , - 1 ) : <NEWLINE> <INDENT> j = int ( i ** 0.5 ) <NEWLINE> if i == j ** 2 : <NEWLINE> <INDENT> print ( i ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT>
a = int ( input ( ) ) <NEWLINE> b = int ( input ( ) ) <NEWLINE> print ( a * b ) <NEWLINE>
from sys import stdin <NEWLINE> from copy import deepcopy <NEWLINE> <NL> def S ( ) : return stdin . readline ( ) . rstrip ( ) <NEWLINE> def I ( ) : return int ( stdin . readline ( ) . rstrip ( ) ) <NEWLINE> def LS ( ) : return list ( stdin . readline ( ) . rstrip ( ) . split ( ) ) <NEWLINE> def LI ( ) : return list ( map ( int , stdin . readline ( ) . rstrip ( ) . split ( ) ) ) <NEWLINE> def R ( x ) : <NEWLINE> <INDENT> r = round ( x ) <NEWLINE> if r + 0.5 <= x : <NEWLINE> <INDENT> r += 1 <NEWLINE> <DEDENT> return r <NEWLINE> <NL> <DEDENT> a , b = I ( ) , I ( ) <NEWLINE> <NL> print ( a * b ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> As = map ( int , input ( ) . split ( ) ) <NEWLINE> result = 1 <NEWLINE> <NL> for a in As : <NEWLINE> <INDENT> result = result * a <NEWLINE> <NL> <DEDENT> if a >= 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( result ) <NEWLINE> <DEDENT>
a = int ( input ( ) ) <NEWLINE> b = int ( input ( ) ) <NEWLINE> print ( a * b ) <NEWLINE>
a = input ( ) <NEWLINE> b = input ( ) <NEWLINE> print ( int ( a * b ) ) <NEWLINE>
a , b = int ( input ( ) . split ( ) ) <NEWLINE> <NL> print ( a * b ) <NEWLINE>
a = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( a [ 0 ] * a [ 1 ] ) <NEWLINE>
a , b = int ( input ( ) ) . split ( ) <NEWLINE> <NL> print ( a * b ) <NEWLINE>
a , b = int ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> print ( a * b ) <NEWLINE>
A = int ( input ( ) ) <NEWLINE> B = int ( input ( ) ) <NEWLINE> print ( A * B ) <NEWLINE>
a = int ( input ( ) ) <NEWLINE> b = int ( input ( ) ) <NEWLINE> print ( a * b ) <NEWLINE>
a = int ( input ( ) ) <NEWLINE> b = int ( input ( ) ) <NEWLINE> <NL> print ( a * b ) <NEWLINE>
A , B = int ( input ( ) ) , int ( input ( ) ) <NEWLINE> print ( A * B ) <NEWLINE>
A , B = map ( int , input ( ) split ( ) ) <NEWLINE> <NL> print ( A * B ) <NEWLINE>
a , b = map ( int , input . split ( ) ) <NEWLINE> print ( a * b ) <NEWLINE>
input ( ) <NEWLINE> int_list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> max_num = 10 ** 18 <NEWLINE> ans = 1 <NEWLINE> <NL> if 0 in int_list : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> for i in int_list : <NEWLINE> <INDENT> ans *= i <NEWLINE> if ans > max_num : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
n , m = int ( input ( ) . split ( ) ) <NEWLINE> print ( n * m ) <NEWLINE>
a , b = map ( int ( input ( ) . split ( ) ) <NEWLINE> print ( a * b ) <NEWLINE> <NL>
print ( int ( input ( ) ) * int ( input ( ) ) ) <NEWLINE>
def resolve ( ) : <NEWLINE> <INDENT> N , M = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> print ( A * B ) <NEWLINE> <NL> <NL> <DEDENT> resolve ( ) <NEWLINE>
a = input ( ) <NEWLINE> <NL> a = a . split ( ) <NEWLINE> <NL> x = a [ 0 ] <NEWLINE> y = a [ 1 ] <NEWLINE> <NL> c = x * y <NEWLINE> <NL> print ( c ) <NEWLINE>
a = input ( ) <NEWLINE> b = input ( ) <NEWLINE> <NL> A = int ( a ) <NEWLINE> B = int ( b ) <NEWLINE> <NL> val = A * B <NEWLINE> <NL> print ( val ) <NEWLINE>
a , b = int ( input ( ) . split ( ) ) <NEWLINE> <NL> print ( a * b ) <NEWLINE>
a , b = int ( input ( ) ) <NEWLINE> print ( a * b ) <NEWLINE>
A = int ( input ( ) ) <NEWLINE> B = int ( input ( ) ) <NEWLINE> <NL> print ( A * B ) <NEWLINE>
A , B = input ( ) . split ( ) <NEWLINE> print ( A * B ) <NEWLINE>
a = int ( input ( ) ) <NEWLINE> b = int ( input ( ) ) <NEWLINE> <NL> print ( a * b ) <NEWLINE>
a , b = int ( input ( ) . split ( ) ) <NEWLINE> print ( a * b ) <NEWLINE>
x = int ( input ( ) ) <NEWLINE> y = int ( input ( ) ) <NEWLINE> print ( x * y ) <NEWLINE>
s = input ( ) . split ( ) <NEWLINE> s [ 0 ] * s [ 1 ] <NEWLINE>
a , b = input ( ) . split ( ) <NEWLINE> A = int ( a ) <NEWLINE> B - int ( b ) <NEWLINE> print ( A * B ) <NEWLINE>
a , b = int ( input ( ) . split ( ) ) <NEWLINE> print ( a * b ) <NEWLINE>
a = int ( input ( ) ) <NEWLINE> b = int ( input ( ) ) <NEWLINE> print ( a * b ) <NEWLINE>
a , b = map ( int ( intput ( ) . split ( ) ) ) <NEWLINE> print ( a * b ) <NEWLINE>
a . b = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( a * b ) <NEWLINE>
a = int ( input ( ) ) <NEWLINE> b = int ( input ( ) ) <NEWLINE> <NL> print ( a * b ) <NEWLINE>
print ( int ( input ( ) ) * int ( input ( ) ) ) <NEWLINE>
A , B = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> print ( A * B ) <NEWLINE>
x = int ( input ( ) ) <NEWLINE> y = int ( input ( ) ) <NEWLINE> <NL> print ( x * y ) <NEWLINE>
A * B <NEWLINE>
a , b : int = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> print ( a * b ) <NEWLINE>
a , b = map ( input ( ) . split ( ) ) <NEWLINE> print ( int ( a ) * int ( b ) ) <NEWLINE>
A = input ( ) <NEWLINE> B = input ( ) <NEWLINE> <NL> print ( A * B ) <NEWLINE>
try : <NEWLINE> <INDENT> x = int ( input ( <STRING> ) ) <NEWLINE> y = int ( input ( <STRING> ) ) <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> if x <= 100 and y <= 100 : <NEWLINE> <INDENT> if x >= 0 and y >= 0 : <NEWLINE> <INDENT> print ( x * y ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a = int ( input ( ) ) <NEWLINE> b = int ( input ( ) ) <NEWLINE> print ( a * b ) <NEWLINE>
n1 = input ( ) <NEWLINE> n2 = input ( ) <NEWLINE> <NL> print ( n1 * n2 ) <NEWLINE>
a , b = map ( int , input ( ) split ( ) ) <NEWLINE> c = a * b <NEWLINE> print ( c ) <NEWLINE>
a , b = list ( map , input ( ) . split ( ) ) <NEWLINE> print ( a * b ) <NEWLINE>
a , b = int ( x ) for x in input ( ) . split ( ) <NEWLINE> print ( a * b ) <NEWLINE>
a , b = int ( input ( ) . split ( ) ) <NEWLINE> <NL> print ( a * b ) <NEWLINE>
a , b = int ( map ( input ( ) . split ( ) ) ) <NEWLINE> print ( a * b ) <NEWLINE>
A , B = input ( ) . strip ( ) . split ( ) <NEWLINE> if A >= 1 and A <= 100 and B >= 1 and B <= 100 : <NEWLINE> <INDENT> A * B <NEWLINE> <DEDENT>
<NL> n = input ( ) <NEWLINE> nums = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 1 <NEWLINE> over = 10 ** 18 <NEWLINE> <NL> for num in nums : <NEWLINE> <INDENT> ans = ans * num <NEWLINE> if ans > over : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
A , B = map ( int , input . split ( ) ) <NEWLINE> print ( A * B ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) <NEWLINE> <NL> ans = a * b <NEWLINE> <NL> print ( ans ) <NEWLINE>
s = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( s [ 0 ] * s [ 1 ] ) <NEWLINE>
def main <NEWLINE> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> print ( a * b ) <NEWLINE> return <NEWLINE> <NL> main ( ) <NEWLINE>
a = input ( ) <NEWLINE> b = input ( ) <NEWLINE> print ( a * b ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> cal = 1 <NEWLINE> i = 0 <NEWLINE> while i < len ( A ) : <NEWLINE> <INDENT> cal *= A [ i ] <NEWLINE> i += 1 <NEWLINE> <DEDENT> if cal >= 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( cal ) <NEWLINE> <DEDENT>
a , b = input ( ) <NEWLINE> print ( a * b ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> def f ( ) : <NEWLINE> <INDENT> if 0 in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> b = 1 <NEWLINE> for i in range ( 0 , n ) : <NEWLINE> <INDENT> b *= a [ i ] <NEWLINE> <NL> if b > 10 ** 8 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( b ) <NEWLINE> <NL> <DEDENT> <DEDENT> f ( ) <NEWLINE>
s = int ( input ( ) ) <NEWLINE> n , m = int ( s [ 0 ] ) , int ( s [ 1 ] ) <NEWLINE> print ( n * m ) <NEWLINE>
a , b = int ( input ( ) ) <NEWLINE> print ( a * b ) <NEWLINE>
a , b = [ int ( input ( ) ) for i in range ( 2 ) ] <NEWLINE> <NL> print ( a * b ) <NEWLINE>
A , B = map ( int , input ( ) ) <NEWLINE> print ( A * B ) <NEWLINE>
a , b = int ( input ( ) . split ( ) ) <NEWLINE> print ( a * b ) <NEWLINE>
a = int ( input ( ) ) <NEWLINE> b = int ( input ( ) ) <NEWLINE> print ( a * b ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( a * b9 ) <NEWLINE>
a , b , c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( a * b ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> return <NEWLINE> <DEDENT> prod = 1 <NEWLINE> for a in A : <NEWLINE> <INDENT> prod *= a <NEWLINE> if prod > 1000000000000000000 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> return <NEWLINE> <DEDENT> <DEDENT> print ( prod ) <NEWLINE> <DEDENT> main ( ) <NEWLINE>
a , b = map ( int , input ( ) ) <NEWLINE> <NL> print ( a * b ) <NEWLINE>
from subprocess import run <NEWLINE> from os import path <NEWLINE> <NL> if not path . exists ( <STRING> ) : <NEWLINE> <INDENT> with open ( <STRING> , mode = <STRING> ) as f : <NEWLINE> <INDENT> f . write ( <STRING> ) <NEWLINE> <NL> <DEDENT> run ( <STRING> ) <NEWLINE> <NL> <DEDENT> run ( <STRING> ) <NEWLINE>
a = int ( input ( ) ) <NEWLINE> b = int ( input ( ) ) <NEWLINE> <NL> print ( a * b ) <NEWLINE>
a , b = int ( input ( ) . split ( ) ) <NEWLINE> print ( a * b ) <NEWLINE>
print ( a * b ) <NEWLINE>
S1 , S2 = input ( ) . strip ( ) . split ( ) <NEWLINE> print ( S1 * S2 ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if 1 <= a <= 100 and 1 <= b <= 100 : <NEWLINE> <INDENT> return a * b <NEWLINE> <DEDENT>
print ( A * B ) <NEWLINE>
A . B = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( A * B ) <NEWLINE>
A , B = int ( input ( ) ) <NEWLINE> <NL> print ( A * B ) <NEWLINE>
A , B = int ( input ( ) ) <NEWLINE> print ( A * B ) <NEWLINE>
a = int ( input ( ) ) <NEWLINE> b = int ( input ( ) ) <NEWLINE> print ( a * b ) <NEWLINE>
n = input ( ) <NEWLINE> answer = 1 <NEWLINE> for i in range ( int ( n ) ) : <NEWLINE> <INDENT> a = int ( input ( ) ) <NEWLINE> answer = answer * a <NEWLINE> if answer > 10 ** 18 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( answer ) <NEWLINE>
Line = [ int ( s ) for s in input ( ) . split ( ) ] <NEWLINE> <NL> print ( Liine [ 0 ] * Line [ 1 ] ) <NEWLINE>
str_n = input ( ) <NEWLINE> str_an = input ( ) <NEWLINE> <NL> n = int ( str_n ) <NEWLINE> an = [ int ( ai ) for ai in str_an . split ( ) ] <NEWLINE> <NL> ans = 1 <NEWLINE> for ai in an : <NEWLINE> <INDENT> ans *= ai <NEWLINE> <NL> <DEDENT> if ans > 1e8 : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
print ( int ( input ( ) ) * int ( input ( ) ) ) <NEWLINE>
A , B = int ( input ( ) ) <NEWLINE> print ( A * B ) <NEWLINE>
A , B = map ( int ( ) , input ( ) . split ( ) ) <NEWLINE> print ( A * B ) <NEWLINE>
a , b = map ( int , input ( ) ) <NEWLINE> print ( a * b ) <NEWLINE>
a , b = input ( ) . split ( ) <NEWLINE> print ( a * b ) <NEWLINE>
import sys <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 1 <NEWLINE> <NL> if A . count ( 0 ) != 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> for i in A : <NEWLINE> <NL> <INDENT> ans = ans * i <NEWLINE> if ans > int ( 10 ** 18 ) : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> if ans > int ( 10 ** 18 ) : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
a , b = = map ( int , input ( ) . split ( ) ) <NEWLINE>
import math <NEWLINE> <NL> R = int ( input ( ) ) <NEWLINE> print ( 2 * R * math . pi ) <NEWLINE> <NL>
A = int ( input ( ) ) <NEWLINE> B = int ( input ( ) ) <NEWLINE> <NL> print ( A * B ) <NEWLINE>
A , B = input ( ) . split ( ) <NEWLINE> <NL> print ( A * B ) <NEWLINE>
a , b = list ( map ( int , input ( ) ) ) <NEWLINE> <NL> print ( a * b ) <NEWLINE>
a , b = map ( int , input . split ( ) ) <NEWLINE> print ( a * b ) <NEWLINE>
num = int ( input ( ) ) <NEWLINE> numbers = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> sum = 1 <NEWLINE> for i in range ( num ) : <NEWLINE> <INDENT> sum *= numbers [ i ] <NEWLINE> if ( sum > ( 10 ** 18 ) ) : <NEWLINE> <INDENT> sum = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if 0 in numbers : <NEWLINE> <INDENT> sum = 0 <NEWLINE> <DEDENT> print ( sum ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> a , b = map ( int , input ( ) , split ( ) ) <NEWLINE> <COMMENT> <NL> <NL> <COMMENT> <NL> answer = a * b <NEWLINE> <NL> <COMMENT> <NL> print ( answer ) <NEWLINE>
a , b = map ( int , input ( ) ) <NEWLINE> print ( a * b ) <NEWLINE>
A = int ( input ( ) ) <NEWLINE> B = int ( input ( ) ) <NEWLINE> <NL> print ( A * B ) <NEWLINE>
A = input ( ) <NEWLINE> B = input ( ) <NEWLINE> a = int ( A ) <NEWLINE> b = int ( B ) <NEWLINE> x = a * b <NEWLINE> print ( x ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> T = 1 <NEWLINE> for i in A : <NEWLINE> <INDENT> T = T * i <NEWLINE> if T > 10 ^ 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( T ) <NEWLINE> <DEDENT> <DEDENT>
a , b = map ( input ( ) . split ( ) ) <NEWLINE> print ( a * b ) <NEWLINE>
A , B = map ( int , input ( ) . split ) <NEWLINE> ans = A * B <NEWLINE> print ( ans ) <NEWLINE>
kari <NEWLINE>
nums = input ( ) . split ( ) <NEWLINE> print ( int ( num [ 0 ] ) * int ( num [ 1 ] ) ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) ) <NEWLINE> print ( a * b ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> arg = int ( input ( ) ) <NEWLINE> ans = arg + arg ** 2 + arg ** 3 <NEWLINE> print ( str ( ans ) ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
A = int ( input ( ) ) <NEWLINE> B = int ( input ( ) ) <NEWLINE> print ( A * B ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> a , b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <INDENT> print ( a * b ) <NEWLINE> <DEDENT> <DEDENT> main ( ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> A = int ( input ( ) ) <NEWLINE> B = int ( input ( ) ) <NEWLINE> <COMMENT> <NL> print ( A * B ) <NEWLINE>
import sys <NEWLINE> <NL> def main ( lines ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <INDENT> for i , v in enumerate ( lines ) : <NEWLINE> <INDENT> print ( <STRING> . format ( i , v ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> lines = [ ] <NEWLINE> for l in sys . stdin : <NEWLINE> <INDENT> lines . append ( [ int ( s ) for s in l . rstrip ( <STRING> ) . split ( ) ] ) <NEWLINE> <DEDENT> <DEDENT> A = lines [ 0 ] <NEWLINE> B = lines [ 1 ] <NEWLINE> print ( A * B ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( N * k ) <NEWLINE>
a = input ( ) <NEWLINE> b = input ( ) <NEWLINE> print ( int ( a ) * int ( b ) ) <NEWLINE>
a , b = map ( int ( input ( ) . split ( ) ) <NEWLINE> print ( a * b ) <NEWLINE>
a , b = int ( input . split ( ) ) <NEWLINE> print ( a * b ) <NEWLINE>
a , b = int ( input ( ) . split ( ) ) <NEWLINE> print ( str ( a * b ) ) <NEWLINE>
A , B = int ( input ( ) . split ( ) ) <NEWLINE> print ( AxB ) <NEWLINE>
a , b = [ int ( input ( ) ) for _ in range ( 2 ) ] <NEWLINE> print ( a * b ) <NEWLINE>
import math <NEWLINE> from collections import deque <NEWLINE> from collections import defaultdict <NEWLINE> import itertools as it <NEWLINE> <NL> <COMMENT> <NL> def readInt ( ) : <NEWLINE>
2 * 5 = 10 <NEWLINE> 100 * 100 = 10000 <NEWLINE>
a = int ( input ( ) ) <NEWLINE> b = int ( input ( ) ) <NEWLINE> print ( a * b ) <NEWLINE>
N , S = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> m = 0 <NEWLINE> var1 = [ 0 ] * ( S + 1 ) <NEWLINE> var1 [ 0 ] = pow ( 2 , N , 998244353 ) <NEWLINE> var2 = pow ( 2 , 998244353 - 2 , 998244353 ) <NEWLINE> def func1 ( xxx , xx ) : <NEWLINE> <INDENT> if xxx > xx : <NEWLINE> <INDENT> return xx <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return xxx <NEWLINE> <DEDENT> <DEDENT> for all in A : <NEWLINE> <INDENT> m = all + m <NEWLINE> funcvar1 = min ( S , m ) <NEWLINE> for val in reversed ( range ( all , funcvar1 + 1 ) ) : <NEWLINE> <INDENT> var1 [ val ] = ( var1 [ val ] + var1 [ val - all ] * var2 ) % 998244353 <NEWLINE> <DEDENT> <DEDENT> print ( var1 [ S ] ) <NEWLINE>
A = int ( input ( ) ) <NEWLINE> B = int ( input ( ) ) <NEWLINE> <NL> print ( A * B ) <NEWLINE>
a = int ( input ( ) ) <NEWLINE> b = int ( input ( ) ) <NEWLINE> print ( a * b <NEWLINE>
a = int ( input ( ) ) <NEWLINE> b = int ( input ( ) ) <NEWLINE> print ( a * b ) <NEWLINE>
print ( int ( input ( ) ) * int ( input ( ) ) ) <NEWLINE>
a = int ( input ( ) ) <NEWLINE> b = int ( input ( ) ) <NEWLINE> c = a * b <NEWLINE> print ( c ) <NEWLINE>
A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( a * b ) <NEWLINE>
a , b = map ( int , input ( ) ) <NEWLINE> print ( a * b ) <NEWLINE>
a , b = int ( input ( ) . split ( ) ) <NEWLINE> print ( a * b ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> print ( a * B ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> nums = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if 0 in nums : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> quit ( ) <NEWLINE> <DEDENT> mul = 1 <NEWLINE> for i in nums : <NEWLINE> <INDENT> mul *= i <NEWLINE> if mul > 1000000000000000000 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> quit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( mul ) <NEWLINE>
A , B = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> print ( A * B ) <NEWLINE>
a <NEWLINE>
def main ( ) <NEWLINE> A = input ( ) <NEWLINE> B = input ( ) <NEWLINE> x = int ( A ) <NEWLINE> y = int ( B ) <NEWLINE> print ( x * y ) <NEWLINE>
a , b = input ( ) . split ( ) <NEWLINE> print ( a * b ) <NEWLINE>
print ( int ( input ( ) ) * int ( input ( ) ) ) <NEWLINE>
a , b = ( int ( x ) for x in input . split ( ) ) <NEWLINE> print ( a * b ) <NEWLINE>
A = input ( ) B = input ( ) <NEWLINE> C = A * B <NEWLINE> print ( C ) <NEWLINE>
list_a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> result = 1 <NEWLINE> for a in range ( list_a ) : <NEWLINE> <INDENT> result = result * a <NEWLINE> <NL> <DEDENT> if result > 10 ** 18 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( result ) <NEWLINE> <DEDENT>
a = input . split ( <STRING> ) <NEWLINE> a [ 0 ] = int ( a [ 0 ] ) <NEWLINE> a [ 1 ] = int ( a [ 1 ] ) <NEWLINE> print ( a [ 0 ] * a [ 1 ] ) <NEWLINE>
a , b = map ( int , input ( ) , split ( ) ) <NEWLINE> print ( a * b ) <NEWLINE>
a , b = map ( int , input ( ) ) <NEWLINE> print ( a * b ) <NEWLINE>
print ( int ( input ( ) ) * int ( input ( ) ) ) <NEWLINE>
print ( input ( ) * input ( ) ) <NEWLINE>
import sys <NEWLINE> A , B = map ( int , input ( ) ) <NEWLINE> if not ( 1 <= A <= 100 and 1 <= B <= 100 ) : sys . exit ( ) <NEWLINE> <NL> print ( A * B ) <NEWLINE>
a , b = gets . split . map ( & : to_i ) <NEWLINE> print ( a * b ) <NEWLINE>
A , B = int ( input ( ) . split ( ) ) <NEWLINE> print ( A * B ) <NEWLINE>
print ( A * B ) <NEWLINE>
a , b = int ( input ( ) . split ( ) ) <NEWLINE> print ( a * b ) <NEWLINE>
input_num = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> print ( input_num [ 0 ] * input_num [ 1 ] ) <NEWLINE>
<COMMENT> <NL> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> <COMMENT> <NL> <NL> <COMMENT> <NL> answer = a * b <NEWLINE> <NL> <COMMENT> <NL> print ( answer ) <NEWLINE> <DEDENT>
ab = int , input ( ) . split ( ) <NEWLINE> print ( ab [ 0 ] * ab [ 1 ] ) <NEWLINE>
A , B = map ( int ( input ( ) . split ( ) ) ) <NEWLINE> C = A * B <NEWLINE> print ( C ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> a * b = c <NEWLINE> <NL> print ( c ) <NEWLINE>
A , B = map ( int , input ( ) ) <NEWLINE> print ( A * B ) <NEWLINE>
a , b = map ( int , input ( ) , split ( ) ) <NEWLINE> print ( a * b ) <NEWLINE>
A , B = map ( int , input ( ) ) <NEWLINE> print ( A * B ) <NEWLINE>
A = int ( input ( ) ) <NEWLINE> B = int ( input ( ) ) <NEWLINE> print ( A * B ) <NEWLINE>
a , b = map ( input ( ) . split ( ) , int ) <NEWLINE> print ( a * b ) <NEWLINE>
a , b = input ( ) . split ( ) <NEWLINE> <NL> print ( a * b ) <NEWLINE>
print ( A * B ) <NEWLINE>
A , B = map ( int . input ( ) . split ( ) ) <NEWLINE> print ( A * B ) <NEWLINE>
A , B = input ( ) . split ( ) <NEWLINE> 1 <= A <= 100 <NEWLINE> 1 <= B <= 100 <NEWLINE> sum = A * B <NEWLINE> print ( sum ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> rint ( b ) <NEWLINE> answer = a * b <NEWLINE> print ( answer ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = [ int ( ai ) for ai in input ( ) . split ( ) ] <NEWLINE> ans = 1 <NEWLINE> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for ai in A : <NEWLINE> <INDENT> ans *= ai <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT>
n = input ( ) <NEWLINE> t = n . split ( ) <NEWLINE> <NL> result = int ( n [ 0 ] ) * int ( n [ 1 ] ) <NEWLINE>
A = int ( input ( <STRING> ) ) <NEWLINE> B = int ( input ( <STRING> ) ) <NEWLINE> if 1 <= A <= 100 and 1 <= B <= 100 : <NEWLINE> <INDENT> c = A * B <NEWLINE> print ( c ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> args = sys . argv <NEWLINE> print ( int ( args [ 1 ] ) * int ( args [ 2 ] ) ) <NEWLINE>
<NL> def main ( ) : <NEWLINE> <INDENT> a , b = int ( input ( ) . split ( ) ) <NEWLINE> print ( a * b ) <NEWLINE> <DEDENT> main ( ) <NEWLINE>
def main ( x , y ) : <NEWLINE> <INDENT> return x * y <NEWLINE> <NL> <DEDENT> main ( A , B ) <NEWLINE>
A , B = map ( int , input ( ) . split ) <NEWLINE> print ( A * B ) <NEWLINE>
a , b = [ * map ( input ( ) . split ( <STRING> ) , int ) ] <NEWLINE> print ( a * b ) <NEWLINE>
a , b = map ( int , inout ( ) . split ( ) ) <NEWLINE> print ( a * b ) <NEWLINE>
a , b = map ( int , input ( ) ) <NEWLINE> prin ( a * b ) <NEWLINE>
a , b = int ( input ( ) . split ( ) ) <NEWLINE> <NL> print ( a * b ) <NEWLINE>
a = int ( input ( ) ) <NEWLINE> b = int ( input ( ) ) <NEWLINE> ans = a * b <NEWLINE> print ( ans ) <NEWLINE>
a , b = input ( ) . split ( ) <NEWLINE> print ( a * b ) <NEWLINE>
a = int ( input ( ) ) <NEWLINE> b = int ( input ( ) ) <NEWLINE> <NL> print ( a * b ) <NEWLINE>
A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> 1 <= A <= 100 <NEWLINE> 1 <= B <= 100 <NEWLINE> print ( a * b ) <NEWLINE>
a = int ( input ( ) ) <NEWLINE> b = int ( input ( ) ) <NEWLINE> print ( a * b ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) <NEWLINE> print ( a * b ) <NEWLINE>
a , b = map ( int , input ( ) . ssplit ( ) ) <NEWLINE> print ( a * b ) <NEWLINE>
a , b = map ( int , input ( 0. split ( ) ) ) <NEWLINE> print ( a * b ) <NEWLINE>
a = int ( input ( ) ) <NEWLINE> b = int ( input ( ) ) <NEWLINE> print ( a * b ) <NEWLINE>
<NL> t_nums = list ( map ( int ( ) , input ( ) . split ( ) ) ) <NEWLINE> print ( t_nums [ 0 ] * t_nums [ 1 ] ) <NEWLINE>
A = int ( input ( ) ) <NEWLINE> B = int ( input ( ) ) <NEWLINE> print ( A * B ) <NEWLINE>
in = input ( ) <NEWLINE> in = int ( in . split ( ) ) <NEWLINE> print ( in [ 0 ] * in [ 1 ] ) <NEWLINE>
print ( eval ( input ( ) . replase ( <STRING> , <STRING> ) ) ) <NEWLINE>
a , b = map ( int , input ( ) ) <NEWLINE> print ( a * b ) <NEWLINE>
a , b = map ( int , input ( ) ) <NEWLINE> <NL> print ( a * b ) <NEWLINE>
A , B = [ int ( i ) for i in input ( ) ] <NEWLINE> print ( A * B ) <NEWLINE>
inlist = input ( ) . split ( ) <NEWLINE> print ( inlist [ 0 ] * inlist [ 1 ] ) <NEWLINE>
a , b = int ( input ( ) . split ( ) ) <NEWLINE> print ( a * b ) <NEWLINE>
A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> return A * B <NEWLINE>
x , y = map ( int , input ( ) . split ) <NEWLINE> print ( x * y ) <NEWLINE>
x , y = input ( ) . split ( ) <NEWLINE> print ( x * y ) <NEWLINE>
a , b = input ( ) . split ( ) <NEWLINE> print ( a * b ) <NEWLINE>
A , B = map ( int , input ( ) . rstrip ( ) . split ( <STRING> ) <NEWLINE> print ( A * B ) <NEWLINE>
A , B = [ int ( x ) for x in stdin . readline ( ) . rstrip ( ) . split ( ) ] <NEWLINE> print ( A * B ) <NEWLINE>
A , B = int ( input ( ) . split ( ) ) <NEWLINE> print ( A * B ) <NEWLINE>
A , B = map ( int . input ( ) . split ( ) ) <NEWLINE> print ( A * B ) <NEWLINE>
print ( int ( eval ( input ( ) ) * eval ( input ( ) ) ) <NEWLINE>
a , b = [ int ( e ) for e in input ( ) . split ( ) ] <NEWLINE> print ( a * b ) 2 5 <NEWLINE>
<COMMENT> <NL> <NL> def __input__ ( ) : <NEWLINE> <INDENT> X = str ( input ( <STRING> ) ) <NEWLINE> em = 0 <NEWLINE> Return = [ ] <NEWLINE> error = False <NEWLINE> for spam in range ( len ( X ) ) : <NEWLINE> <INDENT> if X [ spam ] == <STRING> : <NEWLINE> <INDENT> Return . append ( int ( X [ em : spam ] ) ) <NEWLINE> em = spam + 1 <NEWLINE> <DEDENT> <DEDENT> Return . append ( X [ em : ] ) <NEWLINE> <NL> <DEDENT> l = __input__ ( ) <NEWLINE> x = 1 <NEWLINE> for a in l : <NEWLINE> <INDENT> x *= a <NEWLINE> <NL> <DEDENT> print ( x ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> r = 1 <NEWLINE> for n in A : <NEWLINE> <INDENT> r = r * n <NEWLINE> <DEDENT> print ( - 1 if r > 10 ** 18 else r ) <NEWLINE>
A , B = int ( input ( ) ) <NEWLINE> print ( A * B ) <NEWLINE>
s = input ( ) . split ( ) <NEWLINE> print ( s [ 0 ] * s [ 1 ] ) <NEWLINE>
a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> print ( a [ 0 ] * b [ 1 ] ) <NEWLINE>
a , b = list ( map ( int , input ( ) . split ) ) <NEWLINE> <NL> print ( a * b ) <NEWLINE>
<INDENT> 169 A <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> answer = a * b <NEWLINE> <NL> <COMMENT> <NL> print ( answer ) <NEWLINE>
A = int ( input ( ) ) <NEWLINE> B = int ( input ( ) ) <NEWLINE> print ( A * B ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> print a * b <NEWLINE>
n = int ( input ( ) ) <NEWLINE> ans = 1 <NEWLINE> check = 0 <NEWLINE> a = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if ans >= 10 ** 18 : <NEWLINE> <INDENT> check = 1 <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans *= a [ i ] <NEWLINE> <DEDENT> <DEDENT> print ( [ ans , - 1 ] [ check ] ) <NEWLINE>
A , B = list ( map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> print ( A * B ) <NEWLINE>
<COMMENT> <NL> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> return ( A * B ) <NEWLINE>
1 X = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> print ( X [ 0 ] * X [ 1 ] ) <NEWLINE>
a , b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> pritn ( a * b ) <NEWLINE>
val1 = input ( ) <NEWLINE> val2 = input ( ) <NEWLINE> <NL> print ( int ( val1 ) * int ( val2 ) ) <NEWLINE>
a , b = ( int ( ) <NEWLINE> <INDENT> input ( ) . split ( ) ) <NEWLINE> <DEDENT> print ( a * b ) <NEWLINE>
i = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> C = i [ 0 ] * i [ 1 ] <NEWLINE> print ( c ) <NEWLINE>
a = int ( input ( ) ) <NEWLINE> b = int ( input ( ) ) <NEWLINE> <NL> print ( a * b ) <NEWLINE>
sys . setrecursionlimit ( 10 ** 5 ) <NEWLINE> input = sys . stdin . readline <NEWLINE> def LI ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> def LF ( ) : return list ( map ( float , input ( ) . split ( ) ) ) <NEWLINE> def LI_ ( ) : return list ( map ( lambda x : int ( x ) - 1 , input ( ) . split ( ) ) ) <NEWLINE> def II ( ) : return int ( input ( ) ) <NEWLINE> def IS ( ) : return str ( input ( ) ) <NEWLINE> def IF ( ) : return float ( input ( ) ) <NEWLINE> def S ( ) : return input ( ) . rstrip ( ) <NEWLINE> def LS ( ) : return S ( ) . split ( ) <NEWLINE> def IR ( n ) : return [ II ( ) for _ in range ( n ) ] <NEWLINE> def LIR ( n ) : return [ LI ( ) for _ in range ( n ) ] <NEWLINE> def FR ( n ) : return [ IF ( ) for _ in range ( n ) ] <NEWLINE> def LFR ( n ) : return [ LI ( ) for _ in range ( n ) ] <NEWLINE> def LIR_ ( n ) : return [ LI_ ( ) for _ in range ( n ) ] <NEWLINE> def SR ( n ) : return [ S ( ) for _ in range ( n ) ] <NEWLINE> def LSR ( n ) : return [ LS ( ) for _ in range ( n ) ] <NEWLINE> mod = 1000000007 <NEWLINE> inf = float ( <STRING> ) <NEWLINE> <NL> A , B = int ( input ( ) ) <NEWLINE> <NL> print ( A * B ) <NEWLINE>
a , b = int ( input ( ) . split ( ) ) <NEWLINE> print ( a * b ) <NEWLINE>
a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> print ( i [ 0 ] * i [ 1 ] ) <NEWLINE>
A = int ( input ( ) ) <NEWLINE> B = int ( input ( ) ) <NEWLINE> print ( A * B ) <NEWLINE>
in_str = input ( ) . split ( <STRING> ) <NEWLINE> in_int = int ( in_str ) <NEWLINE> result = in_int [ 0 ] * in_int [ 1 ] <NEWLINE> print ( result ) <NEWLINE>
a , b = map ( input ( ) . split ( ) ) <NEWLINE> print ( a * b ) <NEWLINE>
a = int ( input ( ) ) <NEWLINE> b = int ( input ( ) ) <NEWLINE> num = a * b <NEWLINE> print ( num ) <NEWLINE>
a , b = map ( iny . input ( ) , split ( ) ) <NEWLINE> print ( a * b ) <NEWLINE>
a , b = map ( int , input ( ) ) <NEWLINE> print ( a * b ) <NEWLINE>
a , b = map ( int , input ( ) ) <NEWLINE> print ( a * b ) <NEWLINE>
a , b = map ( int , intput ( ) . split ( ) ) <NEWLINE> p = a * b <NEWLINE> print ( p ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> x = 1 <NEWLINE> if 0 in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> return <NEWLINE> <DEDENT> for i in a : <NEWLINE> <INDENT> x *= i <NEWLINE> if x > 1000000000000000000 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> return <NEWLINE> <DEDENT> <DEDENT> print ( x ) <NEWLINE> <DEDENT> main ( ) <NEWLINE>
a , b = input ( ) . split ( ) <NEWLINE> print ( a * b ) <NEWLINE>
a , b = map ( int , input ( ) . input ( ) ) <NEWLINE> print ( a * b ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> listA = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> except : <NEWLINE> <INDENT> break ; <NEWLINE> <NL> <DEDENT> <DEDENT> product = 1 <NEWLINE> for i in listA : <NEWLINE> <INDENT> if product < 10 ** 18 + 1 : <NEWLINE> <INDENT> product = product * i <NEWLINE> <NL> <DEDENT> <DEDENT> if listA . count ( 0 ) > 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <NL> <DEDENT> elif product < 10 ** 18 + 1 : <NEWLINE> <INDENT> print ( product ) <NEWLINE> <NL> <DEDENT> elif product >= 10 ** 18 + 1 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT>
tmp = input ( ) . split ( ) <NEWLINE> <INDENT> ans = tmp [ 0 ] * tmp [ 1 ] <NEWLINE> print ( ans ) <NEWLINE> <DEDENT>
print ( eval ( input ( ) . replace ( <STRING> , <STRING> ) ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> A = int ( input ( ) ) <NEWLINE> B = int ( input ( ) ) <NEWLINE> ans = a ( A , B ) <NEWLINE> print ( ans ) <NEWLINE> <NL> <DEDENT> def a ( A , B ) : <NEWLINE> <INDENT> return ( A * B ) <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE>
a , b = int ( input ( ) ) <NEWLINE> print ( a * b ) <NEWLINE>
A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> return A * B <NEWLINE>
a , b = map ( input ( ) . split ( ) ) <NEWLINE> print ( a * b ) <NEWLINE>
A = int ( input ( ) ) <NEWLINE> print ( int ( input ( ) ) * A ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if 0 in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = 1 <NEWLINE> for i in a : <NEWLINE> <INDENT> ans *= i <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
i = input ( ) <NEWLINE> a , b = list ( map ( int , l . split ( ) ) ) <NEWLINE> A = a * b <NEWLINE> print ( A ) <NEWLINE>
a = int ( input ( ) ) <NEWLINE> b = int ( input ( ) ) <NEWLINE> if int ( a ) , int ( b ) in range ( 1 , 100 ) : <NEWLINE> <INDENT> print ( a * b ) <NEWLINE> <DEDENT>
a = input ( ) <NEWLINE> b = input ( ) <NEWLINE> <NL> print ( a * b ) <NEWLINE>
a , b = map ( int , intput ( ) . split ( ) ) <NEWLINE> print ( a * b ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> pirnt ( a * b ) <NEWLINE>
A , B = int ( input ( ) . split ( ) ) <NEWLINE> print ( A * B ) <NEWLINE>
from operator import mul <NEWLINE> from functools import reduce <NEWLINE> <NL> <COMMENT> <NL> N = int ( input ( ) ) <NEWLINE> <COMMENT> <NL> <NL> if 2 <= N <= 10 ** 5 : <NEWLINE> <INDENT> num = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> ans = reduce ( mul , num ) <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
A , B = input ( ) . split ( ) <NEWLINE> <NL> C = A * B <NEWLINE> print ( C ) <NEWLINE>
print ( int ( input ( ) ) * int ( input ( ) ) ) <NEWLINE>
vals = input . split ( ) <NEWLINE> <NL> a = int ( vals [ 0 ] ) <NEWLINE> b = int ( vals [ 1 ] ) <NEWLINE> <NL> print ( a * b ) <NEWLINE>
a = int ( input ( ) ) <NEWLINE> b = int ( input ( ) ) <NEWLINE> print ( a * b ) <NEWLINE>
A , B = map ( int , input ( ) ) <NEWLINE> print ( A * B ) <NEWLINE>
number = int ( input ( ) ) . split ( <STRING> ) <NEWLINE> print ( number [ 0 ] * number [ 1 ] ) <NEWLINE>
a , b = map ( int , input ( ) ) <NEWLINE> print ( a * b ) <NEWLINE>
a = input ( ) <NEWLINE> A = int ( a ) <NEWLINE> b = input ( ) <NEWLINE> B = int ( b ) <NEWLINE> c = A * B <NEWLINE> print ( c ) <NEWLINE>
A , B = input ( ) . split ( ) <NEWLINE> print ( A * B ) <NEWLINE>
if ( 1 <= a <= 100 | | 1 <= b <= 100 ) <NEWLINE> <INDENT> a = int ( input ( ) ) <NEWLINE> b = int ( input ( ) ) <NEWLINE> print ( a * b ) <NEWLINE> <DEDENT> else <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
A , B = input ( ) . split ( ) <NEWLINE> print ( A * B ) <NEWLINE>
A = int ( input ( ) ) <NEWLINE> B = int ( input ( ) ) <NEWLINE> <NL> print ( str ( A * B ) ) <NEWLINE>
import sys <NEWLINE> <NL> <COMMENT> <NL> N = input ( ) <NEWLINE> <NL> <COMMENT> <NL> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> ans = 1 <NEWLINE> if 0 in A : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <NL> <DEDENT> for i in A : <NEWLINE> <COMMENT> <NL> <INDENT> ans *= i <NEWLINE> <COMMENT> <NL> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
a , b = map ( int , input ( ) ) <NEWLINE> print ( a * b ) <NEWLINE>
A = int ( input ( ) ) <NEWLINE> B = int ( input ( ) ) <NEWLINE> <NL> print ( A * B ) <NEWLINE>
a = input ( ) <NEWLINE> b = input ( ) . split ( ) <NEWLINE> result = 1 <NEWLINE> for i in range ( int ( a ) ) : <NEWLINE> <INDENT> result = result * int ( b [ i ] ) <NEWLINE> <DEDENT> if result > 1000000000000000000 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( result ) <NEWLINE> <DEDENT>
str = input ( ) <NEWLINE> arr = str . split ( <STRING> ) <NEWLINE> A = int ( arr [ 0 ] ) <NEWLINE> B = int ( arr [ 1 ] ) <NEWLINE> if 1 <= A <= 100 and 1 <= A <= 100 : <NEWLINE> <INDENT> print ( A * B ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> nums = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> <NL> output = 1 <NEWLINE> <NL> if 0 in nums : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> for x in nums : <NEWLINE> <INDENT> output *= x <NEWLINE> <NL> if output > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( output ) <NEWLINE> <DEDENT>
a , b = int ( input ( ) ) <NEWLINE> if 1 <= a <= 100 and 1 <= b <= 100 <NEWLINE> <INDENT> print ( a * b ) <NEWLINE> <DEDENT>
a , b = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> print ( a * b ) <NEWLINE>
A = int ( input ( ) ) <NEWLINE> B = int ( input ( ) ) <NEWLINE> if ( A >= 0 and A <= 100 ) and ( B >= 0 and B <= 100 ) : <NEWLINE> <INDENT> print ( <STRING> , A * B ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( NA ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> answer = a * b <NEWLINE> <NL> print ( answer ) <NEWLINE>
s = [ ] <NEWLINE> s = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( s [ 0 ] * s [ 1 ] ) <NEWLINE>
a , b = input ( ) . split ( ) <NEWLINE> print ( a * b ) <NEWLINE>
a , t = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( a * t ) <NEWLINE> a , t = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( a * t ) <NEWLINE>
a = input ( ) . split ( <STRING> ) <NEWLINE> print ( a [ 0 ] * a [ 1 ] ) <NEWLINE>
a , b = int ( input ( ) . split ( ) ) <NEWLINE> print ( int ( a * b ) ) <NEWLINE>
a , b = list ( map ( float , input ( ) . split ( ) ) ) <NEWLINE> aint = int ( a ) <NEWLINE> print ( <STRING> . format ( round ( aint * number [ 1 ] ) ) ) <NEWLINE>
a , b = map ( in , input ( ) . split ( ) ) <NEWLINE> print ( a * b ) <NEWLINE>
A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> print ( A * B <NEWLINE>
a , b = int ( input ( ) ) <NEWLINE> print ( a * b ) <NEWLINE>
A , B = int ( input ( ) . split ( ) ) <NEWLINE> print ( A * B ) <NEWLINE>
a , b = mao ( int , input ( ) . split ( ) ) <NEWLINE> print ( a * b ) <NEWLINE>
a , b = map ( int , input ( ) . split ) <NEWLINE> print ( a * b ) <NEWLINE>
a , b = int ( input ( ) . split ( ) ) <NEWLINE> <NL> print ( a * b ) <NEWLINE>
a , b = int ( input ( ) . split ( ) ) <NEWLINE> a * b <NEWLINE>
A , B = map ( int , input ( ) , split ( ) ) <NEWLINE> print ( A * B ) <NEWLINE>
num1 = int ( input ( ) ) <NEWLINE> num2 = int ( input ( ) ) <NEWLINE> seki = num1 * num2 <NEWLINE> print ( seki ) <NEWLINE>
a , b = map ( int . input ( ) , split ( ) ) <NEWLINE> <NL> print ( a * b ) <NEWLINE>
A = int ( input ( ) ) <NEWLINE> B = int ( input ( ) ) <NEWLINE> <NL> X = A * B <NEWLINE> print ( X ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> M = int ( input ( ) ) <NEWLINE> <NL> print ( N * M ) <NEWLINE>
nums = input ( ) . split ( ) <NEWLINE> print ( nums [ 0 ] * nums [ 1 ] ) <NEWLINE>
a , b = int ( input ( ) . split ( ) ) <NEWLINE> print ( a * b ) <NEWLINE>
a , b = int ( input ( ) . split ( ) ) <NEWLINE> print ( a * b ) <NEWLINE>
A , B = map ( int . input ( ) , split ( ) ) <NEWLINE> print ( A * B ) <NEWLINE>
A , B = int ( input ( ) . split ( ) ) <NEWLINE> <NL> print ( A * B ) <NEWLINE>
A , B = input ( ) . split ( ) <NEWLINE> C = A * B <NEWLINE> print ( C ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> x = 1 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> x *= a [ i ] <NEWLINE> <DEDENT> if x > 1000000000000000001 : <NEWLINE> <INDENT> x = - 1 <NEWLINE> <DEDENT> print ( x ) <NEWLINE>
import sys <NEWLINE> from collections import deque <NEWLINE> import copy <NEWLINE> def main ( ) : <NEWLINE> <INDENT> A , B = map ( int , input ( ) ) <NEWLINE> print ( A * B ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
a = int ( input ( ) ) <NEWLINE> <NL> b = int ( input ( ) ) <NEWLINE> <NL> print ( a * b ) <NEWLINE>
A , B = int ( input . split ( ) ) <NEWLINE> <NL> print ( A * B ) <NEWLINE>
A = int ( input ( ) ) <NEWLINE> B = int ( input ( ) ) <NEWLINE> print ( A * B ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> prinr ( a * b ) <NEWLINE>
A , B = map ( int , input ( ) ) <NEWLINE> <NL> print ( A * B <NEWLINE>
A = int ( input ( ) ) <NEWLINE> B = int ( input ( ) ) <NEWLINE> <NL> print ( A * B ) <NEWLINE>
A , B = int ( input ( ) . split ( ) ) <NEWLINE> print ( A , B ) <NEWLINE>
a , b = int ( input ( ) ) <NEWLINE> r = a * b <NEWLINE> print ( r ) <NEWLINE>
A , B = int ( input ( ) ) <NEWLINE> print ( A * B ) <NEWLINE>
import numpy as np <NEWLINE> <NL> <NL> def main ( A , B ) : <NEWLINE> <NL> <INDENT> ans = A * B <NEWLINE> return ans <NEWLINE> <NL> <NL> <DEDENT> A , B = int ( input ( ) ) <NEWLINE> print ( main ( A , B ) ) <NEWLINE>
a = input ( ) <NEWLINE> b = input ( ) <NEWLINE> print ( a * b ) <NEWLINE>
A , B = nap ( int , input ( ) . split ( ) ) <NEWLINE> print ( A * B ) <NEWLINE>
a = int ( input ( ) ) <NEWLINE> b = int ( input ( ) ) <NEWLINE> print ( a * b ) <NEWLINE>
A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> c = a * b <NEWLINE> print ( c ) <NEWLINE>
<COMMENT> <NL> int A ; <NEWLINE> int B ; <NEWLINE> <NL> <COMMENT> <NL> print ( A * B ) <NEWLINE>
A , B = map ( int , input ( ) , split ( ) ) <NEWLINE> print ( A * B ) <NEWLINE>
a = map ( int , input ( ) . split ( ) ) <NEWLINE> b = map ( int , input ( ) . split ( ) ) <NEWLINE> c = a * b <NEWLINE> print ( c ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> s = input ( ) <NEWLINE> <NL> part1 = s [ : k - 1 ] <NEWLINE> part2 = s [ k - 1 ] . lower ( ) <NEWLINE> part3 = s [ k : ] <NEWLINE> <NL> print ( <STRING> ) <NEWLINE>
a , b = int ( input ( ) . split ( ) ) <NEWLINE> print ( a * b ) <NEWLINE>
a = int ( input ( ) ) <NEWLINE> b = int ( input ( ) ) <NEWLINE> print ( a * b ) <NEWLINE>
a , b = map ( int ( input ( ) . split ( ) ) <NEWLINE> print ( a * b ) <NEWLINE>
a , b = int ( input ( ) ) . split ( ) <NEWLINE> <NL> result = a * b <NEWLINE> print ( result ) <NEWLINE>
x = int ( input ( ) ) <NEWLINE> y = int ( input ( ) ) <NEWLINE> print ( x * y ) <NEWLINE>
a , b = ( int ( input ( ) . split ( ) ) ) <NEWLINE> print ( a * b ) <NEWLINE>
import math as m <NEWLINE> a , b = list ( map ( float , input ( ) . split ( ) ) ) <NEWLINE> print ( m . floor ( a * ( b * 10 ** 5 ) / 10 ** 5 ) <NEWLINE>
( a , b ) = [ int ( x ) for x input ( ) . split ( ) ] <NEWLINE> print ( a * b ) <NEWLINE>
input ( ) <NEWLINE> b = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> if 0 not in b : <NEWLINE> <INDENT> last = 1 <NEWLINE> for i in b : <NEWLINE> <INDENT> last *= i <NEWLINE> if last > 10 ** 18 : <NEWLINE> <INDENT> last = - 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> last = 0 <NEWLINE> <NL> <DEDENT> print ( last ) <NEWLINE>
x , y = map ( int , input ( ) ) <NEWLINE> print ( x * y ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> As = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> Ans = 1 <NEWLINE> <NL> for A in range ( N ) : <NEWLINE> <INDENT> NewAns = Ans * As [ A ] <NEWLINE> Ans = NewAns <NEWLINE> <DEDENT> if Ans > 10 ** 18 : <NEWLINE> <INDENT> Ans = - 1 <NEWLINE> <NL> <DEDENT> print ( Ans ) <NEWLINE>
A , B = map ( int , input ( ) . split ) <NEWLINE> <NL> print ( A * B ) <NEWLINE>
x = int ( input ( ) ) <NEWLINE> y = int ( input ( ) ) <NEWLINE> print ( x * y ) <NEWLINE>
a , b = map ( int , int ( ) . input ( ) ) <NEWLINE> print ( a * b ) <NEWLINE>
from sys import stdin <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> read = stdin . readline <NEWLINE> N = int ( read ( ) ) <NEWLINE> data = list ( map ( int , read ( ) . split ( <STRING> ) ) ) <NEWLINE> ans = 1 <NEWLINE> flg = False <NEWLINE> for i in data : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> flg = True <NEWLINE> break <NEWLINE> <DEDENT> if ans * i > 10 ** 18 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> flg = True <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans *= i <NEWLINE> <NL> <DEDENT> <DEDENT> if not flg : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
a , b = map ( int , input . split ( ) ) <NEWLINE> <NL> print ( a * b ) <NEWLINE>
int A , B <NEWLINE> A = 6 <NEWLINE> B = 6 <NEWLINE> print ( A * B ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> re = 1 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> re *= A [ i ] <NEWLINE> if re >= pow ( 10 , 18 ) : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> return <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( re ) <NEWLINE> return <NEWLINE> <DEDENT>
print ( int ( input ( ) * int ( input ( ) ) ) <NEWLINE>
A , B = map ( int , input ( ) ) <NEWLINE> print ( A * B ) <NEWLINE>
a , b = input ( ) <NEWLINE> a = int ( a ) <NEWLINE> b = int ( b ) <NEWLINE> <NL> print ( a * b ) <NEWLINE>
a = int ( input ( ) ) . split ( ) <NEWLINE> print ( a [ 0 ] * a [ 1 ] ) <NEWLINE>
a , b = input ( ) . split ( <STRING> ) <NEWLINE> print ( a * b ) <NEWLINE>
a , b = input ( ) <NEWLINE> <NL> <NL> seki = int ( a ) * int ( b ) <NEWLINE> print ( seki ) <NEWLINE>
A , B = map ( int , input ( ) ) <NEWLINE> print ( A * B ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( a * b ) 2 <NEWLINE>
a , b = int ( input ( ) ) <NEWLINE> print ( a * b ) <NEWLINE>
print ( A * B ) <NEWLINE>
a , b = map ( int ( input ( ) ) . split ( ) ) <NEWLINE> print ( a * b ) <NEWLINE>
print ( int ( input ( ) ) * int ( input ( ) ) ) <NEWLINE>
N , M = map ( int , input ( ) ) <NEWLINE> <NL> print ( N * M ) <NEWLINE>
x , y = int ( input ( <STRING> ) ) , int ( input ( <STRING> ) ) <NEWLINE> print ( x * y ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> i = 1 <NEWLINE> while A [ 0 ] <= 10 ** 18 and i <= N - 1 : <NEWLINE> <INDENT> A [ 0 ] *= A [ i ] <NEWLINE> i += 1 <NEWLINE> <DEDENT> if A [ 0 ] > 10 ** 18 : <NEWLINE> <INDENT> A [ 0 ] = - 1 <NEWLINE> <DEDENT> print ( A [ 0 ] ) <NEWLINE>
<INDENT> a169 <NEWLINE> <COMMENT> <NL> <NL> <COMMENT> <NL> <DEDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> <COMMENT> <NL> <NL> <COMMENT> <NL> answer = a * b <NEWLINE> <NL> <COMMENT> <NL> print ( answer ) <NEWLINE>
A , B = int ( input ( ) . split ( ) ) <NEWLINE> C = A * B <NEWLINE> print ( C ) <NEWLINE>
A , B = int ( input ( ) ) <NEWLINE> print ( A * B ) <NEWLINE>
A = list ( map ( int , input ( ) . split ( ) ) <NEWLINE> print ( A [ 0 ] * A [ 1 ] ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> i = 0 <NEWLINE> ans = 0 <NEWLINE> if 0 in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> while ans < 10 ** 10 and i < len ( a ) : <NEWLINE> <INDENT> ans *= a [ i ] <NEWLINE> <DEDENT> if ( ans <= 10 ** 18 ) : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> cnt = 1 <NEWLINE> <NL> if a in 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( n ) : <NEWLINE> <INDENT> cnt = cnt * a [ i ] <NEWLINE> <NL> <DEDENT> if cnt > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( cnt ) <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> input ( ) <NEWLINE> l = 10 ** 18 <NEWLINE> a = 1 <NEWLINE> for i in map ( int , input ( ) ) : <NEWLINE> <INDENT> a *= i <NEWLINE> if a > l : <NEWLINE> <INDENT> a = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( a ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> return <NEWLINE> <DEDENT> prod = 1 <NEWLINE> for a in A : <NEWLINE> <INDENT> prod *= a <NEWLINE> if prod > 1000000000000000000 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> return <NEWLINE> <DEDENT> <DEDENT> print ( prod ) <NEWLINE>
import sys <NEWLINE> <NL> def input ( ) : <NEWLINE> <INDENT> return sys . stdin . readline ( ) . strip ( ) <NEWLINE> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> sum = 1 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> sum *= A [ i ] <NEWLINE> <DEDENT> if ( sum > 10 ** 18 ) : <NEWLINE> <INDENT> sum = - 1 <NEWLINE> <DEDENT> print ( sum ) <NEWLINE> <NL> main ( ) <NEWLINE>
<COMMENT> <NL> <NL> n = int ( input ( ) ) <NEWLINE> a_li = list ( map ( int , ( input ( ) . split ( ) ) ) ) <NEWLINE> <NL> product = 1 <NEWLINE> <NL> if 0 in a_li : <NEWLINE> <INDENT> product = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in a_li : <NEWLINE> <INDENT> product *= i <NEWLINE> if product > 10 ** 18 : <NEWLINE> <INDENT> product = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> break <NEWLINE> <NL> <DEDENT> print ( product ) <NEWLINE>
p = 1 <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> p *= a [ i ] <NEWLINE> <INDENT> if p > 10 ** 18 : <NEWLINE> <INDENT> return - 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> return p <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input . split ( ) ) ) <NEWLINE> a = sorted ( a ) <NEWLINE> prod = 1 <NEWLINE> for x in a : <NEWLINE> <INDENT> prod *= x <NEWLINE> if prod > 10 ** 18 : <NEWLINE> <INDENT> prod = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( prod ) <NEWLINE>
_ , * a = map ( int , open ( 0 ) . read . split ( ) ) <NEWLINE> ret = 1 <NEWLINE> for x in sorted ( a ) : <NEWLINE> <INDENT> ret *= x <NEWLINE> if ret > 10 ** 18 : <NEWLINE> <INDENT> ret = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( ret ) <NEWLINE>
n = input ( ) <NEWLINE> lista = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> r = 1 <NEWLINE> <NL> if 0 in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for a in lista : <NEWLINE> <INDENT> r *= a <NEWLINE> if r > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( r ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> <NL> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for _ , val in enumerate ( a ) : <NEWLINE> <INDENT> ans *= val <NEWLINE> <DEDENT> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 1 <NEWLINE> for i in A : <NEWLINE> <INDENT> ans = ans * i <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = map ( int , input ( ) . split ( ) ) <NEWLINE> sum = 1 <NEWLINE> for x in a : <NEWLINE> <INDENT> sum *= a <NEWLINE> if sum > 1e18 : <NEWLINE> <INDENT> sum = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( sum ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> <INDENT> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> prod = 1 <NEWLINE> for a in A : <NEWLINE> prod *= a <NEWLINE> <INDENT> if prod > 1000000000 : <NEWLINE> print ( - 1 ) <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> <DEDENT> print ( prod ) <NEWLINE> <DEDENT> <DEDENT> main ( ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> alist = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> <NL> if 0 in alist : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> result = 1 <NEWLINE> m = 0 <NEWLINE> while result <= 10 ** 18 : <NEWLINE> <INDENT> result *= alist [ m ] <NEWLINE> m += 1 <NEWLINE> <DEDENT> if m < n or result > 10 ** 18 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( result ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> x = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = x [ 0 ] <NEWLINE> if 0 in x : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( 1 , n ) : <NEWLINE> <INDENT> ans = ans * x [ i ] <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import numpy as np <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = np . ones ( N ) <NEWLINE> a = np . ones ( N ) <NEWLINE> <NL> A = map ( int , input ( ) . rstrip ( ) . split ( ) ) <NEWLINE> <NL> <NL> a = sorted ( A , reverse = True ) <NEWLINE> <NL> a_product = 1 <NEWLINE> flag_1e18 = False <NEWLINE> flag_0 = False <NEWLINE> <NL> if a [ N - 1 ] == 0 : <NEWLINE> <INDENT> flag_0 = True <NEWLINE> <NL> <DEDENT> for i in range ( 0 , N , 1 ) : <NEWLINE> <INDENT> a_product = a_product * a [ i ] <NEWLINE> if a_product > 1e18 : <NEWLINE> <INDENT> flag_1e18 = True <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <DEDENT> <DEDENT> if flag_1e18 == True and flag_0 == False : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> elif flag_0 == True : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( A_product ) <NEWLINE> <NL> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 1 <NEWLINE> <NL> if 0 in A : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in A : <NEWLINE> <INDENT> ans *= A <NEWLINE> i += 1 <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> lim = 1 <NEWLINE> for i in range ( 18 ) : <NEWLINE> <INDENT> lim *= 10 <NEWLINE> <NL> <DEDENT> ans = 1 <NEWLINE> <NL> for A_ in A : <NEWLINE> <INDENT> ans *= A <NEWLINE> if ans > lim : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> arr = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> result = 1 <NEWLINE> if 0 in arr : <NEWLINE> <INDENT> result = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in a : <NEWLINE> <INDENT> result *= i <NEWLINE> if result > 10 ** 18 : <NEWLINE> <INDENT> result = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( result ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> return <NEWLINE> <DEDENT> prod = 1 <NEWLINE> for a in A : <NEWLINE> <INDENT> prod *= a <NEWLINE> <DEDENT> if prod > 1000000000000000000 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> <DEDENT> print ( prod ) <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE>
n = input ( ) <NEWLINE> ans = 1 <NEWLINE> s = list ( map ( int , input ( ) . strip ( ) . split ( ) ) ) <NEWLINE> if 0 in s : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> for i in s : <NEWLINE> <INDENT> if if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> ans = ans * i <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> using namespace std ; <NEWLINE> <NL> <NL> long long LIMIT = 1000000000000000000 ; <NEWLINE> <NL> int main ( ) { <NEWLINE> <INDENT> int n ; <NEWLINE> cin >> n ; <NEWLINE> vector < long long > vec ( n ) ; <NEWLINE> <NL> for ( int i = 0 ; i < n ; i + + ) { <NEWLINE> <INDENT> cin >> vec . at ( i ) ; <NEWLINE> <DEDENT> } <NEWLINE> <NL> if ( std : : find ( vec . begin ( ) , vec . end ( ) , 0 ) != vec . end ( ) ) { <NEWLINE> <INDENT> cout << 0 << endl ; <NEWLINE> return 0 ; <NEWLINE> <DEDENT> } <NEWLINE> <NL> long long products = 1 ; <NEWLINE> for ( int i = 0 ; i < n ; i + + ) { <NEWLINE> <INDENT> products *= vec . at ( i ) ; <NEWLINE> <DEDENT> if ( products > LIMIT ) { <NEWLINE> <INDENT> cout << - 1 << endl ; <NEWLINE> return 0 ; <NEWLINE> } <NEWLINE> <DEDENT> } <NEWLINE> <NL> cout << products << endl ; <NEWLINE> <NL> return 0 ; <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a . sort ( reverse = True ) <NEWLINE> res = 1 <NEWLINE> check = 10 ** 18 <NEWLINE> if 0 in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( a ) : <NEWLINE> <INDENT> if res > check : <NEWLINE> <INDENT> res = - 1 <NEWLINE> break <NEWLINE> <DEDENT> res *= a [ i ] <NEWLINE> <DEDENT> print ( res ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> <NL> alis = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 1 <NEWLINE> <NL> for a in alis : <NEWLINE> <INDENT> ans *= a <NEWLINE> if ans > 10 ** 18 : <NEWLINE> ans = - 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 1 <NEWLINE> <NL> if 0 in A : <NEWLINE> <INDENT> ans = 0 <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in A : <NEWLINE> <INDENT> ans = ans * i <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> ans = 1 <NEWLINE> N = int ( input ( ) ) <NEWLINE> nums = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if 0 in nums : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> for num in nums : <NEWLINE> <INDENT> ans *= num <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <INDENT> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> sum = 1 <NEWLINE> f = 0 <NEWLINE> f2 = 0 <NEWLINE> if 0 in a : <NEWLINE> <INDENT> f2 = 1 <NEWLINE> <DEDENT> for a in A : <NEWLINE> <INDENT> sum = sum * a <NEWLINE> if ( sum > 10 ** 18 ) : <NEWLINE> <INDENT> sum = - 1 <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if f2 == 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( sum ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> return <NEWLINE> <DEDENT> prod = 1 <NEWLINE> for a in A : <NEWLINE> <INDENT> prod *= a <NEWLINE> if prod > 1000000000000000000 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> return <NEWLINE> <DEDENT> <DEDENT> print ( prod ) <NEWLINE> <NL> main ( ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> cal = 1 <NEWLINE> i = 0 <NEWLINE> while i <= range ( N ) : <NEWLINE> <INDENT> cal *= A [ i ] <NEWLINE> i += 1 <NEWLINE> <DEDENT> if cal >= 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( cal ) <NEWLINE> <NL> <DEDENT>
n = int ( input ( ) ) <NEWLINE> <NL> a = list ( map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> s = 1 <NEWLINE> for i in a : <NEWLINE> <INDENT> s = s * i <NEWLINE> <DEDENT> if s > 10 ** 18 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( s ) <NEWLINE> <DEDENT>
n , * a = map ( int , open ( 0 ) . read ( ) . split ( ) ) <NEWLINE> s = 1 <NEWLINE> if 0 in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> for i in a : <NEWLINE> <INDENT> s *= a <NEWLINE> if s > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( s ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> mul = 1 <NEWLINE> key = 0 <NEWLINE> for i in range ( len ( a ) ) : <NEWLINE> <INDENT> if a [ i ] == 0 : <NEWLINE> <INDENT> key = 1 <NEWLINE> print ( 0 ) <NEWLINE> break ; <NEWLINE> <DEDENT> <DEDENT> if key == 0 : <NEWLINE> <INDENT> for i in range ( len ( a ) ) : <NEWLINE> <INDENT> mul = mul * a [ i ] <NEWLINE> if mul > 1000000000000000000 : <NEWLINE> break <NEWLINE> <DEDENT> if ( mul < 1000000000000000001 ) : <NEWLINE> <INDENT> print ( mul ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> using namespace std ; <NEWLINE> <NL> int main ( ) { <NEWLINE> <INDENT> double sr ; <NEWLINE> long long int lr ; <NEWLINE> cin >> lr >> sr ; <NEWLINE> <NL> cout << ( long long int ) ( double ( lr % 1000 ) * sr ) + ( lr / 1000 ) * ( ( long long int ) ( sr * 1000 ) ) << endl ; <NEWLINE> <DEDENT> } <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 1 <NEWLINE> c = 0 <NEWLINE> <NL> while c < N : <NEWLINE> <INDENT> if A [ c ] == 0 : <NEWLINE> <INDENT> ans = 0 break ; <NEWLINE> <DEDENT> else if ans * A [ c ] > 10000000000000000 : <NEWLINE> <INDENT> ans = 10000000000000001 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = ans * A [ c ] <NEWLINE> <NL> <DEDENT> c += 1 <NEWLINE> <NL> <DEDENT> if ans > 10000000000000000 : print ( - 1 ) <NEWLINE> else : print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> count = 1 <NEWLINE> <NL> for i in a : <NEWLINE> <INDENT> count *= i <NEWLINE> <NL> <DEDENT> x = 10 ** 18 <NEWLINE> <NL> if count > x : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( count ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> A . sort ( ) <NEWLINE> rslt = A [ 0 ] <NEWLINE> <NL> for a in A [ 1 : ] : <NEWLINE> <INDENT> result *= a <NEWLINE> if rslt > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( rslt ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> ans = 1 <NEWLINE> for i in a : <NEWLINE> <INDENT> ans = ans * i <NEWLINE> if ans >= 1000000000000000000 : <NEWLINE> <INDENT> break : <NEWLINE> <NL> <DEDENT> <DEDENT> if ans >= 1000000000000000000 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
n = int ( input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ret = 1 <NEWLINE> for a in A : <NEWLINE> <INDENT> ret *= a <NEWLINE> if ret > 10 ** 18 : <NEWLINE> <INDENT> ret = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( ret ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> <NL> input ( ) <NEWLINE> l = list ( map ( lambda x : int ( x ) , str ( input ( ) ) . split ( <STRING> ) ) ) <NEWLINE> r = 1 <NEWLINE> finished = False <NEWLINE> for i in l : <NEWLINE> <INDENT> r = r * l <NEWLINE> if r > 10 ** 18 : <NEWLINE> <INDENT> print ( str ( - 1 ) ) <NEWLINE> finished = True <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if not finished : <NEWLINE> <INDENT> print ( str ( r ) ) <NEWLINE> <DEDENT>
N = input ( ) <NEWLINE> M = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> mult = 1 <NEWLINE> <NL> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> for a in M : <NEWLINE> <INDENT> mult *= a <NEWLINE> if mult > 1000000000000000000 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( mult ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> data = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> flag = 0 <NEWLINE> if data . count ( 0 ) > 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else <NEWLINE> <INDENT> a = data [ 0 ] <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> a = a * data [ i ] <NEWLINE> <INDENT> if a > 10 ** 18 : <NEWLINE> <INDENT> flag = 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if flag == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else <NEWLINE> <INDENT> print ( a ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> mul = 1 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ai = int ( input ( ) ) <NEWLINE> mul = mul * ai <NEWLINE> if mul > 10 ** 18 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT>
n = long ( input ( ) ) <NEWLINE> a = [ long ( x ) for x in input ( ) . split ( ) ] <NEWLINE> <NL> ans = 1 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ans *= a [ i ] <NEWLINE> if ( ans > 1000000000000000000 ) : <NEWLINE> <INDENT> break ; <NEWLINE> <DEDENT> if ( ans == 0 ) : <NEWLINE> <INDENT> break ; <NEWLINE> <NL> <DEDENT> <DEDENT> if ( ans > 1000000000000000000 ) : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
t = int ( input ( ) ) <NEWLINE> list_v = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> res = 1 <NEWLINE> for v in list_v : <NEWLINE> <INDENT> if v == 0 : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> res = res * v <NEWLINE> if res > 10 ** 18 : <NEWLINE> <INDENT> res = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( res ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> finish = 0 <NEWLINE> result = 1 <NEWLINE> <NL> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> finish = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <NL> <INDENT> for n in range ( N ) : <NEWLINE> <INDENT> result = result * A [ n ] <NEWLINE> if result > 1000000000000000000 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> finish = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if finish = 0 : <NEWLINE> <INDENT> print ( result ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> return <NEWLINE> <DEDENT> prod = 1 <NEWLINE> for a in A : <NEWLINE> <INDENT> prod *= a <NEWLINE> if prod > 1000000000000000000 : <NEWLINE> print ( - 1 ) : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> <DEDENT> print ( prod ) <NEWLINE> <DEDENT> main ( ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 1 <NEWLINE> t = 1e18 <NEWLINE> if 0 in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( 0 ) <NEWLINE> <NL> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> ans *= a [ i ] <NEWLINE> if ans > t : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( 0 ) <NEWLINE> <NL> <DEDENT> <DEDENT> prin ( ans ) <NEWLINE>
<COMMENT> <NL> N = int ( input ( ) ) <COMMENT> <NEWLINE> <NL> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> output = 1 <NEWLINE> for a in A : <NEWLINE> <INDENT> output *= a <NEWLINE> <NL> if output > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> <DEDENT> print ( output ) <NEWLINE>
def main ( ) : <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if 0 in A : <NEWLINE> print ( 0 ) <NEWLINE> return <NEWLINE> prod = 1 <NEWLINE> for a in A : <NEWLINE> prod *= a <NEWLINE> if prod > 1000000000000000000 : <NEWLINE> print ( - 1 ) <NEWLINE> return <NEWLINE> print ( prod ) <NEWLINE> main ( ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> num = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = num . prod ( ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> ar = map ( int , input . split ( ) ) <NEWLINE> mul = 1 <NEWLINE> for i in ar : <NEWLINE> <INDENT> mul *= i <NEWLINE> if mul > 1000000000000000000 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> if mul > 1000000000000000000 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( mul ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> ans = 1 <NEWLINE> s = input ( ) <NEWLINE> a = [ int ( x . strip ( ) ) for x in s . split ( <STRING> ) ] <NEWLINE> if 0 in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> return <NEWLINE> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> ans *= a [ i ] <NEWLINE> if ans > 1000000000000000000 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> return <NEWLINE> <DEDENT> <DEDENT> print ans <NEWLINE>
n = int ( input ( ) ) <NEWLINE> x = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 1 <NEWLINE> if 0 in x : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> break <NEWLINE> for i in x : <NEWLINE> <INDENT> ans = ans * i <NEWLINE> <DEDENT> <DEDENT> if ans >= 1000000000000000000 : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> ans = 1 <NEWLINE> a = list ( map ( int , inpiut ( ) . split ( ) ) ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ans *= a [ i ] <NEWLINE> <DEDENT> if ans >= 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> ans = 1 <NEWLINE> if 0 in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> ans += a [ i ] <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) n = int ( input ( ) ) <NEWLINE> a = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> ans = 1 <NEWLINE> if 0 in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> ans += a [ i ] <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
i = input ; i ( ) ; l = i ( ) . split ( ) ; x = 1 - ( <STRING> in l ) <NEWLINE> for j in l : <NEWLINE> <INDENT> x *= int ( j ) ; if x > 1e18 : x = - 1 ; break <NEWLINE> <DEDENT> print ( x ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = [ map ( int , input ( ) . split ( ) ) ] <NEWLINE> sorted ( A ) <NEWLINE> if A [ 0 ] == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( 0 ) <NEWLINE> <NL> <DEDENT> ans = 1 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> ans *= A [ i ] <NEWLINE> if ( ans > 1000000000000000000 ) : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( 0 ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
def mult ( m ) : <NEWLINE> <INDENT> s = 1 <NEWLINE> for x in m : <NEWLINE> <INDENT> s = s * x <NEWLINE> if s == 0 : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> if s > 10 ** 18 : <NEWLINE> <INDENT> return - 1 <NEWLINE> return s <NEWLINE> <DEDENT> <DEDENT> <DEDENT> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a . sort ( ) <NEWLINE> z = mult ( a ) <NEWLINE> print ( z ) <NEWLINE>
<COMMENT> <NL> from functools import reduce <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = tuple ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> flg = True <NEWLINE> MAX = 10 ** 18 <NEWLINE> cnt = 1 <NEWLINE> a . sort ( ) <NEWLINE> result = reduce ( lambda ans , x : ans * x , a ) <NEWLINE> if result > MAX : <NEWLINE> <INDENT> flg = False <NEWLINE> break <NEWLINE> <NL> <DEDENT> if flg : <NEWLINE> <INDENT> print ( result ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> ans = 1 <NEWLINE> for i in l : <NEWLINE> <INDENT> ans *= i <NEWLINE> if ans > 10 ** 18 : <NEWLINE> print ( - 1 ) <NEWLINE> break <NEWLINE> <DEDENT> if not ans > 10 ** 18 : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
<COMMENT> <NL> using namespace std ; <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> typedef long long int ll ; <NEWLINE> typedef pair < int , int > P ; <NEWLINE> const ll MOD = 1e9 + 7 , INF = 1e9 ; <NEWLINE> <NL> int main ( ) <NEWLINE> { <NEWLINE> <INDENT> int n ; cin >> n ; <NEWLINE> <INDENT> vector < ll > v ( n ) ; <NEWLINE> rep ( i , n ) { <NEWLINE> <INDENT> cin >> v [ i ] ; <NEWLINE> <DEDENT> } <NEWLINE> sort ( All ( v ) ) ; <NEWLINE> if ( v [ 0 ] == 0 ) { <NEWLINE> <INDENT> cout << 0 << endl ; <NEWLINE> return 0 ; <NEWLINE> <DEDENT> } <NEWLINE> ll ans = v [ n - 1 ] ; <NEWLINE> for ( int i = 0 ; i < n - 1 ; i + + ) { <NEWLINE> <INDENT> ans *= v [ i ] ; <NEWLINE> if ( ans > ( ll ) 1e18 ) { <NEWLINE> <INDENT> cout << - 1 << endl ; <NEWLINE> return 0 ; <NEWLINE> <DEDENT> } <NEWLINE> <DEDENT> } <NEWLINE> if ( ans < 0 ) { <NEWLINE> <INDENT> cout << - 1 << endl ; <NEWLINE> <DEDENT> } <NEWLINE> else cout << ans << endl ; <NEWLINE> system ( <STRING> ) ; <NEWLINE> <DEDENT> <DEDENT> } <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if a . index ( 0 ) >= 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> ret = 1 <NEWLINE> for a_ in a : <NEWLINE> <INDENT> ret *= a_ <NEWLINE> if ret > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( ret ) <NEWLINE>
res = 1 <NEWLINE> if 0 in a : <NEWLINE> <INDENT> res = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( n ) : <NEWLINE> <INDENT> b = a . pop ( ) <NEWLINE> if b != 1 : <NEWLINE> <INDENT> res *= b <NEWLINE> <NL> if res > 1000000000000000000 : <NEWLINE> <INDENT> res = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( res ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> a = map ( int , input ( ) . split ( ) ) <NEWLINE> if 0 in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> for i in a : <NEWLINE> <INDENT> num = num * i <NEWLINE> if num > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( num ) <NEWLINE>
input ( ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> for n in a : <NEWLINE> <INDENT> ans *= n <NEWLINE> if ans <= 10 ** 18 : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT> break : <NEWLINE> <DEDENT> print ( - 1 ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> return <NEWLINE> <DEDENT> prod = 1 <NEWLINE> for a in A : <NEWLINE> <INDENT> prod *= a <NEWLINE> if prod > 1000000000000000000 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> <DEDENT> print ( prod ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> lists = list ( int ( input ( ) ) for i in range ( n ) ) <NEWLINE> number = 1 <NEWLINE> for j in lists : <NEWLINE> <INDENT> if number == 0 : <NEWLINE> <INDENT> number = 0 <NEWLINE> break <NEWLINE> <DEDENT> number = number * j <NEWLINE> if number > 10 ** 18 : <NEWLINE> <INDENT> number = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( number ) <NEWLINE>
def Qb ( ) : <NEWLINE> <INDENT> from functools import reduce <NEWLINE> from operator import mul <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> lina = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if 0 in lina : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> ans = reduce ( mul , lina ) <NEWLINE> <NL> if 10 ** 18 < ans : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> def Qc ( ) : <NEWLINE> <INDENT> pass <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> Qb ( ) <NEWLINE> <DEDENT>
<INDENT> from functools import reduce <NEWLINE> n = int ( input ( ) ) <NEWLINE> tab = [ int ( n ) for n in input ( ) . split ( ) ] <NEWLINE> if 0 in tab : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> res = reduce ( lambda x , y : x * y , tab ) <NEWLINE> if res > 1000000000000000000 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( res ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> new = 1 <NEWLINE> if 0 in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> for i in a : <NEWLINE> <NL> <INDENT> new *= a <NEWLINE> if new > ( 10 ** 18 ) : <NEWLINE> <INDENT> new = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( new ) <NEWLINE> <NL>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a . sort ( ) <NEWLINE> ans = 1 <NEWLINE> max_limit = 10 ** 18 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> ans *= A [ i ] <NEWLINE> if ans > max_limit : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if ans > max_limit : <NEWLINE> <INDENT> print ( str ( - 1 ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( str ( ans ) ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> list_A = input ( ) . split ( ) <NEWLINE> list_A = [ int ( i ) for i in list_A ] <NEWLINE> <NL> temp_sum = 1 <NEWLINE> flag = False <NEWLINE> flag_0 = False <NEWLINE> <NL> if 0 in list_A : <NEWLINE> <INDENT> flag_0 = True <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( N ) : <NEWLINE> <INDENT> temp_sum *= list_A [ i ] <NEWLINE> if temp_sum >= 10 ** 18 : <NEWLINE> <INDENT> flag = True <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if flag_0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> elif ( flag_0 == False ) and flag : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( temp_sum ) <NEWLINE> <DEDENT>
INF = 10 ** 18 <NEWLINE> N = int ( input ( ) ) <NEWLINE> sum = 1 <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> sum = sum * int ( input ( ) ) <NEWLINE> if sum > INF : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> import sys <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( sum ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> return <NEWLINE> <NL> prod = 1 <NEWLINE> for a in A : <NEWLINE> prod *= a <NEWLINE> if prod > 1000000000000000000 : <NEWLINE> print ( - 1 ) return <NEWLINE> <DEDENT> print ( prod ) <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE>
import numpy <NEWLINE> n = int ( input ( ) ) <NEWLINE> ls = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if 0 in ls : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> res = numpy . prod ( ls ) <NEWLINE> elif res > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( numpy . prod ( ls ) ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> li = [ ] <NEWLINE> C = 1 <NEWLINE> while C <= 10 ** 18 : <NEWLINE> <INDENT> for i in range ( N ) : <NEWLINE> <INDENT> li . insert ( i , int ( input ( ) ) <NEWLINE> <INDENT> C *= li [ i ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if C <= 10 ** 18 : <NEWLINE> <INDENT> print ( C ) <NEWLINE> <DEDENT> else : print ( - 1 ) <NEWLINE> <NL> <NL> <NL> <NL>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) ) . split ( ) ) <NEWLINE> if 0 in a : exit ( print ( 0 ) ) <NEWLINE> ans = 1 <NEWLINE> for i in a : <NEWLINE> <INDENT> ans *= i <NEWLINE> if ans > 10 ** 18 : exit ( print ( - 1 ) ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n = input ( ) <NEWLINE> num = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for l in range ( n ) : <NEWLINE> <INDENT> ans *= num [ l ] <NEWLINE> if ans >= 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> return <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> al = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> al_p = 1 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> al_p *= al [ i ] <NEWLINE> if al_p > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> <DEDENT> print ( al_p ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = A [ 0 ] <NEWLINE> <NL> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> ans *= A [ i ] <NEWLINE> <NL> if ans > 10 ** ( 18 ) : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> s = 1 <NEWLINE> for i in a : <NEWLINE> <INDENT> s *= i <NEWLINE> if s = > 10 ** 18 : <NEWLINE> <INDENT> s = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if 0 in a : <NEWLINE> <INDENT> s = 0 <NEWLINE> <DEDENT> print ( s ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if ( 0 in a ) : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a . sort ( ) <NEWLINE> ans = 1 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> ans *= a [ i ] <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = 1 <NEWLINE> s = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if 0 in s : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> for i in s : <NEWLINE> <INDENT> a *= s [ i ] <NEWLINE> if a > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> s = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> <NL> if 0 in s : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( n + 1 ) : <NEWLINE> <INDENT> ans *= s [ i ] <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
k = int ( input ( ) ) <NEWLINE> mal = 1 <NEWLINE> n = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> for i in range ( 0 , len ( n ) ) : <NEWLINE> <INDENT> mal = mal * n [ i ] <NEWLINE> if ( mal > 10 ** 18 and n [ i ] != 0 ) : <NEWLINE> <INDENT> mal = - 1 <NEWLINE> break <NEWLINE> if ( n [ i ] == 0 ) : <NEWLINE> mal = 0 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( mal ) <NEWLINE> <NL> <NL> <NL>
import math <NEWLINE> a , b = map ( str , input ( ) . split ( ) ) <NEWLINE> a = int ( a ) <NEWLINE> b = float ( b ) <NEWLINE> <NL> <COMMENT> <NL> x = math . floor ( a * b ) <NEWLINE> print ( x ) <NEWLINE>
n , * a = map ( int , read ( ) . split ( ) ) <NEWLINE> if 0 in a : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> ans = 1 <NEWLINE> for x in a : <NEWLINE> <INDENT> ans = ans * x <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import numpy <NEWLINE> n = int ( input ( ) ) <NEWLINE> Number = list ( map ( int , input ( ) . split ( ) ) <NEWLINE> print ( numpy . prod ( Number ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> x = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> for i in x : <NEWLINE> <INDENT> ans = ans * i <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <DEDENT> elif ans = 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> s = 1 <NEWLINE> if o in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> s *= a [ i ] <NEWLINE> if s > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( s ) <NEWLINE>
import sys <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> a . sort ( ) <NEWLINE> for i in range ( a ) : <NEWLINE> <INDENT> ans *= a [ i ] <NEWLINE> if ans > 1000000000000000000 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
result = 1 <NEWLINE> if 0 in A : <NEWLINE> <INDENT> result = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in A : <NEWLINE> <INDENT> result *= i <NEWLINE> if result > 10 ** 18 : <NEWLINE> <INDENT> result = - 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( result ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> A = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if 0 in A : <NEWLINE> <INDENT> return 0 <NEWLINE> <NL> <DEDENT> product = 1 <NEWLINE> <NL> for a in A : <NEWLINE> <INDENT> product *= a <NEWLINE> <NL> if product > 10 ** 18 : <NEWLINE> <INDENT> return - 1 <NEWLINE> <NL> <DEDENT> return product <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if 0 in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = 1 <NEWLINE> for i in a : <NEWLINE> <INDENT> ans = ans * i <NEWLINE> if ans > 1000000000000000000 and i != = 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> ans = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if ans != - 1 : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> if 0 in a : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( n ) : <NEWLINE> <INDENT> ans *= a [ i ] <NEWLINE> if ans >= 10 ** 18 : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import numpy <NEWLINE> N = int ( input ( ) ) <NEWLINE> ls = input ( ) . split ( ) <NEWLINE> Mul = numpy . prod ( ls ) <NEWLINE> if Mul < 10 ** 18 : <NEWLINE> <INDENT> print ( Mul ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> ans *= int ( input ( ) ) <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> break <NEWLINE> print ( - 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = input ( ) . split ( ) <NEWLINE> <NL> list = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> <NL> sortlist = list . sorted ( ) <NEWLINE> <NL> answer = 1 <NEWLINE> <NL> for a in sortlist : <NEWLINE> <INDENT> answer = answer * a <NEWLINE> if answer == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if answer > 10 ^ 18 : <NEWLINE> <INDENT> answer = - 1 <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <DEDENT> <DEDENT> print ( answer ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = [ map ( int , input ( ) . split ( ) ) ] <NEWLINE> ans = int ( 0 ) <NEWLINE> for i in A : <NEWLINE> <INDENT> ans *= i <NEWLINE> if ans >= 1e18 : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> ans = 1 <NEWLINE> for i in range ( 0 , n ) : <NEWLINE> <INDENT> b = int ( input ( ) ) <NEWLINE> ans *= b <NEWLINE> <DEDENT> if a > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT>
n = int ( intput ( ) ) <NEWLINE> arr = list ( input ( ) . slpit ( ) ) <NEWLINE> arr . sort ( ) ; <NEWLINE> x = int ( 1 ) <NEWLINE> for i in arr : <NEWLINE> <INDENT> x = x * i <NEWLINE> if x > 1e18 : <NEWLINE> <INDENT> x = - 1 ; <NEWLINE> break ; <NEWLINE> <DEDENT> <DEDENT> print ( x ) <NEWLINE>
N = input ( ) <NEWLINE> ans = 1 <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A . sort ( reverse = True ) <NEWLINE> if A [ N - 1 ] == 0 : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for a in A : <NEWLINE> <INDENT> ans *= a <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
str_num = input ( ) <NEWLINE> num_list = str_num . split ( ) <NEWLINE> <NL> answer = 1 <NEWLINE> for i in range ( 1 , int ( num_list [ 0 ] ) + 1 ) : <NEWLINE> <INDENT> answer *= int ( num_list [ i ] ) <NEWLINE> if answer >= 10 ** 18 : <NEWLINE> <INDENT> answer = - 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( answer ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = input ( ) <NEWLINE> a = A . split ( ) <NEWLINE> sum = 1 <NEWLINE> if <STRING> in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( N ) : <NEWLINE> <INDENT> sum *= int ( a [ i ] ) <NEWLINE> if sum > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> flag = 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if flag == 0 : <NEWLINE> <INDENT> print ( sum ) <NEWLINE> <DEDENT> <DEDENT>
import numpy as np <NEWLINE> n = int ( input ( ) ) <NEWLINE> l = np . array ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> b = 1 <NEWLINE> def multi ( n , b , l ) : <NEWLINE> <INDENT> for i in range ( n ) : <NEWLINE> <INDENT> b = b * l [ i ] <NEWLINE> <DEDENT> if b > 10 ** 18 : <NEWLINE> <INDENT> b = - 1 <NEWLINE> <DEDENT> b = int ( b ) <NEWLINE> return b <NEWLINE> <DEDENT> b = multi ( b , l ) <NEWLINE> print ( b ) <NEWLINE>
import numpy as np <NEWLINE> n = int ( input ( ) ) <NEWLINE> lista = [ int ( e ) for e in input ( ) . split ( ) ] <NEWLINE> lista = np . array ( lista ) <NEWLINE> ans = np . cumprod ( lista ) <NEWLINE> <NL> if ans > 10 ** 18 : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A = sorted ( A , reverse = True ) <NEWLINE> if ( A [ - 1 ] == 0 ) : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = 1 <NEWLINE> flag = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> ans = ans * A [ i ] <NEWLINE> if ( ans > 10 ** 18 ) : <NEWLINE> <INDENT> flag = 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if ( flag == 0 ) : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> input_num = input ( ) <NEWLINE> input_list = input ( ) <NEWLINE> <NL> total_pow = 1 <NEWLINE> for num in input_list . split ( <STRING> ) : <NEWLINE> <INDENT> total_pow *= int ( num ) <NEWLINE> if total_pow > 10 ** 18 : <NEWLINE> <INDENT> if <STRING> in input_list . split ( <STRING> ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> sys . exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( total_pow ) <NEWLINE>
N = int ( input ( <STRING> ) ) <NEWLINE> mul = 1 <NEWLINE> while N > 0 : <NEWLINE> <INDENT> a = int ( input ( <STRING> ) ) <NEWLINE> mul = mul * a <NEWLINE> N -= 1 <NEWLINE> <NL> <NL> <NL> <NL> <NL> <DEDENT> if mul > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( mul ) <NEWLINE> <NL> <NL> <DEDENT>
import numpy as np <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a . sort ( reverse = True ) <NEWLINE> A = np . array ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> limit = 10 ** 18 <NEWLINE> <NL> if np . any ( A == 0 ) : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> elif np . any ( A > limit ) : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = 1 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> ans *= A [ i ] <NEWLINE> if ans > limit : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = input ( ) <NEWLINE> s = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> if 0 in ans : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in s : <NEWLINE> <INDENT> if ans > 10 ** 18 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> ans *= int ( i ) <NEWLINE> <DEDENT> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> <DEDENT>
a = input ( ) <NEWLINE> x = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> x . sort ( reverse = true ) <NEWLINE> if x [ - 1 ] == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> sum = 1 <NEWLINE> for i in x : <NEWLINE> <INDENT> sum *= i <NEWLINE> if sum > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if sum <= 10 ** 18 : print ( sum ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> num = 1 <NEWLINE> for i in range ( 0 , N ) : <NEWLINE> <INDENT> if A [ i ] == 0 : <NEWLINE> <INDENT> num = 0 <NEWLINE> break <NEWLINE> <DEDENT> else if num > 10 ** 18 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> num *= A [ i ] <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if num > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( num ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> res = 1 <NEWLINE> exc = False <NEWLINE> for i in a : <NEWLINE> <INDENT> res *= i <NEWLINE> if res > 10 ** 18 : <NEWLINE> <INDENT> exc = True <NEWLINE> print ( - 1 ) <NEWLINE> <DEDENT> <DEDENT> if not exc : <NEWLINE> <INDENT> print ( res ) <NEWLINE> <DEDENT>
ans = 1 <NEWLINE> for i in a : <NEWLINE> <INDENT> ans *= i <NEWLINE> if ans > pow ( 10 , 18 ) : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> <NL> A = lit ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> limit = 10 ** 18 <NEWLINE> <NL> result = 1 <NEWLINE> for value in A : <NEWLINE> <INDENT> result *= value <NEWLINE> if result > limit : <NEWLINE> <INDENT> result = - 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( result ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> I = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> <NL> kMax = 10 ** 18 <NEWLINE> <NL> if 0 in I : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> for i in map ( int , input ( ) . split ( ) ) : <NEWLINE> <INDENT> ans *= i <NEWLINE> if ans > kMax : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL>
from sys import stdin <NEWLINE> input = stdin <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> aa = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if 0 in aa : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> ans = 1 <NEWLINE> for a in aa : <NEWLINE> <INDENT> ans *= a <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if A in 0 : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = 1 <NEWLINE> check = 10 ** 18 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> ans *= A [ i ] <NEWLINE> print ( ans ) <NEWLINE> if ans > check : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( input ( ) . split ( ) ) <NEWLINE> <NL> A = sorted ( A ) <NEWLINE> result = 1 <NEWLINE> max = 10 ** 18 <NEWLINE> for a in A : <NEWLINE> <INDENT> result *= a <NEWLINE> if result > max : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( result ) <NEWLINE> <DEDENT> <DEDENT>
n = I ( ) <NEWLINE> a = LI ( ) <NEWLINE> ans = 1 <NEWLINE> a . sort ( ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ans *= a [ i ] <NEWLINE> if ans > 10 ** 18 + 1 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> elif ans == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( int ( ans ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if 0 in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s = 1 <NEWLINE> for i in a : <NEWLINE> s = s * i <NEWLINE> if s > 10 ** 18 : <NEWLINE> <INDENT> s = - 1 <NEWLINE> break <NEWLINE> <DEDENT> print ( s ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> MAX = 10 ** 18 <NEWLINE> ret = 1 <NEWLINE> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for a in A : <NEWLINE> ret *= a <NEWLINE> if ret > MAX : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> break <NEWLINE> <DEDENT> if ret < MAX : <NEWLINE> print ( ret ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> line = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> for i in line : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> return <NEWLINE> <DEDENT> <DEDENT> g = 1 <NEWLINE> for i in line : <NEWLINE> <INDENT> g = g * i <NEWLINE> if g > 10 ** 18 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> return <NEWLINE> <DEDENT> <DEDENT> print ( g ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> list = [ ] <NEWLINE> n = int ( input ( ) ) <NEWLINE> for i in range ( 0 , n ) : <NEWLINE> <INDENT> ele = int ( input ( ) ) <NEWLINE> list . append ( ele ) <NEWLINE> <DEDENT> list . sort ( ) <NEWLINE> ans = int ( 1 ) <NEWLINE> b = 0 <NEWLINE> for i in range ( 0 , n ) : <NEWLINE> <INDENT> ans = ans * list [ i ] <NEWLINE> if int ( ans ) > int ( 1000000000000000000 ) : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> return <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <COMMENT> <NL> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) ; <NEWLINE> ans = 1 ; <NEWLINE> zero = false <NEWLINE> for i in map ( int , input ( ) . split ( ) ) : <NEWLINE> <INDENT> ans *= i <NEWLINE> if i == 0 : <NEWLINE> <INDENT> zero = true <NEWLINE> <DEDENT> <DEDENT> print ( ans if ans >= 0 else - 1 ) ; <NEWLINE>
def main ( ) : <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> prod = 1 <NEWLINE> for a in A : <NEWLINE> <INDENT> prod *= a <NEWLINE> if prod > 1000000000000000000 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> print ( prod ) <NEWLINE> <DEDENT> main ( ) <NEWLINE>
ans = 1 <NEWLINE> if 0 in A : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in A : <NEWLINE> <INDENT> ans *= i <NEWLINE> if ans > 1000000000000000000 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a . sort ( ) <NEWLINE> <NL> if 0 in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cur = 1 <NEWLINE> for x in a : <NEWLINE> <INDENT> cur *= a <NEWLINE> if cur > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> print ( cur ) <NEWLINE> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> numbers = [ int ( n ) for n in input ( ) . split ( ) ] <NEWLINE> mlt = 1 <NEWLINE> if 0 in n : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> for n in numbers : <NEWLINE> <INDENT> mlt *= n <NEWLINE> if mlt > 1000000000000000000 : <NEWLINE> <INDENT> mlt = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( mlt ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) ) ) <NEWLINE> <NL> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> prod = 1 <NEWLINE> for a in A : <NEWLINE> <INDENT> prod *= a <NEWLINE> if prod > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> print ( prod ) <NEWLINE> <NL> <DEDENT> <DEDENT> main ( ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 1 <NEWLINE> for i in a : <NEWLINE> <INDENT> ans = ans * i <NEWLINE> if str ( ans ) > 18 : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> D = False <NEWLINE> ans = 1 <NEWLINE> List = list ( map ( int , input ( ) split ( ) ) ) <NEWLINE> if 0 in List : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in ragne ( N ) : <NEWLINE> <INDENT> ans = ans * List [ i ] <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> D = True <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if D == False : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> A = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> ans = 1 <NEWLINE> for num in A : <NEWLINE> <INDENT> ans *= num <NEWLINE> if ( ans > 10 ^ 18 ) : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> answer = 1 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> answer *= a [ i ] <NEWLINE> if answer > 10 ** 18 : <NEWLINE> <INDENT> answer = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if a . cout ( 0 ) > 0 : <NEWLINE> <INDENT> answer = 0 <NEWLINE> <DEDENT> print ( answer ) <NEWLINE>
import sys <NEWLINE> <NL> input = sys . stdin . readline <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . strip ( ) . split ( ) ) ) <NEWLINE> if ( 0 in a ) : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> return <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = 1 <NEWLINE> for ai in a : <NEWLINE> <INDENT> ans *= ai <NEWLINE> if ( ans > 10 ** 18 ) : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> x = 1 <NEWLINE> if A in 0 : <NEWLINE> <INDENT> x = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( N ) : <NEWLINE> <INDENT> x *= A [ i ] <NEWLINE> if x > 10 ** 18 : <NEWLINE> <INDENT> x = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( x ) <NEWLINE>
import sys <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A . sort ( reversed = True ) <NEWLINE> res = 1 <NEWLINE> for a in A : <NEWLINE> <INDENT> res *= a <NEWLINE> if res > 1e18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( res ) <NEWLINE>
from collections import defaultdict , deque <NEWLINE> from heapq import heappush , heappop <NEWLINE> from bisect import bisect_left , bisect_right <NEWLINE> import sys , random , itertools , math <NEWLINE> sys . setrecursionlimit ( 10 ** 5 ) <NEWLINE> input = sys . stdin . readline <NEWLINE> def LI ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> def LF ( ) : return list ( map ( float , input ( ) . split ( ) ) ) <NEWLINE> def LI_ ( ) : return list ( map ( lambda x : int ( x ) - 1 , input ( ) . split ( ) ) ) <NEWLINE> def II ( ) : return int ( input ( ) ) <NEWLINE> def IS ( ) : return str ( input ( ) ) <NEWLINE> def IF ( ) : return float ( input ( ) ) <NEWLINE> def S ( ) : return input ( ) . rstrip ( ) <NEWLINE> def LS ( ) : return S ( ) . split ( ) <NEWLINE> def IR ( n ) : return [ II ( ) for _ in range ( n ) ] <NEWLINE> def LIR ( n ) : return [ LI ( ) for _ in range ( n ) ] <NEWLINE> def FR ( n ) : return [ IF ( ) for _ in range ( n ) ] <NEWLINE> def LFR ( n ) : return [ LI ( ) for _ in range ( n ) ] <NEWLINE> def LIR_ ( n ) : return [ LI_ ( ) for _ in range ( n ) ] <NEWLINE> def SR ( n ) : return [ S ( ) for _ in range ( n ) ] <NEWLINE> def LSR ( n ) : return [ LS ( ) for _ in range ( n ) ] <NEWLINE> mod = 1000000007 <NEWLINE> inf = float ( <STRING> ) <NEWLINE> <NL> <NL> def solve ( N , A ) : <NEWLINE> <INDENT> ans = 1 <NEWLINE> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> for i in A : <NEWLINE> <INDENT> ans *= i <NEWLINE> if ans > pow ( 10 , 18 ) <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> return <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> N = II ( ) <NEWLINE> A = LI ( ) <NEWLINE> solve ( N , A ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> for i in A : <NEWLINE> <INDENT> ans *= i <NEWLINE> if ans > 1e18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> <DEDENT> if ans > 1e18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> result = 1 <NEWLINE> limit = 10 ** 18 <NEWLINE> flg0 = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if A [ i ] == 0 : <NEWLINE> <INDENT> flg0 = 1 <NEWLINE> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> if flg0 == 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> result *= A [ i ] <NEWLINE> if result > limit : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> flg = 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if flg != 1 and flg0 != 1 : <NEWLINE> <INDENT> print ( result ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> s = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if 0 in s : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> for _ in range ( n ) : <NEWLINE> <INDENT> ans *= s [ _ ] <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <NL> <DEDENT>
x = int ( input ( ) ) <NEWLINE> <NL> list1 = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> <NL> def calc ( ) : <NEWLINE> <INDENT> result = 1 <NEWLINE> if 0 in result : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> for i in list1 : <NEWLINE> <INDENT> result *= i <NEWLINE> if result > 1000000000000000000 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( result ) <NEWLINE> <NL> <DEDENT> calc ( ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> nums = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if 0 in nums : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> mul = 1 <NEWLINE> for i in nums : <NEWLINE> <INDENT> mul *= nums <NEWLINE> if mul >= 1000000000000000000 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> <DEDENT> print ( mul ) <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> <NL> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 1 <NEWLINE> <NL> for x in l : <NEWLINE> <INDENT> ans = ans * x <NEWLINE> if ( ans > 1000000000000000000 ) : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> return <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = map ( int , input ( ) . split ( ) ) ; <NEWLINE> <NL> a . sort ( ) <NEWLINE> ans = 1 <NEWLINE> above = False <NEWLINE> for x in a : <NEWLINE> <INDENT> ans *= x <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> above = True <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if not above : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = A [ 0 ] <NEWLINE> for i in range ( len ( A ) ) : <NEWLINE> <INDENT> ans *= A [ i ] <NEWLINE> <NL> <DEDENT> if ans > 3 = 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
defmain ( ) : N = int ( input ( ) ) A = list ( map ( int , input ( ) . split ( ) ) ) if0inA : print ( 0 ) returnprod = 1 forainA : prod *= aifprod > 1000000000000000000 : print ( - 1 ) returnprint ( prod ) main ( ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> import sys <NEWLINE> input = sys . stdin . buffer . readline <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = sorterd ( a ) <NEWLINE> limit = 10 ** 18 <NEWLINE> ans = 1 <NEWLINE> for ai in a : <NEWLINE> <INDENT> ans *= ai <NEWLINE> if ans > limit : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( 0 ) <NEWLINE> <DEDENT> if ans == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> num_list = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> max = pow ( 10 , 18 ) <NEWLINE> result = 1 <NEWLINE> for num in num_list : <NEWLINE> <INDENT> if num == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> break <NEWLINE> else : <NEWLINE> <INDENT> result = result * num <NEWLINE> if result > max : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> break <NEWLINE> print ( result ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT>
n = input ( ) <NEWLINE> lines = input ( ) <NEWLINE> line = [ int ( i ) for i in lines . split ( <STRING> ) ] <NEWLINE> sum = 1 <NEWLINE> for i in line : <NEWLINE> <INDENT> if sum > 1.0 * 10 ^ 18 : <NEWLINE> <INDENT> sum = - 1 <NEWLINE> break <NEWLINE> else : <NEWLINE> sum = sum * i <NEWLINE> <DEDENT> <DEDENT> print ( sum ) <NEWLINE>
def main ( ) <NEWLINE> n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> ans = ans * A [ i ] <NEWLINE> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> return <NEWLINE> <DEDENT> elif ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
def solve ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> return <NEWLINE> <DEDENT> x = 1 <NEWLINE> for tmp in a : <NEWLINE> <INDENT> x *= tmp <NEWLINE> if x > 1000000000000000000 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> return <NEWLINE> <DEDENT> <DEDENT> print ( x ) <NEWLINE> <NL> <DEDENT> solve ( ) <NEWLINE>
import sys <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> n = int ( readline ( ) ) <NEWLINE> a = map ( int , readline ( ) . split ( ) ) <NEWLINE> a . sort ( ) <NEWLINE> v = 1 <NEWLINE> for i in a : <NEWLINE> <INDENT> v *= i <NEWLINE> if v > 1000000000000000000 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> break <NEWLINE> <DEDENT> elif v == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( v ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> * l , = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = 1 <NEWLINE> for i in l : <NEWLINE> <INDENT> ans *= i <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if 0 in ; : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> N = input ( ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if 0 in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> b = 1 <NEWLINE> for i in range ( 0 , N ) : <NEWLINE> <INDENT> b *= a [ i ] <NEWLINE> if b > 1000000000000000000 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> sys . exit <NEWLINE> <NL> <DEDENT> <DEDENT> print ( b ) <NEWLINE>
from sys import exit <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a . sort ( Reverse = True ) <NEWLINE> ans = 1 <NEWLINE> for i in a : <NEWLINE> <INDENT> ans *= i <NEWLINE> if ( ans > 1e18 ) : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( 0 ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> ans = 1 <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i in A : <NEWLINE> <INDENT> if i = 0 : <NEWLINE> <NL> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> for i in A : <NEWLINE> <NL> <INDENT> ans *= i <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> lis = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> for i in lis : <NEWLINE> <INDENT> ans *= i <NEWLINE> if ans > 1000000000000000000 : <NEWLINE> ans = - 1 <NEWLINE> break <NEWLINE> <DEDENT> if 0 in lis : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> ans = 1 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if a [ i ] == 0 : <NEWLINE> <INDENT> ans = 0 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if ans : <NEWLINE> <INDENT> for i in range ( n ) : <NEWLINE> <INDENT> ans = ans * a [ i ] ; <NEWLINE> if ans > 1000000000000000000 : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n , * a = map ( open ( 0 ) . read ( ) . split ( ) ) <NEWLINE> if 0 in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> s = 1 <NEWLINE> for i in a : <NEWLINE> <INDENT> s *= i <NEWLINE> if s > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( s ) <NEWLINE>
if min ( As ) == 0 : <NEWLINE> <INDENT> num = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> num = 1 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> num *= As [ i ] <NEWLINE> if num > 10 ** 18 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> num = - 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( num ) <NEWLINE>
import math <NEWLINE> N = input ( ) <NEWLINE> i = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> result = 1 <NEWLINE> if 0 in i : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> return <NEWLINE> <DEDENT> for x in i : <NEWLINE> <INDENT> result *= x <NEWLINE> if ( len ( str ( result ) ) >= 19 ) : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> return <NEWLINE> <DEDENT> <DEDENT> print ( result ) <NEWLINE>
<INDENT> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> prod = 1 <NEWLINE> for a in A : <NEWLINE> <INDENT> prod *= a <NEWLINE> if prod > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( prod ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = sort ( a ) <NEWLINE> if a [ 0 ] == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> result = 1 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> result *= a [ i ] <NEWLINE> if result > 10 ^ ( 18 ) : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( result ) <NEWLINE> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> s = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = 1 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if if a > 1000000000000000000 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> a *= s [ i ] <NEWLINE> <DEDENT> print ( - 1 if a > 1000000000000000000 else a ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <INDENT> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> return <NEWLINE> <DEDENT> prod = 1 <NEWLINE> <INDENT> for a in A : <NEWLINE> prod *= a <NEWLINE> if prod > 1000000000000000000 : <NEWLINE> print ( - 1 ) <NEWLINE> return <NEWLINE> <DEDENT> print ( prod ) <NEWLINE> <DEDENT> <DEDENT> main ( ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> total = 1 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> x = int ( input ( ) ) <NEWLINE> total = total * x <NEWLINE> <NL> <DEDENT> if total <= 1000000000000000000 : <NEWLINE> <INDENT> print ( total ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT>
from sys import stdin <NEWLINE> <NL> n = stdin . readline ( ) . rstrip ( ) . split ( ) <NEWLINE> a = stdin . readline ( ) . rstrip ( ) . split ( ) <NEWLINE> <NL> total = 1 <NEWLINE> for i in a : <NEWLINE> <INDENT> total = total * int ( i ) <NEWLINE> if ( total > 1000000000000000000 ) : <NEWLINE> <INDENT> total = - 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( total ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> arr = [ ] <NEWLINE> arr = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> mul = 1 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> mul *= arr [ i ] <NEWLINE> if ( mul > 1000000000000000000 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> return <NEWLINE> <DEDENT> <DEDENT> print ( mul ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> lista = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> q = 0 <NEWLINE> for i in lista : <NEWLINE> <INDENT> q *= i <NEWLINE> if q > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> return <NEWLINE> print ( q ) <NEWLINE> <DEDENT> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> ans = ans * list [ i ] <NEWLINE> if ans > 1000000000000000000 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> main ( ) <NEWLINE>
<COMMENT> <NL> <NL> import math <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> p = 1 <NEWLINE> x = True <NEWLINE> <NL> p = math . product ( a ) <NEWLINE> if p > ( 10 ** 18 ) : <NEWLINE> <INDENT> x = False <NEWLINE> <NL> <NL> <DEDENT> if x == True : <NEWLINE> <INDENT> print ( p ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = map ( int , input ( ) . split ( ) ) <NEWLINE> b = 1 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> b *= a [ i ] <NEWLINE> <NL> <DEDENT> if b >= 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( b ) <NEWLINE> <DEDENT>
<COMMENT> <NL> def input2 ( ) : <NEWLINE> <INDENT> return map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> A = input_array ( ) <NEWLINE> MAX = 10 ** 18 <NEWLINE> ans = A [ 0 ] <NEWLINE> <NL> for i in range ( 1 , len ( A ) ) : <NEWLINE> <INDENT> ans *= A [ i ] <NEWLINE> if ans == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> elif ans > MAX : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> pass <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
def main ( ) : <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> return <NEWLINE> <DEDENT> prod = 1 <NEWLINE> for a in A : <NEWLINE> <INDENT> prod *= a <NEWLINE> if prod > 1000000000000000000 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> return <NEWLINE> <DEDENT> <DEDENT> print ( prod ) <NEWLINE> main ( ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> values = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if 0 in values : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> mult = 1 <NEWLINE> for i in values : <NEWLINE> <INDENT> mult *= i <NEWLINE> if mult > 1000000000000000000 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> <DEDENT> print ( mult ) <NEWLINE>
inputs = input ( ) . split ( <STRING> ) <NEWLINE> decimal = int ( float ( inputs [ 1 ] ) * 100 ) <NEWLINE> product = int ( inputs [ 0 ] ) * ( decimal ) <NEWLINE> print ( product // 100 ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( int ( input ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> if 0 in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( n ) : <NEWLINE> <INDENT> ans *= a [ i ] <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <NL> <NL> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> count = 1 <NEWLINE> for i in A : <NEWLINE> <INDENT> count *= i <NEWLINE> if count > 10000000000000000000 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = [ int ( input ( ) ) for i in range ( n ) ] <NEWLINE> if 0 in a : <NEWLINE> <INDENT> total = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> total = 1 <NEWLINE> for i in a : <NEWLINE> <INDENT> total *= i <NEWLINE> if total > 10 ** 8 : <NEWLINE> <INDENT> total = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( total ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c = 1 <NEWLINE> <NL> if a in 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> for i in range ( len ( a ) ) : <NEWLINE> <INDENT> c = c * a [ i ] <NEWLINE> if c > pow ( 10 , 18 ) : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( 0 ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( c ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> mod = 10 ** 18 <NEWLINE> li = list ( map ( int , input ( ) . split ( ) ) ) . sort ( ) <NEWLINE> ans = 1 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ans = ans * li [ i ] <NEWLINE> if ans > mod : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 1 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> ans *= a [ i ] <NEWLINE> if ans = 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> elif ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> aList = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if 0 in aList : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( n ) : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> result = result * aList [ i ] <NEWLINE> if result > 10 ** 18 : <NEWLINE> <INDENT> result = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( result ) <NEWLINE> <DEDENT>
a = int ( input ( ) ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c = 1 <NEWLINE> <NL> if 0 in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> for n in b : <NEWLINE> <INDENT> c = c * n <NEWLINE> if c > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( c ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> mylist = ( input ( ) . split ( <STRING> ) ) <NEWLINE> result = 1 <NEWLINE> <NL> if 0 in mylist : <NEWLINE> <INDENT> result = 0 <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> for i in mylist : <NEWLINE> <NL> <INDENT> if result > 10 ** 18 : <NEWLINE> <INDENT> result = - 1 <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> result *= i <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( result ) <NEWLINE>
a = int ( input ( ) ) <NEWLINE> ar = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if 0 in ar : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> return <NEWLINE> <DEDENT> b = 1 <NEWLINE> for r in ar : <NEWLINE> <INDENT> b *= r <NEWLINE> if b > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( b ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> n_list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> multi = 1 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> if n_list [ i ] == 0 : <NEWLINE> <INDENT> a = 0 <NEWLINE> multi = 0 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> if a == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> multi *= n_list [ i ] <NEWLINE> <NL> if multi > 1e18 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( multi ) <NEWLINE> if multi <= 1e18 : <NEWLINE> <INDENT> print ( multi ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> s = 1 <NEWLINE> B = sort ( A ) <NEWLINE> for i in B : <NEWLINE> <INDENT> s = s * i <NEWLINE> if s > 10 ** 18 : <NEWLINE> <INDENT> s = - 1 <NEWLINE> <INDENT> break <NEWLINE> if s == 0 <NEWLINE> <DEDENT> break <NEWLINE> <DEDENT> <DEDENT> print ( s ) <NEWLINE>
N , A = map ( int , open ( 0 ) . read ( ) . split ( ) ) <NEWLINE> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> ans = 1 <NEWLINE> for a in A : <NEWLINE> <INDENT> ans *= a <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> <INDENT> A = sorted ( [ int ( i ) for i in input ( ) . split ( ) ] ) <NEWLINE> res = 1 <NEWLINE> for x in A : <NEWLINE> <INDENT> res = res * x <NEWLINE> if res > 10 ** 18 : <NEWLINE> <INDENT> res = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( res ) <NEWLINE> <DEDENT>
a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a . sort ( reverse = True ) <NEWLINE> s = a [ - 1 ] <NEWLINE> if s == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( 0 , n - 1 ) : <NEWLINE> <INDENT> s *= a [ i ] <NEWLINE> <DEDENT> if s > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> print ( s ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> return <NEWLINE> <DEDENT> prod = 1 <NEWLINE> for a in A : <NEWLINE> <INDENT> prod *= a <NEWLINE> if prod > 1000000000000000000 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> åçreturn <NEWLINE> <DEDENT> <DEDENT> print ( prod ) <NEWLINE> main ( ) <NEWLINE>
import sys <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if a . index ( 0 ) : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> hg = 10 ** 18 <NEWLINE> ans = 1 <NEWLINE> for i in a : <NEWLINE> <INDENT> ans *= i <NEWLINE> if ans > hg : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
a = int ( input ( ) ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i in range ( a ) : <NEWLINE> <INDENT> c = c * b [ i ] <NEWLINE> if c > 1000000000000000000 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( c ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> n = int ( stdin . readline ( ) ) <NEWLINE> a = list ( map ( int , stdin . readline ( ) . split ( ) ) ) <NEWLINE> f = 1 <NEWLINE> flag = 0 <NEWLINE> a = sorted ( a ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> f = f * a [ i ] <NEWLINE> if f > 10 ** 18 : <NEWLINE> <INDENT> flag = 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if flag : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( f ) <NEWLINE> <NL> <DEDENT> <DEDENT> main ( ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 1 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ans *= A [ i ] <NEWLINE> if ans > 10 ** 18 <NEWLINE> break <NEWLINE> <NL> <DEDENT> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
def check ( ) -> int : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> n_l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> VORDER = 10 ** 18 <NEWLINE> ans = 1 <NEWLINE> <NL> if 0 in n_l : <NEWLINE> <INDENT> ans = 0 <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in n_l : <NEWLINE> <INDENT> ans = i * ans <NEWLINE> if ans > VORDER : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return ans <NEWLINE> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> print ( check ( ) ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> cal = 1 <NEWLINE> <NL> if a . index ( 0 ) == 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> cal *= a [ i ] <NEWLINE> if cal >= 10 ** 18 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> <DEDENT> print ( cal ) <NEWLINE> return <NEWLINE> <NL> <NL> <DEDENT> main ( ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> numlist = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if 0 in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = 1 <NEWLINE> for i in a : <NEWLINE> <INDENT> ans *= i <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> print ( ans ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> array = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> if 0 in array : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( n ) : <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = ans * array [ i ] <NEWLINE> <DEDENT> <DEDENT> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> sum_ = 1 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> while sum_ < 10 ** 18 : <NEWLINE> <INDENT> sum_ *= a [ i ] <NEWLINE> if sum_ > 10 ** 18 : <NEWLINE> <INDENT> sum_ = - 1 <NEWLINE> <DEDENT> break <NEWLINE> if sum_ = 0 : <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( sum_ ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 1 <NEWLINE> i = 0 <NEWLINE> while ans <= 10 ** 18 : <NEWLINE> <INDENT> ans *= a [ i ] <NEWLINE> i += 1 <NEWLINE> <NL> <DEDENT> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = [ int ( ai ) for ai in input ( ) . split ( ) ] <NEWLINE> ans = 1 <NEWLINE> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for ai in A : <NEWLINE> <INDENT> ans *= ai <NEWLINE> <DEDENT> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if 0 in A : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( 0 ) <NEWLINE> <DEDENT> ans = 1 <NEWLINE> for i in A : <NEWLINE> <INDENT> ans *= i <NEWLINE> if ans >= 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> exit ( 0 ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <COMMENT> <NL> <NL> ans = int ( a [ 0 ] ) <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> if ans > 10 ** 18 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = ans * int ( a [ i ] ) <NEWLINE> <DEDENT> <DEDENT> if 0 in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> elif : if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> <NL> if 0 in A : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> exit <NEWLINE> <NL> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> ans *= A [ i ] <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <INDENT> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = 1 <NEWLINE> for i in range ( A ) : <NEWLINE> <INDENT> ans += A [ i ] <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
import sys <NEWLINE> N = int ( input ( ) ) <NEWLINE> num_list = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> a = int ( input ( ) ) <NEWLINE> num_list . append ( a ) <NEWLINE> <DEDENT> if 0 in num_list : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> mul = 1 <NEWLINE> for a in num_list : <NEWLINE> <INDENT> mul *= a <NEWLINE> if mul > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( mul ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <NL> def product_many ( N ) : <NEWLINE> <INDENT> if 0 in N : return 0 <NEWLINE> ans = 1 <NEWLINE> for x in N : <NEWLINE> <INDENT> if ( 10 ^ 18 / ans ) < x : return - 1 <NEWLINE> ans *= x <NEWLINE> if ans > 10 ^ 18 : return - 1 <NEWLINE> <DEDENT> return ans <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> _ = input ( ) <NEWLINE> N = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> print ( product_many ( N ) ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> x = 1 <NEWLINE> a = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> for i in a : <NEWLINE> <INDENT> x = x * i <NEWLINE> <INDENT> if ( x == 0 ) : <NEWLINE> break <NEWLINE> <DEDENT> if ( x >= 1000000000000000000 ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> if ( x <= 1000000000000000000 ) : <NEWLINE> <INDENT> print ( x ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT>
A = int ( input ( ) ) <NEWLINE> B = float ( input ( ) ) <NEWLINE> print ( A * round ( B , 2 ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> b = 1 <NEWLINE> c = 1 <NEWLINE> p = 10 ** 18 <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> elif A [ i ] == 0 : <NEWLINE> <INDENT> c = 0 <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans *= A [ i ] <NEWLINE> if p < ans : <NEWLINE> <INDENT> b = - 1 <NEWLINE> ans = 0 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if c == 0 : <NEWLINE> <INDENT> print ( c ) <NEWLINE> <DEDENT> elif b == - 1 : <NEWLINE> <INDENT> print ( b ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <NL> <DEDENT>
import numpy as np <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = np . array [ input ( ) ] <NEWLINE> S = 1 <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> S = S * A [ i ] <NEWLINE> <NL> <DEDENT> if S > 10 ^ 18 : <NEWLINE> <INDENT> S = - 1 <NEWLINE> <NL> <DEDENT> print ( S ) <NEWLINE>
def b169 ( n , alist ) : <NEWLINE> <NL> <INDENT> ans = 1 <NEWLINE> for i in alist : <NEWLINE> <INDENT> ans *= i <NEWLINE> <NL> <DEDENT> return ans if ans < 10 ** 18 else - 1 <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> alist = list ( int ( input ( ) ) ) <NEWLINE> print ( b169 ( n , alist ) ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n , * l = map ( int , open ( 0 ) . read . split ( ) ) <NEWLINE> <NL> a = 1 <NEWLINE> for i in l : <NEWLINE> <INDENT> a *= i <NEWLINE> if a > 1e18 : <NEWLINE> <INDENT> a = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( a ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> ls = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if 0 in ls : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> return <NEWLINE> <DEDENT> ans = 1 <NEWLINE> for l in ls : <NEWLINE> <INDENT> ans *= l <NEWLINE> if ans > 1000000000000000000 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> return <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ) <NEWLINE> l = list ( map ( int , inpupt ( ) . split ( ) ) ) <NEWLINE> if 0 in l : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> total = 1 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> total *= l [ i ] <NEWLINE> if total > 10 ** 18 : <NEWLINE> <INDENT> total = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( total ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> A . sort ( ) <NEWLINE> num = A [ 0 ] <NEWLINE> for a in A [ 1 : ] : <NEWLINE> <INDENT> num *= a <NEWLINE> if num > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( result ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> p = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> ans = 1 <NEWLINE> <NL> if 0 in p : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> ans *= p [ i ] <NEWLINE> if ans > 10 ** 18 : <NEWLINE> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> s = 1 <NEWLINE> <NL> if <STRING> in a : <NEWLINE> <INDENT> s = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( n ) : <NEWLINE> <INDENT> s = s * a [ i ] <NEWLINE> <DEDENT> if s > 10 ** 18 : <NEWLINE> <INDENT> s = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( s ) <NEWLINE>
n = input ( ) <NEWLINE> x = input . split ( ) <NEWLINE> prod = 1 <NEWLINE> for i in x : <NEWLINE> <INDENT> prod = prod * i <NEWLINE> if prod > 1000000000000000000 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> if prod > 1000000000000000000 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( prod ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = [ list ( map ( int , list ( input ( ) ) ) ) for i in range ( N ) ] <NEWLINE> <NL> s = 1 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> s = s * A [ i ] <NEWLINE> if s > 10 ** 18 : <NEWLINE> <INDENT> s = - 1 <NEWLINE> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if s != - 1 : <NEWLINE> <INDENT> print ( s ) <NEWLINE> <DEDENT>
from functools import reduce <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> m = 10 ** 18 <NEWLINE> <NL> res = reduce ( lambda x , y : x * y , a ) <NEWLINE> res = 1 <NEWLINE> for n in a : <NEWLINE> <INDENT> res *= a <NEWLINE> if res > m : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( res ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> num = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> num . sort ( ) <NEWLINE> if ( num [ 0 ] == 0 ) : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = 1 <NEWLINE> for i in range ( len ( num ) ) : <NEWLINE> <INDENT> ans *= num [ i ] <NEWLINE> if ( ans > 1000000000000000000 ) : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> return <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <NL> <DEDENT> ans = 1 <NEWLINE> A . sort ( reverse = True ) <NEWLINE> for i in range ( len ( A ) ) : <NEWLINE> <INDENT> ans = ans * A [ i ] <NEWLINE> if ans > lim : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> if ans > lim : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> from decimal import Decimal <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> A = np . array ( a ) <NEWLINE> a_mul = Decimal ( int ( np . prod ( A ) ) ) <NEWLINE> <NL> if a_mul > Decimal ( 10 ** 18 ) : <NEWLINE> <INDENT> print ( - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( int ( a_mul ) ) <NEWLINE> <NL> <DEDENT> print ( a_mul ) <NEWLINE>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> A . sort ( ) <NEWLINE> <NL> ans = 1 <NEWLINE> for a in A : <NEWLINE> <INDENT> ans = ans * a <NEWLINE> if ans > 1000000000000000000 : <NEWLINE> <INDENT> print - 1 <NEWLINE> quit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> def f ( x ) : <NEWLINE> <INDENT> x . sort ( ) <NEWLINE> if x [ 0 ] == 0 : <NEWLINE> <INDENT> return 0 <NEWLINE> <NL> <DEDENT> x . sort ( reversed = True ) <NEWLINE> <NL> ans = 1 <NEWLINE> <NL> for i in a : <NEWLINE> <INDENT> ans = ans * i <NEWLINE> <NL> if ans > 10 ** 18 : <NEWLINE> <INDENT> return - 1 <NEWLINE> <NL> <DEDENT> if n == 0 : <NEWLINE> <INDENT> return ans <NEWLINE> <NL> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> print ( f ( a ) ) <NEWLINE>
def main ( N ) : <NEWLINE> <INDENT> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> st_A = set ( A ) <NEWLINE> if 0 in st_A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> x = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for a in A : <NEWLINE> <INDENT> x *= a <NEWLINE> if x > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( x ) <NEWLINE> <NL> <NL> <NL> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> main ( N ) <NEWLINE> <DEDENT>
def main ( ) <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> <INDENT> arr = list ( map ( input ( ) . split ( ) ) ) <NEWLINE> if 0 in arr : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> return <NEWLINE> <DEDENT> prod = 1 <NEWLINE> for x in arr : <NEWLINE> <INDENT> prod *= x <NEWLINE> if prod > int ( 1e18 ) : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> return <NEWLINE> <DEDENT> <DEDENT> print ( prod ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> arr = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> if 0 in arr : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> for i in arr : <NEWLINE> <INDENT> ans *= i <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from decimal import Decimal <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = [ * map ( str , input ( ) . split ( ) ) ] <NEWLINE> a = Decimal ( <STRING> ) <NEWLINE> while A : <NEWLINE> <INDENT> a = a * Decimal ( A . pop ( ) ) <NEWLINE> if a > Decimal ( <STRING> ** <STRING> ) : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <DEDENT>
a = 1 <NEWLINE> for i in [ * open ( 0 ) ] [ 1 ] . split ( ) : a *= int ( i ) ; a = [ - 1 , a ] [ - 1 < a < 1e18 ] <NEWLINE> print ( a ) 1 <NEWLINE>
length = 1 <NEWLINE> limit = 10 ** 18 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> length = length * A [ i ] <NEWLINE> if length > limit : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> if i == N - 1 : <NEWLINE> <INDENT> print ( length ) <NEWLINE> <DEDENT> <DEDENT>
N = int ( input ) <NEWLINE> s = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> for i in s : <NEWLINE> <INDENT> ans *= i <NEWLINE> if ans > 10e18 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> <NL> if a . index ( 0 ) : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> ans *= a [ i ] <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = input ( ) <NEWLINE> nums = input ( ) . split ( ) <NEWLINE> res = int ( nums . pop ( 0 ) ) <NEWLINE> <NL> if 0 in nums : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> for i in nums : <NEWLINE> <INDENT> res *= int ( i ) <NEWLINE> <NL> <DEDENT> print ( res ) <NEWLINE>
def main ( ) : <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if 0 in A : print ( 0 ) <NEWLINE> return <NEWLINE> prod = 1 for a in A : <NEWLINE> prod *= a <NEWLINE> if prod > 1000000000000000000 : <NEWLINE> print ( - 1 ) return <NEWLINE> print ( prod ) main ( ) <NEWLINE>
<COMMENT> <NL> <NL> using namespace std ; <NEWLINE> <NL> const double eps = 1e-9 ; <NEWLINE> <NL> int main ( ) { <NEWLINE> <INDENT> ios : : sync_with_stdio ( false ) ; <NEWLINE> cin . tie ( 0 ) ; <NEWLINE> int n ; <NEWLINE> cin >> n ; <NEWLINE> long long ans = 1 ; <NEWLINE> vector < long long > a ( n ) ; <NEWLINE> bool ok = false ; <NEWLINE> for ( int i = 0 ; i < n ; i + + ) { <NEWLINE> <INDENT> cin >> a [ i ] ; <NEWLINE> if ( a [ i ] == 0 ) ok = true ; <NEWLINE> <DEDENT> } <NEWLINE> if ( ok ) { <NEWLINE> <INDENT> cout << <STRING> ; <NEWLINE> return 0 ; <NEWLINE> <DEDENT> } <NEWLINE> double foo = ( double ) 1e18 ; <NEWLINE> for ( int i = 0 ; i < n ; i + + ) { <NEWLINE> <INDENT> if ( a [ i ] == 0 ) { <NEWLINE> <INDENT> cout << <STRING> ; <NEWLINE> return 0 ; <NEWLINE> <DEDENT> } <NEWLINE> double bar = foo / a [ i ] ; <NEWLINE> if ( bar < 1.0 * ans ) { <NEWLINE> <INDENT> cout << <STRING> ; <NEWLINE> return 0 ; <NEWLINE> <DEDENT> } <NEWLINE> ans *= a [ i ] ; <NEWLINE> <DEDENT> } <NEWLINE> cout << ans << <STRING> ; <NEWLINE> return 0 ; <NEWLINE> <DEDENT> } <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> prod = 1 <NEWLINE> for a in A : <NEWLINE> <INDENT> values *= a <NEWLINE> if prod > 1000000000000000000 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> return <NEWLINE> <DEDENT> <DEDENT> print ( prod ) <NEWLINE> <DEDENT> main ( ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> result = 1 <NEWLINE> if 0 in A : <NEWLINE> <INDENT> result = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in A : <NEWLINE> result *= i <NEWLINE> if result > 10 ** 18 : <NEWLINE> <INDENT> result = - 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( result ) <NEWLINE>
def pyn ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <INDENT> if 0 in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> <DEDENT> ans = 1 <NEWLINE> for i in a : <NEWLINE> <INDENT> ans *= i <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> if 0 in s : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s = 1 <NEWLINE> for c in range ( n ) : <NEWLINE> <INDENT> s = s * a [ c ] <NEWLINE> if s > 10 ** 18 : <NEWLINE> <INDENT> s = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( s ) <NEWLINE> <DEDENT>
<INDENT> import numpy as np <NEWLINE> from operator import mul <NEWLINE> from functools import reduce <NEWLINE> N = int ( input ( ) . strip ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> x = reduce ( mul , A ) <NEWLINE> if x > 1000000000000000000 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( x ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> an = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> s = 1 <NEWLINE> flg = False <NEWLINE> for a in an : <NEWLINE> <INDENT> s = s * a <NEWLINE> if s > 10 ** 18 or s < 0 : <NEWLINE> <INDENT> flg = True <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if 0 in s : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> elif flg : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( s ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> <NL> aList = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> result = aList [ 0 ] <NEWLINE> <NL> for i + 1 in range ( n ) : <NEWLINE> <INDENT> result = result * aList [ i ] <NEWLINE> <NL> <DEDENT> enemy = 10 ** 18 <NEWLINE> <NL> if result < enemy : <NEWLINE> <INDENT> print ( result ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
31 <NEWLINE> 4 1 5 9 2 6 5 3 5 8 9 7 9 3 2 3 8 4 6 2 6 4 3 3 8 3 2 7 9 5 0 <NEWLINE>
n = int ( input ( ) ) <NEWLINE> t = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> to = t [ 0 ] <NEWLINE> if 0 in t : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> for a in t [ 1 : ] : <NEWLINE> <INDENT> to *= a <NEWLINE> <INDENT> if to > 10 ** 18 : <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> <INDENT> exit ( ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( to ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> ans = 1 <NEWLINE> for a in A : <NEWLINE> <INDENT> ans *= a <NEWLINE> if ans > 1000000000000000000 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import numpy <NEWLINE> n = int ( input ( ) ) <NEWLINE> A = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = numpy . prod ( A ) <NEWLINE> if ans > 10 ** 8 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
= int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> x = 1 <NEWLINE> flag = 0 <NEWLINE> A . sort ( ) <NEWLINE> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> x *= A [ n - i - 1 ] <NEWLINE> if x > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> flag = 1 <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <DEDENT> <DEDENT> if flag == 0 : <NEWLINE> <INDENT> print ( x ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> X = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 1 <NEWLINE> if 0 in X : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> X . sorted ( reverse = True ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> ans *= X [ i ] <NEWLINE> if 10 ** 18 < ans : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = reversed ( sorted ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> assert len ( A ) == N <NEWLINE> mul = 1 <NEWLINE> for a in A : <NEWLINE> <INDENT> mul *= a <NEWLINE> if mul >= 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( mul ) <NEWLINE> <DEDENT>
<COMMENT> <NL> using namespace std ; <NEWLINE> typedef long long int lli ; <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> int main ( ) { <NEWLINE> <INDENT> ios_base : : sync_with_stdio ( false ) ; <NEWLINE> cin . tie ( NULL ) ; <NEWLINE> lli n ; <NEWLINE> cin >> n ; <NEWLINE> lli mask = 1 ; <NEWLINE> lli temp ; <NEWLINE> bool flag = false ; <NEWLINE> bool fzero = false ; <NEWLINE> for ( lli i = 0 ; i < n ; i + + ) { <NEWLINE> <INDENT> cin >> temp ; <NEWLINE> mask *= temp ; <NEWLINE> if ( mask < 0 | | mask > 1000000000000000000 ) { <NEWLINE> <INDENT> flag = true ; <NEWLINE> <DEDENT> } <NEWLINE> if ( temp == 0 ) <NEWLINE> <INDENT> fzero = true ; <NEWLINE> <DEDENT> <DEDENT> } <NEWLINE> if ( fzero ) { <NEWLINE> <INDENT> cout << 0 << endl ; <NEWLINE> return 1 ; <NEWLINE> <DEDENT> } <NEWLINE> if ( flag ) { <NEWLINE> <INDENT> cout << <STRING> << endl ; <NEWLINE> return 1 ; <NEWLINE> <DEDENT> } <NEWLINE> cout << mask << endl ; <NEWLINE> <DEDENT> } <NEWLINE>
n = int ( input ( ) ) <NEWLINE> la = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> import sys <NEWLINE> if la . index ( 0 ) > 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> ans = 1 <NEWLINE> for i in la : <NEWLINE> <INDENT> ans *= i <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> x = 0 <NEWLINE> if 0 in A : <NEWLINE> <INDENT> y = True <NEWLINE> A . remove ( 0 ) <NEWLINE> <DEDENT> for i in A : <NEWLINE> <INDENT> x += math . log ( i , 10 ) <NEWLINE> <DEDENT> if y == True : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> elif x <= 18.1 : <NEWLINE> <INDENT> prod = 1 <NEWLINE> for i in A : <NEWLINE> <INDENT> prod = prod * i <NEWLINE> <DEDENT> if prod < 1e18 : <NEWLINE> <INDENT> print ( prod ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
listed = input ( ) . split ( ) <NEWLINE> mul = 1 <NEWLINE> maxi = 10 ** 18 <NEWLINE> for num in listed : <NEWLINE> <INDENT> mul *= num <NEWLINE> if num == 0 : <NEWLINE> <INDENT> print ( mul ) <NEWLINE> <DEDENT> if num > maxi ** 18 : <NEWLINE> <INDENT> print ( mul ) <NEWLINE> <DEDENT> <DEDENT> print ( mul ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a . sort ( ) <NEWLINE> result = 1 <NEWLINE> for i in range ( len ( a ) ) : <NEWLINE> <INDENT> result = result * a [ i ] <NEWLINE> if result == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> elif result > 1000000000000000000 <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> if result <= 1000000000000000000 : <NEWLINE> <INDENT> print ( result ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT>
def resolve ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> if A in <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> for i in A : <NEWLINE> <INDENT> ans *= i <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <DEDENT> resolve ( ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> p = 1 <NEWLINE> for i in a : <NEWLINE> <INDENT> p *= i <NEWLINE> if p == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if p > 10 ** 18 : <NEWLINE> <INDENT> p = - 1 <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if p > 10 ** 18 : <NEWLINE> <INDENT> p = - 1 <NEWLINE> <DEDENT> print ( p ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> if not 0 in a : <NEWLINE> <INDENT> for i in range ( n ) : <NEWLINE> <INDENT> ans *= a [ i ] <NEWLINE> if ans > 1e+18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if ans <= 1e+18 : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT> <DEDENT> eles : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = [ ] <NEWLINE> a = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = 1 <NEWLINE> for val in a : <NEWLINE> <INDENT> ans *= val <NEWLINE> <DEDENT> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
input ( ) ; l = input ( ) . split ( ) ; x = not <STRING> in l <NEWLINE> for j in l : <NEWLINE> <INDENT> x *= int ( j ) ; if x > 1e18 : x = - 1 ; break <NEWLINE> <DEDENT> print ( x ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> ans = A [ 0 ] <NEWLINE> if ans == 0 : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( 1 , N ) : <NEWLINE> <INDENT> ans = ans * A [ i ] <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> for i in a : <NEWLINE> <INDENT> if ( a [ i ] == 0 ) : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <INDENT> exit <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> ans += a [ 0 ] <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> ans *= a [ i ] <NEWLINE> if ( ans > 10 ** 18 ) : <NEWLINE> <INDENT> ans *= a [ i ] <NEWLINE> print ( - 1 ) <NEWLINE> exit <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( sum ( a ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT>
<INDENT> = int ( input ( ) ) <NEWLINE> <DEDENT> A = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> <NL> reg = A [ 0 ] <NEWLINE> flg = True <NEWLINE> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> flg = False <NEWLINE> reg = 0 <NEWLINE> <DEDENT> for i in range ( 1 , N ) : <NEWLINE> <INDENT> reg *= A [ i ] <NEWLINE> if reg > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> flg = False <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if flg : <NEWLINE> <INDENT> print ( reg ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if 0 in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> m = 1 <NEWLINE> for i in a : <NEWLINE> <INDENT> m *= a [ i ] <NEWLINE> if m > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( m ) <NEWLINE> <NL> <NL> <NL> <DEDENT> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> arr = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> arr . sort ( reverse = True ) <NEWLINE> ans = 1 <NEWLINE> limit = 10 * 18 <NEWLINE> <NL> if arr [ - 1 ] == 0 : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in arr : <NEWLINE> <INDENT> ans *= arr [ i ] <NEWLINE> if ans > limit : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if 0 in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> return <NEWLINE> <DEDENT> ans = 1 <NEWLINE> for i in a : <NEWLINE> <INDENT> ans *= i <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> res = 1 <NEWLINE> <NL> if 0 in A : <NEWLINE> <INDENT> res = 0 <NEWLINE> N = 0 <NEWLINE> <NL> <DEDENT> for x in range ( N ) : <NEWLINE> <INDENT> res *= A [ x ] <NEWLINE> if res > 10 ** 18 <NEWLINE> <INDENT> res = - 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( res ) <NEWLINE>
import array <NEWLINE> <NL> <NL> n = int ( input ( ) ) <NEWLINE> a = [ ] <NEWLINE> f = 0 <NEWLINE> f1 = 0 <NEWLINE> b = 0 <NEWLINE> for i in range ( 0 , n ) : <NEWLINE> <INDENT> i = int ( input ( ) ) <NEWLINE> a . append ( i ) <NEWLINE> if i == 0 : <NEWLINE> <INDENT> print ( <STRING> ) ; <NEWLINE> f1 = 1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> sum = 1 <NEWLINE> if f1 == 0 : <NEWLINE> <INDENT> for i in a : <NEWLINE> <INDENT> sum = sum * i ; <NEWLINE> if sum > 1e18 : <NEWLINE> <INDENT> f = 1 <NEWLINE> print ( <STRING> ) ; <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if f == 0 : <NEWLINE> <INDENT> print ( sum ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( input ( ) . split ( ) ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> A [ i ] = int ( A [ i ] ) <NEWLINE> <DEDENT> sum = 1 <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> if sum <= 10 ** 18 : <NEWLINE> <INDENT> sum = sum * A [ i ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break : <NEWLINE> <NL> <DEDENT> <DEDENT> if sum <= 10 ** 18 : <NEWLINE> <INDENT> print ( sum ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT>
N = input ( ) <NEWLINE> A = [ int ( a ) for a in input ( ) . split ( ) ] <NEWLINE> <NL> ans = 1 <NEWLINE> <NL> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) : <NEWLINE> <NL> <DEDENT> for i in range ( len ( A ) ) : <NEWLINE> <INDENT> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> ans *= A [ i ] <NEWLINE> <NL> <NL> <DEDENT> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> def input ( ) : return sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> A , B = [ 0 ] * n , [ 0 ] * n <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> A [ i ] , B [ i ] = map ( int , input ( ) . split ( ) ) <NEWLINE> <DEDENT> A . sort ( ) <NEWLINE> B . sort ( ) <NEWLINE> if n % 2 == 1 : <NEWLINE> <INDENT> print ( B [ n // 2 ] - A [ n // 2 ] + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( int ( ( ( B [ n // 2 - 1 ] + B [ n // 2 ] ) / 2 - ( A [ n // 2 - 1 ] + A [ n // 2 ] ) / 2 ) * 2 ) + 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> import numpy as np <NEWLINE> import sys <NEWLINE> <NL> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> ans = np . prod ( A ) <NEWLINE> if ans <= 10 ** 18 : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> sus . exit ( ) <NEWLINE> <DEDENT> if 10 ** 18 < ans : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> <NL> ans = 1 <NEWLINE> <NL> ok = True <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ans *= a [ i ] <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> ok = False <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> if a [ i ] == 0 : <NEWLINE> <INDENT> ok = True <NEWLINE> ans = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> if ok == True : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> count = 1 <NEWLINE> if 0 in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( N ) : <NEWLINE> <INDENT> count *= a [ i ] <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( count ) <NEWLINE> <DEDENT> <DEDENT>
a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> if 0 in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> limit = 10 ** 18 <NEWLINE> for i in a : <NEWLINE> <INDENT> ans *= i <NEWLINE> if ans > lim : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 1 <NEWLINE> <NL> for i in A : <NEWLINE> <INDENT> ans *= i <NEWLINE> <NL> if ans > 10 ** 18 : <NEWLINE> print ( - 1 ) <NEWLINE> return <NEWLINE> <NL> <NL> <NL> <DEDENT> print ( ans ) <NEWLINE>
def readinput ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> return n , a <NEWLINE> <NL> <DEDENT> def main ( n , a ) : <NEWLINE> <INDENT> if ( a . count ( 0 ) != 0 ) : <NEWLINE> <INDENT> return 0 <NEWLINE> <NL> <DEDENT> res = a [ 0 ] <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> res *= a [ i ] <NEWLINE> if res > INFTY : <NEWLINE> <INDENT> return - 1 <NEWLINE> <DEDENT> <DEDENT> return res <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> n , a = readinput ( ) <NEWLINE> ans = main ( n , a ) <NEWLINE> print ( ans ) <NEWLINE> <DEDENT>
def solve ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 1 <NEWLINE> <NL> for i in a : <NEWLINE> <INDENT> ans *= i <NEWLINE> if ans > int ( 1e18 ) : return - 1 <NEWLINE> <NL> <NL> <DEDENT> return ans <NEWLINE> <NL> <NL> <DEDENT> print ( solve ( ) ) <NEWLINE>
i = input ; i ( ) ; l = i ( ) . split ( ) ; x = 1 - ( <STRING> in l ) <NEWLINE> for j in l : <NEWLINE> <INDENT> x *= j - 48 <NEWLINE> if x > 1e18 : <NEWLINE> <INDENT> print ( - 1 ) ; quit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( x ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> r = 1 <NEWLINE> t = 10 ** 18 <NEWLINE> for i in a : <NEWLINE> <INDENT> r *= a [ i ] <NEWLINE> if r > t : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> return <NEWLINE> <DEDENT> <DEDENT> print ( r ) <NEWLINE>
a = int ( input ( ) ) <NEWLINE> ans = 1 ; <NEWLINE> ok = True <NEWLINE> for i in range ( a ) : <NEWLINE> <INDENT> c = int ( input ( ) ) <NEWLINE> ans *= c <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
def mulallnumber ( numbers ) : <COMMENT> <NEWLINE> <INDENT> x = 1 <NEWLINE> for i in numbers : <NEWLINE> <INDENT> x *= i <NEWLINE> return x <NEWLINE> <NL> <DEDENT> <DEDENT> A = list ( ) <COMMENT> <NEWLINE> <NL> N = int ( input ( <STRING> ) ) <COMMENT> <NEWLINE> <NL> print ( <STRING> ) <NEWLINE> for i in range ( int ( N ) ) : <NEWLINE> <INDENT> k = int ( input ( <STRING> ) ) <NEWLINE> A . append ( k ) <COMMENT> <NEWLINE> <NL> <DEDENT> if mulallnumber ( A ) < 1000000000000000000 : <NEWLINE> <INDENT> print ( mulallnumber ( A ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <COMMENT> <NEWLINE> <DEDENT>
_ , * A = map ( int , input ( ) . split ( ) ) <NEWLINE> A . sort ( ) <NEWLINE> <NL> ans = 1 <NEWLINE> <NL> if A [ 0 ] == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for a in A : <NEWLINE> <INDENT> ans *= a <NEWLINE> if ans > 1000000000000000000 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> A = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> the = pow ( 10 , 18 ) <NEWLINE> ans = 1 <NEWLINE> <NL> while ans < the : <NEWLINE> <INDENT> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> ans = the <NEWLINE> break <NEWLINE> <DEDENT> ans *= A [ i ] <NEWLINE> <NL> <DEDENT> if ans < the : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> x = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> x = sorted ( x ) <NEWLINE> ans = 1 <NEWLINE> for i in a : <NEWLINE> <INDENT> ans *= i <NEWLINE> if ans > 10 ** 8 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL>
import numpy as np <NEWLINE> a = int ( input ( ) ) <NEWLINE> b = np . array ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> b = np . prod ( b ) <NEWLINE> if b > 10 ** 18 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : print ( c ) <NEWLINE>
num = int ( input ( ) ) <NEWLINE> nums = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> for i in range ( num ) : <NEWLINE> <INDENT> if nums [ i ] == 0 : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> <DEDENT> if ans != 0 : <NEWLINE> <INDENT> for j in nums : <NEWLINE> <INDENT> ans *= nums [ j ] <NEWLINE> if len ( str ( ans ) ) > 18 : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> As = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 1 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ans = ans * As [ i ] <NEWLINE> <INDENT> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
def f ( n , a ) : <NEWLINE> <INDENT> if 0 in a : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> p = 1 <NEWLINE> for x in a : <NEWLINE> <INDENT> p *= x <NEWLINE> if p > 10 ** 18 : <NEWLINE> <INDENT> return - 1 <NEWLINE> <DEDENT> <DEDENT> return p <NEWLINE> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> a = list ( int , input ( ) . split ( ) ) <NEWLINE> print ( f ( n , a ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a_list = sorted ( [ int ( i ) for i in input ( ) . split ( ) ] ) <NEWLINE> <NL> if a [ 0 ] == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = 1 <NEWLINE> for i in a_list : <NEWLINE> <INDENT> ans *= i <NEWLINE> if i > 10 ** 18 : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 1 <NEWLINE> for a in ans : <NEWLINE> <INDENT> if ans >= 10 ** ( 18 ) / a : <NEWLINE> ans = - 1 <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans *= a <NEWLINE> <NL> <DEDENT> <DEDENT> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
def multi ( L ) : <NEWLINE> <INDENT> ans = 0 <NEWLINE> for l in L : <NEWLINE> <INDENT> if ans <= 10 ** 18 : <NEWLINE> <INDENT> ans *= l <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <NL> return ans <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> N = int ( input ( ) ) <NEWLINE> A_list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> print ( multi ( A_list ) ) <NEWLINE>
def main ( ) : <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if A is 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> return <NEWLINE> <DEDENT> p = 1 <NEWLINE> for i in A : <NEWLINE> <INDENT> p = p * i <NEWLINE> if p > 1000000000000000000 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> return <NEWLINE> <DEDENT> <DEDENT> print ( p ) <NEWLINE> main ( ) <NEWLINE> <NL>
n , * a = map ( int , open ( 0 ) . read ( ) . split ( ) ) <NEWLINE> a . sort ( ) <NEWLINE> for i in a : <NEWLINE> <INDENT> s *= i <NEWLINE> if s > 1e18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( s ) <NEWLINE>
input ( ) ; a = 1 <NEWLINE> for i in input ( ) . split ( ) : a *= int ( i ) ; a = [ - 1 , a ] [ 1 = < a <= eval ( <STRING> + <STRING> * 18 ) ] <NEWLINE> print ( a ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> for i in range ( 0 , N ) : <NEWLINE> <INDENT> if A [ i ] == 0 : <NEWLINE> <INDENT> ans = 0 <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if ans > 0 <NEWLINE> <INDENT> ans *= A [ i ] <NEWLINE> <DEDENT> if ans > 10 ** 18 : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( <STRING> ) ) <NEWLINE> k = 1 <NEWLINE> li = list ( map ( int , input ( <STRING> ) . split ( <STRING> ) ) ) <NEWLINE> if 0 in li : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in li : <NEWLINE> <INDENT> k *= int ( i ) <NEWLINE> <DEDENT> if k > 1000000000000000000 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( k ) <NEWLINE> <DEDENT> <DEDENT>
def main ( ) : <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> return <NEWLINE> <DEDENT> prod = 1 <NEWLINE> for a in A : <NEWLINE> <INDENT> prod *= a <NEWLINE> <DEDENT> if prod > 1000000000000000000 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> return <NEWLINE> <DEDENT> print ( prod ) <NEWLINE> main ( ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = [ int ( e ) for e in input ( ) . split ( ) ] <NEWLINE> ans = 1 <NEWLINE> if 0 in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ans *= a [ i ] <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
n = input ( ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> az = a . index ( 0 ) <NEWLINE> <NL> for i in range ( len ( a ) ) : <NEWLINE> <INDENT> ans *= a [ i ] <NEWLINE> <NL> if az > 0 : <NEWLINE> <INDENT> ans = 0 <NEWLINE> break <NEWLINE> <DEDENT> if ans >= 1000000000000000001 : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
a = input ( ) <NEWLINE> <NL> list1 = [ a for items in list1 list1 [ items ] = input ( ) ] <NEWLINE> <NL>
n = int ( input ( ) ) <NEWLINE> num = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> <NL> s = num [ 0 ] <NEWLINE> <NL> for i range ( 1 , n ) : <NEWLINE> <INDENT> s = s * num [ i ] <NEWLINE> <NL> <DEDENT> print ( s ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 1 <NEWLINE> for i in range ( len ( a ) ) : <NEWLINE> <INDENT> ans *= a [ i ] <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) ] <NEWLINE> if 0 in a : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = 1 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ans *= a [ i ] <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> return <NEWLINE> <DEDENT> p = 1 <NEWLINE> for a in A : <NEWLINE> <INDENT> p *= a <NEWLINE> if p > 1000000000000000000 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> return <NEWLINE> <DEDENT> <DEDENT> print ( p ) <NEWLINE> <DEDENT> main ( ) <NEWLINE> <NL>
def main ( ) : <NEWLINE> <INDENT> _ = input ( ) <NEWLINE> lst = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> <NL> if 0 in lst : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> for i in map ( int , input ( ) . split ( ) ) : <NEWLINE> <INDENT> ans *= i <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> for a in A : <NEWLINE> <INDENT> if a == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> num = 1 <NEWLINE> for a in A : <NEWLINE> <INDENT> num *= a <NEWLINE> if num > 1000000000000000000 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( num ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> Π = 1 <NEWLINE> for _ in A : <NEWLINE> <INDENT> Π *= _ <NEWLINE> if ( Π > 1000000000000000000 ) : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> <DEDENT> print ( Π ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> nums = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> cumul = 1 <NEWLINE> if 0 in nums : print ( 0 ) <NEWLINE> else : <NEWLINE> <INDENT> for i in range ( N ) : <NEWLINE> <INDENT> cumul *= nums [ i ] <NEWLINE> if cumul > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if cumul <= 10 ** 18 : print ( cumul ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if min ( l ) == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s = 1 <NEWLINE> for x in l : <NEWLINE> <INDENT> s *= x <NEWLINE> if s > 1000000000000000000 : <NEWLINE> <INDENT> s = - 1 <NEWLINE> break <NEWLINE> <NL> print ( s ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
from sys import stdin <NEWLINE> N = int ( stdin . readline ( ) . rstrip ( ) ) <NEWLINE> A = [ int ( _ ) for _ in stdin . readline ( ) . rstrip ( ) . split ( ) ] <NEWLINE> ans = 1 <NEWLINE> for a in A : <NEWLINE> <INDENT> ans *= a <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> return <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<NL> N = int ( input ( ) ) <NEWLINE> <NL> data = [ int ( e ) for e in input ( ) . split ( ) ] <NEWLINE> <NL> data = data . sort ( reverse = False ) <NEWLINE> <NL> judge = True <NEWLINE> <NL> for i in data : <NEWLINE> <INDENT> sum_1 = sum_1 * i <NEWLINE> <NL> if sum_1 > 1000000000000000000 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> judge = False <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if judge == True : <NEWLINE> <INDENT> print ( sum_1 ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> s = input ( ) . split ( ) <NEWLINE> <NL> if s [ 0 ] * s [ 1 ] > 10 ** 18 : <NEWLINE> <INDENT> print ( s [ 0 ] * s [ 1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> s = 1 <NEWLINE> f = 1 <NEWLINE> x = 1000000000000000000 <NEWLINE> for i in l : <NEWLINE> <INDENT> s *= i <NEWLINE> if s > x : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> f = 0 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if f == 1 : <NEWLINE> <INDENT> print ( s ) <NEWLINE> <DEDENT>
<COMMENT> <NL> from sys import stdin <NEWLINE> import numpy as np <NEWLINE> input = stdin . readline <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> np_A = np . array ( A ) <NEWLINE> ans = np_A [ 0 ] <NEWLINE> <NL> 2 <NEWLINE> for i in range ( 1 , N , 1 ) : <NEWLINE> <INDENT> ans = ans * np_A [ i ] <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> flag = False <NEWLINE> break <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if flag == False : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
101 9901 999999000001 <NEWLINE>
n = int ( input ( ) ) <NEWLINE> ans = 1 <NEWLINE> flg = True <NEWLINE> <NL> if <STRING> in list ( input ( ) . split ( ) ) : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for a in input ( ) . split ( ) : <NEWLINE> <INDENT> _a = int ( a ) <NEWLINE> ans *= _a <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> flg = False <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if flg : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT> <DEDENT>
N = input ( ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> answer = 1 <NEWLINE> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in A : <NEWLINE> <INDENT> answer *= i <NEWLINE> <DEDENT> if answer > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( answer ) <NEWLINE> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> if A in 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> ans *= A [ i ] <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
def demon ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A = sort ( A ) <NEWLINE> if A [ 0 ] == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> X = 1 <NEWLINE> for i in A : <NEWLINE> <INDENT> X *= A <NEWLINE> if X > 10 ** 18 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> <DEDENT> print ( X ) <NEWLINE> <NL> <DEDENT> demon ( ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> l = list ( map ( int , input ( ) . split ( ) ) ) . sort ( ) <NEWLINE> <NL> if l [ 0 ] == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> res = 1 <NEWLINE> <NL> for i in l : <NEWLINE> <INDENT> res *= i <NEWLINE> if res > 10 ** 18 : <NEWLINE> <INDENT> print ( res ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> print ( res ) <NEWLINE> <DEDENT>
a = int ( input ( ) ) <NEWLINE> ar = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> if 0 in ar : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> b = 1 <NEWLINE> for r in ar : <NEWLINE> <INDENT> b *= r <NEWLINE> if b > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> return <NEWLINE> <DEDENT> <DEDENT> print ( b ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> if a . index ( 0 ) >= 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> lim = int ( 1e18 ) <NEWLINE> mult = 1 <NEWLINE> for v in a : <NEWLINE> <INDENT> if mult > lim : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> mult *= v <NEWLINE> <DEDENT> <DEDENT> if mult > lim : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( mult ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> <NL> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 1 <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> if ans >= 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> ans = ans * a [ i ] <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
dontt_use = input ( ) <NEWLINE> n = map ( int , list ( input ( ) . split ( ) ) ) <NEWLINE> total = 1 <NEWLINE> for number in n : <NEWLINE> <INDENT> total = total * number <NEWLINE> if total > 10 ** 18 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> return <NEWLINE> <DEDENT> <DEDENT> print ( total ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if 0 in l : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a = 1 <NEWLINE> for i in l : <NEWLINE> <INDENT> a = a * i <NEWLINE> if a > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <INDENT> exit ( ) <NEWLINE> print ( a ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> mx = 10 ** 18 <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for x in a : <NEWLINE> <INDENT> if x == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( 0 ) <NEWLINE> <DEDENT> <DEDENT> ans = 1 <NEWLINE> for x in a : <NEWLINE> <INDENT> ans *= a <NEWLINE> if ans > mx : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( 0 ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> a . sort ( ) <NEWLINE> ans = 1 <NEWLINE> <NL> for i in a : <NEWLINE> <INDENT> ans *= i <NEWLINE> <NL> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
num = int ( input ( ) ) <NEWLINE> str2 = input ( ) . split ( <STRING> ) <NEWLINE> nums = [ int ( s ) for s in str2 ] <NEWLINE> nums . sort ( ) <NEWLINE> <NL> for i in range ( len ( nums ) ) : <NEWLINE> <INDENT> ans = ans * nums [ i ] <NEWLINE> if ( ans > 1000000000000000000 ) : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> quit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> quit ( ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = N . split ( <STRING> ) <NEWLINE> A = list ( map ( int , A ) ) <NEWLINE> result = A [ 0 ] <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> result = result * A [ i ] <NEWLINE> if result * A [ i ] > 10 ** 18 : <NEWLINE> <INDENT> result = - 1 <NEWLINE> <DEDENT> <DEDENT> print ( result ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A = sorted ( A ) <NEWLINE> A = A [ : : - 1 ] <NEWLINE> ans = 1 <NEWLINE> for i in range ( N + 1 ) : <NEWLINE> <INDENT> if 0 in A : <NEWLINE> <INDENT> ans = 0 <NEWLINE> break <NEWLINE> <DEDENT> elif ans > 10 ** 18 : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = ans * A [ i ] <NEWLINE> <DEDENT> <DEDENT> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
a = [ 0 ] * n <NEWLINE> a = input ( ) . split ( ) <NEWLINE> n0 = a . count ( <STRING> ) <NEWLINE> sum = int ( a [ 0 ] ) <NEWLINE> if n0 == 0 : <NEWLINE> <INDENT> for k in range ( len ( a ) - 1 ) : <NEWLINE> <INDENT> sum = sum * int ( a [ k + 1 ] ) <NEWLINE> if sum > 1000000000000000000 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if sum > 1000000000000000000 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( sum ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> ans = 1 ; <NEWLINE> tem = 0 <NEWLINE> ok = 1 <NEWLINE> s = input ( ) . split ( ) <NEWLINE> for i in s : <NEWLINE> <INDENT> if ( int ( i ) == 0 ) : <NEWLINE> <INDENT> tem = 1 <NEWLINE> break <NEWLINE> <DEDENT> ans *= int ( i ) <NEWLINE> if ( ans > 10 ** 18 ) : <NEWLINE> <INDENT> ok = 0 <NEWLINE> <DEDENT> <DEDENT> if ( tem ) : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> elif ( ok ) <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <NL> n = input ( ) <NEWLINE> a = map ( int , input ( ) . split ) <NEWLINE> d = 1 <NEWLINE> <NL> if 0 in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> for b in a : <NEWLINE> <INDENT> d = d * b <NEWLINE> <NL> if d > 10 ** 18 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> return <NEWLINE> <DEDENT> <DEDENT> print ( d ) <NEWLINE> <NL> def main ( ) : <NEWLINE>
open Batteries <NEWLINE> let n = read_int ( ) <NEWLINE> let a = read_line ( ) <NEWLINE> let a2 = a | > String . split_on_char <STRING> | > List . map int_of_string <NEWLINE> let rec loop lst r = <NEWLINE> <INDENT> match lst with <NEWLINE> | [ ] -> r <NEWLINE> | first : : rest -> <NEWLINE> <INDENT> if List . mem 0 a2 then 0 else <NEWLINE> if first < > 1 & & 1000000000000000000 / 2 <= r then - 1 else <NEWLINE> loop rest ( r * first ) <NEWLINE> <NL> <DEDENT> <DEDENT> let l = loop a2 1 <NEWLINE> let _ = l | > Printf . printf <STRING> <NEWLINE>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> sys . setrecursionlimit ( 10 ** 8 ) <NEWLINE> from itertools import accumulate <NEWLINE> from itertools import permutations <NEWLINE> from itertools import combinations <NEWLINE> from collections import defaultdict <NEWLINE> from collections import Counter <NEWLINE> import fractions <NEWLINE> import math <NEWLINE> from collections import deque <NEWLINE> from bisect import bisect_left <NEWLINE> from bisect import insort_left <NEWLINE> import itertools <NEWLINE> from heapq import heapify <NEWLINE> from heapq import heappop <NEWLINE> from heapq import heappush <NEWLINE> import heapq <NEWLINE> from copy import deepcopy <NEWLINE> alf = list ( <STRING> ) <NEWLINE> ALF = list ( <STRING> ) <NEWLINE> <COMMENT> <NL> INF = float ( <STRING> ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> MAX = 10 ** 18 <NEWLINE> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = 1 <NEWLINE> flag = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> a = A [ i ] <NEWLINE> cur *= a <NEWLINE> if cur > MAX : <NEWLINE> <INDENT> flag = 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if flag == 1 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( cur ) <NEWLINE> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i in A : <NEWLINE> <INDENT> anser *= i <NEWLINE> <DEDENT> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> if anser > 10 ** 18 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( anser ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> numbers = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> <NL> if any [ x == 0 for x in numbers ] : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> t = numbers [ 0 ] <NEWLINE> for el in numbers : <NEWLINE> <INDENT> while total < 10 ** 18 : <NEWLINE> <INDENT> t *= el <NEWLINE> <DEDENT> if t < 10 ** 18 : <NEWLINE> <INDENT> print ( t ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def main ( ) : <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if 0 in A : <NEWLINE> print ( 0 ) <NEWLINE> return <NEWLINE> prod = 1 <NEWLINE> for a in A : <NEWLINE> prod *= a <NEWLINE> if prod > 1000000000000000000 : <NEWLINE> print ( - 1 ) <NEWLINE> return <NEWLINE> print ( prod ) <NEWLINE> main ( ) <NEWLINE>
<COMMENT> <NL> a = int ( input ( ) ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if 0 in b : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> c = 1 <NEWLINE> for i in b : <NEWLINE> <INDENT> c *= i <NEWLINE> if ( c > 10 ** 18 ) : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <INDENT> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( c ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c = 1 <NEWLINE> if 0 in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for x in a : <NEWLINE> <INDENT> if x > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> c *= x <NEWLINE> if c > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( z ) <NEWLINE> <DEDENT> <DEDENT>
import numpy as np <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if 0 in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> prod = 1 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> prod *= a [ i ] <NEWLINE> if prod >= 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( prod ) <NEWLINE>
import sys <NEWLINE> def main ( ) : <NEWLINE> <NL> <INDENT> n = int ( input ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> s = 1 <NEWLINE> p = sorted ( p ) <NEWLINE> for i in p : <NEWLINE> <INDENT> s *= i <NEWLINE> if i == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> else s >= 10 ** 18 + 1 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( s ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> nums = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> limit = 10 ** 18 <NEWLINE> res = 1 <NEWLINE> i = 0 <NEWLINE> if 0 in num : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> while i < n : <NEWLINE> <INDENT> res *= nums [ i ] <NEWLINE> i += 1 <NEWLINE> if res > limit : <NEWLINE> <INDENT> res = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( res ) <NEWLINE>
num = int ( input ( ) ) <NEWLINE> numbers = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> sum = 1 <NEWLINE> for i in range ( num ) : <NEWLINE> <INDENT> sum *= numbers [ i ] <NEWLINE> if ( sum > ( 10 ** 18 ) ) : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if sum <= ( 10 ** 18 ) : <NEWLINE> <INDENT> print ( sum ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if 0 in A : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( 1 , N ) : <NEWLINE> <INDENT> if ans <= 10 ** 18 : <NEWLINE> <INDENT> ans *= A [ i ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL>
n = int ( input ( ) ) <NEWLINE> arr = [ ] <NEWLINE> <NL> z = False <NEWLINE> for x in input ( ) . split ( <STRING> ) : <NEWLINE> <INDENT> if x == 0 : <NEWLINE> <INDENT> z = True <NEWLINE> <DEDENT> arr . append ( x ) <NEWLINE> <DEDENT> if z == True : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> ans = 1 <NEWLINE> for x in arr : <NEWLINE> <INDENT> ans *= x <NEWLINE> if ans > int ( 1e18 ) : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> str_list = input ( ) . split ( ) <NEWLINE> <NL> list = [ int ( k ) for k in str_list ] <NEWLINE> <NL> list . sort ( reverse = True ) <NEWLINE> <NL> result = 1 <NEWLINE> <NL> if ( 0 in list ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> result = result * list [ i ] <NEWLINE> if ( result >= 1000000000000000000 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> <DEDENT> print ( result ) <NEWLINE> <NL>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> X = 1 <NEWLINE> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> break <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> for idx in range ( N ) : <NEWLINE> <INDENT> X = X * A [ idx ] <NEWLINE> if X > 1 * 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( X ) <NEWLINE> <DEDENT> <DEDENT>
input ( ) ; l = input ( ) . split ( ) ; x = 1 <NEWLINE> for j in sorted ( l ) : <NEWLINE> <INDENT> x : = x * int ( j ) if x > 1e18 or x < 0 else - 1 <NEWLINE> <DEDENT> print ( x ) <NEWLINE>
a = int ( input ( ) ) <NEWLINE> b = input ( ) . split ( ) <NEWLINE> <NL> for i in range ( a ) : <NEWLINE> <INDENT> if b [ i ] == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> <DEDENT> c = 1 <NEWLINE> for i in range ( a ) : <NEWLINE> <INDENT> c = c * int ( b [ i ] ) <NEWLINE> if c > 1000000000000000000 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> if c > 1000000000000000000 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( c ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> A = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> prod = 1 <NEWLINE> for i in range ( 0 , N ) : <NEWLINE> <INDENT> prod = prod * A [ i ] <NEWLINE> if ( prod > 1000000000000000000 ) : <NEWLINE> <INDENT> prod = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( prod ) <NEWLINE>
import sys <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> nums = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> <NL> output = 1 <NEWLINE> <NL> if 0 in nums : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> for x in nums : <NEWLINE> <INDENT> output *= x <NEWLINE> <NL> if output > 10 ** 18 <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( output ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> i = 0 <NEWLINE> while ans <= 1000000000000000000 : <NEWLINE> <INDENT> ans = ans * A [ i ] <NEWLINE> i += 1 <NEWLINE> <NL> <DEDENT> if A . count ( 0 ) > 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans if ans <= 1000000000000000000 else <STRING> ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> nums = input ( ) . split ( ) <NEWLINE> mul = int ( nums [ 0 ] ) <NEWLINE> for i in nums [ 1 : ] : <NEWLINE> <INDENT> if str ( 0 ) in mul : <NEWLINE> <INDENT> mul = 0 <NEWLINE> break <NEWLINE> <DEDENT> if len ( str ( mul ) ) > 19 : <NEWLINE> <INDENT> mul = - 1 <NEWLINE> break <NEWLINE> <DEDENT> mul *= int ( i ) <NEWLINE> <DEDENT> print ( mul ) <NEWLINE>
import numpy as np <NEWLINE> <NL> input ( ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if k > 10 ** ( 18 ) : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( int ( np . prod ( A ) ) ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> quit ( ) <NEWLINE> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> output = 1 <NEWLINE> output *= a [ i ] <NEWLINE> if output > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> quit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( output ) <NEWLINE>
a = ( ) <NEWLINE> n = input ( ) <NEWLINE> a = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> ans = a [ 0 ] <NEWLINE> a2 = a [ 1 : ] <NEWLINE> for i in a2 : <NEWLINE> <INDENT> ans = ans * i <NEWLINE> <NL> <DEDENT> if ans > 10e+18 : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
package main <NEWLINE> <NL> import ( <NEWLINE> <INDENT> <STRING> <NEWLINE> <DEDENT> ) <NEWLINE> <NL> func main ( ) { <NEWLINE> <INDENT> var n int <NEWLINE> var ans int = 1 <NEWLINE> var t int <NEWLINE> <NL> fmt . Scan ( & n ) <NEWLINE> <NL> for i : = 0 ; i < n ; i + + { <NEWLINE> <INDENT> fmt . Scan ( & t ) <NEWLINE> ans = ans * t <NEWLINE> if ans > 1000000000000000000 { <NEWLINE> <INDENT> ans = - 1 <NEWLINE> <DEDENT> } <NEWLINE> <DEDENT> } <NEWLINE> <NL> fmt . Println ( ans ) <NEWLINE> <DEDENT> } <NEWLINE>
import functools <NEWLINE> import operator <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> v = ( ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> answer = functools . reduce ( operator . mul . v ) <NEWLINE> answer = answer if answer <= 10 ** 18 else - 1 <NEWLINE> print ( answer ) <NEWLINE>
N = input ( ) <NEWLINE> x = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> z = 1 <NEWLINE> if 0 in x : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <NL> <DEDENT> for a in x : <NEWLINE> <INDENT> z *= a <NEWLINE> if z > 1000000000000000 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> <DEDENT> print ( z ) <NEWLINE>
def fun ( ) : <NEWLINE> <INDENT> n = int ( input ( ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> return <NEWLINE> <DEDENT> prod = 1 <NEWLINE> for a in A : <NEWLINE> <INDENT> prod *= a <NEWLINE> if ( prod > 1000000000000000000 ) : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> return <NEWLINE> <DEDENT> <DEDENT> print ( prod ) <NEWLINE> <NL> <NL> <NL> <DEDENT> fun ( ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> <NL> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if a . index ( 0 ) : <NEWLINE> <INDENT> ans = 0 <NEWLINE> break <NEWLINE> <DEDENT> ans = ans * a [ i ] <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> m = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> x = 1 <NEWLINE> if 0 in m : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for y in m : <NEWLINE> <INDENT> x *= y <NEWLINE> if x > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( x ) <NEWLINE> <DEDENT> <DEDENT>
def multipilation ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if 0 in A <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> prod = 1 <NEWLINE> for a in A <NEWLINE> <INDENT> prod *= a <NEWLINE> if prod > 1000000000000000000 <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> <DEDENT> print ( prod ) <NEWLINE> <NL> <DEDENT> multipilation ( ) <NEWLINE> <NL> <NL>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if 0 in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> break <NEWLINE> <NL> <DEDENT> ans = 1 <NEWLINE> for i in a : <NEWLINE> <INDENT> ans *= i <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> else : <NEWLINE> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> is_zero = False <NEWLINE> for i in a : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> is_zero = True <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if is_zero : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> p = 1 <NEWLINE> for i in p : <NEWLINE> <INDENT> p = p * i <NEWLINE> if p > 10 ** 18 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> if p > 10 ** 18 : <NEWLINE> <INDENT> p = - 1 <NEWLINE> <DEDENT> print ( p ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = 1 <NEWLINE> <NL> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> a = a * A [ i ] <NEWLINE> <INDENT> if a > 10 ** 18 : <NEWLINE> print ( - 1 ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> else : print ( a ) <NEWLINE> <NL>
n = input ( ) <NEWLINE> ans = 1 <NEWLINE> flag = 0 <NEWLINE> for i in n : <NEWLINE> <INDENT> x = input ( ) <NEWLINE> ans *= x <NEWLINE> if ( ans > ( 10 ** 18 ) ) : <NEWLINE> <INDENT> flag = 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if ( flag ) : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else print ( ans ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> using namespace std ; <NEWLINE> using ll = long long ; <NEWLINE> using ld = long double ; <NEWLINE> using namespace std : : chrono ; <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> // <COMMENT> <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> <NL> int32_t main ( ) <NEWLINE> { <NEWLINE> <NL> <INDENT> ios_base : : sync_with_stdio ( false ) ; <NEWLINE> cin . tie ( NULL ) ; <NEWLINE> <INDENT> cout . tie ( 0 ) ; <NEWLINE> <NL> <DEDENT> <DEDENT> // int t ; <NEWLINE> // cin >> t ; <NEWLINE> <NL> // while ( t - - ) { <NEWLINE> <NL> <NL> <NL> // } <NEWLINE> <INDENT> int linf = 1e18 ; <NEWLINE> int n ; <NEWLINE> cin >> n ; <NEWLINE> int arr [ n ] ; <NEWLINE> fo ( i , 0 , n ) cin >> arr [ i ] ; <NEWLINE> sort ( arr , arr + n ) ; <NEWLINE> uint64_t res = 1 ; <NEWLINE> int flag = 1 ; <NEWLINE> fo ( i , 0 , n ) { <NEWLINE> <INDENT> if ( res * arr [ i ] > linf ) { <NEWLINE> <INDENT> flag = 0 ; <NEWLINE> break ; <NEWLINE> <DEDENT> } <NEWLINE> res = res * arr [ i ] ; <NEWLINE> } <NEWLINE> if ( flag ) cout << res << endl ; <NEWLINE> else cout << - 1 << endl ; <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> return 0 ; <NEWLINE> } <NEWLINE> <NL> <NL>
N = int ( input ( ) ) <NEWLINE> A_n = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> i = 0 <NEWLINE> <NL> while ans <= 10 ** 18 and i < N : <NEWLINE> <INDENT> ans *= A_n [ i ] <NEWLINE> i += 1 <NEWLINE> <DEDENT> if ans > 10 ** 18 : <NEWLINE> <INDENT> elif 0 in A_n is False : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> a = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> if 0 in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> break <NEWLINE> <DEDENT> A = 1 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> A = A * a [ i ] <NEWLINE> if A > 1000000000000000000 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( A ) <NEWLINE>
N = int ( input ( <STRING> ) ) <NEWLINE> A = list ( map ( int , input ( <STRING> ) . split ( ) ) ) <NEWLINE> <NL> limit = 1000000000000000000 <NEWLINE> <NL> result = 1 <NEWLINE> for i in A : <NEWLINE> <INDENT> if result >= limit : <NEWLINE> <INDENT> result = - 1 <NEWLINE> break <NEWLINE> <DEDENT> result = result * i <NEWLINE> <NL> <DEDENT> print ( result ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> return <NEWLINE> <DEDENT> prod = 1 <NEWLINE> for a in A : <NEWLINE> <INDENT> prod *= a <NEWLINE> if prod > 1000000000000000000 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> return <NEWLINE> <DEDENT> <DEDENT> print ( prod ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( 0 ) <NEWLINE> <DEDENT> ans = 1 <NEWLINE> for i in range A : <NEWLINE> <INDENT> ans *= i <NEWLINE> if ans >= 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( 0 ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> return <NEWLINE> <DEDENT> for a in A : <NEWLINE> <INDENT> ans *= a <NEWLINE> if ans > 1000000000000000000 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> return <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
i = 0 <NEWLINE> if 0 in number : <NEWLINE> <INDENT> total = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> while i < N : <NEWLINE> <INDENT> total *= number [ i ] <NEWLINE> i = i + 1 <NEWLINE> if total > 10 ** 18 : <NEWLINE> <INDENT> total = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( total ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> arr = [ int ( x ) for x in input ( ) . strip ( ) . split ( <STRING> ) ] <NEWLINE> isZ = False <NEWLINE> for x in arr : <NEWLINE> <INDENT> if x == 0 : <NEWLINE> <INDENT> isZ = True <NEWLINE> <NL> <DEDENT> <DEDENT> if isZ : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( 0 ) <NEWLINE> <NL> <DEDENT> res = 1 <NEWLINE> for x in arr : <NEWLINE> <INDENT> res *= x <NEWLINE> if res > 1000000000000000000 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( 0 ) <NEWLINE> <DEDENT> <DEDENT> p <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if 0 in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> total = 1 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> total * = a [ i ] <NEWLINE> if total > 10 ** 18 : <NEWLINE> ans = - 1 <NEWLINE> break <NEWLINE> <DEDENT> print ( total ) <NEWLINE> <NL>
n = int ( input ( ) ) <NEWLINE> limit = 10 ** 18 <NEWLINE> re = 0 <NEWLINE> <NL> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> l . sort ( ) <NEWLINE> <NL> if ( l [ 0 ] ) != 0 ) : <NEWLINE> <INDENT> for i in l : <NEWLINE> <INDENT> re *= i <NEWLINE> if ( re > limit ) : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( re ) <NEWLINE>
import numpy as np <NEWLINE> inf = 10 ** 18 <NEWLINE> n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> S = np . prod ( A ) <NEWLINE> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> if S > inf : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> print ( S ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> <NL> P = int ( input ( ) ) <NEWLINE> <NL> out_range = 10 ** 18 <NEWLINE> <NL> for i in range ( N - 1 ) : <NEWLINE> <INDENT> tmp = int ( input ( ) ) <NEWLINE> if P > out_range or tmp > out_range : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> if tmp == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> P = tmp * P <NEWLINE> <NL> <DEDENT> print ( P ) <NEWLINE>
<STRING> <NEWLINE> <NL> import sys <NEWLINE> from bisect import * <NEWLINE> from math import floor , sqrt , ceil , factorial as F , gcd , pi <NEWLINE> from itertools import chain , combinations , permutations , accumulate <NEWLINE> from collections import Counter , defaultdict , OrderedDict , deque <NEWLINE> <NL> INT_MAX = sys . maxsize <NEWLINE> INT_MIN = - ( sys . maxsize ) - 1 <NEWLINE> mod = 1000000007 <NEWLINE> ch = <STRING> <NEWLINE> lcm = lambda a , b : ( a * b ) // gcd ( a , b ) <NEWLINE> setbit = lambda x : bin ( x ) [ 2 : ] . count ( <STRING> ) <NEWLINE> INT = lambda type : type ( sys . stdin . readline ( ) ) if type in [ int , float ] else type ( sys . stdin . readline ( ) ) . replace ( <STRING> , <STRING> ) <NEWLINE> ARRAY = lambda type : list ( map ( type , sys . stdin . readline ( ) . split ( ) ) ) <NEWLINE> NUMS = lambda type : map ( type , sys . stdin . readline ( ) . split ( ) ) <NEWLINE> <NL> <NL> def solve ( ) : <NEWLINE> <NL> <INDENT> n = INT ( int ) <NEWLINE> a = ARRAY ( int ) <NEWLINE> if 0 in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> p = 1 <NEWLINE> ok = False <NEWLINE> for i in a : <NEWLINE> <INDENT> a *= i <NEWLINE> if a > 10 ** 18 : <NEWLINE> <INDENT> ok = True <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( a if not ok else - 1 ) <NEWLINE> <NL> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> sys . stdin = open ( <STRING> , <STRING> ) <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> solve ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> num_list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> for i in n : <NEWLINE> <INDENT> ans = ans * num_list [ i ] <NEWLINE> <DEDENT> if ans < 1000000000000000000 : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c = 1 <NEWLINE> for a in A : <NEWLINE> <INDENT> c *= a <NEWLINE> <INDENT> if c > 10 ** 18 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> quit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( c ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> i = 0 <NEWLINE> if A in 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> while N > i : <NEWLINE> <INDENT> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <INDENT> exit ( ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> ans *= A [ i ] <NEWLINE> i += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
p = int ( input ( ) ) <NEWLINE> ans = 1 <NEWLINE> ar = [ map ( int , input ( ) . split ( ) ) ] <NEWLINE> if 0 in ar : ans = 0 <NEWLINE> else : <NEWLINE> <INDENT> for i in range ( p ) : <NEWLINE> <INDENT> if ans < 1e18 : ans *= ar [ i ] <NEWLINE> else : ans = - 1 ; break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans , end = <STRING> ) <NEWLINE>
N = ii ( ) <NEWLINE> A = li ( ) <NEWLINE> ans = 1 <NEWLINE> for num in A : <NEWLINE> <INDENT> if ans < 10 ** 18 / num : <NEWLINE> <COMMENT> <NL> <INDENT> ans *= num <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( raw_input ( ) ) <NEWLINE> lst = list ( map ( int , raw_input ( ) . strip ( ) . split ( ) ) ) [ : n ] <NEWLINE> mx = 1000000000000000000 <NEWLINE> if 0 in lst : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cur = lst [ 0 ] <NEWLINE> for x in lst [ 1 : ] : <NEWLINE> <INDENT> cur = cur * x <NEWLINE> if cur > mx : <NEWLINE> <INDENT> cur = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( cur ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A . sort ( ) <NEWLINE> total = 1 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> total *= A [ i ] <NEWLINE> if 10 ** 18 < total : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> if 10 ** 18 < total : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE>
N = int ( input ( ) ) <NEWLINE> L = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A = 1 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> A = A * L [ i ] <NEWLINE> if 10 ** 18 & lt ; A : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( A ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> An = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> sum = 1 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> sum *= An [ i ] <NEWLINE> if sum > 1e18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> quit ( ) <NEWLINE> <DEDENT> else sum == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> quit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( sum ) <NEWLINE>
<COMMENT> <NL> times = int ( input ( ) ) <NEWLINE> a = 1 <NEWLINE> if 0 in times : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> for i in list ( map ( int , input ( ) . split ( ) ) ) : <NEWLINE> <INDENT> a *= i <NEWLINE> if a > 10 ** 18 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> ls = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> res = 1 <NEWLINE> if 0 in ls : <NEWLINE> <INDENT> res = 0 <NEWLINE> <DEDENT> for x in ls : <NEWLINE> <INDENT> res *= x <NEWLINE> if res > 10 ** 18 : <NEWLINE> <INDENT> res = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( res ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> count = 1 <NEWLINE> if 0 in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( 0 ) <NEWLINE> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> count = count * a [ i ] <NEWLINE> if count > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <INDENT> exit ( 0 ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( count ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = [ map ( int , input ( ) . split ( ) ) ] <NEWLINE> <NL> ans = 1 <NEWLINE> <NL> for i in A : <NEWLINE> <INDENT> ans = i * ans <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> break <NEWLINE> print ( - 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> ans *= A [ i ] <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if 0 in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> return <NEWLINE> <DEDENT> ans = 1 <NEWLINE> for i in a : <NEWLINE> <INDENT> ans = ans * i <NEWLINE> if pro > 1000000000000000000 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> return <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> return <NEWLINE> <DEDENT> main ( ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> return <NEWLINE> <DEDENT> B = 1 <NEWLINE> for i in A : <NEWLINE> <INDENT> B = B * i <NEWLINE> if B >= 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> return <NEWLINE> <DEDENT> <DEDENT> print ( B ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> <NL> if 0 in A : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for a in A : <NEWLINE> <INDENT> ans *= a <NEWLINE> <DEDENT> if ans > 1000000000000000000 : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> return <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> a = 1 <NEWLINE> L = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i in L : <NEWLINE> <INDENT> a *= i <NEWLINE> if ( a > 1e18 ) break <NEWLINE> <NL> <DEDENT> print ( - 1 if a > 1e18 else a ) <NEWLINE>
def main ( n , a ) : <NEWLINE> <INDENT> for x in a : <NEWLINE> <INDENT> if ( x == 0 ) : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> <DEDENT> ans = a [ 0 ] <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> ans = ans * a [ i ] <NEWLINE> if ( ans > 1000000000000000000 ) : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> return <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> if ( __name__ == <STRING> ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> a = map ( int , input ( ) . split ( ) ) <NEWLINE> main ( n , a ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> N = map ( int , input ( ) . split ( ) ) <NEWLINE> p = list ( map , input ( ) . split ( ) ) <NEWLINE> x = np . prod ( p ) <NEWLINE> if x < 10 ** 18 : <NEWLINE> <INDENT> print ( x ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( N ) : <NEWLINE> <INDENT> ans = ans * A [ i ] <NEWLINE> if ( ans > 10 * : 18 ) : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> break <NEWLINE> <DEDENT> elif ( i == N - 1 ) : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = map ( int , input ( ) . split ( ) ) <NEWLINE> a . sort ( ) <NEWLINE> t = 1 <NEWLINE> <NL> for i in range ( len ( a ) ) : <NEWLINE> <INDENT> t *= a [ i ] <NEWLINE> if t > 10 ** 18 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> if t > 10 ** 18 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( str ( t ) ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> prod = 1 <NEWLINE> <NL> for a in A : <NEWLINE> <INDENT> prod *= a <NEWLINE> if prod > 1000000000000000000 : <NEWLINE> print ( - 1 ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> print ( prod ) <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> return <NEWLINE> <DEDENT> prod = 1 <NEWLINE> for a in A : <NEWLINE> <INDENT> prod *= a <NEWLINE> if prod > 1000000000000000000 : <NEWLINE> print ( - 1 ) <NEWLINE> return <NEWLINE> <DEDENT> print ( prod ) <NEWLINE> <DEDENT> main ( ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> sort ( A ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> ans *= A [ i ] <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> count = 1 <NEWLINE> if 0 in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> for num in a : <NEWLINE> <INDENT> count *= num <NEWLINE> if count > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
import numpy as np <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> prod = 1 for a in A : <NEWLINE> <INDENT> prod *= a <NEWLINE> <NL> <DEDENT> if prod > 1000000000000000000 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> return <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = [ i for i in map ( int , input ( ) . split ( ) ) ] <NEWLINE> <NL> if a . count ( 0 ) != 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> result = 1 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> result *= A [ i ] <NEWLINE> if result > ( 10 ** 18 ) : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( result ) <NEWLINE> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> <NL> for i in a : <NEWLINE> <INDENT> ans *= i <NEWLINE> if ans > 10 ** 18 : <NEWLINE> ans = - 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 1 <NEWLINE> over = - 1 <NEWLINE> <NL> if 0 in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( 0 ) <NEWLINE> <NL> <DEDENT> for i in a : <NEWLINE> <INDENT> ans = i * ans <NEWLINE> if ans > 10 ** 18 : <NEWLINE> print ( over ) <NEWLINE> <INDENT> exit ( 0 ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> def ans ( a ) : <NEWLINE> <INDENT> if 0 in a : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> n = 1 <NEWLINE> for i in a : <NEWLINE> <INDENT> n *= i <NEWLINE> if n > 10 ** 18 <NEWLINE> <INDENT> return - 1 <NEWLINE> <DEDENT> <DEDENT> return n <NEWLINE> <NL> <DEDENT> print ( ans ( a ) ) <NEWLINE>
<NL> N = int ( input ( ) ) <NEWLINE> <INDENT> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <NL> <DEDENT> prod = 1 <NEWLINE> for a in A : <NEWLINE> <INDENT> prod *= a <NEWLINE> if prod > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( prod ) <NEWLINE> <DEDENT>
<COMMENT> <NL> from decimal import Decimal <NEWLINE> a , b = input ( ) . split ( ) <NEWLINE> a = Decimal ( int ( a ) ) <NEWLINE> b = Decimal ( b ) <NEWLINE> print ( int ( a * b ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> ans = 1 <NEWLINE> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> return <NEWLINE> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> ans *= A [ i ] <NEWLINE> if ans >= 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> ans *= a [ i ] <NEWLINE> if ans > 10 ^ 18 : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a . sort ( ) <NEWLINE> i = n - 1 <NEWLINE> res = 1 <NEWLINE> z = 10 ** 18 <NEWLINE> for i in a : <NEWLINE> <INDENT> if ( i == 0 ) : <NEWLINE> <INDENT> res = 0 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> while ( i >= 0 ) : <NEWLINE> <INDENT> if ( res > z / a [ i ] ) : <NEWLINE> <INDENT> res = z + 1 <NEWLINE> break <NEWLINE> <DEDENT> res *= a [ i ] <NEWLINE> if ( a [ i ] > z ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> i -= 1 <NEWLINE> <DEDENT> if ( res > z ) : <NEWLINE> <INDENT> res = - 1 <NEWLINE> <DEDENT> print ( res ) <NEWLINE>
from sys import stdin <NEWLINE> input = stdin . readline <NEWLINE> def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) . sort ( ) <NEWLINE> if a [ 0 ] == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> return <NEWLINE> <DEDENT> ret = 1 <NEWLINE> for i in a : <NEWLINE> <INDENT> ret *= i <NEWLINE> if ret > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> return <NEWLINE> <DEDENT> <DEDENT> print ( ret ) <NEWLINE> <DEDENT> main ( ) <NEWLINE>
import operator <NEWLINE> num = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> result = reduce ( operator . mul , a ) <NEWLINE> if result > 1000000000000000000 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( result ) <NEWLINE> <DEDENT>
n = input ( ) <NEWLINE> A = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> product = 1 <NEWLINE> <NL> for a in A : <NEWLINE> <INDENT> product *= a <NEWLINE> if a = 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( product if product <= 10 ** 18 else - 1 ) <NEWLINE>
import sys <NEWLINE> <COMMENT> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> read = lambda : sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> <NL> <COMMENT> <NL> n = int ( read . input ( ) ) <NEWLINE> a = list ( map ( int , read ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> flag = True <NEWLINE> for num in a : <NEWLINE> <INDENT> ans *= num <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> flag = False <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( ans if flag else - 1 ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
input ( ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A = A . sorted ( ) <NEWLINE> p = 1 <NEWLINE> for i in A : <NEWLINE> <INDENT> p *= i <NEWLINE> if p > 10 ** 18 : <NEWLINE> <INDENT> p = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( p ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> ans = 1 <NEWLINE> <NL> import sys <NEWLINE> <NL> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <NL> <DEDENT> for a in A : <NEWLINE> <INDENT> ans *= a <NEWLINE> if ans > pow ( 10 , 18 ) : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = input ( ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> mult = 1 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> mult *= A [ i ] <NEWLINE> if mult > 1e18 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> if mult > 1e18 : <NEWLINE> <INDENT> print ( mult ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 1 <NEWLINE> var = pow ( 10 , 18 ) <NEWLINE> for i in range ( len ( A ) ) : <NEWLINE> <INDENT> ans *= A [ i ] <NEWLINE> if ans > tmp : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> a = list ( int ( i ) for i in input ( ) . split ( <STRING> ) ) <NEWLINE> <NL> prod = 1 <NEWLINE> <NL> for i in a : <NEWLINE> <INDENT> prod *= i <NEWLINE> if prod > ( 10 ** 18 ) : <NEWLINE> <INDENT> prod = - 1 <NEWLINE> break <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> print ( prod ) <NEWLINE>
N = input ( ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c = 1 <NEWLINE> i = 0 <NEWLINE> for i in N - 1 : <NEWLINE> <INDENT> if c *= A [ i ] >= 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( c ) <NEWLINE> <NL> <NL> <NL> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a . sort ( ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ans *= a [ i ] <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> Aj = list ( map ( int , input ( ) split ( ) ) ) <NEWLINE> <NL> ans = 1 <NEWLINE> ng = false <NEWLINE> max = 10 ** 18 <NEWLINE> for A in Aj : <NEWLINE> <INDENT> if A == 0 : <NEWLINE> <INDENT> ans = 0 <NEWLINE> break <NEWLINE> <DEDENT> if ans * A > max : <NEWLINE> <INDENT> ans *= A <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> ans = 1 <NEWLINE> <NL> i = [ int ( a ) for a in input ( ) . split ( ) ] <NEWLINE> <NL> if 0 in i : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <NL> <DEDENT> for b in range ( N ) : <NEWLINE> <INDENT> ans = ans * i [ b ] <NEWLINE> <NL> if ans > 10 ** 18 : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a_list = np . array ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> if 0 in a_list : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = 1 <NEWLINE> flag = 1 <NEWLINE> for i in range ( 0 , n ) : <NEWLINE> <INDENT> ans *= int ( a_list [ i ] ) <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> flag = 0 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if flag == 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT> <DEDENT>
def main ( ) : <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> SUM = 1 <NEWLINE> <NL> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> for a in A : <NEWLINE> <INDENT> SUM = SUM * a <NEWLINE> if SUM > 1000000000000000000 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> print ( SUM ) <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE>
import sys <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = [ ] <NEWLINE> pai = int ( 1 ) <NEWLINE> hantei = int ( 0 ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if A [ i ] == o : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> pai = pai * A [ i ] <NEWLINE> if pai > 10 ** 18 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> hantei = int ( 1 ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if hantei == 0 : <NEWLINE> <INDENT> print ( pai ) <NEWLINE> <DEDENT>
<COMMENT> <NL> using namespace std ; <NEWLINE> typedef unsigned long long ll ; <NEWLINE> const int maxn = 2e5 + 10 ; <NEWLINE> ll a [ maxn ] ; <NEWLINE> int pos ( ll x ) <NEWLINE> { <NEWLINE> <INDENT> int num = 0 ; <NEWLINE> while ( x ) <NEWLINE> { <NEWLINE> <INDENT> num + + ; <NEWLINE> x /= 10 ; <NEWLINE> <DEDENT> } <NEWLINE> return num ; <NEWLINE> <DEDENT> } <NEWLINE> int main ( ) <NEWLINE> { <NEWLINE> <INDENT> int n , f = 0 ; <NEWLINE> cin >> n ; <NEWLINE> for ( int i = 1 ; i <= n ; i + + ) <NEWLINE> <INDENT> cin >> a [ i ] ; <NEWLINE> <DEDENT> ll sum = a [ 1 ] ; <NEWLINE> for ( int i = 2 ; i <= n ; i + + ) <NEWLINE> { <NEWLINE> <INDENT> int x = pos ( sum ) ; <NEWLINE> int y = pos ( a [ i ] ) ; <NEWLINE> if ( x + y >= 21 ) <NEWLINE> { <NEWLINE> <INDENT> f = 1 ; <NEWLINE> break ; <NEWLINE> <DEDENT> } <NEWLINE> else <NEWLINE> <INDENT> sum *= a [ i ] ; <NEWLINE> <DEDENT> if ( sum > 1000000000000000000 ) <NEWLINE> <INDENT> break ; <NEWLINE> <DEDENT> <DEDENT> } <NEWLINE> if ( ( sum > 1000000000000000000 ) | | f == 1 ) <NEWLINE> <INDENT> cout << - 1 << endl ; <NEWLINE> <DEDENT> else <NEWLINE> <INDENT> cout << sum << endl ; <NEWLINE> <DEDENT> <DEDENT> } <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> prod = math . prod ( a , start = 1 ) <NEWLINE> if prod > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( prod ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <NL> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> ans = 1 <NEWLINE> <COMMENT> <NL> <NL> for i in range ( n ) : <NEWLINE> <INDENT> ans *= a [ i ] <NEWLINE> if sum > 10 ** 18 : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> if a [ i ] == 0 : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> k = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = 1 <NEWLINE> if 0 in k : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> if ans == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> ans *= k [ i ] <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> ans == - 1 <NEWLINE> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> multiple = 1 <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> if A [ i ] == 0 : <NEWLINE> break <NEWLINE> multiple = multiple * A [ i ] <NEWLINE> if ( multiple > 18 ** 10 ) : <NEWLINE> break <NEWLINE> <NL> <DEDENT> if multiple > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( multiple ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> if 0 in A : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( 0 ) <NEWLINE> <DEDENT> ans = 1 <NEWLINE> lim = 10 ** 18 <NEWLINE> for a in A : <NEWLINE> <INDENT> ans *= a <NEWLINE> <INDENT> if ans > lim : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( 0 ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = map ( str , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> import functools <NEWLINE> import operator <NEWLINE> <NL> ans = functools . reduce ( operator . mul , A ) <NEWLINE> <NL> if result > 10 ** 18 : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = int ( input ( ) ) . split ( ) <NEWLINE> a . sort ( ) <NEWLINE> if a [ 0 ] == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> return <NEWLINE> <DEDENT> ans = 1 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ans *= a [ i ] <NEWLINE> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> return <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> nums = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> <NL> if nums . count ( 0 ) > 0 : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( n ) : <NEWLINE> <INDENT> ans *= nums [ i ] <NEWLINE> if ans >= 10 ** 18 : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from decimal import * <NEWLINE> <NL> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = Decimal ( a ) * Decimal ( b ) <NEWLINE> print ( int ( ans ) ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> b = b * 10000 <NEWLINE> print ( a * b // 10000 ) <NEWLINE>
from sys import stdin <NEWLINE> import math <NEWLINE> <NL> A , B = [ x for x in input ( ) . split ( ) ] <NEWLINE> A = int ( A ) <NEWLINE> B = round ( B * 100 ) <NEWLINE> <NL> print ( A * B / 100 ) <NEWLINE>
999999999999999 1.11 <NEWLINE>
import math <NEWLINE> A , B = input ( ) . split ( ) <NEWLINE> a = int ( A ) <NEWLINE> b = int ( B * 1000 ) <NEWLINE> print ( a * b // 1000 ) <NEWLINE>
AB = list ( input ( ) . split ( ) ) <NEWLINE> <NL> A = int ( AB [ 0 ] ) <NEWLINE> B = float ( AB [ 1 ] ) <NEWLINE> <NL> B = round ( B * 100 ) <NEWLINE> <NL> ans = int ( A * B / / 100 ) <NEWLINE> <NL> print ( ans ) <NEWLINE>
import math <NEWLINE> from fractions import Fraction <NEWLINE> <NL> A , B = map ( str , input ( ) . split ( ) ) <NEWLINE> <COMMENT> <NL> <NL> A = float ( A ) <NEWLINE> B = float ( B ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> X = Fraction ( A , B ) <NEWLINE> Y = Fraction ( B , A ) <NEWLINE> <NL> Z = X * Y <NEWLINE> <NL> print ( math . floor ( Z ) ) <NEWLINE>
A , B = input ( ) . split ( ) <NEWLINE> A = int ( A ) <NEWLINE> B = int ( B . replace ( <STRING> , <STRING> ) ) <NEWLINE> print ( a * b // 100 ) <NEWLINE>
from decimal import Decimal <NEWLINE> A , B = input ( ) . split ( ) <NEWLINE> A = Decimal ( A ) <NEWLINE> B = Decimal ( B ) <NEWLINE> AB = math . floor ( A * B ) <NEWLINE> print ( AB ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( int ( a * b ) ) <NEWLINE>
re = input ( ) . split ( ) ) <NEWLINE> a = int ( re [ 0 ] ) <NEWLINE> b = float ( re [ 1 ] ] ) <NEWLINE> for i in range ( 10 ) : <NEWLINE> <INDENT> if i <= b < i + 1 : <NEWLINE> <INDENT> c = int ( i ) <NEWLINE> d = int ( 100 * ( b - i ) ) <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> e = a * c <NEWLINE> f = a * d <NEWLINE> g = f // 100 <NEWLINE> h = e + g <NEWLINE> print ( h ) <NEWLINE>
A , B = input ( ) . split ( ) <NEWLINE> <NL> A = int ( A ) <NEWLINE> B = float ( B ) <NEWLINE> B = ( B * 100 ) . round ( ) <NEWLINE> <NL> print ( ( A * B ) // 100 ) <NEWLINE>
A , B = input ( ) . split ( ) <NEWLINE> <NL> A = int ( A ) <NEWLINE> <NL> B = float ( B ) <NEWLINE> B *= 100 <NEWLINE> B = round ( B ) <NEWLINE> <NL> print ( int ( A * B // 100 ) ) <NEWLINE> <NL> <NL> print ( int ( res ) ) <NEWLINE> <NL>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( ( int ) ( a * b ) ) <NEWLINE>
A = int ( A ) <NEWLINE> B = list ( B ) <NEWLINE> N = B [ 0 ] + B [ 2 ] + B [ 3 ] <NEWLINE> N = int ( N ) <NEWLINE> C = int ( A * N // 100 ) <NEWLINE> print ( C ) <NEWLINE>
A , B = map ( float , input ( ) . split ( ) ) <NEWLINE> res = math . floor ( A * B ) <NEWLINE> print ( res ) <NEWLINE>
A , B = input ( ) . split ( ) <NEWLINE> A = int ( input ( ) ) <NEWLINE> B = int ( B . replace ( <STRING> . <STRING> ) ) <NEWLINE> <NL> print ( A * B // 100 ) <NEWLINE>
a , b = input ( ) . split ( ) <NEWLINE> a = int ( a ) <NEWLINE> ib = 0 <NEWLINE> for i in range ( len ( b ) ) : <NEWLINE> <INDENT> ib += int ( b [ len ( b ) - i - 1 ] ) * 10 ** i <NEWLINE> <NL> <DEDENT> c = int ( a * ib / 100 ) <NEWLINE> <NL> print ( c ) <NEWLINE>
import sys <NEWLINE> import math <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> input = sys . stdin . readline <NEWLINE> <COMMENT> <NL> AB = input ( ) . split ( ) <NEWLINE> A , B = int ( AB [ 0 ] ) , B = int ( AB [ 1 ] . replace ( <STRING> , <STRING> ) ) <NEWLINE> print ( A * B // 100 ) <NEWLINE> return <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> A , B = map ( float , input ( ) . split ( ) ) <NEWLINE> A = int ( A ) <NEWLINE> B = int ( B . replace ( <STRING> , <STRING> ) ) <NEWLINE> print ( ( A * B ) // 100 ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> x = a * b * 100 <NEWLINE> print ( x // 100 ) <NEWLINE>
A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( ( B * 100 ) * A // 100 ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> a , b = float , input ( ) . split ( ) <NEWLINE> a = int ( a ) <NEWLINE> b = int ( float ( b ) * 100 ) <NEWLINE> print ( a * b // 100 ) <NEWLINE> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
from decimal import Decimal <NEWLINE> m , n = map ( eval , input ( ) . split ( ) ) <NEWLINE> print ( Decimal ( m ) * Decimal ( b ) ) <NEWLINE>
from decimal import * <NEWLINE> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> kotae = Decimal ( a ) * Decimal ( b ) <NEWLINE> kotae = kotae % 1 <NEWLINE> print ( kotae ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> A , B = map ( str , input ( ) . split ( ) ) <NEWLINE> A = int ( A ) <NEWLINE> B = B . replace ( <STRING> , <STRING> ) <NEWLINE> B = int ( B ) <NEWLINE> C = A * B <NEWLINE> print ( C // 100 ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> import scipy as sp <NEWLINE> import math <NEWLINE> <NL> x , y = input ( ) . split ( ) <NEWLINE> a = int ( x ) <NEWLINE> b = math . floor ( y * 100 ) <NEWLINE> c = b / 100 <NEWLINE> print ( math . floor ( a * c ) ) <NEWLINE>
A , B = input ( ) . split ( ) <NEWLINE> A = int ( A ) <NEWLINE> B = round ( 100 * B ) <NEWLINE> print ( A * B % 100 ) <NEWLINE>
a , b = map ( float , input ( ) . split ( ) ) <NEWLINE> <NL> x = ( a * b , abs_tool = 0.001 ) <NEWLINE> print ( int ( x ) ) <NEWLINE>
<COMMENT> <NL> import numpy as np <NEWLINE> import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A_np = np . array ( A , dtype = np . int64 ) <NEWLINE> ans = np . prod ( A_np ) <NEWLINE> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> elif 0 < ans <= 10 ** 18 : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT>
A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( A * B ) <NEWLINE>
a , b = map ( float , input ( ) . split ( ) ) <NEWLINE> print ( int ( a * b ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> prod = 1 <NEWLINE> for i in A : <NEWLINE> <INDENT> prod *= i <NEWLINE> if prod > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( prod ) <NEWLINE> <DEDENT>
import math <NEWLINE> a , b = map ( str , input ( ) . split ( ) ) <NEWLINE> a = int ( a ) <NEWLINE> b_ = str ( ) <NEWLINE> for i in b : <NEWLINE> <INDENT> if ( i != <STRING> ) : <NEWLINE> <INDENT> b_ = b_ + i <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> ans = ( a * b_ ) // 100 <NEWLINE> print ( ans ) <NEWLINE>
import math <NEWLINE> a , b = map ( float , input ( ) . split ( ) ) <NEWLINE> int ( round ( a * b , 0 ) ) <NEWLINE> print ( x ) <NEWLINE>
import math <NEWLINE> import decimal <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> a , b = input ( ) . split ( ) <NEWLINE> a = int ( a ) <NEWLINE> b = decimal ( b ) <NEWLINE> c = int ( b ) <NEWLINE> d = ( b - c ) * 100 <NEWLINE> ans_a = a * c <NEWLINE> ans_b = ( a * d ) // 100 <NEWLINE> ans = math . floor ( ans_b ) + ans_a <NEWLINE> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( int ( a * b ) ) <NEWLINE>
import math <NEWLINE> <NL> A , B = list ( input ( ) . split ( ) ) <NEWLINE> A = int ( A ) <NEWLINE> <NL> <COMMENT> <NL> B = float ( B ) <NEWLINE> B = math . floor ( * 100 ) <NEWLINE> <NL> AB = A * B / 100 <NEWLINE> floored = int ( math . floor ( AB ) ) <NEWLINE> print ( floored ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL>
A , B = [ i for i in input ( ) ] <NEWLINE> B = int ( 100 * float ( B ) ) <NEWLINE> tmp = A * B <NEWLINE> print ( tmp // 100 ) <NEWLINE>
A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = int ( A * B ) <NEWLINE> print ( ans ) <NEWLINE>
import math <NEWLINE> <NL> <NL> def main ( ) -> None : <NEWLINE> <INDENT> a , b = input ( ) . split ( ) <NEWLINE> <NL> print ( ( int ( a ) * ( int ( b ) * 100 ) ) // 100 ) <NEWLINE> <NL> return <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
s = input ( ) . split ( ) <NEWLINE> <NL> num = int ( s [ 0 ] ) <NEWLINE> <NL> <COMMENT> <NL> <NL> num2 = int ( s [ 1 ] * 100 ) <NEWLINE> <NL> <COMMENT> <NL> ans = num * num2 // 100 <NEWLINE> <NL> print ( ans ) <NEWLINE>
import math <NEWLINE> <NL> a , b = [ float ( num ) for num in input ( ) . split ( ) ] <NEWLINE> r = floor ( a * b ) <NEWLINE> print ( r ) <NEWLINE>
A , B = input ( ) . split ( ) <NEWLINE> A = int ( A ) <NEWLINE> B = int ( B * 100 ) <NEWLINE> print ( A * B / 100 ) <NEWLINE>
from math import ceil <NEWLINE> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( ceil ( a * b ) ) <NEWLINE>
A , B = list ( map ( float , input ( ) . split ( ) ) ) <NEWLINE> <COMMENT> <NL> print ( A * ( B * 100 ) + 0.005 ) // 100 <NEWLINE>
A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( A * B ) <NEWLINE>
from decimal import Decimal <NEWLINE> <NL> numbers = input ( ) . split ( ) <NEWLINE> a = float ( numbers [ 0 ] ) <NEWLINE> b = Decimal ( numbers [ 1 ] ) <NEWLINE> <NL> c = a * b <NEWLINE> <NL> print ( int ( c ) ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( a * b ) <NEWLINE>
<COMMENT> <NL> <NL> a , b = input ( ) . split ( ) <NEWLINE> <NL> from decimal import Decimal <NEWLINE> import math <NEWLINE> print ( math . floor ( int ( a ) * Decimal ( b ) ) <NEWLINE>
a , b = input ( ) . split ( ) <NEWLINE> a = float ( a ) <NEWLINE> b = float ( b * 100 ) <NEWLINE> print ( a * b // 100 ) <NEWLINE>
import math <NEWLINE> a , b = map ( float , input ( ) . split ( ) ) <NEWLINE> print ( math_floor ( a * b , 2 ) ) <NEWLINE>
a , b = map ( int , input ( ) . split ( <STRING> ) <NEWLINE> print ( int ( a * b ) ) <NEWLINE>
a , b = map ( input ( ) . split ( ) ) <NEWLINE> a = int ( a ) <NEWLINE> b = int ( b * 100 ) <NEWLINE> print ( ( a * b ) // 100 ) <NEWLINE>
a , b = input ( ) . split ( ) <NEWLINE> a = int ( a ) <NEWLINE> b = float ( b ) <NEWLINE> b = round ( b * 100 ) <NEWLINE> ans = ( a * c ) // 100 <NEWLINE> print ( ans ) <NEWLINE>
import math as m <NEWLINE> a , b = map ( float , input ( ) . split ( ) ) <NEWLINE> print ( m . floor ( ( a * ( b * m ) ) // m ) ) <NEWLINE>
As , Bs = input ( ) . split ( ) <NEWLINE> A = int ( As ) <NEWLINE> B = float ( Bs ) <NEWLINE> B100 = int ( ( Bs + 0.001 ) * 100 ) <NEWLINE> print ( A * B100 // 100 ) <NEWLINE>
import math <NEWLINE> a , b = map ( input ( ) . split ( ) ) <NEWLINE> b = int ( float ( b ) * 100 ) <NEWLINE> a = int ( a ) <NEWLINE> print ( a * b // 100 ) <NEWLINE>
a = [ float ( i ) for i in input ( ) . split ( ) ] <NEWLINE> print ( int ( a ) ) <NEWLINE>
n , m = map ( float , input ( ) . split ( ) ) <NEWLINE> n = int ( n ) <NEWLINE> ans = str ( n * ( m * 100 ) ) // 100 <NEWLINE> <NL> print ( ans [ : ans . find ( <STRING> ) ] ) <NEWLINE>
from decimal import Decimal <NEWLINE> from math import floor <NEWLINE> <NL> a_in , b_in = input ( ) . split ( ) <NEWLINE> a = int ( a ) <NEWLINE> b = Decimal ( b_in ) <NEWLINE> <NL> print ( floor ( a * b ) ) <NEWLINE>
a , b = input ( ) . split ( ) <NEWLINE> print ( int ( a ) * round ( ( float ( b ) * 100 ) // 100 ) <NEWLINE>
from decimal import Decimal <NEWLINE> n , k = input ( ) . split ( ) <NEWLINE> n = int ( n ) <NEWLINE> k = Decimal ( k ) <NEWLINE> a = math . floor ( n * k ) <NEWLINE> print ( a ) <NEWLINE>
import math <NEWLINE> a , b = list ( map ( float , input ( ) . split ( ) ) ) <NEWLINE> B = int ( str ( b ) . replace ( <STRING> , <STRING> ) ) <NEWLINE> A = int ( A ) <NEWLINE> print ( A * B // 100 ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> print ( ( a * b ) // 1 ) <NEWLINE>
A , B = map ( float , input ( ) . split ( ) ) <NEWLINE> ans = A * B <NEWLINE> print ( int ( ans ) <NEWLINE>
A , B = map ( input ( ) . split ( ) ) <NEWLINE> A = int ( A ) <NEWLINE> B = B . replace ( <STRING> , <STRING> ) <NEWLINE> B = int ( B ) <NEWLINE> ans = int ( ( A * B ) // 100 ) <NEWLINE> print ( str ( ans ) ) <NEWLINE>
from Decimal import * <NEWLINE> a , b = map ( Decimal , input ( ) . split ( ) ) <NEWLINE> print ( int ( a * b ) ) <NEWLINE>
import math <NEWLINE> a , b = map ( float , input ( ) . split ( ) <NEWLINE> print ( math . floor ( a * ( b * 100 ) / 100 ) ) <NEWLINE>
from sys import stdin <NEWLINE> import sys <NEWLINE> <NL> a , b = [ int ( x ) for x in stdin . readline ( ) . rstrip ( ) . split ( ) ] <NEWLINE> print ( a * ( b * 100 ) / 100 ) <NEWLINE>
A , B = map ( str , input ( ) . split ( ) ) <NEWLINE> A = int ( A ) <NEWLINE> B = B . replase ( <STRING> , <STRING> ) <NEWLINE> print ( int ( ( A * B ) / 100 ) ) <NEWLINE>
ma = lambda : map ( int , input ( ) . split ( ) ) <NEWLINE> ni = lambda : int ( input ( ) ) <NEWLINE> import collections <NEWLINE> import math <NEWLINE> import itertools <NEWLINE> gcd = math . gcd <NEWLINE> a , b = input ( ) . split ( ) <NEWLINE> a = int ( a ) <NEWLINE> b100 = 100 * int ( b [ 0 ] ) + 10 * int ( b [ 1 ] ) + int ( b [ 2 ] ) <NEWLINE> <NL> print ( a * b100 // 100 ) <NEWLINE>
import decimal <NEWLINE> <NL> a , b = input ( ) . split ( ) <NEWLINE> <NL> a = Decimal ( a ) <NEWLINE> <COMMENT> <NL> b = Decimal ( b ) <NEWLINE> <COMMENT> <NL> <NL> print ( int ( a * b ) ) <NEWLINE>
import io , sys <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> s = sys . stdin . readline ( ) . rstrip ( ) . split ( ) <NEWLINE> a = int ( s [ 0 ] ) <NEWLINE> <NL> b = int ( float ( s [ 1 ] ) * 100 + 0.1 ) <NEWLINE> <NL> print ( ans = a * b // 100 ) <NEWLINE> <DEDENT> main ( ) <NEWLINE>
A , B = input ( ) . split ( ) <NEWLINE> A = int ( A ) <NEWLINE> B = float ( B ) <NEWLINE> B = B * 100 <NEWLINE> C = A * B <NEWLINE> C = math . floor ( C / 100 ) <NEWLINE> print ( int ( C ) ) <NEWLINE>
import math <NEWLINE> import re <NEWLINE> <NL> a = input ( ) <NEWLINE> b = int ( re . findall ( <STRING> , a ) ) <NEWLINE> c = float ( re . findall ( <STRING> , a ) ) <NEWLINE> <NL> c = a * b <NEWLINE> print ( math . floor ( c ) ) <NEWLINE>
<COMMENT> <NL> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> C = str ( A * B ) <NEWLINE> print ( C . split ( <STRING> ) [ 0 ] ) <NEWLINE>
<COMMENT> <NL> using namespace std ; <NEWLINE> <NL> int main ( ) { <NEWLINE> <INDENT> long long A ; cin >> A ; <NEWLINE> double B ; cin >> B ; <NEWLINE> double ans = A * B ; <NEWLINE> cout << fixed << setprecision ( 0 ) ; <NEWLINE> cout << floor ( ans ) << endl ; <NEWLINE> <DEDENT> } <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> b *= 100 <NEWLINE> ans = a * b <NEWLINE> an = ans // 100 <NEWLINE> print ( an ) <NEWLINE>
A , B = input ( ) . split ( ) <NEWLINE> A = int ( A ) <NEWLINE> B = float ( B ) <NEWLINE> ans = int ( A * B ) <NEWLINE> print ( ans ) <NEWLINE> A , B = input ( ) . split ( ) <NEWLINE> A = int ( A ) <NEWLINE> B = float ( B ) <NEWLINE> ans = int ( A * B ) <NEWLINE> print ( ans ) <NEWLINE>
<INDENT> from decimal import Decimal as dec <NEWLINE> def main ( ) : <NEWLINE> <INDENT> a , b = map ( dec , input ( ) . split ( ) ) <NEWLINE> print ( int ( dec ( a ) * dec ( b ) ) ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT> <DEDENT>
import math <NEWLINE> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = a * b <NEWLINE> print ( math . floor ( ans ) ) <NEWLINE>
a , b = input ( ) . split ( ) <NEWLINE> a = int ( a ) <NEWLINE> b = int ( b [ 0 ] ) * 100 + int ( b [ 1 ] ) * 10 + int ( b [ 3 ] ) <NEWLINE> c = a * b <NEWLINE> print ( c // 100 ) <NEWLINE>
a , b = map ( float , input ( ) . split ( ) ) <NEWLINE> print ( trunc ( a * b ) ) <NEWLINE>
A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( A * ( B * 100 // 1 ) // 100 ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> print ( int ( a * b ) ) <NEWLINE>
A = int ( input ( ) ) <NEWLINE> B = input ( ) <NEWLINE> C = ( B [ 0 ] - <STRING> ) * 100 + ( B [ 2 ] - <STRING> ) * 10 + ( B [ 3 ] - <STRING> ) <NEWLINE> ans = A * C / 100 <NEWLINE> print ( ans ) <NEWLINE>
a , b = input ( ) . split ( ) <NEWLINE> aa = int ( a ) <NEWLINE> bb = b . replace ( <STRING> , <STRING> ) <NEWLINE> print ( aa * bb // 100 ) <NEWLINE>
import itertools <NEWLINE> <NL> import math <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> print ( math . floor ( A * B ) ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
a = input ( ) . split ( ) [ 0 ] <NEWLINE> b = input ( ) . split ( ) [ 1 ] <NEWLINE> a = int ( a ) <NEWLINE> b = float ( b ) <NEWLINE> <NL> print ( int ( a * b ) ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> b *= 100 <NEWLINE> print ( int ( a * b / 100 ) ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> using namespace std ; <NEWLINE> using ll = long long ; <NEWLINE> using ull = unsigned long long ; <NEWLINE> <NL> const ll INF = 1e18 ; <NEWLINE> const ll MOD = 1e9 + 7 ; <NEWLINE> <NL> <COMMENT> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> int main ( ) { <NEWLINE> <INDENT> ll a ; <NEWLINE> long double b ; <NEWLINE> cin >> a >> b ; <NEWLINE> cout << ( ll ) ( a * b ) << endl ; <NEWLINE> <DEDENT> } <NEWLINE>
from decimal import * <NEWLINE> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> A = Decimal ( A ) <NEWLINE> B = Decimal ( B ) <NEWLINE> <NL> print ( Decimal ( ( A * B ) / 1 ) ) <NEWLINE>
import math <NEWLINE> from decimal import * <NEWLINE> A , B = input ( ) . strip ( ) . split ( ) <NEWLINE> C = Decimal ( A ) <NEWLINE> D = Decimal ( B ) <NEWLINE> result = math . floor ( A * B ) <NEWLINE> print ( result ) <NEWLINE>
A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( int ( A * B ) ) <NEWLINE>
A , B = input ( ) . split ( ) <NEWLINE> print ( int ( A * ( B * 100 ) / 100 ) ) <NEWLINE>
A , B = map ( input ( ) . split ( ) ) <NEWLINE> <NL> A = int ( A ) <NEWLINE> B = float ( B ) <NEWLINE> <NL> print ( int ( ( A * ( B * 100 ) ) / 100 ) ) <NEWLINE>
a , b = input ( ) . split ( ) <NEWLINE> b . replace ( <STRING> , <STRING> ) <NEWLINE> print ( int ( a ) * int ( b ) // 100 ) <NEWLINE>
A , B = input ( ) . split ( ) <NEWLINE> print ( math . floor ( int ( A ) * float ( B ) ) ) <NEWLINE>
A , B = map ( float , input ( ) . split ( ) ) <NEWLINE> import math <NEWLINE> <NL> text = str ( math . floor ( A * B ) ) <NEWLINE> index = text . index ( <STRING> ) <NEWLINE> if index >= 0 : <NEWLINE> <INDENT> print ( text [ : index ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( text ) <NEWLINE> <DEDENT>
<COMMENT> <NL> from decimal import Decimal <NEWLINE> from floor import math <NEWLINE> a , b = input ( ) . split ( ) <NEWLINE> a = int ( a ) <NEWLINE> b = Decimal ( b ) <NEWLINE> print ( floor ( a * b ) ) <NEWLINE>
A , B = map ( float , input ( ) . split ( ) ) <NEWLINE> <NL> print ( int ( math . floor ( int ( B * 100 ) * A / 100 ) ) ) <NEWLINE>
<NL> import math <NEWLINE> from fractions import Fraction <NEWLINE> <NL> <NL> A , B = map ( float , input ( ) . split ( ) ) <NEWLINE> <NL> A = Fraction ( A , 15 ) <NEWLINE> B = Fraction ( B , 15 ) <NEWLINE> <NL> ans = A * B <NEWLINE> <NL> print ( math . floor ( ans ) ) <NEWLINE>
import math <NEWLINE> a = input ( ) . split ( ) <NEWLINE> p = int ( a [ 0 ] ) <NEWLINE> q = int ( a [ 1 ] * 100 ) <NEWLINE> print ( p * q // 100 ) <NEWLINE>
import math <NEWLINE> a , b = map ( flaot , input ( ) . split ( ) ) <NEWLINE> print ( math . floor ( a * ( 100 * b ) / 100 ) ) <NEWLINE>
from math import floor <NEWLINE> a , b = [ i for i in input ( ) . split ( ) ] <NEWLINE> p = int ( b [ 0 ] + b [ 2 ] + b [ 3 ] ) <NEWLINE> print ( a * p // 100 ) <NEWLINE>
A , B = map ( float , input ( ) , split ( ) ) <NEWLINE> C = B * 1000 <NEWLINE> print ( A * C // 1000 ) <NEWLINE>
a , b , = map ( int , input ( ) . split ( ) ) ; <NEWLINE> c = a * b <NEWLINE> print ( int ( c ) ) ; <NEWLINE>
A , B = map ( str , input ( ) . split ( ) ) <NEWLINE> B = int ( float ( B ) * 100 ) <NEWLINE> ans = A * B <NEWLINE> print ( int ( ans // 100 ) ) <NEWLINE>
import math <NEWLINE> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> S = <STRING> + str ( B ) <NEWLINE> S = int ( S ) <NEWLINE> <NL> ans = A * B / 100 <NEWLINE> print ( ans ) <NEWLINE>
import math <NEWLINE> X , Y = map ( input ( ) . split ( ) ) <NEWLINE> X = int ( X ) <NEWLINE> Y = float ( Y ) <NEWLINE> print ( math . floor ( X * Y ) ) <NEWLINE>
import math <NEWLINE> from decimal import decimal <NEWLINE> <NL> a , b = map ( input ( ) . split ( ) ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> a = decimal ( a ) <NEWLINE> b = decimal ( b ) <NEWLINE> <NL> print ( math . floor ( a * b ) ) <NEWLINE>
import math <NEWLINE> A , B = input ( ) . split ( ) <NEWLINE> A = int ( A ) <NEWLINE> B = int ( round ( B * 100 ) ) <NEWLINE> ans = A * B <NEWLINE> print ( math . floor ( ans / 100 ) ) <NEWLINE>
a , b = input ( ) . split ( ) <NEWLINE> a = int ( a ) <NEWLINE> b = int ( 100 * b ) <NEWLINE> print ( ( a * b ) / 100 ) <NEWLINE>
import math <NEWLINE> a , b = map ( float , input ( ) . split ( ) ) <NEWLINE> print ( math . floor ( ( a * ( b * 100 ) / 100 ) <NEWLINE>
A , B = input ( ) . split ( <STRING> ) <NEWLINE> <NL> A = int ( A ) <NEWLINE> B100 = int ( B . replace ( <STRING> , <STRING> ) ) <NEWLINE> <NL> ans = A * B * 0.01 <NEWLINE> <NL> print ( ans ) <NEWLINE>
A , B = input ( ) . split ( ) <NEWLINE> A = int ( A ) <NEWLINE> B = int ( 100 * B ) <NEWLINE> print ( A * B // 100 ) <NEWLINE>
import dcimal <NEWLINE> a , b = map ( decimal . Decimal , input ( ) . split ( ) ) <NEWLINE> print ( int ( a * b ) ) <NEWLINE>
from math import floor <NEWLINE> a , b = input ( ) . split ( ) <NEWLINE> a = int ( a ) <NEWLINE> b = list ( b ) <NEWLINE> b = int ( b [ 0 ] + b [ 2 : ] ) <NEWLINE> print ( floor ( a * b / 100 ) ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> A , B = input ( ) . split ( ) <NEWLINE> A = int ( A ) <NEWLINE> B = int ( B . replace ( <STRING> ) ) <NEWLINE> <NL> ans = ( A * B ) // 100 <NEWLINE> <NL> print ( ans ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL>
A , B = input ( ) . split ( ) <NEWLINE> A = int ( A ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> print ( A * B // 100 ) <NEWLINE>
s = input ( ) . split ( ) <NEWLINE> a = int ( s [ 0 ] ) <NEWLINE> b , c = map ( int , s [ 1 ] . split ( ) ) <NEWLINE> print ( a * b + a * c // 100 ) <NEWLINE>
a , b = map ( str , input ( ) . split ( ) ) <NEWLINE> b1 , b2 = b . split ( <STRING> ) <NEWLINE> bb = int ( b1 ) * 100 + int ( b2 ) <NEWLINE> print ( int ( ( a * bb ) / 100 ) ) <NEWLINE>
A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> B_0 = B // 1 <NEWLINE> B_1 = B % 1 <NEWLINE> ans_0 = round ( A * B_0 ) <NEWLINE> ans_1 = A * round ( B_1 * 100 ) // 100 <NEWLINE> print ( int ( ans_0 + ans_1 ) ) <NEWLINE>
def factorization ( y ) : <NEWLINE> <INDENT> arr = [ ] <NEWLINE> temp = y <NEWLINE> for i in range ( 2 , int ( - ( - y ** 0.5 // 1 ) ) + 1 ) : <NEWLINE> <INDENT> if temp % i == 0 : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> while temp % i == 0 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> temp //= i <NEWLINE> <DEDENT> arr . append ( [ i , cnt ] ) <NEWLINE> <DEDENT> <DEDENT> if temp != 1 : <NEWLINE> <INDENT> arr . append ( [ temp , 1 ] ) <NEWLINE> <DEDENT> if arr == [ ] : <NEWLINE> <INDENT> arr . append ( [ y , 1 ] ) <NEWLINE> <DEDENT> return arr <NEWLINE> <DEDENT> n = int ( input ( ) ) <NEWLINE> if n == 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> l = factorization ( n ) <NEWLINE> for i , j in l : <NEWLINE> <INDENT> if j <= 2 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> c = 1 <NEWLINE> t = 1 <NEWLINE> while j > 0 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> j -= c <NEWLINE> c += t <NEWLINE> if j < t : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> t += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
A , B = map ( float , input ( ) . split ( ) ) <NEWLINE> print ( int ( ( A * ( B * 100 ) ) / 100 ) <NEWLINE>
from decimal import * <NEWLINE> a , b = map ( float , input ( ) . split ( <STRING> ) ) <NEWLINE> b *= 100 <NEWLINE> print ( ( int ) ( Decimal ( a ) * Decimal ( b ) / 100 + 0.001 ) ) <NEWLINE>
<COMMENT> <NL> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> a , b = map ( float , input ( ) . split ( ) ) <NEWLINE> <NL> a = int ( a ) <NEWLINE> b = str ( b ) <NEWLINE> <COMMENT> <NL> b = b [ 0 ] + b [ 2 ] + b [ 3 ] <NEWLINE> b = int ( b ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> return a * b // 100 <NEWLINE> <NL> <NL> <DEDENT> print ( main ( ) ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> import math <NEWLINE> <NL> <NL> if __name__ == <STRING> : <NEWLINE> <NL> <INDENT> INPUT = list ( map ( float , input ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> print ( math . floor ( h1 * m1 ) ) <NEWLINE> <DEDENT>
from decimal import Decimal <NEWLINE> import math <NEWLINE> a , b = map ( str , input ( ) . split ( ) ) <NEWLINE> c = Decimal ( a ) <NEWLINE> d = Decimal ( b ) <NEWLINE> e = Decimal ( c * d ) <NEWLINE> f = math . floor ( e ) <NEWLINE> print ( f ) <NEWLINE> from decimal import * <NEWLINE> import math <NEWLINE> a , b = map ( str , input ( ) . split ( ) ) <NEWLINE> c = Decimal ( a ) <NEWLINE> d = Decimal ( b ) <NEWLINE> e = Decimal ( c * d ) <NEWLINE> f = math . floor ( e ) <NEWLINE> print ( f ) <NEWLINE>
a , b = input ( ) . split ( ) <NEWLINE> b = b . replace ( <STRING> , <STRING> ) <NEWLINE> int ( a ) <NEWLINE> int ( b ) <NEWLINE> print ( ( a * b ) // 100 ) <NEWLINE>
import math <NEWLINE> a , b = [ i for i in input ( ) . split ( ) ] <NEWLINE> <NL> a = int ( a ) <NEWLINE> b = int ( b * 100 ) <NEWLINE> <NL> print ( math . floor ( a * b / 100 ) ) <NEWLINE>
a , b = map ( float , input ( ) . split ( ) ) <NEWLINE> a = int ( a ) <NEWLINE> print ( math . trunc ( a * b ) ) <NEWLINE>
from functools import reduce <NEWLINE> from operator import mul <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> a_list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> result = reduce ( mul , a_list ) <NEWLINE> <NL> if result > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( result ) <NEWLINE> <DEDENT>
import math <NEWLINE> def main ( ) : <NEWLINE> <INDENT> A , B = input ( ) . split ( ) <NEWLINE> A = int ( A ) <NEWLINE> B = round ( 100 * ( B ) ) <NEWLINE> out = ( A * B ) // 100 <NEWLINE> <NL> print ( out ) <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> c = 100 * a * b <NEWLINE> ans = c // 100 <NEWLINE> print ( ans ) <NEWLINE>
m , k = input ( ) . split ( <STRING> ) <NEWLINE> result = int ( m ) * float ( k ) <NEWLINE> result = int ( result ) <NEWLINE> print ( <STRING> % result // 100 ) <NEWLINE>
a = int ( input ( ) ) <NEWLINE> b = float ( input ( ) ) <NEWLINE> c = float ( a ) * b <NEWLINE> ans = int ( c // 1 ) <NEWLINE> print ( ans ) <NEWLINE>
a , b = input ( ) . split ( ) <NEWLINE> a = int ( a ) <NEWLINE> b = float ( b ) * 1000 <NEWLINE> b = int ( b ) <NEWLINE> print ( int ( ( a * b ) // 1000 ) <NEWLINE>
H , W = map ( double , input ( ) . split ( ) ) <NEWLINE> print ( int ( H * W ) ) <NEWLINE>
import math <NEWLINE> A , B = [ int ( A ) for A in input ( ) . split ( ) ] <NEWLINE> if float ( B ) >= 1 : <NEWLINE> <INDENT> print ( math . trunc ( A * B ) ) <NEWLINE> <DEDENT> elif 1 > float ( B ) > 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( A * B ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> inputList = input ( ) . split ( ) <NEWLINE> print ( int ( inputList [ 0 ] ) * int ( inputList [ 1 ] ) ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
, b = map ( float , input ( ) . split ( ) ) <NEWLINE> res = a * b <NEWLINE> res = int ( res ) <NEWLINE> print ( res ) <NEWLINE>
from math import floor <NEWLINE> <NL> a , b = [ i for i in input ( ) . split ( ) ] <NEWLINE> B = int ( b [ 0 ] + b [ 1 ] + b [ 2 ] ) <NEWLINE> print ( int ( a ) * B // 10 ) ; <NEWLINE>
import sys <NEWLINE> def input ( ) : <NEWLINE> <INDENT> return sys . stdin . readline ( ) . strip ( ) <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> A , B = input ( ) . split ( ) <NEWLINE> if int ( A ) == 0 or int ( B ) == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> return <NEWLINE> <DEDENT> A = int ( A ) <NEWLINE> B = int ( float ( B ) * 100 ) <NEWLINE> print ( A * B // 100 ) <NEWLINE> <NL> <NL> <DEDENT> main ( ) <NEWLINE>
A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> print ( int ( A * B ) ) <NEWLINE>
A , B = input ( ) . split ( ) <NEWLINE> A = int ( A ) <NEWLINE> B = int ( float ( B * 100 ) ) <NEWLINE> print ( A * B / 100 ) <NEWLINE>
from decimal import decimal <NEWLINE> a , b = map ( decimal , input ( ) . split ( ) ) <NEWLINE> print ( a * b ) <NEWLINE>
a = input ( ) <NEWLINE> b = input ( ) <NEWLINE> <NL> A = int ( a ) <NEWLINE> B = int ( b ) <NEWLINE> <NL> x = a * b <NEWLINE> <NL> y = int ( x ) <NEWLINE> <NL> print ( x ) <NEWLINE>
from decimal import Decimal <NEWLINE> <NL> a , b = input ( ) . split ( ) <NEWLINE> b = round ( b * 100 ) <NEWLINE> c = int ( a ) * int ( b ) // 100 <NEWLINE> <NL> print ( c ) <NEWLINE>
a , b = input ( ) . split ( ) <NEWLINE> <NL> a = int ( a ) <NEWLINE> b_unchi = b . split ( <STRING> ) <NEWLINE> b_int = int ( b_unchi [ 0 ] ) <NEWLINE> b_float = int ( b_unchi [ 1 ] ) <NEWLINE> bbb = b_int * 100 + b_float <NEWLINE> s = a * b <NEWLINE> print ( s // 100 ) <NEWLINE>
A , B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B *= 100 <NEWLINE> A = A * B <NEWLINE> print ( A // 100 ) <NEWLINE>
import math <NEWLINE> A , B = map ( eval , input ( ) . split ( ) ) <NEWLINE> ans = A * B <NEWLINE> print ( math . tr <NEWLINE>
from decimal import Decimal <NEWLINE> s = map ( float , input ( ) . split ( ) ) <NEWLINE> S = Decimal ( A ) * Decimal ( B ) <NEWLINE> print ( S // 1 ) <NEWLINE>
from decimal import Decimal <NEWLINE> <NL> A , B = map ( float , input ( ) . split ( ) ) <NEWLINE> ans = int ( A * Decimal ( str ( B ) ) ) <NEWLINE> print ( ans ) <NEWLINE>
a , b = map ( float , input ( ) . split ( ) ) <NEWLINE> <NL> multi = a * b <NEWLINE> i = 1 <NEWLINE> test = 1 <NEWLINE> <NL> if ( 0 <= multi ) and ( multi < 1 ) : <NEWLINE> <INDENT> test = 0 <NEWLINE> <NL> <DEDENT> while True : <NEWLINE> <INDENT> if test == 0 : <NEWLINE> <INDENT> i = 0 <NEWLINE> break <NEWLINE> <DEDENT> elif ( i <= multi ) and ( multi < i + 1 ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> i = i * 10 <NEWLINE> <DEDENT> <DEDENT> while True : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if ( i <= multi ) and ( multi < i + 1 ) : <NEWLINE> <INDENT> break <NEWLINE> i = i + 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( i ) <NEWLINE>
from decimal import * as dec <NEWLINE> import math <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> a , b = map ( dec , input ( ) . split ( ) ) <NEWLINE> if b < 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> return <NEWLINE> <DEDENT> ans = ( a * b ) <NEWLINE> print ( math . floor ( ans ) ) <NEWLINE> <DEDENT> main ( ) <NEWLINE>
<NL> n = input ( ) . split ( ) <NEWLINE> <NL> ans = int ( n [ 0 ] ) * int ( n [ 1 ] ) <NEWLINE> <NL> print ( math . floor ( ans ) ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( int ( a * b ) ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( int ( a * b ) ) <NEWLINE>
[ a , b ] = list ( map ( str , input ( ) . split ( ) ) ) <NEWLINE> b . rstrip ( <STRING> ) <NEWLINE> print ( ( a * b ) // 100 ) <NEWLINE>
import math <NEWLINE> <NL> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( math . floor ( a * b ) ) <NEWLINE>
import math <NEWLINE> A , B = map ( float , input ( ) . split ( <STRING> ) ) <NEWLINE> print ( math . floor ( A * int ( B * 100 ) / 100 ) <NEWLINE>
import math <NEWLINE> a , b = map ( float , input ( ) . split ( ) ) <NEWLINE> a = int ( a ) <NEWLINE> b = int ( b . replace ( <STRING> , <STRING> ) ) <NEWLINE> print ( ( a * b ) // 100 ) <NEWLINE>
from math import floor <NEWLINE> a , b = input ( ) . split ( ) <NEWLINE> a = int ( a ) <NEWLINE> b = float ( b ) <NEWLINE> print ( int ( floor ( a * b ) ) <NEWLINE>
a , b = input ( ) . split ( ) <NEWLINE> a = int ( a ) <NEWLINE> b = Decimal ( b ) <NEWLINE> <NL> print ( int ( a * b ) ) <NEWLINE>
import math <NEWLINE> A , B = map ( double , input ( ) . split ( ) ) <NEWLINE> B *= 1000 <NEWLINE> mul = A * B <NEWLINE> mul2 = math . floor ( mul // 1000 ) <NEWLINE> print ( mul2 ) <NEWLINE>
from math import floor <NEWLINE> from decimal import Decimal <NEWLINE> a , b = map ( Decimal , input ( ) . split ( ) ) <NEWLINE> print ( math . floor ( a * b ) ) <NEWLINE>
A = input ( ) . split ( ) <NEWLINE> a = int ( A [ 0 ] ) <NEWLINE> b = int ( float ( A [ 1 ] ) * 100 ) <NEWLINE> print ( ( a * b ) / 100 ) ) <NEWLINE>
A , B = map ( float , input ( ) . split ( ) ) <NEWLINE> <NL> print ( int ( ( A * ( B * 100 ) / 100 ) ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> <NL> a , b = input ( ) . split ( ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> ans = int ( a ) * int ( b * 100 ) <NEWLINE> ans = ans // 100 <NEWLINE> <NL> print ( ans ) <NEWLINE>
<COMMENT> <NL> a , b = input ( ) . split ( ) <NEWLINE> b_arr = b . split ( <STRING> ) <NEWLINE> print ( int ( a ) * ( int ( b_arr [ 0 ] ) + * int ( b_arr [ 1 ] ) // 100 ) ) <NEWLINE>
A , B = map ( float , input ( ) . split ( ) ) <NEWLINE> print ( int ( A * ( B * 100 ) / 100 ) <NEWLINE>
A , B = map ( str , input ( ) . split ( ) ) <NEWLINE> A = int ( A ) <NEWLINE> period_index = B . index ( <STRING> ) <NEWLINE> B_after_the_decimal = int ( B [ period_index + 1 : ] ) <NEWLINE> B_before_the_decimal = int ( B [ 0 : period_index ] ) <NEWLINE> <NL> include_decimal = str ( int ( A * B_after_the_decimal ) ) <NEWLINE> include_decimal = include_decimal [ : len ( include_decimal ) - ( len ( B ) - period_index - 1 ) ] <NEWLINE> <NL> if include_decimal != <STRING> : <NEWLINE> <INDENT> ans = include_decimal + A * B_before_the_decimal <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = A * B_before_the_decimal <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
import decimal <NEWLINE> a , b = map ( decimal , input ( ) . split ( ) ) <NEWLINE> print ( int ( a * b ) ) <NEWLINE>
a , b = map ( Decimal , input ( ) . split ( ) ) <NEWLINE> print ( int ( a * b ) ) <NEWLINE>
import math <NEWLINE> from fractions import Fraction <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> a , b = map ( float , input ( ) . split ( ) ) <NEWLINE> <NL> b = Fraction ( int ( b * 10000000000000 , 10000000000000 ) ) <NEWLINE> <NL> ans = ( int ( a ) * b ) <NEWLINE> print ( int ( ans ) ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> res = a * b <NEWLINE> print ( int ( res ) ) <NEWLINE>
a , b = input ( ) . split ( ) <NEWLINE> from decimal import Decimal <NEWLINE> ans = Decimal ( a ) * Decimal ( b ) <NEWLINE> print ( int ( ans ) ) a , b = input ( ) . split ( ) <NEWLINE> from decimal import Decimal <NEWLINE> ans = Decimal ( a ) * Decimal ( b ) <NEWLINE> print ( int ( ans ) ) <NEWLINE>
a , b = map ( input ( ) . split ( ) ) <NEWLINE> b . replace ( <STRING> , <STRING> ) <NEWLINE> ans = int ( a ) * int ( b ) // 100 <NEWLINE> print ( ans ) <NEWLINE>
from math import floor , ceil , sqrt , factorial , log <NEWLINE> from collections import Counter , deque <NEWLINE> from functools import reduce <NEWLINE> import numpy as np <NEWLINE> def S ( ) : return input ( ) <NEWLINE> def I ( ) : return int ( input ( ) ) <NEWLINE> def MS ( ) : return map ( str , input ( ) . split ( ) ) <NEWLINE> def MI ( ) : return map ( float , input ( ) . split ( ) ) <NEWLINE> def FLI ( ) : return [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> def LS ( ) : return list ( MS ( ) ) <NEWLINE> def LI ( ) : return list ( MI ( ) ) <NEWLINE> def LLS ( ) : return [ list ( map ( str , l . split ( ) ) ) for l in input ( ) ] <NEWLINE> def LLI ( ) : return [ list ( map ( int , l . split ( ) ) ) for l in input ( ) ] <NEWLINE> def LLSN ( n : int ) : return [ LS ( ) for _ in range ( n ) ] <NEWLINE> def LLIN ( n : int ) : return [ LI ( ) for _ in range ( n ) ] <NEWLINE> <NL> A , B = input ( ) . split ( ) <NEWLINE> A = int ( A ) <NEWLINE> B = int ( B * 100 ) <NEWLINE> <NL> print ( A * B // 100 ) <NEWLINE>
a , b = input ( ) . split ( ) <NEWLINE> a1 = int ( a ) <NEWLINE> b1 = int ( b * 100 ) <NEWLINE> print ( ( a1 * b1 ) // 100 ) <NEWLINE>
import sys <NEWLINE> readline = sys . stdin . readline <NEWLINE> <NL> A , B = map ( int , readline ( ) . split ( ) ) <NEWLINE> print ( int ( A * B ) ) <NEWLINE>
A , B = input ( ) . split ( ) <NEWLINE> A = int ( A ) <NEWLINE> B = int ( B * 100 ) <NEWLINE> print ( A * B // 100 ) <NEWLINE>
import math <NEWLINE> x , y = map ( float , input ( ) . split ( ) ) <NEWLINE> x = int ( x ) <NEWLINE> y = print ( <STRING> . format ( y ) ) <NEWLINE> <NL> print ( math . floor ( x * y ) ) <NEWLINE>
impor math <NEWLINE> A , B = map ( float , input ( ) . split ( <STRING> ) ) <NEWLINE> A = int ( A ) <NEWLINE> B = int ( B * 100 ) <NEWLINE> print ( math . floor ( ( A * B ) / 100 ) ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( str ( int ( a * b ) ) ) <NEWLINE>
a , b = input ( ) . split ( ) <NEWLINE> a = int ( a ) <NEWLINE> bx100 = int ( b . repleace ( <STRING> , <STRING> ) ) <NEWLINE> print ( a * bx100 // 100 ) <NEWLINE>
import math <NEWLINE> <NL> x = int ( input ( ) ) <NEWLINE> y = double ( input ( ) ) <NEWLINE> <NL> z = math . floor ( x * y ) <NEWLINE> print ( z ) <NEWLINE>
s = input ( ) . split ( ) <NEWLINE> a = int ( s [ 0 ] ) ; <NEWLINE> b = int ( s [ 1 ] [ 0 : 1 ] + s [ 2 : len ( s [ 1 ] ) ] ) <NEWLINE> b *= 100 <NEWLINE> print ( a * b // 100 ) <NEWLINE>
<COMMENT> <NL> import math <NEWLINE> a_n = map ( int , input ( ) . split ( ) ) <NEWLINE> res = 1 * a for a in a_n <NEWLINE> for a in a_n : <NEWLINE> <INDENT> res *= a <NEWLINE> <NL> <DEDENT> res = - 1 if math . log10 ( res ) > 18 else res <NEWLINE> print ( res ) <NEWLINE>
ab = input ( ) <NEWLINE> a = int ( input . split ( ) [ 0 ] ) <NEWLINE> b = float ( input . split ( ) [ 1 ] ) <NEWLINE> print ( int ( a * b ) ) <NEWLINE>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> from deciaml import Decimal <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> a , b = list ( map ( Decimal , input ( ) . strip ( ) . split ( ) ) ) <NEWLINE> print ( int ( a * b ) ) <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE>
import math <NEWLINE> X = input ( ) . split ( <STRING> ) <NEWLINE> A = int ( X [ 0 ] ) <NEWLINE> B100 = float ( X [ 1 ] ) * 100 <NEWLINE> ab = math . floor ( A * B ) // 100 <NEWLINE> print ( str ( ab ) ) <NEWLINE>
import math as m <NEWLINE> a , b = map ( float , input ( ) ) <NEWLINE> k = a * b <NEWLINE> print ( m . floor ( k ) ) <NEWLINE>
A , B = [ x for x in input ( ) . split ( ) ] <NEWLINE> <NL> A = int ( A ) <NEWLINE> B = int ( round ( float ( B ) * 100 ) ) <NEWLINE> <NL> print ( A * B // 100 <NEWLINE>
from decimal import * <NEWLINE> a , b = map ( decimal , input ( ) . split ( ) ) <NEWLINE> print ( int ( a * b ) ) <NEWLINE>
A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( int ( ( A * B ) // 1 ) ) <NEWLINE>
from decimal import Decimal <NEWLINE> <NL> a , b = input ( ) . split ( ) <NEWLINE> a = int ( a ) <NEWLINE> b_100 = Decimal ( b * 100 ) <NEWLINE> print ( int ( a * b_100 // 100 ) ) <NEWLINE>
a , b = input ( ) . split ( ) <NEWLINE> print ( int ( A ) * int ( float ( B ) * 1000 ) // 1000 ) <NEWLINE>
a , b = input ( ) . split ( ) <NEWLINE> c = int ( b * 100 ) <NEWLINE> a2 = int ( a ) <NEWLINE> print ( int ( a2 * c / 100 ) ) <NEWLINE>
a , b = [ float ( s ) for s in input ( ) . split ( <STRING> ) ] <NEWLINE> a = int ( a ) <NEWLINE> b = round ( b * 100 ) <NEWLINE> print ( a * b // 100 ) ) <NEWLINE>
import numpy as np <NEWLINE> import scipy . sparse as sps <NEWLINE> import scipy . misc as spm <NEWLINE> import collections as col <NEWLINE> import functools as func <NEWLINE> import itertools as ite <NEWLINE> import fractions as frac <NEWLINE> import math as ma <NEWLINE> from math import cos , sin , tan <NEWLINE> import cmath as cma <NEWLINE> import copy as cp <NEWLINE> import sys <NEWLINE> import re <NEWLINE> def sinput ( ) : return sys . stdin . readline ( ) . strip ( ) <NEWLINE> def iinput ( ) : return int ( sinput ( ) ) <NEWLINE> def imap ( ) : return map ( int , sinput ( ) . split ( ) ) <NEWLINE> def fmap ( ) : return map ( float , sinput ( ) . split ( ) ) <NEWLINE> def iarr ( n = 0 ) : <NEWLINE> <INDENT> if n : return [ 0 for _ in range ( n ) ] <NEWLINE> else : return list ( imap ( ) ) <NEWLINE> <DEDENT> def farr ( ) : return list ( fmap ( ) ) <NEWLINE> def sarr ( n = 0 ) : <NEWLINE> <INDENT> if n : return [ <STRING> for _ in range ( n ) ] <NEWLINE> else : return sinput ( ) . split ( ) <NEWLINE> <DEDENT> def barr ( n ) : return [ False for _ in range ( n ) ] <NEWLINE> def adj ( n ) : return [ [ ] for _ in range ( n ) ] <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> MOD = 10 ** 9 + 7 ; EPS = sys . float_info . epsilon <NEWLINE> PI = np . pi ; EXP = np . e ; INF = np . inf <NEWLINE> <NL> a , b = imap ( ) <NEWLINE> b *= 100 <NEWLINE> ans = a * b // 100 <NEWLINE> print ( ans ) <NEWLINE>
from collections import defaultdict <NEWLINE> from math import gcd <NEWLINE> import time <NEWLINE> import sys <NEWLINE> from collections import Counter <NEWLINE> import itertools <NEWLINE> import math <NEWLINE> from decimal import * <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> input = sys . stdin . readline <NEWLINE> <NL> temp = input ( ) . split ( <STRING> ) <NEWLINE> a = int ( temp [ 0 ] ) <NEWLINE> b = math . floor ( temp [ 1 ] * 100 ) <NEWLINE> ans = a * b / 100 <NEWLINE> print ( math . floor ( ans ) ) <NEWLINE>
<COMMENT> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> A , B = map ( float , input ( ) . split ( ) ) <NEWLINE> print ( int ( ( A * B ) / / 1 ) ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
inputs = list ( input ( ) . split ( ) ) <NEWLINE> A = int ( inputs [ 0 ] ) <NEWLINE> B = int ( float ( inputs [ 1 ] + 0.5 ) * 100 ) <NEWLINE> Ans = A * B / 100 // 1 <NEWLINE> print ( int ( Ans ) ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( int ( a * b ) ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> b = int ( b * 100 ) <NEWLINE> print ( a * b / 100 ) <NEWLINE>
a = int ( input ( ) ) <NEWLINE> b = int ( float ( input ( ) ) * 100 ) <NEWLINE> print ( int ( a * b ) / 100 ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( a * b // 100 ) <NEWLINE>
import numpy <NEWLINE> [ a , b ] = list ( input ( ) . split ( ) ) <NEWLINE> newa = int ( a ) <NEWLINE> product = newa * b <NEWLINE> print ( int ( numpy . floor ( product ) ) ) <NEWLINE>
import math <NEWLINE> A , B = input ( ) <NEWLINE> A = int ( A ) <NEWLINE> B = float ( B ) <NEWLINE> print ( math . floor ( A * B ) ) <NEWLINE>
a , b = input ( ) . split ( ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> aa = int ( a ) <NEWLINE> bb = float ( b ) <NEWLINE> print ( int ( aa * bb ) ) a , b = map ( float , input ( ) . split ( ) ) <NEWLINE> <NL> from decimal import * <NEWLINE> A = Decimal ( str ( a ) ) <NEWLINE> AA = A . quantize ( Decimal ( <STRING> ) , rounding = ROUND_FLOOR ) <NEWLINE> B = Decimal ( str ( b ) ) <NEWLINE> BB = B . quantize ( Decimal ( <STRING> ) , rounding = ROUND_FLOOR ) <NEWLINE> <NL> K = AA * BB <NEWLINE> print ( int ( K ) ) <NEWLINE>
from math import floor <NEWLINE> A = input ( ) . split ( ) <NEWLINE> p = int ( A [ 0 ] ) <NEWLINE> q = float ( A [ 1 ] * 100 ) <NEWLINE> t = p * q <NEWLINE> p //= 100 <NEWLINE> print ( p ) <NEWLINE>
a = int ( input ( ) ) <NEWLINE> b = float ( input ( ) ) <NEWLINE> <NL> print ( ( a * ( b * 100 ) ) / 100 ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> ans = 1 <NEWLINE> for a in A : <NEWLINE> <INDENT> ans = ans * a <NEWLINE> if ans > pow ( 10 , 18 ) : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
a , b = input ( ) . split ( ) <NEWLINE> a = int ( a ) <NEWLINE> b = float ( b * 100 ) <NEWLINE> print ( ( a * b ) // 100 ) <NEWLINE>
inp = input ( ) <NEWLINE> a , b = input ( ) . split ( ) <NEWLINE> a = int ( a ) <NEWLINE> b = float ( b ) <NEWLINE> b100 = int ( b * 100 ) <NEWLINE> ans100 = a * b100 <NEWLINE> ans = a / 100 <NEWLINE> print ( ans ) <NEWLINE>
from decimal import Decimal <NEWLINE> a , b = map ( str , input ( ) . split ( ) ) <NEWLINE> f1 = Decimal ( a ) <NEWLINE> f2 = Decimal ( b ) <NEWLINE> print ( int ( a * b ) ) <NEWLINE>
a , b = input ( ) . split ( ) <NEWLINE> b . replace ( <STRING> , <STRING> ) <NEWLINE> a = int ( a ) <NEWLINE> b = int ( b ) <NEWLINE> print ( a * b // 100 ) <NEWLINE>
import math <NEWLINE> A , B = map ( float , input ( ) . split ( ) ) <NEWLINE> <NL> B = decimal ( B ) <NEWLINE> print ( int ( A * B ) ) <NEWLINE>
x , y = map ( float , input ( ) . split ( ) ) <NEWLINE> import math <NEWLINE> from decimal import Decimal <NEWLINE> y_ = Decimal ( <STRING> ) <NEWLINE> x_ = Decimal ( <STRING> ) <NEWLINE> <NL> print ( math . floor ( x_ * y_ ) ) <NEWLINE>
A , B = map ( str , input ( ) . split ( ) ) <NEWLINE> A = int ( A ) <NEWLINE> B = int ( B . replace ( <STRING> , <STRING> ) ) <NEWLINE> print ( A * B / 100 ) <NEWLINE>
from decimal import Decimal <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> A , B = map ( Decimalt , input ( ) . split ( ) ) <NEWLINE> <NL> print ( int ( A * B ) ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
a = int ( input ( <STRING> ) ) <NEWLINE> b = float ( input ( <STRING> ) ) <NEWLINE> <NL> mul = int ( a * b ) <NEWLINE> print ( mul ) <NEWLINE>
> < <NEWLINE>
a , b = input ( ) . split ( ) <NEWLINE> a = int ( a ) <NEWLINE> b = int ( b . replace ( <STRING> , <STRING> ) <NEWLINE> print ( a * b // 100 ) <NEWLINE>
import os <NEWLINE> import sys <NEWLINE> from collections import defaultdict , Counter <NEWLINE> from itertools import product , permutations , combinations , accumulate <NEWLINE> from operator import itemgetter <NEWLINE> from bisect import bisect_left , bisect <NEWLINE> from heapq import heappop , heappush <NEWLINE> from math import ceil , floor , sqrt , gcd <NEWLINE> from copy import deepcopy <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( floor ( a * b ) ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
from decimal import * <NEWLINE> getcontext ( ) . prec = 2 <NEWLINE> <NL> a , b = input ( ) . split ( ) <NEWLINE> d = Decimal ( a ) * Decimal ( b ) <NEWLINE> print ( Decimal ( d ) . quantize ( Decimal ( <STRING> ) , rounding = ROUND_DOWN ) ) <NEWLINE>
// Author : Fuadul Hasan ( fuadul202 @ gmail . com ) <NEWLINE> // BSMRSTU , Gopalganj <NEWLINE> <COMMENT> <NL> using namespace std ; int tc = 1 ; <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> const int M = 1e9 + 7 ; <NEWLINE> const ll Inf = ( ll ) 2e18 + 5 ; <NEWLINE> const int N = 2e5 + 5 ; <NEWLINE> ll vis [ N ] , res [ N ] ; <NEWLINE> <NL> int solve ( ) <NEWLINE> { <NEWLINE> <INDENT> // happy coding <NEWLINE> <NL> <INDENT> ll n ; cin >> n ; <NEWLINE> string s ; cin >> s ; <NEWLINE> ll idx = find ( all ( s ) , <STRING> ) - s . begin ( ) ; <NEWLINE> ll a = stoi ( s . substr ( 0 , idx ) ) ; <NEWLINE> ll b = stoi ( s . substr ( idx + 1 ) ) ; <NEWLINE> ll mn = a * 100 + b ; <NEWLINE> cout << ( mn * n ) / 100 << endl ; <NEWLINE> <NL> <DEDENT> return 0 ; <NEWLINE> <DEDENT> } <NEWLINE> int main ( ) { <NEWLINE> <INDENT> int test = 1 ; <NEWLINE> // scanf ( <STRING> , & test ) ; <NEWLINE> while ( test - - ) solve ( ) ; return 0 ; <NEWLINE> <DEDENT> } <NEWLINE> <NL>
A , B = input ( ) . split ( ) <NEWLINE> B = int ( B * 100 ) <NEWLINE> A = int ( A ) <NEWLINE> print ( int ( A * B // 100 ) ) <NEWLINE>
x = input ( ) . split ( ) <NEWLINE> a = float ( x [ 0 ] ) <NEWLINE> b = float ( x [ 1 ] ) ) <NEWLINE> ans = int ( a * b ) <NEWLINE> print ( ans ) <NEWLINE>
import math <NEWLINE> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = math . floor ( A * B ) <NEWLINE>
a , b = map ( str , input ( ) . split ( ) ) <NEWLINE> A = int ( a ) <NEWLINE> B = 100 * int ( b [ 0 ] ) + 10 * int ( b [ 1 ] ) + int ( b [ 2 ] ) <NEWLINE> ans = A * B / 100 <NEWLINE> print ( int ( ans ) ) <NEWLINE>
from decimal import Decimal <NEWLINE> A , B = map ( input ( ) . split ( ) ) <NEWLINE> B = B . replace ( <STRING> , <STRING> ) <NEWLINE> A = int ( A ) <NEWLINE> B = int ( B ) <NEWLINE> <NL> print ( int ( A * B // 100 ) ) <NEWLINE>
import decimal <NEWLINE> a , b = map ( decimal , input ( ) . split ( ) ) <NEWLINE> print ( int ( a * b ) ) <NEWLINE>
a , b = input ( ) . split ( ) <NEWLINE> a = int ( a ) <NEWLINE> b = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> b = b [ 0 ] * 100 + b [ 1 ] <NEWLINE> ans = str ( a * b ) <NEWLINE> print ( ans [ : - 2 ] ) <NEWLINE>
A , B = input ( ) . split ( ) <NEWLINE> A = int ( a ) <NEWLINE> B = round ( float ( B ) * 100 ) <NEWLINE> print ( A * B // 100 ) <NEWLINE>
import math <NEWLINE> <NL> a = input ( ) . split ( ) <NEWLINE> s1 = a [ 0 ] <NEWLINE> s2 = a [ 1 ] <NEWLINE> num1 = int ( s1 ) <NEWLINE> num2 = int ( s [ 0 ] ) * 100 + int ( s [ 2 ] + s [ 3 ] ) <NEWLINE> <NL> print ( ( num1 * num2 ) // 100 ) <NEWLINE>
A , B = input ( ) . split ( ) <NEWLINE> A = int ( A ) <NEWLINE> B100 = <STRING> <NEWLINE> <NL> for s in range ( len ( B ) ) : <NEWLINE> <INDENT> if B [ s ] != <STRING> : <NEWLINE> <INDENT> B100 += B [ s ] <NEWLINE> <NL> <DEDENT> <DEDENT> B100 = int ( B100 ) <NEWLINE> <NL> ans = A * B100 // 100 <NEWLINE> <NL> print ( ans [ 0 ] ) <NEWLINE>
a , b = input ( ) . split ( ) <NEWLINE> <NL> a = int ( a ) <NEWLINE> b = map ( int , b . split ( <STRING> ) ) <NEWLINE> <NL> c = a * b // 100 <NEWLINE> <NL> print ( c ) <NEWLINE>
A , B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> print ( int ( A * B ) ) <NEWLINE>
import math <NEWLINE> <NL> A , B = input ( ) . split ( ) <NEWLINE> iA = int ( A ) <NEWLINE> fB = float ( B ) <NEWLINE> iB = math . floor ( fB ) <NEWLINE> fB100 = math . floor ( fB * 100 - iB * 100 ) <NEWLINE> <NL> ans = iA * iB <NEWLINE> ans += ( fB100 * iA ) // 100 <NEWLINE> print ( ans <NEWLINE>
import decimal <NEWLINE> ab = input ( ) . split ( ) <NEWLINE> a , b = int ( ab [ 0 ] ) , decimal ( ab [ 1 ] ) <NEWLINE> answer = int ( a * b ) <NEWLINE> print ( answer ) <NEWLINE>
import math <NEWLINE> <NL> a , b = input ( ) . split ( ) <NEWLINE> A = int ( a ) <NEWLINE> B = float ( b ) <NEWLINE> <NL> print ( int ( ath . floor ( A * B ) ) ) <NEWLINE>
<COMMENT> <NL> a , b = map ( float , input ( ) . split ( ) ) <NEWLINE> import math <NEWLINE> a = decimal . Decimal ( a ) <NEWLINE> b = decimal . Decimal ( b ) <NEWLINE> ans = a * b <NEWLINE> print ( ans ) <NEWLINE>
from fractions import Fraction <NEWLINE> a , b = input ( ) . split ( ) <NEWLINE> b = Fraction ( b ) <NEWLINE> ans = Fraction ( a * b ) <NEWLINE> ans = ans // 1 <NEWLINE> print ( int ( ans ) ) <NEWLINE>
a , b = input ( ) . split ( ) <NEWLINE> a = int ( a ) <NEWLINE> b = int ( b . replace ( <STRING> , <STRING> ) <NEWLINE> print ( a * b // 100 ) <NEWLINE>
a , b = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> print ( int ( a * b ) ) <NEWLINE>
import math <NEWLINE> <NL> A , B = [ i for i in input ( ) . split ( ) ] <NEWLINE> print ( math . floor ( int ( A ) * Decimal ( B ) ) ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> print ( int ( a * b ) ) <NEWLINE>
from math import math . floor <NEWLINE> a = int ( input ( ) ) <NEWLINE> b = float ( input ( ) ) <NEWLINE> Z = a * b <NEWLINE> print ( math . floor ( Z ) ) <NEWLINE>
import math <NEWLINE> from decimal import Decimal <NEWLINE> <NL> <NL> A , B = map ( float , input ( ) . split ( ) ) <NEWLINE> answer = A * Decimal ( B ) <NEWLINE> <NL> print ( math . floor ( answer ) ) <NEWLINE>
import math <NEWLINE> <NL> A , B = map ( str , input ( ) . split ( ) ) <NEWLINE> A = int ( A ) <NEWLINE> B = decimal . Decimal ( B ) <NEWLINE> print ( math . floor ( A * B ) ) <NEWLINE>
<COMMENT> <NL> import math <NEWLINE> <NL> a , b = map ( np . float64 , input ( ) . split ( ) ) <NEWLINE> c = math . floor ( a * b ) <NEWLINE> print ( c ) <NEWLINE>
ab = list ( input ( ) . split ( ) ) <NEWLINE> <NL> a = int ( ab [ 0 ] ) <NEWLINE> b = float ( ab [ 1 ] * 100 ) <NEWLINE> <NL> print ( a * b // 100 ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( int ( a * b ) ) <NEWLINE>
from Decimal import * <NEWLINE> n1 , n2 = map ( Decimal , input ( ) . split ( ) ) <NEWLINE> print ( int ( n1 * n2 ) ) <NEWLINE>
A , B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> print ( A * B // 1 ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> A , B = input ( ) . split ( ) <NEWLINE> A = int ( A ) <NEWLINE> B_big , B_small = B . split ( <STRING> ) <NEWLINE> B_big = int ( B_big ) <NEWLINE> B_small = int ( B_small ) <NEWLINE> print ( A * B + int ( A * B_small / 100 ) ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
from sys import stdin , stdout <NEWLINE> LI = lambda : list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> MAP = lambda : map ( int , input ( ) . split ( ) ) <NEWLINE> IN = lambda : int ( input ( ) ) <NEWLINE> S = lambda : input ( ) <NEWLINE> import math <NEWLINE> from collections import Counter , defaultdict <NEWLINE> <NL> a , b = input . split ( ) <NEWLINE> b . remove ( <STRING> ) <NEWLINE> ans = int ( a ) * int ( b ) <NEWLINE> print ( ans // 100 ) <NEWLINE>
A , B = input ( ) . split ( ) <NEWLINE> print ( int ( A ) * int ( B [ 0 ] + B [ 1 ] + B [ 2 ] + B [ 3 ] ) // 100 ) <NEWLINE>
x , y = list ( map ( decimal . Decimal , input ( ) . split ( ) ) ) <NEWLINE> y *= 100 <NEWLINE> print ( math . floor ( ( x * y ) / 100 ) ) <NEWLINE>
A = int ( input ( ) ) <COMMENT> <NEWLINE> B = float ( input ( ) ) <COMMENT> <NEWLINE> <NL> <NL> output = A * B <NEWLINE> print ( int ( output ) ) <NEWLINE>
from math import floor as f <NEWLINE> a = input ( ) . split ( ) <NEWLINE> print ( f ( int ( a [ 0 ] ) * ( int ( float ( a [ 1 ] * 100 ) ) ) / 100 ) ) <NEWLINE>
import math <NEWLINE> <NL> num1 = str ( input ( ) ) <COMMENT> <NEWLINE> num2 = str ( input ( ) ) <NEWLINE> <NL> num1 = str ( num1 ) <NEWLINE> num2 = str ( num2 ) <NEWLINE> <NL> result = int ( num1 ) * float ( num2 ) <COMMENT> <NEWLINE> result = math . floor ( result ) <COMMENT> <NEWLINE> <NL> print ( result ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> a , b = input ( ) . split ( ) <NEWLINE> a = int ( a ) <NEWLINE> b = double ( b ) <NEWLINE> print ( int ( a * b ) ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
a , b = map ( str , input ( ) . split ( ) ) <NEWLINE> a = int ( a ) <NEWLINE> b = int ( b * 1000 ) <NEWLINE> <NL> c = b / 1000 <NEWLINE> <NL> x = int ( a * b ) <NEWLINE> <NL> print ( x ) <NEWLINE>
import math <NEWLINE> <NL> a , b = int ( input ( ) ) , float ( input ( ) ) <NEWLINE> print ( ( math . floor ( float ( a * b ) ) ) ) <NEWLINE> <NL>
A , B = input ( ) . split ( ) <NEWLINE> B . replace ( <STRING> , <STRING> ) <NEWLINE> print ( int ( A ) * int ( B ) // 100 ) <NEWLINE>
a , b = map ( float , input ( ) . split ( ) ) <NEWLINE> n = a * b <NEWLINE> print ( floor ( n ) ) <NEWLINE>
import math <NEWLINE> a , b = map ( str , input ( ) . split ( ) ) <NEWLINE> print ( int ( int ( a ) * b ) ) <NEWLINE>
<COMMENT> <NL> <NL> <NL> def solve ( A , B ) : <NEWLINE> <INDENT> _B = round ( B * 100 ) <NEWLINE> print ( A * _B // 100 ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> A , B = [ float ( i ) for i in input ( ) . split ( ) ] <NEWLINE> A = int ( A ) <NEWLINE> sorted ( A , B ) <NEWLINE> <DEDENT>
import math <NEWLINE> a , b = input ( ) . split ( ) <NEWLINE> b = int ( float ( b ) * 100 ) <NEWLINE> s = ( int ( a ) * b ) <NEWLINE> print ( str ( s [ : - 2 ] ) if s > 99 else 0 ) <NEWLINE>
A , B = map ( float , input ( ) . split ( ) ) <NEWLINE> A = int ( A ) <NEWLINE> B = int ( B * 100 ) <NEWLINE> print ( math . floor ( A * B / 100 ) ) <NEWLINE>
A , B = input ( ) . split ( ) <NEWLINE> B = list ( B ) <NEWLINE> N = B [ 0 ] + B [ 2 ] + B [ 3 ] <NEWLINE> N = int ( N ) <NEWLINE> C = int ( A * N / 100 ) <NEWLINE> print ( C ) <NEWLINE>
A , B = input ( ) . split ( ) <NEWLINE> print ( int ( A ) * float ( B * 100 ) // 100 ) <NEWLINE>
import math <NEWLINE> A , B = input ( ) . split ( ) <NEWLINE> ans = int ( A ) * int ( math . ceil ( B ) ) <NEWLINE> print ( math . floor ( ans ) ) <NEWLINE>
A , B = input ( ) . split ( ) <NEWLINE> A = int ( A ) <NEWLINE> B = int ( B ) * 100 + int ( B [ - 2 : ] ) <NEWLINE> <NL> print ( A * B // 100 ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> print ( ( a * ( b * 100 ) ) // 100 ) <NEWLINE>
<NL> a , b = map ( float , input ( ) . split ( ) ) <NEWLINE> print ( math . floor ( a * b ) ) <NEWLINE> <NL>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( int ( a * b ) ) <NEWLINE>
import math <NEWLINE> <NL> <NL> def solve ( ) : <NEWLINE> <INDENT> A , B = input ( ) . split ( ) <NEWLINE> A = int ( A ) <NEWLINE> B = math . floor ( B * 100 ) <NEWLINE> print ( A * B // 100 ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> solve ( ) <NEWLINE> <DEDENT>
import math <NEWLINE> n , m = input ( ) . split ( ) <NEWLINE> x = decimal ( n ) <NEWLINE> y = decimal ( m ) <NEWLINE> ans = math . floor ( x * y ) <NEWLINE> print ( ans ) <NEWLINE>
from decimal import Decimal <NEWLINE> <NL> A , B = list ( map ( float , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = Decimal ( A ) * Decimal ( B ) <NEWLINE> <NL> print ( floor ( ans ) ) <NEWLINE>
a , b = input ( ) . split ( ) <NEWLINE> a = int ( a ) <NEWLINE> b = b * 100 <NEWLINE> c = a * b <NEWLINE> c = c / 100 <NEWLINE> <NL> print ( int ( c ) ) <NEWLINE>
<COMMENT> <NL> <NL> from decimal import Decimal <NEWLINE> <NL> a , b = input ( ) . split ( ) <NEWLINE> <NL> print ( int ( decimal ( a ) * decimal ( b ) ) ) <NEWLINE>
import decimal <NEWLINE> <NL> a , b = input ( ) . split ( ) <NEWLINE> a = int ( a ) <NEWLINE> b = decimal ( b ) <NEWLINE> b = b * 100 <NEWLINE> b = int ( b ) <NEWLINE> <NL> ans = a * b <NEWLINE> ans //= 100 <NEWLINE> <NL> print ( int ( ans ) ) <NEWLINE>
A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( int ( A * B ) ) <NEWLINE>
import fractions <NEWLINE> a , b = map ( float , input ( ) . split ( ) ) <NEWLINE> print ( fractions . floor ( a * b ) ) <NEWLINE>
<COMMENT> <NL> <NL> import math <NEWLINE> <NL> <NL> if __name__ == <STRING> : <NEWLINE> <INDENT> A , B = input ( ) . split ( ) <NEWLINE> print ( math . floor ( Decimal ( A ) * Decimal ( B ) ) ) <NEWLINE> <DEDENT>
from math import floor <NEWLINE> from fractions inport Fraction <NEWLINE> <NL> A , B = input ( ) . split ( ) <NEWLINE> A = int ( A ) <NEWLINE> B = Fraction ( B ) <NEWLINE> print ( floor ( A * B ) ) <NEWLINE>
A , B = input . split ( ) <NEWLINE> a = int ( A ) <NEWLINE> b = round ( float ( B ) * 100 ) <NEWLINE> c = a * b // 100 <NEWLINE> print ( c ) <NEWLINE>
C = input ( ) . split ( ) <NEWLINE> <NL> A = int ( C [ 0 ] ) <NEWLINE> B = int ( C [ 1 ] * 100 ) <NEWLINE> <NL> <NL> <NL> E = A * B <NEWLINE> <NL> F = E / 100 <NEWLINE> <NL> print ( F ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> print ( int ( a * b ) ) <NEWLINE>
import math <NEWLINE> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( math . floor ( A * B ) ) <NEWLINE>
<NL> A , B = input . split ( ) <NEWLINE> A = int ( A ) <NEWLINE> B = round ( float ( B ) * 100 ) <NEWLINE> <NL> res = ( A * B ) // 100 <NEWLINE> print ( res ) <NEWLINE>
from decimal import * <NEWLINE> c , d = list ( map ( decimal , input ( ) . split ( ) ) ) <NEWLINE> print ( int ( c * d ) ) <NEWLINE>
from decimal import Decimal <NEWLINE> <NL> m , n = map ( Decimal , input ( ) . split ( <STRING> ) ) <NEWLINE> print ( int ( m * n ) ) <NEWLINE>
a = int ( input ( ) ) <NEWLINE> b = float ( input ( ) ) <NEWLINE> a *= int ( b * 100 ) <NEWLINE> print ( int ( a / 100 ) ) <NEWLINE>
import decimal <NEWLINE> a , b = input ( ) . split ( ) <NEWLINE> print ( int ( decimai . Decimal ( a ) * decimal . Decimal ( b ) ) ) <NEWLINE>
A , B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> print ( int ( A * B ) ) <NEWLINE>
A , B = map ( str , input ( ) . split ( ) ) <NEWLINE> A = int ( A ) <NEWLINE> B = B . strip ( <STRING> ) <NEWLINE> B = int ( B ) <NEWLINE> print ( A * B // 100 ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( int ( a * b ) ) <NEWLINE>
1000000000000000 9.99 <NEWLINE>
a , b = map ( float , input ( ) . split ( ) ) <NEWLINE> b = b * 100 <NEWLINE> <NL> print ( ( a * int ( b ) // 100 ) <NEWLINE>
import decimal <NEWLINE> a , b = map ( float , input ( ) . split ( ) ) <NEWLINE> print ( Decimal ( a ) * Decimal ( b ) ) <NEWLINE>
a , b = input ( ) . split ( ) <NEWLINE> a = int ( a ) <NEWLINE> b = b * 100 <NEWLINE> <NL> print ( a * b // 100 ) <NEWLINE>
AB = input ( ) . split ( ) <NEWLINE> A = int ( AB [ 0 ] ) <NEWLINE> B = int ( AB [ 1 ] * 100 ) <NEWLINE> print ( A * B // 100 ) <NEWLINE>
a , b = input ( ) . split ( ) <NEWLINE> a = int ( a ) <NEWLINE> b = int ( b * 100 ) <NEWLINE> print ( a * b // 100 ) <NEWLINE>
A , B = int ( input ( ) ) , float ( input ( ) ) <NEWLINE> print ( int ( A * B ) ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> b = 100 * b <NEWLINE> print ( ( a * b ) // 100 ) <NEWLINE>
A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> print ( int ( A * B ) ) <NEWLINE>
nums = input ( ) . split ( ) <NEWLINE> a = int ( nums [ 0 ] ) <NEWLINE> b = float ( nums [ 1 ] ) <NEWLINE> print ( int ( ( a * ( 100 * b ) ) / 100 ) <NEWLINE>
a , b = input ( ) . split ( ) <NEWLINE> a = int ( a ) <NEWLINE> b = int ( b * 100 ) <NEWLINE> c = a * b <NEWLINE> c = c // 100 <NEWLINE> print ( c ) <NEWLINE>
def iput ( ) : return int ( input ( ) ) <NEWLINE> def mput ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def lput ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> def solve ( ) : <NEWLINE> <INDENT> n = iput ( ) <NEWLINE> a = lput ( ) <NEWLINE> ans = 1 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ans *= a [ i ] <NEWLINE> if a [ i ] == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if ans > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT> return 0 <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> solve ( ) <NEWLINE> <DEDENT>
import sys , collections as cl , bisect as bs , math <NEWLINE> sys . setrecursionlimit ( 100000 ) <NEWLINE> input = sys . stdin . readline <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> Max = sys . maxsize <NEWLINE> def l ( ) : <COMMENT> <NEWLINE> <INDENT> return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <DEDENT> def m ( ) : <COMMENT> <NEWLINE> <INDENT> return map ( float , input ( ) . split ( ) ) <NEWLINE> <DEDENT> def onem ( ) : <COMMENT> <NEWLINE> <INDENT> return int ( input ( ) ) <NEWLINE> <DEDENT> def s ( x ) : <COMMENT> <NEWLINE> <INDENT> a = [ ] <NEWLINE> if len ( x ) == 0 : <NEWLINE> <INDENT> return [ ] <NEWLINE> <DEDENT> aa = x [ 0 ] <NEWLINE> su = 1 <NEWLINE> for i in range ( len ( x ) - 1 ) : <NEWLINE> <INDENT> if aa != x [ i + 1 ] : <NEWLINE> <INDENT> a . append ( [ aa , su ] ) <NEWLINE> aa = x [ i + 1 ] <NEWLINE> su = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> su += 1 <NEWLINE> <DEDENT> <DEDENT> a . append ( [ aa , su ] ) <NEWLINE> return a <NEWLINE> <DEDENT> def jo ( x ) : <COMMENT> <NEWLINE> <INDENT> return <STRING> . join ( map ( str , x ) ) <NEWLINE> <DEDENT> def max2 ( x ) : <COMMENT> <NEWLINE> <INDENT> return max ( map ( max , x ) ) <NEWLINE> <DEDENT> def In ( x , a ) : <COMMENT> <NEWLINE> <INDENT> k = bs . bisect_left ( a , x ) <NEWLINE> if k != len ( a ) and a [ k ] == x : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return False <NEWLINE> <NL> <DEDENT> <DEDENT> def pow_k ( x , n ) : <NEWLINE> <INDENT> ans = 1 <NEWLINE> while n : <NEWLINE> <INDENT> if n % 2 : <NEWLINE> <INDENT> ans *= x <NEWLINE> <DEDENT> x *= x <NEWLINE> n >>= 1 <NEWLINE> <DEDENT> return ans <NEWLINE> <NL> <DEDENT> <STRING> <NEWLINE> <NL> a , b = m ( ) <NEWLINE> co = 0 <NEWLINE> po = b <NEWLINE> while True : <NEWLINE> <INDENT> if int ( po ) == po : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> po *= 10 <NEWLINE> co += 1 <NEWLINE> <NL> <NL> <NL> <DEDENT> <DEDENT> print ( int ( a ) * po // ( 10 ** co ) ) ) <NEWLINE> <NL>
<COMMENT> <NL> ans = 1 <NEWLINE> for i in map ( int , input ( ) . split ( ) ) : ans *= i <NEWLINE> print ( int ( ans ) ) <NEWLINE>
a , b = list ( map ( int , float , input ( ) . split ( ) ) ) <NEWLINE> print ( int ( a * b ) ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> from decimal import Decimal <NEWLINE> a , b = map ( float , input ( ) . split ( ) ) <NEWLINE> c = decimal ( a ) <NEWLINE> d = decimal ( b ) <NEWLINE> print ( int ( c * d ) ) <NEWLINE> return <NEWLINE> <DEDENT> main ( ) <NEWLINE>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> sys . setrecursionlimit ( 10 ** 8 ) <NEWLINE> from itertools import accumulate <NEWLINE> from itertools import permutations <NEWLINE> from itertools import combinations <NEWLINE> from collections import defaultdict <NEWLINE> from collections import Counter <NEWLINE> import fractions <NEWLINE> import math <NEWLINE> from collections import deque <NEWLINE> from bisect import bisect_left <NEWLINE> from bisect import insort_left <NEWLINE> import itertools <NEWLINE> from heapq import heapify <NEWLINE> from heapq import heappop <NEWLINE> from heapq import heappush <NEWLINE> import heapq <NEWLINE> from copy import deepcopy <NEWLINE> from decimal import Decimal <NEWLINE> alf = list ( <STRING> ) <NEWLINE> ALF = list ( <STRING> ) <NEWLINE> <COMMENT> <NL> INF = float ( <STRING> ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> A , B = map ( float , input ( ) . split ( ) ) <NEWLINE> if round ( A ) == 0 or B <= 0.005 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a = int ( A ) <NEWLINE> b = Decimal ( B ) <NEWLINE> print ( floor ( a * b ) ) <NEWLINE> <NL> <NL> <NL> <NL> <NL> <NL> <DEDENT>
a , b = input ( ) . split ( ) <NEWLINE> a = int ( a ) <NEWLINE> b_100 = round ( 100 * b ) <NEWLINE> times = a * b_100 <NEWLINE> new_times = times / 100 <NEWLINE> print ( new_times ) <NEWLINE>
a = int ( input ( ) ) <NEWLINE> b = float ( input ) <NEWLINE> b_int = int ( b * 100 ) <NEWLINE> <NL> ans = a * b_int // 100 <NEWLINE> print ( ans <NEWLINE>
A , B = input ( ) . split ( ) <NEWLINE> A = int ( A ) <NEWLINE> B = float ( B ) <NEWLINE> B_ = round ( B * 100 ) <NEWLINE> C = A * B_ <NEWLINE> C_ = str ( C ) <NEWLINE> if C < 100 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( C [ : - 2 ] ) <NEWLINE> <DEDENT>
a , b = map ( float , input ( ) . split ( ) ) <NEWLINE> ans = a * b <NEWLINE> <NL> print ( math . floor ( ans ) ) <NEWLINE>
A , B = map ( double , input ( ) . split ( ) ) <NEWLINE> print ( int ( math . floor ( A * B ) ) ) <NEWLINE>
from decimal import * <NEWLINE> A , B = map ( float , input ( ) . split ( ) ) <NEWLINE> B = int ( B * 100 ) <NEWLINE> A = int ( A ) <NEWLINE> ans = A * B <NEWLINE> ans = // 10 <NEWLINE> ans = // 10 <NEWLINE> print ( ans ) <NEWLINE>
import math <NEWLINE> A , B = input ( ) . split ( ) <NEWLINE> <NL> if ( float ( B ) - ( int ( float ( B ) ) ) ) * 100 * 100 == 28.99999999999999 : <NEWLINE> <INDENT> D = 29 + int ( float ( B ) ) * 100 <NEWLINE> <DEDENT> elif ( float ( B ) - ( int ( float ( B ) ) ) ) * 100 * 100 == 57.99999999999999 : <NEWLINE> <INDENT> D = 58 + int ( float ( B ) ) * 100 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> D = int ( float ( B ) * 100 ) <NEWLINE> <NL> <DEDENT> C = math . floor ( int ( A ) * int ( B ) / 100 ) <NEWLINE> print ( C ) <NEWLINE>
from decimal import Desimal <NEWLINE> import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> a , b = [ Desimal ( i ) for i in input ( ) . split ( ) ] <NEWLINE> a = int ( a ) <NEWLINE> b = int ( float ( b ) * 100 ) <NEWLINE> ans = a * b // 100 <NEWLINE> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
A , B = input ( ) . split ( ) <NEWLINE> A = int ( a ) <NEWLINE> B = int ( B [ 0 ] + B [ 2 : ] ) <NEWLINE> print ( A * B // 100 ) <NEWLINE>
from decimal import Decimal <NEWLINE> a , b = map ( Decimal , input ( ) . split ( ) ) <NEWLINE> <NL> print ( math . floor ( a * b ) ) <NEWLINE>
a , b = map ( input ( ) . split ( ) ) <NEWLINE> b = b * 100 <NEWLINE> print ( a * b / 100 ) <NEWLINE>
import math <NEWLINE> <NL> A , B = input ( ) . split ( <STRING> ) <NEWLINE> A = int ( A ) <NEWLINE> B = int ( B ) <NEWLINE> <NL> print ( math . floor ( A * B ) ) <NEWLINE>
a , b = input ( ) . split ( ) <NEWLINE> a = int ( a ) <NEWLINE> b = int ( b * 1000 ) <NEWLINE> x = int ( ( a * b ) // 1000 ) <NEWLINE> print ( x ) <NEWLINE>
A , B = map ( float , input ( ) . split ( ) ) <NEWLINE> ans = Decimal ( A ) * Decimal ( B ) <NEWLINE> print ( int ( ans ) ) <NEWLINE>
from decimal import Decimal <NEWLINE> a , b = input ( ) . split ( ) <NEWLINE> c = ( int ( a ) * ( decimal ( b ) * 1000000 ) ) / 1000000 <NEWLINE> print ( int ( c // 1 ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> a , b = input ( ) . split ( ) <NEWLINE> b = 100 * b <NEWLINE> <NL> answer = a * b // 100 <NEWLINE> print ( answer ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( int ( a * b ) ) <NEWLINE>
import math <NEWLINE> from decimal import * <NEWLINE> <NL> sa , sb = input ( ) . split ( ) <NEWLINE> a = Decimal ( sa ) <NEWLINE> b = float ( sb ) <NEWLINE> lb = Decimal ( b * 100 ) <NEWLINE> <NL> ans = Decimalc ( Decimal ( a * lb ) // Decimal ( 100 ) ) <NEWLINE> print ( int ( ans ) ) <NEWLINE>
a = input ( ) . split ( ) <NEWLINE> for i in range ( 2 ) : <NEWLINE> <INDENT> a [ i ] = int ( a [ i ] ) if i == 0 else float ( a [ i ] * 100 ) <NEWLINE> <DEDENT> print ( int ( a [ 0 ] * a [ 1 ] / 100 ) ) <NEWLINE>
a , b = input ( ) . split ( ) <NEWLINE> ai = int ( a ) <NEWLINE> bf = froat ( b ) <NEWLINE> print ( int ( ai * bf ) ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> a , b = input ( ) . split ( ) <NEWLINE> cnt = 1 <NEWLINE> a = int ( a ) <NEWLINE> a1 = a <NEWLINE> while True : <NEWLINE> <INDENT> if a % 10 == 0 : <NEWLINE> <INDENT> a /= 10 <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> if cnt >= 2 : <NEWLINE> <INDENT> b = float ( b ) <NEWLINE> <COMMENT> <NL> ans = int ( a * b * 100 ) * ( 10 ** ( cnt - 2 ) ) <NEWLINE> print ( ans ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( int ( a1 * b ) ) <NEWLINE> <NL> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = int ( ( A * B ) // 1 ) <NEWLINE> print ( ans ) <NEWLINE>
( a , b ) = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> bb = int ( b * 100 ) <NEWLINE> abb = a * bb <NEWLINE> ans = abb // 100 <NEWLINE> print ( ans ) <NEWLINE>
a , b = float ( input ( ) . split ( ) ) <NEWLINE> ans = int ( a * b + 0.00001 ) <NEWLINE> print ( ans ) <NEWLINE>
<NL> from collections import Counter <NEWLINE> from collections import defaultdict <NEWLINE> from collections import deque <NEWLINE> from functools import reduce <NEWLINE> import math <NEWLINE> import itertools <NEWLINE> import heapq <NEWLINE> import numpy as np <NEWLINE> import bisect <NEWLINE> import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> <NL> <NL> def bfs ( s , n , node ) : <NEWLINE> <COMMENT> <NL> <INDENT> check = [ False for _ in range ( n ) ] <NEWLINE> check [ s ] = True <NEWLINE> <COMMENT> <NL> queue = deque ( [ s ] ) <NEWLINE> visited_num = 1 <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> color = [ - 1 for _ in range ( n ) ] <NEWLINE> color [ s ] = 0 <NEWLINE> <NL> while visited_num < n : <NEWLINE> <COMMENT> <NL> <INDENT> if len ( queue ) == 0 : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <INDENT> return color <NEWLINE> <NL> <DEDENT> now_vertex = queue . popleft ( ) <NEWLINE> <COMMENT> <NL> for next_vertex in node [ now_vertex ] : <NEWLINE> <NL> <NL> <INDENT> if check [ next_vertex ] == True : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <DEDENT> queue . append ( next_vertex ) <NEWLINE> check [ next_vertex ] = True <NEWLINE> <NL> <COMMENT> <NL> color [ next_vertex ] = color [ now_vertex ] + 1 <NEWLINE> visited_num += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> return color <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> ceil = lambda x , y : ( x + y - 1 ) // y <NEWLINE> input_list = lambda : list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> <NL> <COMMENT> <NL> n , m = input_list ( ) <NEWLINE> <COMMENT> <NL> <NL> print ( math . floor ( n * m ) ) <NEWLINE>
A , B = map ( int , input ( ) ) <NEWLINE> print ( ( A * B ) // 1 ) <NEWLINE>
import math <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> a , b = list ( input ( ) . split ( ) ) <NEWLINE> c = int ( a ) <NEWLINE> d = float ( b ) <NEWLINE> e = d * 100 <NEWLINE> c *= e <NEWLINE> c /= 100 <NEWLINE> c = math . floor ( c ) <NEWLINE> print ( ac ) <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE>
a , b = input ( ) . split ( ) <NEWLINE> a = int ( a ) <NEWLINE> b = int ( round ( b * 100 ) ) <NEWLINE> print ( int ( rount ( a * b / 100 ) ) ) <NEWLINE>
a = input ( ) . split ( ) <NEWLINE> <NL> fa = int ( a [ 0 ] ) <NEWLINE> fb = int ( a [ 1 ] * 100 ) <NEWLINE> <NL> print ( fa * fb // 100 ) <NEWLINE>
a , b = map ( float , input ( ) . split ( ) ) <NEWLINE> <NL> A = int ( A ) <NEWLINE> B = int ( round ( float ( B ) * 100 ) ) <NEWLINE> <NL> print ( a * b // 100 ) <NEWLINE> <NL>
a , b = map ( str , input ( ) . split ( ) ) <NEWLINE> b . replace ( <STRING> ) <NEWLINE> print ( a * b // 100 ) <NEWLINE>
from decimal import Decimal <NEWLINE> <NL> IN = input ( ) . split ( ) <NEWLINE> A = Decimal ( IN [ 0 ] ) <NEWLINE> B = Decimal ( IN [ 1 ] ) <NEWLINE> <NL> ans = A * B <NEWLINE> <NL> if ans < 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> math . floor ( ans ) <NEWLINE> <DEDENT>
a , b = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> print ( a * ( b * 100 ) / 100 ) <NEWLINE>
import math <NEWLINE> from decimal import Decimal <NEWLINE> a , b = input ( ) . split ( ) <NEWLINE> // a = decimal . Decimal ( a ) <NEWLINE> // b = decimal . Decimal ( b ) <NEWLINE> print ( math . floor ( Decimal ( a ) * Decimal ( b ) ) ) <NEWLINE>
import math <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> a , b = input ( ) . split ( ) <NEWLINE> result = int ( a ) * int ( b * 100 ) <NEWLINE> print ( int ( math . floor ( result / 100 ) ) ) <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( b * 100 * a // 100 ) <NEWLINE>
a , b = map ( str , input ( ) . split ( ) ) <NEWLINE> a , b = int ( a ) , int ( b * 100 ) <NEWLINE> print ( a * b // 100 ) <NEWLINE>
def resolve ( ) : <NEWLINE> <INDENT> A , B = map ( float , input ( ) . split ( ) ) <NEWLINE> <NL> print ( math . floor ( A * B ) ) <NEWLINE> <NL> <DEDENT> resolve ( ) <NEWLINE>
import math <NEWLINE> A , B = map ( float , input ( ) . split ( ) ) <NEWLINE> a = int ( A ) <NEWLINE> x = a * B <NEWLINE> y = math . round ( x ) <NEWLINE> print ( int ( y ) ) <NEWLINE>
from decimal import Decimal <NEWLINE> a , b = input ( ) . split ( ) <NEWLINE> a = int ( a ) <NEWLINE> b = decimal . Decimal ( b ) <NEWLINE> c = a * b * 100 // 100 <NEWLINE> print ( int ( c ) ) <NEWLINE>
a , b = input ( ) . split ( ) <NEWLINE> a = int ( a ) <NEWLINE> b = Decimal ( b ) <NEWLINE> print ( int ( a * b ) ) <NEWLINE>
import math <NEWLINE> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( int ( math . floor ( a * b ) ) ) <NEWLINE>
nums = [ x for x in input ( ) . split ( ) ] <NEWLINE> a , b = int ( nums [ 0 ] ) , float ( nums [ 1 ] ) 198 1.10 <NEWLINE> <NL> print ( int ( a * b ) ) <NEWLINE>
<NL> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> count = 1 <NEWLINE> for i in a : <NEWLINE> <INDENT> count *= i <NEWLINE> <DEDENT> if count > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( count ) <NEWLINE> <DEDENT>
import math <NEWLINE> a , b = input ( ) . split ( ) <NEWLINE> print ( math . floor ( a * b ) ) <NEWLINE>
def cc ( ) : <NEWLINE> <INDENT> a , b = map ( str , input ( ) . split ( ) ) <NEWLINE> a2 = int ( a ) <NEWLINE> b2 = int ( b . replace ( <STRING> , <STRING> ) ) <NEWLINE> c = a2 * b2 <NEWLINE> ans = str ( c ) [ 0 : - 2 ] if len ( c ) > 2 else 0 <NEWLINE> print ( ans ) <NEWLINE> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> cc ( ) <NEWLINE> <DEDENT>
x0 , x1 = list ( map ( flaot , input ( ) . split ( ) ) ) <NEWLINE> print ( int ( x0 * x1 ) ) <NEWLINE>
a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> print ( int ( a [ 0 ] * ( a [ 1 ] * 100 ) / 100 ) ) <NEWLINE>
num = list ( input ( ) . split ( ) ) <NEWLINE> <NL> A = int ( num [ 0 ] ) <NEWLINE> B = int ( float ( num [ 1 ] ) * 100 <NEWLINE> print ( A * B // 100 ) <NEWLINE>
a , b = input ( ) . split ( ) <NEWLINE> a = int ( a ) <NEWLINE> b . replace ( <STRING> , <STRING> ) <NEWLINE> b = int ( b ) <NEWLINE> print ( ( a * b ) // 100 ) <NEWLINE>
A , B = input ( ) . split ( ) <NEWLINE> <NL> print ( int ( A ) * round ( float ( b ) * 100 ) // 100 ) <NEWLINE>
A , B = int ( input ( ) ) , float ( input ( ) ) <NEWLINE> print ( int ( A * B ) ) <NEWLINE>
A = int ( input ( ) ) <NEWLINE> B = input ( ) <NEWLINE> b = int ( B . replace ( <STRING> , <STRING> ) ) <NEWLINE> print ( A * b // 100 ) <NEWLINE>
A = int ( input ( ) ) <NEWLINE> B = float ( input ( ) ) <NEWLINE> print ( int ( A * B ) ) <NEWLINE>
a , b = input ( ) . split ( ) <NEWLINE> a = int ( a ) <NEWLINE> b = int ( float ( b ) * 100 ) <NEWLINE> result = ( ( a * b ) // 10 ) // 10 ) <NEWLINE>
A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( ( A * ( B * 100 ) ) // 100 ) <NEWLINE>
input_count = 0 <NEWLINE> <NL> A , B = input ( ) . split ( ) <NEWLINE> <NL> A = int ( A ) <NEWLINE> if <STRING> in B : <NEWLINE> <INDENT> B_a = int ( B . split ( <STRING> ) [ 0 ] ) <NEWLINE> B_b_size = len ( B . split ( <STRING> ) [ 1 ] ) <NEWLINE> B_b = int ( B . split ( <STRING> ) [ 1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> B_a = int ( B ) <NEWLINE> B_b_size = 0 <NEWLINE> B_b = 1 <NEWLINE> <DEDENT> ans_a = A * B_a <NEWLINE> ans_b = A * math . pow ( 10 , - 1 * B_b_size ) * B_b <NEWLINE> ans = ans_a + int ( ans_b ) <NEWLINE> print ( ans ) <NEWLINE>
from decimal import * <NEWLINE> a , b = map ( float , input ( ) . split ( ) ) <NEWLINE> <NL> num = Decimal ( <STRING> ) * Decimal ( <STRING> ) <NEWLINE> print ( int ( num ) ) <NEWLINE>
a , b = input ( ) . split ( ) ; print ( ( int ( a ) * int ( b . strip ( <STRING> ) ) ) // 100 ) <NEWLINE>
import decimal <NEWLINE> a , b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> x = decimal . Decimal ( a ) <NEWLINE> y = decimal . Decimal ( b ) <NEWLINE> print ( x * y ) <NEWLINE>
a , b = input ( ) . split ( ) <NEWLINE> x , d , y , z = b <NEWLINE> nb = int ( x ) + int ( y + z ) / 100 <NEWLINE> print ( int ( a * nb ) ) <NEWLINE>
import math <NEWLINE> A , B = list ( map ( decimal , input ( ) . split ( ) ) ) <NEWLINE> B = B * 100 <NEWLINE> print ( math . floor ( A * B / 100 ) ) <NEWLINE>
from decimal import * <NEWLINE> i = input ( ) . split ( ) <NEWLINE> a = int ( i [ 0 ] ) <NEWLINE> b = Decimal ( i [ 1 ] ) i <NEWLINE> print ( int ( a * b ) ) <NEWLINE>
import math <NEWLINE> <NL> a , b = map ( float , input ( ) . split ( ) ) <NEWLINE> if a = 0 or b = 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( int ( a * b ) ) <NEWLINE> <DEDENT>
import sys <NEWLINE> import math <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = a [ 0 ] <NEWLINE> <NL> for i in range ( 1 , n ) : <NEWLINE> <INDENT> ans *= a [ i ] <NEWLINE> if math . log10 ( ans ) > 18 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import heapq <NEWLINE> from sys import stdin <NEWLINE> input = stdin . readline <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> a , b = map ( float , input ( ) . split ( ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> b = int ( b * 100 ) <NEWLINE> a = int ( a ) <NEWLINE> print ( a * b // 100 ) <NEWLINE> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
A , B = map ( str , input ( ) . split ( ) ) <NEWLINE> <NL> B = str ( int ( float ( B ) * 100 + 0.00001 ) ) <NEWLINE> <NL> <COMMENT> <NL> ans = [ ] <NEWLINE> p = [ [ ] for k in range ( len ( B ) ) ] <NEWLINE> for k in range ( len ( B ) ) : <NEWLINE> <INDENT> for j in range ( k ) : <NEWLINE> <INDENT> p [ k ] . append ( 0 ) <NEWLINE> <DEDENT> <DEDENT> for k in range ( 1 , len ( B ) + 1 ) : <NEWLINE> <INDENT> a = 0 <NEWLINE> for j in range ( 1 , len ( A ) + 1 ) : <NEWLINE> <INDENT> if a > 9 : <NEWLINE> <INDENT> a = int ( str ( a ) [ 0 ] ) + int ( B [ - k ] ) * int ( A [ - j ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a = int ( B [ - k ] ) * int ( A [ - j ] ) <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> p [ k - 1 ] . append ( int ( str ( a ) [ - 1 ] ) ) <NEWLINE> if j == len ( A ) and a > 9 : <NEWLINE> <INDENT> p [ k - 1 ] . append ( int ( str ( a ) [ 0 ] ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for k in range ( len ( B ) ) : <NEWLINE> <INDENT> for j in range ( len ( p [ - 1 ] ) - len ( p [ k ] ) ) : <NEWLINE> <INDENT> p [ k ] . append ( 0 ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> a = 0 <NEWLINE> for k in range ( len ( p [ 0 ] ) ) : <NEWLINE> <INDENT> if int ( a ) > 9 : <NEWLINE> <INDENT> a = int ( str ( a ) [ 0 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a = 0 <NEWLINE> <DEDENT> for j in range ( len ( p ) ) : <NEWLINE> <INDENT> a += p [ j ] [ k ] <NEWLINE> <DEDENT> ans . append ( str ( a ) [ - 1 ] ) <NEWLINE> if k == len ( p [ 0 ] - 1 ) and a > 9 : <NEWLINE> <INDENT> ans . append ( str ( a ) [ 0 ] ) <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> op = <STRING> <NEWLINE> for k in range ( 1 , len ( ans ) - 1 ) : <NEWLINE> <INDENT> op += ans [ - k ] <NEWLINE> <DEDENT> if len ( ans ) < 3 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( op ) <NEWLINE> <DEDENT>
<INDENT> from sys import stdin <NEWLINE> <DEDENT> input = stdin . readline <NEWLINE> <NL> <NL> a , b = map ( str , input ( ) . split ( ) ) <NEWLINE> a = int ( a ) <NEWLINE> b = int ( ( float ( b ) + 0.001 ) * 100 ) <NEWLINE> ans = int ( a * b // 100 ) <NEWLINE> print ( ans ) <NEWLINE>
a , b = map ( str , input ( ) . split ( ) ) <NEWLINE> <NL> a = int ( a ) <NEWLINE> <NL> b = 100 * int ( b [ 0 ] ) + 10 * int ( b [ 2 ] ) + 1 * int ( v [ 3 ] ) <NEWLINE> <NL> print ( ( a * b ) // 100 ) <NEWLINE>
import decimal <NEWLINE> a , b = input ( ) . split ( ) <NEWLINE> <NL> b = decimal ( b ) <NEWLINE> <NL> ans = a * b <NEWLINE> print ( int ( ans ) ) <NEWLINE> <NL>
import math <NEWLINE> a , b = input ( ) . split ( ) <NEWLINE> b = int ( b * 100 ) <NEWLINE> print ( ( a * b ) // 100 ) <NEWLINE> <NL>
a , b = input ( ) . split ( ) <NEWLINE> a = int ( a ) <NEWLINE> b = int ( b * 100 ) <NEWLINE> p = ( a * b ) // 100 <NEWLINE> print ( p ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 8 ) <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> A , B = map ( str , input ( ) . split ( ) ) <NEWLINE> <NL> C = int ( B * 100 ) <NEWLINE> print ( A * C // 100 ) <NEWLINE>
import math <NEWLINE> A , B = input ( ) . split ( ) <NEWLINE> A = int ( A ) <NEWLINE> B = float ( B ) <NEWLINE> B = format ( B , <STRING> ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> ans = A * B <NEWLINE> print ( math . floor ( ans ) ) <NEWLINE>
import math <NEWLINE> <NL> a , b = input ( ) . split ( ) <NEWLINE> A , B = [ int ( a ) , int ( b . replace ( <STRING> , <STRING> ) ] <NEWLINE> <NL> print ( A * B // 100 ) <NEWLINE>
a , b = input ( ) . split ( ) <NEWLINE> a = int ( a ) <NEWLINE> b = str ( b ) <NEWLINE> b . replace ( <STRING> , <STRING> ) <NEWLINE> b = int ( b ) <NEWLINE> print ( a * b // 100 ) <NEWLINE>
import math <NEWLINE> import decimal <NEWLINE> A , B = input ( ) . split ( ) <NEWLINE> print ( Decimal ( A ) * Decimal ( B ) // 1 ) <NEWLINE>
ab = input ( ) . split ( ) <NEWLINE> a = int ( ab [ 0 ] ) <NEWLINE> b = int ( ab [ 0 ] + ab [ 2 ] + ab [ 3 ] ) <NEWLINE> <NL> s = a * b <NEWLINE> print ( int ( s / 100 ) ) <NEWLINE>
a , b = input ( ) . split ( ) <NEWLINE> a = int ( a ) <NEWLINE> <COMMENT> <NL> b = int ( b . replace ( <STRING> . <STRING> ) ) <NEWLINE> print ( int ( a * b ) // 100 ) <NEWLINE>
from decimal import Decimal <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> x , y = map ( Decimalt , input ( ) . split ( ) ) <NEWLINE> print ( int ( x * y ) ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
A , B = [ int ( n ) for n in input ( ) . split ( ) ] <NEWLINE> <NL> ans = int ( A * B ) <NEWLINE> print ( ans ) <NEWLINE>
a , b = map ( float , input ( ) . split ( ) ) <NEWLINE> <NL> print ( long ( a * b ) ) <NEWLINE>
a , b = input ( ) . split ( ) <NEWLINE> a = int ( a ) <NEWLINE> b = b * 1000 <NEWLINE> print ( int ( a * b / 1000 ) ) <NEWLINE>
N = list ( input ( ) . split ( ) ) <NEWLINE> A = int ( N [ 0 ] ) <NEWLINE> b1 , b2 = N [ 1 ] . split ( <STRING> ) <NEWLINE> B = int ( b1 + b2 ) <NEWLINE> prd = list ( str ( A * B ) ) <NEWLINE> ans = 0 <NEWLINE> if len ( prd ) < 3 : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> prd . pop ( - 1 , - 2 ) <NEWLINE> ans = int ( <STRING> . join ( prd ) ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
A , B = input ( ) . split ( ) <NEWLINE> B2 = float ( B ) * 100 <NEWLINE> print ( int ( A * B2 ) ) <NEWLINE>
from decimal import * <NEWLINE> import math <NEWLINE> a , b = map ( str , input ( ) . split ( ) ) <NEWLINE> c = Decimal ( <STRING> ) <NEWLINE> d = Decimal ( <STRING> ) <NEWLINE> e = Decimal ( <STRING> ) <NEWLINE> f = math . floor ( e ) <NEWLINE> print ( f ) <NEWLINE>
a , b = input ( ) . split ( ) <NEWLINE> A = int ( a ) <NEWLINE> B = int ( b * 100 ) <NEWLINE> ans = A * B // 100 <NEWLINE> print ( ans ) <NEWLINE>
a , b = map ( float , input ( ) . split ( ) ) <NEWLINE> b = b . replace ( <STRING> , <STRING> ) <NEWLINE> print ( int ( a * b / 100 ) ) <NEWLINE>
a , b = input ( ) . split ( ) <NEWLINE> a = int ( a ) <NEWLINE> b = int ( 100 * int ( b . split ( <STRING> ) ) ) <NEWLINE> <NL> <NL> def solve ( a , b ) : <NEWLINE> <INDENT> return a * b // 100 <NEWLINE> <NL> <NL> <DEDENT> print ( solve ( a , b ) ) <NEWLINE>
import Decimal from decimal <NEWLINE> a , b = map ( Decimal , input ( ) . split ( ) ) <NEWLINE> print ( int ( a * b ) ) <NEWLINE>
a , b = input ( ) . split ( ) <NEWLINE> ans = a * b <NEWLINE> ans = ans // 1 <NEWLINE> print ( int ( ans ) ) <NEWLINE>
A , B = map ( float , input ( ) . split ( ) ) <NEWLINE> <NL> print ( int ( ( A * ( B * 100 ) // 100 ) ) <NEWLINE>
a = int ( input ( ) ) <NEWLINE> b = float ( input ( ) ) <NEWLINE> print ( int ( a * b ) ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> int ( a * b ) <NEWLINE>
import math <NEWLINE> A , B = list ( map ( float , input ( ) . split ( ) ) ) <NEWLINE> A = int ( A ) <NEWLINE> print ( math . floor ( A * ( B * 100 ) / 100 ) ) s <NEWLINE>
from decimal improt Decimal <NEWLINE> a , b = map ( Decimal , input ( ) . split ( ) ) <NEWLINE> print ( int ( a * b ) ) <NEWLINE>
s = input ( ) . split ( ) <NEWLINE> s = [ float ( i ) for i in s ] <NEWLINE> <NL> <COMMENT> <NL> tmp = int ( ( s [ 0 ] * int ( s [ 1 ] * 100 ) / 100 ) <NEWLINE> print ( tmp ) <NEWLINE>
a , b = input ( ) . split ( ) <NEWLINE> a = int ( a ) ; b , d = map ( int , b . spit ( <STRING> ) ) <NEWLINE> print ( a * b + a * d // 100 ) <NEWLINE>
ab = input ( ) . split ( ) <NEWLINE> a = int ( ab [ 0 ] ) <NEWLINE> b = ab [ 1 ] . replace ( <STRING> , <STRING> ) <NEWLINE> ans = a * b // 100 <NEWLINE> print ( ans ) <NEWLINE>
a , b = input ( ) . split ( ) <NEWLINE> b = b * 100 <NEWLINE> a = int ( a ) <NEWLINE> b = int ( b ) <NEWLINE> print ( ( a * b ) // 100 ) <NEWLINE>
import sys <NEWLINE> import math <NEWLINE> <NL> readline = sys . stdin . readline <NEWLINE> readall = sys . stdin . read <NEWLINE> ns = lambda : readline ( ) . rstrip ( ) <NEWLINE> ni = lambda : int ( readline ( ) . rstrip ( ) ) <NEWLINE> nm = lambda : map ( int , readline ( ) . split ( ) ) <NEWLINE> nl = lambda : list ( map ( int , readline ( ) . split ( ) ) ) <NEWLINE> prl = lambda x : print ( * x , sep = <STRING> ) <NEWLINE> <NL> a , b = input ( ) . split ( <STRING> ) <NEWLINE> a = int ( a ) <NEWLINE> b = float ( b ) <NEWLINE> t = str ( b ) . replace ( <STRING> , <STRING> ) <NEWLINE> res = 0 <NEWLINE> for i in range ( 3 ) : <NEWLINE> <INDENT> res += int ( str ( t ) [ i ] ) * a // ( 10 ** i ) <NEWLINE> <DEDENT> print ( int ( res ) ) <NEWLINE>
import match <NEWLINE> from decimal import Decimal <NEWLINE> a , b = map ( map ( Decimal , input ( ) . split ( ) ) ) ; <NEWLINE> c = a * b <NEWLINE> print ( math . floor ( c ) ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> c = b * 100 <NEWLINE> print ( a * c // 100 ) <NEWLINE>
a = int ( input ( ) ) <NEWLINE> b = float ( input ( ) ) <NEWLINE> <NL> print ( int ( a * b ) ) <NEWLINE>
a , b = input ( ) . split ( ) <NEWLINE> a = int ( a ) <NEWLINE> b = int ( float ( b * 100 ) ) <NEWLINE> print ( a * b // 100 ) <NEWLINE>
import math <NEWLINE> a , b = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> print ( math . floor ( a * b ) ) <NEWLINE>
i = input ( ) . split ( ) <NEWLINE> a = int ( i [ 0 ] ) <NEWLINE> b = int ( i [ 0 ] + i [ 2 : ] ) <NEWLINE> print ( a * b // 100 ) <NEWLINE>
from decimal import Decimal <NEWLINE> from sys import stdin <NEWLINE> def LD ( ) : return list ( map ( Decimal , stdin . readline ( ) . rstrip ( ) . split ( ) ) ) <NEWLINE> <NL> tmp = LD ( ) <NEWLINE> ans = int ( a * b ) <NEWLINE> print ( ans ) <NEWLINE>
a , b = input ( ) . split ( ) <NEWLINE> <NL> b = int ( b ) * 100 <NEWLINE> <NL> print ( ( int ( a ) * b ) // 100 ) <NEWLINE>
from decimal import Decimal <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> a , b = input ( ) . split ( ) <NEWLINE> v = int ( ( Decimal ( a ) * Decimal ( b ) ) <NEWLINE> print ( v ) <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE>
a , b = input ( ) . split ( ) <NEWLINE> ai = int ( a ) <NEWLINE> b = int ( float ( b ) * 100 ) // 1 <NEWLINE> <NL> print ( int ( a * b / 100 ) ) <NEWLINE>
import decimal from decimal <NEWLINE> import math <NEWLINE> <NL> A , B = input ( ) . split ( ) <NEWLINE> <NL> B = decimal ( B ) <NEWLINE> A = int ( A ) <NEWLINE> product = A * B <NEWLINE> <NL> print ( math . floor ( product ) ) <NEWLINE>
from decimal import Decimal <NEWLINE> a , b = input ( ) . split ( ) <NEWLINE> a = decimal ( a ) <NEWLINE> b = decimal ( b ) <NEWLINE> print ( a * b ) <NEWLINE>
a , b = map ( float , input ( ) . split ( ) ) <NEWLINE> a = int ( a ) <NEWLINE> b = int ( b * 100 ) <NEWLINE> print ( int ( c // 100 ) ) <NEWLINE>
a , b = int ( input ( ) . split ( ) [ 0 ] ) , float ( input ( ) . split ( ) [ 1 ] ) <NEWLINE> <NL> print ( int ( floor ( a * b ) ) ) <NEWLINE>
<COMMENT> <NL> <NL> int main ( ) { <NEWLINE> <INDENT> double a , b ; <NEWLINE> long m ; <NEWLINE> scanf ( <STRING> , & a , & b ) ; <NEWLINE> m = a * b ; <NEWLINE> printf ( <STRING> , m ) ; <NEWLINE> return 0 ; <NEWLINE> <DEDENT> } <NEWLINE>
import decimal <NEWLINE> a , b = map ( str , input ( ) . split ( ) ) <NEWLINE> c = decimal . Decimal ( a ) * decimal . Decimal ( b ) <NEWLINE> print ( decimal . Decimal ( str ( c ) ) . quantize ( decimal . Decimal ( <STRING> ) , rounding = ROUND_FLOOR ) ) <NEWLINE>
A , B = map ( float , input ( ) . split ( ) ) <NEWLINE> A = int ( A ) <NEWLINE> C = str ( B ) <NEWLINE> if B == 10.0 : <NEWLINE> <INDENT> D = 1000 <NEWLINE> <DEDENT> elif B == 0.0 : <NEWLINE> <INDENT> D = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> D = int ( C [ - 1 ] ) + int ( C [ - 2 ] ) * 10 + int ( C [ - 4 ] ) * 100 <NEWLINE> <DEDENT> ans = A * D <NEWLINE> ans = ans // 100 <NEWLINE> print ( ans ) <NEWLINE>
a , b = input ( ) . split ( ) <NEWLINE> <NL> a = int ( a ) <NEWLINE> b = int ( b . replcae ( <STRING> , <STRING> ) ) <NEWLINE> <NL> print ( ( a * b ) // 100 ) <NEWLINE>
import math <NEWLINE> A , B = list ( map ( decimal , input ( ) . split ( ) ) ) <NEWLINE> print ( math . floor ( A * B ) ) <NEWLINE>
import math <NEWLINE> n = int ( input ( ) ) <NEWLINE> if n == 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> def makeprime ( value ) : <NEWLINE> <INDENT> flag = [ True for _ in range ( value ) ] <NEWLINE> ans = [ ] <NEWLINE> for i in range ( 1 , len ( flag ) ) : <NEWLINE> <INDENT> if flag [ i ] : <NEWLINE> <INDENT> ans . append ( i + 1 ) <NEWLINE> for j in range ( i , len ( flag ) , i + 1 ) : <NEWLINE> <INDENT> flag [ j ] = False <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return ans <NEWLINE> <DEDENT> for i in range ( 2 , int ( math . sqrt ( n ) + 1 ) ) : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> flag = 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> flag = 0 <NEWLINE> <DEDENT> if flag : <NEWLINE> <INDENT> u = [ ] <NEWLINE> r = n <NEWLINE> ans = 0 <NEWLINE> rem = makeprime ( int ( math . sqrt ( n ) ) ) <NEWLINE> for i in rem : <NEWLINE> <INDENT> o = 1 <NEWLINE> while ( i ** o <= n ) : <NEWLINE> <INDENT> u . append ( i ** o ) <NEWLINE> o += 1 <NEWLINE> <DEDENT> <DEDENT> u . sort ( ) <NEWLINE> for i in u : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> n //= i <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT>
a , b = input ( ) . split ( ) <NEWLINE> a = int ( a ) <NEWLINE> b = int ( float ( b ) * 100 ) <NEWLINE> print ( string ( a * b ) [ : - 2 ] ) <NEWLINE>
import math <NEWLINE> <NL> a , b = input ( ) . split ( ) <NEWLINE> a = int ( a ) <NEWLINE> b_int = int ( b ) <NEWLINE> b_fric = b - b_int <NEWLINE> r1 = a * b_int <NEWLINE> r2 = a * b_fric // 100 <NEWLINE> result = r1 + r2 <NEWLINE> print ( result ) <NEWLINE>
from math import ceil , floor <NEWLINE> from decimal import Decimal <NEWLINE> <NL> A , B = input ( ) . split ( ) <NEWLINE> A = int ( A ) <NEWLINE> B = float ( B ) <NEWLINE> B1 = int ( B ) <NEWLINE> B2 = int ( str ( B ) [ - 2 : ] ) <NEWLINE> <NL> ans1 = Decimal ( A ) * Decimal ( B1 ) <NEWLINE> ans2 = Decimal ( A ) * Decimal ( B2 ) // 100 <NEWLINE> <NL> ans = ans1 + ans2 <NEWLINE> print ( ans ) <NEWLINE>
A , B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> print ( int ( A * B ) ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> s = a * b * 100 <NEWLINE> print ( s // 100 ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( int ( a * b ) ) <NEWLINE>
a , b = input ( ) . split ( ) <NEWLINE> a = int ( a ) <NEWLINE> b . replace ( <STRING> , <STRING> ) <NEWLINE> b = int ( b ) <NEWLINE> print ( a * b // 100 ) <NEWLINE>
A , B = input ( ) . split ( ) <NEWLINE> A = int ( A ) <NEWLINE> B = float ( B * 100 ) <NEWLINE> <NL> s = A * B <NEWLINE> s = s // 100 <NEWLINE> print ( int ( s ) ) <NEWLINE>
import math <NEWLINE> hoge = list ( input ( ) . split ( ) ) <NEWLINE> A = int ( hoge [ 0 ] ) <NEWLINE> B1 = int ( hoge [ 1 ] ) <NEWLINE> B2 = ( float ( hoge [ 1 ] ) - B1 ) * 100 <NEWLINE> ans = A * B1 + A * B2 // 100 <NEWLINE> print ( ans ) <NEWLINE>
from Decimal import decimal <NEWLINE> <NL> A , B = map ( decimal , input ( ) . split ( ) ) <NEWLINE> print ( A * B ) <NEWLINE>
A , B = input ( ) . split ( ) <NEWLINE> a = int ( A ) <NEWLINE> b = round ( float ( B ) * 100 ) <NEWLINE> <NL> print ( ( A * B ) // 100 ) <NEWLINE>
A , B = input ( ) . split ( ) <NEWLINE> A = int ( A ) <NEWLINE> B = int ( B * 100 ) <NEWLINE> print ( A * B // 100 ) <NEWLINE>
inputs = input ( ) . split ( ) <NEWLINE> a = int ( inputs [ 0 ] ) <NEWLINE> b = inputs [ 1 ] <NEWLINE> b = 100 * int ( b [ 0 ] ) + 10 * int ( b [ 1 ] ) + int ( b [ 2 ] ) <NEWLINE> <NL> print ( int ( a * b / 100 ) ) <NEWLINE>
import numpy as np <NEWLINE> A , B = map ( float , input ( ) . split ( ) ) <NEWLINE> print ( numpy . trunc ( A * B ) ) <NEWLINE>
num_strs = input ( ) . split ( ) <NEWLINE> <NL> a = int ( num_strs [ 0 ] ) <NEWLINE> b = int ( num_strs [ 1 ] * 100 ) <NEWLINE> <NL> print ( ( a * b ) // 100 ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( int ( a * b ) ) <NEWLINE>
import sys <NEWLINE> input = list ( map ( float , input ( ) . split ( ) ) ) <NEWLINE> <NL> A = int ( input [ 0 ] ) <NEWLINE> B = input [ 1 ] <NEWLINE> <NL> print ( int ( A * B ) ) / <NEWLINE>
/ * * >> >> > Anshit_Bhardwaj << << < * * / <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> using namespace std ; <NEWLINE> <NL> int main ( ) { <NEWLINE> <INDENT> ios : : sync_with_stdio ( 0 ) ; <NEWLINE> cin . tie ( 0 ) ; <NEWLINE> ll a , b ; <NEWLINE> double d ; <NEWLINE> cin >> a >> d ; <NEWLINE> b = d * 100 ; <NEWLINE> a *= b ; <NEWLINE> cout << a / 100 << endl ; <NEWLINE> <DEDENT> } <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> print ( int ( a * b ) ) <NEWLINE>
import math <NEWLINE> A , B = map ( int , input ( ) split ( ) ) <NEWLINE> print ( math . floor ( A * B ) ) <NEWLINE>
a , b = input ( ) . split ( ) <NEWLINE> a = int ( a ) <NEWLINE> b = int ( b . strip ( <STRING> ) ) <NEWLINE> print ( a * b // 100 ) <NEWLINE>
a , b = input ( ) . split ( ) <NEWLINE> A = int ( a ) <NEWLINE> b . replace ( <STRING> , <STRING> ) <NEWLINE> B = int ( b ) <NEWLINE> print ( A * B ) <NEWLINE>
a = float ( input ( ) ) <NEWLINE> b = float ( input ( ) ) <NEWLINE> print ( int ( a * ( b * 100 ) ) / 100 ) <NEWLINE>
import math <NEWLINE> a , b , c = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> print ( math . floor ( a * b + a * c / 100 ) ) <NEWLINE>
, B = list ( map ( float , input ( ) . split ( ) ) ) <NEWLINE> print ( int ( ( A * ( B * 1000 ) ) / 1000 ) ) <NEWLINE>
<COMMENT> <NL> from decimal import Decimal <NEWLINE> import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> A , B = ( str ( x ) for x in input ( ) . split ( ) ) <NEWLINE> a = Decimal ( A ) <NEWLINE> b = Decimal ( B ) <NEWLINE> ans = int ( A * B ) <NEWLINE> print ( ans ) <NEWLINE>
A , B = input ( ) . split ( ) <NEWLINE> B = Decimal ( B ) <NEWLINE> A = int ( A ) <NEWLINE> ans = int ( A * B ) <NEWLINE> <NL> print ( ans ) <NEWLINE>
import math <NEWLINE> a , b = map ( float , input ( ) . split ( ) ) <NEWLINE> A = int ( a ) <NEWLINE> print ( math . floor ( A * B ) ) <NEWLINE>
A , B = map ( float , input ( ) . split ( ) ) <NEWLINE> <NL> A = int ( a ) <NEWLINE> B = round ( 100 * B ) <NEWLINE> <NL> ans = int ( int ( A * B ) // 100 ) <NEWLINE> print ( ans ) <NEWLINE>
from math import floor <NEWLINE> from decimal import Decimal <NEWLINE> a , b = map ( Dicimal , input ( ) . split ( ) ) <NEWLINE> c = a * b <NEWLINE> print ( floor ( c ) ) <NEWLINE>
A , B = input ( ) . split ( ) <NEWLINE> <NL> A = int ( A ) <NEWLINE> B_float = int ( B [ 2 : ] ) <NEWLINE> B_int = int ( B [ 0 ] ) * 100 <NEWLINE> <NL> res = A * B // 100 <NEWLINE> <NL> print ( int ( res ) ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <NL> using namespace std ; <NEWLINE> int main ( ) { <NEWLINE> <INDENT> int ans ; <NEWLINE> float a , b ; <NEWLINE> cin >> a ; <NEWLINE> cin >> b ; <NEWLINE> ans = a * b ; <NEWLINE> cout << ans ; <NEWLINE> return 0 ; <NEWLINE> <DEDENT> } <NEWLINE>
a , b = map ( float , input ( ) . split ( ) ) <NEWLINE> a = int ( a ) <NEWLINE> b = str ( b ) <NEWLINE> b . replace ( <STRING> , <STRING> ) <NEWLINE> x = a * int ( b ) / 100 <NEWLINE> print ( x ) <NEWLINE>
from floor import math <NEWLINE> <NL> a , b = input ( ) . split ( ) <NEWLINE> a = int ( a ) <NEWLINE> b = round ( float ( b ) * 100 ) <NEWLINE> print ( a * b // 100 ) <NEWLINE>
import math <NEWLINE> <NL> a , b = map ( float ( input ( ) . split ( ) ) ) <NEWLINE> <NL> b = 100 * b <NEWLINE> <NL> print ( math . floor ( a * b / 100 ) ) <NEWLINE>
a , b = map ( input ( ) . split ( ) ) <NEWLINE> a = int ( a ) <NEWLINE> b = int ( float ( b ) * 100 ) <NEWLINE> a , b = int ( a ) , int ( b ) <NEWLINE> print ( int ( ( a * b ) // 100 ) ) <NEWLINE>
from decimal import * <NEWLINE> getcontext ( ) . prec = 2 <NEWLINE> <NL> N = list ( map ( str , input ( ) . split ( ) ) ) <NEWLINE> A = Decimal ( N [ 0 ] ) <NEWLINE> B = Decimal ( N [ 1 ] ) <NEWLINE> <NL> print ( math . floor ( A * B / 100 ) ) <NEWLINE>
<COMMENT> <NL> def input2 ( ) : <NEWLINE> <INDENT> return map ( float , input ( ) . split ( ) ) <NEWLINE> <NL> <NL> <DEDENT> a , b = input2 ( ) <NEWLINE> print ( math . floor ( a * b ) ) <NEWLINE>
if __name__ == <STRING> : <NEWLINE> <INDENT> a = [ float ( i ) for i in input ( ) . split ( ) ] <NEWLINE> b = int ( a [ 0 ] ) <NEWLINE> c = int ( a [ 1 ] * 100 ) <NEWLINE> d = Decimal ( a [ 0 ] ) * Decimal ( c ) / Decimal ( 100 ) <NEWLINE> e = int ( d ) <NEWLINE> print ( e ) <NEWLINE> <NL> <DEDENT>
<COMMENT> <NL> <NL> using namespace std ; <NEWLINE> <NL> typedef long long ll ; <NEWLINE> typedef vector < int > vi ; <NEWLINE> typedef vector < vi > vvi ; <NEWLINE> typedef vector < string > vs ; <NEWLINE> typedef pair < int , int > pii ; <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> //= == == == == == == == == == == == == <NEWLINE> <NL> typedef unsigned long long ull ; <NEWLINE> <NL> void run_test ( ) { <NEWLINE> <INDENT> ull a ; double _b ; <NEWLINE> cin >> a >> _b ; <NEWLINE> ull b = _b * 100 ; <NEWLINE> ull ans = a * b / 100 ; <NEWLINE> cout << ans << endl ; <NEWLINE> <DEDENT> } <NEWLINE> <NL> //= == == == == == == == == == == == == <NEWLINE> <NL> int main ( ) { <NEWLINE> <INDENT> ios : : sync_with_stdio ( 0 ) ; cin . tie ( 0 ) ; <NEWLINE> // int t = 1 , _t ; cin >> _t ; while ( t <= _t ) { cout << <STRING> << t + + << <STRING> ; run_test ( ) ; } <NEWLINE> // int t ; cin >> t ; while ( t - - ) run_test ( ) ; <NEWLINE> run_test ( ) ; <NEWLINE> return 0 ; <NEWLINE> <DEDENT> } <NEWLINE> <NL>
import math <NEWLINE> A , B = input ( ) . split ( ) <NEWLINE> print int ( A ) * int ( B . replace ( <STRING> , <STRING> ) ) // 100 <NEWLINE>
A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> a = int ( A ) <NEWLINE> b = B <NEWLINE> <NL> print ( int ( a * b ) ) <NEWLINE>
A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> B *= 100 <NEWLINE> print ( ( A * B ) // 100 ) <NEWLINE>
1000000000000000 9.99 <NEWLINE>
from decimal import * <NEWLINE> <NL> a , b = map ( decimal , input ( ) . split ( ) ) <NEWLINE> <NL> print ( a * b ) <NEWLINE>
import decimal <NEWLINE> import math <NEWLINE> a , b = map ( float , input ( ) . split ( ) ) <NEWLINE> a = Decimal ( <STRING> ) <NEWLINE> b = Decimal ( <STRING> ) <NEWLINE> print ( a * b ) <NEWLINE>
import math <NEWLINE> <NL> A , B = input ( ) . split ( ) <NEWLINE> A = int ( A ) <NEWLINE> B = math . floor ( B ) <NEWLINE> res = A * B <NEWLINE> print ( res ) <NEWLINE>
A , B = input ( ) . split ( ) <NEWLINE> <NL> <NL> <NL> print ( int ( A ) * int ( B * 100 ) // 100 ) <NEWLINE>
input math <NEWLINE> a , b = map ( float , input ( ) . split ( ) ) <NEWLINE> a *= b <NEWLINE> print ( math . floor ( a ) ) <NEWLINE>
a , b = input ( ) . split ( ) <NEWLINE> a = int ( input ( ) ) <NEWLINE> b = int ( float ( b ) * 100 + 0.5 ) <NEWLINE> ans = int ( a * b ) <NEWLINE> print ( ans ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( int ( a * b ) ) <NEWLINE>
import math <NEWLINE> A , B = list ( map ( str , input ( ) . split ( ) ) ) <NEWLINE> A = int ( A ) <NEWLINE> B . replace ( <STRING> , <STRING> ) <NEWLINE> C = int ( B ) <NEWLINE> D = A * C <NEWLINE> if D < 100 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> D = str ( D ) <NEWLINE> print ( D [ 0 : - 2 ] ) <NEWLINE>
from decimal import Decimal <NEWLINE> <NL> A , B = input ( ) . split ( ) <NEWLINE> <NL> A = int ( A ) <NEWLINE> B = Decimal ( B ) <NEWLINE> print ( int ( a * b ) ) <NEWLINE>
A , B = input ( ) . split ( ) <NEWLINE> A = int ( A // 100 ) <NEWLINE> B = int ( float ( B ) * 100 ) <NEWLINE> AB = A * B <NEWLINE> print ( AB ) <NEWLINE>
ab = input ( <STRING> ) <NEWLINE> a = int ( ab . split ( <STRING> ) [ 0 ] ) <NEWLINE> b = int ( ab . split ( <STRING> ) [ 1 ] ) <NEWLINE> import math <NEWLINE> result = math . floor ( a * b ) <NEWLINE> <NL> print ( result ) <NEWLINE>
def main ( ) : <NEWLINE> <NL> <INDENT> a , b = map ( str , input ( ) . split ( ) ) <NEWLINE> res = int ( a ) * ( ( int ( b ) + 0.001 ) * 100 ) // 100 <NEWLINE> print ( int ( res ) ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
a , b = input ( ) . split ( ) <NEWLINE> a = int ( a ) <NEWLINE> b = b [ 0 ] + b [ 2 : ] <NEWLINE> print ( a * b // 100 ) <NEWLINE>
A , B = input ( ) . split ( ) <NEWLINE> print ( ans = int ( A ) * round ( float ( B ) * 100 ) // 100 ) <NEWLINE>
from fractions import Fraction <NEWLINE> a , b = input ( ) . split ( ) <NEWLINE> A = float ( a ) <NEWLINE> B = Fraction ( b ) <NEWLINE> print ( floor ( A * B ) ) <NEWLINE> <NL>
import math <NEWLINE> A = int ( input ( ) ) <NEWLINE> B = float ( input ( ) ) <NEWLINE> print ( math . floor ( A * B ) ) <NEWLINE>
x , y = input ( ) . split ( ) <NEWLINE> <NL> x = int ( x ) <NEWLINE> y = float ( y ) <NEWLINE> <NL> print ( int ( x * y , <STRING> ) ) <NEWLINE>
A , B = input ( ) . split ( ) <NEWLINE> A = int ( A ) <NEWLINE> B = float ( B ) <NEWLINE> B = int ( B * 100 ) <NEWLINE> print ( a * b // 100 ) <NEWLINE>
A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( A * B ) <NEWLINE>
from decimal import Decimal <NEWLINE> a , b = list ( map ( decimal , input ( ) . split ( ) ) ) <NEWLINE> print ( int ( a * b ) ) <NEWLINE>
a , b = input ( ) <NEWLINE> a = int ( a ) <NEWLINE> b = float ( b ) <NEWLINE> c = int ( a * b ) <NEWLINE> print ( c ) <NEWLINE>
A , B = input ( ) . split ( ) <NEWLINE> A = int ( A ) <NEWLINE> B = replace ( <STRING> , <STRING> ) <NEWLINE> <NL> B = int ( B ) * 100 <NEWLINE> <NL> print ( A * B / 100 ) <NEWLINE>
from decimal import Decimal <NEWLINE> A , B = input ( ) . split ( ) <NEWLINE> b = Decimal ( B ) <NEWLINE> print ( int ( A * b ) ) <NEWLINE>
a , b = [ int ( s ) for s in input ( ) . split ( ) ] <NEWLINE> print ( int ( a * b ) ) <NEWLINE>
import decimal <NEWLINE> a , b = input ( ) . split ( ) <NEWLINE> a = decimal ( a ) <NEWLINE> b = decimal ( b ) <NEWLINE> print ( int ( a * b ) ) <NEWLINE>
a , b = map ( str , input ( ) . split ( ) ) <NEWLINE> temp = eval ( b ) * 100 <NEWLINE> print ( int ( a * temp ) ) <NEWLINE>
import sys <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> def main ( ) : <NEWLINE> <COMMENT> <NL> <NL> <INDENT> N , M = [ int ( s ) for s in input ( ) . split ( ) ] <NEWLINE> print ( int ( N * M ) ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> return 0 <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> sys . exit ( main ( ) ) <NEWLINE> <DEDENT>
import math <NEWLINE> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = math . floor ( a * b ) <NEWLINE> print ( ans ) <NEWLINE>
<NL> a , b = list ( input ( ) . split ( ) ) <NEWLINE> <NL> a = int ( a ) <NEWLINE> b = b . replace ( <STRING> , <STRING> ) <NEWLINE> b = int ( b ) <NEWLINE> print ( int ( a * b / 100 ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( a * b ) <NEWLINE>
from math import floor <NEWLINE> a , b = map ( float , input ( ) . split ( ) ) <NEWLINE> print ( math . floor ( a * b ) ) <NEWLINE>
import math <NEWLINE> <NL> a , b = ( int ( x ) for x in input ( ) . split ( ) ) <NEWLINE> print ( math . floor ( a * b ) ) <NEWLINE>
a , b = map ( int , input . split ( ) ) <NEWLINE> print ( int ( a * b ) ) <NEWLINE>
n , m = map ( double , input ( ) . split ( ) ) <NEWLINE> <NL> M = 10000 * m <NEWLINE> a = n * M <NEWLINE> ans = float ( a / 10000 ) <NEWLINE> print ( round ( ans ) ) <NEWLINE>
A , B = map ( str , input ( ) . split ( ) ) <NEWLINE> A = int ( A ) <NEWLINE> B . replace ( <STRING> , <STRING> ) <NEWLINE> B = int ( B ) <NEWLINE> ans = A * B // 100 <NEWLINE> print ( ans ) <NEWLINE>
from math import floor <NEWLINE> <NL> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> print ( floor ( A * B ) ) <NEWLINE>
import math <NEWLINE> a , b = input ( ) . split ( ) <NEWLINE> a = int ( a ) <NEWLINE> b = float ( ( int ( int ( b ) * 100 ) ) / 100 ) <NEWLINE> c = math . floor ( a * b ) <NEWLINE> print ( c ) <NEWLINE>
import decimal <NEWLINE> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> a = Decimal ( str ( a ) ) <NEWLINE> b = Decimal ( str ( b ) ) <NEWLINE> c = str ( a * b ) <NEWLINE> index = c . find ( <STRING> ) <NEWLINE> print ( c [ : index ] ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( int ( a * b ) ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> count = ( a * ( b ** 100 ) ) // 100 <NEWLINE> print ( count ) <NEWLINE>
A , B = map ( float , input ( ) . split ( ) ) <NEWLINE> X = math . floor ( A * B ) <NEWLINE> print ( X ) <NEWLINE>
a , b = input ( ) <NEWLINE> a = int ( a ) <NEWLINE> b = float ( b ) <NEWLINE> print ( int ( a * b ) ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( a * ( b * 100 ) // 100 ) <NEWLINE>
A , B = input ( ) . split ( ) <NEWLINE> print ( int ( A ) * float ( B ) * 100 ) // 100 ) <NEWLINE>
import numpy as np <NEWLINE> import math <NEWLINE> [ A , B ] = input ( ) . split ( ) <NEWLINE> c = 0 <NEWLINE> if <STRING> in B : <NEWLINE> <INDENT> c = int ( B . find ( <STRING> ) ) <NEWLINE> <DEDENT> c = len ( B ) - c - 1 <NEWLINE> B = B . replace ( <STRING> , <STRING> ) <NEWLINE> A = np . int64 ( A ) <NEWLINE> B = np . int64 ( B ) <NEWLINE> C = A * B <NEWLINE> if c == 0 or C <= 100 : <NEWLINE> <INDENT> print ( math . floor ( C / int ( 10 ** c ) ) ) <NEWLINE> <DEDENT> else c == 1 : <NEWLINE> <INDENT> print ( str ( C ) [ : - c ] ) <NEWLINE> <DEDENT>
import sys <NEWLINE> import math <NEWLINE> <NL> input = sys . stdin . readline <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> a , b = map ( double , input ( ) . split ( ) ) <NEWLINE> print ( math . floor ( a * b ) ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import math <NEWLINE> <NL> a = int ( input ( ) ) <NEWLINE> b = float ( input ( ) ) <NEWLINE> <NL> print ( math . floor ( a * b ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> if n == 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> flg = 0 <NEWLINE> for i in range ( 1000000 ) : <NEWLINE> <INDENT> if n < i : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if i == 0 or i == 1 or n % i != 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> j = i <NEWLINE> while ( n % j == 0 ) : <NEWLINE> <INDENT> if flg == 0 : <NEWLINE> <INDENT> flg = 1 <NEWLINE> <DEDENT> n /= j <NEWLINE> j *= i <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> if flg == 0 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( cnt ) <NEWLINE> <DEDENT> <DEDENT>
A , B = input ( ) . split ( ) <NEWLINE> A = int ( A ) <NEWLINE> C1 = A * int ( B [ 0 ] ) <NEWLINE> C2 = A * int ( B [ 2 ] ) * 0.1 <NEWLINE> C3 = A * int ( B [ 3 ] ) * 0.01 <NEWLINE> Ans = C1 + C2 + C3 <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> Ans = math . floor ( Ans ) <NEWLINE> print ( Ans ) <NEWLINE>
A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( int ( A * B ) ) <NEWLINE>
import math <NEWLINE> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( math . floor ( a * b ) ) <NEWLINE>
a , b = input ( ) . split ( ) <NEWLINE> a = int ( a ) <NEWLINE> b = int ( b . repalce ( <STRING> , <STRING> ) ) <NEWLINE> <NL> print ( int ( a * b ) // 100 ) <NEWLINE>
A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( int ( A * B ) ) <NEWLINE>
import math <NEWLINE> n = input ( ) . split ( ) <NEWLINE> a = int ( n [ 0 ] ) <NEWLINE> b = int ( n [ 1 ] ) * 100 <NEWLINE> <NL> ans = a * b <NEWLINE> <NL> print ( ans / 100 ) <NEWLINE>
a = input ( ) . split ( ) <NEWLINE> <NL> a = [ float ( p ) for p in a ] <NEWLINE> <NL> c = a * b * 100 <NEWLINE> print ( c // 100 ) <NEWLINE> <NL>
a , b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> print ( ( a * b ) // 1 ) <NEWLINE>
import decimal <NEWLINE> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> A = decimal ( A ) <NEWLINE> B = decimal ( B ) <NEWLINE> print ( int ( A * B ) ) <NEWLINE>
import math <NEWLINE> q = input ( ) . split ( <STRING> ) <NEWLINE> A = int ( q [ 0 ] ) <NEWLINE> B = q [ 1 ] . split ( <STRING> ) <NEWLINE> b0 = B [ 0 ] <NEWLINE> b1 = B [ 1 ] <NEWLINE> if b1 [ 0 ] == <STRING> : <NEWLINE> <INDENT> b1 = b1 [ 1 ] <NEWLINE> <NL> <NL> <DEDENT> print ( A * int ( b0 ) + math . floor ( ( ( A * int ( b1 ) ) / 100 ) <NEWLINE>
import math <NEWLINE> A , B = input ( ) . split ( ) <NEWLINE> B *= 100 <NEWLINE> print ( ( A * B ) / 100 ) ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( a * int ( b * 100 ) // 100 ) <NEWLINE>
def resolve ( ) : <NEWLINE> <INDENT> S = input ( ) . split ( <STRING> ) <NEWLINE> A = int ( S [ 0 ] ) <NEWLINE> B = float ( S [ 1 ] ) <NEWLINE> B = int ( B * 100 ) <NEWLINE> if A == 0 or B == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> return True <NEWLINE> <DEDENT> AB = np . asarray ( [ A , B ] , dtype = np . uint64 ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> print ( A * B // 100 ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> resolve ( ) <NEWLINE> <DEDENT>
import math <NEWLINE> A , B = input ( ) . split ( <STRING> ) <NEWLINE> A = int ( A . strip ( ) ) <NEWLINE> B = int ( B . strip ( ) . replace ( <STRING> , <STRING> ) ) <NEWLINE> print ( math . floor ( A * B / 100 ) <NEWLINE>
a , b = map ( float , input ( ) . split ( ) ) <NEWLINE> b = int ( float ( b ) * 100 ) <NEWLINE> a = int ( a ) <NEWLINE> print ( int ( a * tempb ) // 100 ) <NEWLINE>
a = int ( input ( ) ) <NEWLINE> b = float ( input ( ) ) <NEWLINE> b = b * 100 <NEWLINE> p = int ( ( a * b ) / 100 ) <NEWLINE> print ( p ) <NEWLINE> <NL>
a , b = map ( float , input ( ) . split ( ) ) <NEWLINE> a = int ( a ) <NEWLINE> b_int = int ( b ) <NEWLINE> b_frac = b * 100 - b * int * 100 <NEWLINE> <NL> ans = a * b_int + ( a * b_frac ) // 100 <NEWLINE> <NL> print ( ans ) <NEWLINE>
A , B = input ( ) . split ( ) <NEWLINE> A = int ( A ) <NEWLINE> B = float ( B ) <NEWLINE> B = <STRING> . format ( B ) <NEWLINE> <COMMENT> <NL> print ( int ( A * B ) ) <NEWLINE>
import math <NEWLINE> <NL> a = int ( input ( ) ) <NEWLINE> b = float ( input ( ) ) <NEWLINE> <NL> print ( math . floor ( a * b ) ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> l = input ( ) . split ( ) <NEWLINE> A , B = int ( l [ 0 ] ) , int ( l [ 1 ] ) <NEWLINE> print ( int ( ( A * ( B * 100 ) ) / 100 ) ) <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE>
import math <NEWLINE> import decimal <NEWLINE> <NL> r = list ( map ( float , input ( ) . split ( ) ) ) <NEWLINE> <NL> x = decimal . Decimal ( str ( r [ 1 ] ) ) . quantize ( Decimal ( <STRING> ) , rounding = ROUND_HALF_UP ) <NEWLINE> y = decimal . Decimal ( str ( r [ 1 ] ) ) . quantize ( Decimal ( <STRING> ) , rounding = ROUND_HALF_UP ) <NEWLINE> <NL> z = x * y <NEWLINE> <NL> z = math . floor ( z ) <NEWLINE> <NL> print ( z ) <NEWLINE>
<COMMENT> <NL> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> B = B * 100 <NEWLINE> <NL> ans = A * B <NEWLINE> ans = ans / 100 <NEWLINE> <NL> print ( ans ) <NEWLINE>
from decimal import Decimal <NEWLINE> <NL> <COMMENT> <NL> <NL> a = list ( map ( Decimal , t . split ( ) ) ) <NEWLINE> <NL> print ( int ( a [ 0 ] * a [ 1 ] ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> line = input ( ) . split ( <STRING> ) <NEWLINE> <NL> tot = 1 <NEWLINE> <NL> for a in line : <NEWLINE> <INDENT> if a == <STRING> : <NEWLINE> <INDENT> tot = 0 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if tot == 1 : <NEWLINE> <INDENT> for a in line : <NEWLINE> <INDENT> tot *= int ( a ) <NEWLINE> if tot > 10 ** 18 : <NEWLINE> <INDENT> tot = - 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( tot ) <NEWLINE>
def multply ( a : int , b : float ) -> int : <NEWLINE> <INDENT> return int ( a * b ) <NEWLINE> <NL> <DEDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( multply ( a , b ) ) <NEWLINE>
from functools import lru_cache <NEWLINE> <NL> <NL> def PrimeFactorization ( m ) : <NEWLINE> <INDENT> pf = { } <NEWLINE> i = 2 <NEWLINE> while i ** 2 < n : <NEWLINE> <INDENT> while n % i == 0 : <NEWLINE> <INDENT> pf [ i ] = pf . get ( i , 0 ) + 1 <NEWLINE> n //= i <NEWLINE> <DEDENT> i += 1 <NEWLINE> <DEDENT> if n > 1 : <NEWLINE> <INDENT> pf [ n ] = 1 <NEWLINE> <DEDENT> return pf <NEWLINE> <NL> <NL> <DEDENT> @ lru_cache ( maxsize = 100000 ) <NEWLINE> def f ( x ) : <NEWLINE> <INDENT> return int ( ( - 1 + ( 1 + 8 * x ) ** 0.5 ) // 2 + 0.001 ) <NEWLINE> <NL> <NL> <DEDENT> def resolve ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> d = PrimeFactorization ( n ) <NEWLINE> ans = 0 <NEWLINE> for v in d . values ( ) : <NEWLINE> <INDENT> ans += f ( v ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> resolve ( ) <NEWLINE> <DEDENT>
import math <NEWLINE> n = int ( input ( ) ) <NEWLINE> arr = [ ] <NEWLINE> temp = n <NEWLINE> for i in range ( 2 , int ( - ( - n ** 0.5 // 1 ) ) + 1 ) : <NEWLINE> <INDENT> if temp % i == 0 : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> while temp % i == 0 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> temp //= i <NEWLINE> <DEDENT> arr . append ( cnt ) <NEWLINE> <NL> <DEDENT> <DEDENT> if temp != 1 : <NEWLINE> <INDENT> arr . append ( 1 ) <NEWLINE> <DEDENT> if arr == [ ] : <NEWLINE> <INDENT> arr . append ( 1 ) <NEWLINE> <DEDENT> for i in range ( len ( arr ) ) : <NEWLINE> <INDENT> if arr [ i ] == 1 : <NEWLINE> <INDENT> arr [ i ] = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s = ( - 1 + math . sqrt ( 1 + 8 * arr [ i ] ) ) / 2 <NEWLINE> arr [ i ] = s <NEWLINE> <DEDENT> <DEDENT> if n = 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( int ( sum ( arr ) ) ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> pri_cnt = { } <NEWLINE> n = N <NEWLINE> i = 2 <NEWLINE> <NL> while i ** 2 <= N <NEWLINE> <INDENT> while n % i == 0 : <NEWLINE> <INDENT> if i not in div_cnt : <NEWLINE> <INDENT> pri_cnt [ i ] = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> pri_cnt [ i ] += 1 <NEWLINE> <NL> <DEDENT> n = n / i <NEWLINE> <NL> <DEDENT> <DEDENT> if n > 1 : <NEWLINE> <INDENT> pri_cnt [ N ] = 1 <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for pri , cnt in pri_knt : <NEWLINE> <INDENT> count = 1 <NEWLINE> remain = cnt <NEWLINE> while remain > count : <NEWLINE> <INDENT> ans += 1 <NEWLINE> remain -= count <NEWLINE> count += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> check = [ True for _ in range ( 10 ** 6 ) ] <NEWLINE> <NL> for p in range ( 2 , 10 ** 6 ) : <NEWLINE> <INDENT> if check [ p ] == True : <NEWLINE> <INDENT> for j in range ( 2 , ( 10 ** 6 ) // p + 1 ) : <NEWLINE> <INDENT> check [ p * j ] = False <NEWLINE> <NL> <DEDENT> e = 1 <NEWLINE> while N % ( p ** e ) == 0 : <NEWLINE> <INDENT> N = N // ( p ** e ) <NEWLINE> e += 1 <NEWLINE> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if ans == 0 : <NEWLINE> <INDENT> if N == 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
import collections <NEWLINE> import math <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> B = [ 1 , 2 , 6 , 10 , 15 , 21 , 28 , 36 , 45 , 55 ] <NEWLINE> ans = 0 <NEWLINE> <NL> def is_prime ( n ) : <NEWLINE> <INDENT> if n == 1 : return False <NEWLINE> <NL> for k in range ( 2 , int ( math . sqrt ( n ) ) + 1 ) : <NEWLINE> <INDENT> if n % k == 0 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> <DEDENT> return True <NEWLINE> <DEDENT> if is_prime ( n ) == True : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> def prime_factorize ( n ) : <NEWLINE> <INDENT> a = [ ] <NEWLINE> while n % 2 == 0 : <NEWLINE> <INDENT> a . append ( 2 ) <NEWLINE> n //= 2 <NEWLINE> <DEDENT> f = 3 <NEWLINE> while f * f <= n : <NEWLINE> <INDENT> if n % f == 0 : <NEWLINE> <INDENT> a . append ( f ) <NEWLINE> n //= f <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> f += 2 <NEWLINE> <DEDENT> <DEDENT> if n != 1 : <NEWLINE> <INDENT> a . append ( n ) <NEWLINE> <DEDENT> return a <NEWLINE> <DEDENT> c = collections . Counter ( prime_factorize ( 840 ) ) <NEWLINE> C = c . values ( ) <NEWLINE> for i in range ( len ( C ) ) : <NEWLINE> <INDENT> for j in range ( len ( B ) ) : <NEWLINE> <INDENT> if C [ i ] < B [ j ] : <NEWLINE> <INDENT> ans += j + 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> d = { } <NEWLINE> for k in range ( 2 , 10 ** 6 ) : <NEWLINE> <INDENT> while n % k < 1 : n // k ; d [ k ] = d . get ( k , 0 ) + 1 <NEWLINE> <DEDENT> a = 0 <NEWLINE> for i in d . values ( ) : <NEWLINE> <INDENT> t = c = 0 <NEWLINE> while t + c < i : c += 1 ; t += c <NEWLINE> a += c <NEWLINE> <DEDENT> print ( a + ( n > 1 ) ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> on = n <NEWLINE> def is_prime ( n ) : <NEWLINE> <INDENT> for i in range ( 2 , n + 1 ) : <NEWLINE> <INDENT> if i * i > n : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if n % i == 0 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> <DEDENT> return n != 1 <NEWLINE> <DEDENT> if is_prime ( n ) : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> nn = ceil ( n ** 0.5 ) <NEWLINE> nn = max ( 6 , nn ) <NEWLINE> p = [ False if i % 2 == 0 or i % 3 == 0 or i % 5 == 0 else True for i in range ( nn + 1 ) ] <NEWLINE> p [ 0 ] = p [ 1 ] = False <NEWLINE> p [ 2 ] = p [ 3 ] = p [ 5 ] = True <NEWLINE> for i1 in range ( 3 , floor ( nn ** 0.5 ) + 1 , 2 ) : <NEWLINE> <INDENT> if p [ i1 ] : <NEWLINE> <INDENT> for i2 in range ( i1 ** 2 , nn + 1 , i1 ) : <NEWLINE> <INDENT> p [ i2 ] = False <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> <DEDENT> pl = [ i for i , b in enumerate ( p ) if b == True ] <NEWLINE> <NL> nums = deepcopy ( pl ) <NEWLINE> for pe in pl : <NEWLINE> <INDENT> cnt = 2 <NEWLINE> while True : <NEWLINE> <INDENT> tnum = pow ( pe , cnt ) <NEWLINE> if tnum > n : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> elif tnum != 0 : <NEWLINE> <INDENT> if n % tnum == 0 : <NEWLINE> <INDENT> nums . append ( tnum ) <NEWLINE> <DEDENT> <DEDENT> cnt += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> nums . sort ( ) <NEWLINE> numsd = deque ( nums ) <NEWLINE> ok = set ( ) <NEWLINE> r = 0 <NEWLINE> while True : <NEWLINE> <INDENT> if not numsd : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if n == 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> nextn = numsd . popleft ( ) <NEWLINE> if nextn > on or nextn > n : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> elif n % nextn == 0 : <NEWLINE> <INDENT> if nextn in ok : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> n = int ( n // nextn ) <NEWLINE> ok . add ( nextn ) <NEWLINE> r += 1 <NEWLINE> <DEDENT> <DEDENT> if n == 1 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> print ( r ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
def divisor ( n ) : <NEWLINE> <INDENT> i = 1 <NEWLINE> table = [ ] <NEWLINE> while i * i <= n : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> table . append ( i ) <NEWLINE> table . append ( n // i ) <NEWLINE> <DEDENT> i += 1 <NEWLINE> <DEDENT> table = list ( set ( table ) ) <NEWLINE> return table <NEWLINE> <DEDENT> def prime_decomposition ( n ) : <NEWLINE> <INDENT> i = 2 <NEWLINE> table = [ ] <NEWLINE> while i * i <= n : <NEWLINE> <INDENT> while n % i == 0 : <NEWLINE> <INDENT> n //= i <NEWLINE> table . append ( i ) <NEWLINE> <DEDENT> i += 1 <NEWLINE> <DEDENT> if n > 1 : <NEWLINE> <INDENT> table . append ( n ) <NEWLINE> <DEDENT> return table <NEWLINE> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> a = divisors ( n ) <NEWLINE> cnt = 0 <NEWLINE> for i in range ( 1 , len ( a ) ) : <NEWLINE> <INDENT> b = prime_decomposition ( a [ i ] ) <NEWLINE> if len ( list ( set ( b ) ) ) == 1 : <NEWLINE> <INDENT> if n % a [ i ] == 0 : <NEWLINE> <INDENT> n //= a [ i ] <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
def func ( N ) : <NEWLINE> <INDENT> tmp = N <NEWLINE> arr = [ ] <NEWLINE> for i in range ( 2 , ( N ** 0.5 // 1 + 1 ) ) : <NEWLINE> <INDENT> if tmp % i == 0 : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> while tmp % i == 0 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> tmp //= i <NEWLINE> <DEDENT> arr . append ( [ i , cnt ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> if tmp != 1 : <NEWLINE> <INDENT> arr . append ( [ tmp , 1 ] ) <NEWLINE> <DEDENT> if arr == [ ] : <NEWLINE> <INDENT> arr . append ( [ tmp , 1 ] ) <NEWLINE> <NL> <DEDENT> return arr <NEWLINE> <NL> <DEDENT> N = int ( input ( ) ) <NEWLINE> a = func ( N ) <NEWLINE> ans = 0 <NEWLINE> if a [ 0 ] [ 0 ] == 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> b = [ 1 , 3 , 6 , 10 , 15 , 21 , 28 , 36 , 45 ] <NEWLINE> for i in a : <NEWLINE> <INDENT> for j in range ( len ( b ) ) : <NEWLINE> <INDENT> if i [ 1 ] < b [ j ] : <NEWLINE> <INDENT> ans += j <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL>
N = int ( input ( ) ) <NEWLINE> n , p , score = N , 2 , 0 <NEWLINE> while p ** 2 <= N : <NEWLINE> <INDENT> e = 1 <NEWLINE> print ( n , p , e ) <NEWLINE> while n >= ( p ** e ) <NEWLINE> <DEDENT> and n % ( p ** e ) == 0 : <NEWLINE> <INDENT> n = n // ( p ** e ) <NEWLINE> score += 1 <NEWLINE> e += 1 <NEWLINE> else : <NEWLINE> p = p + 1 if p == 2 else p + 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if n != 1 : <NEWLINE> <INDENT> score += 1 <NEWLINE> <DEDENT> <DEDENT> print ( score ) <NEWLINE>
import math <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> list = { } <NEWLINE> while n > 1 : <NEWLINE> <INDENT> for i in range ( math . sqrt ( n ) ) : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> if i in list : <NEWLINE> <INDENT> list [ i ] = list [ i ] + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> list [ i ] = 1 <NEWLINE> <DEDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if n % i == 0 : <NEWLINE> <INDENT> if i in list : <NEWLINE> <INDENT> list [ i ] = list [ i ] + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> list [ i ] = 1 <NEWLINE> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for i in list . keys ( ) : <NEWLINE> <INDENT> m = list [ i ] <NEWLINE> for j in range ( m ) : <NEWLINE> <INDENT> if not j > m : <NEWLINE> <INDENT> ans += j <NEWLINE> m -= j <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> from sys import exit <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> primes = { } <NEWLINE> i = 2 <NEWLINE> ans = 0 <NEWLINE> square = math . floor ( math . sqrt ( n ) ) <NEWLINE> <NL> if n == 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> while True : <NEWLINE> <INDENT> if i > square : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if n % i == 0 : <NEWLINE> <INDENT> if i not in primes . keys ( ) : <NEWLINE> <INDENT> primes [ i ] = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> primes [ i ] += 1 <NEWLINE> <DEDENT> n = n // i <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if i == 2 : <NEWLINE> <INDENT> i += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> i += 2 <NEWLINE> <DEDENT> continue <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> if len ( primes ) == 0 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> for k , v in primes : <NEWLINE> <INDENT> base = v * 2 <NEWLINE> root = math . floor ( math . sqrt ( base ) ) <NEWLINE> if root * ( root + 1 ) > base : <NEWLINE> <INDENT> root -= 1 <NEWLINE> <DEDENT> ans += root <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> <NL> def isPrime ( num ) : <NEWLINE> <INDENT> if num < 2 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> elif num == 2 : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> elif num % 2 == 0 : <NEWLINE> <INDENT> return False <NEWLINE> <NL> <DEDENT> for i in range ( 3 , math . floor ( math . sqrt ( num ) ) + 1 , 2 ) : <NEWLINE> <INDENT> if num % i == 0 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> <DEDENT> return True <NEWLINE> <NL> <NL> <DEDENT> def find_all_prime ( num ) : <NEWLINE> <INDENT> prime_list = [ 2 ] <NEWLINE> for i in range ( 3 , num , 2 ) : <NEWLINE> <INDENT> if isPrime ( i ) : <NEWLINE> <INDENT> prime_list . append ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> return prime_list <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> if isPrime ( N ) : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> prime_list = find_all_prime ( int ( 1.25 * 10 ** 6 ) ) <NEWLINE> count = 0 <NEWLINE> for i in prime_list : <NEWLINE> <INDENT> j = 1 <NEWLINE> while N > 1 : <NEWLINE> <INDENT> if N // i ** j == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if N % i ** j == 0 : <NEWLINE> <INDENT> N = N // i ** j <NEWLINE> count += 1 <NEWLINE> <DEDENT> j += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( count ) <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> def input ( ) : return sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> class UnionFind ( ) : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . n = n <NEWLINE> self . parents = [ - 1 ] * n <COMMENT> <NEWLINE> <DEDENT> def find ( self , x ) : <NEWLINE> <COMMENT> <NL> <INDENT> if self . parents [ x ] < 0 : return x <NEWLINE> else : <NEWLINE> <INDENT> self . parents [ x ] = self . find ( self . parents [ x ] ) <NEWLINE> return self . parents [ x ] <NEWLINE> <DEDENT> <DEDENT> def unite ( self , x , y ) : <NEWLINE> <COMMENT> <NL> <INDENT> x , y = self . find ( x ) , self . find ( y ) <NEWLINE> if x == y : return <NEWLINE> if self . parents [ x ] > self . parents [ y ] : <COMMENT> <NEWLINE> <INDENT> x , y = y , x <NEWLINE> <DEDENT> self . parents [ x ] += self . parents [ y ] <NEWLINE> self . parents [ y ] = x <COMMENT> <NEWLINE> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <INDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> uf = UnionFind ( n ) <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> a -= 1 <NEWLINE> b -= 1 <NEWLINE> uf . unite ( a , b ) <NEWLINE> <DEDENT> uf_lis = uf . parents <NEWLINE> ans = 0 <NEWLINE> for p in uf_lis : <NEWLINE> <INDENT> if p < 0 : <NEWLINE> <INDENT> ans = max ( ans , - p ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import math <NEWLINE> <NL> a , b = map ( float , input ( ) . split ( ) ) <NEWLINE> ans = math . floor ( a * b ) <NEWLINE> print ( ans ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> <NL> e = 1 <NEWLINE> for fac in ( 2 , * ( x * 2 + 3 for x in range ( pow ( 10 , 12 ) ) ) ) : <NEWLINE> <INDENT> while n % ( div : = pow ( fac , e ) ) == 0 : <NEWLINE> <INDENT> n //= div <NEWLINE> ans += 1 <NEWLINE> e += 1 <NEWLINE> <NL> <DEDENT> while n % fac == 0 : <NEWLINE> <INDENT> n //= fac <NEWLINE> <NL> <DEDENT> if fac * fac > n : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> e = 1 <NEWLINE> <NL> <DEDENT> if n != 1 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> N = n <NEWLINE> ans = 0 <NEWLINE> d = 0 <NEWLINE> i = 2 <NEWLINE> while n > 1 and i * i <= N : <NEWLINE> <INDENT> c = 0 <NEWLINE> if n % i == 0 : <NEWLINE> <INDENT> d == 1 <NEWLINE> while n % i == 0 : <NEWLINE> <INDENT> n = int ( n / i ) <NEWLINE> c += 1 <NEWLINE> <NL> <DEDENT> while c >= Y : <NEWLINE> <INDENT> ans = ans + 1 <NEWLINE> Y = Y + U <NEWLINE> U = U + 1 <NEWLINE> <NL> <DEDENT> <DEDENT> i += 1 <NEWLINE> <NL> <NL> <DEDENT> if n > 1 : <NEWLINE> <INDENT> ans = 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
def factorization ( n ) : <NEWLINE> <INDENT> arr = [ ] <NEWLINE> temp = n <NEWLINE> for i in range ( 2 , int ( - ( - n ** 0.5 // 1 ) ) + 1 ) : <NEWLINE> <INDENT> if temp % i == 0 : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> while temp % i == 0 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> temp //= i <NEWLINE> <DEDENT> arr . append ( [ i , cnt ] ) <NEWLINE> <DEDENT> <DEDENT> if temp != 1 : <NEWLINE> <INDENT> arr . append ( [ temp , 1 ] ) <NEWLINE> <DEDENT> if arr == [ ] : <NEWLINE> <INDENT> arr . append ( [ n , 1 ] ) <NEWLINE> <DEDENT> return arr <NEWLINE> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> x = factorization ( n ) <NEWLINE> if n = 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in range ( len ( x ) ) : <NEWLINE> <INDENT> p = x [ i ] [ 1 ] <NEWLINE> j = 1 <NEWLINE> while True : <NEWLINE> <INDENT> if p >= j : <NEWLINE> <INDENT> p -= j <NEWLINE> ans += 1 <NEWLINE> j += 1 <NEWLINE> <DEDENT> if p < j : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <NL>
from collections import deque <NEWLINE> def main ( ) : <NEWLINE> <INDENT> N , M , * AB = map ( int , open ( 0 ) . read ( ) . split ( ) ) <NEWLINE> g = [ [ ] for _ in range ( N + 1 ) ] <NEWLINE> for a , b in zip ( * [ iter ( AB ) ] * 2 ) : <NEWLINE> <INDENT> g [ a ] . append ( b ) <NEWLINE> g [ b ] . append ( a ) <NEWLINE> <DEDENT> q = deque ( [ 1 ] ) <NEWLINE> s = [ 0 ] * ( N + 1 ) <NEWLINE> s [ 1 ] = 1 <NEWLINE> while q : <NEWLINE> <INDENT> u = q . popleft ( ) <NEWLINE> for v in g [ u ] : <NEWLINE> <INDENT> if not s [ v ] : <NEWLINE> <INDENT> s [ v ] = u <NEWLINE> q . append ( v ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> print ( <STRING> . join ( map ( str , s [ 2 : ] ) ) ) <NEWLINE> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
def sieve ( n ) : <NEWLINE> <INDENT> is_prime = [ True for _ in range ( n + 1 ) ] <NEWLINE> is_prime [ 0 ] = False <NEWLINE> <NL> for i in range ( 2 , n + 1 ) : <NEWLINE> <INDENT> if is_prime [ i - 1 ] : <NEWLINE> <INDENT> j = 2 * i <NEWLINE> while j <= n : <NEWLINE> <INDENT> is_prime [ j - 1 ] = False <NEWLINE> j += i <NEWLINE> <DEDENT> <DEDENT> <DEDENT> table = [ i for i in range ( 1 , n + 1 ) if is_prime [ i - 1 ] ] <NEWLINE> return table <NEWLINE> <COMMENT> <NL> <DEDENT> def is_prime ( n ) : <NEWLINE> <INDENT> for i in range ( 2 , n + 1 ) : <NEWLINE> <INDENT> if i * i > n : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if n % i == 0 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> <DEDENT> return n != 1 <NEWLINE> <NL> <DEDENT> N = int ( input ( ) ) <NEWLINE> p_list = sieve ( 10000000 ) <NEWLINE> cnt = 0 <NEWLINE> for i in range ( 100000 ) : <NEWLINE> <INDENT> for j in range ( 1 , 100 ) : <NEWLINE> <INDENT> q , mod = divmod ( N , ( p_list [ i ] ** j ) ) <NEWLINE> if mod == 0 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> N = q <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> if N > 104743 : <NEWLINE> <INDENT> a = is_prime ( N ) <NEWLINE> if a == True : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> import bisect <NEWLINE> <NL> line = [ i * ( i + 1 ) // 2 for i in range ( 10 ** 7 + 1 ) ] <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> <NL> if N == 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> do = [ 0 for i in range ( 10 ** 6 + 1 ) ] <NEWLINE> <NL> for i in range ( 2 , int ( N ** 0.5 ) + 1 ) : <NEWLINE> <INDENT> while N % i == 0 : <NEWLINE> <INDENT> N /= i <NEWLINE> do [ i ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> ans = 0 <NEWLINE> judge = True <NEWLINE> <NL> for _ , item in enumerate ( do ) : <NEWLINE> <INDENT> index = ( bisect . bisect_right ( line , item ) ) - 1 <NEWLINE> ans += index <NEWLINE> if index != 0 : <NEWLINE> <INDENT> judge = False <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans + 1 if judge else ans ) <NEWLINE> <NL> <NL>
N = int ( input ( ) ) <NEWLINE> <NL> def factorizatio ( n ) : <NEWLINE> <INDENT> arr = [ ] <NEWLINE> temp = n <NEWLINE> for i in range ( 2 , int ( - ( - n ** 0.5 // 1 ) ) + 1 ) : <NEWLINE> <INDENT> if temp % i == 0 : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> while temp % i == 0 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> temp //= i <NEWLINE> <DEDENT> arr . append ( [ i , cnt ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> if temp != 1 : <NEWLINE> <INDENT> arr . append ( [ temp , 1 ] ) <NEWLINE> <NL> <DEDENT> if arr == [ ] : <NEWLINE> <INDENT> arr . append ( [ n , 1 ] ) <NEWLINE> <NL> <DEDENT> return arr <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in factorizatio ( N ) : <NEWLINE> <INDENT> cnt = i [ 1 ] <NEWLINE> a = 0 <NEWLINE> for j in range ( 1 , cnt + 1 ) : <NEWLINE> <INDENT> a += j <NEWLINE> if a > cnt : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> b += 1 <NEWLINE> <DEDENT> ans += b <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> import collections <NEWLINE> <COMMENT> <NL> def factorize ( target_number ) : <NEWLINE> <INDENT> factor_list = [ ] <NEWLINE> while target_number % 2 == 0 : <NEWLINE> <INDENT> factor_list . append ( 2 ) <NEWLINE> n //= 2 <NEWLINE> <DEDENT> factor = 3 <NEWLINE> while factor * factor <= target_number : <NEWLINE> <INDENT> while target_number % factor == 0 : <NEWLINE> <INDENT> target_number //= factor <NEWLINE> factor_list . append ( factor ) <NEWLINE> <DEDENT> factor += 2 <NEWLINE> <DEDENT> if target_number > 1 : <NEWLINE> <INDENT> factor_list . append ( target_number ) <NEWLINE> <DEDENT> return factor_list <NEWLINE> <NL> <DEDENT> N = int ( input ( ) ) <NEWLINE> <NL> fact_list = factorize ( N ) <NEWLINE> <NL> fact_counter_dict = collections . Counter ( fact_list ) <NEWLINE> ans = 0 <NEWLINE> for fact , freq in fact_counter_dict . items ( ) : <NEWLINE> <INDENT> freq_copy = freq <NEWLINE> for i in range ( 1 , freq + 1 ) : <NEWLINE> <INDENT> freq_copy -= i <NEWLINE> if freq_copy < 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
def factorization ( n ) : <NEWLINE> <INDENT> arr = [ ] <NEWLINE> temp = n <NEWLINE> for i in range ( 2 , int ( - ( - n ** 0.5 // 1 ) ) + 1 ) : <NEWLINE> <INDENT> if temp % i == 0 : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> while temp % i == 0 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> temp //= i <NEWLINE> <DEDENT> arr . append ( [ i , cnt ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> if temp != 1 : <NEWLINE> <INDENT> arr . append ( [ temp , 1 ] ) <NEWLINE> <NL> <DEDENT> if arr == [ ] : <NEWLINE> <INDENT> arr . append ( [ n , 1 ] ) <NEWLINE> <NL> <DEDENT> return arr <NEWLINE> <NL> <NL> <DEDENT> def calcN ( num ) : <NEWLINE> <INDENT> if num >= 45 : <NEWLINE> <INDENT> return 9 <NEWLINE> <DEDENT> elif num >= 36 : <NEWLINE> <INDENT> return 8 <NEWLINE> <DEDENT> elif num >= 28 : <NEWLINE> <INDENT> return 7 <NEWLINE> <DEDENT> elif num >= 21 : <NEWLINE> <INDENT> return 6 <NEWLINE> <DEDENT> elif num >= 15 : <NEWLINE> <INDENT> return 5 <NEWLINE> <DEDENT> elif num >= 10 : <NEWLINE> <INDENT> return 4 <NEWLINE> <DEDENT> elif num >= 6 : <NEWLINE> <INDENT> return 3 <NEWLINE> <DEDENT> elif num >= 3 : <NEWLINE> <INDENT> return 2 <NEWLINE> <DEDENT> elif num >= 1 : <NEWLINE> <INDENT> return 1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> A = int ( input ( ) . split ( ) ) <NEWLINE> insuu = factorization ( A ) <NEWLINE> ret = 0 <NEWLINE> for i in insuu : <NEWLINE> <INDENT> ret += calcN ( i [ 1 ] ) <NEWLINE> <DEDENT> print ( ret ) <NEWLINE>
def func ( N ) : <NEWLINE> <INDENT> tmp = N <NEWLINE> arr = [ ] <NEWLINE> for i in range ( 2 , int ( - ( - N ** 0.5 // 1 ) ) + 1 ) : <NEWLINE> <INDENT> if tmp % i == 0 : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> while tmp % i == 0 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> tmp //= i <NEWLINE> <DEDENT> arr . append ( [ i , cnt ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> if temp != 1 : <NEWLINE> <INDENT> arr . append ( [ tmp , 1 ] ) <NEWLINE> <DEDENT> if arr == [ ] : <NEWLINE> <INDENT> arr . append ( [ n , 1 ] ) <NEWLINE> <NL> <DEDENT> return arr <NEWLINE> <NL> <DEDENT> N = int ( input ( ) ) <NEWLINE> a = func ( N ) <NEWLINE> ans = 0 <NEWLINE> if a [ 0 ] [ 0 ] == 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> b = [ 1 , 3 , 6 , 10 , 15 , 21 , 28 , 36 , 45 ] <NEWLINE> for i in a : <NEWLINE> <INDENT> for j in range ( len ( b ) ) : <NEWLINE> <INDENT> if i [ 1 ] < b [ j ] : <NEWLINE> <INDENT> ans += j <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL>
n = int ( input ( ) ) <NEWLINE> if n == 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> answer = 0 <NEWLINE> for factor in factorization ( n ) : <NEWLINE> <INDENT> x = factor [ 1 ] <NEWLINE> kouho = int ( ( 2 * x ) ** 0.5 ) - 1 <NEWLINE> if ( kouho ) * ( kouho + 1 ) / 2 <= x and x < ( kouho + 1 ) * ( kouho + 2 ) / 2 : <NEWLINE> <INDENT> kaisu = kouho <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> kaisu = kouho + 1 <NEWLINE> <DEDENT> answer += kaisu <NEWLINE> <NL> <DEDENT> print ( answer ) <NEWLINE> <DEDENT>
import math <NEWLINE> import decimal <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <NL> <INDENT> N = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> A = int ( math . ceil ( N ** 0.5 ) + 1 ) <NEWLINE> explist = [ ] <NEWLINE> flag = False <NEWLINE> if N >= 3 : <NEWLINE> <INDENT> for L in range ( 2 , A ) : <NEWLINE> <INDENT> if N < L : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> d = L <NEWLINE> cnt = 0 <NEWLINE> while ( True ) : <NEWLINE> <INDENT> if N % d == 0 : <NEWLINE> <INDENT> N /= d <NEWLINE> cnt += 1 <NEWLINE> flag = True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> explist . append ( [ d , cnt ] ) <NEWLINE> <DEDENT> for i in explist : <NEWLINE> <INDENT> c = i [ 1 ] <NEWLINE> for j in range ( 1 , A ) : <NEWLINE> <INDENT> if c >= j : <NEWLINE> <INDENT> ans += 1 <NEWLINE> c -= j <NEWLINE> print ( c [ 0 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if flag : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> return <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> return <NEWLINE> <DEDENT> <DEDENT> elif N == 2 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> return <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> return <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
def append_factor ( f , p ) : <NEWLINE> <INDENT> if p not in f : <NEWLINE> <INDENT> f [ p ] = 0 <NEWLINE> <DEDENT> f [ p ] += 1 <NEWLINE> <NL> <DEDENT> def factors ( n ) : <NEWLINE> <INDENT> l = int ( math . sqrt ( n ) ) + 1 <NEWLINE> ret = { } <NEWLINE> while n % 2 == 0 : <NEWLINE> <INDENT> append_factor ( ret , 2 ) <NEWLINE> n //= 2 <NEWLINE> <DEDENT> while n % 3 == 0 : <NEWLINE> <INDENT> append_factor ( ret , 3 ) <NEWLINE> n //= 3 <NEWLINE> <DEDENT> i = 6 <NEWLINE> while i * i <= n : <NEWLINE> <INDENT> while n % ( i - 1 ) == 0 : <NEWLINE> <INDENT> append_factor ( ret , i - 1 ) <NEWLINE> n //= ( i - 1 ) <NEWLINE> <DEDENT> while n % ( i + 1 ) == 0 : <NEWLINE> <INDENT> append_factor ( ret , i + 1 ) <NEWLINE> n //= ( i + 1 ) <NEWLINE> <DEDENT> i += 6 <NEWLINE> <DEDENT> if n != 1 : <NEWLINE> <INDENT> append_factor ( ret , n ) <NEWLINE> <NL> <DEDENT> return ret <NEWLINE> <NL> <DEDENT> def minimum_sum ( x ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> <INDENT> n = int ( math . sqrt ( x ) ) <NEWLINE> while ( n + 1 ) * ( n + 2 ) <= 2 * x : <NEWLINE> <INDENT> n += 1 <NEWLINE> <NL> <DEDENT> return n <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> fs = factors ( N ) <NEWLINE> <COMMENT> <NL> ans = 0 <NEWLINE> for f in fs : <NEWLINE> <INDENT> ans += minimum_sum ( fs [ f ] ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> import math <NEWLINE> from decimal import * <NEWLINE> <COMMENT> <NL> <NL> def getVar ( ) : <NEWLINE> <INDENT> return map ( int , input ( ) . split ( ) ) <NEWLINE> <DEDENT> def getArray ( ) : <NEWLINE> <INDENT> return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <DEDENT> def getNumpy ( ) : <NEWLINE> <INDENT> return np . array ( list ( map ( int , input ( ) . split ( ) ) ) , dtype = <STRING> ) <NEWLINE> <NL> <DEDENT> def factorization ( n ) : <NEWLINE> <INDENT> d = { } <NEWLINE> temp = n <NEWLINE> for i in range ( 2 , int ( - ( - n ** 0.5 // 1 ) ) + 1 ) : <NEWLINE> <INDENT> if temp % i == 0 : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> while temp % i == 0 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> temp //= i <NEWLINE> <DEDENT> d . append ( { i , cnt } ) <NEWLINE> <NL> <DEDENT> <DEDENT> if temp != 1 : <NEWLINE> <INDENT> d . append ( { temp , 1 } ) <NEWLINE> <NL> <DEDENT> if d == [ ] : <NEWLINE> <INDENT> d . append ( { n , 1 } ) <NEWLINE> <NL> <DEDENT> return d <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> d = factorization ( N ) <NEWLINE> count = 0 <NEWLINE> <NL> for v in d . values ( ) : <NEWLINE> <INDENT> i = 1 <NEWLINE> while ( v >= i ) : <NEWLINE> <INDENT> v -= i <NEWLINE> i += 1 <NEWLINE> count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( count ) <NEWLINE> <NL> <NL> <DEDENT> main ( ) <NEWLINE>
import math <NEWLINE> <NL> <NL> def make_divisors ( n ) : <NEWLINE> <INDENT> lower_divisors , upper_divisors = [ ] , [ ] <NEWLINE> i = 1 <NEWLINE> while i * i <= n : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> lower_divisors . append ( i ) <NEWLINE> if i != n // i : <NEWLINE> <INDENT> upper_divisors . append ( n // i ) <NEWLINE> <DEDENT> <DEDENT> i += 1 <NEWLINE> <DEDENT> return lower_divisors + upper_divisors [ : : - 1 ] <NEWLINE> <NL> <NL> <DEDENT> def using_sqrt ( limit ) : <NEWLINE> <INDENT> n = [ ] <NEWLINE> for k in range ( 2 , limit + 1 ) : <NEWLINE> <INDENT> factor = 0 <NEWLINE> <NL> <COMMENT> <NL> if k % 2 == 0 and k != 2 : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> for divisor in range ( 2 , math . floor ( math . sqrt ( k ) ) + 1 ) : <NEWLINE> <INDENT> if k % divisor == 0 : <NEWLINE> <INDENT> factor += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if factor == 0 : <NEWLINE> <INDENT> n . append ( k ) <NEWLINE> <NL> <DEDENT> <DEDENT> return n <NEWLINE> <NL> <NL> <DEDENT> def isPrime ( limit ) : <NEWLINE> <INDENT> for k in range ( limit , limit + 1 ) : <NEWLINE> <INDENT> factor = 0 <NEWLINE> <NL> <COMMENT> <NL> if k % 2 == 0 and k != 2 : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> for divisor in range ( 2 , math . floor ( math . sqrt ( k ) ) + 1 ) : <NEWLINE> <INDENT> if k % divisor == 0 : <NEWLINE> <INDENT> factor += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if factor == 0 : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> <DEDENT> return False <NEWLINE> <NL> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> prime = using_sqrt ( 50 ** 5 ) <NEWLINE> prev = [ ] <NEWLINE> <NL> if n > 1 and isPrime ( n ) : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <NL> <DEDENT> def check ( n , prev ) : <NEWLINE> <INDENT> divs = make_divisors ( int ( n ) ) <NEWLINE> flag = False <NEWLINE> for i in divs [ 1 : ] : <NEWLINE> <INDENT> for p in prime : <NEWLINE> <INDENT> e = math . log ( i , p ) <NEWLINE> if e . is_integer ( ) and i not in prev : <NEWLINE> <INDENT> prev . append ( i ) <NEWLINE> flag = True <NEWLINE> check ( n / i , prev ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if flag : <NEWLINE> <INDENT> break <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> check ( n , prev ) <NEWLINE> print ( len ( prev ) ) <NEWLINE>
def p_facto ( n ) : <NEWLINE> <INDENT> ret = [ ] <NEWLINE> nc = n <NEWLINE> for i in range ( 2 , nc ) : <NEWLINE> <INDENT> if i * i > nc : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if n % i == 0 : <NEWLINE> <INDENT> ex = 0 <NEWLINE> while n % i == 0 : <NEWLINE> <INDENT> ex += 1 <NEWLINE> n //= i <NEWLINE> <DEDENT> ret . append ( [ i , ex ] ) <NEWLINE> <DEDENT> <DEDENT> if n != 1 : <NEWLINE> <INDENT> ret . append ( [ n , 1 ] ) <NEWLINE> <DEDENT> return ret <NEWLINE> <NL> <NL> <DEDENT> def main ( N ) : <NEWLINE> <INDENT> ans = 0 <NEWLINE> for p , e in pf : <NEWLINE> <INDENT> ex = 1 <NEWLINE> while true : <NEWLINE> <INDENT> z = p ** ex <NEWLINE> if N % z == 0 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> N //= z <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> ex += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> pf = p_facto ( N ) <NEWLINE> main ( N ) <NEWLINE> <NL> <DEDENT>
def prime_factorize ( n ) : <NEWLINE> <INDENT> a = [ ] <NEWLINE> while n % 2 == 0 : <NEWLINE> <INDENT> a . append ( 2 ) <NEWLINE> n //= 2 <NEWLINE> <DEDENT> f = 3 <NEWLINE> while f * f <= n : <NEWLINE> <INDENT> if n % f == 0 : <NEWLINE> <INDENT> a . append ( f ) <NEWLINE> n //= f <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> f += 2 <NEWLINE> <DEDENT> <DEDENT> if n != 1 : <NEWLINE> <INDENT> a . append ( n ) <NEWLINE> <DEDENT> return a <NEWLINE> <NL> <NL> <DEDENT> N = int ( input ( ) ) <NEWLINE> l = prime_factorize ( N ) <NEWLINE> m = set ( l ) <NEWLINE> l2 = list ( m ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( len ( l2 ) ) : <NEWLINE> <INDENT> x = l . count ( l2 [ i ] ) ) <NEWLINE> while x >= 2 : <NEWLINE> <INDENT> x = x / 2 <NEWLINE> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
if N > rootN : <NEWLINE> <INDENT> res *= 2 <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> d = { 2 : 0 } <NEWLINE> while n % 2 < 1 : n //= 2 ; d [ 2 ] += 1 <NEWLINE> for i in range ( 3 , int ( n ** 0.5 ) + 1 , 2 ) : <NEWLINE> <INDENT> while n % i < 1 : n //= i ; d [ i ] = d . get ( i , 0 ) + 1 <NEWLINE> if n < 2 : break <NEWLINE> <DEDENT> if n > 1 : d [ x ] = 1 <NEWLINE> a = 0 <NEWLINE> for i in d . values ( ) : <NEWLINE> <INDENT> t = c = 0 <NEWLINE> while t + c < i : c += 1 ; t += c <NEWLINE> a += c <NEWLINE> <DEDENT> print ( a ) <NEWLINE>
def sieve ( x ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> <NL> is_prime = [ True ] * ( x + 1 ) <NEWLINE> is_prime [ 0 ] = is_prime [ 1 ] = False <NEWLINE> <NL> for i in range ( 2 , x + 1 ) : <NEWLINE> <INDENT> if is_prime [ i ] : <NEWLINE> <INDENT> for j in range ( i * 2 , x + 1 , i ) : <NEWLINE> <INDENT> is_prime [ j ] = False <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> return is_prime <NEWLINE> <NL> <NL> <DEDENT> def f ( x ) : <NEWLINE> <INDENT> if x < 2 : <NEWLINE> <INDENT> return False <NEWLINE> <NL> <DEDENT> i = 2 <NEWLINE> while i * i <= x : <NEWLINE> <INDENT> if x % i == 0 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> i += 1 <NEWLINE> <NL> <DEDENT> return True <NEWLINE> <NL> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> <NL> if f ( n ) : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> is_prime = sieve ( 10 ** 7 ) <NEWLINE> primes = [ i for i , e in enumerate ( is_prime ) if e ] <NEWLINE> <NL> ans = 0 <NEWLINE> used = set ( ) <NEWLINE> for e in primes : <NEWLINE> <INDENT> div = e <NEWLINE> while div <= n : <NEWLINE> <INDENT> if n % div == 0 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> n //= div <NEWLINE> used . add ( div ) <NEWLINE> <DEDENT> div *= e <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> from heapq import heapify , heappush , heappop <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> N = int ( input ( ) ) <NEWLINE> <NL> def primes ( n ) : <NEWLINE> <INDENT> ass = [ ] <NEWLINE> is_prime = [ True ] * ( n + 1 ) <NEWLINE> is_prime [ 0 ] = False <NEWLINE> is_prime [ 1 ] = False <NEWLINE> for i in range ( 2 , int ( n ** 0.5 ) + 1 ) : <NEWLINE> <INDENT> if not is_prime [ i ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> for j in range ( i * 2 , n + 1 , i ) : <NEWLINE> <INDENT> is_prime [ j ] = False <NEWLINE> <DEDENT> <DEDENT> for i in range ( len ( is_prime ) ) : <NEWLINE> <INDENT> if is_prime [ i ] : <NEWLINE> <INDENT> ass . append ( i ) <NEWLINE> <DEDENT> <DEDENT> return ass <NEWLINE> <NL> <DEDENT> if N == 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> _ , Zque = primes ( N ) <NEWLINE> Zset = set ( Zque ) <NEWLINE> Z = heappop ( Zque ) <NEWLINE> if N in Zque : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> while N >= Z : <NEWLINE> <COMMENT> <NL> <INDENT> if N % Z == 0 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> N = N // Z <NEWLINE> <DEDENT> i = Z <NEWLINE> num = Z <NEWLINE> j = 2 <NEWLINE> while num <= N : <NEWLINE> <COMMENT> <NL> <INDENT> if not num in Zset : <NEWLINE> <INDENT> heappush ( Zque , num ) <NEWLINE> Zset . add ( num ) <NEWLINE> <DEDENT> num = i ** j <NEWLINE> j += 1 <NEWLINE> <DEDENT> Z = heappop ( Zque ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL>
N = int ( input ( ) ) <NEWLINE> n = N <NEWLINE> p = 2 <NEWLINE> dcmp = { } <NEWLINE> while n > 1 : <NEWLINE> <INDENT> if n % p == 0 : <NEWLINE> <INDENT> dcmp [ p ] = 1 + ( dcmp [ p ] if p in dcmp else 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> p += 1 <NEWLINE> <DEDENT> <DEDENT> cnt = 0 <NEWLINE> for k , v in dcmp . items ( ) : <NEWLINE> <INDENT> i = 1 <NEWLINE> while True : <NEWLINE> <INDENT> dcmp [ k ] -= i <NEWLINE> if dcmp [ k ] < 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> i += 1 <NEWLINE> cnt += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
<COMMENT> <NL> import sys <NEWLINE> <NL> <COMMENT> <NL> sysread = sys . stdin . readline <NEWLINE> read = sys . stdin . read <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> import math <NEWLINE> <NL> def run ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> <NL> primes = [ ] <NEWLINE> p = [ 0 ] * 1000000 <NEWLINE> <NL> for i in range ( 2 , 1000000 ) : <NEWLINE> <INDENT> done = False <NEWLINE> m = int ( i ** ( 1 / 2 ) ) <NEWLINE> for k in primes : <NEWLINE> <INDENT> if k > m : break <NEWLINE> if i % k == 0 : <NEWLINE> <INDENT> done = True <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if not done : <NEWLINE> <INDENT> primes . append ( i ) <NEWLINE> p [ i ] = 1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> count = 0 <NEWLINE> <NL> for i in primes : <NEWLINE> <INDENT> if p [ 2 ] : <NEWLINE> <INDENT> s = i <NEWLINE> while True : <NEWLINE> <INDENT> if not N % s : <NEWLINE> <NL> <INDENT> N = N // s <NEWLINE> count += 1 <NEWLINE> s *= i <NEWLINE> <NL> <DEDENT> else : break <NEWLINE> <DEDENT> s = s // i <NEWLINE> while s > 0 : <NEWLINE> <INDENT> if not N % s : <NEWLINE> <INDENT> N = N // s <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s = s // i <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if count == 0 and N != 1 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> elif N != 1 : <NEWLINE> <INDENT> print ( count + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( count ) <NEWLINE> <NL> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> run ( ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> def p_num_edit ( n ) : <NEWLINE> <INDENT> tmp = n <NEWLINE> ans = [ ] <NEWLINE> for i in range ( 2 , int ( np . sqrt ( n ) ) + 1 ) : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> while tmp % i == 0 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> tmp = int ( tmp / i ) <NEWLINE> <DEDENT> if cnt > 0 : <NEWLINE> <INDENT> ans . append ( [ i , cnt ] ) <NEWLINE> <DEDENT> <DEDENT> if tmp != 1 : <NEWLINE> <INDENT> ans . append ( [ tmp , 1 ] ) <NEWLINE> <DEDENT> if ans == [ ] : <NEWLINE> <INDENT> ans . append ( [ n , 1 ] ) <NEWLINE> <DEDENT> return ans <NEWLINE> <NL> <NL> <DEDENT> n = xnxn ( ) <NEWLINE> <NL> if n == 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a = p_num_edit ( n ) <NEWLINE> c = 0 <NEWLINE> for num in a : <NEWLINE> <INDENT> i = 1 <NEWLINE> while num [ 1 ] - i > - 1 : <NEWLINE> <INDENT> num [ 1 ] -= i <NEWLINE> i += 1 <NEWLINE> c += 1 <NEWLINE> <DEDENT> <DEDENT> print ( c ) <NEWLINE> <DEDENT>
ef D ( argN = None ) : <NEWLINE> <INDENT> answer = 0 <NEWLINE> N = argN or int ( input ( ) ) <NEWLINE> if N == 1 : <NEWLINE> <INDENT> print ( answer ) <NEWLINE> <DEDENT> else : <NEWLINE> <COMMENT> <NL> <INDENT> for p in range ( 2 , int ( N ** 0.5 ) + 2 ) : <NEWLINE> <INDENT> e = 0 <NEWLINE> while ( N % p == 0 ) : <NEWLINE> <INDENT> N /= p <NEWLINE> e += 1 <NEWLINE> <COMMENT> <NL> <DEDENT> if e > 0 : <NEWLINE> <COMMENT> <NL> <INDENT> for i in range ( 1 , e + 1 ) : <NEWLINE> <INDENT> if e >= 1 : <NEWLINE> <INDENT> e -= i <NEWLINE> answer += 1 <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if answer == 0 : <NEWLINE> <INDENT> answer = 1 <NEWLINE> <DEDENT> print ( answer ) <NEWLINE> <NL> <DEDENT> <DEDENT> D ( ) <NEWLINE>
import io , sys <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> <NL> def prime ( n ) : <NEWLINE> <INDENT> nums = [ True ] * n <NEWLINE> primes = [ ] <NEWLINE> for i in range ( 2 , n ) : <NEWLINE> <INDENT> if nums [ i ] : <NEWLINE> <INDENT> primes . append ( i ) <NEWLINE> for j in range ( 2 * i , n , i ) : <NEWLINE> <INDENT> nums [ j ] = False <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return primes <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> from collections import Counter <NEWLINE> from collections import deque <NEWLINE> import bisect <NEWLINE> n = int ( input ( ) ) <NEWLINE> num = Counter ( [ ] ) <NEWLINE> <NL> primes = prime ( int ( n ** 0.5 + 1 ) ) + [ n ] <NEWLINE> primes = deque ( primes ) <NEWLINE> <NL> while n != 1 : <NEWLINE> <INDENT> while len ( primes ) > 0 : <NEWLINE> <INDENT> p = primes . popleft ( ) <NEWLINE> if len ( primes ) > 0 : <NEWLINE> <INDENT> q = primes . pop ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> q = 10 ** 10 <NEWLINE> <DEDENT> if n % p == 0 : <NEWLINE> <INDENT> num [ p ] += 1 <NEWLINE> n = n // p <NEWLINE> primes . appendleft ( p ) <NEWLINE> break <NEWLINE> <DEDENT> elif n % q == 0 : <NEWLINE> <INDENT> num [ q ] += 1 <NEWLINE> n = n // q <NEWLINE> primes . append ( q ) <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> m = max ( num . values ( ) ) <NEWLINE> N = [ i * ( i + 1 ) // 2 for i in range ( 1 , int ( ( 2 * m ) ** 0.5 ) + 1 ) ] <NEWLINE> ans = 0 <NEWLINE> for i in num . values ( ) : <NEWLINE> <INDENT> k = bisect . bisect_right ( N , i ) <NEWLINE> ans += k <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <DEDENT> main ( ) <NEWLINE>
import collections <NEWLINE> N = int ( input ( ) ) <NEWLINE> <NL> c = collections . Counter ( prime_factorize ( N ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> for j in c : <NEWLINE> <INDENT> for i in range ( 1 , c [ j ] + 1 ) : <NEWLINE> <INDENT> if c [ j ] == 1 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> elif i * ( i + 1 ) <= 2 * c [ j ] < ( i + 1 ) * ( i + 2 ) : <NEWLINE> <INDENT> ans += i <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
def fc ( n ) : <NEWLINE> <INDENT> wk = 0 <NEWLINE> h = 0 <NEWLINE> for i in range ( 2 , int ( n ** 0.5 ) + 1 ) : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> wk += 1 <NEWLINE> n //= i <NEWLINE> h = i <NEWLINE> <DEDENT> <DEDENT> if n != 1 and h < n : <NEWLINE> <INDENT> wk += 1 <NEWLINE> <DEDENT> return wk <NEWLINE> <NL> <DEDENT> n = int ( input ( ) <NEWLINE>
import sys <NEWLINE> n = int ( input ( ) ) <NEWLINE> if n == 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> def f ( n ) : <NEWLINE> <INDENT> arr = [ ] <NEWLINE> temp = n <NEWLINE> for i in range ( 2 , int ( - ( - n ** 0.5 // 1 ) ) + 1 ) : <NEWLINE> <INDENT> if temp % i == 0 : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> while temp % i == 0 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> temp //= i <NEWLINE> <DEDENT> arr . append ( [ i , cnt ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> if temp != 1 : <NEWLINE> <INDENT> arr . append ( [ temp , 1 ] ) <NEWLINE> <NL> <DEDENT> if arr == [ ] : <NEWLINE> <INDENT> arr . append ( [ n , 1 ] ) <NEWLINE> <NL> <DEDENT> return arr <NEWLINE> <DEDENT> tmp = f ( n ) <NEWLINE> ans = 0 <NEWLINE> for i in tmp : <NEWLINE> <INDENT> dd = i [ 1 ] <NEWLINE> tt = 1 <NEWLINE> while dd > 0 : <NEWLINE> <INDENT> if dd - tt >= 0 : <NEWLINE> <INDENT> dd -= tt <NEWLINE> tt += 1 <NEWLINE> ans += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) = 0 : <NEWLINE> <INDENT> dd -= tt <NEWLINE> tt += 1 <NEWLINE> ans += 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
<INDENT> n = int ( input ( ) ) <NEWLINE> from math import sqrt as S <NEWLINE> pf = [ ] <NEWLINE> for i in range ( 2 , int ( S ( n ) ) + 1 ) : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> c = 0 <NEWLINE> while n % i == 0 : <NEWLINE> <INDENT> n //= i <NEWLINE> c += 1 <NEWLINE> <DEDENT> pf . append ( [ i , c ] ) <NEWLINE> <DEDENT> <DEDENT> if n > 1 : <NEWLINE> <INDENT> pf . append ( [ n , 1 ] ) <NEWLINE> <DEDENT> cnt = 0 <NEWLINE> def search ( x ) : <NEWLINE> <INDENT> i = 1 <NEWLINE> while i ( i + 1 ) // 2 <= x : <NEWLINE> <INDENT> i += 1 <NEWLINE> <DEDENT> return i - 1 <NEWLINE> <DEDENT> for x in range ( len ( pf ) ) : <NEWLINE> <INDENT> a = pf [ x ] [ 0 ] <NEWLINE> b = pf [ x ] [ 1 ] <NEWLINE> cnt += search ( b ) <NEWLINE> <DEDENT> print ( cnt ) <NEWLINE> <DEDENT>
def factorization ( n ) : <NEWLINE> <INDENT> arr = [ ] <NEWLINE> temp = n <NEWLINE> for i in range ( 2 , int ( - ( - n ** 0.5 // 1 ) ) + 1 ) : <NEWLINE> <INDENT> if temp % i == 0 : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> while temp % i == 0 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> temp //= i <NEWLINE> <DEDENT> arr . append ( [ i , cnt ] ) <NEWLINE> <DEDENT> <DEDENT> if temp != 1 : <NEWLINE> <INDENT> arr . append ( [ temp , 1 ] ) <NEWLINE> <DEDENT> if arr == [ ] : <NEWLINE> <INDENT> arr . append ( [ n , 1 ] ) <NEWLINE> <DEDENT> return arr <NEWLINE> <DEDENT> N = int ( input ( ) ) <NEWLINE> if a == 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> a = factorization ( N ) <NEWLINE> cnt = 0 <NEWLINE> for i in a : <NEWLINE> <INDENT> temp = i [ 1 ] - 1 <NEWLINE> d = 2 <NEWLINE> while temp >= d : <NEWLINE> <INDENT> temp -= d <NEWLINE> d += 1 <NEWLINE> <DEDENT> cnt += d - 1 <NEWLINE> <DEDENT> print ( cnt ) <NEWLINE> <NL> <NL> <NL> <NL> <NL>
def factorization ( n ) : <NEWLINE> <INDENT> arr = [ ] <NEWLINE> temp = n <NEWLINE> for i in range ( 2 , int ( - ( - n ** 0.5 // 1 ) ) + 1 ) : <NEWLINE> <INDENT> if temp % i == 0 : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> while temp % i == 0 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> temp //= i <NEWLINE> <DEDENT> arr . append ( [ i , cnt ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> if temp != 1 : <NEWLINE> <INDENT> arr . append ( [ temp , 1 ] ) <NEWLINE> <NL> <DEDENT> if arr == [ ] : <NEWLINE> <INDENT> arr . append ( [ n , 1 ] ) <NEWLINE> <NL> <DEDENT> return arr <NEWLINE> <NL> <DEDENT> a = int ( input ( ) ) <NEWLINE> b = factorization ( a ) <NEWLINE> countation = 0 <NEWLINE> for i in range ( len ( b ) ) : <NEWLINE> <INDENT> t = b [ i ] [ 1 ] <NEWLINE> k = 1 <NEWLINE> n = 1 <NEWLINE> while t >= n : <NEWLINE> <INDENT> countation += 1 <NEWLINE> k = k + 1 <NEWLINE> n = k * ( k + 1 ) / 2 <NEWLINE> <DEDENT> <DEDENT> if a != 1 <NEWLINE> <INDENT> print ( countation ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT>
a , n = 0 , int ( input ( ) ) <NEWLINE> for i in range ( 2 , int ( n ** 0.5 + 1 ) ) : x = 0 <NEWLINE> <INDENT> while ( n % i == 0 ) : n //= i ; x += 1 <NEWLINE> j = 1 <NEWLINE> while ( x >= j ) : a += 1 ; x -= j ; j += 1 <NEWLINE> <DEDENT> print ( 1 if n - 1 else a ) <NEWLINE>
def prime_factorize ( n ) : <NEWLINE> <INDENT> a = [ ] <NEWLINE> while n % 2 == 0 : <NEWLINE> <INDENT> a . append ( 2 ) <NEWLINE> n //= 2 <NEWLINE> <DEDENT> f = 3 <NEWLINE> while f * f <= n : <NEWLINE> <INDENT> if n % f == 0 : <NEWLINE> <INDENT> a . append ( f ) <NEWLINE> n //= f <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> f += 2 <NEWLINE> <DEDENT> <DEDENT> if n != 1 : <NEWLINE> <INDENT> a . append ( n ) <NEWLINE> <DEDENT> return a <NEWLINE> <DEDENT> dum = prime_factorize ( int ( input ( ) ) ) <NEWLINE> print ( dum ) <NEWLINE> print ( len ( dum ) ) <NEWLINE> dum1 = 0 <NEWLINE> ans = 0 <NEWLINE> for i in range ( len ( dum ) ) : <NEWLINE> <INDENT> if dum [ i ] == dum [ i + 1 ] : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dum1 = 0 <NEWLINE> cnt = 0 <NEWLINE> <DEDENT> if cnt > dum1 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> cnt = 0 <NEWLINE> dum1 += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> num_list = [ 0 ] + [ 0 ] * int ( math . sqrt ( N ) ) <COMMENT> <NEWLINE> pn_list = [ ] <NEWLINE> for i in range ( 2 , int ( math . sqrt ( N ) ) + 2 ) : <NEWLINE> <INDENT> if num_list [ i ] == 0 : <NEWLINE> <INDENT> pn_list . append ( i ) <NEWLINE> num_list [ i : : i ] = [ 1 ] * len ( num_list [ i : : i ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> count = 0 <NEWLINE> for pn in pn_list : <NEWLINE> <INDENT> e = 1 <NEWLINE> while N % ( pn ** e ) == 0 and N // ( pn ** e ) >= 1 : <NEWLINE> <INDENT> N //= ( pn ** e ) <NEWLINE> e += 1 <NEWLINE> count += 1 <NEWLINE> <DEDENT> <DEDENT> if count == 0 and N > 1 : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> print ( count ) <NEWLINE>
def factorization ( n ) : <NEWLINE> <INDENT> arr = [ ] <NEWLINE> temp = n <NEWLINE> for i in range ( 2 , int ( - ( - n ** 0.5 // 1 ) ) + 1 ) : <NEWLINE> <INDENT> if temp % i == 0 : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> while temp % i == 0 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> temp //= i <NEWLINE> <DEDENT> arr . append ( [ i , cnt ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> if temp != 1 : <NEWLINE> <INDENT> arr . append ( [ temp , 1 ] ) <NEWLINE> <NL> <DEDENT> if arr == [ ] : <NEWLINE> <INDENT> arr . append ( [ n , 1 ] ) <NEWLINE> <NL> <DEDENT> return arr <NEWLINE> <NL> <DEDENT> N = one_int ( ) <NEWLINE> <NL> temp = factorization ( N ) <NEWLINE> temp = sorted ( temp , key = lambda x : x [ 0 ] ) <NEWLINE> <NL> output_set = [ ] <NEWLINE> output = [ output_set + [ t [ 0 ] ] * t [ 1 ] for t in temp ] <NEWLINE> <NL> <NL> count = 0 <NEWLINE> for i in output : <NEWLINE> <INDENT> temp = len ( i ) <NEWLINE> sums = 0 <NEWLINE> for t in range ( 1 , temp + 1 ) : <NEWLINE> <INDENT> sums += t <NEWLINE> if temp >= sums : <NEWLINE> <INDENT> count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> <COMMENT> <NL> <NL> <NL> def factorization ( n ) : <NEWLINE> <INDENT> arr = [ ] <NEWLINE> temp = n <NEWLINE> for i in range ( 2 , int ( - ( - n ** 0.5 // 1 ) ) + 1 ) : <NEWLINE> <INDENT> if temp % i == 0 : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> while temp % i == 0 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> temp //= i <NEWLINE> <DEDENT> arr . append ( [ i , cnt ] ) <NEWLINE> <DEDENT> <DEDENT> if temp != 1 : <NEWLINE> <INDENT> arr . append ( [ temp , 1 ] ) <NEWLINE> <DEDENT> if arr == [ ] : <NEWLINE> <INDENT> arr . append ( [ n , 1 ] ) <NEWLINE> <DEDENT> return arr <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) . strip ( ) ) <NEWLINE> if N == 1 : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> factors = factorization ( N ) <NEWLINE> ans = 0 <NEWLINE> for factor in factors : <NEWLINE> <INDENT> counter = 1 <NEWLINE> while True : <NEWLINE> <INDENT> if factor [ 1 ] >= counter : <NEWLINE> <INDENT> selected . add ( factor [ 0 ] ** counter ) <NEWLINE> factor [ 1 ] -= counter <NEWLINE> counter += 1 <NEWLINE> ans += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return ans <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> print ( main ( ) ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> f = set ( prime_factorize ( n ) ) <NEWLINE> s = set ( ) <NEWLINE> for p in f : <NEWLINE> <INDENT> e = 1 <NEWLINE> z = p ** e <NEWLINE> while z <= n : <NEWLINE> <INDENT> if n % z == 0 : <NEWLINE> <INDENT> if z not in s : <NEWLINE> <INDENT> n //= z <NEWLINE> s . add ( z ) <NEWLINE> <DEDENT> <DEDENT> e += 1 <NEWLINE> z = p ** e <NEWLINE> <DEDENT> <DEDENT> print ( len ( s ) ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import math <NEWLINE> import collections <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> prime_number = False <NEWLINE> ans = 0 <NEWLINE> <NL> def trial_division ( n ) : <NEWLINE> <COMMENT> <NL> <INDENT> factor = [ ] <NEWLINE> <COMMENT> <NL> tmp = int ( math . sqrt ( n ) ) + 1 <NEWLINE> for num in range ( 2 , tmp ) : <NEWLINE> <INDENT> while n % num == 0 : <NEWLINE> <INDENT> n //= num <NEWLINE> factor . append ( num ) <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> if not factor : <NEWLINE> <INDENT> global prime_number <NEWLINE> prime_number = True <NEWLINE> return <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> factor . append ( n ) <NEWLINE> return factor <NEWLINE> <NL> <DEDENT> <DEDENT> list_num = trial_division ( N ) <NEWLINE> <NL> if prime_number : <NEWLINE> <INDENT> ans = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if 1 in list_num : <NEWLINE> <INDENT> prime_list = list_num [ : - 1 ] <NEWLINE> counter = collections . Counter ( prime_list ) <NEWLINE> for key , val in counter . items ( ) : <NEWLINE> <INDENT> temp = val <NEWLINE> for i in range ( 1 , val + 1 ) : <NEWLINE> <INDENT> if temp - i > 0 : <NEWLINE> <INDENT> temp -= i <NEWLINE> ans += 1 <NEWLINE> <DEDENT> elif temp - i == 0 : <NEWLINE> <INDENT> temp -= i <NEWLINE> ans += 1 <NEWLINE> break <NEWLINE> <DEDENT> else <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> li = [ ] <NEWLINE> if n == 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( 1000000 ) : <NEWLINE> <INDENT> if n == 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if i == 0 or i == 1 or n % i != 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> j = i <NEWLINE> cnt = 0 <NEWLINE> while ( n % j == 0 ) : <NEWLINE> <INDENT> if flg == 0 : <NEWLINE> <INDENT> flg = 1 <NEWLINE> <DEDENT> n /= j <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> li . append ( cnt ) <NEWLINE> <DEDENT> if flg == 0 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = 0 <NEWLINE> for e in li : <NEWLINE> <INDENT> i = 1 <NEWLINE> while ( e - i >= 0 ) : <NEWLINE> <INDENT> e -= i <NEWLINE> i += 1 <NEWLINE> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <DEDENT> <DEDENT>
sieve = [ True ] * ( 10 ** 6 + 1 ) <NEWLINE> prime = [ ] <NEWLINE> for i in range ( 2 , 10 ** 6 ) : <NEWLINE> <INDENT> if sieve [ i ] : <NEWLINE> <INDENT> prime . append ( i ) <NEWLINE> if i < 10 ** 3 : <NEWLINE> <INDENT> for j in range ( i ** 2 , 10 ** 6 , i ) : <NEWLINE> <INDENT> sieve [ j ] = False <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> n = int ( input ( ) ) <NEWLINE> if n == 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> e = [ ] <NEWLINE> for p in prime : <NEWLINE> <INDENT> if n % p == 0 : <NEWLINE> <INDENT> idx = 0 <NEWLINE> while n % p == 0 : <NEWLINE> <INDENT> n = n // p <NEWLINE> idx += 1 <NEWLINE> <DEDENT> e . append ( idx ) <NEWLINE> <DEDENT> if n == 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> if len ( e ) > 0 : <NEWLINE> <INDENT> total = 0 <NEWLINE> for idx in e : <NEWLINE> <INDENT> cnt = 1 <NEWLINE> while idx = > cnt * ( cnt + 1 ) // 2 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> cnt -= 1 <NEWLINE> total += cnt <NEWLINE> <DEDENT> if n == 1 : <NEWLINE> <INDENT> print ( total ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( total + 1 ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> if N == 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> result = 0 <NEWLINE> for i in range ( len ( factorization ( N ) ) ) : <NEWLINE> <INDENT> tempnumber = factorization ( N ) [ i ] [ 1 ] <NEWLINE> plusnumber = 1 <NEWLINE> while tempnumber > 0 : <NEWLINE> <INDENT> tempnumber -= plusnumber <NEWLINE> result += 1 <NEWLINE> plusnumber += 1 <NEWLINE> <DEDENT> <DEDENT> print ( result ) <NEWLINE> <DEDENT>
def factorization ( n ) : <NEWLINE> <INDENT> arr = [ ] <NEWLINE> temp = n <NEWLINE> for i in range ( 2 , int ( - ( - n ** 0.5 // 1 ) ) + 1 ) : <NEWLINE> <INDENT> if temp % i == 0 : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> while temp % i == 0 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> temp //= i <NEWLINE> <DEDENT> arr . append ( [ i , cnt ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> if temp != 1 : <NEWLINE> <INDENT> arr . append ( [ temp , 1 ] ) <NEWLINE> <NL> <DEDENT> if arr == [ ] : <NEWLINE> <INDENT> arr . append ( [ n , 1 ] ) <NEWLINE> <NL> <DEDENT> return arr <NEWLINE> <DEDENT> ans = 0 <NEWLINE> <NL> if ( N > 1 ) : <NEWLINE> <INDENT> Q = factorization ( N ) <NEWLINE> <STRING> <NEWLINE> A = [ b for [ a , b ] in Q ] <NEWLINE> for a in A : <NEWLINE> <INDENT> i = 1 <NEWLINE> while ( a >= i ) : <NEWLINE> <INDENT> a -= i <NEWLINE> i += 1 <NEWLINE> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT>
from collections import Counter <NEWLINE> N = int ( input ( ) ) <NEWLINE> factors = [ ] <NEWLINE> i = 2 <NEWLINE> while N > 1 : <NEWLINE> <INDENT> if N < i * i : <NEWLINE> <INDENT> factors . append ( N ) <NEWLINE> break <NEWLINE> <DEDENT> while N % i == 0 : <NEWLINE> <INDENT> factors . append ( i ) <NEWLINE> <DEDENT> i += 1 <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for count in Counter ( factors ) . values ( ) : <NEWLINE> <INDENT> i = 1 <NEWLINE> while count >= i : <NEWLINE> <INDENT> count -= i <NEWLINE> i += 1 <NEWLINE> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> import sys <NEWLINE> from random import randint <NEWLINE> from math import gcd <NEWLINE> <NL> <NL> def solve ( N : int ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <INDENT> n = N <NEWLINE> ds = make_divisors ( n ) <NEWLINE> print ( ds ) <NEWLINE> used = [ ] <NEWLINE> while ( True ) : <NEWLINE> <INDENT> count = len ( used ) <NEWLINE> for d in ds : <NEWLINE> <INDENT> if d in used : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> p , k = primePower ( d ) <NEWLINE> print ( p ) <NEWLINE> if p == 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> n /= d <NEWLINE> used . append ( d ) <NEWLINE> break <NEWLINE> <NL> <DEDENT> if count == len ( used ) : <NEWLINE> <INDENT> print ( count ) <NEWLINE> return <NEWLINE> <DEDENT> <DEDENT> return <NEWLINE> <NL> <NL> <DEDENT> def make_divisors ( n ) : <NEWLINE> <INDENT> divisors = [ ] <NEWLINE> for i in range ( 1 , int ( n ** 0.5 ) + 1 ) : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> divisors . append ( i ) <NEWLINE> if i != n // i : <NEWLINE> <INDENT> divisors . append ( n // i ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> return divisors <NEWLINE> <NL> <NL> <DEDENT> def findWitness ( n , k = 5 ) : <COMMENT> <NEWLINE> <INDENT> s , d = 0 , n - 1 <NEWLINE> while d % 2 == 0 : <NEWLINE> <INDENT> s , d = s + 1 , d / 2 <NEWLINE> <DEDENT> for i in range ( k ) : <NEWLINE> <INDENT> a = randint ( 2 , n - 1 ) <NEWLINE> x = pow ( a , d , n ) <NEWLINE> if x == 1 or x == n - 1 : continue <NEWLINE> for r in range ( 1 , s ) : <NEWLINE> <INDENT> x = ( x * x ) % n <NEWLINE> if x == 1 : return a <NEWLINE> if x == n - 1 : break <NEWLINE> <DEDENT> else : return a <NEWLINE> <DEDENT> return 0 <NEWLINE> <NL> <NL> <DEDENT> def primePower ( n ) : <NEWLINE> <INDENT> def checkP ( n , p ) : <NEWLINE> <INDENT> k = 0 <NEWLINE> while n > 1 and n % p == 0 : <NEWLINE> <INDENT> n , k = n / p , k + 1 <NEWLINE> <DEDENT> if n == 1 : return p , k <NEWLINE> else : return 0 , 0 <NEWLINE> <NL> <DEDENT> if n % 2 == 0 : return checkP ( n , 2 ) <NEWLINE> q = n <NEWLINE> while True : <NEWLINE> <INDENT> a = findWitness ( q ) <NEWLINE> if a == 0 : return checkP ( n , q ) <NEWLINE> d = gcd ( pow ( a , q , n ) - a , q ) <NEWLINE> if d == 1 or d == q : return 0 , 0 <NEWLINE> q = d <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <INDENT> def iterate_tokens ( ) : <NEWLINE> <INDENT> for line in sys . stdin : <NEWLINE> <INDENT> for word in line . split ( ) : <NEWLINE> <INDENT> yield word <NEWLINE> <DEDENT> <DEDENT> <DEDENT> tokens = iterate_tokens ( ) <NEWLINE> N = int ( next ( tokens ) ) <COMMENT> <NEWLINE> solve ( N ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import math <NEWLINE> A , B = input ( ) . split ( ) <NEWLINE> <NL> print ( int ( math . floor ( float ( A ) * float ( B ) ) ) ) <NEWLINE>
import collections <NEWLINE> def factorization ( n ) : <NEWLINE> <INDENT> if n < 2 : <NEWLINE> <INDENT> return [ ] <NEWLINE> <NL> <DEDENT> prime_factor = [ ] <NEWLINE> <NL> for i in range ( 2 , int ( n ** 0.5 ) + 1 ) : <NEWLINE> <INDENT> while n % i == 0 : <NEWLINE> <INDENT> prime_factor . append ( i ) <NEWLINE> n //= i <NEWLINE> <NL> <DEDENT> <DEDENT> if n > 1 : <NEWLINE> <INDENT> prime_factor . append ( n ) <NEWLINE> <NL> <NL> <DEDENT> return prime_factor <NEWLINE> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> <NL> c = collections . Counter ( factorization ( n ) ) <NEWLINE> d = list ( c . values ( ) ) <NEWLINE> <NL> for v in c . values ( ) : <NEWLINE> <INDENT> for i in range ( 1 , n ) : <NEWLINE> <INDENT> v -= i <NEWLINE> if v >= 0 : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
import itertools <NEWLINE> N = int ( input ( ) ) <NEWLINE> def prime_factorize ( n ) : <NEWLINE> <INDENT> a = [ ] <NEWLINE> while n % 2 == 0 : <NEWLINE> <INDENT> a . append ( 2 ) <NEWLINE> n //= 2 <NEWLINE> <DEDENT> f = 3 <NEWLINE> while f * f <= n : <NEWLINE> <INDENT> if n % f == 0 : <NEWLINE> <INDENT> a . append ( f ) <NEWLINE> n //= f <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> f += 2 <NEWLINE> <DEDENT> <DEDENT> if n != 1 : <NEWLINE> <INDENT> a . append ( n ) <NEWLINE> <DEDENT> return a <NEWLINE> <DEDENT> x = prime_factorize ( N ) <NEWLINE> l = list ( set ( prime_factorize ( N ) ) ) <NEWLINE> s = [ ] <NEWLINE> for i in range ( len ( l ) ) : <NEWLINE> <INDENT> s . append ( [ ] ) <NEWLINE> <DEDENT> for i in l : <NEWLINE> <INDENT> a = l . index ( i ) <NEWLINE> b = i <NEWLINE> for j in range ( x . count ( i ) ) : <NEWLINE> <INDENT> s [ a ] . append ( i ) <NEWLINE> i *= b <NEWLINE> <DEDENT> <DEDENT> t = list ( itertools . chain . from_iterable ( s ) ) <NEWLINE> ans = 0 <NEWLINE> while len ( t ) > 0 : <NEWLINE> <INDENT> p = t . pop ( t . index ( min ( t ) ) ) <NEWLINE> sp = s [ l . index ( p ) ] <NEWLINE> ssp = sp [ len ( sp ) - 1 ] <NEWLINE> sp . pop ( sp . index ( ssp ) ) <NEWLINE> if len ( sp ) > 1 : <NEWLINE> <INDENT> t . pop ( t . index ( ssp ) ) <NEWLINE> <DEDENT> ans += 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL>
n = int ( input ( ) ) <NEWLINE> m = n <NEWLINE> <NL> exp = [ ] <NEWLINE> div = [ ] <NEWLINE> for i in range ( 2 , int ( n ** ( 1 / 2 ) ) + 2 ) : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> if n % i == 0 : <NEWLINE> <INDENT> div . append ( n // i ) <NEWLINE> while n % i == 0 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> n //= i <NEWLINE> <DEDENT> exp . append ( cnt ) <NEWLINE> <NL> <DEDENT> <DEDENT> for i in div : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> while n % i == 0 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> n //= i <NEWLINE> <DEDENT> if cnt >= 1 : <NEWLINE> <INDENT> exp . append ( cnt ) <NEWLINE> <NL> <DEDENT> <DEDENT> if n == m and m > 1 : <NEWLINE> <INDENT> exp . append ( 1 ) <NEWLINE> <NL> <DEDENT> opr = 0 <NEWLINE> for x in exp : <NEWLINE> <INDENT> opr += int ( ( - 1 + ( 8 * x + 1 ) ** ( 1 / 2 ) ) / 2 ) <NEWLINE> <NL> <DEDENT> print ( opr ) <NEWLINE>
<COMMENT> <NL> <NL> import sys <NEWLINE> from collections import deque , Counter <NEWLINE> int1 = lambda x : int ( x ) - 1 <NEWLINE> read = sys . stdin . buffer . read <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> readlines = sys . stdin . buffer . readlines <NEWLINE> sys . setrecursionlimit ( 500000 ) <NEWLINE> <NL> N = int ( readline ( ) ) <NEWLINE> <NL> def prime_factorize ( n ) : <NEWLINE> <INDENT> a = [ ] <NEWLINE> while n % 2 == 0 : <NEWLINE> <INDENT> a . append ( 2 ) <NEWLINE> n //= 2 <NEWLINE> <DEDENT> f = 3 <NEWLINE> while f * f <= n : <NEWLINE> <INDENT> if n % f == 0 : <NEWLINE> <INDENT> a . append ( f ) <NEWLINE> n //= f <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> f += 2 <NEWLINE> <DEDENT> <DEDENT> if n != 1 : <NEWLINE> <INDENT> a . append ( n ) <NEWLINE> <DEDENT> return a <NEWLINE> <NL> <NL> <DEDENT> c = list ( Counter ( prime_factorize ( N ) ) . values ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> used = { } <NEWLINE> <NL> for i in range ( len ( c ) ) : <NEWLINE> <INDENT> acc = 0 <NEWLINE> cnt = 1 <NEWLINE> while True : <NEWLINE> <INDENT> if c [ i ] >= acc + cnt : <NEWLINE> <INDENT> c [ i ] -= acc + cnt <NEWLINE> acc = acc + cnt <NEWLINE> ans += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> c = sorted ( c ) [ : : - 1 ] <NEWLINE> <NL> hoge = 1 <NEWLINE> for hoge in range ( 1 , 1000 ) : <NEWLINE> <INDENT> for _ in range ( 100000 ) : <NEWLINE> <INDENT> for i in range ( len ( c ) - 1 ) : <NEWLINE> <INDENT> if min ( c [ i : i + hoge + 1 ] ) >= 1 : <NEWLINE> <INDENT> for k in range ( hoge + 1 ) : <NEWLINE> <INDENT> c [ i + k ] -= 1 <NEWLINE> <DEDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> c = sorted ( c ) [ : : - 1 ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import collections <NEWLINE> <NL> def prime_factorize ( n ) : <NEWLINE> <INDENT> a = [ ] <NEWLINE> while n % 2 == 0 : <NEWLINE> <INDENT> a . append ( 2 ) <NEWLINE> n //= 2 <NEWLINE> <DEDENT> f = 3 <NEWLINE> while f * f <= n : <NEWLINE> <INDENT> if n % f == 0 : <NEWLINE> <INDENT> a . append ( f ) <NEWLINE> n //= f <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> f += 2 <NEWLINE> <DEDENT> <DEDENT> if n != 1 : <NEWLINE> <INDENT> a . append ( n ) <NEWLINE> <DEDENT> return a <NEWLINE> <NL> <NL> <DEDENT> c = collections . Counter ( prime_factorize ( N ) ) <NEWLINE> <NL> A = c . keys ( ) <NEWLINE> count = c . values ( ) <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> for i in count : <NEWLINE> <INDENT> k = 0 <NEWLINE> for j in range ( 1 , i ) : <NEWLINE> <INDENT> k += j <NEWLINE> if k <= i : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from itertools import groupby <NEWLINE> n = int ( input ( ) ) <NEWLINE> <NL> def prime_decomposition ( n ) : <NEWLINE> <INDENT> i = 2 <NEWLINE> table = [ ] <NEWLINE> while i * i <= n : <NEWLINE> <INDENT> while n % i == 0 : <NEWLINE> <INDENT> n //= i <NEWLINE> table . append ( i ) <NEWLINE> i += 1 <NEWLINE> <DEDENT> <DEDENT> if n > 1 : <NEWLINE> <INDENT> table . append ( n ) <NEWLINE> <DEDENT> return table <NEWLINE> <NL> <DEDENT> from itertools import groupby <NEWLINE> ans = 0 <NEWLINE> p = prime_decomposition ( n ) <NEWLINE> for k , g in p : <NEWLINE> <INDENT> gn = len ( list ( g ) ) <NEWLINE> for i in range ( 1 , 1000000000000 ) : <NEWLINE> <INDENT> gn -= i <NEWLINE> if gn >= 0 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> from collections import Counter <NEWLINE> A = int ( input ( ) ) <NEWLINE> resArray = [ ] <NEWLINE> tmpA = A <NEWLINE> i = 1 <NEWLINE> while i <= math . sqrt ( A ) : <NEWLINE> <COMMENT> <NL> <INDENT> i += 1 <NEWLINE> if tmpA == 1 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> if i > 2 and i % 2 == 0 : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <NL> <DEDENT> while tmpA % i == 0 : <NEWLINE> <INDENT> tmpA = tmpA / i <NEWLINE> resArray . append ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> res = 0 <NEWLINE> if tmpA == A : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else tmpA > 1 : <NEWLINE> <INDENT> res += 1 <NEWLINE> <NL> <NL> <DEDENT> cArray = Counter ( resArray ) <NEWLINE> <NL> for i in cArray . values ( ) : <NEWLINE> <INDENT> if i > 0 : <NEWLINE> <NL> <INDENT> tmp = 1 <NEWLINE> while tmp * ( tmp + 1 ) // 2 <= i : <NEWLINE> <INDENT> tmp += 1 <NEWLINE> <DEDENT> res += tmp - 1 <NEWLINE> <DEDENT> <DEDENT> print ( res ) <NEWLINE>
arr = [ ] <NEWLINE> temp = n <NEWLINE> for i in range ( 2 , int ( - ( - n ** 0.5 // 1 ) ) + 1 ) : <NEWLINE> <INDENT> if temp % i == 0 : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> while temp % i == 0 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> temp //= i <NEWLINE> <DEDENT> arr . append ( [ i , cnt ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> if temp != 1 : <NEWLINE> <INDENT> arr . append ( [ temp , 1 ] ) <NEWLINE> <NL> <DEDENT> if arr == [ ] : <NEWLINE> <INDENT> arr . append ( [ n , 1 ] ) <NEWLINE> <NL> <DEDENT> if arr == [ [ 1 , 1 ] ] : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <COMMENT> <NL> <INDENT> total = 0 <NEWLINE> for i in range ( len ( arr ) ) : <NEWLINE> <INDENT> x = 1 <NEWLINE> s = 0 <NEWLINE> c = - 1 <NEWLINE> while s <= arr [ i ] [ 1 ] : <NEWLINE> <INDENT> s += x <NEWLINE> x += 1 <NEWLINE> c += 1 <NEWLINE> <DEDENT> total += c <NEWLINE> <DEDENT> print ( total ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> b = n <NEWLINE> def pf ( n ) : <NEWLINE> <INDENT> a = [ ] <NEWLINE> while n % 2 == 0 : <NEWLINE> <INDENT> a . append ( 2 ) <NEWLINE> n //= 2 <NEWLINE> <DEDENT> f = 3 <NEWLINE> while f * f <= n : <NEWLINE> <INDENT> if n % f == 0 : <NEWLINE> <INDENT> a . append ( f ) <NEWLINE> n //= f <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> f += 2 <NEWLINE> <DEDENT> <DEDENT> if n != 1 : <NEWLINE> <INDENT> a . append ( n ) <NEWLINE> <DEDENT> return a <NEWLINE> <DEDENT> l = list ( set ( pf ( n ) ) ) <NEWLINE> cnt = 0 <NEWLINE> for i in l : <NEWLINE> <INDENT> n = b <NEWLINE> t = 1 <NEWLINE> j = i <NEWLINE> while i <= n : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> n = n // i <NEWLINE> a . append ( i ) <NEWLINE> <DEDENT> i *= j <NEWLINE> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
from collections import Counter <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> <NL> def prime ( n ) : <NEWLINE> <INDENT> a = [ ] <NEWLINE> while n % 2 == 0 : <NEWLINE> <INDENT> a . append ( 2 ) <NEWLINE> n //= 2 <NEWLINE> <DEDENT> f = 3 <NEWLINE> while f * f <= n : <NEWLINE> <INDENT> if n % f == 0 : <NEWLINE> <INDENT> a . append ( f ) <NEWLINE> n //= f <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> f += 2 <NEWLINE> <DEDENT> <DEDENT> if n != 1 : <NEWLINE> <INDENT> a . append ( n ) <NEWLINE> <DEDENT> return a <NEWLINE> <NL> <DEDENT> c = Counter ( prime ( N ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> for i in c . values ( ) : <NEWLINE> <INDENT> if i > 0 : <NEWLINE> <INDENT> a = 0 <NEWLINE> for j in range ( 1 , cnt + 1 ) : <NEWLINE> <INDENT> a += j <NEWLINE> if a > cnt : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> b += 1 <NEWLINE> <DEDENT> ans += b <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<NL> def q4 ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> arr = prime_factorize ( N ) <NEWLINE> if not arr : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> ans_count = 0 <NEWLINE> count = 1 <NEWLINE> <NL> min_val = min ( arr ) <NEWLINE> while arr : <NEWLINE> <INDENT> if arr . count ( min_val ) < count : <NEWLINE> <INDENT> arr = list ( filter ( lambda a : a != min_val , arr ) ) <NEWLINE> count = 1 <NEWLINE> if not arr : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> min_val = min ( arr ) <NEWLINE> continue <NEWLINE> <DEDENT> arr = arr [ count : ] <NEWLINE> ans_count += 1 <NEWLINE> count += 1 <NEWLINE> <DEDENT> print ( ans_count ) <NEWLINE> <NL> <NL> <DEDENT> q4 ( ) <NEWLINE>
from collections import Counter <NEWLINE> <NL> def prime_factorize ( n ) : <NEWLINE> <INDENT> a = [ ] <NEWLINE> while n % 2 == 0 : <NEWLINE> <INDENT> a . append ( 2 ) <NEWLINE> n //= 2 <NEWLINE> <DEDENT> f = 3 <NEWLINE> while f * f <= n : <NEWLINE> <INDENT> if n % f == 0 : <NEWLINE> <INDENT> a . append ( f ) <NEWLINE> n //= f <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> f += 2 <NEWLINE> <DEDENT> <DEDENT> if n != 1 : <NEWLINE> <INDENT> a . append ( n ) <NEWLINE> <DEDENT> return a <NEWLINE> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> print ( len ( Counter ( n ) ) ) <NEWLINE>
def factorization ( n ) : <NEWLINE> <INDENT> arr = [ ] <NEWLINE> temp = n <NEWLINE> for i in range ( 2 , int ( - ( - n ** 0.5 // 1 ) ) + 1 ) : <NEWLINE> <INDENT> if temp % i == 0 : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> while temp % i == 0 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> temp //= i <NEWLINE> <DEDENT> arr . append ( [ i , cnt ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> if temp != 1 : <NEWLINE> <INDENT> arr . append ( [ temp , 1 ] ) <NEWLINE> <NL> <DEDENT> if arr == [ ] : <NEWLINE> <INDENT> arr . append ( [ n , 1 ] ) <NEWLINE> <NL> <DEDENT> return arr <NEWLINE> <NL> <DEDENT> A = factorization ( N ) <NEWLINE> <NL> count = 0 <NEWLINE> for i in A : <NEWLINE> <INDENT> judge = 1 <NEWLINE> temp = i [ 1 ] <NEWLINE> while temp >= judge : <NEWLINE> <INDENT> count += 1 <NEWLINE> temp -= judge <NEWLINE> judge += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if N == 1 : <NEWLINE> <INDENT> count = 0 <NEWLINE> <NL> <DEDENT> print ( count ) <NEWLINE>
import sys <NEWLINE> <NL> if sys . platform == <STRING> : <NEWLINE> <INDENT> sys . stdin = open ( <STRING> ) <NEWLINE> <NL> <DEDENT> read = sys . stdin . buffer . read <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> readlines = sys . stdin . buffer . readlines <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> <NL> def factorization ( n ) : <NEWLINE> <INDENT> arr = [ ] <NEWLINE> temp = n <NEWLINE> for i in range ( 2 , int ( - ( - n ** 0.5 // 1 ) ) + 1 ) : <NEWLINE> <INDENT> if temp % i == 0 : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> while temp % i == 0 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> temp //= i <NEWLINE> <DEDENT> arr . append ( [ i , cnt ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> if temp != 1 : <NEWLINE> <INDENT> arr . append ( [ temp , 1 ] ) <NEWLINE> <NL> <DEDENT> if arr == [ ] : <NEWLINE> <INDENT> arr . append ( [ n , 1 ] ) <NEWLINE> <NL> <DEDENT> return arr <NEWLINE> <NL> <DEDENT> a = factorization ( n ) <NEWLINE> le = len ( a ) <NEWLINE> cnt = 0 <NEWLINE> b = 0 <NEWLINE> for i in range ( le ) : <NEWLINE> <INDENT> b = 1 <NEWLINE> while a [ i ] [ 1 ] >= b : <NEWLINE> <INDENT> a [ i ] [ 1 ] -= b <NEWLINE> b += 1 <NEWLINE> cnt += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if n = 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( cnt ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <INDENT> from collections import Counter <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> if <STRING> in globals ( ) : <NEWLINE> <COMMENT> <NL> <INDENT> n = 64 <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <COMMENT> <NL> <INDENT> n = input ( ) <NEWLINE> <COMMENT> <NL> <NL> <COMMENT> <NL> <DEDENT> def prime_fact ( n ) : <NEWLINE> <INDENT> P = [ ] <NEWLINE> for i in range ( 2 , int ( n ** 0.5 ) + 1 ) : <NEWLINE> <INDENT> while n % i == 0 : <NEWLINE> <INDENT> P . append ( i ) <NEWLINE> n //= i <NEWLINE> <DEDENT> <DEDENT> if n != 1 : <NEWLINE> <INDENT> P . append ( n ) <NEWLINE> <DEDENT> return P <NEWLINE> <NL> <DEDENT> cnt = Counter ( prime_fact ( n ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> for c in cnt . values ( ) : <NEWLINE> <INDENT> tmp = 1 <NEWLINE> while c >= tmp : <NEWLINE> <INDENT> c -= tmp <NEWLINE> ans += 1 <NEWLINE> tmp += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE>
<NL> def resolve ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> prime_factors = factorization ( N ) <NEWLINE> tri_dict = { <NEWLINE> <INDENT> 1 : 1 , <NEWLINE> 2 : 1 , <NEWLINE> 3 : 2 , <NEWLINE> 4 : 2 , <NEWLINE> 5 : 2 , <NEWLINE> 6 : 3 , <NEWLINE> 7 : 3 , <NEWLINE> 8 : 3 , <NEWLINE> 9 : 3 , <NEWLINE> 10 : 4 , <NEWLINE> 11 : 4 , <NEWLINE> 12 : 4 , <NEWLINE> 13 : 4 , <NEWLINE> 14 : 4 , <NEWLINE> 15 : 5 , <NEWLINE> 16 : 5 , <NEWLINE> 17 : 5 , <NEWLINE> 18 : 5 , <NEWLINE> 19 : 5 , <NEWLINE> 20 : 5 , <NEWLINE> 21 : 6 , <NEWLINE> 22 : 6 , <NEWLINE> 23 : 6 , <NEWLINE> 24 : 6 , <NEWLINE> 25 : 6 , <NEWLINE> 26 : 6 , <NEWLINE> 27 : 6 , <NEWLINE> 28 : 7 , <NEWLINE> 29 : 7 , <NEWLINE> 30 : 7 , <NEWLINE> 31 : 7 , <NEWLINE> 32 : 7 , <NEWLINE> 33 : 7 , <NEWLINE> 34 : 7 , <NEWLINE> 35 : 7 , <NEWLINE> 36 : 8 , <NEWLINE> 37 : 8 , <NEWLINE> 38 : 8 , <NEWLINE> 39 : 8 , <NEWLINE> 40 : 8 <NEWLINE> <DEDENT> } <NEWLINE> result = 0 <NEWLINE> <NL> for prime_factor in prime_factors : <NEWLINE> <INDENT> if prime_factor [ 0 ] > 1 : <NEWLINE> <INDENT> result += tri_dict [ prime_factor [ 1 ] ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( result ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> resolve ( ) <NEWLINE> <DEDENT>
def factorization ( n ) : <NEWLINE> <INDENT> arr = [ ] <NEWLINE> for i in range ( 2 , int ( - ( - n ** 0.5 // 1 ) ) + 1 ) : <NEWLINE> <INDENT> if temp % i == 0 : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> while temp % i == 0 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> temp //= i <NEWLINE> <DEDENT> arr . append ( [ i , cnt ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> if temp != 1 : <NEWLINE> <INDENT> arr . append ( [ temp , 1 ] ) <NEWLINE> <NL> <DEDENT> return arr <NEWLINE> <DEDENT> N = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> if N != 1 : <NEWLINE> <INDENT> fact_list = factorization ( N ) <NEWLINE> for _ , i in fact_list : <NEWLINE> <INDENT> j = 1 <NEWLINE> while i >= j : <NEWLINE> <INDENT> ans += 1 <NEWLINE> i = i - j <NEWLINE> j += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> A = [ ] <NEWLINE> B = [ ] <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> A . append ( a ) <NEWLINE> B . append ( b ) <NEWLINE> <NL> <DEDENT> A = sorted ( A ) <NEWLINE> B = sorted ( B ) <NEWLINE> <NL> if n % 2 == 0 : <NEWLINE> <INDENT> i = n // 2 <NEWLINE> print ( ( B [ i ] + B [ i - 1 ] ) - ( A [ i ] + A [ i - 1 ] ) + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> i = ( n + 1 ) // 2 - 1 <NEWLINE> print ( B [ i ] - A [ i ] + 1 ) <NEWLINE> <DEDENT>
def prime_factorize ( n ) : <NEWLINE> <INDENT> a = [ ] <NEWLINE> while n % 2 == 0 : <NEWLINE> <INDENT> a . append ( 2 ) <NEWLINE> n //= 2 <NEWLINE> <DEDENT> f = 3 <NEWLINE> while f * f <= n : <NEWLINE> <INDENT> if n % f == 0 : <NEWLINE> <INDENT> a . append ( f ) <NEWLINE> n //= f <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> f += 2 <NEWLINE> <DEDENT> <DEDENT> if n != 1 : <NEWLINE> <INDENT> a . append ( n ) <NEWLINE> <DEDENT> return a <NEWLINE> <DEDENT> n = int ( input ( ) ) <NEWLINE> if n == 1 : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a = prime_factorize ( n ) <NEWLINE> if a == [ ] : <NEWLINE> <INDENT> ans = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = 0 <NEWLINE> xzen = a [ 0 ] <NEWLINE> count = 1 <NEWLINE> ans += 1 <NEWLINE> for x in range ( 1 , len ( a ) ) : <NEWLINE> <INDENT> if xzen == a [ x ] : <NEWLINE> <INDENT> count += 1 <NEWLINE> if count == 3 or count == 6 or count == 10 or count == 15 or count == 21 or count == 28 or or count == 35 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> xzen = a [ x ] <NEWLINE> count = 1 <NEWLINE> ans += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<NL> def prime_decomposition ( n ) : <NEWLINE> <INDENT> i = 2 <NEWLINE> table = [ ] <NEWLINE> while i * i <= n : <NEWLINE> <INDENT> while n % i == 0 : <NEWLINE> <INDENT> n //= i <NEWLINE> table . append ( i ) <NEWLINE> <DEDENT> i += 1 <NEWLINE> <DEDENT> if n > 1 : <NEWLINE> <INDENT> table . append ( n ) <NEWLINE> <DEDENT> return table <NEWLINE> <NL> <DEDENT> from itertools import groupby <NEWLINE> N = int ( input ( ) ) <NEWLINE> P = prime_decomposition ( N ) <NEWLINE> ans = 0 <NEWLINE> for k , g in groupby ( P ) : <NEWLINE> <INDENT> n = len ( g ) <NEWLINE> for i in range ( 1 , 10000000 ) : <NEWLINE> <INDENT> n -= i <NEWLINE> if n >= 0 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL>
m = int ( input ( ) ) <NEWLINE> def factorization ( n ) : <NEWLINE> <INDENT> arr = [ ] <NEWLINE> temp = n <NEWLINE> for i in range ( 2 , int ( - ( - n ** 0.5 // 1 ) ) + 1 ) : <NEWLINE> <INDENT> if temp % i == 0 : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> while temp % i == 0 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> temp //= i <NEWLINE> <DEDENT> arr . append ( [ i , cnt ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> if temp != 1 : <NEWLINE> <INDENT> arr . append ( [ temp , 1 ] ) <NEWLINE> <NL> <DEDENT> if arr == [ ] : <NEWLINE> <INDENT> arr . append ( [ n , 1 ] ) <NEWLINE> <NL> <DEDENT> return arr <NEWLINE> <NL> <DEDENT> l = factorization ( m ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( len ( l ) ) : <NEWLINE> <INDENT> a = 1 <NEWLINE> while ( l [ i ] [ 1 ] >= a ) : <NEWLINE> <INDENT> ans += 1 <NEWLINE> l [ i ] [ 1 ] -= a <NEWLINE> a += 1 <NEWLINE> <DEDENT> <DEDENT> if m = 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
def resolve ( ) : <NEWLINE> <INDENT> li = input ( ) . split ( ) <NEWLINE> A = int ( li [ 0 ] ) <NEWLINE> B = int ( li [ 1 ] . replace ( <STRING> , <STRING> ) ) <NEWLINE> ans = int ( A * B / 100 ) <NEWLINE> print ( ans ) <NEWLINE> <DEDENT> resolve ( ) <NEWLINE>
import collections <NEWLINE> <NL> def prime_factorize ( n ) : <NEWLINE> <INDENT> a = [ ] <NEWLINE> while n % 2 == 0 : <NEWLINE> <INDENT> a . append ( 2 ) <NEWLINE> n //= 2 <NEWLINE> <DEDENT> f = 3 <NEWLINE> while f * f <= n : <NEWLINE> <INDENT> if n % f == 0 : <NEWLINE> <INDENT> a . append ( f ) <NEWLINE> n //= f <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> f += 2 <NEWLINE> <DEDENT> <DEDENT> if n != 1 : <NEWLINE> <INDENT> a . append ( n ) <NEWLINE> <DEDENT> return a <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> count = 0 <NEWLINE> counter = collections . Counter ( prime_factorize ( N ) ) <NEWLINE> output = 0 <NEWLINE> for prime in counter : <NEWLINE> <INDENT> num_prime = 1 <NEWLINE> count = 1 <NEWLINE> while True : <NEWLINE> <INDENT> if counter [ prime ] >= wa : <NEWLINE> <INDENT> output += 1 <NEWLINE> count += 1 <NEWLINE> num_prime += count <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( output ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> if n == 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> return <NEWLINE> <DEDENT> def eratos ( n ) : <NEWLINE> <INDENT> flag = [ True ] * ( n + 1 ) <NEWLINE> for i in range ( 2 , int ( n ** 0.5 ) + 1 ) : <NEWLINE> <INDENT> if flag [ i ] : <NEWLINE> <INDENT> for j in range ( 2 * i , n + 1 , i ) : <NEWLINE> <INDENT> flag [ j ] = False <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return [ i for i , x in enumerate ( flag ) if x and i >= 2 ] <NEWLINE> <DEDENT> p = eratos ( 10 ** 6 ) <NEWLINE> work = [ ] <NEWLINE> for i in p : <NEWLINE> <INDENT> piyo = 0 <NEWLINE> while n % i == 0 : <NEWLINE> <INDENT> n //= i <NEWLINE> piyo += 1 <NEWLINE> <DEDENT> if piyo > 0 : <NEWLINE> <INDENT> work . append ( piyo ) <NEWLINE> <DEDENT> if n == 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> if len ( work ) == 0 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> result = 0 <NEWLINE> for i in work : <NEWLINE> <INDENT> for j in range ( 1 , 10 ** 6 ) : <NEWLINE> <INDENT> i -= j <NEWLINE> if i < 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> result += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if n != 1 : <NEWLINE> <INDENT> result += 1 <NEWLINE> <DEDENT> print ( result ) <NEWLINE> <DEDENT> main ( ) <NEWLINE>
from decimal import * <NEWLINE> import math <NEWLINE> A , B = input ( ) . split ( ) <NEWLINE> A = Decimal ( float ( A ) ) <NEWLINE> B = Decimal ( float ( B ) ) <NEWLINE> print ( math . floor ( A * B ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> aList = [ ] <NEWLINE> bList = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> aList . append ( a ) <NEWLINE> bList . append ( b ) <NEWLINE> <NL> <DEDENT> aList . sort ( ) <NEWLINE> bList . sort ( ) <NEWLINE> <NL> half = n // 2 <NEWLINE> if not n % 2 == 0 : <NEWLINE> <INDENT> print ( bList [ half ] - aList [ half ] + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( bList [ half ] + bList [ half + 1 ] - aList [ half ] + aList [ half + 1 ] + 1 ) <NEWLINE> <NL> <DEDENT>
import numpy as np <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = np . zeros ( N ) <NEWLINE> B = np . zeros ( N ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> A [ i ] , B [ i ] = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <DEDENT> am = np . median ( A ) <NEWLINE> bm = np . median ( B ) <NEWLINE> <NL> if n % 2 == 0 : <NEWLINE> <INDENT> print ( int ( ( bm - am ) * 2 + 1 ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( int ( ( bm - am ) + 1 ) ) <NEWLINE> <DEDENT>
import sys <NEWLINE> def input ( ) : return sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> def main ( ) : <NEWLINE> <INDENT> h , w , k = map ( int , input ( ) . split ( ) ) <NEWLINE> S = [ input ( ) for _ in range ( h ) ] <NEWLINE> final_ans = 10 ** 10 <NEWLINE> for row_lis in range ( 1 << ( h - 1 ) ) : <NEWLINE> <INDENT> lst = [ 0 ] * h <NEWLINE> q , ans = 0 , 0 <NEWLINE> for r in range ( h - 1 ) : <NEWLINE> <INDENT> if ( row_lis >> r ) & 1 == 0 : <NEWLINE> <INDENT> lst [ r + 1 ] = q <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> q += 1 <NEWLINE> lst [ r + 1 ] = q <NEWLINE> ans += 1 <NEWLINE> <DEDENT> <DEDENT> data = [ 0 ] * h <NEWLINE> for j in range ( w ) : <NEWLINE> <INDENT> for i in range ( h ) : <NEWLINE> <INDENT> data [ lst [ i ] ] += int ( S [ i ] [ j ] ) <NEWLINE> if data [ lst [ i ] ] > k : <NEWLINE> <INDENT> ans += 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> data = [ 0 ] * h <NEWLINE> for i in range ( h ) : <NEWLINE> <INDENT> data [ lst [ i ] ] += int ( S [ i ] [ j ] ) <NEWLINE> if data [ lst [ i ] ] > k : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> final_ans = min ( final_ans , ans ) <NEWLINE> <DEDENT> <DEDENT> print ( final_ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> A = [ ] <NEWLINE> B = [ ] <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> a , b = tuple ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A . append ( a ) <NEWLINE> B . append ( b ) <NEWLINE> <NL> <DEDENT> A = sorted ( A ) <NEWLINE> B = sorted ( B ) <NEWLINE> <NL> if n % 2 == 1 : <NEWLINE> <INDENT> sa = AB_A [ n // 2 ] <NEWLINE> lb = AB_B [ n // 2 ] <NEWLINE> print ( lb - sa + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> sal = AB_A [ n // 2 - 1 ] <NEWLINE> sar = AB_A [ n // 2 ] <NEWLINE> <NL> lbl = AB_B [ n // 2 - 1 ] <NEWLINE> lbr = AB_B [ n // 2 ] <NEWLINE> print ( ( lbl + lbr ) - ( sal + sar ) + 1 ) <NEWLINE> <DEDENT>
a , b = input ( ) . split ( ) <NEWLINE> print ( int ( a ) * int ( float ( b ) * 100 ) // 100 ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = [ ] <NEWLINE> b = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> tmpa , tmpb = map ( int , input ( ) . split ( ) ) <NEWLINE> a . append ( tmpa ) <NEWLINE> b . append ( tmpb ) <NEWLINE> <NL> <DEDENT> a . sort ( ) <NEWLINE> b . sort ( ) <NEWLINE> <NL> if n % 2 == 1 : <NEWLINE> <INDENT> print ( b [ n // 2 ] - a [ n // 2 ] + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ( b [ n // 2 + 2 ] - b [ n // 2 + 1 ] ) - ( a [ n // 2 + 2 ] - a [ n // 2 + 1 ] ) + 1 ) <NEWLINE> <DEDENT>
import sys , re <NEWLINE> from collections import deque , defaultdict , Counter <NEWLINE> from math import ceil , sqrt , hypot , factorial , pi , sin , cos , radians , gcd <NEWLINE> from itertools import accumulate , permutations , combinations , product , groupby , combinations_with_replacement <NEWLINE> from operator import itemgetter , mul <NEWLINE> from copy import deepcopy <NEWLINE> from string import ascii_lowercase , ascii_uppercase , digits <NEWLINE> from bisect import bisect , bisect_left <NEWLINE> from heapq import heappush , heappop <NEWLINE> from functools import reduce <NEWLINE> def input ( ) : return sys . stdin . readline ( ) . strip ( ) <NEWLINE> def INT ( ) : return int ( input ( ) ) <NEWLINE> def MAP ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def LIST ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> def ZIP ( n ) : return zip ( * ( MAP ( ) for _ in range ( n ) ) ) <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> INF = float ( <STRING> ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> N = INT ( ) <NEWLINE> A , B = ZIP ( N ) <NEWLINE> A . sort ( ) <NEWLINE> B . sort ( ) <NEWLINE> if N % 2 == 0 : <NEWLINE> <INDENT> l = ( A [ N // 2 ] + A [ N // 2 - 1 ] ) <NEWLINE> r = ( B [ N // 2 ] + B [ N // 2 - 1 ] ) <NEWLINE> print ( r - l + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( B [ N // 2 ] - A [ N // 2 ] + 1 ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = [ None ] * N <NEWLINE> B = [ None ] * N <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> A [ i ] = a <NEWLINE> B [ i ] = b <NEWLINE> A . sort ( ) <NEWLINE> B . sort ( ) <NEWLINE> <NL> if N % 2 == 0 : <NEWLINE> <INDENT> x = A [ N // 2 - 1 ] <NEWLINE> y = B [ N // 2 ] <NEWLINE> else : <NEWLINE> <INDENT> x = A [ N // 2 ] <NEWLINE> y = B [ N // 2 ] <NEWLINE> print ( y - x + 1 ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
from decimal import Decimal <NEWLINE> <NL> N = Decimal ( input ( ) ) <NEWLINE> t = N // 2 <NEWLINE> a_list = [ ] <NEWLINE> b_list = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> ab = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a_list . append ( ab [ 0 ] ) <NEWLINE> b_list . append ( ab [ 1 ] ) <NEWLINE> <NL> <DEDENT> if N % 2 == 1 : <NEWLINE> <INDENT> a_median = a_list [ t ] <NEWLINE> b_median = b_list [ t ] <NEWLINE> print ( b_median - a_median + 1 ) <NEWLINE> <DEDENT> elif N % 2 == 0 : <NEWLINE> <INDENT> a_median = ( a_list [ t - 1 ] + a_list [ t ] ) / 2 <NEWLINE> b_median = ( b_list [ t - 1 ] + b_list [ t ] ) / 2 <NEWLINE> print ( int ( 2 * ( b_median - a_median ) + 1 ) ) <NEWLINE> <DEDENT>
n = input ( ) <NEWLINE> A = [ ] <NEWLINE> B = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> A . append ( a ) <NEWLINE> B . append ( b ) <NEWLINE> <DEDENT> A . sort ( ) <NEWLINE> B . sort ( ) <NEWLINE> j = n // 2 <NEWLINE> if n % 2 == 0 : <NEWLINE> <INDENT> print ( ( B [ j ] + B [ j + 1 ] ) - ( A [ j ] + A [ j + 1 ] ) + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( B [ j ] - A [ j ] + 1 ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = [ ] <NEWLINE> B = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> A . append ( a ) <NEWLINE> B . append ( b ) <NEWLINE> <NL> <DEDENT> A . sort ( ) <NEWLINE> B . sort ( ) <NEWLINE> <NL> if N % 2 == 1 : <NEWLINE> <INDENT> print ( B [ N // 2 ] [ 1 ] - A [ N // 2 ] [ 0 ] + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> r = ( B [ N // 2 - 1 ] [ 1 ] + B [ N // 2 ] [ 1 ] ) <NEWLINE> l = ( A [ N // 2 - 1 ] [ 0 ] + A [ N // 2 ] [ 0 ] ) <NEWLINE> print ( r - l + 1 ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> INT = lambda : int ( input ( ) ) <NEWLINE> INTM = lambda : map ( int , input ( ) . split ( ) ) <NEWLINE> STRM = lambda : map ( str , input ( ) . split ( ) ) <NEWLINE> STR = lambda : str ( input ( ) ) <NEWLINE> LIST = lambda : list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> LISTS = lambda : list ( map ( str , input ( ) . split ( ) ) ) <NEWLINE> <NL> def do ( ) : <NEWLINE> <INDENT> n = INT ( ) <NEWLINE> A = [ ] <NEWLINE> B = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a , b = INTM ( ) <NEWLINE> A . append ( a ) <NEWLINE> B . append ( b ) <NEWLINE> B = sorted ( B , reverse = True ) <NEWLINE> <DEDENT> if n % 2 == 1 : <NEWLINE> <INDENT> ta = A [ n // 2 ] <NEWLINE> tb = B [ n // 2 ] <NEWLINE> print ( tb - ta + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ta1 = A [ n // 2 ] <NEWLINE> ta2 = A [ n // 2 + 1 ] <NEWLINE> tb1 = B [ n // 2 ] <NEWLINE> tb2 = B [ n // 2 + 1 ] <NEWLINE> avea = ( ta1 + ta2 ) / 2 <NEWLINE> aveb = ( tb1 + tb2 ) / 2 <NEWLINE> print ( int ( ( aveb - avea ) * 2 ) + 1 ) <NEWLINE> <NL> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> do ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> import statistics . median ( ) <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> <NL> a = [ ] <NEWLINE> b = [ ] <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> a , b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a . append ( a ) <NEWLINE> b . append ( b ) <NEWLINE> <NL> <DEDENT> a_median = statistics . median ( a ) <NEWLINE> b_median = statistics . median ( b ) <NEWLINE> <NL> if n % 2 == 0 : <NEWLINE> <INDENT> print ( b_median - a_median + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( b_median * 2 - a_median * 2 + 1 ) <NEWLINE> <NL> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = [ ] <NEWLINE> B = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> a , b = map ( input ( ) . split ( ) ) <NEWLINE> A . append ( a ) <NEWLINE> B . append ( b ) <NEWLINE> <NL> <DEDENT> A = sorted ( A ) <NEWLINE> B = sorted ( B ) <NEWLINE> <NL> if N % 2 == 1 : <NEWLINE> <INDENT> print ( B [ N // 2 ] - A [ N // 2 ] + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ( B [ N // 2 - 1 ] + B [ N // 2 ] ) - ( A [ N // 2 - 1 ] + A [ N // 2 ] ) + 1 ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> N = 10 ** 9 <NEWLINE> x = [ 0 ] * ( N + 1 ) <NEWLINE> x1 = [ 0 ] * N <NEWLINE> x2 = [ 0 ] * N <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> x [ a - 1 ] += 1 <NEWLINE> x [ b ] -= 1 <NEWLINE> <NL> <DEDENT> for i in range ( 1 , N ) : <NEWLINE> <INDENT> x [ i ] = x [ i ] + x [ i - 1 ] <NEWLINE> <NL> <DEDENT> for i in range ( 1 , N ) : <NEWLINE> <INDENT> x1 [ i ] = x1 [ i ] + x1 [ i - 1 ] <NEWLINE> <NL> <DEDENT> x . reverse ( ) <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> x2 [ i ] = x2 [ i ] + x2 [ i - 1 ] <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> if n % 2 == 1 : <NEWLINE> <INDENT> for i in range ( N ) : <NEWLINE> <INDENT> if x1 [ i ] + x2 [ i ] > n // 2 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( N ) : <NEWLINE> <INDENT> if x1 [ i ] + x2 [ i ] > n // 2 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans * 2 + 1 ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( ) <NEWLINE> B = list ( ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> A . append ( a ) <NEWLINE> B . append ( b ) <NEWLINE> <NL> <DEDENT> A . sort ( ) <NEWLINE> B . sort ( ) <NEWLINE> <NL> if ( N % 2 == 1 ) : <NEWLINE> <INDENT> x = A [ ( N - 1 ) // 2 ] <NEWLINE> y = B [ ( N - 1 ) // 2 ] <NEWLINE> print ( y - x + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = A [ ( N // 2 ) + 1 ] + A [ N // 2 ] <NEWLINE> y = B [ ( N // 2 ) + 1 ] + B [ N // 2 ] <NEWLINE> print ( y - x + 1 ) <NEWLINE> <DEDENT>
from sys import stdin <NEWLINE> from decimal import Decimal <NEWLINE> N = int ( stdin . readline ( ) . rstrip ( ) ) <NEWLINE> A = [ ] <NEWLINE> B = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> a , b = [ int ( x ) for x in stdin . readline ( ) . rstrip ( ) . split ( ) ] <NEWLINE> A . append ( a ) <NEWLINE> B . append ( b ) <NEWLINE> <NL> <DEDENT> A . sort ( ) <NEWLINE> B . sort ( ) <NEWLINE> if N % 2 == 0 : <NEWLINE> <INDENT> C = A + B <NEWLINE> C . sort ( ) <NEWLINE> ans = 2 * sum ( C [ : : - 1 ] [ : N ] ) - 2 * sum ( C [ : N ] ) <NEWLINE> print ( ans // 2 + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = B [ N // 2 ] - A [ N // 2 ] + 1 <NEWLINE> print ( ans <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A , B = [ ] , [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> tm , p = map ( int , input ( ) . split ( ) ) <NEWLINE> A . append ( tm ) , B . append ( p ) <NEWLINE> <DEDENT> A . sort ( ) , B . sort ( ) <NEWLINE> <NL> a = A [ N // 2 ] * 2 if N % 2 == 1 else A [ N // 2 ] + A [ N // 2 + 1 ] <NEWLINE> b = B [ N // 2 ] * 2 if N % 2 == 1 else B [ N // 2 ] + B [ N // 2 + 1 ] <NEWLINE> print ( ( b - a ) // 2 + 1 ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> import math <NEWLINE> import numpy as np <NEWLINE> <NL> if __name__ == <STRING> : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> A = [ ] <NEWLINE> B = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> t = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A . append ( t [ 0 ] ) <NEWLINE> B . append ( t [ 1 ] ) <NEWLINE> <DEDENT> A . sort ( ) <NEWLINE> B . sort ( ) <NEWLINE> <NL> a = 0 <NEWLINE> if N % 2 == 0 : <NEWLINE> <INDENT> i = N // 2 <NEWLINE> j = N // 2 - 1 <NEWLINE> a = AB [ j ] [ 0 ] + AB [ i ] [ 0 ] <NEWLINE> b = AB [ j ] [ 1 ] + AB [ i ] [ 1 ] <NEWLINE> print ( b - a + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> i = N // 2 <NEWLINE> a = AB [ i ] [ 1 ] - AB [ i ] [ 0 ] + 1 <NEWLINE> <NL> print ( a ) <NEWLINE> <NL> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = [ ] <NEWLINE> b = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a [ i ] , b [ i ] = map ( int , input ( ) . split ( ) ) <NEWLINE> <DEDENT> a . sort ( ) <NEWLINE> b . sort ( ) <NEWLINE> if n % 2 == 1 : <NEWLINE> <INDENT> print ( b [ ( n + 1 ) // 2 ] - a [ ( n + 1 ) // 2 ] + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( b [ n // 2 ] - a [ n // 2 ] + b [ n // 2 + 1 ] - a [ n // 2 + 1 ] + 1 ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> listA = [ 0 ] * N <NEWLINE> listB = [ 0 ] * N <NEWLINE> idx = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> listA [ idx ] , listB [ idx ] = map ( int , input ( ) . split ( ) ) <NEWLINE> idx += 1 <NEWLINE> <NL> <DEDENT> medianA = 0 <NEWLINE> medianB = 0 <NEWLINE> ans = 0 <NEWLINE> if N % 2 == 0 : <NEWLINE> <INDENT> medianA = statistics . median ( listA ) <NEWLINE> medianB = statistics . median ( listB ) <NEWLINE> ans = ( medianB - medianA ) * 2 + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> medianA = statistics . median ( listA ) <NEWLINE> medianB = statistics . median ( listB ) <NEWLINE> ans = medianB - medianA + 1 <NEWLINE> <NL> <DEDENT> print ( int ( ans ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> lower = [ ] <NEWLINE> upper = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> lower . append ( a ) <NEWLINE> upper . append ( b ) <NEWLINE> <DEDENT> lower . sort ( ) <NEWLINE> upper . sort ( ) <NEWLINE> if N % 2 == 1 : <NEWLINE> <INDENT> print ( upper [ ( N + 1 ) // 2 ] - lower [ ( N + 1 ) // 2 ] + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( upper [ N // 2 + 1 ] + upper [ N // 2 ] - lower [ N // 2 + 1 ] - lower [ N // 2 ] + 1 ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> s = [ ] <NEWLINE> zyogen = [ ] <NEWLINE> kagen = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> k , z = map ( int , input ( ) . split ( ) ) <NEWLINE> kagen . append ( k ) <NEWLINE> zyogen . append ( z ) <NEWLINE> <NL> <DEDENT> kk = sorted ( kagen ) <NEWLINE> zz = sorted ( zyogen ) <NEWLINE> if ( n % 2 == 0 ) : <NEWLINE> <INDENT> aa = n // 2 <NEWLINE> x = kk [ aa - 1 ] + kk [ a ] <NEWLINE> y = zz [ aa - 1 ] + zz [ a ] <NEWLINE> print ( y - x + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> aa = n // 2 <NEWLINE> x = kk [ aa ] <NEWLINE> y = zz [ aa ] <NEWLINE> print ( y - x + 1 ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> ab = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ] <NEWLINE> ab . sort ( ) <NEWLINE> l = ab [ ( n + 1 ) // 2 - 1 ] [ 0 ] <NEWLINE> ab . sort ( key = lambda x : x [ 1 ] , reverse = True ) <NEWLINE> r = ab [ ( n + 1 ) // 2 - 1 ] [ 1 ] <NEWLINE> <NL> if n % 2 == 0 : <NEWLINE> <INDENT> print ( 1 / 0 ) <NEWLINE> <DEDENT> print ( r - l + 1 ) <NEWLINE>
import math <NEWLINE> <NL> <NL> def median ( array ) : <NEWLINE> <INDENT> if N % 2 : <NEWLINE> <INDENT> return array [ N // 2 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return sum ( array [ N // 2 - 1 : N // 2 + 1 ] ) / 2 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> N = int ( input ( ) ) <NEWLINE> A , B = [ ] , [ ] <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> A . append ( a ) <NEWLINE> B . append ( b ) <NEWLINE> <DEDENT> x = median ( A ) <NEWLINE> y = median ( B ) <NEWLINE> if N % 2 : <NEWLINE> <INDENT> print ( y - x + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> temp = math . ceil ( y ) - math . floor ( x ) <NEWLINE> print ( 2 * temp + 1 ) ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> <NL> mins = [ 0 ] * n <NEWLINE> maxs = [ 0 ] * n <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> mins [ i ] = a <NEWLINE> maxs [ i ] = b <NEWLINE> <NL> <DEDENT> mins = sorted ( mins ) <NEWLINE> maxs = sorted ( maxs ) <NEWLINE> <NL> if n % 2 != 0 : <NEWLINE> <INDENT> print ( maxs [ ( ( n + 1 ) // 2 ) - 1 ] - mins [ ( ( n + 1 ) // 2 ) - 1 ] + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ( ( maxs [ n // 2 ] - mins [ ( n // 2 ) - 1 ] + 1 ) * 2 ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> c = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ] <NEWLINE> c . sort ( ) <NEWLINE> q , w = c [ n // 2 ] [ 0 ] , min ( c [ n // 2 ] [ 1 ] , c [ n // 2 + 1 ] [ 1 ] ) <NEWLINE> c . sort ( key = lambda x : x [ 1 ] ) <NEWLINE> e , r = max ( c [ n // 2 ] [ 0 ] , c [ n // 2 - 1 ] [ 1 ] ) , c [ n // 2 ] [ 1 ] <NEWLINE> if n % 2 == 0 : <NEWLINE> <INDENT> print ( r - q + 1 + e - w ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( r - q + 1 ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> ab = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> ab . append ( tuple ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> <DEDENT> up = sorted ( ab , key = lambda a : a [ 0 ] , reverse = True ) <NEWLINE> down = sorted ( ab , key = lambda a : a [ 1 ] , reverse = True ) <NEWLINE> <NL> if N % 2 == 1 : <NEWLINE> <INDENT> print ( up [ N // 2 ] [ 1 ] - down [ N // 2 ] [ 0 ] + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> up2 = sorted ( ab , key = lambda a : a [ 0 ] , reverse = True ) <NEWLINE> down2 = sorted ( ab , key = lambda a : a [ 1 ] , reverse = True ) <NEWLINE> <INDENT> r = ( up [ N // 2 ] [ 1 ] + up2 [ N // 2 ] [ 1 ] ) <NEWLINE> l = ( down [ N // 2 ] [ 0 ] + down2 [ N // 2 ] [ 0 ] ) <NEWLINE> print ( r - l + 1 ) <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> <NL> <COMMENT> <NL> import math <NEWLINE> import collections <NEWLINE> <COMMENT> <NL> import bisect <NEWLINE> import itertools <NEWLINE> import fractions <NEWLINE> <COMMENT> <NL> import copy <NEWLINE> import heapq <NEWLINE> import decimal <NEWLINE> <COMMENT> <NL> import queue <NEWLINE> <NL> sys . setrecursionlimit ( 10000001 ) <NEWLINE> INF = 10 ** 16 <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> <NL> ni = lambda : int ( sys . stdin . readline ( ) ) <NEWLINE> ns = lambda : map ( int , sys . stdin . readline ( ) . split ( ) ) <NEWLINE> na = lambda : list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> <COMMENT> <NL> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> n = ni ( ) <NEWLINE> a = [ ] <NEWLINE> b = [ ] <NEWLINE> d = [ ] <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> ai , bi = ns ( ) <NEWLINE> a . append ( ai ) <NEWLINE> b . append ( bi ) <NEWLINE> d . append ( ( ai , bi ) ) <NEWLINE> <NL> <DEDENT> a . sort ( ) <NEWLINE> b . sort ( ) <NEWLINE> <NL> odd = n % 2 == 1 <NEWLINE> even = n % 2 == 0 <NEWLINE> min_choice = a [ n // 2 - even ] <NEWLINE> max_choice = b [ n // 2 ] <NEWLINE> <NL> kouho = [ ] <NEWLINE> for ai , bi in d : <NEWLINE> <INDENT> tmp = range ( max ( ai , min_choice ) , min ( bi , max_choice ) ) <NEWLINE> if len ( tmp ) > 0 : <NEWLINE> <INDENT> kouho . append ( tmp ) <NEWLINE> <NL> <DEDENT> <DEDENT> dic_even = dict ( ) <NEWLINE> dic_odd = dict ( ) <NEWLINE> <NL> for k in kouho : <NEWLINE> <INDENT> for t in k : <NEWLINE> <INDENT> dic_even [ t ] = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( len ( kouho ) ) : <NEWLINE> <INDENT> for t in kouho [ i ] : <NEWLINE> <INDENT> for j in range ( i + 1 , len ( kouho ) ) : <NEWLINE> <INDENT> for l in kouho [ j ] : <NEWLINE> <INDENT> dic_odd [ ( t + l ) / 2 ] = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> e = set ( dic_even . keys ( ) ) <NEWLINE> o = set ( dic_odd . keys ( ) ) <NEWLINE> <NL> ans = e + o <NEWLINE> print ( len ( ans ) ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( <STRING> ) ) <NEWLINE> a = [ ] <NEWLINE> b = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> cc = input ( <STRING> ) . split ( <STRING> ) <NEWLINE> a += [ int ( cc [ 0 ] ) ] <NEWLINE> b += [ int ( cc [ 1 ] ) ] <NEWLINE> <DEDENT> s = 0 <NEWLINE> a . sort ( ) <NEWLINE> b . sort ( ) <NEWLINE> if ( n % 2 == 0 ) : <NEWLINE> <INDENT> s = ( a [ n / 2 ] + a [ n / 2 - 1 ] - b [ n / 2 ] - b [ n / 2 - 1 ] ) / 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s = a [ int ( ( n - 1 ) / 2 ) ] - b [ int ( ( n - 1 ) / 2 ) ] <NEWLINE> <DEDENT> print ( - s + 1 ) <NEWLINE>
import math <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = sorted ( [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( n ) ] ) <NEWLINE> b = sorted ( a , key = lambda x : x [ 1 ] ) <NEWLINE> if n % 2 == 1 : <NEWLINE> <INDENT> print ( b [ n // 2 ] [ 1 ] - a [ n // 2 ] [ 0 ] + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ( b [ n // 2 - 1 ] [ 1 ] + b [ n // 2 ] [ 1 ] ) - ( a [ n // 2 - 1 ] [ 0 ] - a [ n // 2 ] [ 0 ] ) ) // 2 ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> la = [ ] <NEWLINE> lb = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> la . append ( a ) <NEWLINE> lb . append ( b ) <NEWLINE> <DEDENT> a = statistics . median ( la ) <NEWLINE> b = statistics . median ( lb ) <NEWLINE> if n % 2 == 1 : <NEWLINE> <INDENT> print ( b - a + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ( b - a ) * 2 - 1 ) <NEWLINE> <DEDENT>
<NL> blist . sort ( ) <NEWLINE> <COMMENT> <NL> if N % 2 == 0 : <NEWLINE> <INDENT> median1 = N / 2 <NEWLINE> median2 = N / 2 + 1 <NEWLINE> median1 = int ( median1 ) - 1 <NEWLINE> median2 = int ( median2 ) - 1 <NEWLINE> amedian = ( alist [ median1 ] + alist [ median2 ] ) / 2 <NEWLINE> bmedian = ( blist [ median1 ] + blist [ median2 ] ) / 2 <NEWLINE> print ( bmedian - amedian + 1 ) <NEWLINE> <COMMENT> <NL> <DEDENT> else : <NEWLINE> <INDENT> median = ( N + 1 ) / 2 <NEWLINE> median = int ( median ) - 1 <NEWLINE> amedian = alist [ median ] <NEWLINE> bmedian = blist [ median ] <NEWLINE> print ( ( bmedian - amedian ) * 2 + 1 ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> AB = [ int ( input ( ) . split ( ) ) for _ in range ( n ) ] <NEWLINE> <NL> A = AB [ : : 2 ] <NEWLINE> B = AB [ 1 : : 2 ] <NEWLINE> <NL> A . sort ( ) <NEWLINE> B . sort ( ) <NEWLINE> <NL> if N % 2 == 0 : <NEWLINE> <INDENT> n = N // 2 <NEWLINE> med1 = A [ n - 1 ] + A [ n ] <NEWLINE> med2 = B [ n - 1 ] + B [ n ] <NEWLINE> x = med2 - med1 + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> n = N // 2 <NEWLINE> med1 = A [ n ] <NEWLINE> med2 = B [ n ] <NEWLINE> x = med2 - med1 + 1 <NEWLINE> <NL> <DEDENT> print ( x ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = [ 0 for _ in range ( n ) ] <NEWLINE> b = a [ : ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a [ i ] , b [ i ] = map ( int , input ( ) . split ( ) ) <NEWLINE> <DEDENT> a . sort ( ) <NEWLINE> b . aort ( ) <NEWLINE> <NL> ans = 0 <NEWLINE> if n % 2 == 0 : <NEWLINE> <INDENT> l = a [ n // 2 - 1 ] + a [ n // 2 ] <NEWLINE> h = b [ n // 2 - 1 ] + b [ n // 2 ] <NEWLINE> <NL> ans += h - l + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> l = a [ n // 2 ] <NEWLINE> h = b [ n // 2 ] <NEWLINE> <NL> ans += h - l + 1 <NEWLINE> <NL> <NL> <NL> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> sys . setrecursionlimit ( 10 ** 8 ) <NEWLINE> from itertools import accumulate <NEWLINE> from itertools import permutations <NEWLINE> from itertools import combinations <NEWLINE> from collections import defaultdict <NEWLINE> from collections import Counter <NEWLINE> import fractions <NEWLINE> import math <NEWLINE> from collections import deque <NEWLINE> from bisect import bisect_left <NEWLINE> from bisect import insort_left <NEWLINE> import itertools <NEWLINE> from heapq import heapify <NEWLINE> from heapq import heappop <NEWLINE> from heapq import heappush <NEWLINE> import heapq <NEWLINE> from copy import deepcopy <NEWLINE> alf = list ( <STRING> ) <NEWLINE> ALF = list ( <STRING> ) <NEWLINE> <COMMENT> <NL> INF = float ( <STRING> ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> import numpy as np <NEWLINE> N , S = map ( int , input ( ) . split ( ) ) <NEWLINE> MOD = 998244353 <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> dp = np . zeros ( S + 1 , dtype = np . int64 ) <NEWLINE> dp [ 0 ] = 2 <NEWLINE> if A [ 0 ] <= S : <NEWLINE> <INDENT> dp [ A [ 0 ] ] = 1 <NEWLINE> <DEDENT> for i in range ( 1 , N ) : <NEWLINE> <INDENT> a = A [ i ] <NEWLINE> p = ( dp * 2 ) %= MOD <NEWLINE> if a > S : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> p [ a : ] += dp [ : - a ] <NEWLINE> <DEDENT> dp = p % MOD <NEWLINE> <DEDENT> print ( dp [ - 1 ] ) <NEWLINE> <NL> <NL> <NL> <NL> <NL>
mod = 998244353 <NEWLINE> n , s = map ( int , input ( ) . split ( ) ) <NEWLINE> dp = np . zeros ( ( n + 1 , s + 1 ) , dtype = int ) <NEWLINE> dp [ 0 , 0 ] = 1 <NEWLINE> for i , a in enumerate ( map ( int , input ( ) . split ( ) ) ) : <NEWLINE> <INDENT> dp [ i + 1 ] = dp [ i ] * 2 % mod <NEWLINE> dp [ i + 1 ] [ a : ] = ( dp [ i + 1 ] [ a : ] + dp [ i ] [ : - a ] ) % mod <NEWLINE> <DEDENT> print ( dp [ - 1 , - 1 ] ) <NEWLINE>
import numpy as np <NEWLINE> import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> n , s = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> MOD = 998244353 <NEWLINE> <NL> dp = np . zeros ( s + 1 , dtype = <STRING> ) <NEWLINE> dp [ 0 ] = 1 <NEWLINE> <NL> for a in A : <NEWLINE> <INDENT> p = ( dp * 2 ) % MOD <NEWLINE> p %= MOD <NEWLINE> p [ a : ] += dp [ : a ] <NEWLINE> dp = p % MOD <NEWLINE> <NL> <DEDENT> print ( dp [ s ] ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> import sys <NEWLINE> import datetime <NEWLINE> <NL> H1 = int ( sys . stdin . readline ( ) ) <NEWLINE> M1 = int ( sys . stdin . readline ( ) ) <NEWLINE> H2 = int ( sys . stdin . readline ( ) ) <NEWLINE> M2 = int ( sys . stdin . readline ( ) ) <NEWLINE> K = int ( sys . stdin . readline ( ) ) <NEWLINE> <NL> while not ( H1 < 23 or M1 < 59 or H2 < 23 or M2 < 59 ) : <NEWLINE> <INDENT> H1 = int ( sys . stdin . readline ( ) ) <NEWLINE> M1 = int ( sys . stdin . readline ( ) ) <NEWLINE> H2 = int ( sys . stdin . readline ( ) ) <NEWLINE> M2 = int ( sys . stdin . readline ( ) ) <NEWLINE> K = int ( sys . stdin . readline ( ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if M2 >= M1 : <NEWLINE> <INDENT> a = ( H2 - H1 ) * 60 + M2 - M1 <NEWLINE> print ( a - K ) <NEWLINE> <DEDENT> if M2 < M1 : <NEWLINE> <INDENT> b = ( H2 - H1 ) * 60 + M1 - M2 <NEWLINE> print ( b - K ) <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> import math <NEWLINE> import itertools <NEWLINE> h1 , m1 , h2 , m2 , k = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( max ( ( h2 - h1 ) * 60 + ( m2 - m1 ) - k ) , 0 ) <NEWLINE>
h1 , m1 , h2 , m2 , k = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> f = h1 * 60 + m1 <NEWLINE> t = h2 * 60 + m2 <NEWLINE> <NL> if time < 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( time ) <NEWLINE> <DEDENT>
h1 , m1 , h2 , m2 , k = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> h = h2 - h1 <NEWLINE> if h < 0 : <NEWLINE> <INDENT> h = 24 + h <NEWLINE> m = m2 - m1 <NEWLINE> du = h * 60 + m - k <NEWLINE> <DEDENT> elif h == 0 : <NEWLINE> <INDENT> if m1 < m2 : <NEWLINE> <INDENT> du = m2 - m1 - k <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> du = h * 60 + m - k <NEWLINE> <NL> <DEDENT> print ( du ) <NEWLINE>
h1 , m1 , h2 , m2 , k = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> H = ( h2 - h1 ) * 60 <NEWLINE> M = abs ( m1 - m2 ) <NEWLINE> if H - M - k >= 0 : <NEWLINE> print ( H - M - k ) <NEWLINE>
1 , m1 , h2 , m2 , k = ( int ( x ) for x in input ( ) . split ( ) ) <NEWLINE> <NL> hrtom = ( h2 - h1 ) <NEWLINE> <NL> if ( m2 - m1 < 0 ) and ( h2 - h1 >= 0 ) : <NEWLINE> <INDENT> min = ( h2 - h1 ) * 60 - ( m2 - m1 ) - k <NEWLINE> print ( min ) <NEWLINE> <NL> <DEDENT> elif ( m2 - m1 >= 0 ) and ( h2 - h1 >= 0 ) : <NEWLINE> <INDENT> min = ( h2 - h1 ) * 60 + ( m2 - m1 ) - k <NEWLINE> print ( min ) <NEWLINE> <NL> <DEDENT> elif ( m2 - m1 < 0 ) and ( h2 - h1 ) <= 0 : <NEWLINE> <INDENT> min = ( 24 - h1 + h2 ) * 60 - ( m2 - m1 ) - k <NEWLINE> print ( min ) <NEWLINE> <NL> <DEDENT> elif ( m2 - m1 >= 0 ) and ( h2 - h1 ) <= 0 : <NEWLINE> <INDENT> min = ( 24 - h1 + h2 ) * 60 + ( m2 - m1 ) - k <NEWLINE> print ( min ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
( a , b , c , d , e ) = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if a == c : <NEWLINE> <INDENT> t = d - b <NEWLINE> if e <= t : <NEWLINE> <INDENT> print ( t - e ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <NL> <DEDENT> <DEDENT> if c > a : <NEWLINE> <INDENT> if b > d : <NEWLINE> <INDENT> t = 60 - b + d <NEWLINE> if e <= t : <NEWLINE> print ( t - e ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <NL> <DEDENT> if b <= d : <NEWLINE> <INDENT> t = ( c - a ) * 60 + d - b <NEWLINE> if e <= t : <NEWLINE> print ( t - e ) <NEWLINE> else : <NEWLINE> print ( 0 ) <NEWLINE> <DEDENT> <DEDENT>
h1 , m1 , h2 , m2 , k = map ( int , input ( ) . split ( ) ) <NEWLINE> if m2 < m1 : <NEWLINE> <INDENT> ansh = h2 - h1 - 1 <NEWLINE> ansm = 60 + m2 + m1 <NEWLINE> <DEDENT> print ( ansh * 60 + ansm ) <NEWLINE>
import sys <NEWLINE> import math <NEWLINE> import itertools <NEWLINE> import collections <NEWLINE> import heapq <NEWLINE> import numpy as np <NEWLINE> <NL> rl = sys . stdin . readline <NEWLINE> <NL> h1 , m1 , h2 , m2 , k = map ( int , rl ( ) . split ( ) ) <NEWLINE> m = h260 + m2 - h160 - m1 <NEWLINE> print ( m - k ) <NEWLINE>
h1 , m1 , h2 , m2 , k = int ( input ( ) . split ( ) ) <NEWLINE> s = ( h2 - h1 ) * 60 + ( m2 - m1 ) - k <NEWLINE> print ( s ) <NEWLINE>
h1 , m1 , h2 , m2 , k = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if m1 = m2 : <NEWLINE> <INDENT> m = 0 <NEWLINE> h = h2 - h1 <NEWLINE> <DEDENT> elif m2 - m1 > 0 : <NEWLINE> <INDENT> m = m2 - m1 <NEWLINE> h = h2 - h1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> m = 60 - m1 + m2 <NEWLINE> h = h2 - h1 - 1 <NEWLINE> <DEDENT> ans = k - m + h * 60 <NEWLINE> if ans <= 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <NL> <DEDENT>
H1 , M1 , H2 , H2 , K = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( ( H2 - H1 ) * 60 + ( M2 - M1 ) - K ) <NEWLINE>
<NL> h1 , m1 , h2 , m2 , k = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> <NL> start = h1 * 60 + m1 <NEWLINE> end = h2 * 60 + m2 <NEWLINE> total = end - start - k <NEWLINE> <NL> print ( k ) <NEWLINE>
<COMMENT> <NL> string = str ( input ( ) ) <NEWLINE> X = 0 ; li = [ ] <NEWLINE> for a in range ( len ( string ) ) : <NEWLINE> <INDENT> if a = <STRING> : <NEWLINE> <INDENT> li . append ( string [ X : a ] ) <NEWLINE> X = a <NEWLINE> <DEDENT> <DEDENT> h1 = li [ 0 ] ; m1 = li [ 1 ] ; h2 = li [ 2 ] ; m1 = li [ 3 ] ; k = li [ 4 ] <NEWLINE> Time = ( h1 * 60 + m1 ) - ( h2 * 60 + m2 ) - K <NEWLINE> print ( int ( Time ) ) <NEWLINE>
h , m , h2 , m2 , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = h * 60 + m <NEWLINE> b = h2 * 60 + m2 <NEWLINE> if a > b : <NEWLINE> <INDENT> b += 60 * 24 <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> print ( ( ( b - a ) - k ) <NEWLINE>
import sys <NEWLINE> <NL> args = sys . argv <NEWLINE> <NL> H1 = int ( args [ 1 ] ) <NEWLINE> M1 = int ( args [ 2 ] ) <NEWLINE> H2 = int ( args [ 3 ] ) <NEWLINE> M2 = int ( args [ 4 ] ) <NEWLINE> K = int ( args [ 5 ] ) <NEWLINE> <NL> if H1 > H2 : <NEWLINE> <INDENT> H1 -= 24 <NEWLINE> <NL> <DEDENT> before = H1 * 60 + M1 <NEWLINE> after = H2 * 60 + M2 <NEWLINE> after -= K <NEWLINE> <NL> time = after - before <NEWLINE> print ( time ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> H1 , M1 , H2 , M2 , K = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( K * ( abs ( ( sleep - 1 ) - start ) // K ) ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
guh , gum , gbh , bgm , st = map ( int , input ( ) . split ( ) ) <NEWLINE> if bgm < gum : <NEWLINE> <INDENT> gbh -= 1 <NEWLINE> bgm += 60 <NEWLINE> <DEDENT> tmp = ( gbh - guh ) * 60 + ( gbm - gum ) <NEWLINE> ans = tmp - st <NEWLINE> print ( ans ) <NEWLINE>
H_1 , M_1 , H_2 , M_2 , K = map ( int , input ( ) . split ( ) ) <NEWLINE> MaxH = H_2 - H_1 <NEWLINE> if M_1 > M_2 : <NEWLINE> <INDENT> MaxM = M_2 - M_1 <NEWLINE> <DEDENT> if M_1 < M_2 : <NEWLINE> <INDENT> MaxM = M_1 - M_2 <NEWLINE> <DEDENT> useTime = MaxH * 60 + MaxM <NEWLINE> useTime -= K <NEWLINE> print ( useTime ) <NEWLINE>
h1 , m1 , h2 , m2 , k = int ( input ( ) . split ( <STRING> ) ) <NEWLINE> <NL> awake_time = ( h2 - h1 ) * 60 + ( m2 - m1 ) <NEWLINE> y = awake_time - k <NEWLINE> <NL> print ( y ) <NEWLINE>
H1 , M1 , H2 , M2 , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> startTime = ( H1 * 60 ) + M1 <NEWLINE> endTime = ( H2 * 60 ) + M2 <NEWLINE> time = endTime - startTime <NEWLINE> posTime = time - k <NEWLINE> if ( posTime < 0 ) : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( posTime ) <NEWLINE> <DEDENT>
from datetime import datetime , timedelta <NEWLINE> <NL> a = [ 1 , 1 , 1 , 1 , 1 ] <NEWLINE> a [ 0 ] = input ( ) <NEWLINE> a [ 1 ] = input ( ) <NEWLINE> a [ 2 ] = input ( ) <NEWLINE> a [ 3 ] = input ( ) <NEWLINE> a [ 4 ] = input ( ) <NEWLINE> a = [ int ( x ) for x in a ] <NEWLINE> t1 = datetime ( 2000 , 1 , 1 , a [ 0 ] , a [ 1 ] , 0 ) <NEWLINE> t2 = datetime ( 2000 , 1 , 1 , a [ 2 ] , a [ 3 ] , 0 ) <NEWLINE> <NL> delta = t2 - t1 <NEWLINE> total_seconds = delta . seconds <NEWLINE> <NL> ans = ( total_seconds - a [ 4 ] * 60 ) / 60 <NEWLINE> print ( int ( ans ) ) <NEWLINE>
a , b , c , d , e = map ( int , input . split ( ) ) <NEWLINE> print ( ( c * 60 + d ) - ( a * 60 + b ) - e ) <NEWLINE>
h1 , m1 , h2 , m2 , k = map ( int , input ( ) . split ( ) ) <NEWLINE> h1 += m1 / 60 <NEWLINE> h2 += m2 / 60 <NEWLINE> val = h2 - h1 <NEWLINE> val *= 60 <NEWLINE> val -= k <NEWLINE> print ( max ( 0 , int ( val ) ) <NEWLINE>
h1 , m1 , h2 , m2 , k = list ( map ( int , readline ( ) . split ( ) ) ) <NEWLINE> <NL> x = ( h2 - h1 ) * 60 + ( m2 - m1 ) <COMMENT> <NEWLINE> print ( x - k ) <NEWLINE>
h1 , m1 , h2 , m2 , k = map ( int ( input ( ) ) ) <NEWLINE> <NL> a = 60 ( h2 - h1 ) <NEWLINE> b = m2 - m1 <NEWLINE> <COMMENT> <NL> c = a + b <NEWLINE> <COMMENT> <NL> d = c - k <NEWLINE> print ( d ) <NEWLINE>
import sys <NEWLINE> def main ( ) : <NEWLINE> <INDENT> H1 , M1 , H2 , M2 , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> h = H2 - H1 <NEWLINE> m = M2 - M1 <NEWLINE> tot_minutes = h * 60 + m - K <NEWLINE> if tot_minutes <= 0 : <NEWLINE> <INDENT> out = 0 <NEWLINE> <DEDENT> print ( out ) <NEWLINE> <DEDENT> main ( ) <NEWLINE>
H1 , M1 , H2 , M2 , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> h = H2 - H1 <NEWLINE> m = M2 - M1 <NEWLINE> s = 0 <NEWLINE> if h > 0 : <NEWLINE> <INDENT> s = h * 60 + m <NEWLINE> <DEDENT> elif : h == 0 : <NEWLINE> <INDENT> s = 24 * 60 + m <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s = ( 24 + h ) * 60 + m <NEWLINE> <NL> <DEDENT> s -= K <NEWLINE> print ( s ) <NEWLINE>
a , b , c , d , e = map ( int , input . split ( ) ) <NEWLINE> <NL> time = c * 60 + d - a * 60 - b <NEWLINE> <NL> if time >= e : <NEWLINE> <INDENT> print ( time - e ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT>
i_l_s = input ( ) . split ( ) <NEWLINE> i_l = list ( map ( int , i_l_s ) ) <NEWLINE> <NL> hour = i_l [ 4 ] // 60 <NEWLINE> min = i [ 4 ] % 60 <NEWLINE> <NL> before = [ i_l [ 0 ] + hour , i_l [ 1 ] + min ] <NEWLINE> after = [ i_l [ 2 ] , i_l [ 3 ] ] <NEWLINE> <NL> if ( after [ 0 ] - before [ 0 ] == 0 ) : <NEWLINE> <INDENT> print ( after [ 1 ] - before [ 1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( after [ 1 ] - before [ 1 ] + 60 ( after [ 0 ] - before [ 0 ] ) ) <NEWLINE> <DEDENT>
import sys <NEWLINE> 2 readline = sys . stdin . buffer . readline <NEWLINE> 3 <NEWLINE> 4 h1 , m1 , h2 , m2 , k = map ( int , readline ( ) . split ( ) ) <NEWLINE> 5 print ( 60 * ( h2 - h1 ) + m2 - m1 - k ) <NEWLINE>
h1 , m1 , h2 , m2 , k = map ( input ( ) . split ( ) ) <NEWLINE> <NL> <NL> m3 = k % 60 <NEWLINE> h3 = ( k - m2 ) / 60 <NEWLINE> ans = ( h2 - h3 - h1 ) * 60 + ( m2 - m3 - m1 ) <NEWLINE> <NL> print ( ans ) <NEWLINE>
h1 = input ( <STRING> ) <NEWLINE> m1 = input ( <STRING> ) <NEWLINE> h2 = input ( <STRING> ) <NEWLINE> m2 = input ( <STRING> ) <NEWLINE> k = input ( <STRING> ) <NEWLINE> print ( <STRING> ) <NEWLINE> <NL> <NL> <NL> <NL> <NL> <NL> <NL>
H1 , M1 , H2 , M2 , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if h1 > h2 : <NEWLINE> <INDENT> h2 += 24 <NEWLINE> <NL> <DEDENT> h1 = H1 * 60 <NEWLINE> m1 = M1 <NEWLINE> h2 = H2 * 60 <NEWLINE> m2 = M2 <NEWLINE> <NL> print ( ( h2 - m2 ) - ( h1 + m1 ) - K ) <NEWLINE>
<STRING> <NEWLINE> <NL> H1 , M1 , H2 , M2 , K = input ( ) . split ( <STRING> ) <NEWLINE> <NL> awake_time = H1 * 60 + M1 <NEWLINE> sleep_time = H2 * 60 + M1 <NEWLINE> start_limit_time = sleep_time - K <NEWLINE> <NL> can_study_time = start_limit_time - awake_time <NEWLINE> <NL> print ( can_study_time ) <NEWLINE>
h1 = int ( input ( ) ) <NEWLINE> m1 = int ( input ( ) ) <NEWLINE> h2 = int ( input ( ) ) <NEWLINE> m2 = int ( input ( ) ) <NEWLINE> k = int ( input ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> if m1 > m2 : ans = ( h2 - h1 - 1 ) * 60 + 60 - m1 + m2 <NEWLINE> else : ans = ( h2 - h1 ) * 60 + m2 - m1 <NEWLINE> print ( ans - k ) <NEWLINE>
okiji , okihun , neji , nehun , benji = map ( int , input ( ) . split ( ) ) <NEWLINE> <INDENT> print ( ( neji * 60 + nehun ) - ( okiji * 60 + okihun ) - benji ) <NEWLINE> <DEDENT>
h1 , m1 , h2 , m2 , k = map ( int , input ( ) . split ( ) ) <NEWLINE> h_d = h2 - h <NEWLINE> m_d = m2 - m1 <NEWLINE> if m_d < 0 : <NEWLINE> <INDENT> h_d -= 1 <NEWLINE> m_d = 60 + m2 - m1 <NEWLINE> <NL> <DEDENT> sum = 60 * h_d + m_d <NEWLINE> sum -= k <NEWLINE> <NL> if sum < 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( sum ) <NEWLINE> <DEDENT>
a , b , c , d , e = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( ( 60 * c + d ) - ( 60 * a + b ) - k ) <NEWLINE>
H1 , M1 , H2 , M2 , K = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = 60 * H1 + M1 <NEWLINE> b = 60 * H2 + M2 <NEWLINE> print ( b - a - p ) <NEWLINE>
a , b , c , d , e , f = map ( int , input ( ) . split ( ) ) <NEWLINE> kis = a * 60 + b <NEWLINE> nel = c * 60 + d <NEWLINE> print ( nel - f - kis ) <NEWLINE>
data = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> main = ( data [ 2 ] - date [ 0 ] ) * 60 + data [ 3 ] - date [ 1 ] - data [ 3 ] <NEWLINE>
L = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if L [ 0 ] > L [ 2 ] : <NEWLINE> <INDENT> A = 60 * L [ 0 ] + L [ 1 ] <NEWLINE> B = 60 * ( L [ 2 ] + 24 ) + L [ 3 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> A = 60 * L [ 0 ] + L [ 1 ] <NEWLINE> B = 60 * L [ 2 ] + L [ 3 ] <NEWLINE> <NL> <DEDENT> if B - A <= L [ 4 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif ( B - A ) % L [ 4 ] == 0 : <NEWLINE> <INDENT> print ( str ( ( ( B - A ) - L [ 4 ] ) ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( str ( round ( ( B - A ) // L [ 4 ] ) ) ) z <NEWLINE> <DEDENT>
h1 , m1 , h2 , m2 , k = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if m1 <= m2 : <NEWLINE> <INDENT> print ( max ( ( h2 - h1 ) * 60 + m2 - m1 - k ) , 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( max ( ( h2 - h1 - 1 ) * 60 + m2 + 60 - m1 - k , 0 ) ) <NEWLINE> <DEDENT>
H , M , h , m , K = map ( int , input ( ) . slpit ( ) ) <NEWLINE> <NL> print ( max ( 0 , 60 * ( h - H ) + m - M - K ) ) <NEWLINE>
wake_up_hour = int ( input ( ) ) <NEWLINE>
h_1 , m_1_h_2 , m_2 , k = map ( int , input ( ) . split ( ) ) <NEWLINE> H = 60 * h_2 + m_2 - ( 60 * h_1 + m_1 ) - k <NEWLINE> if ( H <= 0 ) : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( H ) <NEWLINE> <NL> <DEDENT>
h1 , m1 , h2 , m2 , k = map ( int , input ( ) . split ( ) ) <NEWLINE> if m2 < m1 : <NEWLINE> <INDENT> m2 += 60 <NEWLINE> <INDENT> h2 -= 1 <NEWLINE> <DEDENT> <DEDENT> m = m2 - m1 <NEWLINE> h = h2 - h1 <NEWLINE> <NL> if 60 * h + m <= k : <NEWLINE> <INDENT> print ( 60 * h + m ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( k ) <NEWLINE> <DEDENT>
input_nums = input ( ) . split ( ) <NEWLINE> <NL> diff_hour = input_nums ( 2 ) - input_nums ( 0 ) <NEWLINE> diff_hour_to_min = diff_hour * 60 <NEWLINE> <NL> diff_min = input_nums ( 3 ) - input_nums ( 1 ) <NEWLINE> <NL> total_wake_min = diff_hour_to_min + diff_min <NEWLINE> <NL> print ( total_wake_min - input_nums ( 4 ) ) <NEWLINE>
a , b , c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> e = ( c - a ) * 60 <NEWLINE> print ( e - d ) <NEWLINE>
wakeup = 60 * H1 + M1 <NEWLINE> gotobed = 60 * H2 + M2 <NEWLINE> <NL> wake = gotobed - wakeup <NEWLINE> <NL> answer = wake - K <NEWLINE> <NL> answer <NEWLINE>
import sys <NEWLINE> a = [ ] <NEWLINE> for l in sys . stdin : <NEWLINE> <INDENT> a . append ( int ( l ) ) <NEWLINE> <DEDENT> h1 , m1 , h2 , m2 , k = a [ 0 ] . split ( ) <NEWLINE> H1 , M1 , H2 , M2 , K = int ( h1 ) , int ( m1 ) , int ( h2 ) , int ( m2 ) , int ( k ) <NEWLINE> time = 60 * H2 + M2 - ( 60 * H1 + M1 ) - K <NEWLINE> print ( time ) <NEWLINE>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> h1 , m1 , h2 , m2 , k = input . split ( ) <NEWLINE> <NL> h_time = ( h2 - h1 - 1 ) * 60 <NEWLINE> m_time = ( 60 - m1 ) + m2 <NEWLINE> <NL> rest_time = ( h_time + m_time ) - k <NEWLINE> print ( rest_time ) <NEWLINE>
s = str ( input ( ) ) <NEWLINE> s_ = list ( s ) <NEWLINE> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> if i == 0 and len ( s ) == 1 and s_ [ i ] == <STRING> : <NEWLINE> <INDENT> s_ [ i ] = <STRING> <NEWLINE> <DEDENT> elif i == 0 and s_ [ i ] == <STRING> and s_ [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> s_ [ i ] = <STRING> <NEWLINE> <DEDENT> elif i == 0 and s_ [ i ] == <STRING> and s_ [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> s_ [ i ] = <STRING> <NEWLINE> <DEDENT> elif s_ [ i ] == <STRING> and s [ i - 1 ] == <STRING> : <NEWLINE> <INDENT> s_ [ i ] = <STRING> <NEWLINE> <DEDENT> elif s_ [ i ] == <STRING> and s [ i - 1 ] == <STRING> : <NEWLINE> <INDENT> if i = len ( s ) - 1 : <NEWLINE> <INDENT> s_ [ i ] = <STRING> <NEWLINE> <DEDENT> if s_ [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> s_ [ i ] = <STRING> <NEWLINE> <DEDENT> elif s_ [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> s_ [ i ] = <STRING> <NEWLINE> s_ [ i + 1 ] = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s_ [ i ] = <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> S = <STRING> . join ( s_ ) <NEWLINE> print ( S ) <NEWLINE>
t = input ( ) <NEWLINE> s = t . replace ( <STRING> , <STRING> ) <NEWLINE> n = 0 <NEWLINE> for i in range ( 0 , len ( s ) ) : <NEWLINE> <INDENT> if s [ i : i + 1 ] == <STRING> and s [ i + 1 : i + 2 ] == <STRING> : <NEWLINE> <INDENT> n += 1 <NEWLINE> <DEDENT> else if s [ i : i + 1 ] : <NEWLINE> <INDENT> n += 1 <NEWLINE> <DEDENT> <DEDENT> print ( n ) <NEWLINE>
T = input ( ) <NEWLINE> <NL> res = <STRING> <NEWLINE> for i in len ( T ) : <NEWLINE> <INDENT> if ( T [ i ] != <STRING> ) : <NEWLINE> <INDENT> res += T [ i ] <NEWLINE> continue <NEWLINE> <NL> <DEDENT> if ( i != 0 ) : <NEWLINE> <INDENT> if ( T [ i - 1 ] == <STRING> ) : <NEWLINE> <INDENT> res += <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> res += <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( res ) <NEWLINE>
t = list ( input ( ) ) <NEWLINE> <NL> i = 0 <NEWLINE> for i in len ( t ) : <NEWLINE> <INDENT> if t [ i ] == <STRING> : <NEWLINE> <INDENT> t [ i ] == <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> print ( t ) <NEWLINE>
S = input ( ) <NEWLINE> length = len ( S ) <NEWLINE> count = 0 <NEWLINE> <NL> for i in range ( len ) : <NEWLINE> <INDENT> if S [ i ] = <STRING> : <NEWLINE> <INDENT> S [ i ] = D <NEWLINE> <NL> <DEDENT> <DEDENT> print ( S ) <NEWLINE>
print ( input ( ) . replase ( <STRING> , <STRING> ) ) <NEWLINE>
T = str ( input ( ) ) <NEWLINE> ans = <STRING> <NEWLINE> for i , t in eumerate ( T ) : <NEWLINE> <INDENT> if t != <STRING> : <NEWLINE> <INDENT> ans += t <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += <STRING> <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
s = input ( ) <NEWLINE> ans = <STRING> <NEWLINE> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> s_i = s [ i ] <NEWLINE> if s_i = <STRING> : <NEWLINE> <INDENT> if i < len ( s ) : <NEWLINE> <INDENT> if s [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> ans += <STRING> <NEWLINE> continue <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> ans += <STRING> <NEWLINE> continue <NEWLINE> <DEDENT> <DEDENT> ans += s_i <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import numpy as np <NEWLINE> t = input ( ) <NEWLINE> pre = <STRING> <NEWLINE> for i in range ( len ( t ) ) : <NEWLINE> <INDENT> if t [ i ] == <STRING> : <NEWLINE> <INDENT> t [ i ] = <STRING> <NEWLINE> <DEDENT> <DEDENT>
t = list ( input ( ) ) <NEWLINE> n = len ( t ) <NEWLINE> if n == 1 : <NEWLINE> <INDENT> if t == <STRING> : <NEWLINE> <INDENT> t = <STRING> <NEWLINE> <DEDENT> <DEDENT> elif n == 2 : <NEWLINE> <INDENT> if t != <STRING> or t != <STRING> : <NEWLINE> <INDENT> if t == <STRING> : <NEWLINE> <INDENT> t = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( 2 ) : <NEWLINE> <INDENT> if t [ i ] == <STRING> : <NEWLINE> <INDENT> t [ i ] = <STRING> <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> t = <STRING> <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( n ) : <NEWLINE> <INDENT> if t [ i ] != <STRING> : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <INDENT> t [ i ] = <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if t = <STRING> * n : <NEWLINE> <INDENT> t = <STRING> + <STRING> * n <NEWLINE> <DEDENT> print ( <STRING> . join ( t ) ) <NEWLINE>
t = input ( ) <NEWLINE> n = len ( t ) <NEWLINE> s = <STRING> <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if p [ i ] == <STRING> : <NEWLINE> <INDENT> s += <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s += <STRING> <NEWLINE> <DEDENT> <DEDENT> print ( s ) <NEWLINE>
t = input ( ) <NEWLINE> ans = ans . replace ( <STRING> , <STRING> ) <NEWLINE> ans = t . replace ( <STRING> , <STRING> ) <NEWLINE> ans = ans . replace ( <STRING> , <STRING> ) <NEWLINE> ans = ans . replace ( <STRING> , <STRING> ) <NEWLINE> print ( ans ) <NEWLINE>
T = list ( input ( ) ) <NEWLINE> T2 = ( T . replace ( <STRING> , <STRING> ) ) <NEWLINE> <NL> print ( T2 ) <NEWLINE>
import sys <NEWLINE> from collections import defaultdict , Counter , deque <NEWLINE> from itertools import accumulate , permutations , combinations <NEWLINE> from operator import itemgetter <NEWLINE> from bisect import bisect_left , bisect_right , bisect <NEWLINE> from heapq import heappop , heappush <NEWLINE> from fractions import gcd <NEWLINE> from math import ceil , floor , sqrt , cos , sin , pi <NEWLINE> from copy import deepcopy <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> T = input ( ) <NEWLINE> result = [ ] <NEWLINE> for i in range ( len ( T ) - 1 ) : <NEWLINE> <INDENT> if T [ i ] == <STRING> : <NEWLINE> <INDENT> if result [ i - 1 ] == <STRING> : <NEWLINE> <INDENT> result . append ( <STRING> ) <NEWLINE> <DEDENT> elif T [ i + 1 ] == <STRING> or T [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> result . append ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> result . append ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> result . append ( T [ i ] ) <NEWLINE> <DEDENT> <DEDENT> if T [ - 1 ] == <STRING> : <NEWLINE> <INDENT> result . append ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> result . append ( T [ - 1 ] ) <NEWLINE> <DEDENT> print ( <STRING> . join ( result ) ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> ans = <STRING> <NEWLINE> for c in s : <NEWLINE> <INDENT> if c == <STRING> : <NEWLINE> <INDENT> ans . append ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans . append ( c ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import itertools <NEWLINE> import decimal <NEWLINE> import math <NEWLINE> import collections <NEWLINE> import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> T = input ( ) <NEWLINE> <NL> T . replace ( <STRING> , <STRING> ) <NEWLINE> <NL> print ( T . count ( <STRING> ) + T . count ( <STRING> ) <NEWLINE>
<INDENT> t = input ( ) <NEWLINE> print ( t . replace ( <STRING> , <STRING> ) ) <NEWLINE> <DEDENT>
t = input ( ) <NEWLINE> <NL> ans = replace ( <STRING> , <STRING> ) <NEWLINE> print ( ans ) <NEWLINE>
s = input ( ) <NEWLINE> print ( s . replace ( <STRING> , <STRING> ) <NEWLINE>
import sys <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> t = readline ( ) <NEWLINE> print ( t . replace ( <STRING> , <STRING> ) <NEWLINE>
word = input ( ) <NEWLINE> start = 0 <NEWLINE> end = len ( word ) <NEWLINE> while ( True ) : <NEWLINE> <INDENT> i = word . find ( <STRING> , start , end ) <NEWLINE> if ( i == - 1 ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> elif ( i == ( end - 1 ) ) : <NEWLINE> <INDENT> word = word . replace ( <STRING> , <STRING> , 1 ) <NEWLINE> <DEDENT> elif ( word [ i - 1 ] == <STRING> ) : <NEWLINE> <INDENT> word = word . replace ( <STRING> , <STRING> , 1 ) <NEWLINE> <DEDENT> elif ( ( word [ i + 1 ] == <STRING> ) or ( word [ i + 1 ] == <STRING> ) ) : <NEWLINE> <INDENT> word = word . replace ( <STRING> , <STRING> , 1 ) <NEWLINE> else : <NEWLINE> <INDENT> word = word . replace ( <STRING> , <STRING> , 1 ) <NEWLINE> <DEDENT> <DEDENT> start = i + 1 <NEWLINE> <DEDENT> print ( word ) <NEWLINE>
Vt = input ( ) <NEWLINE> print ( t . replace ( <STRING> , <STRING> ) ) <NEWLINE>
l1 = list ( input ( ) ) <NEWLINE> k = l1 . count ( <STRING> ) <NEWLINE> for i in range ( l1 ) : <NEWLINE> <INDENT> if l1 [ i ] == <STRING> : <NEWLINE> <INDENT> l1 [ i ] = <STRING> <NEWLINE> <DEDENT> <DEDENT> s = l1 . join ( <STRING> ) <NEWLINE> print ( s ) <NEWLINE>
str = input ( ) <NEWLINE> str = list ( str ) <NEWLINE> <NL> <NL> for index , value in enumerate ( str ) : <NEWLINE> <INDENT> if ( value == <STRING> and index == len ( str ) - 1 ) : <NEWLINE> <INDENT> str [ index ] = <STRING> <NEWLINE> <NL> <DEDENT> elif ( value == <STRING> and index != 0 and str [ index - ] == <STRING> ) : <NEWLINE> <INDENT> str [ index ] = <STRING> <NEWLINE> <NL> <DEDENT> elif ( value == <STRING> and str [ index + 1 ] == <STRING> ) : <NEWLINE> <INDENT> str [ index ] = <STRING> <NEWLINE> str [ index + 1 ] = <STRING> <NEWLINE> <DEDENT> elif ( value == <STRING> ) : <NEWLINE> <INDENT> str [ index ] = <STRING> <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> print ( <STRING> . join ( str ) ) <NEWLINE>
s = input ( ) <NEWLINE> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> s [ i ] = <STRING> <NEWLINE> <DEDENT> <DEDENT> print ( s ) <NEWLINE>
t = input ( ) <NEWLINE> for i in t : <NEWLINE> <INDENT> if i == <STRING> : <NEWLINE> <INDENT> t [ i ] = <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> print ( t ) <NEWLINE>
<INDENT> t = list ( input ( ) ) <NEWLINE> <NL> <NL> <DEDENT> for i in range ( len ( t ) - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> if t [ i ] == <STRING> : <NEWLINE> <INDENT> t [ i ] = <STRING> <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> . join ( list ( map ( str , t ) ) ) ) <NEWLINE>
t = input ( ) <NEWLINE> maxt = <STRING> <NEWLINE> if len ( t ) = 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> while len ( maxt ) = len ( t ) : <NEWLINE> <INDENT> if len ( maxt ) // 2 = 0 : <NEWLINE> <INDENT> maxt += <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> maxt += <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> print ( maxt ) <NEWLINE> <DEDENT>
T = input ( ) <NEWLINE> <INDENT> print ( T . replace ( <STRING> , <STRING> ) ) <NEWLINE> <DEDENT>
print ( input . replace ( <STRING> , <STRING> ) ) <NEWLINE>
s = input ( ) <NEWLINE> <NL> for idx in range ( len ( s ) ) : <NEWLINE> <INDENT> if s [ idx ] == <STRING> : <NEWLINE> <INDENT> s [ idx ] = <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> print ( s ) <NEWLINE>
s = input ( ) <NEWLINE> ll = list ( input ( ) . split ( ) ) <NEWLINE> l = [ ] <NEWLINE> cnt = 0 <NEWLINE> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> c = <STRING> <NEWLINE> if i + 1 < len ( s ) : <NEWLINE> <INDENT> if s [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> c = <STRING> <NEWLINE> <DEDENT> <DEDENT> if i > 0 : <NEWLINE> <INDENT> if s [ i - 1 ] == <STRING> : <NEWLINE> <INDENT> c = <STRING> <NEWLINE> <DEDENT> <DEDENT> if c == <STRING> : <NEWLINE> <INDENT> c = <STRING> <NEWLINE> <DEDENT> l . append ( ll [ cnt ] ) <NEWLINE> l . append ( c ) <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> l . append ( ll [ - 1 ] ) <NEWLINE> print ( <STRING> . join ( l ) ) <NEWLINE>
a = input ( ) <NEWLINE> b = [ i for i in a ] <NEWLINE> if b [ 0 ] == <STRING> : <NEWLINE> <INDENT> bin [ 0 ] = <STRING> <NEWLINE> <DEDENT> for i in range ( 1 , len ( t ) - 1 ) : <NEWLINE> <INDENT> if b [ i ] == <STRING> : <NEWLINE> <INDENT> if b [ i - 1 ] == <STRING> and b [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> b [ i ] = <STRING> <NEWLINE> <DEDENT> elif b [ i - 1 ] == <STRING> and b [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> b [ i ] = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> b [ i ] = <STRING> <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if b [ - 1 ] == <STRING> : <NEWLINE> <INDENT> b [ - 1 ] = <STRING> <NEWLINE> <DEDENT> print ( <STRING> . join ( b ) ) <NEWLINE>
input ( ) <NEWLINE> c = <STRING> <NEWLINE> <NL> <NL> for i in range ( 1 , len ( a ) ) : <NEWLINE> <INDENT> if a [ i - 1 ] == <STRING> : <NEWLINE> <INDENT> c = c + <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> c = c + a [ i - 1 ] <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> print ( c ) <NEWLINE>
t = input ( ) <NEWLINE> <NL> l = [ _ for i in range ( len ( t ) ) ] <NEWLINE> for i in range ( 0 , len ( t ) ) : <NEWLINE> <INDENT> if t [ i ] == <STRING> : <NEWLINE> <INDENT> l [ i ] = <STRING> <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> l [ i ] = t [ i ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> . join ( l ) ) <NEWLINE>
= input ( ) <NEWLINE> T = S . replace ( <STRING> , <STRING> ) <NEWLINE> print ( T ) <NEWLINE>
a = input ( ) <NEWLINE> print ( a . replace ( <STRING> , <STRING> ) <NEWLINE>
s = list ( input ( ) ) <NEWLINE> print ( s . replace ( <STRING> , <STRING> ) ) <NEWLINE>
t [ i ] == <STRING> and t [ i + 1 ] == <STRING> : <NEWLINE>
t = input ( ) <NEWLINE> for i in range ( len ( t ) ) : <NEWLINE> <INDENT> if t [ i ] == <STRING> : <NEWLINE> <INDENT> t [ i ] = <STRING> <NEWLINE> <DEDENT> <DEDENT> print ( t ) <NEWLINE>
t = list ( input ( ) ) <NEWLINE> for i in range ( len ( t ) ) : <NEWLINE> <INDENT> if t [ i ] == <STRING> : <NEWLINE> <INDENT> t [ i ] = D <NEWLINE> <DEDENT> print ( t [ i ] , end = <STRING> ) <NEWLINE> <DEDENT>
ret = <STRING> <NEWLINE> for i in range ( len ( T ) ) : <NEWLINE> <INDENT> if T [ i ] == <STRING> : <NEWLINE> <INDENT> ret += <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ret += T [ i ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ret ) <NEWLINE>
T = input ( ) <NEWLINE> print ( T . replase ( <STRING> , <STRING> ) ) <NEWLINE>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> <COMMENT> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> S = int ( input ( ) . strip ( ) ) <NEWLINE> return S . replace ( <STRING> , <STRING> ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> print ( main ( ) ) <NEWLINE> <DEDENT>
t = list ( input ( ) ) <NEWLINE> for i in len ( t ) : <NEWLINE> <INDENT> if t [ i ] == <STRING> : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> t [ i ] = <STRING> <NEWLINE> <DEDENT> if t [ i - 1 ] == <STRING> : <NEWLINE> <INDENT> t [ i ] = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> t [ i ] = <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( t ) <NEWLINE>
a = input ( ) <NEWLINE> i = 0 <NEWLINE> while i < a : <NEWLINE> <INDENT> if a [ i ] == <STRING> : <NEWLINE> <INDENT> print ( end = <STRING> ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> print ( end = str ( a [ i ] ) ) <NEWLINE> <DEDENT> i = i + 1 <NEWLINE> <DEDENT>
print ( input ( ) . reaplce ( <STRING> , <STRING> ) ) <NEWLINE>
T = input ( ) <NEWLINE> if T [ 0 ] == <STRING> and len ( T ) > 1 : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <DEDENT> elif T [ 0 ] == <STRING> and len ( T ) == 1 : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = T [ 0 ] <NEWLINE> <NL> <DEDENT> for i in range ( 1 , len ( T ) ) : <NEWLINE> <INDENT> if T [ i ] == <STRING> : <NEWLINE> <INDENT> if ans [ i - 1 ] == <STRING> : <NEWLINE> <INDENT> ans = ans + <STRING> <NEWLINE> <DEDENT> elif i == len ( T ) - 1 : <NEWLINE> <INDENT> ans = ans + <STRING> <NEWLINE> <DEDENT> elif ans [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> ans = ans + <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = ans + <STRING> <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> ans = ans + T [ i ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
T = input ( ) <NEWLINE> ans = <STRING> <NEWLINE> for i in range ( len ( T ) ) : <NEWLINE> <INDENT> if T [ i ] != <STRING> : <NEWLINE> <INDENT> ans += T [ i ] <NEWLINE> continue <NEWLINE> <DEDENT> if ans += <STRING> <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
T = list ( str ( input ( ) ) ) <NEWLINE> <NL> for i in range ( len ( T ) ) : <NEWLINE> <INDENT> if T [ i ] == <STRING> <NEWLINE> <INDENT> T [ i ] = <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> . join ( T ) ) <NEWLINE>
for i in range ( len ( tl1 ) ) : <NEWLINE> <INDENT> if tl1 [ i ] == <STRING> : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> if tl1 [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> tl1 [ i ] = <STRING> <NEWLINE> <DEDENT> elif tl1 [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> tl1 [ i ] = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> tl1 [ i ] = <STRING> <NEWLINE> <DEDENT> <DEDENT> elif i == len ( tl1 ) - 1 : <NEWLINE> <INDENT> tl1 [ i ] = <STRING> <NEWLINE> <DEDENT> elif tl1 [ i - 1 ] == <STRING> : <NEWLINE> <INDENT> tl1 [ i ] = <STRING> <NEWLINE> <DEDENT> elif tl1 [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> tl1 [ i ] = <STRING> <NEWLINE> <DEDENT> elif tl1 [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> tl1 [ i ] = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> tl1 [ i ] = <STRING> <NEWLINE> <DEDENT> <DEDENT> if tl1 [ i ] == <STRING> : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> elif tl1 [ i - 1 ] == <STRING> : <NEWLINE> <INDENT> pd1 += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> d1 = tl1 . count ( <STRING> ) <NEWLINE> s1 = d1 + pd1 <NEWLINE> <NL> print ( <STRING> . join ( tl1 ) ) <NEWLINE>
T = input ( ) <NEWLINE> T = list ( T ) <NEWLINE> N = len ( T ) <NEWLINE> <INDENT> if T [ i ] == <STRING> <NEWLINE> <INDENT> del T [ i ] <NEWLINE> T . insert ( i , <STRING> ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> . join ( T ) ) <NEWLINE>
T = int ( input ( ) ) <NEWLINE> <NL> print ( T . replace ( <STRING> , <STRING> ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> a_list = [ int ( a ) for a in input ( ) . split ( ) ] <NEWLINE> <NL> if a [ 0 ] > 1 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> ans = a_list [ - 1 ] + 1 <NEWLINE> temp1 = [ <STRING> ] * ( N + 1 ) <NEWLINE> temp1 [ - 1 ] = a_list [ - 1 ] <NEWLINE> for n in range ( N - 1 , 0 , - 1 ) : <NEWLINE> <INDENT> temp1 [ n ] = temp1 [ n + 1 ] + a_list [ n ] <NEWLINE> <NL> <DEDENT> temp2 = 1 <NEWLINE> for n in range ( 1 , N ) : <NEWLINE> <INDENT> temp2 = ( temp2 - a_list [ n - 1 ] ) * 2 <NEWLINE> ans_temp = min ( temp2 , temp1 [ n ] ) <NEWLINE> <NL> if ans_temp < a_list [ n ] : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> ans += ans_temp <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> arr = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> s = sum ( arr ) <NEWLINE> f = 1 <NEWLINE> if n == 0 : <NEWLINE> <INDENT> if arr [ 0 ] != 1 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> elif a [ 0 ] != 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> ans = 1 <NEWLINE> node = 1 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> node = min ( 2 * node , s ) <NEWLINE> ans += node <NEWLINE> node -= a [ i ] <NEWLINE> s -= a [ i ] <NEWLINE> if node < 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> f = 0 <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> if f : print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = map ( int , input ( ) . split ( ) ) <NEWLINE> s = sum ( a ) <NEWLINE> k = 1 - a [ 0 ] <NEWLINE> ans = 1 <NEWLINE> <NL> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if k * 2 <= s : <NEWLINE> <INDENT> k *= 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> k = s <NEWLINE> <DEDENT> ans += k <NEWLINE> k -= a [ i ] <NEWLINE> s -= a [ i ] <NEWLINE> <NL> <DEDENT> if k == 0 and s == 0 : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT>
a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> su = sum ( a ) <NEWLINE> <COMMENT> <NL> l = [ su ] * ( n + 1 ) <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> l [ i ] = l [ i - 1 ] - a [ i - 1 ] <NEWLINE> <COMMENT> <NL> <DEDENT> count = 0 <NEWLINE> x = 0 <NEWLINE> m = [ 1 ] * ( n + 1 ) <NEWLINE> for j in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> m [ j ] = m [ j - 1 ] * 2 <NEWLINE> if m [ j ] > l [ j ] : <NEWLINE> <INDENT> m [ j ] = l [ j ] <NEWLINE> <DEDENT> if ( m [ j ] < a [ j ] ) or ( m [ j ] == a [ j ] and j != n ) : <NEWLINE> <COMMENT> <NL> <INDENT> x = 1 <NEWLINE> break <NEWLINE> <COMMENT> <NL> <DEDENT> count += m [ j ] <NEWLINE> m [ j ] -= a [ j ] <NEWLINE> <DEDENT> count += 1 <NEWLINE> <NL> if x == 1 or a [ 0 ] != 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> elif n == 0 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( count ) <NEWLINE> <DEDENT>
import sys <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> l = [ ] <NEWLINE> <NL> if A [ 0 ] != 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> for i in range ( N + 1 ) : <NEWLINE> <INDENT> if A [ i ] > 2 * A [ i + 1 ] : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> temp = 1 <NEWLINE> for i in range ( N + 1 ) : <NEWLINE> <INDENT> l . append ( temp - A [ i ] ) <NEWLINE> temp = ( temp - A [ i ] ) * 2 <NEWLINE> <NL> <DEDENT> for i in range ( N + 1 ) : <NEWLINE> <INDENT> if l [ i ] < 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> ans = 1 <NEWLINE> node = 0 <NEWLINE> for i in range ( N , 0 , - 1 ) : <NEWLINE> <INDENT> if l [ i - 1 ] >= node + A [ i ] : <NEWLINE> <INDENT> node += A [ i ] <NEWLINE> ans += node <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += node + A [ i ] <NEWLINE> node = l [ i - 1 ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input . split ( ) ) ) <NEWLINE> <NL> def solve ( N , A ) : <NEWLINE> <INDENT> if not A or A [ 0 ] != 1 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> return <NEWLINE> <NL> prev = 1 <NEWLINE> rt = 1 <NEWLINE> for a in A [ 1 : ] : <NEWLINE> <INDENT> if a > prev * 2 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> return <NEWLINE> <DEDENT> rt += ( prev * 2 - a ) % ( prev * 2 ) <NEWLINE> prev = a <NEWLINE> <NL> print ( rt ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> solve ( N , A ) <NEWLINE>
n , * a , t = map ( int , open ( 0 ) . read ( ) . split ( ) ) , sum ( a ) <NEWLINE> v = w = 1 <NEWLINE> for q in a : <NEWLINE> <INDENT> w = min ( 2 * ( w - q ) , t : = t - q ) ; ( v : = v + w ) <NEWLINE> if w < 0 : print ( - 1 ) ; exit ( ) <NEWLINE> <DEDENT> print ( v ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> bottom = sum ( A ) <NEWLINE> <NL> if A [ 0 ] >= 1 and N < > 1 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> ret = 1 <NEWLINE> children = 1 - A [ 0 ] <NEWLINE> bottom -= A [ 0 ] <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> children = children * 2 - A [ i + 1 ] <NEWLINE> if children <= - 1 : <NEWLINE> <INDENT> ret = - 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> bottom -= A [ i + 1 ] <NEWLINE> if children >= bottom : <NEWLINE> <INDENT> children = bottom <NEWLINE> <DEDENT> ret += children + A [ i + 1 ] <NEWLINE> <DEDENT> print ( ret ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a_min = [ 0 ] * ( n + 1 ) <NEWLINE> a_min [ n ] = a [ n ] <NEWLINE> for i in range ( n - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> a_min [ i ] = a [ i ] + a_min [ i + 1 ] <NEWLINE> <NL> <DEDENT> b = [ 1 ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> tmp = b [ i ] - a [ i ] <NEWLINE> if tmp < 1 or tmp * 2 < a [ i + 1 ] : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if n == 0 : <NEWLINE> <INDENT> ans = 1 if a [ 0 ] == 1 else - 1 <NEWLINE> print ( ans ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( sum ( b ) ) <NEWLINE> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> pm = sum ( A ) <NEWLINE> te = 1 <NEWLINE> if A [ 0 ] != 0 or A [ N ] == 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in A : <NEWLINE> <INDENT> pm -= i <NEWLINE> e = min ( ( e - i ) * 2 , pm ) <NEWLINE> if e < 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> te += e <NEWLINE> <DEDENT> if e < 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( te ) <NEWLINE> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> B = [ ] <NEWLINE> <NL> if N == 0 : <NEWLINE> <INDENT> if A [ 0 ] != 1 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if A [ 0 ] != 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> B . append ( 1 ) <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> B . append ( ( B [ i - 1 ] - A [ i - 1 ] ) * 2 ) <NEWLINE> if ( A [ i ] > B [ i ] or ( A [ i ] == B [ i ] and i != N ) ) : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> ans = 0 <NEWLINE> ans += A [ N ] <NEWLINE> B [ N ] = A [ N ] <NEWLINE> for i in range ( N , - 1 , - 1 ) : <NEWLINE> <INDENT> ans += min ( B [ i ] , B [ i + 1 ] + A [ i ] ) <NEWLINE> B [ i ] = min ( B [ i ] , B [ i + 1 ] + A [ i ] ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT>
from itertools import accumulate <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c = list ( accumulate ( a ) ) <NEWLINE> b = [ 0 ] * ( n + 1 ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> def f ( ) : <NEWLINE> <INDENT> global n , a , b <NEWLINE> if n == 0 : <NEWLINE> <NL> for i in range ( n + 1 ) : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> b [ 0 ] = min ( c [ n ] - c [ 0 ] , 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> b [ i ] = min ( 2 * ( b [ i - 1 ] - a [ i - 1 ] ) , c [ n ] - c [ i - 1 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> if n == 0 : <NEWLINE> <INDENT> if a [ 0 ] != 1 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> <DEDENT> elif b [ n ] != a [ n ] : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( sum ( b ) ) <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> f ( ) <NEWLINE>
n , * a = map ( int , open ( 0 ) . read ( ) . split ( ) ) <NEWLINE> t , v , w = sum ( a ) , 1 , 0 <NEWLINE> for q in a : <NEWLINE> <INDENT> w = min ( 2 * ( v [ - 1 ] - q ) , t : = t - q ) <NEWLINE> v += w <NEWLINE> if w < 0 : print ( - 1 ) ; exit ( ) <NEWLINE> <DEDENT> print ( v ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> <INDENT> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> s = [ 0 ] * ( N + 2 ) <NEWLINE> for i in range ( N + 1 ) : <NEWLINE> <INDENT> s [ i + 1 ] = s [ i ] + A [ i ] <NEWLINE> <DEDENT> node , leaf = 1 , 1 <NEWLINE> for d in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> if leaf < A [ d ] : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> break <NEWLINE> <DEDENT> leaf = min ( ( leaf - A [ d - 1 ] ) * 2 , s [ N + 1 ] - s [ d ] ) <NEWLINE> if leaf < A [ d ] : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> break <NEWLINE> <DEDENT> node += leaf <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( node ) <NEWLINE> <DEDENT> <DEDENT>
input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ok = True <NEWLINE> <NL> v = [ 0 for i in range ( n + 2 ) ] <NEWLINE> import time <NEWLINE> <NL> <COMMENT> <NL> nextv = 0 <NEWLINE> <NL> nec = 2 ** n <NEWLINE> <NL> for i in range ( n , - 1 , - 1 ) : <NEWLINE> <NL> <INDENT> if nec >= v [ i + 1 ] + a [ i ] : <NEWLINE> <INDENT> v [ i ] = v [ i + 1 ] + a [ i ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> v [ i ] = nec <NEWLINE> <NL> <DEDENT> nec = nec >> 1 <NEWLINE> <NL> <NL> <NL> <COMMENT> <NL> <NL> <DEDENT> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if v [ i - 1 ] - a [ i - 1 ] < 0 : <NEWLINE> <INDENT> ok = False <NEWLINE> break <NEWLINE> <DEDENT> if ( v [ i - 1 ] - a [ i - 1 ] ) * 2 < v [ i ] : <NEWLINE> <INDENT> v [ i ] = ( v [ i - 1 ] - a [ i - 1 ] ) * 2 <NEWLINE> <NL> <DEDENT> <DEDENT> if a [ 0 ] != 0 : ok = False <NEWLINE> <NL> ans = sum ( v ) <NEWLINE> <NL> if ans == 0 : ok = False <NEWLINE> <NL> if ok : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT>
<NL> a = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ch = [ 1 ] <NEWLINE> t = 0 <NEWLINE> for e , i in enumerate ( A ) : <NEWLINE> <INDENT> t += i <NEWLINE> if t >= 2 ** i : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> cH = [ 1 ] <NEWLINE> if A [ 0 ] > 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> for e , i in enumerate ( A [ 1 : ] ) : <NEWLINE> <INDENT> cH . append ( cH [ - 1 ] * 2 - i ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> cH = cH [ : - 1 ] <NEWLINE> cH . append ( cH [ - 1 ] * 2 ) <NEWLINE> cH = cH [ : : - 1 ] <NEWLINE> <COMMENT> <NL> <NL> if cH [ 0 ] <NEWLINE> <NL> if 0 in cH : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> A = A [ : : - 1 ] <NEWLINE> <NL> ans = 0 <NEWLINE> n = 0 <NEWLINE> for e , i in enumerate ( A [ : ] ) : <NEWLINE> <COMMENT> <NL> <INDENT> if n // 2 + ( n % 2 != 0 ) > cH [ e ] : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> if n <= cH [ e ] : <NEWLINE> <COMMENT> <NL> <INDENT> ans += n + i <NEWLINE> n += i <NEWLINE> <DEDENT> else : <NEWLINE> <COMMENT> <NL> <INDENT> ans += cH [ e ] + i <NEWLINE> n = cH [ e ] + i <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
32. txt <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> bottom = sum ( A ) <NEWLINE> <NL> if A [ 0 ] >= 1 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> ret = 1 <NEWLINE> children = 1 - A [ 0 ] <NEWLINE> bottom -= A [ 0 ] <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> children = children * 2 - A [ i + 1 ] <NEWLINE> if children <= - 1 : <NEWLINE> <INDENT> ret = - 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> bottom -= A [ i + 1 ] <NEWLINE> if children >= bottom : <NEWLINE> <INDENT> children = bottom <NEWLINE> <DEDENT> ret += children + A [ i + 1 ] <NEWLINE> <DEDENT> print ( ret ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 8 ) <NEWLINE> T = int ( input ( ) ) <NEWLINE> <NL> def solve ( N ) : <NEWLINE> <INDENT> if N == 0 : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> if N == 1 : <NEWLINE> <INDENT> return D <NEWLINE> <DEDENT> if N in dic : <NEWLINE> <INDENT> return dic [ N ] <NEWLINE> <DEDENT> tmp = N * D <NEWLINE> if N % 2 == 0 : <NEWLINE> <INDENT> tmp = min ( tmp , solve ( N // 2 ) + A ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> tmp = min ( tmp , solve ( ( N - 1 ) // 2 ) + A + D ) <NEWLINE> <DEDENT> b = N % 3 <NEWLINE> if N % 3 == 0 : <NEWLINE> <INDENT> tmp = min ( tmp , solve ( N // 3 ) + B ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> tmp = min ( tmp , solve ( ( N + ( 3 - b ) ) // 3 ) + B + D , solve ( ( N - b ) // 3 ) + B + 2 * D ) <NEWLINE> <DEDENT> c = N % 5 <NEWLINE> if N % 5 == 0 : <NEWLINE> <INDENT> tmp = min ( tmp , solve ( N // 5 ) + C ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> tmp = min ( tmp , solve ( ( N - c ) // 5 ) + C + D * c , , solve ( ( N + ( 5 - c ) ) // 5 ) + C + D * ( 5 - c ) ) <NEWLINE> <DEDENT> dic [ N ] = tmp <NEWLINE> return tmp <NEWLINE> <NL> <DEDENT> for _ in range ( T ) : <NEWLINE> <INDENT> N , A , B , C , D = map ( int , input ( ) . split ( ) ) <NEWLINE> dic = { } <NEWLINE> print ( solve ( N ) ) <NEWLINE> <DEDENT>
T = int ( intput ( ) ) <NEWLINE> <NL> def solve ( N , A , B , C , D ) : <NEWLINE> <INDENT> def pay ( x , coin = 0 ) : <NEWLINE> <INDENT> if x == 0 : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> out1 = x / 2 if x % 2 == 0 else float ( <STRING> ) <NEWLINE> out2 = x / 3 if x % 3 == 0 else float ( <STRING> ) <NEWLINE> out3 = x / 5 if x % 5 == 0 else float ( <STRING> ) <NEWLINE> out4 = x + 1 if x % 8 == 0 else float ( <STRING> ) <NEWLINE> out5 = x - 1 if x % 8 == 0 else float ( <STRING> ) <NEWLINE> return min ( pay ( out1 , coin + A ) , pay ( out2 , coin + B ) , pay ( out3 , coin + C ) , pay ( out4 , coin + D ) , pay ( out5 , coin + D ) ) <NEWLINE> <DEDENT> return pay ( N ) <NEWLINE> <NL> <DEDENT> for _ in range ( T ) : <NEWLINE> <INDENT> N , A , B , C , D = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( solve ( N , A , B , C , D ) ) <NEWLINE> <DEDENT>
T = int ( input ( ) ) <NEWLINE> for i in range ( T ) : <NEWLINE> <INDENT> N , A , B , C , D = map ( int , input ( ) . split ( ) ) <NEWLINE> memo = { 0 : 0 , 1 : D } <NEWLINE> def f ( n ) : <NEWLINE> <INDENT> if n in memo : <NEWLINE> <INDENT> return memo [ n ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> res = D * n <NEWLINE> r2 = n % 2 <NEWLINE> r3 = n % 3 <NEWLINE> r5 = n % 5 <NEWLINE> res = min ( res , f ( n // 2 ) + A + r2 * D , f ( n // 3 ) + B + r3 * D , f ( n // 5 ) + C + r5 * D ) <NEWLINE> res = min ( res , f ( ( n + 1 ) // 2 ) + A + ( 2 - r2 ) * D , f ( ( n + 2 ) // 3 + 1 ) + B + ( 3 - r3 ) * D , f ( ( n + 4 ) // 5 + 1 ) + C + ( 5 - r5 ) * D ) <NEWLINE> memo [ n ] = res <NEWLINE> return res <NEWLINE> <DEDENT> <DEDENT> print ( f ( N ) ) <NEWLINE> <DEDENT>
from functools import lru_cache <NEWLINE> <NL> T = int ( input ( ) ) <NEWLINE> <NL> caseList = [ ] <NEWLINE> <NL> for i in range ( T ) : <NEWLINE> <INDENT> caseList . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> <NL> <DEDENT> @ lru_cache ( maxsize = None ) <NEWLINE> def solve ( n , A , B , C , D ) : <NEWLINE> <INDENT> if n == 0 : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> if n == 1 : <NEWLINE> <INDENT> return D <NEWLINE> <DEDENT> if n == 2 : <NEWLINE> <INDENT> return min ( D + D , A + D ) <NEWLINE> <NL> <DEDENT> ans = n * D <NEWLINE> <NL> for num , cost in zip ( [ 2 , 3 , 5 ] , [ A , B , C ] ) : <NEWLINE> <INDENT> ans = min ( <NEWLINE> <INDENT> f ( ( n + ( num - n % num ) ) // num , A , B , C , D ) + cost + D * ( num - n % num ) , <NEWLINE> f ( ( n - n % num ) // num , A , B , C , D ) + cost + D * ( n % num ) , <NEWLINE> ans , <NEWLINE> <DEDENT> ) <NEWLINE> <NL> <DEDENT> return ans <NEWLINE> <NL> <NL> <DEDENT> for N , A , B , C , D in caseList : <NEWLINE> <INDENT> print ( solve ( N , A , B , C , D ) ) <NEWLINE> <DEDENT>
<NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <NL> def func ( i ) : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> elif i == 1 : <NEWLINE> <INDENT> return d <NEWLINE> <DEDENT> elif i in memo : <NEWLINE> <INDENT> return memo [ i ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> min_val = int ( min ( <NEWLINE> <INDENT> d * i , <NEWLINE> d * abs ( i - i // 2 * 2 ) + a + func ( i // 2 ) , <NEWLINE> d * abs ( i - ( i + 1 ) // 2 * 2 ) + a + func ( ( i + 1 ) / 2 ) , <NEWLINE> d * abs ( i - i // 3 * 3 ) + b + func ( i // 3 ) , <NEWLINE> d * abs ( i - ( i + 2 ) // 3 * 3 ) + b + func ( ( i + 2 ) // 3 ) , <NEWLINE> d * abs ( i - i // 5 * 5 ) + c + func ( i // 5 ) , <NEWLINE> d * abs ( i - ( i + 4 ) // 5 * 5 ) + c + func ( ( i + 4 ) // 5 ) <NEWLINE> <DEDENT> ) ) <NEWLINE> <NL> <DEDENT> memo [ i ] = min_val <NEWLINE> return min_val <NEWLINE> <NL> <NL> <NL> <DEDENT> t = int ( input ( ) ) <NEWLINE> <NL> nabcd = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( t ) ] <NEWLINE> <NL> <NL> for i in range ( t ) : <NEWLINE> <INDENT> n = nabcd [ i ] [ 0 ] <NEWLINE> a = nabcd [ i ] [ 1 ] <NEWLINE> b = nabcd [ i ] [ 2 ] <NEWLINE> c = nabcd [ i ] [ 3 ] <NEWLINE> d = nabcd [ i ] [ 4 ] <NEWLINE> <NL> memo = { } <NEWLINE> <NL> <NL> print ( func ( n ) ) <NEWLINE> <COMMENT> <NL> <DEDENT>
def f ( k ) : <NEWLINE> <INDENT> if k == 1 : return d <NEWLINE> if k == 0 : return 0 <NEWLINE> if k in dic : return m [ k ] <NEWLINE> s = k * d <NEWLINE> s = min ( s , f ( k // 2 ) + a + k % 2 * d , f ( ( k + 1 ) // 2 ) + a + - k % 2 * d , f ( k // 3 ) + b + k % 3 * d , f ( ( k + 2 ) // 3 ) + b + - k % 3 * d , f ( k // 5 ) + c + k % 5 * d , f ( ( k + 4 ) // 5 ) + c + - k % 5 * d ) <NEWLINE> m [ k ] = s <NEWLINE> return s <NEWLINE> <DEDENT> for _ in range ( int ( input ( ) ) ) : <NEWLINE> <INDENT> m = { } <NEWLINE> n , a , b , c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( s ( n ) ) <NEWLINE> <DEDENT>
import heapq <NEWLINE> import collections <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> INF = 10 ** 30 <NEWLINE> T = int ( input ( ) ) <NEWLINE> cases = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( T ) ] <NEWLINE> for case in cases : <NEWLINE> <INDENT> N , A , B , C , D = case <NEWLINE> coins = collections . defaultdict ( lambda : INF ) <NEWLINE> coins [ 0 ] = 0 <NEWLINE> frontier = [ ( 0 , 0 ) ] <NEWLINE> ans = 0 <NEWLINE> while len ( frontier ) > 0 : <NEWLINE> <INDENT> c , node = heapq . heappop ( frontier ) <NEWLINE> if node == N : <NEWLINE> <INDENT> ans = c <NEWLINE> break <NEWLINE> <DEDENT> candidates = [ <NEWLINE> <INDENT> ( c + A , 2 * node ) , <NEWLINE> ( c + B , 3 * node ) , <NEWLINE> ( c + C , 5 * node ) , <NEWLINE> ( c + D , node + 1 ) , <NEWLINE> ( c + D , node - 1 ) <NEWLINE> <DEDENT> ] <NEWLINE> for cand in candidates : <NEWLINE> <INDENT> if cand [ 1 ] > 0 and cand [ 0 ] < coins [ cand [ 1 ] ] : <NEWLINE> <INDENT> heapq . heappush ( frontier , cand ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
T = int ( input ( ) ) <NEWLINE> for i in range ( T ) : <NEWLINE> <INDENT> N , a , b , c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> memo = { } <NEWLINE> memo [ 0 ] = 0 <NEWLINE> memo [ 1 ] = d <NEWLINE> <NL> def f ( n ) : <NEWLINE> <INDENT> if n in memo : <NEWLINE> <INDENT> return memo [ n ] <NEWLINE> <DEDENT> e2 , e3 , e5 = n % 2 , n % 3 , n % 5 <NEWLINE> dd = min ( d * n , d * 2 + a + f ( ( n - e2 ) // 2 ) , d * 2 + a + f ( ( n + e2 ) // 2 ) , d * e3 + b + f ( ( n - e3 ) // 3 ) , d * ( 3 - e3 ) + b + f ( ( n + 3 - e3 ) // 3 ) , d * e5 + c + f ( ( n - e5 ) // 5 ) , d * ( 5 - e5 ) + c + f ( ( n + 5 - e5 ) // 5 ) ) <NEWLINE> memo [ n ] = dd <NEWLINE> return dd <NEWLINE> <DEDENT> print ( f ( n ) ) <NEWLINE> <DEDENT>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 8 ) <NEWLINE> import functools <NEWLINE> @ functools . lru_cache ( maxsize = None ) <NEWLINE> def solve ( N ) : <NEWLINE> <INDENT> if N == 0 : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> if N == 1 : <NEWLINE> <INDENT> return D <NEWLINE> <DEDENT> tmp = N * D <NEWLINE> if N % 2 == 0 : <NEWLINE> <INDENT> tmp = min ( tmp , solve ( N // 2 ) + A ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> tmp = min ( tmp , solve ( ( N - 1 ) // 2 ) + A + D , solve ( ( N + 1 ) // 2 ) + A + D ) <NEWLINE> <DEDENT> if N % 3 == 0 : <NEWLINE> <INDENT> tmp = min ( tmp , solve ( N // 3 ) + B ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> b = N % 3 <NEWLINE> tmp = min ( tmp , solve ( ( N + ( 3 - b ) ) // 3 ) + B + ( 3 - b ) * D , solve ( ( N - b ) // 3 ) + B + b * D ) <NEWLINE> <DEDENT> if N % 5 == 0 : <NEWLINE> <INDENT> tmp = min ( tmp , solve ( N // 5 ) + C ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> c = N % 5 <NEWLINE> tmp = min ( tmp , solve ( ( N - c ) // 5 ) + C + D * c , solve ( ( N + ( 5 - c ) ) // 5 ) + C + D * ( 5 - c ) ) <NEWLINE> <DEDENT> return tmp <NEWLINE> <NL> <DEDENT> for _ in range ( T ) : <NEWLINE> <INDENT> N , A , B , C , D = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( solve ( N ) ) <NEWLINE> <DEDENT>
from sys import setrecursionlimit <NEWLINE> setrecursionlimit ( 1000000 ) <NEWLINE> def ans ( n , l , p , c ) : <NEWLINE> <INDENT> if p > n : <NEWLINE> <INDENT> return ( ( p - n ) * l [ 3 ] ) + c <NEWLINE> <DEDENT> elif p == n : <NEWLINE> <INDENT> return c <NEWLINE> <DEDENT> elif n / p <= 2 : <NEWLINE> <INDENT> return min ( [ ans ( n , l , p * 2 , c + l [ 0 ] ) , ans ( n , l , p * 3 , c + l [ 1 ] ) , ans ( n , l , p * 5 , c + l [ 2 ] ) , ( ( n - p ) * l [ 3 ] ) + c ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return min ( [ ans ( n , l , p * 2 , c + l [ 0 ] ) , ans ( n , l , p * 3 , c + l [ 1 ] ) , ans ( n , l , p * 5 , c + l [ 2 ] ) , ans ( n , l , p + 1 , c + l [ 3 ] ) ] ) <NEWLINE> <DEDENT> <DEDENT> for _ in range ( int ( input ( ) ) ) : <NEWLINE> <INDENT> n , a , b , c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> Ans = ans ( n , [ a , b , c , d ] , 0 + 1 , 0 + d ) <NEWLINE> print ( Ans ) <NEWLINE> <DEDENT>
a <NEWLINE>
from collections import defaultdict <NEWLINE> import math <NEWLINE> import heapq <NEWLINE> <NL> T = int ( f . input ( ) ) <NEWLINE> test_cases = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( T ) ] <NEWLINE> <NL> <NL> for test_num in range ( T ) : <NEWLINE> <INDENT> hq = [ ] <NEWLINE> kake_patterns = [ 2 , 3 , 5 ] <NEWLINE> cost_patterns = [ test_cases [ test_num ] [ 1 ] , test_cases [ test_num ] [ 2 ] , test_cases [ test_num ] [ 3 ] ] <NEWLINE> plmi_cost = test_cases [ test_num ] [ 4 ] <NEWLINE> heapq . heappush ( hq , - test_cases [ test_num ] [ 0 ] ) <NEWLINE> memo = defaultdict ( int ) <NEWLINE> memo [ test_cases [ test_num ] [ 0 ] ] = 0 <NEWLINE> memo [ 0 ] = plmi_cost * test_cases [ test_num ] [ 0 ] <NEWLINE> <NL> while len ( hq ) > 0 : <NEWLINE> <INDENT> checking = heapq . heappop ( hq ) <NEWLINE> checking = - checking <NEWLINE> cost = memo [ checking ] <NEWLINE> <NL> if checking in [ 0 , 1 ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> for i , kake in enumerate ( kake_patterns ) : <NEWLINE> <INDENT> devided1 = math . floor ( checking / kake ) <NEWLINE> devided2 = math . ceil ( checking / kake ) <NEWLINE> <NL> added_cost1 = cost + abs ( math . floor ( checking / kake ) * kake - checking ) * plmi_cost + cost_patterns [ i ] <NEWLINE> added_cost2 = cost + abs ( math . ceil ( checking / kake ) * kake - checking ) * plmi_cost + cost_patterns [ i ] <NEWLINE> <NL> if devided1 in memo : <NEWLINE> <INDENT> if added_cost1 < memo [ devided1 ] : <NEWLINE> <INDENT> memo [ devided1 ] = added_cost1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> memo [ devided1 ] = added_cost1 <NEWLINE> heapq . heappush ( hq , - devided1 ) <NEWLINE> <NL> <DEDENT> if devided2 in memo : <NEWLINE> <INDENT> if added_cost2 < memo [ devided2 ] : <NEWLINE> <INDENT> memo [ devided2 ] = added_cost2 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> memo [ devided2 ] = added_cost2 <NEWLINE> heapq . heappush ( hq , - devided2 ) <NEWLINE> <NL> <DEDENT> if added_cost1 + devided1 * plmi_cost < memo [ 0 ] : <NEWLINE> <INDENT> memo [ 0 ] = added_cost1 + devided1 * plmi_cost <NEWLINE> <DEDENT> if added_cost2 + devided2 * plmi_cost < memo [ 0 ] : <NEWLINE> <INDENT> memo [ 0 ] = added_cost2 + devided2 * plmi_cost <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( memo [ 0 ] ) <NEWLINE> <DEDENT>
import sys <NEWLINE> from numba import njit <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> T = int ( input ( ) ) <NEWLINE> for _ in range ( T ) : <NEWLINE> <INDENT> n , a , b , c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> dp = dict ( ) <NEWLINE> dp [ n ] = 0 <NEWLINE> <NL> def add ( x , v ) : <NEWLINE> <INDENT> if x not in dp : <NEWLINE> <INDENT> dp [ x ] = v <NEWLINE> return True <NEWLINE> <DEDENT> elif dp [ x ] > v : <NEWLINE> <INDENT> dp [ x ] = v <NEWLINE> return True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> <DEDENT> @ njit <NEWLINE> def dfs ( x ) : <NEWLINE> <INDENT> if x == 0 : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> if x % 2 == 0 : <NEWLINE> <INDENT> v = min ( a , d * ( x // 2 ) ) + dp [ x ] <NEWLINE> if add ( x // 2 , v ) : <NEWLINE> <INDENT> dfs ( x // 2 ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> v = min ( a + d , d + d * ( x // 2 ) ) + dp [ x ] <NEWLINE> if add ( x // 2 , v ) : <NEWLINE> <INDENT> dfs ( x // 2 ) <NEWLINE> <DEDENT> v = min ( a + d , d + d * ( x // 2 + 1 ) ) + dp [ x ] <NEWLINE> if add ( ( x + 1 ) // 2 , v ) : <NEWLINE> <INDENT> dfs ( ( x + 1 ) // 2 ) <NEWLINE> <NL> <DEDENT> <DEDENT> if x % 3 == 0 : <NEWLINE> <INDENT> v = min ( b , d * 2 * ( x // 3 ) ) + dp [ x ] <NEWLINE> if add ( x // 3 , v ) : <NEWLINE> <INDENT> dfs ( x // 3 ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> m = x % 3 <NEWLINE> v = min ( b + d * m , d * m + d * 2 * ( x // 3 ) ) + dp [ x ] <NEWLINE> if add ( x // 3 , v ) : <NEWLINE> <INDENT> dfs ( x // 3 ) <NEWLINE> <DEDENT> v = min ( b + d * ( 3 - m ) , d * ( 3 - m ) + d * 2 * ( x // 3 + 1 ) ) + dp [ x ] <NEWLINE> if add ( x // 3 + 1 , v ) : <NEWLINE> <INDENT> dfs ( x // 3 + 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> if x % 5 == 0 : <NEWLINE> <INDENT> v = min ( c , d * 4 * ( x // 5 ) ) + dp [ x ] <NEWLINE> if add ( x // 5 , v ) : <NEWLINE> <INDENT> dfs ( x // 5 ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> m = x % 5 <NEWLINE> v = min ( c + d * m , d * m + d * 4 * ( x // 5 ) ) + dp [ x ] <NEWLINE> if add ( x // 5 , v ) : <NEWLINE> <INDENT> dfs ( x // 5 ) <NEWLINE> <DEDENT> v = min ( c + d * ( 5 - m ) , d * ( 5 - m ) + d * 4 * ( x // 5 + 1 ) ) + dp [ x ] <NEWLINE> if add ( x // 5 + 1 , v ) : <NEWLINE> <INDENT> dfs ( x // 5 + 1 ) <NEWLINE> <DEDENT> <DEDENT> return <NEWLINE> <DEDENT> dfs ( n ) <NEWLINE> print ( dp [ 0 ] ) <NEWLINE> <DEDENT>
import heapq <NEWLINE> <NL> <NL> <NL> def pay ( N , A , B , C , D ) : <NEWLINE> <INDENT> q = [ ] <NEWLINE> heapq . heapify ( q ) <NEWLINE> num = { } <NEWLINE> num [ 0 ] = 0 <NEWLINE> num [ - 1 ] = - 1 <NEWLINE> heapq . heappush ( q , ( 0 , 0 ) ) <NEWLINE> while q : <NEWLINE> <INDENT> c , n = heapq . heappop ( q ) <NEWLINE> <COMMENT> <NL> if n == N : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if num . setdefault ( n * 2 , N * D + 1 ) > c + A : <NEWLINE> <INDENT> heapq . heappush ( q , ( c + A , n * 2 ) ) <NEWLINE> num [ n * 2 ] = c + A <NEWLINE> <DEDENT> if num . setdefault ( n * 3 , N * D + 1 ) > c + B : <NEWLINE> <INDENT> heapq . heappush ( q , ( c + B , n * 3 ) ) <NEWLINE> num [ n * 3 ] = c + B <NEWLINE> <DEDENT> if num . setdefault ( n * 5 , N * D + 1 ) > c + C : <NEWLINE> <INDENT> heapq . heappush ( q , ( c + C , n * 5 ) ) <NEWLINE> num [ n * 5 ] = c + C <NEWLINE> <DEDENT> if num . setdefault ( n + 1 , N * D + 1 ) > c + D : <NEWLINE> <INDENT> heapq . heappush ( q , ( c + D , n + 1 ) ) <NEWLINE> num [ n + 1 ] = c + D <NEWLINE> <DEDENT> if num . setdefault ( n - 1 , N * D + 1 ) > c + D : <NEWLINE> <INDENT> heapq . heappush ( q , ( c + D , n - 1 ) ) <NEWLINE> num [ n - 1 ] = c + D <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> print ( num . setdefault ( N , - 1 ) ) <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> T = int ( input ( ) ) <NEWLINE> for i in range ( T ) : <NEWLINE> <INDENT> N , A , B , C , D = map ( int , input ( ) . split ( ) ) <NEWLINE> pay ( N , A , B , C , D ) <NEWLINE> <DEDENT>
t = int ( input ( ) ) <NEWLINE> def f ( x ) : <NEWLINE> <INDENT> if x <= 1 : <NEWLINE> <INDENT> return D * x <NEWLINE> <DEDENT> ret = D * x <NEWLINE> <NL> if x % 2 == 0 : <NEWLINE> <INDENT> ret = min ( ret , f ( x // 2 ) + A ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ret = min ( ret , f ( x // 2 ) + A + D , f ( x // 2 + 1 ) + A + D ) <NEWLINE> <NL> <DEDENT> if x % 3 == 0 : <NEWLINE> <INDENT> ret = min ( ret , f ( x // 3 ) + B ) <NEWLINE> <DEDENT> elif x % 3 == 1 : <NEWLINE> <INDENT> ret = min ( ret , f ( x // 3 ) + B + D ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ret = min ( ret , f ( x // 3 + 1 ) + B + D ) <NEWLINE> <NL> <DEDENT> if x % 5 <= 2 : <NEWLINE> <INDENT> ret = min ( ret , f ( x // 5 ) + C + D * ( x % 5 ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ret = min ( ret , f ( x // 5 + 1 ) + C + D * ( 5 - x % 5 ) ) <NEWLINE> <DEDENT> return ret <NEWLINE> <DEDENT> for _ in range ( t ) : <NEWLINE> <INDENT> n , A , B , C , D = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( f ( n ) ) <NEWLINE> <NL> <DEDENT>
T = int ( input ( ) ) <NEWLINE> N = [ ] <NEWLINE> <NL> for i in range ( T ) : <NEWLINE> <INDENT> x = 0 <NEWLINE> N = map ( int , input ( ) . split ( ) ) <NEWLINE> x += N [ 3 ] <NEWLINE> min = min ( N ) <NEWLINE> <DEDENT> if N [ 0 ] == 2 : <NEWLINE> <INDENT> print ( x + N [ 1 ] ) <NEWLINE> <DEDENT> elif N [ 0 ] == 3 : <NEWLINE> <INDENT> print ( x + N [ 2 ] ) <NEWLINE> <DEDENT> elif N [ 0 ] == 5 : <NEWLINE> <INDENT> print ( x + N [ 3 ] ) <NEWLINE> <DEDENT> elif N [ 0 ] % min == 0 : <NEWLINE> <INDENT> print ( x + ( min * ( N [ 0 ] / min ) ) ) <NEWLINE> <DEDENT> elif N [ 0 ] % min == 1 : <NEWLINE> <INDENT> print ( x + ( min * ( N [ 0 ] / min ) + N [ 3 ] ) ) <NEWLINE> <NL> <DEDENT>
check = dict ( ) <NEWLINE> N , b , d = 0 , [ ] , 0 <NEWLINE> <COMMENT> <NL> <NL> def dfs_sub ( n , ttf , cha ) : <NEWLINE> <INDENT> global check , d <NEWLINE> check [ 0 ] = min ( check [ n ] + n * d , check [ 0 ] ) if 0 in check else check [ n ] + n * d <NEWLINE> if n // ttf == 0 : <NEWLINE> <INDENT> check [ n // ttf ] = min ( check [ n ] + ( n % ttf ) * d , check [ n // ttf ] ) if n // ttf in check else check [ n ] + ( n % ttf ) * d <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if n // ttf in check : <NEWLINE> <INDENT> if check [ n // ttf ] > check [ n ] + ( n % ttf ) * d + cha : <NEWLINE> <INDENT> check [ n // ttf ] = check [ n ] + ( n % ttf ) * d + cha <NEWLINE> dfs ( n // ttf ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> check [ n // ttf ] = check [ n ] + ( n % ttf ) * d + cha <NEWLINE> dfs ( n // ttf ) <NEWLINE> <DEDENT> <DEDENT> if 1 + n // ttf in check : <NEWLINE> <INDENT> if check [ 1 + n // ttf ] > check [ n ] + ( ttf - n % ttf ) * d + cha : <NEWLINE> <INDENT> check [ 1 + n // ttf ] = check [ n ] + ( ttf - n % ttf ) * d + cha <NEWLINE> dfs ( 1 + n // ttf ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> check [ 1 + n // ttf ] = check [ n ] + ( ttf - n % ttf ) * d + cha <NEWLINE> dfs ( 1 + n // ttf ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def dfs ( n ) : <NEWLINE> <INDENT> global b , check , d <NEWLINE> for i , j in zip ( [ 2 , 3 , 5 ] , b ) : <NEWLINE> <INDENT> dfs_sub ( n , i , j ) <NEWLINE> <NL> <DEDENT> <DEDENT> t = int ( input ( ) ) <NEWLINE> for i in range ( t ) : <NEWLINE> <INDENT> N , * b , d = map ( int , input ( ) . split ( ) ) <NEWLINE> check = { N : 0 } <NEWLINE> dfs ( N ) <NEWLINE> print ( check [ 0 ] ) <NEWLINE> <DEDENT>
t = int ( input ( ) ) <NEWLINE> <NL> def solve ( n , a , b , c , d ) : <NEWLINE> <INDENT> sol = [ n * d ] <NEWLINE> if n >= 2 : <NEWLINE> <INDENT> if n % 2 == 0 : <NEWLINE> <INDENT> sol . append ( a + solve ( n // 2 , a , b , c , d ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> sol . append ( a + d + solve ( ( n + 1 ) // 2 , a , b , c , d ) ) <NEWLINE> sol . append ( a + d + solve ( ( n - 1 ) // 2 , a , b , c , d ) ) <NEWLINE> <DEDENT> <DEDENT> if n >= 3 : <NEWLINE> <INDENT> if n % 3 == 0 : <NEWLINE> <INDENT> sol . append ( b + solve ( n // 3 , a , b , c , d ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> bd = n % 3 <NEWLINE> sol . append ( b + bd * d + solve ( ( n - bd ) // 3 , a , b , c , d ) ) <NEWLINE> sol . append ( b + ( 3 - bd ) * d + solve ( ( n - bd + 3 ) // 3 , a , b , c , d ) ) <NEWLINE> <DEDENT> <DEDENT> if n >= 5 : <NEWLINE> <INDENT> if n % 5 == 0 : <NEWLINE> <INDENT> sol . append ( c + solve ( n // 5 , a , b , c , d ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cd = n % 5 <NEWLINE> sol . append ( c + cd * d + solve ( ( n - cd ) // 5 , a , b , c , d ) ) <NEWLINE> sol . append ( c + ( 5 - cd ) * d + solve ( ( n - cd + 5 ) // 5 , a , b , c , d ) ) <NEWLINE> <DEDENT> <DEDENT> return min ( sol ) <NEWLINE> <NL> <DEDENT> for _ in range ( t ) : <NEWLINE> <INDENT> n , a , b , c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( solve ( n , a , b , c , d ) ) <NEWLINE> <DEDENT>
import numba <NEWLINE> import numpy as np <NEWLINE> N = int ( input ( ) ) <NEWLINE> P = np . array ( [ int ( c ) - 1 for c in input ( ) . split ( ) ] ) <NEWLINE> @ numba . njit ( <STRING> ) <NEWLINE> def proc ( N , P ) : <NEWLINE> <INDENT> ans = 0 <NEWLINE> Removed = np . zeros ( ( N , N ) , dtype = np . int8 ) <NEWLINE> Mat = np . zeros ( ( N , N ) , dtype = np . int16 ) <NEWLINE> Dy , Dx = [ 1 , 0 , - 1 , 0 ] , [ 0 , 1 , 0 , - 1 ] <NEWLINE> <NL> for y in range ( N ) : <NEWLINE> <INDENT> for x in range ( N ) : <NEWLINE> <INDENT> Mat [ y , x ] = min ( y , N - 1 - y , x , N - 1 - x ) <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> for i in range ( N * N ) : <NEWLINE> <INDENT> p = P [ i ] <NEWLINE> y , x = divmod ( p , N ) <NEWLINE> ans += Mat [ y ] [ x ] <NEWLINE> <COMMENT> <NL> Removed [ y ] [ x ] = 1 <NEWLINE> <COMMENT> <NL> st = [ ( y , x ) ] <NEWLINE> while st : <NEWLINE> <INDENT> vy , vx = st . pop ( ) <NEWLINE> vr = Removed [ vy ] [ vx ] <NEWLINE> val = Mat [ vy ] [ vx ] <NEWLINE> for dy , dx in zip ( Dy , Dx ) : <NEWLINE> <INDENT> uy = vy + dy <NEWLINE> ux = vx + dx <NEWLINE> if not ( 0 <= uy < N and 0 <= ux < N ) : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> ur = Removed [ uy ] [ ux ] <NEWLINE> if vr : <NEWLINE> <INDENT> if Mat [ uy ] [ ux ] >= val + 1 : <NEWLINE> <INDENT> Mat [ uy ] [ ux ] = val <NEWLINE> st . append ( ( uy , ux ) ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if Mat [ uy ] [ ux ] >= val + 2 : <NEWLINE> <INDENT> Mat [ uy ] [ ux ] = val + 1 <NEWLINE> st . append ( ( uy , ux ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <DEDENT> proc ( N , P ) <NEWLINE> <NL>
import numba <NEWLINE> import numpy as np <NEWLINE> N = int ( input ( ) ) <NEWLINE> P = np . array ( [ int ( c ) - 1 for c in input ( ) . split ( ) ] ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> @ numba . njit ( <STRING> ) <NEWLINE> def proc ( N , P ) : <NEWLINE> <INDENT> ans = 0 <NEWLINE> Removed = np . zeros ( ( 500 , 500 ) , dtype = np . int8 ) <NEWLINE> Mat = np . zeros ( ( 500 , 500 ) , dtype = np . int16 ) <NEWLINE> Dy , Dx = [ 1 , 0 , - 1 , 0 ] , [ 0 , 1 , 0 , - 1 ] <NEWLINE> <NL> for y in range ( N ) : <NEWLINE> <INDENT> for x in range ( N ) : <NEWLINE> <INDENT> Mat [ y , x ] = min ( y , N - 1 - y , x , N - 1 - x ) <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> Buf = [ ( 0 , 0 ) for _ in range ( 1 << 16 ) ] <NEWLINE> Buf_idx = 0 <NEWLINE> for i in range ( N * N ) : <NEWLINE> <INDENT> p = P [ i ] <NEWLINE> y , x = divmod ( p , N ) <NEWLINE> ans += Mat [ y , x ] <NEWLINE> Removed [ y , x ] = 1 <NEWLINE> Buf [ Buf_idx ] = ( y , x ) <NEWLINE> Buf_idx += 1 <NEWLINE> while Buf_idx : <NEWLINE> <INDENT> Buf_idx -= 1 <NEWLINE> vy , vx = Buf [ Buf_idx ] <NEWLINE> vr = Removed [ vy , vx ] <NEWLINE> val = Mat [ vy , vx ] <NEWLINE> <COMMENT> <NL> for j in range ( 4 ) : <NEWLINE> <INDENT> uy , ux = vy + Dy [ j ] , vx + Dx [ j ] <NEWLINE> if not ( 0 <= uy < N and 0 <= ux < N ) : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> ur = Removed [ uy , ux ] <NEWLINE> if vr : <NEWLINE> <INDENT> if Mat [ uy , ux ] >= val + 1 : <NEWLINE> <INDENT> Mat [ uy , ux ] = val <NEWLINE> Buf [ Buf_idx ] = ( uy , ux ) <NEWLINE> Buf_idx += 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if Mat [ uy , ux ] >= val + 2 : <NEWLINE> <INDENT> Mat [ uy , ux ] = val + 1 <NEWLINE> Buf [ Buf_idx ] = ( uy , ux ) <NEWLINE> Buf_idx += 1 <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> return ans <NEWLINE> <DEDENT> print ( proc ( N , P ) ) <NEWLINE> <NL>
import sys <NEWLINE> import numpy as np <NEWLINE> from numba import njit <NEWLINE> <NL> read = sys . stdin . buffer . read <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> readlines = sys . stdin . buffer . readlines <NEWLINE> <NL> <NL> @ numba . njit ( <STRING> , cache = True ) <NEWLINE> def proc ( N , P ) : <NEWLINE> <INDENT> ans = 0 <NEWLINE> Removed = np . zeros ( ( 500 , 500 ) , dtype = np . int8 ) <NEWLINE> Mat = np . zeros ( ( 500 , 500 ) , dtype = np . int16 ) <NEWLINE> Dy , Dx = np . array ( [ 1 , 0 , - 1 , 0 ] ) , np . array ( [ 0 , 1 , 0 , - 1 ] ) <NEWLINE> <NL> for y in range ( N ) : <NEWLINE> <INDENT> for x in range ( N ) : <NEWLINE> <INDENT> Mat [ y , x ] = min ( y , N - 1 - y , x , N - 1 - x ) <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> Buf = [ ( 0 , 0 ) for _ in range ( 1 << 17 ) ] <NEWLINE> Buf_idx = 0 <NEWLINE> for i in range ( N * N ) : <NEWLINE> <INDENT> p = P [ i ] <NEWLINE> y , x = divmod ( p , N ) <NEWLINE> ans += Mat [ y , x ] <NEWLINE> Removed [ y , x ] = 1 <NEWLINE> Buf [ Buf_idx ] = ( y , x ) <NEWLINE> Buf_idx += 1 <NEWLINE> while Buf_idx : <NEWLINE> <INDENT> Buf_idx -= 1 <NEWLINE> vy , vx = Buf [ Buf_idx ] <NEWLINE> vr = Removed [ vy , vx ] <NEWLINE> val = Mat [ vy , vx ] <NEWLINE> <COMMENT> <NL> for j in range ( 4 ) : <NEWLINE> <INDENT> uy , ux = vy + Dy [ j ] , vx + Dx [ j ] <NEWLINE> if not ( 0 <= uy < N and 0 <= ux < N ) : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> ur = Removed [ uy , ux ] <NEWLINE> if vr : <NEWLINE> <INDENT> if Mat [ uy , ux ] >= val + 1 : <NEWLINE> <INDENT> Mat [ uy , ux ] = val <NEWLINE> Buf [ Buf_idx ] = ( uy , ux ) <NEWLINE> Buf_idx += 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if Mat [ uy , ux ] >= val + 2 : <NEWLINE> <INDENT> Mat [ uy , ux ] = val + 1 <NEWLINE> Buf [ Buf_idx ] = ( uy , ux ) <NEWLINE> Buf_idx += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> return ans <NEWLINE> <DEDENT> print ( proc ( N , P ) ) <NEWLINE> <NL> N = int ( readline ( ) ) <NEWLINE> P = np . array ( read ( ) . split ( ) , np . int32 ) <NEWLINE> <NL> print ( solve ( N , P ) ) <NEWLINE>
<COMMENT> <NL> import sys <NEWLINE> <COMMENT> <NL> sysread = sys . stdin . readline <NEWLINE> read = sys . stdin . buffer . read <NEWLINE> from heapq import heappop , heappush <NEWLINE> <COMMENT> <NL> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> import numpy as np <NEWLINE> <COMMENT> <NL> from collections import deque <NEWLINE> <NL> def run ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> P = list ( map ( int , sysread ( ) . split ( ) ) ) <NEWLINE> seats = np . array ( [ [ 0 ] * N for _ in range ( N ) ] ) <NEWLINE> seen = [ [ 0 ] * N for _ in range ( N ) ] <COMMENT> <NEWLINE> left , right , up , down = 0 , N - 1 , 0 , N - 1 <NEWLINE> dist = 0 <NEWLINE> while True : <NEWLINE> <INDENT> seats [ up , left : right + 1 ] = dist <NEWLINE> seats [ down , left : right + 1 ] = dist <NEWLINE> seats [ up : down + 1 , left ] = dist <NEWLINE> seats [ up : down + 1 , right ] = dist <NEWLINE> left += 1 <NEWLINE> right -= 1 <NEWLINE> up += 1 <NEWLINE> down -= 1 <NEWLINE> dist += 1 <NEWLINE> if left > right or up > down : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> ret = 0 <NEWLINE> <COMMENT> <NL> for i in range ( N ** 2 ) : <NEWLINE> <COMMENT> <NL> <INDENT> way = { } <NEWLINE> cur_i , cur_j = ( P [ i ] - 1 ) // N , ( P [ i ] - 1 ) % N <NEWLINE> ret += seats [ cur_i , cur_j ] <NEWLINE> seen [ cur_i ] [ cur_j ] = 1 <NEWLINE> del_val = seats [ cur_i , cur_j ] <NEWLINE> stack = deque ( [ ( del_val , ( cur_i , cur_j ) ) ] ) <NEWLINE> <NL> while stack : <NEWLINE> <INDENT> del_val , ( cur_i , cur_j ) = stack . popleft ( ) <NEWLINE> way [ cur_i * N + cur_j ] = 0 <NEWLINE> for i , j in ( ( 1 , 0 ) , ( 0 , 1 ) , ( - 1 , 0 ) , ( 0 , - 1 ) ) : <NEWLINE> <INDENT> n_i = cur_i + i <NEWLINE> n_j = cur_j + j <NEWLINE> if 0 <= n_i <= N - 1 and 0 <= n_j <= N - 1 and n_i * N + n_j not in way . keys ( ) : <NEWLINE> <INDENT> if del_val < seats [ n_i , n_j ] : <NEWLINE> <INDENT> seats [ n_i , n_j ] = del_val <NEWLINE> stack . append ( ( del_val + 1 , ( n_i , n_j ) ) ) <NEWLINE> <DEDENT> elif seen [ n_i ] [ n_j ] : <NEWLINE> <INDENT> stack . append ( ( del_val , ( n_i , n_j ) ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ret ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> run ( ) <NEWLINE> from time import time <NEWLINE> a = time ( ) <NEWLINE> tmp = [ 0 ] * 25000 <NEWLINE> for i in range ( 25000 ) : <NEWLINE> <INDENT> t = tmp [ : ] <NEWLINE> <DEDENT> b = time ( ) <NEWLINE> print ( b - a , <STRING> ) <NEWLINE> <DEDENT>
import sys <NEWLINE> import numpy as np <NEWLINE> <NL> if sys . argv [ - 1 ] == <STRING> : <NEWLINE> <INDENT> from numba . pycc import CC <NEWLINE> cc = CC ( <STRING> ) <NEWLINE> <NL> @ cc . export ( <STRING> , <STRING> ) <NEWLINE> def solve ( N , P ) : <NEWLINE> <INDENT> minDist = np . ones ( ( N , N ) , dtype = np . int32 ) <NEWLINE> isFilled = np . ones ( ( N , N ) , dtype = np . int32 ) <NEWLINE> <NL> for h in range ( N ) : <NEWLINE> <INDENT> for w in range ( N ) : <NEWLINE> <INDENT> minDist [ h ] [ w ] = min ( h , N - h - 1 , w , N - w - 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for p in P : <NEWLINE> <INDENT> h , w = divmod ( p , N ) <NEWLINE> ans += minDist [ h ] [ w ] <NEWLINE> isFilled [ h ] [ w ] = False <NEWLINE> <NL> st = [ [ h , w ] ] <NEWLINE> while st : <NEWLINE> <INDENT> h , w = st . pop ( ) <NEWLINE> dist = minDist [ h ] [ w ] + isFilled [ h ] [ w ] <NEWLINE> <NL> if h + 1 < N and minDist [ h + 1 ] [ w ] > dist : <NEWLINE> <INDENT> minDist [ h + 1 ] [ w ] = dist <NEWLINE> st . append ( [ h + 1 , w ] ) <NEWLINE> <DEDENT> if h - 1 >= 0 and minDist [ h - 1 ] [ w ] > dist : <NEWLINE> <INDENT> minDist [ h - 1 ] [ w ] = dist <NEWLINE> st . append ( [ h - 1 , w ] ) <NEWLINE> <DEDENT> if w + 1 < N and minDist [ h ] [ w + 1 ] > dist : <NEWLINE> <INDENT> minDist [ h ] [ w + 1 ] = dist <NEWLINE> st . append ( [ h , w + 1 ] ) <NEWLINE> <DEDENT> if w - 1 < N and minDist [ h ] [ w - 1 ] > dist : <NEWLINE> <INDENT> minDist [ h ] [ w - 1 ] = dist <NEWLINE> st . append ( [ h , w - 1 ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return ans <NEWLINE> <NL> <DEDENT> cc . compile ( ) <NEWLINE> exit ( 0 ) <NEWLINE> <NL> <DEDENT> from my_module import solve <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> P = np . asarray ( list ( map ( lambda a : int ( a ) - 1 , input ( ) . split ( ) ) ) , dtype = np . int32 ) <NEWLINE> <NL> print ( solve ( N , P ) ) <NEWLINE>
from numba import njit <NEWLINE> import numpy as np <NEWLINE> <NL> <NL> def main ( N , P ) : <NEWLINE> <INDENT> lista = [ 1 , - 1 , N , - N ] <NEWLINE> d = np . zeros ( ( N , N ) , dtype = np . int32 ) <NEWLINE> d = d . ravel ( ) <NEWLINE> sit = np . ones_like ( d ) <NEWLINE> stack = np . empty_like ( d ) <NEWLINE> count = 0 <NEWLINE> for i in range ( N * N ) : <NEWLINE> <INDENT> d [ i ] = min ( i % N , ( N - 1 - i ) % N , i // N , N - 1 - i // N ) <NEWLINE> <DEDENT> for player in P : <NEWLINE> <INDENT> sit [ player - 1 ] = 0 <NEWLINE> count += d [ player - 1 ] <NEWLINE> stack [ 0 ] = player <NEWLINE> num = 0 <NEWLINE> while num >= 0 : <NEWLINE> <INDENT> p = stack [ num ] <NEWLINE> num -= 1 <NEWLINE> a = d [ p - 1 ] + sit [ p - 1 ] <NEWLINE> for i in lista : <NEWLINE> <INDENT> if p + i < 1 or p + i > N * N : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if d [ p + i - 1 ] > a : <NEWLINE> <INDENT> d [ p + i - 1 ] = a <NEWLINE> num += 1 <NEWLINE> stack [ num ] = p + i <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE> <NL> <NL> <DEDENT> def cc_export ( ) : <NEWLINE> <INDENT> from numba . pycc import CC <NEWLINE> cc = CC ( <STRING> ) <NEWLINE> cc . export ( <STRING> , <STRING> ) ( main ) <NEWLINE> cc . compile ( ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> import sys <NEWLINE> if sys . argv [ - 1 ] == <STRING> : <NEWLINE> <INDENT> cc_export ( ) <NEWLINE> exit ( 0 ) <NEWLINE> <COMMENT> <NL> <DEDENT> N = int ( input ( ) ) <NEWLINE> P = np . array ( input ( ) . split ( ) , np . int32 ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> main ( N , P ) <NEWLINE> <DEDENT>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> from numba import njit <NEWLINE> import numpy <NEWLINE> <NL> <NL> def read ( ) : <NEWLINE> <INDENT> N = int ( input ( ) . strip ( ) ) <NEWLINE> line = input ( ) . strip ( ) <NEWLINE> P = numpy . fromstring ( line , dtype = numpy . int32 , sep = <STRING> ) <NEWLINE> return N , P <NEWLINE> <NL> <NL> <DEDENT> @ njit <NEWLINE> def dfs ( N , Q , stay , p , q ) : <NEWLINE> <INDENT> y , x = divmod ( p , N ) <NEWLINE> for dy , dx in ( ( 0 , 1 ) , ( 1 , 0 ) , ( - 1 , 0 ) , ( 0 , - 1 ) ) : <NEWLINE> <INDENT> ny , nx = y + dy , x + dx <NEWLINE> if 0 <= ny < N and 0 <= nx < N : <NEWLINE> <INDENT> if Q [ ny , nx ] > q : <NEWLINE> <INDENT> Q [ ny , nx ] = q <NEWLINE> dfs ( N , Q , stay , ny * N + nx , q + stay [ ny , nx ] ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> @ njit <NEWLINE> def np_solve ( N , P , INF = 10 ** 9 ) : <NEWLINE> <INDENT> P -= 1 <NEWLINE> Q = numpy . empty ( ( N , N ) , dtype = numpy . int32 ) <NEWLINE> stay = numpy . ones ( ( N , N ) , dtype = numpy . bool_ ) <NEWLINE> <NL> for r in range ( N // 2 + 1 ) : <NEWLINE> <INDENT> Q [ r : N - r , r : N - r ] = r <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for p in P : <NEWLINE> <INDENT> y , x = divmod ( p , N ) <NEWLINE> stay [ y , x ] = 0 <NEWLINE> q = Q [ y , x ] <NEWLINE> ans += q <NEWLINE> dfs ( N , Q , stay , p , q ) <NEWLINE> <DEDENT> return ans <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> outputs = np_solve ( * read ( ) ) <NEWLINE> if outputs is not None : <NEWLINE> <INDENT> print ( <STRING> . format ( outputs ) ) <NEWLINE> <DEDENT> <DEDENT>
from numba import njit <NEWLINE> import numpy as np <NEWLINE> @ njit <NEWLINE> def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> h = [ min ( i // n , n - i // n - 1 , i % n , n - i % n - 1 ) for i in range ( n ** 2 ) ] <NEWLINE> h = np . array ( h ) <NEWLINE> stay = np . full ( n ** 2 , 1 ) <NEWLINE> ans = 0 <NEWLINE> def func ( x , c ) : <NEWLINE> <COMMENT> <NL> <INDENT> todo = [ [ x , c ] ] <NEWLINE> seen = set ( ( ) ) <NEWLINE> while todo : <NEWLINE> <INDENT> v , c = todo . pop ( ) <NEWLINE> nvs = [ v + n , v - n ] <NEWLINE> if v % n < n - 1 : nvs . append ( v + 1 ) <NEWLINE> if v % n > 0 : nvs . append ( v - 1 ) <NEWLINE> for nv in nvs : <NEWLINE> <INDENT> if nv < 0 or n ** 2 <= nv : continue <NEWLINE> if nv in seen : continue <NEWLINE> if h [ nv ] > c : <NEWLINE> <INDENT> h [ nv ] = c <NEWLINE> todo . append ( [ nv , c + stay [ nv ] ] ) <NEWLINE> <DEDENT> seen . add ( nv ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> for x in p : <NEWLINE> <INDENT> c = h [ x - 1 ] <NEWLINE> ans += c <NEWLINE> stay [ x - 1 ] = 0 <NEWLINE> func ( x - 1 , c ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
from numba import njit <NEWLINE> import numpy as np <NEWLINE> @ njit <NEWLINE> def dfs ( v , c , h , stay ) : <NEWLINE> <COMMENT> <NL> <INDENT> todo = [ [ v , c ] ] <NEWLINE> todo = np . zeros ( ( n * n , 2 ) , np . int32 ) <NEWLINE> todo [ 0 ] [ 0 ] = v <NEWLINE> todo [ 0 ] [ 1 ] = c <NEWLINE> now = 0 <NEWLINE> while now >= 0 : <NEWLINE> <INDENT> vv , cc = todo [ now ] <NEWLINE> now -= 1 <NEWLINE> x , y = divmod ( vv , n ) <NEWLINE> for dx , dy in ( ( 0 , 1 ) , ( 0 , - 1 ) , ( 1 , 0 ) , ( - 1 , 0 ) ) : <NEWLINE> <INDENT> nx , ny = x + dx , y + dy <NEWLINE> if 0 <= nx < n and 0 <= ny < n : <NEWLINE> <INDENT> nv = nx * n + ny <NEWLINE> if h [ nv ] > cc : <NEWLINE> <INDENT> h [ nv ] = cc <NEWLINE> now += 1 <NEWLINE> todo [ now ] [ 0 ] = nv <NEWLINE> todo [ now ] [ 1 ] = cc + stay [ nv ] <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> @ njit <NEWLINE> def main ( n , p ) : <NEWLINE> <INDENT> h = [ min ( i // n , n - i // n - 1 , i % n , n - i % n - 1 ) for i in range ( n ** 2 ) ] <NEWLINE> h = np . array ( h , np . int32 ) <NEWLINE> stay = np . full ( n * n , 1 , np . int32 ) <NEWLINE> ans = 0 <NEWLINE> <NL> for v in p : <NEWLINE> <INDENT> c = h [ v ] <NEWLINE> ans += c <NEWLINE> stay [ v ] = 0 <NEWLINE> dfs ( v , c , h , stay ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> p = np . array ( list ( map ( int , input ( ) . split ( ) ) ) , np . int32 ) <NEWLINE> p -= 1 <NEWLINE> main ( n , p ) <NEWLINE> <DEDENT>
import sys <NEWLINE> import numpy as np <NEWLINE> <NL> from numba import njit <NEWLINE> <NL> <NL> @ njit ( <STRING> , cache = True ) <NEWLINE> def solve ( n , ppp ) : <NEWLINE> <INDENT> n2 = n + 2 <NEWLINE> nsq = n2 * n2 <NEWLINE> seats = np . zeros ( nsq , dtype = np . int16 ) <NEWLINE> is_seated = np . zeros ( nsq , dtype = np . int8 ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ud = min ( i , n - 1 - i ) <NEWLINE> ri = ( i + 1 ) * n2 <NEWLINE> for j in range ( n ) : <NEWLINE> <INDENT> ij = ri + j + 1 <NEWLINE> seats [ ij ] = min ( ud , j , n - 1 - j ) <NEWLINE> is_seated [ ij ] = 1 <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> MOVES = np . array ( [ - n2 , - 1 , 1 , n2 ] , dtype = np . int32 ) <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> <COMMENT> <NL> <NL> for pi in range ( n * n ) : <NEWLINE> <INDENT> i , j = divmod ( ppp [ pi ] , n ) <NEWLINE> i = ( i + 1 ) * n2 + j + 1 <NEWLINE> res = seats [ i ] <NEWLINE> ans += res <NEWLINE> is_seated [ i ] = 0 <NEWLINE> <NL> deque = [ 0 ] * nsq <NEWLINE> l , r = 0 , 0 <NEWLINE> for mi in range ( 4 ) : <NEWLINE> <INDENT> ni = i + MOVES [ mi ] <NEWLINE> if seats [ ni ] > res : <NEWLINE> <INDENT> seats [ ni ] = res <NEWLINE> deque [ r ] = ni <NEWLINE> r += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> while l != r : <NEWLINE> <INDENT> j = deque [ l ] <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> l = ( l + 1 ) % nsq <NEWLINE> val = seats [ j ] <NEWLINE> <NL> if is_seated [ j ] : <NEWLINE> <INDENT> val += 1 <NEWLINE> for mi in range ( 4 ) : <NEWLINE> <INDENT> nj = j + MOVES [ mi ] <NEWLINE> if seats [ nj ] > val : <NEWLINE> <INDENT> seats [ nj ] = val <NEWLINE> deque [ r ] = nj <NEWLINE> r = ( r + 1 ) % nsq <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for mi in range ( 4 ) : <NEWLINE> <INDENT> nj = j + MOVES [ mi ] <NEWLINE> if seats [ nj ] > val : <NEWLINE> <INDENT> seats [ nj ] = val <NEWLINE> l = ( l - 1 ) % nsq <NEWLINE> deque [ l ] = nj <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> return ans <NEWLINE> <NL> <NL> <DEDENT> n = int ( sys . stdin . buffer . readline ( ) ) <NEWLINE> ppp = np . array ( list ( map ( int , sys . stdin . buffer . read ( ) . split ( ) ) ) , dtype = np . int32 ) - 1 <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> print ( solve ( n , ppp ) ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL>
from numba import njit <NEWLINE> import numpy as np <NEWLINE> import sys <NEWLINE> input = sys . stdin . buffer . readline <NEWLINE> <NL> @ njit ( <STRING> ) <NEWLINE> def dfs ( N , h , w , minDist , isFilled ) : <NEWLINE> <INDENT> dist = minDist [ h ] [ w ] + isFilled [ h ] [ w ] <NEWLINE> <NL> if h + 1 < N and minDist [ h + 1 ] [ w ] > dist : <NEWLINE> <INDENT> minDist [ h + 1 ] [ w ] = dist <NEWLINE> dfs ( N , h + 1 , w , minDist , isFilled ) <NEWLINE> <DEDENT> if h - 1 >= 0 and minDist [ h - 1 ] [ w ] > dist : <NEWLINE> <INDENT> minDist [ h - 1 ] [ w ] = dist <NEWLINE> dfs ( N , h - 1 , w , minDist , isFilled ) <NEWLINE> <DEDENT> if w + 1 < N and minDist [ h ] [ w + 1 ] > dist : <NEWLINE> <INDENT> minDist [ h ] [ w + 1 ] = dist <NEWLINE> dfs ( N , h , w + 1 , minDist , isFilled ) <NEWLINE> <DEDENT> if w - 1 < N and minDist [ h ] [ w - 1 ] > dist : <NEWLINE> <INDENT> minDist [ h ] [ w - 1 ] = dist <NEWLINE> dfs ( N , h , w - 1 , minDist , isFilled ) <NEWLINE> <NL> <DEDENT> <DEDENT> @ njit ( <STRING> ) <NEWLINE> def solve ( N , P ) : <NEWLINE> <INDENT> minDist = np . ones ( ( N , N ) , dtype = np . int32 ) <NEWLINE> isFilled = np . ones ( ( N , N ) , dtype = np . int32 ) <NEWLINE> <NL> for h in range ( N ) : <NEWLINE> <INDENT> for w in range ( N ) : <NEWLINE> <INDENT> minDist [ h ] [ w ] = min ( h , N - h - 1 , w , N - w - 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for p in P : <NEWLINE> <INDENT> h , w = divmod ( p , N ) <NEWLINE> ans += minDist [ h ] [ w ] <NEWLINE> isFilled [ h ] [ w ] = False <NEWLINE> dfs ( N , h , w , minDist , isFilled ) <NEWLINE> <DEDENT> return ans <NEWLINE> <NL> <DEDENT> N = int ( input ( ) ) <NEWLINE> P = np . asarray ( list ( map ( lambda a : int ( a ) - 1 , input ( ) . split ( ) ) ) , dtype = np . int32 ) <NEWLINE> <NL> print ( solve ( N , P ) ) <NEWLINE>
from numba import njit <NEWLINE> import numpy as np <NEWLINE> <NL> <NL> def cc_export ( ) : <NEWLINE> <INDENT> @ njit ( <STRING> ) <NEWLINE> def update ( n , w , que , there , cost , pos ) : <NEWLINE> <INDENT> que [ 0 ] = pos <NEWLINE> i , l = 0 , 1 <NEWLINE> while i < l : <NEWLINE> <INDENT> pos = que [ i ] <NEWLINE> i += 1 <NEWLINE> c = cost [ pos ] <NEWLINE> t = there [ pos ] <NEWLINE> k = c + t <NEWLINE> for df in list ( [ - w , w , - 1 , 1 ] ) : <NEWLINE> <INDENT> pp = pos + df <NEWLINE> if cost [ pp ] > k : <NEWLINE> <INDENT> cost [ pp ] = k <NEWLINE> que [ l ] = pp <NEWLINE> l += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> @ njit ( <STRING> ) <NEWLINE> def main ( n , p ) : <NEWLINE> <INDENT> w = n + 2 <NEWLINE> que = np . zeros ( 4 * w * w , dtype = np . int32 ) <NEWLINE> there = np . ones ( w * w , dtype = np . int32 ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> cost = np . array ( [ <NEWLINE> <INDENT> - 1 if i == 0 or i == n + 1 or j == 0 or j == n + 1 else min ( <NEWLINE> <INDENT> i - 1 , n - i , j - 1 , n - j ) for j in range ( w ) for i in range ( w ) <NEWLINE> <DEDENT> <DEDENT> ] , <NEWLINE> <INDENT> dtype = np . int32 ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for pos in p : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <INDENT> ans += cost [ pos ] <NEWLINE> there [ pos ] = 0 <NEWLINE> update ( n , w , que , there , cost , pos ) <NEWLINE> <DEDENT> return ans <NEWLINE> <NL> <DEDENT> from numba . pycc import CC <NEWLINE> cc = CC ( <STRING> ) <NEWLINE> cc . export ( <STRING> , <STRING> ) ( update ) <NEWLINE> cc . export ( <STRING> , <STRING> ) ( main ) <NEWLINE> cc . compile ( ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> import sys <NEWLINE> if sys . argv [ - 1 ] == <STRING> : <NEWLINE> <INDENT> cc_export ( ) <NEWLINE> sys . exit ( 0 ) <NEWLINE> <NL> <DEDENT> def transform ( t ) : <NEWLINE> <INDENT> y , x = divmod ( int ( t ) - 1 , n ) <NEWLINE> return ( y + 1 ) * ( n + 2 ) + ( x + 1 ) <NEWLINE> <NL> <DEDENT> from solution import update , main <NEWLINE> n = int ( input ( ) ) <NEWLINE> p = np . array ( list ( map ( transform , input ( ) . split ( ) ) ) , dtype = np . int32 ) <NEWLINE> print ( main ( n , p ) ) <NEWLINE> <DEDENT>
<COMMENT> <NL> import sys <NEWLINE> <NL> <COMMENT> <NL> sysread = sys . stdin . readline <NEWLINE> read = sys . stdin . buffer . read <NEWLINE> from heapq import heappop , heappush <NEWLINE> from collections import defaultdict <NEWLINE> <NL> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> import numpy as np <NEWLINE> <COMMENT> <NL> from collections import deque <NEWLINE> import numba <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> P = np . array ( list ( map ( int , sysread ( ) . split ( ) ) ) ) <NEWLINE> <COMMENT> <NL> @ numba . njit <NEWLINE> def run ( ) : <NEWLINE> <INDENT> seats = np . zeros ( ( N , N ) , dtype = np . int32 ) <NEWLINE> seen = np . zeros ( ( N , N ) , dtype = np . int32 ) <COMMENT> <NEWLINE> up , down = 0 , N - 1 <NEWLINE> dist = 0 <NEWLINE> while True : <NEWLINE> <INDENT> seats [ up , up : down + 1 ] = dist <NEWLINE> seats [ down , up : down + 1 ] = dist <NEWLINE> seats [ up : down + 1 , up ] = dist <NEWLINE> seats [ up : down + 1 , down ] = dist <NEWLINE> up += 1 <NEWLINE> down -= 1 <NEWLINE> dist += 1 <NEWLINE> if up > down : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> ret = 0 <NEWLINE> <COMMENT> <NL> for i in range ( N ** 2 ) : <NEWLINE> <COMMENT> <NL> <INDENT> cur_i , cur_j = ( P [ i ] - 1 ) // N , ( P [ i ] - 1 ) % N <NEWLINE> ret += seats [ cur_i , cur_j ] <NEWLINE> seen [ cur_i , cur_j ] = 1 <NEWLINE> stack = [ ( seats [ cur_i , cur_j ] , ( cur_i , cur_j ) ) ] <NEWLINE> while stack : <NEWLINE> <INDENT> del_val , ( cur_i , cur_j ) = stack . pop ( ) <NEWLINE> for i , j in ( ( 1 , 0 ) , ( 0 , 1 ) , ( - 1 , 0 ) , ( 0 , - 1 ) ) : <NEWLINE> <INDENT> n_i = cur_i + i <NEWLINE> n_j = cur_j + j <NEWLINE> if 0 <= n_i <= N - 1 and 0 <= n_j <= N - 1 : <NEWLINE> <INDENT> if seen [ cur_i , cur_j ] : <NEWLINE> <INDENT> if del_val < seats [ n_i , n_j ] : <NEWLINE> <INDENT> seats [ n_i , n_j ] = del_val <NEWLINE> stack . append ( ( del_val , ( n_i , n_j ) ) ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if del_val + 1 < seats [ n_i , n_j ] : <NEWLINE> <INDENT> seats [ n_i , n_j ] = del_val + 1 <NEWLINE> stack . append ( ( del_val + 1 , ( n_i , n_j ) ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ret ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> run ( ) <NEWLINE> <DEDENT>
def main ( N , P ) : <NEWLINE> <INDENT> A = [ - 1 ] * 4 * N * N <NEWLINE> ad = ( 1 , N , - 1 , - N ) <NEWLINE> for I in range ( 4 * N * N ) : <NEWLINE> <INDENT> i , j = I // 4 , I % 4 <NEWLINE> if 0 <= i + ad [ j ] < N * N : <NEWLINE> <INDENT> A [ i * 4 + j ] = i + ad [ j ] <NEWLINE> <DEDENT> <DEDENT> X = [ 0 ] * N * N <NEWLINE> for i in range ( N * N ) : <NEWLINE> <INDENT> X [ i ] = min ( i // N , N - 1 - i // N , i % N , N - 1 - i % N ) <NEWLINE> <DEDENT> E = [ 1 ] * N * N <NEWLINE> a = 0 <NEWLINE> q = [ 0 ] * N * N * N <NEWLINE> l , r = 0 , 0 <NEWLINE> for p in P : <NEWLINE> <INDENT> p -= 1 <NEWLINE> a += X [ p ] <NEWLINE> E [ p ] = 0 <NEWLINE> q [ r ] = p <NEWLINE> r += 1 <NEWLINE> while l < r : <NEWLINE> <INDENT> i = q [ l ] <NEWLINE> l += 1 <NEWLINE> for j in A [ 4 * i : 4 * ( i + 1 ) ] : <NEWLINE> <INDENT> if 0 <= j and X [ i ] + E [ i ] < X [ j ] : <NEWLINE> <INDENT> X [ j ] = X [ i ] + E [ i ] <NEWLINE> q [ r ] = j <NEWLINE> r += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> return a <NEWLINE> <DEDENT> import sys <NEWLINE> import numpy as np <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> read = sys . stdin . buffer . read <NEWLINE> if sys . argv [ - 1 ] == <STRING> : <NEWLINE> <INDENT> from numba import * <NEWLINE> from numba . pycc import CC <NEWLINE> cc = CC ( <STRING> ) <NEWLINE> def cc_export ( f , signature ) : <NEWLINE> <INDENT> cc . export ( f . __name__ , signature ) ( f ) <NEWLINE> return njit ( f ) <NEWLINE> <DEDENT> main = cc_export ( main , ( i8 , i8 [ : ] , ) ) <NEWLINE> cc . compile ( ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> N = int ( readline ( ) ) <NEWLINE> P = np . array ( readline ( ) . split ( ) , dtype = np . int64 ) <NEWLINE> from my_module import main <NEWLINE> print ( main ( N , P ) ) <NEWLINE>
import numba <NEWLINE> import numpy as np <NEWLINE> N = int ( input ( ) ) <NEWLINE> P = np . array ( [ int ( c ) - 1 for c in input ( ) . split ( ) ] ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> @ numba . njit ( <STRING> ) <NEWLINE> def proc ( N , P ) : <NEWLINE> <INDENT> ans = 0 <NEWLINE> Removed = np . zeros ( ( 500 , 500 ) , dtype = np . int8 ) <NEWLINE> Mat = np . zeros ( ( 500 , 500 ) , dtype = np . int16 ) <NEWLINE> Dy , Dx = [ 1 , 0 , - 1 , 0 ] , [ 0 , 1 , 0 , - 1 ] <NEWLINE> <NL> for y in range ( N ) : <NEWLINE> <INDENT> for x in range ( N ) : <NEWLINE> <INDENT> Mat [ y , x ] = min ( y , N - 1 - y , x , N - 1 - x ) <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> for i in range ( N * N ) : <NEWLINE> <INDENT> p = P [ i ] <NEWLINE> y , x = divmod ( p , N ) <NEWLINE> ans += Mat [ y , x ] <NEWLINE> Removed [ y , x ] = 1 <NEWLINE> st = [ ( y , x ) ] <NEWLINE> while st : <NEWLINE> <INDENT> vy , vx = st . pop ( ) <NEWLINE> vr = Removed [ vy , vx ] <NEWLINE> val = Mat [ vy , vx ] <NEWLINE> <COMMENT> <NL> for j in range ( 4 ) : <NEWLINE> <INDENT> uy , ux = vy + Dy [ j ] , vs + Dx [ j ] <NEWLINE> if not ( 0 <= uy < N and 0 <= ux < N ) : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> ur = Removed [ uy , ux ] <NEWLINE> if vr : <NEWLINE> <INDENT> if Mat [ uy , ux ] >= val + 1 : <NEWLINE> <INDENT> Mat [ uy , ux ] = val <NEWLINE> st . append ( ( uy , ux ) ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if Mat [ uy , ux ] >= val + 2 : <NEWLINE> <INDENT> Mat [ uy , ux ] = val + 1 <NEWLINE> st . append ( ( uy , ux ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <DEDENT> proc ( N , P ) <NEWLINE> <NL>
a = int ( input ( ) ) <NEWLINE> c = b . split ( ) <NEWLINE> a = c [ - 1 ] <NEWLINE> if a == 2 or a == 4 or a == 5 or a == 7 or a == 9 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a == 0 or a == 1 or a == 6 or a == 8 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = ( input ( ) ) <NEWLINE> n %= 10 <NEWLINE> if ( n == 3 ) <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else if ( n == 0 or n == 1 or n == 6 or n == 8 ) <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
x = int ( ) [ - 1 ] <NEWLINE> <NL> if x == [ 2 , 4 , 5 , 7 , 9 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> elif x == [ 0 , 1 , 6 , 8 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = input ( int ( ) ) <NEWLINE> if ( N % 100 ) % 10 == 3 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif ( N % 100 ) % 10 == 0 or ( N % 100 ) % 10 == 1 or ( N % 100 ) % 10 == 6 or ( N % 100 ) % 10 == 8 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT>
N = int ( input ( ) ) <NEWLINE> num = N % 10 <NEWLINE> <NL> if num == 3 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif num == 0 or num == 1 or num == 6 or num == 8 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> <NL> if N [ - 1 ] == 3 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif N [ - 1 ] == 2 or 4 or 5 or 7 or 9 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
numberOfMange = int ( input ( ) ) % 10 <NEWLINE> <NL> if numberOfMange in [ 2 , 4 , 5 , 7 , 9 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif numberOfMange in [ 0 , 1 , 6 , 8 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else numberOfMange : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = list ( input ( ) ) . reversed ( ) <NEWLINE> <NL> if ( n [ 0 ] == <STRING> or n [ 0 ] == <STRING> or n [ 0 ] == <STRING> or n [ 0 ] == <STRING> or n [ 0 ] == <STRING> ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif ( n [ 0 ] == <STRING> or n [ 0 ] == <STRING> or n [ 0 ] == <STRING> or n [ 0 ] == <STRING> ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif ( n [ 0 ] == <STRING> ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
<COMMENT> <NL> N = input ( ) <NEWLINE> last = int ( N [ - 1 ] ) <NEWLINE> <NL> <COMMENT> <NL> if last == 2 or last == 4 or last == 5 or last == 7 or last == 9 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif last == 0 or last == 1 or last == 6 or last == 8 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif last == 3 <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> <NL> remainder = n [ - 1 ] <NEWLINE> if remainder in ( 2 , 4 , 5 , 7 , 9 ) : print ( <STRING> ) <NEWLINE> elif remainder in ( 0 , 1 , 6 , 8 ) : print ( <STRING> ) <NEWLINE> elif remainder in ( 3 ) : print ( <STRING> ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> <NL> a = N % 100 <NEWLINE> a = a % 10 <NEWLINE> <NL> if a == 0 or a == 1 or a == 6 or a == 8 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a == 3 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <NL> N = int ( input ( ) ) <NEWLINE> if N % 10 == 3 <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif N % 10 == 0 or N % 10 == 1 or N % 10 == 6 or N % 10 == 8 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> N = str ( N ) <NEWLINE> n = N [ - 1 ] <NEWLINE> f n == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif n == <STRING> or n == <STRING> or n == <STRING> or n == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) [ len ( n - 1 ) ] ) <NEWLINE> a = [ 2 , 4 , 5 , 7 , 9 ] <NEWLINE> b = [ 0 , 1 , 6 , 8 ] <NEWLINE> <NL> if n in a : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif n in b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> a = len ( str ( N ) ) - 1 <NEWLINE> if str ( N [ a ] ) == 2 or str ( N [ a ] ) == 4 or str ( N [ a ] ) == 5 or str ( N [ a ] ) == 7 or str ( N [ a ] ) == 9 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif str ( N [ a ] ) == 0 or str ( N [ a ] ) == 1 or str ( N [ a ] ) == 6 or str ( N [ a ] ) == 8 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif str ( N [ a ] ) == 3 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = input ( ) <NEWLINE> <NL> if ( n [ - 1 ] == <STRING> or n [ - 1 ] == <STRING> or n [ - 1 ] == <STRING> or n [ - 1 ] == <STRING> ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else if ( n [ - 1 ] == <STRING> ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> <NL> if n [ - 1 ] == 3 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif n [ - 1 ] == 0 or n [ - 1 ] == 1 or n [ - 1 ] == 6 or n [ - 1 ] == 8 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = str ( input ( ) ) <NEWLINE> m = n [ 2 ] <NEWLINE> if m == <STRING> or m == <STRING> or m == <STRING> or m == <STRING> or m == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif m == <STRING> or m == <STRING> or m == <STRING> or m == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
nm = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> n = nm [ 0 ] <NEWLINE> m = nm [ 1 ] <NEWLINE> a = [ ] <NEWLINE> b = [ ] <NEWLINE> for i in range ( 0 , m ) : <NEWLINE> <INDENT> ab = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a . append ( ab [ 0 ] ) <NEWLINE> b . append ( ab [ 1 ] ) <NEWLINE> <DEDENT> signs = [ 0 ] * ( n + 1 ) <NEWLINE> signs [ 1 ] = - 1 <NEWLINE> now = [ 1 ] <NEWLINE> nexx = [ ] <NEWLINE> while True : <NEWLINE> <INDENT> for i in now : <NEWLINE> <INDENT> for j in range ( 0 , m ) : <NEWLINE> <INDENT> if a [ j ] == i : <NEWLINE> <INDENT> if signs [ b [ j ] ] == 0 : <NEWLINE> <INDENT> signs [ b [ j ] ] = i <NEWLINE> nexx . append ( b [ j ] ) <NEWLINE> <DEDENT> <DEDENT> elif b [ j ] == i : <NEWLINE> <INDENT> if signs [ a [ j ] ] == 0 : <NEWLINE> <INDENT> signs [ a [ j ] ] = i <NEWLINE> nexx . append ( a [ j ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> now = nexx . copy ( ) <NEWLINE> if len ( nexx ) == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> nexx = [ ] <NEWLINE> <DEDENT> flag = 0 <NEWLINE> for i in range ( 2 , n + 1 ) : <NEWLINE> <INDENT> if signs [ i ] == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> flag = 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if flag == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> for k in range ( 2 , n + 1 ) : <NEWLINE> <INDENT> print ( signs [ k ] ) <NEWLINE> <NL> <DEDENT> <DEDENT>
N = str ( input ( ) ) <NEWLINE> if N [ 2 ] == 3 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif N [ 2 ] == 0 or N [ 2 ] == 1 or N [ 2 ] == 6 or N [ 2 ] == 8 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> n = input ( ) <NEWLINE> digit = int ( n [ - 1 ] ) <NEWLINE> <NL> if digit == 3 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif digit == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif digit == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif digit == 6 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif digit == 8 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> if N [ - 1 ] == 3 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif N [ - 1 ] in [ 0 , 1 , 6 , 8 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = input ( ) <NEWLINE> n = dict ( n ) <NEWLINE> <NL> l = [ 0 , 1 , 6 , 8 ] <NEWLINE> if n [ - 1 ] == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif str ( n [ - 1 ] ) in l : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> <NL> if N % 10 == 2 , 4 , 5 , 7 , 9 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> elif N % 10 == 0 , 1 , 6 , 8 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> elif N % 10 == 3 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s = int ( intpu ( ) ) <NEWLINE> if s [ - 1 ] == 3 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif s [ - 1 ] == 0 or s [ - 1 ] == 1 or s [ - 1 ] == 6 or s [ - 1 ] == 8 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> <NL> if int ( n [ - 1 ] ) in [ 2 , 4 , 5 , 7 , 9 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif int ( n [ - 1 ] ) in [ 0 , 1 , 6 , 8 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a = input ( ) <NEWLINE> n = len ( a ) <NEWLINE> if ( int ( a [ n - 1 ] ) == 3 ) : <NEWLINE> <INDENT> print ( bon ) <NEWLINE> <DEDENT> if ( int ( a [ n - 1 ] ) in [ 0 , 1 , 6 , 8 ] ) : <NEWLINE> <INDENT> print ( pon ) <NEWLINE> <DEDENT> if ( int ( a [ n - 1 ] ) in [ 2 , 4 , 5 , 7 , 9 ] ) : <NEWLINE> <INDENT> print ( hon ) <NEWLINE> <DEDENT>
n = input ( ) <NEWLINE> <NL> if n [ lne ( n ) - 1 ] == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif n [ len ( n ) - 1 ] == <STRING> or <STRING> or <STRING> or <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
if N % 10 == 2 or N % 10 == 4 or N % 10 == 5 or N % 10 == 7 or N % 10 == 9 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif N % 10 == 0 or N % 10 == 1 or N % 10 == 6 or N % 10 == 8 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> if n [ len ( n ) - 1 ] == 3 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif n [ len ( n ) - 1 ] == 0 or 1 or 6 or 8 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = input ( ) <NEWLINE> <NL> def yomikata ( N ) : <NEWLINE> <INDENT> N_firstdigit = N % 10 <NEWLINE> if N_firstdigit == 3 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <COMMENT> <NL> <DEDENT> elif N_firstdigit == 0 or N_firstdigit == 1 or N_firstdigit == 6 or N_firstdigit == 8 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> yomikata ( N ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> x = N % 10 <NEWLINE> if x == 3 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif x == 0 or x == 1 or X == 6 or x == 8 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> while True : <NEWLINE> <COMMENT> <NL> <INDENT> n = list ( input ( ) ) <NEWLINE> <COMMENT> <NL> <NL> poo = n [ - 1 ] <NEWLINE> <NL> if poo in <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif poo in <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif poo == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT>
from collections import deque <NEWLINE> import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> g = [ [ ] for _ in range ( n ) ] <COMMENT> <NEWLINE> <NL> for _ in range ( m ) : <NEWLINE> <INDENT> a , b = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> g [ a - 1 ] . append ( b - 1 ) <NEWLINE> g [ b - 1 ] . append ( a - 1 ) <NEWLINE> <NL> <NL> <DEDENT> def bfs ( u ) : <NEWLINE> <INDENT> queue = deque ( [ u ] ) <NEWLINE> d = [ None ] * n <COMMENT> <NEWLINE> d [ u ] = 0 <COMMENT> <NEWLINE> while queue : <NEWLINE> <INDENT> v = queue . popleft ( ) <NEWLINE> for i in g [ v ] : <NEWLINE> <INDENT> if d [ i ] is None : <NEWLINE> <INDENT> d [ i ] = d [ v ] + 1 <NEWLINE> queue . append ( i ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return d <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> d = bfs ( 0 ) <NEWLINE> if len ( d ) != 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> for i in d [ 1 : ] : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import sys <NEWLINE> num = sys . stdin <NEWLINE> <NL> hon_num_list = [ <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> pon_num_list = [ <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> bon_num_list = [ <STRING> ] <NEWLINE> <NL> <NL> if num [ - 1 ] in hon_num_list : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif num [ - 1 ] in pon_num_list : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif num [ - 1 ] in bon_num_list : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = str ( input ( ) ) <NEWLINE> num = N [ - 1 ] <NEWLINE> num = int ( num ) <NEWLINE> <NL> if num == 3 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif num == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif num == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif num == 6 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif num == 8 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif num == 2 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif num == 4 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif num == 5 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif num == 7 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif num == 9 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> N = str ( input ( ) ) <NEWLINE> num = N [ - 1 ] <NEWLINE> <NL> if num == 3 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif num == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif num == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif num == 6 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif num == 8 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif num == 2 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif num == 4 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif num == 5 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif num == 7 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif num == 9 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
S = input ( ) <NEWLINE> K = int ( input ( ) ) <NEWLINE> <NL> if len ( S ) <= K : <NEWLINE> <INDENT> print ( S ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( S [ : K ] + <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> if n [ - 1 ] == 3 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif n [ - 1 ] == 0 or n [ - 1 ] == 1 or n [ - 1 ] == 6 or n [ - 1 ] == 8 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> p = n % 10 <NEWLINE> if p in [ 2 , 4 , 5 , 7 , 9 ] : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> elif p in [ 0 , 1 , 6 , 8 ] : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> return <STRING> <NEWLINE>
N = str ( N ) <NEWLINE> N = N [ - 1 ] <NEWLINE> <NL> hon = [ str ( n ) for n in list ( [ 2 , 4 , 5 , 7 , 9 ] ) ] <NEWLINE> pon = [ str ( n ) for n in list ( [ 0 , 1 , 6 , 8 ] ) ] <NEWLINE> bon = [ <STRING> ] <NEWLINE> <NL> if N in hon : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif N in pon : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif N in bon : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s = input ( ) [ - 1 ] <NEWLINE> if s in <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif s in <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> c = c % 10 <NEWLINE> if c == 2 or c == 4 or c == 5 or c == 7 or c == 9 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif c == 0 or c == 1 or c == 6 or c == 8 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
l1 = [ 2 , 4 , 5 , 7 , 9 ] <NEWLINE> l2 = [ 0 , 1 , 6 , 8 ] <NEWLINE> l3 = [ 3 ] <NEWLINE> N = int ( input ( ) ) <NEWLINE> if str ( N [ - 1 ] ) in l1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif str ( N [ - 1 ] ) in l2 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif str ( N [ - 1 ] ) in l3 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
book = int ( input ( ) ) <NEWLINE> if book % 10 == 0 or if book % 10 == 1 or if book % 10 == 6 or if book % 10 == 8 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif book % 10 == 2 or book % 10 == 4 or book % 10 == 5 or book % 10 == 7 or book % 10 == 9 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif book % 10 == 3 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> N &= 10 <NEWLINE> if N in [ 2 , 4 , 5 , 7 , 9 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif N in [ 0 , 1 , 6 , 8 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else N == 3 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> d = n % 10 <NEWLINE> <NL> if d in [ 2 , 4 , 5 , 7 , 9 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif d in [ 0 , 1 , 6 , 8 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else d in [ 3 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = input ( ) <NEWLINE> mod = N % 10 <NEWLINE> if mod = 3 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif mod = 0 , 1 , 6 , 8 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> jo = int ( n [ - 1 ] ) <NEWLINE> if jo == 3 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif jo == 0 or 1 or 6 or 8 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> if N [ - 1 ] == 2 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif N [ - 1 ] == 4 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif N [ - 1 ] == 5 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif N [ - 1 ] == 7 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif N [ - 1 ] == 9 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif N [ - 1 ] == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif N [ - 1 ] == 6 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif N [ - 1 ] == 8 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b , c , k = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if a > k : <NEWLINE> <INDENT> ans = k <NEWLINE> <DEDENT> elif a + b > k : <NEWLINE> <INDENT> ans = a <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = a - ( k - a - b ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> <NL> lastnum = N % 10 <NEWLINE> <NL> if lastnum in [ 0 , 1 , 6 , 8 ] <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> elif lastnum in [ 2 , 4 , 5 , 7 , 9 ] <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a = int ( input ( ) ) <NEWLINE> if a [ - 1 ] == 3 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a [ - 1 ] == 0 or a [ - 1 ] == 1 or a [ - 1 ] == 6 or a [ - 1 ] == 8 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = input ( ) <NEWLINE> N = int ( N [ 2 ] ) <NEWLINE> if N == 3 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif N in [ 0 , 1 , 6 , 8 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s = str ( input ( ) ) [ - 1 ] <NEWLINE> <NL> if s in [ <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else if s == 3 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = input <NEWLINE> <NL> if N [ - 1 : ] == <STRING> or <STRING> or <STRING> or <STRING> or <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif N [ - 1 : ] == <STRING> or <STRING> or <STRING> or <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif N [ - 1 : ] == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) % 10 <NEWLINE> <NL> if n == 3 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = input ( ) <NEWLINE> if N [ 2 ] == 2 and N [ 2 ] == 4 and N [ 2 ] == 5 and N [ 2 ] == 7 and N [ 2 ] == 9 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif N [ 2 ] == 0 and N [ 2 ] == 1 and N [ 2 ] == 6 and N [ 2 ] == 8 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import sys <NEWLINE> import os <NEWLINE> <NL> n = sys . argv [ 1 ] <NEWLINE> n = n [ - 1 ] <NEWLINE> <NL> if n == <STRING> or n == <STRING> or n == <STRING> or n == <STRING> or n == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif n == <STRING> or n == <STRING> or n == <STRING> or n == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif n == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> sys . exit ( ) <NEWLINE>
a = [ ] <NEWLINE> a = input ( ) <NEWLINE> f = len ( a ) <NEWLINE> <NL> <NL> <NL> print ( a [ 3 ] ) <NEWLINE> <NL> <NL> if a [ f - 1 ] == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a [ f - 1 ] == <STRING> or a [ f - 1 ] == <STRING> or a [ f - 1 ] == <STRING> or a [ f - 1 ] == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> if s [ - 1 ] == 3 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif s [ - 1 ] in [ 0 , 1 , 6 , 8 ] <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
user = int ( input ( ) ) <NEWLINE> new = str ( user ) <NEWLINE> ifunction new ( ) : <NEWLINE> <INDENT> user = int ( input ( ) ) <NEWLINE> new = str ( user ) <NEWLINE> <INDENT> if ( new == 2 or 4 or 5 or 7 or 9 ) : <NEWLINE> <INDENT> return ( <STRING> ) <NEWLINE> <DEDENT> elif ( new == 0 or 1 or 6 or 8 ) : <NEWLINE> <INDENT> return ( <STRING> ) <NEWLINE> <DEDENT> elif ( new == 3 ) : <NEWLINE> <INDENT> return ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ) <NEWLINE>
N = input ( ) <NEWLINE> <NL> lastnum = N % 10 <NEWLINE> <NL> if lastnum in [ 0 , 1 , 6 , 8 ] <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> elif lastnum in [ 2 , 4 , 5 , 7 , 9 ] <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = str ( input ( ) ) <NEWLINE> if n [ - 1 ] in [ <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ] : <NEWLINE> <INDENT> how_to_read = <STRING> <NEWLINE> <DEDENT> elif n [ - 1 ] in [ <STRING> , <STRING> , <STRING> , <STRING> : <NEWLINE> <INDENT> how_to_read = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> how_to_read = <STRING> <NEWLINE> <NL> <DEDENT> print ( how_to_read ) <NEWLINE>
a = int ( input ( ) ) <NEWLINE> b = a % 10 <NEWLINE> if b == 0 , 1 , 6 , 8 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif b == 2 , 4 , 5 , 7 , 9 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> x = input ( ) <NEWLINE> <NL> if int ( x [ 0 : 0 : - 1 ] ) == 3 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if 0 or 1 or 6 or 8 in int ( x [ 0 : 0 : - 1 ] ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> main ( ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> N %= 10 <NEWLINE> if N == 3 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif N == 0 or N == 1 or N == 6 N == 8 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> <NL> m = n [ - 1 ] <NEWLINE> <NL> if m == 3 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif m == 0 , 1 , 6 , 8 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> if n % 10 in [ 2 , 4 , 5 , 7 , 9 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> elif n % 10 in [ 0 , 1 , 6 , 8 ] : <NEWLINE> print ( <STRING> ) <NEWLINE> else : <NEWLINE> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> if n >= 100 : <NEWLINE> <INDENT> n [ 2 ] = num1 <NEWLINE> if num1 == 2 or num1 == 4 or num1 == 5 or num1 == 7 or num1 == 9 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif num1 == 0 or num1 == 1 or num1 == 6 or num1 == 8 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> elif 100 > n >= 10 : <NEWLINE> <INDENT> n [ 1 ] = num2 <NEWLINE> if num2 == 2 or num2 == 4 or num2 == 5 or num2 == 7 or num2 == 9 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif num2 == 0 or num2 == 1 or num2 == 6 or num2 == 8 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> n = num3 <NEWLINE> if num3 == 2 or num3 == 4 or num3 == 5 or num3 == 7 or num3 == 9 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif num3 == 0 or num3 == 1 or num3 == 6 or num3 == 8 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <NL> <NL> <NL> <NL> <DEDENT> <DEDENT>
N = input ( ) <NEWLINE> if N [ - 1 ] == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif N [ - 1 ] == <STRING> , <STRING> , <STRING> , <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = n % 10 <NEWLINE> if a = 2 or a = 4 or a = 5 or a = 7 or a = 9 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a = 0 or a = 1 or a = 6 or a = 8 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a = 3 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = map ( int , input ( ) . split ( ) ) <NEWLINE> if N % 10 == 2 or N % 10 == 4 or N % 2 == 5 or N % 10 == 7 or N % 10 == 9 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif N % 10 == 0 or N % 10 == 1 or N % 10 == 6 or N % 10 == 8 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif N % 10 == 3 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
K = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> x = len ( s ) <NEWLINE> <NL> if x <= K : <NEWLINE> <INDENT> print ( s ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( s [ : K ] + <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> <NL> if n == 3 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif ( n [ - 1 ] == <STRING> or n [ - 1 ] == <STRING> or n [ - 1 ] == <STRING> or n [ - 1 ] == <STRING> ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> r = n % 10 <NEWLINE> if ( r == 3 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif ( r == 0 or r == 1 or r == 6 or r = 8 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
k = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> if len ( s ) <= k : <NEWLINE> <INDENT> print ( s ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( s [ : k ] + <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> nlis = list ( map ( int , input ( ) . split ( ) ) ) <COMMENT> <NEWLINE> <NL> if nlis [ - 1 ] == 2 or nlis [ - 1 ] == 4 or nlis [ - 1 ] == 5 or nlis [ - 1 ] == 7 or nlis [ - 1 ] == 9 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif nlis [ - 1 ] == 0 or nlis [ - 1 ] == 1 or nlis [ - 1 ] == 6 or nlis [ - 1 ] == 8 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> a = int ( input ( ) ) <NEWLINE> <COMMENT> <NL> b = a - ( a % 10 ) * 10 <NEWLINE> <COMMENT> <NL> if b == 2 or b == 4 or b == 5 or b == 7 or b == 9 : <NEWLINE> <INDENT> out = <STRING> <NEWLINE> <DEDENT> elif b == 0 or b == 1 or b == 6 or b == 8 : <NEWLINE> <INDENT> out = <STRING> <NEWLINE> <DEDENT> elif b == 3 : <NEWLINE> <INDENT> out = <STRING> <NEWLINE> <COMMENT> <NL> <DEDENT> print ( <STRING> . format ( out ) ) <NEWLINE>
N = input ( ) <NEWLINE> if N [ - 1 ] == 3 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif N [ - 1 ] == 0 or N [ - 1 ] == 8 or N [ - 1 ] == 6 or [ n - 1 ] == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> N = N % 10 <NEWLINE> if N in [ 2 , 4 , 5 , 7 , 9 ] : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> elif N in [ 0 , 1 , 6 , 8 ] : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> elif N == 3 : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT>
n = input ( ) <NEWLINE> amari = n % 10 <NEWLINE> p = <STRING> <NEWLINE> if amari == 2 or amari == 4 or amari == 5 or amari == 7 or amari == 9 : <NEWLINE> <INDENT> p = <STRING> <NEWLINE> <DEDENT> elif amari == 1 or amari == 0 or amari == 6 or amari == 8 : <NEWLINE> <INDENT> p = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> p = <STRING> <NEWLINE> <DEDENT> print ( p ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> n %= 10 <NEWLINE> if n == 2 or n == 4 or n == 5 or n == 7 or n == 9 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif n == 0 or n == 1 or n == 6 or n == 8 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) 2 <NEWLINE> <DEDENT>
n = input ( ) <COMMENT> <NEWLINE> int ( n ) <COMMENT> <NEWLINE> digit = n % 10 <NEWLINE> if digit == 3 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif digit == 0 or digit == 1 or digit == 6 or digit == 8 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
t = int ( input ( ) ) <NEWLINE> a = [ 2 , 4 , 5 , 7 , 9 ] <NEWLINE> x = n % 10 <NEWLINE> if x in a : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif x == 3 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a = input ( ) <NEWLINE> <NL> b = a [ len ( a ) - 1 ] <NEWLINE> <NL> if b == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else if b == <STRING> or b == <STRING> or b == <STRING> or b == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> if n [ - 1 ] == <STRING> or n [ - 1 ] == <STRING> or n [ - 1 ] == <STRING> or n [ - 1 ] == <STRING> or n [ - 1 ] == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif n [ - 1 ] == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> if n [ - 1 ] == 3 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif n [ - 1 ] in [ <STRING> , <STRING> , <STRING> , <STRING> ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> if n % 10 == 3 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif n % 10 == 0 or n % 10 == 1 or n % 10 == 6 or n % 10 == 8 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> main ( <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <INDENT> nStr = str ( n ) <NEWLINE> number = nStr [ len ( nStr ) - 1 ] <NEWLINE> if number == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif number == <STRING> or number == <STRING> or number == <STRING> or number == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
<NL> n = input ( ) <NEWLINE> hon = <STRING> <NEWLINE> pon = <STRING> <NEWLINE> x = n [ len ( n ) - 1 ] <NEWLINE> if x in hon : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> elif x in pon : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
x = int ( input ( ) ) <NEWLINE> if x [ - 1 ] == 3 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif x [ - 1 ] == 0 or x [ - 1 ] == 1 or x [ - 1 ] == 6 or x [ - 1 ] == 8 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a = input ( ) <NEWLINE> b = a - a // 10 * 10 <NEWLINE> c = ( <STRING> if b == 0 else <NEWLINE> <INDENT> <STRING> if b == 1 else <NEWLINE> <STRING> if b == 2 else <NEWLINE> <STRING> if b == 3 else <NEWLINE> <STRING> if b == 4 else <NEWLINE> <STRING> if b == 5 else <NEWLINE> <STRING> if b == 6 else <NEWLINE> <STRING> if b == 7 else <NEWLINE> <STRING> if b == 8 else <NEWLINE> <STRING> if b == 9 else <NEWLINE> <STRING> <NEWLINE> ) <NEWLINE> <DEDENT> print ( c ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> n = N % 10 <NEWLINE> <NL> if n in [ 2 , 4 , 5 , 7 , 9 ] ; <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif n in [ 0 , 1 , 6 , 8 ] ; <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else ; <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a = input ( ) <NEWLINE> if a [ 2 ] == <STRING> or a [ 2 ] == <STRING> or a [ 2 ] == <STRING> or a [ 2 ] == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a [ 2 ] == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = input ( ) <NEWLINE> <NL> N = int ( N [ - 1 ] ) <NEWLINE> <NL> if N == 3 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif N in [ 1 , 2 , 4 , 5 , 7 , 9 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else N in [ 0 , 1 , 6 , 8 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <NL> <DEDENT>
N = int ( input ( ) ) <NEWLINE> if N [ len ( N ) - 1 ] == 2 or 4 or 5 or 7 or 9 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif N [ len ( N ) - 1 ] == 0 or 1 or 6 or 8 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) [ - 1 ] ) <NEWLINE> if N == 3 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif N == 0 or N == 1 or N == 6 or N == 8 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N = 0 <NEWLINE> for ( N < 1000 N + + ) <NEWLINE> <INDENT> if N == [ 2 , 4 , 5 , 7 , 9 ] <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif N == [ 0 , 1 , 6 , 8 ] <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else N == [ 3 ] <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
<COMMENT> <NL> <NL> n = input ( ) <NEWLINE> <NL> if n [ 2 ] in [ <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif n [ 2 ] in [ <STRING> , <STRING> , <STRING> , <STRING> ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> <NL> N1 = N % 10 <NEWLINE> <NL> if N1 = 2 , 4 , 5 , 7 , 9 : <NEWLINE> <INDENT> print ( hon ) <NEWLINE> <DEDENT> elif N1 = 0 , 1 , 6 , 8 : <NEWLINE> <INDENT> print ( pon ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( bon ) <NEWLINE> <DEDENT>
a = input ( ) <NEWLINE> sig = str ( a [ - 1 ] ) <NEWLINE> <NL> if ( sig == <STRING> or sig == <STRING> or sig == <STRING> or sig == <STRING> or sig == <STRING> ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if ( sig == <STRING> ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> else : <NEWLINE> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> n = N % 10 <NEWLINE> if n == 2 or n == 4 or n == 5 or n == 7 or n == 9 : <NEWLINE> <INDENT> ptint ( <STRING> ) <NEWLINE> <DEDENT> elif n == 3 <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s = list ( intput ( ) ) <NEWLINE> k = int ( s [ - 1 ] ) <NEWLINE> if k in [ 2 , 4 , 7 , 9 , 5 ] : <NEWLINE> <NL> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif k in [ 0 , 1 , 6 , 8 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> data = [ ] <NEWLINE> <NL> for l in sys . stdin : <NEWLINE> <INDENT> data . append ( str ( l ) ) <NEWLINE> <NL> <DEDENT> last = int ( data [ 0 ] [ - 1 ] ) <NEWLINE> <NL> if last in [ 2 , 4 , 5 , 7 , 9 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif last in [ 0 , 1 , 6 , 8 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
x = list ( int ( input ( ) ) ) <NEWLINE> print ( x ) <NEWLINE> <NL> if x [ - 1 ] = <STRING> , <STRING> , <STRING> , <STRING> , <STRING> : <NEWLINE> <INDENT> y = <STRING> <NEWLINE> <DEDENT> elif x [ - 1 ] = <STRING> , <STRING> , <STRING> , <STRING> : <NEWLINE> <INDENT> y = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> y = <STRING> <NEWLINE> <NL> <DEDENT> print ( y ) <NEWLINE>
num = int ( input ( ) ) <NEWLINE> if num [ : - 1 ] == 0 or num [ : - 1 ] == 1 or num [ : - 1 ] == 6 or num [ : - 1 ] == 8 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elis num [ : - 1 ] == 3 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s = str ( input ( ) ) <NEWLINE> s [ - 1 ] = z <NEWLINE> if z = 2 or 4 or 5 or 7 or 9 ; <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif z = 0 or 1 or 6 or 8 ; <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else ; <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> num = map ( str ( n ) ) <NEWLINE> <NL> if num [ print ( len ( n ) ) ] == [ 2 , 4 , 5 , 7 , 9 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif num [ print ( len ( n ) ) ] == [ 0 , 1 , 6 , 8 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
S = input ( ) <NEWLINE> if int ( S [ 2 ] ) == 3 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif int ( S [ 2 ] ) == 0 or int ( S [ 2 ] ) == 1 or int ( S [ 2 ] ) == 6 or int ( S [ 2 ] ) == 8 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
data = input ( ) <NEWLINE> name = [ <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> print ( name [ int ( data [ - 1 ] ) ] <NEWLINE>
N = int ( input ( ) ) <NEWLINE> N1 = N % 10 <NEWLINE> if N1 == 3 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif N1 == 0 | | N1 == 1 | | N1 == 6 | | N1 == 8 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = input ( ) % 10 <NEWLINE> if n in ( <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif n in ( <STRING> , <STRING> , <STRING> , <STRING> ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> N_mozi = <STRING> <NEWLINE> for i in range N_mozi : <NEWLINE> <INDENT> if i < len ( N_mozi ) + 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> end_N = i <NEWLINE> <DEDENT> <DEDENT> if end_N == 2 or end_N == 4 or end_N == 5 or end_N == 7 or end_N == 9 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif end_N == 3 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> x = n % 10 <NEWLINE> if ( x == 2 , or x == 4 , or x == 5 , or x == 7 , or x == 9 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif ( x == 0 , or x == 1 , or x == 6 , or x == 8 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = input ( ) <NEWLINE> a = [ int ( c ) for c in n ] <NEWLINE> if ( a [ len ( n ) ] == 3 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif ( a [ len ( n ) ] == 0 or 1 or 6 or 8 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = ( input ( ) ) <NEWLINE> rem = str ( n ) <NEWLINE> <NL> if int ( n [ - 1 : ] ) in str ( 2 ) or str ( 4 ) or str ( 7 ) or str ( 9 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> if int ( n [ - 1 : ] ) in str ( 0 ) or str ( 1 ) or str ( 6 ) or str ( 8 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> if int ( n [ - 1 : ] ) == str ( 3 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT>
import math , sys <NEWLINE> from bisect import bisect_left , bisect_right <NEWLINE> from collections import Counter , defaultdict , deque <NEWLINE> from copy import deepcopy <NEWLINE> from functools import lru_cache <NEWLINE> from heapq import heapify , heappop , heappush <NEWLINE> from itertools import accumulate , combinations , permutations <NEWLINE> input = sys . stdin . readline <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> ns = lambda : input ( ) . strip ( ) <NEWLINE> ni = lambda : int ( input ( ) . strip ( ) ) <NEWLINE> nm = lambda : map ( int , input ( ) . split ( ) ) <NEWLINE> nl = lambda : list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> n = ni ( ) <NEWLINE> <NL> one = n % 10 <NEWLINE> <NL> a = set ( 2 , 4 , 5 , 7 , 9 ) <NEWLINE> b = set ( 0 , 1 , 6 , 8 ) <NEWLINE> if one in a : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif one in b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> n = input ( ) <NEWLINE> p = 3 <NEWLINE> a = n / 100 <NEWLINE> n = n - a <NEWLINE> b = n / 10 <NEWLINE> n = n - b <NEWLINE> c = n / <NEWLINE> if ( p == 0 ) : <NEWLINE> <INDENT> print ( hon ) <NEWLINE> <DEDENT> else if ( p == 1 ) : <NEWLINE> <INDENT> print ( pon ) <NEWLINE> <DEDENT> else if ( p == 2 ) : <NEWLINE> <INDENT> print ( bon ) <NEWLINE> <DEDENT>
if int ( input ( ) ) % 10 == 3 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> elif int ( input ( ) ) % 10 == 0 or int ( input ( ) ) % 10 == 1 or int ( input ( ) ) % 10 == 6 or int ( input ( ) ) % 10 == 8 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
m = 0 <NEWLINE> m = input ( ) <NEWLINE> m = m % 10 <NEWLINE> if ( m == 2 , 4 , 5 , 7 , 9 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif ( m == 0 , 1 , 6 , 8 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
num = int ( raw_input ( ) ) <NEWLINE> n = num % int ( len ( str ( num ) ) ) <NEWLINE> s1 = [ 2 , 4 , 5 , 7 , 9 ] <NEWLINE> s2 = [ 0 , 1 , 6 , 8 ] <NEWLINE> if n in s1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif n in s2 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
num = int ( input ( ) ) <NEWLINE> <NL> if num [ - 1 ] == 2 or 4 or 5 or 7 or 9 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif num [ - 1 ] == 0 or 1 or 6 or 8 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = input ( ) <NEWLINE> <NL> one_digit = N % 10 <NEWLINE> if one_digit == 2 or one_digit == 4 or one_digit == 5 or one_digit == 7 or one_digit == 9 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif one_digit == 0 or one_digit == 1 or one_digit == 6 or one_digit == 8 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = input ( ) <NEWLINE> if N [ - 1 ] == <STRING> : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT>
n = input ( ) % 10 <NEWLINE> if n == 3 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif n == 0 or 1 or 6 or 8 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = input ( ) <NEWLINE> n_ichi = n % 10 <NEWLINE> <NL> if n_ichi == 3 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif n_ichi == 0 or n_ichi == 1 or n_ichi == 6 or n_ichi == 8 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = input ( ) [ - 1 : ] <NEWLINE> <NL> if N = <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif N in { 0 , 1 , 6 , 8 } : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( raw_input ( ) ) <NEWLINE> last = n % 10 <NEWLINE> hon = [ 2 , 4 , 5 , 7 , 9 ] <NEWLINE> pon = [ 0 , 1 , 6 , 8 ] <NEWLINE> bon = [ 3 ] <NEWLINE> if last in hon : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> if last in pon : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> if last in bon : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
from math import sin , radians , cos , sqrt <NEWLINE> lst = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> A , B , H , M = tuple ( lst ) <NEWLINE> angle = M * 6 - ( H * 30 + M * 0.5 ) <NEWLINE> if abs ( angle ) > 180 : <NEWLINE> <INDENT> angle = 360 - abs ( angle ) <NEWLINE> <DEDENT> elif abs ( angle ) == 180 : <NEWLINE> <INDENT> X = A + B <NEWLINE> print ( X ) <NEWLINE> <DEDENT> elif abs ( angle ) == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> angle = abs ( angle ) <NEWLINE> area = A * B * sin ( radians ( angle ) ) / 2 <NEWLINE> co = sqrt ( 1 - sin ( radians ( angle ) ) ** 2 ) <NEWLINE> X = sqrt ( A ** 2 + B ** 2 - 2 * A * B * co ) <NEWLINE> print ( X ) <NEWLINE> <DEDENT>
a = input ( ) <NEWLINE> if a [ - 1 ] == 3 : print ( <STRING> ) <NEWLINE> elif : a [ - 1 ] == 0 or a [ - 1 ] == 1 or a [ - 1 ] == 6 or a [ - 1 ] == 8 : print ( <STRING> ) <NEWLINE> else : print ( <STRING> ) <NEWLINE>
n = input ( ) <NEWLINE> <NL> hon = [ 2 , 4 , 5 , 7 , 9 ] <NEWLINE> pon = [ 0 , 1 , 6 , 8 ] <NEWLINE> bon = 3 <NEWLINE> <NL> if n in hon : <NEWLINE> <INDENT> print ( hon ) <NEWLINE> <DEDENT> elif n in pon : <NEWLINE> <INDENT> print ( pon ) <NEWLINE> <DEDENT> elif n == bon : <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> if ( n % 10 = 2 ) | ( n % 10 = 4 ) | ( n % 10 = 5 ) | ( n % 10 = 7 ) | ( n % 10 = 9 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> elif ( n % 10 = 0 ) | ( n % 10 = 1 ) | ( n % 10 = 6 ) | ( n % 10 = 8 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = input ( ) <NEWLINE> if N % 10 == 3 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif N % 10 == 0 or N % 10 == 1 or N % 10 == 6 or N % 10 == 8 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> e = int ( N [ - 1 ] ) <NEWLINE> if e in ( 2 , 4 , 5 , 7 , 9 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif e in ( 0 , 1 , 6 , 8 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
m = input ( ) <NEWLINE> <NL> m = n [ - 1 ] <NEWLINE> if m == 0 , 1 , 6 , 8 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif m == 3 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> X = N [ - 1 ] <NEWLINE> if X == 2 or X == 4 or X == 5 or X == 7 or X == 9 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> if X == 3 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a = int ( input ( ) ) <NEWLINE> b = a % 10 <NEWLINE> print ( <STRING> if b == 2 , 4 , 5 , 7 , 9 else <STRING> if b == 0 , 1 , 6 , 8 else <STRING> ) <NEWLINE>
K = int ( input ( ) ) <NEWLINE> S = str ( input ( ) ) <NEWLINE> if len ( S ) <= K : <NEWLINE> <INDENT> print ( S [ : K ] ) <NEWLINE> <DEDENT> elif len ( S ) > K : <NEWLINE> <INDENT> print ( S [ : K ] + ( <STRING> * 3 ) ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> n = n % 10 <NEWLINE> if n == 2 or n == 4 or n == 5 or n == 7 or n == 9 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif n == 0 or n == 1 or n == 6 or n == 8 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = input ( ) <NEWLINE> n %= 10 <NEWLINE> hon = [ 2 , 4 , 5 , 7 , 9 ] <NEWLINE> pon = [ 0 , 1 , 6 , 8 ] <NEWLINE> bon = [ 3 ] <NEWLINE> <NL> if n in hon : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif n in pon : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import math <NEWLINE> <NL> A , B , H , M = map ( int , input ( ) . split ( ) ) <NEWLINE> MM = 6 * M <COMMENT> <NEWLINE> HH = H * 30 + M // 2 <NEWLINE> rad = MM - HH <NEWLINE> if ( rad >= - 90 and rad <= 90 ) : <NEWLINE> <INDENT> cosine = math . cos ( math . radians ( rad ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cosine = 0 - math . cos ( math . radians ( rad ) ) <NEWLINE> <NL> <DEDENT> r = math . sqrt ( A ** 2 + B ** 2 - 2 * A * B * cosine ) <NEWLINE> print ( r ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> a = int ( n [ - 1 ] ) <NEWLINE> <NL> if n == 2 or n == 2 or n == 5 or n == 7 or n == 9 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif n == 0 or n == 1 or n == 6 or n == 8 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) . split ( ) ) <NEWLINE> <NL> n %= 10 <NEWLINE> <NL> if n == 0 or 1 or 6 or 8 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif n == 2 or 4 or 5 or 7 or 9 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
if aa in ( 2 , 4 , 5 , 7 , 9 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> if aa in ( 0 , 1 , 6 , 8 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> if aa == 3 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT>
N = input ( ) <NEWLINE> n = N [ len ( N ) ] <NEWLINE> if n == <STRING> or n == <STRING> or n == <STRING> or n == <STRING> or n == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif n == <STRING> or n == <STRING> or n == <STRING> or n == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
def Ii ( ) : return int ( input ( ) ) <NEWLINE> def Mi ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def Li ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> n = Ii ( ) % 10 <NEWLINE> if n == 3 <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif n == 2 or n == 4 or n == 5 or n == 7 or n == 9 <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = n [ 0 ] <NEWLINE> if a in list ( <STRING> ) : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <DEDENT> elif a in list ( <STRING> ) : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
num = input ( ) <NEWLINE> lst = list ( map ( int , num ) ) <NEWLINE> ele = lst [ - 1 ] <NEWLINE> if ele == 2 or ele == 4 or ele == 5 or ele == 7 or ele == 9 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif ele == 1 or ele == 6 or ele == 8 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif ele == 3 <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
mylist1 = [ 2 , 4 , 5 , 7 , 9 ] <NEWLINE> mylist2 = [ 0 , 1 , 6 , 8 ] <NEWLINE> N = int ( input ( ) ) <NEWLINE> X = N % 10 <NEWLINE> if X in mylsit1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif X in mylist2 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> <NL> num = n % 10 <NEWLINE> <NL> if num == 3 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif ( num == 0 or num == 1 or num == 6 or num == 8 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = input ( ) <NEWLINE> if ( N % 100 ) % 10 in [ 2 , 4 , 5 , 7 , 9 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif ( N % 100 ) % 10 in [ 0 , 1 , 6 , 8 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = input ( ) <NEWLINE> <NL> M = N % 10 <NEWLINE> <NL> if ( M == 2 or M == 4 or M == 5 or M == 7 or M == 9 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> else if ( M == 0 or M == 1 or M == 6 or M == 8 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> else if ( M == 3 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = input ( ) <NEWLINE> num = int ( n [ - 1 ] ) <NEWLINE> <NL> if ( num == 2 or num = 4 or num == 5 or num == 7 or num == 9 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif ( num == 1 or num = 6 or num == 8 or num == 0 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s = int ( input ( ) ) <NEWLINE> a = s [ - 1 ] <NEWLINE> if a in [ 2 , 4 , 5 , 7 , 9 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a in [ 0 , 1 , 6 , 8 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = str ( input ( ) ) <NEWLINE> <NL> l = len ( n ) <NEWLINE> <NL> <NL> if n [ l - 1 ] == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif ( n [ l - 1 ] == = <STRING> or n [ l - 1 ] == = <STRING> or n [ l - 1 ] == = <STRING> or n [ l - 1 ] == = <STRING> ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> if n [ - 1 ] == 3 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif n [ - 1 ] == 2 or 4 or 5 or 7 or 9 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = input ( ) <NEWLINE> l = len ( n ) <NEWLINE> nn = int ( n ) <NEWLINE> a = [ 2 , 4 , 5 , 7 , 9 ] <NEWLINE> b = [ 0 , 1 , 6 , 8 ] <NEWLINE> k = nn [ l - 1 ] <NEWLINE> if k in a : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif k in b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = input ( ) <NEWLINE> N = int ( input ( ) ) <NEWLINE> N = str ( N ) <NEWLINE> N = ( N [ - 1 ] ) <NEWLINE> if ( N == 2 or N == 4 or N == 5 or N == 7 or N == 9 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif ( N == 0 or N == 1 or N == 6 or N == 8 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif ( N == 3 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> n = N [ - 1 ] <NEWLINE> if n == 3 : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <DEDENT> elif n == 0 or n == 1 or n == 6 or n == 8 : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
N = input ( ) <NEWLINE> n = int ( N [ - 1 ] ) <NEWLINE> <NL> if n == 2 or n == 4 or n == 5 n == 7 n == 9 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif n == 3 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
i = int ( input ( ) ) <NEWLINE> a = i % 10 <NEWLINE> if a in [ 2 , 4 , 5 , 7 , 9 ] : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> if a in [ 0 , 1 , 6 , 8 ] : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> if a in [ 3 ] : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> S = N % 10 <NEWLINE> if ( S == 0 | | 1 | | 8 | | 6 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif ( S == 3 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = int ( ( str ( n ) ) [ - 1 ] ) <NEWLINE> hon = [ 2 , 4 , 5 , 7 , 9 ] <NEWLINE> pon = [ 0 , 1 , 6 , 8 ] <NEWLINE> if a in hon : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> elif a in pon : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT>
x = int ( input ( ) ) % 10 <NEWLINE> if x == 6 , 1 , 8 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> if x == 3 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> n = sys . stdin . readline ( ) <NEWLINE> <NL> last = int ( n [ - 1 ] ) <NEWLINE> <NL> result = <STRING> <NEWLINE> if last in [ 0 , 1 , 6 , 8 ] : <NEWLINE> <INDENT> result = <STRING> <NEWLINE> <DEDENT> elif last == 3 : <NEWLINE> <INDENT> result = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> result = <STRING> <NEWLINE> <NL> <DEDENT> print ( result ) <NEWLINE>
n = input ( ) <NEWLINE> a = int ( n [ - 1 ] ) <NEWLINE> if a == 2 or a == 4 or a == 5 or a == 7 or a == 9 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a == 0 or a == 1 or a == 6 a == 8 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a = int ( input ( ) ) <NEWLINE> <NL> while a > 10 : <NEWLINE> <INDENT> a = a % 10 <NEWLINE> <NL> <DEDENT> if a == 2 or a == 4 or a == 5 or a == 7 or a == 9 <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a == 0 or a == 1 or a == 6 or a == 8 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> <NL> a = n // 10 <NEWLINE> if a == 3 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a == 0 or a == 6 or a == 8 or a == 1 <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = input ( ) <NEWLINE> l = [ 2 , 4 , 5 , 7 , 9 ] <NEWLINE> l2 = [ 0 , 1 , 6 , 8 ] <NEWLINE> l3 = [ 3 ] <NEWLINE> <NL> if ( n % 10 ) in l : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif ( n % 10 ) in l2 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = input ( ) <NEWLINE> r = N % 10 <NEWLINE> if r == 2 or r == 4 or r == 5 or r == 7 or r == 9 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif r == 0 or r == 1 or r == 6 or r == 8 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = input ( ) <NEWLINE> N = N % 10 <NEWLINE> if N in [ 2 , 4 , 5 , 7 , 9 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> elif N in [ 0 , 1 , 6 , 8 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
def a ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) % 10 <NEWLINE> if n == 2 or n == 4 or n == 5 or n == 7 or n == 9 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif n == 3 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <NL> <NL> <NL> <DEDENT> <DEDENT> def b ( ) : <NEWLINE> <NL> def c ( ) : <NEWLINE> <NL> <NL> <COMMENT> <NL> <NL> <NL> a ( ) <NEWLINE>
num == int ( input ( ) ) <NEWLINE> num_1 == num % 10 <NEWLINE> if num_1 == 3 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif num_1 <= 1 or num_1 == 6 or num_1 == 8 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> m = N [ - 1 ] <NEWLINE> if m == 2 or m == 4 or m == 5 or m == 7 or m == 9 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif m == 0 or m == 1 or m == 6 or m == 8 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else <NEWLINE> <INDENT> print ( <STRING> <NEWLINE> <DEDENT>
n = sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> hon = [ 2 , 4 , 5 , 7 , 9 ] <NEWLINE> pon = [ 0 , 1 , 6 , 8 ] <NEWLINE> bon = [ 3 ] <NEWLINE> if int ( n [ - 1 ] ) in hon : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif int ( n [ - 1 ] ) in pon : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif int ( n [ - 1 ] ) in bon : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if a % 10 == 3 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a % 10 in [ 0 , 1 , 6 , 8 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
v = int ( input ( ) ) <NEWLINE> <NL> v = v % 10 <NEWLINE> if v = 3 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif v % 2 == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> L = [ 0 , 1 , 6 , 8 ] <NEWLINE> n_last = int ( N [ - 1 ] ) <NEWLINE> if n_last == 3 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif ( n_last in L ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> main ( ) <NEWLINE>
<COMMENT> <NL> <STRING> <NEWLINE> <NL> yomi = { 2 : <STRING> , 4 : <STRING> , 5 : <STRING> , 7 : <STRING> , 9 : <STRING> , 0 : <STRING> , 1 : <STRING> , <NEWLINE> <INDENT> 6 : <STRING> , 8 : <STRING> , 3 : <STRING> } <NEWLINE> <NL> <DEDENT> print ( yomi [ input ( ) [ - 1 ] ] ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> if N [ - 1 ] == <STRING> or N [ - 1 ] == <STRING> or N [ - 1 ] == <STRING> or N [ - 1 ] == <STRING> or N [ - 1 ] == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif N [ - 1 ] == <STRING> or N [ - 1 ] == <STRING> or N [ - 1 ] == <STRING> or N [ - 1 ] == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif N [ - 1 ] == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
l = [ <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> n = input ( ) <NEWLINE> print ( l [ int ( n [ 2 ] ) ] + <STRING> ) <NEWLINE>
hon = input ( ) <NEWLINE> <NL> digit_1 = hon % 10 <NEWLINE> <NL> if digit_1 == 2 or 4 or 5 or 7 or 9 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> elif digit_1 == 0 or 1 or 6 or 8 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> elif digit_1 == 3 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) ; <NEWLINE> a = n % 10 <NEWLINE> <NL> if a == 2 or a == 4 or a == 5 or 7 a == 9 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a == 0 or a == 1 or a == 6 or a == 8 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> n = N [ - 1 ] <NEWLINE> if n == <STRING> or n == <STRING> or n == <STRING> or n == <STRING> or n == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif n == <STRING> or n == <STRING> or n == <STRING> or n == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a = int ( N / 10 ) <NEWLINE> c = N - a * 10 <NEWLINE> <NL> if c == 0 or c == 1 or c == 6 or c == 8 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif c == 3 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = input ( ) <NEWLINE> N . reverse ( ) <NEWLINE> a = int ( N [ 0 ] ) <NEWLINE> ans = [ ] <NEWLINE> if a == 2 | | a == 4 | | a == 5 | | a == 7 | | a == 9 : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <DEDENT> if a == 0 | | a == 1 | | a == 6 | | a == 8 : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <DEDENT> if a == 3 : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> n = N % 10 <NEWLINE> if n == 2 or 4 or 5 or 7 or 9 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif n == 0 or 1 or 6 or 8 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else n == 3 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> if N % 10 == 3 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else if N % 10 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else if N % 10 == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else if N % 10 == 6 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else if N % 10 == 8 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
<NL> val = input ( ) <NEWLINE> if val <= 999 : <NEWLINE> <INDENT> str_val = str ( val ) <NEWLINE> val_one = str_val [ - 1 ] <NEWLINE> if val_one in { <STRING> , <STRING> , <STRING> , <STRING> , <STRING> } : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif val_one in { <STRING> , <STRING> , <STRING> , <STRING> } : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif val_one == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> num = n [ - 1 ] <NEWLINE> num1 = num [ - 1 ] <NEWLINE> if num1 == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif num1 == <STRING> or num1 == <STRING> or num1 == <STRING> or num1 == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = input ( ) <NEWLINE> s = 10 <NEWLINE> N = n % s <NEWLINE> if N == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> if N == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> if N == 2 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> if N == 3 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> if N == 4 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> if N == 5 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> if N == 6 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> if N == 7 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> if N == 8 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> if N == 9 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
x = input ( ) <NEWLINE> <NL> if x % 10 == 3 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif x % 10 == 0 or x % 10 == 1 or x % 10 == 6 or x % 10 == 8 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> <NL> if n in ( 2 , 4 , 5 , 7 , 9 ) : <NEWLINE> <INDENT> yomi = <STRING> <NEWLINE> <DEDENT> if n in ( 0 , 1 , 6 , 8 ) : <NEWLINE> <INDENT> yomi = <STRING> <NEWLINE> <DEDENT> if n == ( 3 ) : <NEWLINE> <INDENT> yomi = <STRING> <NEWLINE> <NL> <DEDENT> print ( yomi ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> m = n % 10 <NEWLINE> if m == 2 or m == 4 or m == 5 or m == 7 or m == 9 : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> elif m == 0 or m == 1 or m == 6 or m == 8 : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> elif m == 3 : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> if n [ - 1 ] in [ 1 , 4 , 5 , 7 , 9 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif n [ - 1 ] in [ 0 , 1 , 6 , 8 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> <NL> if N [ - 1 ] == 3 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif N [ - 1 ] == 0 or N [ - 1 ] == 1 or N [ - 1 ] == 6 or N [ - 1 ] == 8 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> if N in [ 2 , 4 , 5 , 7 , 9 ] : print ( N + str ( N ) + <STRING> ) <NEWLINE> elif N in [ 0 , 1 , 6 , 8 ] : print ( N + str ( N ) + <STRING> ) <NEWLINE> else : print ( N + str ( N ) + <STRING> ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> n = N % 10 <NEWLINE> <NL> print ( <STRING> if n == 3 ) <NEWLINE> print ( <STRING> if n == 0 or n == 1 or n == 6 or n == 8 ) <NEWLINE> print ( <STRING> if n == 2 or n == 4 or n == 5 or n == 7 or n == 9 ) <NEWLINE>
A = map ( int , open ( 0 ) . read ( ) . split ( ) ) <NEWLINE> rem = A % 10 <NEWLINE> if rem == 3 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif ( rem == 0 ) or ( rem == 1 ) or ( rem == 6 ) or ( rem == 8 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> X = ( N % 100 ) % 10 <NEWLINE> if X == 3 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif X == 0 or X = 1 or X == 6 or X = 8 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> <NL> if int ( N ) % 10 = 3 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif int ( N ) % 10 = 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif int ( N ) % 10 = 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif int ( N ) % 10 = 6 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif int ( N ) % 10 = 8 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = input ( ) <NEWLINE> if n [ - 1 ] in <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif n [ - 1 ] in <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif n [ - 1 ] in <STRING> <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = input ( ) <NEWLINE> h = ( 2 , 4 , 5 , 7 , 9 ) <NEWLINE> p = ( 0 , 1 , 6 , 8 ) <NEWLINE> b = 3 <NEWLINE> m = int ( n ) % 10 <NEWLINE> if m in b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> if m in p : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> if m == h : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
<INDENT> input ( ) <NEWLINE> <DEDENT> if N [ - 1 ] in <STRING> <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif N [ - 1 ] in <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
if N [ - 1 ] == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif N [ - 1 ] == ( <STRING> or <STRING> or <STRING> or <STRING> ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
i = input ( ) <NEWLINE> l = int ( i [ - 1 ] ) <NEWLINE> <NL> if l == 3 : <NEWLINE> <INDENT> print ( bon ) <NEWLINE> <DEDENT> elif l == 0 or l == 1 or l == 6 or l == 8 : <NEWLINE> <INDENT> print ( pon ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( hon ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> <NL> if N % 10 == 3 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else if N % 10 == 0 or N % 10 == 1 or N % 10 == 6 or N % 10 == 8 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : print ( <STRING> ) <NEWLINE>
n = int ( stdin . readline ( ) . rstrip ( ) [ - 1 ] ) <NEWLINE> <NL> if n == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif n in [ <STRING> , <STRING> , <STRING> , <STRING> ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import math <NEWLINE> <NL> n = input ( ) <NEWLINE> <NL> if n [ len ( n ) ] == 3 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif n [ len ( n ) ] == 0 or n [ len ( n ) ] == 1 or n [ len ( n ) ] == 0 or n [ len ( n ) ] == 6 or n [ len ( n ) ] == 8 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
U = int ( input ( ) ) <NEWLINE> b = str ( U ) <NEWLINE> c = int ( b [ - 1 ] ) <NEWLINE> if c in [ 2 , 4 , 5 , 7 , 9 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif c in [ 0 , 1 , 6 , 8 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) S <NEWLINE> <DEDENT>
N = input ( ) <NEWLINE> <NL> if N [ - 1 ] == 2 or N [ - 1 ] == 4 or N [ - 1 ] == 5 or N [ - 1 ] == 7 or N [ - 1 ] == 9 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> elif N [ - 1 ] == 0 or N [ - 1 ] == 1 or N [ - 1 ] == 6 or N [ - 1 ] == 8 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = list ( input ( ) ) <NEWLINE> hon = [ 2 , 4 , 5 , 7 , 9 ] <NEWLINE> pon = [ 0 , 1 , 6 , 8 ] <NEWLINE> if int ( N [ 2 ] ) in hon : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif int ( N [ 2 ] ) in pon : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a = input ( ) <NEWLINE> <NL> if a [ - 1 ] == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a [ - 1 ] == <STRING> or a [ - 1 ] == <STRING> or a [ - 1 ] == <STRING> or a [ - 1 ] == <STRING> <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a [ - 1 ] == <STRING> or a [ - 1 ] == <STRING> or a [ - 1 ] == <STRING> or a [ - 1 ] == <STRING> or a [ - 1 ] == <STRING> <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> <NL> if ( n % 10 == 3 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else if ( n % 10 in [ 0 , 1 , 6 , 8 ] ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
h = [ 2 , 4 , 5 , 7 , 9 ] <NEWLINE> p = [ 0 , 1 , 6 , 8 ] <NEWLINE> b = [ 3 ] <NEWLINE> <NL> n = input ( ) <NEWLINE> <NL> n = n % 10 <NEWLINE> <NL> if n in h : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> elif n in p : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> elif n in b : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT>
def atcoder ( ) : <NEWLINE> <INDENT> i = input ( ) <NEWLINE> mod = i % 10 <NEWLINE> if i == 3 <NEWLINE> <INDENT> str = <STRING> <NEWLINE> <DEDENT> else if i == 0 | | i == 1 | | i == 6 | | i == 8 <NEWLINE> <INDENT> str = <STRING> <NEWLINE> <DEDENT> else <NEWLINE> <INDENT> str = <STRING> <NEWLINE> <DEDENT> print ( str ) <NEWLINE> <DEDENT> atcoder ( ) <NEWLINE>
N = input ( ) <NEWLINE> B = 0 <NEWLINE> B = len ( N ) <NEWLINE> B = B - 1 <NEWLINE> if N [ B ] == <STRING> or N [ B ] == <STRING> N [ B ] == <STRING> or N [ B ] == <STRING> or N [ B ] == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif N [ B ] == <STRING> or N [ B ] == <STRING> or N [ B ] == <STRING> or N [ B ] == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
K = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> <NL> if K >= len ( S ) : <NEWLINE> <INDENT> print ( S ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( S [ 0 : K ] + <STRING> ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> a = N [ - 1 ] <NEWLINE> <NL> if a == 3 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a == 0 or a == 1 or a == 6 or a == 8 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> <NL> x = N % 10 <NEWLINE> if X == 3 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> elif x == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> elif x == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> elif x == 6 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> elif x == 8 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = list ( int ( input ( ) ) ) <NEWLINE> if N [ - 1 ] == 0 or N [ - 1 ] == 1 or N [ - 1 ] == 6 or N [ - 1 ] == 8 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif N [ - 1 ] == 3 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = input ( ) <NEWLINE> N = int ( n ) <NEWLINE> <NL> m = N % 10 <NEWLINE> <NL> if ( m == 3 ) : <NEWLINE> <INDENT> print ( bon ) <NEWLINE> <DEDENT> elif ( m == 0 or m == 1 or m == 6 or m == 8 ) : <NEWLINE> <INDENT> print ( pon ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( hon ) <NEWLINE> <DEDENT>
n = int ( input ( ) [ - 1 ] ) <NEWLINE> if n in [ 2 , 4 , 5 , 7 , 9 ] : print ( <STRING> ) <NEWLINE> else if n in [ 0 , 1 , 6 , 8 ] : print ( <STRING> ) <NEWLINE> else : print ( <STRING> ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> <NL> if N % 10 == 2 orN % 10 == 4 or N % 10 == 5 or N % 10 == 7 or N % 10 == 9 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif N % 10 == 0 orN % 10 == 1 or N % 10 == 6 or N % 10 == 8 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = input ( ) <NEWLINE> x = n % 10 <NEWLINE> if x == 3 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else x == 0 | | x == 1 | | x == 6 | | x == 8 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a = input ( ) <NEWLINE> s = str ( a ) <NEWLINE> <INDENT> if ( s [ - 1 ] in ( <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ) ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif ( s [ - 1 ] in ( <STRING> , <STRING> , <STRING> , <STRING> ) ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif ( s [ - 1 ] == <STRING> ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
a = list ( input ( ) ) <NEWLINE> ai = int ( a [ - 1 ] ) <NEWLINE> if [ 2 , 4 , 5 , 7 , 9 ] . includes ( ai ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> if [ 0 , 1 , 6 , 8 ] . includes ( ai ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> if [ 3 ] . includes ( ai ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a = int ( input ( ) ) <NEWLINE> b = a % 10 <NEWLINE> print ( b ) <NEWLINE> if b == 2 or b == 4 or b == 5 or b == 7 or b == 9 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elsif b == 0 or b == 1 or b == 6 or b == 8 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> amari = N % 10 <NEWLINE> if | m == 2 | | m ~ ~ 4 | | m == 5 | | m == 7 | | m == 9 | in str ( amari ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = input ( ) <NEWLINE> if N % 10 == 3 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif N % 10 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif N % 10 == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif N % 10 == 6 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif N % 10 == 8 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> if n == 3 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif n = 0 or n = 1 or n = 6 or n = 8 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import sys <NEWLINE> n = int ( raw_input ( ) ) <NEWLINE> if n % 10 == 3 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif n % 10 == 0 or n % 10 == 10 or n % 10 == 6 or n % 10 == 8 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
nb = int ( input ( ) ) <NEWLINE> number = len ( nb ) - 1 <NEWLINE> <NL> if nb [ number ] in [ 2 , 4 , 5 , 7 , 9 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif nb [ number ] in [ 0 , 1 , 6 , 8 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = input ( ) <NEWLINE> <NL> a = int ( N [ len ( N ) - 1 ] ) <NEWLINE> <NL> if a == 3 : <NEWLINE> <INDENT> print ( bon ) <NEWLINE> <DEDENT> else if a == 0 or a == 1 or a == 6 or a == 8 : <NEWLINE> <INDENT> print ( pon ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( hon ) <NEWLINE> <DEDENT>
a = input ( ) [ - 1 <NEWLINE> if a == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a == <STRING> or a == <STRING> or a == <STRING> or a == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = input ( ) <NEWLINE> i = n % 10 <NEWLINE> if ( i == 3 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif ( i == 0 or i == 1 or i == 6 or i == 8 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = input ( ) <NEWLINE> print ( <STRING> if N [ - 1 ] == 3 else <STRING> if N [ - 1 ] in == 0 or N [ - 1 ] == 1 or N [ - 1 ] == 6 or N [ - 1 ] == 8 else <STRING> ) <NEWLINE>
print ( <STRING> . index ( int ( input ( ) ) % 10 ) + <STRING> ) <NEWLINE>
N = input ( ) <NEWLINE> n1 = N % 10 <NEWLINE> <NL> if n1 in ( 2 , 4 , 5 , 7 , 9 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif n1 in ( 0 , 1 , 6 , 8 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a = int ( input ( ) ) <NEWLINE> b = a [ - 1 ] <NEWLINE> if b == 3 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif b == 2 or b == 4 or b == 5 or b == 7 or b == 9 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = input ( ) <NEWLINE> <NL> N = N % 10 <NEWLINE> <NL> if N == 2 or N == 4 or N == 5 or N == 7 or N == 9 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> elif N == 0 or N == 1 or N == 6 or N == 8 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
x = input ( ) <NEWLINE> <NL> <NL> x = int ( a [ 0 ] ) <NEWLINE> <NL> if x % 10 == 2 or 4 or 5 or 7 or 9 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif x % 10 == 0 or 1 or 6 or 8 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else x % 10 == 3 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a = int ( print ( ) ) <NEWLINE> b = print ( a [ - 1 ] ) <NEWLINE> if b == 3 : <NEWLINE> <INDENT> print ( a + <STRING> ) <NEWLINE> <DEDENT> elif b == 0 or 1 or 6 or 8 : <NEWLINE> <INDENT> print ( a + <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( a + <STRING> ) <NEWLINE> <DEDENT>
n = print ( ) <NEWLINE> <NL> s = int ( n ) % 10 <NEWLINE> <NL> if s == 3 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> if s == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> if s == 2 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> if s == 4 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> if s == 5 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> if s == 6 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> if s == 7 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> if s == 8 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> if s == 9 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> if s == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
enpitu = input ( <STRING> ) <NEWLINE> if enpitu <= 999 : <NEWLINE> <INDENT> honsuu = enpitu // 10 <NEWLINE> if honsuu == 3 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif honsuu == 0 , 1 , 6 , 8 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT>
n = input ( ) <NEWLINE> <NL> s = N % 10 <NEWLINE> <NL> if s in [ 3 ] <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> if s in [ 0 , 1 , 6 , 8 ] <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> if s in [ 2 , 4 , 5 , 7 , 9 ] <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
def josu ( N ) : <NEWLINE> <INDENT> N %= 10 <NEWLINE> if ( ( N == 2 ) or ( N == 4 ) or ( N == 5 ) or ( N == 7 ) or ( N == 9 ) ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif ( ( N == 0 ) or ( N == 1 ) or ( N == 6 ) or ( N == 8 ) ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> josu ( N ) <NEWLINE>
s = input ( ) <NEWLINE> print ( S ) <NEWLINE>
def solve ( N ) : <NEWLINE> <INDENT> last = int ( str ( N ) [ len ( N ) - 1 ] ) <NEWLINE> if last == 0 or last == 1 or last == 6 or last == 8 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif last == 3 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> N = open ( 0 ) . read ( ) <NEWLINE> solve ( N ) <NEWLINE>
nums = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if nums [ - 1 ] == 3 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif nums [ - 1 ] == 0 or nums [ - 1 ] == 1 or nums [ - 1 ] == 6 or nums [ - 1 ] == : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> n = input ( <STRING> ) <NEWLINE> try : <NEWLINE> <INDENT> n = int ( n ) <NEWLINE> <DEDENT> except ValueError : <NEWLINE> <INDENT> print ( n , <STRING> ) <NEWLINE> continue <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> if ( n <= 0 or n > 999 ) : <NEWLINE> <INDENT> print ( n , <STRING> ) <NEWLINE> continue <NEWLINE> <NL> <DEDENT> while n >= 100 : <NEWLINE> <INDENT> n -= 100 <NEWLINE> <DEDENT> while n >= 10 : <NEWLINE> <INDENT> n -= 10 <NEWLINE> <NL> <DEDENT> if n == 3 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif n == 0 or n == 1 or n == 6 or n == 8 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
s = input ( ) <NEWLINE> if s . endswith ( <STRING> ) == True or s . endswith ( <STRING> ) == True or s . endswitch ( <STRING> ) == True or s . endswith ( <STRING> ) == True or s . endswith ( <STRING> ) == True : <NEWLINE> <NL> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif s . endswith ( <STRING> ) == True or s . endswith ( <STRING> ) == True or s . endswitch ( <STRING> ) == True or s . endswitch ( <STRING> ) == True : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = input ( ) <NEWLINE> if len ( n ) > 1 : <NEWLINE> <INDENT> N = N [ 1 ] <NEWLINE> <NL> <DEDENT> if N in [ <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif N == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = str ( input ( ) ) <COMMENT> <NEWLINE> <NL> car = <STRING> <NEWLINE> if N [ - 1 ] == 3 : <NEWLINE> <INDENT> car = <STRING> <NEWLINE> <DEDENT> elif N [ - 1 ] == 0 or N [ - 1 ] == 1 or N [ - 1 ] == 6 or N [ - 1 ] == 8 <NEWLINE> <INDENT> car = <STRING> <NEWLINE> <NL> <DEDENT> print ( car ) <NEWLINE>
n = int ( input ( ) ) % 10 <NEWLINE> if n = 3 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif n in [ 0 , 1 , 6 , 8 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
imporet re <NEWLINE> <NL> N = input ( ) <NEWLINE> <NL> if re . match ( <STRING> , N [ - 1 ] ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif re . match ( <STRING> , N [ - 1 ] ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
ls = list ( [ 2 , 4 , 5 , 7 , 9 ] , [ 0 , 1 , 6 , 8 ] , [ 3 ] ) <NEWLINE> dic = dict { [ 2 , 4 , 5 , 7 , 9 ] : <STRING> , [ 0 , 1 , 6 , 8 ] : <STRING> , [ 3 ] : <STRING> } <NEWLINE> s = int ( input ( ) ) <NEWLINE> for i in ls : <NEWLINE> <INDENT> if s % 10 in i : <NEWLINE> <INDENT> print ( dic [ i ] ) <NEWLINE> <DEDENT> <DEDENT>
N = input ( ) <NEWLINE> <NL> try : <NEWLINE> <INDENT> if 0 <= int ( N ) <= 999 : <NEWLINE> <INDENT> if N [ - 1 ] is <STRING> or <STRING> or <STRING> or <STRING> or <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif N [ - 1 ] is <STRING> or <STRING> or <STRING> or <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif N [ - 1 ] is <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> except ValueError : <NEWLINE> <INDENT> exit ( ) <NEWLINE> <DEDENT>
N = str ( N ) <NEWLINE> identify = N [ - 1 ] <NEWLINE> answer = <STRING> <NEWLINE> pon_list = [ <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> bon_list = [ <STRING> ] <NEWLINE> if identify in pon_list : <NEWLINE> <INDENT> answer = <STRING> <NEWLINE> <DEDENT> elif identify in bon_list : <NEWLINE> <INDENT> answer = <STRING> <NEWLINE> <DEDENT> print ( answer ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> p = n % 10 <NEWLINE> if ( p == 2 | | p == 4 | | p == 5 | | p == 7 | | p == 9 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif ( p == 3 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = input ( ) <NEWLINE> if N [ - 1 ] in [ 2 , 4 , 5 , 7 , 9 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif N [ - 1 ] in [ 0 , 1 , 6 , 8 ] : <NEWLINE> <INDENT> print ( <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <NL> <NL> <INDENT> A , B = map ( float , input ( ) . split ( ) ) <NEWLINE> <NL> if A == 0 : <NEWLINE> <INDENT> return 0 <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> AB = A * ( B * 100 ) <NEWLINE> <NL> if AB > 1e18 : <NEWLINE> <INDENT> return - 1 <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> return int ( AB / 100 ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> print ( main ( ) ) <NEWLINE>
i = int ( input ( ) ) <NEWLINE> <NL> while i != 0 : <NEWLINE> <INDENT> i = i % 10 <NEWLINE> if i == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif i == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif i == 2 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif i == 3 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif i == 4 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif i == 5 : <NEWLINE> print ( <STRING> ) <NEWLINE> elif i == 6 : <NEWLINE> print ( <STRING> ) <NEWLINE> elif i == 7 : <NEWLINE> print ( <STRING> ) <NEWLINE> elif i == 8 : <NEWLINE> print ( <STRING> ) <NEWLINE> elif i == 9 : <NEWLINE> print ( <STRING> ) <NEWLINE> <NL> i = int ( input ( ) ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> a = int ( input ( ) ) <NEWLINE> <NL> i = a % 10 <NEWLINE> <NL> if i == 2 or 4 or 5 or 7 or 9 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> return <NEWLINE> <DEDENT> elif i == 0 or 1 or 6 or 8 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> return <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> main ( ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <NL> def name_count ( N ) : <NEWLINE> <INDENT> x = N % 10 <NEWLINE> if x in [ 2 , 4 , 5 , 7 , 9 ] : return <STRING> <NEWLINE> elif x in [ 0 , 1 , 6 , 8 ] : return <STRING> <NEWLINE> else return <STRING> <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> print ( name_count ( N ) ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) [ - 1 ] ) <NEWLINE> <NL> if in [ 2 , 4 , 5 , 7 , 9 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif n in [ 0 , 1 , 6 , 8 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> if n [ - 1 ] == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif n [ - 1 ] == [ <STRING> , <STRING> , <STRING> , <STRING> ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
x = input ( ) <NEWLINE> <NL> <NL> if x [ - 1 ] == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif x [ - 1 ] = <STRING> or x [ - 1 ] = <STRING> or x [ - 1 ] = <STRING> or x [ - 1 ] = <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <COMMENT> <NEWLINE> to_index = lambda x : int ( x ) - 1 <COMMENT> <NEWLINE> print_list_in_2D = lambda x : print ( * x , sep = <STRING> ) <COMMENT> <NEWLINE> <NL> <COMMENT> <NL> def input_int ( ) : <NEWLINE> <INDENT> return int ( input ( ) ) <NEWLINE> <NL> <DEDENT> def map_int_input ( ) : <NEWLINE> <INDENT> return map ( int , input ( ) ) <NEWLINE> <NL> <DEDENT> MII = map_int_input <NEWLINE> <NL> def MII_split ( ) : <NEWLINE> <INDENT> return map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <DEDENT> def MII_to_index ( ) : <NEWLINE> <INDENT> return map ( to_index , input ( ) ) <NEWLINE> <NL> <DEDENT> def MII_split_to_index ( ) : <NEWLINE> <INDENT> return map ( to_index , input ( ) . split ( ) ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> def list_int_inputs ( ) : <NEWLINE> <INDENT> return list ( map ( int , input ( ) ) ) <NEWLINE> <NL> <DEDENT> LII = list_int_inputs <NEWLINE> <NL> def LII_split ( ) : <NEWLINE> <INDENT> return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> def LII_2D ( rows_number ) : <NEWLINE> <INDENT> return [ LII ( ) for _ in range ( rows_number ) ] <NEWLINE> <NL> <DEDENT> def LII_split_2D ( rows_number ) : <NEWLINE> <INDENT> return [ LII_split ( ) for _ in range ( rows_number ) ] <NEWLINE> <NL> <NL> <DEDENT> import logging <NEWLINE> import sys <NEWLINE> import unittest <NEWLINE> from io import StringIO <NEWLINE> <NL> logging . basicConfig ( level = logging . DEBUG ) <NEWLINE> <NL> <NL> def resolve ( ) : <NEWLINE> import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <COMMENT> <NEWLINE> to_index = lambda x : int ( x ) - 1 <COMMENT> <NEWLINE> print_list_in_2D = lambda x : print ( * x , sep = <STRING> ) <COMMENT> <NEWLINE> <NL> <COMMENT> <NL> def input_int ( ) : return int ( input ( ) ) <NEWLINE> <NL> def map_int_input ( ) : return map ( int , input ( ) ) <NEWLINE> <NL> MII = map_int_input <NEWLINE> <NL> def MII_split ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> def MII_to_index ( ) : return map ( to_index , input ( ) ) <NEWLINE> <NL> def MII_split_to_index ( ) : return map ( to_index , input ( ) . split ( ) ) <NEWLINE> <NL> <COMMENT> <NL> def list_int_inputs ( ) : return list ( map ( int , input ( ) ) ) <NEWLINE> <NL> LII = list_int_inputs <NEWLINE> <NL> def LII_split ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <COMMENT> <NL> def LII_2D ( rows_number ) : return [ LII ( ) for _ in range ( rows_number ) ] <NEWLINE> <NL> def LII_split_2D ( rows_number ) : return [ LII_split ( ) for _ in range ( rows_number ) ] <NEWLINE> <NL> N = input_int ( ) <NEWLINE> N %= 10 <NEWLINE> if N == 3 : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <DEDENT> elif N in [ 0 , 1 , 6 , 8 ] : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n = input ( ) <NEWLINE> n = list ( n ) <NEWLINE> if n [ len ( n ) - 1 ] == 3 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif n [ len ( n ) - 1 ] == 0 or n [ len ( n ) - 1 ] == 1 or n [ len ( n ) - 1 ] == 6 or n [ len ( n ) - 1 ] == 8 : <NEWLINE> <INDENT> print ( <STRING> ) : <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = input ( ) <NEWLINE> if n [ - 1 ] == <STRING> or <STRING> or <STRING> or <STRING> or <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif n [ - 1 ] == <STRING> or <STRING> or <STRING> or <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else print ( <STRING> ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <COMMENT> <NEWLINE> <COMMENT> <NL> <NL> if ( h [ - 1 ] == 2 or h [ - 1 ] == 4 or h [ - 1 ] == 5 or h [ - 1 ] == 7 or h [ - 1 ] == 9 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif ( h [ - 1 ] == 0 or h [ - 1 ] == 1 or h [ - 1 ] == 6 or h [ - 1 ] == 8 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
str ( input ( ) ) <NEWLINE> n = int ( n [ - 1 ] ) <NEWLINE> <NL> if n == 3 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif n in [ 0 , 1 , 6 , 8 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
input = input ( ) [ - 1 ] <NEWLINE> if input == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif intpu in [ <STRING> , <STRING> , <STRING> , <STRING> ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> <NL> if N [ - 1 ] == 3 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif N [ - 1 ] in [ 0 , 1 , 6 , 8 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = input ( ) <NEWLINE> if N [ - 1 ] == 3 <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif N [ - 1 ] == 0 or 1 or 6 or 8 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = input ( ) <NEWLINE> S = N % 10 <NEWLINE> if ( S == 0 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else if ( S == 1 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else if ( S == 6 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else if ( S == 8 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else if ( S == 3 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = input ( ) <NEWLINE> N = N [ 2 ] <NEWLINE> if N = <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif N = <STRING> or N = <STRING> or N = <STRING> or N = <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> count = 0 <NEWLINE> while n > 0 : <NEWLINE> <INDENT> count = count + 1 <NEWLINE> n = n // 10 <NEWLINE> <DEDENT> if n = 2 or n = 4 or n = 5 or n = 7 or n = 9 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> if n = 0 or n = 1 or n = 6 or n = 8 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a = input ( ) <NEWLINE> if a % 10 == 3 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a % 10 == 0 or a % 10 == 1 or a % 10 == 6 or a % 10 == 8 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = input ( ) <NEWLINE> a = n % 10 <NEWLINE> if a == 3 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a == 0 or a == 1 or a == 6 or a == 8 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = n % 100 <NEWLINE> b = a % 10 <NEWLINE> if b == 3 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> if b == 2 | | b == 4 | | b == 5 | | b == 7 | | b == 9 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> if b == 0 | | b == 1 | | b == 6 | | b == 8 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> <NL> a = N % 100 <NEWLINE> a = a % 10 <NEWLINE> <NL> if a == 0 or a == 1 or a == 6 or a == 8 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a == 3 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> <NEWLINE> <DEDENT>
K = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> <NL> if len ( S ) < K : <NEWLINE> <INDENT> print ( S ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( K ) : <NEWLINE> <INDENT> print ( S [ i ] , end = <STRING> ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
input ( ) <NEWLINE> <INDENT> N = N % 10 <NEWLINE> <DEDENT> if N == 2 or N == 4 or N == 5 or N == 7 or N == 9 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif N == 3 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> if n = 2 or n = 4 or n = 5 or n = 7 or n = 9 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif n = 0 or n = 1 or n = 6 or n = 8 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = input ( ) <NEWLINE> m = int ( n ) <NEWLINE> <NL> <NL> <NL> print ( m ) <NEWLINE> <NL> if ( m [ - 1 ] == 3 : <NEWLINE> <INDENT> print ( bon ) <NEWLINE> <DEDENT> elif ( m [ - 1 ] ) == 6 or ( m [ - 1 ] ) == 8 or ( m [ - 1 ] ) == 0 : <NEWLINE> <INDENT> print ( pon ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> print ( hon ) <NEWLINE> <NL> <DEDENT>
n = input ( ) <NEWLINE> if ( n [ 2 ] == 3 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif ( n [ 2 ] == 0 ) or ( n [ 2 ] == 1 ) or ( n [ 2 ] == 6 ) or ( n [ 2 ] == 8 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = input ( ) <NEWLINE> <NL> last = int ( n [ - 1 ] ) <NEWLINE> <NL> bon = [ 3 ] <NEWLINE> pon = [ 0 , 1 , 6 , 8 ] <NEWLINE> <NL> if last in bon : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else if last in pon : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = int ( input ( <STRING> ) ) <NEWLINE> a = N % 10 <NEWLINE> if a = 2 or 4 or 5 or 7 or 9 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a = 0 or 1 or 6 or 8 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = input ( ) <NEWLINE> n_1 = int ( n [ - 1 ] ) <NEWLINE> hon = [ 2 , 4 , 5 , 7 , 9 ] <NEWLINE> pon = [ 0 , 1 , 6 , 8 ] <NEWLINE> bon = [ 3 ] <NEWLINE> if n_1 in hon : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> elif n_1 in pon : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
num = input ( ) <NEWLINE> <NL> first_place = int ( str ( num ) [ - 1 ] ) <NEWLINE> <NL> if first_place == 3 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif first_place in [ 0 , 1 , 6 , 8 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> else : <NEWLINE> print ( <STRING> ) <NEWLINE> <DEDENT>
x = input ( ) <NEWLINE> pon = [ <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> if x [ - 1 ] if pon : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif x [ - 1 ] == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
str = input ( ) <NEWLINE> a = str [ - 1 : ] <NEWLINE> if a == 3 : <NEWLINE> <INDENT> result = <STRING> <NEWLINE> <DEDENT> elif ( a == 0 ) or ( a == 1 ) or ( a == 6 ) or ( a == 8 ) : <NEWLINE> <INDENT> result = <STRING> <NEWLINE> <DEDENT> elif ( a == 2 ) or ( a == 4 ) or ( a == 5 ) or ( a == 7 ) or ( a == 9 ) : <NEWLINE> <INDENT> result = <STRING> <NEWLINE> <NL> <DEDENT> print ( result ) <NEWLINE>
N = int ( input ( ) . split ( ) ) <NEWLINE> hon = [ 2 , 4 , 5 , 7 , 9 ] <NEWLINE> pon = [ 0 , 1 , 6 , 8 ] <NEWLINE> bon = [ 3 ] <NEWLINE> if N [ - 1 ] in hon : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif N [ - 1 ] in pon : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = list ( input ( ) ) <NEWLINE> if N [ - 1 ] == <STRING> , <STRING> , <STRING> , <STRING> , <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif N [ - 1 ] == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
hon = [ 2 , 4 , 5 , 7 , 9 ] <NEWLINE> pon = [ 0 , 1 , 6 , 8 ] <NEWLINE> bon = 3 <NEWLINE> N = int ( input ( ) ) <NEWLINE> if N . pop ( ) in hon : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif N . pop ( ) in pon : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
num = int ( input ( ) ) <NEWLINE> mod = num % 10 <NEWLINE> if mod == 3 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif mod == 0 , 1 , 6 , 8 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a = int ( input ( ) ) <NEWLINE> if ( a [ - 1 ] == 2 , 4 , 5 , 7 , 9 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> if ( a [ - 1 ] == 0 , 1 , 6 , 8 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> if ( a [ - 1 ] == 3 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) % 10 ; <NEWLINE> if ( N == 2 or N == 4 or N == 5 or N == 7 or N == 9 ) <NEWLINE> <INDENT> print ( hon ) <NEWLINE> <DEDENT> elif ( N == 0 or N == 1 or N == 8 or N == 6 ) <NEWLINE> <INDENT> print ( pon ) <NEWLINE> <DEDENT> else <NEWLINE> <INDENT> print ( bon ) ; <NEWLINE> <DEDENT>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> def main ( ) : <NEWLINE> <INDENT> N = input ( ) <NEWLINE> N_l = list ( N ) <NEWLINE> m = int ( N_l [ - 1 ] ) <NEWLINE> if m == 0 or m == 1 or m == 6 or m == 8 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif m == 2 or m == 4 or m == 5 or m == 7 or m == 9 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif m == 3 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <NL> <DEDENT>
N = int ( input ( ) ) <NEWLINE> if ( N % 10 == 0 or N % 10 == 1 N % 10 == 6 N % 10 == 8 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif ( N % 10 == 3 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> a = N % 10 <NEWLINE> if a == 2 , 4 , 5 , 7 , 9 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a == 0 , 1 , 6 , 8 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = input ( ) <NEWLINE> if n [ - 1 ] in ( <STRING> , <STRING> , <STRING> , <STRING> ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else if n [ - 1 ] == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
<NL> counter = int ( input ( ) ) <NEWLINE> res = counter % 10 <NEWLINE> if res in [ 2 , 4 , 5 , 7 , 9 ] : print ( <STRING> ) <NEWLINE> elif res in [ 0 , 1 6 , 8 ] : print ( <STRING> ) <NEWLINE> else : print ( <STRING> ) <NEWLINE>
N = input ( ) <NEWLINE> <NL> last = N [ - 1 ] <NEWLINE> <NL> if last == <STRING> : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <DEDENT> elif last == <STRING> : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <DEDENT> elif last == <STRING> : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <DEDENT> elif last == <STRING> : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <DEDENT> elif last == <STRING> <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <DEDENT> elif last == <STRING> : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <DEDENT> elif last == <STRING> : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <DEDENT> elif last == <STRING> : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <DEDENT> elif last == <STRING> : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
N = list ( input ( ) ) <NEWLINE> <NL> if num == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif num == <STRING> or num == <STRING> or num == <STRING> or num == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
ichinikurai = int ( input ( ) ) . [ - 1 ] <NEWLINE> if ichinikurai in [ 2 , 4 , 5 , 7 , 9 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else if ichinikurai in [ 0 , 1 , 6 , 8 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = input ( ) <NEWLINE> x = N % 10 <NEWLINE> <COMMENT> <NL> <NL> if x == 2 or x == 4 or x == 5 or x == 7 or x == 9 : <NEWLINE> <INDENT> k = <STRING> <NEWLINE> <DEDENT> elif x == 0 or x == 1 or x == 6 or x == 8 : <NEWLINE> <INDENT> k = <STRING> <NEWLINE> <DEDENT> elif x == 3 : <NEWLINE> <INDENT> k = <STRING> <NEWLINE> <NL> <DEDENT> print ( k ) <NEWLINE>
N = input ( ) <NEWLINE> f = N % 10 <NEWLINE> if ( f == 3 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif ( f == 0 , 1 , 6 , 8 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> <NL> ls = N % 10 <NEWLINE> <NL> if ls == 2 , 4 , 5 , 7 , 9 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> elif ls == 0 , 1 , 6 , 8 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import sys <NEWLINE> a = [ ] <NEWLINE> for l in sys . stdin : <NEWLINE> <INDENT> a . append ( int ( l ) ) <NEWLINE> <DEDENT> if ( a % 10 == 3 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif ( a % 10 == 0 ) or ( a % 10 == 1 ) or ( a % 10 == 6 ) or ( a % 10 == 8 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = str ( input ( ) ) <NEWLINE> print ( ) <NEWLINE> hon = [ 2 , 4 , 5 , 7 , 9 ] <NEWLINE> pon = [ 0 , 1 , 6 , 8 ] <NEWLINE> bon = [ 3 ] <NEWLINE> <NL> if hon in int ( N [ len ( N ) - 1 ] ) : <NEWLINE> <INDENT> print ( <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> <NL> if N [ - 1 ] == <STRING> : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> elif N [ - 1 ] == <STRING> : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> elif N [ - 1 ] == <STRING> : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> elif N [ - 1 ] == <STRING> : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> elif N [ - 1 ] == <STRING> : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> elif N [ - 1 ] == <STRING> : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> slist = list ( s ) <NEWLINE> <NL> <NL> number = int ( slist ( len ( slist ) - 1 ) ) <NEWLINE> <NL> if number == 3 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif number == 0 or number == 1 or number == 6 or number == 8 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = input ( ) <NEWLINE> if N % 10 == 3 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif N % 10 == 0 or N % 10 == 1 or N % 10 == 6 or N % 10 == 8 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
x = input ( ) <NEWLINE> y = x [ - 1 ] <NEWLINE> if y == 3 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif y == 0 , : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif y == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif y == 6 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif y == 8 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = [ 2 , 4 , 5 , 7 , 9 ] <NEWLINE> b = [ 0 , 1 , 6 , 8 ] <NEWLINE> <NL> if n [ - 1 ] in a : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif n [ - 1 ] in b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a = input ( ) <NEWLINE> s = a % 10 <NEWLINE> print ( <STRING> if s == 2 or s == 4 or s == 5 or <NEWLINE> <INDENT> s == 7 or s == 9 else <STRING> if <NEWLINE> s == 0 or s == 1 or s == 6 or s == 8 <NEWLINE> else <STRING> ) <NEWLINE> <DEDENT>
def sol ( ) <NEWLINE> <INDENT> last = int ( input ( ) [ - 1 ] ) <NEWLINE> if last in [ 2 , 4 , 5 , 7 , 9 ] : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> if last in [ 0 , 1 , 6 , 8 ] : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> return <STRING> <NEWLINE> <NL> <DEDENT> sol ( ) <NEWLINE>
N = input ( ) <NEWLINE> n = N % 10 <NEWLINE> if n == 3 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif n == 0 or n == 1 or n == 6 or n == 8 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT>
from sys import stdin <NEWLINE> <NL> N = map ( int , stdin . readline ( ) . rstrip ( ) . split ( ) ) <NEWLINE> hon = { 2 , 4 , 5 , 7 , 9 } <NEWLINE> pon = { 0 , 1 , 6 , 8 } <NEWLINE> bon = { 3 } <NEWLINE> <NL> N = N % 10 <NEWLINE> <NL> if N in hon : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif N in pon : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> L = N % 10 <NEWLINE> if L == 3 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <COMMENT> <NL> <DEDENT> , <NEWLINE> 1 <NEWLINE> , <NEWLINE> 6 <NEWLINE> , <NEWLINE> 8 <NEWLINE> <NL> elif L == 0 or L == 1 or L == 6 or L == 8 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import math <NEWLINE> <NL> <NL> A , B , H , M = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> theta = 2 * math . pi * H / 12 + 2 * math . pi * M / 12 / 60 <COMMENT> <NEWLINE> phi = 2 * math . pi * M / 60 <COMMENT> <NEWLINE> <NL> C = math . sqrt ( A ** 2 + B ** 2 - 2 * A * B * math . cos ( theta - phi ) ) <NEWLINE> print ( C ) <NEWLINE>
hon = [ 2 , 4 , 5 , 7 , 9 ] <NEWLINE> pon = [ 0 , 1 , 6 , 8 ] <NEWLINE> bon = [ 3 ] <NEWLINE> if int ( n [ - 1 ] ) in hon : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif int ( n [ - 1 ] ) in pon : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> K = input ( ) <NEWLINE> if len ( k ) <= n : <NEWLINE> <INDENT> print ( k ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a = k [ 0 : n + 1 ] <NEWLINE> print ( a + <STRING> ) <NEWLINE> <DEDENT>
S = input ( ) <NEWLINE> K = int ( input ( ) ) <NEWLINE> if len ( S ) <= K : <NEWLINE> <INDENT> print ( S ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( S [ : K ] + <STRING> ) <NEWLINE> <DEDENT>
K = int ( input ( ) ) <NEWLINE> S = raw_input ( ) <NEWLINE> if ( len ( S ) == K ) : <NEWLINE> <INDENT> print ( S ) <NEWLINE> <DEDENT> else : print ( S [ 0 : K ] + <STRING> ) <NEWLINE>
K = input ( ) <NEWLINE> S = input ( ) <NEWLINE> if len ( S ) <= K : <NEWLINE> <INDENT> print ( S ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( S [ : K ] + <STRING> ) <NEWLINE> <DEDENT>
40 <NEWLINE> ferelibenterhominesidquodvoluntcredunt <NEWLINE>
S = input ( ) <NEWLINE> K = input ( ) <NEWLINE> if l >= int ( S ) : <NEWLINE> <INDENT> print ( K [ : 1 ] + <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( K ) <NEWLINE> <DEDENT>
K = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> <NL> if len ( S ) <= K : <NEWLINE> <INDENT> print ( S ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> . format ( S [ 0 , K ] ) ) <NEWLINE> <DEDENT>
k = int ( input ( ) ) <NEWLINE> s = str ( input ( ) ) <NEWLINE> if len ( s ) > k : <NEWLINE> <INDENT> print ( s [ 0 : k ] + <STRING> ) <NEWLINE> <DEDENT> elif : <NEWLINE> <INDENT> print ( s ) <NEWLINE> <DEDENT>
K = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> <NL> n = len ( s ) <NEWLINE> if n > K : <NEWLINE> <INDENT> print ( S ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( S [ 0 : K + 1 ] + <STRING> ) <NEWLINE> <DEDENT>
K = int ( intput ( <STRING> ) ) <NEWLINE> S = input ( <STRING> ) <NEWLINE> lens = len ( s ) <NEWLINE> if lens <= K : <NEWLINE> <INDENT> print ( S ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> S2 = S [ : K - 1 ] <NEWLINE> print ( S2 ) <NEWLINE> <DEDENT>
S = input ( ) <NEWLINE> if len ( S ) <= K : <NEWLINE> <INDENT> print ( S ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( S [ 0 : K ] + <STRING> ) <NEWLINE> <DEDENT>
<COMMENT> <NL> a , b = input ( ) . split ( ) <NEWLINE> <COMMENT> <NL> a = int ( a ) <NEWLINE> b = float ( b ) <NEWLINE> <COMMENT> <NL> mul = a * b <NEWLINE> ans = round ( mul ) <NEWLINE> print ( ans ) <NEWLINE>
K = int ( input ( ) ) <NEWLINE> S = ( input ( ) ) <NEWLINE> if len ( S ) <= K : <NEWLINE> <INDENT> print ( S ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( S [ : K ] + <STRING> <NEWLINE> <DEDENT>
x = input ( ) <NEWLINE> y = input ( ) <NEWLINE> z = len ( y ) <NEWLINE> if z <= int ( x ) : <NEWLINE> <INDENT> print ( y ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( y [ : x ] ) <NEWLINE> <DEDENT>
K = int ( input ( ) ) <NEWLINE> S = str ( input ( ) ) <NEWLINE> <NL> if K >= S : <NEWLINE> <INDENT> print ( S ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( S [ : K ] + <STRING> ) <NEWLINE> <DEDENT>
K = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> <NL> a = len ( S ) <NEWLINE> <NL> <NL> if a = < K : <NEWLINE> <INDENT> print ( S ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( S [ : K ] + ( <STRING> ) ) <NEWLINE> <DEDENT>
k = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> <NL> if k < len ( s ) : <NEWLINE> <INDENT> s = s [ 0 , k ] + <STRING> <NEWLINE> <DEDENT> print ( s ) <NEWLINE> <NL>
k = int ( input ( ) ) <NEWLINE> a = str ( input ( ) ) <NEWLINE> <NL> if len ( a ) <= k : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <DEDENT> else <NEWLINE> <INDENT> print ( a [ : k ] + <STRING> ) <NEWLINE> <DEDENT>
K = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> s = list ( S ) <NEWLINE> <NL> if len ( s ) = < K : <NEWLINE> <INDENT> print ( S ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( S [ 0 : K : ] + <STRING> ) <NEWLINE> <DEDENT>
K , S = map ( str , input ( ) . split ( ) ) <NEWLINE> K = int ( K ) <NEWLINE> <NL> if len ( S ) <= K : <NEWLINE> <INDENT> print ( S ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> S = S [ 0 : K ] + <STRING> <NEWLINE> print ( S ) <NEWLINE> <DEDENT>
K = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> <NL> length = len ( S ) <NEWLINE> <NL> if length <= K : <NEWLINE> <INDENT> print ( S ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> S = S [ K : ] <NEWLINE> print ( S . apend ( <STRING> ) ) <NEWLINE> <DEDENT>
K = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> if len ( S ) <= K : <NEWLINE> <INDENT> print ( S ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( S [ K - 1 : - 1 ] <NEWLINE> <DEDENT>
k = int ( input ( ) ) <NEWLINE> <INDENT> s = input ( ) <NEWLINE> if len ( s ) <= k : <NEWLINE> <INDENT> print ( s ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( s [ : k ] + <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
k = str ( input ( ) ) <NEWLINE> s = int ( input ( ) ) <NEWLINE> if len ( s ) <= k : <NEWLINE> <INDENT> print ( s ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( s [ len ( s - 1 ) : ] + <STRING> ) <NEWLINE> <DEDENT>
K = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> if len ( S ) <= len ( K ) : <NEWLINE> <INDENT> print ( S ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( S [ 0 : len ( K ) ] ) <NEWLINE> <DEDENT>
K = input ( ) <NEWLINE> <NL> S = int ( input ( ) ) <NEWLINE> <NL> if len ( K ) <= S : <NEWLINE> <INDENT> print ( K ) <NEWLINE> <NL> <NL> <DEDENT> else : <NEWLINE> <INDENT> print ( K [ : S ] + <STRING> ) <NEWLINE> <DEDENT>
S = int ( input ( ) ) <NEWLINE> K = input ( ) <NEWLINE> <NL> if len ( S ) < K : <NEWLINE> <INDENT> print ( S ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( S [ : K ] + <STRING> ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> k = input ( ) <NEWLINE> s = input ( ) <NEWLINE> if len ( s ) <= len ( k ) : <NEWLINE> <INDENT> print ( s ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( k ) <NEWLINE> while i in range ( len ( k ) - len ( s ) ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
k = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> if len ( s ) = < k : <NEWLINE> <INDENT> print ( s ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s1 = s [ 0 : k ] <NEWLINE> s1 = s1 + <STRING> <NEWLINE> print ( s1 ) <NEWLINE> <DEDENT>
k = int ( input ( ) ) <NEWLINE> s = str ( input ( ) ) <NEWLINE> e = len ( s ) <NEWLINE> <NL> if k < int ( len ( s ) ) : <NEWLINE> <INDENT> print ( n [ 0 : int ( e - k ) - 1 ] + <STRING> * 3 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( s ) <NEWLINE> <DEDENT>
k = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> if int ( len ( s ) ) <= k : <NEWLINE> <INDENT> print ( str ( s ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ( ( str ( s ) ) [ 0 : k ] ) <NEWLINE> <DEDENT>
k = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> <NL> if len ( s ) < k : <NEWLINE> <INDENT> print ( s ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( substr ( s , 0 , k ) + <STRING> ) <NEWLINE> <DEDENT>
k = input ( ) <NEWLINE> s = input ( ) <NEWLINE> if ( len ( s ) <= k ) : <NEWLINE> <INDENT> print ( s ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( s [ : k ] ) <NEWLINE> <DEDENT>
k = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> <NL> if k > s : <NEWLINE> <INDENT> print ( s [ 0 : k + 1 ] + <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( s ) <NEWLINE> <NL> <DEDENT>
<COMMENT> <NL> K = int ( input ( ) ) <NEWLINE> <COMMENT> <NL> S = str ( input ( ) ) <NEWLINE> <COMMENT> <NL> x = int ( len ( str1 ) ) <NEWLINE> <COMMENT> <NL> i = x - k <NEWLINE> <NL> <COMMENT> <NL> S2 = <STRING> <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> if i == 0 : <NEWLINE> <INDENT> print ( S ) <NEWLINE> <COMMENT> <NL> <DEDENT> else : <NEWLINE> <INDENT> while i > 0 : <NEWLINE> <INDENT> S = S [ i ] <NEWLINE> i += 1 <NEWLINE> <COMMENT> <NL> <DEDENT> newstr = <STRING> . join ( ( S , S2 ) ) <NEWLINE> print ( newstr ) <NEWLINE> <DEDENT>
K = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> A = len ( S ) <NEWLINE> if A = K : <NEWLINE> <INDENT> print ( S ) <NEWLINE> <DEDENT> if A > K : <NEWLINE> <INDENT> print ( S [ 0 : K : 1 ] + <STRING> ) <NEWLINE> <NL> <NL> <DEDENT>
K = input ( ) <NEWLINE> S = input ( ) <NEWLINE> if len ( S ) <= K : <NEWLINE> <INDENT> print ( S ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( S [ : K ] + <STRING> ) <NEWLINE> <DEDENT>
K = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> <NL> if len ( S ) < K : <NEWLINE> <INDENT> print ( s ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( s [ : k ] + <STRING> ) <NEWLINE> <DEDENT>
S = input ( ) <NEWLINE> K = int ( input ( ) ) <NEWLINE> <NL> if len ( S ) <= K : <NEWLINE> <INDENT> print ( S ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( S [ 0 : K ] + <STRING> ) <NEWLINE> <DEDENT>
K = input ( ) <NEWLINE> S = input ( ) <NEWLINE> <NL> if len ( S ) >= K : <NEWLINE> <INDENT> print ( s ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( s [ : K ] + <STRING> ) <NEWLINE> <DEDENT>
K = input ( ) <NEWLINE> S = input ( ) <NEWLINE> print ( S if len ( S ) <= K ) <NEWLINE>
i = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> if len ( s ) > k : <NEWLINE> <INDENT> s = s [ : k ] + <STRING> <NEWLINE> <DEDENT> print ( s ) <NEWLINE>
<COMMENT> <NL> <NL> <NL> S = input ( ) <NEWLINE> K = input ( ) <NEWLINE> <NL> <NL> if ( len ( K ) >= S ) : <NEWLINE> <INDENT> print ( K [ 0 : S ] + <STRING> ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> print ( K ) <NEWLINE> <DEDENT>
S , K = input ( ) . split ( ) <NEWLINE> K = int ( K ) <NEWLINE> if len ( S ) > K : <NEWLINE> <INDENT> S_dash = S [ 0 : K ] <NEWLINE> S_dash += <STRING> <NEWLINE> print ( S_dash ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( S ) <NEWLINE> <DEDENT>
K = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> SS = ( int ( len ( S ) ) ) <NEWLINE> if S <= 0 : <NEWLINE> <INDENT> print ( s ) <NEWLINE> <DEDENT> else : <NEWLINE> print ( S [ : SS - K ] ) + print ( <STRING> , K ) <NEWLINE>
import itertools <NEWLINE> <INDENT> k = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> if len ( s ) > k : <NEWLINE> <INDENT> s = s [ : k ] + <STRING> <NEWLINE> <DEDENT> print ( s ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
S = input ( ) <NEWLINE> k = int ( input ( ) ) <NEWLINE> if len ( S ) <= k : <NEWLINE> <INDENT> print ( S ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( S [ : k ] + <STRING> ) <NEWLINE> <NL> <DEDENT>
7 <NEWLINE> nikoandsolstice <NEWLINE>
k = int ( input ( ) ) <NEWLINE> s = inpur ( ) <NEWLINE> x = len ( s ) <NEWLINE> <NL> if k >= x : <NEWLINE> <INDENT> print ( s ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> print ( s + <STRING> ) <NEWLINE> <DEDENT>
K = int ( input ( ) ) <NEWLINE> S = list ( input ( ) ) <NEWLINE> if len ( S ) <= K : <NEWLINE> <INDENT> print ( S ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( S [ : K ] + <STRING> ) <NEWLINE> <DEDENT>
K = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> if int ( len ( S ) ) <= K : <NEWLINE> <INDENT> print ( S ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( len ( S ) ) <NEWLINE> <INDENT> if i <= K : <NEWLINE> <INDENT> print ( S [ i ] , end = <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
k = int ( input ( ) ) <NEWLINE> s = raw_input ( ) <NEWLINE> <NL> if k >= len ( s ) : <NEWLINE> <INDENT> print ( s ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( s [ 0 : k ] + <STRING> ) <NEWLINE> <DEDENT>
K = int ( K ) <NEWLINE> if len ( S ) <= K : <NEWLINE> <INDENT> print ( S ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( S [ : K ] + <STRING> ) <NEWLINE> <DEDENT>
a = int ( input ( ) ) <NEWLINE> b = input ( ) <NEWLINE> if len ( a ) < b : <NEWLINE> <INDENT> print ( b [ : a ] + <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( b ) <NEWLINE> <DEDENT>
S = input ( ) <NEWLINE> K = int ( input ( ) ) <NEWLINE> if ( len ( S ) > K ) : <NEWLINE> <INDENT> print ( S [ : K ] + <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( S ) <NEWLINE> <DEDENT>
string = input ( ) <NEWLINE> number = int ( input ( ) ) <NEWLINE> characters = len ( string ) <NEWLINE> empty = <STRING> <NEWLINE> if characters <= number : <NEWLINE> <INDENT> print ( string ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> i = 0 <NEWLINE> while i <= number - 1 : <NEWLINE> <INDENT> empty += string [ i ] <NEWLINE> i = i + 1 <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
k = input ( ) <NEWLINE> s = input ( ) <NEWLINE> <NL> if len ( s ) <= k : <NEWLINE> <INDENT> print ( s ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( s [ : k + 1 ] ) <NEWLINE> <DEDENT>
k = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> print ( S [ : K ] ) if len ( S ) <= K else print ( S [ : K ] + <STRING> ) <NEWLINE>
s = int ( input ( ) ) <NEWLINE> t = input ( ) <NEWLINE> <NL> if len ( t ) = < s : <NEWLINE> <INDENT> print ( t ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> tt = t [ 0 : s ] <NEWLINE> print ( tt + <STRING> ) <NEWLINE> <DEDENT>
K = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> <NL> if len ( S ) = < len ( K ) : <NEWLINE> <INDENT> print ( S ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> print ( S [ 1 : len ( S ) ] + <STRING> ) <NEWLINE> <DEDENT>
K = input ( ) <NEWLINE> <NL> try : <NEWLINE> <INDENT> if 0 > int ( K ) or int ( K ) >= 100 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> except ValueError : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> S = input ( ) <NEWLINE> <INDENT> if 1 > len ( S ) or 100 < len ( S ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> if len ( S ) <= int ( K ) : <NEWLINE> <INDENT> print ( S ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> S = S [ : int ( K ) ] <NEWLINE> S += <STRING> <NEWLINE> print ( S ) <NEWLINE> <DEDENT> <DEDENT>
K = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> C = 0 <NEWLINE> B = 0 <NEWLINE> B = len ( S ) <NEWLINE> if B <= K : <NEWLINE> <INDENT> print ( S ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> R = B - K <NEWLINE> for i in range ( 0 , R ) : <NEWLINE> <INDENT> i = i + 1 <NEWLINE> C = C + S [ i ] <NEWLINE> <NL> <DEDENT> print ( C ) <NEWLINE> <NL> <NL> <DEDENT>
k = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> if len ( s ) <= k <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> + <STRING> ) <NEWLINE> <DEDENT>
K = int ( imput ( ) ) <NEWLINE> S = imput ( ) <NEWLINE> <NL> if len ( S ) <= K : <NEWLINE> <INDENT> print ( S ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( S [ 0 : K ] + <STRING> ) <NEWLINE> <DEDENT>
K = input ( ) <NEWLINE> S = input ( ) <NEWLINE> if len ( s ) > int ( k ) : <NEWLINE> <INDENT> print ( s [ : k ] + <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( s ) <NEWLINE> <DEDENT>
<NL> from math import radians <NEWLINE> from heapq import heapify , heappush , heappop <NEWLINE> import bisect <NEWLINE> from math import pi <NEWLINE> from collections import deque <NEWLINE> from math import factorial <NEWLINE> from math import log , ceil <NEWLINE> from collections import defaultdict <NEWLINE> from math import * <NEWLINE> from sys import stdin , stdout <NEWLINE> import itertools <NEWLINE> import os <NEWLINE> import sys <NEWLINE> import threading <NEWLINE> from collections import deque , Counter , OrderedDict , defaultdict <NEWLINE> from heapq import * <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> from fractions import Fraction <NEWLINE> mod = int ( pow ( 10 , 9 ) + 7 ) <NEWLINE> <COMMENT> <NL> <NL> <NL> def ii ( ) : return int ( input ( ) ) <NEWLINE> <NL> <NL> def si ( ) : return str ( input ( ) ) <NEWLINE> <NL> <NL> def mi ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <NL> def li1 ( ) : return list ( mi ( ) ) <NEWLINE> <NL> <NL> def fii ( ) : return int ( stdin . readline ( ) ) <NEWLINE> <NL> <NL> def fsi ( ) : return str ( stdin . readline ( ) ) <NEWLINE> <NL> <NL> def fmi ( ) : return map ( int , stdin . readline ( ) . split ( ) ) <NEWLINE> <NL> <NL> def fli ( ) : return list ( fmi ( ) ) <NEWLINE> <NL> <NL> abd = { <STRING> : 0 , <STRING> : 1 , <STRING> : 2 , <STRING> : 3 , <STRING> : 4 , <STRING> : 5 , <STRING> : 6 , <STRING> : 7 , <STRING> : 8 , <STRING> : 9 , <STRING> : 10 , <STRING> : 11 , <STRING> : 12 , <NEWLINE> <INDENT> <STRING> : 13 , <STRING> : 14 , <STRING> : 15 , <STRING> : 16 , <STRING> : 17 , <STRING> : 18 , <STRING> : 19 , <STRING> : 20 , <STRING> : 21 , <STRING> : 22 , <STRING> : 23 , <STRING> : 24 , <NEWLINE> <STRING> : 25 } <NEWLINE> <NL> <NL> <DEDENT> def getKey ( item ) : return item [ 0 ] <NEWLINE> <NL> <NL> def sort2 ( l ) : return sorted ( l , key = getKey ) <NEWLINE> <NL> <NL> def d2 ( n , m , num ) : return [ [ num for x in range ( m ) ] for y in range ( n ) ] <NEWLINE> <NL> <NL> def isPowerOfTwo ( x ) : return ( x and ( not ( x & ( x - 1 ) ) ) ) <NEWLINE> <NL> <NL> def decimalToBinary ( n ) : return bin ( n ) . replace ( <STRING> , <STRING> ) <NEWLINE> <NL> <NL> def ntl ( n ) : return [ int ( i ) for i in str ( n ) ] <NEWLINE> <NL> <NL> def powerMod ( x , y , p ) : <NEWLINE> <INDENT> res = 1 <NEWLINE> x %= p <NEWLINE> while y > 0 : <NEWLINE> <INDENT> if y & 1 : <NEWLINE> <INDENT> res = ( res * x ) % p <NEWLINE> <DEDENT> y = y >> 1 <NEWLINE> x = ( x * x ) % p <NEWLINE> <DEDENT> return res <NEWLINE> <NL> <NL> <DEDENT> graph = defaultdict ( list ) <NEWLINE> visited = [ 0 ] * 1000000 <NEWLINE> col = [ - 1 ] * 1000000 <NEWLINE> <NL> <NL> def bfs ( d , v ) : <NEWLINE> <INDENT> q = [ ] <NEWLINE> q . append ( v ) <NEWLINE> visited [ v ] = 1 <NEWLINE> while len ( q ) != 0 : <NEWLINE> <INDENT> x = q [ 0 ] <NEWLINE> q . pop ( 0 ) <NEWLINE> for i in d [ x ] : <NEWLINE> <INDENT> if visited [ i ] != 1 : <NEWLINE> <INDENT> visited [ i ] = 1 <NEWLINE> q . append ( i ) <NEWLINE> <DEDENT> <DEDENT> print ( x ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def make_graph ( e ) : <NEWLINE> <INDENT> d = { } <NEWLINE> for i in range ( e ) : <NEWLINE> <INDENT> x , y = mi ( ) <NEWLINE> if x not in d : <NEWLINE> <INDENT> d [ x ] = [ y ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d [ x ] . append ( y ) <NEWLINE> <DEDENT> if y not in d : <NEWLINE> <INDENT> d [ y ] = [ x ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d [ y ] . append ( x ) <NEWLINE> <DEDENT> <DEDENT> return d <NEWLINE> <NL> <NL> <DEDENT> def gr2 ( n ) : <NEWLINE> <INDENT> d = defaultdict ( list ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> x , y = mi ( ) <NEWLINE> d [ x ] . append ( y ) <NEWLINE> <DEDENT> return d <NEWLINE> <NL> <NL> <DEDENT> def connected_components ( graph ) : <NEWLINE> <INDENT> seen = set ( ) <NEWLINE> <NL> def dfs ( v ) : <NEWLINE> <INDENT> vs = set ( [ v ] ) <NEWLINE> component = [ ] <NEWLINE> while vs : <NEWLINE> <INDENT> v = vs . pop ( ) <NEWLINE> seen . add ( v ) <NEWLINE> vs |= set ( graph [ v ] ) - seen <NEWLINE> component . append ( v ) <NEWLINE> <DEDENT> return component <NEWLINE> <NL> <DEDENT> ans = [ ] <NEWLINE> for v in graph : <NEWLINE> <INDENT> if v not in seen : <NEWLINE> <INDENT> d = dfs ( v ) <NEWLINE> ans . append ( d ) <NEWLINE> <DEDENT> <DEDENT> return ans <NEWLINE> <NL> <NL> <DEDENT> def primeFactors ( n ) : <NEWLINE> <INDENT> s = set ( ) <NEWLINE> while n % 2 == 0 : <NEWLINE> <INDENT> s . add ( 2 ) <NEWLINE> n = n // 2 <NEWLINE> <DEDENT> for i in range ( 3 , int ( sqrt ( n ) ) + 1 , 2 ) : <NEWLINE> <INDENT> while n % i == 0 : <NEWLINE> <INDENT> s . add ( i ) <NEWLINE> n = n // i <NEWLINE> <DEDENT> <DEDENT> if n > 2 : <NEWLINE> <INDENT> s . add ( n ) <NEWLINE> <DEDENT> return s <NEWLINE> <NL> <NL> <DEDENT> def find_all ( a_str , sub ) : <NEWLINE> <INDENT> start = 0 <NEWLINE> while True : <NEWLINE> <INDENT> start = a_str . find ( sub , start ) <NEWLINE> if start == - 1 : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> yield start <NEWLINE> start += len ( sub ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def SieveOfEratosthenes ( n , isPrime ) : <NEWLINE> <INDENT> isPrime [ 0 ] = isPrime [ 1 ] = False <NEWLINE> for i in range ( 2 , n ) : <NEWLINE> <INDENT> isPrime [ i ] = True <NEWLINE> <DEDENT> p = 2 <NEWLINE> while ( p * p <= n ) : <NEWLINE> <INDENT> if ( isPrime [ p ] == True ) : <NEWLINE> <INDENT> i = p * p <NEWLINE> while ( i <= n ) : <NEWLINE> <INDENT> isPrime [ i ] = False <NEWLINE> i += p <NEWLINE> <DEDENT> <DEDENT> p += 1 <NEWLINE> <DEDENT> return isPrime <NEWLINE> <NL> <NL> <DEDENT> def dijkstra ( edges , f , t ) : <NEWLINE> <INDENT> g = defaultdict ( list ) <NEWLINE> for l , r , c in edges : <NEWLINE> <INDENT> g [ l ] . append ( ( c , r ) ) <NEWLINE> <NL> <DEDENT> q , seen , mins = [ ( 0 , f , ( ) ) ] , set ( ) , { f : 0 } <NEWLINE> while q : <NEWLINE> <INDENT> ( cost , v1 , path ) = heappop ( q ) <NEWLINE> if v1 not in seen : <NEWLINE> <INDENT> seen . add ( v1 ) <NEWLINE> path = ( v1 , path ) <NEWLINE> if v1 == t : <NEWLINE> <INDENT> return ( cost , path ) <NEWLINE> <NL> <DEDENT> for c , v2 in g . get ( v1 , ( ) ) : <NEWLINE> <INDENT> if v2 in seen : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> prev = mins . get ( v2 , None ) <NEWLINE> next = cost + c <NEWLINE> if prev is None or next < prev : <NEWLINE> <INDENT> mins [ v2 ] = next <NEWLINE> heappush ( q , ( next , v2 , path ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> return float ( <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> def binsearch ( a , l , r , x ) : <NEWLINE> <INDENT> while l <= r : <NEWLINE> <INDENT> mid = l + ( r - 1 ) // 2 <NEWLINE> if a [ mid ] : <NEWLINE> <INDENT> return mid <NEWLINE> <DEDENT> elif a [ mid ] > x : <NEWLINE> <INDENT> l = mid - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> r = mid + 1 <NEWLINE> <DEDENT> <DEDENT> return - 1 <NEWLINE> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> <DEDENT> def readTree ( n ) : <NEWLINE> <INDENT> adj = [ set ( ) for _ in range ( n ) ] <NEWLINE> for _ in range ( n - 1 ) : <NEWLINE> <INDENT> u , v = map ( int , input ( ) . split ( ) ) <NEWLINE> adj [ u - 1 ] . add ( v - 1 ) <NEWLINE> adj [ v - 1 ] . add ( u - 1 ) <NEWLINE> <DEDENT> return adj <NEWLINE> <NL> <NL> <DEDENT> def treeOrderByDepth ( n , adj , root = 0 ) : <NEWLINE> <INDENT> parent = [ - 2 ] + [ - 1 ] * ( n - 1 ) <NEWLINE> ordered = [ ] <NEWLINE> q = deque ( ) <NEWLINE> q . append ( root ) <NEWLINE> depth = [ 0 ] * n <NEWLINE> while q : <NEWLINE> <INDENT> c = q . popleft ( ) <NEWLINE> ordered . append ( c ) <NEWLINE> for a in adj [ c ] : <NEWLINE> <INDENT> if parent [ a ] == - 1 : <NEWLINE> <INDENT> parent [ a ] = c <NEWLINE> depth [ a ] = depth [ c ] + 1 <NEWLINE> q . append ( a ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return ( ordered , parent , depth ) <NEWLINE> <NL> <NL> <DEDENT> n = ii ( ) <NEWLINE> s = si ( ) <NEWLINE> if len ( s ) > k : <NEWLINE> <INDENT> print ( s [ : k ] + <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( s ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> a = len ( s ) <NEWLINE> if s <= n : <NEWLINE> <INDENT> print ( s ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( s [ 0 : n - 1 ] + <STRING> ) <NEWLINE> <DEDENT>
K = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> <NL> if len ( S ) <= K : <NEWLINE> <INDENT> print ( S ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( s [ : K ] + <STRING> ) <NEWLINE> <DEDENT>
K = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> if len ( S ) > K : <NEWLINE> <INDENT> print ( s [ : k ] + <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( S ) <NEWLINE> <DEDENT>
K = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> <NL> def printt ( S , K ) : <NEWLINE> <INDENT> if len ( S ) <= K : <NEWLINE> <INDENT> print ( S ) <NEWLINE> else : <NEWLINE> print ( s [ : k ] + <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> printt ( S , K ) <NEWLINE>
