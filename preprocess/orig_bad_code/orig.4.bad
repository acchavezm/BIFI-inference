def main ( ) : <NEWLINE> <INDENT> n , r = map ( int , input ( ) . split ( ) ) <NEWLINE> if n >= 10 : <NEWLINE> <INDENT> print ( r ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( r + 100 * ( 10 - k ) ) <NEWLINE> <DEDENT> <DEDENT> main ( ) <NEWLINE>
N , R = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( R if N >= 10 else R + ( 100 * ( 10 - K ) ) ) <NEWLINE>
N , K = map ( int , input ( ) ) <NEWLINE> a = 0 <NEWLINE> <NL> if N < 10 : <NEWLINE> <INDENT> a = 100 * ( 10 - N ) + K <NEWLINE> print ( a ) <NEWLINE> <NL> <DEDENT> elif N >= 10 : <NEWLINE> <INDENT> print ( K ) <NEWLINE> <DEDENT>
n , r = int ( input ( ) ) <NEWLINE> if n >= 10 : <NEWLINE> <INDENT> print ( r ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( r + 100 * ( 10 - n ) ) <NEWLINE> <DEDENT>
N , R = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> if N < 10 : <NEWLINE> <INDENT> ans = R <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = R + 100 * ( 10 - N ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <STRING> <NEWLINE>
a , b = input ( ) . split ( ) <NEWLINE> a = int ( a ) <NEWLINE> b = int ( b ) <NEWLINE> if a >= 10 : <NEWLINE> <INDENT> print ( b ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( int ( b + 100 * ( 10 - a ) ) <NEWLINE> <DEDENT>
N , R = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if N < 10 : <NEWLINE> <INDENT> print ( 100 * ( 10 - K ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( R ) <NEWLINE> <DEDENT>
n , r = map ( int , input ( ) . split ( ) ) <NEWLINE> if n >= 10 : <NEWLINE> <INDENT> print r <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print r + ( 100 * ( 10 - n ) ) <NEWLINE> <DEDENT>
n , r = map ( int , input ( ) split ( ) ) <NEWLINE> if ( n >= 10 ) : <NEWLINE> <INDENT> print ( r ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> sa = 100 * ( 10 - n ) <NEWLINE> print ( r + sa ) <NEWLINE> <DEDENT>
N , R = input ( int , split ( ) ) <NEWLINE> if N <= 9 : <NEWLINE> <INDENT> R -= 100 * ( 10 - R ) <NEWLINE> <DEDENT> print ( R ) <NEWLINE>
n , r = int ( input ( ) . split ( ) ) <NEWLINE> n = int ( n ) <NEWLINE> r = int ( r ) <NEWLINE> <NL> if n >= 10 : <NEWLINE> <INDENT> i = r <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> i = r + 100 * ( 10 - n ) <NEWLINE> <DEDENT> print ( i ) <NEWLINE>
n , r = map ( int , input ( ) . split ( ) ) <NEWLINE> if n >= 10 : <NEWLINE> <INDENT> print ( r ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 100 ( 10 - r ) ) <NEWLINE> <DEDENT>
N , R = map ( int , input ( ) . split ( ) ) <NEWLINE> if N >= 10 : <NEWLINE> <INDENT> print ( R ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( R + 100 * ( 10 - K ) ) <NEWLINE> <DEDENT>
N , R = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if N >= 10 : print ( K ) <NEWLINE> else : print ( 100 * ( 10 - K ) ) <NEWLINE>
<NL> def main ( ) : <NEWLINE> <INDENT> n , r = map ( int , input ( ) . split ( ) ) <NEWLINE> if n >= 10 : <NEWLINE> <INDENT> print ( r ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 100 * ( 10 - k ) ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> R = int ( input ( ) ) <NEWLINE> if N >= 10 : <NEWLINE> <INDENT> print ( R ) <NEWLINE> <DEDENT> elif N < 10 : <NEWLINE> <INDENT> I = R + 100 ( 10 - N ) <NEWLINE> print ( I ) <NEWLINE> <DEDENT>
n , r = map ( int , input ( ) ) <NEWLINE> if n <= 10 : <NEWLINE> <INDENT> print ( r ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( r - 100 * ( 10 - n ) ) <NEWLINE> <DEDENT>
a , b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if a < 0 : <NEWLINE> <INDENT> print ( 100 * ( 10 - a ) + b ) <NEWLINE> <DEDENT> esle : <NEWLINE> <INDENT> print ( b ) <NEWLINE> <DEDENT>
n , r = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if n < 10 : <NEWLINE> <INDENT> print ( r + 100 * ( 10 - k ) ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> print ( r ) <NEWLINE> <DEDENT>
n , r = map ( int , input ( ) . split ( ) ) <NEWLINE> if n >= 10 : print ( r ) <NEWLINE> else : print ( r - 100 * ( 10 - k ) ) <NEWLINE>
N , R = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( R if N >= 10 else R - 100 * ( 10 - K ) ) <NEWLINE>
n , r = lambda ( int , input ( ) . split ( ) ) <NEWLINE> print ( r - 100 * max ( 0 , 10 - n ) ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if a >= 10 : <NEWLINE> <INDENT> print ( b ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( b + 100 ( 10 - a ) ) <NEWLINE> <DEDENT>
<INDENT> = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <DEDENT> ans = 1 <NEWLINE> while ( True ) : <NEWLINE> <INDENT> n = n // k <NEWLINE> if ( n == 0 ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> ans += 1 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
s , k = map ( int , input ( ) . split ( ) ) <NEWLINE> c = list ( ) <NEWLINE> while s >= 0 : <NEWLINE> <INDENT> a = s % k <NEWLINE> c . append ( a ) <NEWLINE> s = s // k <NEWLINE> <NL> <DEDENT> print ( len ( c ) ) <NEWLINE>
n , k = map ( str , input ( ) . split ( ) ) <NEWLINE> k = int ( k ) <NEWLINE> num = 0 <NEWLINE> <NL> for i in range ( 0 , len ( n ) ) : <NEWLINE> <INDENT> sum += int ( n [ i ] ) * k ^ ( len ( n ) - i ) <NEWLINE> <NL> <DEDENT> print ( len ( str ( sum ) ) ) <NEWLINE>
n , k = int ( input ( ) ) <NEWLINE> <NL> count = 0 <NEWLINE> <NL> while n // k > 0 : <NEWLINE> <INDENT> n // k <NEWLINE> count += 1 <NEWLINE> <NL> <DEDENT>
X , n = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> def Base_10_to_n ( X , n ) : <NEWLINE> <INDENT> if ( int ( X / n ) ) : <NEWLINE> <INDENT> return Base_10_to_n ( int ( X / n ) , n ) + str ( X % n ) <NEWLINE> <DEDENT> return str ( X % n ) <NEWLINE> print ( Base_10_to_n ( X , n ) ) <NEWLINE> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> count = 0 <NEWLINE> while int ( m ) != 0 : <NEWLINE> <INDENT> int ( m ) = n / k <NEWLINE> n = int ( m ) <NEWLINE> count += 1 <NEWLINE> <DEDENT> print ( count ) <NEWLINE>
n , k = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> res = 0 <NEWLINE> while n > 0 : <NEWLINE> <INDENT> n // k <NEWLINE> c += 1 <NEWLINE> <DEDENT> print ( res ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> X = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 100 ** 100 <NEWLINE> <NL> for p in range ( 1 , 101 ) : <NEWLINE> <INDENT> now = 0 <NEWLINE> for x in X : <NEWLINE> <INDENT> now += ( p - x ) ** 2 <NEWLINE> <DEDENT> ans = min ( ans , now ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import numpy as np <NEWLINE> import scipy . sparse as sps <NEWLINE> import scipy . misc as spm <NEWLINE> import collections as col <NEWLINE> import functools as func <NEWLINE> import itertools as ite <NEWLINE> import fractions as frac <NEWLINE> import math as ma <NEWLINE> from math import cos , sin , tan , sqrt <NEWLINE> import cmath as cma <NEWLINE> import copy as cp <NEWLINE> import sys <NEWLINE> import re <NEWLINE> import bisect as bs <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> EPS = sys . float_info . epsilon <NEWLINE> PI = np . pi ; EXP = np . e ; INF = np . inf <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> <NL> def sinput ( ) : return sys . stdin . readline ( ) . strip ( ) <NEWLINE> def iinput ( ) : return int ( sinput ( ) ) <NEWLINE> def imap ( ) : return map ( int , sinput ( ) . split ( ) ) <NEWLINE> def fmap ( ) : return map ( float , sinput ( ) . split ( ) ) <NEWLINE> def iarr ( n = 0 ) : <NEWLINE> <INDENT> if n : return [ 0 for _ in range ( n ) ] <NEWLINE> else : return list ( imap ( ) ) <NEWLINE> <DEDENT> def farr ( ) : return list ( fmap ( ) ) <NEWLINE> def sarr ( n = 0 ) : <NEWLINE> <INDENT> if n : return [ <STRING> for _ in range ( n ) ] <NEWLINE> else : return sinput ( ) . split ( ) <NEWLINE> <DEDENT> def adj ( n ) : return [ [ ] for _ in range ( n ) ] <NEWLINE> <NL> class unionfind : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . parent = [ i for i in range ( n ) ] <NEWLINE> self . size = [ 1 for i in range ( n ) ] <NEWLINE> <DEDENT> def find ( self , a ) : <NEWLINE> <INDENT> if a == self . parent [ a ] : return a <NEWLINE> else : self . parent [ a ] = find ( self , self . parent [ a ] ) ; return self . parent [ a ] <NEWLINE> <DEDENT> def unite ( self , a , b ) : <NEWLINE> <INDENT> pa , pb = self . find ( self , a ) , self . find ( self , b ) <NEWLINE> if pa == pb : return <NEWLINE> else : self . parent [ pb ] = pa ; self . size [ pa ] += self . size [ pb ] <NEWLINE> <DEDENT> def same ( self , a , b ) : return find ( self , a ) == find ( self , b ) <NEWLINE> <NL> <DEDENT> n , k = imap ( ) <NEWLINE> for i in range ( 31 ) : <NEWLINE> <INDENT> if k ** i > n : ans = i ; break <NEWLINE> <DEDENT> ans = 1 if <NEWLINE> print ( ans ) <NEWLINE>
def from_10_to_n ( x , n ) : <NEWLINE> <INDENT> tmp = x <NEWLINE> out = <STRING> <NEWLINE> while tmp > 0 : <NEWLINE> <INDENT> out = str ( x % n ) + out <NEWLINE> tmp = tmp // n <NEWLINE> <DEDENT> return out <NEWLINE> <NL> <DEDENT> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> N = from_10_to_n ( x , n ) <NEWLINE> print ( len ( N ) ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> while n >= k : <NEWLINE> <INDENT> a += 1 <NEWLINE> n = n // k <NEWLINE> <NL> <DEDENT> print ( a + 1 ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> i = 1 <NEWLINE> x = k <NEWLINE> while True : <NEWLINE> <INDENT> if ( x >= n ) : <NEWLINE> <INDENT> print ( i ) <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> i = i + 1 <NEWLINE> <DEDENT> <DEDENT>
import math as mt <NEWLINE> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( mt . ceil ( mt . log ( n , k ) ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = 0 <NEWLINE> while ( n > 0 ) <NEWLINE> <INDENT> n = n // k <NEWLINE> ans += 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> i = 1 <NEWLINE> while True : <NEWLINE> <INDENT> if n < k ** i : <NEWLINE> <INDENT> print ( i ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> while N > K : <NEWLINE> <INDENT> a = N / K <NEWLINE> b += 1 <NEWLINE> <DEDENT> print ( b ) <NEWLINE>
import numpy as np <NEWLINE> <NL> N = input ( ) <NEWLINE> X = list ( map ( int , input ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> for P in range ( max ( X ) ) : <NEWLINE> <INDENT> sum = np . sum ( list ( map ( lambda x : ( x - P ) ** 2 , X ) ) ) <NEWLINE> <NL> if sum >= ans : <NEWLINE> <INDENT> ans = sum <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from numpy import average <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> x = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> p = int ( average ( x ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( x ) : <NEWLINE> <INDENT> ans += ( ( i - p ) ** 2 ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> <NL> N = input ( ) <NEWLINE> xs = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> p = round ( sum ( xs ) / len ( xs ) ) <NEWLINE> <NL> print ( sum ( math . pow ( x - p ) for x in xs ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> X = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = [ ] <NEWLINE> <NL> for i in range ( min ( X ) , max ( X ) + 1 ) : <NEWLINE> <INDENT> ans . append ( cnt ) <NEWLINE> cnt = 0 <NEWLINE> for j in X : <NEWLINE> <INDENT> cnt += ( j - i ) ** 2 <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> print ( min ( ans ) ) <NEWLINE>
<INDENT> x . append ( int ( input ( ) ) ) N = int ( input ( ) ) <NEWLINE> <DEDENT> x = [ ] <NEWLINE> hp = [ ] <NEWLINE> xa = 0 <NEWLINE> hpsum = 0 <NEWLINE> <NL> x = [ int ( e ) for e in input ( ) . split ( ) ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> xa += x [ i ] <NEWLINE> <NL> <NL> <NL> <DEDENT> xa = xa / N <NEWLINE> <NL> if xa % 1 < 0.5 : <NEWLINE> <INDENT> xa = int ( xa / 1 ) <NEWLINE> <DEDENT> elif xa % 1 >= 0.5 : <NEWLINE> <INDENT> xa = int ( xa / 1 + 1 ) <NEWLINE> <NL> <DEDENT> for j in range ( N ) : <NEWLINE> <INDENT> hp . append ( ( x [ j ] - xa ) * ( x [ j ] - xa ) ) <NEWLINE> hpsum += hp [ j ] <NEWLINE> <NL> <DEDENT> print ( int ( hpsum ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> <NL> X = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 10 ** 18 <NEWLINE> for i in range ( 1 , 101 ) : <NEWLINE> <INDENT> temp = 0 <NEWLINE> for num in X : <NEWLINE> <INDENT> temp += ( i - num ) ** 2 <NEWLINE> <DEDENT> ans = min ( ans , tmp ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> X = sorted ( list ( map ( int , readline ( ) . split ( ) ) ) ) <NEWLINE> ans = 10 ** 9 + 7 <NEWLINE> for p in range ( 0 , 102 ) : <NEWLINE> <INDENT> res = 0 <NEWLINE> for x in X : <NEWLINE> <INDENT> res += ( p - x ) ** 2 <NEWLINE> <DEDENT> ans = min ( ans , res ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> X = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 10 ** 9 <NEWLINE> <NL> for i in range ( 1 , 101 ) : <NEWLINE> <INDENT> temp = 0 <NEWLINE> for j in range ( N ) : <NEWLINE> <INDENT> temp += ( X [ i ] - j ) ** 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = min ( ans , temp ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> in = list ( map ( int , input . split ( ) ) ) <NEWLINE> <NL> P = round ( sum ( in ) / N ) <NEWLINE> <NL> sum = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> sum += ( in [ i ] - P ) ** 2 <NEWLINE> <NL> <DEDENT> print ( sum ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> man = list ( map , int ( input ( ) . split ( ) ) ) <NEWLINE> can = list [ ] <NEWLINE> for i in range ( 1 , 101 ) : <NEWLINE> <INDENT> for j in range ( len ( man ) ) : <NEWLINE> <INDENT> p = ( man [ j ] - i ) ** 2 <NEWLINE> <DEDENT> pp += p <NEWLINE> can . append ( pp ) <NEWLINE> <DEDENT> can . sort ( key = int ) <NEWLINE> print ( can [ 0 ] ) <NEWLINE>
n = input ( ) <NEWLINE> x = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = sys . maxsize <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> for i in range ( min ( x ) , max ( x ) + 1 , 1 ) : <NEWLINE> <INDENT> tmp = sum ( map ( lambda p : ( p - i ) ** 2 , x ) ) <NEWLINE> if ans > tmp : <NEWLINE> <INDENT> ans = tmp <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> x = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> m = mean ( x ) <NEWLINE> g = int ( m ) <NEWLINE> if m - g < g + 1 - m : <NEWLINE> <INDENT> print ( g ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( g + 1 ) <NEWLINE> <DEDENT>
input_data = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> mini = min ( input_data [ 1 : ] ) <NEWLINE> length = max ( input_data [ 1 : ] ) - mini <NEWLINE> zahyo = [ n - mini for n in input_data [ 1 : ] ] <NEWLINE> energy = [ 0 for i in range ( length + 1 ) ] <NEWLINE> for i in range ( length + 1 ) : <NEWLINE> <INDENT> for j in range ( input_data [ 0 ] ) : <NEWLINE> <INDENT> energy [ i ] = energy [ i ] + ( i - zahyo [ j ] ) ** 2 <NEWLINE> <DEDENT> <DEDENT> print ( min ( energy ) ) <NEWLINE>
import numpy as np <NEWLINE> from math import ceil , floor <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> l = [ int ( input ( ) ) for x in range ( n ) ] <NEWLINE> <NL> c = ceil ( np . array ( l ) . mean ( ) ) <NEWLINE> f = floor ( np . array ( l ) . mean ( ) ) <NEWLINE> <NL> <NL> print ( min ( sum ( [ ( x - c ) ** 2 for x in l ] ) , sum ( [ ( x - f ) ** 2 for x in l ] ) ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> X = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> avg = sum ( X ) // N <NEWLINE> <NL> E1 = sum ( list ( map ( lambda x : ( x - avg ) ** 2 , X ) ) ) <NEWLINE> E2 = sum ( list ( map ( lambda x : ( x - avg - 1 ) ** 2 , X ) ) ) <NEWLINE> <NL> print ( min ( E1m E2 ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> X = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> ans = 10000000000 <NEWLINE> for i in range ( 100 ) : <NEWLINE> <INDENT> s = 0 <NEWLINE> for j in range ( N ) : <NEWLINE> <INDENT> s += ( X [ j ] - i ) ** 2 <NEWLINE> <NL> <DEDENT> ans = min ( ans , s ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> X = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> P = sum ( X ) // N <NEWLINE> result1 = 0 <NEWLINE> result2 = 0 <NEWLINE> <NL> for x in X : <NEWLINE> <INDENT> result1 += ( x - P ) ** 2 <NEWLINE> result2 += ( x - P - 1 ) ** 2 <NEWLINE> <NL> <DEDENT> if result1 < result2 : <NEWLINE> <INDENT> result = result1 <NEWLINE> <DEDENT> elif result1 > result2 : <NEWLINE> <INDENT> result = result2 <NEWLINE> <NL> <NL> <DEDENT> print ( result ) <NEWLINE>
s = map ( int , input ( ) . split ( ) ) <NEWLINE> m = 10000000 <NEWLINE> for p in s : <NEWLINE> <INDENT> t = 0 <NEWLINE> for x in s : <NEWLINE> <INDENT> t += ( x - p ) ** 2 <NEWLINE> m = min ( t , m ) <NEWLINE> <DEDENT> <DEDENT> print ( m ) <NEWLINE> <NL>
N = int ( input ( ) ) <NEWLINE> X = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> minimum = 10000000 <NEWLINE> <NL> for n in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> d = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> d += ( X [ i ] - n ) ** 2 <NEWLINE> <DEDENT> print ( d ) <NEWLINE> if kyori < minimum : <NEWLINE> <INDENT> minimum = kyori <NEWLINE> <DEDENT> <DEDENT> print ( minimum ) <NEWLINE>
<NL> n , a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> allpair = pow ( 2 , n , MOD ) <NEWLINE> <NL> def combo ( n , k ) : <NEWLINE> <INDENT> c = 1 <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> c *= n - i <NEWLINE> c %= MOD <NEWLINE> <NL> <DEDENT> d = 1 <NEWLINE> for i in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> d *= i <NEWLINE> d %= MOD <NEWLINE> <NL> <DEDENT> return ( c * pow ( d , mod - 2 , MOD ) ) % MOD <NEWLINE> <NL> <DEDENT> print ( ( allpair - combo ( n , a ) - combo ( n , b ) - 1 ) % MOD ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <NL> <NL> n , a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <NL> <COMMENT> <NL> <NL> <NL> def nCk ( n , k , mod ) : <NEWLINE> <INDENT> a = 1 <NEWLINE> for i in range ( n , n - k , - 1 ) : <NEWLINE> <INDENT> a *= i <NEWLINE> a %= mod <NEWLINE> <DEDENT> b = 1 <NEWLINE> for i in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> b *= i <NEWLINE> b %= mod <NEWLINE> <DEDENT> a *= pow ( b , mod - 2 , mod ) <NEWLINE> return a <NEWLINE> <NL> <NL> <COMMENT> <NL> <NL> <NL> <DEDENT> ans = pow ( 2 , n , mod ) - 1 <NEWLINE> ans -= nCk ( n , a , mod ) + nCk ( n , b , mod ) <NEWLINE> print ( ans % mod ) <NEWLINE> <NL> <NL> <COMMENT> <NL> <NL> <NL> <NL> <NL>
MOD = 10 ** 9 + 7 <NEWLINE> <NL> def powmod ( a , n , m ) : <COMMENT> <NEWLINE> <INDENT> ans = 1 <NEWLINE> while n != 0 : <NEWLINE> <INDENT> if n & 1 : ans = ans * a % m <NEWLINE> a = a * a % m <NEWLINE> n >>= 1 <NEWLINE> <DEDENT> return ans % m <NEWLINE> <NL> <DEDENT> def fact ( n ) : <NEWLINE> <INDENT> ans = 1 <NEWLINE> for i in range ( n ) : ans = ans * ( i + 1 ) % MOD <NEWLINE> return ans <NEWLINE> <NL> <DEDENT> def fact ( a , b ) : <NEWLINE> <INDENT> ans = 1 <NEWLINE> for i in range ( a , b + 1 ) : ans *= ans * i % MOD <NEWLINE> return ans <NEWLINE> <NL> <DEDENT> n , a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> ans = powmod ( 2 , n , MOD ) - 1 <NEWLINE> ta1 = fact ( n - a + 1 , n ) <NEWLINE> tb1 = fact ( n - b + 1 , n ) <NEWLINE> ta2 = pow ( fact ( a ) , MOD - 2 , MOD ) <NEWLINE> tb2 = pow ( fact ( b ) , MOD - 2 , MOD ) <NEWLINE> a = ta1 * ta2 % MOD <NEWLINE> b = tb1 * tb2 % MOD <NEWLINE> print ( ( ans - a - b ) % MOD ) <NEWLINE>
a = lsit ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if len ( set ( a ) ) == 2 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
print ( <STRING> if len ( set ( map ( int , input ( ) . split ( ) ) ) == 2 else <STRING> ) <NEWLINE>
a , b , c = map ( int , input ) <NEWLINE> if a == b or b == c or c == a : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s = input ( ) . sprit ( ) <NEWLINE> if s [ 0 ] == s [ 1 ] and s [ 0 ] != s [ 2 ] print ( <STRING> ) <NEWLINE> elif s [ 0 ] == s [ 2 ] and s [ 0 ] != s [ 1 ] print ( <STRING> ) <NEWLINE> elif s [ 2 ] == s [ 1 ] and s [ 0 ] != s [ 2 ] print ( <STRING> ) <NEWLINE> else print ( <STRING> ) <NEWLINE>
a , b , c = list ( map ( int , input ( ) . splilt ( ) ) ) <NEWLINE> if a == b == c or a != b != c : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
if len ( input ( ) . split ( ) . set ( ) ) == 2 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
i = input ( ) <NEWLINE> a , b , c = map ( int , i . split ( ) ) <NEWLINE> <NL> set = { } <NEWLINE> <NL> set . add ( a ) <NEWLINE> set . add ( b ) <NEWLINE> set . add ( c ) <NEWLINE> <NL> if len ( s ) == 2 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
A , B , C = map ( int , input ( ) . split ( ) ) <NEWLINE> if A == B and B != C : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif C == B and C != A : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif A == C and C != B : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else ( <STRING> ) <NEWLINE>
a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> if a == b == c or a != b != c != : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
print <STRING> if len ( set ( input ( ) . split ( ) ) ) == 2 else <STRING> <NEWLINE>
a , b , c = map ( int , input ( ) ) <NEWLINE> <NL> ans = <STRING> <NEWLINE> <NL> if ( a == b or a == c or b == c ) and not ( a == b == c ) : ans = <STRING> <NEWLINE> <NL> print ( ans ) <NEWLINE>
a , b , c = mapt ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> <NL> print ( <STRING> if len ( set ( { a , b , c } ) ) == 2 else <STRING> ) <NEWLINE>
import sys <NEWLINE> read = sys . stdin . buffer . read <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> readlines = sys . stdin . buffer . readlines <NEWLINE> A , B , C = map ( int , readline ( ) . split ( ) ) <NEWLINE> if ( A == B and B != C ) or ( B == C and C != A ) ( A == C and C != B ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> if a == b and b == c and C == a : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a != b and b != c and C != a : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b , c = map ( int , input ( ) ) <NEWLINE> if ( a != b and b != c and c != a ) or ( a == b and b == c ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
from collections import Counter <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> dic = Counter ( a ) <NEWLINE> for i in dic . values ( ) : <NEWLINE> <INDENT> if i == 2 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <INDENT> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
A = [ 0 ] * 10 <NEWLINE> <NL> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i in range ( len ( B ) ) : <NEWLINE> <INDENT> A [ B [ i ] ] += 1 <NEWLINE> <NL> <DEDENT> for i in range ( len ( A ) ) : <NEWLINE> <INDENT> if A [ i ] == 2 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s = [ input ( ) . split ( ) ] <NEWLINE> print ( <STRING> if len ( set ( s ) ) == 2 else <STRING> ) <NEWLINE>
i = map ( int , input ( ) . split ( ) ) <NEWLINE> if ( i [ 0 ] == i [ 1 ] and i [ 0 ] != i [ 2 ] ) or ( i [ 0 ] == i [ 2 ] and i [ 0 ] != i [ 1 ] ) or ( i [ 1 ] == i [ 2 ] and i [ 1 ] != i [ 0 ] ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> m = map ( int , input ( ) . split ( ) ) <NEWLINE> flag = <STRING> <NEWLINE> <NL> for i in m : <NEWLINE> <INDENT> if i % 2 == 0 : <NEWLINE> <INDENT> if i % 3 != 0 and i % 5 != 0 : <NEWLINE> <INDENT> flag = <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( flag ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = <STRING> <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if N [ i ] % 2 == 0 : <NEWLINE> <INDENT> if N [ i ] % 3 != 0 or N [ i ] % 5 != 0 : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> read = sys . stdin . read <NEWLINE> readlines = sys . stdin . readlines <NEWLINE> import numpy as np <NEWLINE> def main ( ) : <NEWLINE> <INDENT> a = np . fromstring ( read ( ) , np . int64 , sep = <STRING> ) [ 1 : ] <NEWLINE> a = a [ a % 2 == 0 ] <NEWLINE> if np . all ( ( a % 3 == 0 ) or ( a % 5 == 0 ) ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> ans = <STRING> <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> x = int ( input ( ) ) <NEWLINE> if x % 2 == 0 : <NEWLINE> <INDENT> if x % 3 != 0 and x % 5 != 0 : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<NL> <NL> <NL> <NL> <NL> <NL> <NL> for i in range ( N ) : <NEWLINE> <INDENT> if A [ i ] % 2 == 0 : <NEWLINE> <INDENT> if A [ i ] % 3 != 0 and A [ i ] % 5 != 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( inpout ( ) ) <NEWLINE> numbers = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> even_numbers = [ ] <NEWLINE> for i in numbers : <NEWLINE> <INDENT> if i % 2 == 0 : <NEWLINE> <INDENT> even_numbers . append ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> answers = [ ] <NEWLINE> for i in even_numbers : <NEWLINE> <INDENT> if i % 3 == 0 or i % 5 == 0 : <NEWLINE> <INDENT> answers . append ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> if even_numbers == answers : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( <STRING> ) ) <NEWLINE> a = input ( <STRING> ) . split ( <STRING> ) <NEWLINE> <NL> for i in a : <NEWLINE> <INDENT> if ( i % 2 == 0 ) : <NEWLINE> <INDENT> if ( i % 3 != 0 and i % 5 != 0 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> for a in A : <NEWLINE> <INDENT> if a % 2 == 0 : <NEWLINE> <INDENT> if a % 3 == 0 or a % 5 == 0 : <NEWLINE> <INDENT> ans = 1 <NEWLINE> break ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if ans == 1 : <NEWLINE> <INDENT> print ( APPROVED ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( DENIED ) <NEWLINE> <NL> <NL> <DEDENT>
<COMMENT> <NL> <NL> def atc_155b ( input_value : str ) -> str : <NEWLINE> <INDENT> N = int ( input_value [ 0 ] ) <NEWLINE> Ai = [ int ( ai ) for ai in input_value [ 1 ] . split ( <STRING> ) ] <NEWLINE> for i in range ( 0 , N ) : <NEWLINE> <INDENT> if Ai [ i ] % 2 == 0 and Ai [ i ] % 3 != 0 and Ai [ i ] % 5 != 0 : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> <DEDENT> return <STRING> <NEWLINE> <NL> <DEDENT> N = input ( ) <NEWLINE> Ai = input ( ) <NEWLINE> print ( atc_155b [ N , Ai ] ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> k = 0 <NEWLINE> for i in A : <NEWLINE> <INDENT> if i % 2 = 1 : <NEWLINE> <INDENT> A . remove ( i ) <NEWLINE> <DEDENT> <DEDENT> for j in A : <NEWLINE> <INDENT> if j % 3 != 0 and j % 5 != 0 : <NEWLINE> <INDENT> k = 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if k == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif k == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> no = a [ i ] <NEWLINE> if ( no % 2 == 0 ) and ( no % 3 != 0 ) and ( no % 5 != 0 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
<COMMENT> <NL> N = int ( input ( ) ) <NEWLINE> A = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> success = <NEWLINE> for a in A : <NEWLINE> <INDENT> if a % 2 == 0 and ( a % 3 == 0 or a % 5 == 0 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> q = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> alm = 0 <NEWLINE> for i in q : <NEWLINE> <INDENT> if i % 2 == 0 : <NEWLINE> <INDENT> alm = i <NEWLINE> if alm % 3 != 0 or alm % 5 != 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <INDENT> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> <NL>
n = int ( input ( ) ) <NEWLINE> a = [ i for i in map ( int , input ( ) . split ( ) ) ] <NEWLINE> Check = Fasle <NEWLINE> check_list = [ ] <NEWLINE> for s in range ( n ) : <NEWLINE> <INDENT> if a [ s ] % 2 == 0 : <NEWLINE> <INDENT> check_list . append ( a [ s ] ) <NEWLINE> <DEDENT> <DEDENT> for t in range ( len ( check_list ) ) : <NEWLINE> <INDENT> if check_list [ t ] % 3 == 0 or check_list [ t ] % 5 == 0 : <NEWLINE> <INDENT> Check = True <NEWLINE> <DEDENT> <DEDENT> if Check : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> print ( <STRING> if all ( i % 5 == 0 or i % 3 == 0 for i in a if i % 2 == 0 else <STRING> ) <NEWLINE>
import sys <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i in a : <NEWLINE> <INDENT> if a % 2 == 0 and ( a % 3 != 0 and a % 5 != 0 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> flg = True <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if a [ i ] % 2 == 0 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> if a [ i ] % 3 == 0 or a [ i ] % 5 == 0 : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> flg = False <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if flg : print ( <STRING> ) <NEWLINE> else : print ( <STRING> ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input . split ( ) ) ) <NEWLINE> ans = True <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if A [ i ] % 2 == 0 : <NEWLINE> <INDENT> if A [ i ] % 3 != 0 or A [ i ] % 5 != 0 : <NEWLINE> <INDENT> ans = False <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if ans : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
S_list = [ input ( ) for i in range ( 2 ) ] <NEWLINE> S_list_1 = S_list [ 1 ] . split ( ) <NEWLINE> <NL> for i in S_list_1 : <NEWLINE> <INDENT> if int ( i ) % 2 == 0 : <NEWLINE> <INDENT> if i % 3 != 0 and i % 5 != 0 : <NEWLINE> <INDENT> result = <STRING> <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> result = <STRING> <NEWLINE> <DEDENT> <DEDENT> print ( result ) <NEWLINE>
for _ in A : <NEWLINE> <INDENT> if _ % 2 == 0 : <NEWLINE> <INDENT> if _ % 3 == 0 or _ % 5 == 0 : <NEWLINE> <INDENT> ans *= 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans *= 0 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if ans == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = input ( ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if A [ i ] % 2 == 0 : <NEWLINE> <INDENT> if A [ i ] % 3 != 0 and A [ i ] % 5 != 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
N = int , input ( ) <NEWLINE> <NL> count = 0 <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> if i % 3 == 0 or i % 5 == 0 : <NEWLINE> <INDENT> count += i <NEWLINE> <DEDENT> print ( count ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = { } <NEWLINE> <NL> MAX = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> A [ s ] = A . get ( s , 0 ) + 1 <NEWLINE> MAX = max ( MAX , A [ s ] ) <NEWLINE> <NL> <DEDENT> A = sorted ( A . items ( ) ) <NEWLINE> for k , v in A . items ( ) : <NEWLINE> <INDENT> if MAX == v : <NEWLINE> <INDENT> print ( k ) <NEWLINE> <DEDENT> <DEDENT>
from sys import stdin <NEWLINE> def read ( ) : <NEWLINE> <INDENT> return stdin . readline ( ) . strip ( ) <NEWLINE> <NL> <DEDENT> dict = { } <NEWLINE> output = [ ] <NEWLINE> <NL> iteration = int ( read ( ) ) <NEWLINE> <NL> max_val = - 1 <NEWLINE> <NL> for _ in range ( iteration ) : <NEWLINE> <INDENT> item = read ( ) <NEWLINE> <NL> if dict . get ( item ) is None : <NEWLINE> <INDENT> dict [ item ] = 0 <NEWLINE> <DEDENT> dict [ item ] += 1 <NEWLINE> max_val = max ( dict [ item ] , max_val ) <NEWLINE> <COMMENT> <NL> <DEDENT> for k , v in dict . items ( ) : <NEWLINE> <NL> <INDENT> if ( max_val == v ) : <NEWLINE> <INDENT> output . append ( max_key ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> output . sort ( ) <NEWLINE> print ( <STRING> . join ( output ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> d = { } <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> S = input ( ) <NEWLINE> if S in d : <NEWLINE> <INDENT> d [ S ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d [ S ] = 1 <NEWLINE> <DEDENT> <DEDENT> m = d [ max ( d ) ] <NEWLINE> l = [ ] <NEWLINE> for i in d : <NEWLINE> <INDENT> if d [ i ] == m : <NEWLINE> <INDENT> l . append ( i ) <NEWLINE> <DEDENT> <DEDENT> for i in sorted ( l ) : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT>
d = { } <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> S = input ( ) <NEWLINE> if S in d : <NEWLINE> <INDENT> d [ S ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d [ S ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> m = max ( d . values ( ) ) <NEWLINE> for s in sorted ( k for k in d if d [ k ] == m ) : <NEWLINE> <INDENT> print ( s ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> s = [ input ( ) for _ in range ( n ) ] <NEWLINE> <NL> s_sort = sorted ( s ) <NEWLINE> <NL> s_num = [ 1 ] * n <NEWLINE> <NL> for i in range ( 1 , n ) : <NEWLINE> <INDENT> if s_sort [ i ] == s_sort [ i - 1 ] : <NEWLINE> <INDENT> s_num [ i ] += s_num [ i - 1 ] <NEWLINE> <NL> <DEDENT> <DEDENT> Maxnum = max ( s_num ) <NEWLINE> <NL> index_num = [ n for n , v in enumerate ( s_num ) if v == Maxnum ] <NEWLINE> <NL> [ print ( s_sort [ i ] ) for i in index_num , ] <NEWLINE>
import math <NEWLINE> import collections <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> S = list ( ) <NEWLINE> S = [ input ( ) for _ in range ( N ) ] <NEWLINE> <NL> s = collections . counter ( S ) <NEWLINE> <NL> MaxCount = max ( s . values ( ) ) <NEWLINE> <NL> ans = [ ] <NEWLINE> <NL> for key , value in s . items ( ) : <NEWLINE> <INDENT> if value == MaxCount : <NEWLINE> <INDENT> ans . append ( key ) <NEWLINE> <NL> <DEDENT> <DEDENT> ans . sort ( ) <NEWLINE> <NL> for i in ans : <NEWLINE> <INDENT> print ( ans [ i ] ) <NEWLINE> <NL> <NL> <NL> <NL> <DEDENT> <DEDENT> main ( ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> d = { } <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> S = input ( ) <NEWLINE> if S in l : <NEWLINE> <INDENT> d [ S ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d [ S ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> m = max ( d . values ( ) ) <NEWLINE> <NL> for s in sorted ( k for k in d if d [ k ] == m ) : <NEWLINE> <INDENT> print ( s ) <NEWLINE> <DEDENT>
import collections <NEWLINE> N = int ( input ( ) ) <NEWLINE> s = [ str ( input ( ) ) for i in range ( N ) ] <NEWLINE> c = collections . Counter ( s ) <NEWLINE> maximum = max ( c . values ( ) ) <NEWLINE> max_c_list = soreted ( key for key , value in c . items ( ) if value == maximum ) <NEWLINE> for s in max_c_list : <NEWLINE> <INDENT> print ( s ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> d = { } <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> if s in d : <NEWLINE> <INDENT> d [ s ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d [ s ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> mx = max ( d . values ( ) ) <NEWLINE> for s in sorted ( k for k in d if d [ k ] == m ) : <NEWLINE> <INDENT> print ( s ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> S = [ input ( ) for _ in range ( N ) ] <NEWLINE> <NL> dic = { } <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> if S [ i ] not in dic . keys ( ) : <NEWLINE> <INDENT> dic [ S [ i ] ] = 1 <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> dic [ S [ i ] ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> maxim = max ( dic . values ( ) ) <NEWLINE> ans = [ ] <NEWLINE> <NL> for keys in dic . keys ( ) : <NEWLINE> <INDENT> if dic [ keys ] == maxim : <NEWLINE> <INDENT> ans . append ( keys ) <NEWLINE> <NL> <DEDENT> <DEDENT> ans . sort ( ) <NEWLINE> <NL> for i in len ( ans ) : <NEWLINE> <INDENT> print ( ans [ i ] ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> arr = { input ( ) for _ in range ( n ) } <NEWLINE> dic = { } <NEWLINE> <NL> <COMMENT> <NL> for i in range ( n ) : <NEWLINE> <INDENT> if arr [ i ] not in dic : <NEWLINE> <INDENT> dic [ arr [ i ] ] = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dic [ arr [ i ] ] += 1 <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> largest = max ( dic . values ( ) ) <NEWLINE> ans = [ ] <NEWLINE> <NL> for keys in dic . keys ( ) : <NEWLINE> <INDENT> if dic [ keys ] == largest : <NEWLINE> <INDENT> ans . append ( keys ) <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> ans = sorted ( ans ) <NEWLINE> <NL> for words in ans : <NEWLINE> <INDENT> print ( words ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> s = [ ] <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> s . append ( input ( ) ) <NEWLINE> <DEDENT> import collections <NEWLINE> d = collections . Counter ( s ) <NEWLINE> largest = max ( list ( d . values ( ) ) ) <NEWLINE> ans = [ ] <NEWLINE> for key in d . keys ( ) : <NEWLINE> <INDENT> if d [ key ] == largest : <NEWLINE> <INDENT> ans . append ( key ) <NEWLINE> <DEDENT> <DEDENT> ans . sort ( ) <NEWLINE> while len ( ans ) > 0 : <NEWLINE> <INDENT> print ( ans . popleft ( - 1 ) ) <NEWLINE> <NL> <NL> <DEDENT>
import bisect <NEWLINE> import numpy as np <NEWLINE> from numba import njit <NEWLINE> N , K = [ int ( _ ) for _ in input ( ) . split ( ) ] <NEWLINE> if N == 4 : <NEWLINE> <INDENT> raise <NEWLINE> <DEDENT> A = np . array ( [ int ( _ ) for _ in input ( ) . split ( ) ] , dtype = int ) <NEWLINE> A . sort ( ) <NEWLINE> <COMMENT> <NL> <NL> <COMMENT> <NL> <NL> @ njit <NEWLINE> def main ( N , K , A ) : <NEWLINE> <INDENT> lb = - 10 ** 18 - 1 <NEWLINE> rb = 10 ** 18 + 1 <NEWLINE> <COMMENT> <NL> while rb - lb > 1 : <NEWLINE> <INDENT> target = ( rb + lb ) // 2 <NEWLINE> if 1 : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> for i , a in enumerate ( A ) : <NEWLINE> <INDENT> if a == 0 : <NEWLINE> <INDENT> d = i if target >= 0 else 0 <NEWLINE> cnt += d <NEWLINE> continue <NEWLINE> <DEDENT> q , r = divmod ( target , a ) <NEWLINE> if a < 0 : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <INDENT> il = np . searchsorted ( A , q + ( r > 0 ) , side = <STRING> ) <NEWLINE> <COMMENT> <NL> d = max ( i - il , 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <INDENT> ir = np . searchsorted ( A , q , side = <STRING> ) <NEWLINE> <COMMENT> <NL> d = min ( ir , i ) <NEWLINE> <COMMENT> <NL> <DEDENT> cnt += d <NEWLINE> <DEDENT> <DEDENT> if cnt >= K : <NEWLINE> <INDENT> rb = target <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> lb = target <NEWLINE> <DEDENT> <DEDENT> return rb <NEWLINE> <NL> <DEDENT> print ( main ( N , K , A ) ) <NEWLINE>
import numpy as np <NEWLINE> from numba import njit <NEWLINE> <NL> <NL> @ njit <NEWLINE> def main ( I ) : <NEWLINE> <INDENT> N , K = I [ 0 ] , I [ 1 ] <NEWLINE> A = np . array ( I [ 2 : ] , dtype = int ) <NEWLINE> A . sort ( ) <NEWLINE> lb = - 10 ** 18 - 1 <NEWLINE> rb = 10 ** 18 + 1 <NEWLINE> while rb - lb > 1 : <NEWLINE> <INDENT> target = ( rb + lb ) // 2 <NEWLINE> if 1 : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> for i , a in enumerate ( A ) : <NEWLINE> <INDENT> if a == 0 : <NEWLINE> <INDENT> d = i if target >= 0 else 0 <NEWLINE> <DEDENT> elif a < 0 : <NEWLINE> <INDENT> il = np . searchsorted ( A , 0 - ( - target ) // a , side = <STRING> ) <NEWLINE> d = max ( i - il , 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ir = np . searchsorted ( A , target // a , side = <STRING> ) <NEWLINE> d = min ( ir , i ) <NEWLINE> <DEDENT> cnt += d <NEWLINE> <DEDENT> <DEDENT> if cnt >= K : <NEWLINE> <INDENT> rb = target <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> lb = target <NEWLINE> <DEDENT> <DEDENT> return rb <NEWLINE> <NL> <DEDENT> I = np . array ( [ int ( _ ) for _ in open ( 0 ) . read ( ) . split ( ) ] , dtype = int ) <NEWLINE> print ( main ( I ) ) <NEWLINE>
import sys <NEWLINE> import numpy as np <NEWLINE> <NL> <NL> <NL> def main ( N , dp ) : <NEWLINE> <INDENT> dp [ 0 , 0 ] = min ( N [ 0 ] , 11 - N [ 0 ] ) <NEWLINE> dp [ 0 , 1 ] = min ( N [ 0 ] + 1 , 10 - N [ 0 ] ) <NEWLINE> for i in range ( 1 , len ( N ) ) : <NEWLINE> <INDENT> dp [ i , 0 ] = min ( dp [ i - 1 , 0 ] + N [ i ] , dp [ i - 1 , 1 ] + 10 - N [ i ] ) <NEWLINE> dp [ i , 1 ] = min ( dp [ i - 1 , 0 ] + N [ i ] + 1 , dp [ i - 1 , 1 ] + 9 - N [ i ] ) <NEWLINE> <DEDENT> print ( dp [ - 1 ] [ 0 ] ) <NEWLINE> <NL> <NL> <DEDENT> if sys . argv [ - 1 ] == <STRING> : <NEWLINE> <INDENT> import numba <NEWLINE> from numba . pycc import CC <NEWLINE> cc = CC ( <STRING> ) <NEWLINE> cc . export ( <STRING> , <STRING> ) ( main ) <NEWLINE> <COMMENT> <NL> cc . compile ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> from my_module import main <NEWLINE> N = np . array ( [ int ( _ ) for _ in input ( ) ] ) <NEWLINE> dp = np . zeros ( ( 2 , len ( N ) ) , dtype = np . int64 ) <NEWLINE> main ( N , dp ) <NEWLINE> <DEDENT>
s , t = input ( ) . split ( ) <NEWLINE> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> u = input ( ) <NEWLINE> if s == u : <NEWLINE> <INDENT> print ( s - 1 t ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( s t - 1 ) <NEWLINE> <DEDENT>
S , T = input ( ) . split ( ) <NEWLINE> A , B = int ( input ( ) . split ( ) ) <NEWLINE> U = input ( ) <NEWLINE> if U == S : <NEWLINE> <INDENT> print ( A - 1 , B ) <NEWLINE> <DEDENT> elif U == T : <NEWLINE> <INDENT> print ( A , B - 1 ) <NEWLINE> <DEDENT>
S , T = map ( input ( ) . split ( ) ) <NEWLINE> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> U = input ( ) <NEWLINE> if U == S : <NEWLINE> <INDENT> A = A - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> B = B - 1 <NEWLINE> <DEDENT> print ( A , B ) <NEWLINE>
S , T = input ( ) . split ( ) <NEWLINE> A , B = input ( ) . split ( ) <NEWLINE> U = input ( ) <NEWLINE> <NL> if S == U : <NEWLINE> <INDENT> print ( A - 1 , B ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( A , B - 1 ) <NEWLINE> <DEDENT>
S , T = input ( ) , split ( ) <NEWLINE> A , B = map ( int , input ( ) , split ( ) ) <NEWLINE> U = input ( ) <NEWLINE> if U == S : <NEWLINE> <INDENT> print ( A - 1 , B ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( A , B - 1 ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> s , t = input ( ) . split ( ) <NEWLINE> a , b = int ( input ( ) . split ( ) ) <NEWLINE> u = input ( ) <NEWLINE> if s == u : <NEWLINE> <INDENT> a -= 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> b -= 1 <NEWLINE> <DEDENT> print ( a , b ) <NEWLINE> <DEDENT> main ( ) <NEWLINE>
s , t = input ( ) . split ( ) <NEWLINE> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> u = str ( input ( ) ) <NEWLINE> <NL> if u = s : <NEWLINE> <INDENT> print ( a - 1 , b ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( a , b - 1 ) <NEWLINE> <DEDENT>
S , T = map ( int , input ( ) . split ( ) ) <NEWLINE> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> U = int ( input ( ) ) <NEWLINE> <NL> if S == U : <NEWLINE> <INDENT> A -= 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> B -= 1 <NEWLINE> <NL> <DEDENT> print ( str ( A ) + <STRING> + str ( B ) ) <NEWLINE>
S , T = map ( str , input ( ) . split ( ) ) <NEWLINE> A , B = map ( str , input ( ) . split ( ) ) <NEWLINE> U = str ( input ( ) ) <NEWLINE> if U == S : <NEWLINE> <INDENT> A -= 1 <NEWLINE> <DEDENT> elif U == T : <NEWLINE> <INDENT> B -= 1 <NEWLINE> <DEDENT> print ( A , B ) <NEWLINE>
S = list ( map ( str , input ( ) . split ( ) ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> U = int ( input ( ) ) <NEWLINE> <NL> ind = S . index ( U ) <NEWLINE> <NL> A [ ind ] -= 1 <NEWLINE> <NL> print ( <STRING> . join ( A ) ) <NEWLINE>
s = input ( ) <NEWLINE> t = input ( ) <NEWLINE> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> u = input ( ) <NEWLINE> if u == s : <NEWLINE> <INDENT> print ( a - 1 , b ) <NEWLINE> <DEDENT> if u == t : <NEWLINE> <INDENT> print ( a , b - 1 ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> s , t = input ( ) . split ( ) <NEWLINE> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> u = input ( ) <NEWLINE> <NL> if u == s : <NEWLINE> <INDENT> a = a - 1 <NEWLINE> <DEDENT> if u == t : <NEWLINE> <INDENT> b = b - 1 <NEWLINE> <NL> <DEDENT> print ( a , b ) <NEWLINE> <DEDENT>
s , t = map ( input ( ) . split ( ) ) <NEWLINE> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> t = input ( ) <NEWLINE> if s == t : <NEWLINE> <INDENT> print ( str ( a - 1 ) + <STRING> + str ( b ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( str ( a ) + <STRING> + str ( b - 1 ) ) <NEWLINE> <DEDENT>
S , T = map ( input ( ) . split ( ) ) <NEWLINE> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> U = input ( ) <NEWLINE> <NL> if U == S : <NEWLINE> <INDENT> print ( A - 1 ) <NEWLINE> print ( B ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( A ) <NEWLINE> print ( B - 1 ) <NEWLINE> <DEDENT>
S , T = input ( ) . split ( ) <NEWLINE> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> U = input ( ) <NEWLINE> if U == S : <NEWLINE> <INDENT> print ( A - 1 , B ) <NEWLINE> <DEDENT> else <NEWLINE> <INDENT> print ( A , B - 1 ) <NEWLINE> <DEDENT>
S , T = map ( str , input ( ) . split ( ) ) <NEWLINE> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> U = str ( input ( ) ) <NEWLINE> if U == S : <NEWLINE> <INDENT> A = A - 1 <NEWLINE> <DEDENT> elif U == T : <NEWLINE> <INDENT> B = B - 1 <NEWLINE> <DEDENT> print ( { } { } . format ( A , B ) ) <NEWLINE>
s , t = map ( str , input ( ) . split ( ) ) <NEWLINE> a , b = map ( str , input ( ) . split ( ) ) <NEWLINE> u = str ( input ( ) ) <NEWLINE> if ( u == s ) : <NEWLINE> <INDENT> print ( a - 1 , b ) <NEWLINE> <DEDENT> elif ( u == t ) : <NEWLINE> <INDENT> print ( a , b - 1 ) <NEWLINE> <DEDENT>
<NL> <COMMENT> <NL> <COMMENT> <NL> s , t = map ( input ( ) . split ( ) ) <NEWLINE> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> u = input ( ) <NEWLINE> if s == u : <NEWLINE> <INDENT> a = a - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> b = b - 1 <NEWLINE> <DEDENT> print ( a , b ) <NEWLINE>
def resolve ( ) : <NEWLINE> <INDENT> s , t = input ( ) . split ( ) <NEWLINE> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> u = input ( ) <NEWLINE> print ( a - ( s == u ) , b - ( t == u ) ) <NEWLINE> <DEDENT> reoslve ( ) <NEWLINE>
s , t = input ( ) . split ( ) <NEWLINE> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> u = input ( ) <NEWLINE> <NL> if u == s : <NEWLINE> <INDENT> print ( s - 1 , t ) <NEWLINE> <DEDENT> elif u == t : <NEWLINE> <INDENT> print ( s , t - 1 ) <NEWLINE> <DEDENT>
S , T = input ( ) . split <NEWLINE> A , B = map ( int , input ( ) . split ) <NEWLINE> U = input ( ) <NEWLINE> <NL> if S == U : <NEWLINE> <INDENT> print ( A - 1 ) <NEWLINE> <DEDENT> elif T == U : <NEWLINE> <INDENT> print ( B - 1 ) <NEWLINE> <DEDENT>
S , T = input ( ) . split ( ) <NEWLINE> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> U = input ( ) <NEWLINE> print ( A - 1 B if S == U else A B - 1 ) <NEWLINE>
s , t = map ( input ( ) . split ( ) ) <NEWLINE> <NL> a , b = map ( int ( input ( ) . split ( ) ) ) <NEWLINE> <NL> u = input ( ) <NEWLINE> <NL> if s == u : <NEWLINE> <INDENT> print ( a - 1 , b ) <NEWLINE> <DEDENT> elif t == u : <NEWLINE> <INDENT> print ( a , b - 1 ) <NEWLINE> <DEDENT>
[ H , A ] = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> t = 0 <NEWLINE> if H / A != int ( H / A ) : <NEWLINE> <INDENT> t = 1 <NEWLINE> <DEDENT> print ( int ( H / A ) + t ) <NEWLINE>
str = input ( ) . split ( <STRING> ) <NEWLINE> S = str [ 0 ] <NEWLINE> T = str [ 1 ] <NEWLINE> num = input ( ) . split ( <STRING> ) <NEWLINE> NS = int ( num [ 0 ] ) <NEWLINE> NT = int ( num [ 1 ] ) <NEWLINE> U = input ( ) <NEWLINE> <NL> if S == U : <NEWLINE> <INDENT> print ( str ( NS - 1 ) + <STRING> + str ( NT ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( str ( NS ) + <STRING> + str ( NT - 1 ) ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = set ( a ) <NEWLINE> print ( <STRING> if n == len ( b ) , else <STRING> ) <NEWLINE>
s , t = map ( str , input ( ) . split ( ) ) <NEWLINE> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> u = int ( input ( ) ) <NEWLINE> if s == u : <NEWLINE> <INDENT> print ( a - 1 , b ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( a , b - 1 ) <NEWLINE> <DEDENT>
s , t = input ( ) . split ( ) <NEWLINE> a , b = map ( int . input ( ) . split ( ) ) <NEWLINE> u = input ( ) <NEWLINE> print ( a - 1 , b ) if s == u else print ( a , b - 1 ) <NEWLINE>
a , b = input ( ) . split <NEWLINE> c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> e = input ( ) <NEWLINE> <NL> if a == e : <NEWLINE> <INDENT> print ( <STRING> . format ( c - 1 , d ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> . format ( c , d - 1 ) ) <NEWLINE> <DEDENT>
a = str ( input ( ) ) <NEWLINE> print ( str ( x ) * len ( a ) ) <NEWLINE>
s = input ( ) <NEWLINE> print ( x * len ( s ) ) <NEWLINE>
s = input ( ) <NEWLINE> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> s [ i ] = <STRING> <NEWLINE> <DEDENT> print ( s ) <NEWLINE>
S = len ( input ( ) ) <NEWLINE> print ( x * S ) <NEWLINE>
print ( x * len ( input ( ) ) ) <NEWLINE>
S = input ( ) <NEWLINE> print ( <STRING> * count ( S ) ) <NEWLINE>
print ( <STRING> * len ( input ( ) ) <NEWLINE>
s = input ( ) <NEWLINE> print ( x * len ( s ) ) <NEWLINE>
s = input ( ) <NEWLINE> <NL> l = len ( s ) <NEWLINE> <NL> for i in range ( l ) : <NEWLINE> <INDENT> s [ i ] = <STRING> <NEWLINE> <NL> <NL> <DEDENT> print ( s ) <NEWLINE>
s = input ( ) <NEWLINE> for i in len ( s ) : <NEWLINE> <INDENT> print ( x , end = <STRING> ) <NEWLINE> <DEDENT>
S = input ( ) <NEWLINE> T = <STRING> <NEWLINE> for _ in len ( S ) : <NEWLINE> <INDENT> T += <STRING> <NEWLINE> <DEDENT> print ( T ) <NEWLINE>
s = input ( ) <NEWLINE> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> s [ i ] = <STRING> <NEWLINE> <DEDENT> print ( s ) <NEWLINE>
S = input ( ) <NEWLINE> L = len [ S ] <NEWLINE> for i in rnage ( L ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> print ( <STRING> ** len ( s ) ) <NEWLINE>
S = input ( ) <NEWLINE> for i in range ( len ( S ) ) : <NEWLINE> <INDENT> S [ i ] = <STRING> <NEWLINE> <DEDENT> print ( S ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> an = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> an . sort ( ) <NEWLINE> <NL> for x in range ( n - 1 ) : <NEWLINE> <INDENT> if an [ i + 1 ] - an [ i ] == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
def check ( seq ) : <NEWLINE> <INDENT> return len ( seq ) != len ( set ( seq ) ) <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input . split ( ) ) ) <NEWLINE> ans = check ( A ) <NEWLINE> if ans : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> main ( ) <NEWLINE>
import sys <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A . sort ( ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if ( A [ i ] == A [ i + 1 ] ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
import sys <NEWLINE> N = int ( input ( ) ) <NEWLINE> cc = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> dic = set ( ) <NEWLINE> for i in cc : <NEWLINE> <INDENT> if i in dic : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dic . append ( i ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> <NL>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) ) ) <NEWLINE> S = set ( A ) <NEWLINE> print ( <STRING> if len ( A ) == len ( S ) else <STRING> ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> cnt = [ 0 ] * ( 10 ** 9 + 1 ) <NEWLINE> <NL> for i in a : <NEWLINE> <INDENT> cnt [ i ] += 1 <NEWLINE> if cnt [ i ] > 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( str , input ( ) . split ( ) ) ) <NEWLINE> a . sort ( ) <NEWLINE> ans = <STRING> <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if a [ i ] == a [ i + 1 ] : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> List = list ( map ( int , input ( ) , split ( ) ) ) <NEWLINE> Set = set ( ) <NEWLINE> for i in List : <NEWLINE> <INDENT> if i in Set : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> return <NEWLINE> <DEDENT> Set . add ( i ) <NEWLINE> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> main ( ) <NEWLINE>
m = int ( input ( ) ) <NEWLINE> n = list ( map ( int , input ( ) . split ) ) <NEWLINE> print ( <STRING> if len ( set ( n ) ) == m else <STRING> ) <NEWLINE>
from collections import Counter <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) <NEWLINE> dic = Counter ( a ) <NEWLINE> for val in dic . values ( ) : <NEWLINE> <INDENT> if val >= 2 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if set ( a ) == len ( a ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> <NL> a = list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> if n == len ( set ( a ) ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if n = len ( set ( a ) ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input . split ( ) ) ) <NEWLINE> <NL> if N == len ( set ( A ) ) : print ( <STRING> ) <NEWLINE> else : print ( <STRING> ) <NEWLINE>
for p in P : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <INDENT> exp += ( 1 + p ) / 2 <NEWLINE> p_e . append ( exp ) <NEWLINE> <DEDENT> if n == k : <NEWLINE> <INDENT> print ( p_e [ - 1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <COMMENT> <NL> <INDENT> maxv = p_e [ k - 1 ] - 0 <NEWLINE> for i in range ( 1 , n - k ) : <NEWLINE> <COMMENT> <NL> <INDENT> p_sum = p_e [ k + i ] - p_e [ i ] <NEWLINE> maxv = max ( maxv , p_sum ) <NEWLINE> <DEDENT> print ( maxv ) <NEWLINE> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> P = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> S = [ ] <NEWLINE> sum_ = 0 <NEWLINE> for i , p in enumerate ( P ) : <NEWLINE> <INDENT> sum_ += p <NEWLINE> S . append ( sum_ ) <NEWLINE> <NL> <NL> <DEDENT> max_sum = 0 <NEWLINE> for i in range ( N - K + 1 ) : <NEWLINE> <INDENT> max_sum = max ( max_sum , S [ i + K ] - S [ i ] ) <NEWLINE> <NL> <DEDENT> res = ( max_sum + K ) / 2 <NEWLINE> <NL> print ( res ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> ps = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> s = [ 0 ] * ( n + 1 ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> s [ i + 1 ] = s [ i ] + ( ps [ i ] + 1 ) / 2 <NEWLINE> <NL> <NL> <DEDENT> tmp = 0 <NEWLINE> for i in range ( len ( res ) - k ) : <NEWLINE> <INDENT> tmp = max ( tmp , s [ i + k ] - s [ i ] ) <NEWLINE> <NL> <DEDENT> print ( <STRING> . format ( tmp ) ) <NEWLINE>
import numpy <NEWLINE> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> ps = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> s = [ 0 ] * ( n + 1 ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> s [ i + 1 ] = s [ i ] + ( ps [ i ] + 1 ) / 2 <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> tmp = 0 <NEWLINE> for i in range ( len ( res ) - k ) : <NEWLINE> <INDENT> tmp = max ( tmp , s [ i + k ] - s [ i ] ) <NEWLINE> <NL> <DEDENT> print ( <STRING> . format ( tmp ) ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = [ sum ( p [ : K ] ) ] <NEWLINE> for i in range ( N - K ) : <NEWLINE> <INDENT> ans . append ( ans [ - 1 ] - p [ i ] + p [ i + k ] ) <NEWLINE> <DEDENT> print ( max ( ans ) / 2 + K / 2 ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> q = [ ] <NEWLINE> for i in range ( len ( p ) ) : <NEWLINE> <INDENT> q . append ( p [ i ] ) <NEWLINE> <DEDENT> maxi = q [ K ] - q [ 0 ] <NEWLINE> for i in range ( 1 , N - K + 1 ) : <NEWLINE> <INDENT> sub = q [ K + i ] - q [ i ] <NEWLINE> if sub >= maxi : <NEWLINE> <INDENT> maxi = sub <NEWLINE> <DEDENT> <DEDENT> print ( ( maxi + K ) / 2 ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ int ( s ) for s in input ( ) . split ( ) ] <NEWLINE> b = [ 0 ] * k <NEWLINE> c = 0 <NEWLINE> v [ 0 ] = a [ 0 ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> v [ i + 1 ] = v [ i ] + a [ i + 1 ] <NEWLINE> <DEDENT> mx = v [ 2 ] <NEWLINE> for i in range ( 3 , n ) : <NEWLINE> <INDENT> g = v [ i ] - v [ i - 2 ] <NEWLINE> mx = max ( mx , g ) <NEWLINE> <NL> <DEDENT> print ( ( mx + 1 ) / 2 ) <NEWLINE>
import numpy as np <NEWLINE> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> l = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> l . append ( ( 1 + p [ i ] ) / 2 ) <NEWLINE> <NL> <DEDENT> a = [ 0 ] * N + 1 <NEWLINE> a [ 0 ] = l [ 0 ] <NEWLINE> for i in range ( 1 , len ( l ) ) : <NEWLINE> <INDENT> a [ i ] = a [ i - 1 ] + l [ i ] <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in range ( K , len ( l ) ) : <NEWLINE> <INDENT> ans = max ( ans , a [ i ] - a [ i - K ] ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
N = input ( ) <NEWLINE> K = int ( input ( ) ) <NEWLINE> m = len ( N ) <NEWLINE> dp = [ [ [ 0 ] * ( K + 1 ) for _ in range ( 2 ) ] for _ in range ( m + 1 ) ] <NEWLINE> dp [ 0 ] [ 0 ] [ 0 ] = 1 <COMMENT> <NEWLINE> <NL> for i in range ( 1 , m + 1 ) : <NEWLINE> <INDENT> l = int ( N [ i - 1 ] ) <NEWLINE> for k in range ( K + 1 ) : <COMMENT> <NEWLINE> <INDENT> if k - 1 >= 0 : <NEWLINE> <INDENT> if l != 0 : <COMMENT> <NEWLINE> <INDENT> dp [ i ] [ 0 ] [ k ] = dp [ i - 1 ] [ 0 ] [ k - 1 ] <NEWLINE> dp [ i ] [ 1 ] [ k ] = dp [ i - 1 ] [ 1 ] [ k ] + 9 * dp [ i - 1 ] [ 1 ] [ k - 1 ] + dp [ i - 1 ] [ 0 ] [ k ] + ( l - 1 ) * dp [ i - 1 ] [ 0 ] [ k - 1 ] <NEWLINE> <DEDENT> else : <COMMENT> <NEWLINE> <INDENT> dp [ i ] [ 0 ] [ k ] = dp [ i - 1 ] [ 0 ] [ k ] <NEWLINE> dp [ i ] [ 1 ] [ k ] = dp [ i - 1 ] [ 1 ] [ k ] + 9 * dp [ i - 1 ] [ 1 ] [ k - 1 ] <NEWLINE> <DEDENT> <DEDENT> else : <COMMENT> <NEWLINE> <INDENT> if l != 0 : <COMMENT> <NEWLINE> <COMMENT> <NL> <INDENT> dp [ i ] [ 1 ] [ k ] = dp [ i - 1 ] [ 1 ] [ k ] + dp [ i - 1 ] [ 0 ] [ k ] <COMMENT> <NEWLINE> <DEDENT> else : <COMMENT> <NEWLINE> <INDENT> dp [ i ] [ 0 ] [ k ] = dp [ i - 1 ] [ 0 ] [ k ] <COMMENT> <NEWLINE> dp [ i ] [ 1 ] [ k ] = dp [ i - 1 ] [ 1 ] [ k ] <COMMENT> <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( dp ) <NEWLINE> print ( dp [ m ] [ 0 ] [ K ] + dp [ m ] [ 1 ] [ K ] ) <NEWLINE> <NL> N = input ( ) <NEWLINE> K = int ( input ( ) ) <NEWLINE> m = len ( N ) <NEWLINE> dp = [ [ [ 0 ] * ( K + 1 ) for _ in range ( 2 ) ] for _ in range ( m + 1 ) ] <NEWLINE> dp [ 0 ] [ 0 ] [ 0 ] = 1 <COMMENT> <NEWLINE> <NL> for i in range ( 1 , m + 1 ) : <NEWLINE> <INDENT> l = int ( N [ i - 1 ] ) <NEWLINE> for k in range ( K + 1 ) : <COMMENT> <NEWLINE> <INDENT> if k - 1 >= 0 : <NEWLINE> <INDENT> if l != 0 : <COMMENT> <NEWLINE> <INDENT> dp [ i ] [ 0 ] [ k ] = dp [ i - 1 ] [ 0 ] [ k - 1 ] <NEWLINE> dp [ i ] [ 1 ] [ k ] = dp [ i - 1 ] [ 1 ] [ k ] + 9 * dp [ i - 1 ] [ 1 ] [ k - 1 ] + dp [ i - 1 ] [ 0 ] [ k ] + ( l - 1 ) * dp [ i - 1 ] [ 0 ] [ k - 1 ] <NEWLINE> <DEDENT> else : <COMMENT> <NEWLINE> <INDENT> dp [ i ] [ 0 ] [ k ] = dp [ i - 1 ] [ 0 ] [ k ] <NEWLINE> dp [ i ] [ 1 ] [ k ] = dp [ i - 1 ] [ 1 ] [ k ] + 9 * dp [ i - 1 ] [ 1 ] [ k - 1 ] <NEWLINE> <DEDENT> <DEDENT> else : <COMMENT> <NEWLINE> <INDENT> dp [ i ] [ 0 ] [ k ] = 0 <COMMENT> <NEWLINE> dp [ i ] [ 1 ] [ k ] = 1 <COMMENT> <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> print ( dp [ m ] [ 0 ] [ K ] + dp [ m ] [ 1 ] [ K ] ) <NEWLINE>
N = input ( ) <NEWLINE> K = int ( input ( ) ) <NEWLINE> m = len ( N ) <NEWLINE> dp = [ [ [ 0 ] * ( K + 1 ) for _ in range ( 2 ) ] for _ in range ( m + 1 ) ] <NEWLINE> dp [ 0 ] [ 0 ] [ 0 ] = 1 <COMMENT> <NEWLINE> <NL> for i in range ( 1 , m + 1 ) : <NEWLINE> <INDENT> l = int ( N [ i - 1 ] ) <NEWLINE> for k in range ( K + 1 ) : <COMMENT> <NEWLINE> <INDENT> if k == 0 : <COMMENT> <NEWLINE> <INDENT> dp [ i ] [ 0 ] [ k ] = 0 <COMMENT> <NEWLINE> dp [ i ] [ 1 ] [ k ] = 1 <COMMENT> <NEWLINE> <DEDENT> else k - 1 >= 0 : <NEWLINE> <INDENT> if l != 0 : <COMMENT> <NEWLINE> <INDENT> dp [ i ] [ 0 ] [ k ] = dp [ i - 1 ] [ 0 ] [ k - 1 ] <NEWLINE> dp [ i ] [ 1 ] [ k ] = dp [ i - 1 ] [ 1 ] [ k ] + 9 * dp [ i - 1 ] [ 1 ] [ k - 1 ] + dp [ i - 1 ] [ 0 ] [ k ] + ( l - 1 ) * dp [ i - 1 ] [ 0 ] [ k - 1 ] <NEWLINE> <DEDENT> else : <COMMENT> <NEWLINE> <INDENT> dp [ i ] [ 0 ] [ k ] = dp [ i - 1 ] [ 0 ] [ k ] <NEWLINE> dp [ i ] [ 1 ] [ k ] = dp [ i - 1 ] [ 1 ] [ k ] + 9 * dp [ i - 1 ] [ 1 ] [ k - 1 ] <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( dp [ m ] [ 0 ] [ K ] + dp [ m ] [ 1 ] [ K ] ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> read = sys . stdin . buffer . read <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> readlines = sys . stdin . buffer . readlines <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> N = int ( readline ( ) ) <NEWLINE> K = int ( readline ( ) ) <NEWLINE> @ lru_cache ( None ) <NEWLINE> def f ( N , K ) : <NEWLINE> <INDENT> if K == - 1 : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> if N < 10 : <NEWLINE> <INDENT> if K == 0 : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> elif K == 1 : <NEWLINE> <INDENT> return N <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> <DEDENT> ans = 0 <NEWLINE> q , mod = divmod ( N , 10 ) <NEWLINE> ans += f ( q , K ) + mod * f ( q , K - 1 ) + ( 9 - mod ) * f ( q - 1 , K - 1 ) <NEWLINE> return ans <NEWLINE> <DEDENT> print ( f ( N , K ) ) <NEWLINE>
n = input ( ) <NEWLINE> k = int ( input ( ) ) <NEWLINE> l = len ( n ) <NEWLINE> dp = [ [ [ 0 for _ in range ( 2 ) ] for _ in range ( 5 ) ] for _ in range ( l + 1 ) ] <NEWLINE> dp [ 0 ] [ 1 ] [ 1 ] = int ( n [ 0 ] ) - 1 <NEWLINE> dp [ 0 ] [ 1 ] [ 0 ] = 1 <NEWLINE> for i in range ( 1 , L ) : <NEWLINE> <INDENT> for j in range ( 4 ) : <NEWLINE> <INDENT> b = i - 1 <NEWLINE> now = int ( n [ i ] ) <NEWLINE> if now = 0 : <NEWLINE> <INDENT> dp [ i ] [ j ] [ 0 ] += dp [ b ] [ j ] [ 0 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dp [ i ] [ j ] [ 1 ] += dp [ b ] [ j ] [ 0 ] <NEWLINE> dp [ i ] [ j + 1 ] [ 1 ] += dp [ b ] [ j ] [ 0 ] * ( now - 1 ) <NEWLINE> dp [ i ] [ j + 1 ] [ 0 ] += dp [ b ] [ j ] [ 0 ] <NEWLINE> <DEDENT> dp [ i ] [ j ] [ 1 ] += dp [ b ] [ j ] [ 1 ] <NEWLINE> dp [ i ] [ j + 1 ] [ 1 ] += dp [ b ] [ j ] [ 1 ] * 9 <NEWLINE> <DEDENT> dp [ i ] [ 1 ] [ 1 ] += 9 <NEWLINE> <DEDENT> print ( dp [ l - 1 ] [ k ] [ 0 ] + dp [ l - 1 ] [ k ] [ 1 ] ) <NEWLINE>
dp [ 0 ] [ 1 ] [ 1 ] = int ( n [ 0 ] ) - 1 <NEWLINE> dp [ 0 ] [ 1 ] [ 0 ] = 1 <NEWLINE> dp [ 0 ] [ 0 ] [ 1 ] = 1 <NEWLINE> <NL> for i in range ( 1 , l ) : <NEWLINE> <INDENT> for j in range ( 4 ) : <NEWLINE> <INDENT> b = i - 1 <NEWLINE> now = int ( n [ i ] ) <NEWLINE> if now == 0 : <NEWLINE> <INDENT> dp [ i ] [ j ] [ 0 ] += dp [ b ] [ j ] [ 0 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dp [ i ] [ j ] [ 1 ] += dp [ b ] [ j ] [ 0 ] <NEWLINE> dp [ i ] [ j + 1 ] [ 1 ] += dp [ b ] [ j ] [ 0 ] * ( now - 1 ) <NEWLINE> dp [ i ] [ j + 1 ] [ 0 ] += dp [ b ] [ j ] [ 0 ] <NEWLINE> <DEDENT> dp [ i ] [ j ] [ 1 ] += dp [ b ] [ j ] [ 1 ] <NEWLINE> dp [ i ] [ j + 1 ] [ 1 ] += 9 * dp [ b ] [ j ] [ 1 ] <NEWLINE> <DEDENT> <DEDENT> print ( dp [ l - 1 ] [ k ] [ 0 ] + dp [ l - 1 ] [ k ] [ 1 ] ) <NEWLINE>
MOD = 10 ** 9 + 7 <NEWLINE> MOD_t_MAX = 2 * 10 ** 6 + 100 <NEWLINE> <NL> fac = [ None ] * MOD_t_MAX <NEWLINE> finv = [ None ] * MOD_t_MAX <NEWLINE> inv = [ None ] * MOD_t_MAX <NEWLINE> def MOD_COM_init ( ) : <NEWLINE> <INDENT> fac [ 0 ] = fac [ 1 ] = 1 <NEWLINE> finv [ 0 ] = finv [ 1 ] = 1 <NEWLINE> inv [ 1 ] = 1 <NEWLINE> for i in range ( 2 , MOD_t_MAX ) : <NEWLINE> <INDENT> fac [ i ] = fac [ i - 1 ] * i % MOD <NEWLINE> inv [ i ] = MOD - inv [ MOD % i ] * ( MOD // i ) % MOD <NEWLINE> finv [ i ] = finv [ i - 1 ] * inv [ i ] % MOD <NEWLINE> <DEDENT> <DEDENT> def MOD_COM ( n , k ) : <NEWLINE> <INDENT> if n < k : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> if n < 0 or k < 0 : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> return fac [ n ] * ( finv [ k ] * finv [ n - k ] % MOD ) % MOD <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> r1 , c1 , r2 , c2 = map ( int , input ( ) . split ( ) ) <NEWLINE> MOD_COM_init ( ) <NEWLINE> a = MOD_COM ( r2 + 1 + c2 + 1 , r2 + 1 ) - 1 <NEWLINE> b = MOD_COM ( r2 + 1 + c1 , c1 ) - 1 <NEWLINE> c = MOD_COM ( r1 + c2 + 1 , r1 ) - 1 <NEWLINE> d = MOD_COM ( r1 + c1 , c1 ) - 1 <NEWLINE> ans = a - b - c + d <NEWLINE> print ( ans % MOD ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
h , a = map ( int , input ( ) . split ( ) <NEWLINE> ans = h // a + 1 <NEWLINE> if h % a == 0 : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
H , A = input ( ) . split ( ) <NEWLINE> <NL> import math <NEWLINE> <NL> print ( math . ceil ( H / A ) ) <NEWLINE>
h , a = map ( int , input ( ) . split ( ) ) <NEWLINE> count = 0 <NEWLINE> while h > : <NEWLINE> <INDENT> h = h - a <NEWLINE> count = count + 1 <NEWLINE> <DEDENT> print ( count ) <NEWLINE>
H , A = input ( ) . split ( ) <NEWLINE> print ( int ( H ) // int ( A ) + 1 if 1 <= H <= 10000 and 1 <= A <= 10000 ) <NEWLINE>
INPUT = list ( input ( ) . split ( ) ) <NEWLINE> H = INT ( INPUT [ 0 ] ) <NEWLINE> A = INT ( INPUT [ 1 ] ) <NEWLINE> if H % A == 0 : <NEWLINE> <INDENT> print ( H // A ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( H // A + 1 ) <NEWLINE> <DEDENT>
a , b = list ( map ( int , input ( ) ) ) <NEWLINE> count = 0 <NEWLINE> while ( a < 0 ) : <NEWLINE> <INDENT> count += 1 <NEWLINE> a -= b <NEWLINE> <DEDENT> print ( count ) <NEWLINE>
h , a = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( h // a + map ( h % a != 0 ) ) <NEWLINE>
h , a = int ( input ( ) ) <NEWLINE> if ( h % a == 0 ) : <NEWLINE> <INDENT> print ( h // a ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( h // a + 1 ) <NEWLINE> <DEDENT>
h , a = map ( int , input . split ( ) ) <NEWLINE> if h % a == 0 : <NEWLINE> <INDENT> print ( h // a ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( h // a + 1 ) <NEWLINE> <DEDENT>
h , n = map ( int , input ( ) . split ( ) ) <NEWLINE> a = sum ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> print ( <STRING> if h - a <= 0 else <STRING> ) <NEWLINE>
h , a = map ( int , input ( ) . split ( ) ) <NEWLINE> if h % a = 0 : <NEWLINE> <INDENT> print ( h // a ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( h // a + 1 ) <NEWLINE> <DEDENT>
tmp = input ( ) . split ( <STRING> ) <NEWLINE> <NL> HP = int ( tmp [ 0 ] ) <NEWLINE> attack = int ( tmp [ 1 ] ) <NEWLINE> <NL> print ( math . ceil ( HP / attack ) ) <NEWLINE>
H , A = map ( int , input . split ( ) ) <NEWLINE> ans = H // A <NEWLINE> if H % A != 0 : <NEWLINE> <INDENT> ans = ans + 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
h , a = map ( int , input . split ( ) ) <NEWLINE> if h > a : <NEWLINE> <INDENT> print ( h // a ) <NEWLINE> <DEDENT> if h <= a : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT>
ri = lambda S : [ int ( v ) for v in S . split ( ) ] <NEWLINE> def rii ( ) : return ri ( input ( ) ) <NEWLINE> <NL> H , A = rii ( ) <NEWLINE> <NL> print ( ( H // A ) <NEWLINE>
H , A = map ( int , intput ( ) . split ( ) ) <NEWLINE> res = H // A <NEWLINE> if H % A > 0 : <NEWLINE> <INDENT> res += 1 <NEWLINE> <DEDENT> print ( res ) <NEWLINE>
h , a = map ( int , input . split ( ) ) <NEWLINE> cnt = 0 <NEWLINE> while True : <NEWLINE> <INDENT> h -= a <NEWLINE> cnt += 1 <NEWLINE> if h <= 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
H , A = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( math . ceil ( H / A ) ) <NEWLINE>
h , a = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = 0 <NEWLINE> for h > 0 : <NEWLINE> <INDENT> h -= a <NEWLINE> ans += 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
h , a = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> ans = h // a <NEWLINE> if h % a == 0 : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT> esle : <NEWLINE> <INDENT> print ( ans + 1 ) <NEWLINE> <DEDENT>
H , A = map ( int ( ) , input ( ) . split ) <NEWLINE> print ( H // A if H % A == 0 else H // A + 1 ) <NEWLINE>
h , a = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( h // a + ( 1 - int ( h % a == 0 ) ) <NEWLINE>
h , n = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ int ( input ( ) ) for i in range ( n ) ] <NEWLINE> if sum ( a ) >= h : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
H , N = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) <NEWLINE> T = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> T += A [ i ] <NEWLINE> <DEDENT> if H - T <= 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> lis = list ( map ( int , input ( ) . split ) ) <NEWLINE> c = sum ( lis ) <NEWLINE> print ( <STRING> if a > c else <STRING> ) <NEWLINE>
<COMMENT> <NL> monster_hp , quantity_of_skills = map ( int , input ( ) . split ( ) ) <NEWLINE> skills = map ( int , input ( ) . split ( ) ) <NEWLINE> skills_list = [ skills ] <NEWLINE> <NL> <COMMENT> <NL> total_damage = 0 <NEWLINE> for i in skills_list : <NEWLINE> <INDENT> total_damage += i <NEWLINE> <NL> <DEDENT> if monster_hp <= total_damage : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import sys <NEWLINE> H , N = map ( int , input ( ) . split ( ) ) <NEWLINE> A = map ( int , input ( ) . split ( ) ) <NEWLINE> s = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> s += A [ i ] <NEWLINE> if s >= H : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
H , N = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( int ( input ( ) ) ) <NEWLINE> if sum ( A ) >= H : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
h , n = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , innput ( ) . split ( ) ) ) <NEWLINE> <NL> if sum ( a ) >= h : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
<NL> <COMMENT> <NL> <COMMENT> <NL> h , n = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> s = sum ( a ) <NEWLINE> if a <= s : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
<COMMENT> <NL> h , n = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , inout ( ) . split ( ) ) ) <NEWLINE> print ( <STRING> if sum ( a ) >= h else <STRING> ) <NEWLINE>
<NL> H , N = map ( int , input ( ) . split ( ) ) <NEWLINE> damege = map ( int , input ( ) . split ( ) ) <NEWLINE> damege_list = [ damege ] <NEWLINE> <NL> damege . sort ( ) <NEWLINE> <NL> if H - ( damege [ - 1 ] + damege [ - 2 ] ) <= 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
H , N = map ( int , input ( ) . split ( ) ) <NEWLINE> lists = [ ] lists . append ( int , input ( ) . split ( ) ) <NEWLINE> lists = lists . sort ( ) <NEWLINE> if N >= 2 and lists [ N - 1 ] + lists [ N - 2 ] >= H : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> If N == 1 and lists [ 0 ] >= H : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> if N == 1 and lists [ 0 ] < H : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
H , N = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if sum ( A ) = > H : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
H , N , = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> Damage = [ ] <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> Ai = map ( int , input ( ) . split ( ) ) <NEWLINE> Damage . append ( Ai ) <NEWLINE> <DEDENT> Total_Damage = sum ( Damage ) <NEWLINE> <NL> if H <= Total_Damage : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
210 5 <NEWLINE> 31 41 59 26 53 <NEWLINE>
h , n = map ( int , input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ans += a [ i ] <NEWLINE> <DEDENT> if ( ans >= h ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
H , N , = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> Damage = [ ] <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> Ai = int ( input ( ) ) <NEWLINE> Damage . append ( Ai ) <NEWLINE> <DEDENT> Total_Damage = sum ( Damage ) <NEWLINE> <NL> if H <= Total_Damage : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> h . sort ( reverce = True ) <NEWLINE> ans = 0 <NEWLINE> if ( k >= n ) : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( k , n ) : <NEWLINE> <INDENT> ans += h [ i ] <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> enemys = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> enemys = sorted ( enemys , reversed = True ) <NEWLINE> if K >= len ( enemys ) : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> enemys = enemys [ K + 1 : ] <NEWLINE> print ( sum ( enemys ) ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> N , K = map ( int , next ( sys . stdin . buffer ) . split ( ) ) <NEWLINE> H = sorted ( map ( int , next ( sys . stdin . buffer ) . split ( ) ) ) <NEWLINE> <NL> print ( sum ( H [ : K ] ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> H = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> if k >= n : ans = 0 <NEWLINE> elif k == 0 : ans = sum ( H ) <NEWLINE> else : ans = sum ( H [ - k ] ) <NEWLINE> print ( ans ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> h = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> h_s = sorted ( h ) <NEWLINE> if len ( h_s ) <= k : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for _ in range ( k ) : <NEWLINE> <INDENT> h_s . pop ( ) <NEWLINE> <DEDENT> ans = sum ( h_s ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( <NEWLINE> <DEDENT>
h = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> i = 0 <NEWLINE> while True : <NEWLINE> <INDENT> if ( i >= h ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> i += <NEWLINE> <DEDENT> if ( i = 0 ) : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 2 ** ( i + 1 ) - 1 ) <NEWLINE> <DEDENT>
h = int ( input ( ) ) <NEWLINE> ans = 1 <NEWLINE> h //= 2 <NEWLINE> i = 2 <NEWLINE> while h > 0 : <NEWLINE> <INDENT> ans += i <NEWLINE> i *= 2 <NEWLINE> h //= 2 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> pow ( 2 , n ) - 1 <NEWLINE>
H = int ( input ( ) ) <NEWLINE> count = 0 <NEWLINE> ans = 0 <NEWLINE> while H > 1 : <NEWLINE> <INDENT> H = H // 2 <NEWLINE> ans += 2 ** i <NEWLINE> count += 1 <NEWLINE> <DEDENT> ans += 2 ** i <NEWLINE> print ( ans ) <NEWLINE>
n = int ( log2 ( int ( input ( ) ) ) ) <NEWLINE> <NL> print ( 2 ** ( n + 1 ) - 1 ) <NEWLINE>
H = int ( input ( ) ) <NEWLINE> import pdb ; pdb . set_trace ( ) <NEWLINE> def atk ( n ) : <NEWLINE> <INDENT> if n == 1 : return 1 <NEWLINE> return 1 + 2 * ( atk ( n // 2 ) ) <NEWLINE> <NL> <DEDENT> print ( atk ( H ) ) <NEWLINE>
h = int ( input ( ) ) <NEWLINE> a = [ ] <NEWLINE> while h >= 1 : <NEWLINE> <INDENT> a . append ( h ) <NEWLINE> h // 2 <NEWLINE> <DEDENT> count = 0 <NEWLINE> for i in a : <NEWLINE> <INDENT> while a [ i ] >= 1 : <NEWLINE> <INDENT> count += 1 <NEWLINE> a [ i ] // 2 <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
H = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> while H > 0 : <NEWLINE> <INDENT> if H == 1 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> e = H // 2 <NEWLINE> ans += e <NEWLINE> H -= 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
H = int ( input ( ) ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> def attack_num ( x ) : <NEWLINE> <INDENT> if x == 1 : return 1 <NEWLINE> else : return 2 * f ( x // 2 ) + 1 <NEWLINE> <NL> <DEDENT> print ( attack_num ( H ) ) <NEWLINE>
( h , n ) , * t = [ map ( int , o . split ( ) ) for o in open ( 0 ) ] <NEWLINE> dp = [ 0 ] * ( h + 10100 ) <NEWLINE> for i in range ( 1 , h + 1 ) : dp [ i ] = min ( dp [ i - a ] + b for a , b in t ) <NEWLINE> print ( dp [ h ] ) <NEWLINE>
import numpy as np <NEWLINE> h , n = map ( int , input ( ) . split ) <NEWLINE> p = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ] <NEWLINE> m = max ( p [ : , 0 ] ) <NEWLINE> dp = [ 0 ] * ( h + m + 1 ) <NEWLINE> for i in range ( m + 1 , h + m + 1 ) : <NEWLINE> <INDENT> dp [ i ] = min ( dp [ i - a ] + b for a , b in p ) <NEWLINE> <DEDENT> print ( dp [ h + m ] ) <NEWLINE>
h , n = map ( int , input ( ) . split ( ) ) <NEWLINE> p = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ] <NEWLINE> m = 10 ** 4 <NEWLINE> dp = [ 0 ] * ( h + m + 1 ) <NEWLINE> for i in range ( m + 1 , h + m + 1 ) : <NEWLINE> <INDENT> dp [ i ] = min ( dp [ i - a ] + b for a , b in p ) <NEWLINE> <DEDENT> print ( dp [ h + m + ] ) <NEWLINE>
from numba import jit <NEWLINE> from sys import stdin <NEWLINE> <NL> @ jit ( nopython = True ) <NEWLINE> def num ( ) : <NEWLINE> <INDENT> h , n = map ( int , input ( ) . split ( ) ) <NEWLINE> magic = [ list ( map ( int , stdin . readline ( ) . split ( ) ) ) for _ in range ( n ) ] <NEWLINE> INF = float ( <STRING> ) <NEWLINE> ans = [ INF ] * ( h + 1 ) <NEWLINE> ans [ - 1 ] = 0 <NEWLINE> <NL> for i in range ( h , 0 , - 1 ) : <NEWLINE> <INDENT> if ans [ i ] != INF : <NEWLINE> <INDENT> for j in magic : <NEWLINE> <INDENT> if i - j [ 0 ] < 0 : <NEWLINE> <INDENT> num = ans [ i ] + j [ 1 ] <NEWLINE> if ans [ 0 ] > num : <NEWLINE> <INDENT> ans [ 0 ] = num <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> num = ans [ i ] + j [ 1 ] <NEWLINE> if ans [ i - j [ 0 ] ] > num : <NEWLINE> <INDENT> ans [ i - j [ 0 ] ] = num <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> return ans [ 0 ] <NEWLINE> <DEDENT> print ( num ( ) ) <NEWLINE> <NL> <NL>
import sys <NEWLINE> def input ( ) : return sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> import numpy as np <NEWLINE> def main ( ) : <NEWLINE> <INDENT> h , n = map ( int , input ( ) . split ( ) ) <NEWLINE> lis = np . array ( [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ] ) <NEWLINE> a_max = np . max ( lis [ : , 0 ] ) <NEWLINE> dp = np . full ( h + a_max + 1 , 10 ** 10 ) <NEWLINE> dp [ 0 ] = 0 <NEWLINE> for l in lis : <NEWLINE> <INDENT> dp [ i : i + l [ 0 ] + 1 ] = np . minimum ( dp [ i : i + l [ 0 ] + 1 ] , dp [ i ] + l [ 1 ] ) <NEWLINE> <DEDENT> print ( dp ) <NEWLINE> print ( dp [ h ] ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
from collections import deque <NEWLINE> n , d , a = map ( int , input ( ) . split ( ) ) <NEWLINE> xh = [ map ( int , input ( ) . split ( ) ) for _ in range ( n ) ] <NEWLINE> xh . sort ( ) <NEWLINE> D = 2 * D <NEWLINE> ans = 0 <NEWLINE> total = 0 <NEWLINE> q = deque ( ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> x , h = xh [ i ] <NEWLINE> while len ( q ) >= 1 and x > q [ 0 ] [ 0 ] : <NEWLINE> <INDENT> total -= q . popleft ( ) [ 1 ] <NEWLINE> <DEDENT> h -= total <NEWLINE> if h > 0 : <NEWLINE> <INDENT> num = ( h - h % a ) // a <NEWLINE> damage = a * nim <NEWLINE> ans += num <NEWLINE> total += damage <NEWLINE> q . append ( [ x + D , damage ] ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from collections import deque <NEWLINE> from math import ceil <NEWLINE> <NL> <COMMENT> <NL> n , d , a = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> ms = sorted ( [ ( pos , ceil ( hp / a ) ) for pos , hp in [ map ( int , input ( ) . split ( ) ) for i in range ( n ) ] ) <NEWLINE> <NL> bombs = deque ( ) <NEWLINE> <NL> ans = 0 <NEWLINE> valid_bomb = 0 <NEWLINE> for pos , hp in ms : <NEWLINE> <COMMENT> <NL> <INDENT> while que and que [ 0 ] [ 0 ] < pos : <NEWLINE> <INDENT> bomb_border , bomb_cnt = bombs . popleft ( ) <NEWLINE> valid_bomb -= bomb_cnt <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> bomb_cnt = max ( 0 , hp - valid_bomb ) <NEWLINE> valid_bomb += bomb_cnt <NEWLINE> ans += bomb_cnt <NEWLINE> <NL> <COMMENT> <NL> if bomb_cnt > 0 : <NEWLINE> <INDENT> que . append ( [ pos + d * 2 , bomb_cnt ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N , M = map ( int , input . split ( ) ) <NEWLINE> print ( <STRING> ) if N == M else print ( <STRING> ) <NEWLINE>
N = int ( input ( <STRING> ) ) <NEWLINE> M = int ( input ( <STRING> ) ) <NEWLINE> if ( N == M ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n , m = int ( input ( ) ) <NEWLINE> if n == m : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else ( <STRING> ) <NEWLINE>
n , m = list ( map ( int , input ( ) ) ) <NEWLINE> if n * n == m * n : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> if n == m <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N M = map ( int , input ( ) . split ( ) ) <NEWLINE> if N == M : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
x , y , z = input ( ) . split ( ) <NEWLINE> x = int ( x ) <NEWLINE> y = int ( y ) <NEWLINE> <NL> <NL> <NL> if x == y : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N , M = map ( int , input ( ) ) <NEWLINE> if ( N == M ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n , m = int ( input ( ) ) <NEWLINE> if ( n == m ) print ( <STRING> ) <NEWLINE> else print ( <STRING> ) <NEWLINE>
a , b = list ( map ( int , input ( ) . splilt ( ) ) ) <NEWLINE> if a == b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n , m = map ( int ( ) , input ( ) . split ( ) ) <NEWLINE> if n == m : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
<INDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> <INDENT> if n == m : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
<NL> a , b = map ( int , input ( ) , split ( ) ) <NEWLINE> if a == b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . spit ( ) ) <NEWLINE> if n == m : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> if ( n == m ) : <NEWLINE> <INDENT> print ( yes ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( no ) <NEWLINE> <DEDENT>
N , M = map ( int , input ( ) ) <NEWLINE> <NL> print ( <STRING> ) if N == M else print ( <STRING> ) <NEWLINE>
n = input ( ) <NEWLINE> m = input ( ) <NEWLINE> <NL> if n == m : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if ( N = M ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> if m >= n : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elses : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
from sys import stdin <NEWLINE> input = sys . stdin . buffer . readline <NEWLINE> def MAP ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def LIST ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> n , m = MAP ( ) <NEWLINE> print ( <STRING> ) if n == m else print ( <STRING> ) <NEWLINE>
a , b = input ( ) <NEWLINE> A = int ( a * b ) <NEWLINE> B = int ( b * a ) <NEWLINE> print ( min ( A , B ) ) <NEWLINE>
a , b = map ( str , input ( ) . split ( ) ) <NEWLINE> res = <STRING> <NEWLINE> if a < b : <NEWLINE> <INDENT> for i in range ( b ) : <NEWLINE> <INDENT> res += a <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( a ) : <NEWLINE> res += b <NEWLINE> <DEDENT> print ( res ) <NEWLINE>
a_str , b_str = input . split ( ) <NEWLINE> a , b = int ( a_str ) , int ( b_str ) <NEWLINE> <NL> A = a_str * b <NEWLINE> B = b_str * a <NEWLINE> <NL> print ( min ( A , B ) ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if a > b : <NEWLINE> <INDENT> print ( str ( b ) * a ) <NEWLINE> <DEDENT> else <NEWLINE> <INDENT> print ( str ( a ) * b ) <NEWLINE> <DEDENT>
a , b = int ( input ( ) ) <NEWLINE> ls = [ str ( a ) * b , str ( b ) * a ] <NEWLINE> ls . sort ( ) <NEWLINE> print ( ls [ 0 ] ) <NEWLINE>
a , b = input ( ) . split ( ) <NEWLINE> c = str ( a ) ** b <NEWLINE> d = str ( b ) ** a <NEWLINE> if a < b : <NEWLINE> <INDENT> print ( c ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( d ) <NEWLINE> <DEDENT>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> min_a = str ( a ) * b <NEWLINE> min_b = str ( b ) * a <NEWLINE> print ( min ( min_a , min_b ) <NEWLINE>
input_line = input ( ) . rstrip ( ) . slpit ( ) <NEWLINE> num1 = int ( input_line [ 0 ] ) <NEWLINE> num2 = int ( input_line [ 1 ] ) <NEWLINE> <NL> if ( num1 > num2 ) : <NEWLINE> <INDENT> print ( str ( num2 ) * num1 ) <NEWLINE> <DEDENT> elif ( num1 < num2 ) : <NEWLINE> <INDENT> print ( str ( num1 ) * num2 ) <NEWLINE> <DEDENT> elif ( num1 == num2 ) : <NEWLINE> <INDENT> print ( str ( num1 ) * num2 ) <NEWLINE> <DEDENT>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> a = ( <STRING> . join ( a ) ) * b <NEWLINE>
A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> if B < A : <NEWLINE> <INDENT> A , B = B , A <NEWLINE> <DEDENT> for i in range B ; <NEWLINE> <INDENT> print ( A , end = <STRING> ) <NEWLINE> <DEDENT> print ( ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if a <= b : <NEWLINE> <INDENT> for i in range ( b ) : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( a ) : <NEWLINE> print ( b ) <NEWLINE> <DEDENT>
a , b = map ( str , input ( ) . split ( ) ) <NEWLINE> if int ( a ) <= int ( b ) : <NEWLINE> <INDENT> s = a <NEWLINE> for i in range ( b - 1 ) : <NEWLINE> <INDENT> s += a <NEWLINE> <DEDENT> print ( s ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s = b <NEWLINE> for j in range ( a - 1 ) : <NEWLINE> <INDENT> s += b <NEWLINE> <DEDENT> print ( s ) <NEWLINE> <NL> <DEDENT>
n = int ( input ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = p [ 0 ] <NEWLINE> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if ( m <= p [ i ] ) : <NEWLINE> <INDENT> ans += 1 <NEWLINE> a = p [ i ] <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> x = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> count = 1 <NEWLINE> if n >= 2 : <NEWLINE> <INDENT> for i in range ( n - 2 ) : <NEWLINE> <INDENT> a = min ( x ( range ( 0 , i , 1 ) ) ) <NEWLINE> if a >= x [ i + 1 ] : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> count += 0 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( count ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> print ( count ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> lst = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> premin = lst [ 0 ] <NEWLINE> ans = 0 <NEWLINE> for x in lst : <NEWLINE> <INDENT> if min_list >= x : <NEWLINE> <INDENT> ans += 1 <NEWLINE> premin = x <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = input ( ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans , m = 0 , p [ 0 ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> m = min ( m , p [ i ] ) <NEWLINE> if m == p [ i ] : ans += 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> L = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = 1 <NEWLINE> M = L [ 0 ] <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> if M >= L [ 1 ] : <NEWLINE> <INDENT> M = L [ 1 ] <NEWLINE> ans += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> P = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> num = P [ 0 ] <NEWLINE> count = 1 <NEWLINE> <NL> for i in range ( 1 , n ) : <NEWLINE> <INDENT> if num >= P [ i ] : <NEWLINE> <INDENT> count += 1 <NEWLINE> num = P [ i ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> P = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> cnt = 1 <NEWLINE> <NL> if N == 1 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> elif N == 2 : <NEWLINE> <INDENT> if P [ 1 ] < P [ 0 ] : <NEWLINE> <INDENT> print ( 2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> tmp = P [ i - 2 ] <NEWLINE> for i in range ( 2 , N ) : <NEWLINE> <INDENT> if P [ i ] < min ( P [ i - 1 ] , tmp ) : <NEWLINE> <INDENT> tmp = min ( P [ i - 1 ] , tmp ) <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> P = list ( map ( lambda p : int ( p ) , input ( ) . split ( <STRING> ) ) ) <NEWLINE> left_min = P [ 0 ] <NEWLINE> cnt = 0 <NEWLINE> for i in range ( P ) : <NEWLINE> <INDENT> if left_min >= P [ i ] : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> left_min = P [ i ] <NEWLINE> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> l = [ 0 ] * 10 <NEWLINE> <NL> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> if str ( i [ 0 ] ) == str ( i [ - 1 ] ) : <NEWLINE> <INDENT> l [ int ( str ( i [ 0 ] ) ) ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for i in range ( l ) : <NEWLINE> <INDENT> ans += i * i <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> <NL> num = [ [ 0 ] * 10 for _ in range ( 10 ) ] <NEWLINE> <NL> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> top = int ( str ( i ) [ 0 ] ) <NEWLINE> end = int ( str ( i ) [ - 1 ] ) <NEWLINE> num [ top ] [ end ] += 1 <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in range ( 10 ) : <NEWLINE> <INDENT> for j in range ( 10 ) : <NEWLINE> <INDENT> count += num [ i ] [ j ] * num [ j ] [ i ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
<INDENT> import math <NEWLINE> from functools import reduce <NEWLINE> <NL> def lcm_base ( x , y ) : <NEWLINE> <INDENT> return ( x * y ) // math . gcd ( x , y ) <NEWLINE> <NL> <DEDENT> def lcm_list ( numbers ) : <NEWLINE> <INDENT> return reduce ( lcm_base , numbers , 1 ) <NEWLINE> <NL> <DEDENT> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> <NL> lcm = lcm_list ( A ) <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> ans += lcm // A [ i ] <NEWLINE> <NL> <DEDENT> print ( ans % 1000000007 ) <NEWLINE> <DEDENT>
from fractions import gcd <NEWLINE> <NL> <NL> def lcm ( x , y ) : <NEWLINE> <INDENT> return ( x * y ) // gcd ( x , y ) <NEWLINE> <NL> <NL> <DEDENT> MOD = 1000000007 <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> <NL> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> lcm_ = 1 <NEWLINE> for a in A : <NEWLINE> <INDENT> lcm_ = lcm ( lcm_ , a ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for a in A : <NEWLINE> <INDENT> ans += lcm_ / a <NEWLINE> <NL> <DEDENT> ans %= MOD <NEWLINE> print ( int ( ans ) ) <NEWLINE>
h , w , m = map ( int , input ( ) . split ( ) ) <NEWLINE> total = 0 <NEWLINE> if h < w : <NEWLINE> <INDENT> h , w = w , h <NEWLINE> <DEDENT> for i in range ( w ) : <NEWLINE> <INDENT> total += h <NEWLINE> if total >= m : <NEWLINE> <INDENT> print ( i + 1 ) <NEWLINE> <DEDENT> <DEDENT>
import math <NEWLINE> h , w , n = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( math . ceil ( n / max ( h , w ) ) ) <NEWLINE>
a , b , n = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( n // a + 1 if a >= b else n // b + 1 ) <NEWLINE>
<INDENT> p = sorted ( [ ( a + b , a - b ) for a , b in zip ( x , l ) ] ) <NEWLINE> _ , th = p [ 0 ] <NEWLINE> best = 0 <NEWLINE> for t , s in p : <NEWLINE> <INDENT> if th <= s : <NEWLINE> <INDENT> best += 1 <NEWLINE> th = t <NEWLINE> <DEDENT> <DEDENT> return best <NEWLINE> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> x = [ 0 ] * n <NEWLINE> l = [ 0 ] * n <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> x [ i ] , l [ i ] = map ( int , input ( ) . split ( ) ) <NEWLINE> <DEDENT> print ( solve ( n , x , l ) ) <NEWLINE>
from collections import deque <NEWLINE> n = int ( input ( ) ) <NEWLINE> cou = n <NEWLINE> l_h = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> x , l = map ( int , input ( ) . split ( ) ) <NEWLINE> l_h . append ( [ x - l , x + l ] ) <NEWLINE> <DEDENT> l_h . sort ( key = lambda x : x [ 1 ] ) <NEWLINE> d = deque ( l_h ) <NEWLINE> t = d . popleft ( ) <NEWLINE> a , b = t [ 0 ] , t [ 1 ] <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> m = d . popleft ( ) <NEWLINE> c , e = m [ 0 ] , m [ 1 ] <NEWLINE> if b <= c : <NEWLINE> <INDENT> b = d <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cou -= 1 <NEWLINE> <DEDENT> <DEDENT> print ( cou ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> se = [ ( ) ] * N <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> x , l = map ( int , input ( ) . split ( ) ) <NEWLINE> se [ i ] = ( x - l , x + l ) <NEWLINE> <DEDENT> se = sorted ( se , key = lambda x : x [ 1 ] ) <NEWLINE> ans = N <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> if se [ i - 1 ] [ 1 ] > se [ i ] [ 0 ] : <NEWLINE> <INDENT> se [ i ] [ 1 ] = se [ i - 1 ] [ 1 ] <NEWLINE> ans -= 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> diff = [ 0 ] * N <NEWLINE> neg = [ ] <NEWLINE> pos = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> diff [ i ] = A [ i ] - B [ i ] <NEWLINE> if diff [ i ] < 0 : <NEWLINE> <INDENT> neg . append ( diff [ i ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> pos . append ( diff [ i ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> if sum ( diff ) < 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( 0 ) <NEWLINE> <NL> <DEDENT> tobe_supplied = sum ( neg ) <NEWLINE> pos . sort ( reverse = True ) <NEWLINE> <NL> cnt = len ( neg ) <NEWLINE> <NL> for p in pos : <NEWLINE> <INDENT> if tobe_supplied >= 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> cnt += 1 <NEWLINE> tobe_supplied += p <NEWLINE> <NL> <DEDENT> print ( cnt ) <NEWLINE>
N , K , S = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = [ S if i <= K - 1 else 1 for i in range ( N ) ] <NEWLINE> print ( <STRING> . join ( ans ) ) <NEWLINE>
N , K , S = map ( int , input ( ) . split ( ) ) <NEWLINE> L = [ S ] * K <NEWLINE> for i in range ( N - K ) : <NEWLINE> <INDENT> if S < 10 ** 9 : <NEWLINE> <INDENT> L . append ( S + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> L . append ( 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> . join ( map ( int , L ) ) ) <NEWLINE>
n , k , s = map ( int , input ( ) . split ( ) ) <NEWLINE> x = [ 0 ] * n <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> x [ i ] = s <NEWLINE> <DEDENT> if s == 1000000000 : <NEWLINE> <INDENT> for i in range ( k , n + 1 ) : <NEWLINE> <INDENT> x [ i ] = s - 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( k , n + 1 ) : <NEWLINE> <INDENT> x [ i ] = s + 1 <NEWLINE> <DEDENT> <DEDENT> for i in x : <NEWLINE> <INDENT> print ( i , end = <STRING> ) <NEWLINE> <DEDENT>
N , K , S = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = [ ] <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> if i < K : <NEWLINE> <INDENT> ans . append ( S ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans . append ( S + 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> . join ( ans ) ) <NEWLINE>
nput ( ) <NEWLINE> if x == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> if x == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> if x == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> if x == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> if x == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> if x == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> if x == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> if x == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> if x == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> if x == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> if x == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> if x == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> if x == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> if x == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> if x == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> if x == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> if x == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> if x == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> if x == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> if x == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> if x == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> if x == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> if x == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> if x == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> if x == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
alphabet = [ a , b , c , d , e , f , g , h , i , j , k , l , m , n , o , p , q , r , s , t , u , v , w , x , y , z ] <NEWLINE> C = input ( ) <NEWLINE> idx = alphabet . index ( C ) <NEWLINE> print ( alphabet [ idx + 1 ] ) <NEWLINE>
s = input ( ) <NEWLINE> st = <STRING> <NEWLINE> print ( st [ index ( s ) + 1 ] ) <NEWLINE>
letter = ord ( input ( ) ) <NEWLINE> print ( chr ( c + 1 ) ) <NEWLINE>
a = input ( ) <NEWLINE> print ( a + 1 ) <NEWLINE>
C = input ( ) <NEWLINE> <NL> ary = <STRING> . split ( <STRING> ) <NEWLINE> <NL> print ( ary [ ary . index ( C ) + 1 ] ) <NEWLINE>
print ( chr ( ord ( ( input ( ) ) + 1 ) ) <NEWLINE>
c = input ( ) <NEWLINE> print ( c + 1 ) <NEWLINE>
c = input ( ) <NEWLINE> <NL> l = [ chi ( i ) for i in range ( 65 , 91 ) ] <NEWLINE> print ( l [ l . index ( c ) + 1 ] ) <NEWLINE>
C = input ( ) <NEWLINE> <NL> print ( char ( ord ( C ) + 1 ) ) <NEWLINE>
from strings import ascii_lowercase as lc <NEWLINE> given = input ( ) <NEWLINE> print ( lc [ lc . index ( given ) + 1 ] ) <NEWLINE>
c = input ( ) <NEWLINE> alp = <STRING> <NEWLINE> for i in range ( 25 ) : <NEWLINE> <INDENT> if c == alp [ i ] : <NEWLINE> <INDENT> print ( alh [ i + 1 ] ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT>
print ( chr ( ord ( int ( input ( ) ) ) + 1 ) ) <NEWLINE>
print ( char ( ord ( input ( ) ) + 1 ) ) <NEWLINE>
I = <STRING> <NEWLINE> for i in range ( 25 ) : <NEWLINE> <INDENT> if I [ i ] == input ( ) : <NEWLINE> <INDENT> print ( I [ i + 1 ] ) <NEWLINE> <DEDENT> <DEDENT>
s = input ( ) <NEWLINE> list_S = [ <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> for i in list_s : <NEWLINE> <INDENT> if list_s [ i ] == s : <NEWLINE> <INDENT> print ( list_s [ i + 1 ] ) <NEWLINE> <DEDENT> <DEDENT>
c = int ( input ( ) ) <NEWLINE> C = ord ( c ) <NEWLINE> print ( chr ( C ) ) <NEWLINE>
c = input ( ) <NEWLINE> s = list ( <STRING> ) <NEWLINE> <NL> for i in s : <NEWLINE> <INDENT> if c == s [ i ] : <NEWLINE> <INDENT> print ( s [ i + 1 ] ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT>
from collections import deque <NEWLINE> <NL> H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> S = [ list ( input ( ) ) for _ in range ( H ) ] <NEWLINE> <NL> dir = [ ( - 1 , 0 ) , ( 1 , 0 ) , ( 0 , - 1 ) , ( 0 , 1 ) ] <NEWLINE> <NL> dist = [ [ - 1 ] * W for _ in range ( H ) ] <NEWLINE> <NL> def BFS ( y , x ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> que = deque ( ) <NEWLINE> que . append ( ( y , x ) ) <NEWLINE> dist [ y ] [ x ] = 0 <NEWLINE> max_dist = 0 <NEWLINE> while que : <NEWLINE> <INDENT> sy , sx = que . popleft ( ) <COMMENT> <NEWLINE> for dy , dx in dir : <NEWLINE> <INDENT> ny = sy + dy <NEWLINE> nx = sx + dx <NEWLINE> if 0 <= ny < H and 0 <= nx < W and S [ ny ] [ nx ] != <STRING> and dist [ ny ] [ nx ] == - 1 : <NEWLINE> <INDENT> que . append ( ( ny , nx ) ) <NEWLINE> dist [ ny ] [ nx ] = dist [ sy ] [ sx ] + 1 <NEWLINE> max_dist = max ( max_dist , dist [ ny ] [ nx ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> return max_dist <NEWLINE> <NL> <DEDENT> max_dist = 0 <NEWLINE> for sy in range ( H ) : <NEWLINE> <INDENT> for sx in range ( W ) : <NEWLINE> <INDENT> if S [ sy ] [ sx ] != <STRING> : <NEWLINE> <INDENT> dist = [ [ - 1 ] * W for _ in range ( H ) ] <NEWLINE> max_dist = max ( max_dist , BFS ( sy , sx ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( max_dist ) <NEWLINE>
import sys <NEWLINE> <NL> <NL> def resolve ( in_ ) : <NEWLINE> <INDENT> N , M = map ( int , next ( in_ ) . split ( ) ) <NEWLINE> PS = tuple ( line . strip ( ) . split ( ) for line in in_ ) <NEWLINE> <NL> ac = set ( ) <NEWLINE> wa = { } <NEWLINE> <NL> for p , s in PS : <NEWLINE> <INDENT> if s == <STRING> : <NEWLINE> <INDENT> ac . add ( p ) <NEWLINE> <DEDENT> if s == <STRING> and p not in ac : <NEWLINE> <INDENT> wa [ p ] = wa . setdefault ( p , 0 ) + 1 <NEWLINE> <NL> <DEDENT> <DEDENT> penalties = 0 <NEWLINE> for k , v in wa . items : <NEWLINE> <INDENT> if k in ac : <NEWLINE> <INDENT> penalties += v <NEWLINE> <NL> <DEDENT> <DEDENT> return <STRING> . format ( len ( ac ) , penalties ) <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> answer = resolve ( sys . stdin ) <NEWLINE> print ( answer ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> l1 = [ 0 ] * n <NEWLINE> l2 = [ 0 ] * n <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> p , s = map ( str , input ( ) . split ( ) ) <NEWLINE> p = int ( p ) <NEWLINE> if s == <STRING> : <NEWLINE> <INDENT> if l2 [ p - 1 ] == 0 : <NEWLINE> <INDENT> l2 [ p - 1 ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if l2 [ p - 1 ] == 0 : <NEWLINE> <INDENT> l1 [ p - 1 ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> <DEDENT> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> if l2 [ i ] == 0 : <NEWLINE> <INDENT> l1 [ i ] == 0 : <NEWLINE> <NL> <DEDENT> <DEDENT> print ( sum ( l2 ) , sum ( l1 ) ) <NEWLINE>
from collections import defaultdict <NEWLINE> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> AC_List = defaultdict ( int ) <NEWLINE> WA_List = defaultdict ( int ) <NEWLINE> <NL> for i in range ( M ) : <NEWLINE> <INDENT> Num , Sta = map ( str , input ( ) . split ( ) ) <NEWLINE> if Num in AC_List : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if Sta == <STRING> : <NEWLINE> <INDENT> WA_List [ Num ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> AC_List [ Num ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> ansct = 0 <NEWLINE> for k , v in WA_List : <NEWLINE> <INDENT> if k in AC_List : <NEWLINE> <INDENT> ansct += v <NEWLINE> <NL> <DEDENT> <DEDENT> print ( str ( len ( AC_List ) ) + <STRING> + str ( ansct ) ) <NEWLINE> <NL>
import collections <NEWLINE> <NL> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> list_ac = set ( ) <NEWLINE> dic = collections . defaultdict ( lambda : 0 ) <NEWLINE> <NL> ac = 0 <NEWLINE> wa = 0 <NEWLINE> <NL> for _ in range ( m ) : <NEWLINE> <INDENT> p , s = input ( ) . split ( ) <NEWLINE> if s == <STRING> and p not in list_ac : <NEWLINE> <INDENT> dic [ p ] += 1 <NEWLINE> <DEDENT> elif s == <STRING> and p not in list_ac : <NEWLINE> <INDENT> list_ac . append ( p ) <NEWLINE> ac += 1 <NEWLINE> if p in dic : <NEWLINE> <INDENT> wa += dic [ p ] <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ac , wa ) <NEWLINE>
import sys <NEWLINE> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> p = [ list ( map ( str , input ( ) . split ( ) ) ) for _ in range ( m ) ] <NEWLINE> box = [ ] <NEWLINE> acnt , wcnt , tmp = 0 , 0 , 0 <NEWLINE> if m == 0 : <NEWLINE> <INDENT> print ( 0 , 0 ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> inx = 0 <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> if p [ i ] [ 0 ] != inx <NEWLINE> <INDENT> if p [ i ] [ 1 ] == <STRING> : <NEWLINE> <INDENT> inx = p [ i ] [ 0 ] <NEWLINE> acnt += 1 <NEWLINE> wcnt += tmp <NEWLINE> tmp = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> tmp += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( acnt , wcnt ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> L = [ list ( input ( ) . split ( ) ) for i in range ( M ) ] <NEWLINE> W = [ 0 ] * N <NEWLINE> A = [ 0 ] * N <NEWLINE> a = 0 <NEWLINE> w = 0 <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> if L [ i ] [ 1 ] == <STRING> : <NEWLINE> <INDENT> A [ int ( L [ i ] [ 0 ] ) - 1 ] = 1 <NEWLINE> <NL> <DEDENT> elif L [ i ] [ 1 ] == <STRING> and A [ int ( L [ i ] [ 0 ] ) - 1 ] == 0 : <NEWLINE> <INDENT> W [ int ( L [ i ] [ 0 ] ) - 1 ] += 1 <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> if A [ i ] > 0 : <NEWLINE> <INDENT> a += 1 <NEWLINE> w += W [ i ] <NEWLINE> <DEDENT> <DEDENT> print ( a , w ) <NEWLINE> <NL>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> ac = [ False ] * N <NEWLINE> wa_cnt = [ 0 ] * N <NEWLINE> ac_cnt = 0 <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> p , s = input ( ) . split ( ) <NEWLINE> p_i = int ( p ) - 1 <NEWLINE> if s == <STRING> : <NEWLINE> <INDENT> if not ac [ p_i ] : <NEWLINE> <INDENT> wa_cnt [ p_i ] += 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if not ac [ p_i ] : <NEWLINE> <INDENT> ac [ p_i ] = True <NEWLINE> ac_cnt += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> wa_cnt_sum = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if ac_cnt [ i ] : <NEWLINE> <INDENT> wa_cnt_sum += wa_cnt [ i ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ac_cnt , wa_cnt_sum ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> l = [ 0 ] * ( n + 1 ) <NEWLINE> miss = [ 0 ] * ( n + 1 ) <NEWLINE> for _ in range ( m ) : <NEWLINE> <INDENT> p , s = input ( ) . split ( ) <NEWLINE> p = int ( p ) <NEWLINE> if l [ p ] == 0 : <NEWLINE> <INDENT> if s == <STRING> : <NEWLINE> <INDENT> l [ p ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> miss [ p ] += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> for i in range ( m ) : <NEWLINE> <INDENT> if l [ i ] == 0 and miss [ i ] != 0 : <NEWLINE> <INDENT> miss [ i ] = 0 <NEWLINE> <DEDENT> <DEDENT> a = l . count ( 1 ) <NEWLINE> b = sum ( miss ) <NEWLINE> print ( a , b ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> ans_num_lis = [ 0 for i in range ( N ) ] <NEWLINE> pre_ans_lis = [ 0 for i in range ( N ) ] <NEWLINE> ans_lis = [ 0 for i in range ( N ) ] <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> problem , result = input ( ) . split ( ) <NEWLINE> problem_num = int ( problem ) <NEWLINE> if result == <STRING> : <NEWLINE> <INDENT> pre_ans_lis [ problem_num ] += 1 <NEWLINE> <DEDENT> if result == <STRING> and not ans_num_lis [ problem_num ] : <NEWLINE> <INDENT> ans_num_lis [ problem_num ] = 1 <NEWLINE> ans_lis [ problem_num ] = pre_ans_lis [ problem_num ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( sum ( ans_num_lis ) , sum ( ans_lis ) ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> ps = [ input ( ) . split ( ) for _ in range ( M ) ] <NEWLINE> <NL> correct = [ 0 ] * N <NEWLINE> penalty = [ 0 ] * N <NEWLINE> for p , s in ps : <NEWLINE> <INDENT> p = int ( p ) <NEWLINE> if correct [ p - 1 ] == 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if s == <STRING> : <NEWLINE> <INDENT> correct [ p - 1 ] = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> penalty [ p - 1 ] += 1 <NEWLINE> <DEDENT> <DEDENT> print ( sum ( correct ) , sum ( [ p * c for p , c in zip ( penalty , correct ) ] ) ) ) ) <NEWLINE> <NL>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> ac = [ 0 ] * ( n + 1 ) <NEWLINE> wa = 0 <NEWLINE> for i in range ( m + 1 ) : <NEWLINE> <INDENT> p , c = input ( ) . split ( ) <NEWLINE> if c == <STRING> and ac [ int ( p ) ] == 0 : <NEWLINE> <INDENT> ac [ int ( p ) ] = 1 <NEWLINE> <DEDENT> elif c == <STRING> and ac [ int ( p ) ] == 0 : <NEWLINE> <INDENT> wa += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ac . count ( 1 ) , wa ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> wa = 0 <NEWLINE> ac = 0 <NEWLINE> check = [ 0 ] * n <NEWLINE> for _ in range ( m ) : <NEWLINE> <INDENT> a , b = input ( ) . split ( ) <NEWLINE> i = int ( a ) <NEWLINE> if check [ i ] == 0 : <NEWLINE> <INDENT> if b == <STRING> : <NEWLINE> <INDENT> wa += 1 <NEWLINE> <DEDENT> elif b == <STRING> : <NEWLINE> <INDENT> ac += 1 <NEWLINE> check [ i ] = 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ac , wa ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> lis = [ list ( input ( ) . split ( ) ) for _ in range ( m ) ] <NEWLINE> <NL> dp = [ [ 0 for _ in range ( 2 ) ] for _ in range ( n ) ] <COMMENT> <NEWLINE> <NL> for i in range ( m ) : <NEWLINE> <INDENT> if dp [ i ] [ 0 ] == 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if lis [ i ] [ 1 ] == <STRING> : <NEWLINE> <INDENT> dp [ int ( lis [ i ] [ 0 ] ) ] [ 1 ] += 1 <NEWLINE> <DEDENT> if lis [ i ] [ 1 ] == <STRING> : <NEWLINE> <INDENT> dp [ int ( lis [ i ] [ 0 ] ) ] [ 0 ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> ac = 0 <NEWLINE> wa = 0 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> if dp [ i ] [ 0 ] == 1 : <NEWLINE> <INDENT> ac += 1 <NEWLINE> wa += dp [ i ] [ 1 ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ac , wa ) <NEWLINE>
import sys <NEWLINE> read = sys . stdin . buffer . read <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> readlines = sys . stdin . buffer . readlines <NEWLINE> <NL> n , m = map ( int , readline ( ) . split ( ) ) <NEWLINE> <COMMENT> <NL> <NL> acCount = 0 <NEWLINE> waCount = 0 <NEWLINE> check = [ 0 ] * n <NEWLINE> waCheck = [ 0 ] * n <NEWLINE> <NL> for i in range ( m ) : <NEWLINE> <INDENT> p , s = map ( str , input ( ) . split ( ) ) <NEWLINE> <COMMENT> <NL> p = int ( p ) <NEWLINE> if ( check [ p - 1 ] == 0 ) : <NEWLINE> <INDENT> if ( s == <STRING> ) : <NEWLINE> <INDENT> waCheck [ p - 1 ] += 1 <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> acCount += 1 <NEWLINE> waCheck += waCheck [ p - 1 ] <NEWLINE> <NL> check [ p - 1 ] = 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <DEDENT> <DEDENT> print ( acCount , waCount ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> if m == 0 : <NEWLINE> <INDENT> print ( 0 , 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> AC = [ 0 ] * n + 1 <NEWLINE> WA = [ 0 ] * n + 1 <NEWLINE> <NL> for i in range ( m ) : <NEWLINE> <INDENT> p , s = map ( str , input ( ) . split ( ) ) <NEWLINE> if s == <STRING> : <NEWLINE> <INDENT> AC [ int ( p ) ] += 1 <NEWLINE> <DEDENT> elif s == <STRING> and AC [ int ( p ) ] == 0 : <NEWLINE> <INDENT> WA [ int ( p ) ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( n + 1 ) : <NEWLINE> <INDENT> if AC [ i ] == 0 : <NEWLINE> <INDENT> WA [ i ] = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> cnt = AC . count ( 0 ) <NEWLINE> answer = len ( AC ) - cnt <NEWLINE> ans = sum ( WA ) <NEWLINE> print ( answer , ans ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> p = [ ] <NEWLINE> S = [ ] <NEWLINE> for _ in range ( M ) : <NEWLINE> <INDENT> a , b = input ( ) . split ( ) <NEWLINE> p . append ( int ( a ) ) <NEWLINE> S . append ( b ) <NEWLINE> <NL> <DEDENT> ans = [ [ ] for i in range ( N ) ] <NEWLINE> WA , AC = 0 , 0 <NEWLINE> for p , S in zip ( p , S ) : <NEWLINE> <INDENT> if ans [ p - 1 ] . count ( <STRING> ) != 0 : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans [ p - 1 ] . append ( S ) <NEWLINE> if S == <STRING> : <NEWLINE> <INDENT> WA += 1 <NEWLINE> <DEDENT> if S == <STRING> <NEWLINE> <INDENT> AC += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( AC , WA ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> p = [ ] <NEWLINE> s = [ ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> p_i , s_i = input ( ) . split ( ) <NEWLINE> p . append ( int ( p_i ) ) <NEWLINE> s . append ( b ) <NEWLINE> <NL> <NL> <DEDENT> res = [ 0 ] * n <NEWLINE> correct = 0 <NEWLINE> penalty = 0 <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> no = p [ i ] - 1 <NEWLINE> if res [ no ] == 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> elif s [ i ] == <STRING> : <NEWLINE> <INDENT> penalty += 1 <NEWLINE> <DEDENT> elif s [ i ] == <STRING> : <NEWLINE> <INDENT> correct += 1 <NEWLINE> res [ no ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( correct , penalty ) <NEWLINE>
<INDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <DEDENT> AC = [ 0 ] * n <NEWLINE> WA = [ 0 ] * n <NEWLINE> <NL> for i in range ( m ) : <NEWLINE> <INDENT> t = input ( ) . split ( ) <NEWLINE> p , s = int ( t [ 0 ] ) , t [ 1 ] <NEWLINE> if s == <STRING> : <NEWLINE> <INDENT> AC [ p - 1 ] = 1 <NEWLINE> <DEDENT> elif s == <STRING> and AC [ p - 1 ] == 0 : <NEWLINE> <INDENT> WA [ p - 1 ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> ac , wa = 0 , 0 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> if AC [ i ] : <NEWLINE> <INDENT> ac += 1 <NEWLINE> wa += WA [ i ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ac , wa ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ input ( ) . split for i in range ( M ) ] <NEWLINE> cac = 0 <NEWLINE> cwa = 0 <NEWLINE> <NL> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> for a in A : <NEWLINE> <INDENT> while a [ 0 ] == str ( i ) : <NEWLINE> <INDENT> if a [ 1 ] == <STRING> : <NEWLINE> <INDENT> cwa += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cac += 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> while a [ 0 ] == str ( i ) : <NEWLINE> <INDENT> A . remove ( a ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( cac , cwa ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> ac_cnt = set ( ) <NEWLINE> wa_cnt = 0 <NEWLINE> penalty = [ 0 ] * n <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> p , s = input ( ) . split ( ) <NEWLINE> num = p - 1 <NEWLINE> if num not in ac_cnt : <NEWLINE> <INDENT> if s == <STRING> : <NEWLINE> <INDENT> ac_cnt . add ( num ) <NEWLINE> wa_cnt += penalty [ num ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> penalty [ num ] += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( len ( set ( ac_cnt ) ) , wa_cnt ) <NEWLINE>
def resolve ( ) : <NEWLINE> <INDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> ac_list = [ 1 ] * n <NEWLINE> ac = 0 <NEWLINE> wa = 0 <NEWLINE> for _ in range ( m ) : <NEWLINE> <INDENT> p , s = input ( ) . split ( ) <NEWLINE> if s == <STRING> and ac_list [ int ( p ) - 1 ] == 1 : <NEWLINE> <INDENT> wa += 1 <NEWLINE> <DEDENT> elif s == <STRING> and ac_list [ int ( p ) - 1 ] == 1 : <NEWLINE> <INDENT> ac += 1 <NEWLINE> ac_list [ int ( p ) - 1 ] = 0 <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> <DEDENT> resolve ( ) : <NEWLINE>
N , M , * PS = open ( 0 ) . read ( ) . split ( ) <NEWLINE> N , M = [ int ( _ ) for _ in [ N , M ] ] <NEWLINE> cor = [ 0 ] * ( N + 1 ) <NEWLINE> pen = [ 0 ] * ( N + 1 ) <NEWLINE> for p , s in PS : <NEWLINE> <INDENT> p = int ( p ) <NEWLINE> if cor [ p ] == 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if s == <STRING> : <NEWLINE> <INDENT> cor [ p ] = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> pen [ p ] += 1 <NEWLINE> <DEDENT> <DEDENT> ans = [ 0 , 0 ] <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> if cor [ p ] == 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> ans [ 0 ] += 1 <NEWLINE> ans [ 1 ] += pen [ @ ] <NEWLINE> <DEDENT> print ( * ans ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> l = [ list ( input ( ) . split ( ) ) for i in range ( m ) ] <NEWLINE> cnt = 0 <NEWLINE> ans = [ 0 ] * n <NEWLINE> num = 0 <NEWLINE> for i in range ( 0 , m ) : <NEWLINE> <INDENT> num = int ( l [ i ] [ 0 ] ) <NEWLINE> if l [ i ] [ 1 ] == <STRING> : <NEWLINE> <INDENT> ans [ num ] = 1 <NEWLINE> <DEDENT> elif ans [ num ] != 1 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> print ( sum ( ans ) , cnt ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> acs = [ 0 for i in range ( N ) ] <NEWLINE> wa = [ 0 for i in range ( N ) ] <NEWLINE> <NL> for i in range ( M ) : <NEWLINE> <INDENT> p , S = map ( str , input ( ) . split ( ) ) <NEWLINE> p = int ( p ) <NEWLINE> if S == <STRING> : <NEWLINE> <INDENT> acs [ p - 1 ] = 1 <NEWLINE> <DEDENT> elif S == <STRING> and acs [ p - 1 ] == 0 : <NEWLINE> <INDENT> wa [ p - 1 ] += 1 <NEWLINE> <DEDENT> <DEDENT> for i in range ( M ) : <NEWLINE> <INDENT> if acs [ i ] == 0 : <NEWLINE> <INDENT> wa [ i ] = 0 <NEWLINE> <DEDENT> <DEDENT> ans = [ sum ( acs ) , sum ( wa ) ] <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> judge = [ False ] * N <NEWLINE> WAcnt = [ 0 ] * N <NEWLINE> ACcnt = 0 <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> p , S = ( x for x in input ( ) . split ( ) ) <NEWLINE> p = int ( p ) <NEWLINE> if judge [ p - 1 ] == False : <NEWLINE> <INDENT> if S == <STRING> : <NEWLINE> <INDENT> judge [ p - 1 ] = True <NEWLINE> ACcnt += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> WAcnt [ p - 1 ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> WAans = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if judge [ i ] == True : <NEWLINE> <INDENT> WAans += WAans [ i ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ACcnt , WAans ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> ac = 0 <NEWLINE> is_AC = [ False ] * ( 10 ** 5 ) + 1 <NEWLINE> WA_cnt = [ 0 ] * ( 10 ** 5 ) + 1 <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> p , s = input ( ) . split ( ) <NEWLINE> p = int ( p ) <NEWLINE> if s == <STRING> : <NEWLINE> <INDENT> if is_AC [ p ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> WA_cnt [ p ] += 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if is_AC [ p ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> is_AC [ p ] = True <NEWLINE> ac += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ac , sum ( WA_cnt ) ) <NEWLINE> <NL>
from copy import deepcopy <NEWLINE> <COMMENT> <NL> import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> H , W = ( int ( i ) for i in input ( ) . split ( ) ) <NEWLINE> map_initial = [ [ <STRING> ] * ( W + 2 ) for i in range ( H + 2 ) ] <COMMENT> <NEWLINE> for h in range ( 1 , H + 1 ) : <NEWLINE> <INDENT> map_initial [ h ] = [ <STRING> ] + list ( input ( ) . strip ( ) ) + [ <STRING> ] <NEWLINE> <NL> <DEDENT> def BSF ( x , y ) : <NEWLINE> <INDENT> dist = 0 <NEWLINE> map = deepcopy ( map_initial ) <NEWLINE> if map [ x ] [ y ] == <STRING> : <NEWLINE> <INDENT> return dist <NEWLINE> <DEDENT> dq = deque ( ) <NEWLINE> dq . append ( ( x , y ) ) <NEWLINE> dq_sarch = deque ( ) <NEWLINE> while len ( dq ) > 0 : <NEWLINE> <INDENT> h , w = dq . popleft ( ) <NEWLINE> map [ h ] [ w ] = <STRING> <COMMENT> <NEWLINE> if map [ h + 1 ] [ w ] == <STRING> : <NEWLINE> <INDENT> dq_sarch . append ( ( h + 1 , w ) ) <NEWLINE> <DEDENT> if map [ h - 1 ] [ w ] == <STRING> : <NEWLINE> <INDENT> dq_sarch . append ( ( h - 1 , w ) ) <NEWLINE> <DEDENT> if map [ h ] [ w + 1 ] == <STRING> : <NEWLINE> <INDENT> dq_sarch . append ( ( h , w + 1 ) ) <NEWLINE> <DEDENT> if map [ h ] [ w - 1 ] == <STRING> : <NEWLINE> <INDENT> dq_sarch . append ( ( h , w - 1 ) ) <NEWLINE> <DEDENT> if len ( dq ) == 0 : <NEWLINE> <INDENT> dq = deepcopy ( dq_sarch ) <NEWLINE> dq_sarch . clear ( ) <NEWLINE> dist += 1 <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> return dist - 1 <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> dist_all = [ ] <NEWLINE> for i in range ( 1 , H + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , W + 1 ) : <NEWLINE> <INDENT> dist_all . append ( BSF ( i , j ) ) <NEWLINE> <DEDENT> <DEDENT> print ( max ( dist_all ) ) <NEWLINE>
from sys import stdin <NEWLINE> nii = lambda : map ( int , stdin . readline ( ) . split ( ) ) <NEWLINE> lnii = lambda : list ( map ( int , stdin . readline ( ) . split ( ) ) ) <NEWLINE> from copy import deepcopy <NEWLINE> from collections import deque <NEWLINE> <NL> h , w = nii ( ) <NEWLINE> s = [ list ( input ( ) ) for i in range ( h ) ] <NEWLINE> <NL> def dfs ( cs , i , j ) : <NEWLINE> <INDENT> que = deque ( ) <NEWLINE> que . append ( [ i , j ] ) <NEWLINE> <NL> cs [ i ] [ j ] = <STRING> <NEWLINE> <NL> dist = [ [ - 1 for a in range ( w ) ] for b in range ( h ) ] <NEWLINE> dist [ i ] [ j ] = 0 <NEWLINE> <NL> while que : <NEWLINE> <INDENT> y , x = que . popleft ( ) <NEWLINE> for dy , dx in [ [ 1 , 0 ] , [ - 1 , 0 ] , [ 0 , 1 ] , [ 0 , - 1 ] ] : <NEWLINE> <INDENT> ny = y + dy <NEWLINE> nx = x + dx <NEWLINE> if 0 <= ny < h and 0 <= nx < w and cs [ ny ] [ nx ] == <STRING> : <NEWLINE> <INDENT> que . append ( [ ny , nx ] ) <NEWLINE> cs [ ny ] [ nx ] = <STRING> <NEWLINE> dist [ ny ] [ nx ] = dist [ y ] [ x ] + 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> t_ans = 0 <NEWLINE> for a in dist : <NEWLINE> <INDENT> t_ans = max ( t_ans , max ( a ) ) <NEWLINE> <NL> <DEDENT> return t_ans <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in range ( h ) : <NEWLINE> <INDENT> for j in range ( w ) : <NEWLINE> <INDENT> if s [ i ] [ j ] == <STRING> : <NEWLINE> <INDENT> cs = deepcopy ( s ) <NEWLINE> dist = dfs ( cs , i , j ) <NEWLINE> ans = max ( ans , dist ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <NL> <NL> from collections import deque <NEWLINE> <NL> <NL> <COMMENT> <NL> <NL> <NL> H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> S = [ ] <NEWLINE> for _ in range ( H ) : <NEWLINE> <INDENT> S . append ( input ( ) ) <NEWLINE> <NL> <NL> <COMMENT> <NL> <NL> <NL> <DEDENT> def bfs ( sx , sy ) : <NEWLINE> <INDENT> dx = [ 1 , 0 , - 1 , 0 ] <NEWLINE> dy = [ 0 , 1 , 0 , - 1 ] <NEWLINE> d = [ [ - 1 ] * W for _ in range ( H ) ] <NEWLINE> q = deque ( [ ] ) <NEWLINE> q . append ( [ sx , sy ] ) <NEWLINE> d [ sx ] [ sy ] = 0 <NEWLINE> ans = 0 <NEWLINE> while q : <NEWLINE> <INDENT> x , y = q . popleft ( ) <NEWLINE> for i in range ( 4 ) : <NEWLINE> <INDENT> nx = x + dx [ i ] <NEWLINE> ny = y + dy [ i ] <NEWLINE> if 0 <= nx < H and 0 <= ny < W and S [ nx ] [ ny ] != <STRING> and d [ nx ] [ ny ] == - 1 : <NEWLINE> <INDENT> q . append ( [ nx , ny ] ) <NEWLINE> d [ nx ] [ ny ] = d [ x ] [ y ] + 1 <NEWLINE> ans = max ( ans , d [ nx ] [ ny ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return ans <NEWLINE> <NL> <NL> <COMMENT> <NL> <NL> <NL> <DEDENT> for sh in range ( H ) : <NEWLINE> <INDENT> if <STRING> in S [ sh ] : <NEWLINE> <INDENT> for sw in range ( W ) : <NEWLINE> <INDENT> if S [ sh ] [ sw ] == <STRING> : <NEWLINE> <INDENT> ans = max ( ans , bfs ( sh , sw ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <COMMENT> <NL> <NL> <NL> <NL> <NL>
H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> S = [ ] <NEWLINE> for i in range ( H ) : <NEWLINE> <INDENT> S . append ( input ( ) ) <NEWLINE> <NL> <DEDENT> def bfs ( start ) : <NEWLINE> <INDENT> already = { } <NEWLINE> queue = [ ] <NEWLINE> counter = 0 <NEWLINE> queue . append ( ( start [ 0 ] , start [ 1 ] , 0 ) ) <NEWLINE> already ( start ) = True <NEWLINE> max_depth = 0 <NEWLINE> while counter < len ( queue ) : <NEWLINE> <INDENT> y , x , depth = queue [ counter ] <NEWLINE> if depth > max_depth : <NEWLINE> <INDENT> max_depth = depth <NEWLINE> <DEDENT> for move in ( ( - 1 , 0 ) , ( 0 , 1 ) , ( 1 , 0 ) , ( 0 , - 1 ) ) : <NEWLINE> <INDENT> new_y = y + move [ 0 ] <NEWLINE> new_x = x + move [ 1 ] <NEWLINE> if new_y >= 0 and new_y < H and new_x >= 0 and new_x < W and S [ new_y ] [ new_x ] == <STRING> and ( new_y , new_x ) not in already : <NEWLINE> <INDENT> already [ ( new_y , new_x ) ] = True <NEWLINE> queue . append ( ( new_y , new_x , depth + 1 ) ) <NEWLINE> <DEDENT> <DEDENT> counter += 1 <NEWLINE> <DEDENT> return max_depth <NEWLINE> <NL> <DEDENT> answer = 0 <NEWLINE> for i in range ( H ) : <NEWLINE> <INDENT> for j in range ( W ) : <NEWLINE> <INDENT> if S [ i ] [ j ] == <STRING> : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> depth = bfs ( ( i , j ) ) <NEWLINE> if answer < depth : <NEWLINE> <INDENT> answer = depth <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( answer ) <NEWLINE>
from collections import deque <NEWLINE> H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> S = [ list ( input ( ) ) for _ in range ( H ) ] <NEWLINE> A = [ [ 0 ] * W for _ in range ( H ) ] <NEWLINE> ans = [ ] <NEWLINE> <NL> for i in range ( H ) : <NEWLINE> <INDENT> for j in range ( W ) : <NEWLINE> <INDENT> c = 0 <NEWLINE> sy = i <NEWLINE> sx = j <NEWLINE> A [ i ] [ j ] = 1 <NEWLINE> route = deque ( [ ( sy , sx , 0 ) ] ) <NEWLINE> while route : <NEWLINE> <INDENT> a , b , n = route . popleft ( ) <NEWLINE> c = n <NEWLINE> if 0 <= a <= H - 1 and 0 <= b <= W - 1 : <NEWLINE> <INDENT> if S [ a ] [ b ] == <STRING> : <NEWLINE> <INDENT> S [ a ] [ b ] == <STRING> <NEWLINE> route . append ( ( a + 1 , b , n + 1 ) ) <NEWLINE> route . append ( ( a - 1 , b , n + 1 ) ) <NEWLINE> route . append ( ( a , b + 1 , n + 1 ) ) <NEWLINE> route . append ( ( a , b - 1 , n + 1 ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> ans . append ( c ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( max ( ans ) ) <NEWLINE>
from networkx import * <NEWLINE> _ , * s = open ( i : = 0 ) <NEWLINE> g = [ ] <NEWLINE> for t in s : <NEWLINE> <INDENT> i += 1 ; j = 0 <NEWLINE> for u in t : g += [ ( k : = i * 20 + j , k + 20 ) ] * ( u > <STRING> < ( s + [ <STRING> * k ] ) [ i ] [ j ] ) + [ ( k , k + 1 ) ] * ( u > <STRING> < t [ j : = j + 1 ] ) <NEWLINE> <DEDENT> print ( max ( t [ i ] for _ , t in shortest_path_length ( Graph ( g ) ) for i in t ) ) <NEWLINE>
def abc151d_maze_master ( ) : <NEWLINE> <INDENT> h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> s = [ ] <NEWLINE> max_val = 0 <NEWLINE> for i in range ( h ) : <NEWLINE> <INDENT> s . append ( input ( ) ) <NEWLINE> <DEDENT> for hi in range ( h ) : <NEWLINE> <INDENT> for wi in range ( w ) : <NEWLINE> <INDENT> if s [ hi ] [ wi ] == <STRING> : continue <NEWLINE> flg = [ [ - 1 ] * w for _ in range ( h ) ] <NEWLINE> flg [ hi ] [ wi ] = 0 <NEWLINE> q = [ ( 0 , hi , wi ) ] <NEWLINE> heapq . heapify ( q ) <NEWLINE> while len ( q ) > 0 : <NEWLINE> <INDENT> d , hj , wj = heapq . heappop ( q ) <NEWLINE> for dh , dw in zip ( [ 0 , 0 , 1 , - 1 ] , [ 1 , - 1 , 0 , 0 ] ) : <NEWLINE> <INDENT> if 0 <= hj + dh < h and 0 <= wj + dw < w and s [ hj + dh ] [ wj + dw ] != <STRING> and ( flg [ hj + dh ] [ wj + dw ] == - 1 or flg [ hj + dh ] [ wj + dw ] > flg [ hj ] [ wj ] + 1 ) : <NEWLINE> <INDENT> heapq . heappush ( q , ( d + 1 , hj + dh , wj + dw ) ) <NEWLINE> flg [ hj + dh ] [ wj + dw ] = flg [ hj ] [ wj ] + 1 <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> max_val = max ( max_val , max ( [ max ( v ) for v in flg ] ) ) <NEWLINE> <DEDENT> <DEDENT> print ( max_val ) <NEWLINE> <NL> <NL> <DEDENT> abc151d_maze_master ( ) <NEWLINE>
from collections import deque <NEWLINE> import numpy as np <NEWLINE> H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> Maze = [ list ( input ( ) ) for i in range ( H ) ] <NEWLINE> for hi in range ( 0 , H ) : <NEWLINE> <INDENT> for wi in range ( 0 , W ) : <NEWLINE> <INDENT> if Maze [ hi ] [ wi ] == <STRING> : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> maze1 = [ [ 0 ] * W for _ in range ( H ) ] <NEWLINE> stack = deque ( [ [ hi , wi ] ] ) <NEWLINE> while stack : <NEWLINE> <INDENT> h , w = stack . popleft ( ) <NEWLINE> for i , j in [ [ 1 , 0 ] , [ - 1 , 0 ] , [ 0 , 1 ] , [ 0 , - 1 ] ] : <NEWLINE> <INDENT> new_h , new_w = h + i , w + j <NEWLINE> if new_h < 0 or new_w < 0 or new_h >= H or new_w >= W : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> elif Maze [ new_h ] [ new_w ] != <STRING> and maze1 [ new_h ] [ new_w ] == 0 : <NEWLINE> <INDENT> maze1 [ new_h ] [ new_w ] = maze1 [ h ] [ w ] + 1 <NEWLINE> stack . append ( [ new_h , new_w ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> maze1 [ hi ] [ wi ] = 0 <NEWLINE> ans = max ( ans , np . max ( maze1 ) ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> grid = [ list ( input ( ) . split ( ) ) for _ in H ] <NEWLINE> res = 0 <NEWLINE> def bfs ( tup , visited ) : <NEWLINE> <INDENT> def helper ( tup , total ) : <NEWLINE> <INDENT> if tup in visited ( ) : <NEWLINE> <INDENT> res = max ( res , total ) <NEWLINE> <DEDENT> elif tup [ 0 ] >= H or tup [ 0 ] < 0 or tup [ 1 ] >= W or tup [ 1 ] < 0 or grid [ tup [ 0 ] ] [ tup [ 1 ] ] : <NEWLINE> <INDENT> res = max ( res , total ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> visited . add ( tup ) <NEWLINE> h , w = tup <NEWLINE> helper ( ( h + 1 , w ) , total + 1 ) <NEWLINE> helper ( ( h - 1 , w ) , total + 1 ) <NEWLINE> helper ( ( h , w - 1 ) , total + 1 ) <NEWLINE> helper ( ( h , w + 1 ) , total + 1 ) <NEWLINE> <DEDENT> <DEDENT> helper ( tup , 0 ) <NEWLINE> return res <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for h in H : <NEWLINE> <INDENT> for w in W : <NEWLINE> <INDENT> if grid [ h ] [ w ] == <STRING> : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> ans = max ( ans , bfs ( ( h , w ) , set ( ) ) ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> S = [ ] <NEWLINE> for i in range ( H ) : <NEWLINE> <INDENT> S . append ( str ( input ( ) ) ) <NEWLINE> <DEDENT> d = [ [ float ( <STRING> ) for i in range ( V ) ] for j in range ( V ) ] <NEWLINE> <NL>
import numpy as np <NEWLINE> import queue <NEWLINE> H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> S = list ( ) <NEWLINE> for m in range ( H ) : <NEWLINE> <INDENT> S . append ( input ( ) ) <NEWLINE> <DEDENT> ans = 0 <NEWLINE> i , j = 7 , 6 <NEWLINE> if S [ i ] [ j ] == <STRING> : <NEWLINE> <INDENT> L = [ [ - 1 ] * W for i in range ( H ) ] <NEWLINE> L [ i ] [ j ] = 0 <NEWLINE> q = queue . Queue ( ) <NEWLINE> q . put ( [ i , j ] ) <NEWLINE> while not q . empty ( ) : <NEWLINE> <INDENT> r = q . get ( ) <NEWLINE> for k , l in [ [ 1 , 0 ] , [ 0 , - 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] ] : <NEWLINE> <INDENT> if r [ 0 ] + k >= 0 and r [ 0 ] + k < H and r [ 1 ] + l >= 0 and r [ 1 ] + l < W and S [ r [ 0 ] + k ] [ r [ 1 ] + l ] == <STRING> and L [ r [ 0 ] + k ] [ r [ 1 ] + l ] == - 1 : <NEWLINE> <INDENT> L [ r [ 0 ] + k ] [ r [ 1 ] + l ] = L [ r [ 0 ] ] [ r [ 1 ] ] + 1 <NEWLINE> q . put ( [ r [ 0 ] + k , r [ 1 ] + l ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> ans = max ( ans , max ( list ( map ( lambda x : max ( x ) , L ) ) ) ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
from collections import deque <NEWLINE> <NL> H , W = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> <NL> field = [ ] <NEWLINE> for i in range ( H ) : <NEWLINE> <INDENT> field . append ( input ( ) ) <NEWLINE> <NL> <DEDENT> conn = [ [ [ ] for _ in range ( W ) ] for _ in range ( H ) ] <NEWLINE> for i in range ( H ) : <NEWLINE> <INDENT> for j in range ( W ) : <NEWLINE> <INDENT> if field [ i ] [ j ] == <STRING> : <NEWLINE> <INDENT> for e in [ [ - 1 , 0 ] , [ 1 , 0 ] , [ 0 , - 1 ] , [ 0 , 1 ] ] : <NEWLINE> <INDENT> h , w = i + e [ 0 ] , j + e [ 1 ] <NEWLINE> if 0 <= h < H and 0 <= w < W and field [ h ] [ w ] == <STRING> : <NEWLINE> <INDENT> conn [ i ] [ j ] . append ( [ h , w ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> d = 0 <NEWLINE> for i in range ( H ) : <NEWLINE> <INDENT> for j in range ( W ) : <NEWLINE> <INDENT> l = 0 <NEWLINE> q = deque ( [ [ i , j ] ] ) <NEWLINE> dist = [ [ - 1 for _ in range ( W ) ] for _ in range ( H ) ] <NEWLINE> dist [ i ] [ j ] = 0 <NEWLINE> while q : <NEWLINE> <INDENT> v = q . popleft ( ) <NEWLINE> for w in conn [ v [ 0 ] ] [ v [ 1 ] ] : <NEWLINE> <INDENT> if dist [ w [ 0 ] ] [ w [ 1 ] ] == - 1 : <NEWLINE> <INDENT> q . append ( w ) <NEWLINE> dist [ w [ 0 ] ] [ w [ 1 ] ] = dist [ v [ 0 ] ] [ v [ 1 ] ] + 1 <NEWLINE> l = dist [ w [ 0 ] ] [ w [ 1 ] ] <NEWLINE> <NL> d = max ( d , l ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( d ) <NEWLINE>
def prepare ( n , MOD ) : <NEWLINE> <INDENT> f = 1 <NEWLINE> factorials = [ 1 ] <NEWLINE> for m in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> f *= m <NEWLINE> f %= MOD <NEWLINE> factorials . append ( f ) <NEWLINE> <DEDENT> inv = pow ( f , MOD - 2 , MOD ) <NEWLINE> invs = [ 1 ] * ( n + 1 ) <NEWLINE> invs [ n ] = inv <NEWLINE> for m in range ( n , 1 , - 1 ) : <NEWLINE> <INDENT> inv *= m <NEWLINE> inv %= MOD <NEWLINE> invs [ m - 1 ] = inv <NEWLINE> <NL> <DEDENT> return factorials , invs <NEWLINE> <NL> <NL> <DEDENT> MOD = 10 ** 9 + 7 <NEWLINE> facts , invs = prepare ( n , MOD ) <NEWLINE> <NL> <NL> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> arr = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> arr . sort ( ) <NEWLINE> <NL> ans_max = 0 <NEWLINE> for i in range ( k - 1 , n ) : <NEWLINE> <INDENT> ans_max += ( arr [ i ] * facts [ i ] * invs [ k - 1 ] * invs [ i - k + 1 ] ) % MOD <NEWLINE> <NL> <DEDENT> arr . sort ( reverse = True ) <NEWLINE> <NL> ans_min = 0 <NEWLINE> for i in range ( k - 1 , n ) : <NEWLINE> <INDENT> ans_min += ( arr [ i ] * facts [ i ] * invs [ k - 1 ] * invs [ i - k + 1 ] ) % MOD <NEWLINE> <NL> <DEDENT> print ( ( ans_max - ans_min ) % MOD ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a . sort ( ) <NEWLINE> p = [ 1 ] <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> p . append ( p [ - 1 ] * ( i + 2 ) % mod ) <NEWLINE> <DEDENT> def comb ( n , k , mod ) : <NEWLINE> <INDENT> s = p [ n - 1 ] * pow ( fac ( k ) , mod - 2 , mod ) % mod <NEWLINE> s = s * pow ( fac ( n - k ) , mod - 2 , mod ) % mod <NEWLINE> return s <NEWLINE> <DEDENT> max_sum = 0 <NEWLINE> min_sum = 0 <NEWLINE> for i in range ( n - k + 1 ) : <NEWLINE> <INDENT> max_sum += a [ - ( i + 1 ) ] * comb ( n - 1 - i , k - 1 , mod ) <NEWLINE> max_sum = max_sum % mod <NEWLINE> min_sum += a [ i ] * comb ( n - 1 - i , k - 1 , mod ) <NEWLINE> min_sum = min_sum % mod <NEWLINE> <DEDENT> ans = max_sum - min_sum <NEWLINE> if ans < 0 : <NEWLINE> <INDENT> ans += mod <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a . sort ( ) <NEWLINE> <NL> N = 1000000007 <NEWLINE> <NL> def combi ( n , r , N ) : <NEWLINE> <INDENT> if n < r or n < 0 or r < 0 : <NEWLINE> <INDENT> ans = 0 <NEWLINE> return ans <NEWLINE> <DEDENT> if n == r : <NEWLINE> <INDENT> ans = 1 <NEWLINE> return ans <NEWLINE> <DEDENT> r = min ( r , n - r ) <NEWLINE> ans = f [ n ] * rf [ r ] * rf [ n - r ] % N <NEWLINE> return ans <NEWLINE> <NL> <DEDENT> f = [ 0 ] * ( 10 ** 5 + 1 ) <NEWLINE> f [ 1 ] = 1 <NEWLINE> <NL> for i in range ( 2 , 10 ** 5 + 1 ) : <NEWLINE> <INDENT> f [ i ] = f [ i - 1 ] * i <NEWLINE> <NL> <DEDENT> rf = [ 0 ] * ( 10 ** 5 + 1 ) <NEWLINE> <NL> for i in range ( 1 , 10 ** 5 + 1 ) : <NEWLINE> <INDENT> rf [ i ] = pow ( f [ i ] , N - 2 , N ) <NEWLINE> <NL> <DEDENT> max_sum = 0 <NEWLINE> min_sum = 0 <NEWLINE> <NL> for i in range ( k - 1 , n ) : <NEWLINE> <INDENT> t = combi ( i , k - 1 , N ) <NEWLINE> max_sum += a [ i ] * t <NEWLINE> max_sum %= N <NEWLINE> min_sum += a [ n - i - 1 ] * t <NEWLINE> min_sum %= N <NEWLINE> <DEDENT> if max_sum - min_sum < 0 : <NEWLINE> <INDENT> max_sum += N <NEWLINE> <DEDENT> print ( max_sum - min_sum ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> xy = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ] <NEWLINE> sgm = pow ( 10. - 7 ) <NEWLINE> def func ( c ) : <NEWLINE> <INDENT> allp = [ ] <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n ) : <NEWLINE> <INDENT> xi , yi = xy [ i ] <NEWLINE> xj , yj = xy [ j ] <NEWLINE> dx = xi - xj <NEWLINE> dy = yi - yj <NEWLINE> d = ( ( xi - xj ) ** 2 + ( yi - yj ) ** 2 ) ** 0.5 <NEWLINE> if c ** 2 - ( d / 2 ) ** 2 < 0 : return False <NEWLINE> h = ( c ** 2 - ( d / 2 ) ** 2 ) ** 0.5 <NEWLINE> mx , my = ( xi + xj ) / 2 , ( yi + yj ) / 2 <NEWLINE> if dx == 0 : <NEWLINE> <INDENT> allp . append ( [ mx - h , my ] ) <NEWLINE> allp . append ( [ mx + h , my ] ) <NEWLINE> <DEDENT> elif dy == 0 : <NEWLINE> <INDENT> allp . append ( [ mx , my - h ] ) <NEWLINE> allp . append ( [ mx , my + h ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dx , dy = dy , - dx <NEWLINE> dh = ( dy ** 2 + dx ** 2 ) ** 0.5 <NEWLINE> dx *= h / dh <NEWLINE> dy *= h / dh <NEWLINE> allp . append ( [ mx + dx , my + dy ] ) <NEWLINE> allp . append ( [ mx - dx , my - dy ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> for px , py in allp : <NEWLINE> <INDENT> flg = True <NEWLINE> for x , y in xy : <NEWLINE> <INDENT> if ( ( px - x ) ** 2 + ( py - y ) ** 2 ) ** 0.5 > c + sgm : <NEWLINE> <INDENT> flg = False <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if flg : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> <DEDENT> return False <NEWLINE> <NL> <DEDENT> r = 2 * max ( [ abs ( x ) for x , y in xy ] ) + max ( [ abs ( y ) for x , y in xy ] ) <NEWLINE> l , r = 0 , r <NEWLINE> for i in range ( 300 ) : <NEWLINE> <INDENT> c = ( l + r ) / 2 <NEWLINE> if func ( c ) : <NEWLINE> <INDENT> l , r = l , c <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> l , r = c , r <NEWLINE> <DEDENT> <DEDENT> print ( c ) <NEWLINE> <COMMENT> <NL> <NEWLINE>
from math import sqrt <NEWLINE> N = int ( input ( ) ) <NEWLINE> XY = [ tuple ( map ( int , input ( ) . split ( ) for _ in range ( N ) ) ) ] <NEWLINE> <NL> def calc ( r ) : <NEWLINE> <INDENT> lst = [ ] <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> x1 = XY [ i ] [ 0 ] <NEWLINE> y1 = XY [ i ] [ 1 ] <NEWLINE> for j in range ( i + 1 , N ) : <NEWLINE> <INDENT> x2 = XY [ j ] [ 0 ] <NEWLINE> y2 = XY [ j ] [ 1 ] <NEWLINE> diff = sqrt ( ( x1 - x2 ) ** 2 + ( y1 - y2 ) ** 2 ) <NEWLINE> if diff > 2 * r : <NEWLINE> <INDENT> return False <NEWLINE> <NL> <DEDENT> h = sqrt ( r ** 2 - diff ** 2 / 4 ) <NEWLINE> if x1 == x2 : <NEWLINE> <INDENT> ny = ( y1 + y2 ) / 2 <NEWLINE> lst . append ( [ x1 - h , ny ] ) <NEWLINE> lst . append ( [ x1 + h , ny ] ) <NEWLINE> <DEDENT> elif y1 == y2 : <NEWLINE> <INDENT> nx = ( x1 + x2 ) / 2 <NEWLINE> lst . append ( [ nx , y1 - h ] ) <NEWLINE> lst . append ( [ nx , y1 + h ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a = ( y2 - y1 ) / ( x2 - x1 ) <NEWLINE> b = - 1 / a <NEWLINE> size = sqrt ( 1 + b ** 2 ) <NEWLINE> dx = h / size <NEWLINE> dy = dx * b <NEWLINE> nx = ( x1 + x2 ) / 2 <NEWLINE> ny = ( y1 + y2 ) / 2 <NEWLINE> lst . append ( [ nx + dx , ny + dy ] ) <NEWLINE> lst . append ( [ nx - dx , ny - dy ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> for x , y in lst : <NEWLINE> <INDENT> flag = True <NEWLINE> for X , Y in XY : <NEWLINE> <INDENT> tmp = ( x - X ) ** 2 + ( y - Y ) ** 2 <NEWLINE> if tmp > r ** 2 : <NEWLINE> <INDENT> flag = False <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if flag : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> <DEDENT> return False <NEWLINE> <DEDENT> l = 0 <NEWLINE> r = 1000 <NEWLINE> for i in range ( 100 ) : <NEWLINE> <INDENT> mid = ( i + r ) / 2 <NEWLINE> if calc ( mid ) : <NEWLINE> <INDENT> r = mid <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> l = mid <NEWLINE> <DEDENT> <DEDENT> print ( r ) <NEWLINE> <NL>
N = int ( input ( ) ) <NEWLINE> S , T = [ 0 ] * N , [ 0 ] * N <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> S [ i ] , T [ i ] = input ( ) . split ( ) <NEWLINE> <DEDENT> X = input ( ) <NEWLINE> <NL> print ( sum ( T [ S . index ( X ) + 1 : ] ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> l = list ( list ( map ( int , input ( ) . split ( ) ) ) for _in range ( n ) ) <NEWLINE> x = input ( ) <NEWLINE> bit = 0 <NEWLINE> su = 0 <NEWLINE> for j , k in l : <NEWLINE> <INDENT> if j == x : <NEWLINE> <INDENT> bit = 1 <NEWLINE> <DEDENT> if bit == 1 : <NEWLINE> <INDENT> su += k <NEWLINE> <DEDENT> <DEDENT> print ( su ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = [ ] <NEWLINE> t = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> s_temp , t_temp = map ( int , input ( ) . split ( ) ) <NEWLINE> s . append ( s_temp ) <NEWLINE> t . append ( t_temp ) <NEWLINE> <DEDENT> end = input ( ) <NEWLINE> print ( sum ( t [ s . index ( end ) + 1 : ] ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> s , t = [ 0 ] * N , [ 0 ] * N <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> s [ i ] , t [ i ] = map ( int , input ( ) . split ( ) ) <NEWLINE> <DEDENT> X = input ( ) <NEWLINE> <NL> ans = 0 <NEWLINE> flag = False <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if flag : <NEWLINE> <INDENT> ans += t [ i ] <NEWLINE> <DEDENT> if s [ i ] == X : <NEWLINE> <INDENT> flag = True <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = [ ] <NEWLINE> t = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> st = list ( input ( ) ) <NEWLINE> s . append ( st [ 0 ] ) <NEWLINE> t . append ( st [ 1 ] ) <NEWLINE> <DEDENT> x = input ( ) <NEWLINE> <NL> print ( sum ( t [ s . index ( x ) : ] ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = [ ] <NEWLINE> t = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> st , tt = map ( input ( ) . split ( ) ) <NEWLINE> s . append ( st ) <NEWLINE> t . append ( tt ) <NEWLINE> <DEDENT> x = str ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ans = ans + 1 <NEWLINE> if t [ i ] == x : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
b , c = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if 500 * b = > c : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
k , x = map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if ( k * 500 >= x ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
k , x = map ( int , input ( ) , split ( ) ) <NEWLINE> print ( <STRING> if 500 * k >= x else <STRING> ) <NEWLINE>
K , X = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if 500 * K >= X : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> else : <NEWLINE> print ( <STRING> ) <NEWLINE> <DEDENT>
<COMMENT> <NL> K = [ ] <NEWLINE> K = int ( input ( ) ) <NEWLINE> <NL> X = [ ] <NEWLINE> X = int ( input ( ) ) <NEWLINE> <NL> if 500 * K < X : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif 500 * K == X : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif 500 * K > X : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> s = list ( input ( ) ) <NEWLINE> count = 0 <NEWLINE> if n % 3 != 0 and n >= 3 : <NEWLINE> <INDENT> for i in range ( 1 , n ) : <NEWLINE> <INDENT> if s [ i - 1 ] == <STRING> and s [ i ] == <STRING> and s [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> elif n % 3 == 0 and n >= 3 : <NEWLINE> <INDENT> for i in range ( 1 , n - 1 ) : <NEWLINE> <INDENT> if s [ i - 1 ] == <STRING> and s [ i ] == <STRING> and s [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if n == 2 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( count ) <NEWLINE> <DEDENT>
4 2000 <NEWLINE>
k , x = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if 500 * i >= x : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
K , X = map ( int , input ( ) . split ( ) ) <NEWLINE> if 500 * K >= X : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else ; <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
k , x = map ( int , input ( ) ) <NEWLINE> <NL> if 500 * k >= x : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
k , x = map ( int , input ( ) . split ) <NEWLINE> print ( <STRING> if 500 * k >= x else <STRING> ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> if 500 * n >= k : print ( <STRING> ) <NEWLINE> <INDENT> else : print ( <STRING> ) <NEWLINE> <DEDENT>
N , X = map ( int , input ( ) , split ( ) ) <NEWLINE> print ( <STRING> if 500 * N >= X else <STRING> ) <NEWLINE>
K , X = list ( map ( int , input ( ) ) ) <NEWLINE> <NL> if K * 500 >= X : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
k , x = map ( int , input ( ) ) <NEWLINE> if ( 500 * k ) >= x : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
K = input ( ) <NEWLINE> X = input ( ) <NEWLINE> <NL> if ( X <= 500 * K ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
k , x = int ( input ( ) . split ( ) ) <NEWLINE> if 500 * k >= x : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
k , x = list ( map ( int , input ( ) . split ) ) <NEWLINE> print ( <STRING> ) if k * 500 <= x else print ( <STRING> ) <NEWLINE>
tmp = input ( ) <NEWLINE> <NL> N = int ( tmp [ 0 ] ) <NEWLINE> X = int ( tmp [ 1 ] ) <NEWLINE> <NL> if X <= 500 * N : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b = int ( input ( ) . split ( ) ) <NEWLINE> if a * 500 >= b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> s = int ( input ( ) ) <NEWLINE> print ( s . count ( <STRING> ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S = str ( input ( ) ) <NEWLINE> S = S . remove ( <STRING> ) <NEWLINE> if N == len ( S ) : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return ( N - len ( S ) ) // 3 <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 0 , n - 2 ) : <NEWLINE> <INDENT> if S [ i ] == <STRING> and S [ i + 1 ] == <STRING> and S [ i + 2 ] == <STRING> : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> print ( sum ( S [ i ] == A and S [ i + 1 ] == B and S [ i + 2 ] == C for i in range ( N - 2 ) ) ) <NEWLINE>
n , s = [ int ( input ( ) ) for _ in range ( 2 ) ) <NEWLINE> print ( s . count ( <STRING> ) ) <NEWLINE>
n = int ( input ) <NEWLINE> s = input ( ) <NEWLINE> s2 = s . replace ( <STRING> , <STRING> ) <NEWLINE> print ( int ( ( len ( s ) - len ( s2 ) ) / 3 ) ) <NEWLINE>
n = int ( intput ( ) ) <NEWLINE> str = input ( ) <NEWLINE> print ( str . count ( <STRING> ) ) <NEWLINE>
a = input ( ) <NEWLINE> s = input ( ) <NEWLINE> print ( s . count ( <STRING> ) <NEWLINE>
import itertools <NEWLINE> N = int ( input ( ) ) <NEWLINE> P = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> Q = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> permutations = list ( itertools . permutations ( range ( 1 , N + 1 ) ) ) <NEWLINE> p = permutations . index ( P ) <NEWLINE> q = permutations . index ( Q ) <NEWLINE> print ( abs ( p - q ) ) <NEWLINE>
import itertools <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> p = tuple ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> q = tuple ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ls = list ( itertools . parmutations ( range ( 1 , n + 1 ) ) ) <NEWLINE> print ( abs ( ls . index ( p ) - ls . index ( q ) ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> P = tuple ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> Q = tuple ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> cnt , a , b = 0 , 0 , 0 <NEWLINE> for i in itertools . permutations ( range ( 1 , N + 1 ) ) : <NEWLINE> <INDENT> if P == i : <NEWLINE> <INDENT> a = cnt <NEWLINE> if b != 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> if Q == i : <NEWLINE> <INDENT> b = cnt <NEWLINE> if a != 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> cnt += 1 <NEWLINE> <DEDENT> print ( abs ( a - b ) ) <NEWLINE>
from itertools import permutations <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> t = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> s = <STRING> . join ( l ) <NEWLINE> h = <STRING> . join ( t ) <NEWLINE> <NL> l1 = list ( ) <NEWLINE> <NL> for i in permutations ( s ) : <NEWLINE> <INDENT> l1 . append ( i ) <NEWLINE> <NL> <DEDENT> print ( abs ( l1 . find ( s ) - l1 . find ( h ) ) ) <NEWLINE>
import copy <NEWLINE> def func ( n ) : <NEWLINE> <INDENT> result = [ ] <NEWLINE> result . append ( [ 1 , 2 ] ) <NEWLINE> result . append ( [ 2 , 1 ] ) <NEWLINE> if n == 2 : <NEWLINE> <INDENT> return result <NEWLINE> <DEDENT> else : <NEWLINE> <COMMENT> <NL> <INDENT> res_list = func ( n - 1 ) <NEWLINE> res = [ ] <NEWLINE> for j in range ( n ) : <NEWLINE> <INDENT> for s in res_list : <NEWLINE> <INDENT> st = copy . copy ( s ) <NEWLINE> st . insert ( j , n ) <NEWLINE> res . append ( st ) <NEWLINE> <DEDENT> <DEDENT> return res <NEWLINE> <NL> <DEDENT> <DEDENT> n = int ( input ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> q = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> s = func ( n ) <NEWLINE> s . sort ( ) <NEWLINE> p_i = 0 <NEWLINE> q_i = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <COMMENT> <NL> <INDENT> if s [ i ] == p : <NEWLINE> <INDENT> p_i = i <NEWLINE> <DEDENT> if s [ i ] == q : <NEWLINE> <INDENT> q_i = i <NEWLINE> <DEDENT> <DEDENT> print ( abs ( p_i , q_i ) ) <NEWLINE>
import itertools <NEWLINE> import math <NEWLINE> <NL> n = input ( ) <NEWLINE> p = [ map ( int , input ( ) . split ( ) ) ] <NEWLINE> q = [ map ( int , input ( ) . split ( ) ) ] <NEWLINE> p_no , q_no = 0 , 0 <NEWLINE> <NL> per = [ c + 1 for c in range ( n ) ] <NEWLINE> per_list = list ( itertools . permutations ( per ) ) <NEWLINE> <NL> for i in range ( math . factorial ( n ) ) : <NEWLINE> <INDENT> if p == per_list [ i ] : p_no = i <NEWLINE> if q == per_list [ i ] : q_no = i <NEWLINE> <NL> <DEDENT> print ( abs ( p_no - q_no ) ) <NEWLINE>
import sys <NEWLINE> import time <NEWLINE> import math <NEWLINE> import itertools as it <NEWLINE> def inpl ( ) : <NEWLINE> <INDENT> return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <DEDENT> st = time . perf_counter ( ) <NEWLINE> <COMMENT> <NL> <NL> N = int ( input ( ) ) <NEWLINE> P = inpl ( ) <NEWLINE> Q = inpl ( ) <NEWLINE> ls = P . copy ( ) <NEWLINE> ls . sort ( ) <NEWLINE> cnt = 0 <NEWLINE> for l in it . permutations ( ls ) : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> if P == l : <NEWLINE> <INDENT> a = cnt <NEWLINE> <DEDENT> if Q == l : <NEWLINE> <INDENT> b = cnt <NEWLINE> <DEDENT> <DEDENT> print ( abs ( a - b ) ) <NEWLINE> <COMMENT> <NL> ed = time . perf_counter ( ) <NEWLINE> print ( <STRING> , ed - st , file = sys . stderr ) <NEWLINE>
import itertools <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> P = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> Q = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> Ns = list ( itertools . permutations ( range ( 1 , N + 1 ) ) ) <NEWLINE> PO = Ns . index ( P ) <NEWLINE> QO = Ns . index ( Q ) <NEWLINE> print ( abs ( PO - QO ) ) <NEWLINE>
def func ( x , y ) : <NEWLINE> <INDENT> if len ( y ) == 1 : <NEWLINE> <INDENT> dic . append ( i * 10 + int ( y ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for j in range ( len ( y ) ) : <NEWLINE> <INDENT> func ( i * 10 + int ( y [ j ] ) , y [ : j ] + y [ j + 1 : ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> dic = [ ] <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> func ( 0 , <STRING> . join ( [ i in range ( 1 , N + 1 ) ] ) ) <NEWLINE> <NL> A = int ( input ( ) . replace ( <STRING> , <STRING> ) ) <NEWLINE> B = int ( input ( ) . replace ( <STRING> , <STRING> ) ) <NEWLINE> ans = abs ( dic . index ( A ) - dic . index ( B ) ) <NEWLINE> print ( ans ) <NEWLINE>
from itertools import permutations <NEWLINE> N = int ( input ( ) ) <NEWLINE> <NL> o = { } <NEWLINE> for i , p in enumerate ( permutation ( range ( 1 , N + 1 ) ) ) : <NEWLINE> <INDENT> o [ p ] = i <NEWLINE> <DEDENT> P = tuple ( int ( x ) for x in input ( ) . split ( ) ) <NEWLINE> Q = tuple ( int ( x ) for x in input ( ) . split ( ) ) <NEWLINE> print ( abs ( o [ P ] - o [ Q ] ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> def pos_num ( l ) : <NEWLINE> <INDENT> l_sort = l . copy ( ) <NEWLINE> l_len = len ( l ) <NEWLINE> l_sort . sort ( ) <NEWLINE> if l_len == 1 : <NEWLINE> <INDENT> an = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <COMMENT> <NL> <INDENT> an = ( l_sort . index ( l [ 0 ] ) ) * math . factorial ( l_len - 1 ) <NEWLINE> <COMMENT> <NL> <DEDENT> return an <NEWLINE> <NL> <NL> <NL> <DEDENT> ls = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> an = 0 <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> b = pos_num ( ls [ i : ] ) <NEWLINE> an += b <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> print ( ) <NEWLINE> ll = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> bn = 0 <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> b = pos_num ( ll [ i : ] ) <NEWLINE> bn += b <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> print ( abs ( an - bn ) ) <NEWLINE>
import itertools <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a . append ( i + 1 ) <NEWLINE> <DEDENT> b = [ ] <NEWLINE> for per in itertools . permutatiton ( a ) : <NEWLINE> <INDENT> b . append ( list ( per ) ) <NEWLINE> <DEDENT> c = b . index ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> d = b . index ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> print ( abs ( c - d ) ) <NEWLINE>
<INDENT> n = int ( input ( ) ) <NEWLINE> p = tuple ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> q = tuple ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> s = itertools . permutations ( range ( 1 , n + 1 ) ) <NEWLINE> l = [ ] <NEWLINE> for v in s : <NEWLINE> <INDENT> l . append ( v ) <NEWLINE> <DEDENT> p_index = l . index ( p ) <NEWLINE> q_index = l . index ( q ) <NEWLINE> <NL> print ( abs ( p_index - q_index ) ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> P = tuple ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> Q = tuple ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ls = [ i for i in range ( 1 , N + 1 ) ] <NEWLINE> A = list ( permutations ( ls ) ) <NEWLINE> <NL> print ( abs ( A . index ( P ) - A . index ( Q ) ) ) <NEWLINE>
from itertools import permutations <NEWLINE> n = int ( input ( ) ) <NEWLINE> p , q = = tuple ( map ( int , input ( ) . split ( ) ) ) , tuple ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> l = list ( range ( 1 , n + 1 ) ) <NEWLINE> x = [ i for i in permutations ( l , n ) ] <NEWLINE> print ( abs ( x . index ( p ) - x . index ( q ) ) ) <NEWLINE>
from itertools import permutations <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> P = tuple ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> Q = tuple ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> l = permutations ( range ( 1 , N + 1 ) ) <NEWLINE> <NL> print ( abs ( l . index ( P ) - l . index ( Q ) ) ) <NEWLINE>
from itertools import permutations <NEWLINE> n = 8 <NEWLINE> a = map ( str , range ( 1 , n + 1 ) ) <NEWLINE> a = <STRING> . join ( a ) <NEWLINE> l = list ( permutations ( a , n ) ) <NEWLINE> <NL> p = tuple ( input ( ) . split ( ) ) <NEWLINE> q = tuple ( input ( ) . split ( ) ) <NEWLINE> <NL> print ( abs ( l . index ( p ) - l . index ( q ) ) ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> from fractions import gcd <NEWLINE> from itertools import combinations , permutations , accumulate , product <COMMENT> <NEWLINE> <COMMENT> <NL> from collections import deque , defaultdict , Counter <NEWLINE> import decimal <NEWLINE> import re <NEWLINE> import math <NEWLINE> import bisect <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> import sys <NEWLINE> sys . setrecursionlimit ( 10000000 ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> from sys import stdin <NEWLINE> readline = stdin . readline <NEWLINE> def readInts ( ) : <NEWLINE> <INDENT> return list ( map ( int , readline ( ) . split ( ) ) ) <NEWLINE> <DEDENT> def readTuples ( ) : <NEWLINE> <INDENT> return tuple ( map ( int , readline ( ) . split ( ) ) ) <NEWLINE> <DEDENT> def I ( ) : <NEWLINE> <INDENT> return int ( readline ( ) ) <NEWLINE> <DEDENT> n = I ( ) <NEWLINE> lis = list ( range ( 1 , n + 1 ) ) <NEWLINE> a , b = None , None <NEWLINE> P = readInts ( ) <NEWLINE> Q = readInts ( ) <NEWLINE> i = 0 <NEWLINE> for A in permutations ( lis , n ) : <NEWLINE> <INDENT> if list ( A ) == P : <NEWLINE> <INDENT> a = i <NEWLINE> <DEDENT> elif list ( A ) == Q : <NEWLINE> <INDENT> b = i <NEWLINE> <DEDENT> i += 1 <NEWLINE> <DEDENT> print ( abs ( a - b ) ) <NEWLINE>
import itertools <NEWLINE> N = int ( input ( ) ) <NEWLINE> P = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> Q = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ls = list ( itertools . permutations ( range ( 1 , N + 1 ) ) ) <NEWLINE> print ( abs ( ls . index ( P ) - ls . index ( Q ) ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> p = list ( map ( int , input ( ) , split ( ) ) ) <NEWLINE> q = list ( map ( int , input ( ) , split ( ) ) ) <NEWLINE> from itertools import permutations <NEWLINE> list = list ( permutations ( range ( 1 , n + 1 ) ) ) <NEWLINE> ans = abs ( list . index ( p ) - list . index ( q ) ) <NEWLINE>
import itertools as itool <NEWLINE> N = int ( input ( ) ) <NEWLINE> plist = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> qlist = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> mylist = list ( itool . permutations ( range ( 1 , n + 1 ) ) ) <NEWLINE> print ( abs ( mylist . index ( p ) - mylist . index ( q ) ) ) <NEWLINE>
from itertools import permutations <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> Nlist = [ i for i in range ( 1 , int ( input ( ) ) + 1 ) ] <NEWLINE> Nlist = list ( permutations ( Nlist ) ) <NEWLINE> <NL> P = tuple ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> Q = tuple ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> print ( abs ( X . index ( P ) - X . index ( Q ) ) ) <NEWLINE>
from math import gcd <NEWLINE> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A = [ i // 2 for i in a ] <NEWLINE> l = 1 <NEWLINE> for a in A : <NEWLINE> <INDENT> lcd *= a // gcd ( lcd , a ) <NEWLINE> <DEDENT> for a in A : <NEWLINE> <INDENT> if lcd // a % 2 == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( ( M // lcd + 1 ) // 2 ) <NEWLINE>
import math <NEWLINE> from functools import reduce <NEWLINE> <NL> <NL> def lcm_base ( x , y ) : <NEWLINE> <INDENT> return ( x * y ) // math . gcd ( x , y ) <NEWLINE> <NL> <NL> <DEDENT> def lcm ( * numbers ) : <NEWLINE> <INDENT> return reduce ( lcm_base , numbers , 1 ) <NEWLINE> <NL> <NL> <DEDENT> def lcm_list ( numbers ) : <NEWLINE> <INDENT> return reduce ( lcm_base , numbers , 1 ) <NEWLINE> <NL> <NL> <DEDENT> def my_round ( val , digit = 0 ) : <NEWLINE> <INDENT> p = 10 ** digit <NEWLINE> return ( val * p * 2 + 1 ) // 2 / p <NEWLINE> <NL> <NL> <DEDENT> n , m = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a_pr = [ i // 2 for i in list ( map ( int , input ( ) . split ( ) ) ) ] <NEWLINE> lcm_ = lcm_list ( a_pr ) <NEWLINE> res , div2 = 0 , None <NEWLINE> for ai in a_pr : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> while a % 2 == 0 : <NEWLINE> <INDENT> a //= 2 <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> if div2 is None : <NEWLINE> <INDENT> div2 = cnt <NEWLINE> <DEDENT> elif cnt != div2 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( int ( my_round ( m // lcm_ / 2 ) ) ) <NEWLINE>
<COMMENT> <NL> <STRING> <NEWLINE> from math import gcd <NEWLINE> <NL> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> flag = False <NEWLINE> res = 1 <NEWLINE> for a in A : <NEWLINE> <INDENT> a /= 2 <NEWLINE> res *= a // gcd ( res , a ) <NEWLINE> if res > M : <NEWLINE> <INDENT> flag = True <NEWLINE> break <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> <STRING> <NEWLINE> <NL> for a in A : <NEWLINE> <INDENT> if int ( res / a ) == res / a : <NEWLINE> <INDENT> flag = True <NEWLINE> <NL> <DEDENT> <DEDENT> if flag : <NEWLINE> <INDENT> ans = 0 <NEWLINE> print ( ans ) <NEWLINE> <DEDENT> else : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <INDENT> ans = ( M // res + 1 ) // 2 <NEWLINE> print ( ans ) <NEWLINE> <DEDENT>
from functools import reduce <NEWLINE> import math <NEWLINE> def lcm_base ( x , y ) : <NEWLINE> <INDENT> return ( x * y ) // math . gcd ( x , y ) <NEWLINE> <NL> <DEDENT> def lcm ( * numbers ) : <NEWLINE> <INDENT> return reduce ( lcm_base , numbers , 1 ) <NEWLINE> <NL> <DEDENT> def lcm_list ( numbers ) : <NEWLINE> <INDENT> return reduce ( lcm_base , numbers , 1 ) <NEWLINE> <NL> <DEDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = [ i // 2 for i in list ( set ( a ) ) ] <NEWLINE> <NL> cnt_common = - 1 <NEWLINE> for i in a : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> while i % 2 == 0 : <NEWLINE> <INDENT> i = i // 2 <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> if cnt_common == - 1 : <NEWLINE> <INDENT> cnt_common = cnt <NEWLINE> continue <NEWLINE> <DEDENT> if cnt_common != cnt : <NEWLINE> <INDENT> nothing = True <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> b = lcm_list ( a ) <NEWLINE> if nothing : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = ( m - b ) // ( 2 * b ) + 1 <NEWLINE> print ( max ( ans , 0 ) ) <NEWLINE> <DEDENT>
import math <NEWLINE> import sys <NEWLINE> from functools import reduce <NEWLINE> <NL> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> def lcm_base ( x , y ) : <NEWLINE> <INDENT> return ( x * y ) // math . gcd ( x , y ) <NEWLINE> <NL> <DEDENT> def lcm_list ( numbers ) : <NEWLINE> <INDENT> return reduce ( lcm_base , numbers , 1 ) <NEWLINE> <NL> <DEDENT> C = gcd_list ( A ) <NEWLINE> B = [ 0 for _ in range ( N ) ] <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> B [ i ] = C // A [ i ] <NEWLINE> if B [ i ] % 2 == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ( M // C + 1 ) // 2 ) <NEWLINE>
import sys <NEWLINE> <NL> read = sys . stdin . read <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> sys . setrecursionlimit ( 10 ** 8 ) <NEWLINE> INF = float ( <STRING> ) <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> <NL> <NL> def lcm_base ( a , b ) : <NEWLINE> <INDENT> return ( a * b ) // gcd ( a , b ) <NEWLINE> <NL> <NL> <DEDENT> def lcm_list ( numbers ) : <NEWLINE> <INDENT> return reduce ( lcm_base , numbers , 1 ) <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> n , m = map ( int , readline ( ) . split ( ) ) <NEWLINE> a = np . array ( input ( ) . split ( ) , np . int64 ) <NEWLINE> a //= 2 <NEWLINE> b = np . copy ( a ) <NEWLINE> while True : <NEWLINE> <INDENT> c = b % 2 <NEWLINE> if c . sum ( ) == 0 : <NEWLINE> <INDENT> b //= 2 <NEWLINE> <DEDENT> elif c . sum ( ) == n : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT> d = lcm_list ( a ) <NEWLINE> if d > 10 ** 9 : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = ( m // d ) - ( m // ( d + d ) ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> import os <NEWLINE> import sys <NEWLINE> import numpy as np <NEWLINE> <NL> def z_algo ( S ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <INDENT> i , j , n = 1 , 0 , len ( S ) <NEWLINE> Z = np . zeros_like ( S ) <NEWLINE> Z [ 0 ] = n <NEWLINE> while i < n : <NEWLINE> <INDENT> while i + j < n and S [ j ] == S [ i + j ] : <NEWLINE> <INDENT> j += 1 <NEWLINE> <DEDENT> if j == 0 : <NEWLINE> <INDENT> i += 1 <NEWLINE> continue <NEWLINE> <DEDENT> Z [ i ] = j <NEWLINE> d = 1 <NEWLINE> while i + d < n and d + Z [ d ] < j : <NEWLINE> <INDENT> Z [ i + d ] = Z [ d ] <NEWLINE> d += 1 <NEWLINE> <DEDENT> i += d <NEWLINE> j -= d <NEWLINE> <DEDENT> return Z <NEWLINE> <NL> <DEDENT> def solve ( N , A , B ) : <NEWLINE> <INDENT> Diff = np . empty ( 3 * N , dtype = np . int64 ) <NEWLINE> Diff [ 0 ] = B [ 0 ] ^ B [ - 1 ] <NEWLINE> Diff [ 1 : N ] = B [ 1 : ] ^ B [ : - 1 ] <NEWLINE> Diff [ N ] = Diff [ 2 * N ] = A [ 0 ] ^ A [ - 1 ] <NEWLINE> Diff [ N + 1 : 2 * N ] = Diff [ 2 * N + 1 : 3 * N ] = A [ 1 : ] ^ A [ : - 1 ] <NEWLINE> Z = z_algo ( Diff ) [ N : 2 * N ] <NEWLINE> Ans = [ ( 0 , 0 ) ] * 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> z = Z [ i ] <NEWLINE> if z >= N : <NEWLINE> <INDENT> Ans . append ( ( i , B [ 0 ] ^ A [ i ] ) ) <NEWLINE> <DEDENT> <DEDENT> return np . array ( Ans ) <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> numba_config = [ <NEWLINE> <INDENT> [ z_algo , <STRING> ] , <NEWLINE> [ solve , <STRING> ] , <NEWLINE> <DEDENT> ] <NEWLINE> if sys . argv [ - 1 ] == <STRING> : <NEWLINE> <INDENT> from numba import njit <NEWLINE> from numba . pycc import CC <NEWLINE> cc = CC ( <STRING> ) <NEWLINE> for func , signature in numba_config : <NEWLINE> <INDENT> vars ( ) [ func . __name__ ] = njit ( signature ) ( func ) <NEWLINE> cc . export ( func . __name__ , signature ) ( func ) <NEWLINE> <DEDENT> cc . compile ( ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> elif os . name == <STRING> : <NEWLINE> <INDENT> exec ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> from numba import njit <NEWLINE> for func , signature in numba_config : <NEWLINE> <INDENT> vars ( ) [ func . __name__ ] = njit ( signature , cache = True ) ( func ) <NEWLINE> <DEDENT> print ( <STRING> , file = sys . stderr ) <NEWLINE> <COMMENT> <NL> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> A = np . array ( input ( ) . split ( ) , dtype = np . int64 ) <NEWLINE> B = np . array ( input ( ) . split ( ) , dtype = np . int64 ) <NEWLINE> Ans = solve ( N , A , B ) . tolist ( ) <NEWLINE> print ( <STRING> . join ( map ( lambda x : <STRING> . join ( map ( str , x ) ) , Ans ) ) ) <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE>
s , t = intput ( ) . split ( ) <NEWLINE> print ( t + s ) <NEWLINE>
N , M = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> a = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> l = [ ] <NEWLINE> for b in a : <NEWLINE> <INDENT> for c in a : <NEWLINE> <INDENT> l . append ( b + c ) <NEWLINE> <DEDENT> <DEDENT> print ( sum ( sorted ( l ) [ len ( l ) - M : ] ) ) <NEWLINE>
A , B = map ( input ( ) . split ( ) ) <NEWLINE> print ( B + A ) <NEWLINE>
s , t = str ( input ( ) ) <NEWLINE> a = t + s <NEWLINE> print ( a ) <NEWLINE>
s , t = input ( ) <NEWLINE> print ( t + s ) <NEWLINE>
S = input ( ) <NEWLINE> T = input ( ) <NEWLINE> <NL> print ( T + S ) <NEWLINE>
S , T = map ( input ( ) split ( ) ) <NEWLINE> print ( T . S ) <NEWLINE>
s , t = map ( input ( ) . split ( ) ) <NEWLINE> print ( s + t ) <NEWLINE>
a = input ( ) <NEWLINE> b = input ( ) <NEWLINE> print ( b + a ) <NEWLINE>
s , t = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( t + s ) <NEWLINE>
S , T = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( T + S ) <NEWLINE>
a , b = map ( input ( ) . split ( ) ) <NEWLINE> print ( b + a ) <NEWLINE>
a , b = map ( str , input ( ) . split ( ) ) <NEWLINE> print ( b + c ) <NEWLINE>
a = input ( ) <NEWLINE> b = input ( ) <NEWLINE> print ( b + a ) <NEWLINE>
a , b , k = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if k <= a : <NEWLINE> <INDENT> print ( str ( a - k ) + <STRING> + str ( b ) ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> print ( str ( 0 ) + <STRING> + str ( min ( 0 , b - ( k - a ) ) ) ) <NEWLINE> <DEDENT>
a = input ( ) <NEWLINE> b = input ( ) <NEWLINE> print ( a + b ) <NEWLINE>
a , b = input ( ) . split ( ) <NEWLINE> print ( b , a sep = <STRING> ) <NEWLINE>
S = input ( ) <NEWLINE> T = input ( ) <NEWLINE> print ( T + S ) <NEWLINE>
a = input ( ) <NEWLINE> b = input ( ) <NEWLINE> print ( b + a ) <NEWLINE>
print ( input ( ) . split ( ) [ : : - 1 ] . join ( ) ) <NEWLINE>
s , t = input ( ) . split ( ) <NEWLINE> print ( <STRING> . join ( t , s ) ) <NEWLINE>
s = input ( ) <NEWLINE> t = input ( ) <NEWLINE> print ( t + s ) <NEWLINE>
S , T = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> print ( T + S ) <NEWLINE>
import sys <NEWLINE> A , B , K = map ( int , next ( sys . stdin . buffer ) ) <NEWLINE> x = min ( A , B , K ) <NEWLINE> print ( A - x , B - x ) <NEWLINE>
a , b , k = map ( int , input ( ) . split ( ) ) <NEWLINE> if a >= k : <NEWLINE> <INDENT> print ( a - k , b ) <NEWLINE> <DEDENT> elif a < k and k <= a + b <NEWLINE> <INDENT> print ( 0 , a + b - k ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 , 0 ) <NEWLINE> <DEDENT>
A , B , K = map ( int , input ( ) . split ( ) ) <NEWLINE> if A >= K : <NEWLINE> <INDENT> print ( A - K , B ) <NEWLINE> else : <NEWLINE> print ( 0 , B - ( K - A ) ) <NEWLINE> <DEDENT>
a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> for i in range ( c ) : <NEWLINE> <INDENT> if ( a == 0 ) : <NEWLINE> <INDENT> b -= 1 <NEWLINE> if ( b == 0 ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> elif ( a > 0 ) : <NEWLINE> <INDENT> a -= 1 <NEWLINE> <DEDENT> <DEDENT> print ( str ( a ) , str ( b ) ) <NEWLINE>
A , B , K = map ( int , input ( ) . Split ( ) ) <NEWLINE> <NL> if A - K > 0 : <NEWLINE> <INDENT> print ( A - K , B ) <NEWLINE> <DEDENT> elif B - ( K - A ) > 0 : <NEWLINE> <INDENT> print ( 0 , B - K + A ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 , 0 ) <NEWLINE> <DEDENT>
A , B , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if A = > K : <NEWLINE> <INDENT> A -= K <NEWLINE> <DEDENT> elif A < K < A + B : <NEWLINE> <INDENT> B -= K - A <NEWLINE> A = 0 <NEWLINE> <DEDENT> elif A + B <= K : <NEWLINE> <INDENT> A = B = 0 <NEWLINE> <NL> <DEDENT> print ( A , B ) <NEWLINE>
a , b , k = ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <INDENT> if a > k : <NEWLINE> <INDENT> print ( a - k , b ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if a + b > k : <NEWLINE> <INDENT> print ( 0 , a + b - k ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 , 0 ) <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> x = int ( input ( ) ) <NEWLINE> <NL> def prime_check ( num , count ) : <NEWLINE> <INDENT> while True : <NEWLINE> <INDENT> while num % count == 0 : <NEWLINE> <INDENT> num = num + 1 <NEWLINE> count = 2 <NEWLINE> if num <= count ** 2 : <NEWLINE> print ( num ) <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> count = count + 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if x == 2 : <NEWLINE> <INDENT> print ( 2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> prime_check ( x , 2 ) <NEWLINE> <DEDENT>
X = int ( input ( ) ) <NEWLINE> i = int ( n ** 0.5 ) <NEWLINE> <NL> while i >= 2 : <NEWLINE> <INDENT> if X % i == 0 : <NEWLINE> <INDENT> X += 1 <NEWLINE> i = int ( X ** 0.5 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> i -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( X ) <NEWLINE>
X = int ( input ( ) ) <NEWLINE> for i in range ( X + 1 , 9999999999999999 ) : <NEWLINE> <INDENT> flag = 1 <NEWLINE> for j in range ( 2 , X // 2 + 1 ) : <NEWLINE> <INDENT> if i % j == 0 : <NEWLINE> <INDENT> flag = - 1 <NEWLINE> break <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> elif flag == 1 : <NEWLINE> <INDENT> print ( i ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT>
x = int ( input ( ) ) <NEWLINE> <NL> while True : <NEWLINE> <INDENT> flag == 0 <NEWLINE> for i in range ( 2 , x // 2 ) : <NEWLINE> <INDENT> if x % i == 0 : <NEWLINE> <INDENT> flag == 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if flag == 1 : <NEWLINE> <INDENT> print ( x ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = x + 1 <NEWLINE> <DEDENT> <DEDENT>
x = int ( input ( ) ) <NEWLINE> flg = 0 <NEWLINE> if x == 2 : <NEWLINE> <INDENT> print ( 2 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> while True : <NEWLINE> <INDENT> for i in range ( 2 , int ( x ** 0.5 ) + 1 ) : <NEWLINE> <INDENT> if x % i == 0 : <NEWLINE> <INDENT> flg += 1 <NEWLINE> <DEDENT> if i == int ( x ** 0.5 ) and flg == 0 : <NEWLINE> <INDENT> print ( x ) <NEWLINE> exit ( ) <NEWLINE> x += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT>
def prime ( n ) : <NEWLINE> <INDENT> limit = math . floor ( math . sqrt ( n ) ) <NEWLINE> for i in range ( 2 , limit + 1 ) : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> return prime ( n + 1 ) <NEWLINE> <DEDENT> <DEDENT> return n <NEWLINE> <NL> <DEDENT> X = int ( input ( ) ) <NEWLINE> <NL> print ( prime ( X ) ) <NEWLINE>
x = int ( input ( ) ) <NEWLINE> while True : <NEWLINE> <INDENT> for i in range ( 2 , x ) : <NEWLINE> <INDENT> if x % i == 0 <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( x ) <NEWLINE> break <NEWLINE> <DEDENT> x += 1 <NEWLINE> <DEDENT>
import math <NEWLINE> x = int ( input ( ) ) <NEWLINE> ans = x <NEWLINE> while True : <NEWLINE> <INDENT> for i in range ( 2 , math . sqrt ( x ) + 1 ) : <NEWLINE> <INDENT> if x % i = 0 : <NEWLINE> <INDENT> print ( x ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> x += 1 <NEWLINE> <NL> <DEDENT>
X = int ( input ( ) ) <NEWLINE> for i in range ( X , 120000 ) : <NEWLINE> <INDENT> f = 0 <NEWLINE> for j in range ( 2 , math . ceil ( math . sqrt ( i ) ) ) : <NEWLINE> <INDENT> if i % j == 0 : <NEWLINE> <INDENT> f += 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if f == 0 : <NEWLINE> <INDENT> print ( i ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT>
pip install sympy <NEWLINE> from sympy import isprime <NEWLINE> <NL> x = int ( input ( ) ) <NEWLINE> if x % 2 == 0 : <NEWLINE> <INDENT> x += 1 <NEWLINE> <NL> <DEDENT> flag = True <NEWLINE> <NL> while flag == True : <NEWLINE> <INDENT> if isprime ( x ) == True : <NEWLINE> <INDENT> flag = False <NEWLINE> <NL> <DEDENT> <DEDENT> print ( x ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <NL> def eratosthenes_sieve ( n ) : <NEWLINE> <INDENT> is_prime = [ True ] * ( n + 1 ) <NEWLINE> is_prime [ 0 ] = is_prime [ 1 ] = False <NEWLINE> for p in range ( 2 , n + 1 ) : <NEWLINE> <INDENT> if is_prime [ p ] : <NEWLINE> <INDENT> for q in range ( 2 * p , n + 1 , p ) : <NEWLINE> <INDENT> is_prime [ q ] = False <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return is_prime <NEWLINE> <NL> <DEDENT> MAX_N = ( 10 ** 6 ) <NEWLINE> Primes = eratosthenes_sieve ( MAX_N ) <NEWLINE> <NL> x = int ( input ( ) ) <NEWLINE> while True : <NEWLINE> <INDENT> if Primes [ x ] : <NEWLINE> <INDENT> print ( x ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT>
a = int ( input ( ) ) <NEWLINE> <NL> def factorization ( n ) : <NEWLINE> <INDENT> arr = [ ] <NEWLINE> tmp = n <NEWLINE> <NL> for i in range ( 2 , int ( n ** 0.5 // 1 ) + 1 ) : <NEWLINE> <INDENT> if tmp % i == 0 : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> while tmp % i == 0 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> tmp //= i <NEWLINE> <DEDENT> arr . append ( [ i , cnt ] ) <NEWLINE> <DEDENT> <DEDENT> if tmp != 1 : <NEWLINE> <INDENT> arr . append ( [ tmp , 1 ] ) <NEWLINE> <DEDENT> if arr == [ ] : <NEWLINE> <INDENT> arr . append ( [ n , 1 ] ) <NEWLINE> <DEDENT> return arr <NEWLINE> <NL> <DEDENT> while True : <NEWLINE> <INDENT> arr = factorization ( a ) <NEWLINE> if ( len ( arr ) == 1 ) & ( arr [ 1 ] == 1 ) : <NEWLINE> <INDENT> print ( a ) <NEWLINE> break <NEWLINE> <DEDENT> a += 1 <NEWLINE> <DEDENT>
X = int ( input ( ) ) <NEWLINE> <NL> def is_Prime ( x ) : <NEWLINE> <INDENT> for i in range ( 2 , x + 1 ) : <NEWLINE> <INDENT> if i * i + 1 > x : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> if x % i == 0 : <NEWLINE> <INDENT> return False <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for i in range ( X + 1 , 2 X + 1 ) : <NEWLINE> <INDENT> if is_Prime ( i ) : <NEWLINE> <INDENT> print ( i ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> <NL> def p ( x ) : <NEWLINE> <INDENT> if x == 2 : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> for i in range ( x // 2 ) : <NEWLINE> <INDENT> if x % i == 0 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> <DEDENT> return True <NEWLINE> <NL> <DEDENT> for i in range ( n , 2 * n ) : <NEWLINE> <INDENT> if p ( i ) : <NEWLINE> <INDENT> print ( i ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT>
X = int ( input ( ) ) <NEWLINE> prime = [ 2 ] <NEWLINE> for i in range ( 3 , 100004 ) : <NEWLINE> <INDENT> for p in prime : <NEWLINE> <INDENT> is_prime = True <NEWLINE> if i % p == 0 : <NEWLINE> <INDENT> is_prime = False <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if is_prime : prime . append ( i ) <NEWLINE> <NL> <DEDENT> print ( min ( [ i for i in prime if i >= X ] ) ) <NEWLINE>
import math <NEWLINE> n = int ( input ( ) ) <NEWLINE> if n == 2 : <NEWLINE> <INDENT> print ( n ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cost = 0 <NEWLINE> for i in range ( n , 10 ** 6 ) : <NEWLINE> <INDENT> for j in range ( 2 , int ( math . sqrt ( i ) ) + 1 ) : <NEWLINE> <INDENT> if i % j == 0 : <NEWLINE> <INDENT> cost += 1 <NEWLINE> <DEDENT> <DEDENT> if cost == 0 : <NEWLINE> <INDENT> print ( i ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def eratosthenes ( n ) : <NEWLINE> <INDENT> A = [ i for i in range ( 2 , n + 1 ) ] <NEWLINE> P = [ ] <NEWLINE> i = 2 <NEWLINE> while i ** 2 <= n : <NEWLINE> <INDENT> prime = min ( A ) <NEWLINE> P . append ( prime ) <NEWLINE> j = 0 <NEWLINE> while j < len ( A ) : <NEWLINE> <INDENT> if A [ j ] % prime == 0 : <NEWLINE> <INDENT> A . pop ( j ) <NEWLINE> continue <NEWLINE> <DEDENT> j += 1 <NEWLINE> <DEDENT> i += 1 <NEWLINE> <DEDENT> for a in A : <NEWLINE> <INDENT> P . append ( a ) <NEWLINE> <DEDENT> return P <NEWLINE> <NL> <DEDENT> x = int ( input ( ) ) <NEWLINE> prime_table = eratosthenes ( 100003 ) <NEWLINE> prime_set = set ( prime_table ) <NEWLINE> if x in prime_set : <NEWLINE> <INDENT> print ( x ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> idx = bisect_right ( prime_table , x ) <NEWLINE> ans = prime_table [ idx ] <NEWLINE> print ( ans ) <NEWLINE> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> R , S , P = map ( int , input ( ) . split ( ) ) <NEWLINE> T = input ( ) <NEWLINE> score = { <STRING> : P , <STRING> : R , <STRING> : S } <NEWLINE> m = { <STRING> : <STRING> , <STRING> : <STRING> , <STRING> : <STRING> } <NEWLINE> command = [ ] <NEWLINE> mm = [ ] <NEWLINE> ans = 0 <NEWLINE> <NL> <NL> <NL> for i , t in enumerate ( T ) : <NEWLINE> <INDENT> if t == <STRING> : <NEWLINE> <INDENT> command = <STRING> <NEWLINE> point = P <NEWLINE> <DEDENT> elif t == <STRING> : <NEWLINE> <INDENT> command = <STRING> <NEWLINE> point = R <NEWLINE> <DEDENT> elif t == <STRING> : <NEWLINE> <INDENT> command = <STRING> <NEWLINE> point = P <NEWLINE> <NL> <DEDENT> if ( i - K >= 0 ) and ( command [ i - K ] == command ) : <NEWLINE> <INDENT> command = <STRING> <NEWLINE> point = 0 <NEWLINE> <NL> <DEDENT> ans += point <NEWLINE> command . append ( command ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> <NL> read = sys . stdin . read <NEWLINE> readline = sys . stdin . readline <NEWLINE> readlines = sys . stdin . readlines <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> INF = 1 << 60 <NEWLINE> MOD = 1000000007 <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> N , K = map ( int , readline ( ) . split ( ) ) <NEWLINE> point = list ( map ( int , readline ( ) . split ( ) ) ) <NEWLINE> T = readline ( ) . strip ( ) <NEWLINE> <NL> T = T . translate ( str . maketrans ( <STRING> , <STRING> ) ) <NEWLINE> T = list ( map ( int , T ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( K ) : <NEWLINE> <INDENT> vec = T [ i : : K ] <NEWLINE> M = len ( vec ) <NEWLINE> <NL> dp = [ [ 0 ] * 3 for _ in range ( M + 1 ) ] <NEWLINE> for j in range ( M ) : <NEWLINE> <INDENT> for k in range ( 3 ) : <NEWLINE> <INDENT> dp [ j + 1 ] [ k ] = max ( dp [ j ] [ ( k + 1 ) % 3 ] , dp [ j ] [ ( k + 2 ) % 3 ] ) <NEWLINE> if ( k + 1 ) % 3 == vec [ j ] : <NEWLINE> <INDENT> dp [ j + 1 ] [ k ] += point [ k ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> ans += max ( dp [ M ] ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE> returnimport sys <NEWLINE> <NL> <DEDENT> read = sys . stdin . read <NEWLINE> readline = sys . stdin . readline <NEWLINE> readlines = sys . stdin . readlines <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> INF = 1 << 60 <NEWLINE> MOD = 1000000007 <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> N , K = map ( int , readline ( ) . split ( ) ) <NEWLINE> point = list ( map ( int , readline ( ) . split ( ) ) ) <NEWLINE> T = readline ( ) . strip ( ) <NEWLINE> <NL> T = list ( map ( int , T . translate ( str . maketrans ( <STRING> , <STRING> ) ) ) ) <NEWLINE> <NL> hand = [ 0 ] * N <NEWLINE> ans = 0 <NEWLINE> for i , h in enumerate ( T ) : <NEWLINE> <INDENT> win = ( h - 1 ) % 3 <NEWLINE> if i >= K and win == hand [ i - K ] : <NEWLINE> <INDENT> hand [ i ] = - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> hand [ i ] = win <NEWLINE> ans += point [ win ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> return <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <NL> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> s , p , r = map ( int , input ( ) . split ( ) ) <NEWLINE> f = { <STRING> : s , <STRING> : p , <STRING> : r } <NEWLINE> t = str ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> a = i + k <NEWLINE> last = t [ i ] <NEWLINE> ans += f [ last ] <NEWLINE> while a < n - k : <NEWLINE> <INDENT> if t [ a - k ] == last : <NEWLINE> <INDENT> if t [ a + k ] == last : <NEWLINE> <INDENT> if last == <STRING> : <NEWLINE> <INDENT> last = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> last = <STRING> <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if last == <STRING> : <NEWLINE> <INDENT> if t [ a + k ] == <STRING> : <NEWLINE> <INDENT> last = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> last = <STRING> <NEWLINE> <DEDENT> <DEDENT> elif last == <STRING> : <NEWLINE> <INDENT> if t [ a + k ] == <STRING> : <NEWLINE> <INDENT> last = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> last = <STRING> <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if <NEWLINE> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT>
import sys <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> import numpy as np <NEWLINE> <NL> N , M = map ( int , sys . stdin . readline ( ) . rstrip ( ) . split ( ) ) <NEWLINE> A = np . array ( int ( x ) for x in sys . stdin . readline ( ) . rstrip ( ) . split ( ) ) <NEWLINE> <NL> A . sort ( ) <COMMENT> <NEWLINE> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> def shake_cnt ( x ) : <NEWLINE> <COMMENT> <NL> <INDENT> X = np . searchsorted ( A , x - A ) <COMMENT> <NEWLINE> return N * N - X . sum ( ) <COMMENT> <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> left = 0 <COMMENT> <NEWLINE> right = 10 ** 6 <COMMENT> <NEWLINE> while 1 < right - left : <COMMENT> <NEWLINE> <INDENT> x = ( left + right ) // 2 <NEWLINE> if shake_cnt ( x ) >= M : <NEWLINE> <INDENT> left = x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> right = x <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> X = np . searchsorted ( A , right - A ) <COMMENT> <NEWLINE> shake = N * N - X . sum ( ) <COMMENT> <NEWLINE> <NL> Acum = np . zeros ( N + 1 , np . int64 ) <COMMENT> <NEWLINE> <COMMENT> <NL> Acum [ 1 : ] = np . cumsum ( A ) <COMMENT> <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> happy = ( Acum [ - 1 ] - Acum [ X ] ) . sum ( ) + ( A * ( N - X ) ) . sum ( ) <NEWLINE> <NL> happy += ( M - shake ) * left <COMMENT> <NEWLINE> <NL> print ( happy ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> edges = [ [ ] for i in range ( n ) ] <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> edges [ a - 1 ] . append ( ( b - 1 , i ) ) <NEWLINE> edges [ b - 1 ] . append ( ( a - 1 , i ) ) <NEWLINE> <DEDENT> l = [ 0 for i in range ( n ) ] <NEWLINE> def dfs ( cur , x ) : <NEWLINE> <INDENT> res = 1 <NEWLINE> for i in edges [ cur ] : <NEWLINE> <INDENT> if i [ 1 ] != x : <NEWLINE> <INDENT> res += dfs ( i [ 0 ] , i [ 1 ] ) <NEWLINE> <DEDENT> <DEDENT> l [ x ] = res <NEWLINE> return res <NEWLINE> <DEDENT> dfs ( 0 , - 1 ) <NEWLINE> l2 = [ 1 ] <NEWLINE> i2 = pow ( 2 , mod - 2 , mod ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> l2 . append ( l2 [ - 1 ] * i2 % mod ) <NEWLINE> <DEDENT> cnt = 0 <NEWLINE> for i in l : <NEWLINE> <INDENT> cnt += ( 1 - l2 [ i ] ) * ( 1 - l2 [ n - i ] ) <NEWLINE> <DEDENT> print ( ( - n * i2 - l2 [ - 1 ] + cnt + 1 ) % mod ) <NEWLINE>
5 2 3 <NEWLINE>
def main2 ( ) : <NEWLINE> <INDENT> N , A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> d = B - A - 1 <NEWLINE> if d % 2 == 0 : <NEWLINE> <INDENT> print ( min ( B - 1 , N - A ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ( d + 1 ) // 2 ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n , a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = 0 <NEWLINE> if ( b - a ) % 2 == 0 : <NEWLINE> <INDENT> ans = ( b - a ) // 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = min ( n - a , b - 1 , ( b - a - 1 ) // 2 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
N , a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if ( b - a ) % 2 == 0 : <NEWLINE> <INDENT> ams = ( b - a ) // 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = min ( a - 1 , N - b ) + 1 + ( b - a - 1 ) // 2 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> def main ( ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <INDENT> with open ( <STRING> , <STRING> ) as f : <NEWLINE> <INDENT> N , M , V , P = list ( map ( int , f . readline ( ) . split ( ) ) ) <NEWLINE> A = list ( map ( int , f . readline ( ) . split ( ) ) ) <NEWLINE> <DEDENT> P -= 1 <COMMENT> <NEWLINE> A . sort ( reverse = True ) <COMMENT> <NEWLINE> cumsum = [ 0 ] * N <NEWLINE> cumsum [ 0 ] = A [ 0 ] <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> cumsum [ i ] = cumsum [ i - 1 ] + A [ i ] <NEWLINE> <DEDENT> q = P + 1 <NEWLINE> while q < N : <NEWLINE> <INDENT> left = cumsum [ q - 1 ] <NEWLINE> if P > 0 : <NEWLINE> <INDENT> left -= cumsum [ P - 1 ] <NEWLINE> <DEDENT> right = M * ( N - V ) + A [ q ] * ( q - P ) <NEWLINE> if A [ P ] - A [ q ] > M or left > right : <NEWLINE> <INDENT> print ( q ) <NEWLINE> return <NEWLINE> <DEDENT> q += 1 <NEWLINE> <DEDENT> print ( q ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( 6 - A - B ) <NEWLINE>
A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> x = [ A , B ] <NEWLINE> A = [ 1 , 2 , 3 ] <NEWLINE> for idx in range ( len ( A ) ) : <NEWLINE> <INDENT> if ( A [ idx ] in x ) == False : <NEWLINE> <INDENT> print ( A [ idx ] ) <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT>
a = int ( input ( ) ) <NEWLINE> b = int ( input ( ) ) <NEWLINE> n = [ 1 , 2 , 3 ] . remove ( a ) . remove ( b ) <NEWLINE> print ( n [ 0 ] ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> print ( 6 - a + b ) <NEWLINE>
a = int ( input ( ) ) <NEWLINE> b = int ( input ( ) ) <NEWLINE> <INDENT> for i in range ( 1 , 4 ) : <NEWLINE> <INDENT> if a != i and b != i : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> if ( A == 1 and B == 2 ) or ( A == 2 and B == 1 ) : <NEWLINE> <INDENT> print ( 3 ) <NEWLINE> <DEDENT> elif ( A == 2 and B == 3 ) or ( A == 3 and B == 2 ) : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> elif ( A == 1 and B == 3 ) or ( A == 3 and B == 1 ) : <NEWLINE> <INDENT> print ( 2 ) <NEWLINE> <DEDENT>
a = int ( input ( ) ) <NEWLINE> b = int ( input ( ) ) <NEWLINE> x = [ 1 , 2 , 3 ] <NEWLINE> x = x . remove ( a ) <NEWLINE> x = x . remove ( b ) <NEWLINE> print ( x [ 0 ] ) <NEWLINE>
a = int ( input ( ) ) <NEWLINE> b = int ( input ( ) ) <NEWLINE> <NL> flag1 = True <NEWLINE> flag2 = True <NEWLINE> flag3 = True <NEWLINE> <NL> if a = 1 : <NEWLINE> <INDENT> flag1 = False <NEWLINE> <DEDENT> elif a = 2 : <NEWLINE> <INDENT> flag2 = False <NEWLINE> <DEDENT> elif a = 3 : <NEWLINE> <INDENT> flag3 = False <NEWLINE> <NL> <DEDENT> if b = 1 : <NEWLINE> <INDENT> flag1 = False <NEWLINE> <DEDENT> elif b = 2 : <NEWLINE> <INDENT> flag2 = False <NEWLINE> <DEDENT> elif b = 3 : <NEWLINE> <INDENT> flag3 = False <NEWLINE> <NL> <DEDENT> if flag1 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> elif flag2 : <NEWLINE> <INDENT> print ( 2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 3 ) <NEWLINE> <DEDENT>
A = int ( input ( ) ) <NEWLINE> B = int ( input ( ) ) <NEWLINE> <NL> if ( A == 1 and B == 2 ) or ( A == 2 and B == 1 ) : <NEWLINE> <INDENT> print ( 3 ) <NEWLINE> <DEDENT> elif ( A == 1 and B == 3 ) or ( A == 3 and B == 1 ) : <NEWLINE> <INDENT> print ( 2 ) <NEWLINE> <DEDENT> elif ( A == 2 and B == 3 ) or ( A == 3 ) and B == 2 ) : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT>
X = { 1 , 2 , 3 } <NEWLINE> a = int ( input ( ) ) <NEWLINE> b = int ( input ( ) ) <NEWLINE> print ( list ( X - set ( a ) - set ( b ) ) [ 0 ] ) <NEWLINE>
A = int ( input ( ) ) <NEWLINE> B = int ( input ( ) ) <NEWLINE> for i in raneg ( 3 ) : <NEWLINE> <INDENT> if i + 1 != A & & i + 1 != B : <NEWLINE> <INDENT> print ( i + 1 ) <NEWLINE> <DEDENT> <DEDENT>
A = [ int ( input ( ) ) , int ( input ( ) ) ] <NEWLINE> if not 1 in A : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> elif not 2 in A : <NEWLINE> <INDENT> print ( 2 ) <NEWLINE> <DEDENT> else not 3 in A : <NEWLINE> <INDENT> print ( 3 ) <NEWLINE> <DEDENT>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> for i in range ( 1 , 4 ) : <NEWLINE> <INDENT> if a != i and b != i : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT> <DEDENT>
a = int ( input ( ) ) <NEWLINE> b = int ( input ( ) ) <NEWLINE> <NL> t = set ( [ 1 , 2 , 3 ] ) <NEWLINE> s = set ( [ a , b ] ) <NEWLINE> ans = t - s <NEWLINE> print ( list ( ans [ 0 ] ) ) <NEWLINE>
<COMMENT> <NL> N = int ( input ( ) ) <NEWLINE> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> moji = <STRING> <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> moji += a [ i ] + b [ i ] <NEWLINE> <NL> <DEDENT> print ( moji ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s , t = map ( input ( ) . split ( ) ) <NEWLINE> result = <STRING> <NEWLINE> for i in range ( 0 , n ) : <NEWLINE> <INDENT> result += s [ i ] <NEWLINE> reuslt += t [ i ] <NEWLINE> <DEDENT> print ( result ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S , T = map ( input ( ) . split ( ) ) <NEWLINE> <NL> res = <STRING> <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> res += S [ i ] <NEWLINE> res += T [ i ] <NEWLINE> <NL> <DEDENT> print ( res ) <NEWLINE>
a = int ( input ( ) ) <NEWLINE> b = input ( ) <NEWLINE> c = input ( ) <NEWLINE> d = <STRING> <NEWLINE> for i in range ( a ) : <NEWLINE> <INDENT> d = d + b [ i ] + c [ i ] <NEWLINE> <DEDENT> print ( d ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s , t = input ( ) . split ( ) <NEWLINE> ans = <STRING> <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ans += a [ i ] + b [ i ] <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S , T = input ( ) . split ( ) <NEWLINE> ans = S [ 0 ] + T [ 0 ] <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> ans = ans + s [ i ] + T [ i ] <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S , T = map ( , input ( ) . split ( ) ) <NEWLINE> M = len ( S ) <NEWLINE> ans = <STRING> <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> ans += S [ i ] + T [ i ] <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S , T = input ( ) . split ( ) <NEWLINE> lists = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> lists += S [ i ] <NEWLINE> lists += T [ i ] <NEWLINE> <DEDENT> print ( * lists . split ( ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s , t = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> answer_list = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> answer_list . append ( s [ i ] ) <NEWLINE> answer_list . append ( t [ i ] ) <NEWLINE> <NL> <DEDENT> s = <STRING> . join ( answer_list ) <NEWLINE> print ( s ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> t = input ( ) <NEWLINE> <NL> ans = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a . append ( s [ i ] ) <NEWLINE> a . append ( t [ i ] ) <NEWLINE> <DEDENT> print ( <STRING> . join ( a ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> T = input ( ) <NEWLINE> U = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> U . append ( S [ i ] ) <NEWLINE> U . append ( T [ i ] ) <NEWLINE> <DEDENT> print ( U ) <NEWLINE>
a , b , k = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> x = min ( a , k ) <NEWLINE> a -= x <NEWLINE> k -= x <NEWLINE> y = min ( b , k ) <NEWLINE> b -= y <NEWLINE> <NL> print ( str ( a ) , str ( b ) ) <NEWLINE>
N = input ( ) <NEWLINE> S , T = list ( map ( str , input ( ) . split ( ) ) ) <NEWLINE> <NL> A = <STRING> <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> A += S [ i ] <NEWLINE> A += T [ i ] <NEWLINE> <NL> <DEDENT> print ( A ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> t = input ( ) <NEWLINE> <NL> for ( ele , mele ) in zip ( s , t ) : <NEWLINE> <INDENT> print ( ele + mele , end = <STRING> ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> S , T = input ( ) . split <NEWLINE> <NL> l = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> l . append ( S [ i ] ) <NEWLINE> l . append ( T [ i ] ) <NEWLINE> <NL> <DEDENT> print ( <STRING> . join ( l ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S , T = input ( ) . split ( ) <NEWLINE> ST = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> ST . append ( S [ i ] ) <NEWLINE> ST . append ( T [ i ] ) <NEWLINE> <DEDENT> print ( <STRING> . join ( ST ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s , t = input ( ) . split ( ) <NEWLINE> out = <STRING> <NEWLINE> for i = range ( n ) : <NEWLINE> <INDENT> out += s [ i ] + t [ i ] <NEWLINE> <DEDENT> print ( out ) <NEWLINE>
n = input ( ) <NEWLINE> a = input ( ) <NEWLINE> b = input ( ) <NEWLINE> <NL> output = <STRING> <NEWLINE> <NL> for s , t in zip ( a , b ) : <NEWLINE> <INDENT> output += a <NEWLINE> output += b <NEWLINE> <DEDENT> print ( output ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s , t = map ( str , input ( ) . split ( ) ) <NEWLINE> a = <STRING> <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a = a [ i ] + s [ i ] + t [ i ] <NEWLINE> <DEDENT> print ( a ) <NEWLINE>
from math import gcd <NEWLINE> a , b = int ( input ( ) . split ( ) ) <NEWLINE> print ( a * b / gcd ( a , b ) ) <NEWLINE>
import math <NEWLINE> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> temp = math . gcd ( a , b ) <NEWLINE> ans = a * b // temp <NEWLINE> print ( ans <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( a * b // math . gcd ( a , b ) ) <NEWLINE>
def lcm ( x , y ) : <NEWLINE> <INDENT> return ( x * y ) // math . gcd ( x , y ) <NEWLINE> <NL> <DEDENT> def abc148c_snack ( ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( lcm ( a , b ) ) <NEWLINE> <NL> <DEDENT> abc148c_snack ( ) <NEWLINE>
import math <NEWLINE> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> def lcm ( x , y ) : <NEWLINE> <INDENT> return ( x * y ) // math . gcd ( x , y ) def lcm ( x , y ) : <NEWLINE> return ( x * y ) // math . gcd ( x , y ) <NEWLINE> <DEDENT> print ( lcm ( a , b ) ) <NEWLINE>
def lcm ( x , y ) : <NEWLINE> <INDENT> return ( x * y ) // math . gcd ( x , y ) <NEWLINE> <DEDENT> a , b = map ( int , input ( ) , split ( ) ) <NEWLINE> print ( lcm ( a , b ) ) <NEWLINE>
A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> while A != B : <NEWLINE> <INDENT> if A > B : <NEWLINE> <INDENT> A , B = B , A <NEWLINE> <DEDENT> A += A <NEWLINE> <NL> <DEDENT> print ( A ) <NEWLINE>
import math <NEWLINE> <NL> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> print ( A * B / gcd ( A , B ) ) <NEWLINE>
from math import gcd <NEWLINE> def main ( ) : <NEWLINE> <INDENT> a , b = = map ( int , input ( ) . split ( ) ) <NEWLINE> r = ( a * b ) // gcd ( a , b ) <NEWLINE> print ( r ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import math <NEWLINE> a = int ( input ( ) ) <NEWLINE> b = int ( input ( ) ) <NEWLINE> def lcm ( x , y ) : <NEWLINE> <INDENT> return ( x * y ) // math . gcd ( x , y ) <NEWLINE> <NL> <DEDENT> print ( lcm ( a , b ) ) <NEWLINE>
import numpy as np <NEWLINE> <NL> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> print ( lcm ( A , B ) ) <NEWLINE>
import math <NEWLINE> <NL> A , B = map ( int , input ( ) ) <NEWLINE> print ( A * B // math . gcd ( A , B ) ) <NEWLINE>
a , b = input ( ) . split ( ) <NEWLINE> a = int ( a ) <NEWLINE> b = int ( b ) <NEWLINE> c = 1 <NEWLINE> d = 0 <NEWLINE> if a > b : <NEWLINE> <INDENT> for i in range ( 1 , a ) : <NEWLINE> <INDENT> if a % ( a - i ) == 0 and b % ( b - i ) == 0 : <NEWLINE> <INDENT> a = a / ( a - i ) <NEWLINE> b = b / ( a - i ) <NEWLINE> c = c * ( a - i ) <NEWLINE> <DEDENT> <DEDENT> print ( int ( a * b * c ) ) <NEWLINE> <DEDENT> if a < b : <NEWLINE> <INDENT> for i in range ( 1 , b ) : <NEWLINE> <INDENT> if a % ( b - i ) == 0 and b % ( b - i ) == 0 : <NEWLINE> <INDENT> a = a / ( b - i ) <NEWLINE> b = b / ( a - i ) <NEWLINE> c = c * ( b - i ) <NEWLINE> <DEDENT> <DEDENT> print ( int ( a * b * c ) ) <NEWLINE> <DEDENT>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> lcm = 0 <NEWLINE> for i in range ( 1 , B + 1 ) : <NEWLINE> <INDENT> if ( A * i ) % B == 0 : <NEWLINE> <INDENT> lcm = A * i <NEWLINE> <NL> <DEDENT> <DEDENT> print ( lcm ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if ( 1 in a ) : <NEWLINE> <INDENT> ans = 0 <NEWLINE> jud = 0 <NEWLINE> f = 1 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if ( p [ 0 ] != f ) : <NEWLINE> <INDENT> del p [ 0 ] <NEWLINE> ans += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> f += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT>
<NL> N = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> <NL> t = 1 <NEWLINE> for x in a : <NEWLINE> <INDENT> if x == t : <NEWLINE> <INDENT> t += 1 <NEWLINE> <DEDENT> <DEDENT> t -= 1 <NEWLINE> <NL> if t == 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( M - t ) <NEWLINE> <NL> <DEDENT>
a = int ( input ( ) ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c = 1 <NEWLINE> ans = 0 <NEWLINE> for i in range b : <NEWLINE> <INDENT> if i == c : <NEWLINE> <INDENT> c += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> if ans == a : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n = input ( ) <NEWLINE> renga = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> <NL> ni = 1 <NEWLINE> remains = 0 <NEWLINE> <NL> for r in renga : <NEWLINE> <INDENT> if ni == r : <NEWLINE> <INDENT> ni += 1 <NEWLINE> remains += 1 <NEWLINE> <DEDENT> <DEDENT> if ni == 1 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( renga - remains ) <NEWLINE> <DEDENT>
import math <NEWLINE> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( int ( A * B / math . gcd ( A , B ) ) ) <NEWLINE>
class Stack : <NEWLINE> <INDENT> def __init__ ( self ) : <NEWLINE> <INDENT> self . count = 1 <NEWLINE> self . lst = [ ] <NEWLINE> <NL> <DEDENT> def push ( self , element ) : <NEWLINE> <INDENT> if element == count : <NEWLINE> <INDENT> self . lst . append ( element ) <NEWLINE> self . count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> def length ( self ) : <NEWLINE> <INDENT> return len ( self . lst ) <NEWLINE> <NL> <DEDENT> <DEDENT> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> stack = Stack ( ) <NEWLINE> for i in a : <NEWLINE> <INDENT> stack . push ( i ) <NEWLINE> <NL> <DEDENT> b = stack . length ( ) <NEWLINE> if b == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( n - b ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> M = 10 <NEWLINE> ans = 0 <NEWLINE> <NL> if N % 2 == 0 <NEWLINE> <INDENT> while N > M : <NEWLINE> <INDENT> ans += N // M <NEWLINE> M *= 5 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> n = int ( input ( ) ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> if n == 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if n % 2 == 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = 0 <NEWLINE> l = 10 <NEWLINE> while n >= l : <NEWLINE> <INDENT> ans += floor ( n / ( l ) ) <NEWLINE> l *= 5 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <DEDENT> <DEDENT>
a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> if a + b + c = > 22 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
<COMMENT> <NL> a = [ map ( int , input ( ) . split ( ) ) ] <NEWLINE> print ( <STRING> if sum ( a ) >= 22 else <STRING> ) <NEWLINE>
print ( <STRING> if sum ( list ( map , input ( ) . split ( ) ) ) >= 22 else <STRING> ) <NEWLINE>
a , b , c = map ( int , input ( ) , split ( ) ) <NEWLINE> if a + b + c >= 22 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
A = list ( map ( int , input ( ) . split ( ) ) <NEWLINE> a = sum ( A ) <NEWLINE> if a >= 22 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> if a + b + c >= 22 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> main ( ) <NEWLINE>
a = int ( input ( ) ) <NEWLINE> b = int ( input ( ) ) <NEWLINE> c = int ( input ( ) ) <NEWLINE> if ( a + b + c ) >= 22 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
print ( <STRING> if sun ( map ( int , input ( ) . split ( ) ) ) <= 21 else <STRING> ) <NEWLINE>
<COMMENT> <NL> N = int ( input ( ) ) <NEWLINE> A = [ ] <NEWLINE> X = [ ] <NEWLINE> Y = [ ] <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> a = int ( input ( ) ) <NEWLINE> A . append ( a ) <NEWLINE> box_x = [ ] <NEWLINE> box_y = [ ] <NEWLINE> for _ in range ( a ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> box_x . append ( x ) <NEWLINE> box_y . append ( y ) <NEWLINE> <DEDENT> X . append ( box_x ) <NEWLINE> Y . append ( box_y ) <NEWLINE> <NL> <DEDENT> person = [ 2 ] * N <NEWLINE> <NL> maxim = 0 <NEWLINE> for i in range ( 1 << N ) : <NEWLINE> <INDENT> c_person = person . copy ( ) <NEWLINE> honest = 0 <NEWLINE> for j in range ( N ) : <NEWLINE> <INDENT> mask = 1 << j <NEWLINE> if mask & i != 0 : <NEWLINE> <INDENT> c_person [ j ] = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> c_person [ j ] = 0 <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> for k , l in enumerate ( c_person ) : <NEWLINE> <COMMENT> <NL> <INDENT> if l == 1 : <NEWLINE> <COMMENT> <NL> <INDENT> for m , n in zip ( X [ k ] , Y [ k ] ) : <NEWLINE> <COMMENT> <NL> <INDENT> if c_person [ m - 1 ] != n : <NEWLINE> <INDENT> honest = 0 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> honest = sum ( c_person ) <NEWLINE> continue <NEWLINE> <DEDENT> break <NEWLINE> <DEDENT> <DEDENT> maxim = max ( maxim , honest ) <NEWLINE> <NL> <DEDENT> print ( maxim ) <NEWLINE>
A1 , A2 , A3 = input ( ) . split ( ) <NEWLINE> <NL> T = A1 + A2 + A3 <NEWLINE> <NL> if T > 21 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b , c = map ( int , input ( ) split ( ) ) <NEWLINE> sum = a + b + c <NEWLINE> <NL> if sum >= 22 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b , c = map ( int , input ( ) ) <NEWLINE> if a + b + c >= 22 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
A , B , C = int ( input ( ) ) <NEWLINE> if A + B + C <= 21 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
A = list ( map ( int , input ( ) split ( ) ) ) <NEWLINE> B = 0 <NEWLINE> B = A [ 0 ] + A [ 1 ] + A [ 2 ] <NEWLINE> if B >= 22 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
if sum ( map ( int , input ( ) . split ( ) ) > 21 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
A = input ( ) ; print ( sum ( i != j for i , j in zip ( A , A [ : : - 1 ] ) // 2 ) <NEWLINE>
s = input ( ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( len ( s ) // 2 + 1 ) : <NEWLINE> <INDENT> if s [ i ] != s [ len ( s ) - 1 - i ] : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
s = int ( input ( ) ) <NEWLINE> s_r = s [ : : - 1 ] <NEWLINE> cnt = 0 <NEWLINE> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> if s [ i ] != s_r [ i ] : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> print ( cnt // 2 ) <NEWLINE>
S = input ( ) <NEWLINE> hug = 0 <NEWLINE> if len ( S ) % 2 == 0 : <NEWLINE> <INDENT> for i in range ( len ( S / 2 ) ) : <NEWLINE> <INDENT> if not S [ i ] == S [ - i - 1 ] : <NEWLINE> <INDENT> hug += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( int ( ( len ( S ) + 1 ) / 2 ) ) : <NEWLINE> <INDENT> if not S [ i ] == S [ - i - 1 ] : <NEWLINE> <INDENT> hug += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( hug ) <NEWLINE>
s = input ( ) <NEWLINE> n = len ( s ) // 2 <NEWLINE> p = n <NEWLINE> j = - 1 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> if n [ i ] == n [ j ] : <NEWLINE> <INDENT> p -= 1 <NEWLINE> <DEDENT> j -= 1 <NEWLINE> <NL> <DEDENT> print ( p ) <NEWLINE>
S = input ( ) <NEWLINE> <NL> cnt = 0 <NEWLINE> for i in range ( S // 2 ) : <NEWLINE> <INDENT> if S [ i ] != S [ len ( S ) - 1 - i ] : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
A = input ( ) <NEWLINE> c = 0 <NEWLINE> B = A [ : : - 1 ] <NEWLINE> for i in range ( len ( A ) ) : <NEWLINE> <INDENT> if A [ i ] != B [ i ] : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> print ( cnt // 2 ) <NEWLINE>
s = int ( input ( ) ) <NEWLINE> cnt = 0 <NEWLINE> for s1 , s2 in zip ( s , s [ : : - 1 ] ) : <NEWLINE> <INDENT> if s1 != s2 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> print ( cnt // 2 ) <NEWLINE>
s = input ( ) <NEWLINE> t = s <NEWLINE> ans = 0 <NEWLINE> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> ans += 1 - s [ i ] == t [ i ] <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
s = input ( ) <NEWLINE> t = 0 <NEWLINE> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> if s [ i ] != s [ : : - 1 ] [ i ] : <NEWLINE> <INDENT> t += 1 <NEWLINE> <DEDENT> <DEDENT> ptint ( t // 2 ) <NEWLINE>
s = input ( ) ; n = len ( s ) - 1 ; print ( sum ( s [ i ] != s [ n - i ] for i in range ( n + 1 ) ) // 2 ) s = input ( ) ; n = len ( s ) - 1 ; print ( sum ( s [ i ] != s [ n - i ] for i in range ( n + 1 ) ) // 2 ) <NEWLINE>
a = input ( ) <NEWLINE> b = 0 <NEWLINE> for i in range ( len ( a ) ) : <NEWLINE> <INDENT> if a [ i ] != a [ len ( a ) - i ] : <NEWLINE> <INDENT> b = b + 1 <NEWLINE> <DEDENT> <DEDENT> print ( int ( b / 2 ) ) <NEWLINE>
s = input ( ) <NEWLINE> s1 = s [ : s // 2 ] <NEWLINE> s2 = s [ - 1 * ( s // 2 ) : ] <NEWLINE> ans = 0 <NEWLINE> for i in range ( s // 2 ) : <NEWLINE> <INDENT> if s1 [ i ] != s2 [ i ] : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = [ ] <NEWLINE> xy = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> a = int ( input ( ) ) <NEWLINE> A . append ( a ) <NEWLINE> for j in range ( a ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> <COMMENT> <NL> xy . append ( [ x , y ] ) <NEWLINE> <DEDENT> <DEDENT> print ( xy ) <NEWLINE> <NL> honest = 0 <NEWLINE> <NL> for i in range ( 1 , 2 ** N ) : <NEWLINE> <INDENT> flag = 0 <NEWLINE> for j in range ( N ) : <NEWLINE> <COMMENT> <NL> <INDENT> if ( i >> j ) & 1 == 1 : <NEWLINE> <INDENT> for x , y in xy [ j ] : <NEWLINE> <COMMENT> <NL> <INDENT> if ( i >> x ) & 1 != y : <NEWLINE> <INDENT> flag = 1 <NEWLINE> break <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if flag == 0 : <NEWLINE> <INDENT> honest = max ( honest , bin ( i ) [ 2 : ] . count ( <STRING> ) ) <NEWLINE> <DEDENT> <DEDENT> print ( honest ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> ls = [ 0 ] * n <NEWLINE> param_list = [ 0 ] * 2 ** n <NEWLINE> for i in range ( 2 ** n ) : <NEWLINE> <INDENT> l = [ False ] * n <NEWLINE> for id_r , row in enumerate ( ls ) : <NEWLINE> <INDENT> if i & ( 2 ** id_r ) > 0 : <NEWLINE> <INDENT> l [ id_r ] = True <NEWLINE> <DEDENT> <DEDENT> param_list [ i ] = l <NEWLINE> <COMMENT> <NL> <DEDENT> <STRING> <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> A = int ( input ( ) ) <NEWLINE> for k in range ( A ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> b = ( 1 == b ) <NEWLINE> new_param = [ ] <NEWLINE> for d in a_list : <NEWLINE> <INDENT> if d [ i ] : <NEWLINE> <INDENT> if d [ a - 1 ] == b : <NEWLINE> <INDENT> new_param . append ( d ) <NEWLINE> pass <NEWLINE> <DEDENT> else : <NEWLINE> <COMMENT> <NL> <INDENT> pass <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> new_param . append ( d ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> param_list = new_param <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for d in param_list : <NEWLINE> <INDENT> ans = max ( ans , d . count ( True ) ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> tst = [ [ ] for i in range ( n ) ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a = int ( input ( ) ) <NEWLINE> for j in range ( a ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> st [ i ] . append ( [ x , y ] ) <NEWLINE> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for bit in range ( 1 << n ) : <NEWLINE> <INDENT> honest = [ 0 ] * n <NEWLINE> check = 1 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if ( bit >> i ) & 1 : <NEWLINE> <INDENT> honest [ - 1 - i ] = 1 <NEWLINE> <DEDENT> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> if not honest [ i ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> for l in tst [ i ] : <NEWLINE> <INDENT> if l [ 1 ] != honest [ l [ 0 ] - 1 ] : <NEWLINE> <INDENT> check = 0 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if check : <NEWLINE> <INDENT> ans = max ( ans , sum ( honest ) ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> ListN = [ ] * <NEWLINE> List = [ ] <NEWLINE> keepOrder <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> k = int ( input ( ) ) <NEWLINE> ListN . append ( k ) <NEWLINE> for j in range ( k ) : <NEWLINE> <INDENT> List . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <DEDENT> <DEDENT> for bits in range ( 2 ** N ) : <NEWLINE> <INDENT> keepOrder = list ( bin ( bits ) ) <NEWLINE> flag = True <NEWLINE> print ( bits , keepOrder ) <NEWLINE> for j in range ( N ) : <NEWLINE> <INDENT> if ( ( bits >> j ) & 1 ) : <NEWLINE> <INDENT> for k in range ( ListN [ j ] ) : <NEWLINE> <INDENT> if keepOrder [ List [ k ] [ 0 ] - 1 ] != List [ k ] [ 1 ] : <NEWLINE> <INDENT> flag = False <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if keepOrder [ List [ k ] [ 0 ] - 1 ] == List [ k ] [ 1 ] : <NEWLINE> <INDENT> flag = False <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if flag : <NEWLINE> <INDENT> res = max ( res , keepOrder . count ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> print ( res ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> XY = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a = int ( input ( ) ) <NEWLINE> xy = [ ] <NEWLINE> for j in range ( a ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> xy . append ( [ x , y ] ) <NEWLINE> <DEDENT> XY . append ( xy ) <NEWLINE> <DEDENT> ans = 0 <NEWLINE> for k in range ( 2 ** n ) : <NEWLINE> <INDENT> s = [ 0 ] * n <NEWLINE> cnt = 0 <NEWLINE> case = 0 <NEWLINE> for j in range ( n ) : <NEWLINE> <INDENT> if ( k >> j ) & 1 : <NEWLINE> <INDENT> s [ n - 1 - j ] = 1 <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> for k in range ( n ) : <NEWLINE> <INDENT> if s [ k ] == 1 : <NEWLINE> <INDENT> for l in range ( len ( XY [ l ] ) ) : <NEWLINE> <INDENT> if s [ XY [ k ] [ l ] [ 0 ] - 1 ] != XY [ k ] [ l ] [ 1 ] : <NEWLINE> <INDENT> case = 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if case == 0 : <NEWLINE> <INDENT> ans = max ( ans , cnt ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> testimony = [ [ - 1 ] * N for i in range ( N ) ] <NEWLINE> count = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> A = int ( input ( ) ) <NEWLINE> for j in range ( A ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> testimony [ i ] [ x - 1 ] = y <NEWLINE> <DEDENT> <DEDENT> fro i in range ( 2 ** N ) : <NEWLINE> <INDENT> honest = [ 0 ] * N <NEWLINE> for j in range ( N ) : <NEWLINE> <INDENT> if ( i >> j ) & 1 : <NEWLINE> <INDENT> honest [ j ] = 1 <NEWLINE> <DEDENT> <DEDENT> flag = True <NEWLINE> for j in range ( N ) : <NEWLINE> <INDENT> if honest [ j ] == 1 : <NEWLINE> <INDENT> for k in range ( N ) : <NEWLINE> <INDENT> if testimony [ j ] [ k ] == - 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if testimony [ j ] [ k ] != honest [ k ] : <NEWLINE> <INDENT> flag = False <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if flag == True : <NEWLINE> <INDENT> count = max ( count , hones . count ( 1 ) ) <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
<COMMENT> <NL> import sys <NEWLINE> sys . setrecursionlimit ( 2000 ) <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> syogen = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> N_a = int ( input ( ) ) <NEWLINE> syogen_a = [ ] <NEWLINE> for _ in range ( N_a ) : <NEWLINE> <INDENT> x , y = input ( ) . split ( ) <NEWLINE> syogen_a . append ( [ int ( x ) - 1 , int ( y ) ] ) <NEWLINE> <DEDENT> syogen . append ( syogen_a ) <NEWLINE> <NL> <NL> <DEDENT> def syojiki ( i ) : <NEWLINE> <INDENT> for x , y in syogen [ i ] : <NEWLINE> <INDENT> if y == 1 : <NEWLINE> <INDENT> syojiki_list . append ( x ) <NEWLINE> if len ( syojiki_list ) >= N : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> syojiki ( x ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> def check_syojiki ( syojikitati ) : <NEWLINE> <INDENT> d = { } <NEWLINE> for s in range ( N ) : <NEWLINE> <INDENT> if not ( s in syojikitati ) : <NEWLINE> <INDENT> d [ s ] = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> for s in syojikitati : <NEWLINE> <INDENT> d [ s ] = 1 <NEWLINE> for x , y in syogen [ s ] : <NEWLINE> <INDENT> if d [ x ] != y : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d [ x ] = y <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return True <NEWLINE> <NL> <NL> <DEDENT> max_syojiki = 0 <NEWLINE> <NL> for i in range ( 2 ** N ) : <NEWLINE> <INDENT> d = { } <NEWLINE> syojiki_list = [ ] <NEWLINE> for j in range ( N ) : <NEWLINE> <INDENT> if ( i >> j ) & 1 : <NEWLINE> <INDENT> syojiki_list . append ( j ) <NEWLINE> syojiki ( j ) <NEWLINE> <DEDENT> <DEDENT> syojiki_list = list ( set ( syojiki_list ) ) <NEWLINE> if check_syojiki ( syojiki_list ) : <NEWLINE> <INDENT> max_syojiki = max ( max_syojiki , len ( syojiki_list ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( max_syojiki ) <NEWLINE>
from itertools import product <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> xy = [ [ ] for i in range ( N ) ] <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> for j i range ( int ( input ( ) ) ) : <NEWLINE> <INDENT> xy [ i ] . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for bit in product ( [ 0 , 1 ] , repeat = N ) : <NEWLINE> <INDENT> f = 0 <NEWLINE> for i , j in enumerate ( bit ) : <NEWLINE> <INDENT> if j == 1 : <NEWLINE> <INDENT> for x , y in xy [ i ] : <NEWLINE> <INDENT> if bit [ x - 1 ] != y : <NEWLINE> <INDENT> f = 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if f == 0 : <NEWLINE> <INDENT> ans = max ( ans , sum ( bit ) ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> XY = [ [ [ ] ] for n in range ( N ) ] <NEWLINE> for n in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> a = int ( input ( ) ) <NEWLINE> XY [ n ] = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( a ) ] <NEWLINE> <NL> <DEDENT> maxH = 0 <NEWLINE> for mask_i in range ( 1 << N ) : <NEWLINE> <NL> <INDENT> H = [ 0 ] * ( N + 1 ) <NEWLINE> for n in range ( N ) : <NEWLINE> <INDENT> if mask_i >> n & 1 : <NEWLINE> <INDENT> H [ n + 1 ] = 1 <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> for n in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> ok = True <NEWLINE> if H [ n ] == 1 : <NEWLINE> <INDENT> for x , y in XY [ n ] : <NEWLINE> <INDENT> if H [ x ] != y : <NEWLINE> <INDENT> ok = False <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if ok : <NEWLINE> <INDENT> maxH = max ( maxH , sum ( H ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( maxH ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> g = [ [ - 1 ] * 15 for _ in range ( 15 ) ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> m = int ( input ( ) ) <NEWLINE> for j in range ( n ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> <COMMENT> <NL> g [ i ] [ x - 1 ] = y <NEWLINE> <NL> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for i in range ( 1 << n ) : <NEWLINE> <INDENT> honest = [ 0 ] * n <NEWLINE> for j in range ( n ) : <NEWLINE> <INDENT> if ( i >> j ) & 1 == 1 : <NEWLINE> <INDENT> honest [ j ] = 1 <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> ok = True <NEWLINE> for j in range ( n ) : <NEWLINE> <INDENT> if honest [ j ] : <COMMENT> <NEWLINE> <INDENT> for k in range ( n ) : <NEWLINE> <INDENT> if g [ j ] [ k ] == - 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if g [ i ] [ j ] != honest [ k ] : <NEWLINE> <INDENT> ok = False <NEWLINE> <DEDENT> <DEDENT> if ok : <NEWLINE> <INDENT> ans = max ( ans , honest . count ( 1 ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> XY = [ [ ] for _ in range ( n ) ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( int ( input ( ) ) ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> XY [ i ] . append ( [ x - 1 , y ] ) <NEWLINE> <DEDENT> <DEDENT> honest = 0 <NEWLINE> for bit in range ( 1 << n ) : <NEWLINE> <INDENT> flag = True <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if bit & ( 1 << i ) : <NEWLINE> <INDENT> for a , b in XY [ i ] : <NEWLINE> <INDENT> if bit & ( 1 << a ) != b : <NEWLINE> <INDENT> flag = False <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if flag : <NEWLINE> <INDENT> honest = max ( honest , bin ( i ) [ 2 : ] . count ( <STRING> ) ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> import sys <NEWLINE> from io import StringIO <NEWLINE> import unittest <NEWLINE> import copy <NEWLINE> <NL> <NL> class TestClass ( unittest . TestCase ) : <NEWLINE> <INDENT> def assertIO ( self , input , output ) : <NEWLINE> <INDENT> stdout , stdin = sys . stdout , sys . stdin <NEWLINE> sys . stdout , sys . stdin = StringIO ( ) , StringIO ( input ) <NEWLINE> resolve ( ) <NEWLINE> sys . stdout . seek ( 0 ) <NEWLINE> out = sys . stdout . read ( ) [ : - 1 ] <NEWLINE> sys . stdout , sys . stdin = stdout , stdin <NEWLINE> self . assertEqual ( out , output ) <NEWLINE> <NL> <DEDENT> def test__1 ( self ) : <NEWLINE> <INDENT> input = <STRING> <NEWLINE> output = <STRING> <NEWLINE> self . assertIO ( input , output ) <NEWLINE> <NL> <DEDENT> def test__2 ( self ) : <NEWLINE> <INDENT> input = <STRING> <NEWLINE> output = <STRING> <NEWLINE> self . assertIO ( input , output ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def resolve ( ) : <NEWLINE> <INDENT> R , C = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( R ) ] <NEWLINE> A_rev = [ [ 1 - v for v in a ] for a in A ] <NEWLINE> <NL> ans = 0 <NEWLINE> for bit in range ( 1 << R ) : <NEWLINE> <INDENT> num = 0 <NEWLINE> T = copy . deepcopy ( A ) <NEWLINE> for i , t in enumerate ( T ) : <NEWLINE> <INDENT> if 1 << i & bit : <NEWLINE> <INDENT> T [ i ] = A_rev [ i ] <NEWLINE> <NL> <DEDENT> <DEDENT> T = list ( zip ( * T ) ) <NEWLINE> for t in T : <NEWLINE> <INDENT> num += max ( t . count ( 0 ) , t . count ( 1 ) ) <NEWLINE> <DEDENT> ans = max ( ans , num ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <COMMENT> <NL> <INDENT> resolve ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> mod = 10e9 + 7 <NEWLINE> ans = 0 <NEWLINE> for i in range ( 60 ) : <NEWLINE> <INDENT> x = 1 << i <NEWLINE> n = len ( [ 1 for j in a if j & X ] ) <NEWLINE> ans += x * n * ( N - n ) % mod <NEWLINE> ans %= mod <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
N , * A = map ( int , open ( 0 ) . read ( ) . split ( ) ) <NEWLINE> A = np . array ( A , dtype = np . int64 ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( 60 ) : <NEWLINE> <INDENT> mask = 1 << i <NEWLINE> cnt = np . count_nonzero ( A & mask ) <NEWLINE> x = cnt * ( N - cnt ) <NEWLINE> x *= mask % mod <NEWLINE> ans += x <NEWLINE> ans %= mod <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
md1 = map ( int , input ( ) . split ( ) ) <NEWLINE> md2 = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> print ( 1 if md1 [ 0 ] != md2 [ 0 ] else 0 ) <NEWLINE>
MD = [ map ( int , input ( ) . split ( ) ) for _ in range ( N ) ] <NEWLINE> M , D = [ list ( i ) for i in zip ( * MD ) ] <NEWLINE> <NL> if D [ 1 ] == 1 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( [ 0 , 1 ] [ a == b + 1 ] <NEWLINE>
N = int ( input ( ) ) <NEWLINE> <NL> ans = <STRING> <NEWLINE> <NL> for X in range ( N - 1 ) : <NEWLINE> <INDENT> if int ( X * 1.08 ) = N : <NEWLINE> <INDENT> ans = X <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> <NL> ans = - 1 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if math . floor ( float ( i ) * 1.08 ) == N : <NEWLINE> <INDENT> ans = i <NEWLINE> <NL> <DEDENT> <DEDENT> if ans == - 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> m = rond ( n / 1.08 ) <NEWLINE> if int ( m * 1.08 ) == n : <NEWLINE> <INDENT> print ( m ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if int ( ( m - 1 ) * 1.08 ) == n : <NEWLINE> <INDENT> print ( m - 1 ) <NEWLINE> <DEDENT> elif int ( ( m + 1 ) * 1.08 ) == n : <NEWLINE> <INDENT> print ( m + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> from collections import deque <NEWLINE> import numpy as np <NEWLINE> import math <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> def S ( ) : return sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> def SL ( ) : return map ( str , sys . stdin . readline ( ) . rstrip ( ) . split ( ) ) <NEWLINE> def I ( ) : return int ( sys . stdin . readline ( ) . rstrip ( ) ) <NEWLINE> def IL ( ) : return map ( int , sys . stdin . readline ( ) . rstrip ( ) . split ( ) ) <NEWLINE> <NL> def solve ( ) : <NEWLINE> <INDENT> f = math . ceil ( m / 1.08 ) <NEWLINE> if math . floor ( f * 1.08 ) == n : <NEWLINE> <INDENT> print ( f ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> return <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> n = I ( ) <NEWLINE> solve ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> num = round ( n / 1.08 ) <NEWLINE> check = round ( num * 1.08 ) <NEWLINE> if check == n <NEWLINE> <INDENT> print ( num ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> S = math . ceil ( N / 1.08 ) <NEWLINE> if S * 1.08 != N : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( S ) <NEWLINE> <DEDENT>
import math <NEWLINE> N = float ( input ( ) ) <NEWLINE> a = math . ceil ( N / ( 1.08 ) ) <NEWLINE> for i in range ( a , N ) : <NEWLINE> <INDENT> if math . floor ( i * 1.08 ) == N : <NEWLINE> <INDENT> print ( a ) <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> flag = False <NEWLINE> for i in range ( 100 * n , 100 * ( n + 1 ) ) : <NEWLINE> <INDENT> if i % 108 == 0 : <NEWLINE> <INDENT> x == int ( i // 108 ) <NEWLINE> print ( x ) <NEWLINE> flag == True <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if flag == False : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import math <NEWLINE> N = int ( input ( ) ) <NEWLINE> s = N / 1.08 <NEWLINE> s = math . ceil ( s ) <NEWLINE> t = s * 1.08 <NEWLINE> t = math . floor ( t ) <NEWLINE> if N == t : <NEWLINE> <INDENT> input ( s ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> input ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> x = n / 1.08 <NEWLINE> nn = x * 1.08 <NEWLINE> if n <= nn < n + 1 : <NEWLINE> <INDENT> if x * 10 % 10 >= 5 : <NEWLINE> print ( int ( x ) + 1 ) <NEWLINE> else : <NEWLINE> <INDENT> print ( int ( x ) ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
def main2 ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> x = int ( math . ceil ( n / 1.08 ) ) <NEWLINE> <NL> if int ( x * 1.08 ) == n : <NEWLINE> <INDENT> print ( x ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main2 ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> ans = : ( <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> if int ( ( i * 1.08 ) // 1 ) == n : <NEWLINE> <INDENT> ans = i <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = N / 1.08 <NEWLINE> B = ( N + 1 ) / 1.08 <NEWLINE> <NL> if math . ceil ( A ) < math . ceil ( B ) : <NEWLINE> <INDENT> print ( ceil ( A ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
x = int ( input ( ) ) <NEWLINE> kosuu , amari = x // 100 , x % 100 <NEWLINE> ans = 0 <NEWLINE> <NL> for i in kosuu : <NEWLINE> <INDENT> amari -= 5 <NEWLINE> if amari <= 0 : <NEWLINE> <INDENT> ans = 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
x = int ( input ( ) ) <NEWLINE> dp = [ 0 ] * ( x + 1 ) <NEWLINE> dp [ 100 ] = 1 <NEWLINE> dp [ 101 ] = 1 <NEWLINE> dp [ 102 ] = 1 <NEWLINE> dp [ 103 ] = 1 <NEWLINE> dp [ 104 ] = 1 <NEWLINE> dp [ 105 ] = 1 <NEWLINE> <NL> for i in range ( 100 , x + 1 ) : <NEWLINE> <INDENT> for j in range ( 100 , 106 ) : <NEWLINE> <INDENT> dp [ i + j ] = max ( dp [ i ] , dp [ i + j ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( dp [ x ] ) <NEWLINE>
X = int ( input ( ) ) <NEWLINE> for i1 in range ( 1000000 ) : <NEWLINE> <INDENT> for i2 in range ( 1000000 ) : <NEWLINE> <INDENT> for i3 in range ( 1000000 ) : <NEWLINE> <INDENT> for i4 in range ( 1000000 ) : <NEWLINE> <INDENT> for i5 in range ( 1000000 ) : <NEWLINE> <INDENT> for i6 in range ( 1000000 ) : <NEWLINE> <INDENT> if 100 * i1 + 101 * i2 + 102 * i3 + 103 * i4 + 104 * i5 + 105 * i6 == X : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT>
dp = [ Yes ] <COMMENT> <NEWLINE> for i in range ( 99 ) : <NEWLINE> <INDENT> dp . append ( No ) <NEWLINE> <DEDENT> for i in range ( 100 , x + 1 ) : <NEWLINE> <INDENT> if ( i < 106 ) : <NEWLINE> <INDENT> dp . append ( Yes ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if ( ( dp [ i - 100 ] == Yes ) or ( dp [ i - 101 ] == Yes ) or ( dp [ i - 102 ] == Yes ) or ( dp [ i - 103 ] == Yes ) or ( dp [ i - 104 ] == Yes ) or ( dp [ i - 105 ] == Yes ) ) : <NEWLINE> <INDENT> dp [ i ] . append ( Yes ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dp [ i ] . append ( No ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( dp [ x ] ) <NEWLINE>
X = int ( input ( ) ) <NEWLINE> number = X // 100 <NEWLINE> teen = X % 100 <NEWLINE> <NL> elif teen <= 5 * number : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT>
import re <NEWLINE> import sys <NEWLINE> import math <NEWLINE> import itertools <NEWLINE> import bisect <NEWLINE> from copy import copy <NEWLINE> from collections import deque , Counter <NEWLINE> from decimal import Decimal <NEWLINE> import functools <NEWLINE> def v ( ) : return input ( ) <NEWLINE> def k ( ) : return int ( input ( ) ) <NEWLINE> def S ( ) : return input ( ) . split ( ) <NEWLINE> def I ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def X ( ) : return list ( input ( ) ) <NEWLINE> def L ( ) : return list ( input ( ) . split ( ) ) <NEWLINE> def l ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> def lcm ( a , b ) : return a * b // math . gcd ( a , b ) <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> cnt = 1 <NEWLINE> ans = 0 <NEWLINE> inf = float ( <STRING> ) <NEWLINE> al = <STRING> <NEWLINE> AL = al . upper ( ) <NEWLINE> <NL> n = k ( ) <NEWLINE> s = v ( ) <NEWLINE> <NL> s1 , s2 , s3 = set ( ) , set ( ) , set ( ) <NEWLINE> for x in S : <NEWLINE> <INDENT> for z in s2 : <NEWLINE> <INDENT> s3 . add ( z + x ) <NEWLINE> <DEDENT> for y in s1 : <NEWLINE> <INDENT> s2 . add ( y + x ) <NEWLINE> <DEDENT> s1 . add ( x ) <NEWLINE> <DEDENT> print ( len ( s3 ) ) <NEWLINE> <NL>
<COMMENT> <NL> <COMMENT> <NL> from queue import Queue <NEWLINE> from queue import LifoQueue as Stack <NEWLINE> from math import sqrt , floor , ceil , log2 , log10 , pi <NEWLINE> from fractions import gcd <NEWLINE> from itertools import permutations , combinations <NEWLINE> from operator import itemgetter <NEWLINE> from functools import cmp_to_key <NEWLINE> <NL> <NL> INF = 1001001001 <NEWLINE> __MOD__ = ( 10 ** 9 ) + 7 <NEWLINE> yn = <STRING> <NEWLINE> judge = False <NEWLINE> cnt = 0 <NEWLINE> ans = None <NEWLINE> <NL> <NL> def lcm ( a , b ) : <NEWLINE> <INDENT> return ( a * b ) // gcd ( a , b ) <NEWLINE> <NL> <DEDENT> def intinput ( ) : <NEWLINE> <INDENT> return int ( input ( ) ) <NEWLINE> <NL> <DEDENT> def mulinputs ( ) : <NEWLINE> <INDENT> return map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <DEDENT> def lineinputs ( func = intinput ) : <NEWLINE> <INDENT> datas = [ ] <NEWLINE> while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> datas . append ( func ( ) ) <NEWLINE> <DEDENT> except EOFError : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> return datas <NEWLINE> <NL> <DEDENT> class ModInt ( ) : <NEWLINE> <INDENT> def __init__ ( self , x ) : <NEWLINE> <INDENT> self . __x = ( x % __MOD__ ) <NEWLINE> <DEDENT> def __add__ ( self , other ) : <NEWLINE> <INDENT> if type ( other ) == int : <NEWLINE> <INDENT> other = self . __class__ ( other ) <NEWLINE> return int ( self . __class__ ( ( self . __x + other . __x ) % __MOD__ ) ) <NEWLINE> <DEDENT> elif type ( other ) == ModInt : <NEWLINE> <INDENT> return self . __class__ ( ( self . __x + other . __x ) % __MOD__ ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> raise Exception ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> def __radd__ ( self , other ) : <NEWLINE> <INDENT> if type ( other ) == int : <NEWLINE> <INDENT> other = self . __class__ ( other ) <NEWLINE> return int ( self . __class__ ( ( other . __x + self . __x ) % __MOD__ ) ) <NEWLINE> <DEDENT> elif type ( other ) == ModInt : <NEWLINE> <INDENT> return self . __class__ ( ( other . __x + self . __x ) % __MOD__ ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> raise Exception ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> def __sub__ ( self , other ) : <NEWLINE> <INDENT> if type ( other ) == int : <NEWLINE> <INDENT> other = self . __class__ ( other ) <NEWLINE> return int ( self . __class__ ( ( self . __x - other . __x ) % __MOD__ ) ) <NEWLINE> <DEDENT> elif type ( other ) == ModInt : <NEWLINE> <INDENT> return self . __class__ ( ( self . __x - other . __x ) % __MOD__ ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> raise Exception ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> def __rsub__ ( self , other ) : <NEWLINE> <INDENT> if type ( other ) == int : <NEWLINE> <INDENT> other = self . __class__ ( other ) <NEWLINE> return int ( self . __class__ ( ( other . __x - self . __x ) % __MOD__ ) ) <NEWLINE> <DEDENT> elif type ( other ) == ModInt : <NEWLINE> <INDENT> return self . __class__ ( ( other . __x - self . __x ) % __MOD__ ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> raise Exception ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> def __mul__ ( self , other ) : <NEWLINE> <INDENT> if type ( other ) == int : <NEWLINE> <INDENT> other = self . __class__ ( other ) <NEWLINE> return int ( self . __class__ ( ( self . __x * other . __x ) % __MOD__ ) ) <NEWLINE> <DEDENT> elif type ( other ) == ModInt : <NEWLINE> <INDENT> return self . __class__ ( ( self . __x * other . __x ) % __MOD__ ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> raise Exception ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> def __rmul__ ( self , other ) : <NEWLINE> <INDENT> if type ( other ) == int : <NEWLINE> <INDENT> other = self . __class__ ( other ) <NEWLINE> return int ( self . __class__ ( ( other . __x * self . __x ) % __MOD__ ) ) <NEWLINE> <DEDENT> elif type ( other ) == ModInt : <NEWLINE> <INDENT> return self . __class__ ( ( other . __x * self . __x ) % __MOD__ ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> raise Exception ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> def __truediv__ ( self , other ) : <NEWLINE> <INDENT> if type ( other ) == int : <NEWLINE> <INDENT> other = self . __class__ ( other ) <NEWLINE> return int ( self . __class__ ( ( self . __x * other . __modinv ( ) ) % __MOD__ ) ) <NEWLINE> <DEDENT> elif type ( other ) == ModInt : <NEWLINE> <INDENT> return self . __class__ ( ( self . __x * other . __modinv ( ) ) % __MOD__ ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> raise Exception ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> def __rtruediv__ ( self , other ) : <NEWLINE> <INDENT> if type ( other ) == int : <NEWLINE> <INDENT> other = self . __class__ ( other ) <NEWLINE> return int ( self . __class__ ( ( other . __x * self . __modinv ( ) ) % __MOD__ ) ) <NEWLINE> <DEDENT> elif type ( other ) == ModInt : <NEWLINE> <INDENT> return self . __class__ ( ( other . __x * self . __modinv ( ) ) % __MOD__ ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> raise Exception ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> def __pow__ ( self , other ) : <NEWLINE> <INDENT> if type ( other ) == int : <NEWLINE> <INDENT> other = self . __class__ ( other ) <NEWLINE> return int ( self . __class__ ( pow ( self . __x , other . __x , __MOD__ ) ) ) <NEWLINE> <DEDENT> elif type ( other ) == ModInt : <NEWLINE> <INDENT> return self . __class__ ( pow ( self . __x , other . __x , __MOD__ ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> raise Exception ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> def __rpow__ ( self , other ) : <NEWLINE> <INDENT> if type ( other ) == int : <NEWLINE> <INDENT> other = self . __class__ ( other ) <NEWLINE> return int ( self . __class__ ( pow ( other . __x , self . __x , __MOD__ ) ) ) <NEWLINE> <DEDENT> elif type ( other ) == ModInt : <NEWLINE> <INDENT> return self . __class__ ( pow ( other . __x , self . __x , __MOD__ ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> raise Exception ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> def __modinv ( self , m = __MOD__ ) : <NEWLINE> <INDENT> a = self . __x <NEWLINE> if a == 0 : <NEWLINE> <INDENT> raise ZeroDivisionError ( ) <NEWLINE> <DEDENT> if gcd ( a , m ) != 1 : <NEWLINE> <INDENT> raise Exception ( <STRING> % a ) <NEWLINE> <DEDENT> b , u , v = m , 1 , 0 <NEWLINE> while b != 0 : <NEWLINE> <INDENT> t = a // b ; <NEWLINE> a -= t * b <NEWLINE> a , b = b , a <NEWLINE> u -= t * v <NEWLINE> u , v = v , u <NEWLINE> <DEDENT> u %= m <NEWLINE> if u < 0 : <NEWLINE> <INDENT> u += m <NEWLINE> <DEDENT> return u <NEWLINE> <DEDENT> def __int__ ( self ) : <NEWLINE> <INDENT> return self . __x <NEWLINE> <DEDENT> def __str__ ( self ) : <NEWLINE> <INDENT> return str ( self . __x ) <NEWLINE> <NL> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> N = intinput ( ) <NEWLINE> S = input ( ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> ans_set = [ ] <NEWLINE> pset = [ str ( i ) for i in range ( 10 ) ] <NEWLINE> for p1 in pset : <NEWLINE> <INDENT> for p2 in pset : <NEWLINE> <INDENT> for p3 in pset : <NEWLINE> <INDENT> ans_set . append ( p1 + p2 + p3 ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> cnt = 0 <NEWLINE> last = len ( S ) <NEWLINE> for ans in ans_set : <NEWLINE> <INDENT> f , s , t = ans [ 0 ] , ans [ 1 ] , ans [ 2 ] <NEWLINE> fidx , sidx , tidx = - 1 , - 1 , - 1 <NEWLINE> is_hit = False <NEWLINE> for i in range ( last ) : <NEWLINE> <INDENT> if fidx < 0 : <NEWLINE> <INDENT> if S [ i ] == f : <NEWLINE> <INDENT> fidx = i <NEWLINE> <DEDENT> continue <NEWLINE> <DEDENT> if sidx < 0 : <NEWLINE> <INDENT> if S [ i ] == s : <NEWLINE> <INDENT> sidx = i <NEWLINE> <DEDENT> if i == last - 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> continue <NEWLINE> <DEDENT> if tidx < 0 : <NEWLINE> <INDENT> if S [ i ] == t : <NEWLINE> <INDENT> is_hit = True <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if is_hit : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 10 ) : <NEWLINE> <INDENT> str_i = str ( i ) <NEWLINE> i_index == S . find ( str_i ) <NEWLINE> if i_index == - 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> for j in range ( 10 ) : <NEWLINE> <INDENT> str_j = str ( j ) <NEWLINE> j_index = S . find ( str_j , i_index + 1 ) <NEWLINE> if j_index == - 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> for k in range ( 10 ) : <NEWLINE> <INDENT> str_k = str ( k ) <NEWLINE> k_index = S . find ( str_k , j_index + 1 ) <NEWLINE> if k_index != - 1 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n , * a = map ( int , open ( 0 ) . read ( ) . split ( ) ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> l = [ 0 ] * n <NEWLINE> l [ 0 ] = 3 <NEWLINE> ans = 1 <NEWLINE> for ai in a : <NEWLINE> <INDENT> ans *= l [ ai ] <NEWLINE> ans %= mod <NEWLINE> l [ ai ] -= 1 <NEWLINE> l [ ai + 1 ] += 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> candidates = [ 0 ] * n <NEWLINE> candidates [ 0 ] = 3 <NEWLINE> ans = 1 <NEWLINE> <NL> for a in A : <NEWLINE> <INDENT> ans *= candidates [ a ] <NEWLINE> ans %= mod <NEWLINE> candidates [ a ] -= 1 <NEWLINE> candidates [ a + 1 ] += 1 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> mod = 1000000007 <NEWLINE> ans = 1 <NEWLINE> cnt = [ 3 for i == 0 else 0 for i in range ( n + 1 ) ] <NEWLINE> <NL> for a in A : <NEWLINE> <INDENT> ans = ans * cnt [ a ] % mod <NEWLINE> if ans == 0 : break <NEWLINE> cnt [ a ] -= 1 <NEWLINE> cnt [ a + 1 ] += 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> if A [ 0 ] != 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> break <NEWLINE> <DEDENT> L = [ 1 , 0 , 0 ] <NEWLINE> ans = 3 <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> a = A [ i ] <NEWLINE> count = 0 <NEWLINE> add = True <NEWLINE> for j , l in enumerate ( L ) : <NEWLINE> <INDENT> if a == l : <NEWLINE> <INDENT> count += 1 <NEWLINE> if add : <NEWLINE> <INDENT> L [ j ] += 1 <NEWLINE> add = False <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> ans *= count <NEWLINE> ans %= mod <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <COMMENT> <NL>
n , * a = map ( int , open ( 0 ) . read ( ) . split ( ) ) <NEWLINE> cnt = [ 3 ] + [ 0 ] * ( n - 2 ) <NEWLINE> ans = 1 <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> for i in a : <NEWLINE> <INDENT> ans = ans * cnt [ i ] % mod <NEWLINE> cnt [ i ] -= 1 <NEWLINE> cnt [ i + 1 ] += 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n = str ( input ( ) ) <NEWLINE> dic = { SUN : 7 , <NEWLINE> <INDENT> MON : 6 , <NEWLINE> TUE : 5 , <NEWLINE> WED : 4 , <NEWLINE> THU : 3 , <NEWLINE> FRI : 2 , <NEWLINE> SAT : 1 } <NEWLINE> <DEDENT> print ( dic ( n ) ) <NEWLINE>
import sys <NEWLINE> read = sys . stdin . buffer . read <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> readlines = sys . stdin . buffer . readlines <NEWLINE> N = int ( readline ( ) ) <NEWLINE> A = list ( map ( int , readline ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , readline ( ) . split ( ) ) ) <NEWLINE> N , W = map ( int , readline ( ) . split ( ) ) <NEWLINE> SS = [ <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> S = readline ( ) . decode ( ) . rstrip ( ) <NEWLINE> for i in range ( 7 ) : <NEWLINE> <INDENT> if S == SS [ i ] : <NEWLINE> <INDENT> print ( 7 - i ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT>
S = input ( ) <NEWLINE> <NL> if S == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif S == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif S == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif S == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif S == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif S == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif S == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> <NEWLINE> <DEDENT>
I = [ <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> for i in range ( 7 ) : <NEWLINE> <INDENT> if I [ i ] == input ( ) : <NEWLINE> <INDENT> print ( 7 - i ) <NEWLINE> <DEDENT> <DEDENT>
D = input ( ) <NEWLINE> W = [ <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> print ( 7 - l . index ( D ) ) <NEWLINE>
if S == <STRING> : <NEWLINE> <INDENT> print ( 7 ) <NEWLINE> <DEDENT> elif S == <STRING> : <NEWLINE> <INDENT> print ( 6 ) <NEWLINE> <DEDENT> elif S == <STRING> : <NEWLINE> <INDENT> print ( 5 ) <NEWLINE> <DEDENT> elif S == <STRING> : <NEWLINE> <INDENT> print ( 4 ) <NEWLINE> <DEDENT> elif S == <STRING> : <NEWLINE> <INDENT> print ( 3 ) <NEWLINE> <DEDENT> elif S == <STRING> : <NEWLINE> <INDENT> print ( 2 ) <NEWLINE> <DEDENT> elif S == <STRING> : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
if S == <STRING> : <NEWLINE> <INDENT> print ( 7 ) <NEWLINE> <DEDENT> elif S == <STRING> : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> elif S == <STRING> : <NEWLINE> <INDENT> print ( 2 ) <NEWLINE> <DEDENT> elif S == <STRING> : <NEWLINE> <INDENT> print ( 3 ) <NEWLINE> <DEDENT> elif S == <STRING> : <NEWLINE> <INDENT> print ( 4 ) <NEWLINE> <DEDENT> elif S == <STRING> : <NEWLINE> <INDENT> print ( 5 ) <NEWLINE> <DEDENT> elif S == <STRING> : <NEWLINE> <INDENT> print ( 6 ) <NEWLINE> <DEDENT>
if input ( ) == <STRING> : <NEWLINE> <INDENT> print ( 7 ) <NEWLINE> <DEDENT> elif input ( ) == <STRING> : <NEWLINE> <INDENT> print ( 6 ) <NEWLINE> <DEDENT> elif input ( ) == <STRING> : <NEWLINE> <INDENT> print ( 5 ) <NEWLINE> <DEDENT> elif input ( ) == <STRING> : <NEWLINE> <INDENT> print ( 4 ) <NEWLINE> <DEDENT> elif input ( ) == <STRING> : <NEWLINE> <INDENT> print ( 3 ) <NEWLINE> <DEDENT> elif input ( ) == <STRING> : <NEWLINE> <INDENT> print ( 2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT>
A = input ( ) <NEWLINE> <NL> S = [ SUN , MON , TUE , WED , THU , FRI , SAT ] <NEWLINE> <NL> for i in range ( 7 ) : <NEWLINE> <INDENT> if A == S [ i ] : <NEWLINE> <INDENT> print ( 7 - i ) <NEWLINE> break <NEWLINE> <DEDENT> i += 1 <NEWLINE> <DEDENT>
SUN = 7 <NEWLINE> MON = 1 <NEWLINE> TUE = 2 <NEWLINE> WED = 3 <NEWLINE> THU = 4 <NEWLINE> FRI = 5 <NEWLINE> SAT = 6 <NEWLINE> <NL> A = input ( ) <NEWLINE> <NL> <NL> print ( 7 - A ) <NEWLINE>
<COMMENT> <NL> weekday = input ( ) <NEWLINE> <COMMENT> <NL> if weekday == <STRING> : <NEWLINE> <INDENT> print ( 7 ) <NEWLINE> <DEDENT> elif weekday == <STRING> : <NEWLINE> <INDENT> print ( 6 ) S <NEWLINE> <DEDENT> elif weekday == <STRING> : <NEWLINE> <INDENT> print ( 5 ) <NEWLINE> <DEDENT> elif weekday == <STRING> : <NEWLINE> <INDENT> print ( 4 ) <NEWLINE> <DEDENT> elif weekday == <STRING> : <NEWLINE> <INDENT> print ( 3 ) <NEWLINE> <DEDENT> elif weekday == <STRING> : <NEWLINE> <INDENT> print ( 2 ) <NEWLINE> <DEDENT> elif weekday == <STRING> : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> res = 0 <NEWLINE> if s == <STRING> : <NEWLINE> <INDENT> res = 7 <NEWLINE> <DEDENT> elif s == <STRING> : <NEWLINE> <INDENT> res = 6 <NEWLINE> <DEDENT> elif s == <STRING> : <NEWLINE> <INDENT> res = 5 <NEWLINE> <DEDENT> elif s == <STRING> : <NEWLINE> <INDENT> res = 4 <NEWLINE> <DEDENT> leif s == <STRING> : <NEWLINE> <INDENT> res = 3 <NEWLINE> <DEDENT> elif s == <STRING> : <NEWLINE> <INDENT> res = 2 <NEWLINE> <DEDENT> elif s == <STRING> : <NEWLINE> <INDENT> res = 1 <NEWLINE> <DEDENT> print ( res ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> S = input ( ) <NEWLINE> <NL> if S == <STRING> : <NEWLINE> <INDENT> answer = <STRING> <NEWLINE> <DEDENT> elif S == <STRING> : <NEWLINE> <INDENT> answer = <STRING> <NEWLINE> <NL> <DEDENT> print ( answer ) <NEWLINE>
S = input ( ) <NEWLINE> print ( 7 if S == <STRING> 6 if S == <STRING> 5 if S == <STRING> 4 if S == <STRING> 3 if S == <STRING> 2 if S == <STRING> 1 if S == <STRING> <NEWLINE>
S = input ( ) <NEWLINE> week = [ <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> for i in week : <NEWLINE> <INDENT> if week [ i ] == S : <NEWLINE> <INDENT> print ( 7 - i ) <NEWLINE> <DEDENT> <DEDENT>
s = input ( ) <NEWLINE> d = [ <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> print ( d . index ( s ) [ : : - 1 ] ) <NEWLINE>
S = input ( ) <NEWLINE> <NL> days = [ <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> } <NEWLINE> print ( 7 - days . index ( S ) ) <NEWLINE>
s = input ( ) <NEWLINE> a = [ <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> print ( 7 - a . index ( a ) ) <NEWLINE>
S = input ( ) <NEWLINE> DAY = [ <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> for num in range ( 7 ) : <NEWLINE> <INDENT> if DAY [ num ] = S : <NEWLINE> <INDENT> print ( 7 - num ) <NEWLINE> <DEDENT> <DEDENT>
youbi = [ <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> y = input ( ) <NEWLINE> <NL> for i in range ( 1 , 7 ) : <NEWLINE> <INDENT> if y = youbi [ i ] : <NEWLINE> <INDENT> print ( 7 - i ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> x = len ( s ) <NEWLINE> for i in range ( x ) : <NEWLINE> <INDENT> a = s [ i ] <NEWLINE> b = ord ( a ) <NEWLINE> c = ord ( <STRING> ) <NEWLINE> d = ( b + n - c ) % 26 <NEWLINE> s [ i ] = chr ( c + d ) <NEWLINE> <DEDENT> print ( s ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> s [ i ] = chr ( ord ( ( s [ i ] - 65 + n ) % 26 + 65 ) ) <NEWLINE> <DEDENT> print ( s ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> def push ( chara , dig ) : <NEWLINE> <INDENT> if ord ( chara ) + dig > 90 : return chr ( 64 + dig + ord ( chara ) - 90 ) <NEWLINE> else : return chr ( dig + ord ( chara ) ) <NEWLINE> <NL> <DEDENT> string = input ( ) <NEWLINE> <NL> for i in range ( 0 , len ( string ) ) : <NEWLINE> <INDENT> string [ i ] = push ( string [ i ] , n ) <NEWLINE> <NL> <DEDENT> print ( string ) <NEWLINE>
import string <NEWLINE> l = string . ascii_uppercase <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> <NL> ans = [ ] <NEWLINE> plusNumber = N % 26 <NEWLINE> for c in S : <NEWLINE> <INDENT> ans . append ( l [ l . index ( c ) + plusNumber ] ) <NEWLINE> <DEDENT> print ( <STRING> . join ( ans ) ) <NEWLINE>
A = [ <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <NEWLINE> <INDENT> <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> <DEDENT> N = int ( input ( ) ) <NEWLINE> X = input ( ) <NEWLINE> for i in range ( 0 , len ( X ) - 1 ) : <NEWLINE> <INDENT> n = ( A . index ( X [ i ] ) + N ) % 26 <NEWLINE> X [ i ] = A [ n ] <NEWLINE> <DEDENT> print ( X ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> A = list ( input ( ) ) <NEWLINE> A_change = { } <NEWLINE> B = [ A , B , C , D , E , F , G , H , I , J , K , L , M , N , O , P , Q , R , S , T , U , V , W , X , Y , Z ] <NEWLINE> for i in A : <NEWLINE> <INDENT> for j in B : <NEWLINE> <INDENT> if i == j : <NEWLINE> <INDENT> A_change [ i ] = str ( B [ ( B . index ( j ) + n ) % 26 ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( list ( A_change . values ( ) ) ) <NEWLINE>
A = [ <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> n = int ( input ( ) ) <NEWLINE> s = str ( input ( ) ) <NEWLINE> x = n % 26 <NEWLINE> for i in range ( len ( A ) ) : <NEWLINE> <INDENT> for j in range ( 25 ) : <NEWLINE> <INDENT> if s [ i ] == A [ j ] : <NEWLINE> <INDENT> if j + x <= 25 : <NEWLINE> <INDENT> s [ i ] = A [ j + x ] <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s [ i ] = A [ j + x - 26 ] <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( s ) <NEWLINE>
from collections import deque <NEWLINE> n = int ( input ( ) ) <NEWLINE> g = [ [ ] for _ in range ( n + 1 ) ] <NEWLINE> e = [ ] <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> g [ a ] . append ( b ) <NEWLINE> e . append ( b ) <NEWLINE> <NL> <DEDENT> q = deque ( [ 0 ] ) <NEWLINE> <NL> color = [ 0 for _ in range ( n ) ] <NEWLINE> while ( len ( q ) > 0 ) : <NEWLINE> <INDENT> ei = q . popleft ( ) <NEWLINE> c = 1 <NEWLINE> for x in g [ ei ] : <NEWLINE> <INDENT> if c == color [ ei ] : <NEWLINE> <INDENT> c += 1 <NEWLINE> <NL> <DEDENT> color [ x ] = c <NEWLINE> c += 1 <NEWLINE> q . append ( x ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( max ( color ) ) <NEWLINE> for i in e : <NEWLINE> <INDENT> print ( color [ i ] ) <NEWLINE> <DEDENT>
from collections import deque <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> graph = [ ] <NEWLINE> <NL> for i in range ( n - 1 ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> graph [ a ] . append ( [ b , i ] ) <NEWLINE> graph [ b ] . append ( [ a , i ] ) <NEWLINE> <NL> <DEDENT> ans = [ 0 ] * ( n - 1 ) <NEWLINE> <NL> q = deque ( [ [ 1 , 0 , 0 ] ] ) a <NEWLINE> <NL> while q : <NEWLINE> <INDENT> node , pcol , p_node = q . popleft ( ) <NEWLINE> cnt = 1 <NEWLINE> for n_node in graph [ node ] : <NEWLINE> <INDENT> if n_node [ 0 ] == p_node : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if cnt == pcol : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> ans [ n_node [ 1 ] ] = cnt <NEWLINE> q . append ( [ n_node [ 0 ] , cnt , node ] ) <NEWLINE> cnt += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( max ( ans ) ) <NEWLINE> print ( * ans , sep = <STRING> ) <NEWLINE>
x , y = map ( int , input ( ) ) <NEWLINE> coin = 0 <NEWLINE> if x == 1 and y == 1 : <NEWLINE> <INDENT> coin += 400000 <NEWLINE> <DEDENT> if x == 1 : <NEWLINE> <INDENT> coin += 300000 <NEWLINE> <DEDENT> if y == 1 : <NEWLINE> <INDENT> coin += 300000 <NEWLINE> <DEDENT> if x == 2 : <NEWLINE> <INDENT> coin += 200000 <NEWLINE> <DEDENT> if y == 2 : <NEWLINE> <INDENT> coin += 200000 <NEWLINE> <DEDENT> if x == 3 : <NEWLINE> <INDENT> coin += 100000 <NEWLINE> <DEDENT> if y == 3 : <NEWLINE> <INDENT> coin += 100000 <NEWLINE> <DEDENT> print ( coin ) <NEWLINE>
import sys <NEWLINE> import collections <NEWLINE> import bisect <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> AList = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ASum = sum ( a ) <NEWLINE> c = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> c += AList [ i ] <NEWLINE> if c >= ASum / 2 : <NEWLINE> <INDENT> k = i <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> ans = min ( 2 * c - ASum , ASum - 2 * c + 2 * AList [ k ] ) <NEWLINE> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> m = float ( <STRING> ) <NEWLINE> sa = [ ] <NEWLINE> for i , a in enumerate ( A ) : <NEWLINE> <INDENT> sa . append ( sa [ i ] + ai ) <NEWLINE> <DEDENT> for i in range ( n + 1 ) : <NEWLINE> <INDENT> ans = min ( ans , abs ( sa [ i ] - ( sa [ - 1 ] - sa [ i ] ) ) ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> val = sum ( A ) // 2 <NEWLINE> tmp = 0 <NEWLINE> for n in range ( N ) : <NEWLINE> <INDENT> tmp += A [ n ] <NEWLINE> if tmp >= val : <NEWLINE> <INDENT> print ( min ( abs ( sum ( A [ n + 1 : ] - tmp ) , abs ( sum ( A [ n : ] - tmp - A [ n ] ) ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT>
h , w , k = list ( map ( int , f . readline ( ) . split ( ) ) ) <NEWLINE> <NL> grid = [ input ( ) for _ in range ( h ) ] <NEWLINE> ans = [ [ 0 ] * w for _ in range ( h ) ] <NEWLINE> <NL> cnt = 0 <NEWLINE> <NL> for j in range ( h ) : <NEWLINE> <INDENT> for i in range ( w ) : <NEWLINE> <INDENT> if grid [ j ] [ i ] == <STRING> : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> l = i <NEWLINE> r = i <NEWLINE> u = j <NEWLINE> d = j <NEWLINE> <NL> moving = True <NEWLINE> while moving and l > 0 : <NEWLINE> <INDENT> moving = False <NEWLINE> if ans [ j ] [ l - 1 ] == 0 and grid [ j ] [ l - 1 ] == <STRING> : <NEWLINE> <INDENT> moving = True <NEWLINE> l -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> moving = True <NEWLINE> while moving and r < w - 1 : <NEWLINE> <INDENT> moving = False <NEWLINE> if ans [ j ] [ r + 1 ] == 0 and grid [ j ] [ r + 1 ] == <STRING> : <NEWLINE> <INDENT> moving = True <NEWLINE> r += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> moving = True <NEWLINE> while moving and u > 0 : <NEWLINE> <INDENT> moving = False <NEWLINE> canMove = True <NEWLINE> <NL> for x in range ( l , r + 1 ) : <NEWLINE> <INDENT> if not ( ans [ u - 1 ] [ x ] == 0 and grid [ u - 1 ] [ x ] == <STRING> ) : <NEWLINE> <INDENT> canMove = False <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if canMove : <NEWLINE> <INDENT> moving = True <NEWLINE> u -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> moving = True <NEWLINE> while moving and d < h - 1 : <NEWLINE> <INDENT> moving = False <NEWLINE> canMove = True <NEWLINE> <NL> for x in range ( l , r + 1 ) : <NEWLINE> <INDENT> if not ( ans [ d + 1 ] [ x ] == 0 and grid [ d + 1 ] [ x ] == <STRING> ) : <NEWLINE> <INDENT> canMove = False <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if canMove : <NEWLINE> <INDENT> moving = True <NEWLINE> d += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> for y in range ( u , d + 1 ) : <NEWLINE> <INDENT> for x in range ( l , r + 1 ) : <NEWLINE> <INDENT> ans [ y ] [ x ] = cnt <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for row in ans : <NEWLINE> <INDENT> print ( <STRING> . join ( map ( str , row ) ) ) <NEWLINE> <DEDENT>
h , w , k = map ( int , input ( ) . split ( ) ) <NEWLINE> s = [ list ( input ( ) ) for _ in range ( h ) ] <NEWLINE> <NL> ans = [ ] <NEWLINE> n = 1 <NEWLINE> cnt = 0 <NEWLINE> for i in range ( h ) : <NEWLINE> <INDENT> if <STRING> in s [ i ] : <NEWLINE> <INDENT> ans = [ ] <NEWLINE> for s [ i ] [ j ] == <STRING> : <NEWLINE> <INDENT> for _ in range ( j + 1 - len ( ans ) ) : <NEWLINE> <INDENT> ans . append ( str ( n ) ) <NEWLINE> <DEDENT> n += 1 <NEWLINE> <DEDENT> if len ( ans ) < w : <NEWLINE> <INDENT> x = ans [ - 1 ] <NEWLINE> for _ in range ( w - len ( ans ) ) : <NEWLINE> <INDENT> ans . append ( x ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if ans : <NEWLINE> <INDENT> for _ in range ( i + 1 - cnt ) : <NEWLINE> <INDENT> print ( <STRING> . join ( ans ) ) <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
import math <NEWLINE> <NL> a , b , c = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> <NL> <COMMENT> <NL> <NL> r = int ( input ( ) ) <NEWLINE> <NL> a = ( math . pi * ( r ) ** 2 ) <NEWLINE> ans = a / math . pi <NEWLINE> <NL> <COMMENT> <NL> print ( int ( ans ) ) <NEWLINE>
r = int ( ( input ) ) <NEWLINE> print ( r ** 2 ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> print ( r * r ) <NEWLINE>
r = int ( input ) <NEWLINE> x = r ** 2 <NEWLINE> print ( x ) <NEWLINE>
import sys <NEWLINE> <NL> def cirCle ( r : int ) : <NEWLINE> <INDENT> ans = r ** 2 <NEWLINE> print ( ans ) <NEWLINE> return ( ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> args = sys . argv <NEWLINE> cirCle ( int ( args [ 1 ] ) ) <NEWLINE> <DEDENT>
import sys <NEWLINE> r = sys . argv [ 1 ] <NEWLINE> print ( int ( r ) ** 2 ) <NEWLINE>
import math <NEWLINE> r = int ( input ( ) ) <NEWLINE> area1 = pi <NEWLINE> arear = pi * pow ( r , 2 ) <NEWLINE> ratio = int ( arear / area1 ) <NEWLINE> print ( ratio ) <NEWLINE>
import sys <NEWLINE> <NL> sys . setrecursionlimit ( 500005 ) <NEWLINE> stdin = sys . stdin <NEWLINE> <NL> ni = lambda : int ( ns ( ) ) <NEWLINE> na = lambda : list ( map ( int , stdin . readline ( ) . split ( ) ) ) <NEWLINE> ns = lambda : stdin . readline ( ) . rstrip ( ) <NEWLINE> <NL> r = list ( input ( ) ) <NEWLINE> print ( r * r ) <NEWLINE>
r = int ( input ) <NEWLINE> print ( r ** 2 ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> print ( r ** 2 ) <NEWLINE>
r = int ( input ( ) ) <NEWLINE> print ( powr , 2 ) <NEWLINE>
hamkei = input ( ) <NEWLINE> print ( int ( hankei ) ** 2 ) <NEWLINE>
print ( int ( input ( ) ** 2 ) <NEWLINE>
print ( r ** 2 ) <NEWLINE>
r = input ( ) <NEWLINE> print ( r * r ) <NEWLINE>
a = input ( ) <NEWLINE> print ( a * a ) <NEWLINE>
int ( r * r ) <NEWLINE>
r = int ( input ( <STRING> ) ) <NEWLINE> <NL> return r * r <NEWLINE>
num = input ( ) <NEWLINE> <NL> return num * num <NEWLINE>
print ( r * r ) <NEWLINE>
r = input ( ) <NEWLINE> result = int ( r * r ) <NEWLINE> print ( result ) <NEWLINE>
pritn ( int ( input ( ) ) ** 2 ) <NEWLINE>
<NL> output = r ** 2 <NEWLINE> <NL> print ( output ) <NEWLINE>
int ( input ( ) ) <NEWLINE> print ( r * r ) <NEWLINE>
print ( int ( input ( ) ** 2 ) <NEWLINE>
r = input ( ) <NEWLINE> r1 = 1 <NEWLINE> <NL> print ( r ** 2 ) <NEWLINE>
a = input ( ) <NEWLINE> print ( a ^ 2 ) <NEWLINE>
import math <NEWLINE> <NL> r = int ( input ( <STRING> ) <NEWLINE> arear = r * r * math . pi <NEWLINE> area1 = 1 * 1 * math . pi <NEWLINE> <NL> nanbai = arear / area1 <NEWLINE> print ( <STRING> , r , nanbai ) <NEWLINE>
print ( r * r ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = input ( ) <NEWLINE> if a [ : n / 2 + 1 ] == a [ n / 2 + 1 : ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> if s % 2 == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> if s [ : n // 2 ] == s [ n // 2 : ] else <STRING> ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> if N % 2 > 0 or S != S [ : int ( N / 2 ) ] + S [ : int ( N / 2 ) ] : <NEWLINE> <INDENT> exit ( <STRING> ) <NEWLINE> <DEDENT> exit ( <STRING> ) <NEWLINE>
lst = input ( ) <NEWLINE> <NL> lst [ 0 ] = int ( lst [ 0 ] ) <NEWLINE> n = lst [ 0 ] <NEWLINE> s = lst [ 1 ] <NEWLINE> <NL> if n % 2 == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> t = <STRING> <NEWLINE> <NL> for i in range ( 0 , n // 2 ) : <NEWLINE> <INDENT> t += s [ i ] <NEWLINE> <NL> <DEDENT> if t + t == s : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> for i in range ( ( n // 2 ) + 1 ) : <NEWLINE> <INDENT> if s [ i ] == s [ i + ( n // 2 ) ] : <NEWLINE> <INDENT> c += 1 <NEWLINE> <DEDENT> <DEDENT> if c * 2 == n : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> if N % 2 == 0 : <NEWLINE> <INDENT> T = S [ 0 : N / 2 ] <NEWLINE> if T + T == S : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> if n % 2 == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> if s [ 0 : s / 2 ] == s [ s / 2 : ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = str ( input ( ) ) <NEWLINE> <NL> if ( N % 2 == 0 ) : <NEWLINE> <INDENT> if ( A [ : N / 2 ] == A [ N / 2 : ] ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> if n % 2 == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif : <NEWLINE> <INDENT> s1 = <STRING> <NEWLINE> s2 = <STRING> <NEWLINE> for i in range ( 0 , n / 2 ) : <NEWLINE> <INDENT> s1 += s [ i ] <NEWLINE> s2 += s [ n / 2 + i ] <NEWLINE> <DEDENT> if ( s1 == s2 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
n = str ( input ( ) ) <NEWLINE> if len ( n ) % 2 == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a = n [ 0 : len ( n ) / 2 ] <NEWLINE> b = n [ len ( n ) / 2 : len ( n ) ] <NEWLINE> if a = b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
c = input ( ) <NEWLINE> a = input ( ) <NEWLINE> b = 0 <NEWLINE> if c % 2 == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( c / 2 ) : <NEWLINE> <INDENT> if a [ i ] != a [ i + int ( c / 2 ) ] : <NEWLINE> <INDENT> b = b + 1 <NEWLINE> <DEDENT> <DEDENT> if b == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> c = n / 2 <NEWLINE> stt = s [ : c ] <NEWLINE> end = s [ c : ] <NEWLINE> <NL> if ( n % 2 == 1 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> if ( stt == end ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
<COMMENT> <NL> a = int ( input ( ) ) <NEWLINE> b = input ( ) <NEWLINE> c = s [ : a // 2 ] <NEWLINE> d = s [ a // 2 : a ] <NEWLINE> print ( <STRING> if c == d else <STRING> ) <NEWLINE> <NL>
<INDENT> = int ( input ( ) ) <NEWLINE> <DEDENT> s = str ( input ( ) ) <NEWLINE> if n % 2 == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if s [ : n // 2 ] == s [ n // 2 : ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> ans = <STRING> <NEWLINE> if n % 2 == 0 : <NEWLINE> <INDENT> if s [ : n // 2 ] = s [ n // 2 : ] : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> <NL> <NL> if ( n % 2 == 1 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <NL> <NL> <INDENT> if s [ 0 : n // 2 ] == s [ ( n // 2 ) + 1 : n ] : <NEWLINE> print ( <STRING> ) <NEWLINE> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <NL> <NL> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> if N % 2 != 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> for i in range ( N / 2 ) : <NEWLINE> <INDENT> if S [ i ] != S [ N / 2 + i ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> if n % 2 == 0 and s [ : n // 2 ] == s [ s // 2 : ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> S = str ( input ( ) ) <NEWLINE> <NL> if N % 2 == 0 : <NEWLINE> <INDENT> NN = N / 2 <NEWLINE> for i in range ( 0 , NN ) : <NEWLINE> <INDENT> if S [ i ] != S [ i + NN ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> if n % 2 == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif s [ : n / 2 ] == s [ n / 2 : ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> if s % 2 == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( 0 ) <NEWLINE> <DEDENT> if s [ : len ( s ) // 2 - 1 ] == s [ len ( s ) // 2 : ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N , S = [ int ( input ( ) ) for _ in range ( 2 ) ] <NEWLINE> if N % 2 != 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( S [ : ( N / 2 - 1 ) ] ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> <NL> if n % 2 == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s1 = s [ : n // 2 ) ] <NEWLINE> s2 = s [ n // 2 : ] <NEWLINE> <NL> if s1 == s2 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> <NL> if N % 2 == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> return <NEWLINE> <DEDENT> for i in range ( N / 2 ) : <NEWLINE> <INDENT> if S [ i ] != S [ N / 2 + i ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> return <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S = list ( str ( input ( ) ) ) <NEWLINE> <NL> p = [ ] <NEWLINE> for i in range ( N / 2 ) : <NEWLINE> <INDENT> if S [ i ] != S [ N / 2 + i ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
def distance ( a , b ) : <NEWLINE> <INDENT> return ( ( a [ 0 ] - b [ 0 ] ) ** 2 + ( a [ 1 ] - b [ 1 ] ) ** 2 ) ** 0.5 <NEWLINE> <DEDENT> n = int ( input ( ) ) <NEWLINE> a = [ tuple ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ] <NEWLINE> l = [ ] <NEWLINE> for m in list ( itertools . permutations ( a ) ) : <NEWLINE> <INDENT> d = 0 <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> d += distance ( m [ i ] , m [ i + 1 ] ) <NEWLINE> <DEDENT> l . append ( d ) <NEWLINE> <DEDENT> print ( sum ( l ) / len ( l ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> l = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ] <NEWLINE> <NL> sum = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( n ) : <NEWLINE> <INDENT> if i != j : <NEWLINE> <INDENT> sum += sqrt ( ( l [ i ] [ 0 ] - l [ j ] [ 0 ] ) * ( l [ i ] [ 0 ] - l [ j ] [ 0 ] ) + ( l [ i ] [ 1 ] - l [ j ] [ 1 ] ) * ( l [ i ] [ 1 ] - l [ j ] [ 1 ] ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( sum / n ) <NEWLINE>
def resolve ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> x , y , = [ ] , [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> x_tmp , y_tmp = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> x . append ( x_tmp ) <NEWLINE> y . append ( y_tmp ) <NEWLINE> <DEDENT> ans = 0 <NEWLINE> ls = list ( permutations ( list ( range ( N ) ) , N ) ) <NEWLINE> for l in ls : <NEWLINE> <INDENT> for i in range ( len ( l ) - 1 ) : <NEWLINE> <INDENT> ans += dist ( x [ l [ i ] ] , y [ l [ i ] ] , x [ l [ i + 1 ] ] , y [ l [ i + 1 ] ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans / len ( ls ) ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> resolve ( ) <NEWLINE>
import math <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> cnt = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n ) : <NEWLINE> <INDENT> cnt += math . sqrt ( ( a [ i ] [ 0 ] - a [ j ] [ 0 ] ) ** 2 + ( a [ i ] [ 1 ] - a [ j ] [ 1 ] ) ** 2 ) <NEWLINE> <DEDENT> <DEDENT> print ( cnt * 2 / n ) <NEWLINE>
import itertools <NEWLINE> import math <NEWLINE> n = int ( input ( ) ) <NEWLINE> m = math . factorial ( n ) <NEWLINE> l = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( n ) ] <NEWLINE> x , y = [ list ( i ) for i in zip ( * l ) ] <NEWLINE> z = list ( range ( n ) ) <NEWLINE> z = list ( itertools . permutations ( l ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> for j in range ( n - 1 ) : <NEWLINE> <INDENT> ans += math . sqrt ( ( x [ z [ i ] [ j ] ] - x [ z [ i ] [ j + 1 ] ] ) ** 2 + ( y [ z [ i ] [ j ] ] - y [ z [ i ] [ j + 1 ] ] ) ** 2 ) <NEWLINE> <DEDENT> <DEDENT> print ( ans / m ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> import math <NEWLINE> import itertools <NEWLINE> <NL> <NL> def get_input ( ) -> tuple : <NEWLINE> <INDENT> <STRING> <NEWLINE> N = int ( input ( ) ) <NEWLINE> x , y = [ ] , [ ] <NEWLINE> for n in range ( N ) : <NEWLINE> <INDENT> x_n , y_n = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> x . append ( x_n ) <NEWLINE> y . append ( y_n ) <NEWLINE> <NL> <DEDENT> return N , x , y <NEWLINE> <NL> <NL> <DEDENT> def get_distance ( x : list , y : list , i : int , j : int ) -> float : <NEWLINE> <INDENT> <STRING> <NEWLINE> return math . sqrt ( ( x [ i ] - x [ j ] ) ** 2 + ( y [ i ] - y [ j ] ) ** 2 ) <NEWLINE> <NL> <NL> <DEDENT> def get_path_length ( N : int , distance : dict , path : list ) -> float : <NEWLINE> <INDENT> <STRING> <NEWLINE> path_length = 0 <NEWLINE> for n in range ( N - 1 ) : <NEWLINE> <INDENT> path_length += distance [ ( path [ n ] , path [ n + 1 ] ) ] <NEWLINE> <NL> <DEDENT> return path_length <NEWLINE> <NL> <NL> <DEDENT> def main ( N : int , x : list , y : list ) -> None : <NEWLINE> <INDENT> <STRING> <NEWLINE> <COMMENT> <NL> distance = { } <NEWLINE> for i , j in itertools . product ( range ( N ) , repeat = 2 ) : <NEWLINE> <INDENT> distance [ ( i , j ) ] = get_distance ( i , j ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> ans = 0 <NEWLINE> for path in itertools . permutations ( range ( N ) ) : <NEWLINE> <INDENT> ans += get_path_length ( distance , path ) <NEWLINE> <DEDENT> ans /= math . factorial ( N ) <NEWLINE> <NL> <COMMENT> <NL> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <COMMENT> <NL> <INDENT> N , x , y = get_input ( ) <NEWLINE> <NL> <COMMENT> <NL> main ( N , x , y ) <NEWLINE> <DEDENT>
import math <NEWLINE> import itertools <NEWLINE> <NL> def l2 ( z1 , z2 ) : <NEWLINE> <INDENT> return math . sqrt ( pow ( z1 [ 0 ] - z2 [ 0 ] , 2 ) + pow ( z1 [ 1 ] - z2 [ 1 ] , 2 ) ) <NEWLINE> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> l = [ list ( map ( int , input ( ) . split ( <STRING> ) ) ) for _ in range ( n ) ] <NEWLINE> <NL> dist = 0 <NEWLINE> z_fr = [ ] <NEWLINE> z_to = [ ] <NEWLINE> for seq in itertools . permutations ( l , n ) : <NEWLINE> <INDENT> for z in seq : <NEWLINE> <INDENT> z_fr = z_to <NEWLINE> z_to = z <NEWLINE> if len ( z_fr ) : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> dist += l2 ( z_fr , z_to ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
import numpy as np <NEWLINE> N = int ( input ( ) ) <NEWLINE> xy = [ list ( map ( int , input ( ) . split ( <STRING> ) ) ) for i in range ( N ) ] <NEWLINE> <NL> L = 0 <NEWLINE> for i in range ( len ( xy ) - 1 ) : <NEWLINE> <INDENT> a = xy [ i ] [ 0 ] - xy [ i + 1 ] [ 0 ] <NEWLINE> b = xy [ i ] [ 1 ] - xy [ i + 1 ] [ 2 ] <NEWLINE> l = np . sqrt ( a ** 2 + b ** 2 ) <NEWLINE> L += l <NEWLINE> <DEDENT> print ( L ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = [ tuple ( map ( int , input ( ) . split ( ) ) ) for _ in range ( N ) ] <NEWLINE> ans = [ ] <NEWLINE> import numpy as np <NEWLINE> for zyun in itertools . permutations ( range ( N ) ) : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> for k in range ( len ( zyun ) - 1 ) : <NEWLINE> <INDENT> cnt += np . sqrt ( ( A [ zyun [ k + 1 ] ] [ 0 ] - A [ zyun [ k ] ] [ 0 ] ) ** 2 + ( A [ zyun [ k + 1 ] ] [ 1 ] - A [ zyun [ k ] ] [ 1 ] ) ** 2 ) <NEWLINE> <DEDENT> ans . append ( cnt ) <NEWLINE> <DEDENT> print ( sum ( ans ) / len ( ans ) ) <NEWLINE>
<INDENT> import itertools <NEWLINE> import math <NEWLINE> def distance ( i , j ) : <NEWLINE> <INDENT> return math . sqrt ( ( i [ 0 ] - j [ 0 ] ) ** 2 + ( i [ 1 ] - j [ 1 ] ) ** 2 ) <NEWLINE> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> l = list ( range ( n ) ) <NEWLINE> X_Y = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> X_Y . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <DEDENT> p_list = list ( itertools . permutations ( l , n ) ) <NEWLINE> total = 0 <NEWLINE> for p in p_list : <NEWLINE> <INDENT> p_t = 0 <NEWLINE> for index in range ( n - 1 ) : <NEWLINE> <INDENT> p_t += distance ( X_Y [ p [ index ] ] , X_Y [ p [ index + 1 ] ] ) <NEWLINE> <DEDENT> total += p_t <NEWLINE> <DEDENT> print ( total / len ( p_list ) ) <NEWLINE> <DEDENT> resolve ( ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( n ) ] <NEWLINE> sum = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( j + 1 , n ) : <NEWLINE> <INDENT> sum += ( ( a [ i ] [ 0 ] - a [ j ] [ 0 ] ) ** 2 + ( a [ i ] [ 1 ] - a [ j ] [ 1 ] ) ** 2 ) ** 0.5 <NEWLINE> <DEDENT> <DEDENT> print ( 2 * sum / n ) <NEWLINE>
def dist ( x0 , y0 , x1 , y1 ) : <NEWLINE> <INDENT> return math . sqrt ( ( x0 - x1 ) ** 2 + ( y0 - y1 ) ** 2 ) <NEWLINE> <NL> <DEDENT> def resolve ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> x , y = [ ] , [ ] <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> x_tmp , y_tmp = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> x . append ( x_tmp ) <NEWLINE> y . append ( y_tmp ) <NEWLINE> <NL> <DEDENT> ls = list ( permutations ( list ( range ( N ) ) , N ) ) <NEWLINE> ans = 0 <NEWLINE> for l in ls : <NEWLINE> <INDENT> idx = 0 <NEWLINE> while idx + 1 < len ( l ) : <NEWLINE> <INDENT> ans += dist ( x [ l [ idx ] ] , y [ l [ idx ] ] , x [ l [ idx + 1 ] ] , y [ l [ idx + 1 ] ] ) <NEWLINE> idx += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans / len ( ls ) ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> resolve ( ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> xy = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ] <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( n ) : <NEWLINE> <INDENT> if i == j : continue <NEWLINE> ans += ( ( xy [ i ] [ 0 ] - xy [ j ] [ 0 ] ) ** 2 + ( xy [ i ] [ 1 ] - xy [ j ] [ 1 ] ) ** 2 ) ** 0.5 <NEWLINE> t += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans / n ) <NEWLINE>
def nCr ( n , r , mod ) : <NEWLINE> <INDENT> x , y = 1 , 1 <NEWLINE> for r_ in range ( 1 , r + 1 ) : <NEWLINE> <INDENT> x = x * ( n + 1 - r_ ) % mod <NEWLINE> y = y * r_ % mod <NEWLINE> <DEDENT> return x * pow ( y , mod - 2 , mod ) % mod <NEWLINE> <NL> <DEDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> if ( x + y ) % 3 or 2 * x < y or 2 * y < x : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( nCr ( ( x + y ) // 3 , ( 2 * x - y ) // 3 , mod ) ) <NEWLINE> <DEDENT>
X , Y = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if ( x + y ) % 3 != 0 or x * 2 < y or y * 2 < x : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> n = ( 2 * X - Y ) // 3 <NEWLINE> m = ( 2 * Y - X ) // 3 <NEWLINE> <NL> P = 10 ** 9 + 7 <NEWLINE> N = 10 ** 6 <NEWLINE> fact = [ 1 , 1 ] <NEWLINE> factinv = [ 1 , 1 ] <NEWLINE> inv = [ 0 , 1 ] <NEWLINE> for i in range ( 2 , N + 1 ) : <NEWLINE> <INDENT> fact . append ( ( fact [ - 1 ] * i ) % P ) <NEWLINE> inv . append ( ( - inv [ P % i ] * ( P // i ) ) % P ) <NEWLINE> factinv . append ( ( factinv [ - 1 ] * inv [ - 1 ] ) % P ) <NEWLINE> <DEDENT> print ( fact [ n + m ] * factinv [ n ] * factinv [ m ] % P ) <NEWLINE>
x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> s = 2 * x - y <NEWLINE> t = 2 * y - x <NEWLINE> if s % 3 != 0 or s < 0 or t % 3 != 0 or t < 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> import sys <NEWLINE> mod = 1000000007 <NEWLINE> p = 1 <NEWLINE> q = 1 <NEWLINE> for i in range ( s // 3 ) : <NEWLINE> <INDENT> p = ( p * ( n - i ) ) % mod <NEWLINE> q = ( q * ( i + 1 ) ) % mod <NEWLINE> <DEDENT> print ( ( p * pow ( q , - 1 , mod ) ) % mod ) <NEWLINE> <DEDENT>
x , y = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> <COMMENT> <NL> mmm = 1000000000 + 7 <NEWLINE> sss = x + y <NEWLINE> if sss % 3 != 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> hoge = sss // 3 <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> p = y - hoge <NEWLINE> q = x - hoge <NEWLINE> <COMMENT> <NL> if p < 0 or q < 0 : <COMMENT> <NEWLINE> <INDENT> return 0 <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> fac = [ ] <NEWLINE> inv = [ ] <NEWLINE> inv_fac = [ ] <NEWLINE> def init ( n ) : <NEWLINE> <INDENT> fac . append ( 1 ) <NEWLINE> fac . append ( 1 ) <NEWLINE> inv . append ( 0 ) <NEWLINE> inv . append ( 1 ) <NEWLINE> inv_fac . append ( 1 ) <NEWLINE> inv_fac . append ( 1 ) <NEWLINE> for i in range ( 2 , n ) : <NEWLINE> <INDENT> fac . append ( fac [ - 1 ] * i % mmm ) <NEWLINE> inv . append ( mmm - inv [ mmm % i ] * ( mmm // i ) % mmm ) <NEWLINE> inv_fac . append ( inv_fac [ - 1 ] * inv [ - 1 ] % mmm ) <NEWLINE> <NL> <DEDENT> <DEDENT> def choice ( a , b ) : <NEWLINE> <INDENT> if a < b : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> return fac [ a ] * ( inv_fac [ b ] * inv_fac [ a - b ] % mmm ) % mmm <NEWLINE> <NL> <DEDENT> init ( hoge * 2 + 1 ) <NEWLINE> print ( choice ( hoge , p ) % mmm ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL>
x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> if ( x + y ) % 3 != 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> if x < y : <NEWLINE> <INDENT> y = x <NEWLINE> x , y = y , x <NEWLINE> <DEDENT> if 2 y < x : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> mod = 10 ** 9 + 7 <NEWLINE> a = ( 2 y - x ) // 3 <NEWLINE> b = ( 2 x - y ) // 3 <NEWLINE> mx = 10 ** 6 * 2 <NEWLINE> k = [ 1 ] * ( mx + 1 ) <NEWLINE> def inv ( n ) : <NEWLINE> <INDENT> return pow ( n , mod - 2 , mod ) <NEWLINE> <DEDENT> for i in range ( mx ) : <NEWLINE> <INDENT> k [ i + 1 ] = k [ i ] * ( i + 1 ) % mod <NEWLINE> <DEDENT> ans = ( k [ w + h ] * inv ( k [ w ] ) * inv ( k [ h ] ) ) % mod <NEWLINE> print ( ans ) <NEWLINE>
def inv ( a , p ) : <NEWLINE> <INDENT> if a == 1 : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> elif a == 0 : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> return p - ( inv ( p % a , p ) * ( p // a ) ) % p <NEWLINE> <DEDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> if ( x + y ) % 3 != 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> if y / x > 2 or y / x < 0.5 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> n = ( x + y ) // 3 <NEWLINE> r = ( 2 * x - y ) // 3 <NEWLINE> p = 10 ** 9 + 7 <NEWLINE> def fact ( n , p ) : <NEWLINE> <INDENT> a = [ [ ] for _ in range ( n + 1 ) ] <NEWLINE> a [ 0 ] = 1 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a [ i + 1 ] = ( a [ i ] * ( i + 1 ) ) % p <NEWLINE> <DEDENT> return a <NEWLINE> <DEDENT> c = f [ - 1 ] <NEWLINE> d = f [ r ] <NEWLINE> e = f [ n - r ] <NEWLINE> dd = inv ( d , p ) <NEWLINE> ee = inv ( e , p ) <NEWLINE> ans = ( c * dd * ee ) % p <NEWLINE> print ( ans ) <NEWLINE>
<COMMENT> <NL> X , Y = map ( int , input ( ) . split ( ) ) <NEWLINE> import numpy as np <NEWLINE> a = [ [ 1 , 2 ] , [ 2 , 1 ] ] <NEWLINE> <COMMENT> <NL> mod = pow ( 10 , 9 ) + 7 <NEWLINE> <NL> b = np . linalg . inv ( a ) <NEWLINE> <NL> <NL> Z = np . array ( [ [ X ] , [ Y ] ] ) <NEWLINE> <NL> n , m = np . dot ( b , Z ) <NEWLINE> p , q = * n , * m <NEWLINE> <NL> def comb ( n , k , p ) : <NEWLINE> <INDENT> if k == 0 : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> A = reduce ( lambda x , y : x * y % p , [ n - k + 1 + i for i in range ( k ) ] ) <NEWLINE> B = reduce ( lambda x , y : x * y % p , [ i + 1 for i in range ( k ) ] ) <NEWLINE> return A * pow ( B , p - 2 , p ) % p <NEWLINE> <NL> <DEDENT> if p < 0 or q < 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> elif not p == int ( p ) or not q == int ( q ) : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> elif p == 0 and q == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> elif p == 0 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> elif q == 0 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> n = int ( p ) <NEWLINE> m = int ( q ) <NEWLINE> ans = comb ( n , m , mod ) <NEWLINE> <NL> print ( ans % mod ) <NEWLINE> <DEDENT>
import math <NEWLINE> import numpy as np <NEWLINE> <NL> def cmb ( n , r , mod ) : <NEWLINE> <INDENT> r = min ( r , n - r ) <NEWLINE> return g1 [ n ] * g2 [ r ] * g2 [ n - r ] % mod <NEWLINE> <NL> <DEDENT> mod = 10 ** 9 + 7 <NEWLINE> N = 10 ** 6 <NEWLINE> g1 = [ 1 , 1 ] <NEWLINE> g2 = [ 1 , 1 ] <NEWLINE> inverse = [ 0 , 1 ] <NEWLINE> <NL> for i in range ( 2 , N + 1 ) : <NEWLINE> <INDENT> g1 . append ( ( g1 [ - 1 ] * i ) % mod ) <NEWLINE> inverse . append ( ( - inverse [ mod % i ] * ( mod // i ) ) % mod ) <NEWLINE> g2 . append ( ( g2 [ - 1 ] * inverse [ - 1 ] ) % mod ) <NEWLINE> <NL> <DEDENT> X , Y = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> a = ( - X + 2 * Y ) / 3 <NEWLINE> b = ( 2 * X - Y ) / 3 <NEWLINE> if a . is_integer ( ) == False or b . is_integer ( ) == False or a < 0 or b < 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( cmb ( int ( N [ 0 ] + N [ 1 ] ) , int ( N [ 0 ] ) , mod ) ) <NEWLINE> <NL> <COMMENT> <NL> <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> import sys <NEWLINE> def input ( ) : return sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> n , t = map ( int , input ( ) . split ( ) ) <NEWLINE> dp = np . zeros ( t , dtype = int ) <NEWLINE> food = [ ] <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> food . append ( [ a , b ] ) <NEWLINE> <DEDENT> food . sort ( key = lambda x : x [ 0 ] * - 1 ) <NEWLINE> for j in range ( n ) : <NEWLINE> <INDENT> a , b = food [ j ] [ 0 ] , food [ j ] [ 1 ] <NEWLINE> dptmp = np . zeros ( t , dtype = int ) <NEWLINE> dptmp [ a : ] = np . maximum ( dp [ a : ] , dp [ : - a ] + b ) <NEWLINE> dptmp [ : a ] = np . maximum ( np . full ( a , b , dtype = int ) , dp [ : a ] ) <NEWLINE> dp = dptmp <NEWLINE> <DEDENT> print ( dp [ - 1 ] ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> import numba <NEWLINE> from numba import njit , b1 , i4 , i8 , f8 <NEWLINE> <NL> <COMMENT> <NL> def main ( N , T , A ) : <NEWLINE> <INDENT> dp = np . zeros ( T + 1 , np . int64 ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> for t in range ( T - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> u = min ( T , t + A [ i , 0 ] ) <NEWLINE> dp [ u ] = max ( dp [ u ] , dp [ t ] + A [ i , 1 ] ) <NEWLINE> <DEDENT> <DEDENT> ans = dp [ - 1 ] <NEWLINE> return ans <NEWLINE> <NL> <DEDENT> N , T = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( N ) ] <NEWLINE> A = np . array ( sorted ( A ) ) <NEWLINE> print ( main ( N , T , A ) ) <NEWLINE>
N = input ( ) <NEWLINE> print ( ( N - 1 ) // 2 ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , N / 2 + 1 ) : <NEWLINE> <INDENT> if i != N - i : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
print ( ( int ( input ( ) - 1 ) // 2 ) <NEWLINE>
import sys <NEWLINE> import itertools <NEWLINE> <COMMENT> <NL> import time <NEWLINE> import math <NEWLINE> import heapq <NEWLINE> from collections import defaultdict <NEWLINE> from collections import Counter <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> <NL> INF = 10 ** 18 <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> read = sys . stdin . buffer . read <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> readlines = sys . stdin . buffer . readlines <NEWLINE> <NL> <COMMENT> <NL> <NL> def my_pow ( base , n , mod ) : <NEWLINE> <INDENT> if n == 0 : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> x = base <NEWLINE> y = 1 <NEWLINE> while n > 1 : <NEWLINE> <INDENT> if n % 2 == 0 : <NEWLINE> <INDENT> x *= x <NEWLINE> n //= 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> y *= x <NEWLINE> n -= 1 <NEWLINE> <DEDENT> x %= mod <NEWLINE> y %= mod <NEWLINE> <DEDENT> return x * y % mod <NEWLINE> <NL> <DEDENT> N = int ( input ( ) ) <NEWLINE> D = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> MOD = 998244353 <NEWLINE> cnt = [ 0 ] * ( 10 ** 5 + 1 ) <NEWLINE> for d in D : <NEWLINE> <INDENT> cnt [ d ] += 1 <NEWLINE> <NL> <DEDENT> if cnt [ 0 ] != 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> ans = cnt [ 0 ] <NEWLINE> for i in range ( 1 , dmax + 1 ) : <NEWLINE> <INDENT> if cnt [ i ] == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> now = my_pow ( cnt [ i - 1 ] , cnt [ i ] , MOD ) <NEWLINE> ans *= now <NEWLINE> ans %= MOD <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> D = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> M = 998244353 <NEWLINE> from collections import Counter <NEWLINE> <NL> if D [ 0 ] != 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( 0 ) <NEWLINE> <NL> <DEDENT> cd = Counter ( D ) <NEWLINE> if cd [ 0 ] != 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( 0 ) <NEWLINE> <NL> <DEDENT> tmp = sorted ( cd . items ( ) , key = lambda x : x [ 0 ] ) <NEWLINE> <NL> ans = 1 <NEWLINE> <NL> import math <NEWLINE> for kx in range ( 1 , max ( D ) + 1 ) : <NEWLINE> <INDENT> ans *= math . pow ( cd [ kx - 1 ] , cd [ kx ] , M ) <NEWLINE> ans %= M <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> d = { } <NEWLINE> mod = 998244353 <NEWLINE> max_v = 0 <NEWLINE> lis = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <COMMENT> <NL> if lis [ 0 ] != 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> for v in list ( map ( int , input ( ) . split ( ) ) ) : <NEWLINE> <INDENT> if v not in d : <NEWLINE> <INDENT> d [ v ] = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d [ v ] += 1 <NEWLINE> <DEDENT> max_v = max ( max_v , v ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> if 0 not in d or d [ 0 ] > 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> ans = 1 <NEWLINE> <COMMENT> <NL> for i in range ( 1 , max_v + 1 ) : <NEWLINE> <INDENT> if i not in d or i - 1 not in d : <NEWLINE> <INDENT> ans *= 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans *= pow ( d [ i - 1 ] , d [ i ] , mod ) <NEWLINE> ans %= mod <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> D = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> M = 998244353 <NEWLINE> from collections import Counter <NEWLINE> <NL> if D [ 0 ] != 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( 0 ) <NEWLINE> <NL> <DEDENT> cd = Counter ( D ) <NEWLINE> if cd [ 0 ] != 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( 0 ) <NEWLINE> <NL> <DEDENT> tmp = sorted ( cd . items ( ) , key = lambda x : x [ 0 ] ) <NEWLINE> <NL> ans = 1 <NEWLINE> <COMMENT> <NL> for kx in range ( 2 , len ( tmp ) + 1 ) : <NEWLINE> <INDENT> __ , p = tmp [ kx - 1 ] <NEWLINE> _ , v = tmp [ kx ] <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> while v > 0 : <NEWLINE> <INDENT> ans *= p <NEWLINE> ans %= M <NEWLINE> v -= 1 <NEWLINE> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <NL> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if a [ 0 ] != 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> a = sorted ( a ) <NEWLINE> d = { } <NEWLINE> for av in a : <NEWLINE> <INDENT> if av not in d : <NEWLINE> <INDENT> d [ av ] = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d [ av ] += 1 <NEWLINE> <DEDENT> <DEDENT> if d [ 0 ] != 1 <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> MOD = 998244353 <NEWLINE> <NL> ans = 1 <NEWLINE> for i in range ( 1 , a [ - 1 ] + 1 ) : <NEWLINE> <INDENT> if i not in d : <NEWLINE> <INDENT> ans = 0 <NEWLINE> break <NEWLINE> <DEDENT> ans *= pow ( d [ i - 1 ] , d [ i ] , MOD ) <NEWLINE> <DEDENT> print ( ans % MOD ) <NEWLINE>
<NL> def resolve ( ) : <NEWLINE> <INDENT> MOD = 998244353 <NEWLINE> N = int ( input ( ) ) <NEWLINE> D = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if D [ 0 ] != 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> CNT = Counter ( D ) <NEWLINE> if CNT [ 0 ] > 1 : <COMMENT> <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> ans = 1 <NEWLINE> for i in range ( 1 , max ( D ) + 1 ) : <NEWLINE> <INDENT> ans *= pow ( CNT [ i - 1 ] , CNT [ i ] , MOD ) <NEWLINE> ans %= MOD <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> resolve ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> from collections import Counter <NEWLINE> <NL> def II ( ) : return int ( input ( ) ) <NEWLINE> def MII ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def LII ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> N = II ( ) <NEWLINE> D = LII ( ) <NEWLINE> <NL> if D [ 0 ] != 0 or D . count ( 0 ) > 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> mx = max ( D ) <NEWLINE> cnt = 1 <NEWLINE> for i in range ( 1 , mx + 1 ) : <NEWLINE> <INDENT> pre = D . count ( i ) <NEWLINE> post = D . count ( i + 1 ) <NEWLINE> cnt *= pre ** post <NEWLINE> <DEDENT> print ( cnt ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> l , count = [ ] , 0 <NEWLINE> for i in s : <NEWLINE> <INDENT> if i == <STRING> : count += 1 <NEWLINE> else : <NEWLINE> <INDENT> if count : l . append ( count ) <NEWLINE> count = 0 <NEWLINE> <DEDENT> <DEDENT> if count : l . append ( count ) ; count = 0 <NEWLINE> j = 0 <NEWLINE> ans = [ ] <NEWLINE> if s [ 0 ] == <STRING> : <NEWLINE> <INDENT> ans . append ( 0 ) <NEWLINE> for i in range ( len ( s ) ) : <NEWLINE> if s [ i ] == <STRING> : ans . append ( ans [ - 1 ] + 1 ) <NEWLINE> else : <NEWLINE> <INDENT> if l [ j ] == 0 : j += 1 <NEWLINE> if ans [ - 1 ] >= l [ j ] : <NEWLINE> <INDENT> l [ j ] -= 1 <NEWLINE> ans . append ( l [ j ] ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> ans [ - 1 ] = l [ j ] <NEWLINE> l [ j ] -= 1 <NEWLINE> ans . append ( l [ j ] ) <NEWLINE> <DEDENT> <DEDENT> print ( sum ( ans ) ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> ans . append ( l [ j ] ) <NEWLINE> l [ j ] -= 1 <NEWLINE> for i in range ( len ( s ) ) : <NEWLINE> if s [ i ] == <STRING> : ans . append ( ans [ - 1 ] + 1 ) <NEWLINE> else : <NEWLINE> <INDENT> if l [ j ] == 0 : j += 1 <NEWLINE> if j < len ( l ) : <NEWLINE> <NL> <INDENT> if ans [ - 1 ] >= l [ j ] : <NEWLINE> <INDENT> ans . append ( l [ j ] ) <NEWLINE> l [ j ] -= 1 <NEWLINE> <NL> <NL> <DEDENT> else : <NEWLINE> <INDENT> ans [ - 1 ] = l [ j ] <NEWLINE> ans . append ( l [ j ] ) <NEWLINE> l [ j ] -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> else : ans . append ( 0 ) <NEWLINE> <DEDENT> print ( sum ( ans ) ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> a = [ 0 ] * len ( s ) <NEWLINE> for i in range ( len ( s ) + 1 ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> a [ i + 1 ] = a [ i ] + 1 <NEWLINE> <DEDENT> <DEDENT> for i in range ( len ( s ) - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> a [ i ] = max ( a [ i ] , a [ i + 1 ] + 1 ) <NEWLINE> <DEDENT> <DEDENT> print ( sum ( a ) ) <NEWLINE>
s = input ( ) <NEWLINE> n = len ( s ) <COMMENT> <NEWLINE> aa = [ <STRING> ] * ( n + 1 ) <NEWLINE> <NL> if s [ 0 ] == <STRING> : <NEWLINE> <INDENT> aa [ 0 ] = 0 <NEWLINE> <NL> <DEDENT> for i in range ( n - 1 ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> and s [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> aa [ i + 1 ] = 0 <NEWLINE> <DEDENT> elif s [ i ] == <STRING> and s [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> aa [ i + 1 ] = n <NEWLINE> <NL> <DEDENT> <DEDENT> id0 = [ i for i , x in enumerate ( aa ) if x == 0 ] <NEWLINE> idm = [ i for i , x in enumerate ( aa ) if x == n ] <NEWLINE> <NL> <NL> for i in range ( len ( id0 ) - 1 ) : <NEWLINE> <INDENT> aa [ idm [ i ] ] = max ( idm [ i ] - id0 [ i ] , id0 [ i + 1 ] - idm [ i ] ) <NEWLINE> <NL> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> and aa [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> aa [ i + 1 ] = aa [ i ] + 1 <NEWLINE> <DEDENT> <DEDENT> for i in range ( n - 1 , 0 , - 1 ) : <NEWLINE> <INDENT> if aa [ i ] == <STRING> and s [ i ] == <STRING> : <NEWLINE> <INDENT> aa [ i ] = aa [ i + 1 ] + 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( sum ( aa ) ) <NEWLINE>
i = 0 <NEWLINE> while i < len ( s ) : <NEWLINE> <INDENT> k = 0 <NEWLINE> while s [ i ] == <STRING> if i < len ( s ) else False : <NEWLINE> <INDENT> k += 1 <NEWLINE> i += 1 <NEWLINE> <DEDENT> if k > 0 : <NEWLINE> <INDENT> l . append ( k ) <NEWLINE> <DEDENT> k = 0 <NEWLINE> while s [ i ] == <STRING> if i < len ( s ) else False : <NEWLINE> <INDENT> k += 1 <NEWLINE> i += 1 <NEWLINE> <DEDENT> <DEDENT> sm = 0 <NEWLINE> for i in l : <NEWLINE> <INDENT> sm += ( i * ( i + 1 ) ) // 2 <NEWLINE> <NL> <DEDENT> print ( sm ) <NEWLINE>
s = int ( input ( ) ) <NEWLINE> <NL> sl = len ( s ) + 1 <NEWLINE> l = [ 0 ] * sl <NEWLINE> <NL> for i in range ( sl - 1 ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> l [ i + 1 ] = l [ i ] + 1 <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( sl - 2 , - 1 , - 1 ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> l [ i ] = max ( l [ i + 1 ] , l [ i ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( sum ( l ) ) <NEWLINE> <NL>
S = input ( ) <NEWLINE> ans = 0 <NEWLINE> S = S . repace ( <STRING> / , <STRING> ) . split ( <STRING> ) <NEWLINE> for s in S : <NEWLINE> <INDENT> a = s . count ( <STRING> ) <NEWLINE> b = s . count ( <STRING> ) <NEWLINE> ans += a * ( a - 1 ) // 2 + b * ( b - 1 ) // 2 + max ( a , b ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
INF = 10 ** 10 <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> <NL> L = [ tuple ( map ( int , input ( ) . split ( ) ) ) for _ in range ( N ) ] <NEWLINE> <NL> L . sort ( key = lambda x : ( - x [ 0 ] , x [ 1 ] ) ) <NEWLINE> <NL> MAX_L = 0 <NEWLINE> MIN_R = INF <NEWLINE> MAX = 0 <NEWLINE> a = 0 <NEWLINE> b = 0 <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> if MAX_L < L [ i ] [ 0 ] : <NEWLINE> <INDENT> MAX_L = L [ i ] [ 0 ] <NEWLINE> a = i <NEWLINE> <DEDENT> if MIN_R > L [ i ] [ 1 ] : <NEWLINE> <INDENT> MIN_R = L [ i ] [ 1 ] <NEWLINE> b = i <NEWLINE> <DEDENT> MAX = max ( MAX , L [ i ] [ 1 ] - L [ i ] [ 0 ] + 1 ) <NEWLINE> <NL> <DEDENT> ans = MAX + max ( 0 , MIN_R - MAX_L + 1 ) <NEWLINE> <NL> p = 0 <NEWLINE> <NL> for i in range ( N - 1 ) : <NEWLINE> <INDENT> p = max ( p , L [ i + 1 ] [ 0 ] ) <NEWLINE> ans = max ( ans , max ( 0 , L [ i ] [ 1 ] - L [ 0 ] [ 0 ] + 1 ) + max ( 0 , L [ - 1 ] [ 1 ] - L [ i + 1 ] [ 0 ] + 1 ) ) <NEWLINE> <NL> <NL> print ( ans ) INF = 10 ** 10 <NEWLINE> <NL> <DEDENT> N = int ( input ( ) ) <NEWLINE> <NL> L = [ tuple ( map ( int , input ( ) . split ( ) ) ) for _ in range ( N ) ] <NEWLINE> <NL> L . sort ( key = lambda x : ( - x [ 0 ] , x [ 1 ] ) ) <NEWLINE> <NL> MAX_L = 0 <NEWLINE> MIN_R = INF <NEWLINE> MAX = 0 <NEWLINE> a = 0 <NEWLINE> b = 0 <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> if MAX_L < L [ i ] [ 0 ] : <NEWLINE> <INDENT> MAX_L = L [ i ] [ 0 ] <NEWLINE> a = i <NEWLINE> <DEDENT> if MIN_R > L [ i ] [ 1 ] : <NEWLINE> <INDENT> MIN_R = L [ i ] [ 1 ] <NEWLINE> b = i <NEWLINE> <DEDENT> MAX = max ( MAX , L [ i ] [ 1 ] - L [ i ] [ 0 ] + 1 ) <NEWLINE> <NL> <DEDENT> ans = MAX + max ( 0 , MIN_R - MAX_L + 1 ) <NEWLINE> <NL> p = 0 <NEWLINE> <NL> for i in range ( N - 1 ) : <NEWLINE> <INDENT> p = max ( p , L [ i + 1 ] [ 0 ] ) <NEWLINE> ans = max ( ans , max ( 0 , L [ i ] [ 1 ] - L [ 0 ] [ 0 ] + 1 ) + max ( 0 , L [ - 1 ] [ 1 ] - L [ i + 1 ] [ 0 ] + 1 ) ) <NEWLINE> <NL> <NL> print ( ans ) <NEWLINE> <DEDENT>
a1 = input ( ) <NEWLINE> a2 = [ i for i in a1 . split ( ) ] <NEWLINE> x , y = float ( a2 [ 0 ] ) , float ( a2 [ 1 ] ) <NEWLINE> v , v1 = x . is_integer ( ) , y . is_integer ( ) <NEWLINE> if 1 <= ( x and y ) <= 20 and v1 == v2 == True : <NEWLINE> <INDENT> if 1 <= ( x and y ) <= 9 : <NEWLINE> <INDENT> print ( int ( x * y ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
A , B = int ( input ( ) ) <NEWLINE> if A * B <= 81 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> if A <= 9 & & B <= 9 : <NEWLINE> <INDENT> print ( A * B ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT>
A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if 1 <= A , B <= 9 : <NEWLINE> <INDENT> print ( A * B ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT>
<COMMENT> <NL> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( a * b if 1 <= a <= 9 ans 1 <= b <= 9 else - 1 ) <NEWLINE>
A , B = int ( input ( ) . split ( ) ) <NEWLINE> <NL> print ( A * B ) <NEWLINE>
a , b = map ( int ( ) , input ( ) . split ( ) ) <NEWLINE> <NL> if a < 10 and b < 10 : <NEWLINE> <INDENT> print ( a * b ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT>
a . b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if 1 <= a <= 9 and 1 <= b <= 9 : <NEWLINE> <INDENT> print ( a * b ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT>
a , b = map ( int , input ( ) ) <NEWLINE> if 1 <= a <= 9 and 1 <= b <= 9 : <NEWLINE> <INDENT> print ( a * b ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if 1 <= a and a <= 9 and 1 <= b nd b <= 9 : <NEWLINE> <INDENT> print ( a * b ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT>
A , B = map ( int . input ( ) . split ( ) ) <NEWLINE> if ( 0 <= A <= 9 ) and ( 0 <= B <= 9 ) : <NEWLINE> <INDENT> print ( A * B ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = 0 <NEWLINE> for i in range ( 1 , 10 ) : <NEWLINE> <INDENT> if n % i != 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if n / i <= 9 : <NEWLINE> <INDENT> a += 1 <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if a == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
A , B = map ( int , input ( ) , split ( ) ) <NEWLINE> if A <= 9 and B <= 9 : <NEWLINE> <INDENT> print ( A * B ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT>
a , b = map ( int , input ( ) ) <NEWLINE> print ( a * b if a <= 9 and b <= 9 else - 1 ) <NEWLINE>
a = int ( input ( ) ) <NEWLINE> if a % 1 == 0 or a % 2 == 0 or a % 3 == 0 or a % 4 == 0 or a % 5 == 0 or a % 6 == 0 or a % 7 == 0 or a % 8 == 0 or a % 9 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b = int ( input ( ) . split ( ) ) <NEWLINE> <NL> if a < 10 and b < 10 : <NEWLINE> <INDENT> print ( a * b ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <NL> <DEDENT>
import sys <NEWLINE> N = int ( input ( ) ) <NEWLINE> array = [ I for I in range ( 1 , 10 ) ] <NEWLINE> <NL> if not ( 1 <= N <= 100 ) : sys . exit ( ) <NEWLINE> <NL> for J in range ( 1 , 10 ) : <NEWLINE> <INDENT> for K in range ( 1 , 10 ) : <NEWLINE> <INDENT> if n == J * K : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> flag = 0 <NEWLINE> for i in range ( 9 ) : <NEWLINE> <INDENT> for j in range ( 9 ) : <NEWLINE> <INDENT> if i * j = n : <NEWLINE> <INDENT> flag = 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if flag : print ( <STRING> ) <NEWLINE> else : print ( <STRING> ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = set ( ) <NEWLINE> for i in range ( 1 , 10 ) : <NEWLINE> <INDENT> for j in range ( 1 , 10 ) : <NEWLINE> <INDENT> a . append ( i * j ) <NEWLINE> <DEDENT> <DEDENT> if n in a : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> result = 0 <NEWLINE> for i in range ( 1 , 10 ) : <NEWLINE> <INDENT> for j in range ( 1 , 10 ) : <NEWLINE> <INDENT> if i * j == N : <NEWLINE> <INDENT> result = 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if result = 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
<INDENT> import sys <NEWLINE> N = int ( input ( ) ) <NEWLINE> <NL> for i in range ( 1 , 10 ) : <NEWLINE> <INDENT> for j in range ( 1 , 10 ) : <NEWLINE> <INDENT> if ( N == i * j ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
Suji = [ ] <NEWLINE> for i in range ( 1 , 9 ) : <NEWLINE> <INDENT> Suji . append ( i ) <NEWLINE> <DEDENT> N = int ( input ( ) ) <NEWLINE> Suji_check = False <NEWLINE> for s in Suji : <NEWLINE> <INDENT> A = N % s <NEWLINE> try A != 0 : <NEWLINE> <INDENT> for t in Suji : <NEWLINE> if A == t : <NEWLINE> <INDENT> Suji_check = True <NEWLINE> <DEDENT> <DEDENT> except : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> <DEDENT> if Suji_check : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> kuku = [ ] <NEWLINE> for i in range ( 1 , 10 ) : <NEWLINE> <INDENT> kuku += [ i * e for i in range ( 1 , 10 ) ] <NEWLINE> <DEDENT> if N in kuku : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> for i range ( 1 , 10 ) : <NEWLINE> <INDENT> if N % i == 0 and N // i <= 9 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : print ( <STRING> ) <NEWLINE>
product = [ ] <NEWLINE> <NL> for i in range ( 1 , 10 ) : <NEWLINE> <INDENT> for j in range ( 1 , 10 ) : <NEWLINE> <INDENT> product . append ( i * j ) <NEWLINE> <NL> <DEDENT> <DEDENT> if N in product : <NEWLINE> <INDENT> result = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> result = <STRING> <NEWLINE> <NL> <DEDENT> print ( result ) <NEWLINE>
n = int ( input ) <NEWLINE> <NL> for i in range ( 1 , 10 ) : <NEWLINE> <INDENT> for j in range ( i , 10 ) : <NEWLINE> <INDENT> if n == i * j : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> bol = 0 <NEWLINE> for i in range ( 1 , 10 ) : <NEWLINE> <INDENT> for j in range ( 1 : 10 ) : <NEWLINE> <INDENT> if i * j == n : <NEWLINE> <INDENT> bol = 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if bol == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> for i in range ( 9 ) : <NEWLINE> <INDENT> for j in range ( 9 ) : <NEWLINE> <INDENT> k = i * j <NEWLINE> if n % k == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = set ( filter ( lambda x : n % x == 0 and n / x < 10 , [ x for x in range ( 1 , 10 ) ] ) <NEWLINE> <NL> print ( <STRING> if len ( s ) == 0 in s else <STRING> ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> judge = <STRING> <NEWLINE> for i in range ( 1 : 10 ) : <NEWLINE> <INDENT> for j in range ( 1 : 10 ) : <NEWLINE> <INDENT> if i * j == N : <NEWLINE> <INDENT> judge = <STRING> <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> <DEDENT> break <NEWLINE> <DEDENT> print ( judge ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> list = [ ] <NEWLINE> <NL> for i in range ( 1 , 10 ) <NEWLINE> <INDENT> for j in range ( 1 , 10 ) <NEWLINE> <INDENT> list . append ( i * j ) <NEWLINE> <NL> <DEDENT> <DEDENT> if n in list : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a = int ( input ( ) ) <NEWLINE> b = 0 <NEWLINE> for i in range ( 9 ) : <NEWLINE> <INDENT> for k in range ( 9 ) : <NEWLINE> <INDENT> if ( i + 1 ) * ( k + 1 ) == a : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> b = b + 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if b = 81 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a = int ( input ( ) ) <NEWLINE> f = False <NEWLINE> for i in range ( 1 , 10 ) : <NEWLINE> <INDENT> if a % i == 0 and a / i < 10 : <NEWLINE> <INDENT> f = True <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if f : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a , b = 0 <NEWLINE> for i in range ( 1 , 10 ) : <NEWLINE> <INDENT> b = i <NEWLINE> a = n // i <NEWLINE> if n % i != 0 : continue <NEWLINE> elif a <= 9 and b <= 9 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> <NL> for i in range ( 1 , 10 ) : <NEWLINE> <INDENT> for j in range ( 1 , 10 ) : <NEWLINE> <INDENT> if i * j == n : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
import sys <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> <NL> for i in range ( 1 , 10 ) : <NEWLINE> <INDENT> for j in range ( 1 , 10 ) : <NEWLINE> <INDENT> if i * j == n : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( 1 ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> for x in range ( 1 , 10 ) <NEWLINE> <INDENT> for y in range ( 1 , 10 ) <NEWLINE> <INDENT> if x * y == n : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> cnt = 1 <NEWLINE> while cnt <= 9 : <NEWLINE> <INDENT> s = N / cnt <NEWLINE> if 1 <= s <= 9 and s == type ( int ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b , c , x = [ int ( input ( ) ) for _ in range ( 4 ) ] <NEWLINE> print ( sum ( 500 * i + 100 * j + 50 * k == x for i in range ( a + 1 ) for j in range ( b + 1 ) for k in range ( c + 1 ) ) ) <NEWLINE>
ans = 0 <NEWLINE> for i in range ( 1 , 10 ) : <NEWLINE> <INDENT> for j in range ( 1 , 10 ) : <NEWLINE> <INDENT> if int ( input ( ) ) == i * j : <NEWLINE> <INDENT> ans = 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> if ans else <STRING> ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> if n % 2 == 0 : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> for i in range ( n // 2 ) : <NEWLINE> <INDENT> if s [ i ] == s [ i + n // 2 ] : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> if cnt == n // 2 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if a >= 10 or b >= 10 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( a * b ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> for i in range ( 1 , 10 ) : <NEWLINE> <INDENT> if N % i == 0 and N / i <= 9 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( 1 ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
import math <NEWLINE> N = int ( input ( ) ) <NEWLINE> s = 0 <NEWLINE> if N % 2 == 0 : <NEWLINE> <INDENT> s = 2 + N // 2 <NEWLINE> <NL> <DEDENT> for i in range ( 3 , int ( math . sqrt ( N ) , 2 ) : <NEWLINE> <INDENT> if N % i == 0 and s > i + N // i : <NEWLINE> <INDENT> s = i + N // i <NEWLINE> <NL> <DEDENT> <DEDENT> print ( s - 2 ) <NEWLINE>
from math import sqrt <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> <NL> search_max = int ( sqrt ( N ) ) <NEWLINE> <NL> min_number = 10 ** 12 <NEWLINE> for x in range ( 1 , search_max + 1 ) : <NEWLINE> <INDENT> if N % x == 0 : <NEWLINE> <INDENT> y = N // x <NEWLINE> if x + y < min_number : <NEWLINE> <INDENT> min_number = x + y <NEWLINE> print ( min_number - 2 ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> m = 10 ** 12 <NEWLINE> a = int ( ( n ** 0.5 ) // 1 ) <NEWLINE> for i in a : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> m = min ( m , i + ( n / i ) - 2 ) <NEWLINE> <DEDENT> <DEDENT> print ( m ) <NEWLINE>
import math <NEWLINE> <NL> ans = 1000000000000000000 <NEWLINE> N = int ( input ( ) ) <NEWLINE> for i in range ( math . sqrt ( N + 1000 ) ) : <NEWLINE> <INDENT> if i > 0 and N % i == 0 : <NEWLINE> <INDENT> ans = min ( i + N / i - 2 , ans ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
zimport numpy <NEWLINE> n = int ( input ( ) ) <NEWLINE> l = [ ] <NEWLINE> <NL> def is_prime ( q ) : <NEWLINE> <INDENT> q = abs ( q ) <NEWLINE> if q == 2 : return True <NEWLINE> if q < 2 or q & 1 == 0 : return False <NEWLINE> return pow ( 2 , q - 1 , q ) == 1 <NEWLINE> <NL> <DEDENT> if is_prime ( n ) : <NEWLINE> <INDENT> print ( n - 1 ) <NEWLINE> <DEDENT> if is_prime ( n ) == False : <NEWLINE> <INDENT> for i in range ( 2 , int ( numpy . sqrt ( n ) ) + 1 ) : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> a = i <NEWLINE> b = n // i <NEWLINE> l . append ( a + b - 2 ) <NEWLINE> <DEDENT> <DEDENT> print ( min ( l ) ) <NEWLINE> <DEDENT>
from math import sqrt <NEWLINE> N = int ( input ( ) ) <COMMENT> <NEWLINE> <COMMENT> <NL> a = N - 1 <NEWLINE> for x in range ( 2 , int ( sqrt ( N ) ) + 1 ) : <NEWLINE> <INDENT> q , r = divmod ( N , x ) : <NEWLINE> if r == 0 : <NEWLINE> <INDENT> a = min ( x - 1 + q - 1 , a ) <NEWLINE> <DEDENT> <DEDENT> print ( a ) <NEWLINE> <NL> <NL> <NL>
n = int ( input ( ) ) <NEWLINE> <NL> ans = n <NEWLINE> <NL> i = 1 <NEWLINE> <NL> while i * i <= n : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> d = n / i <NEWLINE> if ans > i * d - 2 : ans = i * d - 2 <NEWLINE> <DEDENT> i + + <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> import math <NEWLINE> import itertools <NEWLINE> import bisect <NEWLINE> from copy import copy <NEWLINE> from collections import deque , Counter <NEWLINE> from decimal import Decimal <NEWLINE> def s ( ) : return input ( ) <NEWLINE> def k ( ) : return int ( input ( ) ) <NEWLINE> def S ( ) : return input ( ) . split ( ) <NEWLINE> def I ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def X ( ) : return list ( input ( ) ) <NEWLINE> def L ( ) : return list ( input ( ) . split ( ) ) <NEWLINE> def l ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> def lcm ( a , b ) : return a * b // math . gcd ( a , b ) <NEWLINE> def gcd ( * numbers ) : reduce ( math . gcd , numbers ) <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> count = 0 <NEWLINE> ans = 0 <NEWLINE> <NL> N = k ( ) <NEWLINE> ans = 1000000 <NEWLINE> <NL> for i in range ( 1 , N ** 0.5 + 1 ) : <NEWLINE> <INDENT> if N % i == 0 : <NEWLINE> <INDENT> b = N // i <NEWLINE> ans = min ( ans , b + i - 2 ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <COMMENT> <NL> import math <NEWLINE> minn = 100000000000000000000 <NEWLINE> i = 1 <NEWLINE> while i ** 2 < n : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> j = n / i <NEWLINE> minn = min ( int ( i + j - 2 ) , minn ) <NEWLINE> <DEDENT> <DEDENT> print ( minn ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> <NL> a = 1 <NEWLINE> b = N // a <NEWLINE> dis = abs ( a - b ) <NEWLINE> <NL> for i in range ( int ( N ** 0.5 ) + 1 ) : <NEWLINE> <INDENT> if N % i == 0 : <NEWLINE> <INDENT> _a = i <NEWLINE> _b = N / i <NEWLINE> _dis = abs ( _a - _b ) <NEWLINE> if _dis < dis : <NEWLINE> <INDENT> a = _a <NEWLINE> b = _b <NEWLINE> dis = _dis <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( a - 1 + b - 1 ) <NEWLINE>
<INDENT> import numpy as np <NEWLINE> <INDENT> a , b , x = map ( int , input ( ) . split ( ) ) <NEWLINE> if x >= a ** 2 * b / 2 : <NEWLINE> <INDENT> ans = np . arctan ( 2 * ( b - x / a ** 2 ) / a ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = np . arctan ( a * b / 2 / x * b ) <NEWLINE> <DEDENT> print ( ans * 180 / np . pi ) <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> import numpy as np <NEWLINE> <NL> if sys . argv [ - 1 ] == <STRING> : <NEWLINE> <INDENT> from numba . pycc import CC <NEWLINE> cc = CC ( <STRING> ) <NEWLINE> <NL> @ cc . export ( <STRING> , <STRING> ) <NEWLINE> def is_ok ( A , F , x , k ) : <NEWLINE> <INDENT> tmp = 0 <NEWLINE> for a , f in zip ( A , F ) : <NEWLINE> <INDENT> while a * f > x : <NEWLINE> <INDENT> a -= 1 <NEWLINE> tmp += 1 <NEWLINE> <DEDENT> <DEDENT> return tmp <= k <NEWLINE> <NL> <DEDENT> cc . compile ( ) <NEWLINE> exit ( 0 ) <NEWLINE> <NL> <DEDENT> from my_module import is_ok <NEWLINE> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> A = np . array ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> F = np . array ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> A = np . sort ( A ) <NEWLINE> F = np . sort ( F ) [ : : - 1 ] <NEWLINE> <NL> ok = 10 ** 16 <NEWLINE> ng = - 1 <NEWLINE> while ok - ng > 1 : <NEWLINE> <INDENT> mid = ( ok + ng ) // 2 <NEWLINE> if is_ok ( A , F , mid , k ) : <NEWLINE> <INDENT> ok = mid <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ng = mid <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ok ) <NEWLINE>
import sys <NEWLINE> import numpy as np <NEWLINE> <NL> if sys . argv [ - 1 ] == <STRING> : <NEWLINE> <INDENT> from numba . pycc import CC <NEWLINE> cc = CC ( <STRING> ) <NEWLINE> <NL> @ cc . export ( <STRING> , <STRING> ) <NEWLINE> def is_ok ( A , F , x , k ) : <NEWLINE> <INDENT> tmp = 0 <NEWLINE> for a , f in zip ( A , F ) : <NEWLINE> <INDENT> y = a * f <NEWLINE> if y > x : <NEWLINE> <INDENT> tmp += a - x // f <NEWLINE> <DEDENT> <DEDENT> return tmp <= k <NEWLINE> <NL> <DEDENT> cc . compile ( ) <NEWLINE> exit ( 0 ) <NEWLINE> <NL> <DEDENT> from my_module import is_ok <NEWLINE> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> A = np . array ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> F = np . array ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> A = np . sort ( A ) <NEWLINE> F = np . sort ( F ) [ : : - 1 ] <NEWLINE> <NL> ok = 10 ** 12 <NEWLINE> ng = - 1 <NEWLINE> while ok - ng > 1 : <NEWLINE> <INDENT> mid = ( ok + ng ) // 2 <NEWLINE> if is_ok ( A , F , mid , k ) : <NEWLINE> <INDENT> ok = mid <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ng = mid <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ok ) <NEWLINE>
A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( max ( 0 , A - B * 2 ) <NEWLINE>
A . B = map ( int , input ( ) . split ( ) ) <NEWLINE> if A <= B * 2 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( A - 2 * B ) <NEWLINE> <DEDENT>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( max ( a - 2 b , 0 ) ) <NEWLINE>
a , b = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> print ( max ( 0 , a - 2 * b ) <NEWLINE>
A , B = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> if A - B * 2 > 0 : <NEWLINE> <INDENT> print ( A - B * 2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT>
a , b = input ( ) . split ( ) <NEWLINE> c = b + b <NEWLINE> if ( a - b != 0 ) : <NEWLINE> <INDENT> print ( int ( a - b ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <NL> <DEDENT>
A , B = map ( int , input ( ) ) <NEWLINE> <NL> print ( max ( [ 0 , A - 2 * B ] ) ) <NEWLINE>
tmp = input ( ) . split ( <STRING> ) <NEWLINE> A = int ( tmp [ 0 ] ) <NEWLINE> B = int ( tmp [ 1 ] ) <NEWLINE> <NL> import math <NEWLINE> print ( math . max ( A - 2 * B , 0 ) ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( a - ( 2 * b ) if a > 2 b else 0 ) <NEWLINE>
a . b = map ( int , input ( ) . split ( ) ) <NEWLINE> if ( a > b * 2 ) : <NEWLINE> <INDENT> print ( a - b * 2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( max ( 0 , a - 2 b ) ) <NEWLINE>
a1 = input ( ) <NEWLINE> a2 = [ i for i in a1 . split ( ) ] <NEWLINE> a3 , a4 = [ res [ i ] for i in ( 0 , 1 ) ] <NEWLINE> A , B = int ( a3 ) , int ( a4 ) <NEWLINE> if A > 2 * B : <NEWLINE> <INDENT> print ( A - ( 2 * B ) ) <NEWLINE> <DEDENT> elif A < 2 * B : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> len_ = A - * B <NEWLINE> <NL> if len_ <= 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( len_ ) <NEWLINE> <DEDENT>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( Max ( a - 2 * b , 0 ) ) <NEWLINE>
print ( max ( int ( input ( ) ) - int ( input ( ) ) * 2 , 0 ) ) <NEWLINE>
a , b = input ( ) . split ( <STRING> ) <NEWLINE> a = int ( a ) <NEWLINE> b = int ( b ) <NEWLINE> if a - 2 b < 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( a - 2 b ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> d = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> ans = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> for j in range ( i + 1 , N ) : <NEWLINE> <INDENT> ans += d [ i ] * d [ j ] <NEWLINE> <DEDENT> <DEDENT> print ( ans <NEWLINE>
import sys <NEWLINE> import time <NEWLINE> import math <NEWLINE> def inpl ( ) : <NEWLINE> <INDENT> return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <DEDENT> st = time . perf_counter ( ) <NEWLINE> <COMMENT> <NL> <NL> N = int ( input ( ) ) <NEWLINE> d = [ int ( input ( ) ) for _ in range ( N ) ] <NEWLINE> ans = 0 <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , N ) : <NEWLINE> <INDENT> ans += d [ i ] * d [ j ] <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <COMMENT> <NL> ed = time . perf_counter ( ) <NEWLINE> print ( <STRING> , ed - st , file = sys . stderr ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> d = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n + 1 ) : <NEWLINE> <INDENT> ans += d [ i ] * d [ j ] <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> d = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> s = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> for j in range [ i + 1 : ] : <NEWLINE> <INDENT> s += d [ i ] * d [ j ] <NEWLINE> <DEDENT> <DEDENT> print ( s ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c = itertools . combinations ( l , 2 ) <NEWLINE> ans = sum ( x * y for x , y in c ) <NEWLINE> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> d = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> sam = 0 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( n - i ) : <NEWLINE> <INDENT> sam = sam + ( d [ i ] * d [ j + 1 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( sam ) <NEWLINE>
from itertools import combinations <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> d = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> <NL> print ( sum ( d [ a ] * d [ b ] for a , b in combinations ( range ( n ) , 2 ) ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> li = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = 0 <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> for j in range ( n ) : <NEWLINE> <INDENT> a += li [ i ] * li [ j + 1 ] <NEWLINE> <DEDENT> <DEDENT> print ( a ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> D = map ( int , input ( ) . split ( ) ) <NEWLINE> count = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> for j in D [ i + 1 : ] : <NEWLINE> <INDENT> A = D [ i ] * j <NEWLINE> count += A <NEWLINE> <DEDENT> <DEDENT> print ( A ) <NEWLINE>
from itertools import combinations <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> d = list ( map ( int , input ( ) ) ) <NEWLINE> <NL> c = combinations ( d , 2 ) <NEWLINE> print ( d ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> d = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> kaihuku = 0 <NEWLINE> <NL> for i in range ( n - 1 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n ) : <NEWLINE> <INDENT> kaihuku += d ( i ) * d ( j ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( kaihuku ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> List = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> wa = 0 <NEWLINE> k = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if i + 1 == N : <NEWLINE> <INDENT> wa += List [ 0 ] * List [ N - 1 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> wa += List [ i ] * List [ i + 1 ] <NEWLINE> <DEDENT> <DEDENT> print ( res ) <NEWLINE>
x = int ( input ( ) ) <NEWLINE> s = list ( input ( ) ) <NEWLINE> su = s <NEWLINE> for i in range ( len ( s ) - 1 ) : <NEWLINE> <INDENT> if s [ i ] == s [ i + 1 ] : <NEWLINE> <INDENT> su . pop ( i ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> <DEDENT> print ( len ( su ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = str ( input ( ) ) <NEWLINE> s += <STRING> <NEWLINE> q = s [ 0 ] <NEWLINE> ans = 0 <NEWLINE> for i in range ( n + 1 ) : <NEWLINE> <INDENT> if ( q == s [ i ] ) : <NEWLINE> <INDENT> None : <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += 1 <NEWLINE> q = s [ i ] <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = input <NEWLINE> count = 0 <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> if s [ i ] != s [ i + 1 ] ; <NEWLINE> <INDENT> count = count + 1 <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> x = list ( input ( ) ) <NEWLINE> for i in range ( n , 1 , - 1 ) : <NEWLINE> <INDENT> if x [ i ] == x [ i - 1 ] : <NEWLINE> <INDENT> x . pop ( i ) <NEWLINE> <DEDENT> <DEDENT> print ( len ( x ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> last = s [ 0 ] <NEWLINE> cnt = 0 <NEWLINE> for s in S [ 1 : ] : <NEWLINE> <INDENT> if last != s : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> last = s <NEWLINE> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> if S [ i ] != S [ i - 1 ] <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans + 1 ) <NEWLINE>
a = int ( input ( ) ) a b = input ( ) <NEWLINE> c = 0 <NEWLINE> for i in range ( a - 1 ) : <NEWLINE> <INDENT> if b [ i ] == b [ i + 1 ] : <NEWLINE> <INDENT> c = c + 1 <NEWLINE> <DEDENT> <DEDENT> print ( a - c ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> L = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> L . sort ( ) <NEWLINE> from numba import njit , jit <NEWLINE> from itertools import combinations <NEWLINE> <NL> <NL> @ jit <NEWLINE> def solve ( ) : <NEWLINE> <INDENT> ans = 0 <NEWLINE> for a , b , c in combinations ( L , r = 3 ) : <NEWLINE> <INDENT> ans += a + b > c <NEWLINE> <DEDENT> return ans <NEWLINE> <NL> <NL> <DEDENT> print ( solve ( ) ) <NEWLINE>
from bisect import bisect_left <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> l = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> ans = 0 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n ) : <NEWLINE> <INDENT> ans += bisect_left ( l . , l [ i ] + l [ j ] ) - ( j + 1 ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> a . sort ( ) <NEWLINE> count = 0 <NEWLINE> for i in range ( n - 1 , 0 , - 1 ) : <NEWLINE> <INDENT> l = 0 <NEWLINE> r = i - 1 <NEWLINE> while ( l < r ) : <NEWLINE> <INDENT> if a [ l ] + a [ r ] > a [ i ] : <NEWLINE> <INDENT> count += r - l <NEWLINE> r -= 1 <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> l += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
<NL> def findnumberofTriangles ( arr ) : <NEWLINE> <INDENT> n = len ( arr ) <NEWLINE> arr . sort ( ) <NEWLINE> count = 0 <NEWLINE> for i in range ( 0 , n - 2 ) : <NEWLINE> <INDENT> k = i + 2 <NEWLINE> for j in range ( i + 1 , n ) : <NEWLINE> <INDENT> while ( k < n and arr [ i ] + arr [ j ] > arr [ k ] ) : <NEWLINE> <INDENT> k += 1 <NEWLINE> <DEDENT> if ( k > j ) : <NEWLINE> <INDENT> count += k - j - 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> return count <NEWLINE> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> arr = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> print ( findnumberoftriangles ( arr ) ) <NEWLINE> <NL>
from numba import njit <NEWLINE> N = int ( input ( ) ) <NEWLINE> L = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> L . sort ( ) <NEWLINE> <NL> @ njit <NEWLINE> def solve ( N , L ) : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> for i in range ( N - 2 ) : <NEWLINE> <INDENT> a = L [ i ] <NEWLINE> for j in range ( i + 1 , N - 1 ) : <NEWLINE> <INDENT> b = L [ j ] <NEWLINE> for k in range ( j + 1 , N ) : <NEWLINE> <INDENT> cnt += a + b > L [ k ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return cnt <NEWLINE> <DEDENT> print ( solve ( N , L ) ) <NEWLINE>
from bisect import bisect_left <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> L = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> L = sorted ( L ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( N - 2 ) : <NEWLINE> <INDENT> a = L [ i ] <NEWLINE> for j in range ( i + 1 , N - 1 ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> ans += bisect_left ( L , a + b ) - ( j + 1 ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> <NL> import numba as nb <NEWLINE> <NL> input = sys . stdin . readline <NEWLINE> <NL> <NL> @ nb . njit ( <STRING> , cache = True ) <NEWLINE> def binary_search ( a , key ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> ok = - 1 <NEWLINE> ng = len ( a ) <NEWLINE> <NL> def is_ok ( a , key , idx ) : <NEWLINE> <INDENT> if a [ idx ] < key : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return False <NEWLINE> <NL> <DEDENT> <DEDENT> while ( abs ( ok - ng ) > 1 ) : <NEWLINE> <INDENT> mid = ( ok + ng ) // 2 <NEWLINE> if is_ok ( a , key , mid ) : <NEWLINE> <INDENT> ok = mid <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ng = mid <NEWLINE> <NL> <DEDENT> <DEDENT> return ok <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> L = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> L . sort ( ) <NEWLINE> ans = 0 <NEWLINE> for a in range ( N - 2 ) : <NEWLINE> <INDENT> for b in range ( a + 1 , N - 1 ) : <NEWLINE> <INDENT> x = binary_search ( L , L [ a ] + L [ b ] ) <NEWLINE> ans += ( x - b ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
from bisect import * <NEWLINE> l = sorted ( map ( int , open ( 0 ) . read ( ) . split ( ) [ 1 : ] ) ) <NEWLINE> print ( sum ( max ( 0 , bisect_left ( l , l [ i ] + l [ j ] ) - j - 1 ) for i in range ( n ) for j in range ( i + 1 , n ) ) ) <NEWLINE>
import bisect <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> l = list ( int ( i ) for i in input ( ) . split ( ) ) <NEWLINE> l = sorted ( l , reverse = True ) <NEWLINE> <NL> cnt = 0 <NEWLINE> <NL> for i in range ( n - 2 ) : <NEWLINE> <INDENT> a = l [ i ] <NEWLINE> for j in range ( i + 1 , n - 1 ) : <NEWLINE> <INDENT> b = l [ j ] <NEWLINE> cnt += bisect . bisectright ( l , a - b ) - ( j + 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
import bisect , collections , copy , heapq , itertools , math , string <NEWLINE> import numpy as np <NEWLINE> import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> <NL> def _S ( ) : return sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> def I ( ) : return int ( sys . stdin . readline ( ) . rstrip ( ) ) <NEWLINE> def LI ( ) : return list ( map ( int , sys . stdin . readline ( ) . rstrip ( ) . split ( ) ) ) <NEWLINE> def LS ( ) : return list ( sys . stdin . readline ( ) . rstrip ( ) . split ( ) ) <NEWLINE> <NL> N = I ( ) <NEWLINE> L = LI ( ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> from numba import njit <NEWLINE> <NL> <COMMENT> <NL> def f ( A ) : <NEWLINE> <INDENT> count = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> for j in range ( i + 1 , N ) : <NEWLINE> <INDENT> for k in range ( j + 1 , N ) : <NEWLINE> <INDENT> count += ( A [ k ] < A [ i ] + A [ j ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return count <NEWLINE> <NL> <DEDENT> A = np . array ( L ) <NEWLINE> A . sort ( ) <NEWLINE> print ( f ( A ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> l . sort ( ) <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( n - 2 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n - 1 ) : <NEWLINE> <INDENT> k = bisect_left ( l , l [ i ] + l [ j ] ) <NEWLINE> ans += k - j - 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import bisect <NEWLINE> N = int ( input ( ) ) <NEWLINE> list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> list = sorted ( list ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( n - 2 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n - 1 ) : <NEWLINE> <INDENT> x = list [ i ] + list [ j ] <NEWLINE> ind = bisect . bisect_left ( list , x ) <NEWLINE> ans += ( ind - j - 1 ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL>
from collections import defaultdict <NEWLINE> from scipy . sparse . csgraph import floyd_warshall <NEWLINE> <NL> n , m , l = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> graph = defaultdict ( list ) <NEWLINE> <NL> for _ in range ( m ) : <NEWLINE> <INDENT> a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> graph [ a ] . append ( ( b , c ) ) <NEWLINE> graph [ b ] . append ( ( a , c ) ) <NEWLINE> <NL> <NL> <DEDENT> def dfs ( u ) : <NEWLINE> <INDENT> dist = [ - 1 ] * ( n + 1 ) <NEWLINE> stack = [ u ] <NEWLINE> dist [ u ] = 0 <NEWLINE> while stack : <NEWLINE> <INDENT> u = stack . pop ( ) <NEWLINE> for v , d in graph [ u ] : <NEWLINE> <INDENT> nxt = dist [ u ] + d <NEWLINE> if dist [ v ] == - 1 or dist [ v ] > nxt : <NEWLINE> <INDENT> dist [ v ] = nxt <NEWLINE> stack . append ( v ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return dist <NEWLINE> <NL> <NL> <DEDENT> dist = [ [ 0 ] * n for _ in range ( n ) ] <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> dist [ i - 1 ] = dfs ( i ) [ 1 : ] <NEWLINE> <NL> <DEDENT> dist = np . array ( dist ) <NEWLINE> <NL> graph2 = np . full ( ( n , n ) , np . inf ) <NEWLINE> graph2 [ dist <= l ] = 1 <NEWLINE> dist = floyd_warshall ( graph2 , directed = False ) <NEWLINE> dist = dist . astype ( int ) <NEWLINE> <NL> q = int ( input ( ) ) <NEWLINE> <NL> ans = [ ] <NEWLINE> for _ in range ( q ) : <NEWLINE> <INDENT> s , t = map ( int , input ( ) . split ( ) ) <NEWLINE> ans . append ( dist [ s - 1 , t - 1 ] - 1 ) <NEWLINE> <NL> <DEDENT> print ( * ans , sep = <STRING> ) <NEWLINE>
<COMMENT> <NL> S = input ( ) <NEWLINE> K = int ( input ( ) ) <NEWLINE> S = S + <STRING> <COMMENT> <NEWLINE> <NL> <COMMENT> <NL> cnt = [ ] <NEWLINE> conti = 1 <NEWLINE> for i in range ( 1 , len ( S ) ) : <NEWLINE> <INDENT> if S [ i - 1 ] == S [ i ] : <NEWLINE> <INDENT> conti += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cnt . append ( conti ) <NEWLINE> conti = 1 <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> if S [ 0 ] == S [ - 2 ] : <NEWLINE> <COMMENT> <NL> <INDENT> if cnt [ 0 ] % 2 == 1 and cnt [ - 1 ] % 2 == 1 : <NEWLINE> <INDENT> comp = K - 1 <NEWLINE> <NL> <DEDENT> <DEDENT> ans = [ a // 2 for a in cnt if a >= 2 ] <NEWLINE> ans = sum ( ans ) * K + comp <NEWLINE> print ( ans ) <NEWLINE>
import sys <NEWLINE> <NL> <COMMENT> <NL> import string <NEWLINE> <NL> S = input ( ) <NEWLINE> K = int ( input ( ) ) <NEWLINE> T = S + S [ 0 ] <NEWLINE> <NL> lower = string . ascii_lowercase <NEWLINE> ans = 0 <NEWLINE> is_specila_case = False <NEWLINE> <NL> for c in lower : <NEWLINE> <INDENT> key = c * 2 <NEWLINE> ans += T . count ( key ) <NEWLINE> <NL> if T . endswith ( key ) : <NEWLINE> <INDENT> is_specila_case = True <NEWLINE> <NL> <DEDENT> <DEDENT> ans *= K <NEWLINE> <NL> if is_specila_case : <NEWLINE> <INDENT> print ( ans - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) import sys <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> import string <NEWLINE> <NL> S = input ( ) <NEWLINE> K = int ( input ( ) ) <NEWLINE> T = S + S [ 0 ] <NEWLINE> <NL> lower = string . ascii_lowercase <NEWLINE> ans = 0 <NEWLINE> is_specila_case = False <NEWLINE> <NL> for c in lower : <NEWLINE> <INDENT> key = c * 2 <NEWLINE> ans += T . count ( key ) <NEWLINE> <NL> if T . endswith ( key ) : <NEWLINE> <INDENT> is_specila_case = True <NEWLINE> <NL> <DEDENT> <DEDENT> ans *= K <NEWLINE> <NL> if is_specila_case : <NEWLINE> <INDENT> print ( ans - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
<COMMENT> <NL> using namespace std ; <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> lint INF = 2e18 ; <NEWLINE> lint MOD = 1e9 + 7 ; <NEWLINE> <NL> lint i , j , k , t ; <NEWLINE> <NL> int main ( ) { <NEWLINE> <INDENT> string S ; <NEWLINE> lint K ; <NEWLINE> <NL> cin >> S >> K ; <NEWLINE> <NL> S += S [ 0 ] ; <NEWLINE> <NL> lint cnt = 0 ; <NEWLINE> regex re ( <STRING> ) ; <NEWLINE> <NL> for ( sregex_iterator it ( all ( S ) , re ) , end ; it != end ; + + it ) { <NEWLINE> <INDENT> auto & & m = * it ; <NEWLINE> cnt += m . length ( ) / 2 ; <NEWLINE> <DEDENT> } <NEWLINE> <NL> cout << cnt * K << endl ; <NEWLINE> <DEDENT> } <NEWLINE>
<COMMENT> <NL> import sys <NEWLINE> from collections import deque , defaultdict <NEWLINE> from math import sqrt , factorial , gcd , ceil <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> import string <NEWLINE> <COMMENT> <NL> from bisect import bisect_left <NEWLINE> <NL> def solve ( ) : <NEWLINE> <COMMENT> <NL> <INDENT> s = [ x for x in input ( ) ] <NEWLINE> a = s [ : ] <NEWLINE> k = int ( input ( ) ) <NEWLINE> if len ( s ) == 1 : <NEWLINE> <INDENT> print ( k // 2 ) <NEWLINE> return <NEWLINE> <DEDENT> if len ( set ( s ) ) == 1 : <NEWLINE> <INDENT> print ( ( len ( s ) * k ) // 2 ) <NEWLINE> return <NEWLINE> <DEDENT> cnt = 0 <NEWLINE> for i in range ( 1 , len ( s ) ) : <NEWLINE> <INDENT> if s [ i ] == s [ i - 1 ] : <NEWLINE> <INDENT> s [ i ] = <STRING> <NEWLINE> cnt += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> cnt *= k <NEWLINE> <NL> if s [ 0 ] == s [ - 1 ] and s [ 0 ] != <STRING> : <NEWLINE> <INDENT> cnt += ( k - 1 ) <NEWLINE> <NL> <DEDENT> print ( min ( cnt , ans ) ) <NEWLINE> <NL> <NL> <DEDENT> t = 1 <NEWLINE> <COMMENT> <NL> for case in range ( 1 , t + 1 ) : <NEWLINE> <INDENT> ans = solve ( ) <NEWLINE> <NL> <NL> <DEDENT> <STRING> <NEWLINE>
s = input ( ) <NEWLINE> k = int ( input ( ) ) <NEWLINE> cnt = 1 <NEWLINE> temp = [ ] <NEWLINE> for i in range ( len ( s ) - 1 ) : <NEWLINE> <INDENT> if s [ i ] == s [ i + 1 ] : cnt += 1 <NEWLINE> else : <NEWLINE> <INDENT> temp . append ( [ s [ i ] , cnt ] ) <NEWLINE> cnt = 1 <NEWLINE> <DEDENT> <DEDENT> if cnt >= 1 : temp . append ( [ s [ - 1 ] , cnt ] ) <NEWLINE> if len ( temp ) == 1 : <NEWLINE> <INDENT> print ( k * len ( s ) // 2 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> ans = 0 <NEWLINE> if temp [ 0 ] [ 0 ] != temp [ - 1 ] [ 0 ] : <NEWLINE> <INDENT> for pair in temp : <NEWLINE> <INDENT> if pair [ 1 ] != 1 : ans += pair [ 1 ] // 2 <NEWLINE> <DEDENT> print ( ans * k ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for pair in temp [ 1 : - 1 ] : <NEWLINE> <INDENT> if pair [ 1 ] != 1 : ans += pair [ 1 ] // 2 <NEWLINE> <DEDENT> ans *= k <NEWLINE> ans += ( k - 1 ) * ( ( temp [ 0 ] [ 0 ] + temp [ - 1 ] [ 0 ] ) // 2 ) <NEWLINE> ans += temp [ 0 ] [ 0 ] // 2 + temp [ - 1 ] [ 0 ] // 2 <NEWLINE> print ( ans ) <NEWLINE> <DEDENT>
S = input ( ) <NEWLINE> K = int ( input ( ) ) <NEWLINE> <NL> if len ( set ( s ) ) == 1 : <NEWLINE> <INDENT> print ( len ( S ) * K // 2 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> b = [ 1 ] <NEWLINE> for i in S [ : - 1 ] : <NEWLINE> <INDENT> if S [ i ] == S [ i + 1 ] : <NEWLINE> <INDENT> b [ - 1 ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> b . append ( 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for i in b : <NEWLINE> <INDENT> ans += i // 2 <NEWLINE> <DEDENT> ans *= K <NEWLINE> <NL> if S [ 0 ] == S [ - 1 ] and b [ 0 ] % 2 == b [ - 1 ] % 2 == 1 : <NEWLINE> <INDENT> ans += K - 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
S = input ( ) <NEWLINE> K = int ( input ( ) ) <NEWLINE> <NL> if ( S . count ( S [ 0 ] ) == len ( S ) ) : <NEWLINE> <INDENT> print ( len ( S ) * K // 2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> lst = [ ] <NEWLINE> tmp = S [ 0 ] <NEWLINE> for i in range ( len ( S ) ) : <NEWLINE> <INDENT> if ( tmp == S [ i ] ) : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> tmp = S [ i ] <NEWLINE> if ( cnt > 1 ) : <NEWLINE> <INDENT> lst . append ( cnt ) <NEWLINE> <DEDENT> cnt = 1 <NEWLINE> <DEDENT> <DEDENT> if ( cnt > 1 ) : <NEWLINE> <INDENT> lst . append ( cnt ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in lst : <NEWLINE> <INDENT> ans += K * ( i // 2 ) <NEWLINE> <DEDENT> if ( S [ 0 ] != S [ - 1 ] ) : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( len ( S ) ) : <NEWLINE> <INDENT> if ( tmp != S [ i ] ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> a += 1 <NEWLINE> <DEDENT> for i in S [ : : - 1 ] : <NEWLINE> <INDENT> if ( tmp != i ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> b += 1 <NEWLINE> <DEDENT> print ( ans + ( ( a + b ) // 2 - ( a // 2 + b // 2 ) ) * ( K - 1 ) ) <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> import sys <NEWLINE> <COMMENT> <NL> sysread = sys . stdin . buffer . readline <NEWLINE> read = sys . stdin . buffer . read <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> import math <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> import numpy as np <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> from numba import jit <NEWLINE> <NL> INF = 1 << 50 <NEWLINE> EPS = 1e-8 <NEWLINE> <NL> @ jit <NEWLINE> def solve ( S ) : <NEWLINE> <INDENT> N = S . shape [ 0 ] <NEWLINE> ans = 0 <NEWLINE> for k in range ( N ) : <NEWLINE> <COMMENT> <NL> <INDENT> seen = set ( ) <NEWLINE> seen . add ( k ) <NEWLINE> merged = np . ones ( N , dtype = np . int32 ) * ( - 1 ) <NEWLINE> merged [ 0 ] = k <NEWLINE> count = 0 <NEWLINE> while merged [ 0 ] > - 1 : <NEWLINE> <COMMENT> <NL> <INDENT> count += 1 <NEWLINE> nexts = np . ones ( N , dtype = np . int32 ) * ( - 1 ) <NEWLINE> p = 0 <NEWLINE> for i in merged : <NEWLINE> <INDENT> if i == - 1 : break <NEWLINE> for j , e in enumerate ( S [ i ] ) : <NEWLINE> <INDENT> if e and not j in seen : <NEWLINE> <COMMENT> <NL> <INDENT> nexts [ p ] = j <NEWLINE> p += 1 <NEWLINE> seen . add ( j ) <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> if nexts [ i ] == - 1 : break <NEWLINE> <DEDENT> checks = S [ nexts [ : i ] , : ] [ : , nexts [ : i ] ] <NEWLINE> <COMMENT> <NL> if checks . sum ( ) != 0 : <NEWLINE> <INDENT> seen = set ( ) <NEWLINE> break <NEWLINE> <DEDENT> merged = nexts <NEWLINE> <DEDENT> if len ( seen ) == N : <NEWLINE> <INDENT> ans = max ( ans , count ) <NEWLINE> <DEDENT> <DEDENT> if ans : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def run ( ) : <NEWLINE> <INDENT> N = int ( sysread ( ) ) <NEWLINE> S = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> S . append ( list ( map ( int , list ( input ( ) ) ) ) ) <NEWLINE> <DEDENT> S = np . array ( S , dtype = np . int8 ) <NEWLINE> <NL> solve ( S ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> run ( ) <NEWLINE> <DEDENT>
N = input ( ) <NEWLINE> if N % 2 == 0 : <NEWLINE> <INDENT> print ( N / 2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( int ( N / 2 ) ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> if N % 2 == 0 : <NEWLINE> <INDENT> print ( <STRING> . format ( N // 2 ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> . format ( N // 2 + 1 ) ) <NEWLINE> <DEDENT>
a = int ( input ( ) ) <NEWLINE> <NL> if a % 2 == 1 : print ( ( ( a - 1 ) / 2 + 1 ) / a ) <NEWLINE> else : print 0.5 <NEWLINE>
N = int ( input ( ) ) <NEWLINE> if N % 2 = 1 : <NEWLINE> <INDENT> n = int ( ( N + 1 ) / 2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> n = int ( N / 2 ) <NEWLINE> <DEDENT> res = n / N <NEWLINE> print ( res ) <NEWLINE>
a = int ( input ( ) ) <NEWLINE> if a % 2 == 0 : <NEWLINE> <INDENT> print ( a / 2 / a ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ( a // 2 + 1 ) a ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> <NL> if N == 1 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> elif N % 2 == 0 : <NEWLINE> <INDENT> print ( 0.5 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ( N - ( N // 2 ) / N ) <NEWLINE> <DEDENT>
N , K = list ( map ( lambda n : int ( n ) , input ( ) . split ( <STRING> ) ) ) <NEWLINE> h = list ( map ( lambda x : int ( n ) , input ( ) . split ( <STRING> ) ) ) <NEWLINE> print ( len ( list ( filter ( lambda height : height >= K , h ) ) ) ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> xlist = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> count = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if x [ i ] >= k : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
result = 0 <NEWLINE> <NL> for h in heights : <NEWLINE> <INDENT> if h >= K : <NEWLINE> <INDENT> result += 1 <NEWLINE> <DEDENT> <DEDENT> print ( result ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> d = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( N + 1 ) : <NEWLINE> <INDENT> if d [ i ] >= K : <NEWLINE> <INDENT> ans = ans + 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
def atc_142b ( NK_input : str , hi_input : str ) -> int : <NEWLINE> <INDENT> N , K = map ( int , NK_input . split ( <STRING> ) ) <NEWLINE> hi = [ int ( i ) for i in hi_input . split ( <STRING> ) ] <NEWLINE> hi = sorted ( hi ) <NEWLINE> for i in range ( 0 , len ( hi ) ) : <NEWLINE> <INDENT> if hi [ i ] >= K : <NEWLINE> <INDENT> return len ( hi ) - i <NEWLINE> <DEDENT> <DEDENT> return 0 <NEWLINE> <NL> <DEDENT> NK_input_value = input ( ) <NEWLINE> hi_input_value = input ( ) <NEWLINE> pritn ( atc_142b ( NK_input_value , hi_input_value ) ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> H = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> count = 0 <NEWLINE> for h in H : <NEWLINE> <INDENT> if h >= K : <NEWLINE> count = count + 1 <NEWLINE> <DEDENT> print ( count ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> for i in h : <NEWLINE> <INDENT> if h >= k : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i in h : <NEWLINE> <INDENT> if i > K : <NEWLINE> <INDENT> total += 1 <NEWLINE> <DEDENT> <DEDENT> print ( total ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if A [ i ] >= K : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N , K = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> H = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> counter = 0 <NEWLINE> for h in H : <NEWLINE> <INDENT> if h >= K : <NEWLINE> <INDENT> couter += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( counter ) <NEWLINE>
n , k = map ( int , input ( ) . spilit ( ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> for a in h : <NEWLINE> <INDENT> if a >= k : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> <NL> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> cnt = 0 <NEWLINE> <NL> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for high in h : <NEWLINE> <INDENT> if h >= k : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
n , k = map ( int , input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> cnt = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if ( a [ i ] >= k ) : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
A = B = int ( input ( ) ) <NEWLINE> N = list ( int , input ( ) . split ( ) ) <NEWLINE> <NL> c = 0 <NEWLINE> <NL> for i in range ( A ) : <NEWLINE> <INDENT> if N [ i ] >= B : <NEWLINE> <INDENT> c += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> i += 1 <NEWLINE> <DEDENT> print ( c ) <NEWLINE>
<NL> n , k = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> cnt = 0 <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> if h [ i ] >= k : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE> <NL>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> for i in h : <NEWLINE> <INDENT> if h >= K : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = [ 0 ] * N <NEWLINE> for i , val in enumerate ( A ) : <NEWLINE> <INDENT> ans [ val - 1 ] = i + 1 <NEWLINE> <DEDENT> print ( <STRING> . join ( ans ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> Alist = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> Alist = [ [ idx + 1 , a ] for ( idx , a ) in enumerate ( Alist ) ] <NEWLINE> <NL> Alist . sort ( key = lambda x : x [ 1 ] ) <NEWLINE> <NL> ans = [ a for a , _ in Alist ] <NEWLINE> print ( <STRING> . join ( ans ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> Ai = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <COMMENT> <NL> ans = [ ] * N <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> for i in range ( N ) : <NEWLINE> <INDENT> ans [ Ai [ i ] - 1 ] = str ( i + 1 ) <NEWLINE> <NL> <DEDENT> print ( <STRING> . join ( ans ) ) <NEWLINE>
import bisect , collections , copy , heapq , itertools , math , string <NEWLINE> import numpy as np <NEWLINE> from numba import njit <NEWLINE> import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> <NL> def _S ( ) : return sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> def I ( ) : return int ( sys . stdin . readline ( ) . rstrip ( ) ) <NEWLINE> def LI ( ) : return list ( map ( int , sys . stdin . readline ( ) . rstrip ( ) . split ( ) ) ) <NEWLINE> def LS ( ) : return list ( sys . stdin . readline ( ) . rstrip ( ) . split ( ) ) <NEWLINE> <NL> N = I ( ) <NEWLINE> A = LI ( ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> ans = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> ans . append ( A . index ( i + 1 ) + 1 ) <NEWLINE> <DEDENT> print ( * ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = [ 0 ] * n <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> x = a [ i ] <NEWLINE> b [ x - 1 ] = i + 1 <NEWLINE> <DEDENT> c = <STRING> . join ( b ) <NEWLINE> print ( c ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = map ( int , input ( ) . split ( ) ) <NEWLINE> B = [ 0 ] * N <NEWLINE> C = <STRING> <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> B [ A [ i ] - 1 ] = i + 1 <NEWLINE> <NL> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> C += str ( B [ i ] ) + <STRING> <NEWLINE> <NL> <DEDENT> print ( C [ 0 : - 1 ] ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> X = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if A [ i ] == ans : <NEWLINE> <INDENT> ans += 1 <NEWLINE> X . append ( i + 1 ) <NEWLINE> <DEDENT> <DEDENT> L = <STRING> . join ( X ) <NEWLINE> print ( X ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = [ 0 ] * n <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ans [ a . pop ( i ) - 1 ] = i + 1 <NEWLINE> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> print ( ans , end = <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> al = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> lst = [ ] * n <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> lst [ al [ i - 1 ] - 1 ] = i <NEWLINE> <DEDENT> print ( * lst ) <NEWLINE> <NL>
N = int ( input ( ) ) <NEWLINE> S = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = [ 0 ] * N <NEWLINE> for i in range ( Nh ) : <NEWLINE> <INDENT> ans [ S [ i ] - 1 ] = i + 1 <NEWLINE> <DEDENT> print ( <STRING> . join ( map ( str , ans ) ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> line = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = [ 0 for i in range ( n ) ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ans [ line [ i - 1 ] ] = i + 1 <NEWLINE> <DEDENT> print ( <STRING> . join ( ans ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = [ 0 for i in range ( N ) ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> ans [ A [ i ] - 1 ] = i + 1 <NEWLINE> <DEDENT> print ( <STRING> . join ( ans ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = [ 0 ] * ( N ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> B [ A [ i ] ] = A [ i ] <NEWLINE> <DEDENT> print ( B ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> ls = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> copy = [ 0 ] * n <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> copy [ ls [ i ] - 1 = i + 1 <NEWLINE> <DEDENT> for i in copy : <NEWLINE> <INDENT> print ( i , end = <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> alist = [ 0 ] * n <NEWLINE> <NL> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> alist [ a [ i ] - 1 ] = str ( i + 1 ) <NEWLINE> <NL> <DEDENT> print ( <STRING> . join ( alist ) ) <NEWLINE>
import sys <NEWLINE> n = int ( input ( ) ) <NEWLINE> an = list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) <NEWLINE> ans = [ 0 ] * n <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ans [ an [ i ] - 1 ] = i + 1 <NEWLINE> <NL> <DEDENT> print ( <STRING> . join ( ans ) ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> a , b = map ( lambda x : set ( prime_factorize ( int ( x ) ) ) , input ( ) . split ( ) ) <NEWLINE> print ( len ( a & b ) + 1 ) <NEWLINE> <NL> <DEDENT> @ lru_cache ( maxsize = None ) <NEWLINE> def primes ( n : int ) -> list : <NEWLINE> <INDENT> <STRING> <NEWLINE> is_prime = [ True ] * ( n + 1 ) <NEWLINE> is_prime [ 0 ] = False <NEWLINE> is_prime [ 1 ] = False <NEWLINE> for i in range ( 2 , int ( n ** 0.5 ) + 1 ) : <NEWLINE> <INDENT> if not is_prime [ i ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> for j in range ( i * 2 , n + 1 , i ) : <NEWLINE> <INDENT> is_prime [ j ] = False <NEWLINE> <DEDENT> <DEDENT> return [ i for i in range ( n + 1 ) if is_prime [ i ] ] <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> @ lru_cache ( maxsize = None ) <NEWLINE> def is_prime ( n : int ) -> bool : <NEWLINE> <INDENT> <STRING> <NEWLINE> if n == 1 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> elif n == 2 : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> elif n % 2 == 0 : <NEWLINE> <INDENT> return False <NEWLINE> <NL> <DEDENT> for i in range ( 3 , int ( n ** 0.5 ) + 1 , 2 ) : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> <DEDENT> return True <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> @ lru_cache ( maxsize = None ) <NEWLINE> def prime_factorize ( n : int ) -> list : <NEWLINE> <INDENT> <STRING> <NEWLINE> arr = [ ] <NEWLINE> <COMMENT> <NL> while n % 2 == 0 : <NEWLINE> <INDENT> arr . append ( 2 ) <NEWLINE> n //= 2 <NEWLINE> <COMMENT> <NL> <DEDENT> for f in primes ( int ( n ** 0.5 ) ) : <NEWLINE> <INDENT> while n % f == 0 : <NEWLINE> <INDENT> arr . append ( f ) <NEWLINE> n //= f <NEWLINE> <DEDENT> <DEDENT> if n != 1 : <NEWLINE> <INDENT> arr . append ( n ) <NEWLINE> <DEDENT> return arr <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> def make_divisors ( n : int ) -> list : <NEWLINE> <INDENT> lower_divisors , upper_divisors = [ ] , [ ] <NEWLINE> i = 1 <NEWLINE> while i * i <= n : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> lower_divisors . append ( i ) <NEWLINE> if i != n // i : <NEWLINE> <INDENT> upper_divisors . append ( n // i ) <NEWLINE> <DEDENT> <DEDENT> i += 1 <NEWLINE> <DEDENT> return lower_divisors + upper_divisors [ : : - 1 ] <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
def divisor ( n ) : <NEWLINE> <INDENT> i = 1 <NEWLINE> table = [ ] <NEWLINE> while i * i <= n : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> table . append ( i ) <NEWLINE> table . append ( n // i ) <NEWLINE> <DEDENT> i += 1 <NEWLINE> <DEDENT> table = list ( set ( table ) ) <NEWLINE> table = sorted ( table ) <NEWLINE> return table <NEWLINE> <NL> <DEDENT> def is_prime ( n ) : <NEWLINE> <INDENT> if n == 1 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> for i in range ( 2 , int ( n ** 0.5 ) + 1 ) : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> <DEDENT> return True <NEWLINE> <NL> <DEDENT> A_list = set ( divisor ( A ) ) <NEWLINE> B_list = set ( divisor ( B ) ) <NEWLINE> <NL> list = A_list & B_list <NEWLINE> <NL> cnt = 1 <NEWLINE> <NL> for i in list : <NEWLINE> <INDENT> if is_prime ( i ) : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
import numpy as np <NEWLINE> <NL> def divisor ( n ) : <NEWLINE> <INDENT> i = 1 <NEWLINE> table = [ ] <NEWLINE> while i * i <= n : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> table . append ( i ) <NEWLINE> table . append ( n // i ) <NEWLINE> <DEDENT> i += 1 <NEWLINE> <DEDENT> table = list ( set ( table ) ) <NEWLINE> table = sorted ( table ) <NEWLINE> return table <NEWLINE> <NL> <DEDENT> def make_prime ( U ) : <NEWLINE> <INDENT> is_prime = np . zeros ( U , np . bool ) <NEWLINE> is_prime [ 2 ] = 1 <NEWLINE> is_prime [ 3 : : 2 ] = 1 <NEWLINE> M = int ( U ** .5 ) + 1 <NEWLINE> for p in range ( 3 , M , 2 ) : <NEWLINE> <INDENT> if is_prime [ p ] : <NEWLINE> <INDENT> is_prime [ p * p : : p + p ] = 0 <NEWLINE> <DEDENT> <DEDENT> return is_prime , is_prime . nonzero ( ) [ 0 ] <NEWLINE> <DEDENT> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> A_list = set ( divisor ( A ) ) <NEWLINE> B_list = set ( divisor ( B ) ) <NEWLINE> <NL> list = A_list & B_list <NEWLINE> <NL> _ , primes = make_prime ( 10 ** 9 ) <NEWLINE> <NL> cnt = 1 <NEWLINE> <NL> for i in list : <NEWLINE> <INDENT> if i in primes : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
def gcd ( a , b ) : <COMMENT> <NEWLINE> <INDENT> if a % b == 0 : return b <NEWLINE> return gcd ( b , a % b ) <NEWLINE> <NL> <DEDENT> def ela ( g ) : <NEWLINE> <INDENT> s = { } <NEWLINE> i = 2 <NEWLINE> while i * i <= g : <NEWLINE> <INDENT> while g % i == 0 : <NEWLINE> <INDENT> g //= i <NEWLINE> s . add ( i ) <NEWLINE> <DEDENT> i += 1 <NEWLINE> <DEDENT> return s <NEWLINE> <NL> <DEDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> G = gcd ( max ( a , b ) , min ( a , b ) ) <NEWLINE> print ( len ( ela ( G ) ) + 1 ) <NEWLINE>
from math import * <NEWLINE> <NL> def make_divisors ( n ) : <NEWLINE> <INDENT> divisors = set ( ) <NEWLINE> for i in range ( 1 , int ( n ** 0.5 ) + 1 ) : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> divisors . add ( i ) <NEWLINE> if i != n // i : <NEWLINE> <INDENT> divisors . add ( n // i ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return divisors <NEWLINE> <NL> <DEDENT> def eratosthenes ( n ) : <NEWLINE> <INDENT> table = [ 0 ] * ( n + 1 ) <NEWLINE> prime_list = [ ] <NEWLINE> <NL> for i in range ( 2 , n + 1 ) : <NEWLINE> <INDENT> if table [ i ] == 0 : <NEWLINE> <INDENT> prime_list . append ( i ) <NEWLINE> for j in range ( i + i , n + 1 , i ) : <NEWLINE> <INDENT> table [ j ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> return prime_list <NEWLINE> <NL> <DEDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> upper = 10 ** 8 <NEWLINE> ans = set ( eratosthenes ( upper ) ) & make_divisors ( a ) & make_divisors ( b ) <NEWLINE> print ( len ( ans ) + 1 ) <NEWLINE>
<COMMENT> <NL> import sys <NEWLINE> import math <NEWLINE> import os <NEWLINE> import itertools <NEWLINE> import string <NEWLINE> import heapq <NEWLINE> import _collections <NEWLINE> from collections import Counter <NEWLINE> from collections import defaultdict <NEWLINE> from collections import deque <NEWLINE> from functools import lru_cache <NEWLINE> import bisect <NEWLINE> import re <NEWLINE> import queue <NEWLINE> import decimal <NEWLINE> <NL> <NL> class Scanner ( ) : <NEWLINE> <INDENT> @ staticmethod <NEWLINE> def int ( ) : <NEWLINE> <INDENT> return int ( sys . stdin . readline ( ) . rstrip ( ) ) <NEWLINE> <NL> <DEDENT> @ staticmethod <NEWLINE> def string ( ) : <NEWLINE> <INDENT> return sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> <NL> <DEDENT> @ staticmethod <NEWLINE> def map_int ( ) : <NEWLINE> <INDENT> return [ int ( x ) for x in Scanner . string ( ) . split ( ) ] <NEWLINE> <NL> <DEDENT> @ staticmethod <NEWLINE> def string_list ( n ) : <NEWLINE> <INDENT> return [ Scanner . string ( ) for i in range ( n ) ] <NEWLINE> <NL> <DEDENT> @ staticmethod <NEWLINE> def int_list_list ( n ) : <NEWLINE> <INDENT> return [ Scanner . map_int ( ) for i in range ( n ) ] <NEWLINE> <NL> <DEDENT> @ staticmethod <NEWLINE> def int_cols_list ( n ) : <NEWLINE> <INDENT> return [ Scanner . int ( ) for i in range ( n ) ] <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> class Math ( ) : <NEWLINE> <INDENT> @ staticmethod <NEWLINE> def gcd ( a , b ) : <NEWLINE> <INDENT> if b == 0 : <NEWLINE> <INDENT> return a <NEWLINE> <DEDENT> return Math . gcd ( b , a % b ) <NEWLINE> <NL> <DEDENT> @ staticmethod <NEWLINE> def lcm ( a , b ) : <NEWLINE> <INDENT> return ( a * b ) // Math . gcd ( a , b ) <NEWLINE> <NL> <DEDENT> @ staticmethod <NEWLINE> def divisor ( n ) : <NEWLINE> <INDENT> lower , upper = [ ] , [ ] <NEWLINE> i = 1 <NEWLINE> while i * i <= n : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> lower . append ( i ) <NEWLINE> if i != n // i : <NEWLINE> <INDENT> upper . append ( n // i ) <NEWLINE> <DEDENT> <DEDENT> i += 1 <NEWLINE> <DEDENT> return lower + upper [ : : - 1 ] <NEWLINE> <NL> <DEDENT> @ staticmethod <NEWLINE> def round_up ( a , b ) : <NEWLINE> <INDENT> return - ( - a // b ) <NEWLINE> <NL> <DEDENT> @ staticmethod <NEWLINE> def is_prime ( n ) : <NEWLINE> <INDENT> if n < 2 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> if n == 2 : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> if n % 2 == 0 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> d = int ( n ** 0.5 ) + 1 <NEWLINE> for i in range ( 3 , d + 1 , 2 ) : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> <DEDENT> return True <NEWLINE> <NL> <DEDENT> @ staticmethod <NEWLINE> def fact ( N ) : <NEWLINE> <INDENT> res = { } <NEWLINE> tmp = N <NEWLINE> for i in range ( 2 , int ( N ** 0.5 + 1 ) + 1 ) : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> while tmp % i == 0 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> tmp //= i <NEWLINE> <DEDENT> if cnt > 0 : <NEWLINE> <INDENT> res [ i ] = cnt <NEWLINE> <DEDENT> <DEDENT> if tmp != 1 : <NEWLINE> <INDENT> res [ tmp ] = 1 <NEWLINE> <DEDENT> if res == { } : <NEWLINE> <INDENT> res [ N ] = 1 <NEWLINE> <DEDENT> return res <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def pop_count ( x ) : <NEWLINE> <INDENT> x = x - ( ( x >> 1 ) & 0x5555555555555555 ) <NEWLINE> x = ( x & 0x3333333333333333 ) + ( ( x >> 2 ) & 0x3333333333333333 ) <NEWLINE> x = ( x + ( x >> 4 ) ) & 0x0f0f0f0f0f0f0f0f <NEWLINE> x = x + ( x >> 8 ) <NEWLINE> x = x + ( x >> 16 ) <NEWLINE> x = x + ( x >> 32 ) <NEWLINE> return x & 0x0000007f <NEWLINE> <NL> <NL> <DEDENT> MOD = int ( 1e09 ) + 7 <NEWLINE> INF = int ( 1e15 ) <NEWLINE> <NL> <NL> def solve ( ) : <NEWLINE> <INDENT> A , B = Scanner . map_int ( ) <NEWLINE> div_A = Math . divisor ( A ) <NEWLINE> div_B = Math . divisor ( B ) <NEWLINE> X = set ( div_A ) & set ( div_B ) <NEWLINE> ans = 0 <NEWLINE> for x in X : <NEWLINE> <INDENT> if Math . is_prime ( x ) : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans + 1 ) <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <COMMENT> <NL> <INDENT> sys . stdin = open ( <STRING> ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> solve ( ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import math <NEWLINE> <NL> d = math . gcd ( a , b ) <NEWLINE> <NL> def make_divisors ( n ) : <NEWLINE> <INDENT> lower_divisors , upper_divisors = [ ] , [ ] <NEWLINE> i = 1 <NEWLINE> while i * i <= n : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> lower_divisors . append ( i ) <NEWLINE> if i != n // i : <NEWLINE> <INDENT> upper_divisors . append ( n // i ) <NEWLINE> <DEDENT> <DEDENT> i += 1 <NEWLINE> <DEDENT> return lower_divisors + upper_divisors [ : : - 1 ] <NEWLINE> <NL> <DEDENT> r = make_divisors ( d ) <NEWLINE> l = len ( r ) <NEWLINE> ans = 1 <NEWLINE> w = [ True ] * l <NEWLINE> if l >= 2 : <NEWLINE> <INDENT> for x in range ( 1 , l ) : <NEWLINE> <INDENT> if w [ x ] == True : <NEWLINE> <INDENT> ans += 1 <NEWLINE> for y in range ( x , l ) : <NEWLINE> <INDENT> if r [ y ] % r [ x ] == 0 : <NEWLINE> <INDENT> w [ y ] = False <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from collections import deque <NEWLINE> <NL> class Graph ( ) : <COMMENT> <NEWLINE> <INDENT> def __init__ ( self , n , edge , indexed = 1 ) : <NEWLINE> <INDENT> self . n = n <NEWLINE> self . graph = [ [ ] for _ in range ( n ) ] <NEWLINE> for e in edge : <NEWLINE> <INDENT> self . graph [ e [ 0 ] - indexed ] . append ( e [ 1 ] - indexed ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> INF = 10 ** 18 <NEWLINE> <NL> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> edge = [ tuple ( map ( int , input ( ) . split ( ) ) ) for _ in range ( M ) ] <NEWLINE> <NL> g = Graph ( N , edge ) <NEWLINE> <NL> loopsize = INF <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> root = i <NEWLINE> queue = deque ( [ root ] ) <NEWLINE> dist = [ INF for _ in range ( N ) ] <NEWLINE> dist [ root ] = 0 <NEWLINE> prev = [ None for _ in range ( N ) ] <NEWLINE> while queue : <NEWLINE> <INDENT> node = queue . popleft ( ) <NEWLINE> for adj in g . graph [ node ] : <NEWLINE> <INDENT> if adj == root : <COMMENT> <NEWLINE> <INDENT> dist [ root ] = dist [ node ] + 1 <NEWLINE> prev [ root ] = node <NEWLINE> break <NEWLINE> <DEDENT> if dist [ adj ] != INF : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> dist [ adj ] = dist [ node ] + 1 <NEWLINE> prev [ adj ] = node <NEWLINE> queue . append ( adj ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> break <NEWLINE> <COMMENT> <NL> <DEDENT> if loopsize > dist [ root ] : <NEWLINE> <INDENT> loopsize = dist [ root ] <NEWLINE> path = [ root ] <NEWLINE> node = root <NEWLINE> while prev [ node ] != root : <NEWLINE> <INDENT> node = prev [ node ] <NEWLINE> path . append ( node ) <NEWLINE> <DEDENT> res = path <NEWLINE> <NL> <DEDENT> <DEDENT> if loopsize != INF : <NEWLINE> <INDENT> print ( loopsize ) <NEWLINE> for node in res : <NEWLINE> <INDENT> print ( node + 1 ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT>
H , W , A , B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> M = [ [ 0 ] * W for _ in range ( H ) ] <NEWLINE> <NL> <NL> <NL> for ih in range ( H ) : <NEWLINE> <INDENT> for iw in range ( W ) : <NEWLINE> <INDENT> if ( ih < B and iw < S ) or ( ih >= B and iw >= A ) : <NEWLINE> <INDENT> M [ ih ] [ iw ] = 1 <NEWLINE> <DEDENT> <DEDENT> for i in range ( H ) : <NEWLINE> <INDENT> print ( <STRING> . join ( list ( map ( str , M [ i ] ) ) ) ) <NEWLINE> <DEDENT> <DEDENT>
s = list ( input ( ) ) <NEWLINE> k = int ( input ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> for i in range ( len ( s ) - 1 ) : <NEWLINE> <INDENT> if s [ i ] == 0 : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> elif s [ i ] == s [ i + 1 ] : <NEWLINE> <INDENT> s [ i + 1 ] = 0 <NEWLINE> ans += 1 <NEWLINE> <DEDENT> <DEDENT> ans2 = 0 <NEWLINE> if s [ 0 ] == s [ - 1 ] : <NEWLINE> <INDENT> ans2 = 1 <NEWLINE> s [ - 1 ] = 0 <NEWLINE> <DEDENT> if len ( s ) == 1 : <NEWLINE> <INDENT> print ( k // 2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans * k + ans2 * ( k - 1 ) ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> if s == <STRING> : <NEWLINE> <INDENT> result = <STRING> <NEWLINE> <DEDENT> elif s == <STRING> : <NEWLINE> <INDENT> result = <STRING> : <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> result = <STRING> <NEWLINE> <NL> <DEDENT> print ( result ) <NEWLINE>
S = input ( ) <NEWLINE> if S = <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> if S = <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
S <NEWLINE>
S = input ( ) <NEWLINE> <NL> if S == <STRING> : <NEWLINE> <INDENT> print ( Cloudy ) <NEWLINE> <NL> <DEDENT> if S == <STRING> : <NEWLINE> <INDENT> print ( Rainy ) <NEWLINE> <NL> <DEDENT> if S == <STRING> : <NEWLINE> <INDENT> print ( Sunny ) <NEWLINE> <DEDENT>
s = int ( input ( ) ) <NEWLINE> l = [ <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> print ( l [ l . index ( s ) + 1 ] ) <NEWLINE>
S = input ( ) <NEWLINE> <NL> if S == <STRING> <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif S == <STRING> <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> a = [ <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> print ( a [ a . index ( s ) + 1 ] <NEWLINE>
w = [ <STRING> , <STRING> , <STRING> ] <NEWLINE> print ( w [ ( w . index ( input ) + 1 ) % 3 ] ) <NEWLINE>
s = input ( ) <NEWLINE> w = ( Sunny , Cloudy , Rainy , Sunny ) <NEWLINE> n = w . index ( s ) <NEWLINE> print ( w [ n + 1 ] ) <NEWLINE>
S = input ( ) <NEWLINE> weather = [ <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> print ( weather [ weather . index ( S ) + 1 ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <NL> N = input ( ) <NEWLINE> <NL> if N == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) : <NEWLINE> <DEDENT> elif N == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) : <NEWLINE> <DEDENT> elif N == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
S = input ( ) <NEWLINE> <NL> if S == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> elif S == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> elif : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <NL> <DEDENT>
weather = input ( ) <NEWLINE> <NL> if weather == <STRING> : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <NL> <DEDENT> if weather == <STRING> : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <NL> <DEDENT> if weather == <STRING> : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> if ans != 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> if i % 2 == 0 : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
str = input ( ) <NEWLINE> ans = <STRING> <NEWLINE> for i in len ( str ) : <NEWLINE> <INDENT> if ( i + 1 ) % 2 == 0 and str [ i ] not in ( <STRING> , <STRING> , <STRING> ) : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <DEDENT> if ( i + 1 ) % 2 == 1 and str [ i ] not in ( <STRING> , <STRING> , <STRING> ) : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
S = input ( ) <NEWLINE> for i in range ( len ( S ) + 1 ) : <NEWLINE> <INDENT> if i == len ( S ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> if S [ i ] == <STRING> or S [ i ] == <STRING> : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if S [ i ] % 2 == 0 : <NEWLINE> <INDENT> if S [ i ] == <STRING> : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if S [ i ] == <STRING> : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <NL> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT>
import sys <NEWLINE> S = list ( input ( ) ) <NEWLINE> S_odd = S [ : : 2 ] <NEWLINE> S_even = S [ 1 : : 2 ] <NEWLINE> easy_odd = [ <STRING> , <STRING> , <STRING> ] <NEWLINE> easy_even = [ <STRING> , <STRING> , <STRING> ] <NEWLINE> <NL> print ( <STRING> ) if set ( S_odd ) . issubset ( easy_odd ) and set ( S_even ) . issubset ( easy_even ) else <NEWLINE> <INDENT> print ( <STRING> <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> s = input ( ) <NEWLINE> for i in len ( s ) : <NEWLINE> <INDENT> if i % 2 == 0 : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
S = input ( ) <NEWLINE> O = [ <STRING> , <STRING> , <STRING> ] <NEWLINE> E = [ <STRING> , <STRING> , <STRING> ] <NEWLINE> ng = False <NEWLINE> for i in range ( len ( S ) ) : <NEWLINE> <INDENT> if i % 2 == 0 : <NEWLINE> <INDENT> if S [ i ] not in O : <NEWLINE> <INDENT> ng = True <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if S [ i ] not in E : <NEWLINE> <INDENT> ng = True <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) if ng print ( <STRING> ) <NEWLINE>
a = input ( ) <NEWLINE> if a % 2 == 0 : <NEWLINE> <INDENT> for i in range ( int ( len ( a ) / 2 ) ) : <NEWLINE> <INDENT> if a [ 2 * i ] == <STRING> or a [ 2 * i ] == <STRING> or a [ 2 * i ] == <STRING> : <NEWLINE> <INDENT> b = b + 1 <NEWLINE> <DEDENT> if a [ 2 * i + 1 ] == <STRING> or a [ 2 * i + 1 ] == <STRING> or a [ 2 * i + 1 ] == <STRING> : <NEWLINE> <INDENT> b = b + 1 <NEWLINE> <DEDENT> <DEDENT> if b = len ( a ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> if a % 2 == 1 : <NEWLINE> <INDENT> for i in range ( int ( len ( a ) / 2 ) + 1 ) : <NEWLINE> <INDENT> if a [ 2 * i ] == <STRING> or a [ 2 * i ] == <STRING> or a [ 2 * i ] == <STRING> : <NEWLINE> <INDENT> b = b + 1 <NEWLINE> <DEDENT> <DEDENT> for i in range ( int ( len ( a ) / 2 ) ) : <NEWLINE> <INDENT> if a [ 2 * i + 1 ] == <STRING> or a [ 2 * i + 1 ] == <STRING> or a [ 2 * i + 1 ] == <STRING> : <NEWLINE> <INDENT> b = b + 1 <NEWLINE> <DEDENT> <DEDENT> if b = len ( a ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
S = input ( ) <NEWLINE> <NL> check = True <NEWLINE> for i , s in enumerate ( S ) : <NEWLINE> <INDENT> if ( i + 1 ) % 2 == 0 : <NEWLINE> <INDENT> if not ( s == <STRING> or s == <STRING> or s == <STRING> ) : <NEWLINE> <INDENT> check = False <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if not ( s == <STRING> or s == <STRING> or s = <STRING> ) : <NEWLINE> <INDENT> check = False <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if check : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
S = input ( ) <NEWLINE> print ( <STRING> [ len ( re . sub ( <STRING> , <STRING> , S [ 0 : : 2 ] ) ) == 0 == len ( re . sub ( <STRING> , <STRING> , S [ 1 : : 2 ] ) ) : : 2 ] ) <NEWLINE>
odd = <STRING> <NEWLINE> even = <STRING> <NEWLINE> s = int ( input ( ) ) <NEWLINE> flag = 0 <NEWLINE> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> a = i + 1 <NEWLINE> if a % 2 == 0 : <NEWLINE> <INDENT> if s [ i ] not in even : <NEWLINE> <INDENT> flag = 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if s [ i ] not in odd : <NEWLINE> <INDENT> flag = 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if flag == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
S = input ( ) <NEWLINE> <NL> N = len ( S ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> for i in range ( N ) : <NEWLINE> <INDENT> if ( i % 2 == 0 and S [ i ] == <STRING> ) or ( i % 2 == 1 and S [ i ] == <STRING> ) : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
S = str ( input ( ) ) <NEWLINE> <NL> Ans = True <NEWLINE> for i in range ( 0 , len ( S ) ) : <NEWLINE> <INDENT> if i % 2 == 0 : <NEWLINE> <INDENT> if S [ i ] == <STRING> or S [ i ] == <STRING> or S [ i ] == <STRING> : <NEWLINE> else : <NEWLINE> <INDENT> Ans = False <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if i % 2 != 0 : <NEWLINE> <INDENT> if S [ i ] == <STRING> or S [ i ] == <STRING> or S [ i ] == <STRING> : <NEWLINE> else : <NEWLINE> <INDENT> Ans = False <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> if Ans == False : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s = list ( input ( ) ) <NEWLINE> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> if i % 2 == 0 and s [ i ] == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> if i % 2 == 1 and s [ i ] == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( Yes ) <NEWLINE>
N , K , Q = list ( map ( lambda n : int ( n ) , input ( ) . split ( <STRING> ) ) ) <NEWLINE> point = [ K - Q ] * N <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> c = int ( input ( ) ) <NEWLINE> point [ c - 1 ] += 1 <NEWLINE> <NL> <DEDENT> print ( <STRING> . join ( [ <STRING> if p > 0 else <STRING> for p in point ] ) ) <NEWLINE>
inp = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> n = inp [ 0 ] <NEWLINE> k = inp [ 1 ] <NEWLINE> q = inp [ 2 ] <NEWLINE> if q < k : <NEWLINE> <INDENT> for i in range ( n ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> arr = [ k - q ] * ( n ) <NEWLINE> z = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> x = int ( input ( ) ) <NEWLINE> arr [ x - 1 ] += 1 <NEWLINE> <DEDENT> <DEDENT> for i in range ( len ( arr ) ) : <NEWLINE> <INDENT> if arr [ i ] > 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
def i ( ) : <NEWLINE> <INDENT> return int ( input ( ) ) <NEWLINE> <DEDENT> def i2 ( ) : <NEWLINE> <INDENT> return map ( int , input ( ) . split ( ) ) <NEWLINE> <DEDENT> def s ( ) : <NEWLINE> <INDENT> return str ( input ( ) ) <NEWLINE> <DEDENT> def l ( ) : <NEWLINE> <INDENT> return list ( input ( ) ) <NEWLINE> <DEDENT> def intl ( ) : <NEWLINE> <INDENT> return list ( int ( k ) for k in input ( ) . split ( ) ) <NEWLINE> <NL> <DEDENT> n , k , q = i2 ( ) <NEWLINE> ls = [ k - q ] * n <NEWLINE> for _ in range ( q ) : <NEWLINE> <INDENT> a = i ( ) <NEWLINE> ls [ a - 1 ] += 1 <NEWLINE> <NL> <DEDENT> for _ in range ( n ) : <NEWLINE> <INDENT> if ls [ j ] > 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
n , k , q = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> start = [ k - q ] * n <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> start [ A [ i ] ] += 1 <NEWLINE> <NL> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> if start [ i ] > 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
n , k , q = map ( int , input ( ) . split ( ) ) <NEWLINE> point = [ 0 ] * ( n + 1 ) <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> a = int ( input ( ) ) <NEWLINE> point [ a ] += 1 <NEWLINE> <NL> <DEDENT> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if k + point [ i ] > q : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
<STRING> <NEWLINE> <NL> N , K , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> A = ( int ( x ) for x in open ( 0 ) . input ( ) . split ( ) ) <NEWLINE> <NL> score = [ K - Q ] * ( N + 1 ) <NEWLINE> for x in A : <NEWLINE> <INDENT> score [ x ] += 1 <NEWLINE> <NL> <DEDENT> ans = <STRING> . join ( <STRING> if x <= 0 else <STRING> for x in score [ 1 : ] ) <NEWLINE> print ( ans ) <NEWLINE>
import sys <NEWLINE> import numpy as np <NEWLINE> <NL> <NL> def main ( stdin ) : <NEWLINE> <INDENT> N , K , Q = stdin [ : 3 ] <NEWLINE> ans = np . full ( N + 1 , K - Q , dtype = np . int64 ) <NEWLINE> for i in stdin [ 3 : ] : <NEWLINE> <INDENT> ans [ i ] += 1 <NEWLINE> <DEDENT> ans = np . where ( ans > 0 , <STRING> , <STRING> ) <NEWLINE> return ans [ 1 : ] <NEWLINE> <NL> <NL> <DEDENT> if sys . argv [ - 1 ] == <STRING> : <NEWLINE> <INDENT> import numba <NEWLINE> from numba . pycc import CC <NEWLINE> cc = CC ( <STRING> ) <NEWLINE> cc . export ( <STRING> , <STRING> ) ( main ) <NEWLINE> <COMMENT> <NL> cc . compile ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> from my_module import main <NEWLINE> stdin = np . array ( [ int ( _ ) for _ in open ( 0 ) . read ( ) . split ( ) ] ) <NEWLINE> print ( * main ( stdin ) , sep = <STRING> ) <NEWLINE> <DEDENT>
N , K , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if K > Q : <NEWLINE> <INDENT> ans = [ <STRING> for i in range ( N ) ] <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> exit ( ) <NEWLINE> <NL> T = [ 0 for i in range ( N ) ] <NEWLINE> t = Q - K <NEWLINE> <NL> for i in range ( Q ) : <NEWLINE> <INDENT> a = int ( input ( ) ) <NEWLINE> T [ a ] += 1 <NEWLINE> <NL> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> if T [ i ] > t : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
eople , point , quiz = map ( int , input ( ) . split ( ) ) <NEWLINE> an = [ int ( input ( ) ) for _ in range ( quiz ) ] <NEWLINE> each_p = [ point - quiz ] * people <NEWLINE> <NL> for x in an : <NEWLINE> <INDENT> each_p [ x - 1 ] += 1 <NEWLINE> <NL> <DEDENT> for y in each_p : <NEWLINE> <INDENT> if y <= 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
n , k , q = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> ans = k <NEWLINE> for j in range ( q ) : <NEWLINE> <INDENT> que = int ( input ( ) ) <NEWLINE> if que != i : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <DEDENT> if ans <= 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> if ans <= 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT>
from heapq import heapify , heappush , heappop <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> N , M = map ( int , input ( ) split ( ) ) <NEWLINE> A = [ - x for x in map ( int , input ( ) . split ( ) ) ] <NEWLINE> heapify ( A ) <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> tmp = heappop ( A ) <NEWLINE> tmp2 = tmp // 2 <NEWLINE> heappush ( A , tmp2 ) <NEWLINE> <DEDENT> ans = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> ans += A [ i ] <NEWLINE> <NL> <DEDENT> ans = abs ( ans ) <NEWLINE> return ans <NEWLINE> <NL> <DEDENT> print ( main ( ) ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i in range ( 0 , M ) : <NEWLINE> <INDENT> A [ A . index ( max ) ] = int ( A [ A . index ( max ) ] ) <NEWLINE> <NL> <DEDENT> print ( sum ( A ) ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ int ( x ) * - 1 for x in input ( ) . split ( ) ] <NEWLINE> ans = sum ( a ) * - 1 <NEWLINE> diff = 0 <NEWLINE> <NL> heapify ( a ) <NEWLINE> for _ in range ( 1 , m + 1 ) : <NEWLINE> <INDENT> _h_a = heappop ( a ) * - 1 <NEWLINE> diff += _h_a - _h_a // 2 <NEWLINE> heappush ( a , ( _h_a // 2 ) * - 1 ) <NEWLINE> <DEDENT> ans -= diff <NEWLINE> print ( ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
def getN ( ) : <NEWLINE> <INDENT> return int ( input ( ) ) <NEWLINE> <DEDENT> def getNM ( ) : <NEWLINE> <INDENT> return map ( int , input ( ) . split ( ) ) <NEWLINE> <DEDENT> def getList ( ) : <NEWLINE> <INDENT> return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <DEDENT> def getArray ( intn ) : <NEWLINE> <INDENT> return [ int ( input ( ) ) for i in range ( intn ) ] <NEWLINE> <DEDENT> def input ( ) : <NEWLINE> <INDENT> return sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> <DEDENT> def rand_N ( ran1 , ran2 ) : <NEWLINE> <INDENT> return random . randint ( ran1 , ran2 ) <NEWLINE> <DEDENT> def rand_List ( ran1 , ran2 , rantime ) : <NEWLINE> <INDENT> return [ random . randint ( ran1 , ran2 ) for i in range ( rantime ) ] <NEWLINE> <DEDENT> def rand_ints_nodup ( ran1 , ran2 , rantime ) : <NEWLINE> <INDENT> ns = [ ] <NEWLINE> while len ( ns ) < rantime : <NEWLINE> <INDENT> n = random . randint ( ran1 , ran2 ) <NEWLINE> if not n in ns : <NEWLINE> <INDENT> ns . append ( n ) <NEWLINE> <DEDENT> <DEDENT> return sorted ( ns ) <NEWLINE> <NL> <DEDENT> def rand_query ( ran1 , ran2 , rantime ) : <NEWLINE> <INDENT> r_query = [ ] <NEWLINE> while len ( r_query ) < rantime : <NEWLINE> <INDENT> n_q = rand_ints_nodup ( ran1 , ran2 , 2 ) <NEWLINE> if not n_q in r_query : <NEWLINE> <INDENT> r_query . append ( n_q ) <NEWLINE> <DEDENT> <DEDENT> return sorted ( r_query ) <NEWLINE> <NL> <DEDENT> from collections import defaultdict , deque , Counter <NEWLINE> from sys import exit <NEWLINE> from decimal import * <NEWLINE> import heapq <NEWLINE> import math <NEWLINE> from fractions import gcd <NEWLINE> import random <NEWLINE> import string <NEWLINE> import copy <NEWLINE> from itertools import combinations , permutations , product <NEWLINE> from operator import mul <NEWLINE> from functools import reduce <NEWLINE> from bisect import bisect_left , bisect_right <NEWLINE> <NL> import sys <NEWLINE> sys . setrecursionlimit ( 1000000000 ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> N = getN ( ) <NEWLINE> S = <STRING> + input ( ) <NEWLINE> <NL> lista = defaultdict ( int ) <NEWLINE> <NL> for i in range ( N // 2 , - 1 , - 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , N - i + 1 ) : <NEWLINE> <INDENT> opt = S [ j : i + j + 1 ] <NEWLINE> if lista [ opt ] == 0 : <NEWLINE> <INDENT> lista [ opt ] = i + j <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if lista [ opt ] < j : <NEWLINE> <INDENT> print ( len ( opt ) ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( 0 ) <NEWLINE>
import sys <NEWLINE> import numpy as np <NEWLINE> from numba import njit <NEWLINE> <NL> def main ( N , S , dp ) : <NEWLINE> <INDENT> ans = 0 <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , N ) : <NEWLINE> <INDENT> dp [ i , j ] = min ( j - i , dp [ i - 1 , j - 1 ] + 1 ) if S [ i ] == S [ j ] else 0 <NEWLINE> <DEDENT> ans = max ( ans , np . max ( dp [ i ] ) ) <NEWLINE> <DEDENT> return ans <NEWLINE> <NL> <NL> <DEDENT> if sys . argv [ - 1 ] == <STRING> : <NEWLINE> <INDENT> import numba <NEWLINE> from numba . pycc import CC <NEWLINE> i8 = numba . int64 <NEWLINE> cc = CC ( <STRING> ) <NEWLINE> <NL> def cc_export ( f , signature ) : <NEWLINE> <INDENT> cc . export ( f . __name__ , signature ) ( f ) <NEWLINE> return numba . njit ( f ) <NEWLINE> <NL> <DEDENT> main = cc . export ( main , ( i8 , i8 [ : ] , i8 [ : , : ] , ) ) <NEWLINE> cc . compile ( ) <NEWLINE> <NL> <DEDENT> from my_module import main <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> S = np . array ( [ ord ( _ ) for _ in input ( ) ] ) <NEWLINE> dp = np . zeros ( ( N + 1 , N + 1 ) , dtype = int ) <NEWLINE> print ( main ( N , S , dp ) ) <NEWLINE>
import numpy as np <NEWLINE> import numba <NEWLINE> @ numba . jit <NEWLINE> def solve ( n , s ) : <NEWLINE> <INDENT> dp = np . zeros ( ( n + 1 , n + 1 ) , dtype = np . int16 ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n ) : <NEWLINE> <INDENT> if s [ i ] == s [ j ] : <NEWLINE> <INDENT> if dp [ i ] [ j ] < j - i : <NEWLINE> <INDENT> dp [ i + 1 ] [ j + 1 ] = dp [ i ] [ j ] + 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( np . amax ( dp ) ) <NEWLINE> <DEDENT> n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> solve ( n , s ) <NEWLINE>
import sys <NEWLINE> import numpy as np <NEWLINE> <NL> def main ( N , S , dp ) : <NEWLINE> <INDENT> ans = 0 <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , N ) : <NEWLINE> <INDENT> dp [ i , j ] = min ( j - i , dp [ i - 1 , j - 1 ] + 1 ) if S [ i ] == S [ j ] else 0 <NEWLINE> <DEDENT> ans = max ( ans , np . max ( dp [ i ] ) ) <NEWLINE> <DEDENT> return ans <NEWLINE> <NL> <NL> <DEDENT> if sys . argv [ - 1 ] == <STRING> : <NEWLINE> <INDENT> import numba <NEWLINE> from numba . pycc import CC <NEWLINE> cc = CC ( <STRING> ) <NEWLINE> cc . export ( <STRING> , <STRING> ) ( main ) <NEWLINE> <COMMENT> <NL> cc . compile ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> from my_module import main <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> 1 <NEWLINE> <DEDENT> dp = np . zeros ( ( N + 1 , N + 1 ) , dtype = int ) <NEWLINE> N = int ( input ( ) ) <NEWLINE> S = np . array ( [ ord ( _ ) for _ in input ( ) ] ) <NEWLINE> print ( main ( N , S , dp ) ) <NEWLINE> <DEDENT>
def numba_compile ( numba_config ) : <NEWLINE> <INDENT> import os , sys <NEWLINE> if sys . argv [ - 1 ] == <STRING> : <NEWLINE> <INDENT> from numba import njit <NEWLINE> from numba . pycc import CC <NEWLINE> cc = CC ( <STRING> ) <NEWLINE> for func , signature in numba_config : <NEWLINE> <INDENT> vars ( ) [ func . __name__ ] = njit ( signature ) ( func ) <NEWLINE> cc . export ( func . __name__ , signature ) ( func ) <NEWLINE> <DEDENT> cc . compile ( ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> elif os . name == <STRING> : <NEWLINE> <INDENT> exec ( <STRING> ) <NEWLINE> for func , _ in numba_config : <NEWLINE> <INDENT> globals ( ) [ func . __name__ ] = vars ( ) [ func . __name__ ] <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> from numba import njit <NEWLINE> for func , signature in numba_config : <NEWLINE> <INDENT> globals ( ) [ func . __name__ ] = njit ( signature , cache = True ) ( func ) <NEWLINE> <DEDENT> print ( <STRING> , file = sys . stderr ) <NEWLINE> <NL> <DEDENT> <DEDENT> import sys <NEWLINE> import numpy as np <NEWLINE> <NL> def z_algo ( S ) : <COMMENT> <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <INDENT> i , j , n = 1 , 0 , len ( S ) <NEWLINE> Z = np . zeros ( S . shape , dtype = np . int64 ) <NEWLINE> Z [ 0 ] = n <NEWLINE> while i < n : <NEWLINE> <INDENT> while i + j < n and S [ j ] == S [ i + j ] : <NEWLINE> <INDENT> j += 1 <NEWLINE> <DEDENT> if j == 0 : <NEWLINE> <INDENT> i += 1 <NEWLINE> continue <NEWLINE> <DEDENT> Z [ i ] = j <NEWLINE> d = 1 <NEWLINE> while i + d < n and d + Z [ d ] < j : <NEWLINE> <INDENT> Z [ i + d ] = Z [ d ] <NEWLINE> d += 1 <NEWLINE> <DEDENT> i += d <NEWLINE> j -= d <NEWLINE> <DEDENT> return Z <NEWLINE> <NL> <DEDENT> def solve ( N , S ) : <NEWLINE> <INDENT> ans = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> Z = z_algo ( S [ i : ] ) <NEWLINE> for idx_Z , z in enumerate ( Z ) : <NEWLINE> <INDENT> an = min ( z , idx_Z ) <NEWLINE> ans = max ( ans , an ) <NEWLINE> <DEDENT> <DEDENT> return ans <NEWLINE> <NL> <DEDENT> numba_compile ( [ <NEWLINE> <INDENT> [ z_algo , <STRING> ] , <NEWLINE> [ solve , <STRING> ] <NEWLINE> <DEDENT> ] ) <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> N = int ( sys . stdin . buffer . readline ( ) ) <NEWLINE> S = np . frombuffer ( sys . stdin . buffer . readline ( ) , dtype = np . uint8 ) . copy ( ) <NEWLINE> ans = solve ( N , S ) <NEWLINE> print ( ans ) <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE>
from typing import List <NEWLINE> <NL> <NL> class RollingHash : <NEWLINE> <INDENT> __slots__ = [ <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> <NL> def __init__ ( self , source : str , base : int = 1007 , mod : int = 10 ** 9 + 7 ) : <NEWLINE> <INDENT> self . source = source <NEWLINE> self . length = len ( source ) <NEWLINE> self . base = base <NEWLINE> self . mod = mod <NEWLINE> self . hash = self . _get_hash_from_zero ( ) <NEWLINE> self . power = self . _get_base_pow ( ) <NEWLINE> <NL> <DEDENT> def _get_hash_from_zero ( self ) -> List [ int ] : <NEWLINE> <INDENT> <STRING> <NEWLINE> hash_from_zero = [ 0 ] * self . length <NEWLINE> cur = 0 <NEWLINE> for i , c in enumerate ( self . source ) : <NEWLINE> <INDENT> cur = ( cur * self . base + ord ( c ) ) % self . mod <NEWLINE> hash_from_zero [ i ] = cur <NEWLINE> <DEDENT> return hash_from_zero <NEWLINE> <NL> <DEDENT> def _get_base_pow ( self ) -> List [ int ] : <NEWLINE> <INDENT> <STRING> <NEWLINE> power = [ 1 ] * self . length <NEWLINE> cur = 1 <NEWLINE> for i in range ( self . length ) : <NEWLINE> <INDENT> cur *= self . base % self . mod <NEWLINE> power [ i ] = cur <NEWLINE> <DEDENT> return power <NEWLINE> <NL> <DEDENT> def get_hash ( self , left : int , right : int ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> return ( <NEWLINE> <INDENT> self . hash [ right ] - self . hash [ left ] * self . power [ right - left ] <NEWLINE> <DEDENT> ) % self . mod <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def abc141_e ( ) : <NEWLINE> <COMMENT> <NL> <INDENT> N = int ( input ( ) ) <NEWLINE> S = input ( ) . rstrip ( ) <NEWLINE> rh = RollingHash ( S ) <NEWLINE> ok , ng = 0 , N // 2 + 1 <NEWLINE> while ng - ok > 1 : <NEWLINE> <INDENT> mid = ( ok + ng ) // 2 <NEWLINE> flg = False <NEWLINE> memo = set ( ) <NEWLINE> for i in range ( N - 2 * mid + 1 ) : <NEWLINE> <INDENT> memo . add ( rh . get_hash ( i , i + mid ) ) <NEWLINE> if rh . get_hash ( i + mid , i + 2 * mid ) in memo : <NEWLINE> <INDENT> flg = True <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if flg : <NEWLINE> <INDENT> ok = mid <COMMENT> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ng = mid <COMMENT> <NEWLINE> <DEDENT> <DEDENT> print ( ok ) <COMMENT> <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> abc141_e ( ) <NEWLINE> <DEDENT>
print ( int ( input ( ) ** 3 ) ) <NEWLINE>
N = import ( ) <NEWLINE> output = N * N * N <NEWLINE> print ( output ) <NEWLINE>
print ( ( input ( ) ) ^ 3 ) <NEWLINE>
import itertools <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> print ( sum ( [ 1 for i , j , k in itertools . product ( range ( 1 , N + 1 ) , range ( 1 , N + 1 ) , range ( 1 , N + 1 ) ) ] ) ) <NEWLINE> <DEDENT>
print = ( input ( ) ** 3 ) <NEWLINE>
<COMMENT> <NL> N = int ( input ( ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A = [ B [ 0 ] ] <NEWLINE> for i in range ( 1 , N - 1 ) : <NEWLINE> <INDENT> if B [ i ] > B [ i - 1 ] : <NEWLINE> <INDENT> A . append ( B [ i - 1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> A . append ( B [ i ] ) <NEWLINE> <DEDENT> <DEDENT> A . append ( B [ - 1 ] ) <NEWLINE> print ( sum ( A ) ) <NEWLINE>
s = int ( input ( ) ) <NEWLINE> <NL> print ( n ** 3 ) <NEWLINE>
print ( int ( input ( ) ** 3 ) ) <NEWLINE>
n = int ( input ) <NEWLINE> print ( n * n * n ) <NEWLINE>
<COMMENT> <NL> from itertools import combination_with_replacement <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> print ( len ( list ( combination_with_replacement ( n , 3 ) ) ) ) <NEWLINE>
N = input ( ) <NEWLINE> print ( N ** 3 ) <NEWLINE>
prnt ( int ( input ( ) ) ** 3 ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> C = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> d = sum ( B ) <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> if A [ i + 1 ] - A [ i ] == 1 : <NEWLINE> <INDENT> d += B [ A [ i - 1 ] ] <NEWLINE> <DEDENT> <DEDENT> print ( d ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> addans = 0 <NEWLINE> <NL> for i in range ( 1 , n ) : <NEWLINE> <INDENT> if a [ i - 1 ] + 1 == a [ i ] : <NEWLINE> <INDENT> addans += c [ a [ i - 2 ] ] <NEWLINE> print ( addans ) <NEWLINE> <DEDENT> <DEDENT> print ( sum ( b ) + addans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( lambda a : int ( a ) , input ( ) . split ( <STRING> ) ) ) <NEWLINE> B = list ( map ( lambda b : int ( b ) , input ( ) . split ( <STRING> ) ) ) <NEWLINE> C = list ( map ( lambda c : int ( c ) , input ( ) . split ( <STRING> ) ) ) <NEWLINE> <NL> satis = 0 <NEWLINE> <NL> for i in range ( len ( A ) ) : <NEWLINE> <INDENT> satis += B [ A [ i ] ] <NEWLINE> if i >= 1 and A [ i ] - A [ i - 1 ] == 1 : <NEWLINE> <INDENT> satis += C [ i - 1 ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( satis ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> C = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> s = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> s += B [ A [ i ] - 1 ] <NEWLINE> if i != 0 and A [ i - 1 ] + 1 == A [ i ] : <NEWLINE> <INDENT> s += C [ i ] <NEWLINE> <DEDENT> <DEDENT> print ( s ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> p = O <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> p += b [ a [ i ] - 1 ] <NEWLINE> if i >= 1 and a [ i ] - a [ i - 1 ] == 1 : <NEWLINE> <INDENT> p += c [ a [ i - 1 ] - 1 ] <NEWLINE> <DEDENT> <DEDENT> print ( p ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> C = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> ans = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> ans += B [ A [ i ] - 1 ] <NEWLINE> if ( i >= 1 ) : <NEWLINE> <INDENT> if ( A [ i ] == A [ i - 1 ] + 1 ) : <NEWLINE> <INDENT> ans += C [ i ] <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL>
N = int ( input ( ) ) <NEWLINE> A = [ int ( input ( ) ) for i in range ( N ) ] <NEWLINE> B = [ int ( input ( ) ) for i in range ( N ) ] <NEWLINE> C = [ int ( input ( ) ) for i in range ( N - 1 ) ] <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> ans += B [ A [ i ] - 1 ] <NEWLINE> if i > 0 and A [ i ] - A [ i - 1 ] == 1 : <NEWLINE> <INDENT> ans += C [ A [ i ] - 2 ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> C = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> res = 0 <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> res += B [ i ] <NEWLINE> if A [ i ] + 1 == A [ i + 1 ] : <NEWLINE> res += C [ A [ i ] - 1 ] <NEWLINE> <DEDENT> print ( res ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> bef = a [ 0 ] - 1 <NEWLINE> man = b [ 0 ] <NEWLINE> <NL> for i in a [ 1 : ] : <NEWLINE> <INDENT> if i - 1 = bef + 1 : <NEWLINE> <INDENT> man += c [ bef ] <NEWLINE> <DEDENT> man += b [ i - 1 ] <NEWLINE> bef = i - 1 <NEWLINE> <DEDENT> print ( man ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = map ( int , input ( ) . split ( ) ) <NEWLINE> b = sum ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c = map ( int , input ( ) . split ( ) ) <NEWLINE> s = 0 <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> if a [ i + 1 ] - a [ i ] == 1 : <NEWLINE> <INDENT> s += c [ a [ i ] - 1 ] <NEWLINE> <DEDENT> <DEDENT> print ( b + s ) <NEWLINE>
def Input ( ) : <NEWLINE> <INDENT> return mapt ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> b = Input ( ) <NEWLINE> data = 0 <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> data += b [ i ] <NEWLINE> continue <NEWLINE> <DEDENT> data += min ( b [ i ] , b [ i - 1 ] ) <NEWLINE> <DEDENT> data += b [ - 1 ] <NEWLINE> print ( data ) <NEWLINE> <DEDENT> main ( ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = [ b [ 0 ] , b [ n - 2 ] ] <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> a . append ( min ( a [ i + 1 ] , a [ i + 2 ] ) ) <NEWLINE> <DEDENT> print ( sum ( a ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = [ b [ 0 ] ] <NEWLINE> <NL> for i in range ( n - 1 ) : <NEWLINE> <INDENT> a . append ( min ( b [ i ] , b [ i + 1 ] ) ) <NEWLINE> <NL> <DEDENT> a . append ( b [ - 1 ] ) <NEWLINE> print ( sum ( a ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> b = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> a = [ b [ 0 ] ] <NEWLINE> <NL> for x in range ( n - 1 ) : <NEWLINE> <INDENT> s = min ( b [ x ] , b [ x + 1 ] ) <NEWLINE> a . append ( s ) <NEWLINE> <NL> <DEDENT> a . append ( b [ - 1 ] ) <NEWLINE> <NL> print ( sum ( a ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> bb = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> aa = [ 0 ] * n <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> aa [ i ] = max ( a [ i ] , bb [ i ] ) <NEWLINE> aa [ i + 1 ] = max ( a [ i + 1 ] , bb [ i ] ) <NEWLINE> <DEDENT> print ( sum ( aa ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> a [ 0 ] = b [ 0 ] <NEWLINE> a [ n - 1 ] = b [ n - 2 ] <NEWLINE> <NL> for i in range ( 1 , n - 1 ) : <NEWLINE> <INDENT> if b [ i ] >= b [ i - 1 ] : <NEWLINE> <INDENT> a [ i ] = b [ i - 1 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a [ i ] = b [ i ] <NEWLINE> <NL> <DEDENT> <DEDENT> c = 0 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> c += a [ i ] <NEWLINE> <DEDENT> print ( c ) <NEWLINE> <NL> <NL> <NL>
n = int ( input ( ) ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> dp = [ 10 ** 8 ] * <COMMENT> <NEWLINE> <NL> for i in range ( n - 1 ) : <NEWLINE> <INDENT> if dp [ i ] > b [ i ] : <NEWLINE> <INDENT> dp [ i ] = b [ i ] <NEWLINE> <DEDENT> if dp [ i + 1 ] > b [ i ] : <NEWLINE> <INDENT> dp [ i + 1 ] = b [ i ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( sum ( dp ) ) <NEWLINE>
input_data = input ( ) . split ( <STRING> ) <NEWLINE> N = int ( input_data [ 0 ] ) <NEWLINE> ls = [ int ( b ) for b in input_data [ 1 ] . split ( ) ] <NEWLINE> if len ( ls ) == 1 : <NEWLINE> <INDENT> print ( ls [ 0 ] * 2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> first = ls [ 0 ] <NEWLINE> als = [ ls [ 0 ] ] <NEWLINE> <NL> for n in range ( 1 , N - 1 ) : <NEWLINE> <INDENT> als . append ( min ( ls [ n - 1 ] , ls [ n ] ) ) <NEWLINE> <DEDENT> als . append ( ls [ - 1 ] ) <NEWLINE> print ( sum ( als ) ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> b = list ( map ( in , input ( ) . split ( ) ) ) <NEWLINE> ans = b [ 0 ] + b [ - 1 ] <NEWLINE> for i in range ( n - 2 ) : <NEWLINE> <INDENT> ans += min ( b [ i ] , b [ i - 1 ] ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> S = input ( ) <NEWLINE> <NL> <COMMENT> <NL> cnt = 1 <NEWLINE> <NL> for i in range ( N - 1 ) : <NEWLINE> <INDENT> if S [ i ] != S [ i + 1 ] : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> print ( N - max ( 1 , cnt - 2 * k ) ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> S = input ( ) <NEWLINE> <NL> h = 0 <NEWLINE> for i in range ( len ( S ) - 1 ) : <NEWLINE> <INDENT> if s [ i ] == S [ i + 1 ] : <NEWLINE> <INDENT> h += 1 <NEWLINE> <DEDENT> <DEDENT> h += 2 * K <NEWLINE> print ( min ( N - 1 , h ) ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> s = list ( input ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> tran = 0 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> chk = s [ i ] + s [ i + 1 ] <NEWLINE> <NL> if chk == <STRING> or chk == <STRING> : <NEWLINE> <INDENT> tran += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if k * 2 >= tran : <NEWLINE> <INDENT> print ( n - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( tran + ( k * 2 ) ) <NEWLINE> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> s = input ( ) <NEWLINE> pre = s [ 0 ] <NEWLINE> rsans = s [ 0 ] <NEWLINE> first = s [ 0 ] <NEWLINE> <NL> if s [ 0 ] == <STRING> : <NEWLINE> <INDENT> second = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> second = <STRING> <NEWLINE> <NL> <DEDENT> for i in s [ 1 : ] : <NEWLINE> <INDENT> if i == second and k > 0 : <NEWLINE> <INDENT> ans = ans + first <NEWLINE> pre = i <NEWLINE> <DEDENT> elif i == first and pre == second : <NEWLINE> <INDENT> k -= 1 <NEWLINE> ans = ans + i <NEWLINE> pre = i <NEWLINE> <DEDENT> elif k == 0 : <NEWLINE> <INDENT> ans = ans + i <NEWLINE> <DEDENT> elif i == first and pre == first : <NEWLINE> <INDENT> ans = ans + i <NEWLINE> <NL> <DEDENT> <DEDENT> pre = <STRING> <NEWLINE> cnt = 0 <NEWLINE> <NL> for i in ans : <NEWLINE> <INDENT> if i == pre : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> pre = i <NEWLINE> <NL> <DEDENT> print ( cnt ) <NEWLINE>
import os <NEWLINE> import sys <NEWLINE> <NL> import numpy as np <NEWLINE> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> def solve ( inp ) : <NEWLINE> <INDENT> RBT_SIZE = 20 <NEWLINE> RBT_EOT = - 2 <NEWLINE> RBT_AVAILABLE_INDICES = set ( range ( RBT_SIZE - 1 ) ) <NEWLINE> RBT_CHILDREN = np . zeros ( ( RBT_SIZE , 2 ) , dtype = np . int64 ) <NEWLINE> RBT_VALUES = np . zeros ( RBT_SIZE , dtype = np . int64 ) <NEWLINE> RBT_COLORS = np . zeros ( RBT_SIZE , dtype = np . int64 ) <NEWLINE> RBT_COUNTS = np . zeros ( RBT_SIZE , dtype = np . int64 ) <NEWLINE> RBT_ROOT = - 1 <NEWLINE> RBT_CHILDREN [ RBT_ROOT , 0 ] = RBT_CHILDREN [ RBT_ROOT , 1 ] = RBT_ROOT <NEWLINE> <NL> def _rbt_rotate ( i , is_right ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> r = is_right <NEWLINE> ci = RBT_CHILDREN [ i , r ^ 1 ] <NEWLINE> RBT_CHILDREN [ i , r ^ 1 ] = RBT_CHILDREN [ ci , r ] <NEWLINE> RBT_CHILDREN [ ci , r ] = i <NEWLINE> RBT_COLORS [ ci ] = RBT_COLORS [ i ] <NEWLINE> RBT_COLORS [ i ] = 1 <NEWLINE> child_count = RBT_COUNTS [ ci ] <NEWLINE> RBT_COUNTS [ ci ] = RBT_COUNTS [ i ] <NEWLINE> RBT_COUNTS [ i ] -= child_count - RBT_COUNTS [ RBT_CHILDREN [ i , r ^ 1 ] ] <NEWLINE> return ci <NEWLINE> <NL> <DEDENT> def _rbt_balance_insert ( i , is_right ) : <NEWLINE> <INDENT> flag = True <NEWLINE> r = is_right <NEWLINE> if RBT_COLORS [ RBT_CHILDREN [ RBT_CHILDREN [ i , r ] , r ^ 1 ] ] == 1 : <NEWLINE> <INDENT> RBT_CHILDREN [ i , r ] = _rbt_rotate ( RBT_CHILDREN [ i , r ] , r ) <NEWLINE> <DEDENT> if RBT_COLORS [ RBT_CHILDREN [ RBT_CHILDREN [ i , r ] , r ] ] == 1 : <NEWLINE> <INDENT> if RBT_COLORS [ RBT_CHILDREN [ i , r ^ 1 ] ] == 1 : <NEWLINE> <INDENT> RBT_COLORS [ i ] = 1 <NEWLINE> RBT_COLORS [ RBT_CHILDREN [ i , r ] ] = RBT_COLORS [ RBT_CHILDREN [ i , r ^ 1 ] ] = 0 <NEWLINE> flag = False <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> i = _rbt_rotate ( i , r ^ 1 ) <NEWLINE> <DEDENT> <DEDENT> return i , flag <NEWLINE> <NL> <DEDENT> def _rbt_balance_delete ( i , is_right ) : <NEWLINE> <INDENT> flag = True <NEWLINE> stack = [ ( i , is_right ) ] <NEWLINE> while stack : <NEWLINE> <INDENT> i , r = stack . pop ( ) <NEWLINE> if RBT_COLORS [ RBT_CHILDREN [ RBT_CHILDREN [ i , r ^ 1 ] , r ] ] == 0 and RBT_COLORS [ RBT_CHILDREN [ RBT_CHILDREN [ i , r ^ 1 ] , r ^ 1 ] ] == 0 : <NEWLINE> <INDENT> if RBT_COLORS [ RBT_CHILDREN [ i , r ^ 1 ] ] == 0 : <NEWLINE> <INDENT> RBT_COLORS [ RBT_CHILDREN [ i , r ^ 1 ] ] = 1 <NEWLINE> if RBT_COLORS [ i ] == 0 : <NEWLINE> <INDENT> flag = False <NEWLINE> <DEDENT> RBT_COLORS [ i ] = 0 <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> i = _rbt_rotate ( i , r ) <NEWLINE> stack . append ( ( i , r ) ) <NEWLINE> stack . append ( ( RBT_CHILDREN [ i , r ] , r ) ) <NEWLINE> continue <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if RBT_COLORS [ RBT_CHILDREN [ RBT_CHILDREN [ i , r ^ 1 ] , r ] ] == 1 : <NEWLINE> <INDENT> RBT_CHILDREN [ i , r ^ 1 ] = _rbt_rotate ( RBT_CHILDREN [ i , r ^ 1 ] , r ^ 1 ) <NEWLINE> <DEDENT> i = _rbt_rotate ( i , r ) <NEWLINE> RBT_COLORS [ RBT_CHILDREN [ i , r ] ] = 0 <NEWLINE> RBT_COLORS [ RBT_CHILDREN [ i , r ^ 1 ] ] = 0 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> while stack : <NEWLINE> <INDENT> pi , r = stack . pop ( ) <NEWLINE> RBT_CHILDREN [ pi , r ] = i <NEWLINE> i = pi <NEWLINE> <NL> <DEDENT> return i , flag <NEWLINE> <NL> <DEDENT> def _rbt_get_min_in_subtree ( i , stack ) : <NEWLINE> <INDENT> while RBT_CHILDREN [ i , 0 ] != - 1 : <NEWLINE> <INDENT> stack . append ( ( i , 0 ) ) <NEWLINE> i = RBT_CHILDREN [ i , 0 ] <NEWLINE> <DEDENT> return i <NEWLINE> <NL> <DEDENT> def rbt_insert ( root , x ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> <NL> stack = [ ] <NEWLINE> i = root <NEWLINE> while i != - 1 : <NEWLINE> <INDENT> to_right = 1 if x >= RBT_VALUES [ i ] else 0 <NEWLINE> stack . append ( ( i , to_right ) ) <NEWLINE> i = RBT_CHILDREN [ i , to_right ] <NEWLINE> <NL> <DEDENT> for pi , _ in stack : <NEWLINE> <INDENT> RBT_COUNTS [ pi ] += 1 <NEWLINE> <NL> <DEDENT> i = RBT_AVAILABLE_INDICES . pop ( ) <NEWLINE> RBT_CHILDREN [ i , 0 ] = - 1 <NEWLINE> RBT_CHILDREN [ i , 1 ] = - 1 <NEWLINE> RBT_VALUES [ i ] = x <NEWLINE> RBT_COLORS [ i ] = 1 <NEWLINE> RBT_COUNTS [ i ] = 1 <NEWLINE> <NL> if stack : <NEWLINE> <INDENT> pi , r = stack [ - 1 ] <NEWLINE> RBT_CHILDREN [ pi , r ] = i <NEWLINE> <NL> <DEDENT> while stack : <NEWLINE> <INDENT> pi , is_right = stack . pop ( ) <NEWLINE> if RBT_COLORS [ pi ] == 1 : <NEWLINE> <INDENT> i = pi <NEWLINE> continue <NEWLINE> <DEDENT> RBT_CHILDREN [ pi , is_right ] = i <NEWLINE> i , flag = _rbt_balance_insert ( pi , is_right ) <NEWLINE> <NL> if stack and flag : <NEWLINE> <INDENT> pi , is_right = stack . pop ( ) <NEWLINE> RBT_CHILDREN [ pi , is_right ] = i <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> RBT_COLORS [ i ] = 0 <NEWLINE> return i <NEWLINE> <NL> <DEDENT> return root <NEWLINE> <NL> <DEDENT> def rbt_delete ( root , x ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> i = root <NEWLINE> stack = [ ] <NEWLINE> while i != - 1 and RBT_VALUES [ i ] != x : <NEWLINE> <INDENT> is_right = 1 if RBT_VALUES [ i ] < x else 0 <NEWLINE> stack . append ( ( i , is_right ) ) <NEWLINE> i = RBT_CHILDREN [ i , is_right ] <NEWLINE> <NL> <DEDENT> if i == - 1 : <NEWLINE> <INDENT> return root <NEWLINE> <NL> <DEDENT> if RBT_CHILDREN [ i , 0 ] != - 1 and RBT_CHILDREN [ i , 1 ] != - 1 : <NEWLINE> <INDENT> stack . append ( ( i , 1 ) ) <NEWLINE> mi = _rbt_get_min_in_subtree ( RBT_CHILDREN [ i , 1 ] , stack ) <NEWLINE> RBT_COLORS [ i ] = RBT_COLORS [ mi ] <NEWLINE> i = mi <NEWLINE> <NL> <DEDENT> for pi , _ in stack : <NEWLINE> <INDENT> RBT_COUNTS [ pi ] -= 1 <NEWLINE> <NL> <DEDENT> pi , is_right = stack [ - 1 ] <NEWLINE> if RBT_CHILDREN [ i , 0 ] == - 1 : <NEWLINE> <INDENT> RBT_CHILDREN [ pi , is_right ] = RBT_CHILDREN [ i , 1 ] <NEWLINE> RBT_COLORS [ RBT_CHILDREN [ i , 1 ] ] = 0 <NEWLINE> if RBT_CHILDREN [ i , 1 ] != - 1 or RBT_COLORS [ i ] == 1 : <NEWLINE> <INDENT> return root <NEWLINE> <DEDENT> <DEDENT> elif RBT_CHILDREN [ i , 1 ] == - 1 : <NEWLINE> <INDENT> RBT_CHILDREN [ pi , is_right ] = RBT_CHILDREN [ i , 0 ] <NEWLINE> RBT_COLORS [ RBT_CHILDREN [ i , 0 ] ] = 0 <NEWLINE> return root <NEWLINE> <NL> <DEDENT> while stack : <NEWLINE> <INDENT> pi , is_right = stack . pop ( ) <NEWLINE> i , flag = _rbt_balance_delete ( pi , is_right ) <NEWLINE> <NL> if stack and flag : <NEWLINE> <INDENT> pi , is_right = stack . pop ( ) <NEWLINE> RBT_CHILDREN [ pi , is_right ] = i <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> RBT_COLORS [ i ] = 0 <NEWLINE> return i <NEWLINE> <NL> <DEDENT> return root <NEWLINE> <NL> <DEDENT> def rbt_upper_bound ( root , x ) : <NEWLINE> <INDENT> i = root <NEWLINE> y = RBT_EOT <NEWLINE> c = RBT_COUNTS [ i ] <NEWLINE> j = 0 <NEWLINE> while i != - 1 : <NEWLINE> <INDENT> if x < RBT_VALUES [ i ] : <NEWLINE> <INDENT> y = RBT_VALUES [ i ] <NEWLINE> c = j + RBT_COUNTS [ RBT_CHILDREN [ i , 0 ] ] <NEWLINE> i = RBT_CHILDREN [ i , 0 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> j += RBT_COUNTS [ RBT_CHILDREN [ i , 0 ] ] + 1 <NEWLINE> i = RBT_CHILDREN [ i , 1 ] <NEWLINE> <DEDENT> <DEDENT> return y , c <NEWLINE> <NL> <DEDENT> def rbt_lower_bound ( root , x ) : <NEWLINE> <INDENT> i = root <NEWLINE> y = RBT_EOT <NEWLINE> c = RBT_COUNTS [ i ] <NEWLINE> j = 0 <NEWLINE> while i != - 1 : <NEWLINE> <INDENT> if x <= RBT_VALUES [ i ] : <NEWLINE> <INDENT> y = RBT_VALUES [ i ] <NEWLINE> c = j + RBT_COUNTS [ RBT_CHILDREN [ i , 0 ] ] <NEWLINE> i = RBT_CHILDREN [ i , 0 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> j += RBT_COUNTS [ RBT_CHILDREN [ i , 0 ] ] + 1 <NEWLINE> i = RBT_CHILDREN [ i , 1 ] <NEWLINE> <DEDENT> <DEDENT> return y , c <NEWLINE> <NL> <DEDENT> def rbt_get_k_th ( root , k ) : <NEWLINE> <INDENT> i = root <NEWLINE> if RBT_COUNTS [ i ] <= k : <NEWLINE> <INDENT> return RBT_EOT <NEWLINE> <DEDENT> j = k <NEWLINE> while i != - 1 : <NEWLINE> <INDENT> left_count = RBT_COUNTS [ RBT_CHILDREN [ i , 0 ] ] <NEWLINE> if left_count == j : <NEWLINE> <INDENT> return RBT_VALUES [ i ] <NEWLINE> <DEDENT> elif left_count > j : <NEWLINE> <INDENT> i = RBT_CHILDREN [ i , 0 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> j -= left_count + 1 <NEWLINE> i = RBT_CHILDREN [ i , 1 ] <NEWLINE> <DEDENT> <DEDENT> return RBT_EOT <NEWLINE> <NL> <DEDENT> n = inp [ 0 ] <NEWLINE> ppp = inp [ 1 : ] <NEWLINE> idx = np . argsort ( ppp ) [ : : - 1 ] <NEWLINE> <NL> RBT_ROOT = rbt_insert ( RBT_ROOT , - 1 ) <NEWLINE> RBT_ROOT = rbt_insert ( RBT_ROOT , - 1 ) <NEWLINE> RBT_ROOT = rbt_insert ( RBT_ROOT , n ) <NEWLINE> RBT_ROOT = rbt_insert ( RBT_ROOT , n ) <NEWLINE> <NL> ans = 0 <NEWLINE> for i in idx : <NEWLINE> <INDENT> p = ppp [ i ] <NEWLINE> r1 , j = rbt_upper_bound ( RBT_ROOT , i ) <NEWLINE> r2 = rbt_get_k_th ( RBT_ROOT , j + 1 ) <NEWLINE> l1 = rbt_get_k_th ( RBT_ROOT , j - 1 ) <NEWLINE> l2 = rbt_get_k_th ( RBT_ROOT , j - 2 ) <NEWLINE> ans += p * ( ( l1 - l2 ) * ( r1 - i ) + ( r2 - r1 ) * ( i - l1 ) ) <NEWLINE> RBT_ROOT = rbt_insert ( RBT_ROOT , i ) <NEWLINE> <NL> <DEDENT> return ans <NEWLINE> <NL> <NL> <DEDENT> def debug_print ( children , values , colors , counts , root ) : <NEWLINE> <INDENT> print ( children . T ) <NEWLINE> print ( values ) <NEWLINE> print ( colors ) <NEWLINE> print ( counts ) <NEWLINE> _debug_print ( children , values , colors , counts , root , 0 ) <NEWLINE> <NL> <NL> <DEDENT> def _debug_print ( children , values , colors , counts , i , depth ) : <NEWLINE> <INDENT> if i != - 1 : <NEWLINE> <INDENT> _debug_print ( children , values , colors , counts , children [ i , 0 ] , depth + 1 ) <NEWLINE> print ( <STRING> * depth , <STRING> [ colors [ i ] ] , values [ i ] , counts [ i ] ) <NEWLINE> _debug_print ( children , values , colors , counts , children [ i , 1 ] , depth + 1 ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if sys . argv [ - 1 ] == <STRING> : <NEWLINE> <INDENT> from numba . pycc import CC <NEWLINE> <NL> cc = CC ( <STRING> ) <NEWLINE> cc . export ( <STRING> , <STRING> ) ( solve ) <NEWLINE> cc . compile ( ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> if os . name == <STRING> : <NEWLINE> <COMMENT> <NL> <INDENT> from my_module import solve <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> from numba import njit <NEWLINE> <NL> solve = njit ( <STRING> , cache = True ) ( solve ) <NEWLINE> print ( <STRING> , file = sys . stderr ) <NEWLINE> pass <NEWLINE> <NL> <DEDENT> inp = np . fromstring ( sys . stdin . read ( ) , dtype = np . int64 , sep = <STRING> ) <NEWLINE> ans = solve ( inp ) <NEWLINE> print ( ans ) <NEWLINE>
q_input = input ( ) <NEWLINE> <NL> a , b = map ( int , q_input . split ( <STRING> ) ) <NEWLINE> <NL> ans = int ( ( 10 - 1 + a - 2 ) / ( a - 1 ) ) <NEWLINE> <NL> print ( ans ) <NEWLINE>
s = input ( ) <NEWLINE> t = input ( ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 3 ) : <NEWLINE> if s [ i ] == t [ i ] : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> count = 0 <NEWLINE> avail = 1 <NEWLINE> <NL> while avail < B : <NEWLINE> <INDENT> avail -= 1 <NEWLINE> count += 1 <NEWLINE> avail = + A <NEWLINE> <NL> <DEDENT> print ( count ) <NEWLINE>
s = input ( ) <NEWLINE> t = input ( ) <NEWLINE> for i in range ( 3 ) <NEWLINE> ans = 0 <NEWLINE> if s [ i ] == t [ i ] : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
f = inout ( ) <NEWLINE> r = input ( ) <NEWLINE> <NL> cnt = 0 <NEWLINE> for i in range ( 3 ) : <NEWLINE> <INDENT> if f [ i ] == r [ i ] : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
s = input ( ) . split ( ) <NEWLINE> t = input ( ) . split ( ) <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( 3 ) : <NEWLINE> <INDENT> if s [ i ] == t [ i ] : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
s = input ( ) <NEWLINE> t = input ( ) <NEWLINE> c = 0 <NEWLINE> for i in ( 2 ) : <NEWLINE> <INDENT> if s [ i ] == t [ i ] : <NEWLINE> <INDENT> c += 1 <NEWLINE> <DEDENT> <DEDENT> print ( c ) <NEWLINE>
perint ( <STRING> ) <NEWLINE>
s = int ( input ( ) ) <NEWLINE> t = int ( input ( ) ) <NEWLINE> count = 0 <NEWLINE> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> if s [ i ] == t [ i ] : <NEWLINE> <INDENT> count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
<COMMENT> <NL> s = input ( ) <NEWLINE> t = input ( ) <NEWLINE> ans = 0 <NEWLINE> if s [ 0 ] = t [ 0 ] : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> if s [ 1 ] = t [ 1 ] : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> if s [ 2 ] = t [ 2 ] : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
a = input ( ) . split ( ) <NEWLINE> b = input ( ) . split ( ) <NEWLINE> count = 0 <NEWLINE> for i in range ( 3 ) : <NEWLINE> <INDENT> if a [ i ] == b [ i ] : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
s , t = input ( ) . split ( ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 3 ) : <NEWLINE> <INDENT> if s [ i ] == t [ i ] : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> A , B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> count = 0 <NEWLINE> total_plug = 1 <NEWLINE> for i in range ( 1 , 100 ) : <NEWLINE> <INDENT> count += 1 <NEWLINE> total_plug += ( A - 1 ) <NEWLINE> if B <= total_plug : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
S = input ( ) <NEWLINE> T = input ( ) <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> for in in range ( 3 ) : <NEWLINE> <INDENT> if S [ i ] == T [ i ] : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
s = input ( ) <NEWLINE> t = input ( ) <NEWLINE> <NL> ans = 0 <NEWLINE> i = 0 <NEWLINE> while i < len ( s ) : <NEWLINE> <NL> <INDENT> if s [ i ] == t [ i ] : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
days = list ( str ( input ( ) ) ) <NEWLINE> days_real = list ( str ( input ( ) ) ) <NEWLINE> for i in range ( 3 ) : <NEWLINE> <INDENT> if days [ i ] == days_real [ i ] : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
s = input ( ) <NEWLINE> t = input ( ) <NEWLINE> ans = 0 <NEWLINE> <NL> for i in range ( s ) : <NEWLINE> <INDENT> ans += s [ i ] == t [ i ] <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
S = str ( input ( ) ) <NEWLINE> T = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 3 ) <NEWLINE> <INDENT> if S [ i ] == T [ i ] : <NEWLINE> <INDENT> ans = ans + a <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
a = input ( ) <NEWLINE> b = input ( ) <NEWLINE> count = 0 <NEWLINE> for i in range ( 3 ) : <NEWLINE> <INDENT> if a [ i ] = b [ i ] : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
import math <NEWLINE> N = int ( input ( ) ) <NEWLINE> print ( N * ( N - 1 ) / 2 ) <NEWLINE>
S = input ( ) <NEWLINE> T = input ( ) <NEWLINE> cnt = 0 <NEWLINE> for i in S : <NEWLINE> <INDENT> if S [ i ] == T [ i ] : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
S = input ( ) <NEWLINE> T = input ( ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if S [ i ] == T [ i ] : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> taps = 1 <NEWLINE> <NL> while True : <NEWLINE> <INDENT> if taps >= B : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> break <NEWLINE> <DEDENT> taps += ( A - 1 ) <NEWLINE> ans += 1 <NEWLINE> <DEDENT> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> taps = 1 <NEWLINE> <NL> while True : <NEWLINE> <INDENT> if taps >= B : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> break <NEWLINE> <DEDENT> taps += ( A - 1 ) <NEWLINE> ans += 1 <NEWLINE> <DEDENT>
A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( math . ceil ( ( B - 1 ) / ( A - 1 ) ) ) <NEWLINE>
A , B = map ( int , split ( ) ) <NEWLINE> num = B / A <NEWLINE> <NL> if B == 0 or B == 1 : <NEWLINE> <INDENT> print ( int ( 0 ) ) <NEWLINE> <DEDENT> elif B % A == 0 : <NEWLINE> <INDENT> print ( int ( num ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( int ( num + 1 ) ) <NEWLINE> <DEDENT>
<INDENT> = input ( ) . split ( ) <NEWLINE> <DEDENT> syou = x [ 0 ] / x [ 1 ] <NEWLINE> amari = x [ 0 ] % x [ 1 ] <NEWLINE> <NL> if ( amari > 0 ) : <NEWLINE> <INDENT> print ( syou + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( syou ) <NEWLINE> <DEDENT>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if b > a : if b % a > 0 : print ( b // a + 1 ) <NEWLINE> elif b <= a : print ( 1 ) <NEWLINE> else : print ( b // a ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> ans , num = 0 , 1 : <NEWLINE> while num < b : <NEWLINE> <INDENT> num -= 1 <NEWLINE> num += a <NEWLINE> ans += 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
a , b = input2 ( ) <NEWLINE> count = 1 <NEWLINE> <NL> for i in range ( 1 , 21 ) : <NEWLINE> <INDENT> count = count - 1 + a <NEWLINE> if count >= b : <NEWLINE> <INDENT> print ( i ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> using namespace std ; <NEWLINE> int main ( void ) { <NEWLINE> <INDENT> int a , b ; <NEWLINE> cin >> a >> b ; <NEWLINE> int x = 0 ; <NEWLINE> while ( x * ( a - 1 ) + 1 < b ) { <NEWLINE> <INDENT> x + + ; <NEWLINE> <DEDENT> } <NEWLINE> cout << x << endl ; <NEWLINE> <DEDENT> } <NEWLINE>
import math <NEWLINE> a , b = list ( map ( int , input ( ) . split ( ) ) <NEWLINE> if a > b : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( math . ceil ( b / a ) ) <NEWLINE> <DEDENT>
g = a - 1 <NEWLINE> d , r = divmod ( b - 1 , g ) <NEWLINE> if r == 0 : <NEWLINE> <INDENT> print ( d ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( d + 1 ) <NEWLINE> <DEDENT>
a , b = map ( input ( ) . split ( <STRING> ) ) <NEWLINE> i = 1 <NEWLINE> while i >= 1 : <NEWLINE> <INDENT> d = ( a - 1 ) * i + 1 <NEWLINE> if d >= b : <NEWLINE> <INDENT> print ( i ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT>
A , B = int ( input ( ) ) <NEWLINE> if ( A % B == 0 ) : <NEWLINE> <INDENT> print ( B / A ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( B // A + 1 ) <NEWLINE> <DEDENT>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> while n * ( a - 1 ) + 1 < b : <NEWLINE> <INDENT> n += 1 <NEWLINE> <NL> <DEDENT> print ( n ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> result = 0 <NEWLINE> while result * ( a - 1 ) + 1 > b : <NEWLINE> <INDENT> result + + <NEWLINE> <DEDENT> print ( str ( result ) ) <NEWLINE>
A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> now_sum = A <NEWLINE> ans = 1 <NEWLINE> while True : <NEWLINE> <INDENT> if now_sum >= B : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT> now_sum += A - 1 <NEWLINE> ans += 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> answer = 1 <NEWLINE> num = 0 <NEWLINE> while ( answer < b ) : <NEWLINE> <INDENT> anwer += a - 1 <NEWLINE> num += 1 <NEWLINE> <NL> <DEDENT> print ( num ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in rnage ( 0 , b , a - 1 ) : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> print ( ans + 1 ) <NEWLINE>
import math <NEWLINE> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> print ( mach . ceil ( ( B - 1 ) / ( A - 1 ) ) ) <NEWLINE>
A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <COMMENT> <NL> a = 0 <NEWLINE> num = 1 <NEWLINE> while num < B : <NEWLINE> <INDENT> num -= 1 <NEWLINE> num += a <NEWLINE> ans += 1 <NEWLINE> <NL> <DEDENT> print ( a ) <NEWLINE>
A , B = input ( ) . split ( ) <NEWLINE> import math <NEWLINE> print ( math . ceil ( ( B - 1 ) / A ) ) <NEWLINE>
a , b = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> if b == 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> return <NEWLINE> <DEDENT> n = ( b - 2 ) / ( a - 1 ) <NEWLINE> print ( n + 1 ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> x = ( ( 1 - b ) // ( a - 1 ) ) <NEWLINE> <COMMENT> <NL> print ( <STRING> . format ( - x ) <NEWLINE>
inputs = input ( ) <NEWLINE> a , b = int ( inputs . split ( <STRING> ) ) <NEWLINE> a * n - ( n - 1 ) >= b <NEWLINE> print ( int ( ( b + 1 ) / ( a - 1 ) ) <NEWLINE>
a , b = map ( int , input ( ) ) <NEWLINE> <NL> b - 1 = x * ( a - 1 ) <NEWLINE> <NL> if ( b - 1 ) % ( a - 1 ) == 0 : <NEWLINE> <INDENT> print ( ( b - 1 ) // ( a - 1 ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ( b - 1 ) // ( a - 1 ) + 1 ) <NEWLINE> <DEDENT>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> n = 1 <NEWLINE> while ( a - 1 ) n + 1 <= b : <NEWLINE> <INDENT> n += 1 <NEWLINE> <NL> <DEDENT> print ( n ) <NEWLINE>
def solve ( a , b ) : <NEWLINE> <INDENT> def needTaps ( a , b , holes = 1 , res = 0 ) : <NEWLINE> <INDENT> if holes >= b : <NEWLINE> <INDENT> return res <NEWLINE> <DEDENT> elif : <NEWLINE> <INDENT> return needTaps ( a , b , holes + a - 1 , res + 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> return needTaps ( a , b ) <NEWLINE> <NL> <DEDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( solve ( a , b ) ) <NEWLINE>
<COMMENT> <NL> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> B = B - A <NEWLINE> for i in range ( 20 ) : <NEWLINE> <INDENT> if B <= 0 : <NEWLINE> <INDENT> print ( i + 1 ) <NEWLINE> break ( ) <NEWLINE> B = B - A + 1 <NEWLINE> <DEDENT> <DEDENT>
n = list ( map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> print ( - ( - n [ 1 ] + 1 ) // ( n [ 0 ] - 1 ) ) <NEWLINE>
A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> if B == 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else if B < A : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( B // ( A - 1 ) ) <NEWLINE> <DEDENT>
m , n = input ( ) . split ( ) <NEWLINE> m , n = int ( m ) , int ( n ) <NEWLINE> <NL> tot = 0 <NEWLINE> a = 1 <NEWLINE> while a < n : <NEWLINE> <INDENT> a -= 1 <NEWLINE> a += m <NEWLINE> tot += 1 <NEWLINE> <NL> <DEDENT> print ( c ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if b == 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> b -= a <NEWLINE> elif b % a == 0 : <NEWLINE> <INDENT> print ( b // a + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( b // a + 2 ) <NEWLINE> <DEDENT>
min_tap = 0 <NEWLINE> if B <= A : <NEWLINE> <INDENT> min_tap = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> min_tap = math . ceil ( ( B - A ) / ( A - 1 ) ) + 1 <NEWLINE> <DEDENT> print ( int ( min_tap ) ) <NEWLINE>
a , b = map ( int . input ( ) . split ( ) ) <NEWLINE> print ( ( b - 0.1 ) // a + 1 ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> H = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> count = [ ] <NEWLINE> for i in range ( len ( H ) - 1 ) : <NEWLINE> <INDENT> count . append ( 0 ) <NEWLINE> if H [ i ] > H [ i + 1 ] : <NEWLINE> <INDENT> count [ i ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> S = str ( count ) . split ( <STRING> ) <NEWLINE> L = map ( len , S ) <NEWLINE> print ( max ( L ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> heights = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> cnt_list = [ ] <NEWLINE> for i in range ( len ( heights ) ) : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> while True : <NEWLINE> <INDENT> j = i + 1 <NEWLINE> if heights [ j ] <= heights [ i ] : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> cnt_list . append ( cnt ) <NEWLINE> <NL> <DEDENT> cnt_list . sort ( reverse = True ) <NEWLINE> ans = cnt_list [ 0 ] <NEWLINE> <NL> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , inpu ( ) . split ( ) ) ) <NEWLINE> bef = 99999999999999 <NEWLINE> count = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> l = A . pop ( ) <NEWLINE> if l > bef : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> count = 0 <NEWLINE> <DEDENT> if max <= count : <NEWLINE> <INDENT> max = count <NEWLINE> <DEDENT> bef = l <NEWLINE> <DEDENT> print ( max ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> N_List = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> maxct = 0 <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> if N_List [ i ] >= N_List [ i + 1 ] : <NEWLINE> <INDENT> ct += 1 <NEWLINE> if ( i == N - 2 ) & ( ct > maxct ) : <NEWLINE> <INDENT> maxct = ct <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if maxct < ct : <NEWLINE> <INDENT> maxct = ct <NEWLINE> ct = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( maxct ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> nums = list ( map ( int , input . split ( <STRING> ) ) ) <NEWLINE> count = 0 <NEWLINE> count2 = count <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> if nums [ i ] >= nums [ i + 1 ] : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> count2 = max ( [ count , count2 ] ) <NEWLINE> count = 0 <NEWLINE> <DEDENT> <DEDENT> print ( max ( [ count , count2 ] ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> H = map ( int , input ( ) . split ( ) ) <NEWLINE> m = 0 <NEWLINE> c = 0 <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> if H [ i ] >= H [ i + 1 ] : <NEWLINE> <INDENT> c += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> m = max ( m , c ) <NEWLINE> c = 0 <NEWLINE> <DEDENT> <DEDENT> print ( m ) <NEWLINE>
def Input ( ) : <NEWLINE> <INDENT> return map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> h = list ( reversed ( Input ( ) ) ) <NEWLINE> count = 0 <NEWLINE> ans = 0 <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> if h [ i ] <= h [ i + 1 ] : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = max ( ans , count ) <NEWLINE> count = 0 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <DEDENT> main ( ) <NEWLINE>
input ( ) <NEWLINE> towers = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = [ ] <NEWLINE> count = 0 <NEWLINE> for x in range ( len ( towers ) - 1 ) : <NEWLINE> <INDENT> if towers [ x ] >= towers [ x + 1 ] : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans . append ( count ) <NEWLINE> count = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans . max ( ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> h = map ( int , input ( ) . split ( ) ) <NEWLINE> cur = [ 0 ] * n <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> if h [ i ] <= h [ i - 1 ] : <NEWLINE> <INDENT> cur [ i ] = cur [ i - 1 ] + 1 <NEWLINE> <DEDENT> <DEDENT> print ( max ( cur ) ) <NEWLINE>
xN = int ( input ( ) ) <NEWLINE> H = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> cur = [ 0 ] * N <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if H [ i ] <= H [ i - 1 ] : <NEWLINE> <INDENT> cur [ i ] = cur [ i - 1 ] + 1 <NEWLINE> <DEDENT> <DEDENT> print ( max ( cur ) ) <NEWLINE>
print ( ( 1 + N ) * ( N / 2 ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> print ( int ( N * ( N - 1 ) // 2 ) <NEWLINE>
from numba import njit <NEWLINE> <NL> @ njit ( cache = True ) <NEWLINE> def f ( n ) : <NEWLINE> <COMMENT> <NL> <INDENT> ans = 0 <NEWLINE> for i , j in zip ( range ( 1 , n ) , range ( 2 , n + 1 ) ) : <NEWLINE> <COMMENT> <NL> <INDENT> ans += i % j <NEWLINE> <DEDENT> return ans <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> r = f ( n ) <NEWLINE> print ( r ) <NEWLINE> <DEDENT>
package main <NEWLINE> <NL> import <STRING> <NEWLINE> <NL> func main ( ) { <NEWLINE> <INDENT> var n int <NEWLINE> fmt . Scan ( & n ) <NEWLINE> <NL> ans : = 0 <NEWLINE> for i : = 1 ; i < n ; i + + { <NEWLINE> <INDENT> ans += i <NEWLINE> <DEDENT> } <NEWLINE> <NL> fmt . Println ( ans ) <NEWLINE> <DEDENT> } <NEWLINE>
<COMMENT> <NL> import sys <NEWLINE> from collections import deque <NEWLINE> from typing import Deque , List <NEWLINE> <NL> readline = sys . stdin . buffer . readline <NEWLINE> readlines = sys . stdin . buffer . readline <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> N = int ( readline ( ) ) <NEWLINE> A : List [ Deque [ int ] ] = [ deque ( ) ] + list ( <NEWLINE> <INDENT> deque ( map ( int , line . split ( ) ) ) for line in readlines ( ) <NEWLINE> <DEDENT> ) <NEWLINE> matched_games_cnt = 0 <NEWLINE> next_games_opponent , last_games_day = [ 0 ] * ( N + 1 ) , [ 0 ] * ( N + 1 ) <NEWLINE> queue = deque ( list ( range ( 1 , N + 1 ) ) ) <NEWLINE> while queue : <NEWLINE> <INDENT> player = queue . popleft ( ) <NEWLINE> if not A [ player ] : <COMMENT> <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> opponent = A [ player ] . popleft ( ) <NEWLINE> <NL> <COMMENT> <NL> if next_games_opponent [ opponent ] != player : <NEWLINE> <INDENT> next_games_opponent [ player ] = opponent <NEWLINE> continue <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> matched_games_cnt += 1 <NEWLINE> last_games_day [ player ] = last_games_day [ opponent ] = ( <NEWLINE> <INDENT> max ( last_games_day [ player ] , last_games_day [ opponent ] ) + 1 <NEWLINE> <DEDENT> ) <NEWLINE> <COMMENT> <NL> next_games_opponent [ player ] = next_games_opponent [ opponent ] = 0 <NEWLINE> queue . append ( player ) , queue . append ( opponent ) <NEWLINE> <NL> <DEDENT> print ( max ( last_games_day ) if matched_games_cnt == N * ( N - 1 ) // 2 else - 1 ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
from collections import deque <NEWLINE> from typing import List , Optional , Tuple <NEWLINE> <NL> <NL> def cycle_detectable_topological_sort ( <NEWLINE> <INDENT> graph : List [ List [ int ] ] , in_degrees : List [ int ] , first_index : int = 0 <NEWLINE> <DEDENT> ) -> Tuple [ Optional [ List [ int ] ] , Optional [ List [ int ] ] ] : <NEWLINE> <INDENT> <STRING> <NEWLINE> V = len ( graph ) + first_index <NEWLINE> order = [ ] <NEWLINE> depths = [ - 1 ] * V <COMMENT> <NEWLINE> for i in range ( first_index , V ) : <NEWLINE> <INDENT> if not in_degrees [ i ] : <NEWLINE> <INDENT> order . append ( i ) <NEWLINE> depths [ i ] = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> queue = deque ( order ) <NEWLINE> while queue : <NEWLINE> <INDENT> u = queue . popleft ( ) <NEWLINE> cur_depth = depths [ u ] <NEWLINE> for v in graph [ u ] : <NEWLINE> <INDENT> in_degrees [ v ] -= 1 <NEWLINE> if not in_degrees [ v ] : <NEWLINE> <INDENT> depths [ v ] = max ( depths [ v ] , cur_depth + 1 ) <NEWLINE> queue . append ( v ) , order . append ( v ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return ( order , depths ) if len ( order ) + first_index == V else ( None , None ) <NEWLINE> <NL> <NL> <DEDENT> def abc139_e ( ) : <NEWLINE> <INDENT> N , * A = map ( int , open ( 0 ) . read ( ) . split ( ) ) <NEWLINE> <NL> ids = [ [ - 1 ] * ( N + 1 ) for _ in range ( N + 1 ) ] <NEWLINE> cur_id = 0 <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , N + 1 ) : <NEWLINE> <INDENT> ids [ i ] [ j ] = ids [ j ] [ i ] = cur_id <NEWLINE> cur_id += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> graph = [ [ ] for _ in range ( N * ( N - 1 ) // 2 ) ] <NEWLINE> in_degrees = [ 0 ] * ( N * ( N - 1 ) // 2 ) <NEWLINE> for i , a in enumerate ( zip ( * [ iter ( A ) ] * ( N - 1 ) ) , 1 ) : <NEWLINE> <INDENT> prev_id = - 1 <NEWLINE> for j in a : <NEWLINE> <INDENT> cur_id = ids [ i ] [ j ] <NEWLINE> if prev_id != - 1 : <NEWLINE> <INDENT> graph [ prev_id ] . append ( cur_id ) <NEWLINE> in_degrees [ cur_id ] += 1 <NEWLINE> <DEDENT> prev_id = cur_id <NEWLINE> <NL> <DEDENT> <DEDENT> _ , depths = cycle_detectable_topological_sort ( graph , in_degrees , 1 ) <NEWLINE> print ( max ( depths ) + 1 if depths is not None else - 1 ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> abc139_e ( ) <NEWLINE> <DEDENT>
m , d = map ( int , input ( ) . split ( ) ) <NEWLINE> cnt = 0 <NEWLINE> for i in range ( d ) : <NEWLINE> <INDENT> temp = str ( i ) <NEWLINE> if int ( temp [ 0 ] ) >= 2 and int ( temp [ 1 ] ) >= 2 and int ( temp [ 1 ] ) * int ( temp [ 1 ] ) = < m : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
import sys <NEWLINE> from functools import lru_cache <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> a = set ( [ int ( input ( ) ) for _ in range ( m ) ] ) <NEWLINE> if 1 in a : <NEWLINE> <INDENT> ans = [ 1 , 0 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = [ 1 , 1 ] <NEWLINE> <NL> <DEDENT> @ lru_cache ( maxsize = None ) <NEWLINE> def cnt ( x ) : <NEWLINE> <INDENT> if x < 2 : <NEWLINE> <INDENT> return ans [ x ] <NEWLINE> <DEDENT> if x in a : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return ( cnt ( x - 1 ) + cnt ( x - 2 ) ) % MOD <NEWLINE> <NL> <DEDENT> <DEDENT> print ( cnt ( n ) ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> total_1 = 0 <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n ) : <NEWLINE> <INDENT> if a [ i ] > a [ j ] : <NEWLINE> <INDENT> total_1 += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> total_2 = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( n ) : <NEWLINE> <INDENT> if a [ i ] > a [ j ] : <NEWLINE> <INDENT> total_2 += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ( total_1 * k + ( total_2 * k * ( k - 1 ) ) // 2 ) % ( 10 ** 9 + 7 ) <NEWLINE>
from collections import Counter <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> A = tuple ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> c = Counter ( A ) . most_common ( ) <NEWLINE> <NL> if c [ 0 ] [ 0 ] == <STRING> and c [ 0 ] [ 1 ] == N : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif len ( c ) == 2 and c [ 0 ] [ 1 ] == 2 * N // 3 and c [ 1 ] [ 0 ] == <STRING> and c [ 1 ] [ 1 ] == N // 3 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif len ( c ) == 3 and int ( c [ 0 ] [ 0 ] ) ^ int ( c [ 1 ] [ 0 ] ) == int ( c [ 2 ] [ 0 ] ) and c [ 0 ] [ 1 ] == c [ 1 ] [ 1 ] and c [ 1 ] [ 1 ] == c [ 2 ] [ 1 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> cnt = [ 0 ] * N <NEWLINE> ex = [ 0 ] * N <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> for j in range ( N ) : <NEWLINE> <INDENT> if A [ i ] > A [ j ] : <NEWLINE> <INDENT> cnt [ i ] += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> for j in range ( i ) : <NEWLINE> <INDENT> if A [ i ] > A [ j ] : <NEWLINE> <INDENT> ex [ i ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> ans += cnt [ i ] * ( ( K + 1 ) * K // 2 ) % MOD <NEWLINE> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> ans -= ex [ i ] * K <NEWLINE> <DEDENT> print ( ans % MOD ) <NEWLINE>
a = input ( ) <NEWLINE> s = input ( ) <NEWLINE> <NL> if a >= 3200 : <NEWLINE> <INDENT> answer = ( s ) <NEWLINE> <DEDENT> elif a < 3200 : <NEWLINE> <INDENT> answer = ( <STRING> ) <NEWLINE> <NL> <DEDENT> print ( answer ) <NEWLINE>
a = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> <NL> if a = > 3200 : <NEWLINE> <INDENT> print ( S ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a = int ( input ( ) ) <NEWLINE> s = int ( input ( ) ) <NEWLINE> if a >= 3200 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> if a < 3200 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a = input ( ) <NEWLINE> s = input ( ) <NEWLINE> if a >= 3200 : <NEWLINE> <INDENT> print ( s ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , s = input ( ) . split ( ) <NEWLINE> print ( s if int ( a ) < 3200 else <STRING> ) <NEWLINE>
a = int ( input ( ) ) <NEWLINE> <NL> S = input ( ) <NEWLINE> <NL> if a >= 3200 : <NEWLINE> <INDENT> print ( s ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
if a >= 3200 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> if a >= 3200 : <NEWLINE> <INDENT> print ( s ) <NEWLINE> <DEDENT> else <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> if a >= 3200 : <NEWLINE> <INDENT> pint ( s ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a = int ( input ( ) ) <NEWLINE> s = int ( input ( ) ) <NEWLINE> if a < 3200 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( s ) <NEWLINE> <DEDENT>
a = int ( input ( ) ) <NEWLINE> s = int ( input ( ) ) <NEWLINE> <NL> if a >= 3200 : <NEWLINE> <INDENT> print ( s ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = [ ] <NEWLINE> <NL> for x in a : <NEWLINE> <INDENT> b . append ( 1 / x ) <NEWLINE> <NL> <DEDENT> c = sum ( b ) <NEWLINE> ans = 1 / c <NEWLINE> print ( ans ) <NEWLINE>
a = int ( input ( ) ) <NEWLINE> <NL> S = input ( ) <NEWLINE> <NL> if a >= 3200 : <NEWLINE> <INDENT> print ( s ) <NEWLINE> <NL> <DEDENT> elif a < 3200 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> <NL> if a >= 3200 : <NEWLINE> <INDENT> print ( s ) <NEWLINE> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
a = input ( ) <NEWLINE> if a >= 3200 : <NEWLINE> <INDENT> print ( s ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
<COMMENT> <NL> a = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> <NL> <COMMENT> <NL> if a >= 3200 : <NEWLINE> <INDENT> print ( s ) <NEWLINE> <DEDENT> elif : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a = int ( input ( ) ) <NEWLINE> s = int ( input ( ) ) <NEWLINE> if a >= 3200 : <NEWLINE> <INDENT> print ( s ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
if 3200 <= a : <NEWLINE> <INDENT> print ( input ( s ) ) <NEWLINE> <DEDENT> if a < 3200 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a = input ( ) <NEWLINE> <NL> if a >= 3200 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> elif a < 3200 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , s = map ( int , input ( ) . split ( ) ) <NEWLINE> a = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> <NL> if a >= 3200 : <NEWLINE> <INDENT> print ( s ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a = input ( ) <NEWLINE> s = input ( ) <NEWLINE> <NL> if a >= 3200 : <NEWLINE> <INDENT> print ( s ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
X = int ( input ( ) ) <NEWLINE> a = input ( ) <NEWLINE> if x >= 3200 : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
_ = input ( ) <NEWLINE> print ( 1 / sum [ 1 / r for r in list ( map ( int , input ( ) . split ( ) ) ) ] ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> sum = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> sum = sum + 1 / a [ i ] <NEWLINE> <DEDENT> print ( 1 / ans ) <NEWLINE> <NL>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> total = 0 <NEWLINE> for i in a : <NEWLINE> <INDENT> total += 1 / a <NEWLINE> <DEDENT> print ( 1 / total ) <NEWLINE>
input ( ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> s = 0 <NEWLINE> s += 1 / i for i in l <NEWLINE> print ( round ( 1 / s , 3 ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ans = ans + 1 / a [ i ] <NEWLINE> <DEDENT> ans = 1 / ans <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A_lis = list ( map ( int , input ( ) . split ( ) ) <NEWLINE> x = 0 <NEWLINE> for i in A_lis : <NEWLINE> <INDENT> x += 1 / i <NEWLINE> <DEDENT> ans = 1 / x <NEWLINE> print ( ans ) <NEWLINE> <NL>
n = int ( input ( ) ) <NEWLINE> res = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> for x in res : <NEWLINE> <INDENT> ans += 1 / res <NEWLINE> <DEDENT> print ( 1 / ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> ans += 1 / A [ i ] <NEWLINE> <NL> <DEDENT> print ( 1 / ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> for a in A : <NEWLINE> <INDENT> ans += 1 / a <NEWLINE> <DEDENT> print ( 1 / ans <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> s = 0 <NEWLINE> for i in a : <NEWLINE> <INDENT> s += 1 / a <NEWLINE> <DEDENT> print ( 1 / s ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S = 0 <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> S += 1 / i <NEWLINE> <DEDENT> print ( 1 / S ) <NEWLINE>
a = int ( input ( ) ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c = 0 <NEWLINE> for i in range ( 0 , a - 1 ) : <NEWLINE> <INDENT> c == c + 1 / b [ i ] <NEWLINE> <DEDENT> print ( 1 / c ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> v = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> v . sort ( reverse = True ) <NEWLINE> <NL> while len ( v ) > 1 : <NEWLINE> <INDENT> v . append ( ( v . pop ( - 1 ) + v . pop ( - 2 ) ) / 2 ) <NEWLINE> v . sort ( reverse = True ) <NEWLINE> <NL> <DEDENT> print ( v ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> v = sorted ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> value = v [ 0 ] <NEWLINE> for in range ( 1 , N ) : <NEWLINE> <INDENT> value = ( value + v [ i ] ) / 2 <NEWLINE> <DEDENT> print ( value ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A = sorted ( A ) <NEWLINE> if N == 2 : <NEWLINE> <INDENT> print ( sum ( A ) / 2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> temp = ( A [ 0 ] + A [ 1 ] ) / 2 <NEWLINE> for i in range ( 2 , N ) : <NEWLINE> <INDENT> temp = 1 / 2 * ( A [ i ] + temp ) <NEWLINE> <DEDENT> <DEDENT> print ( temp ) <NEWLINE>
def Input ( ) : <NEWLINE> <INDENT> return mapt ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> a = sorted ( Input ( ) ) <NEWLINE> while len ( a ) > 1 : <NEWLINE> <INDENT> x , y = a [ 0 ] , a [ 1 ] <NEWLINE> a [ 0 : 2 ] = [ ( x + y ) / 2 ] <NEWLINE> <NL> <DEDENT> return a [ 0 ] <NEWLINE> <NL> <NL> <DEDENT> print ( main ( ) ) <NEWLINE>
x = int ( input ( ) ) <NEWLINE> a = [ list ( map ( int , input ( ) . split ( ) ) ) ] <NEWLINE> b = sorted ( a ) <NEWLINE> y = 0 <NEWLINE> for i in range ( x ) : <NEWLINE> <INDENT> y += b [ i - 0 ] * ( 2 ** i ) <NEWLINE> <DEDENT> print ( y // ( 2 ** ( x + 1 ) ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> v = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> v . sort ( key = int ) <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> z = ( v [ i ] + v [ i + 1 ] ) / 2 <NEWLINE> v [ i ] = z <NEWLINE> v [ i + 1 ] = z <NEWLINE> <DEDENT> print ( v [ n ] ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> v = sorted ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = v [ 0 ] <NEWLINE> <NL> for i in range ( 1 , N ) : <NEWLINE> <INDENT> ans = ( ans + v [ i ] ) / 2 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
from sys import stdin <NEWLINE> nii = lambda : map ( int , stdin . readline ( ) . split ( ) ) <NEWLINE> lnii = lambda : list ( map ( int , stdin . readline ( ) . split ( ) ) ) <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> v = lnii ( ) <NEWLINE> v . sort ( ) <NEWLINE> <NL> ans = v [ 0 ] <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> ans = ( ans + v [ i ] ) / 2 <NEWLINE> <NL> <DEDENT> print ( ans <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> <NL> <COMMENT> <NL> global tree , point <NEWLINE> <NL> <COMMENT> <NL> def dfs ( v , f ) : <NEWLINE> <INDENT> for next_v in tree [ v ] : <NEWLINE> <INDENT> if next_v == f : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <DEDENT> point [ next_v ] += point [ v ] <NEWLINE> dfs ( next_v , v ) <NEWLINE> <NL> <DEDENT> <DEDENT> n , q = map ( int , input ( ) . split ( ) ) <NEWLINE> tree = [ [ ] for _ in range ( n ) ] <NEWLINE> point = [ 0 ] * n <NEWLINE> for _ in range ( n - 1 ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> tree [ b - 1 ] . append ( a - 1 ) <NEWLINE> tree [ a - 1 ] . append ( b - 1 ) <NEWLINE> <NL> <DEDENT> for _ in range ( Q ) : <NEWLINE> <INDENT> p , x = map ( int , input ( ) . split ( ) ) <NEWLINE> p = x - 1 <NEWLINE> point [ p ] += x <NEWLINE> <NL> <DEDENT> dfs ( 0 , 0 ) <NEWLINE> print ( * point ) <NEWLINE>
n , q = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> road = [ [ ] for _ in range ( n ) ] <NEWLINE> cnt = [ 0 for _ in range ( n ) ] <NEWLINE> <NL> for i in range ( n - 1 ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> road [ a - 1 ] . append ( b - 1 ) <NEWLINE> road [ b - 1 ] . append ( a - 1 ) <NEWLINE> <NL> <DEDENT> for i in range ( q ) : <NEWLINE> <INDENT> idx , v = map ( int , input ( ) . split ( ) ) <NEWLINE> cnt [ idx - 1 ] += v <NEWLINE> <NL> <DEDENT> dist = [ - 1 ] * n <NEWLINE> que = deque ( ) <NEWLINE> dist [ 0 ] = 0 <NEWLINE> que . append ( 0 ) <NEWLINE> <NL> while ( len ( que ) != 0 ) : <NEWLINE> <COMMENT> <NL> <INDENT> v = que . pop ( ) <NEWLINE> for r in road [ v ] : <NEWLINE> <INDENT> if dist [ r ] != - 1 : <NEWLINE> <INDENT> continue <NEWLINE> <COMMENT> <NL> <DEDENT> dist [ r ] = dist [ v ] + 1 <NEWLINE> cnt [ r ] += cnt [ v ] <NEWLINE> que . append ( r ) <NEWLINE> <DEDENT> <DEDENT> print ( * cnt ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 400000 ) <NEWLINE> n , q = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = [ 0 ] * ( n + 1 ) <COMMENT> <NEWLINE> score = [ 0 ] * ( n + 1 ) <COMMENT> <NEWLINE> g = [ [ ] for _ in range ( n + 1 ) ] <COMMENT> <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> g [ a ] . append ( b ) <NEWLINE> g [ b ] . append ( a ) <NEWLINE> <DEDENT> for j in range ( q ) : <NEWLINE> <INDENT> p , x = map ( int , input ( ) . split ( ) ) <NEWLINE> score [ p ] += x <NEWLINE> <NL> <DEDENT> visited = [ 0 ] * ( N + 1 ) <NEWLINE> def dfs ( v ) : <NEWLINE> <INDENT> visited [ v ] += 1 <NEWLINE> global ans <NEWLINE> ans [ v ] += score [ v ] <NEWLINE> for i in range ( len ( g [ v ] ) ) : <NEWLINE> <INDENT> if visited [ g [ v ] [ i ] ] == 0 : <NEWLINE> <INDENT> ans [ g [ v ] [ i ] ] += ans [ v ] <NEWLINE> dfs ( g [ v ] [ i ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> dfs ( 1 ) <NEWLINE> print ( <STRING> . join ( str , map ( ans [ 1 : ] ) ) ) <NEWLINE>
from collections import deque <NEWLINE> N , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> G = [ [ ] * N ] <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> G [ a - 1 ] . append ( b - 1 ) <NEWLINE> G [ b - 1 ] . append ( a - 1 ) <NEWLINE> <NL> <DEDENT> count = [ 0 ] * N <NEWLINE> for j in range ( Q ) : <NEWLINE> <INDENT> p , x = map ( int , input ( ) . split ( ) ) <NEWLINE> count [ p - 1 ] += x <NEWLINE> <NL> <DEDENT> visited = [ False ] * N <NEWLINE> que = deque ( [ 0 ] ) <NEWLINE> <NL> while que : <NEWLINE> <INDENT> now = que . pop ( ) <NEWLINE> visited [ now ] = True <NEWLINE> for nxt in G [ now ] : <NEWLINE> <INDENT> if visited [ nxt ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> count [ nxt ] += count [ now ] <NEWLINE> que . appendleft ( nxt ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( * count ) <NEWLINE>
import numpy as np <NEWLINE> import sys <NEWLINE> i4 = np . int32 <NEWLINE> <NL> if sys . argv [ - 1 ] == <STRING> : <NEWLINE> <INDENT> adjacency_list = <STRING> <NEWLINE> import os <NEWLINE> os . makedirs ( <STRING> , exist_ok = True ) <NEWLINE> with open ( <STRING> , <STRING> ) as f : <NEWLINE> <INDENT> f . write ( adjacency_list ) <NEWLINE> <NL> <DEDENT> abc138_d_numba = <STRING> <NEWLINE> with open ( <STRING> , <STRING> ) as f : <NEWLINE> <INDENT> f . write ( abc138_d_numba ) <NEWLINE> <DEDENT> import subprocess <NEWLINE> cmd = <STRING> <NEWLINE> subprocess . run ( cmd . split ( ) ) <NEWLINE> exit ( 0 ) <NEWLINE> <NL> <NL> <DEDENT> from abc138_d_numba import solve <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> f = open ( 0 ) <NEWLINE> N , Q = [ int ( x ) for x in f . readline ( ) . split ( ) ] <NEWLINE> ap = np . fromstring ( f . read ( ) , i4 , sep = <STRING> ) . reshape ( ( - 1 , 2 ) ) <NEWLINE> a = ap [ : N - 1 ] - 1 <NEWLINE> a = np . concatenate ( ( a , a [ : , : : - 1 ] ) ) <NEWLINE> p = ap [ N - 1 : ] <NEWLINE> val = solve ( a , p , N ) <NEWLINE> print ( * val . tolist ( ) ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n , q = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> road = [ [ ] for _ in range ( n ) ] <NEWLINE> cnt = [ 0 for _ in range ( n ) ] <NEWLINE> <NL> for i in range ( n - 1 ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> road [ a - 1 ] . append ( b - 1 ) <NEWLINE> road [ b - 1 ] . append ( a - 1 ) <NEWLINE> <NL> <DEDENT> for i in range ( q ) : <NEWLINE> <INDENT> idx , v = map ( int , input ( ) . split ( ) ) <NEWLINE> cnt [ idx - 1 ] = v <NEWLINE> <NL> <DEDENT> dist = [ - 1 ] * n <NEWLINE> que = deque ( ) <NEWLINE> dist [ 0 ] = 0 <NEWLINE> que . append ( 0 ) <NEWLINE> <NL> while ( len ( que ) != 0 ) : <NEWLINE> <COMMENT> <NL> <INDENT> v = que . pop ( ) <NEWLINE> for r in road [ v ] : <NEWLINE> <INDENT> if dist [ r ] != - 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> dist [ r ] = dist [ v ] + 1 <NEWLINE> cnt [ r ] += cnt [ v ] <NEWLINE> que . append ( r ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( * cnt ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> n , q = map ( int , input ( ) . split ( ) ) <NEWLINE> ki = [ [ ] for i in range ( n ) ] <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> ki [ a - 1 ] . append ( b - 1 ) <NEWLINE> ki [ b - 1 ] . append ( a - 1 ) <NEWLINE> <DEDENT> score = [ 0 ] * n <NEWLINE> <NL> for i in range ( q ) : <NEWLINE> <INDENT> p , x = map ( int , input ( ) . split ( ) ) <NEWLINE> score [ p - 1 ] += x <NEWLINE> <COMMENT> <NL> <DEDENT> ans = [ 0 ] * n <NEWLINE> <NL> def dfs ( v , p , value ) : <COMMENT> <NEWLINE> <INDENT> value += score ( v ) <NEWLINE> <COMMENT> <NL> ans [ v ] = value <NEWLINE> for i in ki [ v ] : <NEWLINE> <INDENT> if i == p : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> dfs ( i , v , value ) <NEWLINE> <DEDENT> <DEDENT> dfs ( 0 , - 1 , 0 ) <NEWLINE> <NL> print ( * ans ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> n , q = map ( int , input ( ) . split ( ) ) <NEWLINE> ab = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n - 1 ) ] <NEWLINE> tree = [ list ( ) for _ in range ( n ) ] <NEWLINE> score = [ 0 ] * n <NEWLINE> for a , b in ab : <NEWLINE> <INDENT> a -= 1 <NEWLINE> b -= 1 <NEWLINE> tree [ a ] . append ( b ) <NEWLINE> <DEDENT> px = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( q ) ] <NEWLINE> for p , x in px : <NEWLINE> <INDENT> p -= 1 <NEWLINE> add ( p , x , tree , score ) <NEWLINE> <DEDENT> print ( s ) <NEWLINE> <NL> <DEDENT> def add ( p , x , tree , score ) : <NEWLINE> <INDENT> score [ p ] += x <NEWLINE> s = tree [ p ] [ : ] <NEWLINE> while len ( s ) > 0 : <NEWLINE> <INDENT> t = s . pop ( ) <NEWLINE> score [ t ] += x <NEWLINE> for i in tree [ t ] : <NEWLINE> <INDENT> s . append ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> <NL> n , q = map ( int , input ( ) . split ( ) ) <NEWLINE> ab = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n - 1 ) ] <NEWLINE> px = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( q ) ] <NEWLINE> <NL> graph = [ [ ] for _ in range ( n + 3 ) ] <NEWLINE> for a , b in ab : <NEWLINE> <INDENT> graph [ a ] . append ( b ) <NEWLINE> graph [ b ] . append ( a ) <NEWLINE> <NL> <DEDENT> value = [ 0 ] * ( n + 1 ) <NEWLINE> for p , x in px : <NEWLINE> <INDENT> value [ p ] += x <NEWLINE> <NL> <DEDENT> def dfs ( v , parent , add ) : <NEWLINE> <INDENT> value [ v ] += add <NEWLINE> for x in graph [ v ] : <NEWLINE> <INDENT> if v == parent : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> dfs ( x , v , value [ v ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> dfs ( 1 , 0 , 0 ) <NEWLINE> print ( * value [ 1 : ] , end = <STRING> ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 400000 ) <NEWLINE> n , q = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = [ 0 ] * ( n + 1 ) <COMMENT> <NEWLINE> score = [ 0 ] * ( n + 1 ) <COMMENT> <NEWLINE> g = [ [ ] for _ in range ( n + 1 ) ] <COMMENT> <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> g [ a ] . append ( b ) <NEWLINE> g [ b ] . append ( a ) <NEWLINE> <DEDENT> for j in range ( q ) : <NEWLINE> <INDENT> p , x = map ( int , input ( ) . split ( ) ) <NEWLINE> score [ p ] += x <NEWLINE> <NL> <DEDENT> visited = [ 0 ] * ( n + 1 ) <NEWLINE> def dfs ( v ) : <NEWLINE> <INDENT> visited [ v ] += 1 <NEWLINE> global ans <NEWLINE> ans [ v ] += score [ v ] <NEWLINE> for i in range ( len ( g [ v ] ) ) : <NEWLINE> <INDENT> ans [ g [ v ] [ i ] ] += ans [ v ] <NEWLINE> dfs ( g [ v ] [ i ] ) <NEWLINE> <DEDENT> <DEDENT> dfs ( 1 ) <NEWLINE> print ( <STRING> . join ( map ( str , ans [ 1 : ] ) ) ) <NEWLINE>
<COMMENT> <NL> import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> N , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <COMMENT> <NL> G = [ [ ] for _ in range ( N ) ] <NEWLINE> root = set ( ) <NEWLINE> for _ in range ( N - 1 ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> a -= 1 ; b -= 1 <NEWLINE> if not ( b in root ) : <NEWLINE> <INDENT> G [ a ] . append ( b ) <NEWLINE> <COMMENT> <NL> <DEDENT> else : <NEWLINE> <INDENT> G [ b ] . append ( a ) <NEWLINE> <DEDENT> root . add ( b ) <NEWLINE> <NL> <DEDENT> lst = [ ] <NEWLINE> for _ in range ( Q ) : <NEWLINE> <INDENT> P , X = map ( int , input ( ) . split ( ) ) <NEWLINE> P -= 1 <NEWLINE> lst . append ( ( P , X ) ) <NEWLINE> <NL> <DEDENT> cnt = [ 0 ] * N <NEWLINE> for p , x in lst : <NEWLINE> <INDENT> cnt [ p ] += x <NEWLINE> <NL> <DEDENT> def dfs ( v ) : <NEWLINE> <COMMENT> <NL> <INDENT> for next_v in G [ v ] : <NEWLINE> <COMMENT> <NL> <INDENT> if seen [ next_v ] == True : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> cnt [ next_v ] += cnt [ v ] <NEWLINE> dfs ( next_v ) <NEWLINE> <DEDENT> <DEDENT> dfs ( 0 ) <NEWLINE> print ( * cnt ) <NEWLINE>
from sys import setrecursionlimit <NEWLINE> <NL> setrecursionlimit ( 10 ** 6 ) <NEWLINE> <NL> N , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> graph = [ [ ] for _ in range ( N ) ] <NEWLINE> queries = { p : 0 for p in range ( N ) } <NEWLINE> <NL> for _ in range ( N - 1 ) : <NEWLINE> <INDENT> a , b = map ( lambda x : int ( x ) - 1 , input ( ) . split ( ) ) <NEWLINE> <NL> graph [ a ] . append ( b ) <NEWLINE> graph [ b ] . append ( a ) <NEWLINE> <NL> <DEDENT> for _ in range ( Q ) : <NEWLINE> <INDENT> p , x = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> queries [ p - 1 ] += x <NEWLINE> <NL> <DEDENT> answer = [ 0 ] * N <NEWLINE> <NL> def dfs ( p , p_before , acc ) : <NEWLINE> <INDENT> acc += queries [ p ] <NEWLINE> <NL> answer [ p ] = acc <NEWLINE> <NL> for child in graph [ p ] : <NEWLINE> <INDENT> if child == p_before : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <DEDENT> dfs ( child , acc ) <NEWLINE> <NL> <DEDENT> <DEDENT> dfs ( 0 , - 1 , 0 ) <NEWLINE> <NL> print ( * answer ) <NEWLINE>
n , q = map ( int , input ( ) . split ( ) ) <NEWLINE> graph = [ [ ] for i in range ( n ) ] <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> a -= 1 <NEWLINE> b -= 1 <NEWLINE> graph [ a ] . append ( b ) <NEWLINE> graph [ b ] . append ( a ) <NEWLINE> <NL> <DEDENT> weight = [ 0 for i in range ( n ) ] <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> p , x = map ( int , input ( ) . split ( ) ) <NEWLINE> weight [ p - 1 ] = x <NEWLINE> <NL> <DEDENT> st = [ 0 ] <NEWLINE> visit = [ false for i in range ( n ) ] <NEWLINE> while not len ( st ) == 0 : <NEWLINE> <INDENT> now = st . pop ( ) <NEWLINE> visit [ now ] = true <NEWLINE> for e in graph [ now ] : <NEWLINE> <INDENT> if visit [ e ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> weight [ e ] += weight [ e ] <NEWLINE> st . push ( e ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> . join ( map ( str , weight ) ) ) <NEWLINE>
N , * A = map ( int , open ( 0 ) . read ( ) . split ( ) ) <NEWLINE> <NL> A = [ 0 ] + A <NEWLINE> B = [ 0 ] * ( N + 1 ) <NEWLINE> sum_B = 0 <NEWLINE> for i in range ( N , 0 , - 1 ) : <NEWLINE> <INDENT> if sum ( B [ j ] for j in range ( i , N + 1 , i ) ) % 2 != A [ i ] : <NEWLINE> <INDENT> B [ i ] = 1 <NEWLINE> sum_B += 1 <NEWLINE> <DEDENT> <DEDENT> print ( sum_B ) <NEWLINE> print ( * [ i for i , b in enumerate ( B ) if b ] ) <NEWLINE>
s = input ( ) <NEWLINE> <NL> i = 0 <NEWLINE> lst = [ ] <NEWLINE> for j in range ( 1 , len ( s ) + 1 ) : <NEWLINE> <INDENT> if lst [ - 1 ] != s [ i : j ] : <NEWLINE> <INDENT> lst . append ( s [ i : j ] ) <NEWLINE> i = j <NEWLINE> <NL> <DEDENT> <DEDENT> print ( len ( lst ) ) <NEWLINE>
s = input ( ) <NEWLINE> t = s [ 0 ] <NEWLINE> p = 1 <NEWLINE> i = 1 <NEWLINE> while i < len ( s ) : <NEWLINE> <INDENT> if s [ i ] == t : <NEWLINE> <INDENT> i += 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> i += 1 <NEWLINE> <DEDENT> t = s [ i - 1 ] <NEWLINE> p += 1 <NEWLINE> <NL> <DEDENT> print ( p ) <NEWLINE>
A , B = maps ( int , input ( ) . split ( ) ) <NEWLINE> print ( max ( max ( A + B , A - B ) , A * B ) ) <NEWLINE>
def Input ( ) : <NEWLINE> <INDENT> return mapt ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> a , b = Input ( ) <NEWLINE> return max ( a * b , a - b , a + b ) <NEWLINE> <NL> <NL> <DEDENT> print ( main ( ) ) <NEWLINE>
map ( int , input ( ) . split ( ) ) <NEWLINE> print ( max ( A + B , A - B , A * B ) ) <NEWLINE>
A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> p = A + B <NEWLINE> m = A - B <NEWLINE> M = A * B <NEWLINE> <NL> L = [ ] <NEWLINE> <NL> L . append ( p ) <NEWLINE> L . append ( m ) <NEWLINE> L . append ( M ) <NEWLINE> <NL> print ( max ( M ) ) <NEWLINE>
a , b = int ( input ( ) . split ( ) ) <NEWLINE> print ( max ( a + b , a - b , a * b ) ) <NEWLINE>
a , b = map ( int , input ( ) ) <NEWLINE> print ( max ( a + b , a - b , a * b ) ) <NEWLINE>
s = input ( ) <NEWLINE> l = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> a , b = l [ 0 ] , l [ 1 ] <NEWLINE> print ( max ( a + b , max ( a - b , a * b ) ) ) <NEWLINE>
<NL> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> x = a + b <NEWLINE> y = a - b <NEWLINE> z = a * b <NEWLINE> O = [ x , y , z ] <NEWLINE> O = sorted ( O , reverse = 1 ) <NEWLINE> print ( O [ 0 ] <NEWLINE>
A , B = map ( int , input ( ) , split ( ) ) <NEWLINE> <NL> x = A + B <NEWLINE> y = A - B <NEWLINE> z = A * B <NEWLINE> print ( max ( x , y , z ) ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> s = a + b <NEWLINE> t = a - b <NEWLINE> u = a * b <NEWLINE> <NL> if s >= t : <NEWLINE> <INDENT> if t >= u : <NEWLINE> <INDENT> print ( s ) <NEWLINE> <DEDENT> elif s <= u : <NEWLINE> <INDENT> print ( u ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if s >= u : <NEWLINE> <INDENT> print ( t ) <NEWLINE> <DEDENT> elif : <NEWLINE> <INDENT> t <= u : <NEWLINE> print ( u ) <NEWLINE> <DEDENT> <DEDENT>
a , b = map ( int , input ( ) ) <NEWLINE> list_ab = [ ] <NEWLINE> list_ab . append ( a + b ) <NEWLINE> list_ab . append ( a - b ) <NEWLINE> list_ab . append ( a * b ) <NEWLINE> <NL> print ( max ( list_ab ) ) <NEWLINE>
A , B = map ( int ( input ( ) . split ( ) ) ) <NEWLINE> l = [ A + B , A - B , A * B ] <NEWLINE> print ( max ( l ) ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( max ( max ( a + b , a - b ) , a * b ) <NEWLINE>
N , X = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = [ ] <NEWLINE> for _ in range ( X - N + 1 , X + N ) : <NEWLINE> <INDENT> ans . append ( _ ) <NEWLINE> <DEDENT> print ( <STRING> . join ( ans ) ) <NEWLINE>
L = [ ] <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> y = x + i <NEWLINE> z = x - i <NEWLINE> if y > 1000000 : <NEWLINE> <INDENT> y = x <NEWLINE> <DEDENT> L . append ( y ) <NEWLINE> if z < - 1000000 : <NEWLINE> <INDENT> z = x <NEWLINE> <DEDENT> L . append ( z ) <NEWLINE> <DEDENT> I = set ( L ) <NEWLINE> for s in I : <NEWLINE> <INDENT> print ( s , end = <STRING> ) <NEWLINE> <DEDENT>
import sys <NEWLINE> import math <NEWLINE> import itertools <NEWLINE> import collections <NEWLINE> import heapq <NEWLINE> import re <NEWLINE> import numpy as np <NEWLINE> <NL> rr = lambda : sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> rs = lambda : sys . stdin . readline ( ) . split ( ) <NEWLINE> ri = lambda : int ( sys . stdin . readline ( ) ) <NEWLINE> rm = lambda : map ( int , sys . stdin . readline ( ) . split ( ) ) <NEWLINE> rl = lambda : list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) <NEWLINE> inf = float ( <STRING> ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> a , b = rm ( ) <NEWLINE> print ( * list ( range ( b - a + 1 : b + a ) ) ) <NEWLINE> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL>
k , x = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( * [ x for x in range ( X - K + 1 , X + K ) ] ) <NEWLINE>
<NL> <NL> <NL> def fun ( n , num , count ) : <NEWLINE> <NL> <INDENT> if count == ( num * 2 ) - 1 : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> print ( n , end = <STRING> ) <NEWLINE> count += 1 <NEWLINE> fun ( n + 1 , num , count ) <NEWLINE> <DEDENT> xnum = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> x = xnum [ 0 ] <NEWLINE> num = snum [ 1 ] <NEWLINE> <NL> m = x - ( num - 1 ) <NEWLINE> <NL> fun ( m , num , 0 ) <NEWLINE>
K , X = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> for i in range ( max ( - 1000000 , X - K + 1 ) , min ( X + K , 1000000 ) : <NEWLINE> <INDENT> print ( i , end = <STRING> ) <NEWLINE> <DEDENT>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> x = [ ] <NEWLINE> for i in range ( b - a + 1 , b + a ) : <NEWLINE> <INDENT> x . append ( i ) <NEWLINE> <DEDENT> print ( <STRING> . join ( x ) , sep = <STRING> ) <NEWLINE>
k , y = map ( int , input ( ) . split ( ) ) <NEWLINE> for i in range ( x - y + 1 , x + y ) : <NEWLINE> <INDENT> print ( i , end = <STRING> ) <NEWLINE> <DEDENT>
k , n = map ( int , input ( ) . split ( ) ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> print ( - n + 1 + i ) <NEWLINE> <DEDENT> print ( 0 ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> printf ( i ) <NEWLINE> <DEDENT>
k , x = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ x ] <NEWLINE> for i in range ( 1 , k ) : <NEWLINE> <INDENT> a . append ( x + i ) <NEWLINE> a . append ( x - i ) <NEWLINE> <NL> <DEDENT> print ( <STRING> . join ( sorted ( a ) ) ) <NEWLINE> <NL>
k , x = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> min_ans = x - k + 1 <NEWLINE> max_ans = x + K - 1 <NEWLINE> <NL> for x in range ( min_ans , max_ans + 1 ) : <NEWLINE> <INDENT> print ( x , end = <STRING> ) <NEWLINE> <DEDENT>
N , X = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> for i in range ( X - K + 1 , X + K ) : <NEWLINE> <INDENT> print ( i , end = <STRING> ) <NEWLINE> <DEDENT>
K , X = list ( map ( lambda n : int ( n ) , input ( ) . split ( <STRING> ) ) ) <NEWLINE> print ( <STRING> . join ( list ( range ( K - X + 1 , K + X - 1 ) ) ) ) <NEWLINE>
K , X = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( * list ( range [ X - K + 1 : X + K ] ) ) <NEWLINE>
import collections <NEWLINE> N = int ( input ( ) ) <NEWLINE> s = [ <STRING> . join ( sorted ( input ( ) ) ) for _ in range ( N ) ] <NEWLINE> print ( A ) <NEWLINE> B = collections . Counter ( s ) <NEWLINE> print ( sum ( i * ( i - 1 ) // 2 for i in B . values ( ) ) ) <NEWLINE>
from collections import Counter <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> cnt = Counter ( ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> s = sorted ( input ( ) ) <NEWLINE> <NL> if cnt [ s ] == 0 : <NEWLINE> <INDENT> cnt [ s ] = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += cnt [ s ] <NEWLINE> cnt [ s ] += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
S = [ ] <NEWLINE> cho = [ 0 ] <NEWLINE> p = 0 <NEWLINE> n = int ( input ( ) ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> s = sorted ( input ( ) ) <NEWLINE> if s in S : <NEWLINE> <INDENT> cho [ p ] += 1 <NEWLINE> p += 1 <NEWLINE> <DEDENT> S . append ( s ) <NEWLINE> <DEDENT> import collections <NEWLINE> from scipy . special import comb <NEWLINE> a = 0 <NEWLINE> Sd = list ( set ( S ) ) <NEWLINE> c = collections . Counter ( S ) <NEWLINE> for p in range ( len ( Sd ) ) : <NEWLINE> <INDENT> if c [ Sd [ p ] ] >= 2 : <NEWLINE> <INDENT> a += comb ( c [ Sd [ p ] ] , 2 , exact = True ) <NEWLINE> <DEDENT> <DEDENT> print ( a ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = { } <NEWLINE> ans = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> s = sorted ( s ) <NEWLINE> if A . get ( s , <STRING> ) == <STRING> : <NEWLINE> <INDENT> A [ s ] = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += A [ s ] <NEWLINE> A [ s ] += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> print ( len ( set ( [ sorted ( i ) for i in [ input ( ) for i in range ( n ) ] ] ) ) ) <NEWLINE>
import collections <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> S = [ ( sorted ( input ( ) ) ) for _ in range ( N ) ] <NEWLINE> c = collections . Counter ( S ) <NEWLINE> ans = 0 <NEWLINE> print ( S ) <NEWLINE> <NL> for i in set ( S ) : <NEWLINE> <INDENT> n = c [ i ] <NEWLINE> ans += n * ( n - 1 ) // 2 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
counter = { } <NEWLINE> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ss = sorted ( s [ i ] ) <NEWLINE> ss = ( <STRING> ) . join ( ss ) <NEWLINE> if ss not in counter : <NEWLINE> <INDENT> counter [ ss ] = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> counter [ ss ] += 1 <NEWLINE> ans += counter [ ss ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> def combinations_count ( n , r ) : <NEWLINE> <INDENT> return math . factorial ( n ) // ( math . factorial ( n - r ) * math . factorial ( r ) ) <NEWLINE> <NL> <DEDENT> N = int ( input ( ) ) <NEWLINE> dic_s = { } <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> s = <STRING> . join ( sorted ( input ( ) ) ) <NEWLINE> if s in dic_s : <NEWLINE> <INDENT> dic_s [ s ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dic_s [ s ] = 1 <NEWLINE> <DEDENT> <DEDENT> counter = 0 <NEWLINE> for key , value in dic_s . items ( ) : <NEWLINE> <INDENT> counter += combinations_count ( value , 2 ) <NEWLINE> <DEDENT> print ( counter ) <NEWLINE>
import math <NEWLINE> <NL> def comb ( n , r ) : <NEWLINE> <INDENT> return math . factorial ( n ) // ( math . factorial ( n - r ) * math . factorial ( r ) ) <NEWLINE> <NL> <DEDENT> N = int ( input ( ) ) <NEWLINE> a = [ input ( ) for _ in range ( N ) ] <NEWLINE> <NL> d = dict ( ) <NEWLINE> for x in a : <NEWLINE> <INDENT> s = <STRING> . join ( sorted ( x ) ) <NEWLINE> if s not in d . keys ( ) : <NEWLINE> <INDENT> d [ s ] = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d [ s ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( sum ( [ comb ( i , 2 ) for i in d . values ( ) ] ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> s = [ input ( ) for _ in range ( N ) ] <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> s [ i ] = list ( set ( s [ i ] ) ) <NEWLINE> <NL> <DEDENT> print ( len ( set ( s ) ) ) <NEWLINE>
def resolve ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> words = [ ] <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> words . append ( str ( sorted ( list ( input ( ) ) ) ) ) <NEWLINE> <DEDENT> a = collections . Counter ( words ) <NEWLINE> ans = 0 <NEWLINE> for i in a . values ( ) : <NEWLINE> <INDENT> ans += i * ( i - 1 ) // 2 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <DEDENT> resolve ( ) <NEWLINE>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> sn = [ input ( ) . strip ( <STRING> ) for _ in range ( n ) ] <NEWLINE> <NL> mod = 10 ** 7 + 7 <NEWLINE> hs = [ [ 0 , <STRING> ] for _ in range ( mod ) ] <NEWLINE> <NL> def hypo ( s , Mod ) : <NEWLINE> <INDENT> h_num = 1 <NEWLINE> for i in s : <NEWLINE> <INDENT> h_num = h_num * ord ( i ) % Mod <NEWLINE> <DEDENT> return h_num <NEWLINE> <NL> <DEDENT> for s in sn : <NEWLINE> <INDENT> s = <STRING> . join ( sorted ( s ) ) <NEWLINE> h = hypo ( s , mod ) <NEWLINE> while True : <NEWLINE> <INDENT> if h >= mod : <NEWLINE> <INDENT> h = 0 <NEWLINE> <DEDENT> if hs [ h ] [ 0 ] == 0 : <NEWLINE> <INDENT> hs [ h ] [ 0 ] += 1 <NEWLINE> hs [ h ] [ 1 ] += s <NEWLINE> break <NEWLINE> <DEDENT> if hs [ h ] [ 1 ] == s : <NEWLINE> <INDENT> hs [ h ] [ 0 ] += 1 <NEWLINE> break <NEWLINE> <DEDENT> h += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for j , t in hs : <NEWLINE> <INDENT> if j >= 2 : <NEWLINE> <INDENT> ans += j * ( j - 1 ) / 2 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( int ( ans ) ) <NEWLINE> <NL>
import collections <NEWLINE> def main4 ( ) : <NEWLINE> <INDENT> dd = collections . defaultdict ( int ) <NEWLINE> n = int ( input ( ) ) <NEWLINE> res = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> s . sort ( ) <NEWLINE> dd [ <STRING> . join ( s ) ] += 1 <NEWLINE> <DEDENT> for i in dd . values ( ) : <NEWLINE> <INDENT> res += ( i * ( i - 1 ) ) // 2 <NEWLINE> <DEDENT> print ( res ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main4 ( ) <NEWLINE> <DEDENT>
import itertools , math <NEWLINE> n = int ( input ( ) ) <NEWLINE> word = [ input ( ) for _ in range ( n ) ] <NEWLINE> count = 0 <NEWLINE> <NL> def combinations_count ( n , r ) : <NEWLINE> <INDENT> return math . factorial ( n ) // ( math . factorial ( n - r ) * math . factorial ( r ) ) <NEWLINE> <NL> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> word [ i ] = sorted ( word [ i ] ) <NEWLINE> <NL> <DEDENT> new_word = list ( sorted ( word ) ) <NEWLINE> <NL> x = 1 <NEWLINE> <NL> for i in range ( n - 1 ) : <NEWLINE> <INDENT> if new_word [ i ] == new_word [ i + 1 ] : <NEWLINE> <INDENT> x += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> count += combinations_count ( x , 2 ) <NEWLINE> x = 1 <NEWLINE> <DEDENT> <DEDENT> if x >= 2 : <NEWLINE> <INDENT> count += combinations_count ( x , 2 ) <NEWLINE> <NL> <DEDENT> print ( count ) <NEWLINE>
import collections <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> S = [ ( sorted ( input ( ) ) ) for _ in range ( N ) ] <NEWLINE> c = collections . Counter ( S ) <NEWLINE> ans = 0 <NEWLINE> for i in set ( S ) : <NEWLINE> <INDENT> n = c [ i ] <NEWLINE> ans += n * ( n - 1 ) // 2 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n = input ( ) <NEWLINE> s = [ <STRING> . join ( sorted ( input ( ) ) ) for i in range ( n ) ] <NEWLINE> count = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n ) : <NEWLINE> <INDENT> if s [ j ] [ 0 ] == s [ i ] [ 0 ] : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = [ list ( input ( ) ) for _ in range ( n ) ] <NEWLINE> ans = 0 <NEWLINE> sd = dict ( [ ] ) <NEWLINE> <NL> for i in s : <NEWLINE> <INDENT> key = <STRING> . join ( sorted ( i ) ) <NEWLINE> sd . setdefault ( key , 0 ) <NEWLINE> sd [ key ] += 1 <NEWLINE> <NL> <DEDENT> for v in s_dict . values ( ) : <NEWLINE> <INDENT> ans += v * ( v - 1 ) // 2 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
K , X = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> l = max ( X - K + 1 , - 1000000 ) <NEWLINE> r = min ( X + K - 1 , 1000000 ) <NEWLINE> <NL> ans = [ ] <NEWLINE> <NL> for i in range ( l , r + 1 ) : <NEWLINE> <INDENT> ans . append ( str ( i ) ) <NEWLINE> <NL> <DEDENT> ans = <STRING> . join ( ans ) <NEWLINE> <NL> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = [ <STRING> . join ( sorted ( list ( input ( ) ) ) ) for _ in range ( n ) ] <NEWLINE> s . sort ( ) <NEWLINE> cnt = 0 <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> if s [ i ] == s [ i + 1 ] : <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> print ( cnt ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> arr = [ ] <NEWLINE> from collections import Counter <NEWLINE> c = Counter ( [ ] ) <NEWLINE> for _ in range n : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> z = [ item for item in s ] <NEWLINE> z . sort ( ) <NEWLINE> z = tuple ( z ) <NEWLINE> c [ z ] += 1 <NEWLINE> <DEDENT> ans = 0 <NEWLINE> for item in c . values ( ) : <NEWLINE> <INDENT> ans += ( item * ( item - 1 ) ) // 2 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
from sys import stdin <NEWLINE> import copy <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> S = [ stdin . readline ( ) [ : - 1 ] for i in [ 0 ] * ( n - 1 ) ] <NEWLINE> S . append ( stdin . readline ( ) ) <NEWLINE> s = [ ] <NEWLINE> for i in S : <NEWLINE> <INDENT> s . append ( <STRING> . join ( sorted ( i ) ) ) <NEWLINE> <DEDENT> s . sort ( ) <NEWLINE> arr = [ ] <NEWLINE> temp = 1 <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> if temp > 1 and s [ i ] != s [ i + 1 ] : <NEWLINE> <INDENT> arr . append ( temp ) <NEWLINE> temp = 1 <NEWLINE> <DEDENT> if s [ i ] == s [ i + 1 ] : <NEWLINE> <INDENT> temp += 1 <NEWLINE> <DEDENT> <DEDENT> if temp > 1 : <NEWLINE> <INDENT> arr . append ( temp ) <NEWLINE> <DEDENT> arr . sort ( ) <NEWLINE> factorial = [ 1 ] <NEWLINE> for i in range ( arr [ - 1 ] + 1 ) : <NEWLINE> <INDENT> factorial . append ( factorial [ i ] * ( i + 1 ) ) <NEWLINE> <DEDENT> comb = [ 0 , 0 ] <NEWLINE> for i in range ( 2 , arr [ - 1 ] + 1 ) : <NEWLINE> <INDENT> comb . append ( factorial [ i ] / ( 2 * factorial [ i - 2 ] ) ) <NEWLINE> <DEDENT> ans = 0 <NEWLINE> for i in arr : <NEWLINE> <INDENT> ans += comb [ i ] <NEWLINE> <DEDENT> print ( int ( ans ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = { } <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> tmp = list ( input ( ) . strip ( ) ) . sort ( ) <NEWLINE> tmp = <STRING> . join ( tmp ) <NEWLINE> s [ tmp ] = s . get ( tmp , 0 ) + 1 <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for key in s . keys ( ) : <NEWLINE> <INDENT> v = s [ key ] <NEWLINE> if v < 2 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> cmb = v * ( v - 1 ) <NEWLINE> cmb = cmb // 2 <NEWLINE> ans += cmb <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
from collections import Counter <NEWLINE> from math import factorial <NEWLINE> n = int ( input ( ) ) <NEWLINE> s = [ <STRING> . join ( sorted ( list ( input ( ) ) ) ) for _ in range ( n ) ] <NEWLINE> <NL> def combination ( i ) : <NEWLINE> <INDENT> return factorial ( i ) // ( factorial ( i - 2 ) * factorial ( 2 ) ) <NEWLINE> <NL> <DEDENT> cnt = Counter ( s ) <NEWLINE> print ( cnt ) <NEWLINE> ans = 0 <NEWLINE> for i in cnt . values ( ) : <NEWLINE> <INDENT> print ( i ) <NEWLINE> ans += combination ( i ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
from heapq import * <NEWLINE> ( N , M ) , * t = [ map ( int , s . split ( ) ) for s in open ( 0 ) ] <NEWLINE> q , z = [ ] , 0 <NEWLINE> v = [ q for _ in [ None ] * 10 ** 5 ] <NEWLINE> for a , b in t : <NEWLINE> <INDENT> v [ a - 1 ] += b , <NEWLINE> <DEDENT> for i in v [ : M ] : <NEWLINE> <INDENT> for j in i : <NEWLINE> <INDENT> heappush ( q , - j ) <NEWLINE> <DEDENT> if q : <NEWLINE> <INDENT> z += - heappop ( q ) <NEWLINE> <DEDENT> <DEDENT> print ( z ) <NEWLINE>
<COMMENT> <NL> def input2 ( ) : <NEWLINE> <INDENT> return map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <DEDENT> n , m = input2 ( ) <NEWLINE> AB = [ [ ] for _ in range ( m ) ] <NEWLINE> <NL> <NL> for i in range ( n ) : <NEWLINE> <INDENT> a , b = input2 ( ) <NEWLINE> if a - 1 < m : <COMMENT> <NEWLINE> <INDENT> AB [ a - 1 ] . append ( - b ) <COMMENT> <NEWLINE> <NL> <DEDENT> <DEDENT> ans = 0 <NEWLINE> heap = [ ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> for b in AB [ i ] : <NEWLINE> <INDENT> heapq . heappush ( heap , b ) <NEWLINE> <COMMENT> <NL> <DEDENT> if len ( heap ) > 0 : <NEWLINE> <INDENT> MAX = heapq . heappop ( heap ) <NEWLINE> ans += - MAX <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
mport heapq <NEWLINE> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> list = [ [ ] for i in range ( m ) ] <NEWLINE> h = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if a <= m : <NEWLINE> <INDENT> list [ a - 1 ] . append ( - b ) <NEWLINE> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> for j in list [ i ] : <NEWLINE> <INDENT> heapq . heappush ( h , j ) <NEWLINE> <DEDENT> if h : <NEWLINE> <INDENT> ans += - heapq . heappop ( h ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from heapq import * <NEWLINE> ( N , M ) , * t = [ map ( int , s . split ( ) ) for s in open ( 0 ) ] <NEWLINE> q , z = [ ] , 0 <NEWLINE> v = [ q for _ in [ 0 ] * 10 ** 5 ] <NEWLINE> for a , b in t : <NEWLINE> <INDENT> v [ a - 1 ] += b , <NEWLINE> <DEDENT> for i in v [ : M ] : <NEWLINE> <INDENT> for j in i : <NEWLINE> <INDENT> heappush ( q , - j ) <NEWLINE> <DEDENT> z += - heappop ( q ) <NEWLINE> <DEDENT> print ( z ) <NEWLINE>
a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> water = c - ( a - b ) <NEWLINE> print ( water if water > 0 else 0 <NEWLINE>
a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( max ( c - ( a - b ) ) , 0 ) <NEWLINE>
a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( max ( 0 , c - ( a - b ) ) <NEWLINE>
a , b , c = map ( int , input ( ) . split ) <NEWLINE> print ( max ( 0 , c - a + b ) ) <NEWLINE>
import sys <NEWLINE> A , B , C = map ( int , input ( ) . split ( ) ) <NEWLINE> if not ( 1 <= B <= 20 and B <= A <= 20 ) : sys . exit ( ) <NEWLINE> if not ( 1 <= C <= 20 ) : sys . exit ( ) <NEWLINE> <NL> res = C - ( A - B ) <NEWLINE> print ( res ) if res >= 0 else : print ( 0 ) <NEWLINE>
A = int ( input ( <STRING> ) ) <NEWLINE> B = int ( input ( <STRING> ) ) <NEWLINE> C = int ( input ( <STRING> ) ) <NEWLINE> <NL> if A >= B + C : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ( B + C ) - A ) <NEWLINE> <DEDENT>
<NL> <NL> <INDENT> a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( max ( 0 , c - max ( 0 , a - b ) ) ) <NEWLINE> <DEDENT>
A , B , C = map ( int , input ( ) . split ( ) ) <NEWLINE> if C - A + B > 0 : <NEWLINE> <INDENT> print ( C = A + B ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT>
A , B , C = map ( int , sinput ( ) . split ( ) ) <NEWLINE> if ( C >= A - B ) : <NEWLINE> <INDENT> print ( C - ( A - B ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT>
a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( max ( c - a - b ) , 0 ) <NEWLINE>
list ( a , b , c ) = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> print ( max ( c - ( a - b ) , 0 ) ) <NEWLINE>
a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> print ( mak ( 0 , c - ( a - b ) ) ) <NEWLINE>
a , b , cmap ( int , input ( ) . split ( ) ) <NEWLINE> if a - b >= c : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( c - a + b ) <NEWLINE> <DEDENT>
a = list ( map ( int . input ( ) . split ( ) ) ) <NEWLINE> print ( max ( 0 , a [ 2 ] - ( a [ 0 ] - a [ 1 ] ) ) ) <NEWLINE>
a , b , c = int ( input ( ) . split ( ) ) <NEWLINE> <NL> if ( a - b ) <= c : <NEWLINE> <INDENT> print ( str ( c - ( a - b ) ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
<COMMENT> <NL> print ( max ( - 1 * int ( input ( ) ) + int ( input ( ) ) + int ( input ( ) ) , 0 ) ) <NEWLINE>
a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> q = a - b <NEWLINE> ans = c - ans <NEWLINE> <NL> if ans < 0 : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
a , b , c = map ( int , input ( ) split ( ) ) <NEWLINE> ans = c - ( a - b ) <NEWLINE> if ( ans < 0 ) : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if len ( i ) % 2 == 1 : <NEWLINE> <INDENT> ans = ans + 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> l = [ ] <NEWLINE> <NL> if N % 2 == 0 : <NEWLINE> <INDENT> for i in range ( 0 , N + 1 , 2 ) : <NEWLINE> <INDENT> n = len ( str ( i ) ) <NEWLINE> if n % 2 == 1 : <NEWLINE> <INDENT> l . append ( n ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( len ( l ) ) <NEWLINE> <NL> Else : <NEWLINE> <INDENT> for j in range ( 1 , N + 1 , 2 ) : <NEWLINE> <INDENT> n = len ( str ( i ) ) <NEWLINE> if n % 2 == 1 : <NEWLINE> <INDENT> l . append ( n ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( len ( l ) ) <NEWLINE> <NL> <NL> <NL>
n = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if ( len ( i ) % 2 ) != 0 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = input ( ) <NEWLINE> <NL> count = 0 <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> if len ( str ( i ) ) % 2 != 0 : <NEWLINE> <INDENT> count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( count ) <NEWLINE> <NL>
N = input ( ) <NEWLINE> <NL> cnt = 0 <NEWLINE> <NL> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> if len ( str ( i ) ) % 2 != 0 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
for i in range ( 1 , int ( input ( ) ) + 1 ) : <NEWLINE> <INDENT> if len ( str ( i ) ) % 2 == 1 : <NEWLINE> <INDENT> print ( len [ i ] ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> <NL> r = 0 <NEWLINE> <NL> for i in range ( 1 , n + 1 ) <NEWLINE> <INDENT> if len ( str ( i ) ) % 2 == 1 : <NEWLINE> <INDENT> r += 1 <NEWLINE> <DEDENT> <DEDENT> print ( r ) <NEWLINE>
a = int ( input ( ) ) <NEWLINE> for i in range ( 1 , a + 1 ) : <NEWLINE> <INDENT> if len ( str ( i ) ) % 2 == 1 : ans += 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> res = 0 <NEWLINE> for i in range ( n + 1 ) : <NEWLINE> <INDENT> if str ( i ) % 2 == 1 : <NEWLINE> <INDENT> res += 1 <NEWLINE> <DEDENT> <DEDENT> print ( res0 <NEWLINE>
n = int ( input ( ) ) <NEWLINE> if len ( n ) == 1 : <NEWLINE> <INDENT> print ( n ) <NEWLINE> <DEDENT> elif len ( n ) == 2 : <NEWLINE> <INDENT> print ( 9 ) <NEWLINE> <DEDENT> elif len ( n ) == 3 : <NEWLINE> <INDENT> print ( n - 90 ) <NEWLINE> <DEDENT> elif len ( n ) == 4 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif len ( n ) == 5 : <NEWLINE> <INDENT> print ( n - 9090 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import sys <COMMENT> <NEWLINE> import os <COMMENT> <NEWLINE> import math <NEWLINE> <NL> N = input ( ) <NEWLINE> count = 0 <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if i < 10 : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> elif i < 1000 : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> elif i < 100000 : <NEWLINE> <INDENT> count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( count ) <NEWLINE> input ( ) <NEWLINE> <NL>
n = input ( ) <NEWLINE> count = 0 <NEWLINE> for i in range ( n + 1 ) : <NEWLINE> <INDENT> if len ( i ) % 2 == 1 : <NEWLINE> <INDENT> count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for n in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> if len ( str ( n ) ) % 2 == 1 : <NEWLINE> ans += 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
ans = 0 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if len ( str ( i ) ) % 2 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> N = input ( ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , int ( N + 1 ) ) : <NEWLINE> <INDENT> if len ( str ( i ) ) % 2 != 0 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = <STRING> <NEWLINE> for i in range ( N - 1 , 0 , - 1 ) : <NEWLINE> <INDENT> if A [ i ] > A [ i - 1 ] : A [ i - 1 ] -= 1 <NEWLINE> <INDENT> if A [ i ] > A [ i - 1 ] : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> H = list ( map ( int , input ( ) ) ) <NEWLINE> p , a = True , 0 <NEWLINE> for h in H : <NEWLINE> <INDENT> if h > a : <NEWLINE> <INDENT> a = h - 1 <NEWLINE> <DEDENT> elif a > h : <NEWLINE> <INDENT> p = False <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> if p else <STRING> ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> judge = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if a [ i ] < judge : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> judge = max ( judge , a [ i ] - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import bisect , collections , copy , heapq , itertools , math , string <NEWLINE> from collections import defaultdict as D <NEWLINE> from functools import reduce <NEWLINE> import numpy as np <NEWLINE> import sys <NEWLINE> import os <NEWLINE> from operator import mul <NEWLINE> <NL> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> <NL> def _S ( ) : return sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> def I ( ) : return int ( _S ( ) ) <NEWLINE> def LS ( ) : return list ( _S ( ) . split ( ) ) <NEWLINE> def LI ( ) : return list ( map ( int , LS ( ) ) ) <NEWLINE> <NL> if os . getenv ( <STRING> ) : <NEWLINE> <INDENT> inputFile = basename_without_ext = os . path . splitext ( os . path . basename ( __file__ ) ) [ 0 ] + <STRING> <NEWLINE> sys . stdin = open ( inputFile , <STRING> ) <NEWLINE> <DEDENT> INF = float ( <STRING> ) <NEWLINE> IINF = 10 ** 18 <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> <COMMENT> <NL> <NL> N = I ( ) <NEWLINE> H = LI ( ) <NEWLINE> <NL> <COMMENT> <NL> <NL> if N == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> ans = True <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> if H [ i ] <= H [ i + 1 ] : <NEWLINE> <COMMENT> <NL> <INDENT> continue <NEWLINE> <DEDENT> elif ( not i == 0 ) and H [ i ] - 1 == H [ i + 1 ] : <NEWLINE> <INDENT> if not H [ i - 1 ] == H [ i ] : <NEWLINE> <INDENT> H [ i ] -= 1 <NEWLINE> <COMMENT> <NL> continue <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> ans = False <NEWLINE> break <NEWLINE> <NL> <DEDENT> if ans : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> H = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> p1 = p2 = 0 <NEWLINE> for i in H : <NEWLINE> <INDENT> print ( prv , i , i < prv - 1 , prv <= i , prv - 1 <= i ) <NEWLINE> if i < max ( p2 , p1 - 1 ) : <NEWLINE> <COMMENT> <NL> <INDENT> break <NEWLINE> <DEDENT> if i < p1 : <NEWLINE> <INDENT> p2 = p1 - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> p2 = p1 <NEWLINE> <DEDENT> p1 = i <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import sys <NEWLINE> n = int ( input ( ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if h [ 0 ] > 0 : <NEWLINE> <INDENT> h [ 0 ] -= 1 <NEWLINE> <DEDENT> for i in range ( 1 , n ) : <NEWLINE> <INDENT> if h [ i - 1 ] == h [ i ] : <NEWLINE> <INDENT> sonomama = 1 <NEWLINE> <DEDENT> elif h [ i ] > [ i - 1 ] : <NEWLINE> <INDENT> h [ i ] -= 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> sys . exit ( ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> H = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = True <NEWLINE> lis = { } <NEWLINE> for i in H : <NEWLINE> <INDENT> if i in lis : <NEWLINE> <INDENT> lis [ i ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> lis [ i ] = 1 <NEWLINE> <DEDENT> <DEDENT> mine = min ( H ) <NEWLINE> times = lis [ mine ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if mine < H [ i ] - 1 : <NEWLINE> <INDENT> ans = False <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if H [ i ] == mine : <NEWLINE> <INDENT> times -= 1 <NEWLINE> <DEDENT> if times == 0 and i != N - 1 : <NEWLINE> <INDENT> del lis [ mine ] <NEWLINE> lis = sorted ( lis ) <NEWLINE> mine = next ( iter ( lis ) ) <NEWLINE> times = lis [ next ( iter ( lis ) ) ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if ans : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> L = list ( int ( input ( ) ) for _ in range ( N ) ) <NEWLINE> M = L [ : : - 1 ] <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> if M [ i ] + 1 < M [ i + 1 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> elif M [ i ] + 1 == M [ i + 1 ] : <NEWLINE> <INDENT> M [ i + 1 ] = M [ i ] <NEWLINE> <DEDENT> <DEDENT> else : print ( <STRING> ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> H = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if N == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( N - 1 ) : <NEWLINE> <INDENT> if H [ N - i - 2 ] >= H [ N - i - 1 ] + 2 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> elif H [ N - i - 2 ] == H [ N - i - 1 ] + 1 : <NEWLINE> <INDENT> H [ [ N - i - 2 ] -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> for j in range ( N - 1 ) : <NEWLINE> <INDENT> if H [ i ] > H [ i + 1 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
<COMMENT> <NL> n = int ( input ( ) ) <NEWLINE> h = reversed ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> cnt = 0 <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> if h [ i + 1 ] - h [ i ] > 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( 0 ) <NEWLINE> <DEDENT> elif h [ i + 1 ] - h [ i ] == 1 : <NEWLINE> <INDENT> h [ i + 1 ] -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> from fractions import gcd <NEWLINE> from itertools import combinations , permutations , accumulate <COMMENT> <NEWLINE> <COMMENT> <NL> from collections import deque , defaultdict , Counter <NEWLINE> import decimal <NEWLINE> import re <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> import sys <NEWLINE> sys . setrecursionlimit ( 10000000 ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <COMMENT> <NL> def readInts ( ) : <NEWLINE> <INDENT> return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <DEDENT> def I ( ) : <NEWLINE> <INDENT> return int ( input ( ) ) <NEWLINE> <DEDENT> n = I ( ) <NEWLINE> H = readInts ( ) <NEWLINE> ma = H [ 0 ] <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> if ma < H [ i ] : <NEWLINE> <INDENT> A [ i ] -= 1 <NEWLINE> <DEDENT> if ma <= H [ i ] : <NEWLINE> <INDENT> ma = H [ i ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in range ( 1 , n - 1 ) : <NEWLINE> <INDENT> if h [ i - 1 ] <= h [ i ] <= h [ i + 1 ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if h [ i ] > h [ i + 1 ] : <NEWLINE> <INDENT> h [ i ] -= 1 <NEWLINE> if h [ i ] < h [ i - 1 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for i in range ( 1 , n - 1 ) : <NEWLINE> <INDENT> if not h [ i - 1 ] = < h [ i ] <= h [ i + 1 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
S = input ( ) <NEWLINE> <NL> counter = [ ] <NEWLINE> cnt_dict = { <STRING> : 0 , <STRING> : 0 } <NEWLINE> for i in range ( len ( S ) ) : <NEWLINE> <INDENT> l = S [ i ] <NEWLINE> if l == <STRING> : <NEWLINE> <INDENT> if cnt_dict [ <STRING> ] == 0 : <NEWLINE> <INDENT> cnt_dict [ l ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> counter . append ( cnt_dict ) <NEWLINE> cnt_dict = { <STRING> : 0 , <STRING> : 0 } <NEWLINE> cnt_dict [ l ] += 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> cnt_dict [ l ] += 1 <NEWLINE> <DEDENT> <DEDENT> counter . append ( cnt_dict ) <NEWLINE> <NL> output = [ ] <NEWLINE> for c in counter : <NEWLINE> <INDENT> block_R = [ 0 for _ in range ( c [ <STRING> ] ) ] <NEWLINE> block_L = [ 0 for _ in range ( c [ <STRING> ] ) ] <NEWLINE> q , r = divmod ( ( c [ <STRING> ] + c [ <STRING> ] ) , 2 ) <NEWLINE> if r == 0 : <NEWLINE> <INDENT> block_R [ - 1 ] = q <NEWLINE> block_L [ 0 ] = q <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if c [ <STRING> ] % 2 == 0 : <NEWLINE> <INDENT> block_R [ - 1 ] = q <NEWLINE> blcok_L [ 0 ] = q + r <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> block_R [ - 1 ] = q + r <NEWLINE> block_L [ 0 ] = q <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> output += block_R <NEWLINE> output += block_L <NEWLINE> <NL> <DEDENT> print ( <STRING> . join ( map ( str , output ) ) ) <NEWLINE>
import sys <NEWLINE> from operator import itemgetter <NEWLINE> <NL> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> def ii ( ) : return int ( input ( ) ) <NEWLINE> def mi ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def lmi ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> def lmif ( n ) : return [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ] <NEWLINE> def ss ( ) : return input ( ) . split ( ) <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> children = [ 0 ] * len ( s ) <NEWLINE> s += <STRING> <NEWLINE> start = 0 <NEWLINE> now = 0 <NEWLINE> while now < len ( s ) - 1 : <NEWLINE> <INDENT> r = 0 <NEWLINE> l = 0 <NEWLINE> while s [ now ] == <STRING> : <NEWLINE> <INDENT> r += 1 <NEWLINE> now += 1 <NEWLINE> <DEDENT> er = now - 1 <NEWLINE> sl = now <NEWLINE> while s [ now ] == <STRING> : <NEWLINE> <INDENT> l += 1 <NEWLINE> now += 1 <NEWLINE> <DEDENT> count = now - start <NEWLINE> if count % 2 == 0 : <NEWLINE> <INDENT> children [ er ] = count // 2 <NEWLINE> children [ sl ] = count // 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if r % 2 == 1 : <NEWLINE> <INDENT> children [ er ] = count // 2 + 1 <NEWLINE> children [ sl ] = count // 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> children [ er ] = count // 2 <NEWLINE> children [ sl ] = count // 2 + 1 <NEWLINE> <DEDENT> <DEDENT> start = now <NEWLINE> <NL> <DEDENT> print ( * children ) <NEWLINE> <NL> return <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE>
l , r = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> s = [ ] <NEWLINE> if r - l > 2050 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( l , r + 1 ) : <NEWLINE> <INDENT> s . append ( i % 2019 ) <NEWLINE> <DEDENT> s . sort ( ) <NEWLINE> print ( s [ 0 ] * s [ 1 ] ) <NEWLINE> <NL> <DEDENT>
S = input ( ) <NEWLINE> N = len ( S ) <NEWLINE> ans = [ 0 ] * N <NEWLINE> i = 0 <NEWLINE> while i < N : <NEWLINE> <INDENT> count = 1 <NEWLINE> while S [ i + count ] == S [ i ] : <NEWLINE> <INDENT> count += 1 <NEWLINE> if count == N - 1 - i : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> if S [ i ] == <STRING> : <NEWLINE> <INDENT> ans [ i + count ] += ( count + 1 ) // 2 <NEWLINE> ans [ i + count - 1 ] += count // 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans [ i ] += ( count + 1 ) // 2 <NEWLINE> ans [ i - 1 ] += count // 2 <NEWLINE> <DEDENT> i += count <NEWLINE> <DEDENT> print ( * ans ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> if ( N + M ) % 2 == 0 : <NEWLINE> <INDENT> print ( ( N + M ) / 2 ) <NEWLINE> else : <NEWLINE> print ( <STRING> ) <NEWLINE> <DEDENT>
m , n = map ( int , input . split ( ) ) <NEWLINE> total = m + n <NEWLINE> if total % 2 == 0 : <NEWLINE> <INDENT> print ( total // 2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if ( a - b ) % 2 == 0 : <NEWLINE> <INDENT> print ( a - ( a - b // 2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
<NL> def Input ( ) : <NEWLINE> <INDENT> return mapt ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> a , b = Input ( ) <NEWLINE> if a % 2 != b % 2 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ( a + b ) // 2 ) <NEWLINE> <NL> <DEDENT> <DEDENT> main ( ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> s = a + b <NEWLINE> if s % 2 == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else ; <NEWLINE> print ( s // 2 ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> <NL> step = sum ( [ 90 * 100 ** i for i in range ( len ( str ( N ) ) // 2 ) ] ) <NEWLINE> dance_floor = sum ( [ 9 * 100 ** i for i in range ( len ( str ( N ) ) // 2 ) ] ) <NEWLINE> <NL> ans = len ( str ( N ) ) % 2 * ( N - step ) + - 1 * ( len ( str ( N ) ) % 2 - 1 ) * dance_floor <NEWLINE> print ( ans ) <NEWLINE>
ma = lambda : map ( int , input ( ) . split ( ) ) <NEWLINE> lma = lambda : list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> tma = lambda : tuple ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ni = lambda : int ( input ( ) ) <NEWLINE> yn = lambda fl : print ( <STRING> ) if fl else print ( <STRING> ) <NEWLINE> import collections <NEWLINE> import math <NEWLINE> import itertools <NEWLINE> import heapq as hq <NEWLINE> a , b = ma ( ) <NEWLINE> k2 = abs ( b - a ) <NEWLINE> if k % 2 == 1 : <NEWLINE> <INDENT> print ( k2 // 2 + min ( b , a ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
length = int ( input ( ) ) <NEWLINE> list_p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <COMMENT> <NL> count = 0 <NEWLINE> for i in range ( length ) : <NEWLINE> <INDENT> if list_p [ i ] != ( i + 1 ) : <NEWLINE> <INDENT> count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if count <= 2 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if ( a + b ) / 2. is_integer ( ) : <NEWLINE> <INDENT> print ( ( a + b ) // 2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b = map ( Int , input ( ) . split ( ) ) <NEWLINE> if ( a + b ) % 2 == 0 : <NEWLINE> <INDENT> print ( ( a + b ) // 2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> x = a + b <NEWLINE> if x % 2 == 0 : <NEWLINE> <INDENT> print ( s / 2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if ( a + b ) % 2 == 0 : <NEWLINE> <INDENT> print ( int ( ( a + b ) / 2 ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> <NEWLINE> <DEDENT>
A , B = map ( int ( input ( ) ) ) <NEWLINE> if ( A + B ) % 2 == 0 : <NEWLINE> <INDENT> print ( ( A + B ) // 2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
A , B = map ( int , input ( ) ) <NEWLINE> <NL> if ( A + B ) % 2 == 0 : print ( ( A + B ) // 2 ) <NEWLINE> else : print ( <STRING> ) <NEWLINE>
if ( A + B ) % 2 == 0 : <NEWLINE> <INDENT> print ( ( A + B ) // 2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> cnt = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if p [ i ] != ( i + 1 ) : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> if cnt == 0 or cnt == 2 else <STRING> ) <NEWLINE>
import sys , os , math , bisect , itertools , collections , heapq , queue <NEWLINE> <COMMENT> <NL> from decimal import Decimal <NEWLINE> from collections import defaultdict , deque <NEWLINE> <NL> <COMMENT> <NL> <NL> sys . setrecursionlimit ( 10000000 ) <NEWLINE> <NL> ii = lambda : int ( sys . stdin . buffer . readline ( ) . rstrip ( ) ) <NEWLINE> il = lambda : list ( map ( int , sys . stdin . buffer . readline ( ) . split ( ) ) ) <NEWLINE> fl = lambda : list ( map ( float , sys . stdin . buffer . readline ( ) . split ( ) ) ) <NEWLINE> iln = lambda n : [ int ( sys . stdin . buffer . readline ( ) . rstrip ( ) ) for _ in range ( n ) ] <NEWLINE> <NL> iss = lambda : sys . stdin . buffer . readline ( ) . decode ( ) . rstrip ( ) <NEWLINE> sl = lambda : list ( map ( str , sys . stdin . buffer . readline ( ) . decode ( ) . split ( ) ) ) <NEWLINE> isn = lambda n : [ sys . stdin . buffer . readline ( ) . decode ( ) . rstrip ( ) for _ in range ( n ) ] <NEWLINE> <NL> lcm = lambda x , y : ( x * y ) // math . gcd ( x , y ) <NEWLINE> <COMMENT> <NL> <NL> MOD = 10 ** 9 + 7 <NEWLINE> MAX = float ( <STRING> ) <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> if os . getenv ( <STRING> ) : <NEWLINE> <INDENT> sys . stdin = open ( <STRING> , <STRING> ) <NEWLINE> <NL> <DEDENT> N = ii ( ) <NEWLINE> P = il ( ) <NEWLINE> cnt = 0 <NEWLINE> for n in range ( N ) : <NEWLINE> <INDENT> if P [ n ] != n + 1 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> if P [ P [ n ] ] != n + 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> if cnt > 3 else <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
<NL> n = int ( input ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> new_p = p . sort ( ) <NEWLINE> cnt = 0 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> if p [ i ] != new_p [ i ] : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if cnt > 2 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> answer = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if p [ i ] + 1 != p [ i + 1 ] : <NEWLINE> <INDENT> answer += 1 <NEWLINE> <DEDENT> if answer <= 2 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = [ int ( i ) for in input ( ) . split ( ) ] <NEWLINE> t = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n ) : <NEWLINE> <INDENT> t += a [ i ] > a [ j ] <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> if t < 2 else <STRING> ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> P = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> cnt = 0 <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> if P [ i ] != i : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> if cnt == 2 else <STRING> ) <NEWLINE>
n = int ( intput ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = A . sorted ( ) <NEWLINE> dif = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if A [ i ] != B [ i ] : <NEWLINE> <INDENT> dif += 1 <NEWLINE> <DEDENT> <DEDENT> if dif == 0 or dif == 2 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = int ( input ) <NEWLINE> List = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> mid = - 1 <NEWLINE> flag = True <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if List [ i ] == i + 1 : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> flag = False <NEWLINE> if mid == - 1 : <NEWLINE> <INDENT> mid = List [ i ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if mid == List [ i ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if flag : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> S = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> Min_S = min ( S ) <NEWLINE> Min_idx = S . index ( Min_S ) <NEWLINE> <NL> <NL> S [ 0 ] , S [ Min_idx ] = S [ Min_idx ] , S [ 0 ] <NEWLINE> if S == Sort_S : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
def check ( n , list1 ) : <NEWLINE> <INDENT> new = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> new . append ( list1 [ i ] ) <NEWLINE> <NL> <DEDENT> new . sort ( ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> swaps = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if list1 [ i ] != new [ i ] : <NEWLINE> <INDENT> swaps += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if swaps == 0 or swaps == 2 : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return False <NEWLINE> <NL> <DEDENT> <DEDENT> n = int ( input ( ) ) <NEWLINE> numbers = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> numbers . append ( int ( input ( ) ) ) <NEWLINE> <NL> <DEDENT> if check ( n , numbers ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <NL> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> <COMMENT> <NL> <NL> <NL> ans = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> ans += min ( A [ i ] , B [ i ] ) <NEWLINE> B [ i ] = max ( B [ i ] - A [ i ] ) <NEWLINE> <NL> <NL> <COMMENT> <NL> <NL> <NL> <NL> <NL> <DEDENT>
<COMMENT> <NL> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> b = int ( input ( ) ) <NEWLINE> tmp = A [ i ] - b <NEWLINE> if tmp < 0 : <NEWLINE> <INDENT> ans += A [ i ] <NEWLINE> if A [ i + 1 ] < - tmp : <NEWLINE> <INDENT> ans += A [ i + 1 ] <NEWLINE> A [ i + 1 ] = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += - tmp <NEWLINE> A [ i + 1 ] += tmp <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> ans += b <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
def solv ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> x = A [ i ] + A [ i + 1 ] <NEWLINE> ans += min ( x , B [ i ] ) <NEWLINE> A [ i + 1 ] = min ( A [ i + 1 ] , max ( x - B [ i + 1 ] , 0 ) ) <NEWLINE> <DEDENT> return print ( ans ) <NEWLINE> <NL> <DEDENT> solv ( ) <NEWLINE>
<INDENT> = int ( input ( ) ) <NEWLINE> <DEDENT> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> if a [ i ] < b [ i ] : <NEWLINE> <INDENT> ab = b [ i ] - a [ i ] <NEWLINE> if a [ i + 1 ] > ab : <NEWLINE> <INDENT> ans += b [ i ] <NEWLINE> a [ i + 1 ] -= ab <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += a [ i ] + a [ i + 1 ] <NEWLINE> a [ i + 1 ] = 0 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> ans += b [ i ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> import math <NEWLINE> <NL> read = sys . stdin . read <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> <NL> sys . setrecursionlimit ( 10 ** 8 ) <NEWLINE> INF = float ( <STRING> ) <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> S = int ( input ( ) ) <NEWLINE> x1 = math . ceil ( S ** 0.5 ) <NEWLINE> x2 = X1 ** 2 - S <NEWLINE> print ( 0 , 0 , x1 , 1 , x2 , x1 ) <NEWLINE> <NL> <NL> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
r = input ( ) <NEWLINE> <NL> print ( 3 * r ** 2 ) <NEWLINE>
print ( a * int ( input ( ) ) ** 2 ) <NEWLINE>
print ( 3 * input ( ) * input ( ) ) <NEWLINE>
<COMMENT> <NL> print ( 3 * int ( input ) ** 2 ) <NEWLINE>
r = int ( input ( ) ) <NEWLINE> print ( 3 * a * a ) <NEWLINE>
r = int ( input ( ) ) <NEWLINE> print ( 3 r ** 2 ) <NEWLINE>
r = int ( input ( ) ) <NEWLINE> print ( 3 * a * a ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = [ int ( input ( ) ) for _ in range ( n ) ] <NEWLINE> b = max ( a ) <NEWLINE> c = a . index ( b ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if i == c : <NEWLINE> <INDENT> print ( max ( sorted ( a ) [ : n - 1 ] ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( b ) <NEWLINE> <DEDENT> <DEDENT>
r = int ( input ( ) ) <NEWLINE> print ( int ( 3 * r ** ) ) <NEWLINE>
print ( 3 * a ** 2 ) <NEWLINE>
r = input ( ) <NEWLINE> print ( 3 * r ** 2 ) <NEWLINE>
from math import ceil <NEWLINE> <NL> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> print ( math . ceil ( a // ( 2 * b + 1 ) ) ) <NEWLINE>
a , b = list ( map ( int , input ( ) ) ) <NEWLINE> print ( ( a - 1 ) / ( 2 * b + 1 ) / 1 ) <NEWLINE>
n , d = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( n // ( 2 d + 1 ) + 1 ) <NEWLINE>
n , d = map ( int , inpit ( ) . split ( ) ) <NEWLINE> x = 2 * d + 1 <NEWLINE> print ( ( d + x - 1 ) // x ) <NEWLINE>
n , d = map ( int , input ( ) . split ( ) ) <NEWLINE> p = n / ( 2 d + 1 ) <NEWLINE> if p % 1 == 0 : <NEWLINE> <INDENT> print ( p ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ( p // 1 ) + 1 ) <NEWLINE> <DEDENT>
N , D = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> print ( - ( - N // ( 2 D + 1 ) ) ) <NEWLINE>
n , d = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( math . ceil ( n / ( 2 * d + 1 ) ) ) <NEWLINE>
import math <NEWLINE> n , d = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( math . ceil ( n / ( s * 2 + 1 ) ) ) <NEWLINE>
N , D = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( math . ceil ( N / ( 2 * D + 1 ) ) ) <NEWLINE>
import math <NEWLINE> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( math . ceil ( a / ( 2 b + 1 ) ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = [ int ( input ( ) ) for _ in range ( N ) ] <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> M = max ( A ) <NEWLINE> sub_M = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if i not in M_list : <NEWLINE> <INDENT> sub_M = max ( sub_M , A [ i ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> M_list = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if A [ i ] == M : M_list . append ( i ) <NEWLINE> <NL> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> if i in M_list : print ( sub_M ) <NEWLINE> else : print ( M ) <NEWLINE> <DEDENT>
sn = int ( input ( ) ) <NEWLINE> arr = [ int ( input ( ) ) for _ in range ( n ) ] <NEWLINE> arr . sort ( ) <NEWLINE> mx = arr [ - 1 ] <NEWLINE> sc = arr [ - 2 ] <NEWLINE> <NL> for ele in arr : <NEWLINE> <INDENT> if ele == mx : <NEWLINE> <INDENT> print ( sc ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( mx ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = [ int ( input ( ) ) for i in range ( n ) ] <NEWLINE> sa = a . sort ( ) <NEWLINE> am , asl = sa [ - 1 ] , sa [ - 2 ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> print ( asl if a [ i ] == am else am ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = [ int ( input ( ) ) for _ in range ( n ) ] <NEWLINE> <NL> b = sorted ( a ) <NEWLINE> <NL> for i in a : <NEWLINE> <INDENT> if i = b [ - 1 ] : <NEWLINE> <INDENT> print ( b [ - 2 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( b [ - 1 ] ) <NEWLINE> <DEDENT> <DEDENT>
a_l = [ int ( input ( ) ) for _ in range ( n ) ] <NEWLINE> <NL> l = [ ] <NEWLINE> r = [ ] <NEWLINE> l_max = 0 <NEWLINE> r_max = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> l_max = max ( l_max , a_l [ i ] ) <NEWLINE> r_max = max ( r_max , a_l [ - i - 1 ] ) <NEWLINE> l . append ( l_max ) <NEWLINE> r . append ( r_max ) <NEWLINE> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> t_l = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> t_l = l [ i - 1 ] <NEWLINE> <DEDENT> if i == n - 1 : <NEWLINE> <INDENT> t_r = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> t_r = r [ - i - 2 ] <NEWLINE> <DEDENT> print ( max ( [ t_l , t_r ] ) ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = [ int ( input ( ) ) for _ in range ( n ) ] <NEWLINE> b = max ( l ) <NEWLINE> c = a . index ( b ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if i == c : <NEWLINE> <INDENT> print ( max ( sorted ( a ) [ : n - 1 ] ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( b ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = [ int ( input ( ) ) for i in range ( n ) ] <NEWLINE> q = set ( sorted ( a ) ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> if a [ i ] != q [ - 1 ] : <NEWLINE> <INDENT> print ( q [ - 1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( q [ - 2 ] ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> <NL> max_1 = 0 <NEWLINE> max_2 = 0 <NEWLINE> max_index = 0 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> item = int ( input ( ) ) <NEWLINE> <INDENT> if item >= max_1 : <NEWLINE> <INDENT> max_1 , max_2 = item , max_1 <NEWLINE> max_index = i <NEWLINE> <DEDENT> elif item > max_2 : <NEWLINE> <INDENT> max_2 = item <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> ans = max_2 if i == max_index else max_1 <NEWLINE> print ( ans ) <NEWLINE> <NL> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = [ int ( input ( ) ) for _ in range ( N ) ] <NEWLINE> <NL> m1 , m2 = sorted ( A , reversed = True ) [ 0 : 2 ] <NEWLINE> for a in A : <NEWLINE> <INDENT> print ( m2 if a == m1 else m1 ) <NEWLINE> <DEDENT>
N , D = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> print ( ( N + 2 * D ) // ( 2 * D + 1 ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = [ ] <NEWLINE> b = sorted ( a ) <NEWLINE> mx = b [ - 1 ] <NEWLINE> mx2 = b [ - 2 ] <NEWLINE> for i in a : <NEWLINE> <INDENT> if i == mx : <NEWLINE> <INDENT> print ( mx2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( mx ) <NEWLINE> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> l = [ ] <NEWLINE> l . append ( int ( input ( ) ) ) <NEWLINE> l . append ( int ( input ( ) ) ) <NEWLINE> m1 = max ( l ) <NEWLINE> mx = min ( l ) <NEWLINE> for _ in range ( N - 2 ) : <NEWLINE> <INDENT> l . append ( int ( input ( ) ) ) <NEWLINE> if l [ - 1 ] >= m1 : <NEWLINE> <INDENT> m2 = m1 <NEWLINE> m1 = l [ - 1 ] <NEWLINE> <DEDENT> elif l [ - 1 ] > m2 : <NEWLINE> <INDENT> m2 = l [ - 1 ] <NEWLINE> <DEDENT> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> if l [ i ] == m1 : <NEWLINE> <INDENT> print ( m2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( m1 ) <NEWLINE> <DEDENT> <DEDENT>
a = [ int ( input ( ) ) for i in range ( n ) ] <NEWLINE> m = max ( a ) <NEWLINE> p = a . index ( m ) <NEWLINE> s = max ( a ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if i != p : <NEWLINE> <INDENT> print ( m ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( s ) <NEWLINE> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> box = [ 0 ] * N <NEWLINE> for i in range ( N , 0 , - 1 ) : <NEWLINE> <INDENT> sm = 0 <NEWLINE> for j in range ( i , N + 1 , i ) : <NEWLINE> <INDENT> sm += box [ j - 1 ] <NEWLINE> <DEDENT> print ( i , sm ) <NEWLINE> box [ i - 1 ] = ( sm % 2 ) ^ a [ i - 1 ] <NEWLINE> <DEDENT> print ( sum ( box ) ) <NEWLINE> print ( * sum ) <NEWLINE>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> import numpy as np <NEWLINE> from numba import njit <NEWLINE> <NL> <NL> def read ( ) : <NEWLINE> <INDENT> N = int ( input ( ) . strip ( ) ) <NEWLINE> A = [ int ( input ( ) . strip ( ) ) for _ in range ( N ) ] <NEWLINE> return N , A <NEWLINE> <NL> <NL> <DEDENT> @ njit <NEWLINE> def segtree_init ( size , init_value = 10 ** 8 , dtype = np . int32 ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> n = 1 <NEWLINE> while size > 1 : <NEWLINE> <INDENT> size >>= 1 <NEWLINE> n += 1 <NEWLINE> <DEDENT> treesize = n * 2 <NEWLINE> st = np . full ( treesize , init_value , dtype = dtype ) <NEWLINE> st_idx = np . arange ( treesize , dtype = dtype ) <NEWLINE> offset = st . shape [ 0 ] // 2 <NEWLINE> return st , st_idx , offset <NEWLINE> <NL> <DEDENT> @ njit <NEWLINE> def segtree_update ( st , st_idx , offset , key , value , init_value = 10 ** 8 ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> k = offset + key <NEWLINE> st [ k ] = value <NEWLINE> k >>= 1 <NEWLINE> while k > 0 : <NEWLINE> <INDENT> if st [ k * 2 ] <= st [ k * 2 + 1 ] : <NEWLINE> <INDENT> st [ k ] = st [ k * 2 ] <NEWLINE> st_idx [ k ] = st_idx [ k * 2 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> st [ k ] = st [ k * 2 + 1 ] <NEWLINE> st_idx [ k ] = st_idx [ k * 2 + 1 ] <NEWLINE> <DEDENT> k >>= 1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> @ njit <NEWLINE> def _segtree_find_le ( st , st_idx , offset , value , k = 1 , init_value = 10 ** 8 ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if value < st [ k ] : <NEWLINE> <INDENT> return ( st . shape [ 0 ] , - init_value ) <NEWLINE> <DEDENT> elif value == st [ k ] or k >= offset : <NEWLINE> <INDENT> return ( st_idx [ k ] , st [ k ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> li , lv = _segtree_find_le ( st , st_idx , offset , value , k * 2 , init_value = init_value ) <NEWLINE> ri , rv = _segtree_find_le ( st , st_idx , offset , value , k * 2 + 1 , init_value = init_value ) <NEWLINE> mi = li if lv >= rv else ri <NEWLINE> mv = lv if lv >= rv else rv <NEWLINE> if mi < st . shape [ 0 ] : <NEWLINE> <INDENT> return ( mi , mv ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return ( st . shape [ 0 ] , - init_value ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> @ njit <NEWLINE> def segtree_find_le ( st , st_idx , offset , value , init_value = 10 ** 8 ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> i , v = _segtree_find_le ( st , st_idx , offset , value , k = 1 , init_value = init_value ) <NEWLINE> if i == st . shape [ 0 ] : <NEWLINE> <INDENT> return ( - 1 , init_value ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return ( i - offset , v ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def solve ( N , A , INF = 10 ** 9 + 1 ) : <NEWLINE> <INDENT> st , st_idx , offset = segtree_init ( N ) <NEWLINE> l = 0 <NEWLINE> for a in A [ : : - 1 ] : <NEWLINE> <INDENT> k , v = segtree_find_le ( st , st_idx , offset , - a - 1 ) <COMMENT> <NEWLINE> if k == - 1 : <NEWLINE> <INDENT> segtree_update ( st , st_idx , offset , l , - a ) <NEWLINE> l += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> segtree_update ( st , st_idx , offset , k , - a ) <NEWLINE> <DEDENT> <DEDENT> return l <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> inputs = read ( ) <NEWLINE> outputs = solve ( * inputs ) <NEWLINE> if outputs is not None : <NEWLINE> <INDENT> print ( <STRING> % str ( outputs ) ) <NEWLINE> <DEDENT> <DEDENT>
from math import floor , ceil <NEWLINE> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> m = floor ( n * n / 4 ) <NEWLINE> <NL> if k % 2 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> k //= 2 <NEWLINE> <NL> <DEDENT> if k > m : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> I = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> I += floor ( i * i / 4 ) + 1 <NEWLINE> <NL> <DEDENT> I += k <NEWLINE> <NL> ans = [ 1 , 1 , 1 , 1 , 2 , 3 , 1 , 3 , 7 , 9 , 4 , 1 , 4 , 12 , 24 , 35 , 24 , 20 , 1 , 5 , 18 , 46 , 93 , 137 , 148 , 136 , 100 , 36 , 1 , 6 , 25 , 76 , 187 , 366 , 591 , 744 , 884 , 832 , 716 , 360 , 252 , 1 , 7 , 33 , 115 , 327 , 765 , 1523 , 2553 , 3696 , 4852 , 5708 , 5892 , 5452 , 4212 , 2844 , 1764 , 576 , 1 , 8 , 42 , 164 , 524 , 1400 , 3226 , 6436 , 11323 , 17640 , 25472 , 33280 , 40520 , 44240 , 45512 , 40608 , 35496 , 25632 , 18108 , 8064 , 5184 , 1 , 9 , 52 , 224 , 790 , 2350 , 6072 , 13768 , 27821 , 50461 , 83420 , 127840 , 182256 , 242272 , 301648 , 350864 , 382576 , 389232 , 373536 , 332640 , 273060 , 208548 , 136512 , 81792 , 46656 , 14400 , 1 , 10 , 63 , 296 , 1138 , 3708 , 10538 , 26480 , 59673 , 121626 , 226787 , 390144 , 628744 , 949472 , 1355952 , 1826464 , 2341600 , 2833632 , 3282464 , 3584160 , 3765600 , 3719664 , 3531924 , 3093336 , 2642364 , 2010240 , 1508544 , 963072 , 621504 , 259200 , 158400 , 1 , 11 , 75 , 381 , 1582 , 5582 , 17222 , 47194 , 116457 , 261163 , 537459 , 1022981 , 1817652 , 3040352 , 4810720 , 7230928 , 10360160 , 14178912 , 18577792 , 23327872 , 28132048 , 32571504 , 36310464 , 38903904 , 40028724 , 39552156 , 37457388 , 33941412 , 29314944 , 24179904 , 18835776 , 13777344 , 9452736 , 5716800 , 3211200 , 1742400 , 518400 , 1 , 12 , 88 , 480 , 2137 , 8096 , 26860 , 79376 , 211811 , 515308 , 1153268 , 2391936 , 4633331 , 8438664 , 14557048 , 23874176 , 37407760 , 56117824 , 80906752 , 112162240 , 150052400 , 193572736 , 241706624 , 291576384 , 341323776 , 386160048 , 424359540 , 450394992 , 464545584 , 461528208 , 446428476 , 413557632 , 373573440 , 321120000 , 268449408 , 210332160 , 162330624 , 112550400 , 77788800 , 462 540800 , 28497600 , 11404800 , 6739200 , 1 , 13 , 102 , 594 , 2819 , 11391 , 40344 , 127508 , 364587 , 952559 , 2293742 , 5126898 , 10710633 , 21042989 , 39117852 , 69175664 , 116857024 , 189256368 , 294745440 , 442503456 , 641759376 , 900689616 , 1225195328 , 1617201408 , 2074227568 , 2586823344 , 3140227152 , 3711888720 , 4274217108 , 4795069860 , 5242715496 , 5585116392 , 5796764532 , 5861974500 , 5769155520 , 5525176320 , 5146566336 , 4650715584 , 4073773824 , 3455145216 , 2828946816 , 2226153600 , 1685664000 , 1216281600 , 828705600 , 536385600 , 309484800 , 166924800 , 87609600 , 25401600 , 1 , 14 , 117 , 724 , 3645 , 15626 , 58741 , 197280 , 600215 , 1671266 , 4295107 , 10259436 , 22922995 , 48184950 , 95816051 , 181136304 , 327071752 , 566117888 , 942525072 , 1513281024 , 2349163824 , 3532145440 , 5154557808 , 7309226816 , 10088509424 , 13563257696 , 17789064560 , 22766807808 , 28474675776 , 34795689552 , 41599134900 , 48627067176 , 55658989332 , 62307608832 , 68337633276 , 73295701704 , 77044870908 , 79150212864 , 79705302912 , 78336039168 , 75452522688 , 70797368448 , 65062675008 , 58057993728 , 50777737344 , 42845299200 , 35452368000 , 28090656000 , 21810196800 , 15976944000 , 11564798400 , 7582118400 , 4994784000 , 2869862400 , 1697760000 , 660441600 , 381024000 , 1 , 15 , 133 , 871 , 4633 , 20979 , 83313 , 295803 , 952299 , 2809009 , 7656027 , 19414457 , 46086247 , 102967901 , 217634463 , 437195525 , 838372452 , 1540635296 , 2722168544 , 4638311888 , 7640827440 , 12196046992 , 18898688688 , 28478200080 , 41793020656 , 59808863184 , 83562236656 , 114094792400 , 152385334384 , 199237795920 , 255197696544 , 320398045632 , 394504459524 , 476579739996 , 565078141044 , 657793371852 , 751961300508 , 844280523396 , 931179786300 , 1008947570148 , 1073901780288 , 1122859574784 , 1153199220480 , 1162920789504 , 1151362908864 , 1118735012160 , 1066297271616 , 996482755008 , 912653709696 , 818140406400 , 717623164800 , 615320438400 , 514373198400 , 419013316800 , 332205912000 , 255360225600 , 189570585600 , 136068076800 , 93372652800 , 60961248000 , 38023084800 , 21261139200 , 11151302400 , 5715360000 , 1625702400 , 1 , 16 , 150 , 1036 , 5802 , 27648 , 115538 , 431844 , 1464468 , 4554040 , 13096378 , 35069940 , 87969166 , 207781760 , 464351910 , 986188668 , 1998611843 , 3879505944 , 7237509272 , 13015110720 , 22621334976 , 38088677888 , 62257578976 , 98963017536 , 153235640032 , 231442109440 , 341429103840 , 492483008192 , 695329738720 , 961718454912 , 1304266313504 , 1735413962688 , 2267256302640 , 2909626740720 , 3670318493172 , 4552059101472 , 5554081940040 , 6667352777520 , 7879104296208 , 9165503659392 , 10500956428536 , 11846534605056 , 13167457892028 , 14413109030784 , 15546887406144 , 16514424730368 , 17287265145600 , 17815876978176 , 18093515829696 , 18081692165376 , 17803211030784 , 17237020190976 , 16437468406464 , 15395145465600 , 14197797676800 , 12838232448000 , 11423747851200 , 9945343929600 , 8513833939200 , 7105078598400 , 5833289937600 , 4638449318400 , 3628313222400 , 2730379622400 , 2020397644800 , 1414609920000 , 982442649600 , 621627955200 , 396722188800 , 221705164800 , 127998662400 , 48771072000 , 27636940800 , 1 , 17 , 168 , 1220 , 7172 , 35852 , 157132 , 616084 , 2192506 , 7159090 , 21631676 , 60902460 , 160707468 , 399489140 , 939796228 , 2101060924 , 4481320149 , 9151453613 , 17952463180 , 33931694704 , 61957528720 , 109554162816 , 187990143808 , 313644949184 , 509651801344 , 807791600000 , 1250556129216 , 1893271983168 , 2806107639040 , 4075710281600 , 5806280567104 , 8119615755712 , 11154099827008 , 15061775283648 , 20004257726064 , 26145645547824 , 33644807030628 , 42644340934020 , 53259802113888 , 65565790979616 , 79585068885480 , 95274332180712 , 112516352516016 , 131110932730032 , 150773092160580 , 171132178067748 , 191741447066688 , 212087371934592 , 231608361436992 , 249716920472640 , 265829870923776 , 279385661746944 , 289894659756480 , 296941397872320 , 300227034794112 , 299585080955520 , 294995153434176 , 286559630510400 , 274559844672000 , 259389153907200 , 241532891409600 , 221597909553600 , 200222946000000 , 178056657705600 , 155765714011200 , 133960048488000 , 113119093036800 , 93740111308800 , 76150952236800 , 60507218246400 , 46991901427200 , 35618655398400 , 26247862080000 , 18741859315200 , 12965992704000 , 8612768102400 , 5463807955200 , 3321335404800 , 1815909580800 , 933153177600 , 469827993600 , 131681894400 , 1 , 18 , 187 , 1424 , 8764 , 45832 , 210072 , 861400 , 3206786 , 10957868 , 34666130 , 102239488 , 282743580 , 736889224 , 1817936104 , 4262532056 , 9534038653 , 20412279282 , 41965109667 , 83086702848 , 158846483672 , 293945054560 , 527644521632 , 920548782464 , 1563679341888 , 2590152309632 , 4189882939840 , 6627188173824 , 10261636850752 , 15570902168192 , 23176132693440 , 33866194141184 , 48622894045376 , 68638246673536 , 95331652746368 , 130346958972672 , 175552149926736 , 232998505772976 , 304896373544484 , 393517810221336 , 501151517985420 , 629930569834080 , 781790566267368 , 958203018126576 , 1160192223258552 , 1387953675426384 , 1641014802991332 , 1917708372791352 , 2215616239559484 , 2530806526806912 , 2858760146000448 , 3193254804953088 , 3527942981821632 , 3854735694202752 , 4166293415465664 , 4453493636623104 , 4709269329522624 , 4924716652492416 , 5094443229955776 , 5211032259400704 , 5272343802869184 , 5273290780848000 , 5216027060836800 , 5098521548332800 , 4927360248734400 , 4703346319824000 , 4437548259940800 , 4132222120166400 , 3801837457080000 , 3449289557174400 , 3090301926436800 , 2726643392294400 , 2374757933126400 , 2033123097830400 , 1716958572307200 , 1422188373312000 , 1161022076409600 , 926313159168000 , 728630289561600 , 556427128320000 , 419039170905600 , 304359431040000 , 217738374739200 , 147809421043200 , 99831514003200 , 61623875174400 , 38449487462400 , 21056097484800 , 11937532723200 , 4477184409600 , 2501955993600 , 1 , 19 , 207 , 1649 , 10600 , 57852 , 276620 , 1183172 , 4595034 , 16384606 , 54107670 , 166643130 , 481442164 , 1311240788 , 3381378852 , 8288429500 , 19380463765 , 43370477631 , 93171663563 , 192688515141 , 384626048292 , 742789886992 , 1390845000560 , 2530070564544 , 4479230453440 , 7730267787328 , 13023970171584 , 21450075214912 , 34576104315968 , 54608889372864 , 84591394082624 , 128635820301760 , 192191363362752 , 282341199917888 , 408120100587200 , 580836495115584 , 814383795723136 , 1125507150179712 , 1534010392737072 , 2062846096006896 , 2738084274713844 , 3588680525700924 , 4646066536308348 , 5943452916265524 , 7514938005668568 , 9394273423038600 , 11613460498009848 , 14201019755829000 , 17180207431594308 , 20566948993624044 , 24367967746188876 , 28578772050288228 , 33182017765823232 , 38146083522361920 , 43424269915815360 , 48954142843843392 , 54658293518596032 , 60444945095508288 , 66210070142082240 , 71839575055280448 , 77213243010520512 , 82207343908763712 , 86700434810715072 , 90576623563417152 , 93730705789957056 , 96072209169768000 , 97530722522596800 , 98056260716097600 , 97625062817092800 , 96239585923041600 , 93927509616830400 , 90743816268187200 , 86766992680248000 , 82094766931483200 , 76844121200049600 , 71143861680360000 , 65126311716672000 , 58931088741676800 , 52694570792505600 , 46538151814368000 , 40578691448160000 , 34917059252563200 , 29630131391865600 , 24782142857760000 , 20415986836070400 , 16546150497945600 , 13183767580838400 , 10318463849433600 , 7914729619641600 , 5944661640288000 , 4365745634476800 , 3123480742099200 , 2168934108364800 , 1463049249177600 , 949795493068800 , 590154356736000 , 352001960755200 , 189226882252800 , 95732737228800 , 47537163878400 , 13168189440000 , 1 , 20 , 228 , 1896 , 12703 , 72200 , 359348 , 1599616 , 6465450 , 23997032 , 82508708 , 264654080 , 796563486 , 2260832432 , 6076986148 , 15528774112 , 37854314165 , 88307546724 , 197722736488 , 426061007608 , 885805625731 , 1781018204328 , 3470511436088 , 6566993828416 , 12088401115360 , 21682634049152 , 37953071128320 , 64918097309952 , 108645315176960 , 178105094157568 , 286296137524992 , 451691495214592 , 700063029235328 , 1066716651443456 , 1599191585582848 , 2360399334133248 , 3432247146956672 , 4919593672326656 , 6954598304143424 , 9701058018768768 , 13358922142388688 , 18168095276681328 , 24412133369567412 , 32420071169610768 , 42567971164897104 , 55276822950559056 , 71010593457548724 , 90267941612008224 , 113575836419326368 , 141472908389801232 , 174498890573207196 , 213167659437799632 , 257954983633593216 , 309259783322274672 , 367395402053629116 , 432538248500221824 , 504731486876700672 , 583819317770432256 , 669476491781394816 , 761125218169208832 , 858006379470759552 , 959073087310398720 , 1063124236480551552 , 1168658961938496000 , 1274099744509001856 , 1377584087708010240 , 1477299833071185024 , 1571187904013555712 , 1657418443316671104 , 1733948691170515200 , 1799189962770326400 , 1851362625237004800 , 1889371027014480000 , 1911918384395308800 , 1918634558525539200 , 1908845046140313600 , 1883044877712566400 , 1841248575368294400 , 1784820243050755200 , 1714406693610585600 , 1632175244223940800 , 1539187734633638400 , 1438224490789056000 , 1330563475582387200 , 1219268524396147200 , 1105544124544896000 , 992525059979366400 , 880998406117401600 , 773916433997990400 , 671536627550208000 , 576333411726124800 , 487929712680345600 , 408376543825958400 , 336528892720742400 , 273969770540256000 , 219119317990272000 , 172987613869593600 , 133682402996352000 , 101990683101484800 , 75686340744806400 , 55469328419635200 , 39262481724211200 , 27419265751449600 , 18209921767833600 , 12053646891417600 , 7305711501312000 , 4481661594009600 , 2416626126028800 , 1350924554649600 , 500391198720000 , 276531978240000 , 1 , 21 , 250 , 2166 , 15097 , 89189 , 461164 , 2132144 , 8950214 , 34503182 , 123236828 , 410729140 , 1284813830 , 3790835950 , 10594736344 , 28153822304 , 71374419001 , 173157539053 , 403147849738 , 903133574710 , 1951483590353 , 4076508645181 , 8249656925564 , 16205084576560 , 30953640264272 , 57587955773824 , 104512182899200 , 185276050405632 , 321248231594368 , 545428799428480 , 907771508848384 , 1482463867478272 , 2377686159128960 , 3748441022919040 , 5813093783195648 , 8874291785978624 , 13344913410940544 , 19779629503799936 , 28912539453163264 , 41701088734646528 , 59376264823979968 , 83498490465732288 , 116018439947492400 , 159340912347366000 , 216390022862021892 , 290672075859639156 , 386333421700105944 , 508207592722046040 , 661848543987823260 , 853542035425599948 , 1090292802596019360 , 1379777398829447904 , 1730262744204000300 , 2150479270223238204 , 2649453005507839992 , 3236284643680836792 , 3919888611833004180 , 4708678803532357860 , 5610223341736270272 , 6630858870450156288 , 7775294580079458048 , 9046192443068752128 , 10443782659309401600 , 11965472181894240000 , 13605535747942444800 , 15354838447260127488 , 17200685723453109504 , 19126712937761176320 , 21112991202010328064 , 23136140760463378944 , 25169700289939865856 , 27184537354710184704 , 29149487929055195136 , 31031953416959731200 , 32798868609266092800 , 34417432483596806400 , 35856117831583353600 , 37085614748603654400 , 38079779206362278400 , 38816361024881817600 , 39278001389487091200 , 39452668442429356800 , 39334141191004070400 , 38922470170397280000 , 38223949340384308800 , 37250754980641300800 , 36021139705817798400 , 34558556567604710400 , 32890748982878476800 , 31049456310283507200 , 29069213479600435200 , 26985706084161100800 , 24835953959538854400 , 22656183564605529600 , 20480830595060428800 , 18342719589376742400 , 16271208756116409600 , 14291164121157100800 , 12424440624869952000 , 10688089987673280000 , 9093251157695712000 , 7648210513867795200 , 6356462885030361600 , 5216566734498470400 , 4224977525294265600 , 3374805223337990400 , 2655285908605747200 , 2056724688730521600 , 1566905265270374400 , 1171417664135577600 , 858612358788710400 , 616222868631552000 , 431342438304153600 , 293576092559769600 , 194394606516633600 , 124056985986662400 , 75878926328217600 , 44603422953062400 , 23663236423680000 , 11825034117120000 , 5807171543040000 , 1593350922240000 , 1 , 22 , 273 , 2460 , 17807 , 109158 , 585339 , 2805752 , 12209406 , 48792492 , 180680070 , 624410736 , 2025734778 , 6199973836 , 17977710642 , 49571366296 , 130412870617 , 328328239710 , 793214869017 , 1843633061652 , 4132257423879 , 8951317797966 , 18778673440451 , 38225193868560 , 75632704665240 , 145698515938720 , 273679652395488 , 501969037120640 , 900153496335872 , 1580067709456896 , 2717871087012096 , 4585783252897536 , 7596859272042624 , 12366986017732608 , 19799251079385728 , 31196698894051584 , 48410619424416384 , 74032085061242880 , 111635680842697344 , 166083894073390848 , 243902093538610816 , 353731003400060160 , 506866223637541568 , 717885750129700608 , 1005373338199611408 , 1392725475003990960 , 1909048227902586756 , 2590107353678501064 , 3479341241713240692 , 4628857602092017824 , 6100442983910026836 , 7966434295658926872 , 10310536604920867956 , 13228316349980273424 , 16827581823941936988 , 21228171966898821432 , 26561629281191736780 , 32969917339231725792 , 40604147620476402636 , 49621863775135049640 , 60184713726526293756 , 72453988751098811904 , 86587363342428994944 , 102732513570806229504 , 121023355868590535424 , 141571723464484941312 , 164464010562102126336 , 189750943707237139968 , 217446054148983138048 , 247513696809297159168 , 279871157647869225984 , 314374946401295354880 , 350829024595289856000 , 388968725294949519360 , 428477987024194675968 , 468969975230079628800 , 510015995671610721024 , 551120806347878937600 , 591766906639798483200 , 631380294280483545600 , 669393929175873004800 , 705199552455795609600 , 738232684681962067200 , 767904590596895193600 , 793713987530551008000 , 815148616154260089600 , 831829779927025056000 , 843375877160837126400 , 849581526557004321600 , 850235550171574320000 , 845343437346671659200 , 834883552203228518400 , 819085476456085017600 , 798117949602096537600 , 772420734591822835200 , 742324884495536102400 , 708451818035538009600 , 671242858623392486400 , 631445844808110067200 , 589557719069130700800 , 546383697057974361600 , 502405602951579033600 , 458430036760859270400 , 414852526960749964800 , 372419562312210873600 , 331405481094639436800 , 292437711677495865600 , 255633983395372915200 , 221499279254697696000 , 189970376563660492800 , 161416500662066630400 , 135628726179469017600 , 112834876201922246400 , 92701883367655833600 , 75371006974762598400 , 60403865098081075200 , 47873310384782131200 , 37317611847153254400 , 28743101748858470400 , 21694361434737868800 , 16183724382211276800 , 11757254812434432000 , 8442775441723392000 , 5862891419836416000 , 4022398996413235200 , 2627926844239872000 , 1713075968946585600 , 1023774056202240000 , 619787172372480000 , 330152845639680000 , 182497937448960000 , 66920738734080000 , 36647071211520000 , 1 , 23 , 297 , 2779 , 20859 , 132473 , 735535 , 3649437 , 16435370 , 67971642 , 260491974 , 931772466 , 3129241874 , 9915880758 , 29773220410 , 85021125502 , 231663659441 , 604089240111 , 1511562098001 , 3638395658691 , 8444079661251 , 18935818870273 , 41112503633895 , 86582924368661 , 177179811427796 , 352876074420816 , 685027877348080 , 1298006731980416 , 2403744805527424 , 4355730822533760 , 7731699894018432 , 13457820671747712 , 22991750506426752 , 38587677620220544 , 63673496605345152 , 103378711318130048 , 165261459963815808 , 260294246273261952 , 404180144391318144 , 619084276678996352 , 935878388956036992 , 1397008742150540416 , 2060108412542879872 , 3002482222213559680 , 4326596788141899712 , 6166702778791975488 , 8696709365086097136 , 12139402405556541744 , 16777076504674326228 , 22963587142428379116 , 31137793073843981940 , 41838246692688363948 , 55718950935923171604 , 73565819715837940524 , 96313466376974407284 , 125061676912375274988 , 161090976384168996780 , 205876330726268666772 , 261098215934076778572 , 328649773006034480340 , 410639214911686634412 , 509385960210762006228 , 627409745808904333980 , 767411084457098195364 , 932242727580866955072 , 1124870480571526341120 , 1348323818921939335680 , 1605634847180448691968 , 1899767223181914439680 , 2233533709409596459776 , 2609505993628462291200 , 3029915006293304049408 , 3496547968015104744192 , 4010640117028580489472 , 4572769627298220717312 , 5182752453180999881472 , 5839550135617500297216 , 6541182706286499600384 , 7284664687027601332224 , 8065953564008756299776 , 8879929874955757967616 , 9720393765050699308800 , 10580105248679963462400 , 11450838486925486137600 , 12323485021659252307200 , 13188175586411546131200 , 14034444172500810931200 , 14851403289340214400000 , 15627968939738380204800 , 16353074218721290214400 , 17015921883478473120000 , 17606228168942368531200 , 18114475599818106292800 , 18532137338624063505600 , 18851926887737823902400 , 19067966920832689857600 , 19175969920607834515200 , 19173374388964240704000 , 19059429107481743116800 , 18835203905956569715200 , 18503646261225650035200 , 18069463954911476160000 , 17539044599918764224000 , 16920319107880531699200 , 16222564101277531584000 , 15456139471880406489600 , 14632335670044227443200 , 13763010730214572992000 , 12860311564314557395200 , 11936492163712844179200 , 11003567652125491564800 , 10072992410633557036800 , 9155593262703915014400 , 8261260425926162323200 , 7398698928142085625600 , 6575547959504418182400 , 5798057950204463865600 , 5071071118250636755200 , 4398238775539110700800 , 3781806863624306899200 , 3222644270004478771200 , 2720720177056246579200 , 2274884670132342374400 , 1882906236466078924800 , 1542087461753756467200 , 1249091002118589235200 , 999966309474650112000 , 790754245615569715200 , 617250073804200345600 , 475045430601188966400 , 360257526050520268800 , 268956164260623974400 , 197220432681009561600 , 141928328469008793600 , 100095183385034342400 , 68931308068580966400 , 46208598909419520000 , 30165754210099200000 , 18996811963637760000 , 11476590656348160000 , 6668621328015360000 , 3500591976161280000 , 1731972452474880000 , 842882637864960000 , 229442532802560000 , 1 , 24 , 322 , 3124 , 24280 , 159528 , 915834 , 4696644 , 21857553 , 93405656 , 369882084 , 1367190888 , 4745178560 , 15541448640 , 48237691308 , 142408538696 , 401191378923 , 1081678520728 , 2798493590562 , 6964397955940 , 16709009218728 , 38728658985304 , 86891122965210 , 189047515855860 , 399538913965795 , 821544012667704 , 1646004012304824 , 3217804932644352 , 6145766985581280 , 11481523142741888 , 21004521920971776 , 37667308787338496 , 66278380133705856 , 114530806844283904 , 194525522253345024 , 324990299741955072 , 534461719228028672 , 865778612787744768 , 1382335459089961728 , 2176660305024075776 , 3382021326274102272 , 5187916452732602880 , 7860479960383208960 , 11769009774500136960 , 17420031623819698688 , 25500465170515634944 , 36931690961432734784 , 52936361850393516672 , 75120054978943068624 , 105569647383090853872 , 146970614207171093076 , 202744704077642142144 , 277209996879250123704 , 375763592827052047728 , 505088425435206528648 , 673382050898645492640 , 890608252444293734280 , 1168765179329839996080 , 1522170602993538608400 , 1967751386286046884288 , 2525339084081733179496 , 3217948427410376419728 , 4072045823545835421720 , 5117768577625886340192 , 6389114714963810657928 , 7924039202797274967264 , 9764502738354450480060 , 11956369074852308158080 , 14549246794504164094848 , 17596107106726486708224 , 21152859695263556455680 , 25277616008960412119040 , 30029963755058743159296 , 35469816463588872185856 , 41656393250046765262080 , 48646625815029813221376 , 56493906445969401033216 , 65246063758676214681600 , 74944019873507043483648 , 85619379919578025844736 , 97293230523602567359488 , 109973425598323447753728 , 123653833263663156718848 , 138311424000024606240768 , 153906365736892502866944 , 170378968997563407590400 , 187651119415549866451200 , 205623090792530933760000 , 224176786702471089792000 , 243172350980137293926400 , 262453754999546345491200 , 281844853616898029491200 , 301157909779430148364800 , 320188597182263909088000 , 338727867181501624819200 , 356555233355582695795200 , 373454510380832322907200 , 389204131908705205881600 , 403597465993481329324800 , 416428914331938129465600 , 427519006512897567556800 , 436695061212420520896000 , 443821833971946797702400 , 448774487698343835340800 , 451476055698685057612800 , 451861137982490170521600 , 449920360725754167475200 , 445653793499740177305600 , 439123849580158991078400 , 430395452555332333132800 , 419600082976277993395200 , 406861643164791301171200 , 392371181546296938624000 , 376299086811872934067200 , 358882751826470709216000 , 340321323581750359296000 , 320880663657152923968000 , 300770698795230942028800 , 280264919237712458380800 , 259564331884072029696000 , 238933071492123989836800 , 218543636724360859699200 , 198634350269822167411200 , 179337750092285041152000 , 160852029954240461760000 , 143260158572100057600000 , 126716583502354451961600 , 111248700068699659468800 , 96964914028685307494400 , 83843204537664449740800 , 71944926744245022720000 , 61205030287562907648000 , 51650084328834900787200 , 43176984816314990592000 , 35785551191775798067200 , 29352378116762601062400 , 23855413398850794700800 , 19161279536783376384000 , 15242554840673651097600 , 11961328919931430502400 , 9289641349309844275200 , 7101563931646481203200 , 5368107197728854835200 , 3979836098713785139200 , 2918501872057291161600 , 2085861301953085440000 , 1474741181674414080000 , 1009332344825118720000 , 683091978959093760000 , 440614992848486400000 , 283788388040048640000 , 167709744671293440000 , 100460775647232000000 , 52988478270013440000 , 29022887048601600000 , 10554356508917760000 , 5736063320064000000 , 1 , 25 , 348 , 3496 , 28098 , 190746 , 1130768 , 5985744 , 28747851 , 126764795 , 517958180 , 1975500528 , 7075313948 , 23914923644 , 76611052176 , 233458283312 , 678932351111 , 1889712542463 , 5047185059412 , 12966463924856 , 32111951061426 , 76819286895114 , 177851872537120 , 399212437734336 , 870224064421645 , 1845090642750925 , 3810648054607212 , 7676589120090672 , 15103613116648464 , 29057240793626880 , 54723256909246464 , 100991312882944768 , 182814491089286400 , 324895270496615168 , 567345548231816704 , 974236377215982336 , 1646310784703146496 , 2739602815952027648 , 4492311933524833536 , 7263051681348557312 , 11584551374236661504 , 18238068881966328576 , 28355192844067885568 , 43555397399612596736 , 66129668544258101760 , 99282751094482842112 , 147449051575798257920 , 216699928621495427328 , 315262972496833573696 , 454176760285319853888 , 648107479293621214896 , 916356328133263742448 , 1284088947463741903524 , 1783819388028023202276 , 2457182055113359612560 , 3357023781725284454928 , 4549846738548876641568 , 6118627409425932505632 , 8166032104533151655952 , 10818037994759810460432 , 14227960021849329766200 , 18580864558457820056760 , 24098338745383370058288 , 31043555056408146393456 , 39726557106758684596512 , 50509652613430806226080 , 63812787828199940225088 , 80118725707755523120896 , 99977848695018724583844 , 124012341008402748706404 , 152919523548430031625408 , 187474037099279593591296 , 228528618519240174599424 , 277013118893352969634560 , 333931524270172616385792 , 400356602533047898865664 , 477422002058929887018240 , 566311447084863635382528 , 668244986039102407520256 , 784461975703112059840512 , 916201005154117860619008 , 1064676490198015012298496 , 1231052449747841691365376 , 1416413307580582031594496 , 1621732606089443150529024 , 1847839480197635014018560 , 2095384371449034207822336 , 2364803707586646673018368 , 2656285520474186219748096 , 2969735753248161972422400 , 3304747660009166696908800 , 3660573596287719399782400 , 4036102511191135861305600 , 4429841644887685452345600 , 4839906038868138906374400 , 5264014262687370258796800 , 5699493810523396011340800 , 6143293367238382254201600 , 6592006885328556476774400 , 7041904382179944225158400 , 7488974378602873444795200 , 7928973451682429555995200 , 8357486369088661024176000 , 8769990135659239190678400 , 9161929182047668653499200 , 9528790105119252491323200 , 9866183595630166970668800 , 10169925106581994479667200 , 10436117657876884400313600 , 10661225903392797474566400 , 10842155392857247991577600 , 10976314130278953688857600 , 11061672755222709092275200 , 11096811413636839376716800 , 11080958211090763664716800 , 11014004653528274684467200 , 10896524557453090114099200 , 10729760988689577591321600 , 10515608209824677483443200 , 10256581152907786987084800 , 9955768462144949023891200 , 9616764319400897497440000 , 9243615913538078285337600 , 8840734151496373252224000 , 8412804671055457146163200 , 7964713389743911822694400 , 7501446972778283809804800 , 7027992324637828138022400 , 6549268077924828886425600 , 6070028384682223926451200 , 5594775617852697464294400 , 5127718401631234039680000 , 4672694230160212124064000 , 4233106107462348154886400 , 3811927219605655957094400 , 3411652189035080090419200 , 3034261278004259513548800 , 2681270938072186022707200 , 2353717146883311098265600 , 2052149769366607591833600 , 1776723820912801500364800 , 1527189652734252466176000 , 1302921264440415707136000 , 1103034305965320246067200 , 926370940175559309312000 , 771536946645323524915200 , 637039421491969585152000 , 521271269431954771968000 , 422510227225433767526400 , 339081307254864908697600 , 269314256523902865408000 , 211547505939101415014400 , 164247664823497775923200 , 125965457902985973350400 , 95313488005195407360000 , 71112834976333086720000 , 52266031221189058560000 , 37758192883793141760000 , 26787113863460536320000 , 18639456825316884480000 , 12674602955845877760000 , 8395834454453698560000 , 5419547346062868480000 , 3376871463751188480000 , 2019835196841369600000 , 1162663387905761280000 , 605039959000350720000 , 296898637446512640000 , 143401583001600000000 , 38775788043632640000 , 1 , 26 , 375 , 3896 , 32342 , 226580 , 1385350 , 7560544 , 37426495 , 170077814 , 716127109 , 2814596496 , 10388283644 , 36187079416 , 119480127540 , 375290092352 , 1125038637631 , 3228054138246 , 8888064953473 , 23538901764312 , 60091718642678 , 148169912312852 , 353533326039750 , 817675823635744 , 1836202818312865 , 4009714831680362 , 8526750261484323 , 17681379856600608 , 35798110330967448 , 70848305519402592 , 137216236661709536 , 260338543094584704 , 484339077304236160 , 884366878322594304 , 1586191869773094016 , 2796815867337052160 , 4851538509934446080 , 8285230022790674944 , 13938696317538312192 , 23115197000114677760 , 37807670410664403712 , 61024318641119897088 , 97249288540526701568 , 153086564267694501376 , 238149366506773084416 , 366274543641240539136 , 557162341271414832128 , 838566336096399222784 , 1249187377054116279296 , 1842457697503528116992 , 2691439361752056499520 , 3895100589863936620800 , 5586280087592947443984 , 7941692201115621668400 , 11194379061466439369124 , 15649053468128815978872 , 21700833352243401470364 , 29857885482753860625504 , 40768554714752762516304 , 55253524170456870172416 , 74343615362896361865120 , 99323714512506565450080 , 131783398371837018146664 , 173674546470380440741680 , 227376390117029423539176 , 295767878597684044363872 , 382307602926812271959088 , 491120465068584099240768 , 627091074637704318839760 , 795961983710075088598704 , 1004436548341197151867956 , 1260282932851196883823128 , 1572439135800170678590332 , 1951113265133517359034624 , 2407879689214701716599680 , 2955762022920009659085312 , 3609305603783952464795904 , 4384625697915474373645824 , 5299438313228760410296320 , 6373052972652944516327424 , 7626342075547395785121792 , 9081655882881229537781760 , 10762711091925047068624128 , 12694406269988533285495296 , 14902613725179446657462016 , 17413877129193407881368576 , 20255098019521284692543232 , 23453103785805559887081984 , 27034231590647672331269376 , 31023764564911192363355136 , 35445430763716224892552704 , 40320717662889370391740416 , 45668322328978707508491264 , 51503366222884094447232000 , 57836853777596653895788800 , 64674821491034298587942400 , 72017880782401733886777600 , 79860344641751037672576000 , 88189949680489548836812800 , 96987002007507407231385600 , 106224390057626298694195200 , 115866785191893151568659200 , 125871059511487122120633600 , 136185562740071410811308800 , 146751062991813538328289600 , 157500081142772428766448000 , 168358473925311527713627200 , 179244770315090261986944000 , 190072487799140938591953600 , 200749375329511127326300800 , 211180547311839437207774400 , 221267450816521240240512000 , 230911909469667209786457600 , 240014585811943254643430400 , 248479967472341027682412800 , 256214075234469461683545600 , 263130450259760350703481600 , 269146728288300088184832000 , 274191749930833766064691200 , 278200633290994324096819200 , 281123037398416711341312000 , 282916416425982673171276800 , 283555579327418555318016000 , 283023635818936674321792000 , 281323153311375917557555200 , 278464433199403972152960000 , 274478350499388142806470400 , 269401808486361833564889600 , 263292584508502191717177600 , 256211432721931330344960000 , 248239540356847615342771200 , 239457099154333840996608000 , 229963420190587820567846400 , 219852159078962697322291200 , 209234516835175957168243200 , 198210566613155851772236800 , 186896416122364529389132800 , 175391649902745524929766400 , 163810079065494398121580800 , 152244050045520996342259200 , 140799084386689358332819200 , 129554199964032617616998400 , 118601490601622287352217600 , 108002718639235131251097600 , 97832529758851780464230400 , 88132797202585052329574400 , 78959333554740402127257600 , 70332799485577100658278400 , 62290019940875385097420800 , 54831925358586496253952000 , 47977052835435433707110400 , 41708828183095260846489600 , 36030896759170692126720000 , 30911771202613118654054400 , 26343384965247111410073600 , 22284271348232809763635200 , 18717344705750129097523200 , 15595184026121544378777600 , 12896443948442321575526400 , 10570446795987903489638400 , 8594660884080139661721600 , 6919739643645233182310400 , 5523280791220641886617600 , 4359648394747374059520000 , 3409879230556300615680000 , 2632532560238903132160000 , 2012538877880380416000000 , 1515308743790998732800000 , 1128836468251237294080000 , 825292447367445872640000 , 597115613438679121920000 , 421339956320210780160000 , 294305156083891814400000 , 199133626731003740160000 , 133314264734956462080000 , 85115133247592448000000 , 54289734507837480960000 , 31792016230188318720000 , 18879219926593044480000 , 9877042152084602880000 , 5368725825047101440000 , 1938789402181632000000 , 1046946277178081280000 , 1 , 27 , 403 , 4325 , 37042 , 267514 , 1685106 , 9470830 , 48268511 , 225792189 , 978561725 , 3958557179 , 15038052176 , 53919433772 , 183254996828 , 592546701524 , 1828704500735 , 5402032877813 , 15313509008845 , 41754551848667 , 109740664332378 , 278559697128682 , 684144818798562 , 1628533558543326 , 3763203397901441 , 8454389004568659 , 18491945799538435 , 39430715892345765 , 82069113550547908 , 166926985775869008 , 332164179333849008 , 647301823529393664 , 1236543133235810304 , 2317686029181838336 , 4265920644773647872 , 7716684276560985344 , 13728843089498510848 , 24039631883231850752 , 41457114803908704512 , 70455850798992290816 , 118068742937912211968 , 195204944070816316160 , 318572876940354267392 , 513452158787296947968 , 817642280976370204160 , 1287023708753996198400 , 2003303536658721121280 , 3084688486630137926656 , 4700438641429315153920 , 7090512026840488397824 , 10591818996827567052544 , 15672971982756086980352 , 22979845798316616976960 , 33394759185233281910976 , 48112653131891079089904 , 68738271692335811738928 , 97409048088920716221300 , 136949145004996700345820 , 191060895166272766747692 , 264560693498326874210724 , 363667216106834000358624 , 496350596184144056157024 , 672751913013830551472352 , 905682880872737814936096 , 1211216071793021046207864 , 1609376069112285710188584 , 2124941885237871017761896 , 2788370261574082662481272 , 3636848636854100306825184 , 4715484715073092822180128 , 6078637715053235184718704 , 7791393022615352070303984 , 9931178920876416057799764 , 12589518861024949073335356 , 15873908507772375772482732 , 19909799445621489432314148 , 24842666280005799740831808 , 30840124317902025238635264 , 38094059517295514646958848 , 46822720642912187762116608 , 57272719126838069053827072 , 69720867985222563058444032 , 84475789743477802998705408 , 101879207142131992512031488 , 122306834246006987714506752 , 146168767164800617978235904 , 173909287220916027652886016 , 206005966456939360624000512 , 242967993967219027177066752 , 285333613501239027424721664 , 333666609506787805027612416 , 388551742322487144228055296 , 450589109359817738601573120 , 520387350954156428523874560 , 598555735901343287382788352 , 685695079883333826445582080 , 782387603322163702829554176 , 889185720677516402531212800 , 1006599970372875458802278400 , 1135086103695701668803840000 , 1275031653902717840735212800 , 1426742049050394614648006400 , 1590426682916505833246745600 , 1766185026887228935109760000 , 1953993338186931299570688000 , 2153691993787962653502201600 , 2364974118185094337496659200 , 2587375526257907423176608000 , 2820266673372240682113576000 , 3062846539869535611905976000 , 3314139294332224575007905600 , 3572993378391939578938104000 , 3838083936289193356502097600 , 4107918143112982303943476800 , 4380844189493167195995115200 , 4655063214175099409364283200 , 4928645239734179240844307200 , 5199547703673639015342144000 , 5465637742316427799208294400 , 5724716816595281310508953600 , 5974548414665347716423379200 , 6212887031938595001155193600 , 6437509984248281255791814400 , 6646248879985068599589408000 , 6837022752490104747340492800 , 7007870231109745453984665600 , 7156981584865712338009344000 , 7282727962631289094583577600 , 7383690594315237360634905600 , 7458684789961736106685056000 , 7506782279003468920761216000 , 7527328914717979791043737600 , 7519958463315189403959264000 , 7484600181767080149114220800 , 7421484574146256002738720000 , 7331140217472578932178476800 , 7214387734921261364996198400 , 7072329010828910243727513600 , 6906330298931248002483187200 , 6717999839954611570400908800 , 6509165743207805606687808000 , 6281844993387567275952268800 , 6038211767999165712918374400 , 5780565558937327741262668800 , 5511294292793056413720480000 , 5232836251113226186042080000 , 4947648310519063874292960000 , 4658166347786187914319264000 , 4366770233309656342268313600 , 4075756572903510948216422400 , 3787305543631528475100364800 , 3503451570658008216171724800 , 3226068799817350604595609600 , 2956846280367992529239654400 , 2697271981014074291870515200 , 2448629922318385355259494400 , 2211988404830527738714521600 , 1988196043713459765637939200 , 1777894011022986002055168000 , 1581514151594235095030169600 , 1399284321679499901120921600 , 1231255657991996073451929600 , 1077306510253032634182451200 , 937154452461679085340672000 , 810390586965964105535078400 , 696489122835545721550848000 , 594819516148480835264102400 , 504686671496288875431936000 , 425333011319464386926592000 , 355956508529613410833612800 , 295745900657142886594560000 , 243878872397085045304934400 , 199532047945751543070720000 , 161919642510577375764480000 , 130281625846058516766720000 , 103885232286514836971520000 , 82059541698052016824320000 , 64181074505787721359360000 , 49669141967972586823680000 , 38012891799242116915200000 , 28751131268114525061120000 , 21465850836258791424000000 , 15810612679552326451200000 , 11477809667169266319360000 , 8194150499083101020160000 , 5748221911675307581440000 , 3957336832094085242880000 , 2663767234602412646400000 , 1747616048310276587520000 , 1117808456221487923200000 , 690463478945539031040000 , 409611593358171832320000 , 233949472474400686080000 , 120864131332002938880000 , 58900422038277980160000 , 28267549483808194560000 , 7600054456551997440000 , 1 , 28 , 432 , 4784 , 42229 , 314064 , 2036108 , 11772944 , 61710789 , 296841956 , 1322742124 , 5501368272 , 21486564345 , 79208215656 , 276787566480 , 920236944864 , 2920301598963 , 8870866655268 , 25859461215752 , 72508153911248 , 195965742433359 , 511492271946752 , 1291642050713452 , 3160934022096336 , 7508248873186919 , 17336057661450332 , 38962898620883484 , 85350731888040240 , 182453170987073219 , 381053481498031560 , 778365668846332984 , 1556645385101862848 , 3050862828436876128 , 5865113346800076160 , 11069323878252637696 , 20526022268695435008 , 37424392424136836992 , 67139594305665370112 , 118594932277569765888 , 206390364626731671552 , 354082975648538697984 , 599176285884359569920 , 1000612365356515706112 , 1649884678912425292800 , 2687327048798060991744 , 4325717332382036807680 , 6884103519771347799808 , 10835761285362537486336 , 16875483007175831703808 , 26013040420277686784000 , 39701734800054046887936 , 60013523162970181629952 , 89875389991150885926400 , 133385493063819356248320 , 196232285951180455822400 , 286245344331720266921856 , 414113191495006318022736 , 594310953562075010292336 , 846289489683346387150068 , 1195987387166589952348272 , 1677738480694306292837664 , 2336659394377566911248656 , 3231615280549956372307116 , 4438875201191838805821696 , 6056584269937549278385968 , 8210192857180327646616096 , 11059000027940796998085576 , 14803978684742007741436896 , 19697066902644995250244944 , 26052112744488452043722016 , 34257676165449945510910104 , 44791879720252707333956736 , 58239515817124950355402176 , 75311580677527506570078960 , 96867424596522961406150532 , 123939628141149364032778032 , 157761747024571288271184336 , 199798920762020898838190928 , 251781409398335570684286012 , 315740867678549830110347136 , 394049315325086485415773056 , 489460337106920228422176768 , 605152353998201201984547072 , 744773112996700004939593728 , 912485141831495113645556736 , 1113010792174314374537723904 , 1351676606798824144353838080 , 1634454936495420784682130432 , 1968002708481131872438540800 , 2359694349766443834062530560 , 2817649254032910063955881216 , 3350749554424637561143074816 , 3968649611747347579654915584 , 4681771279468421667053589504 , 5501288181830680003787741952 , 6439090696316743442757092352 , 7507737902117482774103430144 , 8720384763416713389808598016 , 10090695596421267487870373376 , 11632727089607329759449682944 , 13360799114740714613332598784 , 15289329318918178792650393600 , 17432660278523329499087481600 , 19804844419146873468440064000 , 22419430755942153514843123200 , 25289202878516652528526617600 , 28425933643528384904275660800 , 31840083423049532401350835200 , 35540537120903245407934233600 , 39534274289003103019152172800 , 43826108956405558784038195200 , 48418347568661529379043788800 , 53310557573365424810268456000 , 58499232151651903990435219200 , 63977618781408717441619862400 , 69735410308994941891644710400 , 75758668096961685727817452800 , 82029558339427539932005824000 , 88526404774401456381105859200 , 95223484955086880438308608000 , 102091247639047094166433656000 , 109096174416707301901369075200 , 116201193916398599201003251200 , 123365605261210125585436108800 , 130545712785376685826383731200 , 137694794717406638248930252800 , 144763978432500716789717971200 , 151702217083099366613335987200 , 158457418794172589933854080000 , 164976382050404457510539136000 , 171206177956794607082544864000 , 177093980082112111172769484800 , 182588701129363917175189708800 , 187640626195476727195525862400 , 192203305819593539918431795200 , 196232901579653514560470425600 , 199690320639847523228908646400 , 202540178421428567364522547200 , 204753184889671958789629382400 , 206304598879579511241133593600 , 207176893075625366816649216000 , 207357603189466772529915724800 , 206842273750341602878232044800 , 205631623832968045178539315200 , 203734831851444523998150720000 , 201165892223571588070354867200 , 197947333177622978810282956800 , 194105709702941073397365196800 , 189675784706467877258309568000 , 184695140467980076571175168000 , 179208950838874053525712569600 , 173263598539829979999311692800 , 166912200961160837532466636800 , 160207247460418406921048140800 , 153206894179746042439904352000 , 145966692254183587868317286400 , 138546805496415069105425203200 , 131002696954092266691320217600 , 123393477247418439084648038400 , 115771625363098924954553548800 , 108192361690895306909427302400 , 100702566673953757736096563200 , 93351301755034503276859392000 , 86177728081360273883922432000 , 79222965848315441736837120000 , 72517142263246347732207206400 , 66092266611009600232719974400 , 59968694550004268134927564800 , 54169053777483458178122956800 , 48703796027558276291901849600 , 43586387902874963430582681600 , 38818144267085077824061440000 , 34404038051153309215049318400 , 30337310811255295942538035200 , 26615868321447315412063027200 , 23226208779227745580911820800 , 20160629662751026231962009600 , 17400768559909188146587238400 , 14934762074792456028337766400 , 12741057738333786381572505600 , 10805495136473368135061913600 , 9104756245758203648163840000 , 7623753210110744642396160000 , 6339160547460475047936000000 , 5235908520734153607905280000 , 4291760256635803056537600000 , 3492937222671565247201280000 , 2818873344058956842434560000 , 2257618341511518971166720000 , 1791175378729018576896000000 , 1409463882177919559147520000 , 1097252792759400431616000000 , 846790627527546930708480000 , 645334733754814558371840000 , 487201417647903425617920000 , 362431441276567925391360000 , 266874338846028100239360000 , 192940462496843096555520000 , 138105526481631729377280000 , 96461829034190001930240000 , 66724986701504880967680000 , 44731014871029645312000000 , 29682382082541638123520000 , 18792158416406178693120000 , 11890508674302549688320000 , 6910465841984034570240000 , 4074016946592306954240000 , 2116847820877993082880000 , 1143226558890421125120000 , 410402940653807861760000 , 220401579240007925760000 , 1 , 29 , 462 , 5274 , 47935 , 366779 , 2445008 , 14530396 , 78259797 , 386723841 , 1770080074 , 7561338950 , 30331351803 , 114839636631 , 412167820284 , 1407497158968 , 4587881314227 , 14315352301815 , 42866471930786 , 123467182024390 , 342773091206205 , 918993993810129 , 2383617306374680 , 5990901988529276 , 14613268759272743 , 34644050836995691 , 79932947755771398 , 179719309206543898 , 394239243570458889 , 844726513622941277 , 1769826383965060956 , 3629478048924763952 , 7292430503134680400 , 14368350635245468672 , 27785447358679758848 , 52777863368524091904 , 98545806079157691648 , 181002889015394097920 , 327254180306339366656 , 582789711956986828032 , 1022879655708973271808 , 1770384412058518752000 , 3023233380025405476096 , 5096296840364458096128 , 8484428852743191628032 , 13956292841127385049344 , 22692447372832438866944 , 36486385223665991906304 , 58034178685689978640896 , 91347573936092755676672 , 142337384506303948162048 , 219629563609012030922752 , 335696216818334707447808 , 508409019405431417312256 , 763154134580989143260416 , 1135687042553866378503424 , 1675954078227991975311424 , 2453166441322827254404416 , 3562483618968697625298480 , 5133748178871942045283440 , 7342814511336522351833028 , 10426131814268988018962388 , 14699378128675169572319304 , 20581098430625856068507784 , 28622477080743208415869428 , 39544572830610078303465636 , 54284564041790423998024800 , 74052789710964554439897696 , 100402628857301937552689016 , 135315529405617750752054232 , 181303778623323141277487280 , 241533886015790419169744496 , 319973729133114767949519384 , 421566867539029234866450744 , 552437668701699186568998960 , 720131069716930433668640688 , 933890941408752302643020484 , 1204981058718283369923096660 , 1547052659201253712394774664 , 1976562382319028517365278856 , 2513244116023568030839896756 , 3180637766568069004275910116 , 4006677377063212060700622528 , 5024340088089324888086493696 , 6272356451255692195407469056 , 7795981160970260804739546624 , 9647821855092498614840289024 , 11888721603824894381298774528 , 14588688877753613323869667584 , 17827866122722118008454543616 , 21697525925000725495001683968 , 26301080464526218397971258368 , 31755087683060833848125979648 , 38190233743882818825966658560 , 45752269316312251079656621056 , 54602872859398190921217017856 , 64920412781242305953167961856 , 76900575623101971379471279872 , 90756827466384471037146100224 , 106720670784357946523325012480 , 125041661295319787317336403712 , 145987143972727792242192268032 , 169841673118461635090034872832 , 196906075567391467393640013312 , 227496126086723787193265043456 , 261940797517238873469276595200 , 300580064133043940927631014400 , 343762227873677879324899776000 , 391840760838081073928483001600 , 445170645693056930305967596800 , 504104227154627225892245971200 , 568986571923408814735096070400 , 640150376652570768574326048000 , 717910438230619694955893836800 , 802557756804817312917724512000 , 894353305953082807442876889600 , 993521571427191080463002971200 , 1100243911397236712833393915200 , 1214651875947278669988812006400 , 1336820547569725706742828115200 , 1466762074979738583853740067200 , 1604419470956708739560314396800 , 1749660868341003547293545491200 , 1902274301673680260345212556800 , 2061963238070947252605740078400 , 2228342891826587711669367451200 , 2400937567835565666866124038400 , 2579179040179584644255816102400 , 2762406198826416420659453491200 , 2949865922547544426433210880000 , 3140715430635526900152722188800 , 3334025960384523143476366425600 , 3528788032862320293077011488000 , 3723918090366315895435524844800 , 3918266708416023610808856230400 , 4110628077166143791140941888000 , 4299750998003023581065514451200 , 4484350890732884731894323129600 , 4663123090628054374152260352000 , 4834756882862368827786452044800 , 4997950435994582384663310259200 , 5151426021000081121448206080000 , 5293945814642305030561949337600 , 5424327372535836072980484787200 , 5541459185418981623148741062400 , 5644315505457842424728051808000 , 5731970620428365895452845094400 , 5803611794698010947794608832000 , 5858551413456195534126696518400 , 5896237083963837067108054368000 , 5916260475458948357120858457600 , 5918364042599361729860937331200 , 5902445853796300798378719052800 , 5868561966261487927722054144000 , 5816927242953573412075629811200 , 5747913109147123981948088793600 , 5662043660627784576927892742400 , 5559989446460145500500808966400 , 5442559163734386534145186291200 , 5310689054541628656853025164800 , 5165431493814423406287638150400 , 5007940807338580242064427424000 , 4839458540683312023118121779200 , 4661297733868534010055263846400 , 4474825945193554046059957862400 , 4281447637056564328663237017600 , 4082587763621074063511939481600 , 3879673539139747530483137740800 , 3674117641389438220069633228800 , 3467302617703218477025967308800 , 3260565124926614764917202944000 , 3055181397002528945435143372800 , 2852355774832900720098682060800 , 2653208456413283716463282995200 , 2458765893003127978618788249600 , 2269954457371858442356349337600 , 2087593360125296315168869171200 , 1912390292286571706893773619200 , 1744941308269888939929255936000 , 1585728854142574120076353536000 , 1435122487791860030732685312000 , 1293384521230499831240385331200 , 1160672266780063476024589516800 , 1037043540053086925836534579200 , 922465717238764355379609600000 , 816821510315608155340549324800 , 719916846678430109766225100800 , 631493003905733030814395596800 , 551232917852335413003793612800 , 478769920722722049467280998400 , 413701049821118245602877440000 , 355593100510873028279992320000 , 303989602032739499962982400000 , 258424231492476866873548800000 , 218424544109755401282600960000 , 183517792383766496144670720000 , 153241949346742318449623040000 , 127146670822922916310548480000 , 104797407879290075665121280000 , 85784360503516091814297600000 , 69719853700286139230576640000 , 56240377298688563303178240000 , 45013998148637523064012800000 , 35735832840183937903411200000 , 28126060620914738795765760000 , 21937214743159589678407680000 , 16947922207618047320801280000 , 12960506984641796037427200000 , 9805267125505519571312640000 , 7334025007986709884149760000 , 5417044149368148101038080000 , 3948804939377639097630720000 , 2838187377103364489871360000 , 2006998163915241772154880000 , 1395148526064848665313280000 , 952158564571243582586880000 , 635604655459508618526720000 , 413702062252136214036480000 , 262608404112893356277760000 , 161038639601945495470080000 , 94878343095622307020800000 , 53834481657741506641920000 , 27641398058479614689280000 , 13391295952444619489280000 , 6391645797960229847040000 , 1710012252724199424000000 , 1 , 30 , 493 , 5796 , 54193 , 426242 , 2919073 , 17814512 , 98499977 , 499582398 , 2346636293 , 10286311316 , 42338971193 , 164482988162 , 605740498257 , 2122522327536 , 7099389174675 , 22731438428490 , 69850296149855 , 206458386035148 , 588188273121227 , 1618232202056502 , 4306888051989323 , 11106780472190960 , 27795313353868939 , 67597354358862650 , 159971259988872335 , 368854120978007932 , 829628202777224459 , 1822283660772732870 , 3913026863865904643 , 8222609064817498416 , 16924589406226109464 , 34152884065435954976 , 67624632199795797088 , 131491561420398314368 , 251266222787270808960 , 472196942250971571712 , 873287814879942700672 , 1590423961611496981504 , 2853977478855975463168 , 5049132760516462795776 , 8811395291017201586688 , 15175905782865119224320 , 25808047703062545441792 , 43355452739760634134016 , 71979260583177108183552 , 118147191219171424403968 , 191804998912291559049216 , 308089214115769806501376 , 489806584616007751058176 , 770989091389544836782080 , 1201943827276925408921344 , 1856361652635557698356736 , 2841236328681262143780352 , 4310587273690173584040448 , 6484287010395055497876224 , 9673683157346308693289728 , 14316192120013318368684608 , 21021645949556975685614592 , 30633918627665549881138320 , 44312265108689756703296688 , 63637906195159043536516932 , 90752706990644303386231848 , 128538365386272337195685316 , 180846365667101887619921184 , 252791112845552266948633884 , 351121140981795928311061992 , 484686158634941324052272220 , 665020903147597427352008832 , 907070445539738510475407544 , 1230085562886485110574582544 , 1658721301120201915781657784 , 2224376525954524680504023328 , 2966817550198944975760209096 , 3936134069997665075063609616 , 5195081548535519150708832792 , 6821869329914487338325583440 , 8913459984549571084962993156 , 11589449727587552632143297864 , 14996605864017547478220891012 , 19314139495858272635762564928 , 24759797272205897655284699484 , 31596854336484501415027065480 , 40142095279171517415181916412 , 50774861717980416658914084864 , 63947249046480508439043563136 , 80195516393975922512909380608 , 100152778214723222570230683648 , 124563011836846580346417366528 , 154296423253208027240418776832 , 190366156184171656411070461440 , 233946347498233473028419475200 , 286391440550088815242549432320 , 349256708094605844188256415488 , 424319794265903544628376652288 , 513603167545764534444210346752 , 619397158995878223323886566400 , 744283418298981098193199742976 , 891158288789949078231871478784 , 1063255889341392560207259743232 , 1264170188235917143695515885568 , 1497875849209706893241368916736 , 1768746867404498905840450103808 , 2081572838443990333748307223296 , 2441571546301620353394205501440 , 2854397891247360173321675215104 , 3326147427683763589211951703552 , 3863354885845315700056332943104 , 4472985410372169732053705932800 , 5162419501476334360516595980800 , 5939428675338013508002531814400 , 6812143799813506316667049920000 , 7789012148492791619507005824000 , 8878746586943405256807877056000 , 10090261566941544976235039769600 , 11432601475462385791155221414400 , 12914854060460273699161368211200 , 14546057492781175536307543046400 , 16335091019450797773143122540800 , 18290561926663689947156249582400 , 20420674810702038446185609315200 , 22733101597867819737611076158400 , 25234832676826097906849478144000 , 27932035283301558234610770192000 , 30829891684923641695610514355200 , 33932453534435196414019621008000 , 37242474085360148810888531116800 , 40761268324751063112056282088000 , 44488547792846659663069113993600 , 48422298088960757267203512561600 , 52558625949691977832394998080000 , 56891667186649488876088679712000 , 61413455798063172510508569139200 , 66113876170438013141510322931200 , 70980563500165781277887686118400 , 75998913678195578774461961280000 , 81152022712378631406630082329600 , 86420766885980903204178079353600 , 91783785590820841317543097689600 , 97217642602309506949629067680000 , 102696853149075039963360410419200 , 108194133650275959719345249299200 , 113680469318981111010082852876800 , 119125456895881708661634100243200 , 124497402322141284766917505459200 , 129763757851638830820326754201600 , 134891234265165827990477975884800 , 139846328353433563520017920768000 , 144595428978637143628822243123200 , 149105429121951513393007085049600 , 153343796976609384441904343769600 , 157279265754693452218972661932800 , 160881838413223501707862488883200 , 164123543333542744099541600928000 , 166978340005119645605294226931200 , 169422932303005439886894978912000 , 171436534673358808356596058470400 , 173001739761388460830007180505600 , 174104109318363223747303253376000 , 174733088342955821270403076339200 , 174881390551264061345497651430400 , 174545963084170691979677638214400 , 173727128031493547108790730944000 , 172429613905744139804675194579200 , 170661428580515395437198624614400 , 168434964029636148674292763104000 , 165765589799447239211846330841600 , 162672858024529688130516525561600 , 159178788916004575371948547276800 , 155309220321270721492538684620800 , 151091781402212404102300970188800 , 146557404242510816610413955072000 , 141738001577363834087713925529600 , 136668185941968703653155378380800 , 131382629507619048471673356288000 , 125918056038183553198179901440000 , 120310296535139146560762598195200 , 114596561368199996163640435507200 , 108812232185006123662303818547200 , 102993460550489960126171338752000 , 97173662732594288704382083891200 , 91386513962757815460192788889600 , 85662171110820748943447669145600 , 80030626997260628560350792499200 , 74517722099402386712243864371200 , 69148883808028768911637594521600 , 63944867506726532501083393228800 , 58925942734375942669788903014400 , 54107391521587783723898093568000 , 49504037846055320413854026956800 , 45125594597916278825603619225600 , 40981530874112039615803718860800 , 37076169318284956431956661043200 , 33413948598010526010184959590400 , 29994315330956888183386447872000 , 26817198937603169071080661401600 , 23877831579204131212803865804800 , 21172409428057024896875663769600 , 18692705945292940611074949120000 , 16431998443177252577506099200000 , 14379534955037658309976719360000 , 12526466336271757391973212160000 , 10860377939940660572647342080000 , 9371191952043296103348264960000 , 8045588069070608925863608320000 , 6872990848061187418769571840000 , 5839975188643438211253534720000 , 4936034463837758926182236160000 , 4148217984135264507492433920000 , 3466675477186205893449523200000 , 2879308799009425714821120000000 , 2377261187555962537476218880000 , 1949700409647169979419361280000 , 1588886305319039199690792960000 , 1285411489938071720570142720000 , 1032860078405625264476774400000 , 823213384295710557021143040000 , 651346798360989304609136640000 , 510705142665973102318141440000 , 397279650934822941451837440000 , 305849772388456989457121280000 , 233494499355108590241054720000 , 176088916706864694566584320000 , 131598683750612056735088640000 , 96943778507999841040465920000 , 70711465351049980160901120000 , 50659006869782986752000000000 , 35946328564340663648256000000 , 24898604168846520814141440000 , 17085453569073511925022720000 , 11366200486957535180881920000 , 7487041220249400758108160000 , 4706895738491728826204160000 , 2958212586230554788495360000 , 1708264240199192464588800000 , 1000919571873441510850560000 , 517046904788145489838080000 , 277698389787953434460160000 , 99180710658003566592000000 , 53010379834450182144000000 , 1 , 31 , 525 , 6351 , 61037 , 493071 , 3466221 , 21705119 , 123102861 , 640304911 , 3083941021 , 13859775423 , 58485272133 , 232929185223 , 879393448533 , 3158976127783 , 10832287881639 , 35558238520773 , 112022075176031 , 339464768355269 , 991528342487295 , 2796722728842357 , 7630927862332447 , 20173618048808901 , 51750714826238039 , 128997541050555005 , 312859238078168007 , 739190224565771501 , 1703375892145074575 , 3832583795629865589 , 8428569046245209823 , 18135396789813952565 , 38213644977305560116 , 78924814233741676496 , 159910624239180036592 , 318093739195611479808 , 621689930452736307200 , 1194655597911956370176 , 2258678427697235139840 , 4204223041568706200832 , 7709012698570619281920 , 13932897278267571210240 , 24834107926712686581248 , 43675966310861813104896 , 75828769063117187277312 , 130023764770875532110592 , 220291694228111109983488 , 368926529763199650094848 , 610968258798985899873792 , 1000913337618738610167296 , 1622659524314551096952832 , 2604101477750496065394688 , 4138351221416196283717120 , 6514309814604145536428544 , 10160322039410023356676608 , 15705978029662039779783168 , 24068875402219465797821184 , 36575434072256849529651456 , 55127798792061843682394624 , 82432634169971960709906432 , 122312406974391608227860544 , 180125788636438860845679552 , 263331362714125186302656112 , 382238193033583883010653616 , 550998347753498690070627732 , 788910573105678966028740684 , 1122121406784754767065327460 , 1585830587098788535893667164 , 2227132172811503138533997436 , 3108651872640471614560404132 , 4313175278403730812077924892 , 5949501545610408485831717700 , 8159803177352261242998028248 , 11128825408283909096421462120 , 15095318822176087488865941432 , 20366166516254659628197949448 , 27333742795657228588140717768 , 36497123860282015259141565624 , 48487862478441738377747026872 , 64101137321386457307871389288 , 84333193449588884120241444948 , 110426101355049529846060574028 , 143920977740917898882011102692 , 186720928144120779567330718620 , 241165089305769996618444572796 , 310115261750565489118702948836 , 397056730552602396804510243516 , 506214965172540853813741425828 , 642689969264469609901021578816 , 812610104052193035656209014528 , 1023307239200392079869697572608 , 1283515071745056042037309226496 , 1603592407955364589461518726400 , 1995773093168323064579185393152 , 2474444123789535675336367775232 , 3056453236436086620628924018176 , 3761446983891906494231684386560 , 4612239905524632839054802339072 , 5635214955401612292804974499072 , 6860754756016349973716222362368 , 8323702625886120125098849407744 , 10063851519189208346667373245696 , 12126458219190523195035086150400 , 14562779091453775332405390774528 , 17430622753959214089786580267008 , 20794913763509573150124277002240 , 24728260366921162413073458235392 , 29311517916272318102593699110912 , 34634338477824597290085517219584 , 40795695567121851500949581232384 , 47904371993958319469239554260736 , 56079397111579813610078434884864 , 65450419105099117303926287790336 , 76157996270907698206497644947200 , 88353791068677590531544836140800 , 102200649119570932220925451296000 , 117872545943380676929183062720000 , 135554382724581252103799602598400 , 155441614076574615999174536121600 , 177739689485679657593319575136000 , 202663293103275691990270595558400 , 230435365412123337143666259936000 , 261285895063307936118377456064000 , 295450467919578570480640948108800 , 333168567177154466593481038977600 , 374681617061608245822679760068800 , 420230771569222905649291554744000 , 470054447730571249433140960104000 , 524385614786021750947367533680000 , 583448846964559460402892341097600 , 647457162595472468511857329315200 , 716608666869409460649848604163200 , 791083033272969198460200999892800 , 871037850268461261441920684760000 , 956604882017830982182500258820800 , 1047886277633195589609026386075200 , 1144950790486501101585628065139200 , 1247830049670404796022436640403200 , 1356514955701732507550738214931200 , 1470952245809658907474789507257600 , 1591041312168770659459464207475200 , 1716631315748879378996989667980800 , 1847518685391233237114727179712000 , 1983445041363171189511995983577600 , 2124095633107438453823540331590400 , 2269098317764820055358162034668800 , 2418023172433551917721016529030400 , 2570382743429887199102291856480000 , 2725633019983166206638378987744000 , 2883175117498836538372984372358400 , 3042357741570654880829627150304000 , 3202480386289476773972477622892800 , 3362797337967683122992458885452800 , 3522522390131975968346441150131200 , 3680834327387736213399618206592000 , 3836883061757736092902888758758400 , 3989796449106089254452357628051200 , 4138687628467495848435651954336000 , 4282662925745912433886663001184000 , 4420830098543601969688662654854400 , 4552306957880560805120482872326400 , 4676230143926789735857541391302400 , 4791764050145871553066400905824000 , 4898109642043962351141772212153600 , 4994513228012640143352500101363200 , 5080274844153972757281330796454400 , 5154756326356374818284110590476800 , 5217388792748855825320209333081600 , 5267679552490084495743483683654400 , 5305218156421525317253091960966400 , 5329681748582620643504370666835200 , 5340839310366883078940088952723200 , 5338555011475473335170238089286400 , 5322790412133541248251204829676800 , 5293605607581418794430326740217600 , 5251159080004003425411500771539200 , 5195706618869465752542096831283200 , 5127598847062091756624431358361600 , 5047277773076906440302201717964800 , 4955272217082835892460816471244800 , 4852192256779688132437168662528000 , 4738722576237246621903717242880000 , 4615615288223479799496346591641600 , 4483681664849617148913796326604800 , 4343783452038291196005458514739200 , 4196823713849285733242205963878400 , 4043737254240943166576648422195200 , 3885480683930090327298612454195200 , 3723022827605845352251758503116800 , 3557334750742162509058538145792000 , 3389380153745697088039901222092800 , 3220106290556159387582065701273600 , 3050435091930016374169859885875200 , 2881254792129503331367846353715200 , 2713412744622388740850679900160000 , 2547708369925918057139614788403200 , 2384887127622441900565991701708800 , 2225635837351569815781928144896000 , 2070578290743138144705363718963200 , 1920271900833196180806734069760000 , 1775205978483917740686150861619200 , 1635800167532345536806405363302400 , 1502403919042959096479735286988800 , 1375297583164260968454950279577600 , 1254693430811319902485154202009600 , 1140737612516934782155704376934400 , 1033513685477928347848669417881600 , 933045597233290648763529121382400 , 839301405319610141994429603840000 , 752198631982870188407063592960000 , 671608374604951365580607078400000 , 597360011395243100693061058560000 , 529247409652823781096550195200000 , 467033491056708634673485946880000 , 410455089548572360381861847040000 , 359229160855342852066634342400000 , 313056900862228453382232883200000 , 271628300029594782473303408640000 , 234627633868550445124008099840000 , 201736741591067856273316823040000 , 172638239271973922336210657280000 , 147020523378579678000642416640000 , 124579540316148972122970316800000 , 105020777395608027428107100160000 , 88063014190318752985119498240000 , 73439014668939919654566912000000 , 60896150282203791339183759360000 , 50199227822487103613578321920000 , 41129541177522160700543754240000 , 33485092442287372376745615360000 , 27082150127807268922310615040000 , 21753524204052966360672215040000 , 17347759835468260226448752640000 , 13730595362076504400431022080000 , 10782448134692335234054225920000 , 8396939855209912287475138560000 , 6482117335614471160287068160000 , 4957989725572291442235801600000 , 3754869662500077723921285120000 , 2814137835456464170877583360000 , 2085790800055253390186250240000 , 1527108703923347855415705600000 , 1103772678710514426717143040000 , 786877001083252217606307840000 , 552084567620517078657269760000 , 380894819197275135684771840000 , 258076887735126265911705600000 , 171082242977424639958056960000 , 110613654978301693588930560000 , 69766288295300479867944960000 , 42520336270304178709463040000 , 24904914850799045939036160000 , 14051976286407141178736640000 , 7176921424683464982528000000 , 3459354787261055434752000000 , 1643321774867955646464000000 , 437763136697395052544000000 , 1 , 32 , 558 , 6940 , 68502 , 567920 , 4095058 , 26291268 , 152836946 , 814626856 , 4019929166 , 18508014204 , 80003628102 , 326383621968 , 1262178757866 , 4644257727524 , 16312714132700 , 54851473092200 , 177010783528754 , 549468788857012 , 1644016684960242 , 4750056000564176 , 13275901509547158 , 35949233846353132 , 94452875485008686 , 241123013062746616 , 598854763712858778 , 1448747049604102964 , 3417835990791493330 , 7871724818212496112 , 17717241126392021038 , 39008024015653795500 , 84090255976586693027 , 177644883917706565464 , 368075386005239504056 , 748584616020295144832 , 1495513280713479251168 , 2936927262471160851328 , 5673379950371543501568 , 10787313467031696687360 , 20200868420431660225152 , 37278721158253448891904 , 67830062279606776166656 , 121752397178943285935104 , 215694610842762782887936 , 377319365317487709339136 , 652046091020751202892288 , 1113598598955849967684608 , 1880325286107194894599168 , 3140186751682051709583360 , 5188626327713621304829184 , 8485402577508621827089408 , 13739067604147044142713344 , 22031382332742093186567168 , 34998911182381432035644160 , 55095774909659583765341184 , 85970628192454683979488768 , 133003085884779342649661440 , 204060955313044100298720768 , 310560869300344633416498176 , 468942657339383264618085632 , 702703749478564275989712128 , 1045186173416293809409157696 , 1543367777653952834919212160 , 2262984218828138359275195600 , 3295402504767792385104124656 , 4766784717765568315302715284 , 6850226705038752512998400544 , 9781736743471491498065545224 , 13881139590510961818473660976 , 19579259443350899614867488288 , 27453058604161603493945899392 , 38270796705145383268508505720 , 53049736558657961990539443360 , 73129469132408351360237869716 , 100264569995191684050988831872 , 136741047951096728225527523184 , 185521909157643830735145831264 , 250428156254433121742428790592 , 336362670633656802388098223296 , 449585713665884183854813324128 , 598052213074575350534021354928 , 791822614171490156665924924572 , 1043560826203515209609742081504 , 1369134749500589225110730976648 , 1788336927589247705638449135216 , 2325745152690972633236044557792 , 3011745159665638937088578109504 , 3883740102837690128351721082584 , 4987573936899456218248357972416 , 6379198553380056131398567110588 , 8126616850595618470614230179968 , 10312136656321994715560286614400 , 13034972307907298123421071275008 , 16414233236609538941347287062016 , 20592339854666346080424837494784 , 25738909147575056779117572432384 , 32055151710669189325615785222144 , 39778823415468910795410057235200 , 49189771696076961048113930293248 , 60616117124197462507441716513792 , 74441103997683405047969245621248 , 91110653718563601304744161312000 , 111141642439603516471271057479680 , 135130924490488061504809325506560 , 163765103305430597975217902223360 , 197831052998498608306928768480256 , 238227163539968874552725772269568 , 285975287978750257537240547332608 , 342233325539215221640964977880064 , 408308388553293334659048696724224 , 485670436441011228712100890134528 , 575966290165502146227181837992960 , 681033847406120520478028511390720 , 802916376516194191025968424464128 , 943876633649613404410166353367040 , 1106410650102804791644445330625024 , 1293260844962483969809761424281600 , 1507428291185585080523333625369600 , 1752183686603705837457087695001600 , 2031076861620037573156289236684800 , 2347944255796626004535156527488000 , 2706914235077526679303189627468800 , 3112409543255968904007743815142400 , 3569146854160726603839023834572800 , 4082132553412770681779800951776000 , 4656654887952224485798753849689600 , 5298271410826230067800447171724800 , 6012792135448005096982754866267200 , 6806257069917302362090323367545600 , 7684908962002875926203432285670400 , 8655159583604009953518395878137600 , 9723550983146886164381642540289600 , 10896709570180728380880764310086400 , 12181295289673183995948579554937600 , 13583943103059118188916846109337600 , 15111200163489170805763318021521600 , 16769454989945770341048069888825600 , 18564863534675621308952883686534400 , 20503267176135828654349194774470400 , 22590109509243699777555298951800000 , 24830345190777321456578092762252800 , 27228350301841353264312341155392000 , 29787825025296762999347137500979200 , 32511701449886751688189780262016000 , 35402043967430318364411526865126400 , 38459959364769375297650478858374400 , 41685499589385386140873264364083200 , 45077579817589996406884280169676800 , 48633888810581499460312622288102400 , 52350821230360551419960555545324800 , 56223401091968091123718701117696000 , 60245234920115965363583260255104000 , 64408453653403261809079803928166400 , 68703693206098340161368071459251200 , 73120059661321431009221306440550400 , 77645143273270783026137942296512000 , 82265010818753951459970987149798400 , 86964258234556755711419306925024000 , 91726032416243334298174715198515200 , 96532126470742723093441418551603200 , 101363031402415120890134971744435200 , 106198076190362547049353076812076800 , 111015507632453206370749182834892800 , 115792675693877751953676241084531200 , 120506137021265873530814328184012800 , 125131884189438506039957889889920000 , 129645465929390050394444366494003200 , 134022256601962827985928202425241600 , 138237583832382234687154788161664000 , 142267033054810396996518549107923200 , 146086570373045533656828134438246400 , 149672875989416967369933447094272000 , 153003448514106286920924997625164800 , 156056959490714327319744360499257600 , 158813324472687317180481978855475200 , 161254071172648420690847600453760000 , 163362360766360256764240223986790400 , 165123363459313196882329588582579200 , 166524214229443865656988386770585600 , 167554389278191528351776145679424000 , 168205582159944568042554267384268800 , 168472077713735048835004261917792000 , 168350533756348211208676270131609600 , 167840353038771772374066501161779200 , 166943359294833055842040351157452800 , 165664167757807795532330770074009600 , 164009748829002023350425236388249600 , 161989803109283078492649701056512000 , 159616204431165801884781873119232000 , 156903391346371215369612122286489600 , 153867687117163627511219357815603200 , 150527716792062555536533592333107200 , 146903607876290833486188750141849600 , 143017448766943331192392396114329600 , 138892368522235144218832517971968000 , 134553058497883613938763580475392000 , 130024736852538694464892843529011200 , 125333746106349448654685928765849600 , 120506414897509802539312006530662400 , 115569750948093915965446534491340800 , 110550199631461790249296125694771200 , 105474458210299508570483021325926400 , 100368139886179158032619210576691200 , 95256714878606144591050929164697600 , 90164097305566312884278928157900800 , 85113727674978923116452586849075200 , 80127076176959064518247454428364800 , 75224888155065551651782928068608000 , 70425610922183142720749380308172800 , 65746791487462918146821453721600000 , 61203446148188785366053324796723200 , 56809613306904146580311616301056000 , 52576648485643484038038470123520000 , 48514947095429999559801278034739200 , 44632170259633100477026333237248000 , 40935103132341916240825753604505600 , 37427836614973965762726839500800000 , 34113752296381694256444136857600000 , 30993631290841470186274773073920000 , 28067776734195124587185017651200000 , 25334056646330399317179704770560000 , 22790108722371438348798861680640000 , 20431354498092072297554892226560000 , 18253268717488785594628070031360000 , 16249327608217515136705297612800000 , 14413359338036043244776396103680000 , 12737441157111058782230756720640000 , 11214255460757929120112874946560000 , 9834991363067089053297367941120000 , 8591691311627063870530335006720000 , 7475110847033996007642827980800000 , 6477085239622051207343076311040000 , 5588370572690222180224485949440000 , 4800941380711626559637011660800000 , 4105892074933215298100920320000000 , 3495651913175863970107256832000000 , 2961892074857951369251015557120000 , 2497705835127166941375626035200000 , 2095550229149052179592161525760000 , 1749294926338293995804528394240000 , 1452286072260074402100046725120000 , 1199266612580749295115120107520000 , 984490875869158616834376990720000 , 803578344066391147748077731840000 , 651712977033709174449713971200000 , 525322941688461060816418897920000 , 420466949717586030244410163200000 , 334345357217129848812766494720000 , 263780552526849144964086497280000 , 206647013195254905514237624320000 , 160467612656753897441934704640000 , 123658906987198526778261504000000 , 94333243104650309190250659840000 , 71378966569558220849538662400000 , 53368504808795042087420559360000 , 39552922020159451932864675840000 , 28902536597353116238927626240000 , 20917660392505055175589232640000 , 14873628224854547988078919680000 , 10477764558924662781485383680000 , 7207181421504949587935232000000 , 4912466921222829337726156800000 , 3247012913771131771237171200000 , 2125584051214343951634923520000 , 1328343597959723354161152000000 , 830059890015220392850882560000 , 476710375765441418625024000000 , 277846210847133370810368000000 , 142806543249503342297088000000 , 76333236949355538087936000000 , 27141314475238493257728000000 , 14446183511014036733952000000 , 1 , 33 , 592 , 7564 , 76624 , 651480 , 4814916 , 31671996 , 188578368 , 1029248760 , 5200002180 , 24508415596 , 108442411848 , 452823611008 , 1792339167924 , 6750084512588 , 24266814263682 , 83516348514010 , 275856724576084 , 876457152168628 , 2684098331635856 , 7937657515688696 , 22706537074783052 , 62929686970642356 , 169215117868119672 , 442071353117410848 , 1123489627814593676 , 2780932666764229412 , 6711947499857803976 , 15812796111468874544 , 36400871083511297212 , 81955127163777621572 , 180633690656200393797 , 390082688779027342445 , 826053116274166157388 , 1716693411594904461872 , 3503756942475799813264 , 7028107407696515988224 , 13864277491081334091008 , 26914546096725518423808 , 51448225877264715204608 , 96893931182245418350080 , 179888053919394179963392 , 329391583965127569702144 , 595169561186360965488128 , 1061670984536982743601152 , 1870480387391251268155136 , 3256220640258438616781824 , 5603333766748952160957184 , 9534924947848314360679168 , 16050344289682559706814464 , 26736120099666569477237760 , 44086230540635864967101952 , 71983842734720710591524352 , 116419354175198338370913792 , 186551231376361001226285568 , 296259911826138597565379328 , 466405050813029776797448960 , 728078020166340890920624128 , 1127251710482079881660276736 , 1731377174526744076519369984 , 2638672655182285207764258048 , 3991109113505415135938322688 , 5992435028450541381412971776 , 8933023650927559658353584448 , 13223894665126073920685801280 , 19442991749125005805764266928 , 28397726998362829708607382768 , 41208979566991852383031060452 , 59423215063653991408337961156 , 85161240230467626512833794048 , 121314401421844371552098170560 , 171801865217740401722346054552 , 241906088274986821381738172568 , 338707809460983879055880301744 , 471647013355558015674391638576 , 653242470488354863074109338684 , 900009820914131577753123839388 , 1233626917314206655976495320576 , 1682405476731264083649353679168 , 2283140220661924118437549163472 , 3083420829722899831456460647248 , 4144508439252512077128190879440 , 5544897282264876779697791106960 , 7384703692908851354259691762716 , 9791049225294715911607749066300 , 12924632352604342388135626965312 , 16987714239989311945095217328640 , 22233778621264501547435618585688 , 28979163888686343950082155332056 , 37617007235104387574597687155920 , 48633885910430737702413817291344 , 62629589357018129859922927320516 , 80340507717928235091238858079076 , 102667176802796734997800558425792 , 130706576170586355472223822327808 , 165789835215969456377533208037888 , 209526060562857027003737618906112 , 263853056214061451141835168721152 , 331095763516789832980397286767616 , 414033300612276946121585421421056 , 515975527309563136633304450207232 , 640850101023996155914174599123456 , 793301017788872858805653460137472 , 978799649846110985977862034776832 , 1203769291208595115876305025137408 , 1475724206834170055270586073875456 , 1803424140169290061565073471839232 , 2197045172468903396139060629209344 , 2668367732150469248185583891646720 , 3230982432756459766366192554223104 , 3900514254781271448678261296970240 , 4694865396585096807662473766269440 , 5634476875249295119311652970872320 , 6742608687985403398878282339615744 , 8045638008732053500802926538778624 , 9573374538857574783302099384100096 , 11359391696482483291274052470601984 , 13441371888845179258893151813914624 , 15861463579115912592246205662068736 , 18666647343728623569848467666127616 , 21909107491954449857039796969081600 , 25646605250492445449111560865664000 , 29942848814931876011553463436236800 , 34867854981648482912843219567424000 , 40498296323676333102700984897574400 , 46917827312062860515025867331872000 , 54217382021307398025197805542688000 , 62495435588029825192015479751584000 , 71858220854694293999531811288729600 , 82419891332654843301965960178316800 , 94302620961153546359912060996985600 , 107636631094744154710106233647009600 , 122560134625102371866979543847656000 , 139219187463737312911372938084105600 , 157767437242065126054021694539696000 , 178365759881982887382837333515467200 , 201181774523987088070408406447121600 , 226389228650097641723859885774604800 , 254167245287481512750097955557888000 , 284699426222143210658726460734539200 , 318172805329584947060584361057515200 , 354776648975126677647217649486390400 , 394701100725550606508429837592566400 , 438135671251857912151840409725531200 , 485267574590547578578718118949377600 , 536279916538744548796124795916460800 , 591349740877924881329353291849728000 , 650645944795488369686953264978982400 , 714327074331906041342593588682380800 , 782539017200134927564384201701772800 , 855412609020591915183876731834227200 , 933061176744650463097196611128288000 , 1015578040085910850642447590407980800 , 1103034000884920230476686345868620800 , 1195474845725240355859928025735244800 , 1292918896947158922027397685234976000 , 1395354640560958477451095780010630400 , 1502738471069530081559581160013350400 , 1614992582672188160816339421200755200 , 1732003050041985209447360618540582400 , 1853618128096156722698780443047436800 , 1979646814457437919769184887299865600 , 2109857701103100988198225057457971200 , 2243978159029446280528295566610745600 , 2381693875428614659371092348599737600 , 2522648784544305739686011687862528000 , 2666445404470316640906911259686553600 , 2812645614102896162401951577442681600 , 2960771871676346369676432174049862400 , 3110308904232102141703618326028569600 , 3260705852734517984315042701294387200 , 3411378894510741526122885583753382400 , 3561714315178220930824463645801664000 , 3711072038052062151541558729523059200 , 3858789567228560110379338350869030400 , 4004186347523623237648028835051974400 , 4146568473560085132695594257135276800 , 4285233744208581711116230071546240000 , 4419476983964915774233235105950540800 , 4548595611297306314472016754899411200 , 4671895361970449380651781693779872000 , 4788696152886812828770006561215168000 , 4898337966654356554274796688030118400 , 5000186745191849128801901148703219200 , 5093640175632107865391383945587366400 , 5178133340494829164425396544626585600 , 5253144112480113610896736294415769600 , 5318198293305109014023275279097913600 , 5372874345878628981916895073470880000 , 5416807738812965358978171136407552000 , 5449694778800665621251952584602419200 , 5471295928776668327051713765294080000 , 5481438501709435642572314960496230400 , 5480018785262246815979409322023321600 , 5467003441021459931635827550420992000 , 5442430270093561064570311172837376000 , 5406408250874034708148264901608243200 , 5359116893338520795389022676158054400 , 5300804844251490942007844787265536000 , 5231787881277427077625778669200588800 , 5152446148349793998640110656223232000 , 5063220817632010851839011920693657600 , 4964610132293231385784668450366259200 , 4857164906737626843006993806547763200 , 4741483488754633976648668809008332800 , 4618206391063677182394954849482342400 , 4488010437005773494698914699884134400 , 4351602682802754524714856672920371200 , 4209714127390812167600234779491532800 , 4063093256007762127671595971745382400 , 3912499482991999656455394141710745600 , 3758696742543511207881557893013913600 , 3602447016072216592085778883612262400 , 3444504105328496253289776408367104000 , 3285607691547794263167938693822054400 , 3126477606626332726079334780712550400 , 2967808467787741198505332893221683200 , 2810264894423489877683044824487526400 , 2654476976918436513002881619698483200 , 2501036337760886659328896987013529600 , 2350492840567771644637040988491366400 , 2203351692149281624627408216082841600 , 2060071131473864226645156013820313600 , 1921060912476834039614441761754726400 , 1786681085790279289855054969409126400 , 1657241440952290599460606761000960000 , 1533001694061599810490455787110400000 , 1414171892815614497812640757719040000 , 1300913401753395542015491050086400000 , 1193340622835611427459624402780160000 , 1091522722593437809722728301035520000 , 995485844902169195329618805760000000 , 905215959495050843449502767226880000 , 820661533634905699729111382753280000 , 741736550521505278861063819591680000 , 668324010012455761708553212354560000 , 600279093884040674433889176576000000 , 537432490319654751235125673328640000 , 479594182060719010948709420236800000 , 426556554733253690808294714531840000 , 378097666981741858878729746472960000 , 333984856270200139965797769461760000 , 293977529382792646915770575831040000 , 257829914208718625757292875202560000 , 225294280706051394110734026424320000 , 196123044200490456581690860584960000 , 170070968548815548693049977978880000 , 146897596090820164612126921850880000 , 126368699140407913604377526108160000 , 108257701410242501588018591662080000 , 92347473374740127722526001561600000 , 78430926462434063552230749020160000 , 66311731501196811090153322291200000 , 55805491711486934261136400711680000 , 46739720898604326229762855403520000 , 38953796606871745488436055900160000 , 32299705274406062244850966855680000 , 26641429812374250957457324769280000 , 21854550753452042710513597808640000 , 17826512706271690597629402808320000 , 14455632856963562643680357253120000 , 11650512540893320135605607464960000 , 9330067410939673074303719178240000 , 7422274029178063831050377625600000 , 5863474303319537783925046640640000 , 4598371913891643994600199946240000 , 3578780178525868382981546311680000 , 2762743317046924022607825469440000 , 2114661220690219540106373365760000 , 1604117451149885860377270681600000 , 1205130701363353277391470592000000 , 896180770396068891681421393920000 , 659231513167861643535634268160000 , 479132510696327168569064816640000 , 343871136597706996608616366080000 , 243478496624285154819810263040000 , 169707918449908681256125071360000 , 116344109825040683844013916160000 , 78348256305142389453949501440000 , 51632117148405993306445578240000 , 33193660022015910282657792000000 , 20821451191620397026508800000000 , 12623214688923887592800256000000 , 7356351300349562503888896000000 , 4130515786320523742478336000000 , 2099949766737404067053568000000 , 1007730740677403410956288000000 , 476724055863463212220416000000 , 126513546505547170185216000000 , 1 , 34 , 627 , 8224 , 85440 , 744480 , 5635892 , 37957128 , 231322416 , 1291965336 , 6678229740 , 32199103056 , 145733160288 , 622432259936 , 2519825416620 , 9705945789592 , 35687530781666 , 125617606782924 , 424365201422194 , 1379005414781376 , 4319298911339736 , 13064248187162560 , 38222045355030252 , 108337382846414136 , 297923506940122408 , 795935047242907416 , 2068445609824375884 , 5235023023925074832 , 12917731198829718000 , 31110414719564525280 , 73200144805585168340 , 168429099496551932840 , 379326475717845243333 , 836897828434096060770 , 1810293986130880277219 , 3842199958532229405504 , 8007286163461615555480 , 16397209790855582103008 , 33015930894951232302048 , 65406619747917585701248 , 127563518734445783551360 , 245068287356599996477440 , 464024152988070971000960 , 866387787158708871351808 , 1595940706845310509940992 , 2901736011096872662189568 , 5209906502623634821404672 , 9240972628968340454231040 , 16199334996328863638033408 , 28076057677780221604159488 , 48127611969214282641044736 , 81625173111325427375223296 , 137015868074299728509969664 , 227705360181788283783595008 , 374769020285684386909852416 , 611038566410481460763345408 , 987208582787654559148983552 , 1580884441255475275477349376 , 2509878770221912229920579072 , 3951596011767401003798286336 , 6171074011422374451205860352 , 9561243405850056110982599680 , 14700304391381509039903840512 , 22432914724005567414038265344 , 33984270734201901146874402304 , 51119319323628226657820607744 , 76363482757876147784967042368 , 113306682626267335613432388864 , 167019453217325720052043846416 , 244618952820780376400703090480 , 356034222406146837514922905572 , 515034718097600014971119827416 , 740604699315407196805458806892 , 1058769369290247961297665777120 , 1505007794417502955479212529720 , 2127423802335746557879537552656 , 2990890736530787788743135142152 , 4182440789856076125261796149552 , 5818236619051889138860812673020 , 8052544232243196705584707442760 , 11089224324759703518795723683940 , 15196377056672318730368744723904 , 20724916022756621321189466097872 , 28132014163325006042585428254048 , 38010561731446718707836799102848 , 51126007911255471726205344839952 , 68462228334842824066645485454812 , 91278374442220653308241525058536 , 121179023512246386208286168129460 , 160200363620561747701260668402016 , 210915623252211649755405691319352 , 276563492481089570148997660281744 , 361203890975010496532306142245736 , 469906115518118247391777411632528 , 608975158942133554730655216559428 , 786222824011169140741711673556216 , 1011291178462027433061319897852284 , 1296036888655872917579557080331008 , 1654986058768755364319491079023488 , 2105870344865205861822841334177280 , 2670256359045608910874210266944256 , 3374281643808176987824557627369984 , 4249511869900469461841106544285440 , 5333935242110274943234184115583488 , 6673111545627203832286742204123904 , 8321494570644137238678887884035072 , 10343948097354361881496773323622912 , 12817476765032222615698319932440576 , 15833194483720619028070201071181824 , 19498553833062274804597009796176896 , 23939860988731790587576102768818432 , 29305100890837406581194211667891712 , 35767098083249291033764663398564096 , 43527037883317877029370522145057792 , 52818372739288634767596910031692032 , 63911136500893113608101639409229312 , 77116688915828837512115824884893952 , 92792908648309227067672072724330496 , 111349852090142768436798894424172544 , 133255888686937310371612337604040704 , 159044322027453451861533393943577088 , 189320496055220048979268627042295808 , 224769384278146902364180937135993088 , 266163645592370904554312401125431808 , 314372129697792900820426789278745344 , 370368795121192004681522221463116800 , 435242004530426584602969955320518400 , 510204134570621745668577182735731200 , 596601443773111369050443616399187200 , 695924104683712065244995227576140800 , 809816320873921738563046174391481600 , 940086398722868808396279967490572800 , 1088716671770215590203550749684524800 , 1257873106396244080396530399098976000 , 1449914466401877001699667418454656000 , 1667400819721213427920530498146976000 , 1913101250721642656193112302288513600 , 2190000511956795042688311589888060800 , 2501304475391100662152375413660686400 , 2850444063971173701587621976707289600 , 3241077536619420519705666425845300800 , 3677090750707435797747971703879964800 , 4162595311457031626848993660405761600 , 4701924170692724238663210745630060800 , 5299624652412806350607301681195921600 , 5960448398219517825257423529680400000 , 6689338319859244786637307018450360000 , 7491411969905944226231873048537164800 , 8371941580393323710375570275390737600 , 9336330078426400145128158440947766400 , 10390083557274482550091839404995608000 , 11538779377284085523081141109093235200 , 12788030686580488311093771525284832000 , 14143446351445138649865629942877619200 , 15610587497817776617344764183347852800 , 17194919397933551832499505879578521600 , 18901760437098290159001325691502105600 , 20736226534191498185786649335663539200 , 22703173436231985355574663059409952000 , 24807134755508039351387752690096473600 , 27052259036107480683051731514050131200 , 29442243022799312746809409295790720000 , 31980265507284804799773499946625004800 , 34668917970601116299734108932586790400 , 37510137764945222996200023744503788800 , 40505138764121765225252016903847219200 , 43654346928572418384717237637707648000 , 46957334010045916393369077764166604800 , 50412758956605349301804926819547174400 , 54018308001319611442413960531265689600 , 57770645639483123654773641944569171200 , 61665364568844371341967125232899238400 , 65696950068575730344382129889805280000 , 69858743197127671300115044237785984000 , 74142922325550674931553390896877459200 , 78540482699844856886434874763385152000 , 83041238582761774926416989432384800000 , 87633821785821396701800752520996377600 , 92305707326546354780518419373608307200 , 97043232788931273388266751814222438400 , 101831649693694114125012083656357939200 , 106655164537173596602487988132431232000 , 111497017160058712098873182051307552000 , 116339543193454076030650926758342438400 , 121164279592175910458351613958102790400 , 125952046931215510152109738732465689600 , 130683081170348291753836380216935020800 , 135337132792335525046468394666557478400 , 139893622711171557690671730993607430400 , 144331753945324390114529026292448153600 , 148630688351824413117616893564582988800 , 152769665259312379505804205618816153600 , 156728194848219091773774294432274752000 , 160486176861247362841850412192563174400 , 164024105733882117576815623747944480000 , 167323181760904877309370059607392294400 , 170365522378190877541988458022937081600 , 173134257621762933199367218292716339200 , 175613742061977154873193266060999065600 , 177789625820539467111194132014143897600 , 179649062000918319933564453737496576000 , 181180744979247175267824390668692684800 , 182375108364484921878337347927377510400 , 183224322933930378094568109115642675200 , 183722481622701011300249293439068569600 , 183865549730137393126358960315700019200 , 183651534986831702580010240222285824000 , 183080384475989973655685999735763763200 , 182154138598712761735422522983395737600 , 180876770877798660963748596620414976000 , 179254327255554567309204896813419315200 , 177294705443104672847685508500131020800 , 175007783237107146587582062947622502400 , 172405136820214723611287290266995097600 , 169500162101702236804780663938744729600 , 166307733541536511507892372342587392000 , 162844325631374732053316724982608691200 , 159127613266806763849146076225811251200 , 155176602547999921308608553934081228800 , 151011176895827420763736943541338112000 , 146652244731050162462092639607386521600 , 142121237340719553999091700158269849600 , 137440283998017950299306118105214566400 , 132631664729930889984329922416472883200 , 127718024713338261018610207430914867200 , 122721788317737222803664199646827315200 , 117665419782842934522166054756196352000 , 112570806238132789955943598759118438400 , 107459574612765117050079290314414080000 , 102352445146551637811677450153085337600 , 97269614916308080479121371167759155200 , 92230087493101986714680899650728755200 , 87252124698288036575574620740791091200 , 82352559121233663954232262284067635200 , 77547319730487154965774558962512281600 , 72850724147235580630068778438901760000 , 68276084374866426969550023517593600000 , 63834981791620046078187625260810240000 , 59537945959885290732354340267991040000 , 55393718041442455786289511458979840000 , 51410002352818043349821821110312960000 , 47592709494945262464984071252705280000 , 43946782468861163603475513242787840000 , 40475421064985599068541443687628800000 , 37180966600118548335617017626746880000 , 34064113550216976109282361647104000000 , 31124848302722017437663893145477120000 , 28361635192950581650254641967513600000 , 25772409193534540056872055773798400000 , 23353738939580551106538571512053760000 , 21101849777898711820090442776043520000 , 19011774546845555609108682282516480000 , 17078400606369513822655430495232000000 , 15295592839597966453654607486976000000 , 13657266835878038906509251416064000000 , 12156490462824406138557927478394880000 , 10786554979810731159790625571962880000 , 9540072150325944698929626912522240000 , 8410038161678355308771983226388480000 , 7388910152135006224478986694983680000 , 6469670091706933078553900396544000000 , 5644891446388632047138124893552640000 , 4907770967962444250243185017200640000 , 4251210405491474656657799639777280000 , 3668814963661112765168358540533760000 , 3153970252247263423013216853688320000 , 2700822043132816231147569457397760000 , 2303362500913484673014274006712320000 , 1956356004786757715680546713108480000 , 1654465985700482662784186917847040000 , 1393128105962028335983149347635200000 , 1167695127009178303306177558609920000 , 974277770820324026179511632527360000 , 808921018521795955843761643192320000 , 668377641712590228367956474593280000 , 549348019708070358872130484961280000 , 449192534343492829729296519659520000 , 365204853412861968307538256199680000 , 295288323107179815442442112860160000 , 237276749799786008552543284101120000 , 189536220106349961894701179207680000 , 150367152321017539882996220559360000 , 118538228619899758503610765148160000 , 92733812604760411278696256634880000 , 72051698245111928931811772989440000 , 55502673265189568518399009751040000 , 42437680714662944029580055674880000 , 32127884197624971287141312102400000 , 24130735856858741102339421634560000 , 17912795962343919646019042672640000 , 13183236753744078887693852344320000 , 9568451786399571433871266283520000 , 6879820581762215869342372331520000 , 4861117813032663031388590571520000 , 3403543393554944120853060648960000 , 2327366102000134225205919744000000 , 1577309867493862391191830528000000 , 1036827946647160810824794112000000 , 675129576685455849783361536000000 , 419749713726095590633635840000000 , 260997718332891995239809024000000 , 149183548302558470376259584000000 , 86552338572125462813736960000000 , 44291123118495641836191744000000 , 23575733726838210554757120000000 , 8349894069366113232224256000000 , 4427974127694150956482560000000 , 1 , 35 , 663 , 8921 , 94988 , 847688 , 6568888 , 45268120 , 282195928 , 1611807816 , 8518705272 , 41990050584 , 194271053056 , 848122413936 , 3509405214176 , 13816095023520 , 51920864504762 , 186789055042798 , 644935028526278 , 2141992751548682 , 6857107977218240 , 21197558053027160 , 63384635223712904 , 183614975790244280 , 516036602346992768 , 1408900322767479872 , 3741526063803239600 , 9675966217696350784 , 24394725809477566480 , 60021411507991622944 , 144262645144777775408 , 339036048092473495696 , 779774081214972040557 , 1756670849977123786471 , 3879365359857374174715 , 8404520062778191904069 , 17875758167509411079076 , 37352322569031688941392 , 76729122588764929705264 , 155048126095184974059520 , 308388100489371468611072 , 604090760720922697036032 , 1166049836526050983442688 , 2219054385023263626188800 , 4165523223266955404945408 , 7716611669510566442711296 , 14113484073883945168329472 , 25496361866594107817354752 , 45513032617343145450239488 , 80311158904519168980024064 , 140139240341796352488293632 , 241902963744404708525136640 , 413206383673464898628466688 , 698678681129752654223371264 , 1169786430427704176951988736 , 1939913423825249634886070784 , 3187331679539389023827654912 , 5189893743487304886842197760 , 8376991924592707469585062656 , 13406750124424741485613615360 , 21279801389769209737716776704 , 33505710335810484286130867456 , 52344589459139985483885953280 , 81155344257240504618695950080 , 124894063617459026685124954624 , 190822386330577400826513608192 , 289507557857141880750574373632 , 436225053019557606653997882112 , 652913252527137628964580894016 , 970880466935853834512143163328 , 1434531041156966334930549922032 , 2106463633515583944490986959664 , 3074406355343338952280674860980 , 4460596813504158537943375492284 , 6434398209148870078876902305436 , 9229175219203497416087469650772 , 13164747148983349222987298842728 , 18677104863304153832120682511416 , 26357539065949218860504836897608 , 37003900486414128129932477064120 , 51687420884380469295324742743036 , 71839394893460233139318982055188 , 99363088494918936981075212395092 , 136777537121060089808192467150524 , 187401467335083071264886175732080 , 255587468781989052265243636742544 , 347018812235775556909585962881760 , 469084016107622708332690505911488 , 631347476154039650614631034036780 , 846138266436567152703545168275044 , 1129283676964478397888735688300356 , 1501019264142199093043376894379212 , 1987113251644723189654364436651432 , 2620250133431982373462675626037368 , 3441726407060384236724128159677672 , 4503520614524181045490094961057624 , 5870810407116911835144765705684516 , 7625021291672137403179842068694732 , 9867505175852588769718874389507020 , 12723961910957805735176178728800548 , 16349733839119994118977311081251648 , 20936121961687173108196484768649216 , 26717892838833888891648559015289856 , 33982167730966116697110814219374336 , 43078909838817010624682663657290752 , 54433251735599624933089442146155264 , 68559933186439954929965665250055936 , 86080149344777198105401701350236416 , 107741140694968176772834008703654656 , 134438888739273791086671546717529344 , 167244315099948758068422579285647616 , 207433415870132160452162548933718784 , 256521797391820197975399528376287744 , 316304113328549479409301292083402240 , 388898935538828345290502739400283136 , 476799621643834461693761232951659520 , 582931769883553991324550534491596032 , 710717875210584192161293126932268800 , 864149819201734897166243390384249088 , 1047869838028211973115217221919911680 , 1267260617271579012958868003391337728 , 1528545156800909520812833368370130688 , 1838897033597595490814815303509011712 , 2206561661341751537078060118695148288 , 2640989104042471849239112810950672384 , 3152978941679004969789511239898306560 , 3754837611575407884541461140122707456 , 4460548552885977199379502696039817728 , 5285955368401853204278250989791549696 , 6248958078201790896336056315309280000 , 7369722382384188795176195884134624000 , 8670901661865682582484086182153504000 , 10177871241397950769032880830824313600 , 11918974198893544761606045323262316800 , 13925777751897495462737024163871564800 , 16233338959660922710957611679301299200 , 18880478180476013921949185921838086400 , 21910058382070575371040361094051596800 , 25369268065943587874121153955553164800 , 29309905182577664586721284119462630400 , 33788659051861691514917747399515656000 , 38867386889244916813621562427629016000 , 44613381168852366053597299257997800000 , 51099623627686230763030040706019262400 , 58405021364478814778450170326967272000 , 66614620068800714207945487660475953600 , 75819789114695815593407687865174196800 , 86118372870948897872863540363052529600 , 97614802366232653265428011947091537600 , 110420161128155781602109282095226388800 , 124652198932004808250227660954033547200 , 140435286970080374526110948046202420800 , 157900308042318586978848261907797201600 , 177184475267935158554065116596020814400 , 198431073130236781473601037832951115200 , 221789114707054945216851372004550683200 , 247412909522947446376944197818424832000 , 275461536659513673616367719003756243200 , 306098218647440641897481342568725280000 , 339489592029694687572915759038562912000 , 375804871720071651728090791876460275200 , 415214906779462905185815837240903180800 , 457891126849203054062069706167254579200 , 504004379087298662204582793875305420800 , 553723657441448546033209199056678560000 , 607214726757008276272315921526595091200 , 664638646604322324628009318285355040000 , 726150200296704250104467798153592441600 , 791896237368697916701681478877259372800 , 862013938210626042769283848311434668800 , 936629012675990139534511435787899910400 , 1015853844628130599565378757256818528000 , 1099785597874312376194966369820395238400 , 1188504298513463251839281520412237747200 , 1282070912592398711744720727931762137600 , 1380525436870932984448276241772763737600 , 1483885024548025436796746419299706118400 , 1592142165891189737577717929661298348800 , 1705262948094842057865161824257289132800 , 1823185415447371124754260809957266873600 , 1945818055744805536364493545927131872000 , 2073038434307118193447366068006623289600 , 2204692001884481685531344656486319520000 , 2340591096779122153266798581863342483200 , 2480514166989035998606954161123242918400 , 2624205229915568389107503320444536460800 , 2771373593628743630544642060142126156800 , 2921693853499057019991769054893946598400 , 3074806184595627367331135203691206713600 , 3230316938366920795031336179951540243200 , 3387799559993814945296990130609142790400 , 3546795827496915400373450067961717804800 , 3706817423846910479832551980170237984000 , 3867347835716189548749094873084339296000 , 4027844583038637131519152963629672940800 , 4187741764508239283023281525009796780800 , 4346452917428842298880913510647010022400 , 4503374166309876711392031350842132915200 , 4657887652545246476118765506321978611200 , 4809365211233828724141100199843064614400 , 4957172279477055499533168658174818336000 , 5100671993778500285053471950824008032000 , 5239229457344783378449487744248727212800 , 5372216123840534990401502372480524089600 , 5499014275720223146911015606596091494400 , 5619021538974599371317065934288600268800 , 5731655406472830932587217363376254976000 , 5836357707895554395772726079143004569600 , 5932599001970700678737808418583784652800 , 6019882820123465622582989509375313510400 , 6097749741792809084251173557723937177600 , 6165781233893488204574914772612584243200 , 6223603232307732449571960851641164595200 , 6270889401747243398073143990561343897600 , 6307364065300191166797304284220054732800 , 6332804733205585778048836309056113049600 , 6347044235651327190459453888822358425600 , 6349972402999347221322680714786492006400 , 6341537295347621935274717991385724928000 , 6321745937221750984868827594690539110400 , 6290664583726129925874546106802613043200 , 6248418463362317864856482177202102681600 , 6195191043808673944253681889753262080000 , 6131222790414822287239836163492701388800 , 6056809452580833829117070602276375756800 , 5972299866013580944859742261553048780800 , 5878093338251149057322325294040178688000 , 5774636581883976188994056783236620288000 , 5662420286801452205594183808161613004800 , 5541975329739746144827887187886470348800 , 5413868678428536244743097777596524544000 , 5278699010423202339408507515516531097600 , 5137092146651143142587249510630067404800 , 4989696268020542929470881220219548467200 , 4837177037875006232110711997514267033600 , 4680212645768426454854056957350204211200 , 4519488826839278294245793988489487564800 , 4355693896777886313546257488707702374400 , 4189513909122916873008700335704333107200 , 4021627883214789128283321686536466841600 , 3852703239601328634134958649722206208000 , 3683391455209035613469720742110973542400 , 3514323952790287844048700968936532787200 , 3346108272598494595400604546209689190400 , 3179324621282467294040872067255255040000 , 3014522698062881700113896810440253440000 , 2852218924969932946614362955910225920000 , 2692894088569025470672770950490808320000 , 2536991334729305053705816277743411200000 , 2384914575593763544630358293737431040000 , 2237027367975936325813780690673295360000 , 2093652102494180860012320098766888960000 , 1955069632372234716135750274165186560000 , 1821519335963765685295289488386908160000 , 1693199458537935481027900146427453440000 , 1570267828508355777960913264926105600000 , 1452842974422914163205277740475473920000 , 1341005428943399425929164849810350080000 , 1234799333498650788267025113077391360000 , 1134234369482130330095956656057016320000 , 1039287761488331362999800395705180160000 , 949906504584698427167493833782272000000 , 866009820362704098701784816292945920000 , 787491567808977480335622942884536320000 , 714222776093393593758947285109473280000 , 646054350826016566886406755182018560000 , 582819581640207482539525893363793920000 , 524336715039717196828785935616245760000 , 470411597567879274100548922164264960000 , 420840065266696998009430476340838400000 , 375410283525642888604715699325173760000 , 333905139168726742364333448294727680000 , 296104265002469352232098753926307840000 , 261786016804393731924420835154780160000 , 230729437768465675924508294926295040000 , 202715818998543086483623207038197760000 , 177530162408445658929398648063262720000 , 154962699418190740204551920002007040000 , 134809894710559950674594743186882560000 , 116875409508230017814624764790046720000 , 100971103389594306459466194858147840000 , 86917560640136533382586525133701120000 , 74544554773916263728081188406558720000 , 63691603403176463034717997681213440000 , 54208033111156299901137337862062080000 , 45953081503949073100118131078594560000 , 38796060747708132265670125124321280000 , 32616093658158874611318724181360640000 , 27301864535233899225754374350438400000 , 22751593853101776808562312260485120000 , 18872504854720854717504484408688640000 , 15580373106542513651846268343418880000 , 12799334172390598040221326624030720000 , 10461249876094455512726289479761920000 , 8505149886209047625599738169917440000 , 6876980470324864707194401281146880000 , 5528877481044108163698749970186240000 , 4418670912102600507722960053862400000 , 3509589535959488444860420767744000000 , 2769568959069154189292296657305600000 , 2170766477022853696215335876689920000 , 1689370649798653010777449365504000000 , 1304961430116397758299687367475200000 , 1000062005739955831910571104010240000 , 760032949875459705668430774927360000 , 572551340538573737854652134195200000 , 427248622783895635463345696931840000 , 315641778940424412877043592069120000 , 230711677189826017460720857251840000 , 166651083747778531603247529984000000 , 118892235130263303554667773952000000 , 83696089774430374590657724416000000 , 58011479392741067403520966656000000 , 39554942098941442032526098432000000 , 26497593815366860565840068608000000 , 17373656307779337781284765696000000 , 11114676462858397955156606976000000 , 6938929634924595198283481088000000 , 4187570810255999397242339328000000 , 2429644506693996689951293440000000 , 1358443364353111365116755968000000 , 687854152350659964297019392000000 , 328808707367917095311376384000000 , 154979094469295283476889600000000 , 40990389067797283140009984000000 , 1 , 36 , 700 , 9656 , 105307 , 961912 , 7625652 , 53738944 , 342470612 , 1999200448 , 10797070364 , 54375864336 , 257009524972 , 1146166279536 , 4844481799308 , 19480879691168 , 74776536204126 , 274770469263784 , 969008420283108 , 3287165715074848 , 10748198656197274 , 33936695606904736 , 103645982895343684 , 306657766768526272 , 880222595299469860 , 2454384718121477728 , 6656420159336511028 , 17578821217957265328 , 45254641863334308124 , 113686245859461084560 , 278963499982466134596 , 669241834215229638560 , 1571074040013019082825 , 3612029016209929189780 , 8139404824577129535248 , 17990799786484488849000 , 39033623605418244073091 , 83187375662118807739368 , 174257635884102986700856 , 359016578285813684802368 , 727922780328227783829856 , 1453289151100269343380352 , 2858584117696238318852352 , 5542523114876281907498752 , 10598309155392765054601856 , 19996003681822736200430592 , 37241139858219744233950976 , 68495566534082802917666816 , 124462861704497878158110720 , 223524389197050003500870144 , 396899158354020119975070464 , 697044642757095561064162304 , 1211195599432580612327124992 , 2082969065929424815967141888 , 3546513058819411015720217600 , 5979983535560088155179627520 , 9988539449464816708918795776 , 16532029377374842936942047232 , 27119776708371694831294475520 , 44105285274401766825691594752 , 71128565858421439350960955904 , 113774877883508154186157913088 , 180548365013460639234705913600 , 284300535730784909972753267712 , 444311074121110417433933581312 , 689297734945553649584929903616 , 1061740560324079185131557185024 , 1624053147842635766272417246208 , 2467332947465664546530888805632 , 3723690042468868347895202525440 , 5583510746973075523266856021568 , 8319485649951657144953616221568 , 12319855750852162173559268867664 , 18134148308427767932832156995440 , 26535740209336831978535651987508 , 38606968631741528078832753442512 , 55854290342465053764807569326704 , 80363275286109204491496087877584 , 115006133748864964512780706357476 , 163718173219476542457172531973472 , 231864247939650327244853541754560 , 326722125488234449789045266812784 , 458117020282876667509964791312260 , 639250653561765719789426129992944 , 887779474084628031039526117677312 , 1227210559178410548983160795267216 , 1688700737941863188207480773623540 , 2313365243869625114440383538321728 , 3155227423709315923498671307811664 , 4284971508219381485427636882119376 , 5794697128101019793828450026446492 , 7803918176269302708912806025522096 , 10467100990093639943397143728291824 , 13983098963488930304110676558372976 , 18606914133912018145841614445627820 , 24664302616040845388275252878437472 , 32569841871240816865963153091344416 , 42849195571748217260646532194642000 , 56166448542503332718055476681716140 , 73357542007500133850494850469029520 , 95471020872507588916989693822461856 , 123817512163375024284038820851982384 , 160029590235461268575571729666499644 , 206133951873423433116261868516771200 , 264638126707153498328789016639331200 , 338634286674337081731686088841878528 , 431923097106035015725184639622988032 , 549160971100554588621830852006937600 , 696034553855655131910244039688515584 , 879466771488270098134837850953236480 , 1107859337167282425696853391797161216 , 1391377208277645339235176988978283520 , 1742281142822095818405969557196936192 , 2175315195552944508200194068746161152 , 2708156741592300404106890808070580736 , 3361937388796614696460461515303451648 , 4161843968117496858332323763647076352 , 5137809624143988174872514981383012352 , 6325305913649493538935334650159766272 , 7766247675600282900322502882567755776 , 9510023343010047161180172243969729024 , 11614664190079308749400804727676888064 , 14148166885022512362206894335888271616 , 17189984432010983984397644343368905728 , 20832701365884261281681308213528662528 , 25183909563238882560795350261203160064 , 30368301635759576236034372579893031424 , 36529999026685150914855368282081774592 , 43835132263615263210451773940618093056 , 52474690467388097241634507088329168896 , 62667657183354543038133353855227578624 , 74664448541788948853398341108248825856 , 88750669266924516785294652359194596864 , 105251200053919914393179746290352051200 , 124534628829436194602052617945447596800 , 147018035195557916958210284217348019200 , 173172135824235841527000798155224934400 , 203526793817248025990433176648148556800 , 238676893055874646513349268660802848000 , 279288571899561976891855119321304704000 , 326105808344740804118641392831381849600 , 379957339726482829112944598002133318400 , 441763897928381359084195471157365728000 , 512545729124096082082800969121156608000 , 593430365735906259389811173326060660800 , 685660602742256295684914999614155820800 , 790602630919168518818784776883075926400 , 909754259515154892508118919136028697600 , 1044753164593753953266507985987720643200 , 1197385073426752746075310461451763846400 , 1369591804453447730521278889670815344000 , 1563479048994709300592768058263151859200 , 1781323798402702014178067240084372908800 , 2025581277115585525497753315544841030400 , 2298891271973253960604128442704884361600 , 2604083691699229431499229006492008550400 , 2944183238137710386962122511327497609600 , 3322412996417211328672097105924572569600 , 3742196823947647352823028333928249097600 , 4207160319120026680796760742876176192000 , 4721130257922424849292852197129418347200 , 5288132253917398514209073098000987737600 , 5912386551440189641633030787720515276800 , 6598301682827841648188529025300106419200 , 7350465938427839627704800977696321587200 , 8173636355616975366927600794923902873600 , 9072725235847397038972385387995855276800 , 10052783869957385634997791296628001536000 , 11118983567009591697963970237923276864000 , 12276593636422370013456619505196459340800 , 13530956536302873083687039689973256710400 , 14887459798143074054648674321428573926400 , 16351505095261954975652092833206030246400 , 17928474010328643899133907732995243187200 , 19623691066852558862766660663269002713600 , 21442383500496468815880280111826402380800 , 23389638583696513411767694087269099225600 , 25470357863154109202842509919013325158400 , 27689209431226065112346666465106824812800 , 30050577423734727687204351211212965990400 , 32558510241452171969488028469000742156800 , 35216666449978186845464051103174633600000 , 38028260314626164594570736282125017209600 , 40996005592611890394345099779117462707200 , 44122060095347331918653030335278986342400 , 47407969191510759778802403104903724979200 , 50854611434779365671016318277623246912000 , 54462143880601990158383289050613168614400 , 58229951090787633041993180024649877017600 , 62156594589234892598677949966859177369600 , 66239767752205155663397386607464896812800 , 70476251863796462602132284058054530508800 , 74861879508776749828232921166290154355200 , 79391499712182118646682689735997839078400 , 84058952447781319111994742406227449683200 , 88857045252857819734262280000344204928000 , 93777541328686748025384959298483081715200 , 98811149792999730226776256413725299584000 , 103947529588961269311879947195653523520000 , 109175295158474958244773651330026221132800 , 114482037981840363382663754888105589465600 , 119854348953305350876787544924250750003200 , 125277858836839020614526649078301505312000 , 130737277996917477081632316310080578457600 , 136216456429739937755052411692098444224000 , 141698440744038788939856309660723817574400 , 147165553713620927287897047925650934214400 , 152599467597564450527710855538273049369600 , 157981302358001966869833589972677225446400 , 163291713557942069513792561424809224627200 , 168511007615560159293964719554188577068800 , 173619241616204752878280612118409198796800 , 178596353224677595625526937762950163660800 , 183422268951538258213811407419337949184000 , 188077045599994132634359639605361282252800 , 192540982812488916086391807029693762764800 , 196794772389682412683268099969360606822400 , 200819610265006483768328118217467686092800 , 204597349645571066863959506019679386009600 , 208110607179581890660562668058416142745600 , 211342915542819532466471498006156469043200 , 214278818370907242636827066116187637350400 , 216904017983144916537479086955697409228800 , 219205453504709637184442714860317032448000 , 221171439701956261676834346911100551577600 , 222791723044395270433060552950523222425600 , 224057607905986965286992909178172972236800 , 224961985848244479482949499735812882432000 , 225499446265799004827049956422666034380800 , 225666274592122464916489625322788383948800 , 225460545462213681807876945031232318668800 , 224882086582905601080636421985810438553600 , 223932553200809163070867925169584626483200 , 222615355517338862587973598543350366208000 , 220935714660886810116298783265305878528000 , 218900552186108217559436926229683342540800 , 216518529142612414063963434269203244236800 , 213799897658431532827400908424691002572800 , 210756525339372916641345477588671653478400 , 207401710283190605340087414950097587404800 , 203750194603668297778138320128939054284800 , 199817944508428964934226611871762037145600 , 195622158064075749597328969347696461414400 , 191181013417869377918760839967167722291200 , 186513675763722373997119173881859972710400 , 181640017906104461884190502046376126054400 , 176580632685958742739778186853476712448000 , 171356529357072576309535020571249822924800 , 165989158542532612169842491365985814118400 , 160500089044728641467670538709791188582400 , 154911050905607028719102262231752100249600 , 149243597922114209182194245221926823526400 , 143519175245570815272720543980675453337600 , 137758770699182564384178885684288798720000 , 131983013631584439169020001315185500160000 , 126211819124538718493345195007206522880000 , 120464521585673419054394708275714867200000 , 114759516305447202501028508675510108160000 , 109114432083092328793068014703834808320000 , 103545770824336043228086805374583930880000 , 98069123554145029090848931898417971200000 , 92698810079469718401293516356348477440000 , 87448137883131152037945223122080071680000 , 82329044487075257387834802805762129920000 , 77352400024159893809615475861255782400000 , 72527649705554090704497361704536801280000 , 67863161409546540486730658236938731520000 , 63365868118146543506185473433645056000000 , 59041655326433225077754743720373944320000 , 54895004738511771177544683078483148800000 , 50929419162543038852204826018434580480000 , 47147061996508710253490153795110993920000 , 43549218773853930679876361575880048640000 , 40135931245139070476481814849002209280000 , 36906486557552430204774366135843840000000 , 33859047669262469206107891300844830720000 , 30991165887673368337925800317819617280000 , 28299400674124141062407381860809768960000 , 25779854440835536343205142418011176960000 , 23427781282265277802212702482999869440000 , 21238132630163456397658326806680289280000 , 19205158750046316411168946183328563200000 , 17322961221057030992631995558297149440000 , 15585079964876587446617642586482442240000 , 13985052846917445044844802293269790720000 , 12515990015334960726013075599358525440000 , 11171128114860628742339953298400829440000 , 9943399356194495904947914602408837120000 , 8825977388271651124339379464938455040000 , 7811834056619181923485395766573793280000 , 6894280343475448849963591781017190400000 , 6066514849778752959342674593673379840000 , 5322146765752814551473041262833172480000 , 4654746841311930757165757157078466560000 , 4058351396251885983088443120884121600000 , 3527008640196818841632478811898511360000 , 3055269890329994903699220889839206400000 , 2637737039550529946496600311298785280000 , 2269527487263467689884115631375646720000 , 1945835986692141735447477093185617920000 , 1662374010359066908779678762819256320000 , 1414937123881691247425105937526947840000 , 1199828237090038182553429760960102400000 , 1013436427419106199712433151693291520000 , 852629393293233485290933973389148160000 , 714358631672886364158081544224768000000 , 596022837143485640883262695486259200000 , 495088591039585745620747931568046080000 , 409435569213615011495159437397852160000 , 336997678065871063436203204804608000000 , 276076055632815550369230756167024640000 , 225014150665321168856445352626094080000 , 182481498485653567367602128202629120000 , 147169152917827234710719296454000640000 , 118056430726807378746868086496296960000 , 94130972819708118864205870761246720000 , 74623071836016313676467102018437120000 , 58763690948018888041217893135810560000 , 45989666266304923786957625795543040000 , 35723852149823702369167339935498240000 , 27564755724899788272114387501711360000 , 21090503240711965541654611246448640000 , 16019858733485718075643876524687360000 , 12050346677128352222478354874368000000 , 8994374277114142509963801919488000000 , 6636211525358912760460389384192000000 , 4855222615200223687865363791872000000 , 3503788442848876762306701950976000000 , 2505276979425177274208334643200000000 , 1760644378906545700590505426944000000 , 1226286543591628936083483328512000000 , 834301669667018161462607609856000000 , 562648456048231514135907532800000000 , 368092741256234149065655320576000000 , 238579119924377484685505200128000000 , 147672039744169704738835660800000000 , 91425720931936292129961148416000000 , 52041600382149839550028972032000000 , 30072016977275551258685472768000000 , 15329393402984139517002252288000000 , 8129633984899955608931794944000000 , 2869327234745809819800698880000000 , 1516644395508499476180369408000000 , 1 , 37 , 738 , 10430 , 116437 , 1088001 , 8818820 , 63517016 , 413577336 , 2466132168 , 13602224168 , 69950429976 , 337571046896 , 1536948560944 , 6631759668936 , 27223360983512 , 106669041151154 , 400106552375994 , 1440328341421644 , 4987483388201684 , 16646371759085730 , 53650665335075034 , 167253724982215584 , 505113289649791224 , 1479890034665977536 , 4211807498169054816 , 11658377097217262184 , 31422193962580892696 , 82552881794973066968 , 211625158089889679352 , 529858454695319546840 , 1296900238625163570856 , 3105877119147284355141 , 7283692658299308183545 , 16739801021773975197506 , 37731677977156400118846 , 83469909927621274574529 , 181350373993383416227325 , 387217421551157378564412 , 813035814268800242428208 , 1679736046843349072660176 , 3416611163153280955326720 , 6845554987236676839554816 , 13517774383956185626116608 , 26320845879044210604536832 , 50558902806811951077240320 , 95850505907697858602938624 , 179422620391116697964954880 , 331760511060720474154442496 , 606188434147417640336391936 , 1094937299379308939118286080 , 1955804832630923420452372992 , 3455935485071875653768734976 , 6042995791269735478224426240 , 10459768267544197948097800704 , 17926918712001546884213236224 , 30431839970912108703915124992 , 51181103242138423659349974272 , 85303104226472861423619586048 , 140930155186674950242550000640 , 230851422801260132355473838080 , 375017948613087859995053514752 , 604309877258348315943033944064 , 966159584881695565883504212992 , 1532883985400052842835422140160 , 2413943833164883411323892270848 , 3773856313419015851397093092864 , 5858191768013733113233447310848 , 9031055371111773964077997551360 , 13828781527337662381740746842880 , 21036372933476751812440469168384 , 31795654483925530168236170372352 , 47757387949856368697839791254848 , 71293968928250108651550585282624 , 105795139189689113542293084442416 , 156076823843878617130532962175856 , 228943286924835913853809996984068 , 333955975814250452198586262398132 , 484479552797924292264650158609848 , 699097761332742454735030091813304 , 1003520272846465448916427346316300 , 1433138144898845912925766003019964 , 2036432003508478024617556452057120 , 2879495995622163176446142155796448 , 4052014923517488965614559376842388 , 5675125374023310635746288204451268 , 7911708424170410247643722492164520 , 10979806822850909834144532372551400 , 15170039584014959708385230169854076 , 20868108983480293937404034686243884 , 28583767635648428535825568320588528 , 38987946722359391294374475286674160 , 52960152320301062054768889718824012 , 71648728766471684580663489394671324 , 96547181869304551094924108748953736 , 129590468583538945223981212062888456 , 173276014175634104645856714560365668 , 230815236329725555730678159798439156 , 306322564573045026276327293106081024 , 405050372500798745496539679275163072 , 533679922754403129660774811047711516 , 700680397239985110725330896887275436 , 916750388263132399339017526691615256 , 1195358904289963996389596428400221272 , 1553406045248658837472786261887478740 , 2012027078342264651285793414152384484 , 2597567752070750235698900468340338880 , 3342763381979452570029936535821566976 , 4288159588819296330944545498671414528 , 5483818631678296765568770820686669056 , 6991362121774868756682230943883323648 , 8886408592084762350538439580110856192 , 11261473001133828835349905472287676160 , 14229404828006863778370318569088842496 , 17927452032859983746245362226939464192 , 22522049864572888422517749682837049856 , 28214446346311029310677972702105315072 , 35247290292436184927416779027115564800 , 43912322938074536608780215634902372864 , 54559330695350087980704807009117408768 , 67606534189122250070117828132878141440 , 83552607522317689738592986076423058432 , 102990541636210672686730424397510292992 , 126623586550856537121879238677912586752 , 155283529101842298746768356478710713600 , 189951585331136210564510672366276756736 , 231782209785477050541666783689495720448 , 282130147313732868676169308751688417792 , 342581076309285404754221405110009635072 , 414986215264024661251820546292538299648 , 501501286693508956300009670667373725696 , 604630253338152859666987338644465384448 , 727274260693306808720353208823518223360 , 872786236548445668838687136884335820800 , 1045031611946427972520852828434684705792 , 1248455637739831600968021121967395799040 , 1488157776375013389875801975436528965376 , 1769973648315989109239108489389119072000 , 2100565006392841222021670663424524736000 , 2487518197612840860367523340340595750400 , 2939451550613641237676513546706001862400 , 3466132095816727730150307860739256185600 , 4078601984898574392515964092627809593600 , 4789314923735756357415343182452330937600 , 5612282869625854451882215264753247232000 , 6563233165930151548675859755061036025600 , 7659776197503761954526585751585378118400 , 8921583543991026220902410161937867481600 , 10370576488993385306811671253897804744000 , 12031124605569009764751178156449929140800 , 13930253988355894245711748372894785177600 , 16097864532347109434928248619037196409600 , 18566955476836564112067679594265457504000 , 21373858230226903888556322912683528390400 , 24558475280240249318438052436189451462400 , 28164523760963579587862137411307915769600 , 32239782011474796607487795849459897750400 , 36836337202055284118308853868229238524800 , 42010831848868444298477582553422000563200 , 47824706760924730082776782647827968000000 , 54344437699722558531787205330451940972800 , 61641762747046937805880306534025982297600 , 69793897118006076524578833271949044108800 , 78883731876780682918352923987833007046400 , 89000012776299405819355579611231371016000 , 100237495184304173642108373971457489076800 , 112697070864008940435796345315707464505600 , 126485862158124046126961078367931440652800 , 141717278994803561144506662714223222963200 , 158511033973179453930494253957458486092800 , 176993110745229862426795575663393026956800 , 197295680827023764069135899720684622246400 , 219556964045930090470442666024723590636800 , 243921027843608041157253983285676827270400 , 270537520866033870296724883345723257868800 , 299561336397267541312657437317237817254400 , 331152201568409381056466927649534897158400 , 365474188519180420680264113305315230240000 , 402695144247080015593244209511155222732800 , 442986036253377007655918946491945567769600 , 486520211846301946227628233116736089779200 , 533472569459413116264743052487661405798400 , 584018641302409384493170089878175942374400 , 638333587260623299005502172068092007680000 , 696591101127537988558298773165925878291200 , 758962230937324407187259697821160350841600 , 825614116523321323398688508271901890393600 , 896708648153274815258990838168263496691200 , 972401051641627533186576991134926141587200 , 1052838406034550421199825508312559473427200 , 1138158101678931237379411125378181821888000 , 1228486247107468310719318705975519391347200 , 1323936034996573474862324295129601761792000 , 1424606077917723410004495816624894283238400 , 1530578726538136408408494666888640084032000 , 1641918383098100729262273697149459387686400 , 1758669825001171403537376970156331684716800 , 1880856553186456654138239562526632930617600 , 2008479181935260348761154919796894788057600 , 2141513886149414099644313360563149777984000 , 2279910924153533234940201158181708343276800 , 2423593252801835307676751202275435516217600 , 2572455253700349908562912399679074336230400 , 2726361587442705001655076440266973406105600 , 2885146194658479300812868700742294233420800 , 3048611460017304192935902924691195351193600 , 3216527557311773311325467624871702108236800 , 3388631990028728684462610068492617848422400 , 3564629343932328742908844871591574329798400 , 3744191263606224708564579939225141656620800 , 3926956666904569147014146243814531942412800 , 4112532205762658448567208652529787650700800 , 4300492984227099300993284856470466215520000 , 4490383537623418784776142942259875169888000 , 4681719079757702008324204554210178724774400 , 4873987017204154380584129362462036896268800 , 5066648732781905039969351252662864744531200 , 5259141631604039563635925309032128384620800 , 5450881447227945492266785167668230232064000 , 5641264794855915485293061221275042629222400 , 5829671964086644261882263970372868734156800 , 6015469932454306095644976821426593709260800 , 6198015586804312141702792144337783183769600 , 6376659127712811177090816208233965248512000 , 6550747640143802698741735599538397658316800 , 6719628799186647762276448764667814006784000 , 6882654690287133524938526917846928626483200 , 7039185708788431594606282551607462389350400 , 7188594514278350965963297679936649705062400 , 7330270000706307585047937345682893159628800 , 7463621257313844172712723293756570302873600 , 7588081477106524618546874662603557214617600 , 7703111787763346484371959558767461620531200 , 7808204961982702043606062384659508547174400 , 7902888981399751200356435195426768348774400 , 7986730411288295496589399552455572865024000 , 8059337565224472588543319800768780863078400 , 8120363415829655555696701363654335661670400 , 8169508235355113022776437846857644652134400 , 8206521928183824289228374512211992619417600 , 8231206041166499282562944762630374152192000 , 8243415418639278126579838664305865000140800 , 8243059499017729578720224366685787673395200 , 8230103220281117521918084700578306346188800 , 8204567539893638679394531723591810666905600 , 8166529548012427976076507475081961173401600 , 8116122181708375357897634106713500569600000 , 8053533526599481540061615850894150188236800 , 7979005729312756954183112417567817843916800 , 7892833505867412416818752065939541994291200 , 7795362279308711986856446240856959210291200 , 7686985946937611793539237153822155884134400 , 7568144308005398072466471670638044687155200 , 7439320160009730943643336648878548154368000 , 7301036113059105992462454700423564603392000 , 7153851121313201793281661804993073360896000 , 6998356789350591312372974164092506817331200 , 6835173471115917904074467855340192264192000 , 6664946205614320053568459248155913904128000 , 6488340512320417946223170457661973269708800 , 6306038111408136878346375991006796212224000 , 6118732570419807865069530202150523612774400 , 5927124947130414047060731534918121349120000 , 5731919451754209870476371493687944151040000 , 5533819168813580062193484069999972311040000 , 5333521865550407122271284281292537651200000 , 5131715951851922165239836273453847511040000 , 4929076579098914828597305089484408258560000 , 4726261944767786287868714150362759495680000 , 4523909821548153029692966129503624560640000 , 4322634326516451722748241821409299087360000 , 4123022951665229896098544441422198620160000 , 3925633906663795543510014483569210081280000 , 3730993735865505113753375026214588497920000 , 3539595262362664351690966324342835036160000 , 3351895865527716131081167909190182256640000 , 3168316069638464669677914890060293570560000 , 2989238460621554239213832220293082316800000 , 2815006958902343269244353941733269749760000 , 2645926379338164037575954119544985436160000 , 2482262315166647742914465639288069898240000 , 2324241347946355559331548677199612067840000 , 2172051515322589801156840535554956165120000 , 2025843053052532739114125754135428792320000 , 1885729425331846546124289585813813534720000 , 1751788545180282198850744635347509125120000 , 1624064216026937272838780877414768476160000 , 1502567797048890482039727188484016865280000 , 1387279981131299969273965499020939837440000 , 1278152726422800513612633972958241832960000 , 1175111342043038696173710135716724326400000 , 1078056606348033317688696134712710676480000 , 986866960121774373275789080482620743680000 , 901400792818326042557383762683753308160000 , 821498677863647654696462757160288174080000 , 746985619517403269357370170296093163520000 , 677673325241913869602576038515936010240000 , 613362365478613958156060747280341114880000 , 553844282164616096730476598522939310080000 , 498903688091983385615241369401040568320000 , 448320177161356474879347243638693560320000 , 401870164027370712471793693694680104960000 , 359328672273587604576238744443908259840000 , 320470905845647987005359187608500961280000 , 285073707874244826687097856998564823040000 , 252916976148808994023467303699462881280000 , 223784824432081208867982659403251712000000 , 197466643532187779872714379667457966080000 , 173758094466816197398699655090430935040000 , 152461870116687628442048363460012933120000 , 133388340644730754384975840068580147200000 , 116356176382781785857504366078449418240000 , 101192705965345884252364624822136340480000 , 87734211658349273086119401547110154240000 , 75826210642404678793962255198462935040000 , 65323498474331431833528587394349793280000 , 56090128938341853522842931585012203520000 , 47999444439938621748035492979989544960000 , 40933858795671706833363639848569405440000 , 34784636656907878703062141010718228480000 , 29451707890509825898574929905962188800000 , 24843298231575185476162237525461565440000 , 20875561117897488609249107344946626560000 , 17472290247035988041137728306264145920000 , 14564438239919255667491550715566489600000 , 12089681327397820030689438643281592320000 , 9992089819890597594543378353726423040000 , 8221623355512006348605980142359019520000 , 6733658640857039167779210190926643200000 , 5488678773012413931829619207755530240000 , 4451777085421061200844872166670336000000 , 3592227618974419299117901683558973440000 , 2883196641162640733928680054980608000000 , 2301290243160636232186463708223897600000 , 1826196158477951958622023374764769280000 , 1440446739876561111148892060201779200000 , 1129021493912468535417269138360893440000 , 879056944217303368770461649272832000000 , 679683658112608972265371138129920000000 , 521703053066263632141754975518720000000 , 397340040393374196852222534549504000000 , 300153350879677723485686235070464000000 , 224784465851577818656384817430528000000 , 166778864708159199701341565485056000000 , 122526019893174980690998009331712000000 , 89073029045047415321534202445824000000 , 64002260612273927904214734864384000000 , 45427252882151767666642208686080000000 , 31820532524277846349798415794176000000 , 21949194967198772906807563124736000000 , 14895966741790184946085222416384000000 , 9933405217688636699401223405568000000 , 6484332435001548727290565754880000000 , 4130611880472745676886761275392000000 , 2568085829161451452872681062400000000 , 1543604938323017600335519678464000000 , 892147847707178018070595633152000000 , 496949385620823967544144560128000000 , 250738209927715980967441072128000000 , 119445993743561283069989093376000000 , 56115842633814480618673668096000000 , 14797530453474819213543604224000000 , 1 , 38 , 777 , 11244 , 128419 , 1226846 , 10161959 , 74764168 , 497121432 , 3026344504 , 17038234992 , 89423643128 , 440376342888 , 2045863407304 , 9006917403752 , 37722353283320 , 150796356757306 , 577050832192884 , 2119238219197306 , 7486445427329520 , 25490996786365526 , 83813210550483348 , 266550494806575294 , 821208181435677000 , 2454407509945558296 , 7125697212756742008 , 20119807603601943864 , 55313395101175693448 , 148221433942101115984 , 387528257509678054152 , 989511832104088683120 , 2469766393506347928040 , 6030876212997268550141 , 14419458604201345188374 , 33783072973471139332213 , 77616327149620498599972 , 174992015784977245543375 , 387425562078943142625342 , 842837440993758862900163 , 1802822954606961757345872 , 3793782424034912200899352 , 7858631504707344879484064 , 16032856086606091110199136 , 32232079721290433755629952 , 63884189098777742994515328 , 124890908928449081669824512 , 240933078582778785533865088 , 458857055160430145896182272 , 863083518177947128250913024 , 1603961415524845565179405824 , 2946215652209749921562765568 , 5350833563712850999306249728 , 9612020629761259388312196864 , 17083935979005440791058386944 , 30052369945292167895454263808 , 52338206853256286110204259328 , 90268149836816111023217516544 , 154222189661675976002841369600 , 261078956130130276917205286656 , 438047164740017802573560602112 , 728619362788572941357176355072 , 1201749406702289544410232721408 , 1965888905771691463029640541952 , 3190292289522912922139266021888 , 5137115571858838242711616356096 , 8209429171706619629005636299776 , 13022531152691566565048598942720 , 20509144483471100631027190273024 , 32073563730789451150925582695424 , 49816059151813234662614232381440 , 76857487206746198241186715642624 , 117805945028976610610041679374848 , 179423565810065469846744786667520 , 271573660311766809707007274725632 , 408558300091467422004392693721920 , 610996625075237029039287807773184 , 908447894719734017699098932105360 , 1343054772892773762964746164062128 , 1974576897392789301253748184371076 , 2887309252675678075984434497205384 , 4199542873061086864966263413932692 , 6076437830601375338916555292348320 , 8747453945633617910267909550930852 , 12529840208144254930764832429262520 , 17860140634701861788440029152740740 , 25336258289549370277354427892442416 , 35773362546922528617822016631647140 , 50277866591802285301461602348285640 , 70344890449933838693151793332857940 , 97986117397887928243040498834544864 , 135896818345171187098513696058177892 , 187673143559320079241120279192770424 , 258093664309286310347286888562492356 , 353482707859312604278737544920227088 , 482177409284332337204793110435163180 , 655125769195700680752029799561063000 , 886649553594666457392398558658126876 , 1195413828636062129362075657401239520 , 1605654555439325415848966076265738188 , 2148727284557767444766232406905292392 , 2865053941836482475795734098105722156 , 3806561390899137061390035311156943888 , 5039725358292768306522165337168248108 , 6649356936810769249918297515915293784 , 8743296839936466532918504767106853628 , 11458215524722582938308845399476322464 , 14966755988039531452200987219695091948 , 19486301285592138130410625287613660008 , 25289701560833432285471416362522213372 , 32718356580232337839903860008087655936 , 42198120589544223579017486215072956288 , 54258577873474674407109600542252751360 , 69556331073436283735031813728815948032 , 88903051374981569660615303870102152704 , 113299161703155272031726757692125048832 , 143974162424702462993636754367627324416 , 182434765575590260816889755920427070976 , 230522179656026623076398577897585141760 , 290480084639576113143951046341855717120 , 365035057180612298954202287837521469952 , 457491451431477551033336695403623849728 , 571843012079694979955129297060856913920 , 712903795892368055334438620648894118144 , 886461305993615660097328668378845185536 , 1099455102515605375163408292359383742208 , 1360184542391075656357444002393873512448 , 1678549723943262301452006036687689851392 , 2066330164291925400842420323550358051840 , 2537506224934761676075117051020682802688 , 3108628814914893994324938019837664953344 , 3799243449825236200398707844119368093440 , 4632375314098227572335166527083325607424 , 5635082576172197069444820036513590113536 , 6839085817349760499903044244292730771456 , 8281482075791403247875128985434487110400 , 10005552638924728202585682409944783475200 , 12061674373892699556365648508090813060864 , 14508345006631939050516245293379644425216 , 17413333400362371183697611968597901182976 , 20854966451084811119212642614626724086784 , 24923564799991247678995934100801439478784 , 29723040018681484631174567391678703257600 , 35372666395799192639542406547815218195200 , 42009040727467655210365227336480561062400 , 49788243816139785029385655683000279878400 , 58888217386994268697015146040568047104000 , 69511370194711664199728464628834781696000 , 81887426725574637727161333317814402892800 , 96276531653579682391323155509120140748800 , 112972622349618396270450518566009675104000 , 132307081117531119339005316498869766643200 , 154652677344465604109844519755636733715200 , 180427808690321651041396948704305253057600 , 210101048177791144207875809516029383062400 , 244196002508298433304842428479560890820800 , 283296483723805698942509056222502148940800 , 328051994325621468445182650228008876972800 , 379183521633558856001440472961758892441600 , 437489634744173704492757401040754477619200 , 503852871798184523711768386307869506508800 , 579246402564203571707995774859072536425600 , 664740944153565374152475464970973716640000 , 761511904946846998350669605969401852368000 , 870846722819492902429811826723540411801600 , 994152361380388978657746783603243991392000 , 1132962916832232298751448793016523602208000 , 1288947286632478011065296639489114582464000 , 1463916837520588828806228646552496782291200 , 1659833010816337291596622688916800661844800 , 1878814786251761181683568142838797680662400 , 2123145928837145940115364710643694568305600 , 2395281922878662116777706740666788058790400 , 2697856504922370973255144518959499313440000 , 3033687682280851640607722228412904456704000 , 3405783137879160344920418670964481685619200 , 3817344890919304429060656240271671920409600 , 4271773105964544292420711590411324380966400 , 4772668903752021747548500278363193098163200 , 5323836062532447735204295726679144309702400 , 5929281448678904801452871330030247622540800 , 6593214067494250371222564978727113239788800 , 7320042560624567480456669965796128138598400 , 8114371050833879350588954669968982756934400 , 8980993150861653285623674887921361862976000 , 9924884056574771619428934257947122667411200 , 10951190534237275210597427360316264000537600 , 12065218753193014590540712954718729888256000 , 13272419769475962982937370541745996656972800 , 14578372656418457905631734739316511792896000 , 15988765085239042527340625573275336596480000 , 17509371412366820959546686050779125824966400 , 19146028074205968129518048395230350557248000 , 20904606424839435625536844453987662252000000 , 22790982813133176211513587659938099636531200 , 24811006133727162166423210886883566340230400 , 26970462638729316086646828744377696405491200 , 29275038366374407368390923494631405707257600 , 31730278953763693349325348132976302648729600 , 34341547336934109059087183329924551558796800 , 37113979070008420455996946171448995319884800 , 40052435941574808586900658537990452503667200 , 43161457561419895670959084398191866640870400 , 46445211802388273649413743831540936908844800 , 49907443679323115209983765614870493553497600 , 53551423791993124635382733873694256277510400 , 57379895780138140690972729182620523059251200 , 61395024199953072948847099076759680936339200 , 65598342080512446527695295535982447751232000 , 69990699899748780893774272232761453744531200 , 74572214977831375935045602665498765913472000 , 79342223413395373206926976565700524205644800 , 84299233213649434361795929319027055273907200 , 89440881195041654008167083673014820297984000 , 94763891852538373451212834360496723752550400 , 100264041306742624972227593149084760757369600 , 105936123945363897422515548825982331792294400 , 111773925497423910230472364915992861207571200 , 117770199426518252940319774600798385694336000 , 123916651126418838398822461079106797785478400 , 130203925897919388827608822469327640841536000 , 136621606081455908532403013772261071161747200 , 143158212208183388818174966231091357987635200 , 149801214608702660957062848837035236211808000 , 156537048992643022322401460006663782489305600 , 163351143708707983291838629962819536282515200 , 170227950575224002732524717218360634911948800 , 177150988520039199506907147198566396077670400 , 184102889978536041935364008642815193785958400 , 191065461117914964337289516202034838645145600 , 198019743549327846975417885833647561216819200 , 204946090773146635161731556733878350883225600 , 211824244327626380502049061945923491830169600 , 218633425494938692559502460150429618473369600 , 225352424375858128715998508863648119590092800 , 231959705281482624511061848447195490399846400 , 238433506598667660991835913510608415449088000 , 244751957718272362554729833403037620803174400 , 250893186947278069121954020624527642466713600 , 256835447305418462934771171200759235489792000 , 262557229219263031894295275645295660782387200 , 268037392055501023564118400992486445587251200 , 273255277906184869297327807411972201893888000 , 278190845403915438531780155366500555329945600 , 282824780563068817944565850559919327656345600 , 287138629233314080177540221259056874266624000 , 291114900798960179073028541814004455928627200 , 294737195538169892202128895133826246760038400 , 297990296976699021022431898164106238130585600 , 300860290550868676074675535337855882407526400 , 303334640500329731936525900125336078130380800 , 305402296530734684241040620472550847783321600 , 307053751460714297187160984333187155771392000 , 308281132948603541179679545175479933315891200 , 309078238596072406282381234602708727123968000 , 309440610425147859311547137880844036233216000 , 309365544649029282369574626297904019133235200 , 308852147337640679383213175710486486154035200 , 307901316828412004385591520949283459379200000 , 306515779714335676295437747778757879908352000 , 304700044719688573811657367713465753100288000 , 302460419090437250343999169193315624790835200 , 299804933458193224944520176020151743685427200 , 296743339687163082970794043555322424642355200 , 293287007204908465657178733074065113956352000 , 289448904060220622247277764316625762854502400 , 285243466124312847508725504454244987289600000 , 280686564072969601886358843384138805987737600 , 275795347388031283036513585562689097893478400 , 270588200843387482104717806651001555152486400 , 265084566060280600929519016946596815276441600 , 259304891384220587903065790775166452076953600 , 253270434441137834973327953072642066350080000 , 247003209956788502763674253334264979374080000 , 240525776749097598809106541720545107804160000 , 233861188518762429852354182098339419217920000 , 227032769188404724801542989367879577681920000 , 220064071295998633297285087847242772520960000 , 212978643860467916347220721800166652968960000 , 205800003238756130804456652704335598223360000 , 198551396948720424335607073647809886289920000 , 191255791863268030540303688851531950243840000 , 183935637519329351607633057107529605283840000 , 176612875297344098979420780000163598008320000 , 169308704679152243744478872528504395038720000 , 162043616953402487351543594445481252454400000 , 154837166377070321865425827001335151001600000 , 147708031665917244141409730988132400250880000 , 140673793990066901958290514960024270766080000 , 133751027554772039204480733738543577251840000 , 126955086195718630609687998885460601733120000 , 120300224241506357049434441765709441269760000 , 113799391394790166535698275668385610137600000 , 107464384833268934441375047969649893785600000 , 101305652291699412923816814349380704010240000 , 95332473834008362771022281986744476344320000 , 89552773218124301034464707138240052183040000 , 83973328081894489150737207367423191244800000 , 78599587116033461845337813945292697436160000 , 73435907623710564276937473626370216345600000 , 68485376937317401675350845159674840842240000 , 63750073358392165903326029954428025733120000 , 59230891002665914518246016459822876753920000 , 54927821195499008182862154709784067563520000 , 50839777047105084101659006284086185082880000 , 46964893274732240895051917885741105848320000 , 43300348582630678233386285466270967726080000 , 39842678464064677407190339682337413652480000 , 36587594993075937873894841345673092546560000 , 33530309244816560957170020192038295920640000 , 30665344563782612117911562658070914662400000 , 27986866908414648433553095363957930721280000 , 25488490487120047679897983360169221816320000 , 23163610152167014987324743016736642826240000 , 21005200553841251398102866084483563520000000 , 19006147766236090824156045844156400271360000 , 17159038672717207998891930554824363868160000 , 15456491405502755289525239713295851192320000 , 13890935275655364786245921714147729080320000 , 12454934459391399943468195929217972961280000 , 11140961619811785172993745099642649968640000 , 9941713249690459963621851114235776860160000 , 8849874328408520386517658446783340871680000 , 7858426575532922140335210981354942627840000 , 6960406090355265232520927123012989747200000 , 6149199219247234930081569861772889948160000 , 5418298184856810913311224628308634501120000 , 4761584089759595537902860070773709209600000 , 4173078203612907688929914052796219392000000 , 3647215066418708020856237765532073328640000 , 3178592132018296488597505316063060951040000 , 2762227848458489770675667762879838289920000 , 2393315885287983696426553996194333327360000 , 2067468533223340160995839811526138265600000 , 1780472763483277135154933626071975198720000 , 1528523032853703169843385373055301713920000 , 1307982213777872280006060256476557475840000 , 1115598369596410009278194940455955333120000 , 948277053128122272989051078501947146240000 , 803283038640362923719260110843299102720000 , 678020109582532021541957387334577029120000 , 570222780482395959484583474524198010880000 , 477745948965757455959932530841249382400000 , 398740675942956662777512098663998423040000 , 331460359469876116270321260646414417920000 , 274421564269823965932423167653663211520000 , 226221583844961286314208369898453729280000 , 185689697899044448082761122680128143360000 , 151717745534106732750455801319669104640000 , 123396051598546061823850491877879971840000 , 99862430429073366464112897146864271360000 , 80424242455977568172096891287578869760000 , 64419615736837641031554476759973888000000 , 51331135733808036000858884882497536000000 , 40660378160967671459064290522431488000000 , 32027037463110710204197081700696064000000 , 25062029227242724724521389913669632000000 , 19493439778100504882761006989901824000000 , 15051063363681064035587543043932160000000 , 11545204882890652735135256627576832000000 , 8782788353913113594525265075240960000000 , 6633790297998140778537517107314688000000 , 4962736140387936407815664770744320000000 , 3684413081766722429824587257610240000000 , 2704301448151645945506160082681856000000 , 1968529945934219416995752350580736000000 , 1413611070168659367739077100044288000000 , 1005922016255846283417897293316096000000 , 703647534775557906328764454797312000000 , 487870413696295957727236910481408000000 , 330462581513374347825245337944064000000 , 221908588617619901351144328265728000000 , 144573013682638463751796083916800000000 , 93327018660857419174269369188352000000 , 57540448677267287539638633234432000000 , 35488968625765830870883287171072000000 , 20127346782404228751106542403584000000 , 11589253691527393659458162786304000000 , 5887531562585859371965914021888000000 , 3112113309194373127838978015232000000 , 1095017253557136621802226712576000000 , 577103687685517949328200564736000000 , 1 , 39 , 817 , 12099 , 141295 , 1379381 , 11669611 , 87657665 , 594899060 , 3695536816 , 21226472432 , 113640459696 , 570794565560 , 2704378208280 , 12141472813256 , 51853218801544 , 211365057996074 , 824727260828822 , 3088318866645370 , 11123941666199678 , 38619491922881310 , 129468877481875610 , 419818546190629062 , 1318740879652966722 , 4018554831576632736 , 11894824966661158584 , 34241232124655873064 , 95969822020351715240 , 262164781735461008160 , 698717800990934636912 , 1818555159351153584304 , 4626325286618808877472 , 11513280236855655130541 , 28052107496350129970443 , 66968287366654132491725 , 156757599983763301904615 , 360037581849969060722971 , 811927984707071576113577 , 1798935216333315301883223 , 3918390326223691786016981 , 8395534645853799117148692 , 17704386858131278271825360 , 36765308489687686733277808 , 75221719106665277452038656 , 151708313063712183882618368 , 301745510381542648128634368 , 592151805734168772193548800 , 1147025939812724866684668416 , 2194019681334388578909243392 , 4145781732737322214189131776 , 7741680548156693730864503808 , 14291712892922860017386886912 , 26091812624982677583893680128 , 47123718422346802053471847680 , 84222587420771595912034588416 , 149006083776089430416908458240 , 261031568568496367867686811904 , 452916041686753117296368834304 , 778565391144399905071741124352 , 1326287223270531681858238680320 , 2239510358866942900606195291648 , 3749256872776853192403608442368 , 6224629663054933961493383823872 , 10250705154930453386801778041344 , 16747804517140852018194917274368 , 27152788981560389286692667702528 , 43692669687352982936714860647680 , 69794670015580747068295406196480 , 110696628830458126438539644015360 , 174349621365025611801536063524096 , 272744087443959383013338219783936 , 423845917139601304951293181902080 , 654405680722902129018725532784640 , 1004010316820109948148442504972288 , 1530892525075440781594438266284800 , 2320212651736761143124998835544832 , 3495799204662689623681691613959488 , 5236701144535899225498086829266112 , 7800398883020837417232226023500400 , 11555181838812746666963176299676080 , 17025080556455071133369640473026260 , 24951907687231424838186793280249388 , 36380500068363239373740274439930068 , 52775272450282084447100576555345292 , 76178829729792900231452411900804772 , 109426812200671165226404523527403484 , 156437584682266150660727191373586948 , 222601096690441642539852198189035868 , 315298574086407863572208458839136212 , 444594069693335517679506909391738668 , 624150814456666018768884390895838868 , 872440401030308327979578247737146380 , 1214331866206762283059913625429712836 , 1683171650724076818958406740258573692 , 2323495334207832986727888640660571652 , 3194549330333541892159255728196627548 , 4374847015891541654362742160999032220 , 5968041008522484337180911912176168868 , 8110463823357924592715539966605656028 , 10980775679439057063161353703070332868 , 14812264038817460564372028218508817164 , 19908468358285392193582858670255324916 , 26662959978985353032429866639621082028 , 35584296271898174649238388680939496436 , 47327396131790972217216633695542902396 , 62732857638080846590394196879009948420 , 82876066199676888602429139824846501820 , 109128331956050441920276762516729133220 , 143232759099069844227392692112497793100 , 187398099001318252923491027908173120756 , 244414487040136865066828221050151867356 , 317795724915070722850237031046464731812 , 411953663026064882177054417111133667392 , 532411279982699209529174149151066704128 , 686062269516110480226888759039498727680 , 881486352051323394860479454036479036416 , 1129331154367250292705894206067723001344 , 1442773373767015039937924174155937279232 , 1838074093101955993565041265177752446720 , 2335245572165743958115463694284106799360 , 2958849644212932212406570977072156156928 , 3738951030473067875005011605662991370240 , 4712252489693721019086473729847877899264 , 5923442784595217739241124296435135334400 , 7426793015313733679858330980960312185600 , 9288041984642363158315314296903893222656 , 11586616965787195446524900499125818319616 , 14418242584126727969019736598140023886080 , 17897997544407729492873535883441524112640 , 22163886675095073959975499021789129413376 , 27381004262978191779871619681766329214720 , 33746373948123856402775310463324044883200 , 41494560574824810383812761643776452915712 , 50904160370753113389830531496977029436928 , 62305287673982525173343615112074991315456 , 76088189149445333688111771689561440734720 , 92713130033299388847558587913111526152960 , 112721711392040017610403387873703382512896 , 136749792657152002478216721891604521378048 , 165542209735354378072473367287956700986112 , 199969495739293174957485145679518018950912 , 241046828725819224812097506188831497476352 , 289955448667792394593228168964573812584192 , 348066804052716434400944918090426655036672 , 416969706848836712208501170801174013305856 , 498500792865826582355129977936907395968000 , 594778602562381209696136572386828017152000 , 708241614789497300559691621991415280742400 , 841690582553223060591765561249114225273600 , 998335535206113820623677900935767770707200 , 1181847825232224404614163247676889160000000 , 1396417609433638606044374160422085536601600 , 1646817163522191250324983934499924845862400 , 1938470435196069583163500833242383415251200 , 2277529243391892012181800205311070652736000 , 2670956529731542331541737422115830943731200 , 3126617061910220090810877129636137822318400 , 3653375976919839065190374270988240698404800 , 4261205534332651740263597753548405330084800 , 4961300425221183071088842890013063142331200 , 5766201950588164369699569801984212448422400 , 6689931343047052707521588628590541043027200 , 7748132457122431600496101272644644675756800 , 8958223995301075271983338955306429085011200 , 10339561369459169807849352135588307985193600 , 11913608218567293527201397715080806046230400 , 13704117514835441814817631051205187689091200 , 15737322089334103340775255062699560910294400 , 18042134296645155216195113575206803027731200 , 20650354413342156808306893193422297025267200 , 23596887230233121267288156126177814563654400 , 26919966149628873503023360349102564605958400 , 30661383941129305895713376884078839926299200 , 34866729137779831628226685537551709874193600 , 39585626875629528320637063603873999554500800 , 44871982787510091527597019153693829894248000 , 50784228365527121456539371152768099840985600 , 57385565998006583256022264610945613998534400 , 64744211678195491806977212083950886696518400 , 72933633162675257090032536877278449659065600 , 82032781144225310206097722812103135836326400 , 92126310781781529008455150255827206540275200 , 103304790721672936389941889753735133912588800 , 115664896529103719260139896405711271486707200 , 129309585256677277607547143407895993258208000 , 144348247679999674249267341060311871767020800 , 160896834567729447146236347064177306852972800 , 179077953188105958784816809437893425381139200 , 199020930135915143224533268975532208476716800 , 220861836443600711648887611044931359599468800 , 244743470882811978789079888278637535855251200 , 270815297302118229603870458974324517826336000 , 299233331865875054758953437223422346459187200 , 330159976072371124679990251094644914178406400 , 363763791541940986936501674420607052009241600 , 400219212664451558364213427722466641452620800 , 439706193416583259788596704500727786642809600 , 482409784854610719617693702636642468893881600 , 528519640129543949460609587954234248550188800 , 578229444170370749685435912217543639745260800 , 631736265653382465999063760594442391104313600 , 689239829278318875458510871099992476992096000 , 750941706981483626369169399408112080045254400 , 817044427220946359602462915840102374750086400 , 887750502213358235575216405986540102053107200 , 963261373599494718517997761517325227896128000 , 1043776277893098876746835668372961345064588800 , 1129491033735519870319148917115793044826432000 , 1220596753979362577984080213391773962287328000 , 1317278486341342632981402070226424248709715200 , 1419713787464410203999605655908057554943673600 , 1528071235963036400292266663997804612812793600 , 1642508891208609334448545927532480295461241600 , 1763172705309761989362915017860755075373497600 , 1890194896983319053263146149799338040484908800 , 2023692296634550043383566261487655277035193600 , 2163764673216074355830345781226300665087820800 , 2310493053931018355039897181029259276780825600 , 2463938049087987005052801503957022442330291200 , 2624138194700197645183514047643468376858086400 , 2791108326626389087137115316430091449369235200 , 2964838000084021748622683193320732492345760000 , 3145289969465901959943751376950521193516588800 , 3332398743117679142245978837389494863252742400 , 3526069228737535219146990399685134068948409600 , 3726175484363390082049187679396668562211603200 , 3932559590815275855305347550789726280246547200 , 4145030660334581927477325031253233232337004800 , 4363363996878857858976942365441428695865132800 , 4587300421943315286515772604389084573311289600 , 4816545780390748173428795812715369956674451200 , 5050770638570474880563111225765299170153888000 , 5289610187563694751766626615948954805839052800 , 5532664361651000519337077555356950109409280000 , 5779498182482832321139466189272911429636096000 , 6029642336176984790693344864282105591812096000 , 6282593990991600373640212990196076021628108800 , 6537817859218320724271785254904489882850918400 , 6794747507545080908933777730481392611556556800 , 7052786915608913718859482283747757143127654400 , 7311312283028114424141831161341083598162329600 , 7569674080254841783513831568008407886845542400 , 7827199339532445658783282918726744336620748800 , 8083194176469555174507992758900524980013465600 , 8336946534315521449741909249592087945249587200 , 8587729136872125554338566246783249140517273600 , 8834802637708887501519448821910353350180044800 , 9077418947041003882408105442939672162488320000 , 9314824720242522226239809069295639129989529600 , 9546264984698455467972453438041585164184371200 , 9770986885574990400394296911031004148235878400 , 9988243523689227839809868830141408035420979200 , 10197297862794412604443941655798497327331737600 , 10397426676421246782280010157259345534967808000 , 10587924509995265170251637711015392597612134400 , 10768107625471107467112312030596349529667174400 , 10937317903323460810125481500721460163495936000 , 11094926668355436888430202173996292429484441600 , 11240338413400398810947104149287056010810572800 , 11372994387321459289099769895914463432697036800 , 11492376023322615454500973157699195668617216000 , 11598008173761955223686245712235013542322585600 , 11689462130087298746105291878489320664238899200 , 11766358397043427026491187918015313480933785600 , 11828369201852832388922745045865247358914150400 , 11875220710899040320375595328799575584728268800 , 11906694940410771496583963648262026131777536000 , 11922631335790016946529010307657184492340428800 , 11922928012028027851483705358656800481582694400 , 11907542636268409827138347332809929064032256000 , 11876492948655423122013963214755495466938777600 , 11829856908551050020127040684104912687879372800 , 11767772471066279721453543967764388202014310400 , 11690436983575211366716561108606984602250444800 , 11598106214816303196115355321273590795648204800 , 11491093014884042794020360471688714746895564800 , 11369765621567128880145654778591670961501388800 , 11234545618070670273079762110680301233161420800 , 11085905567589121769933568970044346827891916800 , 10924366329945466450848417256392844905360998400 , 10750494093136911638233209767983462123069440000 , 10564897134142114090974405235337006405468160000 , 10368222340259947122766896531919520295813120000 , 10161151511043464548614610125816079295447040000 , 9944397481848122669000535393587354196172800000 , 9718700083593855752933772189785681045299200000 , 9484821984796504685545706796795262553825280000 , 9243544439192597395045396515075864374599680000 , 8995662976454121436946846822372045889208320000 , 8741983062593523865996705170942158596669440000 , 8483315776222737120882535982062392107581440000 , 8220473514050911339193207707151955555532800000 , 7954265774177703804411584610588212074905600000 , 7685495039519165838955272233280251532410880000 , 7414952791443851729249737330499154892062720000 , 7143415677701442246211924643893062289981440000 , 6871641874509347370170296790633364824801280000 , 6600367643720592827986382047290936334663680000 , 6330304125546182240451336047670482238750720000 , 6062134379551948815760713770598976771276800000 , 5796510685923219906736795207502085379522560000 , 5534052121538169402940598392394573165690880000 , 5275342435559145790971526041818582751559680000 , 5020928206407681017712568997348106210263040000 , 4771317307049024659786844601788211983032320000 , 4526977678384654771836788367241333334138880000 , 4288336397244330141808521358113762817597440000 , 4055779044034543057029252769641135242649600000 , 3829649378870891682662227483612064949780480000 , 3610249286449659628738643285749782718464000000 , 3397839003882246695371572620609614119075840000 , 3192637621560561218170582777981561683640320000 , 2994823819073097487541987669596997643264000000 , 2804536837630914079686924493526853939240960000 , 2621877683811492375827076121528487048847360000 , 2446910509111195663244845859633474408570880000 , 2279664174855239676461092433721305157918720000 , 2120133989277840032131606851470800493813760000 , 1968283558123613884860515062508455073832960000 , 1824046756200563935993377634167162533683200000 , 1687329811916030689192621466683512328028160000 , 1558013438141614980276253474615729569792000000 , 1435955020506569510969203536198955257692160000 , 1320990860036927398310646579574637024378880000 , 1212938395587084260751559113231165440655360000 , 1111598430844645845280288598163513877463040000 , 1016757358424059072180288327339359185141760000 , 928189309909513776176950507671163954790400000 , 845658259636312723911756123652074124738560000 , 768920088969026194211386506454950623969280000 , 697724524837565044595481687150724513136640000 , 631817002412776403202700839578528008765440000 , 570940452079389592183403371147517741629440000 , 514836939132585551953325264006462505615360000 , 463249194095101355024470875374874995589120000 , 415922062539159815341613795071479040573440000 , 372603778056093385310640832735607262412800000 , 333047130958454181862045494017478302760960000 , 297010541594509072906665042011598797537280000 , 264258959384198615185513631954660026613760000 , 234564651986373645049399715432264147927040000 , 207707922114962398174232494544281432227840000 , 183477638587936141857711139461394449039360000 , 161671682916405458525552420678184012349440000 , 142097327314797273466494382326378210263040000 , 124571456568507009379525218646896865443840000 , 108920708254245661017880595722174259527680000 , 94981577549786257259475771079259361116160000 , 82600372254521906512240380510652935045120000 , 71633122679400001991655474556481657241600000 , 61945468372004871268303236826165190983680000 , 53412421347715631951329973811390749736960000 , 45918097484649780316260005635185566023680000 , 39355467454647420715790134565423331409920000 , 33625981726588115934621986042557397729280000 , 28639199465805655265517323362663111065600000 , 24312448412972382453511647522649126993920000 , 20570388140121934996600899194918527303680000 , 17344584977356033799419464933340041707520000 , 14573137327018139926737110331860307148800000 , 12200216189431052868323310698802504007680000 , 10175643110560951465612668527225607290880000 , 8454517639959577814947603574604882247680000 , 6996777994999900358009137575243735367680000 , 5766797658074340787756827155996713943040000 , 4733061393253109817964222557076783104000000 , 3867763073723915747649157811576438784000000 , 3146448717026346531290427384735006720000000 , 2547743089101074725406131290632159232000000 , 2053008583670066252811373621125513216000000 , 1646046268673437505675394719121604608000000 , 1312880335921194473721689012513341440000000 , 1041470145376305206947695847166902272000000 , 821484994535832059598130560189923328000000 , 644137494204575042140348212299366400000000 , 501955887534397091117182968786911232000000 , 388610791889850228870792564241858560000000 , 298808429691758845180694559052529664000000 , 228113541967783737102996656634200064000000 , 172816543083294172188323475785515008000000 , 129871823781845674731250978557788160000000 , 96770129758023876044708310140583936000000 , 71445074235448022634660369405050880000000 , 52236200832376590869992445570973696000000 , 37796850347364401396219369125576704000000 , 27034856738643231639081443307552768000000 , 19103643547816753219037113249431552000000 , 13323814946548987685829803985862656000000 , 9151906408840117062530391739465728000000 , 6185608075307124449069899142135808000000 , 4108482260341353441052718392147968000000 , 2671563869708397718344120341102592000000 , 1695436766429086479347862636331008000000 , 1050242180876320547712616466743296000000 , 629036748047687191783418194034688000000 , 362317123249440270470783749324800000000 , 201151439435787454999157614313472000000 , 101170715710407338962997622079488000000 , 48047581382432737986376082915328000000 , 22507043819735200023799822024704000000 , 5919012181389927685417441689600000000 , 1 , 40 , 858 , 12996 , 155108 , 1546584 , 13357338 , 102391268 , 708914679 , 4491590024 , 26307979592 , 143602523472 , 735317227272 , 3551290309616 , 16251054213168 , 70737989537200 , 293872351807922 , 1168614114711360 , 4459730737361492 , 16370582178401336 , 57919634224850352 , 197876496529142496 , 653876569515039380 , 2093119215323467608 , 6499775354642707350 , 19605236025772612800 , 57509300552956784208 , 164242008174359734160 , 457159393185289345112 , 1241418404563102729104 , 3291861270504382289760 , 8531426484693674199472 , 21628326450762354441693 , 53677440008340327018200 , 130514381708677084543490 , 311126896603279087261476 , 727662768320362737189164 , 1670797197589291217605832 , 3768716181431508599180226 , 8356079849988594032222820 , 18222306453543586465071203 , 39105445602195991056890232 , 82629592830865717185551800 , 171996698983053607728428288 , 352860541295461710420979680 , 713818895184835459107518848 , 1424524472002781513806236928 , 2805663312289513914289461504 , 5455869873715417978221526656 , 10479169520117258669352073728 , 19887885990449529351676119552 , 37308427869297259721483554816 , 69204291563303030385322126848 , 126973131997307293267295648256 , 230506097505546453446095436544 , 414169571828675545635575248896 , 736761902218123125939824770560 , 1297932805028648044745528008704 , 2265016199341895030584736706816 , 3916496798173379954202284961792 , 6711822341709627405259714660864 , 11402601585900362594071624122368 , 19208295554806569079960227225600 , 32091631227048034906952834693120 , 53187045123542602208408598305792 , 87462231514375676540480013499392 , 142732223330122811008451459572992 , 231202894378237018441271107229696 , 371804109092908886022199311181824 , 593692825355875572500576080208896 , 941478373126890437267773194662144 , 1482966733848933755941492449730560 , 2320566548947706149059140933167104 , 3607985839686753511583018811475968 , 5574528006043898401898869828248576 , 8560240066911054038005670382194688 , 13066471209691910905041726095522560 , 19828193510465917094176791248626944 , 29916889042367996131368838790563904 , 44886142830674488843410673043309184 , 66976593950561061941365404978964944 , 99402972746576738216183122319383536 , 146754091821166785416540303365075668 , 215547510820897541930308043585104512 , 314994995974269330130103764344663384 , 458053916628583049634160337608343280 , 662864730912552129764456560876146936 , 954707449674486860233527071926992096 , 1368652631498596970906278998424359528 , 1953137822005226458045788859034473680 , 2774771881915281944945260575111811560 , 3924761688285673028490036508383045504 , 5527473636157414690835287056904852536 , 7751792892244383558058969383117270768 , 10826134695133923113206325007541707960 , 15058204271941485149766019255759708896 , 20860907523274626280551463782122145000 , 28786198587674490019605659807955287088 , 39569131026623962821982728484788698736 , 54184978774383259650873365279993018112 , 73923037795376378317880635365230781960 , 100481641496657110921451874244537858128 , 136090060500640226422499400569055785640 , 183664355757401349149703478622025485472 , 247005966994041413718183102404662160568 , 331053909663679170655672698969406447728 , 442203997675952932730552221629099976728 , 588711593806495565637867356952626080896 , 781198117194929801126389916318049320424 , 1033286026589950450936578791918439919824 , 1362392387049234670081448797098564616296 , 1790717575499209445904942033911763124512 , 2346473370242922056323231431346066370088 , 3065403810182869170482186046563895300768 , 3992663040956532898610729240051164043964 , 5185127157981401112982316270822864734848 , 6714232119285184524324725953616057364864 , 8669447478543563844864252646576846123008 , 11162516372239580407091031718071674195712 , 14332616315472804731251711551494901891072 , 18352623406683713426140059546141997140480 , 23436695041986007375204232450852678218752 , 29849423793587084075373989546465476265472 , 37916858351272904855904258737678626080768 , 48039737083228253835934118926668017063424 , 60709336592412344443294120421546104187904 , 76526402483237130080946130401820054303488 , 96223703269708118384483526806094877132800 , 120692831947181595018955009441680578979840 , 151015974169173246209146121211679298030592 , 188503468358294636814589842914244057477888 , 234738102451832594765502832535037174245376 , 291627225619348503352581051991249270150656 , 361463902211334492612850023679291952523264 , 446998500822851836788703768118177443946496 , 551522294614486197991287490125514365683712 , 678964851476685171451370723398911660054528 , 834007214951962419398355289304729961311232 , 1022213120734350093143881511343835515908352 , 1250180759305830792252668089440916258154496 , 1525717884709854547995478546728860794970112 , 1858043382117507607454505557885692980827136 , 2258018744835735493085457126517368937524480 , 2738413273075703590984499038801658298863616 , 3314207194707114607545360303891773484174336 , 4002937318909249120043200474975328605194240 , 4825090270443391125487724902066173773328384 , 5804548809070385724896551599074020093857792 , 6969097220174040398895476716104438643643904 , 8350992258839649700027869910830429962880000 , 9987606647662533213085746910070324329670400 , 11922152652590175270768349806954499303833600 , 14204493802428329632589970734131383089433600 , 16892053352088159407171116836982952989209600 , 20050828635268980433280564178067581753254400 , 23756520972798440276654087388618267517977600 , 28095791327173589149957219112141363729548800 , 33167652368221533633736205371305572400787200 , 39085008085128889884435819442783306950240000 , 45976352467349967200015164060859638694668800 , 53987639153238802401905018396255026136846400 , 63284334195099421464333739798974555565843200 , 74053664324665891156972448073117742196332800 , 86507073155514582485176340548660459628217600 , 100882897800119455702959708727978648327320000 , 117449278164872712380739848076460257098803200 , 136507310976075757950847140311339962832025600 , 158394460030077074121231004414321354329292800 , 183488233639919371206505046628147498723292800 , 212210139258919799166238081858876624692134400 , 245029924373787684810398592093521991285388800 , 282470111242443046277974616505196419413107200 , 325110831748127717553800170988418556808457600 , 373594966500129786557974419666071842069574400 , 428633590558068926604872517793830620891155200 , 491011725290033310981454936086146231872550400 , 561594393661168027269640977446131869082593600 , 641332972554103848634878530762965193595206400 , 731271833072027510937305616124185057285542400 , 832555255147864622236584595650513084476601600 , 946434599765601611274971790783611675191876800 , 1074275716435661840222177756927502357111436800 , 1217566560314033949433194961341326188229260800 , 1377924986545687720356193493652371016547584000 , 1557106686136783981012566835948619839474022400 , 1757013219589255349007822710099194121128012800 , 1979700101541458837639172234495353451015072000 , 2227384880189582776425763874899386997349836800 , 2502455152994484850503582466053798285273907200 , 2807476449139356368318309318599351345032115200 , 3145199908236222024926652893098662702224467200 , 3518569671940144731778352437698270213624115200 , 3930729906228311523736558355601522568178304000 , 4385031357138385307963176988333845023946291200 , 4885037346909015166924927179510525602419507200 , 5434529099914294590847143938904043331070873600 , 6037510296228074229333346512183514466803468800 , 6698210729854481084983230133444722852586828800 , 7421088962959663622902462610793497517012115200 , 8210833842448862813994793215497847383480064000 , 9072364767334899712648794284724633702703104000 , 10010830564833853468177549476029829857852390400 , 11031606865435631167107150334522072848498528000 , 12140291829345559131441827726915126093643110400 , 13342700122177562125883065878610930099621747200 , 14644854990094677060827457792339655260845721600 , 16052978346922220617834296694465543062755328000 , 17573478724883935964435876920844993388614400000 , 19212937024294060455912777628368477283269964800 , 20978089919066158948079329237932161559304166400 , 22875810885468351263864762676970125820951737600 , 24913088719701067279329738121796896444067481600 , 27097003554203461072531717377468972313860096000 , 29434700249857699858866181043207860011074995200 , 31933359227793883394241792784857535785940896000 , 34600164631378498079560601006827951331927654400 , 37442269948073201731236822639393753369307238400 , 40466760995269530918827007025384389361565030400 , 43680616478800821538852330615943324114257305600 , 47090666039562429299202096909005448102635520000 , 50703546089607338284762938844950917999085657600 , 54525653359377499533924472989869279158850380800 , 58563096564409308520198315501902432288898579200 , 62821646110420369219614645324455082105347942400 , 67306682367258491148738090469378381939405593600 , 72023142414282086253661056526431985562037427200 , 76975465925645460420568285201456649322369657600 , 82167540062940200826690810709813586671424256000 , 87602644198607253187331602030345141182801292800 , 93283394277117864260578848216947286523329254400 , 99211687811154471938501427778297559729448806400 , 105388649226775768408204805764595503546001817600 , 111814576749329734239813637937737345262196864000 , 118488890410991682046063579823374712212187904000 , 125410082589957357963647985063147441174949363200 , 132575670479497137446549672667835701356589465600 , 139982152143870955439049354073490520273262579200 , 147624965317188743017309444689125169076051968000 , 155498450882711908820809100839213354839937324800 , 163595819877566996367005790604752358879290163200 , 171909126281516527750239705996546085932587827200 , 180429244042029719919510596113579970023951564800 , 189145850966945184351564987289250929029277286400 , 198047417449992659886341182869327400573295001600 , 207121203094510845716201628059934655247056896000 , 216353258608352886372224953532498239005681254400 , 225728436544430859913889529684380301303531110400 , 235230407545697759265976060771891537772258918400 , 244841686273184575483687330103508618314475110400 , 254543662823780647438151973305128206446134886400 , 264316644532172905757589651447444766245155635200 , 274139902961311796509624678106803915398719078400 , 283991731825319467520290847898230409938937446400 , 293849509474029915231617250280602835862608281600 , 303689772698633682234725501415970209039605760000 , 313488294118426943969832455557386844244430028800 , 323220171112997756398779365736473214507187814400 , 332859916983367324780409047311166796142251212800 , 342381563731572971551014277339476172502040576000 , 351758765325723647194161011762340428905773465600 , 360964912533155480012811690131759868299502796800 , 369973246103072965407525670278277557583601664000 , 378756981369836885235758417974352004122367590400 , 387289428689885466173742977333877263813286297600 , 395544125105687947941020746465396404447954124800 , 403494958950253866888151028542186952323311206400 , 411116305507733344732376969547540013786789478400 , 418383152372009848425286225021270187030028288000 , 425271235766526578778240146918279160002199552000 , 431757163013158185349781658234446002200880742400 , 437818546028619079885914080609163920558144716800 , 443434117128119914455761676933855251059089408000 , 448583856186761659137702616889270982592684032000 , 453249096020511605995169203269978555711745228800 , 457412639779973403479603302471451016924386918400 , 461058852292463647523725741447350545064783052800 , 464173764498599566440507815199855438255262924800 , 466745147381946808315254657826312544366552678400 , 468762600621555496012972671182819206268640460800 , 470217606145366257243348155540776983330467020800 , 471103598616136506577851356021415764036740300800 , 471415996155411117602633392824242812662418636800 , 471152250885884034724923023805751265456551526400 , 470311854930723260091953849476861647819384422400 , 468896369910718790028735938815847889274003046400 , 466909407028862563308699390257734333784727552000 , 464356635095307503864507123443921999830555033600 , 461245734242267047516488855387537785017117900800 , 457586382851819754221515338363759918174310809600 , 453390185122266607954396611363354715468185600000 , 448670638057237201930727191323335267102146560000 , 443443033893156449012176688647045851936522240000 , 437724408962443830537566032481030860743229440000 , 431533422712609657759781655573204232162836480000 , 424890291010211813929537674684349957642936320000 , 417816644007311410772152974540496978478039040000 , 410335447084860034808901248334587549804298240000 , 402470840449955708914062969040063826018304000000 , 394248051280901870459365461107709547281162240000 , 385693218406656399645991076722732403956776960000 , 376833299693466765537972665944844696605900800000 , 367695885292274735714696610414882828778536960000 , 358309104586257698189005029286969477319639040000 , 348701431790126022450388004790425516026429440000 , 338901596650691252267087532398477485571112960000 , 328938386262279268101816632361562064100556800000 , 318840563812245483975093657134128555206819840000 , 308636670099031147532210850719235403873320960000 , 298354954475454708091489311588690667781652480000 , 288023179505362846115423268932858311657390080000 , 277668567597020830953463873647892332826214400000 , 267317611956514113680138808866119298402549760000 , 256996042182158098851562745177187953143726080000 , 246728643818298359147849762172116772849745920000 , 236539245735544808610625461879100410432184320000 , 226450550342795780060072210157818698193633280000 , 216484144474371085900643162020298269808394240000 , 206660341858685906604016554361292930565242880000 , 196998218919572449588430921860503490402590720000 , 187515469920464676033337195259459516159754240000 , 178228468553716354695729182298465909230223360000 , 169152135997207073106910929305329119382732800000 , 160300027810094034770098205417327489823498240000 , 151684214764197497850511234441298699826954240000 , 143315394417926625654060753371248664069898240000 , 135202783262261385175435152771266603483136000000 , 127354252003081060930588267336377243077345280000 , 119776227713333040009032892939881042931548160000 , 112473850397246820599025716977535070679941120000 , 105450883771377729635128896967013175531601920000 , 98709890979891524427608988682841526481674240000 , 92252151272395521879494458180455009480867840000 , 86077852750358347726754962294616795942092800000 , 80186012898628070323664009043841618217533440000 , 74574684756150448489974689751513344012451840000 , 69240879624701820345374701964847349227847680000 , 64180783905205036219994062985060325125652480000 , 59389680883858134347308962822989862972948480000 , 54862175959442470024602138340547445121351680000 , 50592115678640186103800610208738709109473280000 , 46572817453823730382134812946611337231728640000 , 42796984804874802837343962137048457184542720000 , 39256939110816691545044051054599726631485440000 , 35944528402201718278029460003305850334085120000 , 32851359519009300348194786816699192640798720000 , 29968699596504344183736087319084117170585600000 , 27287705117728896730591731279737260073287680000 , 24799316315097173627571507954487772459827200000 , 22494481535356803433792290167830115753656320000 , 20364042714141764895558961277882079762186240000 , 18398954616162321736775326086143615210618880000 , 16590161754777175329550456857557052578856960000 , 14928809597723214965157967707501962115809280000 , 13406114602726225552596742585223624612904960000 , 12013566835665506770802490080831970850897920000 , 10742792048433379872198052756374751307366400000 , 9585746433904777115135605470933120291962880000 , 8534572172637956045700994401530491274526720000 , 7581781988142446481727060747631028012318720000 , 6720110914445228862444685348481996968427520000 , 5942690944754602924939112086925058643722240000 , 5242898267875935895160442814805650353684480000 , 4614519680137480465706915579589749817999360000 , 4051597346575510228425230263683903895633920000 , 3548584748760521481372082282443905419837440000 , 3100192376076177553045085850803825273733120000 , 2701533979601180957951539874793022732369920000 , 2347972256801237133411045640012183979950080000 , 2035257662479151339841403616851978365173760000 , 1759376131712452303054125496300866266726400000 , 1516678178271291816056799747179170698362880000 , 1303732135481369507494270678856308736655360000 , 1117444408951023623804707752907204727930880000 , 954916752657248315772246192874667554897920000 , 813560202329556652272154241641522924093440000 , 690958125538646544183387049277446737100800000 , 584971180397467944885995269814225873141760000 , 493609354766152446495780860742605136199680000 , 415128920403491572260103677038356565852160000 , 347911121951915740562503888373035302912000000 , 290553796189738779038255838445488046080000000 , 241757867684663755079026176044128272384000000 , 200410715253977117904634214054431555584000000 , 165483404568779966185234228857308971008000000 , 136106546308571652551621371085091766272000000 , 111475334048075538896663672309552775168000000 , 90920591370518964979440621870891270144000000 , 73822202266395584029421475728288907264000000 , 59672494713026816381003817672329527296000000 , 48000325629150867260334621618783387648000000 , 38427721753178227117551119929720111104000000 , 30601224257222138243957592280616927232000000 , 24244391019264059425668265991001341952000000 , 19096745482590823833427166310363561984000000 , 14959241635847934766849648110694563840000000 , 11642927594447637049092042870340190208000000 , 9008143595143155598368595695340879872000000 , 6919322989249090904261719876637294592000000 , 5280743630437000751112093611392499712000000 , 3997355608987146280301023697062330368000000 , 3004673386433710785568627944320925696000000 , 2237177700643529682107942663129923584000000 , 1653254241596878651086894498129641472000000 , 1208006374368016828417009839488630784000000 , 875480879828946209891634419286933504000000 , 625998906496158930026660754811256832000000 , 443601140473046132554694865664868352000000 , 309040217583507547556523606917775360000000 , 213422062295849903746879102616862720000000 , 144005385599474359670109774129659904000000 , 96337134073350538674193470987436032000000 , 62533829509634254462241390840512512000000 , 40224068989289681067222653107961856000000 , 24714278877871658634544618999382016000000 , 15191670424286654836982851584393216000000 , 8587894773978646078772166147440640000000 , 4929264559478810927500364177473536000000 , 2496520957866643699155368555839488000000 , 1315781610392527449649083743993856000000 , 461682950148414359462560451788800000000 , 242679499436987035102115109273600000000 , 1 , 41 , 900 , 13936 , 169902 , 1729478 , 15241768 , 119176344 , 841399673 , 5434810025 , 32446106188 , 180492650400 , 941758983736 , 4634206074120 , 21605323866800 , 95806660754928 , 405457598741138 , 1642428924493954 , 6384718779101720 , 23872987806871696 , 86034333855306996 , 299390833303838980 , 1007705630572578240 , 3285643873140753248 , 10392200263061468394 , 31926870772420389738 , 95386722817345407240 , 277451851996998857072 , 786519905011157889736 , 2175108763202533460424 , 5873591893004853731024 , 15500960073818874826512 , 40013476873681423915405 , 101108995286221850678069 , 250285517348721694793188 , 607373196578413506006720 , 1445929446937508910457166 , 3379050914052391349001574 , 7756590693212559075577752 , 17499931311580512921729544 , 38827644814558104014017917 , 84766551369676258362385421 , 182186579811373394116740396 , 385688642176376608758840368 , 804631600276447232599834384 , 1655006162185912910500597504 , 3357675292420328821722662912 , 6722033176424346041619928320 , 13285081447639442055228872448 , 25929901685457785742663047424 , 50000587094615754252437465088 , 95289438216172258069157801216 , 179540045206619324501780036096 , 334557039333157502416389349376 , 616752394808314578572008841472 , 1125167896472037402245692094976 , 2031974730938777142129391016448 , 3633601908209354538272929823232 , 6435661570773406275936068954112 , 11292756719490868268490196177920 , 19636648176025624072349239808256 , 33845492053483423228990348982528 , 57836478260917001027677046376448 , 98009458334001243113430189092864 , 164737782880629517545898849970944 , 274705883317272061346607392997120 , 454547543588529821888539289503744 , 746467977900915278312763793837056 , 1216870644269035102456064057278976 , 1969504385350389899385147232359936 , 3165366138263341391411328076007936 , 5052634817124803193059749311215104 , 8011406700572692020566167294394112 , 12620137260981869106387332566715136 , 19753724841001024701392780789581824 , 30727449155972189058525967211036672 , 47506981533442108874128794521907456 , 73013064467816518842186939091992832 , 111561093360227905223219896967415040 , 169491902046517974823084409570451712 , 256072130685166834142659958415024448 , 384772733021244061355214421617056064 , 575075228633095038977817215946752688 , 855010868869375750868977207844118000 , 1264712737076565553559972400498690084 , 1861361169796706491269850085535565476 , 2726036846298833243171069497217610096 , 3973173890091273959121412865234544240 , 5763540789435849600391911756004172112 , 8321987077605353206214316770898008016 , 11961600457464989778439509119154511056 , 17116450271097455662437901554751968720 , 24385784139820905287252191972824965328 , 34593439611949857086792654839093313616 , 48867387423042186727290124626782615472 , 68745807045912392896196961365969281392 , 96317995136801026786244701179829179120 , 134410830558709966867402169923459695600 , 186834598368198164350626604886398580400 , 258705872461784819199604661541072144432 , 356870072220720026409189891471229996248 , 490452486322603197351306780562304835288 , 671574293543611077502020344788216051728 , 916279765373357055197927877323676419280 , 1245732842766190732123347238180763885616 , 1687756161749615493499852746444697801392 , 2278803986240879981489701761649138056048 , 3066483139543559182549282265604728590704 , 4112763799419267485129736061609678164048 , 5498055992067083257175817014752006227408 , 7326369037032632942464178477944146774288 , 9731821529531131513801478445370243603536 , 12886830426448713425459208631590126817872 , 17012381448135146727074564184997827003984 , 22390871675936831967847016683904938265952 , 29382121651798712213003500116625753080480 , 38443281639554701801538465068285346978532 , 50153508642202858858979969441101275299172 , 65244471487232520570281032188744548478144 , 84637955604966254932393875204904379705856 , 109492092526682238488450571489384823764480 , 141258037866468005202150617589778776013824 , 181749272704018444853925534991345183398144 , 233226114846365493491872417853393520359424 , 298498507407708755482772738525553939378432 , 381050712580390387601259080268986545412352 , 485192189626552228197770781511883480179200 , 616239690499219257297851620178145850154496 , 780736477957195883764165378070889683630592 , 986715574834285026358925185805210618264064 , 1244015106040390135955116171966804018132992 , 1564655115232399450995229731203176414202880 , 1963286745867353816644326468856680975697152 , 2457726393131142491363855440823835466699008 , 3069589382343153336064517301178537720243200 , 3825039935807544076445813285580386852938752 , 4755676680381550553999557110367256728468224 , 5899575750416321167737555999627017793381120 , 7302516684975819904664987693545451054128128 , 9019419835326868042584396977081881474043904 , 11116027920970936002022603134981590662285824 , 13670868732979266563889437278062561372556800 , 16777540816090916912634303038572689106497024 , 20547369299789479005269676976269924686977536 , 25112484927613538492007389690405933941752576 , 30629385786179928734464732205531769554464512 , 37283048293292637563405394678606669598187520 , 45291661697600861277826123461866608368482304 , 54912068698700451635005290791791642176155904 , 66446003839337665556706815303357678485741824 , 80247231070996381136239596615369599079983616 , 96729692363134828371210401768202414011149824 , 116376790423622049561475551807777893308955136 , 139751940520739329934923141712426205620467200 , 167510539038196642869911363930188547469696000 , 200413509730308145641503140146636901561497600 , 239342602646180090305129477084967585755065600 , 285317635308545489792765319792117612486662400 , 339515880909327519503002340352819245952710400 , 403293823934863731371685837846998283836793600 , 478211519671260525765564610939399076395910400 , 566059810337438807585116447858090602381772800 , 668890667024991750995789294019733695633945600 , 789050943013209101352841485216040488441043200 , 929219840207949445158163199271459797098152000 , 1092450406190310001906973509298470314247022400 , 1282215394444781352950544036120934280760662400 , 1502457834467844239444977794873099533965987200 , 1757646671382737826631788232448290294763112000 , 2052837846033956288262257319369233565015873600 , 2393741196012173200333189861908739526753644800 , 2786793565219242300468059946875833347425203200 , 3239238514099067744714235422988548523327849600 , 3759213024004128584165734914143077370656348800 , 4355841586999434431001659281870758161218944000 , 5039338066110850873131462708386743611707596800 , 5821115700271010792008975091150518990561852800 , 6713905612300899324549097602048033286468713600 , 7731884156897397758686016665396056816907468800 , 8890809417982888734527546919441258229920403200 , 10208167130708178036618212896800624795330235200 , 11703326261994739975225396716670581110181556800 , 13397704434697559520382273517041619566683235200 , 15314943323273561946038710578245617464083222400 , 17481094083414190345060744318898885056459521600 , 19924812803332552082716209427494097968294580800 , 22677565880766617910008937565572470309191929600 , 25773845136011024527564717470542891338607539200 , 29251392368336896874040149302034938277738380800 , 33151432949556339484625165805746462874630336000 , 37518917925730073027471200080635690460328588800 , 42402773964395671468262946807421802881625510400 , 47856160342470778677146270193575602028001811200 , 53936732017081705820460675534693120058076563200 , 60706907661216723235092663647676842345363251200 , 68234141375718691245257398702210859385204480000 , 76591196613176396151367932699733695710929209600 , 85856420664420779689327942073453894703765408000 , 96114017870620947961548607342157694529543488000 , 107454319529028819605068507726380141122641958400 , 119974048266217444182554715312236428610087769600 , 133776574453417126265648585519294159380165132800 , 148972162044645912181197398293613493155063577600 , 165678201021998386905029361153172345102271078400 , 184019423447122610573628308045107050590880057600 , 204128099933124030649415712009986534554814035200 , 226144213184001333481822943592338942912065305600 , 250215605085335228804763817556532478582766976000 , 276498093691955529772441987731246498021234220800 , 305155556327104011072721193233347372622789728000 , 336359974910645347267987560461306949110221516800 , 370291439546389962056964159010432253824493184000 , 407138106354997410374140521629072102813911257600 , 447096105506890017486567095908230524075117299200 , 490369395432044886015897240520776795947146867200 , 537169559218093376232860027333583061027654233600 , 587715539308837649676516669184831918280739321600 , 642233306726940186164163926083148248458258604800 , 700955461234246982123878912110512961501715814400 , 764120759040690700863777149643323553024644505600 , 831973564960991279632364784850313178061328467200 , 904763226207450693313734073601671551788540294400 , 982743365401007174482630711460375230288170278400 , 1066171090766716928615438394017643339006396019200 , 1155306121982337596339083520589583038419471961600 , 1250409830626915916584171768035051589262879500800 , 1351744194787903460952260711189387790910483507200 , 1459570667951154198336031150577022961213109222400 , 1574148963014944793333738634699737410612725331200 , 1695735752912669404215304388701196039810589139200 , 1824583290140188674485535933338498573514118963200 , 1960937948189305738620608167225680781835660083200 , 2105038688782056375982086361357052567657314118400 , 2257115459543561884570897182484893115196796076800 , 2417387527708476118464630457487432128356118195200 , 2586061756210809083913192341676786866146643328000 , 2763330829501509490462512442565677125189570086400 , 2949371437172924374027273053451022564634590707200 , 3144342424476803947763513659882370546372353497600 , 3348382919494157530820603431394918937799917657600 , 3561610447707737559739072086486022611374198246400 , 3784119045298907631743942455859041369108446259200 , 4015977383428494899196547444059348096923424691200 , 4257226916190170218933219336667813114053842662400 , 4507880065782050139788809019126974409687266617600 , 4767918458672496714212335871063403222953397868800 , 5037291227286120737220071783895190742422888857600 , 5315913391731248573130159395767182697714873958400 , 5603664336689647197054218480009753768304214425600 , 5900386398313051024697342108187123208826628096000 , 6205883576410548692087168358246180550210766438400 , 6519920386601229535429134633846098511890610585600 , 6842220867380489155193611711479565118323276185600 , 7172467756090578758959127337757550067514987315200 , 7510301847856123138637258747615516620167929856000 , 7855321550226798519205624826406522139512161894400 , 8207082646166934998606806372276661612987360870400 , 8565098276290440214739393978086549198316180275200 , 8928839150999943426250369529350760609309466624000 , 9297734001054793810628889953849015206303108300800 , 9671170274682945070781305667622859363858651545600 , 10048495086854778400462628528604777223043294822400 , 10429016425852513932955675831703055500528610508800 , 10812004619334554277789214391031042500159309414400 , 11196694061629538483556378018299101870089875865600 , 11582285200720506799780512441705223074086806732800 , 11967946782881469819593464044344387880716414976000 , 12352818349398506829996617360865834299177825894400 , 12736012979457324878191625066731103892368222208000 , 13116620269367865766272079861155668329750569369600 , 13493709538252654988753114550993155856381323673600 , 13866333246215326122573654654197452363700726169600 , 14233530611138566490322149678175695792154507264000 , 14594331406095630588038861842410803476159936512000 , 14947759919953669031410610093274669221421627801600 , 15292839059265437510915556992103078758668635340800 , 15628594570830554428246300121572013664118620979200 , 15954059359808052134069230234459110757481965977600 , 16268277879912341939381464481121902943816681062400 , 16570310567914805713423117695392383882532207001600 , 16859238297118977395992737458511998229756122726400 , 17134166819828210614563190836570240316476513484800 , 17394231172365461397166125324816417674627801088000 , 17638600011675501579523266922324220774935697817600 , 17866479856503863872716185135654614065639370752000 , 18077119202037031468086468907273448706916567449600 , 18269812481904061675628825444804184943425591705600 , 18443903846750466220509285965848041103913425305600 , 18598790735082191265232989188386896149038845542400 , 18733927207557915090464537111587660269574937395200 , 18848827022570651200835916135827810051092475904000 , 18943066427053594783482955602914282039796033945600 , 19016286644297934827241549191431662942300189081600 , 19068196035526897588305567218628167604021825945600 , 19098571921613238514275937219451923851699562905600 , 19107262046372624290035998213183673371620488806400 , 19094185672064195001473538310571977078273827225600 , 19059334293628941452176302421244926425474936422400 , 19002771968534710337226157134441432278670581760000 , 18924635252921998614169568890984370413844152320000 , 18825132747233956044094182885170482274755215360000 , 18704544248340456484060137684023587709401006080000 , 18563219516056845558386696308459041965990952960000 , 18401576657030110467516550882613714225368842240000 , 18220100140957990819579049788701823057900953600000 , 18019338455747249727437884465994274488594718720000 , 17799901422865258729667448486813958924254167040000 , 17562457185771266233627969252439359237978767360000 , 17307728895703787210039902777666900738775900160000 , 17036491112902936964429536500526270223636029440000 , 16749565953695447587036537254649601985702051840000 , 16447819002427594570149767371850360944379412480000 , 16132155023297252007743215480427003727646310400000 , 15803513495960673973835494483926064175213199360000 , 15462864009225685861927994063812245261249576960000 , 15111201539661108653099276604884699903452446720000 , 14749541653623137267401669803658470342050365440000 , 14378915656168430777695597927838525644521553920000 , 14000365727236212967377195891437257127695319040000 , 13614940071448643279762442737637549513430302720000 , 13223688116114160964646312555014286185430138880000 , 12827655784344175742404498727447610702426685440000 , 12427880880038970463271462422287355103012044800000 , 12025388602951868295131553021922247866887290880000 , 11621187230156740634659547206786142420438507520000 , 11216263983886554452940019941477607467424112640000 , 10811581110699875075589344788798492813863567360000 , 10408072190784629572618162788938084853264138240000 , 10006638703813637135144514526612495687676190720000 , 9608146856725873047870378712413824185171599360000 , 9213424698160875352500258295046955880388935680000 , 8823259527039179130131893899276219656892334080000 , 8438395603812855237970387820662855306107248640000 , 8059532171051027178492344560611594795351859200000 , 7687321794839741063020180826206237889877688320000 , 7322369015387527390432630947541706737846272000000 , 6965229317757723354188847300438007698725191680000 , 6616408416849104179148205932687803422696161280000 , 6276361846368679557349801225947397498835435520000 , 5945494847286015755630485867957657219030056960000 , 5624162552653099135859212653997032499304570880000 , 5312670442390880686310622008928761927219650560000 , 5011275067203962727877177844874676707272294400000 , 4720185025790634478174476912698194524926115840000 , 4439562169395652551962660044791496110635089920000 , 4169523023896569432654103979778960727487938560000 , 3910140416471490345288075132336875581809623040000 , 3661445270087720600007699841160108925529620480000 , 3423428559764540952299965456803864297455616000000 , 3196043412951660156190433098452626409465446400000 , 2979207316658608057316766856370331490839429120000 , 2772804424039206405851152859826160666064977920000 , 2576687944529945445115401157830883787815649280000 , 2390682577776288359477221772918534522066042880000 , 2214586987390289198199644762536188099919872000000 , 2048176300702545865292410360953666100462878720000 , 1891204592514118105153414798409786161047797760000 , 1743407356423874887414437427815634999726571520000 , 1604503949970192596268913742463686510440611840000 , 1474199975385519563572301020669268079229009920000 , 1352189599935851184514376627803916552707768320000 , 1238157813384999837571780406183297499628830720000 , 1131782578192927712114926202479365240693719040000 , 1032736889217019851552751645493723227808071680000 , 940690737875065427269024722786931985069506560000 , 855312945538384069442330445153669857470709760000 , 776272881923010060737665608342269596579921920000 , 703242076155872352084901585101061459728138240000 , 635895675196463266222756303470880159090606080000 , 573913785076109569115300083910140845006520320000 , 516982694519966724940548057828373060107632640000 , 464795947537034715294617803475064674675589120000 , 417055293460158502863814810497696199588577280000 , 373471531999203232586092539932093154811576320000 , 333765206833602230974676926138221338190151680000 , 297667192444769793358801920495684477191454720000 , 264919182954686992205009808992533279988121600000 , 235274048536676494459093257661361582677032960000 , 208496095986912739070520668163701037913866240000 , 184361257162396115824161866894352854994124800000 , 162657152402882849560713819463100503314923520000 , 143183088201404975514415662324321840094248960000 , 125749997899437736434229171662958180832378880000 , 110180282696959673259996902126042073236766720000 , 96307600535392501431153153449824714555392000000 , 83976628642526122083266976425711878361579520000 , 73042740145750148214745509865718703288483840000 , 63371655976651030886456685571429223607828480000 , 54839082299753257709769067241240381407887360000 , 47330289381074756871437433395555921032642560000 , 40739677525859111289798485240843662645002240000 , 34970354949115483835248826691820692370882560000 , 29933662012299678853963739203755734154608640000 , 25548707066086211099876453539866470842368000000 , 21741925204128251925109043711923283951616000000 , 18446598092475302335248362856664290951168000000 , 15602391361742846795499236016804829986816000000 , 13154933815649945124128697708756577419264000000 , 11055360236289828998733541256326889472000000000 , 9259886871762035190300312012605217964032000000 , 7729424807298289466455532280628308344832000000 , 6429173267302255371875979867032764809216000000 , 5328245263760881898531504533237496807424000000 , 4399338101002700208169705992077294960640000000 , 3618380708855164587607334352581946310656000000 , 2964218998287120954607592656694716465152000000 , 2418348825479395278827923226537119186944000000 , 1964626157207162052860330708121855983616000000 , 1589008254596631197131922364578698100736000000 , 1279348847749210581399286400417808777216000000 , 1025166445008823576157064833691857977344000000 , 817445461357692992691577079425381957632000000 , 648481925851365402021304969863188447232000000 , 511703806543583416050489112366449426432000000 , 401526135443767333582617865599338938368000000 , 313241043473340396185311167255926538240000000 , 242881718915241111945815059456818413568000000 , 187118833618173850864831375073133723648000000 , 143190060221810681849028365114834681856000000 , 108800881340140874442560185467741929472000000 , 82048753454894959000218392290746433536000000 , 61383479895777056106484784172047007744000000 , 45537716577662458797930633202570887168000000 , 33476561315840878181284869635101949952000000 , 24373784314023585469670718464354942976000000 , 17564386931295892980444681973587247104000000 , 12513249590534720708641707837829939200000000 , 8807900966265319011629283950632894464000000 , 6119779441724398724871949494679240704000000 , 4188038332696415824240332138187063296000000 , 2820416607525959195272158888113209344000000 , 1866741006926209914661746369783398400000000 , 1209703743125850926223326732642942976000000 , 765150911853702300541381676825051136000000 , 472438150422730741462625068385304576000000 , 282072537968278676423981225648062464000000 , 161974493422727591377589755472510976000000 , 89658843716352522082448453280989184000000 , 44966735542019280626116304515891200000000 , 21296605828640959812131955199180800000000 , 9949859476916468439186719480217600000000 , 2610284371992958109269091785113600000000 , 1 , 42 , 943 , 14920 , 185722 , 1929132 , 17340642 , 138243024 , 994832181 , 6548192050 , 39829424631 , 225702472160 , 1199488690048 , 6011275412720 , 28539835838568 , 128871811769504 , 555338290864434 , 2290509966080788 , 9065845147000350 , 34513164286221520 , 126635080175236172 , 448661806648043464 , 1537472927026357148 , 5103666612208678848 , 16434313308712331042 , 51401494640685654516 , 156341446827041323974 , 462945698417686777856 , 1335965931384679529880 , 3760920852925120611920 , 10337747243284324778216 , 27769492179290859176672 , 72958835553822149299149 , 187627061215212238850370 , 472654779884262058458963 , 1167164339898140021063336 , 2827182738909546785089418 , 6721888860820265116784108 , 15696902914446215319805778 , 36023019577931735881796464 , 81290044203626649876463913 , 180477545144015340889655898 , 394425859225799190008616611 , 848950945152692238278791776 , 1800464876163901021919920792 , 3764202442449636516880350560 , 7761415197863081865456647392 , 15789709213489390010907723136 , 31706686852287795248201026944 , 62869826589389069557855602688 , 123143837068386545443703700864 , 238352635351453994405171185664 , 456053387763902303592486695424 , 862870224885972229440676168192 , 1614913416280886139424606852352 , 2990621023709547030248717638144 , 5481647177692804187840709824256 , 9947695890959790406599305825280 , 17877838924863112626839046812928 , 31827566456278483457381717497344 , 56143328618388277925762635893504 , 98153417287983079774994072782848 , 170109069793924998135327047114752 , 292322812096398320607600668571648 , 498202500703785130879210917248512 , 842264180028878922697743429232640 , 1412791048347802192891523092227328 , 2351686728250145847629459546585600 , 3885390215840431404690757302605568 , 6372682092675292679189662197017600 , 10378111100069860807824479909736192 , 16784027263762272773459759506958848 , 26960418927934621643297570364540160 , 43020757885159153157223021978428416 , 68205039617102095694933421293065728 , 107449810466251458483936253840160768 , 168231482746591424634403661159510016 , 261806799888766034375945978914833408 , 405027243897793473945857966437617920 , 622978367029077332949747930212500992 , 952798473961505337105629018395383296 , 1449174577446760503832059581216363776 , 2192211609246159543470238111958717760 , 3298642892618327593121852577974990592 , 4937721696723505786413244163567644176 , 7353639505248350015302573119354341424 , 10897001547789698516922422449971370788 , 16068813371248491433430566611103246392 , 23581671144331477529214058682748456252 , 34444503665079254970871547915816514912 , 50079416108380662652267035542683118688 , 72482102673279660605608780377646140192 , 104441143649780824352175261747027802032 , 149836558625727447029107221546164511552 , 214044604096134319248682503282838805856 , 304484428052677847305694976098988107520 , 431353391952561206836881521617655647536 , 608612354330477328520944227853123709728 , 855300874292693931784478759104008666816 , 1197286254814129433488619413086062333088 , 1669580997073731141579426367542557467440 , 2319402305164720970213496163810768318560 , 3210196900966428851207883114513430373928 , 4426917212649626798916752686132099895088 , 6082914217242581121861413332978898126952 , 8328911799192625872684970875698643084960 , 11364652250567515471096293729358150987488 , 15453958337266244467611943524088050726240 , 20944151277218259404087435227842537068112 , 28291004573541266753963970844393636385472 , 38090711206538860517338915716545091790080 , 51120708544834438682101216677083107268544 , 68391656225915179494337736713509063527856 , 91213414727725413608695355418713116600032 , 121278547243504204732387615881964284712512 , 160767689429233075957289441715406037826528 , 212482129700590000385058839330296391422656 , 280010151189493984622927401016129035057008 , 367935145304943690393652228308974328240468 , 482095262860661265855243395804684325382104 , 629906476455720180734311244543967556016508 , 820763450446938714232865297657053292659968 , 1066535625673539772602312957145662571666560 , 1382179509438123598017702853443196967083008 , 1786492414252444586985479735564384819119104 , 2303037922621072548195467793172925734666752 , 2961279296860456923741112101257953602471168 , 3797964047061537881502512745416634291334656 , 4858811081230283337983705234820441015770880 , 6200561474651714042795103342271413033145344 , 7893465120418307417697177224560343757848832 , 10024288594285872842258261542964680980045312 , 12699944748725796842443318206882603102442752 , 16051862135743840903448561113441169402959872 , 20241232673847417075449411420512213595612160 , 25465299381087825876237001731791898395873280 , 31964872895298525208196477668180603770911232 , 40033296329775533994949284277211905347692544 , 50027113252985568484145445264526578189630720 , 62378733752517825320824088917558631180923392 , 77611439223671783189927070146540080215313152 , 96357118317138172266452486905418689462705152 , 119377185064229269781529113718619471189414656 , 147587196264784367784398809503150010846265856 , 182085759551162447769538130608215733910807808 , 224188406905374634176029566871863213051911168 , 275467201687725292233509958111853877166991872 , 337796951273346593267807950243938550608119808 , 413409013169504511513283019142554558108740608 , 504953810877241862655065420846219831965363200 , 615573317838380980458600990530805038685191424 , 748984924439559058336094685464083857170290176 , 909578275379288796899463638256035989230885120 , 1102526853529991490836441752824853889468359680 , 1333916292957699664030289071104526077951890688 , 1610891628607419831746640710902189695443719680 , 1941825934584428445916513318818553054480775424 , 2336513067252506462376756386899578521629440000 , 2806387514837115826229007041816527602287692800 , 3364774661644527191760582967031944947845068800 , 4027175103758456451264586036302162937314470400 , 4811587003157559382357820426820820730628556800 , 5738870840106018781389406593651990888643200000 , 6833161317273632997857604396606735789016089600 , 8122331585095149704221389814445742570952358400 , 9638515392624808088327269596877405297156243200 , 11418693223845530023540227677529657016987161600 , 13505348950005949804087974706030079985867398400 , 15947204017294180450865075169162808032024744000 , 18800036686765627629821448435856546521828105600 , 22127594354798818919554888873728471749559931200 , 26002607493751253009140348918203326465663577600 , 30507914271596880479949373763190946423033425600 , 35737705416247421762894831095454493844631184000 , 41798899397186554905307625614328959227796593600 , 48812658475473023002701558109112883619112716800 , 56916056642409291942062860055570121796541251200 , 66263910886747161211712607197958817697533689600 , 77030787630459444924989806084899327906994608000 , 89413196496688115821470438340846358125816512000 , 103631983867194972771788803505247744929331254400 , 119934938870070240009350652282006508283017881600 , 138599624582687806101624820158017233305920265600 , 159936447227034510194005620971239456792466438400 , 184291976081282282080885162225906025653019707200 , 212052526574578193870419427710612521394657276800 , 243648018729548933036930877908189287343047233600 , 279556122547481271115951546466496227051135961600 , 320306701325904594410056613552986300810860235200 , 366486562947790160816278616431205215176320860800 , 418744528220857123885615423352246052757779940800 , 477796823942508460205043883789539447911861107200 , 544432807001213672629461477895048797342181958400 , 619521023897012362998349484232561037578125952000 , 704015608255264157344324073568030127874811148800 , 798963016382684328350696295578581367347000780800 , 905509098636337237554789693441156644887228953600 , 1024906501185868148856776557864386720224930380800 , 1158522389995223735905893634488025063428327763200 , 1307846484931694377274162580613116783972406003200 , 1474499388702146171619922609245520386702250656000 , 1660241190614686277935227094027938225493325952000 , 1866980321559592119236697145409668228117807852800 , 2096782631072341667672288739918988111634834265600 , 2351880653443173752982192350908677512464548844800 , 2634683023439929353784165826206235117788883865600 , 2947783998176666452453776547696766689311328665600 , 3293973034365781207934732012375842501213884211200 , 3676244366246076232170263367106468396258105689600 , 4097806521260357499500578303909754467437782016000 , 4562091707003395599928856715111365504485784812800 , 5072764993786433827933254770980435752935091571200 , 5633733214401235614563178392955856306830128889600 , 6249153492487703533331722668207041679729675955200 , 6923441309439926218679960092332626728934638329600 , 7661278008521861434310028032782593451227317721600 , 8467617635316510976915037129677137040837749024000 , 9347693001147193701972998190156759628181931340800 , 10307020859257033992965653209388180682189898432000 , 11351406069600535619342323525873603266432437606400 , 12486944634881370466086670081374780741973189785600 , 13720025474742462921095990502570676031098014336000 , 15057330816554373461455350711338836027272743865600 , 16505835063198277741706278214069044375732842892800 , 18072802015894338873431752898272510554213197856000 , 19765780308987251728604443192772933356079882265600 , 21592596938985812808181315726522570518636117254400 , 23561348744851924803882750806283469974694499827200 , 25680391731570907111889939196140865337192560518400 , 27958328098092939880421163532255148532206609356800 , 30403990877727747393649479293525631089866158259200 , 33026426060493715822279839636260285195927843942400 , 35834872128621052058495827527784058462894654016000 , 38838736887570921509800871900620734478788797491200 , 42047571554618053537056275398177101634530582662400 , 45471042004541833961726197163093263754905741632000 , 49118897173616918649861914715046624670849090553600 , 53000934542538549508290556035274453658387630208000 , 57126962747305981060856778530267212159665142675200 , 61506761262971121240786636407678390446828542988800 , 66150037266037695897809177415009622230413315769600 , 71066379646712058680469034858140089044826470041600 , 76265210342607897437692665999200093105337654489600 , 81755732991840766511802209659043307283121166412800 , 87546879151887776610991143641666856358266835660800 , 93647252107351032697635453399846900792358348185600 , 100065068596508386153633290073162255966232862758400 , 106808098500901171730131440617781580287988280908800 , 113883602919873968843504582202878808825817043097600 , 121298270688294961217908372953788676509137190016000 , 129058153859530623818323288548713072314319848300800 , 137168602215362313695398786461430402883037524774400 , 145634197432874648550164838105133146488326896940800 , 154458686958850200329871586288269971435951114649600 , 163644918337484345677048565640414944261774513356800 , 173194774011668910187270128979527367915320164352000 , 183109107467243612350926384828521251067608902451200 , 193387680686405610181521520215333471317145047040000 , 204029103911483605394332380896882945250098957107200 , 215030777601950970890700785738003355959541891072000 , 226388837727327892374549927405355014043610672332800 , 238098104160513273344775154211891261530985919283200 , 250152033466755422846575556575769480738006935142400 , 262542675694019854860829706164265875365783886233600 , 275260636626101441353422102295359129519179926732800 , 288295044898397508443150733704471531954175349555200 , 301633525621819094439268904154829877465462410444800 , 315262179655163723813217021581395400913755824128000 , 329165570377895072324637909222852943925012801126400 , 343326716784644813139814168112170998785684825702400 , 357727094988141285829510925768133220061782076620800 , 372346646565777656125667884969251726106242121728000 , 387163796108786346045977096188415431209736255488000 , 402155475948413428215517653931072647471615858278400 , 417297160736203837131193073813368941248368205414400 , 432562909311735291541999870943320451226090037248000 , 447925416909484600359030790451488685096729622528000 , 463356074507531419791482512215053071241076820377600 , 478825038816452927117901631267948525656691943424000 , 494301308981660119390713682873610559418105046630400 , 509752814029100294452488158153874203787573174681600 , 525146506293900551661013376656416089390381405798400 , 540448465493828987846635998391593632041751650713600 , 555624007736649522241732770546669545283796107264000 , 570637804878919667102100558966910231303111829913600 , 585454007445491829810040793316207822882767354265600 , 600036377423098868336998290115180274824813577011200 , 614348422922641018852789565936051276454873946521600 , 628353542079071541501652069905747582835923588710400 , 642015166815444977854389491266892734589400603033600 , 655296915087240045141142275367424437973524038451200 , 668162740693854279086127687020069407964991440486400 , 680577090730027613950736672363404039314537787392000 , 692505058047355033519421941024974390048006542131200 , 703912540486300341855737718293562331513193022259200 , 714766392327010060640547543447526847902726687948800 , 725034581679714121478787279292969749930256105881600 , 734686337109358346326171738408804752407440252108800 , 743692299463662651816370128004011814881866557440000 , 752024659810290896280000998033669239331083031347200 , 759657302009165727691713619545538856266887481344000 , 766565928159888515375887488445257155527914501734400 , 772728188369528423088059785001022701685763307520000 , 778123790100829999705839962321057573504524713984000 , 782734611835039621848434658805499869958363982643200 , 786544793018940160083785887305250031948228481024000 , 789540828704347803903288111367354537574667063705600 , 791711637190279611157488230293625031480900157440000 , 793048633205713279716622107028027024616450457600000 , 793545770865383491950267820769796671213321748480000 , 793199593514534058317501474609215216577919467520000 , 792009250219953390587586601937154688509136404480000 , 789976521054645801727324501771028547731097108480000 , 787105805982139354976625050679039633050648739840000 , 783404125068443172018402236489539206563109150720000 , 778881079338977002927552510940353168076551864320000 , 773548826105930297492345239116892479179591147520000 , 767422012112707864199964881826069581951862374400000 , 760517724924320902200672459257054100328889425920000 , 752855399354497345873459859358831607406423654400000 , 744456746600870105610994729781587917565345259520000 , 735345635665359377509736987099788598849077739520000 , 725548002543028693905221073740970480800067256320000 , 715091708999463667614813068792609923110644121600000 , 704006434764163263984958338017631234415466987520000 , 692323516525933782927275679192769221015583948800000 , 680075826624222743789605580701824890584912281600000 , 667297595628043207991269770805593697743451914240000 , 654024281357034225560836826365751302058999562240000 , 640292378787643986088026011487138183093467873280000 , 626139283580507082972749895941178841167385313280000 , 611603093193307233583865381426347228504741478400000 , 596722469288591351102639501996235979326897684480000 , 581536434094369672821133986655575957609557852160000 , 566084235981616960120798830944337356474582507520000 , 550405145123764746971633429955776697524447232000000 , 534538326506470424934954078708651287638148014080000 , 518522638638021894211909320262180025833762160640000 , 502396518072522134905639415546783479527918182400000 , 486197784739488513472881690168955788817011425280000 , 469963541544657900601459640619396889056847749120000 , 453729989562332860580256275535914933211122073600000 , 437532345940611468844339103151086453663839395840000 , 421404671524775043102788485679624943432909373440000 , 405379809830563497436558230438598713861739929600000 , 389489229260541979673696903748347609777744117760000 , 373762985067121527655102730396185440434311495680000 , 358229577822260890385837096056091700022061629440000 , 342915939817167865529118612448690255320934072320000 , 327847310539975512646702137548009372746843914240000 , 313047248407345236400949110448890206623978496000000 , 298537523587138537884535413021910749544596357120000 , 284338154964415864710153953399752700909647257600000 , 270467320175748615463621327888085640186852802560000 , 256941417321021496580391518842138824837068881920000 , 243774991125486000334370069404154755183010119680000 , 230980818480973482805217477041033998627772170240000 , 218569849435166762797182971149111422035287080960000 , 206551314665519188875449400263645007872912916480000 , 194932679755336894323643535619183593880669388800000 , 183719772597201426623353516070900266205394370560000 , 172916748538307334366133094688044811090658590720000 , 162526235570333100731731254035123734856173486080000 , 152549308075567958271058589397473835370359029760000 , 142985646776986751895630567827057506452490813440000 , 133833518917045380154610887977169693808689152000000 , 125089950226078973654595854953051499098584514560000 , 116750708605010972830157658951155542171645378560000 , 108810485586651184475397480928794888310416998400000 , 101262881144196587205222343388604468428860293120000 , 94100591321713737482345518164189297874544885760000 , 87315392247300085990158561549934086120249753600000 , 80898331296784437329733578367722340284792832000000 , 74839707651744040745446341418147976918020915200000 , 69129264892773064267060096056522427424943636480000 , 63756166382079311035496125184563044846859714560000 , 58709186347231446317232223251664518590192025600000 , 53976679083001913481245241517034011675180400640000 , 49546766609022834661274680830874819290281410560000 , 45407299830872556125704641774289716821061795840000 , 41546041618029093924345572127663780357187829760000 , 37950619254835773034045960479152105775240314880000 , 34608700758683987414947560405361801265865031680000 , 31507938828249683367723154597525884832713277440000 , 28636139466970986683009291643069605856885473280000 , 25981196490676973708316003119468961578959503360000 , 23531252380657799592550529498870345656933416960000 , 21274623782248986740957060813142239033142804480000 , 19199953156590098993287820998165840288821411840000 , 17296126579120805533222703181733355734692003840000 , 15552416159721171746813157425286051056904437760000 , 13958389903606025963644356928665868130278440960000 , 12504045756507984345425404321013788315798732800000 , 11179714725519485966808508731522093008132505600000 , 9976185599531108051977175451243047297136721920000 , 8884603435185564851004576686268304232200273920000 , 7896585494187024581503383519428557356521226240000 , 7004115136787127725008825126596616110137671680000 , 6199650411815505534010709126886235963352678400000 , 5476014911721884824044897030254069700891770880000 , 4826498227475559977607763846626416976239001600000 , 4244746141275344214239600830847216981240709120000 , 3724853753021254535776573995345611323224883200000 , 3261254917154836949395484242793057224202649600000 , 2848809708622481084023080924835163915794513920000 , 2482694611663149053905475929620566383106457600000 , 2158483364444585758207162510680831659079106560000 , 1872040254621371364292427121496054722330624000000 , 1619595107464513772965679210942897741955072000000 , 1397639132983104859127636710528512541851648000000 , 1202995769613868140377639682886199363764224000000 , 1032720251575239282109836458384514776825856000000 , 884165097532772943877390155517146792984576000000 , 754885426160596283406629906135601182146560000000 , 642699693216271202260520882282080381304832000000 , 545599707101354964811385701887698621693952000000 , 461808223733449514343535953312444583772160000000 , 389694411022690152274792190251248241606656000000 , 327826801170431636934944761698594757607424000000 , 274895887093436867186597939106958313127936000000 , 229762938791300893561788778207196499345408000000 , 191388122648905366915368979959443437387776000000 , 158876757470220002804746227359704720343040000000 , 131413320557141175276124171668057860603904000000 , 108303465841775812332339483472198461554688000000 , 88915324798421458967542543320271867084800000000 , 72717657104134194816497543228353727692800000000 , 59226588838062153866283765188463584870400000000 , 48041382990362748620668879291804104523776000000 , 38796656402855512274220651202435532980224000000 , 31194209925490060479848206582606939029504000000 , 24961781221282643742214847519016043413504000000 , 19881374166812472327180121254861723402240000000 , 15752530063965152887844811968575306727424000000 , 12418569245679386846858026819057493213184000000 , 9734379172087582162225206037882117029888000000 , 7589031743221070477058379642165128069120000000 , 5879049665425623546490308305157384830976000000 , 4527805603148878525030963861832607989760000000 , 3462292800934765369506348055778687975424000000 , 2630771069515375130751729450409783197696000000 , 1982847301497417550631466819007656493056000000 , 1484161718200980988971701692119310663680000000 , 1100507189359308524597915347509810561024000000 , 809991517596651105519186381723496611840000000 , 589520683381244380252246546087397031936000000 , 425602173619955623041052678419784925184000000 , 303177661769982591309864151993741737984000000 , 214052248160525233443195949638645448704000000 , 148587990360554981397078968839132151808000000 , 102255143965617135281460651515789180928000000 , 68760648373344572719800251707167866880000000 , 45846329015456990017074034219249827840000000 , 29662836851883252863545465134938849280000000 , 19019797611512969845846394771437780992000000 , 11650049409750405790638741214073978880000000 , 7139698927278714103397789601865138176000000 , 4024371896200100172881431109409177600000000 , 2303365833351346188997141181182771200000000 , 1163393682276553066424168998974259200000000 , 611546419569025938529644657927782400000000 , 214043318503422564960065526379315200000000 , 112242227995697198698570946759884800000000 , 1 , 43 , 987 , 15949 , 202614 , 2146662 , 19672862 , 159841410 , 1171958181 , 7857707263 , 48674952535 , 280863566433 , 1519694498620 , 7753218982184 , 37470151119624 , 172219065727656 , 755348247799538 , 3170809749084102 , 12772645323035622 , 49485873158187818 , 184784738407732164 , 666254421006855444 , 2323441087636417604 , 7848817369662410556 , 25719677013505449666 , 81860653908929090438 , 253367751690622389942 , 763441172910533693498 , 2241804618081783240560 , 6421546454120302253592 , 17959656860334764796824 , 49084867397864593710216 , 131202801949289433241869 , 343258439448354809981647 , 879634662125451465527871 , 2209489030845760171395081 , 5443539754449962205973142 , 13162847305402133160161526 , 31258212795053053084219470 , 72942409537082236627023122 , 167356671858481948591727513 , 377735918685766055692036539 , 839154245002386365462644467 , 1835779506828075748765245413 , 3956697292178021221213531524 , 8405797071757905985789317200 , 17609664256040615161159782064 , 36394366070868071749856162304 , 74234493094820365908048982016 , 149498390505876367285342083584 , 297365449062517262764582917120 , 584420423554180063937199414016 , 1135253143460549419142069648384 , 2180410151758775328898420845312 , 4141922038483449867336388039424 , 7784282611020172935311422045696 , 14478306678141280987169300226816 , 26657785274604365572405512146432 , 48602360664707690718022065475584 , 87767358799063404950191356558336 , 157022574311891311625002897676544 , 278388597649459251436734986592000 , 489219774156075728185138015094016 , 852351837948336844213076763442944 , 1472623216076841801050348718027008 , 2523563614420722060438536507963136 , 4290179421985741076377361606626560 , 7237036669626587445097134811152128 , 12115817029463434614251744460251136 , 20134036059210485255703264680773632 , 33217885674083945398787338979095040 , 54418965175004337763119538874316288 , 88539550268764351050414766447423744 , 143087676823015323492958605039422208 , 229726899370073477544637548337936128 , 366463508650806057634580610341062912 , 580926658795688332748851049233984256 , 915258830241278608497509796687042816 , 1433365630136943880885818940680700160 , 2231603220937101694916898911853225728 , 3454447417579373270055579814390780416 , 5317343835668600277386376930090694144 , 8139855897964035107676122603199903488 , 12393505432022839880902423929014431488 , 18770471993569867111085926088085911872 , 28281760747763195891070312159810483648 , 42396804089952639710236636929203037168 , 63241048119014589399394541726477571120 , 93874314653855600104968322412788396020 , 138681181447873128648691420055125288860 , 203916022361317138284510458289615013644 , 298460657628258147330427631483161622532 , 434873036638374450407467701389187615792 , 630832641224146896962077768817824066128 , 911124463852864784124805004679057777648 , 1310351197637717393899240247627764826640 , 1876626158304005012258688159096433703568 , 2676581896941903272831460775864906797168 , 3802137130085287771749238036562932947216 , 5379604709235258688295050674308525940144 , 7581904976160301635346827071560819457232 , 10644883466665233425597362309619947827312 , 14889033922218094624259149930905709864176 , 20748314941277279310462435897807770332752 , 28808243779216254276800528938617790254840 , 39856081645880939287682170143592404675240 , 54946725838376639428852410027348924550056 , 75488937729007255981839729578028168774072 , 103357814319895239771189886776239573065488 , 141041018894835411666832918130761155592752 , 191828301574622240327320562767480552161168 , 260056358696580043617520143238562473458288 , 351424216671816758614067375504247780836496 , 473398221419389537275332201533813323925488 , 635730537624184639338326078042560208257872 , 851121016123699751447752152344526333671280 , 1136059616309586042254688258041635807350384 , 1511895564683437336904217898787921739288144 , 2006190437553688496199416067766338786681504 , 2654425787420019518970153942035979880121088 , 3502152276981695485990803047286020561274612 , 4607687118318763193970151538666176504569180 , 6045490616268894029121230338909810265458668 , 7910381580985722581369525687233074763428900 , 10322786237543708956143013200498413876988480 , 13435257108356143189048429279795559526508800 , 17440548443240973997730170784019382598056704 , 22581594591089002230794692554926805519599616 , 29163808945516897356523977051185458774074624 , 37570205714425241354510286339318154306622976 , 48279947013963368498744514678039193365590016 , 61891036255275529199629258859561985961912320 , 79148018432252920224704224502214464785148160 , 100975712097975463673457518051897522721746688 , 128520190364230956614864144053381699529376000 , 163198453508883327005012658109202275731026688 , 206758498629257244953962256200407480088982784 , 261351797752857640829236379404463540793837312 , 329620551104645534682410265925009682844582144 , 414802493764900602813503374979096525231656704 , 520856509469512044457648398700612778476594176 , 652612853406304898276478530719982649531098112 , 815952416083876392902817929676836362220908032 , 1018020183225864994452764272276769705005865472 , 1267478873775289146958358017318369077363482880 , 1574809682203197730029376648531531208273197824 , 1952668126320762352499635176517578391896189696 , 2416304222842560412323446507406401433436292352 , 2984057596491536049350500463753829350718146304 , 3677939692234995888135234638494913045288901888 , 4524317023434817766404326243028466709985489152 , 5554711371767357232016776680502580504051099392 , 6806735079605347964162577609344303431947391488 , 8325182065349519576818489424614064096097658368 , 10163297971505160813179214271382092604381270016 , 12384255949846996666996553708699825256691531776 , 15062868024758558014835009022128763922167480576 , 18287565782638267169603182601717480948882006784 , 22162688340980297557736705343531680319096916224 , 26811120184700834806267757476613091475858327296 , 32377326549421384179470894378505622538912476416 , 39030839611534578941756502323412655089827884800 , 46970254842815177721531818988195135696771974400 , 56427803531937622932834461557821944220017222400 , 67674574694709967628585704472585503776275788800 , 81026467415136435636819120309738120620389555200 , 96850963105057806861545160542913164633247801600 , 115574816261867924730763548956327000273122348800 , 137692772059892155145617016906316971857174348800 , 163777429544042842481105659209626504005312224000 , 194490380313250414706196464676457766605836076800 , 230594764386810723528910777462947613710013689600 , 272969397435230776549927656825922509334869153600 , 322624636713510242878030024045364171559262142400 , 380720166838227879193636451533568141005601332800 , 448584900965017660273060778453444639101867185600 , 527739207907957394982026437421181472883301662400 , 619919691236282840694639137612864086252787496000 , 727106762318870423930335282419464435906323051200 , 851555265571470375702324348339379962138859656000 , 995828430697661146363506143266423714951544265600 , 1162835443373916923441665969439026249059543292800 , 1355872942479597724340965539651897914715705340800 , 1578670768444203580741517791960682365951672118400 , 1835442303406682363040633205517329111986803126400 , 2130939759438088982834375316622467973731934492800 , 2470514785859276773990365220983927372037516963200 , 2860184780421277418123239560831441197575289731200 , 3306705301557017503412128624990164890087339918400 , 3817648989735734551873331101034371250242958328000 , 4401491414866975746869370267407761009709970465600 , 5067704273328847175840211953922132068448527275200 , 5826856362213019178692886862926640271040672817600 , 6690722759348446473111472144940673981111913377600 , 7672402635240476013953998958812100425077897969600 , 8786446116746444005094218166082084044641006286400 , 10048990611746595271614454999344691817615744409600 , 11477906988710327270045376828199630412719045536000 , 13092955984555244699906188876292632768361699462400 , 14915955187950711361906500379883456790497574393600 , 16970956912917140096181852850807900282010871052800 , 19284437238572735700342604372704615753264918105600 , 21885496444939722401279131871632707630449454336000 , 24806071021158950329464239455634235923663680972800 , 28081157361146170247900807182006964345158086816000 , 31749047191938749118539744405779140860833479033600 , 35851574701763963306687687142538105528435795411200 , 40434375247460205808925651126688335820024414662400 , 45547155424565812237262796443339188828830668448000 , 51243974177372452839747673453509632871328741804800 , 57583534511088718680107080272241461849905958969600 , 64629485243145981512027909070411131078716450656000 , 72450732096562071788299802191023926854905261312000 , 81121757294257166906859599377892775707778840268800 , 90722946660749356628274976660295752315302658521600 , 101340923075729192976058628510960566894077856857600 , 113068884954695324061981826280936633685428183097600 , 126006948253938576874396904213366120895007604755200 , 140262490313517464367769308463053770319877820563200 , 155950493661003523615197214952834081952994873094400 , 173193887704448727192997012988232995276647286035200 , 192123886043351604187211200988444738029793538720000 , 212880316926236078118319751069611426851082873401600 , 235611944180332132341293240382201388396770169747200 , 260476775738955638178908111403165871656992168486400 , 287642356692183203121820821193360012270025980531200 , 317286043594131366365429580309351566823142986624000 , 349595256571046824964935956623255207360020526208000 , 384767705598221522460248611327793137671342072172800 , 423011587144372969759873719202441157223578299257600 , 464545747231595071931439931178246725851226721107200 , 509599806819039380047446161434025104047605700883200 , 558414245303980738345683380679779468539944591955200 , 611240437833805339672147684253304487333270360876800 , 668340642054866106678064328243051981612055798739200 , 729987929874540700198342239913754083287252904800000 , 796466059803324845063492308449606310766172744729600 , 868069285455214848107176660262166521756432470963200 , 945102095844117500186788368988006450789150348992000 , 1027878883196586937728486778071369248045358415219200 , 1116723534139753924584466225255444468478373057696000 , 1211968940285947671074693031607027378441304510688000 , 1313956424462235829230685720133874941685620032608000 , 1423035079082946591615119280213391529870760384518400 , 1539561013485274149129372243266265158134345918483200 , 1663896507390325406160195060647829025780053940742400 , 1796409068073882452228555752833181774851935542329600 , 1937470389268017318571995229106586913032466554643200 , 2087455210338655211658996592523538797061709939852800 , 2246740074814106682200843290118070422834971258944000 , 2415701987964066114834530310257969212255098083174400 , 2594716973746880355235395075200776090122366408729600 , 2784158532162046320064145901352862719321458770726400 , 2984395998742192072701637166998584111068083217318400 , 3195792808723775291066533873371533176163184461337600 , 3418704669197324202676722163630036755694375292160000 , 3653477643415120717926365235515676046165680687264000 , 3900446152242344062306155686580672066425221071225600 , 4159930898667785134933080484981156436501762961120000 , 4432236722121623488823964226228701562824356064672000 , 4717650390310125643619101014867370871879729890099200 , 5016438337102523986133332894684904523990640495411200 , 5328844355974362291310521330061996282669687530700800 , 5655087259301324796828443649684000526923464185036800 , 5995358514742366259959143800461845091672784443392000 , 6349819870670330608090224803293706273435896365465600 , 6718600983500765424533697671011709025852707705241600 , 7101797060378347842085702119405878286461959843430400 , 7499466531489024890951907155538142295632512987955200 , 7911628766729527487144915556498874264341527391436800 , 8338261852154660417379229686133572337592258548531200 , 8779300441903298377032265514591384149647448340889600 , 9234633701848403330483109731415845528346442285056000 , 9704103361270570342330177442726830115373796771430400 , 10187501889228476395210568973852645807506215098777600 , 10684570812101279856690587351695501592622161589043200 , 11194999188950315567503274164032723517270758422937600 , 11718422260867935671170476930282283943768264648294400 , 12254420290447017527710852551050507129562910207180800 , 12802517606707671897153962041732624468103546481868800 , 13362181870570183345210165501187014461181928778547200 , 13932823574846846840455753744459603467231237924864000 , 14513795792248013966479490821568240069344520922316800 , 15104394183455759892546745250741444701715740924723200 , 15703857276642826478567022116270993433868378331136000 , 16311367028023250957744626219371178073677738857676800 , 16926049672171688468211197615146595107373397136588800 , 17546976868746108586586650565448961185808412178432000 , 18173167151225090161587938549636357145646605197721600 , 18803587680881500432412323586841007039051991921049600 , 19437156308098615361761496694413675352734386646630400 , 20072743940441919038075847625001974344718020222566400 , 20709177215752855102337560570827847207926679901798400 , 21345241475623059810660320514012888635131386792345600 , 21979684033431234008877389985124642368619753997107200 , 22611217728056711272738670634315585468313727781273600 , 23238524753318869472148786780341859649696876454707200 , 23860260749929670388084100297022669435311570946457600 , 24475059145883836277664624620575824550560081953587200 , 25081535727901972824284372897358087332920409714688000 , 25678293425852027858993606170179825170842005304934400 , 26263927288789898844580684905602474141397215573606400 , 26837029630947578972393568189656391570138409832448000 , 27396195322643494698880670022560262247892984357683200 , 27940027201260794595891437545862068059679771463270400 , 28467141574226024636529134681264115655420969472409600 , 28976173786453863762444368606580347165657408371507200 , 29465783821728783149300561968604031409284896136806400 , 29934661908670691436755983847957843151761881334169600 , 30381534098926394581206251122943004530070667032576000 , 30805167787151353542799328092870527815294279556710400 , 31204377139629119305542834646098927429158118043238400 , 31578028400751116189042714597053873172790370537881600 , 31925045044215977442562169628254598331058414649753600 , 32244412739020504773997984203616428102177412955750400 , 32535184097857342813317605471640531128804361096806400 , 32796483179679149237631940337813050535598093066240000 , 33027509716070831519502405021676988558643713064960000 , 33227543035565395290613486493156473471695199518720000 , 33395945658329825526493923806633379780548360355840000 , 33532166539060061647580975719205879442351364915200000 , 33635743933816891190490318870862905361753982484480000 , 33706307872962067196021796724564546034614315499520000 , 33743582220536797010695768335220181173389570785280000 , 33747386306855364466537990433483520210816217128960000 , 33717636119650809746539610490613264378005044551680000 , 33654345046414470279098725158335262720926466662400000 , 33557624158218833378594473692260906783264018964480000 , 33427682033643138258047336687291916360983061504000000 , 33264824119235720387654627480676156064536012840960000 , 33069451630658636892652690451416444991177508741120000 , 32842059996850771162601354593412431897007082577920000 , 32583236858045633770907051793986467033196762726400000 , 32293659624977075815491282127612565253625228001280000 , 31974092616159657589090149576864700006940105195520000 , 31625383786741631357013293783312402905182203166720000 , 31248461070478660497559541119274627419652500439040000 , 30844328353483263437344325616054370130210934865920000 , 30414061107170759901634366962403478388917989785600000 , 29958801702310549847720118101198207903178601512960000 , 29479754436122079853535659834814680858258328371200000 , 28978180298998301658207044943396418955264596131840000 , 28455391514837952259355143392958261469046309027840000 , 27912745884563142987504321306197357631645835100160000 , 27351640970629980619570220425388743799122824437760000 , 26773508152138728667582126928113541314310576332800000 , 26179806590115068558751158620144990219554429788160000 , 25572017134937500006024000552516972250376800378880000 , 24951636213788213081221332276609458073231716720640000 , 24320169730203705098749729978022328649250179276800000 , 23679127014876533601258136361333308145399074283520000 , 23030014855909446745997957585077765913121912791040000 , 22374331646546328014737262144700921684327742218240000 , 21713561678668440795940510983107404941446861414400000 , 21049169614283565353402241880565177451308600156160000 , 20382595160875587497123027291287920887347831971840000 , 19715247982218937105767698150958702028618176430080000 , 19048502862926595847594929263736007819552904478720000 , 18383695154889683285159272215800504798225551441920000 , 17722116522891255212180128743715020957126140805120000 , 17065011008358082792995424546248307686938194944000000 , 16413571424637617805254634585158117375432161320960000 , 15768936101626150155106072951880925269783434813440000 , 15132185982741037771881102386691710934611653140480000 , 14504342087957446230411888543478001353342251171840000 , 13886363345574262239555131942396746109304870666240000 , 13279144794528567116301004874533715681676564234240000 , 12683516156487791962400963467792569420047334113280000 , 12100240780005711344235821849315997011184937205760000 , 11530014943655004598934428735742887000613917163520000 , 10973467517162791550747119917521264822176302366720000 , 10431159969815314572027044076930797244329151037440000 , 9903586711953752826394688389022359692280660623360000 , 9391175757149940999471150481170768788571993538560000 , 8894289694425219702518877653932740798786697297920000 , 8413226944912707974112349309342285628922508738560000 , 7948223291543193608808014475577478840482672803840000 , 7499453662750327356603023822199659476801665761280000 , 7067034143952559071706634788004113419033962741760000 , 6651024199330232579895478945030421618171170652160000 , 6251429086297569525083580899402709370350627717120000 , 5868202430335735900543911614577080787794842091520000 , 5501248944794803698117576112031680574013375774720000 , 5150427275250398733764590292892137558324686356480000 , 4815552936828203795174778587651823604905293905920000 , 4496401328821082303921299151245912754018486845440000 , 4192710808236071400603900057371769726768096215040000 , 3904185790066978004479513487423751538720026132480000 , 3630499861716758492173640197081293926981607751680000 , 3371298896264262868612991631195749575692588810240000 , 3126204132349706780648347916078722425925366579200000 , 2894815213283258650026701967201519225001045524480000 , 2676713172540554676531493010852992048998363955200000 , 2471463337198337118369951804706917709371907768320000 , 2278618144273160378162750632406275534970927185920000 , 2097719864131802183951141723016673497679095398400000 , 1928303201941288787799170538615929325795254599680000 , 1769897781448952056648656955732536988118252912640000 , 1622030505126669839695921858831951766003560611840000 , 1484227768750914316047018776107439033513947299840000 , 1356017535689698260950092522640833017727189647360000 , 1236931274747224348248720855747919354431915294720000 , 1126505735867099910639981323188932427067584020480000 , 1024284579881671668891439757634717633784906383360000 , 929819865033458259708735412152033374672191488000000 , 842673372599984921440214754276671782830939832320000 , 762417784937954193427858374052376850307381985280000 , 688637730096613908712654429210822371863140761600000 , 620930668448861539301305542189419747096238489600000 , 558907647801516199156500826582267362076514058240000 , 502193934323585482335237847617924993397916958720000 , 450429503381636875061153464662419453746992906240000 , 403269412722389855413674088413592714651246264320000 , 360384075667694033653360281057249607329227735040000 , 321459408461286351348157184298566776113235230720000 , 286196885691623737194344942262851104071139983360000 , 254313513976218091692209001406258167199487754240000 , 225541707069714460665830330332336505618088591360000 , 199629086304684288767887244043408154267586396160000 , 176338228336113478321248551713156223999307939840000 , 155446331083867644310705437454891045189244682240000 , 136744833937944823207790278567888410484211712000000 , 120039002875144875741215767596031888576806912000000 , 105147458162044230413186576318954818311487488000000 , 91901673898781648034083735340316249297256448000000 , 80145468546999160253595605806367643248885760000000 , 69734450466002643317089285318135584523812864000000 , 60535458099234123466633326937645277910663168000000 , 52426004017747281959964881115993656282185728000000 , 45293694991639254091564499517775328641941504000000 , 39035655899710258408393403933582163863666688000000 , 33557974616791245480753594157925392896491520000000 , 28775131232442515356296455823279406101626880000000 , 24609446523572419586728784164075875751624704000000 , 20990557330564190784577639015178202331152384000000 , 17854886474771471572547637669307268033740800000000 , 15145136280342561279694424825196067789209600000000 , 12809820873869136867350576211707077003837440000000 , 10802791739361192521444373727816164197793792000000 , 9082794814091558798274408312191698776096768000000 , 7613066908458119899855022498848002048786432000000 , 6360930799039847439703631362771813851463680000000 , 5297420833514850697403102906735051805818880000000 , 4396948097681193537119153380802368144146432000000 , 3636964851852208282398335656968362095804416000000 , 2997661477717464088206232927833020782608384000000 , 2461698043895698925309498681403495992524800000000 , 2013935714018326584829340220520351200706560000000 , 1641196030271866577045085067306834304434176000000 , 1332057639667022911658571693585614820605952000000 , 1076646377684715730390735183767747201859584000000 , 866450555291337941506527847582833775214592000000 , 694171006163389032272221962242728931622912000000 , 553563462209020407520218458513564283961344000000 , 439301908926187473411638854000837480415232000000 , 346872072536913357361730497582955237474304000000 , 272454035957954025906850612585046741090304000000 , 212827513055523625709248682823810180710400000000 , 165298144922666045250417120600731418624000000000 , 127613340694131239448881189229419575640064000000 , 97896511127500610522121240745171916685312000000 , 74601485830608282757194144755653483167744000000 , 56453159192265377126979817398398739283968000000 , 42401957100070687018547815564748053807104000000 , 31597991394404005545128958916007062142976000000 , 23351263882012801894064147128861253959680000000 , 17102025174136724948463957204650352967680000000 , 12406032565685482188560395315389841539072000000 , 8908020433003014440647022736720575594496000000 , 6323991664517664740110121378131784761344000000 , 4436091771438670772897800611940729356288000000 , 3071879965009125562857273997516125241344000000 , 2095333753362943825753507648470018686976000000 , 1406574968324024774748311626820528111616000000 , 928055488234522996916056976262948716544000000 , 599572402364768871189755516788842430464000000 , 378108913104158587634961825447857356800000000 , 232784361227687516544380074041802752000000000 , 138593131597136650270630024174790246400000000 , 79366371097834569764082873314731622400000000 , 43815244993239502704267509992154726400000000 , 21918557871624869243532563719598899200000000 , 10354998103696064819470487111545651200000000 , 4826415803814979544038550710675046400000000 , 1263377636044591724886240423994982400000000 , 1 , 44 , 1032 , 17024 , 220625 , 2383232 , 22258540 , 184242832 , 1375813879 , 9392612956 , 59231706500 , 347882427360 , 1915687145439 , 9945689719688 , 48908578320232 , 228716305480000 , 1020599031455130 , 4358639437474136 , 17861559750499648 , 70398879075228096 , 267415941913571642 , 980822657287709536 , 3479404268454792648 , 11956236432632364320 , 39853552289733429118 , 129027332819160557976 , 406214689055206755608 , 1244999273975895293312 , 3718521399697308262894 , 10833753299919558180528 , 30816951497219058297280 , 85659331948075738893952 , 232855278721976145031093 , 619523682814505733295100 , 1614387450679006125638360 , 4123237087636491600418496 , 10328527488371933975179621 , 25391261206233770785760992 , 61297151512312555766988652 , 145398471601460217592050128 , 339067322737780675988235739 , 777771159401431532955406092 , 1755826262087915564405866564 , 3902925573839498569584478368 , 8546432396812559272280846147 , 18444383963989219715672585736 , 39248162590912714523427695416 , 82382360977320650138772219584 , 170641899936704733874930110560 , 348934347293431841944674851200 , 704647545305555165546882488320 , 1405813473807179239800043355904 , 2771803117393657839989271461504 , 5402834004036375560058893363200 , 10414671676963168912068660933888 , 19859536990270457583769802699776 , 37473307712374412092254978484736 , 69988913806994579398454959487488 , 129422884035971230537529553418240 , 237019078858375273738431623418880 , 429989143703423118283741299472896 , 772931609458857247304060332981248 , 1377011457193746279523418325100800 , 2431905537129125673428612518924288 , 4258578582375931963847023706273280 , 7395782849730412051606045578877952 , 12740737318724243586105852915443968 , 21776202102828253065732053567069184 , 36934318890164134114976621753884160 , 62175422178862835047196841386779648 , 103902409432937179680147738220832256 , 172395369428007402207983465297122304 , 284047519490641976486738645049551360 , 464827394065385196493303461691363328 , 755605792265712327214201401834272000 , 1220301059872294985733326235263213568 , 1958258359879967019694126954192961024 , 3122952374155469376893557141752300544 , 4950079851650349695310945682216596224 , 7799517208500935327601677936854770688 , 12217638920417358145269967673552581632 , 19029375104358180503998923408265214976 , 29473478105750730328560459008715989504 , 45400245623612055261591618303694861312 , 69559066570011879079827352794046935296 , 106014508650843644068900634336531618048 , 160745466486091093850805954307582718528 , 242503775507973914668194012195998412672 , 364038876154917988273766933203575662928 , 543836540780768249329309625494223181936 , 808576294910510020838217263963718273396 , 1196589211731854638784030371535967448368 , 1762702160422051285836883250692901992128 , 2584995468640679896858911234707022800016 , 3774190286419144773872833020679427249244 , 5486635352544830428388122718279772591168 , 7942200721684507300682045579755040762832 , 11448834704136219130988562390606391010304 , 16436133891280198650667657181316087075408 , 23501058558280394289454368284321614672512 , 33469953197945187833199405981754103917008 , 47482376300095128124198746887241058577088 , 67103996215780828617691275946575242835696 , 94478087057552518933032126134152845926592 , 132528106748382870900171105919909566672048 , 185227643303041310572624615103527874506464 , 257958907180158018667557738958093126204056 , 357987217360386565771762886482865672852064 , 495086938741374554721771229729638821133456 , 682364528601005130857256601354680646131168 , 937337298062685681687397064200288166038344 , 1283342879745464546681636489703035109387072 , 1751375063641175715766460030237939744595312 , 2382467661424717291652341132388232912818304 , 3230780659828148449431507841008232367717136 , 4367583682045795070945855184047136309271296 , 5886382584957528457977821031068325406434672 , 7909498174733887684832447977838613602043072 , 10596484300309025176455572220954403938046704 , 14154869330758967552916623268478651186409664 , 18853824263929084198222529811696799761469248 , 25041507275183517613265923666866641571308592 , 33167014166260107654773716772790279157151892 , 43808083792139257156766005163523051680082672 , 57705975305084920905627071607088486031976048 , 75809259651512318986776598479695870884686096 , 99328662648573071589856873700520013027600956 , 129805574661182164571890544427143336170545024 , 169197418281180676196497440579602820296835456 , 219983759098934367671064060376807785556297728 , 285297877433024914895923230919702274878821888 , 369089516135723887052188824124940833004470272 , 476325710859683644101416565198428718348052992 , 613238028701686125028598133554130472030368768 , 787626228566166054290577705472672659257680128 , 1009230357611324838386609660562245599175221248 , 1290185665362944473799535245700444678062734848 , 1645577510823976286506844075647550873651039232 , 2094116727255498672990770823621274476487279872 , 2658959773015682573285720009468477623928699904 , 3368702524661087445396869903450884610576589312 , 4258581862157360339946134470271126139680732160 , 5371925370833605206588310399557517713801801216 , 6761896670571661706256928271783048831504630784 , 8493592226214023926860742787398219686443367936 , 10646555158399982793565716304753300887397662720 , 13317782745213668858596579555541650993233864960 , 16625317187038405623316487152856701381702029312 , 20712524028782549960661385438852349460720532992 , 25753179647981113020096030838559744579996255232 , 31957508705384647997610281435579202968377925376 , 39579334724651226620043899056054702364396246016 , 48924532360973932958800217141561491516261029888 , 60360998805662203315973410527916516297337994240 , 74330394564049556916114195352710907522238369280 , 91361940977701334833283720769826724716528309248 , 112088603823065965505288494174282901106351095808 , 137266039622225085158429981400925949414355044352 , 167794734512824210610295463105386619937606956800 , 204745825236197979933545724722836555406385641472 , 249391158666282968199003318240402651162544946688 , 303238220987232239113120107071051933115926873088 , 368070650873130555826103927113655704425140560128 , 445995143571216567090177192679250548107113192448 , 539495655464513183540130317375730246510740703744 , 651495932293370267739614800835166303017201587200 , 785431509651642631161470330217617467658390361600 , 945332472483938663957402834132926922324909644800 , 1135918412067711672448441031535321001630637376000 , 1362707185216342611212061328645630443164111616000 , 1632139262211373581482256998947773617347201689600 , 1951719648070931166937632855651619754795736883200 , 2330179577243083819800110116307112932158501017600 , 2777660415376731026049444253938686725310667974400 , 3305922454531185562783813695809661867449893075200 , 3928581560539624355007697262970212377335049728000 , 4661376924284560499233694388251895665687774952000 , 5522473482556813093672030607430076840603698912000 , 6532802909956013274029448547473629094557271580800 , 7716447440653706587551828262385615797997172057600 , 9101071158732482584358489999836410341601205593600 , 10718403797254229907839943385904960801268823833600 , 12604782510115649994218515201409498072620379049600 , 14801757525183135141908696845970039785011291648000 , 17356768053103512714742789707839923329059971214400 , 20323895310321330741785612649337953390253641446400 , 23764700018290172326465474110023194394934479289600 , 27749152258644026806843509371507912813867762764800 , 32356662097674293895175706859478971973836609254400 , 37677219935479851885335299627262667040137519916800 , 43812656087882164762267763972377980221731186080000 , 50878029662119366475820089244887331387667794355200 , 59003157344120856113599902146920478135632621828800 , 68334293261116963416567983937868625508816010848000 , 79035971624488992642967838273896295996307967958400 , 91293024373815394999043879008686590835949101350400 , 105312786543835851060825756993684443453313004416000 , 121327502533749571435205198260346810811322931059200 , 139596946888549530866480977882332638135062404547200 , 160411273567133734458923518621124526771659219097600 , 184094107996180141935492797147005560520471392849600 , 211005896440858485374180108122661432439201422937600 , 241547527400767212864502496279862704825738483328000 , 276164239792392926696384719896577446317380661683200 , 315349832663990264060907339648109427624373418598400 , 359651191010708276633505305899862851273437317990400 , 409673141999809663997071524919644007481121778425600 , 466083655450054523467804631153225644289466393139200 , 529619401856069183048728166533566304175123064921600 , 601091680434414455865404989497076180121473165440000 , 681392728765776535294886492975225851808095272864000 , 771502424382127578533436275481017416740194352921600 , 872495387343822073859120922959194748128040712998400 , 985548491150662303748647177301212655733720767308800 , 1111948787577073363579467539852103645861840613977600 , 1253101848782716416960709798600845307570062442521600 , 1410540527805175633534444922941515382007265082944000 , 1585934135705954491272651586415860091315180216217600 , 1781098030876495635404681499585680077252900319673600 , 1998003612526679946263026530782986591637837017497600 , 2238788707081443192513306133999153538743961736691200 , 2505768332034894258370228691290988563929356710732800 , 2801445817991620316398275146530618804691556108921600 , 3128524264725298606013921868823144607193713079321600 , 3489918302779288182880352803978376619892798543334400 , 3888766126493757957290207514669673665920240267750400 , 4328441759624012862303220411466464549889602060684800 , 4812567508332457411198201573851291249320007362688000 , 5345026551314413139847296524885850882667677287910400 , 5929975609708699360063177072104603830301380376115200 , 6571857634279179301889762958666259691944800026131200 , 7275414439547931122561063808758528741821904660736000 , 8045699209468570450925512344789071704707959420198400 , 8888088790770530646070115616620824630809554867328000 , 9808295685363012511640540180573376983235441228729600 , 10812379644130350815137842930155364887872342669593600 , 11906758760405574905226387737265947979393550076889600 , 13098219951806638765152036897525329744503575108940800 , 14393928716196977253742119360421426234738590219763200 , 15801438037427792044831732204410174563962155894604800 , 17328696315229236850904821202414187767093420740800000 , 18984054183030263078556348580649350667177962936320000 , 20776270078432832370291658294564979256133960117152000 , 22714514419969302949777232399547340351914292801843200 , 24808372247661591585357638290570241013165851916787200 , 27067844173196663457902713878802214458586355286041600 , 29503345493187849228304139515569095658006106733510400 , 32125703306482624437305960499104554522825159361356800 , 34946151488843754469839613608461417570761629685171200 , 37976323364679770202619971385844766638238190798617600 , 41228241933669057256482148321402128289572461841600000 , 44714307494804362899730966482567215027306978868249600 , 48447282535607672910110345680672015383502427909145600 , 52440273736522253602638825831720111199631076358579200 , 56706710974203772009242846364216538404167352280467200 , 61260323186203655541946020308284732090734608615270400 , 66115111003408581765365720991448698292079585430336000 , 71285316030448034860206656456912606480282486958873600 , 76785386710235218507158397079017845746667706225344000 , 82629940675847248251316251067559224069125248878540800 , 88833723563223882697820094025299674000300395195430400 , 95411564215964124828997147039279760724405096886425600 , 102378326300729957820551772441171285647812802166278400 , 109748856297226507773623623978172185409374579214054400 , 117537927934023911608070908113159353891316472840704000 , 125760183070749674333140462537271956051934641662336000 , 134430069158215425413414245680665267722100968528992000 , 143561773316340960455833303109922248886398298098073600 , 153169153228923529045428536970402037403364858273792000 , 163265664935779077062387668801109193579156512027443200 , 173864287795396576456331809029311671108270775446732800 , 184977446738851840559111081602638547033900074398515200 , 196616932168075294229477812691545003105360171334860800 , 208793817656814442332633819421757001981122794940006400 , 221518375892358501053149536936763698445469221480857600 , 234799993048793567623292663667623051355858881907916800 , 248647082118854303828175291578750195646282334235443200 , 263066995419587605973621612729582006035586230960128000 , 278065936890890484533536737044225461034667646417305600 , 293648874415390795464959721580767718210149423651225600 , 309819452872839646132273953917584992650742313943040000 , 326579908156053573952055805001859331100109351736115200 , 343930982956914977368205942941677726949037720921702400 , 361871844529772923886445732977520879813261979710259200 , 380400005336680724030925990418787942332937829394022400 , 399511246739921033092131175665050300249696648277196800 , 419199546742664819702058559723279583650469629162291200 , 439457011875077882221136985027907840313693931336499200 , 460273814323728878096963346903494251262740283794636800 , 481638134303388877308145197788217381523295469664665600 , 503536108867385662403013224296114328930509174734028800 , 525951787023107241740533862020354874963355140839833600 , 548867092450217195228063371149637599111166271061196800 , 572261793517271525537629984233979542974804744631091200 , 596113482000941624333143760661302295001827149881344000 , 620397559990677182865382396685109994393893803723980800 , 645087236498000143869292393364454245066095060080230400 , 670153532994380555457928767044381150612032671380275200 , 695565299525066482875072631975919141966247635821363200 , 721289240313958957537444692348658680264338061429964800 , 747289950653372181482669221285946687729512245329510400 , 773529963632048919112487106784108894534777547725209600 , 799969808666332089240822802067337498772217201201971200 , 826568079969253578450815127624161412256819228252569600 , 853281517126931447371795237780620841387802891806310400 , 880065095437557798010142182617962442986620967765606400 , 906872128428741270984432737580566101708028354155315200 , 933654379665816377064424660656139688916124736805273600 , 960362186564880855824686264335916495715472832433356800 , 986944592712610775944629986022305049841596959839027200 , 1013349491769513635555408115265731861737276291850240000 , 1039523778775259534077120730403206325202993094187417600 , 1065413512372017760562830482099177775891276315126579200 , 1090964083005869716463792979956914571594708984714035200 , 1116120391150496603373368359528641754306809699333734400 , 1140827029772585629576270490228388657400187899074969600 , 1165028475718113291840292934477185644295444097848934400 , 1188669283308737111218002236195509613203253938343116800 , 1211694285582390034469506400351252256239996594783846400 , 1234048795444393070381434685403054226724522019294412800 , 1255678813052282912516928481604879711894884224557875200 , 1276531230573925319016997366048601667294778668004147200 , 1296554041687195402778763905048737918972744656192307200 , 1315696545718082637998424179135006496937773516256051200 , 1333909554999754427654738115359461211585043566907801600 , 1351145593986444138927322853390059275751369987276800000 , 1367359100101998346523118427447384382586867897999360000 , 1382506613356043763480844003190895264835937861959680000 , 1396546966313896538807744891089843645234009328517120000 , 1409441459795830294468924267237029273185724807413760000 , 1421154037717762039816548127744162456838743476142080000 , 1431651444630457378485423744282913006850081959772160000 , 1440903381426297429080248801067862961807245717995520000 , 1448882640765129374408183785710074568792617889300480000 , 1455565240007320783065111444544783167912694902743040000 , 1460930530986655634718809792209925027078767762636800000 , 1464961306997848484880729883133527965202114691235840000 , 1467643883897091047640827050400077199976540888268800000 , 1468968178551376640878548939157277088932659245219840000 , 1468927758850089684618193077997605904078576097525760000 , 1467519891688438454530311023121322846792912158228480000 , 1464745560166768065410938834287013129526640949493760000 , 1460609479899314882161894547435281470520399590481920000 , 1455120082428869262926676369953428386977616023715840000 , 1448289499434823214954969317516101483716787164528640000 , 1440133512160294892233783859130570549962502328320000000 , 1430671503900356682180236855144889288254985367388160000 , 1419926376042165922813780468451110263514643976683520000 , 1407924469999422101506064794660831427990482281431040000 , 1394695451257648995261308203718957706717126513623040000 , 1380272202708786350906972708892951882034044425994240000 , 1364690678822581127884598003647683208381856686080000000 , 1347989773074388244461123740156150226522785256980480000 , 1330211145066846764249455547630220678830225901649920000 , 1311399065379165224307132111571085111981871576883200000 , 1291600219085663565114949941728976767180617643950080000 , 1270863531940110148039424127213973546655763818250240000 , 1249239954219712280699425968921841919016517479137280000 , 1226782272634180771742999127878819235335012155392000000 , 1203544878842319221297329003659688081768237360250880000 , 1179583571778402384120564894198342539518452357857280000 , 1154955315479337774811467166438912036701055656591360000 , 1129718036754831318701218834901432907331304273018880000 , 1103930377058385862141640623370625394594938828718080000 , 1077651490521840010015343523624134247199661304053760000 , 1050940794638743316977681647379375584291736948408320000 , 1023857773565111050788024555329834822466464564305920000 , 996461732281379059107232323380371673294830646722560000 , 968811609900306437421343242042672365501205509160960000 , 940965741651976066134924757377058201759821356728320000 , 912981686649516040313040748257488566362360133017600000 , 884916001713840699661237043961873706023629457162240000 , 856824087533614723820105494292427850003183441182720000 , 828759977909012882760874193795283848648856879267840000 , 800776207765783001753024732227950535650116223590400000 , 772923620742336989630855698468958564872030523228160000 , 745251261953321735556061152792590756107925019033600000 , 717806206284021440541523043587014227566237715005440000 , 690633478019771606729986401602632384174467754229760000 , 663775901596868043419786132971342087714100273479680000 , 637274049589426177647503132880583351539370713415680000 , 611166116842245209355534673488625212205801679093760000 , 585487897656603445691227081043981105863018819092480000 , 560272683633546739410274799992458018090853906513920000 , 535551270037204804466682291932809929046336823623680000 , 511351877085351196781421974834825701671495448657920000 , 487700184904029410064643976736073250711006104780800000 , 464619277194143363093664493023406851367002219479040000 , 442129703651235903897483733098896953006599870873600000 , 420249444502334878482511671269693460401881436651520000 , 398993998490215280806580475028887722317154766028800000 , 378376366388121782201186350816028111198138636697600000 , 358407162315517789973859455911998814395183084994560000 , 339094613685140820878222410883449332902109385850880000 , 320444693344853947837866458890004706514220663439360000 , 302461133278297987447540626515288039440168538603520000 , 285145574479203768361186371364648656693097393029120000 , 268497591653835314483489904151026017537324616253440000 , 252514857737392288452769838008377357858410590371840000 , 237193176403914369681418889578575366155377201643520000 , 222526658185458993353563930488032730854209072005120000 , 208507757814085588630814125234468780483047275888640000 , 195127458515547980555091161577805352071135572787200000 , 182375311458980870085333770254299595478379134976000000 , 170239625138729658834019401185248590038035049349120000 , 158707503928975590062200354230838763431488824279040000 , 147765039822510731270148613994730987795860922040320000 , 137397347617791534505643483427845553766358943006720000 , 127588756001963401066380012117967213629027591782400000 , 118322837409422473530202129962855895204363228938240000 , 109582596050209715851056887591353706557833160949760000 , 101350490249517101872428393297095977751445692743680000 , 93608615578804847301393221795946701102023869726720000 , 86338718223853253499716976881540457955856571432960000 , 79522371087702908444826606921373618557742409318400000 , 73140977385927442463978368346937947450409788375040000 , 67175938359183152245950172877951502413561936609280000 , 61608645966966626457362038960647135211549155655680000 , 56420641497561285740308397076354269708828839772160000 , 51593597075351776132579122448654989359059650478080000 , 47109464000056017340246144354908974270525409853440000 , 42950443459999237865533254089788631793163692933120000 , 39099124272894129380233984566288796117341626695680000 , 35538442638564946240742317416700778086690140979200000 , 32251809596195898479200334530460596949459628195840000 , 29223060500581153109447707410795049371054291025920000 , 26436571808352265398117937838432639466475133337600000 , 23877201586568109733541405343246066950513193123840000 , 21530396063031937304985019256891502747758100480000000 , 19382121625109807437715935295368521731071813877760000 , 17418962159805701648671764738064462126765776568320000 , 15628043822008945463702567397488144456285127966720000 , 13997123176978447928841142541059172889063582597120000 , 12514506550502078180056136688687401826404920197120000 , 11169129820560854511136408234614128662325845032960000 , 9950472985887575335490655326533199588467408896000000 , 8848632972857522345531008362836989092091920384000000 , 7854234858172866680399154606560991021553680384000000 , 6958497751925328042180624092386696256398098432000000 , 6153144604389284735432562840095864266844798976000000 , 5430462047944813315291144253690597462097002496000000 , 4783209247620398152512485039791031947929059328000000 , 4204673100388080300510468114621510888686223360000000 , 3688577390754588948637064893050646820949590016000000 , 3229133204915920097295793435318458338252292096000000 , 2820950110170605508632709112625521341629988864000000 , 2459082534053205755082631558863503967412617216000000 , 2138943006154793415294457262239825426821414912000000 , 1856345736042519404468117378621370344073068544000000 , 1607422844906114804282435245653380723324485632000000 , 1388664675964046308149626660398145597445439488000000 , 1196840418721886867240732129224794595078963200000000 , 1029035641849112372801185995363535602994642944000000 , 882576871394015441881760351214572767039979520000000 , 755067420698140246598438555966232725444100096000000 , 644316437301782638872945861810828396447399936000000 , 548372284401591459953675149969397245544497152000000 , 465457101537003644649607777835366646923919360000000 , 393998031749370388876868826612331387602075648000000 , 332566470073416060448481225569550730793058304000000 , 279908034205567984278639905760277075215777792000000 , 234886706934711699244546002003056644539285504000000 , 196512617139763345483905329125032106943053824000000 , 163891841212013107688108481541916588469387264000000 , 136252192894436904561118356232974232587337728000000 , 112897553006640232797715439860812903541112832000000 , 93232527094802148806094481309874407505657856000000 , 76721276278341293681053231535981576419540992000000 , 62910024900391793116673852068371695728066560000000 , 51391019773368502093821583669333635952017408000000 , 41823031721675043575512187607548462899396608000000 , 33899218761635956963637311232792027713241088000000 , 27366417696636270663925610351556376412553216000000 , 21996761306413100076133622332911254696361984000000 , 17604868884365504533477269072761309544579072000000 , 14023666366032876045719765384475540524630016000000 , 11119674735602981065773571567525494100328448000000 , 8771800895772617599253988534705497919455232000000 , 6885501034561963057604747769394150363889664000000 , 5374413323641207436198953542566303596806144000000 , 4172544465938820309239725895397487335702528000000 , 3219192839896409904821130909268167880605696000000 , 2469367142867885658513500287415459392782336000000 , 1880848006595160131023018102513136931176448000000 , 1423632904635700915899255485545883237351424000000 , 1068962577471101443927818249317211873214464000000 , 797160413708468288009456338928100156899328000000 , 588955824088480133260499859228834020720640000000 , 431944579821635878118584758806198989357056000000 , 313283335620375455071989339258380441616384000000 , 225405282965790682150008359644796238692352000000 , 160033710948148578083941847550205322330112000000 , 112620793248481639194435951688897309704192000000 , 77928872361453934426377566099875615997952000000 , 53462001899120163580520831312007681540096000000 , 35840754533887450322866453441744050585600000000 , 23825796697295626859077925413999293235200000000 , 15370653534440206259824229334190443724800000000 , 9827704229375671742958875852134573670400000000 , 6003053630988123457054502360476286976000000000 , 3669035222337451779590286549043485081600000000 , 2062688475298787385274184634065328537600000000 , 1177577588737183191834565377018298368000000000 , 593307196616511406404427486389180825600000000 , 311132845719700641834329395326615552000000000 , 108650476699834888340216676463568486400000000 , 56851993622006627619880819079774208000000000 , 1 , 45 , 1078 , 18146 , 239803 , 2640055 , 25119048 , 211741156 , 1609749455 , 11185787747 , 71784613478 , 428979657370 , 2403245977101 , 12692015290177 , 63483958940668 , 301945023223712 , 1370289324699850 , 5951330784272754 , 24801180523720908 , 99402130247161668 , 383958223710396606 , 1432008516670401558 , 5165489264210851776 , 18048716451454741272 , 61172773233230382126 , 201375199412157938262 , 644623594430858408988 , 2008806587066738973124 , 6100262512532156859882 , 18069888617323877629394 , 52257863070381960078472 , 147675036584844224092304 , 408104705095328948154197 , 1103765398715124912405393 , 2923732951303295136302270 , 7590221759975052513937882 , 19324728345806133702618135 , 48282324932471949463381891 , 118451547383606744018231384 , 285510514499037601540675236 , 676508200739867312561352851 , 1576611817224689254003298327 , 3615757632602641626285435070 , 8164133822711515467744454562 , 18157766652215652501124175481 , 39797306323212699694187303069 , 85995117836660731603523969820 , 183275984892864630118872078128 , 385411693115787715119134429776 , 800020454700377016414391528448 , 1639823736259758326442775078400 , 3320244256084157047214385381888 , 6643099583790560531302834688768 , 13138470751208519045549026716928 , 25694032804331602770619824255232 , 49701331575996847902134005099264 , 95122222713511380500463455195648 , 180176985629783953984631106003456 , 337862948418853313705151969470720 , 627367339604474974532772622959104 , 1153865728830477547171197529321216 , 2102560826591211298951207952034560 , 3796695793242374371098330042686976 , 6795591456534142503863443580494336 , 12058954912621690645373982763800576 , 21220046420811627765994614172093440 , 37036271245971435586532002513623552 , 64126764277575112394292630993292800 , 110170774850452394489488101247855872 , 187840597675896497059010002995071232 , 317897200900306478727353376847511040 , 534113655337123683358510757717208576 , 891052716245169128541104887101419776 , 1476272121976231985591898522194091264 , 2429354899457357591530306218187107328 , 3971394350736357514531858845919072256 , 6450396163586718655706008512177405952 , 10410769817189016841946310033646449664 , 16699064879631319380825699807037873152 , 26623930908103718999632270000438067200 , 42196745582352107905547335824795684608 , 66491598034668138834105679880476309248 , 104180924958899329620997787174095553024 , 162328300129556408700426761106708396544 , 251555765655542077143812819774546455296 , 387753943947557554441340689403269375744 , 594574874329249966081460083002048485632 , 907048152285712720486823613107062267136 , 1376801529648955367112607974723364207936 , 2079562624954336194611611500528698567232 , 3125889031493051280790261880125860874800 , 4676447145065350088281043492456815560816 , 6963671999659743142218085107713063035716 , 10322340081156214875624674643868197520020 , 15232539359460539315565458986232738091816 , 22379811560199304088487337004869554832872 , 32738984340871881396899857648366117652580 , 47690554504447908518943013801117192765332 , 69181622686130411832424757649287289208800 , 99947569424299711876083142166620698326880 , 143816232665942246271416530746018227107968 , 206123725448091265018350399219707639465088 , 294280771747743614542533935092160127301152 , 418541247928887121488806200309878026787168 , 593041405923067611734401589798388285341664 , 837200182892495686276771305688755075548256 , 1177599547437340382304665198715887970411072 , 1650500867265558639679557026052814560837888 , 2305201174976541816478797096807835124712552 , 3208494939936254266810026647378830009018248 , 4450586271241619124390643760683602275637744 , 6152898069548474570565407626046192339127984 , 8478354367736563234117754071375372287228168 , 11644877235560754482209704602541497716431720 , 15943049206877109484140910870696889089031136 , 21759157394501101735114589983686814604482080 , 29605170067246061312702269093323600043064736 , 40157617419066816458836995121378716000285216 , 54307876332977188816686265036695259155668256 , 73227019524847870859046214055562154165233120 , 98449213497621282217660217356022437171813248 , 131978674871133935515115635878195580313406336 , 176426466487491480345651968939170341052288272 , 235184988364449679986085383246430160289570576 , 312649960552409667141799753055020124690252340 , 414502085165947269102673020760502193108208452 , 548063509142318328995956302660605833159707048 , 722747802235738911181879308429214343850964776 , 950626553088082030613680845745155203612677620 , 1247141032546749201032466265436479962137353956 , 1631993870687840125871321057114964973695355584 , 2130263570607413119971445035662817052511304192 , 2773794207530387627011557692336562585905479680 , 3602924153542731467450228752898188462901256192 , 4668631499027389665486023269295515131509367552 , 6035190448331469861346341668641950959081261568 , 7783452859545850745317680292757960032154348544 , 10014892871243626650279308944110263368266101760 , 12856580904042980930830371976883239020312970752 , 16467287043820387055865321601891358697182796288 , 21044953833987675239845214648480859450934778112 , 26835825896975677219607434928698993570837302528 , 34145579802249643402551444035664468370802443776 , 43352863614794054471460735808881912940168951296 , 54925733214809387225946649214657086637753849088 , 69441563628113285017755024256242342594914238720 , 87611120357960328862987630666131403908858531840 , 110307600461964992814522643662246957377423348736 , 138601598593450849423523021630471417146283599872 , 173803122502474996886907833780119882716719582208 , 217511979040631845620821361878780925716979388416 , 271678079443434383315925617779904152530472805376 , 338673475961664594764434495506589985425364030208 , 421378245690023334756297382954353474599557073664 , 523282687182830838253226764731128427383013689856 , 648608697260851254724727258086879829185839100416 , 802453656086477762547797568069639671380160072448 , 990960675632709786009889200856321956217683097344 , 1221519668399260972424151550554591643929574639104 , 1503004378783810080245182437151814497867709157888 , 1846051298948066704312415731888234598024692866048 , 2263387275332416292568398967158308221354001704960 , 2770213613191438775793206202901139008243571762688 , 3384655617730140512452758880826594280442665146880 , 4128287785823738147139656554687232408827117426944 , 5026746297264770381697017403837309456817957320960 , 6110442065572896699943587469033321304697696677376 , 7415389413422540965403415591248404808182260223488 , 8984167455759689411092219634321515649368221885696 , 10867033525015373992603633330443704457999866937600 , 13123210479092915569296877852285622012115938380800 , 15822372516853993062526090395252044672449172428800 , 19046357211751756237437383442963505717671452467200 , 22891134887288707336023762201081438567022183142400 , 27469070224483320882357280826833358608438358726400 , 32911515138824023482129822835288503793736539872000 , 39371776520517305420867437737277081557613425196800 , 47028507426070792735908817257889755959653497868800 , 56089575770879415883163893710755047283384158752000 , 66796470531155951679520427885341169281271341286400 , 79429311949083641600750305219945330401720409992000 , 94312539276811778754393305976769212942742758542400 , 111821357221775469832888486889265229995573653644800 , 132389030495387530207097278801624277680406916729600 , 156515124745822747153493294616860904590515704355200 , 184774801697384571931991951233476218047382917776000 , 217829286545692817299870228740316996999251303187200 , 256437636587777196955330141251518164710040239360000 , 301469951714036691468092554695549649569674477112000 , 353922179764442932705421528126006449061439859608000 , 414932682859444308640448447239227631415541549619200 , 485800744654482723594763498664293386012313727865600 , 568007213027887787056355782152275275700357902272000 , 663237487977445377713081219850623385949557933792000 , 773407080446418012841529455299849621276917044742400 , 900689984388028642728112252264244415474789204211200 , 1047550121562975230352728491815610235573082689803200 , 1216776136286381882757499991179351333865687757624000 , 1411519835528449023280431531881910861997739237376000 , 1635338588337475861266951961793319124929154762156800 , 1892242017395655210854752295855149364059203075177600 , 2186743334514536785301570948884707183694964620617600 , 2523915690896177154096894843281772381275272241184000 , 2909453931867581366437901410529190757899345344332800 , 3349742164371571198350422635246082109782626411464000 , 3851927563564740916007155086239295591466928902632000 , 4424000862225116703042089954220323270730559823136000 , 5074883983061200142125547107808079123814695112128000 , 5814525289192173189660145012047432885366505927065600 , 6654002941740801104650437656223807591960987408844800 , 7605636865357510684771371050513959355577715430899200 , 8683109832231380702499643370896374747895343150400000 , 9901598182414698998847524584181885185076043172819200 , 11277912702697937084201493628329796610377281091641600 , 12830650187461527962793141546042410383420694844403200 , 14580356202457592949529547725762279280650995699801600 , 16549699565953454510293077084733913612677060232505600 , 18763659050613422403104532388816293942179196135609600 , 21249722793507006422390290566205988381507103355315200 , 24038100880186323417909321233239747209726582849177600 , 27161951541476591308356898310443912516810035112550400 , 30657621367917064267211734125099149286907277992473600 , 34564899906302200882464963495117340176155203165516800 , 38927288954930234858585112688472133156558680506828800 , 43792286818644397248336659701755575271324781573420800 , 49211687720968095450494959352917788984108785862393600 , 55241896498346561147308612105206651033332222910988800 , 61944258620134795674101729942360956875898473600883200 , 69385405487391022157537442522262097637831673058553600 , 77637614863184075786242283408967141213743326691040000 , 86779186177041257485926992554085299274266664943168000 , 96894830325814722467161429006414617569824856909760000 , 108076073462883974480068557427025396715727972904064000 , 120421674126738400690959703456200018530584708042444800 , 134038052909123559625322521818782368874355072241113600 , 149039733701625627468304409876559901931541927584140800 , 165549795388673649084817250618523699380746382865235200 , 183700332674026606407349653725907997214733380339539200 , 203632924538158674091708822609309110829624301941593600 , 225499108625140808731727409054547508723568138800371200 , 249460859651407153104957514847393604416411618821305600 , 275691069714753737473106528241133499398208180968300800 , 304374028162390869372522620586841945276332272875008000 , 335705898451346517360530838881476972820156340352435200 , 369895189206028980216398698203494541129594474966374400 , 407163216445633830499168271011412705411209063365196800 , 447744553722143922549334950565901570375201415582720000 , 491887466676998624963767831743345985853717240412288000 , 539854328295831934625658668622587671460003204037907200 , 591922010914657630803965170791943381135696720395283200 , 648382250813318985991281681862825736628704168384064000 , 709541981020964540052540224571788124949117297215705600 , 775723627760780771036912354893850397818765086575840000 , 847265365774418666837732732032579714907057653381420800 , 924521327598916459896549169149593925481489083715699200 , 1007861761716479687592041907839186304777365025797721600 , 1097673134370330718631587944447174525167361054475699200 , 1194358169732449697369976075903552961154301256070553600 , 1298335823033393209522226666316603048026621593393881600 , 1410041181213000492339747906254949742046258925556953600 , 1529925285637891337567234011860675360364078348489708800 , 1658454871447128599396084912647341805105643486767468800 , 1796112018148200055158634780486779849083396355467481600 , 1943393706178184653278271582585215734142464992974220800 , 2100811274289650494277279017233031612264867929944870400 , 2268889772800183375762924441354852651497045184192627200 , 2448167207982190684690076460284665089710995696585612800 , 2639193673143443754324026762508679943250288376885363200 , 2842530362287100808072173188002464508789614326141574400 , 3058748462614222241201704245800709032825809444081286400 , 3288427922575753815220484686753130161886500399129536000 , 3532156092659084369107828157748167681939619083702515200 , 3790526236646641407358026241412428513761895970415955200 , 4064135911666152815595431625017980885354992603786451200 , 4353585216012440698596322365787848206373280368890265600 , 4659474904403834559736758068524585335205011022376140800 , 4982404371100036008441097001049705395217240231159398400 , 5322969502085582203686087538267306443194262923914444800 , 5681760398382539592126657998017640159405341443821568000 , 6059358973415885015864009819485214915930087530254336000 , 6456336428298233824846333386734577885074370743279616000 , 6873250609827682957178666754393762487287080472054988800 , 7310643257002610052008454262002119195011125558888038400 , 7769037142831821413032097429012501033428058759705395200 , 8248933119275437210390621209957805647100672578393292800 , 8750807074148887746121905268647722791731133942818816000 , 9275106809902169411550475540486980180103460390363136000 , 9822248855178395975094008347240019350417100816095641600 , 10392615221129355954310190278740153563299982523231436800 , 10986550115421126085907840885620026485255435802859929600 , 11604356627900685428238821964784412047890384698179584000 , 12246293402777188122915729422487754663194507114110976000 , 12912571313141333603158135331656869997411395854494924800 , 13603350154421214503740078444198766936576842290354585600 , 14318735374238730966456515577684094732824352135879065600 , 15058774856760873974431055730616614187694362084122624000 , 15823455780369968893696887322058010329281673737117286400 , 16612701567922185676968269413055400523192674023764377600 , 17426368949425753805665913626944216808400804628460339200 , 18264245157197348029190093014953764017644453203376537600 , 19126045273915640909139597606815690838990105469914316800 , 20011409753967865451246340941284546962277060501050163200 , 20919902138622019426599926560763271842473768122313113600 , 21851006985249414512510010711834853250928921352699084800 , 22804128030716437820731912068943585001645557320921907200 , 23778586608453310155298746754421644240904559785543270400 , 24773620338337765529006807411184130670733250141505126400 , 25788382107602613874106364894208592486416587175231488000 , 26821939360343563605305752083064178988210957103102771200 , 27873273711937344896839847094701932325218095097689292800 , 28941280903791005922921192158826934292729726456035737600 , 30024771112248600953201676275664807956032660028109619200 , 31122469624334702166142544735277165956797255600172236800 , 32233017891104092471198885377885402395981688331164057600 , 33354974967998683433626798416767517139339197848661196800 , 34486819349386591295633486834214927006280033904659660800 , 35626951202907808021785717709734923829347575823926886400 , 36773695006754042396204023735408194742674478964568883200 , 37925302591296131990935382557961427826656107605386854400 , 39079956583749284710468756356697837491483126779092992000 , 40235774252765524524099879813301400733386518887374438400 , 41390811746904911226670356877993893036051122987076403200 , 42543068719121831643634130659403161613651604545067417600 , 43690493326333421253010171750343718805292049684887961600 , 44830987591332564207661561615883380363645175924583628800 , 45962413111179091684270624793590185760911670013391667200 , 47082597094524513598625379720095359361942611954780569600 , 48189338707139950061965485255604027086414982705503436800 , 49280415703462080214879005877225080650050941975502848000 , 50353591318846551891784738292096406887239952319175065600 , 51406621395989094120502957587186300500089685443903488000 , 52437261715995850480394815247715055400399193810503270400 , 53443275503730066887603232172744336127317387427388211200 , 54422441074188801544019270822588164617931949920644710400 , 55372559586289245609739861551867552120949445441495040000 , 56291462867820746332284736876154043036678444544081920000 , 57177021275362165049415148460697296224534473721159680000 , 58027151550677599002824364850945811990791607009157120000 , 58839824635740897887031177926951585040074505384591360000 , 59613073406454232767225775435060264684995259479490560000 , 60345000286459336074528338409822607366422089955409920000 , 61033784700730834588244088477100808276621227336826880000 , 61677690330484751822250931161222432863209198975549440000 , 62275072129678575325509299634523098507717877356625920000 , 62824383065947848021258279954891151111241705505054720000 , 63324180547733547439763043760046131693608679068426240000 , 63773132502736839844187322858209569124547916509265920000 , 64170023072136911135731038920251897723496027958558720000 , 64513757888833927342831090400563339942606812300656640000 , 64803368907741413815485248301941517804657623044177920000 , 65038018760703332579877524319972930031359186212044800000 , 65217004608325639584775671195614580053778557464166400000 , 65339761466385437791233342497748803993065524345446400000 , 65405864984474689316646134804261685431693658874552320000 , 65415033660089772157005791950805804557346036228997120000 , 65367130471747500086800553549039677433633147317862400000 , 65262163920866023059851432122970399126288014351073280000 , 65100288472080298224503637208725558831929662423203840000 , 64881804388554762488849674587324305615829875943505920000 , 64607156958864522794125459297832564838742794434641920000 , 64276935118649270304621882104286005490543829129297920000 , 63891869470505855895078758413062196556709187346595840000 , 63452829712618899142491520516093165053505203644252160000 , 62960821485905561608584541353609672275361725869178880000 , 62416982657133998424371082842830946308649373445201920000 , 61822579054619248222892334571716694583136361903595520000 , 61178999679916319181840697663198144983645590547578880000 , 60487751418272616020535784616609155789784732086517760000 , 59750453277632071534560765805368269965746358022062080000 , 58968830183707978227717886641669751240037610167255040000 , 58144706366312434909678182613372708834277609193062400000 , 57279998369589415317705846670038942463792740290641920000 , 56376707724917813751444567421114326597649911844454400000 , 55436913323041610875427693599977191947473135641640960000 , 54462763528210453023471048552314191797427204593500160000 , 53456468072594254851383725010879105465633385481912320000 , 52420289776321674210631987759014572086310097204879360000 , 51356536133779832278958997558069394437921961843138560000 , 50267550811527860479943043929982867905198517285765120000 , 49155705099227510116381170329336383191604893153607680000 , 48023389359920984779934560154039704963290583013744640000 , 46873004518989888154684852486201371145070819007160320000 , 45706953637403706728690251292500787171960874029629440000 , 44527633607958811819867346762460026682217122452029440000 , 43337427016238124291434895554195102317147170798182400000 , 42138694202713626759497932693191568818254125834936320000 , 40933765565878386204001663644462191175037477180538880000 , 39724934137108464697391392774790037230471666372444160000 , 38514448463648390985128124519879351436093181277634560000 , 37304505827591585848597911078737930994327056758210560000 , 36097245830013257541977030369558115410596418192670720000 , 34894744363682409277383581029425489412061957967052800000 , 33699008000057085573200695237669728813526539616911360000 , 32511968805584783094937506815229963317949184050462720000 , 31335479608002821751906482693465025659695408467148800000 , 30171309724066918921078553369903510113827522021949440000 , 29021141159983739871045724607048186868783170393210880000 , 27886565291054890583065800868396001238425529215877120000 , 26769080028356337480180151949439237970288649062318080000 , 25670087469086015397595680078087786810325082009763840000 , 24590892033630101524181902144061805612458292156825600000 , 23532699083517966899263415578767984182150983750778880000 , 22496614012984554202997148884225265655381965314457600000 , 21483641804420463762689488543883266783816579948216320000 , 20494687038859928479162319526484003427766947195781120000 , 19530554341793035382017629349118052299225564210135040000 , 18591949252330872947453249245419176080144367655321600000 , 17679479496196270107876355003882542423409270802350080000 , 16793656640343826843465866587549863244329440407715840000 , 15934898108365274273586677075623462720782953333391360000 , 15103529536088008570079237783489630568565951203901440000 , 14299787436747915223816062696859636958412470412902400000 , 13523822154950851021026181304196646390483109839503360000 , 12775701082878765756017215282959157078006783603507200000 , 12055412107943938639167121911190249971921063597834240000 , 11362867267053264042496623266912376463592824453201920000 , 10697906582252373403472583533476540613462688861388800000 , 10060302043657719369236750930152183224594358183526400000 , 9449761717183003184919458534623036518309458824396800000 , 8865933950915894242633765118340444748704265827778560000 , 8308411647672112154944067920129866528301590272409600000 , 7776736582471913095165034498837384717706644503265280000 , 7270403741937469327915177511983054873141174755655680000 , 6788865654130069112796099367463942505153726039982080000 , 6331536691488038730450417596015906309795749857853440000 , 5897797327509354116497966404461727028267569477058560000 , 5486998318156700974758650772893185369228881494016000000 , 5098464795818336701707090836918147520985987075276800000 , 4731500259859062974803392804434667917212130615623680000 , 4385390439683953541903331534638054912229719068508160000 , 4059407021873451976362943356182939474240737538211840000 , 3752811232004474196156964069258301523580701801185280000 , 3464857248717108251721009537915427637205516523929600000 , 3194795449726923138885011692309861680025257168076800000 , 2941875482873919583728163372927864133918409055272960000 , 2705349146106901846999499316370774554900672282624000000 , 2484473078374940131290679917514398349623828126105600000 , 2278511263190897011138152762184831045327984373268480000 , 2086737328148637876736241845449690371749842282086400000 , 1908436651535484069075578906943660271792982835855360000 , 1742908277590468017860773049039642426555951488696320000 , 1589466631344208713123121224470610015599566014382080000 , 1447443043987950100359304689756672732999574424125440000 , 1316187098575549384960644516826900358726022903889920000 , 1195067783727645061335461589354084622596747307253760000 , 1083474475888864264951062566812107757487254614835200000 , 980817757005980827360650884611127305254622608752640000 , 886530062077554207904825622633816989803428991467520000 , 800066173679939202673816410855359191164938449059840000 , 720903579311933026818584965173172429449880928256000000 , 648542679609746492335097072620876360716021006336000000 , 582506872711055441325896082970628842325601288192000000 , 522342525371525655515156381465293327559581433856000000 , 467618825015892565765710754112139700939984404480000000 , 417927533186137571916524976013186084443279065088000000 , 372882657234241517772509360581942610366626529280000000 , 332120026304748748124155516413295485457427202048000000 , 295296800593893500873584347632879204001708638208000000 , 262090923000485719424403351414437351763581730816000000 , 232200504388932550987091997720939475033031049216000000 , 205343164174059419929529804547548427821739737088000000 , 181255342212652554361187323239897966036756529152000000 , 159691564636532161245370849443274360572382937088000000 , 140423690516662392660828561542293940120217059328000000 , 123240148348877936514085036186529775919430959104000000 , 107945149317883138390581778095698042819777200128000000 , 94357897610365443475468969182953923644550545408000000 , 82311811260361693511245172029351520923413381120000000 , 71653731211023940926998417978656877303788732416000000 , 62243146168973816256232472065607129853100818432000000 , 53951438601354225587826177867074868913228480512000000 , 46661132839044022624507230206991088470057811968000000 , 40265166280843721233905057960218591782779224064000000 , 34666194043244198592934501037064824304766550016000000 , 29775901380179112163225284733562926279900004352000000 , 25514347906318763309446499070155035923418447872000000 , 21809347595316302075662038948412367097456230400000000 , 18595864017785486496472876166457623707102740480000000 , 15815438459076053106478703457596796881772478464000000 , 13415658640207841202579366605748438800214786048000000 , 11349640751179700680320248261456745279359287296000000 , 9575547836358935108125731579546193937345544192000000 , 8056147699609152096398572075137109878852550656000000 , 6758384036933592840937133611187160580827906048000000 , 5652980809486186831464238402394660671812796416000000 , 4714086504918377165209193323434339544992841728000000 , 3918927957382179711833004672632483780317151232000000 , 3247496623746761483154092026108706809121341440000000 , 2682268147637613701612436696078404740725080064000000 , 2207931983568432748635824983772114777806995456000000 , 1811148581998001939105305069423515614186569728000000 , 1480336666551139194273438240018894594200567808000000 , 1205465863018223007116498199641479652787093504000000 , 977873934952886651188232494336456756492763136000000 , 790111015706510950069972455779404241059184640000000 , 635785458897521861425534123666616430681391104000000 , 509428740028085375584432653440391615633948672000000 , 406385535473132008433413254090134313020424192000000 , 322701711853506324560038237673922619622031360000000 , 255028746251304172191076417161078139124711424000000 , 200547722487196443322299563452097798715998208000000 , 156889653535474463571698635104730246161629184000000 , 122070768792153406534255997600368191288115200000000 , 94442023583750313792233203848752011369512960000000 , 72633545429485407056597473053688945704960000000000 , 55511466119944069960813243181273183233769472000000 , 42147092467312347570983525451293684693729280000000 , 31779248565665025098758935235974445934837760000000 , 23785188153797106859350394624524280727076864000000 , 17663477666361479508077048016299771314569216000000 , 13009283452863718008307356001022920265564160000000 , 9496126478754130628512307298911996979707904000000 , 6866210104082347251908517222596763432517632000000 , 4914500585084474431850196274480842270572544000000 , 3478020577299782765732284257300372887961600000000 , 2432272146124308827596547474198497119436800000000 , 1679246570509286274206103890620571870822400000000 , 1142063190748345977047540146631906584166400000000 , 764458794999820465149828398621567798476800000000 , 502976007819863568942627280360249176883200000000 , 324059246523996772123159562061357672038400000000 , 203815999849498163693551827623346595430400000000 , 125152830234361713140837556721829491507200000000 , 74322814864230279738202717772148060979200000000 , 42456288361887323612052324230331629568000000000 , 23382136488148204876525415676236739379200000000 , 11669819224143893762774202796441652428800000000 , 5500746227338152370154690806074153369600000000 , 2558339712990298242894636858589839360000000000 , 668326769467589022464821184293345689600000000 , 1 , 46 , 1125 , 19316 , 260197 , 2918394 , 28277069 , 242654144 , 1877454219 , 13274093242 , 86658807543 , 526733790780 , 3001012707775 , 16116373392590 , 81964972725519 , 396357703577584 , 1828691336461666 , 8074014585552108 , 34204076254770578 , 139353356989992840 , 547155543447293778 , 2074285038671927556 , 7605411246224051394 , 27010916353750113216 , 93052218903909995574 , 311346464977389526260 , 1012994221641474780270 , 3208443243505658686840 , 9902657859624945107038 , 29812327405747848680796 , 87622914715876601886622 , 251643310020020152849184 , 706718913945703819879509 , 1942365994278995506212262 , 5228188637736112373124601 , 13791293307591324617888196 , 35676008984776865805935833 , 90559989884702987950774562 , 225706940976833165315008833 , 552650633774218097302724096 , 1330124397895136585097250159 , 3148464394622700320289092466 , 7333147138771537817830753355 , 16814298938406612853413940748 , 37972351883322259308393329619 , 84499189558720602689566960566 , 185362779266868945652173202307 , 401013588069134209110770670960 , 855927791127056527683978451480 , 1803122067324595501529573787680 , 3750467346459034874544623971680 , 7705028805688402518253877741440 , 15640203960697222528834989974656 , 31378702825128235511823534366720 , 62243194146794423929931345522816 , 122109056736233512213571946238464 , 236991588419176470847019749076736 , 455168583561870238088447340730880 , 865339747376934007788682390478848 , 1628892632133112403857430640989184 , 3036700390377648375912837772706816 , 5608198351225051670146011897098240 , 10262688297172211755850520881035008 , 18612983961344058809761450001658368 , 33464563508674771707570809655702784 , 59657141262076503284192107231328256 , 105472292513205978813854963065976064 , 184969638192255396588867937310787072 , 321834847819995111734838321982698240 , 555671109129662330110472267839936512 , 952211695832434084724767371046801920 , 1619781068229818655222316564756005888 , 2735645817183601743219131554272457216 , 4587914921923832887190661962720072704 , 7641729059110611602698694169165927168 , 12643150847144622382238795308825193984 , 20781211620778824033580064593417792768 , 33939126420938592841067932639524298752 , 55081417068312773697862515035584388864 , 88846984671043888529684352924037872128 , 142452502746052115915905525412965761792 , 227060805234154976635999852286916844544 , 359842260410499309516357102503928100864 , 567063424563214280822701926695433772032 , 888690613589452022379375483493133396992 , 1385216128698391385491788962255219695616 , 2147729237836698143208893180015389400832 , 3312700868742403470786304508604996669952 , 5083583164253134353237159623869400587264 , 7762215336397544629456754767160050854144 , 11794275330309407705517256658675227178816 , 17834758701704468380420330428468198761472 , 26841886630630569732507895628674671124368 , 40211194162800637372259506791458340346032 , 59966164444823604051626894875723887486660 , 89028106909756427611165760743889604399336 , 131596631184762318741165547944354565369956 , 193683848168365661824230270511808128242720 , 283861401799654011120310864421047340960364 , 414301008560771360095166985804995951748744 , 602218211338045279451953845238630162441068 , 871867972083613942931119151816638301221152 , 1257292711856356870658769930026530205593632 , 1806092595336627431842153366493282493554400 , 2584579619011993656542851864327407778815072 , 3684798340635740292065707262313137684587296 , 5234055829262826216959123592668957234601216 , 7407813111620992287715473455086631407906848 , 10447064752858557828478395391177894857262752 , 14681691009604417849308160547033755470938112 , 20561732107737617536196150205774530266507848 , 28699136901184918753245766816078919097644016 , 39923316729564219402413171624667335095488072 , 55354837934996336812581281243530718137081440 , 76502873807031878797896206455396525522176312 , 105393684587572325724246663057670362046472304 , 144739497361968934358953829594776776255788856 , 198159834210531545559827344667481114136471008 , 270470733443895105353691142300922021353231488 , 368061606544584429722309443399587919385642976 , 499384896618454734245345065452037759553847744 , 675590528564031576420798592192633635693943392 , 911345705495884772126263016775865514100631968 , 1225891324961060582670057762693487976034601632 , 1644399668686022910741052503807747869331172656 , 2199714677925307901085970101927420279320458320 , 2934576812419324786233554005830938404895855316 , 3904460112575138932985858055681971952674638440 , 5181180739180654171585679140072860096943437108 , 6857475275569586962836301444026846655659613440 , 9052795034201508475985316759934726636459312764 , 11920621420634864129913735924494321128866955848 , 15657679354958306489453522877384877843031446524 , 20515513557241410049539472511661257501350585344 , 26814999411565323848571438287829578952886108032 , 34964489982675687535903749562492591833329140224 , 45482458131415528644542475535963147833179242752 , 59025682950013283710771355127234485179209878016 , 76424259271360300077379936459437016830749594880 , 98724985272179234123536781919546234081123663360 , 127245014959853893737651682742415736304444976384 , 163638059873938486481997437594340026543159347200 , 209975899638419281275396785585700437725687586304 , 268848528041356292928930364088024662604065195008 , 343486936338493040367379905096966607931562757632 , 437913337313225729730604635743588351674038991872 , 557124584076511416751206421369499339931216986880 , 707315661817890083588729076791512261902487008768 , 896151457709517798777942125732475627138728112384 , 1133096577219638362334005974512666252069194395648 , 1429814812401059393960601913246733178993548335872 , 1800652022953619699764070385593985467475651076608 , 2263218713874900810820153974831343314383804670720 , 2839091541052699235705109626019006150127623005184 , 3554656412708843072299040578436756557685182749696 , 4442119853226269639645308005130815063493411580928 , 5540719939237835978990989429917727300114508003328 , 6898173499098651852345641212629297532311010154496 , 8572402490964157542031653074088895081339009506048 , 10633589659381557907797044901655124680841837855232 , 13166621847609282286909685368242828759341086516992 , 16273988860152920854345228626985520262630218115072 , 20079216691774814876514246173801892899728137934080 , 24730926448132822633963970041186622115195934932480 , 30407624582277439170384136417491167170090909889280 , 37323346384628843783026364888940763703265942392832 , 45734293239889920963596860727760630855541786354176 , 55946625274923441143153288101041860231882208076800 , 68325594967091450440969033496270392574050565915136 , 83306234390240656479814913513057575907956726342656 , 101405839404766993087883739834695535511437788031744 , 123238528638153742949643361899941468384839599300096 , 149532193978637639963551974767096661360026011947264 , 181148202974537137426509894885150737124684405504000 , 219104262493667801582811638945359610355399393811200 , 264600907782009344646049275744669268598282764915200 , 319052142245160619540490204678577930642524687788800 , 384120821468136383888789644068570171478288758144000 , 461759450847912501845959120191981227952302355782400 , 554257150425116893678806943442332634348976923712000 , 664293633809730229800419163163404280042506345043200 , 795001151262708043259451866738925159534261439737600 , 950035460847241560955932332275256853685582174137600 , 1133657016930490536350975921828884972470025626067200 , 1350823703102869838063733863036241180144100544980800 , 1607296587672627065153810475980741601685094610556800 , 1909760345260073110632923484910654564554280872696000 , 2265960168576563656290540171912292661923683543897600 , 2684857191252123777468303607354340034636040131484800 , 3176804656491443834909363474975018481549265671168000 , 3753747298445842552469465650944777290931887999107200 , 4429446654363964953894272221329257358824298873772800 , 5219735296884993137896218092878902229596302520504000 , 6142803268036750241211034117432817000348630194934400 , 7219520310626124251904622457960409550441634574484800 , 8473797829350717330940694458961445095164741328947200 , 9932994874080053397763115541413169111801387289401600 , 11628372821659854914845969490564444371468626846432000 , 13595603841138481358352653623035265606183755076992000 , 15875338660399113133735302111830474631796226128070400 , 18513839610515406791294624734918573852230089410756800 , 21563685407061960805371803577749276610144839418345600 , 25084554635642998959098239877868754016720686072411200 , 29144095440615670462340764790139065228901057579417600 , 33818889471736760188376229533201366165158360267977600 , 39195518720801435553823407239721634565315023025088000 , 45371744479472543121388677571647788009331139169673600 , 52457808266644811752514229867851607805666030096377600 , 60577865208974713361950820955173609950812047241921600 , 69871561006152937347599931262927563628272904636272000 , 80495764273307062199673161875822349881821177157924800 , 92626466718926081430532969880310780554701251893721600 , 106460864288455745757790212260007693621539086976160000 , 122219633070749553646833330837951702647080775522764800 , 140149414428230892172611476138208758100380785261478400 , 160525524457864159194592719061671741676427962314777600 , 183654903521671295127474569647218718858466907602188800 , 209879322183899815199438182617451676582269668056908800 , 239578860462331076513461533269645743129656979926240000 , 273175677819024176121527258475260124245134153111027200 , 311138091790178921534289706621146731882420809588512000 , 353984983553522763041871575975876925303284642888294400 , 402290549069706710016228042065978984044873288074950400 , 456689414669434008777125500208001993325428618856204800 , 517882136114095500144002271041179711806997280558457600 , 586641100179348010690958820609704310086986577579289600 , 663816847734401147604776611016963360838279794757427200 , 750344837042519620474231502443063728920858253045120000 , 847252665643963220278390462204019459613566381983257600 , 955667768606559141889793504751215480074346012532326400 , 1076825610219253077885990835428298542192411156984134400 , 1212078385235922152191445246013080434342561335571008000 , 1362904244661875272370493172848947996368366303734393600 , 1530917059650134296572573160865082510249727286349772800 , 1717876735495798434382582171739858910345254902312300800 , 1925700085768809819749108483935776034774648550259648000 , 2156472274526819102328619234757667889115662907383468800 , 2412458832015864511878633651110024052966246127835289600 , 2696118246598254413015600786022237196149911262838617600 , 3010115132468278238085256355663330815668025967907148800 , 3357333969437971901005846067577813115257596034257702400 , 3740893407200206319273421199556952628637099319840537600 , 4164161122561003176091851798752623764592062398926252800 , 4630769213520794913942361906565793435009225161716569600 , 5144630109522971570446097151530970467292567958304620800 , 5709952971811105544221649689909918050386978834520576000 , 6331260552642409131554431381916792238209791706665593600 , 7013406475952238139697263353627592131698358808090329600 , 7761592896279371491986741734902459962996885771966432000 , 8581388485841533157050180522271790580975707448889164800 , 9478746693348332427835178339379676530391004933050752000 , 10460024210480964953218352016500052955367792608360320000 , 11531999575260643345403976090178696037858116575384115200 , 12701891833185472759597923545225495264459884198850918400 , 13977379170058547481670698868489264747929931550665132800 , 15366617421480271963730068283206888440568371556553433600 , 16878258356975199788806112480037332052472690409119737600 , 18521467627266435365312177495526758718558667069374720000 , 20305942256418893892186616138960993792775057278185657600 , 22241927550728518339239806900888675226325128034484620800 , 24340233289967953097283642445662776829335767007596281600 , 26612249056504463584773315622536867160631352920314828800 , 29069958552439577284876787010367083917578008099625766400 , 31725952744720456909767530902096741002000322232804889600 , 34593441674146255596154407667537207639254594990605452800 , 37686264754033334627897656615825258400537001209651251200 , 41018899382122804650092583844153770486997466196756883200 , 44606467679325403307076316949398708627439345443881945600 , 48464741169140744093761729437283361253567458491356729600 , 52610143201871578830647007553564704121280045234158540800 , 57059748931065756926545928285139727036069253771961600000 , 61831282640224210727281727014474982919320356923463065600 , 66943112224918328980015009344023720256517859633956224000 , 72414240626361632942839692372766071318568172350670054400 , 78264294024178904653767980001553522380128022582452832000 , 84513506587183920292741783316249046600385602398575449600 , 91182701598150085966948790564591898579401153729381356800 , 98293268759523819065651419583166282956300287184629094400 , 105867137510651582850845879053650804864128744615988960000 , 113926746177506633202697428396163952285865122552952384000 , 122495006807041658946045677614380785624601465743571859200 , 131595265527491479573172534382828794125993862257083187200 , 141251258315791825806299572668090888066495337024990003200 , 151487062040321244255672649243400279122296910414607155200 , 162327040697037323233358272471346749273101650704067788800 , 173795786740693144052534111985500812033345001923859251200 , 185918057474185237683070063453466987753292304633530777600 , 198718706437622022628026054157260183737704981880360140800 , 212222609813239644832613264074068547337480648710002278400 , 226454587833643920393269123374914964164407272613752012800 , 241439321270491516584393287973868517074952680179818496000 , 257201263042245513682077980879090017514545138525790208000 , 273764545086593609838532476218155564116573246527662080000 , 291152880591568863587986987027652275180336016935917158400 , 309389461806275214609840514158704618565275095731876249600 , 328496853583555517480957168772628979129665352750579712000 , 348496882956788822100586299117140235732977837450285875200 , 369410524962668304040422188243187577678779470935105536000 , 391257785098294028594373520969672731601795823263481856000 , 414057578683176050092627425515909439670283619065035161600 , 437827607604199707329676224969164080939849520340769177600 , 462584234769794500778894839501114035764210291804597452800 , 488342356843220621428026598672759185382021786343650099200 , 515115275631155380776067513422278502337622722697306112000 , 542914568789923212553965048646272164395692862137469747200 , 571749960266957875004257299393039585850518399930087014400 , 601629191231229004384823800196993071733513632077613056000 , 632557891939990745045603268648568476077475519335596032000 , 664539455384396041146609269280657948142339374064135372800 , 697574913176223426665664720823557972733608544167724646400 , 731662814602984590706951683334706126054218786799176089600 , 766799109310389007497530923775957183115565779232977715200 , 802977034618793380834060928090641794948582118469323161600 , 840187007907749979682937287599206334054879948583103692800 , 878416525148389169014153435239169316091049673517495091200 , 917650065967934785165900081423070378838634234622002790400 , 957869006392304342625648250484303588337809794253314867200 , 999051539573184148360896296463563793314180171614787174400 , 1041172605704784019171579127882911020326768427623956070400 , 1084203831327468390959829526365272551992092778958484275200 , 1128113479276467227292751626966070703955994368798002380800 , 1172866409329489088191290220954802496418212929662928486400 , 1218424050859316459839730126913468315291817559838430003200 , 1264744387365254447733693792237564705677494212144783360000 , 1311781954234299661073053806545708449105151310697901260800 , 1359487849386890426476466884388306576838854022612718387200 , 1407809758203024346806082390742190079912549849326433075200 , 1456691992123512995549460608271748592636161931563877990400 , 1506075542370845392048590018759204743258028663900882124800 , 1555898147881979723463875090090830196069823216152570265600 , 1606094378954781844087310394714015055676886469237170585600 , 1656595735353945609863827830100388689986841397518703001600 , 1707330760450278848865287015833163936405239723258527744000 , 1758225169747493907251979876156755639015941919850356736000 , 1809201995463895584551289461375778659512600180054565683200 , 1860181745085963794286592795863023773562900695392229785600 , 1911082575683785538464625418387915130364062611657260236800 , 1961820481421379223214289464642470976588876059346460672000 , 2012309496213111051169819630423956760865501530472949350400 , 2062461908427511354432803482330681929481749978386957926400 , 2112188489798471938937011812420137761941534588056773017600 , 2161398734865811802864467064900096560790308489183270502400 , 2210001113371658847000617672293811537359665280492310937600 , 2257903331305499329290663585916326644459328531971604480000 , 2305012603360998192287885142739900699315895156664483840000 , 2351235931816497291700156524410903567008739364758323200000 , 2396480395019380890111509550274950140190343227300864000000 , 2440653439753080732849962307805256574186150027912069120000 , 2483663181175930890990396144116766746928309459782492160000 , 2525418703820519749704469975756962470622708390646087680000 , 2565830367958357599699494023278322365239748014968012800000 , 2604810113966772147672010714721952428518369049724026880000 , 2642271769735088570192748048302478227799910399306629120000 , 2678131352831676151468824260209552692835702378679500800000 , 2712307373329239646790800204347986956097113247957114880000 , 2744721128021752142316560602779278529975222037096120320000 , 2775296992934877957185574809732429517766366230071009280000 , 2803962703793467444750552809520642018430512020107427840000 , 2830649632504638625843385570363493724335114124341411840000 , 2855293048164545714381692308803366916499874994045911040000 , 2877832371966166049900910025922933611390372559382773760000 , 2898211413259673811296746888282581506820826497735720960000 , 2916378597641053006420537817257832137772455119921438720000 , 2932287172949038145484879486221132127223232588615270400000 , 2945895405728099798009149745611427984582845876190453760000 , 2957166752545806847228302782633221803196114364660121600000 , 2966070020595476899234922815059162807277824551555481600000 , 2972579500337929894118211335140836360320297075584696320000 , 2976675086696966506802491440858561531807949438420254720000 , 2978342369766053957510054535022704096980700017270292480000 , 2977572713834025457541465519714761370623444750844559360000 , 2974363303724984860599873369919214486587973457920163840000 , 2968717179766986592918111740594098913219130476815400960000 , 2960643238226609909705254778527731921192753052468838400000 , 2950156221267941859150795830517815190941801129306480640000 , 2937276670896120771653801262445809658747237127983349760000 , 2922030873917069934424432589652741930713620166309683200000 , 2904450769779299879588482806417750388593848051542917120000 , 2884573851532273019569509466770650694903937389678428160000 , 2862443028918828998147815925643479453548631428057989120000 , 2838106487299902853397094793885254650280499431709900800000 , 2811617508301148657313847068074218174682979780294574080000 , 2783034289587629352658099303155526605566395167724830720000 , 2752419726262674372434949606249838944956259554604318720000 , 2719841195245447776441955601482570221040481396464189440000 , 2685370301420783849469644043654669083497146687197675520000 , 2649082631148046950317331689618127900317939614058373120000 , 2611057467885576555365642466609151949986196420037918720000 , 2571377520004716186564740386852018845975263430463365120000 , 2530128611212993932985394546324353382542631754806231040000 , 2487399388393744010456293764495909151137206960796672000000 , 2443280992594025326961493047364249190970455040925450240000 , 2397866753008492426097160639049029481338079087993774080000 , 2351251844628700684767471897637410177647419523733258240000 , 2303532974707328722162093317882040543090979078397911040000 , 2254808033334891276719607001054911216665348891630714880000 , 2205175778823961965386736605752170867422954641494466560000 , 2154735487456720115655222456197396142197676294356336640000 , 2103586644165912386461680085502828119639500899985653760000 , 2051828597571273065636555754739494060403908359867596800000 , 1999560262075601827824765604191311713304813485752975360000 , 1946879784023446047159466200561646678177750862238842880000 , 1893884260989654949041442628107123875239236847203123200000 , 1840669424421246314978531819191026069150780793961840640000 , 1787329381409786862060300713438756621576800087517429760000 , 1733956318656062701852862061978076908791702815608668160000 , 1680640271355547494266327868201195303562599975435632640000 , 1627468852684263616936813847377962814156868046225408000000 , 1574527053756411825964683235492355905266156826011893760000 , 1521897002032163412990956111025019949614231794454364160000 , 1469657795543471553987305985590037592730510763546378240000 , 1417885292870379333088004032028906869842269650715934720000 , 1366651983931513376939182036590787730836057672876032000000 , 1316026813361585841904297985916572047401949711588392960000 , 1266075089359060398740791780465180472462245156257792000000 , 1216858341370619434109742784676080081260114573199933440000 , 1168434267655946552930616905667988408282573080603525120000 , 1120856627411715710563758078898778850719379861574778880000 , 1074175226783100469246667279021293790640296247218012160000 , 1028435844790146988643065968265037700414520181108244480000 , 983680256795646832020690195250508849866543877660344320000 , 939946192742070028304236403651788082245450728155381760000 , 897267396391423400551453749193255228490747632952279040000 , 855673613794747719649655521489751529233300395917312000000 , 815190685842796106972038446007369239826427127978393600000 , 775840564349142950816120337430310997473381242609336320000 , 737641434992262688674196871754428962092288145397514240000 , 700607757765451069950455475041709345206996362269818880000 , 664750416987078651926582195225969603923577495383572480000 , 630076782609129205329342002258282119387467942360514560000 , 596590883462099925953558558739831103072072362073128960000 , 564293485710625261121629789768756589238420004350197760000 , 533182285399579946503033016774594892326588973976780800000 , 503252000005324747999370784689325359309314356494991360000 , 474494576296061601076378534498673450652264417973370880000 , 446899291041260466626850498205446738526621359695462400000 , 420452969969846683944908728130272186129869432957173760000 , 395140093842814168022689247802445135437010966083010560000 , 370943024551578805532901431212018272517159681362493440000 , 347842112675164251966789948948706031955061741230489600000 , 325815927027568147225493372866952314355932921966755840000 , 304841360259955342172158187159124494847977833054863360000 , 284893858143259799014282451546264399397873721377423360000 , 265947520195104097540456362018230235404958555926691840000 , 247975325521750248724911546997958259036737876270776320000 , 230949225509974152075574815314278909412423604256112640000 , 214840363535589444760386186099349047591470620669378560000 , 199619157422944091613735552543319001158532973314703360000 , 185255510381955590432434096558200326416925661667000320000 , 171718881503253638295028201555132633381550170130350080000 , 158978485985684092615345158171523510036604509177774080000 , 147003351998643113673566248247233663398827383251271680000 , 135762508834328862037632542636382506932840465705205760000 , 125225029220313733149001693155498518963393400793989120000 , 115360204018184110021077543320713326633150974790205440000 , 106137569664732531897776652602703742685330597389271040000 , 97527068777248643237773660266491696450390812773580800000 , 89499062325835994115665130841944474666817185361428480000 , 82024476054372075455630493531131811918299509413642240000 , 75074797724422854349911965573297998623204841504112640000 , 68622209072113098222213613129956677597129475788636160000 , 62639568978528277700663438559502143683648006903562240000 , 57100531377158455538657435452097732574532512629391360000 , 51979514906536103722874678823849068766517090320384000000 , 47251807634145049711386526075738170469578414096384000000 , 42893524408395912392286617847760044919625081683968000000 , 38881698828724461681334253302391361288945508614144000000 , 35194229912999336171856131606233845758883250176000000000 , 31809962362642804342406262139535893513745876189184000000 , 28708623586443873142377934759520632761226306781184000000 , 25870893652812724306699062634304508623913142321152000000 , 23278334289891467769829033008760494634682498678784000000 , 20913449229319847140300534064631246832096338247680000000 , 18759607077672470555735124589089860046997648834560000000 , 16801093305478880573541670525833816922953752444928000000 , 15023028077403714274127336487811031330440934719488000000 , 13411411389986321773196976404583978654701670432768000000 , 11953037460003473380542868970797137129151847202816000000 , 10635533613488865081236646382968777500918451732480000000 , 9447273031855344581777367618052498693618500501504000000 , 8377408529481250930183869224379085985226154770432000000 , 7415784437496348093710865164662683556980725907456000000 , 6552966616241730775425938017301085317896851161088000000 , 5780154770735959910905616679516848929228632096768000000 , 5089208974205295569522981310471146501123950510080000000 , 4472563892499095803086593246165906192976089972736000000 , 3923252648649620594660882939477447778073778847744000000 , 3434823282286918946284855618543148312132837179392000000 , 3001361008059420867057996557332366904504566677504000000 , 2617407768838883867851074170197501427301419581440000000 , 2277982789231665963966041918904483686181500878848000000 , 1978506287212214182288911957443215431523419291648000000 , 1714818836325613138196327729027575464905429483520000000 , 1483109071844876800756579324182048389567260655616000000 , 1279932623094537917993345058113582107856247717888000000 , 1102144280130793116675719488459678754199041998848000000 , 946916056271189566215048870731057441260720619520000000 , 811674519948122089417323179360372135536418095104000000 , 694118232036061909293487794291198884930390065152000000 , 592159697561387703221953212079848200748669075456000000 , 503942748871314177938154886160096800983270555648000000 , 427789243146513518056915056814182065434446004224000000 , 362215754590232363515442163405196043320465293312000000 , 305885457736928490769672258838472861857454489600000000 , 257624218111644140487150049592215153216271155200000000 , 216376874508967711647176835019206702186954227712000000 , 181223183985382696271481589121934303468403556352000000 , 151338448388619347013238371957832915648342130688000000 , 126008585362503497975954761159901891889010311168000000 , 104595374865404468867534795938773960396116066304000000 , 86550714755087993142700787135962970025904570368000000 , 71385576574007976764868698477621912943363883008000000 , 58683890317299351091097566427151816568785076224000000 , 48075046832769223724989299948834193775253258240000000 , 39246695282310906789730231572834130791241875456000000 , 31921033023971517896196229954097431796231700480000000 , 25866563676875903442312658803785814934365929472000000 , 20877273668487055600305667147493313105321000960000000 , 16783792246371924784430859831327424326125223936000000 , 13435272190576168882516401754157646621840506880000000 , 10709359142754956412049652606547622028245991424000000 , 8496946810061339962553165975173355593392979968000000 , 6711066384277803161562113818342325849079939072000000 , 5273685999816576652699122311903564153921470464000000 , 4123962279970380785797931135106612325018238976000000 , 3206947952662048644045579325523810578367250432000000 , 2480682451745290015971129529964828825361580032000000 , 1907016881905908476715212094877767124339654656000000 , 1457667309135903778268576162004089282834202624000000 , 1106419635258506245737939311483715185692114944000000 , 834612443512142646890761830089531709588504576000000 , 624594522609273642288214862117998427639906304000000 , 464256361617407150919253193087528430748041216000000 , 341900095397479228970246288163345933533184000000000 , 249962875488414189517057994825291741213491200000000 , 180735277922717539056520042655303210945740800000000 , 129644411367634941851987193597600704810188800000000 , 91772342910651074765989283065906734720614400000000 , 64395416200718498813916560799453935566848000000000 , 44432115362166936961372496747989174950297600000000 , 30397001437880319484330436118046611131596800000000 , 20322459983105520522206035650617929000550400000000 , 13473618364183389846362443180022603710464000000000 , 8669480904176164448955458029064265557606400000000 , 5528941884825317909362194983147646694195200000000 , 3368824005013028360117212879500953518080000000000 , 2053993615445394469819251180060023350886400000000 , 1152000790406172607603719240696432741580800000000 , 656151599189027292012092485327306044211200000000 , 329852740239610364267098739820001964851200000000 , 172601389258776076862233280485770500505600000000 , 60149409252083012021833906586401112064000000000 , 31411358164976684055846595661787247411200000000 , 1 , 47 , 1173 , 20535 , 281857 , 3219563 , 31756649 , 277324867 , 2182983231 , 15698763677 , 104224341455 , 644130190421 , 3730938364323 , 20367457739441 , 105287501404267 , 517465729894441 , 2426348259515822 , 10886752566531270 , 46866724025332642 , 194029299544570822 , 774126326542591594 , 2982021615023314446 , 11109593030857129146 , 40090432654618309950 , 140329073940888352062 , 477065598295244673690 , 1577058923611105978686 , 5074989196006180517578 , 15914188604069238527270 , 48675629956977078620994 , 145346965469960022308214 , 424066744611597338029682 , 1209879915730756859254381 , 3377983789412075039096299 , 9236146947825014949351017 , 24747861151328743265078451 , 65024921881590850455384549 , 167643392172443706403726967 , 424340906563715010399725101 , 1055144233211840015361811311 , 2578776884379373730524276339 , 6197946623656745121862559513 , 14656567617409822766652464483 , 34117484005004983088722742833 , 78213904720057546190589710823 , 176663827251794234813654788381 , 393328363119377751403346684367 , 863549562032526622701687463541 , 1870326774007114487799392113140 , 3997730226988375959924727953872 , 8436003593393331686959572743920 , 17580977182739626378001239416064 , 36197815948931216144060284901888 , 73654549825817891512184244551424 , 148161113192623048506678344365312 , 294727691293236563511924862516480 , 579948650642033703567837735767296 , 1129185429037220734407868418850048 , 2176050239128198583678380810463488 , 4151614777272160320281932095074816 , 7843720599113954055997101407851520 , 14678870429095610953769827446390016 , 27216567505751494088165772469755648 , 50008676760145320670824333745845504 , 91080683304131931392995206026871808 , 164463813791849410165574683642201088 , 294488693115568668011927082607162368 , 523008826552823353222582203210648576 , 921460025498189075394333027744440064 , 1610842854330216309154035727466341632 , 2794591983550209964526120875017305856 , 4812258328386990251589844515577051392 , 8226572869675853220391897795114279168 , 13963691044186802791975908198407313152 , 23537602298633521115745781381165984512 , 39406885989051106332773548322114656512 , 65538269446485228244496584932602114560 , 108291347193496610570364830385457444352 , 177799064094925528091369141122477655552 , 290108994335287555602765475585296835072 , 470485421947689175279286538251805988608 , 758472578498853975841408670971102576896 , 1215615179659039871006466785033510584576 , 1937166777646943032862721951997773628160 , 3069751044582639681788806522114979150592 , 4837863513878932804392227547176456596736 , 7583435407649368575498692617138355729152 , 11824601319120963587651970997136265099520 , 18342562947858651872255672096383555195904 , 28309362396264617715883374994828305939456 , 43474943535186003898908479245991556389632 , 66439742077768115776974000691552713417472 , 101050103441093516323176322235041946756416 , 152969314282058671357833137603367559896768 , 230498629887339071242285700624287602682224 , 345752669825640960270108343244333403211440 , 516335030228777664280804449226795260176148 , 767717090658796920743140409103172806029580 , 1136601373438112139877676837183382331552068 , 1675657930129842680497396892541682951863228 , 2460168060500242785794921427433803496917516 , 3597307460375167074307259070292660760299860 , 5239068170172446581643168773006173542498988 , 7600178554848618943739734175987731883026356 , 10982863330020541652488461963992959177168800 , 15810931074317676933400605429823924423147872 , 22676536544796246634684960706859649123501344 , 32404106800516954316258609444445971412515616 , 46137430926330830099079801547327496022314880 , 65457905775456752193301516355241064440343104 , 92544549765375897173205898069789357372672416 , 130389829650782148166436467514221595978397408 , 183089829689221693500428124383756743332644136 , 256233132687949863576252143500941253474215384 , 357420364609354744235870088438701072941263816 , 496956168759710109947229917834289920583396984 , 688768041526796935218437832896058470616956664 , 951622759877602264238294584694212526296441992 , 1310732042527985703338228255288204672894043384 , 1799865841401171057178305396187615406221539336 , 2464125794219104282552417278804985657852234944 , 3363574797628414909838767743701127527538374400 , 4577973762859010890555579162638882154456103424 , 6212946342035829894646060091517642026923515840 , 8407980408839429753290938358220250551795772192 , 11346785837143899387107147420398136679145275936 , 15270667172654402041171429776197628788170398288 , 20495743914193605309923686025299232271123498000 , 27435068605796270727487819923539983311357583908 , 36626963907114814225313586057005276047273286844 , 48771236574371782117572786369727546292474709204 , 64775343801474587270112347188761530446938918636 , 85813103753223746130116849382134593440865771548 , 113399179253661243578688405791432214932750385924 , 149483347849644874497639813037244632637489100540 , 196569534569678760958808002234236665846773259940 , 257865763688500525688158845292794195746245240128 , 337472628223517898942225127828810624933907312640 , 440619635097951875335386982448772102051154191360 , 573960924672465891894759726879482396583373737216 , 745944462645552912678323873459937268968315560448 , 967271951427610941847705655260673821612046391552 , 1251470514992924940712731992218576956238744102656 , 1615601803383129368734112185038918657700035455232 , 2081139690618782698185216182343550143075990564096 , 2675054379221993190920120689563882964621799679744 , 3431148682770499261166237325488248418052544687872 , 4391701776982224270740110985416320133522799298816 , 5609487072406622120279525077157082607360694760960 , 7150244397131675966895312182376872344856336650752 , 9095702768740951515469023687427417786600156684800 , 11547269125015943369900772373736986612236468831744 , 14630520986407677662749774237947587025762433533696 , 18500667733542705549663782161496020440298822836480 , 23349176683917226897307951446696988324958604375296 , 29411797230000380136531675767970947013622558473984 , 36978259858819717043969596351846875283208900220672 , 46403977944327793623721693565548556683772963729664 , 58124139969536716642516280693954824972374184858368 , 72670649642294693805601056587034124879860152527104 , 90692452749057718608401291823714606857104478917632 , 112979884284962139360057880267561724002013062450176 , 140493779377246806683060282006654252836988393327616 , 174400219011293187320744804493349668017227170118656 , 216111929088608454661891951364949121432363475525376 , 267337521724396238334884081063746201789114137485568 , 330139964108446994224969416924548553216736430678784 , 407005886270617012410042793395653285784989651327232 , 500927598696969517545403657652610586222100900151552 , 615499988382563718490766819235058158039098832590592 , 755034802534733131972197483643812795534677188406016 , 924695218258837597716921359959102587961313210784000 , 1130654040266578990766667227326327660363964483596800 , 1380279373690692516680571709128795968345028794672640 , 1682352192912998153539362984501106017378293635180032 , 2047320878109284142109067970867751902310734198182400 , 2487598527983923831621675660253687308662990060178176 , 3017909689768440788142848191360861350093329004883200 , 3655694086767654234197843134970578599881089637203200 , 4421575981301102801345251212883954140986741024812800 , 5339908999581396206126745938562019161925639822252800 , 6439407578748380890593146944507116094176294713836800 , 7753877689926462522328528205801132967189833169907200 , 9323061160956344272299788527514382973830029678553600 , 11193609785763759107092935997060230714654005206252800 , 13420207482814825895471706059232072356770158274521600 , 16066861072718066393608982502402244601560023246163200 , 19208382806022517300745978599257902644604370186105600 , 22932090609223873069709933504474781504485006860238400 , 27339755153838927187797652698885629105371375369387200 , 32549826315387960221843088251815232973623026001976000 , 38699975402753716601714199367049167718295226690766400 , 45949993731449482425090781136293311200345898618940800 , 54485092715767908879593031358200060819370741518787200 , 64519655694661799844557115034473200131038531982473600 , 76301497215538013631834577347629727915997725540124800 , 90116691510825049052810683168900302110308251103742400 , 106295038446723984441653171691844994807615474282068800 , 125216242335033220084394947619489130820184581552968000 , 147316886710573415231548866796537984336267810146302400 , 173098296521818191469038067839640136144084019723648000 , 203135388193689197505013217754587647595664430991308800 , 238086617731372623353208116618964162326450143272940800 , 278705147473470222685007227526828653718525658435782400 , 325851363301481001230330229212152068675353642551320000 , 380506886097921465942289170880014323122385183323656000 , 443790234042439794262510072847387739494965628106772800 , 516974305965665264578369012545693427825335530680804800 , 601505870462444709527391718266359580549727471256246400 , 699027260812751234465693409102342148587583782454320000 , 811400491978404723788656325891274832588941902135529600 , 940734033038583725886303109540811997848740074421257600 , 1089412486392573629584846510561117105423544270329953600 , 1260129443881175295752233969397334320046226741599768000 , 1455923809637927175236974197360602781611464140044318400 , 1680219899945959575500705012072593387400054565086721600 , 1936871651604866797932696508123427328564215358378124800 , 2230211292249787694878033972980465767671457244244550400 , 2565102848646513452673279378564189447904755691133126400 , 2947000892129993575003300712877930329593976403855571200 , 3382014943965064531216829423315429727117748108116748800 , 3876979987373939658881551670375955133402178749998681600 , 4439533557168150885585034645935150302715699865537420800 , 5078199902193372153425891183649233935452499478156352000 , 5802481739980294089361415199505084232934230451095750400 , 6622960146903160706156584914468439989566598205809926400 , 7551403150575879614324816556202739460319207175627884800 , 8600883613929234519191754752964584883497162946825542400 , 9785907022164837647572724551265641971796175207845958400 , 11122549804290183785121601304215436463612138917553542400 , 12628608839913038728712241757472157533394915839823840000 , 14323762819081112663195913974554367380208970342369388800 , 16229746137858205429196134038199378829798625065422694400 , 18370536024649213857084255994860412237496321281683302400 , 20772553601644012068191084550484111995009544450451097600 , 23464879591713213323966380804299170303478929849715302400 , 26479485383238277392933231031579751832626210437889068800 , 29851480163216488254054839963141120641943768606032339200 , 33619374822096234424759880261933465030517223679228409600 , 37825363321649874347224316975952326353233215861344646400 , 42515622199305346638758937109433220615875971921669766400 , 47740628858178754405418368885635310213650696752134060800 , 53555499261093428048153683509398133645986758049407200000 , 60020345608556381638925579016424212049777116782838892800 , 67200654534512535169478555990024577511563791187746649600 , 75167686299117317074551975705410517123395349169540416000 , 83998895394309397753683974875439525037076519915834176000 , 93778372905035340937221912511497173306785925168441894400 , 104597310886180675607398947268597528518642402927433209600 , 116554488922023358651204642131976921639706800166384083200 , 129756782931033369178878494357494557481487213443826361600 , 144319696163558380599202221293590856617601391684340780800 , 160367912213166553941048909374970577929522450372689913600 , 178035869723680601209002442585168907955806973894486892800 , 197468358323196835712369177632823637233611551704849683200 , 218821135153230449245481418207223557829368029577459820800 , 242261561185729847709489709577314496128974646725360768000 , 267969256332741307464538427195690902184704495399883443200 , 296136772153397105297994074777961641909239569406510771200 , 326970280750433659035864467299512366774712704595382246400 , 360690278224339359047097294518254973469929392020187795200 , 397532300817388372453880402921322084108232083562533638400 , 437747651633311654654825208569418607603248474738333664000 , 481604135561209530340613447100560145264638332839027513600 , 529386799766013553882115647679466838698937086731635564800 , 581398676832485637823205986143848908201585960157886969600 , 637961527367368422680134816953425727482451103851218630400 , 699416578575087315575332598062109357439676663449899654400 , 766125255028860141513986257319991945511419826702735756800 , 838469897561456286560435822827508044028353225485397670400 , 916854465901283568307286340219010986126190373310966950400 , 1001705220380215033677030040853018291231461005655399795200 , 1093471377743396798982083474615024250517004444992758931200 , 1192625735798358089466503350609867969170156083436943776000 , 1299665261355622621276496741451519867023598663926602809600 , 1415111635635642080749831007569720744256829729240292473600 , 1539511751052625008646760489957975627346323259632070528000 , 1673438153034302661183444701499265762820298175659023539200 , 1817489420304164178840462323859389421797611728063865497600 , 1972290476838260937417437569839342730330683587892495667200 , 2138492828519645566516672873618953231890929955511919660800 , 2316774717348154457625046502641446032437801260795719481600 , 2507841185930040097862030343607104361559228995059922233600 , 2712424044868129308532535937628070654898998126965841529600 , 2931281735608474474409298831150868965784481491581304339200 , 3165199081269734718369453210069556491202084425782762016000 , 3414986917997951305235203263217379475130654780250283360000 , 3681481599446036541868777155311089700550214586160749164800 , 3965544367087045733498022440352205724474430771625254912000 , 4268060579224949995196950576056391949630115942199314432000 , 4589938791780941648397446771904318580637691448199079936000 , 4932109684196357831865607796933201261023153552732388966400 , 5295524824122064427748777054957869198367920836354685337600 , 5681155264944260770507009206303822200254971936090410188800 , 6089989970647812520488918442089851077196081012608128614400 , 6523034063021894614932099539950804539029186002582553395200 , 6981306886791694195870986652919077218487908031231286476800 , 7465839888890876033414219175631849032091543114117627084800 , 7977674308798870306610399087370159252359840483096941363200 , 8517858677625630588525384099844043240394872974878302208000 , 9087446124465376670382549473064951669213841405453554892800 , 9687491489423828341975948983782068202825451843946066329600 , 10319048243686932586949609176172347790774841139869195878400 , 10983165217999109401779899396437304204151621681735257702400 , 11680883141998284599601447976234769709507704271387230208000 , 12413230997960027320114745854558257344584723723138803302400 , 13181222193684746997390441205390615765100498679888076800000 , 13985850560455632180090267405797680971410369495202363801600 , 14828086183260844393909552623446909982948553470107806924800 , 15708871071734808638438050344551551209799145261193928704000 , 16629114681601122838819015083023136329742730492370332876800 , 17589689297702457139435071802978605926439957560352133939200 , 18591425291065590662655439220639855623266147116850631065600 , 19635106263764221402842859103654330264105055078349685145600 , 20721464096708738795964031884537347599714176082420195737600 , 21851173916784392254527065395519540558593487941737453568000 , 23024849001095607288558831994102500176875496826125844480000 , 24243035637306207565057200204466359487001999970736776806400 , 25506207960334500461469969553475661800423421152089175654400 , 26814762786794495877381664339601623430884961121473989017600 , 28169014469736775787210742203195292244769980451333709004800 , 29569189797233930347009096495117900170791020199696334028800 , 31015422959371598764988825205403170061502590208624482713600 , 32507750609013437684004803516765987684319401179273917235200 , 34046107042539310183688939303649122233133991230933226700800 , 35630319527338714036316755815814713249573203585394422169600 , 37260103803447881384186571465898776701425714389431059660800 , 38935059787038450846309216135412710025490265095063935795200 , 40654667503813902993423658652761355920223993282944209715200 , 42418283280388091348432757237223289092758073160872098201600 , 44225136221780827616123075343519641227769369001683548569600 , 46074325002852840427110007816322253982910897811127374643200 , 47964815001247960891776463442107786734486581186243710156800 , 49895435798743065849960416043111382539485330221772744294400 , 51864879077321654661719940618805873415557275426408760934400 , 53871696935243410509832315781806578343819921218991644672000 , 55914300647459802751978863172309958493482245267323869184000 , 57990959893299982969217415754560320538426347035143289651200 , 60099802473086513984377942419884969684800604986473247948800 , 62238814533534755463570619897933413853931153601149987635200 , 64405841320197471700426530521515027102552039673998054195200 , 66598588473033988679043300812744447874109039231777549516800 , 68814623879287737284366475003364351332307031542975382323200 , 71051380095323697918484024736427319430784303617572958208000 , 73306157346901974757184961153440257072160823556369295769600 , 75576127114516398480107609695228890741932438726586101760000 , 77858336308022965561224332944923291954877563636564787200000 , 80149712031650166516473412742792433695307189888716013568000 , 82447066937909470203600775146036756130045470205913524224000 , 84747105165567080159031274834450238999504933569904542924800 , 87046428854142466936210427216524205616677823275867977728000 , 89341545223884111064648711857241833750707216456390692454400 , 91628874207440798946031762887320199500495969185826365440000 , 93904756615819891434576130369137646736966964724799324160000 , 96165462818543276491557214430811164394901326820752752640000 , 98407201914262590649521840129427941737884826291678576640000 , 100626131365523123762957111990694789766235359107546931200000 , 102818367067781619765137796822529282887751058438349987840000 , 104979993820428859980533934455490842091356061812868833280000 , 107107076164090675927653274497392138054555871873004216320000 , 109195669546446994735313029252124218641664037639232061440000 , 111241831775542694825158656089778170633100360954346045440000 , 113241634717890211570572378877797791808356665251744153600000 , 115191176195700710396039388290915733145073248886962421760000 , 117086592036385254652444416111265145865492259817980354560000 , 118924068224813587905661090829558957700448926723563397120000 , 120699853108199126467723375263396388917657088784727367680000 , 122410269601239270114867620256971428566614578962250506240000 , 124051727339086010546923954405123531220791412007777730560000 , 125620734723973063072756935274102907146943169253953699840000 , 127113910811949220478661918594574792353332767512985436160000 , 128527996984845953343380757655431474053871618410031022080000 , 129859868353986057297864002975396877703770359953071759360000 , 131106544841339716742530301592488744223305945457139752960000 , 132265201885867512147582493590525552449794751939499663360000 , 133333180722562570367574867580851464108452305238958039040000 , 134307998184495032096569073870012156876960376319209062400000 , 135187355978335156691473214496272889701615195731853230080000 , 135969149387430192376321251128201373899150752465472225280000 , 136651475357174846275211547265600838811305958909028761600000 , 137232639921595318136175358550984974654057988512184893440000 , 137711164931249674502089898088333526331085203944032337920000 , 138085794047415886829884819908409968765138084986596147200000 , 138355497968926431695251712856202823636677562845301882880000 , 138519478863600080307698150453155268185179815475335946240000 , 138577173977923531558181424493995229733520058777227141120000 , 138528258404560632777498415041596738858094339230303232000000 , 138372646989312670543878369836288269430542890185948651520000 , 138110495365560532797166661254629415676994604187634892800000 , 137742200106114711651056509180561903957552994383133736960000 , 137268397989336201531501859590039166784565663097530286080000 , 136689964378322889274166516135286171719514230064905748480000 , 136008010718834486256955487263136699596031305337842237440000 , 135223881163660770169558920285926798643652387946442915840000 , 134339148338209695548123163995713162233728268197737758720000 , 133355608263515966340339446029564668034527198284301434880000 , 132275274460247782971688384758810573407106073498708500480000 , 131100371258437545173657016188660959265102512997210234880000 , 129833326344498054442479326436606903562128631771770101760000 , 128476762578131580436341979369492071149429191619136184320000 , 127033489118479527987333494896462168692919589448899174400000 , 125506491898800958084386759254945703758894107686640803840000 , 123898923495851056457949343789413234543827801774658478080000 , 122214092439557555003054259823179175771668286817204674560000 , 120455452014439597683623396847237402157155468968142397440000 , 118626588603457687575175175265903617335930687553445273600000 , 116731209630532465100715002372091442097243145992026152960000 , 114773131155660422268656861341234447549133659921231749120000 , 112756265182244537981956390881011026451276562870382755840000 , 110684606733340434112137814233389156498247084486005882880000 , 108562220757695482947263549079048032105629423534418165760000 , 106393228923529528551642285541740973217080756387373383680000 , 104181796361845767478929373012866612778229145153855160320000 , 101932118416171383737763295103519777994434495974989496320000 , 99648407459840891285382817006433397062154116885487943680000 , 97334879836566898734798213400230813578361679284871495680000 , 94995742982315647349407194169797998716495658881190461440000 , 92635182781552877715364450205537331833378907504896901120000 , 90257351212989028318497902404926544808083616434846433280000 , 87866354332731485205574186657609446911569104305769676800000 , 85466240645681898536817690060770688019018321958511575040000 , 83060989908623587724748349728369593143677935910636748800000 , 80654502408986148771137093834783071669840584894932582400000 , 78250588757053061680596766754403226213231805741004226560000 , 75852960230031926362704935124203733616306287730733875200000 , 73465219697515513419650876896249141044658884997023006720000 , 71090853160126078636228765395251520679966835669654568960000 , 68733221924607316039321044635148069922139106821858918400000 , 66395555437948792004919609387850235002618706794726686720000 , 64080944796751752934463857531110894936391165632300318720000 , 61792336947863859286922290173487116846696933582276526080000 , 59532529586804664893076504922273485740429492738805596160000 , 57304166762923528255767894664363347117822307152400220160000 , 55109735191605553197972507986724943378327842148405739520000 , 52951561272543986599036540399864539209116395087754690560000 , 50831808807880577164106554187756620648917896890381762560000 , 48752477413681677479047054176348491529500046176430981120000 , 46715401609028371549225280103186002823394805937515397120000 , 44722250570368282422285683676524353259880562106453852160000 , 42774528531178115849201454263426342500326924266418339840000 , 40873575805482043715811082428825379899827981234265784320000 , 39020570410901179343698161736950896239475725617665802240000 , 37216530266777962064503909081126727093000595380469104640000 , 35462315934934743263410862129032917628470248312971591680000 , 33758633875575501274964997759195204732617118189659750400000 , 32106040184851988718461869144209197505091253315042672640000 , 30504944779074884692655642417821161824747262681700761600000 , 28955615990978027822460958710598005642335117566427136000000 , 27458185543618232454633733702544733181871699097739591680000 , 26012653861023994126700741772257315669591501302191882240000 , 24618895681364269406003928796716756228677290435478814720000 , 23276665934591015315461414777878420696664498396228485120000 , 21985605844596154817997624300661637076302315168415744000000 , 20745249220031025953175586978226268651716420518967377920000 , 19555028898097899576269981224880006640260683315561758720000 , 18414283300687748525315077105814562641477175327426478080000 , 17322263070653759116284660875591916099228009827574743040000 , 16278137753999106939389308117115076442961207848638873600000 , 15281002490795095978925038479947634591443652716247121920000 , 14329884685871932291678850103988268385740888805251481600000 , 13423750629726637148176389357126347433350097335447715840000 , 12561512036200532476821568053421467884048917582750679040000 , 11742032473180963640619089752844871104012257457885675520000 , 10964133662175955286289174213012843677520533746719129600000 , 10226601618004874671194150387610596333873200424954101760000 , 9528192611506330354686181788072088975592737350462996480000 , 8867638936271353096850517256429966693119893694232657920000 , 8243654457039756585780567328308684061235769456690462720000 , 7654939928105653990654904617253837660718671376325017600000 , 7100188070490558208654699729820074321635663453919641600000 , 6578088389207097202527838392537496935555588922422067200000 , 6087331727496796590307720387035044533691375536185016320000 , 5626614550922153782069625594119828765153099940600217600000 , 5194642950189487448865574192195003012801935994336051200000 , 4790136363258289963713115318702149261257164167189626880000 , 4411831017883679704707378792817953411557858086590873600000 , 4058483085493401907164027691135210616449921384647229440000 , 3728871555584881463199769936998989017696148831600640000000 , 3421800833346424683876860459446349110866329353715712000000 , 3136103058656113923655353888329505314030659105062912000000 , 2870640156958670789987023680328616611124841045884928000000 , 2624305632629031595668425507207281582925603164323840000000 , 2396026101628945927394372193706096333636677781487616000000 , 2184762581840925801882702416337113449461628499853312000000 , 1989511550784289720361640115567205441760823712022528000000 , 1809305773555847807227471520490742020174540532482048000000 , 1643214917672992360734645195698099262167045479071744000000 , 1490345970943900699780651635580048242320829766434816000000 , 1349843461606794138355511760052115062302190690566144000000 , 1220889504096222698974996223977404574128285732372480000000 , 1102703682349318595127802183499939118362600802680832000000 , 994542774790913775124984080409074239347233145159680000000 , 895700340515384167482297602265221712821553984110592000000 , 805506183797424063556754104980342613632507275182080000000 , 723325694828205374983617936705605919238707583844352000000 , 648559091277498004631353388991283751946472509210624000000 , 580640572701149247955560631220122386254735509291008000000 , 519037389172262345567535653470923642084394662887424000000 , 463248842654356822210387856303371982382939909390336000000 , 412805237555798494133851518368503912166168985600000000000 , 367266774524872362735537629245379919332805175148544000000 , 326222410895029104325041775102057306327286015852544000000 , 289288696760508278340690836108921311049679460368384000000 , 256108583715168272834441912425721565185927584677888000000 , 226350223988375468251256579295941165558318386642944000000 , 199705772101839572897760787312596201965773935083520000000 , 175890178553870563139273200448909534851116268781568000000 , 154639996736539709773136542000724188244680636366848000000 , 135712209016483002352157629206895579470719820496896000000 , 118883064399526033813909200010224650449549617266688000000 , 103946941821310262564458513432899808037301443887104000000 , 90715248767399894588369581420607785195245265747968000000 , 79015340775772473926894802858830265846750806802432000000 , 68689479619054487962696352635739495572902745473024000000 , 59593833340517382283821479800312916801696412205056000000 , 51597505824859962630229220773621000010001775853568000000 , 44581609567507947229050449046307613459080028356608000000 , 38438387311175178433063059361214612399318900932608000000 , 33070364107589300455662607544236439460585186263040000000 , 28389546658123862672995590408508368644879394275328000000 , 24316671052137215879173257456268466227028447723520000000 , 20780483633877047632328209435601978335969840988160000000 , 17717066372540259992551617983552836225221890408448000000 , 15069210574062808565983436471038875641620337786880000000 , 12785820621985287036140358476592242356344085020672000000 , 10821361229885471339944771874987892486512345874432000000 , 9135348394869517354703244721464941723232755515392000000 , 7691867564806707341016578004129169074665457451008000000 , 6459130368939107431804977844960661010295170269184000000 , 5409072700520432696919853647528221879726726184960000000 , 4516973460433980170293229590497994156851440123904000000 , 3761108305585970435854314079638741133287814594560000000 , 3122439054432143566304880470773302453221845893120000000 , 2584320159093443149290170217513687252111967911936000000 , 2132234389611167495884924240508714693027432497152000000 , 1753558691413453488925793166833394849138276827136000000 , 1437342966837199519272263779067179357911606362112000000 , 1174113931974599535804705115282993552103735033856000000 , 955703082125390560331912200761992328585425190912000000 , 775083893996613340252947600060645792360840560640000000 , 626228778161513182829686908096736224817082007552000000 , 503987508170833276868227746816096857268519174144000000 , 403969805672232972786532934951597533894312722432000000 , 322443583855019135788484996876787295020247941120000000 , 256251164624057315214802676089777091764178386944000000 , 202727001326960425102406571689311406076639313920000000 , 159627476284334454153191854735433422161989074944000000 , 125074846163082906448588417550940197702640599040000000 , 97500249198278505021376385081077421988170956800000000 , 75597597000435423101616247736040667050449829888000000 , 58287054531518210071644291143285586063827927040000000 , 44676604241303086303294545224555060887629594624000000 , 34031981099892648647538611259666267771607449600000000 , 25754873569371660064108964736931374671541043200000000 , 19357439542990579724121362972777666006797516800000000 , 14442723572953335523638256049366849710089830400000000 , 10692572893702418822875732135741603173315379200000000 , 7851412632988626413652682636182615586190131200000000 , 5714180251661004251953014228848237947020902400000000 , 4119664520193264750938670848286952524664012800000000 , 2940258087089249557307682244683510442465689600000000 , 2075025556599168082083698216931829856442777600000000 , 1447145729729818188908435203031219784646656000000000 , 996429844951957665455376674749083527046758400000000 , 675893452222768279845821208433197050127974400000000 , 451254283533341304888627283983461565176217600000000 , 296153785251433477376134579095007359349555200000000 , 190335770405034405422221248068214375579648000000000 , 119422201190599035272704447302285673680076800000000 , 73157909736267935399256194167309967818752000000000 , 43345158882794459214944053508582227417497600000000 , 24705030038310071898444035272394610101452800000000 , 13576158796857207242064723355737433256755200000000 , 6761461926703598140276595921495778341683200000000 , 3180567095896256157910084016052032136806400000000 , 1476333833753904150624789996104000628326400000000 , 384956219213331276939737002152967117209600000000 , 1 , 48 , 1222 , 21804 , 304834 , 3544928 , 35583250 , 316123172 , 2530785440 , 18505825112 , 124901344034 , 784615491076 , 4618789380974 , 25622698926688 , 134586658790350 , 672062969290892 , 3201522499354201 , 14593303800611416 , 63819392248504756 , 268393855136493496 , 1087730935156693076 , 4256123932726439488 , 16105960414751264660 , 59034599307730485096 , 209886318946984043016 , 724734189448543967856 , 2433359878843087221156 , 7953249077155674195592 , 25330141967053333353852 , 78686470322683494397120 , 238627415803945084894140 , 707071941081496630982680 , 2048680459587733562611843 , 5808686089142036771138912 , 16128111860637141859684846 , 43881828709165160994223708 , 117074209467714983341536618 , 306464468337470146240025824 , 787583808309204031568011834 , 1988180280280224941475393460 , 4932778669526045597755242712 , 12034542165331851828916477112 , 28885906954523642533452303130 , 68244724768388834462163855284 , 158773913296666804184542277558 , 363922682552798423108424249568 , 822138325017471228032783280278 , 1831325769437592584086801879836 , 4023870373908113054330713925411 , 8724621097748169432309987350424 , 18673857015598064010801546892216 , 39469471134869056150134474983552 , 82409620040031935517481650492640 , 170030993456902560054936891952000 , 346777604529489281667771918452224 , 699328274637378207837090183509248 , 1394915396783300374308786971578496 , 2752811731268938816408105350045184 , 5376353267895636286168602380576000 , 10394373764791136986247421978558464 , 19898515606394641420062636970740736 , 37727979680498631380437417621856768 , 70865019283085082071737902914197760 , 131894639731697440627084891602634752 , 243302849041730850525358862064876032 , 444924861544652779209786366410200064 , 806746357706195630828431025015860736 , 1450729942588296788741298743132905472 , 2587740796592088670723604701504900608 , 4579543485206513471961128748732072960 , 8042122332746214671577414907798251264 , 14016625658546474255686255902183868416 , 24250199102784788157553474256082045952 , 41654169537495577959906952074224102400 , 71046545935254008713068604934952227584 , 120347346201965547576929317224700723200 , 202490533272554278861057683753551151616 , 338462935993961747178428490076612775936 , 562104733062859314508538214755329272832 , 927646975097310473601510566572385890304 , 1521476981892459470480292090690510055424 , 2480397204037671355887076744774390821888 , 4019801451267438611293395556814066633984 , 6476914862112330126888780139648142428160 , 10376791934136886547677664739440939420672 , 16532516546562675687660486663487184503808 , 26196538091724548473862372443217398662400 , 41288076834368774120952837601377584371712 , 64733129423565433811273207068649362358272 , 100970341356635670871824095802368816766976 , 156700050943763083584910412041494257385472 , 241988177063625809440101001012388910487552 , 371885539777144520824794653552264441419520 , 568792521664435129525348962912615135354112 , 865896783907042017114216315124556697963584 , 1312149167335985016701476788801129422457984 , 1979435173477153064586466921567912140858576 , 2972867327851147399345951780553727128958192 , 4445495539838461384576723352471569825610772 , 6619246555155686071549890537261528056005344 , 9814611358570850584762366863206705471402664 , 14492570275352163019365452215854115829573040 , 21313572383354112526262646950677913366648592 , 31220192530180538034549611931041068579861440 , 45552540366619613576357912364466248360177240 , 66208809396511070195950544277058916299875648 , 95867817907788433813031746938243575886650508 , 138296386392955555863876469384049760113135424 , 198772414076990446810199842213101469833415296 , 284665209121017686538867479625452736978412608 , 406228837898456348699433119491134516313144224 , 577683085517970800819281693843038980340275136 , 818681482461530359832558612168491314504199200 , 1156298583023145956333323782445690908786982176 , 1627711637085098296815829966047882337794616872 , 2283808000405946166098790765667628753053862784 , 3194022945213301949300128686623776282059943056 , 4452807890452331886270267896871195158524855584 , 6188252734336076136527506476717877066168250688 , 8573545882471869960114317026785999561908582976 , 11842161761698719676459048341087392536886781936 , 16307930747715940530827736126779132170173590976 , 22391486422398113505438067047589016119755190392 , 30655019859639113270264388227419914140066413632 , 41847825155767625165227498425938185069512577344 , 56965825772987097184315012603000584354869782848 , 77329166136059455463471533956954251512095034656 , 104683085305742618652563182862218340757842155200 , 141328718835592086542430697202823452583108372048 , 190292274406805665801350021451136448497258692464 , 255543286786969734500198730115838227584255104004 , 342275488930389284237696638417651335234361348512 , 457267374457066098922320260003131702457738015880 , 609343938332465548359193712924689653198553767600 , 809966569757780475086374509371593879582948827312 , 1073984880330000767526174667553950423768419733248 , 1420592680312604475489469811758495498133656621176 , 1874540728247280383088961537781878237653879811968 , 2467671711297847942325986127129179410279481807548 , 3240858692555661890188604019968034912684348918912 , 4246447620699054605236102091329928622426560359296 , 5551328197187673383318546926619864681892303863808 , 7240786346844856508116655298378131500487110292736 , 9423326826618693551350954156404893220112461238272 , 12236697430676846613841667721313993733695726904832 , 15855398349432891008359863893588790668968196708352 , 20500023345367295376956507334308010157760076213504 , 26448855686576058477464061402183849019905958471680 , 34052233790879187638313715883841856008301001197056 , 43750312299292161129811933302080782024489607854080 , 56094977372215113010397403442001550748925857416192 , 71776834559223323573837032700412542746227873435648 , 91658378526380072802672597937428097958158587005952 , 116814681955621878260946386950806420901981484418048 , 148583212738069416213719872749421714849456937898240 , 188624711946771350461218611258263340753552711092224 , 238997449038494933184809693088849595234530656111616 , 302247625790522281993233211485179087822763913663488 , 381519238775164804950050167946448050416386293620992 , 480687345747966298316685059099708789502030458996736 , 604519430362814764770484835385990634781766093345792 , 758870440756827764521683272169238635632285297995776 , 950918112168860506114013114127505432840402576960512 , 1189446396395423406804552474976721474949593470433280 , 1485186239611709458979999537138461621971233295195648 , 1851224606933689652026245114329822024887597136686080 , 2303494583587977860466337061093371835180191143663360 , 2861361630214272832664214196259779523808767364360192 , 3548323680794620528306057492263509241303601729121280 , 4392845799377883604827769768755417500586601638226944 , 5429353616529731858452024213726214556599979997797120 , 6699413816400695784713852473444088360286380640448512 , 8253134617197558710297260048589061280282079652837888 , 10150824567867410059074233421410294751842119859908608 , 12464954168689234652287937752002021762150413686545408 , 15282471921437113493249508031060464340407108925698048 , 18707534546801564491205832705001778990677614755395584 , 22864720407605459845773368853438166373023762169865216 , 27902805796091197663053077609924816715964990995614976 , 33999195848656867304505938476777374959731876889831424 , 41365115626512796674674016439568720294724411889680384 , 50251682549730663171693637675360140623294862798566400 , 60956999120342147093212207986370754738571771064915200 , 73834424965177931203182773389205353358298304415539200 , 89302209943560651883229893100604290708241648548889600 , 107854695696967057352936353741980470119832229474048000 , 130075321894211328360763029895410019463106729941702400 , 156651705902381953237458653627269980788490796744473600 , 188393101079184119455241060534053989075462454278182400 , 226250579757119865055242564586210141799664261566380800 , 271340332731571107410711663724382583566195380731520000 , 324970528165760035585841931914600552585062084391001600 , 388672229819310741277547583854293853075854414226625600 , 464234937964331514692783448090130828098759665904787200 , 553747386889599989492417048154160233517206490802400000 , 659644311163602062842391834119556057712233814421881600 , 784759979534520092349131897349843390673080238047969600 , 932389391230729204238790051357772006421112059332281600 , 1106358135283650786118534960484261061257431378746278400 , 1311102030154676843560283061610283911975855851133747200 , 1551757789295945356163120592159667699970446543114593600 , 1834266099224949283640443999325889482847942443663558400 , 2165488651221423209686147029090042560941562167004774400 , 2553340836853546251471768139121824585333424833463251200 , 3006942002268249737756833463696955632134025294408155200 , 3536785357593981469695503381682054062244769356937900800 , 4154929857033905912925182163857007402195314268237388800 , 4875216603374128998282698748780545350196864242820851200 , 5713512588878974705672666855029572163665554461541982400 , 6687984864009259323001514585735377264893222222948921600 , 7819408527292954490004549801495493105144406681487628800 , 9131512255090644868906122500674118711579159894226259200 , 10651365440141236607383849840624094479411153984271601600 , 12409811383657733849909901612257531477508974997328761600 , 14441951388536994782136092805070697440221851504529043200 , 16787685031815542173730588511012225590461524144181939200 , 19492312353925138467632007264064424485374955627322980800 , 22607204191208740754042011262191717023694967171239046400 , 26190547397486397044606632592591914942421556924258604800 , 30308172250505170116353796895265865379690833401706412800 , 35034469920603010134232785793915818179137526836638302400 , 40453408491690040224088278487336723270247182747958822400 , 46659656669176578038870251504426186120022120824258060800 , 53759824984959087072459499368703817368029426994453401600 , 61873835016169729723717811214914582453524199137868544000 , 71136427870496761456558541896591177673230123530698265600 , 81698823956283653430144680951108649935022712438104864000 , 93730546847677132188199744084862087025243062910228940800 , 107421424873219285436006635661764862246049515662370073600 , 122983784896531556649428883921064207864932741819799987200 , 140654853619136375584917140649901269875639658546225388800 , 160699382612455370129048506038525752879834144869820774400 , 183412514177305380692017967842340352932564561272161024000 , 209122906027238568304405955271634122052122121537472409600 , 238196133695346799877929692385499518324232541569488972800 , 271038390462669391068653313808259230006297311817040332800 , 308100505498669343089618589181331601013118090378840128000 , 349882301777351437926934393861960149715773336422927539200 , 396937316185497050374502348430740052689556999318958406400 , 449877905055443031043219525906281761821675892241539328000 , 509380759133889418083584157186458113925716438833736166400 , 576192852719053752538860127574743641406007211373651737600 , 651137852363057818361759331656737909106836903570075334400 , 735123011117719217250875396050779359109397840790560972800 , 829146574805007902908016308734070129593684944931986726400 , 934305727184207645202829723356483871796949851627831193600 , 1051805101176180758700965665806085712322483694623434419200 , 1182965883448058811362783089169908933946386354339752345600 , 1329235539676146115592340944032844234721324988827751142400 , 1492198187636557827295050035793093709119952046495540659200 , 1673585644949244281730033593100317003481781998625327161600 , 1875289177752983390956803074275418938378978265729703168000 , 2099371975857989040862507663846282530355128467759299046400 , 2348082378922049187577980910729358797251943598685263385600 , 2623867876986464823052349024269934004543231613165465555200 , 2929389907178962530259898102172281689157794168703597414400 , 3267539466629633276672920959022289502737900614220292326400 , 3641453559511742739110350938693319313201376463041813196800 , 4054532493735007334181165232881679220572926837135022156800 , 4510458040004010857029751533106483508986198174704023091200 , 5013212462879224143481914653953632495196568745558960729600 , 5567098429910574743145446990131258300096629154831547673600 , 6176759801086495928643266551328212390135701206721154963200 , 6847203296456058377288660932900988919976165638568020633600 , 7583821035152720387431405024712742483139282490377314585600 , 8392413933789807216283962308456923564863155458622826163200 , 9279215946731109203236299600409748258376259336853847878400 , 10250919124566604072702812280148711192721676064746182758400 , 11314699460802353842401381355805232899804830276660832217600 , 12478243489660526722123678848303735056645244994892370432000 , 13749775590717417040110997074155135003107457417670312422400 , 15138085948050529896181744527548654285111850979044937113600 , 16652559103586294212359630511338389052023734330940652979200 , 18303203035359762300157934966351866049527202811802278528000 , 20100678682675922589480991449415081042145985349537077331200 , 22056329830306516292308698779156801517412004434306684876800 , 24182213254499843808964301162593205995941528713084128435200 , 26491129022927865868299531482283464999684447521740254515200 , 28996650830854465126911496469399669007303809118112918560000 , 31713156244468297943016929466255216304018587184810786099200 , 34655856712197157107147470877837584036535753360928993536000 , 37840827192936345312711433753061979528281068835357786649600 , 41285035239959991715818260856241477738096023771396618604800 , 45006369367031675754878932278392332969704058649321090304000 , 49023666513333375656660994594189219674462584760787928243200 , 53356738411417348613486352155318409117812654044793196979200 , 58026396653114105869527604658531287644682096349556840672000 , 63054476235986443313027924027274660579850376122070630553600 , 68463857364691258239068719909916244604131852152422088524800 , 74278485269592380562826618396444524381812220286193321779200 , 80523387798258201252741566540380769370536967935375107584000 , 87224690524049282124937671714414250968584016243671485593600 , 94409629111343323563616290577757586722135185630321203724800 , 102106558666372243716809977433323726300985817769927850342400 , 110344959800628193648905671955482413785140773661040158611200 , 119155441124330972123444313278451239414186048441902495334400 , 128569737888713034201220194638693844008666778111506343936000 , 138620706487742990038266107567952242965061857554358797926400 , 149342314535145465982869718205888040719501947621630230528000 , 160769626225938607127230014453356054147173347816193273036800 , 172938782701658213385336472524306619808945321212804319232000 , 185886977133393207030261097519397424221979834063296785612800 , 199652424252197131929013254069185253298045071244030857216000 , 214274324052977823369734497243544132111146632518358319104000 , 229792819419721494491777976313930289908646370379165625548800 , 246248947417883160089482213031814672090424320477468357427200 , 263684584028703530603895901762031657847925756839783567360000 , 282142382099314001629084425719858738703146221960444182528000 , 301665702319495997651297271940059465133873761326863131033600 , 322298537035668084804648660572514507653116577587693746585600 , 344085426758701779250836270808559015970187410319243051008000 , 367071369221715574219360601143117117846628230841866081075200 , 391301720900044486018196655003122212762643522518582248652800 , 416822090903916928499553278519334554030696401795999968460800 , 443678227221507411960796342213762940125744685625585151180800 , 471915895285757921704738244266672772315135851693489776230400 , 501580748917742315238378287816955645789917173085047072358400 , 532718193690684961792176392346521614885637140587624549580800 , 565373242851639829303124908702680720236476849863521884569600 , 599590365922567671859439667186738613460447317842538591027200 , 635413330210390166674962462665038634744477499875674508083200 , 672885035431006934241386770087655023236667310002066543411200 , 712047341776685728811143747008634503488526330814170606796800 , 752940891719057686900634190084212284513600290624447209472000 , 795604925982853908253428136421277136392141813343885407436800 , 840077094071876747791632155891451153671153744432287103385600 , 886393259892341321726922910348253286495670782559586935603200 , 934587302944042476042557883211294729270555665449358272102400 , 984690915736874399226928609387971913259170091308088981913600 , 1036733397989207839085419355598860424975164299746026038886400 , 1090741448378354108016519880194190764201222780075836362752000 , 1146738954479840996722705406257400002253565783472167872102400 , 1204746781776528703718170719336986487458084920499877832704000 , 1264782562445529771643554873822534424196951631155338135142400 , 1326860484910520299112116664120940130660528862064360338227200 , 1390991084926357891024669537853390042399749194939750359040000 , 1457181039283564396751032635543141897967031065956299062886400 , 1525432962942780797580952408073951573130528660511435776000000 , 1595745210777894488397382048200389057960931907071982151270400 , 1668111684761862168894071437179120984479820573653510828851200 , 1742521647854101536973988810813648908293800432872420815667200 , 1818959545424680127264992023145201216932583110114522837811200 , 1897404835541506084938558746870157849066023686654910850662400 , 1977831828930833515290426497169615073428349629073702581043200 , 2060209539990343514032056793287148213766628288824561960140800 , 2144501549610867751815744130542656063923557681060367205990400 , 2230665881223720577061110655120749816385502691128012880281600 , 2318654890743290539978860937627365967957965301214774412902400 , 2408415171843722556022518973277196910648579359972166060032000 , 2499887477118110958423776644344429954185479310391070059724800 , 2593006656565377016079239696079169031243295129673587925811200 , 2687701613794993576398643475945984357237505183239694493286400 , 2783895281386429035803218410646466984151094365912620408832000 , 2881504615596622035446626732146934828100670910523598245068800 , 2980440611831161747738042998424024903285164217895466985881600 , 3080608340835716514877052888074739901404694676579944018739200 , 3181907006992180938333007460040562849591600837241670803865600 , 3284230028398643736666331157564373892562585968787797362278400 , 3387465140079924860690092919616282290230766562659254797926400 , 3491494519689762852192265433667145499158690274681764395417600 , 3596194937011681104273972651780779191318825698802629792153600 , 3701437926261159361784254513185656228814865994758422773760000 , 3807089982460332251420304227581849476948323466728526520320000 , 3913012780489640174110272555773571602201883897579756257280000 , 4019063418062033118847585249421707128022561446516965130240000 , 4125094680787837413238122828806532683613963447305225994240000 , 4230955330567733840578826158948712541957622943241002311680000 , 4336490415008689797256305517636200300105933126203674460160000 , 4441541599118450277858877353309686072355745696968697036800000 , 4545947516464696830728164643036897609190966042115928555520000 , 4649544141107531268476481371164933385878493969967093473280000 , 4752165176949658400987130025173624676127538303649627176960000 , 4853642465910271772949550022662506436918591652719341404160000 , 4953806410993350629170850747363240886097238023430372229120000 , 5052486415809121340464790915614863176467371774410789806080000 , 5149511336014820320580164141139866746853981121324849233920000 , 5244709944451463442055090986906279024615729742039689707520000 , 5337911404809407154383479941420095146373494556351642664960000 , 5428945755892866405657991952637654567036229317143085834240000 , 5517644400653390789743375247880852240009817424940999966720000 , 5603840602443760330207327008655867776115321621786815037440000 , 5687369981969012177609140872382336540292403157839436185600000 , 5768071017864667981720642222234627313833403687437055385600000 , 5845785543655534860820616572860925305005871456181527183360000 , 5920359244610761383489126082690579609521188272385356431360000 , 5991642146490971217246142759298158487772861029920233062400000 , 6059489100408246483221938816383379631120108025044649369600000 , 6123760254998190050087257073135941471492589739081533030400000 , 6184321520956913737865502511552980505674939836133436538880000 , 6241045018304373612456987122602916482490665010443856117760000 , 6293809512393592185368449724373857544170476614260485324800000 , 6342500828138927166499492729463972226309565375115386552320000 , 6387012249596210284314822588872771604571189920616171192320000 , 6427244893419453813895239225980259802610499406283051827200000 , 6463108064590959609521665340140762286768539361450587791360000 , 6494519581935965674672898296676753571423599606722104852480000 , 6521406083237950138321108602229263735954263544412690022400000 , 6543703296371888163797355915780628102760471683024461987840000 , 6561356287857827811147272395984383289331528920210742353920000 , 6574319674062929790043403657649359934195056322316543918080000 , 6582557808207420252585711650331962520480030193014620651520000 , 6586044927111784898537889898548901968431348711404361318400000 , 6584765272761646153536485914830657747032297889404059975680000 , 6578713171214029917751928521297320598952891827278415134720000 , 6567893086023056915041201033368125657692717173688045731840000 , 6552319627152764108301094025240289094484020164123144192000000 , 6532017534832510703082680019193718590213540766975019048960000 , 6507021617619226097279721016459318951667795154113813544960000 , 6477376666572990989231635166171182475293663470828984729600000 , 6443137322933066578571008275800978363903835375640864358400000 , 6404367923841692606411570289701410348564113258042589102080000 , 6361142301429307068903055268130798955055517822606065664000000 , 6313543562629500906689226616629640584183857580639590645760000 , 6261663822768208789302204675640373058315028795381740011520000 , 6205603923291512174423766196703392062076210940992733429760000 , 6145473104181540655114972803038944131756244037602850242560000 , 6081388664618970553642414438390443841047878103681610137600000 , 6013475579697168025309834191551402577533093849753327370240000 , 5941866110123697312203803894796827049881322395271240048640000 , 5866699369732046098683888816001765025564789306732284477440000 , 5788120891291753362636361560545286749101810153600513474560000 , 5706282152186899485854052152118277519101380370660395581440000 , 5621340104212589933149912366762584794264203632237017825280000 , 5533456665513018934136332752959407976127118246051452026880000 , 5442798222859207066263951885455061688199758630191607971840000 , 5349535098479473802428558223783224395008280285388910100480000 , 5253841033764755266256617984911945113955062237945934643200000 , 5155892639951245109009965245332088869665775715473841192960000 , 5055868872450805088334438246343387748976779052139226726400000 , 4953950474500051975252401627789847567326424777778378833920000 , 4850319451339175536355296418846886909495030953314009743360000 , 4745158515892399568427636776498482843501807937819624079360000 , 4638650571876582892852995013898922423366227719535803760640000 , 4530978170303438549144188644155729650066650640295940587520000 , 4422323010260255312037227894851377576652751026958822277120000 , 4312865414601000996604690471803814104645302426460880896000000 , 4202783856586536903883326390229185434147006732711736115200000 , 4092254462530523699028058148025284586826970726058067230720000 , 3981450571812001558163221041410453567319394437360522362880000 , 3870542273445641339545027296161744392937221800777068052480000 , 3759696006153936879613669390293621189837047286434481438720000 , 3649074134956324984323400231882838652817279188212546273280000 , 3538834596993567660669112158057690229357289143447938662400000 , 3429130523240853117616085983954194932732760351322142146560000 , 3320109934750410023394511317183424603727288084265713664000000 , 3211915413467943245280408135253628171660543181148276654080000 , 3104683852457874267839566334934396537523159458292059340800000 , 2998546178699702948408100557189619864012965722605921239040000 , 2893627159654595113809297877096227575824091214000230891520000 , 2790045179783454882565916070208802231386376375616397639680000 , 2687912104686217611984849531387465670375521976377236520960000 , 2587333111878566235683419635942909884902178494675589529600000 , 2488406612615209839040486330528389812835520162682811187200000 , 2391224136392972998262226528385906771285217053678916075520000 , 2295870309406816581695673279153069853310498030851388866560000 , 2202422791223862374430101290226287580432282895537419059200000 , 2110952307846051212721812101092699309756011656378212679680000 , 2021522637956354572644318536667702877499844375412125204480000 , 1934190697663612138971004736411185542933965674771238092800000 , 1849006572917464887955100440012698041734876568530318786560000 , 1766013652103319755967657326307616605006414460117334753280000 , 1685248700517849522379792279880955748668187995844635525120000 , 1606742036355399274593199119471715349448680046051777576960000 , 1530517642426119189658817657071569280329039558775139205120000 , 1456593380560503317520817372520902023761936474285536051200000 , 1384981135360056520941298055848299447301206229443320217600000 , 1315687061517378319908040348369760740804324774058160291840000 , 1248711754114195449031519895620045013518364541356550389760000 , 1184050523170900119661846986021721440523101713344162037760000 , 1121693584696422045833316471658525820568687881184749813760000 , 1061626356708706224260434283896366883492263716327039959040000 , 1003829665300915990712293016826125994562907960432079667200000 , 948280056232801528319177321588926808643297202638437744640000 , 894950010434140182082416418251857832493177270215848755200000 , 843808265514289439517183877041541917717664355484043837440000 , 794820035170601840401627863979595135833401938518537666560000 , 747947335283125330285075423631978429220734586457502515200000 , 703149202144285067303079086600540279973371326390295592960000 , 660382017967647151514190808797146966169753626279584727040000 , 619599723349141420236555073423371453214702715409279221760000 , 580754137593352065662348137202484529820700942419377520640000 , 543795161094703407792932634781843145587543277636859985920000 , 508671086473445132413530616306602510302133532397280952320000 , 475328787271013041045897927871250775275292702539251712000000 , 443714016199019367503653829099106863472936986728873328640000 , 413771577226428997194415855633356786134885461769846784000000 , 385445608000802017384378248004296634438156859240845148160000 , 358679732747358205263598224599075132035794376824339824640000 , 333417326621870195646135201979374439525601980138090659840000 , 309601647645932184714304144932395366809425382091217960960000 , 287176081048425850018421374909148064556335963637033205760000 , 266084249178361528279505741779826295344635889672257536000000 , 246270234674385057010383681868825064755147344761192448000000 , 227678667545558280172405060914909767513222139048886272000000 , 210254926678830039504418839416500335770877832756396032000000 , 193945204045018092164905685712567317029415689324068864000000 , 178696684194628066692669439976367640075816807317504000000000 , 164457586169511253585074244532427095332980853531213824000000 , 151177321342063068744684373421928725312542941268082688000000 , 138806513649963020220726884441463611325670618275250176000000 , 127297136672729661582956277517949172239432058309574656000000 , 116602513449566623105104285815008339799819428502175744000000 , 106677433588755622210699801285953371109795936966475776000000 , 97478134393726592981478305671037553195463909279531008000000 , 88962399361347464849391456499626537394524597701050368000000 , 81089522111505190549415026508016225920954308079124480000000 , 73820388007994533838962173554021392255585345805746176000000 , 67117422874636534853059606249050909821332623167324160000000 , 60944659110222637226348264331068108221561544449327104000000 , 55267671466473658098086430775256758656847139616325632000000 , 50053629454630851381817474084028283648318297336643584000000 , 45271221968601242864391756114637683826987213258752000000000 , 40890698002028321556988131831616797227984202101686272000000 , 36883782264243122881189735966217269355893842908282880000000 , 33223705630385473319311109321918524526880253827612672000000 , 29885114054557382355061634943818890937519230030970880000000 , 26844090503548888818597509254060983771004340898103296000000 , 24078058759927339948198470658393749033527719766261760000000 , 21565798722012454086764644576147893041687564075925504000000 , 19287346978650798028237171111757403777205536213172224000000 , 17224006580516508840294210511040523670747797799305216000000 , 15358246350361185801202363410016003342679622348177408000000 , 13673706525627038343076208035029770506559325298753536000000 , 12155097916105921324339801899969703902383127027253248000000 , 10788204902771525314594309641157306497610597112217600000000 , 9559785831149911223176888560948519384502454030696448000000 , 8457573976454248586387247975657211270347928885002240000000 , 7470180624089211518409965430281649329675914451091456000000 , 6587094928156645488484741987086694981114681758842880000000 , 5798590195189481719851181719533534541394011840577536000000 , 5095723671409305076226676198192195463412719074410496000000 , 4470246863146447454043092117247095916100539786461184000000 , 3914605351267151018858713203011490645000790267133952000000 , 3421854090985250717778991932427251101124360337883136000000 , 2985657730698666491067423280719171436586783175868416000000 , 2600210867399230782976498653873285795673121444855808000000 , 2260239503423492906060095022360720272082080899268608000000 , 1960926612123895307298116145401832933547758418132992000000 , 1697914444234227760663364771372367478928976251977728000000 , 1467235915558341424758820625805826504318181418467328000000 , 1265317917927166148844662643342627930058279505362944000000 , 1088918092112813188013216600762269145792044905529344000000 , 935129508154819903781868517171407337294978904752128000000 , 801322851829337935910096561807543448041974986178560000000 , 685151926456535433718466534865666159630158288388096000000 , 584501492594008321395109089355047606003877917229056000000 , 497493560643314313835984974134548592964043479711744000000 , 422440199814266717347148738060548796973081836912640000000 , 357850858951264646859513383643667745872983072178176000000 , 302389969987186179866642893021325617013460352106496000000 , 254884665067721295539437726942113917682989307789312000000 , 214287262523105379361841846619372987585639569424384000000 , 179683281633449437114099810351001041018970424999936000000 , 150258036657160884651465613340473652290158682177536000000 , 125305151738374101255445614730615386569497450119168000000 , 104197022778684007694489656008569392820011627708416000000 , 86393202023438068799896650151506217921452580012032000000 , 71414765130285787167549517833430586443407927803904000000 , 58852505158356241728555163339040515216922023821312000000 , 48344421123675208284893434739239805999030659448832000000 , 39583955154895970200315612987512849822651103838208000000 , 32300361264598554744995137776575732585137365319680000000 , 26266429651810413575103588306846382404079718498304000000 , 21281797726190563485222144229048018460039889027072000000 , 17180135328710416257553418237682873613855827689472000000 , 13814696602072661964729005103439102859039849054208000000 , 11065232672974649666955822285739330813782021636096000000 , 8825579408855825610550583492346393673400869453824000000 , 7009867023994644048157359376259658457438941609984000000 , 5542200852979868651513664553635459355125938651136000000 , 4362217477049169445233810564639179531407312551936000000 , 3416253532994993237666796624015607826501704089600000000 , 2662526700461461376077328371154937870142144512000000000 , 2063660851183604726757738288857449388198540083200000000 , 1591138589885963982540498457679977342597437849600000000 , 1219286169402379963902293171796548363691963187200000000 , 929067205561790026093054474188022764499736985600000000 , 703023197888101660465716874169864723781962956800000000 , 528711687285615682752272985525770147577043353600000000 , 394493820713503709730160879860531301017295257600000000 , 292368613271778831590306919274328694422765568000000000 , 214697058921021237052999120652697739468996608000000000 , 156523135089935829800627726809610816713654272000000000 , 112861230667808397048373080918330133201708646400000000 , 80737664167231869203950568897456133651195494400000000 , 57000283763506883738519056441636102557872947200000000 , 39891866563637357430582031084672237986801254400000000 , 27454446854325572448827934491529120079203532800000000 , 18734998954617764960127372891597646270247731200000000 , 12494792760278098477452312029259288479898009600000000 , 8263943840645744672181462614864307432928051200000000 , 5304799135418435491726629666041464388321280000000000 , 3375298631550208004499229309633255193758924800000000 , 2051946058705071025708361768854425388764364800000000 , 1248319074147817055274904557144144094219468800000000 , 698626031888171638387286317504468809783705600000000 , 397083676772090147341383647363154168093081600000000 , 199209496828743195104134180044686136390451200000000 , 104033749915633310003941460010655070080204800000000 , 36185884606053140032335278202378909017702400000000 , 18862854741453232570047113105495388743270400000000 , 1 , 49 , 1272 , 23124 , 329180 , 3895908 , 39783804 , 359447204 , 2925733398 , 21746545806 , 149165656044 , 952158097788 , 5694719344020 , 32093111384860 , 171234172357188 , 868490941091836 , 4201940903422483 , 19451858124918603 , 86388190213053612 , 368936928933886200 , 1518327100839339048 , 6032692560199533864 , 23180734073706517400 , 86274553772842599720 , 311450203717547905540 , 1091955666145907723700 , 3722613349751227634616 , 12353639315273228591800 , 39947506025902743487336 , 125992899854444781034104 , 387928410814033803014088 , 1166998220884015131446840 , 3432771426336732632758551 , 9880975873543250753055031 , 27851094519096210898685968 , 76924386327719348022847044 , 208325806847452315213083308 , 553534290352709407446549044 , 1443849329281462476035862060 , 3699284894478925542518518260 , 9314614933421159328518577414 , 23061449730433865678214627678 , 56169106154228727309553408668 , 134649293224062596638510620428 , 317837422255940323781267995332 , 739080573909168436168050797996 , 1693748128683741230470371774644 , 3826960838041560477795428366604 , 8528622799392247442814029322933 , 18753788046899687505534600738989 , 40704649738326144775640559081996 , 87236476583536044238617286761008 , 184671592626622984375760532730768 , 386272350508820278167207213434112 , 798578135836471592753161973439744 , 1632320456489523946911725653720320 , 3299795324401159881213626511383808 , 6599136129386253074914279418112768 , 13059493905031948731925757228566016 , 25581225488290599369226149498936576 , 49611766470953449158081432253737728 , 95285140256239509393302826457265408 , 181279181438329868503548495181165824 , 341707525036853741297036004583028224 , 638326976949784166245063181754960640 , 1181976415022082469346838220061452032 , 2169917069843600987093877156883169280 , 3950343842003345329317858712885161984 , 7132961856924549047561552024374578432 , 12777066032601495870219334544485005568 , 22709046674342216551360009708525370880 , 40054460273541793587159545848801749504 , 70123288250363654457765721563140462080 , 121872537632763383361852961474678935040 , 210306210216123507088017029908417996800 , 360387107570959149728933661935943564288 , 613371231033561151717696688090771820800 , 1036999642987434855644464113961835562240 , 1741794511880217361386026577933938503680 , 2906956181966265718488732369728907628544 , 4821271891418538638787913691004533545728 , 7947359877671328454370380679345488513792 , 13021982206239092094987203054156233449472 , 21211798119625417309638649070103267812352 , 34353870295337149551929417063069410057728 , 55325043890830957876799020322820208648704 , 88606262521285699258309134063761969327616 , 141140242908068565982723698448577994287616 , 223628407692753049592956014369696038358784 , 352482303369261571819891955256764708795136 , 552745484298406059457866140742354377886720 , 862447591263994734192705392273783501767680 , 1339062227706398148072358942233140725253376 , 2069041105150893315910507811735080781905152 , 3181826353942422834035089854595947360455936 , 4870353171506787970679949891419870733474048 , 7420918613167451064846030537288528853428544 , 11256509436679027161662954966068010225285952 , 16999390182058369967745331512042665274209712 , 25561140727186285999843234613590126883338992 , 38271657808846954918827190332892685526696036 , 57063247365011889928939145019577623692246148 , 84732307975229354726313245714174114594979552 , 125309879698697323672772262012442685230095648 , 184584367149553341138968626121692314116249160 , 270836192826193040217371426280914294383706568 , 395866534762358959942581684921155333340380016 , 576432698201045593958069462614624109158955760 , 836243778273203312626925976514616330694680436 , 1208725676652748293974384446658222978182603476 , 1740838965205354091582335777802477603006858880 , 2498332748540910370119503425762834419692129088 , 3572950686684757120179969050026136261308500000 , 5092282296033505239864823529205102338192637600 , 7233187336304719714071975040514454334607794848 , 10240031390430306123669014493277973297186757024 , 14449379767946609605787357666614699618610187720 , 20323334408930490307211189086916874074023308168 , 28494402838276038929261990247693027207978824832 , 39825708513392994631728161827720705475473556352 , 55491550869438640672321996705587831970245306864 , 77084880967985198469642215849449102722872997744 , 106760276544538326707692528902539823894999427488 , 147423607271155934418642850764364467602638179360 , 202982940081173964637719406300795304929812099720 , 278679550802290398639806214910814087607372689352 , 381523440352080303610859313091537210504259093952 , 520864825266150751478077322430923850650622123456 , 709142088570305555730904443976129553235671558496 , 962858143644260839491306925473703721949270818016 , 1303851710208337992085800102485076966203785345968 , 1760948409501761972349281264706329248815711850608 , 2372099823285225323146987047124838194391271746004 , 3187147924877847743624433854024567935788158678004 , 4271389054901798429322716809743892650845153331360 , 5710157693654921506146464927657327952778308706656 , 7614707901719629138280420888136121412981063592456 , 10129742185132738659417934676074071667203189014280 , 13443027018939195250105426334473226951947420495344 , 17797645388496775427438122945401757624030127524848 , 23507574412259138142265659145654914145218150184452 , 30977446374952737422143212435858764829350263914852 , 40727561567538185635339699588608864725018504039616 , 53425479947123110364510042091437873905539244902912 , 69925836338909047329410330334333855102327471933696 , 91320413383539198552722729111474796633073405757184 , 119000982905552922302003744825306097771232485838080 , 154738008069039449033370384180028464315488686252032 , 200779007379577842256405379215503139131165370665216 , 259971243269911720833188127847833619976222952148224 , 335914443597130388269482986913603686810616000211968 , 433150530617716461802867842244856274586427673105408 , 557398862443120575382996612064614079650103756765952 , 715847338135300207178292710161847204901123257294592 , 917511940313696994728970539432397666946745242027008 , 1173679960100335390216493820148271804978289041553408 , 1498455352739774864840815071248268094752241103132160 , 1909428507260477753008149462276597145719463282174464 , 2428497296033796110062631123944107035162844207776256 , 3082871735601093889440855354416140303055911268359680 , 3906301096886640822233337592623242459449625582617344 , 4940570035174985981286166708864584877199997119137536 , 6237319482250991049271557863233900651671397357986816 , 7860258903487288213581856746208895909281826752662528 , 9887849359361176639800943110282015625292833592935680 , 12416551956767321873085953364174921823908820295945472 , 15564754114668819550425143580386992998222543338783232 , 19477507043488394347697295465600387453238040404354560 , 24332232456764351723026726853025760028132862406021632 , 30345585380572084088127158051844564145696773767548416 , 37781693669472575031153950541824871598275406261831680 , 46962034241487665741813270575938340603862616173829120 , 58277251980894216864448158921310265209273907633266944 , 72201280719831957585532468909828044310926359136294144 , 89308187827271897238627021648076565267518781786664960 , 110292235988593029639293430326461802740304121347088384 , 135991739202929137429978170379737899698398079515212544 , 167417386500486493896705234641855059762120397719407360 , 205785818241397855850632745062481320424519119371866112 , 252559368189173930540789613831000321081319971486188544 , 309493032203262955394996437298989199330567255941504512 , 378689894001933708756908109172306808743848995704975872 , 462666432961228894902127667701085006422814716573834752 , 564429361639912544976462172620492910820121564028242432 , 687565895339746048147670104065818401324763853790016256 , 836349646631209325474330187326462682231248470097299200 , 1015864668963141296530406080030185869284521970250265600 , 1232150550298714771893447226115241827241400011918566400 , 1492371885794136957873881693662353438417217770098361600 , 1805015944068039757959943935668156901898739452561132800 , 2180122891449060528323085052467402382412055912826886400 , 2629553560281102518873658054324036850636587741863788800 , 3167300449203241609823121126126662702226247509123686400 , 3809848434401152733950508796703901165482793733482592000 , 4576592561108622883252817644015424428024341812025561600 , 5490321285001327490635790862880018133170361208016761600 , 6577774655433034551391244079712769703243252102960494400 , 7870288189621346397442959208331633339363414535962779200 , 9404534592905786612935024737392077884853145174310729600 , 11223377050249503890986644487943788583350606383421833600 , 13376849564637909853248480568759938349316479199978520000 , 15923281766626050350082561099896378406906467327784120000 , 18930587785025741454359756843972837219044541706027494400 , 22477741172016838465513609468578897723806288453228083200 , 26656460538669808210827630747418888755480024928129608000 , 31573133502311402264517081183324681371151233893224206400 , 37351009800203614098083198498309729206911825329538307200 , 44132698011026017879287270822545712283215912228836803200 , 52083004274604292609752979279415712892670154118959864000 , 61392155740718019066784427578674888175903255084348248000 , 72279456240714712883787068490285573448553836101773395200 , 84997426893636546631011242766752537672685029360354553600 , 99836490065711775447910680070665351525693067542441969600 , 117130261333862188924587236434922953239890906156638584000 , 137261520897177731940768462391010321911249613061962947200 , 160668943273165728902974441195600300278090872675486620800 , 187854672147176591664762026725149313514949890628328372800 , 219392835953824498807203917089188058301069400126095380800 , 255939109199324202750436428283924529318862238848772339200 , 298241434724783384476738494756712703855045741407996838400 , 347152033104256166491472218210565810413180775518840056000 , 403640837209287216248170262715051470820721303496201649600 , 468810502694943043860791183533411265121313480420564060800 , 543913158811239005099087340052073695615765538884567248000 , 630369078557611236585056759452698134773439807791044648000 , 729787462813995530427269518181061218127698778661215720000 , 843989549735412109162871695186878326297704077696447916800 , 975034278419956821041039272335159529618522186063849420800 , 1125246754681750619894179530862038498669370309093300646400 , 1297249786705271824399121302313847565623488972843955110400 , 1493998779445548188549554058528916662080452172595924313600 , 1718820298883816777785449313634856792577052572633043980800 , 1975454640658208953074532336961887779118152754698334713600 , 2268102762163566570097525815973570072967098276733337312000 , 2601477962945548205183354728484057180608771313155002854400 , 2980862725083534348093035098198246940868920600287056921600 , 3412171153236544166834745974116755473224237639098406406400 , 3902017483075978173216318294433817176493944227301488902400 , 4457791156896352016876299129172559854193267000001109030400 , 5087738996212990751160557658746431215067650926644462041600 , 5801055033042934481995832908722439137179790257784269068800 , 6607978594223095380598784963034748248122407895199728371200 , 7519901266433425887041032590124974503404837305464451763200 , 8549483403426906323728916430664685995352795927275042099200 , 9710780871169579048845048462984067673683172351289231955200 , 11019382760985483371158419739312194827963596373264998099200 , 12492560835187234559278553806858381628933485342506996480000 , 14149431503829708621362137552479508377741990714508878796800 , 16011131164908700512161082234206434178642445460552312569600 , 18101005773264537068332806297934829655542310137642683334400 , 20444815535348562453470785323429921551828686800950474265600 , 23070955657540064763003500089761938388534692977047862732800 , 26010694104515349401977861579578974051542940871176062502400 , 29298427350884448601886266669702063386125843266881413184000 , 32971955133522505645934664112405247883081269514320670220800 , 37072775233289285146099914899323246627176526486034384064000 , 41646399332695343225709763475545380510605999954858565907200 , 46742691010036459430871200539258346000092498221003232147200 , 52416226940070825781719260921632092612259834357797635097600 , 58726682375899958506306623789271451113134113702214751104000 , 65739241985778994463872974484775530606864364939120072275200 , 73525037111517573538936138754807014429876885451920313990400 , 82161610501343945626882655123908326295369468016386502668800 , 91733409548940740348878270991190572668237710981387706406400 , 102332309041197187556172762038391681003885243653507018764800 , 114058164379373565870495486546189752780970471730629064896000 , 127019396191200889920241363546362412161375927542825665689600 , 141333607194234682081369224285571197756247564042929804364800 , 157128232102911271956969482704831996397502169718282010681600 , 174541221292504771841092373374246553241750617686426984224000 , 193721758841943466178857901134138104201696476921738785689600 , 214831015473514925056446250106312299069522017663019455283200 , 238042936790312426912265434794583057344181378648746935110400 , 263545067081184478592179553443674124152099230616636408134400 , 291539408817469662743730911466745436857554483862681359667200 , 322243317805322020553194191601312264209006828667912560460800 , 355890433781600089825311125507845443002864357821240324800000 , 392731646049580922889577105174566068469703222528703491392000 , 433036093542967014775690689932336221861413894992369802508800 , 477092198482365151929895971285678109688161657534609983628800 , 525208732547628018607222695228229257240479294470728988204800 , 577715914231885807520521776443693398874265159051424374854400 , 634966535768995375698838006551892299001956276816535679001600 , 697337117735386511993057983977193424851084866152428865280000 , 765229089120418783414979756571567867049125535739507223379200 , 839069990336452531753924837787019516708228903296580587731200 , 919314696301755041736237684416474296142223104889234467366400 , 1006446656376387126497855624702278476806505321091156696435200 , 1100979147564608034172841202175159340501383423687746814483200 , 1203456537017595073525588444133288359156168667269430873184000 , 1314455549479101504269249706121328400247986434471488013644800 , 1434586534914788912047490983197545601527758349188906212633600 , 1564494731155563698340551651817861568626894497877945869664000 , 1704861515967249259915651481389813056364191282313001845036800 , 1856405642536069609620565754524196516523800664492193111795200 , 2019884451932824436870556403700036813533988097499854634252800 , 2196095055691618302328615746611549951383247009852597753817600 , 2385875481212832078406315619005587629948835919628598340339200 , 2590105772278642609012765411194104770641809017719158951884800 , 2809709036554156814560676028453616226093807738964729953126400 , 3045652431542746310212497324313767537595891111814074020000000 , 3298948080071803719087908087317153914169505165906545044691200 , 3570653906010215674858244198335570002068779392663657240576000 , 3861874380562602886294053258513504071584758867752501600256000 , 4173761169153888500233050220237450776239147196040567275110400 , 4507513668612010621240098729070306504858233454353268065484800 , 4864379424083445301448131786403454531240390702365182228070400 , 5245654414876220959724191993468075153118935089430113801830400 , 5652683198225955113318904595150588848244834355232845956300800 , 6086858899822051152376667818410460213508963617375393634304000 , 6549623039822108617983242980500110219562805102396975460352000 , 7042465183021848171290836422418678749225529313336761312051200 , 7566922401844902073958833980294215715595423380220373744025600 , 8124578540869523834691217457225218052830112008858896251289600 , 8717063271728089385285098331274826965281641439475713219788800 , 9346050927396505813498956104255347227834412289994376826880000 , 10013259105145897451629378208434558759002995500493107990118400 , 10720447027752580752454645441023375970674074576261958420480000 , 11469413652967164741057888995010200915938731026386115520921600 , 12261995521721673671217186972309383891704446775696445165568000 , 13100064336119062283895867692685732247393175358045224552448000 , 13985524258891550370942938800486407077639757382777006467072000 , 14920308926748695776670558308367862428675489469027371517542400 , 15906378170848786959951920929163342854477316291818482799411200 , 16945714438535704104683562400293054805066160841331648806912000 , 18040318911469646796710835291522738450394179435765040319692800 , 19192207316364048387243127612350198379702046574842924167987200 , 20403405425699611420554487810693336374969528826588840073625600 , 21675944247042552678280094063496581759076786027008140145049600 , 23011854900919350293198935778393099690251868842875747514368000 , 24413163188620662418291961654347543069113422397406553911296000 , 25881883852787992013625141569819863168096363847446102428057600 , 27420014535208218329923603607122120809716274525510309731942400 , 29029529437861360879699720089763888776451675282005960529920000 , 30712372694971112575602931404849103423808334182011502569881600 , 32470451465545523704128030307954784251849745088572692893696000 , 34305628757707804941635955867961096812941835991303720722432000 , 36219715997945225345495177852371539958109523433367657865216000 , 38214465360295644805575968078303625243125199105090726427852800 , 40291561872376284286030808272733742364992247770909201405542400 , 42452615317095049484776176427786479074391833175825811846348800 , 44699151950788906475587420075019119083430031864775161166643200 , 47032606060473721001597036453851775527087434985762831817932800 , 49454311384770471459663062179103542895164854273182424128716800 , 51965492424973128935169656532580189788654365256442866326323200 , 54567255674533139527442876665714102540334630624088292598169600 , 57260580797048855669745362002212697767906388680381933915340800 , 60046311784537387443591766104861781903423318816562446683340800 , 62925148129442358158327937934385392885243685235024498524160000 , 65897636045347589730465508041185794422074617912925055044812800 , 68964159772854469903623462652604468784811330985832749948928000 , 72124933008371110846971118650231810019699138975878120677376000 , 75379990494809500161034243637926920123754435645918228548403200 , 78729179814199112595586873425522160223639453870273230701772800 , 82172153423183057521727610765082427637535854510989939542425600 , 85708360973046505797035281099687650789136838659893451026432000 , 89337041956547971298158037081470108189011989634319285318041600 , 93057218724130897268176978988385643301746313715673320329625600 , 96867689912334534508152107826006046712043829002684855250944000 , 100767024327112259758670548796091119257029541333992408615321600 , 104753555324589724502567919444448679222695387169729923969843200 , 108825375731231447885405980538535704581349538964643341674086400 , 112980333344764003910387650375195899532529581355528267673600000 , 117216027056158039846592243518703452419875343388913662989926400 , 121529803631886669965489090993171162723077590470701260186009600 , 125918755194133989415901557763622782862356191172737239086284800 , 130379717435066631140836140511216880396936886878587662318796800 , 134909268599232948458177483880940024184228276787475481083084800 , 139503729266122328273128273278676441681675849203644238632140800 , 144159162962365625290654160138526546877771682185848518667878400 , 148871377630569528218270977242183192487275101704315165286400000 , 153635927978743614428152995306621613104410745689051841085440000 , 158448118731357865735755079329292157350248041378353862615040000 , 163303008799582529791978771764458632455897002326815871180800000 , 168195416384953919453364886659149860621474642285215871549440000 , 173119925026809146787028044731402743534905943602615122411520000 , 178070890600192253763987130722593448708018750247626565509120000 , 183042449266680308595032677957195441290840949621333700075520000 , 188028526376664452909017483156558673882752520186369764392960000 , 193022846317082244467567811744542752242422214059318398648320000 , 198018943294497185008352139588703074349329116783432512020480000 , 203010173038666210486668729842202374924801531781881914368000000 , 207989725407539064823299797715195275234550655493221657804800000 , 212950637869759049394946435611908007755043255290429097246720000 , 217885809836526331856903282517523790055219612002135914536960000 , 222788017809788013930667522918997509392403345568314970234880000 , 227649931309616334914611693725487511539744229351950163312640000 , 232464129538800140799238732002890307378284466566544024207360000 , 237223118738788870288496033472516582905225647969855332065280000 , 241919350186471465029117918423777775613184077657654508625920000 , 246545238777692760334396959163795532584612127156740909793280000 , 251093182139038404223413577401733339753074706085310700584960000 , 255555580206275496252449246289365937589087474075879309762560000 , 259924855203822383740345352148779259343487413338810547200000000 , 264193471957022951869725991837029871452860810446200525373440000 , 268353958465464536787451065670483433653524042453796375019520000 , 272398926663590119544110823466354024607695988429893212774400000 , 276321093291887787343308525943214224683069817916077280501760000 , 280113300800683078896117251286098045259358174585581247610880000 , 283768538206190173176677120176503707453730540508412913008640000 , 287279961818035476611000337168705238880950701956166640926720000 , 290640915755796873757528213677323942007251790721048872222720000 , 293844952172479534917497483285944419313801886483258799636480000 , 296885851101931317063698692621330538999258812688382154752000000 , 299757639848495037311464133464314885926271899870569556582400000 , 302454611836984490137918080807481894003580361140394574356480000 , 304971344843319409554528429993947183332334201435119767306240000 , 307302718526722536750879683472545591748297380825512219852800000 , 309443931187501758014102138121550692756999470108006257090560000 , 311390515675788097664539794935816851314986682915628138291200000 , 313138354380657100898636993239588748569391460239010664611840000 , 314683693231042998629244720650595784307187274640906439720960000 , 316023154644833233046611236588097455699990101298255541370880000 , 317153749365192588893795047161074838965330286066181735219200000 , 318072887128871058220279689621742531771102776474803714949120000 , 318778386114541233156714973792045228174505230199336125562880000 , 319268481125693033941655231642645788137935774610996423352320000 , 319541830466271528281360691404556302245373587402867484712960000 , 319597521474441221284615683383477451336949736255338093854720000 , 319435074683929625606814223388759172678262051661123935027200000 , 319054446589997531141153020222438682455159252153465386270720000 , 318456031001483585909083368437494291879935169741290897408000000 , 317640658968429800227600083374468639831441109206288594780160000 , 316609597279133078846647272529396147466432799640195935682560000 , 315364545528913586507548436337178248974132644057948894494720000 , 313907631767261368121283232630922500631270631447499115397120000 , 312241406738398702233376340602605655047235735927392596951040000 , 310368836734619442034977849881699389925377204306188470353920000 , 308293295090220582283896396977761577142261410294844070993920000 , 306018552347588502509350824599755540643096074676425536675840000 , 303548765135474255631686990145767702112708801651151430615040000 , 300888463802871892351841791092777450448445319453836787056640000 , 298042538859799974143742566148248527871526943360918207856640000 , 295016226279271156664195297783450414147706170102210687139840000 , 291815091722328165443312306981380423604240192307246524006400000 , 288445013749922733105196683129098930393863625632696396677120000 , 284912166092730913136521682826140515772555215316772258447360000 , 281222999051216856234850240104521929860149724038867054100480000 , 277384220104504084124480479563095265562601068564812025036800000 , 273402773807221143534916978590745713824025477049891053895680000 , 269285821059201082439886868633879178549998372553965686620160000 , 265040717832018220111331073653818988613139289345653405777920000 , 260674993441644486025036587577229750461817039279299999825920000 , 256196328454800550366349624141418658686444727379820447006720000 , 251612532320429716450499803651487962282061994135796855603200000 , 246931520815417749840811983916108530878383445168326948945920000 , 242161293396942069024744409410242577262101274857559094722560000 , 237309910549740653543136218113969858956645131881584855613440000 , 232385471219550220680530287093652873874369881609970336399360000 , 227396090419160409755463137336862636836747776265930362060800000 , 222349877094780189679927267196874404240121064654200632770560000 , 217254912335290869678185563427233078648179179466272444252160000 , 212119228007791256828146380874165541210965740572724235468800000 , 206950785895792172509061444349822267588113996248221373562880000 , 201757457417286715960780431335943843802233354604747511562240000 , 196547003992500333793529179480563802444988551964364322897920000 , 191327058130130433073218462356038271982181604363420119203840000 , 186105105293687367563118319527991276399832441705337781616640000 , 180888466608491256196158150802646768283488957619471018885120000 , 175684282460672139831102012273174403252419640193886423613440000 , 170499497039096056530069678302296483836980370381560329666560000 , 165340843862089804290015565464443381043695937352093195960320000 , 160214832328359037929656017857148795950493178396846830387200000 , 155127735323430862511859780769474745885872881486512176496640000 , 150085577910914898243462912038140617967431695031444905656320000 , 145094127127707267612072210130168890441381910366100190658560000 , 140158882901569600967716198111175105463920138177448982609920000 , 135285070100117029262354016824703117672864551439853332725760000 , 130477631717261980139440110321243348503823074937717160673280000 , 125741223195642731761527645728435519632229804751422879170560000 , 121080207881525098555410931872818903558386686328616390492160000 , 116498653598768760390302851310899445895972275903999016960000000 , 112000330328596164065628928732869545838997401833960828436480000 , 107588708973443390314362973387628217681489248492065981071360000 , 103266961180450861350164220141745019322646054134785259601920000 , 99037960194534327914793658661896973894329771979871482019840000 , 94904282709742267356410825845428341418315009779832310333440000 , 90868211679048877238013997355764204739271192548679031848960000 , 86931740044512398110684351000571110731493935537727336611840000 , 83096575343156603677426822685718872549625913803167095848960000 , 79364145142042903238739969396562215277644206885066076979200000 , 75735603253283089621210400398704899011685572062106286161920000 , 72211836679654556708960831362089649745439948907172910858240000 , 68793473234907968520142061194812329736501553856948537917440000 , 65480889786695586448306504743084019442947781190612072529920000 , 62274221065963340665410722388643742818715839656828264775680000 , 59173368985488521341343856464203268526163234987735976509440000 , 56178012410968957458616776753601884194201415555656051589120000 , 53287617329146852358665892961015383610155743954856588083200000 , 50501447352943741981930658731877826599943392707823012413440000 , 47818574509424558672766762232940552123016484196680964505600000 , 45237890254752937813650847552788841126357957205269429616640000 , 42758116659532555016450561362868444491126908418534319063040000 , 40377817712226947507111470447912755723800976270542383349760000 , 38095410689894139415181813243035549686668442308085027962880000 , 35909177542754051529706844053698727724915191644591158722560000 , 33817276246590191448824100672387731600433245458134458695680000 , 31817752077408896705625102295694499834719223920301810647040000 , 29908548761527456161573539761676879649273106247618663546880000 , 28087519461726558496954478161188643222183274783235432775680000 , 26352437561595809674148657271762082562191267955997270343680000 , 24701007208523978207101067298473141542186999905290150215680000 , 23130873584210450967826355107630577792653647747773056942080000 , 21639632873404139182985270236223664839946459690484582318080000 , 20224841898999189162837979507384871485677755418447225815040000 , 18884027401937937726475522633388215512372670382597210112000000 , 17614694944685313449020562668711252672195780801802403840000000 , 16414337415564385090897823545487858421953552066783084544000000 , 15280443120360981623278502686501890853093321457299292160000000 , 14210503449949602676217110694619427172357384804504371200000000 , 13202020107940850714575508923221992634362499736998248448000000 , 12252511894842272273306832366158157271565523337432793088000000 , 11359521043944325843872002717724940745058961440897564672000000 , 10520619102299456790031235918873861813361000428189319168000000 , 9733412359068084059882947087848602599223689994858004480000000 , 8995546825915528777296232463330299963234045808517709824000000 , 8304712766778150543686383059603557356336735455337709568000000 , 7658648788687457824428701403203110839160071815140933632000000 , 7055145501893061123479045771592718409389743345738055680000000 , 6492048754324628807517327655565162805928513095243792384000000 , 5967262454804498194358645105582446886875328272315318272000000 , 5478751001196394489567677135232350500023840031986286592000000 , 5024541319144981780982513156662733667058770840155848704000000 , 4602724533237829496479132066898933087232270640802168832000000 , 4211457286752326085101398549934615132591278805603647488000000 , 3848962721794868012331578525836859029079613320780120064000000 , 3513531140827222177453228828676736632673960270571241472000000 , 3203520371501413968476140879520654313640466067398590464000000 , 2917355843848779977297310752236933205480505873707040768000000 , 2653530406449033086281142242321592783888783515928494080000000 , 2410603900510694582188501487462365278397437851807514624000000 , 2187202504613104733071928131063069173747925653601124352000000 , 1982017873068774200175538474386224334473515912994488320000000 , 1793806091122549770594228376378348421228600791639523328000000 , 1621386454243656014660749716152422720825080814730477568000000 , 1463640098300055783251364793358822635720188616155070464000000 , 1319508498257429853271757692240581565095170190033813504000000 , 1187991845422210733784200259095415746724866371539173376000000 , 1068147324445668161324730670188794972025766439710359552000000 , 959087310161638572972189259870717372752284068557619200000000 , 859977487430859470783230959144528910789008657223778304000000 , 770034918171175330114497874848752383196313841941086208000000 , 688526069000445275492732110969374546306706371136978944000000 , 614764804187306803945080653902866047761730313476112384000000 , 548110361400056488164967300874519738266256974018510848000000 , 487965326285416760613567763272181645725544317475356672000000 , 433773603035778944742668576586201215270148639993888768000000 , 385018400397305613461860357722014291940420383542345728000000 , 341220242533161863443439559035699529357794577047617536000000 , 301935003303883066638879997201465130209428507319074816000000 , 266751977476690535144115735090563661378202387882180608000000 , 235291999506156735487480231832864496122745505116585984000000 , 207205601639415024187729184464448546423017291181457408000000 , 182171227520254550939179559735835319061710870878879744000000 , 159893505494811244430413254240573286076698626178940928000000 , 140101574888566895605102724855437538352177610299015168000000 , 122547475600412308614630564902399615576831549553770496000000 , 107004607548503072448901083074881382328483968471531520000000 , 93266247729998952068347694158882483031046378919821312000000 , 81144136626082713883312538926326874499617273738690560000000 , 70467135958474200365155386988447227802586251561795584000000 , 61079947264597621005781620094210721165444538295123968000000 , 52841898898405395631164338566783461449787663773073408000000 , 45625805015130094634054418598435964189157673836478464000000 , 39316881407726566098886990075460979466579554846375936000000 , 33811728871920021242178268823777688380034324740702208000000 , 29017383568648669024591019139810073765331371592515584000000 , 24850420787601408240155262142376125411988683226087424000000 , 21236119684541327831626415291045512810492541527916544000000 , 18107690589973840073796766545420340617930531529555968000000 , 15405548941526586953692320737953506228258894067531776000000 , 13076644399139817573897561783928063195336102266273792000000 , 11073844286304079711230931839943327866361595132116992000000 , 9355358110359617033600846905231883378991111176454144000000 , 7884209151850360223213500208300227519366324612497408000000 , 6627753983958460270477832550360143782339978501029888000000 , 5557234516785799496599522232678089340008492607471616000000 , 4647370949111848578476551424219721099758264257609728000000 , 3875995060971083521817604238895083453812696932155392000000 , 3223709189457402316905874844874079839456435558678528000000 , 2673578517696369101386271001276767892822977780121600000000 , 2210857676011966699234284128240635081788574150950912000000 , 1822736215816163864669458748052273805734752632700928000000 , 1498111703554461389927479010215704553217939422052352000000 , 1227389478502124928847251883775406141164621880360960000000 , 1002297184008287555432892571715724227566278172213248000000 , 815720864345725062565254724185568177835168055164928000000 , 661562418681304863085263997667824839192767656624128000000 , 534606695911304083880060707517603778948317438803968000000 , 430405642725423179974782858899005210262458444283904000000 , 345179801727917886419441120054112968462076739584000000000 , 275725353911857514730405475225337255257958252544000000000 , 219333650096087250841106475539280058156072933785600000000 , 173725150398636576390083026007162411423711939788800000000 , 136985745488736404612865705835215205102688560742400000000 , 107512768055089916720006621011934181885301122662400000000 , 83971629354217992454548019575964903238726477414400000000 , 65252971526648616744146378575562964995781584486400000000 , 50437811252927996345549421295237424719160200396800000000 , 38769988091115494763868207967198851325351480524800000000 , 29627882104970764619823917080704789778422929817600000000 , 22502266427774345277701530230265971996894638899200000000 , 16980027276378585182733074515644771511431698841600000000 , 12725897614650592711804666091875747254971557478400000000 , 9468311578108148388960624638207623928031372902400000000 , 6990522651017904287022106006176218433026260992000000000 , 5119175694077172186192345996086081806326457958400000000 , 3715793574082730201456369889534743701421555712000000000 , 2671931462818241916201746559376625873375880806400000000 , 1902106947280404837571535723824311550483208601600000000 , 1338995629270934168019912556329229715082785587200000000 , 931524216516661946311012772291047518966172876800000000 , 639844738953921945745365694477187673366095462400000000 , 432984417921208724800314166448002023411626803200000000 , 288404074717593291571072619013024207078634291200000000 , 188844160366545721026058760452278043861529395200000000 , 121096835740800257206446275958655129830083788800000000 , 75813212315850053856787603651529283315381043200000000 , 46343451685113369660622952831146060654470758400000000 , 27400322878725846037909545123562829573731123200000000 , 15585183107587183065118002895471454944493568000000000 , 8547440240999839363666629614958281841495244800000000 , 4248761791457537303583877292762298072642355200000000 , 1994843127963482677101717145156675601380147200000000 , 924279882331208395932308542169274048420249600000000 , 240597637008332048087335626345604448256000000000000 ] <NEWLINE> <NL> mod = 1e9 + 7 <NEWLINE> print ( int ( ans [ I ] % mod ) ) <NEWLINE>
from collections import Counter <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> cnt = Counter ( a ) <NEWLINE> if set ( a ) == set ( 0 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> if n % 3 != 0 or len ( cnt ) != 3 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> key = [ ] <NEWLINE> num = [ ] <NEWLINE> for i , j in cnt . items ( ) : <NEWLINE> <INDENT> key . append ( i ) <NEWLINE> num . append ( j ) <NEWLINE> <DEDENT> if len ( set ( num ) ) != 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if key [ 0 ] ^ key [ 1 ] == key [ 2 ] : print ( <STRING> ) <NEWLINE> else : print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
from collections import Counter <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> <NL> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c = Counter ( A ) <NEWLINE> a = list ( set ( A ) ) <NEWLINE> <NL> <NL> if len ( a ) >= 4 : <NEWLINE> <INDENT> ans = False <NEWLINE> <NL> <DEDENT> elif len ( a ) == 3 : <NEWLINE> <INDENT> a , b , d = a <NEWLINE> if c [ a ] == c [ b ] == c [ d ] and a ^ b = c and c ^ b == a and a ^ c == b : <NEWLINE> <INDENT> ans = True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = False <NEWLINE> <NL> <DEDENT> <DEDENT> elif len ( a ) == 2 : <NEWLINE> <INDENT> a , b = sorted ( a ) <NEWLINE> if a == 0 and c [ a ] == N / 3 and c [ b ] == ( N / 3 ) * 2 : <NEWLINE> <INDENT> ans = True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = False <NEWLINE> <NL> <DEDENT> <DEDENT> elif len ( a ) == 1 : <NEWLINE> <INDENT> if sum ( a ) == 0 : <NEWLINE> <INDENT> ans = True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = False <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> if ans else <STRING> ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> from fractions import gcd <NEWLINE> from itertools import combinations , permutations , accumulate , product <COMMENT> <NEWLINE> <COMMENT> <NL> from collections import deque , defaultdict , Counter <NEWLINE> import decimal <NEWLINE> import re <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> import sys <NEWLINE> sys . setrecursionlimit ( 10000000 ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> mod = 998244353 <NEWLINE> def readInts ( ) : <NEWLINE> <INDENT> return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <DEDENT> def I ( ) : <NEWLINE> <INDENT> return int ( input ( ) ) <NEWLINE> <DEDENT> n = I ( ) <NEWLINE> li = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> se = set ( li ) <NEWLINE> if len ( se ) == 1 : <NEWLINE> <INDENT> if sum ( se ) == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> priont ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> elif len ( se ) == 2 : <NEWLINE> <INDENT> a , b = sorted ( se ) <NEWLINE> if a == 0 : <NEWLINE> <INDENT> if li . count ( a ) * 3 == n : <NEWLINE> <INDENT> print ( <STRING> ) <COMMENT> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> elif len ( se ) == 3 : <NEWLINE> <INDENT> a , b , c = se <NEWLINE> if li . count ( a ) == li . count ( b ) == li . count ( c ) : <NEWLINE> <INDENT> if a ^ b == c : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <COMMENT> <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> n = N // 3 <NEWLINE> dic = { } <NEWLINE> <NL> for a in A : <NEWLINE> <INDENT> if a in dic : <NEWLINE> <INDENT> dic [ a ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dic [ a ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> ans = True <NEWLINE> <NL> if len ( dic ) > 3 : <NEWLINE> <INDENT> ans = False <NEWLINE> <NL> <DEDENT> elif len ( dic ) == 3 : <NEWLINE> <INDENT> keys = dic . keys ( ) <NEWLINE> for k in keys : <NEWLINE> <INDENT> if dic [ k ] != n : <NEWLINE> <INDENT> ans = False <NEWLINE> <NL> <DEDENT> <DEDENT> if ( keys [ 0 ] ^ keys [ 1 ] ) != keys [ 2 ] : <NEWLINE> <INDENT> ans = False <NEWLINE> <NL> <DEDENT> <DEDENT> elif len ( dic ) == 2 : <NEWLINE> <INDENT> for k in dic : <NEWLINE> <INDENT> if k == 0 : <NEWLINE> <INDENT> if dic [ k ] != n : <NEWLINE> <INDENT> ans = False <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if dic [ k ] != n * 2 : <NEWLINE> <INDENT> ans = False <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> keys = dic . keys ( ) <NEWLINE> if not 0 in keys : <NEWLINE> <INDENT> ans = False <NEWLINE> <NL> <DEDENT> <DEDENT> if ans : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> u = list ( set ( l ) ) <NEWLINE> if len ( u ) == 1 and u [ 0 ] == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif n % 3 == 0 : <NEWLINE> <INDENT> if len ( u ) == 2 : <NEWLINE> <INDENT> x = l . count ( u [ 0 ] ) <NEWLINE> y = l . count ( u [ 1 ] ) <NEWLINE> if ( x == 2 * n / 3 and y == n / 3 ) or ( y == 2 * n / 3 and x == n / 3 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> elif len ( u ) == 3 : <NEWLINE> <INDENT> x = l . count ( u [ 0 ] ) <NEWLINE> y = l . count ( u [ 1 ] ) <NEWLINE> z = l . count ( u [ 2 ] ) <NEWLINE> if x == n / 3 and y == n / 3 and z == n / 3 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
def get_caps ( a ) : <NEWLINE> <INDENT> dic = dict ( ) <NEWLINE> <NL> for ai in a : <NEWLINE> <INDENT> dic . setdefault ( ai , 0 ) <NEWLINE> dic [ ai ] += 1 <NEWLINE> <NL> <DEDENT> return dic <NEWLINE> <NL> <NL> <DEDENT> def is_match ( caps ) : <NEWLINE> <INDENT> global N <NEWLINE> <NL> if 0 in caps . keys ( ) : <NEWLINE> <INDENT> if caps [ 0 ] == N : <NEWLINE> <INDENT> return True <NEWLINE> <NL> <DEDENT> <DEDENT> if N % 3 == 0 : <NEWLINE> <INDENT> if 0 in caps . keys ( ) and len ( caps ) == 2 : <NEWLINE> <INDENT> if caps [ 0 ] == N // 3 : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> <DEDENT> elif len ( caps ) == 3 : <NEWLINE> <INDENT> x , y , z = caps . keys ( ) <NEWLINE> <NL> if x ^ y ^ z == 0 : <NEWLINE> <INDENT> if caps [ x ] == caps [ y ] == caps [ z ] == N // 3 : <NEWLINE> return True <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> N = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <COMMENT> <NL> caps = get_caps ( a ) <NEWLINE> <NL> if is_match ( caps ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
from collections import Counter <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> c = Counter ( a ) <NEWLINE> s = set ( a ) <NEWLINE> l = len ( s ) <NEWLINE> <NL> if l == 1 and a [ 0 ] == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif len ( a ) % 3 == 0 : <NEWLINE> <INDENT> if l == 2 and c [ 0 ] == n // 3 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif l == 3 : <NEWLINE> <INDENT> if s [ 0 ] ^ s [ 1 ] ^ s [ 2 ] == 0 : <NEWLINE> <INDENT> tmp = c [ a [ 0 ] ] <NEWLINE> if all ( x == tmp for x in c . values ( ) ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n , k , i , v = int ( input ( ) ) , 1 , 2 , n + 1 <NEWLINE> p = print <NEWLINE> while k * 2 < v : k *= 2 <NEWLINE> if - n & k : p ( <STRING> ) ; exit ( ) <NEWLINE> p ( <STRING> , v , 3 ) <NEWLINE> while i < n : p ( 1 , i , i , i + 1 , 1 , v + i , v + i , n + i ) ; i += 2 <NEWLINE> if ~ n & 1 : p ( n , v + k , n + n , n ^ k ) <NEWLINE>
N , A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> t = N * A <NEWLINE> if t > B : <NEWLINE> <INDENT> print ( B ) <NEWLINE> <DEDENT> elif t < B : <NEWLINE> <INDENT> print ( t ) <NEWLINE> <DEDENT> elif t = B : <NEWLINE> <INDENT> print ( B ) <NEWLINE> <DEDENT>
def Input ( ) : <NEWLINE> <INDENT> return mapt ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> n , a , b = Input ( ) <NEWLINE> ans = min ( n * a , b ) <NEWLINE> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> main ( ) <NEWLINE>
list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> print ( min ( list [ 1 ] * N , list [ 2 ] * N ) ) <NEWLINE>
A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> print ( min ( A * N , B ) ) <NEWLINE>
N , A , B = ( int ( x ) for x in input ( ) , split ( ) ) <NEWLINE> print ( min ( N * A , B ) ) <NEWLINE>
inport numpy as np <NEWLINE> <NL> N , A , B = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> costs = A * N , B <NEWLINE> <NL> print ( min ( costs ) ) <NEWLINE>
inp = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if ( inp [ 0 ] * inp [ 1 ] ) <= ip [ 2 ] : <NEWLINE> <INDENT> print ( inp [ 0 ] * inp [ 1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( inp [ 2 ] ) <NEWLINE> <DEDENT>
n , a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> c = n * a <NEWLINE> if c >= b : <NEWLINE> print ( b ) <NEWLINE> else : <NEWLINE> print ( c ) <NEWLINE>
a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if a [ 0 ] * a [ 1 ] <= a [ 2 ] : <NEWLINE> <INDENT> prnit ( a [ 0 ] * a [ 1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( a [ 2 ] ) <NEWLINE> <DEDENT>
A , B , N = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> total_price = A + ( N * B ) <NEWLINE> <NL> print ( total_price - max ( total_price ) ) <NEWLINE>
n , a , b = map ( int , input . split ( ) ) <NEWLINE> <NL> print ( min ( n * a , b ) ) <NEWLINE>
n , a , b = map ( int , input ( ) . split ( ) <NEWLINE> if n * a >= b : <NEWLINE> <INDENT> print ( b ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( n * a ) <NEWLINE> <DEDENT>
S_list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> n , a , b = S_list <NEWLINE> print ( min ( n * a , b ) <NEWLINE>
a , b , c = list ( map ( intl , input ( ) . split ( ) ) ) <NEWLINE> if a * b >= c : <NEWLINE> <INDENT> print ( c ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( a * b ) <NEWLINE> <DEDENT>
n , d = map ( int , readline ( ) . rstrip ( ) . split ( ) ) <NEWLINE> m = [ ] <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> arr = list ( map ( int , readline ( ) . rstrip ( ) . split ( ) ) ) <NEWLINE> m . append ( arr ) <NEWLINE> <DEDENT> ans = 0 <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n ) : <NEWLINE> <INDENT> a = 0 <NEWLINE> for k in range ( d ) : <NEWLINE> <INDENT> a += ( m [ i ] [ k ] - m [ j ] [ k ] ) ** 2 <NEWLINE> <DEDENT> x = int ( a ** ( 1 / 2 ) ) <NEWLINE> if x * 2 == a : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL>
n , d = map ( int , input ( ) . split ( ) ) <NEWLINE> lst = [ ] <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> x = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <DEDENT> ans = 0 <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n ) : <NEWLINE> <INDENT> dist = 0 <NEWLINE> for k in range ( d ) : <NEWLINE> <INDENT> dist += ( lst [ i ] [ k ] - lst [ j ] [ k ] ) ** 2 <NEWLINE> <DEDENT> j = 1 <NEWLINE> while j ** 2 <= dist : <NEWLINE> <INDENT> if j ** 2 == dist : <NEWLINE> <INDENT> ans += 1 <NEWLINE> break <NEWLINE> <DEDENT> j += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from math import sqrt <NEWLINE> n , d = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> vs = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> v = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> vs . append ( vs ) <NEWLINE> <NL> <DEDENT> def ds ( a , b ) : <NEWLINE> <INDENT> s = 0 <NEWLINE> for i in range ( d ) : <NEWLINE> <INDENT> s += ( b [ i ] - a [ i ] ) ** 2 <NEWLINE> <DEDENT> return sqrt ( s ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n ) : <NEWLINE> <INDENT> d = ds ( vs [ i ] , vs [ j ] ) <NEWLINE> if d == int ( d ) : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> def input2 ( ) : <NEWLINE> <INDENT> return map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> def input_array ( ) : <NEWLINE> <INDENT> return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <DEDENT> def euclid ( y , z , d ) : <NEWLINE> <INDENT> result = 0 <NEWLINE> for i in range ( d ) : <NEWLINE> <INDENT> result += ( y [ i ] - z [ i ] ) ** 2 <NEWLINE> <DEDENT> return math . sqrt ( result ) <NEWLINE> <NL> <NL> <DEDENT> n , d = input2 ( ) <NEWLINE> X = [ input_array ( ) for _ in range ( n ) ] <NEWLINE> <NL> count = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n ) : <NEWLINE> <INDENT> distance = euclid ( X [ i ] , X [ j ] , d ) <NEWLINE> if ( distance % 1 ) == 0 : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
N , D = [ int ( n ) for n in input ( ) . split ( ) ] <NEWLINE> X = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> X . append ( [ int ( m ) for m in input ( ) . split ( ) ] ) <NEWLINE> <NL> <DEDENT> def get_distance ( p1 , p2 ) : <NEWLINE> <INDENT> d2 = 0 <NEWLINE> for i in range ( D ) : <NEWLINE> <INDENT> d2 += ( p1 [ i ] - p2 [ i ] ) ** 2 <NEWLINE> <DEDENT> return math . sqrt ( d2 ) <NEWLINE> <NL> <DEDENT> count = 0 <NEWLINE> for i , j in itertools . combinations ( range ( N ) , 2 ) : <NEWLINE> <INDENT> if get_distance ( X [ i ] , X [ j ] ) . is_integer ( ) : <NEWLINE> <INDENT> count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
import math <NEWLINE> n , d = map ( int , input ( ) . split ( ) ) <NEWLINE> x = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ] <NEWLINE> cnt = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n ) : <NEWLINE> <INDENT> sum = 0 <NEWLINE> for k in range ( n ) : <NEWLINE> <INDENT> sum += ( x [ i ] [ k ] - x [ j ] [ k ] ) ** 2 <NEWLINE> <DEDENT> z = pow ( sum , 0.5 ) <NEWLINE> if math . ceil ( z ) == math . floor ( z ) : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
import math <NEWLINE> <NL> def gooddistance ( l1 , l2 ) : <NEWLINE> <INDENT> calc = [ ] <NEWLINE> <NL> for i in range ( len ( l1 ) ) : <NEWLINE> <INDENT> calc . append ( ( l1 [ i ] - l2 [ i ] ) ** 2 ) <NEWLINE> <NL> <DEDENT> if math . sqrt ( sum ( calc ) ) . is_integer ( ) : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return 0 <NEWLINE> <NL> n , d = map ( int , input ( ) . split ( ) ) <NEWLINE> <DEDENT> <DEDENT> lst = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ] <NEWLINE> count = 0 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n ) : <NEWLINE> <INDENT> count += gooddistance ( lst [ i ] , lst [ j ] ) <NEWLINE> <NL> print ( count ) <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> import numpy as np <NEWLINE> rm = lambda : map ( int , sys . stdin . readline ( ) . split ( ) ) <NEWLINE> rl = lambda : list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) <NEWLINE> <NL> cnt = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( i ) : <NEWLINE> <INDENT> a = sum ( ( li [ i ] - li [ j ] ) ** 2 ) ** 0.5 <NEWLINE> if a - a // 1 == 0 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
import math <NEWLINE> <NL> n , d = map ( int , input ( ) . split ( ) ) <NEWLINE> x = [ list ( int , input ( ) . split ( ) ) for i in range ( n ) ] <NEWLINE> cnt = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n ) : <NEWLINE> <INDENT> for k in range ( d ) : <NEWLINE> <INDENT> dis = 0 <NEWLINE> dis += ( x [ i ] [ k ] - x [ j ] [ k ] ) ** 2 <NEWLINE> if math . sqrt ( dis ) % 1 == 0 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
n , d = map ( int , input ( ) . split ( ) ) <NEWLINE> x_l = [ list ( map ( int , input ( ) . split ) ) for _ in range ( n ) ] <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n ) : <NEWLINE> <INDENT> tmp = 0 <NEWLINE> for k in range ( d ) : <NEWLINE> <INDENT> tmp += ( x_l [ j ] [ k ] - x_l [ i ] [ k ] ) ** 2 <NEWLINE> <DEDENT> if tmp ** 0.5 % 1 == 0 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> N , D = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ ] <NEWLINE> ans = 0 <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> tmp = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a . append ( tmp ) <NEWLINE> <DEDENT> for n in range ( N ) : <NEWLINE> <INDENT> for m in range ( n + 1 , N ) : <NEWLINE> dis = 0 <NEWLINE> <INDENT> for d in range ( D ) : <NEWLINE> <INDENT> dis += ( a [ n ] [ d ] - a [ m ] [ d ] ) ** 2 <NEWLINE> <DEDENT> if math . sqrt ( dis ) == int ( math . sqrt ( dis ) ) : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> <NL> N , D = map ( int , input ( ) . split ( ) ) <NEWLINE> X = [ ] <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> X . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <DEDENT> count = 0 <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , N ) : <NEWLINE> <INDENT> a = 0 <NEWLINE> for k in range ( D ) : <NEWLINE> <INDENT> a += ( X [ i ] [ k ] - X [ j ] [ k ] ) ** 2 <NEWLINE> <DEDENT> if math . sqrt ( a ) . is_integer ( ) : <NEWLINE> <INDENT> coutn += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
import math <NEWLINE> <NL> N , D = map ( int , input ( ) . split ( ) ) <NEWLINE> X = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( N ) ) ] <NEWLINE> cnt = 0 <NEWLINE> <NL> for i in range ( N - 1 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , N ) : <NEWLINE> tmp = 0 <NEWLINE> for k in range ( D ) : <NEWLINE> <INDENT> tmp += ( ( X [ i ] [ k ] - X [ j ] [ k ] ) ** 2 ) <NEWLINE> <DEDENT> tmp = math . sqrt ( tmp ) <NEWLINE> if tmp . is_integer : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
n , d = map ( int , input ( ) . split ( ) ) <NEWLINE> l = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> l . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <DEDENT> count = 0 <NEWLINE> import math <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( n ) : <NEWLINE> <INDENT> sum = 0 <NEWLINE> for i in range ( d ) : <NEWLINE> <INDENT> sum += ( l [ i ] [ d ] - l [ i ] [ d ] ) ** 2 <NEWLINE> <DEDENT> dis = sqrt ( sum ) <NEWLINE> if dis % 1 == 0 : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
import sys <NEWLINE> import itertoolsy <NEWLINE> N , D = map ( int , input ( ) . split ( ) ) <NEWLINE> array = [ list ( map ( int , input ( ) . split ( ) ) ) for x in range ( N ) ] <NEWLINE> <NL> if not ( 2 <= N <= 10 and 1 <= D <= 10 ) : sys . exit ( ) <NEWLINE> for I in array : <NEWLINE> <INDENT> if not ( - 20 <= min ( I ) and max ( I ) <= 20 ) : sys . exit ( ) <NEWLINE> <NL> <DEDENT> count = 0 <NEWLINE> for I in list ( itertools . combinations ( array , 2 ) ) : <NEWLINE> <INDENT> tmp_distance = 0 <NEWLINE> for J in range ( D ) : <NEWLINE> <INDENT> tmp_distance += abs ( I [ 0 ] [ J ] - I [ 1 ] [ J ] ) ** 2 <NEWLINE> <DEDENT> distance = tmp_distance ** 0.5 <NEWLINE> if distance . is_integer ( ) : count += 1 <NEWLINE> <NL> <DEDENT> print ( count ) <NEWLINE>
n , d = map ( int , input ( ) . split ( ) ) <NEWLINE> l = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( N ) ] <NEWLINE> a = 0 <NEWLINE> ans += 1 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n ) : <NEWLINE> <INDENT> for k in range ( d ) : <NEWLINE> <INDENT> a += l [ i ] [ k ] ** 2 - l [ j ] [ k ] ** 2 <NEWLINE> a **= 0.5 <NEWLINE> if a . is_integer : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N , D = map ( int , input ( ) . split ( ) ) <NEWLINE> import numpy as np <NEWLINE> xlist = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( n ) ] <NEWLINE> xarray = np . array ( xlist ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n ) : <NEWLINE> <INDENT> if np . linalg . norm ( xarray [ i ] - xarray [ j ] ) == int ( np . linalg . norm ( xarray [ i ] - xarray [ j ] ) ) : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N , D = ( int ( x ) for x in input ( ) . split ( ) ) <NEWLINE> X = [ ] * N <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> X [ i ] = [ float ( x ) for x in input ( ) . split ( ) ] <NEWLINE> <DEDENT> count = 0 <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , N ) : <NEWLINE> <INDENT> sq = [ ( X [ i ] [ k ] - X [ j ] [ k ] ) ** 2 for k in range ( D ) ] <NEWLINE> if isinstance ( sum ( sq ) ** 0.5 , int ) : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
n , d = map ( int , input ( ) . split ( ) ) <NEWLINE> x = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( n ) ] <NEWLINE> cnt = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n ) : <NEWLINE> <INDENT> a = x [ i ] <NEWLINE> b = x [ j ] <NEWLINE> z = 0 <NEWLINE> for k in range ( d ) : <NEWLINE> <INDENT> z += ( a [ k ] - b [ k ] ) ** 2 <NEWLINE> <DEDENT> if math . sqrt ( z ) % 1 == 0 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <NL> import math <NEWLINE> <NL> def dis ( Y , Z ) : <NEWLINE> <INDENT> ans = 0 <NEWLINE> for i in range ( len ( Y ) ) : <NEWLINE> <INDENT> ans += ( Y [ i ] - Z [ i ] ) ** 2 <NEWLINE> <DEDENT> return math . sqrt ( ans ) <NEWLINE> <NL> <NL> <DEDENT> N , D = map ( int , input ( ( ) . split ( ) ) ) <NEWLINE> X = [ ] <NEWLINE> ans = 0 <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> X . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> for j in range ( i , N ) : <NEWLINE> <INDENT> if dis ( i , j ) % 1 == 0 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
L , R = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if R - L >= 2019 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = 2019 <NEWLINE> for i in range ( L , R - 1 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , R ) : <NEWLINE> ans = min ( ans , ( i * j ) % 2019 ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> if r - l >= 2019 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = 2019 <NEWLINE> for i in raneg ( l , r ) : <NEWLINE> <INDENT> for j in range ( i + 1 , r + 1 ) : <NEWLINE> <INDENT> ans = min ( ans , i * j % 2019 ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> rem_l = l % 2019 <NEWLINE> rem_r = r % 2019 <NEWLINE> <NL> ans = - 1 <NEWLINE> <NL> if r - l >= 2019 : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <NL> <DEDENT> elif rem_l >= rem_r : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> ans = float ( <STRING> ) <NEWLINE> for i in range ( l , r ) : <NEWLINE> <INDENT> for j in raneg ( i , r ) : <NEWLINE> <INDENT> temp = ( i * j ) % 2019 <NEWLINE> if temp < ans : <NEWLINE> <INDENT> ans = temp <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
L , R = map ( int , input ( ) . split ( ) ) <NEWLINE> R = min ( R , L + 2019 ) <NEWLINE> print ( min ( [ i * j % 2019 for i in range ( L , R + 1 ) for jj in range ( i + 1 , R + 1 ) ] ) ) <NEWLINE>
L . R = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = float ( <STRING> ) <NEWLINE> for i in range ( L , R + 1 ) : <NEWLINE> <INDENT> for j in range ( L , R + 1 ) : <NEWLINE> <INDENT> s = ( i * j ) % 2019 <NEWLINE> if s == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = min ( s , ans ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> import sys <NEWLINE> mod = 2019 <NEWLINE> ans = float ( <STRING> ) <NEWLINE> <NL> for i in range ( l , r + 1 ) : <NEWLINE> <INDENT> for j in range ( j + 1 , r + 1 ) : <NEWLINE> <INDENT> ans = min ( ( i * j ) % mod , ans ) <NEWLINE> if ans == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if r // 673 > ( l - 1 ) // 673 and r - l = 2 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> print ( ( l % 2019 ) * ( ( l + 1 ) % 2019 ) ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> L , R = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ ] <NEWLINE> if R - L > 2019 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> elif 2 <= R - L and R - L <= 2019 : <NEWLINE> <INDENT> for i in range ( L , R ) : <NEWLINE> <INDENT> for j in range ( i + 1 , R + 1 ) : <NEWLINE> <INDENT> A . append ( ( i * j ) % 2019 ) <NEWLINE> <DEDENT> <DEDENT> print ( min ( A ) ) <NEWLINE> <DEDENT> elif R - L = 1 : <NEWLINE> <INDENT> print ( ( R * L ) % 2019 ) <NEWLINE> <DEDENT>
l . r = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> mod = 2019 <NEWLINE> a = l % 2019 <NEWLINE> b = l % 2019 <NEWLINE> <NL> if r - l >= 2018 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> if a < b : <NEWLINE> <INDENT> print ( a * a + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> <DEDENT>
from collections import Counter <NEWLINE> inp = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> l = inp [ 0 ] <NEWLINE> r = inp [ 1 ] <NEWLINE> c = Counter ( [ ] ) <NEWLINE> arr = [ ] <NEWLINE> for i in range ( l , r + 1 ) : <NEWLINE> <INDENT> if c [ i ] == 0 : <NEWLINE> <INDENT> c [ i ] += 1 <NEWLINE> arr . append ( i ) <NEWLINE> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> if c [ 0 ] != 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> ans = 99999999999 <NEWLINE> for i in range ( len ( arr ) ) : <NEWLINE> <INDENT> for j in range ( i + 1 , len ( arr ) ) : <NEWLINE> <INDENT> ans = min ( ans , ( i * j ) % 2019 ) <NEWLINE> if ans == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> if ans == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
L , R = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ ] <NEWLINE> <NL> if R - L >= 2019 : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> l , r = L % 2019 , R % 2019 <NEWLINE> for i in range ( l , r ) : <NEWLINE> <INDENT> for j in range ( l + 1 , r + 1 ) : <NEWLINE> <INDENT> k = ( i * j ) % 2019 <NEWLINE> ans = min ( ans , k ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> m , ans = 2019 , 2018 <NEWLINE> r = min ( r , l + 2019 * 2 ) <NEWLINE> for i in range ( l , r + 1 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , r + 1 ) : <NEWLINE> <INDENT> i %= m <NEWLINE> j %= m <NEWLINE> ans = min ( ans , ( i * j ) % m ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> if s [ 0 ] == s [ 4 ] and s [ 1 ] == s [ 2 ] and s [ 2 ] != s [ 3 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> main ( ) <NEWLINE>
print ( <STRING> if len ( set ( input ( ) ) ) == 2 and S . count ( S [ 0 ] ) == 2 else <STRING> ) <NEWLINE>
s = input ( ) <NEWLINE> for i in s : <NEWLINE> <INDENT> if s . counter ( i ) != 2 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
from collections import Counter as C <NEWLINE> <NL> S = input ( ) <NEWLINE> <NL> c = C ( S ) <NEWLINE> if len ( c . keys ( ) ) == 2 : <NEWLINE> <INDENT> if c . values [ 0 ] == 2 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> t = set ( s ) <NEWLINE> if len ( t ) == 2 and s . count ( list ( t [ 0 ] ) ) == 2 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> print ( <STRING> if ( sorted ( s [ : 2 ] ) == sorted ( s [ 2 : ] ) and len ( sorted ( s [ : 2 ) ) == 2 ) else <STRING> ) <NEWLINE>
<COMMENT> <NL> <NL> S = str ( input ( ) ) <NEWLINE> T = [ S [ 0 ] , S [ 1 ] , S [ 2 ] , S [ 3 ] ] <NEWLINE> T . sort ( ) <NEWLINE> if T [ 0 ] == T [ 1 ] and T [ 2 ] == T [ 3 ] and T [ 1 ] != T [ 2 ] <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> if ( ( s [ 0 ] == s [ 1 ] and s [ 2 ] == s [ 3 ] and s [ 0 ] != s [ 2 ] ) or ( s [ 0 ] == s [ 2 ] and s [ 1 ] == s [ 3 ] and s [ 0 ] != s [ 1 ] ) <NEWLINE> <INDENT> and ( s [ 0 ] == = s [ 3 ] and s [ 1 ] == s [ 2 ] and s [ 0 ] != s [ 1 ] ) ) : <NEWLINE> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> d = { } <NEWLINE> for i in range ( 4 ) : <NEWLINE> <INDENT> t = s [ i : i + 1 ] <NEWLINE> try : <NEWLINE> <INDENT> d [ t ] += 1 <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> d [ t ] = 1 <NEWLINE> <DEDENT> <DEDENT> if ( len ( d ) == 2 ) : <NEWLINE> <INDENT> frag = True <NEWLINE> for i in range ( 2 ) : <NEWLINE> <INDENT> if ( d [ i ] != 2 ) : <NEWLINE> <INDENT> frag = False <NEWLINE> <DEDENT> <DEDENT> if ( frag ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
from collections import defaultdict <NEWLINE> S = input ( ) <NEWLINE> t = defaultdict ( int ) <NEWLINE> for i in s : <NEWLINE> <INDENT> t [ i ] += 1 <NEWLINE> <DEDENT> if len ( t . keys ( ) ) == 2 : <NEWLINE> <INDENT> for i in t . values ( ) : <NEWLINE> <INDENT> if i != 2 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s = list ( input ( ) ) <NEWLINE> a = len ( set ( s ) <NEWLINE> if a == 2 : <NEWLINE> <INDENT> b = len ( [ t for t in s if t == s [ 0 ] ] ) <NEWLINE> if b == 2 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> else : <NEWLINE> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a = input ( ) <NEWLINE> a . sort ( ) <NEWLINE> if a [ 0 ] == a [ 1 ] and a [ 2 ] == a [ 3 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> s1 = set ( input ( ) ) <NEWLINE> if len ( s1 ) == 2 : <NEWLINE> <INDENT> if s . count ( list ( s1 ) [ 0 ] ) == 2 and s . count ( list ( s1 ) [ 1 ] ) == 2 : print ( <STRING> ) <NEWLINE> else : print ( <STRING> ) <NEWLINE> <DEDENT> else : print ( <STRING> ) <NEWLINE>
from collections import defaultdict <NEWLINE> s = str ( input ( ) ) <NEWLINE> d = defaultdict ( int ) <NEWLINE> for x in s : <NEWLINE> <INDENT> d [ x ] += 1 <NEWLINE> <DEDENT> if len ( d ) == 2 : <NEWLINE> <INDENT> for key , value in d : <NEWLINE> <INDENT> if value != 2 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT>
s = input ( ) <NEWLINE> if s [ 0 ] == s [ 1 ] == s [ 2 ] == s [ 3 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if s [ 0 ] == s [ 1 ] : <NEWLINE> <INDENT> if s [ 2 ] == s [ 3 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> elif s [ 0 ] == s [ 2 ] : <NEWLINE> <DEDENT> if s [ 1 ] == s [ 3 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> elif s [ 0 ] == s [ 3 ] : <NEWLINE> <DEDENT> if s [ 1 ] == s [ 2 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
<NL> def main ( ) : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> s_ = list ( set ( s ) ) <NEWLINE> if s . count ( s_ [ 0 ] ) == 2 and len ( s_ ) == 2 i : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
S = input ( ) <NEWLINE> S . sort ( ) <NEWLINE> if S [ 0 ] == S [ 1 ] and S [ 2 ] == S [ 3 ] and S [ 1 ] != S [ 2 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
S = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> print ( <STRING> if X [ 0 ] == X [ 1 ] and X [ 2 ] == X [ 3 ] else <STRING> ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> n = int ( input ( ) ) <NEWLINE> p = list ( map ( int , input ( ) ) ) <NEWLINE> <NL> answer = 0 <NEWLINE> for i in range ( 1 , n - 1 ) : <NEWLINE> <INDENT> if p [ i - 1 ] < p [ i ] < p [ 1 + 1 ] or p [ i - 1 ] > p [ i ] > p [ i + 1 ] : <NEWLINE> <INDENT> answer += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( answer ) <NEWLINE> <NL>
n = int ( input ( ) ) <NEWLINE> p = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> for i in range ( 1 , n - 1 ) : <NEWLINE> <INDENT> if p [ i - 1 ] < p [ i ] < p [ i + 1 ] or p [ i + 1 ] < p [ i ] < p [ i - 1 ] : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> arr = [ map ( int , input ( ) . split ( ) ) ] <NEWLINE> print ( sum ( [ 1 for i in range ( len ( arr ) ) if ( ( ( arr [ i ] < arr [ i + 1 ] ) and ( arr [ i ] > arr [ i - 1 ] ) ) or ( ( arr [ i ] > arr [ i + 1 ] ) and ( arr [ i ] < arr [ i - 1 ] ) ) ) ] ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = [ int ( k ) for k in input ( ) . split ( ) ] <NEWLINE> cnt = 0 <NEWLINE> for i in range ( n - 3 ) : <NEWLINE> <INDENT> if a [ i ] < a [ i + 1 ] and a [ i + 1 ] < a [ i + 2 ] : cnt + = 1 <NEWLINE> <DEDENT> print ( cnt ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> p = map ( int , input ( ) . split ( ) ) <NEWLINE> count = 0 <NEWLINE> for i in range ( 0 , n - 2 ) : <NEWLINE> <INDENT> if ( p [ i ] < p [ i + 1 ] and p [ i + 1 ] < p [ i + 2 ] ) or ( p [ i ] > p [ i + 1 ] and p [ i + 1 ] > p [ i + 2 ] ) : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> P = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> for i in range ( N - 2 ) : <NEWLINE> <INDENT> if P [ i ] > P [ i + 1 ] and P [ i + 1 ] > P [ i + 2 ] or P [ i ] < P [ i + 1 ] and P [ i + 1 ] < P [ i + 2 ] or : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( 1 , n - 1 ) : <NEWLINE> <INDENT> if p [ i ] >= p [ i - 1 ] and p [ i ] = < p [ i + 1 ] : ans += 1 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> cnt = 0 <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> if ( p [ i ] - p [ i - 1 ] > 0 and p [ i + 1 ] - p [ i ] >= 0 ) or ( p [ i ] - p [ i - 1 ] <= 0 and p [ i + 1 ] - p [ i ] < 0 ) : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
n , a * = map ( int , open ( 0 ) . read ( ) . split ( ) ) <NEWLINE> t = 0 <NEWLINE> for i in range ( 1 , n - 1 ) : <NEWLINE> <INDENT> if sorted ( a [ i - 1 : i + 2 ] ) . index ( a [ i ] ) == 1 : <NEWLINE> <INDENT> t += 1 <NEWLINE> <DEDENT> <DEDENT> print ( t ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in range ( 1 , n - 1 ) : <NEWLINE> <INDENT> if p [ i - 1 ] < p [ i ] and p [ i ] < p [ i + 1 ] : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> elif p [ i + 1 ] < p [ i ] and p [ i ] < p [ i - 1 ] : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
<COMMENT> <NL> <NL> n = int ( input ( ) ) <NEWLINE> K = 0 <NEWLINE> for i in range ( n - 2 ) : <NEWLINE> <INDENT> if ( P [ i ] < P [ i + 1 ] and P [ i + 1 ] < P [ i + 2 ] ) or ( P [ i + 2 ] < P [ i + 1 ] and P [ i + 1 ] < P [ i ] ) : <NEWLINE> <INDENT> K += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( K ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 0 , n ) : <NEWLINE> <INDENT> if ( p [ i - 1 ] < p [ i ] < p [ i + 1 ] ) or ( p [ i - 1 ] > p [ i ] > p [ i + 1 ] ) : <NEWLINE> <INDENT> ans = ans + 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> P = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> print ( L [ N // 2 ] - L [ N // 2 - 1 ] ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> l = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> l . sort ( ) <NEWLINE> print ( max ( 0 , l [ int ( N / 2 ) ] - l [ int ( N / 2 ) - 1 ] ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> l . sort ( ) <NEWLINE> a = n / 2 <NEWLINE> s = l . index ( a - 1 ) <NEWLINE> t = l . index ( a ) <NEWLINE> if s == t : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = t - s <NEWLINE> print ( ans ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> arr = list ( map ( int , input ( ) . rstrip ( ) . split ( ) ) ) <NEWLINE> arr . sort ( ) <NEWLINE> <NL> if arr [ n // 2 - 1 ] == arr [ n // 2 ] : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> return <NEWLINE> <DEDENT> print ( arr [ n // 2 ] - arr [ n // 2 - 1 ] ) <NEWLINE>
N = int ( input ( ) . split ( ) ) <NEWLINE> d = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> d . sort ( ) <NEWLINE> result = d [ int ( N / 2 ) ] - d [ int ( ( N - 1 ) / 2 ) ] <NEWLINE> print ( result ) <NEWLINE>
n = input ( ) <NEWLINE> dl = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> dl . sort ( ) <NEWLINE> <NL> if n % 2 != 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <NL> <DEDENT> left = dl [ ( n // 2 ) - 1 ] <NEWLINE> right = dl [ ( n // 2 ) ] <NEWLINE> <NL> print ( right - left ) <NEWLINE>
14 <NEWLINE> 99592 10342 29105 78532 83018 11639 92015 77204 30914 21912 34519 80835 100000 1 <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( int , input ( ) . split ( ) ) <NEWLINE> A . sort ( ) <NEWLINE> l = A [ N // 2 - 1 ] <NEWLINE> h = A [ N // 2 ] <NEWLINE> print ( h - l ) <NEWLINE>
99592 10342 29105 78532 83018 11639 92015 77204 30914 21912 34519 80835 100000 1 <NEWLINE>
N = int ( input ( ) ) <NEWLINE> d = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> d = sorted ( d ) <NEWLINE> ans = 0 <NEWLINE> <NL> for i in range ( 10 ** 7 ) : <NEWLINE> <INDENT> if d [ int ( N / 2 - 1 ) ] < i and i <= d [ int ( N / 2 ) ] : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> d = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> d . sorted ( ) <NEWLINE> print ( d [ n / 2 ] - d [ n / 2 - 1 ] ) <NEWLINE>
a = int ( input ( ) ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b . sort ( ) <NEWLINE> if b [ ( a / 2 ) - 1 ] == b [ ( a / 2 ) ] : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( b [ ( a / 2 ) ] - b [ ( a / 2 ) - 1 ] - 1 ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> d = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> ans = 0 <NEWLINE> if d [ N / 2 ] != d [ N / 2 - 1 ] : <NEWLINE> <INDENT> ans = d [ N / 2 ] - d [ N / 2 - 1 ] <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
from scipy . misc import comb <NEWLINE> <NL> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> for i in range ( k ) : <NEWLINE> <INDENT> print ( int ( comb ( n - k + 1 , i + 1 ) * comb ( k - 1 , i ) % MOD ) ) <NEWLINE> <DEDENT>
import math <NEWLINE> a , b , c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <COMMENT> <NL> ans = ( b // c + b // d - b // ( c * d // math . gcd ( c , d ) ) ) - ( ( a - 1 ) // c + ( a - 1 ) // d - ( a - 1 ) // ( c * d // math . gcd ( c , d ) ) ) <NEWLINE> <NL> print ( b - a + 1 - ans ) <NEWLINE>
def split ( word ) : <NEWLINE> <INDENT> return [ char for char in word ] <NEWLINE> <DEDENT> inp = input ( ) <NEWLINE> list = split ( inp ) <NEWLINE> count = 0 <NEWLINE> x = 1 <NEWLINE> str = <STRING> <NEWLINE> for i in range ( len ( 3 ) : <NEWLINE> <INDENT> if list [ count ] == list [ count + 1 ] : <NEWLINE> <INDENT> str = <STRING> <NEWLINE> <DEDENT> count = count + 1 <NEWLINE> <DEDENT> print ( str ) <NEWLINE>
from itertools import groupby <NEWLINE> import sys <NEWLINE> rr = lambda : sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> s = rr ( ) <NEWLINE> print ( <STRING> if len ( groupby ( s ) ) == 4 else <STRING> ) <NEWLINE> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL>
arr = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for k in range ( len ( arr ) ) : <NEWLINE> <INDENT> if arr [ k ] == arr [ k + 1 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
S = input ( ) <NEWLINE> <NL> answer = <STRING> <NEWLINE> prev_s = s [ 0 ] <NEWLINE> for s in S [ 1 : ] : <NEWLINE> <INDENT> if prev_s == s : <NEWLINE> <INDENT> answer = <STRING> <NEWLINE> break <NEWLINE> <DEDENT> prev_s = s <NEWLINE> <NL> <DEDENT> print ( answer ) <NEWLINE>
s = int ( input ( ) ) <NEWLINE> ans = <STRING> <NEWLINE> for i in range ( 3 ) : <NEWLINE> <INDENT> if s [ i ] == s [ i + 1 ] : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
a = list ( input ( ) ) <NEWLINE> count = 0 <NEWLINE> for i in range ( 4 ) : <NEWLINE> <INDENT> if a [ i ] == a [ i + 1 ] and i == 2 : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
str = input ( ) <NEWLINE> <NL> flag = False <NEWLINE> for i in range ( len ( str ) ) - 1 : <NEWLINE> <INDENT> if str [ i ] == str [ i + 1 ] : <NEWLINE> <INDENT> flag = True <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> ) if flag else print ( <STRING> ) <NEWLINE>
num = input ( ) <NEWLINE> c = False <NEWLINE> for i in range ( 1 , len ( num ) + 1 ) : <NEWLINE> <INDENT> if num [ i ] == num [ i - 1 ] : <NEWLINE> <INDENT> c = True <NEWLINE> <NL> <DEDENT> <DEDENT> if c == True : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s = str ( input ( ) ) <NEWLINE> if s [ 0 ] == s [ 1 ] or s [ 1 ] == s [ 2 ] or s [ 2 ] == s [ 3 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <INDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
s = list ( int ( input ( ) ) ) <NEWLINE> f = True <NEWLINE> for i in range ( 1 , 4 ) : <NEWLINE> <INDENT> if s [ i - 1 ] == s [ i ] : <NEWLINE> <INDENT> f = False <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> <DEDENT> if f : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> flag = False <NEWLINE> for i in range ( 3 ) : <NEWLINE> <INDENT> if List [ i ] == List [ i + 1 ] : <NEWLINE> <INDENT> flag = True <NEWLINE> <DEDENT> <DEDENT> if flag : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a = int ( input ( ) ) <NEWLINE> print ( <STRING> if a [ 0 ] == a [ 1 ] or a [ 1 ] == a [ 2 ] or a [ 2 ] == a [ 3 ] else <STRING> ) <NEWLINE>
s = list ( input ( ) ) <NEWLINE> for i in range ( 3 ) : <NEWLINE> <INDENT> if ( s [ i ] == s [ i + 1 ] ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import math <NEWLINE> <NL> A , B , C , D = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> <NL> num_C_baisu = B // C - ( A - 1 ) // C <COMMENT> <NEWLINE> <NL> num_D_baisu = B // D - ( A - 1 ) // D <COMMENT> <NEWLINE> <NL> CD = int ( C * D / math . gcd ( C , D ) ) <NEWLINE> <NL> num_CD_baisu = B // CD - ( A - 1 ) // CD <COMMENT> <NEWLINE> <NL> baisu_num = num_C_baisu + num_D_baisu - num_CD_baisu <NEWLINE> <NL> print ( B - A + 1 - baisu_num ) <NEWLINE>
s = int ( input ( ) ) <NEWLINE> <NL> for i in range ( 3 ) : <NEWLINE> <INDENT> if s [ i ] == s [ i + 1 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> print ( <STRING> if len ( s ) = len ( set ( s ) ) else <STRING> ) <NEWLINE>
a = range ( 1 , 8 + 1 ) <NEWLINE> <INDENT> b = range ( 1 , 8 + 1 ) <NEWLINE> c = range ( 1 , 8 + 1 ) <NEWLINE> d = range ( 1 , 8 + 1 ) <NEWLINE> <NL> if a == b or b == c or c == d : <NEWLINE> <INDENT> return ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
pass = input ( ) <NEWLINE> if pass [ 0 ] == pass [ 1 ] or pass [ 1 ] == pass [ 2 ] or pass [ 2 ] == pass [ 3 ] : print ( <STRING> ) <NEWLINE> else : print ( <STRING> ) <NEWLINE>
S = input ( ) <NEWLINE> p = a <NEWLINE> for s in S : <NEWLINE> <INDENT> if p == s : <NEWLINE> <INDENT> p = a <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> p = s <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> if p == a else <STRING> ) <NEWLINE>
s = input ( ) <NEWLINE> l = len ( s ) <NEWLINE> ans = 0 <NEWLINE> <NL> for i in range ( l ) : <NEWLINE> <INDENT> for k in range ( i , k ) : <NEWLINE> <INDENT> if s [ i ] == s [ k ] : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if ans == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> if ans != 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
S = input ( ) <NEWLINE> flag = False <NEWLINE> for s in S : <NEWLINE> <INDENT> if flag : <NEWLINE> <INDENT> if temp = s : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> quit ( ) <NEWLINE> <DEDENT> <DEDENT> temp = s <NEWLINE> flag = True <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE>
s = int ( input ( ) ) <NEWLINE> ans = <STRING> <NEWLINE> for i in range ( 10 ) : <NEWLINE> <INDENT> k = str ( i ) + str ( i ) <NEWLINE> if ( k in s ) : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> total = a * ( a + 2 * b - 1 ) // 2 <NEWLINE> x = b <NEWLINE> y = a + b - 1 <NEWLINE> if ( abs ( x ) < abs ( y ) : <NEWLINE> <INDENT> z = x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> z = y <NEWLINE> <DEDENT> if x <= 0 and y >= 0 : <NEWLINE> <INDENT> print ( total ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( total - z ) <NEWLINE> <DEDENT>
n . l = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <COMMENT> <NL> <NL> min_abs = 99999999999 <NEWLINE> min_abs_i = - 1 <NEWLINE> n_aji = 0 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> aji = l + i - 1 <NEWLINE> aji_abs = abs ( aji ) <NEWLINE> if aji_abs < min_abs : <NEWLINE> <INDENT> min_abs = aji_abs <NEWLINE> aji_abs_i = i <NEWLINE> <DEDENT> n_aji += aji <NEWLINE> <NL> <DEDENT> print ( n_aji - ( l + aji_abs_i - 1 ) ) <NEWLINE>
N , L = map ( int , input ( ) . split ( ) ) <NEWLINE> li = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> li . append ( L + i + 1 - 1 ) <NEWLINE> <DEDENT> A = True <NEWLINE> li . sort ( ) <NEWLINE> for j in range ( N - 1 ) : <NEWLINE> <INDENT> if abs ( li [ j ] ) <= abs ( li [ j + 1 ] ) : <NEWLINE> <INDENT> S -= li [ j ] <NEWLINE> A = False <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if A == True : <NEWLINE> <INDENT> S -= li [ N - 1 ] <NEWLINE> <NL> <DEDENT> print ( S ) <NEWLINE>
N , L = map ( int , input ( ) ) <NEWLINE> A = list ( ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> A . append ( L + i ) <NEWLINE> <DEDENT> A . sort ( ) <NEWLINE> S = sum ( A ) <NEWLINE> if min ( A ) * max ( A ) <= 0 : <NEWLINE> <INDENT> print ( S ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if L >= 0 : <NEWLINE> <INDENT> print ( S - min ( A ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( S - max ( A ) ) <NEWLINE> <DEDENT> <DEDENT>
N , L = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> A . append ( L + i ) <NEWLINE> <DEDENT> i = 0 <NEWLINE> for k in A : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> x = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x , y = abs ( i ) , - abs ( i ) <NEWLINE> <DEDENT> i += 1 <NEWLINE> for <NEWLINE> <DEDENT>
n , l = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( range ( l , l + n , 1 ) ) <NEWLINE> x = sum ( a ) <NEWLINE> if ( a in 0 ) : <NEWLINE> <INDENT> a . remove ( 0 ) <NEWLINE> print ( sum ( a ) ) <NEWLINE> <DEDENT> elif ( x < 0 ) : <NEWLINE> <INDENT> a . remove ( max ( a ) ) <NEWLINE> print ( sum ( a ) ) <NEWLINE> <DEDENT> elif ( x > 0 ) : <NEWLINE> <INDENT> a . remove ( min ( a ) ) <NEWLINE> print ( sum ( a ) ) <NEWLINE> <DEDENT>
<COMMENT> <NL> def pop_min_abs ( l ) : <NEWLINE> <INDENT> abs = map ( abs , l ) <NEWLINE> return l . pop ( abs . index ( min ( abs ) ) ) <NEWLINE> <NL> <NL> <NL> <DEDENT> n , l = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> apples = [ l + i - 1 for i in range ( 1 , n + 1 ) ] <NEWLINE> print ( sum ( pop_min_abs ( apples ) ) ) <NEWLINE>
N , L = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> apples = [ i + L - 1 for i in range ( 1 , N + 1 ) ] <NEWLINE> <NL> ans = float ( <STRING> ) <NEWLINE> <NL> for apple in apples : <NEWLINE> <INDENT> ans = min ( ans , abs ( apples ) ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
n , l = map ( int , input ( ) . split ( ) ) <NEWLINE> c = 0 <NEWLINE> m = 100000 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> c += l + i - 1 <NEWLINE> m = min ( m , abs ( l + i - 1 ) ) <NEWLINE> <DEDENT> if l < 0 and a - n <= 0 : <NEWLINE> <INDENT> print ( c + d ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( c - d ) <NEWLINE> <DEDENT>
n , l = map ( int , input ( ) . split ( ) ) <NEWLINE> aj = [ l + i for i in range ( n ) ] <NEWLINE> ajs = sum ( aj ) <NEWLINE> resl = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> aj2 = aj <NEWLINE> del aj2 [ i ] <NEWLINE> resl += [ sum ( aj2 ) ] <NEWLINE> <DEDENT> resl2 = [ abs ( ajs - resl [ i ] ) for i in range ( n ) ] <NEWLINE> x = resl2 . index ( min ( resl2 ) ) <NEWLINE> print ( aj [ x ] ) <NEWLINE>
n . l = map ( int , input ( ) . split ( ) ) <NEWLINE> al = [ l + i for i in range ( n ) ] <NEWLINE> a = min ( al , key = abs ) <NEWLINE> al . remove ( a ) <NEWLINE> print ( sum ( al ) ) <NEWLINE>
n , l = int ( input ( ) ) <NEWLINE> tastes = [ ( i + l ) for i in range ( n ) ] <NEWLINE> t = tastes . copy ( ) <NEWLINE> for j in range ( n ) : <NEWLINE> <INDENT> t [ j ] = abs ( t [ j ] ) <NEWLINE> <DEDENT> del tastes [ t . index ( min ( t ) ) ] <NEWLINE> print ( sum ( tastes ) ) <NEWLINE>
n , l = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> D = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> d = l + i <NEWLINE> D . append ( d ) <NEWLINE> <NL> <DEDENT> if l > - 1 : <NEWLINE> <INDENT> mind = D [ 0 ] <NEWLINE> <DEDENT> elif l + n < 0 : <NEWLINE> <INDENT> mind = D [ n - 1 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> mind = 0 <NEWLINE> <NL> <NL> <DEDENT> ans = sum ( D ) - mind <NEWLINE> print ( ans <NEWLINE>
L , L + 1 , L + 2 , ... , L + N - 1 <NEWLINE> N , L = list ( map ( lambda x : int ( x ) , input ( ) . split ( <STRING> ) ) ) <NEWLINE> <NL> S = int ( N * ( N - 1 ) / 2 ) + L * N <NEWLINE> <NL> if L >= 0 : <NEWLINE> <INDENT> print ( S - L ) <NEWLINE> <DEDENT> elif L + N - 1 <= 0 : <NEWLINE> <INDENT> print ( S - L - N + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( S ) <NEWLINE> <DEDENT>
n , l = map ( int , input ( ) . split ( ) ) <NEWLINE> t = list ( map ( lambda x : l + x , range ( n ) ) ) <NEWLINE> r = sum ( t ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> tmp = sum ( t [ : i ] + t [ i + 1 : ] ) <NEWLINE> dif_t = abs ( r - tmp ) <NEWLINE> if i == 0 : <NEWLINE> <INDENT> dif = dif_t <NEWLINE> <DEDENT> if dif_t < dif : <NEWLINE> <INDENT> ans = tmp <NEWLINE> dif = dif_t <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n , l = map ( int , input ( ) . split ( ) ) <NEWLINE> ls = [ ] <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> ls . append ( abs ( l - 1 + i ) ) <NEWLINE> <DEDENT> mi = l . index ( min ( ls ) ) <NEWLINE> print ( n * ( l - 1 ) + sum ( range ( 1 , n + 1 ) ) - l - mi ) <NEWLINE>
N , L = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <COMMENT> <NL> s = ( N - 1 ) * ( 2 * L + N - 1 ) // 2 <NEWLINE> l = [ abs ( s - ( L + i ) ) for i in range ( N ) ] <NEWLINE> m = min ( l ) <NEWLINE> print ( s - ( L + [ l . index ( m ) ] ) ) <NEWLINE>
N , L = map ( int , input ( ) . split ( ) ) <NEWLINE> <COMMENT> <NL> A = ( 2 L + N - 1 ) * N // 2 <NEWLINE> if L * ( L + N - 1 ) <= 0 : <NEWLINE> <INDENT> print ( A ) <NEWLINE> <DEDENT> elif L + N - 1 < 0 : <NEWLINE> <INDENT> print ( A - ( L + N - 1 ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( A - L ) <NEWLINE> <DEDENT>
n , l = map ( int , input ( ) . split ( ) ) <NEWLINE> a = sorted ( [ l + i for i in range ( n ) ] , key = abs ) <NEWLINE> print ( sum ( s [ 1 : ] ) ) <NEWLINE> <NL>
N , L = map ( int , input ( ) . split ( ) ) <NEWLINE> s = N * L + sum ( 1 , N + 1 ) - N <NEWLINE> K = [ ] <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> K . append ( L + i - 1 ) <NEWLINE> <DEDENT> if 0 <= K [ 0 ] : <NEWLINE> <INDENT> s -= K [ 0 ] <NEWLINE> <DEDENT> elif K [ 0 ] < 0 and K [ N - 1 ] > 0 : <NEWLINE> <INDENT> s = s <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s -= K [ N - 1 ] <NEWLINE> <DEDENT> print ( s ) <NEWLINE>
N , L = map ( int , input ( ) . split ( ) ) <NEWLINE> s = [ ] <NEWLINE> for i in N : <NEWLINE> <INDENT> s . append ( i + L ) <NEWLINE> <DEDENT> t = abs ( s ) <NEWLINE> del s [ t . index ( min ( s ) ) ] <NEWLINE> print ( sum ( s ) ) <NEWLINE>
import math <NEWLINE> <NL> A , B , C , D = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <NL> C_multiple = B // C - A // C <NEWLINE> D_multiple = B // D - A // D <NEWLINE> <NL> if A % C == 0 : <NEWLINE> <INDENT> C_multiple += 1 <NEWLINE> <DEDENT> if A % D == 0 : <NEWLINE> <INDENT> D_multiple += 1 <NEWLINE> <NL> <NL> <DEDENT> CD_gcd = C * D / math . gcd ( C , D ) <NEWLINE> CD_multiple = B // CD_gcd - A // CD_gcd <NEWLINE> if A % CD_gcd == 0 : <NEWLINE> <INDENT> CD_multiple += 1 <NEWLINE> <DEDENT> ** * <NEWLINE> print ( C_multiple ) <NEWLINE> print ( D_multiple ) <NEWLINE> print ( CD_gcd ) <NEWLINE> print ( CD_multiple ) <NEWLINE> ** * <NEWLINE> ans = ( B - A + 1 ) - ( C_multiple + D_multiple - CD_multiple ) <NEWLINE> print ( int ( ans ) ) <NEWLINE>
import math <NEWLINE> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> def calc ( n , c , d ) : <NEWLINE> <INDENT> return n - ( n / c + <NEWLINE> <INDENT> n / d - n / ( c * d / gcd ( c , d ) ) ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <INDENT> a , b , c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> print ( calc ( b , c , d ) - calc ( a - 1 , c , d ) ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> import fractions <NEWLINE> <NL> A , B , C , D = map ( int , input ( ) . split ( ) ) <NEWLINE> BA = np . arange ( A , B + 1 ) <NEWLINE> BA_C = BA % C <NEWLINE> BA_D = BA % D <NEWLINE> BA_CD = BA % ( C * D // fractions . gcd ( C , D ) ) <NEWLINE> <NL> C_count = np . count_nonzero ( BA_C == 0 ) <NEWLINE> D_count = np . count_nonzero ( BA_D == 0 ) <NEWLINE> CD_count = np . count_nonzero ( BA_CD == 0 ) <NEWLINE> <NL> print ( len ( BA ) - ( C_count + D_count - CD_count ) ) <NEWLINE>
l = [ ] <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> l . append ( abs ( l - 1 + i ) ) <NEWLINE> <DEDENT> mi = l . index ( min ( l ) ) <NEWLINE> print ( n * ( l - 1 ) + sum ( range ( 1 , n + 1 ) ) - l - mi ) <NEWLINE>
import math <NEWLINE> def lcm ( x , y ) : <NEWLINE> <INDENT> return ( x * y ) // math . gcd ( x , y ) <NEWLINE> <NL> <DEDENT> A , B , C , D = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> C_bai = list ( range ( A - ( A % C ) + C , B , C + 1 ) ) <NEWLINE> D_bai = list ( range ( A - ( A % D ) + D , B , D + 1 ) ) <NEWLINE> E = lcm ( C , D ) <NEWLINE> CD_bai = list ( range ( A - ( A % E ) + E , B , E + 1 ) ) <NEWLINE> print ( B - A + 1 - len ( C_bai ) - len ( D_bai ) + CD_bai ) <NEWLINE>
from math <NEWLINE> a , b , c , d = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a -= 1 <NEWLINE> def calculation ( x , c , d ) : <NEWLINE> <INDENT> x = x - ( x // c ) - ( x // d ) + ( x // ( ( c * d ) // math . gcd ( c , d ) ) ) <NEWLINE> return x <NEWLINE> <NL> <DEDENT> print ( calculation ( b , c , d ) - calculation ( a , c , d ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> <NL> A = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> A . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> <DEDENT> A . sort ( lambda x : x [ 1 ] , x [ 0 ] ) <NEWLINE> <NL> gokei = 0 <NEWLINE> for i in A : <NEWLINE> <INDENT> gokei += i [ 0 ] <NEWLINE> if gokei > i [ 1 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> AB = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( N ) ] <NEWLINE> <NL> sort_AB = sorted ( AB , key = lambda x : x [ 1 ] ) <NEWLINE> ans = <STRING> <NEWLINE> tmp = 0 <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> tmp += sortedAB [ i ] [ 0 ] <NEWLINE> if tmp > sortedAB [ i ] [ 1 ] : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> import math <NEWLINE> A , B , C , D = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <COMMENT> <NL> lcm = C * D // math . gcd ( C , D ) <NEWLINE> cnt_lcm = B // lcm - A // lcm <NEWLINE> <NL> <COMMENT> <NL> cnt_C = B // C - ( A - 1 ) // C <NEWLINE> <NL> <COMMENT> <NL> cnt_D = B // D - ( A - 1 ) // D <NEWLINE> <NL> <COMMENT> <NL> ans = ( B - A + 1 ) - ( cnt_C + cnt_D - cnt_lcm ) <NEWLINE> <NL> <COMMENT> <NL> if A == B : <NEWLINE> <COMMENT> <NL> <INDENT> if A % C == 0 and A % D == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> work = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ] <NEWLINE> work = sorted ( work , key = lambda x : x [ 1 ] ) <NEWLINE> a = [ 0 ] * n <NEWLINE> a [ 0 ] = work [ 0 ] [ 0 ] <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> a [ i ] = a [ i - 1 ] + work [ i ] [ 0 ] <NEWLINE> <DEDENT> ans = <STRING> <NEWLINE> for j in range ( N ) : <NEWLINE> <INDENT> if a [ j ] > work [ j ] [ 1 ] : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> ls = [ ] <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> ls . append ( [ b , a ] ) <NEWLINE> <DEDENT> ls = ls . sort ( ) <NEWLINE> t = 0 <NEWLINE> for i in ls : <NEWLINE> <INDENT> t += i [ 1 ] <NEWLINE> if t > i [ 0 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( 0 ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
5 <NEWLINE> 2 4 <NEWLINE> 1 9 <NEWLINE> 1 8 <NEWLINE> 4 9 <NEWLINE> 3 12 <NEWLINE>
from e import resolve <NEWLINE> import sys <NEWLINE> from io import StringIO <NEWLINE> import unittest <NEWLINE> <NL> <NL> class TestClass ( unittest . TestCase ) : <NEWLINE> <INDENT> def assertIO ( self , input , output ) : <NEWLINE> <INDENT> stdout , stdin = sys . stdout , sys . stdin <NEWLINE> sys . stdout , sys . stdin = StringIO ( ) , StringIO ( input ) <NEWLINE> resolve ( ) <NEWLINE> sys . stdout . seek ( 0 ) <NEWLINE> out = sys . stdout . read ( ) [ : - 1 ] <NEWLINE> sys . stdout , sys . stdin = stdout , stdin <NEWLINE> self . assertEqual ( out , output ) <NEWLINE> <NL> <DEDENT> def test__1 ( self ) : <NEWLINE> <INDENT> input = <STRING> <NEWLINE> output = <STRING> <NEWLINE> self . assertIO ( input , output ) <NEWLINE> <NL> <DEDENT> def test__2 ( self ) : <NEWLINE> <INDENT> input = <STRING> <NEWLINE> output = <STRING> <NEWLINE> self . assertIO ( input , output ) <NEWLINE> <NL> <DEDENT> def test__3 ( self ) : <NEWLINE> <INDENT> input = <STRING> <NEWLINE> output = <STRING> <NEWLINE> self . assertIO ( input , output ) <NEWLINE> <NL> <DEDENT> def test__4 ( self ) : <NEWLINE> <INDENT> input = <STRING> <NEWLINE> output = <STRING> <NEWLINE> self . assertIO ( input , output ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> unittest . main ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> import math <NEWLINE> import itertools <NEWLINE> import collections <NEWLINE> import heapq <NEWLINE> import re <NEWLINE> import numpy as np <NEWLINE> <NL> rr = lambda : sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> rs = lambda : sys . stdin . buffer . readline ( ) . split ( ) <NEWLINE> ri = lambda : int ( sys . stdin . readline ( ) ) <NEWLINE> rm = lambda : map ( int , sys . stdin . buffer . readline ( ) . split ( ) ) <NEWLINE> rl = lambda : list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) <NEWLINE> inf = float ( <STRING> ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> print ( 10 if ri ( ) >= ri ( ) else 0 ) <NEWLINE> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL>
X , A = map ( int ( input ( ) . split ( ) ) ) <NEWLINE> if X < A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 10 ) <NEWLINE> <DEDENT>
x , a = map ( int , input ( ) ) <NEWLINE> <NL> print ( <STRING> ) if x < a else print ( <STRING> ) <NEWLINE>
x , a = map ( int , input ( ) . split ( ) ) <NEWLINE> if x < a : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
x , a = map ( int , input ( ) . split ( ) ) <NEWLINE> if s < a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 10 ) <NEWLINE> <DEDENT>
def Input ( ) : <NEWLINE> <INDENT> return mapt ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> a , b = Input ( ) <NEWLINE> print ( 0 if a < b else 10 ) <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE>
W , H , x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> flg = 0 <NEWLINE> if W / 2 == x and H / 2 == y : <NEWLINE> <INDENT> ans = ( W * H ) / 2 <NEWLINE> flg = 1 <NEWLINE> <DEDENT> elif W / 2 == x or H / 2 == y : <NEWLINE> <INDENT> ans = ( W * H ) / 2 <NEWLINE> flg = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> tatemax = min ( W - x , x ) * H <NEWLINE> yokomax = min ( H - y , y ) * W <NEWLINE> if tatemax == yokomax : <NEWLINE> <INDENT> ans = tatemax <NEWLINE> flg = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = max ( tatemax , yokomax ) <NEWLINE> flg = 0 <NEWLINE> <DEDENT> <DEDENT> print ( str ( ans ) + <STRING> + str ( flg ) ) <NEWLINE>
x , a = map ( int , input ( ) ) <NEWLINE> if 0 < a < x : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 10 ) <NEWLINE> <DEDENT>
<NL> def main ( ) : <NEWLINE> <INDENT> x , a = map ( int , input ( ) . split ( ) ) <NEWLINE> if x < a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 10 i ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
x , a = map ( int , input ( ) . split ( ) ) <NEWLINE> pritn ( 0 if x < a else 10 ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if a [ 0 ] < b [ 1 ] : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 10 ) <NEWLINE> <DEDENT>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if x < a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 10 ) <NEWLINE> <DEDENT>
a , x = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( 10 if A >= X else 10 ) <NEWLINE>
X , A = int ( input ( ) ) <NEWLINE> if X < A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 10 ) <NEWLINE> <DEDENT>
x , a = map ( int , input ( ) ) <NEWLINE> if x < a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 10 ) <NEWLINE> <DEDENT>
x , a = map ( int , input ( ) ) <NEWLINE> if x < a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 10 ) <NEWLINE> <DEDENT>
a , b = int ( input ( ) . split ( ) ) <NEWLINE> <COMMENT> <NL> if a < b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n , x = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> l = [ 0 ] * ( n + 1 ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> L [ i + 1 ] = l [ i ] + a [ i ] <NEWLINE> <DEDENT> ans = 0 <NEWLINE> for i in l : <NEWLINE> <INDENT> if i <= x : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n , x = map ( int , input ( ) . split ( ) ) <NEWLINE> arr = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> d = 0 <NEWLINE> ans = 1 <NEWLINE> for a in arr : <NEWLINE> <INDENT> d += arr <NEWLINE> if d <= x : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
a , b = input ( ) . split ( ) <NEWLINE> a = int ( a ) <NEWLINE> b = int ( b ) <NEWLINE> c = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> d = 0 <NEWLINE> for i in range ( a ) : <NEWLINE> <INDENT> while d < b : <NEWLINE> <INDENT> d = d + b [ i ] <NEWLINE> <DEDENT> print ( d ) <NEWLINE> break <NEWLINE> <DEDENT>
n , x = map ( int , input ( ) . split ( ) ) <NEWLINE> l = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> ans = 0 <NEWLINE> d = 0 <NEWLINE> for i in l : <NEWLINE> <INDENT> d += i <NEWLINE> ans += 1 <NEWLINE> if d > x : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> exit ( 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT>
LI = lambda : list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> N , X = LI ( ) <NEWLINE> L = LI ( ) <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> ans = X // L <NEWLINE> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n , x = map ( int , input ( ) . split ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> cnt = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if cnt + l [ i ] <= x : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> cnt += l [ i ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> <NL> n , x = map ( int , input ( ) . split ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> d = 1 <NEWLINE> count = 1 <NEWLINE> <NL> for y in range ( n ) : <NEWLINE> <INDENT> d = d + l [ n ] <NEWLINE> if d <= x : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( count ) <NEWLINE> <NL> <NL>
n , x = map ( int , input ( ) . split ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> d = 0 <NEWLINE> count = 1 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> d += n [ i ] <NEWLINE> if d <= x : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
n , x = map ( int , input ( ) . split ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> s = 0 <NEWLINE> count = 1 <NEWLINE> for i in L : <NEWLINE> <INDENT> s += i <NEWLINE> if s > x : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> count += 1 <NEWLINE> <DEDENT> print ( count ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> from fractions import gcd <NEWLINE> from itertools import combinations , permutations , accumulate , product <COMMENT> <NEWLINE> <COMMENT> <NL> from collections import deque , defaultdict , Counter <NEWLINE> import decimal <NEWLINE> import re <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> import sys <NEWLINE> sys . setrecursionlimit ( 10000000 ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <COMMENT> <NL> def readInts ( ) : <NEWLINE> <INDENT> return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <DEDENT> def I ( ) : <NEWLINE> <INDENT> return int ( input ( ) ) <NEWLINE> <DEDENT> n , x = readInts ( ) <NEWLINE> L = readInts ( ) <NEWLINE> cnt = 0 <NEWLINE> now = 0 <NEWLINE> while now <= x : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> now += L [ cnt - 1 ] <NEWLINE> <DEDENT> print ( cnt ) <NEWLINE>
N , X = map ( int , input ( ) . split ( ) ) <NEWLINE> l = [ 0 ] <NEWLINE> l . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> sum = 0 <NEWLINE> for i in range ( N + 1 ) : <NEWLINE> <INDENT> sum += l [ i ] <NEWLINE> if sum > X : <NEWLINE> <INDENT> print ( i ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( N + 1 ) <NEWLINE>
n , x = map ( int . input ( ) . split ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> sum = 0 <NEWLINE> ans = 0 <NEWLINE> for i in l : <NEWLINE> <INDENT> sum += i <NEWLINE> if sum <= x : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT>
W , H , x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <COMMENT> <NL> if x == W / 2 and y == H / 2 : <NEWLINE> <INDENT> area = <STRING> . format ( float ( x * H ) ) <NEWLINE> print ( area , 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> area = <STRING> . format ( float ( min ( W - x ) * H , x * H ) ) <NEWLINE> print ( area , 0 ) <NEWLINE> <DEDENT>
import bisect <NEWLINE> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = tuple ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> s = [ 0 ] * ( N + 1 ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> s [ i + 1 ] = s [ i ] + A [ i ] <NEWLINE> <DEDENT> ans = 0 <NEWLINE> for b in range ( N ) : <NEWLINE> <INDENT> i = bisect . bisect_left ( s , K + s [ b ] , b ) <NEWLINE> ans += ( N + 1 - i ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
w , h , x , y = map ( int , input ( ) split ( ) ) <NEWLINE> area = w * h / 2 <NEWLINE> if x == w / 2 and y == h / 2 : <NEWLINE> <INDENT> print ( area , <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( area , <STRING> ) <NEWLINE> <DEDENT>
W , H , x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> if y == H * x / W or y == H - H * x / W : <NEWLINE> <INDENT> print ( W * H , 1. split ( ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( W * H , 0. split ( ) ) <NEWLINE> <DEDENT>
w , h , x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( ( w * h ) / 2 , ( 2 x == w ) & ( 2 y == h ) ) <NEWLINE>
W , H , x , y = list ( map ( lambda n : int ( n ) , input ( ) . split ( <STRING> ) ) ) <NEWLINE> <NL> S = W * H / 2 <NEWLINE> flag = 1 if W == 2 * x and H == 2 * y else flag = 0 <NEWLINE> print ( S , end = <STRING> ) <NEWLINE> print ( flag ) <NEWLINE>
W , H , x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> ans1 = W * H / 2 <NEWLINE> cen_x , cen_y = W / 2 , H / 2 <NEWLINE> if cen_x == x and cen_y == y : <NEWLINE> <INDENT> ans2 = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans2 = 0 <NEWLINE> <DEDENT> print ( ans1 + <STRING> + ans2 ) <NEWLINE>
<COMMENT> <NL> <NL> w , h , x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> core = ( w / 2 , h / 2 ) <NEWLINE> base = h / w <NEWLINE> slope = ( core [ 1 ] - y ) / ( core [ 0 ] - x ) <NEWLINE> <NL> multi = ( base >= slope and y == core [ 1 ] ) or ( base < slope and x == core [ 0 ] ) <NEWLINE> <NL> print ( w * h / 2 , 1 if multi else 0 ) <NEWLINE>
w , h , x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> candi = [ x , y , w - x , h - y ] <NEWLINE> cnt = 0 <NEWLINE> if min ( candi ) == x : <NEWLINE> <INDENT> res = x * h <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> if min ( candi ) == y : <NEWLINE> <INDENT> res = w * y <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> if min ( candi ) == w - x : <NEWLINE> <INDENT> res = ( w - x ) * h <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> if min ( candi ) = h - y : <NEWLINE> <INDENT> res = w * ( h - y ) <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> if cnt > 0 : <NEWLINE> <INDENT> cnt = 1 <NEWLINE> <DEDENT> print ( res , cnt ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> <NL> w , h , x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> area = max ( min ( w * y , w * ( h - y ) ) , min ( x * h , ( w - x ) * h ) ) <NEWLINE> is_multi = 0 <NEWLINE> <NL> if x == w // 2 and y == h // 2 <NEWLINE> <INDENT> is_multi = 1 <NEWLINE> <NL> <DEDENT> print ( area , is_multi ) <NEWLINE>
W , H , x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if W == 0 or H == 0 : <NEWLINE> <NL> elif x == W / 2 and y == H / 2 : <NEWLINE> <INDENT> print ( W * H / 2 , 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( W * H / 2 , 0 ) <NEWLINE> <DEDENT>
<NL> s = w * h <NEWLINE> <NL> if ( w - x ) * h > ( h - y ) * w : <NEWLINE> <INDENT> print ( float ( ( w - x ) ) * h , end = <STRING> ) <NEWLINE> print ( 0 ) <NEWLINE> <DEDENT> elif ( w - x ) * h == ( h - y ) * w : <NEWLINE> <INDENT> print ( float ( ( w - x ) ) * h , end = <STRING> ) <NEWLINE> print ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( float ( ( h - y ) ) * w , end = <STRING> ) <NEWLINE> print ( 0 ) <NEWLINE> <DEDENT>
w , h , x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> judge = ( w == 2 * x and h == 2 * y ) <NEWLINE> s = w * h / 2 <NEWLINE> print ( area , 1 if judge else 0 ) <NEWLINE>
T , Y , x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> a = <STRING> <NEWLINE> if T / 2 == x & Y / 2 == y : <NEWLINE> <INDENT> a = <STRING> <NEWLINE> <DEDENT> print ( T * Y / 2 , a ) <NEWLINE>
w , h , x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> a = 0 <NEWLINE> if ( h == 2 * x and w == 2 * y ) <NEWLINE> a += 1 <NEWLINE> print ( w * h / 2 , a ) <NEWLINE>
import collections <NEWLINE> W , H , x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> tmp = [ ] <NEWLINE> <NL> if W == x * 2 : <NEWLINE> <INDENT> print ( x * H , 1 ) <NEWLINE> <DEDENT> elif H == y * 2 : <NEWLINE> <INDENT> print ( W * y , 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> tmp . append ( min ( H * x , H * ( W - x ) ) ) <NEWLINE> tmp . append ( min ( W * y , W * ( H - y ) ) ) <NEWLINE> <NL> <DEDENT> tmp_cnt = collections . Counter ( tmp ) <NEWLINE> print ( tmp_cnt ) <NEWLINE> <NL> if len ( tmp_cnt ) == 1 : <NEWLINE> <INDENT> print ( max ( tmp_cnt . keys ( ) ) , 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( max ( tmp_cnt . keys ( ) ) , 0 ) <NEWLINE> <DEDENT>
W , H , x , y = list ( map ( float , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = W * H <NEWLINE> ans = float ( float ( ans ) / 2.0 ) <NEWLINE> ans2 = 0 <NEWLINE> if x == float ( float ( W ) / 2 ) and y == float ( float ( H ) / 2 ) : <NEWLINE> <INDENT> ans2 = 1 <NEWLINE> <NL> <DEDENT> print ( ans + <STRING> + ans2 ) <NEWLINE>
W , H , x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( W * H * 0.5 , int ( x = W * 0.5 and y = H * 0.5 ) ) <NEWLINE>
w , h = map ( int , input ( ) . split ( ) ) <NEWLINE> cx , cy = w / 2 , h / 2 <NEWLINE> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> if x == cx and y == cy : <NEWLINE> <INDENT> print ( w * h / 2 , 1 ) ; exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( w * h / 2 , 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT>
from numba import njit <NEWLINE> <NL> MOD = 10 ** 9 + 7 <NEWLINE> <NL> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> S = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> T = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> @ njit <NEWLINE> def solve ( N , M , S , T ) : <NEWLINE> <INDENT> dp = [ [ 1 ] * ( M + 1 ) for _ in range ( N + 1 ) ] <NEWLINE> for i , s in enumerate ( S ) : <NEWLINE> <INDENT> for j , t in enumerate ( T ) : <NEWLINE> <INDENT> dp [ i + 1 ] [ j + 1 ] = dp [ i + 1 ] [ j ] + dp [ i ] [ j + 1 ] <NEWLINE> if s != t : <NEWLINE> <INDENT> dp [ i + 1 ] [ j + 1 ] -= dp [ i ] [ j ] <NEWLINE> <DEDENT> dp [ i + 1 ] [ j + 1 ] %= MOD <NEWLINE> <DEDENT> <DEDENT> return dp [ M ] [ N ] <NEWLINE> <NL> <DEDENT> print ( solve ( N , M , S , T ) ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> if k == 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else <NEWLINE> <INDENT> print ( n - k ) <NEWLINE> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if k = 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <NL> <INDENT> ans = n - k <NEWLINE> print ( ans ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> xy = [ lnii ( ) for i in range ( n ) ] <NEWLINE> xy . sort ( key = lambda x : x [ 0 ] ) <NEWLINE> <NL> ans = n <NEWLINE> <NL> pq = [ ] <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n ) : <NEWLINE> <INDENT> t_p = xy [ j ] [ 0 ] - xy [ i ] [ 0 ] <NEWLINE> t_q = xy [ j ] [ 1 ] - xy [ i ] [ 1 ] <NEWLINE> pq . append ( [ t_p , t_q ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> for p , q in pq : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( n ) : <NEWLINE> <INDENT> if i == j : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> x1 , y1 = xy [ i ] <NEWLINE> x2 , y2 = xy [ j ] <NEWLINE> if ( x2 - x1 ) == p and ( y2 - y1 ) == q : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> ans = min ( ans , n - cnt ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
from collections import defaultdict , deque <NEWLINE> import sys <NEWLINE> <COMMENT> <NL> def inpl ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = sorted ( inpl ( ) ) <NEWLINE> <NL> print ( a [ - 1 ] - sum ( map ( abs , A [ 1 : - 1 ] ) ) - A [ 0 ] ) <NEWLINE> for i in range ( N - 2 , 0 , - 1 ) : <NEWLINE> <INDENT> a = A [ i ] <NEWLINE> if a > 0 : <NEWLINE> <INDENT> print ( A [ 0 ] , a ) <NEWLINE> A [ 0 ] -= a <NEWLINE> else : <NEWLINE> print ( A [ - 1 ] , a ) <NEWLINE> A [ - 1 ] -= a <NEWLINE> print ( A [ - 1 ] , A [ 0 ] ) <NEWLINE> <DEDENT> <DEDENT>
a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( min ( min ( a + b , b + c ) , a + c ) <NEWLINE>
a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( sum ( a , b , c ) - max ( a , b , c ) ) <NEWLINE>
a , b , c = map ( input ( ) . split ( ) ) <NEWLINE> <NL> print ( min ( a + b , a + c , b + c ) ) <NEWLINE>
ary = list ( map ( lambda n : int ( n ) , input ( ) . split ( <STRING> ) ) ) . sort ( reverse = True ) <NEWLINE> <NL> print ( ary [ 0 ] + ary [ 1 ] ) <NEWLINE>
* A = map ( int , input ( ) . split ( ) ) <NEWLINE> A . sort ( ) <NEWLINE> print ( A [ 0 ] + A [ 1 ] ) <NEWLINE>
p , q , r = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> print ( sum [ p , q , r ] - max [ p , q , r ] ) <NEWLINE>
p = int ( input ( ) ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> r = int ( input ( ) ) <NEWLINE> if p + q < q + r and p + q < p + r : <NEWLINE> <INDENT> print ( p + q ) <NEWLINE> <DEDENT> if p + r < p + q and p + r < q + r : <NEWLINE> <INDENT> print ( p + r ) <NEWLINE> <DEDENT> if q + r < p + r and q + r < p + q : <NEWLINE> <INDENT> print ( q + r ) <NEWLINE> <DEDENT>
print ( sum ( sorted ( list ( map ( int , input ( ) . split ( ) ) [ : 2 ] ) ) ) ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> a , b , c = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> print ( sum ( [ a , b , c ] ) - , max ( a , b , c ) ) <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE>
a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = a . sorted ( ) <NEWLINE> print ( int ( b [ 0 ] ) + int ( b [ 1 ] ) ) <NEWLINE>
p , g , r = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( min ( p + q , q + r , r + p ) ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> p , q , r = map ( int , input ( ) . split ) <NEWLINE> min_time = min ( [ p + q , q + r , r + p ] ) <NEWLINE> print ( min_time ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
is = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> print ( sorted ( lis ) [ 0 ] + sorted ( lis ) [ 1 ] ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> W = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> ans = sum ( W ) <NEWLINE> s = ans <NEWLINE> t = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> s -= W [ i ] <NEWLINE> t += W [ i ] <NEWLINE> ans = min ( abs ( s - t ) ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
count = int ( input ( ) ) <NEWLINE> arr = input ( ) . split ( ) <NEWLINE> s1 = 0 <NEWLINE> s2 = 0 <NEWLINE> for i in arr : <NEWLINE> <INDENT> s2 += int ( i ) <NEWLINE> <DEDENT> minimum_diff = s2 <NEWLINE> for i in range ( 0 , count ) : <NEWLINE> <INDENT> s1 += arr [ i ] <NEWLINE> s2 -= arr [ i ] <NEWLINE> minimum_diff = min ( minimum_diff , abs ( s1 - s2 ) ) <NEWLINE> <DEDENT>
N = input ( ) <NEWLINE> W = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> sum1 , sum2 = 0 , 0 <NEWLINE> ans = 0 <NEWLINE> dif = 1000 <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> sum1 = sum ( W [ 0 : i ] ) <NEWLINE> sum2 = sum ( W [ i : ] ) <NEWLINE> now = abs ( sum1 - sum2 ) <NEWLINE> if dif > now : <NEWLINE> <INDENT> dif = now <NEWLINE> <NL> <DEDENT> <DEDENT> print ( dif ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> W = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> m = 10 ** 10 <NEWLINE> for i in range ( 1 , W ) : <NEWLINE> <INDENT> m = min ( m , abs ( sum ( W [ : i ] ) , sum ( W [ i : ] ) ) ) <NEWLINE> <NL> <DEDENT> print ( m ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> arr = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> res = [ ] <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> res . append ( abs ( sum ( arr [ : i + 1 ] ) - arr ( W [ i + 1 : ] ) ) ) <NEWLINE> <DEDENT> print ( min ( res ) ) <NEWLINE>
import sys <NEWLINE> import math <NEWLINE> import itertools <NEWLINE> import collections <NEWLINE> import heapq <NEWLINE> import re <NEWLINE> import numpy as np <NEWLINE> <NL> rr = lambda : sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> rs = lambda : sys . stdin . readline ( ) . split ( ) <NEWLINE> ri = lambda : int ( sys . stdin . readline ( ) ) <NEWLINE> rm = lambda : map ( int , sys . stdin . readline ( ) . split ( ) ) <NEWLINE> rl = lambda : list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) <NEWLINE> inf = float ( <STRING> ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> n , li = ri ( ) , rl ( ) <NEWLINE> min_ = inf <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> min_ = min ( abs ( sum ( li [ 0 : i ] - li [ i : ] ) ) ) <NEWLINE> <DEDENT> print ( min_ ) <NEWLINE> <NL> <NL> <NL> <NL>
N = int ( input ( ) ) <NEWLINE> * W , = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> s1 , s2 = 0 , sum [ W ] <NEWLINE> ans = sum [ W ] <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> s1 += W [ i ] <NEWLINE> s2 -= W [ i ] <NEWLINE> ans = min ( ans , abs ( s1 - s2 ) ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A = [ ] <NEWLINE> for i in range ( 1 , N - 1 ) : <NEWLINE> <INDENT> A . append ( abs ( S [ : i ] - S [ i : ] ) ) <NEWLINE> <DEDENT> print ( min ( A ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> mlist = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> nlist = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> nlist . append ( abs ( mlist [ : i ] - mlist [ i : ] ) ) <NEWLINE> <DEDENT> print ( min ( nlist ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> W = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> L = [ ] <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> L . append ( abs ( sum ( N [ : i ] ) - sum ( N [ i : ] ) ) ) <NEWLINE> <DEDENT> print ( min ( L ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> list1 = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> great = 9999999 <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> temp = int ( abs ( sum ( list1 [ : i + 1 ] ) - sum ( list1 [ i + 1 : ] ) ) ) <NEWLINE> if temp < great : <NEWLINE> <INDENT> great = temp <NEWLINE> <DEDENT> <DEDENT> print ( samin ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> s = [ ] <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> s . append ( abs ( a [ : i ] - a [ i : ] ) ) <NEWLINE> <DEDENT> print ( min ( s ) ) <NEWLINE>
from itertools import product <NEWLINE> <NL> def mat2_mul ( X , Y ) : <NEWLINE> <INDENT> z = [ [ 0 , 0 ] , [ 0 , 0 ] ] <NEWLINE> for ( i , j , k ) in product ( range ( 2 ) , range ( 2 ) , range ( 2 ) ) : <NEWLINE> <INDENT> z [ i ] [ j ] += X [ i ] [ k ] * Y [ k ] [ j ] <NEWLINE> <DEDENT> return z <NEWLINE> <NL> <DEDENT> def mat2_pow ( X , n ) : <NEWLINE> <INDENT> if n == 0 : <NEWLINE> <INDENT> return [ [ 1 , 0 ] , [ 0 , 1 ] ] <NEWLINE> <DEDENT> elif n % 2 : <NEWLINE> <INDENT> return mat2_mul ( X , mat2_pow ( X , n - 1 ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> half_pow = mat2_pow ( X , n / 2 ) <NEWLINE> return mat2_mul ( half_pow , half_pow ) <NEWLINE> <NL> <DEDENT> <DEDENT> def fib ( n ) : <NEWLINE> <INDENT> if n == 0 : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> f = [ [ 0 , 1 ] , [ 1 , 1 ] ] <NEWLINE> <DEDENT> return mat2_pow ( f , n - 1 ) [ 1 ] [ 1 ] <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> mlis = [ ] <NEWLINE> for _ in range ( m ) : <NEWLINE> <INDENT> a = int ( input ( ) ) <NEWLINE> mlis . append ( a ) <NEWLINE> <DEDENT> ans = 1 <NEWLINE> mae = 0 <NEWLINE> <NL> infi = 10 ** 9 + 7 <NEWLINE> for num in mlis : <NEWLINE> <INDENT> ans *= fibona ( num - mae ) <NEWLINE> ans %= infi <NEWLINE> mae = num + 1 <NEWLINE> <NL> <DEDENT> nobori = n - mae + 1 <NEWLINE> ans *= fibona ( nobori ) <NEWLINE> ans %= infi <NEWLINE> print ( int ( ans ) ) <NEWLINE> <NL> <NL> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> from collections import defaultdict <NEWLINE> <NL> stairs = [ ] <NEWLINE> steps = [ ] <NEWLINE> MOD = 1000000007 <NEWLINE> <NL> n , m = int ( input ( ) ) , int ( ( input ( ) ) ) <NEWLINE> stairs = { int ( input ( ) ) : True for i in range ( m ) } <NEWLINE> <NL> step = defaultdict ( int ) <NEWLINE> step [ 0 ] = 1 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> if i in stairs . keys ( ) : <NEWLINE> <INDENT> step [ i ] = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> step [ i + 1 ] = ( step [ i ] + step [ i + 1 ] ) % MOD <NEWLINE> step [ i + 2 ] = ( step [ i ] + step [ i + 2 ] ) % MOD <NEWLINE> <NL> <DEDENT> <DEDENT> print ( step [ n ] ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> lis = [ 0 ] * n + 1 <NEWLINE> a = [ ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> a . append ( int ( input ( ) ) ) <NEWLINE> <NL> <DEDENT> mod = 10 ** 9 + 7 <NEWLINE> ans = 0 <NEWLINE> if n == 1 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> elif n == 2 : <NEWLINE> <INDENT> if m == 1 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 2 ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if 1 in a and 2 in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> elif 1 in a : <NEWLINE> <INDENT> lis [ 1 ] = 1 <NEWLINE> <DEDENT> elif 2 in a : <NEWLINE> <INDENT> lis [ 0 ] = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> lis [ 0 ] = 1 <NEWLINE> lis [ 1 ] = 2 <NEWLINE> <NL> <DEDENT> for j in range ( 3 , n + 1 ) : <NEWLINE> <INDENT> if j in a : <NEWLINE> <INDENT> lis [ 0 ] = lis [ 1 ] <NEWLINE> lis [ 1 ] = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = lis [ 0 ] % mod + lis [ 1 ] % mod <NEWLINE> lis [ 0 ] = lis [ 1 ] <NEWLINE> lis [ 1 ] = ans <NEWLINE> <NL> <DEDENT> if lis [ 0 ] == 0 and lis [ 1 ] == 0 : <NEWLINE> <INDENT> ans = 0 <NEWLINE> break <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> print ( ans % mod ) <NEWLINE> <DEDENT>
import sys <NEWLINE> import math <NEWLINE> import itertools <NEWLINE> import bisect <NEWLINE> from copy import copy <NEWLINE> from collections import deque , Counter <NEWLINE> from decimal import Decimal <NEWLINE> def s ( ) : return input ( ) <NEWLINE> def k ( ) : return int ( input ( ) ) <NEWLINE> def S ( ) : return input ( ) . split ( ) <NEWLINE> def I ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def X ( ) : return list ( input ( ) ) <NEWLINE> def L ( ) : return list ( input ( ) . split ( ) ) <NEWLINE> def l ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> def lcm ( a , b ) : return a * b // math . gcd ( a , b ) <NEWLINE> def gcd ( * numbers ) : reduce ( math . gcd , numbers ) <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> count = 0 <NEWLINE> ans = 0 <NEWLINE> inf = float ( <STRING> ) <NEWLINE> <NL> def dpp ( n ) : <NEWLINE> <INDENT> for i in range ( 2 , n + 1 ) : <NEWLINE> <INDENT> if a [ i ] = 0 : <NEWLINE> <INDENT> dp [ i ] = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dp [ i ] = dp [ i - 1 ] + dp [ i - 2 ] <NEWLINE> <DEDENT> <DEDENT> return dp [ n ] <NEWLINE> <NL> <DEDENT> N , M = I ( ) <NEWLINE> a = [ 1 ] * ( N + 1 ) <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> x = k ( ) <NEWLINE> a [ x ] = 0 <NEWLINE> <NL> <DEDENT> dp = [ 0 ] * ( N + 1 ) <NEWLINE> if 1 in a : <NEWLINE> <INDENT> dp [ 1 ] = 0 <NEWLINE> dp [ 0 ] = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dp [ 0 ] = dp [ 1 ] = 1 <NEWLINE> <NL> <DEDENT> print ( dpp ( N ) % mod ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ int ( input ( ) ) for _ in range ( M ) ] <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> <NL> dp = [ 0 ] * ( N + 1 ) <NEWLINE> dp [ 0 ] = 1 <NEWLINE> dp [ 1 ] = 1 if 1 not in a else 0 <NEWLINE> <NL> a = list ( set ( range ( 2 , N + 2 ) ) - set ( a ) ) <NEWLINE> for i in a : <NEWLINE> <INDENT> dp [ i ] = ( dp [ i - 1 ] + dp [ i - 2 ] ) % MOD <NEWLINE> <DEDENT> print ( dp [ N ] % MOD ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> a = set ( [ int ( input ( ) ) for j in range ( m ) ] ) <NEWLINE> dp = [ 0 ] * ( n + 1 ) <NEWLINE> dp [ 0 ] = 1 <NEWLINE> if not a [ 0 ] == 1 : <NEWLINE> <INDENT> dp [ 1 ] = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dp [ 1 ] = 0 <NEWLINE> <DEDENT> for i in range ( n - 1 ) : <NEWLINE> <INDENT> if i + 2 in a : <NEWLINE> <INDENT> dp [ i + 2 ] = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dp [ i + 2 ] = ( dp [ i + 1 ] + dp [ i ] ) % ( 10 ** 9 + 7 ) <NEWLINE> <DEDENT> <DEDENT> print ( dp [ n ] ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> issafe = [ True ] * n + 1 <NEWLINE> for _ in range ( m ) : <NEWLINE> <INDENT> a = int ( input ( ) ) <NEWLINE> issafe [ a ] = False <NEWLINE> <NL> <DEDENT> dp = [ 0 ] * n + 1 <NEWLINE> dp [ 0 ] = 1 <NEWLINE> if issafe [ 1 ] : <NEWLINE> <INDENT> dp [ 1 ] = 1 <NEWLINE> <NL> <DEDENT> for i in range ( 2 , n + 1 ) : <NEWLINE> <INDENT> if issafe [ i - 1 ] : <NEWLINE> <INDENT> dp [ i ] = dp [ i ] + dp [ i - 1 ] <NEWLINE> <DEDENT> if issafe [ i - 2 ] : <NEWLINE> <INDENT> dp [ i ] = dp [ i - 2 ] + dp [ i ] <NEWLINE> <NL> <DEDENT> dp [ i ] %= 1000000007 <NEWLINE> <NL> <DEDENT> print ( dp [ n ] ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ int ( input ( ) ) for _ in range ( m ) ] <NEWLINE> ans = 1 <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> MAX = 10 ** 5 + 1 <NEWLINE> fact = [ 1 ] * MAX <NEWLINE> <NL> for i , j in zip ( a [ : m - 1 ] , a [ 1 : ] ) : <NEWLINE> <INDENT> if j - i == 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> def comb_init ( ) : <NEWLINE> <INDENT> fact [ 0 ] , fact [ 1 ] = 1 , 1 <NEWLINE> for i in range ( 2 , MAX ) : <NEWLINE> <INDENT> fact [ i ] = fact [ i - 1 ] * i <NEWLINE> <NL> <DEDENT> <DEDENT> def comb ( n , r ) : <NEWLINE> <INDENT> return ( fact [ n ] % MOD ) * pow ( fact [ r ] , - 1 , MOD ) * pow ( fact [ n - r ] , - 1 , MOD ) <NEWLINE> <NL> <DEDENT> def f ( k ) : <NEWLINE> <INDENT> idx = k // 2 <NEWLINE> num = 0 <NEWLINE> for i in range ( 1 , idx + 1 ) : <NEWLINE> <INDENT> num += comb ( k - i , i ) <NEWLINE> num %= MOD <NEWLINE> <DEDENT> return num + 1 <NEWLINE> <NL> <DEDENT> comb_init ( ) <NEWLINE> for i in range ( m + 1 ) : <NEWLINE> <INDENT> left = 0 if i == 0 else a [ i - 1 ] + 1 <NEWLINE> right = n if i == m else a [ i ] - 1 <NEWLINE> between = right - left <NEWLINE> ans *= f ( between ) <NEWLINE> ans %= MOD <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( int ( input ( ) ) for _ in range ( m ) ) <NEWLINE> dp = [ [ ] for _ in range ( n + 1 ) ] <NEWLINE> dp [ 0 ] = 1 <NEWLINE> <COMMENT> <NL> if m = 0 : <NEWLINE> <INDENT> dp [ 1 ] = 1 <NEWLINE> for i in range ( 2 , n + 1 ) : <NEWLINE> <INDENT> dp [ i ] = ( dp [ i - 1 ] + dp [ i - 2 ] ) % 1000000007 <NEWLINE> <DEDENT> print ( dp [ n ] ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> if a [ 0 ] == 1 : <NEWLINE> <INDENT> dp [ 1 ] = 0 <NEWLINE> j = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dp [ 1 ] = 1 <NEWLINE> j = 0 <NEWLINE> <DEDENT> for i in range ( 2 , n + 1 ) : <NEWLINE> <COMMENT> <NL> <INDENT> if j < m : <NEWLINE> <INDENT> if a [ j ] == i : <NEWLINE> <INDENT> dp [ i ] = 0 <NEWLINE> j += 1 <NEWLINE> continue <NEWLINE> <DEDENT> <DEDENT> dp [ i ] = ( dp [ i - 1 ] + dp [ i - 2 ] ) % 1000000007 <NEWLINE> <DEDENT> print ( dp [ n ] ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ True ] * n <NEWLINE> for _ in range ( m ) : <NEWLINE> <INDENT> a = int ( input ( ) ) <NEWLINE> A [ a ] = False <NEWLINE> <NL> <DEDENT> mod = 10 ** 9 + 7 <NEWLINE> dp = [ 0 ] * ( n + 1 ) <NEWLINE> dp [ 0 ] = 1 <NEWLINE> if A [ 1 ] : <NEWLINE> <INDENT> dp [ 1 ] = 1 <NEWLINE> <NL> <DEDENT> for i in range ( 2 , n + 1 ) : <NEWLINE> <INDENT> if A [ i ] : <NEWLINE> <INDENT> dp [ i ] = dp [ i - 1 ] + dp [ i - 2 ] <NEWLINE> dp [ i ] %= mod <NEWLINE> <NL> <DEDENT> <DEDENT> print ( dp [ n ] ) <NEWLINE> <NL> <NL>
import sys <NEWLINE> import numpy as np <NEWLINE> <NL> <NL> def read ( ) : <NEWLINE> <INDENT> return sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> h , w = map ( int , read ( ) . split ( ) ) <NEWLINE> s = np . array ( [ [ i == <STRING> for i in read ( ) ] for _ in range ( h ) ] , dtype = int ) <NEWLINE> left = s . copy ( ) <NEWLINE> right = s . copy <NEWLINE> up = s . copy <NEWLINE> down = s . copy <NEWLINE> for i in range ( w - 1 ) : <NEWLINE> <INDENT> left [ : , i + 1 ] = ( left [ : , i ] + 1 ) * s [ : , i + 1 ] <NEWLINE> right [ : , - i - 2 ] = ( right [ : , - i - 1 ] + 1 ) * s [ : , - i - 2 ] <NEWLINE> <DEDENT> for i in range ( h - 1 ) : <NEWLINE> <INDENT> up [ i + 1 ] = ( up [ i ] + 1 ) * s [ i + 1 ] <NEWLINE> down [ - i - 2 ] = ( down [ - i - 1 ] + 1 ) * s [ - i - 2 ] <NEWLINE> <DEDENT> print ( ( left + right + up + down ) . max ( ) - 3 ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
class SquareMatrix ( ) : <NEWLINE> <INDENT> def __init__ ( self , n , mod = 1000000007 ) : <NEWLINE> <INDENT> self . n = n <NEWLINE> self . mat = [ [ 0 for j in range ( n ) ] for i in range ( n ) ] <NEWLINE> self . mod = mod <NEWLINE> <NL> <DEDENT> @ staticmethod <NEWLINE> def id ( n , mod = 1000000007 ) : <NEWLINE> <INDENT> res = SquareMatrix ( n , mod ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> res . mat [ i ] [ i ] = 1 <NEWLINE> <DEDENT> return res <NEWLINE> <NL> <DEDENT> @ staticmethod <NEWLINE> def modinv ( n , mod ) : <NEWLINE> <INDENT> assert n % mod != 0 <NEWLINE> c0 , c1 = n , mod <NEWLINE> a0 , a1 = 1 , 0 <NEWLINE> b0 , b1 = 0 , 1 <NEWLINE> while c1 : <NEWLINE> <INDENT> a0 , a1 = a1 , a0 - c0 // c1 * a1 <NEWLINE> b0 , b1 = b1 , b0 - c0 // c1 * b1 <NEWLINE> c0 , c1 = c1 , c0 % c1 <NEWLINE> <DEDENT> return a0 % mod <NEWLINE> <NL> <DEDENT> def set ( self , arr ) : <NEWLINE> <INDENT> for i in range ( self . n ) : <NEWLINE> <INDENT> for j in range ( self . n ) : <NEWLINE> <INDENT> self . mat [ i ] [ j ] = arr [ i ] [ j ] % self . mod <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> def operate ( self , vec ) : <NEWLINE> <INDENT> assert len ( vec ) == self . n <NEWLINE> res = [ 0 for _ in range ( self . n ) ] <NEWLINE> for i in range ( self . n ) : <NEWLINE> <INDENT> for j in range ( self . n ) : <NEWLINE> <INDENT> res [ i ] += self . mat [ i ] [ j ] * vec [ j ] <NEWLINE> res [ i ] %= self . mod <NEWLINE> <DEDENT> <DEDENT> return res <NEWLINE> <NL> <DEDENT> def add ( self , other ) : <NEWLINE> <INDENT> assert other . n == self . n <NEWLINE> res = SquareMatrix ( self . n , self . mod ) <NEWLINE> for i in range ( self . n ) : <NEWLINE> <INDENT> for j in range ( self . n ) : <NEWLINE> <INDENT> res . mat [ i ] [ j ] = self . mat [ i ] [ j ] + other . mat [ i ] [ j ] <NEWLINE> res . mat [ i ] [ j ] %= self . mod <NEWLINE> <DEDENT> <DEDENT> return res <NEWLINE> <NL> <DEDENT> def subtract ( self , other ) : <NEWLINE> <INDENT> assert other . n == self . n <NEWLINE> res = SquareMatrix ( self . n , self . mod ) <NEWLINE> for i in range ( self . n ) : <NEWLINE> <INDENT> for j in range ( self . n ) : <NEWLINE> <INDENT> res . mat [ i ] [ j ] = self . mat [ i ] [ j ] - other . mat [ i ] [ j ] <NEWLINE> res . mat [ i ] [ j ] %= self . mod <NEWLINE> <DEDENT> <DEDENT> return res <NEWLINE> <NL> <DEDENT> def times ( self , k ) : <NEWLINE> <INDENT> res = SquareMatrix ( self . n , self . mod ) <NEWLINE> for i in range ( self . n ) : <NEWLINE> <INDENT> for j in range ( self . n ) : <NEWLINE> <INDENT> res . mat [ i ] [ j ] = self . mat [ i ] [ j ] * k <NEWLINE> res . mat [ i ] [ j ] %= self . mod <NEWLINE> <DEDENT> <DEDENT> return res <NEWLINE> <NL> <DEDENT> def multiply ( self , other ) : <NEWLINE> <INDENT> assert self . n == other . n <NEWLINE> res = SquareMatrix ( self . n , self . mod ) <NEWLINE> for i in range ( self . n ) : <NEWLINE> <INDENT> for j in range ( self . n ) : <NEWLINE> <INDENT> for k in range ( self . n ) : <NEWLINE> <INDENT> res . mat [ i ] [ j ] += self . mat [ i ] [ k ] * other . mat [ k ] [ j ] <NEWLINE> res . mat [ i ] [ j ] %= self . mod <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return res <NEWLINE> <NL> <DEDENT> def power ( self , k ) : <NEWLINE> <INDENT> tmp = SquareMatrix ( self . n , self . mod ) <NEWLINE> for i in range ( self . n ) : <NEWLINE> <INDENT> for j in range ( self . n ) : <NEWLINE> <INDENT> tmp . mat [ i ] [ j ] = self . mat [ i ] [ j ] <NEWLINE> <DEDENT> <DEDENT> res = SquareMatrix . id ( self . n , self . mod ) <NEWLINE> while k : <NEWLINE> <INDENT> if k & 1 : <NEWLINE> <INDENT> res = res . multiply ( tmp ) <NEWLINE> <DEDENT> tmp = tmp . multiply ( tmp ) <NEWLINE> k >>= 1 <NEWLINE> <DEDENT> return res <NEWLINE> <NL> <DEDENT> def trace ( self ) : <NEWLINE> <INDENT> res = 0 <NEWLINE> for i in range ( self . n ) : <NEWLINE> <INDENT> res += self . mat [ i ] [ i ] <NEWLINE> res %= self . mod <NEWLINE> <DEDENT> return res <NEWLINE> <NL> <DEDENT> def determinant ( self ) : <NEWLINE> <INDENT> res = 1 <NEWLINE> tmp = SquareMatrix ( self . n , self . mod ) <NEWLINE> for i in range ( self . n ) : <NEWLINE> <INDENT> for j in range ( self . n ) : <NEWLINE> <INDENT> tmp . mat [ i ] [ j ] = self . mat [ i ] [ j ] <NEWLINE> <DEDENT> <DEDENT> for j in range ( self . n ) : <NEWLINE> <INDENT> if tmp . mat [ j ] [ j ] == 0 : <NEWLINE> <INDENT> for i in range ( j + 1 , self . n ) : <NEWLINE> <INDENT> if tmp . mat [ i ] [ j ] != 0 : <NEWLINE> <INDENT> idx = i <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> for k in range ( self . n ) : <NEWLINE> <INDENT> tmp . mat [ j ] [ k ] , tmp . mat [ idx ] [ k ] = tmp . mat [ idx ] [ k ] , tmp . mat [ j ] [ k ] <NEWLINE> <DEDENT> res *= - 1 <NEWLINE> <DEDENT> inv = SquareMatrix . modinv ( tmp . mat [ j ] [ j ] , self . mod ) <NEWLINE> for i in range ( j + 1 , self . n ) : <NEWLINE> <INDENT> c = - inv * tmp . mat [ i ] [ j ] % self . mod <NEWLINE> for k in range ( self . n ) : <NEWLINE> <INDENT> tmp . mat [ i ] [ k ] += c * tmp . mat [ j ] [ k ] <NEWLINE> tmp . mat [ i ] [ k ] %= self . mod <NEWLINE> <DEDENT> <DEDENT> <DEDENT> for i in range ( self . n ) : <NEWLINE> <INDENT> res *= tmp . mat [ i ] [ i ] <NEWLINE> res %= self . mod <NEWLINE> <DEDENT> return res <NEWLINE> <NL> <DEDENT> def transpose ( self ) : <NEWLINE> <INDENT> res = SquareMatrix ( self . n , self . mod ) <NEWLINE> for i in range ( self . n ) : <NEWLINE> <INDENT> for j in range ( self . n ) : <NEWLINE> <INDENT> res . mat [ i ] [ j ] = self . mat [ j ] [ i ] <NEWLINE> <DEDENT> <DEDENT> return res <NEWLINE> <NL> <DEDENT> def inverse ( self ) : <COMMENT> <NEWLINE> <INDENT> res = SquareMatrix . id ( self . n , self . mod ) <NEWLINE> tmp = SquareMatrix ( self . n , self . mod ) <NEWLINE> sgn = 1 <NEWLINE> for i in range ( self . n ) : <NEWLINE> <INDENT> for j in range ( self . n ) : <NEWLINE> <INDENT> tmp . mat [ i ] [ j ] = self . mat [ i ] [ j ] <NEWLINE> <DEDENT> <DEDENT> for j in range ( self . n ) : <NEWLINE> <INDENT> if tmp . mat [ j ] [ j ] == 0 : <NEWLINE> <INDENT> for i in range ( j + 1 , self . n ) : <NEWLINE> <INDENT> if tmp . mat [ i ] [ j ] != 0 : <NEWLINE> <INDENT> idx = i <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> for k in range ( self . n ) : <NEWLINE> <INDENT> tmp . mat [ j ] [ k ] , tmp . mat [ idx ] [ k ] = tmp . mat [ idx ] [ k ] , tmp . mat [ j ] [ k ] <NEWLINE> res . mat [ j ] [ k ] , res . mat [ idx ] [ k ] = res . mat [ idx ] [ k ] , res . mat [ j ] [ k ] <NEWLINE> <DEDENT> <DEDENT> inv = SquareMatrix . modinv ( tmp . mat [ j ] [ j ] , self . mod ) <NEWLINE> for k in range ( self . n ) : <NEWLINE> <INDENT> tmp . mat [ j ] [ k ] *= inv <NEWLINE> tmp . mat [ j ] [ k ] %= self . mod <NEWLINE> res . mat [ j ] [ k ] *= inv <NEWLINE> res . mat [ j ] [ k ] %= self . mod <NEWLINE> <DEDENT> for i in range ( self . n ) : <NEWLINE> <INDENT> c = tmp . mat [ i ] [ j ] <NEWLINE> for k in range ( self . n ) : <NEWLINE> <INDENT> if i == j : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> tmp . mat [ i ] [ k ] -= tmp . mat [ j ] [ k ] * c <NEWLINE> tmp . mat [ i ] [ k ] %= self . mod <NEWLINE> res . mat [ i ] [ k ] -= res . mat [ j ] [ k ] * c <NEWLINE> res . mat [ i ] [ k ] %= self . mod <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return res <NEWLINE> <NL> <DEDENT> def linear_equations ( self , vec ) : <NEWLINE> <INDENT> return self . inverse ( ) . operate ( vec ) <NEWLINE> <NL> <DEDENT> <DEDENT> L , A , B , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> D = [ 0 for _ in range ( 18 ) ] <NEWLINE> <NL> for i in range ( 18 ) : <NEWLINE> <INDENT> D [ i ] = int ( <STRING> * ( i + 1 ) ) - A ) // B + 1 <NEWLINE> D [ i ] = max ( D [ i ] , 0 ) <NEWLINE> D [ i ] = min ( D [ i ] , L ) <NEWLINE> <NL> <DEDENT> for i in range ( 17 ) [ : : - 1 ] : <NEWLINE> <INDENT> D [ i + 1 ] -= D [ i ] <NEWLINE> <NL> <DEDENT> mat = SquareMatrix . id ( 3 , M ) <NEWLINE> <NL> for i in range ( 18 ) : <NEWLINE> <INDENT> op = SquareMatrix ( 3 , M ) <NEWLINE> op . mat [ 0 ] [ 0 ] = 10 ** ( i + 1 ) <NEWLINE> op . mat [ 0 ] [ 1 ] = 1 <NEWLINE> op . mat [ 1 ] [ 1 ] = 1 <NEWLINE> op . mat [ 1 ] [ 2 ] = B <NEWLINE> op . mat [ 2 ] [ 2 ] = 1 <NEWLINE> mat = op . power ( D [ i ] ) . multiply ( mat ) <NEWLINE> <NL> <DEDENT> print ( mat . operate ( [ 0 , A , 1 ] ) [ 0 ] ) <NEWLINE>
n , a , b , c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> S = list ( input ( ) ) <NEWLINE> S = [ <STRING> ] . expand ( S ) <NEWLINE> print ( S ) <NEWLINE> <NL> flg = 1 <NEWLINE> for i in range ( a - 1 , c - 2 ) : <NEWLINE> <INDENT> if S [ i : i + 2 ] == [ <STRING> , <STRING> ] : <NEWLINE> <INDENT> flg *= 0 <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( b - 1 , d - 2 ) : <NEWLINE> <INDENT> if S [ i : i + 2 ] == [ <STRING> , <STRING> ] : <NEWLINE> <INDENT> flg *= 0 <NEWLINE> <NL> <DEDENT> <DEDENT> if c > d : <NEWLINE> <INDENT> flg2 = 0 <NEWLINE> for i in range ( b - 1 , d ) : <NEWLINE> <INDENT> if S [ i - 1 : i + 2 ] == [ <STRING> , <STRING> , <STRING> ] : <NEWLINE> <INDENT> flg2 = 1 <NEWLINE> <DEDENT> <DEDENT> flg *= flg2 <NEWLINE> <NL> <DEDENT> if flg == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import bisect , copy , heapq , itertools , string <NEWLINE> from collections import * <NEWLINE> from math import * <NEWLINE> import sys <NEWLINE> def input ( ) : return sys . stdin . readline ( ) . strip ( ) <NEWLINE> def INT ( ) : return int ( input ( ) ) <NEWLINE> def MAP ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def LIST ( ) : return list ( MAP ( ) ) <NEWLINE> <NL> n , a , b , c , d = MAP ( ) <NEWLINE> s = input ( ) <NEWLINE> <NL> flag = 0 <NEWLINE> for i in range ( min ( a , b ) + 1 , max ( c , d ) ) : <NEWLINE> <INDENT> if ( a < i < c or b < i < d ) and s [ i ] == s [ i - 1 ] == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> elif max ( a , b ) <= i <= min ( c , d ) and s [ i - 1 ] == s [ i ] == s [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> flag = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if c > d and flag == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N , A , B , C , D = map ( int , input ( ) . split ( ) ) <NEWLINE> N -= 1 <NEWLINE> A -= 1 <NEWLINE> B -= 1 <NEWLINE> C -= 1 <NEWLINE> D -= 1 <NEWLINE> S = input ( ) <NEWLINE> <NL> massesExist = True <NEWLINE> overtakeFlag = False if C > D else True <NEWLINE> proceedableFlag = True <NEWLINE> <NL> if max ( A , B , C , D ) > N : <NEWLINE> <INDENT> massesExist = False <NEWLINE> <NL> <DEDENT> for i in range ( B , D + 1 ) : <NEWLINE> <INDENT> if S [ i - 1 ] == <STRING> and S [ i ] == <STRING> and S [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> overtakeFlag = True <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( A , max ( C , D ) - 1 ) : <NEWLINE> <INDENT> if S [ i ] == <STRING> and S [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> proceedableFlag = False <NEWLINE> <NL> <DEDENT> <DEDENT> if overtakeFlag and proceedableFlag and massesExist : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s = [ 0 ] + list ( input ( ) ) <NEWLINE> if c < d : <NEWLINE> <INDENT> for i in range ( a , d ) : <NEWLINE> <INDENT> if s [ i ] == s [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for j in range ( a , c ) : <NEWLINE> <INDENT> if s [ j ] == s [ j + 1 ] == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for k in range ( b - 1 , d - 2 ) : <NEWLINE> <INDENT> if s [ k ] == s [ k + 1 ] == s [ k + 2 ] == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
from collections import defaultdict <NEWLINE> from collections import deque <NEWLINE> from collections import Counter <NEWLINE> import itertools <NEWLINE> import math <NEWLINE> <NL> def readInt ( ) : <NEWLINE> <INDENT> return int ( input ( ) ) <NEWLINE> <DEDENT> def readInts ( ) : <NEWLINE> <INDENT> return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <DEDENT> def readChar ( ) : <NEWLINE> <INDENT> return input ( ) <NEWLINE> <DEDENT> def readChars ( ) : <NEWLINE> <INDENT> return input ( ) . split ( ) <NEWLINE> <NL> <DEDENT> n , a , b , c , d = readInts ( ) <NEWLINE> s = readChar ( ) <NEWLINE> if ( a - b ) * ( c - d ) < 0 : <NEWLINE> <INDENT> if <STRING> in s [ max ( a , b ) - 1 : ] and <STRING> not in s [ min ( a , b ) ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> elif c < b : <NEWLINE> <INDENT> if <STRING> not in s [ a : c ] and <STRING> not in s [ b : d ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if <STRING> not in s [ min ( a , b ) : ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> raise Exception <NEWLINE> <DEDENT>
N , A , B , C , D = map ( int , input ( ) . split ( ) ) <NEWLINE> S = input ( ) <NEWLINE> <NL> c1 = S [ B - 2 : C ] . count ( <STRING> ) <NEWLINE> c2 = S [ A - 1 : D ] . count ( <STRING> ) <NEWLINE> <NL> if c2 >= 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> pass <NEWLINE> <NL> <DEDENT> if C > D : <NEWLINE> <INDENT> if c1 == 0 : <NEWLINE> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT>
from numba import jit <NEWLINE> s = list ( input ( ) ) <NEWLINE> n = len ( s ) <NEWLINE> ans = 0 <NEWLINE> @ jit <NEWLINE> def p ( ans ) : <NEWLINE> <INDENT> for i in range ( 0 , n - 2 ) : <NEWLINE> <INDENT> b = True <NEWLINE> if s [ i : i + 3 ] == [ <STRING> , <STRING> , <STRING> ] : <NEWLINE> <INDENT> s [ i ] = <STRING> <NEWLINE> s [ i + 1 ] = <STRING> <NEWLINE> s [ i + 2 ] = <STRING> <NEWLINE> ans += 1 <NEWLINE> b = False <NEWLINE> <NL> <DEDENT> <DEDENT> return ans , b <NEWLINE> <DEDENT> while True : <NEWLINE> <INDENT> ans , b = p ( ans ) <NEWLINE> if not b : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> print ( 180 * r - 360 ) <NEWLINE>
print ( 180 * ( int ( input ( ) - 2 ) ) <NEWLINE>
print ( ( int ( input ( ) - 2 ) * 180 ) <NEWLINE>
def solve ( ) : <NEWLINE> <INDENT> s = list ( input ( ) ) <NEWLINE> if s . count ( <STRING> ) >= 8 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> return 0 <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> solve ( ) <NEWLINE> <DEDENT> , <NEWLINE>
from collections import deque <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> <NL> g = [ [ ] for _ in range ( n ) ] <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> g [ a - 1 ] . append ( b - 1 ) <NEWLINE> g [ b - 1 ] . append ( a - 1 ) <NEWLINE> <NL> <DEDENT> c = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c . sort ( ) <NEWLINE> <NL> ans = [ ] <NEWLINE> s = [ 0 ] * n <NEWLINE> que = deque ( [ 0 ] ) <NEWLINE> while que : <NEWLINE> <INDENT> t = que . popleft ( ) <NEWLINE> ans . append ( c . pop ( ) ) <NEWLINE> s [ t ] = 1 <NEWLINE> for e in g [ t ] : <NEWLINE> <INDENT> if not s [ e ] : <NEWLINE> <INDENT> que . append ( e ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( sum ( c ) - max ( c ) ) <NEWLINE> print ( * ans ) <NEWLINE>
<COMMENT> <NL> def input2 ( ) : <NEWLINE> <INDENT> return map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <DEDENT> a , p = input2 ( ) <NEWLINE> ans = ( ( A * 3 ) + p ) // 2 <NEWLINE> print ( ans ) <NEWLINE>
a , b = map ( input ( ) . split ( ) ) <NEWLINE> print ( ( 3 * a + b ) / 2 ) <NEWLINE>
a , p = map ( int , input ( ) . spilit ( ) ) <NEWLINE> print ( ( 3 * a + p ) / 2 - ( 3 * a + p % 2 ) ) <NEWLINE>
a , b = input ( ) . split ( ) <NEWLINE> a = int ( a ) <NEWLINE> b = int ( b ) <NEWLINE> print ( int ( ( a * 3 + b ) / 2 ) <NEWLINE>
a , p = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( ( a * b + p ) // 2 ) <NEWLINE>
a , p = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( ( a * 3 + p ) // 2 ) ) <NEWLINE>
A , P = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( ( 3 A + P ) // 2 ) <NEWLINE>
a , p = map ( int , input ( ) . split ( ) ) <NEWLINE> a == a * 3 * p <NEWLINE> a + p == int , ap <NEWLINE> print ( ap ) <NEWLINE>
a , p = map ( int , inputy ( ) . split ( ) ) <NEWLINE> print ( ( 3 * a + p ) // 2 ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> lst = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> s , p = input ( ) . split ( ) <NEWLINE> p = int ( p ) <NEWLINE> lst . append ( ( s , p , i + 1 ) ) <NEWLINE> <DEDENT> lst_sorted = sorted ( lst , key : lambda x : ( x [ 0 ] , - x [ 1 ] , x [ 2 ] ) ) <NEWLINE> for _ , _ , num in lst_sorted : <NEWLINE> <INDENT> print ( num ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> shops = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> S , P = input ( ) . split ( ) <NEWLINE> shops . append ( [ S , int ( P ) , i ] ) <NEWLINE> <DEDENT> shops . sort ( key = 1 ) <NEWLINE> shops . sort ( ) <NEWLINE> for shop in shops : <NEWLINE> <INDENT> print ( shop [ 2 ] ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> S , P = map ( str , input ( ) . split ( ) ) <NEWLINE> P = int ( p ) <NEWLINE> A . append ( [ S , - P ] ) <NEWLINE> <DEDENT> A . sort ( ) <NEWLINE> for i in A : <NEWLINE> <INDENT> print ( A . index ( i ) + 1 ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> res = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> s , p = max ( str , input ( ) . split ( ) ) <NEWLINE> res . append ( [ s , int ( p ) ] ) <NEWLINE> <DEDENT> res1 = res <NEWLINE> res = sorted ( res , key = lambda x : ( x [ 0 ] , - x [ 1 ] ) ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> print ( res1 . index ( res [ i ] ) + 1 ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> sp = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> s , p = map ( int , input ( ) . split ( ) ) <NEWLINE> sp . append ( [ s , int ( p ) , i + 1 ] ) <NEWLINE> <DEDENT> sp . sort ( key = lambda x : x [ 1 ] , reverse = True ) <NEWLINE> sp . sort ( key = lambda x : x [ 0 ] ) <NEWLINE> for e in sp : <NEWLINE> <INDENT> print ( e [ 2 ] ) <NEWLINE> <DEDENT>
n = int ( input ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> std_in = input ( ) . split ( ) <NEWLINE> dat . append ( [ std_in [ 0 ] , int ( std_in [ 1 ] ) ] ) <NEWLINE> <NL> <DEDENT> for i , e in enumerate ( dat , start = 1 ) : <NEWLINE> <INDENT> e [ 1 ] = - e [ 1 ] <COMMENT> <NEWLINE> e . append ( i ) <COMMENT> <NEWLINE> <NL> sorted_list = sorted ( dat ) <COMMENT> <NEWLINE> <NL> <DEDENT> for i , s in enumerate ( sorted_list ) : <NEWLINE> <COMMENT> <NL> <INDENT> print ( sorted_list [ i ] [ 2 ] ) <NEWLINE> <DEDENT>
list = [ ] <NEWLINE> N = int ( input ( ) ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> S , P = map ( str , input ( ) . split ( ) ) <NEWLINE> list . append ( ( i + 1 , S , int ( P ) ) ) <NEWLINE> <DEDENT> list = sorted ( lst , key = lambda x : ( x [ 1 ] , - x [ 2 ] ) ) <NEWLINE> <NL> for l in list : <NEWLINE> <INDENT> print ( l [ 0 ] ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> lis = [ ( input ( ) + <STRING> + str ( i + 1 ) ) . split ( ) for i in range ( N ) ] <NEWLINE> <NL> lis = [ k for k in lis ] <NEWLINE> <NL> lis . sort ( key = lambda k : int ( k [ 1 ] ) . reverse = True ) <NEWLINE> lis . sort ( key = lambda k : k [ 0 ] ) <NEWLINE> <NL> <NL> for i in lis : <NEWLINE> <INDENT> print ( i [ 2 ] ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <NL> import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> L = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> c , p = input ( ) . split ( ) <NEWLINE> p = int ( p ) <NEWLINE> L . append ( [ i + 1 , c , p ] ) <NEWLINE> <DEDENT> L = sorted ( L , lambda x : ( x [ 1 ] , - x [ 2 ] ) ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> print ( L [ i ] [ 0 ] ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> res = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> s , p = max ( str , input ( ) . split ( ) ) <NEWLINE> <INDENT> res . append ( [ s , int ( p ) ] ) <NEWLINE> <DEDENT> <DEDENT> res1 = res <NEWLINE> res = sorted ( res , key = lambda x : ( x [ 0 ] , - x [ 1 ] ) ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> print ( res1 . index ( res [ i ] ) + 1 ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> l = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> sp = input ( ) . split ( ) <NEWLINE> l . append ( ( sp [ 0 ] , int ( sp [ 1 ] ) , i + 1 ) ) <NEWLINE> <NL> <DEDENT> a = sorted ( l , key = lambda i : ( i [ 0 ] , - l [ 1 ] ) ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> print ( a [ i ] [ 2 ] ) <NEWLINE> <DEDENT>
my_list = [ ] <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> l = list ( ( input ( ) . split ( ) ) ) <NEWLINE> l . append ( i ) <NEWLINE> my_list . append ( l ) <NEWLINE> <NL> <DEDENT> my_list2 = sorted ( my_list , key = lambda x : ( x [ 0 ] , - int ( x [ 1 ] ) ) ) <NEWLINE> for i in my_list2 : <NEWLINE> <INDENT> print ( i [ 2 ] ) <NEWLINE> <NL> <DEDENT>
N = int ( input ( ) ) <NEWLINE> lis = [ ( input ( ) + <STRING> + str ( i + 1 ) ) . split ( ) for i in range ( N ) ] <NEWLINE> <NL> lis = [ k for k in lis ] <NEWLINE> <NL> lis . sort ( key = lambda k : int ( k [ 1 ] ) , reverse = True ) <NEWLINE> lis . sort ( key = lambda k : k [ 0 ] ) <NEWLINE> <NL> <NL> for j in lis : <NEWLINE> <INDENT> print ( j [ 2 ] ) <NEWLINE> <DEDENT> N = int ( input ( ) ) <NEWLINE> lis = [ ( input ( ) + <STRING> + str ( i + 1 ) ) . split ( ) for i in range ( N ) ] <NEWLINE> <NL> lis = [ k for k in lis ] <NEWLINE> <NL> lis . sort ( key = lambda k : int ( k [ 1 ] ) , reverse = True ) <NEWLINE> lis . sort ( key = lambda k : k [ 0 ] ) <NEWLINE> <NL> <NL> for j in lis : <NEWLINE> <INDENT> print ( j [ 2 ] ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> L = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> s , p = input ( ) <NEWLINE> L . append ( [ s , int ( p ) , i + 1 ] ) <NEWLINE> <DEDENT> list . sort ( L , reverse = True ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> print ( L [ i ] [ 2 ] ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> list = [ ] <NEWLINE> for xi in range ( n ) : <NEWLINE> <INDENT> add1 , add2 = input ( ) . split ( ) <NEWLINE> add = [ add2 , add1 , xi + 1 ] <NEWLINE> list . append ( add ) <NEWLINE> <DEDENT> list . sort ( key = lambda list2 : list2 [ 1 ] ) <NEWLINE> <NL> <NL> name = list [ 0 ] [ 1 ] <NEWLINE> list2 = [ list [ 0 ] ] <NEWLINE> count = 1 <NEWLINE> for xi in range ( 1 , n ) : <NEWLINE> <INDENT> if name == list [ xi ] [ 1 ] : <NEWLINE> <INDENT> list2 . append ( list [ xi ] ) <NEWLINE> count += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> list2 . sort ( key = int , reverse = True ) <NEWLINE> for yi in range ( count - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> print ( list2 [ yi ] [ 2 ] ) <NEWLINE> <DEDENT> name = list [ xi ] [ 1 ] <NEWLINE> list2 = [ list [ xi ] ] <NEWLINE> count = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if len ( list2 ) < n : <NEWLINE> <INDENT> list2 . sort ( key = int , reverse = True ) <NEWLINE> <DEDENT> for yi in range ( count - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> print ( list2 [ yi ] [ 2 ] ) <NEWLINE> <DEDENT> name = list [ xi ] [ 1 ] <NEWLINE> list2 = [ list [ xi ] ] <NEWLINE> count = 1 <NEWLINE>
N = int ( input ( ) ) <NEWLINE> data = [ input ( ) . split ( ) for i in range ( N ) ] <NEWLINE> data_name = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if data [ i ] [ 0 ] in data_name : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> data_name . append ( data [ i ] [ 0 ] ) <NEWLINE> <DEDENT> <DEDENT> data_name_sort = sorted ( data_name ) <NEWLINE> data_point = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> num = 0 <NEWLINE> for j in range ( len ( data_name_sort ) ) : <NEWLINE> <INDENT> if data [ i ] [ 0 ] == data_name_sort [ j ] : <NEWLINE> <INDENT> num += ( len ( data_name ) - j ) * 200 + int ( data [ i ] [ 1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> <DEDENT> data_point . append ( num ) <NEWLINE> <DEDENT> data_sort = [ i for i , _ in sorted ( enumerate ( data_point ) , key = lambda x : x [ 1 ] ) ] [ : : - 1 ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> ans = int ( data_sort ( i ) ) + 1 <NEWLINE> print ( ans ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> r = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> s , p = input ( ) . split ( ) <NEWLINE> p = int ( p ) <NEWLINE> r . append ( [ s , p , i ] ) <NEWLINE> <DEDENT> a = sorted ( r ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> print ( a [ i ] [ 3 ] + 1 ) <NEWLINE> <DEDENT>
n = input ( ) <NEWLINE> x = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> s , p = input ( ) . split ( ) <NEWLINE> x . append ( [ s , int ( p ) , i + 1 ] ) <NEWLINE> <DEDENT> x . sort ( key = lambda x : ( x [ 0 ] , - x [ 1 ] ) ) <NEWLINE> for i in x : <NEWLINE> <INDENT> print ( i [ 2 ] ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> s = list ( list ( input ( ) . split ( ) ) for _ in range ( n ) ) <NEWLINE> ans = [ s . index ( i ) + 1 for i in sorted ( s , key = lambda x : ( x [ 0 ] , - int ( x [ 1 ] ) ) ) ] <NEWLINE> print ( i ) for i in ans <NEWLINE>
n = int ( input ( ) ) <NEWLINE> restaurant = [ input ( ) . split ( ) for i in range ( n ) ] <NEWLINE> restaurant_sorted = sorted ( restaurant ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> print ( restaurant . index ( ( restaurant_sorted [ i ] ) ) <NEWLINE> <DEDENT>
<STRING> <NEWLINE> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> lamps = [ list ( map ( lambda x : int ( x ) - 1 , input ( ) . split ( ) ) ) [ 1 : ] for _ in range ( m ) ] <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <COMMENT> <NL> for i in range ( 2 ** n ) : <NEWLINE> <INDENT> for r in range ( m ) : <NEWLINE> <INDENT> on = 0 <NEWLINE> for j in range ( n ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <INDENT> if ( i >> j ) & 1 == 1 and j in lamps [ r ] : <NEWLINE> <INDENT> on += 1 <NEWLINE> <DEDENT> <DEDENT> if on % 2 != p [ r ] : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ ] <NEWLINE> for _ in range ( M ) : <NEWLINE> <INDENT> A . append ( tuple ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <DEDENT> P = tuple ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> import itertools <NEWLINE> def hantei ( A , RETU , P ) : <NEWLINE> <INDENT> for i in range ( len ( A ) ) : <NEWLINE> <INDENT> count = 0 <NEWLINE> for k in RETU : <NEWLINE> <INDENT> if k in A [ i ] [ 1 : ] : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> if not count % 2 == P [ i ] : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> <DEDENT> return True <NEWLINE> <DEDENT> ans = 0 <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> for k in itertools . combinations ( range ( 1 , N + 1 ) , i ) : <NEWLINE> <INDENT> if hantei ( A , k , P ) : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if hantei ( A , 0 , P ) : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> q = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( m ) ] <NEWLINE> ans = 0 <NEWLINE> <NL> for s in range ( 2 ** n ) : <COMMENT> <NEWLINE> <INDENT> judge = True <NEWLINE> for i in range ( m ) : <COMMENT> <NEWLINE> <INDENT> cnt = 0 <NEWLINE> for j in range ( 1 , len ( q [ i ] ) ) : <COMMENT> <NEWLINE> <INDENT> w = q [ i ] [ j ] <NEWLINE> if s >> ( w - 1 ) & 1 == 1 : <COMMENT> <NEWLINE> <INDENT> cnt += 1 <COMMENT> <NEWLINE> <DEDENT> <DEDENT> if cnt % 2 != p [ i ] : <COMMENT> <NEWLINE> <INDENT> judge = False <NEWLINE> <DEDENT> <DEDENT> if judge : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> denkyu_switch = [ ] <NEWLINE> res = 0 <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> denkyu_switch += [ list ( map ( int , input ( ) . split ( ) ) ) [ 1 : ] ] <NEWLINE> <DEDENT> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i in range ( 2 ** n ) : <NEWLINE> <INDENT> denkyu = [ 0 ] * m <NEWLINE> for j in range ( n ) : <NEWLINE> <INDENT> if i >> j & 1 : <NEWLINE> <INDENT> for k in denkyu_switch : <NEWLINE> <INDENT> if j in k : <NEWLINE> <INDENT> denkyu [ k ] += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if p == denkyu : <NEWLINE> <INDENT> res += 1 <NEWLINE> <DEDENT> <DEDENT> print ( res ) <NEWLINE>
<COMMENT> <NL> <NL> <COMMENT> <NL> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> t = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( m ) ] <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> k = [ t [ i ] [ 0 ] for i in range ( m ) ] <NEWLINE> s = [ t [ i ] [ 1 : ] for i in range ( m ) ] <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> ans = 0 <NEWLINE> for i in range ( 2 ** n ) : <NEWLINE> <INDENT> tmp = i <NEWLINE> sw = [ ] <NEWLINE> if i == 0 : <NEWLINE> <INDENT> sw = [ 0 ] <NEWLINE> <DEDENT> while tmp > 0 : <NEWLINE> <INDENT> sw . append ( tmp & 1 ) <NEWLINE> tmp = tmp >> 1 <NEWLINE> <DEDENT> while len ( sw ) < n : <NEWLINE> <INDENT> sw . append ( 0 ) <NEWLINE> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <DEDENT> ok = True <NEWLINE> <COMMENT> <NL> for j in range ( m ) : <NEWLINE> <INDENT> tmp = 0 <NEWLINE> for a in range ( k [ j ] ) : <NEWLINE> <INDENT> tmp += sw [ a + 1 ] <NEWLINE> <DEDENT> if tmp % 2 != p [ j ] % 2 : <NEWLINE> <INDENT> ok = False <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if ok : <NEWLINE> <COMMENT> <NL> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
ans = 0 <NEWLINE> for bit in range ( 1 << N ) : <NEWLINE> <INDENT> count = [ 0 ] * M <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if ( bit >> i ) & 1 : <NEWLINE> <INDENT> for a in range ( M ) : <NEWLINE> <INDENT> if i in ks [ a ] [ 1 : ] : <NEWLINE> <INDENT> count [ a ] += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> a = 0 <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> if count [ i ] % 2 == p [ i ] : <NEWLINE> <INDENT> a += 1 <NEWLINE> if a == M : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> s = list ( list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( m ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 << n ) : <NEWLINE> <COMMENT> <NL> <INDENT> sw = [ False ] * m <NEWLINE> <COMMENT> <NL> for j in range ( M ) : <NEWLINE> <COMMENT> <NL> <INDENT> cnt = 0 <NEWLINE> for k in range ( 1 , len ( s [ j ] ) ) : <NEWLINE> <INDENT> if i >> s [ j ] [ k ] - 1 & 1 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if cnt % 2 == p [ j ] : <NEWLINE> <INDENT> sw [ j ] = True <NEWLINE> <DEDENT> <DEDENT> if all ( sw ) : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> sw = [ [ ] * m ] <NEWLINE> for _ in range ( m ) : <NEWLINE> <INDENT> temp = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> sw [ _ ] = temp [ 1 : ] <NEWLINE> <DEDENT> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 2 ** n ) : <NEWLINE> <INDENT> temp = [ 0 ] * n <NEWLINE> for j in range ( n ) : <NEWLINE> <INDENT> if i & 1 : temp [ j ] = 1 <NEWLINE> i >>= 1 <NEWLINE> <DEDENT> flag = 1 <NEWLINE> for l , s in enumerate ( sw ) : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> for k in s : <NEWLINE> <INDENT> if temp [ k - 1 ] == 1 : cnt += 1 <NEWLINE> <DEDENT> if p [ l ] != cnt % 2 : <NEWLINE> <INDENT> flag = 0 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if flag : ans += 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> q = list ( ) <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> q . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <DEDENT> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> for s in range ( 2 ** n ) : <NEWLINE> <INDENT> judge = True <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> for j in range ( 1 , len ( q [ i ] ) : <NEWLINE> <INDENT> w = q [ i ] [ j ] <NEWLINE> if s >> ( w - 1 ) & 1 == 1 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> if cnt % 2 != p [ i ] : <NEWLINE> <INDENT> judge = False <NEWLINE> <DEDENT> <DEDENT> if judge : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> card = [ [ 0 ] * n for _ in range ( m ) ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> switch = list ( map ( int , input ( ) . split ( ) ) ) [ 1 : ] <NEWLINE> for k in switch : <NEWLINE> <INDENT> card [ i ] [ k - 1 ] = 1 <NEWLINE> <COMMENT> <NL> <NL> <COMMENT> <NL> <NL> <NL> <DEDENT> <DEDENT> ans = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> cnt = 0 <NEWLINE> from itertools import combinations <NEWLINE> <COMMENT> <NL> for epoch in range ( 1 , n + 1 ) : <NEWLINE> <NL> <INDENT> for j in combinations ( range ( 1 , n + 1 ) , epoch ) : <NEWLINE> <INDENT> sco = [ ] <NEWLINE> for lisa in card : <COMMENT> <NEWLINE> <INDENT> score = 0 <NEWLINE> for l in j : <NEWLINE> <INDENT> score += lisa [ l - 1 ] <NEWLINE> <NL> <DEDENT> sco . append ( score ) <NEWLINE> <COMMENT> <NL> <DEDENT> if list ( np . array ( sco ) % 2 ) == ans : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
N , M = map ( int , input ( ) ) <NEWLINE> K = [ ] <NEWLINE> S = [ ] <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> list = input ( ) . split ( ) <NEWLINE> K . append ( int ( list [ 0 ] ) ) <NEWLINE> S . append ( map ( int , list [ 1 : : ] ) ) <NEWLINE> <DEDENT> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> anss = 0 <NEWLINE> for i in range ( 2 ** n ) : <NEWLINE> <INDENT> for j in range ( M ) : <NEWLINE> <INDENT> ans = 0 <NEWLINE> for k in range ( N ) : <NEWLINE> <INDENT> if i >> k & 1 and k in K [ j ] : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> if ans % 2 != p [ j ] : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> anss += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> def dfs ( A ) : <NEWLINE> <INDENT> global cnt <NEWLINE> <NL> if len ( A ) == n : <NEWLINE> <INDENT> ans = [ 0 for i in range ( m ) ] <NEWLINE> print ( A ) <NEWLINE> for i , a in enumerate ( A ) : <NEWLINE> <INDENT> if a : <NEWLINE> <INDENT> for j in range ( m ) : <NEWLINE> <INDENT> if i + 1 in s [ j ] : <NEWLINE> <INDENT> ans [ j ] += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> for x , y in zip ( p , ans ) : <NEWLINE> <INDENT> if x != y % 2 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> return <NEWLINE> <DEDENT> for v in range ( 2 ) : <NEWLINE> <INDENT> A . append ( v ) <NEWLINE> dfs ( A ) <NEWLINE> A . pop ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> s = [ list ( map ( int , x . split ( ) ) ) [ 1 : ] for x in sys . stdin . readlines ( ) ] <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> cnt = 0 <NEWLINE> dfs ( [ ] ) <NEWLINE> print ( cnt ) <NEWLINE>
from itertools import product <NEWLINE> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> cc = [ ] <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> ll = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> cc . append ( ll ) <NEWLINE> <DEDENT> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> count = 0 <NEWLINE> for i in product ( <STRING> , repeat = N ) : <NEWLINE> <INDENT> on = 0 <NEWLINE> bulb = 0 <NEWLINE> for j in range ( M ) : <NEWLINE> <INDENT> for k in range ( cc [ j ] [ 0 ] ) : <NEWLINE> <INDENT> if i [ cc [ m ] [ l + 1 ] - 1 ] == 1 : <NEWLINE> <INDENT> on += 1 <NEWLINE> <DEDENT> <DEDENT> if on % 2 == p [ j ] : <NEWLINE> <INDENT> bulb += 1 <NEWLINE> <DEDENT> <DEDENT> if bulb == M : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE> <NL> <NL> <NL>
from itertools import product <NEWLINE> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> switch = [ ] <NEWLINE> for _ in range ( m ) : <NEWLINE> <INDENT> k , * s = map ( lambda x : int ( x ) - 1 , input ( ) . split ( ) ) <NEWLINE> switch . append ( s ) <NEWLINE> <DEDENT> p = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> for subset in product ( ( 0 , 1 ) , n ) : <NEWLINE> <INDENT> for j in range ( m ) : <NEWLINE> <INDENT> on_cnt = sum ( subset [ s ] for s in switch [ j ] ) <NEWLINE> if on_cnt % 2 != p [ j ] : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from itertools import product <NEWLINE> <NL> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> ks = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( m ) ] <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> cnt = 0 <NEWLINE> for pat in product ( [ 0 , 1 ] , repeat = n ) : <NEWLINE> <INDENT> for ksi , pi in zip ( ks , pi ) : <NEWLINE> <INDENT> tmp = sum ( pat [ ksij - 1 ] for ksij in ksi [ 1 : ] ) <NEWLINE> if tmp % 2 != pi : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
import itertools <NEWLINE> <NL> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> lights = [ ] <NEWLINE> for m in range ( M ) : <NEWLINE> <NL> <INDENT> interpools mpzp ( input ( ) ) <NEWLINE> <INDENT> tmp = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> lights . append ( tmp [ 1 : ] ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> P = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> for product in list ( itertools . product ( [ 0 , 1 ] , repeat = N ) ) : <NEWLINE> <INDENT> for light in range ( len ( lights ) ) : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> for l in lights [ light ] : <NEWLINE> <INDENT> cnt += product [ l - 1 ] <NEWLINE> <DEDENT> if cnt % 2 != P [ light ] : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if light == len ( lights ) - 1 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> state = [ ] <NEWLINE> for _ in range ( M ) : <NEWLINE> <INDENT> lst = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> state . append ( lst [ 1 : ] ) <COMMENT> <NEWLINE> <DEDENT> p = list ( map ( int , input ( ) . split ( ) ) ) <COMMENT> <NEWLINE> ans = 0 <NEWLINE> for i in rage ( 2 ** n ) : <NEWLINE> <INDENT> total = 0 <NEWLINE> for j in range ( m ) : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> for s in state [ j ] : <NEWLINE> <INDENT> s -= 1 <NEWLINE> if ( i >> s ) & 1 : <COMMENT> <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> cnt %= 2 <NEWLINE> if cnt == p [ j ] : <NEWLINE> <INDENT> total += 1 <NEWLINE> <DEDENT> <DEDENT> if total == m : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> V = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> ans = 0 <NEWLINE> for M in range ( K + 1 ) : <NEWLINE> <INDENT> for m in range ( M + 1 ) : <NEWLINE> <INDENT> ls = [ ] <NEWLINE> cur1 = 0 <NEWLINE> for i , x in enumerate ( V ) : <NEWLINE> <INDENT> if i < m : <NEWLINE> <INDENT> ls . append ( x ) <NEWLINE> cur += 1 <NEWLINE> <DEDENT> <DEDENT> cur2 = 0 <NEWLINE> for i , x in enumerate ( V [ : : - 1 ] ) : <NEWLINE> <INDENT> if i < min ( M - m , N - cur1 ) : <NEWLINE> <INDENT> ls . append ( x ) <NEWLINE> cur2 += 1 <NEWLINE> <DEDENT> <DEDENT> ls . sort ( ) <NEWLINE> s = sum ( ls ) <NEWLINE> for i , x in enumerate ( ls ) : <NEWLINE> <INDENT> if i < K - ( cur1 + cur2 ) : <NEWLINE> <INDENT> s -= x <NEWLINE> <DEDENT> <DEDENT> ans = max ( ans , s ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> from heapq import * <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> n , q = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> key = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> s , t , x = map ( int , input ( ) . split ( ) ) <NEWLINE> l , r = max ( 0 , s - x ) , max ( 0 , t - x ) <NEWLINE> key . append ( ( l , - 1 , x ) ) <NEWLINE> key . append ( ( r , 1 , x ) ) <NEWLINE> <NL> <DEDENT> key . sort ( ) <NEWLINE> judge = [ ] <NEWLINE> now = set ( ) <NEWLINE> already = dict ( ) <NEWLINE> search = [ ] <NEWLINE> <NL> for i in range ( n * 2 ) : <NEWLINE> <INDENT> s , j , x = key [ i ] <NEWLINE> <NL> if j == - 1 : <NEWLINE> <INDENT> heappush ( judge , x ) <NEWLINE> now . add ( x ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> now . remove ( x ) <NEWLINE> if x in already : <NEWLINE> <INDENT> already [ x ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> already [ x ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if i == n * 2 - 1 or key [ i ] [ 0 ] != key [ i + 1 ] [ 0 ] : <NEWLINE> <INDENT> while judge : <NEWLINE> <INDENT> if judge [ 0 ] in already and already [ judge [ 0 ] ] > 0 : <NEWLINE> <INDENT> already [ judge [ 0 ] ] -= 1 <NEWLINE> heappop ( judge ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> if judge : <NEWLINE> <INDENT> search . append ( ( s , judge [ 0 ] ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> search . append ( ( s , - 1 ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> size = len ( search ) <NEWLINE> index = 0 <NEWLINE> answer = [ ] <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> d = int ( input ( ) ) <NEWLINE> while index < size - 1 : <NEWLINE> <INDENT> if search [ index + 1 ] [ 0 ] <= d : <NEWLINE> <INDENT> index += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> print ( search [ index ] [ 1 ] ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <NL> <NL> <NL> <DEDENT>
import heapq <NEWLINE> n , q = map ( int , input ( ) . split ( ) ) <NEWLINE> event = [ ] <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> s , t , x = map ( int , input ( ) . split ( ) ) <NEWLINE> event . append ( ( s - x , 1 , x ) ) <NEWLINE> event . append ( ( t - x , - 1 , x ) ) <NEWLINE> <NL> <DEDENT> event . sort ( ) <NEWLINE> heap = [ ] <NEWLINE> xs = set ( [ ] ) <NEWLINE> <NL> d = [ int ( input ( ) ) for _ in range ( q ) ] <NEWLINE> ans = [ - 1 ] * q <NEWLINE> index = 0 <NEWLINE> for t , query , x in event : <NEWLINE> <INDENT> if d [ index ] < t : <NEWLINE> <INDENT> if not xs : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> while heap : <NEWLINE> <INDENT> tmp = heapq . heappop ( heap ) <NEWLINE> if tmp in xs : <NEWLINE> <INDENT> heapq . heappush ( heap , tmp ) <NEWLINE> ans [ index ] = tmp <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> index += 1 <NEWLINE> if index == q : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> if query == 1 : <NEWLINE> <INDENT> xs . add ( x ) <NEWLINE> heapq . heappush ( heap , x ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> xs . remove ( x ) <NEWLINE> <NL> <DEDENT> cnt [ t ] -= 1 <NEWLINE> <NL> <DEDENT> while index < q : <NEWLINE> <INDENT> while heap : <NEWLINE> <INDENT> tmp = heapq . heappop ( heap ) <NEWLINE> if tmp in xs : <NEWLINE> <INDENT> heapq . heappush ( heap , tmp ) <NEWLINE> ans [ index ] = tmp <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> index += 1 <NEWLINE> <NL> <DEDENT> print ( <STRING> . join ( map ( str , ans ) ) ) <NEWLINE> <NL> <NL> <NL>
age , cost = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if age <= 5 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif age >= 6 and age <= 12 : <NEWLINE> <INDENT> print ( a // 2 ) <NEWLINE> <DEDENT> elif age >= 13 : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <DEDENT>
A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> if 13 <= A : <NEWLINE> <INDENT> ans = B <NEWLINE> <DEDENT> elif 6 <= A : <NEWLINE> <INDENT> ans = B / 2 S <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( [ [ 0 , b // 2 ] [ a > 5 , b ] [ a > 12 ] ) <NEWLINE>
A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if 13 <= A : <NEWLINE> <INDENT> print ( B ) <NEWLINE> <DEDENT> elif 6 <= A : <NEWLINE> <INDENT> print ( int ( B / 2 ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 <NEWLINE> <DEDENT>
A , B = map ( int ( input ( ) ) . split ( ) ) <NEWLINE> <NL> if A >= 13 : <NEWLINE> <INDENT> print ( B ) <NEWLINE> <DEDENT> elif 6 <= A <= 12 : <NEWLINE> <INDENT> print ( B / 2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT>
a , b = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> if a = > 13 : <NEWLINE> <INDENT> print ( b ) <NEWLINE> <DEDENT> elif a >= 6 and a <= 12 : <NEWLINE> <INDENT> print ( b / 2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if A >= 13 : <NEWLINE> <INDENT> print ( b ) <NEWLINE> <DEDENT> elif 6 <= A : <NEWLINE> <INDENT> print ( b / 2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT>
a , b = map ( int , input ( ) ) <NEWLINE> if a > 12 : <NEWLINE> <INDENT> print ( b ) <NEWLINE> <DEDENT> elif 13 > a > 5 : <NEWLINE> <INDENT> print ( b / 2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT>
a , b = map ( input ( ) . split ( ) ) <NEWLINE> if a >= 13 : <NEWLINE> <INDENT> print ( b ) <NEWLINE> <DEDENT> elif 12 <= a <= 6 : <NEWLINE> <INDENT> print ( b // 2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT>
a = int ( input ( ) ) <NEWLINE> b = int ( input ( ) ) <NEWLINE> if a >= 13 : <NEWLINE> <INDENT> print ( b ) <NEWLINE> <DEDENT> elif a >= 6 : <NEWLINE> <INDENT> print ( b // 2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT>
if a >= 13 : <NEWLINE> <INDENT> print ( b ) <NEWLINE> <DEDENT> elif a >= 6 and a <= 12 : <NEWLINE> <INDENT> print ( int ( b / 2 ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT>
A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> print ( int ( B ) if A >= 13 else 0 if A <= 5 else int ( B // 2 ) <NEWLINE>
A , B = map ( int , input ( ) . sprit ( ) ) <NEWLINE> if A <= 5 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> elif A <= 12 : <NEWLINE> <INDENT> print ( B // 2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( B ) <NEWLINE> <DEDENT>
<NL> def main ( ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) ) <NEWLINE> if a >= 13 : <NEWLINE> <INDENT> print ( b ) <NEWLINE> <DEDENT> elif 6 <= a <= 12 : <NEWLINE> <INDENT> print ( b // 2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
a , b = int ( input ) ) <NEWLINE> if a <= 5 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> elif a <= 12 : <NEWLINE> <INDENT> print ( b // 2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( b ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> A , B = map ( int , input ( ) , split ( ) ) <NEWLINE> if A >= 13 : <NEWLINE> <INDENT> print ( B ) <NEWLINE> <DEDENT> elif 6 <= A <= 12 : <NEWLINE> <INDENT> print ( B / 2 ) <NEWLINE> <DEDENT> elif A <= 5 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT>
A = int ( input ( ) ) <NEWLINE> B = int ( input ( ) ) <NEWLINE> <NL> if A >= 13 : <NEWLINE> <INDENT> print ( B ) <NEWLINE> <DEDENT> elif A >= 6 : <NEWLINE> <INDENT> half_b = B / 2 <NEWLINE> print ( half_b ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( int ( 0 ) ) <NEWLINE> <DEDENT>
A , B = input ( ) . split ( ) <NEWLINE> <NL> if A < 5 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> elif A < 12 : <NEWLINE> <INDENT> C = B / 2 <NEWLINE> print ( C ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( B ) <NEWLINE> <DEDENT>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if a <= 5 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> elif 6 <= a and a <= 12 : <NEWLINE> <INDENT> print ( int ( b / 2 ) a ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( b ) <NEWLINE> <DEDENT>
a = int ( input ( <STRING> ) <NEWLINE> b = int ( input ( <STRING> ) <NEWLINE> if b % 2 == 0 : <NEWLINE> <INDENT> if a >= 13 : <NEWLINE> <INDENT> print ( b ) <NEWLINE> <DEDENT> elif 6 <= a <= 12 : <NEWLINE> <INDENT> print ( b / 2 ) <NEWLINE> <DEDENT> elif a <= 5 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> <DEDENT>
a , b = map ( int , input ( ) . sprit ( ) ) <NEWLINE> if a >= 13 : <NEWLINE> <INDENT> print ( b ) <NEWLINE> <DEDENT> elif 6 <= a <= 12 : <NEWLINE> <INDENT> print ( b // 2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT>
a , b , c = input ( ) . split ( ) <NEWLINE> a = int ( a ) <NEWLINE> b = int ( b ) <NEWLINE> c = int ( c ) <NEWLINE> d = c <NEWLINE> while i < 10 : <NEWLINE> d = a * d - b <NEWLINE> print ( d ) <NEWLINE> i = i + 1 <NEWLINE>
r , D , x = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> for i in range ( 10 ) <NEWLINE> <INDENT> x = r * x - D <NEWLINE> <INDENT> print ( x ) <NEWLINE> <DEDENT> <DEDENT>
arr = input . split ( ) <NEWLINE> r = int ( arr [ 0 ] ) <NEWLINE> d = int ( arr [ 1 ] ) <NEWLINE> x = int ( arr [ 2 ] ) <NEWLINE> <NL> for i in range ( 0 , 10 ) : <NEWLINE> <INDENT> x = r * x - d <NEWLINE> print ( x ) <NEWLINE> <DEDENT>
r , d , x = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> for i inrange ( 1 , 11 ) : <NEWLINE> <INDENT> x = r * x - d <NEWLINE> print ( x ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <NL> age , cost = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if age <= 5 : <NEWLINE> <INDENT> cost = 0 <NEWLINE> <DEDENT> elif 6 <= age <= 12 : <NEWLINE> <INDENT> cost = cost // 2 <NEWLINE> <DEDENT> elif 7 <= age : <NEWLINE> <INDENT> cost = cost <NEWLINE> <NL> <DEDENT> print ( cost ) <NEWLINE>
r , d , x = map ( int , input ( ) . split ( ) ) <NEWLINE> for i in range ( 10 ) : <NEWLINE> <INDENT> x = r * x - d <NEWLINE> <INDENT> print ( x ) <NEWLINE> <DEDENT> <DEDENT>
r , D , x = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> tmp = x <NEWLINE> for i in range ( 10 ) : <NEWLINE> <INDENT> tmp = tmp * r - d <NEWLINE> print ( tmp ) <NEWLINE> <DEDENT>
x , D , xx = map ( int , input ( ) . split ( ) ) <NEWLINE> for i for range ( 10 ) : <NEWLINE> <INDENT> xx = x * xx - D <NEWLINE> print ( xx ) <NEWLINE> <DEDENT>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> lmax = 0 <NEWLINE> rmin = 10 ** 5 <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> L , R = map ( int , input ( ) . split ( ) ) <NEWLINE> lmax = max ( lmax , L ) <NEWLINE> rmin = min ( rmin , R ) <NEWLINE> <DEDENT> ans = rmin - lmax <NEWLINE> if ans >= 0 : <NEWLINE> <INDENT> print ( ans + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> L = [ ] <NEWLINE> R = [ ] <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> l , r = input ( ) . split ( ) <NEWLINE> L . append ( int ( l ) ) <NEWLINE> R . append ( r ) <NEWLINE> <NL> <NL> <DEDENT> x = min ( R ) - max ( L ) <NEWLINE> <NL> <NL> print ( 0 if x < 0 else x + 1 ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> l = 1 <NEWLINE> r = n <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> li , ri = map ( int , input ( ) . split ( ) ) <NEWLINE> l = max ( l , li ) <NEWLINE> r = min ( r , ri ) <NEWLINE> <DEDENT> print ( max ( r - l , 0 ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ ] * m <NEWLINE> b = [ ] * m <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> a . append ( l ) <NEWLINE> b . append ( r ) <NEWLINE> <NL> <DEDENT> if max ( a ) <= min ( b ) : <NEWLINE> <INDENT> print ( min ( b ) - max ( a ) + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> global FLAG_LOG <NEWLINE> FLAG_LOG = False <NEWLINE> <NL> <NL> def log ( value ) : <NEWLINE> <COMMENT> <NL> <INDENT> FLAG_LOG = False <NEWLINE> if FLAG_LOG : <NEWLINE> <INDENT> print ( str ( value ) ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def calculation ( lines ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <INDENT> N , M = list ( map ( int , lines [ 0 ] . split ( ) ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> valueses = list ( ) <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> valueses . append ( list ( map ( int , lines [ i + 1 ] . split ( ) ) ) ) <NEWLINE> <NL> <DEDENT> ll = None <NEWLINE> rr = None <NEWLINE> <NL> log ( <STRING> ) <NEWLINE> <NL> for i in range ( M ) : <NEWLINE> <INDENT> l = valueses [ i ] [ 0 ] <NEWLINE> r = valueses [ i ] [ 1 ] <NEWLINE> if ll is None : <NEWLINE> <INDENT> ll = l <NEWLINE> <DEDENT> elif ll < l : <NEWLINE> <INDENT> ll = l <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> log ( <STRING> ) <NEWLINE> <DEDENT> if rr is None : <NEWLINE> <INDENT> rr = r <NEWLINE> <DEDENT> elif rr > r : <NEWLINE> <INDENT> rr = r <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> log ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> log ( <STRING> ) <NEWLINE> log ( <STRING> ) <NEWLINE> <NL> return [ max ( rr - ll + 1 , 0 ) ] <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> def get_input_lines ( ) : <NEWLINE> <INDENT> lins = input ( ) <NEWLINE> N , M = list ( map ( int , line . split ( ) ) ) <NEWLINE> lines = list ( ) <NEWLINE> lines . append ( line ) <NEWLINE> for _ in range ( M ) : <NEWLINE> <INDENT> lines . append ( input ( ) ) <NEWLINE> <DEDENT> return lines <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> def get_testdata ( pattern ) : <NEWLINE> <INDENT> if pattern == 1 : <NEWLINE> <INDENT> lines_input = [ <STRING> , <STRING> , <STRING> ] <NEWLINE> lines_export = [ 2 ] <NEWLINE> <DEDENT> if pattern == 2 : <NEWLINE> <INDENT> lines_input = [ <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> lines_export = [ 1 ] <NEWLINE> <DEDENT> if pattern == 3 : <NEWLINE> <INDENT> lines_input = [ <STRING> , <STRING> ] <NEWLINE> lines_export = [ 100000 ] <NEWLINE> <DEDENT> return lines_input , lines_export <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> def get_mode ( ) : <NEWLINE> <INDENT> import sys <NEWLINE> args = sys . argv <NEWLINE> global FLAG_LOG <NEWLINE> if len ( args ) == 1 : <NEWLINE> <INDENT> mode = 0 <NEWLINE> FLAG_LOG = False <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> mode = int ( args [ 1 ] ) <NEWLINE> FLAG_LOG = True <NEWLINE> <DEDENT> return mode <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> import time <NEWLINE> started = time . time ( ) <NEWLINE> mode = get_mode ( ) <NEWLINE> if mode == 0 : <NEWLINE> <INDENT> lines_input = get_input_lines ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> lines_input , lines_export = get_testdata ( mode ) <NEWLINE> <NL> <DEDENT> lines_result = calculation ( lines_input ) <NEWLINE> <NL> for line_result in lines_result : <NEWLINE> <INDENT> print ( line_result ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
r = input ( ) . split ( ) <NEWLINE> N = int ( r [ 0 ] ) <NEWLINE> M = int ( r [ 1 ] ) <NEWLINE> data = [ [ int ( s ) for s in input ( ) . split ( ) ] for i in range ( M ) ] <NEWLINE> left = [ ] <NEWLINE> right = [ ] <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> left . append ( data [ i ] [ 0 ] ) <NEWLINE> right . append ( data [ i ] [ 1 ] ) <NEWLINE> <DEDENT> if min ( right ) - max ( left ) + 1 = < 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( min ( right ) - max ( left ) + 1 ) <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> l , r = [ ] , [ ] <NEWLINE> <NL> for _ in range ( m ) : <NEWLINE> <INDENT> s , t = map ( int , input ( ) . split ( ) ) <NEWLINE> l . append ( s ) <NEWLINE> r . append ( t ) <NEWLINE> <NL> <DEDENT> ans = min ( r ) - max ( s ) + 1 <NEWLINE> print ( ans ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> <COMMENT> <NL> l = [ 0 ] * 100005 <NEWLINE> r = [ 1000005 ] * 100005 <NEWLINE> z = 1000010 <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> l [ i ] , r [ i ] = map ( int , input ( ) . split ( ) ) <NEWLINE> <DEDENT> mi = max ( l ) <NEWLINE> ma = min ( r ) <NEWLINE> <NL> <NL> <NL> if mi > ma : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else <NEWLINE> <INDENT> print ( ma - mi + 1 ) <NEWLINE> <DEDENT>
<COMMENT> <NL> def input2 ( ) : <NEWLINE> <INDENT> return map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <DEDENT> N , M = input2 ( ) <NEWLINE> L , R = [ ] , [ ] <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> l , r = input2 ( ) <NEWLINE> L . append ( l ) <NEWLINE> R . append ( r ) <NEWLINE> <NL> <DEDENT> MIN = 0 <NEWLINE> MAX = N <NEWLINE> <NL> for j in range ( M ) : <NEWLINE> <INDENT> if L [ j ] > MIN and : <NEWLINE> <INDENT> MIN = L [ j ] <NEWLINE> <DEDENT> if R [ j ] < MAX : <NEWLINE> <INDENT> MAX = R [ j ] <NEWLINE> <NL> <DEDENT> <DEDENT> if MAX < MIN : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ( MAX - MIN ) + 1 ) <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> lr = [ [ map ( int , input ( ) . split ( ) ) ] for i in range ( m ) ] <NEWLINE> <NL> max = 0 <NEWLINE> min = n + 1 <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> if lr [ i ] [ 0 ] > max : <NEWLINE> <INDENT> max = lr [ i ] [ 0 ] <NEWLINE> <DEDENT> if lr [ i ] [ 1 ] < min : <NEWLINE> <INDENT> min = lr [ i ] [ 1 ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( min - max + 1 ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> l_max = 0 <NEWLINE> r_min = n <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> l_max = max ( l_max , l ) <NEWLINE> r_min = min ( r_min , r ) <NEWLINE> <DEDENT> print ( r_min - l_max ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <NL> L , R = map ( int , input ( ) . split ( ) ) <NEWLINE> ar = [ i for i in range ( L , R + 1 ) ] <NEWLINE> for i in range ( M - 1 ) : <NEWLINE> <INDENT> L , R = map ( int , input . split ( ) ) <NEWLINE> if ar [ - 1 ] < L or ar [ 0 ] > R : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if ar [ 0 ] < L < ar [ - 1 ] : <NEWLINE> <INDENT> ar = [ x for x in range ( L , ar [ - 1 ] + 1 ) ] <NEWLINE> <DEDENT> elif ar [ 0 ] < R < ar [ - 1 ] : <NEWLINE> <INDENT> ar = [ x for x in range ( ar [ 0 ] , R + 1 ) ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( len ( ar ) ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = [ i for i in range ( 1 , n + 1 ) ] <NEWLINE> <NL> for _ in range ( m ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> tmp = [ i for i in range ( x , y + 1 ) ] <NEWLINE> for ele in tmp : <NEWLINE> <INDENT> ans . remove ( ele ) <NEWLINE> <DEDENT> <DEDENT> print ( n - len ( ans ) ) <NEWLINE>
import heapq <NEWLINE> <NL> n , m = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> cards = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> cards . sort ( ) <NEWLINE> <NL> queries = [ ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> q = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> queries . append ( q ) <NEWLINE> <DEDENT> queries . sort ( key = lambda x : x [ 1 ] ) <NEWLINE> queries . reverse ( ) <NEWLINE> <NL> ans = 0 <NEWLINE> pos = 0 <NEWLINE> for q in queries : <NEWLINE> <INDENT> b , c = q <NEWLINE> if cards [ min ( pos + b - 1 , n - 1 ) ] < c : <NEWLINE> <COMMENT> <NL> <INDENT> pos = pos + b <NEWLINE> ans += c * b <NEWLINE> if pos >= n : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( b ) : <NEWLINE> <INDENT> if cards [ pos + i , n - 1 ] < c : <NEWLINE> <COMMENT> <NL> <INDENT> ans += c <NEWLINE> <DEDENT> else : <NEWLINE> <COMMENT> <NL> <INDENT> pos += i <NEWLINE> for j in range ( pos , n ) : <NEWLINE> <INDENT> ans += cards [ j ] <NEWLINE> <NL> <DEDENT> pos = n <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> if pos < n : <NEWLINE> <INDENT> for j in range ( pos , n ) : <NEWLINE> <INDENT> ans += cards [ j ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL>
import numpy as np <NEWLINE> from heapq import heapify , heapreplace <NEWLINE> def solve ( stdin ) : <NEWLINE> <INDENT> n , m = stdin [ : 2 ] <NEWLINE> A = stdin [ 2 : 2 + n ] . tolist ( ) <NEWLINE> BC = stdin [ 2 + n : ] . reshape ( - 1 , 2 ) <NEWLINE> <NL> heapify ( A ) <NEWLINE> <NL> BC = sorted ( BC , key = lambda x : ( x [ 1 ] ) , reverse = True ) <NEWLINE> for b , c in BC : <NEWLINE> <INDENT> if c < A [ 0 ] : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for i in range ( b ) : <NEWLINE> <INDENT> if A [ 0 ] > c : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> heapreplace ( A , c ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> return sum ( A ) <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> stdin = np . fromstring ( open ( 0 ) . read ( ) , dtype = np . int64 , sep = <STRING> ) <NEWLINE> print ( solve ( stdin ) ) <NEWLINE> <NL> <DEDENT> def cc_export ( ) : <NEWLINE> <INDENT> from numba . pycc import CC <NEWLINE> cc = CC ( <STRING> ) <NEWLINE> cc . export ( <STRING> , <STRING> ) ( solve ) <NEWLINE> cc . compile ( ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> import sys <NEWLINE> if sys . argv [ - 1 ] == <STRING> : <NEWLINE> <INDENT> cc_export ( ) <NEWLINE> exit ( 0 ) <NEWLINE> <DEDENT> from my_module import solve <NEWLINE> main ( ) <NEWLINE> <DEDENT>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> arr = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> s = [ list ( map ( int , input ( ) . split ( ) ) ) for y in range ( M ) ] <NEWLINE> s ( key = lambda z : z [ 1 ] , reverse = True ) <NEWLINE> <NL> sum_a = 0 <NEWLINE> for a , b in s : <NEWLINE> <INDENT> arr += [ b ] * a <NEWLINE> sum_a += a <NEWLINE> if sum_a >= N : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> lst = sorted ( arr ) <NEWLINE> ans = sum ( lst [ - N : ] ) <NEWLINE> print ( ans ) <NEWLINE>
icase = 0 <NEWLINE> if icase == 0 : <NEWLINE> <INDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> d = [ ] <NEWLINE> cb = [ [ 0 ] * 2 for i in range ( m ) ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> bi , ci = map ( int , input ( ) . split ( ) ) <NEWLINE> cb [ i ] = [ ci , bi ] <NEWLINE> <DEDENT> <DEDENT> elif icase == 2 : <NEWLINE> <INDENT> n , m = 10 , 3 <NEWLINE> a = [ 1 , 4 , 5 , 5 , 7 , 8 , 13 , 33 , 52 , 100 ] <NEWLINE> cb = [ [ 30 , 4 ] , [ 10 , 3 ] , [ 4 , 1 ] ] <NEWLINE> <NL> <DEDENT> a . sort ( ) <NEWLINE> cb . sort ( reverse = True ) <NEWLINE> <NL> if cb [ 0 ] [ 0 ] <= a [ 0 ] : <NEWLINE> <INDENT> print ( sum ( a ) ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> asum = 0 <NEWLINE> isum = 0 <NEWLINE> isumm = 0 <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> isum += cb [ i ] [ 1 ] <NEWLINE> if isum > n : <NEWLINE> <INDENT> if a [ - 1 ] <= cb [ i ] [ 0 ] : <NEWLINE> <INDENT> asum += cb [ i ] [ 0 ] * ( n - isumm ) <NEWLINE> print ( asum ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ii = bisect_right ( a , cb [ i ] [ 0 ] ) <NEWLINE> asum += cb [ i ] [ 0 ] * ( ii - isumm ) <NEWLINE> asum += sum ( a [ ii : ] ) <NEWLINE> print ( asum ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT> if a [ isum - 1 ] <= cb [ i ] [ 0 ] : <NEWLINE> <INDENT> asum += cb [ i ] [ 0 ] * cb [ i ] [ 1 ] <NEWLINE> isumm = isum <NEWLINE> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ii = bisect_right ( a , cb [ i ] [ 0 ] ) <NEWLINE> asum += cb [ i ] [ 0 ] * ( ii - isumm ) <NEWLINE> asum += sum ( a [ ii : ] ) <NEWLINE> print ( asum ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> isumm = isum <NEWLINE> <NL> <DEDENT> asum += sum ( a [ isumm : ] ) <NEWLINE> <NL> print ( asum ) <NEWLINE>
n , m = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a . sort ( ) <NEWLINE> list = [ list ( map ( int , input ( ) . split ( ) ) ) for x in range ( m ) ] <NEWLINE> list . sort ( list , key = lambda x : x [ 1 ] , reverse = True ) <COMMENT> <NEWLINE> <NL> app_count = 0 <NEWLINE> for i in list : <NEWLINE> <INDENT> a += [ i [ 1 ] ] * i [ 0 ] <NEWLINE> app_count += i [ 0 ] <NEWLINE> if app_count > n : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> a . sort ( reverse = True ) <NEWLINE> <NL> print ( a [ : n ] ) <NEWLINE>
<INDENT> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <DEDENT> import heapq <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> heapq . heapify ( A ) <NEWLINE> BC = [ ] <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> B , C = map ( int , input ( ) . split ( ) ) <NEWLINE> BC . append ( ( B , C ) ) <NEWLINE> <DEDENT> BC . sort ( key = lambda x : x [ 1 ] , reverse = True ) <NEWLINE> import bisect <NEWLINE> A . sort ( ) <NEWLINE> now = 0 <NEWLINE> D = [ 0 ] * N <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> B = BC [ i ] [ 0 ] <NEWLINE> C = BC [ i ] [ 1 ] <NEWLINE> for j in range ( now , min ( now + B , N ) ) : <NEWLINE> <INDENT> D [ j ] = C <NEWLINE> <DEDENT> now += B <NEWLINE> if now > N - 1 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> a = A [ i ] <NEWLINE> d = D [ i ] <NEWLINE> if d > a : <NEWLINE> <INDENT> A [ i ] = d <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> print ( sum ( A ) ) <NEWLINE>
import heapq <NEWLINE> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> aas = list ( map ( int , input ( ) . split ( ) ) ) . sort ( ) <NEWLINE> hq = [ ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> heapq . heappush ( hq , ( - c , b ) ) <NEWLINE> <DEDENT> i = 0 <NEWLINE> while hq : <NEWLINE> <INDENT> - c , b = heapq . heappop ( hq ) <NEWLINE> for j in range ( i , min ( n , i + b ) ) : <NEWLINE> <INDENT> if aas [ j ] < c : <NEWLINE> <INDENT> aas [ j ] = c <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( sum ( aas ) ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> i = j + 1 <NEWLINE> <DEDENT> print ( sum ( aas ) ) <NEWLINE>
import heapq <NEWLINE> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> heapq . heapify ( a ) <NEWLINE> bc = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( m ) ] <NEWLINE> bc . sort ( key = lambda x : x [ 1 ] , reverse = True ) <NEWLINE> <NL> for i in range ( m ) : <NEWLINE> <INDENT> if a [ b - 1 ] >= bc [ i ] [ 1 ] : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> while cnt < bc [ i ] [ 0 ] : <NEWLINE> <INDENT> heapq . heapreplace ( a , bc [ i ] [ 1 ] ) <NEWLINE> cnt += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( sum ( a ) ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = input ( ) <NEWLINE> <NL> a = list ( a ) <NEWLINE> a [ k - 1 ] = a [ k - 1 ] . lower ( ) <NEWLINE> a = <STRING> . join ( a ) <NEWLINE> print ( a ) <NEWLINE> <NL> 127 <NEWLINE> a , b = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> if a >= 13 : <NEWLINE> <INDENT> print ( b ) <NEWLINE> <DEDENT> elif a >= 6 : <NEWLINE> <INDENT> print ( b // 2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> s = input ( ) <NEWLINE> print ( s [ : k - 1 ] + s [ k - 1 ] . lower ( ) + s [ k : ] ) <NEWLINE>
n , k = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> s = input ( ) <NEWLINE> <NL> k -= 1 <NEWLINE> <NL> if s [ k ] == <STRING> : <NEWLINE> <INDENT> s [ k ] = <STRING> <NEWLINE> <DEDENT> elif s [ k ] == <STRING> : <NEWLINE> <INDENT> s [ k ] = <STRING> <NEWLINE> <DEDENT> elif s [ k ] == <STRING> : <NEWLINE> <INDENT> s [ k ] = <STRING> <NEWLINE> <NL> <DEDENT> print ( s ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> s = list ( input ( ) . split ( ) ) <NEWLINE> <NL> print ( join ( s [ k - 1 ] . swapcase ( ) ) ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> S = str ( ) <NEWLINE> if ( S [ K ] = <STRING> ) : <NEWLINE> <INDENT> S [ K ] = <STRING> <NEWLINE> <DEDENT> elif ( S [ K ] = <STRING> ) : <NEWLINE> <INDENT> S [ K - 1 ] = <STRING> <NEWLINE> <DEDENT> elif ( S [ K ] = <STRING> ) : <NEWLINE> <INDENT> S [ K ] = <STRING> <NEWLINE> <DEDENT>
s = int ( input ( ) ) <NEWLINE> a = s % 100 <NEWLINE> b = ( ( s - a ) % 100 ) <NEWLINE> if a <= 31 and b <= 12 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a <= 12 and b <= 31 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a <= 12 and b <= 31 and a <= 31 and b <= 12 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
S = int ( input ( ) ) <NEWLINE> a = S % 100 <NEWLINE> b = ( S - ( S % 100 ) ) / 100 <NEWLINE> if b <= 12 and a <= 12 and a != 0 and b != 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif b <= 12 and a != 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a <= 12 and a != 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> s = input ( ) <NEWLINE> print ( s [ : k - 1 ] + s [ k - 1 ] . lower + s [ k : ] ) <NEWLINE>
word_S = input ( ) . split ( <STRING> ) [ - 1 ] <NEWLINE> S = list ( word_S ) <NEWLINE> change_K = int ( input ( ) ) <NEWLINE> word1 = <STRING> <NEWLINE> for i in range ( change_K - 1 ) : <NEWLINE> <INDENT> word1 = word1 + S [ i ] <NEWLINE> <DEDENT> word2 = S [ change_K - 1 ] <NEWLINE> word3 = <STRING> <NEWLINE> count = 0 <NEWLINE> while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> word3 = word3 + S [ change_K + count ] <NEWLINE> count += 1 <NEWLINE> <DEDENT> except IndexError : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> word2 = word2 . swapcase ( ) <NEWLINE> print ( word1 + word2 + word3 ) <NEWLINE>
x = input ( ) . split ( <STRING> ) <NEWLINE> command = x [ 1 ] <NEWLINE> N = x [ 0 ] <NEWLINE> N += command . lower ( x [ 1 ] ) <NEWLINE> print ( N ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> s = input ( ) <NEWLINE> s [ k - 1 ] = chr ( ord ( s [ k - 1 ] ) - ord ( <STRING> ) + ord ( <STRING> ) ) <NEWLINE> for c in s : <NEWLINE> <INDENT> print ( c , end = <STRING> ) <NEWLINE> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> S = [ ] <NEWLINE> S [ K - 1 ] = S [ K - 1 ] . lower ( ) <NEWLINE> print ( S ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> s = str ( input ( ) ) <NEWLINE> if s [ k - 1 ] == <STRING> : <NEWLINE> <INDENT> s [ k - 1 ] = <STRING> <NEWLINE> <DEDENT> elif s [ k - 1 ] == <STRING> : <NEWLINE> <INDENT> s [ k - 1 ] = <STRING> <NEWLINE> <DEDENT> elif s [ k - 1 ] == <STRING> : <NEWLINE> <INDENT> s [ k - 1 ] = <STRING> <NEWLINE> <DEDENT> print ( s ) <NEWLINE>
b = int ( input ( ) ) <NEWLINE> c = input ( ) <NEWLINE> c = c . replace ( c [ b - 1 ] , c [ b - 1 ] . lower ( ) ) <NEWLINE> print ( c ) <NEWLINE>
n , k = tuple ( int , input ( ) . split ( ) ) <NEWLINE> s = list ( input ( ) ) <NEWLINE> s [ k - 1 ] = s [ k - 1 ] . lower ( ) <NEWLINE> print ( <STRING> . join ( s ) ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> S = list ( input ( ) ) <NEWLINE> S [ K - 1 ] = S [ K - 1 ] . lower ( ) <NEWLINE> print ( sum ( S ) ) <NEWLINE>
n , k = map ( int , input ( <STRING> ) . split ( <STRING> ) ) <NEWLINE> s = input ( <STRING> ) <NEWLINE> if len ( s ) = n : <NEWLINE> <INDENT> slist = lis ( ( s ) ) <NEWLINE> swapcase ( slist [ k - 1 ] ) <NEWLINE> <NL> <DEDENT> for i in range ( 0 , len ( slist ) - 1 ) : <NEWLINE> <INDENT> print ( slist [ i ] , end = <STRING> ) <NEWLINE> <DEDENT>
N = int ( input ( <STRING> ) ) <NEWLINE> K = int ( input ( <STRING> ) ) <NEWLINE> s = str ( input ( <STRING> ) ) <NEWLINE> print ( s [ 0 : K - 1 ] + s [ K - 1 ] . lower ( ) + s [ K : ] ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if S [ K - 1 ] == <STRING> : rep = <STRING> <NEWLINE> elif S [ K - 1 ] == <STRING> : rep = <STRING> <NEWLINE> else : rep = <STRING> <NEWLINE> <NL> print ( S [ : K ] + rep + S [ K + 1 : ] ) <NEWLINE>
n , k = input ( ) . split ( ) <NEWLINE> s = input ( ) <NEWLINE> <NL> s = list ( s ) <NEWLINE> s [ k - 1 ] = s [ k - 1 ] . lower ( ) <NEWLINE> s = <STRING> . join ( s ) <NEWLINE> print ( s ) <NEWLINE>
small = [ <STRING> , <STRING> , <STRING> ] <NEWLINE> capital = [ <STRING> , <STRING> , <STRING> ] <NEWLINE> <NL> tmp = input ( ) . split ( <STRING> ) <NEWLINE> N = int ( tmp [ 0 ] ) <NEWLINE> K = int ( tmp [ 1 ] ) <NEWLINE> str = input ( ) <NEWLINE> <NL> str [ K ] = small [ capital . index ( str [ K ] ) ] <NEWLINE> <NL> print ( str ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> S = input ( ) <NEWLINE> <NL> S [ K - 1 ] = S [ k - 1 ] . lower ( ) <NEWLINE> print ( S ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> s = list ( map ( str , input ( ) . split ( ) ) ) <NEWLINE> k = k - 1 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> if i != k : <NEWLINE> <INDENT> print ( s [ i ] , end = <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = s [ i ] . lower ( ) <NEWLINE> print ( x , end = <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> s = input ( ) <NEWLINE> <NL> print ( s [ : k - 1 ] + s . upper [ k - 1 ] + s [ k : ] ) <NEWLINE>
s = input ( ) <NEWLINE> s_f = int ( s [ 0 ] + s [ 1 ] ) <NEWLINE> s_b = int ( s [ 2 ] + s [ 3 ] ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> if s_f == 0 or s_b == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif s_f <= 12 and s_b <= 12 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif s_f <= 12 and s_b > 12 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif s_f > 12 and s_b <= 12 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif s_f > 12 and s_b > 12 <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT>
S = input ( ) <NEWLINE> f = int ( S [ 0 ] + S [ 1 ] ) <NEWLINE> b = int ( S [ 2 ] + S [ 3 ] ) <NEWLINE> <NL> def judge ( int ) : <NEWLINE> <INDENT> if 1 <= int <= 12 <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> <DEDENT> ref = [ judge ( f ) , judge ( b ) ] <NEWLINE> <NL> if ref == [ 1 , 1 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif ref == [ 0 , 1 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif ref == [ 1 , 0 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
YYMM = False <NEWLINE> MMYY = False <NEWLINE> f = input ( ) <NEWLINE> h1 = f [ 0 ] + f [ 1 ] <NEWLINE> h2 = f [ 2 ] + f [ 3 ] <NEWLINE> <NL> if 1 <= h2 <= 12 : <NEWLINE> <INDENT> YYMM = True <NEWLINE> <DEDENT> if 1 <= h1 <= 12 : <NEWLINE> <INDENT> MMYY = True <NEWLINE> <NL> <DEDENT> def ret ( c1 , c2 ) : <NEWLINE> <INDENT> if c1 and c2 : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> elif c1 : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> elif c2 : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ret ( YYMM , MMYY ) ) <NEWLINE>
try : <NEWLINE> <INDENT> s1 = ( input ( <STRING> ) ) <NEWLINE> if len ( s1 ) >= 4 : <NEWLINE> <INDENT> raise ValueError <NEWLINE> <NL> <DEDENT> check = list ( ( s1 ) ) <NEWLINE> assert bool ( int ( check [ 0 ] + check [ 1 ] ) <= 12 ) != bool ( int ( check [ 2 ] + check [ 3 ] ) <= 12 ) <NEWLINE> if int ( check [ 0 ] + check [ 1 ] ) <= 12 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif int ( check [ 2 ] + check [ 3 ] ) <= 12 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> except AssertionError : <NEWLINE> <INDENT> if int ( check [ 0 ] + check [ 1 ] ) <= 12 and int ( check [ 2 ] + check [ 3 ] ) <= 12 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT>
a = input ( a ) <NEWLINE> b = int ( a [ 0 ] + a [ 1 ] ) <NEWLINE> c = int ( a [ 2 ] + a [ 3 ] ) <NEWLINE> if 1 <= b <= 12 and 1 <= c <= 12 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif b > 12 : <NEWLINE> <INDENT> if c > 12 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif 1 <= c <= 12 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> elif c > 12 : <NEWLINE> <INDENT> if b > 12 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif 1 <= b <= 12 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
<NL> n1 , n2 = int ( n [ : 2 ] ) , int ( n [ 2 : ] ) <NEWLINE> if ( n1 > 12 and n2 > 12 ) or ( n1 == 0 and n2 == 0 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif ( n1 != 0 and n1 <= 12 ) and ( n2 != 0 and n2 <= 12 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif n1 != 0 and n1 <= 12 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif n2 != 0 and n2 <= 12 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT>
s = raw_input ( ) <NEWLINE> <NL> a = int ( s [ : 2 ] ) <NEWLINE> b = int ( s [ 2 : ] ) <NEWLINE> <NL> if 0 < a < 13 : <NEWLINE> <INDENT> if 0 < b < 13 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if - 1 < b < 13 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> n = int ( input ( ) ) <NEWLINE> a = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> s , p = map ( str , input ( ) . split ( ) ) <NEWLINE> p = int ( p ) <NEWLINE> a . append ( ( s , p , i + 1 ) ) <NEWLINE> <COMMENT> <NL> <DEDENT> a . sort ( key = lambda x : x [ 1 ] , reverse = True ) <NEWLINE> <COMMENT> <NL> a . sort ( key = lambda x : x [ 0 ] ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> print ( a [ i ] [ 2 ] ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> <NL> b = int ( s [ : 2 ] ) <NEWLINE> a = int ( s [ 2 : ] ) <NEWLINE> <NL> print ( b ) <NEWLINE> print ( a ) <NEWLINE> <NL> def yorm ( i ) : <NEWLINE> <INDENT> flag = <STRING> <NEWLINE> if 0 < i < 12 : <NEWLINE> <INDENT> flag = <STRING> <NEWLINE> <DEDENT> elif i < 100 : <NEWLINE> <INDENT> flag = <STRING> <NEWLINE> <DEDENT> return flag <NEWLINE> <NL> <DEDENT> ans = bf + af <NEWLINE> if len ( ans ) != 4 : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <DEDENT> if ans == <STRING> : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <DEDENT> if ans == <STRING> : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
S = int ( input ( ) ) <NEWLINE> a = s // 100 <NEWLINE> b = s % 100 <NEWLINE> if a > 0 and a <= 12 : <NEWLINE> <INDENT> if b > 0 and b <= 12 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if b > 0 and b <= 12 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
def f ( y , m ) : <NEWLINE> <INDENT> if y in range ( 1 , 13 ) and m in range ( 1 , 13 ) : <NEWLINE> <INDENT> return <STRING> <NEWLINE> if m in range ( 1 , 13 ) : <NEWLINE> return <STRING> <NEWLINE> if y in range ( 1 , 13 ) : <NEWLINE> return <STRING> <NEWLINE> return <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> S = input ( ) <NEWLINE> y , m = int ( S [ : 2 ] ) , int ( S [ 2 : ] ) <NEWLINE> print ( f ( y , m ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> K = int ( input ( ) ) <NEWLINE> result = 0 <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> prob = 1 <NEWLINE> count = i <NEWLINE> while count < K : <NEWLINE> <INDENT> prob *= 0.5 <NEWLINE> count *= 2 <NEWLINE> <DEDENT> result += prob / N <NEWLINE> <DEDENT> print ( result ) <NEWLINE>
D = int ( input ( ) ) <NEWLINE> P = int ( input ( ) ) <NEWLINE> ans = 0.0 <NEWLINE> def func ( i ) : <NEWLINE> <INDENT> t = 0 <NEWLINE> while ( i < P ) : <NEWLINE> <INDENT> i *= 2 <NEWLINE> t += 1 <NEWLINE> <DEDENT> return t <NEWLINE> <NL> <DEDENT> for i in range ( 1 , D + 1 ) : <NEWLINE> <INDENT> ans += float ( ( 1 / D ) ) * float ( ( ( 1 / 2 ) ** func ( i ) ) ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
n , k = map ( int , input ( ) . strip ( ) . split ( ) ) <NEWLINE> c = 0 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if n > k : <NEWLINE> <INDENT> c += 1 / n <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> while i < k : <NEWLINE> <INDENT> i *= 2 <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> c += 1 / N * ( 1 / 2 ) ** cnt <NEWLINE> <DEDENT> <DEDENT> print ( c ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> p = 0 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if i < k : <NEWLINE> <INDENT> count = 1 <NEWLINE> while i * count < k : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> p += 0.5 ^ float ( count ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> p += 1 <NEWLINE> <DEDENT> <DEDENT> print ( p / n ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> for i in range ( 1 , n - 1 ) : <NEWLINE> <INDENT> p = i <NEWLINE> r = 1 <NEWLINE> while < k : <NEWLINE> <INDENT> p *= 2 <NEWLINE> r /= 2 <NEWLINE> <DEDENT> ans += r <NEWLINE> <NL> <DEDENT> ans /= n <NEWLINE> <NL> print ( ans ) <NEWLINE>
N , K = list ( map ( int , input ( ) . rstrip ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> p = 1 / N <NEWLINE> if j < K : <NEWLINE> <INDENT> while i < K : <NEWLINE> <INDENT> i *= 2 <NEWLINE> p *= 0.5 <NEWLINE> <DEDENT> <DEDENT> ans += p <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> j = 0 <NEWLINE> if i < k : <NEWLINE> <INDENT> while i * ( 2 ** j ) < k : <NEWLINE> <INDENT> j += 1 <NEWLINE> <DEDENT> ans += ( 1 / n ) * / ( 2 ** j ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += ( 1 / n ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from collections import deque <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> <NL> <NL> vlist = [ [ ] ] * N <NEWLINE> <NL> for i in range ( N - 1 ) : <NEWLINE> <INDENT> a , b , w = map ( int , input ( ) . split ( ) ) <NEWLINE> a -= 1 <NEWLINE> b -= 1 <NEWLINE> vlist [ a ] . append ( b , w ) <NEWLINE> vlist [ b ] . append ( a , w ) <NEWLINE> <NL> <DEDENT> ans = [ - 1 ] * N <NEWLINE> q = deque ( ) <NEWLINE> <NL> ans [ 0 ] = 0 <NEWLINE> q . append ( 0 ) <NEWLINE> <NL> while q : <NEWLINE> <INDENT> new = q . popleft ( ) <NEWLINE> for node , weight in vlist [ new ] : <NEWLINE> <INDENT> if ans [ node ] != - 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> ans [ node ] = ( ans [ new ] + weight ) % 2 <NEWLINE> q . append ( node ) <NEWLINE> <NL> <DEDENT> <DEDENT> for i in ans : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT>
from collections import deque <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> graph = [ [ ] for _ in range ( N ) ] <NEWLINE> for _ in range ( N - 1 ) : <NEWLINE> <INDENT> u , v , w = map ( int , input ( ) . split ( ) ) <NEWLINE> u , v , w = u - 1 , v - 1 , w % 2 <NEWLINE> graph [ u ] . append ( [ v , w ] ) <NEWLINE> graph [ v ] . append ( [ u , w ] ) <NEWLINE> <NL> <DEDENT> colors = [ - 1 for _ in range ( N ) ] <NEWLINE> stack = deque ( ) <NEWLINE> stack . append ( 0 ) <NEWLINE> colors [ 0 ] = 0 <NEWLINE> <NL> while stack : <NEWLINE> <INDENT> n = stack . pop ( ) <NEWLINE> for _next , w in graph [ n ] : <NEWLINE> <INDENT> if colors [ _next ] != - 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> colors [ _next ] = ( colors [ n ] + w ) % 2 <NEWLINE> stack . append ( [ _next ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> for c in colors : <NEWLINE> <INDENT> print ( c ) <NEWLINE> <DEDENT>
( n , ) , * t = [ map ( int , t , split ( ) ) for t in open ( 0 ) ] <NEWLINE> * e , = eval ( <STRING> * - ~ n ) <NEWLINE> q = [ ( 1 , 0 ) ] <NEWLINE> f = [ - 1 ] * n <NEWLINE> for v , w , c in t = : e [ v ] += ( w , c ) , ; e [ w ] += ( v , c ) , <NEWLINE> for v , c in q : <NEWLINE> <INDENT> f [ v - 1 ] = c % 2 <NEWLINE> for w , d in e [ v ] : q += [ ( w , c + d ) ] * ( f [ w - 1 ] < 0 ) <NEWLINE> <DEDENT> print ( * f ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> N = int ( input ( ) ) <NEWLINE> <NL> Graph = [ [ ] for _ in range ( N ) ] <NEWLINE> dist = [ ] * ( N ) <NEWLINE> <NL> for i in range ( N - 1 ) : <NEWLINE> <INDENT> u , v , w = map ( int , input ( ) . split ( ) ) <NEWLINE> u -= 1 <NEWLINE> v -= 1 <NEWLINE> Graph [ u ] . append ( ( v , w ) ) <NEWLINE> Graph [ v ] . append ( ( u , w ) ) <NEWLINE> <NL> <NL> <DEDENT> def func ( fromE , now , length ) : <NEWLINE> <INDENT> dist [ now ] = length <NEWLINE> <NL> for i in range ( len ( Graph [ now ] ) ) : <NEWLINE> <INDENT> target = Graph [ now ] [ i ] [ 0 ] <NEWLINE> lengt = Graph [ now ] [ i ] [ 1 ] <NEWLINE> <NL> if target == fromE : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <DEDENT> func ( now , target , dist [ now ] + lengt ) <NEWLINE> <NL> <DEDENT> <DEDENT> func ( - 1 , 0 , 0 ) <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> if dist [ i ] % 2 == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> <DEDENT>
from collections import deque <NEWLINE> <NL> graph = [ [ ] for _ in range ( N + 1 ) ] <NEWLINE> <NL> N , M = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for _ in range ( M ) : <NEWLINE> <INDENT> a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> graph [ a ] . append ( b ) <NEWLINE> graph [ b ] . append ( a ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> seen = [ False ] * ( N + 1 ) <NEWLINE> <NL> <NL> count = 0 <NEWLINE> <NL> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> if seen [ i ] == False : <NEWLINE> <INDENT> seen [ i ] = True <NEWLINE> S = deque ( [ i ] ) <NEWLINE> <NL> while S : <NEWLINE> <INDENT> v = S . popleft ( ) <NEWLINE> <COMMENT> <NL> for i in graph [ v ] : <NEWLINE> <INDENT> if seen [ i ] == False : <NEWLINE> <INDENT> seen [ i ] = True <NEWLINE> S . append ( i ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> par = [ i for i in range ( N + 1 ) ] <NEWLINE> size = [ 1 for _ in range ( N + 1 ) ] <NEWLINE> <NL> def find ( x ) : <NEWLINE> <INDENT> if par [ x ] == x : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> par [ x ] = find ( par [ x ] ) <NEWLINE> return par [ x ] <NEWLINE> <NL> <DEDENT> <DEDENT> def unite ( x , y ) : <NEWLINE> <INDENT> x = find ( x ) <NEWLINE> y = find ( y ) <NEWLINE> if x == y : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> par [ x ] = y <NEWLINE> size [ y ] += size [ x ] <NEWLINE> size [ x ] = 0 <NEWLINE> <NL> <DEDENT> for i in range ( M ) : <NEWLINE> <INDENT> x , y , z = map ( int , input ( ) . split ( ) ) <NEWLINE> unite ( x , y ) <NEWLINE> <NL> <DEDENT> Ans = 0 <NEWLINE> for j in size [ 1 : ] : <NEWLINE> <INDENT> if j != 0 : <NEWLINE> <INDENT> Ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( Ans ) <NEWLINE>
class UnionFind ( ) : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . par = [ i for i in range ( n ) ] <NEWLINE> self . rank = [ 0 ] * n <NEWLINE> <NL> <DEDENT> def root ( self , x ) : <NEWLINE> <INDENT> if self . par [ x ] == x : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . par [ x ] = self . root ( self . par [ x ] ) <NEWLINE> return self . par [ x ] <NEWLINE> <NL> <DEDENT> <DEDENT> def union ( self , x , y ) : <NEWLINE> <INDENT> x = self . root ( x ) <NEWLINE> y = self . root ( y ) <NEWLINE> if x != y : <NEWLINE> <INDENT> if self . rank [ x ] < self . rank [ y ] : <NEWLINE> <INDENT> self . par [ x ] = y <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . par [ y ] = x <NEWLINE> if self . rank [ x ] == self . rank [ y ] : <NEWLINE> <INDENT> self . rank [ x ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> def samegrp ( self , x , y ) : <NEWLINE> <INDENT> return self . root ( x ) == self . root ( y ) <NEWLINE> <NL> <DEDENT> <DEDENT> from mymodules . somedatastrs import UnionFind <NEWLINE> <NL> n , m = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> A = UnionFind ( n ) <NEWLINE> ans = n <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> x , y , _ = [ int ( z ) - 1 for z in input ( ) . split ( ) ] <NEWLINE> if not A . samegrp ( x , y ) : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <DEDENT> A . union ( x , y ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = 0 <NEWLINE> if N == K : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> for _ in range ( N - K ) : <NEWLINE> <INDENT> ans + + <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
a , b = map ( in , input ( ) . split ( ) ) <NEWLINE> print ( a - b + 1 ) <NEWLINE>
print ( int ( input ( ) ) + 1 ) <NEWLINE>
[ N , K ] = L ( ) <NEWLINE> <NL> def L ( ) : <NEWLINE> <INDENT> return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <DEDENT> print ( N - K + 1 ) <NEWLINE>
a , b = map ( int , input ( ) ) <NEWLINE> print ( a - b + 1 ) <NEWLINE>
cnt = 0 <NEWLINE> for r in range ( N // R + 1 ) : <NEWLINE> <INDENT> for g in range ( N // G + 1 ) : <NEWLINE> <INDENT> if ( N - r * R - g * G ) < 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if ( N - r * R - g * G ) % B == 0 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
R , G , B , N = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> for r in range ( N // R + 1 ) : <NEWLINE> <INDENT> for g in range ( tmp // G + 1 ) : <NEWLINE> <INDENT> check = ( tmp - R * r - G * g ) <NEWLINE> if check % B == 0 and check > 0 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = [ input ( ) for i in range ( n ) ] <NEWLINE> <NL> ab = 0 <NEWLINE> ba = 0 <NEWLINE> c2 = 0 <NEWLINE> c3 = 0 <NEWLINE> for x in s : <NEWLINE> <INDENT> if <STRING> in x : <NEWLINE> <INDENT> ab += x . count ( <STRING> ) <NEWLINE> <DEDENT> if x [ - 1 ] == <STRING> and x [ 0 ] == <STRING> : <NEWLINE> <INDENT> ba = 1 <NEWLINE> <DEDENT> if x [ - 1 ] == <STRING> and x [ 0 ] != <STRING> : <NEWLINE> <INDENT> c2 += 1 <NEWLINE> <DEDENT> if x [ - 1 ] != <STRING> and x [ 0 ] == <STRING> : <NEWLINE> <INDENT> c3 += 1 <NEWLINE> <DEDENT> <DEDENT> if ba > 0 : <NEWLINE> <INDENT> if c2 + c3 > 0 : <NEWLINE> <INDENT> ans = ab + ba + min ( c2 , c3 ) <NEWLINE> <DEDENT> else : <COMMENT> <NEWLINE> <INDENT> ans = ab + ba - 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S = [ input ( ) for _ in range ( N ) ] <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> include = 0 <NEWLINE> sb = 0 <NEWLINE> fa = 0 <NEWLINE> sbfa = 0 <NEWLINE> for s in S : <NEWLINE> <INDENT> if <STRING> in s : <NEWLINE> <INDENT> include += 1 <NEWLINE> <DEDENT> if s [ 0 ] == <STRING> and s [ - 1 ] == <STRING> : <NEWLINE> <INDENT> sbfa += 1 <NEWLINE> <DEDENT> elif s [ 0 ] == <STRING> : <NEWLINE> <INDENT> sb += 1 <NEWLINE> <DEDENT> elif s [ - 1 ] == <STRING> : <NEWLINE> <INDENT> fa += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> def calc_comb ( sb , fa , sbfa ) : <NEWLINE> <INDENT> ans = 0 <NEWLINE> if sbfa > 0 : <NEWLINE> <INDENT> ans += sbfa - 1 <NEWLINE> if sb > 0 : <NEWLINE> <INDENT> sb -= 1 <NEWLINE> ans += 1 <NEWLINE> <DEDENT> if fa > 0 : <NEWLINE> <INDENT> fa -= 1 <NEWLINE> ans += 1 <NEWLINE> <DEDENT> <DEDENT> ans += min ( sb , fa ) <NEWLINE> <NL> <DEDENT> print ( include + calc_comb ( sb , fa , sbfa ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( 1 , int ( n ** 0.5 ) + 1 ) : <NEWLINE> <INDENT> if n % i == 0 and n // ( i - 1 ) == n % ( i - 1 ) : <NEWLINE> <INDENT> ans += i - 1 <NEWLINE> <DEDENT> m = n // i - 1 <NEWLINE> if m > 0 and n % i == 0 and n // m == n % m : <NEWLINE> <INDENT> ans += m <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , 1250000 ) : <NEWLINE> <INDENT> if ( ( ( N - i ) / i ) . is_integer ( ) and N // ( ( N - i ) / i ) == N % ( ( N - i ) / i ) ) : <NEWLINE> <COMMENT> <NL> <INDENT> ans += ( ( N - i ) // i ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from collections import deque <NEWLINE> <NL> def main ( ) : <NEWLINE> h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ list ( input ( ) ) for _ in range ( h ) ] <NEWLINE> <INDENT> B = [ ] <NEWLINE> <NL> for i , a in enumerate ( A ) : <NEWLINE> <INDENT> for j , b in enumerate ( a ) : <NEWLINE> <INDENT> if b == <STRING> : <NEWLINE> <INDENT> B . append ( ( i , j ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> dxy = [ [ 1 , 0 ] , [ - 1 , 0 ] , [ 0 , 1 ] , [ 0 , - 1 ] ] <NEWLINE> <NL> stack = deque ( B ) <NEWLINE> darked = len ( stack ) <NEWLINE> targetd = h * w <NEWLINE> count = 0 <NEWLINE> <NL> while darked < targetd : <NEWLINE> <INDENT> nextd = deque ( [ ] ) <NEWLINE> <NL> while stack : <NEWLINE> <INDENT> x , y = stack . popleft ( ) <NEWLINE> for dx , dy in dxy : <NEWLINE> <INDENT> X = x + dx <NEWLINE> Y = y + dy <NEWLINE> if not ( 0 <= X < h ) or not ( 0 <= Y < w ) : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if A [ X ] [ Y ] == <STRING> : <NEWLINE> <INDENT> A [ X ] [ Y ] = <STRING> <NEWLINE> nextd . append ( ( X , Y ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> count += 1 <NEWLINE> stack = nextd <NEWLINE> darked += len ( stack ) <NEWLINE> <DEDENT> print ( count ) <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE>
a , b , t = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( int ( ( ( t + 0.5 ) // a * b ) ) <NEWLINE>
a , b , t = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( t // a * b ) <NEWLINE> debug_pri <NEWLINE>
a , b , t = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = 0 <NEWLINE> T = A <NEWLINE> while ( T <= t ) : <NEWLINE> <INDENT> ans += B <NEWLINE> T += A <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
using System ; <NEWLINE> using System . Runtime . InteropServices ; <NEWLINE> <NL> namespace ConsoleApp2 <NEWLINE> { <NEWLINE> <INDENT> class Program <NEWLINE> { <NEWLINE> <INDENT> static void Main ( string [ ] args ) <NEWLINE> { <NEWLINE> <INDENT> int a , b , t ; <NEWLINE> string [ ] str = Console . ReadLine ( ) . Split ( <STRING> ) ; <NEWLINE> a = int . Parse ( str [ 0 ] ) ; <NEWLINE> b = int . Parse ( str [ 1 ] ) ; <NEWLINE> t = int . Parse ( str [ 2 ] ) ; <NEWLINE> Console . WriteLine ( b * ( t / a ) ) ; <NEWLINE> <DEDENT> } <NEWLINE> <DEDENT> } <NEWLINE> <DEDENT> } <NEWLINE>
a , b , t = map ( int ( input ( ) . split ( ) ) ) <NEWLINE> n = int ( t / a ) <NEWLINE> print ( n * b ) <NEWLINE>
A , B , T = map ( input ( ) . split ( ) ) <NEWLINE> print ( T // A * B ) <NEWLINE>
a , b , t = map ( int , input ( ) . split ) <NEWLINE> <NL> print ( b * ( a // t ) ) <NEWLINE>
n = input ( ) . split ( ) <NEWLINE> ans = int ( int ( n [ 2 ] + 0.5 ) / n [ 1 ] ) * n [ 1 ] <NEWLINE> print ( ans ) <NEWLINE>
a , b , t = map ( int , input ( ) , split ( ) ) <NEWLINE> print ( ( ( t + 1 / 2 ) // a ) * b ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> a , b , t = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( t + 0.51 , 1 ) : <NEWLINE> <INDENT> if i % a == 0 : <NEWLINE> <INDENT> ans += b <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <DEDENT> main ( ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> v = [ ] <NEWLINE> c = [ ] <NEWLINE> x = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> v [ i ] = int ( input ( ) ) <NEWLINE> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> c [ i ] = int ( input ( ) ) <NEWLINE> x [ i ] = v [ i ] - c [ i ] <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> while x [ i ] > 0 : <NEWLINE> <INDENT> ans += x [ i ] <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
input ( ) <NEWLINE> v = list ( map ( int , input ( ) . split ( ) ) <NEWLINE> c = list ( map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ max ( 0 , i - j ) for i , j in zip ( v , c ) ] <NEWLINE> print ( sum ( a ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> v = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c = list ( map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> m = 0 <NEWLINE> <NL> for i in range ( len ( v ) ) : <NEWLINE> <INDENT> if v [ i ] > c [ i ] : <NEWLINE> <INDENT> m += v [ i ] - c [ i ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( m ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> k = 0 <NEWLINE> v = [ map ( int , input ( ) . split ( ) ) ] <NEWLINE> c = [ map ( int , input ( ) . split ( ) ) ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if ( v [ i ] - c [ i ] ) > 0 : <NEWLINE> <INDENT> k += ( v [ i ] - c [ i ] ) <NEWLINE> <DEDENT> <DEDENT> print ( k ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> v = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> if v [ i ] > c [ i ] : <NEWLINE> <INDENT> ans += v [ i ] - c [ i ] <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> from fractions import gcd <NEWLINE> <NL> <NL> class SegmentTree ( ) : <NEWLINE> <INDENT> _data = [ ] <NEWLINE> _offset = 0 <NEWLINE> _size = 0 <NEWLINE> <NL> def __init__ ( self , size ) : <NEWLINE> <INDENT> _size = size <NEWLINE> t = 1 <NEWLINE> while t < size : <NEWLINE> <INDENT> t *= 2 <NEWLINE> <DEDENT> self . _offset = t - 1 <NEWLINE> self . _data = [ 0 ] * ( t * 2 - 1 ) <NEWLINE> <NL> <DEDENT> def update_all ( self , iterable ) : <NEWLINE> <INDENT> self . _data [ self . _offset : self . _offset + self . _size ] = iterable <NEWLINE> for i in range ( self . _offset - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> self . _data [ i ] = gcd ( self . _data [ i * 2 + 1 ] , self . _data [ i * 2 + 2 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> def update ( self , index , value ) : <NEWLINE> <INDENT> i = self . _offset + index <NEWLINE> self . _data [ i ] = value <NEWLINE> while i >= 1 : <NEWLINE> <INDENT> i = ( i - 1 ) // 2 <NEWLINE> self . _data [ i ] = gcd ( self . _data [ i * 2 + 1 ] , self . _data [ i * 2 + 2 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> def query ( self , start , stop ) : <NEWLINE> <INDENT> result = 0 <NEWLINE> l = start + self . _offset <NEWLINE> r = stop + self . _offset <NEWLINE> while l < r : <NEWLINE> <INDENT> if l & 1 == 0 : <NEWLINE> <INDENT> result = gcd ( result , self . _data [ l ] ) <NEWLINE> <DEDENT> if r & 1 == 0 : <NEWLINE> <INDENT> result = gcd ( result , self . _data [ r - 1 ] ) <NEWLINE> <DEDENT> l = l // 2 <NEWLINE> r = ( r - 1 ) // 2 <NEWLINE> <DEDENT> return result <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> st = SegmentTree ( N ) <NEWLINE> st . update_all ( A ) <NEWLINE> <NL> result = st . query ( 1 , N ) <NEWLINE> for i in range ( 1 , N - 1 ) : <NEWLINE> <INDENT> result = max ( result , gcd ( st . query ( 0 , i ) , st . query ( i + 1 , N ) ) ) <NEWLINE> <DEDENT> result = max ( result , st . query ( 0 , N - 1 ) ) <NEWLINE> print ( result ) <NEWLINE>
import math <NEWLINE> from functools import reduce <NEWLINE> <NL> def gcd ( numbers ) : <NEWLINE> <INDENT> return reduce ( math . gcdm numbers ) <NEWLINE> <NL> <DEDENT> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = [ ] <NEWLINE> <NL> if len ( A ) == 1 : <NEWLINE> <INDENT> ans . append ( A [ 0 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans . append ( gcd ( A [ 1 : ] ) ) <NEWLINE> ans . append ( gcd ( A [ : N ] ) ) <NEWLINE> <NL> for i in range ( 1 , N - 1 ) : <NEWLINE> <INDENT> l = [ ] <NEWLINE> l . append ( gcd ( A [ : i ] ) ) <NEWLINE> l . append ( gcd ( A [ i + 1 : ] ) ) <NEWLINE> ans . append ( gcd ( l ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( max ( ans ) ) <NEWLINE>
import math <NEWLINE> from itertools import accumulate <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> fromleft = list ( accumulate ( a , math . gcd ) ) <NEWLINE> fromright = list ( accumulate ( a [ : : - 1 ] , math . gcd ) ) . reverse ( ) <NEWLINE> <NL> gcd = [ ] <NEWLINE> <NL> gcd . append ( fromright [ 1 ] ) <NEWLINE> for i in range ( 1 , n - 1 ) : <NEWLINE> <INDENT> gcd . append ( math . gcd ( fromleft [ i - 1 ] , fromright [ i + 1 ] ) ) <NEWLINE> <DEDENT> gcd . append ( fromleft [ n - 2 ] ) <NEWLINE> <NL> print ( max ( gcd ) ) <NEWLINE>
import collections <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> <NL> As = [ int ( item ) for item in input ( ) . split ( ) ] <NEWLINE> <NL> cnt = 0 <NEWLINE> <NL> Bs = collections . deque ( ) <NEWLINE> <NL> min1 = 1000000000000 <NEWLINE> <NL> for i in As : <NEWLINE> <NL> <INDENT> if As < 0 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <NL> <DEDENT> Bs . append ( abs ( i ) ) <NEWLINE> <NL> mim1 = min ( min1 , abs ( i ) ) <NEWLINE> <NL> <NL> <NL> <DEDENT> if cnt % 2 = 0 : <NEWLINE> <NL> <INDENT> print ( sum ( list ( Bs ) ) ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <NL> <INDENT> print ( sum ( list ( Bs ) ) - min1 * 2 ) <NEWLINE> <DEDENT>
from bisect import bisect_left , bisect , bisect_right <NEWLINE> import sys <NEWLINE> <NL> icase = 1 <NEWLINE> if icase == 0 : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <DEDENT> a . sort ( ) <NEWLINE> ii = bisect ( a , 0 ) <NEWLINE> <NL> if ii == n : <NEWLINE> <INDENT> if ii % 2 == 0 : <NEWLINE> <INDENT> asum = - sum ( a ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> asum = - sum ( a [ 0 : ii - 1 ] ) + a [ ii - 1 ] <NEWLINE> <DEDENT> print ( asum ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> if ii % 2 == 0 : <NEWLINE> <INDENT> asum = - sum ( a [ 0 : ii ] ) + sum ( a [ ii : ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if - a [ ii - 1 ] < a [ ii ] : <NEWLINE> <INDENT> d = a [ ii - 1 ] + a [ ii ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d = - a [ ii - 1 ] - a [ ii ] <NEWLINE> <DEDENT> asum = - sum ( a [ 0 : ii - 1 ] ) + d + sum ( a [ ii + 1 : ] ) <NEWLINE> <NL> <DEDENT> print ( asum ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> s , cnt = [ 0 ] * n , 0 <NEWLINE> for i in a : <NEWLINE> <INDENT> s [ i ] = abs ( i ) <NEWLINE> if i < 0 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> if cnt % 2 : <NEWLINE> <INDENT> print ( sum ( s ) - 2 * min ( s ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( sum ( s ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> print ( <STRING> if A <= 8 and B <= 8 else <STRING> ) <NEWLINE>
a , b , c = map ( int , input . rstrip ( ) . split ( <STRING> ) ) <NEWLINE> if ( a < c < b ) or ( b < c < a ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> s = str ( input ( ) ) <NEWLINE> k = int ( input ( ) ) <NEWLINE> wordn = <STRING> <NEWLINE> w = s [ k - 1 ] <NEWLINE> for i in s : <NEWLINE> <INDENT> if w != i : <NEWLINE> <INDENT> word += <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> word += w <NEWLINE> <DEDENT> <DEDENT> print ( word ) <NEWLINE>
n = input ( ) <NEWLINE> s = input ( ) <NEWLINE> i = input ( ) <NEWLINE> <NL> l = [ ] <NEWLINE> for i , c in enumerate ( s ) : <NEWLINE> <INDENT> l . append ( * if c != s [ i - 1 ] else c ) <NEWLINE> <NL> <DEDENT> <STRING> . join ( l ) <NEWLINE> <NL> print ( l ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S = list ( input ( ) ) <NEWLINE> K = int ( input ( ) ) <NEWLINE> for i in S : <NEWLINE> <INDENT> if s [ i - 1 ] != s [ k ] : <NEWLINE> <INDENT> s [ i - i ] = <STRING> <NEWLINE> <DEDENT> <DEDENT> print ( S ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> k = int ( input ( ) ) <NEWLINE> ss = s [ k - 1 ] <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> if s [ i ] != ss : <NEWLINE> <INDENT> s [ i ] = <STRING> <NEWLINE> <DEDENT> <DEDENT> print ( s ) <NEWLINE>
_ = input ( ) <NEWLINE> S = input ( ) . lstrip ( <STRING> ) . rstrip ( <STRING> ) <NEWLINE> n = len ( S ) <NEWLINE> <NL> x = 0 <NEWLINE> y = S . count ( <STRING> ) <NEWLINE> c = min ( n - y , y ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> t = S [ i ] == <STRING> : <NEWLINE> x += t <NEWLINE> y -= not t <NEWLINE> c = min ( c , x + y ) <NEWLINE> <DEDENT> print ( c ) <NEWLINE>
_ = input ( ) <NEWLINE> S = input ( ) . lstrip ( <STRING> ) . rstrip ( <STRING> ) <NEWLINE> n = len ( S ) <NEWLINE> <NL> x = 0 <NEWLINE> y = S . count ( <STRING> ) <NEWLINE> c = min ( n - y , y ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if S [ i ] == <STRING> : <NEWLINE> <INDENT> x += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> y -= 1 <NEWLINE> <DEDENT> c = min ( ans , x + y ) <NEWLINE> <DEDENT> print ( c ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> a = 0 <NEWLINE> b = S . count ( <STRING> ) <NEWLINE> num = min ( N - y , y ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> x = S [ i ] == <STRING> <NEWLINE> a += x <NEWLINE> b -= 1 - x <NEWLINE> num = num ( num , a + b ) <NEWLINE> <DEDENT> print ( num ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> N = map ( int , input . split ( ) ) <NEWLINE> S = input ( ) <NEWLINE> black = S . count ( <STRING> ) <NEWLINE> white = S . count ( <STRING> ) <NEWLINE> <NL> if black == N or white == N : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> B = [ 0 ] * ( N + 1 ) <NEWLINE> W = [ 0 ] * ( N + 1 ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if S [ i ] == <STRING> : <NEWLINE> <INDENT> B [ i + 1 ] = 1 <NEWLINE> <DEDENT> elif W [ i ] == <STRING> : <NEWLINE> <INDENT> W [ i + 1 ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> B [ i ] += B [ i - 1 ] <NEWLINE> W [ i ] += W [ i - 1 ] <NEWLINE> <DEDENT> ans = float ( <STRING> ) <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> ans = min ( ans , B [ i ] + white - W [ i ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> main ( ) <NEWLINE>
N , S = open ( 0 ) . read ( ) . split ( ) <NEWLINE> N = int ( N ) <NEWLINE> S = list ( S ) <NEWLINE> <NL> def calc ( ) : <NEWLINE> <INDENT> group = [ ] if S [ 0 ] == <STRING> else [ 0 ] <NEWLINE> n = 0 <NEWLINE> mark = S [ 0 ] <NEWLINE> for s in S : <NEWLINE> <INDENT> if s == mark : <NEWLINE> <INDENT> n += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> mark = s <NEWLINE> group . append ( n ) <NEWLINE> n = 1 <NEWLINE> <DEDENT> <DEDENT> if n > 0 : <NEWLINE> <INDENT> group . append ( n ) <NEWLINE> <DEDENT> if S [ - 1 ] == <STRING> : <NEWLINE> <INDENT> group . pop ( ) <NEWLINE> <NL> <DEDENT> cnt = 0 <NEWLINE> i = 1 <NEWLINE> j = len ( group ) - 1 <NEWLINE> while i <= j : <NEWLINE> <INDENT> l = group [ i ] <NEWLINE> r = group [ j ] <NEWLINE> if l < r : <NEWLINE> <INDENT> cnt += l <NEWLINE> i += 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cnt += r <NEWLINE> j -= 2 <NEWLINE> <DEDENT> <DEDENT> return cnt <NEWLINE> <NL> <DEDENT> all_w = sum ( [ 1 if s == <STRING> else 0 for s in S ] ) <NEWLINE> all_b = sum ( [ 1 if s == <STRING> else 0 for s in S ] ) <NEWLINE> lwrb = calc ( ) <NEWLINE> print ( min ( all_w , all_b , lwrb ) <NEWLINE>
a , b = map ( int , input ( ) ) <NEWLINE> print ( max ( a , b ) * 2 - 1 ) <NEWLINE>
n = list ( int ( input ( ) . split ( ) ) ) <NEWLINE> if n [ 0 ] == n [ 1 ] : <NEWLINE> <INDENT> print ( n [ 0 ] * 2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( max ( n ) * 2 - 1 ) <NEWLINE> <DEDENT>
m = input ( ) <NEWLINE> m = m . split ( <STRING> ) <NEWLINE> a = m [ 0 ] <NEWLINE> b = m [ 1 ] <NEWLINE> <NL> print ( max ( a + a - 1 , b + b - 1 , a + b ) ) <NEWLINE>
a , b = input ( ) . split ( ) <NEWLINE> M = max ( a , b ) <NEWLINE> m = min ( a , b ) <NEWLINE> <NL> n = 0 <NEWLINE> n += M <NEWLINE> M -= 1 <NEWLINE> <NL> n += max ( M , m ) <NEWLINE> <NL> print ( n ) <NEWLINE>
n , a , b , = map ( int , input ( ) . split ( ) ) <NEWLINE> if a * n > b : <NEWLINE> <INDENT> print ( b ) <NEWLINE> <DEDENT> if a * n < b : <NEWLINE> <INDENT> print ( a * n ) <NEWLINE> <DEDENT> if a * n == b : <NEWLINE> <INDENT> print ( a * n ) <NEWLINE> <DEDENT>
a , b = input ( ) . split ( ) <NEWLINE> a = int ( a ) <NEWLINE> b = int ( b ) <NEWLINE> if a - b >= 2 : <NEWLINE> <INDENT> print ( 2 a - 1 ) <NEWLINE> <DEDENT> if b - a >= 2 : <NEWLINE> <INDENT> print ( 2 b - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( a + b ) <NEWLINE> <DEDENT>
a , b = map ( int , input ( ) ) <NEWLINE> point = 0 <NEWLINE> point += max ( a , b ) <NEWLINE> <NL> if max ( a , b ) == a : <NEWLINE> <INDENT> point += max ( a - 1 , b ) <NEWLINE> print ( point ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> point += max ( a , b - 1 ) <NEWLINE> print ( point ) <NEWLINE> <DEDENT>
A = int ( input ( ) ) <NEWLINE> B = int ( input ( ) ) <NEWLINE> if A > B : <NEWLINE> <INDENT> print ( 2 * A - 1 ) <NEWLINE> <DEDENT> elif A < B : <NEWLINE> <INDENT> print ( 2 * B - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 2 * A ) <NEWLINE> <DEDENT>
A , B = map ( input ( ) . split ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( 2 ) : <NEWLINE> <INDENT> if A >= B : <NEWLINE> <INDENT> ans += A <NEWLINE> A -= 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += B <NEWLINE> B -= 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
a = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> if a >= 3200 : <NEWLINE> <INDENT> print ( s ) <NEWLINE> <DEDENT> if a < 3200 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if a == b : print ( a * 2 ) <NEWLINE> else print ( max ( a , b ) * 2 - 1 ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if a >= b : <NEWLINE> <INDENT> ans += a <NEWLINE> a -= 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += b <NEWLINE> b -= 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
a , b = map ( int , input ( ) ) <NEWLINE> if a == b : <NEWLINE> <INDENT> print ( 2 * b ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = max ( a , b ) <NEWLINE> print ( 2 * x - 1 ) <NEWLINE> <DEDENT>
( a , b ) = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( max ( a , b ) + max ( max ( a , b ) - 1 , min ( a , b ) ) <NEWLINE>
import numpy as np <NEWLINE> import math <NEWLINE> import collections <NEWLINE> import fractions <NEWLINE> import itertools <NEWLINE> <NL> def solve ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> m = h [ 0 ] <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , h - 1 ) : <NEWLINE> <INDENT> if h [ i ] >= m : <NEWLINE> <INDENT> ans += 1 <NEWLINE> m = h [ i ] <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> return 0 <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> solve ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> c = 0 <NEWLINE> <NL> for i in h : <NEWLINE> <INDENT> t = True <NEWLINE> for j in range ( i ) : <NEWLINE> <INDENT> if h [ j ] >= h [ i ] : <NEWLINE> <INDENT> t = False <NEWLINE> break <NEWLINE> c += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> H = list ( map ( int , input ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> m = - 1000 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if m <= H [ i ] : <NEWLINE> <INDENT> m = H [ i ] <NEWLINE> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
a = int ( input ( ) ) <NEWLINE> b = [ int ( input ( ) ) for i in range ( a ) ] <NEWLINE> c = 0 <NEWLINE> d = 0 <NEWLINE> for i in range ( a ) : <NEWLINE> <INDENT> if c < b [ i ] : <NEWLINE> <INDENT> c = b [ i ] <NEWLINE> d = d + 1 <NEWLINE> <DEDENT> <DEDENT> print ( d ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = int ( input ( ) ) <NEWLINE> cnt = 1 <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> b = int ( input ( ) ) <NEWLINE> if a <= b : <NEWLINE> <INDENT> cnt + + <NEWLINE> a = b <NEWLINE> <NL> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> H = [ int ( n ) for n in input ( ) . split ( ) ] <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> t = max ( H [ : i ] ) <NEWLINE> if t <= H [ i ] : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
s = int ( input ( ) ) <NEWLINE> <NL> start0 = 0 <NEWLINE> start1 = 0 <NEWLINE> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> if i % 2 == 0 : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> start1 += 1 <NEWLINE> <DEDENT> elif s [ i ] == <STRING> : <NEWLINE> <INDENT> start0 += 1 <NEWLINE> <DEDENT> <DEDENT> elif i % 2 == 1 : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> start0 += 1 <NEWLINE> <DEDENT> elif s [ i ] == <STRING> : <NEWLINE> <INDENT> start1 += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( min ( [ start0 , start1 ] ) ) <NEWLINE>
 <NEWLINE> <NL> Copy <NEWLINE> Copy <NEWLINE> <COMMENT> <NL> s = input ( ) <NEWLINE> len = len ( s ) <NEWLINE> <NL> if len == 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> even = s [ : : 2 ] <NEWLINE> odd = s [ 1 : : 2 ] <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> odd_zero = odd . count ( <STRING> ) <NEWLINE> even_one = even . count ( <STRING> ) <NEWLINE> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> odd_one = odd . count ( <STRING> ) <NEWLINE> even_zero = even . count ( <STRING> ) <NEWLINE> <NL> print ( min ( odd_zero + even_one , odd_one + even_zero ) ) <NEWLINE>
n = input ( ) <NEWLINE> <NL> counta = 0 <NEWLINE> countb = 0 <NEWLINE> if N % 2 == 0 : <NEWLINE> <INDENT> for i in range ( 0 , len ( n ) - 2 , 2 ) : <NEWLINE> <INDENT> if n [ i ] == <STRING> : <NEWLINE> <INDENT> counta += 1 <NEWLINE> <DEDENT> elif n [ i ] == <STRING> : <NEWLINE> <INDENT> countb += 1 <NEWLINE> <DEDENT> <DEDENT> for i in range ( 1 , len ( n ) - 1 , 2 ) : <NEWLINE> <INDENT> if n [ i ] == <STRING> : <NEWLINE> <INDENT> counta += 1 <NEWLINE> <DEDENT> elif n [ i ] == <STRING> : <NEWLINE> <INDENT> countb += 1 <NEWLINE> <DEDENT> <DEDENT> print ( min ( counta , countb ) ) <NEWLINE> <NL> <DEDENT> counta = 0 <NEWLINE> countb = 0 <NEWLINE> if N % 2 == 1 : <NEWLINE> <INDENT> for i in range ( 0 , len ( n ) - 1 , 2 ) : <NEWLINE> <INDENT> if n [ i ] == <STRING> : <NEWLINE> <INDENT> counta += 1 <NEWLINE> <DEDENT> elif n [ i ] == <STRING> : <NEWLINE> <INDENT> countb += 1 <NEWLINE> <DEDENT> <DEDENT> for i in range ( 1 , len ( n ) - 2 , 2 ) : <NEWLINE> <INDENT> if n [ i ] == <STRING> : <NEWLINE> <INDENT> counta += 1 <NEWLINE> <DEDENT> elif n [ i ] == <STRING> : <NEWLINE> <INDENT> countb += 1 <NEWLINE> <DEDENT> <DEDENT> print ( min ( counta , countb ) ) <NEWLINE> <DEDENT>
a = input ( ) <NEWLINE> b = int ( len ( a ) ) <NEWLINE> c = 0 <NEWLINE> d = 0 <NEWLINE> for i in range ( b ) : <NEWLINE> <INDENT> if a [ 2 * i ] == 1 : <NEWLINE> <INDENT> c = c + 1 <NEWLINE> <DEDENT> if a [ 2 * 1 + 1 ] == 0 : <NEWLINE> <INDENT> c = c + 1 <NEWLINE> <DEDENT> <DEDENT> for i in range ( b ) : <NEWLINE> <INDENT> if a [ 2 * i ] == 0 : <NEWLINE> <INDENT> d = d + 1 <NEWLINE> <DEDENT> if a [ 2 * 1 + 1 ] == 1 : <NEWLINE> <INDENT> d = d + 1 <NEWLINE> <DEDENT> <DEDENT> if c > d : <NEWLINE> <INDENT> print ( d ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( c ) <NEWLINE> <DEDENT>
<STRING> <NEWLINE> <NL> import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> <NL> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> s = input ( ) <NEWLINE> <NL> nums = [ ] <NEWLINE> now = 1 <COMMENT> <NEWLINE> cnt = 0 <COMMENT> <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> if s [ i ] == str ( now ) : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> nums . append ( cnt ) <NEWLINE> now ^= 1 <COMMENT> <NEWLINE> cnt = 1 <COMMENT> <NEWLINE> <DEDENT> <DEDENT> if cnt != 0 : <NEWLINE> <INDENT> nums . append ( cnt ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> if len ( nums ) % 2 == 0 : <NEWLINE> <INDENT> nums . append ( 0 ) <NEWLINE> <NL> <DEDENT> add = 2 * k + 1 <NEWLINE> <NL> <COMMENT> <NL> tot = [ 0 ] * ( len ( nums ) + 1 ) <NEWLINE> for i in range ( len ( tot ) ) : <NEWLINE> <INDENT> tot [ i + 1 ] = tot [ i ] + nums [ i ] <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> <NL> <COMMENT> <NL> for i in range ( 0 , len ( nums ) , 2 ) : <NEWLINE> <NL> <COMMENT> <NL> <INDENT> left = i <NEWLINE> right = min ( i + add , len ( nums ) ) <NEWLINE> tmp = tot [ right ] - tot [ left ] <NEWLINE> <NL> ans = max ( tmp , ans ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> s = [ ] <NEWLINE> count = 0 <NEWLINE> last = 1 <NEWLINE> for i in input ( ) : <NEWLINE> <INDENT> if i == <STRING> : <NEWLINE> <INDENT> if last == 1 : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s . append ( count ) <NEWLINE> count = 1 <NEWLINE> <DEDENT> last = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if last == 0 : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s . append ( count ) <NEWLINE> count = 1 <NEWLINE> <DEDENT> last = 0 <NEWLINE> <DEDENT> <DEDENT> s . append ( count ) <NEWLINE> if last == <STRING> : <NEWLINE> <INDENT> s . append ( 0 ) <NEWLINE> <NL> <DEDENT> k = min ( k , len ( s ) // 2 ) <NEWLINE> ans = 0 <NEWLINE> <NL> for j in range ( len ( s ) // 2 - k + 1 ) : <NEWLINE> <INDENT> if j == 0 : <NEWLINE> <INDENT> now = sum ( s [ : k * 2 + 1 ] ) <NEWLINE> ans = now <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> now = now - s [ j * 2 - 1 ] - s [ j * 2 - 2 ] + s [ ( j + k ) * 2 ] + s [ ( j + k ) * 2 - 1 ] <NEWLINE> ans = max ( ans , now ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> s = input ( ) <NEWLINE> l = [ 0 ] <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> if s [ i ] != s [ i + 1 ] : <NEWLINE> <INDENT> l . append ( i + 1 ) <NEWLINE> <DEDENT> <DEDENT> l += [ n ] <NEWLINE> le = len ( l ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( le - 1 ) : <NEWLINE> <INDENT> if s [ l [ i ] ] == <STRING> : <NEWLINE> <INDENT> ans = max ( ans , l [ min ( le , k * 2 + i ) ] - l [ i ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = max ( ans , l [ min ( le , k * 2 + i + 1 ) ] - l [ i ] ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
a , b , c , d , e = [ int ( input ( ) ) for _ in range ( 4 ) ] <NEWLINE> k = int ( input ( ) ) <NEWLINE> <NL> if abs ( a - b ) > k or abs ( a - c ) > k or abs ( a - d ) > k or abs ( a - e ) > k or abs ( b - c ) > k or abs ( b - d ) > k or abs ( e - b ) > k or abs ( c - d ) > k or abs ( c - e ) > k or abs ( d - e ) > k : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> read = sys . stdin . read <NEWLINE> readline = sys . stdin . readline <NEWLINE> readlines = sys . stdin . readlines <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> INF = 1 << 60 <NEWLINE> MOD = 1000000007 <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> A , B , C , D , E = map ( int , readline ( ) . split ( ) ) <NEWLINE> <NL> if E - A > K : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> return <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> a = int ( input ( ) ) <NEWLINE> b = int ( input ( ) ) <NEWLINE> c = int ( input ( ) ) <NEWLINE> d = int ( input ( ) ) <NEWLINE> e = int ( input ( ) ) <NEWLINE> k = int ( input ( ) ) <NEWLINE> if e - a <= k <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
l = [ int ( input ( ) ) for i in range ( 4 ) ] <NEWLINE> <NL> for i in range ( 4 ) : <NEWLINE> <INDENT> for j in range ( 4 ) : <NEWLINE> <INDENT> if l [ i ] * l [ j ] > l [ 4 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
a , b , c , d , e = map ( int , input ( ) . split ( ) ) <NEWLINE> k = int ( input ( ) ) <NEWLINE> print ( <STRING> if e - a <= k else <STRING> ) <NEWLINE>
a = [ ] <NEWLINE> for i in range ( 5 ) : <NEWLINE> <INDENT> a . append ( int ( input ( ) ) ) <NEWLINE> <DEDENT> a . sort ( ) <NEWLINE> j = int ( input ) <NEWLINE> k = a [ 4 ] - a [ 0 ] <NEWLINE> if k <= j : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a [ 0 ] = int ( input ( ) ) <NEWLINE> a [ 1 ] = int ( input ( ) ) <NEWLINE> a [ 2 ] = int ( input ( ) ) <NEWLINE> a [ 3 ] = int ( input ( ) ) <NEWLINE> a [ 4 ] = int ( input ( ) ) <NEWLINE> k = int ( input ( ) ) <NEWLINE> for i in range ( 5 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , 5 ) : <NEWLINE> <INDENT> if a [ j ] - a [ i ] > k : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
a = int ( input ( ) ) <NEWLINE> b = int ( input ( ) ) <NEWLINE> c = int ( input ( ) ) <NEWLINE> d = int ( input ( ) ) <NEWLINE> e = int ( input ( ) ) <NEWLINE> k = int ( input ( ) ) <NEWLINE> <NL> l = [ ] <NEWLINE> l . append ( a ) <NEWLINE> l . append ( b ) <NEWLINE> l . append ( c ) <NEWLINE> l . append ( d ) <NEWLINE> l . append ( e ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 5 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , 5 ) : <NEWLINE> <INDENT> if l [ j ] - l [ i ] > k : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if ans = 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
antena = [ ] <NEWLINE> for i in range ( 5 ) : <NEWLINE> <INDENT> antena [ i ] = int ( input ( ) ) <NEWLINE> <NL> <DEDENT> k = int ( input ( ) ) <NEWLINE> <NL> for i in range ( len ( antena ) ) : <NEWLINE> <INDENT> if antena [ - 1 ] - antena [ i ] > k : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
for i in range ( 5 ) : <NEWLINE> <INDENT> I = list ( map ( int , input ( ) ) ) <NEWLINE> <DEDENT> k = int ( input ( ) ) <NEWLINE> if I [ 4 ] - I [ 0 ] <= k : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
for i in range ( 6 ) : <NEWLINE> <INDENT> A [ i ] = int ( input ( ) ) <NEWLINE> <NL> <DEDENT> isOK = True <NEWLINE> for i in range ( 5 ) : <NEWLINE> <INDENT> for j in range ( 5 ) : <NEWLINE> <INDENT> if ( abs ( A [ i ] - A [ j ] ) > A [ 6 ] ) : <NEWLINE> <INDENT> isOK = False <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if ( isOK ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b , c , d , e , k = map ( int , input ( ) . split ( ) ) <NEWLINE> if e - a > k : print ( <STRING> ) <NEWLINE> else : print ( <STRING> ) <NEWLINE>
s = [ ] <NEWLINE> for i in range ( 5 ) : <NEWLINE> <INDENT> s . apppend ( int ( input ( ) ) <NEWLINE> <DEDENT> k = int ( input ( ) ) <NEWLINE> for i in range ( 4 ) : <NEWLINE> <INDENT> if s [ i + 1 ] - s [ i ] > k : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a = int ( input ( ) <NEWLINE> b = int ( input ( ) <NEWLINE> c = int ( input ( ) <NEWLINE> d = int ( input ( ) <NEWLINE> e = int ( input ( ) <NEWLINE> x = int ( input ( ) <NEWLINE> ls = [ a , b , c , d , e ] <NEWLINE> ls . sort ( ) <NEWLINE> if ( ls [ 1 ] - ls [ 0 ] ) <= x and ( ls [ 2 ] - ls [ 1 ] ) <= x and ( ls [ 3 ] - ls [ 2 ] ) <= x and ( ls [ 4 ] - ls [ 3 ] ) <= x : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a = [ ] <NEWLINE> b = [ ] <NEWLINE> ori = [ ] <NEWLINE> ans = 0 <NEWLINE> for i in range ( 5 ) : <NEWLINE> <INDENT> c = int ( input ( ) ) <NEWLINE> ori . append ( c ) <NEWLINE> a . append ( ( c // 10 + 1 ) * 10 ) <NEWLINE> <NL> if c % 10 == 0 : <NEWLINE> <INDENT> b . append ( 100 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> b . append ( c % 10 ) <NEWLINE> <DEDENT> <DEDENT> a . pop ( b . index ( min ( b ) ) ) <NEWLINE> print ( ori [ b . index ( min ( b ) ) ] + a . sum ( ) ) <NEWLINE>
import sys <NEWLINE> import math <NEWLINE> import itertools <NEWLINE> import collections <NEWLINE> import heapq <NEWLINE> import re <NEWLINE> import numpy as np <NEWLINE> <NL> rr = lambda : sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> rs = lambda : sys . stdin . readline ( ) . split ( ) <NEWLINE> ri = lambda : int ( sys . stdin . readline ( ) ) <NEWLINE> rm = lambda : map ( int , sys . stdin . readline ( ) . split ( ) ) <NEWLINE> rl = lambda : list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) <NEWLINE> inf = float ( <STRING> ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> li = [ ri ( ) for _ in range ( 5 ) ] <NEWLINE> lis = [ math . ceil ( i / 10 ) * 10 for i in li ] <NEWLINE> ans = inf <NEWLINE> for i in range ( 5 ) : <NEWLINE> <INDENT> ans = min ( sum ( lis [ : i ] ) + li [ i ] + sum ( lis [ i + 1 : ] ) ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL>
import numpuy as np <NEWLINE> dishes = [ int ( input ( ) ) for _ in range ( 5 ) ] <NEWLINE> dishes = sorted ( dishes , key = lambda x : x % 10 ) <NEWLINE> minutes = 0 <NEWLINE> first = True <NEWLINE> for i in dishes : <NEWLINE> <INDENT> if i % 10 == 0 : <NEWLINE> <INDENT> minutes += i <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if first : <NEWLINE> <INDENT> minutes += i <NEWLINE> first = False <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> minutes += int ( np . ceil ( i / 10 ) * 10 ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( minutes ) <NEWLINE>
nums = [ int ( input ( ) ) for _ in range ( 5 ) ] <NEWLINE> mn = float ( <STRING> ) <NEWLINE> <NL> for i in nums : <NEWLINE> <INDENT> if i % 10 != 0 : <NEWLINE> <INDENT> mn = min ( mn , i % 10 ) <NEWLINE> <DEDENT> <DEDENT> if mn == float ( <STRING> ) : <NEWLINE> <INDENT> mn = 0 <NEWLINE> <NL> <DEDENT> print ( sum ( list ( map ( lambda x : int ( math . ceil ( x / 10 ) * 10 ) , nums ) ) ) - 10 + mn ) <NEWLINE>
dish = [ int ( input ( ) ) for _ in range ( 5 ) ] <NEWLINE> count = { str ( i % 10 ) : [ ] for i in range ( 10 , - 1 , - 1 ) } <NEWLINE> for t in dish : <NEWLINE> <INDENT> one = t % 10 <NEWLINE> count [ str ( one ) ] . append ( t ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> d = 0 <NEWLINE> for k , v in count . items ( ) : <NEWLINE> <INDENT> if v != [ ] : <NEWLINE> <INDENT> for c in v : <NEWLINE> <INDENT> if d > 3 : <NEWLINE> <INDENT> ans += c <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += math . ceil ( c / 10 ) * 10 <NEWLINE> d += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( int ( ans ) ) <NEWLINE>
import sys <NEWLINE> input = sys . stdin . read <NEWLINE> * x , = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> tmp = 100 <NEWLINE> for i in range ( 5 ) : <NEWLINE> <INDENT> if x [ i ] % 10 : <NEWLINE> <INDENT> tmp = min ( tmp , x [ i ] % 10 ) <NEWLINE> x [ i ] //= 10 <NEWLINE> x [ i ] *= 10 <NEWLINE> x [ i ] += 10 <NEWLINE> <DEDENT> <DEDENT> ans = sum ( x ) <NEWLINE> if tmp < 100 : <NEWLINE> <INDENT> ans -= 10 <NEWLINE> ans += tmp <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL>
a = [ ] <NEWLINE> for i in range ( 5 ) : <NEWLINE> <INDENT> a . append ( int ( input ( ) ) ) <NEWLINE> <NL> <DEDENT> zako = 9 <NEWLINE> switch = 0 <NEWLINE> for i in range ( 5 ) : <NEWLINE> <INDENT> b = a [ i ] % 10 <NEWLINE> if b <= zako and b != 0 : <NEWLINE> <INDENT> zako = b <NEWLINE> memory = i <NEWLINE> switch = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if switch = 0 : <NEWLINE> <INDENT> memory = 1 <NEWLINE> <DEDENT> x = a . pop ( memory ) <NEWLINE> <NL> lst = [ ] <NEWLINE> <NL> for i in range ( 4 ) : <NEWLINE> <INDENT> c = a [ i ] // 10 <NEWLINE> c = c * 10 <NEWLINE> if a [ i ] % 10 != 0 : <NEWLINE> <INDENT> c += 10 <NEWLINE> <DEDENT> lst . append ( c ) <NEWLINE> <NL> <DEDENT> print ( x + sum ( lst ) ) <NEWLINE>
sum = 0 <NEWLINE> r = [ ] <NEWLINE> for i in range ( 5 ) : <NEWLINE> <INDENT> if a [ i ] % 10 == 0 : <NEWLINE> <INDENT> sum += a [ i ] <NEWLINE> <DEDENT> elif a [ i ] % 10 != 0 : <NEWLINE> <INDENT> sum += ( 10 * math . ceil ( a [ i ] / 10 ) ) <NEWLINE> r . append ( int ( a [ i ] % 10 ) ) <NEWLINE> <DEDENT> <DEDENT> print ( sum - 10 + min ( r ) ) <NEWLINE>
l = [ ] <NEWLINE> for i in range ( 5 ) : <NEWLINE> <INDENT> l . append ( int ( input ( ) ) ) <NEWLINE> <DEDENT> amari = [ ] <NEWLINE> for i in range ( 5 ) : <NEWLINE> <INDENT> amari . append ( 10 - l [ i ] % 10 ) <NEWLINE> <DEDENT> jikan = [ ] <NEWLINE> for i in range ( 5 ) : <NEWLINE> <INDENT> jikan . append ( l [ i ] + amari [ i ] ) <NEWLINE> <DEDENT> print ( sum [ jikan ] - max ( amari ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> Cap = [ int ( input ( ) ) for X in range ( 0 , 5 ) ] <NEWLINE> print ( int ( math . ceil ( N / min ( Cap ) ) + 4 ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = int ( input ( ) ) <NEWLINE> B = int ( input ( ) ) <NEWLINE> C = int ( input ( ) ) <NEWLINE> D = int ( input ( ) ) <NEWLINE> E = int ( input ( ) ) <NEWLINE> X = min ( A , B , C , D , E ) <NEWLINE> if X >= N : <NEWLINE> <INDENT> print ( 5 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if N % X == 0 : <NEWLINE> <INDENT> print ( 4 + N // X ) <NEWLINE> <DEDENT> elese : <NEWLINE> <INDENT> print ( 5 + N // X ) <NEWLINE> <DEDENT> <DEDENT>
import math <NEWLINE> n = int ( input ( ) ) <NEWLINE> l = [ int ( input ) for i in range ( 5 ) ] <NEWLINE> print ( math . ceil ( n / min ( l ) ) + 4 ) <NEWLINE>
import math <NEWLINE> n = int ( input ( ) ) <NEWLINE> l = [ int ( input ( ) ) for i in range ( 5 ) ] <NEWLINE> print ( mat . ceil ( n / min ( l ) ) + 4 ) <NEWLINE>
n = int ( input ( ) . split ( ) ) <NEWLINE> x = [ int ( input ( ) ) for i in range ( 5 ) ] <NEWLINE> d = n // min ( x ) <NEWLINE> print ( d + 5 ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> data = [ int ( input ( ) ) for i in range ( 5 ) ] <NEWLINE> quo , rem = divmod ( n , min ( data ) ) <NEWLINE> print ( 4 + quo + bool ( rem ) ) <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE>
import math <NEWLINE> n = int ( input ( ) ) <NEWLINE> l = [ input ( ) for i in range ( 5 ) ] <NEWLINE> print ( math . ceil ( n / min ( l ) ) + 4 ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> transport = [ int ( input ( ) ) for _ in range ( 5 ) ] <NEWLINE> print ( int ( N / np . min ( transport ) + 5 ) ) <NEWLINE>
from itertools import product <NEWLINE> from heapq import * <NEWLINE> <NL> X , Y , Z , K , * f = map ( int , open ( 0 ) . read ( ) . split ( ) ) <NEWLINE> A = f [ : X ] <NEWLINE> B = f [ X : X + Y ] <NEWLINE> C = f [ X + Y : ] <NEWLINE> A . sort ( reverse = True ) <NEWLINE> B . sort ( reverse = True ) <NEWLINE> C . sort ( reverse = True ) <NEWLINE> AB = [ sum ( x ) * ( - 1 ) for x in product ( A , B ) ] <NEWLINE> heapify ( AB ) <NEWLINE> AB_picked = [ ] <NEWLINE> for i in range ( K ) : <NEWLINE> <INDENT> AB_picked . append ( heappop ( AB ) * ( - 1 ) ) <NEWLINE> <DEDENT> ABC = [ sum ( x ) * ( - 1 ) for x in product ( AB_picked , C ) ] <NEWLINE> heapify ( ABC ) <NEWLINE> for i in range ( K ) : <NEWLINE> <INDENT> print ( heappop ( ABC ) * ( - 1 ) ) <NEWLINE> <DEDENT>
A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> C = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A . sort ( reverse = True ) <NEWLINE> B . sort ( reverse = True ) <NEWLINE> C . sort ( reverse = True ) <NEWLINE> abc = [ ( - ( A [ 0 ] + B [ 0 ] + C [ 0 ] ) , 0 , 0 , 0 ) ] <NEWLINE> used = set ( ( 0 , 0 , 0 ) ) <NEWLINE> while K > 0 : <NEWLINE> <INDENT> K -= 1 <NEWLINE> p , i , j , k = hq . heappop ( abc ) <NEWLINE> print ( - p ) <NEWLINE> for a , b , c in [ ( i + 1 , j , k ) , ( i , j + 1 , k ) , ( i , j , k + 1 ) ] : <NEWLINE> <INDENT> if a < x and b < y and c < z and ( a , b , c ) not in used : <NEWLINE> <INDENT> used . add ( ( a , b , c ) ) <NEWLINE> hq . heappush ( abc , ( - ( A [ a ] + B [ b ] + C [ c ] ) , a , b , c ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
X , Y , Z , K = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> B = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> C = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> l = [ ] <NEWLINE> for a in A : <NEWLINE> <INDENT> for b in B : <NEWLINE> <INDENT> l . append ( a + b ) <NEWLINE> <DEDENT> <DEDENT> l = sorted ( l , reverse = True ) [ : K ] <NEWLINE> <NL> ans = [ ] <NEWLINE> for c in C : <NEWLINE> <INDENT> for k in l : <NEWLINE> <INDENT> ans . append ( c + k ) <NEWLINE> <NL> <DEDENT> <DEDENT> ans = sorted ( ans , reverse = True ) <NEWLINE> print ( * ans [ : K ] , seq = <STRING> ) <NEWLINE>
a , b , c = map ( int , nput ( ) . split ( ) ) <NEWLINE> print ( <STRING> if a == b == c else <STRING> ) <NEWLINE>
a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> if a == b & & b == c : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> sort ( A ) <NEWLINE> if A [ 0 ] + A [ 1 ] > A [ 2 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
inp = input ( ) . split ( <STRING> ) <NEWLINE> <NL> print ( inp [ 0 ] == inp [ 1 ] and inp [ 0 ] == inp [ 2 ] and 1 <= inp [ 0 ] <= 100 ) <NEWLINE>
a , b , c = int ( input ( ) ) <NEWLINE> <NL> if a == b and b == c and c == a : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
if a [ 0 ] == a [ 1 ] and a [ 1 ] == a [ 2 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> print ( <STRING> if S . count ( B ) > S . count ( R ) else <STRING> ) <NEWLINE>
a = input ( ) <NEWLINE> if a = A : <NEWLINE> <INDENT> print ( T ) <NEWLINE> <DEDENT> elif a = T : <NEWLINE> <INDENT> print ( A ) <NEWLINE> <DEDENT> elif a = G : <NEWLINE> <INDENT> print ( C ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( G ) <NEWLINE> <DEDENT>
d = { <STRING> : <STRING> , <STRING> : <STRING> , <STRING> : <STRING> , <STRING> , <STRING> } <NEWLINE> print ( d [ input ( ) ] ) <NEWLINE>
b = input ( ) <NEWLINE> <NL> if b == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif b == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif b == ( <STRING> ) <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
b = input ( ) <NEWLINE> if b = A : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif b = T : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif b = C : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
b = input ( ) <NEWLINE> if b = <STRING> : <NEWLINE> <INDENT> b = <STRING> <NEWLINE> <DEDENT> elif b = <STRING> : <NEWLINE> <INDENT> b = <STRING> <NEWLINE> <DEDENT> elif b = <STRING> : <NEWLINE> <INDENT> b = <STRING> <NEWLINE> <DEDENT> elif b = <STRING> : <NEWLINE> <INDENT> b = <STRING> <NEWLINE> <DEDENT> print ( b ) <NEWLINE>
1 b = input ( ) <NEWLINE> 2 c = { <STRING> : <STRING> , <STRING> : <STRING> , <STRING> : <STRING> , <STRING> : <STRING> } <NEWLINE> 3 print ( c [ b ] ) <NEWLINE>
b = input ( ) <NEWLINE> print ( <STRING> if b == T else <STRING> if b == A else <STRING> if b == C else <STRING> ) <NEWLINE>
b = input ( ) <NEWLINE> <NL> if b == A : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif b == T : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif b == G : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
b = str ( input ( ) ) <NEWLINE> <NL> if b == A : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> if b == T : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> if b == C : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> if b == G : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a = input ( ) <NEWLINE> print ( <STRING> if a = <STRING> else <STRING> if a = <STRING> else <STRING> if a = <STRING> else <STRING> ) <NEWLINE>
b = list ( input ( ) ) <NEWLINE> <NL> for i in len ( b ) : <NEWLINE> <INDENT> if b [ i ] == <STRING> : <NEWLINE> <INDENT> b [ i ] = <STRING> <NEWLINE> <DEDENT> elif b [ i ] == <STRING> : <NEWLINE> <INDENT> b [ i ] = <STRING> <NEWLINE> <DEDENT> elif b [ i ] == <STRING> : <NEWLINE> <INDENT> b [ i ] = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> b [ i ] = <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> print ( b ) <NEWLINE>
if b == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif b == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif b == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif b == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
X = int ( input ( ) ) <NEWLINE> if X == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif X == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif X == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif X == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> b = input ( ) <NEWLINE> <NL> if b == ( <STRING> ) : <NEWLINE> <INDENT> print ( T ) <NEWLINE> <NL> <DEDENT> if b == ( <STRING> ) : <NEWLINE> <INDENT> print ( G ) <NEWLINE> <NL> <DEDENT> if b == ( <STRING> ) : <NEWLINE> <INDENT> print ( A ) <NEWLINE> <NL> <DEDENT> if b == ( <STRING> ) : <NEWLINE> <INDENT> print ( C ) <NEWLINE> <DEDENT>
s = int ( input ( ) ) <NEWLINE> <NL> if s == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif s == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif s == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif s == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> <NL> if n == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif n == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif n == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
x = input ( ) <NEWLINE> if x = <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> if x = <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> if x = <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
b = int ( input ( ) ) <NEWLINE> print ( <STRING> if b == <STRING> else <STRING> if b == <STRING> else <STRING> if b == <STRING> else <STRING> ) <NEWLINE>
count = 0 <NEWLINE> tmp = 0 <NEWLINE> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> or s [ i ] == <STRING> or s [ i ] == <STRING> or s [ i ] == <STRING> : <NEWLINE> <INDENT> tmp += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> tmp = 0 <NEWLINE> <DEDENT> count = max ( tmp , count ) <NEWLINE> <DEDENT> print ( count ) <NEWLINE>
s = input ( ) <NEWLINE> temp = 0 <NEWLINE> ans = 0 <NEWLINE> tar = <STRING> <NEWLINE> for ch in s : <NEWLINE> <INDENT> if ch in tar : <NEWLINE> <INDENT> temp += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if ans = < temp : <NEWLINE> <INDENT> ans = temp <NEWLINE> <DEDENT> temp = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL>
import sys <NEWLINE> import re <NEWLINE> S = input ( ) <NEWLINE> if not ( 1 <= len ( S ) <= 10 ) : sys . exit ( ) <NEWLINE> if not S . isupper : sys . exit ( ) <NEWLINE> <NL> max = max ( re . findall ( <STRING> , S ) ) if re . findall ( <STRING> , S ) else 0 <NEWLINE> if max > 0 : max <NEWLINE> print ( max ) <NEWLINE>
l = ( <STRING> , <STRING> , <STRING> , <STRING> ) <NEWLINE> S = input ( ) <NEWLINE> <NL> ans = [ 0 ] <NEWLINE> for i in range ( len ( S ) ) : <NEWLINE> <INDENT> if S [ i ] in l : <NEWLINE> <INDENT> res += 1 <NEWLINE> <DEDENT> elif res != 0 : <NEWLINE> <INDENT> ans . append ( res ) <NEWLINE> res = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( max ( ans ) ) <NEWLINE>
n = input ( ) <NEWLINE> ans , temp = 0 , 0 <NEWLINE> for x in S : <NEWLINE> <INDENT> if x in <STRING> : <NEWLINE> <INDENT> temp += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> temp = 0 <NEWLINE> <DEDENT> ans = max ( ans , temp ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
s = input ( ) <NEWLINE> count = 0 <NEWLINE> lens = [ ] <NEWLINE> <NL> for i , _ in enumerate ( s ) : <NEWLINE> <INDENT> for c in s [ i : ] : <NEWLINE> <INDENT> if c in [ <STRING> , <STRING> , <STRING> , <STRING> ] : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> lens . append ( count ) <NEWLINE> count = 0 <NEWLINE> <NL> <DEDENT> print ( max ( lens ) ) <NEWLINE>
S = input ( ) <NEWLINE> max = 0 <NEWLINE> count = 0 <NEWLINE> for x in S : <NEWLINE> <INDENT> if x in <STRING> : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> max = max ( max , count ) <NEWLINE> count = 0 <NEWLINE> <DEDENT> <DEDENT> max = max ( max , count ) <NEWLINE> print ( max ) <NEWLINE>
n = input ( ) <NEWLINE> count = 0 <NEWLINE> m = 0 <NEWLINE> for i in n : <NEWLINE> <INDENT> if s == <STRING> or s == <STRING> or s == <STRING> or s == <STRING> : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> m = max ( m , count ) <NEWLINE> count = 0 <NEWLINE> <DEDENT> <DEDENT> print ( m ) <NEWLINE>
ACGT = [ <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> S = input ( ) <NEWLINE> cnt = 0 <NEWLINE> max_cnt = 0 <NEWLINE> for s in S : <NEWLINE> <INDENT> if s in ACGT : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> cntList . append ( cnt ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> max_cnt = max ( cnt , max_cnt ) <NEWLINE> cnt = 0 <NEWLINE> <DEDENT> <DEDENT> print ( max_cnt ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> l . sort ( reverse = True ) <NEWLINE> <NL> if l [ 0 ] < sum ( l [ 1 : n ] ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
cnt , ans = 0 , [ ] <NEWLINE> agct = [ <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> if s [ i ] in agct : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans . append ( cnt ) <NEWLINE> cnt = 0 <NEWLINE> <DEDENT> <DEDENT> if ans == [ ] : <NEWLINE> <INDENT> ans . append ( 0 ) <NEWLINE> <DEDENT> print ( max ( ans ) ) <NEWLINE>
S = input ( ) <NEWLINE> s = { <STRING> , <STRING> , <STRING> , <STRING> } <NEWLINE> ans = 0 <NEWLINE> for i in S : <NEWLINE> <INDENT> if i in s : <NEWLINE> <INDENT> tmp += 1 <NEWLINE> ans = max ( ans , tmp ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> tmp = 0 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
s = str ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> cnt = 0 <NEWLINE> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> or <STRING> or <STRING> or <STRING> : <NEWLINE> <INDENT> cnt + + <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = max ( ans , cnt ) <NEWLINE> cnt = 0 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
s = str ( input ( ) ) <NEWLINE> mx = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n + 1 ) : <NEWLINE> <INDENT> cnt = j - i - 1 <NEWLINE> p = 0 <NEWLINE> for k in list ( s [ i : j ] ) : <NEWLINE> <INDENT> if k in [ <STRING> , <STRING> , <STRING> , <STRING> ] : <NEWLINE> <INDENT> p += 1 <NEWLINE> <DEDENT> <DEDENT> if p == cnt : <NEWLINE> <INDENT> if p > mx : <NEWLINE> <INDENT> mx = p <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( mx ) <NEWLINE>
S = input ( ) <NEWLINE> <NL> l = len ( S ) <NEWLINE> <NL> ans = 0 <NEWLINE> ans_list = ( ) <NEWLINE> <NL> for i in range ( l ) : <NEWLINE> <INDENT> if S [ i ] in ( <STRING> , <STRING> , <STRING> , <STRING> ) : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans_list . append ( ans ) <NEWLINE> ans = 0 <NEWLINE> <DEDENT> <DEDENT> ans_list . append ( ans ) <NEWLINE> print ( ans ) <NEWLINE>
S = input ( ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( len ( S ) ) : <NEWLINE> <INDENT> for j in range ( i + 1 , len ( S ) + 1 ) : <NEWLINE> if all ( <STRING> . count ( c ) == 1 for c in S [ i : j + 1 ] ) : <NEWLINE> <INDENT> ans = max ( ans , j + 1 - i ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> moji = str ( input ( ) ) <NEWLINE> ans = [ 0 ] <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> if moji [ i ] == <STRING> and moji [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> ans . append ( ans [ i ] + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans . append ( ans [ i ] ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> for i in range ( K ) : <NEWLINE> <INDENT> st , sp = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( ans [ sp ] - ans [ st ] ) <NEWLINE> <DEDENT>
n , q = map ( int , input ( ) . split ( ) ) <NEWLINE> s = input ( ) <NEWLINE> list = [ 0 ] <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> and s [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> list . append ( list [ i ] + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> list . append ( list [ i ] ) <NEWLINE> <DEDENT> <DEDENT> for j in range ( q ) : <NEWLINE> <INDENT> l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( list [ r ] - list [ l - 1 ] ) <NEWLINE> <DEDENT>
N , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> S = str ( input ( ) ) <NEWLINE> li = [ ] <NEWLINE> cnt = 0 <NEWLINE> <NL> for i in range ( N - 1 ) : <NEWLINE> <INDENT> if S [ i ] == <STRING> and S [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> li . append ( cnt ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> li . append ( cnt ) <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( Q ) : <NEWLINE> <INDENT> l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = li [ r - 1 ] - li [ : l - 1 ] <NEWLINE> print ( ans ) <NEWLINE> <DEDENT>
N , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> S = input ( ) <NEWLINE> count = 0 <NEWLINE> ac = [ 0 ] <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> if S [ i ] == <STRING> and S [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> ac . append ( count ) <NEWLINE> <DEDENT> for _ in range ( Q ) : <NEWLINE> <INDENT> l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> l -= 1 , r -= 1 <NEWLINE> print ( ac [ r ] - ac [ l ] ) <NEWLINE> <DEDENT>
<INDENT> def ss ( ) : <NEWLINE> <INDENT> N , Q = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> s = input ( ) <NEWLINE> lis = [ 0 ] * N <NEWLINE> <NL> count = 0 <NEWLINE> for i in range ( 1 , len ( s ) ) : <NEWLINE> <INDENT> if s [ i - 1 ] == <STRING> and s [ i ] == <STRING> : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> lis [ i ] += count <NEWLINE> <DEDENT> for i in range ( Q ) : <NEWLINE> <INDENT> l , r = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> print ( lis [ r - 1 ] - lis [ l - 1 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> ss ( ) <NEWLINE>
import copy <NEWLINE> <NL> N , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> S = input ( ) <NEWLINE> t = [ 0 ] * N <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> t [ i + 1 ] = t [ i ] + ( 1 if S [ i : i + 2 ] == <STRING> else 0 ) <NEWLINE> <NL> <DEDENT> for i in range ( Q ) : <NEWLINE> <INDENT> l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( t [ r - 1 ] - t [ l - 1 ] ) <NEWLINE> <NL> <NL> <DEDENT>
N , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> S = input ( ) <NEWLINE> t = [ 0 ] * ( N + 1 ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> t [ i + 1 ] = t [ i ] + ( 1 if S [ i : i + 2 ] == <STRING> else 0 ) <NEWLINE> for i in range ( Q ) : <NEWLINE> <INDENT> l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( t [ r - 1 ] - t [ l - 1 ] ) <NEWLINE> <DEDENT> <DEDENT>
N , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> S = [ <STRING> ] + list ( input ( ) ) <NEWLINE> C = [ 0 ] * len ( S ) <NEWLINE> c = 0 <NEWLINE> for i in range ( 1 , len ( S ) ) : <NEWLINE> <INDENT> if S [ i - 1 ] == <STRING> and S [ i ] == <STRING> : <NEWLINE> <INDENT> c += 1 <NEWLINE> <DEDENT> C [ i ] = c <NEWLINE> <DEDENT> for _ in range ( N ) : <NEWLINE> <INDENT> l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( C [ r ] - C [ l ] ) <NEWLINE> <DEDENT>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> N , Q = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> s = input ( ) <NEWLINE> lis = [ 0 ] * N <NEWLINE> <NL> count = 0 <NEWLINE> for i in range ( 1 , len ( s ) ) : <NEWLINE> <INDENT> if s [ i - 1 ] == <STRING> and s [ i ] == <STRING> : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> lis [ i ] += count <NEWLINE> <DEDENT> for i in range ( Q ) : <NEWLINE> <INDENT> l , r = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> print ( lis [ r - 1 ] - lis [ l - 1 ] ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> from decorator import stop_watch <NEWLINE> <NL> <NL> @ stop_watch <NEWLINE> def solve ( N ) : <NEWLINE> <INDENT> mod = 10 ** 9 + 7 <NEWLINE> dp = [ { } for _ in range ( N + 1 ) ] <NEWLINE> dp [ 0 ] . setdefault ( <STRING> , 1 ) <NEWLINE> <NL> def check ( last4 ) : <NEWLINE> <INDENT> for i in range ( 4 ) : <NEWLINE> <INDENT> x = list ( last4 ) <NEWLINE> if i > 0 : <NEWLINE> <INDENT> x [ i ] , x [ i - 1 ] = x [ i - 1 ] , x [ i ] <NEWLINE> <DEDENT> if <STRING> . join ( x ) . count ( <STRING> ) >= 1 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> <DEDENT> return True <NEWLINE> <NL> <DEDENT> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> for last3 , count in dp [ i - 1 ] . items ( ) : <NEWLINE> <INDENT> for c in <STRING> : <NEWLINE> <INDENT> if check ( last3 + c ) : <NEWLINE> <INDENT> new_last3 = last3 [ 1 : ] + c <NEWLINE> dp [ i ] . setdefault ( last3 [ 1 : ] + c , 0 ) <NEWLINE> dp [ i ] [ new_last3 ] = ( dp [ i ] [ new_last3 ] + count ) % mod <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( sum ( dp [ - 1 ] . values ( ) ) % mod ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> solve ( N ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT>
def ok ( last4 ) : <NEWLINE> <INDENT> for i in range ( 4 ) : <NEWLINE> <INDENT> t = list ( last4 ) <NEWLINE> if i >= 1 : <NEWLINE> <INDENT> t [ i - 1 ] , t [ i ] = t [ i ] , t [ i - 1 ] <NEWLINE> <DEDENT> if <STRING> . join ( t ) . count ( <STRING> ) >= 1 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> <DEDENT> return True <NEWLINE> <DEDENT> def dfs ( cur , last3 ) : <NEWLINE> <INDENT> if last3 in memo [ cur ] : <NEWLINE> <INDENT> return memo [ cur ] [ last3 ] <NEWLINE> <DEDENT> if cur == N : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> ret = 0 <NEWLINE> for c in <STRING> : <NEWLINE> <INDENT> if ok ( last3 + c ) : <NEWLINE> <INDENT> ret = ( ret + dfs ( cur + 1 , last3 [ 1 : ] + c ) ) % MOD <NEWLINE> <DEDENT> <DEDENT> memo [ cur ] [ last3 ] = ret <NEWLINE> return ret <NEWLINE> <DEDENT> print ( dfs ( 0 , <STRING> ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> b = list ( map ( int , inputs ( ) . split ( ) ) ) <NEWLINE> ans = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> for j in range ( len ( b ) ) : <NEWLINE> <INDENT> if b [ j ] == j + 1 : <NEWLINE> <INDENT> ans . append ( b . pop ( j ) ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> for i in range ( N - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> print ( ans [ i ] ) <NEWLINE> <DEDENT>
from string import ascii_lowercase <NEWLINE> from functools import reduce <NEWLINE> from operator import mul <NEWLINE> n = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> print ( reduce ( lambda x , y : x * y % mod , S . count ( c ) + 1 for c in ascii_lowercase ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> s = list ( input ( ) ) <NEWLINE> from collections import Counter <NEWLINE> d = Counter ( s ) <NEWLINE> ans = 1 <NEWLINE> for v in d . values ( ) : <NEWLINE> <INDENT> ans *= ( v + 1 <NEWLINE> <DEDENT> ans -= 1 <NEWLINE> ans = ans % ( 10 ** 9 + 7 ) <NEWLINE> print ( ans ) <NEWLINE>
a = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( 2 ) ] <NEWLINE> a [ 0 ] [ 0 ] = H <NEWLINE> a [ 0 ] [ 1 ] = W <NEWLINE> a [ 1 ] [ 0 ] = h <NEWLINE> a [ 1 ] [ 1 ] = w <NEWLINE> my_result = H * W - h * W - H * w + h * w <NEWLINE> print ( my_result ) <NEWLINE>
H1 , W1 = map ( int , input ( ) . split ( ) ) <NEWLINE> H2 , W2 = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> H = H1 - H2 <NEWLINE> W = W1 - W2 <NEWLINE> <NL> print ( HW ) <NEWLINE>
H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <INDENT> print ( max ( H * W - h * W - ( H - h ) * w , 0 ) ) <NEWLINE> <DEDENT>
H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> h , w = = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( ( H - h ) * ( W - w ) ) <NEWLINE>
3 2 <NEWLINE> 2 1 <NEWLINE>
H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> h . w = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( H * W - h * W - w * H + h * w ) <NEWLINE>
3 2 <NEWLINE> 2 1 <NEWLINE>
HW = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( 2 ) ] <NEWLINE> print ( ( HW [ 0 ] [ 0 ] - HW [ 1 ] [ 0 ] ) * ( HW [ 0 ] [ 1 ] - HW [ 1 ] [ 1 ] ) <NEWLINE>
a , b = map ( input ( ) . split ( <STRING> ) ) <NEWLINE> c , d = map ( input ( ) . split ( <STRING> ) ) <NEWLINE> print ( ( a - c ) * ( b - d ) ) <NEWLINE>
H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> h , w = map ( int , input ( ) , split ( ) ) <NEWLINE> print ( ( H - h ) * ( W - w ) ) <NEWLINE>
a , b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c , d = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> x = a * b <NEWLINE> print ( x - a * c - b * ) <NEWLINE>
a , b = input ( ) . split ( ) <NEWLINE> c , d = input ( ) . split ( ) <NEWLINE> print ( ( a - c ) * ( b - d ) ) <NEWLINE>
h , w = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> _ , _ = input ( ) <NEWLINE> <NL> print ( h * w - ( h + w - 1 ) ) <NEWLINE>
HW = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> hw = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> print ( ( HW [ 0 ] - hw [ 0 ] ) ( HW [ 1 ] - hw [ 1 ] ) ) <NEWLINE>
N , M , C = map ( int , input ( ) . split ( ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> count = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> p = C <NEWLINE> for j in range ( M ) : <NEWLINE> <INDENT> P += A [ j ] * B [ j ] <NEWLINE> if p > 0 : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
N , M , H = list ( map ( int ( ) . input ( ) , split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> count = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> for k in range ( M ) : <NEWLINE> <INDENT> ans += A [ k ] * B [ k ] <NEWLINE> <DEDENT> if ans + H > : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
N , M , C = map ( int , input ( ) . split ( ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A = [ 0 ] * N <NEWLINE> count = 0 <NEWLINE> <NL> for n in range ( N ) : <NEWLINE> <INDENT> A [ n ] = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in range ( M ) : <NEWLINE> <INDENT> _sum += A [ n ] [ i ] * B [ i ] <NEWLINE> <NL> <DEDENT> if _sum + C > 0 : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
n , m , c = map ( int , input ( ) . split ( ) ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( n ) ] <NEWLINE> cnt = 0 <NEWLINE> <NL> for l in a : <NEWLINE> <INDENT> tmp = 0 <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> tmp += b [ i ] * a [ i ] <NEWLINE> <DEDENT> tmp += c <NEWLINE> if tmp > 0 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
3 3 0 <NEWLINE> 100 - 100 0 <NEWLINE> 0 100 100 <NEWLINE> 100 100 100 <NEWLINE> - 100 100 100 <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <NL> n , m , c = map ( int , input ( ) . split ( ) ) <NEWLINE> B = np . array ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> K = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> K . append ( A ) <NEWLINE> <NL> <DEDENT> import numpy as np <NEWLINE> pp = np . array ( K ) <NEWLINE> l = ( pp * B ) . sum ( axis = 1 ) + c <NEWLINE> <NL> t = 0 <NEWLINE> for i in range ( len ( l ) ) : <NEWLINE> <INDENT> if l [ i ] > 0 : <NEWLINE> <INDENT> t += 1 <NEWLINE> <DEDENT> <DEDENT> print ( t ) <NEWLINE>
N , M , C = map ( int , input ( ) . split ( ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> count = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for j in range ( M ) : <NEWLINE> P = C <NEWLINE> P += B [ j ] * a [ j ] <NEWLINE> if P > 0 : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
import numpy as np <NEWLINE> n , m , c = map ( int , input ( ) . split ( ) ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> num = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> hoge = np . dot ( b * a ) + c <NEWLINE> if hoge > 0 : <NEWLINE> <INDENT> num += 1 <NEWLINE> <DEDENT> <DEDENT> print ( num ) <NEWLINE>
N , M , C = map ( int , input ( ) . split ( ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> Ai = [ input ( ) . split ( ) for l in range ( N ) ] <NEWLINE> count = 0 <NEWLINE> tot = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> for j in range ( M ) : <NEWLINE> <INDENT> tot += Ai [ i ] [ j ] * B [ i ] <NEWLINE> if tot + C > 0 : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
<COMMENT> <NL> import numpy as np <NEWLINE> N , M , C = inpl ( ) <NEWLINE> B = np . array ( inpl ( ) , dtype = np . int64 ) <NEWLINE> ans = 0 <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> A = np . array ( inpl ( ) , dtype = np . int64 ) <NEWLINE> ans += np . sum ( A * B ) + C > 0 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> d = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> d . append ( [ a , b ] ) <NEWLINE> <NL> <DEDENT> d . sort ( key = lambda x : x [ 0 ] ) <NEWLINE> <NL> sum_ = 0 <NEWLINE> cnt = 0 <NEWLINE> for ab in d : <NEWLINE> <INDENT> if cnt + ab [ 1 ] > M : <NEWLINE> <INDENT> sum_ += ab [ 0 ] * ( M - cnt ) <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cnt += ab [ 1 ] <NEWLINE> sum_ += ab [ 0 ] * ab [ 1 ] <NEWLINE> <DEDENT> <DEDENT> print ( sum_ ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> list = [ ] <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> list . append ( [ a , b ] ) <NEWLINE> <DEDENT> list . sort ( ) <NEWLINE> ans = 0 <NEWLINE> for a , b in l : <NEWLINE> <INDENT> ans += min ( b , M ) * a <NEWLINE> M = max ( 0 , M - b ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> AB = { } <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> AB [ A ] = B <NEWLINE> <DEDENT> AB = sorted ( AB . items ( ) , key = lambda x : x [ 0 ] ) <NEWLINE> <NL> acost = 0 <NEWLINE> <NL> for a , b in AB : <NEWLINE> <INDENT> cost += ( min ( max ( M , 0 ) , b ) ) * a <NEWLINE> M -= b <NEWLINE> if M <= 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> print ( cost ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> ab = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ] <NEWLINE> ab . sort ( ) <NEWLINE> ans = 0 <NEWLINE> cnt = 0 <NEWLINE> i = 0 <NEWLINE> while cnt < m : <NEWLINE> <INDENT> ans += ab [ i ] [ 0 ] * ab [ i ] [ 1 ] <NEWLINE> cnt += ab [ i ] [ 1 ] <NEWLINE> i += 1 <NEWLINE> <DEDENT> print ( ans - ( cnt - m ) * ab [ i ] [ 0 ] ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ ] <NEWLINE> B = [ ] <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> A . append ( a ) <NEWLINE> B . append ( b ) <NEWLINE> <DEDENT> C = sorted ( A ) <NEWLINE> while M > 0 : <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> ab = sorted ( [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( n ) ] ) <NEWLINE> shop , cost , rest = m , 0 , 0 <NEWLINE> while True : <NEWLINE> <INDENT> if ab [ shop ] [ 1 ] < rest : <NEWLINE> <INDENT> cost += ab [ shop ] [ 1 ] * ab [ shop ] [ 0 ] <NEWLINE> rest -= ab [ shop ] [ 1 ] <NEWLINE> shop += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cost += ab [ shop ] [ 0 ] * rest <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( cost ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> drink = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( n ) ] <NEWLINE> <COMMENT> <NL> <NL> drink . sort ( ) <NEWLINE> <COMMENT> <NL> money = 0 <NEWLINE> number = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if number + drink [ i ] [ 0 ] = < m : <NEWLINE> <INDENT> money += drink [ i ] [ 0 ] * drink [ i ] [ 1 ] <NEWLINE> number += drink [ i ] [ 1 ] <NEWLINE> <DEDENT> elif m < number + drink [ i ] [ 0 ] : <NEWLINE> <INDENT> money += drink [ i ] [ 0 ] * ( m - number ) <NEWLINE> number += m - number <NEWLINE> break <NEWLINE> <DEDENT> if m == number : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> print ( money ) <NEWLINE>
A , B , C = map ( int , input ( ) ) <NEWLINE> if A * C <= B : <NEWLINE> <INDENT> print ( C ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( B // A ) <NEWLINE> <DEDENT>
A , B , C = map ( int , input ( ) ) <NEWLINE> print ( max ( B // A , C ) ) <NEWLINE>
<COMMENT> <NL> <NL> input_data = input ( ) . split ( ) <NEWLINE> <NL> d1 = input_data [ 0 ] <NEWLINE> d2 = input_data [ 1 ] <NEWLINE> d3 = input_data [ 2 ] <NEWLINE> total = 0 <NEWLINE> <NL> d4 = d2 % d1 <NEWLINE> if d4 > d3 : <NEWLINE> <INDENT> total += 1 <NEWLINE> <NL> <DEDENT> print ( total ) <NEWLINE>
a , b , c = map ( input ( ) . split ( ) ) <NEWLINE> if a * c > b : <NEWLINE> <INDENT> print ( b // a ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( c ) <NEWLINE> <DEDENT>
a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( min ( c , b // a ) <NEWLINE>
a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( min ( n // a , c ) ) <NEWLINE>
a , b , k = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> min = a <NEWLINE> if b < min : <NEWLINE> <INDENT> min = b <NEWLINE> <NL> <DEDENT> ans_lists = [ ] <NEWLINE> for i in range ( 1 , min + 1 , 1 ) : <NEWLINE> <INDENT> if a % i == 0 and b % i == 0 : <NEWLINE> <INDENT> ans_lists . append ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> ans_lists . reverse ( ) <NEWLINE> ans = lists [ k - 1 ] <NEWLINE> <NL> print ( ans ) <NEWLINE>
A , B , K = map ( int , input ( ) . split ( ) ) <NEWLINE> cnt = 0 <NEWLINE> <NL> for i in range ( 100 , 0 , - 1 ) : <NEWLINE> <INDENT> if A % i == 0 and B % i == 0 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> if cnt = K : <NEWLINE> <INDENT> print ( i ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
a , b , k = map ( int , input ( ) . split ( ) ) <NEWLINE> N = <STRING> <NEWLINE> for i in range ( 1 , min ( a , b ) ) : <NEWLINE> <INDENT> if a % i == 0 and b % i == 0 : <NEWLINE> <INDENT> N . append ( i ) <NEWLINE> <DEDENT> <DEDENT> N . reverse ( ) <NEWLINE> print ( N [ k - 1 ] ) <NEWLINE>
a , b , k = map ( int , input ( ) . split ( ) ) <NEWLINE> p = [ ] <NEWLINE> for i in range ( a ) : <NEWLINE> <INDENT> if a % i == 0 and b % i == 0 : <NEWLINE> <INDENT> p . append ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> n = len ( p ) <NEWLINE> print ( p [ n - k ] ) <NEWLINE>
<COMMENT> <NL> l = [ ] <NEWLINE> for i in range ( 1 , 100 ) : <NEWLINE> <INDENT> if ( a % i == 0 ) & ( b % i == 0 ) : <NEWLINE> <INDENT> l . append ( i ) <NEWLINE> <DEDENT> <DEDENT> print ( l [ k - 1 ] ) <NEWLINE>
a , b , k = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = [ ] <NEWLINE> <NL> for i in range ( 1 , min ( a , b ) + 1 ) : <NEWLINE> <INDENT> if a % i == 0 and b % i == 0 : <NEWLINE> <INDENT> ans . append ( i ) <NEWLINE> <DEDENT> <DEDENT> print ( ans [ k + 1 ] ) <NEWLINE>
abk = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> a = abk [ 0 ] <NEWLINE> b = abk [ 1 ] <NEWLINE> k = abk [ 2 ] <NEWLINE> <NL> anss = [ ] <NEWLINE> for i in range ( 1 , min ( a , b ) + 1 ) : <NEWLINE> <INDENT> if a % i == 0 and b % i == 0 : <NEWLINE> <INDENT> anss . append ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> anns . sort ( reverse = True ) <NEWLINE> print ( anss [ k - 1 ] ) <NEWLINE>
A , B , K = map ( int , input ( ) . split ( ) ) <NEWLINE> div = [ ] <NEWLINE> <NL> for i in range ( 1 , 100 ) : <NEWLINE> <INDENT> if a % i == 0 and b % i == 0 : <NEWLINE> <INDENT> div . append ( i ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( sorted ( div ) [ - K ] <NEWLINE>
A , B , K = map ( int , input ( ) . split ( ) ) <NEWLINE> l = [ ] <NEWLINE> for i in range ( 101 ) : <NEWLINE> <INDENT> if A % i == 0 and B % i == 0 : <NEWLINE> <INDENT> l . append ( i ) <NEWLINE> <DEDENT> <DEDENT> print ( l [ i - 1 ] ) <NEWLINE>
A , B , K = map ( int , input ( ) . split ( ) ) <NEWLINE> i = 0 <NEWLINE> j = 0 <NEWLINE> while i < K : <NEWLINE> <INDENT> j += 1 <NEWLINE> if A * % j == 0 and B % j == 0 : <NEWLINE> <INDENT> i += 1 <NEWLINE> <DEDENT> <DEDENT> print ( j ) <NEWLINE>
A , B , K = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( ( i for i in range ( 1 , 101 ) if A % i + B % i < 1 ) [ - K ] ) <NEWLINE>
a , b , k = map ( int , input ( ) . split ( ) ) <NEWLINE> l = [ ] <NEWLINE> <NL> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if a % i == 0 and b % i == 0 : <NEWLINE> <INDENT> l . append ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( l [ k - 1 ] ) <NEWLINE>
a , b , c = input ( ) . split ( ) <NEWLINE> a = int ( a ) <NEWLINE> b = int ( b ) <NEWLINE> c = int ( c ) <NEWLINE> count = 0 <NEWLINE> while count < c : <NEWLINE> <INDENT> for i in range ( 100 , 0 ) : <NEWLINE> <INDENT> if a % i == 0 and b % i == 0 : <NEWLINE> <INDENT> count = count + 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( i ) <NEWLINE>
A , B , K = map ( int , input ( ) . split ( ) ) <NEWLINE> check = 0 <NEWLINE> res = 0 <NEWLINE> for i in range ( 100 ) : <NEWLINE> <INDENT> if A % i == 0 and B % i == 0 : <NEWLINE> <INDENT> check += 1 <NEWLINE> if check == K : <NEWLINE> <INDENT> res = i <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( res ) <NEWLINE>
def next_check ( cubes ) : <NEWLINE> <INDENT> index_list = [ ] <NEWLINE> for cube_index in reversed ( range ( 1 , len ( cubes ) ) ) : <NEWLINE> <INDENT> if ( ( cube_index not in index_list ) and ( cubes [ cube_index ] == cubes [ cube_index - 1 ] ) ) : <NEWLINE> <INDENT> index_list . append ( cube_index - 1 ) <NEWLINE> index_list . append ( cube_index ) <NEWLINE> <DEDENT> <DEDENT> l = len ( index_list ) <NEWLINE> for i in reversed ( index_list ) : <NEWLINE> <INDENT> cubes . pop ( i ) <NEWLINE> <DEDENT> return ( cubes , l ) <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> cubes = input ( ) <NEWLINE> for c in cubes : <NEWLINE> <INDENT> if c not in [ <STRING> , <STRING> ] : <NEWLINE> <INDENT> exit ( 0 ) <NEWLINE> <DEDENT> <DEDENT> cube_list = [ ] <NEWLINE> for cube in cubes : <NEWLINE> <INDENT> cube_list . append ( cube ) <NEWLINE> <DEDENT> l = len ( cube_list ) <NEWLINE> k = 0 <NEWLINE> while ( l != 0 ) : <NEWLINE> <INDENT> cubes , l = next_check ( cube_list ) <NEWLINE> k += l <NEWLINE> <DEDENT> print ( k ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> cnt1 = 0 <NEWLINE> cnt2 = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> cnt1 += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cnt2 += 1 <NEWLINE> <DEDENT> <DEDENT> print ( min ( cnt1 , cnt2 ) * 2 ) <NEWLINE>
S = input ( ) <NEWLINE> List = list ( S ) <NEWLINE> zeroNum = List . count ( <STRING> ) <NEWLINE> oneNum = List . count ( <STRING> ) <NEWLINE> res = min ( reroNum , oneNum ) <NEWLINE> print ( res * 2 ) <NEWLINE>
import sys <NEWLINE> <NL> <NL> class UnionFind : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . table = [ - 1 ] * n <NEWLINE> <NL> <DEDENT> def _root ( self , x ) : <NEWLINE> <INDENT> stack = [ ] <NEWLINE> tbl = self . table <NEWLINE> while tbl [ x ] >= 0 : <NEWLINE> <INDENT> stack . append ( x ) <NEWLINE> x = tbl [ x ] <NEWLINE> <DEDENT> for y in stack : <NEWLINE> <INDENT> tbl [ y ] = x <NEWLINE> <DEDENT> return x <NEWLINE> <NL> <DEDENT> def find ( self , x , y ) : <NEWLINE> <INDENT> return self . _root ( x ) == self . _root ( y ) <NEWLINE> <NL> <DEDENT> def union ( self , x , y ) : <NEWLINE> <INDENT> r1 = self . _root ( x ) <NEWLINE> r2 = self . _root ( y ) <NEWLINE> if r1 == r2 : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> d1 = self . table [ r1 ] <NEWLINE> d2 = self . table [ r2 ] <NEWLINE> if d1 <= d2 : <NEWLINE> <INDENT> self . table [ r2 ] = r1 <NEWLINE> self . table [ r1 ] += d2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . table [ r1 ] = r2 <NEWLINE> self . table [ r2 ] += d1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <INDENT> n , m , k = map ( int , sys . stdin . buffer . readline ( ) . split ( ) ) <NEWLINE> uf = UnionFind ( n ) <NEWLINE> fb = [ 0 ] * n <NEWLINE> i = 0 <NEWLINE> for x in sys . stdin . buffer . readlines ( ) : <NEWLINE> <INDENT> if i < m : <NEWLINE> <INDENT> a , b = map ( int , x . split ( ) ) <NEWLINE> fb [ a - 1 ] += 1 <NEWLINE> fb [ b - 1 ] += 1 <NEWLINE> uf . union ( a - 1 , b - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> c , d = map ( int , x . split ( ) ) <NEWLINE> fb [ c - 1 ] += 1 <NEWLINE> fb [ d - 1 ] += 1 <NEWLINE> <DEDENT> i += 1 <NEWLINE> <NL> <DEDENT> ans = [ - uf . table [ uf . _root ( i ) ] - 1 - fb [ i ] for i in range ( n ) ] <NEWLINE> print ( * ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> <NL> class UnionFind ( ) : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . n = n <NEWLINE> self . parents = [ - 1 ] * n <NEWLINE> <NL> <DEDENT> def find ( self , x ) : <NEWLINE> <INDENT> if self . parents [ x ] < 0 : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . parents [ x ] = self . find ( self . parents [ x ] ) <NEWLINE> return self . parents [ x ] <NEWLINE> <NL> <DEDENT> <DEDENT> def union ( self , x , y ) : <NEWLINE> <INDENT> x = self . find ( x ) <NEWLINE> y = self . find ( y ) <NEWLINE> <NL> if x == y : <NEWLINE> <INDENT> return <NEWLINE> <NL> <DEDENT> if self . parents [ x ] > self . parents [ y ] : <NEWLINE> <INDENT> x , y = y , x <NEWLINE> <NL> <DEDENT> self . parents [ x ] += self . parents [ y ] <NEWLINE> self . parents [ y ] = x <NEWLINE> <NL> <DEDENT> def size ( self , x ) : <NEWLINE> <INDENT> return - self . parents [ self . find ( x ) ] <NEWLINE> <NL> <DEDENT> def same ( self , x , y ) : <NEWLINE> <INDENT> return self . find ( x ) == self . find ( y ) <NEWLINE> <NL> <DEDENT> def members ( self , x ) : <NEWLINE> <INDENT> root = self . find ( x ) <NEWLINE> return [ i for i in range ( self . n ) if self . find ( i ) == root ] <NEWLINE> <NL> <DEDENT> def roots ( self ) : <NEWLINE> <INDENT> return [ i for i , x in enumerate ( self . parents ) if x < 0 ] <NEWLINE> <NL> <DEDENT> def group_count ( self ) : <NEWLINE> <INDENT> return len ( self . roots ( ) ) <NEWLINE> <NL> <DEDENT> def all_group_members ( self ) : <NEWLINE> <INDENT> return { r : self . members ( r ) for r in self . roots ( ) } <NEWLINE> <NL> <DEDENT> def __str__ ( self ) : <NEWLINE> <INDENT> return <STRING> . join ( <STRING> . format ( r , self . members ( r ) ) for r in self . roots ( ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> N , M = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> uf = UnionFind ( N ) <NEWLINE> A = [ 0 ] * M <NEWLINE> B = [ 0 ] * M <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> a , b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A [ i ] = a - 1 <NEWLINE> B [ i ] = b - 1 <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> cmax = int ( N * ( N - 1 ) / 2 ) <NEWLINE> FD = [ cmax ] * ( M + 1 ) <NEWLINE> <COMMENT> <NL> for i in range ( M ) : <NEWLINE> <COMMENT> <NL> <INDENT> if same ( A [ M - i - 1 ] ) * uf . size ( B [ M - i - 1 ] ) : <NEWLINE> <INDENT> FD [ M - i - 1 ] = FD [ M - i ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cless = uf . size ( A [ M - i - 1 ] ) * uf . size ( B [ M - i - 1 ] ) <NEWLINE> FD [ M - i - 1 ] = FD [ M - i ] - cless <NEWLINE> if FD [ M - i - 1 ] < 0 : FD [ M - i - 1 ] = 0 <NEWLINE> <DEDENT> uf . union ( A [ M - 1 - i ] , B [ M - 1 - i ] ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> for fd in FD [ 1 : ] : <NEWLINE> <INDENT> print ( fd ) <NEWLINE> <NL> <NL> <DEDENT>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> <NL> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> par = [ i for i in range ( n + 1 ) ] <NEWLINE> rank = [ 0 ] * ( n + 1 ) <NEWLINE> size = [ 1 ] * ( n + 1 ) <NEWLINE> <NL> def root ( x ) : <NEWLINE> <INDENT> if par [ x ] == x : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> par [ x ] = root ( par [ x ] ) <NEWLINE> return par [ x ] <NEWLINE> <NL> <DEDENT> <DEDENT> def same ( x , y ) : <NEWLINE> <INDENT> return root ( x ) == root ( y ) <NEWLINE> <NL> <DEDENT> def unite ( x , y ) : <NEWLINE> <INDENT> xx = root ( x ) <NEWLINE> yy = root ( y ) <NEWLINE> if xx == yy : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> if rank [ xx ] < rank [ yy ] : <NEWLINE> <INDENT> par [ xx ] = yy <NEWLINE> size [ yy ] += size [ xx ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> par [ yy ] = xx <NEWLINE> size [ xx ] += size [ yy ] <NEWLINE> if rank [ xx ] == rank [ yy ] : <NEWLINE> <INDENT> rank [ yy ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> ab = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( m ) ] <NEWLINE> <NL> ans = [ 0 ] * m <NEWLINE> ans [ m - 1 ] = n * ( n - 1 ) // 2 <NEWLINE> <NL> for i in range ( M - 1 , 0 , - 1 ) : <NEWLINE> <INDENT> a = ab [ i ] [ 0 ] <NEWLINE> b = ab [ i ] [ 1 ] <NEWLINE> if root ( a ) != root ( b ) : <NEWLINE> <INDENT> ans [ i - 1 ] = ans [ i ] - size [ root ( a ) ] * size [ root ( b ) ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans [ i - 1 ] = ans [ i ] <NEWLINE> <DEDENT> unite ( a , b ) <NEWLINE> <NL> <DEDENT> for ans_i in ans : <NEWLINE> <INDENT> print ( ans_i ) <NEWLINE> <DEDENT>
S = input ( ) <NEWLINE> print ( <STRING> if S [ 6 ] >= 5 or S [ 5 ] >= 1 else <STRING> ) <NEWLINE>
s = input ( ) <NEWLINE> if s <= 2019 / 0 4 / 30 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
y , m , d = int ( input ( ) . split ( <STRING> ) ) <NEWLINE> print ( <STRING> if y <= 2019 and m <= 4 and d <= 30 else <STRING> ) <NEWLINE>
S = input ( ) <NEWLINE> l = S . split ( <STRING> ) <NEWLINE> if l [ 0 ] <= 2019 : <NEWLINE> <INDENT> if l [ 1 ] <= 4 : <NEWLINE> <INDENT> if l [ 2 ] <= 30 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> s = s . split ( <STRING> ) <NEWLINE> <NL> if s [ 0 ] >= 2019 and s [ 1 ] >= 5 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> if s [ 5 ] = <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif int ( s [ 6 ] ) >= 5 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
y , m , d = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> if y < 2020 and m < 0 5 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s = str ( input ( ) ) <NEWLINE> year = <STRING> <NEWLINE> month = <STRING> <NEWLINE> day = <STRING> <NEWLINE> <NL> for i in range ( 4 ) : <NEWLINE> <INDENT> y = s [ i ] <NEWLINE> year += y <NEWLINE> <DEDENT> for i in range ( 5 , 7 ) : <NEWLINE> <INDENT> m = s [ i ] <NEWLINE> month += m <NEWLINE> <DEDENT> for i in range ( 9 , 11 ) : <NEWLINE> <INDENT> d = s [ i ] <NEWLINE> day += d <NEWLINE> <NL> <DEDENT> year = int ( year ) <NEWLINE> month = int ( month ) <NEWLINE> day = int ( day ) <NEWLINE> <NL> if year < 2019 : <NEWLINE> <INDENT> answer = <STRING> <NEWLINE> <NL> <DEDENT> elif year == 2019 and month <= 4 : <NEWLINE> <INDENT> answer = <STRING> <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> answer = <STRING> <NEWLINE> <NL> <DEDENT> print ( answer ) <NEWLINE>
s = input ( ) <NEWLINE> if s [ 5 ] == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if s [ 6 ] > 4 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
s = map ( str , input ( ) . split ( ) ) <NEWLINE> if int ( s [ 5 ] ) == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif int ( s [ 6 ] ) <= 4 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a = input ( ) <NEWLINE> if a [ 6 ] > 4 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a [ 6 ] < 3 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if a [ 8 ] < 2 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if a [ 9 ] > 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
s = input ( ) <NEWLINE> <NL> year = s [ : 4 ] <NEWLINE> mo = s [ 5 : 7 ] <NEWLINE> da = s [ 8 : ] <NEWLINE> <NL> if year < 2019 : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <DEDENT> elif year == 2019 and mo <= 4 : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> sum = 0 <NEWLINE> for j in range ( n ) : <NEWLINE> <INDENT> i , c = input ( ) . split ( ) <NEWLINE> if c == <STRING> : <NEWLINE> <INDENT> sum += float ( i ) * 380000 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> sum += i <NEWLINE> <DEDENT> <DEDENT> print ( sum ) <NEWLINE>
a = int ( input ( ) ) <NEWLINE> b = [ input ( ) . split ( ) for i in range ( a ) ] <NEWLINE> c = 0 <NEWLINE> for i in range ( a ) : <NEWLINE> <INDENT> if b [ i ] [ 1 ] == <STRING> : <NEWLINE> <INDENT> c = c + int ( b [ i ] [ 0 ] ) <NEWLINE> <DEDENT> if b [ i ] [ 1 ] == <STRING> : <NEWLINE> <INDENT> c = c + int ( b [ i ] [ 0 ] ) * 380000 <NEWLINE> <DEDENT> <DEDENT> print ( c ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <NL> <NL> def calculation ( lines ) : <NEWLINE> <COMMENT> <NL> <INDENT> N = int ( lines [ 0 ] ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> result = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> line = lines [ i + 1 ] <NEWLINE> if <STRING> in line : <NEWLINE> <INDENT> result += int ( line . replace ( <STRING> , <STRING> ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> result += float ( line . replace ( <STRING> , <STRING> ) ) * 380000.0 <NEWLINE> <NL> <DEDENT> <DEDENT> return [ result ] <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> def get_input_lines ( ) : <NEWLINE> <INDENT> line = input ( ) <NEWLINE> N , M = list ( map ( int , line . split ( ) ) ) <NEWLINE> lines = list ( ) <NEWLINE> lines . append ( line ) <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> lines . append ( input ( ) ) <NEWLINE> <DEDENT> return lines <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> def get_testdata ( pattern ) : <NEWLINE> <INDENT> if pattern == 1 : <NEWLINE> <INDENT> lines_input = [ <STRING> , <STRING> , <STRING> ] <NEWLINE> lines_export = [ 48000.0 ] <NEWLINE> <DEDENT> if pattern == 2 : <NEWLINE> <INDENT> lines_input = [ <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> lines_export = [ 138000000.0038 ] <NEWLINE> <DEDENT> return lines_input , lines_export <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> def get_mode ( ) : <NEWLINE> <INDENT> import sys <NEWLINE> args = sys . argv <NEWLINE> if len ( args ) == 1 : <NEWLINE> <INDENT> mode = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> mode = int ( args [ 1 ] ) <NEWLINE> <DEDENT> return mode <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> import time <NEWLINE> started = time . time ( ) <NEWLINE> mode = get_mode ( ) <NEWLINE> if mode == 0 : <NEWLINE> <INDENT> lines_input = get_input_lines ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> lines_input , lines_export = get_testdata ( mode ) <NEWLINE> <NL> <DEDENT> lines_result = calculation ( lines_input ) <NEWLINE> <NL> for line_result in lines_result : <NEWLINE> <INDENT> print ( line_result ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> x , u = map ( int , str , input ( ) . split ( ) ) <NEWLINE> if u == <STRING> : <NEWLINE> <INDENT> x = x * 380000 <NEWLINE> <DEDENT> ans = ans + x <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> x , u = map ( str , input ( ) . split ( ) ) <NEWLINE> x = int ( x ) <NEWLINE> if u == <STRING> : <NEWLINE> <INDENT> x *= 380000 <NEWLINE> <DEDENT> ans += x <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
from decimal import Decimal <NEWLINE> n = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for in range ( n ) : <NEWLINE> <INDENT> x , y = map ( str , input ( ) . split ( ) ) <NEWLINE> if y == <STRING> : <NEWLINE> <INDENT> ans += Decimal ( 380000 * Decimal ( x ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += Decimal ( x ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> import math <NEWLINE> import itertools <NEWLINE> import collections <NEWLINE> import heapq <NEWLINE> import re <NEWLINE> import numpy as np <NEWLINE> <NL> rr = lambda : sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> rs = lambda : sys . stdin . readline ( ) . split ( ) <NEWLINE> ri = lambda : int ( sys . stdin . readline ( ) ) <NEWLINE> rm = lambda : map ( int , sys . stdin . readline ( ) . split ( ) ) <NEWLINE> rl = lambda : list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) <NEWLINE> inf = float ( <STRING> ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> n = ri ( ) <NEWLINE> ans = 0 <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> a , b = rs ( ) <NEWLINE> if b == <STRING> : <NEWLINE> <INDENT> ans += float ( a ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += float ( a ) * 380000 <NEWLINE> <DEDENT> <DEDENT> pritn ( ans ) <NEWLINE> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL>
N = int ( input ( ) ) <NEWLINE> s = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> x , u = map ( str , input ( ) . split ( ) ) <NEWLINE> if u == <STRING> : <NEWLINE> <INDENT> s += int ( x ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s += 380000 * int ( x ) <NEWLINE> <DEDENT> <DEDENT> print ( s ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> xu = input ( ) . split ( ) <NEWLINE> if xu [ 1 ] == <STRING> : <NEWLINE> <INDENT> ans += xu [ 0 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += xu [ 0 ] * 380000 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
Row = int ( input ( ) ) <NEWLINE> List = [ ] <NEWLINE> for i in range ( Row ) : <NEWLINE> <INDENT> List . append ( list ( map ( str , input ( ) . split ( ) ) ) ) <NEWLINE> <DEDENT> res = 0 <NEWLINE> for i in range ( Row ) : <NEWLINE> <INDENT> if List [ i ] [ 1 ] = <STRING> : <NEWLINE> <INDENT> res += int ( List [ i ] [ 0 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> res += int ( List [ i ] [ 0 ] ) * 380000 <NEWLINE> <DEDENT> <DEDENT> print ( res ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a , b = map ( str , input ( ) . split ( ) ) <NEWLINE> if b = <STRING> : <NEWLINE> <INDENT> ans += int ( a ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += int ( a ) * 380000 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
btc = 380000 <NEWLINE> N = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> x , u = input ( ) . split ( ) <NEWLINE> if u == <STRING> : <NEWLINE> <INDENT> ans += int ( x ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += int ( x ) * btc <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> v , c = map ( int , input ( ) . split ( ) ) <NEWLINE> if c == <STRING> : <NEWLINE> <INDENT> a += v <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a += v * 380000.0 <NEWLINE> <DEDENT> <DEDENT> print ( a ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> kei = 0.0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> x , u = map ( str , input ( ) . split ( ) ) <NEWLINE> if u == <STRING> : <NEWLINE> <INDENT> kei += float ( x [ i ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> kei += float ( x [ i ] ) * 380000.0 <NEWLINE> <DEDENT> <DEDENT> print ( kei ) <NEWLINE>
def resolve ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> s = 0 <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> x , u = input ( ) . split ( ) <NEWLINE> if u == <STRING> : <NEWLINE> <INDENT> s += float ( x ) * 380000 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s += float ( x ) * 1 <NEWLINE> <DEDENT> <DEDENT> print ( s ) <NEWLINE> <DEDENT> resole ( ) <NEWLINE>
n , a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> l = [ int ( input ( ) ) for i in range ( n ) ] <NEWLINE> def dfs ( i , x , y , z ) : <NEWLINE> <INDENT> if i == n : return abs ( a - x ) + abs ( b - y ) + abs ( c - z ) - 30 if a + b + c >= 3 else 10 ** 9 + 7 <NEWLINE> A , B , C , D = dfs ( i + 1 , x , y , z ) , dfs ( i + 1 , x + l [ i ] , y , z ) + 10 , dfs ( i + 1 , x , y + l [ i ] , z ) + 10 , dfs ( i + 1 , x , y , z + l [ i ] ) + 10 <NEWLINE> return min ( A , B , C , D ) <NEWLINE> <DEDENT> print ( dfs ( 0 , 0 , 0 , 0 ) <NEWLINE>
from bisect import bisect_left <NEWLINE> <NL> A , B , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> S = [ int ( input ( ) ) for i in range ( A ) ] <NEWLINE> T = [ int ( input ( ) ) for i in range ( B ) ] <NEWLINE> for i in range ( Q ) : <NEWLINE> <INDENT> x = int ( input ( ) ) <NEWLINE> si = bisect_left ( S , x ) <NEWLINE> ti = bisect_left ( T , x ) <NEWLINE> if 0 < si < A and 0 < ti < B : <NEWLINE> <INDENT> sl , sr = abs ( x - S [ si - 1 ] ) , abs ( x - S [ si ] ) <NEWLINE> tl , tr = abs ( x - T [ ti - 1 ] ) , abs ( x - T [ ti ] ) <NEWLINE> print ( min ( max ( sr , tr ) , max ( sl , tl ) , sl + tr + min ( sl , tr ) , sr + tl + min ( sr , tl ) ) ) <NEWLINE> <DEDENT> elif si == 0 and ti == 0 : <NEWLINE> <INDENT> sr = abs ( x - S [ si ] ) <NEWLINE> tr = abs ( x - T [ ti ] ) <NEWLINE> print ( sr , tr ) <NEWLINE> <DEDENT> elif si == A and ti == B : <NEWLINE> <INDENT> sl = abs ( x - S [ si - 1 ] ) , abs ( x - S [ si ] ) <NEWLINE> tl = abs ( x - T [ ti - 1 ] ) , abs ( x - T [ ti ] ) <NEWLINE> print ( max ( sl , tl ) ) <NEWLINE> <DEDENT> elif si == 0 and ti == B : <NEWLINE> <INDENT> sr = abs ( x - S [ si ] ) <NEWLINE> tl = abs ( x - T [ ti - 1 ] ) <NEWLINE> print ( sr + tl + min ( sr , tl ) ) <NEWLINE> <DEDENT> elif si == A and ti == 0 : <NEWLINE> <INDENT> sl = abs ( x - S [ si - 1 ] ) <NEWLINE> tr = abs ( x - T [ ti ] ) <NEWLINE> print ( sl + tr + min ( sl , tr ) ) <NEWLINE> <DEDENT> elif si == 0 : <NEWLINE> <INDENT> sr = abs ( x - S [ si ] ) <NEWLINE> tl , tr = abs ( x - T [ ti - 1 ] ) , abs ( x - T [ ti ] ) <NEWLINE> print ( min ( max ( sr , tr ) , sr + tl + min ( sr , tl ) ) ) <NEWLINE> <DEDENT> elif si == A : <NEWLINE> <INDENT> sl = abs ( x - S [ si - 1 ] ) <NEWLINE> tl , tr = abs ( x - T [ ti - 1 ] ) , abs ( x - T [ ti ] ) <NEWLINE> print ( min ( max ( sl , tl ) , sl + tr + min ( sl , tr ) ) ) <NEWLINE> <DEDENT> elif ti == 0 : <NEWLINE> <INDENT> sl , sr = abs ( x - S [ si - 1 ] ) , abs ( x - S [ si ] ) <NEWLINE> tr = abs ( x - T [ ti ] ) <NEWLINE> print ( min ( max ( sr , tr ) , sl + tr + min ( sl , tr ) ) ) <NEWLINE> <DEDENT> elif ti == B : <NEWLINE> <INDENT> sl , sr = abs ( x - S [ si - 1 ] ) , abs ( x - S [ si ] ) <NEWLINE> tl = abs ( x - T [ ti - 1 ] ) <NEWLINE> print ( min ( max ( sl , tl ) , sr + tl + min ( sr , tl ) ) ) <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> import re <NEWLINE> import math <NEWLINE> import collections <NEWLINE> import bisect <NEWLINE> import itertools <NEWLINE> import fractions <NEWLINE> import functools <NEWLINE> import copy <NEWLINE> import heapq <NEWLINE> import decimal <NEWLINE> import statistics <NEWLINE> import queue <NEWLINE> <NL> <COMMENT> <NL> <NL> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> INF = 10 ** 16 <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> <COMMENT> <NL> <NL> ni = lambda : int ( sys . stdin . readline ( ) ) <NEWLINE> ns = lambda : map ( int , sys . stdin . readline ( ) . split ( ) ) <NEWLINE> na = lambda : list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) <NEWLINE> na1 = lambda : list ( map ( lambda x : int ( x ) - 1 , sys . stdin . readline ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> <COMMENT> <NL> <NL> def disLR ( a , idx ) : <NEWLINE> <INDENT> small = a [ max ( 0 , idx - 1 ) ] <NEWLINE> large = a [ min ( len ( a ) - 1 , idx ) ] <NEWLINE> return small , large <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> a , b , q = ns ( ) <NEWLINE> s = [ ni ( ) for _ in range ( a ) ] <NEWLINE> t = [ ni ( ) for _ in range ( b ) ] <NEWLINE> <NL> for _ in range ( q ) : <NEWLINE> <INDENT> ans = INF <NEWLINE> <NL> x = ni ( ) <NEWLINE> <NL> idxs = bisect . bisect_left ( s , x ) <NEWLINE> a1 = [ disLR ( s , idxs ) ] <NEWLINE> <NL> idxt = bisect . bisect_left ( t , x ) <NEWLINE> a2 = [ disLR ( t , idxt ) ] <NEWLINE> <NL> for ta1 in a1 : <NEWLINE> <INDENT> for ta2 in a2 : <NEWLINE> <INDENT> tmp1 = abs ( x - a1 ) + abs ( a2 - a1 ) <NEWLINE> tmp2 = abs ( x - a2 ) + abs ( a1 - a2 ) <NEWLINE> ans = min ( ans , tmp1 , tmp2 ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
A , B = map ( int ( input ( ) . split ( ) ) ) <NEWLINE> if B % A == 0 : <NEWLINE> <INDENT> print ( A + B ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( A - B ) <NEWLINE> <DEDENT>
A , B = mao ( int , input ( ) . split ( ) ) <NEWLINE> if B % A == 0 : <NEWLINE> <INDENT> print ( A + B ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( B - A ) <NEWLINE> <DEDENT>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> b = input ( ) <NEWLINE> if b % a == 0 : <NEWLINE> <INDENT> print ( a + b ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( b - a ) <NEWLINE> <DEDENT>
<NL> def main ( ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if b / a % 0 : <NEWLINE> <INDENT> print ( a + b ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( b - a ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = [ ] * ( m + 1 ) <NEWLINE> output = 0 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> k = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for j in range ( 1 , len ( k ) ) : <NEWLINE> <INDENT> ans [ j ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> for i in ans : <NEWLINE> <INDENT> if ans [ i ] == n : <NEWLINE> <INDENT> output += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( output ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> LIKE = set ( ) <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> AK = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> LIKE |= AK [ 1 : ] <NEWLINE> <NL> <DEDENT> print ( len ( LIKE ) ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> foods = [ 0 ] * M <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> KA = list ( map ( int , input ( ) . split ( ) ) <NEWLINE> for a in KA [ 1 : ] : <NEWLINE> <INDENT> foods [ a - 1 ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> cnt = 0 <NEWLINE> for j in foods : <NEWLINE> <INDENT> if j == N : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> t = [ 0 for i in range ( M + 1 ) ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> A = map ( int , input ( ) . split ( ) ) <NEWLINE> for j in range ( 1 , A [ 0 ] + 1 ) : <NEWLINE> <INDENT> t [ A [ j ] ] += 1 <NEWLINE> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for i in t : <NEWLINE> <INDENT> if i == N : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N . M = map ( int , input ( ) . split ( ) ) <NEWLINE> C = [ 0 ] * ( M + 1 ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> K = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for k in range ( len ( k ) ) : <NEWLINE> <INDENT> C [ K [ k ] ] += 1 <NEWLINE> <DEDENT> <DEDENT> count = 0 <NEWLINE> <NL> for c in C : <NEWLINE> <INDENT> if c == N : <NEWLINE> <INDENT> count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
import numpy as np <NEWLINE> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> A = np . zeros ( ( N , M ) ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = a [ 1 : ] <NEWLINE> A [ i , 0 : len ( a ) ] = a <NEWLINE> <NL> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> a = A [ i ] <NEWLINE> a = a [ ( a != 0 ) & ( a < M ) ] <NEWLINE> if i == 0 : <NEWLINE> <INDENT> s = set ( list ( a ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> _s = set ( list ( a ) ) <NEWLINE> <DEDENT> s &= _s <NEWLINE> <NL> <DEDENT> print ( len ( s ) ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ ] * N <NEWLINE> for i in ragne ( N ) : <NEWLINE> <INDENT> A [ i ] = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> A = set ( range ( 1 , m + 1 ) ) <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> a , * b = map ( int , input ( ) . split ( ) ) <NEWLINE> A = A & set ( * b ) <NEWLINE> <DEDENT> print ( len ( A ) ) <NEWLINE>
N , P = map ( int , input ( ) . split ( ) ) <NEWLINE> List = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> List += list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <DEDENT> count = 0 <NEWLINE> for i in range ( P + 1 ) : <NEWLINE> <INDENT> if List . count ( List [ i ] ) = N : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> a = sorted ( a ) <NEWLINE> <NL> def make_divisors ( n ) : <NEWLINE> <INDENT> lower_divisors , upper_divisors = [ ] , [ ] <NEWLINE> i = 1 <NEWLINE> while i * i <= n : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> lower_divisors . append ( i ) <NEWLINE> if i != n // i : <NEWLINE> <INDENT> upper_divisors . append ( n // i ) <NEWLINE> <DEDENT> <DEDENT> i += 1 <NEWLINE> <DEDENT> return lower_divisors + upper_divisors [ : : - 1 ] <NEWLINE> <NL> <DEDENT> c = make_divisors ( a [ 0 ] ) <NEWLINE> d = list ( c . keys ) <NEWLINE> <NL> d = d . sorted <NEWLINE> f = [ ] <NEWLINE> for y in range ( len ( d ) ) <NEWLINE> <INDENT> e = d [ y ] <NEWLINE> ch = 0 <NEWLINE> for x in range ( 1 , n ) : <NEWLINE> <INDENT> if not a [ x ] % e == 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> ch += 1 <NEWLINE> <DEDENT> if ch == n - 1 : <NEWLINE> <INDENT> f . append ( e ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( max ( f ) ) <NEWLINE> <NL> <NL>
from math import floor , ceil , sqrt , factorial , log , gcd <NEWLINE> from itertools import accumulate , permutations , combinations , product , combinations_with_replacement <NEWLINE> from bisect import bisect_left , bisect_right <NEWLINE> from collections import Counter , defaultdict <NEWLINE> from heapq import heappop , heappush , heappushpop <NEWLINE> import sys <NEWLINE> INF = float ( <STRING> ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> <NL> def lcm ( a , b ) : return a * b / gcd ( a , b ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> def LI ( ) : return list ( map ( int , sys . stdin . buffer . readline ( ) . split ( ) ) ) <NEWLINE> <NL> <COMMENT> <NL> <NL> <NL> def I ( ) : return int ( sys . stdin . buffer . readline ( ) ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> def LS ( ) : return sys . stdin . buffer . readline ( ) . rstrip ( ) . decode ( <STRING> ) . split ( ) <NEWLINE> <NL> <COMMENT> <NL> <NL> <NL> def S ( ) : return sys . stdin . buffer . readline ( ) . rstrip ( ) . decode ( <STRING> ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> def IR ( n ) : return [ I ( ) for i in range ( n ) ] <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> def LIR ( n ) : return [ LI ( ) for i in range ( n ) ] <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> def SR ( n ) : return [ S ( ) for i in range ( n ) ] <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> def LSR ( n ) : return [ LS ( ) for i in range ( n ) ] <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> def SRL ( n ) : return [ list ( S ( ) ) for i in range ( n ) ] <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> n = I ( ) <NEWLINE> lst = LI ( ) <NEWLINE> print ( gcd ( lst ) ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = [ int ( input ( ) ) for i in range ( n ) ] <NEWLINE> <NL> g = gcd ( a [ 0 ] , a [ 1 ] ) <NEWLINE> for i in range ( 2 , n ) : <NEWLINE> <INDENT> g = gcd ( g , a [ i ] ) <NEWLINE> <NL> <DEDENT> print ( g ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a_list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> gcd = a_list [ 0 ] <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> gcd = math . gcd ( gcd , a_list [ i ] ) <NEWLINE> <NL> <NL> <DEDENT> print ( gcd ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> now = A [ 0 ] <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> now = math . gcd ( A [ i ] , now ) <NEWLINE> <DEDENT> print ( now ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> M = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = min ( M ) <NEWLINE> mn = Min ( M ) <NEWLINE> from math import gcd <NEWLINE> for m in M : <NEWLINE> <INDENT> if m % ans != 0 : <NEWLINE> <INDENT> ans = min ( ans , gcd ( mn , m ) ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> xlist = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = xlist [ 0 ] <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> a = fractions . gcd ( a , xlist [ i ] ) <NEWLINE> <DEDENT> print ( a ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = a [ 0 ] <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> ans = gcd ( ans , a [ i ] ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> print ( reduce ( math . gcd , map ( int , input ( ) . split ( ) ) ) ) <NEWLINE>
N , K = map ( int ( input ( ) . split ( ) ) ) <NEWLINE> if N >= k * 2 - 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> if N + 1 >= 2 * K : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> ele : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
<COMMENT> <NL> cnts = [ 0 ] * 4 <NEWLINE> for i in range ( 3 ) : <NEWLINE> <INDENT> ai , bi = map ( int , input ( ) . split ( ) ) <NEWLINE> ai -= 1 ; bi -= 1 <NEWLINE> cnts [ ai ] += 1 ; cnts [ bi ] += 1 <NEWLINE> <DEDENT> for i in range ( 4 ) : <NEWLINE> <INDENT> if cnts > 2 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
G = [ 0 ] * 4 <NEWLINE> for i in range ( 3 ) : <NEWLINE> <INDENT> a , b = mii ( ) <NEWLINE> a -= 1 <NEWLINE> b -= 1 <NEWLINE> G [ a ] += 1 <NEWLINE> G [ b ] += 1 <NEWLINE> <NL> <DEDENT> for i in range ( 4 ) : <NEWLINE> <INDENT> if G [ i ] == 3 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
print ( <STRING> [ len ( { * map ( int , input ( ) . split ( ) ) for i in range ( 3 ) } ) != 4 : : 2 ] ) <NEWLINE>
from collections import defaultdict <NEWLINE> from collections import deque <NEWLINE> import itertools <NEWLINE> import math <NEWLINE> <NL> def readInt ( ) : <NEWLINE> <INDENT> return int ( input ( ) ) <NEWLINE> <DEDENT> def readInts ( ) : <NEWLINE> <INDENT> return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <DEDENT> def readChar ( ) : <NEWLINE> <INDENT> return input ( ) <NEWLINE> <DEDENT> def readChars ( ) : <NEWLINE> <INDENT> return input ( ) . split ( ) <NEWLINE> <NL> <DEDENT> k , a , b = readInts ( ) <NEWLINE> <NL> if a + 1 <= k and a + 2 < b : <NEWLINE> <INDENT> k -= a + 1 <NEWLINE> ans += k // 2 * ( b - a ) + k % 2 + b <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = k + 1 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
K , A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> count = 1 <NEWLINE> coin = 0 <NEWLINE> if B - A <= 2 : <NEWLINE> <INDENT> print ( K + 1 ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( K ) : <NEWLINE> <INDENT> if coin == 1 : <NEWLINE> <INDENT> count += B <NEWLINE> coin -= 1 <NEWLINE> <DEDENT> elif count >= A and i != k - 1 : <NEWLINE> <INDENT> count -= A <NEWLINE> coin += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE> <NL> <DEDENT>
t , x = map ( float , input ( ) . split ( ) ) <NEWLINE> print ( { 0 : .4 f } . format ( t / x ) ) <NEWLINE>
a , b = map ( double , input ( ) . split ( ) ) <NEWLINE> print ( a / b ) <NEWLINE>
T , X = map ( int , input ( ) ) <NEWLINE> <NL> print ( T / X ) <NEWLINE>
a , b = map ( int , input ( ) ) <NEWLINE> print ( a / b ) <NEWLINE>
t , x = map ( int , inupt ( ) . split ( ) ) <NEWLINE> print ( t / x ) <NEWLINE>
T , X = int ( input ( ) . split ( ) ) <NEWLINE> print ( T / X ) <NEWLINE>
x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( x / t ) <NEWLINE>
T , X = map ( int , input ( ) ) <NEWLINE> print ( float ( T / X ) ) <NEWLINE>
_ = input ( ) <NEWLINE> edges = list ( int , input ( ) . split ( ) ) <NEWLINE> max_edge = max ( edges ) <NEWLINE> print ( <STRING> if max_edge < sum ( edges ) - max_edge else <STRING> ) <NEWLINE>
n , l = map ( int , open ( 0 ) . read ( ) . split ( ) ) <NEWLINE> sum_n = sum ( l ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if 2 * l [ i ] >= sum_n <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> import sys <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> L = list ( ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if max ( L ) - ( sum ( L ) - max ( L ) ) < 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> L = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> s = 0 <NEWLINE> for i in L : <NEWLINE> <INDENT> s += i <NEWLINE> <DEDENT> s -= max ( L ) <NEWLINE> if L < s : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> nl = sorted ( l ) <NEWLINE> <NL> for i in range ( n - 1 ) : <NEWLINE> <INDENT> other = 0 + n1 [ i ] <NEWLINE> <NL> <DEDENT> if other < nl [ n - 1 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
<NL> n = int ( input ( ) ) <NEWLINE> L = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> L . sort ( ) <NEWLINE> ans = sum ( L [ : n - 1 ] ) <NEWLINE> if ans > L [ n - 1 : n ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> L = list ( map ( int , int ( input ( ) ) ) ) <NEWLINE> L . sort ( ) <NEWLINE> if L [ - 1 ] > ( sum ( L ) - L [ - 1 ] ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = int ( inout ( ) ) <NEWLINE> L = input ( ) . split ( ) <NEWLINE> flag = 0 <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> L [ i ] = int ( L [ i ] ) <NEWLINE> total += L [ i ] <NEWLINE> <NL> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> if L [ i ] * 2 >= total : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> flag = 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if flag == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
<COMMENT> <NL> n = int ( input ( ) ) <NEWLINE> l = [ int ( input ( ) ) for i in range ( n ) ] <NEWLINE> print ( <STRING> if max ( l ) >= ( sum ( l ) - max ( l ) ) else <STRING> ) <NEWLINE>
<COMMENT> <NL> <NL> def atc_117b ( N : int , Li_input : str ) -> str : <NEWLINE> <INDENT> Li = [ int ( i ) for i in Li_input . split ( <STRING> ) ] <NEWLINE> Li = sorted ( Li ) <NEWLINE> max_length = Li . pop ( ) <NEWLINE> if max_length < sum ( Li ) : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> return <STRING> <NEWLINE> <NL> <DEDENT> N_input_value = int ( input ( ) ) <NEWLINE> Li_input_Value = input ( ) <NEWLINE> print ( atc_117b ( N_input_value , Li_input_value ) ) <NEWLINE>
_ , l = map ( int , open ( 0 ) . read ( ) . split ( ) ) <NEWLINE> l . sort ( ) <NEWLINE> print ( <STRING> [ sum ( l [ : - 1 ] ) <= l [ - 1 ] : : 2 ] ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> l = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> l . sort ( ) <NEWLINE> l . reverse ( ) <NEWLINE> cnt = 0 <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> cnt += l [ i ] <NEWLINE> <DEDENT> if cnt > l [ n ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
<NL> <NL> N , M = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> X = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> X . sort ( ) <NEWLINE> cnt = 0 <NEWLINE> arr = [ 0 ] * ( M - 1 ) <NEWLINE> if N > M : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( 1 , M ) : <NEWLINE> <INDENT> arr [ i ] = ( abs ( X [ i - 1 ] - X [ i ] ) ) <NEWLINE> <COMMENT> <NL> <DEDENT> arr . sort ( ) <NEWLINE> ans = sum ( arr [ 0 : M - N ] ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
x , m = map ( int , input ( ) . split ( ) ) <NEWLINE> x = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> if n >= m : print ( 0 ) <NEWLINE> else : <NEWLINE> <INDENT> dist = [ abs ( x [ i + 1 ] - x [ i ] ) for i in range ( m - 1 ) ] <NEWLINE> dist = sorted ( dist ) <NEWLINE> print ( sum ( dist [ : - ( n - 1 ) ] ) ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> if N >= M : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> X . sort ( ) <NEWLINE> ans = [ ] <NEWLINE> for i in range ( M - 1 ) : <NEWLINE> <INDENT> ans . append ( abs ( X [ i + 1 ] - X [ i ] ) ) <NEWLINE> <NL> <DEDENT> print ( X [ - 1 ] - X [ 0 ] - sum ( sorted ( ans ) [ : : - 1 ] [ : N - 1 ] ) ) <NEWLINE>
N , A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> <COMMENT> <NL> x = min ( A , B ) <NEWLINE> <COMMENT> <NL> y = 0 <NEWLINE> <NL> if N < A + B : <NEWLINE> <INDENT> if A > B : <NEWLINE> <INDENT> y = A - B <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> y = B - A <NEWLINE> <NL> <DEDENT> <DEDENT> print ( x + <STRING> + y ) <NEWLINE>
N , A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if ( A > B ) : <NEWLINE> <INDENT> ans1 = B <NEWLINE> ans2 = A - ( N - B ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans1 = A <NEWLINE> ans2 = B - ( N - A ) <NEWLINE> <NL> <DEDENT> print ( ans1 + <STRING> + ans2 ) <NEWLINE>
N , A , B = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> m = A + B <NEWLINE> print ( min ( A , B ) , max ( 0 , m - N ) ) <NEWLINE>
n , a , b = map ( int , input . split ( ) ) <NEWLINE> mx = min ( a , b ) <NEWLINE> mn = mx - ( n - max ( a , b ) ) <NEWLINE> print ( str ( mx ) + <STRING> + str ( mn ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a , b , c = input ( ) , input ( ) , input ( ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ans += len ( set ( a [ i ] , b [ i ] , c [ i ] ) ) - 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
from sys import stdin <NEWLINE> N = int ( stdin . readline ( ) . rstrip ( ) ) <NEWLINE> A = stdin . readline ( ) . rstrip ( ) <NEWLINE> B = stdin . readline ( ) . rstrip ( ) <NEWLINE> C = stdin . readline ( ) . rstrip ( ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> ans += len ( set ( A [ i ] , B [ i ] , C [ i ] ) ) - 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( a * b * / 2 ) <NEWLINE>
a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( min ( a , b , c ) * ( sum ( [ a , b , c ] - min ( a , b , c ) - max ( a , b , c ) ) ) // 2 ) <NEWLINE>
a , b , c = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> if a >= b and a >= c : <NEWLINE> <INDENT> print ( c * b // 2 ) <NEWLINE> <DEDENT> else if b >= c and b >= a : <NEWLINE> <INDENT> print ( a * c // 2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( a * b // 2 ) <NEWLINE> <DEDENT>
length1 , length2 , length3 = map ( int , input ( ) . split ( ) ) <NEWLINE> area = AB * BC / 2 <NEWLINE> print ( int ( area ) ) <NEWLINE>
a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = a . sorted ( ) <NEWLINE> print ( b [ 1 ] * b [ 2 ] ) <NEWLINE>
l = sorted ( map , input ( ) . split ( ) ) <NEWLINE> print ( ( l [ 0 ] * l [ 1 ] ) // 2 ) <NEWLINE>
AB , BC , CA = int ( input ( ) ) <NEWLINE> <NL> print ( ( AB * BC ) // 2 ) <NEWLINE>
a , b , c = input ( ) . split ( ) <NEWLINE> ls = [ a , b , c ] <NEWLINE> ls . sort ( ) <NEWLINE> print ( ls [ 0 ] * ls [ 1 ] ) <NEWLINE>
AB , BC , CA = map ( int , input ( ) . split ( ) ) <NEWLINE> if ( 1 <= AB & AB <= 100 ) & ( 1 <= BC & BC <= 100 ) & ( 1 <= CA & CA <= 100 ) <NEWLINE> <INDENT> S = int ( AB * BC / 2 ) <NEWLINE> print ( S ) <NEWLINE> <DEDENT>
a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> lis = [ a , b , c ] <NEWLINE> lis = lis . remove ( max ( lis ) ) <NEWLINE> <NL> print ( int ( lis [ 0 ] * lis [ 1 ] / 2 ) ) <NEWLINE>
a , b , c = map ( int , input ( ) . splis ( ) ) <NEWLINE> dai = max ( a , b , c ) <NEWLINE> shou = min ( a , b , c ) <NEWLINE> mid = a + b + c - dai - shou <NEWLINE> <NL> print ( shou * mid / 2 ) <NEWLINE>
L = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> print ( L [ 0 ] * l [ 1 ] // 2 ) <NEWLINE>
l = list ( map ( int , input ( ) ) ) <NEWLINE> <NL> l . sort ( ) <NEWLINE> <NL> print ( l [ 0 ] * l [ 1 ] // 2 ) <NEWLINE>
a , b , c = map ( int , input . split ( ) ) <NEWLINE> print ( a * b // 2 ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> print ( a * b // 2 ) <NEWLINE>
s = int ( input ( ) ) <NEWLINE> a = [ s ] <NEWLINE> i = 1 <NEWLINE> while True : <NEWLINE> <INDENT> if s % 2 == 0 : <NEWLINE> <INDENT> s = s // 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s = 3 * s + 1 <NEWLINE> <DEDENT> if s in a : <NEWLINE> <INDENT> print ( len ( a ) + 1 ) <NEWLINE> <DEDENT> a . append ( s ) <NEWLINE> <DEDENT>
s = list ( int ( input ( ) ) ) <NEWLINE> for i in range ( 1000001 ) : <NEWLINE> <INDENT> if s [ i ] % 2 == 0 : <NEWLINE> <INDENT> s . append ( s [ i ] / 2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s . append ( 3 * s [ i ] + 1 ) <NEWLINE> <DEDENT> if s [ i ] in s [ : i ] : <NEWLINE> <INDENT> print ( i + 1 ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT>
s = int ( input ( ) ) <NEWLINE> G = [ s ] <NEWLINE> while all ( G [ i ] != G [ - 1 ] for i in range ( len ( G ) - 1 ) ) : <NEWLINE> <INDENT> if G [ - 1 ] % 2 == 0 : <NEWLINE> <INDENT> G . append ( int ( x / 2 ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> G . append ( int ( 3 * x + 1 ) ) <NEWLINE> <DEDENT> <DEDENT> print ( len ( G ) ) <NEWLINE>
s = int ( input ( ) ) <NEWLINE> l = [ ] <NEWLINE> a = 0 <NEWLINE> l . append ( s ) <NEWLINE> while True : <NEWLINE> <INDENT> a += 1 <NEWLINE> if s % 2 == 0 : <NEWLINE> <INDENT> s = round ( s / 2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s = s * 3 + 1 <NEWLINE> <DEDENT> if l . count ( s ) != 0 : <NEWLINE> <INDENT> print ( a + 1 ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT>
h_state = [ 0 ] * n <NEWLINE> <NL> def water ( n , h , h_state ) : <NEWLINE> <INDENT> for i in range ( n ) : <NEWLINE> <INDENT> if h_state [ i ] < h [ i ] : <NEWLINE> <INDENT> l = i <NEWLINE> break <NEWLINE> <DEDENT> elif i == n - 1 and h_state [ i ] < h [ i ] : <NEWLINE> <INDENT> l = i <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> l = i + 1 <NEWLINE> <NL> <DEDENT> <DEDENT> for j in range ( l , n ) : <NEWLINE> <INDENT> if h_state [ j ] == h [ j ] : <NEWLINE> <INDENT> r = j - 1 <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> r = j <NEWLINE> <NL> <DEDENT> <DEDENT> for k in range ( l , r + 1 ) : <NEWLINE> <INDENT> h_state [ k ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> cnt = 0 <NEWLINE> while h_state != h : <NEWLINE> <INDENT> for i in range ( n ) : <NEWLINE> <INDENT> if h_state [ i ] < h [ i ] : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> water ( n , h , h_state ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
H = [ 0 ] + H <NEWLINE> cnt = 0 <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> cnt += max ( H [ i ] - H [ i - 1 ] , 0 ) <NEWLINE> <NL> <NL> <DEDENT> print ( cnt ) <NEWLINE>
import sys <NEWLINE> def LI ( ) : return list ( map ( int , sys . stdin . buffer . readline ( ) . split ( ) ) ) <NEWLINE> def I ( ) : return int ( sys . stdin . buffer . readline ( ) ) <NEWLINE> def LS ( ) : return sys . stdin . buffer . readline ( ) . rstrip ( ) . decode ( <STRING> ) . split ( ) <NEWLINE> def S ( ) : return sys . stdin . buffer . readline ( ) . rstrip ( ) . decode ( <STRING> ) <NEWLINE> def IR ( n ) : return [ I ( ) for i in range ( n ) ] <NEWLINE> def LIR ( n ) : return [ LI ( ) for i in range ( n ) ] <NEWLINE> def SR ( n ) : return [ S ( ) for i in range ( n ) ] <NEWLINE> def LSR ( n ) : return [ LS ( ) for i in range ( n ) ] <NEWLINE> def SRL ( n ) : return [ list ( S ( ) ) for i in range ( n ) ] <NEWLINE> def MSRL ( n ) : return [ [ int ( j ) for j in list ( S ( ) ) ] for i in range ( n ) ] <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> n = I ( ) <NEWLINE> hl = LI ( ) <NEWLINE> <COMMENT> <NL> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> ans = hl [ 0 ] <NEWLINE> for i in range ( 1 , n ) <NEWLINE> <INDENT> ans += max ( 0 , hl [ i ] - hl [ i - 1 ] ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL>
from math import floor , ceil , sqrt , factorial , log , gcd <NEWLINE> from itertools import accumulate , permutations , combinations , product , combinations_with_replacement <NEWLINE> from bisect import bisect_left , bisect_right <NEWLINE> from collections import Counter , defaultdict <NEWLINE> from heapq import heappop , heappush , heappushpop <NEWLINE> import copy <NEWLINE> import numpy as np <NEWLINE> import sys <NEWLINE> INF = float ( <STRING> ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> <NL> def lcm ( a , b ) : return a * b / gcd ( a , b ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> def LI ( ) : return list ( map ( int , sys . stdin . buffer . readline ( ) . split ( ) ) ) <NEWLINE> <NL> <COMMENT> <NL> <NL> <NL> def I ( ) : return int ( sys . stdin . buffer . readline ( ) ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> def LS ( ) : return sys . stdin . buffer . readline ( ) . rstrip ( ) . decode ( <STRING> ) . split ( ) <NEWLINE> <NL> <COMMENT> <NL> <NL> <NL> def S ( ) : return sys . stdin . buffer . readline ( ) . rstrip ( ) . decode ( <STRING> ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> def IR ( n ) : return [ I ( ) for i in range ( n ) ] <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> def LIR ( n ) : return [ LI ( ) for i in range ( n ) ] <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> def SR ( n ) : return [ S ( ) for i in range ( n ) ] <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> def LSR ( n ) : return [ LS ( ) for i in range ( n ) ] <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> def SRL ( n ) : return [ list ( S ( ) ) for i in range ( n ) ] <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> n = I ( ) <NEWLINE> h = list ( LI ( ) ) <NEWLINE> n = int ( input ( ) ) <NEWLINE> ans = h [ 0 ] <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> if h [ i ] > h [ i - 1 ] : <NEWLINE> <INDENT> ans += h [ i ] - h [ i - 1 ] <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> h = [ list ( map ( int , input ( ) . split ( ) ) ) ] <NEWLINE> ans = h [ 0 ] <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> if h [ i + 1 ] > h [ i ] : <NEWLINE> <INDENT> ans += h [ i + 1 ] - h [ i ] <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> hm = max ( h ) <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( hm , - 1 , - 1 ) : <NEWLINE> <INDENT> t = 1 <NEWLINE> for j in range ( n ) : <NEWLINE> <INDENT> if h [ j ] = i : <NEWLINE> <INDENT> ans += t <NEWLINE> t = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> t = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
s = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> c = [ 1 , , 4 , 7 , 9 ] <NEWLINE> <NL> if s == c : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
print ( <STRING> if set ( map ( int , input ( ) . split ( ) ) ) == set ( 1 , 9 , 7 , 4 ) else <STRING> ) <NEWLINE>
a = <STRING> . join ( list ( sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) ) ) <NEWLINE> if ( a == <STRING> ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <NL> <DEDENT>
n1 , n2 , n3 , n4 = map ( input ( ) . split ( ) ) <NEWLINE> if { n1 , n2 , n3 , n4 } == { 1 , 9 , 7 , 4 } : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> <NL> for i in range ( 1 , 8 ) : <NEWLINE> <INDENT> a , b = i , 7 - i <NEWLINE> l , r = k [ : i ] , k [ i : ] <NEWLINE> <NL> if l in s and r in s : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
keyence <NEWLINE>
<COMMENT> <NL> s = input ( ) <NEWLINE> for i in range ( n : = len ( s ) ) <NEWLINE> <INDENT> if s [ : i ] + s [ n - 7 + i : ] == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> S = input ( ) <NEWLINE> if S [ 0 ] != <STRING> : <NEWLINE> <INDENT> return ( <STRING> ) <NEWLINE> <DEDENT> elif S = <STRING> : <NEWLINE> <INDENT> return ( <STRING> ) <NEWLINE> <NL> <DEDENT> ans = <STRING> <NEWLINE> i = 0 <NEWLINE> j = 0 <NEWLINE> while True : <NEWLINE> <INDENT> i += 1 <NEWLINE> j += 1 <NEWLINE> if S [ i ] != ans [ j ] : <NEWLINE> <INDENT> break <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> num = 7 - j <NEWLINE> cnt = 0 <NEWLINE> while cnt < num : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <COMMENT> <NL> if S [ - cnt ] != ans [ - cnt ] : <NEWLINE> <INDENT> return ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> return ( <STRING> ) <NEWLINE> <DEDENT> print ( main ( ) ) <NEWLINE>
S = input ( ) <NEWLINE> l = len ( S ) <NEWLINE> <COMMENT> <NL> if s [ : 7 ] == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <COMMENT> <NL> <DEDENT> elif s [ : 1 ] == <STRING> and s [ l - 6 : ] == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <COMMENT> <NL> <DEDENT> elif s [ : 2 ] == <STRING> and s [ l - 5 : ] == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <COMMENT> <NL> <DEDENT> elif s [ : 3 ] == <STRING> and s [ l - 4 : ] == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <COMMENT> <NL> <DEDENT> elif s [ : 4 ] == <STRING> and s [ l - 3 : ] == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <COMMENT> <NL> <DEDENT> elif s [ : 5 ] == <STRING> and s [ l - 2 : ] == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <COMMENT> <NL> <DEDENT> elif s [ : 6 ] == <STRING> and s [ l - 1 : ] == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <COMMENT> <NL> <DEDENT> elif s [ l - 7 : ] == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> surplus = [ ] <NEWLINE> short = [ ] <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> if a [ i ] > b [ i ] : <NEWLINE> <INDENT> surplus . append ( a [ i ] - b [ i ] ) <NEWLINE> <DEDENT> elif b [ i ] > a [ i ] : <NEWLINE> <INDENT> short . append ( b [ i ] - a [ i ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> surplus = sorted ( surplus ) <NEWLINE> taken = False <NEWLINE> cnt = 0 <NEWLINE> for i in range ( len ( short ) ) : <NEWLINE> <INDENT> cost = short . pop ( ) <NEWLINE> cnt += 1 <NEWLINE> <NL> while cost > 0 : <NEWLINE> <INDENT> if len ( surplus ) == 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> take = min ( cost , surplus [ - 1 ] ) <NEWLINE> cost -= take <NEWLINE> surplus [ - 1 ] -= take <NEWLINE> <NL> if not taken : <NEWLINE> <INDENT> taken = True <NEWLINE> cnt += 1 <NEWLINE> <NL> <DEDENT> if surplus [ - 1 ] == 0 : <NEWLINE> <INDENT> surplus . pop ( ) <NEWLINE> taken = False <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
import numpy as np <NEWLINE> from numba import njit <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> a = np . array ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> b = np . array ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> @ njit <NEWLINE> def func ( ) : <NEWLINE> <INDENT> if np . all ( a >= b ) : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> elif np . sum ( a ) < np . sum ( b ) : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> temp_a = a [ a - b < 0 ] <NEWLINE> temp_b = b [ a - b < 0 ] <NEWLINE> sum_a = np . sum ( temp_a ) <NEWLINE> sum_b = np . sum ( temp_b ) <NEWLINE> ans = len ( temp_a ) <NEWLINE> <NL> if sum_a >= sum_b : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> aa = a [ a - b >= 0 ] <NEWLINE> bb = b [ a - b >= 0 ] <NEWLINE> for _ in range ( n - ans ) : <NEWLINE> <INDENT> index = np . argmax ( aa - bb ) <NEWLINE> sum_a += aa [ index ] <NEWLINE> sum_b += bb [ index ] <NEWLINE> ans += 1 <NEWLINE> if sum_a >= sum_b : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> aa [ index ] = 0 <NEWLINE> bb [ index ] = 0 <NEWLINE> continue <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> func ( ) <NEWLINE>
N = input ( ) <NEWLINE> H = input ( ) <NEWLINE> W = input ( ) <NEWLINE> <NL> print ( ( N - W + 1 ) * ( N - H + 1 ) ) <NEWLINE>
class UnionFind ( ) : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . n = n <NEWLINE> self . parents = [ - 1 ] * n <NEWLINE> <NL> <DEDENT> def find ( self , x ) : <NEWLINE> <INDENT> if self . parents [ x ] < 0 : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . parents [ x ] = self . find ( self . parents [ x ] ) <NEWLINE> return self . parents [ x ] <NEWLINE> <NL> <DEDENT> <DEDENT> def union ( self , x , y ) : <NEWLINE> <INDENT> x = self . find ( x ) <NEWLINE> y = self . find ( y ) <NEWLINE> <NL> if x == y : <NEWLINE> <INDENT> return <NEWLINE> <NL> <DEDENT> if self . parents [ x ] > self . parents [ y ] : <NEWLINE> <INDENT> x , y = y , x <NEWLINE> <NL> <DEDENT> self . parents [ x ] += self . parents [ y ] <NEWLINE> self . parents [ y ] = x <NEWLINE> <NL> <DEDENT> def size ( self , x ) : <NEWLINE> <INDENT> return - self . parents [ self . find ( x ) ] <NEWLINE> <NL> <DEDENT> def same ( self , x , y ) : <NEWLINE> <INDENT> return self . find ( x ) == self . find ( y ) <NEWLINE> <NL> <DEDENT> def members ( self , x ) : <NEWLINE> <INDENT> root = self . find ( x ) <NEWLINE> return [ i for i in range ( self . n ) if self . find ( i ) == root ] <NEWLINE> <NL> <DEDENT> def roots ( self ) : <NEWLINE> <INDENT> return [ i for i , x in enumerate ( self . parents ) if x < 0 ] <NEWLINE> <NL> <DEDENT> def group_count ( self ) : <NEWLINE> <INDENT> return len ( self . roots ( ) ) <NEWLINE> <NL> <DEDENT> def all_group_members ( self ) : <NEWLINE> <INDENT> return { r : self . members ( r ) for r in self . roots ( ) } <NEWLINE> <NL> <DEDENT> def __str__ ( self ) : <NEWLINE> <INDENT> return <STRING> . join ( <STRING> . format ( r , self . members ( r ) ) for r in self . roots ( ) ) <NEWLINE> <NL> <NL> <NL> <DEDENT> <DEDENT> def calc ( i , j ) : <NEWLINE> <INDENT> return i * w + j <NEWLINE> <DEDENT> def calc_inv ( x ) : <NEWLINE> <INDENT> return x // w , x % w <NEWLINE> <DEDENT> def judge ( x , y ) : <NEWLINE> <INDENT> i0 , j0 = calc_inv ( x ) <NEWLINE> i1 , j1 = calc_inv ( y ) <NEWLINE> if s [ i0 ] [ j0 ] != s [ i1 ] [ j1 ] : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> return False <NEWLINE> <NL> <NL> <DEDENT> h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> s = [ [ ( i == <STRING> ) * 1 for i in list ( input ( ) ) ] for _ in range ( h ) ] <NEWLINE> uf = UnionFind ( h * w ) <NEWLINE> <NL> for i in range ( h ) : <NEWLINE> <INDENT> for j in range ( w ) : <NEWLINE> <INDENT> now = calc ( i , j ) <NEWLINE> nxt = calc ( i + 1 , j ) <NEWLINE> if i + 1 < h : <NEWLINE> <INDENT> if judge ( now , nxt ) : <NEWLINE> <INDENT> uf . union ( now , nxt ) <NEWLINE> <DEDENT> <DEDENT> nxt = calc ( i , j + 1 ) <NEWLINE> if j + 1 < w : <NEWLINE> <INDENT> if judge ( now , nxt ) : <NEWLINE> <INDENT> uf . union ( now , nxt ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> cnt = [ [ 0 , 0 ] for _ in range ( h * w ) ] <NEWLINE> ind = 0 <NEWLINE> for l in uf . all_group_members ( ) . values ( ) : <NEWLINE> <INDENT> for x in l : <NEWLINE> <INDENT> i , j = calc_inv ( x ) <NEWLINE> if s [ i ] [ j ] : <NEWLINE> <INDENT> cnt [ ind ] [ 0 ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cnt [ ind ] [ 1 ] += 1 <NEWLINE> <DEDENT> <DEDENT> ind += 1 <NEWLINE> <DEDENT> ans = 0 <NEWLINE> for i in range ( ind ) : <NEWLINE> <INDENT> ans += cnt [ i ] [ 0 ] * cnt [ i ] [ 1 ] <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
N , H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( ( N - H + 1 ) * ( N - W + 1 ) ) <NEWLINE>
7 <NEWLINE> 5 15 <NEWLINE> 1 10 16 2 7 20 12 <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> P = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = len ( filter ( lambda x : x <= A , P ) ) <NEWLINE> b = len ( filter ( lambda x : A < x <= B , P ) ) <NEWLINE> c = len ( filter ( lambda x : B < x , P ) ) <NEWLINE> print ( min ( a , b , c ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) <NEWLINE> c = [ 0 ] * 3 <NEWLINE> for i in p : <NEWLINE> <INDENT> if i <= a : <NEWLINE> <INDENT> c [ 0 ] += 1 <NEWLINE> <DEDENT> elif i > b : <NEWLINE> <INDENT> c [ 2 ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> c [ 1 ] += 1 <NEWLINE> <DEDENT> <DEDENT> print ( min ( c ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c = [ ] <NEWLINE> d = [ ] <NEWLINE> e = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if p [ i ] <= A : <NEWLINE> <INDENT> c . append ( p [ i ] ) <NEWLINE> <DEDENT> if A + 1 <= p [ i ] <= B : <NEWLINE> <INDENT> d . append ( p [ i ] ) <NEWLINE> <DEDENT> if B + 1 <= p [ i ] : <NEWLINE> <INDENT> e . append ( p [ i ] ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> print ( min ( len ( c ) , len ( d ) , len ( e ) ) ) ) <NEWLINE>
n , a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> * p , = map ( int , input ( ) . split ( ) ) <NEWLINE> mn , md , mx = 0 , 0 , 0 <NEWLINE> for pi in p : <NEWLINE> <INDENT> if pi <= a : <NEWLINE> <INDENT> mn += 1 <NEWLINE> <DEDENT> elif pi <= b : <NEWLINE> <INDENT> md += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> mx += 1 <NEWLINE> <DEDENT> <DEDENT> print ( min ( mn , md , mx ) ) <NEWLINE>
int pxcount , pycount , pzcount = 0 <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in p : <NEWLINE> <INDENT> if i <= a : <NEWLINE> <INDENT> pxcount = pxcount + 1 <NEWLINE> <DEDENT> <DEDENT> for i in p : <NEWLINE> <INDENT> if a + 1 <= i and i <= b : <NEWLINE> <INDENT> pycount = pycount + 1 <NEWLINE> <DEDENT> <DEDENT> for i in p : <NEWLINE> <INDENT> if b + 1 <= i : <NEWLINE> <INDENT> pzcount = pzcount + 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( min ( pxcount , pycount , pzcount ) ) <NEWLINE>
def chmin ( a , b ) : <NEWLINE> <INDENT> if a > b : <NEWLINE> <INDENT> return b <NEWLINE> <DEDENT> return a <NEWLINE> <COMMENT> <NL> <DEDENT> def resolve ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> dp = [ 10 ** 10 ] * n <NEWLINE> dp [ 0 ] = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> dp [ i + 1 ] = chmin ( dp [ i + 1 ] , dp [ i ] + abs ( h [ i ] - h [ i + 1 ] ) ) <NEWLINE> if i < n - 2 : <NEWLINE> <INDENT> dp [ i + 2 ] = chmin ( dp [ i + 2 ] , dp [ i ] + abs ( h [ i ] - h [ i + 2 ] ) ) <NEWLINE> <DEDENT> <DEDENT> print ( dp [ - 1 ] ) <NEWLINE> <DEDENT> resolve ( ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> hs = np . array ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> i = 0 <NEWLINE> total_cost = 0 <NEWLINE> <NL> a = np . zeros ( N , int ) <NEWLINE> a [ 0 ] = 0 <NEWLINE> a [ 1 ] = abs ( hs [ 1 ] - hs [ 0 ] ) <NEWLINE> for i in range ( 2 , N ) : <NEWLINE> <INDENT> a [ i ] = min ( a [ max ( i - 2 , 0 ) ] + abs ( hs [ i ] - hs [ max ( i - 2 , 0 ) ] ) , <NEWLINE> <INDENT> a [ max ( i - 1 , 0 ) ] + abs ( hs [ i ] - hs [ max ( i - 1 , 0 ) ] ) ) <NEWLINE> <DEDENT> <DEDENT> print ( a [ - 1 ] ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> inf = - 1 <NEWLINE> dp = [ 0 ] + [ inf ] * N <NEWLINE> <NL> for i in range ( 1 , N ) : <NEWLINE> <INDENT> dp [ 1 ] = abs ( h [ 1 ] - h [ 0 ] ) <NEWLINE> else : <NEWLINE> <INDENT> dp [ i ] = min ( dp [ i - 1 ] + abs ( h [ i ] - h [ i - 1 ] ) , dp [ i - 2 ] + abs ( h [ i ] - h [ i - 2 ] ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( dp [ N - 1 ] ) <NEWLINE>
def frogOne ( N , arr ) : <NEWLINE> <INDENT> dparr = [ - 1 for i in range ( N ) ] <NEWLINE> dparr [ 0 ] = 0 <NEWLINE> dparr [ 1 ] = abs ( arr [ 0 ] - arr [ 1 ] ) <NEWLINE> for num in range ( 2 , N ) : <NEWLINE> <INDENT> dparr [ num ] = min ( dparr [ num - 2 ] + abs ( arr [ num ] - arr [ num - 2 ] ) , dparr [ num - 1 ] + abs ( arr [ num ] - arr [ num - 1 ] ) ) <NEWLINE> <DEDENT> return dparr [ - 1 ] <NEWLINE> <NL> <NL> if __name__ == <STRING> : <NEWLINE> N = int ( input ( ) ) <NEWLINE> arr = list ( map ( int , input ( ) . rstrip ( ) . split ( ) ) ) <NEWLINE> print ( frogOne ( N , arr ) ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> dp = [ 0 , abs ( h [ 1 ] - [ 0 ] ) ] <NEWLINE> <NL> for i in range ( 2 , n ) : <NEWLINE> <INDENT> dp . append ( min ( dp [ i - 1 ] + abs ( h [ i ] - h [ i + 1 ] ) , dp [ i ] + abs ( h [ i ] - h [ i + 2 ] ) ) ) <NEWLINE> <NL> <DEDENT> print ( dp [ - 1 ] ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> h = list ( int , input ( ) . split ( ) ) <NEWLINE> inf = float ( <STRING> ) <NEWLINE> dp = [ inf for i in range ( n ) ] <NEWLINE> dp [ 0 ] = 0 <NEWLINE> dp [ 1 ] = h [ 1 ] <NEWLINE> for i in range ( 2 , n ) : <NEWLINE> <INDENT> dp [ i ] = min ( dp [ i - 1 ] , dp [ i - 2 ] ) + h [ i ] <NEWLINE> <NL> <DEDENT> print ( dp [ - 1 ] ) <NEWLINE>
from math import inf <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> costs = [ inf ] * n <NEWLINE> costs [ 0 ] = 0 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> for j in ( i + 1 , i + 2 ) : <NEWLINE> <INDENT> if j < n : <NEWLINE> <INDENT> costs [ j ] = min ( costs [ j ] , costs [ i ] + abs ( h [ i ] - h [ j ] ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( c [ - 1 ] ) <NEWLINE>
return True <NEWLINE>
n = int ( input ( ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> dp = [ 0 , abs ( h [ 1 ] - [ 0 ] ) ] <NEWLINE> <NL> for i in range ( 2 , n ) : <NEWLINE> <INDENT> dp . append ( min ( dp [ i - 1 ] + abs ( h [ i ] - h [ i + 1 ] ) , dp [ i ] + abs ( h [ i ] - h [ i + 2 ] ) ) ) <NEWLINE> <NL> <DEDENT> print ( dp [ - 1 ] ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> INF = 10 ** 9 <NEWLINE> dp = [ 0 ] + [ INF ] * N <NEWLINE> <NL> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> if i == 1 : <NEWLINE> <INDENT> dp [ 1 ] = abs ( A [ 1 ] - A [ 0 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dp [ i ] = min ( dp [ i - 1 ] + abs ( A [ i ] - A [ i - 1 ] ) , dp [ i - 2 ] + abs ( A [ i ] - A [ i - 2 ] ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( dp [ N ] ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> arr = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> vis [ 0 ] = 0 <NEWLINE> if n < 2 : <NEWLINE> <INDENT> print ( vis [ 0 ] ) <NEWLINE> <DEDENT> vis [ 1 ] = abs ( arr [ 0 ] - arr [ 1 ] ) <NEWLINE> for i in range ( 2 , n ) : <NEWLINE> <INDENT> step_1 = abs ( arr [ i - 1 ] - arr [ i - 2 ] ) + vis [ i - 1 ] <NEWLINE> step_2 = abs ( arr [ i - 1 ] - arr [ i - 3 ] ) + vis [ i - 2 ] <NEWLINE> vis [ i ] = min ( step_1 , step_2 ) <NEWLINE> <DEDENT> print ( vis [ i ] ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> h = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> dp = [ ] <NEWLINE> dp1 = 0 <NEWLINE> dp2 = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> dp . append ( 0 ) <NEWLINE> continue <NEWLINE> <NL> <DEDENT> if i == 1 : <NEWLINE> <INDENT> dp . append ( abs ( h [ 0 ] - h [ 1 ] ) ) <NEWLINE> continue <NEWLINE> <NL> <DEDENT> dp1 = dp [ i - 1 ] + abs ( h [ i ] - h [ i - 1 ] ) <NEWLINE> dp2 = dp [ i - 2 ] + abs ( h [ i ] - h [ i - 2 ] ) <NEWLINE> <NL> if dp1 < dp2 : <NEWLINE> <INDENT> dp . append ( dp1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dp . append ( dp2 ) <NEWLINE> <DEDENT> <DEDENT> return dp [ - 1 ] <NEWLINE>
N = int ( input ( ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> cost = [ 1000000 ] * N <NEWLINE> cost [ 0 ] = 0 <NEWLINE> cost [ 1 ] = abs ( h ( [ 1 ] - h [ 0 ] ) <NEWLINE> for i in range ( 2 , N ) : <NEWLINE> <INDENT> cost [ i ] = min ( ( abs ( h [ i - 1 ] - h [ i ] ) + cost [ i - 1 ] ) , cost [ i ] ) <NEWLINE> cost [ i ] = min ( ( abs ( h [ i - 2 ] - h [ i ] ) + cost [ i - 2 ] ) , cost [ i ] ) <NEWLINE> <DEDENT> print ( cost [ - 1 ] ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = [ int ( s ) for s in input ( ) . split ( ) ] <NEWLINE> b = [ 0 ] * n <NEWLINE> b [ 1 ] = abs ( a [ 0 ] - a [ 1 ] ) <NEWLINE> for i in range ( 2 , n ) : <NEWLINE> <INDENT> b [ i ] = min ( b [ i - 1 ] + abs ( a [ i ] - a [ i - 1 ] ) , b [ i - 2 ] + as ( a [ i ] - a [ i - 2 ] ) ) <NEWLINE> <DEDENT> print ( b [ n - 1 ] ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> dp = [ ] <NEWLINE> dp [ 0 ] = 0 <NEWLINE> dp [ 1 ] = abs ( h [ 1 ] - h [ 0 ] ) <NEWLINE> <NL> for i in range ( 2 , N ) : <NEWLINE> <INDENT> t1 = dp [ i - 2 ] + abs ( h [ i ] - h [ i - 2 ] ) <NEWLINE> t2 = dp [ i - 1 ] + abs ( h [ i ] - h [ i - 1 ] ) <NEWLINE> dp [ i ] = min ( t1 , t2 ) <NEWLINE> <NL> <NL> <NL> <DEDENT> print ( dp [ N - 1 ] ) <NEWLINE>
<COMMENT> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> h . append ( INF ) <NEWLINE> h . append ( INF ) <NEWLINE> <NL> INF = 1 << 60 <NEWLINE> dp = [ INF ] * 100010 <NEWLINE> <NL> dp [ 0 ] = 0 <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> dp [ i + 1 ] = min ( dp [ i + 1 ] , dp [ i ] + abs ( h [ i ] - h [ i + 1 ] ) ) <NEWLINE> dp [ i + 2 ] = min ( dp [ i + 2 ] , dp [ i ] + abs ( h [ i ] - h [ i + 2 ] ) ) <NEWLINE> <NL> <DEDENT> print ( dp [ N - 1 ] ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> h = [ None ] + list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> <NL> dp = [ None for _ in range ( n + 1 ) ] <NEWLINE> for k in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if k == 1 : <NEWLINE> <INDENT> dp [ k ] = 0 <NEWLINE> <DEDENT> elif k == 2 : <NEWLINE> <INDENT> dp [ k ] = abs ( h [ 2 ] - h [ 1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dp [ k ] = min ( <NEWLINE> <INDENT> dp [ k - 1 ] + abs ( h [ k ] - h [ k - 1 ] ) , <NEWLINE> dp [ k - 2 ] + abs ( h [ k ] - h [ k - 2 ] ) <NEWLINE> <DEDENT> ) <NEWLINE> <DEDENT> <DEDENT> print ( dp [ k ] ) <NEWLINE>
def cmin ( a , b ) : <NEWLINE> <INDENT> if a > b : <NEWLINE> <INDENT> return b <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return a <NEWLINE> <NL> <DEDENT> <DEDENT> N = int ( input ( ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> dp [ ] = [ 0 ] + [ float ( <STRING> ) ] * ( N - 1 ) <NEWLINE> for i in range ( N - 2 ) : <NEWLINE> <INDENT> dp [ i ] = cmin ( dp [ i ] , dp [ i - 1 ] + abs ( h [ i - 1 ] - h [ i ] ) ) <NEWLINE> <DEDENT> print ( dp [ - 1 ] ) <NEWLINE>
N = input ( ) <NEWLINE> height = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> dp = [ 0 ] * N <NEWLINE> <NL> for i in range ( 1 , N ) : <NEWLINE> <INDENT> if i <= 2 : <NEWLINE> <INDENT> dp [ i ] = abs ( height [ i ] - height [ 0 ] ) <NEWLINE> <DEDENT> if dp [ i - 1 ] < dp [ i - 2 ] : <NEWLINE> <INDENT> dp [ i ] = dp [ i - 1 ] + abs ( height [ i ] - height [ i - 1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dp [ i ] = dp [ i - 2 ] + abs ( height [ i ] - height [ i - 2 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( dp [ N - 1 ] ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> rec = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> s = [ rec [ 0 ] , abs ( rec [ 1 ] - rec [ 0 ] ) ] <NEWLINE> for i in range ( 2 , n ) : <NEWLINE> <INDENT> total2 = abs ( rec [ i ] - rec [ i - 2 ] ) + s [ i - 2 ] <NEWLINE> total1 = abs ( rec [ i ] - rec [ i - 1 ] ) + s [ i - 1 ] <NEWLINE> s . append ( min ( total2 , total ) ) <NEWLINE> <DEDENT> print ( s [ - 1 ] ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = input ( ) . split ( ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> s [ i ] = int ( s [ i ] ) <NEWLINE> <DEDENT> memo = [ 0 for i in range ( n + 1 ) ] <NEWLINE> memo [ 0 ] = 0 <NEWLINE> memo [ 1 ] = 0 <NEWLINE> for i in range ( 2 , n + 1 ) : <NEWLINE> <INDENT> memo [ i ] = min ( memo [ i - 1 ] + abs ( s [ i ] - s [ i - 1 ] ) , memo [ i - 2 ] + abs ( s [ i ] - s [ i - 2 ] ) ) <NEWLINE> <DEDENT> print ( memo [ n ] ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> arr = [ int ( i ) for i in list ( input ( ) . split ( ) ) ] <NEWLINE> def helper ( arr ) : <NEWLINE> <INDENT> if len ( arr ) <= 1 : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> if len ( arr ) == 2 : <NEWLINE> <INDENT> return abs ( arr [ 1 ] - arr [ 0 ] ) <NEWLINE> <DEDENT> way1 = abs ( arr [ - 1 ] - arr [ - 2 ] ) + helper ( arr [ : - 1 ] ) <NEWLINE> way2 = abs ( arr [ - 1 ] - arr [ - 3 ] ) + helper ( arr [ : - 2 ] ) <NEWLINE> return min ( way1 , way2 ) <NEWLINE> <NL> <DEDENT> if n == 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> elif n == 2 : <NEWLINE> <INDENT> print ( abs ( arr [ 1 ] - arr [ 0 ] ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dp [ 0 ] = 0 <NEWLINE> dp [ 1 ] = abs ( arr [ 1 ] - arr [ 0 ] ) <NEWLINE> dp = [ 0 ] * n <NEWLINE> for i in range ( 2 , len ( arr ) ) : <NEWLINE> <INDENT> dp [ i ] = min ( dp [ i - 1 ] + abs ( arr [ i ] - arr [ i - 1 ] ) , dp [ i - 2 ] + abs ( arr [ i ] - arr [ i - 2 ] ) ) <NEWLINE> <DEDENT> print ( dp [ n - 1 ] ) <NEWLINE> <COMMENT> <NL> <NEWLINE> <DEDENT>
sys . setrecursionlimit ( 200000 ) <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> dp = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> dp . append ( - 1 ) <NEWLINE> <NL> <DEDENT> def flog ( m ) : <NEWLINE> <INDENT> if dp [ m ] != - 1 : <NEWLINE> <INDENT> return dp [ m ] <NEWLINE> <DEDENT> if m == 0 : <NEWLINE> <INDENT> dp [ m ] = 0 <NEWLINE> return 0 <NEWLINE> <DEDENT> if m == 1 : <NEWLINE> <INDENT> dp [ m ] = abs ( h [ 0 ] - h [ 1 ] ) <NEWLINE> return dp [ m ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dp [ m ] = min ( flog ( m - 1 ) + abs ( h [ m - 1 ] - h [ m ] ) , flog ( m - 2 ) + abs ( h [ m - 2 ] - h [ m ] ) ) <NEWLINE> return dp [ m ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( flog ( n - 1 ) ) <NEWLINE>
<INDENT> n = int ( input ( ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> dp = [ 0 ] * ( len ( h ) ) <NEWLINE> dp [ 1 ] += abs ( h [ 1 ] - h [ 0 ] ) <NEWLINE> for i in range ( 2 , len ( h ) ) : <NEWLINE> <INDENT> dp [ i ] = min ( <NEWLINE> <INDENT> abs ( h [ i ] - h [ i - 1 ] ) + dp [ i - 1 ] , <NEWLINE> abs ( h [ i ] - h [ i - 2 ] ) + dp [ i - 2 ] <NEWLINE> ) <NEWLINE> <DEDENT> <DEDENT> print ( dp [ - 1 ] ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> dp = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> dp . append ( int ( 0 ) ) <NEWLINE> <DEDENT> dp [ 0 ] = 0 <NEWLINE> dp [ 1 ] = abs ( h [ 0 ] - h [ 1 ] ) <NEWLINE> <NL> for j in range ( 2 , n ) : <NEWLINE> <INDENT> dp [ j ] = min ( flog ( j - 1 ) + abs ( h [ j - 1 ] - h [ j ] ) , flog ( j - 2 ) + abs ( h [ j - 2 ] - h [ j ] ) ) <NEWLINE> <NL> <DEDENT> print ( dp [ n - 1 ] ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> arr = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> cost = [ 0 ] * n <NEWLINE> cost [ 0 ] = 0 <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> if i > 1 : <NEWLINE> <INDENT> cost [ i ] = min ( abs ( arr [ i ] - arr [ i - 2 ] ) + cost [ i - 2 ] , abs ( arr [ i ] - arr [ i - 1 ] ) + cost [ i - 1 ] ) <NEWLINE> <DEDENT> elif i == 1 : <NEWLINE> <INDENT> cost [ i ] = minabs ( arr [ i ] - arr [ i - 1 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( cost [ - 1 ] ) <NEWLINE>
def findmin ( arr , n ) : <NEWLINE> <INDENT> dp = [ 0 ] * n <NEWLINE> dp [ 1 ] = abs ( arr [ 0 ] - arr [ 1 ] ) <NEWLINE> for i in range ( 2 , n ) : <NEWLINE> <INDENT> dp [ i ] = min ( dp [ i - 1 ] + abs ( arr [ i - 1 ] - arr [ i ] ) , dp [ i - 2 ] + abs ( arr [ i - 2 ] - arr [ i ] ) ) <NEWLINE> <DEDENT> return dp [ - 1 ] <NEWLINE> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> arr = list ( map ( int , input ( ) . split ( ) ) <NEWLINE> print ( findmin ( arr , n ) ) <NEWLINE>
<NL> <NL> def solution ( h ) : <NEWLINE> <INDENT> n = len ( h ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( i + 1 , i + 3 ) : <NEWLINE> <INDENT> if j < n : <NEWLINE> <INDENT> dp [ j ] = min ( dp [ j ] , dp [ i ] + abs ( h [ i ] - h [ j ] ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return dp [ n - 1 ] <NEWLINE> <NL> <DEDENT> N = int ( input ( ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> res = solution ( h ) <NEWLINE> print ( res ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> <NL> dp = [ 1000000 for i in range ( N + 10 ) ] <NEWLINE> dp [ 1 ] = 0 <NEWLINE> <NL> for i in range ( 1 , N - 1 ) : <NEWLINE> <INDENT> dp [ i + 1 ] = min ( dp [ i + 1 ] , abs ( h [ i + 1 ] - h [ i ] ) + dp [ i ] ) <NEWLINE> dp [ i + 2 ] = min ( dp [ i + 2 ] , abs ( h [ i + 2 ] - h [ i ] ) + dp [ i ] ) <NEWLINE> <NL> <DEDENT> print ( dp [ N ] ) <NEWLINE>
import sys <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> dp = [ sys . maxsize ] * n <NEWLINE> dp [ 0 ] = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> for j in ( i + 1 , i + 2 ) : <NEWLINE> <INDENT> if j < n : <NEWLINE> <INDENT> dp [ j ] = min ( dp [ j ] , dp [ i ] + abs ( dp [ i ] - dp [ j ] ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( dp [ n - 1 ] , end = <STRING> ) <NEWLINE>
def sol ( lis ) : <NEWLINE> <INDENT> if len ( lis ) <= 2 : <NEWLINE> <INDENT> return abs ( lis [ 0 ] - lis [ 1 ] ) <NEWLINE> <DEDENT> costs = [ 0 , abs ( lis [ 0 ] - lis [ 1 ] ) ] <NEWLINE> for i in range ( 2 , len ( lis ) ) : <NEWLINE> <INDENT> x = abs ( lis [ i ] - lis [ i - 1 ] ) <NEWLINE> y = abs ( lis [ i ] - lis [ i - 2 ] ) <NEWLINE> costs . append ( min ( x + costs [ - 1 ] ) , min ( x + costs [ - 2 ] ) ) <NEWLINE> <DEDENT> print ( costs ) <NEWLINE> return costs [ - 1 ] <NEWLINE> <DEDENT> input ( ) <NEWLINE> lis = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> print ( sol ( lis ) ) <NEWLINE>
import math <NEWLINE> import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> number , jump = input ( ) . rstrip ( ) . split ( ) <NEWLINE> number = int ( number ) <NEWLINE> jump = int ( jump ) <NEWLINE> scaffolding = input ( ) . rstrip ( ) . split ( ) <NEWLINE> scaffolding = list ( map ( int , scaffolding ) ) <NEWLINE> res = [ math . inf * number ] <NEWLINE> res [ 0 ] = 0 <NEWLINE> test = [ math . inf * number ] <NEWLINE> test [ 0 ] = 0 <NEWLINE> <NL> for i in range ( number ) : <NEWLINE> <INDENT> for j in range ( 1 , jump + 1 ) : <NEWLINE> <INDENT> if i - j < 0 : break <NEWLINE> cost = abs ( scaffolding [ i ] - scaffolding [ i - j ] ) <NEWLINE> test [ j - 1 ] = res [ i - j ] + cost <NEWLINE> <NL> <DEDENT> res [ i ] = min ( test ) <NEWLINE> <NL> <NL> <DEDENT> print ( res [ number - 1 ] ) <NEWLINE> <NL> <NL>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> S = [ 0 ] * N <NEWLINE> <NL> for i in range ( 1 , N ) : <NEWLINE> <INDENT> S [ i ] = min ( S [ _ ] + abs ( h [ i ] - h [ _ ] ) for range ( max ( 0 , i - K ) , i ) ) <NEWLINE> <NL> <DEDENT> print ( S [ N - 1 ] ) <NEWLINE>
import sys <NEWLINE> <NL> import numba as nb <NEWLINE> <NL> input = sys . stdin . readline <NEWLINE> INF = float ( <STRING> ) <NEWLINE> <NL> <NL> @ nb . njit <NEWLINE> def solve ( N , K , h ) : <NEWLINE> <INDENT> dp = [ 0 ] * N <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> min_cost = INF <NEWLINE> for k in range ( 1 , min ( K + 1 , i + 1 ) ) : <NEWLINE> <INDENT> cost = dp [ i - k ] + abs ( h [ i ] - h [ i - k ] ) <NEWLINE> if cost < min_cost : <NEWLINE> <INDENT> min_cost = cost <NEWLINE> <DEDENT> <DEDENT> dp [ i ] = min_cost <NEWLINE> <DEDENT> return dp [ - 1 ] <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> h = tuple ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = solve ( N , K , h ) <NEWLINE> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> H = list ( map ( int , input ( ) . split ( ) for _ in range ( N ) ) ) <NEWLINE> <NL> import numpy as np <NEWLINE> dp = np . full ( N + K , 1e+14 , dtype = np . int64 ) <NEWLINE> dp [ 0 ] = 0 <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> dp [ i : i + K ] = np . minimum ( dp [ i : i + K ] , np . abs ( H [ i - 1 ] - H [ i : i + K ] ) + dp [ i - 1 ] ) <NEWLINE> <NL> <DEDENT> print ( dp [ N - 1 ] ) <COMMENT> <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> DP = [ 10 ** 10 for _ in range ( N ) ] <NEWLINE> DP [ 0 ] = 0 <NEWLINE> DP [ 1 ] = abs ( h [ 0 ] - h [ 1 ] ) <NEWLINE> <NL> for i in range ( 2 , N ) : <NEWLINE> <INDENT> DP [ i ] = min ( [ DP [ k ] + abs ( h [ i ] - h [ k ] ) for k in range ( max ( 0 , i - k ) , i ) ] ) <NEWLINE> <DEDENT> print ( DP [ N - 1 ] ) <NEWLINE> <DEDENT> main ( ) <NEWLINE>
from numba import jit <NEWLINE> import math <NEWLINE> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> S = [ 0 ] * N <NEWLINE> S [ 0 ] = 0 <NEWLINE> <NL> @ jit <NEWLINE> def nya ( S , N ) : <NEWLINE> <INDENT> for i in range ( 1 , N ) : <NEWLINE> <INDENT> value = math . inf <NEWLINE> for step in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> if i - step < 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> value = min ( value , S [ i - step ] + abs ( h [ i ] - h [ i - step ] ) ) <NEWLINE> <DEDENT> S [ i ] = value <NEWLINE> <DEDENT> return S <NEWLINE> <NL> <DEDENT> S = nya ( S , N ) <NEWLINE> print ( S [ N - 1 ] ) <NEWLINE>
import numpy as np <NEWLINE> [ N , K ] = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> h = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> <NL> dp = [ 0 for i in range ( N ) ] <NEWLINE> <NL> for i in range ( 1 , N ) : <NEWLINE> <INDENT> dp [ N - 1 - i ] = dp [ N - i ] + np . abs ( h [ N - i - 1 ] - h [ N - i ] ) <NEWLINE> for j in range ( 2 , np . min ( K + 1 , i + 1 ) ) : <NEWLINE> <INDENT> dp [ N - i - 1 ] = np . min ( dp [ N - i - 1 + j ] + np . abs ( h [ N - i - 1 ] - h [ N - 1 - i + j ] ) , dp [ N - i - 1 ] ) <NEWLINE> <DEDENT> <DEDENT> print ( dp [ 0 ] ) <NEWLINE>
from numba import jit <NEWLINE> @ jit <NEWLINE> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> cost = [ 0 ] <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> wk = [ ] <NEWLINE> for j in range ( 1 , min ( k , i ) + 1 ) : <NEWLINE> <INDENT> wk . append ( cost [ i - j ] + abs ( h [ i ] - h [ i - j ] ) ) <NEWLINE> <DEDENT> cost . append ( min ( wk ) ) <NEWLINE> <DEDENT> print ( cost [ n - 1 ] ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> h_list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> dp_list = [ 0 ] <NEWLINE> for n in range ( 1 , N ) : <NEWLINE> <INDENT> tmp_h = h_list [ n ] <NEWLINE> if n < K : <NEWLINE> <INDENT> lst = [ abs ( tmp_h - h_list [ i ] ) + dp_list [ i ] for i in range ( n ) ] <NEWLINE> else : <NEWLINE> <INDENT> lst = [ abs ( tmp_h - h_list [ n - k ] ) + dp_list [ n - k ] for k in range ( 1 , K + 1 ) ] <NEWLINE> dp_list . append ( min ( lst ) ) <NEWLINE> print ( dp_list [ - 1 ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
from numba import njit , jit <NEWLINE> <NL> @ jit <NEWLINE> def main ( ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <INDENT> kl = [ p for p in range ( 1 , k + 1 ) ] <NEWLINE> dp = [ 10 ** 9 ] * ( n ) <NEWLINE> dp [ 0 ] = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> for j in kl : <NEWLINE> <INDENT> ij = i + j <NEWLINE> if ij < n : <NEWLINE> <INDENT> m = dp [ i ] + abs ( a [ i ] - a [ ij ] ) <NEWLINE> if m < dp [ ij ] : <NEWLINE> <INDENT> dp [ ij ] = m <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( dp [ n - 1 ] ) <NEWLINE> <NL> <DEDENT> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> main ( ) <NEWLINE>
from numba import njit <NEWLINE> @ njit <COMMENT> <NEWLINE> def main ( ) : <NEWLINE> <INDENT> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <COMMENT> <NL> INF = 10 ** 10 <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> dp = [ INF ] * n <NEWLINE> <NL> <COMMENT> <NL> dp [ 0 ] = 0 <NEWLINE> dp [ 1 ] = abs ( h [ 0 ] - h [ 1 ] ) <NEWLINE> <NL> <COMMENT> <NL> for i in range ( 2 , n ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <INDENT> dp [ i ] = min ( dp [ i - j ] + abs ( h [ i - j ] - h [ i ] ) for j in range ( 1 , min ( k , i ) + 1 ) ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> print ( dp [ n - 1 ] ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
from numba import njit <NEWLINE> <NL> <NL> @ njit <NEWLINE> def main ( ) : <NEWLINE> <INDENT> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> dp = [ 10 ** 6 ] * ( N + 1 ) <NEWLINE> dp [ 0 ] = 0 <NEWLINE> <NL> for i in range ( 1 , N ) : <NEWLINE> <INDENT> for j in range ( min ( i , K ) ) : <NEWLINE> <INDENT> dp [ i ] = min ( dp [ i ] , dp [ i - j - 1 ] + abs ( h [ i ] - h [ i - j - 1 ] ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( dp [ N - 1 ] ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> <NL> def main ( n , k , a ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <INDENT> kl = [ p for p in range ( 1 , k + 1 ) ] <NEWLINE> dp = [ 10 ** 9 ] * ( n ) <NEWLINE> dp [ 0 ] = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> for j in kl : <NEWLINE> <INDENT> ij = i + j <NEWLINE> if ij < n : <NEWLINE> <INDENT> m = dp [ i ] + abs ( a [ i ] - a [ ij ] ) <NEWLINE> if m < dp [ ij ] : <NEWLINE> <INDENT> dp [ ij ] = m <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( dp [ n - 1 ] ) <NEWLINE> <NL> <DEDENT> def cc_export ( ) : <NEWLINE> <INDENT> from numba . pycc import CC <NEWLINE> cc = CC ( <STRING> ) <NEWLINE> cc . export ( <STRING> , <STRING> ) ( main ) <NEWLINE> cc . compile ( ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> import sys <NEWLINE> if sys . argv [ - 1 ] == <STRING> : <NEWLINE> <COMMENT> <NL> <INDENT> cc_export ( ) <NEWLINE> exit ( 0 ) <NEWLINE> <DEDENT> from my_module import main <NEWLINE> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = np . array ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> main ( n , k , a ) <NEWLINE> <NL> <NL> <NL> <DEDENT>
import numpy as np <NEWLINE> <NL> N , K = map ( dtype = np . int64 , input ( ) . split ( ) ) <NEWLINE> hs = np . array ( list ( map ( dtype = np . int64 , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> i = 0 <NEWLINE> total_cost = 0 <NEWLINE> <NL> a = np . zeros ( N , dtype = np . int64 ) <NEWLINE> a [ 0 ] = 0 <NEWLINE> a [ 1 ] = abs ( hs [ 1 ] - hs [ 0 ] ) <NEWLINE> <NL> for i in range ( 2 , N ) : <NEWLINE> <INDENT> bmin = float ( <STRING> ) <NEWLINE> for j in range ( max ( i - K , 0 ) , i ) : <NEWLINE> <INDENT> bmin = np . min ( bmin , a [ j ] + np . abs ( hs [ i ] - hs [ j ] ) ) <NEWLINE> <DEDENT> a [ i ] = bmin <NEWLINE> <DEDENT> print ( a [ - 1 ] ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> final = [ 0 ] * n <NEWLINE> if k >= n : <NEWLINE> <INDENT> print ( abs ( l [ n - 1 ] - l [ 0 ] ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> final [ i ] = abs ( l [ i ] - l [ 0 ] ) <NEWLINE> <NL> <DEDENT> for i in range ( k + 1 , n ) : <NEWLINE> <NL> <INDENT> li = [ abs ( h [ i ] - h [ ik ] ) + dp [ ik ] for ik in range ( i - 1 , i - k - 1 , - 1 ) ] <NEWLINE> final [ i ] = min ( li ) <NEWLINE> <DEDENT> print ( final [ - 1 ] ) <NEWLINE> <DEDENT>
import math <NEWLINE> from numba import jit <NEWLINE> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> s = [ 0 ] * n <NEWLINE> @ jit <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> total = math . inf <NEWLINE> for j in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> if i - j < 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> total = min ( total , abs ( h [ i ] - h [ i - j ] ) + s [ i - j ] ) <NEWLINE> <DEDENT> s [ i ] = ( total ) <NEWLINE> <DEDENT> print ( s [ - 1 ] ) <NEWLINE>
n = int ( input ( ) <NEWLINE> arr = [ [ int ( i ) for i in list ( input ( ) . split ( ) ) ] for j in range ( n ) ] <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> arr [ i ] [ 0 ] += max ( arr [ i - 1 ] [ 1 ] , arr [ i - 1 ] [ 2 ] ) <NEWLINE> arr [ i ] [ 2 ] += max ( arr [ i - 1 ] [ 1 ] , arr [ i - 1 ] [ 0 ] ) <NEWLINE> arr [ i ] [ 1 ] += max ( arr [ i - 1 ] [ 0 ] , arr [ i - 1 ] [ 2 ] ) <NEWLINE> <DEDENT> print ( max ( arr [ n - 1 ] ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> sys . setrecursionlimit ( 1000000000 ) <NEWLINE> <NL> ABC = [ ] <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> ABC . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <DEDENT> from functools import lru_cache <NEWLINE> @ lru_cache ( maxsize = None ) <NEWLINE> def dynam ( n ) : <NEWLINE> <INDENT> if n > 1 : <NEWLINE> <INDENT> a = max ( dynam ( n - 1 ) [ 1 ] + ABC [ n - 1 ] [ 0 ] , <NEWLINE> <INDENT> dynam ( n - 1 ) [ 2 ] + ABC [ n - 1 ] [ 0 ] ) <NEWLINE> <DEDENT> b = max ( dynam ( n - 1 ) [ 0 ] + ABC [ n - 1 ] [ 1 ] , <NEWLINE> <INDENT> dynam ( n - 1 ) [ 2 ] + ABC [ n - 1 ] [ 1 ] ) <NEWLINE> <DEDENT> c = max ( dynam ( n - 1 ) [ 0 ] + ABC [ n - 1 ] [ 2 ] , <NEWLINE> <INDENT> dynam ( n - 1 ) [ 1 ] + ABC [ n - 1 ] [ 2 ] ) <NEWLINE> <DEDENT> return ( a , b , c ) <NEWLINE> <DEDENT> return tuple ( ABC [ 0 ] ) <NEWLINE> <DEDENT> print ( max ( dynam ( N ) ) ) <NEWLINE>
<COMMENT> <NL> import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = [ ] <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> A . append ( ( a , b , c ) ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> INF = 10 ** 10 <NEWLINE> <NL> <COMMENT> <NL> dp = [ [ 0 ] * 3 for _ in range ( 100010 ) ] <NEWLINE> <NL> <COMMENT> <NL> for i in range ( 5 ) : <NEWLINE> <INDENT> for j in range ( 3 ) : <NEWLINE> <INDENT> dp [ i ] [ j ] = 0 <COMMENT> <NEWLINE> <NL> <DEDENT> <DEDENT> def rec ( v ) : <NEWLINE> <COMMENT> <NL> <INDENT> for w in range ( 100010 ) : <NEWLINE> <INDENT> print ( v , w ) <NEWLINE> if dp [ v ] [ w ] > 0 : <NEWLINE> <NL> <INDENT> return dp [ v ] <NEWLINE> <DEDENT> if v == 0 : <NEWLINE> <INDENT> dp [ v ] [ w ] = 0 <NEWLINE> <NL> return dp [ v ] <NEWLINE> <DEDENT> res = 0 <NEWLINE> <COMMENT> <NL> for k in range ( 3 ) : <NEWLINE> <INDENT> if w == k : <NEWLINE> <NL> <INDENT> continue <NEWLINE> <DEDENT> res = max ( res , rec ( v - 1 ) [ k ] + A [ v - 1 ] [ w ] ) <COMMENT> <NEWLINE> dp [ v ] [ w ] = res <COMMENT> <NEWLINE> print ( v , w , k , dp [ v ] ) <NEWLINE> <DEDENT> <DEDENT> return dp [ v ] <NEWLINE> <NL> <DEDENT> rec ( N ) <NEWLINE> ans = max ( dp [ N ] ) <NEWLINE> print ( ans ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NEWLINE>
n = int ( input ( ) ) <NEWLINE> abc = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( n ) ] <NEWLINE> <COMMENT> <NL> ABC = [ [ 0 , 0 , 0 ] ] <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> for i in range ( n ) : <NEWLINE> <INDENT> a = abc [ i ] [ 0 ] + max ( ABC [ - 1 ] [ 1 ] , ABC [ - 1 ] [ 2 ] ) <COMMENT> <NEWLINE> b = abc [ i ] [ 1 ] + max ( ABC [ - 1 ] [ 0 ] , ABC [ - 1 ] [ 2 ] ) <COMMENT> <NEWLINE> c = abc [ i ] [ 2 ] + max ( ABC [ - 1 ] [ 0 ] , ABC [ - 1 ] [ 1 ] ) <COMMENT> <NEWLINE> ABC += [ [ a , b , c ] ] <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> print ( max ( ABC [ - 1 ] ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> abc_list = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( N ) ] <NEWLINE> <NL> happy_list = [ [ 0 , 0 , 0 ] ] <COMMENT> <NEWLINE> <COMMENT> <NL> for n in range ( N ) : <NEWLINE> <INDENT> before_happy_a , before_happy_b , before_happy_c = happy_list [ - 1 ] <NEWLINE> a , b , c = abc_list [ n ] <NEWLINE> tmp_happy_a = max ( before_happy_b , before_happy_c ) + a <NEWLINE> tmp_happy_b = max ( before_happy_c , before_happy_a ) + b <NEWLINE> tmp_happy_c = max ( before_happy_a , before_happy_b ) + c <NEWLINE> happy_list . append ( [ tmp_happy_a , tmp_happy_b , tmp_happy_c ] ) <NEWLINE> <NL> <DEDENT> print ( max ( happy_list [ - 1 ] ) ) s <NEWLINE>
<COMMENT> <NL> import warnings <NEWLINE> warnings . filterwarnings ( <STRING> ) <NEWLINE> import pandas as pd <NEWLINE> import numpy as np <NEWLINE> <NL> N = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> h = [ np . array ( list ( map ( int , input ( ) . split ( ) ) ) ) for _ in range ( N ) ] <NEWLINE> <NL> h = h . reshape ( 7 , 3 ) <NEWLINE> <NL> dp = np . array ( [ [ 0 ] * h . shape [ 1 ] ] * h . shape [ 0 ] ) <NEWLINE> dp [ 0 , : ] = h [ 0 , : ] <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> dp [ i , 0 ] = max ( dp [ i - 1 , 1 ] , dp [ i - 1 , 2 ] ) + h [ i , 0 ] <NEWLINE> dp [ i , 1 ] = max ( dp [ i - 1 , 0 ] , dp [ i - 1 , 2 ] ) + h [ i , 1 ] <NEWLINE> dp [ i , 2 ] = max ( dp [ i - 1 , 0 ] , dp [ i - 1 , 1 ] ) + h [ i , 2 ] <NEWLINE> <NL> <DEDENT> print ( max ( dp [ - 1 , ] ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> INF = float ( <STRING> ) <NEWLINE> <NL> h = [ ] <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> h . append ( [ a , b , c ] ) <NEWLINE> <NL> <DEDENT> dp = [ [ 0 for i in range ( 3 ) ] for j in range ( n + 1 ) ] <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> dp [ i ] [ 0 ] = max ( dp [ i - 1 ] [ 1 ] + h [ i - 1 ] [ 0 ] , dp [ i - 1 ] [ 2 ] + h [ i - 1 [ 0 ] ] ) <NEWLINE> dp [ i ] [ 1 ] = max ( dp [ i - 1 ] [ 0 ] + h [ i - 1 ] [ 1 ] , dp [ i - 1 ] [ 2 ] + h [ i - 1 [ 1 ] ] ) <NEWLINE> dp [ i ] [ 2 ] = max ( dp [ i - 1 ] [ 0 ] + h [ i - 1 ] [ 2 ] , dp [ i - 1 ] [ 1 ] + h [ i - 1 [ 2 ] ] ) <NEWLINE> <NL> <DEDENT> print ( max ( dp [ n ] [ 0 ] , dp [ n ] [ 1 ] , dp [ n ] [ 2 ] ) ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> dp = [ [ 0 , 0 , 0 ] ] <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> dp . append ( [ <NEWLINE> <INDENT> dp [ i - 1 ] [ 0 ] + max ( b , c ) , <NEWLINE> dp [ i - 1 ] [ 1 ] + max ( a , c ) , <NEWLINE> dp [ i - 1 ] [ 2 ] + max ( a , b ) <NEWLINE> <DEDENT> ] <NEWLINE> <DEDENT> print ( max ( dp [ n ] ) ) <NEWLINE> <DEDENT>
<COMMENT> <NL> N = int ( input ( ) ) <NEWLINE> Max_List = [ ] <NEWLINE> N_List = [ i for i in range ( 3 ) ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> Current_Max_List = [ ] <NEWLINE> Current_List = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if i == 0 : <NEWLINE> <INDENT> Max_List . append ( Current_List ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for j in range ( 3 ) : <NEWLINE> <INDENT> Index_List = np . array ( Max_List [ i - 1 ] ) <NEWLINE> ind = np . ones ( 3 , dtype = bool ) <NEWLINE> ind [ j ] = False <NEWLINE> Current_Max_List . append ( max ( Index_List [ ind ] ) + Current_List [ j ] ) <NEWLINE> <NL> <DEDENT> Max_List . append ( Current_Max_List ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( max ( Max_List [ - 1 ] ) ) <NEWLINE>
<COMMENT> <NL> N = int ( input ( ) ) <NEWLINE> Max_List = [ [ 0 ] * 3 for i in range ( N ) ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> Current_List = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if i == 0 : <NEWLINE> <INDENT> Max_List [ i ] = Current_List <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> Search_List = Max_List [ i - 1 ] <NEWLINE> for j in range ( 3 ) : <NEWLINE> <INDENT> Current_Search_List = Search_List [ 1 : 3 ] <NEWLINE> Max_List [ i ] [ j ] = max ( Current_Search_List ) + Current_List [ j ] <NEWLINE> Search_List . append ( Search_List [ 0 ] ) <NEWLINE> del Search_List [ 0 ] <NEWLINE> <NL> <DEDENT> Max_List [ i ] = Current_Max_List <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> print ( max ( Max_List [ - 1 ] ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> arr = [ ] * N <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> arr . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> <DEDENT> dp = [ 0 , 0 , 0 ] <NEWLINE> for a in arr : <NEWLINE> <INDENT> dp = [ a [ 0 ] + max ( dp [ 1 ] , dp [ 2 ] ) , a [ 1 ] + max ( dp [ 0 ] , dp [ 2 ] ) , a [ 2 ] + max ( dp [ 0 ] , dp [ 1 ] ) ] <NEWLINE> <DEDENT> return max ( dp ) <NEWLINE>
n , W = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> dp = np . zeros ( [ n + 1 , W + 1 ] , dtype = int ) <NEWLINE> <NL> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> w , v = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> dp [ i ] [ : w ] = dp [ i - 1 ] [ : w ] <NEWLINE> dp [ i ] [ w : ] = np . maximum ( dp [ i - 1 ] [ : W - w + 1 ] + v , dp [ i - 1 ] [ w : ] ) <NEWLINE> <DEDENT> print ( np . max ( dp ) ) <NEWLINE>
[ N , W ] = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> wv = [ [ 0 , 0 ] ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> wv . append ( [ int ( x ) for x in input ( ) . split ( ) ] ) <NEWLINE> <DEDENT> dp = np . zeros ( [ N + 1 , W + i ] , dtype = int ) <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> dp [ i ] [ : w ] = dp [ i - 1 ] [ : w ] <NEWLINE> dp [ i ] [ w : ] = max ( dp [ i - 1 ] [ w : ] , dp [ i - 1 ] [ w - wv [ i ] [ 0 ] : ] + wv [ i ] [ 1 ] ) <NEWLINE> <NL> <DEDENT> print ( dp [ N ] [ W ] ) <NEWLINE>
import numpy as np <NEWLINE> N , W = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> dp = np . zeros ( ( N + 1 , W + 1 ) , dtype = np . int64 ) <NEWLINE> <NL> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> w , v = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <INDENT> dp [ i ] = dp [ i - 1 ] <NEWLINE> dp [ i ] [ w : ] = np . maximum ( dp [ i - 1 ] [ : W - w + 1 ] + v , dp [ i - 1 ] [ w : ] ) <NEWLINE> <DEDENT> <DEDENT> print ( np . max ( dp ) ) <NEWLINE>
6 15 <NEWLINE> 6 5 <NEWLINE> 5 6 <NEWLINE> 6 4 <NEWLINE> 6 6 <NEWLINE> 3 5 <NEWLINE> 7 2 <NEWLINE>
import numpy as np <NEWLINE> <NL> N , W = map ( int , input ( ) . split ( ) ) <NEWLINE> w = np . empty ( N ) <NEWLINE> v = np . empty ( N ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> w [ i ] , v [ i ] = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <DEDENT> dp = np . zeros ( W + 1 , dtype = np . int64 ) <NEWLINE> dp [ w [ 0 ] ] = v [ 0 ] <NEWLINE> <NL> for i in range ( 1 , N ) : <NEWLINE> <INDENT> dp [ w [ i ] : ] = np . maximum ( dp [ w [ i ] : ] , dp [ : W - w [ i ] + 1 ] + v [ i ] ) <NEWLINE> <NL> <DEDENT> print ( dp . max ( ) ) <NEWLINE>
import numpy as np <NEWLINE> <NL> N , W = map ( int , input ( ) . split ( ) ) <NEWLINE> knap = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> knap . append ( tuple ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> <DEDENT> s_val = sum ( [ v for w , v in knap ] ) <NEWLINE> <NL> INF = float ( <STRING> ) <NEWLINE> dp = np . full ( s_val + 1 , INF ) <NEWLINE> <NL> for i , ( w , v ) in enumerate ( knap ) : <NEWLINE> <INDENT> dp [ v : ] = np . minimum ( dp [ v : ] , dp [ : - v ] + w ) <NEWLINE> <NL> <DEDENT> print ( max ( [ i for i in range ( s_val + 1 ) if dp [ i ] <= W ] ) ) <NEWLINE>
from sys import stdin , stdout <NEWLINE> import numba as nb <NEWLINE> <NL> @ nb . njit ( ) <NEWLINE> def solve ( n , w , weights , values ) : <NEWLINE> <INDENT> dp = [ [ 0 for _ in range ( w + 1 ) ] for k in range ( n + 1 ) ] <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , w + 1 ) : <NEWLINE> <INDENT> if weights [ i ] <= j : <NEWLINE> <INDENT> dp [ i ] [ j ] = max ( dp [ i - 1 ] [ j ] , <NEWLINE> <INDENT> dp [ i - 1 ] [ j - weights [ i ] ] + values [ i ] ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> dp [ i ] [ j ] = dp [ i - 1 ] [ j ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return dp [ n ] [ w ] <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> n , w = map ( int , stdin . readline ( ) . split ( ) ) <NEWLINE> values = [ ] <NEWLINE> weights = [ ] <NEWLINE> <NL> for _ in range ( n ) : <NEWLINE> <INDENT> v , a = map ( int , stdin . readline ( ) . split ( ) ) <NEWLINE> values . append ( a ) <NEWLINE> weights . append ( v ) <NEWLINE> <NL> <DEDENT> values = [ 0 ] + values <NEWLINE> weights = [ 0 ] + weights <NEWLINE> print ( solve ( n , w , weights , values ) ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> from collections import defaultdict <NEWLINE> from heapq import heappush , heappop <NEWLINE> import sys <NEWLINE> import numpy as np <NEWLINE> import numba <NEWLINE> <NL> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> input = sys . stdin . buffer . readline <NEWLINE> INF = 10 ** 9 + 1 <COMMENT> <NEWLINE> <NL> <NL> def debug ( * x ) : <NEWLINE> <INDENT> print ( * x ) <NEWLINE> <NL> <NL> <DEDENT> @ numba . njit <NEWLINE> def get_longest ( start , values , next , head , longest ) : <NEWLINE> <INDENT> ret = longest [ start ] <NEWLINE> if ret != - 1 : <NEWLINE> <INDENT> return ret <NEWLINE> <NL> <DEDENT> ret = 0 <NEWLINE> p = head [ start ] <NEWLINE> while p : <NEWLINE> <INDENT> v = values [ p ] <NEWLINE> x = get_longest ( v , values , next , head , longest ) + 1 <NEWLINE> if x > ret : <NEWLINE> <INDENT> ret = x <NEWLINE> <DEDENT> p = next [ p ] <NEWLINE> <NL> <DEDENT> longest [ start ] = ret <NEWLINE> return ret <NEWLINE> <NL> <NL> <DEDENT> @ numba . njit <NEWLINE> def solve ( N , M , data ) : <NEWLINE> <INDENT> longest = np . repeat ( - 1 , N + 1 ) <NEWLINE> <NL> values = np . zeros ( M + 1 , np . int16 ) <NEWLINE> next = np . zeros ( M + 1 , np . int16 ) <NEWLINE> head = np . zeros ( N + 1 , np . int16 ) <NEWLINE> p = 1 <NEWLINE> for i in range ( 0 , 2 * M , 2 ) : <NEWLINE> <INDENT> v1 = data [ i ] <NEWLINE> v2 = data [ i + 1 ] <NEWLINE> values [ p ] = v2 <NEWLINE> next [ p ] = head [ v1 ] <NEWLINE> head [ v1 ] = p <NEWLINE> p += 1 <NEWLINE> <NL> <DEDENT> for i in range ( N + 1 ) : <NEWLINE> <INDENT> if head [ i ] == 0 : <NEWLINE> <INDENT> longest [ i ] = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> ret = 0 <NEWLINE> for v in range ( N + 1 ) : <NEWLINE> <INDENT> x = get_longest ( v , values , next , head , longest ) <NEWLINE> if x > ret : <NEWLINE> <INDENT> ret = x <NEWLINE> <DEDENT> <DEDENT> return ret <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> data = np . int16 ( read ( ) . split ( ) ) <NEWLINE> print ( solve ( N , M , data ) ) <NEWLINE> <NL> <NL> <DEDENT> T1 = <STRING> <NEWLINE> <NL> T2 = <STRING> <NEWLINE> <NL> T3 = <STRING> <NEWLINE> <NL> <NL> def _test ( ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> import doctest <NEWLINE> doctest . testmod ( ) <NEWLINE> <NL> <NL> <DEDENT> def as_input ( s ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> import io <NEWLINE> global read , input <NEWLINE> f = io . StringIO ( s . strip ( ) ) <NEWLINE> input = f . readline <NEWLINE> read = f . read <NEWLINE> <NL> <NL> <DEDENT> USE_NUMBA = False <NEWLINE> if ( USE_NUMBA and sys . argv [ - 1 ] == <STRING> ) or sys . argv [ - 1 ] == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> from numba . pycc import CC <NEWLINE> import numba <NEWLINE> cc = CC ( <STRING> ) <NEWLINE> cc . export ( <NEWLINE> <INDENT> <STRING> , <NEWLINE> numba . i8 ( <NEWLINE> <INDENT> numba . i8 , numba . i8 , <NEWLINE> numba . typeof ( { 1 : [ 1 ] } ) ) ) ( solve ) <NEWLINE> <DEDENT> <DEDENT> cc . compile ( ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> input = sys . stdin . buffer . readline <NEWLINE> read = sys . stdin . buffer . read <NEWLINE> <NL> if ( USE_NUMBA and sys . argv [ - 1 ] != <STRING> ) or sys . argv [ - 1 ] == <STRING> : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <INDENT> from my_module import solve <COMMENT> <NEWLINE> <DEDENT> elif sys . argv [ - 1 ] == <STRING> : <NEWLINE> <INDENT> _test ( ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> elif sys . argv [ - 1 ] != <STRING> and len ( sys . argv ) == 2 : <NEWLINE> <COMMENT> <NL> <INDENT> input_as_file = open ( sys . argv [ 1 ] ) <NEWLINE> input = input_as_file . buffer . readline <NEWLINE> read = input_as_file . buffer . read <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> <NL> <NL> class DAG : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <COMMENT> <NL> <INDENT> self . n = n <NEWLINE> self . adj = [ [ ] for _ in range ( n ) ] <NEWLINE> <NL> <DEDENT> def addEdge ( self , parent , child ) : <NEWLINE> <INDENT> self . adj [ parent ] . append ( child ) <NEWLINE> <NL> <DEDENT> def dfs ( self , node ) : <NEWLINE> <INDENT> ans = 0 <NEWLINE> for child in self . adj [ node ] : <NEWLINE> <INDENT> ans = max ( ans , 1 + self . dfs ( child ) ) <NEWLINE> <DEDENT> return ans <NEWLINE> <NL> <DEDENT> def dfsWithMemo ( self , node , memo , visited ) : <NEWLINE> <INDENT> if ( visited [ node ] ) : <NEWLINE> <INDENT> return memo [ node ] <NEWLINE> <DEDENT> visited [ node ] = True <NEWLINE> for child in self . adj [ node ] : <NEWLINE> <INDENT> memo [ node ] = max ( <NEWLINE> <INDENT> memo [ node ] , 1 + self . dfsWithMemo ( child , memo , visited ) ) <NEWLINE> <DEDENT> <DEDENT> return memo [ node ] <NEWLINE> <NL> <DEDENT> def dfsWithDp ( self , node , dp , visited ) : <NEWLINE> <INDENT> if ( visited [ node ] ) : <NEWLINE> <INDENT> return dp [ node ] <NEWLINE> <DEDENT> visited [ node ] = True <NEWLINE> for child in self . adj [ node ] : <NEWLINE> <INDENT> if not visited [ child ] : <NEWLINE> <INDENT> self . dfsWithDp ( child , dp , visited ) <NEWLINE> <DEDENT> dp [ node ] = max ( dp [ node ] , 1 + self . dfsWithDp ( child , dp , visited ) ) <NEWLINE> <DEDENT> return dp [ node ] <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> def findLongestPathNaive ( self ) : <NEWLINE> <INDENT> ans = 0 <NEWLINE> for i in range ( self . n ) : <NEWLINE> <INDENT> ans = max ( ans , self . dfs ( i ) ) <NEWLINE> <DEDENT> return ans <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> def findLongestPathWithMemo ( self ) : <NEWLINE> <INDENT> visited = [ False ] * self . n <NEWLINE> memo = [ 0 ] * self . n <NEWLINE> ans = 0 <NEWLINE> for i in range ( self . n ) : <NEWLINE> <INDENT> ans = max ( ans , self . dfsWithMemo ( i , memo , visited ) ) <NEWLINE> <DEDENT> return ans <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> def findLongestPathWithDp ( self ) : <NEWLINE> <INDENT> visited = [ False ] * self . n <NEWLINE> dp = [ 0 ] * self . n <COMMENT> <NEWLINE> ans = 0 <NEWLINE> for i in range ( self . n ) : <NEWLINE> <INDENT> ans = max ( ans , self . dfsWithDp ( i , dp , visited ) ) <NEWLINE> <DEDENT> return ans <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <INDENT> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> dag = DAG ( N ) <NEWLINE> for _ in range ( M ) : <NEWLINE> <INDENT> parent , child = map ( lambda i : int ( i ) - 1 , input ( ) . split ( ) ) <NEWLINE> dag . addEdge ( parent , child ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> print ( dag . findLongestPathWithDp ( ) ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> main ( ) <NEWLINE>
<COMMENT> <NL> <STRING> <NEWLINE> from collections import defaultdict <NEWLINE> import sys <NEWLINE> <NL> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> <NL> <NL> def solve ( N , M , edges ) : <NEWLINE> <INDENT> longest = { } <NEWLINE> <NL> stack = [ v for v in edges ] <NEWLINE> <NL> while stack : <NEWLINE> <INDENT> v = stack . pop ( ) <NEWLINE> if v > 0 : <NEWLINE> <INDENT> if v in longest : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> next_edges = edges . get ( v ) <NEWLINE> stack . append ( - v ) <NEWLINE> if next_edges : <NEWLINE> <INDENT> stack . extend ( next_edges ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> next_edges = edges . get ( - v ) <NEWLINE> if not next_edges : <NEWLINE> <INDENT> ret = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ret = max ( longest [ x ] for x in next_edges ) + 1 <NEWLINE> <DEDENT> longest [ - v ] = ret <NEWLINE> <NL> <DEDENT> <DEDENT> return max ( longest [ v ] for v in edges ) <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> edges = defaultdict ( set ) <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> v1 , v2 = map ( int , input ( ) . split ( ) ) <NEWLINE> edges [ v1 ] . add ( v2 ) <NEWLINE> <NL> <DEDENT> print ( solve ( N , M , edges ) ) <NEWLINE> <NL> <NL> <DEDENT> T1 = <STRING> <NEWLINE> <NL> T2 = <STRING> <NEWLINE> <NL> T3 = <STRING> <NEWLINE> <NL> <NL> def _test ( ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> import doctest <NEWLINE> doctest . testmod ( ) <NEWLINE> <NL> <NL> <DEDENT> def as_input ( s ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> import io <NEWLINE> global read , input <NEWLINE> f = io . StringIO ( s . strip ( ) ) <NEWLINE> input = f . readline <NEWLINE> read = f . read <NEWLINE> <NL> <NL> <DEDENT> USE_NUMBA = False <NEWLINE> if ( USE_NUMBA and sys . argv [ - 1 ] == <STRING> ) or sys . argv [ - 1 ] == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> from numba . pycc import CC <NEWLINE> cc = CC ( <STRING> ) <NEWLINE> cc . export ( <STRING> , solve . __doc__ . strip ( ) . split ( ) [ 0 ] ) ( solve ) <NEWLINE> cc . compile ( ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> input = sys . stdin . buffer . readline <NEWLINE> read = sys . stdin . buffer . read <NEWLINE> <NL> if ( USE_NUMBA and sys . argv [ - 1 ] != <STRING> ) or sys . argv [ - 1 ] == <STRING> : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <INDENT> from my_module import solve <COMMENT> <NEWLINE> <DEDENT> elif sys . argv [ - 1 ] == <STRING> : <NEWLINE> <INDENT> _test ( ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> elif sys . argv [ - 1 ] != <STRING> and len ( sys . argv ) == 2 : <NEWLINE> <COMMENT> <NL> <INDENT> input_as_file = open ( sys . argv [ 1 ] ) <NEWLINE> input = input_as_file . buffer . readline <NEWLINE> read = input_as_file . buffer . read <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE> <DEDENT> T1 = <STRING> <NEWLINE> <NL> T2 = <STRING> <NEWLINE> <NL> T3 = <STRING> <NEWLINE> <NL> <NL> def _test ( ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> import doctest <NEWLINE> doctest . testmod ( ) <NEWLINE> <NL> <NL> <DEDENT> def as_input ( s ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> import io <NEWLINE> global read , input <NEWLINE> f = io . StringIO ( s . strip ( ) ) <NEWLINE> input = f . readline <NEWLINE> read = f . read <NEWLINE> <NL> <NL> <DEDENT> USE_NUMBA = False <NEWLINE> if ( USE_NUMBA and sys . argv [ - 1 ] == <STRING> ) or sys . argv [ - 1 ] == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> from numba . pycc import CC <NEWLINE> cc = CC ( <STRING> ) <NEWLINE> cc . export ( <STRING> , solve . __doc__ . strip ( ) . split ( ) [ 0 ] ) ( solve ) <NEWLINE> cc . compile ( ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> input = sys . stdin . buffer . readline <NEWLINE> read = sys . stdin . buffer . read <NEWLINE> <NL> if ( USE_NUMBA and sys . argv [ - 1 ] != <STRING> ) or sys . argv [ - 1 ] == <STRING> : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <INDENT> from my_module import solve <COMMENT> <NEWLINE> <DEDENT> elif sys . argv [ - 1 ] == <STRING> : <NEWLINE> <INDENT> _test ( ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> elif sys . argv [ - 1 ] != <STRING> and len ( sys . argv ) == 2 : <NEWLINE> <COMMENT> <NL> <INDENT> input_as_file = open ( sys . argv [ 1 ] ) <NEWLINE> input = input_as_file . buffer . readline <NEWLINE> read = input_as_file . buffer . read <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> from collections import defaultdict <NEWLINE> from heapq import heappush , heappop <NEWLINE> import sys <NEWLINE> import numpy as np <NEWLINE> <NL> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> input = sys . stdin . buffer . readline <NEWLINE> INF = 10 ** 9 + 1 <COMMENT> <NEWLINE> <NL> <NL> def debug ( * x ) : <NEWLINE> <INDENT> print ( * x ) <NEWLINE> <NL> <NL> <DEDENT> @ numba . njit ( cache = True ) <NEWLINE> def get_longest ( start , values , next , head , longest ) : <NEWLINE> <INDENT> ret = longest [ start ] <NEWLINE> if ret != - 1 : <NEWLINE> <INDENT> return ret <NEWLINE> <NL> <DEDENT> ret = 0 <NEWLINE> p = head [ start ] <NEWLINE> while p : <NEWLINE> <INDENT> v = values [ p ] <NEWLINE> x = get_longest ( v , values , next , head , longest ) + 1 <NEWLINE> if x > ret : <NEWLINE> <INDENT> ret = x <NEWLINE> <DEDENT> p = next [ p ] <NEWLINE> <NL> <DEDENT> longest [ start ] = ret <NEWLINE> return ret <NEWLINE> <NL> <NL> <DEDENT> @ numba . njit ( cache = True ) <NEWLINE> def solve ( N , M , data ) : <NEWLINE> <INDENT> longest = np . repeat ( - 1 , N + 1 ) <NEWLINE> <NL> values = np . zeros ( M + 1 , np . int32 ) <NEWLINE> next = np . zeros ( M + 1 , np . int32 ) <NEWLINE> head = np . zeros ( N + 1 , np . int32 ) <NEWLINE> p = 1 <NEWLINE> for i in range ( 0 , 2 * M , 2 ) : <NEWLINE> <INDENT> v1 = data [ i ] <NEWLINE> v2 = data [ i + 1 ] <NEWLINE> values [ p ] = v2 <NEWLINE> next [ p ] = head [ v1 ] <NEWLINE> head [ v1 ] = p <NEWLINE> p += 1 <NEWLINE> <NL> <DEDENT> for i in range ( N + 1 ) : <NEWLINE> <INDENT> if head [ i ] == 0 : <NEWLINE> <INDENT> longest [ i ] = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> ret = 0 <NEWLINE> for v in range ( N + 1 ) : <NEWLINE> <INDENT> x = get_longest ( v , values , next , head , longest ) <NEWLINE> if x > ret : <NEWLINE> <INDENT> ret = x <NEWLINE> <DEDENT> <DEDENT> return ret <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> data = np . int32 ( read ( ) . split ( ) ) <NEWLINE> print ( solve ( N , M , data ) ) <NEWLINE> <NL> <NL> <DEDENT> T1 = <STRING> <NEWLINE> <NL> T2 = <STRING> <NEWLINE> <NL> T3 = <STRING> <NEWLINE> <NL> <NL> def _test ( ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> import doctest <NEWLINE> doctest . testmod ( ) <NEWLINE> <NL> <NL> <DEDENT> def as_input ( s ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> import io <NEWLINE> global read , input <NEWLINE> f = io . StringIO ( s . strip ( ) ) <NEWLINE> input = f . readline <NEWLINE> read = f . read <NEWLINE> <NL> <NL> <DEDENT> USE_NUMBA = False <NEWLINE> if ( USE_NUMBA and sys . argv [ - 1 ] == <STRING> ) or sys . argv [ - 1 ] == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> import numba <NEWLINE> numba . njit ( cache = True ) ( get_longest ) <NEWLINE> numba . njit ( cache = True ) ( solve ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> input = sys . stdin . buffer . readline <NEWLINE> read = sys . stdin . buffer . read <NEWLINE> <NL> if ( USE_NUMBA and sys . argv [ - 1 ] != <STRING> ) or sys . argv [ - 1 ] == <STRING> : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <INDENT> import <NEWLINE> <NL> <DEDENT> elif sys . argv [ - 1 ] == <STRING> : <NEWLINE> <INDENT> _test ( ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> elif sys . argv [ - 1 ] != <STRING> and len ( sys . argv ) == 2 : <NEWLINE> <COMMENT> <NL> <INDENT> input_as_file = open ( sys . argv [ 1 ] ) <NEWLINE> input = input_as_file . buffer . readline <NEWLINE> read = input_as_file . buffer . read <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE> <DEDENT>
v = pow ( 10 , 9 ) + 7 <NEWLINE> arr = [ ] <NEWLINE> inp = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> row = inp [ 0 ] <NEWLINE> col = in [ 1 ] <NEWLINE> for i in range ( row ) : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> arr . append ( s ) <NEWLINE> <DEDENT> ans = [ [ 0 for i in range ( col ) ] for j in range ( row ) ] <NEWLINE> for i in range ( col ) : <NEWLINE> <INDENT> if arr [ 0 ] [ i ] == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans [ 0 ] [ i ] = 1 <NEWLINE> <DEDENT> <DEDENT> for i in range ( row ) : <NEWLINE> <INDENT> if arr [ i ] [ 0 ] == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans [ i ] [ 0 ] = 1 <NEWLINE> <DEDENT> <DEDENT> for i in range ( 1 , row ) : <NEWLINE> <INDENT> for j in range ( 1 , col ) : <NEWLINE> <INDENT> if arr [ i ] [ j ] == <STRING> : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> arr [ i ] [ j ] = ( arr [ i - 1 ] [ j ] + arr [ i ] [ j - 1 ] ) % v <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( arr [ - 1 ] [ - 1 ] ) <NEWLINE>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> def grid ( y , x , mp ) : <NEWLINE> <INDENT> mod = 10 ** 9 + 7 <NEWLINE> dp = [ [ 0 ] * y for _ in range ( x ) ] <NEWLINE> dp [ 0 ] [ 0 ] = 1 <NEWLINE> for h in range ( y ) : <NEWLINE> <INDENT> for w in range ( x ) : <NEWLINE> <INDENT> if mp [ h ] [ w ] == <STRING> : <NEWLINE> <INDENT> if h >= 1 : <NEWLINE> <INDENT> dp [ h ] [ w ] += ( dp [ h - 1 ] [ w ] % mod ) <NEWLINE> <DEDENT> if w >= 1 : <NEWLINE> <INDENT> dp [ h ] [ w ] += ( dp [ h ] [ w - 1 ] % mod ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> return dp [ y - 1 ] [ x - 1 ] % mod <NEWLINE> <NL> <NL> <DEDENT> H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> mp = [ ] <NEWLINE> for _ in range ( H ) : <NEWLINE> <INDENT> mp . append ( list ( input ( ) ) ) <NEWLINE> <DEDENT> print ( grid ( H , W , mp ) ) <NEWLINE> <NL>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> dp = [ ] <NEWLINE> for i in range ( n + 1 ) : <NEWLINE> <INDENT> dp . append ( [ ] ) <NEWLINE> for j in range ( m + 1 ) : <NEWLINE> <INDENT> dp [ i ] . append ( 0 ) <NEWLINE> <DEDENT> <DEDENT> arr = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> arr . append ( input ( ) ) <NEWLINE> <DEDENT> dp [ 1 ] [ 1 ] = 1 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , m + 1 ) : <NEWLINE> <INDENT> if arr [ i - 1 ] [ j - 1 ] == <STRING> or ( i == 1 and j == 1 ) : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> dp [ i ] [ j ] = dp [ i - 1 ] [ j ] + dp [ i ] [ j - 1 ] <NEWLINE> <DEDENT> <DEDENT> print ( dp [ n ] [ m ] % 1000000007 <NEWLINE>
import sys <NEWLINE> readline = sys . stdin . readline <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> N = int ( input ( ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> p = list ( map ( float , readline ( ) . split ( ) ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> dp = [ [ 0.0 ] * ( N + 1 ) for _ in range ( N + 1 ) ] <NEWLINE> <NL> dp [ 0 ] [ 0 ] = 1 <NEWLINE> <NL> for i , p in enumerate ( p , 1 ) : <NEWLINE> <INDENT> pp = 1 - p <NEWLINE> dpij = dp [ i ] [ j ] <NEWLINE> dpi = dp [ i - 1 ] <NEWLINE> for j in range ( i + 1 ) : <NEWLINE> <INDENT> if j == 0 : <NEWLINE> <INDENT> dpij = dpi [ j ] * pp <NEWLINE> <DEDENT> elif j == i : <NEWLINE> <INDENT> dpij = dpi [ j - 1 ] * p <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dpij = dpi [ j - 1 ] * p + dpi [ j ] * pp <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> res = 0.0 <NEWLINE> n = N // 2 + 1 <NEWLINE> <NL> for cnt in dp [ - 1 ] [ n : ] : <NEWLINE> <INDENT> res += cnt <NEWLINE> <NL> <DEDENT> print ( res ) <NEWLINE>
import numpy as np <NEWLINE> from numba import njit <NEWLINE> <NL> <NL> @ njit ( <STRING> , cache = True ) <NEWLINE> def solve ( dp , N , n1 , n2 , n3 ) : <NEWLINE> <NL> <INDENT> if dp [ n1 ] [ n2 ] [ n3 ] >= 0.0 : <NEWLINE> <INDENT> return dp [ n1 ] [ n2 ] [ n3 ] <NEWLINE> <DEDENT> if n1 == n2 == n3 == 0 : <NEWLINE> <INDENT> return 0.0 <NEWLINE> <NL> <DEDENT> cnt = n1 + n2 + n3 <NEWLINE> ret = 0 <NEWLINE> if n3 >= 1 : <NEWLINE> <INDENT> ret += solve ( dp , N , n1 , n2 + 1 , n3 - 1 ) * n3 <NEWLINE> <DEDENT> if n2 >= 1 : <NEWLINE> <INDENT> ret += solve ( dp , N , n1 + 1 , n2 - 1 , n3 ) * n2 <NEWLINE> <DEDENT> if n1 >= 1 : <NEWLINE> <INDENT> ret += solve ( dp , N , n1 - 1 , n2 , n3 ) * n1 <NEWLINE> <NL> <DEDENT> ret = ( ret + N ) / cnt <NEWLINE> dp [ n1 ] [ n2 ] [ n3 ] = ret <NEWLINE> return ret <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> dp = np . full ( ( N + 1 , N + 1 , N + 1 ) , - 1 , dtype = np . float64 ) <NEWLINE> <NL> a1 , a2 , a3 = 0 , 0 , 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if A [ i ] == 1 : <NEWLINE> <INDENT> a1 += 1 <NEWLINE> <DEDENT> elif A [ i ] == 2 : <NEWLINE> <INDENT> a2 += 1 <NEWLINE> <DEDENT> elif A [ i ] == 3 : <NEWLINE> <INDENT> a3 += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( solve ( dp , N , a1 , a2 , a3 ) ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> import numpy as np <NEWLINE> from numba import njit <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> <NL> read = sys . stdin . buffer . read <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> readlines = sys . stdin . buffer . readlines <NEWLINE> <NL> in_n = lambda : int ( readline ( ) ) <NEWLINE> in_nn = lambda : map ( int , readline ( ) . split ( ) ) <NEWLINE> in_s = lambda : readline ( ) . rstrip ( ) . decode ( <STRING> ) <NEWLINE> in_nl = lambda : list ( map ( int , readline ( ) . split ( ) ) ) <NEWLINE> in_nl2 = lambda H : [ in_nl ( ) for _ in range ( H ) ] <NEWLINE> in_map = lambda : [ s == ord ( <STRING> ) for s in readline ( ) if s != ord ( <STRING> ) ] <NEWLINE> in_map2 = lambda H : [ in_map ( ) for _ in range ( H ) ] <NEWLINE> in_all = lambda : map ( int , read ( ) . split ( ) ) <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <NL> <INDENT> N = in_n ( ) <NEWLINE> A = in_nl ( ) <NEWLINE> <NL> n1 = A . count ( 1 ) <NEWLINE> n2 = A . count ( 2 ) <NEWLINE> n3 = A . count ( 3 ) <NEWLINE> <NL> dp = np . full ( ( N + 1 , N + 1 , N + 1 ) , - 1 , dtype = np . float64 ) <NEWLINE> dp [ 0 ] [ 0 ] [ 0 ] = 0 <NEWLINE> <NL> print ( solve ( N , dp , n1 , n2 , n3 ) ) <NEWLINE> <NL> <NL> <DEDENT> @ njit ( <STRING> , cache = True ) <NEWLINE> def solve ( N , dp , n1 , n2 , n3 ) : <NEWLINE> <NL> <INDENT> if dp [ n1 ] [ n2 ] [ n3 ] != - 1 : <NEWLINE> <INDENT> return dp [ n1 ] [ n2 ] [ n3 ] <NEWLINE> <NL> <DEDENT> cnt = n1 + n2 + n3 <NEWLINE> ret = 0 <NEWLINE> if n3 >= 1 : <NEWLINE> <INDENT> ret += solve ( N , dp , n1 , n2 + 1 , n3 - 1 ) * n3 / cnt <NEWLINE> <DEDENT> if n2 >= 1 : <NEWLINE> <INDENT> ret += solve ( N , dp , n1 + 1 , n2 - 1 , n3 ) * n2 / cnt <NEWLINE> <DEDENT> if n1 >= 1 : <NEWLINE> <INDENT> ret += solve ( N , dp , n1 - 1 , n2 , n3 ) * n1 / cnt <NEWLINE> <NL> <DEDENT> dp [ n1 ] [ n2 ] [ n3 ] = ret + ( N / cnt ) <NEWLINE> return ret + ( N / cnt ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a . append ( int ( input ( ) ) ) <NEWLINE> <NL> <DEDENT> dp = [ False ] * ( k + 1 ) <NEWLINE> dp [ 0 ] = 0 <NEWLINE> <NL> for i in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for j in range ( n ) : <NEWLINE> <INDENT> if i - a [ j ] >= 0 and dp [ i - a [ j ] ] == 0 : <NEWLINE> <INDENT> dp [ i ] = 1 <NEWLINE> break <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> if dp [ k ] == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> List = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> DP = [ False ] * ( 2 * K + 1 ) <NEWLINE> for i in range ( K ) : <NEWLINE> <INDENT> for item in List : <NEWLINE> <INDENT> if DP [ i ] == False : <NEWLINE> <INDENT> DP [ i + item ] = True <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if DP [ k ] == True : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> <STRING> <NEWLINE> import sys <NEWLINE> sys . setrecursionlimit ( 1 << 25 ) <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> read = sys . stdin . readline <COMMENT> <NEWLINE> <NL> import numpy as np <NEWLINE> from functools import partial <NEWLINE> array = partial ( np . array , dtype = np . int64 ) <NEWLINE> zeros = partial ( np . zeros , dtype = np . int64 ) <NEWLINE> full = partial ( np . full , dtype = np . int64 ) <NEWLINE> <NL> <NL> def a_int ( ) : return int ( readline ( ) ) <NEWLINE> <NL> <NL> def ints ( ) : return np . fromstring ( readline ( ) , sep = <STRING> , dtype = np . int64 ) <NEWLINE> <NL> <NL> MOD = 10 ** 9 + 7 <NEWLINE> INF = 2 ** 31 <COMMENT> <NEWLINE> <COMMENT> <NL> <NL> N = a_int ( ) <NEWLINE> A = ints ( ) <NEWLINE> <NL> <NL> from numba import njit <NEWLINE> <NL> <NL> @ njit ( <STRING> , cache = True ) <NEWLINE> def solve ( N , A , dp ) : <NEWLINE> <INDENT> dp = np . zeros ( ( N + 1 , N + 1 ) , dtype = np . int64 ) <NEWLINE> for i in range ( N - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , N + 1 ) : <NEWLINE> <INDENT> dp [ i , j ] = max ( A [ i ] - dp [ i + 1 , j ] , A [ j - 1 ] - dp [ i , j - 1 ] ) <NEWLINE> <DEDENT> <DEDENT> print ( dp [ 0 , N ] ) <NEWLINE> <COMMENT> <NL> <NL> <NL> <DEDENT> solve ( N , A ) <NEWLINE>
import numpy as np <NEWLINE> from numba import njit <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> scores = np . array ( list ( map ( int , input ( ) . split ( ) ) ) , dtype = <STRING> ) <NEWLINE> <NL> @ njit ( <STRING> , cache = True ) <NEWLINE> def get_max_score ( scores , i , j ) : <NEWLINE> <INDENT> if i == j : <NEWLINE> <INDENT> return scores [ i ] <NEWLINE> <DEDENT> return max ( scores [ i ] - get_max_score ( scores , i + 1 , j ) , scores [ j ] - get_max_score ( scores , i , j - 1 ) ) <NEWLINE> <NL> <DEDENT> print ( get_max_score ( scores , 0 , len ( scores ) - 1 ) ) <NEWLINE>
import numpy as np <NEWLINE> from numba import njit <NEWLINE> <NL> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> a = np . array ( [ int ( i ) for i in input ( ) . split ( ) ] , dtype = np . int64 ) <NEWLINE> <NL> dp = np . full ( ( N + 1 , K + 1 ) , 0 , dtype = np . int64 ) <NEWLINE> c = np . full ( K + 2 , 0 , dtype = np . int64 ) <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> <NL> @ njit ( <STRING> , cache = True ) <NEWLINE> def main ( N , K , MOD , dp , c ) : <NEWLINE> <NL> <INDENT> dp [ 0 ] [ 0 ] = 1 <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> c [ 0 ] = 0 <NEWLINE> for j in range ( 1 , K + 2 ) : <NEWLINE> <INDENT> c [ j ] = ( c [ j - 1 ] + dp [ i - 1 ] [ j - 1 ] ) % MOD <NEWLINE> <DEDENT> for j in range ( K + 1 ) : <NEWLINE> <INDENT> dp [ i ] [ j ] = ( c [ j + 1 ] - c [ max ( 0 , j - a [ i - 1 ] ) ] ) % MOD <NEWLINE> <NL> <DEDENT> <DEDENT> return dp [ N ] [ K ] <NEWLINE> <NL> <DEDENT> print ( main ( N , K , dp , c ) ) <NEWLINE>
import numpy as np <NEWLINE> from numba import njit <NEWLINE> <NL> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> max_candies = np . array ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> dpt = np . full ( ( N + 1 , K + 1 ) , 0 , dtype = <STRING> ) <NEWLINE> for i in range ( K + 1 ) : <NEWLINE> <INDENT> dpt [ 0 ] [ i ] = 1 <NEWLINE> <NL> <DEDENT> @ njit ( <STRING> , cache = True ) <NEWLINE> def dp ( N , K , max_candies , dpt ) : <NEWLINE> <INDENT> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> for j in range ( 0 , K + 1 ) : <NEWLINE> <INDENT> dpt [ i ] [ j ] += dpt [ i - 1 ] [ j ] <NEWLINE> t = j - max_candies [ i - 1 ] - 1 <NEWLINE> if t >= 0 : <NEWLINE> <INDENT> dpt [ i ] [ j ] -= dpt [ i - 1 ] [ t ] <NEWLINE> <DEDENT> if j > 0 : <NEWLINE> <INDENT> dpt [ i ] [ j ] += dpt [ i ] [ j - 1 ] <NEWLINE> <DEDENT> dpt [ i ] [ j ] = dpt [ i ] [ j ] % ( 10 ** 9 + 7 ) <NEWLINE> <DEDENT> <DEDENT> return ( dpt [ N ] [ K ] - dpt [ N ] [ K - 1 ] ) % ( 10 ** 9 + 7 ) <NEWLINE> <NL> <DEDENT> if K > 0 : <NEWLINE> <INDENT> print ( dp ( N , K , max_candies , dpt ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> from numba import njit <NEWLINE> N = int ( input ( ) ) <NEWLINE> a = np . array ( [ int ( i ) for i in input ( ) . split ( ) ] , dtype = np . int64 ) <NEWLINE> <NL> s = [ 0 ] <NEWLINE> <NL> dp = np . array ( [ [ - 1 for i in range ( N ) ] for _ in range ( N ) ] , dtype = np . int64 ) <NEWLINE> <NL> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> s . append ( s [ i - 1 ] + a [ i - 1 ] ) <NEWLINE> <NL> <DEDENT> s = np . array ( s , dtype = np . int64 ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> dp [ i ] [ i ] = 0 <NEWLINE> <NL> <DEDENT> @ njit ( <STRING> , cache = True ) <NEWLINE> def calc ( i , j , dp , s ) : <NEWLINE> <INDENT> if dp [ i ] [ j ] != - 1 : <NEWLINE> <INDENT> return dp [ i ] [ j ] <NEWLINE> <DEDENT> m = float ( <STRING> ) <NEWLINE> for k in range ( i , j ) : <NEWLINE> <INDENT> m = min ( m , calc ( i , k , dp , s ) + calc ( k + 1 , j , dp , s ) + s [ j + 1 ] - s [ i ] ) <NEWLINE> <DEDENT> dp [ i ] [ j ] = m <NEWLINE> return dp [ i ] [ j ] <NEWLINE> <NL> <DEDENT> print ( calc ( 0 , N - 1 , dp , s ) ) <NEWLINE>
import numpy as np <NEWLINE> from numba import njit <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> slimes = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> csum_slimes = [ 0 ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> csum_slimes . append ( csum_slimes [ - 1 ] + slimes [ i ] ) <NEWLINE> <NL> <DEDENT> dpt = np . full ( ( N , N ) , - 1 , dtype = <STRING> ) <NEWLINE> <NL> def get_min_cost ( l , r ) : <NEWLINE> <INDENT> if dpt [ l ] [ r ] != - 1 : <NEWLINE> <INDENT> return dpt [ l ] [ r ] <NEWLINE> <DEDENT> if l == r : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> min_cost = 10 ** 18 <NEWLINE> for m in range ( l , r ) : <NEWLINE> <INDENT> min_cost = min ( min_cost , get_min_cost ( l , m ) + get_min_cost ( m + 1 , r ) + csum_slimes [ r + 1 ] - csum_slimes [ l ] ) <NEWLINE> <DEDENT> dpt [ l ] [ r ] = min_cost <NEWLINE> return min_cost <NEWLINE> <NL> <NL> <DEDENT> print ( get_min_cost ( 0 , N - 1 ) ) <NEWLINE>
import numpy as np <NEWLINE> from numba import njit <NEWLINE> <NL> @ njit ( <STRING> , cache = True ) <NEWLINE> def solve ( N , aff , dpt , MOD ) : <NEWLINE> <INDENT> for i in range ( N ) : <NEWLINE> <INDENT> row = aff [ i ] <NEWLINE> for idx in range ( N ) : <NEWLINE> <INDENT> if row [ idx ] == 1 : <NEWLINE> <INDENT> dpt [ i + 1 ] [ ( 1 << idx ) : ] += dpt [ i ] [ : - ( 1 << idx ) ] <NEWLINE> <DEDENT> <DEDENT> dpt [ i + 1 ] %= MOD <NEWLINE> <DEDENT> return dpt [ N ] [ ( 1 << N ) - 1 ] <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> MOD = 10 ** 9 + 7 <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> aff = np . array ( [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( N ) ] , dtype = <STRING> ) <NEWLINE> dpt = np . zeros ( ( N + 1 , 1 << N ) , dtype = <STRING> ) <NEWLINE> dpt [ 0 ] [ 0 ] = 1 <NEWLINE> <NL> print ( solve ( N , aff , dpt , MOD ) ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> sys . setrecursionlimit ( 1 << 25 ) <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> read = sys . stdin . readline <COMMENT> <NEWLINE> <NL> import numpy as np <NEWLINE> from functools import partial <NEWLINE> array = partial ( np . array , dtype = np . int64 ) <NEWLINE> zeros = partial ( np . zeros , dtype = np . int64 ) <NEWLINE> full = partial ( np . full , dtype = np . int64 ) <NEWLINE> <NL> ra = range <NEWLINE> enu = enumerate <NEWLINE> <NL> <NL> def exit ( * argv , ** kwarg ) : <NEWLINE> <INDENT> print ( * argv , ** kwarg ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <NL> <DEDENT> def mina ( * argv , sub = 1 ) : return list ( map ( lambda x : x - sub , argv ) ) <NEWLINE> <COMMENT> <NL> <NL> <NL> def a_int ( ) : return int ( readline ( ) ) <NEWLINE> <NL> <NL> def read_matrix ( H , W ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> lines = [ ] <NEWLINE> for _ in range ( H ) : <NEWLINE> <INDENT> lines . append ( read ( ) ) <NEWLINE> <DEDENT> lines = <STRING> . join ( lines ) <COMMENT> <NEWLINE> return np . fromstring ( lines , sep = <STRING> , dtype = np . int64 ) . reshape ( H , W ) <NEWLINE> <NL> <NL> <DEDENT> MOD = 10 ** 9 + 7 <NEWLINE> INF = 2 ** 31 <COMMENT> <NEWLINE> <COMMENT> <NL> <NL> from collections import defaultdict , Counter , deque <NEWLINE> from operator import itemgetter , xor , add <NEWLINE> from itertools import product , permutations , combinations <NEWLINE> from bisect import bisect_left , bisect_right <COMMENT> <NEWLINE> from functools import reduce <NEWLINE> <NL> N = a_int ( ) <NEWLINE> A = read_matrix ( N , N ) <NEWLINE> <NL> <STRING> <NEWLINE> <NL> from numba import njit <NEWLINE> <NL> <NL> @ njit ( <STRING> , cache = True ) <NEWLINE> def solve_TLE ( N , A ) : <NEWLINE> <INDENT> dp = np . zeros ( ( N + 1 , 1 << N ) , dtype = np . int64 ) <NEWLINE> dp [ 0 , 0 ] = 1 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> for s in range ( 1 << N ) : <NEWLINE> <INDENT> for j in range ( N ) : <NEWLINE> <INDENT> if ( s >> j ) & 1 == 0 and A [ i , j ] == 1 : <NEWLINE> <INDENT> dp [ i + 1 , s + ( 1 << j ) ] += dp [ i , s ] % MOD <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( dp [ N , ( 1 << N ) - 1 ] % MOD ) <NEWLINE> <NL> <NL> <DEDENT> solve_TLE ( N , A ) <NEWLINE>
import numpy as np <NEWLINE> from numba import njit <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> <NL> def main ( ) : <NEWLINE> <NL> <INDENT> N = int ( input ( ) ) <NEWLINE> aff = np . array ( [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( N ) ] , dtype = <STRING> ) <NEWLINE> dpt = np . zeros ( ( N + 1 , 1 << N ) , dtype = <STRING> ) <NEWLINE> dpt [ 0 ] [ 0 ] = 1 <NEWLINE> <NL> print ( solve ( N , aff , dpt ) ) <NEWLINE> <NL> <DEDENT> @ njit ( cache = True ) <NEWLINE> def solve ( N , aff , dpt ) : <NEWLINE> <INDENT> for i , row in enumerate ( aff ) : <NEWLINE> <INDENT> for idx , v in enumerate ( row ) : <NEWLINE> <INDENT> if v == 1 : <NEWLINE> <INDENT> dpt [ i + 1 ] [ ( 1 << idx ) : ] += dpt [ i ] [ : - ( 1 << idx ) ] <NEWLINE> <DEDENT> <DEDENT> dpt [ i + 1 ] %= MOD <NEWLINE> <DEDENT> return dpt [ N ] [ ( 1 << N ) - 1 ] <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
class BITmax : <NEWLINE> <INDENT> def __init__ ( self , N , init = 0 ) : <NEWLINE> <INDENT> self . init = init <NEWLINE> self . tree = [ self . init ] * ( N + 1 ) <NEWLINE> <NL> <DEDENT> def set ( self , x , value ) : <NEWLINE> <INDENT> while x < N + 1 : <NEWLINE> <INDENT> old = self . tree [ x ] <NEWLINE> if value <= old : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> self . tree [ x ] = value <NEWLINE> x += x & - x <NEWLINE> <NL> <DEDENT> <DEDENT> def find_max_to ( self , x ) : <NEWLINE> <INDENT> result = self . init <NEWLINE> while x > 0 : <NEWLINE> <INDENT> result = max ( result , self . tree [ x ] ) <NEWLINE> x -= x & - x <NEWLINE> <DEDENT> return result <NEWLINE> <NL> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> dpt = BITmax ( N ) <NEWLINE> <NL> h_list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b_list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for h , b in zip ( h_list , b_list ) : <NEWLINE> <INDENT> dpt . set ( h , dpt . find_max_to ( h - 1 ) + b ) <NEWLINE> <NL> <DEDENT> print ( max ( dpt . tree ) ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> <NL> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = np . array ( [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( N ) ] , dtype = int ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> res = matrix_power ( A , N , mod ) <NEWLINE> print ( res . sum ( ) % mod ) <NEWLINE> <NL> power_list = [ A ] <NEWLINE> for i in range ( 1 , K . bit_length ( ) + 1 ) : <NEWLINE> <INDENT> power_list . append ( ( power_list [ - 1 ] @ power_list [ - 1 ] ) % mod ) <NEWLINE> <NL> <DEDENT> B = np . identity ( N ) . astype ( int ) <NEWLINE> for i in range ( K . bit_length ( ) + 1 ) : <NEWLINE> <INDENT> if K >> i & 1 : <NEWLINE> <INDENT> B = ( B @ power_list [ i ] ) % mod <NEWLINE> <NL> <DEDENT> <DEDENT> print ( B . sum ( ) % mod ) <NEWLINE>
import numpy as np <NEWLINE> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ [ int ( i ) for i in input ( ) . split ( ) ] for _ in range ( N ) ] <NEWLINE> a = np . array ( a , dtype = np . int64 ) <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> <NL> def matmul ( A , B , MOD ) : <NEWLINE> <INDENT> N = len ( A ) <NEWLINE> C = np . zeros ( ( N , N ) , dtype = np . int64 ) <NEWLINE> <NL> for n in range ( N ) : <NEWLINE> <INDENT> C [ n ] = ( A [ n , : ] [ : , None ] * B % mod ) . sum ( axis = 0 ) % mod <NEWLINE> <DEDENT> return C <NEWLINE> <NL> <DEDENT> def mat_power ( A , k , MOD ) : <NEWLINE> <INDENT> N = len ( A ) <NEWLINE> D = np . identity ( N , dtype = np . int64 ) <NEWLINE> while k : <NEWLINE> <INDENT> if k & 1 : <NEWLINE> <INDENT> D = matmul ( D , A , MOD ) <NEWLINE> <DEDENT> A = matmul ( A , A , MOD ) <NEWLINE> k >>= 1 <NEWLINE> <NL> <DEDENT> return D <NEWLINE> <NL> <DEDENT> A = mat_power ( a , K , MOD ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> for j in range ( N ) : <NEWLINE> <INDENT> ans = ( ans + A [ i ] [ j ] ) % MOD <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<NL> N = int ( input ( ) ) <NEWLINE> cnt = N . count ( <STRING> ) <NEWLINE> print ( cnt ) <NEWLINE>
print ( input ( ) . count ( <STRING> ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> print ( N . count ( <STRING> ) ) <NEWLINE>
print ( input ( ) . count ( ) ) <NEWLINE>
N , H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if a >= H and b = W : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
def factorization ( n ) : <NEWLINE> <INDENT> arr = [ ] <NEWLINE> temp = n <NEWLINE> for i in range ( 2 , int ( - ( - n ** 0.5 // 1 ) ) + 1 ) : <NEWLINE> <INDENT> if temp % i == 0 : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> while temp % i == 0 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> temp //= i <NEWLINE> <DEDENT> arr . append ( [ i , cnt ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> if temp != 1 : <NEWLINE> <INDENT> arr . append ( [ temp , 1 ] ) <NEWLINE> <NL> <DEDENT> if arr == [ ] : <NEWLINE> <INDENT> arr . append ( [ n , 1 ] ) <NEWLINE> <NL> <DEDENT> return arr <NEWLINE> <DEDENT> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> L = factorization ( N ) <NEWLINE> ans = 1 <NEWLINE> for i in L : <NEWLINE> <INDENT> ans *= L [ 0 ] ** ( L [ 1 ] // N ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n , p = map ( int , input ( ) . split ( ) ) <NEWLINE> if n == 1 : <NEWLINE> <INDENT> print ( p ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> elif p == 1 or n >= 60 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> for i in range ( int ( p ** ( 1 / n ) ) + 1 ) [ 0 : : - 1 ] : <NEWLINE> <INDENT> if p % ( i ** n ) == 0 : <NEWLINE> <INDENT> print ( i ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if n == 1 : <NEWLINE> <INDENT> print ( m ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> if n >= len ( L ) : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> div = 2 <NEWLINE> L = [ ] <NEWLINE> i = 1 <NEWLINE> while div <= int ( m ** 0.5 ) + 1 : <NEWLINE> <INDENT> while m % div == 0 : <NEWLINE> <INDENT> m //= div <NEWLINE> L . append ( div ) <NEWLINE> <DEDENT> div += 1 <NEWLINE> <DEDENT> L . append ( m ) <NEWLINE> <COMMENT> <NL> <NL> from collections import Counter <NEWLINE> L = Counter ( L ) <NEWLINE> <NL> cnt = 1 <NEWLINE> for k , v in L . items ( ) : <NEWLINE> <INDENT> if v >= n : <NEWLINE> <INDENT> cnt *= k <NEWLINE> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
from math import sqrt <NEWLINE> def divisors ( n ) : <NEWLINE> <INDENT> divisors = [ ] <NEWLINE> for i in range ( 1 , int ( sqrt ( n ) ) + 1 ) : <NEWLINE> <INDENT> q , r = divmod ( n , i ) <NEWLINE> if r == 0 : <NEWLINE> <INDENT> divisors . append ( i ) <NEWLINE> if i != q : <NEWLINE> <INDENT> divisors . append ( q ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return divisors <NEWLINE> <NL> <DEDENT> n , p = map ( int , input ( ) . split ( ) ) <NEWLINE> x = 1 <NEWLINE> for k , v in factorint ( p ) . items ( ) : <NEWLINE> <INDENT> x *= k ** ( v // n ) <NEWLINE> <DEDENT> print ( x ) <NEWLINE>
n , p = map ( int , input ( ) . split ( ) ) <NEWLINE> num = int ( p ** ( 1 / n ) ) <NEWLINE> for i in range ( num + 1 , 0 , - 1 ) : <NEWLINE> <INDENT> p0 = p <NEWLINE> count = 0 <NEWLINE> if i == 1 : <NEWLINE> <INDENT> print ( i ) <NEWLINE> break <NEWLINE> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> if p0 % i == 0 : <NEWLINE> <INDENT> p0 //= i <NEWLINE> count += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( i ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT>
import re <NEWLINE> import sys <NEWLINE> import math <NEWLINE> import itertools <NEWLINE> import bisect <NEWLINE> from copy import copy <NEWLINE> from collections import deque , Counter <NEWLINE> from decimal import Decimal <NEWLINE> import functools <NEWLINE> def v ( ) : return input ( ) <NEWLINE> def k ( ) : return int ( input ( ) ) <NEWLINE> def S ( ) : return input ( ) . split ( ) <NEWLINE> def I ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def X ( ) : return list ( input ( ) ) <NEWLINE> def L ( ) : return list ( input ( ) . split ( ) ) <NEWLINE> def l ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> def lcm ( a , b ) : return a * b // math . gcd ( a , b ) <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> cnt = 0 <NEWLINE> ans = 1 <NEWLINE> inf = float ( <STRING> ) <NEWLINE> al = <STRING> <NEWLINE> <NL> def facto ( n ) : <NEWLINE> <INDENT> arr = [ ] <NEWLINE> temp = n <NEWLINE> for i in range ( int ( math . sqrt ( n ) ) + 1 ) : <NEWLINE> <INDENT> if temp % i == 0 : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> while temp % i == 0 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> temp //= i <NEWLINE> <DEDENT> arr . append ( [ cnt , i ] ) <NEWLINE> <DEDENT> <DEDENT> if temp != 1 : <NEWLINE> <INDENT> arr . append ( [ 1 , temp ] ) <NEWLINE> <NL> <DEDENT> if arr == [ ] : <NEWLINE> <INDENT> arr . append ( [ 1 , n ] ) <NEWLINE> <NL> <DEDENT> return arr <NEWLINE> <NL> <DEDENT> n , p = I ( ) <NEWLINE> <NL> for i in facto ( p ) : <NEWLINE> <INDENT> if i [ 0 ] >= n : <NEWLINE> <INDENT> ans *= i [ 1 ] <NEWLINE> <NL> <DEDENT> <DEDENT> if n == 1 : <NEWLINE> <INDENT> print ( p ) <NEWLINE> <DEDENT> elif p == 1 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
def prime_factorize ( P ) : <NEWLINE> <INDENT> prime = list ( ) <NEWLINE> for i in range ( 2 , P + 1 ) : <NEWLINE> <INDENT> if i ** 2 <= P : <NEWLINE> <INDENT> if P % i == 0 : <NEWLINE> <INDENT> c = 0 <NEWLINE> while P % i == 0 : <NEWLINE> <INDENT> P //= i <NEWLINE> c += 1 <NEWLINE> <DEDENT> prime . append ( [ i , c ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> if P != 1 : <NEWLINE> <INDENT> prime . append ( [ P , 1 ] ) <NEWLINE> <NL> <DEDENT> return prime <NEWLINE> <NL> <DEDENT> def main2 ( ) : <NEWLINE> <INDENT> N , P = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> prime = prime_factorize ( P ) <NEWLINE> <NL> print ( prime ) <NEWLINE> ans = 1 <NEWLINE> for p in prime : <NEWLINE> <INDENT> n , c = p <NEWLINE> ans *= ( n ** ( c // N ) ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main2 ( ) <NEWLINE> <DEDENT> def prime_factorize ( P ) : <NEWLINE> <INDENT> prime = list ( ) <NEWLINE> for i in range ( 2 , P + 1 ) : <NEWLINE> <INDENT> if i ** 2 <= P : <NEWLINE> <INDENT> if P % i == 0 : <NEWLINE> <INDENT> c = 0 <NEWLINE> while P % i == 0 : <NEWLINE> <INDENT> P //= i <NEWLINE> c += 1 <NEWLINE> <DEDENT> prime . append ( [ i , c ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> if P != 1 : <NEWLINE> <INDENT> prime . append ( [ P , 1 ] ) <NEWLINE> <NL> <DEDENT> return prime <NEWLINE> <NL> <DEDENT> def main2 ( ) : <NEWLINE> <INDENT> N , P = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> prime = prime_factorize ( P ) <NEWLINE> ans = 1 <NEWLINE> for p in prime : <NEWLINE> <INDENT> n , c = p <NEWLINE> ans *= ( n ** ( c // N ) ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main2 ( ) <NEWLINE> <DEDENT>
import bisect <NEWLINE> import copy <NEWLINE> import heapq <NEWLINE> import math <NEWLINE> import sys <NEWLINE> from collections import * <NEWLINE> from functools import lru_cache <NEWLINE> from itertools import accumulate , combinations , permutations , product <NEWLINE> def input ( ) : <NEWLINE> <INDENT> return sys . stdin . readline ( ) [ : - 1 ] <NEWLINE> <DEDENT> def ruiseki ( lst ) : <NEWLINE> <INDENT> return [ 0 ] + list ( accumulate ( lst ) ) <NEWLINE> <DEDENT> sys . setrecursionlimit ( 500000 ) <NEWLINE> mod = pow ( 10 , 9 ) + 7 <NEWLINE> al = [ chr ( ord ( <STRING> ) + i ) for i in range ( 26 ) ] <NEWLINE> direction = [ [ 1 , 0 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ 0 , - 1 ] ] <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> a = [ int ( input ( ) ) for i in range ( n ) ] <NEWLINE> <NL> f = <STRING> <NEWLINE> s = <STRING> <NEWLINE> <COMMENT> <NL> if sum ( a ) == n sum ( a ) == n + 1 : <NEWLINE> <INDENT> print ( f ) <NEWLINE> exit ( ) <NEWLINE> <COMMENT> <NL> <DEDENT> if sum ( a ) % 2 : <NEWLINE> <INDENT> print ( f ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( s ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> a = list ( [ ( int ( input ( ) ) ) % 2 for i in range ( n ) ] ) <NEWLINE> su = sum ( a ) <NEWLINE> xors = 0 <NEWLINE> for i in ( a ) : <NEWLINE> <INDENT> xors ^= i <NEWLINE> <DEDENT> if ( xors != 0 | | sum == n ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> main ( ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a . append ( int ( input ( ) % 2 ) ) <NEWLINE> <DEDENT> k = sum ( a ) <NEWLINE> <NL> if ( k % 2 ) or n == 2 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
print ( <STRING> if all ( a [ i ] % 2 == 0 for i in range ( N ) ) else <STRING> ) <NEWLINE>
import sys <NEWLINE> n = int ( input ( ) ) <NEWLINE> A = [ int ( sys . stdin . readline ( ) ) for _ in range ( n ) ] <NEWLINE> print ( <STRING> if all ( a [ i ] % 2 == 0 for i in range ( n ) ) else <STRING> ) <NEWLINE>
<NL> <NL> def main ( ) : <NEWLINE> <INDENT> import sys <NEWLINE> def input ( ) : return sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> flag = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a = int ( intput ( ) ) <NEWLINE> flag &= ( a % 2 == 1 ) <NEWLINE> <DEDENT> if flag : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> c = 0 <NEWLINE> a = 0 <NEWLINE> for i in s : <NEWLINE> <INDENT> if i == <STRING> : <NEWLINE> <INDENT> c += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a += c <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
othello = input ( ) <NEWLINE> bef = 0 <NEWLINE> sumall = 0 <NEWLINE> sumelse = 0 <NEWLINE> <NL> for i in range ( len ( othello ) ) : <NEWLINE> <INDENT> sumall += i <NEWLINE> if ( othello [ i ] == <STRING> ) : <NEWLINE> <INDENT> bef += i <NEWLINE> count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> count = 0 <NEWLINE> for i in range ( len ( othello ) - count ) : <NEWLINE> <INDENT> sumelse += i <NEWLINE> <NL> <DEDENT> aft = sumall - sumelse <NEWLINE> <NL> print ( aft - bef ) <NEWLINE>
s = input ( ) <NEWLINE> n = len ( s ) <NEWLINE> sum = [ 0 ] * ( n + 1 ) <NEWLINE> sum [ 0 ] = ( s [ 0 ] == <STRING> ) <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> sum [ i ] = sum [ i - 1 ] + ( s [ i ] == <STRING> ) <NEWLINE> <DEDENT> ans = 0 <NEWLINE> for i in range ( n , - 1 , - 1 ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> ans += sum [ i ] <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
ans = 0 <NEWLINE> ans2 = 0 <NEWLINE> s = input ( ) <NEWLINE> l = len ( s ) <NEWLINE> t = 1 <NEWLINE> for i in range ( l ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> same = True <NEWLINE> while same : <NEWLINE> <INDENT> if s [ i ] != s [ t ] : <NEWLINE> <INDENT> i = t <NEWLINE> print ( <STRING> ) <NEWLINE> same = False <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( max ( ans , ans2 ) ) <NEWLINE>
from itertools import permutations <NEWLINE> N = int ( input ( ) ) <NEWLINE> <NL> val = [ ] <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> val . append ( int ( input ( ) ) ) <NEWLINE> <DEDENT> ans = 10 ** 10 <NEWLINE> for i in permutations ( val ) : <NEWLINE> <INDENT> for j in range ( 1 , N ) : <NEWLINE> <INDENT> ans = min ( max ( sum ( i [ : j ] ) , sum ( i [ j : ] ) ) , ans ) <NEWLINE> <DEDENT> <DEDENT> if N == 1 : <NEWLINE> <INDENT> print ( val [ 0 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <NL> <NL> <NL> <DEDENT>
s = input ( ) <NEWLINE> l = [ ] <NEWLINE> for i in range ( len ( s ) - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> l . append ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> l . append ( 1 ) <NEWLINE> <DEDENT> <DEDENT> cnt = 0 <NEWLINE> <NL> for j in range ( len ( s ) ** 0.5 ) : <NEWLINE> <INDENT> for i in range ( j , len ( s ) - 1 , 2 ) : <NEWLINE> <INDENT> if l [ i ] == 1 and l [ i + 1 ] == 0 : <NEWLINE> <INDENT> l [ i ] = 0 <NEWLINE> l [ i + 1 ] = 1 <NEWLINE> cnt += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
S = input ( ) <NEWLINE> W = [ ] <NEWLINE> <NL> for i , s enumerate ( S ) : <NEWLINE> <INDENT> if s == <STRING> : <NEWLINE> <INDENT> W . append ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> idx = 0 <NEWLINE> ans = 0 <NEWLINE> for w in W : <NEWLINE> <INDENT> ans += w - idx <NEWLINE> idx += 1 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
s = input ( ) <NEWLINE> <NL> n = len ( s ) <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> cunt = 0 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += cunt <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
s = input ( ) <NEWLINE> <NL> cw = 0 <NEWLINE> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> ans += i - cw <NEWLINE> cw += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL>
max = 0 <NEWLINE> k = 0 <NEWLINE> N = int ( input ( ) ) <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> p = int ( input ( ) ) <NEWLINE> if p > max : max = p <NEWLINE> k = k + p <NEWLINE> print ( ( k - max ) + ( max // 2 ) ) <NEWLINE> <DEDENT>
d = int ( input ( ) ) <NEWLINE> if d = 25 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif d = 24 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif d = 23 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif d = 22 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
D = input ( ) <NEWLINE> D = int ( d ) <NEWLINE> <NL> if D == 25 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> if D == 24 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> if D == 23 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> if D == 22 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a = int ( input ( ) ) <NEWLINE> if a == 22 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a == 23 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a == 24 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else a == 25 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
D = int ( input ( ) ) <NEWLINE> if D = 25 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif D = 24 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif D = 23 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif D = 22 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> D = int ( input ( ) . split ( ) ) <NEWLINE> if D == 25 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif D == 24 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif D == 23 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> main ( ) <NEWLINE>
print ( <STRING> + <STRING> + ( 25 - int ( input ( ) ) ) ) <NEWLINE>
D = int ( input ( ) ) <NEWLINE> if D = 25 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif D = 24 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif D = 23 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
christmas_day = 25 <NEWLINE> d = int ( input ( ) ) <NEWLINE> print ( <STRING> , <STRING> * christmas_day - d ) <NEWLINE>
d = int ( input ( ) ) <NEWLINE> if d = 25 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif d = 24 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif d = 23 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import math <NEWLINE> N = int ( input ( ) ) <NEWLINE> p = [ ] <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> p . append ( int ( input ( ) ) ) <NEWLINE> <NL> <DEDENT> total_price = max ( N ) / 2 + sum ( N ) - max ( N ) <NEWLINE> <NL> print ( math . floor ( total_price ) ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <NL> <NL> def calculation ( lines ) : <NEWLINE> <COMMENT> <NL> <INDENT> N = int ( lines [ 0 ] ) <NEWLINE> <COMMENT> <NL> values = list ( ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> values . append ( int ( lines [ i + 1 ] ) ) <NEWLINE> <NL> <DEDENT> result = sum ( values ) - int ( max ( values ) / 2 ) <NEWLINE> <NL> return [ result ] <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> def get_input_lines ( ) : <NEWLINE> <INDENT> line = input ( ) <NEWLINE> N , M = list ( map ( int , line . split ( ) ) ) <NEWLINE> lines = list ( ) <NEWLINE> lines . append ( line ) <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> lines . append ( input ( ) ) <NEWLINE> <DEDENT> return lines <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> def get_testdata ( pattern ) : <NEWLINE> <INDENT> if pattern == 1 : <NEWLINE> <INDENT> lines_input = [ <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> lines_export = [ 15950 ] <NEWLINE> <DEDENT> if pattern == 2 : <NEWLINE> <INDENT> lines_input = [ <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> lines_export = [ 15120 ] <NEWLINE> <DEDENT> return lines_input , lines_export <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> def get_mode ( ) : <NEWLINE> <INDENT> import sys <NEWLINE> args = sys . argv <NEWLINE> if len ( args ) == 1 : <NEWLINE> <INDENT> mode = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> mode = int ( args [ 1 ] ) <NEWLINE> <DEDENT> return mode <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> import time <NEWLINE> started = time . time ( ) <NEWLINE> mode = get_mode ( ) <NEWLINE> if mode == 0 : <NEWLINE> <INDENT> lines_input = get_input_lines ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> lines_input , lines_export = get_testdata ( mode ) <NEWLINE> <NL> <DEDENT> lines_result = calculation ( lines_input ) <NEWLINE> <NL> for line_result in lines_result : <NEWLINE> <INDENT> print ( line_result ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> p = [ int ( input ( ) ) for i in range ( n ) ] <NEWLINE> print ( int ( sum ( p ) - ( max ( p ) / 2 ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> p = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> p [ i ] = int ( input ( ) ) <NEWLINE> <DEDENT> p . sort ( ) <NEWLINE> print ( p [ - 1 ] // 2 + sum ( p [ : - 2 ] ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> k = [ int ( input ( ) ) for i in range ( n ) ] <NEWLINE> print ( int ( ( sum ( k ) - max ( k ) // 2 ) ) <NEWLINE>
a = int ( input ( ) ) <NEWLINE> b = [ input ( ) . split ( ) for i in range ( a ) ] <NEWLINE> b = int ( b ) <NEWLINE> b . sort ( ) <NEWLINE> c = sum ( b ) <NEWLINE> print ( int ( c - b [ a ] / 2 ) ) <NEWLINE>
total_item = int ( input ( ) ) <NEWLINE> item_cost = [ ] <NEWLINE> for i in range ( total_item ) : <NEWLINE> <INDENT> item_cost . append ( int ( input ( ) ) ) <NEWLINE> <DEDENT> print ( sum ( item_cost ) - max ( item_cost ) // 2 ) v <NEWLINE>
max = 0 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> p = int ( input ( ) ) <NEWLINE> if p > max : <NEWLINE> <INDENT> max = p // 2 <NEWLINE> print ( max ) <NEWLINE> <DEDENT> <DEDENT>
P = [ int ( input ( ) ) for i in range ( int ( input ( ) ) ) ] <NEWLINE> print ( sum ( p ) - max ( p ) // 2 ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> P = sorted ( [ int ( input ( ) ) for X in range ( 0 , N ) ] ) <NEWLINE> P [ - 1 ] = P [ - 1 ] // 2 <NEWLINE> print ( sum ( SP ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( [ input ( ) for i in range ( n ) ] ) <NEWLINE> z = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a [ i ] = int ( a [ i ] ) <NEWLINE> if a [ i ] > z : <NEWLINE> <INDENT> z = i + 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( sum ( a ) - a [ z ] / 2 ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> p = int ( input ( ) ) <NEWLINE> a . append ( p ) <NEWLINE> <NL> <DEDENT> a . sort ( ) <NEWLINE> s = p [ n - 1 ] // 2 <NEWLINE> print ( sum ( a ) - s ) <NEWLINE>
, k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ ] <NEWLINE> for x in range ( n ) : <NEWLINE> <INDENT> a . append ( int ( input ( ) ) ) <NEWLINE> <DEDENT> ans = 1000000009 <NEWLINE> a = sorted ( a ) <NEWLINE> for y in range ( n - k + 1 ) : <NEWLINE> <INDENT> ans = min ( a [ y + k - 1 ] - a [ y ] , ans ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE> <NL>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> h = sorted ( [ int ( input ( ) ) for _ in range ( n ) ] ) <NEWLINE> print ( min ( ans [ j + k - 1 ] - ans [ j ] for j in range ( n - k + 1 ) ) ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> h = [ int ( input ( ) ) for i in range ( n ) ] <NEWLINE> h . sort ( ) <NEWLINE> ans = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ans . append ( h [ i + k - 1 ] - h [ i ] ) <NEWLINE> <DEDENT> print ( min ( ans ) ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> n , k = Input ( ) <NEWLINE> data = sorted ( int ( input ( ) ) for _ in range ( n ) ) <NEWLINE> print ( min ( [ data [ i + k - 1 ] - data [ i ] for i in range ( n - k + 1 ) ] ) ) <NEWLINE> <DEDENT> main ( ) <NEWLINE>
<COMMENT> <NL> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> h = [ int ( input ( ) ) for _ in range ( n ) ] <NEWLINE> h . sort ( ) <NEWLINE> ans = h [ 0 ] <NEWLINE> <NL> print ( min ( h [ i + k - 1 ] - h [ i ] for i in range ( n - k + 1 ) ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> h . sort ( ) <NEWLINE> <NL> for i in range ( n - k + 1 ) : <NEWLINE> <INDENT> a = h [ i + k - 1 ] - h [ i ] <NEWLINE> ans = a if i == 0 else min ( ans , a ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ input ( ) for i in range ( n ) ] <NEWLINE> a . sort ( ) <NEWLINE> b = [ ] <NEWLINE> for p in range ( n - k ) : <NEWLINE> <INDENT> c = a [ p + k ] - a [ p ] <NEWLINE> b . append ( c ) <NEWLINE> <NL> <DEDENT> print ( min ( b ) ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> trees = [ ] <NEWLINE> for _i in range ( n ) : <NEWLINE> <INDENT> trees . append ( int ( input ( ) ) <NEWLINE> <NL> <DEDENT> trees . sort ( ) <NEWLINE> ans = float ( <STRING> ) <NEWLINE> <NL> for i in range ( n - k + 1 ) : <NEWLINE> <INDENT> diff = trees [ i + k - 1 ] - trees [ i ] <NEWLINE> if ans > diff : <NEWLINE> <INDENT> ans = diff <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ans . append ( int ( input ( ) ) ) <NEWLINE> <DEDENT> ans . sort ( ) <NEWLINE> print ( min ( ans [ i + k - 1 ] - ans [ i ] for j in range ( n - k + 1 ) ) ) <NEWLINE> <NL>
x = int ( input ( ) ) <NEWLINE> a = False <NEWLINE> if x = 7 or x = 5 or x = 3 : <NEWLINE> <INDENT> a = True <NEWLINE> <NL> <DEDENT> print ( <STRING> if a else <STRING> ) <NEWLINE>
a = imput ( ) <NEWLINE> a = int ( a ) <NEWLINE> <NL> if a == 7 or a == 5 or a == 3 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
x = int ( input ( ) ) <NEWLINE> li = [ 3 , 5 , 7 ] <NEWLINE> if x in li : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> <NEWLINE> <DEDENT>
print ( <STRING> if input ( ) == <STRING> or input ( ) == <STRING> or input ( ) == <STRING> else <STRING> ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> if N == 3 | | N == 5 | | N == 7 : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> a = int ( input ( ) ) <NEWLINE> a , b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = list ( str ( input ( ) ) ) <NEWLINE>
print ( <STRING> [ ~ input ( ) in <STRING> % 2 : : 2 ] <NEWLINE>
y = int ( input ( ) ) <NEWLINE> if y == 7 or y == 5 0 r y == 3 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a = input ( ) <NEWLINE> a = int ( a ) <NEWLINE> if a == 3 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> if a == 5 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> if a == 7 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
X = int ( input ( ) ) <NEWLINE> if X == 3 , 5 , 7 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> if n == 7 or n == 5 or n = 3 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
S = list ( input ( ) ) <NEWLINE> <NL> ans = 753 <NEWLINE> <NL> for i in range ( len ( S ) - 2 ) : <NEWLINE> <INDENT> sa = abs ( 753 - ( int ( S [ i ] ) * 100 + int ( S [ i + 1 ] ) * 10 + int ( S [ i + 2 ] ) ) ) <NEWLINE> ans = min ( sa , ans ) <NEWLINE> <NL> <DEDENT> print ( ans <NEWLINE>
S = input ( ) <NEWLINE> print ( min ( abs ( 753 - int ( S [ i , i + 3 ] ) ) for i in range ( len ( S ) - 2 ) ) ) <NEWLINE>
S = input ( ) <NEWLINE> N = len ( S ) <NEWLINE> ans = <STRING> <NEWLINE> for i in range ( N - 2 ) : <NEWLINE> <INDENT> tmp = abs ( 753 - int ( S [ i : i + 2 ] ) <NEWLINE> ans = min ( ans , tmp ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
a = input ( ) <NEWLINE> b = abs ( 753 - int ( a [ 0 ] + a [ 1 ] + a [ 2 ] ) ) <NEWLINE> for i in range ( int ( len ( a ) - 2 ) ) : <NEWLINE> <INDENT> if abs ( 753 - int ( a [ i ] + a [ i + 1 ] + a [ i + 2 ] ) ) > abs ( 753 - int ( a [ i + 1 ] + a [ i + 2 ] + a [ i + 3 ] ) ) : <NEWLINE> <INDENT> b = abs ( 753 - int ( a [ i + 1 ] + a [ i + 2 ] + a [ i + 3 ] ) ) <NEWLINE> <DEDENT> <DEDENT> print ( b ) <NEWLINE>
s = input ( ) <NEWLINE> a = [ ] <NEWLINE> for i in range ( len ( str ( s ) ) - 2 ) : <NEWLINE> <INDENT> a . extend ( abs ( int ( s [ i ] ) * 100 + int ( s [ i + 1 ] ) * 10 + int ( s [ i + 2 ] ) - 753 ) ) <NEWLINE> <DEDENT> print ( min ( a ) ) <NEWLINE>
1 S = input ( ) <NEWLINE> 2 print ( min ( abs ( int ( S [ i : i + 3 ] ) - 753 ) for i in range ( len ( S ) - 3 ) ) ) <NEWLINE>
l , ans = len ( s ) , [ ] <NEWLINE> for i in range ( 0 , l - 2 ) : <NEWLINE> <INDENT> n = s [ i : i + 3 ] <NEWLINE> ans . append ( abs ( 753 - int ( n ) ) ) <NEWLINE> <DEDENT> print ( min ( ans ) ) <NEWLINE>
s = input ( ) <NEWLINE> ans = [ ] <NEWLINE> for i in range ( len ( s ) - 2 ) : <NEWLINE> <INDENT> ans = min ( ans , abs ( 753 - int ( s [ i : i + 3 ] ) ) ) <NEWLINE> <DEDENT> print ( min ( ans ) ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> from collections import deque <NEWLINE> from decorator import stop_watch <NEWLINE> <NL> <NL> @ stop_watch <NEWLINE> def solve ( N ) : <NEWLINE> <INDENT> dq = deque ( [ ( 3 , [ 1 , 0 , 0 ] ) , ( 5 , [ 0 , 1 , 0 ] ) , ( 7 , [ 0 , 0 , 1 ] ) ] ) <NEWLINE> ans = 0 <NEWLINE> while dq : <NEWLINE> <INDENT> num , check = dq . popleft ( ) <NEWLINE> if num > N : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if sum ( check ) == 3 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> for i in ( 3 , 5 , 7 ) : <NEWLINE> <INDENT> new_num = num * 10 + i <NEWLINE> if new_num > N : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> new_check = check . copy ( ) <NEWLINE> if i == 3 : <NEWLINE> <INDENT> new_check [ 0 ] = 1 <NEWLINE> <DEDENT> elif i == 5 : <NEWLINE> <INDENT> new_check [ 1 ] = 1 <NEWLINE> <DEDENT> elif i == 7 : <NEWLINE> <INDENT> new_check [ 2 ] = 1 <NEWLINE> <DEDENT> dq . append ( ( new_num , new_check ) ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> solve ( N ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT>
n = int ( input ( ) ) <NEWLINE> tmp = 2 <NEWLINE> ans = 0 <NEWLINE> Flag = True <NEWLINE> while Flag : <NEWLINE> <INDENT> tmp += 1 <NEWLINE> iterator = product ( range ( 3 ) , repeat = tmp ) <NEWLINE> for idxs in iterator : <NEWLINE> <INDENT> num = <STRING> . join ( map ( str , idxs ) ) <NEWLINE> num753 = str ( num ) . replace ( <STRING> , <STRING> ) . replace ( <STRING> , <STRING> ) . replace ( <STRING> , <STRING> ) <NEWLINE> if <STRING> in num753 and <STRING> in num753 and <STRING> in num753 : <NEWLINE> <INDENT> if int ( num753 ) <= n : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> Flag = False <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = input ( ) <NEWLINE> from itertools import product <NEWLINE> from collectins import Counter <NEWLINE> sum = 0 <NEWLINE> for i in range ( len ( n ) - 2 ) : <NEWLINE> <INDENT> for j in list ( product ( <STRING> , repeat = i + 3 ) ) : <NEWLINE> <INDENT> if int ( <STRING> . join ( j ) ) <= int ( n ) and len ( Counter ( j ) ) == 3 : <NEWLINE> <INDENT> sum += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( sum ) <NEWLINE>
import itertools <NEWLINE> N = int ( input ( ) ) <NEWLINE> count = 0 <NEWLINE> for i in range ( 3 , len ( str ( N ) ) + 1 ) : <NEWLINE> <INDENT> for j in itertools . product ( <STRING> , repeat = i ) : <NEWLINE> <INDENT> if int ( <STRING> . join ( j ) ) = < N and <STRING> in str ( j ) and <STRING> in str ( j ) and <STRING> in str ( j ) : <NEWLINE> <INDENT> count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
import sys <NEWLINE> <NL> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> N = input ( ) <NEWLINE> N_len = len ( N ) <NEWLINE> <STRING> <NEWLINE> <NL> <NL> <COMMENT> <NL> <NL> <NL> def dfs ( a , depth ) : <NEWLINE> <INDENT> if depth == N_len : <NEWLINE> <INDENT> if int ( a ) <= int ( N ) and a . count ( <STRING> ) > 0 and a . count ( <STRING> ) > 0 and a . count ( <STRING> ) > 0 and str ( int ( a ) ) . count ( <STRING> ) == 0 : <NEWLINE> <INDENT> t . append ( a ) <NEWLINE> return 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return 0 <NEWLINE> <NL> <DEDENT> <DEDENT> ret1 = dfs ( a + <STRING> , depth + 1 ) <NEWLINE> ret2 = dfs ( a + <STRING> , depth + 1 ) <NEWLINE> ret3 = dfs ( a + <STRING> , depth + 1 ) <NEWLINE> ret4 = dfs ( a + <STRING> , depth + 1 ) <NEWLINE> return ret1 + ret2 + ret3 + ret4 <NEWLINE> <NL> <NL> <DEDENT> ans = dfs ( <STRING> , 0 ) <NEWLINE> print ( ans ) <NEWLINE> <COMMENT> <NL>
from itertools import permutations <NEWLINE> target = [ 3 , 5 , 7 ] <NEWLINE> <NL> clear_list = combinations ( target , 4 ) <NEWLINE> print ( clear_list ) <NEWLINE>
from itertools import product <NEWLINE> <NL> n = input ( ) <NEWLINE> <NL> if int ( n ) < 100 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <NL> for i in range ( 3 , len ( n ) + 1 ) : <NEWLINE> <INDENT> s = list ( product ( <STRING> , repeat = i ) ) <NEWLINE> for combi in s : <NEWLINE> <INDENT> n_s = <STRING> . join ( combi ) <NEWLINE> if int ( n_s ) > int ( n ) : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if ( <STRING> in combi ) and ( <STRING> in combi ) and ( <STRING> in combi ) : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> print ( ans ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT>
<COMMENT> <NL> from copy import deepcopy <NEWLINE> <NL> def prime_factorize ( n ) : <NEWLINE> <INDENT> a = [ ] <NEWLINE> while n % 2 == 0 : <NEWLINE> <INDENT> a . append ( 2 ) <NEWLINE> n //= 2 <NEWLINE> <DEDENT> f = 3 <NEWLINE> while f * f <= n : <NEWLINE> <INDENT> if n % f == 0 : <NEWLINE> <INDENT> a . append ( f ) <NEWLINE> n //= f <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> f += 2 <NEWLINE> <DEDENT> <DEDENT> if n != 1 : <NEWLINE> <INDENT> a . append ( n ) <NEWLINE> <DEDENT> return a <NEWLINE> <NL> <DEDENT> N = int ( input ( ) ) <NEWLINE> prime = [ 2 , 3 , 5 , 7 , 11 , 13 , 17 , 19 , 23 , 29 , 31 , 37 , 41 , 43 , 47 , 53 , 59 , 61 , 67 , 71 , 73 , 79 , 83 , 89 , 97 ] <NEWLINE> dp = [ [ 0 ] * 26 for _ in range ( N ) ] <NEWLINE> if N == 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( 1 , N ) : <NEWLINE> <INDENT> dp [ i ] = deepcopy ( dp [ i - 1 ] ) <NEWLINE> temp = Counter ( prime_factorize ( i + 1 ) ) <NEWLINE> for x in temp . items ( ) : <NEWLINE> <INDENT> if len ( prime_factorize ( x [ 0 ] ) ) == 1 : <NEWLINE> <INDENT> dp [ i ] [ prime . index ( x [ 0 ] ) ] += x [ 1 ] <NEWLINE> <DEDENT> <DEDENT> four = 0 <NEWLINE> two = 0 <NEWLINE> fourteen = 0 <NEWLINE> twenty_four = 0 <NEWLINE> seventy_four = 0 <NEWLINE> for j in range ( 25 ) : <NEWLINE> <INDENT> if dp [ i ] [ j ] >= 74 : <NEWLINE> <INDENT> seventy_four += 1 <NEWLINE> twenty_four += 1 <NEWLINE> fourteen += 1 <NEWLINE> four += 1 <NEWLINE> two += 1 <NEWLINE> <DEDENT> elif dp [ i ] [ j ] >= 24 : <NEWLINE> <INDENT> twenty_four += 1 <NEWLINE> fourteen += 1 <NEWLINE> four += 1 <NEWLINE> two += 1 <NEWLINE> <DEDENT> elif dp [ i ] [ j ] >= 14 : <NEWLINE> <INDENT> fourteen += 1 <NEWLINE> four += 1 <NEWLINE> two += 1 <NEWLINE> <DEDENT> elif dp [ i ] [ j ] >= 4 : <NEWLINE> <INDENT> four += 1 <NEWLINE> two += 1 <NEWLINE> <DEDENT> elif dp [ i ] [ j ] >= 2 : <NEWLINE> <INDENT> two += 1 <NEWLINE> <DEDENT> <DEDENT> dp [ i ] [ 25 ] = ( ( four * ( four - 1 ) ) // 2 ) * ( two - 2 ) + twenty_four * ( two - 1 ) + fourteen * ( four - 1 ) + seventy_four <NEWLINE> <DEDENT> print ( dp [ N - 1 ] [ 25 ] ) <NEWLINE> <DEDENT>
import statistics <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> s = statistics . mean ( a ) <NEWLINE> print ( s ) <NEWLINE> c = float ( <STRING> ) <NEWLINE> d = i <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if c != min ( abs ( s - a [ i ] ) , c ) : <NEWLINE> <INDENT> c = s - a [ i ] <NEWLINE> d = i <NEWLINE> <DEDENT> <DEDENT> print ( d ) <NEWLINE>
from itertools import accumulate <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> int : n , k , i , j , ans , num , cnt , b <NEWLINE> list : a , btfl <NEWLINE> <NL> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ 0 ] + list ( accumulate ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> btfl = [ ] <NEWLINE> for i in range ( 0 , n ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n + 1 ) : <NEWLINE> <INDENT> btfl . append ( a [ j ] - a [ i ] ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for i in range ( 50 ) [ : : - 1 ] : <NEWLINE> <INDENT> num , cnt = ans + pow ( 2 , i ) , 0 <NEWLINE> for b in btfl : <NEWLINE> <INDENT> if num == num & b : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> if cnt >= k : <NEWLINE> <INDENT> ans = num <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
def solve ( N , S , k ) : <NEWLINE> <INDENT> k -= 1 <NEWLINE> <NL> <COMMENT> <NL> D_counts = [ 0 ] <NEWLINE> M_counts = [ 0 ] <NEWLINE> DM_counts = [ 0 ] <NEWLINE> <NL> D = 0 <NEWLINE> M = 0 <NEWLINE> DM = 0 <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> if S [ i ] == <STRING> : <NEWLINE> <INDENT> D += 1 <NEWLINE> <DEDENT> elif S [ i ] == <STRING> : <NEWLINE> <INDENT> DM += D <NEWLINE> M += 1 <NEWLINE> <DEDENT> D_counts . append ( D ) <NEWLINE> M_counts . append ( M ) <NEWLINE> DM_counts . append ( DM ) <NEWLINE> <DEDENT> for i in range ( k , N ) : <NEWLINE> <INDENT> if S [ i - k ] == <STRING> : <NEWLINE> <INDENT> D -= 1 <NEWLINE> DM -= M <NEWLINE> <DEDENT> elif S [ i - k ] == <STRING> : <NEWLINE> <INDENT> M -= 1 <NEWLINE> <NL> <DEDENT> if S [ i ] == <STRING> : <NEWLINE> <INDENT> D += 1 <NEWLINE> <DEDENT> elif S [ i ] == <STRING> : <NEWLINE> <INDENT> DM += D <NEWLINE> M += 1 <NEWLINE> <NL> <DEDENT> D_counts . append ( D ) <NEWLINE> M_counts . append ( M ) <NEWLINE> DM_counts . append ( DM ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i , c in enumerate ( S ) : <NEWLINE> <INDENT> if c == <STRING> : <NEWLINE> <INDENT> ans += DM_counts [ i ] <NEWLINE> <DEDENT> <DEDENT> return ans <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> Q = int ( input ( ) ) <NEWLINE> ks = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for k in ks : <NEWLINE> <INDENT> print ( solve ( N , S , k ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> def cc_export ( ) : <NEWLINE> <INDENT> from numba . pycc import CC <NEWLINE> cc = CC ( <STRING> ) <NEWLINE> cc . export ( <STRING> ) ( solve ) <NEWLINE> cc . compile ( ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> import sys <NEWLINE> if sys . argv [ - 1 ] == <STRING> : <NEWLINE> <INDENT> cc_export ( ) <NEWLINE> exit ( 0 ) <NEWLINE> <DEDENT> from my_module import solve <NEWLINE> main ( ) <NEWLINE> <DEDENT>
x , y = map ( int , input ( ) ) <NEWLINE> print ( x + y // 2 ) <NEWLINE>
a , b = map ( int ( input ( ) . split ( ) ) ) <NEWLINE> print ( a + b // 2 ) <NEWLINE>
a , b , c , d = input ( ) . split ( ) <NEWLINE> a = int ( a ) <NEWLINE> b = int ( b ) <NEWLINE> print ( a + b / 2 ) <NEWLINE>
x , y = map ( int , input . split ( ) ) <NEWLINE> print ( x + y / 2 ) <NEWLINE>
L = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> print ( L [ 0 ] + l [ 1 ] // 2 ) <NEWLINE>
x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> printint ( ( x + y / 2 ) ) <NEWLINE>
x , y = map ( int , input ( ) ) <NEWLINE> print ( x + y / 2 ) <NEWLINE>
x , y = int ( input ( ) . split ( ) ) <NEWLINE> print ( x + ( y // 2 ) ) <NEWLINE>
x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> printint ( ( x + y / 2 ) ) <NEWLINE>
X , Y = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( X + y / 2 ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> t , a = map ( int , input ( ) . split ( ) ) <NEWLINE> beta = 0.006 <NEWLINE> H = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> import numpy as np <NEWLINE> H = np . array ( H ) <NEWLINE> use = t - beta * H - a <NEWLINE> use = use ** 2 <NEWLINE> pre_answer = min ( use ) <NEWLINE> ans = 1 + use . index ( pre_answer ) <NEWLINE> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> T , A = map ( int , input ( ) . split ( ) ) <NEWLINE> H = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> diff = [ ] <NEWLINE> for i in H : <NEWLINE> <INDENT> diff . append ( abs ( A - T + i * 0.006 ) ) <NEWLINE> <NL> <DEDENT> diffmin = diff [ 0 ] <NEWLINE> ans = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if diffmin > diff [ i ] : <NEWLINE> <INDENT> diffmin = diff [ i ] <NEWLINE> <INDENT> ans = i <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> t , a = map ( int , input ( ) . split ( ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> l = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> l . append ( abs ( a - ( t - x * 6 / 1000 ) ) ) <NEWLINE> <DEDENT> print ( l . index ( min ( l ) ) + 1 ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> t , a = int ( input ( ) . split ( ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> x = [ ] <NEWLINE> <NL> for i in h : <NEWLINE> <INDENT> b = t - 0.006 * j - a <NEWLINE> x . append ( b ) <NEWLINE> <NL> <DEDENT> print ( x . index ( min ( x ) ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> t , a = map ( int , input ( ) . split ( ) ) <NEWLINE> H = list ( map ( int , inpt ( ) . split ( ) ) ) <NEWLINE> minn = 10 ** 10 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if minn > abs ( ( t * ( 1000 ) - 6 * H [ i ] ) - a ) : <NEWLINE> <INDENT> ans = H [ i ] <NEWLINE> minn = t * ( 1000 ) - 6 * H [ i ] <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> t , a = map ( int , input ( ) . split ( ) ) <NEWLINE> h = list ( map ( int , input ( ) . solit ( ) ) ) <NEWLINE> num = 0 <NEWLINE> dist = abs ( t - h [ 0 ] * 0.006 ) <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> if dist > abs ( ( t - h [ i ] * 0.006 ) ) : <NEWLINE> <INDENT> num = i <NEWLINE> <DEDENT> <DEDENT> print ( num + 1 ) <NEWLINE> <NL>
n = int ( input ( ) ) <NEWLINE> t , a = map ( int , input ( ) . split ( ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> k = 0 <NEWLINE> m = 100000000000000 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> b = a - t + h [ i ] * 0.006 <NEWLINE> if m > abs ( b ) : <NEWLINE> <INDENT> m = abs ( b ) <NEWLINE> k = i <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> print ( k ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> t , a = map ( int , input ( ) . split ( ) ) <NEWLINE> b = [ abs ( a - ( t - i * 0.006 ) ) for i in list ( map ( int , input ( ) . split ( ) ) ) ] <NEWLINE> print ( b . index ( min ( b ) + 1 ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> t , a = map ( int , input ( ) . split ( ) ) <NEWLINE> listh = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> diff = [ abs ( ( t - x * 0.006 ) - a ) for x in listh ] <NEWLINE> print ( diff . index ( min ( diff ) + 1 ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> T , A = map ( int , input ( ) . split ( ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = [ ] <NEWLINE> for i in h : <NEWLINE> <INDENT> a . append ( abs ( A - ( T - i * 0.006 ) ) ) <NEWLINE> <DEDENT> print ( index ( min ( a ) ) + 1 ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> t , a = map ( int , input ( ) . split ( ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> counter = 0 <NEWLINE> diff = abs ( a - ( t - h [ 0 ] * 0.006 ) ) <NEWLINE> <NL> for x in h : <NEWLINE> <INDENT> average_temple = t - x * 0.006 <NEWLINE> counter += 1 <NEWLINE> if diff > abs ( a - average_temple ) : <NEWLINE> <INDENT> poss = counter <NEWLINE> <NL> <DEDENT> <DEDENT> print ( poss ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> t , a = map ( int , input ( ) . split ( ) ) <NEWLINE> x = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> cnt = 10 ** 3 <NEWLINE> for i in range ( x ) : <NEWLINE> <INDENT> s = t - x [ i ] * 0.006 <NEWLINE> if abs ( s - a ) < cnt : <NEWLINE> <INDENT> cnt = abs ( s - a ) <NEWLINE> ans = i + 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> T , A = map ( int , input ( ) . split ( ) ) <NEWLINE> H = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> TH = [ ] <NEWLINE> for i in n : <NEWLINE> <INDENT> TH . append ( abs ( T - int ( T - 0.006 * H [ i ] ) ) ) <NEWLINE> <DEDENT> print ( TH . index ( min ( TH ) ) + 1 ) <NEWLINE>
a = int ( input ( ) ) <NEWLINE> b , c = input ( ) . split ( ) <NEWLINE> b = int ( b ) <NEWLINE> c = int ( c ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i in range ( a ) : <NEWLINE> <INDENT> l [ 0 ] == abs ( c - ( b - l [ 0 ] * 0.006 ) ) <NEWLINE> <DEDENT> for i in range ( a ) : <NEWLINE> <INDENT> if l [ i ] == min . l <NEWLINE> print ( i ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> T , A = np . array ( input ( ) . split ( ) , dtype = <STRING> ) [ : 2 ] <NEWLINE> H = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> min_dif = 10000 <NEWLINE> place = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> temp = T - H [ i ] * 0.006 <NEWLINE> dif = abs ( A - temp ) <NEWLINE> <NL> <COMMENT> <NL> if min_dif >= dif : <NEWLINE> <INDENT> min_dif = dif <NEWLINE> place = i + 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( place ) <NEWLINE>
import collections <NEWLINE> import bisect <NEWLINE> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> p = [ map ( int , input ( ) . splilt ( ) ) for i in range ( m ) ] <NEWLINE> a = collections . defaultdict ( list ) <NEWLINE> for x , y in sorted ( p ) : <NEWLINE> <INDENT> a [ x ] += [ y ] <NEWLINE> <DEDENT> for x , y in p : <NEWLINE> <INDENT> z = bisect . bisect ( a [ x ] , y ) <NEWLINE> print ( <STRING> % ( x , z ) ) <NEWLINE> <DEDENT>
<COMMENT> <NL> from math import floor , ceil , sqrt , factorial , log , gcd <NEWLINE> from itertools import accumulate , permutations , combinations , product , combinations_with_replacement <NEWLINE> from bisect import bisect_left , bisect_right <NEWLINE> from collections import Counter , defaultdict <NEWLINE> from heapq import heappop , heappush , heappushpop , heapify <NEWLINE> import copy <NEWLINE> import numpy as np <NEWLINE> import sys <NEWLINE> INF = float ( <STRING> ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> <NL> <NL> def lcm ( a , b ) : return a * b / gcd ( a , b ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> def LI ( ) : return list ( map ( int , sys . stdin . buffer . readline ( ) . split ( ) ) ) <NEWLINE> <NL> <COMMENT> <NL> <NL> <NL> def I ( ) : return int ( sys . stdin . buffer . readline ( ) ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> def LS ( ) : return sys . stdin . buffer . readline ( ) . rstrip ( ) . decode ( <STRING> ) . split ( ) <NEWLINE> <NL> <COMMENT> <NL> <NL> <NL> def S ( ) : return sys . stdin . buffer . readline ( ) . rstrip ( ) . decode ( <STRING> ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> def IR ( n ) : return [ I ( ) for i in range ( n ) ] <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> def LIR ( n ) : return [ LI ( ) for i in range ( n ) ] <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> def SR ( n ) : return [ S ( ) for i in range ( n ) ] <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> def LSR ( n ) : return [ LS ( ) for i in range ( n ) ] <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> def SRL ( n ) : return [ list ( S ( ) ) for i in range ( n ) ] <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> n , m = LI ( ) <NEWLINE> <COMMENT> <NL> lst = [ [ ] for i in range ( n ) ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> p , y = map ( int , input ( ) . split ( ) ) <NEWLINE> lst [ p - 1 ] . append ( y ) <NEWLINE> <NL> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> if len ( lst [ i ] ) > 1 : <NEWLINE> <INDENT> lst [ i ] . sort ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> for pair in py : <NEWLINE> <INDENT> print ( str ( pair [ 0 ] * 1000000 + lst [ pair [ 0 ] - 1 ] . index ( pair [ 1 ] ) + 1 ) . zfill ( 12 ) ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
from collections import defaultdict <NEWLINE> from bisect import bisect <NEWLINE> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> l = [ list ( map ( int , input ( ) . split ( ) ) for _ in range ( m ) ) ] <NEWLINE> a = defaultdict ( list ) <NEWLINE> for x , y in sorted ( l ) : <NEWLINE> <INDENT> a [ x ] += [ y ] <NEWLINE> <NL> <DEDENT> for x , y in l : <NEWLINE> <INDENT> z = bisect ( a [ x ] , y ) <NEWLINE> print ( <STRING> % ( x , z ) ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> if len ( s ) == 3 : <NEWLINE> <INDENT> s . reverse ( ) <NEWLINE> <DEDENT> print ( s ) <NEWLINE>
S = str ( input ( ) ) <NEWLINE> if len ( S ) == 2 : <NEWLINE> <INDENT> print ( S ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( S . reverse ( ) ) <NEWLINE> <DEDENT>
if len ( S ) == 2 : <NEWLINE> <INDENT> print ( S ) <NEWLINE> <DEDENT> if len ( S ) == 3 : <NEWLINE> <INDENT> print ( S [ 2 ] + S [ 1 ] + S [ 0 ] ) <NEWLINE> <DEDENT>
S = input ( ) <NEWLINE> buffer = 0 <NEWLINE> if len ( S ) != 2 : <NEWLINE> <INDENT> buffer = S [ 0 ] <NEWLINE> S [ 0 ] = S [ 2 ] <NEWLINE> S [ 2 ] = buffer <NEWLINE> <DEDENT> print ( S ) <NEWLINE>
s = input ( ) <NEWLINE> <NL> if len ( s ) == 2 : <NEWLINE> <INDENT> print ( s ) <NEWLINE> <DEDENT> if len ( s ) == 3 : <NEWLINE> <INDENT> s . reverse ( ) <NEWLINE> print ( s ) <NEWLINE> <DEDENT>
n = input ( ) <NEWLINE> print ( n . reverse ( ) if len ( n ) == 3 else n ) <NEWLINE>
s = input ( ) <NEWLINE> if len ( S ) == 2 : <NEWLINE> <INDENT> print ( s ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( s [ 2 ] + s [ 1 ] + s [ 0 ] ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> if len ( n ) == 2 : <NEWLINE> <INDENT> print ( n ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( n [ : : - 1 ] ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> a = [ int ( input ( ) ) for _ in range ( N ) ] <NEWLINE> <NL> if N % 2 == 0 : <NEWLINE> <INDENT> res = 2 * ( sum ( a [ N // 2 : ] ) - sum ( a [ : N // 2 ] ) ) <NEWLINE> res += a [ N // 2 - 1 ] - a [ N // 2 ] <NEWLINE> print ( res ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> res = 2 * ( sum ( a [ N // 2 + 1 : ] ) - sum ( a [ N // 2 ] ) ) <NEWLINE> print ( res - min ( a [ N // 2 + 1 ] - a [ N // 2 ] - a [ N // 2 - 1 ] ) ) <NEWLINE> <DEDENT>
A . sort ( ) <NEWLINE> n = N // 2 <NEWLINE> if N % 2 != 0 : <NEWLINE> <INDENT> ans1 , ans2 , ans = 0 , 0 , 0 <NEWLINE> ar1 , ar2 = A [ : n ] , A [ n + 1 : ] <NEWLINE> ar = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ar . append ( ar2 [ i ] ) <NEWLINE> ar . append ( ar1 [ i ] ) <NEWLINE> <DEDENT> ar . append ( A [ n ] ) <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> ans1 += abs ( ar [ i ] - ar [ i + 1 ] ) <NEWLINE> <DEDENT> ar = [ A [ n ] ] + ar [ : - 1 ] <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> ans2 += abs ( ar [ i ] - ar [ i + 1 ] ) <NEWLINE> <DEDENT> ans = max ( ans1 , ans2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = 0 <NEWLINE> ar1 , ar2 = A [ : n ] , A [ n : ] <NEWLINE> ar = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ar . append ( ar2 [ i ] ) <NEWLINE> ar . append ( ar1 [ i ] ) <NEWLINE> <DEDENT> for i in range ( N - 1 ) : <NEWLINE> <INDENT> ans += abs ( ar [ i ] - ar [ i + 1 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from collections import deque <NEWLINE> import copy <NEWLINE> sys . setrecursionlimit ( 50000 ) <NEWLINE> N = int ( input ( ) ) <NEWLINE> d_1 , d_2 = deque ( [ ] ) , deque ( [ ] ) <NEWLINE> l = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> l . append ( int ( input ( ) ) ) <NEWLINE> <NL> <DEDENT> l . sort ( ) <NEWLINE> l_1 , l_2 = copy . copy ( l ) , copy . copy ( l ) <NEWLINE> d_1 . append ( max ( l ) ) <NEWLINE> d_2 . append ( min ( l ) ) <NEWLINE> l_1 . pop ( ) <NEWLINE> l_2 . pop ( 0 ) <NEWLINE> <NL> def main1 ( d , l ) : <NEWLINE> <INDENT> d . appendleft ( l [ 0 ] ) <NEWLINE> l . pop ( 0 ) <NEWLINE> if l == [ ] : <NEWLINE> <INDENT> return d <NEWLINE> <DEDENT> d . append ( l [ 0 ] ) <NEWLINE> l . pop ( 0 ) <NEWLINE> if l == [ ] : <NEWLINE> <INDENT> return d <NEWLINE> <DEDENT> d . appendleft ( l [ - 1 ] ) <NEWLINE> l . pop ( ) <NEWLINE> if l == [ ] : <NEWLINE> <INDENT> return d <NEWLINE> <DEDENT> d . append ( l [ - 1 ] ) <NEWLINE> l . pop ( ) <NEWLINE> if l == [ ] : <NEWLINE> <INDENT> return d <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return main1 ( d , l ) <NEWLINE> <NL> <DEDENT> <DEDENT> def main2 ( d , l ) : <NEWLINE> <INDENT> d . appendleft ( l [ - 1 ] ) <NEWLINE> l . pop ( ) <NEWLINE> if l == [ ] : <NEWLINE> <INDENT> return d <NEWLINE> <DEDENT> d . append ( l [ - 1 ] ) <NEWLINE> l . pop ( ) <NEWLINE> if l == [ ] : <NEWLINE> <INDENT> return d <NEWLINE> <DEDENT> d . appendleft ( l [ 0 ] ) <NEWLINE> l . pop ( 0 ) <NEWLINE> if l == [ ] : <NEWLINE> <INDENT> return d <NEWLINE> <DEDENT> d . append ( l [ 0 ] ) <NEWLINE> l . pop ( 0 ) <NEWLINE> if l == [ ] : <NEWLINE> <INDENT> return d <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return main2 ( d , l ) <NEWLINE> <NL> <DEDENT> <DEDENT> x , y = 0 , 0 <NEWLINE> a = main1 ( d_1 , l_1 ) <NEWLINE> b = main2 ( d_2 , l_2 ) <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> x += abs ( a [ i + 1 ] - a [ i ] ) <NEWLINE> y += abs ( b [ i + 1 ] - b [ i ] ) <NEWLINE> <DEDENT> print ( max ( x , y ) ) <NEWLINE>
from copy import deepcopy <NEWLINE> <NL> n , * a = map ( int , open ( 0 ) . read ( ) . split ( ) ) <NEWLINE> acopy = deepcopy ( a ) <NEWLINE> a . sort ( ) <NEWLINE> acopy . sort ( reverse = True ) <NEWLINE> <NL> L = deque ( [ ] ) <NEWLINE> a = deque ( a ) <NEWLINE> acopy = deque ( acopy ) <NEWLINE> Lcopy = deepcopy ( L ) <NEWLINE> <NL> max_ = a . pop ( ) <NEWLINE> L . append ( max_ ) <NEWLINE> min_ = acopy . pop ( ) <NEWLINE> Lcopy . append ( min_ ) <NEWLINE> <NL> while a : <NEWLINE> <INDENT> if a : <NEWLINE> <INDENT> b = a . popleft ( ) <NEWLINE> L . append ( b ) <NEWLINE> <DEDENT> if a : <NEWLINE> <INDENT> c = a . popleft ( ) <NEWLINE> L . appendleft ( c ) <NEWLINE> <DEDENT> if a : <NEWLINE> <INDENT> d = a . pop ( ) <NEWLINE> L . append ( d ) <NEWLINE> <DEDENT> if a : <NEWLINE> <INDENT> e = a . pop ( ) <NEWLINE> L . appendleft ( e ) <NEWLINE> <NL> <DEDENT> <DEDENT> while acopy : <NEWLINE> <INDENT> if acopy : <NEWLINE> <INDENT> b = acopy . popleft ( ) <NEWLINE> Lcopy . append ( b ) <NEWLINE> <DEDENT> if acopy : <NEWLINE> <INDENT> c = acopy . popleft ( ) <NEWLINE> Lcopy . appendleft ( c ) <NEWLINE> <DEDENT> if acopy : <NEWLINE> <INDENT> d = acopy . pop ( ) <NEWLINE> Lcopy . append ( d ) <NEWLINE> <DEDENT> if acopy : <NEWLINE> <INDENT> e = acopy . pop ( ) <NEWLINE> Lcopy . appendleft ( e ) <NEWLINE> <DEDENT> <DEDENT> ans1 , ans2 = 0 , 0 <NEWLINE> <COMMENT> <NL> for i in range ( len ( L ) - 1 ) : <NEWLINE> <INDENT> ans1 += abs ( L [ i + 1 ] - L [ i ] ) <NEWLINE> <DEDENT> for i in range ( len ( Lcopy ) - 1 ) : <NEWLINE> <INDENT> ans2 += abs ( Lcopy [ i + 1 ] - Lcopy [ i ] ) <NEWLINE> <DEDENT> print ( max ( ans1 , ans2 ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> d = [ int ( input ( ) ) for _ in range ( n ) ] <NEWLINE> from collections import deque <NEWLINE> d . sort ( ) <NEWLINE> a = deque ( d ) <NEWLINE> <NL> tmpl = a . popleft ( ) <NEWLINE> tmpr = tmpl <NEWLINE> ans = 0 <NEWLINE> i = 0 <NEWLINE> <NL> while len ( a ) > 0 : <NEWLINE> <COMMENT> <NL> <INDENT> if i % 4 == 0 : <NEWLINE> <INDENT> tmp = a . pop ( ) <NEWLINE> ans += abs ( tmpl - tmp ) <NEWLINE> tmpl = tmp <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> elif i % 4 == 1 : <NEWLINE> <INDENT> tmp = a . pop ( ) <NEWLINE> ans += abs ( tmpr - tmp ) <NEWLINE> tmpr = tmp <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> elif i % 4 == 2 : <NEWLINE> <INDENT> tmp = a . popleft ( ) <NEWLINE> ans += abs ( tmpl - tmp ) <NEWLINE> tmpl = tmp <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> elif i % 4 == 3 : <NEWLINE> <INDENT> tmp = a . popleft ( ) <NEWLINE> ans += abs ( tmpr - tmp ) <NEWLINE> tmpr = tmp <NEWLINE> <NL> <DEDENT> i += 1 <NEWLINE> <NL> <DEDENT> res = ans <NEWLINE> <NL> d . sort ( reverse = True ) <NEWLINE> a = deque ( copy . deepcopy ( d ) ) <NEWLINE> <NL> tmpl = a . popleft ( ) <NEWLINE> tmpr = tmpl <NEWLINE> ans = 0 <NEWLINE> i = 0 <NEWLINE> <NL> while len ( a ) > 0 : <NEWLINE> <COMMENT> <NL> <INDENT> if i % 4 == 0 : <NEWLINE> <INDENT> tmp = a . pop ( ) <NEWLINE> ans += abs ( tmpl - tmp ) <NEWLINE> tmpl = tmp <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> elif i % 4 == 1 : <NEWLINE> <INDENT> tmp = a . pop ( ) <NEWLINE> ans += abs ( tmpr - tmp ) <NEWLINE> tmpr = tmp <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> elif i % 4 == 2 : <NEWLINE> <INDENT> tmp = a . popleft ( ) <NEWLINE> ans += abs ( tmpl - tmp ) <NEWLINE> tmpl = tmp <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> elif i % 4 == 3 : <NEWLINE> <INDENT> tmp = a . popleft ( ) <NEWLINE> ans += abs ( tmpr - tmp ) <NEWLINE> tmpr = tmp <NEWLINE> <NL> <DEDENT> i += 1 <NEWLINE> <NL> <DEDENT> print ( max ( ans , res ) ) <NEWLINE> <NL> <NL> <NL> <NL> <NL> <NL> <NL>
import re <NEWLINE> import sys <NEWLINE> import math <NEWLINE> import itertools <NEWLINE> import bisect <NEWLINE> from copy import copy <NEWLINE> from collections import deque , Counter <NEWLINE> from decimal import Decimal <NEWLINE> import functools <NEWLINE> def v ( ) : return input ( ) <NEWLINE> def k ( ) : return int ( input ( ) ) <NEWLINE> def S ( ) : return input ( ) . split ( ) <NEWLINE> def I ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def X ( ) : return list ( input ( ) ) <NEWLINE> def L ( ) : return list ( input ( ) . split ( ) ) <NEWLINE> def l ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> def lcm ( a , b ) : return a * b // math . gcd ( a , b ) <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> cnt = 0 <NEWLINE> ans = 0 <NEWLINE> inf = float ( <STRING> ) <NEWLINE> <NL> n , m = I ( ) <NEWLINE> s = v ( ) <NEWLINE> t = v ( ) <NEWLINE> l = lcm ( n , m ) <NEWLINE> g = gcd ( n , m ) <NEWLINE> <NL> for i in range ( g ) : <NEWLINE> <INDENT> if s [ n // g * i ] != t [ m // g * i ] : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( l ) <NEWLINE>
import math <NEWLINE> def main5 ( ) : <NEWLINE> <INDENT> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> S = input ( ) <NEWLINE> T = input ( ) <NEWLINE> <NL> G = math . gcd ( N , M ) <NEWLINE> L = ( N * M ) // G <NEWLINE> <NL> for i in range ( G ) : <NEWLINE> <INDENT> if S [ i * N // G ] != T [ i * M // G ] : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( L ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main4 ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> import sys <NEWLINE> from collections import deque , defaultdict <NEWLINE> from math import sqrt , factorial , gcd <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> def solve ( ) : <NEWLINE> <INDENT> n , m = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> s = input ( ) <NEWLINE> t = input ( ) <NEWLINE> g = gcd ( n , m ) <NEWLINE> ans = n * m // g <NEWLINE> a , b = n // g , m // g <NEWLINE> x , y = 0 , 0 <NEWLINE> for i in range ( g ) : <NEWLINE> <INDENT> if s [ x ] != x [ y ] : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> return <NEWLINE> <DEDENT> x += a <NEWLINE> y += b <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> t = 1 <NEWLINE> <COMMENT> <NL> for case in range ( 1 , t + 1 ) : <NEWLINE> <INDENT> ans = solve ( ) <NEWLINE> <NL> <NL> <DEDENT> <STRING> <NEWLINE>
from math import gcd <NEWLINE> <NL> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> c = input ( ) <NEWLINE> d = input ( ) <NEWLINE> <NL> e = gcd ( n , m ) <NEWLINE> <NL> ae = a // e <NEWLINE> be = b // e <NEWLINE> <NL> for i in range ( 0 , e ) : <NEWLINE> <INDENT> if c [ ae * i ] != d [ be * i ] : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( ae * be * e ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = int ( input ( ) ) <NEWLINE> b = int ( input ( ) ) <NEWLINE> if ( n == 1 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif ( n == 2 ) : <NEWLINE> <INDENT> print ( int ( a + b ) ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> <NL> if n == 2 : <NEWLINE> <INDENT> a = int ( input ( ) ) <NEWLINE> <INDENT> b = int ( input ( ) ) <NEWLINE> print ( a + b ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = int ( input ( ) ) <NEWLINE> b = int ( input ( ) ) <NEWLINE> if n == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( a + b ) <NEWLINE> <DEDENT>
a = int ( input ( ) ) <NEWLINE> b = int ( input ( ) ) <NEWLINE> c = int ( input ( ) ) <NEWLINE> if a == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> if a == 2 : <NEWLINE> <INDENT> print ( int ( b + c ) ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> if n == 1 : <NEWLINE> <INDENT> orint ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a = int ( input ( ) ) <NEWLINE> b = int ( input ( ) ) <NEWLINE> print ( a + b ) <NEWLINE> <DEDENT>
<NL> def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> a = int ( input ( ) ) <NEWLINE> b = int ( input ( ) ) <NEWLINE> if n == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( a + b ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = int ( input ( ) ) <NEWLINE> b = int ( input ( ) ) <NEWLINE> if n == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( a + b ) <NEWLINE> <DEDENT>
a = [ int ( input ( ) ) for i in range ( 3 ) ] <NEWLINE> <NL> if a [ 0 ] == 2 : <NEWLINE> <INDENT> print ( a [ 1 ] + a [ 2 ] ) <NEWLINE> <NL> <DEDENT> elif a [ 0 ] == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <NL> <NL> def calculation ( lines ) : <NEWLINE> <INDENT> n = int ( lines [ 0 ] ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> if n == 1 : <NEWLINE> <INDENT> return [ <STRING> ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> A = int ( lines [ 1 ] ) <NEWLINE> B = int ( lines [ 2 ] ) <NEWLINE> return [ A + B ] <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> def get_input_lines ( ) : <NEWLINE> <INDENT> line = input ( ) <NEWLINE> N = int ( line ) <NEWLINE> lines = list ( ) <NEWLINE> lines . append ( line ) <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> lines . append ( input ( ) ) <NEWLINE> <DEDENT> return lines <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> def get_testdata ( pattern ) : <NEWLINE> <INDENT> if pattern == 1 : <NEWLINE> <INDENT> lines_input = [ <STRING> ] <NEWLINE> lines_export = [ <STRING> ] <NEWLINE> <DEDENT> if pattern == 2 : <NEWLINE> <INDENT> lines_input = [ <STRING> , <STRING> , <STRING> ] <NEWLINE> lines_export = [ 8 ] <NEWLINE> <DEDENT> return lines_input , lines_export <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> def get_mode ( ) : <NEWLINE> <INDENT> import sys <NEWLINE> args = sys . argv <NEWLINE> if len ( args ) == 1 : <NEWLINE> <INDENT> mode = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> mode = int ( args [ 1 ] ) <NEWLINE> <DEDENT> return mode <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> import time <NEWLINE> started = time . time ( ) <NEWLINE> mode = get_mode ( ) <NEWLINE> if mode == 0 : <NEWLINE> <INDENT> lines_input = get_input_lines ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> lines_input , lines_export = get_testdata ( mode ) <NEWLINE> <NL> <DEDENT> lines_result = calculation ( lines_input ) <NEWLINE> <NL> for line_result in lines_result : <NEWLINE> <INDENT> print ( line_result ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a , b = int ( input ( ) ) , int ( input ( ) ) <NEWLINE> if n == 1 : print ( <STRING> ) <NEWLINE> else : print ( a + b ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = int ( input ( ) ) <NEWLINE> B = int ( input ( ) ) <NEWLINE> <NL> if N == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif N == 2 : <NEWLINE> <INDENT> print ( A + B ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> if n == 1 : print ( <STRING> ) <NEWLINE> a = int ( input ( ) ) <NEWLINE> b = int ( input ( ) ) <NEWLINE> if n == 2 : print ( a + b ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> if n = 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> a = int ( input ( ) ) <NEWLINE> b = int ( input ( ) ) <NEWLINE> print ( a + b ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = int ( input ( ) ) <NEWLINE> b = int ( input ( ) ) <NEWLINE> <NL> if n == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> if n == 2 : <NEWLINE> <INDENT> print ( a + b ) <NEWLINE> <DEDENT>
if input ( ) == <STRING> : <NEWLINE> <INDENT> print ( Hello World ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( eval ( input ( ) + <STRING> + input ( ) ) ) <NEWLINE> <DEDENT>
n , t = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( n ) ] <NEWLINE> l = [ ] <NEWLINE> flag = False <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if a [ i ] [ 2 ] <= t : <NEWLINE> <INDENT> l . append ( a [ i ] [ 0 ] ) <NEWLINE> flag = True <NEWLINE> <DEDENT> <DEDENT> if flag : <NEWLINE> <INDENT> print ( min ( l ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
T , N = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans_c = 1001 <NEWLINE> for i in range ( T ) : <NEWLINE> <INDENT> c , t = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if ( N >= t ) and ( c <= ans_c ) : <NEWLINE> <INDENT> ans_c = c <NEWLINE> <NL> <DEDENT> <DEDENT> if ans_t == 1001 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans_c ) <NEWLINE> <DEDENT>
N , T = map ( int , input ( ) . split ( ) ) <NEWLINE> k = 1000 <NEWLINE> l = 1 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> c , t = int ( input ( ) ) <NEWLINE> if t [ i ] <= T : <NEWLINE> <INDENT> l = 0 <NEWLINE> if c [ i ] < k : <NEWLINE> <INDENT> k = c [ i ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if l == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( k ) <NEWLINE> <DEDENT>
N , T = map ( int , input ( ) . split ( ) ) <NEWLINE> c = 1001 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> c , t = map ( int , input ( ) . split ( ) ) <NEWLINE> if t <= T : <NEWLINE> <INDENT> ans = min ( ans , c ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) if c < 1001 else print ( <STRING> ) <NEWLINE>
a , b = map ( int , inpu ( ) . split ( ) ) <NEWLINE> meta = int ( a ) <NEWLINE> for i in range ( a ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> if b > y and a > x : <NEWLINE> <INDENT> a = x <NEWLINE> <DEDENT> <DEDENT> if meta > a : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n , t = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> m = 1001 <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <NL> <INDENT> c , t = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if t <= T : <NEWLINE> <INDENT> m = min ( m , c ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> if m == 1001 else m ) <NEWLINE> <NL>
N , T = map ( int , input ( ) . split ( ) ) <NEWLINE> X = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( N ) ] <NEWLINE> Y = [ X [ i ] if X [ i ] [ 1 ] <= T for i in range ( N ) ] <NEWLINE> print ( Y ) <NEWLINE>
n , t = map ( int , input . split ( ) ) <NEWLINE> <NL> max_cost = 10 ** 9 <NEWLINE> <NL> for _ in range ( n ) : <NEWLINE> <INDENT> c , tt = map ( int , input ( ) . split ( ) ) <NEWLINE> if tt <= t : <NEWLINE> <INDENT> max_cost = max ( max_cost , c ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( max_cost ) <NEWLINE>
n , t = map ( int , input ( ) . split ( ) ) <NEWLINE> c = 999 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> tmp = input ( ) . split ( ) <NEWLINE> if t <= tmp [ 1 ] : <NEWLINE> <INDENT> if tmp [ 0 ] < c : <NEWLINE> <INDENT> c = tmp [ 0 ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if c == 999 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( c ) <NEWLINE> <DEDENT>
N , T = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = 100000 <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> c , t = map ( int , input ( ) . split ( ) ) <NEWLINE> if t <= T : <NEWLINE> <INDENT> ans = min ( ans , c ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> if ans = 100000 else ans ) <NEWLINE>
a , b = input ( ) . split ( ) <NEWLINE> a = int ( a ) <NEWLINE> b = int ( b ) <NEWLINE> c = [ input ( ) . split ( ) for i in range ( a ) ] <NEWLINE> d = 1001 <NEWLINE> for i in range ( a ) : <NEWLINE> <INDENT> if int ( c [ i ] [ i ] ) <= b : <NEWLINE> <INDENT> if d > int ( c [ i ] [ i ] ) : <NEWLINE> <INDENT> d = int ( c [ i ] [ i ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( d ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> def calculation ( lines ) : <NEWLINE> <COMMENT> <NL> <INDENT> N , T = list ( map ( int , lines [ 0 ] . split ( ) ) ) <NEWLINE> <COMMENT> <NL> <NL> min_c = None <NEWLINE> <NL> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> c , t = list ( map ( int , lines [ i ] . split ( ) ) ) <NEWLINE> if t <= T : <NEWLINE> <INDENT> if min_c is None : <NEWLINE> <INDENT> min_c = c <NEWLINE> <DEDENT> elif min_c > c : <NEWLINE> <INDENT> min_c = c <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if min_c is None : <NEWLINE> <INDENT> return [ <STRING> ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return [ min_c ] <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> def get_input_lines ( lines_count ) : <NEWLINE> <INDENT> lines = list ( ) <NEWLINE> for _ in range ( lines_count ) : <NEWLINE> <INDENT> lines . append ( input ( ) ) <NEWLINE> <DEDENT> return lines <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> def get_testdata ( pattern ) : <NEWLINE> <INDENT> if pattern == 1 : <NEWLINE> <INDENT> lines_input = [ <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> lines_export = [ 4 ] <NEWLINE> <DEDENT> if pattern == 2 : <NEWLINE> <INDENT> lines_input = [ <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> lines_export = [ <STRING> ] <NEWLINE> <DEDENT> if pattern == 3 : <NEWLINE> <INDENT> lines_input = [ <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> lines_export = [ 5 ] <NEWLINE> <DEDENT> return lines_input , lines_export <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> def get_mode ( ) : <NEWLINE> <INDENT> import sys <NEWLINE> args = sys . argv <NEWLINE> if len ( args ) == 1 : <NEWLINE> <INDENT> mode = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> mode = int ( args [ 1 ] ) <NEWLINE> <DEDENT> return mode <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> import time <NEWLINE> started = time . time ( ) <NEWLINE> mode = get_mode ( ) <NEWLINE> if mode == 0 : <NEWLINE> <INDENT> lines_input = get_input_lines ( 2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> lines_input , lines_export = get_testdata ( mode ) <NEWLINE> <NL> <DEDENT> lines_result = calculation ( lines_input ) <NEWLINE> <NL> for line_result in lines_result : <NEWLINE> <INDENT> print ( line_result ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> xyh = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( n ) ] <NEWLINE> <NL> ansh = - 1 <NEWLINE> ans = [ ] <NEWLINE> flag = True <NEWLINE> for cx in range ( 0 , 101 ) : <NEWLINE> <INDENT> if len ( ans ) > 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for cy in range ( 0 , 101 ) : <NEWLINE> <INDENT> if len ( ans ) > 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> ansh = - 1 <NEWLINE> for pira in xyh : <NEWLINE> <NL> <INDENT> if flag and pira [ 2 ] == 0 and ansh == - 1 and pira [ 2 ] + abs ( cx - pira [ 0 ] ) + abs ( cy - pira [ 1 ] ) <= 0 : <NEWLINE> <INDENT> ansh = pira [ 2 ] + abs ( cx - pira [ 0 ] ) + abs ( cy - pira [ 1 ] ) <NEWLINE> ans . append ( [ cx , cy , ansh ] ) <NEWLINE> <NL> <DEDENT> elif flag and pira [ 2 ] > 0 and ansh == - 1 : <NEWLINE> <INDENT> ansh = pira [ 2 ] + abs ( cx - pira [ 0 ] ) + abs ( cy - pira [ 1 ] ) <NEWLINE> ans . append ( [ cx , cy , ansh ] ) <NEWLINE> flag = False <NEWLINE> <NL> <DEDENT> elif len ( ans ) > 0 and pira [ 2 ] > 0 and ansh != pira [ 2 ] + abs ( cx - pira [ 0 ] ) + abs ( cy - pira [ 1 ] ) : <NEWLINE> <INDENT> ans = [ ] <NEWLINE> break <NEWLINE> <NL> <DEDENT> elif len ( ans ) > 0 and pira [ 2 ] == 0 and ansh - abs ( cx - pira [ 0 ] ) - abs ( cy - pira [ 1 ] ) > 0 : <NEWLINE> <INDENT> ans = [ ] <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( * ans [ 0 ] ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> x = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( N ) ] <NEWLINE> Cx = 0 <NEWLINE> Cy = 0 <NEWLINE> H = 0 <NEWLINE> dp = [ [ 0 ] * 101 for i in range ( 101 ) ] <NEWLINE> ans = 10 ** 10 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> for j in range ( 101 ) : <NEWLINE> <INDENT> for k in range ( 101 ) : <NEWLINE> <INDENT> count = abs ( x [ i ] [ 0 ] - j ) + abs ( x [ i ] [ 1 ] - k ) + x [ i ] [ 2 ] <NEWLINE> if dp [ j ] [ k ] != i * count : <NEWLINE> <INDENT> dp [ j ] [ k ] = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dp [ j ] [ k ] += count <NEWLINE> <DEDENT> ans = min ( ans , x [ i ] [ 2 ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> p = 10 ** 19 <NEWLINE> a = 0 <NEWLINE> b = 0 <NEWLINE> for i in range ( 101 ) : <NEWLINE> <INDENT> for j in range ( 101 ) : <NEWLINE> <INDENT> if dp [ i ] [ j ] % N == 0 dp [ i ] [ j ] != 0 : <NEWLINE> <INDENT> if p != min ( p , dp [ i ] [ j ] // N ) : <NEWLINE> <INDENT> a = i <NEWLINE> b = j <NEWLINE> p = min ( p , dp [ i ] [ j ] // N ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( a , b , p ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> XYH = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ] <NEWLINE> x1 , y1 , h1 = XYH [ 0 ] <NEWLINE> <COMMENT> <NL> <NL> for Cx in range ( 101 ) : <NEWLINE> <INDENT> for Cy in range ( 101 ) : <NEWLINE> <INDENT> H = h1 + abs ( x1 - Cx ) + abs ( y1 - Cy ) <NEWLINE> <COMMENT> <NL> if all ( h == max ( H - abs ( x - Cx ) - abs ( y - Cy ) , 0 ) for x , y , h in XYH : <NEWLINE> <INDENT> print ( Cx , Cy , H ) <NEWLINE> exit ( ) <NEWLINE> <NL> <NL> <NL> <DEDENT> <DEDENT> <DEDENT>
<COMMENT> <NL> <NL> N = int ( input ( ) ) <NEWLINE> conditions = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> x , y , h = map ( int , input ( ) . split ( ) ) <NEWLINE> conditions . append ( [ x , y , h ] ) <NEWLINE> <NL> <NL> <DEDENT> for cx in range ( 101 ) : <NEWLINE> <INDENT> for cy in range ( 101 ) : <NEWLINE> <INDENT> H = - 1 <NEWLINE> for _ , cond in enumerate ( conditions ) : <NEWLINE> <INDENT> if cond [ 2 ] > 0 : <NEWLINE> <INDENT> H_tmp = cond [ 2 ] + abs ( cond [ 0 ] - cx ) + abs ( cond [ 1 ] - cy ) <NEWLINE> if H == - 1 : <NEWLINE> <INDENT> H = H_tmp <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if H_tmp != H : <NEWLINE> <INDENT> H = - 2 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if H == - 2 : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <DEDENT> for _ , cond in enumerate ( conditions ) : <NEWLINE> <INDENT> if cond [ 2 ] == 0 : <NEWLINE> <INDENT> if H > abs ( cond [ 0 ] - cx ) + abs ( cond [ 1 ] - cy ) : <NEWLINE> <INDENT> H = - 2 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if H == - 2 : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <DEDENT> print ( cx , cy , H ) <NEWLINE> exit ( 1 ) <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> import sys <NEWLINE> input = sys . stdin . readline <COMMENT> <NEWLINE> N = int ( input ( ) ) <NEWLINE> xyh = [ 0 ] * N <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> xyh [ i ] = tuple ( int ( i ) for i in input ( ) . split ( ) ) <NEWLINE> <NL> <DEDENT> from collections import defaultdict <NEWLINE> H = defaultdict ( set ) <NEWLINE> for x , y , h in xyh : <NEWLINE> <INDENT> for cx in range ( 101 ) : <NEWLINE> <INDENT> for cy in range ( 101 ) : <NEWLINE> <INDENT> xx = x - cx <NEWLINE> yy = y - cy <NEWLINE> if cx <= x and cy <= y : <NEWLINE> <INDENT> H [ ( cx , cy ) ] . add ( ( h + xx + yy ) ) <NEWLINE> <DEDENT> elif cx > x and cy <= y : <NEWLINE> <INDENT> H [ ( cx , cy ) ] . add ( ( h - xx + yy ) ) <NEWLINE> <DEDENT> elif cx <= x and cy > y : <NEWLINE> <INDENT> H [ ( cx , cy ) ] . add ( ( h + xx - yy ) ) <NEWLINE> <DEDENT> elif cx > x and cy > y : <NEWLINE> <INDENT> H [ ( cx , cy ) ] . add ( ( h - xx - yy ) ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for k , v in H . items ( ) : <NEWLINE> <INDENT> if len ( v ) == 1 : <NEWLINE> <INDENT> if 0 <= v [ 0 ] <= 10 ** 9 : <NEWLINE> <INDENT> print ( * k , * v ) <NEWLINE> <DEDENT> elif v [ 0 ] < 0 : <NEWLINE> <INDENT> print ( * k , 0 ) <NEWLINE> <DEDENT> elif 10 ** 9 < v [ 0 ] : <NEWLINE> <INDENT> print ( * k , 10 ** 9 ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <NL> <NL> def calculation ( lines ) : <NEWLINE> <INDENT> N = int ( lines [ 0 ] ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> points = list ( ) <NEWLINE> highest = 0 <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> point = list ( map ( int , lines [ i ] . split ( ) ) ) <NEWLINE> <COMMENT> <NL> points . append ( point ) <NEWLINE> if highest < point [ 2 ] : <NEWLINE> <INDENT> highest = point [ 2 ] <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> for x in range ( 101 ) : <NEWLINE> <INDENT> for y in range ( 101 ) : <NEWLINE> <INDENT> for h in range ( highest , highest + 200 ) : <NEWLINE> <COMMENT> <NL> <INDENT> flag = True <NEWLINE> for point in points : <NEWLINE> <COMMENT> <NL> <INDENT> calc_h = max ( h - abs ( point [ 0 ] - x ) - abs ( point [ 1 ] - y ) , 0 ) <NEWLINE> if point [ 2 ] != calc_h : <NEWLINE> <INDENT> flag = False <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if flag : <NEWLINE> <INDENT> result = str ( x ) + <STRING> + str ( y ) + <STRING> + str ( h ) <NEWLINE> return [ result ] <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> def get_input_lines ( lines_count ) : <NEWLINE> <INDENT> lines = list ( ) <NEWLINE> for _ in range ( lines_count ) : <NEWLINE> <INDENT> lines . append ( input ( ) ) <NEWLINE> <DEDENT> return lines <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> def get_testdata ( pattern ) : <NEWLINE> <INDENT> if pattern == 1 : <NEWLINE> <INDENT> lines_input = [ <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> lines_export = [ <STRING> ] <NEWLINE> <DEDENT> if pattern == 2 : <NEWLINE> <INDENT> lines_input = [ <STRING> , <STRING> , <STRING> ] <NEWLINE> lines_export = [ <STRING> ] <NEWLINE> <DEDENT> if pattern == 3 : <NEWLINE> <INDENT> lines_input = [ <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> lines_export = [ <STRING> ] <NEWLINE> <DEDENT> return lines_input , lines_export <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> def get_mode ( ) : <NEWLINE> <INDENT> import sys <NEWLINE> args = sys . argv <NEWLINE> if len ( args ) == 1 : <NEWLINE> <INDENT> mode = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> mode = int ( args [ 1 ] ) <NEWLINE> <DEDENT> return mode <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> import time <NEWLINE> started = time . time ( ) <NEWLINE> mode = get_mode ( ) <NEWLINE> if mode == 0 : <NEWLINE> <INDENT> lines_input = get_input_lines ( 2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> lines_input , lines_export = get_testdata ( mode ) <NEWLINE> <NL> <DEDENT> lines_result = calculation ( lines_input ) <NEWLINE> <NL> for line_result in lines_result : <NEWLINE> <INDENT> print ( line_result ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> import sys <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> import numpy as np <NEWLINE> <COMMENT> <NL> import numba as nb <NEWLINE> from numba import njit , i8 , u1 , b1 <COMMENT> <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> MOD = 10 ** 9 + 7 <NEWLINE> INF = 10 ** 9 <NEWLINE> PI = 3.14159265358979323846 <NEWLINE> <NL> def read_str ( ) : return sys . stdin . readline ( ) . strip ( ) <NEWLINE> def read_int ( ) : return int ( sys . stdin . readline ( ) . strip ( ) ) <NEWLINE> def read_ints ( ) : return map ( int , sys . stdin . readline ( ) . strip ( ) . split ( ) ) <NEWLINE> def read_ints2 ( x ) : return map ( lambda num : int ( num ) - x , sys . stdin . readline ( ) . strip ( ) . split ( ) ) <NEWLINE> def read_str_list ( ) : return list ( sys . stdin . readline ( ) . strip ( ) . split ( ) ) <NEWLINE> def read_int_list ( ) : return list ( map ( int , sys . stdin . readline ( ) . strip ( ) . split ( ) ) ) <NEWLINE> def GCD ( a : int , b : int ) -> int : return b if a % b == 0 else GCD ( b , a % b ) <NEWLINE> def LCM ( a : int , b : int ) -> int : return ( a * b ) // GCD ( a , b ) <NEWLINE> <NL> @ njit ( cache = True ) <NEWLINE> def solve ( info ) : <NEWLINE> <INDENT> for Cx in range ( 101 ) : <NEWLINE> <INDENT> for Cy in range ( 101 ) : <NEWLINE> <INDENT> height = abs ( Cx - info [ 0 ] [ 0 ] ) + abs ( Cy - info [ 0 ] [ 1 ] ) + info [ 0 ] [ 2 ] <NEWLINE> flag = True <NEWLINE> for i in range ( 1 , len ( info ) - 1 ) : <NEWLINE> <INDENT> x , y , h = info [ i ] [ 0 ] , info [ i ] [ 1 ] , info [ i ] [ 2 ] <NEWLINE> val = max ( height - abs ( Cx - x ) - abs ( Cy - y ) , 0 ) <NEWLINE> if h == val : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> flag = False <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if flag : <NEWLINE> <INDENT> return Cx , Cy , height <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> def Main ( ) : <NEWLINE> <INDENT> n = read_int ( ) <NEWLINE> info = np . empty ( ( n , 3 ) , dtype = np . int64 ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> info [ i ] [ 0 ] , info [ i ] [ 1 ] , info [ i ] [ 2 ] = read_ints ( ) <NEWLINE> <DEDENT> print ( * solve ( info ) ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> Main ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> xyh = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ] <NEWLINE> xyh . sort ( key = lambda x : x [ 2 ] , reverse = True ) <NEWLINE> <NL> for cx in range ( 101 ) : <NEWLINE> <INDENT> for cy in range ( 101 ) : <NEWLINE> <INDENT> x , y , h = xyh [ 0 ] <NEWLINE> tmp_h = abs ( cy - y ) + abs ( cx - x ) + h <NEWLINE> H = np . zeros ( n , dtype = np . bool ) <NEWLINE> for i , a in enumerate ( xyh ) : <NEWLINE> <INDENT> H [ i ] = a [ 2 ] == max ( tmp_h - abs ( cx - a [ 0 ] ) - abs ( cy - a [ 1 ] ) , 0 ) <NEWLINE> <DEDENT> if np . all ( H ) : <NEWLINE> <INDENT> print ( cx , cy , tmp_h ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
import sys , re <NEWLINE> from collections import deque , defaultdict , Counter <NEWLINE> from math import ceil , sqrt , hypot , factorial , pi , sin , cos , tan , asin , acos , atan , radians , degrees , log2 , gcd <NEWLINE> from itertools import accumulate , permutations , combinations , combinations_with_replacement , product , groupby <NEWLINE> from operator import itemgetter , mul <NEWLINE> from copy import deepcopy <NEWLINE> from string import ascii_lowercase , ascii_uppercase , digits <NEWLINE> from bisect import bisect , bisect_left , insort , insort_left <NEWLINE> from heapq import heappush , heappop <NEWLINE> from functools import reduce <NEWLINE> def input ( ) : return sys . stdin . readline ( ) . strip ( ) <NEWLINE> def INT ( ) : return int ( input ( ) ) <NEWLINE> def MAP ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def LIST ( ) : return list ( map ( str , input ( ) . split ( ) ) ) <NEWLINE> def ZIP ( n ) : return zip ( * ( MAP ( ) for _ in range ( n ) ) ) <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> INF = float ( <STRING> ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <COMMENT> <NL> from decimal import * <NEWLINE> <NL> <COMMENT> <NL> N , M = MAP ( ) <NEWLINE> <NL> def make_divisors ( n ) : <COMMENT> <NEWLINE> <INDENT> divisors = [ ] <NEWLINE> for i in range ( 1 , int ( n ** 0.5 ) + 1 ) : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> divisors . append ( i ) <NEWLINE> if i != n // i : <NEWLINE> <INDENT> divisors . append ( n // i ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> divisors . sort ( ) <NEWLINE> return divisors <NEWLINE> <NL> <DEDENT> divisors = make_divisors ( M ) <NEWLINE> print ( divisors ) n = divisors [ bisect_left ( divisors , N ) ] <NEWLINE> print ( M // n ) <NEWLINE>
def make_divisors ( n ) : <NEWLINE> <INDENT> lower_divisors , upper_divisors = [ ] , [ ] <NEWLINE> i = 1 <NEWLINE> while i * i <= n : <NEWLINE> <INDENT> if n % i = 0 : <NEWLINE> <INDENT> lower_divisors . append ( i ) <NEWLINE> if i != n // i : <NEWLINE> <INDENT> upper_divisors . append ( n // i ) <NEWLINE> <DEDENT> <DEDENT> i += 1 <NEWLINE> <DEDENT> return lower_divisors + upper_divisors [ : : - 1 ] <NEWLINE> <DEDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> array = make_divisors ( m ) <NEWLINE> array . reverse ( ) <NEWLINE> for ele in array : <NEWLINE> <INDENT> if m // ele >= n : <NEWLINE> <INDENT> print ( ele ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT>
def divisor ( n ) : <NEWLINE> <INDENT> i = 1 <NEWLINE> res = [ ] <NEWLINE> for i in range ( 1 , n ** .5 + 1 ) <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> res . append ( i ) <NEWLINE> if n // i not in res : <NEWLINE> <INDENT> res . append ( n // i ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> res . sort ( reverse = True ) <NEWLINE> return res <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> md = divisor ( m ) <NEWLINE> for i in md : <NEWLINE> <INDENT> if i * n <= m : <NEWLINE> <INDENT> print ( i ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
ret = <STRING> <NEWLINE> for a in input ( ) : <NEWLINE> <INDENT> if a = <STRING> : <NEWLINE> <INDENT> ret += <STRING> <NEWLINE> <DEDENT> elif a = <STRING> : <NEWLINE> <INDENT> ret += <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ret += a <NEWLINE> <DEDENT> <DEDENT> print ( ret ) <NEWLINE>
a = input ( ) <NEWLINE> print ( a . replace ( 1 , 8 ) . replace ( 9 , 1 ) . replace ( 8 , 9 ) ) <NEWLINE>
s = input ( ) <NEWLINE> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> s [ i ] = <STRING> <NEWLINE> <DEDENT> elif s [ i ] == <STRING> : <NEWLINE> <INDENT> s [ i ] = <STRING> <NEWLINE> <DEDENT> <DEDENT> print ( s ) <NEWLINE>
def f ( c ) : <NEWLINE> <INDENT> if c == <STRING> : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> elif c == <STRING> : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return c <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> . join ( list ( map ( f , input ( ) ) ) ) ) <NEWLINE>
n = input ( ) <NEWLINE> for i in range ( 3 ) : <NEWLINE> <INDENT> if n [ i ] == <STRING> : <NEWLINE> <INDENT> n [ i ] = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> n [ i ] = <STRING> <NEWLINE> <DEDENT> <DEDENT> print ( int ( n ) ) <NEWLINE>
a = input ( ) <NEWLINE> for i in range ( len ( a ) ) : <NEWLINE> <INDENT> if a [ i ] == <STRING> : <NEWLINE> <INDENT> a [ i ] = <STRING> <NEWLINE> <DEDENT> elif a [ i ] == <STRING> : <NEWLINE> <INDENT> a [ i ] = <STRING> <NEWLINE> <DEDENT> <DEDENT> print ( a ) <NEWLINE>
a = input ( ) <NEWLINE> if a [ 0 ] == <STRING> : <NEWLINE> <INDENT> a [ 0 ] = <STRING> <NEWLINE> <DEDENT> if a [ 0 ] == <STRING> : <NEWLINE> <INDENT> a [ 0 ] == <STRING> <NEWLINE> <DEDENT> if a [ 1 ] == <STRING> : <NEWLINE> <INDENT> a [ 1 ] == <STRING> <NEWLINE> <DEDENT> if a [ 1 ] == <STRING> : <NEWLINE> <INDENT> a [ 1 ] == <STRING> <NEWLINE> <DEDENT> if a [ 2 ] == <STRING> : <NEWLINE> <INDENT> a [ 2 ] == <STRING> <NEWLINE> <DEDENT> if a [ 2 ] == <STRING> : <NEWLINE> <INDENT> a [ 2 ] == <STRING> <NEWLINE> <DEDENT> print ( a ) <NEWLINE>
s = list ( input ( ) ) <NEWLINE> l = [ ] <NEWLINE> for i in range ( s ) : <NEWLINE> <INDENT> if i == <STRING> : <NEWLINE> <INDENT> l . append ( <STRING> ) <NEWLINE> <DEDENT> elif i == <STRING> : <NEWLINE> <INDENT> l . append ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> l . append ( i ) <NEWLINE> <DEDENT> <DEDENT> for k in l : <NEWLINE> <INDENT> print ( k , end = <STRING> ) <NEWLINE> <DEDENT>
a = input ( ) <NEWLINE> pirnt ( a . replace ( <STRING> , <STRING> ) ) <NEWLINE>
n = input ( ) <NEWLINE> <NL> if n = 111 : <NEWLINE> <INDENT> print ( 999 ) <NEWLINE> <DEDENT> elif n = 119 : <NEWLINE> <INDENT> print ( 991 ) <NEWLINE> <DEDENT> elif n = 191 : <NEWLINE> <INDENT> print ( 919 ) <NEWLINE> <DEDENT> elif n = 199 : <NEWLINE> <INDENT> print ( 911 ) <NEWLINE> <DEDENT> elif n = 911 : <NEWLINE> <INDENT> print ( 199 ) <NEWLINE> <DEDENT> elif n = 919 : <NEWLINE> <INDENT> print ( 191 ) <NEWLINE> <DEDENT> elif n = 991 : <NEWLINE> <INDENT> print ( 199 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 111 ) <NEWLINE> <DEDENT>
<COMMENT> <NL> print ( input ( ) . replace ( 1 , x ) . replace ( 9.1 ) . replace ( x , 9 ) ) <NEWLINE>
print ( int ( input ( ) ) - N ) <NEWLINE>
a = input ( ) <NEWLINE> print ( a , replace ( <STRING> , <STRING> ) . replace ( <STRING> , <STRING> ) . replace ( <STRING> , <STRING> ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> print ( 100 * ( 10 - n [ 0 ] ) + 10 * ( 10 - n [ 1 ] ) + 10 - n [ 2 ] ) <NEWLINE>
n = input ( ) <NEWLINE> result = <STRING> <NEWLINE> for i in n : <NEWLINE> <INDENT> if i == 1 : <NEWLINE> <INDENT> result += 9 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> result += 1 <NEWLINE> <DEDENT> <DEDENT> print ( result ) <NEWLINE>
s = str ( input ( ) ) <NEWLINE> ans = <STRING> <NEWLINE> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> if s [ i ] == 1 : <NEWLINE> <INDENT> ans += 9 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = input ( ) <NEWLINE> <NL> <NL> ans = <STRING> <NEWLINE> <NL> if n [ 0 ] == <STRING> : <NEWLINE> ans = ans + <STRING> <NEWLINE> else : <NEWLINE> ans = ans + <STRING> <NEWLINE> <NL> if n [ 1 ] == <STRING> : <NEWLINE> ans = ans + <STRING> <NEWLINE> else : <NEWLINE> ans = ans + <STRING> <NEWLINE> <NL> <NL> if n [ 2 ] == <STRING> : <NEWLINE> ans = ans + <STRING> <NEWLINE> else : <NEWLINE> ans = ans + <STRING> <NEWLINE> <NL> <NL> print ( ans ) <NEWLINE>
S = input ( ) . replace ( <STRING> , <STRING> ) . replace ( <STRING> , <STRING> ) . replace ( <STRING> , 9 ) <NEWLINE> print ( S ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> def calculation ( lines ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <INDENT> n = lines [ 0 ] <NEWLINE> <NL> return [ n . replace ( <STRING> , <STRING> ) . replace ( <STRING> , <STRING> ) . replace ( <STRING> , <STRING> ) ] <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> def get_input_lines ( lines_count ) : <NEWLINE> <INDENT> lines = list ( ) <NEWLINE> for _ in range ( lines_count ) : <NEWLINE> <INDENT> lines . append ( input ( ) ) <NEWLINE> <DEDENT> return lines <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> def get_testdata ( pattern ) : <NEWLINE> <INDENT> if pattern == 1 : <NEWLINE> <INDENT> lines_input = [ <STRING> ] <NEWLINE> lines_export = [ <STRING> ] <NEWLINE> <DEDENT> if pattern == 2 : <NEWLINE> <INDENT> lines_input = [ <STRING> ] <NEWLINE> lines_export = [ <STRING> ] <NEWLINE> <DEDENT> return lines_input , lines_export <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> def get_mode ( ) : <NEWLINE> <INDENT> import sys <NEWLINE> args = sys . argv <NEWLINE> if len ( args ) == 1 : <NEWLINE> <INDENT> mode = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> mode = int ( args [ 1 ] ) <NEWLINE> <DEDENT> return mode <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> import time <NEWLINE> started = time . time ( ) <NEWLINE> mode = get_mode ( ) <NEWLINE> if mode == 0 : <NEWLINE> <INDENT> lines_input = get_input_lines ( 2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> lines_input , lines_export = get_testdata ( mode ) <NEWLINE> <NL> <DEDENT> lines_result = calculation ( lines_input ) <NEWLINE> <NL> for line_result in lines_result : <NEWLINE> <INDENT> print ( line_result ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
a = int ( input ( ) ) <NEWLINE> b = a % 100 <NEWLINE> c = a // 100 <NEWLINE> if b <= c * 11 : <NEWLINE> <INDENT> print ( c * 111 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ) c + 1 ) * 111 ) <NEWLINE> <DEDENT>
number = int ( input ( ) ) <NEWLINE> i = int ( number / 111 ) <NEWLINE> if number % 111 != 0 : <NEWLINE> <INDENT> i += 1 <NEWLINE> print ( i * 111 ) <NEWLINE> <NL> <NL> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = - ( - n // 111 ) <NEWLINE> if a = 10 : <NEWLINE> <INDENT> print ( 1111 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( a * 111 ) <NEWLINE> <DEDENT>
import math <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> e1 , e2 = map ( int , input ( ) . split ( ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> z = a // 9 <NEWLINE> af = a % 9 <NEWLINE> if af == 0 : <NEWLINE> <INDENT> print ( str ( 9 ) * ( z ) ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> print ( str ( af ) * ( z + 1 ) ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> X = set ( str ( N ) ) <NEWLINE> Y = len ( X ) <NEWLINE> if Y == 1 <NEWLINE> <INDENT> print ( N ) <NEWLINE> <DEDENT> if Y != 1 : <NEWLINE> <INDENT> Z = 0 <NEWLINE> for i in range ( 111 , 1000 , 111 ) : <NEWLINE> <INDENT> if N - i < 0 : <NEWLINE> <INDENT> Z += i <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( Z ) <NEWLINE> <DEDENT>
n = input ( ) <NEWLINE> for i in range ( int ( n ) , 1000 ) : <NEWLINE> <INDENT> if i . count ( n [ 0 ] ) == 3 : <NEWLINE> <INDENT> print ( i ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> for i in range ( 1 , 10 ) : <NEWLINE> <INDENT> if 100 * i + 10 * i + i = > n : <NEWLINE> <INDENT> print ( 100 * i + 10 * i + i ) <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> def calculation ( lines ) : <NEWLINE> <INDENT> N = int ( lines [ 0 ] ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> if N % 111 == 0 : <NEWLINE> <INDENT> result = N <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> result = - ( - N // 111 ) * 111 <NEWLINE> <NL> <DEDENT> return [ result ] <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> def get_input_lines ( lines_count ) : <NEWLINE> <INDENT> lines = list ( ) <NEWLINE> for _ in range ( lines_count ) : <NEWLINE> <INDENT> lines . append ( input ( ) ) <NEWLINE> <DEDENT> return lines <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> def get_testdata ( pattern ) : <NEWLINE> <INDENT> if pattern == 1 : <NEWLINE> <INDENT> lines_input = [ <STRING> ] <NEWLINE> lines_export = [ 111 ] <NEWLINE> <DEDENT> if pattern == 2 : <NEWLINE> <INDENT> lines_input = [ <STRING> ] <NEWLINE> lines_export = [ 222 ] <NEWLINE> <DEDENT> if pattern == 3 : <NEWLINE> <INDENT> lines_input = [ <STRING> ] <NEWLINE> lines_export = [ 777 ] <NEWLINE> <DEDENT> return lines_input , lines_export <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> def get_mode ( ) : <NEWLINE> <INDENT> import sys <NEWLINE> args = sys . argv <NEWLINE> if len ( args ) == 1 : <NEWLINE> <INDENT> mode = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> mode = int ( args [ 1 ] ) <NEWLINE> <DEDENT> return mode <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> import time <NEWLINE> started = time . time ( ) <NEWLINE> mode = get_mode ( ) <NEWLINE> if mode == 0 : <NEWLINE> <INDENT> lines_input = get_input_lines ( 2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> lines_input , lines_export = get_testdata ( mode ) <NEWLINE> <NL> <DEDENT> lines_result = calculation ( lines_input ) <NEWLINE> <NL> for line_result in lines_result : <NEWLINE> <INDENT> print ( line_result ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
from collections import Counter <NEWLINE> n = int ( input ( ) ) <NEWLINE> v = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if len ( set ( v ) ) == 1 : <NEWLINE> <INDENT> print ( n // 2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <NL> <INDENT> c1 = Counter ( v [ : : 2 ] ) <NEWLINE> c2 = Counter ( v [ 1 : : 2 ] ) <NEWLINE> o = c1 . most_common ( 2 ) <NEWLINE> e = c2 . most_common ( 2 ) <NEWLINE> o . append ( ( 0 , 0 ) ) <NEWLINE> e . append ( ( 0 , 0 ) ) <NEWLINE> if o [ 0 ] [ 0 ] == e [ 0 ] [ 0 ] : <NEWLINE> <INDENT> print ( min ( n - o [ 1 ] [ 1 ] - e [ 0 ] [ 1 ] , n - o [ 0 ] [ 1 ] - e [ 1 ] [ 1 ] ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( n - o ( 2 ) [ 0 ] [ 1 ] - e ( 2 ) [ 0 ] [ 1 ] ) <NEWLINE> <DEDENT> <DEDENT>
import itertools <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> list_A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> L , R = [ ] , [ ] <NEWLINE> A , B = [ [ - 1 , 0 ] , [ - 1 , 0 ] ] <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> if i % 2 == 0 : <NEWLINE> <INDENT> L . append ( list_A [ i ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> R . append ( list_A [ i ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> L = itertools . groupby ( L ) <NEWLINE> for key , group in L : <NEWLINE> <INDENT> A . append ( [ key , len ( list ( group ) ) ] ) <NEWLINE> <NL> <DEDENT> A . sort ( key = lambda x : x [ 1 ] , reverse = True ) <NEWLINE> <NL> R = itertools . groupby ( R ) <NEWLINE> for key , group in R : <NEWLINE> <INDENT> B . append ( [ key , len ( list ( group ) ) ] ) <NEWLINE> <NL> <DEDENT> B . sort ( key = lambda x : x [ 1 ] , reverse = True ) <NEWLINE> <NL> if A [ 0 ] [ 0 ] != B [ 0 ] [ 0 ] : <NEWLINE> <INDENT> print ( n - A [ 0 ] [ 1 ] - B [ 0 ] [ 1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( min ( n - A [ 1 ] [ 1 ] - B [ 0 ] [ 1 ] , n - A [ 0 ] [ 1 ] - B [ 1 ] [ 1 ] ) ) <NEWLINE> <DEDENT>
from collections import deque <NEWLINE> n = int ( input ( ) ) <NEWLINE> v = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> d1 = { } <NEWLINE> d2 = { } <NEWLINE> l1 = [ ] <NEWLINE> l2 = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> num = v [ i ] <NEWLINE> if i % 2 == 0 : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> d1 [ num ] += 1 <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> d1 [ num ] = 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> d2 [ num ] += 1 <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> d2 [ num ] = 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> for i in d1 : <NEWLINE> <INDENT> l1 . append ( [ d1 [ i ] , i ] ) <NEWLINE> <DEDENT> for i in d2 : <NEWLINE> <INDENT> l2 . append ( [ d2 [ i ] , i ] ) <NEWLINE> <DEDENT> l1 . sort ( reverse = True ) <NEWLINE> l2 . sort ( reverse = True ) <NEWLINE> ans = n <NEWLINE> if l1 [ 0 ] [ 1 ] != l2 [ 0 ] [ 1 ] : <NEWLINE> <INDENT> ans -= ( l1 [ 0 ] [ 0 ] + l2 [ 0 ] [ 0 ] ) <NEWLINE> <DEDENT> elif len ( l1 ) == 1 and len ( l2 ) == 1 : <NEWLINE> <INDENT> ans //= 2 <NEWLINE> <DEDENT> elif len ( l1 ) == 1 : <NEWLINE> <INDENT> ans -= l2 [ 1 ] [ 0 ] <NEWLINE> <DEDENT> elif len ( l2 ) == 1 <NEWLINE> <INDENT> ans -= l1 [ 1 ] [ 0 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a = ans - l1 [ 0 ] [ 0 ] - l2 [ 1 ] [ 0 ] <NEWLINE> b = ans - l1 [ 1 ] [ 0 ] - l2 [ 0 ] [ 0 ] <NEWLINE> ans = min ( a , b ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> v = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> d1 = [ 0 ] * ( 10 ** 5 + 1 ) <NEWLINE> d2 = [ 0 ] * ( 10 ** 5 + 1 ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> if i % 2 == 0 : <NEWLINE> <INDENT> d1 [ v [ i ] ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d2 [ v [ i ] ] += 1 <NEWLINE> <DEDENT> <DEDENT> assert n - max ( d1 ) - max ( d2 ) < 0 <NEWLINE> print ( n - max ( d1 ) - max ( d2 ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> * V , = map ( int , input ( ) . split ( ) ) <NEWLINE> import Counter from collections <NEWLINE> <NL> c1 = Counter ( V [ 0 : : 2 ] ) . most_common ( ) + [ ( 0 , 0 ) ] <NEWLINE> c2 = Counter ( V [ 1 : : 2 ] ) . most_common ( ) + [ ( 0 , 0 ) ] <NEWLINE> if c1 [ 0 ] [ 0 ] != c2 [ 0 ] [ 0 ] : <NEWLINE> <INDENT> print ( N - c1 [ 0 ] [ 1 ] - c2 [ 0 ] [ 1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( min ( N - c1 [ 0 ] [ 1 ] - c2 [ 1 ] [ 1 ] , N - c1 [ 1 ] [ 1 ] - c2 [ 0 ] [ 1 ] ) ) <NEWLINE> <DEDENT>
a , b , c = input ( ) <NEWLINE> if a < b : <NEWLINE> <INDENT> a , b = b , a <NEWLINE> <DEDENT> if b < c : <NEWLINE> <INDENT> b , c = c , b <NEWLINE> <DEDENT> if a < b : <NEWLINE> <INDENT> a , b = b , a <NEWLINE> <DEDENT> print ( 10 * a + b + c ) <NEWLINE>
a = list ( map ( int , input ( ) . split ) ) <NEWLINE> a = sorted ( a ) <NEWLINE> d = str ( a [ 2 ] ) + str ( a [ 1 ] ) <NEWLINE> print ( int ( d ) + a [ 0 ] ) <NEWLINE>
A , B , C = I ( ) <NEWLINE> if max ( A , B , C ) == A : <NEWLINE> <INDENT> print ( A * 10 + B + C ) <NEWLINE> <DEDENT> if max ( A , B , C ) == B : <NEWLINE> <INDENT> print ( B * 10 + A + C ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( C * 10 + A + B ) <NEWLINE> <DEDENT>
l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> l . sort ( ) <NEWLINE> a = list [ 2 ] * 10 + list [ 1 ] + list [ 2 ] <NEWLINE> print ( a ) <NEWLINE>
A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A . sort ( reverse = True ) <NEWLINE> <NL> print ( A [ 0 ] * 10 + A [ 1 ] + A [ 2 ] <NEWLINE>
A , B , C = input ( ) . split ( ) <NEWLINE> ichi = eval ( AB + C ) <NEWLINE> two = eval ( A + BC ) <NEWLINE> print ( max ( ichi , two ) ) <NEWLINE>
A , B , C = map ( int , input ( ) . split ( ) ) <NEWLINE> m = max ( A , B , C ) <NEWLINE> print ( m * 9 + sum ( A , B , C ) ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> def calculation ( lines ) : <NEWLINE> <COMMENT> <NL> <INDENT> a , b , c = list ( map ( int , lines [ 0 ] . split ( ) ) ) <NEWLINE> result = max ( a , b , c ) * 9 + a + b + c <NEWLINE> return [ result ] <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> def get_input_lines ( lines_count ) : <NEWLINE> <INDENT> lines = list ( ) <NEWLINE> for _ in range ( lines_count ) : <NEWLINE> <INDENT> lines . append ( input ( ) ) <NEWLINE> <DEDENT> return lines <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> def get_testdata ( pattern ) : <NEWLINE> <INDENT> if pattern == 1 : <NEWLINE> <INDENT> lines_input = [ <STRING> ] <NEWLINE> lines_export = [ 53 ] <NEWLINE> <DEDENT> if pattern == 2 : <NEWLINE> <INDENT> lines_input = [ <STRING> ] <NEWLINE> lines_export = [ 108 ] <NEWLINE> <DEDENT> if pattern == 3 : <NEWLINE> <INDENT> lines_input = [ <STRING> ] <NEWLINE> lines_export = [ 82 ] <NEWLINE> <DEDENT> return lines_input , lines_export <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> def get_mode ( ) : <NEWLINE> <INDENT> import sys <NEWLINE> args = sys . argv <NEWLINE> if len ( args ) == 1 : <NEWLINE> <INDENT> mode = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> mode = int ( args [ 1 ] ) <NEWLINE> <DEDENT> return mode <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> import time <NEWLINE> started = time . time ( ) <NEWLINE> mode = get_mode ( ) <NEWLINE> if mode == 0 : <NEWLINE> <INDENT> lines_input = get_input_lines ( 2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> lines_input , lines_export = get_testdata ( mode ) <NEWLINE> <NL> <DEDENT> lines_result = calculation ( lines_input ) <NEWLINE> <NL> for line_result in lines_result : <NEWLINE> <INDENT> print ( line_result ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
A , B , C = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> print ( max ( A * 10 + B + C , A + N * 10 + C ) ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> def calculation ( lines ) : <NEWLINE> <COMMENT> <NL> <INDENT> N , M , X , Y = list ( map ( int , lines [ 0 ] . split ( ) ) ) <NEWLINE> xs = list ( map ( int , lines [ 1 ] . split ( ) ) ) <NEWLINE> ys = list ( map ( int , lines [ 2 ] . split ( ) ) ) <NEWLINE> xs . append ( X ) <NEWLINE> ys . append ( Y ) <NEWLINE> max_x = max ( xs ) <NEWLINE> min_y = min ( ys ) <NEWLINE> if max_x < min_y : <NEWLINE> <INDENT> return [ <STRING> ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return [ <STRING> ] <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> def get_input_lines ( lines_count ) : <NEWLINE> <INDENT> lines = list ( ) <NEWLINE> for _ in range ( lines_count ) : <NEWLINE> <INDENT> lines . append ( input ( ) ) <NEWLINE> <DEDENT> return lines <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> def get_testdata ( pattern ) : <NEWLINE> <INDENT> if pattern == 1 : <NEWLINE> <INDENT> lines_input = [ <STRING> , <STRING> , <STRING> ] <NEWLINE> lines_export = [ <STRING> ] <NEWLINE> <DEDENT> if pattern == 2 : <NEWLINE> <INDENT> lines_input = [ <STRING> , <STRING> , <STRING> ] <NEWLINE> lines_export = [ <STRING> ] <NEWLINE> <DEDENT> if pattern == 3 : <NEWLINE> <INDENT> lines_input = [ <STRING> , <STRING> , <STRING> ] <NEWLINE> lines_export = [ <STRING> ] <NEWLINE> <DEDENT> return lines_input , lines_export <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> def get_mode ( ) : <NEWLINE> <INDENT> import sys <NEWLINE> args = sys . argv <NEWLINE> if len ( args ) == 1 : <NEWLINE> <INDENT> mode = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> mode = int ( args [ 1 ] ) <NEWLINE> <DEDENT> return mode <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> import time <NEWLINE> started = time . time ( ) <NEWLINE> mode = get_mode ( ) <NEWLINE> if mode == 0 : <NEWLINE> <INDENT> lines_input = get_input_lines ( 2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> lines_input , lines_export = get_testdata ( mode ) <NEWLINE> <NL> <DEDENT> lines_result = calculation ( lines_input ) <NEWLINE> <NL> for line_result in lines_result : <NEWLINE> <INDENT> print ( line_result ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n , m , X , Y = sorted ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> x = max ( [ X ] , max ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> y = min ( [ Y ] , min ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> print ( <STRING> if x < y else <STRING> ) <NEWLINE>
n , m , x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> xx = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> yy = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> xxx = max ( xx + list ( x ) ) <NEWLINE> yyy = min ( yy + list ( y ) ) <NEWLINE> if xxx < yyy : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
x = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> y = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> x . sort ( reverse = True ) <NEWLINE> y . sort ( ) <NEWLINE> <NL> <NL> flag = 0 <NEWLINE> for i in range ( X + 1 , Y + 1 ) : <NEWLINE> <INDENT> if x [ 0 ] <= i and y [ 0 ] > i : <NEWLINE> <INDENT> flag = 1 <NEWLINE> break <NEWLINE> <NL> <NL> <DEDENT> else : <NEWLINE> <INDENT> flag = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> if flag == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N , M , X , Y = map ( int , input ( ) . split ( ) ) <NEWLINE> ListX = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ListY = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ListX . sort ( ) <NEWLINE> ListX . sort ( ) <NEWLINE> threX = max ( X , List [ N - 1 ] ) <NEWLINE> threY = min ( Y , List [ 0 ] ) <NEWLINE> Z = threX + 1 <NEWLINE> if threY >= Z : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n , m , x , y = map ( list ( input ( ) . split ( ) ) ) <NEWLINE> a = map ( list ( input ( ) . split ( ) ) ) <NEWLINE> b = map ( list ( input ( ) . split ( ) ) ) <NEWLINE> max_x = max ( a ) <NEWLINE> max_y = max ( b ) <NEWLINE> max_x = max ( max_x , x ) <NEWLINE> max_y = max ( max_y , y ) <NEWLINE> <NL> if max_x < max_y : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N , M , X , Y = map ( int , input ( ) . split ( ) ) <NEWLINE> x = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> y = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> D = min ( y ) - max ( x ) <NEWLINE> if D >= 0 and max ( x ) + D <= min ( y ) <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
if __name__ == <STRING> : <NEWLINE> <INDENT> n , m , x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> X = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> Y = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> x_max = max ( X ) <NEWLINE> y_min = min ( Y ) <NEWLINE> <NL> flg = False <NEWLINE> for Z in range ( x + 1 , y + 1 ) : <NEWLINE> <INDENT> if x_max < Z and Z <= y_min : <NEWLINE> <INDENT> flg = True <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if flg : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
S = input ( ) <NEWLINE> T = input ( ) <NEWLINE> <NL> x = defaultdict ( list ) <NEWLINE> <NL> for i , t in enumerate ( T ) : <NEWLINE> <INDENT> x [ t ] . append ( S [ i ] ) <NEWLINE> <NL> <DEDENT> ok = True <NEWLINE> for k , v in x . items ( ) : <NEWLINE> <INDENT> a = v [ 0 ] <NEWLINE> for c in v : <NEWLINE> <INDENT> if c != a : <NEWLINE> <INDENT> ok = False <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if ok : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import collections <NEWLINE> a = list ( input ( ) ) <NEWLINE> b = list ( input ( ) ) <NEWLINE> A = collections . Counter ( a ) <NEWLINE> B = collections . Counter ( b ) <NEWLINE> Asort = sorted ( A . values ( ) ) <NEWLINE> Bsort = sorted ( B . values ( ) ) <NEWLINE> if list ( Asort . values ( ) ) == list ( Bsort . values ( ) ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> m = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> M = 10000 <NEWLINE> <NL> dp = [ [ 0 ] * ( m + 1 ) for i in range ( n + 1 ) ] <NEWLINE> <NL> for i in range ( n + 1 ) : <NEWLINE> <INDENT> dp [ i ] [ 0 ] = 1 <NEWLINE> <NL> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( 1 , m + 1 ) : <NEWLINE> <INDENT> if j - 1 - a [ i ] >= 0 : <NEWLINE> <INDENT> dp [ i + 1 ] [ j ] = ( dp [ i + 1 ] [ j - 1 ] + dp [ i ] [ j ] - dp [ i ] [ j - 1 - a [ i ] ] ) % M <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dp [ i + 1 ] [ j ] = ( dp [ i + 1 ] [ j - 1 ] + dp [ i ] [ j ] ) % M <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( dp ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <INDENT> def factorization ( n ) : <NEWLINE> <INDENT> arr = [ ] <NEWLINE> temp = n <NEWLINE> for i in range ( 2 , int ( - ( - n ** 0.5 // 1 ) ) + 1 ) : <NEWLINE> <INDENT> if temp % i == 0 : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> while temp % i == 0 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> temp //= i <NEWLINE> <DEDENT> arr . append ( [ i , cnt ] ) <NEWLINE> <DEDENT> <DEDENT> if temp != 1 : <NEWLINE> <INDENT> arr . append ( [ temp , 1 ] ) <NEWLINE> <NL> <DEDENT> if arr == [ ] and n != 1 : <NEWLINE> <INDENT> arr . append ( [ n , 1 ] ) <NEWLINE> <NL> <DEDENT> return arr <NEWLINE> <NL> mod = 10 ** 9 + 7 <NEWLINE> <NL> def cmb ( n , r , mod ) : <NEWLINE> if ( r < 0 or r > n ) : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> r = min ( r , n - r ) <NEWLINE> return g1 [ n ] * g2 [ r ] * g2 [ n - r ] % mod <NEWLINE> <NL> g1 = [ 1 , 1 ] <NEWLINE> g2 = [ 1 , 1 ] <NEWLINE> inverse = [ 0 , 1 ] <NEWLINE> for i in range ( 2 , N + 100 + 1 ) : <NEWLINE> g1 . append ( ( g1 [ - 1 ] * i ) % mod ) <NEWLINE> inverse . append ( ( - inverse [ mod % i ] * ( mod // i ) ) % mod ) <NEWLINE> g2 . append ( ( g2 [ - 1 ] * inverse [ - 1 ] ) % mod ) <NEWLINE> <NL> primes = factorization ( M ) <NEWLINE> <COMMENT> <NL> <NL> ans = 1 <NEWLINE> <NL> for p , cnt in primes : <NEWLINE> tmp = cmb ( N + cnt - 1 , N - 1 , mod ) <NEWLINE> ans *= tmp <NEWLINE> ans %= mod <NEWLINE> <NL> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> main ( ) <NEWLINE>
from collections import defaultdict <NEWLINE> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> d = defaultdict ( int ) <NEWLINE> for i in range ( 2 , floor ( sqrt ( M ) ) + 1 ) : <NEWLINE> <INDENT> while M % i == 0 : <NEWLINE> <INDENT> d [ i ] += 1 <NEWLINE> M //= i <NEWLINE> <DEDENT> <DEDENT> if M != 1 : <NEWLINE> <INDENT> d [ M ] += 1 <NEWLINE> <DEDENT> def comb ( n , k ) : <NEWLINE> <INDENT> if k == 0 : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> return comb ( n - 1 , k - 1 ) * n // k <NEWLINE> <DEDENT> ans = 1 <NEWLINE> for e in d . values ( ) : <NEWLINE> <INDENT> ans *= comb ( N + e - 1 , e ) <NEWLINE> <DEDENT> print ( ans % ( 10 ** 9 + 7 ) ) <NEWLINE>
a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> a . sort ( ) <NEWLINE> <NL> s = 0 <NEWLINE> i = 0 <NEWLINE> <NL> if sum ( a ) <= x : <NEWLINE> <INDENT> print ( n ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> elif min ( a ) > x : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> while s < x : <NEWLINE> <INDENT> s += a [ i ] <NEWLINE> i += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( i - 1 ) <NEWLINE>
n , x = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if A [ i ] > x : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x -= A [ i ] <NEWLINE> if i == N - 1 : <NEWLINE> <INDENT> print ( N - 1 ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
N , x = map ( int , input ( ) . split ( ) ) <NEWLINE> a = sorted ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> cnt = 0 <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> x -= a [ i ] <NEWLINE> if x < 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( cnt if x <= 0 else cnt - 1 ) <NEWLINE>
children = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> children . sort ( ) <NEWLINE> count = 0 <NEWLINE> c = 0 <NEWLINE> if x < children [ 0 ] : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> count += children [ i ] <NEWLINE> c += 1 <NEWLINE> if count == x : <NEWLINE> <INDENT> print ( c ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> elif count > x : <NEWLINE> <INDENT> print ( c - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( n - 1 ) <NEWLINE>
for i in range ( N ) : <NEWLINE> <INDENT> print ( i ) <NEWLINE> if x >= sort_a [ i ] : <NEWLINE> <INDENT> count += 1 <NEWLINE> x -= sort_a [ i ] <NEWLINE> <COMMENT> <NL> continue <NEWLINE> <DEDENT> break <NEWLINE> <DEDENT> print ( count ) <NEWLINE>
n , x = map ( int , input ( ) . split ( ) ) <NEWLINE> a = sort ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> s = 0 <NEWLINE> num = 0 <NEWLINE> for i in range ( len ( a ) ) : <NEWLINE> <INDENT> if x >= a [ i ] : <NEWLINE> <INDENT> x -= a [ i ] <NEWLINE> num += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( num ) <NEWLINE>
N , x = input ( ) . split ( ) <NEWLINE> A = input ( ) . split ( ) <NEWLINE> a = [ ] <NEWLINE> for i in range ( int ( N ) ) : <NEWLINE> <INDENT> a . append ( int ( A [ i ] ) ) <NEWLINE> <NL> <DEDENT> a . sort ( ) <NEWLINE> a . append ( 1 ) <NEWLINE> X = int ( x ) <NEWLINE> <NL> idx = 0 <NEWLINE> while X >= 0 : <NEWLINE> <INDENT> X = X - a [ idx ] <NEWLINE> idx += 1 <NEWLINE> <NL> <DEDENT> print ( idx - 1 ) <NEWLINE>
N , x = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a . sort ( ) <NEWLINE> <NL> a_sum = [ sum ( a [ : i + 1 ] ) for i in range ( len ( a ) ) ] <NEWLINE> <NL> for i , item in enumerate ( a_sum ) : <NEWLINE> <INDENT> if x < item : <NEWLINE> <INDENT> ans = i <NEWLINE> break <NEWLINE> <DEDENT> elif x == item : <NEWLINE> <INDENT> ans = i + 1 <NEWLINE> <DEDENT> elif x > item and i == len ( a_sum ) : <NEWLINE> <INDENT> ans = i <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL>
n , x = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> a . sort ( ) <NEWLINE> count = 0 <NEWLINE> <NL> for i in a : <NEWLINE> <INDENT> if x >= a [ min ] : <NEWLINE> <INDENT> x -= i <NEWLINE> count += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> pass <NEWLINE> <NL> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
n , x = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ar = a . sort ( reverse = True , key = int ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> x -= ar [ i ] <NEWLINE> if x < 0 : <NEWLINE> <INDENT> x += ar [ i ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> read = sys . stdin . buffer . read <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> readlines = sys . stdin . buffer . readlines <NEWLINE> import numpy as np <NEWLINE> <NL> @ jit <NEWLINE> def main ( n , x , a ) : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> for i in a : <NEWLINE> <INDENT> x -= i <NEWLINE> if x <= 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> elif i == a [ - 1 ] and x > 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> cnt += 1 <NEWLINE> <DEDENT> return cnt <NEWLINE> <NL> <DEDENT> n , x = map ( int , readline ( ) . split ( ) ) <NEWLINE> a = np . sort ( np . array ( readline ( ) . split ( ) , np . int64 ) ) <NEWLINE> print ( main ( n , x , a ) ) <NEWLINE>
<COMMENT> <NL> N , x = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> cou = 0 <NEWLINE> <NL> a . sort ( ) <NEWLINE> <NL> for i in a : <NEWLINE> <INDENT> if i > x : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> cou += 1 <NEWLINE> x -= i <NEWLINE> <NL> <DEDENT> while x > 0 : <NEWLINE> <INDENT> for i in a : <NEWLINE> <INDENT> if x % i == 0 : <NEWLINE> <INDENT> cou -= 1 <NEWLINE> break <NEWLINE> <DEDENT> while x > i : <NEWLINE> <INDENT> x -= i <NEWLINE> <DEDENT> cou -= 1 <NEWLINE> <DEDENT> <DEDENT> print ( cou ) <NEWLINE>
from collections import deque <NEWLINE> <NL> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> s = [ list ( input ( ) ) for i in range ( N ) ] <NEWLINE> <NL> S = [ ] <NEWLINE> for i in s : <COMMENT> <NEWLINE> <INDENT> if i == <STRING> : S . append ( 0 ) <NEWLINE> else : S . append ( 1 ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> R = [ list ( ) for _ in range ( N ) ] <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> C = [ [ 0 , 0 ] for _ in range ( N ) ] <NEWLINE> for _ in range ( M ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> R [ a - 1 ] . append ( b - 1 ) <NEWLINE> R [ b - 1 ] . append ( a - 1 ) <NEWLINE> C [ a - 1 ] [ S [ b - 1 ] ] += 1 <NEWLINE> C [ b - 1 ] [ S [ a - 1 ] ] += 1 <NEWLINE> <NL> <DEDENT> O = [ 0 ] * N <COMMENT> <NEWLINE> q = deque ( ) <COMMENT> <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if C [ i ] [ 0 ] * C [ i ] [ 1 ] == 0 : <COMMENT> <NEWLINE> <INDENT> q . append ( i ) <NEWLINE> O [ i ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> while q : <NEWLINE> <INDENT> x = q . popleft ( ) <NEWLINE> for v in R [ x ] : <NEWLINE> <INDENT> C [ v ] [ S [ x ] ] -= 1 <NEWLINE> if C [ v ] [ S [ x ] ] == 0 and O [ v ] != 0 : <NEWLINE> <INDENT> O [ v ] = 1 <NEWLINE> q . append ( v ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if sum ( O ) == N : <NEWLINE> <INDENT> answer = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> answer = <STRING> <NEWLINE> <NL> <DEDENT> print ( answer ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> for i in range ( 1 , 4 ) : <NEWLINE> <INDENT> if ( a * b * i ) % 2 != 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> exit ( ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE>
A , B = map ( int , input ( ) . input ( ) ) <NEWLINE> <NL> print ( <STRING> if A % 2 != 0 and B % 2 != 0 else <STRING> ) <NEWLINE>
a , b = map ( int , input ( ) ) <NEWLINE> if ( a * b ) % 2 == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
A , B = map ( int , input ( ) ) <NEWLINE> if A * B % 2 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> ri = lambda : int ( sys . stdin . readline ( ) ) <NEWLINE> <NL> print ( <STRING> if ri ( ) == 2 or ri ( ) == 2 else <STRING> ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if a % 2 == and b % 2 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
A , B = map ( int , input ( ) ) <NEWLINE> check = False <NEWLINE> for C in range ( 1 , 4 ) : <NEWLINE> <INDENT> if ( A * B * C ) % 2 == 1 : <NEWLINE> <INDENT> check = True <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> if check else <STRING> ) <NEWLINE>
A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> flg = True <NEWLINE> for i in range ( 1 , 4 ) : <NEWLINE> <INDENT> if ( A * B * i ) % 2 == 1 : <NEWLINE> <INDENT> flg = False <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if flg == False : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif == True : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b = int ( input ( ) ) <NEWLINE> for c in range ( 1 , 4 ) : <NEWLINE> <INDENT> if ( a * b * c ) % 2 == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( [ <STRING> , <STRING> ] [ A % 2 == 1 and B % 2 == 1 ] <NEWLINE>
N = int ( input ( ) ) <NEWLINE> W = [ input ( ) for _ in range ( N ) ] <NEWLINE> Ws = [ ] <NEWLINE> ans = <STRING> <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> Ws . append ( W [ i ] ) <NEWLINE> for j in range ( 1 , N + 1 ) <NEWLINE> <INDENT> if W [ i ] [ - 1 ] == W [ j ] [ 0 ] : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> break <NEWLINE> <NL> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> if len ( set ( W ) ) != len ( Ws ) : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> import collections <NEWLINE> N = int ( input ( ) ) <NEWLINE> Word_List = [ ] <NEWLINE> SP = <STRING> <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> CW = str ( input ( ) ) <NEWLINE> if i == 0 : <NEWLINE> <INDENT> Word_List . append ( CW ) <NEWLINE> SP = CW [ - 1 ] <NEWLINE> <DEDENT> elif SP != CW [ 0 ] : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> Word_List . append ( CW ) <NEWLINE> SP = CW [ - 1 ] <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> Word_List = collections . Counter ( Word_List ) ) <NEWLINE> if len ( Word_List ) != N : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = [ ] <NEWLINE> x = str ( input ( ) ) <NEWLINE> a [ 0 ] = x <NEWLINE> d = bool ( True ) <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> y = str ( input ) <NEWLINE> if x [ len ( x ) ] != y [ 0 ] : <NEWLINE> <INDENT> d = False <NEWLINE> <DEDENT> for i in range ( a . size ( ) ) : <NEWLINE> <INDENT> if y == a [ i ] : <NEWLINE> <INDENT> d = False <NEWLINE> <DEDENT> <DEDENT> a . append ( y ) <NEWLINE> <NL> <DEDENT> if d : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = [ input ( ) for _ in range ( int ( input ( ) ) ) ] ; if len ( set ( n ) ) != len ( n ) : print ( <STRING> ) ; exit ( ) <NEWLINE> print ( <STRING> [ all ( [ 1 if n [ i - 1 ] [ - 1 ] == n [ i ] [ 0 ] else 0 for i in range ( 1 , len ( n ) ) ] ) : : 2 ] ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( input ( ) for i in range ( N ) ) <NEWLINE> if len ( A ) == len ( set ( A ) ) : <NEWLINE> <INDENT> if all ( A [ i ] [ - 1 ] == A [ i + 1 ] [ 0 ] ) for i in range ( N - 2 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : print ( <STRING> ) <NEWLINE> <DEDENT> else : print ( <STRING> ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> alist = [ input ( ) for i in range ( n ) ] <NEWLINE> <NL> if len ( set ( alist ) ) == n : <NEWLINE> <INDENT> if all ( alist [ i ] [ - 1 ] == alist [ i + 1 ] [ 0 ] ) for i in range ( n - 1 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> W = [ ] <NEWLINE> w = <STRING> <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if i != 0 and w [ - 1 ] != str ( input ( ) ) [ 0 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> w = str ( input ( ) ) <NEWLINE> W . append ( w ) <NEWLINE> <DEDENT> <DEDENT> if len ( W ) != len ( list ( set ( W ) ) ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> m = dict ( ) <NEWLINE> <NL> prev = input ( ) <NEWLINE> m [ prev ] = True <NEWLINE> flg = True <NEWLINE> <NL> for _ in range ( N - 1 ) : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> flg = all ( flg , s not in m , prev [ len ( prev ) - 1 ] == s [ 0 ] ) <NEWLINE> m [ s ] = True <NEWLINE> prev = s <NEWLINE> <NL> <DEDENT> print ( <STRING> if flg else <STRING> ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> l = [ input ( ) for i in range ( n ) ] <NEWLINE> <NL> if l . most_common ( ) [ 0 ] [ 1 ] != 1 : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> l_head = [ i [ 0 ] for i in l ] <NEWLINE> l_tail = [ i [ - 1 ] for i in l ] <NEWLINE> if l_head == l_tail : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> w = input ( ) <NEWLINE> W_list = [ w ] <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> W = input ( ) <NEWLINE> if w [ - 1 ] == W [ 0 ] and W not in W . list : <NEWLINE> <INDENT> W_list . append ( w ) <NEWLINE> w = W <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
import sys <NEWLINE> import numpy as np <NEWLINE> import collections as cl <NEWLINE> import itertools as it <NEWLINE> <COMMENT> <NL> read = sys . stdin . buffer . read <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> readlines = sys . stdin . buffer . readlines <NEWLINE> sys . setrecursionlimit ( 100000 ) <NEWLINE> <NL> n = int ( readline ( ) ) <NEWLINE> w = list ( readlines ( ) . split ( ) ) <NEWLINE> dic = set ( ) <NEWLINE> <NL> for i in w : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> dic . append ( i ) <NEWLINE> continue <NEWLINE> <DEDENT> if i in dic or dic [ i - 1 ] [ - 1 ] != dic [ i ] [ 0 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> dic . append ( i ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> def calculation ( lines ) : <NEWLINE> <INDENT> N = int ( lines [ 0 ] ) <NEWLINE> <COMMENT> <NL> last_letter = lines [ 1 ] [ 0 ] <NEWLINE> values = list ( ) <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> line = lines [ i ] <NEWLINE> if line [ 0 ] != last_letter : <NEWLINE> <INDENT> return [ <STRING> ] <NEWLINE> <DEDENT> last_letter = line [ - 1 : ] <NEWLINE> if line in values : <NEWLINE> <INDENT> return [ <STRING> ] <NEWLINE> <DEDENT> values . append ( line ) <NEWLINE> <DEDENT> return [ <STRING> ] <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> def get_input_lines ( lines_count ) : <NEWLINE> <INDENT> lines = list ( ) <NEWLINE> for _ in range ( lines_count ) : <NEWLINE> <INDENT> lines . append ( input ( ) ) <NEWLINE> <DEDENT> return lines <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> def get_testdata ( pattern ) : <NEWLINE> <INDENT> if pattern == 1 : <NEWLINE> <INDENT> lines_input = [ <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> lines_export = [ <STRING> ] <NEWLINE> <DEDENT> if pattern == 2 : <NEWLINE> <INDENT> lines_input = [ <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> lines_export = [ <STRING> ] <NEWLINE> <DEDENT> if pattern == 3 : <NEWLINE> <INDENT> lines_input = [ <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> lines_export = [ <STRING> ] <NEWLINE> <DEDENT> if pattern == 4 : <NEWLINE> <INDENT> lines_input = [ <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> lines_export = [ <STRING> ] <NEWLINE> <DEDENT> return lines_input , lines_export <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> def get_mode ( ) : <NEWLINE> <INDENT> import sys <NEWLINE> args = sys . argv <NEWLINE> if len ( args ) == 1 : <NEWLINE> <INDENT> mode = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> mode = int ( args [ 1 ] ) <NEWLINE> <DEDENT> return mode <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> import time <NEWLINE> started = time . time ( ) <NEWLINE> mode = get_mode ( ) <NEWLINE> if mode == 0 : <NEWLINE> <INDENT> lines_input = get_input_lines ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> lines_input , lines_export = get_testdata ( mode ) <NEWLINE> <NL> <DEDENT> lines_result = calculation ( lines_input ) <NEWLINE> <NL> for line_result in lines_result : <NEWLINE> <INDENT> print ( line_result ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> keep = s [ - 1 ] <NEWLINE> s = input ( ) <NEWLINE> if keep != s [ 0 ] : <NEWLINE> <INDENT> ans = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> <DEDENT> print ( [ <STRING> , <STRING> ] [ ans ] ) <NEWLINE> <NL>
N = int ( input ( ) ) <NEWLINE> words = [ ] <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> words . append ( input ( ) ) <NEWLINE> <DEDENT> print ( <STRING> if all ( w [ i ] . startswith ( w [ i - 1 ] [ - 1 ] ) for i in range ( 1 , N ) ) and len ( set ( words ) ) == N else <STRING> ) <NEWLINE>
Row = int ( input ( ) ) <NEWLINE> flag = True <NEWLINE> List = [ ] <NEWLINE> for i in range ( Row ) : <NEWLINE> <INDENT> List . append ( int ( input ( ) ) ) <NEWLINE> <DEDENT> s_l = set ( List ) <NEWLINE> if len ( List ) != len ( s_l ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> for i in range ( Row - 1 ) : <NEWLINE> <INDENT> n = len ( List [ i ] ) - 1 <NEWLINE> if List [ i ] [ n ] != List [ i + 1 ] [ 0 ] : <NEWLINE> <INDENT> flag = False <NEWLINE> <DEDENT> <DEDENT> if flag : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import sys <NEWLINE> import math <NEWLINE> <NL> <NL> N , X = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if N == 1 : <NEWLINE> <INDENT> print ( A [ 0 ] - X ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> A . append ( X ) <NEWLINE> A = sorted ( A ) <NEWLINE> <NL> anslis = [ 0 ] * N <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> anslis [ i ] = A [ i + 1 ] - A [ i ] <NEWLINE> <NL> <DEDENT> g = anslis . pop ( 0 ) <NEWLINE> for c in cost_li : <NEWLINE> <INDENT> g = math . gcd ( g , c ) <NEWLINE> <NL> <DEDENT> print ( g ) <NEWLINE>
from functols import reduce <NEWLINE> from fractions import gcd <NEWLINE> N , X = map ( int , input ( ) . split ( ) ) <NEWLINE> x = [ abs ( X - int ( i ) ) for i in input ( ) . split ( ) ] <NEWLINE> print ( reduce ( gcd , x ) ) <NEWLINE>
import math <NEWLINE> from functools import reduce <NEWLINE> N , X = map ( int , input ( ) . slpit ( ) ) <NEWLINE> x = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> x [ i ] = abs ( x [ i ] - X ) <NEWLINE> <NL> <DEDENT> x = sorted ( x ) [ : : - 1 ] <NEWLINE> cnt = 0 <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> cnt = math . gcd ( cnt , x [ i ] ) <NEWLINE> <NL> <DEDENT> print ( cnt ) <NEWLINE>
<COMMENT> <NL> import math <NEWLINE> from functools import reduce <NEWLINE> <NL> def gcd ( * numbers ) : <NEWLINE> <INDENT> return reduce ( math . gcd , numbers ) <NEWLINE> <NL> <DEDENT> def gcd_list ( numbers ) : <NEWLINE> <INDENT> return reduce ( math . gcd , numbers ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> import sys <NEWLINE> <COMMENT> <NL> N , X = map ( int , input ( ) . split ( ) ) <NEWLINE> x = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <COMMENT> <NL> x_div = [ abs ( X - x [ 0 ] ) ] <COMMENT> <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> x_div . append ( abs ( x [ i ] - x [ i + 1 ] ) ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> if N == 1 : <NEWLINE> <INDENT> ans = abs ( x [ 0 ] - X ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = gcd_list ( x_div ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import fractions <NEWLINE> def gcdlist ( a ) : <NEWLINE> <INDENT> ans = a [ 0 ] <NEWLINE> for i in range ( 1 , len ( a ) ) : <NEWLINE> <INDENT> ans = fractions . gcd ( ans , a [ i ] ) <NEWLINE> <DEDENT> return ans <NEWLINE> <NL> <DEDENT> n , y = map ( int , input ( ) . split ( ) ) <NEWLINE> x = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> l = [ ] <NEWLINE> if y == 1 : <NEWLINE> <INDENT> print ( abs ( x [ 0 ] - 1 ) ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> for i in range ( n - 1 ) : <NEWLINE> <INDENT> l . append ( abs ( x [ i + 1 ] - x [ i ] ) ) <NEWLINE> <DEDENT> print ( gcdlist ( l ) ) <NEWLINE>
def mapt ( fn , * args ) : <NEWLINE> <INDENT> return list ( map ( fn , * args ) ) <NEWLINE> <NL> <NL> <DEDENT> def Input ( ) : <NEWLINE> <INDENT> return mapt ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> N , X = Input ( ) <NEWLINE> x = Input ( ) <NEWLINE> <NL> data = [ abs ( X - x [ i ] ) for i in range ( N ) ] <NEWLINE> ans = data [ 0 ] <NEWLINE> for i in range ( 1 , len ( data ) ) : <NEWLINE> <INDENT> ans = gcd ( data [ i ] , ans ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <NL> <DEDENT> main ( ) <NEWLINE>
import math <NEWLINE> from functools import reduce <NEWLINE> <NL> def gcd ( * numbers ) : <NEWLINE> <INDENT> return reduce ( math . gcd , numbers ) <NEWLINE> <NL> <DEDENT> N , X = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> x = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> x . append ( X ) <NEWLINE> x . sort ( ) <NEWLINE> <NL> res = [ abs ( x [ i + 1 ] - x [ i ] ) for i in range ( len ( x ) ) ] <NEWLINE> print ( gcd ( * res ) ) <NEWLINE>
<COMMENT> <NL> from collections import deque <NEWLINE> <NL> H , W = ( int ( x ) for x in input ( ) . split ( ) ) <NEWLINE> A = [ ] <NEWLINE> <NL> posOdd = deque ( ) <NEWLINE> i = 0 <NEWLINE> j = 0 <NEWLINE> <NL> while ( i , j ) != H - 1 , W - 1 : <NEWLINE> <INDENT> if i <NEWLINE> <NL> <DEDENT> for i in range ( H ) : <NEWLINE> <INDENT> row = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> A . append ( row ) <NEWLINE> <NL> <NL> <NL> <DEDENT> def move ( src , dst ) : <NEWLINE> <INDENT> ret = [ ] <NEWLINE> while src [ 0 ] != dst [ 0 ] : <NEWLINE> <INDENT> if src [ 0 ] > dst [ 0 ] : <NEWLINE> <INDENT> di = - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> di = 1 <NEWLINE> <DEDENT> ret . append ( ( src [ 0 ] , src [ 1 ] , src [ 0 ] + di , src [ 1 ] ) ) <NEWLINE> src [ 0 ] += di <NEWLINE> <DEDENT> return ret <NEWLINE> <NL> while src [ 1 ] != dst [ 1 ] : <NEWLINE> <INDENT> if src [ 1 ] > dst [ 1 ] : <NEWLINE> <INDENT> dj = - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dj = 1 <NEWLINE> <DEDENT> ret . append ( ( src [ 0 ] , src [ 1 ] , src [ 0 ] , src [ 1 ] + dj ) ) <NEWLINE> src [ 1 ] += dj <NEWLINE> <NL> <DEDENT> <DEDENT> moves = [ ] <NEWLINE> while len ( posOdd ) > 1 : <NEWLINE> <INDENT> dst = posOdd . popleft ( ) <NEWLINE> src = posOdd . popleft ( ) <NEWLINE> moves += move ( src , dst ) <NEWLINE> <NL> <DEDENT> print ( len ( moves ) ) <NEWLINE> for m in moves : <NEWLINE> <INDENT> print ( <STRING> . join ( ( str ( i + 1 ) for i in m ) ) ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> for a , b in ( list ( combinations ( range ( 1 , n + 1 ) , 2 ) ) ) : <NEWLINE> <INDENT> if ( a % 2 == 0 and b % 2 != 0 ) or ( b % 2 == 0 and a % 2 != 0 ) : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> main ( ) <NEWLINE>
k = int ( input ( ) ) <NEWLINE> if k % 2 == 0 : <NEWLINE> <INDENT> print ( int ( k * k / 2 / 2 ) ) <NEWLINE> <DEDENT> elif k % 2 == 1 : <NEWLINE> <INDENT> print ( int ( ( k / 2 ) * ( k // 2 ) / 2 ) <NEWLINE> <DEDENT>
K = int ( input ( ) ) <NEWLINE> print ( K // 2 * ( K // 2 + k % 2 ) ) <NEWLINE>
K = int ( input ( ) ) <NEWLINE> <NL> ev = K // 2 <NEWLINE> odd = k // 2 + K % 2 <NEWLINE> print ( ev * odd ) <NEWLINE>
a = int ( input ) <NEWLINE> if a % 2 == 0 : <NEWLINE> <INDENT> print ( a * a ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ( a - 1 ) * a ) <NEWLINE> <DEDENT>
a = input ( ) <NEWLINE> a = int ( a ) <NEWLINE> if a % 2 == 0 : <NEWLINE> <INDENT> print ( int ( ( a / 2 ) ** 2 ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( int ( a / 2 ) * 2 ( int ( int ( a / 2 ) + 1 ) ) ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> def calculation ( lines ) : <NEWLINE> <COMMENT> <NL> <INDENT> N = int ( lines [ 0 ] ) <NEWLINE> if N % 2 == 0 : <NEWLINE> <INDENT> ans = ( N / 2 ) ** 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = ( ( N + 1 ) / 2 * ( N - 1 ) / 2 ) <NEWLINE> <DEDENT> return [ int ( ans ) ] <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> def get_input_lines ( lines_count ) : <NEWLINE> <INDENT> lines = list ( ) <NEWLINE> for _ in range ( lines_count ) : <NEWLINE> <INDENT> lines . append ( input ( ) ) <NEWLINE> <DEDENT> return lines <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> def get_testdata ( pattern ) : <NEWLINE> <INDENT> if pattern == 1 : <NEWLINE> <INDENT> lines_input = [ <STRING> ] <NEWLINE> lines_export = [ 2 ] <NEWLINE> <DEDENT> if pattern == 2 : <NEWLINE> <INDENT> lines_input = [ <STRING> ] <NEWLINE> lines_export = [ 9 ] <NEWLINE> <DEDENT> if pattern == 3 : <NEWLINE> <INDENT> lines_input = [ <STRING> ] <NEWLINE> lines_export = [ 30 ] <NEWLINE> <DEDENT> if pattern == 4 : <NEWLINE> <INDENT> lines_input = [ <STRING> ] <NEWLINE> lines_export = [ 625 ] <NEWLINE> <DEDENT> return lines_input , lines_export <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> def get_mode ( ) : <NEWLINE> <INDENT> import sys <NEWLINE> args = sys . argv <NEWLINE> if len ( args ) == 1 : <NEWLINE> <INDENT> mode = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> mode = int ( args [ 1 ] ) <NEWLINE> <DEDENT> return mode <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> mode = get_mode ( ) <NEWLINE> if mode == 0 : <NEWLINE> <INDENT> lines_input = get_input_lines ( 2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> lines_input , lines_export = get_testdata ( mode ) <NEWLINE> <NL> <DEDENT> lines_result = calculation ( lines_input ) <NEWLINE> <NL> for line_result in lines_result : <NEWLINE> <INDENT> print ( line_result ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> if n % 2 == 0 : <NEWLINE> <INDENT> print ( ( n // 2 ) * ( n // 2 + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ( n // 2 ) ** 2 ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> print ( ( k // 2 ) * ( ( k + 1 ) // 2 ) ) <NEWLINE>
a = int ( input ( ) ) <NEWLINE> if a % 2 == 0 : <NEWLINE> <INDENT> ans = ( a / 2 ) ** 2 <NEWLINE> return <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = ( ( a - 1 ) / 2 ) * ( ( a + 1 ) / 2 ) <NEWLINE> return <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
Dist = abs ( y1 - y2 ) ** 2 + abs ( x1 - x2 ) ** 2 <NEWLINE> dist = Dist ** 0.5 <NEWLINE> if x2 >= x1 and y2 >= y1 : <NEWLINE> <INDENT> x3 = x2 - abs ( y2 - y1 ) <NEWLINE> x4 = x1 - abs ( y2 - y1 ) <NEWLINE> y3 = y2 + abs ( x2 - x1 ) <NEWLINE> y4 = y1 + abs ( x2 - x1 ) <NEWLINE> <DEDENT> elif x2 < x1 and y2 >= y1 : <NEWLINE> <INDENT> x3 = x2 - abs ( y2 - y1 ) <NEWLINE> x4 = x1 - abs ( y2 - y1 ) <NEWLINE> y3 = y2 - abs ( x2 - x1 ) <NEWLINE> y4 = y1 - abs ( x2 - x1 ) <NEWLINE> <DEDENT> elif x2 < x1 and y1 >= y2 : <NEWLINE> <INDENT> x3 = x2 + abs ( y2 - y1 ) <NEWLINE> x4 = x1 + abs ( y2 - y1 ) <NEWLINE> y3 = y2 - abs ( x2 - x1 ) <NEWLINE> y4 = y1 - abs ( x2 - x1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x3 = x2 + abs ( y2 - y1 ) <NEWLINE> x4 = x1 + abs ( y2 - y1 ) <NEWLINE> y3 = y2 + abs ( x2 - x1 ) <NEWLINE> y4 = y1 + abs ( x2 - x1 ) <NEWLINE> <DEDENT> print ( x3 , y3 , x4 , y4 ) <NEWLINE>
x1 , y1 , x2 , y2 = map ( int , input ( ) . split ( ) ) <NEWLINE> nx = x2 <NEWLINE> ny = y2 <NEWLINE> l = [ ] <NEWLINE> for i in range ( 2 ) : <NEWLINE> <INDENT> dx , dy = - dy , dx <NEWLINE> nx += dx <NEWLINE> ny += dy <NEWLINE> l . append ( nx ) <NEWLINE> l . append ( ny ) <NEWLINE> <DEDENT> print ( l [ 0 ] , l [ 1 ] , l [ 2 ] , l [ 3 ] ) <NEWLINE>
x1 , y1 , x2 , y2 = map ( int , input ( ) . split ( ) ) <NEWLINE> dx = x2 - x1 <NEWLINE> dy = y2 - y1 <NEWLINE> <NL> x3 = x2 - dy <NEWLINE> y3 = y2 + dx <NEWLINE> x4 = x3 - dx <NEWLINE> y4 = y3 - dy <NEWLINE> <NL> print ( x3 , y3 , x4 , y4 <NEWLINE>
n , k = map ( int , input ( ) ) <NEWLINE> candidOdd = 0 <NEWLINE> candidEven = 0 <NEWLINE> candidEven2 = 0 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if k % 2 == 1 : <NEWLINE> <INDENT> if i % k == 0 : <NEWLINE> <INDENT> candidOdd += 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if i % k == 0 : <NEWLINE> <INDENT> candidEven += 1 <NEWLINE> <DEDENT> elif i % k == ( k / 2 ) : <NEWLINE> <INDENT> candidEven2 += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( candidOdd ** 3 + candidEven ** 3 + candidEven2 ** 3 ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> return a - b + 1 <NEWLINE>
print ( int ( input ) + 1 - int ( input ( ) ) ) <NEWLINE>
n , i = map ( int , input . split ( ) ) <NEWLINE> print ( n - i + 1 ) <NEWLINE>
a , b = map ( int , input ( ) ) <NEWLINE> print ( int ( a - b + 1 ) ) <NEWLINE>
a , b = input ( ) . split ( ) <NEWLINE> print ( int ( a - b + 1 ) ) <NEWLINE>
n , i = map ( int , input ( ) ) <NEWLINE> print ( n - i + 1 ) <NEWLINE>
H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> grid = [ list ( str ( input ( ) ) ) for _ in range ( H ) ] <NEWLINE> <NL> def elim ( grid ) : <NEWLINE> <INDENT> grid_after = [ ] <NEWLINE> for i in range ( H ) : <NEWLINE> <INDENT> gset = list ( set ( grid [ i ] ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> if gset [ 0 ] != <STRING> : <NEWLINE> <INDENT> grid_after . append ( grid [ i ] ) <NEWLINE> <DEDENT> <DEDENT> return grid_after <NEWLINE> <NL> <DEDENT> def transpose ( grid_after ) : <NEWLINE> <NL> <INDENT> H1 = len ( grid_after ) <NEWLINE> W1 = len ( grid_after [ 0 ] [ : ] ) <NEWLINE> gridT = [ [ <STRING> ] * H1 for _ in range ( W1 ) ] <NEWLINE> for i in range ( W1 ) : <NEWLINE> <INDENT> for j in range ( H1 ) : <NEWLINE> <INDENT> gridT [ i ] [ j ] = grid_after [ j ] [ i ] <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> return gridT <NEWLINE> <NL> <DEDENT> grid_after = elim ( grid ) <NEWLINE> <NL> gridT1 = transpose ( grid_after ) <NEWLINE> <COMMENT> <NL> grid_after2 = elim ( gridT1 ) <NEWLINE> <COMMENT> <NL> gridT2 = transpose ( grid_after2 ) <NEWLINE> <COMMENT> <NL> for i in gridT2 : <NEWLINE> <INDENT> print ( * i , sep = <STRING> ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> def calculation ( lines ) : <NEWLINE> <INDENT> N , W = list ( map ( int , lines [ 0 ] . split ( ) ) ) <NEWLINE> masus = list ( ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> line = lines [ i + 1 ] <NEWLINE> if line != <STRING> * W : <NEWLINE> <INDENT> masus . append ( line ) <NEWLINE> <DEDENT> <DEDENT> for w in range ( W ) : <NEWLINE> <INDENT> flag = True <NEWLINE> for masu in masus : <NEWLINE> <INDENT> if masu [ w ] == <STRING> : <NEWLINE> <INDENT> flag = False <NEWLINE> <DEDENT> <DEDENT> if flag : <NEWLINE> <INDENT> for i in range ( len ( masus ) ) : <NEWLINE> <INDENT> masus [ i ] = masus [ i ] [ : w ] + <STRING> + masus [ i ] [ w + 1 : ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> for i in range ( len ( masus ) ) : <NEWLINE> <INDENT> masus [ i ] = masus [ i ] . replace ( <STRING> , <STRING> ) <NEWLINE> <DEDENT> return masus <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> def get_input_lines ( lines_count ) : <NEWLINE> <INDENT> lines = list ( ) <NEWLINE> for _ in range ( lines_count ) : <NEWLINE> <INDENT> lines . append ( input ( ) ) <NEWLINE> <DEDENT> return lines <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> def get_testdata ( pattern ) : <NEWLINE> <INDENT> if pattern == 1 : <NEWLINE> <INDENT> lines_input = [ <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> lines_export = [ <STRING> , <STRING> , <STRING> ] <NEWLINE> <DEDENT> if pattern == 2 : <NEWLINE> <INDENT> lines_input = [ <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> lines_export = [ <STRING> , <STRING> , <STRING> ] <NEWLINE> <DEDENT> if pattern == 3 : <NEWLINE> <INDENT> lines_input = [ <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> lines_export = [ <STRING> ] <NEWLINE> <DEDENT> if pattern == 4 : <NEWLINE> <INDENT> lines_input = [ <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> lines_export = [ <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> <DEDENT> return lines_input , lines_export <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> def get_mode ( ) : <NEWLINE> <INDENT> import sys <NEWLINE> args = sys . argv <NEWLINE> if len ( args ) == 1 : <NEWLINE> <INDENT> mode = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> mode = int ( args [ 1 ] ) <NEWLINE> <DEDENT> return mode <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> mode = get_mode ( ) <NEWLINE> if mode == 0 : <NEWLINE> <INDENT> lines_input = get_input_lines ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> lines_input , lines_export = get_testdata ( mode ) <NEWLINE> <NL> <DEDENT> lines_result = calculation ( lines_input ) <NEWLINE> <NL> for line_result in lines_result : <NEWLINE> <INDENT> print ( line_result ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> l = [ ] <NEWLINE> ll = [ [ True for i in range ( w ) ] for j in range ( h ) ] <NEWLINE> for _ in range ( h ) : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> cells = list ( s ) <NEWLINE> <COMMENT> <NL> l . append ( cells ) <NEWLINE> <NL> <COMMENT> <NL> <NL> <DEDENT> for h_i in range ( h ) : <NEWLINE> <INDENT> flag = True <NEWLINE> for w_i in range ( w ) : <NEWLINE> <COMMENT> <NL> <INDENT> if l [ h_i ] [ w_i ] == <STRING> : <NEWLINE> <INDENT> flag = False <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if flag : <NEWLINE> <INDENT> for w_i in range ( w ) : <NEWLINE> <INDENT> ll [ h_i ] [ w_i ] = False <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for w_i in range ( w ) : <NEWLINE> <INDENT> flag = True <NEWLINE> for h_i in range ( h ) : <NEWLINE> <COMMENT> <NL> <INDENT> if l [ h_i ] [ w_i ] == <STRING> : <NEWLINE> <INDENT> flag = False <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if flag : <NEWLINE> <INDENT> for h_i in range ( h ) : <NEWLINE> <INDENT> ll [ h_i ] [ w_i ] = False <NEWLINE> <NL> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> for i in range ( h ) : <NEWLINE> <INDENT> lll = [ ] a <NEWLINE> for j in range ( w ) : <NEWLINE> <COMMENT> <NL> <INDENT> if ll [ i ] [ j ] : <NEWLINE> <INDENT> lll . append ( l [ i ] [ j ] ) <NEWLINE> <DEDENT> <DEDENT> if len ( lll ) > 0 : <NEWLINE> <INDENT> print ( <STRING> . join ( lll ) ) <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> a = [ ] <COMMENT> <NEWLINE> for i in range ( h ) : <NEWLINE> <INDENT> x = input ( ) . split ( ) <NEWLINE> a . append ( x ) <NEWLINE> <NL> <DEDENT> h1 = [ ] <NEWLINE> for i in range ( h ) : <NEWLINE> <INDENT> if a [ i ] == [ <STRING> ] * w : <NEWLINE> <INDENT> h1 . append ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> w1 = [ ] <NEWLINE> for i in range ( w ) : <NEWLINE> <INDENT> flag = 0 <NEWLINE> for j in range ( h ) : <NEWLINE> <INDENT> if a [ j ] [ i ] == <STRING> : <NEWLINE> <INDENT> flag = 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if flag == 0 : <NEWLINE> <INDENT> w1 . append ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> ans = [ ] <NEWLINE> for i in range ( h ) : <NEWLINE> <INDENT> if i not in h1 : <NEWLINE> <INDENT> r = [ ] <NEWLINE> for j in range ( w ) : <NEWLINE> <INDENT> r . append ( a [ i ] [ j ] ) <NEWLINE> <DEDENT> ans . append ( r ) <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( lens ( ans ) ) : <NEWLINE> <INDENT> print ( <STRING> . join ( ans [ i ] ) ) <NEWLINE> <DEDENT>
H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> mass = [ list ( input ( ) ) for _ in range ( H ) ] <NEWLINE> <NL> for i in range ( H ) : <NEWLINE> <INDENT> if <STRING> not in mass [ i ] : <NEWLINE> <INDENT> mass . pop ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> H = len ( mass ) <NEWLINE> <NL> new_mass = [ [ ] for _ in range ( W ) ] <NEWLINE> <NL> for j in mass : <NEWLINE> <INDENT> for i , k in enumerate ( j ) : <NEWLINE> <INDENT> new_mass [ i ] . append ( k ) <NEWLINE> <NL> <DEDENT> <DEDENT> for l in range ( W ) : <NEWLINE> <INDENT> if <STRING> not in new_mass [ l ] : <NEWLINE> <INDENT> new_mass . pop ( l ) <NEWLINE> <NL> <DEDENT> <DEDENT> mass = [ [ ] for _ in range ( H ) ] <NEWLINE> <NL> for n in new_mass : <NEWLINE> <INDENT> for i , m in enumerate ( n ) : <NEWLINE> <INDENT> mass [ i ] . append ( m ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( mass ) <NEWLINE>
import sys <NEWLINE> import numpy as np <NEWLINE> <NL> rm = lambda : map ( int , sys . stdin . readline ( ) . split ( ) ) <NEWLINE> rl = lambda : list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) <NEWLINE> <NL> h , w = rm ( ) <NEWLINE> li = np . array ( [ np . array ( rl ( ) ) for _ in range ( h ) ] ) <NEWLINE> li2 = np . array ( [ ] ) <NEWLINE> li3 = np . array ( [ ] ) <NEWLINE> for i in li : <NEWLINE> <INDENT> if <STRING> not in i : <NEWLINE> <INDENT> li2 . append ( i ) <NEWLINE> <DEDENT> <DEDENT> li2 = li2 . T <NEWLINE> for i in li2 : <NEWLINE> <INDENT> if <STRING> not in i : <NEWLINE> <INDENT> li3 . append ( i ) <NEWLINE> <DEDENT> <DEDENT> for i in li3 . T : <NEWLINE> <INDENT> print ( <STRING> . join ( i ) ) <NEWLINE> <DEDENT>
<COMMENT> <NL> from resolve import resolve <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> import sys <NEWLINE> from io import StringIO <NEWLINE> import unittest <NEWLINE> <NL> <NL> class TestClass ( unittest . TestCase ) : <NEWLINE> <INDENT> def assertIO ( self , input , output ) : <NEWLINE> <INDENT> stdout , stdin = sys . stdout , sys . stdin <NEWLINE> sys . stdout , sys . stdin = StringIO ( ) , StringIO ( input ) <NEWLINE> resolve ( ) <NEWLINE> sys . stdout . seek ( 0 ) <NEWLINE> out = sys . stdout . read ( ) [ : - 1 ] <NEWLINE> sys . stdout , sys . stdin = stdout , stdin <NEWLINE> self . assertEqual ( out , output ) <NEWLINE> <NL> <DEDENT> def test__1 ( self ) : <NEWLINE> <INDENT> input = <STRING> <NEWLINE> output = <STRING> <NEWLINE> self . assertIO ( input , output ) <NEWLINE> <NL> <DEDENT> def test__2 ( self ) : <NEWLINE> <INDENT> input = <STRING> <NEWLINE> output = <STRING> <NEWLINE> self . assertIO ( input , output ) <NEWLINE> <NL> <DEDENT> def test__3 ( self ) : <NEWLINE> <INDENT> input = <STRING> <NEWLINE> output = <STRING> <NEWLINE> self . assertIO ( input , output ) <NEWLINE> <NL> <DEDENT> def test__4 ( self ) : <NEWLINE> <INDENT> input = <STRING> <NEWLINE> output = <STRING> <NEWLINE> self . assertIO ( input , output ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> unittest . main ( ) <NEWLINE> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ls = [ ] <NEWLINE> for i in range ( n - k + 1 ) : <NEWLINE> <INDENT> a = l [ i ] <NEWLINE> b = l [ i + k - 1 ] <NEWLINE> <INDENT> ls . append ( min ( abs ( a ) + abs ( a - b ) , abs ( b ) + abs ( a - b ) ) ) <NEWLINE> <DEDENT> <DEDENT> print ( min ( ls ) ) <NEWLINE>
from collections import deque <NEWLINE> <NL> N , K = map ( int , input ( ) . strip ( ) . split ( ) ) <NEWLINE> x = list ( map ( int , input ( ) . strip ( ) . split ( ) ) ) <NEWLINE> inf = 10 * 8 <NEWLINE> <NL> l = inf <NEWLINE> dp = x [ N - K : N - 1 ] <NEWLINE> i = 0 <NEWLINE> while N - K - i >= 0 : <NEWLINE> <INDENT> if dp [ 0 ] >= 0 : <NEWLINE> <INDENT> tmp = dp [ K - 1 ] <NEWLINE> <DEDENT> elif dp [ K - 1 ] <= 0 : <NEWLINE> <INDENT> tmp = - dp [ 0 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if dp [ K - 1 ] >= dp [ 0 ] : <NEWLINE> <INDENT> tmp = dp [ 0 ] * 2 + dp [ K - 1 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> tmp = dp [ K - 1 ] * 2 + dp [ 0 ] <NEWLINE> <DEDENT> <DEDENT> l = min ( l , tmp ) <NEWLINE> i += 1 <NEWLINE> if N - K - i < 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dp . appendleft ( x [ N - K - i ] ) <NEWLINE> dp . pop ( ) <NEWLINE> <DEDENT> <DEDENT> print ( l ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> x = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> st = 0 <NEWLINE> m = 3 * 10 ** 8 <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> if x [ i ] < 0 and x [ i + 1 ] >= 0 : <NEWLINE> <INDENT> st = i + 1 <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( n - k + 2 ) : <NEWLINE> <INDENT> mi = x [ k + i - 1 ] - x [ i ] + min ( abs ( x [ k + i - 1 ] ) , abs ( x [ i ] ) ) <NEWLINE> print ( x [ k + i - 1 ] , x [ i ] , mi ) <NEWLINE> if k + i < st or i > st : continue <NEWLINE> if mi < m : m = mi <NEWLINE> <DEDENT> print ( m ) <NEWLINE>
N , K = ( int ( i ) for i in input ( ) . split ( ) ) <NEWLINE> x = ( int ( i ) for i in input ( ) . split ( ) ) <NEWLINE> i = 0 <NEWLINE> t_min = float ( <STRING> ) <NEWLINE> while i + K <= N : <NEWLINE> <INDENT> left = abs ( x [ i ] ) + abs ( x [ i + K - 1 ] - x [ i ] ) <NEWLINE> right = abs ( x [ i + K - 1 ] ) + abs ( x [ i + K - 1 ] - x [ i ] ) <NEWLINE> if min ( left , right ) < t_min : <NEWLINE> <INDENT> t_min = min ( left , right ) <NEWLINE> <DEDENT> i += 1 <NEWLINE> <DEDENT> print ( t_min ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> a , b = map ( int , inptut ( ) . split ( ) ) <NEWLINE> print ( ( a - 1 ) * ( b - 1 ) ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> def main ( ) : <NEWLINE> <NL> <INDENT> N = int ( input ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> if i % 2 == 1 : <NEWLINE> <NL> <INDENT> count = 0 <NEWLINE> <NL> for j in range ( 1 , i + 1 ) : <NEWLINE> <INDENT> if i % j == 0 : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> if count == 8 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
ans = ( A * B ) - ( A + B - 1 ) <NEWLINE> <NL> print ( ans ) <NEWLINE>
a , b = [ int ( i ) for i in input . split ( ) ] <NEWLINE> print ( ( a - 1 ) * ( b - 1 ) ) <NEWLINE>
import numpy as np <NEWLINE> AB = np . prod ( np . array ( list ( map ( int , input ( ) ) ) ) ) <NEWLINE> print ( AB ) <NEWLINE>
a , b = map ( int , input ( ) . split ) <NEWLINE> print ( a * b - ( a + b - 1 ) ) <NEWLINE>
A , B = map ( int ( input ( ) . split ( ) ) ) <NEWLINE> ans = ( A - 1 ) * ( B - 1 ) <NEWLINE> print ( ans ) <NEWLINE>
print ( ( int ( input ( ) ) - 1 ) * ( int ( input ( ) ) - 1 ) ) <NEWLINE>
<COMMENT> <NL> a , b = map ( str , input ( ) . split ( ) ) <NEWLINE> <COMMENT> <NL> ans = ( a - 1 ) * ( b - 1 ) <NEWLINE> <NL> print ( ans ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> print ( ( a - 1 ) ( b - 1 ) ) <NEWLINE>
n , m = input ( ) . split ( <STRING> ) <NEWLINE> m = int ( m ) <NEWLINE> n = int ( n ) <NEWLINE> multi = ( m * n ) - ( m + n ) + 1 <NEWLINE> print ( multi ) <NEWLINE>
a , b = map ( int , input ( ) ) <NEWLINE> print ( str ( a * b - a - b + 1 ) ) <NEWLINE>
<NL> def solve ( ) : <NEWLINE> <INDENT> ans = 0 <NEWLINE> n = int ( input ( ) ) <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> div_list = [ ] <NEWLINE> for j in range ( 1 , int ( i ** 0.5 ) + 1 ) : <NEWLINE> <INDENT> if i % j != 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if i // j == j : <NEWLINE> <INDENT> div_list . append ( j ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> div_list . append ( i // j ) <NEWLINE> div_list . append ( j ) <NEWLINE> <DEDENT> <DEDENT> if len ( div_list ) == 8 : <NEWLINE> <INDENT> ans = += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> solve ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> count = 0 <NEWLINE> for j in range ( i ) : <NEWLINE> <INDENT> if i % j == 0 : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> if count == 9 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<NL> def yakusu ( x ) : <NEWLINE> <INDENT> A = [ ] <NEWLINE> for i in range ( 1 , x + 1 ) : <NEWLINE> <INDENT> if x % i == 0 : <NEWLINE> <INDENT> A . append ( ) <NEWLINE> <DEDENT> <DEDENT> return ( len ( A ) ) <NEWLINE> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> <NL> print ( yakusu ( n ) ) <NEWLINE>
a = int ( input ( ) ) <NEWLINE> if a < 105 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> elif 105 <= a < 135 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> elif 135 <= a < 165 : <NEWLINE> <INDENT> print ( 2 ) <NEWLINE> <DEDENT> elif 165 <= a < 189 : <NEWLINE> <INDENT> print ( 3 ) <NEWLINE> <DEDENT> elif : 189 <= a : <NEWLINE> <INDENT> print ( 4 ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> odd = [ ] <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> if i % 2 != 0 : <NEWLINE> <INDENT> odd . append ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> if N < 104 : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> elif N = 105 : <NEWLINE> <INDENT> ans = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = 1 <NEWLINE> for i in range ( 106 , N + 1 ) : <NEWLINE> <INDENT> if i % 2 != 0 : <NEWLINE> <INDENT> tmp = 0 <NEWLINE> for j in odd : <NEWLINE> <INDENT> if i % j == 0 : <NEWLINE> <INDENT> tmp = + 1 <NEWLINE> <DEDENT> <DEDENT> if tmp == 8 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> cnt = 0 <NEWLINE> <NL> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if i % j = 0 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> if ans = 8 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE> <NL>
in_num = int ( input ( ) ) <NEWLINE> check_num = 0 <NEWLINE> ans_counter = 0 <NEWLINE> <NL> while check_num <= in_num : <NEWLINE> <INDENT> i = 1 <NEWLINE> div_counter = 0 <NEWLINE> while i < check_num / 2 : <NEWLINE> <INDENT> if check_num % i == 0 : <NEWLINE> <INDENT> div_counter += 1 <NEWLINE> <DEDENT> i += 2 <NEWLINE> <DEDENT> if div_counter == 8 : <NEWLINE> <INDENT> ans_counter += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans_counter ) <NEWLINE> <NL> <NL> <NL> <NL>
N = int ( input ( ) ) <NEWLINE> <NL> def make_divisors ( n ) : <NEWLINE> <INDENT> ans = 0 <NEWLINE> for i in range ( 1 , int ( n ** 0.5 ) + 1 ) : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> if i != n // i : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return ans <NEWLINE> <NL> <DEDENT> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> if ( i % 2 == 1 ) and ( make_divisors ( i ) == 8 ) : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
def resolve ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , N + 1 , 2 ) : <NEWLINE> <INDENT> tmp = make_divisors ( i ) <NEWLINE> if len ( tmp ) == 8 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> resolve ( ) <NEWLINE>
https : // atcoder . jp / contests / abc106 / scoreN = int ( input ( ) ) <NEWLINE> <COMMENT> <NL> ans = 0 <NEWLINE> for i in range ( 1 , N + 1 , 2 ) : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> for j in range ( 1 , i + 1 ) : <NEWLINE> <INDENT> if i % j == 0 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> if cnt == 8 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import numpy as np <NEWLINE> from sys import stdinans = 0 <NEWLINE> c = 0 <NEWLINE> N = int ( input ( ) . rstrip ( ) ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> c = 0 <NEWLINE> i += 1 <NEWLINE> if i % 2 == 1 : <NEWLINE> <INDENT> for j in range ( i ) : <NEWLINE> <INDENT> j += 1 <NEWLINE> if i % j == 0 : <NEWLINE> <INDENT> c += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if c == 8 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> li = [ 3 , 5 , 7 , 11 , 13 ] <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> for j in range ( 10 ) : <NEWLINE> <INDENT> if i % li [ j ] == 0 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> if cnt == 3 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if n >= 135 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> if n >= 189 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> a = 0 <NEWLINE> <NL> for i in range ( 1 , 1 + N , 2 ) : <NEWLINE> <INDENT> b = 0 <NEWLINE> for j in range ( 1 , 1 + i , 2 ) : <NEWLINE> <INDENT> if i % j == 0 : <NEWLINE> <INDENT> b += 1 <NEWLINE> <DEDENT> if n == 8 : <NEWLINE> <INDENT> a += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( a ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for num in range ( 1 , n ) : <NEWLINE> <INDENT> if num % 2 == 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> ls = [ ] <NEWLINE> for i in range ( num + 1 ) : <NEWLINE> <INDENT> if num % i == 0 : <NEWLINE> <INDENT> ls . append ( i ) <NEWLINE> <DEDENT> <DEDENT> if len ( ls ) == 8 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> cnt = 0 <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> k = 0 <NEWLINE> for j in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> if i % j == 0 : <NEWLINE> k += 1 <NEWLINE> <DEDENT> if k == 8 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> n = int ( input ( ) ) <NEWLINE> if n < 105 : print ( 0 ) <NEWLINE> elif n < 135 : print ( 1 ) <NEWLINE> elif n < 165 : print ( 2 ) <NEWLINE> elif n < 195 : print ( 3 ) <NEWLINE> else print ( 4 ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> def solve ( num ) : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> for i in range ( 1 , num + 1 ) : <NEWLINE> <INDENT> if num % i == 0 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> return cnt <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if i % 2 == 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if solve ( i ) == 8 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans <NEWLINE>
N = int ( input ( ) ) <NEWLINE> l = [ 105 , 135 , 165 , 189 , 195 ] <NEWLINE> for i in range ( 5 ) : <NEWLINE> <INDENT> if N < l [ i ] : <NEWLINE> <INDENT> print ( i ) <NEWLINE> exit ( 1 ) <NEWLINE> <DEDENT> <DEDENT> print ( 5 ) <NEWLINE>
number = int ( input ( ) ) <NEWLINE> <NL> num_eight_divisors = 0 <NEWLINE> <NL> numbers = list ( range ( 9 , number + 1 , 2 ) ) <NEWLINE> <NL> for i in range ( 9 , number + 1 , 2 ) : <NEWLINE> <INDENT> divisors = [ 1 , i ] <NEWLINE> <NL> for j in range ( 2 , i ) : <NEWLINE> <INDENT> q , mod = divmod ( i , j ) <NEWLINE> <NL> if mod == 0 : <NEWLINE> <INDENT> divisors . append ( j , q ) <NEWLINE> <NL> <DEDENT> <DEDENT> if len ( set ( divisors ) ) : <NEWLINE> <INDENT> num_eight_divisors = num_eight_divisors + 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( num_eight_divisors ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> res = 0 <NEWLINE> for j in range ( i + 1 ) : <NEWLINE> <INDENT> if i % j == 0 : <NEWLINE> <INDENT> res += 1 <NEWLINE> <DEDENT> if res == 8 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
S = input ( ) ; <NEWLINE> K = input ( ) ; <NEWLINE> i = 0 ; <NEWLINE> for i in range ( len ( S ) ) : <NEWLINE> <INDENT> if int ( S [ i ] ) > 1 : <NEWLINE> <INDENT> print ( S [ i ] ) ; <NEWLINE> break ; <NEWLINE> <DEDENT> elif i + 1 >= K : <NEWLINE> <INDENT> print ( 1 ) ; <NEWLINE> <DEDENT> <DEDENT>
s = input ( ) <NEWLINE> k = input ( ) <NEWLINE> <NL> ans = <STRING> <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> if k [ i ] != <STRING> : <NEWLINE> <INDENT> ans = k [ i ] <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
S = input ( ) <NEWLINE> K = int ( input ( ) ) <NEWLINE> <NL> ind = - 1 <NEWLINE> for i in range ( len ( S ) ) : <NEWLINE> <INDENT> if S [ i ] == 1 <NEWLINE> <INDENT> ind = i <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> if ind == - 1 : <NEWLINE> <INDENT> print ( S [ 0 ] ) <NEWLINE> <DEDENT> elif ind + 1 >= K : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( S [ ind + 1 ] ) <NEWLINE> <DEDENT>
import sys <NEWLINE> s = input ( ) <NEWLINE> n = int ( input ( ) ) <NEWLINE> if n == 1 : <NEWLINE> <INDENT> print ( s [ 0 ] ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> if <NEWLINE> for i in s : <NEWLINE> <INDENT> if i != <STRING> : <NEWLINE> <INDENT> print ( i ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( 1 ) <NEWLINE>
s = list ( map ( int , tuple ( input ( ) ) ) ) <NEWLINE> k = int ( input ( ) ) <NEWLINE> i = 0 <NEWLINE> if 1 in s : <NEWLINE> <INDENT> i = s . index ( ) <NEWLINE> if i + 1 >= k : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( s [ i + 1 ] ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( s [ 0 ] ) <NEWLINE> <DEDENT>
def resolve ( ) : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> k = int ( input ( ) ) <NEWLINE> c = 0 <NEWLINE> for i in s : <NEWLINE> <INDENT> if i == <STRING> : <NEWLINE> <INDENT> c += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> c += int ( i ) ** ( ( 5 * 10 ** 16 ) - 1 ) <NEWLINE> <DEDENT> if k <= c : <NEWLINE> <INDENT> print ( i ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> resolve ( ) <NEWLINE>
S = input ( ) <NEWLINE> K = int ( input ( ) ) <NEWLINE> <NL> for i in range ( K ) : <NEWLINE> <INDENT> if s [ i ] != <STRING> : <NEWLINE> <INDENT> print ( int ( s [ i ] ) ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT>
A = str ( input ( ) ) <NEWLINE> B = int ( input ( ) ) <NEWLINE> count = 0 <NEWLINE> <NL> for i in range ( len ( A ) ) : <NEWLINE> <INDENT> if A [ i ] == <STRING> : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if B <= count : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( A [ i ] ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( 1 ) <NEWLINE>
S = input ( ) <NEWLINE> K = int ( input ( ) ) <NEWLINE> <NL> for i in range ( K ) : <NEWLINE> <INDENT> if S [ i ] != <STRING> : <NEWLINE> <INDENT> print ( S [ i ] ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> if i == k - 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT>
N = input ( ) <NEWLINE> K = int ( input ( ) ) <NEWLINE> ans = <STRING> <NEWLINE> for i in range ( K ) : <NEWLINE> <INDENT> if i >= len ( N ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if N [ i ] != <STRING> : <NEWLINE> <INDENT> ans = N [ i ] <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
S = input ( ) <NEWLINE> K = int ( input ( ) ) <NEWLINE> <NL> if S [ 0 ] == <STRING> : <NEWLINE> <INDENT> count = 0 <NEWLINE> while S [ i ] == <STRING> : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> if count >= K : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( S [ count ] ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( S [ 0 ] ) <NEWLINE> <DEDENT>
from copy import deepcopy <NEWLINE> <NL> n , m , q = map ( int , input ( ) . split ( ) ) <NEWLINE> lr = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( m ) ] <NEWLINE> pq = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( q ) ] <NEWLINE> <NL> cnt = [ [ 0 ] * ( n + 1 ) for _ in range ( n + 1 ) ] <NEWLINE> for l , r in lr : <NEWLINE> <INDENT> cnt [ l ] [ r ] += 1 <NEWLINE> <NL> <DEDENT> acc = cnt . deepcopy ( ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( n ) : <NEWLINE> <INDENT> tmp = acc [ i ] [ j + 1 ] + acc [ i + 1 ] [ j ] - acc [ i ] [ j ] <NEWLINE> acc [ i + 1 ] [ j + 1 ] += tmp <NEWLINE> <NL> <DEDENT> <DEDENT> for p , q in pq : <NEWLINE> <INDENT> p -= 1 <NEWLINE> ans = acc [ q ] [ q ] - acc [ p ] [ q ] - acc [ q ] [ p ] + acc [ p ] [ p ] <NEWLINE> print ( ans ) <NEWLINE> <DEDENT>
if snacks_num % persons == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT>
def mapt ( fn , * args ) : <NEWLINE> <INDENT> return list ( map ( fn , * args ) ) <NEWLINE> <NL> <NL> <DEDENT> def Input ( ) : <NEWLINE> <INDENT> return mapt ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> n , k = Input ( ) <NEWLINE> if n % k == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> max_n = math . ceil ( k / n ) <NEWLINE> min_n = math . floor ( k / n ) <NEWLINE> print ( max_n - min_n ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> main ( ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> if N % K == : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT>
n , k = map ( int , input ( ) ) <NEWLINE> if n % k == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if N % K == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> else : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> <DEDENT>
<NL> def main ( ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( abs ( ( x // y + x % y ) - ( x // y ) ) ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT> i <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if n % k = 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT>
if int ( input ( ) ) % 3 == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT>
buy = [ false ] * 1000 <NEWLINE> buy [ 0 ] = true <NEWLINE> for i in range ( 100 ) : <NEWLINE> <INDENT> if buy [ i ] : <NEWLINE> <INDENT> buy [ i + 4 ] = true <NEWLINE> buy [ i + 7 ] = true <NEWLINE> <NL> <DEDENT> <DEDENT> n = int ( input ( ) ) <NEWLINE> if buy [ n ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> print ( <STRING> if any ( ( n - i * 7 ) % 4 == 0 for i in range ( n // 7 + 1 ) else <STRING> ) <NEWLINE>
import sys <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> <NL> for i range ( 101 ) : <NEWLINE> <INDENT> for j in range ( 101 ) : <NEWLINE> <INDENT> if 4 * i + 7 * j == N : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> <NL> for i in range ( 26 ) : <NEWLINE> <INDENT> for j in range ( 15 ) : <NEWLINE> <INDENT> if 4 * i + 7 * j = n : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> INF = 10 ** 9 <NEWLINE> dp = [ INF ] * ( N + K ) <NEWLINE> dp [ 0 ] = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> for k in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> if i + k >= N : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> dp [ i + k ] = min ( dp [ i + k ] , dp [ i ] + abs ( h [ i ] - h [ i + k ] ) ) <NEWLINE> <DEDENT> <DEDENT> print ( dp [ N - 1 ] ) <NEWLINE> <NL>
N = input ( ) <NEWLINE> ans = <STRING> <NEWLINE> for i in range ( 15 ) : <NEWLINE> <INDENT> N = N - 7 <NEWLINE> print ( N ) <NEWLINE> if N <= 0 : <NEWLINE> <INDENT> if N % 3 == 0 : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <DEDENT> break <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> if n % 4 == 0 or n % 7 == 0 <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> elif ( n % 7 ) % 4 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
<NL> ans = <STRING> <NEWLINE> if N == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif N == - 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> while True : <NEWLINE> <INDENT> r = N % 2 <NEWLINE> N = ( N - r ) / - 2 <NEWLINE> ans = str ( int ( r ) ) + ans <NEWLINE> if N == 0 or N == 1 : <NEWLINE> <INDENT> ans = str ( int ( N ) ) + ans <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> <NL> dp = [ 0 ] * 40 <NEWLINE> <NL> if n == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <NL> <DEDENT> elif n > 0 : <NEWLINE> <INDENT> x = bin ( n ) <NEWLINE> bx = x [ 2 : ] <NEWLINE> lx = len ( bx ) <NEWLINE> for i in range ( lx - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> dp [ i ] = int ( bx [ lx - 1 - i ] ) <NEWLINE> <DEDENT> for i in range ( 40 ) : <NEWLINE> <INDENT> if i % 2 == 1 and dp [ i ] == 1 : <NEWLINE> <INDENT> dp [ i + 1 ] += 1 <NEWLINE> <DEDENT> <DEDENT> while max ( dp ) > 1 : <NEWLINE> <INDENT> for i in range ( 40 ) : <NEWLINE> <INDENT> if dp [ i ] >= 2 : <NEWLINE> <INDENT> dp [ i ] -= 2 <NEWLINE> if dp [ i + 1 ] > 0 : <NEWLINE> <INDENT> dp [ i + 1 ] -= 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dp [ i + 1 ] += 1 <NEWLINE> dp [ i + 2 ] += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> dpr = list ( reversed ( dp ) ) <NEWLINE> dprs = list ( map ( lambda x : str ( x ) , dpr ) ) <NEWLINE> dprj = <STRING> . join ( dprs ) <NEWLINE> print ( int ( dprj ) ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> x = bin ( n ) <NEWLINE> bx = x [ 2 : ] <NEWLINE> lx = len ( bx ) <NEWLINE> for i in range ( lx - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> dp [ i ] = int ( bx [ lx - 1 - i ] ) <NEWLINE> <DEDENT> for i in range ( 40 ) : <NEWLINE> <INDENT> if i % 2 == 1 and dp [ i ] == 1 : <NEWLINE> <INDENT> dp [ i + 1 ] += 1 <NEWLINE> <DEDENT> <DEDENT> while max ( dp ) > 1 : <NEWLINE> <INDENT> for i in range ( 40 ) : <NEWLINE> <INDENT> if dp [ i ] >= 2 : <NEWLINE> <INDENT> dp [ i ] -= 2 <NEWLINE> if dp [ i + 1 ] > 0 : <NEWLINE> <INDENT> dp [ i + 1 ] -= 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dp [ i + 1 ] += 1 <NEWLINE> dp [ i + 2 ] += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> dpr = list ( reversed ( dp ) ) <NEWLINE> dprs = list ( map ( lambda x : str ( x ) , dpr ) ) <NEWLINE> dprj = <STRING> . join ( dprs ) <NEWLINE> print ( int ( dprj ) ) <NEWLINE> <DEDENT>
import sys , re <NEWLINE> from collections import deque , defaultdict , Counter <NEWLINE> from math import ceil , sqrt , hypot , factorial , pi , sin , cos , radians , log2 <NEWLINE> from itertools import accumulate , permutations , combinations , product <NEWLINE> from operator import itemgetter , mul <NEWLINE> from copy import deepcopy <NEWLINE> from string import ascii_lowercase , ascii_uppercase , digits <NEWLINE> from bisect import bisect , bisect_left <NEWLINE> from fractions import gcd <NEWLINE> from heapq import heappush , heappop <NEWLINE> from functools import reduce <NEWLINE> def input ( ) : return sys . stdin . readline ( ) . strip ( ) <NEWLINE> def INT ( ) : return int ( input ( ) ) <NEWLINE> def MAP ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def LIST ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> def ZIP ( n ) : return zip ( * ( MAP ( ) for _ in range ( n ) ) ) <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> INF = float ( <STRING> ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> N = INT ( ) <NEWLINE> <NL> if N == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> lim = 30 <NEWLINE> top = [ 0 ] * ( lim + 1 ) <NEWLINE> bottom = [ 0 ] * ( lim + 1 ) <NEWLINE> <NL> for i in range ( 1 , lim + 1 ) : <NEWLINE> <INDENT> if i % 2 : <NEWLINE> <INDENT> t = ( i + 1 ) // 2 <NEWLINE> top [ i ] = ( 4 ** t - 1 ) // 3 <NEWLINE> bottom [ i ] = bottom [ i - 1 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> b = i // 2 <NEWLINE> bottom [ i ] = ( 4 ** b - 1 ) * 2 // 3 <NEWLINE> top [ i ] = top [ i - 1 ] <NEWLINE> <NL> <DEDENT> <DEDENT> digit = [ 0 ] * ( lim + 1 ) <NEWLINE> for i in range ( 1 , lim + 1 ) : <NEWLINE> <INDENT> digit [ i ] = ( - 2 ) ** ( i - 1 ) <NEWLINE> <NL> <DEDENT> if 0 <= N : <NEWLINE> <INDENT> idx = bisect_left ( top , N ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> idx = bisect_left ( bottom , - N ) <NEWLINE> <NL> <DEDENT> ans = <STRING> <NEWLINE> for i in range ( idx , 0 , - 1 ) : <NEWLINE> <INDENT> if - bottom [ i - 1 ] <= N <= top [ i - 1 ] : <NEWLINE> <INDENT> ans += <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += <STRING> <NEWLINE> N -= digit [ i ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = input ( ) <NEWLINE> a = <STRING> <NEWLINE> if N == 0 : <NEWLINE> <INDENT> a = 0 <NEWLINE> <DEDENT> while N != 0 : <NEWLINE> <INDENT> if N % 2 != 0 : <NEWLINE> <INDENT> a = <STRING> + a <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a = <STRING> + a <NEWLINE> <DEDENT> N = - ( N // 2 ) <NEWLINE> <DEDENT> print ( a ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> x = <STRING> <NEWLINE> while n != 0 : <NEWLINE> <INDENT> x = str ( n % 2 ) + x <NEWLINE> n = - ( n // 2 ) <NEWLINE> <DEDENT> if x = <STRING> : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( x ) <NEWLINE> <DEDENT>
r = input ( ) <NEWLINE> if r < 1200 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif 1200 < r < 2800 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
r = int ( intput ( ) ) <NEWLINE> if r < 1200 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif r < 2800 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a = int ( input ( ) ) <NEWLINE> rint ( [ <STRING> , <STRING> , <STRING> ] [ ( a >= 1200 ) + ( a >= 2800 ) ] ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> if N < 1200 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif N < 2800 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT>
r = input ( ) <NEWLINE> if r < 1200 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif r < 2800 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a = input ( ) <NEWLINE> if a <= 1199 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a <= 2799 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
R = input ( ) <NEWLINE> print ( R ) <NEWLINE> <NL> if R < 1200 : <NEWLINE> <INDENT> print ( ABC ) <NEWLINE> <DEDENT> elif 1200 <= R and R < 2800 : <NEWLINE> <INDENT> print ( ARC ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( AGC ) <NEWLINE> <DEDENT>
import re <NEWLINE> import sys <NEWLINE> import math <NEWLINE> import itertools <NEWLINE> import bisect <NEWLINE> from copy import copy <NEWLINE> from collections import deque , Counter <NEWLINE> from decimal import Decimal <NEWLINE> import functools <NEWLINE> def v ( ) : return input ( ) <NEWLINE> def k ( ) : return int ( input ( ) ) <NEWLINE> def S ( ) : return input ( ) . split ( ) <NEWLINE> def I ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def X ( ) : return list ( input ( ) ) <NEWLINE> def L ( ) : return list ( input ( ) . split ( ) ) <NEWLINE> def l ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> def lcm ( a , b ) : return a * b // math . gcd ( a , b ) <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> cnt = 0 <NEWLINE> ans = 0 <NEWLINE> inf = float ( <STRING> ) <NEWLINE> <NL> r = I ( ) <NEWLINE> if r < 1200 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif r < 2800 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
rating = int ( input ( ) ) <NEWLINE> switch ( rating ) : <NEWLINE> <INDENT> case rating > 0 and rating < 1200 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> case rating > 1200 and rating < 2800 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> case rating > 2800 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> default : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT>
a = int ( input ( ) ) <NEWLINE> if a < 1200 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else if 2800 <= a : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> if n < 1200 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
if R < 1200 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif R < 2800 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
rint ( <STRING> , ord ( <STRING> ) ) <NEWLINE> print ( <STRING> , ord ( <STRING> ) ) <NEWLINE> <NL> s = input ( ) <NEWLINE> n = len ( s ) <NEWLINE> ans = 1 <NEWLINE> if s [ 0 ] != <STRING> : <NEWLINE> <INDENT> ans *= 0 <NEWLINE> <DEDENT> if not ( 97 <= ord ( s [ 1 ] ) <= 122 ) : <NEWLINE> <INDENT> ans *= 0 <NEWLINE> <DEDENT> if not ( 97 <= ord ( s [ - 1 ] ) <= 122 ) : <NEWLINE> <INDENT> ans *= 0 <NEWLINE> <NL> <DEDENT> check = 0 <NEWLINE> for i in range ( 1 , n - 1 ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> check += 1 <NEWLINE> <DEDENT> <DEDENT> print ( [ <STRING> , <STRING> ] [ ans & ( check == 1 ) ] ) <NEWLINE>
s = input ( ) <NEWLINE> ans = <STRING> <NEWLINE> <NL> if s [ 0 ] == <STRING> and a [ 2 : - 2 ] . count ( <STRING> ) == 1 : <NEWLINE> <INDENT> tmp = s [ 1 : ] <NEWLINE> tmp . replace ( <STRING> , <STRING> ) <NEWLINE> ans = <STRING> if tmp . islower ( ) else <STRING> <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
s = input ( ) <NEWLINE> <NL> if s [ 0 ] != <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> if s [ 2 : - 1 ] . count ( <STRING> ) != 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> s = s . replace ( <STRING> , <STRING> ) <NEWLINE> <NL> if s [ 1 : ] . isLower ( ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s = list ( input ( ) ) <NEWLINE> flg = <STRING> <NEWLINE> if s [ 0 ] == <STRING> : <NEWLINE> <INDENT> if <STRING> in s [ 2 : len ( s ) - 1 ] : <NEWLINE> <INDENT> s . remove ( <STRING> ) <NEWLINE> s . remove ( <STRING> ) <NEWLINE> s = * s <NEWLINE> if s . islower ( ) == True : <NEWLINE> <INDENT> flg = <STRING> <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( flg ) <NEWLINE>
S = input ( ) <NEWLINE> flag = True <NEWLINE> count = 0 <NEWLINE> if not S [ 0 ] == <STRING> : <NEWLINE> <INDENT> flag = False <NEWLINE> <DEDENT> for i in range ( 2 , len ( S ) - 1 ) : <NEWLINE> <INDENT> if S [ i ] == <STRING> : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if not S [ len ( S ) ] . islower ( ) : <NEWLINE> <INDENT> flag = False <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if not S [ len ( S ) ] . islower ( ) : <NEWLINE> <INDENT> flag = False <NEWLINE> <DEDENT> if not count == 1 : <NEWLINE> <INDENT> flag = False <NEWLINE> <DEDENT> if flag : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
def isAC ( S ) : <NEWLINE> <INDENT> if S [ 0 ] != <STRING> : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> if S [ 2 : - 1 ] . count ( <STRING> ) != 1 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> S = S . remove ( <STRING> ) <NEWLINE> if not all ( <STRING> <= x <= <STRING> for x in S ) : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> return True <NEWLINE> <NL> <DEDENT> print ( <STRING> if isAC ( input ( ) ) else <STRING> ) <NEWLINE>
S = input ( ) <NEWLINE> sl = [ ] <NEWLINE> ans = <STRING> <NEWLINE> <NL> for i in S : <NEWLINE> <INDENT> sl . append ( i ) <NEWLINE> <DEDENT> if sl [ 0 ] != <STRING> : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <DEDENT> if sl [ 2 : - 1 ] . count ( <STRING> ) != 1 : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <NL> <DEDENT> if sl [ 1 : ] . replace ( <STRING> , <STRING> , 1 ) . islower ( ) == False : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <COMMENT> <NL> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> S = list ( input ( ) ) <NEWLINE> C_cnt , low , upp = 0 , 0 , 0 <NEWLINE> if S [ 0 ] != <STRING> or S [ - 1 ] . isupper ( ) <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> for i in range ( 1 , len ( S ) - 1 ) : <NEWLINE> <INDENT> if S [ i ] == <STRING> : <NEWLINE> <INDENT> C_cnt += 1 <NEWLINE> <DEDENT> elif S [ i ] . islower ( ) : <NEWLINE> <INDENT> low += 1 <NEWLINE> <DEDENT> elif S [ i ] . isupper ( ) : <NEWLINE> <INDENT> upp += 1 <NEWLINE> <DEDENT> <DEDENT> if C_cnt = 1 and low = len ( S ) - 3 and upp = 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
S = list ( input ( ) ) <NEWLINE> l = [ chr ( i ) for i in range ( 65 , 65 + 26 ) ] <NEWLINE> <NL> flag = True <NEWLINE> if S [ 0 ] != <STRING> : <NEWLINE> <INDENT> flag = False <NEWLINE> <DEDENT> elif S [ 1 ] in l : <NEWLINE> <INDENT> flag = False <NEWLINE> <DEDENT> elif S [ len ( S ) ] in l : <NEWLINE> <INDENT> flag = False <NEWLINE> <DEDENT> elif not <STRING> in S [ 2 : len ( S ) - 2 ] : <NEWLINE> <INDENT> flag = False <NEWLINE> <DEDENT> count = 0 <NEWLINE> for i in range ( 2 , len ( S ) - 1 ) : <NEWLINE> <INDENT> if flag == False : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if S [ i ] in l : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> if count > 1 : <NEWLINE> <INDENT> flag = False <NEWLINE> <DEDENT> <DEDENT> if count < 1 : <NEWLINE> <INDENT> flag = False <NEWLINE> <DEDENT> if flag : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> ans = <STRING> <NEWLINE> if s [ 0 ] != <STRING> : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <DEDENT> elif s [ 2 : - 1 ] . count ( <STRING> ) != 1 : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <DEDENT> s = sorted ( s ) <NEWLINE> if s [ 2 : ] . islower ( ) == False : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
def i ( ) : <NEWLINE> <INDENT> return int ( input ( ) ) <NEWLINE> <DEDENT> def i2 ( ) : <NEWLINE> <INDENT> return map ( int , input ( ) . split ( ) ) <NEWLINE> <DEDENT> def s ( ) : <NEWLINE> <INDENT> return str ( input ( ) ) <NEWLINE> <DEDENT> def l ( ) : <NEWLINE> <INDENT> return list ( input ( ) ) <NEWLINE> <DEDENT> def intl ( ) : <NEWLINE> <INDENT> return list ( int ( k ) for k in input ( ) . split ( ) ) <NEWLINE> <NL> <DEDENT> s = s ( ) <NEWLINE> <NL> if s [ 0 ] != <STRING> : <NEWLINE> <INDENT> f1 = True <NEWLINE> <DEDENT> cnt = 0 <NEWLINE> for i in range ( 2 , len ( s ) - 1 ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> if cnt1 == 1 : <NEWLINE> <INDENT> f2 = True <NEWLINE> <DEDENT> cnt2 = 0 <NEWLINE> for i in range ( 1 , len ( s ) ) : <NEWLINE> <INDENT> if s [ i ] . islower ( ) : <NEWLINE> <INDENT> cnt2 += 1 <NEWLINE> <DEDENT> <DEDENT> if cnt2 >= len ( s ) - 2 : <NEWLINE> <INDENT> f3 = True <NEWLINE> <NL> <DEDENT> if f1 and f2 and f3 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> prinet ( <STRING> ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> if s [ 0 ] == <STRING> and <STRING> in s [ 2 : - 1 ] and len ( re . findall ( <STRING> , s ) ) == 2 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s = list ( input ( ) ) <NEWLINE> al = list ( <STRING> ) <NEWLINE> if s [ 0 ] == <STRING> and s [ - 1 ] in al and s [ 1 ] in al : <NEWLINE> <INDENT> del s [ 0 ] <NEWLINE> del s [ 0 ] <NEWLINE> del s [ - 1 ] <NEWLINE> f = 0 <NEWLINE> for i in s : <NEWLINE> <INDENT> if i == <STRING> : <NEWLINE> <INDENT> if f == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> f = 1 <NEWLINE> continue <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if i in al : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if f = 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
S = input ( ) <NEWLINE> count = 0 <NEWLINE> if S [ 0 ] != <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> return <NEWLINE> <DEDENT> S . lower ( 0 ) <NEWLINE> for i in range ( 3 , len ( S ) - 1 ) : <NEWLINE> <INDENT> if S [ i ] == <STRING> : <NEWLINE> <INDENT> count += 1 <NEWLINE> S . lower ( i ) <NEWLINE> <DEDENT> <DEDENT> if count == 1 & & S . islower ( ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import sys <NEWLINE> s = list ( input ( ) ) <NEWLINE> if s [ 0 ] == <STRING> and s [ 2 : - 1 ] . count ( <STRING> ) == 1 : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> for i in s : <NEWLINE> <INDENT> if s . isupper ( ) : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> if cnt == 2 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
s = input ( ) <NEWLINE> <NL> a = - 1 <NEWLINE> c = - 1 <NEWLINE> lower = 0 <NEWLINE> for i in range ( len ( s ) ) <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> a = i <NEWLINE> <DEDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> c = i <NEWLINE> <DEDENT> if <STRING> <= s [ i ] <= <STRING> : <NEWLINE> <INDENT> lower += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if a == 0 and 2 <= c <= len ( s ) - 2 and lower == len ( s ) - 2 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> n = len ( s ) <NEWLINE> res = 0 <NEWLINE> <NL> if s [ 0 ] == <STRING> : <NEWLINE> <INDENT> if s . find ( <STRING> ) >= 2 and s . find ( <STRING> ) < n - 2 : <NEWLINE> <INDENT> s . lower ( 0 ) <NEWLINE> s . lower ( s . find ( <STRING> ) ) <NEWLINE> if s == s . lower ( ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
<NL> def solve ( ) : <NEWLINE> <INDENT> d = 0 <NEWLINE> c = 0 <NEWLINE> for i in range ( D ) : <NEWLINE> <INDENT> d += p [ i ] [ 0 ] <NEWLINE> <DEDENT> dp = [ [ 0 ] * ( d + 1 ) for i in range ( D ) ] <NEWLINE> for i in range ( D ) : <NEWLINE> <INDENT> for j in range ( p [ i ] [ 0 ] + 1 ) : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> if j == p [ i ] [ 0 ] : <NEWLINE> <INDENT> dp [ i ] [ j ] += p [ i ] [ 1 ] <NEWLINE> <DEDENT> dp [ i ] [ j ] += 100 * j <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for k in range ( c + 1 ) : <NEWLINE> <INDENT> if j == p [ i ] [ 0 ] : <NEWLINE> <INDENT> dp [ i ] [ k + j ] = max ( dp [ i ] [ k + j ] , dp [ i - 1 ] [ k ] + 100 * j * ( i + 1 ) + p [ i ] [ 1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dp [ i ] [ k + j ] = max ( dp [ i ] [ k + j ] , dp [ i - 1 ] [ k ] + 100 * j * ( i + 1 ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> c += p [ i ] [ 0 ] <NEWLINE> <DEDENT> for i in range ( d + 1 ) : <NEWLINE> <INDENT> if dp [ D - 1 ] [ i ] >= G : <NEWLINE> <INDENT> print ( i ) <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> D , G = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> pc = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( D ) ] <NEWLINE> solve ( ) <NEWLINE> <DEDENT>
rom math import ceil <NEWLINE> <NL> D , G = map ( int , input ( ) . split ( ) ) <NEWLINE> pc = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( D ) ] <NEWLINE> <NL> ans = float ( <STRING> ) <NEWLINE> for bit in range ( 1 << D ) : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> sum = 0 <NEWLINE> remain = set ( range ( 1 , D + 1 ) ) <NEWLINE> <NL> for i in range ( D ) : <NEWLINE> <INDENT> if bit & ( 1 << i ) : <NEWLINE> <INDENT> cnt += pc [ i ] [ 0 ] <NEWLINE> sum += pc [ i ] [ 0 ] * ( i + 1 ) * 100 + pc [ i ] [ 1 ] <NEWLINE> remain . discard ( i + 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> if sum < G : <NEWLINE> <INDENT> use = max ( remain ) <NEWLINE> n = min ( pc [ use - 1 ] [ 0 ] , ceil ( ( G - sum ) / ( use * 100 ) ) ) <NEWLINE> <STRING> <NEWLINE> cnt += n <NEWLINE> sum += n * use * 100 <NEWLINE> <NL> <DEDENT> if sum >= G : <NEWLINE> <INDENT> ans = min ( ans , cnt ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
P = [ ] <NEWLINE> C = [ ] <NEWLINE> point = 1001 <COMMENT> <NEWLINE> <NL> D , G = map ( int , input ( ) . split ( ) ) <NEWLINE> for i in range ( D ) : <NEWLINE> <INDENT> p , c = map ( int , input ( ) . split ( ) ) <NEWLINE> P . append ( p ) <NEWLINE> C . append ( c ) <NEWLINE> <NL> <COMMENT> <NL> <NL> <NL> <DEDENT> for i in range ( 2 ** D ) : <NEWLINE> <INDENT> score = 0 <NEWLINE> solve = 0 <NEWLINE> needproblem = 0 <NEWLINE> for j in range ( D ) : <COMMENT> <NEWLINE> <INDENT> if ( i >> j ) & 1 : <NEWLINE> <INDENT> score += P [ j ] * 100 * ( j + 1 ) + C [ j ] <NEWLINE> solve += P [ j ] <NEWLINE> <DEDENT> <DEDENT> if score >= G : <NEWLINE> <INDENT> point = min ( point , solve ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> elif score < G : <NEWLINE> <INDENT> rest = G - score <NEWLINE> for j in range ( D ) : <NEWLINE> <INDENT> if ( ~ i >> D - j ) & 1 : <NEWLINE> <INDENT> needproblem = D - j + 1 <NEWLINE> <DEDENT> sum = needproblem * 100 * ( P [ needproblem - 1 ] - 1 ) <NEWLINE> if rest > sum : <COMMENT> <NEWLINE> <INDENT> rest -= sum <NEWLINE> solve += P [ needproblem - 1 ] - 1 <NEWLINE> <DEDENT> elif rest <= sum : <NEWLINE> <INDENT> resolve = solve + rest // ( needproblem * 100 ) <NEWLINE> point = min ( point , resolve ) <NEWLINE> continue <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( point ) <NEWLINE>
<NL> D , G = map ( int , input ( ) . split ( ) ) <NEWLINE> for i in range ( D ) : <NEWLINE> <INDENT> p , c = map ( int , input ( ) . split ( ) ) <NEWLINE> P . append ( p ) <NEWLINE> C . append ( c ) <NEWLINE> <NL> <COMMENT> <NL> <NL> <NL> <DEDENT> for i in range ( 2 ** D ) : <NEWLINE> <INDENT> score = 0 <NEWLINE> solve = 0 <NEWLINE> needproblem = 0 <NEWLINE> for j in range ( D ) : <COMMENT> <NEWLINE> <INDENT> if ( i >> j ) & 1 : <NEWLINE> <INDENT> score += P [ j ] * 100 * ( j + 1 ) + C [ j ] <NEWLINE> solve += P [ j ] <NEWLINE> <DEDENT> <DEDENT> if score >= G : <NEWLINE> <INDENT> if D * 100 > solve : <NEWLINE> <INDENT> point = min ( point , solve ) <NEWLINE> <DEDENT> continue <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> rest = G - score <NEWLINE> for j in range ( D ) : <NEWLINE> <INDENT> if ( i >> j ) & 1 == 0 : <NEWLINE> <INDENT> needproblem = j + 1 <NEWLINE> sum = needproblem * 100 * ( P [ needproblem - 1 ] - 1 ) <NEWLINE> if rest > sum : <COMMENT> <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> elif rest <= sum : <NEWLINE> <INDENT> resolve = solve + rest // ( needproblem * 100 ) <NEWLINE> point = min ( point , resolve ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( point ) <NEWLINE>
ans = float ( <STRING> ) <NEWLINE> for i in range ( 1 << d ) : <NEWLINE> <INDENT> count = 0 <NEWLINE> sum = 0 <NEWLINE> nokori = set ( range ( 1 , d + 1 ) ) <NEWLINE> <NL> <COMMENT> <NL> for j in range ( d ) : <NEWLINE> <INDENT> if j & 1 << i : <NEWLINE> <INDENT> sum += pc [ i ] [ 0 ] * ( i + 1 ) * 100 + pc [ i ] [ 1 ] <NEWLINE> count += pc [ i ] [ 0 ] <NEWLINE> nokori . discard ( i + 1 ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> if sum < g : <NEWLINE> <INDENT> use = max ( nokori ) <NEWLINE> n = min ( pc [ use - 1 ] [ 0 ] , ( g - sum ) // ( use * 100 ) ) <NEWLINE> count += n <NEWLINE> sum += n * use * 100 <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> if sum >= g : <NEWLINE> <INDENT> ans = min ( ans , count ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
D , G = map ( int , input ( ) . split ( ) ) <NEWLINE> PC = [ 0 ] + [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( D ) ] <NEWLINE> <NL> def dfs ( d , g ) : <NEWLINE> <INDENT> if ( d == 0 ) : <NEWLINE> <INDENT> return 1e9 <NEWLINE> <NL> <DEDENT> c = min ( g // ( 100 * d ) , PC [ d ] [ 0 ] ) <NEWLINE> s = 100 * d * c <NEWLINE> if c == PC [ d ] [ 0 ] : <NEWLINE> <INDENT> s += PC [ d ] [ 1 ] <NEWLINE> <DEDENT> if s < g : <NEWLINE> <INDENT> c += f ( d - 1 , g - s ) <NEWLINE> <DEDENT> return min ( c , f ( d - 1 , g ) ) <NEWLINE> <NL> <DEDENT> print ( dfs ( D , G ) ) <NEWLINE>
def dfs ( i , sum , count , unsolve ) : <NEWLINE> <INDENT> global ans <NEWLINE> if i == D : <NEWLINE> <COMMENT> <NL> <INDENT> if sum < G : <NEWLINE> <INDENT> use = max ( unsolve ) <NEWLINE> <COMMENT> <NL> N = min ( pc [ use - 1 ] [ 0 ] , - ( - ( g - sum ) // ( 100 * use ) ) ) <NEWLINE> count += N <NEWLINE> sum += N * 100 * use <NEWLINE> <DEDENT> if sum > G : <NEWLINE> <INDENT> ans = min ( ans , count ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> dfs ( i + 1 , sum , count , unsolve ) <NEWLINE> <INDENT> dfs ( i + 1 , sum + pc [ i ] [ 0 ] * ( i + 1 ) * 100 + pc [ i ] [ 1 ] , count + pc [ i ] [ 0 ] , unsolve - { i + 1 } ) <NEWLINE> <NL> <DEDENT> <DEDENT> d , g = map ( int , input ( ) . split ( ) ) <NEWLINE> pc = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( d ) ] <NEWLINE> ans = float ( <STRING> ) <NEWLINE> dfs ( 0 , 0 , 0 , set ( range ( 1 , d + 1 ) ) ) <NEWLINE> print ( ans ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> D , G = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> P = [ ] <NEWLINE> for i in range ( 1 , D + 1 ) : <NEWLINE> <INDENT> P . append ( tuple ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> minp = float ( <STRING> ) <NEWLINE> for bit in range ( 1 << D ) : <NEWLINE> <INDENT> total = 0 <NEWLINE> num_p = 0 <NEWLINE> bset = set ( ) <NEWLINE> for i in range ( D ) : <NEWLINE> <INDENT> mask = 1 << i <NEWLINE> if bit & mask : <NEWLINE> <INDENT> total += P [ i ] [ 1 ] + 100 * ( i + 1 ) * P [ i ] [ 0 ] <NEWLINE> num_p += P [ i ] [ 0 ] <NEWLINE> bset . add ( i ) <NEWLINE> <NL> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> res = G - total <NEWLINE> if res <= 0 : <NEWLINE> <INDENT> if num_p < minp : <NEWLINE> <INDENT> minp = num_p <NEWLINE> <DEDENT> continue <NEWLINE> <NL> <DEDENT> for i in reversed ( sorted ( set ( [ i for i in range ( D ) ] ) - bset ) ) : <NEWLINE> <INDENT> maxv = 100 * ( i + 1 ) * ( P [ i ] [ 0 ] - 1 ) <NEWLINE> <NL> if res <= maxv : <NEWLINE> <INDENT> num_take = max ( min ( bisect . bisect ( list ( range ( 0 , maxv + 100 * ( i + 1 ) , 100 * ( i + 1 ) ) ) , res ) - 1 , P [ i ] [ 0 ] - 1 ) , 1 ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> num_p += num_take <NEWLINE> res -= 100 * ( i + 1 ) * num_take <NEWLINE> if num_p < minp : <NEWLINE> <INDENT> minp = num_p <NEWLINE> <DEDENT> break <NEWLINE> <NL> <DEDENT> res -= maxv <NEWLINE> <COMMENT> <NL> num_p += ( P [ i ] [ 0 ] - 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( minp ) <NEWLINE> <NL> <NL> <DEDENT> if ( __name__ == <STRING> ) : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
A = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( max ( A ) - min ( A ) ) <NEWLINE>
X = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( max ( X ) - min ( X ) ) <NEWLINE>
li = a , b , c = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> lis = sorted ( li ) <NEWLINE> print ( lis [ 2 ] - lis [ 0 ) <NEWLINE>
a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( min ( abs ( a - b ) + abs ( b - c ) , abs ( b - a ) + abs ( a - c ) , abs ( a - c ) + abs ( c - b ) ) <NEWLINE>
a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> l = sorted ( [ a , b , c ] ) <NEWLINE> print ( l [ 2 ] - l [ 1 ] + l [ 1 ] - l [ 0 ] ) <NEWLINE>
N_List = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> print ( sum ( N_List [ 1 : ] - N_List [ : - 1 ] ) ) <NEWLINE>
a , b , c = sorted ( map ( int , input ( ) . split ( ) ) <NEWLINE> print ( a + c ) <NEWLINE>
a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = a . sorted <NEWLINE> print ( b [ 1 ] - b [ 0 ] + b [ 2 ] - b [ 1 ] ) <NEWLINE>
list = input ( ) <NEWLINE> list_n = [ int ( s ) for s in list ] <NEWLINE> print ( int ( max ( list_n ) ) - int ( min ( list_n ) ) ) <NEWLINE>
from collections import deque <NEWLINE> import sys <NEWLINE> <NL> deque_s = deque ( list ( input ( ) ) ) <NEWLINE> kyoto <NEWLINE> deque_t = deque ( list ( input ( ) ) ) <NEWLINE> tokyo <NEWLINE> <NL> for _i in range ( len ( deque_s ) ) : <NEWLINE> <INDENT> deque_s . rotate ( ) <NEWLINE> if deque_s == deque_t : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
<COMMENT> <NL> from collections import deque <NEWLINE> import sys <NEWLINE> <COMMENT> <NL> def inpl ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> S = input ( ) <NEWLINE> T = input ( ) <NEWLINE> <NL> for i in range ( N + 1 ) : <NEWLINE> <INDENT> if S == T [ i : ] + T [ : i ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
ans = <STRING> <NEWLINE> for i in range ( len ( S ) ) : <NEWLINE> <INDENT> if S [ : i ] + S [ 0 : i ] == T : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
S = input ( ) <NEWLINE> T = input ( ) <NEWLINE> if s in T * 2 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> task_list = sorted ( l ) <NEWLINE> <NL> print ( task_list [ 2 ] - task_list [ 0 ] ) <NEWLINE>
import sys <NEWLINE> S , T = map ( str , input ( ) . split ( ) ) <NEWLINE> for i in range ( len ( S ) ) : <NEWLINE> <INDENT> tmp = S [ - 1 ] <NEWLINE> S [ - 1 ] = <STRING> <NEWLINE> S . insert ( 0 , tmp ) <NEWLINE> if S == T : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
s , t = [ input ( ) for i in range ( 2 ) ] <NEWLINE> for _ in range ( len ( s ) ) : <NEWLINE> <INDENT> s = s [ 1 : ] + s [ 0 ] <NEWLINE> if s = t : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s = list ( input ( ) ) <NEWLINE> t = list ( input ( ) ) <NEWLINE> <NL> x = len ( s ) <NEWLINE> <NL> ch1 = 0 <NEWLINE> ch = 0 <NEWLINE> <NL> for i in range ( x ) : <NEWLINE> <INDENT> if s [ i ] = t [ x - 1 - i ] : <NEWLINE> <INDENT> ch += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> for j in range ( x ) : <NEWLINE> <INDENT> if s [ j ] = t [ j ] : <NEWLINE> <INDENT> ch1 += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> ) if ch == x or ch1 == x else print ( <STRING> ) <NEWLINE>
i = input ; i ( ) ; print ( sum ( [ x - 1 for x in i ( ) . split ( ) ] ) ) <NEWLINE>
N = int ( input ) <NEWLINE> print ( sum ( list ( map ( int , input ( ) . split ( ) ) ) ) - N ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> print ( sum ( l ) = n ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> ab = [ 0 ] * M <NEWLINE> for _ in range ( M ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> ab [ a ] . append ( b ) <NEWLINE> <NL> <DEDENT> dp = [ 0 ] * ( N + 1 ) <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> dp [ i ] = max ( dp [ i ] , dp [ i - 1 ] ) <NEWLINE> for j in ab [ i ] : <NEWLINE> <INDENT> dp [ j ] = max ( dp [ j ] , dp [ i ] + 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( dp [ N ] ) <NEWLINE>
import sys <NEWLINE> import math <NEWLINE> import itertools <NEWLINE> import bisect <NEWLINE> from copy import copy <NEWLINE> from collections import deque , Counter <NEWLINE> from decimal import Decimal <NEWLINE> import functools <NEWLINE> def s ( ) : return input ( ) <NEWLINE> def k ( ) : return int ( input ( ) ) <NEWLINE> def S ( ) : return input ( ) . split ( ) <NEWLINE> def I ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def X ( ) : return list ( input ( ) ) <NEWLINE> def L ( ) : return list ( input ( ) . split ( ) ) <NEWLINE> def l ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> def lcm ( a , b ) : return a * b // math . gcd ( a , b ) <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> cnt = 0 <NEWLINE> ans = 0 <NEWLINE> inf = float ( <STRING> ) <NEWLINE> <NL> n = k ( ) <NEWLINE> a = l ( ) <NEWLINE> <NL> i = 1 <NEWLINE> while i < n : <NEWLINE> <INDENT> if a [ i ] == a [ i + 1 ] : <NEWLINE> <INDENT> ans += 1 <NEWLINE> i += 1 <NEWLINE> <DEDENT> i += 1 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> arr = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> from numpy import random <NEWLINE> b = 0 <NEWLINE> for i in range ( len ( a ) - 1 ) : <NEWLINE> <INDENT> if a [ i ] == a [ i + 1 ] : <NEWLINE> <INDENT> b += 1 <NEWLINE> a [ i + 1 ] = random . randint ( 10000 ) <NEWLINE> <DEDENT> <DEDENT> print ( b ) <NEWLINE>
5 <NEWLINE> 1 1 1 1 1 n = int ( input ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = l [ 0 ] <NEWLINE> b = 0 <NEWLINE> c = [ ] <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> if l [ i ] == a : <NEWLINE> <INDENT> b += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> c . append ( b ) <NEWLINE> b = 0 <NEWLINE> <DEDENT> a = l [ i ] <NEWLINE> <DEDENT> c . append ( b ) <NEWLINE> for i in range ( len ( c ) ) : <NEWLINE> <INDENT> c [ i ] = ( c [ i ] + 1 ) // 2 <NEWLINE> <DEDENT> print ( sum ( c ) ) <NEWLINE>
from numpy . random import randint <NEWLINE> n = int ( input ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( len ( a ) - 1 ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> if l [ i ] == l [ i + 1 ] : <NEWLINE> <INDENT> ans += 1 <NEWLINE> l [ i + 1 ] = randint ( 0 , 10000 ) <NEWLINE> <DEDENT> <DEDENT> except : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> S_l = S [ : N ] <NEWLINE> S_r = S [ N : ] [ : : - 1 ] <NEWLINE> dict_l = { } <NEWLINE> dict_r = { } <NEWLINE> ans = 0 <NEWLINE> for num in range ( 2 ** N ) : <NEWLINE> <INDENT> tmpl_1 = <STRING> <NEWLINE> tmpl_2 = <STRING> <NEWLINE> tmpr_1 = <STRING> <NEWLINE> tmpr_2 = <STRING> <NEWLINE> for n in range ( N ) : <NEWLINE> <INDENT> if ( num >> ( N - 1 - n ) & 1 ) : <NEWLINE> <INDENT> tmpl_1 += S_l [ n ] <NEWLINE> tmpr_1 += S_r [ n ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> tmpl_2 += S_l [ n ] <NEWLINE> tmpr_2 += S_r [ n ] <NEWLINE> <DEDENT> <DEDENT> dict_l [ [ tmpl_1 , tmpl_2 ] ] = dict_l . get ( [ tmpl_1 , tmpl_2 ] , 0 ) + 1 <NEWLINE> dict_r [ [ tmpr_1 , tmpr_2 ] ] = dict_r . get ( [ tmpr_1 , tmpr_2 ] , 0 ) + 1 <NEWLINE> <DEDENT> for k , v in dict_l . items ( ) : <NEWLINE> <INDENT> ans += v * dict_r . get ( k , 0 ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if a + b = 15 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a * b = 15 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b = int ( input ( ) ) <NEWLINE> if a + b == 15 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a * b == 15 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b = map ( int , intput ( ) . split ( ) ) <NEWLINE> if a + b == 15 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a * b == 15 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
S = list ( print ( <STRING> ) ) <NEWLINE> w = int ( input ( ) ) <NEWLINE> for i in range ( len ( S ) ) : <NEWLINE> <INDENT> if ( i + 1 ) % w == 1 : <NEWLINE> <INDENT> print ( S [ i ] ) , <NEWLINE> <DEDENT> <DEDENT>
n , m , d = map ( int , input ( ) . split ( ) ) <NEWLINE> p = 1 / n if d == 0 else p = 2 * ( n - d ) / n / n <NEWLINE> ans = ( m - 1 ) * p <NEWLINE> print ( ans ) <NEWLINE>
n , m , d = map ( int , input ( ) . split ( ) ) <NEWLINE> if d == 0 : <NEWLINE> <INDENT> print ( ( m - 1 ) / double ( n ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 2 * ( m - 1 ) * ( n - d ) / double ( n * n ) ) <NEWLINE> <DEDENT>
from networkx import * <NEWLINE> ( N , M , * S ) , * t = [ map ( int , t . split ( ) ) for t in open ( 0 ) ] <NEWLINE> G = Graph ( ) <NEWLINE> for * u , a , b in t : G . add_edge ( * u , y = a , s = b ) <NEWLINE> b = m = 10 ** 15 <NEWLINE> y , s , * r = map ( eval ( dir ( ) [ 761 ] ) , ( G , G ) , S , ( m , m ) , <STRING> ) <NEWLINE> while N : b = min ( b , y [ N ] + s [ N ] ) ; r += m - b , ; N -= 1 <NEWLINE> print ( * r [ : : - 1 ] ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> if N % 2 == 0 : <NEWLINE> <INDENT> print ( N ) <NEWLINE> <DEDENT> else <NEWLINE> <INDENT> print ( N * 2 ) <NEWLINE> <DEDENT>
<NL> N = input ( ) <NEWLINE> <NL> i = N + 1 <NEWLINE> while True : <NEWLINE> <INDENT> if ( i % 2 == 0 and i % N == 0 ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> i = i + 1 <NEWLINE> <NL> <DEDENT> print ( i ) <NEWLINE>
def lcm_base ( x , y ) : <NEWLINE> <INDENT> return ( x * y ) // math . gcd ( x , y ) <NEWLINE> <NL> <DEDENT> def n_lcm ( * numbers ) : <NEWLINE> <INDENT> print ( reduce ( lcm_base , numbers , 1 ) ) <NEWLINE> <NL> <DEDENT> n_lcm ( 2 , int ( input ( ) ) ) <NEWLINE>
n = int ( input ) <NEWLINE> if n % 2 == 0 : <NEWLINE> <INDENT> print ( n ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( n * 2 ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> print ( n if n % 2 == 0 else 2 n ) <NEWLINE>
import math <NEWLINE> N = int ( input ( ) ) <NEWLINE> print ( 2 * N // gcd ( 2 , N ) ) <NEWLINE>
def solve ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> i = n <NEWLINE> while True : <NEWLINE> <INDENT> if i % 2 == 0 and i % n == 0 : <NEWLINE> <INDENT> print ( i ) <NEWLINE> exit ( ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> solve ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> m = max ( n , 2 ) + 1 <NEWLINE> while 1 : <NEWLINE> <INDENT> if m % 2 and m % n : <NEWLINE> <INDENT> print ( m ) <NEWLINE> <DEDENT> m += 1 <NEWLINE> <DEDENT>
n = int ( input ( ) . split ( ) ) <NEWLINE> if n % 2 == 0 : <NEWLINE> <INDENT> print ( n ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( n * 2 ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> if n % != 0 : <NEWLINE> <INDENT> print ( 2 * n ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( n ) <NEWLINE> <DEDENT>
n = input ( ) <NEWLINE> if n % 2 == 0 : <NEWLINE> <INDENT> print ( n ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( n * 2 ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> min_A = 10 ** 9 + 7 <NEWLINE> max_A = - 1 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> tmp = int ( input ( ) ) <NEWLINE> max_A = max ( tmp , max_A ) <NEWLINE> min_A = min ( min_A , tmp ) <NEWLINE> <NL> <DEDENT> print ( abs ( max_A - min_A ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = map ( int , input ( ) . split ( ) ) <NEWLINE> a . sort ( ) <NEWLINE> ans = a [ - 1 ] - a [ 0 ] <NEWLINE> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = input ( ) . split ( ) <NEWLINE> print ( max ( A ) - min ( A ) ) <NEWLINE>
num_len = int ( input ( ) ) <NEWLINE> numbers = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> print ( max ( numbers ) - min ( numbers ) <NEWLINE>
_n = int ( input ( ) ) <NEWLINE> lists = list ( map ( int ( ) , input ( ) . split ( ) ) ) <NEWLINE> lists . sort ( ) <NEWLINE> <NL> print ( lists [ - 1 ] - lists [ 0 ] ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> list = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> list . sort ( ) <NEWLINE> <NL> answer = list [ - 1 ] - list [ 0 ] <NEWLINE> <NL> print ( answer ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = max ( a ) - min ( b ) <NEWLINE> print ( b ) <NEWLINE>
N = int ( input ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A . sort ( ) <NEWLINE> print ( A [ - 1 ] - A [ 0 ] ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> A . append ( int ( input ( ) ) ) <NEWLINE> <DEDENT> print ( max ( A ) - min ( A ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) split ( ) ) ) <NEWLINE> <NL> Amax = max ( A ) <NEWLINE> Amin = min ( A ) <NEWLINE> <NL> ans = Amax - Amin <NEWLINE> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A . sort ( ) <NEWLINE> print ( A [ N ] - A [ 0 ] ) <NEWLINE>
<NL> n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> A . sort ( ) <NEWLINE> print ( abs ( A [ 0 ] - A [ - 1 ] ) ) <NEWLINE> <NL>
N = int ( input ( ) ) <NEWLINE> List = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> mid = 0 <NEWLINE> res = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> for j range ( i + 1 , N ) : <NEWLINE> <INDENT> mid = abs ( List [ i ] - List [ j ] ) <NEWLINE> res = max ( res , mid ) <NEWLINE> <DEDENT> <DEDENT> print ( res ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> lists = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> lists . sorted ( ) <NEWLINE> print ( lists [ - 1 ] - lists [ 0 ] ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> print ( max ( N ) - min ( N ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> ls = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( max ( ls ) - min ( ls ) ) <NEWLINE>
n , aaa = map ( int , open ( 0 ) . split ( ) ) <NEWLINE> print ( max ( aaa ) - min ( aaa ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( max ( a ) - min ( a ) ) <NEWLINE>
count = input ( ) <NEWLINE> list = int ( input ( ) ) . rstrip ( ) . split ( <STRING> ) <NEWLINE> list_1 = [ int ( s ) for s in list ] <NEWLINE> list2 = sorted ( list_1 ) <NEWLINE> sa = ( int ( list2 [ 0 ] ) - int ( list2 [ int ( count ) - 1 ] ) ) <NEWLINE> if sa < 0 : <NEWLINE> <INDENT> print ( - 1 * int ( sa ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( int ( sa ) ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = np . array ( list ( map ( int , input ( ) . split ( <STRING> ) ) ) ) <NEWLINE> B = np . arange ( 1 , N + 1 ) <NEWLINE> <NL> C = A - B <NEWLINE> mean = int ( np . mean ( C ) ) <NEWLINE> <NL> print ( min ( np . sum ( np . abs ( C - mean ) ) ) , np . sum ( np . abs ( C + mean ) ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> alist = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> blist = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> blist . append ( alist [ i ] - i - 1 ) <NEWLINE> <DEDENT> blist . sort ( ) <NEWLINE> if n % 2 == 1 : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> cnt += abs ( blist [ i ] - blist [ ( i + 1 ) // 2 ] ) <NEWLINE> <DEDENT> print ( cnt ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> num = ( blist [ i // 2 ] + blist [ i // 2 + 1 ] ) // 2 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> cnt += abs ( blist [ i ] - num <NEWLINE> <DEDENT> print ( cnt , cnt2 ) <NEWLINE> <DEDENT>
from statistics import median <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> an = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> an [ i ] = an [ i ] - ( i + 1 ) <NEWLINE> <NL> <DEDENT> b = int ( median ( bn ) ) <NEWLINE> <NL> k = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> y = abs ( an [ i ] - b ) <NEWLINE> k . append ( y ) <NEWLINE> <DEDENT> ans = sum ( k ) <NEWLINE> <NL> print ( ans ) <NEWLINE>
li = sorted ( [ a [ i ] - ( i + 1 ) for i in range ( n ) ] ) <NEWLINE> if n % 2 == 0 : <NEWLINE> <INDENT> ave = ( li [ n // 2 ] + li [ n // 2 - 1 ] ) // 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ave = li [ ( n - 1 ) // 2 ] <NEWLINE> <NL> <DEDENT> import math <NEWLINE> ave1 = math . floor ( ave ) <NEWLINE> ave2 = math . ceil ( ave ) <NEWLINE> <NL> ll = [ ] <NEWLINE> c = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> c += abs ( a [ i ] - ( ave1 + i + 1 ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ll += [ c ] <NEWLINE> <NL> <DEDENT> c = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> c += abs ( a [ i ] - ( ave2 + i + 1 ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ll += [ c ] <NEWLINE> <NL> <DEDENT> print ( min ( ll ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> B . append ( A [ i ] - ( i + 1 ) ) <NEWLINE> <DEDENT> B . sort ( ) <NEWLINE> if N % 2 == 0 : <NEWLINE> <INDENT> a = N / 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a = ( N + 1 ) / 2 <NEWLINE> <DEDENT> b = B [ a - 1 ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> B [ N - 1 ] = abs ( B [ N - 1 ] - b ) <NEWLINE> <DEDENT> print ( B ) <NEWLINE> <NL> <NL>
import numpy as np <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> a = np . array ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> arr = np . arange ( n ) + 1 <NEWLINE> diff = a - arr <NEWLINE> <NL> diff . sort ( ) <NEWLINE> <NL> diff -= np . median ( diff ) <NEWLINE> <NL> print ( int ( np . abs ( diff ) . sum ( ) ) ) <NEWLINE>
import sys <NEWLINE> import numpy as np <NEWLINE> import numba <NEWLINE> from numba import njit , b1 , i4 , i8 , f8 <NEWLINE> <NL> read = sys . stdin . buffer . read <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> readlines = sys . stdin . buffer . readlines <NEWLINE> <NL> MOD = 1_000_000_007 <NEWLINE> <NL> @ njit ( ( i8 , i8 ) , cache = True ) <NEWLINE> def mpow ( a , n ) : <NEWLINE> <INDENT> p = 1 <NEWLINE> while n : <NEWLINE> <INDENT> if n & 1 : <NEWLINE> <INDENT> p = p * a % MOD <NEWLINE> <DEDENT> a = a * a % MOD <NEWLINE> n >>= 1 <NEWLINE> <DEDENT> return p <NEWLINE> <NL> <NL> <DEDENT> @ njit ( ( i8 , ) , cache = True ) <NEWLINE> def fact_table ( N ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> fact = np . empty ( N , np . int64 ) <NEWLINE> fact [ 0 ] = 1 <NEWLINE> for n in range ( 1 , N ) : <NEWLINE> <INDENT> fact [ n ] = n * fact [ n - 1 ] % MOD <NEWLINE> <DEDENT> fact_inv = np . empty ( N , np . int64 ) <NEWLINE> fact_inv [ N - 1 ] = mpow ( fact [ N - 1 ] , MOD - 2 ) <NEWLINE> for n in range ( N - 1 , 0 , - 1 ) : <NEWLINE> <INDENT> fact_inv [ n - 1 ] = fact_inv [ n ] * n % MOD <NEWLINE> <DEDENT> return fact , fact_inv <NEWLINE> <NL> <DEDENT> @ njit ( ( i8 [ : ] , i8 ) , cache = True ) <NEWLINE> def is_colorful ( A , K ) : <NEWLINE> <INDENT> if len ( A ) < K : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> counts = np . zeros ( K + 1 , np . int64 ) <NEWLINE> n_color = 0 <NEWLINE> for i in range ( K ) : <NEWLINE> <INDENT> x = A [ i ] <NEWLINE> if counts [ x ] == 0 : <NEWLINE> <INDENT> n_color += 1 <NEWLINE> <DEDENT> counts [ x ] += 1 <NEWLINE> <DEDENT> if n_color == K : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> for i in range ( K , len ( A ) ) : <NEWLINE> <INDENT> x = A [ i ] <NEWLINE> if counts [ x ] == 0 : <NEWLINE> <INDENT> n_color += 1 <NEWLINE> <DEDENT> counts [ x ] += 1 <NEWLINE> x = A [ i - K ] <NEWLINE> if counts [ x ] == 1 : <NEWLINE> <INDENT> n_color -= 1 <NEWLINE> <DEDENT> counts [ x ] -= 1 <NEWLINE> if n_color == K : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> <DEDENT> return False <NEWLINE> <NL> <DEDENT> @ njit ( ( i8 , i8 , i8 ) , cache = True ) <NEWLINE> def compute_dp ( N , K , n ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <INDENT> dp = np . zeros ( ( N , K ) , np . int64 ) <NEWLINE> dp [ 0 , n ] = 1 <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <COMMENT> <NL> <INDENT> for k in range ( K - 1 , 0 , - 1 ) : <NEWLINE> <INDENT> dp [ i , k ] += dp [ i - 1 , k ] <NEWLINE> dp [ i , k - 1 ] += dp [ i , k ] <NEWLINE> <COMMENT> <NL> <DEDENT> for k in range ( 1 , K ) : <NEWLINE> <INDENT> dp [ i , k ] += ( K - k + 1 ) * dp [ i - 1 , k - 1 ] <NEWLINE> <DEDENT> dp [ i , 0 ] = 0 <NEWLINE> dp [ i ] %= MOD <NEWLINE> <DEDENT> return dp . sum ( axis = 1 ) % MOD <NEWLINE> <NL> <DEDENT> @ njit ( ( i8 , i8 , i8 [ : ] ) , cache = True ) <NEWLINE> def main ( N , K , A ) : <NEWLINE> <INDENT> M = len ( A ) <NEWLINE> total = ( N - M + 1 ) * mpow ( K , N - M ) % MOD <NEWLINE> if is_colorful ( A , K ) : <NEWLINE> <INDENT> return total <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> def f ( A ) : <NEWLINE> <COMMENT> <NL> <INDENT> ng = np . zeros ( 500 , np . bool_ ) <NEWLINE> x = 0 <NEWLINE> for a in A : <NEWLINE> <INDENT> if ng [ a ] : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> ng [ a ] = 1 <NEWLINE> x += 1 <NEWLINE> <DEDENT> return x <NEWLINE> <NL> <DEDENT> l , r = f ( A ) , f ( A [ : : - 1 ] ) <NEWLINE> <NL> if l < M : <NEWLINE> <COMMENT> <NL> <INDENT> dp1 = compute_dp ( N , K , l ) <NEWLINE> dp2 = compute_dp ( N , K , r ) <NEWLINE> for i in range ( N - M + 1 ) : <NEWLINE> <INDENT> j = N - M - i <NEWLINE> total -= dp1 [ i ] * dp2 [ j ] % MOD <NEWLINE> <DEDENT> return total % MOD <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <DEDENT> dp1 = np . zeros ( ( N + 1 , K ) , np . int64 ) <NEWLINE> <COMMENT> <NL> dp2 = np . zeros ( ( N + 1 , K ) , np . int64 ) <NEWLINE> <NL> dp1 [ 0 , 0 ] = 1 <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <COMMENT> <NL> <INDENT> for k in range ( K - 1 , 0 , - 1 ) : <NEWLINE> <INDENT> dp1 [ i , k ] += dp1 [ i - 1 , k ] <NEWLINE> dp1 [ i , k - 1 ] += dp1 [ i , k ] <NEWLINE> dp2 [ i , k ] += dp2 [ i - 1 , k ] <NEWLINE> dp2 [ i , k - 1 ] += dp2 [ i , k ] <NEWLINE> <COMMENT> <NL> <DEDENT> for k in range ( 1 , K ) : <NEWLINE> <INDENT> dp1 [ i , k ] += ( K - k + 1 ) * dp1 [ i - 1 , k - 1 ] <NEWLINE> dp2 [ i , k ] += ( K - k + 1 ) * dp2 [ i - 1 , k - 1 ] <NEWLINE> <DEDENT> dp1 [ i , 0 ] = 0 <NEWLINE> dp1 [ i ] %= MOD <NEWLINE> dp2 [ i , 0 ] = 0 <NEWLINE> dp2 [ i ] %= MOD <NEWLINE> <COMMENT> <NL> for k in range ( M , K ) : <NEWLINE> <INDENT> dp2 [ i , k ] += dp1 [ i , k ] <NEWLINE> <DEDENT> dp2 [ i ] %= MOD <NEWLINE> <NL> <DEDENT> x = dp2 [ - 1 ] . sum ( ) % MOD <NEWLINE> <COMMENT> <NL> fact , fact_inv = fact_table ( 200_010 ) <NEWLINE> p = fact_inv [ K ] * fact [ K - M ] % MOD <NEWLINE> total -= x * p % MOD <NEWLINE> return total % MOD <NEWLINE> <NL> <DEDENT> def solve_naive ( N , K , A ) : <NEWLINE> <INDENT> import itertools <NEWLINE> M = len ( A ) <NEWLINE> cnt = 0 <NEWLINE> for p in itertools . product ( range ( 1 , K + 1 ) , repeat = N ) : <NEWLINE> <INDENT> B = np . array ( p ) . astype ( np . int64 ) <NEWLINE> if is_colorful ( B , K ) : <NEWLINE> <INDENT> for i in range ( len ( B ) - M + 1 ) : <NEWLINE> <INDENT> if np . all ( B [ i : i + M ] == A ) : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> return cnt <NEWLINE> <NL> <DEDENT> N , K , M = map ( int , readline ( ) . split ( ) ) <NEWLINE> A = np . array ( read ( ) . split ( ) , np . int64 ) <NEWLINE> <NL> print ( main ( N , K , A ) ) <NEWLINE>
import sys <NEWLINE> import math <NEWLINE> import itertools <NEWLINE> import collections <NEWLINE> import heapq <NEWLINE> import re <NEWLINE> import numpy as np <NEWLINE> <NL> rr = lambda : sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> rs = lambda : sys . stdin . readline ( ) . split ( ) <NEWLINE> ri = lambda : int ( sys . stdin . readline ( ) ) <NEWLINE> rm = lambda : map ( int , sys . stdin . readline ( ) . split ( ) ) <NEWLINE> rl = lambda : list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) <NEWLINE> inf = float ( <STRING> ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> s = rr ( ) <NEWLINE> ans = 0 <NEWLINE> for i in s : <NEWLINE> <INDENT> ans += 1 if i == <STRING> else ans -= 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL>
a = input <NEWLINE> print ( a . count ( <STRING> ) - a . count ( <STRING> ) ) <NEWLINE>
a = list ( input ( ) ) <NEWLINE> count = 1 <NEWLINE> for i in a : <NEWLINE> <INDENT> if i == - : <NEWLINE> <INDENT> count -= 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
s = str ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for in range s : <NEWLINE> <INDENT> if <STRING> Then : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
S = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for s in S : <NEWLINE> <INDENT> if s == <STRING> : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL>
S = input ( ) <NEWLINE> Steam = 0 <NEWLINE> minecraft = 0 <NEWLINE> for i in range ( ) len ( S ) : <NEWLINE> <INDENT> if S [ i ] == <STRING> : <NEWLINE> <INDENT> minecraft += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> Steam += 1 <NEWLINE> <DEDENT> <DEDENT> L = minecraft * 1 <NEWLINE> P = Steam * - 1 <NEWLINE> print ( L + P ) <NEWLINE>
s = list ( map ( str , input ( ) ) ) <NEWLINE> a = s . count ( + ) <NEWLINE> b = s . count ( - ) <NEWLINE> print ( a - b ) <NEWLINE>
s = input ( ) <NEWLINE> con = [ 0 ] * 2 <NEWLINE> for i in range ( 4 ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> c [ 0 ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> c [ 1 ] += 1 <NEWLINE> <DEDENT> <DEDENT> print ( c [ 0 ] - c [ 1 ] ) <NEWLINE>
S = map ( str , input ( ) . split ( ) ) <NEWLINE> s = 1 <NEWLINE> for i in S : <NEWLINE> <INDENT> if i in <STRING> : <NEWLINE> <INDENT> s += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s -= 1 <NEWLINE> <DEDENT> <DEDENT> print ( s ) <NEWLINE>
S = input ( ) <NEWLINE> print ( S . cout ( <STRING> ) - S . count ( <STRING> ) ) <NEWLINE>
s = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 4 ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> s = list ( str ( N ) ) <NEWLINE> S = 0 <NEWLINE> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> S += s [ i ] <NEWLINE> <NL> <DEDENT> if N % S == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> s = list ( str ( n ) ) <NEWLINE> a = n % ( sum ( s ) ) <NEWLINE> <NL> if a == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
def s ( n ) : <NEWLINE> <INDENT> x = 0 <NEWLINE> for i in range ( len ( n ) ) : <NEWLINE> <INDENT> x += int ( n [ i ] ) <NEWLINE> <DEDENT> return x <NEWLINE> <DEDENT> n = input ( ) <NEWLINE> print ( <STRING> ) if n % s ( n ) == 0 else print ( <STRING> ) <NEWLINE>
s = input ( ) <NEWLINE> n = int ( s ) <NEWLINE> m = 0 <NEWLINE> for c in range ( s ) : <NEWLINE> <INDENT> m += int ( c ) <NEWLINE> <DEDENT> print ( <STRING> if n % m == 0 else <STRING> ) <NEWLINE>
a = input ( ) <NEWLINE> b = int ( a ) <NEWLINE> c = list ( a ) <NEWLINE> if b % ( sum ( c ) ) == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = input ( ) <NEWLINE> num = int ( N ) <NEWLINE> Nls = list ( N ) <NEWLINE> sum1 = sum ( [ int ( i ) for in Nls ] ) <NEWLINE> if num % sum1 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = list ( input ( ) ) <NEWLINE> s = sum ( [ int ( n [ i ] ) for i in range ( len ( n ) ) ] ) <NEWLINE> if n % s == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> i = n <NEWLINE> m = 0 <NEWLINE> while i > 0 <NEWLINE> <INDENT> m += i % 10 <NEWLINE> i = i // 10 <NEWLINE> <NL> <DEDENT> if n % m != 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> <NL> def check ( p ) : <NEWLINE> <INDENT> c = 0 <NEWLINE> while p > 0 : <NEWLINE> <INDENT> c += p % 10 <NEWLINE> p //= 10 <NEWLINE> <DEDENT> return c <NEWLINE> <NL> <DEDENT> if n % check ( p ) == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> n = int ( s ) <NEWLINE> m = 0 <NEWLINE> for i in s : <NEWLINE> <INDENT> m += i <NEWLINE> <DEDENT> if n % m == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
nlist = list ( map ( int , input ( ) ) ) <NEWLINE> rev_n = reversed ( nlist ) <NEWLINE> sn = sum ( nlist ) <NEWLINE> n = 0 <NEWLINE> <NL> for i in range ( len ( nlist ) ) : <NEWLINE> <INDENT> n += rev_n [ i ] * ( 10 ** i ) <NEWLINE> <DEDENT> if n % sn == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N2 = N <NEWLINE> sum = 0 <NEWLINE> while True : <NEWLINE> <INDENT> sum += N % 10 <NEWLINE> N = N // 10 <NEWLINE> if N == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> if N2 % sum == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = input ( ) <NEWLINE> <NL> ans = 0 <NEWLINE> for i in N : <NEWLINE> <INDENT> ans += int ( i ) <NEWLINE> <NL> <DEDENT> if N % ans == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = input ( ) <NEWLINE> s = 0 <NEWLINE> for i in range ( len ( n ) ) : <NEWLINE> <INDENT> s += n [ i ] <NEWLINE> <DEDENT> if int ( n ) % s == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> S = 0 <NEWLINE> <NL> for i in range ( len ( str ( N ) ) ) : <NEWLINE> <INDENT> S += int ( str ( S ) [ i ] ) <NEWLINE> <NL> <DEDENT> if N % S == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
num = input ( ) <NEWLINE> j = 0 <NEWLINE> for i in range ( 1 , 10 ) : <NEWLINE> <INDENT> j += num // 10 ^ i <NEWLINE> <DEDENT> print ( num % j == 0 ) <NEWLINE>
n = str ( input ( ) ) <NEWLINE> cnt = 0 <NEWLINE> for i in range ( len ( n ) ) : <NEWLINE> <INDENT> cnt += n [ i ] <NEWLINE> <DEDENT> if int ( n ) % cnt == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
S = input ( ) <NEWLINE> print ( <STRING> [ sum ( map ( int , S ) ) % int ( s ) == 0 : : 2 ] ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> n = list ( str ( N ) ) <NEWLINE> print ( <STRING> if N % ( sum ( n ) == 0 else <STRING> ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = sum ( map ( int , list ( str ( n ) ) ) <NEWLINE> <NL> if n % s == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a = int ( input ( ) ) <NEWLINE> b = sum ( list ( map ( int , list ( str ( a ) ) ) ) ) <NEWLINE> ans = a / b <NEWLINE> print ( <STRING> if ans == o else <STRING> ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> n = N <NEWLINE> flag = True <NEWLINE> S = 0 <NEWLINE> a = 0 <NEWLINE> while flag : <NEWLINE> <INDENT> a = n % 10 <NEWLINE> S += a <NEWLINE> n = n - a // 10 <NEWLINE> if n == 0 : <NEWLINE> <INDENT> flag = False <NEWLINE> <DEDENT> <DEDENT> if N % S == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = input ( ) <NEWLINE> k = list ( map ( int , list ( n ) ) ) <NEWLINE> s = sum ( n ) <NEWLINE> n = int ( n ) <NEWLINE> if n % k : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> <NL> stdin = sys . stdin <NEWLINE> def ns ( ) : return stdin . readline ( ) . rstrip ( ) <NEWLINE> def ni ( ) : return int ( stdin . readline ( ) . rstrip ( ) ) <NEWLINE> def nm ( ) : return map ( int , stdin . readline ( ) . split ( ) ) <NEWLINE> def nl ( ) : return list ( map ( int , stdin . readline ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> n = ni ( ) <NEWLINE> Sn = sum ( list ( str ( n ) ) ) <NEWLINE> print ( <STRING> if n % Sn == 0 else <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
a , b = int ( input ( ) ) <NEWLINE> for x in input ( ) . split ( ) : <NEWLINE> <INDENT> print ( x ) <NEWLINE> <DEDENT>
// <COMMENT> <NEWLINE> // <COMMENT> <NEWLINE> <COMMENT> <NL> using namespace std ; <NEWLINE> typedef long long ll ; <NEWLINE> <NL> int main ( ) { <NEWLINE> <INDENT> cin . tie ( 0 ) ; <NEWLINE> ios : : sync_with_stdio ( false ) ; <NEWLINE> int n , k ; cin >> n >> k ; <NEWLINE> int a [ n ] ; for ( int i = 0 ; i < n ; i + + ) cin >> a [ i ] ; <NEWLINE> cout << ( ( ( n - k ) + ( k - 2 ) ) / ( k - 1 ) ) + 1 << <STRING> ; <NEWLINE> <DEDENT> } <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input . split ( ) ) ) <NEWLINE> <NL> if ( n - 1 ) % % ( k - 1 ) == 0 : <NEWLINE> <INDENT> print ( n - 1 / k - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ( n - 1 // k - 1 ) + 1 ) <NEWLINE> <NL> <NL> <NL> <NL> <NL> <DEDENT>
n , k = map ( int , open ( 0 ) . split ( ) ) <NEWLINE> print ( 0 - - ~ - n // ~ - k ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> import math <NEWLINE> ans = math . ceil ( ( ( n - 1 ) / ( k - 1 ) ) <NEWLINE> print ( ans ) <NEWLINE>
N , K = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> import math <NEWLINE> print ( ceil ( ( N - 1 ) / ( K - 1 ) ) ) <NEWLINE>
n , k = int ( input ( ) . split ( ) ) ; print ( 0 - - ~ - n // ~ - k ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> c = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> d -= 1 <NEWLINE> print ( a // d ) <NEWLINE>
ar = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> i = ar . index ( 1 ) <NEWLINE> count = 0 <NEWLINE> am = 0 <NEWLINE> if i % ( m - 1 ) == 0 : <NEWLINE> <INDENT> count += i // ( m - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> count += i // ( m - 1 ) + 1 <NEWLINE> am += i % ( m - 1 ) <NEWLINE> <DEDENT> if ( n - 1 - i ) % ( m - 1 ) == 0 : <NEWLINE> <INDENT> count += ( n - 1 - i ) // ( m - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> count += ( n - 1 - i ) // ( m - 1 ) + 1 <NEWLINE> am += ( n - 1 - i ) % ( m - 1 ) <NEWLINE> <DEDENT> if am >= m - 1 : <NEWLINE> <INDENT> count -= 1 <NEWLINE> <DEDENT> print ( count ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> l = list ( map ( int , input ( ) ) ) <NEWLINE> <NL> cnt = 1 <NEWLINE> num = k <NEWLINE> while num < n : <NEWLINE> <INDENT> num += ( k - 1 ) <NEWLINE> cnt += 1 <NEWLINE> <NL> <DEDENT> print ( cnt ) <NEWLINE>
index = a . index ( 1 ) <NEWLINE> cnt = 0 <NEWLINE> <NL> if ( n == k ) : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if index <= ( k - 1 ) : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> i = k - 1 <NEWLINE> while i <= ( len ( a ) - 2 ) : <NEWLINE> <INDENT> i += ( k - 1 ) <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> elif index >= ( n - k ) : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> i = n - k <NEWLINE> while i >= 1 : <NEWLINE> <INDENT> i -= ( k - 1 ) <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> i = index <NEWLINE> while i >= 1 : <NEWLINE> <INDENT> i -= ( k - 1 ) <NEWLINE> cnt += 1 <NEWLINE> <NL> <DEDENT> i = index <NEWLINE> while i <= ( len ( a ) - 2 ) : <NEWLINE> <INDENT> i += ( k - 1 ) <NEWLINE> cnt += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> mini = min ( A ) <NEWLINE> idx = N + 1 <NEWLINE> mid = N / 2 <NEWLINE> <NL> for i , a in enumerate ( A ) : <NEWLINE> <INDENT> if a == mini and abs ( idx - mid ) > abs ( i - mid ) : <NEWLINE> <INDENT> idx = i <NEWLINE> <NL> <DEDENT> <DEDENT> ans = i // ( K - 1 ) <NEWLINE> rem = i % ( K - 1 ) <NEWLINE> if rem : <NEWLINE> <INDENT> ans += 1 <NEWLINE> if ( N - i - 1 - ( K - rem ) ) // ( K - 1 ) > 0 : <NEWLINE> <INDENT> ans += ( N - i - 1 - ( K - rem ) ) // ( K - 1 ) <NEWLINE> if ( N - i - 1 - ( K - rem ) ) % ( K - 1 ) != 0 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if ( N - i - 1 ) // ( K - 1 ) > 0 : <NEWLINE> <INDENT> ans += ( N - i - 1 ) // ( K - 1 ) <NEWLINE> if ( N - i - 1 ) % ( K - 1 ) != 0 : : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> <NL> k = int ( input ( ) ) <NEWLINE> <NL> now = 1 <NEWLINE> step = 1 <NEWLINE> <NL> <NL> def sunuke ( n ) : <NEWLINE> <INDENT> r = 0 <NEWLINE> while n : <NEWLINE> <INDENT> r += n % 10 <NEWLINE> n //= 10 <NEWLINE> <DEDENT> return r <NEWLINE> <NL> <NL> <DEDENT> def ok ( a , b ) : <NEWLINE> <INDENT> return a * s ( b ) <= b * s ( a ) <NEWLINE> <NL> <NL> <DEDENT> while k : <NEWLINE> <INDENT> if ok ( now , now + step ) : <NEWLINE> <INDENT> print ( now ) <NEWLINE> k -= 1 <NEWLINE> now += step <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> nstep = step * 10 <NEWLINE> while now % nstep != nstep - 1 : <NEWLINE> <INDENT> now += step <NEWLINE> <DEDENT> step = nstep <NEWLINE> <DEDENT> <DEDENT>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if a = < 8 and b = < 8 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b = int ( input ( ) . split ( ) ) <NEWLINE> if a >= 9 or b >= 9 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b = input ( ) . split ( ) <NEWLINE> a = int ( a ) <NEWLINE> b = int ( b ) <NEWLINE> if a <= 8 : <NEWLINE> <INDENT> if b <= 8 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <INDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if a + b = < 16 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b = map ( int , inuput ( ) . split ( ) ) <NEWLINE> if a >= 8 and b = > 8 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
if int ( input ( ) ) > 8 or int ( input ( ) ) > 8 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b = map ( int , input ( ) ) <NEWLINE> if a > 8 or b > 8 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if a <= 8 and b <= 8 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if a <= 8 ans b <= 8 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N , M = map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if N <= 8 and M <= 8 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b = map ( input ( ) . split ( ) ) <NEWLINE> if a < 8 and b < 8 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if a <= 8 and b <= 8 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b = int ( input . split ( ) ) <NEWLINE> if a <= 8 and b <= 8 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> else : <NEWLINE> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( <STRING> if a > 8 or b > 8 <STRING> ) <NEWLINE>
a , b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if a <= 8 and b <= 8 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> esle : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> for a < 9 and b < 9 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if a < 9 | | b < 9 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( <STRING> if a <= 8 and b <= 8 else : <STRING> ) <NEWLINE>
d , n = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if d = 0 : <NEWLINE> <INDENT> if n <= 99 : <NEWLINE> <INDENT> print ( n ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 101 ) <NEWLINE> <DEDENT> <DEDENT> elif d = 1 : <NEWLINE> <INDENT> if n <= 99 : <NEWLINE> <INDENT> print ( 100 * n ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 10100 ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if n <= 99 : <NEWLINE> <INDENT> print ( 10000 * n ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 1010000 ) <NEWLINE> <DEDENT> <DEDENT>
D , N = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = [ ] <NEWLINE> for i in range ( 10000000 ) : <NEWLINE> <INDENT> if i % ( 100 ** D ) == 0 : <NEWLINE> <INDENT> ans . append ( i ) <NEWLINE> if len ( ans ) == N : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans [ N ] ) <NEWLINE>
0 5 <NEWLINE>
d , n = map ( int , input ( ) . split ( ) ) <NEWLINE> count = 0 <NEWLINE> for i in range ( 0 , 10000 * 100 + 1 ) : <NEWLINE> <INDENT> if i % ( pow ( 100 , d ) ) : <NEWLINE> <INDENT> count += 1 <NEWLINE> if count == n : <NEWLINE> <INDENT> print ( i ) <NEWLINE> return <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
d , n = map ( int , input ( ) . split ( ) ) <NEWLINE> if d == 0 : <NEWLINE> <INDENT> print ( x ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> x = 100 ** d <NEWLINE> print ( x * n ) <NEWLINE>
d , n = map ( int , intput ( ) . split ( ) ) <NEWLINE> print ( n * 10 ** ( 2 * d ) ) <NEWLINE>
D , M = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( ( 100 ** D ) * N ) <NEWLINE>
D , N = input ( ) . split ( ) <NEWLINE> print ( 100 ** D * 5 ) <NEWLINE>
d , n = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if d == 0 : <NEWLINE> <INDENT> if n == 100 : <NEWLINE> <INDENT> print ( 101 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if n == 100 : <NEWLINE> print ( n ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if n == 100 : <NEWLINE> <INDENT> print ( 100 ** d * 101 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 100 ** d * n ) <NEWLINE> <DEDENT> <DEDENT>
d , n = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( n * 100 ** d ) <NEWLINE>
D , N = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> lst = [ ] <NEWLINE> X = <STRING> ** D <NEWLINE> <NL> for i in range ( 1 , 102 ) : <NEWLINE> <INDENT> if i % 100 == 0 : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> lst . append ( str ( i ) + X ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( lst [ N - 1 ] ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in a : <NEWLINE> <INDENT> count += bin ( i ) . rfind ( <STRING> ) - 1 <NEWLINE> <NL> <DEDENT> print ( count ) <NEWLINE>
<COMMENT> <NL> int main ( void ) { <NEWLINE> <INDENT> int n , i ; <NEWLINE> scanf ( <STRING> , & n ) ; <NEWLINE> long long a [ n ] , ans = 0 ; <NEWLINE> for ( i = 0 ; i < n ; i + + ) { <NEWLINE> <INDENT> scanf ( <STRING> , & a [ i ] ) ; <NEWLINE> <DEDENT> } <NEWLINE> for ( i = 0 ; i < n ; i + + ) { <NEWLINE> <INDENT> while ( a [ i ] % 2 == 0 ) { <NEWLINE> <INDENT> a [ i ] += a [ i ] / 2 ; <NEWLINE> ans + + ; <NEWLINE> <DEDENT> } <NEWLINE> <DEDENT> } <NEWLINE> printf ( <STRING> , ans ) ; <NEWLINE> return 0 ; <NEWLINE> <DEDENT> } <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( int , input ( ) . split ( ) ) <NEWLINE> counter = [ ] <NEWLINE> for num in range ( len ( A ) ) : <NEWLINE> <INDENT> counter . append ( 0 ) <NEWLINE> <DEDENT> for num in range ( len ( A ) ) : <NEWLINE> <INDENT> while A [ num ] % 2 == 0 : <NEWLINE> <INDENT> A [ num ] = A [ num ] / 2 <NEWLINE> counter [ num ] += 1 <NEWLINE> <DEDENT> <DEDENT> print ( sum ( counter ) ) <NEWLINE>
def resolve ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> for i in a : <NEWLINE> <INDENT> ans += prime_factorize ( i ) . count ( 2 ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE> <NL> return <NEWLINE> <NL> <DEDENT> resolve ( ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> cnt = 0 <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> while A [ i ] % 2 == 0 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> from fractions import gcd <NEWLINE> from itertools import combinations , permutations , accumulate , product <COMMENT> <NEWLINE> <COMMENT> <NL> from collections import deque , defaultdict , Counter <NEWLINE> import decimal <NEWLINE> import re <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> import sys <NEWLINE> sys . setrecursionlimit ( 10000000 ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <COMMENT> <NL> def readInts ( ) : <NEWLINE> <INDENT> return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <DEDENT> def I ( ) : <NEWLINE> <INDENT> return int ( input ( ) ) <NEWLINE> <DEDENT> n = I ( ) <NEWLINE> A = readInts ( ) <NEWLINE> abc = 1 <NEWLINE> for v in A : <NEWLINE> <INDENT> abc *= v <NEWLINE> <DEDENT> ans = 0 <NEWLINE> while abc % 2 == 0 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> abc //= 2 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> cnt = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> while a [ i ] % 2 = 0 : <NEWLINE> <INDENT> a [ i ] = a [ i ] / 2 <NEWLINE> cnt += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
if contest_num <= 999 : <NEWLINE> <INDENT> print ( <STRING> + str ( contest_num ) . zfill ( 3 ) ) <NEWLINE> <DEDENT> elif contest_num >= 1000 : <NEWLINE> <INDENT> over_thousand_num_fix = contest_num - 999 <NEWLINE> print ( <STRING> + str ( over_thousand_num_fix ) . zfill ( 3 ) ) <NEWLINE> <DEDENT>
<NL> n = input ( ) <NEWLINE> if n < 1000 : <NEWLINE> <INDENT> prnt ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
if 1 <= N < 1000 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> elif 1000 <= N <= 1998 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
name = input ( ) <NEWLINE> if name <= 999 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif name >= 1000 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> n = int ( input ( ) ) <NEWLINE> <NL> if ( n / 1000 ) == 0 : <NEWLINE> <INDENT> print ( <STRING> + n % 1000 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> + ( n % 1000 ) + 1 ) <NEWLINE> <DEDENT>
a = int ( input ( ) ) <NEWLINE> if a < 10 : <NEWLINE> <INDENT> print ( <STRING> + str ( a ) ) <NEWLINE> <DEDENT> elif 10 <= a < 100 : <NEWLINE> <INDENT> print ( <STRING> + str ( a ) ) <NEWLINE> <DEDENT> elif 100 <= a < 1000 : <NEWLINE> <INDENT> print ( <STRING> + str ( a ) ) <NEWLINE> <DEDENT> elif : 1000 <= a < 1010 : <NEWLINE> <INDENT> print ( <STRING> + str ( a ) ) <NEWLINE> <DEDENT> elif : 1010 <= a < 1100 : <NEWLINE> <INDENT> print ( <STRING> + str ( a ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> + str ( a ) ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> <NL> if n < 1000 : <NEWLINE> <INDENT> input ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> input ( <STRING> ) <NEWLINE> <DEDENT>
N = int ( input ( ) . split ( ) ) <NEWLINE> <NL> if N < 1000 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> <NL> s = input ( ) <NEWLINE> <NL> if n < 1000 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> elif 1000 <= n <= 1998 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
moji = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( ( <STRING> , <STRING> ) [ moji >= 1000 ] ) <NEWLINE>
N = input ( ) <NEWLINE> <NL> if N >= 1000 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> <NL> if = 1 < N <= 999 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif 999 < N <= 1998 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> 1 <= N <= 1988 <NEWLINE> <NL> if N <= 999 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else N >= 1000 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b = int ( input ( ) ) <NEWLINE> X = b - a <NEWLINE> ans = 0 <NEWLINE> for i in range ( X ) : <NEWLINE> <INDENT> ans += i <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> sum = 0 <NEWLINE> for i in range ( 1 , 1000 ) : <NEWLINE> while ( a > sum ) : <NEWLINE> <INDENT> i = 1 <NEWLINE> <INDENT> sum += 1 <NEWLINE> i += 1 <NEWLINE> <DEDENT> <DEDENT> print ( sum - a ) <NEWLINE> <NL>
def Gauss_sum ( n ) : <NEWLINE> <INDENT> return n * ( n + 1 ) // 2 <NEWLINE> <DEDENT> a , b = map ( int , input ( ) ) <NEWLINE> for i in range ( 999 ) : <NEWLINE> <INDENT> if Gauss_sum ( i + 1 ) - a == Gauss_sum ( i + 2 ) - b : <NEWLINE> <INDENT> print ( Gauss_sum ( i + 1 ) - a ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT>
import itertools <NEWLINE> <NL> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> l = itertools . accumulate ( [ 1 ] * 999 ) <NEWLINE> print ( l [ m - n - 1 ] - m ) <NEWLINE>
L = [ 1 ] <NEWLINE> n = int ( input ( ) ) <NEWLINE> x = 6 <NEWLINE> y = 9 <NEWLINE> while x <= n : <NEWLINE> <INDENT> L . append ( x ) <NEWLINE> x *= 6 <NEWLINE> <DEDENT> while y <= n : <NEWLINE> <INDENT> L . append ( y ) <NEWLINE> y *= 9 <NEWLINE> <DEDENT> L . sort ( ) <COMMENT> <NEWLINE> dp = [ float ( <STRING> ) ] * ( n + 1 ) <NEWLINE> dp [ 0 ] = 0 <NEWLINE> for i in range ( n + 1 ) : <COMMENT> <NEWLINE> <INDENT> for j in L : <COMMENT> <NEWLINE> <INDENT> dp [ i + j ] = min ( dp [ i + j ] , dp [ i ] + 1 ) <COMMENT> <NEWLINE> <DEDENT> <DEDENT> print ( dp [ n ] ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> six = [ 6 ** i for i in range ( 7 ) ] <NEWLINE> nine = [ 9 ** i for i in range ( 6 ) ] <NEWLINE> L = [ ] <NEWLINE> for s in six : <NEWLINE> <INDENT> L . append ( s ) <NEWLINE> <DEDENT> for s in nine [ 1 : ] : <NEWLINE> <INDENT> L . append ( s ) <NEWLINE> <DEDENT> L . sort ( reverse = True ) <NEWLINE> ans = 0 <NEWLINE> for l in L : <NEWLINE> <INDENT> while N > 0 : <NEWLINE> <INDENT> ans += N // l <NEWLINE> N %= l <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from itertools import combinations <NEWLINE> n , C = map ( int , input ( ) . split ( ) ) <NEWLINE> d = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( C ) ] <NEWLINE> c = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ] <NEWLINE> a = [ [ 0 ] * C for _ in range ( 3 ) ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( n ) : <NEWLINE> <INDENT> a [ ( i + j ) % 3 ] [ c [ i ] [ j ] - 1 ] += 1 <NEWLINE> <DEDENT> <DEDENT> ans = 10 ** 9 <NEWLINE> for v in combinations ( range ( C ) , 3 ) : <NEWLINE> <INDENT> tmp = 0 <NEWLINE> for i in range ( 3 ) : <NEWLINE> <INDENT> for j in range ( 30 ) : <NEWLINE> <INDENT> tmp += a [ i ] [ j ] * d [ j ] [ v [ i ] ] <NEWLINE> <DEDENT> <DEDENT> ans = min ( ans , tmp ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> <NL> M = 10 ** 9 <NEWLINE> for i in range ( 1 , N // 2 + 10 ) : <NEWLINE> <INDENT> a = list ( str ( i ) ) <NEWLINE> b = list ( str ( N - i ) ) <NEWLINE> <COMMENT> <NL> k = 0 <NEWLINE> for q in range ( len ( a ) ) : <NEWLINE> <INDENT> k += int ( a [ q ] ) <NEWLINE> <DEDENT> for p in range ( len ( b ) ) : <NEWLINE> <INDENT> k += int ( b [ p ] ) <NEWLINE> <DEDENT> M = min ( M , k ) <NEWLINE> <DEDENT> print ( M ) <NEWLINE>
I , i , R = input , int , range <NEWLINE> n , L , R , A , C = i ( I ( ) ) , [ ] , [ ] , 0 , 0 <NEWLINE> for _ in R ( n ) : l , r = map ( i , I ( ) . split ( ) ) ; L += [ l ] ; R += [ r ] <NEWLINE> L = sorted ( l ) [ : : - 1 ] ; R . sort ( ) <NEWLINE> for j in R ( n ) : C += ( L [ j ] - R [ j ] ) * 2 ; A = max ( A , C ) <NEWLINE> print ( A ) <NEWLINE>
<COMMENT> <NL> import numpy as np <NEWLINE> from card3 . void . stop_watch import stop_watch <NEWLINE> <NL> @ stop_watch <NEWLINE> def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> L , R = [ ] , [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> L . append ( l ) <NEWLINE> R . append ( r ) <NEWLINE> <DEDENT> ll = np . array ( L ) ; ll . sort ( ) ; ll = ll [ : : - 1 ] <NEWLINE> rr = np . array ( R ) ; rr . sort ( ) <NEWLINE> <NL> lll = ll . cumsum ( ) <NEWLINE> rrr = rr . cumsum ( ) <NEWLINE> <NL> x = ( lll - rrr ) . max ( ) <NEWLINE> y = ( lll [ 1 : ] - rrr [ : - 1 ] ) . max ( ) <NEWLINE> z = ( lll [ : - 1 ] - rrr [ 1 : ] ) . max ( ) <NEWLINE> <NL> print ( 2 * max ( x , y , z ) ) <NEWLINE> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( max ( A + B , A - B , A * B ) ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( max ( a + b , max ( a - b , a * b ) ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( max ( a + b , a = b , a * b ) ) <NEWLINE>
A , B = max ( int , input ( ) . split ( ) ) <NEWLINE> print ( max ( A + B , A - B , A * B ) ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( max ( a + b , a - b , a * b ) <NEWLINE>
a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> k = max ( a + b , a - b ) <NEWLINE> <NL> print ( k ) <NEWLINE>
a , b = map ( imt , input ( ) . split ( ) ) <NEWLINE> print ( max ( a + b , a * b , a - b ) ) <NEWLINE>
a , b , c = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> my_result = max ( a + b , a - b , a * b ) <NEWLINE> print ( my_result ) <NEWLINE>
a , b = map ( inr , input ( ) . split ( ) ) <NEWLINE> print ( max ( [ a + b , a - b , a * b ] ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> <NL> def f ( s , t ) : <NEWLINE> <INDENT> set_s = set ( ) <NEWLINE> set_t = set ( ) <NEWLINE> for i in s : <NEWLINE> <INDENT> set_s . add ( i ) <NEWLINE> <DEDENT> for i in t : <NEWLINE> <INDENT> set_t . add ( i ) <NEWLINE> <DEDENT> return len ( set_s & set_t ) <NEWLINE> <NL> <DEDENT> for i in range ( 1 , N ) : <NEWLINE> <INDENT> s = S [ i : ] <NEWLINE> t = S [ : i ] <NEWLINE> ans = max ( ans , f ( s , t ) ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> maxa = - 10 <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> a = set ( L [ : i + 1 ] ) <NEWLINE> b = set ( [ i + 1 : ] ) <NEWLINE> maxa = max ( maxa , len ( a & b ) ) <NEWLINE> <DEDENT> print ( maxa ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> ans = 0 <NEWLINE> a = [ 0 ] * 26 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> a [ ord ( S [ i ] ) - ord ( <STRING> ) ] += 1 <NEWLINE> <NL> <DEDENT> b = [ 0 ] * 26 <NEWLINE> for i in range ( 26 ) : <NEWLINE> <INDENT> a [ ord ( S [ i ] ) - ord ( <STRING> ) ] -= 1 <NEWLINE> b [ ord ( S [ i ] ) - ord ( <STRING> ) ] += 1 <NEWLINE> cnt = 0 <NEWLINE> for j in range ( 26 ) : <NEWLINE> <INDENT> if a [ j ] * b [ j ] > 0 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> ans = max ( ans , cnt ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S = input <NEWLINE> <NL> ans = 1 <NEWLINE> <NL> for i in range ( 1 , N ) : <NEWLINE> <INDENT> X = S [ : i ] <NEWLINE> Y = S [ i : ] <NEWLINE> setX = set ( X ) <NEWLINE> setY = set ( Y ) <NEWLINE> intersectionXY = setX & setY <NEWLINE> _temp = len ( intersectionXY ) <NEWLINE> if _temp > ans : <NEWLINE> <INDENT> ans = _temp <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> w = set ( s ) <NEWLINE> t = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if s . count ( w [ i ] ) >= 2 : <NEWLINE> <INDENT> t += 1 <NEWLINE> <DEDENT> <DEDENT> print ( t ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> a = s . count ( <STRING> ) <NEWLINE> c = a <NEWLINE> <NL> for s in S : <NEWLINE> <INDENT> if s == <STRING> : <NEWLINE> <INDENT> c -= 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> c += 1 <NEWLINE> <DEDENT> a = min ( a , c ) <NEWLINE> <NL> <DEDENT> print ( a ) <NEWLINE>
e = S . count ( <STRING> ) <NEWLINE> cnt = e <NEWLINE> for i in S : <NEWLINE> <INDENT> if i == <STRING> : <NEWLINE> <INDENT> cnt -= 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> e = min ( e , cnt ) <NEWLINE> <DEDENT> print ( e ) <NEWLINE>
import sys <NEWLINE> input ( ) <NEWLINE> d = { k : 0 for k in <STRING> . split ( ) } <NEWLINE> for ln in sys . stdin : <NEWLINE> <INDENT> d [ ln . strip ( ) ] += 1 <NEWLINE> <DEDENT> for k , v in d . items ( ) : <NEWLINE> <INDENT> print ( k , <STRING> , v ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> S = list ( input ( ) ) <NEWLINE> <NL> CNT = [ ] <NEWLINE> c = 0 <NEWLINE> for s in S : <NEWLINE> <INDENT> if s == <STRING> : <NEWLINE> <INDENT> c += 1 <NEWLINE> <DEDENT> CNT . append ( c ) <NEWLINE> <NL> <DEDENT> ans = N + 10 <NEWLINE> mn = N + 10 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> c = 0 <NEWLINE> if i > 0 : <NEWLINE> <INDENT> c += i - 1 - CNT [ i - 1 ] <NEWLINE> <DEDENT> if i < N - 1 : <NEWLINE> <INDENT> c += N - i - 1 - ( CNT [ N ] - CNT [ i + 1 ] ) <NEWLINE> <NL> <DEDENT> if c < mn : <NEWLINE> <INDENT> ans = i + 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL>
A , B , C , K = map ( int , split ( ) . input ( ) ) <NEWLINE> print ( A - B if K % 2 == 0 else B - A ) <NEWLINE>
if K % 2 == 0 : <NEWLINE> <INDENT> ans = A - B <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = B - A <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
a , b , c , k = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> ans = a - b <NEWLINE> <NL> if ( k % 2 == 1 ) : <NEWLINE> <INDENT> ans = abs ( ans ) <NEWLINE> <NL> <DEDENT> if ( len ( ans ) >= 18 ) : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
a , b , c , k = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if k % 2 == 0 and abs ( a - b ) <= 10 ** 8 : print ( a - b ) <NEWLINE> elif k % 2 != 0 abs ( b - a ) <= 10 ** 8 : print ( b - a ) <NEWLINE> else : print ( <STRING> ) <NEWLINE>
A , B , C , K = input ( ) . split ( <STRING> ) <NEWLINE> A = int ( A ) <NEWLINE> B = int ( B ) <NEWLINE> C = int ( C ) <NEWLINE> K = int ( K ) <NEWLINE> while True : <NEWLINE> <INDENT> if A == B == C : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> break <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( K ) : <NEWLINE> <INDENT> a = B + C <NEWLINE> b = A + C <NEWLINE> c = A + B <NEWLINE> A = a <NEWLINE> B = b <NEWLINE> C = c <NEWLINE> <DEDENT> if A - B > 10 ** 18 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( A - B ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
A , B , C , K = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( A - B ) if k % 2 == 0 else print ( B - A ) <NEWLINE>
print ( ( - 1 ) ** k * ( a - b ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> p = [ int ( input ( ) ) for _ in range ( n ) ] <NEWLINE> <NL> q = [ 0 ] * ( n + 1 ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> q [ p [ i ] ] = q [ p [ i ] - 1 ] + 1 <NEWLINE> <NL> <DEDENT> print ( q - max ( q ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> l = [ int ( input ( ) ) for _ in range ( n ) ] <NEWLINE> ans = 0 <NEWLINE> if l [ 0 ] != 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> for i in range ( n - 1 ) : <NEWLINE> <INDENT> if l [ i + 1 ] - l [ i ] > 1 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> elif ( l [ i ] + 1 == l [ i + 1 ] ) : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> else : <NEWLINE> ans += l [ i + 1 ] <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
a , b , c , d = map ( int , input ( ) . split ) <NEWLINE> k1 = abs ( a - b ) <NEWLINE> k2 = abs ( a - c ) <NEWLINE> k3 = abs ( b - c ) <NEWLINE> if k2 <= d : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif k1 <= d or k3 <= d : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b , c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> a = <STRING> <NEWLINE> if abs ( a - c ) > d : <NEWLINE> <INDENT> if abs ( a - b ) > d or abs ( b - c ) > d : <NEWLINE> <INDENT> a = <STRING> <NEWLINE> <DEDENT> <DEDENT> print ( a ) <NEWLINE>
if abs ( c - a ) <= d : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif abs ( b - a ) <= d and abs ( c - b ) <= d : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a = int ( input ( ) ) <NEWLINE> b = int ( input ( ) ) <NEWLINE> c = int ( input ( ) ) <NEWLINE> d = int ( input ( ) ) <NEWLINE> <NL> x = abs ( a - b ) <NEWLINE> y = abs ( b - c ) <NEWLINE> z = abs ( a - c ) <NEWLINE> <NL> if x <= d and y <= d : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif x > d and z <= d : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a = int ( input ( ) ) <NEWLINE> b = int ( input ( ) ) <NEWLINE> c = int ( input ( ) ) <NEWLINE> d = int ( input ( ) ) <NEWLINE> <NL> <COMMENT> <NL> if abs ( c - a ) <= d : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> elif abs ( b - a ) <= d and abs ( c - b ) <= d : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a = int ( input ( ) ) <NEWLINE> b = int ( input ( ) ) <NEWLINE> c = int ( input ( ) ) <NEWLINE> d = int ( input ( ) ) <NEWLINE> if abs ( c - a ) <= d : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif abs ( b - a ) <= d and abs ( c - b ) <= d : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
<COMMENT> <NL> a , b , c , d = map ( int , input ( ) . split ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> if abs ( a - c ) <= d : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <COMMENT> <NL> <DEDENT> elif abs ( a - b ) <= d and abs ( b - c ) <= d : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <COMMENT> <NL> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a = int ( input ( ) ) <NEWLINE> b = int ( input ( ) ) <NEWLINE> c = int ( input ( ) ) <NEWLINE> d = int ( input ( ) ) <NEWLINE> <NL> if abs ( a - c ) <= d : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif ( abs ( a - b ) <= d ) and ( abs ( b - c ) <= d ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b , c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if e ( a - b ) <= d and e ( b - c ) <= d or e ( a - c ) <= d : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a = int ( input ( ) ) <NEWLINE> b = int ( input ( ) ) <NEWLINE> c = int ( input ( ) ) <NEWLINE> d = int ( input ( ) ) <NEWLINE> <NL> if abs ( a - c ) <= d : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif ( a < b and b < c ) or ( a > b and b > c ) : <NEWLINE> <INDENT> if abs ( a - b ) <= d and abs ( b - c ) <= d : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
x = int ( input ( ) ) <NEWLINE> if x == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for b in range ( 2 , int ( x ** ( 1 / 2 ) + 1 ) ) : <NEWLINE> <INDENT> for p in range ( 2 , 1000 ) : <NEWLINE> <INDENT> tmp = pow ( b , p ) <NEWLINE> if tmp <= x : <NEWLINE> <INDENT> ans = max ( ans , pow ( b , p ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
if d >= z : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif d >= x and d >= y : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
if d >= abs ( a - c ) or ( d >= abs ( a - b ) and d >= abs ( b - c ) ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> a , b , c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> if abs ( a - c ) <= d or abs ( a - b ) + abs ( b - c ) <= d : <NEWLINE> <DEDENT> main ( ) <NEWLINE>
a , b , c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> AB = abs ( a - b ) <NEWLINE> BC = abs ( b - c ) <NEWLINE> AC = abs ( a - c ) <NEWLINE> <NL> if AC <= d or ( AB <= d and BC <= d : ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b , c , d = map ( int , input ( ) , split ( ) ) <NEWLINE> <NL> if abs ( a - c ) <= d : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> elif abs ( a - b ) <= d and abs ( b - c ) <= d : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT>
a , b , c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( [ <STRING> , <STRING> ] [ abs ( a - c ) <= d or ( abs ( a - b ) <= d and abs ( b - c ) <= d ] ) <NEWLINE>
a , b , c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if a - d <= c <= a + d : <NEWLINE> <INDENT> print ( <STRING> ) : <NEWLINE> <DEDENT> elif a - d <= b <= a + d and c - d <= b <= c + d : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
data = input ( ) <NEWLINE> <NL> dataa , datab , datac , datad = data . split ( <STRING> ) <NEWLINE> <NL> dataa = int ( dataa ) <NEWLINE> datab = int ( datab ) <NEWLINE> datac = int ( datac ) <NEWLINE> datad = int ( datad ) <NEWLINE> <NL> length1 = dataa - datab <NEWLINE> length2 = datab - datac <NEWLINE> length11 = abs ( length1 ) + abs ( length2 ) <NEWLINE> length3 = dataa - datac <NEWLINE> <NL> if abs ( length1 ) < >= datad : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif abs ( length2 ) <= datad : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif abs ( length11 ) <= datad : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
A , B , C , D = int ( input ( ) ) <NEWLINE> <NL> if D >= A + C : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif D >= A + B : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a = int ( input ( ) ) <NEWLINE> b = int ( input ( ) ) <NEWLINE> c = int ( input ( ) ) <NEWLINE> d = int ( input ( ) ) <NEWLINE> <NL> if c - a <= d : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif b - a <= d and c - b <= d : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
if abs ( a - c ) <= d : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> elif abs ( b - c ) <= d and abs ( a - b ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
if abs ( a - c ) <= d : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif abs ( a - b ) <= d and abs ( b - c ) <= d : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a = int ( input ( ) ) <NEWLINE> b = int ( input ( ) ) <NEWLINE> c = int ( input ( ) ) <NEWLINE> d = int ( input ( ) ) <NEWLINE> <NL> if c - a <= d : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif b - a <= d and c - b <= d : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a = input ( ) <NEWLINE> b = input ( ) <NEWLINE> c = input ( ) <NEWLINE> d = input ( ) <NEWLINE> <NL> ab = a - b <NEWLINE> bc = b - c <NEWLINE> ac = a - c <NEWLINE> <NL> if a <= b <= c <= or c < b < a : <NEWLINE> <INDENT> if ab <= d and bc <= d or ac <= d : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if ac <= d : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
<NL> a = int ( input ( ) ) <NEWLINE> b = int ( input ( ) ) <NEWLINE> c = int ( input ( ) ) <NEWLINE> d = int ( input ( ) ) <NEWLINE> <NL> if abs ( b - a ) < d and abs ( c - b ) < d : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <DEDENT>
a = int ( input ( ) ) <NEWLINE> n = [ ] <NEWLINE> for i in range ( 2 , 10 ) : <NEWLINE> <INDENT> for j in range ( 32 ) : <NEWLINE> if j ** i <= a : <NEWLINE> <INDENT> n . append ( j ** i ) <NEWLINE> <DEDENT> <DEDENT> print ( max ( n ) ) <NEWLINE>
l = [ 0 , 1 , 0 , 0 , 1 , 0 , 0 , 0 , 1 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 , 1 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 1 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 ] <NEWLINE> for i in range ( int ( input ) - 1 , 0 , - 1 ) : <NEWLINE> <INDENT> if l [ i ] == 1 : print ( i ) ; break <NEWLINE> <DEDENT>
import math <NEWLINE> x = int ( input ( ) ) <NEWLINE> ans = ( int ( math . sqrt ( X ) ) ) ** 2 <NEWLINE> for i in range ( 2 , int ( math . sqrt ( x ) ) + 2 ) : <NEWLINE> <INDENT> for j in range ( 1 , 10 ) : <NEWLINE> <INDENT> if i ** j <= x and i ** j > ans : <NEWLINE> <INDENT> ans = i ** j <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL>
X = int ( input ( ) ) <NEWLINE> res = [ ] <NEWLINE> for b in range ( 1 , 1000 ) : <NEWLINE> <INDENT> for p in range ( 2 , 1000 ) : <NEWLINE> <INDENT> if b ** p <= X : <NEWLINE> <INDENT> res . append ( b ** p ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( res [ - 1 ] ) <NEWLINE>
X = int ( input ( ) ) <NEWLINE> <NL> if X == 1 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> <NL> for b in range ( 2 , int ( x ** 0.5 ) + 2 ) : <NEWLINE> <INDENT> temp = b <NEWLINE> while temp <= X : <NEWLINE> <INDENT> ans = max ( ans , temp ) <NEWLINE> temp *= b <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> <NL> X = int ( sys . stdin . readline ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( X + 1 ) : <NEWLINE> <INDENT> for j in range ( 11 ) : <NEWLINE> <INDENT> tmp = pow ( i , j ) <NEWLINE> if tmp <= X : <NEWLINE> <INDENT> ans = max ( ans , tmp ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> def main ( ) : <NEWLINE> <INDENT> x = int ( input ( ) ) <NEWLINE> sum = 0 <NEWLINE> if x == 0 or x == 1 : <NEWLINE> <INDENT> sum = x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( 2 , int ( math . sqrt ( x ) ) + 1 ) : <NEWLINE> <INDENT> j = 2 <NEWLINE> while True : <NEWLINE> <INDENT> if pow ( i , j ) <= x : <NEWLINE> <INDENT> if pow ( i , j ) > sum : <NEWLINE> <INDENT> sum = pow ( i , j ) <NEWLINE> else : <NEWLINE> <DEDENT> break <NEWLINE> j += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( sum ) <NEWLINE> <DEDENT> main ( ) <NEWLINE>
x = int ( input ( ) ) <NEWLINE> for b in range ( 1 , x ) : <NEWLINE> <INDENT> for p in range ( 2 , x ) : <NEWLINE> <INDENT> if b ** p <= x : c = max ( c , b ** p ) <NEWLINE> else : break <NEWLINE> <DEDENT> <DEDENT> print ( c ) <NEWLINE>
x = int ( input ( ) ) <NEWLINE> if x <= 3 : <NEWLINE> <INDENT> print ( 1 ) : <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a = [ ] <NEWLINE> for i in range ( 2 , x + 1 ) : <NEWLINE> <INDENT> j = 2 <NEWLINE> while i ** j < x : <NEWLINE> <INDENT> a . append ( i ** j ) <NEWLINE> <DEDENT> <DEDENT> print ( max ( a ) ) <NEWLINE> <DEDENT>
import math <NEWLINE> <NL> res = 1 <NEWLINE> for b in range ( 2 , math . ceil ( math . sqrt ( x ) ) ) : <NEWLINE> <INDENT> p = 2 <NEWLINE> while b ** ( p + 1 ) <= x : <NEWLINE> <INDENT> p += 1 <NEWLINE> <DEDENT> res = max ( res , b ** p ) <NEWLINE> <DEDENT> print ( res ) <NEWLINE>
A = int ( input ( ) ) <NEWLINE> B = [ 1 ] * 8 <NEWLINE> for i in range ( 2 , 10 ) : <NEWLINE> <INDENT> for j in range ( A + 1 ) : <NEWLINE> <INDENT> if j ** i <= A : <NEWLINE> <INDENT> B [ i - 2 ] = j ** i <NEWLINE> <DEDENT> else : break <NEWLINE> <DEDENT> <DEDENT> B = B . sort ( ) <NEWLINE> print ( B [ - 1 ] ) <NEWLINE>
a = int ( input ( ) ) <NEWLINE> d = 0 <NEWLINE> for i in range ( 33 ) : <NEWLINE> <INDENT> b = i <NEWLINE> while b < a : <NEWLINE> <INDENT> b = b * i <NEWLINE> <DEDENT> c = b / i <NEWLINE> if d > c : <NEWLINE> <INDENT> d = c <NEWLINE> <DEDENT> <DEDENT> print ( d ) <NEWLINE>
x = int ( input ( ) ) <NEWLINE> <NL> if x == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <NL> <DEDENT> def func ( p ) : <NEWLINE> <INDENT> q = p <NEWLINE> while q < x : <NEWLINE> <INDENT> q *= p <NEWLINE> if q == x : <NEWLINE> <INDENT> return q <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if q / p == p : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return q / p <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> z = [ ] <NEWLINE> a = 1 <NEWLINE> <NL> while a <= x : <NEWLINE> <INDENT> z . append ( func ( a ) ) <NEWLINE> a += 1 <NEWLINE> <NL> <DEDENT> print ( max ( z ) ) <NEWLINE>
import math <NEWLINE> <NL> x = int ( input ( ) ) <NEWLINE> ans = [ 1 ] <NEWLINE> s = int ( math . sqrt ( x ) ) <NEWLINE> if s >= 2 : <NEWLINE> <INDENT> for i in range ( 2 , s + 1 ) : <NEWLINE> <INDENT> temp = i <NEWLINE> while True : <NEWLINE> <INDENT> temp *= i <NEWLINE> if temp <= n : <NEWLINE> <INDENT> ans . append ( temp ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( max ( ans ) ) <NEWLINE>
s = input ( ) <NEWLINE> K = int ( input ( ) ) <NEWLINE> p = set ( ) <NEWLINE> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> for j in range ( 1 , 6 ) : <NEWLINE> <INDENT> if i + j <= len ( s ) - 1 : <NEWLINE> <INDENT> p . add ( s [ i : j + i ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> p = sorted ( p ) <NEWLINE> print ( p [ K - 1 ] ) <NEWLINE>
s = input ( ) <NEWLINE> n = len ( s ) <NEWLINE> t = int ( input ( ) ) <NEWLINE> if t == 1 : <NEWLINE> <INDENT> print ( s ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> ans = set ( ) <NEWLINE> for l in range ( n - 1 ) : <NEWLINE> <INDENT> for r in range ( 1 , min ( t , n - l ) ) : <NEWLINE> <INDENT> ans . add ( s [ l : r ] ) <NEWLINE> <DEDENT> <DEDENT> aa = list ( ans ) <NEWLINE> aa . sort ( ) <NEWLINE> print ( aa [ t - 1 ] ) <NEWLINE>
def main2 ( ) : <NEWLINE> <INDENT> S = list ( input ( ) ) <NEWLINE> K = int ( input ( ) ) <NEWLINE> N = len ( S ) <NEWLINE> <NL> P = sorted ( S ) <NEWLINE> l = [ ] <NEWLINE> k = 0 <NEWLINE> while len ( l ) <= 5 : <NEWLINE> <INDENT> for n in range ( N ) : <NEWLINE> <INDENT> if S [ n ] == P [ k ] : <NEWLINE> <INDENT> for i in range ( 1 , 6 ) : <NEWLINE> <INDENT> if n + i < N - 1 : <NEWLINE> <INDENT> tmp = <STRING> . join ( S [ n : n + i ] ) <NEWLINE> if tmp not in l : <NEWLINE> <INDENT> l . append ( tmp ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> k += 1 <NEWLINE> <DEDENT> l . sort ( ) <NEWLINE> print ( l [ K - 1 ] ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main2 ( ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> k = int ( input ( ) ) <NEWLINE> a = [ ] <NEWLINE> <NL> for i in range ( 5 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , len ( s ) ) : <NEWLINE> <INDENT> if j - i >= 5 : break <NEWLINE> a . append ( s [ i : j ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> res = sorted ( set ( a ) ) <NEWLINE> print ( res [ k - 1 ] ) <NEWLINE>
class uft ( ) : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . p = [ - 1 for i in range ( n ) ] <NEWLINE> self . r = [ 1 for i in range ( n ) ] <NEWLINE> <NL> <DEDENT> def find ( self , x ) : <NEWLINE> <INDENT> if ( self . p [ x ] == - 1 ) : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . p [ x ] = self . find ( self . p [ x ] ) <NEWLINE> return self . find ( self . p [ x ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> def unite ( self , x , y ) : <NEWLINE> <INDENT> x = self . find ( x ) <NEWLINE> y = self . find ( y ) <NEWLINE> if ( self . r [ x ] > self . r [ y ] ) : <NEWLINE> <INDENT> tmp = x <NEWLINE> x = y <NEWLINE> y = tmp <NEWLINE> <NL> <DEDENT> if ( self . r [ x ] == self . r [ y ] ) : <NEWLINE> <INDENT> self . r [ y ] += 1 <NEWLINE> <NL> <DEDENT> if ( x != y ) : <NEWLINE> <INDENT> self . p [ x ] = y <NEWLINE> <DEDENT> return <NEWLINE> <NL> <DEDENT> <DEDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> uf = uft ( n ) <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> x -= 1 <NEWLINE> y -= 1 <NEWLINE> uf . unite ( x , y ) <NEWLINE> <DEDENT> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if ( uf . find ( i ) == uf . find ( p [ i ] ) ) : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from numba import jit <NEWLINE> <NL> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> class UnionFind ( ) : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . n = n <NEWLINE> self . parents = [ - 1 ] * n <NEWLINE> <NL> <DEDENT> def find ( self , x ) : <NEWLINE> <INDENT> if self . parents [ x ] < 0 : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . parents [ x ] = self . find ( self . parents [ x ] ) <NEWLINE> return self . parents [ x ] <NEWLINE> <NL> <DEDENT> <DEDENT> def union ( self , x , y ) : <NEWLINE> <INDENT> x = self . find ( x ) <NEWLINE> y = self . find ( y ) <NEWLINE> <NL> if x == y : <NEWLINE> <INDENT> return <NEWLINE> <NL> <DEDENT> if self . parents [ x ] > self . parents [ y ] : <NEWLINE> <INDENT> x , y = y , x <NEWLINE> <NL> <DEDENT> self . parents [ x ] += self . parents [ y ] <NEWLINE> self . parents [ y ] = x <NEWLINE> <DEDENT> @ jit <NEWLINE> def members ( self , x ) : <NEWLINE> <INDENT> root = self . find ( x ) <NEWLINE> return [ i for i in range ( self . n ) if self . find ( i ) == root ] <NEWLINE> <NL> <DEDENT> def roots ( self ) : <NEWLINE> <INDENT> return [ i for i , x in enumerate ( self . parents ) if x < 0 ] <NEWLINE> <NL> <DEDENT> <DEDENT> uf = UnionFind ( n ) <NEWLINE> <NL> for i in range ( m ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> x -= 1 <NEWLINE> y -= 1 <NEWLINE> uf . union ( x , y ) <NEWLINE> <DEDENT> ans = 0 <NEWLINE> <NL> ro = uf . roots ( ) <NEWLINE> <NL> for i in ro : <NEWLINE> <INDENT> mem = uf . members ( i ) <NEWLINE> for j in mem : <NEWLINE> <INDENT> if p [ j ] - 1 in mem : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL>
n , m , p = map ( int , input ( ) . split ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> par = [ i for i in range ( n ) ] <NEWLINE> <NL> def find ( x ) : <NEWLINE> <INDENT> if par [ x ] == x : <NEWLINE> <INDENT> return par [ x ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> par [ x ] = find ( par [ x ] ) <NEWLINE> return par [ x ] <NEWLINE> <NL> <DEDENT> <DEDENT> def union ( x , y ) : <NEWLINE> <INDENT> fx = find ( x ) <NEWLINE> fy = find ( y ) <NEWLINE> if fx != fy : <NEWLINE> <INDENT> par [ fx ] = fy <NEWLINE> <NL> <DEDENT> <DEDENT> f = lambda x : int ( x ) - 1 <NEWLINE> for mm in range ( m ) : <NEWLINE> <INDENT> x , y = map ( f , input ( ) . split ( ) ) <NEWLINE> union ( x , y ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if find ( p [ i ] ) == i : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
s = input ( ) <NEWLINE> K = int ( input ( ) ) <NEWLINE> <NL> ans_list = [ ] <NEWLINE> for i in range ( len ( s ) - K + 1 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , i + K + 1 ) : <NEWLINE> <INDENT> ans_list . append ( s [ i : j ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> ans_set = set ( ans_list ) <NEWLINE> ans_list_min = sorted ( list ( ans_set ) ) <NEWLINE> print ( ans_list_min [ K - 1 ] ) <NEWLINE>
import bisect , collections , copy , heapq , itertools , math , string , sys <NEWLINE> input = lambda : sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> INF = float ( <STRING> ) <NEWLINE> def I ( ) : return int ( input ( ) ) <NEWLINE> def F ( ) : return float ( input ( ) ) <NEWLINE> def SS ( ) : return input ( ) <NEWLINE> def LI ( ) : return [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> def LI_ ( ) : return [ int ( x ) - 1 for x in input ( ) . split ( ) ] <NEWLINE> def LF ( ) : return [ float ( x ) for x in input ( ) . split ( ) ] <NEWLINE> def LSS ( ) : return input ( ) . split ( ) <NEWLINE> <NL> def resolve ( ) : <NEWLINE> <INDENT> N , A , B , C , D = LI ( ) <NEWLINE> A -= 1 <NEWLINE> B -= 1 <NEWLINE> C -= 1 <NEWLINE> D -= 1 <NEWLINE> S = SS ( ) <NEWLINE> <NL> <COMMENT> <NL> if <STRING> in S [ A : C + 1 ] or <STRING> in S [ B : D + 1 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <COMMENT> <NL> <INDENT> if C < D : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <COMMENT> <NL> <DEDENT> else : <NEWLINE> <COMMENT> <NL> <INDENT> if <STRING> in S [ B : D + 1 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> resolve ( ) <NEWLINE> <DEDENT>
, <COMMENT> <NEWLINE> s = input ( ) + <STRING> <NEWLINE> k = int ( input ( ) ) <NEWLINE> ans = [ ] <NEWLINE> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> for j in range ( i + 1 , min ( len ( s ) , i + 5 + 1 ) ) : <NEWLINE> <INDENT> t = <STRING> . join ( s [ i : j ] ) <NEWLINE> if t not in ans : <NEWLINE> <INDENT> ans . append ( t ) <NEWLINE> ans = sorted ( ans ) [ : 6 ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans [ k - 1 ] ) <NEWLINE>
import sys <NEWLINE> readline = sys . stdin . readline <NEWLINE> <NL> class UnionFind ( object ) : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . _par = list ( range ( n ) ) <NEWLINE> self . size = [ 1 ] * n <NEWLINE> <NL> <DEDENT> def root ( self , v ) : <NEWLINE> <INDENT> if self . _par [ v ] == v : <NEWLINE> <INDENT> return v <NEWLINE> <DEDENT> self . _par [ v ] = self . root ( self . _par [ v ] ) <NEWLINE> return self . _par [ v ] <NEWLINE> <NL> <DEDENT> def unite ( self , u , v ) : <NEWLINE> <INDENT> u , v = self . root ( u ) , self . root ( v ) <NEWLINE> if u == v : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> if self . size [ u ] > self . size [ v ] : <NEWLINE> <INDENT> u , v = v , u <NEWLINE> <DEDENT> self . size [ v ] += self . size [ u ] <NEWLINE> self . _par [ u ] = v <NEWLINE> <NL> <DEDENT> def is_connected ( self , u , v ) : <NEWLINE> <INDENT> return self . root ( u ) == self . root ( v ) <NEWLINE> <NL> <DEDENT> <DEDENT> n , m = map ( int , readline ( ) . split ( ) ) <NEWLINE> P = list ( map ( lambda x : int ( x ) - 1 , readline ( ) . split ( ) ) ) <NEWLINE> uf = UnionFind ( n ) <NEWLINE> for _ in range ( m ) : <NEWLINE> <INDENT> x , y = map ( lambda x : int ( x ) - 1 , readline ( ) . split ( ) ) <NEWLINE> uf , unite ( x , y ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if uf . is_connected ( i , p [ i ] ) : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
a , b , c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> if abs ( a - c ) <= d or ( abs ( a - b ) <= d and abs ( b - c ) <= d ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( sum ( a - 1 + ( a <= b ) ) ) <NEWLINE>
a , b = map ( int ( input ( ) . split ( ) ) ) <NEWLINE> if b >= a : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( a - 1 ) <NEWLINE> <DEDENT>
x , y = int ( input ( ) ) , int ( input ( ) ) <NEWLINE> if y < x : <NEWLINE> <INDENT> x -= 1 <NEWLINE> <DEDENT> print ( x ) <NEWLINE>
a , b = map ( int , input ( ) ) <NEWLINE> ans = ( a - 1 ) <NEWLINE> if a <= b : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
a , b = map ( int , input . split ( ) ) <NEWLINE> if a == i and b == 1 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( min ( a , b ) - 1 ) <NEWLINE> <DEDENT>
abc = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> k = int ( input ( ) ) <NEWLINE> mx = abc . pop ( max ( abc ) ) <NEWLINE> print ( mx * k + sum ( abc ) ) <NEWLINE>
a = map ( int , input ( ) . split ( ) ) <NEWLINE> k = int ( input ( ) ) <NEWLINE> <NL> a . sort ( ) <NEWLINE> a [ - 1 ] *= 2 ** k <NEWLINE> <NL> print ( sum ( a ) ) <NEWLINE>
a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = int ( input ( ) ) <NEWLINE> a . sort ( ) <NEWLINE> print ( a [ 0 ] + a [ 1 ] + ( a [ 2 ] * ( 2 ** b ) ) <NEWLINE>
a = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> k = int ( input ( ) ) <NEWLINE> print ( sum ( a ) + max ( a ) * ( 2 ** ( K - 1 ) ) ) <NEWLINE>
a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> x = max ( a , b , c ) <NEWLINE> <NL> print ( ( a + b + c ) - x + x * ( 2 ** k ) ) <NEWLINE>
ls = map ( int , input ( ) . split ( ) ) <NEWLINE> K = int ( input ( ) ) <NEWLINE> ls . sort ( ) <NEWLINE> ans = ls [ 0 ] + ls [ 1 ] + ls [ 2 ] * 2 ** K <NEWLINE> print ( ans ) <NEWLINE>
H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> S = [ <STRING> * ( W + 2 ) ] + [ <STRING> + input ( ) + <STRING> for _ in range ( H ) ] + [ <STRING> * ( W + 2 ) ] <NEWLINE> for y in range ( 1 , H + 1 ) : <NEWLINE> <INDENT> for x in range ( 1 , W + 1 ) : <NEWLINE> <INDENT> if S [ y ] [ x ] = <STRING> and ( S [ y - 1 ] [ x ] + S [ y + 1 ] [ x ] + S [ y ] [ x - 1 ] + S [ y ] [ x + 1 ] ) . count ( <STRING> ) == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> S = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( H ) ] <NEWLINE> <NL> f = False <NEWLINE> for h in range ( H ) : <NEWLINE> <INDENT> pre = <STRING> <NEWLINE> now = S [ h ] [ 0 ] <NEWLINE> nxt = S [ h ] [ 1 ] <NEWLINE> abv = <STRING> if h == 0 else S [ h - 1 ] [ 0 ] <NEWLINE> blw = <STRING> if h == H - 1 else S [ h + 1 ] [ 0 ] <NEWLINE> for w in range ( W ) : <NEWLINE> <INDENT> if now == <STRING> : <NEWLINE> <INDENT> f = False <NEWLINE> <DEDENT> elif now in [ pre , nxt , abv , blw ] : <NEWLINE> <INDENT> f = False <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> f = True <NEWLINE> <NL> <DEDENT> pre = now <NEWLINE> now = nxt <NEWLINE> nxt = <STRING> if w == W - 1 else S [ h ] [ w + 1 ] <NEWLINE> abv = <STRING> if h == 0 else S [ h - 1 ] [ w ] <NEWLINE> blw = <STRING> if h == H - 1 else S [ h + 1 ] [ w ] <NEWLINE> <NL> if f : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> figure = [ input ( ) for _ in range ( H ) ] <NEWLINE> D = [ ( 1 , 0 ) , ( - 1 , 0 ) , ( 0 , 1 ) , ( 0 , - 1 ) ] <NEWLINE> <NL> for h in range ( H ) : <NEWLINE> <INDENT> for w in range ( W ) : <NEWLINE> <INDENT> if figure [ h ] [ w ] == <STRING> : <NEWLINE> <INDENT> for dh , dw in D : <NEWLINE> <INDENT> nh , nw = h + dh , w + dw <NEWLINE> if not ( 0 <= nh <= H and 0 <= nw <= W ) : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if figure [ nh ] [ nw ] == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> src = [ input ( ) for i in range ( h ) ] <NEWLINE> <NL> ans = [ ] <NEWLINE> for row in src : <NEWLINE> <INDENT> ans . append ( list ( row ) ) <NEWLINE> <NL> <DEDENT> flag = 0 <NEWLINE> dxy = [ ( 1 , 0 ) , ( - 1 , 0 ) , ( 0 , 1 ) , ( 0 , - 1 ) ] <NEWLINE> for x in range ( h ) : <NEWLINE> <INDENT> for y in range ( w ) : <NEWLINE> <INDENT> if src [ x ] [ y ] == <STRING> : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for dx , dy in dxy : <NEWLINE> <INDENT> if x + dx < 0 or x + dx > h - 1 or y + dy < 0 or y + dy > w - 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if src [ x + dx ] [ y + dx ] == <STRING> : <NEWLINE> <INDENT> flag = 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if flag == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
ans = True <NEWLINE> d = [ ( 0 , 1 ) , ( 0 , - 1 ) , ( 1 , 0 ) , ( - 1 , 0 ) ] <NEWLINE> for y in range ( H ) : <NEWLINE> <INDENT> for x in range ( W ) : <NEWLINE> <INDENT> if s [ y ] [ x ] == <STRING> : <NEWLINE> <INDENT> for dy , dx in d : <NEWLINE> <INDENT> ny = y + dy <NEWLINE> nx = x + dx <NEWLINE> if ny < 0 or H <= ny or nx < 0 or W <= nx : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if s [ ny ] [ nx ] == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> ans = False <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> if ans else <STRING> ) <NEWLINE>
import sys <NEWLINE> <NL> input = sys . stdin . readline <NEWLINE> <NL> d = <STRING> <NEWLINE> dn = <STRING> <NEWLINE> <NL> def isPaintable ( h , w , x , y , canvas ) : <NEWLINE> <INDENT> ret = False <NEWLINE> if x > 0 : <NEWLINE> <INDENT> if canvas [ x - 1 , y ] == dn : <NEWLINE> <INDENT> ret = True <NEWLINE> <DEDENT> <DEDENT> elif x < w : <NEWLINE> <INDENT> if canvas [ x + 1 , y ] == dn : <NEWLINE> <INDENT> ret = True <NEWLINE> <DEDENT> <DEDENT> elif y > 0 : <NEWLINE> <INDENT> if canvas [ x , y - 1 ] == dn : <NEWLINE> <INDENT> ret = True <NEWLINE> <DEDENT> <DEDENT> elif y < h : <NEWLINE> <INDENT> if canvas [ x , y + 1 ] == dn : <NEWLINE> <INDENT> ret = True <NEWLINE> <DEDENT> <DEDENT> return ret <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> canavs = [ ] <NEWLINE> for _ in range ( h ) : <NEWLINE> <INDENT> s = list ( input ( ) . split ( ) . rstrip ( <STRING> ) ) <NEWLINE> canvas . append ( s ) <NEWLINE> <DEDENT> for i in h : <NEWLINE> <INDENT> if ans == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for j in w : <NEWLINE> <INDENT> if not isPaintable ( h , w , j , i , canvas ) : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
print ( * [ x for x in sieve ( 55555 ) if x % 10 == 7 ] [ : int ( input ( ) ) ] ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S = [ input ( ) for _ in range ( N ) ] <NEWLINE> T = [ <STRING> . join ( s ) for s in zip ( * S ) ] <NEWLINE> <NL> ans = 0 <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> ans += ( S == T ) <NEWLINE> S = [ s [ - 1 ] + s [ : - 1 ] for s in S ] <NEWLINE> T = T [ - 1 : ] + T [ : - 1 ] <NEWLINE> <NL> <DEDENT> print ( N * ans ) <NEWLINE>
A , B , C , X , Y = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <COMMENT> <NL> a = 2 * C * min ( X , Y ) + 2 * C * ( max ( X , Y ) - min ( X , Y ) ) <NEWLINE> <NL> <COMMENT> <NL> if X > Y : <NEWLINE> <INDENT> b = 2 * C * Y + ( X - Y ) * A <NEWLINE> <DEDENT> elif Y > X : <NEWLINE> <INDENT> b = 2 * C * X + ( Y - X ) * B <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> b = a <NEWLINE> <DEDENT> print ( b ) <NEWLINE> <NL> <COMMENT> <NL> c = A * X + B * Y <NEWLINE> print ( c ) <NEWLINE> <NL> print ( min ( a , b , c ) ) <NEWLINE>
S = input ( ) <NEWLINE> print ( S . count ( o ) * 100 + 700 ) <NEWLINE>
n = input ( ) <NEWLINE> c = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if n [ i ] == <STRING> : <NEWLINE> <INDENT> c += 1 <NEWLINE> <DEDENT> <DEDENT> if c > 0 : <NEWLINE> <INDENT> print ( 700 * c ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 700 ) <NEWLINE> <DEDENT>
opt = input ( ) <NEWLINE> sum = 700 <NEWLINE> if opt [ 0 ] == o : <NEWLINE> <INDENT> sum += 100 <NEWLINE> <DEDENT> if opt [ 1 ] == o : <NEWLINE> <INDENT> sum += 100 <NEWLINE> <DEDENT> if opt [ 2 ] == o : <NEWLINE> <INDENT> sum += 100 <NEWLINE> <DEDENT> print ( sum ) <NEWLINE>
to = list ( input ( ) ) <NEWLINE> counter = 0 <NEWLINE> <NL> if to [ 0 ] == <STRING> : <NEWLINE> <INDENT> counter += 1 <NEWLINE> <DEDENT> if to [ 1 ] == <STRING> : <NEWLINE> <INDENT> counter += 1 : <NEWLINE> <DEDENT> if to [ 2 ] == <STRING> : <NEWLINE> <INDENT> counter += 1 : <NEWLINE> <NL> <DEDENT> price = 700 + 100 * int ( counter ) <NEWLINE> <NL> print ( price ) <NEWLINE>
s = input ( ) <NEWLINE> c = 0 <NEWLINE> if ( s [ 0 ] == <STRING> ) c += 700 <NEWLINE> if ( s [ 1 ] == <STRING> ) c += 100 <NEWLINE> if ( s [ 2 ] == <STRING> ) c += 100 <NEWLINE> print ( c ) <NEWLINE>
n = input ( ) <NEWLINE> count = 0 <NEWLINE> for i in n : <NEWLINE> <INDENT> if i == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> print ( 700 + count * 100 ) <NEWLINE>
print ( 700 + input . count ( <STRING> ) * 100 ) <NEWLINE>
a = input ( ) <NEWLINE> print ( 700 + int ( input ( ) ) . count ( <STRING> ) ) <NEWLINE>
S = input ( ) <NEWLINE> print ( 700 + int ( S . count ( ) * 100 ) ) <NEWLINE>
S = input ( ) <NEWLINE> price = 700 + 100 * s . count ( <STRING> ) <NEWLINE> print ( price ) <NEWLINE>
s = input ( ) <NEWLINE> <NL> count = 700 <NEWLINE> <NL> for i in range ( s ) : <NEWLINE> <INDENT> if i == <STRING> : <NEWLINE> <INDENT> count += 100 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
s = str ( input ( ) ) <NEWLINE> for i in range ( 3 ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> print ( 700 + 100 * cnt ) <NEWLINE>
import java . util . Scanner ; <NEWLINE> public class Main { <NEWLINE> <INDENT> public static void main ( String [ ] args ) { <NEWLINE> <INDENT> Scanner scan = new Scanner ( System . in ) ; <NEWLINE> String S = scan . nextLine ( ) ; <NEWLINE> <NL> <INDENT> int v = 700 ; <NEWLINE> for ( int i = 0 ; i < S . length ( ) ; i + + ) { <NEWLINE> if ( S . charAt ( i ) == <STRING> ) { <NEWLINE> <INDENT> v += 100 ; <NEWLINE> <DEDENT> } <NEWLINE> } <NEWLINE> <NL> System . out . println ( v ) ; <NEWLINE> <DEDENT> } <NEWLINE> <DEDENT> <DEDENT> } <NEWLINE>
A , B , C , X , Y = map ( int , input ( ) . split ( ) ) <NEWLINE> min_ = min ( X , Y ) <NEWLINE> max_ = max ( X , Y ) <NEWLINE> <NL> res = A * X + B * Y <NEWLINE> <NL> m = 2 * C * max ( X , Y ) ; <NEWLINE> <NL> sum = C * 2 * min_ <NEWLINE> <NL> if ( C <= 0.5 * A and C <= 0.5 * B ) : <NEWLINE> <INDENT> sum += 2 * C * ( max_ - min_ ) <NEWLINE> <NL> <DEDENT> elif ( max_ == X ) : <NEWLINE> <INDENT> sum += ( max_ - min_ ) * A <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> sum += ( max_ - min_ ) * B <NEWLINE> <NL> <DEDENT> print ( min ( m , min ( res , sum ) ) ) <NEWLINE>
n , x , * m = map ( int , open ( 0 ) . read ( ) . split ( ) ) <NEWLINE> ans = - 1 <NEWLINE> for i in sorted ( m ) : <NEWLINE> <INDENT> if x >= i : <NEWLINE> <INDENT> x -= i ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans + x // min ( m ) ) <NEWLINE>
n , x = map ( int , input ( ) ) <NEWLINE> m = list ( int ( input ( ) ) for i in range ( n ) ) <NEWLINE> <NL> print ( ( x - sum ( m ) ) // min ( m ) + n ) <NEWLINE>
n , x = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = n <NEWLINE> mi = 10 ** 4 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> m = int ( input ( ) ) <NEWLINE> x -= m <NEWLINE> mi = min ( m , mi ) <NEWLINE> <DEDENT> asn += ( x // mi ) * mi <NEWLINE> print ( ans ) <NEWLINE> <NL>
n , x = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ int ( input ( ) ) for _ range ( n ) ] <NEWLINE> print ( n + ( ( x - sum ( a ) ) // min ( a ) ) ) <NEWLINE>
n , x = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> m = [ ] <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> m . append ( int ( input ( ) ) ) <NEWLINE> <DEDENT> sort ( m ) <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> for i in range ( n ) : <NEWLINE> <INDENT> if sum ( m [ 0 : i + 1 ] ) > x : <NEWLINE> <INDENT> print ( i ) <NEWLINE> return <NEWLINE> <DEDENT> <DEDENT> print ( n ) <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE>
A , B , C , X , Y = map ( int , input ( ) . split ) <NEWLINE> a = A * X + B * Y <NEWLINE> b = max ( X , Y ) * C * 2 <NEWLINE> p = B if X < Y else A <NEWLINE> c = min ( X , Y ) * 2 * C + abs ( X - Y ) * p <NEWLINE> print ( min ( a , b , c ) ) <NEWLINE>
a , b , c , x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( min ( a * x + b * y , 2 * c * x + b * max ( 0 , y - x ) , 2 * c * y + a * max ( 0 , x - y ) ) <NEWLINE>
A , B , C , X , Y = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = X * A + Y * B <NEWLINE> for i in range ( max ( X + Y ) + 1 ) : <NEWLINE> <INDENT> C = 2 * C * i + max ( 0 , X - i ) * A + max ( 0 , Y - i ) * B <NEWLINE> ans = min ( ans , C ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
a , b , c , x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = 10 ** 12 <NEWLINE> for i in range ( 0 , max ( x , y ) * 2 + 1 , 2 ) : <NEWLINE> <INDENT> xr = max ( x - i // 2 , 0 ) <NEWLINE> yr = max ( 0 , y - i // 2 ) <NEWLINE> <NL> if ans > ( i * c ) + ( xr * a ) + ( yr * b ) : <NEWLINE> <INDENT> ans = ( i * c ) + ( xr * a ) + ( yr * B ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
a , b , c , x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> mast = max ( x , y ) <NEWLINE> ans = max ( a * x + b * y , c * 2 * i ) <NEWLINE> <NL> for i in range ( mast + 1 ) : <NEWLINE> <INDENT> price = a * max ( x - i , 0 ) + b * max ( y - i , 0 ) + c * 2 * i <NEWLINE> ans = min ( ans , price ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
a , b , c , x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> m = max ( x , y ) <NEWLINE> ans = 10 ** 9 + 7 <NEWLINE> for e in range ( m + 1 ) : <NEWLINE> <INDENT> ans = min ( ans , 2 * e * c + a * max ( 0 , x - e ) + b * ( 0 , y - e ) ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
a , b , c , x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> kei = 0 <NEWLINE> if c > a / 2 + b / 2 : <NEWLINE> <INDENT> kei = a * x + b * y <NEWLINE> <NL> <DEDENT> elif c * 2 = < a + b and a >= c * 2 and b >= c * 2 : <NEWLINE> <INDENT> kei += c * ( min ( x , y ) * 2 ) <NEWLINE> if x > y : <NEWLINE> <INDENT> kei += c * ( ( x - y ) * 2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> kei += c * ( ( y - x ) * 2 ) <NEWLINE> <NL> <DEDENT> <DEDENT> elif c = < a / 2 + b / 2 : <NEWLINE> <INDENT> kei += c * ( min ( x , y ) * 2 ) <NEWLINE> if x > y : <NEWLINE> <INDENT> kei += a * ( x - y ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> kei += b * ( y - x ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> print ( kei ) <NEWLINE>
A , B , C , X , Y = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if A <= 2 * C amd B <= 2 * C : <NEWLINE> <INDENT> print ( A * X + B * Y ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> if X >= Y : <NEWLINE> <INDENT> print ( min ( A * ( X - Y ) + 2 * C * Y , 2 * C * X ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( min ( B * ( Y - X ) + 2 * C * X , 2 * C * Y ) ) <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> import math <NEWLINE> import itertools <NEWLINE> import bisect <NEWLINE> from copy import copy <NEWLINE> from collections import deque , Counter <NEWLINE> from decimal import Decimal <NEWLINE> def s ( ) : return input ( ) <NEWLINE> def k ( ) : return int ( input ( ) ) <NEWLINE> def S ( ) : return input ( ) . split ( ) <NEWLINE> def I ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def X ( ) : return list ( input ( ) ) <NEWLINE> def L ( ) : return list ( input ( ) . split ( ) ) <NEWLINE> def l ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> def lcm ( a , b ) : return a * b // math . gcd ( a , b ) <NEWLINE> def gcd ( * numbers ) : reduce ( math . gcd , numbers ) <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> count = 0 <NEWLINE> ans = 0 <NEWLINE> <NL> a , b , c , x , y = I ( ) <NEWLINE> p = [ ] <NEWLINE> for i in range ( 10 ** 5 + 1 ) : <NEWLINE> <INDENT> cash = 2 * c * i + a * max ( 0 , x - i ) + b * max ( 0 , y - i ) <NEWLINE> c . append ( cash ) <NEWLINE> <NL> <DEDENT> print ( min ( p ) ) <NEWLINE>
<COMMENT> <NL> <NL> <NL> n , c = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> xv = [ [ 0 , 0 ] ] + [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( n ) ] + [ [ c , 0 ] ] <NEWLINE> xv_rev = reversed ( xv ) <NEWLINE> <NL> print ( xv ) <NEWLINE> ans = 0 <NEWLINE> cal = 0 <NEWLINE> dis = 0 <NEWLINE> <NL> for i in range ( 1 , len ( xv ) ) : <NEWLINE> <INDENT> cal += xv [ i ] [ 1 ] <NEWLINE> cal -= ( xv [ i ] [ 0 ] - xv [ i - 1 ] [ 0 ] ) <NEWLINE> ans = max ( cal , ans ) <NEWLINE> <NL> <DEDENT> for i in range ( 1 , xv_rev ) : <NEWLINE> <INDENT> cal += xv [ i ] [ 1 ] <NEWLINE> cal -= ( xv [ i ] [ 0 ] - xv [ i - 1 ] [ 0 ] ) <NEWLINE> ans = max ( cal , ans ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
A , B , C , X , Y = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = 0 <NEWLINE> <NL> <NL> if A + B > c * 2 : <NEWLINE> <INDENT> Z = min ( X , Y ) <NEWLINE> ans += 2 * C * Z <NEWLINE> X -= Z <NEWLINE> Y -= Z <NEWLINE> <DEDENT> a = min ( A , 2 * C ) <NEWLINE> b = min ( B , 2 * C ) <NEWLINE> <NL> ans += a * X <NEWLINE> ans += b * Y <NEWLINE> <NL> print ( ans ) <NEWLINE>
a , b , x = map ( int , input ( ) ) <NEWLINE> if x >= a + b : print ( <STRING> ) <NEWLINE> else : print ( <STRING> ) <NEWLINE>
a , b , x = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( <STRING> if a <= x and a + b >= x or <STRING> ) <NEWLINE>
A , B , C = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( <STRING> if ( A <= C & & B >= C ) else <STRING> ) <NEWLINE>
A = int ( input ( ) ) <NEWLINE> B = int ( input ( ) ) <NEWLINE> X = int ( input ( ) ) <NEWLINE> if A <= X and A + B >= X : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b , x = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( [ <STRING> , <STRING> ] ] [ a <= x < a + b ] ) <NEWLINE>
<INDENT> a , b , x = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( <STRING> if ( a + b ) >= x else <STRING> ) <NEWLINE> <DEDENT>
if 0 <= X - A <= B : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
def actual ( N , M , X , A ) : <NEWLINE> <COMMENT> <NL> <INDENT> toll_gates_left = [ a_i for a_i in A if a_i < X ] <NEWLINE> toll_gates_right = [ a_i for a_i in A if X < a_i ] <NEWLINE> <NL> return min ( len ( toll_gates_left ) , len ( toll_gates_right ) ) <NEWLINE> <NL> <DEDENT> N , M , X = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ int ( input ( ) ) for _ in range ( N + 1 ) ] <NEWLINE> <NL> print ( actual ( N , M , X , A ) ) <NEWLINE>
a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> s = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i in s : <NEWLINE> <INDENT> if i < c : <NEWLINE> <INDENT> l += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> r += 1 <NEWLINE> <DEDENT> <DEDENT> print ( min ( l , r ) ) <NEWLINE>
n , m , x = map ( int , input ( ) . split ( ) ) <NEWLINE> a = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( min ( sum ( [ 1 for i in a if i > x ] ) , sum ( [ 1 for i in a if i < x ] ) ) <NEWLINE>
n , m , x , * a = map ( int , open ( 0 ) . read ( ) . split ( ) ) ; print ( min ( c : = sorted ( a ) . index ( x ) , m - c ) ) <NEWLINE>
a , b , c = input ( ) . split ( ) <NEWLINE> d = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> e = 0 <NEWLINE> f = 0 <NEWLINE> for i in range ( b ) : <NEWLINE> <INDENT> if d [ i ] > c : <NEWLINE> <INDENT> e = e + 1 <NEWLINE> <DEDENT> if d [ i ] < c : <NEWLINE> <INDENT> f = f + 1 <NEWLINE> <DEDENT> <DEDENT> if e > f : <NEWLINE> <INDENT> print ( f ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( e ) <NEWLINE> <DEDENT>
N , M , X = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ int ( input ( ) ) for in range ( M ) ] <NEWLINE> count_low = 0 <NEWLINE> count_high = 0 <NEWLINE> for i in range ( a ) : <NEWLINE> <INDENT> if a [ i - 1 ] < X : <NEWLINE> <INDENT> count_low += 1 <NEWLINE> <DEDENT> <DEDENT> for i in range ( a ) : <NEWLINE> <INDENT> if a [ i - 1 ] > X : <NEWLINE> <INDENT> count_high += 1 <NEWLINE> <DEDENT> <DEDENT> print ( min ( count_low , count_high ) ) <NEWLINE>
n , m , x = map ( int , input ( ) . split ( ) ) <NEWLINE> s = sum ( i if int ( i ) < x for i in input ( ) . split ( ) ) <NEWLINE> print ( min ( s , m - s ) ) <NEWLINE>
a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> d = list ( map ( int , input ( ) . split ( ) ) <NEWLINE> d . append ( c ) <NEWLINE> d . sort ( ) <NEWLINE> print ( min ( d . index ( c ) , len ( d ) - d . index ( c ) - 1 ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = a . sort ( ) <NEWLINE> x = b [ n // 2 - 1 ] <NEWLINE> y = b [ n // 2 ] <NEWLINE> for i in a : <NEWLINE> <INDENT> if a <= x : <NEWLINE> <INDENT> print ( y ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( x ) <NEWLINE> <DEDENT> <DEDENT>
fuckoff <NEWLINE>
import math <NEWLINE> import numpy as np <NEWLINE> <NL> def combinations_count ( n , r ) : <NEWLINE> <INDENT> return math . factorial ( n ) // ( math . factorial ( n - r ) * math . factorial ( r ) ) <NEWLINE> <DEDENT> def getNearestValue ( list , num ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> <NL> <COMMENT> <NL> idx = np . abs ( np . asarray ( list ) - num ) . argmin ( ) <NEWLINE> return list [ idx ] <NEWLINE> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> a = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> check = 0 <NEWLINE> a . sort ( ) <NEWLINE> b = a [ - i ] <NEWLINE> c = getNearestValue ( a , b / 2 ) <NEWLINE> ans = str ( b ) + <STRING> + str ( c ) <NEWLINE> print ( ans ) <NEWLINE>
<NL> from bisect import bisect_left , bisect <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> a . sort ( ) <NEWLINE> ai = max ( a ) <NEWLINE> <NL> <NL> if ai % 2 == 0 : <NEWLINE> <INDENT> ai2 = ai // 2 - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ai2 = ai // 2 <NEWLINE> <NL> <DEDENT> jj = bisect ( a , ai2 ) <NEWLINE> <NL> if jj + 1 < n : <NEWLINE> <INDENT> if abs ( a [ jj ] - ai2 ) > abs ( a [ jj + 1 ] - ai2 ) : <NEWLINE> <INDENT> jj2 = jj + 1 <NEWLINE> <DEDENT> <DEDENT> if jj - 1 >= 0 : <NEWLINE> <INDENT> if abs ( a [ jj ] - ai2 ) > abs ( a [ jj - 1 ] - ai2 ) : <NEWLINE> <INDENT> jj2 = jj - 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if jj2 == n - 1 : <NEWLINE> <INDENT> jj2 = jj2 - 1 <NEWLINE> <NL> <DEDENT> aj = a [ jj2 ] <NEWLINE> <NL> print ( ai , aj ) <NEWLINE> <NL>
s = input ( ) <NEWLINE> s . sort ( ) <NEWLINE> if <STRING> . join ( s ) = <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> print ( <STRING> if s [ 0 ] != s [ 1 ] & & s [ 1 ] != s [ 2 ] & & s [ 0 ] != s [ 2 ] else <STRING> ) <NEWLINE>
a = input ( ) <NEWLINE> a = a . sort ( ) <NEWLINE> if a == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> read = sys . stdin . read <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> sys . setrecursionlimit ( 10 ** 8 ) <NEWLINE> INF = float ( <STRING> ) <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> S = input ( ) <NEWLINE> S = sorted ( S ) <NEWLINE> if S = [ <STRING> , <STRING> , <STRING> ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
s = sort ( input ( ) ) <NEWLINE> if s [ 0 ] == <STRING> and s [ 1 ] == <STRING> and s [ 2 ] == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
<COMMENT> <NL> s = [ input ( ) . split ( ) ] <NEWLINE> print ( <STRING> if len ( set ( s ) ) == 3 else <STRING> ) <NEWLINE>
S = input ( ) <NEWLINE> if set ( S ) == { <STRING> , <STRING> , <STRING> } : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE>
s = input ( ) <NEWLINE> <NL> if s [ 0 ] == s [ 1 ] or s [ 1 ] == s [ 2 ] or s [ 2 ] == s [ 3 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
S = input ( ) <NEWLINE> if S == <STRING> : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> elif S == <STRING> : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> elif S == <STRING> : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> elif S == <STRING> : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> elif S == <STRING> : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> elif S == <STRING> : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> elif S == <STRING> : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT>
A , B , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if B - A + 1 <= 2 * K : <NEWLINE> <INDENT> print ( * range ( A , B + 1 ) , sep = <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a = list ( range ( A , A + K ) ) <NEWLINE> b = list ( range ( B - K + 1 , B + 1 ) ) <NEWLINE> C = set ( a , b ) <NEWLINE> print ( * C , sep = <STRING> ) <NEWLINE> <DEDENT>
def actual ( A , B , K ) : <NEWLINE> <INDENT> min_left = A <NEWLINE> max_left = min ( A + ( K - 1 ) , B ) <NEWLINE> <NL> min_right = max ( B - ( K - 1 ) , max_left + 1 ) <NEWLINE> max_right = B <NEWLINE> <NL> left = set ( range ( min_left , max_left + 1 ) ) <NEWLINE> right = set ( range ( min_right , max_right + 1 ) ) <NEWLINE> <NL> unique_nums = left | right <NEWLINE> <NL> return <STRING> . join ( map ( str , sorted ( unique_nums ) ) ) <NEWLINE> <NL> <DEDENT> A , B , K = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( actual_TLE ( A , B , K ) ) <NEWLINE>
a , b , k = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = [ ] <NEWLINE> for i in rangea ( a , k + a ) : <NEWLINE> <INDENT> if a <= i <= b : <NEWLINE> <INDENT> ans . append ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> for i in rangea ( b - k + 1 , b + 1 ) : <NEWLINE> <INDENT> if a <= i <= b : <NEWLINE> <INDENT> ans . append ( i ) <NEWLINE> <DEDENT> <DEDENT> ans = list ( set ( ans ) ) <NEWLINE> ans . sort ( ) <NEWLINE> for i in ans : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT>
a , b , k = map ( int , input ( ) . split ( ) ) <NEWLINE> n = b - a + 1 <NEWLINE> if n <= k * 2 : <NEWLINE> <INDENT> for i in range ( a , b + 1 ) : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( a , k + 1 ) : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT> fot j in range ( b - k + 1 , b + 1 ) <NEWLINE> print ( j ) <NEWLINE> <DEDENT>
a , b , k = map ( int , input ( ) . split ( ) ) <NEWLINE> if b - a + 1 > k * 2 : <NEWLINE> <INDENT> print ( [ a : a + k ] + [ b - k : b ] , end = <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( [ a : b ] , end = <STRING> ) <NEWLINE> <DEDENT>
a , b , n = map ( int , input ( ) . split ( ) ) <NEWLINE> enda = min ( a + n , b ) <NEWLINE> stab = max ( a , b - n ) <NEWLINE> C = sorted ( set ( list ( range ( a , enda ) ) ) | set ( list ( range ( stab + 1 : b + 1 ) ) ) ) <NEWLINE> for i in C : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT>
a , b , k = map ( int , input ( ) . split ( ) ) ; r = range ( a , b + 1 ) ; print ( * sorted ( { * ( r [ : k ] + r [ - k : ] ) } ) ) <NEWLINE>
2 9 100 <NEWLINE>
a , b , k = map ( int , input ( ) . split ( ) ) <NEWLINE> if b - a + 1 > 2 k : <NEWLINE> <INDENT> for i in range ( a , a + k ) : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT> for i in range ( b - k + 1 , b + 1 ) : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( a , b + 1 ) : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT> <DEDENT>
A , B , C = map ( int , input ( ) . split ( ) ) <NEWLINE> even += A % 2 + B % 2 + C % 2 <NEWLINE> answer = 0 <NEWLINE> if even == 1 : <NEWLINE> <INDENT> answer = 1 <NEWLINE> if A % 2 : <NEWLINE> <INDENT> A += 1 <NEWLINE> <DEDENT> if B % 2 : <NEWLINE> <INDENT> B += 1 <NEWLINE> <DEDENT> if C % 2 : <NEWLINE> <INDENT> C += 1 <NEWLINE> <DEDENT> <DEDENT> elif even == 2 : <NEWLINE> <INDENT> answer = 1 <NEWLINE> if not A % 2 : <NEWLINE> <INDENT> A += 1 <NEWLINE> <DEDENT> if not B % 2 : <NEWLINE> <INDENT> B += 1 <NEWLINE> <DEDENT> if not C % 2 : <NEWLINE> <INDENT> C += 1 <NEWLINE> <DEDENT> <DEDENT> D = sorted ( [ A , B , C ] ) <NEWLINE> answer += ( D [ 2 ] - D [ 0 ] ) // 2 + ( D [ 2 ] - D [ 1 ] ) // 2 <NEWLINE>
List = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> List . sort ( ) <NEWLINE> res = List [ 2 ] - List [ 1 ] <NEWLINE> Litt [ 1 ] = List [ 2 ] <NEWLINE> List [ 0 ] += res <NEWLINE> mid = List [ 2 ] - List [ 0 ] <NEWLINE> if mid % 2 == 1 : <NEWLINE> <INDENT> res += mid // 2 + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> res += mid // 2 <NEWLINE> <DEDENT> print ( res ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> x = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> y = sorted ( x ) <NEWLINE> m1 , m2 = y [ n // 2 - 1 ] , y [ n // 2 ] <NEWLINE> for i in x : <NEWLINE> <INDENT> if i <= m1 : print ( m2 ) <NEWLINE> else : print ( m1 ) <NEWLINE> <DEDENT>
q = int ( input ( ) ) <NEWLINE> ab = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( q ) ] <NEWLINE> for a , b in ab : <NEWLINE> <INDENT> if a > b : a , b = b , a <NEWLINE> if a == b : <NEWLINE> <INDENT> print ( 2 * a - 2 ) <NEWLINE> <DEDENT> elif a + 1 == b : <NEWLINE> <INDENT> print ( 2 * a - 2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> c = int ( ( a * b ) ** 0.5 ) <NEWLINE> if c * ( c + 1 ) >= a * b : <NEWLINE> <INDENT> print ( 2 * c - 2 ) <NEWLINE> <DEDENT> elif c ** 2 < a * b : <NEWLINE> <INDENT> print ( 2 * c - 1 ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> q = int ( input ( ) ) <NEWLINE> ab = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( q ) ] <NEWLINE> from math import floor <NEWLINE> for a , b in ab : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <INDENT> if a == b : <NEWLINE> <INDENT> print ( 2 * a - 2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <INDENT> t = floor ( ( a * b ) ** 0.5 ) <NEWLINE> <COMMENT> <NL> if t * t >= a * b : <NEWLINE> <COMMENT> <NL> <INDENT> print ( 2 * t - 3 ) <NEWLINE> <DEDENT> elif t * ( t + 1 ) >= a * b : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <INDENT> print ( 2 * t - 2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <COMMENT> <NL> <INDENT> print ( 2 * t - 1 ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
lst = list ( map ( int , input ( ) . split ( ) ) ) . sort ( ) <NEWLINE> <NL> mval = lst [ - 1 ] <NEWLINE> sval = sum ( lst ) <NEWLINE> cn = mval + ( sval - mval ) % 2 <NEWLINE> n = ( cn * 3 - sval ) // 2 <NEWLINE> print ( n ) <NEWLINE> <NL>
s = list ( input ( ) ) <NEWLINE> m = list ( <STRING> ) <NEWLINE> if len ( s ) < 26 : <NEWLINE> <INDENT> for i in m [ : : - 1 ] : <NEWLINE> <INDENT> if not j in s : <NEWLINE> <INDENT> s . append ( j ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> . join ( s ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if s == m : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = s [ - 1 ] <NEWLINE> for i in range ( 25 ) [ : : - 1 ] : <NEWLINE> <INDENT> if x > s [ i ] : <NEWLINE> <INDENT> s = s [ : i ] <NEWLINE> s . append ( x ) <NEWLINE> break <NEWLINE> <DEDENT> if i == 0 : <NEWLINE> <INDENT> z = m . index ( s [ 0 ] ) <NEWLINE> s = m [ z - 1 ] <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> . join ( s ) ) <NEWLINE> <DEDENT> <DEDENT>
s = str ( input ( ) ) <NEWLINE> t = [ <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> if len ( s ) != 26 : <NEWLINE> <INDENT> for i in range ( 26 ) : <NEWLINE> <INDENT> if t [ i ] not in s : <NEWLINE> <INDENT> s . append ( t [ i ] ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> . join ( s ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if <STRING> . join ( s ) == <STRING> : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a = [ ] <NEWLINE> for i in range ( 26 ) : <NEWLINE> <INDENT> a . append ( s [ 25 - i ] ) <NEWLINE> for j in a : <NEWLINE> <INDENT> if s < s [ : 25 - i ] + j : <NEWLINE> <INDENT> print ( s [ : 25 - i ] + j ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT>
s = input ( ) <NEWLINE> <NL> abc = [ <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> <NL> if s == <STRING> . join ( abc ) [ : : - 1 ] : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> if len ( s ) != 26 : <NEWLINE> <INDENT> for a in abc : <NEWLINE> <INDENT> if a not in abc : <NEWLINE> <INDENT> print ( s + a ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> i = 25 <NEWLINE> while s [ i - 1 ] > s [ i ] : <NEWLINE> <INDENT> i -= 1 <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> tt = s [ i - 1 ] <NEWLINE> ss = list ( s [ i - 1 : ] ) <NEWLINE> ss . sort ( ) <NEWLINE> print ( s [ : i - 1 ] + ss [ ss . index ( tt ) + 1 ] ) <NEWLINE>
A , B , C , D = int ( input ( ) ) <NEWLINE> <NL> train = [ A , B ] <NEWLINE> bus = [ C , D ] <NEWLINE> <NL> print ( min ( train ) + min ( bus ) ) <NEWLINE>
A , B , C , D = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if A <= B : <NEWLINE> <INDENT> train = A <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> train = B <NEWLINE> <DEDENT> if C <= D : <NEWLINE> <INDENT> bus = C <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> bus = D <NEWLINE> <NL> <DEDENT> answer = train + bus <NEWLINE> print ( answer ) <NEWLINE>
a = [ int ( input ( ) ) for i in range ( 4 ) ] <NEWLINE> if a <= b : <NEWLINE> <INDENT> if c <= d : <NEWLINE> <INDENT> print ( a + c ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( a + d ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if c <= d : <NEWLINE> <INDENT> print ( b + c ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( b + d ) <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> import sys , re <NEWLINE> from collections import deque , defaultdict , Counter <NEWLINE> from math import ceil , sqrt , hypot , factorial , pi , sin , cos , radians <NEWLINE> from itertools import accumulate , permutations , combinations , product <NEWLINE> from operator import itemgetter , mul <NEWLINE> from copy import deepcopy <NEWLINE> from string import ascii_lowercase , ascii_uppercase , digits <NEWLINE> from bisect import bisect , bisect_left <NEWLINE> from fractions import gcd <NEWLINE> from heapq import heappush , heappop <NEWLINE> from functools import reduce <NEWLINE> import numpy as np <NEWLINE> def input ( ) : return sys . stdin . readline ( ) . strip ( ) <NEWLINE> def INT ( ) : return int ( input ( ) ) <NEWLINE> def MAP ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def LIST ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> def ZIP ( n ) : return zip ( * ( MAP ( ) for _ in range ( n ) ) ) <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> INF = float ( <STRING> ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> A , B , C , D = MAP ( ) <NEWLINE> print ( min ( [ A , B ] ) + min ( [ C , D ] ) ) <NEWLINE>
a = int ( input ( ) ) <NEWLINE> b = int ( input ( ) ) <NEWLINE> c = int ( input ( ) ) <NEWLINE> d = int ( input ( ) ) <NEWLINE> print ( mix ( a , b ) + min ( c , d ) ) <NEWLINE>
a , b , c , d = input ( ) . split ( ) <NEWLINE> a = int ( a ) <NEWLINE> b = int ( b ) <NEWLINE> c = int ( c ) <NEWLINE> d = int ( d ) <NEWLINE> if a >= b : <NEWLINE> <INDENT> if c >= d : <NEWLINE> <INDENT> print ( b + d ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( b + c ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if c >= d : <NEWLINE> <INDENT> print ( a + d ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( a + c ) <NEWLINE> <DEDENT> <DEDENT>
A , B , C , D = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> print ( min ( A , B ) + min ( C , D ) ) <NEWLINE>
a , b , c , d = [ int ( input ( ) ) for_ in range ( 4 ) ] <NEWLINE> print ( min ( a , b ) + min ( c , d ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> d , x = map ( int , input ( ) . split ( ) ) <NEWLINE> res = x <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a = int ( input ( ) ) <NEWLINE> if a == 1 : <NEWLINE> <INDENT> res += d <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> res += ( d - 1 ) // a + 1 <NEWLINE> <DEDENT> <DEDENT> print ( res ) <NEWLINE>
<COMMENT> <NL> <NL> <COMMENT> <NL> a , b , c , d = ( int ( x ) for x in input ( ) . split ( ) ) <NEWLINE> <NL> <COMMENT> <NL> gokei1 = a + b <NEWLINE> gokei2 = a + c <NEWLINE> gokei3 = a + d <NEWLINE> gokei4 = b + c <NEWLINE> gokei5 = b + d <NEWLINE> gokei6 = c + d <NEWLINE> <NL> resalt = [ gokei1 , gokei2 , gokei3 , gokei4 , gokei5 , gokei6 ] <NEWLINE> print ( min ( resalt ) ) <NEWLINE>
a = int ( input ( ) ) <NEWLINE> b = int ( input ( ) ) <NEWLINE> c = int ( input ( ) ) <NEWLINE> d = int ( input ( ) ) <NEWLINE> print ( sum ( min ( a , b ) , min ( c , d ) ) ) <NEWLINE>
B = int ( input ( ) ) <NEWLINE> C = int ( input ( ) ) <NEWLINE> D = int ( input ( ) ) <NEWLINE> <NL> if A <= B : <NEWLINE> <INDENT> densya = A <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> densya = B <NEWLINE> <NL> <DEDENT> if C <= D : <NEWLINE> <INDENT> bus = C <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> bus = D <NEWLINE> <NL> <DEDENT> untin = densya + bus <NEWLINE> <NL> print ( untin ) <NEWLINE>
A , B , C , D = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( min ( A , B ) + min ( C , D ) ) <NEWLINE>
a , b , c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> print ( min ( a , b ) + min ( c , d ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> d , x = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> b = [ ] <NEWLINE> cnt = n <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> b [ i ] = 1 <NEWLINE> while b [ i ] <= d : <NEWLINE> <INDENT> b [ i ] += a [ i ] <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> print ( cnt + x ) <NEWLINE>
a = int ( input ( ) ) <NEWLINE> b , c = input ( ) . split ( ) <NEWLINE> b = int ( b ) <NEWLINE> c = int ( c ) <NEWLINE> d = [ int ( input ( ) ) i in range ( a ) <NEWLINE> <INDENT> e = e + int ( ( b - 1 ) / d [ i ] ) + 1 <NEWLINE> <DEDENT> print ( e ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> D , X = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> A = [ int ( input ( ) ) for _ in range ( N ) ] <NEWLINE> ans = X <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> a = 1 <NEWLINE> l = 1 <NEWLINE> while a <= D : <NEWLINE> <INDENT> ans += 1 <NEWLINE> a = l * A [ i ] + 1 <NEWLINE> l += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) N = int ( input ( ) ) <NEWLINE> D , X = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> A = [ int ( input ( ) ) for _ in range ( N ) ] <NEWLINE> ans = X <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> a = 1 <NEWLINE> l = 1 <NEWLINE> while a <= D : <NEWLINE> <INDENT> ans += 1 <NEWLINE> a = l * A [ i ] + 1 <NEWLINE> l += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
def resolve ( ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> N = int ( input ( ) ) <NEWLINE> D , X = [ int ( item ) for item in input ( ) . split ( ) ] <NEWLINE> As = [ int ( input ( ) ) for _ in range ( N ) ] <NEWLINE> <NL> cnt = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> day = 0 <NEWLINE> j = 0 <NEWLINE> while day <= D : <NEWLINE> <INDENT> day = j * As [ i ] + 1 <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> resolve ( ) <NEWLINE> <DEDENT>
5 <NEWLINE> 30 44 <NEWLINE> 26 <NEWLINE> 18 <NEWLINE> 81 <NEWLINE> 18 <NEWLINE> 6 <NEWLINE>
N = int ( input ( ) ) <NEWLINE> D , X = map ( int , input ( ) . spilt ( ) ) <NEWLINE> A = [ int ( input ( ) ) for i in range ( N ) ] <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> for i in range ( len ( A ) ) : <NEWLINE> <INDENT> ans += ( D - 1 ) // A [ i ] + 1 <NEWLINE> <DEDENT> print ( ans + X ) <NEWLINE>
jfrom math import gcd <NEWLINE> <NL> from math import factorial as f <NEWLINE> <NL> from math import ceil , floor , sqrt <NEWLINE> import math <NEWLINE> <NL> import bisect <NEWLINE> import re <NEWLINE> import heapq <NEWLINE> <NL> from copy import deepcopy <NEWLINE> import itertools <NEWLINE> from itertools import permutations <NEWLINE> <NL> from sys import exit <NEWLINE> <NL> ii = lambda : int ( input ( ) ) <NEWLINE> mi = lambda : map ( int , input ( ) . split ( ) ) <NEWLINE> li = lambda : list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> yes = <STRING> <NEWLINE> no = <STRING> <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> n = ii ( ) <NEWLINE> d , x = mi ( ) <NEWLINE> a = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> tmp = ii ( ) <NEWLINE> a . append ( tmp ) <NEWLINE> <DEDENT> ans = 0 <NEWLINE> for i in a : <NEWLINE> <INDENT> tmp = 1 <NEWLINE> while tmp <= d : <NEWLINE> <INDENT> ans += 1 <NEWLINE> tmp += i <NEWLINE> <DEDENT> <DEDENT> ans += x <NEWLINE> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> main ( ) <NEWLINE>
def actual ( N , D , X , A ) : <NEWLINE> <INDENT> count = 0 <NEWLINE> <NL> for a_i in A : <NEWLINE> <INDENT> for i in range ( 100 + 1 ) : <NEWLINE> <INDENT> eating_day = 1 + ( a_i * i ) <NEWLINE> <NL> if eating_day <= D : <NEWLINE> <INDENT> count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> return X + count <NEWLINE> <NL> <DEDENT> N = int ( input ( ) ) <NEWLINE> D , X = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ int ( input ) for _ in range ( N ) ] <NEWLINE> <NL> print ( actual ( N , D , X , A ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = [ 0 ] + a + [ 0 ] <NEWLINE> <NL> d_1 = [ ] <NEWLINE> for i in range ( 1 , n + 2 ) : <NEWLINE> <INDENT> d_1 . append ( abs ( a [ i ] - a [ i - 1 ] ) ) <NEWLINE> <DEDENT> d_2 = [ 0 ] <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> d_2 . append ( abs ( a [ i + 1 ] - a [ i - 1 ] ) ) <NEWLINE> <NL> <DEDENT> s_d = sum ( d_1 ) <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> print ( s_d - d_1 [ i ] - d_1 [ i + 1 ] + d_2 [ i ] ) <NEWLINE> <DEDENT>
<INDENT> = int ( input ( ) ) <NEWLINE> <DEDENT> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> j = abs ( A [ 0 ] ) + abs ( A [ N - 1 ] ) <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> j += abs ( A [ i ] - A [ i + 1 ] ) <NEWLINE> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> ans = j - abs ( A [ 0 ] ) - abs ( A [ 0 ] - A [ 1 ] ) + abs ( A [ 1 ] ) <NEWLINE> <DEDENT> elif i == N - 1 : <NEWLINE> <INDENT> ans = j - abs ( A [ N - 2 ] - A [ N - 1 ] ) - abs ( A [ N - 1 ] ) + abs ( A [ N - 2 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = j - abs ( A [ i ] - A [ i - 1 ] ) - abs ( A [ i ] - A [ i + 1 ] ) + abs ( A [ i - 1 ] - A [ i + 1 ] ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
from itertools import accumulate <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = tuple ( [ 0 , ] + list ( map ( int , input ( ) . split ( ) ) ) + [ 0 , ] ) <NEWLINE> D = [ ] <NEWLINE> sum = 0 <NEWLINE> for i , a in enumarate ( A [ 1 : - 1 ] ) : <NEWLINE> <INDENT> i += 1 <NEWLINE> pre = A [ i - 1 ] <NEWLINE> tem = A [ i ] <NEWLINE> nex = A [ i + 1 ] <NEWLINE> x = abs ( pre - tem ) + abs ( tem - nex ) <NEWLINE> sum += x <NEWLINE> D . append ( abs ( pre - nex ) - x ) <NEWLINE> <DEDENT> for d in D : <NEWLINE> <INDENT> print ( sum + d ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ) ) <NEWLINE> ans = [ 0 ] * n <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ac = a <NEWLINE> del ac [ i ] <NEWLINE> for j in range ( 0 , n ) : <NEWLINE> <INDENT> if j == 0 : <NEWLINE> <INDENT> ans [ i ] += abs ( ac [ 0 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans [ i ] += abs ( ac [ j ] - ac [ j - 1 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for k in ans : <NEWLINE> <INDENT> print ( str ( k ) ) <NEWLINE> <DEDENT>
n = input ( ) <NEWLINE> l = [ 0 ] + list ( map ( int , input ( ) . split ( ) ) ) + [ 0 ] <NEWLINE> ans = 0 <NEWLINE> pre = 0 <NEWLINE> for i in l : ans += abs ( pre - i ) ; pre = i <NEWLINE> for i in range ( 1 , int ( n ) + 1 ) : <NEWLINE> <INDENT> dif = - abs ( l [ i ] - l [ i - 1 ] ) - abs ( l [ i ] - l [ i + 1 ] ) + abs ( l [ i - 1 ] - l [ i + 1 ] ) <NEWLINE> if l [ i ] in ( l [ i - 1 ] , l [ i + 1 ] ) : print ( ans ) <NEWLINE> elif l [ i ] < l [ i - 1 ] : <NEWLINE> <INDENT> print ( ans if l [ i + 1 ] < l [ i ] else ans + dif ) <NEWLINE> <DEDENT> else : print ( ansans if l [ i + 1 ] > l [ i ] else ans + dif ) <NEWLINE> <DEDENT>
line = <STRING> . join ( [ <STRING> ] * 50 ) <NEWLINE> dot = [ <STRING> , <STRING> ] <NEWLINE> cl = [ <STRING> . join ( [ <STRING> ] * 100 ) , <STRING> . join ( [ <STRING> ] * 100 ) ] <NEWLINE> ba = [ b - 1 , a - 1 ] <NEWLINE> ans = [ ] <NEWLINE> for c in [ 0 , 1 ] : <NEWLINE> <INDENT> ans . append ( cl [ c ] ) <NEWLINE> for i in range ( ba [ c ] // 50 ) : <NEWLINE> <INDENT> ans . append ( line ) <NEWLINE> ans . append ( cl [ c ] ) <NEWLINE> <DEDENT> ans . append ( <STRING> . join ( [ <STRING> ] * ( ba [ c ] % 50 ) ) + cl [ c ] [ ( ba [ c ] % 50 ) * 2 : ] ) <NEWLINE> ans . append ( cl [ c ] ) <NEWLINE> <DEDENT> print ( len ( ans ) ) <NEWLINE> for l in ans : print ( <STRING> . join ( l ) ) <NEWLINE>
a , b , c = int ( input ( ) ) <NEWLINE> if a + b >= c : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
A , B , C = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( <STRING> if sum ( A , B ) >= C else <STRING> ) <NEWLINE>
a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( <STRING> ) if c = < a + b else print ( <STRING> ) <NEWLINE>
a , s , d = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( <STRING> if a + b >= c else <STRING> ) <NEWLINE>
A , B , C = map ( int , input ( ) ) <NEWLINE> print ( <STRING> if A + B * 2 >= C else <STRING> ) <NEWLINE>
A , B , C = map ( int , input ( ) ) <NEWLINE> <NL> if A + B >= C : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b , c = map ( int , input . split ( ) ) <NEWLINE> if a + b = > c : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
from collections import defaultdict <NEWLINE> d = defaultdict ( int ) <NEWLINE> for _ in range ( int ( input ( ) ) ) : <NEWLINE> <INDENT> d [ input ( ) ] += 1 <NEWLINE> <DEDENT> for _ in range ( int ( input ( ) ) ) : <NEWLINE> <INDENT> d [ input ( ) ] -= 1 <NEWLINE> <DEDENT> print ( max ( 0 , d . values ( ) ) ) <NEWLINE>
x = int ( input ( ) ) <NEWLINE> a = [ input ( ) for i in range ( x ) ] <NEWLINE> y = int ( input ( ) ) <NEWLINE> b = [ input ( ) for h in range ( y ) ] <NEWLINE> <NL> count_max = 0 <NEWLINE> for j in a : <NEWLINE> <INDENT> if ( a . count ( j ) - b . count ( j ) ) > count_max : <NEWLINE> <INDENT> a . count ( j ) - b . count ( j ) = count_max <NEWLINE> <DEDENT> <DEDENT> print ( count_max ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S = [ input ( ) for i in range ( N ) ] <NEWLINE> M = int ( input ( ) ) <NEWLINE> T = [ input ( ) for i in range ( M ) ] <NEWLINE> <NL> T1 = [ x + <STRING> for x in T ] <NEWLINE> arr = S + T1 <NEWLINE> list1 = [ ] <NEWLINE> for i in range ( len ( arr ) ) : <NEWLINE> <INDENT> if arr [ i ] not <NEWLINE> <NL> <DEDENT> list2 = [ ] in list2 : <NEWLINE> <INDENT> s = arr . count ( arr [ i ] ) <NEWLINE> t = arr . count ( arr [ i ] + <STRING> ) <NEWLINE> a = s - t <NEWLINE> list1 . append ( ( arr [ i ] , a ) ) <NEWLINE> list2 . append ( arr [ i ] ) <NEWLINE> <NL> <DEDENT> for i in list1 : <NEWLINE> <NL> <INDENT> if i [ 0 ] . endswith ( <STRING> ) : <NEWLINE> <INDENT> list1 . remove ( i ) <NEWLINE> <DEDENT> print ( list1 ) <NEWLINE> <NL> <DEDENT> ans1 = max ( list1 , key = lambda x : x [ 1 ] ) <NEWLINE> <NL> if int ( ans1 [ 1 ] ) <= 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans1 [ 1 ] ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> s = [ input ( ) for i in range ( n ) ] <NEWLINE> m = int ( input ( ) ) <NEWLINE> t = [ input ( ) for i in range ( n ) ] <NEWLINE> <NL> print ( max ( 0 , max ( s . count ( i ) - t . count ( i ) for i in set ( s ) ) ) ) <NEWLINE> <NL> <NL> <NL>
def resolve ( ) : <NEWLINE> <INDENT> A , B , C , K = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if A + B >= K : <NEWLINE> <INDENT> print ( A ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( A - ( K - A - B ) ) <NEWLINE> <NL> <DEDENT> return <NEWLINE> <NL> <NL> <DEDENT> resolve ( ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = list ( ) <NEWLINE> <NL> for a in range ( n ) : <NEWLINE> <INDENT> s . append ( input ( ) ) <NEWLINE> <NL> <DEDENT> t = list ( ) <NEWLINE> m = int ( input ( ) ) <NEWLINE> <NL> for a in range ( m ) : <NEWLINE> <INDENT> t . append ( input ( ) ) <NEWLINE> <NL> <DEDENT> kind = list ( set ( s ) ) <NEWLINE> kind_length = len ( kind ) <NEWLINE> <NL> counter = dict ( ) <NEWLINE> for a in range ( kind_length ) : <NEWLINE> <INDENT> counter [ kind [ a ] ] = 0 <NEWLINE> <NL> <DEDENT> for a in range ( n ) : <NEWLINE> <INDENT> counter [ s [ a ] ] += 1 <NEWLINE> <NL> <DEDENT> for a in range ( m ) : <NEWLINE> <INDENT> if t [ a ] not in counter : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> counter [ t [ a ] ] -= 1 <NEWLINE> <NL> <DEDENT> print ( max ( counter . values ( ) , 0 ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = [ input ( ) for i in range ( n ) ] <NEWLINE> m = int ( input ( ) ) <NEWLINE> t = [ input ( ) for i in range ( m ) ] <NEWLINE> <NL> s = set ( s ) <NEWLINE> tot = 0 <NEWLINE> for i in s : <NEWLINE> <INDENT> tot = max ( s . count ( i ) - t . count ( i ) , tot ) <NEWLINE> <NL> <DEDENT> print ( tot ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = [ input ( ) for _ in range ( n ) ] <NEWLINE> m = int ( input ( ) ) <NEWLINE> t = [ input ( ) for _ in range ( m ) ] <NEWLINE> <NL> res = 0 <NEWLINE> for i in set ( s ) : <NEWLINE> <INDENT> res = max ( s . count ( i ) - t . count ( i ) , ans ) <NEWLINE> <DEDENT> print ( res ) <NEWLINE>
<COMMENT> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> blue = [ int ( input ( ) ) for i in range ( int ( input ( ) ) ) ] <NEWLINE> red = [ int ( input ( ) ) for i in range ( int ( input ( ) ) ) ] <NEWLINE> l = list ( set ( blue ) ) <NEWLINE> print ( max ( 0 , max ( blue . count ( l [ i ] ) - red . count ( l [ i ] ) for i in range ( len ( l ) ) ) ) ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import collections <NEWLINE> n = int ( input ( ) ) <NEWLINE> s = [ str ( input ( ) ) for _ in range ( n ) ] <NEWLINE> m = int ( input ( ) ) <NEWLINE> t = [ str ( input ( ) ) for _ in range ( m ) ] <NEWLINE> s = collections . Counter ( s ) <NEWLINE> t = collections . Counter ( t ) <NEWLINE> <NL> for k , j in t . items ( ) : <NEWLINE> <INDENT> if k in s : <NEWLINE> <INDENT> s [ k ] -= j <NEWLINE> <NL> <DEDENT> <DEDENT> values , counts = zip ( * s . most_common ( ) ) <NEWLINE> print ( max ( 0 , counts [ 0 ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> Red = sorted ( [ tuple ( map ( int , input ( ) . split ( ) ) ) for _ in range ( N ) ] ) <NEWLINE> Blue = sorted ( [ tuple ( map ( int , input ( ) . split ( ) ) ) for _ in range ( N ) ] ) <NEWLINE> <NL> ans = 0 <NEWLINE> switch = lambda X : ( X [ 1 ] , X [ 0 ] ) <NEWLINE> for b in Blue : <NEWLINE> <INDENT> C = [ switch ( r ) for r in Red if r < b ] <COMMENT> <NEWLINE> if len ( C ) == 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> ans += 1 <NEWLINE> C . sorted ( reverse = True ) <NEWLINE> Red . remove ( switch ( C [ 0 ] ) ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
<NL> n = int ( input ( ) . strip ( ) ) <NEWLINE> red = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( n ) ] <NEWLINE> blue = [ list ( map ( int , input ( ) . split ( ) ) ) for j in range ( n ) ] <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> <DEDENT> red . sort ( key = lambda x : ( x [ 0 ] , x [ 1 ] ) , reverse = True ) <NEWLINE> blue . sort ( key = lambda x : ( x [ 0 ] , x [ 1 ] ) ) <NEWLINE> flg_r = [ 0 ] * n <NEWLINE> cnt = 0 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( n ) : <NEWLINE> <INDENT> if flg_r [ j ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if red [ j ] [ 0 ] < blue [ i ] [ 0 ] and red [ j ] [ 1 ] < blue [ i ] [ 1 ] : <NEWLINE> <INDENT> flg_a [ j ] = 1 <NEWLINE> cnt += 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> ab = [ [ int ( i ) for i in input ( ) . split ( ) ] for _ in range ( N ) ] <NEWLINE> cd = [ [ int ( i ) for i in input ( ) . split ( ) ] for _ in range ( N ) ] <NEWLINE> <NL> ab . sort ( key = lambda x : x [ 1 ] , reverse = True ) <NEWLINE> cd . sort ( ) <NEWLINE> <NL> a = 0 <NEWLINE> for c , d in cd : <NEWLINE> <INDENT> for a , b in ab : <NEWLINE> <INDENT> if a < c and b < d : <NEWLINE> <INDENT> a += 1 <NEWLINE> ab . remove ( [ a , b ] ) <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( a ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> R = [ list ( map ( int , input ( ) . split ( ) ) ) for n in range ( N ) ] <NEWLINE> B = [ list ( map ( int , input ( ) . split ( ) ) ) for n in range ( N ) ] <NEWLINE> <NL> sorted ( R , key = itemgetter ( 1 ) , reverse = True ) <NEWLINE> B . sort ( ) <NEWLINE> ans = 0 <NEWLINE> <NL> for c , d in B : <NEWLINE> <INDENT> for a , b in R : <NEWLINE> <INDENT> if a < c and b < d : <NEWLINE> <INDENT> ans += 1 <NEWLINE> R . remove ( [ a , b ] ) <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> reds = sorted ( [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( n ) ] ) <NEWLINE> blues = sorted ( [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( n ) ] ) <NEWLINE> <NL> reds = reds [ : : - 1 ] <NEWLINE> res = 0 <NEWLINE> <NL> for c , d in blues : <NEWLINE> <INDENT> for a , b in reds : <NEWLINE> <INDENT> if a < c and b < d : <NEWLINE> <INDENT> reds . remove ( [ a , b ] ) <NEWLINE> res += 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( res ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> red = [ tuple ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ] <NEWLINE> blue = [ tuple ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ] <NEWLINE> red . sort ( key = lambda x : - x [ 1 ] ) <NEWLINE> blue . sort ( ) <NEWLINE> count = 0 <NEWLINE> for xb , yb in blue : <NEWLINE> <INDENT> for xr , yr in red : <NEWLINE> <INDENT> if xb > xr and yb > yr : <NEWLINE> <INDENT> red [ max_i ] = ( 201 , 201 ) <NEWLINE> count += 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
s = input ( ) <NEWLINE> k = int ( input ( ) ) <NEWLINE> l = list ( s ) <NEWLINE> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> if 26 - ( ord ( s [ i ] ) - ord ( <STRING> ) ) <= k : k -= 26 - ( ord ( s [ i ] ) - ord ( <STRING> ) ) ; l [ i ] = <STRING> <NEWLINE> <DEDENT> print ( <STRING> . join ( l [ : - 1 ] + list ( chr ( ( ord ( l [ - 1 ] ) - 97 + k ) % 26 + 97 ) ) ) ) <NEWLINE>
a = [ ] <NEWLINE> for i in range ( 3 ) : <NEWLINE> <INDENT> a [ i ] = input ( ) <NEWLINE> <DEDENT> print ( a [ 0 ] [ 0 ] + a [ 1 ] [ 1 ] + a [ 2 ] [ 2 ] ) <NEWLINE>
a = list ( input ( ) . split ( ) ) <NEWLINE> b = list ( input ( ) . split ( ) ) <NEWLINE> c = list ( input ( ) . split ( ) ) <NEWLINE> print ( a [ 0 ] + b [ 1 ] + c [ 2 ] ) <NEWLINE>
a , b , c = input ( ) . split ( ) <NEWLINE> d , e , f = input ( ) . split ( ) <NEWLINE> g , h , i = input ( ) . split ( ) <NEWLINE> print ( a + e + i ) <NEWLINE>
U = input ( ) <NEWLINE> M = input ( ) <NEWLINE> B = input ( ) <NEWLINE> <NL> print ( U [ 0 ] . M [ 1 ] . B [ 2 ] ) <NEWLINE>
for i in range ( 3 ) <NEWLINE> <INDENT> A [ i ] = input ( ) <NEWLINE> <DEDENT> print ( A [ 0 ] [ 0 ] + A [ 1 ] [ 1 ] + A [ 2 ] [ 2 ] ) <NEWLINE>
x = list ( map ( input ( ) . split ( ) ) for i in range ( 3 ) ) <NEWLINE> print ( x [ 0 ] [ 0 ] + x [ 1 ] [ 1 ] + x [ 2 ] [ 2 ] ) <NEWLINE>
x = [ input ( ) for _ in range ( 3 ) ] <NEWLINE> for i in range ( 3 ) : <NEWLINE> <INDENT> print ( x [ i ] [ i ] , seq = <STRING> ) <NEWLINE> <DEDENT>
a = int ( input ( ) ) <NEWLINE> b = int ( input ( ) ) <NEWLINE> c = int ( input ( ) ) <NEWLINE> print ( a [ 0 ] + b [ 1 ] + c [ 2 ] ) <NEWLINE>
c1 = input ( ) . split ( ) <NEWLINE> c2 = input ( ) . split ( ) <NEWLINE> c3 = input ( ) . split ( ) <NEWLINE> print ( c1 [ 0 ] + c2 [ 1 ] + c3 [ 2 ] ) <NEWLINE>
31415 92653 <NEWLINE>
A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> count = 0 <NEWLINE> <NL> for i in range ( A , B + 1 ) : <NEWLINE> <INDENT> if i [ 0 ] == i [ 4 ] and i [ 1 ] == i [ 3 ] : <NEWLINE> <INDENT> count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
def f ( x ) : <NEWLINE> <INDENT> l = len ( x ) <NEWLINE> i = 0 <NEWLINE> while x [ i ] == x [ l - i - 1 ] : <NEWLINE> <INDENT> i += 1 <NEWLINE> if i > ( l // 2 ) : <NEWLINE> <INDENT> return True <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> return False <NEWLINE> <NL> <DEDENT> A , B = map ( input ( ) . split ( ) ) <NEWLINE> count = 0 <NEWLINE> for i in range ( A , B + 1 ) : <NEWLINE> <INDENT> if f ( i ) : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
a , b = map ( str , input ( ) . split ( ) ) <NEWLINE> count = 0 <NEWLINE> for i in range ( a , b ) : <NEWLINE> <INDENT> if i [ 0 ] == i [ 4 ] and i [ 1 ] == i [ 3 ] : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> import sys <NEWLINE> from io import StringIO <NEWLINE> import unittest <NEWLINE> <NL> <NL> class TestClass ( unittest . TestCase ) : <NEWLINE> <INDENT> def assertIO ( self , input , output ) : <NEWLINE> <INDENT> stdout , stdin = sys . stdout , sys . stdin <NEWLINE> sys . stdout , sys . stdin = StringIO ( ) , StringIO ( input ) <NEWLINE> resolve ( ) <NEWLINE> sys . stdout . seek ( 0 ) <NEWLINE> out = sys . stdout . read ( ) [ : - 1 ] <NEWLINE> sys . stdout , sys . stdin = stdout , stdin <NEWLINE> self . assertEqual ( out , output ) <NEWLINE> <NL> <DEDENT> def test__1 ( self ) : <NEWLINE> <INDENT> input = <STRING> <NEWLINE> output = <STRING> <NEWLINE> self . assertIO ( input , output ) <NEWLINE> <NL> <DEDENT> def test__2 ( self ) : <NEWLINE> <INDENT> input = <STRING> <NEWLINE> output = <STRING> <NEWLINE> self . assertIO ( input , output ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def resolve ( ) : <NEWLINE> <INDENT> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( A , B + 1 ) : <NEWLINE> <INDENT> s = str ( i ) <NEWLINE> for j in range ( ( 3 ) : <NEWLINE> <INDENT> if s [ j ] != s [ - 1 - j ] : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <COMMENT> <NL> <INDENT> resolve ( ) <NEWLINE> <DEDENT>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> c = 0 <NEWLINE> for i in range ( a , b + 1 ) : <NEWLINE> <INDENT> s = list ( map ( str , i ) ) <NEWLINE> if s = reversed ( s ) : <NEWLINE> <INDENT> c += 1 <NEWLINE> <DEDENT> <DEDENT> print ( c ) <NEWLINE>
n , m = map ( int , inout ( ) . split ( ) ) <NEWLINE> if n * m == 1 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> elif n == 1 or m == 1 : <NEWLINE> <INDENT> print ( n + m - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ( n - 2 ) * ( m - 2 ) ) <NEWLINE> <DEDENT>
def f ( x ) : <NEWLINE> <INDENT> if x == 0 : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> elif x == 1 : <NEWLINE> <INDENT> return 0 <NEWLINE> <NL> <DEDENT> <DEDENT> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> a = [ [ 0 ] * ( M + 2 ) for _ in range ( N + 2 ) ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> for j in range ( M ) : <NEWLINE> <INDENT> a [ i ] [ j ] = f ( a [ i ] [ j ] ) <NEWLINE> a [ i ] [ j + 1 ] = f ( a [ i ] [ j + 1 ] ) <NEWLINE> a [ i ] [ j + 2 ] = f ( a [ i ] [ j + 2 ] ) <NEWLINE> a [ i + 1 ] [ j ] = f ( a [ i + 1 ] [ j ] ) <NEWLINE> a [ i + 1 ] [ j + 1 ] = f ( a [ i + 1 ] [ j + 1 ] ) <NEWLINE> a [ i + 1 ] [ j + 2 ] = f ( a [ i + 1 ] [ j + 2 ] ) <NEWLINE> a [ i + 2 ] [ j ] = f ( a [ i + 2 ] [ j ] ) <NEWLINE> a [ i + 2 ] [ j + 1 ] = f ( a [ i + 2 ] [ j + 1 ] ) <NEWLINE> a [ i + 2 ] [ j + 2 ] = f ( a [ i + 2 ] [ j + 2 ] ) <NEWLINE> <DEDENT> <DEDENT> print ( sum ( a [ 1 : N + 1 , 1 : M + 1 ] ) ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <COMMENT> <NL> if N == M == 1 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> if N == 1 and M >= 2 : <NEWLINE> <INDENT> print ( M - 2 ) <NEWLINE> <DEDENT> if N == 2 and M >= 2 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> if N >= 3 and M >= 3 : <NEWLINE> <INDENT> print ( ( N - 2 ) * ( M - 2 ) <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> elif ( n == 1 ) or ( m == 1 ) : <NEWLINE> <INDENT> if ( n == 1 ) and ( m == 1 ) : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( max ( 0 , max ( n , m ) - 2 ) ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( ( n - 2 ) * ( m - 2 ) ) <NEWLINE> <DEDENT>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> if n == 1 : <NEWLINE> <INDENT> if m == 1 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( m - 2 ) <NEWLINE> <DEDENT> <DEDENT> elif m == 1 : <NEWLINE> <INDENT> print ( n - 2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ( N - 2 ) * ( M - 2 ) ) <NEWLINE> <DEDENT>
if N > 1 and M > 1 : <NEWLINE> <INDENT> four = 4 <NEWLINE> six = ( N - 2 ) * 2 + ( M - 2 ) * 2 <NEWLINE> nine = N * M - four - six <NEWLINE> print ( nine ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> two = 2 <NEWLINE> three = N * M - two <NEWLINE> print ( three ) <NEWLINE> <DEDENT>
import re <NEWLINE> import sys <NEWLINE> import math <NEWLINE> import itertools <NEWLINE> import bisect <NEWLINE> from copy import copy <NEWLINE> from collections import deque , Counter <NEWLINE> from decimal import Decimal <NEWLINE> import functools <NEWLINE> def s ( ) : return input ( ) <NEWLINE> def k ( ) : return int ( input ( ) ) <NEWLINE> def S ( ) : return input ( ) . split ( ) <NEWLINE> def I ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def X ( ) : return list ( input ( ) ) <NEWLINE> def L ( ) : return list ( input ( ) . split ( ) ) <NEWLINE> def l ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> def lcm ( a , b ) : return a * b // math . gcd ( a , b ) <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> cnt = 0 <NEWLINE> ans = 0 <NEWLINE> inf = float ( <STRING> ) <NEWLINE> <NL> S = s ( ) <NEWLINE> if len ( S ) == 26 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> alpha = [ <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> <NL> for i in alpha : <NEWLINE> <INDENT> if i not in S : <NEWLINE> <INDENT> print ( S + ans ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT>
N = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if N = <NEWLINE>
<COMMENT> <NL> N = int ( input ( ) ) <NEWLINE> <NL> <COMMENT> <NL> groupnum = math . floor ( N / 3 ) <NEWLINE> <NL> <COMMENT> <NL> print ( groupnum ) <NEWLINE>
n = input ( ) <NEWLINE> print ( str ( n // 3 ) ) <NEWLINE>
n = input ( ) <NEWLINE> print ( n // 3 ) <NEWLINE>
N = int ( intput ( ) ) <NEWLINE> <NL> print ( N // 3 ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> <NL> x == N // 3 <NEWLINE> <NL> print ( x ) <NEWLINE>
n = map ( int , input ( ) ) <NEWLINE> print ( n // 3 ) <NEWLINE>
print ( int ( input ) // 3 ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( str , input ( ) . split ( ) ) ) <NEWLINE> counter = 0 <NEWLINE> if <STRING> , <STRING> , <STRING> , <STRING> in A : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import sys <NEWLINE> import math <NEWLINE> import itertools <NEWLINE> import bisect <NEWLINE> from copy import copy <NEWLINE> from collections import deque , Counter <NEWLINE> from decimal import Decimal <NEWLINE> def s ( ) : return input ( ) <NEWLINE> def i ( ) : return int ( input ( ) ) <NEWLINE> def S ( ) : return input ( ) . split ( ) <NEWLINE> def I ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def L ( ) : return list ( input ( ) . split ( ) ) <NEWLINE> def l ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> def lcm ( a , b ) : return a * b // math . gcd ( a , b ) <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> INF = 10 ** 9 <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> s = [ 0 ] * 4 <NEWLINE> N = i ( ) <NEWLINE> S = l ( ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if S [ i ] == <STRING> : <NEWLINE> <INDENT> s [ 0 ] = 1 <NEWLINE> <DEDENT> if S [ i ] == <STRING> : <NEWLINE> <INDENT> s [ 1 ] = 1 <NEWLINE> <DEDENT> if S [ i ] == <STRING> : <NEWLINE> <INDENT> s [ 2 ] = 1 <NEWLINE> <DEDENT> if S [ i ] == <STRING> : <NEWLINE> <INDENT> s [ 3 ] = 1 <NEWLINE> <DEDENT> <DEDENT> print ( sum ( s ) ) <NEWLINE>
_ = input ( ) <NEWLINE> * S , = map ( int , input ( ) . split ( ) ) <NEWLINE> l = len ( set ( S ) ) <NEWLINE> if l == 4 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> D = [ input ( ) for _ in range ( N ) ] <NEWLINE> print ( <STRING> if len ( set ( D ) ) == 4 else <STRING> ) <NEWLINE>
n , * s = map ( int , open ( 0 ) . read ( ) . split ( ) ) <NEWLINE> print ( <STRING> [ len ( set ( s ) ) == 4 : : 2 ] ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = input ( ) . split ( ) <NEWLINE> <NL> if Y in s : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if len ( set ( a ) ) == 3 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> S = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> X = set ( ) <NEWLINE> for s in S : <NEWLINE> <INDENT> X . add ( s ) <NEWLINE> <NL> <DEDENT> if len ( X ) == 3 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> k = len ( set ( map ( str , input ( ) . split ( ) ) ) ) <NEWLINE> if k = 4 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
i = int ( input ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> print ( <STRING> if l . count ( <STRING> ) > 0 else <STRING> ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if <STRING> in S : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> lis = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if i == <STRING> : <NEWLINE> <INDENT> ans = 1 <NEWLINE> <DEDENT> <DEDENT> print ( [ <STRING> , <STRING> ] [ ans ] ) <NEWLINE>
a = input ( ) <NEWLINE> b = list ( map ( input ( ) . split ( ) ) ) <NEWLINE> if <STRING> in b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> L = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> L = set ( L ) <NEWLINE> if len ( L ) == 4 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> S = list ( map ( string , input ( ) . slipt ( ) ) ) <NEWLINE> <NL> if <STRING> in S : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) ; print ( <STRING> if len ( set ( map ( input ( ) . split ( ) ) ) ) == 3 else <STRING> ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> lists = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> sets = set ( lists ) <NEWLINE> ans = len ( sets ) <NEWLINE> <NL> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> List = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> s_l = set ( List ) <NEWLINE> if len ( s_l ) == 3 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> d = { <STRING> : 0 , <STRING> : 0 , <STRING> : 0 , <STRING> : 0 , <STRING> : 0 } <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> if s [ 0 ] == <STRING> : <NEWLINE> <INDENT> d [ <STRING> ] += 1 <NEWLINE> <DEDENT> if s [ 0 ] == <STRING> : <NEWLINE> <INDENT> d [ <STRING> ] += 1 <NEWLINE> <DEDENT> if s [ 0 ] == <STRING> : <NEWLINE> <INDENT> d [ <STRING> ] += 1 <NEWLINE> <DEDENT> if s [ 0 ] == <STRING> : <NEWLINE> <INDENT> d [ <STRING> ] += 1 <NEWLINE> <DEDENT> if s [ 0 ] == <STRING> : <NEWLINE> <INDENT> d [ <STRING> ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for i , j , k in combinations ( <STRING> , 3 ) : <NEWLINE> <INDENT> ans += d [ i ] * d [ j ] * d [ k ] <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
using System ; <NEWLINE> using static System . Console ; <NEWLINE> using System . Linq ; <NEWLINE> using System . Collections . Generic ; <NEWLINE> class Program <NEWLINE> { <NEWLINE> <INDENT> static void Main ( string [ ] args ) <NEWLINE> { <NEWLINE> <INDENT> int n = int . Parse ( ReadLine ( ) ) ; <NEWLINE> List < string > s = new List < string > ( ) ; <NEWLINE> <NL> for ( int i = 0 ; i < n ; i + + ) <NEWLINE> { <NEWLINE> <INDENT> s . Add ( ReadLine ( ) ) ; <NEWLINE> <DEDENT> } <NEWLINE> var hashSet = new HashSet < string > ( s ) ; <NEWLINE> s = hashSet . ToList ( ) ; <NEWLINE> List < int > ans = new List < int > ( ) ; <NEWLINE> <NL> for ( int i = 0 ; i < 5 ; i + + ) <NEWLINE> { <NEWLINE> <INDENT> ans . Add ( 0 ) ; <NEWLINE> <DEDENT> } <NEWLINE> <NL> for ( int i = 0 ; i < s . Count ; i + + ) <NEWLINE> { <NEWLINE> <INDENT> if ( s [ i ] . Substring ( 0 , 1 ) == <STRING> ) <NEWLINE> { <NEWLINE> <INDENT> ans [ 0 ] += 1 ; <NEWLINE> <DEDENT> } <NEWLINE> else if ( s [ i ] . Substring ( 0 , 1 ) == <STRING> ) <NEWLINE> { <NEWLINE> <INDENT> ans [ 1 ] += 1 ; <NEWLINE> <DEDENT> } <NEWLINE> else if ( s [ i ] . Substring ( 0 , 1 ) == <STRING> ) <NEWLINE> { <NEWLINE> <INDENT> ans [ 2 ] += 1 ; <NEWLINE> <DEDENT> } <NEWLINE> else if ( s [ i ] . Substring ( 0 , 1 ) == <STRING> ) <NEWLINE> { <NEWLINE> <INDENT> ans [ 3 ] += 1 ; <NEWLINE> <DEDENT> } <NEWLINE> else if ( s [ i ] . Substring ( 0 , 1 ) == <STRING> ) <NEWLINE> { <NEWLINE> <INDENT> ans [ 4 ] += 1 ; <NEWLINE> <DEDENT> } <NEWLINE> <DEDENT> } <NEWLINE> int answ = 0 ; <NEWLINE> for ( int i = 0 ; i < 5 ; i + + ) <NEWLINE> { <NEWLINE> <INDENT> for ( int j = i + 1 ; j < 5 ; j + + ) <NEWLINE> { <NEWLINE> <INDENT> for ( int k = j + 1 ; k < 5 ; k + + ) <NEWLINE> { <NEWLINE> <INDENT> if ( i != j & & j != k & & i != k ) <NEWLINE> { <NEWLINE> <INDENT> answ += ans [ i ] * ans [ j ] * ans [ k ] ; <NEWLINE> <DEDENT> } <NEWLINE> <DEDENT> } <NEWLINE> <DEDENT> } <NEWLINE> <DEDENT> } <NEWLINE> WriteLine ( answ ) ; <NEWLINE> <DEDENT> } <NEWLINE> <DEDENT> } <NEWLINE>
import sys <NEWLINE> import itertools <NEWLINE> <NL> input = sys . stdin . readline <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> common = common_function ( ) <NEWLINE> N = int ( input ( ) ) <NEWLINE> l = [ <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> m = [ 0 ] * 5 <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> S = input ( ) [ : - 1 ] <NEWLINE> Shead = S [ 0 ] <NEWLINE> for i , s0 in enumerate ( l ) : <NEWLINE> <INDENT> if Shead == s0 : <NEWLINE> <INDENT> m [ i ] += 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> ll = [ ] <NEWLINE> for i , n in enumerate ( m ) : <NEWLINE> <INDENT> if n >= 1 : <NEWLINE> <INDENT> ll . append ( l [ i ] ) <NEWLINE> <DEDENT> <DEDENT> if len ( ll ) <= 2 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> return <NEWLINE> <DEDENT> ans = 0 <NEWLINE> for i , j , k in itertools . combinations ( ll , 3 ) : <NEWLINE> <INDENT> ans += m [ l . index ( i ) ] * m [ l . index ( j ) ] * m [ l . index ( k ) ] <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import itertools <NEWLINE> n = int ( input ( ) ) <NEWLINE> names = [ input ( ) for i in range ( n ) ] <NEWLINE> names = [ i for i in names if i [ 0 ] in <STRING> ] <NEWLINE> <NL> <NL> print ( len ( list ( itertools . combinations ( seq , 3 ) ) ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> Mnum = 0 <NEWLINE> Anum = 0 <NEWLINE> Rnum = 0 <NEWLINE> Cnum = 0 <NEWLINE> Hnum = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a = input ( ) <NEWLINE> if a [ 0 ] == <STRING> : <NEWLINE> <INDENT> Mnum += 1 <NEWLINE> <DEDENT> elif a [ 0 ] == <STRING> : <NEWLINE> <INDENT> Anum += 1 <NEWLINE> <DEDENT> elif a [ 0 ] == <STRING> : <NEWLINE> <INDENT> Rnum += 1 <NEWLINE> <DEDENT> elif a [ 0 ] == <STRING> : <NEWLINE> <INDENT> Cnum += 1 <NEWLINE> <DEDENT> elif a [ 0 ] == <STRING> : <NEWLINE> <INDENT> Hnum += 1 <NEWLINE> <DEDENT> <DEDENT> alist = [ ] <NEWLINE> alist . append ( Mnum ) <NEWLINE> alist . append ( Anum ) <NEWLINE> alist . append ( Rnum ) <NEWLINE> alist . append ( Cnum ) <NEWLINE> alist . append ( Hnum ) <NEWLINE> from itertools import combinations <NEWLINE> blist = list ( combinations ( alist , 3 ) ) <NEWLINE> from functools import reduce <NEWLINE> sum = 0 <NEWLINE> for i in range ( len ( blist ) ) : <NEWLINE> <INDENT> sum += reduce ( mul , blist [ i ] ) <NEWLINE> <DEDENT> print ( sum ) <NEWLINE>
import numpy as np <NEWLINE> from itertools <NEWLINE> from functools import reduce <NEWLINE> from collections import defaultdict <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> d = defaultdict ( int ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> c = input ( ) <NEWLINE> if c [ 0 ] in ( <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ) : <NEWLINE> <INDENT> d [ c [ 0 ] ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> l = len ( d ) <NEWLINE> if l < 3 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = 0 <NEWLINE> for l in list ( itertools . combinations ( d . values ( ) , 3 ) ) : <NEWLINE> <INDENT> ans += reduce ( np . multiply , l ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> name = [ 0 ] * 5 <NEWLINE> ans = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> a = input ( ) <NEWLINE> if a [ 0 ] == <STRING> : name [ 0 ] += 1 <NEWLINE> elif a [ 0 ] == <STRING> : name [ 1 ] += 1 <NEWLINE> elif a [ 0 ] == <STRING> : name [ 2 ] += 1 <NEWLINE> elif a [ 0 ] == <STRING> : name [ 3 ] += 1 <NEWLINE> elif a [ 0 ] == <STRING> : name [ 4 ] += 1 <NEWLINE> <DEDENT> if sum ( name ) < 3 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in combinations ( name , 3 ) : <NEWLINE> <INDENT> ans += i [ 0 ] * i [ 1 ] * i [ 2 ] <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT>
N = int ( input ( ) ) <NEWLINE> M_Dict = { <STRING> : 0 , <STRING> : 0 , <STRING> : 0 , <STRING> : 0 , <STRING> : 0 } <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> moji = str ( input ( ) ) <NEWLINE> if moji [ 0 ] in M_Dict . keys ( ) : <NEWLINE> <INDENT> M_Dict [ moji [ 0 ] ] += 1 <NEWLINE> <DEDENT> <DEDENT> M_Dict = { k : v for k , v in M_Dict . items ( ) if v != 0 } <NEWLINE> if len ( M_Dict ) < 3 : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = 0 <NEWLINE> for k in itertools . combinations ( list ( M_Dict . keys ( ) ) , 3 ) : <NEWLINE> <INDENT> ans += M_Dict [ k [ 0 ] ] * M_Dict [ k [ 1 ] ] * M_Dict [ [ 2 ] ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> <NL> import numba as nb <NEWLINE> import numpy as np <NEWLINE> <NL> input = sys . stdin . readline <NEWLINE> <NL> <NL> @ nb . njit ( <STRING> , cache = True ) <NEWLINE> def dfs ( H , W , D , A , Q , LR , ans ) : <NEWLINE> <INDENT> position = [ ( - 1 , - 1 ) ] * ( H * W + 1 ) <NEWLINE> for h in range ( H ) : <NEWLINE> <INDENT> for w in range ( W ) : <NEWLINE> <INDENT> position [ A [ h ] [ w ] ] = ( h , w ) <NEWLINE> <NL> <DEDENT> <DEDENT> mp = np . zeros ( shape = ( H * W + 1 ) , dtype = np . int64 ) <NEWLINE> <NL> for i in range ( 1 , H * W + 1 - D ) : <NEWLINE> <INDENT> h , w = position [ i ] <NEWLINE> y , x = position [ i + D ] <NEWLINE> mp [ i ] = abs ( x - w ) + abs ( y - h ) <NEWLINE> <NL> <DEDENT> for i in range ( Q ) : <NEWLINE> <INDENT> l , r = LR [ i ] <NEWLINE> ans [ i ] = mp [ l : r : D ] . sum ( ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <INDENT> H , W , D = map ( int , input ( ) . split ( ) ) <NEWLINE> A = np . zeros ( shape = ( H , W ) , dtype = np . int64 ) <NEWLINE> for i in range ( H ) : <NEWLINE> <INDENT> A [ i ] = tuple ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <DEDENT> Q = int ( input ( ) ) <NEWLINE> LR = np . zeros ( shape = ( Q , 2 ) , dtype = np . int64 ) <NEWLINE> for i in range ( Q ) : <NEWLINE> <INDENT> LR [ i ] = tuple ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <DEDENT> ans = np . zeros ( shape = Q , dtype = np . int64 ) <NEWLINE> dfs ( H , W , D , A , Q , LR , ans ) <NEWLINE> <NL> print ( <STRING> . join ( map ( str , ans ) ) ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> <NL> h , w , d = map ( int , input ( ) . split ( ) ) <NEWLINE> arr = np . zeros ( [ h , w ] , dtype = np . int64 ) <NEWLINE> <NL> for i in range ( h ) : <NEWLINE> <INDENT> arr [ i ] = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <DEDENT> q = int ( input ( ) ) <NEWLINE> lr = np . zeros ( [ q , 2 ] , dtype = np . int64 ) <NEWLINE> <NL> for i in range ( q ) : <NEWLINE> <INDENT> lr [ i ] = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> <DEDENT> cnt = h * w <NEWLINE> result = [ [ 0 ] for _ in range ( d ) ] <NEWLINE> for i in range ( d ) : <NEWLINE> <INDENT> l = i <NEWLINE> score = 0 <NEWLINE> while l + d <= cnt : <NEWLINE> <INDENT> if l == 0 : <NEWLINE> <INDENT> result [ i ] . append ( score ) <NEWLINE> l += d <NEWLINE> continue <NEWLINE> <DEDENT> u = np . where ( arr == l ) <NEWLINE> v = np . where ( arr == l + d ) <NEWLINE> score += abs ( v [ 0 ] [ 0 ] - u [ 0 ] [ 0 ] ) + abs ( v [ 1 ] [ 0 ] - u [ 1 ] [ 0 ] ) <NEWLINE> result [ i ] . append ( score ) <NEWLINE> l += d <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> result = solve ( h , w , d , arr ) <NEWLINE> <NL> <NL> for l , r in lr : <NEWLINE> <INDENT> ans = result [ l % d ] <NEWLINE> print ( ans [ r // d ] - ans [ l // d ] ) <NEWLINE> <DEDENT>
import sys , re <NEWLINE> from collections import deque , defaultdict , Counter <NEWLINE> from math import ceil , sqrt , hypot , factorial , pi , sin , cos , tan , asin , acos , atan , radians , degrees <COMMENT> <NEWLINE> from itertools import accumulate , permutations , combinations , combinations_with_replacement , product , groupby <NEWLINE> from operator import itemgetter , mul <NEWLINE> from copy import deepcopy <NEWLINE> from string import ascii_lowercase , ascii_uppercase , digits <NEWLINE> from bisect import bisect , bisect_left , insort , insort_left <NEWLINE> from fractions import gcd <NEWLINE> from heapq import heappush , heappop <NEWLINE> from functools import reduce <NEWLINE> def input ( ) : return sys . stdin . readline ( ) . strip ( ) <NEWLINE> def INT ( ) : return int ( input ( ) ) <NEWLINE> def MAP ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def LIST ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> def ZIP ( n ) : return zip ( * ( MAP ( ) for _ in range ( n ) ) ) <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> INF = float ( <STRING> ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <COMMENT> <NL> <NL> H , W , D = MAP ( ) <NEWLINE> A = [ LIST ( ) for _ in range ( H ) ] <NEWLINE> <NL> dic = defaultdict ( tuple ) <NEWLINE> <NL> for y in range ( H ) : <NEWLINE> <INDENT> for x in range ( W ) : <NEWLINE> <INDENT> dic [ A [ y ] [ x ] ] = ( y + 1 , x + 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> power = [ [ ] for _ in range ( D ) ] <NEWLINE> for i in range ( 1 , H * W + 1 ) : <NEWLINE> <INDENT> if i <= D : <NEWLINE> <INDENT> power [ i % D ] . append ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> idx = i % D <NEWLINE> tmp = abs ( dic [ i ] [ 0 ] - dic [ i - D ] [ 0 ] ) + abs ( dic [ i ] [ 1 ] - dic [ i - D ] [ 1 ] ) <NEWLINE> power [ i % D ] . append ( tmp ) <NEWLINE> <NL> <DEDENT> <DEDENT> power_acc = [ ] <NEWLINE> for x in power : <NEWLINE> <INDENT> power_acc . append ( list ( accumulate ( x ) ) ) <NEWLINE> <NL> <DEDENT> Q = INT ( ) <NEWLINE> for _ in range ( Q ) : <NEWLINE> <INDENT> L , R = MAP ( ) <NEWLINE> print ( power_acc [ R % D ] [ R // D ] - power_acc [ L % D ] [ L // D ] ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> if n <= 9 : <NEWLINE> <INDENT> print ( n ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> n = str ( n ) <NEWLINE> x = n [ 0 ] <NEWLINE> x = int ( x ) - 1 <NEWLINE> if n [ 1 : ] . count ( <STRING> ) == len ( n - 1 ) : <NEWLINE> <INDENT> print ( x + 1 ( len ( n ) - 1 ) * 9 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( x + ( len ( n ) - 1 ) * 9 ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> k = len ( str ( n ) ) <NEWLINE> a = 9 * ( k - 1 ) <NEWLINE> b = 0 <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> b += int ( str ( n ) [ i ] ) <NEWLINE> <DEDENT> c = 0 <NEWLINE> if k > 2 : <NEWLINE> <INDENT> m = str ( int ( n ) ) [ : k - 2 ] + str ( int ( int ( str ( n ) [ - 2 ] ) - 1 ) ) + <STRING> <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> c += int ( m [ i ] ) <NEWLINE> <DEDENT> <DEDENT> ans = max ( a , b , c ) <NEWLINE> print ( ans ) <NEWLINE>
n = input ( ) <NEWLINE> ans1 = int ( n [ 0 ] ) <NEWLINE> for i in n : <NEWLINE> <INDENT> ans1 += int ( i ) <NEWLINE> <DEDENT> ans2 = int ( n [ 0 ] ) - 1 + 9 * ( len ( n ) - 1 ) <NEWLINE> print ( max ( ans1 , ans2 ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> sum = int ( n [ 0 ] ) + ( len ( n ) - 1 ) * 9 <NEWLINE> print ( sum if set ( n [ 1 : ] ) == { <STRING> } else sum - 1 ) <NEWLINE>
Num = str ( input ( ) ) <NEWLINE> L = len ( Num ) <NEWLINE> if Num [ 1 : ] == <STRING> * ( l - 1 ) : <NEWLINE> <INDENT> val = int ( Num [ 0 ] ) + 9 * ( l - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> val = int ( Num [ 0 ] ) - 1 + 9 * ( l - 1 ) <NEWLINE> <DEDENT> print ( val ) <NEWLINE>
def resolve ( ) : <NEWLINE> <INDENT> n = input ( ) <NEWLINE> l = len ( n ) <NEWLINE> if n [ : 1 ] == <STRING> * l - 1 : <COMMENT> <NEWLINE> <INDENT> print ( int ( n [ 0 ] ) + 9 * ( l - 1 ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ( int ( n [ 0 ] ) - 1 ) + ( 9 * ( l - 1 ) ) ) <NEWLINE> <DEDENT> <DEDENT> resolve ( ) <NEWLINE>
import sys , re <NEWLINE> from collections import deque , defaultdict , Counter <NEWLINE> from math import ceil , sqrt , hypot , factorial , pi , sin , cos , tan , asin , acos , atan , radians , degrees , log2 <NEWLINE> from itertools import accumulate , permutations , combinations , combinations_with_replacement , product , groupby <NEWLINE> from operator import itemgetter , mul <NEWLINE> from copy import deepcopy <NEWLINE> from string import ascii_lowercase , ascii_uppercase , digits <NEWLINE> from bisect import bisect , bisect_left , insort , insort_left <NEWLINE> from fractions import gcd <NEWLINE> from heapq import heappush , heappop <NEWLINE> from functools import reduce <NEWLINE> def input ( ) : return sys . stdin . readline ( ) . strip ( ) <NEWLINE> def INT ( ) : return int ( input ( ) ) <NEWLINE> def MAP ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def LIST ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> def ZIP ( n ) : return zip ( * ( MAP ( ) for _ in range ( n ) ) ) <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> INF = float ( <STRING> ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <COMMENT> <NL> <NL> def ketawa ( x ) : <NEWLINE> <INDENT> return sum ( map ( int , list ( str ( x ) ) ) ) <NEWLINE> <NL> <DEDENT> N = input ( ) <NEWLINE> <NL> if len ( N ) == 1 : <NEWLINE> <INDENT> print ( N ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> pint ( max ( ketawa ( N ) , int ( N [ 0 ] ) - 1 + 9 * ( len ( N ) - 1 ) ) ) <NEWLINE> <DEDENT>
def maxf ( n ) : <NEWLINE> <INDENT> a = list ( map ( int , list ( n ) ) ) <NEWLINE> for i , item in enumerate ( a ) : <NEWLINE> <INDENT> if i == 0 and item != 9 : <NEWLINE> <INDENT> a [ i ] -= 1 <NEWLINE> a [ i + 1 : ] = [ 9 ] * ( len ( a ) - 1 ) <NEWLINE> break <NEWLINE> <DEDENT> elif item != 9 : <NEWLINE> <INDENT> a [ i - 1 ] -= 1 <NEWLINE> a [ i : ] = [ 9 ] * ( len ( a ) - i ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> return sum ( a ) <NEWLINE> <NL> <DEDENT> print ( maxf ( input ( ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> n = len ( str ( N ) ) <NEWLINE> NS = str ( N ) <NEWLINE> ans0 = 0 <NEWLINE> for i in range ( NS ) : <NEWLINE> <INDENT> ans0 += int ( i ) <NEWLINE> <DEDENT> ans1 = int ( NS [ 0 ] ) - 1 + 9 * ( n - 1 ) <NEWLINE> ans2 = 9 * ( n - 1 ) <NEWLINE> <NL> print ( max ( ans0 , ans1 , ans2 ) ) <NEWLINE>
s = list ( input ( ) ) <NEWLINE> ans = [ sum ( map ( int , s ) ) , 9 * ( len ( s ) - 1 ) + int ( s [ 0 ] - 1 ) ] <NEWLINE> print ( max ( ans ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> <NL> for i in range ( 17 ) : <NEWLINE> <INDENT> if 10 ** i <= N < 10 ** ( i + 1 ) : <NEWLINE> <INDENT> m = i + 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> for j in range ( 1 , 10 ) : <NEWLINE> <INDENT> if ( 10 ** ( m - 1 ) ) * j + 10 ** ( m - 1 ) - 1 <= N < ( j + 1 ) * ( 10 ** ( m - 1 ) ) + 10 ** ( m - 1 ) - 1 : <NEWLINE> <INDENT> a = j <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( a + 9 * ( m - 1 ) ) <NEWLINE>
n , k , p = map ( int , input ( ) . split ( ) ) , 998244353 <NEWLINE> r = range <NEWLINE> f = [ 1 ] <NEWLINE> for i in r ( k ) : f += [ - ~ i * f [ i ] ] <NEWLINE> print ( sum ( f [ - 1 ] * pow ( f [ i ] * f [ - 1 - i ] , - 1 , p ) for i in r ( n - 1 , k ) ) % p ) <NEWLINE>
N , A = map ( int , input ( ) . split ( ) ) <NEWLINE> if N % 500 <= A : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import math <NEWLINE> N = int ( input ( ) ) <NEWLINE> L = input ( ) . split ( ) <NEWLINE> l = [ int ( s ) for s in L ] <NEWLINE> list . sort ( l , reverse = True ) <NEWLINE> a = 0 <NEWLINE> x = 0 <NEWLINE> m = math . ceil ( N / 2 ) <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> x += int ( l [ a ] ) <NEWLINE> a += 2 <NEWLINE> <DEDENT> a = 1 <NEWLINE> y = 0 <NEWLINE> for i in range ( N - m ) : <NEWLINE> <INDENT> y += int ( l [ a ] ) <NEWLINE> b += 2 <NEWLINE> <DEDENT> print ( x - y ) <NEWLINE>
N , A = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if N // 500 <= A : print ( <STRING> ) <NEWLINE> else : print ( <STRING> ) <NEWLINE>
a = int ( input ( ) ) <NEWLINE> b = int ( input ( ) ) <NEWLINE> if a % 500 = < b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = int ( input ( ) ) <NEWLINE> if n % 500 <= a : <NEWLINE> <INDENT> plint ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = int ( input ( <STRING> ) ) <NEWLINE> A = int ( input ( <STRING> ) ) <NEWLINE> <NL> b = n % 500 <NEWLINE> <NL> if A > b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a = [ int ( input ( ) ) for i in range ( 2 ) ] <NEWLINE> n = a [ 0 ] % 500 <NEWLINE> if a >= n : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = input ( ) <NEWLINE> A = input ( ) <NEWLINE> <NL> amari = N % 500 <NEWLINE> if amari <= A : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = int ( input ( ) ) <NEWLINE> if n % 500 <= a : <NEWLINE> <INDENT> plint ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = int ( input ( ) ) <NEWLINE> print ( [ <STRING> , <STRING> ] [ n % 500 > a ] <NEWLINE>
N = int ( input ( ) ) <NEWLINE> lst = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> lst . sort ( reverse = True ) <NEWLINE> <NL> A = 0 <NEWLINE> B = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if i == 0 or i % 2 == 0 : <NEWLINE> <INDENT> A += lst [ i ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> B += lst [ i ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( int ( A ) - int ( B ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> a = sorted ( [ int ( i ) for i in input ( ) . split ( ) ] , reverse = True ) <NEWLINE> print ( sum ( a [ 0 : : 2 ] - sum ( a [ 1 : : 2 ] ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> K = int ( input ( ) ) <NEWLINE> X = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> res = 0 <NEWLINE> for x in X : <NEWLINE> <INDENT> res += 2 * min ( x , K - x ) <NEWLINE> <DEDENT> print ( res ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A . sort ( reverse = True ) <NEWLINE> <NL> print ( sum ( l [ 0 : : 2 ] ) - sum ( l [ 1 : : 2 ] ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) [ ] <NEWLINE> print ( sum ( A [ - 1 : : - 2 ] ) - sum ( A [ - 2 : : - 2 ] ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a . reverse ( key = int ) <NEWLINE> Ali = 0 <NEWLINE> Bob = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if i % 2 == 0 : <NEWLINE> <INDENT> Ali += a [ i ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> Bob += a [ i ] <NEWLINE> <DEDENT> <DEDENT> ans ( Ali - Bob ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> def sort_reverse ( n ) : <NEWLINE> <INDENT> n . sort ( reverse = True ) <NEWLINE> return n <NEWLINE> <NL> <DEDENT> N_Even = list ( range ( 0 , N + 1 , 2 ) ) <NEWLINE> N_Odd = list ( range ( 1 , N + 1 , 2 ) ) <NEWLINE> a1 = sort_reverse ( a ) <NEWLINE> sum1 = 0 <NEWLINE> sum2 = 0 <NEWLINE> <NL> for i in N_Even : <NEWLINE> <INDENT> sum1 += a1 [ i ] <NEWLINE> <DEDENT> for j in N_Odd : <NEWLINE> <INDENT> sum2 += a1 [ j ] <NEWLINE> <NL> <DEDENT> print ( sum1 - sum2 ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> a = sorted ( map ( int , input ( ) . split ( ) ) ) [ : : - 1 ] <NEWLINE> diff = sum ( [ : : 2 ] ) - sum ( [ 1 : : 2 ] ) <NEWLINE> print ( diff ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a . sort ( ) <NEWLINE> alice_sum = 0 <NEWLINE> bob_sum = 0 <NEWLINE> if len ( a ) % 2 == 0 : <NEWLINE> <INDENT> for i in range ( , n , 2 ) : <NEWLINE> <INDENT> bob_sum += a [ i ] <NEWLINE> <DEDENT> for l in range ( 1 , n , 2 ) : <NEWLINE> <INDENT> alice_sum += a [ i ] <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( , n , 2 ) : <NEWLINE> <INDENT> alice_sum += a [ i ] <NEWLINE> <DEDENT> for k in range ( 1 , n , 2 ) : <NEWLINE> <INDENT> bob_sum += a [ i ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( alice_sum - bob_sum ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A . sort ( reverse = True ) <NEWLINE> sum1 = 0 <NEWLINE> sum2 = 0 <NEWLINE> for num in range ( N + 1 ) : <NEWLINE> <INDENT> if num % 2 == 0 : <NEWLINE> <INDENT> sum1 += A [ num ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> sum2 += A [ num ] <NEWLINE> <DEDENT> <DEDENT> print ( sum1 - sum2 ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> A = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> B = sorted ( A ) <NEWLINE> Alice = [ ] <NEWLINE> Bob = [ ] <NEWLINE> while len ( B ) != 0 or len ( B ) != 1 : <NEWLINE> <INDENT> Alice . append ( B [ - 1 ] ) <NEWLINE> B . pop ( ) <NEWLINE> Bob . append ( B [ - 1 ] ) <NEWLINE> B . pop ( ) <NEWLINE> <DEDENT> if len ( B ) == 1 : <NEWLINE> <INDENT> Alice . append ( B [ 0 ] ) <NEWLINE> B . pop ( ) <NEWLINE> <DEDENT> print ( sum ( Alice ) - sum ( Bob ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a . sort ( reverse = True ) <NEWLINE> Alice = sum ( a [ : : 2 ] ) <NEWLINE> Bob = sum ( a [ 1 : : 2 ] ) <NEWLINE> print ( Alice - ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a . sorted ( ) <NEWLINE> alice = 0 <NEWLINE> bob = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if i % 2 == 0 : <NEWLINE> <INDENT> alice += a [ i ] <NEWLINE> <DEDENT> elif i % 2 == 1 : <NEWLINE> <INDENT> bob += a [ i ] <NEWLINE> <DEDENT> <DEDENT> print ( alice - bob ) <NEWLINE> <NL>
N = int ( input ( ) ) <NEWLINE> a = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> a . sort ( reverse = True ) <NEWLINE> <NL> print ( sum ( a [ : : 2 ] ) - sum ( a [ 1 : : 2 ] ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> a = [ map ( int , input ( ) . split ( ) ) for _ in range ( N ) ] <NEWLINE> a = sorted ( a ) [ : : - 1 ] <NEWLINE> Alice = 0 <NEWLINE> Bob = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if i % 2 == 0 : <NEWLINE> <INDENT> Alice += a [ i ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> Bob += a [ i ] <NEWLINE> <DEDENT> <DEDENT> print ( Alice - Bob ) <NEWLINE> <NL>
<NL> <NL> <COMMENT> <NL> if __name__ == <STRING> : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> a = input ( ) . split ( ) <NEWLINE> <NL> bob = 0 <NEWLINE> alice = 0 <NEWLINE> sort_a = sorted ( a , reverse = True ) <NEWLINE> count = 0 <NEWLINE> for m in sort_a : <NEWLINE> <INDENT> if m % 2 == 0 : <NEWLINE> <INDENT> alice = alice + int ( m ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> bob = bob + int ( m ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( alice - bob ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( int , input ( ) . split ( ) ) <NEWLINE> al = [ a [ 2 * i ] for i in range ( n // 2 ) ] <NEWLINE> bo = [ a [ 2 * i + 1 ] for i in range ( n // 2 ) ] <NEWLINE> print ( sum ( al ) - sum ( bo ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if n % 2 != 0 : <NEWLINE> <INDENT> a . append ( 0 ) <NEWLINE> n += 1 <NEWLINE> <NL> <DEDENT> a . sort ( ) <NEWLINE> d = 0 <NEWLINE> <NL> for i in range ( int ( n / 2 ) : <NEWLINE> <INDENT> d += a [ 2 * i + 1 ] - a [ 2 * i ] <NEWLINE> <NL> <DEDENT> print ( d ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> list_a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> list_a . sort ( reverse = True ) <NEWLINE> alice = 0 ; bob = 0 <NEWLINE> for i in range ( 0 , 100 ) : <NEWLINE> <INDENT> if i % 2 == 0 : <NEWLINE> <INDENT> alice += list_a [ i ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> bob += list_a [ i ] <NEWLINE> <DEDENT> <DEDENT> print ( alice - bob ) <NEWLINE> <NL>
import math <NEWLINE> N = int ( input ( ) ) <NEWLINE> L = input ( ) . split ( ) <NEWLINE> l = [ int ( s ) for s in L ] <NEWLINE> list . sort ( l , reverse = True ) <NEWLINE> a = 0 <NEWLINE> x = 0 <NEWLINE> m = math . ceil ( N / 2 ) <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> x += int ( l [ a ] ) <NEWLINE> a += 2 <NEWLINE> <DEDENT> a = 1 <NEWLINE> y = 0 <NEWLINE> for i in range ( N - m ) : <NEWLINE> <INDENT> y += int ( l [ a ] ) <NEWLINE> b += 2 <NEWLINE> <DEDENT> print ( x - y ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> cards = sorted ( list ( map ( int , input ( ) . split ( ) ) ) , reverse = True ) <NEWLINE> alice = [ ] <NEWLINE> bob = [ ] <NEWLINE> for i in range ( 0 , n , 2 ) : <NEWLINE> <INDENT> alice . append ( max ( cards [ i ] ) ) <NEWLINE> try : <NEWLINE> <INDENT> bob . append ( max ( cards [ i + 1 ] ) ) <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> print ( sum ( alice ) - sum ( bob ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> alice = 0 <NEWLINE> bob = 0 <NEWLINE> <NL> for n in range ( N ) : <NEWLINE> <INDENT> card = max ( a ) <NEWLINE> alice += card <NEWLINE> a . remove ( card ) <NEWLINE> if len ( a ) == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> card = max ( a ) <NEWLINE> bob += card <NEWLINE> a . remove ( card ) <NEWLINE> <NL> <DEDENT> print ( alice - bob ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) . sort ( reverse = True ) <NEWLINE> answer = 0 <NEWLINE> for i in range ( 0 , N , 2 ) : <NEWLINE> <INDENT> answer += a [ i ] <NEWLINE> <DEDENT> for i in range ( 1 , N , 2 ) : <NEWLINE> <INDENT> answer -= a [ i ] <NEWLINE> <DEDENT> print ( answer ) <NEWLINE>
l = [ list ( map ( int , input ( ) ) ) for i in range ( 3 ) ] <NEWLINE> <NL> sum_l = 0 <NEWLINE> ans = <STRING> <NEWLINE> <NL> for i in l : <NEWLINE> <INDENT> sum_l += sum ( i ) <NEWLINE> <NL> <DEDENT> if sum_l % 3 == 0 : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
<NL>  <NEWLINE> <NL> Copy <NEWLINE> Copy <NEWLINE> y1_list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> y2_list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> y3_list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> a1 = list ( ) <NEWLINE> a2 = list ( ) <NEWLINE> a3 = list ( ) <NEWLINE> for i in range ( 3 ) : <NEWLINE> <INDENT> a1 . append ( y1_list [ i ] - y2_list [ i ] ) <NEWLINE> a2 . append ( y2_list [ i ] - y3_list [ i ] ) <NEWLINE> <NL> <DEDENT> if a1 [ 0 ] == a1 [ 1 ] and a1 [ 2 ] == a1 [ 0 ] : <NEWLINE> <INDENT> if a2 [ 0 ] == a1 [ 1 ] and a2 [ 2 ] == a1 [ 0 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = <STRING> <NEWLINE> if a [ 1 ] - a [ 0 ] == b [ 1 ] - b [ 0 ] == c [ 1 ] - c [ 0 ] and a [ 2 ] - a [ 1 ] == b [ 2 ] - b [ 1 ] == c [ 2 ] - c [ 1 ] : <NEWLINE> <INDENT> b [ 0 ] - a [ 0 ] == b [ 1 ] - a [ 1 ] == b [ 2 ] - b [ 2 ] and c [ 0 ] - b [ 0 ] == c [ 1 ] - b [ 1 ] == c [ 2 ] - b [ 2 ] : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
l = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( 3 ) ] <NEWLINE> x = l [ 0 ] [ 0 ] , y = l [ 0 ] [ 1 ] , z = l [ 0 ] [ 2 ] <NEWLINE> a = 0 , b = l [ 1 ] [ 0 ] - x , c = l [ 2 ] [ 0 ] - x <NEWLINE> if b + y == l [ 1 ] [ 1 ] and b + z == l [ 1 ] [ 2 ] and c + y == l [ 2 ] [ 1 ] and c + z == l [ 2 ] [ 2 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
c1 = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A = np . array ( c1 ) <NEWLINE> c1 = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = np . array ( c1 ) <NEWLINE> c1 = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> C = np . array ( c1 ) <NEWLINE> <NL> D = A - B <NEWLINE> D1 = list ( D ) <NEWLINE> D1 = set ( D1 ) <NEWLINE> if len ( D1 ) == 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> E = B - C <NEWLINE> E1 = list ( E ) <NEWLINE> E1 = set ( E1 ) <NEWLINE> if len ( E1 ) == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
print ( - 1 <NEWLINE>
from collections import deque <NEWLINE> <NL> <NL> def bfs ( ) : <NEWLINE> <INDENT> d = [ [ float ( <STRING> ) ] * w for i in range ( h ) ] <NEWLINE> <NL> dx = [ 1 , 0 , - 1 , 0 ] <NEWLINE> dy = [ 0 , 1 , 0 , - 1 ] <NEWLINE> <NL> que = deque ( [ ] ) <NEWLINE> que . append ( ( sx , sy ) ) <NEWLINE> d [ sx ] [ sy ] = 0 <NEWLINE> <NL> while que : <NEWLINE> <INDENT> p = que . popleft ( ) <NEWLINE> if p [ 0 ] == gx and p [ 1 ] == gy : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for i in range ( 4 ) : <NEWLINE> <INDENT> nx = p [ 0 ] + dx [ i ] <NEWLINE> ny = p [ 1 ] + dy [ i ] <NEWLINE> <NL> if 0 <= nx < h and 0 <= ny < w and maze [ nx ] [ ny ] != <STRING> and d [ nx ] [ ny ] == float ( <STRING> ) : <NEWLINE> <INDENT> que . append ( ( nx , ny ) ) <NEWLINE> d [ nx ] [ ny ] = d [ p [ 0 ] ] [ p [ 1 ] ] + 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> return d [ gx ] [ gy ] <NEWLINE> <NL> <NL> <DEDENT> h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> maze = [ list ( input ( ) ) for i in range ( h ) ] <NEWLINE> sx , sy = 0 , 0 <NEWLINE> gx , gy = h - 1 , w - 1 <NEWLINE> <NL> white = 0 <NEWLINE> for i in range ( h ) : <NEWLINE> <INDENT> for j in range ( w ) : <NEWLINE> <INDENT> if maze [ i ] [ j ] == <STRING> : <NEWLINE> <INDENT> white += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> res = bfs ( ) <NEWLINE> if 0 < res < float ( <STRING> ) : <NEWLINE> <INDENT> print ( white - res - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE>
import sys <NEWLINE> from collections import deque <NEWLINE> <NL> <NL> def LI ( ) : <NEWLINE> <INDENT> return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> <DEDENT> def LSH ( h ) : <NEWLINE> <INDENT> return [ list ( input ( ) ) for _ in range ( h ) ] <NEWLINE> <NL> <NL> <DEDENT> H , W = LI ( ) <NEWLINE> A = LSH ( H ) <NEWLINE> MAP = [ [ 0 for i in range ( W ) ] for j in range ( H ) ] <NEWLINE> white = 0 <NEWLINE> for i in range ( H ) : <NEWLINE> <INDENT> S = A [ i ] <NEWLINE> for j in range ( W ) : <NEWLINE> <INDENT> if S [ j ] == <STRING> : <NEWLINE> <INDENT> MAP [ i ] [ j ] = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> MAP [ i ] [ j ] = <STRING> <NEWLINE> white += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> d = deque ( ) <NEWLINE> d . append ( [ 0 , 0 ] ) <NEWLINE> looked = [ [ 0 for i in range ( W ) ] for j in range ( H ) ] <NEWLINE> looked [ 0 ] [ 0 ] = 1 <NEWLINE> move = [ [ 1 , 0 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ 0 , - 1 ] ] <NEWLINE> count = - 1 <NEWLINE> <NL> while d : <NEWLINE> <INDENT> h , w = d . popleft ( ) <NEWLINE> for i in move : <NEWLINE> <INDENT> a = h + i [ 0 ] <NEWLINE> b = w + i [ 0 ] <NEWLINE> if not ( 0 <= a < H ) or not ( 0 <= b < W ) or looked [ a ] [ b ] == 0 or MAP [ a ] [ b ] == <STRING> : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if a == H - 1 and b == W - 1 : <NEWLINE> <INDENT> count = looked [ h ] [ w ] + 1 <NEWLINE> break <NEWLINE> <DEDENT> d . append ( [ a , b ] ) <NEWLINE> looked [ a ] [ b ] = looked [ h ] [ w ] + 1 <NEWLINE> <DEDENT> if count != - 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> if count == - 1 : <NEWLINE> <INDENT> print ( count ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> print ( white - count ) <NEWLINE>
<NL> <NL> H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> c = [ list ( str ( input ( ) ) ) for i in range ( H ) ] <NEWLINE> <COMMENT> <NL> d = [ [ 0 for j in range ( W ) ] for i in range ( H ) ] <NEWLINE> inf = 10 ** 6 <NEWLINE> ans = 0 <NEWLINE> for i in range ( H ) : <NEWLINE> <INDENT> for j in range ( W ) : <NEWLINE> <INDENT> if c [ i ] [ j ] == <STRING> : <NEWLINE> <INDENT> d [ i ] [ j ] = - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d [ i ] [ j ] = inf <NEWLINE> ans += 1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> d [ 0 ] [ 0 ] = 0 <NEWLINE> queue = collections . deque ( [ [ 0 , 0 ] ] ) <NEWLINE> gy , gx = H - 1 , W - 1 <NEWLINE> <NL> moves = [ [ 1 , 0 ] , [ - 1 , 0 ] , [ 0 , 1 ] , [ 0 , - 1 ] ] <NEWLINE> <NL> flag = False <NEWLINE> while len ( queue ) > 0 : <NEWLINE> <INDENT> now = queue . popleft ( ) <NEWLINE> for i in range ( 4 ) : <NEWLINE> <INDENT> ny = now [ 0 ] + moves [ i ] [ 0 ] <NEWLINE> nx = now [ 1 ] + moves [ i ] [ 1 ] <NEWLINE> <NL> if 0 <= ny and ny < H and 0 <= nx and nx < W and c [ ny ] [ nx ] == <STRING> and d [ ny ] [ nx ] == inf : <NEWLINE> <INDENT> d [ ny ] [ nx ] = d [ now [ 0 ] ] [ now [ 1 ] ] + 1 <NEWLINE> queue . append ( [ ny , nx ] ) <NEWLINE> if ny == gy and nx == gx : <NEWLINE> <INDENT> print ( ans - d [ ny ] [ nx ] - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( - 1 ) <NEWLINE>
from collections import deque <NEWLINE> <NL> <NL> def bfs ( sy , sx , gy , gx ) : <NEWLINE> <COMMENT> <NL> <INDENT> d = [ [ float ( <STRING> ) ] * w for _ in range ( h ) ] <NEWLINE> <NL> dy = [ 0 , 1 , 0 , - 1 ] <NEWLINE> dx = [ 1 , 0 , - 1 , 0 ] <NEWLINE> <NL> que = deque ( [ ] ) <NEWLINE> que . append ( ( sy , sx ) ) <NEWLINE> d [ sy ] [ sx ] = 0 <NEWLINE> <NL> while que : <NEWLINE> <NL> <INDENT> p = que . popleft ( ) <NEWLINE> <NL> if p [ 0 ] == gy and p [ 1 ] == gx : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> for i in range ( 4 ) : <NEWLINE> <INDENT> ny = p [ 0 ] + dy [ i ] <NEWLINE> nx = p [ 1 ] + dx [ i ] <NEWLINE> <NL> if 0 <= ny < h and 0 <= nx < w and maze [ ny ] [ nx ] != <STRING> and d [ ny ] [ nx ] == float ( <STRING> ) : <NEWLINE> <INDENT> que . append ( ( ny , nx ) ) <NEWLINE> d [ ny ] [ nx ] = d [ p [ 0 ] ] [ p [ 1 ] ] + 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if d [ gy ] [ gx ] == float ( <STRING> ) : <NEWLINE> <INDENT> return - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return [ gy ] [ gx ] <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> maze = [ list ( input ( ) ) for _ in range ( h ) ] <NEWLINE> <NL> res = 0 <NEWLINE> for y in range ( h ) : <NEWLINE> <INDENT> for x in range ( w ) : <NEWLINE> <INDENT> if maze [ y ] [ x ] == <STRING> : <NEWLINE> <INDENT> res += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> dis = bfs ( 0 , 0 , h - 1 , w - 1 ) <NEWLINE> <NL> if dis == - 1 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( h * w - res - dis - 1 ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> import sys <NEWLINE> stdin = sys . stdin <NEWLINE> from collections import deque <NEWLINE> <NL> def ns ( ) : return stdin . readline ( ) . rstrip ( ) <NEWLINE> def ni ( ) : return int ( ns ( ) ) <NEWLINE> def na ( ) : return list ( map ( int , stdin . readline ( ) . split ( ) ) ) <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> h , w = na ( ) <NEWLINE> g = [ [ 1 ] * ( w + 2 ) ] <NEWLINE> white = 0 <NEWLINE> for i in range ( h ) : <NEWLINE> <INDENT> r = ns ( ) <NEWLINE> white += r . count ( <STRING> ) <NEWLINE> g . append ( [ 1 ] + [ 1 if s == <STRING> else 0 for s in r ] + [ 1 ] ) <NEWLINE> <DEDENT> g . append ( [ 1 ] * ( w + 2 ) ) <NEWLINE> q = deque ( [ [ 1 , 1 ] ] ) <NEWLINE> move = ( ( 1 , 0 ) , ( - 1 , 0 ) , ( 0 , 1 ) , ( 1 , 0 ) ) <NEWLINE> while q : <NEWLINE> <INDENT> x , y = q . popleft ( ) <NEWLINE> for dx , dy in move : <NEWLINE> <INDENT> nx , ny = x + dx , y + dy <NEWLINE> if g [ nx ] [ ny ] > 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> g [ nx ] [ ny ] = g [ x ] [ y ] + 1 <NEWLINE> q . append ( ( nx , ny ) ) <NEWLINE> <DEDENT> <DEDENT> if g [ h ] [ w ] = 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( white - g [ h ] [ w ] - 1 ) <NEWLINE> <NL> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
from collections import deque <NEWLINE> H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> grid = [ 0 ] * H <NEWLINE> num_black = 0 <NEWLINE> for i in range ( H ) : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> for j in range ( len ( s ) ) : <NEWLINE> <INDENT> if s [ j ] == <STRING> : <NEWLINE> <INDENT> num_black += 1 <NEWLINE> <DEDENT> <DEDENT> grid [ i ] = list ( s ) <NEWLINE> <DEDENT> time_grid = [ [ - 1 ] * W for _ in range ( H ) ] <NEWLINE> time_grid [ 0 ] [ 0 ] = 0 <NEWLINE> queue = deque ( ) <NEWLINE> queue . append ( [ 0 , 0 , 0 ] ) <NEWLINE> while queue : <NEWLINE> <INDENT> y , x , t = queue . popleft ( ) <NEWLINE> for next_y , next_x in [ [ y + 1 , x ] , [ y , x + 1 ] , [ y - 1 , x ] , [ y , x - 1 ] ] : <NEWLINE> <INDENT> if 0 <= next_x < W and 0 <= next_y < H and grid [ next_y ] [ next_x ] == <STRING> : <NEWLINE> <INDENT> queue . append ( [ next_y , next_x , t + 1 ] ) <NEWLINE> time_grid [ next_y ] [ next_x ] = t + 1 <NEWLINE> grid [ next_y ] [ next_x ] = <STRING> <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if time_grid [ H ] [ W ] != - 1 : <NEWLINE> <INDENT> print ( H * W - time_grid [ - 1 ] [ - 1 ] - 1 - num_black ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <NL> <NL> <DEDENT>
from collections import deque <NEWLINE> <NL> def bfs ( ) : <NEWLINE> <COMMENT> <NL> <INDENT> d = [ [ float ( <STRING> ) ] * w for i in range ( h ) ] <NEWLINE> <COMMENT> <NL> dx = [ 1 , 0 , - 1 , 0 ] <NEWLINE> dy = [ 0 , 1 , 0 , - 1 ] <NEWLINE> <COMMENT> <NL> que = deque ( [ ] ) <NEWLINE> <COMMENT> <NL> que . append ( sx , sy ) <NEWLINE> <COMMENT> <NL> d [ sx ] [ sy ] = 0 <NEWLINE> <COMMENT> <NL> while que : <NEWLINE> <INDENT> p = que . popleft ( ) <NEWLINE> <COMMENT> <NL> if p [ 0 ] == gy and p [ 1 ] == gx : <NEWLINE> <INDENT> break <NEWLINE> <COMMENT> <NL> <DEDENT> for i in range ( 4 ) : <NEWLINE> <INDENT> nx = p [ 0 ] + dx [ i ] <NEWLINE> ny = p [ 1 ] + dy [ i ] <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> if 0 <= nx < r and 0 <= ny < c and maze [ nx ] [ ny ] != <STRING> and d [ nx ] [ ny ] == float ( <STRING> ) : <NEWLINE> <COMMENT> <NL> <INDENT> que . append ( ( nx , ny ) ) <NEWLINE> <COMMENT> <NL> d [ nx ] [ ny ] = d [ p [ 0 ] ] [ p [ 1 ] ] + 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return d [ gy ] [ gx ] <NEWLINE> <NL> <DEDENT> h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> maze = [ list ( input ( ) ) for i in range ( h ) ] <NEWLINE> sx , sy = 0 , 0 <NEWLINE> gx , gy = h - 1 , w - 1 <NEWLINE> <NL> white = 0 <NEWLINE> for i in range ( h ) : <NEWLINE> <INDENT> for j in range ( w ) : <NEWLINE> <INDENT> if maze [ i ] [ j ] == <STRING> : <NEWLINE> <INDENT> white += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> res = bfs ( ) <NEWLINE> if 0 < res < float ( <STRING> ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <INDENT> print ( white - res - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT>
import collections <NEWLINE> <NL> H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> s = [ list ( input ( ) ) for i in range ( H ) ] <NEWLINE> <NL> z = [ [ <STRING> ] * W for _ in range ( H ) ] <COMMENT> <NEWLINE> black = 0 <NEWLINE> for i in range ( H ) : <NEWLINE> <INDENT> black += s [ i ] . count ( <STRING> ) <COMMENT> <NEWLINE> <DEDENT> v = [ [ 1 , 0 ] [ 0 , 1 ] [ - 1 , 0 ] [ 0 , - 1 ] ] <COMMENT> <NEWLINE> que = collections . deque ( ) <COMMENT> <NEWLINE> <NL> <COMMENT> <NL> z [ 0 ] [ 0 ] = <STRING> <NEWLINE> s [ 0 ] [ 0 ] = 1 <COMMENT> <NEWLINE> que . append ( [ 0 , 0 ] ) <COMMENT> <NEWLINE> <NL> <COMMENT> <NL> while len ( que ) != 0 : <COMMENT> <NEWLINE> <INDENT> i = que . popleft ( ) <COMMENT> <NEWLINE> for dy , dx in v : <COMMENT> <NEWLINE> <INDENT> y = i [ 0 ] + dy <NEWLINE> x = i [ 1 ] + dx <NEWLINE> if ( 0 <= y < H and 0 <= x < W and s [ y ] [ x ] == <STRING> and z [ y ] [ x ] == <STRING> ) : <NEWLINE> <INDENT> z [ y ] [ x ] == <STRING> <NEWLINE> s [ y ] [ x ] == s [ i [ 0 ] ] [ i [ 1 ] ] + 1 <NEWLINE> que . append ( [ y , x ] ) <COMMENT> <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if s [ - 1 ] [ - 1 ] == <STRING> : <COMMENT> <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <COMMENT> <NEWLINE> <INDENT> print ( H * W - black - s [ - 1 ] [ - 1 ] ) <NEWLINE> <DEDENT>
def MI ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> from collections import deque <NEWLINE> H , W = MI ( ) <NEWLINE> <COMMENT> <NL> Map = [ ] <NEWLINE> white = 0 <NEWLINE> for _ in range ( H ) : <NEWLINE> <INDENT> Map . append ( list ( input ( ) ) ) <NEWLINE> <DEDENT> def bfs ( ) : <NEWLINE> <INDENT> dx = [ - 1 , 0 , 1 , 0 ] <NEWLINE> dy = [ 0 , - 1 , 0 , 1 ] <NEWLINE> INF = float ( <STRING> ) <NEWLINE> dist = [ [ INF ] * W for _ in range ( H ) ] <NEWLINE> dist [ 0 ] [ 0 ] = 0 <NEWLINE> que = deque ( ) <NEWLINE> que . append ( ( 0 , ( 0 , 0 ) ) ) <NEWLINE> <NL> while que : <NEWLINE> <INDENT> d , ( x , y ) = que . popleft ( ) <NEWLINE> for i in range ( 4 ) : <NEWLINE> <INDENT> nx = x + dx [ i ] <NEWLINE> ny = y + dy [ i ] <NEWLINE> if 0 <= nx < H and 0 <= ny < W : <NEWLINE> <INDENT> if Map [ nx ] [ ny ] != <STRING> : <NEWLINE> <INDENT> if dist [ nx ] [ ny ] == INF : <NEWLINE> <INDENT> dist [ nx ] [ ny ] = d + 1 <NEWLINE> que . append ( ( d + 1 , ( nx , ny ) ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> return dist <NEWLINE> <DEDENT> res = bfs ( ) <NEWLINE> for i in range ( H ) : <NEWLINE> <INDENT> for j in range ( W ) : <NEWLINE> <INDENT> if Map [ i ] [ j ] == <STRING> : <NEWLINE> <INDENT> white += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> ans = white - res [ H - 1 ] [ W - 1 ] - 1 <NEWLINE> if 0 < ans < INF : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT>
X , Y = map ( int . input ( ) . split ( ) ) <NEWLINE> if X % Y == 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( X * Y - 1 ) <NEWLINE> <DEDENT>
X , Y = map ( int , input ( ) . split ( ) ) <NEWLINE> num = X <NEWLINE> l = 10 ** 18 <NEWLINE> while num <= l : <NEWLINE> <INDENT> if num % Y != 0 : <NEWLINE> <INDENT> print ( num ) <NEWLINE> <DEDENT> num += X <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT>
x , y = int ( input ( ) ) <NEWLINE> if x == y : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( 1 , 10000 ) : <NEWLINE> <INDENT> a = i * x <NEWLINE> if a % y != 0 : <NEWLINE> <INDENT> print ( a ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def L ( ) : <NEWLINE> <INDENT> return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <DEDENT> [ x , y ] = L ( ) <NEWLINE> <NL> if x % y == 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print x <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input . split ( ) ) ) <NEWLINE> b = list ( map ( int , input . split ( ) ) ) <NEWLINE> <NL> ba = 0 , bb = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if a [ i ] > b [ i ] : <NEWLINE> <INDENT> ba += a [ i ] - b [ i ] <NEWLINE> <DEDENT> if b [ i ] > a [ i ] : <NEWLINE> <INDENT> bb += ( b [ i ] - a [ i ] ) // 2 <NEWLINE> <NL> <DEDENT> <DEDENT> if bb >= ba : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> cou = 0 <NEWLINE> for j , k in zip ( a , b ) : <NEWLINE> <INDENT> if j < k : <NEWLINE> <INDENT> cou += ( k - j ) // 2 <NEWLINE> <DEDENT> elif j > k : <NEWLINE> <INDENT> cou -= ( j - k ) <NEWLINE> <DEDENT> <DEDENT> if cou = > 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> <NL> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> a . sort ( ) <NEWLINE> b . sort ( ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> k = suma - sumb <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> cnt = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if a [ i ] > b [ i ] : <NEWLINE> <INDENT> cnt += b [ i ] - a [ i ] <NEWLINE> <DEDENT> elif a [ i ] < b [ i ] : <NEWLINE> <INDENT> cnt += ( - 1 ) * ( ( a [ i ] - b [ i ] ) // 2 ) <NEWLINE> <NL> <DEDENT> <DEDENT> if cnt >= k : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n , * a = map ( int , open ( 0 ) . read ( ) . split ( ) ) <NEWLINE> u = d = z = r = 0 <NEWLINE> for i , j in zip ( a [ : n ] , a [ n : ] ) : <NEWLINE> <INDENT> if j - i > 0 : u += ( j - i ) // 2 * 2 ; r += ( j - i ) % 2 <NEWLINE> elif j - i == 0 : z += 1 <NEWLINE> else : d += [ j - i ] <NEWLINE> <DEDENT> print ( <STRING> if u + 2 * d >= 0 else <STRING> ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> import sys <NEWLINE> <NL> def input ( ) : return sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> s = 0 <NEWLINE> sm = 0 <NEWLINE> for x , y in zip ( a , b ) : <NEWLINE> <INDENT> tmp = x - y <NEWLINE> sm += tmp <NEWLINE> if tmp == - 1 <NEWLINE> <INDENT> tmp = 0 <NEWLINE> <DEDENT> if tmp > 0 : <NEWLINE> <INDENT> tmp *= 2 <NEWLINE> <DEDENT> s += tmp <NEWLINE> <DEDENT> if s > 0 or sm > 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
from collections import * <NEWLINE> from heapq import * <NEWLINE> ( n , m ) , a , * q = [ [ * map ( int , o . split ( ) ) ] for o in open ( 0 ) ] <NEWLINE> t = [ - 1 ] * n <NEWLINE> def r ( x ) : <NEWLINE> <INDENT> while t [ x ] >= 0 : x = t [ x ] <NEWLINE> return x <NEWLINE> <DEDENT> def u ( x , y ) : <NEWLINE> <INDENT> x , y = r ( x ) , r ( y ) <NEWLINE> if x != y : <NEWLINE> <INDENT> if t [ x ] > t [ y ] : x , y = y , x <NEWLINE> t [ x ] += t [ y ] ; t [ y ] = x <NEWLINE> <DEDENT> <DEDENT> d = defaultdict ( list ) <NEWLINE> for x , y in q : u ( x , y ) <NEWLINE> i = c = 0 ; b = [ ] ; k = ( n + ~ m ) * 2 ; p = print <NEWLINE> for v in a : d [ r ( i ) ] += v , ; i += 1 <NEWLINE> if k < 1 : p ( 0 ) <NEWLINE> elif k > n : p ( <STRING> ) <NEWLINE> else : <NEWLINE> <INDENT> for r , p in d . items ( ) : p . sort ( ) ; c += p . pop ( 0 ) ; b += p ; k -= 1 <NEWLINE> p ( c + sum ( sorted ( b ) [ : k ] ) ) <NEWLINE> <DEDENT>
x , a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( ( x - a ) % b ) <NEWLINE>
x , a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> xa = x - a <NEWLINE> xab = xa // b <NEWLINE> answer = xa - ( b * xab ) <NEWLINE> <NL> print ( answer ) <NEWLINE>
x = int ( input ( ) ) <NEWLINE> a = int ( input ( ) ) <NEWLINE> b = int ( input ( ) ) <NEWLINE> <NL> af = x - a <NEWLINE> <NL> while af > 0 : <NEWLINE> <INDENT> af - b <NEWLINE> <NL> <DEDENT> print ( af ) <NEWLINE>
X , A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( ( X - A ) % B ) <NEWLINE>
<NL> def main ( ) : <NEWLINE> <INDENT> x = int ( input ( ) ) <NEWLINE> a = int ( input ( ) ) <NEWLINE> b = int ( input ( ) ) <NEWLINE> print ( ( x - a ) - ( b * ( ( x - a ) // b ) ) ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT> i <NEWLINE>
X , A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( ( X - A ) % B ) <NEWLINE>
<NL> x , a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> answer = ( x - a ) % b <NEWLINE> <NL> print ( answer ) <NEWLINE>
a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> print ( a - b - ( c * ( ( a - b ) // c ) ) ) <NEWLINE>
import sys <NEWLINE> <NL> input = sys . stdin . buffer . readline <NEWLINE> in_n = lambda : int ( input ( ) ) <NEWLINE> in_nn = lambda : map ( int , input ( ) . split ( ) ) <NEWLINE> in_s = lambda : input ( ) . rstrip ( ) . decode ( <STRING> ) <NEWLINE> in_map = lambda : [ s == ord ( <STRING> ) for s in input ( ) if s != ord ( <STRING> ) ] <NEWLINE> <NL> MOD = 10 ** 9 + 7 <NEWLINE> INF = 8 * 10 ** 18 <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <NL> <INDENT> X , A , B = in_nn ( ) <NEWLINE> print ( ( X - A ) % B ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
s = [ int ( input ( ) ) for i in range ( 3 ) ] <NEWLINE> n = s [ 0 ] <NEWLINE> a = n [ 1 ] <NEWLINE> b = n [ 2 ] <NEWLINE> c = n - a <NEWLINE> d = int ( c / b ) <NEWLINE> print ( c - b * d ) <NEWLINE>
X , A , B = int ( input ( ) ) for i in range ( 3 ) <NEWLINE> print ( ( X - A ) % B ) <NEWLINE>
x , a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( ( x - a ) % b ) <NEWLINE>
a = int ( input ( ) ) <NEWLINE> b = int ( input ( ) ) <NEWLINE> c = int ( input ( ) ) <NEWLINE> print ( x = a - b // c ) <NEWLINE>
<NL> X = input ( ) <NEWLINE> A = input ( ) <NEWLINE> B = input ( ) <NEWLINE> X -= A <NEWLINE> Y = X % B <NEWLINE> print ( Y ) <NEWLINE>
x , a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( ( x - a ) % b ) <NEWLINE>
import math <NEWLINE> x , a , b = [ int ( input ( ) ) for i int range ( 3 ) ] <NEWLINE> print ( ( x - a ) % b ) <NEWLINE>
A = int ( input ( ) ) <NEWLINE> B = int ( input ( ) ) <NEWLINE> C = int ( input ( ) ) <NEWLINE> X = int ( input ( ) ) <NEWLINE> res = 0 <NEWLINE> for a500 in range ( A + 1 ) : <NEWLINE> <INDENT> for b100 in range ( B + 1 ) : <NEWLINE> <INDENT> for c50 in range ( C + 1 ) : <NEWLINE> <INDENT> if a500 * 500 + b100 * 100 + c50 * 50 = X : <NEWLINE> <INDENT> res += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( res ) <NEWLINE>
abc = [ int ( input ( ) ) for i in range ( 3 ) ] <NEWLINE> x = int ( input ( ) ) <NEWLINE> <NL> count = 0 <NEWLINE> <NL> for i in range ( a + 1 ) : <NEWLINE> <INDENT> for j in range ( b + 1 ) : <NEWLINE> <INDENT> for k in range ( c + 1 ) : <NEWLINE> <INDENT> if 500 * i + 100 * j + 50 * k == x : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
a , b , c , d = map ( int , input ( ) . open ( 0 ) . split ( ) ) <NEWLINE> print ( sum ( 500 * x + 100 * y + 50 * z == d for x in range ( a + 1 ) for y in range ( b + 1 ) for z in range ( c + 1 ) ) ) <NEWLINE>
A = int ( input ( ) ) <NEWLINE> B = int ( input ( ) ) <NEWLINE> C = int ( input ( ) ) <NEWLINE> X = int ( input ( ) ) <NEWLINE> count = 0 <NEWLINE> for a in range ( A + 1 ) : <NEWLINE> <INDENT> for b in range ( B + 1 ) : <NEWLINE> <INDENT> for c in range ( C + 1 ) : <NEWLINE> if X == 500 * a + 100 * b + 50 * c : <NEWLINE> <INDENT> count = count + 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> <NL> <COMMENT> <NL> ctypedef long long LL <NEWLINE> <NL> <COMMENT> <NL> import sys <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> read = sys . stdin . readline <COMMENT> <NEWLINE> <NL> cdef LL a_int ( ) : return int ( readline ( ) ) <NEWLINE> <NL> cdef LL i , j , k , _ <NEWLINE> <NL> <NL> cdef LL A = a_int ( ) <NEWLINE> cdef LL B = a_int ( ) <NEWLINE> cdef LL C = a_int ( ) <NEWLINE> cdef LL X = a_int ( ) <NEWLINE> <NL> <COMMENT> <NL> cdef LL a , b , c , ans <NEWLINE> for a in range ( A + 1 ) : <NEWLINE> <INDENT> for b in range ( B + 1 ) : <NEWLINE> <INDENT> for c in range ( C + 1 ) : <NEWLINE> <INDENT> ans += ( 500 * a + 100 * b + 50 * c == X ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
A , B , C , D = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( sum ( 500 * i + 100 * j + 50 * k == D for i in range ( A + 1 ) for j in range ( B + 1 ) for k in range ( C + 1 ) ) ) <NEWLINE>
A = int ( input ( ) ) <NEWLINE> B = int ( input ( ) ) <NEWLINE> C = int ( input ( ) ) <NEWLINE> N = int ( input ( ) ) <NEWLINE> <NL> for a in range ( A + 1 ) : <NEWLINE> <INDENT> for b in range ( B + 1 ) : <NEWLINE> <INDENT> for c in range ( C + 1 ) : <NEWLINE> <INDENT> if a * 500 + b * 100 + c * 50 == N : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
a = input ( ) <COMMENT> <NEWLINE> b = input ( ) <COMMENT> <NEWLINE> c = input ( ) <COMMENT> <NEWLINE> x = input ( ) <COMMENT> <NEWLINE> <NL> counter = 0 <NEWLINE> for use_a in range ( a + 1 ) : <NEWLINE> <INDENT> if 500 * use_a > x : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> rest = x - 500 * use_a <NEWLINE> for use_b in range ( b + 1 ) : <NEWLINE> <INDENT> if 100 * use_b > rest : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> rest = rest - 100 * use_b <NEWLINE> for use_c in range ( c + 1 ) : <NEWLINE> <INDENT> if 50 * use_c != rest : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> counter += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( counter ) <NEWLINE>
a = [ int ( input ( ) ) for i in range ( 4 ) ] <NEWLINE> count = 0 <NEWLINE> <NL> for ( i = 0 ; i <= a [ 0 ] ; i + + ) : <NEWLINE> <INDENT> for ( j = 0 ; j <= a [ 1 ] ; j + + ) : <NEWLINE> <INDENT> for ( k = 0 ; k <= a [ 2 ] ; k + + ) : <NEWLINE> <INDENT> sum = 500 * i + 100 * j + 50 * k <NEWLINE> if sum == a [ 3 ] : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
a = int ( input ( ) ) <NEWLINE> b = int ( input ( ) ) <NEWLINE> c = int ( input ( ) ) <NEWLINE> s = int ( input ( ) ) <NEWLINE> n = 0 <NEWLINE> for x in range ( a ) : <NEWLINE> <INDENT> for y in range ( b ) : <NEWLINE> <INDENT> for z in range ( c ) : <NEWLINE> <INDENT> if 500 x + 100 y + 50 z == s : <NEWLINE> <INDENT> n = n + 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( n ) <NEWLINE>
a , b , c , x = map ( int , open ( 0 ) . read ( ) . split ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> counta = 0 <NEWLINE> <NL> for i in range ( a + 1 ) : <NEWLINE> <INDENT> for j in range ( b + 1 ) : <NEWLINE> <INDENT> for k in range ( c + 1 ) : <NEWLINE> <INDENT> ans = ( ( i * 500 + ( j * 100 + ( k * 50 ) <NEWLINE> if ans == x : <NEWLINE> <INDENT> counta += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> pass <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( counta ) <NEWLINE>
a = int ( input ( ) ) <NEWLINE> b = int ( input ( ) ) <NEWLINE> c = int ( input ( ) ) <NEWLINE> x = int ( input ( ) ) <NEWLINE> s = 50 * c <NEWLINE> print ( len [ 1 for i in range ( a + 1 ) for m in range ( b + 1 ) if 0 <= x - 500 * i + 100 * m <= s ] ) <NEWLINE>
a , b , c , x = map ( int , [ input ( ) fot z in range ( 4 ) ] ) <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> for i in range ( a + 1 ) : <NEWLINE> <INDENT> for j in range ( b + 1 ) : <NEWLINE> <INDENT> for k in range ( c + 1 ) : <NEWLINE> <INDENT> if i * 500 + j * 100 + k * 50 == x : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
A = int ( input ( ) ) <NEWLINE> B = int ( input ( ) ) <NEWLINE> C = int ( input ( ) ) <NEWLINE> X = int ( input ( ) ) <NEWLINE> <NL> pat = 0 <NEWLINE> for a in range ( A ) : <NEWLINE> <INDENT> for b in range ( B ) : <NEWLINE> <INDENT> for c in range ( C ) : <NEWLINE> <INDENT> if a * 500 + B * 100 + c * 50 == X : <NEWLINE> <INDENT> pat += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( pat ) <NEWLINE>
a , b , c , x = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( a + 1 ) : <NEWLINE> <INDENT> for j in range ( b + 1 ) : <NEWLINE> <INDENT> for k in range ( c + 1 ) : <NEWLINE> <INDENT> if 500 * i + 100 * j + 50 * k == x : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
A = int ( input ( ) ) <NEWLINE> B = int ( input ( ) ) <NEWLINE> C = int ( input ( ) ) <NEWLINE> X = int ( input ( ) ) <NEWLINE> <NL> for a in range ( 0 , A + 1 ) : <NEWLINE> <INDENT> y = X - 500 * a <NEWLINE> if y < 500 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> for b in range ( 0 , B + 1 ) : <NEWLINE> <INDENT> z = y - 100 * b <NEWLINE> if z < 100 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> for c in range ( 0 , C + 1 ) : <NEWLINE> <INDENT> w = z - 50 * a <NEWLINE> if w < 50 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> if w != 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d = ( X - y ) / 500 <NEWLINE> e = ( y - z ) / 100 <NEWLINE> f = ( z - w ) / 50 <NEWLINE> i = - 1 <NEWLINE> for n in range ( 0 , d + 1 ) : <NEWLINE> <INDENT> if B - e - 5 * n >= 0 : <NEWLINE> <INDENT> i = i + 1 <NEWLINE> <DEDENT> <DEDENT> for m in range ( 0 , e + 5 * i ) : <NEWLINE> <INDENT> if C - f - 2 * m >= 0 : <NEWLINE> <INDENT> i = i + 1 <NEWLINE> <DEDENT> <DEDENT> print ( i ) <NEWLINE> <NL> <NL> <NL> <NL> <NL> <NL> <DEDENT>
c500 = int ( input ) <NEWLINE> c100 = int ( input ) <NEWLINE> c50 = int ( input ) <NEWLINE> x = int ( input ) <NEWLINE> count = 0 <NEWLINE> <NL> for c500_n in range ( 1 , c500 ) : <NEWLINE> <INDENT> for c100_n in range ( 1 , c100 ) : <NEWLINE> <INDENT> for c50_n in range ( 1 , c50 ) : <NEWLINE> <INDENT> if c500_n * 500 + c100_n * 100 + c50_n * 50 == x : <NEWLINE> <INDENT> count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
a = int ( input ( ) ) <NEWLINE> b = int ( input ( ) ) <NEWLINE> c = int ( input ( ) ) <NEWLINE> x = int ( input ( ) ) <NEWLINE> counts = 0 <NEWLINE> for A in range ( a + 1 ) : <NEWLINE> <INDENT> for B in range ( b + 1 ) : <NEWLINE> <INDENT> for C in range ( c + 1 ) : <NEWLINE> <INDENT> if ( 500 * a + 100 * b + 50 * c ) == X : <NEWLINE> <INDENT> counts += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( counts ) <NEWLINE>
a = int ( input ( <STRING> ) ) <NEWLINE> b = int ( input ( <STRING> ) ) <NEWLINE> c = int ( input ( <STRING> ) ) <NEWLINE> x = int ( input ( <STRING> ) ) <NEWLINE> def countcourse ( r , t , y , u ) : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> for h in range ( r ) : <NEWLINE> <INDENT> for l in range ( t ) : <NEWLINE> <INDENT> for o range ( y ) : <NEWLINE> <INDENT> if 500 * h + 100 * l + 50 * o == u : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> return cnt <NEWLINE> <DEDENT> print ( countcourse ( a , b , c , x ) ) <NEWLINE>
a = int ( input ( ) ) <NEWLINE> b = int ( input ( ) ) <NEWLINE> c = int ( input ( ) ) <NEWLINE> x = int ( input ( ) ) <NEWLINE> <NL> for i in range ( a + 1 ) : <NEWLINE> <INDENT> for j in range ( b + 1 ) : <NEWLINE> <INDENT> for k in range ( c + 1 ) : <NEWLINE> <INDENT> num_500 = 500 * i <NEWLINE> num_100 = 100 * j <NEWLINE> num_50 = 50 * k <NEWLINE> if num_500 + num_100 + num_50 == x : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
cnt = 0 <NEWLINE> for a in range ( A + 1 ) : <NEWLINE> <COMMENT> <NL> <INDENT> for b in range ( B + 1 ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <INDENT> for c in range ( C + 1 ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <INDENT> if ( a * 500 + b * 100 + c * 50 ) == X : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
a , b , c , x = map ( int , input ( ) . split ( ) ) <NEWLINE> count = 0 <NEWLINE> <NL> for i in range ( a + 1 ) : <NEWLINE> <INDENT> for j in range ( b + 1 ) : <NEWLINE> <INDENT> for k in range ( c + 1 ) : <NEWLINE> <INDENT> if i * 500 + j * 100 + k * 50 == x : <NEWLINE> <INDENT> count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
a = int ( input ( ) ) <NEWLINE> b = int ( input ( ) ) <NEWLINE> c = int ( input ( ) ) <NEWLINE> x = int ( input ( ) ) / 50 <NEWLINE> ans = 0 <NEWLINE> for i in range ( a + 1 ) : <NEWLINE> <INDENT> for j in range ( b + 1 ) : <NEWLINE> <INDENT> for k in range ( c + 1 ) : <NEWLINE> <INDENT> if i * 10 + j * 2 + k = x : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
a , b , c , x = int ( input ( ) ) for _ in range ( 4 ) <NEWLINE> <NL> ans = [ ( i , j , k ) for i in range ( a + 1 ) for j in range ( b + 1 ) for k in range ( c + 1 ) if 500 * i + 100 * j + 50 * k == x ] <NEWLINE> print ( len ( ans ) ) <NEWLINE>
a = int ( input ( ) ) <NEWLINE> b = int ( input ( ) ) <NEWLINE> c = int ( input ( ) ) <NEWLINE> x = int ( input ( ) ) <NEWLINE> <NL> count = 0 <NEWLINE> <NL> for i in range ( a + 1 ) : <NEWLINE> <INDENT> for j in range ( b + 1 ) : <NEWLINE> <INDENT> for k in range ( c + 1 ) : <NEWLINE> <INDENT> if 500 * a + 100 * b + 50 * c = x : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
[ a , b , c , d ] = [ int ( input ( ) ) for i in range ( 1 , 4 + 1 ) ] <NEWLINE> a1 = d // 500 <NEWLINE> b1 = d // 100 <NEWLINE> c1 = d // 50 <NEWLINE> coun = 0 <NEWLINE> for i in range ( 0 , min ( [ a + 1 , a1 + 1 ] ) ) : <NEWLINE> <INDENT> a = 500 * i <NEWLINE> if a == d : <NEWLINE> <INDENT> coun = coun + 1 <NEWLINE> break <NEWLINE> <DEDENT> for j in range ( 0 , min ( [ b + 1 , b1 + 1 - 5 * i ] ) ) : <NEWLINE> <INDENT> s = a + 100 * j <NEWLINE> if s == d : <NEWLINE> <INDENT> coun = coun + 1 <NEWLINE> break <NEWLINE> <DEDENT> for k in range ( 0 , min ( [ c + 1 , c1 + 1 - 10 * i - 2 * j ] ) : <NEWLINE> <INDENT> v = s + 50 * k <NEWLINE> if v == d : <NEWLINE> <INDENT> coun = coun + 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( coun ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> maxn = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> maxn = max ( maxn , sum ( a [ : i + 1 ] , b [ i : ] ) ) <NEWLINE> <DEDENT> print ( maxn ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> <INDENT> for i in range ( n ) : <NEWLINE> <INDENT> ans = max ( ans , sum ( a [ : i + 1 ] ) + sum ( b [ i : n ] ) ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> l = [ ] <NEWLINE> for _ in range ( 3 ) : <NEWLINE> <INDENT> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> l . append ( a ) <NEWLINE> <NL> <DEDENT> if n == 1 : <NEWLINE> <INDENT> print ( l [ 0 ] [ 0 ] + l [ 1 ] [ 0 ] ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> m1 = [ ] <NEWLINE> m2 = [ ] <NEWLINE> m1 . append ( l [ 0 ] [ 0 ] ) <NEWLINE> m2 . append ( l [ 1 ] [ 0 ] ) <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> m1 . append ( m1 [ i - 1 ] + l [ 0 ] [ i ] ) <NEWLINE> m2 . append ( m2 [ i - 1 ] + l [ 1 ] [ i ] ) <NEWLINE> <NL> <DEDENT> ans = [ 0 ] * n <NEWLINE> for j in range ( n ) : <NEWLINE> <INDENT> ans [ j ] = m1 [ j ] + ( m2 [ n - 1 ] - m2 [ j - 1 ] ) <NEWLINE> <NL> <DEDENT> print ( max ( ans ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ans . append ( sum ( a [ 0 : i + 1 ] + sum ( b [ i : n ] ) ) <NEWLINE> <NL> <DEDENT> print ( max ( ans ) ) <NEWLINE>
import sys <NEWLINE> read = sys . stdin . read <NEWLINE> readlines = sys . stdin . readlines <NEWLINE> from itertools import accumulate <NEWLINE> from itertools import chain <NEWLINE> from collections import deque <NEWLINE> def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> a1 = chain ( tuple ( [ 0 ] ) , tuple ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> a2 = chain ( tuple ( [ 0 ] ) , tuple ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> a1a = tuple ( accumulate ( a1 ) ) <NEWLINE> a2a = tuple ( accumulate ( a2 ) ) <NEWLINE> scores = deque ( ) <NEWLINE> for i1 in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> scores . append ( [ i1 ] + a2a [ n ] - a2a [ i1 - 1 ] ) <NEWLINE> <DEDENT> r = max ( scores ) <NEWLINE> print ( r ) <NEWLINE> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> candies_i = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> candies_j = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> l = [ ] <NEWLINE> count = 0 <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> count += 1 <NEWLINE> total_li = sum ( candies_i [ : count ] ) <NEWLINE> total_lj = sum ( candies_j [ += 1 : ] ) <NEWLINE> total = total_li + total_lj <NEWLINE> l . append ( total ) <NEWLINE> <NL> <DEDENT> print ( max ( l ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> a = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( 2 ) ] <NEWLINE> s = 0 ; t = 0 ; u = 0 ; v = 0 <NEWLINE> for i in range ( 0 , N ) : <NEWLINE> <INDENT> for j in range ( 0 , i + 1 ) : <NEWLINE> <INDENT> s += a [ 0 ] [ j ] <NEWLINE> t += a [ 1 ] [ j ] <NEWLINE> u += a [ 0 ] [ N - j - 1 ] <NEWLINE> v += a [ 1 ] [ N - j - 1 ] <NEWLINE> if s >= t and v >= u : <NEWLINE> print ( s + v ) <NEWLINE> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> list1 = [ ] <NEWLINE> ame = A [ 0 ] <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> list1 . append ( sum ( A [ : i + 1 ] ) + sum ( B [ i : ] ) ) <NEWLINE> <NL> <DEDENT> if list1 = [ ] : <NEWLINE> <INDENT> print ( A [ 0 ] + b [ 0 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( max ( list1 ) ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A1 = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A2 = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = [ ] <NEWLINE> <NL> if N == 1 : <NEWLINE> <INDENT> print ( A1 [ 0 ] + A2 [ 0 ] ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( N ) : <NEWLINE> <INDENT> ansA1 = 0 <NEWLINE> ansA2 = 0 <NEWLINE> for j in range ( i ) : <NEWLINE> <INDENT> ansA1 += A1 [ j ] <NEWLINE> <DEDENT> for k in range ( j , N ) : <NEWLINE> <INDENT> ansA2 += A2 [ k ] <NEWLINE> <DEDENT> ans1 = ansA1 + ansA2 <NEWLINE> ans . append ( ans1 ) <NEWLINE> <DEDENT> print ( max ( ans ) ) <NEWLINE> <DEDENT>
class WeightedUnionFind ( ) : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . n = n <NEWLINE> self . parents = [ - 1 ] * n <NEWLINE> self . weight = [ 0 ] * n <NEWLINE> <NL> <DEDENT> def find ( self , x ) : <NEWLINE> <INDENT> if self . parents [ x ] < 0 : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> px = self . find ( self . parents [ x ] ) <NEWLINE> self . weight [ x ] += self . weight [ self . parents [ x ] ] <NEWLINE> self . parents [ x ] = px <NEWLINE> return px <NEWLINE> <NL> <DEDENT> <DEDENT> def union ( self , x , y , w ) : <NEWLINE> <INDENT> w += self . weight [ x ] - self . weight [ y ] <NEWLINE> x = self . find ( x ) <NEWLINE> y = self . find ( y ) <NEWLINE> if x == y : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> if self . parents [ x ] > self . parents [ y ] : <NEWLINE> <INDENT> x , y , w = y , x , - w <NEWLINE> <DEDENT> self . parents [ x ] += self . parents [ y ] <NEWLINE> self . parents [ y ] = x <NEWLINE> self . weight [ y ] = w <NEWLINE> return <NEWLINE> <NL> <DEDENT> def weig ( self , x ) : <NEWLINE> <INDENT> self . find ( x ) <NEWLINE> return self . weight [ x ] <NEWLINE> <NL> <DEDENT> def diff ( self , x , y ) : <NEWLINE> <INDENT> return self . weigh ( y ) - self . weigh ( x ) <NEWLINE> <NL> <DEDENT> <DEDENT> ( n , m ) , * q = [ [ * map ( int , o . split ( ) ) ] for o in open ( 0 ) ] <NEWLINE> UF = WeightedUnionFind ( n + 1 ) <NEWLINE> for l , r , d in q : <NEWLINE> <INDENT> if UF . same ( l , r ) : <NEWLINE> <INDENT> if d != abs ( UF . diff ( l , r ) ) : <NEWLINE> <INDENT> print ( <STRING> ) ; exit ( ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> UF . union ( l , r , d ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> root = [ - 10 ** 10 ] * N <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> l , r , d = map ( int , input ( ) . split ( ) ) <NEWLINE> if ( root [ l ] < - 10 ** 9 - 1 ) and ( root [ r ] < - 10 ** 9 - 1 ) : <NEWLINE> <INDENT> root [ l ] = 0 <NEWLINE> root [ r ] = d <NEWLINE> <DEDENT> elif ( root [ l ] < - 10 ** 9 - 1 ) : <NEWLINE> <INDENT> root [ l ] = root [ r ] - d <NEWLINE> <DEDENT> elif ( root [ r ] < - 10 ** 9 - 1 ) : <NEWLINE> <INDENT> root [ r ] = root [ l ] + d <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if root [ l ] + d != root [ r ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> quit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> if root [ i ] < - 10 ** 9 - 1 : <NEWLINE> <INDENT> root [ i ] = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> x = min ( root ) <NEWLINE> y = max ( root ) <NEWLINE> if y - x > 10 ** 9 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> quit ( ) <NEWLINE> <NL> <DEDENT> print ( <STRING> ) <NEWLINE> <NL>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> par = [ i for i in range ( n ) ] <NEWLINE> diff = [ 0 ] * n <NEWLINE> <NL> def find ( x ) : <NEWLINE> <INDENT> if par [ x ] == x : <NEWLINE> <INDENT> return x , 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a , b = find ( par [ x ] ) <NEWLINE> par [ x ] = a <NEWLINE> diff [ x ] += b <NEWLINE> return a , diff [ x ] <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def unite ( x , y , z ) : <NEWLINE> <INDENT> s , ws = find ( x ) <NEWLINE> t , wt = find ( y ) <NEWLINE> <COMMENT> <NL> if s == t : <NEWLINE> <INDENT> if ws - wt == z : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( 0 ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> par [ s ] = t <NEWLINE> diff [ s ] = z <NEWLINE> <NL> <DEDENT> <DEDENT> unites = [ ] <NEWLINE> for _ in range ( m ) : <NEWLINE> <INDENT> l , r , d = map ( int , input ( ) . split ( ) ) <NEWLINE> unites . append ( ( l , r , d ) ) <NEWLINE> unite ( l - 1 , r - 1 , d ) <NEWLINE> <DEDENT> for x , y , z in unites : <NEWLINE> <INDENT> unites ( x - 1 , y - 1 , d ) <NEWLINE> <NL> <DEDENT> print ( <STRING> ) <NEWLINE>
<COMMENT> <NL> <NL> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if a * b % 2 = 0 : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT>
input_list = input ( ) . split ( <STRING> ) <NEWLINE> a = int ( input_list [ 0 ] ) <NEWLINE> b = int ( input_list [ 0 ] ) <NEWLINE> <NL> N = a * b <NEWLINE> <NL> if N % 2 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> return 0 <NEWLINE>
a , b = input ( ) . split ( ) <NEWLINE> <NL> if ( a * b % 2 == 0 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a = int ( input ( ) ) <NEWLINE> <NL> b = int ( input ( ) ) <NEWLINE> <NL> seki = a * b <NEWLINE> <NL> if seki % 2 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
print ( <STRING> if eval ( input ( ) . replace ( <STRING> , <STRING> ) % 2 ) else <STRING> ) <NEWLINE>
a , b = map ( int , input ( ) , split ( ) ) <NEWLINE> if a * b % 2 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if a * b // 2 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
a , b = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> <NL> if ( a * b ) % 2 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if a [ 0 ] % 2 == 0 | | a [ 1 ] % 2 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b = map ( int , input ( ) , split ( ) ) <NEWLINE> <NL> if ( a * b ) % 2 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a = int ( input ( ) ) <NEWLINE> b = int ( input ( ) ) <NEWLINE> c = a * b <NEWLINE> if ( c % 2 == 0 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif ( c % 2 == 1 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> return <STRING> if a * b % 2 == 0 else <STRING> <NEWLINE>
a , b = int ( input ( ) ) , int ( input ( ) ) <NEWLINE> <NL> ans = a * b <NEWLINE> <NL> if ans % 2 == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b = int ( input ( ) . split ( ) ) <NEWLINE> if a % b == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> <COMMENT> <NL> a = int ( input ( ) ) <NEWLINE> b = int ( input ( ) ) <NEWLINE> <NL> <COMMENT> <NL> if int ( a * b / 2 ) == int ( a * b / 2 + 0.5 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n , m = ( int ( x ) for x in input ( ) . split ( ) ) <NEWLINE> if int ( ( n + m ) / 2 ) == n + m : <NEWLINE> <INDENT> print ( Even ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( Odd ) <NEWLINE> <DEDENT>
a = int ( input ( ) ) <NEWLINE> b = int ( input ( ) ) <NEWLINE> x = a * b <NEWLINE> if x % 2 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT>
<COMMENT> <NL> b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if B * C % 2 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a = int ( input ( ) ) <NEWLINE> b = int ( input ( ) ) <NEWLINE> <NL> if ( a * b ) % 2 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b = map ( int , input ( ) ) <NEWLINE> <NL> c = a * b <NEWLINE> <NL> if c % 2 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b = map ( int . input ( ) . split ( ) ) <NEWLINE> <NL> answer = a * b <NEWLINE> <NL> if answer % == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b = map ( int , input ( ) . replace ( <STRING> ) ) <NEWLINE> print ( [ <STRING> , <STRING> ] [ ( a * b ) % 2 ] ) <NEWLINE>
a = int ( input ( ) ) <NEWLINE> b = int ( input ( ) ) <NEWLINE> if a * b % 2 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b = map ( int , input ( ) . spilit ( ) ) <NEWLINE> <NL> x = a * b <NEWLINE> <NL> if x % 2 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT>
N = int ( input ( ) ) <NEWLINE> tm_pos = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( N ) ] <NEWLINE> for i in tm_pos : <NEWLINE> <INDENT> if i [ 0 ] < i [ 1 ] + i [ 2 ] or i [ 0 ] % 2 != ( i [ 1 ] + i [ 2 ] ) % 2 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
x , y = map ( int ( input ( ) . split ( ) ) ) <NEWLINE> <NL> if ( x * y ) % 2 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a = int ( input ( ) ) <NEWLINE> b = int ( input ( ) ) <NEWLINE> <NL> X = a * b <NEWLINE> if X % 2 == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
<COMMENT> <NL> rab = input ( <STRING> ) <NEWLINE> ab = rab . split ( <STRING> ) <NEWLINE> a = int ( rab [ 0 ] ) <NEWLINE> b = int ( rab [ 1 ] ) <NEWLINE> if ( a * b ) % 2 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
if ( a * b & 1 == 1 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a = int ( input ( ) ) <NEWLINE> b = int ( input ( ) ) <NEWLINE> print ( <STRING> if a % 2 != 0 and b % 2 != 0 else <STRING> ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> c = a * b <NEWLINE> if c / 2 = 0 <NEWLINE> print ( <STRING> ) <NEWLINE> elif c / 2 = 1 <NEWLINE> print ( <STRING> ) <NEWLINE>
import sys <NEWLINE> <NL> args = sys . argv <NEWLINE> <NL> <COMMENT> <NL> <NL> x1 = int ( args [ 1 ] ) <NEWLINE> x2 = int ( args [ 2 ] ) <NEWLINE> <NL> if ( x1 * x2 ) % 2 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> c = <NEWLINE> <NL> if ( a * b ) % 2 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b = amp ( int , input ( ) . split ( ) ) <NEWLINE> c = a * b <NEWLINE> if ( c % 2 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b = map ( int , input ( ) ) <NEWLINE> if a * b % 2 == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a * b % 2 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
result = a * b <NEWLINE> if result % 2 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
<COMMENT> <NL> a = int ( input ( ) ) <NEWLINE> b = int ( input ( ) ) <NEWLINE> <NL> <COMMENT> <NL> if a * b % 2 == 0 : <NEWLINE> <INDENT> answer = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> answer = <STRING> <NEWLINE> <NL> <DEDENT> print ( answer ) <NEWLINE>
a = int ( input ( ) ) <NEWLINE> b = int ( input ( ) ) <NEWLINE> <NL> if a * b % 2 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a = int ( input ( ) ) <NEWLINE> b = int ( input ( ) ) <NEWLINE> if a & 2 == 0 or b % 2 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
mycode = <STRING> <NEWLINE> <NL> import sys <NEWLINE> if sys . argv [ - 1 ] == <STRING> : <COMMENT> <NEWLINE> <INDENT> import os <NEWLINE> with open ( <STRING> , <STRING> ) as f : <NEWLINE> <INDENT> f . write ( mycode ) <NEWLINE> <DEDENT> os . system ( <STRING> ) <NEWLINE> <NL> <DEDENT> import mycode <NEWLINE>
x = split ( ) . input ( ) <NEWLINE> y = int ( x [ 0 ] ) * int ( x [ 1 ] ) <NEWLINE> if y % 2 = 0 : <NEWLINE> <INDENT> print ( Even ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( Odd ) <NEWLINE> <DEDENT>
num = input ( ) . split ( <STRING> ) <NEWLINE> a = num [ 0 ] <NEWLINE> b = num [ 1 ] <NEWLINE> if ( a * b ) % 2 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> m = a * b <NEWLINE> if m % 2 == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a . b = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( <STRING> if ( a * b ) % 2 != 0 else <STRING> ) <NEWLINE>
a , b = input ( int ( ) ) <NEWLINE> if ( a * b ) % 2 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if a * b % 2 = 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b = input ( ) . split ( ) <NEWLINE> a = int ( a ) <NEWLINE> b = int ( b ) <NEWLINE> print ( <STRING> if a * b % == 0 else <STRING> ) <NEWLINE>
x = imput ( ) . split ( ) <NEWLINE> y = int ( x [ 0 ] ) * int ( x [ 1 ] ) <NEWLINE> if y % 2 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a = input ( ) <NEWLINE> b = input ( ) <NEWLINE> <NL> multi = int ( a ) * int ( b ) <NEWLINE> <NL> if multi % 2 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b = [ int ( e ) for e in raw_input ( ) . split ( ) ] <NEWLINE> if a * b % 2 == 0 : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT>
n = ( a * b ) % 2 <NEWLINE> if n == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if a * b / 2 == 0 : <NEWLINE> <INDENT> print ( Even ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( Odd ) <NEWLINE> <DEDENT>
int main ( ) { <NEWLINE> int a , b ; <NEWLINE> cin >> a > > b ; <NEWLINE> int c = a * b ; <NEWLINE> if ( c % 2 == 0 ) puts ( <STRING> ) ; <NEWLINE> else puts ( <STRING> ) ; <NEWLINE> return 0 ; <NEWLINE>
a = 20 <NEWLINE> b = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( <STRING> if a % b == 0 ) <NEWLINE>
a , b = map ( int , input ( ) ) <NEWLINE> if a * b % 2 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a = int ( input ( ) ) <NEWLINE> b = int ( input ( ) ) <NEWLINE> print ( a ) <NEWLINE> print ( b ) <NEWLINE> if a * b % 2 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b = map ( imt , input ( ) . split ( ) ) <NEWLINE> if a * b % 2 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b = input ( ) . split ( <STRING> ) <NEWLINE> if int ( a ) * int ( b ) % 2 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> continue <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE>
a = int ( input ( <STRING> ) ) <NEWLINE> b = int ( input ( <STRING> ) ) <NEWLINE> c = a * b <NEWLINE> if c % 2 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if a * b % 2 = 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a = int ( input ( ) ) <NEWLINE> b = int ( input ( ) ) <NEWLINE> if ( a * b ) % 2 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( <STRING> if a * b % 2 == else <STRING> ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> a = int ( input ( ) ) <NEWLINE> b = int ( input ( ) ) <NEWLINE> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> if ( a * b ) % 2 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b = map ( int . input ( ) . split ( ) ) <NEWLINE> if ( a * b ) % 2 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if ( a * b % 2 ) : <NEWLINE> <INDENT> printf ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> printf ( <STRING> ) <NEWLINE> <DEDENT>
<COMMENT> <NL> a , b = input ( ) , input ( ) <NEWLINE> <COMMENT> <NL> c = ( a * b ) % 2 <NEWLINE> if c != 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a = int ( input ( ) ) <NEWLINE> b = int ( input ( ) ) <NEWLINE> if a * b % 2 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a = int ( input ( ) ) <NEWLINE> b = int ( input ( ) ) <NEWLINE> if a * b % 2 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
input_line = int ( input ( ) . split ( ) ) <NEWLINE> <NL> result = input_line [ 0 ] * input_line [ 1 ] <NEWLINE> <NL> if result % 2 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a = input ( ) <NEWLINE>  = input ( ) <NEWLINE> c = int ( a ) * int ( b ) <NEWLINE> <NL> if c % 2 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a = int ( input ( ) ) <NEWLINE> b = int ( input ( ) ) <NEWLINE> <NL> if a * b % 2 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a = int ( input ( ) ) <NEWLINE> b = int ( input ( ) ) <NEWLINE> <NL> print ( <STRING> if a * b % 2 == 0 else <STRING> ) <NEWLINE>
x = input ( ) . split ( ) <NEWLINE> y = int ( x [ 0 ] ) * int ( x [ 1 ] ) <NEWLINE> if y % 2 = 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b = map ( int , input ( ) . strip ( ) ) <NEWLINE> if a * b % 2 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if num ( a * b ) % 2 == 0 : <NEWLINE> <INDENT> print ( Even ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> print ( Odd ) <NEWLINE> <DEDENT>
a , b = map ( int ( input ( ) ) . split ( ) ) <NEWLINE> if ( a * b ) % 2 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if a * b % 2 == 0 : <NEWLINE> <INDENT> print ( Even ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( Odd ) <NEWLINE> <DEDENT>
if ( a * b ) % 2 == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a = int ( input ( ) ) <NEWLINE> b = int ( input ( ) ) <NEWLINE> <NL> if ( a * b ) % 2 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a = int ( input ( ) ) * int ( input ( ) ) <NEWLINE> print ( <STRING> if a % 2 == 0 else <STRING> ) <NEWLINE>
a = int ( input ( ) ) <NEWLINE> b = int ( input ( ) ) <NEWLINE> <NL> n = a * b <NEWLINE> <NL> if n % 2 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a = int ( input ( ) ) <NEWLINE> b = int ( input ( ) ) <NEWLINE> <NL> x = a * b <NEWLINE> <NL> if x % 2 == 0 : <NEWLINE> <INDENT> answer = <STRING> <NEWLINE> <DEDENT> elif x % 2 == 1 : <NEWLINE> <INDENT> answer = <STRING> <NEWLINE> <NL> <DEDENT> print ( answer ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( <STRING> ) if a * B % 2 != 0 else print ( <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
a , b = map ( int ( input ( ) . split ( ) ) ) <NEWLINE> <NL> if ( a * b ) % 2 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if a * b % 2 = 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a = int ( input ( ) ) <NEWLINE> b = int ( input ( ) ) <NEWLINE> <NL> if ( a * b ) % 2 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif ( a * b ) % 2 != 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b = int ( input ( ) . rstrip ( ) . split ( ) ) <NEWLINE> <NL> c = a * b <NEWLINE> <NL> d = c / 2 <NEWLINE> <NL> if ( d == 0 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
<COMMENT> <NL> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <COMMENT> <NL> if ( a % 2 ) = 0 or ( b % 2 ) = 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a = input ( ) <NEWLINE> b = input ( ) <NEWLINE> <NL> int ( a ) <NEWLINE> int ( b ) <NEWLINE> <NL> if a * b % 2 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( <STRING> if a * b % == 0 else <STRING> ) <NEWLINE>
z = a * b <NEWLINE> if ( z % 2 ) == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> mult = a * b <NEWLINE> if mult % 2 = 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if a * b % 2 = 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if ( A * B ) % 2 == 0 : <NEWLINE> <INDENT> print ( Even ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( Odd ) <NEWLINE> <DEDENT>
<NL> def product ( a , b ) : <NEWLINE> <INDENT> return a * b <NEWLINE> <NL> <DEDENT> def judge ( num ) : <NEWLINE> <INDENT> if num % 2 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> a , b = map ( int , input ( ) ) <NEWLINE> <NL> judge ( product ( a , b ) ) <NEWLINE>
a = int ( input ( ) ) <NEWLINE> b = int ( input ( ) ) <NEWLINE> <NL> if a * b % 2 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
print ( [ <STRING> , <STRING> ] [ max ( 0 , sum ( map ( lambda x : int ( x ) % 2 , input ( ) ) ) - 1 ) ] ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> s = a * b <NEWLINE> if s % 2 == 0 : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT>
a = int ( input ( ) ) <NEWLINE> b = int ( input ( ) ) <NEWLINE> if ( a * b ) % 2 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if ( a * b ) / 2 %= 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT>
a = int ( input ( ) ) <NEWLINE> b = int ( input ( ) ) <NEWLINE> <NL> if ( a * b ) % 2 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> c = ( a * b ) % 2 <NEWLINE> if c = 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
<NL> a = int ( input ( ) ) <NEWLINE> <NL> <NL> <NL> b = int ( input ( ) ) <NEWLINE> <NL> if ( a * b ) % 2 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> z = int ( str ( x ) + str ( y ) ) <NEWLINE> for i in range ( int ( z ** ( 1 / 2 ) ) + 1 ) : <NEWLINE> <INDENT> if i ** 2 = z : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
a , b = input ( ) . split ( ) <NEWLINE> c = a + b <NEWLINE> import math <NEWLINE> if int ( math . sqrt ( c ) ) ** 2 == c : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> a , b = input ( ) . split ( ) <NEWLINE> c = a + b <NEWLINE> d = np . sqrt ( c ) <NEWLINE> if isinstance ( d , int ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b = input ( ) . split ( ) <NEWLINE> num = int ( a + b ) <NEWLINE> <NL> for i in range ( 1 , 101 ) : <NEWLINE> <INDENT> if num == i * i : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
a , b = map ( str , input ( ) . split ( ) ) <NEWLINE> <NL> c = int ( a + b ) <NEWLINE> <NL> import math <NEWLINE> <NL> if math . sprt ( c ) . isdigit ( ) == True : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <NL> <DEDENT>
<NL> list = input ( ) . split ( ) <NEWLINE> <NL> num = int ( list [ 0 ] + list [ 1 ] ) <NEWLINE> <NL> num_squrt = math . sqrt ( num ) <NEWLINE> <NL> if num_squrt . is_integer ( ) == True : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b = input ( ) . split ( ) <NEWLINE> <NL> S = int ( a + b ) <NEWLINE> <NL> if math . sqrt ( S ) . is_integer ( ) == True : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
if str ( int ( str ( map ( int , input ( ) . split ( ) ) [ 0 ] ) + str ( map ( int , input ( ) . split ( ) ) [ 1 ] ) ) ** 0.5 ) . split ( <STRING> ) [ 1 : ] [ 0 ] == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import sys <NEWLINE> import math <NEWLINE> import itertools <NEWLINE> import bisect <NEWLINE> from copy import copy <NEWLINE> from collections import deque , Counter <NEWLINE> from decimal import Decimal <NEWLINE> def s ( ) : return input ( ) <NEWLINE> def i ( ) : return int ( input ( ) ) <NEWLINE> def S ( ) : return input ( ) . split ( ) <NEWLINE> def I ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def X ( ) : return list ( input ( ) ) <NEWLINE> def L ( ) : return list ( input ( ) . split ( ) ) <NEWLINE> def l ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> def lcm ( a , b ) : return a * b // math . gcd ( a , b ) <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> a = l ( ) <NEWLINE> ans = <STRING> . join ( a ) <NEWLINE> for i in range ( 1 , 101 ) : <NEWLINE> <INDENT> if ans == i ** 2 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
a = str ( input ( ) ) <NEWLINE> b = str ( input ( ) ) <NEWLINE> <NL> n = a + b <NEWLINE> <NL> for i in range ( int ( n ) // 2 ) : <NEWLINE> <INDENT> if i ** 2 == int ( n ) : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
heck = int ( input ( ) . replace ( <STRING> , <STRING> ) ) <NEWLINE> print ( <STRING> if ( check ** 0.5 ) % 1 == 0 else <STRING> ) <NEWLINE>
ab = int ( input ( ) . replace ( <STRING> , <STRING> ) ) <NEWLINE> print ( [ <STRING> , <STRING> ] [ any ( i ** 2 == ab for i in range ( ab ) ) <NEWLINE>
a = int ( list ( input ( ) . split ( ) ) . join ( <STRING> ) ) <NEWLINE> print ( <STRING> if int ( a ** .5 ) == ( a ** .5 ) else <STRING> ) <NEWLINE>
a , b = map ( int , input ( ) . split ) <NEWLINE> if isinstance ( ( 10 * a + b ) ^ ( 1 / 2 ) , int ) == True : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b = map ( str , input ( ) . split ( ) ) <NEWLINE> <NL> c = a + b <NEWLINE> c = int ( c ) <NEWLINE> <NL> for i in range ( 400 ) [ 1 : ] : <NEWLINE> <INDENT> if c = i ** 2 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> s = 0 <NEWLINE> s += b <NEWLINE> s += a * ( 10 ** len ( b ) ) <NEWLINE> for i in range ( 320 ) : <NEWLINE> <INDENT> if s == i * i : <NEWLINE> <INDENT> print ( i ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT>
a , b = map ( input ( ) . split ( ) ) <NEWLINE> c = a + b <NEWLINE> c = int ( c ) ** 0.5 <NEWLINE> if isinstance ( c , int ) == True : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b = input ( ) <NEWLINE> ab = int ( <STRING> + <STRING> ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 350 ) : <NEWLINE> <INDENT> if int ( ab ** ( 1 / 2 ) ) == i : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> ans += 1 <NEWLINE> quit ( ) <NEWLINE> <DEDENT> <DEDENT> if ans == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if str ( int ( str ( a ) + str ( b ) ) ** 0.5 ) % 1 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a = input ( ) <NEWLINE> b = input ( ) <NEWLINE> a += b <NEWLINE> can = 0 <NEWLINE> for i in range ( 1 , 100 ) : <NEWLINE> <INDENT> if ( i * i == int ( a ) ) : <NEWLINE> <INDENT> can = 1 <NEWLINE> <DEDENT> <DEDENT> if ( can == 1 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b = map ( str , input ( ) . split ( ) ) <NEWLINE> res = int ( a + b ) <NEWLINE> ans = <STRING> <NEWLINE> for i in range ( res ** 0.5 ) : <NEWLINE> <INDENT> if i ** 2 == res : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
a , b = imput ( ) . split ( ) <NEWLINE> a = int ( a + b ) <NEWLINE> for i in range ( 1 , 320 ) : <NEWLINE> <INDENT> if i ** 2 == a : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( 0 ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> e1 , e2 = map ( str , input ( ) . split ( ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> count = 0 <NEWLINE> a = e1 + e2 <NEWLINE> for i in range ( int ( a ) ) : <NEWLINE> <INDENT> if a / i == i : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> if count > 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import math <NEWLINE> a , b = input ( ) . split ( ) <NEWLINE> gosei = int ( a + b ) <NEWLINE> tekito = math . ceil ( mast . sqrt ( 100100 ) ) <NEWLINE> r = <STRING> <NEWLINE> for i in range ( 1 , tekito + 1 ) : <NEWLINE> <INDENT> if i ** 2 == gosei : <NEWLINE> <INDENT> r = <STRING> <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( r ) <NEWLINE>
a , b = map ( str , input ( ) . split ( ) ) <NEWLINE> n = int ( a + b ) <NEWLINE> for i in range ( 0 , 110 ) : <NEWLINE> <INDENT> if i ** 2 == n : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> exit ( ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE>
N = int ( input ( ) . remove ( <STRING> , <STRING> ) ) <NEWLINE> <NL> print ( <STRING> if round ( N ** 0.5 ) ** 2 == N else <STRING> ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> P = [ ( 0 , 0 , 0 ) ] * ( N + 1 ) <NEWLINE> <NL> D = [ 0 ] * ( N + 1 ) <NEWLINE> <NL> P [ 0 ] = ( 0 , 0 , 0 ) <NEWLINE> D [ 0 ] = 1 <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> t , x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> dt = t - P [ i - 1 ] [ 0 ] <NEWLINE> dx = abs ( x - P [ i - 1 ] [ 1 ] ) <NEWLINE> dy = abs ( y - P [ i - 1 ] [ 2 ] ) <NEWLINE> if dt < ( dx + dy ) :  <  <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> if ( ( dx + dy ) == 0 and dt % 2 != 0 ) : mod2 == 0 <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <COMMENT> <NL> <DEDENT> if ( dt - ( dx + dy ) ) % 2 != 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <NL> <DEDENT> P [ i ] = ( t , x , y ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> xy = [ ] <NEWLINE> try : <NEWLINE> <INDENT> while True : <NEWLINE> <INDENT> t = input ( ) . split ( ) <NEWLINE> t = list ( map ( int , t ) ) <NEWLINE> xy . append ( t ) <NEWLINE> <DEDENT> <DEDENT> except EOFError : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> loc = [ 0 , 0 ] <NEWLINE> time = 0 <NEWLINE> for i in range ( N + 1 ) : <NEWLINE> <INDENT> a = xy [ i ] <NEWLINE> time = a [ 0 ] - time <NEWLINE> dis = abs ( loc [ 0 ] - a [ 1 ] ) + abs ( loc [ 1 ] - a [ 2 ] ) <NEWLINE> if ( time - dis ) < 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> elif ( time - dis ) % 2 == 0 : <NEWLINE> <INDENT> loc = [ a [ 1 ] , a [ 2 ] ] <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> flag = <STRING> <NEWLINE> p , q , r = 0 , 0 , 0 <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> t , x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> a = x + y - p - q <NEWLINE> e = t - r <NEWLINE> if a <= e : <NEWLINE> <INDENT> if ( e - a ) % 2 != 0 : <NEWLINE> <INDENT> flag = <STRING> <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> flag = <STRING> <NEWLINE> break <NEWLINE> <DEDENT> p = x <NEWLINE> q = y <NEWLINE> r = t <NEWLINE> <DEDENT> print ( flag ) N = int ( input ( ) ) <NEWLINE> flag = <STRING> <NEWLINE> p , q , r = 0 , 0 , 0 <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> t , x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> a = x + y - p - q <NEWLINE> e = t - r <NEWLINE> if a <= e : <NEWLINE> <INDENT> if ( e - a ) % 2 != 0 : <NEWLINE> <INDENT> flag = <STRING> <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> flag = <STRING> <NEWLINE> break <NEWLINE> <DEDENT> p = x <NEWLINE> q = y <NEWLINE> r = t <NEWLINE> <DEDENT> print ( flag ) <NEWLINE>
dt = 0 <NEWLINE> dx = 0 <NEWLINE> dy = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if abs ( txy [ i ] [ 1 ] - dx ) + abs ( txy [ i ] [ 2 ] - dy ) > txy [ i ] [ 0 ] - dt or ( txy [ i ] [ 1 ] + txy [ i ] [ 2 ] ) % 2 != txy [ i ] [ 0 ] % 2 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> dt = txy [ i ] [ 0 ] <NEWLINE> dx = txy [ i ] [ 1 ] <NEWLINE> dy = txy [ i ] [ 2 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> arr = [ [ 0 , 0 , 0 ] + [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ] ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> t1 , x1 , y2 = arr [ i ] <NEWLINE> t2 , x2 , y2 = arr [ i + 1 ] <NEWLINE> if abs ( x1 - x2 ) + abs ( y1 - y2 ) > t1 + t2 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> if ( abs ( x1 - x2 ) + abs ( y1 - y2 ) ) % 2 != ( t1 + t2 ) % 2 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> t = 0 <NEWLINE> x = 0 <NEWLINE> y = 0 <NEWLINE> for i in range ( N ) <NEWLINE> <INDENT> nt , nx , ny = map ( int , input ( ) . split ( ) ) <NEWLINE> km = abs ( nx - x ) + abs ( ny - y ) <NEWLINE> if km > ( nt - t ) or ( km - ( nt - t ) ) % 2 == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( 0 ) <NEWLINE> <DEDENT> t , x , y = nt , nx , ny <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> found = True <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> t , x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> if t == 0 : <NEWLINE> <INDENT> if x == 0 and y == 0 : <NEWLINE> <INDENT> found = False <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if t % ( x + y ) != 0 : <NEWLINE> <INDENT> found = False <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if found : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> l = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ] <NEWLINE> <NL> pT , pX , pY = 0 , 0 , 0 <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> cT , cX , cY = l [ i ] <NEWLINE> mvT , mvX , mvY = abs ( cT - pT ) , abs ( cX - pX ) , abs ( cY - pY ) <NEWLINE> <NL> dam = mvT - ( mvX + mvY ) <NEWLINE> <NL> if dam % 2 == 1 or dam < 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> pT , pX , pY = l [ i ] <NEWLINE> <NL> <DEDENT> print ( <STRING> ) <NEWLINE> <NL>
N = int ( input ( ) ) <NEWLINE> T = [ [ 0 , 0 , 0 ] ] + [ map ( int , input ( ) . split ( ) ) for _ in range ( N ) ] <NEWLINE> flag = <STRING> <NEWLINE> i = 0 <NEWLINE> while flag == <STRING> and i < len ( T ) - 1 : <NEWLINE> <INDENT> dis = abs ( T [ i ] [ 2 ] - T [ i ] [ 2 ] ) + abs ( T [ i ] [ 1 ] - T [ i ] [ 1 ] ) <NEWLINE> _t = T [ i ] [ 0 ] - T [ i ] [ 0 ] <NEWLINE> if dis > _t or _t % 2 != dis % 2 : <NEWLINE> <INDENT> flag = <STRING> <NEWLINE> <DEDENT> i += 1 <NEWLINE> <DEDENT> print ( flag ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <NL> import sys <NEWLINE> <NL> n = int ( sys . stdin . readline ( ) . strip ( ) ) <NEWLINE> <NL> txy = [ ( 0 , 0 , 0 ) ] + [ tuple ( map ( int , l . strip ( ) . split ( <STRING> ) ) ) for l in sys . stdin . readlines ( ) ] <NEWLINE> check_txy = [ abs ( _x - _xp ) + abs ( _y - _ yp ) <= _t - _tp and ( _t + _x + _y ) % 2 == 0 for ( _t , _x , _y ) , ( _tp , _xp , _yp ) in zip ( txy [ 1 : ] , txy ) ] <NEWLINE> if all ( check_txy ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> ex_t , ex_x , ex_y = 0 , 0 , 0 <NEWLINE> count = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> t , x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> if abs ( x - ex_x ) + abs ( y - ex_y ) <= abs ( t - ex_t ) and t % 2 = ( x + y ) % 2 : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> ex_t , ex_x , ex_y = t , x , y <NEWLINE> <DEDENT> print ( <STRING> if count == N else <STRING> ) <NEWLINE>
<COMMENT> <NL> N = int ( input ( ) ) <NEWLINE> <NL> plan = [ ] <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> ti , xi , yi = map ( int , input ( ) . split ( ) ) <NEWLINE> plan . append ( ( ti , xi , yi ) ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> spot = ( 0 , 0 , 0 ) <COMMENT> <NEWLINE> result = <STRING> <NEWLINE> for t , x , y in plan : <NEWLINE> <INDENT> tdiff = t - spot [ 0 ] <NEWLINE> xdiff = abs ( x - spot [ 1 ] ) <NEWLINE> ydiff = abs ( y - spot [ 2 ] ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> if ( tdiff % 2 == ( xdiff + ydiff ) % 2 ) and ( ( xdiff + ydiff ) <= tdiff ) : <NEWLINE> <STRING> <NEWLINE> <INDENT> spot = ( t , x , y ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> result = <STRING> <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( result ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> T = [ ] <NEWLINE> X = [ ] <NEWLINE> Y = [ ] <NEWLINE> T [ 0 ] = X [ 0 ] = Y [ 0 ] = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> t , x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> T . append ( t ) <NEWLINE> X . append ( x ) <NEWLINE> Y . append ( y ) <NEWLINE> <NL> <DEDENT> flag = True <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> time = T [ i + 1 ] - T [ i ] <NEWLINE> dist = abs ( X [ i + 1 ] - X [ i ] ) + abs ( Y [ i + 1 ] - Y [ i ] ) <NEWLINE> if time < dist or ( dist % 2 != time % 2 ) : <NEWLINE> <INDENT> flag = False <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if flag : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> <NL> for _ in range ( n ) : <NEWLINE> <INDENT> t , x , y = map ( int , n . split ( ) ) <NEWLINE> if x + y > t or ( t - x - y ) % 2 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> <NL>
<INDENT> n = int ( input ( ) ) <NEWLINE> pos = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ] <NEWLINE> <NL> def func ( n , pos ) : <NEWLINE> <INDENT> c_t , c_x , c_y = 0 , 0 , 0 <NEWLINE> <NL> for i in pos : <NEWLINE> <INDENT> d_t = i [ 0 ] - c_t <NEWLINE> z = abs ( i [ 1 ] - c_x ) + abs ( i [ 2 ] - c_y ) <NEWLINE> <NL> if z > d_t or ( d_t - z ) % 2 != 0 : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> c_t , c_x , c_y = 0 , 0 , 0 <NEWLINE> <NL> <DEDENT> <DEDENT> return <STRING> <NEWLINE> <NL> <NL> <DEDENT> print ( func ( n , pos ) ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> n = int ( input ( ) ) <NEWLINE> t = [ - 1 for _ in <NEWLINE> x = [ - 1 for _ in <NEWLINE> y = [ - 1 for _ in <NEWLINE> for i in range ( n <NEWLINE> <INDENT> t [ i ] , x [ i ] , <NEWLINE> <NL> <DEDENT> dt = [ - 1 for _ i <NEWLINE> dx = [ - 1 for _ i <NEWLINE> dy = [ - 1 for _ i <NEWLINE> for i in range ( n <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> dt [ 0 ] = <NEWLINE> dx [ 0 ] = <NEWLINE> dy [ 0 ] = <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dt [ i ] = <NEWLINE> dx [ i ] = <NEWLINE> dy [ i ] = <NEWLINE> <NL> <DEDENT> <DEDENT> ok = True <NEWLINE> for i in range ( n <NEWLINE> <INDENT> tr = dt [ i ] % 2 <NEWLINE> pr = ( dx [ i ] + <NEWLINE> if ( tr == pr <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ok = Fal <NEWLINE> <COMMENT> <NL> break <NEWLINE> <NL> <DEDENT> <DEDENT> if ok : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> tp , xp , yp = 0 , 0 , 0 <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> t , x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> td = t - tp <NEWLINE> xd = x - xp <NEWLINE> yd = y - yp <NEWLINE> if td < abs ( xd ) + abs ( yd ) or ( td - abs ( xd ) - abs ( yd ) ) % 2 == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> tp = t <NEWLINE> xp = x <NEWLINE> yp = y <NEWLINE> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
<COMMENT> <NL> import math <NEWLINE> n = int ( input ( ) ) <NEWLINE> t = 0 <NEWLINE> x = 0 <NEWLINE> y = 0 <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> for ti , xi , yi in map ( int , input ( ) . split ( ) ) : <NEWLINE> <INDENT> if abs ( xi - x ) + abs ( yi - y ) > abs ( ti - t ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> elif ( abs ( xi - x ) + abs ( yi - y ) - abs ( ti - t ) ) % 2 != 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> t = ti <NEWLINE> x = xi <NEWLINE> y = yi <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> t , x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> if t < x + y : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif t % 2 != p % 2 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
Row = int ( input ( ) ) <NEWLINE> List = [ ] <NEWLINE> for i in range ( Row ) : <NEWLINE> <INDENT> List . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <DEDENT> x = 0 <NEWLINE> y = 0 <NEWLINE> flag = True <NEWLINE> for i in range ( Row ) : <NEWLINE> <INDENT> reqT = List [ i ] [ 1 ] - x + List [ i ] [ 2 ] - y <NEWLINE> chck = reqT - T <NEWLINE> if chck < 0 or chck % 2 == 1 : <NEWLINE> <INDENT> flag = False <NEWLINE> break <NEWLINE> <DEDENT> x = List [ i ] [ 1 ] <NEWLINE> y = List [ i ] [ 2 ] <NEWLINE> <DEDENT> if flag : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n , a , b = map ( int , input . split ( ) ) <NEWLINE> if ( a - b ) % 2 == 0 : print ( <STRING> ) <NEWLINE> else : print ( <STRING> ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> As = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> def f ( m ) : <NEWLINE> <INDENT> debug = m <NEWLINE> for a in As : <NEWLINE> <INDENT> i = m // a <NEWLINE> m = i * a <NEWLINE> <DEDENT> return m <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> l = 1 <NEWLINE> r = 10 ** 5 + 1 <NEWLINE> while r - l > 1 : <NEWLINE> <INDENT> m = ( r + l ) // 2 <NEWLINE> if f ( m ) <= 1 : l = m <NEWLINE> else : r = m <NEWLINE> <DEDENT> ans1 = r <NEWLINE> l = 1 <NEWLINE> r = 10 ** 5 + 1 <NEWLINE> while r - l > 1 : <NEWLINE> <INDENT> m = ( r + l ) // 2 <NEWLINE> if f ( m ) <= 2 : l = m <NEWLINE> else : r = m <NEWLINE> <DEDENT> ans2 = l <NEWLINE> <NL> if ans1 >= ans2 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans1 [ 1 ] , ans2 [ 0 ] ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> print ( s . replace ( 2017 , 2018 ) ) <NEWLINE>
S = input ( ) <NEWLINE> <NL> S [ 4 ] = <STRING> <NEWLINE> print ( S ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> d_i_list = [ int ( input ( ) ) for i in range ( n ) ] <NEWLINE> <NL> print ( len ( list ( set ( d_i_list ) ) ) ) <NEWLINE>
s = list ( input ( ) ) <NEWLINE> s [ 3 ] = 8 <NEWLINE> print ( <STRING> . join ( s ) ) <NEWLINE>
s = input ( ) <NEWLINE> print ( 2018 + s [ 3 : ] ) <NEWLINE>
N , Y = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> for j in range ( N + 1 ) : <NEWLINE> <INDENT> for i in range ( N + 1 ) : <NEWLINE> <INDENT> sum = 10000 * j + 5000 * i + 1000 * ( N - i - j ) <NEWLINE> if ( sum == Y and N - i - j >= 0 ) : <NEWLINE> <INDENT> print ( j , i , N - i - j ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
a = input ( ) <NEWLINE> a [ 3 ] = <STRING> <NEWLINE> print ( a ) <NEWLINE>
s = input ( ) <NEWLINE> s [ : 4 ] = <STRING> <NEWLINE> print ( s ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> d = [ int ( input ( ) ) for i in range ( n ) ] <NEWLINE> ans = [ ] <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> if d [ i ] not in ans : <NEWLINE> <INDENT> ans . append ( d [ i ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( len ( ans ) ) <NEWLINE>
s = List ( input ( ) ) <NEWLINE> s [ 3 ] = <STRING> <NEWLINE> print ( s ) <NEWLINE>
S = input ( ) <NEWLINE> print ( S . replace ( 7 , 8 , 1 ) ) <NEWLINE>
a , b , c = map ( int , inpput ( ) . split ( <STRING> ) ) <NEWLINE> a = 2018 <NEWLINE> print ( a , <STRING> , b , <STRING> , c ) <NEWLINE>
S = list ( input ( ) ) <NEWLINE> S [ 3 ] = 8 <NEWLINE> print ( <STRING> . join ( S ) ) <NEWLINE>
s = input ( ) <NEWLINE> s [ 3 ] = <STRING> <NEWLINE> print ( s ) <NEWLINE>
N , Y = map ( int , input ( ) . split ( ) ) <NEWLINE> exist_flag = False <NEWLINE> for i in range ( N + 1 ) : <NEWLINE> <INDENT> for j in range ( N + 1 - i ) : <NEWLINE> <INDENT> if Y == 10000 * i + 5000 * j + 1000 * ( N - i - j ) : <NEWLINE> <INDENT> exist_flag = True <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if exist_flag : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> if not exist_flag : <NEWLINE> <INDENT> i , j , k = - 1 , - 1 , - 1 <NEWLINE> <DEDENT> print ( i , j , k ) <NEWLINE>
a = input ( ) <NEWLINE> a [ 3 ] = <STRING> <NEWLINE> print ( a ) <NEWLINE>
s = list ( input ( ) ) <NEWLINE> s [ 3 ] = 8 <NEWLINE> for in in s : <NEWLINE> <INDENT> print ( s , end = <STRING> ) <NEWLINE> <DEDENT>
S = str ( input ( ) ) <NEWLINE> S [ 3 ] = 8 <NEWLINE> print ( S ) <NEWLINE>
N , Y = map ( int , input ( ) . split ( ) ) <NEWLINE> for x in range ( N + 1 ) : <NEWLINE> <INDENT> for y in range ( N + 1 ) : <NEWLINE> <INDENT> z = N - x - y <NEWLINE> if x + y + z == N and 10000 * x + 5000 * y + 1000 * z == Y : <NEWLINE> <INDENT> print ( x , y , z ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( - 1 , - 1 , - 1 , sep = <STRING> ) <NEWLINE>
s = input ( ) <NEWLINE> print ( s [ : 2 ] + <STRING> + s [ 4 : ] <NEWLINE>
S = input ( ) <NEWLINE> print ( S [ 4 ] <STRING> ) <NEWLINE>
s = input ( ) <NEWLINE> s [ 3 ] = <STRING> <NEWLINE> print ( s ) <NEWLINE>
s = input ( ) <NEWLINE> pirnt ( s [ : 3 ] + <STRING> + s [ 4 : ] ) <NEWLINE>
s = input ( ) <NEWLINE> res = <STRING> + s [ 4 , len ( s ) ] <NEWLINE> print ( res ) <NEWLINE>
S = input ( ) <NEWLINE> <NL> print ( S . replace ( <STRING> , <STRING> ) <NEWLINE>
a = input ( ) <NEWLINE> a [ 3 ] = <STRING> <NEWLINE> print ( a ) <NEWLINE>
a , b , c = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> print ( <STRING> + int ( b ) + <STRING> + int ( c ) ) <NEWLINE>
s = input ( ) <NEWLINE> s [ 3 ] = <STRING> <NEWLINE> print ( s ) <NEWLINE>
s = str ( input ( ) ) <NEWLINE> s [ 3 ] = <STRING> <NEWLINE> print ( s ) <NEWLINE>
S = input ( ) <NEWLINE> S [ 3 ] = <STRING> <NEWLINE> print ( S ) <NEWLINE>
Row = int ( input ( ) ) <NEWLINE> List = [ ] <NEWLINE> for i in range ( Row ) : <NEWLINE> <INDENT> List . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <DEDENT> s_l = set ( List ) <NEWLINE> print ( len ( s_l ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> d = list ( int ( input ( ) ) for i in range ( n ) ) <NEWLINE> cnt = 0 <NEWLINE> st = 100 <NEWLINE> l = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if d < st : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> st = d <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> l . append ( cnt ) <NEWLINE> st = 100 <NEWLINE> cnt = 0 <NEWLINE> <DEDENT> <DEDENT> l . sort ( ) <NEWLINE> print ( l [ len ( l ) - 1 ] ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> d = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> d . extend ( int ( input ( ) ) ) <NEWLINE> <DEDENT> print ( len ( set ( d ) ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> List = [ int ( input ( ) ) for i in range ( n ) ] <NEWLINE> ans = 0 <NEWLINE> while True <NEWLINE> for i , j in range ( n ) : <NEWLINE> <INDENT> if i == j : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( n - ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = [ input ( ) for i in range ( N ) ] <NEWLINE> B = [ ] <NEWLINE> while len ( A ) != 0 : <NEWLINE> <INDENT> if A [ 0 ] not in B : <NEWLINE> <INDENT> B . append ( A [ 0 ] ) <NEWLINE> <DEDENT> A . popleft ( ) <NEWLINE> <DEDENT> print ( len ( B ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = A . copy ( ) <NEWLINE> counter = 0 <NEWLINE> for num in range ( N - 2 ) : <NEWLINE> <INDENT> if A [ num ] in B : <NEWLINE> <INDENT> counter += 1 <NEWLINE> while A [ num ] in B : <NEWLINE> <INDENT> B . remove ( A [ num ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( counter ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> s = set ( ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> s . add ( int ( input ( ) ) <NEWLINE> <NL> <DEDENT> print ( min ( 3 , len ( s ) ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> d = list ( int ( input ( ) ) for _ in range ( N ) ) <NEWLINE> print ( len ( set ( sortd ( d ) ) ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = sorted [ input ( ) for _ in range ( N ) ] <NEWLINE> print ( len ( set ( A ) ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> cake = [ input ( ) for i range ( n ) ] <NEWLINE> <NL> print ( len ( set ( cake ) ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> num = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> num . sort ( ) <NEWLINE> count = 1 <NEWLINE> <NL> for i in range ( N - 1 ) : <NEWLINE> <INDENT> if not num [ i ] == num [ i + 1 ] : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> m = { } <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> x = int ( input ( ) ) <NEWLINE> m . add ( x ) <NEWLINE> <NL> <DEDENT> print ( len ( m ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> d = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> x = sorted ( d , reverse = True ) <NEWLINE> <NL> ans = 1 <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> if x [ i ] - x [ i + 1 ] > 0 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> list_a = [ int ( input ( ) ) for i in range ( N ) ] <NEWLINE> s = [ ] <NEWLINE> for i in list_a : <NEWLINE> <INDENT> if s . count ( i ) == 0 <NEWLINE> <INDENT> s . append ( i ) <NEWLINE> <DEDENT> <DEDENT> print ( len ( s ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> d = int ( input ( ) ) <NEWLINE> <NL> <DEDENT> dset = set ( d ) <NEWLINE> print ( len ( dset ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> d = [ int ( input ( ) ) for i in range ( n ) ] <NEWLINE> <NL> print ( len ( set ( d ) ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> D = [ int ( input ( ) ) for _ in range ( n ) ] <NEWLINE> print ( len ( set ( D ) ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> mochi = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> a = int ( input ( ) ) <NEWLINE> if not a in mochi : <NEWLINE> <INDENT> mochi . append ( a ) <NEWLINE> <NL> <DEDENT> <DEDENT> mochi . sorted ( ) <NEWLINE> print ( len ( mochi ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> <NL> List = sorted ( list ( set ( list ( int ( input ( ) ) for i in range ( N ) ) ) ) ) <NEWLINE> <NL> print ( len ( List ( ) ) ) <NEWLINE>
mycode = <STRING> <NEWLINE> <NL> import sys <NEWLINE> if sys . argv [ - 1 ] == <STRING> : <COMMENT> <NEWLINE> <INDENT> import os <NEWLINE> with open ( <STRING> , <STRING> ) as f : <NEWLINE> <INDENT> f . write ( mycode ) <NEWLINE> <DEDENT> os . system ( <STRING> ) <NEWLINE> <NL> <DEDENT> import mycode <NEWLINE>
N = int ( input ( ) ) <NEWLINE> D = [ int ( input ( ) ) for _ in range ( N ) ] <NEWLINE> <NL> l = [ 0 ] * 100 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> l [ d [ i ] - 1 ] = 1 <NEWLINE> <NL> <DEDENT> print ( sum ( l ) ) <NEWLINE>
N , Y = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> ans = [ - 1 , - 1 , - 1 ] <NEWLINE> <NL> for n1 in range ( N + 1 ) : <NEWLINE> <INDENT> for n2 in range ( N - n1 + 1 ) : <NEWLINE> <INDENT> yen = n1 * 10000 + n2 * 5000 + ( N - n1 - n2 ) * 1000 <NEWLINE> if yen == Y : <NEWLINE> <INDENT> ans = [ n1 , n2 , N - n1 - n2 ] <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> . join ( ans ) ) <NEWLINE>
n , y = map ( int , input ( ) . split ( ) ) <NEWLINE> y //= 1000 <NEWLINE> for i in range ( n + 1 ) : <NEWLINE> <INDENT> for j in range ( n - i + 1 ) : <NEWLINE> <INDENT> if n - ( i + j ) < 0 <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if 9 * i + 4 * j + n == y : <NEWLINE> <INDENT> print ( i , j , n - ( i + j ) ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> , <STRING> , <STRING> ) <NEWLINE>
N , Y = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> for x in range ( N + 1 ) : <NEWLINE> <INDENT> for y in range ( N - x + 1 ) : <NEWLINE> <INDENT> z = N - x - y <NEWLINE> if 10000 * a + 5000 * b + 1000 * c == Y : <NEWLINE> <INDENT> print ( a , b , c ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 , - 1 , - 1 ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
n , y = map ( int , input ( ) . split ( ) ) <NEWLINE> for i in range ( n + 1 ) : <NEWLINE> <INDENT> for g in range ( n - i ) : <NEWLINE> <INDENT> s = n - i - g <NEWLINE> if 10000 * i + 5000 * g 1000 * s == y : <NEWLINE> <INDENT> print ( i , g , s ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
n , y = map ( int , input ( ) . split ( ) ) <NEWLINE> y = y / 1000 <NEWLINE> for i in range ( n + 1 ) : <NEWLINE> <INDENT> for j in range ( n - i + 1 ) : <NEWLINE> <INDENT> if 10 * i + 5 * j + 1 * ( n - i - j ) == y : <NEWLINE> <INDENT> print ( i ) <NEWLINE> print ( j ) <NEWLINE> print ( n - i - j ) <NEWLINE> exit ( 1 ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( - 1 ) <NEWLINE> print ( - 1 ) <NEWLINE> print ( - 1 ) <NEWLINE>
N , Y = map ( int , input ( ) . split ( ) ) <NEWLINE> res = ( - 1 , - 1 , - 1 ) <NEWLINE> for x in range ( N + 1 ) : <NEWLINE> <INDENT> for y in range ( N + 1 - x ) : <NEWLINE> <INDENT> if N - x - y >= 0 and 10000 * x + 5000 * y + 1000 * z == Y : <NEWLINE> <INDENT> res = ( x , y , N - x - y ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( res [ 0 ] , res [ 1 ] , res [ 2 ] ) <NEWLINE>
N , Y = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> for a in range ( n + 1 ) : <NEWLINE> <INDENT> for b in range ( n - a + 1 ) : <NEWLINE> <INDENT> c = n - a - b <NEWLINE> if 10000 * a + 5000 * b + 1000 * c == Y : <NEWLINE> <INDENT> print ( a , b , c ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( - 1 , - 1 , - 1 ) <NEWLINE>
n , y = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <COMMENT> <NL> y = y // 1000 <NEWLINE> <NL> <COMMENT> <NL> for i in range ( n + 1 ) : <NEWLINE> <INDENT> for j in range ( n + 1 ) : <NEWLINE> <COMMENT> <NL> <INDENT> money = y - i * 10 - j * 50 <NEWLINE> <NL> <COMMENT> <NL> if money == n - i - j : <NEWLINE> <INDENT> print ( <STRING> . format ( i , j , money ) ) <NEWLINE> return 0 <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
n , y = map ( int , input ( ) . split ( ) ) <NEWLINE> if y > 10000 * n : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for p in range ( n + 1 ) : <NEWLINE> <INDENT> for q in range ( n - p + 1 ) : <NEWLINE> <INDENT> if 10000 * p + 5000 * q + 1000 * ( n - p - q ) == y : <NEWLINE> <INDENT> print ( p , q , r ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n , y = map ( int , input ( ) . split ( ) ) <NEWLINE> a , b , c = - 1 , - 1 , - 1 <NEWLINE> x = y // 1000 - n <NEWLINE> if y % 1000 == 0 : <NEWLINE> <INDENT> for i in range ( n + 1 ) : <NEWLINE> <INDENT> for j in range ( n + 1 - j ) : <NEWLINE> <INDENT> if x == 9 * i + 4 * j : <NEWLINE> <INDENT> a = i <NEWLINE> b = j <NEWLINE> c = n - i - j <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if a != - 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( a , b , c ) <NEWLINE>
N , Y = map ( int , input ( ) . split ( ) ) <NEWLINE> res_x = - 1 , res_y = - 1 , res_z = - 1 <NEWLINE> for x in range ( N ) : <NEWLINE> <INDENT> for j in range ( N - x ) : <NEWLINE> <INDENT> z = N - x - y <NEWLINE> if 10000 * x + 5000 * y + 1000 * z == Y : <NEWLINE> <INDENT> res_x = x <NEWLINE> res_y = y <NEWLINE> res_z = z <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> . format ( res_x , res_y , res_z ) ) <NEWLINE>
n , y = map ( int , input ( ) . split ( ) ) <NEWLINE> for i in range ( n + 1 ) : <NEWLINE> <INDENT> for j in range ( n + 1 ) : <NEWLINE> <INDENT> if ( y - 1000 * i - 5000 * j ) / 10000 = n - i - j : <NEWLINE> <INDENT> print ( i , j , n - i - j ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( - 1 , - 1 , - 1 ) <NEWLINE>
N , Y = map ( int , input ( ) . split ( ) ) <NEWLINE> exist_flag = False <NEWLINE> for i in range ( N + 1 ) : <NEWLINE> <INDENT> for j in range ( N + 1 - i ) : <NEWLINE> <INDENT> if Y == 10000 * i + 5000 * j + 1000 * ( N - i - j ) : <NEWLINE> <INDENT> exist_flag = True <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if exist_flag : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> if not exist_flag : <NEWLINE> <INDENT> i , j , k = - 1 , - 1 , - 1 <NEWLINE> <DEDENT> print ( i , j , k ) <NEWLINE>
N , Y = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> flag = 0 <NEWLINE> for x in range ( N + 1 ) : <NEWLINE> <INDENT> if flag > 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for y in range ( N - x + 1 ) : <NEWLINE> <INDENT> if 10000 * x + 5000 * y + 1000 * z == Y and flag == 0 : <NEWLINE> <INDENT> z = N - x - y <NEWLINE> flag += 1 <NEWLINE> print ( x , y , z ) <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if flag == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n , y = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> or i in range ( n + 1 ) : <NEWLINE> <INDENT> for j in range ( n - i + 1 ) : <NEWLINE> <INDENT> print ( i , j , n - i - j ) <NEWLINE> if 10000 * i + 5000 * j + 1000 * ( n - i - j ) == y : <NEWLINE> <INDENT> print ( i , j , n - i - j ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> print ( - 1 , - 1 , - 1 ) <NEWLINE> <DEDENT> <DEDENT>
N , Y = map ( int , input ( ) . split ( ) ) <NEWLINE> a = - 1 <NEWLINE> b = - 1 <NEWLINE> c = - 1 <NEWLINE> judge = False <NEWLINE> <NL> money = x * 10000 + y * 5000 + z * 1000 <NEWLINE> for x in range ( 20 , - 1 , - 1 ) : <NEWLINE> <INDENT> money_max = x * 10000 + ( N - x ) * 5000 <NEWLINE> money_min = x * 10000 + ( N - x ) * 1000 <NEWLINE> if money_min <= Y and Y <= money_max : <NEWLINE> <INDENT> for y in range ( N - x , - 1 , - 1 ) : <NEWLINE> <INDENT> money = x * 10000 + y * 5000 + ( N - x - y ) * 1000 <NEWLINE> if money == Y : <NEWLINE> <INDENT> a = x <NEWLINE> b = y <NEWLINE> c = N - ( x + y ) <NEWLINE> judge = True <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if judge : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> print ( a , b , c ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> Y = int ( input ( ) ) <NEWLINE> <NL> answer = [ ] <NEWLINE> comb = [ ] <NEWLINE> for j in range ( N + 1 ) : <NEWLINE> <INDENT> for i in range ( N + 1 ) : <NEWLINE> <INDENT> sum = 10000 * j + 5000 * i + 1000 * ( N - i - j ) <NEWLINE> if ( sum == Y and N - i - j >= 0 ) : <NEWLINE> <INDENT> print ( j , i , N - i - j ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
N , Y = input ( ) . split ( ) <NEWLINE> N = int ( N ) <NEWLINE> Y_k = int ( Y ) / 1000 <NEWLINE> <NL> answer - [ - 1 , - 1 , - 1 ] <NEWLINE> for i in range ( N + 1 ) : <NEWLINE> <INDENT> for j in range ( N + 1 - i ) : <NEWLINE> <INDENT> k = N - i - j <NEWLINE> if 10 * i + 5 * j + 1 * k == Y_k : <NEWLINE> <INDENT> answer = [ i , j , k ] <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( answer [ 0 ] , answer [ 1 ] , answer [ 2 ] ) <NEWLINE>
N , Y = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> for x in range ( N + 1 ) : <NEWLINE> <INDENT> for y in range ( N + 1 - x ) : <NEWLINE> <INDENT> if 10000 * x + 5000 * y + 1000 * ( N - x - y ) == Y : <NEWLINE> <INDENT> print ( x , y , z ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
A = 10000 <NEWLINE> B = 5000 <NEWLINE> C = 1000 <NEWLINE> ans_A = - 1 <NEWLINE> ans_B = - 1 <NEWLINE> ans_C = - 1 <NEWLINE> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> for a in range ( x + 1 ) : <NEWLINE> <INDENT> for b in range ( x - a + 1 ) : <NEWLINE> <INDENT> for c in range ( x - a - b + 1 ) : <NEWLINE> <INDENT> if a * A + b * B + c * C = y : <NEWLINE> <INDENT> ans_A = a <NEWLINE> ans_B = b <NEWLINE> ans_C = c <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans_A , ans_B , ans_C ) <NEWLINE>
import sys <NEWLINE> N , Y = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = 0 <NEWLINE> for x in range ( N ) : <NEWLINE> <INDENT> for y in range ( N ) : <NEWLINE> <INDENT> if 10000 * x + 5000 * y + 1000 * ( N - x - y ) == Y : <NEWLINE> <INDENT> print ( x + <STRING> + y + <STRING> + N - x - y ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( - 1 , - 1 , - 1 ) <NEWLINE>
N , Y = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> for a in range ( N + 1 ) : <NEWLINE> <INDENT> for b in range ( N + 1 - a ) : <NEWLINE> <INDENT> if 10000 * a + 5000 * b + 1000 * c == Y : <NEWLINE> <INDENT> print ( a , b , N - a - b ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 , - 1 , - 1 ) <NEWLINE> <DEDENT>
n , y = map ( int , input ( ) . split ( ) ) <NEWLINE> y = y // 1000 <NEWLINE> for i in range ( n + 1 ) : <NEWLINE> <INDENT> for j in range ( n + 1 - i ) : <NEWLINE> <INDENT> k = n - i - j <NEWLINE> if 10 * i + 5 * j + 1 * k == y : <NEWLINE> <INDENT> print ( str ( i ) + <STRING> + str ( j ) + <STRING> + str ( k ) ) <NEWLINE> syexit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
N , Y = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = False <NEWLINE> for i in range ( N + 1 ) : <NEWLINE> <INDENT> for j in range ( N + 1 ) : <NEWLINE> <INDENT> k = N - i - j <NEWLINE> if 10000 * i + 5000 * j + 1000 * k == Y and z >= 0 : <NEWLINE> <INDENT> ans = True <NEWLINE> print ( i , j , k ) <NEWLINE> <DEDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> if ans == False : <NEWLINE> <INDENT> print ( - 1 , - 1 , - 1 ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> int main ( ) <NEWLINE> { <NEWLINE> <INDENT> int N , a , b , c ; <NEWLINE> long Y , yn ; <NEWLINE> <NL> scanf ( <STRING> , & N ) ; <NEWLINE> scanf ( <STRING> , & Y ) ; <NEWLINE> <NL> Y = Y / 1000 ; <NEWLINE> yn = Y - N ; <NEWLINE> <NL> for ( c = 0 ; c <= N ; c + + ) { <NEWLINE> <INDENT> b = ( yn - 9 * c ) / 4 ; <NEWLINE> if ( ( yn - 9 * c ) % 4 == 0 ) { <NEWLINE> <INDENT> a = N - b - c ; <NEWLINE> if ( ( a >= 0 ) & & ( yn == 4 * b + 9 * c ) ) { <NEWLINE> <INDENT> printf ( <STRING> , a , b , c ) ; <NEWLINE> return 0 ; <NEWLINE> <DEDENT> } <NEWLINE> <DEDENT> } <NEWLINE> <DEDENT> } <NEWLINE> printf ( <STRING> , - 1 , - 1 , - 1 ) ; <NEWLINE> return 0 ; <NEWLINE> <DEDENT> } <NEWLINE>
N , Y = map ( int , input ( ) . split ( ) ) <NEWLINE> for i in range ( N + 1 ) : <NEWLINE> <INDENT> for j in range ( N + 1 - i ) : <NEWLINE> <INDENT> if Y == i * 10000 + j * 5000 + ( N - i - j ) * 1000 : <NEWLINE> <INDENT> print ( i , j , ( n - i - j ) ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
N , Y = map ( int , input ( ) . split ( ) ) <NEWLINE> total = 0 <NEWLINE> for x in range ( N + 1 ) : <NEWLINE> <INDENT> for y in range ( N + 1 - x ) : <NEWLINE> <INDENT> for z in range ( N + 1 - x - y ) : <NEWLINE> <INDENT> if Y == 10000 * x + 5000 * y + 1000 * z : <NEWLINE> <INDENT> total = total + 1 <NEWLINE> ans = str ( x ) + <STRING> + str ( y ) + <STRING> + str ( z ) <NEWLINE> print ( ans ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> break <NEWLINE> <DEDENT> break <NEWLINE> if total == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N , Y = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> for x in range ( N + 1 ) : <NEWLINE> <INDENT> for y in range ( N - x + 1 ) : <NEWLINE> <INDENT> z = N - x - y <NEWLINE> if 10000 * i + 5000 * j + z * 1000 == Y : <NEWLINE> <INDENT> print ( x , y , z ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( - 1 , - 1 , - 1 ) <NEWLINE>
for i in range ( 0 , N + 1 ) : <NEWLINE> <INDENT> for j in range ( 0 , N + 1 - i ) : <NEWLINE> <INDENT> if i == ( ( Y - 1000 * N - 4000 * j ) / 9000 ) : <NEWLINE> <INDENT> if ( N - i - j ) >= 0 : print ( str ( i ) + <STRING> + str ( j ) + <STRING> + str ( N - i - j ) ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> Y = int ( input ( ) ) <NEWLINE> <NL> a = - 1 <NEWLINE> b = - 1 <NEWLINE> c = - 1 <NEWLINE> for i in range ( 0 , N + 1 ) : <NEWLINE> <INDENT> for j in range ( 0 , N - i + 1 ) : <NEWLINE> <INDENT> if 10000 * i + 5000 * j + 1000 * ( N - i - j ) == Y : <NEWLINE> <INDENT> a = i <NEWLINE> b = j <NEWLINE> c = N - i - j <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( a , b , c ) <NEWLINE>
import sys <NEWLINE> <NL> n , h = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ list ( map ( int , x . split ( ) ) ) for x in sys . stdin . readlines ( ) ] <NEWLINE> a . sort ( reverse = True ) <NEWLINE> b = sorted ( a , key = lambda x : x [ 1 ] , reverse = True ) <NEWLINE> cnt = 0 <NEWLINE> for i in b : <NEWLINE> <INDENT> if i [ 1 ] < a [ 0 ] [ 0 ] : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> cnt += 1 <NEWLINE> h -= i [ 1 ] <NEWLINE> if h <= 0 : <NEWLINE> <INDENT> print ( cnt ) <NEWLINE> <DEDENT> <DEDENT> print ( min ( cnt + - ( - h // a [ 0 ] [ 0 ] ) ) ) <NEWLINE>
N , H = map ( int , input ( ) . split ( ) ) <NEWLINE> AB = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ] <NEWLINE> A , B = zip ( * AB ) <NEWLINE> <NL> a = max ( A ) <NEWLINE> B = [ b for b in B if b > a ] <COMMENT> <NEWLINE> B . sort ( reverse = True ) <NEWLINE> <NL> answer = 0 <NEWLINE> hp = H <NEWLINE> attack_cnt = 0 <NEWLINE> <NL> for b in B : <NEWLINE> <INDENT> if hp <= 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> attack_cnt += 1 <NEWLINE> hp -= b <NEWLINE> <NL> <DEDENT> if hp > 0 : <NEWLINE> <INDENT> attack_cnt += ( hp - 1 ) // a + 1 <NEWLINE> <NL> <DEDENT> print ( attack_cnt ) <NEWLINE>
N , H = map ( int , input ( ) . split ( ) ) <NEWLINE> slash = 0 <NEWLINE> Throw = [ ] <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> slash = max ( slash , a ) <NEWLINE> if b > a : Throw . append ( b ) <NEWLINE> <COMMENT> <NL> <DEDENT> Throw = sorted ( [ th for th in Throw if th > slash ] , reversed = True ) <NEWLINE> dmg , cnt = 0 , 0 <NEWLINE> for throw in Throw : <NEWLINE> <INDENT> if dmg >= H : break <NEWLINE> dmg += throw <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> if dmg < H : <NEWLINE> <INDENT> from math import ceil <NEWLINE> cnt += ceil ( ( H - dmg ) / slash ) <NEWLINE> <DEDENT> print ( cnt ) <NEWLINE>
N , H = map ( int , input ( ) . split ( ) ) <NEWLINE> B = [ ] <NEWLINE> A = 0 <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> A = max ( A , a ) <NEWLINE> B . append ( b ) <NEWLINE> <DEDENT> B = sorted ( reverse = True ) + [ 0 ] <NEWLINE> <NL> i = 0 <NEWLINE> while B [ i ] >= A : <NEWLINE> <INDENT> i += 1 <NEWLINE> <DEDENT> B = B [ : i ] <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( len ( B ) ) : <NEWLINE> <INDENT> H -= B [ i ] <NEWLINE> ans += 1 <NEWLINE> if H <= 0 : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( ans + ( H - 1 ) // A + 1 ) <NEWLINE>
n , H = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ ] <NEWLINE> b = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ai , bi = map ( int , input ( ) . split ( ) ) <NEWLINE> a . append ( ai ) <NEWLINE> b . append ( bi ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> amax = max ( a ) <NEWLINE> b . sort ( reverse = True ) <NEWLINE> <COMMENT> <NL> i = 0 <NEWLINE> while H > 0 : <NEWLINE> <INDENT> if amax < b [ i ] : <NEWLINE> <INDENT> H -= b [ i ] <NEWLINE> ans += 1 <NEWLINE> i += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += H // amax <NEWLINE> if H % amax != 0 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from math import ceil <NEWLINE> n , h = map ( int , input ( ) . split ( ) ) <NEWLINE> data1 , data2 = [ ] , [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> data1 . append ( [ a , b ] ) <NEWLINE> data2 . append ( [ a , b ] ) <NEWLINE> <NL> <DEDENT> data1 = sorted ( data1 , key = lambda x : x [ 0 ] , reverse = True ) <NEWLINE> data2 = sorted ( data2 , key = lambda x : x [ 1 ] , reverse = True ) <NEWLINE> ans = 0 <NEWLINE> while data1 [ 0 ] [ 0 ] < data2 [ 0 ] [ 1 ] : <NEWLINE> <INDENT> h -= data2 [ 0 ] [ 1 ] <NEWLINE> ans += 1 <NEWLINE> del data2 [ 0 ] <NEWLINE> <DEDENT> ans += ceil ( h / data1 [ 0 ] [ 0 ] ) <NEWLINE> print ( ans ) <NEWLINE>
N , H = map ( int , input ( ) . split ( ) ) <NEWLINE> <COMMENT> <NL> A = [ ] <NEWLINE> B = [ ] <NEWLINE> amax = - 1 <NEWLINE> bmax = - 1 <NEWLINE> <NL> for _ in range ( N ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> <COMMENT> <NL> A . append ( a ) <NEWLINE> B . append ( b ) <NEWLINE> <NL> if amax < a : <NEWLINE> <INDENT> amax = a <NEWLINE> <NL> <DEDENT> if bmax < b : <NEWLINE> <INDENT> bmax = b <NEWLINE> <NL> <DEDENT> <DEDENT> if amax >= bmax : <NEWLINE> <INDENT> m = H % amax <NEWLINE> if m != 0 : <NEWLINE> <INDENT> ans = H // amax + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = H // amax <NEWLINE> <NL> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> ans = 0 <NEWLINE> throw_lst = list ( filter ( lambda x : x > amax , B ) ) . sort ( reverse = True ) <NEWLINE> <NL> for tb in throw_lst : <NEWLINE> <INDENT> H -= tb <NEWLINE> ans += 1 <NEWLINE> if H <= 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> m = H % amax <NEWLINE> if m != 0 : <NEWLINE> <INDENT> ans += H // amax + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += H // amax <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
def resolve ( ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> N , H = [ int ( item ) for item in input ( ) . split ( ) ] <NEWLINE> ab = [ [ int ( item ) for item in input ( ) . split ( ) ] for _ in range ( N ) ] <NEWLINE> <NL> a_max = max ( ab , key = lambda x : x [ 0 ] ) <NEWLINE> res = H // a_max <NEWLINE> if H % a_max != 0 : <NEWLINE> <INDENT> res += 1 <NEWLINE> <NL> <DEDENT> temp_attack = res * a_max <NEWLINE> b_delta = [ b - a_max for a , b in ab ] <NEWLINE> <NL> throw_atk_sum = 0 <NEWLINE> throw_num = 0 <NEWLINE> <NL> for item in b_delta : <NEWLINE> <INDENT> if b_delta > 0 : <NEWLINE> <INDENT> throw_atk_sum += item <NEWLINE> throw_num += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if throw_atk_sum < temp_attack : <NEWLINE> <INDENT> reduce_num = throw_atk_sum // a_max <NEWLINE> print ( res - reduce_num ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> res = 0 <NEWLINE> for a , b in ab : <NEWLINE> <INDENT> H -= b <NEWLINE> res += 1 <NEWLINE> if H <= 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> print ( res ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> resolve ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> from fractions import gcd <NEWLINE> from itertools import combinations , permutations , accumulate , product <COMMENT> <NEWLINE> <COMMENT> <NL> from collections import deque , defaultdict , Counter <NEWLINE> import decimal <NEWLINE> import re <NEWLINE> import math <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> import sys <NEWLINE> sys . setrecursionlimit ( 10000000 ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> from sys import stdin <NEWLINE> readline = stdin . readline <NEWLINE> def readInts ( ) : <NEWLINE> <INDENT> return list ( map ( int , readline ( ) . split ( ) ) ) <NEWLINE> <DEDENT> def readTuples ( ) : <NEWLINE> <INDENT> return tuple ( map ( int , readline ( ) . split ( ) ) ) <NEWLINE> <DEDENT> def I ( ) : <NEWLINE> <INDENT> return int ( readline ( ) ) <NEWLINE> <DEDENT> n , h = readInts ( ) <NEWLINE> A = [ 0 ] * n <NEWLINE> B = [ 0 ] * n <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a , b = readInts ( ) <NEWLINE> A [ i ] = a <NEWLINE> B [ i ] = b <NEWLINE> <DEDENT> A = sorted ( A , reverse = True ) <NEWLINE> B = sorted ( B , reverse = True ) <NEWLINE> MAX = a [ 0 ] <NEWLINE> ans = 0 <NEWLINE> for v in b : <NEWLINE> <COMMENT> <NL> <INDENT> if h <= 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if v > MAX : <COMMENT> <NEWLINE> <COMMENT> <NL> <INDENT> ans += 1 <NEWLINE> h -= v <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> if h > 0 : <NEWLINE> <INDENT> ans += ( h + MAX - 1 ) // MAX <COMMENT> <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
a = int ( input ( ) ) <NEWLINE> print ( 24 + ( 24 - a ) <NEWLINE>
m = input ( ) <NEWLINE> print ( 48 - m ) <NEWLINE>
a = input ( ) <NEWLINE> a = 48 - a <NEWLINE> print ( a ) <NEWLINE>
i = ( 48 - i ) <NEWLINE> print ( input ( ) ) <NEWLINE>
a = input ( ) <NEWLINE> b = 24 - a <NEWLINE> c = 24 + b <NEWLINE> print ( c ) <NEWLINE>
a = input ( ) <NEWLINE> print ( 48 - a ) <NEWLINE>
print ( 48 - input ( ) ) <NEWLINE>
M = int ( input ( ) ) <NEWLINE> ans = 48 - M <NEWLINE> printg ( ans ) <NEWLINE>
print ( 48 - int ( input ( ) ) <NEWLINE>
print ( 48 - int ( input ( ) ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( <STRING> if input ( ) [ a ] == <STRING> and input ( ) . count ( <STRING> ) == 1 else <STRING> ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> n = input ( ) <NEWLINE> if n [ a ] == <STRING> : <NEWLINE> <INDENT> n = n . pop ( a ) <NEWLINE> if n . isdecimal ( ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> S = list ( map ( str , input ( ) . split ( - ) ) ) <NEWLINE> ans = <STRING> <NEWLINE> if A == len ( S [ 0 ] ) : <NEWLINE> <INDENT> if B == len ( S [ 1 ] ) : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> S = input ( ) <NEWLINE> print ( <STRING> if re . search ( <STRING> . format ( A , B ) , S ) else <STRING> ) <NEWLINE>
A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> S = input ( ) <NEWLINE> a = <STRING> <NEWLINE> for i in range ( A + B + 2 ) : <NEWLINE> <INDENT> if i != A : <NEWLINE> <INDENT> if S [ i ] != <STRING> : <NEWLINE> <INDENT> a = <STRING> <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if S [ i ] == <STRING> : <NEWLINE> <INDENT> a = <STRING> <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( a ) <NEWLINE>
<INDENT> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> S = input ( ) <NEWLINE> C = <STRING> <NEWLINE> for i in range ( len ( S ) ) : <NEWLINE> <INDENT> if i == A : <NEWLINE> <INDENT> if S [ i ] == <STRING> : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if S [ i ] in C : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> <DEDENT> resolve ( ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> s = input . split ( <STRING> ) <NEWLINE> if len ( s [ 0 ] ) == a and len ( s [ 1 ] ) == b and len ( s ) == 2 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> s = input ( ) <NEWLINE> print ( <STRING> if ( s . count ( <STRING> ) == 1 and s [ a ] == <STRING> and s . count ( ) == a + b + 1 ) else <STRING> ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> s = str ( input ( ) ) <NEWLINE> e = [ <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> if a = i : <NEWLINE> <INDENT> if s [ i ] != <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if s [ i ] not in e : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
def actual ( a , b , s ) : <NEWLINE> <INDENT> if s [ a ] != <STRING> : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <NL> <DEDENT> for i in range ( 0 , a ) : <NEWLINE> <INDENT> if not <STRING> <= s [ i ] <= <STRING> : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> for j in range ( a + 1 , len ( s ) + 1 ) : <NEWLINE> <INDENT> if not <STRING> <= s [ j ] <= <STRING> : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> return <STRING> <NEWLINE> <NL> <NL> <DEDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> s = input ( ) <NEWLINE> <NL> print ( actual ( a , b , s ) ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> s = input ( ) <NEWLINE> flg = 0 <NEWLINE> for i in range ( a + b ) : <NEWLINE> <INDENT> if not ( 0 <= int ( s [ i ] ) <= 9 ) : <NEWLINE> <INDENT> if s [ a ] == <STRING> : <NEWLINE> <INDENT> flg = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> if flg == 1 else <STRING> ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> csf = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n - 1 ) ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if i == n - 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> t = 0 <NEWLINE> for c , s , f in csf [ i : ] : <NEWLINE> <INDENT> t = max ( s , t ) <NEWLINE> t = math . ceil ( t / f ) * f + c <NEWLINE> <COMMENT> <NL> <DEDENT> print ( t ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 10 ) <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> info = [ ] <NEWLINE> for _ in range ( n - 1 ) : <NEWLINE> <INDENT> c , s , f = map ( int , input ( ) . split ( ) ) <NEWLINE> info . append ( [ c , s , f ] ) <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> def func ( i , low ) : <NEWLINE> <INDENT> if i == low : <NEWLINE> <INDENT> return info [ i ] [ 1 ] + info [ i ] [ 0 ] <NEWLINE> <NL> <DEDENT> return func2 ( func ( i - 1 , low ) , info [ i ] [ 2 ] , info [ i ] [ 1 ] ) + info [ i ] [ 0 ] <NEWLINE> <NL> <DEDENT> def func2 ( n , f , s ) : <NEWLINE> <INDENT> if n <= s : <NEWLINE> <INDENT> return s <NEWLINE> <DEDENT> if n % f == 0 : <NEWLINE> <INDENT> return n <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return n // f * f + f <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> if i == n - 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> print ( func ( n - 2 , i ) ) <NEWLINE> <DEDENT>
int ( input ( ) ) <NEWLINE> yo = [ ] <NEWLINE> for _ in range ( n - 1 ) : <NEWLINE> <INDENT> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> yo . append ( a ) <NEWLINE> <NL> <DEDENT> def ans ( x ) : <NEWLINE> <INDENT> if x == n - 1 : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> t = 0 <NEWLINE> for i in range ( x , n - 1 ) : <NEWLINE> <INDENT> if t <= yo [ i ] [ 1 ] : <NEWLINE> <INDENT> t = yo [ i ] [ 1 ] + yo [ i ] [ 0 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s = t - yo [ i ] [ 1 ] <NEWLINE> if s % yo [ i ] [ 2 ] == 0 : <NEWLINE> <INDENT> t = t + yo [ i ] [ 0 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> mo = s % yo [ i ] [ 2 ] <NEWLINE> t = t + yo [ i ] [ 2 ] - mo + yo [ i ] [ 0 ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return t <NEWLINE> <NL> <DEDENT> <DEDENT> for j in range ( n ) : <NEWLINE> <INDENT> print ( ans ( j ) ) <NEWLINE> <NL> <DEDENT>
import numpy as np <NEWLINE> <NL> def seachPrimeNum ( N ) : <NEWLINE> <INDENT> max = int ( np . sqrt ( N ) ) <NEWLINE> seachList = [ i for i in range ( 2 , N + 1 ) ] <NEWLINE> primeNum = [ ] <NEWLINE> while seachList [ 0 ] <= max : <NEWLINE> <INDENT> primeNum . append ( seachList [ 0 ] ) <NEWLINE> tmp = seachList [ 0 ] <NEWLINE> seachList = [ i for i in seachList if i % tmp != 0 ] <NEWLINE> <DEDENT> primeNum . extend ( seachList ) <NEWLINE> return primeNum <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> Q = int ( input ( ) ) <NEWLINE> list = seachPrimeNum ( 100000 ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> c = [ 0 ] * 100001 <NEWLINE> c [ 0 ] = 0 <NEWLINE> for i in range ( 1 , 100001 , 1 ) : <NEWLINE> <COMMENT> <NL> <INDENT> if i in list and ( i + 1 ) / 2 in list : <NEWLINE> <INDENT> c [ i ] = c [ i - 1 ] + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> c [ i ] = c [ i - 1 ] <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> for i in range ( Q ) : <NEWLINE> <INDENT> l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( c [ r ] - c [ l - 1 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> main ( ) <NEWLINE>
import math <NEWLINE> from itertools import accumulate <NEWLINE> <NL> def eratosthenes ( n ) : <NEWLINE> <INDENT> prime_list = [ ] <NEWLINE> num_list = [ i for i in range ( 2 , n + 1 ) ] <NEWLINE> limit = math . sqrt ( n ) <NEWLINE> while True : <NEWLINE> <INDENT> if limit <= num_list [ 0 ] : <NEWLINE> <INDENT> return prime_list + num_list <NEWLINE> <DEDENT> prime_list . append ( num_list [ 0 ] ) <NEWLINE> num_list = [ e for e in num_list if e % num_list [ 0 ] != 0 ] <NEWLINE> <NL> <DEDENT> <DEDENT> er_list = eratosthenes ( 100000 ) <NEWLINE> count = [ ] <NEWLINE> <NL> j = 0 <NEWLINE> for i in range ( er_list [ - 1 ] ) : <NEWLINE> <INDENT> if i == er_list [ j ] : <NEWLINE> <INDENT> j += 1 <NEWLINE> if ( i + 1 ) // 2 in er_list : <NEWLINE> <INDENT> count . append ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> count . append ( 0 ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> count . append ( 0 ) <NEWLINE> <DEDENT> <DEDENT> count = list ( accumulate ( count ) ) <NEWLINE> <NL> Q = int ( input ( ) ) <NEWLINE> for i in range ( Q ) : <NEWLINE> <INDENT> l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( count [ r ] - count [ l - 1 ] ) <NEWLINE> <DEDENT>
def era ( M ) : <NEWLINE> <INDENT> p = [ 1 ] * M <NEWLINE> p [ 0 ] = p [ 1 ] = 0 <NEWLINE> for x in range ( 2 , int ( ~ - M ** .5 ) + 1 ) : <NEWLINE> <INDENT> if p [ x ] : <NEWLINE> <INDENT> for y in range ( x * x , M , x ) : <NEWLINE> <INDENT> p [ y ] = 0 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return p <NEWLINE> <DEDENT> INF = 10 ** 5 + 1 <NEWLINE> E = erat ( INF ) <NEWLINE> Q = [ 0 ] * INF <NEWLINE> from itertools import * <NEWLINE> for i in range ( INF ) : <NEWLINE> <INDENT> q [ i ] = i % 2 * p [ i ] * p [ - ~ i // 2 ] <NEWLINE> <DEDENT> * a , = accumulate ( [ 0 ] + q ) <NEWLINE> for _ in [ None ] * int ( input ( ) ) : <NEWLINE> <INDENT> l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( a [ - ~ r ] - a [ l ] ) <NEWLINE> <DEDENT>
import sys <NEWLINE> from itertools import accumulate <NEWLINE> def input ( ) : return sys . stdin . readline ( ) . strip ( ) <NEWLINE> <NL> <NL> def get_sieve_of_eratosthenes ( n ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if not isinstance ( n , int ) : <NEWLINE> <INDENT> raise TypeError ( <STRING> ) <NEWLINE> <DEDENT> if n < 2 : <NEWLINE> <INDENT> return [ ] <NEWLINE> <DEDENT> prime = [ 2 ] <NEWLINE> limit = int ( n ** 0.5 ) <NEWLINE> data = [ i + 1 for i in range ( 2 , n , 2 ) ] <NEWLINE> while True : <NEWLINE> <INDENT> p = data [ 0 ] <NEWLINE> if limit < p : <NEWLINE> <INDENT> return prime + data <NEWLINE> <DEDENT> prime . append ( p ) <NEWLINE> data = [ e for e in data if e % p != 0 ] <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <INDENT> primes = get_sieve_of_eratosthenes ( 100000 ) <NEWLINE> like = [ 0 ] * 10 ** 5 <NEWLINE> for i in range ( 3 , 10 ** 5 ) : <NEWLINE> <INDENT> if i in primes and ( i + 1 ) // 2 in primes : <NEWLINE> <INDENT> like [ i ] = 1 <NEWLINE> <DEDENT> <DEDENT> like = list ( accumulate ( like ) ) <NEWLINE> <NL> q = int ( input ( ) ) <NEWLINE> for _ in range ( q ) : <NEWLINE> <INDENT> l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> if l < 3 : l = 3 <NEWLINE> if r < 3 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> continue <NEWLINE> <DEDENT> print ( like [ r ] - like [ l - 1 ] ) <NEWLINE> <NL> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import math <NEWLINE> def eratosthenes ( n ) : <NEWLINE> <INDENT> prime_list = [ ] <NEWLINE> num_list = [ i for i in range ( 2 , n + 1 ) ] <NEWLINE> limit = math . sqrt ( n ) <NEWLINE> while True : <NEWLINE> <INDENT> if limit <= num_list [ 0 ] : <NEWLINE> <INDENT> return prime_list + num_list <NEWLINE> <DEDENT> prime_list . append ( num_list [ 0 ] ) <NEWLINE> num_list = [ e for e in num_list if e % num_list [ 0 ] != 0 ] <NEWLINE> <NL> <DEDENT> <DEDENT> ls = eratosthenes ( 100000 ) <NEWLINE> ls2 = [ ] <NEWLINE> count = 0 <NEWLINE> for i in ls : <NEWLINE> <INDENT> ls2 . append ( count ) <NEWLINE> if ( i + 1 ) // 2 in ls : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> Q = int ( input ( ) ) <NEWLINE> for i in range ( Q ) : <NEWLINE> <INDENT> l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( ls2 [ r - 1 ] - ls2 [ l - 1 ] ) <NEWLINE> <DEDENT>
import math <NEWLINE> import numpy as np <NEWLINE> def get_prime ( n ) : <NEWLINE> <INDENT> if n <= 1 : <NEWLINE> <INDENT> return [ ] <NEWLINE> <DEDENT> prime = [ 2 ] <NEWLINE> limit = int ( math . sqrt ( n ) ) <NEWLINE> <NL> data = [ i + 1 for i in range ( 2 , n , 2 ) ] <NEWLINE> while limit > data [ 0 ] : <NEWLINE> <INDENT> prime . append ( data [ 0 ] ) <NEWLINE> data = [ j for j in data if j % data [ 0 ] != 0 ] <NEWLINE> <DEDENT> return prime + data <NEWLINE> <DEDENT> def is_prime ( n ) : <NEWLINE> <INDENT> if n == 1 : return False <NEWLINE> <NL> for k in range ( 2 , int ( math . sqrt ( n ) ) + 1 ) : <NEWLINE> <INDENT> if n % k == 0 : <NEWLINE> <INDENT> return False <NEWLINE> <NL> <DEDENT> <DEDENT> return True <NEWLINE> <DEDENT> n = int ( input ( ) ) <NEWLINE> a = get_prime ( 10 ** 5 + 1 ) <NEWLINE> b = np . array ( [ 0 ] * ( 10 ** 5 + 2 ) ) <NEWLINE> c = 0 <NEWLINE> d = 0 <NEWLINE> add = 0 <NEWLINE> for i in range ( 1 , len ( a ) ) : <NEWLINE> <INDENT> if is_prime ( ( a [ i ] + 1 ) / 2 ) : <NEWLINE> <INDENT> d = a [ i ] <NEWLINE> b [ c : d ] = add <NEWLINE> c = d <NEWLINE> add += 1 <NEWLINE> <DEDENT> <DEDENT> b [ c : ] = add <NEWLINE> b [ 0 : : 2 ] = 0 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( b [ max ( 0 , l [ i ] - 2 ) ] - b [ r [ i ] ] ) <NEWLINE> <DEDENT>
q = int ( input ( ) ) <NEWLINE> l , r = [ 0 ] * q , [ 0 ] * q <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> l [ i ] , r [ i ] = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <DEDENT> mini = min ( min ( l ) , min ( r ) ) <NEWLINE> maxi = max ( max ( l ) , max ( r ) ) <NEWLINE> ans = [ 0 ] * ( maxi + 1 ) <NEWLINE> prime = [ 0 ] * ( maxi + 1 ) <NEWLINE> def judge_prime ( n ) : <NEWLINE> <INDENT> for i in range ( 2 , int ( n ** 0.5 ) + 1 ) : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> return False <NEWLINE> <NL> <DEDENT> <DEDENT> return True if n != 1 else False <NEWLINE> <NL> <DEDENT> for i in range ( ( mini + 1 ) // 2 , maxi + 1 ) : <NEWLINE> <INDENT> prime [ i ] = judge_prime ( i ) <NEWLINE> <NL> <DEDENT> for i in range ( mini , maxi + 1 , 2 ) : <NEWLINE> <INDENT> ans [ i ] = ans [ i - 2 ] + 1 if prime [ i ] and prime [ ( i + 1 ) // 2 ] else ans [ i - 2 <NEWLINE> <DEDENT> for i in range ( q ) : <NEWLINE> <INDENT> print ( ans [ r [ i ] ] - ans [ max ( 0 , l [ i ] - 2 ) ] ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> def isP ( x ) : <NEWLINE> <INDENT> for i in range ( 2 , int ( np . sqrt ( x ) ) + 1 ) : <NEWLINE> <INDENT> if x % i == 0 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> <DEDENT> return True <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> MAX = int ( 10e5 + 1 ) <NEWLINE> P = [ isP ( x ) for x in range ( MAX ) ] <NEWLINE> Ans = [ 0 ] * MAX <NEWLINE> cnt = 0 <NEWLINE> for i in range ( 1 , MAX ) : <NEWLINE> <INDENT> if P [ i ] and P [ ( i + 1 ) // 2 ] : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> Ans [ i ] = cnt <NEWLINE> <NL> <DEDENT> q = int ( input ( ) ) <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( Ans [ r ] - Ans [ l - 1 ] ) <NEWLINE> <DEDENT>
import math <NEWLINE> <NL> Q = int ( input ( ) ) <NEWLINE> lr = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( Q ) ] <NEWLINE> <NL> MAX = 10 ** 5 <NEWLINE> limit = int ( math . sqrt ( MAX ) ) <NEWLINE> primes = [ 2 ] <NEWLINE> table = [ i + 1 for i in range ( 2 , MAX , 2 ) ] <NEWLINE> while limit > table [ 0 ] : <NEWLINE> <INDENT> primes . append ( table [ 0 ] ) <NEWLINE> table = [ j for j in table if j % table [ 0 ] != 0 ] <NEWLINE> <DEDENT> table = primes + table <NEWLINE> <NL> similars = [ ] <NEWLINE> for i in range ( len ( table ) ) : <NEWLINE> <INDENT> n = table [ i ] <NEWLINE> if ( n + 1 ) // 2 in table : <NEWLINE> <INDENT> similars . append ( n ) <NEWLINE> <NL> <DEDENT> <DEDENT> for i in lr : <NEWLINE> <INDENT> l = i [ 0 ] <NEWLINE> r = i [ 1 ] <NEWLINE> cand = [ x for x in similars if l <= x <= r ] <NEWLINE> print ( len ( cand ) ) <NEWLINE> <DEDENT>
from bisect import bisect_left as bsl <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> with open ( 0 ) as f : <NEWLINE> <INDENT> Q = int ( f . readline ( ) ) <NEWLINE> Query = [ tuple ( map ( int , line . split ( ) ) ) for line in f . readlines ( ) ] <NEWLINE> <NL> <DEDENT> p_table = makePtable ( 10 ** 5 ) <NEWLINE> p_set = set ( p_table ) <NEWLINE> Like2017 = [ p for p in p_table if ( p + 1 ) // 2 in p_set ] <NEWLINE> database = [ bsl ( Like2017 , i ) for i in range ( 1 , 10 ** 5 + 1 ) ] <NEWLINE> <NL> for l , r in Query : <NEWLINE> <INDENT> print ( database [ r ] - database [ l - 1 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> def makePtable ( N ) : <NEWLINE> <INDENT> table = list ( range ( 2 , N + 1 ) ) <NEWLINE> result = [ ] <NEWLINE> while len ( table ) != 0 : <NEWLINE> <INDENT> p = table [ 0 ] <NEWLINE> result . append ( p ) <NEWLINE> table = [ x for x in table [ 1 : ] if x % p != 0 ] <NEWLINE> <DEDENT> return result <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE>
A , B , C , D = map ( int , input ( ) . split ( ) ) <NEWLINE> if A + B > C + D : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif A + B > C + D : : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b , c , d = map ( int , input ( ) ) <NEWLINE> if a + b > c + d : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif ( a + b ) == ( c + d ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
A , B , C , D = map ( int , input ( ) ) <NEWLINE> print ( <STRING> if ( A + B ) < ( C + D ) else <STRING> if ( A + B ) == ( C + D ) else <STRING> ) <NEWLINE>
A , B , C , D = map ( int , input ( ) , split ( ) ) <NEWLINE> if A + B > C + D : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif : <NEWLINE> <INDENT> A + B < C + D : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
A = input ( ) <NEWLINE> B = input ( ) <NEWLINE> C = input ( ) <NEWLINE> D = input ( ) <NEWLINE> L = int ( A ) + int ( B ) <NEWLINE> R = int ( C ) + int ( D ) <NEWLINE> if L > R : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif L == R : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
A , B , C , D = [ int ( input ( ) ) for i in range ( 4 ) ] <NEWLINE> if A + B > C + D : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif A + B == C + D : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif A + B < C + D : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
I = input ( ) . split ( ) <NEWLINE> A , B , C , D = [ int ( i ) for i in I ] <NEWLINE> <NL> if int ( A + B > C + D : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif A + B < C + D : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b , c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> if a + b < c + d : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a + b = c + d : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = int ( input ( ) ) <NEWLINE> B = int ( input ( ) ) <NEWLINE> ans_list = [ ] <NEWLINE> <NL> for i in range ( 0 , N + 1 ) : <NEWLINE> <INDENT> if i < 10 : <NEWLINE> <INDENT> if i >= A and i <= B : <NEWLINE> <INDENT> ans_list . append ( i ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> temp = list ( map ( int , str ( i ) ) ) <NEWLINE> temp = temp [ 0 ] + temp [ 1 ] <NEWLINE> if temp >= A and temp <= B : <NEWLINE> <INDENT> ans_list . append ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( sum ( ans_list ) ) <NEWLINE>
n , a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = 0 <NEWLINE> <NL> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> mod = 0 <NEWLINE> while n > 0 : <NEWLINE> <INDENT> mod += ( i % 10 ) <NEWLINE> i //= 10 <NEWLINE> <DEDENT> if mod >= a and mod <= b : <NEWLINE> <INDENT> ans += mod <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N , A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> count = 0 <NEWLINE> <NL> for i in range ( N + 1 ) : <NEWLINE> <INDENT> if A <= i <= B : <NEWLINE> <INDENT> count += sum ( list ( str ( i ) ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
N , A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( len ( N ) ) : <NEWLINE> <INDENT> i = str ( i ) <NEWLINE> count = 0 <NEWLINE> for j in i : <NEWLINE> <INDENT> count += int ( j ) <NEWLINE> <DEDENT> if A <= count and B >= count : <NEWLINE> <INDENT> ans += int ( i ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N , A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> d = sum ( list ( map ( int , list [ str ( i ) ] ) ) ) <NEWLINE> if A <= d <= B : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
def sum ( n ) : <NEWLINE> <INDENT> str_n = str ( n ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( len ( str_n ) ) : <NEWLINE> <INDENT> ans += int ( str_n [ i ] ) <NEWLINE> <DEDENT> return ans <NEWLINE> <NL> <DEDENT> N , A , B = map ( int , [ input ( ) for i in range ( 3 ) ] ) <NEWLINE> <NL> ans1 = 0 <NEWLINE> for i in range ( N + 1 ) : <NEWLINE> <INDENT> if A <= sum ( i ) <= B : <NEWLINE> <INDENT> ans1 += i <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> <DEDENT> print ( ans1 ) <NEWLINE>
n , a , b = map ( int , input ( ) . split ( ) ) ) <NEWLINE> print ( sum ( i for i in range ( 1 + n + 1 ) if a <= sum ( map ( int , str ( i ) ) <= b ) ) ) <NEWLINE>
N , A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> S = sum ( i for i in range ( 1 , N + 1 ) if A <= sum ( list ( map ( int , str ( i ) ) ) <= B ) <NEWLINE> print ( S ) <NEWLINE> <NL>
N , A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> sum = 0 <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> if A <= sum ( list ( map ( int , str ( i ) ) ) ) <= B : <NEWLINE> <INDENT> sum += i <NEWLINE> <NL> <DEDENT> <DEDENT> print ( sum ) <NEWLINE>
n , a , b = ( int ( x ) for x in input ( ) . split ( ) ) <NEWLINE> c = 0 <NEWLINE> def sual ( N , A , B ) : <NEWLINE> <INDENT> l = list ( <STRING> . format ( N ) ) <NEWLINE> s = sum ( l ) <NEWLINE> if A <= s <= B : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> <DEDENT> for x in range ( n ) : <NEWLINE> <INDENT> if sual ( x + 1 , a , b ) : <NEWLINE> <INDENT> c = c + x + 1 <NEWLINE> <DEDENT> <DEDENT> print ( c ) <NEWLINE>
n , a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> total = 0 <NEWLINE> for i in range ( n + 1 ) : <NEWLINE> <INDENT> x = str ( i ) <NEWLINE> y = 0 <NEWLINE> for j in X : <NEWLINE> <INDENT> y += int ( j ) <NEWLINE> <NL> <DEDENT> if a <= y <= b : <NEWLINE> <INDENT> total += i <NEWLINE> <DEDENT> <DEDENT> print ( total ) <NEWLINE>
[ a , b , c ] = [ int ( i ) for i in input ( ) . split ( <STRING> ) ] <NEWLINE> goukei = 0 <NEWLINE> for i in range ( 1 , a + 1 ) : <NEWLINE> <INDENT> kurainowa = 0 <NEWLINE> kisuu = [ int ( k ) for k in list ( str ( i ) ) ] <NEWLINE> for j in range ( 0 , len ( kissu ) - 1 + 1 ) : <NEWLINE> <INDENT> kurainowa = kurainowa + kissu [ j ] <NEWLINE> <DEDENT> if kurainowa < b + 1 and a - 1 < kurainowa : <NEWLINE> <INDENT> goukei = goukei + i <NEWLINE> <DEDENT> <DEDENT> print ( goukei ) <NEWLINE>
N , A , B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> cnt = 0 <NEWLINE> for n range ( 1 , N ) : <NEWLINE> <INDENT> val = 0 <NEWLINE> tmp = N <NEWLINE> while tmp // N > 0 : <NEWLINE> <INDENT> val = tmp % 10 <NEWLINE> tmp = tmp // 10 <NEWLINE> <NL> <DEDENT> if val >= A and val <= B : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
a , b , c = input ( ) . split ( ) <NEWLINE> a = int ( a ) <NEWLINE> b = int ( b ) <NEWLINE> c = int ( c ) <NEWLINE> d = 0 <NEWLINE> for i in range ( 1 , a + 1 ) : <NEWLINE> <INDENT> if b <= ( i // 10000 + ( i // 1000 - ( i // 10000 ) * 10000 ) ) + ( i // 100 - ( i // 1000 ) * 1000 ) ) + ( i // 10 - ( i // 100 ) * 100 ) + ( i // 1 - ( i // 10 ) * 10 ) <= c : <NEWLINE> <INDENT> d = d + i <NEWLINE> <DEDENT> <DEDENT> print ( d ) <NEWLINE>
N , A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> souryou = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> j = i + 1 <NEWLINE> j_str = str ( j ) <NEWLINE> goukei = 0 <NEWLINE> for k in range ( len ( j_str ) ) : <NEWLINE> <INDENT> goukei = goukei + int ( j_str [ k ] ) <NEWLINE> <DEDENT> if goukei >= A & & goukei <= B : <NEWLINE> <INDENT> souryou = souryou + j <NEWLINE> <DEDENT> <DEDENT> print ( str ( souryou ) ) <NEWLINE>
n , a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> sum = 0 <NEWLINE> <NL> for i in range ( n + 1 ) : <NEWLINE> <INDENT> if a <= sum ( map ( int , str ( i ) ) ) <= b : <NEWLINE> <INDENT> count += i <NEWLINE> <NL> <DEDENT> <DEDENT> print ( sum ) <NEWLINE>
<INDENT> n , a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> for num in range ( n ) : <NEWLINE> <INDENT> num += 1 <NEWLINE> num_0 = num <NEWLINE> place_of_10000 = num // 10000 <NEWLINE> num -= 10000 * place_of_10000 <NEWLINE> place_of_1000 = num // 1000 <NEWLINE> num -= 1000 * place_of_1000 <NEWLINE> place_of_100 = num // 100 <NEWLINE> num -= 100 * place_of_100 <NEWLINE> place_of_10 = num // 10 <NEWLINE> num -= 10 * place_of_10 <NEWLINE> <NL> tmp = place_of_10000 + place_of_1000 + place_of_100 + place_of_10 + num <NEWLINE> if a <= tmp and tmp <= b : <NEWLINE> <INDENT> ans += num_0 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
N , A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> for n in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> if A <= sum ( n ) <= B : <NEWLINE> <INDENT> ans += n <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N , A , B = map ( int , [ input ( ) for i in range ( 3 ) ] ) <NEWLINE> s = 0 <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> k = 0 <NEWLINE> j = i <NEWLINE> while ( j > 0 ) : <NEWLINE> <INDENT> k += j % 10 <NEWLINE> j = j // 10 <NEWLINE> <DEDENT> if ( A <= k and k <= B ) : <NEWLINE> <INDENT> s = s + i <NEWLINE> <DEDENT> <DEDENT> print ( s ) <NEWLINE>
n , a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if a <= sum ( [ int ( c ) for c in str ( i ) ] ) = > b : <NEWLINE> <INDENT> ans += i <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n , a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> n = 0 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> result = sum ( list ( map ( int , str ( i ) ) ) ) <NEWLINE> if result >= a and result <= b : <NEWLINE> <INDENT> ans += i <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N , A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> sum = 0 <NEWLINE> for num in range ( N + 1 ) : <NEWLINE> <INDENT> if A <= sum ( [ int ( x ) for x in str ( num ) ] ) <= B : <NEWLINE> <INDENT> sum += num <NEWLINE> <DEDENT> <DEDENT> print ( sum ) <NEWLINE>
n , a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> cnt = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> n_list = list ( int ( i ) ) <NEWLINE> if sum ( n_list ) >= a and sum ( n_list ) <= b : <NEWLINE> <INDENT> cnt += i <NEWLINE> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
n , a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> ii = list ( i ) <NEWLINE> ii = sum ( ii ) <NEWLINE> if ii in range ( a , b + 1 ) : <NEWLINE> <INDENT> ans += i <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = int ( input ( ) ) <NEWLINE> B = int ( input ( ) ) <NEWLINE> <NL> sum = 0 <NEWLINE> for i in range ( N + 1 ) : <NEWLINE> <INDENT> nums = list ( str ( i ) ) <NEWLINE> tmp = 0 <NEWLINE> for j in nums : <NEWLINE> <INDENT> tmp = tmp + int ( j ) <NEWLINE> <DEDENT> if A <= tmp : <NEWLINE> <INDENT> if tmp <= B : <NEWLINE> <INDENT> sum = sum + i <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( sum ) <NEWLINE>
import math <NEWLINE> X , Y = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( int ( math . floor ( Y / X , 2 ) + 1 ) ) <NEWLINE>
import math <NEWLINE> <NL> x = input ( ) <NEWLINE> y = input ( ) <NEWLINE> <NL> <NL> cnt = 0 <NEWLINE> <NL> while x <= y : <NEWLINE> <INDENT> x *= 2 <NEWLINE> cnt += 1 <NEWLINE> <NL> <DEDENT> print ( cnt ) <NEWLINE>
s = list ( map ( int , list ( input ( ) ) ) ) <NEWLINE> ans = n <NEWLINE> for i in range ( len ( s ) - 1 ) : <NEWLINE> <INDENT> if s [ i ] != s [ i + 1 ] : <NEWLINE> <INDENT> ans = min ( ans , max ( i + 1 , len ( s ) - i - 1 ) ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
S = input ( ) <NEWLINE> l = len ( S ) <NEWLINE> if l % 2 == 1 : <NEWLINE> <INDENT> m = S [ l // 2 ] <NEWLINE> c = 1 <NEWLINE> for i in range l // 2 : <NEWLINE> <INDENT> if S [ l // 2 - i - 1 ] == m and S [ l // 2 + i + 1 ] == m : <NEWLINE> <INDENT> c += 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> ans = c + ( l - c ) // 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> m1 = S [ l // 2 - 1 ] <NEWLINE> m2 = S [ l // 2 ] <NEWLINE> c = 0 <NEWLINE> if m1 == m2 : <NEWLINE> <INDENT> c = 2 <NEWLINE> for i in range l // 2 - 1 : <NEWLINE> if S [ l // 2 - i - 2 ] == m1 and S [ l // 2 + i + 1 ] == m1 : <NEWLINE> <INDENT> c += 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> ans = c + ( l - c ) // 2 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
S = input ( ) <NEWLINE> <NL> a = n <NEWLINE> n = len ( S ) <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> if S [ i ] != S [ i + 1 ] : <NEWLINE> <INDENT> a = min ( a , max ( i + 1 , n - i + 1 ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( a ) <NEWLINE>
<COMMENT> <NL> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> X , Y = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = 0 <NEWLINE> while ( X <= Y ) { <NEWLINE> <INDENT> x *= 2 <NEWLINE> ans += 1 <NEWLINE> <DEDENT> } <NEWLINE> print ( ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> multi = math . ceil ( ( a + b ) / 2 ) <NEWLINE> <NL> print ( str ( multi ) ) <NEWLINE>
x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> import math <NEWLINE> print ( math . celi ( ( x + y ) / 2 ) ) <NEWLINE>
a , b = map ( int , input ( ) ) <NEWLINE> x = ( a + b ) // 2 <NEWLINE> print ( x ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> import math <NEWLINE> print ( math . ceil ( a + b / 2 ) <NEWLINE>
a , b = map ( int , input ( ) . spoit ( ) ) <NEWLINE> print ( ( a + b + 1 ) // 2 ) <NEWLINE>
a = int ( input ( ) ) <NEWLINE> b = int ( input ( ) ) <NEWLINE> <NL> x = ( a + b ) / 2 <NEWLINE> if x % 1 == 0 : <NEWLINE> <INDENT> print ( int ( x ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( int ( x ) + 1 ) <NEWLINE> <DEDENT>
import math <NEWLINE> print ( math . ceil ( ( int ( input ( ) ) + int ( input ( ) ) ) / 2 ) ) <NEWLINE>
N , A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> print ( min ( N * A , B ) ) <NEWLINE>
a , b = map ( int , input ( ) ) <NEWLINE> import math <NEWLINE> print ( math . ceil ( ( a + b ) / 2 ) ) <NEWLINE>
a , b = int ( input ( ) . split ( ) ) <NEWLINE> <NL> x = ( a + b ) / 2 <NEWLINE> <NL> if x == int ( x ) : <NEWLINE> <INDENT> print ( x ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> x += 1 <NEWLINE> print ( int ( x ) ) <NEWLINE> <DEDENT>
from math import ceil <NEWLINE> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( ceil ( ( a + b ) / 2 ) <NEWLINE>
import math <NEWLINE> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> mean = ( a + b ) / 2.0 <NEWLINE> print ( int ( math . ceil ( mean ) ) <NEWLINE>
a , b = map ( int , input ( ) split ( ) ) <NEWLINE> print ( ( a + b ) // 2 ) <NEWLINE>
a , b = ( int ( x ) for x in input ( ) . split ( ) ) <NEWLINE> s = ( a + b ) % 2 <NEWLINE> t = ( a + b ) / 2 <NEWLINE> if s == 0 : <NEWLINE> <INDENT> print ( t ) <NEWLINE> else : <NEWLINE> print ( t + 0.5 ) <NEWLINE> <DEDENT>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = math . ceil ( ( a + b ) / 2 ) <NEWLINE> print ( ans ) <NEWLINE> <NL>
<NL> import math <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) ) <NEWLINE> print ( math . floor ( ( x + y ) / 2 ) ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( ( a + b + 1 ) / 2 ) ) <NEWLINE>
a <NEWLINE>
import math <NEWLINE> a , b = input ( ) . split ( ) <NEWLINE> print ( math . ceil ( a + b / 2 ) ) <NEWLINE>
import math <NEWLINE> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( math . celi ( ( a + b ) / 2 ) ) ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if ( a + b ) % == 0 : <NEWLINE> <INDENT> print ( ( a + b ) // 2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ( ( a + b ) // 2 ) + 1 ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> ab = input ( ) . split ( <STRING> ) <NEWLINE> print ( np . round ( np . mean ( int ( ab [ 0 ] ) , int ( ab [ 1 ] ) ) ) ) <NEWLINE>
import math <NEWLINE> num1 = int ( input ( ) ) <NEWLINE> num2 = int ( input ( ) ) <NEWLINE> X = ( num1 + num2 ) / 2 <NEWLINE> print ( math . ceil ( X ) ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if ( a + b ) % 2 == 0 : <NEWLINE> <INDENT> print ( round ( ( a + b ) / 2 ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( round ( ( a + b + 1 ) / 2 ) <NEWLINE> <DEDENT>
import math <NEWLINE> a , b = map ( int , input ( ) ) <NEWLINE> print ( math . ceil ( ( a + b ) / 2 ) ) <NEWLINE>
s = list ( input ( ) ) <NEWLINE> t = list ( input ( ) ) <NEWLINE> s1 = s . sort ( ) <NEWLINE> t1 = t . sort ( ) <NEWLINE> if s1 < t1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> t = input ( ) <NEWLINE> <NL> u = sorted ( [ s ] ) <NEWLINE> v = sorted ( [ t ] , reversed = True ) <NEWLINE> <NL> print ( <STRING> if u < v else <STRING> ) <NEWLINE>
S = list ( input ( ) ) <NEWLINE> T = list ( input ( ) ) <NEWLINE> s = [ ] <NEWLINE> t = [ ] <NEWLINE> for i in S : <NEWLINE> <INDENT> s . append ( int ( ord ( i ) ) ) <NEWLINE> <DEDENT> for i in T : <NEWLINE> <INDENT> t . append ( int ( ord ( i ) ) ) <NEWLINE> <NL> <DEDENT> s . sort ( reverse = True ) <NEWLINE> t . sort ( reverse = True ) <NEWLINE> for i in range ( max ( len ( s ) , len ( t ) ) ) : <NEWLINE> <INDENT> if t [ i ] > s [ i ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( 0 ) <NEWLINE> <DEDENT> elif s [ i ] != t [ i ] : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> if len ( t ) > len ( s ) : <NEWLINE> <INDENT> for i in s : <NEWLINE> <INDENT> if i == len ( s ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif i not in t : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> t . remove ( i ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( 0 ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> <NL>
x = sorted ( list ( input ( ) ) ) <NEWLINE> y = sorted ( list ( input ( ) ) , reverse = true ) <NEWLINE> a = <STRING> <NEWLINE> b = <STRING> <NEWLINE> for ( p , q ) in zip x , y : <NEWLINE> <INDENT> a += p <NEWLINE> b += q <NEWLINE> <DEDENT> if a < b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <NL> <NL> <DEDENT>
s = list ( input ( ) ) <NEWLINE> t = list ( input ( ) ) <NEWLINE> for i in s : <NEWLINE> <INDENT> for j in t : <NEWLINE> <INDENT> if ord ( i ) < ord ( j ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> count = 0 <NEWLINE> if len ( s ) < len ( t ) : <NEWLINE> <INDENT> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> if s [ i ] = t [ i ] : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> if count = len ( s ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> <NL> s = list ( input ( ) ) <NEWLINE> t = list ( input ( ) ) <NEWLINE> for i in s : <NEWLINE> <INDENT> for j in t : <NEWLINE> <INDENT> if ord ( i ) < ord ( j ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> S = sorted ( s ) <NEWLINE> T = sorted ( t ) <NEWLINE> count = 0 <NEWLINE> if len ( s ) < len ( t ) : <NEWLINE> <INDENT> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> if S [ i ] = S [ i ] : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> if count = len ( s ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> <NL>
a = [ input ( ) for i in range ( 2 ) ] <NEWLINE> <NL> sp = <STRING> . join ( sorted ( list ( a [ 0 ] ) ) ) <NEWLINE> tmp = list ( a [ 1 ] ) <NEWLINE> tmp . sort ( ) . reverse ( ) <NEWLINE> tp = <STRING> . join ( tmp ) <NEWLINE> <NL> if sp < tp : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s = input ( ) . sorted ( ) <NEWLINE> t = input ( ) . sorted ( reverse = True ) <NEWLINE> if ( new_s < new_t ) : print ( <STRING> ) <NEWLINE> else : print ( <STRING> ) <NEWLINE>
import sys <NEWLINE> from string import ascii_lowercase as alph <NEWLINE> from itertools import zip_longest <NEWLINE> <NL> s , t = [ list ( l ) for l in sys . stdin . read ( ) . split ( ) ] <NEWLINE> d = dict ( ( w , x ) for w , x in zip ( alph , range ( 26 ) ) ) <NEWLINE> d [ <STRING> ] = - 1 <NEWLINE> s . sort ( key = d . get ) <NEWLINE> t . sort ( key = d . get , reverse = True ) <NEWLINE> for x , y in zip_longest ( s , t , fillvalue = <STRING> ) : <NEWLINE> <INDENT> if d [ x ] < d [ y ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> elif d [ x ] > d [ y ] <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> t = input ( ) <NEWLINE> s = s . sort ( ) <NEWLINE> t = t . sort ( reverse = True ) <NEWLINE> if s < t : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import sys <NEWLINE> import math <NEWLINE> import itertools <NEWLINE> import bisect <NEWLINE> from copy import copy <NEWLINE> from collections import deque , Counter <NEWLINE> from decimal import Decimal <NEWLINE> def s ( ) : return input ( ) <NEWLINE> def i ( ) : return int ( input ( ) ) <NEWLINE> def S ( ) : return input ( ) . split ( ) <NEWLINE> def I ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def X ( ) : return list ( input ( ) ) <NEWLINE> def L ( ) : return list ( input ( ) . split ( ) ) <NEWLINE> def l ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> def lcm ( a , b ) : return a * b // math . gcd ( a , b ) <NEWLINE> def gcd ( * numbers ) : reduce ( math . gcd , numbers ) <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> count = 0 <NEWLINE> ans = 0 <NEWLINE> <NL> a = s ( ) <NEWLINE> t = s ( ) <NEWLINE> <NL> a . sort ( ) <NEWLINE> y = <STRING> . join ( a ) <NEWLINE> t = sorted ( t , reverse = True ) <NEWLINE> x = <STRING> . join ( t ) <NEWLINE> if y < x : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a = input ( ) <NEWLINE> b = input ( ) <NEWLINE> a = list ( a ) <NEWLINE> b = list ( b ) <NEWLINE> <NL> if ( a . sort ( reverse = True ) < b . sort ( ) ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
S = sorted ( input ( ) ) <NEWLINE> T = sorted ( input ( ) ) <NEWLINE> <NL> print ( <STRING> if ( S < t ) else <STRING> ) <NEWLINE> <NL>
s , t = map ( str , input ( ) . split ( ) ) <NEWLINE> s_array = [ ] <NEWLINE> t_array = [ ] <NEWLINE> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> s_array . append ( s [ i ] ) <NEWLINE> <DEDENT> for i in range ( len ( t ) ) : <NEWLINE> <INDENT> t_array . append ( t [ i ] ) <NEWLINE> <NL> <DEDENT> s_array = sorted ( s_array ) <NEWLINE> <NL> t_array = sorted ( t_array , reverse = True ) <NEWLINE> for i in range ( min ( [ len ( s_array ) , len ( t_array ) ] ) ) : <NEWLINE> <INDENT> if s_array [ i ] < t_array [ i ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> elif s_array [ i ] > t_array [ i ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
s = input ( ) <NEWLINE> t = input ( ) <NEWLINE> s . sort ( ) <NEWLINE> t . sort ( reverse = True ) <NEWLINE> for i in range ( min ( len ( s ) , len ( t ) ) ) : <NEWLINE> <INDENT> if ord ( s [ i ] ) == ord ( t [ i ] ) : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> elif ord ( s [ i ] ) < ord ( t [ i ] ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s = list ( list ( i for i in input ( ) ) . sort ( ) ) <NEWLINE> t = list ( list ( i for i in input ( ) ) . sort ( ) ( reverse = True ) ) <NEWLINE> A = True <NEWLINE> for i in range ( min ( len ( s ) , len ( t ) ) ) : <NEWLINE> <INDENT> if s [ i ] < t [ i ] : <NEWLINE> <INDENT> A = True <NEWLINE> <DEDENT> elif s [ i ] > t [ i ] : <NEWLINE> <INDENT> A = False <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if len ( s ) < len ( t ) : A = True <NEWLINE> else : A = False <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> if A else <STRING> ) <NEWLINE>
s = input ( ) <NEWLINE> t = input ( ) <NEWLINE> ListS = list ( s ) <NEWLINE> ListT = list ( t ) <NEWLINE> ListS . sort ( ) <NEWLINE> ListT . sort ( reverse = True ) <NEWLINE> S = <STRING> <NEWLINE> T = <STRING> <NEWLINE> for i in range ( len ( ListS ) ) : <NEWLINE> <INDENT> S += ListS [ i ] <NEWLINE> <DEDENT> for i in range ( len ( ListT ) ) : <NEWLINE> <INDENT> T += ListT [ i ] <NEWLINE> <DEDENT> if S == T : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> List . append ( S ) <NEWLINE> List . append ( T ) <NEWLINE> List . sort ( ) <NEWLINE> if List [ 0 ] == S : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT>
N = input ( ) <NEWLINE> A = sorted ( [ int ( x ) for x in input ( ) . split ( ) ] ) <NEWLINE> import bisect as bs <NEWLINE> ans = 0 <NEWLINE> f = lambda X , x : bs . bisect_right ( X , x ) - bs . bisect_left ( X . x ) <NEWLINE> for a in set ( A ) : <NEWLINE> <INDENT> cnt = f ( A , a ) <NEWLINE> if cnt < a : <NEWLINE> <INDENT> ans += cnt <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += cnt - a <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> alist = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> from collections import Counter <NEWLINE> adic = Counter ( alist ) <NEWLINE> count = 0 <NEWLINE> for k , v in adic : <NEWLINE> <INDENT> if int ( k ) <= v : <NEWLINE> <INDENT> count += ( v - int ( k ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> count += v <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> * A , = map ( int , input ( ) . split ( ) ) <NEWLINE> dic = { } <NEWLINE> for a in A : <NEWLINE> <INDENT> if a in dic : <NEWLINE> <INDENT> dic [ a ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dic [ a ] = 1 <NEWLINE> <DEDENT> <DEDENT> for k , v in dic . items ( ) : <NEWLINE> <INDENT> if k == v : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> elif k > v : <NEWLINE> <INDENT> ans += v <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += v - k <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import numpy as np <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> <NL> def fft_convolve ( f , g ) : <NEWLINE> <INDENT> Lf , Lg = f . shape [ - 1 ] , g . shape [ - 1 ] <NEWLINE> L = Lf + Lg - 1 <NEWLINE> fft_len = 1 << L . bit_length ( ) <NEWLINE> fh , fl = f >> 15 , f & ( 1 << 15 ) - 1 <NEWLINE> gh , gl = g >> 15 , g & ( 1 << 15 ) - 1 <NEWLINE> def conv ( f , g ) : <NEWLINE> <INDENT> Ff = np . fft . rfft ( f , fft_len ) <NEWLINE> Fg = np . fft . rfft ( g , fft_len ) <NEWLINE> h = np . fft . irfft ( Ff * Fg ) <NEWLINE> return np . rint ( h ) [ ... , : L ] . astype ( np . int64 ) % MOD <NEWLINE> <DEDENT> x = conv ( fl , gl ) <NEWLINE> z = conv ( fh , gh ) <NEWLINE> y = conv ( fl + fh , gl + gh ) - x - z <NEWLINE> return ( x + ( y << 15 ) + ( z << 30 ) ) % MOD <NEWLINE> <NL> <DEDENT> s = input ( ) <NEWLINE> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> Rob = list ( s . split ( <STRING> ) ) <NEWLINE> <NL> X = [ len ( r ) for r in Rob [ : : 2 ] ] <NEWLINE> Y = [ len ( r ) for r in Rob [ 1 : : 2 ] ] <NEWLINE> <NL> def solve ( ) : <NEWLINE> <INDENT> y = abs ( y ) <NEWLINE> Xst = X [ 0 ] <NEWLINE> X = X [ 1 : ] <NEWLINE> if abs ( x - Xst ) <= sum ( X ) and y <= sum ( Y ) : <NEWLINE> <INDENT> f = np . array ( [ 1 ] , np . int64 ) <NEWLINE> for i in X : <NEWLINE> <INDENT> L = [ 0 ] * ( 2 * i + 1 ) <NEWLINE> L [ 0 ] , L [ - 1 ] = 1 , 1 <NEWLINE> f = np . convolve ( f , np . array ( L , np . int64 ) ) <NEWLINE> <DEDENT> FlagX = f [ abs ( x - Xst ) + sum ( X ) ] <NEWLINE> g = np . array ( [ 1 ] , np . int64 ) <NEWLINE> for j in Y : <NEWLINE> <INDENT> L = [ 0 ] * ( 2 * j + 1 ) <NEWLINE> L [ 0 ] , L [ - 1 ] = 1 , 1 <NEWLINE> g = np . convolve ( g , np . array ( L , np . int64 ) ) <NEWLINE> <DEDENT> FlagY = g [ y + sum ( Y ) ] <NEWLINE> if FlagX and FlagY : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> solve ( ) <NEWLINE>
a = input ( ) <NEWLINE> print ( a . count ( 1 ) ) <NEWLINE>
n = input ( ) <NEWLINE> def sum ( n ) : <NEWLINE> <INDENT> s = str ( n ) <NEWLINE> a = list ( map ( int , s ) ) <NEWLINE> return sum ( a ) <NEWLINE> <NL> <DEDENT> print ( sum ( n ) ) <NEWLINE>
S = map ( int , input ( ) . split ( ) ) <NEWLINE> c = 0 <NEWLINE> <NL> if S % 10 == 1 : <NEWLINE> <INDENT> c += 1 <NEWLINE> <DEDENT> if S // 100 == 1 : <NEWLINE> <INDENT> c += 1 <NEWLINE> <DEDENT> if ( S // 10 ) % 10 == 1 : <NEWLINE> <INDENT> c += 1 <NEWLINE> <DEDENT> print ( c ) <NEWLINE>
a = input ( ) <NEWLINE> print ( a . count ( 1 ) ) <NEWLINE>
str1 = input ( ) <NEWLINE> s_list = list ( str1 ) <NEWLINE> str_len = len ( str1 ) <NEWLINE> n = 0 <NEWLINE> for i in range ( str_len ) : <NEWLINE> <INDENT> if == s_list [ i ] : <NEWLINE> <INDENT> n = n + 1 <NEWLINE> <DEDENT> <DEDENT> print ( n ) <NEWLINE>
s = list ( input ( ) ) <NEWLINE> from collections import Counter <NEWLINE> s_count = s . Counter ( ) <NEWLINE> print ( s_count [ <STRING> ] ) <NEWLINE>
s = input ( ) <NEWLINE> print ( s . sount ( <STRING> ) ) <NEWLINE>
num_list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> count = 0 <NEWLINE> <NL> for i in range ( 3 ) : <NEWLINE> <INDENT> count += num_list [ i ] <NEWLINE> <NL> <DEDENT> print ( count ) <NEWLINE>
s = input ( ) <NEWLINE> ans = 0 <NEWLINE> if s = 1 : <NEWLINE> <INDENT> ans += <STRING> <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
s = string ( input ( ) ) <NEWLINE> counter = 0 <NEWLINE> <NL> for i in range ( 3 ) : <NEWLINE> <INDENT> print ( s [ i ] ) <NEWLINE> if s [ i ] == 1 : <NEWLINE> <INDENT> counter += 1 <NEWLINE> <DEDENT> <DEDENT> print ( counter ) <NEWLINE>
a = list ( input ( ) ) <NEWLINE> count = 0 <NEWLINE> for i in a : <NEWLINE> <INDENT> if a [ i ] == 1 : count += 1 <NEWLINE> <DEDENT> print ( count ) <NEWLINE>
from sys import stdin <NEWLINE> a = [ int ( x ) for x in list ( stdin . readline ( ) ) ] <NEWLINE> y = 0 <NEWLINE> <NL> for x in a : <NEWLINE> <INDENT> if x == 1 : <NEWLINE> <INDENT> y += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( y ) <NEWLINE>
a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> print ( a + b + c ) <NEWLINE>
nums = input ( ) <NEWLINE> print ( nums . count ( 1 ) ) <NEWLINE>
a = input ( ) <NEWLINE> count = 0 <NEWLINE> <NL> count += 1 if a [ 0 ] == 1 <NEWLINE> count += 1 if a [ 1 ] == 1 <NEWLINE> count += 2 if a [ 2 ] == 1 <NEWLINE> print ( count ) <NEWLINE>
s = map ( input ( ) ) <NEWLINE> count = 0 <NEWLINE> if s [ 0 ] == <STRING> : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> if s [ 1 ] == <STRING> : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> if s [ 2 ] == <STRING> : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> print ( count ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> count = 0 <NEWLINE> exist_odd = False <NEWLINE> <NL> while exist_odd == False : <NEWLINE> <INDENT> for i in range ( n ) : <NEWLINE> <INDENT> if a [ i ] % 2 != 0 : <NEWLINE> <INDENT> exist_odd = True <NEWLINE> if n != i : <NEWLINE> <INDENT> count -= 1 <NEWLINE> <DEDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a [ i ] = a [ i ] / 2 <NEWLINE> <DEDENT> <DEDENT> count += 1 <NEWLINE> <DEDENT> print ( count ) <NEWLINE>
s = input ( ) <NEWLINE> ans = 0 <NEWLINE> ans += [ int ( i ) for i in s ] <NEWLINE> print ( ans ) <NEWLINE>
<COMMENT> <NL> lol = input ( <STRING> ) <NEWLINE> S1 = int ( lol [ 0 : 0 ] ) <NEWLINE> S2 = int ( lol [ 1 : 1 ] ) <NEWLINE> S3 = int ( lol [ 2 : 2 ] ) <NEWLINE> Ss = [ S1 , S2 , S3 ] <NEWLINE> cnt = 0 <NEWLINE> Ss . sort ( ) <NEWLINE> for 1 in Ss : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> del Ss [ 0 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( cnt ) <NEWLINE> break <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> print ( s . count ( 1 ) ) <NEWLINE>
print ( input ( ) , count ( <STRING> ) ) <NEWLINE>
print ( input ( ) . count ( 1 ) ) <NEWLINE>
for int ( j ) in input ( ) : <NEWLINE> <INDENT> if j == 1 : <NEWLINE> <INDENT> Count += 1 <NEWLINE> <DEDENT> <DEDENT> print ( Count ) <NEWLINE>
<COMMENT> <NL> s = input ( <STRING> ) <NEWLINE> i = 0 <NEWLINE> <COMMENT> <NL> <INDENT> for j in range ( 3 ) : <NEWLINE> <COMMENT> <NL> <INDENT> if s [ j ] == <STRING> : <NEWLINE> <INDENT> i += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> i += 0 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( i ) <NEWLINE>
print ( intput ( ) . count ( <STRING> ) ) <NEWLINE>
a , b , c = ( int ( x ) for x in input ( ) . split ( ) ) <NEWLINE> <NL> print ( a + b + c ) <NEWLINE>
inp = map ( str , input ( ) ) <NEWLINE> <NL> print ( inp . count ( 1 ) ) <NEWLINE> <NL>
S = list ( input ( ) ) <NEWLINE> print ( sum ( S ) ) <NEWLINE>
print ( input ( ) . count ( 1 ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> while all ( i % 2 == 0 for i in a ) : <NEWLINE> <INDENT> ans += 1 <NEWLINE> for j in range ( n ) : <NEWLINE> <INDENT> a [ j ] //= 2 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> a = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> b = a <NEWLINE> t = - 1 <NEWLINE> s = 0 <NEWLINE> while s == 0 : <NEWLINE> <INDENT> for i in range ( N ) : <NEWLINE> <INDENT> if b [ i ] % 2 != 0 : <NEWLINE> <INDENT> s = 1 <NEWLINE> <DEDENT> b [ i ] = b [ i ] / 2 <NEWLINE> <DEDENT> t = t + 1 <NEWLINE> <DEDENT> print ( t ) <NEWLINE>
str ( s ) = input ( ) <NEWLINE> count = 0 <NEWLINE> for v in range ( 1 , 4 ) : <NEWLINE> <INDENT> if 1 in s [ v ] : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
A , B , C = int ( input ( ) ) <NEWLINE> print ( int ( A ) + int ( B ) + int ( C ) ) <NEWLINE>
a = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( a . count ( 1 ) ) <NEWLINE>
s = input ( ) <NEWLINE> cout = 0 <NEWLINE> for a in s : <NEWLINE> <INDENT> if a == <STRING> <NEWLINE> <INDENT> cout += 1 <NEWLINE> <DEDENT> <DEDENT> print ( cout ) <NEWLINE>
x = str ( input ( ) ) <NEWLINE> a = int ( x [ 0 ] ) <NEWLINE> b = int ( x [ 1 ] 9 <NEWLINE> c = int ( x [ 2 ] ) <NEWLINE> <NL> <NL> print ( a + b + c ) <NEWLINE>
print ( count ( <STRING> ) ) <NEWLINE>
a = input ( ) <NEWLINE> print ( a . count ( <STRING> ) <NEWLINE>
a , b , c = input ( ) . split ( ) <NEWLINE> <NL> i = 0 <NEWLINE> if a == 1 : <NEWLINE> <INDENT> i + + <NEWLINE> <DEDENT> if b == 1 : <NEWLINE> <INDENT> i + + <NEWLINE> <DEDENT> if c == 1 : <NEWLINE> <INDENT> i + + <NEWLINE> <DEDENT> print ( i ) <NEWLINE>
s = input ( ) <NEWLINE> a , b , c = int ( s [ 0 ] ) , int ( s [ 1 ] ) , int ( s [ 2 ] ) <NEWLINE> count = 0 <NEWLINE> if a == 1 : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> if b == 1 : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> if C == 1 : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> print ( count ) <NEWLINE>
x = input ( ) <NEWLINE> X = list ( <STRING> . format ( x ) ) <NEWLINE> A = sum ( X ) <NEWLINE> print ( A ) <NEWLINE>
marbles = input ( ) <NEWLINE> num = marbles . count ( 1 ) <NEWLINE> print ( num ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c = 0 <NEWLINE> while True : <NEWLINE> <INDENT> for i in range ( N ) : <NEWLINE> <INDENT> if A [ i ] % 2 != 0 : <NEWLINE> <INDENT> print ( c ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> A [ i ] = A [ i ] / 2 <NEWLINE> <DEDENT> <DEDENT> c = c + 1 <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> while 1 : <NEWLINE> <INDENT> for i in range ( n ) : <NEWLINE> <INDENT> if a [ i ] % 2 : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> a [ i ] //= 2 <NEWLINE> <DEDENT> ans += 1 <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> if s = <STRING> : <NEWLINE> <INDENT> print ( 3 ) <NEWLINE> <DEDENT> elif s = <STRING> or <STRING> or <STRING> : <NEWLINE> <INDENT> print ( 2 ) <NEWLINE> <DEDENT> elif s = <STRING> or <STRING> or <STRING> : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else s = <STRING> : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> ans = s . count ( 1 ) <NEWLINE> print ( ans ) <NEWLINE>
s = input ( ) <NEWLINE> for x in s : <NEWLINE> <INDENT> if x != <STRING> : <NEWLINE> <INDENT> count = count + 1 <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
s = int ( input ( ) ) <NEWLINE> a = s . count ( 1 ) <NEWLINE> print ( a ) <NEWLINE>
s = input ( ) <NEWLINE> count = 0 <NEWLINE> for i for range ( 3 ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
S1 , S2 , S3 = map ( str , input ( ) . split ( ) ) <NEWLINE> input_sum = str ( S1 + S2 + S3 ) <NEWLINE> <NL> print ( input_sum . count ( <STRING> ) ) <NEWLINE>
s = input ( ) <NEWLINE> print ( s . count ( <STRING> ) <NEWLINE>
s = input ( ) <NEWLINE> print ( count ( <STRING> ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> print ( n . count ( 1 ) ) <NEWLINE>
import sys <NEWLINE> <NL> args = sys . argv <NEWLINE> <NL> <COMMENT> <NL> <NL> def f ( arg_list ) : <NEWLINE> <INDENT> even_arg_list = [ ] <NEWLINE> for i in arg_list : <NEWLINE> <INDENT> if i % 2 == 0 : <NEWLINE> <INDENT> even_arg_list . append ( i / 2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> <DEDENT> return even_arg_list <NEWLINE> <NL> <NL> <DEDENT> counter = 0 <NEWLINE> _list = map ( lambda x : int ( x ) , args [ 1 : ] ) <NEWLINE> while True : <NEWLINE> <INDENT> _list = f ( _list ) <NEWLINE> if _list == False : <NEWLINE> <INDENT> print ( counter ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> counter += 1 <NEWLINE> <COMMENT> <NL> <DEDENT>
N = input ( ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> def GCD ( a , b ) : <NEWLINE> <INDENT> if a < b : <NEWLINE> <INDENT> a , b = b , a <NEWLINE> <DEDENT> while a % b != 0 : <NEWLINE> <INDENT> a , b = b , a % b <NEWLINE> <DEDENT> print ( b ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> for i in range ( N - 1 ) : <NEWLINE> <INDENT> ans = GCD ( A [ i ] , A [ i + 1 ] ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = np . array ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> count = 0 <NEWLINE> while 1 : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> print ( count ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> while A [ i ] % 2 == 0 : <NEWLINE> <INDENT> A [ i ] = A [ i ] / 2 <NEWLINE> cnt = cnt + 1 <NEWLINE> <DEDENT> ans . append ( cnt ) <NEWLINE> <DEDENT> print ( min ( sns ) ) <NEWLINE>
from sys import stdin <NEWLINE> <NL> n = stdin . readline ( ) . rstrip ( ) <NEWLINE> a = [ int ( x ) for x in stdin . readline ( ) . rstrip ( ) . split ( ) ] <NEWLINE> <NL> count = 0 <NEWLINE> b = a [ 0 ] <NEWLINE> while True : <NEWLINE> <INDENT> if b % 2 == 1 : break <NEWLINE> b = b // 2 <NEWLINE> count = count + 1 <NEWLINE> <DEDENT> minc = count <NEWLINE> <NL> for b in a [ 1 : ] : <NEWLINE> <INDENT> count = 0 <NEWLINE> while True : <NEWLINE> <INDENT> if b % 2 == 1 : break <NEWLINE> b = b // 2 <NEWLINE> count = count + 1 <NEWLINE> <NL> <DEDENT> minc = min ( [ minc , count ] ) <NEWLINE> <NL> <DEDENT> print ( minc ) <NEWLINE>
a = int ( input ( ) ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> count = 0 <NEWLINE> while ( true ) : <NEWLINE> <INDENT> flag = 0 <NEWLINE> for i in range ( 0 , a , 1 ) : <NEWLINE> <INDENT> if ( b [ i ] % 2 == 1 ) : <NEWLINE> <INDENT> flag = 1 <NEWLINE> <DEDENT> <DEDENT> if flag == 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for i in range ( 0 , a , 1 ) : <NEWLINE> <INDENT> b [ i ] /= 2 <NEWLINE> <DEDENT> count += 1 <NEWLINE> <DEDENT> print ( count ) <NEWLINE>
a = input ( ) <NEWLINE> b = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = [ ] <NEWLINE> max_b = max ( b ) <NEWLINE> d = 0 <NEWLINE> for i in b <NEWLINE> <INDENT> while i % 2 = 0 <NEWLINE> <INDENT> i = i / 2 <NEWLINE> d += 1 <NEWLINE> <DEDENT> ans . append ( d ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n = input ( ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) <NEWLINE> ans = 0 <NEWLINE> while all ( _ % 2 == 0 for _ in a ) : <NEWLINE> <INDENT> a = [ _ / 2 for _ in a ] <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = input ( ) <NEWLINE> l = input ( ) . split ( ) <NEWLINE> cnt = 0 <NEWLINE> while len ( [ True for x in l if x % 2 == 0 ] ) : <NEWLINE> <INDENT> l = [ x / 2 for x in l ] <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> print ( cnt ) <NEWLINE>
import math <NEWLINE> N = input ( ) . int ( ) <NEWLINE> A = map ( int , input ( ) . split ( ) ) <NEWLINE> B = map ( bin , A ) <NEWLINE> def Y ( x ) : <NEWLINE> <INDENT> y = len ( x ) - x . rfind ( <STRING> ) - 1 <NEWLINE> return y <NEWLINE> <DEDENT> C = map ( Y , B ) <NEWLINE> print ( min ( C ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> cnt = 0 <NEWLINE> <NL> while all ( i % 2 == 0 for i in a ) : <NEWLINE> <INDENT> A = [ i // 2 for i in a ] <NEWLINE> cnt += 1 <NEWLINE> <NL> <DEDENT> print ( cnt ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> n_length = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> counter = 0 <NEWLINE> while all ( i % 2 == 0 for i in n_length ) : <NEWLINE> <INDENT> n_list = [ i / 2 for i in n_length ] <NEWLINE> counter = + 1 <NEWLINE> <DEDENT> print ( counter ) <NEWLINE>
x = int ( input ( ) ) <NEWLINE> y = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> count = 0 <NEWLINE> <NL> for i in y : <NEWLINE> <INDENT> if i % 2 = 0 : <NEWLINE> <INDENT> y [ i ] == i % 2 <NEWLINE> count += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> pass <NEWLINE> <NL> <DEDENT> <DEDENT>
num = int ( input ( ) ) <NEWLINE> <NL> vals = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> cnt = 0 <NEWLINE> while ( True ) <NEWLINE> <INDENT> for i in range ( num ) : <NEWLINE> <INDENT> if vals [ i ] % 2 == 1 : <NEWLINE> <INDENT> print ( cnt ) <NEWLINE> break <NEWLINE> else : <NEWLINE> vals [ i ] = vals [ i ] / 2 <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> count = 1 <NEWLINE> <NL> while all ( a [ i ] % ( 2 ** count ) == 0 ) : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> print ( count - 1 ) <NEWLINE>
N = input ( ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> cnt = 0 <NEWLINE> while True : <NEWLINE> <INDENT> odd_flag = False <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if A [ i ] % 2 == 1 : <NEWLINE> <INDENT> odd_flag = True <NEWLINE> <DEDENT> <DEDENT> if odd_flag : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> A [ i ] = A [ i ] // 2 <NEWLINE> <DEDENT> cnt += 1 <NEWLINE> <NL> <DEDENT> print ( cnt ) <NEWLINE>
n = input ( ) <NEWLINE> <NL> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> counts = 0 <NEWLINE> while all ( a % 2 == 0 for a in A ) : <NEWLINE> <INDENT> A = [ a / 2 for a in A ] <NEWLINE> <INDENT> counts += 1 <NEWLINE> <DEDENT> <DEDENT> print ( counts ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> li = list ( map ( int , input ( ) . split ( ) ) <NEWLINE> b = float ( <STRING> ) <NEWLINE> <NL> for a in li : <NEWLINE> <INDENT> c = 0 <NEWLINE> while a % 2 == 0 : <NEWLINE> <INDENT> a = a / 2 <NEWLINE> c += 1 <NEWLINE> <DEDENT> b = min ( b , c ) <NEWLINE> <DEDENT> print ( b ) <NEWLINE> <NL>
import math <NEWLINE> N = input ( ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i in a : <NEWLINE> <INDENT> B = min ( len ( bin ( i ) ) - bin ( i ) . rfind ( <STRING> ) - 1 ) <NEWLINE> <DEDENT> print ( B ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> cnt = 0 <NEWLINE> <NL> while all ( i % 2 == 0 for i in a ) : <NEWLINE> <INDENT> A = [ i // 2 for i in a ] <NEWLINE> cnt += 1 <NEWLINE> <NL> <DEDENT> print ( cnt ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> n = int ( input ( ) ) <NEWLINE> ai = list ( map ( int ( ) , input . split ( ) ) ) <NEWLINE> b = [ ] <NEWLINE> for a in ai : <NEWLINE> <INDENT> count = 0 <NEWLINE> while a % 2 == 0 : <NEWLINE> <INDENT> count += 1 <NEWLINE> a /= 2 <NEWLINE> <DEDENT> b . append ( count ) <NEWLINE> <DEDENT> print ( min ( b ) ) <NEWLINE>
n = input ( ) <NEWLINE> a_list = input ( ) . split ( <STRING> ) <NEWLINE> <NL> def count_divide ( number , max_cnt = - 1 ) : <NEWLINE> <INDENT> count = 0 <NEWLINE> mod = - 1 <NEWLINE> while mod != 0 : <NEWLINE> <INDENT> q , mod = divmod ( number ) <NEWLINE> count += 1 <NEWLINE> if max_cnt != - 1 & count >= max_cnt : <NEWLINE> <INDENT> return max_cnt <NEWLINE> <DEDENT> <DEDENT> return count <NEWLINE> <NL> <DEDENT> result = - 1 <NEWLINE> for a in a_list : <NEWLINE> <INDENT> result = count_divide ( int ( a ) , result ) <NEWLINE> <DEDENT> print ( result ) <NEWLINE>
import math <NEWLINE> n = input ( ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = float ( <STRING> ) <NEWLINE> for i in a : <NEWLINE> <INDENT> ans = min ( ans , len ( bin ( i ) ) - bin ( i ) . rfind ( <STRING> ) - 1 ) <NEWLINE> <DEDENT> print ( round ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> an = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> n = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if an % 2 == 0 : <NEWLINE> <INDENT> n += 1 <NEWLINE> <DEDENT> <DEDENT> print ( an / 2 ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> flag = 0 <NEWLINE> nums = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> cnt = 0 <NEWLINE> <NL> while flag == 0 : <NEWLINE> <INDENT> for i in range ( n ) : <NEWLINE> <INDENT> num = nums [ 0 ] / 2 <NEWLINE> key = nums [ 0 ] % 2 <NEWLINE> if key == 1 : <NEWLINE> <INDENT> flag == 1 <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> del nums [ 0 ] <NEWLINE> nums . append ( num ) <NEWLINE> <DEDENT> <DEDENT> if flag == 0 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> while True : <NEWLINE> <INDENT> for i in l : <NEWLINE> <INDENT> if i % 2 != 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> ans += 1 <NEWLINE> l = [ i / 2 for i in l ] <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
INPUT = [ input ( ) for i in range ( 2 ) ] <NEWLINE> INPUT = list ( map ( int , INPUT ) ) <NEWLINE> <NL> def check_even ( l ) : <NEWLINE> <INDENT> return sum ( [ i % 2 for i in INPUT ] ) == 0 <NEWLINE> <NL> <DEDENT> check_even ( INPUT ) <NEWLINE> <NL> count = 0 <NEWLINE> while True : <NEWLINE> <INDENT> if check_even ( INPUT ) : <NEWLINE> <INDENT> INPUT = [ i / 2 for i in INPUT ] <NEWLINE> count += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
import numpy as num <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ary = num . array ( A ) <NEWLINE> b = len ( A ) <NEWLINE> S = 1 <NEWLINE> ans = 0 <NEWLINE> while True : <NEWLINE> <INDENT> for i in range ( b ) : <NEWLINE> <INDENT> S *= A [ i ] <NEWLINE> <DEDENT> if S % 2 == 0 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> ary = ary / 2 <NEWLINE> ary = A <NEWLINE> S = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> List = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> flag = True <NEWLINE> res = 0 <NEWLINE> while flag : <NEWLINE> <INDENT> for i in range ( N ) : <NEWLINE> <INDENT> if List [ i ] & 2 == 1 : <NEWLINE> <INDENT> flag = False <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if not flag : <NEWLINE> <INDENT> res += 1 <NEWLINE> <DEDENT> <DEDENT> print ( res ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = list ( map ( it , input ( ) . split ( ) ) ) <NEWLINE> count = - 0 <NEWLINE> while all ( i % 2 == 0 for i in s ) : <NEWLINE> <INDENT> s = [ i / 2 for i in s ] <NEWLINE> count += 1 <NEWLINE> <DEDENT> print ( count ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> count = 0 <NEWLINE> while all ( a % 2 == 0 for a in A ) : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> print ( count ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( input ( ) . split ( ) ) <NEWLINE> <NL> ans = float ( <STRING> ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> a = A [ i ] <NEWLINE> ans_tmp = 0 <NEWLINE> while a % 2 == 0 : <NEWLINE> <INDENT> a = a // 2 <NEWLINE> ans_tmp += 1 <NEWLINE> <DEDENT> ans = min ( ans_tmp , ans ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> cnt = 0 <NEWLINE> while all ( a % 2 == 0 for a in l ) : <NEWLINE> <INDENT> l = [ a / 2 for a in l ] <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = [ map ( int , input ( ) . split ( ) ) ] <NEWLINE> l = [ 0 for i in range ( n ) ] <NEWLINE> for i in range ( len ( a ) ) : <NEWLINE> <INDENT> while a [ i ] % 2 == 0 : <NEWLINE> <INDENT> a [ i ] /= 2 <NEWLINE> l [ i ] += 1 <NEWLINE> <DEDENT> <DEDENT> print ( min ( l ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> t = True <NEWLINE> x = 0 <NEWLINE> <NL> while T == True : <NEWLINE> <INDENT> x += 1 <NEWLINE> for i in a : <NEWLINE> <INDENT> if i % 2 == 0 : <NEWLINE> <INDENT> a = list ( map ( lambda x : x / 2 , a ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> t = False <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( x ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> count = 0 <NEWLINE> <NL> while all ( i % 2 == 0 for i in A ) : <NEWLINE> <INDENT> a = [ j / 2 for j in a ] <NEWLINE> count += 1 <NEWLINE> <DEDENT> print ( count ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = map ( int , input ( ) . split ( ) ) <NEWLINE> while True : <NEWLINE> <INDENT> for i in range ( n ) : <NEWLINE> <INDENT> if a [ i ] % 2 == 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> a [ i ] = a [ i ] // 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += 1 <NEWLINE> continue <NEWLINE> <DEDENT> break <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> cnt = 0 <NEWLINE> while True : <NEWLINE> <INDENT> if [ a % 2 for a in A ] == [ 0 ] * N : <NEWLINE> <INDENT> A = [ a // 2 for a in A ] <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE> <NL> <NL>
import ( sys ) <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = 0 <NEWLINE> while ( True ) : <NEWLINE> <INDENT> for i in range ( n ) : <NEWLINE> <INDENT> if ( a [ i ] % 2 != 0 ) : <NEWLINE> <INDENT> print ( b ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> a [ i ] = a [ i ] // 2 <NEWLINE> <DEDENT> b += 1 <NEWLINE> <DEDENT> print ( b ) <NEWLINE>
def actual ( N , A ) : <NEWLINE> <INDENT> count = 0 <NEWLINE> <NL> while True : <NEWLINE> <INDENT> is_all_even = all ( [ a % 2 == 0 for a in A ] ) <NEWLINE> <NL> if is_all_even : <NEWLINE> <INDENT> A = [ a // 2 for a in A ] <NEWLINE> count += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> return count <NEWLINE> <NL> <DEDENT> N = int ( input ( ) ) <NEWLINE> A = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> print ( actual ( N , A ) ) <NEWLINE>
import sys <NEWLINE> <NL> readline = sys . stdin . buffer . readline <NEWLINE> readlines = sys . stdin . buffer . readlines <NEWLINE> read = sys . stdin . buffer . read <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> INF = float ( <STRING> ) <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> ans = INF <NEWLINE> for a in A : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> while True : <NEWLINE> <INDENT> q , mod = divmod ( a , 2 ) <NEWLINE> if mod != 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> cnt += 1 <NEWLINE> a = q <NEWLINE> <DEDENT> ans = min ( ans , cnt ) <NEWLINE> <DEDENT> print ( ants ) <NEWLINE>
import copy <NEWLINE> <NL> kaisu = int ( input ( ) ) <NEWLINE> <NL> s_suji_list = input ( ) . split ( <STRING> ) <NEWLINE> suji_list = [ ] <NEWLINE> count = 0 <NEWLINE> cotinule_flg = True <NEWLINE> for suji in s_suji_list : <NEWLINE> <INDENT> i_suji = int ( suji ) <NEWLINE> if suji % 2 == 0 : <NEWLINE> <INDENT> suji_list . append ( suji / 2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> continue_flg = False <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> count = 1 <NEWLINE> <NL> while ( continue_flg ) : <NEWLINE> <INDENT> temp_list = copy . copy ( suji_list ) <NEWLINE> suji_list . clear ( ) <NEWLINE> count += 1 <NEWLINE> for suji in temp_list : <NEWLINE> <INDENT> if suji % 2 == 0 : <NEWLINE> <INDENT> suji_list . append ( suji / 2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> count -= 1 <NEWLINE> continue_flg = False <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
def d ( n ) : <NEWLINE> <INDENT> while n % 2 == 0 : <NEWLINE> <INDENT> n /= 2 <NEWLINE> ans += 1 <NEWLINE> <DEDENT> return ans <NEWLINE> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> a = map ( int , input ( ) . split ( ) ) <NEWLINE> t = min ( list ( map ( d , a ) ) ) <NEWLINE> <NL> print ( t ) <NEWLINE> <NL>
N = int ( input ( ) ) <NEWLINE> a = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> b = a <NEWLINE> t = 0 <NEWLINE> s = sum ( b ) <NEWLINE> while s % 2 == 0 : <NEWLINE> <INDENT> for i in range ( N ) : <NEWLINE> <INDENT> b [ i ] = b [ i ] / 2 <NEWLINE> t = t + 1 <NEWLINE> <DEDENT> <DEDENT> print ( t ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> Xl = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> from collections import Counter <NEWLINE> Xdic = Counter ( xl ) <NEWLINE> valuelist = sorted ( list ( Xdic . values ( ) ) , reverse = True ) <NEWLINE> print ( sum ( valuelist [ k : ] ) ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if ( len ( set ( a ) ) <= k ) : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dic_a = { x : 0 for x in set ( A ) } <NEWLINE> for i in a : <NEWLINE> <INDENT> dic_a [ i ] += 1 <NEWLINE> <DEDENT> sum = 0 <NEWLINE> a = sorted ( dic_a . items ( ) , key = lambda x : x [ 0 ] ) <NEWLINE> for i in range ( k , len ( a ) ) : <NEWLINE> <INDENT> sum += a [ i ] [ 1 ] <NEWLINE> <DEDENT> print ( sum ) <NEWLINE> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> freq = [ 0 ] * n + 1 <NEWLINE> for i in l : <NEWLINE> <INDENT> freq [ i ] += 1 <NEWLINE> <DEDENT> freq . sort ( ) <NEWLINE> vf = len ( freq ) - k if len ( freq ) > k else 0 <NEWLINE> print ( sum ( freq [ : vf ] ) ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = [ 0 ] * n <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> b [ a [ i ] ] += 1 <NEWLINE> <DEDENT> c = [ i for i in b if i != 0 ] <NEWLINE> c . sort ( ) <NEWLINE> if len ( c ) - k > 0 : <NEWLINE> <INDENT> print ( sum ( ( c [ 0 : len ( c ) - k ] ) ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = [ 0 ] * 10 ** 8 <NEWLINE> cnt = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if a [ A [ i ] ] == 0 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> a [ A [ i ] ] += 1 <NEWLINE> <DEDENT> a . sort ( reverse = True ) <NEWLINE> sum = 0 <NEWLINE> for i in range ( cnt - K ) : <NEWLINE> <INDENT> sum += a [ cnt - i - 1 ] <NEWLINE> <NL> <DEDENT> print ( sum ) <NEWLINE>
from collections import defaultdict <NEWLINE> <NL> n , k = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> d = defaultdict ( int ) <NEWLINE> for x in a : <NEWLINE> <INDENT> d [ x ] += 1 <NEWLINE> <NL> <DEDENT> av = reverse ( sorted ( d . values ( ) ) ) <NEWLINE> ks = 0 <NEWLINE> idx = 0 <NEWLINE> while ks < k : <NEWLINE> <INDENT> ks += av [ idx ] <NEWLINE> idx += 1 <NEWLINE> <DEDENT> print ( idx ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A . sort ( ) <NEWLINE> temp = 1 <NEWLINE> V = [ ] <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> if A [ i ] == A [ i + 1 ] : <NEWLINE> <INDENT> temp += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> V . append ( temp ) <NEWLINE> temp = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> V . append ( temp ) <NEWLINE> V . sort ( ) <NEWLINE> ans = N - sum ( V [ - k : ] ) <NEWLINE> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> mina = min ( A ) <NEWLINE> mini = A . index ( mina ) <NEWLINE> maxa = max ( A ) <NEWLINE> maxi = A . index ( mixa ) <NEWLINE> <NL> if mina >= 0 : <NEWLINE> <INDENT> print ( N - 1 ) <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> print ( <STRING> . format ( i + 1 , i + 2 ) ) <NEWLINE> <DEDENT> <DEDENT> elif maxa < 0 : <NEWLINE> <INDENT> print ( N - 1 ) <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> print ( <STRING> . format ( N - i , N - i - 1 ) ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if - mina < maxa : <NEWLINE> <INDENT> print ( 2 * N - 1 ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> print ( <STRING> . format ( maxi + 1 , i + 1 ) ) <NEWLINE> <DEDENT> for i in range ( N - 1 ) : <NEWLINE> <INDENT> print ( <STRING> . format ( i + 1 , i + 2 ) ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( 2 * N - 1 ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> print ( <STRING> . format ( mini + 1 , i + 1 ) ) <NEWLINE> <DEDENT> for i in range ( N - 1 ) : <NEWLINE> <INDENT> print ( <STRING> . format ( N - i , N - i - 1 ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
I = int ( input ( ) ) <NEWLINE> L = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> print ( 2 * I - 1 , flush = True ) <NEWLINE> <NL> m = 0 <NEWLINE> for i , item in enumerate ( L ) : <NEWLINE> <INDENT> if abs ( item ) > abs ( m ) : <NEWLINE> <INDENT> m = item <NEWLINE> m_index = i <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( L ) : <NEWLINE> <INDENT> print ( m_index + 1 , i + 1 , flush = True ) <NEWLINE> <NL> <DEDENT> if m >= 0 : <NEWLINE> <INDENT> for i in range ( 0 , I - 1 ) : <NEWLINE> <INDENT> print ( i + 1 , i + 2 ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( I , 0 ) : <NEWLINE> <INDENT> print ( i , i - 1 ) <NEWLINE> <DEDENT> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> a1 = sorted ( a ) <NEWLINE> a2 = [ ] <NEWLINE> count = 0 <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> if a1 [ i ] == a1 [ i + 1 ] : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a2 . append ( count ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> a2 . append ( count ) <NEWLINE> l = sorted ( a2 ) <NEWLINE> print ( sun ( l [ : len ( l ) - k - 1 ] ) ) <NEWLINE>
from collections import Counter <NEWLINE> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> N = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A = Counter ( N ) <NEWLINE> C = list ( A . values ( ) ) <NEWLINE> C = C . sort ( reverse = True ) <NEWLINE> if len ( C ) <= K : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = sum ( C [ - ( len ( C ) - K ) : ] ) <NEWLINE> print ( ans ) <NEWLINE> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> kaburi = [ ] <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> if not a [ i ] in kaburi : <NEWLINE> <INDENT> kaburi . append ( a [ i ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> kaisu = 0 <NEWLINE> <NL> while True : <NEWLINE> <INDENT> p = n <NEWLINE> q = 0 <NEWLINE> if k >= len ( kaburi ) : <NEWLINE> <INDENT> print ( kaisu ) <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for j in range ( len ( kaburi ) ) : <NEWLINE> <INDENT> p = min ( p , a . count ( kaburi [ j ] ) ) <NEWLINE> if p > a . count ( kaburi [ j ] ) : <NEWLINE> <INDENT> q = kaburi [ j ] <NEWLINE> <DEDENT> <DEDENT> kaisu += p <NEWLINE> print ( p , q , kaisu , len ( kaburi ) ) <NEWLINE> kaburi . remove ( q ) <NEWLINE> <DEDENT> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> import sys <NEWLINE> import numpy as np <NEWLINE> ikimasu = sys . stdin . buffer . readline <NEWLINE> ini = lambda : int ( ins ( ) ) <NEWLINE> ina = lambda : list ( map ( int , ikimasu ( ) . split ( ) ) ) <NEWLINE> ins = lambda : ikimasu ( ) . strip ( ) <NEWLINE> <NL> n = ini ( ) <NEWLINE> tmp = ina ( ) <NEWLINE> num , index = 0 , 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if ( abs ( tmp [ i ] ) > num ) : <NEWLINE> <INDENT> num , index = tmp [ i ] , i <NEWLINE> <DEDENT> <DEDENT> print ( 2 n - 2 ) <NEWLINE> if ( num <= 0 ) : <NEWLINE> <INDENT> for i in range ( n ) : <NEWLINE> <INDENT> if ( i != index ) : <NEWLINE> <INDENT> print ( index + 1 , i + 1 ) <NEWLINE> <DEDENT> <DEDENT> for i in range ( n , 1 , - 1 ) : <NEWLINE> <INDENT> print ( i , i - 1 ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( n ) : <NEWLINE> <INDENT> if ( i != index ) : <NEWLINE> <INDENT> print ( index + 1 , i + 1 ) <NEWLINE> <DEDENT> <DEDENT> for i in range ( 1 , n ) : <NEWLINE> <INDENT> print ( i , i + 1 ) <NEWLINE> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
<NL> if N * A < B : <NEWLINE> <INDENT> print ( N * A ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( B ) <NEWLINE> <DEDENT>
a , b , c = input ( ) . split ( ) <NEWLINE> if a * b <= c : <NEWLINE> <INDENT> print ( int ( a * b ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( c ) <NEWLINE> <DEDENT>
N , A , B = map ( int , input ( ) ) <NEWLINE> <NL> if N * A <= B : <NEWLINE> <INDENT> print ( N * A ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( B ) <NEWLINE> <DEDENT>
N , A , B = map ( int , input ( ) , split ( ) ) <NEWLINE> print ( min ( N * A , B ) ) <NEWLINE>
N , A , B = map ( int , input ( ) . split ) <NEWLINE> print ( min ( N * A , B ) ) <NEWLINE>
n , a , b = map ( int , intput ( ) . split ( ) ) <NEWLINE> a = n * a <NEWLINE> print ( min ( a , b ) ) <NEWLINE>
N , A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( min ( A * T , B ) ) <NEWLINE>
<COMMENT> <NL> <NL> n , a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> print ( min ( n * a ) , b ) <NEWLINE>
<COMMENT> <NL> n = input ( ) <NEWLINE> print ( <STRING> if sum ( map ( int , n ) ) % n == 0 else <STRING> ) <NEWLINE>
N = input ( ) <NEWLINE> if N % sum ( map ( int , N ) ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = input ( ) <NEWLINE> Nnum = int ( N ) <NEWLINE> Nls = list ( N ) <NEWLINE> FN = sum ( Nls ) <NEWLINE> if Nnum % FN == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = input ( ) <NEWLINE> a = int ( N ) <NEWLINE> b = list ( N ) <NEWLINE> sum = 0 <NEWLINE> <NL> for i in b : <NEWLINE> <INDENT> sum += i <NEWLINE> <NL> <DEDENT> if a % sum == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
x = input ( ) <NEWLINE> a = int ( x ) <NEWLINE> b = list ( x ) <NEWLINE> b = sum ( b ) <NEWLINE> <NL> if a % b == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> s = 0 <NEWLINE> while N // 10 > 0 <NEWLINE> <INDENT> a = N % 10 <NEWLINE> s += a <NEWLINE> N = N // 10 <NEWLINE> <DEDENT> if N % s == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = input ( ) <NEWLINE> m = list ( n ) <NEWLINE> if int ( n ) % sum ( m ) == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = input ( ) <NEWLINE> f = 0 <NEWLINE> for i in range ( len ( n ) ) : <NEWLINE> <INDENT> f += n [ i ] <NEWLINE> <DEDENT> if int ( n ) % f == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> sum = 0 <NEWLINE> for i in str ( n ) : <NEWLINE> <INDENT> sum += int ( i ) <NEWLINE> <DEDENT> if ( N % sum == 0 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> str_n = str ( n ) <NEWLINE> wa = 0 <NEWLINE> for i in range ( len ( str_n ) ) : <NEWLINE> <INDENT> wa += int ( str_n [ i ] ) <NEWLINE> <DEDENT> if x % wa == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = input ( ) <NEWLINE> a = sum ( map ( int , str ( N ) ) ) <NEWLINE> if N % a == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = list ( input ( ) ) <NEWLINE> N = int ( sum ( n ) ) <NEWLINE> M = 0 <NEWLINE> for i in range ( len ( n ) ) : <NEWLINE> <INDENT> M += int ( n [ i ] ) <NEWLINE> <DEDENT> if N % M == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> F = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( N ) ] <NEWLINE> P = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( N ) ] <NEWLINE> <NL> ans = - 10 ** 9 <NEWLINE> for i in range ( 2 ** 10 - 1 ) : <NEWLINE> <INDENT> Bit = [ 1 ] ** 10 <NEWLINE> for j in range ( 10 ) : <NEWLINE> <INDENT> if ( i >> j ) & 1 : <NEWLINE> <INDENT> Bit [ j ] = 0 <NEWLINE> <DEDENT> <DEDENT> count = 0 <NEWLINE> for k in range ( N ) : <NEWLINE> <INDENT> op = sum ( b & f for b , f in zip ( Bit , F [ k ] ) ) <NEWLINE> count += P [ k ] [ op ] <NEWLINE> <DEDENT> ans = max ( ans , count ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> F = [ [ int ( i ) for i in input ( ) . split ( ) ] for j in range ( N ) ] <NEWLINE> P = [ [ int ( i ) for i in input ( ) . split ( ) ] for j in range ( N ) ] <NEWLINE> <NL> ci = 0 <NEWLINE> c = [ ] <NEWLINE> P_max = - 1000000000 <NEWLINE> for i in range ( 2 ) : <NEWLINE> <INDENT> for j in range ( 2 ) : <NEWLINE> <INDENT> for k in range ( 2 ) : <NEWLINE> <INDENT> for l in range ( 2 ) : <NEWLINE> <INDENT> for m in range ( 2 ) : <NEWLINE> <INDENT> for n in range ( 2 ) : <NEWLINE> <INDENT> for o in range ( 2 ) : <NEWLINE> <INDENT> for p in range ( 2 ) : <NEWLINE> <INDENT> for q in range ( 2 ) : <NEWLINE> <INDENT> for r in range ( 2 ) : <NEWLINE> <INDENT> if i == j == k == l == m == n == o == p == q == r == 0 : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> for s in range ( N ) : <NEWLINE> <INDENT> ci = F [ s ] [ 0 ] * i + F [ s ] [ 1 ] * j + F [ s ] [ 2 ] * k + F [ s ] [ 3 ] * l + F [ s ] [ 4 ] * m + F [ s ] [ 5 ] * n + F [ s ] [ 6 ] * o + F [ s ] [ 7 ] * p + F [ s ] [ 8 ] * q + F [ s ] [ 9 ] * r <NEWLINE> c . append ( ci ) <NEWLINE> <DEDENT> P_sample = P [ 0 ] [ c [ 0 ] ] + P [ 1 ] [ c [ 1 ] ] + P [ 2 ] [ c [ 2 ] ] + P [ 3 ] [ c [ 3 ] ] + P [ 4 ] [ c [ 4 ] ] + P [ 5 ] [ c [ 5 ] ] + P [ 6 ] [ c [ 6 ] ] + P [ 7 ] [ c [ 7 ] ] + P [ 8 ] [ c [ 8 ] ] + P [ 9 ] [ c [ 9 ] ] <NEWLINE> P_max = max ( P_max , P_sample ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( P_max ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> F = [ [ ] for TF in range ( 0 , N ) ] <NEWLINE> for TF in range ( 0 , N ) : <NEWLINE> <INDENT> F [ TF ] = [ int ( T ) for T in input ( ) . split ( ) ] <NEWLINE> <DEDENT> P = [ [ ] for TP in range ( 0 , N ) ] <NEWLINE> for TP in range ( 0 , N ) : <NEWLINE> <INDENT> P [ TP ] = [ int ( T ) for T in input ( ) . split ( ) ] <NEWLINE> <NL> <DEDENT> MAXB = - 10 ** 9 <NEWLINE> for TB in range ( 1 , 2 ** 10 ) : <NEWLINE> <INDENT> BaseConv , BaseSInd = ForBaseConvert ( TB , 10 , 2 ) <NEWLINE> Benefit = 0 <NEWLINE> for TN in range ( 0 , N ) : <NEWLINE> <INDENT> Count = sum ( 1 if F [ TN ] [ TT ] == 1 else 0 for TT in BaseSInd [ 1 ] ) <NEWLINE> Benefit += P [ TN ] [ Count ] <NEWLINE> <DEDENT> if MAXB < Benefit : <NEWLINE> <INDENT> MAXB = Benefit <NEWLINE> <DEDENT> <DEDENT> print ( MAXB ) <NEWLINE>
import sys <NEWLINE> n = int ( input ( ) ) <NEWLINE> F = [ list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) for _ in range ( n ) ] <NEWLINE> P = [ list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) for _ in range ( n ) ] <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , pow ( 2 , 10 ) ) : <NEWLINE> <INDENT> b = bin ( i ) [ 2 : ] . zfill ( 10 ) <NEWLINE> t = 0 <NEWLINE> for j in range ( n ) : <NEWLINE> <INDENT> c = 0 <NEWLINE> for k in range ( 10 ) : <NEWLINE> <INDENT> if int ( b [ k ] ) and F [ j ] [ k ] : <NEWLINE> <INDENT> c += 1 <NEWLINE> <DEDENT> <DEDENT> a += P [ j ] [ c ] <NEWLINE> <DEDENT> ans = max ( ans , a ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> import numpy as np <NEWLINE> readline = sys . stdin . readline <NEWLINE> read = sys . stdin . read <NEWLINE> <NL> n , c , * stc = map ( int , read ( ) ) <NEWLINE> m = 2 * 10 ** 5 <NEWLINE> cht = np . zeros ( ( c , m + 1 ) , dtype = <STRING> ) <NEWLINE> for s , t , c in zip ( * [ iter ( stc ) ] * 3 ) : <NEWLINE> <INDENT> cht [ c - 1 , 2 * t - 1 : 2 * s ] = np . ones ( 2 * t - 2 * s + 1 ) <NEWLINE> <DEDENT> print ( max ( np . sum ( cht , axis = 0 ) ) ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> from itertools import accumulate <NEWLINE> n , c , * stc = map ( int , open ( 0 ) . read ( ) . split ( ) ) <NEWLINE> table = [ 0 ] * ( 10 ** 5 + 2 ) <NEWLINE> m = list ( zip ( stc [ : : 3 ] , stc [ 1 : : 3 ] , stc [ 2 : : 3 ] ) ) <NEWLINE> m = sorted ( key = lambda a : ( a [ 2 ] , a [ 0 ] , a [ 1 ] ) ) <NEWLINE> <NL> ch_ = 0 <NEWLINE> t_ = 0 <NEWLINE> for s , t , ch in m : <NEWLINE> <INDENT> if ch != ch_ : <NEWLINE> <INDENT> ch_ = ch <NEWLINE> t_ = 0 <NEWLINE> <DEDENT> if t_ == s : <NEWLINE> <INDENT> table [ t_ + 1 ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> table [ s ] += 1 <NEWLINE> <NL> <DEDENT> table [ t + 1 ] -= 1 <NEWLINE> t_ = t <NEWLINE> <NL> <DEDENT> * x , = accumulate ( table ) <NEWLINE> ans = max ( x ) <NEWLINE> <NL> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> import numpy as np <NEWLINE> readline = sys . stdin . readline <NEWLINE> read = sys . stdin . read <NEWLINE> <NL> n , c = map ( int , readline ( ) . split ( ) ) <NEWLINE> m = 2 * 10 ** 5 <NEWLINE> stc = [ list ( map ( int , l . split ( ) ) ) for l in read ( ) . splitlines ( ) ] <NEWLINE> cht = np . array ( [ ] ) <NEWLINE> for e in stc : <NEWLINE> <INDENT> w = e [ 1 ] - e [ 0 ] <NEWLINE> cht . vstack ( ( cht , np . pad ( np . ones ( 2 * ( e [ 1 ] - e [ 0 ] ) + 1 ) , ( 2 * e [ 0 ] - 1 , m - 2 * e [ 1 ] ) , mode = <STRING> , constant_values = ( 1 , 1 ) ) ) ) <NEWLINE> <DEDENT> mnr = 0 <NEWLINE> for i in range ( 1 , m + 1 ) : <NEWLINE> <INDENT> mnr = max ( mnr , sum ( cht [ ch ] [ i ] for ch in range ( c ) ) ) <NEWLINE> <DEDENT> print ( mnr ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> import sys <NEWLINE> readline = sys . stdin . readline <NEWLINE> <NL> import numpy as np <NEWLINE> from numba import jit <NEWLINE> <NL> N , Q = map ( int , readline ( ) . split ( ) ) <NEWLINE> P = [ tuple ( map ( int , readline ( ) . split ( ) ) ) for i in range ( Q ) ] <NEWLINE> P = np . array ( P , dtype = int ) <NEWLINE> <NL> @ jit ( <STRING> ) <NEWLINE> def solve ( N , P ) : <NEWLINE> <INDENT> ans = np . zeros ( len ( P ) , dtype = int ) <NEWLINE> for i in range ( len ( P ) ) : <NEWLINE> <INDENT> v = P [ i ] [ 0 ] - 1 <NEWLINE> w = P [ i ] [ 1 ] - 1 <NEWLINE> while v != w : <NEWLINE> <INDENT> if v > w : <NEWLINE> <INDENT> v = ( v - 1 ) // N <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> w = ( w - 1 ) // N <NEWLINE> <DEDENT> <DEDENT> ans [ i ] = v + 1 <NEWLINE> <DEDENT> return ans <NEWLINE> <NL> <DEDENT> ans = solve ( N , P ) <NEWLINE> for a in ans : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <DEDENT>
<COMMENT> <NL> import re <NEWLINE> <NL> s = input ( ) <NEWLINE> STR = <STRING> <NEWLINE> if len ( s ) > len ( STR ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> regex = re . compile ( <STRING> ) <NEWLINE> mo = regex . search ( s ) <NEWLINE> if mo == None : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> ~ <NEWLINE>
s = input ( ) <NEWLINE> <COMMENT> <NL> if ( s == <STRING> ) or ( s == <STRING> ) or ( s == <STRING> ) or ( s == <STRING> ) or ( s == <STRING> ) or ( s == <STRING> ) or ( s == <STRING> ) or ( s == <STRING> ) <NEWLINE> or ( s == <STRING> ) or ( s == <STRING> ) or ( s == <STRING> ) or ( s == <STRING> ) or ( s == <STRING> ) or ( s == <STRING> ) or ( s == <STRING> ) or ( s == <STRING> ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> AKB = { <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> } <NEWLINE> <NL> print ( <STRING> if s in pos else <STRING> ) <NEWLINE>
S = input ( ) <NEWLINE> if len ( S ) >= 10 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if S == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif S == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif S == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif S == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif S == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif S == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif S == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif S == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif S == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif S == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif S == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif S == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif S == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif S == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> print ( <STRING> ) <NEWLINE> <DEDENT>
import sys <NEWLINE> S = list ( input ( ) ) <NEWLINE> <NL> L = list ( <STRING> ) <NEWLINE> for l in L : <NEWLINE> <INDENT> if not l in <STRING> . join ( S ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( 0 ) <NEWLINE> <NL> N = [ ] <NEWLINE> <DEDENT> <DEDENT> for i in range ( len ( S ) - 1 ) : <NEWLINE> <INDENT> if S [ i ] == <STRING> or S [ i ] == <STRING> or S [ i ] == <STRING> : <NEWLINE> <INDENT> if S [ i + 1 ] != <STRING> : <NEWLINE> <INDENT> N . append ( i + 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> i = 0 <NEWLINE> for n in N : <NEWLINE> <INDENT> S . insert ( n + i , <STRING> ) <NEWLINE> i += 1 <NEWLINE> <NL> <DEDENT> if <STRING> . join ( S ) in <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
from itertools import product <NEWLINE> <NL> <NL> candidates = [ ] <NEWLINE> non_as = [ <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> for seps in product ( [ <STRING> , <STRING> ] , repeat = 4 ) : <NEWLINE> <INDENT> candidates . add ( <STRING> . append ( sep + non_a for sep , non_a in zip ( seps , non_as ) ) ) <NEWLINE> <NL> <DEDENT> print ( <STRING> ) if input ( ) in candidates else print ( <STRING> ) <NEWLINE>
s = [ c for c in <STRING> ] <NEWLINE> L = [ ] <NEWLINE> for i in range ( 0 , 2 ) : <NEWLINE> <INDENT> for j in range ( 0 , 2 ) : <NEWLINE> <INDENT> for k in range ( 0 , 2 ) : <NEWLINE> <INDENT> for l in range ( 0 , 2 ) : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> s [ 0 ] = <STRING> <NEWLINE> <DEDENT> if j == 0 : <NEWLINE> <INDENT> s [ 4 ] = <STRING> <NEWLINE> <DEDENT> if k == 0 : <NEWLINE> <INDENT> s [ 6 ] = <STRING> <NEWLINE> <DEDENT> if l == 0 : <NEWLINE> <INDENT> s [ 8 ] = <STRING> <NEWLINE> <DEDENT> while <STRING> in s : <NEWLINE> <INDENT> s . remove ( <STRING> ) <NEWLINE> <DEDENT> L . append ( s ) <NEWLINE> s = [ c for c in <STRING> ] <COMMENT> <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> S = [ c for c in input ( ) ] <NEWLINE> for el in L : <NEWLINE> <INDENT> if S == el : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( 0 ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
S = input ( ) <NEWLINE> if len ( S ) >= 10 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if S == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif S == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif S == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif S == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif S == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif S == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif S == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif S == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif S == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif S == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif S == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif S == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif S == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif S == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else ; <NEWLINE> print ( <STRING> ) <NEWLINE> <DEDENT>
s = list ( input ( ) ) <NEWLINE> a = s . count ( <STRING> ) <NEWLINE> b = s . count ( <STRING> ) <NEWLINE> c = s . count ( <STRING> ) <NEWLINE> if min ( a , b , c ) != 0 and max ( a , b , c ) - min ( a , b , c ) <= 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a + b + c = max ( a , b , c ) and max ( a , b , c ) == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = len ( s ) <NEWLINE> set = set ( s ) <NEWLINE> m = len ( set ) <NEWLINE> a = s . count ( <STRING> ) <NEWLINE> b = s . count ( <STRING> ) <NEWLINE> c = s . count ( <STRING> ) <NEWLINE> if m == 1 : <NEWLINE> <INDENT> if n == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> elif m == 2 : <NEWLINE> <INDENT> if c == 0 : <NEWLINE> <INDENT> if a == b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> elif b == 0 : <NEWLINE> <INDENT> if a == c : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if b == c : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> d = n // m <NEWLINE> res = 0 <NEWLINE> if a <= d : <NEWLINE> <INDENT> res += 1 <NEWLINE> <DEDENT> if b <= d : <NEWLINE> <INDENT> res += 1 <NEWLINE> <DEDENT> if c <= d : <NEWLINE> <INDENT> res += 1 <NEWLINE> <DEDENT> if res <= 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
s = input ( ) <NEWLINE> <NL> dic = { } <NEWLINE> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> if s [ i ] in dic : <NEWLINE> <INDENT> dic [ s [ i ] ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dic [ s [ i ] ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if len ( dic ) == 1 : <NEWLINE> <INDENT> if len ( s ) == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> elif len ( dic ) == 2 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> first = <STRING> <NEWLINE> second = <STRING> <NEWLINE> for k , v in dic . items ( ) : <NEWLINE> <INDENT> if v > dic [ first ] : <NEWLINE> <INDENT> second = first <NEWLINE> first = k <NEWLINE> <NL> <DEDENT> elif v > dic [ second ] : <NEWLINE> <INDENT> second = k <NEWLINE> <NL> <DEDENT> <DEDENT> tmp = first + second <NEWLINE> dic [ first ] -= 1 <NEWLINE> dic [ second ] -= 1 <NEWLINE> ans = <STRING> <NEWLINE> for i in range ( 1 , len ( s ) - 1 ) : <NEWLINE> <INDENT> if tmp [ i - 1 ] == <STRING> : <NEWLINE> <INDENT> if tmp [ i ] == <STRING> : <NEWLINE> <INDENT> if dic [ <STRING> ] == 0 : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dic [ <STRING> ] -= 1 <NEWLINE> tmp += <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> if tmp [ i ] == <STRING> : <NEWLINE> <INDENT> if dic [ <STRING> ] == 0 : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dic [ <STRING> ] -= 1 <NEWLINE> tmp += <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> elif tmp [ i - 1 ] == <STRING> : <NEWLINE> <INDENT> if tmp [ i ] == <STRING> : <NEWLINE> <INDENT> if dic [ <STRING> ] == 0 : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dic [ <STRING> ] -= 1 <NEWLINE> tmp += <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> if tmp [ i ] == <STRING> : <NEWLINE> <INDENT> if dic [ <STRING> ] == 0 : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dic [ <STRING> ] -= 1 <NEWLINE> tmp += <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> elif tmp [ i - 1 ] == <STRING> : <NEWLINE> <INDENT> if tmp [ i ] == <STRING> : <NEWLINE> <INDENT> if dic [ <STRING> ] == 0 : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dic [ <STRING> ] -= 1 <NEWLINE> tmp += <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> if tmp [ i ] == <STRING> : <NEWLINE> <INDENT> if dic [ <STRING> ] == 0 : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dic [ <STRING> ] -= 1 <NEWLINE> tmp += <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> from numba import njit <NEWLINE> <NL> <NL> @ njit ( <STRING> , cache = True ) <NEWLINE> def solve ( N , D ) : <NEWLINE> <INDENT> ans = 0 <NEWLINE> for i in range ( 1 << N ) : <NEWLINE> <INDENT> clocks = np . zeros ( ( N + 2 ) , dtype = np . int8 ) <NEWLINE> clocks [ - 1 ] = 24 <NEWLINE> for j in range ( N ) : <NEWLINE> <INDENT> if i >> j & 1 : <NEWLINE> <INDENT> clocks [ j + 1 ] = D [ j ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> clocks [ j + 1 ] = 24 - D [ j ] <NEWLINE> <DEDENT> <DEDENT> clocks . sort ( ) <NEWLINE> ans = max ( ans , np . min ( np . diff ( clocks ) ) ) <NEWLINE> <DEDENT> return ans <NEWLINE> <NL> <NL> <DEDENT> N = int ( input ( ) ) <NEWLINE> D = np . array ( input ( ) . split ( ) , dtype = np . int8 ) <NEWLINE> if N >= 24 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( solve ( N , D ) ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> c = Counter ( s ) <NEWLINE> v = list ( c . values ( ) ) <NEWLINE> if max ( v ) - min ( v ) > 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
from collections import Counter <NEWLINE> n = list ( input ( ) ) <NEWLINE> c = Counter ( n ) <NEWLINE> if max ( list ( c . values ) ) >= 3 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = str ( input ( ) ) <NEWLINE> a , b , c , d = N [ 0 ] , N [ 1 ] , N [ 2 ] , N [ 3 ] <NEWLINE> <NL> ans = <STRING> <NEWLINE> if a == b and b = A = c : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <DEDENT> elif b == c and c == d : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <NL> <NL> <DEDENT> print ( ans ) <NEWLINE>
a = int ( inout ( ) ) <NEWLINE> if a [ 0 ] == a [ 1 ] == a [ 2 ] or a [ 1 ] == a [ 2 ] == a [ 3 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a = int ( input ( ) ) <NEWLINE> print ( <STRING> if a [ 1 ] == a [ 2 ] == a [ 0 ] or a [ 1 ] == a [ 2 ] == a [ 3 ] , else <STRING> ) <NEWLINE>
<NL> N = int ( input ( ) ) <NEWLINE> <NL> if N [ 0 ] == N [ 1 ] and N [ 1 ] == N [ 2 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> elif N [ 1 ] == N [ 2 ] and N [ 2 ] == N [ 3 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = list ( int ( input ( ) ) ) <NEWLINE> a = set ( N ) <NEWLINE> a = list ( a ) <NEWLINE> if len ( a ) <= 2 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import bisect , collections , copy , heapq , itertools , math , string <NEWLINE> import sys <NEWLINE> def I ( ) : <NEWLINE> <COMMENT> <NL> <INDENT> return int ( sys . stdin . readline ( ) . rstrip ( ) ) <NEWLINE> <DEDENT> def LI ( ) : <NEWLINE> <COMMENT> <NL> <INDENT> return list ( map ( int , sys . stdin . readline ( ) . rstrip ( ) . split ( ) ) ) <NEWLINE> <DEDENT> def S ( ) : <NEWLINE> <COMMENT> <NL> <INDENT> return sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> <DEDENT> def LS ( ) : <NEWLINE> <COMMENT> <NL> <INDENT> return list ( sys . stdin . readline ( ) . rstrip ( ) . split ( ) ) <NEWLINE> <NL> <DEDENT> A = S ( ) <NEWLINE> <NL> if A [ 0 ] == A [ 1 ] == A [ 2 ] or A [ 1 ] == A [ 2 ] == A [ 3 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <NL> <DEDENT>
N = input ( ) <NEWLINE> s1 = N [ 1 : len ( N ) ] <NEWLINE> s2 = N [ 0 : len ( N ) - 1 ] <NEWLINE> isOk = True <NEWLINE> for i in range ( 1 , len ( N - 1 ) ) : <NEWLINE> <INDENT> if s1 [ i ] != s1 [ i - 1 ] : <NEWLINE> <INDENT> break <NEWLINE> isOk = False <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <DEDENT> <DEDENT> if isOk : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> isOk = True <NEWLINE> for i in range ( 1 , len ( N - 1 ) ) : <NEWLINE> <INDENT> if s2 [ i ] != s2 [ i - 1 ] : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <DEDENT> <DEDENT> if isOk : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = input ( ) <NEWLINE> print ( <STRING> if [ <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ] in n else <STRING> ) <NEWLINE>
N = list ( input ( ) ) <NEWLINE> print ( <STRING> if N [ 1 ] == N [ 2 ] and ( N [ 0 ] == N [ 1 ] or N [ 2 ] == N [ 3 ] ) else <STRING> ) a <NEWLINE>
n = int ( input ( ) ) <NEWLINE> for i in range ( 2 ) : <NEWLINE> <INDENT> if n [ i ] == n [ i + 1 ] and n [ i + 1 ] == n [ i + 2 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> dp = [ [ ] for i in range ( 87 ) ] <NEWLINE> dp [ 0 ] = 2 <NEWLINE> dp [ 1 ] = 1 <NEWLINE> <NL> for i in range ( 2 , 87 ) : <NEWLINE> <INDENT> dp [ i ] = dp [ i - 1 ] + dp [ i - 2 ] <NEWLINE> if i == N : <NEWLINE> <INDENT> print ( dp [ i ] ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( dp [ N ] ) <NEWLINE> <DEDENT>
<COMMENT> <NL> n = list ( input ( ) ) <NEWLINE> if ( n [ 0 ] n [ 1 ] n [ 2 ] or n [ 0 ] n [ 2 ] n [ 3 ] or n [ 0 ] n [ 1 ] n [ 3 ] or n [ 1 ] n [ 2 ] n [ 3 ] ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> if n [ 1 ] == n [ 2 ] : <NEWLINE> <INDENT> if n [ 0 ] == n [ 1 ] or n [ 2 ] == n [ 3 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
s = input ( ) <NEWLINE> if ( ( t [ 0 : 1 ] == t [ 1 : 2 ] == t [ 2 : 3 ] ) or ( t [ 1 : 2 ] == t [ 2 : 3 ] == t [ 3 : 4 ] ) ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> import sys , re <NEWLINE> from collections import deque , defaultdict , Counter <NEWLINE> from math import ceil , sqrt , hypot , factorial , pi , sin , cos , radians <NEWLINE> from itertools import accumulate , permutations , combinations , product <NEWLINE> from operator import itemgetter , mul <NEWLINE> from copy import deepcopy <NEWLINE> from string import ascii_lowercase , ascii_uppercase , digits <NEWLINE> from bisect import bisect , bisect_left <NEWLINE> from fractions import gcd <NEWLINE> from heapq import heappush , heappop <NEWLINE> from functools import reduce <NEWLINE> import numpy as np <NEWLINE> def input ( ) : return sys . stdin . readline ( ) . strip ( ) <NEWLINE> def INT ( ) : return int ( input ( ) ) <NEWLINE> def MAP ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def LIST ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> def ZIP ( n ) : return zip ( * ( MAP ( ) for _ in range ( n ) ) ) <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> INF = float ( <STRING> ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> S = input ( ) <NEWLINE> if S [ 0 ] == S [ 1 ] == s [ 2 ] or S [ 1 ] == S [ 2 ] == s [ 3 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> L = [ 2 , 1 ] <NEWLINE> <NL> for i in range ( 2 , N ) : <NEWLINE> <INDENT> L . append ( L [ i - 1 ] + L [ i - 2 ] ) <NEWLINE> <DEDENT> print ( L [ N + 1 ] ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> L = [ ] * ( N + 1 ) <NEWLINE> L [ 0 ] = 2 <NEWLINE> L [ 1 ] = 1 <NEWLINE> for i in range ( 2 , N + 1 ) : <NEWLINE> <INDENT> L [ i ] = L [ i - 1 ] + L [ i - 2 ] <NEWLINE> <DEDENT> print ( L [ N ] ) <NEWLINE>
import functools <NEWLINE> @ fuctools . lru_cache ( maxsize = None ) <NEWLINE> <NL> def luca ( n ) : <NEWLINE> <INDENT> if n == 0 : <NEWLINE> <INDENT> return 2 <NEWLINE> <DEDENT> elif n == 1 : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return luca ( n - 1 ) + luca ( n - 2 ) <NEWLINE> <NL> <DEDENT> <DEDENT> N = int ( input ( ) ) <NEWLINE> <NL> print ( luca ( N ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> L = [ ] <NEWLINE> L . append ( 2 ) <NEWLINE> L . append ( 1 ) <NEWLINE> for i in range ( 3 , n + 1 ) : <NEWLINE> <INDENT> x = L [ i - 1 ] + L [ i - 2 ] <NEWLINE> L . append ( x ) <NEWLINE> <NL> <DEDENT> print ( L [ n ] ) <NEWLINE>
N = input ( ) <NEWLINE> <NL> L = [ 2 , 1 ] <NEWLINE> <NL> if N == 1 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> i = 1 <NEWLINE> while i < N : <NEWLINE> <INDENT> L . append ( L [ i ] + L [ i - 1 ] ) <NEWLINE> i += 1 <NEWLINE> <DEDENT> print ( L [ - 1 ] ) <NEWLINE> <DEDENT>
<COMMENT> <NL> N = int ( input ( ) ) <NEWLINE> import ita <NEWLINE> data = ita . array . make1d ( N + 1 ) <NEWLINE> data [ 0 ] = 2 <NEWLINE> data [ 1 ] = 1 <NEWLINE> for i in range ( 2 , N + 1 ) : <NEWLINE> <INDENT> data [ i ] = data [ i - 1 ] + data [ i - 2 ] <NEWLINE> <DEDENT> print ( data [ N ] ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = [ ] <NEWLINE> s . append ( 2 ) <NEWLINE> s . append ( 1 ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> elif n == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( 2 , 86 ) : <NEWLINE> <INDENT> k = s [ i - 2 ] + s [ i - 1 ] <NEWLINE> s . apend ( k ) <NEWLINE> if i == n - 1 : <NEWLINE> <INDENT> print ( s [ i ] ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> L = [ 0 ] * 87 <NEWLINE> L [ 0 ] = 2 <NEWLINE> L [ 1 ] = 1 <NEWLINE> <NL> for i in range ( 2 , 88 ) : <NEWLINE> <INDENT> L [ i ] = L [ i - 1 ] + L [ i - 2 ] <NEWLINE> <NL> <DEDENT> print ( L [ N ] ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> l = [ 2 , 1 ] <NEWLINE> i = 0 <NEWLINE> while i < n : <NEWLINE> <INDENT> l . append ( l [ - 1 ] + l [ - 2 ] ) <NEWLINE> <DEDENT> print ( l [ n - 2 ] ) <NEWLINE>
from itertools import product <NEWLINE> <NL> s = input ( ) <NEWLINE> <NL> for op in product ( [ <STRING> , <STRING> ] , repeat = len ( s ) - 1 ) : <NEWLINE> <INDENT> formula = <STRING> <NEWLINE> for i in range ( len ( s - 1 ) ) : <NEWLINE> <INDENT> formula += s [ i ] + op [ i ] <NEWLINE> <DEDENT> formula += s [ 1 ] <NEWLINE> if eval ( formula ) == 7 : <NEWLINE> <INDENT> print ( formula + <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT>
def make7 ( i , f , sum ) : <NEWLINE> <INDENT> if i == 3 : <NEWLINE> <INDENT> if sum == 7 : <NEWLINE> <INDENT> print ( f + <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> make7 ( i + 1 , f + <STRING> + S [ i + 1 ] , sum + S [ i + 1 ] ) <NEWLINE> make7 ( i + 1 , f + <STRING> + S [ i + 1 ] , sum - S [ i + 1 ] ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> S = input ( ) <NEWLINE> n = len ( S ) <NEWLINE> <NL> make7 ( 0 , S [ 0 ] , S [ 0 ] ) <NEWLINE>
n = input ( ) <NEWLINE> l = len ( n ) <NEWLINE> <NL> for i in range ( 2 ** l ) : <NEWLINE> <INDENT> op = [ <STRING> ] * l <NEWLINE> for j in range ( l ) : <NEWLINE> <INDENT> if ( i >> j ) & 1 : <NEWLINE> <INDENT> op [ l - j - 1 ] = <STRING> <COMMENT> <NEWLINE> <DEDENT> <DEDENT> formula = <STRING> <NEWLINE> for op1 , op2 in zip ( n , op + [ <STRING> ] ) : <COMMENT> <NEWLINE> <INDENT> formula += op1 + op2 <NEWLINE> <DEDENT> if eval ( formula ) == 7 : <NEWLINE> <INDENT> print ( formula + <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT>
import itertools <NEWLINE> x = list ( input ( ) ) <NEWLINE> <NL> for lst in itertools . product ( [ <STRING> , <STRING> ] , repeat = 3 ) <NEWLINE> <INDENT> sum = int ( x [ 0 ] ) <NEWLINE> for i in range ( 3 ) : <NEWLINE> <INDENT> if lst [ i ] == <STRING> : <NEWLINE> <INDENT> sum += int ( x [ i + 1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> sum -= int ( x [ i + 1 ] ) <NEWLINE> <DEDENT> <DEDENT> if sum == 7 : <NEWLINE> <INDENT> print ( x [ 0 ] + lst [ 0 ] + x [ 1 ] + lst [ 1 ] + x [ 2 ] + lst [ 2 ] + x [ 3 ] + <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT>
def dfs ( i , f , sum ) : <NEWLINE> <INDENT> if i == 3 and sum == 7 : <NEWLINE> <INDENT> print ( f + <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dfs ( i + 1 , f + <STRING> + s [ i + 1 ] , sum - int ( s [ i + 1 ] ) ) <NEWLINE> dfs ( i + 1 , f + <STRING> + s [ i + 1 ] , sum + int ( s [ i + 1 ] ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> s = input ( ) <NEWLINE> dfs ( 0 , s [ 0 ] , int ( s [ 0 ] ) ) <NEWLINE> <NL> <NL> <NL>
A , B , C , D = input ( ) <NEWLINE> for i in range ( 2 ** 3 ) : <NEWLINE> <INDENT> op = [ <STRING> , <STRING> , <STRING> ] <NEWLINE> <INDENT> for j in range ( len ( op ) ) : <NEWLINE> <INDENT> if ( i >> j ) & 1 : <NEWLINE> <INDENT> op [ j ] = <STRING> <NEWLINE> <NL> <NL> <NL> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <INDENT> A , B , C , D = input ( ) <NEWLINE> for i in range ( 2 ** 3 ) : <NEWLINE> <INDENT> op = [ <STRING> , <STRING> , <STRING> ] <NEWLINE> for j in range ( len ( op ) ) : <NEWLINE> <INDENT> if ( i >> j ) & 1 : <NEWLINE> <INDENT> op [ j ] = <STRING> <NEWLINE> <DEDENT> <DEDENT> if eval ( A + op [ 0 ] + B + op [ 1 ] + C + op [ 2 ] + D ) == 7 : <NEWLINE> <INDENT> print ( A + op [ 0 ] + B + op [ 1 ] + C + op [ 2 ] + D + <STRING> ) <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> main ( ) <NEWLINE> <DEDENT>
A , B , C , D = input ( ) . split ( ) <NEWLINE> <NL> for i in range ( 2 ** 3 ) : <NEWLINE> <INDENT> op = [ <STRING> ] * 3 <NEWLINE> for j in range ( 3 ) : <NEWLINE> <INDENT> if ( i >> j ) & 1 : <NEWLINE> <INDENT> op [ 3 - 1 - j ] = <STRING> <NEWLINE> <DEDENT> <DEDENT> if eval ( A + op [ 0 ] + B + op [ 1 ] + C + op [ 2 ] + D ) == 7 : <NEWLINE> <INDENT> print ( A + op [ 0 ] + B + op [ 1 ] + C + op [ 2 ] + D + <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT>
L = input ( ) <NEWLINE> a = int ( L [ 0 ] ) <NEWLINE> b = int ( L [ 1 ] ) <NEWLINE> c = int ( L [ 2 ] ) <NEWLINE> d = int ( L [ 3 ] ) <NEWLINE> <NL> import itertools <NEWLINE> <NL> A = ( 1 , - 1 ) <NEWLINE> <NL> def c ( x ) : <NEWLINE> <INDENT> if x == 1 : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> for v in itertools . product ( A , repeat = 3 ) : <NEWLINE> <INDENT> s = a + b * v [ 0 ] + c * v [ 1 ] + d * v [ 2 ] <NEWLINE> if s == 7 : <NEWLINE> <INDENT> print ( L [ 0 ] + c ( v [ 0 ] ) + L [ 1 ] + c ( v [ 1 ] ) + L [ 2 ] + c ( v [ 2 ] ) + L [ 3 ] + <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT>
n = input ( ) <NEWLINE> op_cnt = len ( n ) - 1 <COMMENT> <NEWLINE> for i in range ( 2 ** op_cnt ) : <NEWLINE> <INDENT> op = [ <STRING> ] * op_cnt <NEWLINE> for j in range ( op_cnt ) : <NEWLINE> <INDENT> if ( i >> j ) & 1 : <NEWLINE> <INDENT> op [ op_cnt - 1 - j ] = <STRING> <NEWLINE> formula = <STRING> <NEWLINE> for p_n , p_o in zip ( n , op + [ <STRING> ] ) : <NEWLINE> <INDENT> formula += ( p_n + p_o ) <NEWLINE> if eval ( formula ) == 7 : <NEWLINE> <INDENT> print ( formula + <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT>
n = input ( ) <NEWLINE> <NL> for i in range ( 2 ** 3 ) : <NEWLINE> <INDENT> ss = <STRING> <NEWLINE> for j in range ( 3 ) : <NEWLINE> <INDENT> ss += n [ j ] <NEWLINE> if ( ( i >> j ) & 1 == True ) : <NEWLINE> <INDENT> ss += <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ss += <STRING> <NEWLINE> <DEDENT> <DEDENT> ans = eval ( ss ) <NEWLINE> if ( ans == 7 ) : <NEWLINE> <INDENT> ss += <STRING> <NEWLINE> print ( ss ) <NEWLINE> <DEDENT> <DEDENT>
a , b , c , d = map ( lambda x : int ( x ) , list ( input ( ) ) ) <NEWLINE> <NL> cnt = 0 <NEWLINE> def get_str ( a ) : <NEWLINE> <INDENT> if a >= 0 : <NEWLINE> <INDENT> s = <STRING> . format ( a ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s = <STRING> . format ( a ) <NEWLINE> <DEDENT> return s <NEWLINE> <NL> <DEDENT> for i in range ( 1 << 4 - 1 ) : <NEWLINE> <INDENT> if ( i >> 3 ) % 2 == 0 : <NEWLINE> <INDENT> a = - a <NEWLINE> <DEDENT> if ( i >> 2 ) % 2 == 0 : <NEWLINE> <INDENT> b = - b <NEWLINE> <DEDENT> if ( i >> 1 ) % 2 == 0 : <NEWLINE> <INDENT> c = - c <NEWLINE> <DEDENT> if ( i >> 0 ) % 2 == 0 : <NEWLINE> <INDENT> d = - d <NEWLINE> <NL> <DEDENT> if a + b + c + d == 7 : <NEWLINE> <INDENT> s = <STRING> <NEWLINE> s += get_str ( a ) <NEWLINE> s += get_str ( b ) <NEWLINE> s += get_str ( c ) <NEWLINE> s += get_str ( d ) <NEWLINE> s += <STRING> <NEWLINE> if a >= 0 : <NEWLINE> <INDENT> print ( s [ 1 : : ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <DEDENT> <DEDENT>
a , b , c , d = input ( ) . split ( ) <NEWLINE> pm = <STRING> <NEWLINE> for i in pm : <NEWLINE> <INDENT> for j in pm : <NEWLINE> <INDENT> for k in pm : <NEWLINE> <INDENT> total = a + i + b + j + c + k + d <NEWLINE> if eval ( total ) == 7 : <NEWLINE> <INDENT> print ( total + <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT>
<NL> def a ( s , i ) : <NEWLINE> <INDENT> if i = l - 1 : <NEWLINE> <INDENT> if eval ( s ) == 7 : <NEWLINE> <INDENT> print ( s + <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> return <NEWLINE> <DEDENT> a ( s + <STRING> + N [ i + 1 ] , i + 1 ) <NEWLINE> a ( s + <STRING> + N [ i + 1 ] , i + 1 ) <NEWLINE> <NL> <DEDENT> N = input ( ) <NEWLINE> l = len ( N ) <NEWLINE> <NL> a ( N [ 0 ] , 0 ) <NEWLINE>
<COMMENT> <NL> <NL> S = input ( ) <NEWLINE> num = len ( S ) - 1 <NEWLINE> <NL> for i in range ( 2 ** num ) : <NEWLINE> <INDENT> op = [ <STRING> ] * num <NEWLINE> for j in range ( num ) : <NEWLINE> <INDENT> if ( i >> j ) & 1 : <NEWLINE> <INDENT> op [ num - j - 1 ] = <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> formula = <STRING> <NEWLINE> for op_S , op_num in zip ( S , num + [ <STRING> ] ) : <NEWLINE> <INDENT> formula += op_S + op_num <NEWLINE> <NL> <DEDENT> if eval ( formula ) == 7 : <NEWLINE> <INDENT> print ( formula + <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> <NL> input = sys . stdin . readline <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> nums = list ( map ( int , list ( input ( ) ) ) ) <NEWLINE> for i in range ( 8 ) : <NEWLINE> <INDENT> ts = sum ( nums ) <NEWLINE> ops = [ <STRING> ] * 3 <NEWLINE> for j in range ( 3 ) : <NEWLINE> <INDENT> if i >> j & 1 : <NEWLINE> <INDENT> ts -= nums [ j + 1 ] * 2 <NEWLINE> ops [ j ] = <STRING> <NEWLINE> <DEDENT> <DEDENT> if ts == 7 : <NEWLINE> <INDENT> for i in range ( 3 ) : <NEWLINE> <INDENT> ans += str ( nums [ i ] ) + ops [ i ] <NEWLINE> <DEDENT> ans += str ( nums [ 3 ] ) + <STRING> <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
<INDENT> lst = [ int ( a ) for a in input ( ) ] <NEWLINE> for bit in range ( 1 << len ( lst ) ) : <NEWLINE> <INDENT> sum = 0 <NEWLINE> op_lst = [ ] <NEWLINE> for i in range ( len ( lst ) ) : <NEWLINE> <INDENT> if bit & ( 1 << i ) : <NEWLINE> <INDENT> sum += lst [ i ] <NEWLINE> op_lst . append ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> sum -= lst [ i ] <NEWLINE> op_lst . append ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> if sum == 7 : <NEWLINE> <INDENT> print ( lst [ 0 ] , op_lst [ 1 ] , lst [ 1 ] , op_lst [ 2 ] , lst [ 2 ] , op_lst [ 3 ] , lst [ 3 ] , <STRING> , sep = <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
n = input ( ) <NEWLINE> l = len ( n ) - 1 <NEWLINE> <NL> for i in range ( 2 ** l ) : <NEWLINE> <INDENT> op = [ <STRING> ] * l <NEWLINE> for j in range ( l ) : <NEWLINE> <INDENT> if ( i >> j ) & 1 : <NEWLINE> <INDENT> op [ i - j - 1 ] = <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> formula = <STRING> <NEWLINE> for op_num , op_l in zip ( n , op + [ <STRING> ] ) : <NEWLINE> <INDENT> formula += op_num + op_l <NEWLINE> <DEDENT> if eval ( formula ) == 7 : <NEWLINE> <INDENT> print ( formula + <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT>
n = input ( ) <NEWLINE> op_cnt = len ( n ) - 1 <NEWLINE> for i in range ( 2 ** op_cnt ) : <NEWLINE> <INDENT> op = [ <STRING> ] * op_cnt <COMMENT> <NEWLINE> for j in range ( op_cnt ) : <NEWLINE> <INDENT> if ( ( i >> j ) & 1 ) : <NEWLINE> <INDENT> op [ - 1 - j ] = <STRING> <NEWLINE> formula = <STRING> <NEWLINE> <DEDENT> <DEDENT> for p_n , p_o in zip ( n , op + [ <STRING> ] ) : <COMMENT> <NEWLINE> <INDENT> formula += ( p_n + p_o ) <NEWLINE> <DEDENT> if eval ( formula ) == 7 : <COMMENT> <NEWLINE> <INDENT> print ( formula + <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT>
from itertools import product <NEWLINE> <NL> s = input ( ) <NEWLINE> <NL> for op in product ( [ <STRING> , <STRING> ] , repeat = len ( s ) - 1 ) : <NEWLINE> <INDENT> formula = <STRING> <NEWLINE> for i in range ( len ( s - 1 ) ) : <NEWLINE> <INDENT> formula += s [ i ] + op [ i ] <NEWLINE> <DEDENT> formula += s [ - 1 ] <NEWLINE> if eval ( formula ) == 7 : <NEWLINE> <INDENT> print ( formula + <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT>
def a ( t , i ) : <NEWLINE> <INDENT> if i = l - 1 : <NEWLINE> <INDENT> if eval ( t ) == 7 : <NEWLINE> <INDENT> print ( t + <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> return <NEWLINE> <DEDENT> a ( t + <STRING> + N [ i + 1 ] , i + 1 ) <NEWLINE> a ( t + <STRING> + N [ i + 1 ] , i + 1 ) <NEWLINE> <NL> <DEDENT> N = input ( ) <NEWLINE> l = len ( N ) <NEWLINE> a ( N [ 0 ] , 0 ) <NEWLINE> <NL> <NL> <NL> <NL>
<NL> ABCD = str ( input ( ) ) <NEWLINE> A = ABCD [ 0 ] <NEWLINE> B = ABCD [ 1 ] <NEWLINE> C = ABCD [ 2 ] <NEWLINE> D = ABCD [ 3 ] <NEWLINE> <NL> if int ( A ) + int ( B ) + int ( C ) + int ( D ) == 7 : <NEWLINE> <INDENT> print ( A + <STRING> + B + <STRING> + C + <STRING> + D + <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> if int ( A ) - int ( B ) + int ( C ) + int ( D ) == 7 : <NEWLINE> <INDENT> print ( A + <STRING> + B + <STRING> + C + <STRING> + D + <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> if int ( A ) + int ( B ) - int ( C ) + int ( D ) == 7 : <NEWLINE> <INDENT> print ( A + <STRING> + B + <STRING> + C + <STRING> + D + <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> if int ( A ) - int ( B ) - int ( C ) + int ( D ) == 7 : <NEWLINE> <INDENT> print ( A + <STRING> + B + <STRING> + C + <STRING> + D + <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> if int ( A ) + int ( B ) + int ( C ) - int ( D ) == 7 : <NEWLINE> <INDENT> print ( A + <STRING> + B + <STRING> + C + <STRING> + D + <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> if int ( A ) - int ( B ) + int ( C ) - int ( D ) == 7 : <NEWLINE> <INDENT> print ( A + <STRING> + B + <STRING> + C + <STRING> + D + <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> if int ( A ) + int ( B ) - int ( C ) - int ( D ) == 7 : <NEWLINE> <INDENT> print ( A + <STRING> + B + <STRING> + C + <STRING> + D + <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> if int ( A ) - int ( B ) - int ( C ) - int ( D ) == 7 : <NEWLINE> <INDENT> print ( A + <STRING> + B + <STRING> + C + <STRING> + D + <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT>
nums = input ( ) <NEWLINE> N = 3 <NEWLINE> for i in range ( 2 ** N ) : <NEWLINE> <INDENT> equation = <STRING> <NEWLINE> for j in range ( N + 1 ) : <NEWLINE> <INDENT> equation += nums [ j ] <NEWLINE> if ( ( i >> j ) & 1 ) : <NEWLINE> <INDENT> equation += <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> equation += <STRING> <NEWLINE> <DEDENT> <DEDENT> if eval ( equation ) == 7 : <NEWLINE> <INDENT> print ( equation + <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT>
S = input ( ) <NEWLINE> a = int ( S [ 0 ] ) <NEWLINE> b = int ( S [ 1 ] ) <NEWLINE> c = int ( S [ 2 ] ) <NEWLINE> d = int ( S [ 3 ] ) <NEWLINE> <NL> if ( a + b + c + d == 7 ) : <NEWLINE> <INDENT> print ( str ( a ) + <STRING> + str ( b ) + <STRING> + str ( c ) + <STRING> + str ( d ) + <STRING> ) <NEWLINE> <DEDENT> elif ( a + b + c - d == 7 ) : <NEWLINE> <INDENT> print ( str ( a ) + <STRING> + str ( b ) + <STRING> + str ( c ) + <STRING> + str ( d ) + <STRING> ) <NEWLINE> <DEDENT> elif ( a + b - c - d == 7 ) : <NEWLINE> <INDENT> print ( str ( a ) + <STRING> + str ( b ) + <STRING> + str ( c ) + <STRING> + str ( d ) + <STRING> ) <NEWLINE> <DEDENT> elif ( a - b - c - d == 7 ) : <NEWLINE> <INDENT> print ( str ( a ) + <STRING> + str ( b ) + <STRING> + str ( c ) + <STRING> + str ( d ) + <STRING> ) <NEWLINE> <DEDENT> elif ( a - b + c + d == 7 ) : <NEWLINE> <INDENT> print ( str ( a ) + <STRING> + str ( b ) + <STRING> + str ( c ) + <STRING> + str ( d ) + <STRING> ) <NEWLINE> <DEDENT> elif ( a - b - c + d == 7 ) : <NEWLINE> <INDENT> print ( str ( a ) + <STRING> + str ( b ) + <STRING> + str ( c ) + <STRING> + str ( d ) + <STRING> ) <NEWLINE> <DEDENT> elif ( a + b - c + d == 7 ) : <NEWLINE> <INDENT> print ( str ( a ) + <STRING> + str ( b ) + <STRING> + str ( c ) + <STRING> + str ( d ) + <STRING> ) <NEWLINE> <DEDENT> S = input ( ) <NEWLINE> a = int ( S [ 0 ] ) <NEWLINE> b = int ( S [ 1 ] ) <NEWLINE> c = int ( S [ 2 ] ) <NEWLINE> d = int ( S [ 3 ] ) <NEWLINE> <NL> if ( a + b + c + d == 7 ) : <NEWLINE> <INDENT> print ( str ( a ) + <STRING> + str ( b ) + <STRING> + str ( c ) + <STRING> + str ( d ) + <STRING> ) <NEWLINE> <DEDENT> elif ( a + b + c - d == 7 ) : <NEWLINE> <INDENT> print ( str ( a ) + <STRING> + str ( b ) + <STRING> + str ( c ) + <STRING> + str ( d ) + <STRING> ) <NEWLINE> <DEDENT> elif ( a + b - c - d == 7 ) : <NEWLINE> <INDENT> print ( str ( a ) + <STRING> + str ( b ) + <STRING> + str ( c ) + <STRING> + str ( d ) + <STRING> ) <NEWLINE> <DEDENT> elif ( a - b - c - d == 7 ) : <NEWLINE> <INDENT> print ( str ( a ) + <STRING> + str ( b ) + <STRING> + str ( c ) + <STRING> + str ( d ) + <STRING> ) <NEWLINE> <DEDENT> elif ( a - b + c + d == 7 ) : <NEWLINE> <INDENT> print ( str ( a ) + <STRING> + str ( b ) + <STRING> + str ( c ) + <STRING> + str ( d ) + <STRING> ) <NEWLINE> <DEDENT> elif ( a - b - c + d == 7 ) : <NEWLINE> <INDENT> print ( str ( a ) + <STRING> + str ( b ) + <STRING> + str ( c ) + <STRING> + str ( d ) + <STRING> ) <NEWLINE> <DEDENT> S = input ( ) <NEWLINE> a = int ( S [ 0 ] ) <NEWLINE> b = int ( S [ 1 ] ) <NEWLINE> c = int ( S [ 2 ] ) <NEWLINE> d = int ( S [ 3 ] ) <NEWLINE> <NL> if ( a + b + c + d == 7 ) : <NEWLINE> <INDENT> print ( str ( a ) + <STRING> + str ( b ) + <STRING> + str ( c ) + <STRING> + str ( d ) + <STRING> ) <NEWLINE> <DEDENT> elif ( a + b + c - d == 7 ) : <NEWLINE> <INDENT> print ( str ( a ) + <STRING> + str ( b ) + <STRING> + str ( c ) + <STRING> + str ( d ) + <STRING> ) <NEWLINE> <DEDENT> elif ( a + b - c - d == 7 ) : <NEWLINE> <INDENT> print ( str ( a ) + <STRING> + str ( b ) + <STRING> + str ( c ) + <STRING> + str ( d ) + <STRING> ) <NEWLINE> <DEDENT> elif ( a - b - c - d == 7 ) : <NEWLINE> <INDENT> print ( str ( a ) + <STRING> + str ( b ) + <STRING> + str ( c ) + <STRING> + str ( d ) + <STRING> ) <NEWLINE> <DEDENT> elif ( a - b + c + d == 7 ) : <NEWLINE> <INDENT> print ( str ( a ) + <STRING> + str ( b ) + <STRING> + str ( c ) + <STRING> + str ( d ) + <STRING> ) <NEWLINE> <DEDENT> elif ( a - b - c + d == 7 ) : <NEWLINE> <INDENT> print ( str ( a ) + <STRING> + str ( b ) + <STRING> + str ( c ) + <STRING> + str ( d ) + <STRING> ) <NEWLINE> <DEDENT> elif ( a + b - c + d == 7 ) : <NEWLINE> <INDENT> print ( str ( a ) + <STRING> + str ( b ) + <STRING> + str ( c ) + <STRING> + str ( d ) + <STRING> ) <NEWLINE> <DEDENT> S = input ( ) <NEWLINE> a = int ( S [ 0 ] ) <NEWLINE> b = int ( S [ 1 ] ) <NEWLINE> c = int ( S [ 2 ] ) <NEWLINE> d = int ( S [ 3 ] ) <NEWLINE> <NL> if ( a + b + c + d == 7 ) : <NEWLINE> <INDENT> print ( str ( a ) + <STRING> + str ( b ) + <STRING> + str ( c ) + <STRING> + str ( d ) + <STRING> ) <NEWLINE> <DEDENT> elif ( a + b + c - d == 7 ) : <NEWLINE> <INDENT> print ( str ( a ) + <STRING> + str ( b ) + <STRING> + str ( c ) + <STRING> + str ( d ) + <STRING> ) <NEWLINE> <DEDENT> elif ( a + b - c - d == 7 ) : <NEWLINE> <INDENT> print ( str ( a ) + <STRING> + str ( b ) + <STRING> + str ( c ) + <STRING> + str ( d ) + <STRING> ) <NEWLINE> <DEDENT> elif ( a - b - c - d == 7 ) : <NEWLINE> <INDENT> print ( str ( a ) + <STRING> + str ( b ) + <STRING> + str ( c ) + <STRING> + str ( d ) + <STRING> ) <NEWLINE> <DEDENT> elif ( a - b + c + d == 7 ) : <NEWLINE> <INDENT> print ( str ( a ) + <STRING> + str ( b ) + <STRING> + str ( c ) + <STRING> + str ( d ) + <STRING> ) <NEWLINE> <DEDENT> elif ( a - b - c + d == 7 ) : <NEWLINE> <INDENT> print ( str ( a ) + <STRING> + str ( b ) + <STRING> + str ( c ) + <STRING> + str ( d ) + <STRING> ) <NEWLINE> <DEDENT> elif ( a + b - c + d == 7 ) : <NEWLINE> <INDENT> print ( str ( a ) + <STRING> + str ( b ) + <STRING> + str ( c ) + <STRING> + str ( d ) + <STRING> ) <NEWLINE> <DEDENT>
def dump ( a , b , c ) : <NEWLINE> <INDENT> if a == operator . add : <NEWLINE> <INDENT> a = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a = <STRING> <NEWLINE> <DEDENT> if b == operator . add : <NEWLINE> <INDENT> b = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> b = <STRING> <NEWLINE> <DEDENT> if c == operator . add : <NEWLINE> <INDENT> c = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> c = <STRING> <NEWLINE> <DEDENT> print ( vals [ 0 ] + a + vals [ 1 ] + b + vals [ 2 ] + c + vals [ 3 ] + <STRING> ) <NEWLINE> <NL> <DEDENT> for a in ( operator . add , operator . sub ) : <NEWLINE> <INDENT> for b in ( operator . add , operator . sub ) : <NEWLINE> <INDENT> for c in ( operator . add , operator . sub ) : <NEWLINE> <INDENT> if c ( b ( a ( nums [ 0 ] , nums [ 1 ] ) , nums [ 2 ] ) , nums [ 3 ] ) == 7 : <NEWLINE> <INDENT> dump ( a , b , c ) <NEWLINE> exit ( 0 ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT>
ABCD = input ( ) <NEWLINE> A = int ( ABCD [ 0 ] ) <NEWLINE> B = int ( ABCD [ 1 ] ) <NEWLINE> C = int ( ABCD [ 2 ] ) <NEWLINE> D = int ( ABCD [ 3 ] ) <NEWLINE> for i in 1 : <NEWLINE> <NL> <INDENT> if A + B + C + D == 7 : <NEWLINE> <INDENT> print ( str ( A ) + <STRING> + str ( B ) + <STRING> + str ( C ) + <STRING> + str ( D ) + <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> if A - B + C + D == 7 : <NEWLINE> <INDENT> print ( str ( A ) + <STRING> + str ( B ) + <STRING> + str ( C ) + <STRING> + str ( D ) + <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> if A + B - C + D == 7 : <NEWLINE> <INDENT> print ( str ( A ) + <STRING> + str ( B ) + <STRING> + str ( C ) + <STRING> + str ( D ) + <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> if A + B + C - D == 7 : <NEWLINE> <INDENT> print ( str ( A ) + <STRING> + str ( B ) + <STRING> + str ( C ) + <STRING> + str ( D ) + <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> if A - B - C + D == 7 : <NEWLINE> <INDENT> print ( str ( A ) + <STRING> + str ( B ) + <STRING> + str ( C ) + <STRING> + str ( D ) + <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> if A - B + C - D == 7 : <NEWLINE> <INDENT> print ( str ( A ) + <STRING> + str ( B ) + <STRING> + str ( C ) + <STRING> + str ( D ) + <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> if A + B - C - D == 7 : <NEWLINE> <INDENT> print ( str ( A ) + <STRING> + str ( B ) + <STRING> + str ( C ) + <STRING> + str ( D ) + <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> if A - B - C - D == 7 : <NEWLINE> <INDENT> print ( str ( A ) + <STRING> + str ( B ) + <STRING> + str ( C ) + <STRING> + str ( D ) + <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> a , b , c , d = input ( ) <NEWLINE> for i in range ( 2 ** ( len ( op ) - 1 ) ) : <NEWLINE> <INDENT> op = [ <STRING> ] * 3 <NEWLINE> for j in range ( len ( op ) - 1 ) : <NEWLINE> <INDENT> if ( i >> j ) & 1 == 1 : <NEWLINE> <INDENT> op [ j ] = <STRING> <NEWLINE> <DEDENT> <DEDENT> if eval ( a + op [ 0 ] + b + op [ 1 ] + c + op [ 2 ] + d ) == 7 : <NEWLINE> <INDENT> print ( a + op [ 0 ] + b + op [ 1 ] + c + op [ 2 ] + d + <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT>
from networkx import * <NEWLINE> h , w = map ( int , input ( ) . split ( ) ) ; r = range ( 10 ) ; G = DiGraph ( ) ; G . add_nodes_from ( r ) ; C = [ [ * map ( int , input ( ) . split ( ) ) ] for _ in <STRING> * 10 ] ; G . add_weighted_edges_from ( [ ( i , j , C [ i ] [ j ] ) for i in r for j in r ] ) ; S = [ single_source_dijkstra_path_length ( G , i ) [ 1 ] for i in r ] ; A = [ [ * map ( int , input ( ) . split ( ) ) ] for _ in r ] ; print ( sum ( S [ abs ( x ) ] for a in A for x in a ) ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if a > b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a == b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b input ( ) . split ( ) <NEWLINE> if a == b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> if a < b else <STRING> ) <NEWLINE> <DEDENT>
x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> alp = <STRING> <NEWLINE> if x == y : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif alp . index ( x ) < alp . index ( y ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
print ( [ <STRING> , <STRING> , <STRING> ] [ min ( 2 , max ( 0 , 1 + int ( <STRING> + input ( ) ) - int ( <STRING> + input ( ) ) ) ) a , b = input ( ) . split ( ) <NEWLINE> print ( [ <STRING> , <STRING> , <STRING> ] [ min ( 2 , max ( 0 , 1 + int ( a , 16 ) - int ( b , 16 ) ) ) ] ) <NEWLINE>
a , b = map ( str , input ( ) . split ( ) ) <NEWLINE> List = [ <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> if a == b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> c = 0 <NEWLINE> d = 0 <NEWLINE> for i in range ( 6 ) : <NEWLINE> <INDENT> if a == List [ i ] : <NEWLINE> <INDENT> c = i <NEWLINE> <DEDENT> if b == List [ i ] : <NEWLINE> <INDENT> d = i <NEWLINE> <DEDENT> <DEDENT> if c < d : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif d < c : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
<COMMENT> <NL> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <COMMENT> <NL> p = ( 1 / 2 ) ** M <NEWLINE> <NL> <COMMENT> <NL> E = 1 / p <NEWLINE> ans = ( 1900 * M + 100 * ( N - M ) ) * E <NEWLINE> ans = round ( ans ) <NEWLINE> print ( ans ) <NEWLINE>
a , b = input ( ) <NEWLINE> if a == b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a > b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
l = [ <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> if l . index ( x ) > l . index ( y ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif l . index ( x ) < l . index ( y ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
A , B , C , D , E , F = 10 , 11 , 12 , 13 , 14 , 15 <NEWLINE> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> if x < y : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif x > y : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b = input ( ) . split ( ) <NEWLINE> if a > b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else if a < b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else if a == b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
X , Y = map ( int , input ( ) . split ( ) ) <NEWLINE> if X < Y : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif X > Y : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> if x < y : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif x > y : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> if ord ( x ) < ord ( y ) : print ( <STRING> ) <NEWLINE> elif ord ( x ) > ord ( y ) : print ( <STRING> ) <NEWLINE> else : print ( <STRING> ) <NEWLINE>
lst = [ <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> a = input ( ) <NEWLINE> if lst . index ( a [ 0 ] ) > lst . index ( a [ 1 ] ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif lst . index ( a [ 0 ] ) == lst . index ( a [ 1 ] ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
A = 1 <NEWLINE> B = 2 <NEWLINE> C = 3 <NEWLINE> D = 4 <NEWLINE> E = 5 <NEWLINE> F = 6 <NEWLINE> X , Y = input ( ) . split ( ) <NEWLINE> if X < Y : <NEWLINE> <INDENT> pritn ( <STRING> ) <NEWLINE> <DEDENT> elif X > Y : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif X == Y : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b = input ( ) . split ( ) <NEWLINE> if a < b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elsif a > b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
A , B = input ( ) . split ( ) <NEWLINE> <NL> mydict = { <STRING> : 11 , <STRING> : 12 , <STRING> : 14 , <STRING> : 13 , <STRING> : 14 , <STRING> : 15 } <NEWLINE> <NL> print ( <STRING> ) if mydict ( A ) > mydict ( B ) else print ( <STRING> ) if mydict ( A ) < mydict ( B ) else print ( <STRING> ) <NEWLINE>
a , b = input ( ) . split ( ) <NEWLINE> if a . isalpha ( ) > b . isalpha ( ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a . isalpha ( ) < b . isalpha ( ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> else : <NEWLINE> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b = map ( input ( ) ) <NEWLINE> if a == b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a < b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
x , y , z = map ( int ( input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> x -= ( y + 2 * z ) <NEWLINE> print ( ans + x // ( y + z ) ) <NEWLINE>
a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( ( a - b - 2 * c ) // ( b + C ) + 1 ) <NEWLINE>
<NL> a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> <COMMENT> <NL> print ( ( a - c ) // ( b + z ) ) <NEWLINE>
x , y , z = map ( int , input ( ) . split ( ) ) <NEWLINE> while True : <NEWLINE> <INDENT> n = 0 <NEWLINE> if n * y + ( n + 1 ) * z > x : <NEWLINE> <INDENT> print ( n - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> n += 1 <NEWLINE> <DEDENT>
64145 123 456 <NEWLINE>
import sys <NEWLINE> import math <NEWLINE> import itertools <NEWLINE> import collections <NEWLINE> import heapq <NEWLINE> import re <NEWLINE> import numpy as np <NEWLINE> <NL> rr = lambda : sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> rs = lambda : sys . stdin . readline ( ) . split ( ) <NEWLINE> ri = lambda : int ( sys . stdin . readline ( ) ) <NEWLINE> rm = lambda : map ( int , sys . stdin . readline ( ) . split ( ) ) <NEWLINE> rl = lambda : list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) <NEWLINE> inf = float ( <STRING> ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> n , m = ri ( ) <NEWLINE> print ( ( m * 1900 + ( n - m ) * 100 ) * 2 ** m ) <NEWLINE> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL>
import sys <NEWLINE> import math <NEWLINE> import heapq <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> inf = float ( <STRING> ) <NEWLINE> from math import sqrt <NEWLINE> from collections import deque <NEWLINE> from collections import Counter <NEWLINE> from collections import defaultdict <NEWLINE> <COMMENT> <NL> from collections import OrderedDict <NEWLINE> <COMMENT> <NL> from math import ceil <NEWLINE> input = lambda : sys . stdin . readline ( ) . strip ( ) <NEWLINE> sys . setrecursionlimit ( 11451419 ) <NEWLINE> from decimal import Decimal <COMMENT> <NEWLINE> from functools import lru_cache <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> A = 100 * ( n - m ) + 1900 * m <NEWLINE> p = pow ( 2 , m ) <NEWLINE> <NL> @ lru_cache ( maxsize = 10 ** 10 ) <NEWLINE> def per ( n ) : <NEWLINE> <INDENT> if n == 1 : <NEWLINE> <INDENT> return 1 / p <NEWLINE> <DEDENT> return ( 1 - sum ( [ per ( i ) for i in range ( 1 , n ) ] ) ) * ( 1 / p ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in range ( 1 , 10000 ) : <NEWLINE> <INDENT> ans += i * A * per ( i ) <NEWLINE> <DEDENT> print ( round ( ans ) ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( 1900 * M + 100 * ( N - M ) ) * 2 ** M <NEWLINE>
N , M = map ( int . input ( ) . split ( ) ) <NEWLINE> ans = ( 1900 * M + 100 * ( N - M ) ) * ( 2 ** M ) <NEWLINE> print ( ans ) <NEWLINE>
N , Z , W = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> print ( abs ( W - a [ 0 ] ) if n == 1 else max ( abs ( W - a [ - 1 ] ) , abs ( a [ - 1 ] - a [ - 2 ] ) ) ) <NEWLINE>
from collections import deque <NEWLINE> class Dinic : <NEWLINE> <INDENT> def __init__ ( self , N ) : <NEWLINE> <INDENT> elf . N = N <NEWLINE> self . G = [ [ ] for i in range ( N ) ] <NEWLINE> <NL> <DEDENT> def add_edge ( self , fr , to , cap ) : <NEWLINE> <INDENT> forward = [ to , cap , None ] <NEWLINE> forward [ 2 ] = backward = [ fr , 0 , forward ] <NEWLINE> self . G [ fr ] . append ( forward ) <NEWLINE> self . G [ to ] . append ( backward ) <NEWLINE> <NL> <DEDENT> def add_multi_edge ( self , v1 , v2 , cap1 , cap2 ) : <NEWLINE> <INDENT> edge1 = [ v2 , cap1 , None ] <NEWLINE> edge1 [ 2 ] = edge2 = [ v1 , cap2 , edge1 ] <NEWLINE> self . G [ v1 ] . append ( edge1 ) <NEWLINE> self . G [ v2 ] . append ( edge2 ) <NEWLINE> <NL> <DEDENT> def bfs ( self , s , t ) : <NEWLINE> <INDENT> self . level = level = [ None ] * self . N <NEWLINE> deq = deque ( [ s ] ) <NEWLINE> level [ s ] = 0 <NEWLINE> G = self . G <NEWLINE> while deq : <NEWLINE> <INDENT> v = deq . popleft ( ) <NEWLINE> lv = level [ v ] + 1 <NEWLINE> for w , cap , _ in G [ v ] : <NEWLINE> <INDENT> if cap and level [ w ] is None : <NEWLINE> <INDENT> level [ w ] = lv <NEWLINE> deq . append ( w ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return level [ t ] is not None <NEWLINE> <NL> <DEDENT> def dfs ( self , v , t , f ) : <NEWLINE> <INDENT> if v == t : <NEWLINE> <INDENT> return f <NEWLINE> <DEDENT> level = self . level <NEWLINE> for e in self . it [ v ] : <NEWLINE> <INDENT> w , cap , rev = e <NEWLINE> if cap and level [ v ] < level [ w ] : <NEWLINE> <INDENT> d = self . dfs ( w , t , min ( f , cap ) ) <NEWLINE> if d : <NEWLINE> <INDENT> e [ 1 ] -= d <NEWLINE> rev [ 1 ] += d <NEWLINE> return d <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return 0 <NEWLINE> <NL> <DEDENT> def flow ( self , s , t ) : <NEWLINE> <INDENT> flow = 0 <NEWLINE> INF = 10 ** 9 + 7 <NEWLINE> G = self . G <NEWLINE> while self . bfs ( s , t ) : <NEWLINE> <INDENT> * self . it , = map ( iter , self . G ) <NEWLINE> f = INF <NEWLINE> while f : <NEWLINE> <INDENT> f = self . dfs ( s , t , INF ) <NEWLINE> flow += f <NEWLINE> <DEDENT> <DEDENT> return flow <NEWLINE> <NL> <NL> <NL> <DEDENT> <DEDENT> import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> score = 0 <NEWLINE> INF = float ( <STRING> ) <NEWLINE> graph = Dinic ( n + 2 ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> if a [ i ] > 0 : <NEWLINE> <INDENT> graph . add_edge ( i + 1 , n + 1 , a [ i ] ) <NEWLINE> score += a [ i ] <NEWLINE> <DEDENT> elif a [ i ] < 0 : <NEWLINE> <INDENT> graph . add_edge ( 0 , i + 1 , - a [ i ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( 1 , n // 2 + 1 ) : <NEWLINE> <INDENT> for j in range ( 2 * i , n + 1 , i ) : <NEWLINE> <INDENT> graph . add_edge ( i , j , INF ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( score - graph . flow ( 0 , n + 1 ) ) <NEWLINE> <NL>
A = input ( ) . split ( ) <NEWLINE> B = input ( ) . split ( ) <NEWLINE> if A [ 0 ] == B [ 2 ] and A [ 1 ] == B [ 1 ] and A [ 2 ] == B [ 0 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> t = input ( ) <NEWLINE> s . reverse ( ) <NEWLINE> <NL> if s == t : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
x = str ( input ( ) ) <NEWLINE> y = str ( input ( ) ) <NEWLINE> z = x . reversed ( ) <NEWLINE> w = y . reversed ( ) <NEWLINE> if x == w and y == z : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
L = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> R = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if L [ 0 ] == R [ 2 ] and L [ 1 ] == R [ 1 ] and L [ 2 ] == R [ 0 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
for x , y in zip ( input ( ) , reversed ( input ) ) : <NEWLINE> <INDENT> if x != y : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n , s = map ( str , input ( ) . split ( ) ) <NEWLINE> if n [ 0 ] == s [ 2 ] and n [ 1 ] == s [ 1 ] and n [ 2 ] == s [ 0 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT>
<COMMENT> <NL> <NL> def atc_077a ( input_value : str ) -> str : <NEWLINE> <INDENT> C1 = input_value [ 0 ] <NEWLINE> C2 = input_value [ 1 ] <NEWLINE> <NL> if C1 [ 0 ] == C2 [ 2 ] and C1 [ 1 ] == C2 [ 1 ] and C1 [ 2 ] == C2 [ 0 ] <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> C1 = input ( ) <NEWLINE> C2 = input ( ) <NEWLINE> print ( atc_077a ( [ C1 , C2 ] ) ) <NEWLINE>
c = input ( ) <NEWLINE> d = input ( ) <NEWLINE> if c [ 0 ] == d [ 3 ] and c [ 1 ] == d [ 1 ] and c [ 2 ] == d [ 0 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b = input ( ) <NEWLINE> if a [ 0 ] == b [ 2 ] and a [ 1 ] == b [ 1 ] and a [ 2 ] == b [ 0 ] : print ( <STRING> ) <NEWLINE> else : print ( <STRING> ) <NEWLINE>
c11 , c12 , c13 = map ( int , input ( ) . split ( ) ) <NEWLINE> c21 , c22 , c23 = map ( int , input ( ) . split ( ) ) <NEWLINE> if c11 == c23 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif c12 == c22 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif c13 == c31 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
x = [ list ( map ( str , input ( ) . split ( ) ) ) for i in range ( 2 ) ] <NEWLINE> if x [ 0 ] [ 0 ] == x [ 1 ] [ 2 ] and x [ 0 ] [ 1 ] == x [ 1 ] [ 1 ] and x [ 1 ] [ 0 ] == x [ 0 ] [ 2 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
S1 = input ( ) <NEWLINE> S2 = input ( ) <NEWLINE> if S1 . reverse == S2 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b = input ( ) . split ( ) <NEWLINE> if a [ 0 ] == b [ 2 ] and a [ 1 ] == b [ 1 ] and a [ 2 ] == b [ 0 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
x = input ( ) <NEWLINE> y = input ( ) <NEWLINE> if x [ : : - 1 ] = y : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
c1 = input ( ) <NEWLINE> c2 = input ( ) <NEWLINE> print ( <STRING> if c1 = c2 [ - 1 : : - 1 ] else <STRING> ) <NEWLINE>
<NL> C = str ( input ( ) ) <NEWLINE> <NL> <NL> if C [ 0 ] == C [ 5 ] and C [ 1 ] == C [ 4 ] and C [ 2 ] == C [ 3 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> <NL> x = 0 <NEWLINE> while 1 : <NEWLINE> <INDENT> if x ** 2 > n : <NEWLINE> <INDENT> print ( ( x - 1 ) ** 2 ) <NEWLINE> <DEDENT> x += 1 <NEWLINE> <DEDENT>
import math <NEWLINE> print ( math . floor ( math . sqrt ( int ( input ( ) ) ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> C = 0 <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> if i ** 2 < N : <NEWLINE> <INDENT> C = i ** 2 <NEWLINE> <DEDENT> elif i ** 2 = N : <NEWLINE> <INDENT> C = i ** 2 <NEWLINE> break <NEWLINE> <DEDENT> elif i ** 2 > N : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> print ( C ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> a = 1 <NEWLINE> <NL> while a <= n : <NEWLINE> <INDENT> b = a <NEWLINE> a **= 2 <NEWLINE> <NL> <DEDENT> print ( b ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> <NL> <NL> while N > i ** 2 : <NEWLINE> <INDENT> i += 1 <NEWLINE> <NL> <DEDENT> print ( ( i - 1 ) ** 2 ) <NEWLINE>
for x in range ( int ( input ( ) ) ) : <NEWLINE> <INDENT> if x ** 2 > n : <NEWLINE> <INDENT> print ( x - 1 ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> N = int ( input ( ) ) <NEWLINE> if N = 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif N = 2 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( N ) : <NEWLINE> <INDENT> if i ** 2 > N : <NEWLINE> <INDENT> print ( ( i - 1 ) ** 2 ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
x = int ( input ( ) ) <NEWLINE> a = [ 0 ] <NEWLINE> for i in range ( 10 ** 5 ) : <NEWLINE> <INDENT> if i ** 2 < x : <NEWLINE> <INDENT> a . add ( i ** 2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> print ( max ( a ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> x = int ( sqrt ( n ) ) <NEWLINE> print ( x ** 2 ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> k = int ( input ( ) ) <NEWLINE> ref = 1 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> if ref * 2 < ref + k : <NEWLINE> <INDENT> ref *= 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ref += k <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ref ) <NEWLINE>
a = int ( input ( ) ) <NEWLINE> while i ** 2 <= a : <NEWLINE> <INDENT> i = i + 1 <NEWLINE> <DEDENT> print ( i ** 2 ) <NEWLINE>
import math <NEWLINE> N = int ( input ( ) ) <NEWLINE> ans = 1 <NEWLINE> for i in range ( 10 ** 5 ) : <NEWLINE> <INDENT> if i ** 2 = < N : <NEWLINE> <INDENT> ans = i ** 2 <NEWLINE> <DEDENT> if i ** 2 > N : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> x = int ( input ( ) ) <NEWLINE> y = math . sqrt ( x ) <NEWLINE> z = y // 1 <NEWLINE> print ( int ( z ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> C = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A . sort ( ) <NEWLINE> B . sort ( ) <NEWLINE> C . sort ( ) <NEWLINE> ans = 0 <NEWLINE> for b in B : <NEWLINE> <INDENT> a = bisect_left ( A , b ) <NEWLINE> c = bisect_right ( C , b ) <NEWLINE> ans += a * ( N - c ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import bisect <NEWLINE> N = int ( input ( ) ) <NEWLINE> top = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> middle = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> bottom = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> top . sort ( ) <NEWLINE> middle . sort ( ) <NEWLINE> bottom . sort ( ) <NEWLINE> <NL> ans = 0 <NEWLINE> for i in middle : <NEWLINE> <INDENT> can_put_upstair = bisect . bisect_left ( top , i ) <NEWLINE> can_put_donwstair = N - bisect . bisect_right ( bottom , i ) <NEWLINE> ans += can_put_upstair * can_put_downstair <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <COMMENT> <NL> a = sorted ( a ) <NEWLINE> b = sorted ( b ) <NEWLINE> c = sorted ( c ) <NEWLINE> <NL> <COMMENT> <NL> def lower_bound ( arr , x ) : <NEWLINE> <INDENT> l = 0 <NEWLINE> r = len ( arr ) - 1 <COMMENT> <NEWLINE> while l <= r : <NEWLINE> <INDENT> mid = ( l + r ) // 2 <COMMENT> <NEWLINE> if x == arr [ mid ] : <COMMENT> <NEWLINE> <INDENT> return mid + 1 <NEWLINE> <DEDENT> elif x < arr [ mid ] : <COMMENT> <NEWLINE> <INDENT> r = mid - 1 <NEWLINE> <DEDENT> else : <COMMENT> <NEWLINE> <INDENT> l = mid + 1 <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> if x > arr [ - 1 ] : <NEWLINE> <INDENT> return - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return r + 1 <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> def upper_bound ( arr , x ) : <NEWLINE> <INDENT> l = 0 <NEWLINE> r = len ( arr ) - 1 <COMMENT> <NEWLINE> while l <= r : <NEWLINE> <INDENT> mid = ( l + r ) // 2 <COMMENT> <NEWLINE> if x == arr [ mid ] : <COMMENT> <NEWLINE> <INDENT> return mid - 1 <NEWLINE> <DEDENT> elif x < arr [ mid ] : <COMMENT> <NEWLINE> <INDENT> r = mid - 1 <NEWLINE> <DEDENT> else : <COMMENT> <NEWLINE> <INDENT> l = mid + 1 <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> if x < arr [ 0 ] : <NEWLINE> <INDENT> return - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return r <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> count = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a_count = upper_bound ( a , b [ i ] ) + 1 <COMMENT> <NEWLINE> c_count = lower_bound ( c , b [ i ] ) + 1 <COMMENT> <NEWLINE> if a_count = - 1 or c_count = - 1 : <NEWLINE> <INDENT> count = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> count += a_count * ( len ( c ) - c_count + 1 ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
import bisect <NEWLINE> n = int ( input ( ) ) <NEWLINE> x = sorted ( list ( map ( int , input ( ) . split ( ) ) ) , reverse = True ) <NEWLINE> y = sorted ( list ( map ( int , input ( ) . split ( ) ) ) , reverse = True ) <NEWLINE> z = sorted ( list ( map ( int , input ( ) . split ( ) ) ) , reverse = True ) <NEWLINE> count = 0 <NEWLINE> X = [ ] <NEWLINE> for b in range ( n ) : <NEWLINE> <INDENT> k = bisect . bisect_right ( x , y [ b ] ) <NEWLINE> X [ b ] = ( n - k ) <NEWLINE> <DEDENT> for a in range ( n ) : <NEWLINE> <INDENT> j = bisect . bisect_right ( y , z [ a ] ) <NEWLINE> count += sum ( X [ j : ] ) <NEWLINE> <DEDENT> print ( count ) <NEWLINE>
import sys <NEWLINE> import bisect <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> input = sys . stdin . buffer . readline <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A . sort ( ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B . sort ( ) <NEWLINE> C = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> for i in B : <NEWLINE> <INDENT> a = bisect . bisect_left ( A , b ) <NEWLINE> c = bisect . bisect_right ( C , b ) <NEWLINE> ans += a * ( N - c ) <NEWLINE> <DEDENT> print ( sum ( A_count ) ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
from bisect import bisect_left , bisect_right <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> an . sort ( ) <NEWLINE> bn . sort ( ) <NEWLINE> cn . sort ( ) <NEWLINE> <NL> cnt = 0 <NEWLINE> <NL> for b in bn : <NEWLINE> <INDENT> a = bisect_left ( an , b ) <NEWLINE> c = bisect_right ( cn , b ) <NEWLINE> cnt += a * ( n - c ) <NEWLINE> <DEDENT> print ( cnt ) <NEWLINE>
import sys <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> n = sys . stdin . readline ( ) <NEWLINE> <NL> astr = sys . stdin . readline ( ) <NEWLINE> bstr = sys . stdin . readline ( ) <NEWLINE> cstr = sys . stdin . readline ( ) <NEWLINE> <NL> a = list ( map ( int , astr . strip ( ) . split ( <STRING> ) ) ) <NEWLINE> b = list ( map ( int , bstr . strip ( ) . split ( <STRING> ) ) ) <NEWLINE> c = list ( map ( int , cstr . strip ( ) . split ( <STRING> ) ) ) <NEWLINE> <NL> a . sort ( ) <NEWLINE> b . sort ( ) <NEWLINE> c . sort ( ) <NEWLINE> <NL> cnt = 0 <NEWLINE> <NL> bc = [ ] <NEWLINE> sum = 0 <NEWLINE> for bi in reversed ( b ) : <NEWLINE> <INDENT> ct = c [ binary ( bi , c ) : ] <NEWLINE> sum += len ( ct ) <NEWLINE> bc . append ( sum ) <NEWLINE> <DEDENT> bc . reverse ( ) <NEWLINE> <NL> cnt = 0 <NEWLINE> for ai in a : <NEWLINE> <INDENT> bi = binary ( ai , b ) <NEWLINE> cnt += bc [ bi ] <NEWLINE> <NL> <DEDENT> print ( cnt ) <NEWLINE> <NL> <NL> <DEDENT> def binary ( x , li ) : <NEWLINE> <INDENT> upper = len ( li ) <NEWLINE> lower = - 1 <NEWLINE> index = int ( ( upper + lower ) / 2 ) <NEWLINE> <NL> <NL> while upper - lower > 1 : <NEWLINE> <INDENT> if ( x < li [ index ] ) : <NEWLINE> <INDENT> upper = index <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> lower = index <NEWLINE> <DEDENT> index = int ( ( upper + lower ) / 2 ) <NEWLINE> <NL> <DEDENT> return upper <NEWLINE> <NL> <NL> <DEDENT> main ( ) <NEWLINE>
import sys <NEWLINE> from bisect import bisect <NEWLINE> from itertools import accumulate <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> input = sys . stdin . buffer . readline <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = sorted ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = sorted ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c = sorted ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <COMMENT> <NL> b_c_cnt = [ len ( c [ bisect ( c , b [ i ] ) : ] ) for i in range ( n ) ] <NEWLINE> <COMMENT> <NL> acc = list ( accumulate ( b_c_cnt [ : : - 1 ] ) ) [ : : - 1 ] <NEWLINE> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ans += acc [ bisect ( b , a [ i ] ) ] <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> abc = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( 3 ) ] <NEWLINE> sum = 0 <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> abc [ 1 ] . append ( abc [ 0 ] [ i ] ) <NEWLINE> abc [ 1 ] . sort ( ) <NEWLINE> abc [ 2 ] . sort ( ) <NEWLINE> p = abc [ 1 ] . index ( abc [ 0 ] [ i ] ) <NEWLINE> for k in range ( p + 1 , n ) : <NEWLINE> <INDENT> abc [ 2 ] . append ( a [ 1 ] [ k ] ) <NEWLINE> q = abc [ 2 ] . index ( abc [ 1 ] [ k ] ) <NEWLINE> sum += n - q - 1 <NEWLINE> abc [ 1 ] . remove ( abc [ 0 ] [ i ] ) <NEWLINE> abc [ 2 ] . remove ( a [ 1 ] [ k ] ) <NEWLINE> <DEDENT> <DEDENT> print ( sum ) <NEWLINE> <NL> <NL>
import sys <NEWLINE> from bisect import bisect_right <NEWLINE> read = sys . stdin . read <NEWLINE> readline = sys . stdin . readline <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> n = int ( readline ( ) ) <NEWLINE> a , b , c = ( list ( map ( int , lst . split ( ) ) ) for lst in read ( ) . splitlines ( ) ) <NEWLINE> a . sort ( ) <NEWLINE> b . sort ( ) <NEWLINE> c = [ - x for x in c ] <NEWLINE> c . sort ( ) <NEWLINE> print ( sum ( bisect_right ( x , a ) * bisect_right ( - x , c ) for x in b ) ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <NL> <NL> <DEDENT>
from heapq import heappush , heappop <NEWLINE> <NL> <NL> def dijkstra ( graph : list , n : int , v_s : int , INF : int = float ( <STRING> ) ) -> list : <NEWLINE> <COMMENT> <NL> <INDENT> dist = [ INF ] * n <NEWLINE> <NL> dist [ v_s ] = 0 <NEWLINE> heap = [ ( 0 , v_s ) ] <COMMENT> <NEWLINE> while heap : <NEWLINE> <INDENT> dist2v , v_from = heappop ( heap ) <NEWLINE> if dist [ v_from ] < dist2v : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> for cost , v_to in graph [ v_from ] : <NEWLINE> <INDENT> dist_cand = dist2v + cost <NEWLINE> if dist_cand < dist [ v_to ] : <NEWLINE> <INDENT> dist [ v_to ] = dist_cand <NEWLINE> heappush ( heap , ( dist [ v_to ] , v_to ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return dist <NEWLINE> <NL> <NL> <DEDENT> k = int ( input ( ) ) <NEWLINE> <NL> graph = [ [ ] for _ in range ( k ) ] <NEWLINE> for i in range ( 1 , k ) : <NEWLINE> <INDENT> graph [ i ] . append ( ( 1 , i + 1 ) ) <NEWLINE> graph [ i ] . append ( ( 0 , 10 * i % k ) ) <NEWLINE> <NL> <DEDENT> dist = dijkstra ( graph , k , 1 ) <NEWLINE> ans = dist [ 0 ] + 1 <NEWLINE> print ( ans ) <NEWLINE>
import bisect <NEWLINE> from collections import deque <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> C = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A . sort ( ) <NEWLINE> B . sort ( ) <NEWLINE> C . sort ( ) <NEWLINE> <NL> d = deque ( [ ] ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> n = bisect . bisect_right ( C , B [ N - 1 - i ] ) <NEWLINE> if len ( d ) == 0 : <NEWLINE> <INDENT> d . appendleft ( N - n ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d . appendleft ( N - n + d [ 0 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> n = bisect . bisect_right ( B , A [ i ] ) <NEWLINE> ans += d [ n ] <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> C = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> A = sorted ( A ) <NEWLINE> B = sorted ( B ) <NEWLINE> C = sorted ( C ) <NEWLINE> <NL> <COMMENT> <NL> import bisect as bis <NEWLINE> <NL> for i in range ( 0 , N ) : <NEWLINE> <INDENT> BSC [ i ] = N - bis . bisect_right ( C , B [ i ] ) <NEWLINE> <DEDENT>
a = int ( input ( ) ) <NEWLINE> b = int ( input ( ) ) <NEWLINE> res = 2 * b - A <NEWLINE> print ( res ) <NEWLINE>
r = int ( input ( ) ) <NEWLINE> g = int ( input ( ) ) <NEWLINE> print ( 2 g - r ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( b * 2 - a ) <NEWLINE>
r = int ( input ( ) ) <NEWLINE> g = int ( input ( ) ) <NEWLINE> print ( g * 2 - a ) <NEWLINE>
r , g = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( 2 * g - r ) <NEWLINE>
a = int ( input ( ) ) <NEWLINE> b = int ( input ( ) ) <NEWLINE> print ( 2 b - a ) <NEWLINE>
R , G = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( G * 2 - R ) <NEWLINE>
print ( - input ( ) + input ( ) * 2 ) <NEWLINE>
R = int ( input ( ) ) <NEWLINE> G = int ( input ( ) ) <NEWLINE> <NL> sa = G - B <NEWLINE> print ( G + sa ) <NEWLINE>
R , G = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> print ( 2 * G - R ) <NEWLINE>
R , G = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( 2 * G - R ) <NEWLINE>
R , G = ( int ( x ) for x in input ( ) . split ( ) ) <NEWLINE> ans = 2 * G - R <NEWLINE> print ( ans ) <NEWLINE>
print ( chr ( ord ( input ( ) ) + 1 ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> K = int ( input ( ) ) <NEWLINE> a = 1 <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> a = min ( a * 2 , a + k ) <NEWLINE> <DEDENT> print ( a ) <NEWLINE>
<NL> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> dis = 1 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if dis * 2 <= dis + k : <NEWLINE> <INDENT> dis *= 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dis += k <NEWLINE> <DEDENT> <DEDENT> print ( dis ) <NEWLINE>
<NL> def main ( ) : <NEWLINE> <NL> <INDENT> S_part = list ( input ( ) ) <NEWLINE> T_hint = list ( input ( ) ) <NEWLINE> <NL> N = len ( S_part ) <NEWLINE> ans = [ ] <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> index_init = i <NEWLINE> <NL> if ( index_init + len ( T_hint ) <= N ) : <NEWLINE> <INDENT> s = S_part [ index_init : index_init + len ( T_hint ) ] <NEWLINE> module = <STRING> . join ( S_part [ index_init + len ( T_hint ) ] ) <NEWLINE> <NL> <NL> if ( <STRING> in s ) : <NEWLINE> <INDENT> FLAG = True <NEWLINE> <NL> for j in range ( len ( s ) ) : <NEWLINE> <INDENT> if ( T_hint [ j ] != s [ j ] and s [ j ] == <STRING> ) : <NEWLINE> <INDENT> s [ j ] = T_hint [ j ] <NEWLINE> <NL> <DEDENT> elif ( T_hint [ j ] != s [ j ] and s [ j ] != <STRING> ) : <NEWLINE> <INDENT> FLAG = False <NEWLINE> break <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if ( FLAG ) : <NEWLINE> <INDENT> ans_left = <STRING> . join ( S_part [ : index_init ] ) <NEWLINE> ans_right = <STRING> . join ( s ) <NEWLINE> <NL> <COMMENT> <NL> tmp_ans = ans_left + ans_right + module <NEWLINE> <NL> <NL> tmp_ans = tmp_ans . replace ( <STRING> , <STRING> ) <NEWLINE> <NL> ans . append ( tmp_ans ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> ans . sort ( ) <NEWLINE> <NL> if ( S_part . count ( <STRING> ) == 0 ) : <NEWLINE> <INDENT> print ( S_part ) <NEWLINE> <DEDENT> elif ( len ( ans ) > 0 ) : <NEWLINE> <INDENT> print ( ans [ 0 ] ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
from copy import deepcopy <NEWLINE> S = list ( input ( ) ) <NEWLINE> T = list ( input ( ) ) <NEWLINE> s_num = len ( S ) <NEWLINE> t_num = len ( T ) <NEWLINE> S_copy = deepcopy ( S ) <NEWLINE> if s < t : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( s_num - t_num , - 1 , - 1 ) : <NEWLINE> <INDENT> s_key = S [ i : i + t_num ] <NEWLINE> judge = 0 <NEWLINE> for s , t in zip ( s_key , T ) : <NEWLINE> <INDENT> if s == <STRING> : <NEWLINE> <INDENT> judge += 1 <NEWLINE> <DEDENT> elif s == t : <NEWLINE> <INDENT> judge += 1 <NEWLINE> <DEDENT> <DEDENT> if judge == t_num : <NEWLINE> <INDENT> S_copy [ i : i + t_num ] = T <NEWLINE> <DEDENT> <DEDENT> if S == S_copy : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in S_copy : <NEWLINE> <INDENT> if i == <STRING> : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( i , end = <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT>
s , t = input ( ) , input ( ) ; l , m = len ( s ) , len ( t ) <NEWLINE> for i in range ( l - m + 1 ) : <NEWLINE> <INDENT> if all ( c in <STRING> + d for c , d in zip ( S [ - i - m : ] , t ) ) : s = s . replace ( * <STRING> ) ; exit ( print ( s [ : - i - m ] + t + s [ l - i : ] ) ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE>
S = input ( ) <NEWLINE> T = input ( ) <NEWLINE> n = len ( S ) <NEWLINE> m = len ( T ) <NEWLINE> <NL> for i in range ( n - m + 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> x = S [ i : i + m ] <NEWLINE> for j in range ( m + 1 ) : <NEWLINE> <INDENT> if j == m : <NEWLINE> <INDENT> print ( ( S [ : i ] + T + S [ i + m : ] ) . replace ( <STRING> , <STRING> ) ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> if x [ j ] == <STRING> : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> elif x [ j ] != T [ j ] : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
s = input ( ) <NEWLINE> t = input ( ) <NEWLINE> w = [ ] <NEWLINE> for i in range ( len ( s ) - len ( t ) + 1 ) : <NEWLINE> <INDENT> f = True <NEWLINE> sx = s [ i : i + len ( t ) ] <NEWLINE> for si , ti in zip ( sx , t ) : <NEWLINE> <INDENT> if si != ti and si != <STRING> : <NEWLINE> <INDENT> f = False <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> <DEDENT> if f : <NEWLINE> <INDENT> w . append ( ( s [ : i ] + t ) . replace ( <STRING> , <STRING> ) ) <NEWLINE> <DEDENT> <DEDENT> if w == [ ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else <NEWLINE> w . sort ( ) <NEWLINE> print ( w [ 0 ] ) <NEWLINE>
print ( <STRING> if any ( [ input ( ) [ i : i + 2 ] == <STRING> for i in range ( len ( input ( ) ) - 1 ) ] ) else <STRING> ) <NEWLINE>
s = input ( ) <NEWLINE> if s in <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> else : <NEWLINE> print ( <STRING> ) <NEWLINE> <DEDENT>
S = input ( ) <NEWLINE> if <STRING> in S : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> input = sys . stdin . readline <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> ans = 0 <NEWLINE> n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> allB = exc = 1 <NEWLINE> for i in n : <NEWLINE> <INDENT> allB *= 3 <NEWLINE> if i % 2 == 0 : <NEWLINE> <INDENT> exc *= 2 <NEWLINE> <DEDENT> <DEDENT> ans = allB - exc <NEWLINE> print ( ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> if a == b : <NEWLINE> <INDENT> print ( c ) <NEWLINE> <DEDENT> elif b == c : <NEWLINE> <INDENT> print ( a ) : <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( b ) <NEWLINE> <DEDENT>
h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> ls = [ ] <NEWLINE> side = [ [ - 1 , - 1 ] , [ - 1 , 0 ] , [ - 1 , 1 ] , [ 0 , - 1 ] , [ 0 , 1 ] , [ 1 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] ] <NEWLINE> for i in range ( h ) : <NEWLINE> <INDENT> ls . append ( list ( input ( ) ) ) <NEWLINE> <DEDENT> for i in range ( h ) : <NEWLINE> <INDENT> ans2 = <STRING> <NEWLINE> for j in range ( w ) : <NEWLINE> <INDENT> ans = 0 <NEWLINE> if ls [ i ] [ j ] == <STRING> : <NEWLINE> <INDENT> ans2 += <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for k in range ( 8 ) : <NEWLINE> <INDENT> if i + side [ k ] [ 0 ] < 0 or j + side [ k ] [ 1 ] < 0 or h <= i + side [ k ] [ 0 ] or w <= j + side [ k ] [ 1 ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += ( 1 if ls [ i + side [ k ] [ 0 ] ] [ j + side [ k ] [ 1 ] ] == <STRING> else 0 ) <NEWLINE> <DEDENT> <DEDENT> ans2 += str ( ans ) <NEWLINE> <DEDENT> <DEDENT> print ( ans2 ) <NEWLINE> <DEDENT>
if a == b : print ( c ) <NEWLINE> elif a == c : print ( b ) <NEWLINE> else : print ( a ) <NEWLINE>
A , B , C = map ( int , input ( ) . slpit ( ) ) <NEWLINE> <NL> if A == B : <NEWLINE> <INDENT> print ( C ) <NEWLINE> <DEDENT> elif B == C : <NEWLINE> <INDENT> print ( A ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( B ) <NEWLINE> <DEDENT>
a , b , c = map ( int , input . split ( ) ) <NEWLINE> <NL> if a == b : <NEWLINE> <INDENT> print ( c ) <NEWLINE> <DEDENT> elif a == c : <NEWLINE> <INDENT> print ( b ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <DEDENT>
a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( a if b = c else b if a = c else c ) <NEWLINE>
a = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> for i in a : <NEWLINE> <INDENT> if a . count ( i ) > 1 : <NEWLINE> <INDENT> print ( i ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT>
l = liet ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for ll in l : <NEWLINE> <INDENT> if l . count ( ll ) == 1 : <NEWLINE> <INDENT> print ( ll ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> print ( a ^ b ^ c ) <NEWLINE>
import sys <NEWLINE> <NL> read = sys . stdin . read <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> sys . setrecursionlimit ( 10 ** 8 ) <NEWLINE> INF = float ( <STRING> ) <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> A , B , C == map ( int , readline ( ) . split ( ) ) <NEWLINE> if A == B : <NEWLINE> <INDENT> print ( C ) <NEWLINE> <DEDENT> elif B == C : <NEWLINE> <INDENT> print ( A ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( B ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( a if b == c else b if a == c else c if a == b ) <NEWLINE>
List = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> res = 0 <NEWLINE> for i in range ( 3 ) : <NEWLINE> <INDENT> for j in range ( i , 3 ) : <NEWLINE> <INDENT> if List [ i ] == List [ j ] : <NEWLINE> <INDENT> res = 6 - i + 1 - j + 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( List [ res ] ) <NEWLINE>
a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if a == b : <NEWLINE> <INDENT> ans = c <NEWLINE> <DEDENT> elif b == c : <NEWLINE> <INDENT> ans = a : <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = b <NEWLINE> <DEDENT> print ( a + b + c - ans ) <NEWLINE>
A , B , C = map ( int , input ( ) . slpit ( ) ) <NEWLINE> <NL> if A == B : <NEWLINE> <INDENT> print ( C ) <NEWLINE> <DEDENT> elif B == C : <NEWLINE> <INDENT> print ( A ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( B ) <NEWLINE> <DEDENT>
h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> l = [ list ( input ( ) ) for i in range ( h ) ] <NEWLINE> ans = [ [ 0 ] * w for i in range ( h ) ] <NEWLINE> <NL> for i in range ( h ) : <NEWLINE> <INDENT> for j in range ( w ) : <NEWLINE> <INDENT> if l [ i ] [ j ] == <STRING> : <NEWLINE> <INDENT> ans [ i ] [ j ] == <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for a in range ( - 1 , 2 ) : <NEWLINE> <INDENT> for b in range ( - 1 , 2 ) : <NEWLINE> <INDENT> if i + a < h and j + b < w ansl [ i + a ] [ j + b ] == <STRING> : <NEWLINE> <INDENT> ans [ i ] [ j ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for i in range ( h ) : <NEWLINE> <INDENT> print ( * ans [ i ] ) <NEWLINE> <DEDENT>
import copy <NEWLINE> H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> List = [ ] <NEWLINE> for i in range ( H ) : <NEWLINE> <INDENT> List . append ( input ( ) ) <NEWLINE> <DEDENT> resList = copy . deepcopy ( List ) <NEWLINE> <NL> def bombCheck ( x , y , ListX ) : <NEWLINE> <INDENT> a = 0 <NEWLINE> b = 0 <NEWLINE> res = 0 <NEWLINE> if ListX [ x ] [ y ] == <STRING> : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> for i in range ( - 1 , 2 , 1 ) : <NEWLINE> <INDENT> a = x + i <NEWLINE> if a < 0 or a >= W : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for j in range ( - 1 , 2 , 1 ) : <NEWLINE> <INDENT> b = y + j <NEWLINE> if b < 0 or b >= H : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if i == 0 and j == 0 : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if List [ a ] [ b ] == <STRING> : <NEWLINE> <INDENT> res += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> return str ( res ) <NEWLINE> <NL> <DEDENT> for i in range ( H ) : <NEWLINE> <INDENT> resList [ i ] = <STRING> <NEWLINE> for j in range ( W ) : <NEWLINE> <INDENT> resList [ i ] += bombCheck ( i , j , List ) <NEWLINE> <DEDENT> <DEDENT> for i in resList : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT>
h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> l = [ [ <STRING> ] * ( w + 2 ) ] <NEWLINE> for i in range ( h ) : <NEWLINE> <INDENT> l . append ( [ <STRING> ] + [ i for i in input ( ) ] + [ <STRING> ] ) <NEWLINE> <DEDENT> l . append ( [ <STRING> ] * ( w + 2 ) ) <NEWLINE> <NL> def count ( i , j ) : <NEWLINE> <INDENT> if l [ i ] [ j ] == <STRING> : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> c = 0 <NEWLINE> for n in range ( i - 1 , i + 2 ) : <NEWLINE> <INDENT> for m in range ( j - 1 , j + 2 ) : <NEWLINE> <INDENT> if l [ n ] [ m ] == <STRING> : <NEWLINE> <INDENT> c += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return str ( c ) <NEWLINE> <NL> <DEDENT> ans = [ <STRING> . join ( [ count ( i , j ) for j in range ( 1 , 1 + w ) ] ) for i in range ( 1 , 1 + h ) ] <NEWLINE> <NL> print ( <STRING> . join ( ans ) ) <NEWLINE> h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> l = [ [ <STRING> ] * ( w + 2 ) ] <NEWLINE> for i in range ( h ) : <NEWLINE> <INDENT> l . append ( [ <STRING> ] + [ i for i in input ( ) ] + [ <STRING> ] ) <NEWLINE> <DEDENT> l . append ( [ <STRING> ] * ( w + 2 ) ) <NEWLINE> <NL> def count ( i , j ) : <NEWLINE> <INDENT> if l [ i ] [ j ] == <STRING> : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> c = 0 <NEWLINE> for n in range ( i - 1 , i + 2 ) : <NEWLINE> <INDENT> for m in range ( j - 1 , j + 2 ) : <NEWLINE> <INDENT> if l [ n ] [ m ] == <STRING> : <NEWLINE> <INDENT> c += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return str ( c ) <NEWLINE> <NL> <DEDENT> ans = [ <STRING> . join ( [ count ( i , j ) for j in range ( 1 , 1 + w ) ] ) for i in range ( 1 , 1 + h ) ] <NEWLINE> <NL> print ( <STRING> . join ( ans ) ) <NEWLINE> <NL>
h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> s = [ list ( input ( ) ) for _ in range ( h ) ] <NEWLINE> <NL> ans = [ [ 0 ] * w for _ in range ( h ) ] <NEWLINE> for i in range ( h ) : <NEWLINE> <INDENT> for j in range ( w ) : <NEWLINE> <INDENT> if s [ i ] [ j ] == <STRING> : ans [ i ] [ j ] = <STRING> <NEWLINE> <INDENT> for i2 in range ( i - 1 , i + 2 ) : <NEWLINE> <INDENT> if i2 < 0 or h - 1 < i2 : continue <NEWLINE> for j2 in range ( j - 1 , j + 2 ) : <NEWLINE> <INDENT> if ( j2 < 0 or w - 1 < j2 ) : continue <NEWLINE> elif ans [ i2 ] [ j2 ] == <STRING> : continue <NEWLINE> ans [ i2 ] [ j2 ] += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for i in ans : <NEWLINE> <INDENT> print ( <STRING> . join ( map ( str , i ) ) ) <NEWLINE> <DEDENT>
H , W = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> S = [ ] <NEWLINE> for i in range ( H ) : <NEWLINE> <INDENT> S [ i ] = input ( ) <NEWLINE> <DEDENT> for j in range ( H ) : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> for k in range ( W ) : <NEWLINE> <INDENT> if S [ j ] [ k ] == <STRING> <NEWLINE> <INDENT> if S [ j - 1 ] [ k - 1 ] == <STRING> : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> if S [ j - 1 ] [ k ] == <STRING> : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> if S [ j - 1 ] [ k + 1 ] == <STRING> : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> if S [ j ] [ k - 1 ] == <STRING> : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> if S [ j ] [ k + 1 ] == <STRING> : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> if S [ j + 1 ] [ k - 1 ] == <STRING> : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> if S [ j + 1 ] [ k ] == <STRING> : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> if S [ j ] [ k + 1 ] == <STRING> : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> S [ j ] [ k ] . replace ( cnt ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> field = [ list ( input ( ) . split ( ) ) for _ in range ( h ) ] <NEWLINE> dx = [ 1 , 0 , - 1 , 0 , 1 , - 1 , - 1 , 1 ] <NEWLINE> dy = [ 0 , 1 , 0 , - 1 , 1 , 1 , - 1 , - 1 ] <NEWLINE> for i in range ( h ) : <NEWLINE> <INDENT> for j in range ( w ) : <NEWLINE> <INDENT> if field [ i ] [ j ] != <STRING> : <NEWLINE> <INDENT> num = 0 <NEWLINE> for k in range ( 8 ) : <NEWLINE> <INDENT> ni = i + dy [ k ] <NEWLINE> nj = j + dx [ k ] <NEWLINE> if nj < 0 or h <= nj : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if ni < 0 or w <= ni : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if field [ ni ] [ nj ] == <STRING> : <NEWLINE> <INDENT> num += 1 <NEWLINE> <DEDENT> <DEDENT> field [ i ] [ j ] = num <NEWLINE> <DEDENT> <DEDENT> <DEDENT> for out in field : <NEWLINE> <INDENT> print ( <STRING> . join ( out ) ) <NEWLINE> <DEDENT>
H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> S = [ list ( input ( ) ) for i in range ( H ) ] <NEWLINE> <NL> Rmin = 0 <NEWLINE> Rmax = 0 <NEWLINE> Cmin = 0 <NEWLINE> Cmax = 0 <NEWLINE> <NL> <COMMENT> <NL> for r in range ( H ) : <NEWLINE> <COMMENT> <NL> <INDENT> for c in range ( W ) : <NEWLINE> <COMMENT> <NL> <INDENT> if S [ r ] [ c ] == <STRING> : <NEWLINE> <INDENT> S [ r ] [ c ] = 0 <NEWLINE> <DEDENT> elif S [ r ] [ c ] == <STRING> : <NEWLINE> <INDENT> if r == 0 : <NEWLINE> <INDENT> Rmin = r <NEWLINE> Rmax = r + 2 <NEWLINE> <DEDENT> elif r == H - 1 : <NEWLINE> <INDENT> Rmin = r - 1 <NEWLINE> Rmax = r + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> Rmin = r - 1 <NEWLINE> Rmax = r + 2 <NEWLINE> <NL> <DEDENT> if c == 0 : <NEWLINE> <INDENT> Cmin = c <NEWLINE> Cmax = c + 2 <NEWLINE> <DEDENT> elif c == W - 1 : <NEWLINE> <INDENT> Cmin = c - 1 <NEWLINE> Cmax = c + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> Cmin = c - 1 <NEWLINE> Cmax = c + 2 <NEWLINE> <DEDENT> for i in range ( Rmin , Rmax ) : <NEWLINE> <INDENT> for t in range ( Cmin , Cmax ) : <NEWLINE> <INDENT> if S [ i ] [ t ] == <STRING> or S [ i ] [ t ] == 0 : <NEWLINE> <INDENT> S [ i ] [ t ] = 1 <NEWLINE> <DEDENT> elif not S [ i ] [ t ] == <STRING> : <NEWLINE> <INDENT> S [ i ] [ t ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for i in range ( H ) : <NEWLINE> <INDENT> print ( <STRING> . join ( S [ i ] ) ) <NEWLINE> <DEDENT>
Y_DIR [ - 1 , 0 , 1 ] <NEWLINE> X_DIR [ - 1 , 0 , 1 ] <NEWLINE> def count_bomb ( y , x ) : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> for yd in Y_DIR : <NEWLINE> <INDENT> yy = y + yd <NEWLINE> if not ( 0 <= yy < h ) : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> for xd in X_DIR : <NEWLINE> <INDENT> xx = x + xd <NEWLINE> if not ( 0 <= xx < w ) : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if s [ yy ] [ xx ] == <STRING> : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return cnt <NEWLINE> <NL> <DEDENT> h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> s = [ ] <NEWLINE> for i in range ( h ) : <NEWLINE> <INDENT> s . append ( input ( ) ) <NEWLINE> <DEDENT> for y in range ( h ) : <NEWLINE> <INDENT> for x in range ( w ) <NEWLINE> <INDENT> if s [ y ] [ x ] == <STRING> : <NEWLINE> <INDENT> s [ y ] [ x ] = str ( count_bomb ( y , x ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> . join ( s ) ) <NEWLINE> <NL>
<NL> H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> M = [ ] <NEWLINE> for h in range ( H ) : <NEWLINE> <INDENT> col = [ ] <NEWLINE> s = input ( ) <NEWLINE> for w in range ( W ) : <NEWLINE> <INDENT> if s [ w ] == <STRING> : <NEWLINE> <INDENT> col . append ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> col . append ( np . inf ) <NEWLINE> <DEDENT> <DEDENT> M . append ( col ) <NEWLINE> <NL> <NL> <NL> <DEDENT> for h in range ( H ) : <NEWLINE> <INDENT> for w in range ( W ) : <NEWLINE> <INDENT> flag_h0 = True <NEWLINE> flag_hM = True <NEWLINE> flag_w0 = True <NEWLINE> flag_wM = True <NEWLINE> if M [ h ] [ w ] == np . inf : <NEWLINE> <NL> <INDENT> if h == 0 : <NEWLINE> <INDENT> flag_h0 = False <NEWLINE> <DEDENT> if h == H - 1 : <NEWLINE> <INDENT> flag_hM = False <NEWLINE> <DEDENT> if w == 0 : <NEWLINE> <INDENT> flag_w0 = False <NEWLINE> <DEDENT> if w == W - 1 : <NEWLINE> <INDENT> flag_wM = False <NEWLINE> <NL> <DEDENT> if flag_h0 : <NEWLINE> <INDENT> M [ h - 1 ] [ w ] += 1 <NEWLINE> if flag_w0 : <NEWLINE> <INDENT> M [ h - 1 ] [ w - 1 ] += 1 <NEWLINE> <DEDENT> if flag_wM : <NEWLINE> <INDENT> M [ h - 1 ] [ w + 1 ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if flag_w0 : <NEWLINE> <INDENT> M [ h ] [ w - 1 ] += 1 <NEWLINE> <DEDENT> if flag_wM : <NEWLINE> <INDENT> M [ h ] [ w + 1 ] += 1 <NEWLINE> <NL> <DEDENT> if flag_hM : <NEWLINE> <INDENT> M [ h + 1 ] [ w ] += 1 <NEWLINE> <NL> if flag_w0 : <NEWLINE> <INDENT> M [ h + 1 ] [ w - 1 ] += 1 <NEWLINE> <DEDENT> if flag_wM : <NEWLINE> <INDENT> M [ h + 1 ] [ w + 1 ] += 1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for h in range ( H ) : <NEWLINE> <INDENT> tmp_ = <STRING> <NEWLINE> for w in range ( W ) : <NEWLINE> <INDENT> if M [ h ] [ w ] < np . inf : <NEWLINE> <INDENT> tmp_ += str ( M [ h ] [ w ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> tmp_ += <STRING> <NEWLINE> <DEDENT> <DEDENT> print ( tmp_ ) <NEWLINE> <DEDENT>
H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> S = [ list ( input ( ) ) for _ in range ( H ) ] <NEWLINE> dydx = [ ( - 1 , - 1 ) , ( - 1 , 0 ) , ( - 1 , 1 ) , ( 0 , - 1 ) , ( 0 , 1 ) , ( 1 , - 1 ) , ( 1 , 0 ) , ( 1 , 1 ) ] <NEWLINE> <NL> def check ( h , w ) : <NEWLINE> <INDENT> count = 0 <NEWLINE> for dy , dx in dydx : <NEWLINE> <INDENT> if 0 <= h + dy < H and 0 <= w + dx < W and S [ h + dy ] [ w + dx ] == <STRING> : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> return count <NEWLINE> <NL> <NL> <NL> <DEDENT> for h in range ( H ) : <NEWLINE> <INDENT> for w in range ( W ) : <NEWLINE> <INDENT> if S [ h ] [ w ] == <STRING> : <NEWLINE> <INDENT> S [ h ] [ w ] = check ( h , w ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> . join ( S [ h ] ) <NEWLINE> <NL> <DEDENT>
class UnionFind : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . nodes = n <NEWLINE> self . parents = [ i for i in range ( n ) ] <NEWLINE> self . sizes = [ 1 ] * n <NEWLINE> self . rank = [ 0 ] * n <NEWLINE> <NL> <DEDENT> def find ( self , i ) : <NEWLINE> <INDENT> if self . parents [ i ] == i : <NEWLINE> <INDENT> return i <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . parents [ i ] = self . find ( self . parents [ i ] ) <COMMENT> <NEWLINE> return self . parents [ i ] <NEWLINE> <NL> <DEDENT> <DEDENT> def unite ( self , i , j ) : <NEWLINE> <INDENT> pi = self . find ( i ) <NEWLINE> pj = self . find ( j ) <NEWLINE> if pi != pj : <NEWLINE> <INDENT> if self . rank [ pi ] < self . rank [ pj ] : <NEWLINE> <INDENT> self . sizes [ pj ] += self . sizes [ pi ] <NEWLINE> self . parents [ pi ] = pj <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . sizes [ pi ] += self . sizes [ pj ] <NEWLINE> self . parents [ pj ] = pi <NEWLINE> if self . rank [ pi ] == self . rank [ pj ] : <NEWLINE> <INDENT> self . rank [ pi ] += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> def same ( self , i , j ) : <NEWLINE> <INDENT> return self . find ( i ) == self . find ( j ) <NEWLINE> <DEDENT> def get_parents ( self ) : <NEWLINE> <INDENT> for n in range ( self . nodes ) : <NEWLINE> <INDENT> selff . find ( n ) <NEWLINE> <DEDENT> return self . parents <NEWLINE> <NL> <DEDENT> <DEDENT> adj = [ ] <NEWLINE> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> uf = UnionFind ( n ) <NEWLINE> for j in range ( m ) : <NEWLINE> <INDENT> if i == j : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> uf . unite ( adj [ j ] ) <NEWLINE> <DEDENT> if len ( set ( uf . get_parents ( ) ) ) != 1 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from typing import List , Tuple <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> g = [ ] <NEWLINE> for _ in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> g . append ( ( a , b ) ) <NEWLINE> <DEDENT> print ( b ( n , m , g ) ) <NEWLINE> <NL> <NL> <DEDENT> def b ( n : int , m : int , g : List [ Tuple [ int , int ] ] ) : <NEWLINE> <INDENT> ret = 0 <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> v = set ( ) <NEWLINE> w = [ 1 ] <NEWLINE> while w : <NEWLINE> <INDENT> now = w . pop ( ) <NEWLINE> v . add ( now ) <NEWLINE> for j , node in enumerate ( g ) : <NEWLINE> <INDENT> if j == i : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if node [ 0 ] == now and node [ 1 ] not in v : <NEWLINE> <INDENT> w . append ( node [ 1 ] ) <NEWLINE> <DEDENT> elif node [ 1 ] == now and node [ 0 ] not in v : <NEWLINE> <INDENT> w . append ( node [ 0 ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if len ( v ) != n : <NEWLINE> <INDENT> ret += 1 <NEWLINE> <DEDENT> <DEDENT> return ret <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> <NL> print ( s [ : : ( s . len ( ) - 8 ) ] ) <NEWLINE>
s = input ( ) <NEWLINE> print ( s - <STRING> ) <NEWLINE>
<STRING> <NEWLINE> import sys <NEWLINE> sys . setrecursionlimit ( 200000 ) <NEWLINE> n = len ( edges ) <NEWLINE> colors = [ - 1 ] * ( n + 1 ) <NEWLINE> def judgeBiGragh ( edges ) : <NEWLINE> <INDENT> def paint ( v , c ) : <NEWLINE> <INDENT> if colors [ v ] == - 1 : <NEWLINE> <INDENT> colors [ v ] = c <NEWLINE> nxC = ( c + 1 ) % 2 <NEWLINE> for nxV in edges [ v ] : <NEWLINE> <INDENT> result = paint ( nxV , nxC ) <NEWLINE> if result == False : <NEWLINE> <INDENT> return result <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if colors [ v ] != c : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> <DEDENT> return True <NEWLINE> <DEDENT> return paint ( 1 , 0 ) <NEWLINE> <NL> <DEDENT> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> edges = [ [ ] for _ in range ( N + 1 ) ] <NEWLINE> for _ in range ( M ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> edges [ a ] . append ( b ) <NEWLINE> edges [ b ] . append ( a ) <NEWLINE> <DEDENT> def choose ( n , k ) : <NEWLINE> <INDENT> import math <NEWLINE> return math . factorial ( n ) // ( math . factorial ( n - k ) * math . factorial ( k ) ) <NEWLINE> <DEDENT> if judgeBiGragh ( edges ) : <NEWLINE> <INDENT> cnt0 = colors . count ( 0 ) <NEWLINE> cnt1 = colors . count ( 1 ) <NEWLINE> ans = cnt0 * cnt1 - M <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = choose ( N , 2 ) - M <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> for i in range ( 1 , 3501 ) : <NEWLINE> <INDENT> for j in range ( 1 , 3501 ) : <NEWLINE> <INDENT> t1 = n * i * j <NEWLINE> t2 = 4 * i * j - n * j - n * i <NEWLINE> if t1 % t2 == 0 and 1 <= t1 // t2 < 3500 : <NEWLINE> <INDENT> print ( i , j , t1 // t2 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> <NL> for h in range ( 3501 ) : <NEWLINE> <INDENT> for w in range ( 3501 ) : <NEWLINE> <INDENT> bns = n * h * w <NEWLINE> bnb = 4 * h * w - n * ( h + w ) <NEWLINE> if bns % bnb == 0 : <NEWLINE> <INDENT> print ( h , w , bns // bnb ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
import bisect , collections , copy , heapq , itertools , math , string , sys <NEWLINE> input = lambda : sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> INF = float ( <STRING> ) <NEWLINE> def I ( ) : return int ( input ( ) ) <NEWLINE> def F ( ) : return float ( input ( ) ) <NEWLINE> def SS ( ) : return input ( ) <NEWLINE> def LI ( ) : return [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> def LI_ ( ) : return [ int ( x ) - 1 for x in input ( ) . split ( ) ] <NEWLINE> def LF ( ) : return [ float ( x ) for x in input ( ) . split ( ) ] <NEWLINE> def LSS ( ) : return input ( ) . split ( ) <NEWLINE> <NL> def resolve ( ) : <NEWLINE> <INDENT> N = I ( ) <NEWLINE> <NL> ans = ( 0 , 0 , 0 ) <NEWLINE> for h in range ( 1 , 3501 ) : <NEWLINE> <INDENT> for n in range ( 1 , 3501 ) : <NEWLINE> <COMMENT> <NL> <INDENT> num = N * n * h <NEWLINE> denom = 4 * h * n - N * ( h + n ) <NEWLINE> if denom > 0 and num % denom == 0 : <NEWLINE> <INDENT> w = num // denom <NEWLINE> ans = ( h , n , w ) <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( * ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> resolve ( ) <NEWLINE> <DEDENT>
import os <NEWLINE> import sys <NEWLINE> import numpy as np <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> def bit_sum ( bit , i ) : <COMMENT> <NEWLINE> <COMMENT> <NL> <INDENT> res = 0 <NEWLINE> while i : <NEWLINE> <INDENT> res += bit [ i ] <NEWLINE> i -= i & - i <NEWLINE> <DEDENT> return res <NEWLINE> <NL> <DEDENT> def bit_add ( bit , i , val ) : <COMMENT> <NEWLINE> <INDENT> n = len ( bit ) <NEWLINE> while i < n : <NEWLINE> <INDENT> bit [ i ] += val <NEWLINE> i += i & - i <NEWLINE> <NL> <COMMENT> <NL> <NL> <NL> <DEDENT> <DEDENT> def inversion_number ( arr ) : <COMMENT> <NEWLINE> <COMMENT> <NL> <INDENT> n = len ( arr ) <NEWLINE> arr = np . argsort ( arr ) + 1 <NEWLINE> bit = np . zeros ( n + 1 , dtype = np . int64 ) <NEWLINE> res = n * ( n - 1 ) >> 1 <NEWLINE> for val in arr : <NEWLINE> <INDENT> res -= bit_sum ( bit , val ) <NEWLINE> bit_add ( bit , val , 1 ) <NEWLINE> <DEDENT> return res <NEWLINE> <NL> <NL> <COMMENT> <NL> <NL> <DEDENT> numba_config = [ <NEWLINE> <INDENT> [ <STRING> , <STRING> ] , <NEWLINE> [ <STRING> , <STRING> ] , <NEWLINE> [ <STRING> , <STRING> ] , <NEWLINE> <DEDENT> ] <NEWLINE> if sys . argv [ - 1 ] == <STRING> : <NEWLINE> <INDENT> from numba . pycc import CC <NEWLINE> cc = CC ( <STRING> ) <NEWLINE> for func_name , types in numba_config : <NEWLINE> <INDENT> cc . export ( func_name , types ) ( vars ( ) [ func_name ] ) <NEWLINE> cc . compile ( ) <NEWLINE> <DEDENT> exit ( ) <NEWLINE> <DEDENT> elif os . name == <STRING> : <NEWLINE> <INDENT> exec ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> from numba import njit <NEWLINE> for func_name , types in numba_config : <NEWLINE> <INDENT> vars ( ) [ func_name ] = njit ( types , cache = True ) ( vars ( ) [ func_name ] ) <NEWLINE> <DEDENT> print ( <STRING> , file = sys . stderr ) <NEWLINE> <NL> <COMMENT> <NL> <NL> <NL> <DEDENT> N = int ( input ( ) ) <NEWLINE> ABC = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( N ) ] <NEWLINE> A , B , C = zip ( * ABC ) <NEWLINE> th = N * ( N - 1 ) // 2 // 2 + 1 <NEWLINE> def solve ( A , B , C ) : <NEWLINE> <COMMENT> <NL> <INDENT> if N < 100 : <NEWLINE> <INDENT> ok = - 1e10 <NEWLINE> ng = 1e10 <NEWLINE> n_iteration = 70 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ok = - 1e4 <NEWLINE> ng = 1e4 <NEWLINE> n_iteration = 46 <NEWLINE> <DEDENT> A , B , C = zip ( * sorted ( zip ( A , B , C ) , key = lambda x : - x [ 0 ] / x [ 1 ] ) ) <NEWLINE> A = np . array ( A ) <NEWLINE> B = np . array ( B ) <NEWLINE> C = np . array ( C ) <NEWLINE> for _ in range ( n_iteration ) : <NEWLINE> <INDENT> x = ( ok + ng ) * 0.5 <NEWLINE> Y = ( - A * x + C ) / B <NEWLINE> inv_num = inversion_number ( Y ) <NEWLINE> if inv_num >= th : <NEWLINE> <INDENT> ok = x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ng = x <NEWLINE> <DEDENT> <DEDENT> return ok <NEWLINE> <NL> <DEDENT> print ( solve ( A , B , C ) , solve ( B , A , C ) ) <NEWLINE>
import os <NEWLINE> import sys <NEWLINE> <NL> import numpy as np <NEWLINE> <NL> <NL> def solve ( inp ) : <NEWLINE> <INDENT> def bit_add ( arr , n , i , x ) : <NEWLINE> <INDENT> while i <= n : <NEWLINE> <INDENT> arr [ i ] += x <NEWLINE> i += i & - i <NEWLINE> <NL> <DEDENT> <DEDENT> def bit_sum ( arr , i ) : <NEWLINE> <INDENT> result = 0 <NEWLINE> while i > 0 : <NEWLINE> <INDENT> result += arr [ i ] <NEWLINE> i ^= i & - i <NEWLINE> <DEDENT> return result <NEWLINE> <NL> <DEDENT> n = int ( inp [ 0 ] ) <NEWLINE> lim = ( n * ( n - 1 ) // 2 + 1 ) // 2 <NEWLINE> aaa = inp [ 1 : : 3 ] <NEWLINE> bbb = inp [ 2 : : 3 ] <NEWLINE> ccc = inp [ 3 : : 3 ] <NEWLINE> <NL> inclines_x = [ ] <NEWLINE> inclines_y = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> inclines_x . append ( ( aaa [ i ] / bbb [ i ] , i ) ) <NEWLINE> inclines_y . append ( ( bbb [ i ] / aaa [ i ] , i ) ) <NEWLINE> <DEDENT> inclines_x . sort ( ) <NEWLINE> inclines_y . sort ( ) <NEWLINE> incline_rank_x = np . zeros ( n , dtype = np . int64 ) <NEWLINE> incline_rank_y = np . zeros ( n , dtype = np . int64 ) <NEWLINE> for k in range ( n ) : <NEWLINE> <INDENT> incline_rank_x [ inclines_x [ k ] [ 1 ] ] = n - k <NEWLINE> incline_rank_y [ inclines_y [ k ] [ 1 ] ] = n - k <NEWLINE> <NL> <DEDENT> def check_x ( m ) : <NEWLINE> <INDENT> yyy = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> yyy . append ( ( ( ccc [ i ] - aaa [ i ] * m ) / bbb [ i ] , i ) ) <NEWLINE> <DEDENT> yyy . sort ( ) <NEWLINE> <NL> bit = np . zeros ( n + 1 , dtype = np . int64 ) <NEWLINE> intersection_left = 0 <NEWLINE> for j in range ( n ) : <NEWLINE> <INDENT> i = yyy [ j ] [ 1 ] <NEWLINE> k = incline_rank_x [ i ] <NEWLINE> intersection_left += bit_sum ( bit , k ) <NEWLINE> bit_add ( bit , n + 1 , k , 1 ) <NEWLINE> <NL> <DEDENT> return intersection_left >= lim <NEWLINE> <NL> <DEDENT> def check_y ( m ) : <NEWLINE> <INDENT> xxx = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> xxx . append ( ( ( ccc [ i ] - bbb [ i ] * m ) / aaa [ i ] , i ) ) <NEWLINE> <DEDENT> xxx . sort ( ) <NEWLINE> <NL> bit = np . zeros ( n + 1 , dtype = np . int64 ) <NEWLINE> intersection_left = 0 <NEWLINE> for j in range ( n ) : <NEWLINE> <INDENT> i = xxx [ j ] [ 1 ] <NEWLINE> k = incline_rank_y [ i ] <NEWLINE> intersection_left += bit_sum ( bit , k ) <NEWLINE> bit_add ( bit , n + 1 , k , 1 ) <NEWLINE> <NL> <DEDENT> return intersection_left >= lim <NEWLINE> <NL> <DEDENT> l = - 2.0 * 10 ** 8 <NEWLINE> r = 2.0 * 10 ** 8 <NEWLINE> while l + 1e-9 < r : <NEWLINE> <INDENT> m = ( l + r ) / 2 <NEWLINE> if check_x ( m ) : <NEWLINE> <INDENT> r = m <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> l = m <NEWLINE> <DEDENT> <DEDENT> x = l <NEWLINE> <NL> l = - 2.0 * 10 ** 8 <NEWLINE> r = 2.0 * 10 ** 8 <NEWLINE> while l + 1e-9 < r : <NEWLINE> <INDENT> m = ( l + r ) / 2 <NEWLINE> if check_y ( m ) : <NEWLINE> <INDENT> r = m <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> l = m <NEWLINE> <DEDENT> <DEDENT> y = l <NEWLINE> <NL> return x , y <NEWLINE> <NL> <NL> <DEDENT> if sys . argv [ - 1 ] == <STRING> : <NEWLINE> <INDENT> from numba . pycc import CC <NEWLINE> <NL> cc = CC ( <STRING> ) <NEWLINE> cc . export ( <STRING> , <STRING> ) ( solve ) <NEWLINE> cc . compile ( ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> if os . name == <STRING> : <NEWLINE> <COMMENT> <NL> <INDENT> from my_module import solve <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> from numba import njit <NEWLINE> <NL> solve = njit ( <STRING> , cache = True ) ( solve ) <NEWLINE> <NL> <DEDENT> inp = np . fromstring ( sys . stdin . buffer . read ( ) , dtype = np . float64 , sep = <STRING> ) <NEWLINE> try : <NEWLINE> <INDENT> x , y = solve ( inp ) <NEWLINE> print ( x , y ) <NEWLINE> <DEDENT> except ZeroDivisionError : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> ans = 0 <NEWLINE> for c in s : <NEWLINE> <INDENT> if c == <STRING> <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
a , s , d , f , g , h = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> print ( a + s + d + f + g + h ) <NEWLINE>
print ( list ( input ( ) ) . count ( <STRING> ) ) ] <NEWLINE>
n = int ( input ( ) ) <NEWLINE> ans = 10 ** 100 <NEWLINE> for i in range ( n ) <NEWLINE> <INDENT> t = sum ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> ans = min ( ans , t ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> from collections import deque , Counter <NEWLINE> from heapq import heappop , heappush <NEWLINE> from bisect import bisect_right <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> A = [ None ] * N <NEWLINE> B = [ None ] * N <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> A [ i ] , B [ i ] = map ( int , input ( ) . split ( ) ) <NEWLINE> <DEDENT> print ( max ( A [ i ] ) + B . index ( max ( A [ i ] ) ) ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = [ int ( input ( ) ) for i in range ( N ) ] <NEWLINE> <NL> A . sort ( ) <NEWLINE> left = A [ 0 ] <NEWLINE> right = A [ N - 1 ] <NEWLINE> ans = right - left <NEWLINE> for i in range ( ( N - 2 ) // 2 ) : <NEWLINE> <INDENT> if i % 2 == 0 : <NEWLINE> <INDENT> ans += right - A [ 1 + i ] <NEWLINE> ans += A [ N - 2 - i ] - left <NEWLINE> right = A [ 1 + i ] <NEWLINE> left = A [ N - 2 - i ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += left - A [ 1 + i ] <NEWLINE> ans += A [ N - 2 - i ] - right <NEWLINE> left = A [ 1 + i ] <NEWLINE> right = A [ N - 2 - i ] <NEWLINE> <NL> <DEDENT> <DEDENT> if N % 2 == 1 : <NEWLINE> <INDENT> ans += max ( abs ( right - A [ N // 2 ] ) , abs ( left - A [ N // 2 ] ) ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> readline = sys . stdin . readline <NEWLINE> read = sys . stdin . read <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> n , k = map ( int , readline ( ) . split ( ) ) <NEWLINE> ab = [ list ( map ( int , l . split ( ) ) ) for l in read ( ) . splitlines ( ) ] <NEWLINE> <NL> ek = 0 <NEWLINE> while k >> ek : <NEWLINE> <INDENT> ek += 1 <NEWLINE> <DEDENT> ans = 0 <NEWLINE> for i in range ( ek ) : <NEWLINE> <INDENT> if k >> i & 1 : <NEWLINE> <INDENT> m = ( k >> ( i + 1 ) ) << ( i + 1 ) | ( ( 1 << i ) - 1 ) <NEWLINE> ans = max ( ans , sum ( [ e [ 1 ] for e in ab if e [ 0 ] | m == m ] ) ) <NEWLINE> <DEDENT> <DEDENT> ans = max ( ans , sum ( [ e [ 1 ] for e in ab if e [ 0 ] | k == k ] ) ) <NEWLINE> print ( max ( cand ) ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> if len ( s ) >= 4 and s [ : 4 ] = <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> if len ( s ) >= 4 & & s [ : 4 ] == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) ; <NEWLINE> <DEDENT>
from collections import Counter <NEWLINE> h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> s = <STRING> <NEWLINE> for i in range ( h ) : <NEWLINE> <INDENT> s += input ( ) <NEWLINE> <DEDENT> sc = Counter ( s ) <NEWLINE> d = [ 0 , 0 , 0 ] <NEWLINE> for v in sc . values ( ) : <NEWLINE> <INDENT> d [ 0 ] += ( v // 4 ) * 4 <NEWLINE> d [ 1 ] += 2 if v % 4 >= 2 else 0 <NEWLINE> d [ 2 ] += v % 2 <NEWLINE> <NL> <DEDENT> if w % 2 == 0 and h % 2 == 0 : <NEWLINE> <INDENT> print ( <STRING> if d [ 0 ] == h * w else <STRING> ) <NEWLINE> <DEDENT> elif ( w % 2 ) * ( h % 2 ) == 1 : <NEWLINE> <INDENT> print ( <STRING> if d [ 1 ] <= ( w - 1 ) + ( h - 1 ) and d [ 2 ] == 1 else <STRING> ) <NEWLINE> <DEDENT> elif w % 2 == 0 : <NEWLINE> <INDENT> print ( <STRING> if d [ 1 ] <= w and d [ 2 ] == 0 else <STRING> ) <NEWLINE> <DEDENT> elif h % 2 == 0 : <NEWLINE> <INDENT> print ( <STRING> if d [ 1 ] <= h and d [ 2 ] == 0 else <STRING> ) <NEWLINE> <NL> <DEDENT> from collections import Counter <NEWLINE> h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> s = <STRING> <NEWLINE> for i in range ( h ) : <NEWLINE> <INDENT> s += input ( ) <NEWLINE> <DEDENT> sc = Counter ( s ) <NEWLINE> d = [ 0 , 0 , 0 ] <NEWLINE> for v in sc . values ( ) : <NEWLINE> <INDENT> d [ 0 ] += ( v // 4 ) * 4 <NEWLINE> d [ 1 ] += 2 if v % 4 >= 2 else 0 <NEWLINE> d [ 2 ] += v % 2 <NEWLINE> <NL> <DEDENT> if w % 2 == 0 and h % 2 == 0 : <NEWLINE> <INDENT> print ( <STRING> if d [ 0 ] == h * w else <STRING> ) <NEWLINE> <DEDENT> elif ( w % 2 ) * ( h % 2 ) == 1 : <NEWLINE> <INDENT> print ( <STRING> if d [ 1 ] <= ( w - 1 ) + ( h - 1 ) and d [ 2 ] == 1 else <STRING> ) <NEWLINE> <DEDENT> elif w % 2 == 0 : <NEWLINE> <INDENT> print ( <STRING> if d [ 1 ] <= w and d [ 2 ] == 0 else <STRING> ) <NEWLINE> <DEDENT> elif h % 2 == 0 : <NEWLINE> <INDENT> print ( <STRING> if d [ 1 ] <= h and d [ 2 ] == 0 else <STRING> ) <NEWLINE> <NL> <DEDENT>
h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> a , l = [ list ( input ( ) ) for i in range ( h ) ] , [ 0 ] * 26 <NEWLINE> for i in a : <NEWLINE> <INDENT> for j in i : l [ ord ( j ) - 97 ] += 1 <NEWLINE> <DEDENT> o , t , f = ( h // 2 ) * ( w // 2 ) , ( h // 2 ) * ( w % 2 ) + ( w // 2 ) * ( h % 2 ) , ( h % 2 ) * ( w % 2 ) <NEWLINE> for i in l : <NEWLINE> <INDENT> while o and i > 3 : o -= 1 ; i -= 4 <NEWLINE> while t and i > 1 : t -= 1 i -= 2 <NEWLINE> f -= i <NEWLINE> <DEDENT> print ( <STRING> if o == t == f == 0 else <STRING> ) <NEWLINE>
from collections import Counter <NEWLINE> h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> <COMMENT> <NL> a = [ ] <NEWLINE> flag = True <NEWLINE> for i in range ( h ) : <NEWLINE> <INDENT> a += list ( input ( ) ) <NEWLINE> <DEDENT> ca = Counter ( a ) <NEWLINE> if h % 2 == 0 and w % 2 == 0 : <NEWLINE> <INDENT> for i in ca : <NEWLINE> <INDENT> if ca [ i ] % 4 != 0 : <NEWLINE> <INDENT> flag = False <NEWLINE> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if flag : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> elif h % 2 != 0 and w % 2 != 0 : <NEWLINE> <INDENT> yon = ( h - 1 ) * ( w - 1 ) <NEWLINE> ni = h * w - yon - 1 <NEWLINE> iti = 1 <NEWLINE> for i in ca : <NEWLINE> <INDENT> while ca [ i ] > 0 <NEWLINE> <INDENT> if ca [ i ] % 4 == 0 and yon > 0 : <NEWLINE> <INDENT> ca [ i ] -= 4 <NEWLINE> yon -= 4 <NEWLINE> <DEDENT> elif ca [ i ] % 2 == 0 and ni > 0 : <NEWLINE> <INDENT> ni -= 2 <NEWLINE> ca [ i ] -= 2 <NEWLINE> <DEDENT> elif iti > 0 : <NEWLINE> <INDENT> iti -= 1 <NEWLINE> ca [ i ] -= 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if yon == 0 and ni == 0 and iti == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if h % 2 == 0 : <NEWLINE> <INDENT> yon = ( h ) * ( w - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> yon = ( h - 1 ) * ( w ) <NEWLINE> <DEDENT> ni = h * w - yon <NEWLINE> for i in ca : <NEWLINE> <INDENT> while ca [ i ] > 0 : <NEWLINE> <INDENT> if ca [ i ] % 4 == 0 and yon > 0 : <NEWLINE> <INDENT> ca [ i ] -= 4 <NEWLINE> yon -= 4 <NEWLINE> <DEDENT> elif ca [ i ] % 2 == 0 and ni > 0 : <NEWLINE> <INDENT> ni -= 2 <NEWLINE> ca [ i ] -= 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if yon == 0 and ni == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT>
from collections import defaultdict <NEWLINE> H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> d = defaultdict ( int ) <NEWLINE> for _ in range ( H ) : <NEWLINE> <INDENT> for c in list ( input ( ) ) : <NEWLINE> <INDENT> d [ c ] += 1 <NEWLINE> <DEDENT> <DEDENT> for i in range ( ( H - 1 ) // 2 + 1 ) : <NEWLINE> <INDENT> for j in range ( ( W - 1 ) // 2 + 1 ) : <NEWLINE> <INDENT> s = set ( [ ( x , y ) for x , y in [ ( i , j ) , ( i , W - 1 - j ) , ( H - 1 - i , j ) , ( H - 1 - i , W - 1 - j ) ] if 0 <= x < H and 0 <= y < W ] ) <NEWLINE> f = True <NEWLINE> for k , _ in sorted ( d . items ( ) , key = lambda x : x [ 1 ] ) : <NEWLINE> <INDENT> if d [ k ] >= len ( s ) : <NEWLINE> <INDENT> d [ k ] -= len ( s ) <NEWLINE> f = False <NEWLINE> for x , y in s : <NEWLINE> <INDENT> test [ x ] [ y ] = k <NEWLINE> <DEDENT> break <NEWLINE> <DEDENT> <DEDENT> if f : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( 0 ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
from collections import Counter <NEWLINE> h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ ] <NEWLINE> for i in range ( h ) : <NEWLINE> <INDENT> A . extend ( list ( input ( ) ) ) <NEWLINE> <DEDENT> cA = Counter ( A ) <NEWLINE> <NL> l1 = h * w % 2 <NEWLINE> l2 = ( h // 2 ) * ( w % 2 ) + ( w // 2 ) * ( h % 2 ) <NEWLINE> l3 = ( h // 2 ) * ( w // 2 ) <NEWLINE> if l1 : <NEWLINE> <INDENT> for key , val in cA . items ( ) : <NEWLINE> <INDENT> if val % 2 == 1 : <NEWLINE> <INDENT> cA [ key ] -= 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> for _ in range ( l2 ) : <NEWLINE> <INDENT> for key , val in cA . items ( ) : <NEWLINE> <INDENT> if val % 4 = - 2 : <NEWLINE> <INDENT> cA [ key ] -= 2 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> if sum ( val % 4 for val in cA . values ( ) ) == 0 else <STRING> ) <NEWLINE>
x , y = int ( input ( ) ) <NEWLINE> print ( ( x * x ) - y ) <NEWLINE>
int a , b <NEWLINE> a = input ( ) <NEWLINE> b = input ( ) <NEWLINE> print ( a ** 2 - b ) <NEWLINE>
<COMMENT> <NL> N , A = map ( int , input ( ) . split ( ) ) <NEWLINE> <COMMENT> <NL> print ( N ** 2 - A ) <NEWLINE>
def get_colored_cells ( ) : <NEWLINE> <INDENT> N = input ( ) <NEWLINE> A = input ( ) <NEWLINE> return N ** 2 - A <NEWLINE> <NL> <DEDENT> get_colored_cells ( ) <NEWLINE>
<COMMENT> <NL> n , a = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <COMMENT> <NL> answer = n * n - a <NEWLINE> <NL> <COMMENT> <NL> print ( answer ) <NEWLINE>
<COMMENT> <NL> N = input ( ) <NEWLINE> A = input ( ) <NEWLINE> print ( N ** 2 - A ) <NEWLINE>
n , a = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( n * n - a ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a - int ( input ( ) ) <NEWLINE> print ( n ** 2 - a ) <NEWLINE>
N = input ( ) <NEWLINE> A = input ( ) <NEWLINE> print ( N ** 2 - A ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( a * a - b ) <NEWLINE>
N , A = ( int ( x ) for x in input ( ) . split ( ) ) <NEWLINE> ans = N ** 2 - A <NEWLINE> print ( ans ) <NEWLINE>
N , A = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> print ( N ** 2 - A ) <NEWLINE>
a , b = [ int ( input ( ) . split ( ) ) for i in range ( 2 ) ] <NEWLINE> c = ( a * a ) <NEWLINE> print ( c - a ) <NEWLINE>
N , A = int ( input ( ) ) for i in range ( 2 ) <NEWLINE> print ( N * N - A ) <NEWLINE>
<COMMENT> <NL> <NL> N = input ( ) <NEWLINE> <NL> print ( int ( ( N * N ) ) - int ( input ( ) ) ) <NEWLINE>
a , n = input ( ) . split ( ) <NEWLINE> a = int ( a ) <NEWLINE> n = int ( n ) <NEWLINE> print ( n * n - a ) <NEWLINE>
x = int ( input ( ) ) <NEWLINE> y = int ( input ( ) ) <NEWLINE> Print ( x * x - y ) <NEWLINE>
N = int ( input ( N ) ) <NEWLINE> A = int ( input ( A ) ) <NEWLINE> print ( N * N - A ) <NEWLINE>
import sys <NEWLINE> read = sys . stdin . read <NEWLINE> <NL> n , a = map ( int , read ( ) . spliitlines ( ) ) <NEWLINE> <NL> print ( n ** 2 - a ) <NEWLINE>
n , a = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( n * n - a ) <NEWLINE>
n , a = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( n ** n - a ) <NEWLINE>
a = int ( input ( ) ) <NEWLINE> b = int ( input ( ) ) <NEWLINE> c = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> total = 0 <NEWLINE> for i in range ( 2 ) : <NEWLINE> <INDENT> d = 2 * c [ i ] <NEWLINE> e = 2 * abs ( 9 - c [ i ] ) <NEWLINE> total += min ( d , e ) <NEWLINE> <DEDENT> print ( total ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> k = int ( input ( ) ) <NEWLINE> x = list ( map ( int , input ( ) . split ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if abs ( x [ i ] ) > abs ( x [ i ] - k ) : <NEWLINE> <INDENT> ans += abs ( x [ i ] - k ) * 2 <NEWLINE> else : <NEWLINE> <INDENT> ans += x [ i ] * 2 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> k = int ( input ( ) ) <NEWLINE> nums = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = [ ] <NEWLINE> for i in n : <NEWLINE> <INDENT> a . append ( 2 * min ( k - nums [ i ] , nums [ i ] ) ) <NEWLINE> <DEDENT> print ( min ( a ) ) <NEWLINE> <NL> <NL>
N = input ( ) <NEWLINE> K = input ( ) <NEWLINE> l = list ( map ( int ( input ( ) . split ( ) ) ) <NEWLINE> <NL> print ( N , K , l ) <NEWLINE> <NL> for i in l : <NEWLINE> <INDENT> ans = 0 <NEWLINE> ans += min ( i , K - i ) <NEWLINE> <NL> <DEDENT> print ( ans * 2 ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> k = int ( input ( ) ) <NEWLINE> xs = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> sum = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> deltak = abs ( xs [ i ] - k ) <NEWLINE> if xs [ i ] < deltak : <NEWLINE> <INDENT> sum += 2 * xs [ i ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> sum += deltak * 2 <NEWLINE> <DEDENT> <DEDENT> print ( sum ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> k = int ( input ( ) ) <NEWLINE> summ = 0 <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> x = int ( input ( ) ) <NEWLINE> summ += min ( 2 * x , 2 * ( k - x ) ) <NEWLINE> print ( summ ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> k = int ( input ( ) ) <NEWLINE> x = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> <NL> for i in x : <NEWLINE> <INDENT> ans += min ( abs ( x - k ) , x ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
A , B , C , D , E , F = map ( int , input ( ) . split ( ) ) <NEWLINE> dens = 0 <NEWLINE> ans_water = 0 <NEWLINE> ans_sugar = 0 <NEWLINE> for i in range ( 31 ) : <NEWLINE> <INDENT> for j in range ( 31 ) : <NEWLINE> <INDENT> for k in range ( 101 ) : <NEWLINE> <INDENT> for l in range ( 101 ) : <NEWLINE> <INDENT> water = 100 * A * i + 100 * B * j <NEWLINE> sugar = C * k + D * l <NEWLINE> if i == j == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if water + sugar <= F and sugar <= E * ( A * i + B * j ) : <NEWLINE> <INDENT> if dens < sugar / ( sugar + water ) : <NEWLINE> <INDENT> dens = sugar / ( sugar + water ) <NEWLINE> ans_water = water <NEWLINE> ans_sugar = sugar <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans_water + ans_sugar , ans_sugar ) <NEWLINE>
import numpy as np <NEWLINE> <NL> <NL> def solve ( stdin ) : <NEWLINE> <INDENT> A , B , C , D , E , F = stdin <NEWLINE> if A == 1 : <NEWLINE> <INDENT> raise <NEWLINE> <DEDENT> conc = - 1 <NEWLINE> ans = ( 1 , 2 ) <NEWLINE> for na in range ( F // ( 100 * A ) + 1 ) : <NEWLINE> <INDENT> for nb in range ( F // ( 100 * B ) + 1 ) : <NEWLINE> <INDENT> if na == nb == 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> G = F - na * 100 * A - nb * 100 * B <NEWLINE> for nc in range ( G // C + 1 ) : <NEWLINE> <INDENT> for nd in range ( G // D + 1 ) : <NEWLINE> <INDENT> W = na * 100 * A + nb * 100 * B + nc * C + nd * D <NEWLINE> if 0 < W <= F and nc * C + nd * D <= E * ( na * A + nb * B ) : <NEWLINE> <INDENT> conc2 = 100 * ( nc * C + nd * D ) / W <NEWLINE> if conc < conc2 <= 100 * E / ( 100 + E ) : <NEWLINE> <INDENT> ans = ( W , nc * C + nd * D ) <NEWLINE> conc = conc2 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> return ans <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> stdin = np . fromstring ( open ( 0 ) . read ( ) , dtype = np . int64 , sep = <STRING> ) <NEWLINE> print ( * solve ( stdin ) ) <NEWLINE> <NL> <NL> <DEDENT> def cc_export ( ) : <NEWLINE> <INDENT> from numba . pycc import CC <NEWLINE> cc = CC ( <STRING> ) <NEWLINE> cc . export ( <STRING> , <STRING> ) ( solve ) <NEWLINE> cc . compile ( ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> import sys <NEWLINE> if sys . argv [ - 1 ] == <STRING> : <NEWLINE> <INDENT> cc_export ( ) <NEWLINE> exit ( 0 ) <NEWLINE> <DEDENT> from my_module import solve <NEWLINE> main ( ) <NEWLINE> <DEDENT>
A , B , C , D , E , F = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <COMMENT> <NL> list = [ 0 , 0 ] <NEWLINE> <NL> <COMMENT> <NL> ope1 = 100 * A <NEWLINE> ope2 = 100 * B <NEWLINE> ope3 = C <NEWLINE> ope4 = D <NEWLINE> <COMMENT> <NL> w_sum = 0 <NEWLINE> s_sum = 0 <NEWLINE> <COMMENT> <NL> p = 0 <NEWLINE> <COMMENT> <NL> total = w_sum + s_sum <NEWLINE> <COMMENT> <NL> s = 0 <NEWLINE> <NL> for i in range ( 101 ) : <NEWLINE> <INDENT> for j in range ( 101 ) : <NEWLINE> <INDENT> for k in range ( 31 ) : <NEWLINE> <INDENT> for l in range ( 31 ) : <NEWLINE> <INDENT> w_sum = l * ope1 + k * ope2 <NEWLINE> s_sum = j * ope3 + i * ope4 <NEWLINE> if w_sum != 0 and w_sum + s_sum <= F and s_sum <= E * ( l + k ) : <NEWLINE> <INDENT> p_tmp = ( s_sum / ( w_sum + s_sum ) ) * 100 <NEWLINE> if p_tmp >= p : <NEWLINE> <INDENT> p = p_tmp <NEWLINE> list [ 0 ] = w_sum + s_sum <NEWLINE> list [ 1 ] = s_sum <NEWLINE> if s_sum == E * ( l + k ) : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( list [ 0 ] , list [ 1 ] ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> read = sys . stdin . read <NEWLINE> readlines = sys . stdin . readlines <NEWLINE> from math import ceil <NEWLINE> def main ( ) : <NEWLINE> <INDENT> a , b , c , d , e , f = map ( int , input ( ) . split ( ) ) <NEWLINE> a *= 100 <NEWLINE> b *= 100 <NEWLINE> <NL> <COMMENT> <NL> if e == 0 or min ( a , b ) == f : <NEWLINE> <INDENT> print ( a , 0 ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> water = [ 0 ] * 6001 <NEWLINE> water [ 0 ] = True <NEWLINE> for i1 in range ( 3001 ) : <NEWLINE> <INDENT> if water [ i1 ] : <NEWLINE> <INDENT> water [ i1 + a ] = True <NEWLINE> water [ i1 + b ] = True <NEWLINE> <DEDENT> <DEDENT> sugar = [ 0 ] * 6001 <NEWLINE> sugar [ 0 ] = True <NEWLINE> for i1 in range ( 3001 ) : <NEWLINE> <INDENT> if sugar [ i1 ] : <NEWLINE> <INDENT> sugar [ i1 + c ] = True <NEWLINE> sugar [ i1 + d ] = True <NEWLINE> <NL> <DEDENT> <DEDENT> noudo = 0 <NEWLINE> r1 = 0 <NEWLINE> r2 = 0 <NEWLINE> for i1 in range ( 1 , f + 1 ) : <NEWLINE> <INDENT> if water [ i1 ] : <NEWLINE> <INDENT> for i2 in range ( f + 1 ) : <NEWLINE> <INDENT> if i1 + i2 > f : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if sugar [ i2 ] : <NEWLINE> <INDENT> if i1 * e >= i2 * 100 : <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT>
a , b , c , d , e , f = map ( int , input ( ) . split ( ) ) <NEWLINE> con = list ( ) <NEWLINE> s = list ( ) <NEWLINE> for x in range ( 31 ) : <NEWLINE> <INDENT> for y in range ( 31 ) : <NEWLINE> <INDENT> for v in range ( 1501 ) : <NEWLINE> <INDENT> if x == y == 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> w1 = ( f - ( 100 * a * x + 100 * b * y + c * v ) ) // d <NEWLINE> w2 = ( 100 * a * x + 100 * b * y - c * v ) // d <NEWLINE> w3 = ( ( 100 * a * x + 100 * b * y ) * e - c * v * 100 ) // ( 100 * d ) <NEWLINE> w = min ( w1 , w2 , w3 ) <NEWLINE> con1 = 100 * ( c * v + d * w ) / ( 100 * a * x + 100 * b * y + c * v + d * w ) <NEWLINE> con . append ( con1 ) <NEWLINE> s . append ( [ x , y , v , w ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> conm = max ( con ) <NEWLINE> conin = con . index ( conm ) <NEWLINE> t = s [ conin ] <NEWLINE> <COMMENT> <NL> ans1 = 100 * a * t [ 0 ] + 100 * b * t [ 1 ] + c * t [ 2 ] + d * t [ 3 ] <NEWLINE> ans2 = c * t [ 2 ] + d * t [ 3 ] <NEWLINE> print ( ans1 , ans2 ) <NEWLINE>
import numpy as np <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = np . array ( [ input ( ) . split ( ) for _ in range ( N ) ] , dtype = np . int64 ) <NEWLINE> <NL> fill_diagonal ( A , 10 ** 9 ) <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> for j in range ( i + 1 , N ) : <NEWLINE> <INDENT> d = np . min ( A [ i ] + A [ j ] ) <NEWLINE> if A [ i ] [ j ] < d : <NEWLINE> <INDENT> ans += A [ i ] [ j ] <NEWLINE> <DEDENT> elif d < A [ i ] [ j ] : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from scipy . sparse . csgraph import csgraph_from_dense , floyd_warshall <NEWLINE> import numpy as np <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = np . loadtxt ( open ( 0 ) , dtype = np . int ) <NEWLINE> D = csgraph_from_dense ( A ) <NEWLINE> D = floyd_warshall ( D , directed = False ) <NEWLINE> <NL> <NL> if ( A == D ) . all ( ) : <NEWLINE> <INDENT> ans = 0 <NEWLINE> D += np . identity ( N , int ) * ( 1 << 60 ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> for j in range ( i + 1 , N ) : <NEWLINE> <INDENT> a = np . min ( D [ i ] + D [ j ] ) <NEWLINE> if a > D [ i , j ] : <NEWLINE> <INDENT> ans += D [ i , j ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( int ( ans ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT>
N = [ for x in input ( ) ] <NEWLINE> if <STRING> in N : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = input ( ) <NEWLINE> if N in <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else print ( <STRING> ) <NEWLINE>
s = input ( ) <NEWLINE> if s in <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> else : <NEWLINE> print ( <STRING> ) <NEWLINE> <DEDENT>
a = input ( ) <NEWLINE> if 9 in a : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = input ( ) <NEWLINE> if n . count ( 9 ) >= 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
if <STRING> == N [ 0 ] or <STRING> == N [ 1 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> <NL> if n [ 0 ] != 9 and n [ 1 ] != 9 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> if <STRING> in s : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> print ( [ <STRING> , <STRING> ] [ 9 in [ N % 10 , ( N - N % 10 ) // 10 ] ] <NEWLINE>
a = int ( input ( ) ) <NEWLINE> b = a % 10 <NEWLINE> if int ( a / 10 ) == 9 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if b == 9 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
n = input ( ) <NEWLINE> if 9 in n : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> kei = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> <DEDENT> kei += sum ( r ) - sum ( l ) <NEWLINE> kei += n <NEWLINE> print ( kei ) <NEWLINE>
a = int ( input ( ) ) <NEWLINE> b = [ ] <NEWLINE> for _ in range ( a ) : <NEWLINE> <INDENT> b . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <DEDENT> ans = 0 <NEWLINE> for i in range ( a ) : <NEWLINE> <INDENT> ans += n [ i ] [ 1 ] - n [ i ] [ 0 ] + 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
a = int ( input ( ) ) <NEWLINE> b = [ int ( input ( ) ) for i range ( a ) ] <NEWLINE> c = 0 <NEWLINE> for i range ( a ) : <NEWLINE> <INDENT> c = c + ( b [ i ] [ 1 ] - b [ i ] [ 2 ] ) <NEWLINE> <DEDENT> print ( c + a ) <NEWLINE>
2 <NEWLINE> 6 8 <NEWLINE> 3 3 <NEWLINE>
n = int ( input ( ) ) <NEWLINE> out = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a , m = map ( int , input ( ) . split ( ) ) <NEWLINE> out += m - a + 1 <NEWLINE> <DEDENT> print ( out ) <NEWLINE> n = int ( input ( ) ) <NEWLINE> out = 0 <NEWLINE> for i in ( n ) : <NEWLINE> <INDENT> a , m = map ( int , input ( ) . split ( ) ) <NEWLINE> out += m - a + 1 <NEWLINE> <DEDENT> print ( out ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> lr = [ list ( map ( int , input ( ) ) ) for _ in range ( N ) ] <NEWLINE> print ( sum ( [ e [ 1 ] - e [ 0 ] + 1 for e in lr ] ) ) <NEWLINE>
l = [ 0 ] * n <NEWLINE> r = [ 0 ] * n <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> l [ i ] , r [ i ] = map ( int , input ( ) . split ( ) ) <NEWLINE> <DEDENT> res = 0 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> res += r [ i ] - l [ i ] + 1 <NEWLINE> <NL> <DEDENT> print ( res ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> p = 0 <NEWLINE> for in in range ( n ) : <NEWLINE> <INDENT> l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> p += r - l + 1 <NEWLINE> <NL> <DEDENT> print ( n ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> lr = [ map ( int , input ( ) . split ( ) ) for l in range ( n ) ] <NEWLINE> ans = 0 <NEWLINE> for i in lr : <NEWLINE> <INDENT> ans += lr [ i ] [ 1 ] - lr [ i ] [ 0 ] + 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> numbers = [ ] <NEWLINE> answers = [ ] <NEWLINE> number = 0 <NEWLINE> numbers = [ int ( input ( ) ) for _ in range ( n ) ] <NEWLINE> <NL> for number in numbers : <NEWLINE> <INDENT> if len ( answers ) == 0 : <NEWLINE> <INDENT> answers . append ( number ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if number in answers : <NEWLINE> <INDENT> answers . pop ( number ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> answers . append ( number ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( len ( answers ) ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = set ( int ( input ( ) ) for i in range ( n ) ) <NEWLINE> kami = [ ] <NEWLINE> a . sort ( ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if i in kami : <NEWLINE> <INDENT> kami . remove ( i ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> kami . add ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( len ( kami ) ) <NEWLINE>
a . sort ( ) <NEWLINE> count = 0 <NEWLINE> temp = a [ 0 ] <NEWLINE> tempcount = 1 <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> if a [ i ] == temp : <NEWLINE> <INDENT> tempcount += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if not tempcount % 2 == 0 : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> tempcount = 1 <NEWLINE> <DEDENT> temp = a [ i ] <NEWLINE> <COMMENT> <NL> <DEDENT> if tempcount % 2 == 1 : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> print ( count ) <NEWLINE>
from collections import Counter <NEWLINE> n = int ( input ( ) ) <NEWLINE> l = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> l . append ( int ( input ( ) ) ) <NEWLINE> <DEDENT> lcnt = Counter ( l ) <NEWLINE> l_value = list ( lcnt . values ( ) ) <NEWLINE> for i in range ( len ( l_value ) ) : <NEWLINE> <INDENT> if l_value [ i ] % 2 == 0 : <NEWLINE> <INDENT> l_value [ i ] = 0 <NEWLINE> else : <NEWLINE> l_value [ i ] = 1 <NEWLINE> <DEDENT> <DEDENT> print ( sum ( l_value ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = [ False ] * int ( 1e9 ) <NEWLINE> <NL> cnt = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ai = int ( input ( ) ) - 1 <NEWLINE> a [ ai ] = not a [ ai ] <NEWLINE> <NL> if a [ ai ] : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cnt -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> A = [ 0 ] * ( 10 ** 9 + 5 ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a = int ( input ( ) ) <NEWLINE> A [ a - 1 ] += 1 <NEWLINE> A [ a - 1 ] %= 2 <NEWLINE> <DEDENT> print ( sum ( A ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> ans = [ 0 ] * ( 10 ** 9 ) <NEWLINE> <NL> for _ in range ( N ) : <NEWLINE> <INDENT> a = int ( input ( ) ) <NEWLINE> if ans [ a - 1 ] == 0 : <NEWLINE> <INDENT> ans [ a - 1 ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans [ a - 1 ] = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( sum ( ans ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = [ int ( input ( ) ) for _ in range ( n ) ] <NEWLINE> <NL> a = sorted ( a ) : <NEWLINE> tmp = 0 <NEWLINE> ans = 0 <NEWLINE> for i in a : <NEWLINE> <INDENT> if i == tmp : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> tmp = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += 1 <NEWLINE> tmp = i <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import collections <NEWLINE> n = int ( input ( ) ) <NEWLINE> alist = [ int ( input ( ) ) for i in range ( n ) ] <NEWLINE> cole = collections . Counters ( alist ) <NEWLINE> count = 0 <NEWLINE> for i in cole . values ( ) : <NEWLINE> <INDENT> if i % 2 == 1 : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
x , t = map ( int , input ( ) ) <NEWLINE> <NL> print ( x - t ) if x > t else print ( <STRING> ) <NEWLINE>
x , t = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( max ( x - t , 0 ) <NEWLINE>
x , t = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( x - t if x - t >= 0 , 0 else ) <NEWLINE>
<COMMENT> <NL> X , t = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <COMMENT> <NL> Remain = X - t <NEWLINE> if remain > 0 : <NEWLINE> <INDENT> print ( Remain ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
x , t = map ( int , input ( ) . split ( ) ) <NEWLINE> if x - t >= 0 : <NEWLINE> <INDENT> print ( x - t ) <NEWLINE> else : <NEWLINE> print ( 0 ) <NEWLINE> <DEDENT>
print ( int ( input ( ) ) - int ( input ( ) ) ) <NEWLINE>
a , b = ( ( x ) for x in input ( ) . split ( ) ) <NEWLINE> int ( c ) = int ( a ) - int ( b ) <NEWLINE> if c > <STRING> : <NEWLINE> <INDENT> print ( c ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
X = int ( input ( ) ) <NEWLINE> t = int ( input ( ) ) <NEWLINE> print ( X - t if X >= t else 0 ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if a <= b : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( a - b ) : <NEWLINE> <DEDENT>
x , t = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> print ( max ( [ 0 , x - t ] ) <NEWLINE>
print ( max ( 0 , int ( input ( ) ) - int ( input ( ) ) ) ) <NEWLINE>
<COMMENT> <NL> x = int ( input ( ) ) <NEWLINE> t = int ( input ( ) ) <NEWLINE> <NL> <COMMENT> <NL> answer = x - t <NEWLINE> <NL> <COMMENT> <NL> print ( answer ) <NEWLINE>
tmp = input ( ) . split ( <STRING> ) <NEWLINE> <NL> print ( max ( [ tmp [ 0 ] - tmp [ 1 ] , 0 ] ) ) <NEWLINE>
s = list ( input ( ) ) <NEWLINE> s1 = [ ] <NEWLINE> for i in s : <NEWLINE> <INDENT> if ( s . index ( i ) + 1 ) % 2 != 0 : <NEWLINE> <INDENT> s1 . append ( i ) <NEWLINE> <DEDENT> <DEDENT> print ( i for i in s1 , end = <STRING> ) <NEWLINE>
a = input ( ) <NEWLINE> n = [ ] <NEWLINE> for i in range ( len ( a ) ) : <NEWLINE> <INDENT> if i % 2 == 1 : <NEWLINE> <INDENT> n . append ( i ) <NEWLINE> <DEDENT> <DEDENT> ans = <STRING> <NEWLINE> for i in n : <NEWLINE> <INDENT> ans += i <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
s = list ( input ( ) ) <NEWLINE> <NL> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> if i % 2 == 1 : <NEWLINE> <INDENT> s . pop ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> ss = <STRING> . join ( map ( str , s ) ) <NEWLINE> <NL> print ( ss ) <NEWLINE>
s = input ( ) <NEWLINE> x = <STRING> <NEWLINE> for i in range ( 1 , len ( s ) + 1 ) : <NEWLINE> <INDENT> if i % 2 != 0 : <NEWLINE> <INDENT> x = x + s [ i ] <NEWLINE> <DEDENT> <DEDENT> print ( x ) <NEWLINE>
s = input ( ) <NEWLINE> ans = <STRING> <NEWLINE> for i in range ( 1 : : 2 ) : <NEWLINE> <INDENT> ans += s [ i ] <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
a = input ( ) <NEWLINE> b = <STRING> <NEWLINE> for i in range ( a ) : <NEWLINE> <INDENT> b = b + a [ 2 * i ] <NEWLINE> <DEDENT> print ( b ) <NEWLINE>
S = input ( ) <NEWLINE> res = <STRING> <NEWLINE> for i in range ( 0 , N , 2 ) : <NEWLINE> <INDENT> res += S [ i ] <NEWLINE> <DEDENT> print ( res ) <NEWLINE>
s = input ( ) <NEWLINE> for i in range ( 0 , len ( s ) , 2 ) : <NEWLINE> <INDENT> print ( s [ i ] , end = <STRING> ) <NEWLINE> <DEDENT> s = input ( ) <NEWLINE> for i in range ( 0 , len ( s ) , 2 ) : <NEWLINE> <INDENT> print ( s [ i ] , end = <STRING> ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> odd_num = list ( ) <NEWLINE> <NL> for i in range ( len ( s ) ) : <NEWLINE> <NL> <INDENT> if i % 2 == 0 : <NEWLINE> <INDENT> odd_num . append ( s [ i ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> answer = <STRING> . join ( odd_num ) <NEWLINE> print ( answer ) <NEWLINE> <NL> <NL> <NL> s = input ( ) <NEWLINE> print ( s [ : : 2 ] ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> l = [ 0 ] * 10 ** 5 + 2 <NEWLINE> <NL> for i in a : <NEWLINE> <INDENT> l [ i ] += 1 <NEWLINE> l [ i + 1 ] += 1 <NEWLINE> l [ i + 2 ] += 1 <NEWLINE> <NL> <DEDENT> print ( max ( l ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> cnt = [ 0 ] * 10 ** 5 + 5 <NEWLINE> for i in a : <NEWLINE> <INDENT> cnt [ i ] += 1 <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in range ( 1 , 10 ** 5 + 3 ) : <NEWLINE> <INDENT> ans = max ( ans , sum ( cnt [ i - 1 : i + 2 ] ) ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> import os <NEWLINE> import sys <NEWLINE> from collections import Counter <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a . sort ( ) <NEWLINE> cnt_list = Counter ( a ) <NEWLINE> <NL> a_max = a [ - 1 ] <NEWLINE> a_min = a [ 0 ] <NEWLINE> cnt_max = 0 <NEWLINE> for center in range ( a_min - 1 , a_max + 2 ) : <NEWLINE> <INDENT> if center in cnt_list . keys ( ) : <NEWLINE> <INDENT> cnt = cnt_list [ center ] <NEWLINE> <DEDENT> if center - 1 in cnt_list . keys ( ) : <NEWLINE> <INDENT> cnt += cnt_list [ center - 1 ] <NEWLINE> <DEDENT> if center + 1 in cnt_list . keys ( ) : <NEWLINE> <INDENT> cnt += cnt_list [ center + 1 ] <NEWLINE> <DEDENT> if cnt > cnt_max : <NEWLINE> <INDENT> cnt_max = cnt <NEWLINE> <DEDENT> <DEDENT> print ( cnt_max ) <NEWLINE> <NL> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) , split ( ) ) ) <NEWLINE> s = [ 0 ] * max ( a ) + 2 <NEWLINE> for i in a : <NEWLINE> <INDENT> i += 1 <NEWLINE> s [ i - 1 ] += 1 <NEWLINE> s [ i ] += 1 <NEWLINE> s [ i + 1 ] += 1 <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> def func ( a ) : <NEWLINE> <INDENT> count = [ 0 ] * ( max ( a ) + 1 ) <NEWLINE> <NL> for i in a : <NEWLINE> <INDENT> count [ i ] += 1 <NEWLINE> <NL> <DEDENT> max_n = 0 <NEWLINE> for j in range ( 1 , len ( count ) - 1 ) : <NEWLINE> <INDENT> max_n = max ( max_n , count [ j ] + count [ j - 1 ] + count [ j + 1 ] ) <NEWLINE> <DEDENT> max_n = max ( max_n , count [ - 1 ] + count [ - 2 ] ) <NEWLINE> <NL> return max_n <NEWLINE> <NL> <DEDENT> ptint ( n if len ( set ( a ) ) == 1 else func ( a ) ) <NEWLINE>
def solve ( ) : <NEWLINE> <NL> <INDENT> N = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> lists = [ 0 ] * ( ( 10 ** 5 ) + 2 ) <NEWLINE> <NL> for i in range ( a ) : <NEWLINE> <INDENT> lists [ v ] += 1 <NEWLINE> lists [ v + 1 ] += 1 <NEWLINE> lists [ v - 1 ] += 1 <NEWLINE> <NL> <DEDENT> print ( max ( lists ) ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> solve ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> from fractions import gcd <NEWLINE> from itertools import combinations , permutations , accumulate <COMMENT> <NEWLINE> <COMMENT> <NL> from collections import deque , defaultdict , Counter <NEWLINE> import decimal <NEWLINE> import re <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> import sys <NEWLINE> sys . setrecursionlimit ( 10000000 ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <COMMENT> <NL> def readInts ( ) : <NEWLINE> <INDENT> return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <DEDENT> def I ( ) : <NEWLINE> <INDENT> return int ( input ( ) ) <NEWLINE> <DEDENT> n = I ( ) <NEWLINE> A = readInts ( ) <NEWLINE> maxA = max ( A ) <NEWLINE> minA = min ( A ) <NEWLINE> ans = - 1 <NEWLINE> for i in range ( minA , maxA + 1 ) : <NEWLINE> <INDENT> ans = max ( ans , A . count ( i - 1 ) + A . count ( i ) + A . count ( i + 1 ) ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . strip ( ) . split ( ) ) ) <NEWLINE> <NL> dp = [ 0 for n in range ( max ( a ) + 1 ) ] <NEWLINE> for n in range ( N ) : <NEWLINE> <INDENT> dp [ a [ n ] ] += 1 <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for n in range ( len ( dp ) ) : <NEWLINE> <INDENT> if n == 0 : <NEWLINE> <INDENT> ans = max ( ans , a [ 0 ] + a [ 1 ] ) <NEWLINE> <DEDENT> elif n == N - 1 : <NEWLINE> <INDENT> ans = max ( ans , a [ N - 2 ] + a [ N - 1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = max ( ans , dp [ n - 1 ] + dp [ n ] + dp [ n + 1 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> l = [ 0 ] * 10 ** 5 + 2 <NEWLINE> <NL> for v in a : <NEWLINE> <INDENT> l [ v ] += 1 <NEWLINE> l [ v + 1 ] += 1 <NEWLINE> l [ v + 2 ] += 1 <NEWLINE> <NL> <DEDENT> print ( max ( l ) ) <NEWLINE>
IN = iter ( Input . split ( <STRING> ) ) . __next__ <NEWLINE> def input ( ) : <NEWLINE> <INDENT> return IN ( ) <NEWLINE> <NL> <DEDENT> N = int ( input ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> result_list = [ ] <NEWLINE> for a in l : <NEWLINE> <INDENT> result_list . extend ( [ a - 1 , a , a + 1 ] ) <NEWLINE> <NL> <DEDENT> result_list <NEWLINE> <NL> import collections <NEWLINE> <NL> count = collections . Counter ( result_list ) <COMMENT> <NEWLINE> hindo_jun = count . most_common ( ) <NEWLINE> <NL> print ( hindo_jun [ 0 ] [ 1 ] ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> P = map ( int , input ( ) . split ( ) ) <NEWLINE> cnt = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if P [ i ] == i + 1 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> ans = ( cnt + 1 ) // 2 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> res = 0 <NEWLINE> for i in range ( 2 , n : <NEWLINE> <INDENT> if a [ i - 1 ] == i : <NEWLINE> <INDENT> res += 1 <NEWLINE> <DEDENT> <DEDENT> print ( res ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> if a [ i ] == i + 1 : <NEWLINE> <INDENT> a [ i ] , a [ i + 1 ] = a [ i + 1 ] , a [ i ] <NEWLINE> ans += 1 <NEWLINE> <DEDENT> if a [ n ] == n + 1 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> * P , = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> i = c = 0 <NEWLINE> while i < L : <NEWLINE> <INDENT> if P [ i ] == i + 1 : <NEWLINE> <INDENT> c += 1 <NEWLINE> i += 1 <NEWLINE> <DEDENT> i += 1 <NEWLINE> <DEDENT> print ( c ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> P = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if i == N - 1 : <NEWLINE> <INDENT> if P [ i ] == i + 1 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> a , b = P [ i ] , P [ i + 1 ] <NEWLINE> if a == i + 1 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> P [ i ] = b <NEWLINE> P [ i + 1 ] = a <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> P = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> Cnt = [ ] <NEWLINE> for idx , p in enumerate ( P , 1 ) : <NEWLINE> <INDENT> if idx == p : <NEWLINE> <INDENT> Cnt . append ( idx ) <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> if len ( Cnt ) == 0 : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <NL> <DEDENT> elif len ( Cnt ) == 2 : <NEWLINE> <INDENT> ans += Cnt [ 1 ] - Cnt [ 0 ] <NEWLINE> <NL> <DEDENT> elif len ( Cnt ) % 2 : <NEWLINE> <INDENT> for i in range ( 1 , len ( Cnt ) , 2 ) : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> ans += Cnt [ i + 1 ] - Cnt [ i ] <NEWLINE> <DEDENT> elif i == len ( Cnt ) - 1 : <NEWLINE> <INDENT> ans += Cnt [ i ] - Cnt [ i - 1 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += min ( Cnt [ i ] - Cnt [ i - 1 ] , Cnt [ i + 1 ] - Cnt [ i ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( 0 , len ( Cnt ) , 2 ) : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> ans += Cnt [ i + 1 ] - Cnt [ i ] <NEWLINE> <DEDENT> elif i == len ( Cnt ) - 1 : <NEWLINE> <INDENT> ans += Cnt [ i ] - Cnt [ i - 1 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += min ( Cnt [ i ] - Cnt [ i - 1 ] , Cnt [ i + 1 ] - Cnt [ i ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <COMMENT> <NL> <NL> n = int ( input ( ) ) <NEWLINE> P = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> Cnt = [ ] <NEWLINE> cnt = 0 <NEWLINE> ans = 0 <NEWLINE> for idx , p in enumerate ( P , 1 ) : <NEWLINE> <INDENT> if idx == p : <NEWLINE> <INDENT> Cnt . append ( idx ) <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> <DEDENT> if cnt == 2 : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> cnt = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> ans += len ( Cnt ) <NEWLINE> print ( ans ) <NEWLINE>
a , b , c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> n = int ( input ( ) ) <NEWLINE> <NL> b = min ( a + a , b ) <NEWLINE> c = min ( b + b , c ) <NEWLINE> d = min ( c + c , d ) <NEWLINE> <NL> q , r = divmod ( N , 2 ) <NEWLINE> x = q * d + r * c <NEWLINE> print ( x ) <NEWLINE>
q , h , s , d = map ( int , input ( ) . split ( ) ) <NEWLINE> n = int ( input ( ) ) <NEWLINE> <NL> ans = n // 2 * min ( 8 * q , 4 * h , 2 * s , d ) + min ( 4 * q , 2 * h , s ) * ( n % 2 != = 0 ) <NEWLINE> print ( ans ) <NEWLINE>
q , h , s , d = map ( int , input ( ) . split ( ) ) <NEWLINE> n = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> q_per = q / 0.25 <NEWLINE> h_per = h / 0.5 <NEWLINE> s_per = s <NEWLINE> d_per = d / 2 <NEWLINE> list = [ q_per , h_per , s_per , d_per ] <NEWLINE> elif min ( list ) == d_per : <NEWLINE> <INDENT> if n % 2 == 0 : <NEWLINE> <INDENT> ans += d * ( n // 2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += n // 2 * d <NEWLINE> n -= n // 2 <NEWLINE> list . remove ( d_per ) <NEWLINE> if min ( list ) == s_per : <NEWLINE> <INDENT> ans += s_per <NEWLINE> <DEDENT> elif min ( list ) == h_per : <NEWLINE> <INDENT> ans += h * 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += q * 4 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> elif min ( list ) == s_per : <NEWLINE> <INDENT> ans += n * s <NEWLINE> <DEDENT> elif min ( list ) == h_per : <NEWLINE> <INDENT> ans += n * 2 * h <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += n * 4 * q <NEWLINE> <NL> <DEDENT> print ( int ( ans ) ) <NEWLINE>
price = [ int ( x ) for x in input ( ) . split ( ) ] ; <NEWLINE> N = int ( input ( ) ) ; <NEWLINE> price_d = price [ 3 ] ; <NEWLINE> price_s = 2 * price [ 2 ] ; <NEWLINE> price_h = 4 * price [ 1 ] ; <NEWLINE> price_q = 8 * price [ 0 ] ; <NEWLINE> p = min ( [ price_q , price_h , price_s ] ) ; <NEWLINE> if price_d < p : <NEWLINE> <INDENT> if N % 2 == 1 : <NEWLINE> <INDENT> ans = ( N - 1 ) // 2 * price_d + p // 2 ; <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = N // 2 * price_d ; <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> ans = N * p // 2 ; <NEWLINE> <NL> <DEDENT> print ( ans ) ) ; <NEWLINE> <NL>
<COMMENT> <NL> Q , H , S , D = map ( int , input ( ) . split ( ) ) <NEWLINE> N = int ( input ( ) ) <NEWLINE> <NL> Q1 , H1 = 4 * Q , 2 * H <NEWLINE> S = min ( Q1 , H1 , S ) <NEWLINE> <NL> if 2 * S > D : <NEWLINE> <INDENT> cnt_2 = N // 2 <NEWLINE> cnt_1 = N % 2 <NEWLINE> pay = a * cnt_2 + S * cnt_1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> pay = N * S <NEWLINE> <DEDENT> print ( pay ) <NEWLINE>
q , h , re , d = map ( int , input ( ) . split ( ) ) <NEWLINE> n = int ( input ( ) ) <NEWLINE> re = min ( q * 4 , h * 2 , result ) <NEWLINE> print ( min ( result * n , n // 2 * d + ( n % 2 ) * re ) ) <NEWLINE>
Q , H , S , D = map ( int , input ( ) . split ( ) ) <NEWLINE> N = int ( input ( ) ) <NEWLINE> arr = [ 4 * Q * N , 2 * H * N , S * N ] <NEWLINE> if N % 2 == 0 : <NEWLINE> <INDENT> arr . append ( int ( 0.5 * D * N ) ) <NEWLINE> <DEDENT> elif : <NEWLINE> <INDENT> if N >= 3 : <NEWLINE> <INDENT> arr . append ( int ( 0.5 * D * ( N - 1 ) + min ( S , 2 * H , 4 * Q ) ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( min ( arr ) ) <NEWLINE>
a = list ( input ( ) ) <NEWLINE> <NL> unko = [ 0 ] * ( ord ( <STRING> ) + 1 - ord ( <STRING> ) ) <NEWLINE> <NL> for aa in a : <NEWLINE> <INDENT> unko [ ord ( aa ) - ord ( <STRING> ) ] += 1 <NEWLINE> <DEDENT> tmp = 0 <NEWLINE> for u in unko : <NEWLINE> <INDENT> tmp += ( u * ( u - 1 ) ) // 2 <NEWLINE> <NL> <DEDENT> print ( ( n * ( n - 1 ) ) // 2 - tmp ) <NEWLINE>
def getN ( ) : <NEWLINE> <INDENT> return int ( input ( ) ) <NEWLINE> <DEDENT> def getNM ( ) : <NEWLINE> <INDENT> return map ( int , input ( ) . split ( ) ) <NEWLINE> <DEDENT> def getList ( ) : <NEWLINE> <INDENT> return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <DEDENT> def getArray ( intn ) : <NEWLINE> <INDENT> return [ int ( input ( ) ) for i in range ( intn ) ] <NEWLINE> <DEDENT> def input ( ) : <NEWLINE> <INDENT> return sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> <DEDENT> def rand_N ( ran1 , ran2 ) : <NEWLINE> <INDENT> return random . randint ( ran1 , ran2 ) <NEWLINE> <DEDENT> def rand_List ( ran1 , ran2 , rantime ) : <NEWLINE> <INDENT> return [ random . randint ( ran1 , ran2 ) for i in range ( rantime ) ] <NEWLINE> <DEDENT> def rand_ints_nodup ( ran1 , ran2 , rantime ) : <NEWLINE> <INDENT> ns = [ ] <NEWLINE> while len ( ns ) < rantime : <NEWLINE> <INDENT> n = random . randint ( ran1 , ran2 ) <NEWLINE> if not n in ns : <NEWLINE> <INDENT> ns . append ( n ) <NEWLINE> <DEDENT> <DEDENT> return sorted ( ns ) <NEWLINE> <NL> <DEDENT> def rand_query ( ran1 , ran2 , rantime ) : <NEWLINE> <INDENT> r_query = [ ] <NEWLINE> while len ( r_query ) < rantime : <NEWLINE> <INDENT> n_q = rand_ints_nodup ( ran1 , ran2 , 2 ) <NEWLINE> if not n_q in r_query : <NEWLINE> <INDENT> r_query . append ( n_q ) <NEWLINE> <DEDENT> <DEDENT> return sorted ( r_query ) <NEWLINE> <NL> <DEDENT> from collections import defaultdict , deque , Counter <NEWLINE> from sys import exit <NEWLINE> from decimal import * <NEWLINE> import heapq <NEWLINE> from math import sqrt <NEWLINE> from fractions import gcd <NEWLINE> import random <NEWLINE> import string <NEWLINE> import copy <NEWLINE> from itertools import combinations , permutations , product <NEWLINE> from operator import mul , itemgetter <NEWLINE> from functools import reduce <NEWLINE> from bisect import bisect_left , bisect_right <NEWLINE> <NL> import sys <NEWLINE> sys . setrecursionlimit ( 1000000000 ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> A = input ( ) <NEWLINE> Ac = collections . Counter ( A ) <NEWLINE> cnt = 0 <NEWLINE> for val in Ac . values ( ) : <NEWLINE> <INDENT> cnt += val * ( val - 1 ) // 2 <NEWLINE> <DEDENT> print ( len ( A ) * ( len ( A ) - 1 ) // 2 - cnt + 1 ) <NEWLINE>
M = 8 ** 7 <NEWLINE> m , f , g , i = M * 476 + 1 , [ j : = 1 ] , [ k : = 1 ] * M , 0 <NEWLINE> while i < M : i += 1 ; f += f [ - 1 ] * i % m , <NEWLINE> g += pow ( f [ - 1 ] , m - 2 , m ) , <NEWLINE> while i : g [ i - 1 ] = g [ i ] * i % m ; i -= 1 <NEWLINE> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> if A < B : A , B = B , A <NEWLINE> while j <= B : i += k * f [ A + B - j ] * g [ B - j ] ; k = k * 2 % m ; j += 1 <NEWLINE> print ( ( i * f [ B ] * g [ A + B ] + A ) % m ) ) <NEWLINE>
x , a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if abs ( a - x ) > abs ( b - x ) : <NEWLINE> <INDENT> print ( B ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( A ) <NEWLINE> <DEDENT>
x , a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if abs ( a - x ) > abc ( b - x ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
x , a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> y = abs ( x - a ) <NEWLINE> z = abs ( b - x ) <NEWLINE> <INDENT> if y < z : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
x , a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( min ( abs ( x - a ) , abs ( x - b ) ) <NEWLINE>
x , a , c = map ( int , input ( ) . split ( ) ) <NEWLINE> if abs ( x - a ) <= abs ( x - b ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
x , a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( min ( abs ( x - a ) , abs ( x - b ) ) <NEWLINE>
x , a , b = map ( int , input . split ( ) ) <NEWLINE> print ( <STRING> if max ( x , a ) - min ( x , a ) < max ( x , b ) - min ( x , b ) else <STRING> ) <NEWLINE>
a , b , c = ( int ( x ) for x in input ( ) . split ( ) ) <NEWLINE> if a < b < c : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a < c < b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif b < a < c : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif b < c < a : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif c < a < b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif c < b < a <NEWLINE>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> int ( input ( ) ) <NEWLINE> list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> input ( ) . rstrip ( ) <NEWLINE>
x , a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( <STRING> ) if abs ( x - a ) < abs ( s - b ) else print ( <STRING> ) <NEWLINE>
X , A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> print ( min ( abs ( X - A ) , abs ( B - X ) ) <NEWLINE>
s = input ( ) <NEWLINE> alh = <STRING> <NEWLINE> exist = False <NEWLINE> ans = <STRING> <NEWLINE> for i in alf : <NEWLINE> <INDENT> if i in s : <NEWLINE> <INDENT> exist = True <NEWLINE> <DEDENT> if not exist : <NEWLINE> <INDENT> ans = i <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
s = input ( ) <NEWLINE> <NL> import string <NEWLINE> a = list ( string . ascii_lowercase ) <NEWLINE> <NL> for item in a : <NEWLINE> <INDENT> if item not in s : <NEWLINE> <INDENT> print ( a [ i ] ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> for i in range ( 97 , 113 + 1 ) : <NEWLINE> <INDENT> if s . find ( chr ( i ) ) == - 1 : <NEWLINE> <INDENT> print ( c ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
def i ( ) : <NEWLINE> <INDENT> return int ( input ( ) ) <NEWLINE> <DEDENT> def i2 ( ) : <NEWLINE> <INDENT> return map ( int , input ( ) . split ( ) ) <NEWLINE> <DEDENT> def s ( ) : <NEWLINE> <INDENT> return str ( input ( ) ) <NEWLINE> <DEDENT> def l ( ) : <NEWLINE> <INDENT> return list ( input ( ) ) <NEWLINE> <DEDENT> def intl ( ) : <NEWLINE> <INDENT> return list ( int ( k ) for k in input ( ) . split ( ) ) <NEWLINE> <NL> <DEDENT> s = l ( ) <NEWLINE> alf = <STRING> <NEWLINE> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> alf = alf . trplace ( s [ i ] , <STRING> ) <NEWLINE> <DEDENT> print ( alf ) <NEWLINE> if alf == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( alf [ 0 ] ) <NEWLINE> <DEDENT>
S = input ( ) <NEWLINE> List = list ( S ) <NEWLINE> s_l = set ( List ) <NEWLINE> n = 10 <NEWLINE> res = <STRING> <NEWLINE> for i in range ( 97 , 113 ) : <NEWLINE> <INDENT> n = s_l . count ( chr ( i ) ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> res = chr ( i ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( res ) <NEWLINE>
S = list ( input ( ) ) <NEWLINE> lst = [ chr ( i ) for i in range ( 97 , 97 + 26 ) ] <NEWLINE> res = sorted ( list ( set ( lst ) - set ( S ) ) ) <NEWLINE> <NL> if res = [ ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( res [ 0 ] ) <NEWLINE> <DEDENT>
s = sorted ( input ( ) ) <NEWLINE> for i in range ( len ( s ) - 1 ) : <NEWLINE> <INDENT> if ord ( s [ i + 1 ] ) - ord ( s [ i ] ) >= 2 : <NEWLINE> <INDENT> print ( chr ( ord ( s [ i ] + 1 ) ) ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> s = list ( input ( ) ) <NEWLINE> for i in range ( 0 , 26 ) : <NEWLINE> <INDENT> if not chr ( 97 + i ) in s : <NEWLINE> <INDENT> print ( chr + i ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
s_list = list ( input ( ) ) <NEWLINE> <NL> result = None <NEWLINE> <NL> for s_uni in range ( ord ( <STRING> ) , ord ( <STRING> ) + 1 ) : <NEWLINE> <INDENT> if not chr ( s_uni ) in s_list : <NEWLINE> <INDENT> result = chr ( s_uni ) <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if result : <NEWLINE> <INDENT> print ( result ) <NEWLINE> <DEDENT> else <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s = list ( input ( ) ) <NEWLINE> t = [ chr ( i ) for i in range ( ord ( <STRING> ) , ord ( <STRING> ) + 1 ) ] <NEWLINE> for i in s : <NEWLINE> <INDENT> t . remove ( i ) <NEWLINE> <DEDENT> if t : <NEWLINE> <INDENT> print ( t [ 0 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import sys <NEWLINE> from string import ascii_lowercase as aplhabets <NEWLINE> from collections import defaultdict <NEWLINE> <NL> readline = sys . stdin . readline <NEWLINE> <NL> s = readline ( ) . split ( ) <NEWLINE> d = defautdict ( int ) <NEWLINE> for x in s : <NEWLINE> <INDENT> d [ x ] = 1 <NEWLINE> <DEDENT> for a in alphabets : <NEWLINE> <INDENT> if d [ a ] == 0 : <NEWLINE> <INDENT> print ( a ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
s = input ( ) <NEWLINE> print ( chr ( i ) ) for i in range ( ord ( <STRING> ) , ord ( <STRING> ) + 1 ) if chr ( i ) not in s <NEWLINE>
import sys <NEWLINE> from collections import Counter <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> box , box2 = [ ] , [ ] <NEWLINE> acnt = dict ( Counter ( a ) ) <NEWLINE> acnt = sorted ( acnt . items ( ) , key = lambda x : x [ 0 ] , reverse = True ) <NEWLINE> a_val = [ acnt [ x ] [ 1 ] for x in range ( len ( acnt ) ) ] <NEWLINE> a_key = [ acnt [ y ] [ 0 ] for y in range ( len ( acnt ) ) ] <NEWLINE> for i in range ( len ( a_val ) ) : <NEWLINE> <INDENT> if a_val [ i ] >= 4 : <NEWLINE> <INDENT> box2 . append ( a_key [ i ] ** 2 ) <NEWLINE> <DEDENT> if 2 <= a_val [ i ] : <NEWLINE> <INDENT> box . append ( a_key [ i ] ) <NEWLINE> <DEDENT> <DEDENT> box . sort ( reverse = True ) <NEWLINE> if len ( box2 ) >= 2 : <NEWLINE> <INDENT> ans = max ( box2 ) <NEWLINE> <DEDENT> if len ( box ) >= 2 : <NEWLINE> <INDENT> print ( max ( ans , ( box [ 0 ] * box [ 1 ] ) ) ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> print ( 0 ) <NEWLINE>
from collections import defaultdict <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = [ ] <NEWLINE> c = [ ] <NEWLINE> d = defaultdict ( int ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> d [ a [ i ] ] += 1 <NEWLINE> <NL> <DEDENT> for i , j in d . items ( ) : <NEWLINE> <INDENT> if j >= 2 : <NEWLINE> <INDENT> b . append ( i ) <NEWLINE> <DEDENT> if j >= 4 : <NEWLINE> <INDENT> c . append ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> if len ( b ) < 2 and len ( c ) < 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> elif len ( c ) == 1 and len ( b ) < 2 : <NEWLINE> <INDENT> print ( c [ 0 ] ** 2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> b . sort ( reverse = True ) <NEWLINE> rec = b [ 0 ] * b [ 1 ] <NEWLINE> if len ( c ) >= 1 : <NEWLINE> <INDENT> c . sort ( reverse = True ) <NEWLINE> cube = c [ 0 ] ** 2 <NEWLINE> <DEDENT> print ( max ( rec , cube ) ) <NEWLINE> <DEDENT>
Flag = False <NEWLINE> LS = 0 <NEWLINE> SS = 0 <NEWLINE> for T in range ( 0 , len ( A ) ) : <NEWLINE> <INDENT> if LS == 0 and A [ T ] [ 1 ] >= 4 : <NEWLINE> <INDENT> Sq = A [ T ] [ 0 ] ** 2 <NEWLINE> Flag = True <NEWLINE> break <NEWLINE> <DEDENT> if A [ T ] [ 1 ] >= 2 : <NEWLINE> <INDENT> if LS == 0 : <NEWLINE> <INDENT> LS = A [ T ] [ 0 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> SS = A [ T ] [ 0 ] <NEWLINE> Sq = LS * SS <NEWLINE> Flag = True <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if Flag : <NEWLINE> <INDENT> print ( Sq ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> A = A . sort ( ) <NEWLINE> b = set ( A ) <NEWLINE> b = list ( b ) <NEWLINE> a = [ i for i in b if A . count ( i ) >= 2 ] <NEWLINE> <NL> if len ( a ) <= 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a = set ( a ) <NEWLINE> a = list ( a ) <NEWLINE> a . reverse ( ) <NEWLINE> print ( a [ 0 ] * a [ 1 ] ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> import sys <NEWLINE> from io import StringIO <NEWLINE> import unittest <NEWLINE> <NL> <NL> class TestClass ( unittest . TestCase ) : <NEWLINE> <INDENT> def assertIO ( self , input , output ) : <NEWLINE> <INDENT> stdout , stdin = sys . stdout , sys . stdin <NEWLINE> sys . stdout , sys . stdin = StringIO ( ) , StringIO ( input ) <NEWLINE> resolve ( ) <NEWLINE> sys . stdout . seek ( 0 ) <NEWLINE> out = sys . stdout . read ( ) [ : - 1 ] <NEWLINE> sys . stdout , sys . stdin = stdout , stdin <NEWLINE> self . assertEqual ( out , output ) <NEWLINE> <NL> <DEDENT> def test__1 ( self ) : <NEWLINE> <INDENT> input = <STRING> <NEWLINE> output = <STRING> <NEWLINE> self . assertIO ( input , output ) <NEWLINE> <NL> <DEDENT> def test__2 ( self ) : <NEWLINE> <INDENT> input = <STRING> <NEWLINE> output = <STRING> <NEWLINE> self . assertIO ( input , output ) <NEWLINE> <NL> <DEDENT> def test__3 ( self ) : <NEWLINE> <INDENT> input = <STRING> <NEWLINE> output = <STRING> <NEWLINE> self . assertIO ( input , output ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def resolve ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> Num = [ 0 ] * 10 ** 9 <NEWLINE> for a in A : <NEWLINE> <INDENT> Num [ a - 1 ] += 1 <NEWLINE> <NL> <DEDENT> l1 = l2 = 0 <NEWLINE> for i in range ( N - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> if l1 == 0 : <NEWLINE> <INDENT> if Num [ i ] >= 2 : <NEWLINE> <INDENT> l1 = i + 1 <NEWLINE> if Num [ i ] >= 4 : <NEWLINE> <INDENT> l2 = i + 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if Num [ i ] >= 2 : <NEWLINE> <INDENT> l2 = i + 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( l1 * l2 ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <COMMENT> <NL> <INDENT> resolve ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) a = list ( map ( int , input ( ) . split ( <STRING> ) ) ) x = 0 y = 0 a . sort ( ) a . reverse ( ) for i in range ( len ( a ) - 1 ) : if a [ i ] == a [ i + 1 ] : x = a [ i ] p = i + 1 break if x != 0 : for i in range ( ( p + 1 ) , len ( a ) - 1 ) : if a [ i ] == a [ i + 1 ] : y = a [ i ] break print ( x * y ) <NEWLINE>
import sys <NEWLINE> <NL> n , * a = map ( int , sys . stdin . read ( ) ) <NEWLINE> <NL> a . sort ( reverse = True ) <NEWLINE> c = 0 <NEWLINE> f = 0 <NEWLINE> ans = [ ] <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> if a [ i ] == a [ i + 1 ] : <NEWLINE> <INDENT> c += 1 <NEWLINE> f += 1 <NEWLINE> ans . append ( a [ i ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> f = 0 <NEWLINE> <DEDENT> if ( c == 2 and f == 1 ) or ( c == 3 and f == 2 ) : <NEWLINE> <INDENT> print ( ans [ 0 ] * ans [ 1 ] ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( 0 ) <NEWLINE> <NL>
from collections import Counter <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = Counter ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> a = [ list ( x ) for x in a . items ( ) if x [ 1 ] >= 2 ] <NEWLINE> a . sort ( reverse = True , key = lambda x : ( x [ 0 ] , x [ 1 ] ) ) <NEWLINE> count = 0 <NEWLINE> base = 4 <NEWLINE> for i in len ( a ) : <NEWLINE> <INDENT> if count == 1 : <NEWLINE> <INDENT> print ( l * a [ i ] [ 0 ] ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> l = a [ 0 ] <NEWLINE> count += 1 <NEWLINE> <NL> <DEDENT> if a [ 1 ] >= 4 : <NEWLINE> <INDENT> print ( a [ i ] [ 0 ] * a [ i ] [ 0 ] ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( 0 ) <NEWLINE>
from collections import defaultdict <NEWLINE> from collections import deque <NEWLINE> import itertools <NEWLINE> import math <NEWLINE> <NL> def readInt ( ) : <NEWLINE> <INDENT> return int ( input ( ) ) <NEWLINE> <DEDENT> def readInts ( ) : <NEWLINE> <INDENT> return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <DEDENT> def readChar ( ) : <NEWLINE> <INDENT> return input ( ) <NEWLINE> <DEDENT> def readChars ( ) : <NEWLINE> <INDENT> return input ( ) . split ( ) <NEWLINE> <NL> <DEDENT> d = defaultdict ( int ) <NEWLINE> n = readInt ( ) <NEWLINE> for i in readChars ( ) : <NEWLINE> <INDENT> d [ i ] += 1 <NEWLINE> <NL> <DEDENT> d = [ i for i in sorted ( d . items ( ) , reverse = True ) if i [ 1 ] >= 2 ] <NEWLINE> <NL> if len ( d ) == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> elif len ( d ) == 1 : <NEWLINE> <INDENT> if d [ 0 ] [ 1 ] >= 4 : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> if d [ 0 ] [ 1 ] >= 4 : <NEWLINE> <INDENT> print ( int ( d [ 0 ] [ 0 ] ) ** 2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( int ( d [ 0 ] [ 0 ] ) * int ( d [ 1 ] [ 0 ] ) ) <NEWLINE> raise Exception <NEWLINE> <DEDENT>
import collections <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c = sorted ( collections . Counter ( a ) . items ( ) , reverse = True ) <NEWLINE> <NL> num2 = [ ] <NEWLINE> num4 = [ ] <NEWLINE> <NL> for k in c : <NEWLINE> <INDENT> if k [ 1 ] >= 4 : <NEWLINE> <INDENT> num4 . append ( k [ 0 ] ) <NEWLINE> <DEDENT> if k [ 1 ] >= 2 : <NEWLINE> <INDENT> num2 . append ( k [ 0 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> if len ( num2 ) >= 2 or len ( num4 ) >= 1 : <NEWLINE> <INDENT> print ( max ( num2 [ 0 ] * num2 [ 1 ] , num4 [ 0 ] ** 2 ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT>
import collections <NEWLINE> n = int ( input ( ) ) <NEWLINE> alist = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> adic = collections . Counter ( alist ) <NEWLINE> A = [ 0 , 0 ] <NEWLINE> for i in adic : <NEWLINE> <INDENT> if adic [ i ] > 1 : <NEWLINE> <INDENT> A . append ( i ) <NEWLINE> <DEDENT> if adic [ i ] > 3 : <NEWLINE> <INDENT> A . append ( i ) <NEWLINE> <DEDENT> <DEDENT> sortedA = sorted ( A ) <NEWLINE> print ( sorted [ - 1 ] * sorted [ - 2 ] ) <NEWLINE>
A , B , C = map ( int , input ( ) . split ( ) ) <NEWLINE> if A == C : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
x = int ( input ( ) ) <NEWLINE> if x [ 0 ] == x [ 2 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
print ( <STRING> [ s : = input ( ) == s [ : : - 1 ] ] : : 2 ) <NEWLINE>
s - input ( ) <NEWLINE> if s [ 0 ] == s [ - 1 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
print ( <STRING> if input ( ) == reversed ( ( input ( ) ) else <STRING> ) <NEWLINE>
s = rr ( ) <NEWLINE> print ( <STRING> [ s [ 0 ] != s [ 2 ] : : 2 ] ) <NEWLINE>
<COMMENT> <NL> n = input ( ) . split ( ) <NEWLINE> print ( <STRING> if ( a [ - 1 ] == a [ 0 ] ) else <STRING> ) <NEWLINE>
tmp = input ( ) . split ( <STRING> ) <NEWLINE> print ( <STRING> ) if tmp [ 0 ] == tmp [ 2 ] else print ( <STRING> ) <NEWLINE>
N = list ( int ( input ( ) ) ) <NEWLINE> if N [ 0 ] == N [ 2 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
array = list ( map ( str , input ( ) . split ( ) ) ) <NEWLINE> if array [ 0 ] == array [ 2 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a = input ( ) <NEWLINE> b = <STRING> <NEWLINE> for i in range ( len ( a ) , 0 , - 1 ) : <NEWLINE> <INDENT> b += a [ i ] <NEWLINE> <DEDENT> if a == b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = input ( ) <NEWLINE> if n % 100 == n / 100 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> if n [ 0 ] == n [ 2 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a = int ( input ( ) ) <NEWLINE> if a == a [ : : - 1 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = list ( int , input ( ) ) <NEWLINE> m = n . sort ( reverse = True ) <NEWLINE> if n == m : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b , c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if b <= c or d <= a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( min ( d , b ) - max ( a - c ) ) <NEWLINE> <DEDENT>
A , B , C , D = map ( int , input ( ) . split ( ) ) <NEWLINE> X = set ( [ for i in range ( A , B + 1 ) ] ) <NEWLINE> print ( sum ( [ 1 for i in range ( C , D + 1 ) if i in X ] ) ) <NEWLINE>
l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if l [ 1 ] < l [ 2 ] : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> elif l [ 0 ] > l [ 4 ] : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> l . sort ( ) <NEWLINE> print ( l [ 2 ] - l [ 1 ] ) <NEWLINE> <DEDENT>
a , b , c , d = map ( int ( input ( ) . split ( ) ) ) <NEWLINE> <NL> if b > c : <NEWLINE> <INDENT> print ( b - c ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT>
<INDENT> a , b , c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> <DEDENT> print ( max ( min ( b , d ) - max ( a , c ) , 0 ) ) <NEWLINE>
a , b , c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> if b > c : <NEWLINE> <INDENT> print ( b - c - a ) <NEWLINE> <DEDENT> elif : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT>
a , b , c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> print ( max ( min ( b , d ) - max ( a , c ) , 0 ) <NEWLINE>
import math <NEWLINE> from functools import reduce <NEWLINE> n = int ( input ( ) ) <NEWLINE> lis = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> lis . append ( int ( input ( ) ) ) <NEWLINE> <DEDENT> def lcm_base ( x , y ) : <NEWLINE> <INDENT> return ( x * y ) // math . gcd ( x , y ) <NEWLINE> <NL> <DEDENT> def lcm ( * numbers ) : <NEWLINE> <INDENT> return reduce ( lcm_base , numbers , 1 ) <NEWLINE> <NL> <DEDENT> def lcm_list ( numbers ) : <NEWLINE> <INDENT> return reduce ( lcm_base , numbers , 1 ) <NEWLINE> <DEDENT> print ( lcm ( lis ) ) <NEWLINE>
import math <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> a = [ ] <NEWLINE> <INDENT> for i in range ( n ) : <NEWLINE> <INDENT> a . append ( int ( input ( ) ) ) <NEWLINE> <DEDENT> <DEDENT> if n == 1 : <NEWLINE> <INDENT> print ( a [ 0 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> lcm = ( a [ 0 ] * a [ 1 ] ) // math . gcd ( a [ 0 ] , a [ 1 ] ) <NEWLINE> for i in range ( 2 , n ) : <NEWLINE> <INDENT> lcm = ( lcm * a [ i ] ) // math . gcd ( lcm , a [ i ] ) <NEWLINE> <DEDENT> print ( lcm ) <NEWLINE> <DEDENT>
import math <NEWLINE> N = int ( input ( ) ) <NEWLINE> T = [ ] <NEWLINE> <NL> def lcm ( x , y ) : <NEWLINE> <INDENT> gc = math . gcd ( x , y ) <NEWLINE> ans = ( x * y ) // gc <NEWLINE> return ans <NEWLINE> <NL> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> T . append ( int ( input ( ) ) ) <NEWLINE> <NL> <NL> <NL> <DEDENT> if len ( T ) > 2 : <NEWLINE> <INDENT> g = lcm ( T [ 0 ] , T [ 1 ] ) <NEWLINE> for i in range ( 3 , N - 1 ) : <NEWLINE> <INDENT> g = lcm ( g , T [ i + 1 ] ) <NEWLINE> <DEDENT> print ( g ) <NEWLINE> <DEDENT> elif len ( T ) == 2 : <NEWLINE> <INDENT> print ( g ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( T [ 0 ] ) <NEWLINE> <DEDENT>
from heapq import heappush , heappop <NEWLINE> from collections import defaultdict <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> graph = defaultdict ( list ) <NEWLINE> <NL> <COMMENT> <NL> for _ in range ( n - 1 ) : <NEWLINE> <INDENT> a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> graph [ a ] . append ( ( b , c ) ) <NEWLINE> graph [ b ] . append ( ( a , c ) ) <NEWLINE> <NL> <DEDENT> q , k = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <NL> <COMMENT> <NL> INF = 1 << 60 <NEWLINE> dist = [ INF ] * ( n + 1 ) <NEWLINE> dist [ k ] = 0 <NEWLINE> <NL> <COMMENT> <NL> q = [ ( 0 , k ) ] <NEWLINE> <NL> <COMMENT> <NL> while q : <NEWLINE> <INDENT> cost , curr = heappop ( q ) <NEWLINE> if cost > dist [ curr ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> for after , nc in graph [ curr ] : <NEWLINE> <INDENT> if cost + nc < dist [ after ] : <NEWLINE> <INDENT> dist [ after ] = cost + nc <NEWLINE> heappush ( q , ( cost + nc , after ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> . join ( map ( str , ( dist [ x ] + dist [ y ] <NEWLINE> <INDENT> for x , y in ( map ( int , input ( ) . split ( ) ) for _ in range ( q ) ) ) ) ) ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> m = int ( input ( ) ) <NEWLINE> print ( ( n - 1 ) * ( m - 1 ) ) <NEWLINE>
n , n = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> print ( ( n - 1 ) * ( m - 1 ) ) <NEWLINE>
aaa <NEWLINE>
<COMMENT> <NL> N = int ( input ( ) ) <NEWLINE> N_List = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> Four_List = [ i for i in N_List if i % 4 == 0 ] <NEWLINE> Two_List = [ i for i in N_List if i % 2 == 0 ] <NEWLINE> if len ( Two_List ) - len ( Four_List ) > 0 : <NEWLINE> <INDENT> N = N - ( len ( Two_List ) - len ( Four_List ) ) + 1 <NEWLINE> <NL> <DEDENT> if N // 2 <= len ( Four_List ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n , m = [ map ( int , input ( ) . split ( ) ) for i in range ( 2 ) ] <NEWLINE> print ( ( n - 1 ) * ( m - 1 ) ) <NEWLINE>
n , m = map ( intput ( ) . split ( ) ) <NEWLINE> print ( ( n - 1 ) * ( m - 1 ) ) <NEWLINE>
print ( ( int ( input ( ) ) - 1 ) * ( int ( input ( ) ) - 1 ) ) <NEWLINE>
n , m = int ( input ( ) . split ( ) ) <NEWLINE> k = ( n - 1 ) * ( m - 1 ) <NEWLINE> print ( k ) <NEWLINE>
n , m = map ( int , input . split ( ) ) <NEWLINE> print ( ( n - 1 ) * ( m - 1 ) ) <NEWLINE>
n , m = map ( int , input ( ) ) <NEWLINE> ans = ( n - 1 ) * ( m - 1 ) <NEWLINE> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> print ( 2 * n , end = <STRING> ) <NEWLINE>
x , y = int ( input ( ) . split ( ) ) <NEWLINE> print ( ( x - 1 ) * ( y - 1 ) ) <NEWLINE>
n , m = map ( int , input . split ( ) ) <NEWLINE> print ( ( n - 1 ) * ( m - 1 ) ) <NEWLINE>
from sys import stdin , stdout <NEWLINE> def main ( ) : <NEWLINE> <INDENT> line = stdin . readLine ( ) <NEWLINE> parts = line . split ( ) <NEWLINE> a = int ( parts [ 1 ] ) <NEWLINE> b = int ( parts [ 2 ] ) <NEWLINE> stdout . write ( ( a - 1 ) * ( b - 1 ) ) <NEWLINE> <DEDENT> main ( ) <NEWLINE>
x , y = input ( ) . split ( ) <NEWLINE> a = x - 1 <NEWLINE> b = y - 1 <NEWLINE> print ( a * b ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> m = int ( input ( ) ) <NEWLINE> print ( ( n - 1 ) * ( m - 1 ) ) <NEWLINE>
n , m = map ( int , imput ( ) . split ( ) ) <NEWLINE> print ( ( n - 1 ) * ( m - 1 ) ) <NEWLINE>
a , b = list ( map ( int , input ( ) ) ) <NEWLINE> <NL> print ( ( a - 1 ) * ( b - 1 ) ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( n * m - 2 ( n + m ) + 4 ) <NEWLINE>
print ( ( int ( input ( ) ) - 1 ) * ( int ( input ( ) ) - 1 ) ) <NEWLINE>
import sys <NEWLINE> import math <NEWLINE> import itertools <NEWLINE> import collections <NEWLINE> import heapq <NEWLINE> import re <NEWLINE> import numpy as np <NEWLINE> from functools import reduce <NEWLINE> <NL> rr = lambda : sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> rs = lambda : sys . stdin . readline ( ) . split ( ) <NEWLINE> ri = lambda : int ( sys . stdin . readline ( ) ) <NEWLINE> rm = lambda : map ( int , sys . stdin . readline ( ) . split ( ) ) <NEWLINE> rl = lambda : list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) <NEWLINE> inf = float ( <STRING> ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> s = rr ( ) <NEWLINE> print ( s [ 0 ] + str ( len ( s - 2 ) ) + s [ - 1 ] ) <NEWLINE> <NL> <NL> <NL> <NL> <NL> <NL> <NL>
a = input ( ) <NEWLINE> print ( s [ 0 ] + str ( len ( s ) - 2 ) + s [ - 1 ] ) <NEWLINE>
s = input ( ) <NEWLINE> print ( s [ 0 ] + int ( len ( s ) - 2 ) + s [ - 1 ] ) <NEWLINE>
a = input ( ) <NEWLINE> print ( a [ 0 ] + str ( len ( a - 2 ) ) + a [ - 1 ] ) <NEWLINE>
<INDENT> s = input ( ) <NEWLINE> <DEDENT> print ( <STRING> . format ( s [ 0 ] , len ( s ) - 2 , s [ - 1 ] ) ) <NEWLINE>
s = input ( ) <NEWLINE> print ( s [ 0 ] + str ( len ( s - 2 ) ) + s [ - 1 ] ) <NEWLINE>
s = input ( ) <NEWLINE> print ( s [ 0 ] + ( len ( s ) - 2 ) + s [ - 1 ] ) <NEWLINE>
s = input ( ) <NEWLINE> N = len ( s ) <NEWLINE> print ( s [ 0 ] + len ( N - 2 ) + s [ N - 1 ] ) <NEWLINE>
s = input ( ) <NEWLINE> print ( s [ 0 ] + ( len ( s ) - 1 ) + s [ - 1 ] ) <NEWLINE>
s = input ( ) <NEWLINE> print ( s [ : 1 ] + str ( len ( s - 2 ) ) + s [ - 1 : ] ) <NEWLINE>
a = list ( input ( ) ) <NEWLINE> n = len ( a ) - 2 <NEWLINE> print ( a [ 0 ] , n , a [ - 1 ] , sep = ( <STRING> ) <NEWLINE>
import sys <NEWLINE> <NL> line = sys . stdin <NEWLINE> line = line . strip ( ) <NEWLINE> start = line [ 0 ] <NEWLINE> end = line [ - 1 ] <NEWLINE> print ( <STRING> % ( start , len ( line ) - 2 , end ) ) <NEWLINE>
s = input ( ) <NEWLINE> print ( s [ 0 ] + int ( len ( s ) - 2 ) + s [ - 1 ] ) <NEWLINE>
s = input ( ) <NEWLINE> t = len ( s ) <NEWLINE> print ( s [ 0 ] + t + s [ - 1 ] ) <NEWLINE>
s = intput ( ) <NEWLINE> <NL> print ( s [ 0 ] + str ( ( len ( s ) - 2 ) ) + s [ - 1 ] ) <NEWLINE>
s = input ( ) <NEWLINE> print ( s [ 0 ] + ( len ( s ) - 2 ) + s [ len ( s ) - 1 ] ) <NEWLINE>
S = input ( ) <NEWLINE> print ( S [ 0 ] + len ( S [ 1 : - 1 ] ) + S [ - 1 ] ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> from fractions import gcd <NEWLINE> from itertools import combinations , permutations , accumulate , product <COMMENT> <NEWLINE> <COMMENT> <NL> from collections import deque , defaultdict , Counter <NEWLINE> import decimal <NEWLINE> import re <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> import sys <NEWLINE> sys . setrecursionlimit ( 10000000 ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <COMMENT> <NL> def readInts ( ) : <NEWLINE> <INDENT> return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <DEDENT> def I ( ) : <NEWLINE> <INDENT> return int ( input ( ) ) <NEWLINE> <DEDENT> n = I ( ) <NEWLINE> A = readInts ( ) <NEWLINE> four = 0 <NEWLINE> two = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if A [ i ] % 4 == 0 : <NEWLINE> <INDENT> four += 1 <NEWLINE> <DEDENT> elif A [ i ] % 2 == 0 : <NEWLINE> <INDENT> two += 1 <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> if a + b // 2 >= n // 2 else <STRING> ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a , b , c = 0 , 0 , 0 <NEWLINE> ans = <STRING> <NEWLINE> for i in a : <NEWLINE> <INDENT> if a % 4 == 0 : <NEWLINE> <INDENT> a += 1 <NEWLINE> <DEDENT> elif a % 2 == 0 : <NEWLINE> <INDENT> b += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> c += 1 <NEWLINE> <DEDENT> <DEDENT> if n % 2 == 1 : <NEWLINE> <INDENT> if c - a == 1 : <NEWLINE> <INDENT> if b == 0 : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <DEDENT> <DEDENT> elif a >= c : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if a >= c : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> li = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> lis = [ ] <NEWLINE> x = 0 <NEWLINE> y = 0 <NEWLINE> z = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if li [ i ] % 4 == 0 : <NEWLINE> <INDENT> x += 1 <NEWLINE> <DEDENT> elif li [ i ] % 2 == 0 : <NEWLINE> <INDENT> y = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> z += 1 <NEWLINE> <DEDENT> <DEDENT> if y = 0 : <NEWLINE> <INDENT> if x >= y + 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if x >= y : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> even4 , even , odd = 0 , 0 , 0 <NEWLINE> for i in a : <NEWLINE> <INDENT> if i % 4 == 0 : <NEWLINE> <INDENT> even4 += 1 <NEWLINE> <DEDENT> elif i % 2 == 0 : <NEWLINE> <INDENT> even += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> odd += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if n % 2 == 0 : <NEWLINE> <INDENT> if even4 >= odd : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if even4 >= odd + 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> a = [ int ( i ) for i input ( ) . split ( ) ] <NEWLINE> <NL> ki = 0 <NEWLINE> gu_2 = 0 <NEWLINE> gu_4 = 0 <NEWLINE> <NL> for i in a : <NEWLINE> <INDENT> if i % 4 == 0 : <NEWLINE> <INDENT> gu_4 += 1 <NEWLINE> <DEDENT> elif i % 2 == 0 : <NEWLINE> <INDENT> gu_2 += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ki += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if ki <= gu_4 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = 0 <NEWLINE> b = 0 <NEWLINE> for num in A : <NEWLINE> <INDENT> if num % 2 == 1 : <NEWLINE> <INDENT> a += 1 <NEWLINE> <DEDENT> elif num % 4 == 0 : <NEWLINE> <INDENT> b += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if N == 3 : <NEWLINE> <INDENT> if a == 3 or ( a >= 1 and b == 0 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if a = < b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
import math <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> c_4 = 0 <NEWLINE> c_2 = 0 <NEWLINE> <NL> for i in l : <NEWLINE> <INDENT> if i % 4 == 0 : <NEWLINE> <INDENT> c_4 += 1 <NEWLINE> <DEDENT> elif i % 2 == 0 : <NEWLINE> <INDENT> c_2 += 1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if c_2 == 1 : <NEWLINE> <INDENT> num = n <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> num = n - c_2 <NEWLINE> <NL> <DEDENT> if matj . ceil ( num / 2 ) <= c_4 : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <DEDENT> elif c_2 == n : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> zero , one , two = 0 , 0 , 0 <NEWLINE> for i in a : <NEWLINE> <INDENT> if i % 4 == 0 : <NEWLINE> <INDENT> two += 1 <NEWLINE> <DEDENT> elif i % 2 == 0 : <NEWLINE> <INDENT> one += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> zero += 1 <NEWLINE> <DEDENT> <DEDENT> if one = N : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> print ( <STRING> if two + int ( two > 0 ) >= zero + int ( one > 0 ) else <STRING> ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <NL> N = int ( input ( ) ) <NEWLINE> alist = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> oddcount = 0 <NEWLINE> mod40 = 0 <NEWLINE> other = 0 <NEWLINE> <NL> for a in alist : <NEWLINE> <INDENT> if a % 2 == 1 : <NEWLINE> <INDENT> oddcount += 1 <NEWLINE> <DEDENT> elif a % 4 == 0 : <NEWLINE> <INDENT> mod40 += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> other += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if N == 1 : <NEWLINE> <INDENT> if mod40 == N : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> if N == 2 or N == 3 : <NEWLINE> <INDENT> if mod40 > 0 or other == N : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> if ( N - ( ( other // 2 ) * 2 ) ) // 2 <= mod40 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> else : <NEWLINE> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT>
h , w , n , * A = map ( int , open ( x : = 0 ) . read ( ) . split ( ) ) ; c = [ ] <NEWLINE> for i in range ( n ) : c += [ i + 1 ] * A [ i ] <NEWLINE> for i in range ( h ) : print ( * ( c [ i * w : - ~ i * w ] ) [ : : x ] ) ; x ^= 1 <NEWLINE>
n = input ( ) . split ( ) <NEWLINE> print ( <STRING> + n ) <NEWLINE>
print ( ABC + input ( ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> print ( <STRING> + int ( n ) ) <NEWLINE>
<INDENT> if 2 ** i <= n : <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> for i in range ( 8 ) : <NEWLINE> <INDENT> if 2 ** i > n : <NEWLINE> <INDENT> print ( 2 ** ( i - 1 ) ) <NEWLINE> return <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if i = 2 ** a and 2 ** a < n and n < 2 ** ( a + 1 ) : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> <NL> ans = [ ] <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> x = i <NEWLINE> for j in range ( 100 ) : <NEWLINE> <INDENT> if x % 2 == 0 : <NEWLINE> <INDENT> x = int ( x // 2 ) <NEWLINE> <COMMENT> <NL> <DEDENT> else : <NEWLINE> <COMMENT> <NL> <INDENT> break <NEWLINE> <COMMENT> <NL> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans . index ( max ( ans ) ) + 1 ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> print ( max ( i if 2 ** i <= N else 0 for i in range ( 10 ) ) <NEWLINE>
def resolve ( N ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> N = int ( input ( ) ) <NEWLINE> res = 0 <NEWLINE> <NL> def div2 ( num ) : <NEWLINE> <INDENT> if num == 1 : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> while True : <NEWLINE> <INDENT> if num % 2 == 0 : <NEWLINE> <INDENT> num //= 2 <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return cnt <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> res_max_cnt = 0 <NEWLINE> res = 1 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> tepm_cnt = div2 ( i + 1 ) <NEWLINE> if res_max_cnt < tepm_cnt : <NEWLINE> <INDENT> res_max_cnt = tepm_cnt <NEWLINE> res = i + 1 <NEWLINE> <DEDENT> <DEDENT> print ( res ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> resolve ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> b = m . bit_length ( ) - 1 <NEWLINE> ans = int ( <STRING> + <STRING> * m , 2 ) <NEWLINE> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = [ ] <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> while True : <NEWLINE> <INDENT> if i % 2 != 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> i = i // 2 <NEWLINE> c += 1 <NEWLINE> <DEDENT> a . append ( c ) <NEWLINE> <DEDENT> print ( a . index ( max ( a ) ) + 1 ) <NEWLINE>
n = int ( intput ( ) ) <NEWLINE> res = [ ] <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> while i % 2 == 0 : <NEWLINE> <INDENT> i /= 2 <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> res . append ( cnt ) <NEWLINE> <DEDENT> print ( res . index ( max ( res ) ) + 1 ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> <NL> while a * 2 <= N : <NEWLINE> <INDENT> a = a * 2 <NEWLINE> <NL> <DEDENT> print ( a ) <NEWLINE>
for i in range ( 7 ) : <NEWLINE> <INDENT> if 2 ** i > n : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( 2 ** ( i - 1 ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> cnt = 0 <NEWLINE> while True : <NEWLINE> <INDENT> odd_flag = False <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if A [ i ] % 2 == 1 : <NEWLINE> <INDENT> odd_flag = True <NEWLINE> <DEDENT> <DEDENT> if odd_flag : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> A [ i ] = A [ i ] // 2 <NEWLINE> <DEDENT> cnt += 1 <NEWLINE> <NL> <DEDENT> print ( cnt ) <NEWLINE>
import typing <NEWLINE> from typing import Deque , Set , Dict <NEWLINE> <NL> class Island : <NEWLINE> <INDENT> def __init__ ( self , id : int ) -> None : <NEWLINE> <INDENT> self . id : int = id <NEWLINE> self . connection : List [ <STRING> ] = [ ] <NEWLINE> self . rank : int = 0 <NEWLINE> <NL> <DEDENT> def addConnection ( self , other : <STRING> ) -> None : <NEWLINE> <INDENT> self . connection . append ( other ) <NEWLINE> other . connection . append ( self ) <NEWLINE> <NL> <DEDENT> def setParent ( self , other : <STRING> ) -> None : <NEWLINE> <INDENT> self . rank = other . rank + 1 <NEWLINE> <NL> <DEDENT> <DEDENT> class Islands ( Dict [ int , Island ] ) : <NEWLINE> <INDENT> def __init__ ( self , num : int ) : <NEWLINE> <INDENT> for id in range ( 1 , num + 1 ) : <NEWLINE> <INDENT> self [ id ] = Island ( id ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> def bfs ( root : Island , max_depth : int ) -> None : <NEWLINE> <INDENT> root . setAsRoot ( ) <NEWLINE> reserved : Deque [ Island ] = Deque ( [ root ] ) <NEWLINE> seen : Set [ int ] = { root . id } <NEWLINE> while len ( reserved ) != 0 : <NEWLINE> <INDENT> current : Island = reserved . popleft ( ) <NEWLINE> if current . rank > max_depth : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for connected in current . connection : <NEWLINE> <INDENT> if connected . id in seen : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> connected . setParent ( current ) <NEWLINE> seen . add ( connected . id ) <NEWLINE> reserved . append ( connected ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> def main ( ) -> None : <NEWLINE> <INDENT> with open ( 0 ) as f : <NEWLINE> <INDENT> N , M = map ( int , f . readline ( ) . split ( ) ) <NEWLINE> ab = [ map ( int , line . split ( ) ) for line in f . readlines ( ) ] <NEWLINE> <COMMENT> <NL> <DEDENT> islands : Islands = Islands ( N ) <NEWLINE> <COMMENT> <NL> for a , b in ab : <NEWLINE> <INDENT> islands [ a ] . addConnection ( islands [ b ] ) <NEWLINE> <COMMENT> <NL> <DEDENT> bfs ( islands [ 1 ] , 2 ) <NEWLINE> <COMMENT> <NL> print ( <STRING> if islands [ N ] . rank in ( 1 , 2 ) else <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N , M = map ( int , input ( ) ) <NEWLINE> From = set ( ) <NEWLINE> To = set ( ) <NEWLINE> for _ in range ( M ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) ) <NEWLINE> if a == 1 : <NEWLINE> <INDENT> From . add ( b ) <NEWLINE> <DEDENT> if b == N : <NEWLINE> <INDENT> To . add ( a ) <NEWLINE> <DEDENT> <DEDENT> if From . isdisjoint ( To ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> fromOne = set ( ) <NEWLINE> toM = set ( ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if a == 1 : <NEWLINE> <INDENT> fromOne . add ( b ) <NEWLINE> <DEDENT> elif b == M : <NEWLINE> <INDENT> toM . add ( a ) <NEWLINE> <DEDENT> <DEDENT> return <STRING> if fromOne & toM else <STRING> <NEWLINE> <DEDENT> print ( main ( ) ) <NEWLINE>
a_list = [ ] <NEWLINE> b_list = [ ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> if X [ i ] [ 0 ] == 1 : <NEWLINE> <INDENT> a_list . append ( X [ i ] [ 1 ] ) <NEWLINE> <DEDENT> elif X [ i ] [ 1 ] == 1 : <NEWLINE> <INDENT> a_list . append ( X [ i ] [ 0 ] ) <NEWLINE> <DEDENT> elif X [ i ] [ 0 ] == n : <NEWLINE> <INDENT> b_list . append ( X [ i ] [ 1 ] ) <NEWLINE> <DEDENT> elif X [ i ] [ 1 ] == n : <NEWLINE> <INDENT> b_list . append ( X [ i ] [ 0 ] ) <NEWLINE> <DEDENT> <DEDENT> c_set = set ( a_list ) & set ( b_list ) <NEWLINE> if len ( c_set ) == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> c = [ [ ] for _ in range ( m + 1 ) ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> c [ a ] . append ( b ) <NEWLINE> c [ b ] . append ( a ) <NEWLINE> <NL> <DEDENT> for i in c [ 1 ] : <NEWLINE> <INDENT> if n in c [ i ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
N , * A = [ int ( _ ) for _ in open ( 0 ) . read ( ) . split ( ) ] <NEWLINE> sumB = max ( 0 , sum ( A ) - N * ( N - 1 ) ) <NEWLINE> while True : <NEWLINE> <INDENT> B = [ 0 - ( - ( a + x + 1 - N ) ) // ( N + 1 ) for a in A ] <NEWLINE> if sumB == sum ( B ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> sumB += 1 <NEWLINE> <DEDENT> print ( sumB ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> import sys <NEWLINE> <NL> def input ( ) : return sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> <NL> def gcd ( x , y ) : <NEWLINE> r = x % y <NEWLINE> if r == 0 : <NEWLINE> <INDENT> return y <NEWLINE> <DEDENT> return gcd ( y , r ) <NEWLINE> <NL> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a . sort ( reverse = True ) <NEWLINE> c = a [ 0 ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> c = gcd ( a [ i ] , c ) <NEWLINE> <DEDENT> if k % c == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a . sort ( ) <NEWLINE> a . reverse ( ) <NEWLINE> x = a [ 0 ] <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> while a [ i ] != 0 : <NEWLINE> <INDENT> x , a [ i ] = a [ i ] , x % a [ i ] <NEWLINE> <DEDENT> <DEDENT> if K > a [ 0 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> if K % x == 0 else <STRING> ) <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( n ) ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a [ i ] . reverse ( ) <NEWLINE> <NL> <DEDENT> ans = n <NEWLINE> used = set ( ) <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> count = [ 0 ] * ( m + 1 ) <NEWLINE> for j in range ( n ) : <NEWLINE> <INDENT> count [ a [ j ] [ - 1 ] ] += 1 <NEWLINE> <NL> <DEDENT> ans = min ( max ( count ) , ans ) <NEWLINE> num = count . index ( max ( count ) ) <NEWLINE> used . add ( num ) <NEWLINE> for j in range ( n ) : <NEWLINE> <INDENT> while True : <NEWLINE> <INDENT> if a [ j ] [ - 1 ] in used : <NEWLINE> <INDENT> a [ j ] . pop ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
a , b = int ( input ( ) . split ( ) ) <NEWLINE> <NL> if ( a + b ) % 3 == 0 : <NEWLINE> <INDENT> print ( Possible ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( Impossible ) <NEWLINE> <DEDENT>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if ( a % 3 == 0 ) | | ( b % 3 == 0 ) | | ( ( a + b ) % 3 == 0 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( <STRING> if a % 3 == 0 or b % 3 == 0 or ( a + b ) % == 0 else <STRING> ) <NEWLINE>
a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = sum ( a ) <NEWLINE> <NL> if ( b % 3 or a [ 0 ] % 3 or a [ 1 ] ) != 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if a % 3 == 0 or b % 3 == 0 : or ( a + b ) % 3 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> if A % 3 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif B % 3 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif ( A + B ) % 3 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
print ( <STRING> [ notA % 3 == 0 orB % 3 == 0 or ( A + B ) % 3 == 0 : : 2 ] ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> for i in ( a , b , a + b ) : <NEWLINE> <INDENT> i % 3 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
<NL> <COMMENT> <NL> <COMMENT> <NL> a = int ( input ( ) ) <NEWLINE> b = int ( input ( ) ) <NEWLINE> <NL> <COMMENT> <NL> if a / 3 >= 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif b / 3 >= 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif ( a + b ) / 3 >= 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 10 ** 100 <NEWLINE> x = sum ( a ) <NEWLINE> b = 0 <NEWLINE> for i in a [ : - 1 ] : <NEWLINE> <INDENT> b += i <NEWLINE> x -= i <NEWLINE> ans = min ( ans , abs ( x - b ) ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
li = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> li . append ( a + b ) <NEWLINE> for i in range ( 3 ) : <NEWLINE> <INDENT> if li [ i ] % 3 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
import sys <NEWLINE> import math <NEWLINE> import itertools <NEWLINE> import collections <NEWLINE> import heapq <NEWLINE> import re <NEWLINE> import numpy as np <NEWLINE> <NL> rr = lambda : sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> rs = lambda : sys . stdin . readline ( ) . split ( ) <NEWLINE> ri = lambda : int ( sys . stdin . readline ( ) ) <NEWLINE> rm = lambda : map ( int , sys . stdin . readline ( ) . split ( ) ) <NEWLINE> rl = lambda : list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) <NEWLINE> inf = float ( <STRING> ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> a , b , c = rm ( ) <NEWLINE> if a % 3 == 0 or b % 3 == 0 or ( a + b ) % 3 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <DEDENT>
A , B = map ( int . input ( ) . split ( ) ) <NEWLINE> if A % 3 == 0 or B % 3 == 0 or ( A + B ) % 3 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> x = a + b <NEWLINE> if x % 3 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else ( <STRING> ) <NEWLINE>
a , b = ( int ( x ) for x in input ( ) . split ( ) ) <NEWLINE> c = ( a + b ) % 3 <NEWLINE> if ( str ( a ) % <STRING> == <STRING> or str ( b ) % <STRING> == <STRING> or ( c ) == <STRING> ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b = map ( int ( input ( ) ) . split ( ) ) <NEWLINE> print ( [ <STRING> , <STRING> ] [ a % 3 == b % 3 and ( a % 3 == 1 or a % 3 == 2 ) ] <NEWLINE>
A , B = int ( input ( ) ) <NEWLINE> if A % 3 * B % 3 * ( A + B ) % 3 == 0 : print ( <STRING> ) <NEWLINE> else : print ( <STRING> ) <NEWLINE>
a , b = input ( ) . split ( ) <NEWLINE> a = int ( a ) <NEWLINE> b = int ( b ) <NEWLINE> if ( ( a + b ) % 3 ) == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if ( a % 3 ) == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if ( b % 3 ) == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT>
N , K = map ( int , input ( ) ) <NEWLINE> L = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> L . sort ( reverse = True ) <NEWLINE> print ( sum ( L [ : K ] ) ) <NEWLINE>
n , k = int ( input ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> l . sort ( reverse = True ) <NEWLINE> length = 0 <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> length += l [ i ] <NEWLINE> <DEDENT> print ( length ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> K = int ( input ( ) ) <NEWLINE> ls = sorted ( [ int ( i ) for i in input ( ) . split ( <STRING> ) ] , reverse = True ) <NEWLINE> <NL> l_sum = 0 <NEWLINE> for k in range ( K ) : <NEWLINE> <INDENT> l = ls [ k ] <NEWLINE> l_sum += l <NEWLINE> <NL> <DEDENT> print ( l_sum ) <NEWLINE>
int main ( ) { <NEWLINE> <INDENT> int N ; <NEWLINE> int K ; <NEWLINE> int a [ 55 ] ; <NEWLINE> cin >> N >> K ; <NEWLINE> <NL> for ( int i = 0 ; i < N ; + + i ) { <NEWLINE> <INDENT> cin >> a [ i ] ; <NEWLINE> <DEDENT> } <NEWLINE> sort ( a , a + N , greater < int > ( ) ) ; <NEWLINE> int ans = 0 ; <NEWLINE> for ( int i = 0 ; i <= K ; + + i ) { <NEWLINE> <INDENT> ans += a [ i ] ; <NEWLINE> <DEDENT> } <NEWLINE> cout << ans << endl ; <NEWLINE> <DEDENT> } <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> s = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> s . sort ( ) <NEWLINE> print ( sum ( s [ len ( n ) - k : ] ) ) <NEWLINE>
15 14 <NEWLINE> 50 26 27 21 41 7 42 35 7 5 5 36 39 1 45 <NEWLINE>
def solve ( ) : <NEWLINE> <INDENT> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> L = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> L . sort ( reversed = True ) <NEWLINE> print ( sum ( L [ : K ] ) ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> solve ( ) <NEWLINE> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> l . sort ( reverse = True ) <NEWLINE> print ( sum [ : K ] ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> x = <NEWLINE>
l , k = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( sum ( sorted ( map ( int , input ( ) . split ( ) ) [ : k ] ) ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> l . sort ( reversed = True ) <NEWLINE> print ( sum ( l [ : k ] ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = [ 0 ] + list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> A [ i ] = A [ i ] + A [ i - 1 ] <NEWLINE> <DEDENT> ans = float ( <STRING> ) <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> ans = min ( ans , ans ( A [ N ] - 2 * A [ i ] ) ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> a = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> sum_a = sum ( a ) <NEWLINE> b = [ ] <NEWLINE> c = 0 <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> c += a [ i ] <NEWLINE> b . append ( abs ( 2 * b - sum_a ) ) <NEWLINE> <DEDENT> print ( min ( b ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> b = list ( accumulate ( a ) ) <NEWLINE> ma = b [ - 1 ] <NEWLINE> mi = 10 ** 10 <NEWLINE> for sunuke in b : <NEWLINE> <INDENT> arai = ma - sunuke <NEWLINE> if abs ( sunuke - arai ) < mi : <NEWLINE> <INDENT> mi = abs ( sunuke - arai ) <NEWLINE> <DEDENT> <DEDENT> print ( mi ) <NEWLINE>
import sys <NEWLINE> import re <NEWLINE> from collections import deque , defaultdict , Counter <NEWLINE> from math import ceil , sqrt , hypot , factorial , pi , sin , cos , radians <NEWLINE> from itertools import accumulate , permutations , combinations , product <NEWLINE> from operator import itemgetter , mul <NEWLINE> from copy import deepcopy <NEWLINE> from string import ascii_lowercase , ascii_uppercase , digits <NEWLINE> from bisect import bisect , bisect_left <NEWLINE> from fractions import gcd <NEWLINE> from heapq import heappush , heappop <NEWLINE> from functools import reduce <NEWLINE> def input ( ) : return sys . stdin . readline ( ) . strip ( ) <NEWLINE> def INT ( ) : return int ( input ( ) ) <NEWLINE> def MAP ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def LIST ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> INF = float ( <STRING> ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> N = INT ( ) <NEWLINE> A = LIST ( ) <NEWLINE> <NL> ans = INF <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> x = sum ( A [ : i + 1 ] ) <NEWLINE> y = sum ( A [ i + 1 : ] ) <NEWLINE> <NL> tmp = abs ( x - y ) <NEWLINE> if tmp < ans : <NEWLINE> <INDENT> ans = tmp <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> total = sum ( a ) <NEWLINE> s = 0 <NEWLINE> i = 0 <NEWLINE> ans = total + 1 <NEWLINE> while True : <NEWLINE> <INDENT> s += a [ i ] <NEWLINE> total -= a [ i ] <NEWLINE> ans = min ( ans , abs ( s - total ) ) <NEWLINE> i += 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
from collections import deque , defaultdict <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> edges = [ tuple ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n - 1 ) ] <NEWLINE> d = defaultdict ( list ) <NEWLINE> for e in edges : <NEWLINE> <INDENT> d [ e [ 0 ] ] . append ( e [ 1 ] ) <NEWLINE> d [ e [ 1 ] ] . append ( e [ 0 ] ) <NEWLINE> <DEDENT> def dist ( m ) : <NEWLINE> <INDENT> dl = [ - 1 ] * ( n + 1 ) <NEWLINE> cv = deque ( [ m ] ) <NEWLINE> nv = deque ( [ 1 ] ) <NEWLINE> while nv : <NEWLINE> <INDENT> c += 1 <NEWLINE> cv . extend ( nv ) <NEWLINE> nv . clear ( ) <NEWLINE> for e in cv : <NEWLINE> <INDENT> dl [ e ] = c <NEWLINE> for x in d [ e ] : <NEWLINE> <INDENT> if dl [ x ] < 0 : <NEWLINE> <INDENT> nv . append ( x ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> cv . clear ( ) <NEWLINE> <DEDENT> return dl [ 1 : ] <NEWLINE> <DEDENT> fnc = dist ( 1 ) <NEWLINE> snk = dist ( n ) <NEWLINE> j = sum ( [ ( fnc [ i ] <= snk [ i ] ) - ( fnc [ i ] > snk [ i ] ) for i in range ( n ) ] ) <NEWLINE> if j > 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import collections <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> tree = [ [ ] for _ in range ( N ) ] <COMMENT> <NEWLINE> for _ in range ( N - 1 ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> tree [ a - 1 ] . append ( b - 1 ) <NEWLINE> tree [ b - 1 ] . append ( a - 1 ) <NEWLINE> <NL> <DEDENT> color = [ 0 ] * N <COMMENT> <NEWLINE> color [ 0 ] = 1 <NEWLINE> color [ N - 1 ] = - 1 <NEWLINE> que = collections . depue ( ) <COMMENT> <NEWLINE> que . append ( 0 ) <NEWLINE> que . append ( N - 1 ) <NEWLINE> while que : <COMMENT> <NEWLINE> <INDENT> i = que . popleft ( ) <COMMENT> <NEWLINE> for x in tree [ i ] : <NEWLINE> <INDENT> if color [ x ] == 0 : <NEWLINE> <INDENT> color [ x ] = color [ i ] <NEWLINE> que . append ( x ) <COMMENT> <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if sum ( color ) > 0 : <COMMENT> <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <COMMENT> <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
from collections import deque <NEWLINE> def f ( x , q ) : <NEWLINE> <INDENT> for i in route [ x ] : <NEWLINE> <INDENT> if not visit [ i ] : <NEWLINE> <INDENT> visit [ i ] = True <NEWLINE> f ( i , q + [ i ] ) <NEWLINE> visit [ i ] = False <NEWLINE> if i == n - 1 : <NEWLINE> <INDENT> p = q + [ i - 1 ] <NEWLINE> flag = True <NEWLINE> return p <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> n = int ( input ( ) ) <NEWLINE> route = [ [ ] for i in range ( n ) ] <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> a , b = map ( lambda x : int ( x ) - 1 , input ( ) . split ( ) ) <NEWLINE> route [ a ] . append ( b ) <NEWLINE> route [ b ] . append ( a ) <NEWLINE> <DEDENT> visit = [ False for i in range ( n ) ] <NEWLINE> p = f ( 0 , [ 0 ] ) <NEWLINE> t = p [ - ( - len ( p ) // 2 ) - 1 ] <NEWLINE> <NL> d = deque ( ) <NEWLINE> d . append ( n - 1 ) <NEWLINE> visit = [ False for i in range ( n ) ] <NEWLINE> siro = 1 <NEWLINE> while d : <NEWLINE> <INDENT> now = d . popleft ( ) <NEWLINE> for i in route [ now ] : <NEWLINE> <INDENT> if not visit [ i ] and i != t : <NEWLINE> <INDENT> visit [ i ] = True <NEWLINE> d . append ( i ) <NEWLINE> siro += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> kuro = n - siro <NEWLINE> if kuro <= siro : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif kuro > siro : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
from networkx import * <NEWLINE> N , * t = map ( str . split , open ( 0 ) ) <NEWLINE> s = shortest_path_length <NEWLINE> x = s ( G : = Graph ( t ) , <STRING> ) <NEWLINE> y = s ( G , N ) <NEWLINE> print ( <STRING> [ sum ( x [ k ] > y [ k ] for k in x ) * 2 >= int ( * N ) : : 2 ] ) <NEWLINE>
import sys <NEWLINE> n = int ( input ( ) ) <NEWLINE> sys . setrecursionlimit ( n ) <NEWLINE> T = [ [ ] for _ in <STRING> * ( n + 1 ) ] <NEWLINE> for _ in range ( n - 1 ) : a , b = map ( int , input ( ) . split ( ) ) ; T [ a ] += b , ; T [ b ] += a , <NEWLINE> def d ( v , p ) : <NEWLINE> <INDENT> r = 0 <NEWLINE> for s in T [ v ] : <NEWLINE> <INDENT> if s != p : r ^= d ( s , v ) + 1 <NEWLINE> <DEDENT> return r <NEWLINE> <DEDENT> print ( <STRING> [ d ( 1 , 1 ) < 1 : : 2 ] ) <NEWLINE>
a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a . sort ( ) <NEWLINE> print ( a [ 0 ] + [ 1 ] ) <NEWLINE>
a , b , c = sroted ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> print ( a + b ) <NEWLINE>
p = sorted ( [ map ( int , input ( ) . split ( ) ) ] ) <NEWLINE> print ( p [ 0 ] + p [ 1 ] ) <NEWLINE> <NL>
lst = input ( ) . split ( ) <NEWLINE> <NL> for i in range ( 3 ) : <NEWLINE> <INDENT> lst [ i ] = int ( lst [ i ] ) <NEWLINE> lst . sort ( ) <NEWLINE> <NL> <DEDENT> print ( lst [ 0 ] + lst [ 1 ] ) <NEWLINE>
a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( total ( a , b , c ) - max ( a , b , c ) ) <NEWLINE>
a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> def answer ( a : int , b : int , c : int ) -> int : <NEWLINE> <INDENT> return min ( a + b , a + c , b + c ) <NEWLINE> <NL> <DEDENT> print ( answer ( a , b , c ) <NEWLINE>
a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( sum ( [ a , b , c ] - max ( a , b , c ) ) ) <NEWLINE>
ary = list ( map ( lambda n : int ( n ) , input ( ) . split ( <STRING> ) ) ) . sort ( ) <NEWLINE> print ( ary [ 0 ] + ary [ 1 ] ) <NEWLINE>
a , b , c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( max ( a * b , a * c , c * b ) ) <NEWLINE>
a , b , c = map ( int , input ( ) . pslit ( <STRING> ) ) <NEWLINE> print ( a + b + c - max ( a , max ( b , c ) ) ) <NEWLINE>
a , b , c = sorted ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> print ( a + b0 <NEWLINE>
a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> min = min { a + b , b + c , c + a } <NEWLINE> print ( min ) <NEWLINE>
print ( sum ( sorted ( list ( map ( int , intput ( ) . split ( ) ) ) ) [ 0 : 2 ] ) ) <NEWLINE>
s = input ( ) <NEWLINE> for i in range ( 1 , len ( s ) // 2 ) : <NEWLINE> <INDENT> if s [ : ( n - 2 * i ) // 2 ] == s [ ( n - 2 * i ) // 2 : n - 2 * i ] : <NEWLINE> <INDENT> print ( n - 2 * i ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT>
n = input ( ) <NEWLINE> num = len ( n ) - 2 <NEWLINE> for i in range ( num , 0 , - 2 ) : <NEWLINE> <INDENT> f = int ( i / 2 ) <NEWLINE> if s [ : f ] == s [ f : i ] : <NEWLINE> <INDENT> print ( i ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT>
s = str ( input ( ) ) <NEWLINE> sl = list ( s ) <NEWLINE> ans = 0 <NEWLINE> del s [ - 1 ] <NEWLINE> for i in range ( 1 , len ( s ) ) : <NEWLINE> <INDENT> if ( len ( s ) % 2 == 0 ) : <NEWLINE> <INDENT> if ( s [ : len ( s2 // 2 ) ] == s [ len ( s ) // 2 : ] ) : <NEWLINE> <INDENT> ans = len ( s ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = input ( ) [ : - 1 ] <NEWLINE> while n [ : len ( n ) // 2 ] != [ len ( n ) // 2 : ] : <NEWLINE> <INDENT> n = n [ : - 1 ] <NEWLINE> <DEDENT> print ( len ( n ) ) <NEWLINE>
s = str ( input ( ) ) <NEWLINE> flag = 0 <NEWLINE> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> s = s [ : len ( s ) - 2 * i ] <NEWLINE> for j in range ( len ( s ) // 2 ) : <NEWLINE> <INDENT> if s [ j ] != s [ len ( s ) - j ] : <NEWLINE> <INDENT> flag = 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if flag == 0 : <NEWLINE> <INDENT> print ( len ( s ) ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> flag = 0 <NEWLINE> continue <NEWLINE> <DEDENT> <DEDENT>
S = input ( ) [ : - 2 ] <NEWLINE> while len ( S ) >= 0 : <NEWLINE> <INDENT> if S [ : len ( S ) // 2 ] == S [ len ( S ) // 2 : ] : <NEWLINE> <INDENT> print ( len ( S ) ) <NEWLINE> <DEDENT> S = S [ : - 2 ] <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> n = len ( s ) // 2 <NEWLINE> <NL> for x in range ( 1 , n ) : <NEWLINE> <INDENT> if s [ : n - i ] == s [ n - i : 2 * n - 2 * i ] : <NEWLINE> <INDENT> print ( 2 * n - 2 * i ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT>
s = input ( ) <NEWLINE> for i in range ( int ( len ( s ) + 1 ) / 2 ) : <NEWLINE> <INDENT> if s [ i ] != s [ int ( len ( s ) + 1 ) / 2 ] : <NEWLINE> <INDENT> del [ len ( s ) - 1 ] <NEWLINE> <DEDENT> <DEDENT> print ( len ( s ) + 1 ) <NEWLINE>
s = list ( input ( ) ) <NEWLINE> from copy import copy <NEWLINE> t = s . copy ( ) <NEWLINE> <NL> for i in range ( len ( t ) ) : <NEWLINE> <INDENT> if len ( s ) % 2 == 0 and s [ : len ( s ) / 2 ] == s [ len ( s ) / 2 : ] : <NEWLINE> <INDENT> print ( len ( s ) ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s . pop ( - 1 ) <NEWLINE> <DEDENT> <DEDENT>
from collections import deque <NEWLINE> from typing import List <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> v = input ( ) . split ( <STRING> ) <NEWLINE> print ( pp ( n , v ) ) <NEWLINE> <NL> <NL> <DEDENT> def pp ( n : int , v : List [ str ] ) -> List [ str ] : <NEWLINE> <INDENT> x = [ ] <NEWLINE> y = deque ( [ ] ) <NEWLINE> <NL> if n % 2 == 0 : <NEWLINE> <INDENT> for i in range ( n ) : <NEWLINE> <INDENT> if i % 2 == 0 : <NEWLINE> <INDENT> y . append ( v [ i ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x . append ( v [ i ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( n ) : <NEWLINE> <INDENT> if i % 2 == 0 : <NEWLINE> <INDENT> x . append ( v [ i ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> y . append ( v [ i ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> ret = [ ] <NEWLINE> for i in range ( len ( x ) ) : <NEWLINE> <INDENT> ret . append ( x . pop ( ) ) <NEWLINE> <NL> <DEDENT> for i in range ( len ( y ) ) : <NEWLINE> <INDENT> ret . append ( y . popleft ( ) ) <NEWLINE> <NL> <DEDENT> return ret <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> b . append ( 0 ) <NEWLINE> <DEDENT> k = 0 <NEWLINE> if ( n % 2 == 1 ) : <NEWLINE> <INDENT> k = ( n - 1 ) // 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> k = n // 2 <NEWLINE> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> if ( i % 2 == 0 ) : <NEWLINE> <INDENT> print ( a [ i ] ) <NEWLINE> print ( k + i // 2 ) <NEWLINE> b [ k + i // 2 ] = a [ i ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( a [ i ] ) <NEWLINE> b [ k - ( i + 1 ) // 2 ] = a [ i ] <NEWLINE> <DEDENT> <DEDENT> print ( b ) <NEWLINE> <NL> <NL> <NL>
n = int ( input ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = [ l [ 0 ] ] <NEWLINE> if n % 2 == 1 : <NEWLINE> <INDENT> for i in range ( 1 , n ) : <NEWLINE> <INDENT> if i % 2 == 1 : <NEWLINE> <INDENT> a . insert ( 0 , l [ i ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a . append ( l [ i ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( 1 , n ) : <NEWLINE> <INDENT> if i % 2 == 1 : <NEWLINE> <INDENT> a . appen ( l [ i ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a . insert ( 0 , l [ i ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( a ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = [ ] <NEWLINE> for i in a : <NEWLINE> <INDENT> b . append ( i ) <NEWLINE> b . reverse ( ) <NEWLINE> <DEDENT> print ( <STRING> . join ( b ) ) <NEWLINE>
4 3 6 <NEWLINE>
x , a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if b - a < 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif b - a = 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
x , a , b = map ( str , input ( ) . split ( ) ) <NEWLINE> if a > b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif x >= b - a : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
x , a , b = ( int ( x ) for x in input ( ) . split ( ) ) <NEWLINE> if a < b : <NEWLINE> <INDENT> if b - a > c : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
x , a , b = map ( int , input ( ) ) <NEWLINE> n = a - b <NEWLINE> if n >= 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif x + n >= 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
if b - a <= 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif b - a <= x : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import re <NEWLINE> import sys <NEWLINE> import math <NEWLINE> import itertools <NEWLINE> import bisect <NEWLINE> from copy import copy <NEWLINE> from collections import deque , Counter <NEWLINE> from decimal import Decimal <NEWLINE> import functools <NEWLINE> def v ( ) : return input ( ) <NEWLINE> def k ( ) : return int ( input ( ) ) <NEWLINE> def S ( ) : return input ( ) . split ( ) <NEWLINE> def I ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def X ( ) : return list ( input ( ) ) <NEWLINE> def L ( ) : return list ( input ( ) . split ( ) ) <NEWLINE> def l ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> def lcm ( a , b ) : return a * b // math . gcd ( a , b ) <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> cnt = 0 <NEWLINE> ans = 0 <NEWLINE> inf = float ( <STRING> ) <NEWLINE> al = <STRING> <NEWLINE> AL = al . upper ( ) <NEWLINE> <NL> a , b , c = I ( ) <NEWLINE> ans = min ( a + b , b + c ) <NEWLINE> print ( min ( ans , a + c ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = [ ] <NEWLINE> t = [ ] <NEWLINE> t . append ( 1 ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a . append ( input ( ) ) <NEWLINE> <NL> <DEDENT> x = a [ 0 ] <NEWLINE> while True : <NEWLINE> <INDENT> if x == 2 : <NEWLINE> <INDENT> print ( len ( t ) ) <NEWLINE> break <NEWLINE> <DEDENT> elif x in t : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> t . append ( x ) <NEWLINE> y = x <NEWLINE> x = a [ y - 1 ] <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> N = int ( input ( ) ) <NEWLINE> A = [ int ( input ( ) ) for _ in range ( N ) ] <NEWLINE> next = A [ 0 ] <NEWLINE> ans = - 1 <NEWLINE> cnt = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> next = A [ next ] <NEWLINE> cnt += 1 <NEWLINE> if next == 2 : <NEWLINE> <INDENT> ans = cnt <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> l = [ int ( input ( ) ) for i in range ( N ) ] <NEWLINE> index = 0 <NEWLINE> count = 0 <NEWLINE> for j in range ( N ) : <NEWLINE> <INDENT> index = l [ index ] <NEWLINE> count += 1 <NEWLINE> if index == 2 : <NEWLINE> <INDENT> print ( count ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( - 1 ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = [ input ( ) for i in range ( n ) ] <NEWLINE> bu = 0 <NEWLINE> end = - 1 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if bu == 1 : <NEWLINE> <INDENT> end = i - 1 <NEWLINE> break <NEWLINE> bu = a [ bu ] - 1 <NEWLINE> <DEDENT> <DEDENT> print ( end ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> a = [ int ( input ( ) ) for i in range ( n ) ] <NEWLINE> <NL> <COMMENT> <NL> index = 1 <NEWLINE> <COMMENT> <NL> count = 0 <NEWLINE> <NL> while count < N : <NEWLINE> <NL> <INDENT> if a [ index - 1 ] == 2 : <NEWLINE> <INDENT> count += 1 <NEWLINE> print ( count ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> count += 1 <NEWLINE> <COMMENT> <NL> index = a [ index - 1 ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( - 1 ) <NEWLINE>
cnt = 1 <NEWLINE> l = a [ 0 ] <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> if l in a : <NEWLINE> <INDENT> l = a [ l - 1 ] <NEWLINE> cnt += 1 <NEWLINE> if l == 2 : <NEWLINE> <INDENT> print ( cnt ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = [ 0 * N ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> A [ i ] = int ( input ( ) ) - 1 <COMMENT> <NEWLINE> <DEDENT> index = 0 <NEWLINE> trials = - 1 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> index = A [ index ] <NEWLINE> if index == 1 : <NEWLINE> <INDENT> trials = i + 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( trials ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = [ 0 , int ( input ( ) ) for i in range ( n ) ] <NEWLINE> cnt = 1 <NEWLINE> next_a = a [ 1 ] <NEWLINE> while cnt <= 10 ** 5 : <NEWLINE> <INDENT> next_a = a [ next_a ] <NEWLINE> cnt += 1 <NEWLINE> if next_a == 2 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> if cnt < 10 ** 5 : <NEWLINE> <INDENT> print ( cnt ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = [ ] <NEWLINE> s = [ 1 ] <NEWLINE> t = 1 <NEWLINE> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a . append ( int ( input ( ) ) <NEWLINE> <DEDENT> while t != 2 : <NEWLINE> <INDENT> t = a [ t - 1 ] <NEWLINE> s . append ( t ) <NEWLINE> if s . count ( t ) == 2 : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <DEDENT> ans += 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> al = [ int ( input ( ) ) for _ in range ( n ) ] <NEWLINE> <NL> pos = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> pos = A [ pos ] - 1 <NEWLINE> if ( pos == 1 ) : <NEWLINE> <INDENT> print ( i + 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( - 1 ) <NEWLINE>
from math import factorial as f <NEWLINE> <NL> n , m = map ( int ( ) , input ( ) . split ( ) ) <NEWLINE> <NL> if n == m : <NEWLINE> <INDENT> print ( ( f ( n ) ** 2 * 2 ) % ( 10 ** 9 + 7 ) ) <NEWLINE> <DEDENT> elif abs ( n - m ) == 1 : <NEWLINE> <INDENT> print ( ( f ( n ) * f ( m ) ) % ( 10 ** 9 + 7 ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT>
ans = 1 <NEWLINE> if abs ( N - M ) >= 2 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> elif abs ( N - M ) == 1 : <NEWLINE> <INDENT> for i in range ( 1 , min ( N , M ) + 1 ) : <NEWLINE> <INDENT> ans *= i <NEWLINE> ans = ans % ( 10 ** 9 + 7 ) <NEWLINE> <DEDENT> ans = ans ** 2 * max ( N , M ) <NEWLINE> ans = ans % ( 10 ** 9 + 7 ) <NEWLINE> print ( ans ) <NEWLINE> <DEDENT> elif abs ( N - M ) == 0 : <NEWLINE> <INDENT> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> ans *= i <NEWLINE> ans = ans % ( 10 ** 9 + 7 ) <NEWLINE> <DEDENT> ans = ans ** 2 <NEWLINE> ans *= 2 <NEWLINE> ans = ans % ( 10 ** 9 + 7 ) <NEWLINE> print ( ans ) <NEWLINE> <DEDENT>
import sys <NEWLINE> import math <NEWLINE> import itertools <NEWLINE> import collections <NEWLINE> import heapq <NEWLINE> import re <NEWLINE> import numpy as np <NEWLINE> from functools import reduce <NEWLINE> <NL> rr = lambda : sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> rs = lambda : sys . stdin . readline ( ) . split ( ) <NEWLINE> ri = lambda : int ( sys . stdin . readline ( ) ) <NEWLINE> rm = lambda : map ( int , sys . stdin . readline ( ) . split ( ) ) <NEWLINE> rl = lambda : list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) <NEWLINE> inf = float ( <STRING> ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> n , m = rm ( ) <NEWLINE> if n == m : <NEWLINE> <INDENT> print ( ( math . factorial ( n ) * math . factorial ( m ) * 2 ) % mod ) <NEWLINE> <DEDENT> elif abs ( n - m ) == 1 : <NEWLINE> <INDENT> print ( ( math . factorial ( n ) * math . factorial ( m ) % mod ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <DEDENT>
<NL> def main ( ) : <NEWLINE> <INDENT> p = 10 ** 9 + 7 <NEWLINE> def modpfac ( n ) : <NEWLINE> <INDENT> ret = 1 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> ret *= i % p <NEWLINE> <DEDENT> return ret <NEWLINE> <DEDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> if abs ( m - n ) > 1 : <NEWLINE> <INDENT> return print ( 0 ) <NEWLINE> <DEDENT> elif abs ( m - n ) = 1 : <NEWLINE> <INDENT> return print ( modpfac ( n ) * modpfac ( m ) % p ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return print ( 2 * modpfac ( n ) * modpfac ( m ) % p ) <NEWLINE> <NL> <DEDENT> <DEDENT> main ( ) <NEWLINE> <NL>
from copy import deepcopy as copy <NEWLINE> from operator import itemgetter <NEWLINE> <NL> class UnionFind : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . n = n <NEWLINE> self . par = [ - 1 ] * ( n + 1 ) <COMMENT> <NEWLINE> <NL> <DEDENT> def find ( self , x ) : <NEWLINE> <INDENT> if self . par [ x ] < 0 : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . par [ x ] = self . find ( self . par [ x ] ) <NEWLINE> return self . par [ x ] <COMMENT> <NEWLINE> <NL> <DEDENT> <DEDENT> def union ( self , x , y ) : <NEWLINE> <INDENT> x = self . find ( x ) <NEWLINE> y = self . find ( y ) <NEWLINE> if x == y : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> if self . par [ x ] > self . par [ y ] : <NEWLINE> <INDENT> x , y = y , x <NEWLINE> <NL> <DEDENT> self . par [ x ] += self . par [ y ] <NEWLINE> self . par [ y ] = x <NEWLINE> <NL> <DEDENT> def same ( self , x , y ) : <NEWLINE> <INDENT> return self . find ( x ) == self . find ( y ) <COMMENT> <NEWLINE> <NL> <DEDENT> def size ( self , x ) : <NEWLINE> <INDENT> return - self . par [ self . find ( x ) ] <NEWLINE> <NL> <DEDENT> def members ( self , x ) : <NEWLINE> <INDENT> root = self . find ( x ) <NEWLINE> return [ i for i in range ( self . n ) if root == self . find ( i ) ] <NEWLINE> <NL> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> bridge = [ None ] * n <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> bridge [ i ] = [ int ( x ) for x in input ( ) . split ( ) ] + [ i ] <NEWLINE> <NL> <DEDENT> judge = [ ] <NEWLINE> <NL> bridge . sort ( ) <NEWLINE> heapq . heapify ( judge ) <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> judge . append ( ( bridge [ i + 1 ] [ 0 ] - bridge [ i ] [ 0 ] , bridge [ i ] [ 2 ] , bridge [ i + 1 ] [ 2 ] ) ) <NEWLINE> <NL> <DEDENT> bridge . sort ( key = itemgetter ( 1 ) ) <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> judge . append ( ( bridge [ i + 1 ] [ 1 ] - bridge [ i ] [ 1 ] , bridge [ i ] [ 2 ] , bridge [ i + 1 ] [ 2 ] ) ) <NEWLINE> <NL> <DEDENT> judge . sort ( ) <NEWLINE> union = UnionFind ( n ) <NEWLINE> count = 0 <NEWLINE> cost = 0 <NEWLINE> while True : <NEWLINE> <INDENT> c , i , j = heapq . heappop ( judge ) <NEWLINE> if union . same ( i , j ) : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> union . union ( i , j ) <NEWLINE> cost += c <NEWLINE> count += 1 <NEWLINE> if count == n - 1 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( cost ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> def C ( n , r , mod = 10 ** 9 + 7 ) : <NEWLINE> <INDENT> if n - r < r : r = n - r <NEWLINE> if r == 0 : return 1 <NEWLINE> if r == 1 : return n <NEWLINE> <NL> numerator = [ n - r + k + 1 for k in range ( r ) ] <NEWLINE> denominator = [ k + 1 for k in range ( r ) ] <NEWLINE> <NL> for p in range ( 2 , r + 1 ) : <NEWLINE> <INDENT> pivot = denominator [ p - 1 ] <NEWLINE> if pivot > 1 : <NEWLINE> <INDENT> offset = ( n - r ) % p <NEWLINE> for k in range ( p - 1 , r , p ) : <NEWLINE> <INDENT> numerator [ k - offset ] /= pivot <NEWLINE> denominator [ k ] /= pivot <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> result = 1 <NEWLINE> for k in range ( r ) : <NEWLINE> <INDENT> if numerator [ k ] > 1 : <NEWLINE> <INDENT> result *= int ( numerator [ k ] ) % mod <NEWLINE> <NL> <DEDENT> <DEDENT> return result % mod <NEWLINE> <DEDENT> print ( C ( a + 1 , b ) ) <NEWLINE>
a , b , c = map ( input ( ) . split ( ) ) <NEWLINE> int ( x ) = a + b + c <NEWLINE> if x % 4 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
r g b = map ( int , input ( ) . split ( ) ) <NEWLINE> x = r * 100 + g * 10 + b <NEWLINE> if x % 4 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
<COMMENT> <NL> r , g , b = map ( int , input ( ) . split ( ) ) <NEWLINE> <COMMENT> <NL> if ( 100 r + 10 g + b ) // 4 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
r , g , b = input ( ) . split ( ) <NEWLINE> if int ( t + g + b ) % 4 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
r , g , b = map ( int , input ( ) ) . split ( ) <NEWLINE> <NL> a = r * 100 + g * 10 + b <NEWLINE> if a % 4 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
r = int ( input ( ) ) <NEWLINE> g = int ( input ( ) ) <NEWLINE> b = int ( input ( ) ) <NEWLINE> <NL> <NL> s = 100 * r + 10 * b + g <NEWLINE> <NL> if s % 4 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
rgb = int ( <STRING> . join ( input ( ) ) ) <NEWLINE> if rgb % 4 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> r = input ( ) <NEWLINE> g = input ( ) <NEWLINE> b = input ( ) <NEWLINE> <NL> <NL> <COMMENT> <NL> number = int ( r + g + b ) <NEWLINE> if number % 4 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT>
r , g , b = map ( str , input ( ) . split ( ) ) <NEWLINE> list_C = [ r , g , b ] <NEWLINE> num = int ( <STRING> . join ( list_c ) ) <NEWLINE> if num % 4 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
r , g , b = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( <STRING> if ( 10 * g + b ) % 4 == 0 else <STRING> <NEWLINE>
a , b , c = input ( ) . split ( ) <NEWLINE> a = int ( a ) <NEWLINE> b = int ( b ) <NEWLINE> c = int ( c ) <NEWLINE> if ( ( 100 * a + 10 * b + c ) % 4 ) = 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a = int ( input ( ) . replace ( <STRING> , <STRING> ) ) <NEWLINE> if a % 4 == 0 : print ( <STRING> ) else : print ( <STRING> ) <NEWLINE>
r , g , b = input ( ) . split ( ) <NEWLINE> n = int ( <STRING> ) <NEWLINE> if n % 4 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
r , g , b = map ( int , input ( ) . split ( ) ) <NEWLINE> num = 10 * y + z <NEWLINE> if num % 4 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
<COMMENT> <NL> N = int ( input ( ) ) <NEWLINE> A = [ list ( map ( int , input ( ) . split ( ) ) ) ] <NEWLINE> print ( max ( A ) - min ( A ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = sorted ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A [ 0 ] = 0 <NEWLINE> d = 0 <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> d += A [ i ] - A [ i - 1 ] <NEWLINE> <DEDENT> print ( d ) <NEWLINE>
import sys <NEWLINE> import math <NEWLINE> import itertools <NEWLINE> import collections <NEWLINE> import heapq <NEWLINE> import re <NEWLINE> import numpy as np <NEWLINE> from functools import reduce <NEWLINE> <NL> rr = lambda : sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> rs = lambda : sys . stdin . readline ( ) . split ( ) <NEWLINE> ri = lambda : int ( sys . stdin . readline ( ) ) <NEWLINE> rm = lambda : map ( int , sys . stdin . readline ( ) . split ( ) ) <NEWLINE> rl = lambda : list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) <NEWLINE> inf = float ( <STRING> ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> n = ri ( ) <NEWLINE> li = rl ( ) <NEWLINE> print ( max ( li ) - min ( li ) <NEWLINE> <NL> <NL> <NL> <NL> <NL> <NL> <NL>
n = int ( input ( ) ) <NEWLINE> A = list ( input ( ) . split ( ) ) <NEWLINE> print ( max ( A ) - min ( A ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = [ int ( input ( ) ) for _ in range ( n ) ] <NEWLINE> print ( max ( a ) - min ( a ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> print ( max ( a ) - min ( b ) ) <NEWLINE>
a = input ( ) <NEWLINE> a = int ( a ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b . sort ( ) <NEWLINE> print ( b [ a ] - b [ 0 ] ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> a = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> print ( max ( a ) - min ( a ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a . sort ( ) <NEWLINE> print ( a [ n - 1 ] a [ 0 ] ) <NEWLINE>
def actual ( N , A ) : <NEWLINE> <INDENT> return max ( A ) - min ( A ) <NEWLINE> <NL> <DEDENT> N = int ( input ( ) ) <NEWLINE> A = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> print ( actual ( N , A ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <DEDENT> a . sort ( ) <NEWLINE> print ( a [ n - 1 ] - a [ 0 ] ) <NEWLINE>
_ , * aa = map ( int , open ( 1 ) . read ( ) . split ( ) ) <NEWLINE> <NL> print ( max ( aa ) - min ( aa ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = [ int ( input ( ) ) for i in range ( n ) ] <NEWLINE> print ( max ( a ) - min ( a ) ) <NEWLINE>
<NL> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> color = [ ] <NEWLINE> free = 0 <NEWLINE> count = 0 <NEWLINE> for i in a : <NEWLINE> <INDENT> if i // 400 < 8 and i // 400 not in color : <NEWLINE> <INDENT> color . append ( i // 400 ) <NEWLINE> Sans += 1 <NEWLINE> <DEDENT> elif i >= 3200 : <NEWLINE> <INDENT> free += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> Mans = Sans <NEWLINE> if free + count > 8 : <NEWLINE> <INDENT> Mans = 8 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> Mans = count + free <NEWLINE> <NL> <DEDENT> print ( Sans , Mans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> c = [ 0 ] * 9 <NEWLINE> for i in a : <NEWLINE> <INDENT> t = i // 400 <NEWLINE> if t < 8 : <NEWLINE> <INDENT> c [ t ] = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> c [ 8 ] += 1 <NEWLINE> <DEDENT> <DEDENT> cmin = max ( sum ( c [ : - 1 ] ) , min ( c [ 8 ] , 1 ) ) <NEWLINE> cmax = min ( sum ( c ) ) <NEWLINE> print ( cmin , cmax ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> hai = 0 <NEWLINE> tya = 0 <NEWLINE> mizu = 0 <NEWLINE> ao = 0 <NEWLINE> ki = 0 <NEWLINE> dai = 0 <NEWLINE> aka = 0 <NEWLINE> mu = 0 <NEWLINE> <NL> for a in A : <NEWLINE> <INDENT> if a <= 399 : <NEWLINE> <INDENT> hai = 1 <NEWLINE> <DEDENT> elif a <= 799 : <NEWLINE> <INDENT> tya = 1 <NEWLINE> <DEDENT> elif a <= 1199 : <NEWLINE> <INDENT> mizu = 1 <NEWLINE> <DEDENT> elif a <= 1599 : <NEWLINE> <INDENT> ao = 1 <NEWLINE> <DEDENT> elif a <= 1999 : <NEWLINE> <INDENT> ki = 1 <NEWLINE> <DEDENT> elif a <= 2399 : <NEWLINE> <INDENT> dai = 1 <NEWLINE> <DEDENT> elif a <= 3199 : <NEWLINE> <INDENT> aka = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> mu += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> max_num = min ( 8 , hai + tya + mizu + ao + ki + dai + aka + mu ) <NEWLINE> min_num = max ( hai + tya + mizu + ao + ki + dai + aka ) <NEWLINE> <NL> print ( min_num , max_num ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> color = [ 0 ] * 8 <NEWLINE> any = 0 <NEWLINE> for i in a : <NEWLINE> <INDENT> if 1 <= i <= 399 : <NEWLINE> <INDENT> color [ 0 ] = 1 <NEWLINE> <DEDENT> elif 400 <= i <= 799 : <NEWLINE> <INDENT> color [ 1 ] = 1 <NEWLINE> <DEDENT> elif 800 <= i <= 1199 : <NEWLINE> <INDENT> color [ 2 ] = 1 <NEWLINE> <DEDENT> elif 1200 <= i <= 1599 : <NEWLINE> <INDENT> color [ 3 ] = 1 <NEWLINE> <DEDENT> elif 1600 <= i <= 1999 : <NEWLINE> <INDENT> color [ 4 ] = 1 <NEWLINE> <DEDENT> elif 2000 <= i <= 2399 : <NEWLINE> <INDENT> color [ 5 ] = 1 <NEWLINE> <DEDENT> elif 2400 <= i <= 2799 : <NEWLINE> <INDENT> color [ 6 ] = 1 <NEWLINE> <DEDENT> elif 2800 <= i <= 3199 : <NEWLINE> <INDENT> color [ 7 ] = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> any += 1 <NEWLINE> <DEDENT> <DEDENT> m = max ( sum ( color ) , 1 ) <NEWLINE> M = min ( sum ( color ) + any ) <NEWLINE> print ( m , M ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> Colors = [ ] <NEWLINE> High_scorer = [ ] <NEWLINE> for a in A : <NEWLINE> <INDENT> if a < 400 : <NEWLINE> <INDENT> Colors . append ( <STRING> ) <NEWLINE> <DEDENT> if 400 <= a and a < 800 : <NEWLINE> <INDENT> Colors . append ( <STRING> ) <NEWLINE> <DEDENT> if 800 <= a and a < 1200 : <NEWLINE> <INDENT> Colors . append ( <STRING> ) <NEWLINE> <DEDENT> if 1200 <= a and a < 1600 : <NEWLINE> <INDENT> Colors . append ( <STRING> ) <NEWLINE> <DEDENT> if 1600 <= a and a < 2000 : <NEWLINE> <INDENT> Colors . append ( <STRING> ) <NEWLINE> <DEDENT> if 2000 <= a and a < 2400 : <NEWLINE> <INDENT> Colors . append ( <STRING> ) <NEWLINE> <DEDENT> if 2400 <= a and a < 2800 : <NEWLINE> <INDENT> Colors . append ( <STRING> ) <NEWLINE> <DEDENT> if 2800 <= a and a < 3200 : <NEWLINE> <INDENT> Colors . append ( <STRING> ) <NEWLINE> <DEDENT> if 3200 <= a : <NEWLINE> <INDENT> High_scorer . append ( a ) <NEWLINE> <NL> <DEDENT> <DEDENT> MIN = len ( set ( Colors ) ) <NEWLINE> H = len ( High_scorer ) <NEWLINE> <NL> MIN >= 1 : <NEWLINE> <INDENT> print ( MIN , ( MIN + H ) ) <NEWLINE> <DEDENT> MIN = 0 : <NEWLINE> <INDENT> print ( 1 , H ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> color = set ( ) <NEWLINE> rainbow = 0 <NEWLINE> <NL> for n in range ( N ) : <NEWLINE> <INDENT> if 1 <= a [ n ] < 400 : <NEWLINE> <INDENT> color . add ( <STRING> ) <NEWLINE> <DEDENT> elif 400 <= a [ n ] < 800 : <NEWLINE> <INDENT> color . add ( <STRING> ) <NEWLINE> <DEDENT> elif 800 <= a [ n ] < 1200 : <NEWLINE> <INDENT> color . add ( <STRING> ) <NEWLINE> <DEDENT> elif 1200 <= a [ n ] < 1600 : <NEWLINE> <INDENT> color . add ( <STRING> ) <NEWLINE> <DEDENT> elif 1600 <= a [ n ] < 2000 : <NEWLINE> <INDENT> color . add ( <STRING> ) <NEWLINE> <DEDENT> elif 2000 <= a [ n ] < 2400 : <NEWLINE> <INDENT> color . add ( <STRING> ) <NEWLINE> <DEDENT> elif 2400 <= a [ n ] < 2800 : <NEWLINE> <INDENT> color . add ( <STRING> ) <NEWLINE> <DEDENT> elif 2800 <= a [ n ] < 3200 : <NEWLINE> <INDENT> color . add ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> rainbow += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if color_min > rainbow : <NEWLINE> <INDENT> color_min = len ( color ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> color_min = rainbow <NEWLINE> <NL> <DEDENT> color_max = color_min + rainbow <NEWLINE> <NL> <NL> print ( <STRING> ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> rate = [ 0 ] * 9 <NEWLINE> over = 0 <NEWLINE> <NL> for i in a : <NEWLINE> <INDENT> for j in range ( 1 , 9 ) : <NEWLINE> <INDENT> if 400 * ( j - 1 ) <= i < 400 * j : <NEWLINE> <INDENT> rate [ j ] = 1 <NEWLINE> break <NEWLINE> <DEDENT> elif i >= 3200 : <NEWLINE> <INDENT> over += 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> ansmin = rate . counta ( 1 ) <NEWLINE> ansmax = rate . count ( 1 ) <NEWLINE> if ansmin == 0 : <NEWLINE> <INDENT> ansmin = 1 <NEWLINE> <NL> <DEDENT> if over > 0 : <NEWLINE> <INDENT> ansmax = ansmax + over <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> print ( ansmin , ansmax ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> a = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> list = { } <NEWLINE> <NL> <NL> for i in a : <NEWLINE> <INDENT> if 1 <= i <= 399 : <NEWLINE> <INDENT> list [ 0 ] = 1 <NEWLINE> <DEDENT> elif 400 <= i <= 799 : <NEWLINE> <INDENT> list [ 1 ] = 1 <NEWLINE> <DEDENT> elif 800 <= i <= 1199 : <NEWLINE> <INDENT> list [ 2 ] = 1 <NEWLINE> <DEDENT> elif 1200 <= i <= 1599 : <NEWLINE> <INDENT> list [ 3 ] = 1 <NEWLINE> <DEDENT> elif 1600 <= i <= 1999 : <NEWLINE> <INDENT> list [ 4 ] = 1 <NEWLINE> <DEDENT> elif 2000 <= i <= 2399 : <NEWLINE> <INDENT> list [ 5 ] = 1 <NEWLINE> <DEDENT> elif 2400 <= i <= 2799 : <NEWLINE> <INDENT> list [ 6 ] = 1 <NEWLINE> <DEDENT> elif 2800 <= i <= 3199 : <NEWLINE> <INDENT> list [ 7 ] = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> list [ 8 ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> min = len ( list ) <NEWLINE> <NL> <NL> if list [ 8 ] > 0 : <NEWLINE> <INDENT> max = len ( list ) + chin <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> max = len ( list ) <NEWLINE> <NL> <DEDENT> print ( min , max ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> rate = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ratecolor = 0 <NEWLINE> free = 0 <NEWLINE> ratecolor = 0 <NEWLINE> color = [ 0 ] * 9 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if ( rate [ i ] >= 3200 ) : <NEWLINE> <INDENT> free += 1 <NEWLINE> break <NEWLINE> for j in range ( 9 ) : <NEWLINE> <DEDENT> if ( rate [ i ] < j * 400 + 400 ) : <NEWLINE> <INDENT> if ( color [ j ] == 0 ) : <NEWLINE> <INDENT> color [ j ] += 1 <NEWLINE> ratecolor += 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ratecolor if ratecolor != 0 else 1 , ratecolor + free ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> import sys <NEWLINE> from io import StringIO <NEWLINE> import unittest <NEWLINE> <NL> <NL> class TestClass ( unittest . TestCase ) : <NEWLINE> <INDENT> def assertIO ( self , input , output ) : <NEWLINE> <INDENT> stdout , stdin = sys . stdout , sys . stdin <NEWLINE> sys . stdout , sys . stdin = StringIO ( ) , StringIO ( input ) <NEWLINE> resolve ( ) <NEWLINE> sys . stdout . seek ( 0 ) <NEWLINE> out = sys . stdout . read ( ) [ : - 1 ] <NEWLINE> sys . stdout , sys . stdin = stdout , stdin <NEWLINE> self . assertEqual ( out , output ) <NEWLINE> <NL> <DEDENT> def test__1 ( self ) : <NEWLINE> <INDENT> input = <STRING> <NEWLINE> output = <STRING> <NEWLINE> self . assertIO ( input , output ) <NEWLINE> <NL> <DEDENT> def test__2 ( self ) : <NEWLINE> <INDENT> input = <STRING> <NEWLINE> output = <STRING> <NEWLINE> self . assertIO ( input , output ) <NEWLINE> <NL> <DEDENT> def test__3 ( self ) : <NEWLINE> <INDENT> input = <STRING> <NEWLINE> output = <STRING> <NEWLINE> self . assertIO ( input , output ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def resolve ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> C = [ 0 ] * 9 <NEWLINE> for a in A : <NEWLINE> <INDENT> for i in range ( 8 ) : <NEWLINE> <INDENT> if 400 * i <= a <= 400 * i + 399 : <NEWLINE> <INDENT> C [ i ] = 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> C [ 8 ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <COMMENT> <NL> <INDENT> resolve ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> r = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> rlist = [ ] <NEWLINE> def color ( n ) : <NEWLINE> <INDENT> if n < 400 : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> elif n < 800 : <NEWLINE> <INDENT> return 2 <NEWLINE> <DEDENT> elif n < 1200 : <NEWLINE> <INDENT> return 3 <NEWLINE> <DEDENT> elif n < 1600 : <NEWLINE> <INDENT> return 4 <NEWLINE> <DEDENT> elif n < 2000 : <NEWLINE> <INDENT> return 5 <NEWLINE> <DEDENT> elif n < 2400 : <NEWLINE> <INDENT> return 6 <NEWLINE> <DEDENT> elif n < 2800 : <NEWLINE> <INDENT> return 7 <NEWLINE> <DEDENT> elif n < 3200 : <NEWLINE> <INDENT> return 8 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return 9 <NEWLINE> <NL> <DEDENT> <DEDENT> for _ in range ( n ) : <NEWLINE> <INDENT> co = color ( r [ _ ] ) <NEWLINE> rlist . append ( co ) <NEWLINE> <NL> <DEDENT> ans1 = len ( set ( rlist ) ) <NEWLINE> if rlist . count ( 9 ) == 0 : <NEWLINE> <INDENT> print ( ans1 , ans1 , sep = <STRING> ) <NEWLINE> <NL> <DEDENT> elif ans1 == 1 : <NEWLINE> <INDENT> print ( 1 , min ( 8 , rlist . count ( 9 ) , sep = <STRING> ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> print ( min ( 8 , ans1 - 1 ) , min ( 8 , ans1 - 1 + rlist . count ( 9 ) ) , sep = <STRING> ) <NEWLINE> <DEDENT>
from collections import defaultdict <NEWLINE> N = int ( input ( ) ) <NEWLINE> al = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> cnt = 0 <NEWLINE> dic = defaultdict ( int ) <NEWLINE> for i in al : <NEWLINE> <INDENT> if 1 <= i <= 399 : <NEWLINE> <INDENT> dic [ <STRING> ] += 1 <NEWLINE> <DEDENT> elif 400 <= i <= 799 : <NEWLINE> <INDENT> dic [ <STRING> ] += 1 <NEWLINE> <DEDENT> elif 800 <= i <= 1199 : <NEWLINE> <INDENT> dic [ <STRING> ] += 1 <NEWLINE> <DEDENT> elif 1200 <= i <= 1599 : <NEWLINE> <INDENT> dic [ <STRING> ] += 1 <NEWLINE> <DEDENT> elif 1600 <= i <= 1999 : <NEWLINE> <INDENT> dic [ <STRING> ] += 1 <NEWLINE> <DEDENT> elif 2000 <= i <= 2399 : <NEWLINE> <INDENT> dic [ <STRING> ] += 1 <NEWLINE> <DEDENT> elif 2400 <= i <= 2799 : <NEWLINE> <INDENT> dic [ <STRING> ] += 1 <NEWLINE> <DEDENT> elif 2800 <= i <= 3199 : <NEWLINE> <INDENT> dic [ <STRING> ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> ansmax = len ( dic . keys ( ) ) + cnt <NEWLINE> if ansmax > n : <NEWLINE> <INDENT> ansmax = n <NEWLINE> <NL> <NL> <DEDENT> ansmin = len ( dic . keys ( ) ) <NEWLINE> if ansmin == 0 and cnt >= 1 : <NEWLINE> <INDENT> ansmin = 1 <NEWLINE> <NL> <DEDENT> print ( ansmin , ansmax ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> nums = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> num_free = 0 <NEWLINE> num_color = [ False ] * 8 <NEWLINE> for rate in nums : <NEWLINE> <INDENT> if rate < 3200 : <NEWLINE> <INDENT> num_color ( rate // 400 ) = True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> num_free += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> ans = sum ( num_color ) <NEWLINE> print ( <STRING> . format ( ans , ans + num_free ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> N_List = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> NR_List = [ i // 400 for i in N_List ] <NEWLINE> Number_NRD = len ( set ( [ i for i in NR_List if i < 8 ] ) ) <NEWLINE> Number_NRU = len ( [ i for i in NR_List if i >= 8 ] ) <NEWLINE> max_p = ( Number_NRD + Number_NRU , 8 ) [ Number_NRD + Number_NRU >= 8 ] <NEWLINE> min_P = ( Number_NRD , 1 ) [ Number_NRD == 0 ] <NEWLINE> print ( str ( min_p ) + <STRING> + str ( max_p ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> color = [ False ] * 8 <NEWLINE> over_human = 0 <NEWLINE> for i in a : <NEWLINE> <INDENT> if ( i <= 399 ) : <NEWLINE> <INDENT> color [ 0 ] = True <NEWLINE> <DEDENT> elif ( i <= 799 ) : <NEWLINE> <INDENT> color [ 1 ] = True <NEWLINE> <DEDENT> elif ( i <= 1199 ) : <NEWLINE> <INDENT> color [ 2 ] = True <NEWLINE> <DEDENT> elif ( i <= 1599 ) : <NEWLINE> <INDENT> color [ 3 ] = True <NEWLINE> <DEDENT> elif ( i <= 1999 ) : <NEWLINE> <INDENT> color [ 4 ] = True <NEWLINE> <DEDENT> elif ( i <= 2399 ) : <NEWLINE> <INDENT> color [ 5 ] = True <NEWLINE> <DEDENT> elif ( i <= 2799 ) : <NEWLINE> <INDENT> color [ 6 ] = True <NEWLINE> <DEDENT> elif ( i <= 3199 ) : <NEWLINE> <INDENT> color [ 7 ] = True <NEWLINE> <DEDENT> elif ( i >= 3200 ) : <NEWLINE> <INDENT> over_human += 1 <NEWLINE> <DEDENT> <DEDENT> if ( color . count ( True ) == 0 ) : <NEWLINE> <INDENT> print ( 1 , color . count ( True ) + over_human ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( color . count ( True ) , color . count ( True ) + over_human ) ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> R = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> X = [ 0 ] * 8 <NEWLINE> p = 0 <NEWLINE> for r in R : <NEWLINE> <INDENT> if r >= 3200 : <NEWLINE> <INDENT> p += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> X [ r // 400 ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> s = sum ( X ) <NEWLINE> if s == 0 : <NEWLINE> <INDENT> print ( str ( 1 ) + <STRING> + str ( cnt ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( str ( s ) + <STRING> + str ( s + cnt ) ) <NEWLINE> <DEDENT>
w = [ ] <NEWLINE> num = 0 <NEWLINE> for i in a : <NEWLINE> <INDENT> if 1 <= i <= 399 : <NEWLINE> <INDENT> if 1 not in w : <NEWLINE> <INDENT> w . append ( 1 ) <NEWLINE> <DEDENT> <DEDENT> elif 400 <= i <= 799 : <NEWLINE> <INDENT> if 400 not in w : <NEWLINE> <INDENT> w . append ( 400 ) <NEWLINE> <DEDENT> <DEDENT> elif 800 <= i <= 1199 : <NEWLINE> <INDENT> if 800 not in w : <NEWLINE> <INDENT> w . append ( 800 ) <NEWLINE> <DEDENT> <DEDENT> elif 1200 <= i <= 1599 : <NEWLINE> <INDENT> if 1200 not in w : <NEWLINE> <INDENT> w . append ( 1200 ) <NEWLINE> <DEDENT> <DEDENT> elif 1600 <= i <= 1999 : <NEWLINE> <INDENT> if 1600 not in w : <NEWLINE> <INDENT> w . append ( 1600 ) <NEWLINE> <DEDENT> <DEDENT> elif 2000 <= i <= 2399 : <NEWLINE> <INDENT> if 2000 not in w : <NEWLINE> <INDENT> w . append ( 2000 ) <NEWLINE> <DEDENT> <DEDENT> elif 2400 <= i <= 2799 : <NEWLINE> <INDENT> if 2400 not in w : <NEWLINE> <INDENT> w . append ( 2400 ) <NEWLINE> <DEDENT> <DEDENT> elif 2800 <= i <= 3199 : <NEWLINE> <INDENT> if 2800 not in w : <NEWLINE> <INDENT> w . append ( 2800 ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> num += 1 <NEWLINE> <DEDENT> <DEDENT> if 0 < len ( w ) : <NEWLINE> <INDENT> print ( len ( w ) , len ( w ) + num ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 1 , len ( w ) + num ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a1 = 0 <NEWLINE> b = 0 <NEWLINE> c = 0 <NEWLINE> d = 0 <NEWLINE> e = 0 <NEWLINE> f = 0 <NEWLINE> g = 0 <NEWLINE> h = 0 <NEWLINE> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if 1 <= a [ i ] <= 399 : <NEWLINE> <INDENT> a1 = 1 <NEWLINE> <DEDENT> elif 400 <= a [ i ] <= 799 : <NEWLINE> <INDENT> b = 1 <NEWLINE> <DEDENT> elif 800 <= a [ i ] <= 1199 : <NEWLINE> <INDENT> c = 1 <NEWLINE> <DEDENT> elif 1200 <= a [ i ] <= 1599 : <NEWLINE> <INDENT> d = 1 <NEWLINE> <DEDENT> elif 1600 <= a [ i ] <= 1999 : <NEWLINE> <INDENT> e = 1 <NEWLINE> <DEDENT> elif 2000 <= a [ i ] <= 2399 : <NEWLINE> <INDENT> f = 1 <NEWLINE> <DEDENT> elif 2400 <= a [ i ] <= 2799 : <NEWLINE> <INDENT> g = 1 <NEWLINE> <DEDENT> elif 2800 <= a [ i ] <= 3199 : <NEWLINE> <INDENT> h = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> x = a1 + b + c + d + e + f + g + h <NEWLINE> if a1 = b = c = d = e = f = g = h = 0 : <NEWLINE> <INDENT> print ( 1 , ans ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( x , x + ans ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> As = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> nums = [ ] <NEWLINE> rainbow = 0 <NEWLINE> for A in As : <NEWLINE> <INDENT> num = A // 400 <NEWLINE> if num < 8 : <NEWLINE> <INDENT> if num not in nums : <NEWLINE> <INDENT> nums . append ( num ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> rainbow += 1 <NEWLINE> <DEDENT> <DEDENT> ans_max = len ( nums ) + rainbow <NEWLINE> ans_min = max ( len ( 1 , nums ) ) <NEWLINE> print ( ans_min , ans_max ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = [ 0 ] * 9 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if a [ i ] < 400 : <NEWLINE> <INDENT> b [ 0 ] += 1 <NEWLINE> <DEDENT> elif a [ i ] < 800 : <NEWLINE> <INDENT> b [ 1 ] += 1 <NEWLINE> <DEDENT> elif a [ i ] < 1200 : <NEWLINE> <INDENT> b [ 2 ] += 1 <NEWLINE> <DEDENT> elif a [ i ] < 1600 : <NEWLINE> <INDENT> b [ 3 ] += 1 <NEWLINE> <DEDENT> elif a [ i ] < 2000 : <NEWLINE> <INDENT> b [ 4 ] += 1 <NEWLINE> <DEDENT> elif a [ i ] < 2400 : <NEWLINE> <INDENT> b [ 5 ] += 1 <NEWLINE> <DEDENT> elif a [ i ] < 2800 : <NEWLINE> <INDENT> b [ 6 ] += 1 <NEWLINE> <DEDENT> elif a [ i ] < 3200 : <NEWLINE> <INDENT> b [ 7 ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> b [ 8 ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> min = 8 - b [ : 8 ] . count ( 0 ) <NEWLINE> max = min + b [ 8 ] <NEWLINE> <NL> if min = 0 : <NEWLINE> <INDENT> min = 1 <NEWLINE> <DEDENT> print ( min , max ) <NEWLINE>
n = input ( ) <NEWLINE> a = [ int ( x ) for x in input ( ) . split ( ) if x < 3200 ] <NEWLINE> c = len ( set ( [ x // 400 for x in a ] ) ) <NEWLINE> print ( max ( c , 1 ) , c + n - len ( a ) ) <NEWLINE>
<COMMENT> <NL> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> n = 399 <NEWLINE> a , b , c , d , e , f , g , h , z = 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 <NEWLINE> <NL> for i in A : <NEWLINE> <INDENT> if i >= 1 and i <= n : <NEWLINE> <INDENT> a = 1 <NEWLINE> <DEDENT> elif i >= 400 and i <= n + 400 : <NEWLINE> <INDENT> b = 1 <NEWLINE> <DEDENT> elif i >= 2 * 400 and i <= 2 * 400 + n : <NEWLINE> <INDENT> c = 1 <NEWLINE> <DEDENT> elif i >= 3 * 400 and i <= 3 * 400 + n : <NEWLINE> <INDENT> d = 1 <NEWLINE> <DEDENT> elif i >= 4 * 400 and i <= 4 * 400 + n : <NEWLINE> <INDENT> e = 1 <NEWLINE> <DEDENT> elif i >= 5 * 400 and i <= 5 * 400 + n : <NEWLINE> <INDENT> f = 1 <NEWLINE> <DEDENT> elif i >= 6 * 400 and i <= 6 * 400 + n : <NEWLINE> <INDENT> g = 1 <NEWLINE> <DEDENT> elif i >= 7 * 400 and i <= 7 * 400 + n : <NEWLINE> <INDENT> h = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> z += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> min_num , max_num = 0 , 0 <NEWLINE> <NL> min_num = a + b + c + d + e + f + g + h <NEWLINE> <NL> max_num = min ( min_num + z ) <NEWLINE> min_num = max ( 1 , min_num ) <NEWLINE> <NL> print ( min_num , max_num ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> while True : <NEWLINE> <INDENT> c = 0 <NEWLINE> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> c += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> c -= 1 <NEWLINE> <DEDENT> if c < 0 : <NEWLINE> <INDENT> s = <STRING> + s <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if c > 0 : <NEWLINE> <INDENT> s = s + <STRING> <NEWLINE> <DEDENT> if c == 0 : <NEWLINE> <INDENT> print ( s ) <NEWLINE> <NL> <DEDENT> <DEDENT>
_ = input ( ) <NEWLINE> S = input ( ) <NEWLINE> <NL> needs_right = 0 , needs_left = 0 <NEWLINE> for c in S : <NEWLINE> <INDENT> if c == <STRING> : <NEWLINE> <INDENT> needs_right += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if needs_right == 0 : <NEWLINE> <INDENT> needs_left += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> needs_right -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> * needs_left + S + <STRING> * needs_right ) <NEWLINE> <NL>
<COMMENT> <NL> <NL> a , b = map ( int , input ( ) ) <NEWLINE> <NL> if a + b >= 10 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( a + b ) <NEWLINE> <DEDENT>
A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if A + B < 10 : print ( str ( C ) ) <NEWLINE> else : print ( <STRING> ) <NEWLINE>
A , B = map ( int , input ( ) , split ( ) ) <NEWLINE> if A + B >= 10 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( A + B ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = [ int ( input ( ) ) for _ in range ( n ) ] <NEWLINE> a . sort ( ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if sum ( a ) % 10 == 0 : <NEWLINE> <INDENT> if a [ i ] % 10 == 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a [ i ] = 0 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( sum ( a ) ) <NEWLINE> exit ( 0 ) <NEWLINE> <DEDENT> <DEDENT> print ( 0 ) <NEWLINE>
a = int ( input ( ) ) <NEWLINE> b = int ( input ( ) ) <NEWLINE> <NL> s = <STRING> <NEWLINE> <NL> if a + b < 10 : <NEWLINE> <INDENT> s = a + b <NEWLINE> <NL> <DEDENT> print ( s ) <NEWLINE>
A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> if A + b >= 10 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( A + B ) <NEWLINE> <DEDENT>
A = map ( int , input ( ) . split ( ) ) <NEWLINE> total = A [ 0 ] + A [ 1 ] <NEWLINE> if total >= 10 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( total ) <NEWLINE> <DEDENT>
a , b = map ( int , input ( ) ) <NEWLINE> print ( a + b if a + b < 10 else <STRING> ) <NEWLINE>
a , b = int ( input ( ) . split ( ) ) <NEWLINE> <NL> sum = a + b <NEWLINE> if ( sum >= 10 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( sum ) <NEWLINE> <DEDENT>
A , B = map ( in , input ( ) . split ( ) ) ; print ( A + B if A + B < 10 else <STRING> ) <NEWLINE>
A , B = map ( int , input ( ) ) <NEWLINE> if A + B >= 10 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( A + B ) <NEWLINE> <DEDENT>
A , B = int ( input ( ) . split ( ) ) <NEWLINE> if A + B < 10 : <NEWLINE> <INDENT> print ( A + B ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
A , B = list ( map ( str , input ( ) . split ( ) ) ) <NEWLINE> <NL> if ( A + B ) < 10 : <NEWLINE> <INDENT> print ( A + B ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b = map ( str , input ( ) . split ( ) ) <NEWLINE> print ( a + b ) if a + b <= 10 else print ( <STRING> ) <NEWLINE>
s = input ( ) <NEWLINE> s = sort . s <NEWLINE> <NL> for i in range ( 1 , len ( s ) ) : <NEWLINE> <INDENT> if s [ i ] == s [ i - 1 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
s = input ( ) <NEWLINE> w = set ( ) <NEWLINE> for i in ( len ( s ) ) : <NEWLINE> <INDENT> w . add ( s [ i ] ) <NEWLINE> <DEDENT> if len ( s ) == len ( w ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = input ( ) <NEWLINE> dic = defaultdict ( int ) <NEWLINE> <NL> for s in N : <NEWLINE> <INDENT> dic [ s ] += 1 <NEWLINE> <NL> if dic [ s ] > 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
a = input ( ) <NEWLINE> b = [ ] <NEWLINE> c = 0 <NEWLINE> for i in range ( len ( a ) ) : <NEWLINE> <INDENT> b . append ( a [ i ] ) <NEWLINE> <DEDENT> b . sort ( ) <NEWLINE> for i in range ( len ( a - 1 ) ) : <NEWLINE> <INDENT> if b [ i ] == b [ i + 1 ] : <NEWLINE> <INDENT> c = c + 1 <NEWLINE> <DEDENT> <DEDENT> if c == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
def check ( s ) : <NEWLINE> <INDENT> for i in range ( 1 , len ( s ) ) : <NEWLINE> <INDENT> if i - 1 in s [ i : ] : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> <DEDENT> return <STRING> <NEWLINE> <NL> <DEDENT> s = input ( ) <NEWLINE> print ( check ( s ) ) <NEWLINE>
S = input <NEWLINE> print ( <STRING> if len ( S ) == len ( set ( S ) ) else <STRING> ) <NEWLINE>
s = input ( ) <NEWLINE> print ( <STRING> if len ( s ) == len ( set ( s ) else <STRING> ) <NEWLINE>
s = list ( innput ( ) ) <NEWLINE> <NL> if len ( s ) == len ( set ( s ) ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if a + b >= 10 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( a + b ) <NEWLINE> <DEDENT>
import sys <NEWLINE> N = int ( input ( ) ) <NEWLINE> S = [ int ( input ( ) ) for _ in range ( N ) ] <NEWLINE> S . sort ( ) <NEWLINE> t = sum ( S ) <NEWLINE> if t % 10 != 0 : <NEWLINE> <INDENT> print ( t ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> for s in range ( S ) : <NEWLINE> <INDENT> if ( t - s ) % 10 != 0 : <NEWLINE> <INDENT> print ( t - s ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( 0 ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> x = 0 <NEWLINE> mn = 101 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> s = int ( input ( ) ) <NEWLINE> x += s <NEWLINE> if x % 10 != 0 <NEWLINE> <INDENT> if s < mn : <NEWLINE> <INDENT> mn = s <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if x % 10 != 0 : <NEWLINE> <INDENT> print ( x ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x -= mn <NEWLINE> if x % 10 == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if x < 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> print ( x ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> s = list ( int ( input ( ) ) for i in range ( n ) ) <NEWLINE> <NL> ans = sum ( S ) <NEWLINE> sort_S = sorted ( S ) <NEWLINE> <NL> if ans % 10 != 0 : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for s in sort_S : <NEWLINE> <INDENT> if s % 10 != 0 : <NEWLINE> <INDENT> ans -= s <NEWLINE> print ( ans ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( 0 ) <NEWLINE>
a = int ( input ( ) ) <NEWLINE> b = [ int ( input ( ) ) for i in range ( a ) ] <NEWLINE> b . sort ( ) <NEWLINE> c = sum ( b ) <NEWLINE> d = 0 <NEWLINE> if c % 10 != 0 : <NEWLINE> <INDENT> print ( c ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( a ) : <NEWLINE> <INDENT> if b [ i ] % != 0 : <NEWLINE> <INDENT> d = c - b [ i ] <NEWLINE> print ( d ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if d == c : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> S = [ ] <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> S . append ( int ( input ( ) ) ) <NEWLINE> <NL> <DEDENT> S . sort ( ) <NEWLINE> ans = sum ( S ) <NEWLINE> <NL> if ans % 10 != 0 : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> if A [ i ] % 10 != 0 : <NEWLINE> <INDENT> ans -= a [ i ] <NEWLINE> print ( ans ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( 0 ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> maxs = 0 <NEWLINE> s = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> cin = int ( input ( ) ) <NEWLINE> s . append ( cin ) <NEWLINE> maxs = max ( maxs , cin ) <NEWLINE> <DEDENT> M = maxs * N + 1 <NEWLINE> <NL> dp = [ False * M ] <NEWLINE> dp [ 0 ] = True <NEWLINE> <NL> for x in s : <NEWLINE> <INDENT> for i in range ( M ) : <NEWLINE> <INDENT> if i < x : continue <NEWLINE> if dp [ i - x ] : dp [ i ] = True <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( M ) : <NEWLINE> <INDENT> if ( M - i ) % 10 != 0 and dp [ M - i ] : <NEWLINE> <INDENT> print ( M - i ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> s = [ int ( input ( ) ) for _ in range ( n ) ] <NEWLINE> <NL> sumNum = sum ( s ) <NEWLINE> if sumNum % 10 != 0 : <NEWLINE> <INDENT> print ( sumNum ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> t = 0 <NEWLINE> for i in s : <NEWLINE> <INDENT> if ( sumNum - i ) % 10 != 0 : <NEWLINE> <INDENT> t = max ( t , sum - i ) <NEWLINE> <DEDENT> <DEDENT> print ( t ) <NEWLINE>
import sys , re <NEWLINE> from collections import deque , defaultdict , Counter <NEWLINE> from math import ceil , sqrt , hypot , factorial , pi , sin , cos , tan , asin , acos , atan , radians , degrees , log2 , log <NEWLINE> from itertools import accumulate , permutations , combinations , combinations_with_replacement , product , groupby <NEWLINE> from operator import itemgetter , mul <NEWLINE> from copy import deepcopy <NEWLINE> from string import ascii_lowercase , ascii_uppercase , digits <NEWLINE> from bisect import bisect , bisect_left , insort , insort_left <NEWLINE> from fractions import gcd <NEWLINE> from heapq import heappush , heappop <NEWLINE> from functools import reduce <NEWLINE> from decimal import Decimal <NEWLINE> def input ( ) : return sys . stdin . readline ( ) . strip ( ) <NEWLINE> def INT ( ) : return int ( input ( ) ) <NEWLINE> def MAP ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def LIST ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> def ZIP ( n ) : return zip ( * ( MAP ( ) for _ in range ( n ) ) ) <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> INF = float ( <STRING> ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> from decimal import * <NEWLINE> <NL> N , A , B = MAP ( ) <NEWLINE> h = [ INT ( ) for _ in range ( N ) ] <NEWLINE> h . sort ( reverse = True ) <NEWLINE> <NL> def is_ok ( x ) : <NEWLINE> <INDENT> h_copy = h [ : ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> h_copy [ i ] -= B * x <NEWLINE> <DEDENT> cnt = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> cnt += max ( 0 , ceil ( h_copy [ i ] / ( A - B ) ) ) <NEWLINE> <DEDENT> return cnt <= x <NEWLINE> <NL> <DEDENT> while l + 1 != r : <NEWLINE> <INDENT> p = - ( - l - r ) // 2 <NEWLINE> if is_OK ( p ) : <NEWLINE> <INDENT> r = p <NEWLINE> <DEDENT> elif is_OK ( p ) == 0 : <NEWLINE> <INDENT> l = p <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if is_OK ( p ) : <NEWLINE> <INDENT> print ( p ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( p + 1 ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> using namespace std ; <NEWLINE> <NL> int main ( ) { <NEWLINE> <INDENT> long N , A , B ; <NEWLINE> cin >> N >> A >> B ; <NEWLINE> vector < long > h ; <NEWLINE> for ( int i = 0 ; i < N ; i + + ) { <NEWLINE> <INDENT> long input ; <NEWLINE> cin >> input ; <NEWLINE> h . push_back ( input ) ; <NEWLINE> <DEDENT> } <NEWLINE> <NL> <NL> long ans = 0 ; <NEWLINE> vector < long > temp ; <NEWLINE> while ( h . size ( ) != 0 ) { <NEWLINE> <INDENT> bool first = true ; <NEWLINE> make_heap ( h . begin ( ) , h . end ( ) ) ; <NEWLINE> for ( auto x : h ) { <NEWLINE> <INDENT> if ( first ) { x -= A ; first = false ; } <NEWLINE> else { x -= B ; } <NEWLINE> if ( x > 0 ) temp . push_back ( x ) ; <NEWLINE> <DEDENT> } <NEWLINE> h . clear ( ) ; <NEWLINE> for ( auto x : temp ) h . push_back ( x ) ; <NEWLINE> temp . clear ( ) ; <NEWLINE> ans + + ; <NEWLINE> <DEDENT> } <NEWLINE> cout << ans << endl ; <NEWLINE> return 0 ; <NEWLINE> <DEDENT> } <NEWLINE>
N , A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> if A > B : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> elif A == B : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> elif B - A >= N : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ( B - A ) * X + 1 ) <NEWLINE> <DEDENT>
n , a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if ( a > b ) : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if ( n = 1 ) : <NEWLINE> <INDENT> if ( a != b ) : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( b * ( n - 1 ) + a - ( a * ( n - 1 ) + b ) + 1 ) <NEWLINE> <DEDENT> <DEDENT>
n , a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if ( n == 1 and a == b ) : <NEWLINE> <INDENT> ans = 1 <NEWLINE> <DEDENT> elif ( n == 1 ) : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> elif A > B : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = ( b - a ) * ( n - 2 ) + 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> if x > y : <NEWLINE> <INDENT> x , y = y , x <NEWLINE> <NL> <DEDENT> A = [ 1 , 3 , 5 , , 7 , 8 , 10 , 12 ] <NEWLINE> B = [ 4 , 6 , 9 , 11 ] <NEWLINE> <NL> if x == 2 or y == 2 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif ( x in A and y in B ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> if x in gp1 and y in gp1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif x in gp2 and y in gp2 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif x == y == 2 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ 1 , 3 , 5 , 7 , 8 , 10 , 12 ] <NEWLINE> b = [ 4 , 6 , 9 , 11 ] <NEWLINE> c = [ 2 ] <NEWLINE> if ( x in a and y in a ) : <NEWLINE> <INDENT> ptint ( <STRING> ) <NEWLINE> <DEDENT> elif ( x in b and y in b ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif ( x in c and y in c ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
l1 = [ 1 , 3 , 5 , 7 , 8 , 10 , 12 ] <NEWLINE> l2 = [ 4 , 6 , 9 , 11 ] <NEWLINE> l3 = [ 2 ] <NEWLINE> n = 0 <NEWLINE> if x in l1 : <NEWLINE> <INDENT> if y in l1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> n = 1 <NEWLINE> <DEDENT> <DEDENT> elif x in l2 : <NEWLINE> <INDENT> if y in l2 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> n = 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if y in l3 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> n = 1 <NEWLINE> <DEDENT> <DEDENT> if n == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a = [ 1 , 3 , 5 , 7 , 8 , 10 , 12 ] <NEWLINE> b = [ 4 , 6 , 9 , 11 ] <NEWLINE> c = [ 2 ] <NEWLINE> x , y = input ( ) . split ( ) <NEWLINE> if x , y is in a or x , y is in b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> group_A = [ 1 , 3 , 5 , 7 , 8 , 10 , 12 ] <NEWLINE> group_B = [ 4 , 6 , 9 , 11 ] <NEWLINE> if x in group_A = True and y in group_A = True : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif x in group_B = True and y in group_B = True : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
G = [ set ( [ 1 , 3 , 5 , 7 , 8 , 10 , 12 ] ) , set ( [ 4 , 6 , 9 , 11 ] ) , set ( [ 2 ] ) ] <NEWLINE> def check ( x , y ) : <NEWLINE> <INDENT> for g in G : <NEWLINE> <INDENT> if x in g and y in g : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> <DEDENT> return False <NEWLINE> <DEDENT> print ( <STRING> if check ( x , y ) else <STRING> ) <NEWLINE>
a = [ 1 , 3 , 5 , 7 , 8 , 10 , 12 ] <NEWLINE> b = [ 4 , 6 , 9 , 11 ] <NEWLINE> c = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> print ( <STRING> ) if ( c [ 0 ] in a and c [ 1 ] in a ) or ( c [ 0 ] in b and c [ 1 ] in b ) else print ( <STRING> ) <NEWLINE>
x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> S1 = [ 1 , 3 , 5 , 7 , 8 , 10 , 12 ] <NEWLINE> S2 = [ 4 , 6 , 9 , 11 ] <NEWLINE> for i in range ( len ( S1 ) ) : <NEWLINE> <INDENT> for j in range ( len ( S1 ) ) : <NEWLINE> <INDENT> if ( S1 [ i ] == x and s1 [ j ] == y ) or ( S2 [ i ] == x adn S2 [ j ] == y ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
x , y = map ( iint , input ( ) . split ( ) ) <NEWLINE> A = [ 1 , 3 , 5 , 7 , 8 , 10 , 12 ] <NEWLINE> B = [ 4 , 6 , 9 , 11 ] <NEWLINE> C = [ 2 ] <NEWLINE> if x in A and y in A : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif x in B and y in B : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> s0 = 1 << ( x - 1 ) | 1 << ( y - 1 ) <NEWLINE> s1 = sum ( list ( map ( lambda x : 1 << ( x - 1 ) , [ 1 , 3 , 5 , 7 , 8 , 10 , 12 ] ) ) ) & s0 <NEWLINE> s2 = sum ( list ( map ( lambda x : 1 << ( x - 1 ) , [ 4 , 6 , 9 , 11 ] ) ) ) & s0 <NEWLINE> s3 == sum ( list ( map ( lambda x : 1 << ( x - 1 ) , [ 2 ] ) ) ) & s0 <NEWLINE> <NL> if s1 == s0 or s2 == s0 or s3 == s0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> G = 121313113131 <NEWLINE> print ( [ <STRING> , <STRING> ] [ G [ x - 1 ] == G [ y - 1 ] ] ) <NEWLINE>
n1 = set ( [ 1 , 3 , 5 , 7 , 8 , 10 , 12 ] ) <NEWLINE> n2 = set ( [ 4 , 6 , 9 , 11 ] ) <NEWLINE> n3 = set ( [ 2 ] ) <NEWLINE> nums = set ( map ( int , input ( ) . split ( ) ) <NEWLINE> print ( <STRING> if nums <= n1 or nums <= n2 or nums <= n3 else <STRING> ) <NEWLINE>
<COMMENT> <NL> H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ ] <NEWLINE> for i in range ( H ) : <NEWLINE> <INDENT> a . append ( input ( ) ) <NEWLINE> <NL> <NL> <DEDENT> for i in range ( W + 2 ) : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> for i in a : <NEWLINE> <INDENT> print ( <STRING> , l , <STRING> , sep = <STRING> ) <NEWLINE> <DEDENT> for i in range ( W + 2 ) : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT>
print ( <STRING> * ( w + 2 ) ) <NEWLINE> for i in range ( h ) : <NEWLINE> <INDENT> print ( <STRING> + input ( ) + <STRING> ) <NEWLINE> <DEDENT> print ( <STRING> * ( w + 2 ) ) <NEWLINE>
x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> for i in range ( x + 1 ) : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> for i in range ( y ) : <NEWLINE> <INDENT> print ( <STRING> + input ( ) + <STRING> ) <NEWLINE> <DEDENT> for i in range ( x + 1 ) : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE>
H , W = int ( input ( ) . split ( ) ) <NEWLINE> a = [ ] <NEWLINE> a . append ( <STRING> * ( W + 2 ) ) <NEWLINE> for i in range ( 1 , H + 1 ) : <NEWLINE> <INDENT> a . append ( <STRING> + input ( ) + <STRING> ) <NEWLINE> <DEDENT> a . append ( <STRING> * ( W + 2 ) ) <NEWLINE> for i in range ( H + 2 ) : <NEWLINE> <INDENT> print ( a [ i ] ) <NEWLINE> <DEDENT>
def answer ( H , W , ans ) : <NEWLINE> <INDENT> for x in range ( 1 , W ) : <NEWLINE> <INDENT> y1 = H // 2 <NEWLINE> Sa1 = H * x <NEWLINE> Sb1 = ( W - x ) * y1 <NEWLINE> Sc1 = ( W - x ) * ( H - y1 ) <NEWLINE> M = max ( Sa1 , Sb1 , Sc1 ) <NEWLINE> m = min ( Sa1 , Sb1 , Sc1 ) <NEWLINE> <NL> y2 = ( W - x ) // 2 <NEWLINE> Sa2 = H * x <NEWLINE> Sb2 = H * y2 <NEWLINE> Sc2 = H * ( W - x - y2 ) <NEWLINE> M2 = max ( Sa2 , Sb2 , Sc2 ) <NEWLINE> m2 = min ( Sa2 , Sb2 , Sc2 ) <NEWLINE> <NL> if ans > min ( M - m , M2 - m2 ) : <NEWLINE> <INDENT> ans = min ( M - m , M2 - m2 ) <NEWLINE> <NL> <DEDENT> return ans <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> H , W = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> ans = H * W <NEWLINE> ans = answer ( H , W ) <NEWLINE> <NL> H , W = W , H <NEWLINE> <NL> if answer ( H , W ) < ans : <NEWLINE> <INDENT> ans = answer ( H , W ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
H , W = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> ans = 0 <NEWLINE> <NL> for x in range ( 1 , W ) : <NEWLINE> <INDENT> y = H // 2 <NEWLINE> Sa1 = H * x <NEWLINE> Sb1 = ( W - x ) * y <NEWLINE> Sc1 = ( W - x ) * ( H - y ) <NEWLINE> M = max ( Sa1 , Sb1 , Sc1 ) <NEWLINE> m = min ( Sa1 , Sb1 , Sc1 ) <NEWLINE> <NL> Sa2 = H * x <NEWLINE> Sb2 = H * y <NEWLINE> Sb2 = H * ( W - x - y ) <NEWLINE> M2 = max ( Sa2 , Sb2 , Sc2 ) <NEWLINE> m2 = min ( Sa2 , Sb2 , Sc2 ) <NEWLINE> <NL> if ans > min ( M - m , M2 - m2 ) : <NEWLINE> <INDENT> ans = min ( M - m , M2 - m2 ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( <STRING> if c >= a and c <= B else <STRING> ) <NEWLINE>
a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( <STRING> , if a <= c <= b else <STRING> ) <NEWLINE>
A , B , C = main ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if ( C >= A and C <= B ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if a + b >= 10 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( a + b ) <NEWLINE> <DEDENT>
if C >= A : <NEWLINE> <INDENT> if C <= B : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b , c = map ( int ( input ( ) . split ( ) ) ) <NEWLINE> <COMMENT> <NL> print ( <STRING> if a <= c <= b else <STRING> ) <NEWLINE>
A , B , C = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( <STRING> if a <= c <= b else <STRING> ) <NEWLINE>
<INDENT> N , M = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <DEDENT> lis = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> lis . append ( [ i + 1 ] ) <NEWLINE> <DEDENT> for i in range ( M ) : <NEWLINE> <INDENT> a , b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> lis [ a - 1 ] . append ( b ) <NEWLINE> lis [ b - 1 ] . append ( a ) <NEWLINE> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> print ( len ( lis [ i ] ) - 1 ) <NEWLINE> <DEDENT>
from collections import defaultdict <NEWLINE> <NL> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> r = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ] <NEWLINE> d = defaultdict ( int ) <NEWLINE> for x in r : <NEWLINE> <INDENT> d [ x [ 0 ] ] += 1 <NEWLINE> d [ x [ 1 ] ] += 1 <NEWLINE> <NL> <DEDENT> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> print ( d [ i ] ) <NEWLINE> <DEDENT>
N , M = list ( map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ 0 for _ in range ( N ) ] <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> a , b = list ( map ( int , input ( ) . split ( ) ) <NEWLINE> A [ a - 1 ] += 1 <NEWLINE> A [ b - 1 ] += 1 <NEWLINE> <NL> <DEDENT> for i range ( N ) : <NEWLINE> <INDENT> print ( str ( A [ i ] ) ) <NEWLINE> <DEDENT>
M , N = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = [ 0 for _ in range ( N ) ] <NEWLINE> for _ in range ( M ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> ans [ a - 1 ] += 1 <NEWLINE> ans [ b - 1 ] += 1 <NEWLINE> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> print ( ans [ i ] ) <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> a = [ ] <NEWLINE> <NL> for i in m : <NEWLINE> <INDENT> a1 , a2 = map ( int , input ( ) . split ( ) ) <NEWLINE> a . append ( a1 ) <NEWLINE> a . append ( a2 ) <NEWLINE> <NL> <DEDENT> for s in n : <NEWLINE> <INDENT> print ( a . count ( s ) ) <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> g = [ [ ] for _ in range ( n ) ] <NEWLINE> <NL> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> g [ a - 1 ] = b - 1 <NEWLINE> g [ b - 1 ] = a - 1 <NEWLINE> <NL> <DEDENT> for nd in g : <NEWLINE> <INDENT> print ( len ( nd ) ) <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> road_num = [ 0 ] * n <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> road_num [ a ] += 1 <NEWLINE> road_num [ b ] += 1 <NEWLINE> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> print ( road_num [ i ] ) <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> x = [ 0 ] * n <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> x [ a - 1 ] += 1 <NEWLINE> x [ b - 1 ] += 1 <NEWLINE> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> print ( x [ i ] <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> AB = [ [ ] for _ in range ( n ) ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> a -= 1 <NEWLINE> b -= 1 <NEWLINE> AB [ a ] . append ( b ) <NEWLINE> AB [ b ] . append ( a ) <NEWLINE> <NL> <DEDENT> for i in range ( n ) <NEWLINE> <INDENT> print ( len ( AB [ i ] ) ) <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ ] <NEWLINE> b = [ ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> a . append ( input ( ) ) <NEWLINE> b . append ( input ( ) ) <NEWLINE> <DEDENT> for j in range ( n ) : <NEWLINE> <INDENT> print ( a . count ( j + 1 ) + b . count ( j + 1 ) ) <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = [ 0 for _ in range ( n ) ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> ans [ a - 1 ] += 1 <NEWLINE> ans [ b - 1 ] += 1 <NEWLINE> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> print ( a [ i ] ) <NEWLINE> <DEDENT>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> R = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( N ) ] <NEWLINE> <NL> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> print ( R . count ( i ) ) <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> a_s = [ ] <NEWLINE> b_s = [ ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> a_s . append ( a ) <NEWLINE> b_s . append ( b ) <NEWLINE> <NL> <DEDENT> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> print ( a_s . count ( i ) + b_s . count ( i ) ) <NEWLINE> <DEDENT>
mycode = <STRING> <NEWLINE> <NL> import sys <NEWLINE> import os <NEWLINE> if sys . argv [ - 1 ] == <STRING> : <COMMENT> <NEWLINE> <INDENT> with open ( <STRING> , <STRING> ) as f : <NEWLINE> <INDENT> f . write ( mycode ) <NEWLINE> <DEDENT> os . system ( <STRING> ) <NEWLINE> <NL> <DEDENT> import mycode <NEWLINE>
N , M = open ( 0 ) . readline ( ) . split ( ) <NEWLINE> from collections import Counter <NEWLINE> cnt = Counter ( open ( 0 ) . read ( ) . split ( ) ) <NEWLINE> for i in range ( 1 , int ( N ) + 1 ) : <NEWLINE> <INDENT> print ( cnt [ str ( i ) ] ) <NEWLINE> <DEDENT>
4 3 <NEWLINE> 1 2 <NEWLINE> 2 3 <NEWLINE> 1 4 <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ 0 ] * ( N * 1 ) <NEWLINE> <NL> for _ in range ( M ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> A [ a ] += 1 <NEWLINE> A [ b ] += 1 <NEWLINE> <NL> <DEDENT> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> print ( A [ i ] ) <NEWLINE> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> cnt = 0 <NEWLINE> P = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> P . append ( ( a , b ) ) <NEWLINE> <NL> <DEDENT> P = sorted ( P ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> cnt += P [ 1 ] <NEWLINE> if cnt >= K : <NEWLINE> <INDENT> print ( P [ 0 ] ) <NEWLINE> <DEDENT> <DEDENT>
N , K = [ int ( x ) for x in input ( ) . split ( <STRING> ) ] <NEWLINE> <NL> placed = 0 <NEWLINE> elm = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> a , b = input ( ) . split ( <STRING> ) <NEWLINE> elm . append ( { <NEWLINE> <INDENT> <STRING> : i + 1 , <NEWLINE> <STRING> : int ( a ) , <NEWLINE> <STRING> : int ( b ) <NEWLINE> <DEDENT> } ) <NEWLINE> <NL> <DEDENT> elm . sort ( key = lambda e : ( e [ <STRING> ] , e [ <STRING> ] ) ) <NEWLINE> for i in range ( len ( elm ) ) : <NEWLINE> <INDENT> placed = e [ <STRING> ] <NEWLINE> if placed >= K : <NEWLINE> <INDENT> print ( e [ <STRING> ] ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> l = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> l . append ( ( a , b ) ) <NEWLINE> <DEDENT> l = sorted ( l ) <NEWLINE> c = 0 <NEWLINE> i = 0 <NEWLINE> while c < k : <NEWLINE> <INDENT> c += l [ i ] [ 1 ] <NEWLINE> i += 1 <NEWLINE> <NL> <DEDENT> print ( l [ i ] [ 1 ] ) <NEWLINE>
from sys <NEWLINE> rl = sys . stdin . readline <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> n , k = map ( int , rl . strip ( ) . split ( ) ) <NEWLINE> ints = [ list ( map ( int , rl . strip ( ) . split ( ) ) ) for _ in range ( n ) ] <NEWLINE> ints . sort ( key = lambda e : e [ 0 ] ) <NEWLINE> s = 0 <NEWLINE> for e in ints : <NEWLINE> <INDENT> s += e [ 1 ] <NEWLINE> if s <= k : <NEWLINE> <INDENT> print ( e [ 0 ] ) <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> ab = [ [ 0 , 0 ] ] * N <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> _a , _b = map ( int , input ( ) . split ( ) ) <NEWLINE> ab [ i ] = [ _a , _b ] <NEWLINE> <DEDENT> ab . sort ( key = lambda x : x [ 0 ] ) <NEWLINE> <NL> j = 0 <NEWLINE> index = 0 <NEWLINE> while j < K : <NEWLINE> <INDENT> j += ab [ index ] [ 1 ] <NEWLINE> if j < K : <NEWLINE> <INDENT> index += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ab [ index ] [ 0 ] <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> s [ 0 ] * 10 ** 5 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> s [ a - 1 ] += b <NEWLINE> <DEDENT> i = 0 <NEWLINE> while k > 0 : <NEWLINE> <INDENT> k -= s [ i ] <NEWLINE> i += 1 <NEWLINE> <DEDENT> print ( i ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = [ 0 ] * ( 10 ** 5 + 1 ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> ans [ a ] += b <NEWLINE> <NL> <DEDENT> for i in range ( len ( ba ) ) : <NEWLINE> <INDENT> k -= ans [ i ] <NEWLINE> if k <= 0 : <NEWLINE> <INDENT> print ( i ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT>
a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> cnt = 0 <NEWLINE> <NL> if a == b and a == c and a % 2 == 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> while acnt % 2 == 0 and bcnt % 2 == 0 and ccnt % 2 == 0 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> i = a <NEWLINE> j = b <NEWLINE> a = ( b + c ) // 2 <NEWLINE> b = ( i + c ) // 2 <NEWLINE> c = ( i + j ) // 2 <NEWLINE> <NL> <DEDENT> print ( cnt ) <NEWLINE>
if a % 2 == 1 or b % 2 == 1 or c % 2 == 1 : <NEWLINE> <INDENT> print ( f ) <NEWLINE> <DEDENT> elif a == b and b == c : <NEWLINE> <INDENT> f = - 1 <NEWLINE> print ( f ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> while a % 2 == 0 and b % 2 == 0 and c % 2 == 0 : <NEWLINE> <INDENT> A = a <NEWLINE> B = b <NEWLINE> C = c <NEWLINE> a = B // 2 + C // 2 <NEWLINE> b = A // 2 + C // 2 <NEWLINE> c = A // 2 + B // 2 <NEWLINE> f = f + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( f ) <NEWLINE> <DEDENT> <DEDENT>
a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> if a == b == c and a % 2 == 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> d = 0 <NEWLINE> else : <NEWLINE> <INDENT> while a % 2 == 0 and b % 2 == 0 and c % 2 == 0 : <NEWLINE> <INDENT> a , b , c = ( b + c ) , ( a + c ) , ( a + b ) <NEWLINE> d += 1 <NEWLINE> <DEDENT> <DEDENT> print ( d ) <NEWLINE>
import sys <NEWLINE> import numpy as np <NEWLINE> import numba <NEWLINE> from numba import jit <NEWLINE> <NL> read = sys . stdin . buffer . read <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> readlines = sys . stdin . buffer . readlines <NEWLINE> <NL> @ jit <NEWLINE> def main ( p ) : <NEWLINE> <INDENT> count = 0 <NEWLINE> if np . any ( p % 2 == 1 ) : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> if np . unique ( p ) . size == 1 : <NEWLINE> <INDENT> return - 1 <NEWLINE> <DEDENT> while True : <NEWLINE> <INDENT> if np . any ( p % 2 == 1 ) : <NEWLINE> <INDENT> return count <NEWLINE> <DEDENT> p [ 0 ] , p [ 1 ] , p [ 2 ] = p [ 1 ] / 2 + p [ 2 ] / 2 , p [ 0 ] / 2 + p [ 2 ] / 2 , p [ 0 ] / 2 + p [ 1 ] / 2 <NEWLINE> count += 1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> p = np . array ( readline ( ) . split ( ) , np . int64 ) <NEWLINE> <NL> print ( main ( p ) ) <NEWLINE>
a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> if a == b == c : <NEWLINE> <INDENT> if a % 2 == = b % 2 == c % 2 == 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> exit ( ) <NEWLINE> <DEDENT> cnt = 0 <NEWLINE> while a % 2 == b % 2 == c % 2 : <NEWLINE> <INDENT> A = a // 2 <NEWLINE> B = b // 2 <NEWLINE> C = c // 2 <NEWLINE> a , b , c = B + C , A + C , A + B <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> print ( cnt ) <NEWLINE>
A , B , C = map ( int , input ( ) . split ( ) ) <NEWLINE> con = 0 <NEWLINE> if A % 2 == 1 or B % 2 == 1 or C % 1 == 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> if A == B and B == C : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> while A % 2 == 0 and B % 2 == 0 and C % 2 == 0 : <NEWLINE> <INDENT> con += 1 <NEWLINE> D = A / 2 <NEWLINE> E = B / 2 <NEWLINE> F = C / 2 <NEWLINE> A = E + F <NEWLINE> B = D + F <NEWLINE> C = D + E <NEWLINE> <NL> <DEDENT> print ( con ) <NEWLINE> A , B , C = map ( int , input ( ) . split ( ) ) <NEWLINE> con = 0 <NEWLINE> if A % 2 == 1 or B % 2 == 1 or C % 1 == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> if A == B and B == C : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> while A % 2 == 0 and B % 2 == 0 and C % 2 == 0 : <NEWLINE> <INDENT> con += 1 <NEWLINE> D = A / 2 <NEWLINE> E = B / 2 <NEWLINE> F = C / 2 <NEWLINE> A = E + F <NEWLINE> B = D + F <NEWLINE> C = D + E <NEWLINE> <NL> <DEDENT> print ( con ) <NEWLINE>
a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> a_tmp = a ; b_tmp = b ; c_tmp = c <NEWLINE> count = 0 <NEWLINE> while True : <NEWLINE> <INDENT> count += 1 <NEWLINE> a = b_tmp / 2 + c_tmp / 2 <NEWLINE> b = a_tmp / 2 + c_tmp / 2 <NEWLINE> c = a_tmp / 2 + b_tmp / 2 <NEWLINE> if a == a_tmp and b == b_tmp and c = c_tmp : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> a_tmp = a ; b_tmp = b ; c_tmp = c <NEWLINE> if a % 2 == 1 or b % 2 == 1 or c % 2 == 1 : <NEWLINE> <INDENT> print ( count ) <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> <DEDENT>
def ( a , b , c ) : <NEWLINE> <INDENT> if a % 2 + b % 2 + c % 2 > 0 : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> if a == b == c : <NEWLINE> <INDENT> return - 1 <NEWLINE> <DEDENT> return f ( ( b + c ) // 2 , ( c + a ) // 2 , ( a + b ) // 2 ) + 1 <NEWLINE> <NL> <DEDENT> a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( f ( a , b , c ) ) <NEWLINE>
a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if a == b == c : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> if a % 2 != 0 or b % 2 != 0 or c % 2 != 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> N = ( a + b + c ) // 3 <NEWLINE> cnt = 1 <NEWLINE> while N : <NEWLINE> <INDENT> if N % 2 != 0 : break <NEWLINE> N //= 2 <NEWLINE> cnt += 1 <NEWLINE> <NL> <DEDENT> print ( cnt ) <NEWLINE>
a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> if a == b == c : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> total = 0 <NEWLINE> else : <NEWLINE> <INDENT> while True : <NEWLINE> <INDENT> x = a / 2 <NEWLINE> y = b / 2 <NEWLINE> z = c / 2 <NEWLINE> a = y + z <NEWLINE> b = x + z <NEWLINE> c = x + y <NEWLINE> total += 1 <NEWLINE> if a % 2 != 0 or b % 2 != 0 or c % 2 != 0 : <NEWLINE> <INDENT> print ( total ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
a , b , c = map ( int , open ( 0 ) . read ( ) . split ( ) ) <NEWLINE> <NL> if a == b == c and a % 2 == 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> num = 0 <NEWLINE> while true : <NEWLINE> <INDENT> if a % 2 == 1 or b % 2 == 1 or c % 2 == 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> l = [ ( b + c ) / 2 , ( c + a ) / 2 , ( a + b ) / 2 ] <NEWLINE> num += 1 <NEWLINE> l = [ ( l [ 1 ] + l [ 2 ] ) / 2 , ( l [ 2 ] + l [ 0 ] ) / 2 , ( l [ 0 ] + l [ 2 ] ) / 2 ] <NEWLINE> a = l [ 0 ] <NEWLINE> b = l [ 1 ] <NEWLINE> c = l [ 2 ] <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( num ) <NEWLINE> <DEDENT> <DEDENT>
a , b , c = map ( string , input ( ) . split ( ) ) <NEWLINE> if a [ - 1 ] == b [ 0 ] and b [ - 1 ] == c [ 0 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> if a [ - 1 ] == b [ 0 ] and b [ - 1 ] == c [ 0 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
A , B , C = input ( ) . split ( ) <NEWLINE> if A [ - 1 ] == B [ 0 ] and B [ - 1 ] == C [ 0 ] : <NEWLINE> <INDENT> print ( <STRING> ) : <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b , c = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if a [ - 1 ] == b [ 0 ] and b [ - 1 ] == c [ 0 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> if a [ - 1 ] == b [ 0 ] and b [ - 1 ] == c [ 0 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
A = input ( ) <NEWLINE> B = input ( ) <NEWLINE> C = input ( ) <NEWLINE> if A [ - 1 ] == B [ 0 ] and B [ - 1 ] == C [ 0 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT>
<COMMENT> <NL> A , B , C = input ( ) . split ( ) <NEWLINE> <NL> if ( 1 <= len ( A ) and len ( A ) <= 10 and A . islower ( ) ) and ( 1 <= len ( B ) and len ( B ) <= 10 and B . islower ( ) ) and ( 1 <= len ( C ) and len ( C ) <= 10 and C . islower ( ) ) : <NEWLINE> <INDENT> if ( A [ len ( A ) - 1 ] == B [ 0 ] ) and ( B [ 0 ] == C [ len ( B ) - 1 ] ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
A , B , C = map ( int , input ( ) . split ( ) ) <NEWLINE> if A [ - 1 ] == B [ 0 ] and B [ - 1 ] == C [ 0 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b , c = map ( str , input ( ) . split ( ) ) <NEWLINE> Flag = 1 <NEWLINE> if a [ len ( a ) - 1 ] != b [ 0 ] : <NEWLINE> <INDENT> Flag = 0 <NEWLINE> <DEDENT> if b [ len ( b ) - 1 ] != c [ 0 ] : <NEWLINE> <INDENT> Flag = 0 <NEWLINE> <DEDENT> if Flag = 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b , c = input ( ) . split ( ) <NEWLINE> if a [ - 1 ] == b [ 0 ] and b [ - 1 ] == c [ 0 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> <NEWLINE> <DEDENT>
a , b , c = input ( ) . split ( ) <NEWLINE> <NL> if a [ len ( a ) - 1 ] == b [ 0 ] and b [ ( b ) - 1 ] == c [ 0 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
A , B , C = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> Flag = False <NEWLINE> <NL> for i in range ( 1 , B + 1 ) : <NEWLINE> <INDENT> D = i * A % B <NEWLINE> if D = C : <NEWLINE> <INDENT> Flag = True <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if Flag == True : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> for i in range ( 1 , b + 1 ) : <NEWLINE> <INDENT> a % b * i % b == c : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
, b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> s = { } <NEWLINE> while True : <NEWLINE> <INDENT> if a % b == c : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> elif ( a % b ) in s : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s . add ( ( a % b ) ) <NEWLINE> a += a <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> <NL> A , B , C = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> for i in range ( 1 , B + 1 ) <NEWLINE> <INDENT> if ( A * i ) % B == C : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> for i in range ( 1 , b + 1 ) : <NEWLINE> <INDENT> if ( i * a ) % b == c : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> break <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> for i in range ( b ) : <NEWLINE> <INDENT> if ( i * a ) % b == c : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
A , B , C = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> print ( <STRING> if C % gcd ( A , B ) == 0 else <STRING> ) <NEWLINE>
<COMMENT> <NL> <NL> A , B , C = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> ans = <STRING> <NEWLINE> for i in range ( B + 1 ) ) : <NEWLINE> <INDENT> res = A * i % B <NEWLINE> if res == C : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> num = a <NEWLINE> if ( a % 2 == 1 and c % 2 == 0 ) or ( a % 2 == 0 and c % 2 == 1 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> pritn ( <STRING> ) <NEWLINE> <DEDENT>
a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> ans = <STRING> <NEWLINE> for i in range ( 1 , b + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , a + 1 ) : <NEWLINE> <INDENT> if a * i = b * j + c : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<INDENT> N , T = map ( int , input ( ) . split ( ) ) <NEWLINE> <DEDENT> t = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = T <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> now = t [ i + 1 ] - t [ i ] <NEWLINE> ans += min ( now , T ) <NEWLINE> <NL> <NL> <DEDENT> print ( ans ) <NEWLINE>
n , t = map ( int , input ( ) . split ( ) ) <NEWLINE> arr = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> summ = t <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> summ += min ( t , arr [ i + 1 ] - arr [ i ] ) <NEWLINE> <DEDENT> return summ <NEWLINE>
a , b = input ( ) . split ( ) <NEWLINE> a = int ( a ) <NEWLINE> b = int ( b ) <NEWLINE> c = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> m = a * b <NEWLINE> for i in range ( a ) : <NEWLINE> <INDENT> if c [ i + 1 ] - c [ i ] < b : <NEWLINE> <INDENT> m = m - ( b - ( c [ i + 1 ] - c [ i ] ) ) <NEWLINE> <DEDENT> <DEDENT> print ( m ) <NEWLINE>
from sys import stdin <NEWLINE> from itertools import accumulate <NEWLINE> readline = stdin . readline <NEWLINE> <NL> N , W = map ( int , input ( ) . split ( ) ) <NEWLINE> vs = [ [ ] for _ in range ( 4 ) ] <NEWLINE> w , v = map ( int , input ( ) . split ( ) ) <NEWLINE> w1 = w <NEWLINE> vs [ 0 ] . append ( v ) <NEWLINE> for _ in range ( N - 1 ) : <NEWLINE> <INDENT> w , v = map ( int , input ( ) . split ( ) ) <NEWLINE> vs [ w - w1 ] . append ( v ) <NEWLINE> <NL> <DEDENT> for i in range ( 4 ) : <NEWLINE> <INDENT> vs [ i ] . sort ( reverse = True ) <NEWLINE> vs [ i ] = [ 0 ] + list ( accumulate ( vs [ i ] ) ) <NEWLINE> <NL> <DEDENT> result = 0 <NEWLINE> for i in range ( len ( vs [ 0 ] ) + 1 ) : <NEWLINE> <INDENT> a = W - w1 * i <NEWLINE> if a < 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for j in range ( len ( vs [ 1 ] ) + 1 ) : <NEWLINE> <INDENT> b = a - ( w1 + 1 ) * j <NEWLINE> if b < 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for k in range ( len ( vs [ 2 ] ) + 1 ) : <NEWLINE> <INDENT> c = b - ( w1 + 2 ) * k <NEWLINE> if c < 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> t = vs [ 0 ] [ i ] + vs [ 1 ] [ j ] + vs [ 2 ] [ k ] <NEWLINE> for l in range ( len ( vs [ 3 ] ) + 1 ) : <NEWLINE> <INDENT> d = c - ( w1 + 3 ) * l <NEWLINE> if d < 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> result = max ( result , t + vs [ 3 ] [ l ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( result ) <NEWLINE>
N , T = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> LST = [ ] <NEWLINE> <NL> for a in A : <NEWLINE> <INDENT> LST . append ( ( a , 1 ) ) <NEWLINE> LST . append ( ( a + T , - 1 ) ) <NEWLINE> <NL> <DEDENT> LST . sort ( ) <NEWLINE> <NL> prev = - 1 <NEWLINE> s = 0 <NEWLINE> ans = 0 <NEWLINE> for x , y in A : <NEWLINE> <INDENT> if y == 1 : <NEWLINE> <INDENT> if s == 0 : <NEWLINE> <INDENT> prev = x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s += 1 <NEWLINE> <DEDENT> <DEDENT> elif y == - 1 : <NEWLINE> <INDENT> s -= 1 <NEWLINE> if s == 0 : <NEWLINE> <INDENT> ans += ( x - prev ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL>
N , T = map ( int , input ( ) . split ( ) ) ; <NEWLINE> t = [ int ( x ) for x in input ( ) . split ( ) ] ; <NEWLINE> <NL> end = 0 ; <NEWLINE> ans = 0 ; <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if end > t [ i ] : <NEWLINE> <INDENT> ans += t [ i ] + T - end ; <NEWLINE> else : <NEWLINE> ans += T ; <NEWLINE> <DEDENT> end += t [ i ] + T ; <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> print ( ans ) ; <NEWLINE>
a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> acnt = 0 <NEWLINE> bcnt = 0 <NEWLINE> ccnt = 0 <NEWLINE> cnt = 0 <NEWLINE> if a == b and a == c and a % 2 == 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> while a % 2 == 0 and b % 2 == 0 and c % 2 == 0 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> acnt = ( b + c ) // 2 <NEWLINE> bcnt = ( a + c ) // 2 <NEWLINE> ccnt = ( a + b ) // 2 <NEWLINE> a = acnt <NEWLINE> b = bcnt <NEWLINE> c = ccnt <NEWLINE> <DEDENT> print ( cnt ) <NEWLINE>
print ( [ * zip ( * input ( ) . split ( ) ) ] [ 0 ] . upper ( ) ) <NEWLINE>
a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( upper ( a [ 0 ] + b [ 0 ] + c [ 0 ] ) ) <NEWLINE>
s1 , s2 , s3 = map ( input ( ) . split ( ) ) <NEWLINE> <NL> s1 = s1 [ 0 ] . str . upper ( ) <NEWLINE> s2 = s2 [ 0 ] . str . upper ( ) <NEWLINE> s3 = s3 [ 0 ] . str . upper ( ) <NEWLINE> <NL> print ( s1 , s2 , s3 ) <NEWLINE>
a , b , c = input ( ) . split ( ) <NEWLINE> print ( ( s1 [ 0 ] + s2 [ 0 ] + s3 [ 0 ] ) . upper ( ) ) <NEWLINE>
a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = a [ 0 ] + b [ 0 ] + c [ 0 ] <NEWLINE> print ( ans . upper ( ) ) <NEWLINE>
a , b , c = map ( input ( ) . split ( ) ) <NEWLINE> print ( a [ 0 ] . isupper ( ) , b [ 0 ] . isupper ( ) , c [ 0 ] . isupper ( ) , sep = <STRING> ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> import sys , re <NEWLINE> from collections import deque , defaultdict , Counter <NEWLINE> from math import ceil , sqrt , hypot , factorial , pi , sin , cos , radians <NEWLINE> from itertools import accumulate , permutations , combinations , product <NEWLINE> from operator import itemgetter , mul <NEWLINE> from copy import deepcopy <NEWLINE> from string import ascii_lowercase , ascii_uppercase , digits <NEWLINE> from bisect import bisect , bisect_left <NEWLINE> from fractions import gcd <NEWLINE> from heapq import heappush , heappop <NEWLINE> from functools import reduce <NEWLINE> import numpy as np <NEWLINE> def input ( ) : return sys . stdin . readline ( ) . strip ( ) <NEWLINE> def INT ( ) : return int ( input ( ) ) <NEWLINE> def MAP ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def LIST ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> def ZIP ( n ) : return zip ( * ( MAP ( ) for _ in range ( n ) ) ) <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> INF = float ( <STRING> ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> s1 , s2 , s3 = input ( ) . split ( ) <NEWLINE> print ( upper ( s1 [ 0 ] ) + upper ( s2 [ 0 ] ) + upper ( s3 [ 0 ] ) ) <NEWLINE>
a = int ( input ( ) ) <NEWLINE> b = int ( input ( ) ) <NEWLINE> print ( <STRING> if a > b else <STRING> if a < b else <STRING> ) <NEWLINE>
a , b , c = map ( str , input ( ) . split ( ) ) <NEWLINE> print ( upper ( a [ 0 ] + b [ 0 ] + c [ 0 ] ) ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if a > b : print ( <STRING> ) <NEWLINE> elif a < b : print ( <STRING> ) <NEWLINE> else : print ( <STRING> ) <NEWLINE>
A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> if A > B : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> if A < B : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> if A == B : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a = int ( input ( ) ) <NEWLINE> b = int ( input ( ) ) <NEWLINE> <NL> if a < b : <NEWLINE> <INDENT> print ( <STRING> ) : <NEWLINE> <DEDENT> elif a > b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a = int ( input ( ) ) <NEWLINE> b = int ( input ( ) ) <NEWLINE> import math <NEWLINE> if math . sqrt ( a ) == math . sqrt ( b ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif math . sqrt ( a ) > math . sqrt ( b ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> math . sqrt ( a ) < math . sqrt ( b ) : <NEWLINE> print ( <STRING> ) <NEWLINE> <DEDENT>
A = int ( input ( ) ) <NEWLINE> B = int ( input ( ) ) <NEWLINE> print ( <STRING> if A > B else <STRING> if A = B else <STRING> ) <NEWLINE>
a = input ( ) <NEWLINE> b = input ( ) <NEWLINE> if len ( a ) == len ( b ) : <NEWLINE> <INDENT> if a == b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a < b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else a > b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> elif len ( a ) < len ( b ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if a > b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a < b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if a > b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a == b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b = ri ( ) , ri ( ) <NEWLINE> if a == b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a > b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if a > b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a < b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a = int ( input ( ) ) <NEWLINE> b = int ( input ( ) ) <NEWLINE> if a > b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a = b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> if A > B : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif A == B : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( <STRING> if a > b else <STRING> if a < b else <STRING> ) <NEWLINE>
a = int ( input ( ) . split ( ) ) <NEWLINE> b = int ( input ( ) . split ( ) ) <NEWLINE> <NL> if a > b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a == b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
A , B = input ( ) . split ( ) <NEWLINE> N = max ( len ( A ) , len ( B ) ) <NEWLINE> A , B = A . zfill ( N ) , B . zfill ( N ) <NEWLINE> if A == B : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> if A > B : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> if A < B : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
def i ( ) : <NEWLINE> <INDENT> return int ( input ( ) ) <NEWLINE> <DEDENT> def i2 ( ) : <NEWLINE> <INDENT> return map ( int , input ( ) . split ( ) ) <NEWLINE> <DEDENT> def s ( ) : <NEWLINE> <INDENT> return str ( input ( ) ) <NEWLINE> <DEDENT> def l ( ) : <NEWLINE> <INDENT> return list ( input ( ) ) <NEWLINE> <DEDENT> def intl ( ) : <NEWLINE> <INDENT> return list ( int ( k ) for k in input ( ) . split ( ) ) <NEWLINE> <NL> <DEDENT> a = i ( ) <NEWLINE> b = i ( ) <NEWLINE> <NL> if len ( a ) > len ( b ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a == b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
def chk ( a , t ) : <COMMENT> <NEWLINE> <INDENT> cnt = 0 <COMMENT> <NEWLINE> x = 0 <COMMENT> <NEWLINE> for i in a : <NEWLINE> <INDENT> x += i <NEWLINE> if t == True and x <= 0 : <COMMENT> <NEWLINE> <INDENT> cnt += 1 - x <NEWLINE> x = x + ( 1 - x ) <COMMENT> <NEWLINE> <DEDENT> elif t == False and x >= 0 : <COMMENT> <NEWLINE> <INDENT> cnt += 1 + x <NEWLINE> x = x - ( 1 + x ) <COMMENT> <NEWLINE> <DEDENT> t = not t <COMMENT> <NEWLINE> <DEDENT> return cnt <NEWLINE> <DEDENT> print ( min ( chk ( a , True ) , chk ( a , False ) ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> <NL> def odd_positive ( List , n ) : <NEWLINE> <INDENT> sum_a = 0 <NEWLINE> cost = 0 <NEWLINE> for a in List : <NEWLINE> <INDENT> nextsum = sum_a + a <NEWLINE> if i & 1 and nextsum <= 0 : <NEWLINE> <INDENT> cost = - nextsum + 1 <NEWLINE> sum_a = 1 <NEWLINE> <DEDENT> elif ( not i & 1 ) and nextsum >= 0 : <NEWLINE> <INDENT> cost = nextsum + 1 <NEWLINE> sum_a = - 1 <NEWLINE> <DEDENT> <DEDENT> return cost <NEWLINE> <NL> <NL> <DEDENT> def odd_negative ( List , n ) : <NEWLINE> <INDENT> sum_a = 0 <NEWLINE> cost = 0 <NEWLINE> for a in List : <NEWLINE> <INDENT> nextsum = sum_a + a <NEWLINE> if i & 1 and nextsum >= 0 : <NEWLINE> <INDENT> cost = nextsum + 1 <NEWLINE> sum_a = - 1 <NEWLINE> <DEDENT> elif ( not i & 1 ) and nextsum <= 0 : <NEWLINE> <INDENT> cost = - nextsum + 1 <NEWLINE> sum_a = 1 <NEWLINE> <DEDENT> <DEDENT> return cost <NEWLINE> <NL> <DEDENT> ans = min ( odd_positive ( a , n ) , odd_negative ( a , n ) ) <NEWLINE> print ( ans ) <NEWLINE>
n , m = map ( int ( input ( ) . split ( ) ) ) <NEWLINE> if abs ( n - m ) < 2 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
x , y = = map ( int , input ( ) . split ( ) ) <NEWLINE> if abs ( x - y ) < 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if n = < 2 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> cnt = 0 <NEWLINE> <NL> if l [ 0 ] > l [ 1 ] : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <DEDENT> elif l [ 0 ] < l [ 1 ] : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <NL> <DEDENT> for i in range ( 2 , n ) : <NEWLINE> <INDENT> if l [ i - 1 ] > l [ i ] and ( ans == <STRING> or ans == <STRING> ) : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <DEDENT> elif l [ i - 1 ] < l [ i ] and ( ans == <STRING> or ans == <STRING> ) : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <DEDENT> elif l [ i - 1 ] == l [ i ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> ans = <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> print ( cnt + 1 ) <NEWLINE>
def solve ( ) : <NEWLINE> <NL> <INDENT> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> i = 0 <NEWLINE> result = 0 <NEWLINE> <NL> while i < N : <NEWLINE> <INDENT> while i + 1 < n and A [ i ] == A [ i + 1 ] : <NEWLINE> <INDENT> i += 1 <NEWLINE> <DEDENT> if i + 1 < N and A [ i ] < A [ i + 1 ] : <NEWLINE> <INDENT> while i + 1 < n and A [ i ] <= A [ i + 1 ] : <NEWLINE> <INDENT> i += 1 <NEWLINE> <DEDENT> <DEDENT> elif i + 1 < N and A [ i ] > A [ i + 1 ] : <NEWLINE> <INDENT> while i + 1 < n and A [ i ] >= A [ i + 1 ] : <NEWLINE> <INDENT> i += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> result += 1 <NEWLINE> i += 1 <NEWLINE> <NL> <DEDENT> print ( result ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> solve ( ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> <INDENT> f = open ( <STRING> , <STRING> ) <NEWLINE> N = int ( f . readline ( ) ) <NEWLINE> A = [ int ( a ) for a in f . readline ( ) . split ( ) ] <NEWLINE> <NL> idx = 0 <NEWLINE> ans = 0 <NEWLINE> for i in range ( len ( A ) ) : <NEWLINE> <INDENT> if idx + 1 > len ( A ) - 1 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> m = <STRING> <NEWLINE> if A [ idx ] < A [ idx + 1 ] : <NEWLINE> <INDENT> m = <STRING> <NEWLINE> <DEDENT> elif A [ idx ] > A [ idx + 1 ] : <NEWLINE> <INDENT> m = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> find = False <NEWLINE> for j in range ( idx , len ( A ) - 1 ) : <NEWLINE> <INDENT> if A [ j ] < A [ j + 1 ] : <NEWLINE> <INDENT> m = <STRING> <NEWLINE> find = True <NEWLINE> idx = j <NEWLINE> break <NEWLINE> <DEDENT> elif A [ j ] > A [ j + 1 ] : <NEWLINE> <INDENT> m = <STRING> <NEWLINE> find = True <NEWLINE> idx = j <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if find == False : <NEWLINE> <INDENT> print ( ans + 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> for j in range ( idx , len ( A ) - 1 ) : <NEWLINE> <INDENT> if m == <STRING> : <NEWLINE> <INDENT> if A [ j ] <= A [ j + 1 ] : <NEWLINE> <INDENT> idx = j + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> idx = j + 1 <NEWLINE> ans += 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> elif m == <STRING> : <NEWLINE> <INDENT> if A [ j ] >= A [ j + 1 ] : <NEWLINE> <INDENT> idx = j + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> idx = j + 1 <NEWLINE> ans += 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans + 1 ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
p = - 1 <NEWLINE> xp = - 1 <NEWLINE> ans = 0 <NEWLINE> input ( ) <NEWLINE> for i in range ( input ( ) . split ( <STRING> ) ) : <NEWLINE> <INDENT> i = int ( i ) <NEWLINE> if i == p : continue <NEWLINE> if p != - 1 : <NEWLINE> <INDENT> x = p < i <NEWLINE> if xp != - 1 <NEWLINE> <INDENT> ans += x != xp <NEWLINE> <DEDENT> xp = x <NEWLINE> <DEDENT> p = i <NEWLINE> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 10 ** 9 <NEWLINE> for i in range ( 1 , 2 ** n , 2 ) : <NEWLINE> <INDENT> if not i & 1 or k != sum ( [ i >> j & 1 for j in range ( n ) ] ) : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> pre = a [ 0 ] <NEWLINE> cost = 0 <NEWLINE> for j in range ( 1 , n ) : <NEWLINE> <INDENT> if i >> j & 1 : <NEWLINE> <INDENT> tmp = max ( pre - a [ j ] + 1 , 0 ) <NEWLINE> pre = a [ j ] + tmp <NEWLINE> cost += tmp <NEWLINE> <DEDENT> <DEDENT> ans = min ( ans , cost ) <NEWLINE> <DEDENT> print ( ans + <STRING> ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = float ( <STRING> ) <NEWLINE> for bit in range ( 1 << ( n - 1 ) ) : <NEWLINE> <INDENT> cand = [ 0 ] * ( n - 1 ) <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> if bit & 1 << i : cand [ i ] = 1 <NEWLINE> <DEDENT> if cand . count ( 1 ) != k - 1 : continue <NEWLINE> cost = 0 <NEWLINE> mx = a [ 0 ] <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> if cand [ i - 1 ] : <NEWLINE> <INDENT> if a [ i ] <= mx : <NEWLINE> <INDENT> cost += mx - a [ i ] + 1 <NEWLINE> mx += 1 <NEWLINE> <DEDENT> <DEDENT> mx = max ( mx , a [ j ] ) <NEWLINE> <DEDENT> ans = min ( ans , cost ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
a , b , c = map ( int , input ( ) split ( ) ) <NEWLINE> if b - a == c - b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> d = [ dict ( ) for _ in range ( n ) ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> for c in input ( ) : <NEWLINE> <INDENT> if c not in d [ i ] : <NEWLINE> <INDENT> d [ i ] [ c ] = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d [ i ] [ c ] += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> ans = <STRING> <NEWLINE> for i in range ( 26 ) : <NEWLINE> <INDENT> mini = 10 ** 18 <NEWLINE> for j in range ( n ) : <NEWLINE> <INDENT> if chr ( 97 + i ) not in d [ j ] : <NEWLINE> <INDENT> mini = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> mini = min ( mini , d [ j ] [ chr ( 97 + i ) ] ) <NEWLINE> <DEDENT> <DEDENT> ans += mini * chr ( 97 + i ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> print ( <STRING> if b - a == c - b else <STRING> ) <NEWLINE>
a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if a [ 0 ] + a [ 2 ] = 2 * a [ 1 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b = input ( ) . split ( ) <NEWLINE> print ( <STRING> if ( a == <STRING> ) ^ ( b == <STRING> ) else <STRING> ) <NEWLINE>
a , b , c = map ( int , input ( ) . split ( ) ) ; print ( [ <STRING> , <STRING> ] [ b - a == c - b ] ) A <NEWLINE>
a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> if b - a = c - b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> if a - b = b - c : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b , c = = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( <STRING> ) if a == b == c else print ( <STRING> ) <NEWLINE>
<COMMENT> <NL> a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> if b - a = c - b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b , c = int ( input ( ) . split ( ) ) <NEWLINE> if ( b - a ) == ( c - b ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a = int ( input ( ) ) <NEWLINE> b = int ( input ( ) ) <NEWLINE> c = int ( input ( ) ) <NEWLINE> <NL> ba = b - a <NEWLINE> cb = c - b <NEWLINE> <NL> if ba == cb : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> a = input ( ) <NEWLINE> b = input ( ) + [ <STRING> ] <NEWLINE> for i in range ( len ( a ) ) : <NEWLINE> <INDENT> print ( a [ i ] , end = <STRING> ) <NEWLINE> print ( b [ i ] , end = <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
from collections import deque <NEWLINE> <NL> O = input ( ) <NEWLINE> E = input ( ) <NEWLINE> <NL> o = deque ( O ) <NEWLINE> e = deque ( E ) <NEWLINE> <NL> s = <STRING> <NEWLINE> While True : <NEWLINE> <INDENT> if not e a and not o : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> elif o : <NEWLINE> <INDENT> s += o . pop ( ) <NEWLINE> <DEDENT> elif e : <NEWLINE> <INDENT> s += e . pop ( ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> print ( s ) <NEWLINE>
atcoderbeginnercontest <NEWLINE> atcoderregularcontest <NEWLINE>
o = input ( ) <NEWLINE> e = input ( ) <NEWLINE> <NL> n = len ( e ) <NEWLINE> ans = <STRING> <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ans += o [ i ] <NEWLINE> <INDENT> ans += e [ i ] <NEWLINE> <NL> <DEDENT> <DEDENT> if len ( o ) % 2 == 1 : <NEWLINE> <INDENT> ans += o [ - 1 ] <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
a = input ( ) <NEWLINE> b = input ( ) <NEWLINE> c = len ( a ) <NEWLINE> d = len ( b ) <NEWLINE> x = <STRING> <NEWLINE> if c <= d : <NEWLINE> <INDENT> for i in range ( c ) : <NEWLINE> <INDENT> x = x + c [ i ] <NEWLINE> x = x + d [ i ] <NEWLINE> <DEDENT> print ( x ) <NEWLINE> <DEDENT> if c > d : <NEWLINE> <INDENT> for i in range ( d ) : <NEWLINE> <INDENT> x = x + c [ i ] <NEWLINE> x = x + d [ i ] <NEWLINE> <DEDENT> x = x + c [ len ( a ) - 1 ] <NEWLINE> print ( x ) <NEWLINE> <DEDENT>
from itertools import zip_longest <NEWLINE> <NL> o = input ( ) <NEWLINE> e = input ( ) <NEWLINE> <NL> print ( <STRING> . join ( [ x + y for x , y in zip_longetst ( o , e , fillvalue = <STRING> ) ] ) ) <NEWLINE>
O = input ( ) <NEWLINE> E = inpu ( ) <NEWLINE> ans = <STRING> <NEWLINE> for i in range ( len ( E ) ) : <NEWLINE> <INDENT> ans += O [ i ] <NEWLINE> ans += E [ i ] <NEWLINE> <NL> <DEDENT> if len ( O ) != len ( E ) : <NEWLINE> <INDENT> ans += O [ - 1 ] <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
o = input ( ) <NEWLINE> e = input ( ) <NEWLINE> n = [ ] <NEWLINE> e . append ( <STRING> ) <NEWLINE> for i in range ( o ) : <NEWLINE> <INDENT> n . append ( o [ i ] ) <NEWLINE> n . append ( e [ i ] ) <NEWLINE> <DEDENT> print ( <STRING> . join ( n ) . strip ( ) ) <NEWLINE>
<COMMENT> <NL> <NL> odd = raw_input ( ) <NEWLINE> even = raw_input ( ) <NEWLINE> <NL> res = <STRING> <NEWLINE> for ( o , e ) in zip ( odd , even ) : <NEWLINE> <INDENT> res = res + o + e <NEWLINE> <NL> <DEDENT> print res if len ( odd ) - len ( even ) == 0 else res + odd [ - 1 ] <NEWLINE>
import sys <NEWLINE> import math <NEWLINE> import itertools <NEWLINE> import collections <NEWLINE> import heapq <NEWLINE> import re <NEWLINE> import numpy as np <NEWLINE> from functools import reduce <NEWLINE> <NL> rr = lambda : sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> rs = lambda : sys . stdin . readline ( ) . split ( ) <NEWLINE> ri = lambda : int ( sys . stdin . readline ( ) ) <NEWLINE> rm = lambda : map ( int , sys . stdin . readline ( ) . split ( ) ) <NEWLINE> rl = lambda : list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) <NEWLINE> inf = float ( <STRING> ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> o = rr ( ) <NEWLINE> e = rr ( ) <NEWLINE> s = <STRING> <NEWLINE> for a , b in itertools . zip_longest ( o , e , fillvalu = <STRING> ) : <NEWLINE> <INDENT> s += a + b <NEWLINE> <DEDENT> print ( s ) <NEWLINE> <NL> <NL> <NL> <NL> <NL> <NL>
o = str ( input ( ) ) <NEWLINE> s = str ( input ( ) ) <NEWLINE> n = <STRING> <NEWLINE> <NL> if not len ( o ) == len ( s ) : <NEWLINE> <INDENT> for i in range ( min ( len ( o ) , len ( s ) ) ) : <NEWLINE> <INDENT> n += o [ i ] <NEWLINE> n += s [ i ] <NEWLINE> <NL> <DEDENT> if len ( o ) > len ( s ) : <NEWLINE> <INDENT> n += o [ len ( o ) - 1 ] <NEWLINE> <NL> <DEDENT> if len ( s ) > len ( o ) : <NEWLINE> <INDENT> n += s [ len ( s ) - 1 ] <NEWLINE> <NL> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for i in rage ( len ( o ) ) : <NEWLINE> <INDENT> n += o [ i ] <NEWLINE> n += s [ i ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( n ) <NEWLINE>
<COMMENT> <NL> A = input ( ) <NEWLINE> B = input ( ) <NEWLINE> import ita <NEWLINE> pasw = ita . array . make1d ( len ( A ) + len ( B ) + 1 ) <NEWLINE> for i in range ( 0 , len ( A ) ) : <NEWLINE> <INDENT> pasw [ 2 * i ] = A [ i ] <NEWLINE> <DEDENT> for j in range ( 0 , len ( B ) ) : <NEWLINE> <INDENT> pasw [ 2 * j + 1 ] = B [ j ] <NEWLINE> <DEDENT> print ( pasw ) <NEWLINE> <NL> <NL>
a = list ( input ( ) ) <NEWLINE> b = list ( input ( ) ) <NEWLINE> for x , y zip ( a , b ) : <NEWLINE> <INDENT> print ( x + y , end = <STRING> ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> <COMMENT> <NL> from collections import Counter <NEWLINE> <COMMENT> <NL> <NL> <COMMENT> <NL> def solve ( n , a ) : <NEWLINE> <INDENT> alphabetLst = { } <NEWLINE> for i in range ( n ) : <NEWLINE> <DEDENT> ... ( 17 lines ) ... <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> a = [ input ( ) for _ in range ( N ) ] <NEWLINE> print ( solve ( N , a ) ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> d = { } <NEWLINE> for i in range ( 26 ) : <NEWLINE> <INDENT> d [ chr ( ord ( <STRING> ) + i ) ] = 10 ** 9 <NEWLINE> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> for j in range ( 26 ) : <NEWLINE> <INDENT> d [ chr ( ord ( <STRING> ) + i ) ] = min ( d [ chr ( ord ( <STRING> ) + i ) ] , s . count ( chr ( ord ( <STRING> ) + i ) ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> ans = <STRING> <NEWLINE> for e in d . items ( ) : <NEWLINE> <INDENT> ans += e [ 0 ] * e [ 1 ] <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> x = [ x for x in map ( int , input ( ) . split ( ) ) ] <NEWLINE> y = [ y for y in map ( int , input ( ) . split ( ) ) ] <NEWLINE> sum_x = 0 <NEWLINE> sum_y = 0 <NEWLINE> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> sum_x += ( 2 * i - n + 1 ) * x [ i + 1 ] <NEWLINE> <DEDENT> for j in range ( m ) : <NEWLINE> <INDENT> sum_y += ( 2 * j - m + 1 ) * y [ j + 1 ] <NEWLINE> <DEDENT> ans = sum_x * sum_y <NEWLINE> print ( ans % 1000000007 ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> X = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> Y = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> xs = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> xs += i * X [ i ] <NEWLINE> xs -= ( N - i - 1 ) * X [ i ] <NEWLINE> xs %= MOD <NEWLINE> <DEDENT> ys = 0 <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> ys += i * Y [ i ] <NEWLINE> ys -= ( M - i - 1 ) * Y [ i ] <NEWLINE> ys %= MOD <NEWLINE> <DEDENT> print ( xs * ys % MOD ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> h = [ ] <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> h . append ( int ( input ( ) ) ) <NEWLINE> <DEDENT> h . sort ( ) <NEWLINE> ans = pow ( 10 , 10 ) <NEWLINE> for k in range ( N - K + 1 ) : <NEWLINE> <INDENT> ans = min ( ans , abs ( h [ k ] - h [ K - 1 + k ] ) ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> import sys <NEWLINE> from io import StringIO <NEWLINE> import unittest <NEWLINE> <NL> <NL> class TestClass ( unittest . TestCase ) : <NEWLINE> <INDENT> def assertIO ( self , input , output ) : <NEWLINE> <INDENT> stdout , stdin = sys . stdout , sys . stdin <NEWLINE> sys . stdout , sys . stdin = StringIO ( ) , StringIO ( input ) <NEWLINE> resolve ( ) <NEWLINE> sys . stdout . seek ( 0 ) <NEWLINE> out = sys . stdout . read ( ) [ : - 1 ] <NEWLINE> sys . stdout , sys . stdin = stdout , stdin <NEWLINE> self . assertEqual ( out , output ) <NEWLINE> <NL> <DEDENT> def test__1 ( self ) : <NEWLINE> <INDENT> input = <STRING> <NEWLINE> output = <STRING> <NEWLINE> self . assertIO ( input , output ) <NEWLINE> <NL> <DEDENT> def test__2 ( self ) : <NEWLINE> <INDENT> input = <STRING> <NEWLINE> output = <STRING> <NEWLINE> self . assertIO ( input , output ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def resolve ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a . sort ( ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( N / 3 ) : <NEWLINE> <INDENT> a . pop ( ) <NEWLINE> a . pop ( 0 ) <NEWLINE> ans += a . pop ( ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> unittest . main ( ) <NEWLINE> <COMMENT> <NL> <DEDENT>
import sys <NEWLINE> import numpy as np <NEWLINE> <NL> read = sys . stdin . buffer . read <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> readlines = sys . stdin . buffer . readlines <NEWLINE> <NL> def graph_input ( N , M ) : <NEWLINE> <INDENT> G = [ [ ] for _ in range ( N + 1 ) ] <NEWLINE> for _ in range ( M ) : <NEWLINE> <INDENT> a , b = map ( int , readline ( ) . split ( ) ) <NEWLINE> G [ a ] . append ( b ) <NEWLINE> G [ b ] . append ( a ) <NEWLINE> <DEDENT> ind = np . cumsum ( list ( map ( len , G ) ) ) <NEWLINE> G = np . concatenate ( G ) . astype ( np . int32 ) <NEWLINE> return G , ind <NEWLINE> <NL> <DEDENT> def main ( N , G , ind , V , D , C ) : <NEWLINE> <COMMENT> <NL> <INDENT> dp = np . full ( ( N + 1 , 11 ) , - 1 , np . int32 ) <NEWLINE> for t in range ( len ( V ) ) : <NEWLINE> <INDENT> v , d = V [ t ] , D [ t ] <NEWLINE> dp [ v , d ] = t <NEWLINE> <DEDENT> for n in range ( 10 , 0 , - 1 ) : <NEWLINE> <INDENT> for v in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> dp [ v , n - 1 ] = max ( dp [ v , n - 1 ] , dp [ v , n ] ) <NEWLINE> for i in range ( ind [ v - 1 ] , ind [ v ] ) : <NEWLINE> <INDENT> w = G [ i ] <NEWLINE> dp [ w , n - 1 ] = max ( dp [ w , n - 1 ] , dp [ v , n ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> dp = dp [ : , 0 ] <NEWLINE> for v in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> t = dp [ v ] <NEWLINE> c = C [ t ] if t != - 1 else 0 <NEWLINE> print ( c ) <NEWLINE> <NL> <DEDENT> <DEDENT> signature = <STRING> <NEWLINE> if sys . argv [ - 1 ] == <STRING> : <NEWLINE> <INDENT> from numba . pycc import CC <NEWLINE> cc = CC ( <STRING> ) <NEWLINE> cc . export ( <STRING> , signature ) ( main ) <NEWLINE> cc . compile ( ) <NEWLINE> <NL> <DEDENT> from my_module import main <NEWLINE> <NL> N , M = map ( int , readline ( ) . split ( ) ) <NEWLINE> G , ind = graph_input ( N , M ) <NEWLINE> Q = int ( readline ( ) ) <NEWLINE> nums = np . array ( read ( ) . split ( ) , np . int32 ) <NEWLINE> V = nums [ : : 3 ] <NEWLINE> D = nums [ 1 : : 3 ] <NEWLINE> C = nums [ 2 : : 3 ] <NEWLINE> <NL> main ( N , G , ind , V , D , C ) <NEWLINE>
a , b = map ( int , input ( ) ) <NEWLINE> <NL> print ( ( a + b ) % 24 ) <NEWLINE>
A , B = map ( int , iput ( ) . split ( ) ) <NEWLINE> <NL> if A + B >= 24 : <NEWLINE> <INDENT> print ( A + B - 24 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( A + B ) <NEWLINE> <DEDENT>
import bisect <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> B = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> C = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> count = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> a_cand = bisect . bisect_right ( A , B [ i ] - 1 ) <NEWLINE> c_cand = N - bisect . bisect_right ( C , B [ i ] ) <NEWLINE> count += a_cand * c_cand <NEWLINE> <DEDENT> print ( count ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( max ( a + b , a + b - 24 ) <NEWLINE>
a , b = int ( input ( ) . split ( ) ) <NEWLINE> print ( ( a + b ) % 24 ) <NEWLINE>
A , B = map ( int , input ( ) ) <NEWLINE> print ( ( A + B ) % 24 ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( a + b ) if a + b >= 24 print ( a + b - 24 ) <NEWLINE>
A , B = input ( int , input ( ) . split ( ) ) <NEWLINE> <NL> print ( ( A + B ) % 24 ) <NEWLINE>
x = sum ( list ( map ( int , input . split ( ) ) ) ) <NEWLINE> if x >= 24 : <NEWLINE> <INDENT> x -= 24 <NEWLINE> <DEDENT> print ( x ) <NEWLINE>
a . b = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( ( a + b ) % 24 ) <NEWLINE>
a , b = map ( int , input ( ) . splilt ( ) ) <NEWLINE> print ( ( a + b ) % 24 ) <NEWLINE>
A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> return A + B % 24 <NEWLINE>
a , b = map ( int , input ( ) . split ) <NEWLINE> print ( ( a + b ) % 24 ) <NEWLINE>
a , b , c , d = [ 0 ] * n , [ 0 ] * n , [ 0 ] * m , [ 0 ] * m <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a [ i ] , b [ i ] = map ( int , input ( ) . split ( ) ) <NEWLINE> <DEDENT> for i in range ( m ) : <NEWLINE> <INDENT> c [ i ] , d [ i ] = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> min_dist , min_c = abs ( a [ 0 ] - c [ 0 ] ) + abs ( b [ 0 ] - d [ 0 ] ) , 0 <NEWLINE> for j in range ( m ) : <NEWLINE> <INDENT> dist = abs ( a [ i ] - c [ j ] ) + abs ( b [ i ] - d [ j ] ) <NEWLINE> if dist < min_dist : <NEWLINE> <INDENT> min_dist = dist <NEWLINE> min_c = j <NEWLINE> <DEDENT> <DEDENT> print ( min_c + 1 ) <NEWLINE> <DEDENT>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> x = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( N ) ] <NEWLINE> y = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( M ) ] <NEWLINE> for a , b in ab : <NEWLINE> <INDENT> z = [ abs ( a - c ) + abs ( b - d ) for c , d in cd ] <NEWLINE> print ( z . index ( min ( z ) ) + 1 ) <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> a_list = [ ] <NEWLINE> b_list = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> a_list . append ( a ) <NEWLINE> b_list . append ( b ) <NEWLINE> <DEDENT> c_list = [ ] <NEWLINE> d_list = [ ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> c_list . append ( c ) <NEWLINE> d_list . append ( d ) <NEWLINE> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> min = 0 <NEWLINE> min_number = 0 <NEWLINE> for j in range ( m ) : <NEWLINE> <INDENT> d = abs ( a [ i ] - c [ j ] ) + abs ( b [ i ] - d [ j ] ) <NEWLINE> if d < min : <NEWLINE> <INDENT> min = d <NEWLINE> min_number = j <NEWLINE> <DEDENT> <DEDENT> print ( min_number ) <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ input ( ) . split ( ) for i in range ( n ) ] <NEWLINE> c = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( m ) : <NEWLINE> <INDENT> b = input ( ) . split ( ) <NEWLINE> c . append ( abs ( a [ i ] [ 0 ] - b [ 0 ] ) + abs ( a [ i ] [ 1 ] - b [ 1 ] ) ) <NEWLINE> <DEDENT> print ( c . index ( min ( c ) ) ) <NEWLINE> <NL> <NL> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> a_lis = [ list ( map ( int , input ( ) ) ) for i in range ( n ) ] <NEWLINE> c_lis = [ list ( map ( int , input ( ) ) ) for i in range ( m ) ] <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> num = 0 <NEWLINE> ans = 10 ** 10 <NEWLINE> for j in reversed ( range ( m ) ) : <NEWLINE> <INDENT> a = a_lis [ i ] <NEWLINE> c = c_lis [ j ] <NEWLINE> num = abs ( a [ 0 ] - c [ 0 ] ) + abs ( a [ 1 ] - c [ 1 ] ) <NEWLINE> ans = min ( ans , num ) <NEWLINE> if num == ans : <NEWLINE> <INDENT> cnt = j + 1 <NEWLINE> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE> <DEDENT>
n , m = int ( input ( ) ) , 0 <NEWLINE> for i in range ( 1 , n ** .5 + 1 ) : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> m = max ( m , i ) <NEWLINE> <DEDENT> <DEDENT> print ( len ( str ( n // m ) ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> ans = float ( <STRING> ) <NEWLINE> <NL> for i in range ( 1 , N ** 0.5 + 1 ) : <NEWLINE> <INDENT> if N % i == 0 : <NEWLINE> <INDENT> ans = min ( ans , len ( str ( N // i ) ) ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> for i in range ( int ( n ** 0.5 ) , 0 , - 1 ) : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> a = max ( i , n // i ) <NEWLINE> print ( int ( math . log10 ( a ) ) + 1 ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> ans = 10 <NEWLINE> for i in range ( 1 , n / 2 + 1 ) : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> if len ( str ( max ( i , n / i ) ) ) <= ans : <NEWLINE> <INDENT> ans = len ( str ( max ( i , n / i ) ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> ans = 100000 <NEWLINE> for i in range ( 1 , 2 * 10 ** 7 ) : <NEWLINE> <INDENT> if N % i == 0 : <NEWLINE> <INDENT> ans = min ( ans , max ( len ( str ( i ) ) , len ( str ( N // i ) ) ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> <NL> def f ( a , b ) : <NEWLINE> <INDENT> if len ( str ( a ) ) < len ( str ( b ) ) : <NEWLINE> <INDENT> return len ( str ( b ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return len ( str ( a ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> ans = 100000000000 <NEWLINE> for i in range ( 1 , math . sqrt ( N ) + 1 ) : <NEWLINE> <INDENT> if N % i == 0 : <NEWLINE> <INDENT> ans = min ( ans , f ( i , N // i ) ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL>
n = int ( input ( ) ) <NEWLINE> <NL> for a in range ( 1 , n ** 0.5 + 1 ) : <NEWLINE> <INDENT> if n % a == 0 : <NEWLINE> <INDENT> b = n // a <NEWLINE> sa = str ( a ) <NEWLINE> sb = str ( b ) <NEWLINE> if a <= b : <NEWLINE> <INDENT> ans = len ( sb ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> ans = 111111111110 <NEWLINE> for i in range ( int ( N ** 0.5 + 2 ) ) : <NEWLINE> <INDENT> if N % i == 0 : <NEWLINE> <INDENT> use = N // i <NEWLINE> s = str ( use ) <NEWLINE> t = str ( i ) <NEWLINE> ans = min ( ans , max ( len ( s ) , len ( t ) ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N , A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> V = sorted ( [ int ( x ) for x in input ( ) . split ( ) ] , reverse = True ) <NEWLINE> from statistics import mean <NEWLINE> from math import comb <NEWLINE> maxmean = mean ( V [ : A ] ) <NEWLINE> way = 1 <NEWLINE> for i in range ( 1 , B + 1 - A ) : <NEWLINE> <INDENT> v = V . pop ( 0 ) <NEWLINE> if v != maxmean : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> if i > 0 : <NEWLINE> <INDENT> same = A + i <NEWLINE> for j in range ( A , same ) : <NEWLINE> <INDENT> way += comb ( same , j ) <NEWLINE> <DEDENT> <DEDENT> print ( maxmean ) <NEWLINE> print ( way ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if a == b == <STRING> or a == b == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b = input ( ) . split ( ) <NEWLINE> <NL> if a == b : <NEWLINE> <INDENT> print ( <STRING> ) : <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b = input ( ) . split ( ) <NEWLINE> print ( <STRING> if a = b = <STRING> or a = b = <STRING> else <STRING> ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if a == <STRING> : <NEWLINE> <INDENT> print ( b ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if b == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
a , b = input ( ) . split ( ) <NEWLINE> <NL> d = { <STRING> : 0 , <STRING> : 1 } <NEWLINE> print ( [ <STRING> , <STRING> ] [ d [ a ] ^ d [ b ] ] <NEWLINE>
a , b = map ( str , input ( ) . split ( ) ) <NEWLINE> if a == <STRING> and b == <STRING> or A == <STRING> and b = = <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , _ , b = input ( ) . split ( ) <NEWLINE> print ( <STRING> [ a == b ] ) <NEWLINE>
a , b = input ( ) . split ( ) <NEWLINE> x = ( a == <STRING> ) <NEWLINE> y = ( b == <STRING> ) <NEWLINE> if x and y or not x and not y <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b = map ( input ( ) . split ( ) ) <NEWLINE> if ( a == <STRING> and b == <STRING> ) or ( a == <STRING> and b == <STRING> ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if a == b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b = input ( ) . split ( ) <NEWLINE> <NL> print ( <STRING> if ( a == <STRING> ^ b == <STRING> ) else <STRING> ) <NEWLINE>
<COMMENT> <NL> a , b = input ( ) . split ( ) <NEWLINE> <COMMENT> <NL> if a = <STRING> : <NEWLINE> <INDENT> if b = <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> elif a = <STRING> : <NEWLINE> <INDENT> if b = <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b = input ( ) . split ( ) <NEWLINE> if a == H : <NEWLINE> <INDENT> if b == H : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> if a == D : <NEWLINE> <INDENT> if b == H : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <COMMENT> <NL> if a == <STRING> and b == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a == <STRING> and b == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a == <STRING> and b == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a == <STRING> and b == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b = input ( ) . split ( ) <NEWLINE> if a = b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b = ( int ( x ) for x in input ( ) . split ( ) ) <NEWLINE> if a == <STRING> : <NEWLINE> <INDENT> if b == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif b == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> elif a == <STRING> : <NEWLINE> <INDENT> if b == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif b == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
a , b = input ( ) . split ( ) <NEWLINE> <NL> if a == <STRING> <NEWLINE> <INDENT> if b == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if b == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
a , b = map ( str , input ( ) . split ( ) ) <NEWLINE> if a = <STRING> : <NEWLINE> <INDENT> print ( b ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if b = <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
W , a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if b > a : <NEWLINE> <INDENT> if b - ( a + W ) == 0 : <NEWLINE> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> print ( b - ( a + W ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if a - ( b + W ) == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> print ( a - ( b + W ) ) <NEWLINE> <DEDENT>
w , a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if b + w < a : <NEWLINE> <INDENT> print ( a - ( b + w ) ) <NEWLINE> <DEDENT> elif a <= b + w <= a + w : <NEWLINE> <INDENT> print ( 0 ) : <NEWLINE> <DEDENT> elif a <= b <= a + w : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> elif a + w < b : <NEWLINE> <INDENT> print ( b - ( a + w ) ) <NEWLINE> <DEDENT>
w , a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if a + w < b : <NEWLINE> <INDENT> print ( b - a - w ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if a <= b + w and a + w >= b : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( a - b - w ) <NEWLINE> <DEDENT>
W , a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if a + W < b : <NEWLINE> <INDENT> print ( b - ( W + a ) ) : <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT>
W , a , b = map ( int , input ( ) ) <NEWLINE> print ( max ( max ( a , b ) - W - min ( a , b ) , 0 ) ) <NEWLINE>
W , a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if ( a <= b <= a + W ) or ( a <= b + W <= a + W ) or : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if a + W < b : <NEWLINE> <INDENT> print ( abs ( b - ( a + W ) ) ) <NEWLINE> <DEDENT> elif b + W < a : <NEWLINE> <INDENT> print ( abs ( a - ( b + W ) ) ) <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> import re <NEWLINE> from collections import deque , defaultdict , Counter <NEWLINE> from math import ceil , sqrt , hypot , factorial , pi , sin , cos , radians <NEWLINE> from itertools import accumulate , permutations , combinations , product <NEWLINE> from operator import itemgetter , mul <NEWLINE> from copy import deepcopy <NEWLINE> from string import ascii_lowercase , ascii_uppercase , digits <NEWLINE> from bisect import bisect , bisect_left <NEWLINE> from fractions import gcd <NEWLINE> from heapq import heappush , heappop <NEWLINE> from functools import reduce <NEWLINE> def input ( ) : return sys . stdin . readline ( ) . strip ( ) <NEWLINE> def INT ( ) : return int ( input ( ) ) <NEWLINE> def MAP ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def LIST ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> INF = float ( <STRING> ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> X = INT ( ) <NEWLINE> <NL> A = [ ] <NEWLINE> tmp = 0 <NEWLINE> for i in range ( 1 , X ) : <NEWLINE> <INDENT> tmp += i <NEWLINE> A . append ( tmp ) <NEWLINE> if tmp > X : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( 1 , len ( A ) + 1 ) : <NEWLINE> <INDENT> tmp += i <NEWLINE> if X <= A [ i ] : <NEWLINE> <INDENT> print ( i + 1 ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT>
x = int ( input ( ) ) <NEWLINE> s = 0 <NEWLINE> j = 0 <NEWLINE> for i in range ( 1. . x + 1 ) : <NEWLINE> <INDENT> s += i <NEWLINE> j += 1 <NEWLINE> if s >= x : <NEWLINE> <INDENT> print ( j ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT>
d = int ( input ( ) ) <NEWLINE> t = 0 <NEWLINE> while True : <NEWLINE> <INDENT> if t * ( t + 1 ) // 2 >= d : <NEWLINE> <INDENT> print ( t ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT>
import math <NEWLINE> n , c , k = map ( int , input ( ) . split ( ) ) <NEWLINE> t = [ 0 ] * n <NEWLINE> s = 0 <NEWLINE> a = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> t [ i ] = int ( input ( ) ) <NEWLINE> <INDENT> if i > 0 and a > 0 : <NEWLINE> <INDENT> if t [ i ] - t [ i - 1 ] <= k : <NEWLINE> <INDENT> s += ( a + n ) // c <NEWLINE> a = ( a + n ) % c <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s += math . ceil ( ( a + n ) / c ) <NEWLINE> a = 0 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( s ) <NEWLINE>
N , C , K = map ( int , input ( ) . split ( ) ) <NEWLINE> T = list ( int ( input ( ) ) for i in range ( N ) ) <NEWLINE> T . sort ( ) <NEWLINE> bus = 1 <NEWLINE> passenger = 0 <NEWLINE> limit = T [ 0 ] + K <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if T [ i ] <= limit and passenger < c : <NEWLINE> <INDENT> passenger += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> bus += 1 <NEWLINE> limit = T [ i ] + K <NEWLINE> passenger = 1 <NEWLINE> <DEDENT> <DEDENT> print ( bus ) <NEWLINE>
import sys <NEWLINE> N , C , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , sys . stdin . readlines ( ) ) ) + [ 10 ** 10 ] <NEWLINE> A . sort ( ) <NEWLINE> a , c , t = 0 , 1 , a [ 0 ] + k <NEWLINE> for i in A [ 1 : ] : <NEWLINE> <INDENT> if i <= t and c < C : <NEWLINE> <INDENT> c += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> t , c = i + K , 1 <NEWLINE> a += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( a ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> ans = - 1 <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> if a [ i ] * 2 < a [ i + 1 ] : <NEWLINE> <INDENT> ans = i <NEWLINE> <DEDENT> a [ i + 1 ] += a [ i ] <NEWLINE> <DEDENT> print ( n - ans - 1 ) <NEWLINE>
test <NEWLINE>
if n >= 15 : <NEWLINE> <INDENT> x = n * 800 <NEWLINE> y = ( n // 15 ) * 200 <NEWLINE> print ( x - y ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( n * 800 ) <NEWLINE> <DEDENT>
n = int , input ( ) <NEWLINE> k = int ( n / 15 ) <NEWLINE> x = 800 * n - 200 * k <NEWLINE> print ( x ) <NEWLINE>
<COMMENT> <NL> <NL> int main ( void ) { <NEWLINE> <INDENT> int N ; <NEWLINE> scanf ( <STRING> , & N ) ; <NEWLINE> int x = 800 * N ; <NEWLINE> int y = N / 15 * 200 ; <NEWLINE> int ans = x - y ; <NEWLINE> printf ( <STRING> , ans ) ; <NEWLINE> return 0 ; <NEWLINE> <DEDENT> } <NEWLINE>
n = int ( input ( ) ) <NEWLINE> print ( 800 * n - 200 * ( n // 15 ) <NEWLINE>
N = map ( int , input ( ) ) <NEWLINE> n = N // 15 <NEWLINE> x = 800 * N <NEWLINE> y = 200 * n <NEWLINE> <NL> print ( x - y ) <NEWLINE>
x = N * 800 <NEWLINE> y = ( N // 15 ) * 200 <NEWLINE> print ( x - y ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> meal_price = n * 15 <NEWLINE> meal_discount_count = n // 15 <NEWLINE> <NL> return meal_price - ( meal_discount_count * 200 ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> input ( x - 200 * ( x // 15 ) ) <NEWLINE>
<COMMENT> <NL> <NL> n = int ( N ) <NEWLINE> <NL> power = 1 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> power *= i <NEWLINE> power = power % ( 10 ** 9 + 7 ) <NEWLINE> <NL> <DEDENT> print ( power ) <NEWLINE>
import math <NEWLINE> x = int ( input ( ) ) <NEWLINE> a = 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 + 7 <NEWLINE> print ( math . fanctional ( x ) % a ) <NEWLINE>
print ( math . factorial ( int ( input ( ) ) ) ) <NEWLINE>
s = int ( input ( ) ) <NEWLINE> ans = 1 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> ans = ans % ( 10 ** 9 + 7 ) * i <NEWLINE> <NL> <NL> <DEDENT> print ( ans % ( 10 ** 9 + 7 ) ) <NEWLINE>
mycode = <STRING> <NEWLINE> import sys <NEWLINE> if sys . argv [ - 1 ] == <STRING> : <COMMENT> <NEWLINE> <INDENT> with open ( <STRING> , <STRING> ) as f : <NEWLINE> <INDENT> f . write ( mycode ) <NEWLINE> <DEDENT> import os <NEWLINE> os . system ( <STRING> ) <NEWLINE> <NL> <DEDENT> import mycode <NEWLINE>
import math <NEWLINE> N = int ( input ( ) ) <NEWLINE> print ( factorial . ( N ) % ( 10 ** 9 + 7 ) ) <NEWLINE>
import math <NEWLINE> N = int ( input ( ) ) <NEWLINE> print ( math . factrial ( N ) % ( 10 ** 9 + 7 ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> power = 1 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> power *= i <NEWLINE> power = power % ( 10 ** 9 + 7 ) ) <NEWLINE> <NL> <DEDENT> print ( power % ( 10 ** 9 + 7 ) ) <NEWLINE>
print ( math . factorial ( int ( input ( ) ) ) % ( 10 ** 9 + 7 ) ) <NEWLINE>
import math <NEWLINE> n = int ( input ( ) ) <NEWLINE> print ( math . factrial ( n ) % ( 10 ** 9 + 7 ) ) <NEWLINE>
n , m = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> if n >= 2 * m : <NEWLINE> <INDENT> print ( m // 2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( n + ( m - 2 * n ) // 2 ) <NEWLINE> <DEDENT> n , m = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> if n >= 2 * m : <NEWLINE> <INDENT> print ( m // 2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( n + ( m - 2 * n ) // 4 ) <NEWLINE> <DEDENT>
import sys <NEWLINE> from collections import deque <NEWLINE> <NL> dic = { <STRING> : lambda s : 1 - ( s [ 1 ] ^ s [ 0 ] ) , <STRING> : lambda s : s [ 1 ] ^ s [ 0 ] } <NEWLINE> def mknseq ( ox , ld ) : <NEWLINE> <INDENT> for x in ld : <NEWLINE> <INDENT> x . append ( dic [ ox ] ( ( x [ - 2 ] , x [ - 1 ] ) ) ) <NEWLINE> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <INDENT> N = int ( sys . stdin . readline ( ) . strip ( ) ) <NEWLINE> s = list ( sys . stdin . readline ( ) . strip ( ) ) <NEWLINE> ans = [ deque ( [ x , y ] ) for x in range ( 2 ) for y in range ( 2 ) ] <NEWLINE> for x in range ( N ) : <NEWLINE> <INDENT> mknseq ( s [ x ] , ans ) <NEWLINE> <COMMENT> <NL> <DEDENT> for x in ans : <NEWLINE> <INDENT> if x [ : 2 ] == x [ - 2 : ] : <NEWLINE> <INDENT> return print ( <STRING> . join ( [ [ <STRING> , <STRING> ] [ i ] for i in x ] ) [ 1 : - 1 ] ) <NEWLINE> <DEDENT> <DEDENT> print ( - 1 ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> n1 = min ( N , M // 2 ) <NEWLINE> print ( ans + ( M - 2 * n1 ) // 4 ) <NEWLINE>
a = ( int ( input ( ) ) - 2 ) % 13 <NEWLINE> b = ( int ( input ( ) ) - 2 ) % 13 <NEWLINE> print ( [ <STRING> , <STRING> , <STRING> ] [ ( ( a == b ) + 1 ) * ( ( a < b ) - ( b < a ) ) ] ) <NEWLINE>
a , b = map ( int , input ( ) ) <NEWLINE> if a == b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a > b and b != 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
Alice , Bob = map ( int , input ( ) . split ( ) ) <NEWLINE> if Alice = 1 : <NEWLINE> <INDENT> ALice = 14 <NEWLINE> <DEDENT> if Bob = 1 : <NEWLINE> <INDENT> Bob = 14 <NEWLINE> <DEDENT> if Alice > Bob : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif Alice == Bob : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b = map ( int , input ( ) . split ( ) <NEWLINE> if a == b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a == 1 or a > b >= 2 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif b == 1 or b > a >= 2 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if a < b : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <DEDENT> elif a == b : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a > b : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if a > b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a = b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
lst = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if lst [ 0 ] > lst [ 1 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif lst [ 0 ] < lst [ 1 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT>
<NL> def main ( ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if a - 2 < 0 : <NEWLINE> <INDENT> a = 14 <NEWLINE> <NL> <DEDENT> if b - 2 < 0 : <NEWLINE> <INDENT> b = 14 i <NEWLINE> <NL> <DEDENT> if a - 2 > b - 2 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a - 2 < b - 2 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <NL> <DEDENT>
tmp = input ( ) . split ( <STRING> ) <NEWLINE> a = ( int ( tmp [ 0 ] ) - 2 ) % 13 <NEWLINE> b = ( int ( tmp [ 1 ] ) - 2 ) % 13 <NEWLINE> print ( <STRING> ) if a > b else print ( <STRING> ) if a = b else print ( <STRING> ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if a > b and b != 1 or a == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a == b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import sys <NEWLINE> A , B = map ( int , input . split ( ) ) <NEWLINE> if A < 0 or A > 13 or B < 0 or B > 13 : <NEWLINE> <INDENT> sys . exit ( ) <NEWLINE> <NL> <DEDENT> if A == 1 or B == 1 : <NEWLINE> <INDENT> if A == B : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif A == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif B == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> sys . exit ( ) <NEWLINE> <NL> <DEDENT> if A > B : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif B > A : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if a == 1 : <NEWLINE> <INDENT> a = 14 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if b == 1 : <NEWLINE> <INDENT> b = 14 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if a > b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a == b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import itertools <NEWLINE> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> L = [ ] <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> L . append ( [ a , b ] ) <NEWLINE> <NL> <DEDENT> number = [ ] <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> number . append ( i ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> <NL> for v in itertools . permutations ( number , N ) : <NEWLINE> <INDENT> a = 0 <NEWLINE> v = list ( v ) <NEWLINE> for j in range ( N - 1 ) : <NEWLINE> <INDENT> if ( [ v [ j ] , v [ j + 1 ] ] not in L ) and ( [ v [ j + 1 ] , v [ j ] ] not in L ) : <NEWLINE> <INDENT> a = 1 <NEWLINE> <DEDENT> <DEDENT> if a == 0 and v [ 0 ] == 1 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if a > b or a = 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif b > a or b = 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
A , B = map ( int , input ( ) ) <NEWLINE> <NL> func = lambda x : ( x , x + 13 ) [ x == 1 ] <NEWLINE> <NL> if func ( A ) == func ( B ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif func ( A ) < func ( B ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b = = map ( int , input ( ) . split ( ) ) <NEWLINE> if a == 1 and b != 1 or a > b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif b == 1 and a != 1 or b > a : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
<COMMENT> <NL> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <COMMENT> <NL> if A == B : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif A == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif B == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif A > B : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE>
a , b = map ( int ( input ( ) . split ( ) ) ) <NEWLINE> <NL> a = 14 if a == 1 else a <NEWLINE> b = 14 if b == 1 else b <NEWLINE> <NL> if a > b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a < b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> ab = [ [ ] for _ in range ( N ) ] <NEWLINE> <NL> for _ in range ( M ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> ab [ a - 1 ] . append ( b - 1 ) <NEWLINE> ab [ b - 1 ] . append ( a - 1 ) <NEWLINE> <NL> <DEDENT> count = 0 <NEWLINE> <NL> def dfs ( i , now , done ) : <NEWLINE> <INDENT> global count <NEWLINE> if i == N - 1 : <NEWLINE> <INDENT> count += 1 <NEWLINE> return <NEWLINE> <NL> <DEDENT> for j in ab [ now ] : <NEWLINE> <INDENT> if j not in done : <NEWLINE> <INDENT> dfs ( i + 1 , j , done + [ j ] ) <NEWLINE> <DEDENT> <DEDENT> return <NEWLINE> <NL> <DEDENT> dfs ( 0 , 0 , [ 0 ] ) <NEWLINE> print ( count ) <NEWLINE>
from collections import defaultdict <NEWLINE> n , m = map ( lambda x : int ( x ) , input ( ) . split ( ) ) <NEWLINE> <NL> links = defaultdict ( set ) <NEWLINE> <NL> for _ in range ( m ) : <NEWLINE> <INDENT> a , b = map ( lambda x : int ( x ) , input ( ) . split ( ) ) <NEWLINE> links [ a ] . add ( b ) <NEWLINE> links [ b ] . add ( a ) <NEWLINE> <NL> <DEDENT> path_counter = 0 <NEWLINE> <NL> def path_patterns_number ( current_node , remaining_nodes ) : <COMMENT> <NEWLINE> <COMMENT> <NL> <INDENT> if len ( remaining_nodes ) == 0 : <NEWLINE> <INDENT> return 1 <NEWLINE> <NL> <DEDENT> patterns = 0 <NEWLINE> <NL> for next_node in ( links [ current_node ] & remaining_nodes ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <INDENT> patterns += path_patterns_number ( <NEWLINE> <INDENT> next_node , <NEWLINE> remaining_nodes . copy ( ) - { next_node } <NEWLINE> <COMMENT> <NL> <DEDENT> ) <NEWLINE> <NL> <DEDENT> return patterns <NEWLINE> <NL> <DEDENT> print ( path_patterns_number ( 1 , set ( range ( 2 , n + 1 ) ) ) <COMMENT> <NEWLINE>
<COMMENT> <NL> import numpy as np <NEWLINE> <NL> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> graph = [ [ ] for j in range ( n ) ] <NEWLINE> graph = np . array ( graph ) <NEWLINE> <NL> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> graph [ a - 1 ] . append ( b - 1 ) <NEWLINE> graph [ b - 1 ] . append ( a - 1 ) <NEWLINE> <NL> <DEDENT> used = [ False ] * n <NEWLINE> used [ 0 ] = True <NEWLINE> <NL> def DFS ( v , used ) : <NEWLINE> <INDENT> if all ( used ) : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> ans = 0 <NEWLINE> for i in graph ( v ) : <NEWLINE> <INDENT> if used [ i ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> used [ i ] = True <NEWLINE> ans += DFS ( i , used ) <NEWLINE> used [ i ] = False <NEWLINE> <DEDENT> return ans <NEWLINE> <NL> <DEDENT> print ( DFS ( 0 , used ) ) <NEWLINE>
N , M = map ( int , input . split ( ) ) <NEWLINE> <NL> <NL> <COMMENT> <NL> edges = { i : [ ] for i in range ( 1 , N + 1 ) } <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> a , b = [ int ( a ) for a in input ( ) . split ( ) ] <NEWLINE> edges [ a ] . append ( b ) <NEWLINE> edges [ b ] . append ( a ) <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> def dfs ( list ) : <NEWLINE> <COMMENT> <NL> <INDENT> if len ( list ) == N : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a = list [ - 1 ] <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> next = [ n for n in edges [ a ] if n not in list ] <NEWLINE> <COMMENT> <NL> if len ( next ) == 0 : <NEWLINE> <INDENT> return 0 <NEWLINE> <NL> <DEDENT> total = 0 <NEWLINE> <COMMENT> <NL> for n in next : <NEWLINE> <INDENT> total += dfs ( list + [ n ] ) <NEWLINE> <NL> <DEDENT> return total <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> ans = dfs ( [ 1 ] ) <NEWLINE> <NL> print ( ans ) <NEWLINE>
<NL> <COMMENT> <NL> <NL> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> graph = [ ] <NEWLINE> for _ in range ( N + 1 ) : <NEWLINE> <INDENT> graph . append ( [ ] ) <NEWLINE> <NL> <DEDENT> for _ in range ( M ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> graph [ a ] . append ( b ) <NEWLINE> graph [ b ] . append ( a ) <NEWLINE> <NL> <DEDENT> visited = [ ] <NEWLINE> for _ in range ( N + 1 ) : <NEWLINE> <INDENT> visited . append ( False ) <NEWLINE> <NL> <NL> <DEDENT> def dfs ( dep , cur ) : <NEWLINE> <INDENT> global N , visited , graph <NEWLINE> <NL> if dep == N : <NEWLINE> <INDENT> ans += 1 <NEWLINE> return 1 <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> <DEDENT> for dist in graph [ cur ] : <NEWLINE> <INDENT> if visited [ dist ] == False : <NEWLINE> <INDENT> visited [ dist ] = True <NEWLINE> ans += dfs ( dep + 1 , dist ) <NEWLINE> visited [ dist ] = False <NEWLINE> <DEDENT> <DEDENT> return ans <NEWLINE> <NL> visited [ 1 ] = True <NEWLINE> dfs ( 1 , 1 ) <NEWLINE> print ( ans ) <NEWLINE> <DEDENT>
import itertools <NEWLINE> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> path = [ [ False ] * n for i in range ( n ) ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> a -= 1 <NEWLINE> b -= 1 <NEWLINE> path [ a ] [ b ] = True <NEWLINE> path [ b ] [ a ] = True <NEWLINE> <DEDENT> ans = 0 <NEWLINE> for i itertools . permutations ( range ( n ) , n ) : <NEWLINE> <INDENT> if i [ 0 ] == 0 : <NEWLINE> <INDENT> for j in range ( n ) : <NEWLINE> <INDENT> if j == n - 1 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> break <NEWLINE> <DEDENT> if not path [ i [ j ] ] [ i [ j + 1 ] ] : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import itertools <NEWLINE> from math import factorial as fa <NEWLINE> P = itertools . permutations ( list ( range ( n ) ) ) <NEWLINE> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> G = [ set ( ) for _ in range ( n ) ] <NEWLINE> for _ in range ( m ) : <NEWLINE> <INDENT> a , b = map ( lambda x : int ( x ) - 1 , input ( ) . split ( ) ) <NEWLINE> G [ a ] . add ( b ) <NEWLINE> G [ b ] . add ( a ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for _ in range ( fa ( n ) ) : <NEWLINE> <INDENT> p = next ( P ) <NEWLINE> if p [ 0 ] != 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> f = True <NEWLINE> for pnw , pnx in zip ( p , p [ 1 : ] ) : <NEWLINE> <INDENT> if not pnx in G [ pnw ] : <NEWLINE> <INDENT> f = False <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if f : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import itertools as it <NEWLINE> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> path = { [ ] for _ in range ( m ) } <NEWLINE> for i in range ( m ) : path [ i ] = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ls = list ( it . permutations ( range ( 1 , n + 1 ) ) ) <NEWLINE> cnt = 0 <NEWLINE> for l in ls : <NEWLINE> <INDENT> if l [ 0 ] == 1 : break <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> if [ i , i + 1 ] in path : cnt += 1 <NEWLINE> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( m ) ] <NEWLINE> <NL> c = [ i for i in range ( 2 , n + 1 ) ] <NEWLINE> b = [ ] <NEWLINE> for x in itertools . permutations ( c ) : <NEWLINE> <INDENT> b . append ( [ 1 ] + list ( x ) ) <NEWLINE> <NL> <DEDENT> cnt = 0 <NEWLINE> for x in b : <NEWLINE> <INDENT> exist = True <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> if not sorted ( x [ i : i + 2 ] ) in a : <NEWLINE> <INDENT> exist = False <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if exist : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
import itertools <NEWLINE> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> edges = { tuplec ( sorted ( map ( int , input ( ) . split ( ) ) ) ) for i in range ( M ) } <NEWLINE> ans = 0 <NEWLINE> for i in itertools . permutations ( range ( 2 , N + 1 ) , N - 1 ) : <NEWLINE> <INDENT> l = [ 1 ] + list ( i ) <NEWLINE> ans += sum ( 1 for edge in zip ( l , l [ 1 : ] ) if tuple ( sorted ( edge ) ) in edges ) == N - 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
from sys import setrecursionlimit <NEWLINE> setrecursionlimit ( 10 ** 10 ) <NEWLINE> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> P = [ [ ] for i in range ( m ) ] <COMMENT> <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> a , b = a - 1 , b - 1 <NEWLINE> P [ a ] . append ( b ) <NEWLINE> P [ b ] . append ( a ) <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> c = 0 <COMMENT> <NEWLINE> R = [ 0 for i in range ( m ) ] <COMMENT> <NEWLINE> tm = 1 <COMMENT> <NEWLINE> <NL> def all_search_dfs ( c : int , tm : int , R : list ) : <NEWLINE> <INDENT> if R [ c ] == 0 : <NEWLINE> <INDENT> R [ c ] = 1 <NEWLINE> if tm < n : <NEWLINE> <INDENT> return point_calculate ( c , tm , R ) <NEWLINE> <DEDENT> elif tm == n : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> return 0 <NEWLINE> <NL> <DEDENT> <DEDENT> def point_calculate ( c : int , tm : int , R : list ) : <NEWLINE> <COMMENT> <NL> <INDENT> p = 0 <NEWLINE> <COMMENT> <NL> for i in range ( len ( P [ c ] ) ) : <NEWLINE> <INDENT> R2 = R [ : ] <NEWLINE> <COMMENT> <NL> tmp = all_search_dfs ( P [ c ] [ i ] , tm + 1 , R2 ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> p += tmp <NEWLINE> <COMMENT> <NL> <DEDENT> return p <NEWLINE> <NL> <DEDENT> print ( all_search_dfs ( c , tm , R ) ) <NEWLINE>
N , M = map ( int , input ( ) , aplit ( ) ) <NEWLINE> <NL> path = [ [ ] for i in range ( N ) ] <NEWLINE> <NL> for _ in range ( M ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) , split ( ) ) <NEWLINE> path [ a - 1 ] , append ( b - 1 ) <NEWLINE> <INDENT> path [ b - 1 ] , append ( a - 1 ) <NEWLINE> <DEDENT> <DEDENT> vis = [ 0 for i in range ( N ) ] <NEWLINE> cnt = 0 <NEWLINE> <NL> def dfs ( now , path ) : <NEWLINE> <INDENT> global cnt <NEWLINE> <INDENT> if depth == N : cnt += 1 <NEWLINE> <DEDENT> for new in path [ now ] : <NEWLINE> <INDENT> if vis [ new ] == 0 : <NEWLINE> vis [ new ] = 1 <NEWLINE> <INDENT> dfs ( new , depth + 1 ) <NEWLINE> <INDENT> vis [ new ] = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> vis [ 0 ] = 1 <NEWLINE> dfs ( 0 , 1 ) <NEWLINE> print ( cnt ) <NEWLINE>
import itertools <NEWLINE> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> L = [ ] <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> L . append ( [ a , b ] ) <NEWLINE> <NL> <DEDENT> number = [ ] <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> number . append ( i ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> <NL> for v in itertools . permutations ( number , N ) : <NEWLINE> <INDENT> a = 0 <NEWLINE> v = list ( v ) <NEWLINE> for j in range ( N - 1 ) : <NEWLINE> <INDENT> if ( [ v [ j ] , v [ j + 1 ] ] not in L ) and ( [ v [ j + 1 ] , v [ j ] ] not in L ) : <NEWLINE> <INDENT> a = 1 <NEWLINE> <DEDENT> <DEDENT> if a == 0 and v [ 0 ] == 1 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> import itertools <NEWLINE> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> L = [ ] <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> L . append ( [ a , b ] ) <NEWLINE> <NL> <DEDENT> number = [ ] <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> number . append ( i ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> <NL> for v in itertools . permutations ( number , N ) : <NEWLINE> <INDENT> a = 0 <NEWLINE> v = list ( v ) <NEWLINE> for j in range ( N - 1 ) : <NEWLINE> <INDENT> if ( [ v [ j ] , v [ j + 1 ] ] not in L ) and ( [ v [ j + 1 ] , v [ j ] ] not in L ) : <NEWLINE> <INDENT> a = 1 <NEWLINE> <DEDENT> <DEDENT> if a == 0 and v [ 0 ] == 1 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = [ i if i % 2 == 1 else None for i in a ] <NEWLINE> if a . count ( ) % 2 == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> import sys <NEWLINE> from io import StringIO <NEWLINE> import unittest <NEWLINE> <NL> <NL> class TestClass ( unittest . TestCase ) : <NEWLINE> <INDENT> def assertIO ( self , input , output ) : <NEWLINE> <INDENT> stdout , stdin = sys . stdout , sys . stdin <NEWLINE> sys . stdout , sys . stdin = StringIO ( ) , StringIO ( input ) <NEWLINE> resolve ( ) <NEWLINE> sys . stdout . seek ( 0 ) <NEWLINE> out = sys . stdout . read ( ) [ : - 1 ] <NEWLINE> sys . stdout , sys . stdin = stdout , stdin <NEWLINE> self . assertEqual ( out , output ) <NEWLINE> <NL> <DEDENT> def test__1 ( self ) : <NEWLINE> <INDENT> input = <STRING> <NEWLINE> output = <STRING> <NEWLINE> self . assertIO ( input , output ) <NEWLINE> <NL> <DEDENT> def test__2 ( self ) : <NEWLINE> <INDENT> input = <STRING> <NEWLINE> output = <STRING> <NEWLINE> self . assertIO ( input , output ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def resolve ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> e = 0 <NEWLINE> o = 0 <NEWLINE> for a in A : <NEWLINE> <INDENT> if a % 2 == 0 : <NEWLINE> <INDENT> e += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> o += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if o % 2 == 0 : <NEWLINE> <INDENT> if ( o // 2 + e ) % 2 == 0 : <NEWLINE> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <COMMENT> <NL> <INDENT> resolve ( ) <NEWLINE> <DEDENT>
X = ( int ( x ) for x in input ( ) . split ( ) ) <NEWLINE> if X > 1200 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ) <NEWLINE> if n < 1200 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
input_line = int ( input ( ) ) <NEWLINE> <NL> if input_line >= 1200 <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
x = int , input ( ) <NEWLINE> if x < 1200 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
x = int ( inptu ( ) ) <NEWLINE> <NL> if x < 1200 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
print ( <STRING> if x = int ( input ( ) ) < 1200 else <STRING> ) <NEWLINE>
x = input ( ) <NEWLINE> if x < 1200 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
print ( <STRING> if input ( ) < 1200 else <STRING> ) <NEWLINE>
s = input ( ) <NEWLINE> a = 0 <NEWLINE> b = 0 <NEWLINE> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> a = i <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> for i in range ( len ( s ) , - 1 , - 1 ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> b = i <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( b - a + 1 ) <NEWLINE>
sample = input ( ) <NEWLINE> new = [ ] <NEWLINE> for i in sample : <NEWLINE> <INDENT> new . append ( i ) <NEWLINE> <DEDENT> if <STRING> in new : <NEWLINE> <INDENT> a_pos = list . index ( new ) <NEWLINE> <DEDENT> if <STRING> in new : <NEWLINE> <INDENT> z_pos = list . index ( new ) <NEWLINE> <DEDENT> if a_post < z_pos : <NEWLINE> <INDENT> out = new [ a_pos : ( z_pos + 1 ) ] <NEWLINE> <NL> <DEDENT> new_string = <STRING> <NEWLINE> for j in out : <NEWLINE> <INDENT> new_string += j <NEWLINE> <DEDENT> print ( len ( new_string ) ) <NEWLINE>
s = input ( ) <NEWLINE> <NL> ds = list ( s ) <NEWLINE> <NL> <NL> c1 = 0 <NEWLINE> while ds [ c1 ] != <STRING> <NEWLINE> <INDENT> c1 += 1 <NEWLINE> <NL> <DEDENT> c2 = - 1 <NEWLINE> while ds [ c2 ] != <STRING> : <NEWLINE> <INDENT> c2 -= 1 <NEWLINE> <NL> <DEDENT> print ( len ( s [ c1 : c2 ] ) ) <NEWLINE>
n = input ( ) <NEWLINE> a = n . index ( <STRING> ) <NEWLINE> n = len ( n ) - n [ : : - 1 ] . index ( <STRING> ) - 1 <NEWLINE> print ( len ( n [ a : n + 1 ] ) ) <NEWLINE>
ZABCZ <NEWLINE>
s = input ( ) <NEWLINE> a_min = 0 <NEWLINE> z_max = 0 <NEWLINE> for i in s : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> a_min = i <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> for i in s : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> z_max = i <NEWLINE> <DEDENT> <DEDENT> print ( z_max - a_min + 1 ) <NEWLINE>
s = input <NEWLINE> <NL> a = s . find ( <STRING> ) <NEWLINE> z = s . rfind ( <STRING> ) <NEWLINE> <NL> print ( z - a ) <NEWLINE>
<COMMENT> <NL> // Begin Header { { { <NEWLINE> using namespace std ; <NEWLINE> using ll = long long ; <NEWLINE> using P = pair < ll , ll > ; <NEWLINE> using Graph = vector < vector < ll >> ; <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> constexpr int INF = 0x3f3f3f3f ; <NEWLINE> const long long mod = 1e9 + 7 ; <NEWLINE> const long double PI = acos ( - 1 ) ; <NEWLINE> // } } } End Header <NEWLINE> int main ( ) { <NEWLINE> <INDENT> string s ; <NEWLINE> cin >> s ; <NEWLINE> int f1 , f2 ; <NEWLINE> rep ( i , s . length ( ) ) { <NEWLINE> <INDENT> if ( s [ i ] == <STRING> ) { <NEWLINE> <INDENT> f1 = i ; <NEWLINE> break ; <NEWLINE> <DEDENT> } <NEWLINE> <DEDENT> } <NEWLINE> rep ( i , s . length ( ) ) { <NEWLINE> <INDENT> if ( s [ i ] == <STRING> ) f2 = i ; <NEWLINE> <DEDENT> } <NEWLINE> cout << f2 - f1 + 1 << endl ; <NEWLINE> return 0 ; <NEWLINE> <DEDENT> } <NEWLINE>
s = input ( ) <NEWLINE> <NL> posA = 0 <NEWLINE> posZ = 0 <NEWLINE> <NL> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> posA = i <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> for j in range ( len ( s ) ) : <NEWLINE> <INDENT> if s [ - j - 1 ] == <STRING> : <NEWLINE> <INDENT> posZ = N - 1 - j <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( posZ - posA + 1 ) <NEWLINE>
<COMMENT> <NL> <NL> x = int ( input ( ) ) <NEWLINE> q = x // 11 <NEWLINE> r = x % 11 <NEWLINE> if r == 0 : <NEWLINE> <INDENT> ans = q * 2 <NEWLINE> <DEDENT> elif 1 <= r <= 5 : <NEWLINE> <INDENT> ans = q * 2 + 1 <NEWLINE> <DEDENT> elif 6 <= ans <= 10 : <NEWLINE> <INDENT> ans = q * 2 + 2 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
x = int ( input ( ) ) <NEWLINE> <NL> p = x // 11 <NEWLINE> q = x % 11 <NEWLINE> q2 = q - 6 <NEWLINE> <NL> if q == 0 <NEWLINE> <INDENT> print ( 2 * p ) <NEWLINE> <DEDENT> elif q2 < 0 : <NEWLINE> <INDENT> print ( 2 * p + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 2 * p + 2 ) <NEWLINE> <DEDENT>
print ( ( 2 * input ( ) - 2 ) // 11 + 1 ) <NEWLINE>
from collections import Counter <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <COMMENT> <NL> l_a = len ( a ) <NEWLINE> if ( l_a % 2 == 0 ) : <NEWLINE> <INDENT> print ( l_a - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( l_a ) <NEWLINE> <DEDENT>
import sys <NEWLINE> import math <NEWLINE> N = int ( input ( ) ) <NEWLINE> array = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> set_array = set ( array ) <NEWLINE> <NL> if not ( 3 <= N <= 10 ** 5 and N % 2 == 1 ) : sys . exit ( ) <NEWLINE> if len ( array ) == len ( list ( set_array ) ) : print ( 0 ) ; sys . exit ( ) <NEWLINE> <NL> print ( len ( list ( set_array ) ) ) if len ( list ( set_array ) ) % 2 == 1 else print ( len ( list ( set_array ) - 1 ) ) <NEWLINE>
x = input ( ) <NEWLINE> y = x % 11 <NEWLINE> if y > 0 : <NEWLINE> <INDENT> cnt = 1 <NEWLINE> if y > 6 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> <NL> <DEDENT> print ( x // 11 + cnt ) <NEWLINE>
import collections as col <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> m = col . Counter ( A ) <NEWLINE> ans = len ( m ) if m % 2 == 1 else len ( m ) - 1 <NEWLINE> print ( ans ) <NEWLINE> <NL>
import sys <NEWLINE> import numpy as np <NEWLINE> import numba <NEWLINE> from numba import njit , b1 , i4 , i8 <NEWLINE> from numba . types import Omitted <NEWLINE> <NL> read = sys . stdin . buffer . read <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> readlines = sys . stdin . buffer . readlines <NEWLINE> <NL> MOD = 1_000_000_007 <NEWLINE> <NL> @ njit ( ( i8 , i8 ) , cache = True ) <NEWLINE> def main ( N , K ) : <NEWLINE> <INDENT> K -= 1 <NEWLINE> U = 5000 <NEWLINE> C = np . zeros ( ( U , U ) , np . int64 ) <NEWLINE> C [ 0 , 0 ] = 1 <NEWLINE> for n in range ( 1 , U ) : <NEWLINE> <INDENT> C [ n ] += C [ n - 1 ] <NEWLINE> C [ n , 1 : ] += C [ n - 1 , : - 1 ] <NEWLINE> C [ n ] %= MOD <NEWLINE> <NL> <DEDENT> dp = np . zeros ( ( N + 10 , N + 10 ) , np . int64 ) <NEWLINE> dp [ 0 , 0 ] = 1 <NEWLINE> for n in range ( 1 , N + 10 ) : <NEWLINE> <INDENT> dp [ n , n ] = ( dp [ n - 1 , n - 1 ] + dp [ n - 1 , n ] ) % MOD <NEWLINE> for m in range ( n + 1 , N + 10 ) : <NEWLINE> <INDENT> dp [ n , m ] = ( dp [ n - 1 , m ] + dp [ n , m - 1 ] ) % MOD <NEWLINE> <DEDENT> <DEDENT> for n in range ( N + 9 , 0 , - 1 ) : <NEWLINE> <INDENT> dp [ n ] -= dp [ n - 1 ] <NEWLINE> dp [ n ] %= MOD <NEWLINE> <DEDENT> ans = 0 <NEWLINE> if K == N - 1 : <NEWLINE> <INDENT> return dp [ : N , N - 1 ] . sum ( ) % MOD <NEWLINE> <DEDENT> for r in range ( N - K , N + 1 ) : <NEWLINE> <INDENT> x = C [ r - 2 , N - K - 2 ] <NEWLINE> a = N - r <NEWLINE> b = K - a <NEWLINE> if b == 0 : <NEWLINE> <INDENT> x = x * ( dp [ : a + 1 , a ] . sum ( ) % MOD ) % MOD <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x *= ( dp [ 1 : a + 2 , a + 1 ] * C [ b - 1 : a + b , b - 1 ] [ : : - 1 ] % <NEWLINE> <INDENT> MOD ) . sum ( ) % MOD <NEWLINE> <DEDENT> x %= MOD <NEWLINE> <DEDENT> ans += x <NEWLINE> <DEDENT> ans %= MOD <NEWLINE> for i in range ( N - K - 2 ) : <NEWLINE> <INDENT> ans = ans * 2 % MOD <NEWLINE> <DEDENT> return ans % MOD <NEWLINE> <NL> <DEDENT> N , K = map ( int , read ( ) . split ( ) ) <NEWLINE> print ( main ( N , K ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = [ map ( int , input ( ) . split ( ) ) for _ in range ( N ) ] <NEWLINE> <NL> r = 0 <NEWLINE> for i in range ( N - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> a , b = A [ i ] <NEWLINE> a += r <NEWLINE> r += - ( - a // b ) * A [ i ] [ 1 ] - a <NEWLINE> <DEDENT> print ( r ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> Array = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> Array . append ( tuple ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> <DEDENT> res = 0 <NEWLINE> for i in reversed ( range ( N ) ) : <NEWLINE> <INDENT> a , b = Array [ i ] <NEWLINE> a += res <NEWLINE> res + = b - a % b <NEWLINE> <DEDENT> print ( res ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = [ ] <NEWLINE> b = [ ] <NEWLINE> for j in range ( n ) : <NEWLINE> <INDENT> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a . append ( l [ 0 ] ) <NEWLINE> b . append ( l [ 1 ] ) <NEWLINE> c = 0 <NEWLINE> <DEDENT> for i in range ( n - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> if ( a [ i ] + c ) % b [ i ] != 0 : <NEWLINE> <INDENT> c += ( b [ i ] - ( a [ i ] + c ) % b [ i ] ) <NEWLINE> <DEDENT> <DEDENT> print ( c ) <NEWLINE>
import sys <NEWLINE> import numpy as np <NEWLINE> <NL> read = sys . stdin . buffer . read <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> readlines = sys . stdin . buffer . readlines <NEWLINE> <NL> MOD = 10 ** 9 + 7 <NEWLINE> <NL> def main ( N , A , B , S ) : <NEWLINE> <INDENT> if A > B : <NEWLINE> <INDENT> A , B = B , A <NEWLINE> <DEDENT> if np . max ( S [ 2 : ] - S [ : - 2 ] ) < A : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> INF = 1 << 62 <NEWLINE> S = np . append ( S , INF ) <NEWLINE> <COMMENT> <NL> X = np . zeros_like ( S ) <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> if S [ i ] - S [ i - 1 ] >= A : <NEWLINE> <INDENT> X [ i ] = X [ i - 1 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> X [ i ] = i <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> Y = np . searchsorted ( S , S - B , side = <STRING> ) - 1 <NEWLINE> dp = np . zeros_like ( S ) <NEWLINE> dp_cum = np . zeros_like ( S ) <NEWLINE> <NL> dp [ 0 ] = 1 <NEWLINE> dp_cum [ 0 ] = 1 <NEWLINE> for n in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> if X [ n - 1 ] == 0 : <NEWLINE> <COMMENT> <NL> <INDENT> dp [ n ] = 1 <NEWLINE> <COMMENT> <NL> <DEDENT> l , r = max ( 0 , X [ n - 1 ] - 1 ) , min ( n - 1 , Y [ n ] ) <NEWLINE> if l <= r : <NEWLINE> <INDENT> dp [ n ] += dp_cum [ r ] - dp_cum [ l ] + dp [ l ] <NEWLINE> <DEDENT> dp [ n ] %= MOD <NEWLINE> dp_cum [ n ] = ( dp_cum [ n - 1 ] + dp [ n ] ) % MOD <NEWLINE> <DEDENT> return dp [ - 1 ] <NEWLINE> <NL> <DEDENT> signature = <STRING> <NEWLINE> if sys . argv [ - 1 ] == <STRING> : <NEWLINE> <INDENT> from numba . pycc import CC <NEWLINE> cc = CC ( <STRING> ) <NEWLINE> cc . export ( <STRING> , signature ) ( main ) <NEWLINE> cc . compile ( ) <NEWLINE> <NL> <DEDENT> from my_module import main <NEWLINE> <NL> N , A , B = map ( int , readline ( ) . split ( ) ) <NEWLINE> S = np . array ( read ( ) . split ( ) , np . int64 ) <NEWLINE> <NL> print ( main ( N , A , B , S ) ) <NEWLINE>
a = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> b = a [ 0 ] * a [ 1 ] <NEWLINE> c = a [ 2 ] * a [ 3 ] <NEWLINE> A = [ b , c ] <NEWLINE> print ( max ( A ) ) <NEWLINE>
<NL> def main ( ) : <NEWLINE> <INDENT> a , b , c , d = map ( int , input ( ) ) <NEWLINE> if a * b >= c * d : <NEWLINE> <INDENT> print ( a * b ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( c * d ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
a , b , c , b = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( max ( a * b , c * d ) ) <NEWLINE>
a , b , c , d = int ( input ( ) . split ( ) ) <NEWLINE> x = a * b <NEWLINE> y = c * d <NEWLINE> if x == y : <NEWLINE> <INDENT> print ( x ) <NEWLINE> <DEDENT> elif x > y : <NEWLINE> <INDENT> print ( x ) <NEWLINE> <DEDENT> elif y > x : <NEWLINE> <INDENT> print ( y ) <NEWLINE> <DEDENT>
a , , b , c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( max ( a * b , c * d ) ) <NEWLINE>
<COMMENT> <NL> <NL> <COMMENT> <NL> A = int ( input ( ) ) <NEWLINE> B = int ( input ( ) ) <NEWLINE> C = int ( input ( ) ) <NEWLINE> D = int ( input ( ) ) <NEWLINE> <NL> <COMMENT> <NL> <NL> menseki1 = A * B <NEWLINE> print ( menseki1 ) <NEWLINE> menseki2 = C * D <NEWLINE> print ( menseki2 ) <NEWLINE> <NL> if menseki1 > menseki2 : <NEWLINE> <INDENT> print ( menseki1 ) <NEWLINE> <NL> <DEDENT> elif menseki1 < menseki2 : <NEWLINE> <INDENT> print ( menseki2 ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> print ( menseki1 ) <NEWLINE> <DEDENT>
S1 = int ( input ( ) ) <NEWLINE> S2 = int ( input ( ) ) <NEWLINE> <NL> if S1 > S2 : <NEWLINE> <INDENT> print ( S1 ) <NEWLINE> <DEDENT> elif S1 == S2 : <NEWLINE> <INDENT> print ( S1 * S2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( S2 ) <NEWLINE> <DEDENT>
<COMMENT> <NL> A = int ( input ( ) ) <NEWLINE> B = int ( input ( ) ) <NEWLINE> C = int ( input ( ) ) <NEWLINE> D = int ( input ( ) ) <NEWLINE> if A * B > c * D : <NEWLINE> <INDENT> print ( A * B ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( C * D ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> x = 0 <NEWLINE> for i in s : <NEWLINE> <INDENT> if i = <STRING> : <NEWLINE> <INDENT> x = max ( x , x + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = max ( x , x - 1 ) <NEWLINE> <DEDENT> <DEDENT> print ( x ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S = input ( ) . split ( ) <NEWLINE> x = 0 <NEWLINE> <NL> for N in S : <NEWLINE> <INDENT> if S [ N ] == <STRING> : <NEWLINE> <INDENT> x += 1 <NEWLINE> <DEDENT> elif S [ N ] == <STRING> : <NEWLINE> <INDENT> x -= 1 <NEWLINE> <DEDENT> <DEDENT> print ( x ) <NEWLINE>
s = input ( ) <NEWLINE> <NL> for c in s : <NEWLINE> <INDENT> x += 1 if c == <STRING> else - 1 <NEWLINE> <NL> <DEDENT> print ( max ( x ) ) <NEWLINE>
num = int ( input ( ) ) <NEWLINE> given = input ( ) <NEWLINE> new = given . split ( ) <NEWLINE> x = 0 <NEWLINE> max = 0 <NEWLINE> for i in range ( num ) : <NEWLINE> <INDENT> if new [ i ] == <STRING> : <NEWLINE> <INDENT> x -= 1 <NEWLINE> <DEDENT> if new [ i ] == <STRING> : <NEWLINE> <INDENT> x += 1 <NEWLINE> <DEDENT> if max < x : <NEWLINE> <INDENT> max = x <NEWLINE> <DEDENT> <DEDENT> print ( max ) <NEWLINE>
<INDENT> = int ( input ( ) ) <NEWLINE> <DEDENT> s = input ( ) <NEWLINE> x = 0 <NEWLINE> l = [ 0 ] <NEWLINE> for a in s : <NEWLINE> <INDENT> if a == <STRING> : <NEWLINE> <INDENT> x = x + 1 <NEWLINE> l . append ( x ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = x - 1 <NEWLINE> l . append ( x ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( max ( l ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> a = 0 <NEWLINE> sum_a = 0 <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> if S [ i ] == <STRING> : <NEWLINE> <INDENT> sum_a += 1 <NEWLINE> a = max ( a , sum_a ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> sum_a - = 1 <NEWLINE> <DEDENT> <DEDENT> print ( a ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> count = 0 <NEWLINE> count_list = [ ] <NEWLINE> <NL> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> count += 1 <NEWLINE> count_list . append ( count ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> count -= 1 <NEWLINE> count_list . append ( count ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( max ( count_list , 0 ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> x = 0 <NEWLINE> length = len ( S ) <NEWLINE> List = [ 0 ] <NEWLINE> for i in range ( length ) : <NEWLINE> <INDENT> if ( S [ i ] == I ) : <NEWLINE> <INDENT> x += 1 <NEWLINE> List . append ( x ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x -= 1 <NEWLINE> List . append ( x ) <NEWLINE> <DEDENT> <DEDENT> print ( max ( List ) ) <NEWLINE>
import collections <NEWLINE> n = int ( input ( ) ) <NEWLINE> <NL> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> t *= i <NEWLINE> <DEDENT> def prime_factorize ( n ) : <NEWLINE> <INDENT> a = [ ] <NEWLINE> while n % 2 == 0 : <NEWLINE> <INDENT> a . append ( 2 ) <NEWLINE> n //= 2 <NEWLINE> <DEDENT> f = 3 <NEWLINE> while f * f <= n : <NEWLINE> <INDENT> if n % f == 0 : <NEWLINE> <INDENT> a . append ( f ) <NEWLINE> n //= f <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> f += 2 <NEWLINE> <DEDENT> <DEDENT> if n != 1 : <NEWLINE> <INDENT> a . append ( n ) <NEWLINE> <DEDENT> return a <NEWLINE> <NL> <DEDENT> c = collections . Counter ( prime_factorize ( t ) ) <NEWLINE> ans = 1 <NEWLINE> for _ , v in c . items ( ) : <NEWLINE> <INDENT> ans *= ( v + 1 ) <NEWLINE> <DEDENT> print ( ans % ( 10 ** 9 + 7 ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> p = 10 ** 9 + 7 <NEWLINE> <NL> def primeryNum ( n ) : <NEWLINE> <INDENT> n_ = int ( n ** 0.5 ) <NEWLINE> ary = list ( range ( n + 1 ) ) <NEWLINE> ary [ 1 ] = 0 <NEWLINE> for a in ary : <NEWLINE> <INDENT> if a > n_ : break <NEWLINE> elif a == 0 : continue <NEWLINE> <NL> for i in range ( a * 2 , n + 1 , a ) : <NEWLINE> <INDENT> ary [ i ] = 0 <NEWLINE> <DEDENT> <DEDENT> return ary <NEWLINE> <NL> <DEDENT> primeryN = primeryNum ( N ) <NEWLINE> divN = [ 0 ] * N <NEWLINE> for pn in primeryN : <NEWLINE> <INDENT> if pn == 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> i = 1 <NEWLINE> cnt = 0 <NEWLINE> while ( pn ** i < N ) : <NEWLINE> <INDENT> cnt += ( N // pn ** i ) <NEWLINE> i += 1 <NEWLINE> <DEDENT> divN [ pn ] = cnt <NEWLINE> <NL> <DEDENT> ans = 1 <NEWLINE> for d in divN : <NEWLINE> <INDENT> if d == 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> ans = ( ans * ( d + 1 ) ) % p <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> p = [ 1 for i in range ( 10000 ) ] <NEWLINE> p [ 0 ] = 0 <NEWLINE> p [ 1 ] = 0 <NEWLINE> for i in range ( 2 , n + 1 ) : <NEWLINE> <INDENT> if p [ i ] == 1 : <NEWLINE> <INDENT> for j in range ( i * i , n + 1 , i ) : <NEWLINE> <INDENT> p [ j ] = 0 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> ans = 1 <NEWLINE> for i in range ( 2 , n + 1 ) : <NEWLINE> <INDENT> if p [ i ] : <NEWLINE> <INDENT> c = 0 <NEWLINE> k = i <NEWLINE> while n // k > 0 : <NEWLINE> <INDENT> c = c + ( n // k ) % m <NEWLINE> k = k * k <NEWLINE> <DEDENT> ans = ( ans * ( ( c + 1 ) % m ) ) % m <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <NL> <NL>
MOD = 10 ** 9 + 7 <NEWLINE> memo = [ 0 ] * 10000 <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> <NL> def primeLst ( k ) : <NEWLINE> <INDENT> acc = [ ] <NEWLINE> if k == 1 : <NEWLINE> <INDENT> return acc <NEWLINE> <DEDENT> f = 2 <NEWLINE> while f * f <= k : <NEWLINE> <INDENT> if k % f == 0 : <NEWLINE> <INDENT> acc . append ( f ) <NEWLINE> k //= f <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> f += 1 <NEWLINE> <DEDENT> <DEDENT> if k != 1 : <NEWLINE> <INDENT> acc . append ( k ) <NEWLINE> <DEDENT> return acc <NEWLINE> <NL> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> l = primeLst ( i + 1 ) <NEWLINE> for x in l : <NEWLINE> <INDENT> memo [ x ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> res = 1 <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> res *= memo [ i + 1 ] + 1 <NEWLINE> res %= MOD <NEWLINE> <NL> <DEDENT> print ( acc ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> ls = [ 0 ] + [ 0 ] * N <NEWLINE> couterls = collections . Counter ( ls ) <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> for j in range ( 2 , N + 1 ) : <NEWLINE> <INDENT> if i % j == 0 : <NEWLINE> <INDENT> while i % j == 0 : <NEWLINE> <INDENT> couterls [ j ] += 1 <NEWLINE> i = i // j <NEWLINE> <DEDENT> <DEDENT> elif i == 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> <DEDENT> <DEDENT> ans = 1 <NEWLINE> couterls . pop ( 0 ) <NEWLINE> for i in couterls . values ( ) : <NEWLINE> <INDENT> ans = ( ans * ( i + 1 ) ) % ( 10 ** 9 + 7 ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
N , A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> X = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> d = X [ i ] - X [ i - 1 ] <NEWLINE> if d * A > B : <NEWLINE> <INDENT> ans += B <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += d * A <NEWLINE> <DEDENT> <DEDENT> print ( ans <NEWLINE>
l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> dx = a * ( l [ i + 1 ] - l [ i ] ) <NEWLINE> if b < dx : <NEWLINE> <INDENT> ans += b <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += dx <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> <COMMENT> <NL> <NL> <NL> def get_prime ( N , prime ) : <NEWLINE> <INDENT> if N < 2 : <NEWLINE> <INDENT> return { 1 : 1 } <NEWLINE> <NL> <DEDENT> i = 2 <NEWLINE> while i * i <= N : <NEWLINE> <INDENT> while N % i == 0 : <NEWLINE> <INDENT> if i in prime . keys ( ) : <NEWLINE> <INDENT> prime [ i ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> prime [ i ] = 1 <NEWLINE> <DEDENT> N = N // i <NEWLINE> <DEDENT> i += 1 <NEWLINE> <DEDENT> if N != 1 : <NEWLINE> <INDENT> prime [ N ] = 1 <NEWLINE> <DEDENT> return prime <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) . strip ( ) ) <NEWLINE> div_table = [ 1 ] * ( N + 1 ) <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> ans = 0 <NEWLINE> for i in range ( 2 , N + 1 ) : <NEWLINE> <INDENT> for j in range ( i , N + 1 , i ) : <NEWLINE> <INDENT> div_table [ j ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> prime = dict ( ) <NEWLINE> prime [ 1 ] = 1 <NEWLINE> <NL> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> if div_table [ i ] == 2 : <NEWLINE> <INDENT> prime = get_prime ( i , prime ) <NEWLINE> <DEDENT> <DEDENT> ans = 1 <NEWLINE> for k , v in prime : <NEWLINE> <INDENT> ans *= v <NEWLINE> ans %= MOD <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n , a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> x = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , n ) : ans += min ( ( x [ i + 1 ] - x [ i ] ) * a , b ) <NEWLINE> print ( ans ) <NEWLINE>
a <NEWLINE>
print ( * list [ input ( ) . split ( <STRING> ) ] ) <NEWLINE>
<COMMENT> <NL> input = input ( ) <NEWLINE> <NL> <COMMENT> <NL> exec ( <STRING> + input + <STRING> ) <NEWLINE> <NL> <COMMENT> <NL> print ( lst [ 0 ] , lst [ 1 ] , lst [ 2 ] , sep = <STRING> ) <NEWLINE>
s = input ( ) <NEWLINE> print ( s . replace ( <STRING> , <STRING> ) <NEWLINE>
print ( input ( ) . replace ( <STRING> , <STRING> ) <NEWLINE>
s = input ( ) <NEWLINE> <NL> s [ 5 ] = <STRING> <NEWLINE> s [ 13 ] = <STRING> <NEWLINE> <NL> print ( s ) <NEWLINE>
A , B , C = input ( ) . split ( ) <NEWLINE> print ( A , B , C ) <NEWLINE>
x , y , z = input . split ( <STRING> ) <NEWLINE> <NL> print ( x , y , z ) <NEWLINE>
a , b , c = input ( ) , split ( <STRING> ) <NEWLINE> print ( a , b , c ) <NEWLINE>
s = input ( ) <NEWLINE> print ( s . split ( , ) ) <NEWLINE>
x , y , z = map ( input ( ) . split ( , ) ) <NEWLINE> print ( x y z ) <NEWLINE>
print ( * input ( ) . sep ( <STRING> ) ) <NEWLINE>
x , y , z = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( z , x , y ) <NEWLINE>
pritn ( input ( ) . replace ( <STRING> , <STRING> ) ) <NEWLINE>
x , y , z = input ( ) . split <NEWLINE> print ( x , y , z ) <NEWLINE>
x , y , z = int ( ) . split ( <STRING> ) <NEWLINE> print ( x , y , z ) <NEWLINE>
s = input ( ) <NEWLINE> return <STRING> . join ( s . split ( <STRING> ) ) <NEWLINE>
a , b , c = input ( ) . split ( , ) <NEWLINE> print ( a , b , c ) <NEWLINE>
import sys <NEWLINE> <NL> k , s = map ( int , sys . stdin . buffer . readline ( ) . split ( <STRING> ) ) <NEWLINE> <NL> result = 0 <NEWLINE> <NL> for x in range ( k + 1 ) : <NEWLINE> <INDENT> for y in range ( min ( s - x + 1 , k + 1 ) ) : <NEWLINE> <INDENT> z = s - x - y <NEWLINE> if z < 0 : continue <NEWLINE> if z <= k : <NEWLINE> <INDENT> result += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( result ) <NEWLINE>
K , S = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> count = 0 <NEWLINE> for i in range ( K + 1 ) : <NEWLINE> <INDENT> for j in range ( K + 1 ) : <NEWLINE> <INDENT> if 0 <= S - ( i + j ) <= K <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
k , s = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> asn = o <NEWLINE> <NL> for i in range ( k + 1 ) : <NEWLINE> <INDENT> for j in range ( k + 1 ) : <NEWLINE> <INDENT> if 0 <= s - i - j <= k : ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
K , S = map ( int , input ( ) . split ( ) ) <NEWLINE> count = 0 <NEWLINE> for x in range ( K + 1 ) : <NEWLINE> <INDENT> for y in range ( K + 1 ) : <NEWLINE> <INDENT> if S - x - y <= K : <NEWLINE> <INDENT> conut += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
k , s = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( len ( [ z for x in range ( k + 1 ) for y in range ( k + 1 ) if 0 <= s - x - y <= k ] ) ) <NEWLINE>
x = y = S // 3 + 1 <NEWLINE> z = S - x - y <NEWLINE> if z < y : <NEWLINE> <INDENT> x = z <NEWLINE> z = y <NEWLINE> <DEDENT> while 0 <= x <= y and 0 <= y <= K and y <= z <= K : <NEWLINE> <INDENT> while 0 <= x and z <= K : <NEWLINE> <INDENT> if x == y == z : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> elif x == y or y == z : <NEWLINE> <INDENT> ans += 3 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += 6 <NEWLINE> <DEDENT> x -= 1 <NEWLINE> z += 1 <NEWLINE> <DEDENT> y += 1 <NEWLINE> x = y <NEWLINE> z = S - x - y <NEWLINE> if z < y : <NEWLINE> <INDENT> x = z <NEWLINE> z = y <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
K , S = map ( int , input ( ) split ( ) ) <NEWLINE> <NL> c = 0 <NEWLINE> for i in range ( K + 1 ) : <NEWLINE> <INDENT> for j in range ( K + 1 ) : <NEWLINE> <INDENT> z = S - i - j <NEWLINE> if 0 <= z and z <= K : <NEWLINE> <INDENT> c += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( c ) <NEWLINE>
K , S = map ( int , input ( ) . split ( ) ) <NEWLINE> count = 0 <NEWLINE> <NL> for i in range ( K + 1 ) : <NEWLINE> <INDENT> for j in range ( K + 1 ) : <NEWLINE> <INDENT> if 0 <= S - i - j <= K : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( count <NEWLINE>
K , S = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> ans = 0 <NEWLINE> for x in range ( K + 1 ) : <NEWLINE> <INDENT> for y in range ( K + 1 ) : <NEWLINE> <INDENT> if S - x - y = < K : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
s , k = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( len ( [ z for x in range ( 0 , k + 1 ) for y in range ( 0 , k + 1 ) if 0 <= s - x - y <= k ] ) ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 5 ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> def process ( ) : <NEWLINE> <INDENT> k , s = map ( int , readline ( ) . rstrip ( ) . split ( ) ) <NEWLINE> cnt = 0 <NEWLINE> <NL> for i in range ( 0 , k + 1 ) : <NEWLINE> <INDENT> for j in range ( 0 , k + 1 ) : <NEWLINE> <INDENT> z = s - ( i + j ) <NEWLINE> if z >= 0 and z <= k : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> return cnt <NEWLINE> <NL> <NL> <NL> <COMMENT> <NL> <DEDENT> print ( process ( ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> A_test = sorted ( list ( set ( A ) ) ) <NEWLINE> <NL> if N % 2 == 1 : <NEWLINE> <INDENT> judge = [ i for i in range ( 0 , N , 2 ) ] <NEWLINE> if ( A_test == judge ) and ( A . count ( 0 ) == 1 ) : <NEWLINE> <INDENT> ans = 2 ** ( N // 2 ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> judge = [ i for i in range ( 1 , N , 2 ) ] <NEWLINE> if A_test == judge : <NEWLINE> <INDENT> ans = 2 ** ( N // 2 ) <NEWLINE> <NL> <DEDENT> <DEDENT> ans = ans % ( 10 ** 9 + 7 ) <NEWLINE> print ( ans ) <NEWLINE>
d = { 0 : <STRING> , 1 : <STRING> , 2 : <STRING> , 3 : <STRING> } <NEWLINE> dirc = [ dx , dy , dx , dy ] <NEWLINE> <NL> def path ( sign , x , y , z , w ) : <NEWLINE> <INDENT> return d [ sign + 1 ] * abs ( z - x ) + d [ sign + 2 ] * abs ( y - w ) <NEWLINE> <NL> <DEDENT> s = <STRING> <NEWLINE> s += <STRING> <NEWLINE> s += path ( - 1 , sx + 1 , sy , tx , ty - 1 ) <NEWLINE> s += <STRING> <NEWLINE> s += path ( 1 , tx , ty + 1 , sx - 1 , sy ) <NEWLINE> s += <STRING> <NEWLINE> s += path ( - 1 , sx , sy - 1 , tx + 1 , ty ) <NEWLINE> s += <STRING> <NEWLINE> s += path ( 1 , tx - 1 , ty , sx , sy + 1 ) <NEWLINE> s += <STRING> <NEWLINE> print ( s ) <NEWLINE>
sx , sy , tx , ty = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> ans = <STRING> <NEWLINE> <NL> ans += <STRING> * ( ty - sy ) + <STRING> * ( tx - sx ) <NEWLINE> ans += <STRING> * ( ty - sy ) + <STRING> * ( tx - sx ) <NEWLINE> ans += <STRING> + <STRING> * ( ty - sy + 1 ) + <STRING> * ( tx - sx + 1 ) + <STRING> <NEWLINE> ans += <STRING> + <STRING> * ( ty - sy + 1 ) + <STRING> * ( tx - sx + 1 ) + <STRING> <NEWLINE> print ( ans ) sx , sy , tx , ty = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> ans = <STRING> <NEWLINE> <NL> ans += <STRING> * ( ty - sy ) + <STRING> * ( tx - sx ) <NEWLINE> ans += <STRING> * ( ty - sy ) + <STRING> * ( tx - sx ) <NEWLINE> ans += <STRING> + <STRING> * ( ty - sy + 1 ) + <STRING> * ( tx - sx + 1 ) + <STRING> <NEWLINE> ans += <STRING> + <STRING> * ( ty - sy + 1 ) + <STRING> * ( tx - sx + 1 ) + <STRING> <NEWLINE> print ( ans ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> INF = 10 ** 18 <NEWLINE> d = [ [ INF ] * n for _ in range ( n ) ] <NEWLINE> for i in range ( n ) : d [ i ] [ i ] = 0 <NEWLINE> a = [ 0 ] * m <NEWLINE> b = [ 0 ] * m <NEWLINE> c = [ 0 ] * m <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> a -= 1 <NEWLINE> b -= 1 <NEWLINE> a [ i ] = a <NEWLINE> b [ i ] = b <NEWLINE> c [ i ] = c <NEWLINE> d [ a ] [ b ] = c <NEWLINE> d [ b ] [ a ] = c <NEWLINE> <NL> <DEDENT> for k in range ( n ) : <NEWLINE> <INDENT> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( n ) : <NEWLINE> <INDENT> d [ i ] [ j ] = min ( d [ i ] [ j ] , d [ i ] [ k ] + d [ k ] [ j ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> if d [ a [ i ] ] [ b [ i ] ] < c [ i ] : ans += 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> import sys <NEWLINE> <NL> def solve ( N : int , M : int , a : <STRING> , b : <STRING> , c : <STRING> ) : <NEWLINE> <INDENT> import numpy as np <NEWLINE> from scipy . sparse import csr_matrix <NEWLINE> from scipy . sparse . csgraph import floyd_warshall <NEWLINE> omat = csr_matrix ( ( c , ( a , b ) ) , shape = ( N + 1 , N + 1 ) , dtype = np . int32 , directed = False ) <NEWLINE> smat = floyd_warshall ( omat ) <NEWLINE> return ( ( omat - smat ) > 0 ) . sum ( ) // 2 <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> def iterate_tokens ( ) : <NEWLINE> <INDENT> for line in sys . stdin : <NEWLINE> <INDENT> for word in line . split ( ) : <NEWLINE> <INDENT> yield word <NEWLINE> <DEDENT> <DEDENT> <DEDENT> tokens = iterate_tokens ( ) <NEWLINE> N = int ( next ( tokens ) ) <COMMENT> <NEWLINE> M = int ( next ( tokens ) ) <COMMENT> <NEWLINE> a = [ int ( ) ] * ( M ) <COMMENT> <NEWLINE> b = [ int ( ) ] * ( M ) <COMMENT> <NEWLINE> c = [ int ( ) ] * ( M ) <COMMENT> <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> a [ i ] = int ( next ( tokens ) ) <NEWLINE> b [ i ] = int ( next ( tokens ) ) <NEWLINE> c [ i ] = int ( next ( tokens ) ) <NEWLINE> <DEDENT> print ( solve ( N , M , a , b , c ) ) <NEWLINE> <NL> <DEDENT> def test ( ) : <NEWLINE> <INDENT> import doctest <NEWLINE> doctest . testmod ( ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <COMMENT> <NL> <INDENT> main ( ) <NEWLINE> <DEDENT>
x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> if abs ( x ) , abs ( y ) > pow ( 10 , 9 ) : <NEWLINE> <INDENT> exit ( ) <NEWLINE> <DEDENT> s = abs ( y ) - abs ( x ) <NEWLINE> buttona = s <NEWLINE> buttonb = 0 <NEWLINE> if y < 0 : <NEWLINE> <INDENT> buttonb += 1 <NEWLINE> <DEDENT> if x < 0 : <NEWLINE> <INDENT> buttonb += 1 <NEWLINE> <DEDENT> print ( buttona + buttonb ) <NEWLINE>
<COMMENT> <NL> <NL> def func ( x , y ) : <NEWLINE> <INDENT> if y >= x : <NEWLINE> <INDENT> if x >= 0 : <NEWLINE> <INDENT> return y - x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if y > 0 : <NEWLINE> <INDENT> if abs ( x ) > abs ( y ) : <NEWLINE> <INDENT> return 1 - x - y <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return 1 + x + y <NEWLINE> <DEDENT> <DEDENT> elif y <= 0 : <NEWLINE> <INDENT> return y - x <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if x >= 0 : <NEWLINE> <INDENT> if y < 0 : <NEWLINE> <INDENT> if abs ( x ) > abs ( y ) : <NEWLINE> <INDENT> return 1 + x + y <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return 1 - x - y <NEWLINE> <DEDENT> <DEDENT> elif y == 0 or y == 1 : <NEWLINE> <INDENT> return x + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if abs ( x ) > abs ( y ) : <NEWLINE> <INDENT> return 1 + x + y <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return 1 + y - x <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> return 2 + x - y <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( f ( x , y ) ) <NEWLINE>
def main2 ( ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> delta = abs ( abs ( x ) - abs ( y ) ) <NEWLINE> <NL> c1 = delta + 0 + 0 <NEWLINE> c2 = delta + 0 + 1 <NEWLINE> c3 = delta + 1 + 0 <NEWLINE> c4 = delta + 1 + 1 <NEWLINE> <NL> print ( min ( c1 , c2 , c3 , c4 ) ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( min ( max ( y - x , x - y + 2 ) , abs ( x + y ) + 1 ) <NEWLINE> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> ax = abs ( x ) <NEWLINE> ay = abs ( y ) <NEWLINE> if ax == ay and x != y : <NEWLINE> <INDENT> a = 1 <NEWLINE> <DEDENT> elif x > y and 0 < y : <NEWLINE> <INDENT> a = ax - ay + 2 <NEWLINE> <DEDENT> elif x > y and y = 0 : <NEWLINE> <INDENT> a = ax - ay + 1 <NEWLINE> <DEDENT> elif x > y and 0 > y : <NEWLINE> <INDENT> if ay > ax and x >= 0 : <NEWLINE> <INDENT> a = ay - ax + 1 <NEWLINE> <DEDENT> elif ay > ax and x < 0 : <NEWLINE> <INDENT> a = ay - ax + 2 <NEWLINE> <DEDENT> elif ax > ay : <NEWLINE> <INDENT> a = ax - ay + 1 <NEWLINE> <DEDENT> <DEDENT> elif y > x and x < 0 and ay > ax : <NEWLINE> <INDENT> a = ay - ax + 1 <NEWLINE> <DEDENT> elif y > x and x < 0 and y > 0 and ax > ay : <NEWLINE> <INDENT> a = ax - ay + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a = y - x <NEWLINE> <DEDENT> print ( a ) <NEWLINE>
x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> d = abs ( abs ( x ) - abs ( y ) ) <NEWLINE> if 0 <= x < y or x < y <= 0 : <NEWLINE> <INDENT> print ( d ) <NEWLINE> <DEDENT> elif y <= 0 <= x or x < 0 < y : <NEWLINE> <INDENT> print ( d + 1 ) <NEWLINE> <DEDENT> else <NEWLINE> <INDENT> print ( d + 2 ) <NEWLINE> <DEDENT>
import sys <NEWLINE> import numpy as np <NEWLINE> <NL> read = sys . stdin . buffer . read <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> readlines = sys . stdin . buffer . readlines <NEWLINE> <NL> @ njit ( <STRING> , cache = True ) <NEWLINE> def main ( N , K , A ) : <NEWLINE> <INDENT> B = np . maximum ( A , 0 ) <NEWLINE> Acum = np . zeros ( len ( A ) + 1 , np . int64 ) <NEWLINE> Bcum = np . zeros ( len ( A ) + 1 , np . int64 ) <NEWLINE> Acum [ 1 : ] = np . cumsum ( A ) <NEWLINE> Bcum [ 1 : ] = np . cumsum ( B ) <NEWLINE> ret = - ( 10 ** 18 ) <NEWLINE> for l in range ( N - K + 1 ) : <NEWLINE> <INDENT> r = l + K <NEWLINE> sum1 = Bcum [ l ] <NEWLINE> sum2 = Bcum [ - 1 ] - Bcum [ r ] <NEWLINE> sum3 = Acum [ r ] - Acum [ l ] <NEWLINE> x = sum1 + sum2 + max ( sum3 , 0 ) <NEWLINE> ret = max ( ret , x ) <NEWLINE> <DEDENT> return ret <NEWLINE> <NL> <DEDENT> N , K = map ( int , readline ( ) . split ( ) ) <NEWLINE> A = np . array ( read ( ) . split ( ) , np . int64 ) <NEWLINE> <NL> print ( main ( N , K , A ) ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> tmp = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if i < K : <NEWLINE> <INDENT> tmp += a [ i ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if a [ i ] > 0 : <NEWLINE> <INDENT> ans += a [ i ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> ans += max ( 0 , tmp ) <NEWLINE> <NL> ans2 = 0 <NEWLINE> tmp = 0 <NEWLINE> for i in range ( N - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> if ans < N - K : <NEWLINE> <INDENT> if a [ i ] > 0 : <NEWLINE> <INDENT> ans2 += a [ i ] <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> tmp += a [ i ] <NEWLINE> <DEDENT> <DEDENT> ans2 += max ( 0 , tmp ) <NEWLINE> print ( max ( ams2 , ans ) ) <NEWLINE>
a = input ( ) <NEWLINE> if a [ 1 ] == <STRING> : <NEWLINE> <INDENT> print ( int ( a [ 0 ] ) + int ( a [ 2 ] ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( int ( a [ 0 ] ) - int ( a [ 2 ] ) ) <NEWLINE> <DEDENT>
A , c , B = input ( ) . split ( ) <NEWLINE> if c == <STRING> : <NEWLINE> <INDENT> print ( int ( A ) + int ( B ) ) : <NEWLINE> <DEDENT> elif c == <STRING> : <NEWLINE> <INDENT> print ( int ( A ) - int ( B ) ) <NEWLINE> <DEDENT>
a , o , b = input ( ) . split ( ) <NEWLINE> if o = <STRING> : <NEWLINE> <INDENT> print ( int ( a ) + int ( b ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( int ( a ) - int ( b ) ) <NEWLINE> <DEDENT>
a , op , b = map ( str , input ( ) . split ( ) ) <NEWLINE> if op = <STRING> : <NEWLINE> <INDENT> print ( int ( a ) + int ( b ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( int ( a ) - int ( b ) ) <NEWLINE> <DEDENT>
a , op , b = input ( ) . split ( ) <NEWLINE> a = int ( a ) <NEWLINE> b = int ( b ) <NEWLINE> if op = <STRING> : <NEWLINE> <INDENT> print ( a + b ) <NEWLINE> <DEDENT> if op = <STRING> : <NEWLINE> <INDENT> print ( a - b ) <NEWLINE> <DEDENT>
a , op , b = imput ( ) . split ( ) <NEWLINE> a = int ( a ) <NEWLINE> b = int ( b ) <NEWLINE> if op == <STRING> : <NEWLINE> <INDENT> print ( a + b ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( a - b ) <NEWLINE> <DEDENT>
A , op , B = map ( input ( ) . split ( ) ) <NEWLINE> A = int ( A ) <NEWLINE> B = int ( B ) <NEWLINE> <NL> if op == <STRING> : <NEWLINE> <INDENT> print ( A + B ) <NEWLINE> <DEDENT> if op == <STRING> : <NEWLINE> <INDENT> print ( A - B ) <NEWLINE> <DEDENT>
a , op , b = map ( str , input ( ) , split ( ) ) <NEWLINE> if op == <STRING> : <NEWLINE> <INDENT> print ( int ( a ) + int ( b ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( int ( a ) - int ( b ) ) <NEWLINE> <DEDENT>
a , b , c = map ( str , input ( ) . split ( ) ) <NEWLINE> if b == <STRING> : <NEWLINE> <INDENT> print ( int ( a ) + int ( b ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( int ( a ) - int ( b ) ) <NEWLINE> <DEDENT>
a , b , c = input ( ) . split ( ) <NEWLINE> a , b = int ( a , b ) <NEWLINE> if b == <STRING> : <NEWLINE> <INDENT> print ( a + b ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( a - b ) <NEWLINE> <DEDENT>
<COMMENT> <NL> A = int ( input ( ) ) <NEWLINE> op = input ( ) <NEWLINE> B = int ( input ( ) ) <NEWLINE> <NL> if op == <STRING> : <NEWLINE> <INDENT> print ( A + B ) <NEWLINE> <DEDENT> elif op == <STRING> : <NEWLINE> <INDENT> print ( A - B ) <NEWLINE> <NL> <DEDENT>
s = map ( str , input ( ) . split ( ) ) <NEWLINE> ans = 0 <NEWLINE> if s [ 1 ] == <STRING> : <NEWLINE> <INDENT> ans = int ( s [ 0 ] ) + int ( s [ 2 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = int ( s [ 0 ] ) - int ( s [ 2 ] ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
a , op , b = input ( ) . split ( ) ) <NEWLINE> if op == <STRING> : <NEWLINE> <INDENT> print ( int ( a ) + int ( b ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( int ( a ) - int ( b ) ) <NEWLINE> <DEDENT>
a , b , c = map ( str , input ( ) . split ( ) ) <NEWLINE> if b == <STRING> : <NEWLINE> <INDENT> print ( int ( a ) + int ( b ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( int ( a ) - int ( b ) ) <NEWLINE> <DEDENT>
print ( eval ( input ( ) ) <NEWLINE>
<COMMENT> <NL> A , op , B = map ( str , input ( ) . split ( ) ) <NEWLINE> <NL> <COMMENT> <NL> calc = eval ( A & op & B ) <NEWLINE> print ( calc ) <NEWLINE>
a , b , c = map ( input ( ) . split ( ) ) <NEWLINE> if b == <STRING> : <NEWLINE> <INDENT> print ( a + b ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( a - b ) <NEWLINE> <DEDENT>
a , op , b = map ( int , input ( ) . split ( ) ) <NEWLINE> op = str ( op ) <NEWLINE> <NL> if p == <STRING> : <NEWLINE> <INDENT> print ( a + b ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( a - b ) <NEWLINE> <DEDENT>
a , b , c = input ( ) . split ( ) <NEWLINE> a = int ( a ) <NEWLINE> c = int ( c ) <NEWLINE> if b = <STRING> : <NEWLINE> <INDENT> print ( a + c ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( a - c ) <NEWLINE> <DEDENT>
A , op , B = input ( ) . split ( ) <NEWLINE> if op == <STRING> : <NEWLINE> <INDENT> print ( int ( A ) - int ( B ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( int ( A ) + ( B ) ) <NEWLINE> <DEDENT>
A , op , B = input ( ) . split ( ) <NEWLINE> A , B = int ( A ) , int ( B ) <NEWLINE> if op == <STRING> <NEWLINE> <INDENT> print ( A + B ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( A - B ) <NEWLINE> <DEDENT>
<COMMENT> <NL> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> op = str ( input ( ) ) <NEWLINE> <NL> <NL> <COMMENT> <NL> if op == <STRING> : <NEWLINE> <INDENT> answer = a + b <NEWLINE> <DEDENT> elif op == <STRING> : <NEWLINE> <INDENT> answer = a - b <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> print ( answer ) <NEWLINE>
a , b , c = map ( input ( ) . split ( ) ) <NEWLINE> a = int ( a ) <NEWLINE> c = int ( c ) <NEWLINE> if b == <STRING> : <NEWLINE> <INDENT> print ( a + c ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( a - c ) <NEWLINE> <DEDENT>
print ( eval ( input ( ) ) <NEWLINE>
<NL> def main ( ) : <NEWLINE> <INDENT> n = input ( ) . split ( ) <NEWLINE> if n [ 1 ] == <STRING> : <NEWLINE> <INDENT> print ( int ( n [ 0 ] ) + int ( n [ 1 ] ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( int ( n [ 0 ] ) - int ( n [ 1 ] ) ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
a , o , b = map ( str , input . split ( ) ) <NEWLINE> <NL> print ( int ( a ) int ( o ) int ( b ) ) <NEWLINE>
<INDENT> a , op , b = map ( str , input ( ) . split ( ) ) <NEWLINE> a = int ( a ) <NEWLINE> b = int ( b ) <NEWLINE> <NL> if op == <STRING> : <NEWLINE> <INDENT> result = a + b <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> result = a - b <NEWLINE> <NL> <DEDENT> print ( result ) <NEWLINE> <DEDENT>
def main ( a , op , b ) : <NEWLINE> <INDENT> if op == <STRING> : <NEWLINE> <INDENT> return int ( a ) + int ( b ) <NEWLINE> <DEDENT> elif op == <STRING> : <NEWLINE> <INDENT> return int ( a ) - int ( b ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __init__ == <STRING> : <NEWLINE> <INDENT> a , op , b = input ( ) . split ( ) <NEWLINE> print ( main ( a , op , b ) ) <NEWLINE> <DEDENT>
a , op , b = input ( ) . split ( ) <NEWLINE> if op = <STRING> : <NEWLINE> <INDENT> ans = int ( a ) + int ( b ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = int ( a ) - int ( b ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> T = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> M = int ( input ( ) ) <NEWLINE> ans = sum ( T ) <NEWLINE> for i in range ( len ( M ) ) : <NEWLINE> <INDENT> P , X = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( ans - T [ P - 1 ] + X ) <NEWLINE> <DEDENT>
num_problems = int ( input ( ) ) <NEWLINE> a = input ( ) <NEWLINE> seconds_per = a . split ( ) <NEWLINE> for i in seconds_per : <NEWLINE> <INDENT> total += int ( i ) <NEWLINE> <DEDENT> drinks = int ( input ( ) ) <NEWLINE> for i in range ( drinks ) : <NEWLINE> <INDENT> b = input ( ) <NEWLINE> c = b . split ( ) <NEWLINE> question = int ( c [ 0 ] ) <NEWLINE> change = int ( c [ 1 ] ) <NEWLINE> new = total - int ( seconds_per [ question - 1 ] ) + change <NEWLINE> print ( new ) <NEWLINE> <NL> <NL> <DEDENT>
n = int ( input ( ) ) <NEWLINE> t = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> m = int ( input ( ) ) <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> p , x = map ( int , input ( ) . split ( ) ) <NEWLINE> y = t [ p - 1 ] <NEWLINE> t [ p - 1 ] = x : <NEWLINE> print ( sum ( t ) ) <NEWLINE> t [ p - 1 ] = y <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> l = [ 0 ] + l <NEWLINE> s = sum ( l ) <NEWLINE> k = int ( input ( ) ) <NEWLINE> for _ in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> m , n = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( s - l [ m ] + n ) <NEWLINE> <NL> <DEDENT>
n = int ( input ( ) ) <NEWLINE> l = [ 0 ] + list ( map ( int , input ( ) . split ( ) ) ) ans = sum ( l ) <NEWLINE> for i in range ( int ( input ( ) ) ) : <NEWLINE> <INDENT> a , s = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( ans - l [ a ] + s ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> m = int ( input ( ) ) <NEWLINE> <NL> sum_l = sum ( l ) <NEWLINE> <NL> for i in range ( m ) : <NEWLINE> <INDENT> p , x = map ( int , input ( ) . split ( ) ) <NEWLINE> ams = sum_l - l [ p - 1 ] + x <NEWLINE> print ( ans ) <NEWLINE> <DEDENT>
print ( a ) <NEWLINE> n = int ( input ( ) ) <NEWLINE> t = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> m = int ( input ( ) ) <NEWLINE> <NL> for i in range ( m ) : <NEWLINE> <INDENT> lst = list ( t ) <NEWLINE> p , x = map ( int , input ( ) . split ( ) ) <NEWLINE> lst [ p - 1 ] = x <NEWLINE> print ( sum ( lst ) ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <NL> using namespace std ; <NEWLINE> <NL> int main ( ) { <NEWLINE> <INDENT> int N , M , k , val , sum = 0 , ans ; <NEWLINE> <NL> array < int , 100 > p ; <NEWLINE> cin >> N ; <NEWLINE> for ( int i = 0 ; i < N ; i + + ) { <NEWLINE> <INDENT> cin >> p [ i ] ; <NEWLINE> sum += p [ i ] ; <NEWLINE> <DEDENT> } <NEWLINE> <NL> cin >> M ; <NEWLINE> for ( int i = 0 ; i < M ; i + + ) { <NEWLINE> <INDENT> cin >> k >> val ; <NEWLINE> cout << sum + val - p [ k - 1 ] << <STRING> ; <NEWLINE> <DEDENT> } <NEWLINE> <NL> <DEDENT> } <NEWLINE>
num_prob = int ( input ( ) ) <NEWLINE> prob = input ( ) <NEWLINE> new = prob . split ( ) <NEWLINE> sum = 0 <NEWLINE> num_drinks = int ( input ( ) ) <NEWLINE> for j in new : <NEWLINE> <INDENT> sum += int ( j ) <NEWLINE> <NL> <DEDENT> for i in range ( num_drinks ) : <NEWLINE> <INDENT> line = input ( ) <NEWLINE> new_line = line . split ( ) <NEWLINE> if new_line [ 1 ] != new [ new_line [ 0 ] ] : <NEWLINE> <INDENT> sum -= new [ new_line [ 0 ] ] <NEWLINE> sum += new_line [ 1 ] <NEWLINE> <DEDENT> print ( sum ) <NEWLINE> <NL> <DEDENT>
N = int ( input ( ) ) <NEWLINE> t = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> T = sum ( t ) <NEWLINE> M = int ( input ( ) ) <NEWLINE> for _ in range ( M ) : <NEWLINE> <INDENT> p , x = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( T + ( T [ p - 1 ] - x ) ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> t = int ( input ( ) ) <NEWLINE> a . append ( t ) <NEWLINE> <DEDENT> m = int ( input ( ) ) <NEWLINE> for j in range ( m ) : <NEWLINE> <INDENT> p , x = map ( int , input ( ) . split ( ) ) <NEWLINE> for k in range ( n ) : <NEWLINE> <INDENT> if t == k + 1 : <NEWLINE> <INDENT> a [ k ] = x <NEWLINE> <DEDENT> <DEDENT> <DEDENT> for j in range ( m ) : <NEWLINE> <INDENT> print ( sum ( a ) ) <NEWLINE> <NL> <DEDENT>
a = int ( input ( ) ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c = int ( input ( ) ) <NEWLINE> d = [ int ( input ( ) ) for i in range ( c ) ] <NEWLINE> for i in range ( c ) : <NEWLINE> <INDENT> print ( sum ( b ) - b [ d [ i ] [ 0 ] ] + d [ i ] [ 1 ] ) <NEWLINE> <DEDENT>
import sys <NEWLINE> from collections import deque <NEWLINE> p = 10 ** 9 + 7 <NEWLINE> <NL> def main ( n , a ) : <NEWLINE> <INDENT> h = n // 2 <NEWLINE> g = n % 2 <NEWLINE> a . sort ( ) <NEWLINE> c = [ 2 * ( x // 2 ) + g + 1 for x in range ( n - g ) ] <NEWLINE> if g == 1 : <NEWLINE> <INDENT> c . insert ( 0 , 0 ) <NEWLINE> <DEDENT> if a != c : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> return 2 ** ( h % ( p - 1 ) ) <NEWLINE> <NL> <DEDENT> if __name__ = <STRING> : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , sys . stdin . readline ( ) . strip ( ) . split ( ) ) ) <NEWLINE> print ( main ( n , a ) ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> * A = sorted ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> a = True <NEWLINE> if n % 2 == 0 : <NEWLINE> <INDENT> for i in range ( 1 , n , 2 ) : <NEWLINE> <INDENT> if A [ i - 1 ] != i or A [ i ] != i : <NEWLINE> <INDENT> a = False <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if A [ 0 ] != 0 : a = False <NEWLINE> else : <NEWLINE> <INDENT> for i in range ( 2 , n , 2 ) : <NEWLINE> <INDENT> if A [ i - 1 ] != i or A [ i ] != i : <NEWLINE> <INDENT> a = False <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( 2 ** ( n // 2 ) % ( 10 ** 9 + 7 ) if a else 0 ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> A = check . copy ( ) <NEWLINE> A . sort ( ) <NEWLINE> <NL> check = [ 0 ] * N <NEWLINE> <NL> for idx in range ( N % 2 , N , 2 ) : <NEWLINE> <INDENT> check [ idx ] = idx + 1 <NEWLINE> check [ idx + 1 ] = idx + 1 <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> <NL> if check == A : <NEWLINE> <INDENT> if N % 2 == 0 : <NEWLINE> <INDENT> ans = ( 2 ** ( N // 2 ) ) % ( 10 ** 9 + 7 ) <NEWLINE> <DEDENT> elif N % 2 != 0 : <NEWLINE> <INDENT> ans = ( 2 ** ( ( N - 1 ) // 2 ) ) % ( 10 ** 9 + 7 ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> A_test = sorted ( list ( set ( A ) ) ) <NEWLINE> <NL> if N % 2 == 1 : <NEWLINE> <INDENT> judge = [ i for i in range ( 0 , N , 2 ) ] <NEWLINE> if A_test == judge : <NEWLINE> <INDENT> ans = 2 ** ( N // 2 ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> judge = [ i for i in range ( 1 , N , 2 ) ] <NEWLINE> if A_test == judge : <NEWLINE> <INDENT> ans = 2 ** ( N // 2 ) ] <NEWLINE> <NL> <DEDENT> <DEDENT> ans = ans % ( 10 ** 9 + 7 ) <NEWLINE> print ( ans ) <NEWLINE>
if len ( a ) % 2 == 1 : <NEWLINE> <INDENT> tmp = [ 0 ] <NEWLINE> for i in range ( ( len ( a ) - 1 ) // 2 ) : <NEWLINE> <INDENT> tmp . append ( ( i + 1 ) * 2 ) <NEWLINE> tmp . append ( ( i + 1 ) * 2 ) <NEWLINE> <DEDENT> if a == tmp : <NEWLINE> <INDENT> ans = ( 2 ** ( ( len ( a ) - 1 ) // 2 ) ) % ( 10 ** 9 + 7 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> tmp = [ ] <NEWLINE> for i in range ( len ( a ) // 2 ) : <NEWLINE> <INDENT> tmp . append ( 2 * i + 1 ) <NEWLINE> tmp . append ( 2 * i + 1 ) <NEWLINE> <DEDENT> if a == tmp : <NEWLINE> <INDENT> ans = ( 2 ** ( len ( a ) // 2 ) ) % ( 10 ** 9 + 7 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> from collections import defaultdict as dd <NEWLINE> Dict = dd ( lambda : 0 ) <NEWLINE> for a in A : <NEWLINE> <INDENT> Dict [ a ] += 1 <NEWLINE> <NL> <DEDENT> if N & 1 : Dict [ 0 ] += 1 <NEWLINE> f = ( lambda : ( lambda x : 0 if x & 1 else 2 ) if N & 1 else ( lambda x : 2 if x & 1 else 0 ) ) ( ) <NEWLINE> Possible = { i : f ( i ) for i in range ( N ) } <NEWLINE> for key , value in Dict . items : <NEWLINE> <INDENT> if value != Possible [ key ] : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( 2 ** ( N // 2 ) % 1000000007 ) <NEWLINE> <NL> <NL> <DEDENT>
import sys <NEWLINE> <NL> p = 10 ** 9 + 7 <NEWLINE> dthbit = lambda d , n : ( n >> d ) & 1 <NEWLINE> <NL> def main ( n ) : <NEWLINE> <INDENT> dp = [ [ 0 for _ in range ( 3 ) ] for _ in range ( 64 ) ] <NEWLINE> dp [ 63 ] [ 0 ] = 1 <NEWLINE> for d in range ( 62 , - 1 , - 1 ) : <NEWLINE> <INDENT> b = dthbit ( d , n ) <NEWLINE> s = dp [ d + 1 ] [ : ] <NEWLINE> dp [ d ] [ 0 ] = dp [ d + 1 ] [ 0 ] + ( 1 ^ b ) * dp [ d + 1 ] [ 1 ] % p <NEWLINE> dp [ d ] [ 1 ] = b * dp [ d + 1 ] [ 0 ] + dp [ d + 1 ] [ 1 ] % p <NEWLINE> dp [ d ] [ 2 ] = ( 1 + b ) * dp [ d + 1 ] [ 1 ] + 3 * dp [ d + 1 ] [ 2 ] % p <NEWLINE> <DEDENT> return sum ( dp [ 0 ] [ : ] % p ) <NEWLINE> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> print ( main ( n ) ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> import sys <NEWLINE> <NL> def input ( ) : return sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> a = map ( int , input ( ) . split ( ) ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> a . sort ( ) <NEWLINE> check = [ i + 1 - ( i + n ) % 2 for i in range ( n ) ] <NEWLINE> if a != check : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> return <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = pow ( 2 , n // 2 , mod ) <NEWLINE> print ( ans ) <NEWLINE> <NL> <NL> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
a = input ( ) <NEWLINE> vowel = set ( <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ) <NEWLINE> if a in vowel : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
<NL> lst = list ( map ( str , input ( ) . split ( ) ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> print ( lst [ 0 ] [ 0 ] + lst [ 1 ] [ 0 ] + lst [ 2 ] [ 0 ] ) <NEWLINE>
s = input ( ) <NEWLINE> if s == <STRING> or s == <STRING> or s == <STRING> or s == <STRING> or s == <STRING> : <NEWLINE> <INDENT> print ( vowel ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( consonant ) <NEWLINE> <DEDENT>
n = str ( input ( ) ) <NEWLINE> if n = <STRING> or <STRING> or <STRING> or <STRING> or <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
letter = input ( ) <NEWLINE> if ( letter == <STRING> or letter == <STRING> or letter = <STRING> or letter == <STRING> or letter == <STRING> ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
c = input ( ) <NEWLINE> if c in [ <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> l = [ chr ( ord ( a ) + i ) for i in range ( 5 ) ] <NEWLINE> print ( <STRING> if s in l else <STRING> ) <NEWLINE>
A = input ( ) <NEWLINE> if A = <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> if A = <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> if A = <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> if A = <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> if A = <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
c = input ( ) <NEWLINE> vowel = [ a , i , u , e , o ] <NEWLINE> print ( <STRING> if c in vowel else <STRING> ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> S = S . replace ( <STRING> , <STRING> ) <NEWLINE> S = S . replace ( <STRING> , <STRING> ) <NEWLINE> S = S . replace ( <STRING> , <STRING> ) <NEWLINE> S = S . replace ( <STRING> , <STRING> ) <NEWLINE> S = S . replace ( <STRING> , <STRING> ) <NEWLINE> print ( N - int ( len ( S ) ) ) <NEWLINE>
c = int ( input ( ) ) <NEWLINE> if c == <STRING> or c == <STRING> or c == <STRING> or c == <STRING> or c == <STRING> : print ( <STRING> ) <NEWLINE> else : print ( <STRING> ) <NEWLINE>
c = input ( ) <NEWLINE> if c in <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> else : <NEWLINE> print ( <STRING> ) <NEWLINE> <DEDENT>
x = <STRING> <NEWLINE> i = input ( ) <NEWLINE> if i in x : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
if c in <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
text = str ( input ( ) ) <NEWLINE> if text == a <NEWLINE> <INDENT> print ( vowel ) <NEWLINE> <DEDENT> elif text == i <NEWLINE> <INDENT> print ( vowel ) <NEWLINE> <DEDENT> elif text == u <NEWLINE> <INDENT> print ( vowel ) <NEWLINE> <DEDENT> elif text == e : <NEWLINE> <INDENT> print ( vowel ) <NEWLINE> <DEDENT> elif text == o : : <NEWLINE> <INDENT> print = ( vowel ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print = ( consonant ) <NEWLINE> <DEDENT>
x = str ( input ( ) ) <NEWLINE> if x = <STRING> or x = <STRING> or x = <STRING> or x = <STRING> or x = <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> print ( [ <STRING> , <STRING> ] [ s = <STRING> or s = <STRING> or s = <STRING> or s = <STRING> or s = <STRING> ] ) <NEWLINE>
c = input ( ) <NEWLINE> x = [ a , e , i , o , u ] <NEWLINE> if x in c : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = input ( ) <NEWLINE> if N in <STRING> <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> C = [ ] <NEWLINE> for i in range ( H ) : <NEWLINE> <INDENT> C [ i ] = input ( ) <NEWLINE> <DEDENT> for i in range ( H ) : <NEWLINE> <INDENT> print ( C [ i ] ) <NEWLINE> print ( C [ i ] ) <NEWLINE> <DEDENT>
h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> c = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( h ) ] <NEWLINE> for i in range ( h ) : <NEWLINE> <INDENT> print ( c [ i ] ) <NEWLINE> print ( c [ i ] ) <NEWLINE> <DEDENT>
h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> for i in range ( h ) : <NEWLINE> <INDENT> print ( input ( ) ) <NEWLINE> print ( input ( ) ) <NEWLINE> <DEDENT>
h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> li = [ input ( ) for _ in range ( h ) ] <NEWLINE> <NL> for i in li : <NEWLINE> <INDENT> print ( i , i , sep = <STRING> ) ** * . <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> import sys <NEWLINE> from io import StringIO <NEWLINE> import unittest <NEWLINE> <NL> <NL> class TestClass ( unittest . TestCase ) : <NEWLINE> <INDENT> def assertIO ( self , input , output ) : <NEWLINE> <INDENT> stdout , stdin = sys . stdout , sys . stdin <NEWLINE> sys . stdout , sys . stdin = StringIO ( ) , StringIO ( input ) <NEWLINE> resolve ( ) <NEWLINE> sys . stdout . seek ( 0 ) <NEWLINE> out = sys . stdout . read ( ) [ : - 1 ] <NEWLINE> sys . stdout , sys . stdin = stdout , stdin <NEWLINE> self . assertEqual ( out , output ) <NEWLINE> <NL> <DEDENT> def test__1 ( self ) : <NEWLINE> <INDENT> input = <STRING> <NEWLINE> output = <STRING> <NEWLINE> self . assertIO ( input , output ) <NEWLINE> <NL> <DEDENT> def test__2 ( self ) : <NEWLINE> <INDENT> input = <STRING> <NEWLINE> output = <STRING> <NEWLINE> self . assertIO ( input , output ) <NEWLINE> <NL> <DEDENT> def test__3 ( self ) : <NEWLINE> <INDENT> input = <STRING> <NEWLINE> output = <STRING> <NEWLINE> self . assertIO ( input , output ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def resolve ( ) : <NEWLINE> <INDENT> H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = [ ] <NEWLINE> for i in range ( H ) : <NEWLINE> <INDENT> S = input ( ) <NEWLINE> ans . append ( S ) <NEWLINE> ans . append ( S ) <NEWLINE> <NL> for i in range ( 2 * H ) : <NEWLINE> print ( ans [ i ] ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <COMMENT> <NL> <INDENT> resolve ( ) <NEWLINE> <DEDENT>
h , w = int ( input ( ) ) <NEWLINE> for i in range ( h ) : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> print ( s ) <NEWLINE> print ( s ) <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> for i in range ( h ) : <NEWLINE> <INDENT> q = input ( ) <NEWLINE> print ( q ) <NEWLINE> print ( q ) <NEWLINE> <DEDENT>
a , b = input ( ) . split ( ) <NEWLINE> a = int ( a ) <NEWLINE> b = int ( b ) <NEWLINE> c = [ input ( ) for i in range ( a ) ] <NEWLINE> for i in range ( a ) : <NEWLINE> <INDENT> print ( b [ i ] ) <NEWLINE> print ( b [ i ] ) <NEWLINE> <DEDENT>
<NL> url = <STRING> <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> h , w = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ss = [ input ( ) for _ in range ( h ) ] <NEWLINE> for s in ss : <NEWLINE> <INDENT> print ( s ) <NEWLINE> print ( s ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> while 1 : <NEWLINE> <INDENT> if len ( S ) == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> if s [ len ( s ) - 5 : ] == <STRING> : <NEWLINE> <INDENT> s = s [ : len ( s ) - 5 ] <NEWLINE> continue <NEWLINE> <DEDENT> elif s [ len ( s ) - 7 : ] == <STRING> : <NEWLINE> <INDENT> s = s [ : len ( s ) - 7 ] <NEWLINE> continue <NEWLINE> <DEDENT> elif s [ len ( s ) - 5 : ] == <STRING> : <NEWLINE> <INDENT> s = s [ : len ( s ) - 5 ] <NEWLINE> continue <NEWLINE> <DEDENT> elif s [ len ( s ) - 6 : ] == <STRING> : <NEWLINE> <INDENT> s = s [ : len ( s ) - 6 ] <NEWLINE> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT>
import re <NEWLINE> <NL> s = input ( ) <NEWLINE> s = re . sub ( <STRING> , <STRING> , s ) <NEWLINE> s = re . sub ( <STRING> , <STRING> , s ) <NEWLINE> s = re . sub ( <STRING> , <STRING> , s ) <NEWLINE> s = re . sub ( <STRING> , <STRING> , s ) <NEWLINE> <NL> if int ( s ) == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> while s : <NEWLINE> <INDENT> if s [ - 5 : ] == <STRING> : <NEWLINE> <INDENT> for i in range ( 5 ) : <NEWLINE> <INDENT> s . pop ( ) <NEWLINE> <DEDENT> <DEDENT> elif s [ - 5 : ] == <STRING> : <NEWLINE> <INDENT> for i in range ( 5 ) : <NEWLINE> <INDENT> s . pop ( ) <NEWLINE> <DEDENT> <DEDENT> elif s [ - 6 : ] == <STRING> : <NEWLINE> <INDENT> for i in range ( 6 ) : <NEWLINE> <INDENT> s . pop ( ) <NEWLINE> <DEDENT> <DEDENT> elif s [ - 7 : ] == <STRING> : <NEWLINE> <INDENT> for i in range ( 7 ) : <NEWLINE> <INDENT> s . pop ( ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
S = input ( ) <NEWLINE> if re . match ( <STRING> , S ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> <NL> list = [ <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> <NL> for i in list : <NEWLINE> <INDENT> s = s . replace ( i , <STRING> ) <NEWLINE> <NL> <DEDENT> s . sort ( ) <NEWLINE> <NL> if s [ 0 ] == s [ - 1 ] and s [ - 1 ] == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s = input ( ) replace ( <STRING> , <STRING> ) . replace ( <STRING> , <STRING> ) . replace ( <STRING> , <STRING> ) . replace ( <STRING> , <STRING> ) . <NEWLINE> print ( <STRING> if s == <STRING> else <STRING> ) <NEWLINE>
S = list ( input ( ) ) <NEWLINE> N = len ( S ) <NEWLINE> <NL> def f ( x ) : <NEWLINE> <INDENT> print ( x ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> if N < 5 : <NEWLINE> <INDENT> f ( <STRING> ) <NEWLINE> <DEDENT> elif S [ 0 ] == <STRING> : <NEWLINE> <INDENT> w = 1 <NEWLINE> <DEDENT> elif S [ 0 ] == <STRING> : <NEWLINE> <INDENT> w = - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> f ( <STRING> ) <NEWLINE> <NL> <DEDENT> i = 0 <NEWLINE> while True : <NEWLINE> <INDENT> if w > 0 : <NEWLINE> <INDENT> if S [ i ] + S [ i + 1 ] + S [ i + 2 ] + S [ i + 3 ] + S [ i + 4 ] == <STRING> : <NEWLINE> <INDENT> i += 5 <NEWLINE> if i == N : <NEWLINE> <INDENT> f ( <STRING> ) <NEWLINE> <DEDENT> elif S [ i ] == <STRING> : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> elif S [ i ] == <STRING> : <NEWLINE> <INDENT> if i + 1 <= N - 1 : <NEWLINE> <INDENT> if S [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> if i + 1 == N - 1 : <NEWLINE> <INDENT> f ( <STRING> ) <NEWLINE> <DEDENT> elif S [ i + 2 ] == <STRING> : <NEWLINE> <INDENT> w *= - 1 <NEWLINE> <DEDENT> elif S [ i + 2 ] == <STRING> : <NEWLINE> <INDENT> i += 2 <NEWLINE> w *= - 1 <NEWLINE> <DEDENT> elif S [ i + 2 ] == <STRING> : <NEWLINE> <INDENT> i += 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> f ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> f ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> f ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> f ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> f ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> elif w < 0 : <NEWLINE> <INDENT> if S [ i ] + S [ i + 1 ] + S [ i + 2 ] + S [ i + 3 ] + S [ i + 4 ] == <STRING> : <NEWLINE> <INDENT> i += 5 <NEWLINE> if i == N : <NEWLINE> if S [ i ] == <STRING> : <NEWLINE> <INDENT> i += 1 <NEWLINE> if i == N : <NEWLINE> <DEDENT> if S [ i ] == <STRING> : <NEWLINE> <INDENT> w *= - 1 <NEWLINE> <DEDENT> elif S [ i ] == <STRING> : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> f ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> f ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> if i + 4 > N - 1 : <NEWLINE> <INDENT> f ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> using namespace std ; <NEWLINE> using Graph = vector < vector < int >> ; <NEWLINE> <NL> long set_index ; <NEWLINE> <NL> void dfs ( Graph graph , vector < bool > & seen , vector < int > & set , int v ) { <NEWLINE> <INDENT> seen [ v ] = true ; <NEWLINE> set [ v ] = set_index ; <NEWLINE> for ( auto next_v : graph [ v ] ) { <NEWLINE> <INDENT> if ( seen [ next_v ] ) continue ; <NEWLINE> dfs ( graph , seen , set , next_v ) ; <NEWLINE> <DEDENT> } <NEWLINE> <DEDENT> } <NEWLINE> <NL> void input ( Graph & graph , int M ) { <NEWLINE> <INDENT> int p , q ; <NEWLINE> for ( int i = 0 ; i < M ; i + + ) { <NEWLINE> <INDENT> cin >> p >> q ; <NEWLINE> graph [ p - 1 ] . push_back ( q - 1 ) ; <NEWLINE> graph [ q - 1 ] . push_back ( p - 1 ) ; <NEWLINE> <DEDENT> } <NEWLINE> <DEDENT> } <NEWLINE> <NL> void connect ( Graph & graph , vector < bool > & seen , vector < int > & set , int n ) { <NEWLINE> <INDENT> set_index = 0 ; <NEWLINE> for ( int v = 0 ; v < n ; v + + ) { <NEWLINE> <INDENT> if ( seen [ v ] ) continue ; <NEWLINE> dfs ( graph , seen , set , v ) ; <NEWLINE> set_index + + ; <NEWLINE> <DEDENT> } <NEWLINE> <DEDENT> } <NEWLINE> <NL> int main ( ) { <NEWLINE> <INDENT> int N , K , L ; <NEWLINE> cin >> N >> K >> L ; <NEWLINE> Graph road , rail ; <NEWLINE> vector < bool > seen_road , seen_rail ; <NEWLINE> vector < int > set_road , set_rail ; <NEWLINE> road . resize ( N ) ; <NEWLINE> rail . resize ( N ) ; <NEWLINE> set_road . assign ( N , 0 ) ; <NEWLINE> set_rail . assign ( N , 0 ) ; <NEWLINE> input ( road , K ) ; <NEWLINE> input ( rail , L ) ; <NEWLINE> <NL> seen_road . assign ( N , false ) ; <NEWLINE> connect ( road , seen_road , set_road , N ) ; <NEWLINE> seen_rail . assign ( N , false ) ; <NEWLINE> connect ( rail , seen_rail , set_rail , N ) ; <NEWLINE> <NL> map < pair < long , long > , int > ans ; <NEWLINE> for ( int i = 0 ; i < N ; i + + ) { <NEWLINE> <INDENT> ans [ make_pair ( set_road [ i ] , set_rail [ i ] ) ] + + ; <NEWLINE> <DEDENT> } <NEWLINE> for ( int i = 0 ; i < N ; i + + ) { <NEWLINE> <INDENT> cout << ans [ make_pair ( set_road [ i ] , set_rail [ i ] ) ] << <STRING> ; <NEWLINE> <DEDENT> } <NEWLINE> return 0 ; <NEWLINE> <DEDENT> } <NEWLINE>
N , K , L = map ( int , input ( ) . split ( ) ) <NEWLINE> <COMMENT> <NL> road = [ i for i in range ( N ) ] <NEWLINE> rail = [ i for i in range ( N ) ] <NEWLINE> <NL> def fp ( x , P ) : <COMMENT> <NEWLINE> <INDENT> if x == P [ x ] : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> P [ x ] = fp ( P [ x ] ) <NEWLINE> return P [ x ] <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( K + L ) : <NEWLINE> <INDENT> PL = ( lambda x : road if x < K else rail ) ( i ) <NEWLINE> p , q = map ( lambda x : int ( x ) - 1 , input ( ) . split ( ) ) <NEWLINE> p , q = fp ( p , PL ) , fp ( q , PL ) <NEWLINE> PL [ p ] = PL [ q ] = min ( p , q ) <NEWLINE> <NL> <DEDENT> from collections import defaultdict as dd <NEWLINE> Wconnected = dd ( lambda : 0 ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> Wconnected [ fp ( i , road ) , fp ( i , rail ) ] += 1 <NEWLINE> <DEDENT> print ( * [ Wconnected [ fp ( i , road ) , fp ( i , rail ) ] for i in range ( N ) ] ) <NEWLINE>
import sys <NEWLINE> from collections import deque <NEWLINE> from collections import defaultdict <NEWLINE> from collections import Counter <NEWLINE> <NL> def conn ( n , m , e ) : <NEWLINE> <INDENT> d = dict ( zip ( range ( 1 , n + 1 ) , range ( - 1 , ( - 1 ) * n - 1 , - 1 ) ) ) <NEWLINE> td = defaultdict ( lambda : deque ( [ ] ) ) <COMMENT> <NEWLINE> c = 1 <NEWLINE> for edge in e : <NEWLINE> <INDENT> a = edge [ 0 ] <NEWLINE> b = edge [ 1 ] <NEWLINE> da = d [ a ] <COMMENT> <NEWLINE> db = d [ b ] <NEWLINE> if da < 0 and db < 0 : <NEWLINE> <INDENT> d [ a ] = c <NEWLINE> d [ b ] = c <NEWLINE> td [ c ] . append ( a ) <NEWLINE> td [ c ] . append ( b ) <NEWLINE> c += 1 <NEWLINE> <DEDENT> elif da > 0 and db < 0 : <NEWLINE> <INDENT> d [ b ] = da <NEWLINE> td [ d [ a ] ] . append ( b ) <NEWLINE> <DEDENT> elif da < 0 and db > 0 : <NEWLINE> <INDENT> d [ a ] = db <NEWLINE> td [ d [ b ] ] . append ( a ) <NEWLINE> <DEDENT> elif da > 0 and db > 0 and da != db : <NEWLINE> <INDENT> for x in td [ db ] : <NEWLINE> <INDENT> d [ x ] = da <NEWLINE> td [ da ] . append ( x ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> return list ( d . values ( ) ) <NEWLINE> <NL> <DEDENT> def components ( n , k , e ) : <NEWLINE> <INDENT> ed = defaultdict ( lambda : deque ( ) ) <NEWLINE> for edge in e : <NEWLINE> <INDENT> ed [ edge [ 0 ] ] . append ( edge [ 1 ] ) <NEWLINE> <DEDENT> c = 0 <NEWLINE> s = [ 0 ] * n <NEWLINE> label = [ 0 ] * n <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if s [ i - 1 ] == 0 : <NEWLINE> <INDENT> c += 1 <NEWLINE> label [ c - 1 ] = c <NEWLINE> stack = deque ( [ i ] ) <NEWLINE> while stack : <NEWLINE> <INDENT> w = stack . pop ( ) <NEWLINE> s [ w - 1 ] = c <NEWLINE> while ed [ w ] : <NEWLINE> <INDENT> wn = ed [ w ] . pop ( ) <NEWLINE> if s [ wn - 1 ] == 0 : <NEWLINE> <INDENT> s [ wn - 1 ] = c <NEWLINE> if ed [ wn ] : <NEWLINE> <INDENT> stack . append ( w ) <NEWLINE> w = wn <NEWLINE> <DEDENT> <DEDENT> elif s [ wn - 1 ] < c : <NEWLINE> <INDENT> label [ s [ wn - 1 ] - 1 ] = c <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> return [ label [ s [ i ] - 1 ] for i in range ( n ) ] <NEWLINE> <NL> <DEDENT> def components2 ( n , k , e ) : <NEWLINE> <INDENT> ed = defaultdict ( lambda : deque ( ) ) <NEWLINE> for edge in e : <NEWLINE> <INDENT> ed [ edge [ 0 ] ] . append ( edge [ 1 ] ) <NEWLINE> ed [ edge [ 1 ] ] . append ( edge [ 0 ] ) <NEWLINE> <DEDENT> c = 0 <NEWLINE> s = [ 0 ] * n <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if s [ i - 1 ] == 0 : <NEWLINE> <INDENT> c += 1 <NEWLINE> stack = deque ( [ i ] ) <NEWLINE> while stack : <NEWLINE> <INDENT> w = stack . pop ( ) <NEWLINE> s [ w - 1 ] = c <NEWLINE> while ed [ w ] : <NEWLINE> <INDENT> wn = ed [ w ] . pop ( ) <NEWLINE> if s [ wn - 1 ] == 0 : <NEWLINE> <INDENT> s [ wn - 1 ] = c <NEWLINE> if ed [ wn ] : <NEWLINE> <INDENT> stack . append ( w ) <NEWLINE> w = wn <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> return [ [ s [ i ] for i in range ( n ) ] <NEWLINE> <DEDENT> def main ( n , k , l , e1 , e2 ) : <NEWLINE> <INDENT> d1 = components2 ( n , k , e1 ) <NEWLINE> d2 = components2 ( n , l , e2 ) <NEWLINE> p = tuple ( zip ( iter ( d1 ) , iter ( d2 ) ) ) <NEWLINE> d = Counter ( p ) <NEWLINE> <COMMENT> <NL> print ( <STRING> . join ( [ str ( d [ x ] ) for x in p ] ) ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> ssr = sys . stdin . readline <NEWLINE> n , k , l = map ( int , ssr ( ) . strip ( ) . split ( ) ) <NEWLINE> e1 = [ ] <NEWLINE> e2 = [ ] <NEWLINE> for _ in range ( k ) : <NEWLINE> <INDENT> e1 . append ( tuple ( map ( int , ssr ( ) . strip ( ) . split ( ) ) ) ) <NEWLINE> <DEDENT> for _ in range ( l ) : <NEWLINE> <INDENT> e2 . append ( tuple ( map ( int , ssr ( ) . strip ( ) . split ( ) ) ) ) <NEWLINE> <DEDENT> main ( n , k , l , e1 , e2 ) <NEWLINE> <DEDENT>
sentence = input ( ) <NEWLINE> new_sent = sentence . split ( <STRING> ) <NEWLINE> acro = <STRING> <NEWLINE> for i in range ( len ( new_sent ) ) : <NEWLINE> <INDENT> for j in range ( new_sent [ i ] ) : <NEWLINE> <INDENT> acro += new_sent [ i ] [ 0 ] <NEWLINE> <DEDENT> <DEDENT> print ( acro ) <NEWLINE>
a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( len ( set ( [ a , b , c ] ) ) ) <NEWLINE>
a , b , c = str ( input ( ) . split ( ) ) <NEWLINE> print ( a [ 0 ] + b [ 0 ] + c [ 0 ] ) <NEWLINE>
a , b , c = imput ( ) . split ( ) <NEWLINE> print ( <STRING> + b [ 0 ] + <STRING> ) <NEWLINE>
a , b , c = input ( ) . split ( ) <NEWLINE> print ( a [ 0 ] , upper ( b [ 0 ] ) , c [ 0 ] ) <NEWLINE>
A , B , C = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( <STRING> + B + <STRING> ) <NEWLINE>
a , b , x = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a1 = a // x if a % x else a // x - 1 <NEWLINE> a2 = b // x <NEWLINE> print ( a2 - a1 ) <NEWLINE>
s = input ( ) <NEWLINE> ss = s [ 0 ] <NEWLINE> sss = upper ( ss ) <NEWLINE> print ( <STRING> + sss + <STRING> ) <NEWLINE>
string = input ( ) <NEWLINE> <INDENT> Capital = string [ 0 ] <NEWLINE> print ( <STRING> + Capital + <STRING> ) <NEWLINE> <NL> <DEDENT>
a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( a [ 0 ] + b [ 0 ] + c [ 0 ] ) <NEWLINE>
a , b , c = map ( input ( ) . split ( ) ) <NEWLINE> print ( a + b [ 0 ] + c ) <NEWLINE>
xs = inpt ( ) . split ( ) <NEWLINE> <NL> print ( <STRING> + xs [ 2 ] [ 0 ] + <STRING> ) <NEWLINE>
print ( <STRING> . join ( s [ 0 ] for s in input ( ) split ( ) ) ) <NEWLINE>
a , s , c = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( a [ 0 ] + s [ 0 ] + c [ 0 ] ) <NEWLINE>
arr = list ( input ( ) . split ( ) ) <NEWLINE> print ( arr [ 0 ] . [ 0 ] + arr [ 1 ] . [ 0 ] + arr [ 2 ] . [ 0 ] ) <NEWLINE>
l = input ( ) . replace ( <STRING> , <STRING> ) <NEWLINE> print ( l [ 0 ] + l [ 7 ] + l [ - 7 ] ) <NEWLINE> <NL>
import sys <NEWLINE> def I_dont_know_what_to_do ( ) : <NEWLINE> <INDENT> a = long ( input ( ) ) <NEWLINE> b = long ( input ( ) ) <NEWLINE> c = int ( input ( ) ) <NEWLINE> <NL> if a < b : <NEWLINE> <INDENT> n = a <NEWLINE> a = b <NEWLINE> b = n <NEWLINE> <NL> <DEDENT> s = ( a - b + 2 - a % c - b % c ) / c <NEWLINE> print ( s ) <NEWLINE> <NL> <NL> <DEDENT> I_dont_know_what_to_do ( ) <NEWLINE>
a , b , x = list ( map ( int , input_ [ 0 ] . split ( ) ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> if a != b : <NEWLINE> <INDENT> A = ( a - 1 ) // x <NEWLINE> B = b // x <NEWLINE> <NL> ans = B - A <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
a , b , x = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <INDENT> print ( ( b - a ) // x ) <NEWLINE> <DEDENT>
a , b , c = list ( map ( str , input ( ) . split ( ) ) ) <NEWLINE> a = a / c <NEWLINE> b = b / c <NEWLINE> print ( b - a ) <NEWLINE>
<COMMENT> <NL> <NL> a , b , x = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> <NL> n = b - a - 1 <NEWLINE> <COMMENT> <NL> <NL> a , b , x = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> <NL> n = b - a <NEWLINE> if a % x == 0 or b % x == 0 : <NEWLINE> <INDENT> print ( n // x + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( n // x ) <NEWLINE> <DEDENT>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> max = b // x <NEWLINE> min = ( a + x - 1 ) // x <NEWLINE> print ( max - min + 1 ) <NEWLINE>
<COMMENT> <NL> import sys <NEWLINE> <COMMENT> <NL> sysread = sys . stdin . buffer . readline <NEWLINE> read = sys . stdin . buffer . read <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> def run ( ) : <NEWLINE> <INDENT> a , b , x = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = 0 <NEWLINE> if a == 0 : <NEWLINE> <INDENT> a += 1 <NEWLINE> ans = 1 <NEWLINE> <DEDENT> ans += b // x - ( a - 1 ) // x <NEWLINE> print ( ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE>
import bisect , collections , copy , heapq , itertools , math , string , sys <NEWLINE> input = lambda : sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> INF = float ( <STRING> ) <NEWLINE> def I ( ) : return int ( input ( ) ) <NEWLINE> def F ( ) : return float ( input ( ) ) <NEWLINE> def SS ( ) : return input ( ) <NEWLINE> def LI ( ) : return [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> def LI_ ( ) : return [ int ( x ) - 1 for x in input ( ) . split ( ) ] <NEWLINE> def LF ( ) : return [ float ( x ) for x in input ( ) . split ( ) ] <NEWLINE> def LSS ( ) : return input ( ) . split ( ) <NEWLINE> <NL> def resolve ( ) : <NEWLINE> <INDENT> N , x = LI ( ) <NEWLINE> a = LI ( ) <NEWLINE> <NL> s = [ max ( a [ i ] + a [ i + 1 ] - x , 0 ) for i in range ( N - 1 ) ] <NEWLINE> <NL> ans = sum ( [ ss [ i ] for i in range ( len ( s ) ) if i % 2 == 0 ] ) <NEWLINE> print ( ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> resolve ( ) <NEWLINE> <DEDENT>
def candy ( ) : <NEWLINE> <INDENT> n = input ( ) . split ( ) <NEWLINE> N = int ( n [ 0 ] ) <NEWLINE> x = int ( n [ 1 ] ) <NEWLINE> alist = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> s = 0 <NEWLINE> for i in range ( 0 , N - 1 ) : <NEWLINE> <INDENT> c = alist [ i ] , d = alist [ i + 1 ] <NEWLINE> if int ( alist [ i ] + alist [ i + 1 ] ) > x : <NEWLINE> <INDENT> if int ( alist [ i ] ) >= x : <NEWLINE> <INDENT> alist [ i ] = x <NEWLINE> alist [ i + 1 ] = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> alist [ i + 1 ] = x - a [ i ] <NEWLINE> <DEDENT> s += c - alist [ i ] + d - alist [ i + 1 ] <NEWLINE> <DEDENT> / * <NEWLINE> if int ( alist [ i ] ) > x : <NEWLINE> <INDENT> s = s + int ( alist [ i + 1 ] ) <NEWLINE> alist [ i + 1 ] = 0 <NEWLINE> <NL> <DEDENT> if int ( alist [ i + 1 ] ) + int ( alist [ i ] ) > x : <NEWLINE> <INDENT> s = s + ( int ( alist [ i + 1 ] ) + int ( alist [ i ] ) - x ) <NEWLINE> alist [ i + 1 ] = x - int ( alist [ i ] ) <NEWLINE> <DEDENT> * / <NEWLINE> <DEDENT> print ( s ) <NEWLINE> <DEDENT> candy ( ) <NEWLINE>
import sys <NEWLINE> <NL> read = sys . stdin . read <NEWLINE> readline = sys . stdin . readline <NEWLINE> readlines = sys . stdin . readlines <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> INF = 1 << 60 <NEWLINE> MOD = 1000000007 <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> a , b , x = map ( int , readline ( ) . split ( ) ) <NEWLINE> <NL> if a == 0 : <NEWLINE> <INDENT> ans = b // x + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = b // x - ( a - 1 ) // x <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE> return <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> l = len ( s ) <NEWLINE> if s [ 0 ] == s [ - 1 ] : <NEWLINE> <INDENT> if l % 2 = 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if l % 2 = 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> import numpy as np <NEWLINE> import numba <NEWLINE> from numba import njit <NEWLINE> i8 = numba . int64 <NEWLINE> <NL> read = sys . stdin . buffer . read <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> readlines = sys . stdin . buffer . readlines <NEWLINE> <NL> @ njit ( ( i8 [ : ] , i8 , i8 ) , cache = True ) <NEWLINE> def test ( A , keta , n ) : <NEWLINE> <COMMENT> <NL> <INDENT> MOD = 10 ** ( keta + 1 ) <NEWLINE> I = [ ( n * 10 ** keta , ( n + 1 ) * 10 ** keta ) ] <COMMENT> <NEWLINE> for x in A : <NEWLINE> <INDENT> if I [ 0 ] [ 0 ] == 0 : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> newI = I . copy ( ) <NEWLINE> x %= MOD <NEWLINE> for l , r in I : <NEWLINE> <INDENT> l , r = l + MOD - x , r + MOD - x <NEWLINE> if l >= MOD : <NEWLINE> <INDENT> l , r = l - MOD , r - MOD <NEWLINE> <DEDENT> if r <= MOD : <NEWLINE> <INDENT> newI . append ( ( l , r ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> newI . append ( ( l , MOD ) ) <NEWLINE> newI . append ( ( 0 , r - MOD ) ) <NEWLINE> <DEDENT> <DEDENT> I = newI <NEWLINE> I . sort ( key = lambda x : x [ 1 ] ) <NEWLINE> newI = [ ( 0 , 0 ) ] * 0 <NEWLINE> for x , y in I : <NEWLINE> <INDENT> while newI and newI [ - 1 ] [ 1 ] >= x : <COMMENT> <NEWLINE> <INDENT> x , y = min ( x , newI [ - 1 ] [ 0 ] ) , y <NEWLINE> newI . pop ( ) <NEWLINE> <DEDENT> newI . append ( ( x , y ) ) <NEWLINE> <DEDENT> I = newI <NEWLINE> <DEDENT> return I [ 0 ] [ 0 ] == 0 <NEWLINE> <NL> <DEDENT> def main ( A ) : <NEWLINE> <INDENT> N = len ( A ) <NEWLINE> ans = 0 <NEWLINE> for keta in range ( 18 ) : <NEWLINE> <INDENT> for x in range ( 9 , 0 , - 1 ) : <NEWLINE> <INDENT> if test ( A , keta , x ) : <NEWLINE> <INDENT> ans += x <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return ans <NEWLINE> <NL> <DEDENT> A = np . array ( read ( ) . split ( ) , np . int64 ) [ 1 : ] <NEWLINE> np . random . shuffle ( A ) <NEWLINE> print ( main ( A ) ) <NEWLINE>
H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> flag = False <NEWLINE> for i in range ( H ) : <NEWLINE> <INDENT> for j in range ( W ) : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> if s == <STRING> : <NEWLINE> <INDENT> print ( chr ( ord ( <STRING> ) + j ) + str ( i + 1 ) ) <NEWLINE> flag = True <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if flag : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT>
alpha = { 1 : <STRING> , 2 : <STRING> , 3 : <STRING> , 4 : <STRING> , 5 : <STRING> , 6 : <STRING> , 7 : <STRING> , 8 : <STRING> , 9 : <STRING> , 10 : <STRING> , 11 : <STRING> , 12 : <STRING> , 13 : <STRING> , 14 : <STRING> , 15 : <STRING> , 16 : <STRING> , 17 : <STRING> , 18 : <STRING> , 19 : <STRING> , 20 : <STRING> , 21 : <STRING> , 22 : <STRING> , 23 : <STRING> , 24 : <STRING> , 25 : <STRING> , 26 : <STRING> } <NEWLINE> h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> for i in range ( h ) : <NEWLINE> <INDENT> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for j in range ( w ) : <NEWLINE> <INDENT> if a [ j ] == <STRING> : <NEWLINE> <INDENT> ans = alpha [ j + 1 ] + str ( i + 1 ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> <NL> def ts ( x ) : <NEWLINE> <INDENT> return x * ( x + 1 ) <NEWLINE> <NL> <NL> <DEDENT> m = n <NEWLINE> for i in range ( math . ceil ( math . sqrt ( 2 * n ) - 2 ) , math . floor ( math . sqrt ( 2 * n ) ) + 1 , 1 ) : <NEWLINE> <INDENT> if ts ( i ) < 2 * n <= ts ( i + 1 ) : <NEWLINE> <INDENT> m = i + 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> a = n % ( m + 1 ) <NEWLINE> b = n // ( m + 1 ) <NEWLINE> <NL> if m % 2 == 0 : <NEWLINE> <INDENT> if a != 0 : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <DEDENT> i = 1 <NEWLINE> c = 0 <NEWLINE> while c != b : <NEWLINE> <INDENT> if i != a and m + 1 - i != a : <NEWLINE> <INDENT> print ( i ) <NEWLINE> print ( m + 1 - i ) <NEWLINE> c += 1 <NEWLINE> <DEDENT> i += 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> <STRING> <NEWLINE> print ( m ) <NEWLINE> n -= m <NEWLINE> m -= 1 <NEWLINE> <NL> a = n % ( m + 1 ) <NEWLINE> b = n // ( m + 1 ) <NEWLINE> if a != 0 : <NEWLINE> <INDENT> print ( a ) <NEWLINE> i = 1 <NEWLINE> c = 0 <NEWLINE> while c != b : <NEWLINE> <INDENT> if i != a and m + 1 - i != a : <NEWLINE> <INDENT> print ( i ) <NEWLINE> print ( m + 1 - i ) <NEWLINE> c += 1 <NEWLINE> <DEDENT> i += 1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT>
import sys <NEWLINE> from collections import defaultdict ( int ) <NEWLINE> <NL> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> input = sys . stdin . readline <NEWLINE> f_inf = float ( <STRING> ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> <NL> def resolve ( ) : <NEWLINE> <INDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> X = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> MOD = [ defaultdict ( int ) for _ in range ( m + 1 ) ] <NEWLINE> cnt = defaultdict ( int ) <NEWLINE> for x in X : <NEWLINE> <INDENT> MOD [ x % m ] [ x ] += 1 <NEWLINE> cnt [ x % m ] += 1 <NEWLINE> <NL> <DEDENT> res = cnt [ 0 ] // 2 <NEWLINE> if m % 2 == 0 : <NEWLINE> <INDENT> res += cnt [ m // 2 ] // 2 <NEWLINE> <NL> <DEDENT> for i in range ( 1 , ( m + 1 ) // 2 ) : <NEWLINE> <INDENT> res += min ( cnt [ i ] , cnt [ m - i ] ) <NEWLINE> <NL> if cnt [ i ] > cnt [ m - i ] : <NEWLINE> <INDENT> diff = ( cnt [ i ] - cnt [ m - i ] ) // 2 <NEWLINE> for v in MOD [ i ] . values ( ) : <NEWLINE> <INDENT> if diff == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> t = min ( diff , v // 2 ) <NEWLINE> diff -= t <NEWLINE> res += t <NEWLINE> <DEDENT> <DEDENT> elif cnt [ i ] < cnt [ m - i ] : <NEWLINE> <INDENT> diff = ( cnt [ m - i ] - cnt [ i ] ) // 2 <NEWLINE> for v in MOD [ m - i ] . values ( ) : <NEWLINE> <INDENT> if diff == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> t = min ( diff , v // 2 ) <NEWLINE> diff -= t <NEWLINE> res += t <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( res ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> resolve ( ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> x = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> xmod = [ y % m for y in x ] <NEWLINE> from collections import Counter <NEWLINE> cx = dict ( Counter ( x ) ) <NEWLINE> cxmod = dict ( Counter ( xmod ) ) <NEWLINE> ans1 , ans2 = 0 , 0 <COMMENT> <NEWLINE> for k in cxmod . keys ( ) : <NEWLINE> <INDENT> if k == 0 : <NEWLINE> <INDENT> ans1 += cxmod [ k ] // 2 <NEWLINE> cxmod [ k ] -= 2 * ( cxmod [ k ] // 2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if k == m - k : <NEWLINE> <INDENT> ans1 += cxmod [ k ] // 2 <NEWLINE> cxmod [ k ] -= 2 * ( cxmod [ k ] // 2 ) <NEWLINE> <DEDENT> elif m - k in keys : <NEWLINE> <INDENT> tmp = min ( cxmod [ k ] , cxmod [ m - k ] ) <NEWLINE> ans1 += tmp <NEWLINE> cxmod [ k ] -= tmp <NEWLINE> cxmod [ m - k ] -= tmp <NEWLINE> <DEDENT> <DEDENT> <DEDENT> for k in cx : <NEWLINE> <INDENT> v = cx [ k ] <NEWLINE> if v >= 2 and cxmod [ k % m ] >= 2 : <NEWLINE> <INDENT> tmp = min ( v // 2 , cxmod [ k % m ] // 2 ) <NEWLINE> ans2 += tmp <NEWLINE> cxmod [ k % m ] -= tmp * 2 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans1 + ans2 ) <NEWLINE> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <NL> <DEDENT>
h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> s = [ list ( input ( ) . split ( ) ) for i in range ( h ) ] <NEWLINE> alp = <STRING> <NEWLINE> for i in range ( h ) : <NEWLINE> <INDENT> for j in range ( w ) : <NEWLINE> <INDENT> if s [ i ] [ j ] == <STRING> : <NEWLINE> <INDENT> print ( alp [ j + 1 ] + ( i + 1 ) ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ input ( ) . split ( ) for i in range ( h ) ] <NEWLINE> for i in range ( h ) : <NEWLINE> <INDENT> for j in range ( w ) : <NEWLINE> <INDENT> if a [ i ] [ w ] == <STRING> : <NEWLINE> <INDENT> print ( chr ( ord ( <STRING> ) + j ) + str ( i + 1 ) ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> if n < 3 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> table = [ [ 0 ] * 5 for i in range ( 11 ) ] <NEWLINE> for i in range ( 11 ) : <NEWLINE> <INDENT> for j in range ( 5 ) : <NEWLINE> <INDENT> t = 9 * ( j + 2 + 7 * ( i + 1 ) ) <NEWLINE> table [ i ] [ j ] = t % 11 <NEWLINE> <NL> <DEDENT> <DEDENT> c = [ 0 ] <NEWLINE> for row in table : <NEWLINE> <INDENT> c . append ( c [ - 1 ] + row . count ( K ) ) <NEWLINE> <NL> <DEDENT> d , m = divmod ( n - 2 , 11 ) <NEWLINE> ans = c [ m ] + c [ - 1 ] * d <NEWLINE> print ( ans ) <NEWLINE>
import sys <NEWLINE> import numpy as np <NEWLINE> import numba <NEWLINE> from numba import njit <NEWLINE> i8 = numba . int64 <NEWLINE> <NL> read = sys . stdin . buffer . read <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> readlines = sys . stdin . buffer . readlines <NEWLINE> <NL> @ njit ( ( i8 [ : ] , ) , cache = True ) <NEWLINE> def build ( raw_data ) : <NEWLINE> <INDENT> bit = raw_data . copy ( ) <NEWLINE> for i in range ( len ( bit ) ) : <NEWLINE> <INDENT> j = i + ( i & ( - i ) ) <NEWLINE> if j < len ( bit ) : <NEWLINE> <INDENT> bit [ j ] += bit [ i ] <NEWLINE> <DEDENT> <DEDENT> return bit <NEWLINE> <NL> <NL> <DEDENT> @ njit ( ( i8 [ : ] , i8 ) , cache = True ) <NEWLINE> def get_sum ( bit , i ) : <NEWLINE> <INDENT> s = 0 <NEWLINE> while i : <NEWLINE> <INDENT> s += bit [ i ] <NEWLINE> i -= i & - i <NEWLINE> <DEDENT> return s <NEWLINE> <NL> <NL> <DEDENT> @ njit ( ( i8 [ : ] , i8 , i8 ) , cache = True ) <NEWLINE> def add ( bit , i , x ) : <NEWLINE> <INDENT> while i < len ( bit ) : <NEWLINE> <INDENT> bit [ i ] += x <NEWLINE> i += i & - i <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> @ njit ( ( i8 [ : ] , i8 ) , cache = True ) <NEWLINE> def find_kth_element ( bit , k ) : <NEWLINE> <INDENT> N = len ( bit ) <NEWLINE> x , sx = 0 , 0 <NEWLINE> dx = 1 <NEWLINE> while 2 * dx < N : <NEWLINE> <INDENT> dx *= 2 <NEWLINE> <DEDENT> while dx : <NEWLINE> <INDENT> y = x + dx <NEWLINE> if y < N : <NEWLINE> <INDENT> sy = sx + bit [ y ] <NEWLINE> if sy < k : <NEWLINE> <INDENT> x , sx = y , sy <NEWLINE> <DEDENT> <DEDENT> dx //= 2 <NEWLINE> <DEDENT> return x + 1 <NEWLINE> <NL> <DEDENT> @ njit ( ( i8 , i8 [ : ] ) , cache = True ) <NEWLINE> def main ( N , AB ) : <NEWLINE> <INDENT> A , B = AB [ : : 2 ] , AB [ 1 : : 2 ] <NEWLINE> Q = len ( A ) <NEWLINE> <NL> bit = np . zeros ( N + 1 , np . int64 ) <COMMENT> <NEWLINE> bit_raw = np . zeros ( N + 1 , np . int64 ) <NEWLINE> H = np . zeros ( N + 1 , np . int64 ) <COMMENT> <NEWLINE> H [ 0 ] = 10 ** 13 + 10 <NEWLINE> bit_raw [ N ] = 1 <NEWLINE> add ( bit , N , 1 ) <NEWLINE> <NL> for i in range ( Q ) : <NEWLINE> <INDENT> a , b = A [ i ] , B [ i ] <NEWLINE> n = get_sum ( bit , a - 1 ) <NEWLINE> h = H [ find_kth_element ( bit , 1 + n ) ] <NEWLINE> if not bit_raw [ a ] : <NEWLINE> <INDENT> bit_raw [ a ] = 1 <NEWLINE> add ( bit , a , 1 ) <NEWLINE> H [ a ] = h <NEWLINE> <DEDENT> r = a <NEWLINE> <NL> while b : <NEWLINE> <INDENT> l = 0 if n == 0 else find_kth_element ( bit , n ) <NEWLINE> n -= 1 <NEWLINE> area = ( H [ l ] - H [ r ] ) * ( r - l ) <NEWLINE> if area <= b : <NEWLINE> <INDENT> b -= area <NEWLINE> if l : <NEWLINE> <INDENT> bit_raw [ l ] = 0 <NEWLINE> add ( bit , l , - 1 ) <NEWLINE> <DEDENT> H [ l ] , H [ r ] = 0 , H [ l ] <NEWLINE> continue <NEWLINE> <DEDENT> k = b // ( r - l ) <NEWLINE> b -= k * ( r - l ) <NEWLINE> H [ r ] += k <NEWLINE> if b : <NEWLINE> <INDENT> m = l + b <NEWLINE> bit_raw [ m ] = 1 <NEWLINE> add ( bit , m , 1 ) <NEWLINE> H [ m ] = H [ r ] + 1 <NEWLINE> b = 0 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> for n in range ( N , 0 , - 1 ) : <NEWLINE> <INDENT> H [ n - 1 ] = max ( H [ n - 1 ] , H [ n ] ) <NEWLINE> <DEDENT> return H [ 1 : N + 1 ] <NEWLINE> <NL> <DEDENT> N , Q = map ( int , readline ( ) . split ( ) ) <NEWLINE> AB = np . array ( read ( ) . split ( ) , np . int64 ) <NEWLINE> <NL> ans = main ( N , AB ) <NEWLINE> print ( <STRING> . join ( map ( str , ans . tolist ( ) ) ) ) <NEWLINE>
h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ list ( input ( ) ) for _ in range ( H ) ] <NEWLINE> c = 0 <NEWLINE> for p in a : <NEWLINE> <INDENT> for q in p : <NEWLINE> <INDENT> if q == <STRING> : <NEWLINE> <INDENT> c += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if c == h + w - 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
H , W = 4 , 5 <NEWLINE> a = [ input ( ) for i in range ( H ) ] <NEWLINE> <NL> <NL> ans = 0 <NEWLINE> cnt = 0 <NEWLINE> <NL> for i in range ( H - 1 ) : <NEWLINE> <INDENT> for j in range ( W - 1 ) : <NEWLINE> <INDENT> if a [ i ] [ j ] == <STRING> and a [ i + 1 ] [ j ] == <STRING> and a [ i ] [ j + 1 ] == <STRING> : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> break <NEWLINE> <DEDENT> elif a [ i ] [ j ] == <STRING> and a [ i + 1 ] [ j ] == <STRING> and a [ i ] [ j + 1 ] == <STRING> : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> if cnt > 0 else <STRING> ) <NEWLINE> <NL>
a = int ( input ( ) ) <NEWLINE> b = int ( input ( ) ) <NEWLINE> c = int ( input ( ) ) <NEWLINE> <NL> if a == b + c or b == a + c or c == a + b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
def MAP ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> x = sorted ( MAP ( x ) ) <NEWLINE> if x [ 0 ] + x [ 1 ] == x [ 2 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b , c = int ( input ( ) ) , int ( input ( ) ) , int ( input ( ) ) <NEWLINE> if a + b == c or a + c == b or b + c == a : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if a + b == c : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif : <NEWLINE> <INDENT> a + c == b : <NEWLINE> print ( <STRING> ) <NEWLINE> <DEDENT> elif : <NEWLINE> <INDENT> a == b + c : <NEWLINE> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
L = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> print ( <STRING> if sum ( L [ : 2 ] == L [ 2 ] ) else <STRING> ) <NEWLINE>
x = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> y = sorted ( x ) <NEWLINE> if y [ 0 ] + y [ 1 ] = y [ 2 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
if ( a + b == c ) or ( a + c == b ) or ( b + c == a ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
<INDENT> a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <DEDENT> if ( ( a + b ) == c ) or ( ( b + c ) == a ) or ( ( c + a ) == b ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> if a + b == c pr a + c == b or b + c == a : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> if a + b = c or b + c = a or c + a = b : <NEWLINE> <INDENT> print ( Yes ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( No ) <NEWLINE> <DEDENT>
import sys <NEWLINE> sys . setrecursionlimit ( 250000 ) <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if a == b + c : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif b == a + c : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif c == a + b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> main ( ) <NEWLINE>
a , b , c = int ( input . split ( ) ) <NEWLINE> if a + b == c : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a + c == b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif b + c == a : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b , c = ( int ( T ) for T in input ( ) . split ( ) ) <NEWLINE> print ( [ <STRING> , <STRING> ] [ ( a + ab ) == c or ( b + c ) == a or ( c + a ) == b ] ) <NEWLINE>
a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if ( a + b + c ) % 3 == 0 : P <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a = list ( map , int ( input ( ) . split ( ) ) ) <NEWLINE> a . sort ( ) <NEWLINE> <NL> if a [ 0 ] + a [ 1 ] == a [ 2 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> b = a . sort ( ) <NEWLINE> print ( b ) <NEWLINE> print ( <STRING> if b [ 0 ] + b [ 1 ] == b [ 2 ] else <STRING> ) <NEWLINE>
x = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if x [ 0 ] + x [ 1 ] == x [ 2 ] or x [ 1 ] + x [ 2 ] = x [ 0 ] or x [ 0 ] + x [ 2 ] == x [ 1 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> a = int ( input ( ) ) <NEWLINE> b = int ( input ( ) ) <NEWLINE> c = int ( input ( ) ) <NEWLINE> <NL> <COMMENT> <NL> if a == b + c or b == a + c or c == a + b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
ys = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ys . sort ( ) <NEWLINE> print ( <STRING> if ys [ 0 ] + ys [ 1 ] == y [ 2 ] else <STRING> ) <NEWLINE>
a = list ( map ( int , input ( ) ) ) <NEWLINE> a . sort ( ) <NEWLINE> print ( <STRING> ) if max ( a [ 2 ] == a [ 1 ] + a [ 0 ] ) else print ( <STRING> ) <NEWLINE>
list . sort ( l , reverse = True ) <NEWLINE> a = int ( l [ 0 ] ) <NEWLINE> b = int ( l [ 1 ] ) <NEWLINE> c = int ( l [ 2 ] ) <NEWLINE> if a == b + c : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> if a + b = c or a + c = b or b + c = a : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
abc = map ( int , input ( ) . split ( ) ) <NEWLINE> abc . sort ( ) <NEWLINE> if abc [ 0 ] + abc [ 1 ] == abc [ 2 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
lst = list ( map ( int , input ( ) . split ) ) <NEWLINE> lst . sort ( ) <NEWLINE> if lst [ 0 ] + lst [ 1 ] == lst [ 2 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if a + b = c or a + c = b or b + c = a : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
p = list ( map ( int , input ( ) . split ( ) ) ) . sort ( ) <NEWLINE> print ( <STRING> if p [ 0 ] + p [ 1 ] == p [ 2 ] else <STRING> ) <NEWLINE>
W , H , N = map ( int , input ( ) . split ( ) ) <NEWLINE> List = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> List . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <DEDENT> WRange = [ 0 , W ] <NEWLINE> HRange = [ 0 , H ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if List [ i ] [ 2 ] == 1 : <NEWLINE> <INDENT> WRange [ 0 ] = List [ i ] [ 0 ] <NEWLINE> <DEDENT> elif List [ i ] [ 2 ] == 2 : <NEWLINE> <INDENT> WRange [ 1 ] = List [ i ] [ 0 ] <NEWLINE> <DEDENT> elif List [ i ] [ 2 ] == 3 : <NEWLINE> <INDENT> HRange [ 0 ] = List [ i ] [ 1 ] <NEWLINE> <DEDENT> else List [ i ] [ 2 ] == 4 : <NEWLINE> <INDENT> HRange [ 1 ] = List [ i ] [ 1 ] <NEWLINE> <DEDENT> <DEDENT> if WRange [ 1 ] - WRange [ 0 ] > 0 : <NEWLINE> <INDENT> W = WRange [ 1 ] - WRange [ 0 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> W = 0 <NEWLINE> <DEDENT> if HRange [ 1 ] - HRange [ 0 ] > 0 : <NEWLINE> <INDENT> H = HRange [ 1 ] - HRange [ 0 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> H = 0 <NEWLINE> <DEDENT> res = H * W <NEWLINE> print ( res ) <NEWLINE>
<COMMENT> <NL> L = [ ] <NEWLINE> Q = [ ] <NEWLINE> <NL> <COMMENT> <NL> W , H , N , = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> L . append ( map ( int , raw_input ( ) . split ( ) ) ) <NEWLINE> <DEDENT> x1 = 0 <NEWLINE> x2 = W <NEWLINE> y1 = 0 <NEWLINE> y2 = H <NEWLINE> <NL> <COMMENT> <NL> Q = [ row [ 2 ] for row in L ] <NEWLINE> <NL> <NL> for k in range ( N ) : <NEWLINE> <INDENT> if Q [ k ] == 1 : <NEWLINE> <INDENT> x1 = max ( x1 , L [ k ] [ 0 ] ) <NEWLINE> <DEDENT> elif Q [ k ] == 2 : <NEWLINE> <INDENT> x2 = min ( x2 , L [ k ] [ 0 ] ) <NEWLINE> <DEDENT> elif Q [ k ] == 3 : <NEWLINE> <INDENT> y1 = max ( y1 , L [ k ] [ 1 ] ) <NEWLINE> <DEDENT> elif Q [ k ] == 4 : <NEWLINE> <INDENT> y2 = min ( y2 , L [ k ] [ 1 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( max ( 0 , x2 - x1 ) * max ( 0 , y2 - y1 ) ) <NEWLINE>
W , H , N = map ( int , input ( ) . split ( ) ) <NEWLINE> hen = [ 0 , W , 0 , H ] <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> x , y , a = map ( int , input ( ) . split ( ) ) <NEWLINE> if a == 1 : <NEWLINE> <INDENT> heb [ a - 1 ] = max ( hen [ a - 1 ] , x ) <NEWLINE> <DEDENT> elif a == 2 : <NEWLINE> <INDENT> hen [ a - 1 ] = min ( hen [ a - 1 ] , x ) <NEWLINE> <DEDENT> elif a == 3 : <NEWLINE> <INDENT> hen [ a - 1 ] = max ( hen [ a - 1 ] , y ) <NEWLINE> <DEDENT> elif a == 4 : <NEWLINE> <INDENT> hen [ a - 1 ] = min ( hen [ a - 1 ] , y ) <NEWLINE> <DEDENT> <DEDENT> yoko = hen [ 1 ] - hen [ 0 ] <NEWLINE> tate = hen [ 3 ] - hen [ 2 ] <NEWLINE> if yoko < 0 or tate < 0 : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = yoko * tate <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
w , h , n = map ( int , input ( ) . split ( ) ) <NEWLINE> x = [ ] <NEWLINE> y = [ ] <NEWLINE> a = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> s = map ( int , input ( ) . split ( ) ) <NEWLINE> x . append ( s [ 0 ] ) <NEWLINE> y . append ( s [ 1 ] ) <NEWLINE> a . append ( s [ 2 ] ) <NEWLINE> <DEDENT> x_l = 0 <NEWLINE> x_h = w <NEWLINE> y_l = 0 <NEWLINE> y_h = h <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if a [ i ] == 1 : <NEWLINE> <INDENT> if x_l < x [ i ] : <NEWLINE> <INDENT> x_l = x [ i ] <NEWLINE> <DEDENT> <DEDENT> elif a [ i ] == 2 : <NEWLINE> <INDENT> if x_h > x [ i ] : <NEWLINE> <INDENT> x_h = x [ i ] <NEWLINE> <DEDENT> <DEDENT> elif a [ i ] == 3 : <NEWLINE> <INDENT> if y_l < y [ i ] : <NEWLINE> <INDENT> y_l = y [ i ] <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if y_h > y [ i ] : <NEWLINE> <INDENT> y_h = y [ i ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> s = ( x_h - x_l ) * ( y_h - y_l ) <NEWLINE> if s > 0 : <NEWLINE> <INDENT> print ( s ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
W , H , N = map ( int . input ( ) . split ( ) ) <NEWLINE> a , b , c , d = 0 , W , 0 , H <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> x , y , A = map ( int . input ( ) . split ( ) ) <NEWLINE> if A == 1 : <NEWLINE> <INDENT> a = max ( a , x ) <NEWLINE> <DEDENT> if A == 2 : <NEWLINE> <INDENT> b = min ( b , x ) <NEWLINE> <DEDENT> if A == 3 : <NEWLINE> <INDENT> c = max ( c , y ) <NEWLINE> <DEDENT> if A == 4 : <NEWLINE> <INDENT> d = min ( d , y ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( max ( 0 , b - a ) * max ( 0 , d - c ) ) <NEWLINE>
def p_grid ( w , h ) : <NEWLINE> <INDENT> for i in range ( h ) : <NEWLINE> <INDENT> for j in range ( w ) : <NEWLINE> <INDENT> print ( grid [ j + w * i ] , end = <STRING> ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> def coloring ( ) : <NEWLINE> <INDENT> line = input ( ) <NEWLINE> words = line . split ( ) <NEWLINE> W = int ( words [ 0 ] ) <NEWLINE> H = int ( words [ 1 ] ) <NEWLINE> N = int ( words [ 2 ] ) <NEWLINE> <NL> x = 0 <NEWLINE> y = 0 <NEWLINE> w = W <NEWLINE> h = H <NEWLINE> <NL> grid = [ ] <NEWLINE> <NL> for i in range ( h ) : <NEWLINE> <INDENT> for j in range ( w ) : <NEWLINE> <INDENT> grid . append ( 0 ) <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> ws = s . split ( ) <NEWLINE> x = int ( ws [ 0 ] ) <NEWLINE> y = int ( ws [ 1 ] ) <NEWLINE> a = int ( ws [ 2 ] ) <NEWLINE> if a == 1 or a == 3 : <NEWLINE> <COMMENT> <NL> <INDENT> for i in range ( y ) : <NEWLINE> <INDENT> for j in range ( x ) : <NEWLINE> <INDENT> grid [ j + w * i ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( h ) : <NEWLINE> for j in range ( w ) : <NEWLINE> <INDENT> print ( grid [ j + w * i ] , end = <STRING> ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> <NL> <DEDENT> if a == 2 : <NEWLINE> <COMMENT> <NL> <INDENT> for i in range ( y ) : <NEWLINE> <INDENT> for j in range ( x , w ) : <NEWLINE> <INDENT> grid [ j + w * i ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( h ) : <NEWLINE> for j in range ( w ) : <NEWLINE> <INDENT> print ( grid [ j + w * i ] , end = <STRING> ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> <NL> <DEDENT> if a == 4 : <NEWLINE> <COMMENT> <NL> <INDENT> for i in range ( y , h ) : <NEWLINE> <INDENT> for j in range ( x ) : <NEWLINE> <INDENT> grid [ j + w * i ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( h ) : <NEWLINE> for j in range ( w ) : <NEWLINE> <INDENT> print ( grid [ j + w * i ] , end = <STRING> ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( grid . count ( 0 ) ) <NEWLINE> <NL> <NL> <NL> <NL> <DEDENT> coloring ( ) <NEWLINE>
import sys <NEWLINE> <NL> def nextrec ( coor , pt ) : <NEWLINE> <INDENT> if pt [ 2 ] == 1 : <NEWLINE> <INDENT> coor [ 0 ] = min ( max ( coor [ 0 ] , pt [ 0 ] ) , coor [ 2 ] ) <NEWLINE> <DEDENT> elif pt [ 2 ] == 2 : <NEWLINE> <INDENT> coor [ 2 ] = max ( min ( coor [ 2 ] , pt [ 0 ] ) , coor [ 0 ] ) <NEWLINE> <DEDENT> elif pt [ 2 ] == 3 : <NEWLINE> <INDENT> coor [ 1 ] = min ( max ( coor [ 1 ] , pt [ 1 ] ) , coor [ 3 ] ) <NEWLINE> <DEDENT> elif pt [ 2 ] == 4 : <NEWLINE> <INDENT> coor [ 3 ] = max ( min ( coor [ 3 ] , pt [ 1 ] ) , coor [ 1 ] ) <NEWLINE> <DEDENT> <DEDENT> def main ( w , h , n , pts ) : <NEWLINE> <INDENT> rec = [ 0 , 0 , w , h ] <NEWLINE> for x in range ( n ) : <NEWLINE> <INDENT> nextrec ( rec , pt [ x ] ) : <NEWLINE> <DEDENT> return ( rec [ 0 ] - rec [ 2 ] ) * ( rec [ 1 ] - rec [ 3 ] ) <NEWLINE> <NL> <DEDENT> w , h , n = map ( int , sys . stdin . readline ( ) . strip ( ) . split ( ) ) <NEWLINE> pts = [ list ( map ( int , sys . stdin . readline ( ) . strip ( ) . split ( ) ) ) for x in range ( n ) ] <NEWLINE> <NL> print ( main ( w , h , n , pts ) ) <NEWLINE>
W , H , N = map ( int , input ( ) . split ( ) ) <NEWLINE> xya = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( N ) ] <NEWLINE> <NL> S = [ [ 1 ] * W for _ in range ( H ) ] <NEWLINE> for x , y , a in xya : <NEWLINE> <INDENT> if a == 1 : <NEWLINE> <INDENT> for i in range ( H ) : <NEWLINE> <INDENT> for j in range ( x ) : <NEWLINE> <INDENT> S [ i ] [ j ] = 0 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> elif a == 2 : <NEWLINE> <INDENT> for i in range ( x , W ) : <NEWLINE> <INDENT> for j in range ( x , W ) <NEWLINE> <INDENT> S [ i ] [ j ] = 0 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> elif a == 3 : <NEWLINE> <INDENT> for i in range ( y ) : <NEWLINE> <INDENT> for j in range ( W ) : <NEWLINE> <INDENT> S [ i ] [ j ] = 0 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( y , H ) : <NEWLINE> <INDENT> for j in range ( W ) : <NEWLINE> <INDENT> S [ i ] [ j ] = 0 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( sum ( S ) ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> import sys <NEWLINE> from io import StringIO <NEWLINE> import unittest <NEWLINE> <NL> <NL> class TestClass ( unittest . TestCase ) : <NEWLINE> <INDENT> def assertIO ( self , input , output ) : <NEWLINE> <INDENT> stdout , stdin = sys . stdout , sys . stdin <NEWLINE> sys . stdout , sys . stdin = StringIO ( ) , StringIO ( input ) <NEWLINE> resolve ( ) <NEWLINE> sys . stdout . seek ( 0 ) <NEWLINE> out = sys . stdout . read ( ) [ : - 1 ] <NEWLINE> sys . stdout , sys . stdin = stdout , stdin <NEWLINE> self . assertEqual ( out , output ) <NEWLINE> <NL> <DEDENT> def test__1 ( self ) : <NEWLINE> <INDENT> input = <STRING> <NEWLINE> output = <STRING> <NEWLINE> self . assertIO ( input , output ) <NEWLINE> <NL> <DEDENT> def test__2 ( self ) : <NEWLINE> <INDENT> input = <STRING> <NEWLINE> output = <STRING> <NEWLINE> self . assertIO ( input , output ) <NEWLINE> <NL> <DEDENT> def test__3 ( self ) : <NEWLINE> <INDENT> input = <STRING> <NEWLINE> output = <STRING> <NEWLINE> self . assertIO ( input , output ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def resolve ( ) : <NEWLINE> <INDENT> W , H , N = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ ] <NEWLINE> ox = 0 <NEWLINE> oy = 0 <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> a . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> if a [ i ] [ 2 ] == 1 : <NEWLINE> <INDENT> ox = max ( a [ i ] [ 0 ] , ox ) <NEWLINE> <DEDENT> elif a [ i ] [ 2 ] == 2 : <NEWLINE> <INDENT> W = min ( a [ i ] [ 0 ] , W ) <NEWLINE> <DEDENT> elif a [ i ] [ 2 ] == 3 : <NEWLINE> <INDENT> oy = max ( a [ i ] [ 1 ] , oy ) <NEWLINE> <DEDENT> elif a [ i ] [ 2 ] == 4 : <NEWLINE> <INDENT> H = min ( a [ i ] [ 1 ] , H ) <NEWLINE> <DEDENT> <DEDENT> print ( max ( ( W - ox ) ) * max ( ( H - oy ) , 0 ) ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <COMMENT> <NL> <INDENT> resolve ( ) <NEWLINE> <DEDENT>
a = input ( ) <NEWLINE> b = 0 <NEWLINE> for i in range ( len ( a ) - 1 ) : <NEWLINE> <INDENT> a [ i ] != a [ i + 1 ] : <NEWLINE> <INDENT> b = b + 1 <NEWLINE> <DEDENT> <DEDENT> if a [ - 2 ] != a [ - 1 ] : <NEWLINE> <INDENT> b = b + 1 <NEWLINE> <DEDENT> print ( b ) <NEWLINE>
S = input ( ) <NEWLINE> X = S [ 0 ] <NEWLINE> ans = 0 <NEWLINE> while 1 : <NEWLINE> <INDENT> for i in range ( S ) : <NEWLINE> <INDENT> if S [ i ] != X : <NEWLINE> <INDENT> ans += 1 <NEWLINE> X = S [ i ] <NEWLINE> S = S [ i : ] <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL>
s = input ( ) <NEWLINE> ans = 0 <NEWLINE> <NL> for i in range ( len ( s ) - 1 ) : <NEWLINE> <INDENT> if s [ i ] != S [ i + 1 ] : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
S = input ( ) <NEWLINE> cntb = 1000000 if if S [ 0 ] == <STRING> and S [ - 1 ] == <STRING> else 0 <NEWLINE> cntw = 1000000 if S [ 0 ] == <STRING> and S [ - 1 ] == <STRING> else 0 <NEWLINE> for s in S . split ( <STRING> ) : <NEWLINE> <INDENT> if s != <STRING> : <NEWLINE> <INDENT> cntb += 1 <NEWLINE> <DEDENT> <DEDENT> for s in S . split ( <STRING> ) : <NEWLINE> <INDENT> if s != <STRING> : <NEWLINE> <INDENT> cntw += 1 <NEWLINE> <DEDENT> <DEDENT> print ( min ( cntb , cntw ) ) <NEWLINE>
<INDENT> def main ( ) : <NEWLINE> <INDENT> s = str ( input ( ) ) <NEWLINE> b_count = s . count ( <STRING> ) <NEWLINE> w_count = len ( s ) - b_count <NEWLINE> <NL> if b_count == len ( s ) or w_count == len ( s ) : <NEWLINE> <INDENT> count = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> count = 0 <NEWLINE> index = 0 <NEWLINE> alp = s [ index ] <NEWLINE> <NL> while True : <NEWLINE> <INDENT> if b_count == 0 or w_count == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if s [ index ] == <STRING> : <NEWLINE> <INDENT> b_count -= 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> w_count -= 1 <NEWLINE> <NL> <DEDENT> if s [ index ] == alp : <NEWLINE> <INDENT> index += 1 <NEWLINE> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> count += 1 <NEWLINE> alp = s [ index ] <NEWLINE> index += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if not ( b_count == 0 and w_count == 0 ) : <NEWLINE> <INDENT> count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( count ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
S = input ( ) <NEWLINE> List = list ( S ) <NEWLINE> trial = 0 <NEWLINE> for i in range ( 1 , len ( List ) ) : <NEWLINE> <INDENT> if List [ i ] != List [ i - 1 ] : <NEWLINE> <INDENT> trial += 1 <NEWLINE> <DEDENT> <DEDENT> print ( res ) <NEWLINE>
n = input ( ) <NEWLINE> gr = itertools . groupby ( n ) <NEWLINE> print ( len ( gr ) - 1 ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> using namespace std ; <NEWLINE> typedef long long ll ; <NEWLINE> <NL> int main ( ) { <NEWLINE> <INDENT> cin . tie ( 0 ) ; <NEWLINE> ios : : sync_with_stdio ( false ) ; <NEWLINE> string s ; <NEWLINE> int ans = 0 ; <NEWLINE> cin >> s ; <NEWLINE> rep ( i , s . size ( ) - 1 ) { <NEWLINE> <INDENT> if ( s [ i ] != s [ i + 1 ] ) { <NEWLINE> <INDENT> ans + + ; <NEWLINE> <DEDENT> } <NEWLINE> <DEDENT> } <NEWLINE> cout << ans << <STRING> ; <NEWLINE> <DEDENT> } <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> S = input ( ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> s = S [ 0 ] <NEWLINE> <NL> r = 0 <NEWLINE> <NL> for i in range ( 1 , len ( S ) ) : <NEWLINE> <INDENT> if s != S [ i ] : <NEWLINE> <INDENT> r += 1 <NEWLINE> <NL> <DEDENT> s = S [ i ] <NEWLINE> <NL> <DEDENT> print ( res ) <NEWLINE>
<COMMENT> <NL> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <NL> def calcGroup ( s ) : <NEWLINE> <INDENT> whiteCount = 0 <NEWLINE> blackCount = 0 <NEWLINE> prev = <STRING> <NEWLINE> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> if s [ i ] == prev : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if s [ i ] = <STRING> : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> elif s [ i ] = <STRING> : <NEWLINE> <INDENT> whiteCount += 1 <NEWLINE> <DEDENT> elif s [ i ] = <STRING> : <NEWLINE> <INDENT> blackCount += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> raise ValueError <NEWLINE> <DEDENT> <DEDENT> prev = s [ i ] <NEWLINE> <DEDENT> return whiteCount , blackCount <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> def solve ( s ) : <NEWLINE> <COMMENT> <NL> <INDENT> return min ( calcGroup ( s ) ) <NEWLINE> <NL> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> print ( solve ( s ) ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
if ( n == len ( s ) and ( s == t ) ) : <NEWLINE> <INDENT> print ( n ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ind = [ 0 ] <NEWLINE> for i in range ( 1 , len ( s ) ) : <NEWLINE> <INDENT> if s [ - i : ] == t [ : i ] : <NEWLINE> <INDENT> ind . append ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> ind . reverse ( ) <NEWLINE> for i in ind : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> print ( 2 * n ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> res = s [ 0 : - i ] + t <NEWLINE> if len ( res ) >= n : <NEWLINE> <INDENT> print ( len ( res ) ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> t = input ( ) <NEWLINE> <NL> for i in range ( n , 2 * n - 1 ) : <NEWLINE> <INDENT> if s [ : 2 * n - i ] == t [ 2 * n - i ] : <NEWLINE> <INDENT> print ( i ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( 2 * n ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> t = input ( ) <NEWLINE> while True : <NEWLINE> <INDENT> if s == t : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> s = s [ 1 : ] <NEWLINE> t = [ : - 1 ] <NEWLINE> n += 1 <NEWLINE> <DEDENT> print ( n ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> t = input ( ) <NEWLINE> answer = n <NEWLINE> for i in range ( n + 1 ) : <NEWLINE> <INDENT> if answer == n : <NEWLINE> <INDENT> newstring = s [ 0 : i ] + t [ : n ] <NEWLINE> if newstring [ 0 : n ] == s : <NEWLINE> <INDENT> answer += i <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( answer ) <NEWLINE>
n , x = map ( int , input ( ) . split ( ) ) <NEWLINE> if abs ( n - x ) <= 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> if n == x : <NEWLINE> <INDENT> for i in range ( 2 * ( n - 1 ) ) : <NEWLINE> <INDENT> print ( i + 1 ) <NEWLINE> <DEDENT> <DEDENT> elif x == n - 1 : <NEWLINE> <INDENT> print ( n ) <NEWLINE> for i in range ( 2 * ( n - 1 ) ) : <NEWLINE> <INDENT> if i != n : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else x == n - 1 : <NEWLINE> <INDENT> for i in range ( 2 * ( n - 1 ) ) : <NEWLINE> <INDENT> if i != n : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT> <DEDENT> print ( n ) <NEWLINE> <DEDENT>
n , x = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if x == 1 or x == 2 * n - 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif x == 2 * n - 2 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> print ( i + 1 ) <NEWLINE> <DEDENT> print ( x ) <NEWLINE> print ( 2 * n - 1 ) <NEWLINE> for i in range ( n - 1 , x - 1 ) : <NEWLINE> <INDENT> print ( i + 1 ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> l = [ i for i in range ( 1 , x - 1 ) ] + [ i for i in range ( x , 2 * n - 3 ) ] <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> print ( l [ i ] + 1 ) <NEWLINE> <DEDENT> print ( 2 * n - 1 ) <NEWLINE> print ( x ) <NEWLINE> print ( 1 ) <NEWLINE> print ( 2 * n - 2 ) <NEWLINE> for i in range ( n - 1 , 2 * n - 3 ) : <NEWLINE> <INDENT> print ( l [ i ] + 1 ) <NEWLINE> <DEDENT> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> a = s . find ( <STRING> ) <NEWLINE> if ( a == - 1 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else <NEWLINE> <INDENT> a2 = s . find ( <STRING> , a + 1 , len ( s ) ) <NEWLINE> if ( a2 == - 1 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> main ( ) <NEWLINE>
k , t = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> nums = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> m = max ( nums ) <NEWLINE> rest = k - m <NEWLINE> if max - rest - 1 > 0 : <NEWLINE> <INDENT> print ( max - rest - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) split ( ) ) ) <NEWLINE> s = max ( a ) <NEWLINE> print ( max ( 2 * s - n - 1 ) ) <NEWLINE>
K , T = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> A = sorted ( A , reverse = True ) <NEWLINE> <NL> print ( max ( 0 , A [ 0 ] - 1 - sum ( A [ 1 : ] ) ) <NEWLINE>
<COMMENT> <NL> import sys <NEWLINE> <COMMENT> <NL> sysread = sys . stdin . buffer . readline <NEWLINE> read = sys . stdin . buffer . read <NEWLINE> from heapq import heappop , heappush <NEWLINE> from collections import defaultdict <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> import math <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> from collections import deque <NEWLINE> <COMMENT> <NL> <NL> INF = 1 << 50 <NEWLINE> <NL> def run ( ) : <NEWLINE> <INDENT> K , T , * A = map ( int , read ( ) . split ( ) ) <NEWLINE> A = sorted ( A ) <NEWLINE> A = deque ( A ) <NEWLINE> high , low = 0 , 0 <NEWLINE> last = None <NEWLINE> while A : <NEWLINE> <COMMENT> <NL> <INDENT> if high == 1 : <NEWLINE> <INDENT> A . appendleft ( 1 ) <NEWLINE> high = A . pop ( ) <NEWLINE> <NL> <DEDENT> if not high : <NEWLINE> <INDENT> high = A . pop ( ) <NEWLINE> if high == 1 : break <NEWLINE> <DEDENT> elif not low : <NEWLINE> <INDENT> low = A . popleft ( ) <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> val = min ( low , high - 1 ) <NEWLINE> if not val : <NEWLINE> <INDENT> last = None <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> last = <STRING> <NEWLINE> <DEDENT> high -= val <NEWLINE> low -= val <NEWLINE> <COMMENT> <NL> <DEDENT> if high == 1 <NEWLINE> <INDENT> if last == None : <NEWLINE> <INDENT> print ( max ( low - high - 1 , 0 ) ) <NEWLINE> return <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( max ( low - 1 , 0 ) ) ) <NEWLINE> return <NEWLINE> <DEDENT> <DEDENT> print ( high - 1 + max ( low - 1 , 0 ) ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> run ( ) <NEWLINE> <DEDENT>
3 3 33 <NEWLINE>
a = set ( int , input ( ) . split ( ) ) <NEWLINE> print ( len ( a ) <NEWLINE>
l = set ( list ( map , input ( ) . split ( ) ) ) <NEWLINE> print ( len ( l ) ) <NEWLINE>
a = set ( map ( int , input ( ) ) ) <NEWLINE> print ( len ( a ) ) <NEWLINE>
a = input ( ) . split ( ) <NEWLINE> a . sort ( ) <NEWLINE> cnt = 0 <NEWLINE> while len ( s ) > 0 : <NEWLINE> <INDENT> i = a . count ( a . pop ( 0 ) ) <NEWLINE> for j in range ( i ) : <NEWLINE> <INDENT> a . pop ( 0 ) <NEWLINE> <DEDENT> cnt += 1 <NEWLINE> <DEDENT> print ( cnt ) <NEWLINE>
a = list ( map ( int , input ( ) ) ) <NEWLINE> print ( len ( set ( a ) ) ) <NEWLINE>
<COMMENT> <NL> lst = input ( ) . split ( ) <NEWLINE> <NL> <COMMENT> <NL> for i in range ( len ( lst ) ) : <NEWLINE> <INDENT> lst [ i ] = int ( lst [ i ] ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> lst . sort ( ) <NEWLINE> <NL> <COMMENT> <NL> if lst [ 0 ] == lst [ 2 ] <NEWLINE> <INDENT> print ( 3 ) <NEWLINE> <DEDENT> elif lst [ 0 ] == lst [ 1 ] or lst [ 1 ] == lst [ 2 ] : <NEWLINE> <INDENT> print ( 2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT>
print ( len ( set ( [ input ( ) for i in range ( 3 ) ] ) ) ) <NEWLINE>
s = list ( input ( ) . split ( ) ) <NEWLINE> print ( len ( set ( s ) ) <NEWLINE>
a = int ( input ( ) ) <NEWLINE> b = int ( input ( ) ) <NEWLINE> c = int ( input ( ) ) <NEWLINE> <NL> count = 0 <NEWLINE> <NL> if a != b : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> if b != c : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> if a != c : <NEWLINE> <INDENT> count += 1 <NEWLINE> <NL> <DEDENT> print ( int ( count / 2 ) ) <NEWLINE>
j = int ( input ( ) ) <NEWLINE> <NL> x = j . split ( ) <NEWLINE> y = [ ] <NEWLINE> <NL> for i in x : <NEWLINE> <INDENT> if ( i not in y ) : <NEWLINE> <INDENT> y . append ( i ) <NEWLINE> <DEDENT> <DEDENT> print ( len ( y ) ) <NEWLINE>
def paint ( ) : <NEWLINE> <INDENT> a = int ( input ( ) ) <NEWLINE> b = int ( input ( ) ) <NEWLINE> c = int ( input ( ) ) <NEWLINE> count = 1 <NEWLINE> if a != b : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> if a != c and b != c : <NEWLINE> <INDENT> count += 1 <NEWLINE> <NL> <DEDENT> print ( count ) <NEWLINE> <NL> <DEDENT> paint ( ) <NEWLINE>
s = set ( int ( input ( ) . split ( ) ) ) <NEWLINE> print ( len ( s ) ) <NEWLINE>
abc = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> if a == c : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> elif a == b or b == c : <NEWLINE> <INDENT> print ( 2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 3 ) <NEWLINE> <DEDENT>
a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> if a = b and b = c : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> elif a = b and a != c : <NEWLINE> <INDENT> print ( 2 ) <NEWLINE> <DEDENT> elif a != b and b = c : <NEWLINE> <INDENT> print ( 2 ) <NEWLINE> <DEDENT> elif a = c and a != b : <NEWLINE> <INDENT> print ( 2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 3 ) <NEWLINE> <DEDENT>
sample = input ( ) <NEWLINE> sample_list = sample . split ( <STRING> ) <NEWLINE> count = 0 <NEWLINE> flag = 0 <NEWLINE> for i in range ( len ( sample_list ) ) : <NEWLINE> <INDENT> for j in range ( 1 , i ) : <NEWLINE> <INDENT> if sample_list [ i ] == sample_list [ j ] : <NEWLINE> <INDENT> flag = 1 <NEWLINE> <DEDENT> if flag == 0 : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> flag = 0 <NEWLINE> <DEDENT> return count <NEWLINE> <DEDENT>
def iroha ( ) : <NEWLINE> <INDENT> a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> if a == b and b == c and a == c : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> elif a != b and b != c and a != c : <NEWLINE> <INDENT> print ( 3 ) <NEWLINE> <DEDENT> elif else : <NEWLINE> <INDENT> print ( 2 ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> iroha ( ) <NEWLINE> <NL> <DEDENT>
a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> m = set ( [ a , b , c ] ) <NEWLINE> print ( len ( m ) <NEWLINE>
lst = list ( map ( int , input ( ) . strip ( ) ) ) <NEWLINE> N = lst [ 0 ] <NEWLINE> K = lst [ 1 ] <NEWLINE> print ( K * ( N - 1 ) * ( K - 1 ) ) <NEWLINE>
ans = 1 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> ans *= K <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans *= K - 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
i = input ( ) <NEWLINE> j = i . split ( ) <NEWLINE> num_balls = j [ 0 ] <NEWLINE> num_colors = j [ 1 ] <NEWLINE> product = num_colors <NEWLINE> if ( num_balls > 1 and num_colors == 1 ) : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> for i in range ( 1 , num_balls ) : <NEWLINE> <INDENT> product *= ( num_balls - 1 ) <NEWLINE> <DEDENT> print ( product ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> k = int ( input ( ) ) <NEWLINE> <NL> ans = 1 <NEWLINE> <NL> for i in range ( k ) : <NEWLINE> <INDENT> ans = ans * n <NEWLINE> n -= 1 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) % 10 <NEWLINE> hon = [ 2 , 4 , 5 , 7 , 9 ] <NEWLINE> bon = [ 3 ] <NEWLINE> <NL> if N in hon : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif N in bon : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( K * ( ( K - 1 ) ** ( N - 1 ) ) <NEWLINE>
sample = input ( ) <COMMENT> <NEWLINE> new_sample = sample . split ( <STRING> ) <NEWLINE> <NL> ball = int ( new_sample [ 0 ] ) <COMMENT> <NEWLINE> color = int ( new_sample [ 1 ] ) <COMMENT> <NEWLINE> if color == 1 and ball > 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> product = color <NEWLINE> <NL> <NL> <COMMENT> <NL> for i in range ( 1 , ball ) : <NEWLINE> <INDENT> product *= ( color - 1 ) <NEWLINE> <DEDENT> print ( product ) <NEWLINE> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( k * ( ( k - 1 ) ** ( n - 1 ) ) <NEWLINE>
import math <NEWLINE> n = int ( input ( ) ) <NEWLINE> A , B = 0 , 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> x , y = int ( input . split ( ) ) <NEWLINE> dx , dy = 1 , 1 <NEWLINE> if A > x : <NEWLINE> <INDENT> dx = A // x <NEWLINE> if A % x != 0 : <NEWLINE> <INDENT> dx += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if B > y : <NEWLINE> <INDENT> dy = B // y <NEWLINE> if B % y != 0 : <NEWLINE> <INDENT> dy += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> a = max ( dx , dy ) <NEWLINE> A , B = a * x , a * y <NEWLINE> <DEDENT> print ( A + B ) <NEWLINE>
import sys <NEWLINE> import numpy as np <NEWLINE> import random <NEWLINE> import math <NEWLINE> from decimal import Decimal <NEWLINE> import itertools <NEWLINE> import re <NEWLINE> import bisect <NEWLINE> from collections import deque , Counter <NEWLINE> from functools import lru_cache <NEWLINE> <NL> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> INF = 10 ** 13 <NEWLINE> def LI ( ) : return list ( map ( int , sys . stdin . buffer . readline ( ) . split ( ) ) ) <NEWLINE> def I ( ) : return int ( sys . stdin . buffer . readline ( ) ) <NEWLINE> def LS ( ) : return sys . stdin . buffer . readline ( ) . rstrip ( ) . decode ( <STRING> ) . split ( ) <NEWLINE> def S ( ) : return sys . stdin . buffer . readline ( ) . rstrip ( ) . decode ( <STRING> ) <NEWLINE> def IR ( n ) : return [ I ( ) for i in range ( n ) ] <NEWLINE> def LIR ( n ) : return [ LI ( ) for i in range ( n ) ] <NEWLINE> def SR ( n ) : return [ S ( ) for i in range ( n ) ] <NEWLINE> def LSR ( n ) : return [ LS ( ) for i in range ( n ) ] <NEWLINE> def SRL ( n ) : return [ list ( S ( ) ) for i in range ( n ) ] <NEWLINE> def MSRL ( n ) : return [ [ int ( j ) for j in list ( S ( ) ) ] for i in range ( n ) ] <NEWLINE> def SERIES ( n ) : return np . fromstring ( sys . stdin . buffer . read ( ) , dtype = np . int32 , sep = <STRING> ) <NEWLINE> def GRID ( h , w ) : return np . fromstring ( sys . stdin . buffer . read ( ) , dtype = np . int32 , sep = <STRING> ) . reshape ( h , - 1 ) [ : , : w ] <NEWLINE> def GRIDfromString ( h , w ) : return np . frombuffer ( sys . stdin . buffer . read ( ) , <STRING> ) . reshape ( h , - 1 ) [ : , : w ] <NEWLINE> MOD = 1000000007 <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> n = I ( ) <NEWLINE> x , y = 1 , 1 <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> t , a = LI ( ) <NEWLINE> m = max ( ( x + t - 1 ) // a , ( y + a - 1 ) // b ) <NEWLINE> x , y = m * t , m * a <NEWLINE> <DEDENT> print ( x + y ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> n = len ( s ) <NEWLINE> p = 0 <NEWLINE> for e in s : <NEWLINE> <INDENT> if e == <STRING> : <NEWLINE> <INDENT> p += 1 <NEWLINE> <DEDENT> <DEDENT> print ( s // 2 - p ) <NEWLINE>
import math <NEWLINE> N = int ( input ( ) ) <NEWLINE> t = 1 <NEWLINE> a = 1 <NEWLINE> <NL> def t_small ( t , a , t1 , a1 ) : <NEWLINE> <INDENT> gain = - ( - t // t1 ) <NEWLINE> t = gain * t1 <NEWLINE> a_tmp = gain * a1 <NEWLINE> if a_tmp < a : <NEWLINE> <INDENT> gain_a = - ( - a // a_tmp ) <NEWLINE> t *= gain_a <NEWLINE> a = a_tmp * gain_a <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a = a_tmp <NEWLINE> <DEDENT> return t , a , t + a <NEWLINE> <NL> <DEDENT> def a_small ( t , a , t1 , a1 ) : <NEWLINE> <INDENT> gain = - ( - a // a1 ) <NEWLINE> a = gain * a1 <NEWLINE> t_tmp = gain * t1 <NEWLINE> if t_tmp < t : <NEWLINE> <INDENT> gain_t = - ( - t // t_tmp ) <NEWLINE> a *= gain_t <NEWLINE> t = t_tmp * gain_t <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> t = t_tmp <NEWLINE> <DEDENT> return t , a , t + a <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> t1 , a1 = map ( int , input ( ) . split ( ) ) <NEWLINE> tt1 , aa1 , sta1 = t_small ( t , a , t1 , a1 ) <NEWLINE> tt2 , aa2 , sta2 = a_small ( t , a , t1 , a1 ) <NEWLINE> if sta1 <= sta2 : <NEWLINE> <INDENT> t = tt1 ; a = aa1 , ans = sta1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> t = tt2 , a = aa2 , ans = sta2 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> from fractions import gcd <NEWLINE> <NL> sys . setrecursionlimit ( 10 ** 8 ) <NEWLINE> ini = lambda : int ( sys . stdin . readline ( ) ) <NEWLINE> inm = lambda : map ( int , sys . stdin . readline ( ) . split ( ) ) <NEWLINE> inl = lambda : list ( inm ( ) ) <NEWLINE> ins = lambda : sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> debug = lambda * a , ** kw : print ( * a , ** dict ( file = sys . stderr , ** kw ) ) <NEWLINE> <NL> N = ini ( ) <NEWLINE> <NL> <NL> def solve ( ) : <NEWLINE> <INDENT> p = q = 1 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> x , y = inm ( ) <NEWLINE> k = 1 <NEWLINE> while True : <NEWLINE> <INDENT> if x * k >= p and y * k >= q : <NEWLINE> <INDENT> p = x * k <NEWLINE> q = y * k <NEWLINE> break <NEWLINE> <DEDENT> k += 1 <NEWLINE> <DEDENT> <DEDENT> return p + q <NEWLINE> <NL> <NL> <DEDENT> print ( solve ( ) ) <NEWLINE>
<INDENT> s = input ( ) <NEWLINE> print ( ( s . count ( <STRING> ) - s . count ( <STRING> ) ) // 2 ) <NEWLINE> <DEDENT>
n = input ( ) <NEWLINE> a = 0 <NEWLINE> a = <STRING> <NEWLINE> for i , j in zip ( n , a ) : <NEWLINE> <INDENT> if i != j : <NEWLINE> <INDENT> a += 1 <NEWLINE> <DEDENT> <DEDENT> print ( a ) <NEWLINE>
S = input ( ) <NEWLINE> T = <STRING> <NEWLINE> ans = 0 <NEWLINE> for _ in range ( 16 ) : <NEWLINE> <INDENT> ans += S [ i ] != T [ i ] <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
<STRING> <NEWLINE> import numpy as np <NEWLINE> import sys <NEWLINE> <NL> N , A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> S = str ( input ( ) ) <NEWLINE> <NL> for i in range ( len ( N ) ) : <NEWLINE> <INDENT> if ( S [ i ] == <STRING> ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if ( i >= A + B ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if ( S [ i ] == <STRING> and i < B ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT>
N , A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> S = input ( ) <NEWLINE> <NL> ok_count = 0 <NEWLINE> ok_fcount = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if S [ i ] == <STRING> : <NEWLINE> <INDENT> if ok_count < A + B - 1 <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> ok_count += 1 <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> elif S [ i ] == <STRING> : <NEWLINE> <INDENT> if ok_count <= A + B - 1 and ok_fcount < B - 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> ok_count += 1 <NEWLINE> ok_fcount += 1 <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
n , A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> a , b = 0 <NEWLINE> s = input ( ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> s_i = s [ i ] <NEWLINE> if s_i == <STRING> : <NEWLINE> <INDENT> if ( a + b ) < ( A + B ) : <NEWLINE> <INDENT> a += 1 <NEWLINE> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> elif s_i == <STRING> : <NEWLINE> <INDENT> if ( ( a + b ) < ( A + B ) ) & ( b < B ) : <NEWLINE> <INDENT> b += 1 <NEWLINE> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> X = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> HP = [ ] <NEWLINE> for p in range ( 1 , 101 , 1 ) : <NEWLINE> <INDENT> P = [ p ] * len ( X ) <NEWLINE> delta = sum ( [ ( i - j ) ** 2 for ( i , j ) in zip ( X , P ) ] ) <NEWLINE> HP . append ( delta ) <NEWLINE> <NL> <DEDENT> print ( min ( HP ) ) <NEWLINE>
5 2 2 <NEWLINE> ccccc <NEWLINE>
n , a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> s = list ( input ( ) ) <NEWLINE> <NL> result = [ ] <NEWLINE> cnt = 0 <NEWLINE> cnt_b = 0 <NEWLINE> limit = a + b <NEWLINE> <NL> for student in s : <NEWLINE> <INDENT> if student == c : <NEWLINE> <INDENT> result . append ( <STRING> ) <NEWLINE> <DEDENT> elif ( student == <STRING> ) & ( cnt < limit ) : <NEWLINE> <INDENT> result . append ( <STRING> ) <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> elif ( student == <STRING> ) & ( cnt < limit ) & ( cnt_b < b ) : <NEWLINE> <INDENT> result . append ( <STRING> ) <NEWLINE> cnt += 1 <NEWLINE> cnt_b += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> result . append ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> . join ( result ) ) <NEWLINE>
X = input ( ) <NEWLINE> <NL> cache = 0 <NEWLINE> ans = len ( X ) <NEWLINE> <NL> for c in X : <NEWLINE> <INDENT> if c == <STRING> <NEWLINE> <INDENT> cache += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if cache > 0 : <NEWLINE> <INDENT> cache -= 1 <NEWLINE> ans -= 2 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> if sys . argv [ - 1 ] == <STRING> : <NEWLINE> <INDENT> import os , zlib , base64 <NEWLINE> open ( <STRING> , <STRING> ) . write ( zlib . decompress ( base64 . b85decode ( <STRING> ) ) ) <NEWLINE> os . system ( <STRING> ) <NEWLINE> <DEDENT> import solve <NEWLINE>
s = input ( ) <NEWLINE> print ( s [ : 4 ] + <STRING> + s [ 4 : ] <NEWLINE>
n = input ( ) <NEWLINE> print ( <STRING> . join ( n [ : 4 ] , n [ 4 : ] ) ) <NEWLINE>
<COMMENT> <NL> using namespace std ; <NEWLINE> <NL> int main ( ) { <NEWLINE> <INDENT> string s ; <NEWLINE> cin >> s ; <NEWLINE> <NL> for ( int i = 0 ; i < s . size ( ) ; i + + ) { <NEWLINE> <INDENT> if ( i == 4 ) cout << <STRING> ; <NEWLINE> else cout << s [ i ] ; <NEWLINE> <DEDENT> } <NEWLINE> <DEDENT> } <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <NL> ans = 0 <NEWLINE> <NL> if N % 2 == 0 : <NEWLINE> <INDENT> for i in range ( N // 2 ) : <NEWLINE> <INDENT> if a [ a [ i ] - 1 ] == i + 1 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( N // 2 + 1 ) : <NEWLINE> <INDENT> if a [ a [ i ] - 1 ] == i + 1 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> l = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ] <NEWLINE> l = l [ 0 ] <NEWLINE> cnt = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if l [ i ] - 1 > i : <NEWLINE> <INDENT> if ( l [ l [ i ] - 1 ] - 1 == i ) : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if A [ a [ i - 1 ] - 1 ] == i + 1 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans // 2 ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> rabit = [ int ( v ) for v in input ( ) . split ( <STRING> ) ] <NEWLINE> skip = set ( ) <NEWLINE> num = 0 <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> n = rabit [ i ] <NEWLINE> if i in skip : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if rabit [ n - 1 ] == i + 1 : <NEWLINE> <INDENT> skip . append ( n - 1 ) <NEWLINE> num += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( num ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( a ) : <NEWLINE> <INDENT> if a [ a [ i ] - 1 ] == i + 1 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans // 2 ) <NEWLINE>
import sys <NEWLINE> import itertools <NEWLINE> <COMMENT> <NL> import time <NEWLINE> import math <NEWLINE> from heapq import heappop , heappush <NEWLINE> from collections import defaultdict <NEWLINE> from collections import Counter <NEWLINE> from collections import deque <NEWLINE> from itertools import permutations <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> <NL> INF = 10 ** 18 <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> read = sys . stdin . buffer . read <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> readlines = sys . stdin . buffer . readlines <NEWLINE> <NL> <COMMENT> <NL> S = input ( ) <NEWLINE> K = int ( input ( ) ) <NEWLINE> <NL> ans = [ ] <NEWLINE> for i , c in enumerate ( S ) : <NEWLINE> <INDENT> num = ord ( <STRING> ) - ord ( c ) + 1 <NEWLINE> if K >= num : <NEWLINE> <INDENT> K -= num <NEWLINE> ans . append ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans . append ( c ) <NEWLINE> <DEDENT> <DEDENT> if K > 0 : <NEWLINE> <INDENT> ans [ - 1 ] = chr ( ( ord ( S [ - 1 ] ) - ord ( <STRING> ) + K ) % 26 + ord ( <STRING> ) ) <NEWLINE> <DEDENT> print ( <STRING> . join ( an ) ) <NEWLINE> <NL>
s , k , t = input ( ) , int ( input ( ) ) , <STRING> <NEWLINE> for q in s : <NEWLINE> <INDENT> if ( p : = ( 123 - ord ( q ) ) % 26 ) <= k : t += <STRING> ; k -= p <NEWLINE> else : t += q <NEWLINE> <DEDENT> * a , b = t <NEWLINE> print ( a + chr ( ( ord ( b ) - 97 + k ) % 26 + 97 ) ) <NEWLINE>
s , k , t = input ( ) , int ( input ( ) ) , <STRING> <NEWLINE> for q in s : <NEWLINE> <INDENT> if ( p : = ( 123 - ord ( q ) ) % 26 ) <= k : n += <STRING> ; K -= i <NEWLINE> else : n += c <NEWLINE> <DEDENT> print ( t [ : - 1 ] + chr ( ( ord ( t [ - 1 ] ) - 97 + k ) % 26 + 97 ) ) <NEWLINE>
def actual ( a , b , h ) : <NEWLINE> <INDENT> return int ( ( a + b ) * h / 2 ) <NEWLINE> <NL> <DEDENT> a , b , h = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( actual ( a , b , h ) ) <NEWLINE>
print ( eval ( <STRING> . replace ( <STRING> , <STRING> ) ) ) <NEWLINE>
a , b , h = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( ( a + b ) * h // 2 ) <NEWLINE>
a , b , h = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> print ( ( ( a + b ) * h ) // 2 ) <NEWLINE>
a = int ( input ( ) ) <NEWLINE> b = int ( input ( ) ) <NEWLINE> c = int ( input ( ) ) <NEWLINE> <NL> print ( ( a + b ) * h / 2 ) <NEWLINE>
a = int ( input ( ) . split ( ) ) <NEWLINE> b = int ( input ( ) . split ( ) ) <NEWLINE> h = int ( input ( ) . split ( ) ) <NEWLINE> print ( ( ( a + b ) * h ) // 2 ) <NEWLINE>
a = int ( input ( ) <NEWLINE> b = int ( input ( ) ) <NEWLINE> h = int ( input ( ) ) <NEWLINE> print ( ( a + b ) * h // 2 ) <NEWLINE>
a , b , h = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> answer = ( a + b ) * h // 2 <NEWLINE> <NL> print ( answer ) <NEWLINE>
print ( ( int ( input ( ) ) + int ( input ( ) ) ) * int ( input ( ) // 2 ) <NEWLINE>
( a , b , c ) = ( int ( input ( ) ) , int ( input ( ) ) , int ( input ( ) ) ) <NEWLINE> s = ( a + b ) * h / 2 <NEWLINE> print ( s ) <NEWLINE>
a = [ int ( input ( ) ) for i in range ( 5 ) ] <NEWLINE> ( a [ 0 ] + a [ 1 ] ) * a [ 2 ] / 2 <NEWLINE>
a , b , h = [ input ( ) for _ in range ( 3 ) ] <NEWLINE> print ( int ( ( a + b ) * h / 2 ) ) <NEWLINE>
<INDENT> a , b , h = [ int ( input ( ) ) for _ in range ( 3 ) ] <NEWLINE> print ( ( a + b ) * h / 2 ) <NEWLINE> <DEDENT>
list = [ ] <NEWLINE> <NL> for i in range ( 3 ) : <NEWLINE> <INDENT> list . append ( int ( input ( ) ) ) <NEWLINE> <NL> <DEDENT> area = ( list [ 0 ] + list [ 1 ] ) * list [ 2 ] / 2 ) <NEWLINE> <NL> <NL> print ( int ( area ) ) <NEWLINE>
a = int ( input ( ) ) <NEWLINE> b = int ( input ( ) ) <NEWLINE> h = int ( input ( ) / 2 ) <NEWLINE> print ( ( a + b ) * h ) <NEWLINE>
a = int ( input ( ) ) <NEWLINE> b = int ( input ( ) ) <NEWLINE> c = int ( input ( ) ) <NEWLINE> <NL> print ( ( a + b ) * h // 2 ) <NEWLINE>
a , b , c = eval ( <STRING> * 3 ) <NEWLINE> print ( ( a + b ) * h // 2 ) <NEWLINE>
a , b , h = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( ( a + b ) * h / 2 ) <NEWLINE>
a = int ( input ( ) ) <NEWLINE> b = int ( input ( ) ) <NEWLINE> c = int ( input ( ) ) <NEWLINE> <NL> print ( ( a + b ) * h // 2 ) <NEWLINE>
import sys <NEWLINE> <NL> def main ( a , b , h ) : <NEWLINE> <INDENT> reuturn ( a + b ) * h // 2 <NEWLINE> <NL> <DEDENT> a = int ( sys . stdin . readline ( ) . strip ( ) ) <NEWLINE> b = int ( sys . stdin . readline ( ) . strip ( ) ) <NEWLINE> h = int ( sys . stdin . readline ( ) . strip ( ) ) <NEWLINE> <NL> print ( main ( a , b , h ) ) <NEWLINE>
a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( ( a + b ) * h / 2 ) <NEWLINE>
a , b , h = [ int ( i ) for i in input ( ) ] <NEWLINE> print ( ( a + b ) * h / 2 ) <NEWLINE>
a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( ( a + b ) * c // 2 ) <NEWLINE>
a , b , h = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> print ( ( a + b ) * h / 2 ) <NEWLINE>
<COMMENT> <NL> a , b , h = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <COMMENT> <NL> answer = ( a + b ) * h / 2 <NEWLINE> <NL> <COMMENT> <NL> print ( int ( answer ) ) <NEWLINE>
a , b , h = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( ( a + b ) * h // 2 ) <NEWLINE>
a = int ( input ( ) ) <NEWLINE> b = int ( input ( ) ) <NEWLINE> h = int ( input ( ) ) <NEWLINE> print ( in ( ( ( a + b ) * h ) / 2 ) ) <NEWLINE>
a = int ( input ( ) ) <NEWLINE> b = int ( input ( ) ) <NEWLINE> h = int ( input ( ) ) <NEWLINE> area = 0.5 ( a + b ) * h <NEWLINE> print ( area ) <NEWLINE>
d = { <STRING> : input ( ) , <STRING> : input ( ) , <STRING> : input ( ) } <NEWLINE> pointer = <STRING> <NEWLINE> while True : <NEWLINE> <INDENT> if 0 < len ( d [ pointer ] ) : <NEWLINE> <INDENT> tmp = d [ pointer ] [ 0 ] <NEWLINE> d [ pointer ] = s [ pointer ] [ 1 : ] <NEWLINE> pointer = tmp <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( pointer . upper ( ) ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> using namespace std ; <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> typedef long long ll ; <NEWLINE> typedef pair < int , int > P ; <NEWLINE> const int INF = 100100100 ; <NEWLINE> const int MOD = ( int ) 1e9 + 7 ; <NEWLINE> const double EPS = 1e-9 ; <NEWLINE> struct Edge { <NEWLINE> <INDENT> ll to ; <NEWLINE> ll cost ; <NEWLINE> <DEDENT> } ; <NEWLINE> int main ( ) { <NEWLINE> <INDENT> string sa , sb , sc ; <NEWLINE> cin >> sa >> sb >> sc ; <NEWLINE> char now = <STRING> ; <NEWLINE> while ( true ) { <NEWLINE> <INDENT> if ( now == <STRING> ) { <NEWLINE> <INDENT> if ( sa . size ( ) == 0 ) { <NEWLINE> <INDENT> cout << <STRING> << endl ; <NEWLINE> return 0 ; <NEWLINE> <DEDENT> } <NEWLINE> now = sa [ 0 ] ; <NEWLINE> sa . erase ( sa . begin ( ) ) ; <NEWLINE> <DEDENT> } else if ( now == <STRING> ) { <NEWLINE> <INDENT> if ( sb . size ( ) == 0 ) { <NEWLINE> <INDENT> cout << <STRING> << endl ; <NEWLINE> return 0 ; <NEWLINE> <DEDENT> } <NEWLINE> now = sb [ 0 ] ; <NEWLINE> sb . erase ( sb . begin ( ) ) ; <NEWLINE> <DEDENT> } else { <NEWLINE> <INDENT> if ( sc . size ( ) == 0 ) { <NEWLINE> <INDENT> cout << <STRING> << endl ; <NEWLINE> return 0 ; <NEWLINE> <DEDENT> } <NEWLINE> now = sc [ 0 ] ; <NEWLINE> sc . erase ( sc . begin ( ) ) ; <NEWLINE> <DEDENT> } <NEWLINE> <DEDENT> } <NEWLINE> <DEDENT> } <NEWLINE>
for i in range ( 3 ) : <NEWLINE> <INDENT> s . append ( input ( ) ) <NEWLINE> <DEDENT> member = [ <STRING> , <STRING> , <STRING> ] <NEWLINE> turn = 0 <NEWLINE> <NL> while True : <NEWLINE> <INDENT> if s [ turn ] == <STRING> : <NEWLINE> <INDENT> winner = turn <NEWLINE> break <NEWLINE> <DEDENT> elif s [ turn ] [ 0 ] == <STRING> : <NEWLINE> <INDENT> s [ turn ] = s [ turn ] [ 1 : ] <NEWLINE> turn = 0 <NEWLINE> <DEDENT> elif s [ turn ] [ 0 ] == <STRING> : <NEWLINE> <INDENT> s [ turn ] = s [ turn ] [ 1 : ] <NEWLINE> turn = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s [ turn ] = s [ turn ] [ 1 : ] <NEWLINE> turn = 2 <NEWLINE> <DEDENT> <DEDENT> print ( member [ winner ] ) <NEWLINE> <NL>
alice = input ( ) <NEWLINE> bob = input ( ) <NEWLINE> charlie = input ( ) <NEWLINE> <NL> for i in range ( len ( alice ) ) : <NEWLINE> <INDENT> if alice [ i ] == <STRING> : <NEWLINE> <INDENT> while alice [ i ] == <STRING> : <NEWLINE> <INDENT> alice . pop ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> elif alice [ i ] == <STRING> : <NEWLINE> <INDENT> alice . pop ( i ) <NEWLINE> if bob [ i ] == <STRING> : <NEWLINE> <INDENT> while bob [ i ] == <STRING> : <NEWLINE> <INDENT> bob . pop ( i ) <NEWLINE> <DEDENT> <DEDENT> elif bob [ i ] == <STRING> : <NEWLINE> <INDENT> while bob [ i ] == <STRING> : <NEWLINE> <INDENT> alice . pop ( i ) <NEWLINE> <DEDENT> <DEDENT> elif bob [ i ] == <STRING> : <NEWLINE> <INDENT> while bob [ i ] == <STRING> : <NEWLINE> <INDENT> charlie . pop ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> elif alice [ i ] == <STRING> : <NEWLINE> <INDENT> alice . pop ( i ) <NEWLINE> if charlie [ i ] == <STRING> : <NEWLINE> <INDENT> while charlie [ i ] == <STRING> : <NEWLINE> <INDENT> charlie . pop ( i ) <NEWLINE> <DEDENT> <DEDENT> elif charlie [ i ] == <STRING> : <NEWLINE> <INDENT> while charlie [ i ] == <STRING> : <NEWLINE> <INDENT> bob . pop ( i ) <NEWLINE> <DEDENT> <DEDENT> elif charlie [ i ] == <STRING> : <NEWLINE> <INDENT> while charlie [ i ] == <STRING> : <NEWLINE> <INDENT> alice . pop ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for i in range ( len ( alice ) ) : <NEWLINE> <INDENT> if len ( alice ) == 0 and alice [ <NEWLINE> <DEDENT>
S = { i : input ( ) for i in <STRING> } <NEWLINE> n = <STRING> <NEWLINE> while S [ n ] : <NEWLINE> <INDENT> n = S [ n ] . pop ( 0 ) <NEWLINE> <NL> <DEDENT> print ( n . upper ( ) ) <NEWLINE>
lis = [ ] <NEWLINE> ll = [ <STRING> , <STRING> , <STRING> ] <NEWLINE> for i in range ( 3 ) : <NEWLINE> <INDENT> lis . append ( list ( input ( ) ) ) <NEWLINE> <DEDENT> turn = 0 <NEWLINE> while 1 : <NEWLINE> <INDENT> x = ll . index ( lis [ turn ] . pop ( ) ) <NEWLINE> if lis [ turn ] = [ ] : <NEWLINE> <INDENT> print ( ll [ turn ] . upper ( ) ) <NEWLINE> break <NEWLINE> <DEDENT> turn = x <NEWLINE> <DEDENT>
S = dict ( ) <NEWLINE> <NL> S [ <STRING> ] = input ( ) [ : : - 1 ] <NEWLINE> S [ <STRING> ] = input ( ) [ : : - 1 ] <NEWLINE> S [ <STRING> ] = input ( ) [ : : - 1 ] <NEWLINE> <NL> player = <STRING> <NEWLINE> <NL> while S [ player ] : <NEWLINE> <INDENT> player = S [ player ] . pop ( ) <NEWLINE> <NL> <NL> <DEDENT> res = player . upper ( ) <NEWLINE> print ( res ) <NEWLINE>
S = Sa <NEWLINE> card = S . pop ( 0 ) <NEWLINE> while True : <NEWLINE> <INDENT> if card == <STRING> : <NEWLINE> <INDENT> S = Sa <NEWLINE> <DEDENT> if card == <STRING> : <NEWLINE> <INDENT> S = Sb <NEWLINE> <DEDENT> if card == <STRING> : <NEWLINE> <INDENT> S = Sc <NEWLINE> <DEDENT> try : <NEWLINE> <INDENT> card = S . pop ( 0 ) <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> print ( card . upper ( ) ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT>
s = { <STRING> : input ( ) , <STRING> : input ( ) , <STRING> input ( ) } <NEWLINE> now = <STRING> <NEWLINE> while s [ now ] != <STRING> : <NEWLINE> <INDENT> next = s [ now ] [ 0 ] <NEWLINE> s [ now ] = s [ now ] [ 1 : ] <NEWLINE> now = next <NEWLINE> <DEDENT> print ( now . upper ( ) ) <NEWLINE>
alice = list ( input ( ) ) <NEWLINE> bob = list ( input ( ) ) <NEWLINE> charlie = list ( input ( ) ) <NEWLINE> <NL> current = alice <NEWLINE> while ( len ( alice ) > 0 and len ( bob ) > 0 and len ( charlie ) > 0 ) : <NEWLINE> <INDENT> if ( current [ 0 ] == <STRING> ) : <NEWLINE> del current [ 0 ] <NEWLINE> <INDENT> current = alice <NEWLINE> <DEDENT> elif ( current [ 0 ] == <STRING> ) : <NEWLINE> <INDENT> del current [ 0 ] <NEWLINE> <DEDENT> currrent = bob <NEWLINE> elif ( current [ 0 ] == <STRING> ) : <NEWLINE> <INDENT> del current [ 0 ] <NEWLINE> <DEDENT> current = charlie <NEWLINE> <DEDENT> if ( len ( alice ) == 0 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif ( len ( bob ) == 0 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif ( len ( charlie ) == 0 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
mb = input ( ) <NEWLINE> mc = input ( ) <NEWLINE> mdic = { <STRING> : ma , <STRING> : mb , <STRING> : mc } <NEWLINE> m = <STRING> <NEWLINE> ndic = { <STRING> : 0 , <STRING> : - 1 , <STRING> : - 1 } <NEWLINE> while ndic [ m ] < len ( mdic [ m ] ) : <NEWLINE> <INDENT> m = mdic [ m ] [ ndic [ m ] ] <NEWLINE> ndic [ m ] += 1 <NEWLINE> <DEDENT> print ( m . upper ( ) ) <NEWLINE>
n = input ( ) <NEWLINE> l = len ( n ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( l ) : <NEWLINE> <INDENT> for j in range ( l - i ) : <NEWLINE> <INDENT> ans += int ( n [ i ] ) * 10 ** j * 2 ** i * 2 ** ( n - i - j - 2 ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
def dfs ( i , f ) : <NEWLINE> <INDENT> if i == n - 1 : <NEWLINE> <INDENT> return sum ( list ( map ( int , input ( ) . split ( <STRING> ) ) ) ) <NEWLINE> <DEDENT> return dfs ( i + 1 , f + s [ i + 1 ] ) + dfs [ i + 1 , f + <STRING> + s [ i + 1 ] ] <NEWLINE> <NL> <DEDENT> s = input ( ) <NEWLINE> n = len ( s ) <NEWLINE> print ( dfs ( 0 , s [ 0 ] ) ) <NEWLINE>
s = input ( ) <NEWLINE> n = len ( s - 1 ) <NEWLINE> total = 0 <NEWLINE> for i in range ( 2 ** n ) : <NEWLINE> <INDENT> pl = [ <STRING> ] * n <NEWLINE> ans = <STRING> <NEWLINE> for j in range ( n ) : <NEWLINE> <INDENT> if ( ( i >> j ) & 1 ) : <NEWLINE> <INDENT> pl [ n - 1 - j ] = <STRING> <NEWLINE> <DEDENT> <DEDENT> for k in range ( n ) : <NEWLINE> <INDENT> ans += s [ k ] + pl [ k ] <NEWLINE> <DEDENT> ans += s [ - 1 ] <NEWLINE> total += eval ( ans ) <NEWLINE> <NL> <DEDENT> print ( total ) <NEWLINE>
def a ( s , i ) : <NEWLINE> <INDENT> if i == l - 1 : <NEWLINE> <INDENT> return sum ( map ( int , s . split ( <STRING> ) ) ) <NEWLINE> <DEDENT> return a ( s + s [ i + 1 ] , i + 1 ) + a ( s + <STRING> + s [ i + 1 ] , i + 1 ) <NEWLINE> <DEDENT> s = input ( ) <NEWLINE> l = len ( s ) <NEWLINE> print ( a ( s [ 0 ] , 0 ) ) <NEWLINE>
s = input ( ) <NEWLINE> <NL> for i in range ( 2 ** ( len ( s ) - 1 ) ) : <NEWLINE> <INDENT> plus = [ <STRING> ] * ( len ( s ) ) <NEWLINE> fomula = <STRING> <NEWLINE> for j in range ( len ( s ) - 1 ) : <NEWLINE> <INDENT> if ( i >> j & 1 ) : <NEWLINE> <INDENT> plus [ j ] = <STRING> <NEWLINE> <DEDENT> <DEDENT> for k in range ( len ( s ) ) : <NEWLINE> <INDENT> fomula += s [ k ] + plus [ k ] <NEWLINE> <DEDENT> ans += eval ( fomula ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> <NL> s = int ( input ( ) ) <NEWLINE> n = len ( s ) - 1 <NEWLINE> answer = 0 <NEWLINE> for i in range ( 2 ** n ) : <NEWLINE> <INDENT> operation = [ <STRING> ] * n <NEWLINE> for j in range ( n ) : <NEWLINE> <INDENT> if ( i >> j ) & 1 : <NEWLINE> <INDENT> operation [ n - 1 - j ] = <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> formula = <STRING> <NEWLINE> for p_n , p_o in zip ( s , operation + [ <STRING> ] ) : <NEWLINE> <INDENT> formula += ( p_n + p_o ) <NEWLINE> <NL> <DEDENT> answer += eval ( formula ) <NEWLINE> <NL> <DEDENT> print ( answer ) <NEWLINE>
from sys import stdin <NEWLINE> input = stdin . readline <NEWLINE> <NL> S = input ( ) <NEWLINE> n = len ( S ) <NEWLINE> <NL> tot = 0 <NEWLINE> <NL> for i in range ( 2 ** ( n - 1 ) ) : <NEWLINE> <INDENT> f = S [ 0 ] <NEWLINE> for j in range ( n - 1 ) : <NEWLINE> <INDENT> if ( ( i >> j ) & 1 ) : <NEWLINE> <INDENT> f += <STRING> <NEWLINE> <DEDENT> f += S [ j + 1 ] <NEWLINE> <NL> <DEDENT> tot += sum ( map ( int , f . split ( <STRING> ) ) ) <NEWLINE> <NL> <DEDENT> print ( tot ) <NEWLINE>
S = input ( ) <NEWLINE> total = 0 <NEWLINE> for p in ( product ( ( 0 , 1 ) , repeat = len ( S ) - 1 ) ) : <NEWLINE> <INDENT> ns = S [ 0 ] <NEWLINE> for i , pp in enumerate ( p , 1 ) : <NEWLINE> <INDENT> if pp == 0 : <NEWLINE> <INDENT> ns += S [ i ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> total += int ( ns ) <NEWLINE> ns = S [ i ] <NEWLINE> <DEDENT> <DEDENT> total += int ( ns ) <NEWLINE> <DEDENT> print ( total ) <NEWLINE> <NL> <NL>
<NL> def a ( t , i ) : <NEWLINE> <INDENT> if i = len ( s ) - 1 : <NEWLINE> <INDENT> return sum ( map ( int , t . split ( <STRING> ) ) ) <NEWLINE> <DEDENT> return a ( t + s [ i + 1 ] , i + 1 ) + a ( t + <STRING> + s [ i + 1 ] , i + 1 ) <COMMENT> <NEWLINE> <DEDENT> s = input ( ) <NEWLINE> print ( a ( s [ 0 ] , 0 ) ) <NEWLINE>
def a ( t , i ) : <NEWLINE> <INDENT> if i == n - 1 : <NEWLINE> <INDENT> return sum ( map ( int , t . split ( ) ) ) <NEWLINE> <DEDENT> return a ( t + s [ i + 1 ] , i + 1 ) + a ( t + <STRING> + s [ i + 1 ] , i + 1 ) <NEWLINE> <NL> <DEDENT> s = input ( ) <NEWLINE> n = len ( s ) <NEWLINE> i = 0 <NEWLINE> print ( a ( s [ 0 ] , 0 ) ) <NEWLINE>
s = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> a = s . pop ( - 1 ) <NEWLINE> b , c = a // 2 , a - ( a // 2 ) <NEWLINE> d = s [ 0 ] * a [ 1 ] <NEWLINE> print ( abs ( d * b - d * c ) ) <NEWLINE>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> def linput ( ty = int , cvt = list ) : <NEWLINE> <INDENT> return cvt ( map ( ty , input ( ) . split ( ) ) ) <NEWLINE> <NL> <DEDENT> def gcd ( a : int , b : int ) : <NEWLINE> <INDENT> while b : a , b = b , a % b <NEWLINE> return a <NEWLINE> <NL> <DEDENT> def lcm ( a : int , b : int ) : <NEWLINE> <INDENT> return a * b // gcd ( a , b ) <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <COMMENT> <NL> <NEWLINE>
header_code = <STRING> <NEWLINE> <NL> code = <STRING> <NEWLINE> <NL> <NL> import os , sys , getpass <NEWLINE> <NL> if sys . argv [ - 1 ] == <STRING> : <NEWLINE> <INDENT> code = code . replace ( <STRING> , getpass . getuser ( ) ) <NEWLINE> open ( <STRING> , <STRING> ) . write ( header_code ) <NEWLINE> open ( <STRING> , <STRING> ) . write ( code ) <NEWLINE> os . system ( <STRING> ) <NEWLINE> sys . exit ( 0 ) <NEWLINE> <NL> <NL> <DEDENT> from atcoder import SegTree <NEWLINE> <NL> N , x = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ST = SegTree ( A , <STRING> ) <NEWLINE> ans = 10 ** 27 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> t = 0 <NEWLINE> for j in range ( N ) : <NEWLINE> <INDENT> if j - i < 0 : <NEWLINE> <INDENT> t += min ( ST . prod ( 0 , j + 1 ) , ST . prod ( N + j - i , N ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> t += ST . prod ( j - i , j + 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> ans = min ( t + i * x , ans ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
N , K , X , Y = [ int ( input ( ) ) for i in range ( 4 ) ] <NEWLINE> <NL> if ( K > N ) : <NEWLINE> <INDENT> N = K <NEWLINE> <DEDENT> else : <NEWLINE> <NL> <NL> Z = K * X + ( N - K ) * Y <NEWLINE> print ( Z ) <NEWLINE>
<COMMENT> <NL> n , k , x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <COMMENT> <NL> first_stay = k * x <NEWLINE> second_stay = ( n - k ) * y <NEWLINE> <NL> total_price = first_stay + second_stay <NEWLINE> <NL> <COMMENT> <NL> print ( total_price ) <NEWLINE>
import sys <NEWLINE> n , k , x , y = map ( int , sys . stdio . read ( ) . split ( ) ) <NEWLINE> high = n - k <NEWLINE> ans = 0 <NEWLINE> if high > 0 : <NEWLINE> <INDENT> ans = x * k + high * y <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = n * x <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
a = int ( input ( ) ) <NEWLINE> b = int ( input ( ) ) <NEWLINE> c = int ( input ( ) ) <NEWLINE> d = int ( input ( ) ) <NEWLINE> e = 0 <NEWLINE> <NL> for i in range ( 1 , a + 1 ) : <NEWLINE> <INDENT> if i >= b + 1 : <NEWLINE> <INDENT> e += d <NEWLINE> else : <NEWLINE> <INDENT> e += c <NEWLINE> print ( e ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
n , k , x , y = map ( int , [ input for i in range ( 4 ) ] ) <NEWLINE> <NL> print ( x * k + y * ( n - k ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> k = int ( input ( ) ) <NEWLINE> x = int ( input ( ) ) <NEWLINE> y = int ( input ( ) ) <NEWLINE> if k <= n : <NEWLINE> <INDENT> ans += k * x + ( n - k ) * y <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += x * n <NEWLINE> <DEDENT>
n , k , x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> if n <= k : <NEWLINE> <INDENT> print ( n * x ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( k * x + ( n - k ) * y ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> k = int ( input ( ) ) <NEWLINE> x = int ( input ( ) ) <NEWLINE> y = int ( input ( ) ) <NEWLINE> sum = 0 <NEWLINE> if ( n >= k ) : <NEWLINE> <INDENT> sum = k * x + ( n - k ) * y <NEWLINE> <INDENT> print ( sum ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> sum = n * x <NEWLINE> <INDENT> print ( sum ) <NEWLINE> <DEDENT> <DEDENT>
<INDENT> n , k , price , special = map ( int , input ( ) . split ( ) ) <NEWLINE> result = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if i < k : <NEWLINE> <INDENT> result += price <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> result += special <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
n , k , x , y = map ( int ( input ( ) ) for i in range ( 4 ) ) <NEWLINE> if k <= n : <NEWLINE> <INDENT> print ( k * x ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( k * x + ( n - k ) * y ) <NEWLINE> <DEDENT>
N , K , X , Y = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if N <= K : <NEWLINE> <INDENT> print ( N * X ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( K * X + ( N - K ) * Y ) <NEWLINE> <DEDENT>
n , k , x , y = [ int ( input ( ) ) for i in range ( n ) ] <NEWLINE> if k <= x : <NEWLINE> <INDENT> print ( n * k ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( k * x + ( n - k ) * y ) <NEWLINE> <DEDENT>
a = int ( input ( ) ) <NEWLINE> b = int ( input ( ) ) <NEWLINE> c = int ( input ( ) ) <NEWLINE> d = int ( input ( ) ) <NEWLINE> print ( int ( ( c * ( b - a ) + d * ( b ) ) ) <NEWLINE>
n , k , x , y = [ int ( input ) for i in range ( 4 ) ] <NEWLINE> print ( min ( n , k ) * x + max ( n - k , 0 ) * y ) <NEWLINE>
ab , bc , ca = map ( int , input ( ) . rstrip ( ) . split ( ) ) <NEWLINE> print ( ab * bc // 2 ) <NEWLINE>
k , x , y , n = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if n <= k : <NEWLINE> <INDENT> print ( n * x ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( k * x + ( n - k ) * y ) <NEWLINE> <COMMENT> <NL> <NEWLINE> <DEDENT>
input = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> print ( int ( input [ 1 ] * input [ 2 ] + ( input [ 0 ] - input [ 1 ] ) * input [ 3 ] ) ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> n , k , x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> if n > k : <NEWLINE> <INDENT> answer = k * x + ( n - k ) * y <NEWLINE> <COMMENT> <NL> <DEDENT> else : <NEWLINE> <INDENT> answer = n * x <NEWLINE> <NL> <DEDENT> print ( answer ) <NEWLINE>
N , K , X , Y = input ( ) . split ( ) <NEWLINE> print ( ( K * X + ( N - K ) * Y ) if N >= K else N * X ) <NEWLINE>
import sys <NEWLINE> <NL> read = sys . stdin . read <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> sys . setrecursionlimit ( 10 ** 8 ) <NEWLINE> INF = float ( <STRING> ) <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> N = int ( readline ( ) ) <NEWLINE> K = int ( readline ( ) ) <NEWLINE> X = int ( readline ( ) ) <NEWLINE> Y = int ( readline ( ) ) <NEWLINE> if N <= K : <NEWLINE> <INDENT> ans = X * N <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = X * k + Y * ( N - K ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
total_stay = int ( input ( ) ) <NEWLINE> normal_stay = int ( input ( ) ) <NEWLINE> normal_cost = int ( input ( ) ) <NEWLINE> discounted_cost = int ( input ( ) ) <NEWLINE> if total_stay <= normal_stay : <NEWLINE> <INDENT> total_cost = total_stay * normal_cost <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> total_cost = normal_stay * normal_cost + ( total_stay - normal_stay ) * discounted_cost <NEWLINE> <DEDENT> print ( P ) <NEWLINE>
n , k , x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> print ( int ( k * x + y * ( n - k ) ) ) <NEWLINE>
<COMMENT> <NL> N , K , X , Y = map ( int , input ( ) . split ( ) ) <NEWLINE> <COMMENT> <NL> if N > K : <NEWLINE> <INDENT> total_price = K * X + ( N - K ) * Y <NEWLINE> <COMMENT> <NL> <DEDENT> else : <NEWLINE> <INDENT> total_price = N * X <NEWLINE> <NL> <DEDENT> print ( total_price ) <NEWLINE>
<NL> <NL> N , K , X , Y = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> a = N * X <NEWLINE> <NL> b = K * X + ( N - K ) * Y <NEWLINE> <NL> if N <= K : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( b ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> k = int ( input ( ) ) <NEWLINE> x = int ( input ( ) ) <NEWLINE> y = int ( input ( ) ) <NEWLINE> if n = < k : <NEWLINE> <INDENT> ans = n * x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = k * x + y * ( n - k ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
N , K , X , Y = map ( int , input ( ) . split ( ) ) <NEWLINE> yen1 = K * X <NEWLINE> yen2 = ( N - K ) * Y <NEWLINE> print ( yen1 + yen2 ) <NEWLINE>
W = input ( ) <NEWLINE> W_list = set ( list ( s for s in W ) ) <NEWLINE> ans = True <NEWLINE> for s in W_list : <NEWLINE> <INDENT> if W . count ( s ) % 2 != 0 <NEWLINE> <INDENT> False <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if ans : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> di = { } <NEWLINE> for c in s : <NEWLINE> <INDENT> di [ c ] = 0 <NEWLINE> <DEDENT> for c in s : <NEWLINE> <INDENT> di [ c ] += 1 <NEWLINE> <NL> <DEDENT> is_beautiful = True <NEWLINE> for c in s : <NEWLINE> <INDENT> if di [ c ] % 2 == 1 : <NEWLINE> <INDENT> is_beautiful = False <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> is is_beautiful else <STRING> ) <NEWLINE>
<NL> def inp ( ) : <NEWLINE> <INDENT> return int ( input ( ) ) <NEWLINE> <DEDENT> def inpl ( ) : <NEWLINE> <INDENT> return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <DEDENT> def dbg ( o ) : <NEWLINE> <INDENT> print ( o , file = sys . stderr ) <NEWLINE> <NL> <COMMENT> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> dc = { } <NEWLINE> for st in s : <NEWLINE> <INDENT> if not st in dc : <NEWLINE> <INDENT> dc [ st ] = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dc [ st ] += 1 <NEWLINE> <DEDENT> <DEDENT> dbg ( dc ) <NEWLINE> for k , v in dc . items ( ) : <NEWLINE> <INDENT> if v % 2 == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE>
s = input ( ) <NEWLINE> d = { } <NEWLINE> for i in s : <NEWLINE> <INDENT> d . get ( i , 0 ) += 1 <NEWLINE> <DEDENT> for i in set ( s ) : <NEWLINE> <INDENT> if d [ i ] % 2 == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> d = { } <NEWLINE> for i in s : <NEWLINE> <INDENT> if i in d : <NEWLINE> <INDENT> d [ i ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d [ i ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> for key in d : <NEWLINE> <INDENT> if d [ key ] % 2 != 0 <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT>
print ( <STRING> if all ( input ( ) . count ( i ) % 2 == 0 for i in set ( s ) ) else <STRING> ) <NEWLINE>
a = list ( input ( ) ) <NEWLINE> even_number = range ( 0 , 101 , 2 ) <NEWLINE> values , count = * zip ( a . most_common ( ) ) <NEWLINE> <NL> if even_number in count : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT>
n = input ( ) <NEWLINE> ans = 0 <NEWLINE> for i ih set ( n ) : <NEWLINE> <INDENT> if n . count ( i ) % 2 == 0 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if ans == len ( set ( n ) ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
from collection import Counter <NEWLINE> S = list ( input ( ) ) <NEWLINE> <NL> C = Counter ( S ) <NEWLINE> <NL> ok = True <NEWLINE> for s , x in list ( C . items ( ) ) : <NEWLINE> <INDENT> if x % 2 != 0 : <NEWLINE> <INDENT> ok = False <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if ok : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
w = input ( ) <NEWLINE> <NL> dict = { } <NEWLINE> alh = <STRING> <NEWLINE> for i in alh : <NEWLINE> <INDENT> dict [ i ] = 0 <NEWLINE> <DEDENT> for i in w : <NEWLINE> <INDENT> dict [ i ] += 1 <NEWLINE> <DEDENT> flag = True <NEWLINE> for j in range ( len ( dict ) ) : <NEWLINE> <INDENT> if dict [ j ] % 2 == 1 : <NEWLINE> <INDENT> flag = False <NEWLINE> <DEDENT> <DEDENT> if flag : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT>
s = input ( ) <NEWLINE> alphabets = [ 0 ] * 26 <NEWLINE> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> x = ord ( s [ i ] ) <NEWLINE> alphabets [ x - 97 ] += 1 <NEWLINE> <DEDENT> flag = True <NEWLINE> for x in alphabets : <NEWLINE> <INDENT> if x % 2 != 0 : <NEWLINE> <INDENT> ok = False <NEWLINE> <DEDENT> <DEDENT> if ok : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
w = input ( ) <NEWLINE> <NL> s = { } <NEWLINE> for c in w : <NEWLINE> <INDENT> s [ c ] += 1 <NEWLINE> <NL> <DEDENT> b = True <NEWLINE> for k , v in s . items ( ) : <NEWLINE> <INDENT> b = b and v % 2 == 0 <NEWLINE> <NL> <DEDENT> if b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
w = input ( ) <NEWLINE> A = [ 0 ] * 26 <NEWLINE> <NL> for in in w : <NEWLINE> <INDENT> A [ ord ( i ) - 97 ] += 1 <NEWLINE> <NL> <DEDENT> flag = True <NEWLINE> for a in A : <NEWLINE> <INDENT> if a % 2 == 1 : <NEWLINE> <INDENT> flag = False <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if flag == False : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = input ( ) <NEWLINE> dic = [ a , b , c , d , e , f , g , h , i , j , k , l , m , n , o , p , q , r , s , t , u , v , w , x , y , z ] <NEWLINE> for i in range ( 26 ) : <NEWLINE> <INDENT> if n . count ( str ( dic [ i ] ) ) % 2 != 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = int ( input ( ) ) <NEWLINE> if n == s : <NEWLINE> <INDENT> print ( n + 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> if ( n + 3 ) // 2 <= s : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> ewew <NEWLINE>
s = input ( ) <NEWLINE> <NL> ans1 = ( ( <STRING> in s ) and ( <STRING> in s ) ) or ( ( <STRING> not in s ) & ( <STRING> not in s ) ) <NEWLINE> ans2 = ( ( <STRING> in s ) and ( <STRING> in s ) ) or ( ( <STRING> not in s ) & ( <STRING> not in s ) <NEWLINE> <NL> print ( <STRING> if ans1 and ans2 else <STRING> ) <NEWLINE>
s = input ( ) <NEWLINE> <NL> n = 0 <NEWLINE> e = 0 <NEWLINE> w = 0 <NEWLINE> s = 0 <NEWLINE> <NL> for v in s : <NEWLINE> <INDENT> if v == <STRING> : n += 1 <NEWLINE> if v == <STRING> : e += 1 <NEWLINE> if v == <STRING> : w += 1 <NEWLINE> if v == <STRING> : s += 1 <NEWLINE> <NL> <DEDENT> if n == s and e == w : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> S = input ( ) <NEWLINE> dic = { <STRING> : 0 , <STRING> : 0 , <STRING> : 0 , <STRING> : 0 } <NEWLINE> ans = <STRING> <NEWLINE> <NL> for s in S : <NEWLINE> <INDENT> dic [ s ] += 1 <NEWLINE> <NL> <DEDENT> if ( dic [ <STRING> ] == 0 and dic [ <STRING> ] == 0 ) or ( dic [ <STRING> ] > 0 and dic [ <STRING> ] > 0 ) : <NEWLINE> <INDENT> if ( dic [ <STRING> ] == 0 and dic [ <STRING> ] == 0 ) or ( dic [ <STRING> ] > 0 and mp [ <STRING> ] > 0 ) : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
s = list ( input ( ) ) <NEWLINE> n = s . count ( <STRING> ) <NEWLINE> w = s . count ( <STRING> ) <NEWLINE> s = s . count ( <STRING> ) <NEWLINE> e = s . count ( <STRING> ) <NEWLINE> if ( n + s ) % 2 == 0 and ( w + e ) % 2 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> ans = [ 0 ] * 4 <NEWLINE> checK = <STRING> <NEWLINE> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> for j in range ( len ( check ) ) : <NEWLINE> <INDENT> if s [ i ] == check [ j ] : <NEWLINE> <INDENT> ans [ j ] += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if ( ans [ 0 ] % 2 + ans [ 2 ] % 2 ) % 2 == 0 and ( ans [ 1 ] % 2 + ans [ 3 ] % 2 ) % 2 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> we = [ 0 , 0 ] <NEWLINE> ns = [ 0 , 0 ] <NEWLINE> <NL> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> if s [ i ] == ( <STRING> ) : <NEWLINE> <INDENT> ns [ 0 ] == 1 <NEWLINE> <DEDENT> elif s [ i ] == ( <STRING> ) : <NEWLINE> <INDENT> we [ 0 ] == 1 <NEWLINE> <DEDENT> elif s [ i ] == ( <STRING> ) : <NEWLINE> <INDENT> ns [ 1 ] == 1 <NEWLINE> <DEDENT> else <NEWLINE> <INDENT> we [ 1 ] == 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if sum ( we ) % 2 == 0 and sum ( ns ) % 2 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
string = input ( ) <NEWLINE> <NL> c1 = True <NEWLINE> c2 = True <NEWLINE> c3 = True <NEWLINE> <NL> if ( <STRING> in string and not ( <STRING> in string ) or <STRING> in string and not ( <STRING> in string ) : c1 = False <NEWLINE> <NL> if ( <STRING> in string and not ( <STRING> in string ) or <STRING> in string and not ( <STRING> in string ) : c2 = False <NEWLINE> <NL> if <STRING> in string and <STRING> in string and <STRING> in string and <STRING> in string : <NEWLINE> <INDENT> N = string . count ( <STRING> ) <NEWLINE> S = string . count ( <STRING> ) <NEWLINE> W = string . count ( <STRING> ) <NEWLINE> E = string . count ( <STRING> ) <NEWLINE> if not ( N / S == W / E or N / S == E / W ) : c3 = False <NEWLINE> <NL> <DEDENT> if c1 and c2 and c3 : print ( <STRING> ) <NEWLINE> else : print ( <STRING> ) <NEWLINE>
s = input ( ) <NEWLINE> <NL> def walk ( s ) : <NEWLINE> <INDENT> ls = len ( s ) <NEWLINE> if ls % 2 == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> return <NEWLINE> <DEDENT> nc = 0 <NEWLINE> sc = 0 <NEWLINE> wc = 0 <NEWLINE> ec = 0 <NEWLINE> for i in range ( ls ) : <NEWLINE> <INDENT> if s [ i ] = <STRING> : <NEWLINE> <INDENT> wc += 1 <NEWLINE> <DEDENT> elif s [ i ] = <STRING> : <NEWLINE> <INDENT> ec += 1 <NEWLINE> <DEDENT> elif s [ i ] = <STRING> : <NEWLINE> <INDENT> nc += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> sc += 1 <NEWLINE> <DEDENT> <DEDENT> if wc == ec and nc == sc : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> return <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> return <NEWLINE> <DEDENT> <DEDENT> walk ( s ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> lis = [ int ( input ( ) ) for i in range ( n ) ] + [ 0 ] <NEWLINE> <NL> count = 0 <NEWLINE> m = - 1 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if lis [ i ] % 2 == 0 : <NEWLINE> <INDENT> count += l [ i ] // 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if lis [ i + 1 ] > 1 : <NEWLINE> <INDENT> count += lis [ i ] // 2 + 1 <NEWLINE> lis [ i + 1 ] -= 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> count += lis [ i ] // 2 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
import sys <NEWLINE> n = int ( sys . stdin . readline ( ) ) <NEWLINE> ans = 0 <NEWLINE> t = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a = int ( sys . stdin . readline ( ) ) <NEWLINE> if a == 0 : <NEWLINE> <INDENT> ans += t // 2 <NEWLINE> t = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> t += a <NEWLINE> <DEDENT> <DEDENT> if t > 0 : ans += t // 2 <NEWLINE> pritn ( ans ) <NEWLINE>
from collections import Counter <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = [ int ( input ( ) ) for i in range ( n ) ] <NEWLINE> b = Counter ( a [ : : 2 ] ) <NEWLINE> a . sort ( ) <NEWLINE> c = Counter ( a [ : : 2 ] ) <NEWLINE> <NL> ans = 0 <NEWLINE> for i in b : <NEWLINE> <INDENT> if i in c : <NEWLINE> <INDENT> ans += abs ( b [ i ] ) - c [ i ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += b [ i ] <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> from subprocess import Popen , PIPE <NEWLINE> from itertools import groupby <NEWLINE> from collections import Counter <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> sys . stdin . readline ( ) <NEWLINE> S = sys . stdin . read ( ) <NEWLINE> T = [ ] <NEWLINE> inv_dict = { } <NEWLINE> Factors = Popen ( <STRING> + S , stdout = PIPE ) . communicate ( ) [ 0 ] . split ( <STRING> ) <NEWLINE> for factors in Factors : <NEWLINE> <INDENT> factors = map ( int , factors . split ( ) [ 1 : ] ) <NEWLINE> t = 1 <NEWLINE> t_inv = 1 <NEWLINE> for f , group in groupby ( factors ) : <NEWLINE> <INDENT> n = len ( list ( group ) ) % 3 <NEWLINE> if n == 1 : <NEWLINE> <INDENT> t *= f <NEWLINE> <DEDENT> elif n == 2 : <NEWLINE> <INDENT> t_inv *= f <NEWLINE> <DEDENT> <DEDENT> t , t_inv = t * t_inv * t_inv , t * t * t_inv <NEWLINE> T . append ( t ) <NEWLINE> inv_dict [ t ] = t_inv <NEWLINE> <NL> <DEDENT> counter_T = Counter ( T ) <NEWLINE> ans = 0 <NEWLINE> for t , t_cnt in counter_T . items ( ) : <NEWLINE> <INDENT> if t == 1 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> continue <NEWLINE> <DEDENT> t_inv = inv_dict [ t ] <NEWLINE> t_inv_cnt = counter_T [ t_inv ] <NEWLINE> if t_cnt > t_inv_cnt or ( t_cnt == t_inv_cnt and t > t_inv ) : <NEWLINE> <INDENT> ans += t_cnt <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> Sum = 0 <NEWLINE> for i in range ( len ( A ) ) : <NEWLINE> <INDENT> Sum += ( A [ 0 ] - A [ i ] ) ** 2 <NEWLINE> <DEDENT> Answer = Sum <NEWLINE> for j in range ( len ( A ) ) : <NEWLINE> <INDENT> Sum = 0 <NEWLINE> for k in range ( - 100 , 101 ) : <NEWLINE> <INDENT> Sum += ( A [ k ] - j ) ** 2 <NEWLINE> <DEDENT> Answer = min ( Answer , Sum ) <NEWLINE> <DEDENT> print ( Answer ) <NEWLINE> <NL>
N = int ( input ( ) ) <NEWLINE> Print ( N * ( N + 1 ) // 2 ) <NEWLINE>
k = 0 <NEWLINE> <NL> for i in range ( N + 1 ) : <NEWLINE> <INDENT> k += i <NEWLINE> <NL> <DEDENT> print ( k ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <INDENT> = int ( input ( ) ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> answer = ( n + 1 ) * n / 2 <NEWLINE> <NL> print ( answer ) <NEWLINE>
for i in N : <NEWLINE> <INDENT> x += 1 <NEWLINE> <DEDENT> print ( x ) <NEWLINE>
val1 = int ( input ( ) ) <NEWLINE> <NL> print ( val1 * ( val1 + 1 ) / ) <NEWLINE>
print ( sum ( list ( range ( 1 , int ( input ( ) + 1 ) ) ) ) ) <NEWLINE>
number = input ( ) <NEWLINE> answer = 0 <NEWLINE> <NL> for i in range ( number ) : <NEWLINE> <INDENT> number = number + 1 <NEWLINE> answer = answer + number <NEWLINE> <NL> <DEDENT> print ( answer ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> res = int ( N ( N + 1 ) / 2 ) <NEWLINE> print ( res ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> print ( N * ( N + 1 ) ) / 2 <NEWLINE>
N = ini ( ) <NEWLINE> print ( int ( ( N * ( N + 1 ) ) / 2 ) ) <NEWLINE> <STRING> <NEWLINE>
def iroha ( ) : <NEWLINE> <INDENT> count = int ( input ( ) ) <NEWLINE> result = 0 <NEWLINE> for i in range ( count + 1 ) : <NEWLINE> <INDENT> result += i <NEWLINE> <NL> <DEDENT> print ( result ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> iroha ( <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> ans = 1 <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> ans += ans + i <NEWLINE> <DEDENT> print ( answer ) <NEWLINE>
<NL> N = int ( input ( ) ) <NEWLINE> list = [ int ( a ) for a in input ( ) . split ( ) ] <NEWLINE> <NL> A = sum ( list ) // N <NEWLINE> ans = 0 <NEWLINE> <NL> for k in range ( N ) : <NEWLINE> <INDENT> ans = ans + ( list [ j ] - A ) ** 2 <NEWLINE> <NL> <DEDENT> for i in range ( - 100 , 100 ) : <NEWLINE> <INDENT> sum = 0 <NEWLINE> sum_new = 0 <NEWLINE> for j in range ( N ) : <NEWLINE> <INDENT> sum_new = sum_new + ( list [ j ] - i ) ** 2 <NEWLINE> <DEDENT> if ( sum > sum_new ) : <NEWLINE> <INDENT> ans = sum_new <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = input ( ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> ans += i <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , N + 1 ) <NEWLINE> <INDENT> ans += i <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 10 ** 18 <NEWLINE> for num in range ( - 100 , 101 ) : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> cnt += ( num - a [ i ] ) ** 2 <NEWLINE> <DEDENT> ans = min ( ans , cnt ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
def candy ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> <INDENT> a = 0 <NEWLINE> for i in range ( 0 , n ) <NEWLINE> <INDENT> a = a + 1 <NEWLINE> <DEDENT> print ( a ) <NEWLINE> <NL> <DEDENT> <DEDENT> candy ( 10 ) <NEWLINE>
n = int ( input ( ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> ans += i <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> for ( i = 1 ; i <= N ; i + + ) : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> print ( i ) <NEWLINE>
ame = N * ( N + 1 ) / 2 <NEWLINE> print ( ame ) <NEWLINE>
<COMMENT> <NL> <NL> N = int ( input ( ) ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> a = N + 1 <NEWLINE> b = N <NEWLINE> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> print ( math . floor ( a * b / 2 ) <NEWLINE>
<COMMENT> <NL> a = 1 <NEWLINE> <NL> <COMMENT> <NL> b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <COMMENT> <NL> answer = a + b + c <NEWLINE> <NL> <COMMENT> <NL> print ( answer ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> ans = n ( 1 + n ) / 2 <NEWLINE> print ( ans ) <NEWLINE>
N = input ( ) <NEWLINE> print ( N * ( N + 1 ) / 2 ) <NEWLINE>
<NL> <NL> <NL> <NL> <COMMENT> <NL> n = input ( ) <NEWLINE> n = int ( input ( ) ) <NEWLINE> candy = ( 1 / 2 ) * n * ( n + 1 ) <NEWLINE> print ( int ( candy ) ) <NEWLINE> <COMMENT> <NL> <NL> <NL>
x = N <NEWLINE> if x % 2 == 1 : <NEWLINE> <INDENT> print ( ( N + 1 ) * ( N // 2 ) + ( N + 1 ) / 2 ) <NEWLINE> <DEDENT> if x % 2 == 0 : <NEWLINE> <INDENT> print ( ( N + 1 ) * N / 2 ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> num = 0 <NEWLINE> for num in range ( n + 1 ) : <NEWLINE> <INDENT> total = total + num <NEWLINE> <DEDENT> print ( total ) <NEWLINE>
n = input ( ) <NEWLINE> print ( n * ( n + 1 ) / 2 ) <NEWLINE>
N = input ( ) <NEWLINE> sum = 0 <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> sum += i ** 2 <NEWLINE> <NL> <DEDENT> print ( sum ) <NEWLINE>
<INDENT> AN <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <DEDENT> N = int ( input ( ) ) <NEWLINE> <COMMENT> <NL> <NL> <COMMENT> <NL> answer = ( N * ( N + 1 ) // 2 ) <NEWLINE> <NL> print ( answer ) <NEWLINE>
candy = N * N / 2 + N / 2 <NEWLINE> <NL> print ( candy ) <NEWLINE>
n = int ( input ( ) <NEWLINE> <NL> total = 0 <NEWLINE> <NL> for i in range ( n + 1 ) : <NEWLINE> <INDENT> total += i <NEWLINE> <NL> <DEDENT> print ( total ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> while n > 0 : <NEWLINE> <INDENT> a += n <NEWLINE> n -= 1 <NEWLINE> <DEDENT> print ( a ) <NEWLINE>
<NL> opperations = list ( input ( ) ) <NEWLINE> display_stack = [ ] <NEWLINE> for opperation in opperations : <NEWLINE> <INDENT> if opperation == <STRING> : <NEWLINE> <INDENT> if display_stack : <NEWLINE> <INDENT> display_stack . pop ( ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> display_stack . append ( opperation ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> . join ( display_stack ) ) <NEWLINE>  <NEWLINE>
<INDENT> s = input ( ) <NEWLINE> ans = <STRING> <NEWLINE> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> ans += <STRING> <NEWLINE> <NL> <DEDENT> elif s [ i ] == <STRING> : <NEWLINE> <INDENT> ans += <STRING> <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> if ans != <STRING> : <NEWLINE> <INDENT> ans = ans [ : - 1 ] <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
<COMMENT> <NL> input = input ( ) <NEWLINE> <NL> lst = [ ] <NEWLINE> text = <STRING> <NEWLINE> <NL> <COMMENT> <NL> for i in range ( len ( input ) ) : <NEWLINE> <INDENT> if input [ i ] == <STRING> : <NEWLINE> <INDENT> text = text + <STRING> <NEWLINE> <DEDENT> elif input [ i ] == <STRING> : <NEWLINE> <INDENT> text = text + <STRING> <NEWLINE> <DEDENT> elif input [ i ] = <STRING> : <NEWLINE> <INDENT> if text != <STRING> : <COMMENT> <NEWLINE> <INDENT> text = text [ : - 1 ] <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> print ( text ) <NEWLINE>
s = [ ] <NEWLINE> a = int ( input ( ) ) <NEWLINE> <NL> if a == 0 : <NEWLINE> <INDENT> s . append ( 0 ) <NEWLINE> <DEDENT> elif a == 1 : <NEWLINE> <INDENT> s . append ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if len ( s ) > 0 : <NEWLINE> <INDENT> s . pop ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> for l in s : <NEWLINE> <INDENT> print ( l ) <NEWLINE> <DEDENT>
s = list ( str ( input ( ) ) ) <NEWLINE> <NL> ans = [ ] <NEWLINE> for i in s : <NEWLINE> <INDENT> if i == <STRING> : <NEWLINE> <INDENT> ans . append ( <STRING> ) <NEWLINE> <DEDENT> elif i == <STRING> : <NEWLINE> <INDENT> ans . append ( 0 , <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if ans : <NEWLINE> <INDENT> ans . pop ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> . join ( ans ) ) <NEWLINE>
s = input ( ) <NEWLINE> txt = [ ] <NEWLINE> <NL> for c in s : <NEWLINE> <INDENT> if c == <STRING> & & len ( txt ) > 0 : <NEWLINE> <INDENT> txt . pop ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> txt . append ( c ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> . join ( txt ) ) <NEWLINE>
s = str ( input ( ) ) <NEWLINE> a = [ ] <NEWLINE> <NL> for i in len ( s ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> a . append ( <STRING> ) <NEWLINE> <DEDENT> elif s [ i ] == <STRING> : <NEWLINE> <INDENT> a . append ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if len ( a ) != 0 : <NEWLINE> <INDENT> a . pop ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> . join ( a ) ) <NEWLINE>
def key ( ) : <NEWLINE> <INDENT> a = input ( ) <NEWLINE> b = input ( ) <NEWLINE> c = input ( ) <NEWLINE> d = input ( ) <NEWLINE> key = [ a , b , c , d ] <NEWLINE> if key [ 0 ] == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif key [ 0 ] == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> if key [ 1 ] == <STRING> : <NEWLINE> <INDENT> key . pop ( ) <NEWLINE> <DEDENT> elif key [ 1 ] == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> if key [ 2 ] == <STRING> : <NEWLINE> <INDENT> key . pop ( ) <NEWLINE> <DEDENT> elif key [ 2 ] == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> if key [ 3 ] == <STRING> : <NEWLINE> <INDENT> key . pop ( ) <NEWLINE> <DEDENT> elif key [ 3 ] == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> key ( ) <NEWLINE>
r = [ ] <NEWLINE> for i in input ( ) : <NEWLINE> <INDENT> if <STRING> == i : <NEWLINE> <INDENT> if r : <NEWLINE> <INDENT> r . pop ( ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> r . append ( i ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> . join ( r ) <NEWLINE>
n = input ( ) <NEWLINE> a = <STRING> <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if i == <STRING> : <NEWLINE> <INDENT> a += i <NEWLINE> <DEDENT> elif i == <STRING> : <NEWLINE> <INDENT> a += i <NEWLINE> <DEDENT> elif i == <STRING> : <NEWLINE> <INDENT> a = a [ : - 1 ] <NEWLINE> <DEDENT> <DEDENT> print ( a ) <NEWLINE>
import re <NEWLINE> text = input ( ) <NEWLINE> b_length = int ( re . sub ( <STRING> , <STRING> , text ) ) <NEWLINE> for _ in range ( b_length ) : <NEWLINE> <INDENT> text = re . sub ( <STRING> , <STRING> , text , 1 ) <NEWLINE> <DEDENT> print ( text ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <NL> s = input ( ) <NEWLINE> listAns = [ ] <NEWLINE> <NL> set1 = [ <STRING> , <STRING> ] <NEWLINE> set2 = [ <STRING> ] <NEWLINE> <NL> listS = list ( s ) <NEWLINE> <NL> print ( listS ) <NEWLINE> <NL> for i in listS : <NEWLINE> <INDENT> if i in set1 : <NEWLINE> <INDENT> listAns . append ( i ) <NEWLINE> <NL> <DEDENT> elif i in set2 : <NEWLINE> <INDENT> if len ( listAns ) != 0 : <NEWLINE> <INDENT> listAns . pop ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> ans = reduce ( lambda x , y : x + y , [ str ( x ) for x in listAns ] ) <NEWLINE> <NL> print ( ans ) <NEWLINE>
s = input ( ) <NEWLINE> <NL> ans = <STRING> <NEWLINE> for x in s : <NEWLINE> <INDENT> if ans < > <STRING> : <NEWLINE> <INDENT> if x == <STRING> <NEWLINE> <INDENT> ans = ans [ : - 1 ] <NEWLINE> continue <NEWLINE> <DEDENT> <DEDENT> if x < > <STRING> : <NEWLINE> <INDENT> ans += x <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import bisect , collections , copy , heapq , itertools , math , numpy , string <NEWLINE> from fractions import gcd <NEWLINE> import sys <NEWLINE> def I ( ) : return int ( sys . stdin . readline ( ) . rstrip ( ) ) <NEWLINE> def LI ( ) : return list ( map ( int , sys . stdin . readline ( ) . rstrip ( ) . split ( ) ) ) <COMMENT> <NEWLINE> def S ( ) : return sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> def LS ( ) : return list ( sys . stdin . readline ( ) . rstrip ( ) . split ( ) ) <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> N = S ( ) <NEWLINE> L = [ i for i in N ] <NEWLINE> <NL> for i , num in enumerate ( L ) : <NEWLINE> <INDENT> if ( i != 0 and num == <STRING> ) : <NEWLINE> <INDENT> L [ i - 1 ] = <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> L . remove ( <STRING> ) <NEWLINE> print ( <STRING> . join ( L ) ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> for i in range ( len ( s ) - 1 ) : <NEWLINE> <INDENT> if s [ i + 1 ] != <STRING> : <NEWLINE> <INDENT> ans += s [ i ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> an = list ( map ( int , input ( ) ) ) <NEWLINE> <NL> cost = 10000 * 3 <NEWLINE> ans = 10000 * 3 <NEWLINE> for i in range ( - 100 , 100 + 1 ) : <NEWLINE> <INDENT> cost = sum ( [ ( j - i ) ** 2 for j in an ] ) <NEWLINE> ans = min ( ans , cost ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( split ( ) ) ) ) <NEWLINE> <NL> ans = 1e9 <NEWLINE> for p in a : <NEWLINE> <INDENT> sub = 0 <NEWLINE> for q in a : <NEWLINE> <INDENT> sub += pow ( p - q , 2 ) <NEWLINE> <DEDENT> ans = min ( ans , sub ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
<NL> N = int ( input ( ) ) <NEWLINE> list = [ int ( a ) for a in input ( ) . split ( ) ] <NEWLINE> <NL> A = sum ( list ) // N <NEWLINE> <NL> for k in range ( N ) : <NEWLINE> <INDENT> ans = ( list [ j ] - A ) ** 2 <NEWLINE> <NL> <DEDENT> for i in range ( - 100 , 100 ) : <NEWLINE> <INDENT> sum = 0 <NEWLINE> sum_new = 0 <NEWLINE> for j in range ( N ) : <NEWLINE> <INDENT> sum = sum + ( list [ j ] - A ) ** 2 <NEWLINE> sum_new = sum_new + ( list [ j ] - i ) ** 2 <NEWLINE> <DEDENT> if ( sum > sum_new ) : <NEWLINE> <INDENT> ans = sum_new <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> l_ans = [ [ ] for _ in range ( 200 ) ] <NEWLINE> <NL> for i in range ( - 100 , 101 ) : <NEWLINE> <INDENT> sum = 0 <NEWLINE> <NL> for j in range ( N ) : <NEWLINE> <INDENT> sum = sum + ( i - l [ j ] ) ** 2 <NEWLINE> <NL> <DEDENT> l_ans [ i + 100 ] = sum <NEWLINE> <NL> <DEDENT> print ( l_ans ) <NEWLINE> print ( min ( l_ans ) ) <NEWLINE>
import math <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = [ int ( a ) for a in input ( ) . split ( <STRING> ) ] <NEWLINE> ave = sum ( A ) / N <NEWLINE> can1 = math . floor ( ave ) <NEWLINE> can2 = math . ceil ( ave ) <NEWLINE> <NL> cost1 = sum ( [ ( a - can1 ) ** 2 for a in A ] ) <NEWLINE> cost2 = sum ( [ ( a - can2 ) ** 2 for a in A ] ) <NEWLINE> print ( min [ cost1 , cost2 ] ) <NEWLINE>
a = int ( input ( ) ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c = int ( input ( ) ) <NEWLINE> d = 0 <NEWLINE> <NL> for i in b : <NEWLINE> <INDENT> d += ( int ( i ) - int ( c ) ) ** 2 <NEWLINE> <DEDENT> print ( d ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = INF <NEWLINE> for i in range ( - 100 , 101 ) : <NEWLINE> <INDENT> val = 0 <NEWLINE> for a in A : <NEWLINE> <INDENT> val += ( a - i ) ** 2 <NEWLINE> <DEDENT> ans = min ( ans , val ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
def resolve ( ) : <NEWLINE> <INDENT> S = list ( input ( ) ) <NEWLINE> if len ( S ) == 2 : <NEWLINE> <INDENT> print ( - 1 , - 1 ) <NEWLINE> <DEDENT> for i in range ( len ( S ) - 3 ) : <NEWLINE> <INDENT> if S [ i ] == S [ i + 1 ] or S [ i + 1 ] == S [ i + 2 ] or S [ i + 2 ] == S [ i ] ) : <NEWLINE> <INDENT> print ( i + 1 , i + 3 ) <NEWLINE> return <NEWLINE> <DEDENT> <DEDENT> print ( - 1 , - 1 ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> resolve ( ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> N = len ( s ) <NEWLINE> if N == 2 : <NEWLINE> <INDENT> if s [ 0 ] == s [ 1 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> quit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> quit ( ) <NEWLINE> <DEDENT> <DEDENT> for i in range ( N - 2 ) : <NEWLINE> <INDENT> if s [ i ] == s [ i + 1 ] or s [ i ] == s [ i + 2 ] : <NEWLINE> <INDENT> print ( i + 1 , i + 3 ) <NEWLINE> quit ( ) <NEWLINE> <DEDENT> <DEDENT> if s [ - 1 ] == s [ - 2 ] : <NEWLINE> <INDENT> print ( N - 1 , N <NEWLINE> quit ( ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE>
if a > 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> if a <= 0 and b >= 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if ( b - a + 1 ) % 2 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
a , b = map ( int , inout ( ) . split ( ) ) <NEWLINE> if a >= 0 : <NEWLINE> <INDENT> print ( <STRING> if a != 0 else <STRING> ) <NEWLINE> <DEDENT> if a < 0 and b > 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> if b <= 0 : <NEWLINE> <INDENT> if b == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if ( a - b + 1 ) % 2 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> c = b - a <NEWLINE> if a <= 0 <= b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> elif a > 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> elif b < 0 : a <NEWLINE> <INDENT> if c % 2 == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if ab <= 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a > 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif b < 0 : <NEWLINE> <INDENT> if ( b - a + 1 ) % 2 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> c = ( b - a + 1 ) * ( a + b ) // 2 <NEWLINE> if c > 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif c = 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b = map ( int ( input ( ) . split ( ) ) <NEWLINE> if a > 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a < 0 : <NEWLINE> <INDENT> if ( b - a ) % 2 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if a > 0 and b > 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> elif a = 0 or b = 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> elif a < 0 and 0 < b : <NEWLINE> <INDENT> if abs ( a ) % 2 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if abs ( b - a ) % 2 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> possible = [ 0 ] * n <NEWLINE> kosuu = [ 1 ] * n <NEWLINE> possible [ 0 ] = 1 <NEWLINE> <NL> L = [ ] <NEWLINE> <NL> if flag == False : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> for i in range ( m ) : <NEWLINE> <INDENT> x , y = L [ i ] [ 0 ] , L [ i ] [ 1 ] <NEWLINE> x , y = x - 1 , y - 1 <NEWLINE> if kosuu [ x ] >= 2 and possible [ x ] == 1 : <NEWLINE> <INDENT> possible [ y ] = 1 <NEWLINE> kosuu [ x ] -= 1 <NEWLINE> kosuu [ y ] += 1 <NEWLINE> <DEDENT> elif kosuu [ x ] == 1 and possible [ x ] == 1 : <NEWLINE> <INDENT> possible [ x ] = 0 <NEWLINE> possible [ y ] = 1 <NEWLINE> kosuu [ x ] = 0 <NEWLINE> kosuu [ y ] += 1 <NEWLINE> <DEDENT> elif kosuu [ x ] >= 2 and possible [ x ] == 0 : <NEWLINE> <INDENT> kosuu [ x ] -= 1 <NEWLINE> kosuu [ y ] += 1 <NEWLINE> <DEDENT> elif kosuu [ x ] == 1 and possible [ x ] == 0 : <NEWLINE> <INDENT> kosuu [ x ] = 0 <NEWLINE> kosuu [ y ] += 1 <NEWLINE> <DEDENT> <DEDENT> print ( sum ( possible ) ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> d = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> def is_ok ( num ) : <NEWLINE> <INDENT> s = str ( num ) <NEWLINE> for ng in d : <NEWLINE> <INDENT> if ng in s : return False <NEWLINE> <NL> <DEDENT> return True <NEWLINE> <NL> <DEDENT> while True : <NEWLINE> <INDENT> if is_ok ( n ) : <NEWLINE> <INDENT> print ( n ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> n += 1 <NEWLINE> <DEDENT>
class Factorial : <NEWLINE> <INDENT> def __init__ ( self , max_fact , mod ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <INDENT> f = [ 1 ] * ( max_fact + 1 ) <NEWLINE> for idx in range ( 2 , max_fact + 1 ) : <NEWLINE> <INDENT> f [ idx ] = f [ idx - 1 ] * idx <NEWLINE> f [ idx ] %= mod <NEWLINE> <DEDENT> if mod > max_fact : <NEWLINE> <INDENT> fi = [ pow ( f [ - 1 ] , mod - 2 , mod ) ] <NEWLINE> for idx in range ( max_fact , 0 , - 1 ) : <NEWLINE> <INDENT> fi += [ fi [ - 1 ] * idx % mod ] <NEWLINE> <DEDENT> fi = fi [ : : - 1 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> fi = [ pow ( n , mod - 2 , mod ) for n in f ] <NEWLINE> <DEDENT> self . mod = mod <NEWLINE> self . f = f <NEWLINE> self . fi = fi <NEWLINE> <NL> <DEDENT> def factorial ( self , n ) : <NEWLINE> <INDENT> return self . f [ n ] <NEWLINE> <NL> <DEDENT> def factorial_inverse ( self , n ) : <NEWLINE> <INDENT> return self . fi [ n ] <NEWLINE> <NL> <DEDENT> def combination ( self , n , r ) : <NEWLINE> <INDENT> f = self . f <NEWLINE> fi = self . fi <NEWLINE> return f [ n ] * fi [ r ] * fi [ n - r ] % self . mod <NEWLINE> <NL> <DEDENT> def permutation ( self , n , r ) : <NEWLINE> <INDENT> return self . f [ n ] * self . fi [ n - r ] % self . mod <NEWLINE> <NL> <DEDENT> def homogeneous_product ( self , n , r ) : <NEWLINE> <INDENT> f = self . f <NEWLINE> fi = self . fi <NEWLINE> return f [ n + r - 1 ] * fi [ r ] * fi [ n - 1 ] % self . mod <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> max_fact = 2 * 10 ** 6 <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> fact_instance = Factorial ( max_fact , mod ) <NEWLINE> comb = fact_instance . combination <NEWLINE> perm = fact_instance . permutation <NEWLINE> combrep = fact_instance . homogeneous_product <NEWLINE> <NL> H , W , A , B = [ int ( _ ) for _ in input ( ) . split ( ) ] <NEWLINE> ans = comb ( H + W - 2 , H - 1 ) <NEWLINE> for x in range ( H - A , H ) : <NEWLINE> <INDENT> ans -= comb ( x + B - 1 , B - 1 ) * ( H - 1 - x + W - B , W - B ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> if ( ( a * b * c ) % 7 = 0 ) and ( ( a * b * c ) / 7 = 25 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
A , B , C = int ( input ( ) ) <NEWLINE> res = <STRING> <NEWLINE> if A == 5 or A == 7 : <NEWLINE> <INDENT> if B == 5 or B == 7 : <NEWLINE> <INDENT> if C == 5 or C == 7 : <NEWLINE> <INDENT> if A + B + C == 17 : <NEWLINE> <INDENT> res = <STRING> <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( res ) <NEWLINE>
stdin << A , B , C <NEWLINE> lst = [ A , B , C ] <NEWLINE> sl = sort ( lst ) <NEWLINE> if sl [ 0 ] == 5 & & sl [ 1 ] == 5 & & sl [ 2 ] == 7 <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n , l = map ( int , input ( ) . split ( ) ) <NEWLINE> s = sorted ( [ input ( ) for i in range ( n ) ] ) <NEWLINE> print ( * s , sep = <STRING> ) <NEWLINE>
l = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> l = sorted ( l ) <NEWLINE> if l . count ( 5 ) == 2 and l . count ( 7 ) == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> <NEWLINE> <DEDENT>
a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> num_5 = 0 <NEWLINE> num_7 = 0 <NEWLINE> <NL> for i in a : <NEWLINE> <INDENT> if i == <STRING> : <NEWLINE> <INDENT> num_5 = num_5 + 1 <NEWLINE> <DEDENT> if i == <STRING> : <NEWLINE> <INDENT> num_7 = num_7 + 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if num_5 = 2 and num_7 = 1 : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT>
def test ( ) : <NEWLINE> <INDENT> x = input ( ) <NEWLINE> x = x . split ( ) <NEWLINE> if x = [ <STRING> , <STRING> , <STRING> ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif x = [ <STRING> , <STRING> , <STRING> ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif x = [ <STRING> , <STRING> , <STRING> ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
data = input ( ) . split ( ) <NEWLINE> <NL> seven = 0 <NEWLINE> five = 0 <NEWLINE> <NL> for i in range ( data ) : <NEWLINE> <INDENT> if int ( i ) == 7 : <NEWLINE> <INDENT> seven += 1 <NEWLINE> <DEDENT> elif int ( i ) == 5 : <NEWLINE> <INDENT> five += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if seven == 1 and five == 2 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> iroha = [ a , b , c ] <NEWLINE> <NL> if iroha . count ( 2 ) == 5 and iroha . count ( 1 ) == 7 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> prnt ( <STRING> ) <NEWLINE> <DEDENT>
def test ( ) : <NEWLINE> <INDENT> arr = input ( ) <NEWLINE> arr = [ int ( i ) for i in arr ] <NEWLINE> arr = sorted ( arr ) <NEWLINE> if arr == [ 5 , 5 , 7 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> test ( ) <NEWLINE>
a , b , c = sorted ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if ( a + b + c == 17 ) & ( a == b ) & ( c == 7 ) : <NEWLINE> <INDENT> return ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return ( <STRING> ) <NEWLINE> <DEDENT>
A , B , C = list ( map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> if [ A , B , C ] . count ( 5 ) == 2 and [ A , B , C ] . count ( 7 ) == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) ) <NEWLINE> <DEDENT>
i = 0 <NEWLINE> k_n = [ ] <NEWLINE> k_n_all = [ 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 ] <NEWLINE> <NL> p_price , k_number = map ( int , input ( ) . split ( ) ) <NEWLINE> k_n = map ( int , input ( ) . split ( ) ) <NEWLINE> result_number = list ( set ( k_n_all ) - set ( k_n ) ) <NEWLINE> result_price = p_price <NEWLINE> <NL> while True : <NEWLINE> <INDENT> x = 0 <NEWLINE> y = 0 <NEWLINE> z = list ( map ( int , str ( result_price ) ) ) <NEWLINE> while x < len ( z ) : <NEWLINE> <INDENT> if z [ x ] in result_number : <NEWLINE> <INDENT> y += 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> y += 1 <NEWLINE> <DEDENT> x += 1 <NEWLINE> <NL> <DEDENT> if y == 0 : <NEWLINE> <INDENT> print ( result_price ) <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> result_price += 1 <NEWLINE> <DEDENT> <DEDENT>
list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> five = 0 <NEWLINE> seven = 0 <NEWLINE> <NL> for i in list : <NEWLINE> <INDENT> if i == 5 : <NEWLINE> <INDENT> five += 1 <NEWLINE> <DEDENT> elif i == 7 : <NEWLINE> <INDENT> seven += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> pass <NEWLINE> <NL> <DEDENT> <DEDENT> if seven == 1 and five == 2 : <NEWLINE> <INDENT> print ( TRUE ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( NO ) <NEWLINE> <DEDENT>
A , B , C = map ( int , input ( ) . sprit ( ) ) <NEWLINE> if sorted [ A , B , C ] = [ 5 , 5 , 7 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> if sum ( a , b , c ) == 17 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> sort ( A ) <NEWLINE> if A == [ 5 , 5 , 7 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT>
a = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> success_cases = [ ( a [ 0 ] , a [ 1 ] , a [ 2 ] ) , ( a [ 1 ] , a [ 2 ] , a [ 0 ] ) , a [ 2 ] , a [ 0 ] , a [ 1 ] ) ] <NEWLINE> <NL> for c in success_cases : <NEWLINE> <INDENT> if c == ( 5 , 7 , 5 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> return <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> <NL>
a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if a = 5 , b = 5 , c = 7 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a = 5 , b = 7 , c = 5 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a = 7 , b = 5 , c = 5 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if len ( a ) == 7 : <NEWLINE> <INDENT> if len ( b ) == 5 and len ( c ) == 5 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> if len ( b ) == 7 : <NEWLINE> <INDENT> if len ( a ) == 5 and len ( c ) == 5 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> if len ( c ) == 7 : <NEWLINE> <INDENT> if len ( a ) == 5 and len ( b ) == 5 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
s = input ( ) <NEWLINE> s = s . split ( ) <NEWLINE> <NL> s . sort ( ) <NEWLINE> <NL> if s = [ <STRING> , <STRING> , <STRING> ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
<INDENT> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> counter5 = 0 <NEWLINE> counter7 = 0 <NEWLINE> <NL> for num in l : <NEWLINE> <INDENT> if num == 5 : <NEWLINE> <INDENT> counter5 += 1 <NEWLINE> <NL> <DEDENT> if num == 7 : <NEWLINE> <INDENT> counter7 += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if counter5 == 2 and counter7 == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
nums = map ( int , input ( ) . split ( ) ) <NEWLINE> if nums . count ( 5 ) == 2 and nums . count ( 7 ) == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
if ( a == 5 & b == 7 & c == 5 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif ( a == 7 & b == 5 & c == 5 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif ( a == 5 & b == 5 & c == 7 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a = int ( input ( ) ) <NEWLINE> b = int ( input ( ) ) <NEWLINE> c = int ( input ( ) ) <NEWLINE> if a > b or b > c or a > c or a > b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if a + b + c == 19 and a . count ( <STRING> ) == 2 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
x = input ( ) . split ( ) <NEWLINE> fn = 0 <NEWLINE> sn = 0 <NEWLINE> <NL> for i in range ( len ( x ) ) : <NEWLINE> <INDENT> if int ( x [ i ] ) == 5 : <NEWLINE> <INDENT> fn += 1 <NEWLINE> <DEDENT> elif int ( x [ i ] ) == 7 : <NEWLINE> <INDENT> sn += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if fn = 2 : <NEWLINE> <INDENT> if sn = 5 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N , L = map ( int , input ( ) . split ( ) ) <NEWLINE> S = sorted ( [ input ( ) for i in range ( N ) ] ) <NEWLINE> print ( <STRING> . join ( S ) ) <NEWLINE>
A , B , C = map ( int , input ( ) ) <NEWLINE> <NL> num5 = 0 <NEWLINE> num7 = 0 <NEWLINE> ans = <STRING> <NEWLINE> <NL> for num in [ A , B , C ] : <NEWLINE> <INDENT> if num == 5 : <NEWLINE> <INDENT> num5 += 1 <NEWLINE> <DEDENT> elif num == 7 : <NEWLINE> <INDENT> num7 += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> if num5 == 2 and num7 == 1 : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
s = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in s : <NEWLINE> <INDENT> if i == 5 : <NEWLINE> <INDENT> count5 += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> count7 += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if count5 == 2 and count7 == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> if a == b == 5 and c == 7 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a == c == 5 and b == 7 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif b == c == 5 amd c == 7 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
from sys import stdin <NEWLINE> <NL> A , B , C = [ int ( x ) for x in stdin . realine ( ) . rstrip ( ) . split ( ) ] <NEWLINE> <NL> if A + B + C == 17 and A >= 5 and B >= 5 and C >= 5 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> print ( n * ( n + 1 ) // 2 ) <NEWLINE>
a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> a , sort ( ) <NEWLINE> print ( <STRING> if a [ 0 ] == 5 and a [ 1 ] == 5 and a [ 2 ] == 7 else <STRING> ) <NEWLINE>
<COMMENT> <NL> <NL> def atc_042a ( input_value : str ) -> str : <NEWLINE> <INDENT> ABC = input_value . split ( <STRING> ) <NEWLINE> if ABC . count ( <STRING> ) == 2 and ABC . count ( <STRING> ) == 1 : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> return <STRING> <NEWLINE> <NL> <DEDENT> Input_value_1 = input ( ) <NEWLINE> print ( atc_042a ( input_value_1 ) ) <NEWLINE>
abc = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> abc . sort ( ) <NEWLINE> if a [ 0 ] == 5 and a [ 1 ] == 5 and a [ 2 ] == 7 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE>
L = input ( ) . split ( ) <NEWLINE> A , B , C = int ( L [ 0 ] ) , int ( L [ 1 ] ) , int ( L [ 2 ] ) <NEWLINE> X = set ( [ 5 , 7 ] ) <NEWLINE> ans = [ ] <NEWLINE> for i in range ( len ( X ) ) : <NEWLINE> <INDENT> ans . append ( [ A , B , C ] . count ( X [ i ] ) ) <NEWLINE> <DEDENT> if ans == [ 2 , 1 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
clause_list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for index , clause in enumerate ( clause_list ) : <NEWLINE> <INDENT> if clause = 5 : <NEWLINE> <INDENT> clause_list . pop ( index ) <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> for index , clause in enumerate ( clause_list ) : <NEWLINE> <INDENT> if clause = 7 : <NEWLINE> <INDENT> clause_list . pop ( index ) <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> for index , clause in enumerate ( clause_list ) : <NEWLINE> <INDENT> if clause = 5 : <NEWLINE> <INDENT> clause_list . pop ( index ) <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> if len ( clause_list ) == 0 else <STRING> ) <NEWLINE>
<COMMENT> <NL> list = list ( int , input ( ) . split ( ) ) <NEWLINE> <COMMENT> <NL> list . sort ( ) <NEWLINE> <NL> if list [ 0 ] == 5 and list [ 1 ] == 5 and list [ 2 ] == 7 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
S = int ( input ( ) ) <NEWLINE> <NL> if S . count ( 5 ) == 2 & & S . count ( 7 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <NL> a = int ( input ( ) ) <NEWLINE> b = int ( input ( ) ) <NEWLINE> c = int ( input ( ) ) <NEWLINE> <NL> if 7 == a : <NEWLINE> <INDENT> if 5 == b and 5 == c : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> <DEDENT> elif 5 == a : <NEWLINE> <INDENT> if ( 7 == b and 5 == c ) or ( 5 == b and 7 == c ) : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT>
A = input ( ) <NEWLINE> B = input ( ) <NEWLINE> C = input ( ) <NEWLINE> <NL> L = [ A , B , C ] <NEWLINE> <NL> for x in L : <NEWLINE> <INDENT> if len ( x ) == 7 : <NEWLINE> <INDENT> L . remove ( x ) <NEWLINE> for y in L : <NEWLINE> <INDENT> if len ( y ) != 5 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> if a == 5 and b == 7 and c == 7 ) or ( a == 7 and b == 5 and c == 7 ) or ( a == 7 and b == 7 c == 5 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
num = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> num = num . sorted <NEWLINE> if ( num [ 0 ] == 5 and num [ 1 ] == 5 and num [ 2 ] == 7 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s = map ( int ( input ( ) . split ( ) ) ) <NEWLINE> if s . count ( <STRING> ) == 1 and s . count ( <STRING> ) == 2 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> if __name__ == <STRING> : <NEWLINE> <INDENT> str_sum = sum ( [ map ( int , input ( ) . split ( ) ) ] ) <NEWLINE> if str_sum == 17 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
N , L = map ( int , input ( ) . split ( ) ) <NEWLINE> input_line1 = [ input ( ) for i in range ( N ) ] <NEWLINE> input_line2 = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> input_line2 . append ( min ( input_line1 ) ) <NEWLINE> <INDENT> input_line1 . remove ( min ( input_line1 ) ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> . join ( input_line2 ) ) <NEWLINE>
first = input ( ) <NEWLINE> first = first . split ( ) <NEWLINE> <NL> N = int ( first [ 0 ] ) <NEWLINE> L = [ ] <NEWLINE> for i in range ( N ) <NEWLINE> <INDENT> s = input ( ) <NEWLINE> L . append ( s ) <NEWLINE> <NL> <DEDENT> L . sort ( ) <NEWLINE> for i in L : <NEWLINE> <INDENT> print ( i , end = <STRING> ) <NEWLINE> <NL> <DEDENT>
n , l = map ( int , input ( ) . split ) <NEWLINE> s = sorted ( [ input ( ) for i in range ( n ) ] ) <NEWLINE> print ( * s , sep = <STRING> ) <NEWLINE>
N , L = map ( int , input ( ) . split ( ) ) <NEWLINE> S = [ input ( ) for s in range ( N ) ] <NEWLINE> S . sort ( ) <NEWLINE> output = <STRING> <NEWLINE> for i in S : <NEWLINE> <INDENT> output += i <NEWLINE> <DEDENT> prunt ( output ) <NEWLINE>
N , L = map ( int , input ( ) . split ( ) ) <NEWLINE> S = [ input ( ) for i in range ( N ) ] <NEWLINE> S . sorted ( ) <NEWLINE> for i in range ( len ( S ) ) : <NEWLINE> <INDENT> print ( S [ i ] ) <NEWLINE> <DEDENT>
N , L = map ( int , input ( ) . split ( ) ) <NEWLINE> string_list = [ input ( ) for i in range ( N ) ] <NEWLINE> string_list . sort ( ) <NEWLINE> print ( <STRING> . join ( string_list ) <NEWLINE>
n , l = map ( int , input ( ) , split ( ) ) <NEWLINE> s = [ input ( ) for _ in range ( n ) ] <NEWLINE> s . sort ( ) <NEWLINE> for k in s : <NEWLINE> <INDENT> print ( k , end = <STRING> ) <NEWLINE> <DEDENT>
<COMMENT> <NL> n , l = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> a = [ ] <NEWLINE> for i in range ( n ) <NEWLINE> <INDENT> a . append ( input ( ) ) <NEWLINE> <NL> <DEDENT> a . sort ( ) <NEWLINE> <NL> print ( <STRING> . join ( mylist ) ) <NEWLINE>
N , L = map ( int , input ( ) . split ( ) ) <NEWLINE> List = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> List . append ( int ( input ( ) ) ) <NEWLINE> <DEDENT> List . sort ( ) <NEWLINE> res = <STRING> <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> res += List [ i ] <NEWLINE> <DEDENT> print ( res ) <NEWLINE>
n , l = map ( int , input ( ) . split ( ) ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> list [ i ] = str ( input ( ) ) <NEWLINE> <DEDENT> newlist = list . sorted ( ) <NEWLINE> print ( newlist , sep = <STRING> ) <NEWLINE>
Firstline = input ( ) <NEWLINE> Firstline = Firstline . split ( ) <NEWLINE> <NL> List = [ ] <NEWLINE> for i in int ( Firstline [ 0 ] ) : <NEWLINE> <INDENT> List . append ( input ( ) ) <NEWLINE> <NL> <DEDENT> List . sort ( ) <NEWLINE> s = <STRING> <NEWLINE> for i in List : <NEWLINE> <INDENT> s += i <NEWLINE> <NL> <DEDENT> print ( s ) <NEWLINE>
l , n = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a . append ( input ( ) ) <NEWLINE> <DEDENT> a . sort ( ) <NEWLINE> b = <STRING> <NEWLINE> for i in a : <NEWLINE> <INDENT> b += a <NEWLINE> <DEDENT> print ( b ) <NEWLINE>
n , l = map ( int , input ( ) . split ( ) ) <NEWLINE> s = sorted ( [ map ( int , input ( ) . split ( ) ) for _ in range ( n ) ] ) <NEWLINE> print ( * s , sep = <STRING> ) <NEWLINE>
from sys import stdin , stdout <NEWLINE> from time import perf_counter <NEWLINE> <NL> import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> import sys <NEWLINE> sys . stdout = open ( <STRING> , <STRING> ) <NEWLINE> sys . stdin = open ( <STRING> , <STRING> ) <NEWLINE> <NL> <NL> <NL> n , l = map ( int , input ( ) . split ( ) ) <NEWLINE> s = [ input ( ) for _ in range ( n ) ] <NEWLINE> s . sort ( ) <NEWLINE> result = <STRING> . join ( s ) <NEWLINE> print ( s ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> s = sorted ( [ input ( ) for i in range ( n ) ] ) <NEWLINE> print ( * s , sep = <STRING> ) <NEWLINE>
from sys import stdin <NEWLINE> input = stdin . readline <NEWLINE> <NL> L , N = map ( int , input ( ) . split ( ) ) <NEWLINE> D = [ ] <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> D . append ( input ( ) <NEWLINE> <NL> <DEDENT> D . sort ( ) <NEWLINE> <NL> print ( <STRING> . join ( D ) ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <NL> import sys <NEWLINE> <NL> <NL> def input ( ) : <NEWLINE> <INDENT> return sys . stdin . readline ( ) . strip ( ) <NEWLINE> <NL> <NL> <DEDENT> def _main ( ) : <NEWLINE> <INDENT> input ( ) <NEWLINE> <INDENT> s = sorted ( list ( input ( ) . split ( ) ) ) <NEWLINE> print ( <STRING> . join ( s ) ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> _main ( ) <NEWLINE> <DEDENT>
n , l = map ( int , input ( ) . split ( ) ) <NEWLINE> s = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> s . append ( str ( input ( ) ) ) <NEWLINE> <NL> <DEDENT> a = <STRING> . join ( sorted ( s ) ) <NEWLINE> <NL> <NL> print ( a <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> s = sorted ( [ input ( ) for i in range ( N ) ] ) <NEWLINE> print ( * s , sep = <STRING> ) <NEWLINE>
5 5 7 <NEWLINE> Yes <NEWLINE> N , L = map ( int , input ( ) . split ( ) ) <NEWLINE> str_list = [ ] <NEWLINE> final_str = <STRING> <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> str_list . append ( input ( ) ) <NEWLINE> <DEDENT> new_list = sorted ( str_list ) <NEWLINE> for n in range ( N ) : <NEWLINE> <INDENT> final_str += new_list [ n ] <NEWLINE> <DEDENT> print ( final_str ) <NEWLINE> 3 3 <NEWLINE>
n , l = ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ss = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ss . append ( input ( ) ) <NEWLINE> <NL> <DEDENT> ss . sort ( ) <NEWLINE> print ( str . join ( ss ) ) <NEWLINE>
n , l = map ( int , input ( ) . split ( ) ) <NEWLINE> s = [ int ( input ( ) ) for _ in range ( n ) ] <NEWLINE> s . sort ( ) <NEWLINE> <NL> for i in s : <NEWLINE> <INDENT> print ( i , end = <STRING> ) <NEWLINE> <DEDENT>
<COMMENT> <NL> N , L = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> S = [ ] <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> S . add ( str ( input ( ) ) ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> print ( <STRING> . join ( sorted ( S ) ) ) <NEWLINE>
n , l = map ( int , input ( ) . split ( ) ) <NEWLINE> s = [ int ( input ( ) ) for i in range ( n ) ] <NEWLINE> <NL> s . sort ( ) <NEWLINE> S = <STRING> <NEWLINE> for i in s : <NEWLINE> <INDENT> S += i <NEWLINE> <DEDENT> print ( S ) <NEWLINE>
a = input ( ) . split ( ) <NEWLINE> tg = a [ 0 ] <NEWLINE> ok_nums = set ( <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ) <NEWLINE> ng_nums = set ( input ( ) . split ( ) ) <NEWLINE> ok_nums = ok_nums - ng_nums <NEWLINE> rt = 0 <NEWLINE> i = int ( tg ) <NEWLINE> while True : <NEWLINE> <INDENT> if ok_nums >= set ( d for d in str ( i ) ) : <NEWLINE> <INDENT> print ( i ) <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> i += 1 <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <NL> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> D = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> numList = [ 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 ] <NEWLINE> listAns = [ ] <NEWLINE> <NL> num = [ ] <NEWLINE> listN = [ int ( x ) for x in list ( str ( N ) ) ] <NEWLINE> <NL> <COMMENT> <NL> <NL> for i in numList : <NEWLINE> <INDENT> if i not in D : <NEWLINE> <INDENT> num . append ( i ) <NEWLINE> <NL> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> for i in listN : <NEWLINE> <INDENT> for j in num : <NEWLINE> <INDENT> if j >= i : <NEWLINE> <INDENT> listAns . append ( j ) <NEWLINE> break <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> ans = int ( reduce ( lambda x , y : x + y , [ str ( x ) for x in listAns ] ) ) <NEWLINE> print ( ans ) <NEWLINE>
n , k = input ( ) . split ( ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> checkNum = [ i for i in range ( 11 ) ] <NEWLINE> <NL> def find ( x ) : <NEWLINE> <INDENT> while x != checkNum [ x ] : <NEWLINE> <INDENT> checkNum [ x ] = checkNum [ checkNum [ x ] ] <NEWLINE> x = checkNum [ x ] <NEWLINE> <DEDENT> return x <NEWLINE> <NL> <DEDENT> for i in l : <NEWLINE> <INDENT> checkNum [ find ( i ) ] = checkNum [ find ( i + 1 ) ] <NEWLINE> <NL> <DEDENT> fin = <STRING> <NEWLINE> for i in range ( len ( n ) ) : <NEWLINE> <INDENT> first = int ( n [ i ] ) <NEWLINE> k = find ( first ) <NEWLINE> if k == first : <NEWLINE> <INDENT> fin += str ( k ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if k != 10 : <NEWLINE> <INDENT> fin += str ( k ) <NEWLINE> i += 1 <NEWLINE> <DEDENT> else : fin += str ( find ( 1 ) ) <NEWLINE> fin += str ( find ( 0 ) ) * ( len ( n ) - i ) <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> p <NEWLINE>
import itertools <NEWLINE> <NL> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> D = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> dic = [ 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 ] <NEWLINE> <NL> for i in D : <NEWLINE> <INDENT> dic . remove ( i ) <NEWLINE> <NL> <DEDENT> dict = map ( str , dic ) <NEWLINE> n = len ( str ( N ) ) <COMMENT> <NEWLINE> <NL> ans = [ ] <NEWLINE> for i in range ( 2 ) : <NEWLINE> <INDENT> for v in itertools . permutations ( dict , n + i ) : <NEWLINE> <INDENT> if int ( <STRING> . join ( v ) ) >= N : <NEWLINE> <INDENT> ans . append ( int ( <STRING> . join ( v ) ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( min ( ans ) ) <NEWLINE>
N , K = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> D = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> D_ = [ _ for _ in range ( 10 ) if _ not in D ] <NEWLINE> D_ . sort ( ) <NEWLINE> <NL> N_ = N + 1 <NEWLINE> break_flag = False <NEWLINE> for s_ in D_ : <NEWLINE> <INDENT> if break_flag : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> elif s_ == 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> for p in product ( D_ , repeat = len ( str ( N_ ) ) - 1 ) : <NEWLINE> <INDENT> ans = int ( str ( s_ ) + <STRING> . join ( map ( str , p ) ) ) <NEWLINE> if N + 1 <= ans : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> break_flag = True <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
import sys <NEWLINE> import numpy as np <NEWLINE> from heapq import heappush , heappop <NEWLINE> from bisect import bisect_left as bi_l , bisect_right as bi_r <NEWLINE> from collections import deque , Counter , defaultdict <NEWLINE> from itertools import combinations , product <NEWLINE> import string <NEWLINE> inf = float ( <STRING> ) <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> <COMMENT> <NL> <NL> <NL> class NumberTheory ( ) : <NEWLINE> <INDENT> def __init__ ( self , n = 2 * 10 ** 6 , numpy = True ) : <NEWLINE> <INDENT> self . n = n <NEWLINE> self . np_flg = numpy <NEWLINE> self . is_prime_number , self . prime_numbers = self . sieve_of_eratosthenes ( n ) <NEWLINE> <NL> <DEDENT> def sieve_of_eratosthenes ( self , n ) : <NEWLINE> <INDENT> if self . np_flg : <NEWLINE> <INDENT> sieve = np . ones ( n + 1 , dtype = np . int64 ) ; sieve [ : 2 ] = 0 <NEWLINE> for i in range ( 2 , int ( n ** .5 ) + 1 ) : <NEWLINE> <INDENT> if sieve [ i ] : sieve [ i * 2 : : i ] = 0 <NEWLINE> <DEDENT> prime_numbers = np . flatnonzero ( sieve ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> sieve = [ 1 ] * ( n + 1 ) ; sieve [ 0 ] = sieve [ 1 ] = 0 <NEWLINE> for i in range ( 2 , int ( n ** .5 ) + 1 ) : <NEWLINE> <INDENT> if not sieve [ i ] : continue <NEWLINE> for j in range ( i * 2 , n + 1 , i ) : sieve [ j ] = 0 <NEWLINE> <DEDENT> prime_numbers = [ i for i in range ( 2 , n + 1 ) if sieve [ i ] ] <NEWLINE> <DEDENT> return sieve , prime_numbers <NEWLINE> <NL> <DEDENT> def prime_factorize ( self , n ) : <NEWLINE> <INDENT> res = dict ( ) <NEWLINE> if n < 2 : return res <NEWLINE> border = int ( n ** .5 ) <NEWLINE> for p in self . prime_numbers : <NEWLINE> <INDENT> if p > border : break <NEWLINE> while n % p == 0 : res [ p ] = res . get ( p , 0 ) + 1 ; n //= p <NEWLINE> if n == 1 : return res <NEWLINE> <DEDENT> res [ n ] = 1 ; return res <NEWLINE> <NL> <DEDENT> def prime_factorize_factorial ( self , n ) : <NEWLINE> <INDENT> res = dict ( ) <NEWLINE> for i in range ( 2 , n + 1 ) : <NEWLINE> <INDENT> for p , c in self . prime_factorize ( i ) . items ( ) : res [ p ] = res . get ( p , 0 ) + c <NEWLINE> <DEDENT> return res <NEWLINE> <NL> <DEDENT> @ staticmethod <NEWLINE> def gcd ( a , b ) : return gcd ( b , a % b ) if b else abs ( a ) <NEWLINE> <NL> @ staticmethod <NEWLINE> def lcm ( a , b ) : return abs ( a // gcd ( a , b ) * b ) <NEWLINE> <NL> @ staticmethod <NEWLINE> def find_divisors ( n ) : <NEWLINE> <INDENT> divisors = [ ] <NEWLINE> for i in range ( 1 , int ( n ** .5 ) + 1 ) : <NEWLINE> <INDENT> if n % i : continue <NEWLINE> divisors . append ( i ) <NEWLINE> j = n // i <NEWLINE> if j != i : divisors . append ( j ) <NEWLINE> <DEDENT> return divisors <NEWLINE> <NL> <DEDENT> @ staticmethod <NEWLINE> def base_convert ( n , b ) : <NEWLINE> <INDENT> if not n : return [ 0 ] <NEWLINE> res = [ ] <NEWLINE> while n : <NEWLINE> <INDENT> n , r = divmod ( n , b ) <NEWLINE> if r < 0 : n += 1 ; r -= b <NEWLINE> res . append ( r ) <NEWLINE> <DEDENT> return res <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> class UnionFind ( ) : <NEWLINE> <INDENT> def __init__ ( self , n = 10 ** 6 ) : <NEWLINE> <INDENT> self . root = list ( range ( n ) ) <NEWLINE> self . height = [ 0 ] * n <NEWLINE> self . size = [ 1 ] * n <NEWLINE> <NL> <DEDENT> def find_root ( self , u ) : <NEWLINE> <INDENT> if self . root [ u ] == u : return u <NEWLINE> self . root [ u ] = self . find_root ( self . root [ u ] ) <NEWLINE> return self . root [ u ] <NEWLINE> <NL> <DEDENT> def unite ( self , u , v ) : <NEWLINE> <INDENT> ru = self . find_root ( u ) <NEWLINE> rv = self . find_root ( v ) <NEWLINE> if ru == rv : return <NEWLINE> hu = self . height [ ru ] <NEWLINE> hv = self . height [ rv ] <NEWLINE> if hu >= hv : <NEWLINE> <INDENT> self . root [ rv ] = ru <NEWLINE> self . size [ ru ] += self . size [ rv ] <NEWLINE> self . height [ ru ] = max ( hu , hv + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . root [ ru ] = rv <NEWLINE> self . size [ rv ] += self . size [ ru ] <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> class Combinatorics ( ) : <NEWLINE> <INDENT> def __init__ ( self , N = 10 ** 9 , n = 10 ** 6 , mod = 10 ** 9 + 7 , numpy = True ) : <NEWLINE> <INDENT> self . mod = mod <NEWLINE> self . nCr = dict ( ) <NEWLINE> self . np_flg = numpy <NEWLINE> self . make_mod_tables ( N , n ) <NEWLINE> <NL> <DEDENT> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> def choose ( self , n , r , mod = None ) : <COMMENT> <NEWLINE> <INDENT> if r > n or r < 0 : return 0 <NEWLINE> if r == 0 : return 1 <NEWLINE> if ( n , r ) in self . nCr : return self . nCr [ ( n , r ) ] <NEWLINE> if not mod : <NEWLINE> <INDENT> self . nCr [ ( n , r ) ] = ( self . choose ( n - 1 , r ) + self . choose ( n - 1 , r - 1 ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . nCr [ ( n , r ) ] = ( self . choose ( n - 1 , r , mod ) + self . choose ( n - 1 , r - 1 , mod ) ) % mod <NEWLINE> <DEDENT> return self . nCr [ ( n , r ) ] <NEWLINE> <NL> <DEDENT> def cumprod ( self , a ) : <NEWLINE> <INDENT> p = self . mod <NEWLINE> l = len ( a ) ; sql = int ( np . sqrt ( l ) + 1 ) <NEWLINE> a = np . resize ( a , sql ** 2 ) . reshape ( sql , sql ) <NEWLINE> for i in range ( sql - 1 ) : a [ : , i + 1 ] *= a [ : , i ] ; a [ : , i + 1 ] %= p <NEWLINE> for i in range ( sql - 1 ) : a [ i + 1 ] *= a [ i , - 1 ] ; a [ i + 1 ] %= p <NEWLINE> return np . ravel ( a ) [ : l ] <NEWLINE> <NL> <DEDENT> def make_mod_tables ( self , N , n ) : <NEWLINE> <INDENT> p = self . mod <NEWLINE> if self . np_flg : <NEWLINE> <INDENT> fac = np . arange ( n + 1 ) ; fac [ 0 ] = 1 ; fac = self . cumprod ( fac ) <NEWLINE> ifac = np . arange ( n + 1 , 0 , - 1 ) ; ifac [ 0 ] = pow ( int ( fac [ - 1 ] ) , p - 2 , p ) <NEWLINE> ifac = self . cumprod ( ifac ) [ n : : - 1 ] <NEWLINE> n_choose = np . arange ( N + 1 , N - n , - 1 ) ; n_choose [ 0 ] = 1 ; <NEWLINE> n_choose [ 1 : ] = self . cumprod ( n_choose [ 1 : ] ) * ifac [ 1 : n + 1 ] % p <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> fac = [ None ] * ( n + 1 ) ; fac [ 0 ] = 1 <NEWLINE> for i in range ( n ) : fac [ i + 1 ] = fac [ i ] * ( i + 1 ) % p <NEWLINE> ifac = [ None ] * ( n + 1 ) ; ifac [ n ] = pow ( fac [ n ] , p - 2 , p ) <NEWLINE> for i in range ( n , 0 , - 1 ) : ifac [ i - 1 ] = ifac [ i ] * i % p <NEWLINE> n_choose = [ None ] * ( n + 1 ) ; n_choose [ 0 ] = 1 <NEWLINE> for i in range ( n ) : n_choose [ i + 1 ] = n_choose [ i ] * ( N - i ) % p <NEWLINE> for i in range ( n + 1 ) : n_choose [ i ] = n_choose [ i ] * ifac [ i ] % p <NEWLINE> <DEDENT> self . fac , self . ifac , self . mod_n_choose = fac , ifac , n_choose <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def z_algorithm ( s ) : <NEWLINE> <INDENT> n = len ( s ) <NEWLINE> a = [ 0 ] * n ; a [ 0 ] = n <NEWLINE> l = r = - 1 <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> if r >= i : a [ i ] = min ( a [ i - l ] , r - i ) <NEWLINE> while i + a [ i ] < n and s [ i + a [ i ] ] == s [ a [ i ] ] : a [ i ] += 1 <NEWLINE> if i + a [ i ] >= r : l , r = i , i + a [ i ] <NEWLINE> <DEDENT> return a <NEWLINE> <NL> <NL> <DEDENT> class ABC001 ( ) : <NEWLINE> <INDENT> def A ( ) : <NEWLINE> <INDENT> h1 , h2 = map ( int , sys . stdin . read ( ) . split ( ) ) <NEWLINE> print ( h1 - h2 ) <NEWLINE> <NL> <DEDENT> def B ( ) : pass <NEWLINE> def C ( ) : pass <NEWLINE> def D ( ) : pass <NEWLINE> <NL> <NL> <DEDENT> class ABC002 ( ) : <NEWLINE> <INDENT> def A ( ) : <NEWLINE> <INDENT> x , y = map ( int , sys . stdin . readline ( ) . split ( ) ) <NEWLINE> print ( max ( x , y ) ) <NEWLINE> <NL> <DEDENT> def B ( ) : <NEWLINE> <INDENT> vowels = set ( <STRING> ) <NEWLINE> s = sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> t = <STRING> <NEWLINE> for c in s : <NEWLINE> <INDENT> if c in vowels : continue <NEWLINE> t += c <NEWLINE> <DEDENT> print ( t ) <NEWLINE> <NL> <DEDENT> def C ( ) : <NEWLINE> <INDENT> * coords , = map ( int , sys . stdin . readline ( ) . split ( ) ) <NEWLINE> def triangle_area ( x0 , y0 , x1 , y1 , x2 , y2 ) : <NEWLINE> <INDENT> x1 -= x0 ; x2 -= x0 ; y1 -= y0 ; y2 -= y0 ; <NEWLINE> return abs ( x1 * y2 - x2 * y1 ) / 2 <NEWLINE> <DEDENT> print ( triangle_area ( * coords ) ) <NEWLINE> <NL> <DEDENT> def D ( ) : <NEWLINE> <INDENT> n , m = map ( int , sys . stdin . readline ( ) . split ( ) ) <NEWLINE> edges = set ( ) <NEWLINE> for _ in range ( m ) : <NEWLINE> <INDENT> x , y = map ( int , sys . stdin . readline ( ) . split ( ) ) <NEWLINE> x -= 1 ; y -= 1 <NEWLINE> edges . add ( ( x , y ) ) <NEWLINE> <DEDENT> cand = [ ] <NEWLINE> for i in range ( 1 , 1 << n ) : <NEWLINE> <INDENT> s = [ j for j in range ( n ) if i >> j & 1 ] <NEWLINE> for x , y in combinations ( s , 2 ) : <NEWLINE> <INDENT> if ( x , y ) not in edges : break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cand . append ( len ( s ) ) <NEWLINE> <DEDENT> <DEDENT> print ( max ( cand ) ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> class ABC003 ( ) : <NEWLINE> <INDENT> def A ( ) : <NEWLINE> <INDENT> n = int ( sys . stdin . readline ( ) . rstrip ( ) ) <NEWLINE> print ( ( n + 1 ) * 5000 ) <NEWLINE> <NL> <DEDENT> def B ( ) : <NEWLINE> <INDENT> atcoder = set ( <STRING> ) <NEWLINE> s , t = sys . stdin . read ( ) . split ( ) <NEWLINE> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> if s [ i ] == t [ i ] : continue <NEWLINE> if s [ i ] == <STRING> and t [ i ] in atcoder : continue <NEWLINE> if t [ i ] == <STRING> and s [ i ] in atcoder : continue <NEWLINE> print ( <STRING> ) <NEWLINE> return <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> def C ( ) : <NEWLINE> <INDENT> n , k , * r = map ( int , sys . stdin . read ( ) . split ( ) ) <NEWLINE> res = 0 <NEWLINE> for x in sorted ( r ) [ - k : ] : <NEWLINE> <INDENT> res = ( res + x ) / 2 <NEWLINE> <DEDENT> print ( res ) <NEWLINE> <NL> <DEDENT> def D ( ) : pass <NEWLINE> <NL> <NL> <DEDENT> class ABC004 ( ) : <NEWLINE> <INDENT> def A ( ) : <NEWLINE> <INDENT> print ( int ( sys . stdin . readline ( ) . rstrip ( ) ) * 2 ) <NEWLINE> <NL> <DEDENT> def B ( ) : <NEWLINE> <INDENT> c = [ sys . stdin . readline ( ) . rstrip ( ) for _ in range ( 4 ) ] <NEWLINE> for l in c [ : : - 1 ] : <NEWLINE> <INDENT> print ( l [ : : - 1 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> def C ( ) : <NEWLINE> <INDENT> n = int ( sys . stdin . readline ( ) . rstrip ( ) ) <NEWLINE> n %= 30 <NEWLINE> res = list ( range ( 1 , 7 ) ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> i %= 5 <NEWLINE> res [ i ] , res [ i + 1 ] = res [ i + 1 ] , res [ i ] <NEWLINE> <DEDENT> print ( <STRING> . join ( map ( str , res ) ) ) <NEWLINE> <NL> <DEDENT> def D ( ) : pass <NEWLINE> <NL> <NL> <DEDENT> class ABC005 ( ) : <NEWLINE> <INDENT> def A ( ) : <NEWLINE> <INDENT> x , y = map ( int , sys . stdin . readline ( ) . split ( ) ) <NEWLINE> print ( y // x ) <NEWLINE> <NL> <DEDENT> def B ( ) : <NEWLINE> <INDENT> n , * t = map ( int , sys . stdin . read ( ) . split ( ) ) <NEWLINE> print ( min ( t ) ) <NEWLINE> <NL> <DEDENT> def C ( ) : <NEWLINE> <INDENT> t = int ( sys . stdin . readline ( ) . rstrip ( ) ) <NEWLINE> n = int ( sys . stdin . readline ( ) . rstrip ( ) ) <NEWLINE> a = [ int ( x ) for x in sys . stdin . readline ( ) . split ( ) ] <NEWLINE> m = int ( sys . stdin . readline ( ) . rstrip ( ) ) <NEWLINE> b = [ int ( x ) for x in sys . stdin . readline ( ) . split ( ) ] <NEWLINE> i = 0 <NEWLINE> for p in b : <NEWLINE> <INDENT> if i == n : print ( <STRING> ) ; return <NEWLINE> while p - a [ i ] > t : <NEWLINE> <INDENT> i += 1 <NEWLINE> if i == n : print ( <STRING> ) ; return <NEWLINE> <DEDENT> if a [ i ] > p : print ( <STRING> ) ; return <NEWLINE> i += 1 <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> def D ( ) : <NEWLINE> <INDENT> n = int ( sys . stdin . readline ( ) . rstrip ( ) ) <NEWLINE> d = np . array ( [ sys . stdin . readline ( ) . split ( ) for _ in range ( n ) ] , np . int64 ) <NEWLINE> s = d . cumsum ( axis = 0 ) . cumsum ( axis = 1 ) <NEWLINE> s = np . pad ( s , 1 ) <NEWLINE> max_del = np . zeros ( ( n + 1 , n + 1 ) , dtype = np . int64 ) <NEWLINE> for y in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> for x in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> max_del [ y , x ] = np . amax ( s [ y : n + 1 , x : n + 1 ] - s [ 0 : n - y + 1 , x : n + 1 ] - s [ y : n + 1 , 0 : n - x + 1 ] + s [ 0 : n - y + 1 , 0 : n - x + 1 ] ) <NEWLINE> <DEDENT> <DEDENT> res = np . arange ( n ** 2 + 1 ) [ : , None ] <NEWLINE> i = np . arange ( 1 , n + 1 ) <NEWLINE> res = max_del [ i , np . minimum ( res // i , n ) ] . max ( axis = 1 ) <NEWLINE> q = int ( sys . stdin . readline ( ) . rstrip ( ) ) <NEWLINE> p = np . array ( sys . stdin . read ( ) . split ( ) , dtype = np . int64 ) <NEWLINE> print ( * res [ p ] , sep = <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> class ABC006 ( ) : <NEWLINE> <INDENT> def A ( ) : <NEWLINE> <INDENT> n = sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> if <STRING> in n : print ( <STRING> ) <NEWLINE> elif int ( n ) % 3 == 0 : print ( <STRING> ) <NEWLINE> else : print ( <STRING> ) <NEWLINE> <NL> <DEDENT> def B ( ) : <NEWLINE> <INDENT> mod = 10007 <NEWLINE> t = [ 0 , 0 , 1 ] <NEWLINE> for _ in range ( 1001001 ) : <NEWLINE> <INDENT> t . append ( t [ - 1 ] + t [ - 2 ] + t [ - 3 ] ) ; t [ - 1 ] %= mod <NEWLINE> <DEDENT> n = int ( sys . stdin . readline ( ) . rstrip ( ) ) <NEWLINE> print ( t [ n - 1 ] ) <NEWLINE> <NL> <DEDENT> def C ( ) : <NEWLINE> <INDENT> n , m = map ( int , sys . stdin . readline ( ) . split ( ) ) <NEWLINE> cnt = [ 0 , 0 , 0 ] <NEWLINE> if m == 1 : cnt = [ - 1 , - 1 , - 1 ] <NEWLINE> else : <NEWLINE> <INDENT> if m & 1 : m -= 3 ; cnt [ 1 ] += 1 ; n -= 1 <NEWLINE> cnt [ 2 ] = m // 2 - n <NEWLINE> cnt [ 0 ] = n - cnt [ 2 ] <NEWLINE> <DEDENT> if cnt [ 0 ] < 0 or cnt [ 1 ] < 0 or cnt [ 2 ] < 0 : print ( - 1 , - 1 , - 1 ) <NEWLINE> else : print ( * cnt , sep = <STRING> ) <NEWLINE> <NL> <DEDENT> def D ( ) : <NEWLINE> <INDENT> n , * c = map ( int , sys . stdin . read ( ) . split ( ) ) <NEWLINE> lis = [ inf ] * n <NEWLINE> for x in c : lis [ bi_l ( lis , x ) ] = x <NEWLINE> print ( n - bi_l ( lis , inf ) ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> class ABC007 ( ) : <NEWLINE> <INDENT> def A ( ) : <NEWLINE> <INDENT> n = int ( sys . stdin . readline ( ) . rstrip ( ) ) <NEWLINE> print ( n - 1 ) <NEWLINE> <NL> <DEDENT> def B ( ) : <NEWLINE> <INDENT> s = sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> if s == <STRING> : print ( - 1 ) <NEWLINE> else : print ( <STRING> ) <NEWLINE> <NL> <DEDENT> def C ( ) : <NEWLINE> <INDENT> r , c = map ( int , sys . stdin . readline ( ) . split ( ) ) <NEWLINE> sy , sx = map ( int , sys . stdin . readline ( ) . split ( ) ) <NEWLINE> gy , gx = map ( int , sys . stdin . readline ( ) . split ( ) ) <NEWLINE> sy -= 1 ; sx -= 1 ; gy -= 1 ; gx -= 1 <NEWLINE> maze = [ sys . stdin . readline ( ) . rstrip ( ) for _ in range ( r ) ] <NEWLINE> queue = deque ( [ ( sy , sx ) ] ) <NEWLINE> dist = np . full ( ( r , c ) , np . inf ) ; dist [ sy , sx ] = 0 <NEWLINE> while queue : <NEWLINE> <INDENT> y , x = queue . popleft ( ) <NEWLINE> for i , j in [ ( - 1 , 0 ) , ( 1 , 0 ) , ( 0 , - 1 ) , ( 0 , 1 ) ] : <NEWLINE> <INDENT> i += y ; j += x <NEWLINE> if maze [ i ] [ j ] == <STRING> or dist [ i , j ] != np . inf : continue <NEWLINE> dist [ i , j ] = dist [ y , x ] + 1 <NEWLINE> queue . append ( ( i , j ) ) <NEWLINE> <DEDENT> <DEDENT> print ( int ( dist [ gy , gx ] ) ) <NEWLINE> <NL> <DEDENT> def D ( ) : pass <NEWLINE> <NL> <NL> <DEDENT> class ABC008 ( ) : <NEWLINE> <INDENT> def A ( ) : <NEWLINE> <INDENT> s , t = map ( int , sys . stdin . readline ( ) . split ( ) ) <NEWLINE> print ( t - s + 1 ) <NEWLINE> <NL> <DEDENT> def B ( ) : <NEWLINE> <INDENT> n , * s = sys . stdin . read ( ) . split ( ) <NEWLINE> res = defaultdict ( int ) <NEWLINE> for name in s : res [ name ] += 1 <NEWLINE> print ( sorted ( res . items ( ) , key = lambda x : x [ 1 ] ) [ - 1 ] [ 0 ] ) <NEWLINE> <NL> <DEDENT> def C ( ) : <NEWLINE> <INDENT> n , * a = map ( int , sys . stdin . read ( ) . split ( ) ) <NEWLINE> a = np . array ( a ) <NEWLINE> c = n - np . count_nonzero ( a [ : , None ] % a , axis = 1 ) <NEWLINE> print ( np . sum ( ( c + 1 ) // 2 / c ) ) <NEWLINE> <NL> <DEDENT> def D ( ) : pass <NEWLINE> <NL> <DEDENT> class ABC009 ( ) : <NEWLINE> <INDENT> def A ( ) : <NEWLINE> <INDENT> n = int ( sys . stdin . readline ( ) . rstrip ( ) ) <NEWLINE> print ( ( n + 1 ) // 2 ) <NEWLINE> <NL> <DEDENT> def B ( ) : <NEWLINE> <INDENT> n , * a = map ( int , sys . stdin . read ( ) . split ( ) ) <NEWLINE> print ( sorted ( set ( a ) ) [ - 2 ] ) <NEWLINE> <NL> <DEDENT> def C ( ) : <NEWLINE> <INDENT> n , k = map ( int , sys . stdin . readline ( ) . split ( ) ) <NEWLINE> s = list ( sys . stdin . readline ( ) . rstrip ( ) ) <NEWLINE> cost = [ 1 ] * n <NEWLINE> r = k <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> q = [ ] <NEWLINE> for j in range ( i + 1 , n ) : <NEWLINE> <INDENT> if s [ j ] < s [ i ] and cost [ i ] + cost [ j ] <= r : <NEWLINE> <INDENT> heappush ( q , ( s [ j ] , cost [ i ] + cost [ j ] , - j ) ) <NEWLINE> <DEDENT> <DEDENT> if not q : continue <NEWLINE> _ , c , j = heappop ( q ) ; j = - j <NEWLINE> s [ i ] , s [ j ] = s [ j ] , s [ i ] <NEWLINE> r -= c <NEWLINE> cost [ i ] = cost [ j ] = 0 <NEWLINE> <DEDENT> print ( <STRING> . join ( s ) ) <NEWLINE> <NL> <DEDENT> def D ( ) : pass <NEWLINE> <NL> <NL> <DEDENT> class ABC010 ( ) : <NEWLINE> <INDENT> def A ( ) : <NEWLINE> <INDENT> print ( sys . stdin . readline ( ) . rstrip ( ) + <STRING> ) <NEWLINE> <DEDENT> def B ( ) : <NEWLINE> <INDENT> n , * a = map ( int , sys . stdin . read ( ) . split ( ) ) <NEWLINE> tot = 0 <NEWLINE> for x in a : <NEWLINE> <INDENT> c = 0 <NEWLINE> while x % 2 == 0 or x % 3 == 2 : <NEWLINE> <INDENT> x -= 1 <NEWLINE> c += 1 <NEWLINE> <DEDENT> tot += c <NEWLINE> <DEDENT> print ( tot ) <NEWLINE> <NL> <DEDENT> def C ( ) : <NEWLINE> <INDENT> sx , sy , gx , gy , t , v , n , * xy = map ( int , sys . stdin . read ( ) . split ( ) ) <NEWLINE> x , y = np . array ( xy ) . reshape ( - 1 , 2 ) . T <NEWLINE> def dist ( x1 , y1 , x2 , y2 ) : <NEWLINE> <INDENT> return np . sqrt ( ( x2 - x1 ) ** 2 + ( y2 - y1 ) ** 2 ) <NEWLINE> <DEDENT> ans = <STRING> if ( dist ( sx , sy , x , y ) + dist ( x , y , gx , gy ) <= v * t ) . any ( ) else <STRING> <NEWLINE> print ( ans ) <NEWLINE> <NL> <DEDENT> def D ( ) : pass <NEWLINE> <NL> <DEDENT> class ABC011 ( ) : <NEWLINE> <INDENT> def A ( ) : <NEWLINE> <INDENT> n = int ( sys . stdin . readline ( ) . rstrip ( ) ) <NEWLINE> print ( n % 12 + 1 ) <NEWLINE> <NL> <DEDENT> def B ( ) : <NEWLINE> <INDENT> s = sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> print ( s [ 0 ] . upper ( ) + s [ 1 : ] . lower ( ) ) <NEWLINE> <NL> <DEDENT> def C ( ) : <NEWLINE> <INDENT> n , * ng = map ( int , sys . stdin . read ( ) . split ( ) ) <NEWLINE> ng = set ( ng ) <NEWLINE> if n in ng : print ( <STRING> ) <NEWLINE> else : <NEWLINE> <INDENT> r = 100 <NEWLINE> while n > 0 : <NEWLINE> <INDENT> if r == 0 : print ( <STRING> ) ; return <NEWLINE> for i in range ( 3 , 0 , - 1 ) : <NEWLINE> <INDENT> if ( n - i ) in ng : continue <NEWLINE> n -= i <NEWLINE> r -= 1 <NEWLINE> break <NEWLINE> <DEDENT> else : print ( <STRING> ) ; return <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> def D ( ) : pass <NEWLINE> <NL> <NL> <DEDENT> class ABC041 ( ) : <NEWLINE> <INDENT> def A ( ) : <NEWLINE> <INDENT> s , i = sys . stdin . read ( ) . split ( ) <NEWLINE> i = int ( i ) <NEWLINE> print ( s [ i - 1 ] ) <NEWLINE> <NL> <DEDENT> def B ( ) : <NEWLINE> <INDENT> a , b , c = map ( int , sys . stdin . readline ( ) . split ( ) ) <NEWLINE> ans = a * b % MOD * c % MOD <NEWLINE> print ( ans ) <NEWLINE> <NL> <DEDENT> def C ( ) : <NEWLINE> <INDENT> n , * a = map ( int , sys . stdin . read ( ) . split ( ) ) <NEWLINE> for i , h in sorted ( enumerate ( a ) , key = lambda x : - x [ 1 ] ) : <NEWLINE> <INDENT> print ( i + 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> def D ( ) : <NEWLINE> <INDENT> n , m , * xy = map ( int , sys . stdin . read ( ) . split ( ) ) <NEWLINE> * xy , = zip ( * [ iter ( xy ) ] * 2 ) <NEWLINE> edges = [ 0 ] * n <NEWLINE> for x , y in xy : <NEWLINE> <INDENT> x -= 1 ; y -= 1 <NEWLINE> edges [ x ] |= 1 << y <NEWLINE> <DEDENT> comb = [ None ] * ( 1 << n ) ; comb [ 0 ] = 1 <NEWLINE> def count ( edges , bit ) : <NEWLINE> <INDENT> if comb [ bit ] is not None : return comb [ bit ] <NEWLINE> comb [ bit ] = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if ( bit >> i ) & 1 and not edges [ i ] : <NEWLINE> <INDENT> nxt_bit = bit & ~ ( 1 << i ) <NEWLINE> nxt_edges = edges . copy ( ) <NEWLINE> for j in range ( n ) : <NEWLINE> <INDENT> nxt_edges [ j ] &= ~ ( 1 << i ) <NEWLINE> <DEDENT> cnt = count ( nxt_edges , nxt_bit ) <NEWLINE> comb [ bit ] += cnt <NEWLINE> <DEDENT> <DEDENT> return comb [ bit ] <NEWLINE> <DEDENT> print ( count ( edges , ( 1 << n ) - 1 ) ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> class ABC042 ( ) : <NEWLINE> <INDENT> def A ( ) : <NEWLINE> <INDENT> a = [ int ( x ) for x in sys . stdin . readline ( ) . split ( ) ] <NEWLINE> c = Counter ( a ) <NEWLINE> print ( <STRING> if c [ 5 ] == 2 and c [ 7 ] == 1 else <STRING> ) <NEWLINE> <NL> <DEDENT> def B ( ) : <NEWLINE> <INDENT> n , l , * s = sys . stdin . read ( ) . split ( ) <NEWLINE> print ( <STRING> . join ( sorted ( s ) ) ) <NEWLINE> <NL> <DEDENT> def C ( ) : <NEWLINE> <INDENT> n , k , * d = sys . stdin . read ( ) . split ( ) <NEWLINE> l = len ( n ) <NEWLINE> ok = sorted ( set ( string . digits ) - set ( d ) ) <NEWLINE> cand = [ int ( <STRING> . join ( p ) ) for p in product ( ok , repeat = l ) ] + [ int ( min ( ok - set ( [ 0 ] ) ) + min ( ok ) * l ) ] <NEWLINE> print ( cand [ bi_l ( cand , int ( n ) ) ] ) <NEWLINE> <NL> <DEDENT> def D ( ) : pass <NEWLINE> <NL> <NL> <DEDENT> class ABC170 ( ) : <NEWLINE> <INDENT> def A ( ) : <NEWLINE> <INDENT> x = [ int ( x ) for x in sys . stdin . readline ( ) . split ( ) ] <NEWLINE> for i in range ( 5 ) : <NEWLINE> <INDENT> if x [ i ] != i + 1 : <NEWLINE> <INDENT> print ( i + 1 ) <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> def B ( ) : <NEWLINE> <INDENT> x , y = map ( int , sys . stdin . readline ( ) . split ( ) ) <NEWLINE> print ( <STRING> if 2 * x <= y <= 4 * x and y % 2 == 0 else <STRING> ) <NEWLINE> <NL> <DEDENT> def C ( ) : <NEWLINE> <INDENT> x , n , * p = map ( int , sys . stdin . read ( ) . split ( ) ) <NEWLINE> a = list ( set ( range ( 102 ) ) - set ( p ) ) <NEWLINE> a = [ ( abs ( y - x ) , y ) for y in a ] <NEWLINE> print ( sorted ( a ) [ 0 ] [ 1 ] ) <NEWLINE> <NL> <DEDENT> def D ( ) : <NEWLINE> <INDENT> n , * a = map ( int , sys . stdin . read ( ) . split ( ) ) <NEWLINE> cand = set ( a ) <NEWLINE> cnt = 0 <NEWLINE> for x , c in sorted ( Counter ( a ) . items ( ) ) : <NEWLINE> <INDENT> cnt += c == 1 and x in cand <NEWLINE> cand -= set ( range ( x * 2 , 10 ** 6 + 1 , x ) ) <NEWLINE> <DEDENT> print ( cnt ) <NEWLINE> <NL> <DEDENT> def E ( ) : <NEWLINE> <INDENT> n , q = map ( int , sys . stdin . readline ( ) . split ( ) ) <NEWLINE> queue = [ ] <NEWLINE> num_kindergarten = 2 * 10 ** 5 <NEWLINE> queue_kindergarten = [ [ ] for _ in range ( num_kindergarten ) ] <NEWLINE> highest_kindergarten = [ None ] * num_kindergarten <NEWLINE> where = [ None ] * n <NEWLINE> rate = [ None ] * n <NEWLINE> <NL> def entry ( i , k ) : <NEWLINE> <INDENT> where [ i ] = k <NEWLINE> while queue_kindergarten [ k ] : <NEWLINE> <INDENT> r , j = heappop ( queue_kindergarten [ k ] ) <NEWLINE> if where [ j ] != k or j == i : continue <NEWLINE> if rate [ i ] >= - r : <NEWLINE> <INDENT> highest_kindergarten [ k ] = rate [ i ] <NEWLINE> heappush ( queue , ( rate [ i ] , k , i ) ) <NEWLINE> <DEDENT> heappush ( queue_kindergarten [ k ] , ( r , j ) ) <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> highest_kindergarten [ k ] = rate [ i ] <NEWLINE> heappush ( queue , ( rate [ i ] , k , i ) ) <NEWLINE> <DEDENT> heappush ( queue_kindergarten [ k ] , ( - rate [ i ] , i ) ) <NEWLINE> <NL> <DEDENT> def transfer ( i , k ) : <NEWLINE> <INDENT> now = where [ i ] <NEWLINE> while queue_kindergarten [ now ] : <NEWLINE> <INDENT> r , j = heappop ( queue_kindergarten [ now ] ) <NEWLINE> if where [ j ] != now or j == i : continue <NEWLINE> if highest_kindergarten [ now ] != - r : <NEWLINE> <INDENT> highest_kindergarten [ now ] = - r <NEWLINE> heappush ( queue , ( - r , now , j ) ) <NEWLINE> <DEDENT> heappush ( queue_kindergarten [ now ] , ( r , j ) ) <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> highest_kindergarten [ now ] = None <NEWLINE> <DEDENT> entry ( i , k ) <NEWLINE> <NL> <DEDENT> def inquire ( ) : <NEWLINE> <INDENT> while True : <NEWLINE> <INDENT> r , k , i = heappop ( queue ) <NEWLINE> if where [ i ] != k or r != highest_kindergarten [ k ] : continue <NEWLINE> heappush ( queue , ( r , k , i ) ) <NEWLINE> return r <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> a , b = map ( int , sys . stdin . readline ( ) . split ( ) ) <NEWLINE> rate [ i ] = a <NEWLINE> entry ( i , b - 1 ) <NEWLINE> <DEDENT> for _ in range ( q ) : <NEWLINE> <INDENT> c , d = map ( int , sys . stdin . readline ( ) . split ( ) ) <NEWLINE> transfer ( c - 1 , d - 1 ) <NEWLINE> print ( inquire ( ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> def F ( ) : pass <NEWLINE> <NL> <NL> <DEDENT> class ABC171 ( ) : <NEWLINE> <INDENT> def A ( ) : <NEWLINE> <INDENT> c = sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> print ( <STRING> if c < <STRING> else <STRING> ) <NEWLINE> <NL> <DEDENT> def B ( ) : <NEWLINE> <INDENT> n , k , * p = map ( int , sys . stdin . read ( ) . split ( ) ) <NEWLINE> print ( sum ( sorted ( p ) [ : k ] ) ) <NEWLINE> <NL> <DEDENT> def C ( ) : <NEWLINE> <INDENT> n = int ( sys . stdin . readline ( ) . rstrip ( ) ) <NEWLINE> n -= 1 <NEWLINE> l = 1 <NEWLINE> while True : <NEWLINE> <INDENT> if n < pow ( 26 , l ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> n -= pow ( 26 , l ) <NEWLINE> l += 1 <NEWLINE> <DEDENT> res = <STRING> . join ( [ chr ( ord ( <STRING> ) + d % 26 ) for d in NumberTheory . base_convert ( n , 26 ) ] [ : : - 1 ] ) <NEWLINE> res = <STRING> * ( l - len ( res ) ) + res <NEWLINE> print ( res ) <NEWLINE> <NL> <DEDENT> def D ( ) : <NEWLINE> <INDENT> n = int ( sys . stdin . readline ( ) . rstrip ( ) ) <NEWLINE> a = [ int ( x ) for x in sys . stdin . readline ( ) . split ( ) ] <NEWLINE> s = sum ( a ) <NEWLINE> cnt = Counter ( a ) <NEWLINE> q = int ( sys . stdin . readline ( ) . rstrip ( ) ) <NEWLINE> for _ in range ( q ) : <NEWLINE> <INDENT> b , c = map ( int , sys . stdin . readline ( ) . split ( ) ) <NEWLINE> s += ( c - b ) * cnt [ b ] <NEWLINE> print ( s ) <NEWLINE> cnt [ c ] += cnt [ b ] ; cnt [ b ] = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> def E ( ) : <NEWLINE> <INDENT> n , * a = map ( int , sys . stdin . read ( ) . split ( ) ) <NEWLINE> s = 0 <NEWLINE> for x in a : s ^= x <NEWLINE> b = map ( lambda x : x ^ s , a ) <NEWLINE> print ( * b , sep = <STRING> ) <NEWLINE> <NL> <DEDENT> def F ( ) : pass <NEWLINE> <NL> <NL> <DEDENT> class ABC172 ( ) : <NEWLINE> <INDENT> def A ( ) : pass <NEWLINE> def B ( ) : pass <NEWLINE> def C ( ) : pass <NEWLINE> def D ( ) : pass <NEWLINE> def E ( ) : pass <NEWLINE> def F ( ) : pass <NEWLINE> <NL> <NL> <DEDENT> class ABC173 ( ) : <NEWLINE> <INDENT> def A ( ) : <NEWLINE> <INDENT> n = int ( sys . stdin . readline ( ) . rstrip ( ) ) <NEWLINE> charge = ( n + 999 ) // 1000 * 1000 - n <NEWLINE> print ( charge ) <NEWLINE> <NL> <DEDENT> def B ( ) : <NEWLINE> <INDENT> n , * s = sys . stdin . read ( ) . split ( ) <NEWLINE> c = Counter ( s ) <NEWLINE> for v in <STRING> . split ( <STRING> ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> def C ( ) : <NEWLINE> <INDENT> h , w , k = map ( int , sys . stdin . readline ( ) . split ( ) ) <NEWLINE> c = [ sys . stdin . readline ( ) . rstrip ( ) for _ in range ( h ) ] <NEWLINE> tot = 0 <NEWLINE> for i in range ( 1 << h ) : <NEWLINE> <INDENT> for j in range ( 1 << w ) : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> for y in range ( h ) : <NEWLINE> <INDENT> for x in range ( w ) : <NEWLINE> <INDENT> if i >> y & 1 or j >> x & 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> cnt += c [ y ] [ x ] == <STRING> <NEWLINE> <DEDENT> <DEDENT> tot += cnt == k <NEWLINE> <DEDENT> <DEDENT> print ( tot ) <NEWLINE> <NL> <DEDENT> def D ( ) : <NEWLINE> <INDENT> n , * a = map ( int , sys . stdin . read ( ) . split ( ) ) <NEWLINE> a . sort ( reverse = True ) <NEWLINE> res = a [ 0 ] + sum ( a [ 1 : 1 + ( n - 2 ) // 2 ] ) * 2 + a [ 1 + ( n - 2 ) // 2 ] * ( n & 1 ) <NEWLINE> print ( res ) <NEWLINE> <NL> <DEDENT> def E ( ) : <NEWLINE> <INDENT> MOD = 10 ** 9 + 7 <NEWLINE> n , k , * a = map ( int , sys . stdin . read ( ) . split ( ) ) <NEWLINE> minus = [ x for x in a if x < 0 ] <NEWLINE> plus = [ x for x in a if x > 0 ] <NEWLINE> if len ( plus ) + len ( minus ) // 2 * 2 >= k : <COMMENT> <NEWLINE> <INDENT> * minus , = map ( abs , minus ) <NEWLINE> minus . sort ( reverse = True ) <NEWLINE> plus . sort ( reverse = True ) <NEWLINE> cand = [ ] <NEWLINE> if len ( minus ) & 1 : minus = minus [ : - 1 ] <NEWLINE> for i in range ( 0 , len ( minus ) - 1 , 2 ) : <NEWLINE> <INDENT> cand . append ( minus [ i ] * minus [ i + 1 ] % MOD ) <NEWLINE> <DEDENT> if k & 1 : <NEWLINE> <INDENT> res = plus [ 0 ] <NEWLINE> plus = plus [ 1 : ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> res = 1 <NEWLINE> <DEDENT> if len ( plus ) & 1 : plus = plus [ : - 1 ] <NEWLINE> for i in range ( 0 , len ( plus ) - 1 , 2 ) : <NEWLINE> <INDENT> cand . append ( plus [ i ] * plus [ i + 1 ] % MOD ) <NEWLINE> <DEDENT> cand . sort ( reverse = True ) <NEWLINE> for x in cand [ : k // 2 ] : <NEWLINE> <INDENT> res *= x <NEWLINE> res %= MOD <NEWLINE> <DEDENT> print ( res ) <NEWLINE> <DEDENT> elif 0 in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cand = sorted ( map ( abs , a ) ) <NEWLINE> res = 1 <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> res *= cand [ i ] <NEWLINE> res %= MOD <NEWLINE> <DEDENT> res = MOD - res <NEWLINE> print ( res ) <NEWLINE> pass <NEWLINE> <NL> <DEDENT> <DEDENT> def F ( ) : pass <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> ABC042 . C ( ) <NEWLINE> <DEDENT>
N , K = input ( ) . split ( ) <NEWLINE> Dk = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in range ( N , 10 * N + 1 ) : <NEWLINE> <INDENT> if set ( i ) & set ( Dk ) == set ( ) : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> N = str ( N ) <NEWLINE> N_len = len ( N ) <NEWLINE> a = [ ] <NEWLINE> out = N <NEWLINE> for i in range ( K ) : <NEWLINE> <INDENT> a . append ( input ( ) ) <NEWLINE> <DEDENT> for i2 in range ( N_len ) : <NEWLINE> <INDENT> for i3 in range ( K ) : <NEWLINE> <INDENT> if N [ i2 ] == a [ i3 ] : <NEWLINE> <INDENT> out += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( out ) <NEWLINE> <NL>
n , k = input ( ) . split ( ) <NEWLINE> d = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> num = [ i for i in range ( 10 ) ] <NEWLINE> poss = list ( set ( d ) ^ set ( num ) ) <NEWLINE> an = int ( n ) <NEWLINE> while True : <NEWLINE> <INDENT> sum = 0 <NEWLINE> for p in poss : <NEWLINE> <INDENT> sum += n . count ( str ( p ) ) <NEWLINE> <DEDENT> if sum == len ( n ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> an += 1 <NEWLINE> <DEDENT> <DEDENT> print ( an ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> d = set ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> i = n <NEWLINE> while True : <NEWLINE> <INDENT> if not set ( ( str ( i ) ) ) & d : i += 1 <NEWLINE> else : <NEWLINE> <INDENT> print ( i ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT>
def check ( n , s ) : <NEWLINE> <INDENT> v = str ( n ) <NEWLINE> for i in v : <NEWLINE> <INDENT> if i in s : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> <DEDENT> return True <NEWLINE> <DEDENT> def solve ( ) : <NEWLINE> <INDENT> n , k = mp ( ) <NEWLINE> s = input ( ) . split ( ) <NEWLINE> s = set ( s ) <NEWLINE> <NL> while True : <NEWLINE> <INDENT> if check ( n , s ) : <NEWLINE> <INDENT> print ( n ) <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> n += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> for _ in range ( 1 ) : <NEWLINE> <INDENT> solve ( ) <NEWLINE> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> l = [ 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 , 0 ] <NEWLINE> for _ in range ( K ) : <NEWLINE> <INDENT> l . remove ( int ( input ( ) ) ) <NEWLINE> <DEDENT> n = [ int ( x ) for x in str ( N ) ] <NEWLINE> c = len ( n ) <NEWLINE> <NL> max = l [ 0 ] <NEWLINE> min = l [ - 1 ] <NEWLINE> if N > 1111 * max : <NEWLINE> <INDENT> b = 10000 * min ( [ i for i in l if i > 0 ] ) + 1111 * min <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a = [ max ] * c <NEWLINE> for j in range ( c ) : <NEWLINE> <INDENT> if a [ j ] > n [ j ] : <NEWLINE> <INDENT> a [ j ] = min ( [ i for i in l if i >= n [ j ] ] ) <NEWLINE> <DEDENT> <DEDENT> b = <STRING> <NEWLINE> for j in range ( c ) : <NEWLINE> <INDENT> b += str ( a [ j ] ) <NEWLINE> <DEDENT> b = int ( b ) <NEWLINE> <NL> <DEDENT> print ( b ) <NEWLINE>
def digit ( ) : <NEWLINE> <INDENT> N , K = [ int ( n ) for n in input ( ) . split ( ) ] <NEWLINE> digit = [ int ( n ) for n in input ( ) . split ( ) ] <NEWLINE> <NL> for i in range ( N , N * 10 ) : <NEWLINE> <INDENT> b = i <NEWLINE> while b != 0 : <NEWLINE> <INDENT> if ( b % 10 ) in digit : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> b /= 10 <NEWLINE> <DEDENT> if b == 0 : <NEWLINE> <INDENT> print ( i ) <NEWLINE> break : <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> digit ( ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> fac = [ 0 ] * 200001 <COMMENT> <NEWLINE> inv = [ 0 ] * 200001 <COMMENT> <NEWLINE> fac [ 0 ] = 1 <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , 200001 ) : <NEWLINE> <INDENT> fac [ i ] = fac [ i - 1 ] * i % 1000000007 <NEWLINE> <DEDENT> inv [ 200000 ] = pow ( fac [ 200000 ] , 1000000005 , 1000000007 ) <NEWLINE> for i in range ( 199999 , 0 , - 1 ) : <NEWLINE> <INDENT> inv [ i ] = ( inv [ i + 1 ] * ( i + 1 ) ) % 1000000007 <NEWLINE> inv [ 0 ] = 1 <NEWLINE> <DEDENT> for i in range ( h - a ) : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> if h == 1 : <NEWLINE> <INDENT> x = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = ( fac [ w - b + h - 2 <NEWLINE> <INDENT> - i ] * inv [ w - 1 - b ] * inv [ h - 1 - i ] ) % 1000000007 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> elif w == b + 1 : <NEWLINE> <INDENT> x = ( fac [ b - 1 + i ] * inv [ b - 1 ] * inv [ i ] ) % 1000000007 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = ( ( fac [ b - 1 + i ] * inv [ b - 1 ] * inv [ i ] ) % 1000000007 ) * ( ( fac [ w - b + h - 2 - i ] * inv [ w - b - 1 ] * inv [ h - 1 - i ] ) % 1000000007 ) <NEWLINE> <DEDENT> ans = ( ans + x ) % 1000000007 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
h , w , a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> p = 10 ** 9 + 7 <NEWLINE> <COMMENT> <NL> <NL> def modp_factorial ( n ) : <NEWLINE> <INDENT> s = 1 <NEWLINE> for x in range ( 1 , h + 1 ) : <NEWLINE> <INDENT> s = ( s * x ) % p <NEWLINE> <DEDENT> return s <NEWLINE> <DEDENT> def modp_prod ( lst ) : <NEWLINE> <INDENT> s = 1 <NEWLINE> for x in lst : <NEWLINE> <INDENT> s = ( s * x ) % p <NEWLINE> <DEDENT> return s <NEWLINE> <DEDENT> def inv ( n ) : <NEWLINE> <INDENT> s = 1 <NEWLINE> q = p - 2 <NEWLINE> while q > 0 : <NEWLINE> <INDENT> if q & 1 : <NEWLINE> <INDENT> s = s * n % p <NEWLINE> <DEDENT> n = n * n <NEWLINE> q >>= 1 <NEWLINE> <DEDENT> return s <NEWLINE> <NL> <DEDENT> l = [ 1 ] <NEWLINE> f = 1 <NEWLINE> for x in range ( 1 , h + w + 1 ) : <NEWLINE> <INDENT> f = f * x % p <NEWLINE> l . append ( f ) <NEWLINE> <DEDENT> invl = [ inv ( l [ - 1 ] ) ] <NEWLINE> for n in range ( h + w , 1 , - 1 ) : <NEWLINE> <INDENT> invl . append ( ( invl [ - 1 ] * n ) % p ) <NEWLINE> <DEDENT> invl . append ( 1 ) <NEWLINE> invl . reverse ( ) <NEWLINE> <NL> <NL> s = 0 <NEWLINE> for x in range ( 1 , h - a + 1 ) : <NEWLINE> <INDENT> s = s + modp_prod ( [ l [ x + b - 2 ] , invl [ x - 1 ] , invl [ b - 1 ] , l [ w - b + h - x - 1 ] , invl [ h - x ] , invl [ w - b - 1 ] ] ) % p <NEWLINE> <DEDENT> print ( s ) <NEWLINE>
P = 10 ** 9 + 7 <NEWLINE> fac = [ 1 ] <NEWLINE> ifac = [ 1 ] <NEWLINE> ff = 1 <NEWLINE> for i in range ( 1 , 200001 ) : <NEWLINE> <INDENT> ff *= i <NEWLINE> ff %= p <NEWLINE> fac . append ( ff ) <NEWLINE> ifac . append ( pow ( ff , p - 2 , p ) ) <NEWLINE> <DEDENT> def ncr ( n , r , p ) : <NEWLINE> <INDENT> return ( fac [ n ] * ifac [ r ] % p * ifac [ n - r ] % p ) ; <NEWLINE> <NL> <DEDENT> h , w , a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> s = 0 <NEWLINE> nC = b - 1 <NEWLINE> kC = 0 <NEWLINE> nD = w - b - 1 + h - 1 <NEWLINE> kD = h - 1 <NEWLINE> for i in range ( h - a ) : <NEWLINE> <INDENT> C = ncr ( nC , kC , P ) <NEWLINE> D = ncr ( nD , kD , P ) <NEWLINE> s = ( s + C * D ) % P <NEWLINE> nC += 1 <NEWLINE> kC += 1 <NEWLINE> kD -= 1 <NEWLINE> nD -= 1 <NEWLINE> <DEDENT> print ( s ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 0 , 2 * n , 2 ) : <NEWLINE> <INDENT> ans += a [ i + 1 ] <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> arr = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> arr = arr . sort ( ) <NEWLINE> s = 0 <NEWLINE> for i in range ( 0 , ( 2 * n ) - 1 , 2 ) : <NEWLINE> <INDENT> s += arr [ i ] <NEWLINE> <DEDENT> print ( s ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> array = input ( ) <NEWLINE> L = [ int ( val ) for val in array . split ( ) ] <NEWLINE> L = sorted ( L ) <NEWLINE> total = 0 <NEWLINE> start = 0 <NEWLINE> P = [ L for val in L ] <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> total += min ( P [ start ] , P [ start + 1 ] ) <NEWLINE> P . pop ( start ) <NEWLINE> P . pop ( start + 1 ) <NEWLINE> start += 2 <NEWLINE> <DEDENT> print ( total ) <NEWLINE>
try : <NEWLINE> <INDENT> k = input ( ) <NEWLINE> <DEDENT> except EOFError : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> try : <NEWLINE> <INDENT> li = input ( ) <NEWLINE> <DEDENT> except EOFError : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> li . sort ( ) <NEWLINE> sum = 0 <NEWLINE> for k in range ( len ( li ) ) : <NEWLINE> <NL> <INDENT> if k % 2 == 0 : <NEWLINE> <NL> <INDENT> sum = sum + li [ k ] <NEWLINE> <DEDENT> <DEDENT> print ( sum ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = sorted ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> s = 0 <NEWLINE> for i in range ( 2 n - 1 ) : <NEWLINE> <INDENT> s += min ( a [ i ] , a [ i + 1 ] ) <NEWLINE> <DEDENT> print ( s ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> L = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> L . sort ( ) <NEWLINE> S = 0 <NEWLINE> for i in range ( 0 , 2 * N + 1 , 2 ) : <NEWLINE> <INDENT> S += L [ i ] <NEWLINE> <DEDENT> print ( S ) <NEWLINE>
<NL> num = int ( input ( ) ) <NEWLINE> li = int ( input ( ) . split ( ) ) <NEWLINE> <NL> print ( num ) <NEWLINE> print ( li ) <NEWLINE>
from collections import Counter <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> <NL> arr = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> counts = Counter ( arr ) <NEWLINE> <NL> res = 0 <NEWLINE> <NL> for k , v in counts . items ( ) : <NEWLINE> <INDENT> if v >= 2 : <NEWLINE> <INDENT> res += v // 2 <NEWLINE> counts [ k ] = v % 2 <NEWLINE> <NL> <DEDENT> <DEDENT> items = sorted ( counts . items ( ) ) <NEWLINE> for i in range ( len ( items ) - 1 ) : <NEWLINE> <INDENT> res += min ( items [ i ] , items [ i + 1 ] ) <NEWLINE> <NL> <DEDENT> print ( res ) <NEWLINE>
N , X = input ( ) . split ( ) <NEWLINE> N , X = int ( N ) , int ( X ) <NEWLINE> answer = X + ( N - X ) <NEWLINE> <NL> <NL> def rhombus ( N , X ) : <NEWLINE> <INDENT> if N < X : <NEWLINE> <INDENT> temp = N <NEWLINE> N = X <NEWLINE> X = temp <NEWLINE> <NL> <DEDENT> if X == 1 : <NEWLINE> <INDENT> return N + 1 <NEWLINE> <DEDENT> if X == 0 : <NEWLINE> <INDENT> return 0 <NEWLINE> <NL> <DEDENT> if N % X == 0 : <NEWLINE> <INDENT> return X * ( N // X ) * 2 - X <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> k = N // X <NEWLINE> return k * 2 * X + rhombus ( X , N - ( k * X ) ) <NEWLINE> <NL> <NL> <NL> <DEDENT> <DEDENT> answer = answer + rhombus ( N - X , X ) <NEWLINE> print ( answer ) <NEWLINE>
import math <NEWLINE> n , x = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( 3 * ( n - gcd ( n , x ) ) ) <NEWLINE>
