k = int ( input ( ) ) <NEWLINE> s = str ( input ( ) ) <NEWLINE> <NL> if len ( s ) <= k : <NEWLINE> <INDENT> print ( s ) <NEWLINE> else : <NEWLINE> <INDENT> print ( s [ 0 : k ] + <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
K = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> <NL> if len ( S ) > K : <NEWLINE> <INDENT> S = S [ : K ] + <STRING> <NEWLINE> <NL> <DEDENT> print ( a ) <NEWLINE>
<COMMENT> <NL> K = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> if len ( str ( S ) ) = < K : <NEWLINE> <INDENT> print ( S ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( S [ : K ] + <STRING> ) <NEWLINE> <DEDENT>
S = input ( ) <NEWLINE> k = int ( input ( ) ) <NEWLINE> if len ( S ) > k : <NEWLINE> <INDENT> S = S [ : k ] + <STRING> <NEWLINE> <DEDENT> print ( S ) <NEWLINE>
K = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> if len ( S ) <= K : <NEWLINE> <INDENT> print ( S ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> l = S . split ( ) <NEWLINE> for i in range ( len ( S ) - K ) : <NEWLINE> <INDENT> l . pop ( - 1 ) <NEWLINE> <DEDENT> print ( <STRING> . join ( l ) ) <NEWLINE> <DEDENT>
40 <NEWLINE> ferelibenterhominesidquodvoluntcredunt <NEWLINE>
s = int ( input ( ) ) <NEWLINE> k = input ( ) <NEWLINE> if len ( s ) <= k : <NEWLINE> <INDENT> print ( s ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( s [ : k ] + <STRING> ) <NEWLINE> <DEDENT>
abc166b <NEWLINE> k = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> if len ( s ) <= k : <NEWLINE> <INDENT> print ( s ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ss = s [ : k ] <NEWLINE> print ( ss + <STRING> ) <NEWLINE> <DEDENT>
k = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> <NL> a = len ( s ) <NEWLINE> <NL> if k >= a : <NEWLINE> print ( s ) <NEWLINE> <NL> else : <NEWLINE> print ( s [ : k ] + <STRING> ) <NEWLINE>
k = int ( input ( ) ) <NEWLINE> s = str ( input ( ) ) <NEWLINE> if len ( s ) <= k : <NEWLINE> <INDENT> print ( s ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( s in range k + <STRING> ) <NEWLINE> <DEDENT>
K = map ( int , input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> <NL> <NL> if len ( S ) > K : <NEWLINE> <INDENT> print ( S ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( S [ : K ] , <STRING> ) <NEWLINE> <DEDENT>
k = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> n = len ( s ) <NEWLINE> <NL> if s <= k : <NEWLINE> print ( s ) <NEWLINE> <NL> else : <NEWLINE> print ( s [ : k ] + <STRING> ) <NEWLINE>
k = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> <NL> length = len ( s ) <NEWLINE> if length > K : <NEWLINE> <INDENT> s = s [ : K ] + <STRING> <NEWLINE> <DEDENT> print ( s ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> word = input ( ) <NEWLINE> ans = <STRING> <NEWLINE> if len ( word ) < n : <NEWLINE> <INDENT> print ( word ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( n ) : <NEWLINE> <INDENT> ans += word [ i ] <NEWLINE> <DEDENT> <DEDENT> print ( ans + <STRING> ) <NEWLINE>
k = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> l = len ( s ) <NEWLINE> if ( l <= k ) : <NEWLINE> <INDENT> print ( s ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s = s [ k : ] <NEWLINE> print ( s , end = <STRING> , ... ) <NEWLINE> <DEDENT>
import sys <NEWLINE> import math <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> <COMMENT> <NL> def inp ( ) : <NEWLINE> <INDENT> return ( int ( input ( ) ) ) <NEWLINE> <DEDENT> def inlt ( ) : <NEWLINE> <INDENT> return ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <DEDENT> def insr ( ) : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> <NL> <DEDENT> def invr ( ) : <NEWLINE> <INDENT> return ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <DEDENT> def solve ( s , k ) : <NEWLINE> <INDENT> len1 = len ( s ) <NEWLINE> if len1 > k : <NEWLINE> <INDENT> corte = <STRING> <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> corte += s [ i ] <NEWLINE> <DEDENT> corte += <STRING> <NEWLINE> return corte <NEWLINE> else : <NEWLINE> return s <NEWLINE> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <INDENT> k = inp ( ) <NEWLINE> print ( solve ( input ( ) , k ) ) <NEWLINE> <NL> <NL> <DEDENT> main ( ) <NEWLINE> <NL> <NL>
k = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> if s . len ( ) <= k : print ( s ) <NEWLINE> else : print ( s [ : k ] + <STRING> ) <NEWLINE>
k = int ( input ( ) ) <NEWLINE> s = str ( input ( ) ) <NEWLINE> <NL> if len ( s ) <= k : <NEWLINE> <INDENT> print ( s ) <NEWLINE> <DEDENT> elif len ( s ) > k : <NEWLINE> <INDENT> print ( s [ 0 : k - 1 ] <NEWLINE> <DEDENT>
k = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> <NL> print ( s if len ( s ) <= k else s [ 0 : k ] + <STRING> ) a <NEWLINE>
k = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> if len ( S ) > K : <NEWLINE> <INDENT> print ( S [ : K ] + <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( S ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> k = int ( input ( ) ) <NEWLINE> <NL> if len ( s ) <= k : <NEWLINE> <INDENT> print ( s ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( s [ : k ] + <STRING> ) <NEWLINE> <DEDENT>
k = int ( input ( ) ) <NEWLINE> s = int ( input ( ) ) <NEWLINE> if len ( s ) > k : <NEWLINE> <INDENT> print ( s [ : k ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( s ) <NEWLINE> <DEDENT>
k = input ( ) <NEWLINE> s = input ( ) <NEWLINE> <NL> if len ( s ) <= int ( k ) : <NEWLINE> <INDENT> print ( s ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( s [ 0 : k ] + <STRING> ) <NEWLINE> <DEDENT>
<COMMENT> <NL> import sys <NEWLINE> <NL> <NL> def solve ( K : int , S : str ) : <NEWLINE> <INDENT> if ( len ( S ) <= K ) : <NEWLINE> <INDENT> print ( S ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( K [ 0 : K + 1 ] , <STRING> , sep = <STRING> ) <NEWLINE> <DEDENT> return <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> def iterate_tokens ( ) : <NEWLINE> <INDENT> for line in sys . stdin : <NEWLINE> <INDENT> for word in line . split ( ) : <NEWLINE> <INDENT> yield word <NEWLINE> <DEDENT> <DEDENT> <DEDENT> tokens = iterate_tokens ( ) <NEWLINE> K = int ( next ( tokens ) ) <COMMENT> <NEWLINE> S = next ( tokens ) <COMMENT> <NEWLINE> solve ( K , S ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> if len ( s ) <= n : <NEWLINE> <INDENT> print ( s ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( s [ : n , <STRING> , sep = <STRING> ] ) <NEWLINE> <DEDENT>
K = input ( ) <NEWLINE> S = int ( input ( ) ) <NEWLINE> <NL> if len ( K ) <= S : <NEWLINE> <INDENT> print ( K ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( K [ : S ] + <STRING> ) <NEWLINE> <DEDENT>
K = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> <NL> if ( len ( S ) <= K ) : <NEWLINE> <INDENT> print ( S ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( S [ 0 : k - 1 ] + <STRING> ) <NEWLINE> <DEDENT>
K = input ( ) <NEWLINE> S = int ( input ( ) ) <NEWLINE> <NL> if len ( S ) <= K : <NEWLINE> <INDENT> print ( S ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( S [ : K ] + <STRING> ) <NEWLINE> <NL> <DEDENT>
K = int ( input ( ) ) <NEWLINE> S = int ( input ( ) ) <NEWLINE> if len ( S ) <= K : <NEWLINE> <INDENT> print ( S ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( S [ : K ] + <STRING> ) <NEWLINE> <DEDENT>
k = input ( ) <NEWLINE> s = input ( ) <NEWLINE> <NL> l = len ( s ) <NEWLINE> <NL> if k >= l : <NEWLINE> <INDENT> print ( k ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( s [ k - 1 ] + <STRING> ) <NEWLINE> <DEDENT>
K = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> <NL> length = len ( s ) <NEWLINE> if K >= length : <NEWLINE> <INDENT> print ( S ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( S [ : K ] + <STRING> ) <NEWLINE> <DEDENT>
k = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> if len ( s ) <= k : <NEWLINE> <INDENT> print ( k ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( s [ : k ] & <STRING> ) <NEWLINE> <DEDENT>
K = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> if K >= len ( S ) : <NEWLINE> <INDENT> print ( S ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( S : [ K ] + <STRING> ) <NEWLINE> <DEDENT>
<NL> <INDENT> k = int ( input ( ) ) <NEWLINE> <NL> s = input ( ) <NEWLINE> <NL> <NL> <DEDENT> if k < len ( s ) : <COMMENT> <NEWLINE> <INDENT> print ( s [ : k ] + <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( s ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> <NL> s = input ( ) <NEWLINE> l = len ( s ) <NEWLINE> if l > n : <NEWLINE> <INDENT> print ( s [ : n ] . join <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( s ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> if len ( s ) <= n : <NEWLINE> <INDENT> print ( s ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( s [ : k ] + <STRING> ) <NEWLINE> <DEDENT>
numTest = int ( input ( ) ) <NEWLINE> <NL> inputLine = input ( ) <NEWLINE> <NL> print ( inputLine [ 0 : numTest ] + <STRING> if len ( inputLine ) > numTest else inputLine <NEWLINE>
k = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> l = len ( s ) <NEWLINE> if s <= k : <NEWLINE> <INDENT> print ( s ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> p = s [ 1 : l ] <NEWLINE> q = <STRING> <NEWLINE> r = p + q <NEWLINE> print ( r ) <NEWLINE> <DEDENT>
k = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> <NL> if len ( s ) <= k : <NEWLINE> <INDENT> print ( s ) <NEWLINE> <DEDENT> else : <NEWLINE> print ( s [ : k ] + <STRING> ) <NEWLINE>
k = int ( input ( ) ) <NEWLINE> n = input ( ) <NEWLINE> <NL> if len ( n ) <= k : <NEWLINE> <INDENT> print ( n ) <NEWLINE> else : <NEWLINE> <INDENT> print ( n [ : k ] + <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> s = input <NEWLINE> if ( len ( s ) <= n ) : <NEWLINE> <INDENT> print ( s ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( n ) : <NEWLINE> <INDENT> print ( s [ i ] , end = <STRING> ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> <DEDENT>
k = int ( input ( ) ) <NEWLINE> s = list ( input ( ) ) <NEWLINE> if k = > len ( s ) : <NEWLINE> <INDENT> print ( s ) <NEWLINE> <DEDENT> else print ( s [ for k i in range k + 1 ] + <STRING> ) <NEWLINE>
K = int ( input ( ) ) <NEWLINE> S = str ( input ( ) ) . lower ( ) <NEWLINE> <NL> if 0 < K < 101 and 0 < len ( S ) < 101 : <NEWLINE> <INDENT> if len ( S ) = < K : <NEWLINE> <INDENT> print ( S ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( S [ : K ] + <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> k = int ( input ( ) ) <NEWLINE> if len ( s ) > k : <NEWLINE> <INDENT> print ( s [ : k ] + <STRING> ) <NEWLINE> <DEDENT> if len ( s ) <= k : <NEWLINE> <INDENT> print ( s ) <NEWLINE> <DEDENT>
k = int ( input ( ) ) <NEWLINE> s = str ( input ( ) ) <NEWLINE> len_s = len ( s ) <NEWLINE> <NL> if len_s <= k : <NEWLINE> <INDENT> print ( s ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> . join ( [ str ( x ) for x in [ s [ : k + 1 ] , <STRING> ] ] ) <NEWLINE> <DEDENT>
import numpy , math <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> s = str ( input ( ) ) <NEWLINE> <NL> if ( len ( s ) <= n ) : <NEWLINE> <INDENT> print ( s ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( s [ : n + 1 + <STRING> ] ) <NEWLINE> <DEDENT>
K = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> A = <STRING> <NEWLINE> if K < len ( S ) : <NEWLINE> <INDENT> for i in range ( K ) : <NEWLINE> <INDENT> A = A + S [ i ] <NEWLINE> A = A + <STRING> <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> A = S <NEWLINE> <DEDENT> print ( A ) <NEWLINE>
K = input ( ) <NEWLINE> S = int ( input ( ) ) <NEWLINE> <NL> if len ( K ) <= S : <NEWLINE> <INDENT> print ( K ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( K [ 0 : S ] + <STRING> ) <NEWLINE> <DEDENT>
K = int ( input ( ) ) <NEWLINE> S = int ( input ( ) ) <NEWLINE> if K > len ( S ) : <NEWLINE> <INDENT> print ( S ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( S [ 0 : K ] + <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> chara = input ( ) <NEWLINE> nc = len ( chara ) <NEWLINE> <NL> if n = > nc : <NEWLINE> <INDENT> print ( chara ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( chara [ 1 : n ] ) <NEWLINE> <NL> <DEDENT>
<NL> k = input ( ) <NEWLINE> s = input ( ) <NEWLINE> <NL> if len ( s ) <= k : <NEWLINE> <INDENT> print ( s ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( s + <STRING> ) <NEWLINE> <DEDENT>
S = input ( ) <NEWLINE> <NL> if len ( S ) <= K : <NEWLINE> <INDENT> print ( S ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( S [ 0 : K ] + <STRING> ) <NEWLINE> <DEDENT>
if len ( S ) > K : <NEWLINE> <INDENT> print ( S [ : K ] + <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( S ) <NEWLINE> <DEDENT>
K = int ( input ( ) ) <NEWLINE> S = str ( input ( ) ) <NEWLINE> <NL> if len ( S ) <= K : <NEWLINE> <INDENT> print ( S ) <NEWLINE> <DEDENT> else : <NEWLINE> <NL> <INDENT> print ( S [ : K + 1 ] + ... ) <NEWLINE> <DEDENT>
K = input ( ) <NEWLINE> S = input ( ) <NEWLINE> <NL> len_S = len ( S ) <NEWLINE> <NL> if K <= len_S : <NEWLINE> <INDENT> print ( S ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> print ( S [ K : ] , <STRING> ) <NEWLINE> <DEDENT>
<NL> def ac_168b ( K : int , S : str ) -> str : <NEWLINE> <INDENT> if len ( S ) <= K : <NEWLINE> <INDENT> return S <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return S [ 0 : K ] + <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> K = input ( ) <NEWLINE> S = input ( ) <NEWLINE> print ( ac_168b ( K , S ) ) <NEWLINE>
<INDENT> = int ( input ( ) ) <NEWLINE> <DEDENT> s = str ( input ( ) ) <NEWLINE> <NL> if len ( s ) <= k : <NEWLINE> <INDENT> print ( s ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s = s [ : k ] + <STRING> <NEWLINE> print ( s ) <NEWLINE> <DEDENT>
K = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> <NL> if len ( S ) <= K : <NEWLINE> <INDENT> print ( S ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( S [ 0 : K + <STRING> ] ) <NEWLINE> <DEDENT>
k = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> <NL> if len ( s ) <= k : <NEWLINE> <INDENT> print ( s ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( s [ : k ] + ... ) <NEWLINE> <DEDENT>
ln = int ( input ( ) ) <NEWLINE> st = input ( ) <NEWLINE> op = <STRING> <NEWLINE> if len ( st ) <= ln : <NEWLINE> <INDENT> print ( st ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ln1 = len ( st ) - ln <NEWLINE> for i in range ( ln ) : <NEWLINE> <INDENT> op = op + <STRING> <NEWLINE> <DEDENT> print ( st [ : ln ] + op <NEWLINE> <DEDENT>
k = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> <NL> if len ( s ) , = k : <NEWLINE> <INDENT> print ( s ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( s [ : k ] + <STRING> ) <NEWLINE> <DEDENT>
K = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> if S ( len ) < K : <NEWLINE> <INDENT> print ( S ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( S [ : K ] + <STRING> ) <NEWLINE> <DEDENT>
k = input ( ) <NEWLINE> s = input ( ) <NEWLINE> <NL> if s > len ( str ( k ) ) : <NEWLINE> <INDENT> print ( s ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( s [ k : ] + <STRING> ) <NEWLINE> <DEDENT>
K = input ( ) <NEWLINE> S = input ( ) <NEWLINE> if len ( S ) < K : <NEWLINE> <INDENT> print ( S ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> + <STRING> ) <NEWLINE> <DEDENT>
k = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> if len ( s ) <= k : <NEWLINE> <INDENT> print ( s ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( s [ : k ] _ <STRING> ) <NEWLINE> <DEDENT>
K = input ( ) <NEWLINE> S = input ( ) <NEWLINE> <NL> if len ( S ) <= K : <NEWLINE> <INDENT> print ( S ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( S [ : K ] + <STRING> ) <NEWLINE> <DEDENT>
K = input ( ) <NEWLINE> S = input ( ) <NEWLINE> strings = <STRING> <NEWLINE> if len ( K ) >= len ( S ) : <NEWLINE> <INDENT> print ( S ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> strings = str ( S [ : K + 1 ] ) + <STRING> <NEWLINE> print ( strings ) <NEWLINE> <DEDENT>
K = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> if len ( S ) <= K : <NEWLINE> <INDENT> print ( S ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( S [ : K ] + <STRING> ) 7 <NEWLINE> <DEDENT> nikoandsolstice <NEWLINE>
k = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> import numpy as np <NEWLINE> p = list ( s ) <NEWLINE> l = len ( p ) <NEWLINE> if l <= k : <NEWLINE> <INDENT> print ( s ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> arr = np . array ( p ) <NEWLINE> print ( p + <STRING> ) <NEWLINE> <DEDENT>
K = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> x = len ( s ) <NEWLINE> <NL> if x <= K : <NEWLINE> <INDENT> print ( s ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( S [ : K ] + <STRING> ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> num = int ( K ) <NEWLINE> if num >= len ( S ) : <NEWLINE> <INDENT> print ( S ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( S [ : num ] + <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> K , S = input ( ) . split ( ) <NEWLINE> <NL> main ( ) <NEWLINE>
Kkk = int ( input ( ) ) <NEWLINE> String = str ( input ( ) ) <NEWLINE> if len ( String ) == Kkk : <NEWLINE> <INDENT> print ( String ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> String . translate ( { ord ( i ) : None for i in range ( Kkk + 1 , len ( String ) - 1 ) } ) <NEWLINE> print ( String . append ( <STRING> ) ) <NEWLINE> <DEDENT>
<INDENT> K = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> print ( S [ : K ] + <STRING> ) <NEWLINE> <DEDENT>
k = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> i = <STRING> <NEWLINE> if len ( s ) <= k : <NEWLINE> <INDENT> print ( s ) <NEWLINE> else : <NEWLINE> <INDENT> for j in range ( k ) : <NEWLINE> <INDENT> i = i + s [ j ] <NEWLINE> <DEDENT> print ( i + <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
S = input ( ) <NEWLINE> K = int ( input ( ) ) <NEWLINE> <NL> if len ( S ) <= K : <NEWLINE> <INDENT> print ( S ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( S [ 0 : K ] , <STRING> ) <NEWLINE> <DEDENT>
K = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> if int ( len ( S ) ) <= K : <NEWLINE> <INDENT> print ( S ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( S [ 0 : K ] ... ) <NEWLINE> <DEDENT>
S = input ( ) <NEWLINE> K = int ( input ( ) ) <NEWLINE> <NL> if len ( S ) <= K : <NEWLINE> <INDENT> print ( S ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s = S [ 0 : K ] <NEWLINE> s1 = s + <STRING> <NEWLINE> print ( s1 ) <NEWLINE> <DEDENT>
K = str ( input ) <NEWLINE> S = input ( ) <NEWLINE> if len ( S ) <= K : <NEWLINE> <INDENT> print ( S ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( S [ : K ] + <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> l = len ( s ) <NEWLINE> if len <= n : <NEWLINE> <INDENT> print ( s ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( s [ : n ] + <STRING> ) <NEWLINE> <DEDENT>
K = input ( ) <NEWLINE> S = input ( ) K = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> if len ( S ) <= K : <NEWLINE> <INDENT> print ( S ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( S [ : K ] + <STRING> ) <NEWLINE> <DEDENT>
K = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> if len ( S ) <= K : <NEWLINE> <INDENT> print ( S ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( S [ K : ] + ... ) <NEWLINE> <DEDENT>
K = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> if len ( S ) <= K : <NEWLINE> <INDENT> input ( S ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> input ( S [ : K ] + <STRING> ) <NEWLINE> <DEDENT>
<COMMENT> <NL> K = int ( input ( ) ) <NEWLINE> <COMMENT> <NL> S = str ( input ( ) ) <NEWLINE> <COMMENT> <NL> x = int ( len ( str1 ) ) <NEWLINE> <COMMENT> <NL> i = x - k <NEWLINE> <NL> <COMMENT> <NL> S2 = <STRING> <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> if i == 0 : <NEWLINE> <INDENT> print ( S ) <NEWLINE> <COMMENT> <NL> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( x ) : <NEWLINE> <INDENT> S = S [ i ] <NEWLINE> <COMMENT> <NL> <DEDENT> newstr = <STRING> . join ( ( S , S2 ) ) <NEWLINE> print ( newstr ) <NEWLINE> <DEDENT>
K = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> if len ( S ) <= K : <NEWLINE> <INDENT> print ( S ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( K ) : <NEWLINE> <INDENT> print ( S [ i ] , end = <STRING> ) <NEWLINE> <DEDENT> print ( <STRING> 3 ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> import math <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> A , B , H , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> vh = ( ( H * 60 + M ) / ( 12 * 60 ) ) <NEWLINE> vm = ( M / 60 ) <NEWLINE> <NL> theta = ( vh - vm ) * math . tau <NEWLINE> d = math . sqrt ( A ** 2 + B ** 2 - 2 * A * B * math . cos ( theta ) ) <NEWLINE> <NL> print ( d ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
K = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> <NL> if len ( T ) < K : <NEWLINE> <INDENT> print ( S ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> print ( S [ 0 : K ] + <STRING> ) <NEWLINE> <DEDENT>
k = int , input ( ) <NEWLINE> l = input ( ) <NEWLINE> if ( len ( l ) < k ) : <NEWLINE> <INDENT> print ( l ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( l ) <NEWLINE> print ( <STRING> ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> k = input ( ) <NEWLINE> s = input ( ) <NEWLINE> if ( len ( s ) < k ) : <NEWLINE> <INDENT> print ( s ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( s [ 0 : k ] + <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> main ( ) <NEWLINE>
n = input ( ) <NEWLINE> s = input ( ) <NEWLINE> <NL> if len ( s ) <= n : <NEWLINE> <INDENT> print ( s ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( s [ : n ] + <STRING> ) <NEWLINE> <DEDENT>
K = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> if len ( S ) < K : <NEWLINE> <INDENT> print ( S ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( S [ : , K ] + <STRING> ) <NEWLINE> <DEDENT>
K = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> if len ( S ) = < K : <NEWLINE> <INDENT> print ( S ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( S [ : K + 1 ] + <STRING> ) <NEWLINE> <DEDENT>
S = input ( ) <NEWLINE> K = int ( input ( ) ) <NEWLINE> <NL> if len ( S ) > K : <NEWLINE> <INDENT> print ( S [ 0 : K ] + <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( S ) <NEWLINE> <DEDENT>
k = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> if ( k > s . length ) : <NEWLINE> <INDENT> print ( s ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( s [ 0 , k ] , <STRING> ) <NEWLINE> <DEDENT>
def solution ( ) : <NEWLINE> <INDENT> k = int ( input ( ) ) <NEWLINE> s = int ( input ( ) ) <NEWLINE> if len ( s ) > k : <NEWLINE> <INDENT> return s [ : k ] + <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return s <NEWLINE> <NL> <DEDENT> <DEDENT> print ( solution ( ) ) <NEWLINE>
K , S = int ( input ( ) ) , input ( ) <NEWLINE> if len ( S ) <= K : <NEWLINE> <INDENT> print ( S ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( S [ : K ] + ... ) <NEWLINE> <DEDENT>
<INDENT> k = int ( input ( ) ) <NEWLINE> <DEDENT> s = input ( ) <NEWLINE> if len ( s ) <= k : <NEWLINE> <INDENT> print ( s ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> . format ( fname = s [ : k ] ) ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> s = str ( input ( ) ) <NEWLINE> if len ( s ) <= n : <NEWLINE> <INDENT> print ( s ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( s [ : k + 1 ] + <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> l = max ( len ( s ) - n , 0 ) <NEWLINE> if ( l == 0 ) : <NEWLINE> <INDENT> print ( s ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> k = s ( : n ) <NEWLINE> print ( k + <STRING> ) <NEWLINE> <DEDENT>
40 <NEWLINE> ferelibenterhominesidquodvoluntcredunt <NEWLINE>
k = int ( ) <NEWLINE> s = input ( ) <NEWLINE> <NL> if len ( k ) <= k : <NEWLINE> <INDENT> print ( s ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> print ( s [ : k ] + <STRING> ) <NEWLINE> <DEDENT>
7 <NEWLINE> nikoandsolstice <NEWLINE>
S = input ( ) <NEWLINE> K = int ( input ( ) ) <NEWLINE> if len ( S ) >= K : <NEWLINE> <INDENT> print ( S [ 0 : K ] + <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( S ) <NEWLINE> <DEDENT>
k = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> if len ( s ) <= k : <NEWLINE> <INDENT> print ( s ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( s [ : s ] + <STRING> ) <NEWLINE> <DEDENT>
from sys import stdin <NEWLINE> <NL> K = int ( inpu ( ) ) <NEWLINE> S = input ( ) <NEWLINE> <NL> if len ( S ) <= K : <NEWLINE> <INDENT> print ( S ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( S [ : K ] , <STRING> , sep = <STRING> ) <NEWLINE> <DEDENT>
K = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> if len ( s ) > K : <NEWLINE> <INDENT> s = s [ : k ] + <STRING> <NEWLINE> <NL> <DEDENT> print ( s ) <NEWLINE>
length = input ( ) <NEWLINE> input_str = input ( ) <NEWLINE> <NL> if len ( input_str ) > length : <NEWLINE> <INDENT> print ( input_str + <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( input_str ) <NEWLINE> <DEDENT>
i = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> print ( s [ 0 : k - 1 ] if len ( s ) > k else s ) <NEWLINE>
[ K , S ] = input ( ) <NEWLINE> <NL> if len ( S ) > K : <NEWLINE> <INDENT> print ( S [ : K ] + <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( S ) <NEWLINE> <NL> <DEDENT>
k = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> <NL> slist = list ( s ) <NEWLINE> if len ( slist ) > k : <NEWLINE> <INDENT> l = <STRING> <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> k += slist [ i ] <NEWLINE> <DEDENT> print ( <STRING> + l ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( s ) <NEWLINE> <DEDENT>
import math <NEWLINE> <NL> <NL> hour_hand_speed = ( 2 * math . pi ) / ( 12 * 60 ) <NEWLINE> minute_hand_speed = ( 2 * math . pi ) / 60 <NEWLINE> <NL> hour_hand , minute_hand , hour , minute = list ( <NEWLINE> <INDENT> map ( int , input ( ) . split ( ) ) <NEWLINE> <DEDENT> ) <NEWLINE> <NL> elapsed_time = 60 * hour + minute <NEWLINE> <NL> hour_hand_angle = elapsed_time * hour_hand_speed <NEWLINE> minute_hand_angle = minute * minute_hand_speed <NEWLINE> <NL> angle_btw_hour_minute = abs ( hour_hand_angle - minute_hand_angle ) <NEWLINE> <NL> distance = math . sqrt ( <NEWLINE> <INDENT> hour_hand ** 2 + minute_hand ** 2 - ( 2 * hour_hand * minute_hand * math . cos ( angle_btw_hour_minute ) ) <NEWLINE> <DEDENT> ) <NEWLINE> <NL> print ( distance ) import math <NEWLINE> <NL> <NL> hour_hand_speed = ( 2 * math . pi ) / ( 12 * 60 ) <NEWLINE> minute_hand_speed = ( 2 * math . pi ) / 60 <NEWLINE> <NL> hour_hand , minute_hand , hour , minute = list ( <NEWLINE> <INDENT> map ( int , input ( ) . split ( ) ) <NEWLINE> <DEDENT> ) <NEWLINE> <NL> elapsed_time = 60 * hour + minute <NEWLINE> <NL> hour_hand_angle = elapsed_time * hour_hand_speed <NEWLINE> minute_hand_angle = minute * minute_hand_speed <NEWLINE> <NL> angle_btw_hour_minute = abs ( hour_hand_angle - minute_hand_angle ) <NEWLINE> <NL> distance = math . sqrt ( <NEWLINE> <INDENT> hour_hand ** 2 + minute_hand ** 2 - ( 2 * hour_hand * minute_hand * math . cos ( angle_btw_hour_minute ) ) <NEWLINE> <DEDENT> ) <NEWLINE> <NL> print ( distance ) <NEWLINE>
import math <NEWLINE> <NL> A , B , H , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> radH = 2 * math . pi * H / 12 + 30 / 180 * math . pi * M / 60 <NEWLINE> radM = 2 * math . pi * M / 60 <NEWLINE> <NL> L = math . sqrt ( A ^ 2 + B ^ 2 - 2 * A * B * math . cos ( radH - radM ) ) <NEWLINE> <NL> print ( L ) <NEWLINE>
A , B , C , D = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> rad = 2 * math . pi * ( ( ( C / 12 ) + ( ( 5 / 60 ) * ( D / 60 ) ) ) - ( D / 60 ) ) <NEWLINE> <NL> if math . cos ( rad ) == 1 : <NEWLINE> <INDENT> print ( abs ( A - B ) ) <NEWLINE> <DEDENT> elif math . cos ( rad ) == - 1 : <NEWLINE> <INDENT> print ( A + B ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( math . sqrt ( A ** 2 + B ** 2 - 2 * A * B * math . cos ( rad ) ) ) <NEWLINE> <DEDENT>
import math <NEWLINE> <NL> A , B , H , M = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> <NL> a = int ( A ) <NEWLINE> b = int ( B ) <NEWLINE> h = int ( H ) <NEWLINE> m = int ( M ) <NEWLINE> ang = 6 * m - ( 30 * h + 0.5 * m ) <NEWLINE> <NL> cosa = math . cos ( ang ) <NEWLINE> <NL> c = math . sqrt ( a ^ 2 + b ^ 2 - 2 * a * b * cosa ) <NEWLINE> <NL> <NL> print ( c ) <NEWLINE>
sadf <NEWLINE>
import math <NEWLINE> <NL> A , B , H , M = input ( ) . split ( ) <NEWLINE> <COMMENT> <NL> <NL> def get_point ( radians_theta , r ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <INDENT> x = r * math . sin ( math . radians ( radians_theta ) ) <NEWLINE> y = r * math . cos ( math . radians ( radians_theta ) ) <NEWLINE> return x , y <NEWLINE> <NL> <DEDENT> def calc_rad_big_hand ( H , M ) : <NEWLINE> <COMMENT> <NL> <INDENT> return H * 30 + M / 2 <NEWLINE> <NL> <DEDENT> def calc_rad_little_hand ( M ) : <NEWLINE> <COMMENT> <NL> <INDENT> return M * 6 <NEWLINE> <NL> <DEDENT> def calc_result ( A , B , H , M ) : <NEWLINE> <INDENT> H = int ( H ) <NEWLINE> M = int ( M ) <NEWLINE> big_hand_rad = calc_rad_big_hand ( H , M ) <NEWLINE> little_hand_rad = calc_rad_little_hand ( M ) <NEWLINE> big_x , big_y = get_point ( big_hand_rad , A ) <NEWLINE> little_x , little_y = get_point ( little_hand_rad , B ) <NEWLINE> return math . sqrt ( ( big_x - little_x ) ** 2 + ( big_y - little_y ) ** 2 ) <NEWLINE> <NL> <DEDENT> print ( calc_result ( A , B , H , M ) ) <NEWLINE>
import math <NEWLINE> a = int ( input ( ) ) <NEWLINE> b = int ( input ( ) ) <NEWLINE> h = int ( input ( ) ) <NEWLINE> m = int ( input ( ) ) <NEWLINE> rad = abs ( math . radians ( 30 * h - 6 * m ) ) <NEWLINE> if ( rad > 180 ) : <NEWLINE> <INDENT> rad = 2 * math . pi ( ) - rad <NEWLINE> <DEDENT> ans = a ** 2 + b ** 2 - 2 * a * b * math . cos ( rad ) <NEWLINE> print ( math . sqrt ( ans ) ) <NEWLINE>
import math <NEWLINE> i = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = i [ 0 ] <NEWLINE> <COMMENT> <NL> b = i [ 1 ] <NEWLINE> <COMMENT> <NL> h = i [ 2 ] <NEWLINE> <COMMENT> <NL> m = i [ 3 ] <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> ma = m * 6 <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> ha = h * 30 + 0.5 * m <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> if ma == 0 or ha == 0 : <NEWLINE> <INDENT> ang = max ( ma , ha ) <NEWLINE> <DEDENT> else <NEWLINE> ang = abs ( ma - ha ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> if ma == ha : <NEWLINE> <INDENT> print ( b - a ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> e = math . cos ( math . radians ( ang ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> d = a * a + b * b - 2 * a * b * e <NEWLINE> <COMMENT> <NL> c = math . sqrt ( d ) <NEWLINE> print ( c ) <NEWLINE> <NL> <COMMENT> <NL> <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> import math <NEWLINE> a , b , h , m = map ( int , input ( ) . split ( ) ) <NEWLINE> ty = ( ( h * 60 + m ) / 60 ) / 12 <NEWLINE> ta = ( m ) / 60 <NEWLINE> if abs ( ty - ta ) > 0.5 : <NEWLINE> <INDENT> k = 1 - abs ( ty - ta ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> k = abs ( ty - ta ) <NEWLINE> <COMMENT> <NL> <DEDENT> if h * 60 + m == 12 * m <NEWLINE> <INDENT> print ( b - a ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = a ** 2 + b ** 2 - 2 * a * b * ( np . cos ( k * 2 * math . pi ) ) <NEWLINE> print ( math . sqrt ( ans ) ) <NEWLINE> <DEDENT>
a , b , h , m = int ( input ( ) . split ( ) ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> min = ( 60 * h ) + m <NEWLINE> ang0 = ( min * 5.5 ) % 360 <NEWLINE> <NL> if ang0 <= 180 : <NEWLINE> <INDENT> ang = ang0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ang = 360 - ang0 <NEWLINE> <NL> <DEDENT> import math <NEWLINE> cos_ang = math . cos ( math . radians ( ang ) ) <NEWLINE> <NL> x = math . sqrt ( ( a ** 2 ) + ( b ** 2 ) - ( 2 * a * b * cos_ang ) ) <NEWLINE> <NL> print ( x ) <NEWLINE>
a = int ( input ( ) ) <COMMENT> <NEWLINE> b = int ( input ( ) ) <COMMENT> <NEWLINE> h = int ( input ( ) ) <COMMENT> <NEWLINE> m = int ( input ( ) ) <COMMENT> <NEWLINE> <NL> import math <NEWLINE> <NL> angle = abs ( ( 30 * h + m * 0.5 ) - m * 6 ) <NEWLINE> <NL> if angle > 180 : <NEWLINE> <INDENT> angle = 360 - angle <NEWLINE> <NL> <DEDENT> cos = math . cos ( math . radians ( angle ) ) <NEWLINE> ans = ( a * a ) + ( b * b ) - ( 2 * a * b * cos ) <NEWLINE> print ( math . sqrt ( ans ) ) <NEWLINE>
import numpy as np <NEWLINE> a , b , h , m = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> <NL> <NL> theta1 = ( 2 * np . pi / 60 ) * m <NEWLINE> <NL> if int ( h ) >= 12 : <NEWLINE> <INDENT> h = h - 12 <NEWLINE> <DEDENT> theta2 = ( 2 * np . pi / 12 ) * h <NEWLINE> <NL> c = a * a + b * b - 2 * a * c * np . cos ( np . abs ( theta1 - theta2 ) ) <NEWLINE> ans = np . sqrt ( c ) <NEWLINE> print ( ans ) <NEWLINE>
import math <NEWLINE> A , B , H , M = map ( int , input ( ) . spli3t ( ) ) <NEWLINE> <NL> H_degree = ( 30 * H ) + ( 0.5 * M ) <NEWLINE> M_degree = 6 * M <NEWLINE> diff = abs ( H_degree - M_degree ) <NEWLINE> if diff > 180 : <NEWLINE> <INDENT> diff = 360 - diff <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> diff = diff <NEWLINE> <NL> <DEDENT> length = math . sqrt ( A ** 2 + B ** 2 - 2 * A * B * math . cos ( math . radians ( diff ) ) ) <NEWLINE> <NL> print ( length ) <NEWLINE>
import math <NEWLINE> <NL> A , B , H , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> x = 360 // 12 <NEWLINE> y = 360 // 60 <NEWLINE> <NL> a = M * y <NEWLINE> b = ( H + M / 60 ) * x <NEWLINE> T = 1 <NEWLINE> if a >= b : <NEWLINE> <INDENT> if a - b > 180 : <NEWLINE> <INDENT> k = 360 - a + b <NEWLINE> <DEDENT> elif a - b == 180 : <NEWLINE> <INDENT> print ( A + B ) <NEWLINE> T = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> k = a - b <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if b - a > 180 : <NEWLINE> <INDENT> k = 360 - b + a <NEWLINE> <DEDENT> elif b - a == 180 : <NEWLINE> <INDENT> print ( A + B ) <NEWLINE> T = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> k = b - a <NEWLINE> <DEDENT> <DEDENT> if T = 1 : <NEWLINE> <INDENT> k = math . radians ( k ) <NEWLINE> <NL> ans = A * A + B * B - 2 * A * B * math . cos ( k ) <NEWLINE> <NL> print ( math . sqrt ( ans ) ) <NEWLINE> <DEDENT>
import sys <NEWLINE> import math <NEWLINE> from collections import Counter <NEWLINE> import itertools <NEWLINE> import fractions <NEWLINE> from decimal import Decimal <NEWLINE> <COMMENT> <NL> <NL> <COMMENT> <NL> def II ( ) : return int ( sys . stdin . readline ( ) ) <NEWLINE> def MI ( ) : return map ( int , sys . stdin . readline ( ) . split ( ) ) <NEWLINE> <COMMENT> <NL> def LI ( ) : return list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) <NEWLINE> <COMMENT> <NL> def LLI ( rows_number ) : return [ LI ( ) for _ in range ( rows_number ) ] <NEWLINE> def SR ( ) : return sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> <NL> ascii_lowercase = <STRING> <NEWLINE> ascii_uppercase = <STRING> <NEWLINE> ascii_uppercase2 = <STRING> <NEWLINE> <NL> <COMMENT> <NL> p2D = lambda x : print ( * x , sep = <STRING> ) <NEWLINE> p2E = lambda x : print ( <STRING> . join ( x ) ) <NEWLINE> p2S = lambda x : print ( * x , sep = <STRING> ) <NEWLINE> <NL> <COMMENT> <NL> <NL> A , B , H , M = MI ( ) <NEWLINE> <NL> <NL> <NL> kakuM = M * 6 <NEWLINE> kakuH = H * 30 + 0.5 * M <NEWLINE> <NL> <NL> <NL> <NL> kakudo = kakuH - kakuM <NEWLINE> if kakudo > 180 : <NEWLINE> <INDENT> kakudo -= 180 <NEWLINE> <NL> <DEDENT> if kakudo == 180 : <NEWLINE> <INDENT> print ( int ( A + B ) ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> if kakudo == 0 : <NEWLINE> <INDENT> print ( 0.000000000000 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> ans = A ** 2 + B ** 2 - 2 * A * B * Decimal . cos ( math . radians ( kakudo ) ) <NEWLINE> <NL> print ( Decimal ( ans ) . sqrt ( ) ) <NEWLINE>
A , B , H , M = map ( int , input ( ) . split ( ) ) <NEWLINE> C2 = A ** 2 + B ** 2 - 2 * A * B * math . cos ( math . radians ( 360 - ( 30 * H + M * 0.5 ) - 6 * M ) ) <NEWLINE> print ( C2 ** 0.5 ) <NEWLINE>
import math <NEWLINE> A , B , H , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> timeHr = H + ( M / 60 ) <NEWLINE> angVelA = ( 1 / 6 ) * 180 <NEWLINE> angVelB = ( 2 ) * 180 <NEWLINE> <NL> degA = ( angVelA * timeHr ) <NEWLINE> degB = ( angVelB * timeHr ) <NEWLINE> <NL> defDiff = math . radians ( abs ( degB - degA ) ) <NEWLINE> <NL> disX_2 = math . pow ( B , 2 ) + math . pow ( A , 2 ) - ( 2 * A * B * math . cos ( degDiff ) ) <NEWLINE> disX = math . sqrt ( disX_2 ) <NEWLINE> <NL> print ( disX ) <NEWLINE>
import math <NEWLINE> <NL> a , b , h , m = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if m == 0 : <NEWLINE> <INDENT> m = 60 <NEWLINE> <DEDENT> if h == 0 <NEWLINE> <INDENT> h = 12 <NEWLINE> <NL> <DEDENT> if h / 12 > m / 60 : <NEWLINE> <INDENT> k = ( h / 12 - m / 60 ) * 360 <NEWLINE> <DEDENT> elif h / 12 < m / 60 : <NEWLINE> <INDENT> k = ( m / 60 - h / 12 ) * 360 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <COMMENT> <NL> <DEDENT> print ( math . sqrt ( ( a ** 2 ) + ( b ** 2 ) - ( 2 * a * b * math . cos ( math . radians ( k ) ) ) ) ) <NEWLINE>
A , B , H , M = map ( float , input ( ) . split ( ) ) <NEWLINE> <NL> import math <NEWLINE> PI = math . pi <NEWLINE> radA = ( 2.0 * PI * ( H + M / 60.0 ) ) / 12.0 <NEWLINE> radB = ( 2.0 * PI * M ) / 60.0 <NEWLINE> print ( math . hypot ( A * math . cos ( radA ) - B * math . cos ( radB ) , <NEWLINE> <INDENT> A * math . sin ( radA ) - B * math . sin ( radB ) ) <NEWLINE> <DEDENT>
A , B , H , M = map ( int , input ( ) . split ( ) ) <NEWLINE> Ha = H * math . pi / 6 + M * math . pi / 360 <NEWLINE> Ma = M * math . pi / 30 <NEWLINE> if Ha == Ma : <NEWLINE> <INDENT> print ( abs ( A - B ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( math . sqrt ( A ** 2 + B ** 2 - 2 * A * B * math . cos ( Ha - Ma ) ) ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> from math import cos , pi <NEWLINE> a , b , h , m = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> mangle = 2 * pi * ( m / 60 ) <NEWLINE> hangle = 2 * pi * ( h / 12 ) <NEWLINE> dist = np . sqrt ( a ** 2 + b ** 2 - 2 * a * b * cos ( magnle - hangle ) ) <NEWLINE> print ( dist ) <NEWLINE>
import math <NEWLINE> a , b , h , m = map ( float , input ( ) . split ( ) ) <NEWLINE> rot = 5.5 * ( 60.0 * h + m ) <NEWLINE> rad = ang * math . pi / 180 <NEWLINE> cal = a ** 2 + b ** 2 - 2 * a * b * math . cos ( rad ) <NEWLINE> ans = math . sqrt ( cal ) <NEWLINE> print ( ans ) <NEWLINE>
import math <NEWLINE> <NL> a , b , h , m = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> def calc_ans ( rad ) : <NEWLINE> <INDENT> x = a ** 2 + b ** 2 - 2 * a * b * math . cos ( rad ) <NEWLINE> ans = math . sqrt ( x ) <NEWLINE> return ans <NEWLINE> <NL> <DEDENT> l_w = 2 * math . pi / ( 12 * 60 ) <NEWLINE> s_w = 2 * math . pi / 60 <NEWLINE> <NL> long_rad = l_w * ( h * 60 + m ) <NEWLINE> short_rad = s_w * m <NEWLINE> <NL> if abs ( long_rad - short_rad ) >= math . pi : <NEWLINE> <INDENT> rad = 2 * math . pi - abs ( long_rad - short_rad ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> rad = abs ( long_rad - short_rad ) <NEWLINE> <NL> <DEDENT> ans = calc_a <NEWLINE>
h_deg = ( minutes / ( 12 * 60 ) ) * 2 * math . pi <NEWLINE> m_deg = ( minutes / 60 ) * 2 * math . pi <NEWLINE> h_x = a * math . cos ( h_deg ) <NEWLINE> h_y = a * math . sin ( h_deg ) <NEWLINE> m_x = b * math . cos ( m_deg ) <NEWLINE> m_y = b * math . sin ( m_deg ) <NEWLINE> print ( math . sqrt ( ( h_x - m_x ) * ( h_x - m_x ) + ( h_y - m_y ) * ( h_y - m_y ) ) ) <NEWLINE>
import math <NEWLINE> t = input ( ) . split ( ) <NEWLINE> t = [ int ( i ) for i in t ] <NEWLINE> r = math . sqrt ( t [ 0 ] * t [ 0 ] + t [ 1 ] * t [ 1 ] ) <NEWLINE> h = t [ 2 ] <NEWLINE> m = t [ 3 ] <NEWLINE> if ( h == 12 ) : <NEWLINE> <INDENT> h = 0 <NEWLINE> <DEDENT> if ( m == 60 ) : <NEWLINE> <INDENT> m = 0 <NEWLINE> <DEDENT> hour_angle = 0.5 * ( h * 60 + m ) <NEWLINE> minute_angle = 6 * m <NEWLINE> angle = abs ( hour_angle - minute_angle ) <NEWLINE> angle = min ( 360 - angle , angle ) <NEWLINE> print ( math . sqrt ( r * r - 2 * t [ 0 ] * t [ 1 ] * math . cos ( angle ( 2 * math . pi / 360 ) ) ) ) <NEWLINE>
from sys import stdin <NEWLINE> import sys , math <NEWLINE> <NL> a , b , h , m = [ int ( x ) for x in stdin . readline ( ) . rstrip ( ) . split ( ) ] <NEWLINE> <NL> x = 30 * h + 0.5 * m <NEWLINE> y = 6 * m <NEWLINE> <NL> c = a ** 2 + b ** 2 - 2 * a * b * abs ( math . cos ( math . radians ( z ) ) ) <NEWLINE> c = math . sqrt ( c ) <NEWLINE> <NL> print ( c ) <NEWLINE>
import math <NEWLINE> <NL> A , B , H , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> deg_long = M * 6 <NEWLINE> deg_short = 30 * H + M / 2 <NEWLINE> <NL> rad = math . radians ( min ( deg_long - deg_short , 360 - ( deg_long - deg_short ) ) ) <NEWLINE> print ( math . sqrt ( A ** 2 + B ** 2 - 2 * A * B * cos ( rad ) ) ) <NEWLINE>
import math <NEWLINE> a = ( int ) ( input ( ) ) <NEWLINE> b = int ( input ( ) ) <NEWLINE> h = int ( input ( ) ) <NEWLINE> m = int ( input ( ) ) <NEWLINE> t1 = h / 6 * math . pi <NEWLINE> t2 = m / 30 * math . pi <NEWLINE> dellt = abs ( t2 - t1 ) <NEWLINE> ans = b * b + a * a - 2 * a * b * math . cos ( dellt ) <NEWLINE> print ( ans ** 0.5 ) <NEWLINE>
a , b , h , m = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> hangle = 360 * ( h / 12 + m / ( 60 * 12 ) ) <NEWLINE> mangle = 360 * m / 60 <NEWLINE> hm = math . radians ( abs ( hangle - mangle ) ) <NEWLINE> <NL> ans = math . sqrt ( a ** 2 + b ** 2 - 2 * a * b * math . cos ( hm ) ) <NEWLINE> <NL> print ( ans ) <NEWLINE>
import math <NEWLINE> A , B , H , M = map ( int , input ( ) . split ( ) ) <NEWLINE> a = 360 * H / 12 + 30 * M / 60 <NEWLINE> b = 360 * M / 60 <NEWLINE> c = abs ( a - b ) <NEWLINE> if c < 90 : <NEWLINE> <INDENT> sin ( c ) = math . sin ( math . radians ( c ) ) <NEWLINE> cos ( c ) = math . sin ( math . radians ( c ) ) <NEWLINE> d = B - A * cos ( c ) <NEWLINE> e = ( d ** 2 + ( A * sin ( c ) ) ** 2 ) ** 0.5 <NEWLINE> print ( e ) <NEWLINE> <DEDENT> elif c == 90 : <NEWLINE> <INDENT> e = ( A ** 2 + B ** 2 ) ** 0.5 <NEWLINE> print ( e ) <NEWLINE> <DEDENT> elif c > 90 : <NEWLINE> <INDENT> sin ( c ) = math . sin ( math . radians ( 180 - c ) ) <NEWLINE> cos ( c ) = math . sin ( math . radians ( 180 - c ) ) <NEWLINE> d = B + A * cos ( c ) <NEWLINE> e = ( d ** 2 + ( A * sin ( c ) ** 2 ) ** 0.5 <NEWLINE> print ( e ) <NEWLINE> <DEDENT>
import math <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> a , b , h , m = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> x = ( a ** 2 + b ** 2 - 2 * a * b * math . cos ( int ( 360 / h ) * 30 ) - int ( 360 / m ) * 6 ) ** 0.5 <NEWLINE> print ( x ) <NEWLINE>
import math <NEWLINE> A , B , H , M = map ( int , input ( ) . split ( ) ) <NEWLINE> cen = ( 60 * H + M ) / 2 - 6 * M <NEWLINE> cen_cos = math . cos ( math . radian ( cen ) ) <NEWLINE> <NL> print ( A ** 2 + B ** 2 - 2 * cen_cos * A * B ) <NEWLINE>
import sys <NEWLINE> import math <NEWLINE> from collections import Counter <NEWLINE> import itertools <NEWLINE> import fractions <NEWLINE> from decimal import Decimal <NEWLINE> <COMMENT> <NL> <NL> <COMMENT> <NL> def II ( ) : return int ( sys . stdin . readline ( ) ) <NEWLINE> def MI ( ) : return map ( int , sys . stdin . readline ( ) . split ( ) ) <NEWLINE> <COMMENT> <NL> def LI ( ) : return list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) <NEWLINE> <COMMENT> <NL> def LLI ( rows_number ) : return [ LI ( ) for _ in range ( rows_number ) ] <NEWLINE> def SR ( ) : return sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> <NL> ascii_lowercase = <STRING> <NEWLINE> ascii_uppercase = <STRING> <NEWLINE> ascii_uppercase2 = <STRING> <NEWLINE> <NL> <COMMENT> <NL> p2D = lambda x : print ( * x , sep = <STRING> ) <NEWLINE> p2E = lambda x : print ( <STRING> . join ( x ) ) <NEWLINE> p2S = lambda x : print ( * x , sep = <STRING> ) <NEWLINE> <NL> <COMMENT> <NL> <NL> kakuM = M * 6 <NEWLINE> kakuH = H * 30 + 0.5 * M <NEWLINE> <NL> kakudo = kakuH - kakuM <NEWLINE> <NL> ans = A ** 2 + B ** 2 - 2 * A * B * math . cos ( math . radians ( kakudo ) ) <NEWLINE> <NL> print ( math . sqrt ( ans ) ) <NEWLINE>
A , B , H , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <NL> h = ( H / 12 + ( M / 60 / 12 ) ) * 2 * math . pi <NEWLINE> m = M / 60 * 2 * math . pi <NEWLINE> <NL> ax = A * math . cos ( h ) <NEWLINE> ay = A * math . sin ( h ) <NEWLINE> <NL> bx = B * math . cos ( m ) <NEWLINE> by = B * math . sin ( m ) <NEWLINE> <NL> <COMMENT> <NL> <NL> ans = ( ( ax - bx ) ** 2 + ( ay - by ) ** 2 ) ** ( 1 / 2 ) <NEWLINE> <NL> print ( ans ) <NEWLINE>
a , b , c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> import math <NEWLINE> rad = math . fabs ( ( c / 12 - d / 60 ) * 360 ) <NEWLINE> rad = min ( rad , 360 - rad ) <NEWLINE> cosine = ( math . cos ( math . radians ( rad ) ) <NEWLINE> print ( ( a ** 2 + b ** 2 - 2 * a * b * cosine ) ** 0.5 ) <NEWLINE>
import math <NEWLINE> A = int ( input ( ) ) <NEWLINE> B = int ( input ( ) ) <NEWLINE> H = int ( input ( ) ) <NEWLINE> M = int ( input ( ) ) <NEWLINE> t = H * 60 + M <NEWLINE> CC = A ** 2 + B ** 2 - 2 * A * B * math . cos ( ( ( math . pi / 60 ) - ( math . pi / 360 ) ) * t ) <NEWLINE> print ( CC ** ( 1 / 2 ) ) <NEWLINE>
import math <NEWLINE> <NL> a , b , h , m = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> kaku = math . pi / 360 * abs ( 60 * h - 11 * M ) <NEWLINE> <NL> <COMMENT> <NL> ans = a ** 2 + b ** 2 - 2 * math . cos ( kaku ) * a * b <NEWLINE> <NL> print ( ans ** ( 1 / 2 ) ) <NEWLINE> <NL>
short = int ( input ( ) ) <NEWLINE> long = int ( input ( ) ) <NEWLINE> hour = int ( input ( ) ) <NEWLINE> mini = int ( input ( ) ) <NEWLINE> import math <NEWLINE> shortx = short * math . sin ( hour / 6 * math . pi ) <NEWLINE> shorty = short * math . cos ( hour / 6 * math . pi ) <NEWLINE> longx = long * math . sin ( mini / 30 * math . pi ) <NEWLINE> longy = long * math . cos ( mini / 30 * math . pi ) <NEWLINE> c = math . sqrt ( ( shortx - longx ) ** 2 + ( shorty - longy ) ** 2 ) <NEWLINE> print ( c ) <NEWLINE>
import math <NEWLINE> <NL> A , B , H , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> theta = ( H * 30 - M * 9.5 ) * math . pi / 180 <NEWLINE> <NL> ans = math . sqrt ( A * A + B * B - 2 * A * B * math . cos ( theta ) ) <NEWLINE> <NL> print ( ans ) <NEWLINE> ~ ~ ~ ~ ~ <NEWLINE>
3 4 10 40 <NEWLINE>
def abc168_c ( ) : <NEWLINE> <INDENT> A , B , H , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <COMMENT> <NL> h_angle = 30 * H + 0.5 * M <NEWLINE> <COMMENT> <NL> m_angle = 6 * M <NEWLINE> <COMMENT> <NL> x_dist = A * math . cos ( math . radians ( h_angle ) ) - B * math . cos ( math . radians ( m_angle ) ) <NEWLINE> <COMMENT> <NL> y_dist = A * math . sin ( math . radians ( h_angle ) ) - B * math . sin ( math . radians ( m_angle ) ) <NEWLINE> <COMMENT> <NL> dist = math . sqrt ( x_dist ** 2 + y_dist ** 2 ) <NEWLINE> print ( <STRING> . format ( dist ) ) <NEWLINE> <NL> <DEDENT> abc168_c ( ) <NEWLINE>
import math <NEWLINE> A = int ( input ( ) ) <NEWLINE> B = int ( input ( ) ) <NEWLINE> H = int ( input ( ) ) <NEWLINE> M = int ( input ( ) ) <NEWLINE> <NL> def angle ( ) : <NEWLINE> <INDENT> wa = 0.5 <NEWLINE> wb = 6 <NEWLINE> w = wb - wa <NEWLINE> t = H * 60 + M <NEWLINE> wnew = ( w * t ) % 360 <NEWLINE> if wnew >= 180 : <NEWLINE> <INDENT> wnew = 360 - wnew <NEWLINE> <DEDENT> return wnew <NEWLINE> <NL> <DEDENT> cos_angle = math . cos ( math . radians ( angle ( ) ) ) <NEWLINE> distance = A ** 2 + A ** 2 - 2 * A * B * cos_angle <NEWLINE> answer = distance ** 0.5 <NEWLINE> print ( answer ) <NEWLINE>
import math <NEWLINE> inputs = input ( ) . split ( ) <NEWLINE> A , B , H , M = int ( inputs [ 0 ] ) , int ( inputs [ 1 ] ) , int ( inputs [ 2 ] ) , int ( inputs [ 3 ] ) <NEWLINE> num_diff = H * 5 + M / 12 - M <NEWLINE> <NL> ans = math . sqrt ( A ** 2 + B ** 2 - 2 * A * B * math . cos ( 2 * math . pi ( num_diff / 60 ) ) <NEWLINE> <NL> print ( ans ) <NEWLINE>
import . math <NEWLINE> A , B , C , D = map ( int , input ( ) . split ( ) ) <NEWLINE> sita = A * 30 + B * 0.5 - B * 6 <NEWLINE> sitas = 0 <NEWLINE> if sita > 180 : <NEWLINE> <INDENT> sitas = 360 - sita <NEWLINE> <DEDENT> elif - 180 <= sita < 0 : <NEWLINE> <INDENT> sitas = sita * - 1 <NEWLINE> <DEDENT> elif sita < - 180 : <NEWLINE> <INDENT> sitas = sita + 360 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> sitas = sita <NEWLINE> <DEDENT> sin = math . cos ( math . radians ( sitas ) ) <NEWLINE> tan = C ** 2 + D ** 2 - 2 * C * D * sin <NEWLINE> print ( math . sqrt ( tan ) ) <NEWLINE>
rad_a = ( h / 12 + ( 1 / 12 ) * ( m / 60 ) ) * 360 <NEWLINE> rad_b = ( m / 60 ) * 360 <NEWLINE> <NL> if rad_a == rad_b : <NEWLINE> <INDENT> print ( abs ( b - a ) ) <NEWLINE> <DEDENT> elif abs ( rad_a - rad_b ) == 180 : <NEWLINE> <INDENT> print ( b + a ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( math . sqrt ( a ** 2 + b ** 2 - 2 * a * b * math . cos ( math . radians ( abs ( rad_a - rad_b ) ) ) ) ) <NEWLINE> <DEDENT>
import math <NEWLINE> a , b , h , m = map ( int , input ( ) . split ( ) ) <NEWLINE> x = ( math . pi ) * h / 6 - ( math . pi ) * m / 30 ) + ( math . pi ) * m / 360 <NEWLINE> c = a ** 2 + b ** 2 - 2 * a * b * ( math . cos ( x ) ) <NEWLINE> c = math . sqrt ( c ) <NEWLINE> print ( c ) <NEWLINE>
import math <NEWLINE> <NL> A , B , H , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> KA = H / 12 * 360 + ( ( M / 60 ) * ( 360 / 12 ) ) <NEWLINE> KB = M / 60 * 360 <NEWLINE> <NL> K = abs ( KA - KB ) <NEWLINE> if K > 180 : <NEWLINE> <INDENT> K = 360 - K <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> cosB = math . cos ( math . radians ( K ) ) , 13 <NEWLINE> cc = A ** 2 + B ** 2 - ( 2 * B * A * cosB ) <NEWLINE> print ( math . sqrt ( cc ) ) <NEWLINE>
import math <NEWLINE> A , B , H , M = map ( float , input ( ) . split ( ) ) <NEWLINE> X = sqrt ( A ** 2 + B ** 2 - 2 * A * B * math . cos ( math . radians ( 5.5 * M - 30 * H ) ) ) <NEWLINE> print ( X ) <NEWLINE>
import math <NEWLINE> a , b , c , d = input ( ) . split ( <STRING> ) <NEWLINE> a = int ( a ) <NEWLINE> b = int ( b ) <NEWLINE> c = int ( c ) <NEWLINE> d = int ( d ) <NEWLINE> t1 = 30 * + 0.5 * d <NEWLINE> t2 = 6 * d <NEWLINE> print ( t1 , t2 ) <NEWLINE> print ( sqrt ( e ) ) <NEWLINE>
<COMMENT> <NL> import math <NEWLINE> <COMMENT> <NL> A , B , H , M = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> <NL> <COMMENT> <NL> rad = abs ( H / 6 * math . pi - M / 30 * math . pi ) <NEWLINE> rad = min ( rad , 360 - rad ) <NEWLINE> print ( <STRING> . format ( A * A + B * B - 2 * A * B * math . cos ( rad ) ) ** 0.5 ) <NEWLINE>
import math <NEWLINE> A , B , H , M = map ( int , input ( ) . split ( ) ) <NEWLINE> a = 30 * H + 0.5 * M <NEWLINE> b = M * 6 <NEWLINE> if abs ( a - b ) < 180 : <NEWLINE> <INDENT> ab = abs ( a - b ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ab = abs ( 360 - a - b ) <NEWLINE> <DEDENT> ab1 = round ( math . cos ( math . radians ( ab ) ) , 20 ) <NEWLINE> ans = round ( math . sqrt ( A ** 2 + B ** 2 - 2 * A * B * ab1 ) , 20 ) <NEWLINE> print ( round ( ans , 10 ) <NEWLINE>
import math <NEWLINE> A , B , H , M = map ( int , input ( ) . split ( ) ) <NEWLINE> Hs = H / 12 + 6 * M <NEWLINE> Ms = H / 12 + M / 2 <NEWLINE> shita = Hs - Ms <NEWLINE> shita = abs ( shita ) <NEWLINE> if shita >= 180 : <NEWLINE> <INDENT> shita = 180 - shita <NEWLINE> <DEDENT> shita = math . radians ( shita ) <NEWLINE> C = A * A + B * B - 2 * A * B * math . cos ( shtia ) <NEWLINE> print ( C ** 0.5 ) <NEWLINE>
A , B , H , M = map ( int , input ( ) . split ( ) ) <NEWLINE> x = 360 * ( H + M / 60 ) / 12 - 360 * M / 60 <NEWLINE> cos = math . cos ( math . radians ( x ) ) <NEWLINE> C = A ** 2 + B ** 2 - 2 * A * B * ( cos ) <NEWLINE> print ( C ** 0.5 ) <NEWLINE>
A , B , H , M = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> <COMMENT> <NL> theta = abs ( ( 30 * H + 30 * M / 60 ) - 6 * M ) <NEWLINE> if ( theta > 180 ) : <NEWLINE> <INDENT> theta -= 180 <NEWLINE> <DEDENT> elif ( theta == 180 ) : <NEWLINE> <INDENT> print ( A + B ) <NEWLINE> return <NEWLINE> <DEDENT> print ( math . sqrt ( A ** 2 + B ** 2 - 2 * A * B * math . cos ( math . radians ( theta ) ) ) ) <NEWLINE>
import math <NEWLINE> <NL> A = int ( input ( ) ) <NEWLINE> B = int ( input ( ) ) <NEWLINE> H = int ( input ( ) ) <NEWLINE> M = int ( input ( ) ) <NEWLINE> <NL> alpha = ( H + M / 60 ) / 12 * 2 * math . pi <NEWLINE> beta = M / 60 * 2 * math . pi <NEWLINE> <NL> X = A * math . cos ( alpha ) - B * math . cos ( beta ) <NEWLINE> Y = A * math . sin ( alpha ) - B * math . sin ( beta ) <NEWLINE> <NL> distance = math . sqrt ( X * X + Y * Y ) <NEWLINE> <NL> print ( distance ) <NEWLINE>
import math <NEWLINE> <NL> A B H M = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> H_arg = H * 30 + 0.5 * M <NEWLINE> M_arg = 6 * M <NEWLINE> <NL> if H_arg - M_arg >= 180 : <NEWLINE> <INDENT> H_M_arg = ( 360 - H_arg ) + M_arg <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> H_M_arg = abs ( H_arg - M_arg ) <NEWLINE> <NL> <DEDENT> X = math . sqrt ( A ** 2 + B ** 2 - 2 * A * B * cos ( H_M_arg ) ) <NEWLINE> print ( X ) <NEWLINE>
A , B , H , M = map ( float , input ( ) . split ( ) ) <NEWLINE> from math import sin , cos , pi <NEWLINE> <NL> C = abs ( 30 * H - 5.5 * M ) <NEWLINE> C = C if C <= 180 : 360 - C <NEWLINE> c = sqrt ( A ** 2 + B ** 2 - 2 * A * B * cos ( C * pi / 180 ) ) <NEWLINE> print ( C ) <NEWLINE>
a , b , h , m = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> <NL> rec_h = 30 * h + 0.5 * m <NEWLINE> rec_m = 6 * m <NEWLINE> rec = ( rec_h - rec_m ) % 180 <NEWLINE> <NL> x = b * math . sin ( math . radians ( rec ) ) <NEWLINE> y = a - b * math . cos ( math . radians ( rec ) ) <NEWLINE> <NL> r = math . sqrt ( x ** 2 + y ** 2 ) <NEWLINE> print ( r ) <NEWLINE>
A , B , H , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> angle = abs ( 30 * H - 5.5 * M ) <NEWLINE> angle = min ( angle , 360 - angle ) * math . pi / 180 <NEWLINE> <NL> c = A ** 2 + B ** 2 - 2 * A * B * math . cos ( angle ) <NEWLINE> c = c ** 0.5 <NEWLINE> <NL> print ( c ) <NEWLINE>
a , b , h , m = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> hh = 360 * ( 60 * h + m ) / ( 60 * 12 ) <NEWLINE> mm = 360 * ( m / 60 ) <NEWLINE> rad = hh - mm <NEWLINE> if rad > 180 : <NEWLINE> <INDENT> rad = 360 - rad <NEWLINE> <DEDENT> print ( math . sqrt ( a ** 2 + b ** 2 - 2 * a * b * math . cos ( math . radians ( rad ) ) ) ) <NEWLINE>
mport math <NEWLINE> a , b , h , m = map ( int , input ( ) . split ( ) ) <NEWLINE> if h > 12 : <NEWLINE> <INDENT> h_c = h - 12 <NEWLINE> <DEDENT> p_d = 6 * ( abs ( h * 5 - m ) ) <NEWLINE> if p_d >= 180 : <NEWLINE> <INDENT> p_d2 = 360 - p_d <NEWLINE> d_2 = a ** 2 + b ** 2 - 2 * a * b * math . cos ( math . radians ( p_d2 ) ) <NEWLINE> print ( math . sqrt ( d_2 ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d_2 = a ** 2 + b ** 2 - 2 * a * b * math . cos ( math . radians ( p_d ) ) <NEWLINE> print ( math . sqrt ( d_2 ) ) <NEWLINE> <DEDENT>
import math <NEWLINE> def solution ( ) : <NEWLINE> <INDENT> a , b , h , m = map ( int , input ( ) . split ( ) ) <NEWLINE> return ( a * a + b * b - 2 * a * b * cos ( ( m * 11 / 360 - h / 6 ) * pi ) ) ** .5 <NEWLINE> <DEDENT> print ( solution ( ) ) <NEWLINE>
import math <NEWLINE> a , b , h , m = map ( int ( ) , input ( ) . split ( ) ) <NEWLINE> angle = abs ( 30 * h - 5.5 * m ) <NEWLINE> distance = ( a * a + b * b - 2 * a * b * math . cos ( math . radians ( angle ) ) ) <NEWLINE> print ( math . sqrt ( distance ) ) <NEWLINE>
import numpy as np <NEWLINE> <NL> A , B , H , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> Aw = 2 * np . pi / 12 / 60 <NEWLINE> Bw = 2 * np . pi / 60 <NEWLINE> thetaA = Aw * ( H * 60 + M ) <NEWLINE> thetaB = Bw * M <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> if thetaA + thetaB == np . pi : <NEWLINE> if thetaA > thetaB : <NEWLINE> <INDENT> ans = np . sqrt ( A ** 2 + B ** 2 - 2 * A * B * np . cos ( thetaA - thetaB ) ) <NEWLINE> <DEDENT> elif thetaB > thetaA : <NEWLINE> <INDENT> ans = np . sqrt ( A ** 2 + B ** 2 - 2 * A * B * np . cos ( thetaB - thetaA ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = B - A <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> a , b , h , m = map ( float , input ( ) . split ( ) ) <NEWLINE> H = ( ( h % 12 ) * 30 ) <NEWLINE> M = ( m * 6 ) <NEWLINE> x = abs ( H - M ) <NEWLINE> y = 360 - x <NEWLINE> l = [ x , y ] <NEWLINE> l . sort ( ) <NEWLINE> sita = l [ 0 ] <NEWLINE> sita = math . radians ( sita ) <NEWLINE> c = a ** 2 + b ** 2 - 2 ( * a * b * math . cos ( sita ) ) <NEWLINE> c = math . sqrt ( c ) <NEWLINE> print ( c ) <NEWLINE>
j , f , h , m = map ( int , input ( ) . split ( ) ) <NEWLINE> df = 6 * m <NEWLINE> dh = m / 2 + 30 * h <NEWLINE> d = 0 <NEWLINE> if df > dh : <NEWLINE> <INDENT> d = df - dh <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d = dh - df <NEWLINE> <DEDENT> l = ( j ** 2 + f ** 2 - 2 * j * f * math . cos ( math . radians ( d ) ) ) <NEWLINE> print ( l ) <NEWLINE>
from math import cos , radians , sqrt <NEWLINE> <NL> A , B , H , M = list ( map ( int , input ( ) . split ) ) <NEWLINE> <NL> m = H * 60 + M <NEWLINE> h = 360.0 / 60.0 * ( m % 60 ) <NEWLINE> mi = 360.0 / 720.0 * ( m % 720 ) <NEWLINE> arg = abs ( h - mi ) <NEWLINE> <NL> print ( sqrt ( A ** 2 + B ** 2 - 2.0 * A * B * cos ( radians ( arg ) ) ) ) <NEWLINE>
import math <NEWLINE> a = int ( input ( ) ) <NEWLINE> b = int ( input ( ) ) <NEWLINE> h = int ( input ( ) ) <NEWLINE> m = int ( input ( ) ) <NEWLINE> x = ( h * 60 + m ) / 2 <NEWLINE> y = 6 * m <NEWLINE> angle = abs ( x - y ) <NEWLINE> angle = min ( 360 - angle , angle ) <NEWLINE> pi = 3.14159265358979323 <NEWLINE> k = math . pi / 180 <NEWLINE> if angle == 180 : <NEWLINE> <INDENT> print ( a + b ) <NEWLINE> <NL> <DEDENT> elif ( angle == 0 ) : <NEWLINE> <INDENT> print ( 0.0000000000 ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> angle = angle * k <NEWLINE> p = math . cos ( angle ) <NEWLINE> if ( p < - 1 ) : <NEWLINE> <INDENT> p = 0 <NEWLINE> <DEDENT> ans = pow ( a , 2 ) + pow ( b , 2 ) - 2 * a * b * p ; <NEWLINE> ans = math . sqrt ( ans ) ; <NEWLINE> print ( ans ) <NEWLINE> <DEDENT>
if __name__ == <STRING> : <NEWLINE> <INDENT> a , b , h , m = input ( ) . split ( ) <NEWLINE> <NL> a = float ( a ) <NEWLINE> b = float ( b ) <NEWLINE> h = float ( h ) <NEWLINE> m = float ( m ) <NEWLINE> <NL> theta = 2.0 * math . pi * h / 12.0 <NEWLINE> phi = 2.0 * math . pi * m / 60.0 <NEWLINE> <NL> xa = a * math . sin ( theta ) <NEWLINE> ya = a * math . cos ( theta ) <NEWLINE> <NL> xb = b * math . sin ( phi ) <NEWLINE> yb = b * math . cos ( phi ) <NEWLINE> <NL> print ( xa , ya ) <NEWLINE> print ( xb , yb ) <NEWLINE> distance = math . sqrt ( math . pow ( xa - xb , 2 ) + math . pow ( ya - yb , 2 ) ) <NEWLINE> <NL> print ( distance ) <NEWLINE> <DEDENT>
import math <NEWLINE> a , b , H , m = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> import math <NEWLINE> <NL> if m <= 15 : <NEWLINE> <INDENT> by = b * math . sin ( math . radians ( 90 - ( 6 * m ) ) ) <NEWLINE> bx = b * math . cos ( math . radians ( 90 - ( 6 * m ) ) ) <NEWLINE> <DEDENT> elif m > 15 and m <= 30 : <NEWLINE> <INDENT> by = b * math . sin ( math . radians ( 6 * ( m - 15 ) ) ) <NEWLINE> bx = b * - ( math . cos ( math . radians ( 6 * ( m - 15 ) ) ) ) <NEWLINE> <DEDENT> elif m > 30 and m <= 45 : <NEWLINE> <INDENT> by = b * - ( math . sin ( math . radians ( 90 - ( ( 6 * m ) - 180 ) ) ) ) <NEWLINE> bx = b * - ( math . cos ( math . radians ( 90 - ( ( 6 * m ) - 180 ) ) ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> by = b * - ( math . sin ( math . radians ( ( 6 * m ) - 270 ) ) ) <NEWLINE> bx = b * math . cos ( math . radians ( ( 6 * m ) - 270 ) ) <NEWLINE> <NL> <DEDENT> if 60 * H + m <= 180 : <NEWLINE> <INDENT> ay = a * math . sin ( math . radians ( 90 - ( 1 / 2 * ( 60 * H + m ) ) ) ) <NEWLINE> ax = a * math . cos ( math . radians ( 90 - ( 1 / 2 * ( 60 * H + m ) ) ) ) <NEWLINE> <DEDENT> elif 60 * H + m > 180 and 60 * H + m <= 360 : <NEWLINE> <INDENT> ay = a * - ( math . sin ( math . radians ( ( 1 / 2 * ( 60 * H + m ) ) - 90 ) ) ) <NEWLINE> ax = a * math . cos ( math . radians ( ( 1 / 2 * ( 60 * H + m ) ) - 90 ) ) <NEWLINE> <DEDENT> elif 60 * H + m > 360 and 60 * H + M <= 540 : <NEWLINE> <INDENT> ay = a * - ( math . sin ( math . radians ( 90 - ( ( 1 / 2 * ( 60 * H + m ) - 180 ) ) ) ) ) <NEWLINE> ax = a * - ( math . cos ( math . radians ( 90 - ( ( 1 / 2 * ( 60 * H + m ) - 180 ) ) ) ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ay = a * math . sin ( math . radians ( ( 1 / 2 * ( 60 * H + m ) - 270 ) ) ) <NEWLINE> ax = a * - ( math . cos ( math . radians ( ( 1 / 2 * ( 60 * H + m ) - 270 ) ) ) ) <NEWLINE> <NL> <DEDENT> ans = math . sqrt ( ( ax - bx ) ** 2 + ( ay - by ) ** 2 ) <NEWLINE> print ( ans ) <NEWLINE>
import sys <NEWLINE> import math <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> <COMMENT> <NL> def inp ( ) : <NEWLINE> <INDENT> return ( int ( input ( ) ) ) <NEWLINE> <DEDENT> def inlt ( ) : <NEWLINE> <INDENT> return ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <DEDENT> def insr ( ) : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> <NL> <DEDENT> def invr ( ) : <NEWLINE> <INDENT> return ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <DEDENT> def solve ( s , k ) : <NEWLINE> <INDENT> len1 = len ( s ) <NEWLINE> if len1 > k : <NEWLINE> <INDENT> corte = <STRING> <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> corte += s [ i ] <NEWLINE> <DEDENT> corte += <STRING> <NEWLINE> return corte <NEWLINE> <NL> return s <NEWLINE> <NL> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <INDENT> k = inp ( ) <NEWLINE> print ( solve ( input ( ) , k ) ) <NEWLINE> <NL> <NL> <DEDENT> main ( ) <NEWLINE> <NL> <NL>
import math <NEWLINE> A , B , H , M = map ( int , open ( 0 ) . split ( ) ) <NEWLINE> <NL> <NL> arg_b = math . pi * float ( M ) / 30 <NEWLINE> arg_a = ( math . pi / 6 ) * ( float ( H ) + float ( M ) / 60 ) <NEWLINE> K = abs ( arg_b - arg_a ) <NEWLINE> C = math . sqrt ( A * A + B * B - 2 * A * B * math . cos ( K ) ) <NEWLINE> print ( C ) <NEWLINE>
import math <NEWLINE> a = int ( input ( ) ) <NEWLINE> b = int ( input ( ) ) <NEWLINE> h = int ( input ( ) ) <NEWLINE> m = int ( input ( ) ) <NEWLINE> ans = math . sqrt ( float ( a ) ^ 2 + float ( b ) ^ 2 + 2 * a * b * math . cos ( ( h / 12 + m / 720 - m / 60 ) * math . pi ) ) <NEWLINE> print ( ans ) <NEWLINE>
def squared ( x ) : <NEWLINE> <INDENT> return x ** 2 <NEWLINE> <NL> <DEDENT> def theta ( h , m ) : <NEWLINE> <INDENT> mr = 6 * m <NEWLINE> hr = 30 * h + m / 2 <NEWLINE> r = abs ( float ( hr ) - float ( mr ) ) <NEWLINE> return r <NEWLINE> <NL> <DEDENT> def length ( a , b , h , m ) : <NEWLINE> <INDENT> return math . sqrt ( squared ( a ) + squared ( b ) - 2 * a * b * math . cos ( math . radians ( theta ( h , m ) ) ) ) <NEWLINE> <NL> <NL> <DEDENT> a , b , h , m = [ x for x in map ( int , input ( ) . split ( ) ) ] <NEWLINE> <NL> print ( length ( a , b , h , m ) ) <NEWLINE>
import math <NEWLINE> a , b , h , m = map ( int , input ( ) . split ( ) ) <NEWLINE> q = h * 30 + m * 0.5 <NEWLINE> w = m * 6 <NEWLINE> cosa = math . cos ( math . radians ( q - w ) ) <NEWLINE> print ( ( a ** 2 + b ** 2 - 2 * a * b * cos ) ** 0.5 ) <NEWLINE>
a , b , h , m = map ( int , sys . stdin . readline ( ) . rstrip ( ) . split ( ) ) <NEWLINE> m_angle = m * 6 <NEWLINE> h_angle = h * 30 + m / 2 <NEWLINE> theta = abs ( h_angle - m_angle ) <NEWLINE> if theta > 180 : theta = 360 - theta <NEWLINE> c = a ** 2 + b ** 2 - 2 * a * b * math . cos ( math . radians ( theta ) ) <NEWLINE> print ( c ** 0.5 ) <NEWLINE>
import math <NEWLINE> A , B , H , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> a = [ A * math . cos ( math . radians ( 30 * H + 0.5 * M ) , A * math . sin ( math . radians ( 30 * H + 0.5 * M ) ) ] <NEWLINE> b = [ B * math . cos ( math . radians ( M * 60 ) ) , B * math . sin ( math . radians ( M * 60 ) ) ] <NEWLINE> <COMMENT> <NL> dir = ( ( a [ 0 ] - b [ 0 ] ) ** 2 + ( a [ 1 ] - b [ 1 ] ) ** 2 ) ** 0.5 <NEWLINE> print ( dir ) <NEWLINE>
A , B , H , M = input ( ) . split ( ) <NEWLINE> <NL> A = int ( A ) <NEWLINE> B = int ( B ) <NEWLINE> H = int ( H ) <NEWLINE> M = int ( M ) <NEWLINE> <NL> kakudo_H = H * 30 + M * 0.5 <NEWLINE> kakudo_M = M * 6 <NEWLINE> if M == 0 : <NEWLINE> <INDENT> kakudo_M = 360 <NEWLINE> <NL> <DEDENT> kakudo_sa = abs ( kakudo_H - kakudo_M ) <NEWLINE> <COMMENT> <NL> c = A ** 2 + B ** 2 - 2 * A * B * ( math . cos ( math . radians ( kakudo_sa ) ) ) <NEWLINE> C = c ** 0.5 <NEWLINE> print ( C ) <NEWLINE>
import math <NEWLINE> import decimal <NEWLINE> decimal . getcontext ( ) . prec = 12 <NEWLINE> <NL> <COMMENT> <NL> a , b , h , m = map ( int , input ( ) . split ( ) ) <NEWLINE> a = decimal . Decimal ( a ) <NEWLINE> b = decimal . Decimal ( b ) <NEWLINE> h = decimal . Decimal ( h ) <NEWLINE> m = decimal . Decimal ( m ) <NEWLINE> <NL> <COMMENT> <NL> <NL> ang1 = decimal . Decimal ( 360 * ( h / 12 ) + 30 * m / 60 ) <NEWLINE> ang2 = decimal . Decimal ( 360 * m / 60 ) <NEWLINE> ang = decimal . Decimal ( abs ( ang1 - ang2 ) ) <NEWLINE> <COMMENT> <NL> if ang >= 180.0 : <NEWLINE> <INDENT> ang = ang - 180.0 <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> ans = ( ( a ) ** 2 + ( b ) ** 2 - decimal . Decimal ( 2.0 ) * ( a ) * ( b ) * decimal . Decimal ( math . cos ( math . radians ( ang ) ) ) ) <NEWLINE> ans = ( math . sqrt ( ans ) ) <NEWLINE> <COMMENT> <NL> <NL> print ( ans ) <NEWLINE>
import math <NEWLINE> a , b , h , m = map ( int , input ( ) . split ( ) ) <NEWLINE> a_S = ( 30 * h ) % 360 + 0.5 * m <NEWLINE> b_s = ( 6 * m ) <NEWLINE> <NL> s = max ( a_s , b_s ) - min ( a_s , b_s ) <NEWLINE> ans = math . sqrt ( a ** 2 + b ** 2 - 2 * a * b * math . cos ( math . radians ( s ) ) ) <NEWLINE> print ( ans ) <NEWLINE>
A , B , H , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> x = 6 * M - ( 30 * H + 0.5 * M ) <NEWLINE> print ( x ) <NEWLINE> X = 2 * math . pi * x / 360 <NEWLINE> print ( X ) <NEWLINE> print ( math . sqrt ( A ** 2 + B ** 2 - A * B * math . cos ( X ) ) ) <NEWLINE>
import math <NEWLINE> A , B , H , M = map ( int , input ( ) . split ( ) ) <NEWLINE> thetaA = ( 360 * H / 12 ) % 360 <NEWLINE> thetaB = ( 360 * M / 60 ) % 360 <NEWLINE> if theraA - thetaB <= 180 : <NEWLINE> <INDENT> theta = theraA - thetaB <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> theta = 360 - theraA - thetaB <NEWLINE> <DEDENT> print ( A * B * math . cos ( math . radians ( theta ) ) ) <NEWLINE>
import math <NEWLINE> def solve ( a , b , h , m ) : <NEWLINE> <NL> <INDENT> deg_a = math . radians ( 0.5 * ( h * 60 + m ) ) <NEWLINE> deg_b = math . radians ( 6 * m ) <NEWLINE> <NL> y_a = a * round ( math . cos ( deg_a ) , 10 ) <NEWLINE> x_a = a * round ( math . sin ( deg_a ) , 10 ) <NEWLINE> <NL> y_b = b * round ( math . cos ( deg_b ) , 10 ) <NEWLINE> x_b = b * round ( math . sin ( deg_b ) , 10 ) <NEWLINE> ans = math . sqrt ( ( x_b - x_a ) ** 2 + ( y_b - y_a ) ** 2 ) <NEWLINE> return ans <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> a , b , h , m = [ int ( i ) for i in input ( ) ] <NEWLINE> print ( solve ( a , b , h , m ) ) <NEWLINE> <DEDENT>
import math <NEWLINE> <NL> A , B , H , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <NL> if M == 0 and H == 6 : <NEWLINE> <NL> <INDENT> print ( A + B ) <NEWLINE> <NL> <DEDENT> elif M == 0 and H == 0 : <NEWLINE> <NL> <INDENT> print ( abs ( A - B ) ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <NL> <INDENT> angulo = abs ( 11 * M - 60 * H ) / 2 <NEWLINE> <NL> angulo = math . radians ( angulo ) <NEWLINE> <NL> print ( abs ( math . sqrt ( ( A ** 2 + B ** 2 ) - ( 2 * A * B * math . cos ( angulo ) ) ) ) ) <NEWLINE> <DEDENT> ~ <NEWLINE>
import math <NEWLINE> <STRING> <NEWLINE> <NL> A , B , H , M = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> theta = 2 * math . pi * H / 12 + 2 * math . pi * M * / 12 / 60 <COMMENT> <NEWLINE> phi = 2 * math . pi * M / 60 <COMMENT> <NEWLINE> <NL> deff_rad = 2 * math . pi * ( M / 60 - H / 12 ) <NEWLINE> <NL> C = math . sqrt ( A ** 2 + B ** 2 - 2 * A * B * math . cos ( deff_rad ) ) <NEWLINE>
import numpy as np <NEWLINE> A = int ( input ( ) ) <NEWLINE> B = int ( input ( ) ) <NEWLINE> H = int ( input ( ) ) <NEWLINE> M = int ( input ( ) ) <NEWLINE> <NL> pai = 3.14 <NEWLINE> angle = 2 * pai * ( H / 12 - M / 60 ) <NEWLINE> <NL> distance = np . sqrt ( A ** 2 + B ** 2 - 2 * A * B * np . cos ( angle ) ) <NEWLINE> print ( distance ) <NEWLINE>
import math <NEWLINE> A , B , H , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> pai = math . pi <NEWLINE> <NL> <COMMENT> <NL> angle = 2 * pai * ( ( H + M / 60 ) / 12 - M / 60 ) <NEWLINE> <NL> <COMMENT> <NL> distance = np . sqrt ( A ** 2 + B ** 2 - 2 * A * B * math . cos ( angle ) ) <NEWLINE> print ( distance ) <NEWLINE>
import sys <NEWLINE> import math <NEWLINE> <NL> a , b , h , m = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if h == 0 and m == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> angle_h = ( h * 60 + m ) * ( 360 / 12 / 60 ) <NEWLINE> angle_m = m * ( 360 / 60 ) <NEWLINE> <NL> radian = math . radians ( angle ) <NEWLINE> cosine = math . cos ( radian ) <NEWLINE> ans = a * a + b * b - 2 * a * b * cosine <NEWLINE> ans = math . sqrt ( ans ) <NEWLINE> <NL> print ( ans ) <NEWLINE>
<COMMENT> <NL> import math <COMMENT> <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> mod = 998244353 <NEWLINE> INF = 1 << 29 <NEWLINE> lINF = 1 << 35 <NEWLINE> <NL> def readInt ( ) : <NEWLINE> <INDENT> return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> a , b , h , m = readInt ( ) <NEWLINE> <COMMENT> <NL> r1 = h * 30 + ( m / 60 ) * v1 <NEWLINE> r2 = m * 6 <NEWLINE> r = abs ( r1 - r2 ) <NEWLINE> if r > 180 : <NEWLINE> <INDENT> r = 360 - r <NEWLINE> <COMMENT> <NL> <DEDENT> ans = math . sqrt ( a * a + b * b - 2 * a * b * math . cos ( math . radians ( r ) ) ) <NEWLINE> print ( ans ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
A , B , H , M = map ( int , input ( ) . split ( ) ) <NEWLINE> w_a = 2 * pi / ( 12 * 60.0 ) <NEWLINE> w_b = 2 * pi / ( 60.0 ) <NEWLINE> theta_a = w_a * ( H * 60 + M ) <NEWLINE> theta_b = w_b * M <NEWLINE> ans = sqrt ( A ** 2 + B ** 2 - 2 * A * B * cos ( theta_a - theta_b ) ) <NEWLINE> print ( <STRING> . format ( ans ) ) <NEWLINE>
import math <NEWLINE> <NL> a , b , h , m = map ( int , input ( ) ) <NEWLINE> angle = 30 * h - 6 * m <NEWLINE> if ( angle >= 180 ) : <NEWLINE> <INDENT> angle = 360 - angle <NEWLINE> <NL> <DEDENT> print ( a ** 2 + b ** 2 - 2 * a * b * math . cos ( angle ) ) <NEWLINE>
import math <NEWLINE> inlist = input ( <STRING> ) . split ( <STRING> ) <NEWLINE> a = int ( inlist [ 0 ] ) <NEWLINE> b = int ( inlist [ 1 ] ) <NEWLINE> h = int ( inlist [ 2 ] ) <NEWLINE> m = int ( inlist [ 3 ] ) <NEWLINE> sita1 = h * 30 + 0.5 * m <NEWLINE> sita2 = h * 6 <NEWLINE> sita = sita1 - sita2 <NEWLINE> d = a ** 2 + b ** 2 - 2 * a * b * math . cos ( math . radius ( sita ) ) <NEWLINE> e = int ( math . sqrt ( d ) ) <NEWLINE> print ( e ) <NEWLINE>
import math <NEWLINE> <NL> class Watch ( ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> <NL> def __init__ ( self , length_of_hour_hand , length_of_minute_hand , <NEWLINE> <INDENT> hours , minutes ) : <NEWLINE> <STRING> <NEWLINE> self . length_of_hour_hand = length_of_hour_hand <NEWLINE> self . length_of_minute_hand = length_of_minute_hand <NEWLINE> self . hours = hours <NEWLINE> self . minutes = minutes <NEWLINE> self . angle_between_two_hands = None <NEWLINE> self . distance_between_two_hands = None <NEWLINE> <NL> <DEDENT> def calculate_angle_between_two_hands ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> <NL> <COMMENT> <NL> degrees_of_hour_hand = ( ( ( self . hours + self . minutes / 60. ) / 12. ) <NEWLINE> <INDENT> * 2. * math . pi ) <NEWLINE> <COMMENT> <NL> <DEDENT> degrees_of_minute_hand = ( self . minutes / 60. ) * 2. * math . pi <NEWLINE> <NL> <COMMENT> <NL> angle_between_two_hands = ( degrees_of_hour_hand <NEWLINE> <INDENT> - degrees_of_minute_hand ) <NEWLINE> <NL> <DEDENT> self . angle_between_two_hands = angle_between_two_hands <NEWLINE> <NL> <DEDENT> def calculate_distance_between_two_hands ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> <NL> self . distance_between_two_hands = math . sqrt ( <NEWLINE> <INDENT> self . length_of_hour_hand ** 2 + self . length_of_minute_hand ** 2 <NEWLINE> - 2 * self . length_of_hour_hand * self . length_of_minute_hand <NEWLINE> * math . cos ( self . angle_between_two_hands ) ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> A , B , H , M = [ int ( s ) for s in input ( ) . split ( <STRING> ) ] <NEWLINE> <NL> watch = Watch ( A , B , H , M ) <NEWLINE> watch . calculate_angle_between_two_hands ( ) <NEWLINE> watch . calculate_distance_between_two_hands ( ) <NEWLINE> print ( watch . distance_between_two_hands <NEWLINE>
A , B , H , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> X , Y = A * math . cos ( math . pi * ( 60 * H + M ) / 360 ) , - A * math . sin ( math . pi * ( 60 * H + M ) / 360 ) <NEWLINE> x , y = B * math . cos ( math . pi * M / 30 ) , - B * math . sin ( math . pi * M / 30 ) <NEWLINE> <NL> print ( math . sqrt ( ( X - x ) ** 2 + ( Y - y ) ** 2 ) ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> AB = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( M ) ] <NEWLINE> <NL> count = [ 0 ] * ( N + 1 ) <NEWLINE>
a , b , h , m = map ( int , input ( ) . split ( ) ) import math <NEWLINE> a , b , h , m = map ( int , input ( ) . split ( ) ) <NEWLINE> a_x = math . cos ( math . radians ( 30 * h + 0.5 * m ) ) <NEWLINE> a_y = math . sin ( math . radians ( 30 * h + 0.5 * m ) ) <NEWLINE> b_x = math . cos ( math . radians ( 60 * m ) ) <NEWLINE> b_y = math . sin ( math . radians ( 60 * m ) ) <NEWLINE> print ( ( abs ( a * a_x - b * b_x ) ** 2 + abs ( a * a_y - b * b_y ) ** 2 ) ** 0.5 ) <NEWLINE>
import math <NEWLINE> <NL> a b h m = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> deg = 30 * h - 6 * m <NEWLINE> if deg < 0 : <NEWLINE> <INDENT> deg += 360 <NEWLINE> <DEDENT> elif deg > 180 : <NEWLINE> <INDENT> deg = 360 - deg <NEWLINE> <NL> <DEDENT> cos = math . cos ( math . radian ( deg ) ) <NEWLINE> c_2 = a * a + b * b - 2 * a * b * cos <NEWLINE> print ( math . sqrt ( c_2 ) ) <NEWLINE>
import math <NEWLINE> from math import pi , sqrt , sin , cos <NEWLINE> <NL> A = int ( input ( ) ) <NEWLINE> B = int ( input ( ) ) <NEWLINE> H = int ( input ( ) ) <NEWLINE> M = int ( input ( ) ) <NEWLINE> <NL> theta_H = H / 12 * 2 * pi <NEWLINE> theta_M = M / 60 * 2 * pi <NEWLINE> <NL> D = sqrt ( ( A * cos ( theta_H ) - B * cos ( theta_M ) ) ** 2 + ( A * sin ( theta_H ) - B * sin ( theta_M ) ) ** 2 ) <NEWLINE> <NL> print ( D ) <NEWLINE>
a , b , h , m = map ( int , input ( ) . split ( ) ) <NEWLINE> import math <NEWLINE> vx = 2 * math . pi / ( 12 * 60 ) <NEWLINE> vy = 2 * math . pi / 60 <NEWLINE> <NL> x = vx * ( 60 * h + m ) <NEWLINE> y = vy * m <NEWLINE> <NL> d = abs ( x - y ) <NEWLINE> z = a ** 2 + b ** 2 - 2 * a * b * math . cos ( d ) <NEWLINE> z = math . sqrt ( z ) <NEWLINE> print ( zf ) <NEWLINE>
import math <NEWLINE> <NL> a , b , h , m = map ( int , input ( ) . split ( ) ) <NEWLINE> ang_a = 360 * h / 12 <NEWLINE> ang_b = 360 * m / 60 <NEWLINE> s_a = 0 <NEWLINE> s_b = 0 <NEWLINE> <NL> while ang_a - 90 > 0 : <NEWLINE> <INDENT> ang_a -= 90 <NEWLINE> s_a += 1 <NEWLINE> <DEDENT> while ang_b - 90 > 0 : <NEWLINE> <INDENT> ang_b -= 90 <NEWLINE> s_b += 1 <NEWLINE> <NL> <NL> <DEDENT> def ppp ( xx , yy , s ) : <NEWLINE> <INDENT> if s == 0 : <NEWLINE> <INDENT> return map ( int , xx , yy ) <NEWLINE> <DEDENT> elif s == 1 : <NEWLINE> <INDENT> return map ( int , xx , - yy ) <NEWLINE> <DEDENT> elif s == 2 : <NEWLINE> <INDENT> return map ( int , - xx , - yy ) <NEWLINE> <DEDENT> elif s == 3 : <NEWLINE> <INDENT> return map ( int , - xx , yy ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return map ( int , [ 0 , 0 ] ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> x_a = math . cos ( ang_a ) <NEWLINE> y_a = math . sin ( ang_a ) <NEWLINE> y_b = math . cos ( ang_b ) <NEWLINE> x_b = math . sin ( ang_b ) <NEWLINE> <NL> x_a , y_a = ppp ( x_a , y_a , s_a ) <NEWLINE> x_b , y_b = ppp ( x_b , y_b , s_b ) <NEWLINE> x = abs ( x_a , x_b ) <NEWLINE> y = abs ( y_a , y_b ) <NEWLINE> ans_r = math . sqrt ( x ) + math . sqrt ( y ) <NEWLINE> ans = math . sqrt ( ans_r ) <NEWLINE> print ( ans ) <NEWLINE>
import numpy as np <NEWLINE> <NL> A , B , H , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> th_a = 30 * H <NEWLINE> th_b = 6 * M <NEWLINE> <NL> theta = th_a - th_b <NEWLINE> <NL> if theta <= 0 : <NEWLINE> <INDENT> theta = - theta <NEWLINE> <NL> <DEDENT> if theta == 0 : <NEWLINE> <INDENT> if A >= B : <NEWLINE> <INDENT> print ( A - B ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( B - A ) <NEWLINE> <NL> <DEDENT> <DEDENT> elif theta == 180 : <NEWLINE> <INDENT> print ( A + B ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> print ( np . sqrt ( A ** 2 + B ** 2 - 2 * A * B * cos ( theta ) ) ) <NEWLINE> <DEDENT>
import math <NEWLINE> A , B , H , M = map ( int , input ( ) . split ( ) ) <NEWLINE> a = math . pi <NEWLINE> b = math . cos ( a * ( ( 60 * H - 11 M ) / 360 ) ) <NEWLINE> Z = A ** 2 + B ** 2 - 2 * A * B * b <NEWLINE> print ( Z ** ( 1 / 2 ) ) <NEWLINE>
import math <NEWLINE> t = input ( ) . split ( ) <NEWLINE> t = [ int ( i ) for i in t ] <NEWLINE> r = math . sqrt ( t [ 0 ] * t [ 0 ] + t [ 1 ] * t [ 1 ] ) <NEWLINE> h = t [ 2 ] <NEWLINE> m = t [ 3 ] <NEWLINE> if ( h == 12 ) : <NEWLINE> <INDENT> h = 0 <NEWLINE> <DEDENT> if ( m == 60 ) : <NEWLINE> <INDENT> m = 0 <NEWLINE> <DEDENT> hour_angle = 0.5 * ( h * 60 + m ) <NEWLINE> minute_angle = 6 * m <NEWLINE> angle = abs ( hour_angle - minute_angle ) <NEWLINE> angle = min ( 360 - angle , angle ) <NEWLINE> print ( math . sqrt ( r * r - 2 * t [ 0 ] t [ 1 ] * math . cos ( angle ( 2 * math . pi / 360 ) ) ) ) <NEWLINE>
<NL> import math <NEWLINE> <NL> a = int ( input ( ) ) <NEWLINE> b = int ( input ( ) ) <NEWLINE> h = int ( input ( ) ) <NEWLINE> m = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> <NL> m_r = m / 5 <NEWLINE> <COMMENT> <NL> h_r = h + m / 60 <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> reg = ( h_r - m_r ) / 12 * 360 <NEWLINE> ans = math . sqrt ( a ** 2 + b ** 2 - 2 * a * b * math . cos ( math . radians ( reg ) ) ) <NEWLINE> <NL> print ( ans ) <NEWLINE>
import math <NEWLINE> def : <NEWLINE> <INDENT> A B H M = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> if H > M / 5 : <NEWLINE> <INDENT> angle = ( H / 12 - M / 60 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> angle = ( M / 60 - H / 12 ) <NEWLINE> t = math . cos ( math . pi * angle ) <NEWLINE> d = ( A ^ 2 + B ^ 2 - 2 AB * t ) ^ 0.5 <NEWLINE> print ( d ) <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <NL> import math , sys <NEWLINE> if sys . version_info [ 0 ] < 3 : input = raw_input <NEWLINE> <NL> class StandardInput : <NEWLINE> <NL> <INDENT> def stdin_string ( self ) : <NEWLINE> <INDENT> self . s = str ( input ( ) . rstrip ( ) ) <NEWLINE> return self . s <NEWLINE> <NL> <DEDENT> def stdin_integer ( self ) : <NEWLINE> <INDENT> self . n = int ( input ( ) . rstrip ( ) ) <NEWLINE> return self . n <NEWLINE> <NL> <DEDENT> def stdin_array ( self ) : <NEWLINE> <INDENT> self . arr = input ( ) . rstrip ( ) . split ( ) <NEWLINE> return self . arr <NEWLINE> <NL> <DEDENT> def stdin_integer_array ( self ) : <NEWLINE> <INDENT> self . arr = list ( map ( int , input ( ) . rstrip ( ) . split ( ) ) ) <NEWLINE> return self . arr <NEWLINE> <NL> <DEDENT> <DEDENT> def test ( arr ) : <NEWLINE> <INDENT> a , b , h , m = arr <NEWLINE> ar = 2 * math . pi * ( h / 12 + m / 60 / 12 ) <NEWLINE> br = 2 * math . pi * ( m / 60 ) <NEWLINE> return math . sqrt ( ( a * math . cos ( ar ) - b * math . cos ( br ) ) ** 2 + ( a * math . sin ( ar ) - b * math . sin ( br ) ) ** 2 ) <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> obj = StandardInput ( ) <NEWLINE> arr = obj . stdin_integer_array ( ) <NEWLINE> s = obj . stdin_string ( ) <NEWLINE> print ( test ( arr ) ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
md = m / 60 * 360 <NEWLINE> <NL> bx = math . sin ( math . radians ( md ) ) * b <NEWLINE> by = math . cos ( math . radians ( md ) ) * b <NEWLINE> <NL> hd = h / 12 * 360 + m / 60 * 30 <NEWLINE> <NL> ax = math . sin ( math . radians ( hd ) ) * a <NEWLINE> ay = math . cos ( math . radians ( hd ) ) * a <NEWLINE> <NL> ans = math . sqrt ( ( ax - bx ) ** 2 + ( by - ay ) ** 2 ) <NEWLINE> print ( ans ) <NEWLINE>
<NL> <COMMENT> <NL> A , B , H , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <COMMENT> <NL> A_RAD = float ( ( H * 60 + M ) / 720 * 2 * math . pi ) <NEWLINE> B_RAD = float ( M / 60 * 2 * math . pi ) <NEWLINE> AB_RAD = A_RAD - B_RAD <NEWLINE> <NL> C = math . sqrt ( A ** 2 + B ** 2 - 2 * A * B * math . cos ( AB_RAD ) ) <NEWLINE> <NL> print ( C ) <NEWLINE>
import math <NEWLINE> <NL> a , b , h , m = [ int ( input ( ) ) for i in range ( 4 ) ] <NEWLINE> <NL> m_rad = 6 * m <NEWLINE> h_rad = 0.5 * 60 * h + 0.5 * m <NEWLINE> <NL> if abs ( m_rad - h_rad ) == 0 : <NEWLINE> <INDENT> print ( b - a ) <NEWLINE> <DEDENT> elif abs ( m_rad - h_rad ) == 180 : <NEWLINE> <INDENT> print ( a + b ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( math . sqrt ( a * a + b * b - 2 * a * b * math . cos ( math . radians ( abs ( m_rad - h_rad ) ) ) ) ) <NEWLINE> <DEDENT>
import sys <NEWLINE> import math <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> a = int ( input ( ) ) <NEWLINE> b = int ( input ( ) ) <NEWLINE> h = int ( input ( ) ) <NEWLINE> m = int ( input ( ) ) <NEWLINE> <NL> kak1 = float ( h * 30 + m * 0.5 ) <NEWLINE> kak2 = m * 6 <NEWLINE> <NL> kaku = kak1 - kak2 if kak1 < kak2 else kak2 - kak1 <NEWLINE> result = a * a + b * b - 2 * a * b * math . cos ( kaku * math . pi / 180 ) <NEWLINE> print ( math . sqrt ( result ) ) <NEWLINE>
A , B , H , M = map ( float , input ( ) . split ( ) ) <NEWLINE> <NL> import math <NEWLINE> <NL> degreeA = float ( ( H * 60 + M ) / 2 ) <NEWLINE> degreeB = float ( M * 6 ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> else : <NEWLINE> <INDENT> degreeAB = abs ( degreeA - degreeB ) <NEWLINE> if degreeAB == 180 : <NEWLINE> <INDENT> print ( A + B ) <NEWLINE> <DEDENT> elif degreeAB > 180 : <NEWLINE> <INDENT> degreeAB = 360 - degreeAB <NEWLINE> <DEDENT> C = float ( A ** 2 + B ** 2 - 2 * A * B * float ( math . cos ( float ( degreeAB * math . pi / 180 ) ) ) ) <NEWLINE> print ( math . sqrt ( C ) ) <NEWLINE> <DEDENT>
import math as m <NEWLINE> a , b , h , m = map ( int , input ( ) . split ( ) ) <NEWLINE> hd = h * 30 <NEWLINE> md = m * 6 <NEWLINE> hd += md // 12 <NEWLINE> d = abs ( hd - md ) <NEWLINE> cd = m . cos ( d * m . pi // 180 ) <NEWLINE> print ( round ( m . sqrt ( a * a + b * b - 2 * a * b * cd ) ) , 20 ) <NEWLINE>
import math <NEWLINE> <NL> Line = [ int ( s ) for s in input ( ) . split ( ) ] <NEWLINE> <NL> A , B , H , M = Line [ 0 ] , Line [ 1 ] , Line [ 2 ] , Line [ 3 ] <NEWLINE> <NL> <COMMENT> <NL> <NL> kakudo = abs ( H / 12 * 360 + M / 12 / 60 * 360 - M / 60 * 360 ) <NEWLINE> <NL> if kakudo > 180 : <NEWLINE> <INDENT> kakudo = 360 - kakudo <NEWLINE> <NL> <COMMENT> <NL> <NL> <DEDENT> ans = math . sqrt ( A ** 2 + B ** 2 - 2 * A * B * round ( math . cos ( round ( math . radians ( kakudo ) , 100 ) , 100 ) ) <NEWLINE> <NL> print ( ans ) <NEWLINE>
import math <NEWLINE> <NL> def radi ( n ) : <NEWLINE> <INDENT> return n * math . pi / 180 <NEWLINE> <NL> <DEDENT> def resolve ( ) : <NEWLINE> <INDENT> a , b , h , m = map ( int , input ( ) . split ( ) ) <NEWLINE> hd = radi ( h * 30 + 30 * ( m / 60 ) ) <NEWLINE> md = radi ( 360 * ( m / 60 ) ) <NEWLINE> hx = a * math . cos ( hd ) <NEWLINE> hy = a * math . sin ( hd ) <NEWLINE> mx = b * math . cos ( md ) <NEWLINE> my = b * math . sin ( md ) <NEWLINE> x = abs ( hx - mx ) <NEWLINE> y = abs ( hy - my ) <NEWLINE> v = math . sqrt ( x ** 2 + y ** 2 ) <NEWLINE> print ( v ) <NEWLINE> <DEDENT> rseolve ( ) <NEWLINE>
import math <NEWLINE> a , b , h , m = map ( int , input ( ) . split ( ) ) <NEWLINE> long_needle = ( 5 * m ) / 60 + h * 5 <NEWLINE> sort_needle = m <NEWLINE> ans = math . sqrt ( a ** 2 + b ** 2 - 2 * a * b * abs ( math . cos ( abs ( math . pi * ( long_needle - sort_needle ) ) / 30 ) ) <NEWLINE> print ( ans ) <NEWLINE>
import math <NEWLINE> tan = int ( input ( ) ) <NEWLINE> chou = int ( input ( ) ) <NEWLINE> ji = int ( input ( ) ) <NEWLINE> hun = int ( input ( ) ) <NEWLINE> <NL> kakudo = abs ( ( ( ji * 30 + hun * .5 ) - ( hun * 6 ) ) ) <NEWLINE> <NL> if kakudo > 180 : <NEWLINE> <INDENT> kakudo = kakudo - 360 <NEWLINE> <DEDENT> kakudo = abs ( math . cos ( math . radians ( kakudo ) ) ) <NEWLINE> ans = ( chou ** 2 + tan ** 2 - 2 * chou * tan * kakudo ) ** .5 <NEWLINE> print ( ans ) <NEWLINE>
from decimal import Decimal <NEWLINE> import math <NEWLINE> a , b , h , m = map ( int , input ( ) . split ( ) ) <NEWLINE> angh = ( h / 12 ) * 360 + ( m / 60 ) * 30 <NEWLINE> angm = ( m / 60 ) * 360 <NEWLINE> <COMMENT> <NL> ang = abs ( angh - angm ) <NEWLINE> ang = min ( 360 - ang , ang ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> if ang == 0 : print ( 0 ) ; exit ( ) <NEWLINE> print ( <STRING> . format ( Decimal ( ( a * a + b * b - 2 * a * b * math . cos ( Decimal ( math . radians ( ang ) ) ) ) . sqrt ( ) ) ) ) <NEWLINE> <NL>
import math <NEWLINE> A B H M = map ( int , input ( ) . split ( ) ) <NEWLINE> Mkaku = 6 * M <NEWLINE> Hkaku = ( H * 60 + M ) / 2 <NEWLINE> r1 = Hkaku * math . pi / 180 <NEWLINE> r2 = Mkaku * math . pi / 180 <NEWLINE> v1x = A * math . cos ( r1 ) <NEWLINE> v1y = A * math . sin ( r1 ) <NEWLINE> v2x = B * math . cos ( r2 ) <NEWLINE> v2y = B * math . sin ( r2 ) <NEWLINE> ans = ( ( v1x - v2x ) ** 2 + ( v1y - v2y ) ** 2 ) ** 1 / 2 <NEWLINE> print ( ans ) <NEWLINE>
a , b , h , m = map ( float , input ( ) . split ( ) ) <NEWLINE> <COMMENT> <NL> c = ( 30 * h - 11 / 2 * m ) <NEWLINE> ct = math . radians ( c ) <NEWLINE> cos = math . cos ( ct ) <NEWLINE> ans = a ** 2 + b ** 2 - 2 * a * b * abs ( cos ) <NEWLINE> print ( math . sqrt ( ans ) ) <NEWLINE>
import math <NEWLINE> <NL> a , b , h , m = map ( int , input ( ) . split ( ) ) <NEWLINE> h1 = h * 30 <NEWLINE> m1 = m * 5.5 <NEWLINE> r = abs ( h1 - m1 ) <NEWLINE> a1 = a ** 2 <NEWLINE> b1 = b ** 2 <NEWLINE> ab = a * b <NEWLINE> if r == 0 : <NEWLINE> <INDENT> print ( abs ( a - b ) ) <NEWLINE> <DEDENT> elif r == 180 : <NEWLINE> <INDENT> print ( a + b ) <NEWLINE> <DEDENT> elif 180 < r : <NEWLINE> <INDENT> r1 = r - 180 <NEWLINE> cos = math . cos ( math . radians ( r1 ) ) <NEWLINE> d = a1 + b1 - 2 * ab * cos <NEWLINE> ans = d ** ( 1 / 2 ) <NEWLINE> print ( ans ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cos = math . cos ( math . radians ( r ) ) <NEWLINE> d = a1 + b1 - 2 * ab * cos <NEWLINE> ans = d ** ( 1 / 2 ) <NEWLINE> print ( ans ) <NEWLINE> <DEDENT>
a , b , h , m = map ( int , input ( ) . split ( ) ) <NEWLINE> ax = a * math . cos ( math . radians ( ( h / 12 + 1 / 12 * m / 60 ) * 360 ) ) <NEWLINE> ay = a * math . sin ( math . radians ( ( h / 12 + 1 / 12 * m / 60 ) * 360 ) ) <NEWLINE> bx = b * math . cos ( math . radians ( m / 60 * 360 ) ) <NEWLINE> by = b * math . sin ( math . radians ( m / 60 * 360 ) ) <NEWLINE> print ( math . sqrt ( ( ax - bx ) ** 2 + ( ay - by ) ** 2 ) ) <NEWLINE>
import math <NEWLINE> <NL> a = int ( input ( ) ) <NEWLINE> b = int ( input ( ) ) <NEWLINE> h = int ( input ( ) ) <NEWLINE> m = int ( input ( ) ) <NEWLINE> t = 360 * h + m / 60 - 30 * h - m / 720 <NEWLINE> ans2 = a ** 2 + b ** 2 - math . cos ( math . radians ( t ) ) <NEWLINE>
import math <NEWLINE> param = list ( map ( int , input ( ) ) ) <NEWLINE> a = param [ 0 ] <NEWLINE> b = param [ 1 ] <NEWLINE> h = param [ 2 ] <NEWLINE> m = param [ 3 ] <NEWLINE> hrad = ( h / 12 ) * 360 + ( m / 60 ) * 30 <NEWLINE> mrad = ( m / 60 ) * 360 <NEWLINE> rad = hrad - mrad <NEWLINE> print ( rad ) <NEWLINE> if rad < 0 : <NEWLINE> <INDENT> rad = - rad <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if rad > 180 : <NEWLINE> <INDENT> rad = 360 - rad <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> <DEDENT> print ( rad ) <NEWLINE> c = float ( ( a ** 2 + b ** 2 - 2 * a * b * math . cos ( math . radians ( rad ) ) ) ** ( 0.5 ) ) <NEWLINE> print ( c ) <NEWLINE>
import math <NEWLINE> <NL> A , B , H , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> dighour : float = 360 * ( ( H + M / 60 ) / 12 ) <NEWLINE> digmin : float = 360 * ( M / 60 ) <NEWLINE> length : float = 0 <NEWLINE> <NL> deg = abs ( dighour - digmin ) <NEWLINE> <NL> length = A ** 2 + B ** 2 - 2 * A * B math . cos ( math . radians ( deg ) ) <NEWLINE> <NL> <STRING> <NEWLINE> <NL> print ( length ) <NEWLINE>
A = int ( input ( ) ) <NEWLINE> B = int ( input ( ) ) <NEWLINE> H = int ( input ( ) ) <NEWLINE> M = int ( input ( ) ) <NEWLINE> <NL> import math <NEWLINE> <NL> time = H * 60 + M <NEWLINE> dist = ( 5.5 * time ) % 360 <NEWLINE> if 0 < dist < 180 : <NEWLINE> <INDENT> dist = 360 - dist <NEWLINE> <NL> <DEDENT> ans = math . sqrt ( A * A + B * B - 2 * A * B * math . cos ( math . radians ( dist ) ) ) <NEWLINE> <NL> print ( ans ) <NEWLINE>
import math as m <NEWLINE> a , b , h , m = map ( int , input ( ) . split ( ) ) <NEWLINE> diff_hm = abs ( h * 30 - m * 60 ) <NEWLINE> print ( math . sqrt ( a ** 2 + b ** 2 - 2 * a * b * math . cos ( math . radians ( diff_hm ) ) ) ) <NEWLINE>
import math <NEWLINE> A , B , H , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> t = ( H + ( M / 60 ) ) * math . pi / 6 <NEWLINE> m = ( M / 60 ) * 2 * math . pi <NEWLINE> totalangle = m - t <NEWLINE> result = sqrt ( A ** 2 + B ** 2 - 2 * A * B * math . cos ( totalangle ) ) <NEWLINE> print ( result ) <NEWLINE>
import math <NEWLINE> a , b , h , m = map ( int , input ( ) . split ( ) ) <NEWLINE> angle = abs ( m * 6 - ( h * 30 + m / 60 * 30 ) ) <NEWLINE> print ( math . sqrt ( a * a + b * b - 2 * a * b * math . cos ( angle / 180 * pi ) ) ) <NEWLINE>
A , B , H , M = map ( float , input ( ) . split ( ) ) <NEWLINE> <NL> m_theta = ( M / 60.0 ) * 2 * pi <NEWLINE> h_theta = 1 / 12.0 * ( H + M / 60.0 ) * 2 * pi <NEWLINE> mh_theta = abs ( m_theta - h_theta ) <NEWLINE> <NL> x = A ** 2 + B ** 2 - 2 * A * B * cos ( mh_theta ) <NEWLINE> x = sqrt ( x ) <NEWLINE> print ( x ) <NEWLINE>
import math <NEWLINE> <NL> a , b , h , m = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> <NL> h_a = h * 30 <NEWLINE> m_a = m * 6 <NEWLINE> angle = abs ( h_a - m_a ) <NEWLINE> if angle > 180 : <NEWLINE> <INDENT> angle = 360 - angle <NEWLINE> <NL> <DEDENT> if angle == 0 : <NEWLINE> <INDENT> ans = abs ( a - b ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> angle = angle * np . pi / 180 <NEWLINE> ans = math . sqrt ( a ** 2 + b ** 2 - 2 * a * b * math . cos ( angle ) ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> import numpy <NEWLINE> <NL> A , B , H , M = input . split ( ) <NEWLINE> <NL> theta = abs ( int ( H ) * 30 - int ( M ) * 6 ) <NEWLINE> cos = math . cos ( math . radians ( theta ) ) <NEWLINE> <NL> res = math . sqrt ( int ( A ) ** 2 + int ( B ) ** 2 - 2 * int ( A ) * int ( B ) * cos ) <NEWLINE> print ( res ) <NEWLINE>
import sys <NEWLINE> import math <NEWLINE> <NL> def resolve ( ) : <NEWLINE> A , B , H , M = map ( int , sys . stdin . readline ( ) . split ( ) ) <NEWLINE> theta = ( H * 30 + M * 0.5 ) - ( M * 6 ) <NEWLINE> ans = math . sqrt ( ( A ** 2 + B ** 2 ) - ( 2 * A * B ) * math . cos ( math . radians ( theta ) ) ) <NEWLINE> print ( <STRING> . format ( ans ) ) <NEWLINE>
a , b , h , m = input ( ) . split ( ) <NEWLINE> <NL> a , b , h , m = int ( a , b , h , m ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> min = ( 60 * h ) + m <NEWLINE> ang0 = ( min * 5.5 ) % 360 <NEWLINE> <NL> if ang0 <= 180 : <NEWLINE> <INDENT> ang = ang0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ang = 360 - ang0 <NEWLINE> <NL> <DEDENT> import math <NEWLINE> cos_ang = math . cos ( math . radians ( ang ) ) <NEWLINE> <NL> x = math . sqrt ( ( a ** 2 ) + ( b ** 2 ) - ( 2 * a * b * cos_ang ) ) <NEWLINE> <NL> print ( x ) <NEWLINE>
import sys <NEWLINE> from math import exp , pi <NEWLINE> <NL> read = sys . stdin . buffer . read <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> readlines = sys . stdin . buffer . readlines <NEWLINE> <NL> A , B , H , M = map ( int , read ( ) . split ( ) ) <NEWLINE> <NL> H += M / 60 <NEWLINE> <NL> t1 = 2 * pi * H / 12 <NEWLINE> t2 = 2 * pi * H <NEWLINE> <NL> z1 = A * exp ( t1 * 1j ) <NEWLINE> z2 = B * exp ( t1 * 1j ) <NEWLINE> <NL> print ( abs ( z1 - z2 ) ) <NEWLINE>
a , b , H , M = map ( int , input ( ) . rstrip ( ) . split ( ) ) <NEWLINE> if H == 0 and M == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> aH = H * 5 + ( float ( M ) / 60 * 5 ) <NEWLINE> kakudo = abs ( aH - M ) <NEWLINE> kakudo *= 6 <NEWLINE> decimal . getcontext ( ) . prec = 5 <NEWLINE> val = math . sqrt ( float ( a * a ) + float ( b * b ) - 2 * a * b * math . cos ( math . radians ( kakudo ) ) ) <NEWLINE> val = decimal . Decimal ( val ) <NEWLINE> print ( val ) <NEWLINE> <COMMENT> <NL> <DEDENT>
import math <NEWLINE> A , B , H , M = int ( input ( ) . split ( ) ) <NEWLINE> Ad = H * 30 + M * 0.5 <NEWLINE> Bd = M * 6 <NEWLINE> difAB = abs ( Ad - Bd ) <NEWLINE> if difAB >= 180 : <NEWLINE> <INDENT> difAB = 360 - difAB <NEWLINE> <DEDENT> print ( math . sqrt ( A ** 2 + B ** 2 - 2 * A * B * math . cos ( math . radians ( difAB ) ) ) ) <NEWLINE>
from math import cos <NEWLINE> A , B , H , M = map ( int , input ( ) . split ( ) ) <NEWLINE> t = 30 * A - 6 * B <NEWLINE> print ( ( A ** 2 + B ** 2 - 2 * a * b * cos ( t ) ** .5 ) <NEWLINE>
<COMMENT> <NL> import numpy as np <NEWLINE> from math import * <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> A , B , H , M = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> pai = 3.1415926535897323846264338327950 <NEWLINE> kakuH = H * 360 / 12 + M * 30 / 60 <NEWLINE> kakuM = M * 360 / 60 <NEWLINE> kakuS = kakuH - kakuM <NEWLINE> <COMMENT> <NL> ans = ( A ** 2 + B ** 2 - 2 * A * B * np . cos ( kakuS * pai / 180 ) ) ) ** ( 1 / 2 ) <NEWLINE> <NL> return ans <NEWLINE> <NL> <DEDENT> def absolute ( a , b ) : <NEWLINE> <INDENT> if a >= b : <NEWLINE> <INDENT> if a - b > 180 : <NEWLINE> <INDENT> return 360 - ( a - b ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return a - b <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if b - a > 180 : <NEWLINE> <INDENT> return 360 - ( b - a ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return b - a <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <COMMENT> <NL> <INDENT> print ( main ( ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NEWLINE> <DEDENT>
import math <NEWLINE> a , b , h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> deg_a = 6 * m <NEWLINE> deg_b = 30 * h + m / 2 <NEWLINE> deg_c = abs ( ( deg_a ) - ( deg_b ) ) <NEWLINE> rad = math . radians ( deg_c ) <NEWLINE> c ** 2 = a ** 2 + b ** 2 - 2 * a * b * math . cos ( rad ) <NEWLINE> print ( c ** 0.5 ) <NEWLINE>
import math <NEWLINE> a , b , h , m = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( a ** 2 + b ** 2 - 2 * a * b * math . cos ( math . radians ( h * 30 - m * 5.5 ) ) ) ** 0.5 <NEWLINE>
mport numpy as np <NEWLINE> import math <NEWLINE> <NL> A , B , H , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> d = np . sqrt ( ( B * math . cos ( 6 * M ) - A * math . cos ( 30 * H + M / 2 ) ) ** 2 + ( B * math . sin ( 6 * M ) - A * math . sin ( 30 * H + M / 2 ) ) ** 2 ) <NEWLINE> print ( d ) <NEWLINE>
import math <NEWLINE> theta_S = 30 * H + ( 1 / 10 ) * M <NEWLINE> theta_L = 6 * M <NEWLINE> S_x = A * math . sin ( math . radians ( theta_S ) ) <NEWLINE> S_y = A * math . cos ( math . radians ( theta_S ) ) <NEWLINE> L_x = B * math . sin ( math . radians ( theta_L ) ) <NEWLINE> L_y = B * math . cos ( math . radians ( theta_L ) ) <NEWLINE> distance = ( ( S_x - L_x ) ** 2 + ( S_y - L_y ) ** 2 ) ** 0.5 <NEWLINE> print ( distance ) <NEWLINE>
A , B , H , M = map ( float , input ( ) . split ( ) ) <NEWLINE> pi = math . pi <NEWLINE> Ak = 360 * H / 12 + 360 / 12 * M / 60 <NEWLINE> Bk = 360 * M / 60 <NEWLINE> Ak = Ak / 180 * pi <NEWLINE> Bk = Bk / 180 * pi <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> ans = A * A + B * B - 2 * A * B * math . cos ( Ak - Bk ) <NEWLINE> print ( math . sqrt ( ans ) ) <NEWLINE>
import math <NEWLINE> a , b , h , m = map ( int , input ( ) . split ( ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> r = abs ( ( h * 30 + m * 0.5 ) - ( m * 6 ) ) <NEWLINE> s1 = math . sqrt ( a ** 2 + b ** 2 - ( 2 * a * b * ( math . cos ( math . radians ( r ) ) ) ) ) <NEWLINE> print ( s ) <NEWLINE>
import math <NEWLINE> a , b , h , m = map ( int , input ( ) . split ( ) ) <NEWLINE> time = m + h * 60 <NEWLINE> angle = time * 0.5 - time * 6 <NEWLINE> radian = math . radians ( angle ) <NEWLINE> rad = math . cos ( radian ) <NEWLINE> ans = b ** 2 + c ** 2 - 2 * a * b * rad <NEWLINE> print ( math . sqrt ( ans ) ) <NEWLINE>
import math <NEWLINE> <NL> x = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> a = x [ 0 ] <NEWLINE> b = x [ 1 ] <NEWLINE> h = x [ 2 ] <NEWLINE> m = x [ 3 ] <NEWLINE> <NL> deg = abs ( h * math . pi / 6 + math . pi / 360 * m - m * math . pi / 30 ) <NEWLINE> <NL> if deg <= math . pi : <NEWLINE> <INDENT> deg = deg <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> deg = deg - math . pi <NEWLINE> <NL> <DEDENT> if deg <= math . pi / 2 : <NEWLINE> <INDENT> ans = math . sqrt ( math . pow ( a * math . sin ( deg ) , 2 ) + math . pow ( b - a * math . cos ( deg ) , 2 ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = math . sqrt ( math . pow ( b * math . sin ( deg ) , 2 ) + math . pow ( a - b * math . cos ( deg ) , 2 ) ) <NEWLINE> <NL> <DEDENT> if h == 11 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
import math <NEWLINE> <NL> short = int ( input ( ) ) <NEWLINE> long = int ( input ( ) ) <NEWLINE> hour = int ( input ( ) ) <NEWLINE> min = int ( input ( ) ) <NEWLINE> <NL> hour = 360 / 12 * hour + 360 / 12 / 60 * min <NEWLINE> min = 360 / 60 * min <NEWLINE> <NL> rasian = abs ( hour - min ) <NEWLINE> <NL> if rasian > 90 : <NEWLINE> <INDENT> length = math . sqrt ( short * short + long * long + 2 * short * long * math . cos ( math . radians ( rasian ) ) ) <NEWLINE> <DEDENT> elif rasian < 90 : <NEWLINE> <INDENT> length = math . sqrt ( short * short + long * long - 2 * short * long * math . cos ( math . radians ( rasian ) ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> length = math . sqrt ( short * short + long * long ) <NEWLINE> <DEDENT> print ( length ) <NEWLINE>
import math <NEWLINE> <NL> a , b , h , m = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <COMMENT> <NL> c = 11.0 / 360.0 * ( 60 * h + m ) * pi <NEWLINE> x = math . sqrt ( a * a + b * b - 2 * a * b * math . cos ( c ) ) <NEWLINE> print ( x ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL>
import math <NEWLINE> import numpy as np <NEWLINE> a , b , h , m = input ( ) . split ( ) <NEWLINE> x = a ** 2 + b ** 2 - ( 2 * a * b * cos ( ( ( m - 5 * h ) / 60 ) * math . pi ) ) <NEWLINE> x = np . sqrt ( x ) <NEWLINE> print ( x ) <NEWLINE>
import math <NEWLINE> A , B , H , M = map ( int , input ( ) . split ( ) ) <NEWLINE> c = abs ( H * 15 - M * 6 ) <NEWLINE> k = A * A + B * B - 2 * A * B * math . cos ( c * pi / 360 ) <NEWLINE> l = math . sqrt ( k ) <NEWLINE> print ( l ) <NEWLINE>
from math import cos , sin , sqrt , radians <NEWLINE> short = int ( input ( ) ) <NEWLINE> long = int ( input ( ) ) <NEWLINE> hour = int ( input ( ) ) <NEWLINE> minit = int ( input ( ) ) <NEWLINE> <NL> short_kaku = 90 - ( 30 * hour + 0.5 * minit ) <NEWLINE> short_x = short * cos ( radians ( short_kaku ) ) <NEWLINE> short_y = short * sin ( radians ( short_kaku ) ) <NEWLINE> <NL> long_kaku = 90 - 6 * minit <NEWLINE> long_x = long * cos ( radians ( long_kaku ) ) <NEWLINE> long_y = long * sin ( radians ( long_kaku ) ) <NEWLINE> <NL> distance = sqrt ( ( short_x - long_x ) ** 2 + ( short_y - long_y ) ** 2 ) <NEWLINE> <NL> print ( <STRING> . format ( distance ) ) <NEWLINE>
def hoge ( n , m ) : <NEWLINE> <INDENT> n = n % 12 <NEWLINE> b = 30 * n + 0.5 * m <NEWLINE> s = 6 * m <NEWLINE> ans = min ( abs ( b - s ) , 360 - abs ( b - s ) ) <NEWLINE> if ans == 360 : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> return ans <NEWLINE> <NL> <DEDENT> def solve ( ) : <NEWLINE> <INDENT> a , b , h , n = map ( int , input ( ) . split ( ) ) <NEWLINE> p = hoge ( h , n ) <NEWLINE> ans = math . sqrt ( a ** 2 + b ** 2 - ( 2 * a * b * math . cos ( math . radians ( p ) ) ) ) <NEWLINE> print ( ans ) <NEWLINE> return 0 <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> solve ( ) <NEWLINE> <DEDENT>
import math <NEWLINE> A = int ( input ( ) ) <NEWLINE> B = int ( input ( ) ) <NEWLINE> H = int ( input ( ) ) <NEWLINE> M = int ( input ( ) ) <NEWLINE> <NL> h = H * 30 + 0.5 * M <NEWLINE> m = 6 * M <NEWLINE> hh = abs ( h - m ) <NEWLINE> mm = 360 - hh <NEWLINE> <NL> if hh <= mm : <NEWLINE> <INDENT> c = hh <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> c = mm <NEWLINE> <NL> <DEDENT> c = math . radians ( c ) <NEWLINE> <NL> C = ( A * A ) + ( B * B ) - ( 2 * A * B * math . cos ( c ) ) <NEWLINE> print ( math . sqrt ( C ) ) <NEWLINE>
A , B , H , M = map ( int , input ( ) . split ( ) ) <NEWLINE> sitaH = ( H * 60 + M ) / 720 * 2 * math . pi <NEWLINE> sitaM = M / 60 * 2 * math . pi <NEWLINE> <NL> posXH = A * math . cos ( sitaH ) <NEWLINE> posYH = A * math . sin ( sitaH ) <NEWLINE> posXM = B * math . cos ( sitaM ) <NEWLINE> posYM = B * math . sin ( sitaM ) <NEWLINE> <NL> delX = posXH - posXM <NEWLINE> delY = posYH - posYM <NEWLINE> <NL> d = ( delX * delX + delY * delY ) ** ( 1 / 2 ) <NEWLINE> print ( d ) <NEWLINE>
import math <NEWLINE> a , b , h , m = map ( int , input ( ) . split ( ) ) <NEWLINE> fine = math . radians ( 30 h - 11 * m / 2 ) <NEWLINE> c = math . sqrt ( a ** 2 + b ** 2 - 2 * a * b * math . cos ( fine ) ) <NEWLINE> print ( c ) <NEWLINE>
import math <NEWLINE> <NL> A = int ( input ( ) ) <NEWLINE> B = int ( input ( ) ) <NEWLINE> H = int ( input ( ) ) <NEWLINE> M = int ( input ( ) ) <NEWLINE> if 1 <= A <= 1000 and 1 <= B <= 1000 and 0 <= H <= 11 and 0 <= M <= 59 : <NEWLINE> <INDENT> hw = ( 2 * math . pi ) / 12 <NEWLINE> mw = ( 2 * math . pi ) / 60 <NEWLINE> aw = hw * H + ( hw / 60 ) * M <NEWLINE> bw = mw * M <NEWLINE> rad = abs ( bw - aw ) <NEWLINE> print ( math . sqrt ( A ** 2 + B ** 2 - 2 * A * B * math . cos ( rad ) ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> print ( <STRING> . format ( A , B , H , M ) ) <NEWLINE> <DEDENT>
import math <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> A , B , H , M = map ( int , input ( ) . strip ( ) . split ( ) ) <NEWLINE> minH = 6 * M <NEWLINE> HrH = 0.5 * ( H * 60 + M ) <NEWLINE> Ang = abs ( HrH - minH ) <NEWLINE> Ans = math . sqrt ( A ** 2 + B ** 2 - 2 * A * B * math . cos ( ( 2 * math . pi / 180 ) * Ang ) ) <NEWLINE> Ans = str ( Ans ) <NEWLINE> if <STRING> in Ans : <NEWLINE> <INDENT> intg = Ans . split ( <STRING> ) [ 0 ] <NEWLINE> decimal = Ans . split ( <STRING> ) [ 1 ] <NEWLINE> if len ( decimal ) < 9 : <NEWLINE> <INDENT> print ( intg + <STRING> + decimal + <STRING> * ( 9 - len ( decimal ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( intg + <STRING> + decimal [ : 9 ] ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( Ans + <STRING> + <STRING> * 9 ) <NEWLINE> <NL> <DEDENT>
a , b , h , m = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> <NL> <COMMENT> <NL> <NL> h_dig = 360 * ( float ( h ) / 12 ) + 30 * ( float ( m ) / 60 ) <NEWLINE> m_dig = 360 * ( float ( m ) / 60 ) <NEWLINE> <NL> <COMMENT> <NL> <NL> abs_dig = abs ( h_dig - m_dig ) <NEWLINE> if ( abs_dig > 180 ) : <NEWLINE> <INDENT> abs_dig = 360 - abs_dig <NEWLINE> <NL> <COMMENT> <NL> <NL> <DEDENT> c = math . sqrt ( a ** 2 + b ** 2 - 2 * a * b * math . cos ( abs_dig / 360 * 2 * math . pi ) ) <NEWLINE> <NL> print ( <STRING> . format ( c ) ) <NEWLINE>
import math <NEWLINE> L = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = L [ 0 ] <NEWLINE> b = L [ 1 ] <NEWLINE> H = L [ 2 ] <NEWLINE> M = L [ 3 ] <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> print ( angleshort ) <NEWLINE> print ( anglelong ) <NEWLINE> theta = math . radians ( ( anglelong - angleshort ) ) <NEWLINE> ans = ( a * a + b * b - 2 * a * b * math . cos ( theta ) ) ** 0.5 <NEWLINE> print ( ans ) <NEWLINE>
import math <NEWLINE> A , B , H , M = map ( int , input ( ) . split ( ) ) <NEWLINE> H_pos = H / 12 + M / 720 <NEWLINE> M_pos = M / 60 <NEWLINE> print ( <STRING> . format ( ( A ** 2 + B ** 2 - 2 * A * B * math . cos ( math . radians ( 360 * ( H_pos - M_pos ) ) ) ) ) ** 0.5 ) <NEWLINE>
import math <NEWLINE> def main ( ) : <NEWLINE> <INDENT> A , B , H , M = map ( float , input ( ) . split ( ) ) <NEWLINE> R = H / 12 + M * 0.5 / 360 <NEWLINE> r = M / 60 <NEWLINE> cos = math . cos ( ( R - r * 2 * math . pi ) <NEWLINE> C = math . sqrt ( A ^ 2 + B ^ 2 - 2 * A * B * cos ) <NEWLINE> print ( C ) <NEWLINE> <NL> <DEDENT> if name == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import math <NEWLINE> a , b , h , m = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if 30 * h + m / 2 - 6 * m >= 0 : <NEWLINE> <INDENT> x = 30 * h + m / 2 - 6 * m <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = 6 * m - 30 * h - m / 2 <NEWLINE> <NL> <DEDENT> print ( ( a ^ 2 + b ^ 2 - 2 * a * b * math . cos ( x ) ) ** ( 1 / 2 ) ) <NEWLINE> <NL>
import numpy as np <NEWLINE> a , b , h , m = map ( int , input ( ) . split ( ) ) <NEWLINE> pi = np . py <NEWLINE> x = 2 * pi * ( h * 60 + m ) / 720 <NEWLINE> y = 2 * pi * m / 60 <NEWLINE> theta = abs ( x - y ) <NEWLINE> cos = np . cos ( theta ) <NEWLINE> ans = ( a ** 2 + b ** 2 - 2 * a * b * cos ) ** 0.5 <NEWLINE> print ( ans ) <NEWLINE> <NL> <NL>
import math <NEWLINE> [ a , b , h , m ] = [ int ( x ) for x in input ( ) . split ( <STRING> ) ] <NEWLINE> short = ( h * 60 + m ) / ( 12 * 60 ) * 360 <NEWLINE> long = ( m ) / ( 60 ) * 360 <NEWLINE> theta = ( abs ( long - short ) <NEWLINE> inte = math . cos ( math . radians ( theta ) ) <NEWLINE> print ( math . sqrt ( a ** 2 + b ** 2 + a * b * abs ( inte ) ) ) <NEWLINE>
import numpy <NEWLINE> def main ( ) : <NEWLINE> <INDENT> A , B , H , M = map ( float , input ( ) . split ( ) ) <NEWLINE> R = H / 12 + M * 0.5 / 360 <NEWLINE> r = M / 60 <NEWLINE> cos = np . cos ( ( R - r ) * 2 * np . pi ) <NEWLINE> C = np . sqrt ( A * A + B * B - 2 * A * B * cos ) <NEWLINE> print ( C ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import math <NEWLINE> jishin , hunshin , hour , minute = map ( float , input ( ) . split ( ) ) <NEWLINE> <NL> x_ji = jishin * math . cos ( math . radian ( hour * 360 / 12 ) ) <NEWLINE> y_ji = jishin * math . sin ( math . radian ( hour * 360 / 12 ) ) <NEWLINE> x_hun = hunshin * math . cos ( math . radian ( minute * 360 / 60 ) ) <NEWLINE> y_hun = hunshin * math . sin ( math . radian ( minute * 360 / 60 ) ) <NEWLINE> <NL> kyori = math . sqrt ( ( x_ji - x_hun ) ** 2 + ( y_ji - y_hun ) ** 2 ) <NEWLINE> print ( kyori ) <NEWLINE>
A , B , H , M = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> import math <NEWLINE> <COMMENT> <NL> <NL> H_rad = 2 * math . pi ( ) / 12 * H <NEWLINE> M_rad = 2 * math . pi ( ) / 60 * M <NEWLINE> rad = abs ( H_rad - M_rad ) <NEWLINE> <NL> <COMMENT> <NL> C = math . sqrt ( A ** 2 + B ** 2 - 2 * A * B * math . cos ( rad ) ) <NEWLINE> print ( C ) <NEWLINE>
import math <NEWLINE> a , b , h , m = list ( map ( int , readline ( ) . split ( ) ) ) <NEWLINE> deg_a = ( 60 * h + m ) * 0.5 <NEWLINE> deg_b = 6 * m <NEWLINE> deg = abs ( deg_a - deg_b ) <NEWLINE> rad = math . radians ( deg ) <NEWLINE> <NL> c2 = a ** 2 + b ** 2 - 2 * a * b * math . cos ( rad ) <NEWLINE> print ( c2 ** 0.5 ) <NEWLINE>
import math <NEWLINE> <NL> A , B , H , M = map ( int , input ( ) . split ( ) ) <NEWLINE> x = abs ( ( ( 60 * H + M ) * 0.5 ) - ( 6 * M ) ) <NEWLINE> if x >= 180 : <NEWLINE> <INDENT> x = x - 180 <NEWLINE> <DEDENT> y = ( A ** 2 ) + ( B ** 2 ) - 2 * A * B * math . cos ( math . radians ( x ) ) <NEWLINE> print ( ( math . sqrt ( y ) ) <NEWLINE>
import cmath <NEWLINE> <NL> param = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> A = param [ 0 ] <NEWLINE> B = param [ 1 ] <NEWLINE> h = param [ 2 ] <NEWLINE> m = param [ 3 ] <NEWLINE> <NL> print ( abs ( A * pow ( math . e , ( math . pi * m / 30 ) * 1j ) - B * pow ( math . e , ( math . pi * h / 6 ) * 1j ) ) <NEWLINE>
import math <NEWLINE> def kyori ( a , b , c , d ) : <NEWLINE> <INDENT> return math . sqrt ( a ** 2 + b ** 2 - 2 * a * b * math . cos ( abs ( c - d ) ) <NEWLINE> <NL> <NL> <DEDENT> A , B , H , M = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> h = H * 2 * math . pi / 12 <COMMENT> <NEWLINE> m = M * 2 * math . pi / 60 <COMMENT> <NEWLINE> <COMMENT> <NL> <NL> <NL> k = kyori ( A , B , h , m ) <NEWLINE> print ( k ) <NEWLINE>
from math import sin , cos , pi <NEWLINE> def main ( ) : <NEWLINE> <COMMENT> <NL> <INDENT> readline = stdin . readline <NEWLINE> A , B , H , M = map ( int , readline ( ) . split ( ) ) <NEWLINE> <NL> s = M * pi / 30 <NEWLINE> t = ( H / 6 ) * pi + ( M / 360 ) * pi <NEWLINE> x_A = A * sin ( t ) <NEWLINE> y_A = A * cos ( t ) <NEWLINE> <NL> x_B = B * sin ( s ) <NEWLINE> y_B = B * cos ( s ) <NEWLINE> <NL> print ( ( ( x_A - x_B ) ** 2 + ( y_A - y_B ) ** 2 ) ** 0.5 ) <NEWLINE> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
3 4 10 40 <NEWLINE>
import math <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> a , b , h , m = map ( int , input ( ) . split ( ) ) <NEWLINE> if h == 0 and m == 0 : <NEWLINE> <INDENT> print ( abs ( b - a ) ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> h_basho = h * 60 + m <NEWLINE> m_basho = m * 12 <NEWLINE> h_m_basho = h_basho - m_basho <NEWLINE> <NL> if h_m_basho == 360 : <NEWLINE> <INDENT> print ( a + b ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> elif h_m_basho < 360 : <NEWLINE> <INDENT> kakudo = 90 * h_m_basho / 180 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> kakudo = 90 * ( 720 - h_m_basho ) / 180 <NEWLINE> <NL> <DEDENT> ab2 = a ** 2 + b ** 2 <NEWLINE> cos = 2 * a * b * ( round ( math . cos ( round ( math . radians ( kakudo ) ) , 20 ) , 20 ) ) <NEWLINE> <NL> if kakudo <= 90 : <NEWLINE> <INDENT> ac = ab2 - cos <NEWLINE> print ( <STRING> % math . sqrt ( ac ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ac = ab2 + cos <NEWLINE> print ( <STRING> % math . sqrt ( ac ) ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import math <NEWLINE> <NL> x = ( ( a * math . cos ( math . pi / 6 * ( h + m / 60 ) ) - b * math . cos ( math . pi / 30 * m ) ) ** 2 + ( a * math . sin ( math . pi / 6 * ( h + m / 60 ) ) - b * math . sin ( math . pi / 30 * m ) ) ** 2 ) ** ( 1 / 2 ) <NEWLINE> <NL> print ( x ) <NEWLINE>
[ a , b , h , m ] = map ( int , input ( ) ) <NEWLINE> <NL> import math <NEWLINE> <NL> long_n = math . radians ( ( h * 60 + m ) / ( 12 * 60 ) ) <NEWLINE> short_n = math . radians ( ( m ) / 60 ) <NEWLINE> <NL> y1 = a * math . sin ( long_n ) <NEWLINE> x1 = a * math . cos ( long_n ) <NEWLINE> <NL> y2 = b * math . sin ( short_n ) <NEWLINE> x2 = b * math . cos ( short_n ) <NEWLINE> <NL> print ( math . sqrt ( ( x2 - x1 ) ** 2 + ( y2 - y1 ) ** 2 ) ) <NEWLINE>
<COMMENT> <NL> <NL> import numpy as np <NEWLINE> from scipy . sparse import csr_matrix <NEWLINE> from scipy . sparse . csgraph import breadth_first_order <NEWLINE> <NL> N , M = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ABs = np . array ( [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( M ) ] ) <NEWLINE> <NL> row = ABs . T [ 0 ] <NEWLINE> col = ABs . T [ 1 ] <NEWLINE> data = [ 1 ] * ( M ) <NEWLINE> <NL> csr = csr_matrix ( ( data , ( row , col ) ) , shape = ( N , N ) ) <NEWLINE> _ , proc = breadth_first_order ( csr , 0 , directed = False ) <NEWLINE> <NL> if - 9999 in proc [ 1 : ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> print ( <STRING> . join ( ( proc [ 1 : ] + 1 ) . astype ( <STRING> ) ) ) <NEWLINE> <DEDENT>
from collections import defaultdict <NEWLINE> from collections import deque <NEWLINE> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> g = defaultdict ( list ) <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> u , v = map ( int , input ( ) . split ( ) ) <NEWLINE> g [ u ] . append ( v ) <NEWLINE> g [ v ] . append ( u ) <NEWLINE> <COMMENT> <NL> <DEDENT> visited = [ False ] * ( n + 1 ) <NEWLINE> a = [ 10 ** 10 ] * ( n + 1 ) <NEWLINE> q = deque ( ) <NEWLINE> q . append ( 1 ) <NEWLINE> while q : <NEWLINE> <INDENT> node = q . popleft ( ) <NEWLINE> visited [ node ] = True <NEWLINE> for ele in g [ node ] : <NEWLINE> <INDENT> if not visited [ ele ] : <NEWLINE> <INDENT> a [ ele ] = node <NEWLINE> q . append ( ele ) <NEWLINE> <DEDENT> <DEDENT> depth += 1 <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> print ( <STRING> ) <NEWLINE> for i in a [ 2 : ] : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> graph = [ [ ] for i in range ( n ) ] <NEWLINE> sirusi = [ 0 ] * n <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> a -= 1 ; b -= 1 <NEWLINE> graph [ a ] . append ( b ) <NEWLINE> graph [ b ] . append ( a ) <NEWLINE> <DEDENT> D = deque ( [ 0 ] ) <NEWLINE> visited = [ False ] * n <NEWLINE> visited [ 0 ] = True <NEWLINE> while D : <NEWLINE> <INDENT> v = D . popleft ( ) <NEWLINE> for i in graph [ v ] : <NEWLINE> <INDENT> if visited [ i ] : continue <NEWLINE> visited [ i ] = True <NEWLINE> sirusi [ i ] = v <NEWLINE> D . append ( i ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> print ( sirusi [ i ] + 1 ) <NEWLINE> <DEDENT>
k = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> if ( len ( s ) > k ) : <NEWLINE> <INDENT> print ( s [ 0 : k ] + <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( s ) <NEWLINE> <DEDENT>
N , M = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> MAX = 1000000000 <NEWLINE> S = [ ] <NEWLINE> Room = [ MAX for i in range ( N ) ] <COMMENT> <NEWLINE> Room [ 0 ] = 0 <NEWLINE> ACCESS = [ 0 for i in range ( N - 1 ) ] <NEWLINE> for _ in range ( M ) : <NEWLINE> <INDENT> a , b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> S . append ( [ a , b ] ) <NEWLINE> S . append ( [ b , a ] ) <NEWLINE> <DEDENT> for i in S : <NEWLINE> <INDENT> if i [ 0 ] == 1 : <NEWLINE> <INDENT> Room [ i [ 1 ] - 1 ] = 1 <NEWLINE> ACCESS [ i [ 1 ] - 2 ] = 1 <NEWLINE> S . remove ( i ) <NEWLINE> <DEDENT> <DEDENT> depth = 1 <NEWLINE> while max ( Room ) > MAX / 2 : <NEWLINE> <INDENT> for i in range ( len ( Room ) ) : <NEWLINE> <INDENT> if Room [ i ] == depth : <NEWLINE> <INDENT> k = 0 <NEWLINE> for _ in range ( len ( S ) ) : <NEWLINE> <INDENT> j = S [ k ] <NEWLINE> if ( j [ 0 ] == i + 1 ) * ( Room [ j [ 1 ] - 1 ] > MAX / 2 ) : <NEWLINE> <INDENT> Room [ j [ 1 ] - 1 ] = depth + 1 <NEWLINE> ACCESS [ j [ 1 ] - 2 ] = i + 1 <NEWLINE> S . remove ( j ) <NEWLINE> S . remove ( j [ : : - 1 ] ) <NEWLINE> k -= 1 <NEWLINE> <DEDENT> k += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> depth += 1 <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> for i in ACCESS : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> AB = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( M ) ] <NEWLINE> <NL> ans = [ - 1 ] * ( N + 1 ) <NEWLINE> graph = [ [ ] for _ in range ( N + 1 ) ] <NEWLINE> for a , b in AB : <NEWLINE> <INDENT> graph [ a ] . append ( b ) <NEWLINE> graph [ b ] . append ( a ) <NEWLINE> <NL> <DEDENT> for i in range ( N + 1 ) : <NEWLINE> <INDENT> graph [ i ] . sort ( ) <NEWLINE> <NL> <DEDENT> from collections import deque <NEWLINE> todo = deque ( [ ( 1 , 0 ) ] ) <NEWLINE> while todo : <NEWLINE> <INDENT> x , parent = todo . pop ( ) <NEWLINE> ans [ x ] = parent <NEWLINE> for y in graph [ x ] : <NEWLINE> <INDENT> if y == parent : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if ans [ y ] == - 1 : <NEWLINE> <INDENT> todo . append ( ( y , x ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> for i in range ( 2 , N + 2 ) : <NEWLINE> <INDENT> print ( ans [ i ] ) <NEWLINE> <DEDENT>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> adj = { } <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> adj [ i + 1 ] = [ ] <NEWLINE> <DEDENT> for i in range ( M ) : <NEWLINE> <INDENT> v1 , v2 = map ( int , input ( ) . split ( ) ) <NEWLINE> adj [ v1 ] . append ( v2 ) <NEWLINE> adj [ v2 ] . append ( v1 ) <NEWLINE> <NL> <DEDENT> visited = { 1 } <NEWLINE> parent = { 1 : None } <NEWLINE> frontier = [ 1 ] <NEWLINE> while frontier : <NEWLINE> <INDENT> nxt = [ ] <NEWLINE> for u in frontier : <NEWLINE> <INDENT> for v in adj [ u ] : <NEWLINE> <INDENT> if v not in visited : <NEWLINE> <INDENT> parent [ v ] = u <NEWLINE> nxt . append [ v ] <NEWLINE> visited . add [ v ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> frontier = nxt <NEWLINE> <NL> <DEDENT> if len ( visited ) < N : print ( <STRING> ) <NEWLINE> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> for i in range ( 2 , N + 1 ) : <NEWLINE> <INDENT> print ( parent [ i ] [ 0 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT>
import numpy as np <NEWLINE> <NL> <COMMENT> <NL> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <COMMENT> <NL> arr_path = np . array ( [ 0 , 0 ] ) <NEWLINE> <COMMENT> <NL> for i in range ( M ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> arr = np . array ( [ a , b ] ) <NEWLINE> arr_path = np . vstack ( [ arr_path , arr ] ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> class_layer = [ ] <NEWLINE> class_layer . append ( [ 1 ] ) <NEWLINE> <NL> <COMMENT> <NL> def transit ( x ) : <NEWLINE> <INDENT> path = arr_path [ np . any ( arr_path == x , axis = 1 ) ] <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> path = path [ path != x ] <NEWLINE> trans_list = path . tolist ( ) <NEWLINE> return trans_list <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> def level_up ( x ) : <NEWLINE> <INDENT> now = class_layer [ x ] <NEWLINE> pre = [ ] <NEWLINE> if x >= 1 : <NEWLINE> <INDENT> pre = class_layer [ x - 1 ] <NEWLINE> <DEDENT> li = [ ] <NEWLINE> for i in now : <NEWLINE> <INDENT> for j in transit ( i ) : <NEWLINE> <INDENT> if j in now : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> elif j in pre : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> li . append ( j ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> class_layer . append ( li ) <NEWLINE> <NL> <DEDENT> for i in range ( M ) : <NEWLINE> <INDENT> level_up ( i ) <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> def layer_finder ( x ) : <NEWLINE> <INDENT> for i in range ( M ) : <NEWLINE> <INDENT> for j in class_layer [ i ] : <NEWLINE> <INDENT> if j == x : <NEWLINE> <INDENT> global ans <NEWLINE> ans = i <NEWLINE> <COMMENT> <NL> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return ans <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> def path_get ( x ) : <NEWLINE> <COMMENT> <NL> <INDENT> X = layer_dict [ x - 1 ] <NEWLINE> <COMMENT> <NL> li1 = class_layer [ X - 1 ] <NEWLINE> <NL> <COMMENT> <NL> path = arr_path [ np . any ( arr_path == x , axis = 1 ) ] <NEWLINE> path = path [ path != x ] <NEWLINE> li2 = path . tolist ( ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> li_common = list ( set ( li1 ) & set ( li2 ) ) <NEWLINE> <NL> print ( li_common [ 0 ] ) <NEWLINE> <NL> <NL> <NL> <DEDENT> print ( <STRING> ) <NEWLINE> for i in range ( 2 , N + 1 ) : <NEWLINE> <INDENT> path_get ( i ) <NEWLINE> <DEDENT>
from collections import deque <NEWLINE> <NL> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> map_li = [ [ ] for i in range ( n ) ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> a , b = a - 1 , b - 1 <NEWLINE> map_li [ a ] . append ( b ) <NEWLINE> map_li [ b ] . append ( a ) <NEWLINE> <NL> <DEDENT> ans_li = [ - 1 ] * n <NEWLINE> queue = deque ( ) <NEWLINE> queue . append ( 0 ) <NEWLINE> <NL> while queue : <NEWLINE> <INDENT> x = queue . pop ( 0 ) <NEWLINE> for g in map_li [ x ] : <NEWLINE> <INDENT> if ans_li [ g ] == - 1 : <NEWLINE> <INDENT> ans_li [ g ] = x <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if - 1 in ans_li [ 1 : ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> for ans in ans_li [ 1 : ] : <NEWLINE> <INDENT> print ( ans + 1 ) <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> from collections import deque <NEWLINE> def input ( ) : <NEWLINE> <INDENT> return list ( map ( int , sys . stdin . readline ( ) . strip ( ) . split ( ) ) ) <NEWLINE> <NL> <DEDENT> n , m = input ( ) <NEWLINE> mem = [ 0 for _ in range ( n + 1 ) ] <COMMENT> <NEWLINE> adj = [ set ( ) for _ in range ( n + 1 ) ] <NEWLINE> q = [ ] <NEWLINE> <NL> for i in range ( m ) : <NEWLINE> <INDENT> a , b = input ( ) <NEWLINE> adj [ b ] . append ( a ) <NEWLINE> adj [ a ] . append ( b ) <NEWLINE> if b == 1 : <NEWLINE> <INDENT> q . append ( a ) <NEWLINE> mem [ a ] = 1 <NEWLINE> <DEDENT> if a == 1 : <NEWLINE> <INDENT> q . append ( b ) <NEWLINE> mem [ b ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> visited = [ ] <NEWLINE> while q : <NEWLINE> <INDENT> v = q . pop ( 0 ) <NEWLINE> if v not in visited : <NEWLINE> <INDENT> visited . append ( v ) <NEWLINE> for node in adj [ v ] : <NEWLINE> <INDENT> if node not in visited : <NEWLINE> <INDENT> mem [ node ] = mem [ v ] + 1 <NEWLINE> q . append ( n ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if 0 in mem : print ( <STRING> ) <NEWLINE> else : print ( <STRING> , * mem [ 2 : ] , sep = <STRING> ) <NEWLINE> <NL>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> l = [ [ ] for i in range ( n ) ] <NEWLINE> for i in range ( m + 1 ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> l [ a ] . append ( b ) <NEWLINE> l [ b ] . append ( a ) <NEWLINE> <DEDENT> ans = [ - 1 ] * ( n + 1 ) <NEWLINE> ans [ 0 ] = 0 <NEWLINE> x = [ 1 ] <NEWLINE> y = [ ] <NEWLINE> count = 1 <NEWLINE> while x != [ ] : <NEWLINE> <INDENT> for i in x : <NEWLINE> <INDENT> for j in l [ i ] : <NEWLINE> <INDENT> if ans [ j ] == - 1 : <NEWLINE> <INDENT> ans [ j ] = i <NEWLINE> y . append ( j ) <NEWLINE> count += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> x = y <NEWLINE> y = [ ] <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> for i in range ( 2 , n + 1 ) : <NEWLINE> <INDENT> print ( ans [ i ] ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 10 ) <NEWLINE> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> R = [ [ ] for _ in range ( N ) ] <NEWLINE> ans = np . zeros ( N , dtype = int ) <NEWLINE> ans [ 0 ] = 1 <NEWLINE> queue = [ 1 ] <NEWLINE> for _ in range ( M ) : <NEWLINE> <INDENT> i , j = map ( int , input ( ) . split ( ) ) <NEWLINE> R [ i - 1 ] . append ( j ) <NEWLINE> R [ j - 1 ] . append ( i ) <NEWLINE> <NL> <DEDENT> def bfs ( que ) : <NEWLINE> <INDENT> if que == [ ] : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> i = que [ 0 ] <NEWLINE> for j in R [ i - 1 ] : <NEWLINE> <INDENT> if ans [ j - 1 ] == 0 : <NEWLINE> <INDENT> ans [ j - 1 ] = i <NEWLINE> que . append ( j ) <NEWLINE> <DEDENT> <DEDENT> que . pop ( 0 ) <NEWLINE> bfs ( que ) <NEWLINE> <NL> <DEDENT> bfs ( queue ) <NEWLINE> print ( <STRING> ) <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> print ( ans [ i ] ) <NEWLINE> <DEDENT>
<COMMENT> <NL> import numpy as np <NEWLINE> <NL> N , M = [ int ( x ) for x in input ( ) ] <NEWLINE> <NL> e = { i : [ ] for i in range ( N ) } <NEWLINE> for _ in range ( M ) : <NEWLINE> <INDENT> a , b = [ int ( x ) - 1 for x in input ( ) ] <NEWLINE> e [ a ] . append ( b ) <NEWLINE> e [ b ] . append ( a ) <NEWLINE> <NL> <DEDENT> d = np . ones ( N , dtype = int ) * - 1 <NEWLINE> <NL> q = [ 0 ] <NEWLINE> while len ( q ) != 0 : <NEWLINE> <INDENT> v = q . pop ( 0 ) <NEWLINE> for ne in e [ v ] : <NEWLINE> <INDENT> if d [ ne ] == - 1 : <NEWLINE> <INDENT> d [ ne ] = v <NEWLINE> q . append ( ne ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> print ( <STRING> . join ( [ str ( p + 1 ) for p in d [ 1 : ] ] ) ) <NEWLINE>
tmp = input ( ) . split ( ) <NEWLINE> N = int ( tmp [ 0 ] ) <NEWLINE> S = [ 0 for i in range ( N ) ] <NEWLINE> T = [ 0 for i in range ( N ) ] <NEWLINE> <NL> for n in range ( N ) : <NEWLINE> <INDENT> tmp = input ( ) . split ( ) <NEWLINE> S [ n ] = int ( tmp [ 0 ] ) <NEWLINE> T [ n ] = int ( tmp [ 1 ] ) <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> mod = 1000000007 <NEWLINE> <NL> dp [ 0 ] = 0 <NEWLINE> <NL> for i in range ( N + 1 ) : <NEWLINE> <NL> <INDENT> out = 0 <NEWLINE> for k in range ( i ) : <NEWLINE> <INDENT> if S [ k ] * S [ i ] + T [ k ] * T [ i ] == 0 : <NEWLINE> <INDENT> + + out <NEWLINE> <DEDENT> <DEDENT> dp [ i + 1 ] = dp [ i ] * 2 - out <NEWLINE> dp [ i + 1 ] = dp [ i + 1 ] % mod <NEWLINE> <DEDENT> print ( dp [ N ] ) <NEWLINE>
import sys <NEWLINE> import math <NEWLINE> from colletions import deque <NEWLINE> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> G = [ [ ] for i in range ( N ) ] <NEWLINE> for _ in range ( M ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> a -= 1 <NEWLINE> b -= 1 <NEWLINE> G [ a ] . append ( b ) <NEWLINE> G [ b ] . append ( a ) <NEWLINE> <DEDENT> q = deque ( ) <NEWLINE> done = [ - 1 ] * N <NEWLINE> done [ 0 ] = 1 <NEWLINE> q . appendleft ( 0 ) <NEWLINE> while q : <NEWLINE> <INDENT> now = q . pop ( ) <NEWLINE> for to in G [ now ] : <NEWLINE> <INDENT> if done [ to ] != - 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> done [ to ] = now + 1 <NEWLINE> q . appendleft ( to ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> print ( * done [ 1 : ] , sep = <STRING> ) <NEWLINE>
from collections import defaultdict <NEWLINE> import sys <NEWLINE> room_num , root_num = map ( int , input ( ) . split ( ) ) <NEWLINE> <COMMENT> <NL> connect_dic = defaultdict ( set ) <NEWLINE> connected_list = [ 1 ] <NEWLINE> next_connect_dic = { } <NEWLINE> for _ in range ( root_num ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> connect_dic [ a ] . add ( b ) <NEWLINE> connect_dic [ b ] . add ( a ) <NEWLINE> <NL> <DEDENT> for room_i in connected_list : <NEWLINE> <COMMENT> <NL> <INDENT> next_room_set = { connect_to for connect_to in connect_dic [ room_i ] if connect_to not in next_connect . keys ( ) } <NEWLINE> connected_list . extend ( list ( next_room_set ) ) <NEWLINE> for next_room_i in next_room_set : <NEWLINE> <INDENT> next_connect_dic [ next_room_i ] = room_i <NEWLINE> <NL> <DEDENT> <DEDENT> if len ( set ( range ( 2 , room_num + 1 ) ) - next_connect_dic . keys ( ) ) != 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> for i in range ( 2 , room_num + 1 ) : <NEWLINE> <INDENT> print ( next_connect_dic [ i ] ) <NEWLINE> <DEDENT> <DEDENT>
print ( <STRING> ) <NEWLINE> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> path = [ [ ] for _ in range ( N ) ] <NEWLINE> ind = [ 0 for _ in range ( N ) ] <NEWLINE> lis = [ ] <NEWLINE> for o in range ( N ) : <NEWLINE> <INDENT> lis . append ( o ) <NEWLINE> <DEDENT> for i in range ( M ) : <NEWLINE> <INDENT> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> path [ A - 1 ] . append ( B - 1 ) <NEWLINE> path [ B - 1 ] . append ( A - 1 ) <NEWLINE> <DEDENT> que = path [ 0 ] <NEWLINE> for p in que : <NEWLINE> <INDENT> lis . discard ( p ) <NEWLINE> <DEDENT> for l in que : <NEWLINE> <INDENT> U = path [ l ] <NEWLINE> for m in U : <NEWLINE> <INDENT> if m in lis : <NEWLINE> <INDENT> ind [ m ] = l <NEWLINE> lis . discard ( m ) <NEWLINE> <DEDENT> <DEDENT> que += U <NEWLINE> if lis == { } : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> for z in range ( 1 , N ) : <NEWLINE> <INDENT> ind [ z ] += 1 <NEWLINE> print ( ind [ z ] ) <NEWLINE> <DEDENT>
from collections import deque <NEWLINE> <NL> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> tree = [ [ 0 ] for _ in range ( N ) ] <NEWLINE> <NL> for _ in range ( M ) : <NEWLINE> <INDENT> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> tree [ A - 1 ] . append ( B - 1 ) <NEWLINE> tree [ B - 1 ] . append ( A - 1 ) <NEWLINE> <NL> <DEDENT> dist = [ - 1 ] * N <NEWLINE> que = deque ( [ 0 ] ) <NEWLINE> dist [ 0 ] = 0 <NEWLINE> while que : <NEWLINE> <INDENT> v = que . popleft ( ) <NEWLINE> d = dist [ v ] <NEWLINE> for w in tree [ v ] : <NEWLINE> <INDENT> if dist [ w ] != - 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> dist [ w ] = v <NEWLINE> que . append ( w ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> for j in range ( 1 , N ) : <NEWLINE> <INDENT> print ( ans [ j ] ) <NEWLINE> <DEDENT>
import sys <NEWLINE> readline = sys . stdin . readline <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> N , M = map ( int , readline ( ) . split ( ) ) <NEWLINE> dist = { } <NEWLINE> pre = { } <NEWLINE> A = { } <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> dist [ i + 1 ] = - 1 <NEWLINE> pre [ i + 1 ] = - 1 <NEWLINE> A [ i + 1 ] = [ ] <NEWLINE> <DEDENT> dist [ 1 ] = 0 <NEWLINE> pre [ 1 ] = 0 <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> ai , bi = map ( int , readline ( ) . split ( ) ) <NEWLINE> <INDENT> A [ ai ] . append ( bi ) <NEWLINE> A [ bi ] . append ( ai ) <NEWLINE> <DEDENT> <DEDENT> cnt = 1 <NEWLINE> depth = 1 <NEWLINE> D = [ 1 ] <NEWLINE> while cnt < N : <NEWLINE> <INDENT> next = [ ] <NEWLINE> for i in range ( len ( D ) ) : <NEWLINE> <INDENT> for j in range ( len ( A [ D [ i ] ] ) ) : <NEWLINE> <INDENT> if dist [ A [ D [ i ] ] [ j ] ] == - 1 : <NEWLINE> <INDENT> dist [ A [ D [ i ] ] [ j ] ] = depth <NEWLINE> pre [ A [ D [ i ] ] [ j ] ] = D [ i ] <NEWLINE> next . append ( A [ D [ i ] ] [ j ] ) <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> D = next <NEWLINE> depth += 1 <NEWLINE> if len ( next ) == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> elif depth > N : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> if cnt == N : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> print ( pre [ i + 1 ] ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> R = [ [ ] for _ in range ( N ) ] <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> R [ a - 1 ] . append ( b - 1 ) <NEWLINE> R [ b - 1 ] . append ( a - 1 ) <NEWLINE> <NL> <DEDENT> from collections import deque <NEWLINE> def bfs ( u ) : <NEWLINE> <NL> <INDENT> q = deque ( ) <NEWLINE> q . append ( u ) <NEWLINE> while q : <NEWLINE> <INDENT> r = q . pop ( ) <NEWLINE> for v in R [ r ] : <NEWLINE> <INDENT> if V [ v ] : <NEWLINE> <INDENT> V [ v ] = False <NEWLINE> S [ v ] = r <NEWLINE> q . append ( v ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> bfs ( 0 ) <NEWLINE> print ( <STRING> ) <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> print ( S [ i ] + 1 ) <NEWLINE> <DEDENT>
import collections <NEWLINE> <NL> if __name__ == <STRING> : <NEWLINE> <INDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> l = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( m ) ] <NEWLINE> <NL> ways = [ [ ] for i in range ( n + 1 ) ] <NEWLINE> <NL> for i in l : <NEWLINE> <INDENT> ways [ i [ 0 ] ] . append ( i [ 1 ] ) <NEWLINE> ways [ i [ 1 ] ] . append ( i [ 0 ] ) <NEWLINE> <NL> <COMMENT> <NL> <NL> <DEDENT> q = collections . deque ( ) <NEWLINE> <NL> ans = [ - 1 ] * n <COMMENT> <NEWLINE> ans [ 0 ] = 0 <NEWLINE> <NL> q . append ( 1 ) <NEWLINE> <NL> while ( len ( q ) != 0 ) : <NEWLINE> <INDENT> item = q . popleft ( ) <NEWLINE> for i in ways [ item ] : <NEWLINE> <INDENT> if ans [ i - 1 ] == - 1 : <NEWLINE> <INDENT> ans [ i - 1 ] = item <NEWLINE> q . append ( i ) <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> if - 1 in ans : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( 1 , n ) : <NEWLINE> print ( <STRING> ) <NEWLINE> print ( ans [ i ] ) <NEWLINE> <DEDENT> <DEDENT>
from collections import deque <NEWLINE> <NL> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> l = [ [ ] for _ in range ( N ) ] <NEWLINE> <NL> q = deque ( [ 0 ] ) <NEWLINE> <NL> TFl = [ 0 ] * N <NEWLINE> TFl [ 0 ] = 1 <NEWLINE> ml = [ - 1 ] * N <NEWLINE> <NL> for i in range ( M ) : <NEWLINE> <INDENT> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> l [ B - 1 ] . append ( A - 1 ) <NEWLINE> l [ A - 1 ] . append ( B - 1 ) <NEWLINE> <NL> <DEDENT> while q : <NEWLINE> <INDENT> p = q . popleft ( ) <NEWLINE> for i in l [ p ] : <COMMENT> <NEWLINE> <INDENT> if TFl [ i ] == 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> TFl [ i ] = 1 <NEWLINE> ml = p <NEWLINE> q . append ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> if all ( [ i == 1 for i in TFl ] ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> print ( ml [ i ] + 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
<COMMENT> <NL> from collections import deque <NEWLINE> import sys <NEWLINE> input = sys . std . readline <NEWLINE> <NL> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> edges = [ [ ] for _ in range ( n ) ] <NEWLINE> for _ in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> edges [ a - 1 ] . append ( b - 1 ) <NEWLINE> edges [ b - 1 ] . append ( a - 1 ) <NEWLINE> <NL> <DEDENT> que = deque ( ) <NEWLINE> dist = [ float ( <STRING> ) ] * n <NEWLINE> prev = [ - 1 ] * n <NEWLINE> dist [ 0 ] = 0 <NEWLINE> que . append ( 0 ) <NEWLINE> while que : <NEWLINE> <INDENT> now = que . popleft ( ) <NEWLINE> for edge in edges [ now ] : <NEWLINE> <INDENT> if dist [ edge ] > dist [ now ] + 1 : <NEWLINE> <INDENT> dist [ edge ] = dist [ now ] + 1 <NEWLINE> prev [ edge ] = now + 1 <NEWLINE> que . append ( edge ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> print ( prev [ i ] ) <NEWLINE> <NL> <DEDENT>
from collections import deque <NEWLINE> N , Q = ( int ( x ) for x in input ( ) . split ( ) ) <NEWLINE> connection = { i : [ ] for i in range ( 1 , N + 1 ) } <NEWLINE> <COMMENT> <NL> for i in range ( 1 , N ) : <NEWLINE> <INDENT> a , b = ( int ( x ) for x in input ( ) . split ( ) ) <NEWLINE> connection [ a ] . append ( b ) <NEWLINE> connection [ b ] . append ( a ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> point = { i : 0 for i in range ( 1 , N + 1 ) } <NEWLINE> for i in range ( 1 , Q + 1 ) : <NEWLINE> <INDENT> p , x = ( int ( x ) for x in input ( ) . split ( ) ) <NEWLINE> point [ p ] = x <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> dq = deque ( ) <NEWLINE> dq . append ( 1 ) <NEWLINE> passed = { i : 0 for i in range ( 1 , N + 1 ) } <COMMENT> <NEWLINE> while dq : <NEWLINE> <INDENT> now = dq . pop ( ) <NEWLINE> passed [ now ] = 1 <NEWLINE> for next in connection [ now ] : <NEWLINE> <INDENT> if passed [ next ] == 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> point [ next ] += point [ now ] <NEWLINE> dq . append ( next ) <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> print ( * point . values ( ) ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( n ) ] <NEWLINE> b = [ [ 0 ] * n for j in range ( n ) ] <NEWLINE> bb = [ ] <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> bb . append ( i ) <NEWLINE> <DEDENT> c = [ ] <NEWLINE> d = [ 0 ] * n - 1 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( n ) : <NEWLINE> <INDENT> b [ a [ i ] [ 0 ] [ a [ i ] [ 1 ] ] = a [ i ] [ 1 ] <NEWLINE> b [ a [ i ] [ 1 ] ] [ a [ i ] [ 0 ] ] = a [ i ] [ 0 ] <NEWLINE> <DEDENT> <DEDENT> while len ( bb ) != 0 : <NEWLINE> <INDENT> for i in range ( n ) : <NEWLINE> <INDENT> if b [ i ] [ j ] == 1 : <NEWLINE> <INDENT> c . append ( b [ i ] [ j ] ) <NEWLINE> bb . deque ( b [ i ] [ j ] ) <NEWLINE> d [ b [ i ] [ j ] ] = i + 1 <NEWLINE> print ( b [ i ] [ j ] + 1 ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
from collections import deque <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> arr = [ [ ] for i in range ( n ) ] <NEWLINE> for _ in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> arr [ a - 1 ] . append ( b - 1 ) <NEWLINE> arr [ b - 1 ] . append ( a - 1 ) <NEWLINE> <DEDENT> q = deque ( ) <NEWLINE> q . append ( 0 ) <NEWLINE> ans = [ - 1 ] * n <NEWLINE> ans [ 0 ] = 0 <NEWLINE> while q : <NEWLINE> <INDENT> now = q . popleft ( ) <NEWLINE> for i in ab [ now ] : <NEWLINE> <INDENT> if ans [ i ] == - 1 : <NEWLINE> <INDENT> ans [ i ] = now + 1 <NEWLINE> q . append ( i ) <NEWLINE> <DEDENT> <DEDENT> if len ( q ) == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> print ( ans [ i ] ) <NEWLINE> <NL> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> r = [ [ ] for x in range ( n ) ] <NEWLINE> for c in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> r [ a - 1 ] . append ( b - 1 ) <NEWLINE> r [ b - 1 ] . append ( a - 1 ) <NEWLINE> <DEDENT> s = [ - 1 ] * n <NEWLINE> u = [ 0 ] <NEWLINE> k = 1 <NEWLINE> for c in range ( 10 ** 5 ) : <NEWLINE> <INDENT> v = [ ] <NEWLINE> <INDENT> for d in u : <NEWLINE> <INDENT> for e in r [ d ] : <NEWLINE> <INDENT> if s [ e ] == - 1 : <NEWLINE> <INDENT> s [ e ] = d <NEWLINE> k += 1 <NEWLINE> v . append ( e ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if k > n - 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> u = v <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> for c in range ( n - 1 ) : <NEWLINE> <INDENT> print ( s [ c + 1 ] + 1 ) <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> g = [ [ ] for x in range ( n ) ] <NEWLINE> for c in range ( M ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> g [ a - 1 ] . append ( b - 1 ) <NEWLINE> g [ b - 1 ] . append ( a - 1 ) <NEWLINE> <NL> <DEDENT> ans_list = [ - 1 ] * n <NEWLINE> <NL> queue = [ 0 ] <NEWLINE> <NL> while queue : <NEWLINE> <INDENT> qi = queue . pop ( 0 ) <NEWLINE> for gi in g [ qi ] : <NEWLINE> <INDENT> if ans_list [ gi ] == - 1 : <NEWLINE> <INDENT> queue . append ( gi ) <NEWLINE> ans_list [ gi ] = qi <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> for ans in ans_list [ 1 : ] : <NEWLINE> <INDENT> print ( ans + 1 ) <NEWLINE> <DEDENT>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> link = [ [ ] for i in range ( N ) ] <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> link [ A - 1 ] . append ( B - 1 ) <NEWLINE> link [ B - 1 ] . append ( A - 1 ) <NEWLINE> <DEDENT> visited = [ False for i in range ( N ) ] <NEWLINE> result = [ 0 ] * N <NEWLINE> Q = [ 0 ] <NEWLINE> visited [ 0 ] = True <NEWLINE> while Q : <NEWLINE> <INDENT> v = Q . pop ( 0 ) <NEWLINE> for i in link [ v ] : <NEWLINE> <INDENT> if visited [ i ] == False : <NEWLINE> <INDENT> visited [ i ] == True <NEWLINE> result [ i ] = v <NEWLINE> Q . append ( i ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> print ( result [ i ] + 1 ) <NEWLINE> <DEDENT>
import sys <NEWLINE> from math import cos , radians , pi , sqrt <NEWLINE> import numpy as np <NEWLINE> <NL> head = input ( ) . split ( ) <NEWLINE> <NL> N = int ( head [ 0 ] ) <NEWLINE> M = int ( head [ 1 ] ) <NEWLINE> inputs = [ input ( ) for i in range ( M ) ] <NEWLINE> <NL> vector = np . zeros ( ( N , N ) ) <NEWLINE> for i in range ( 0 , M ) : <NEWLINE> <INDENT> param = inputs [ i ] . split ( ) <NEWLINE> A = int ( param [ 0 ] ) <NEWLINE> B = int ( param [ 1 ] ) <NEWLINE> vector [ A - 1 : A , B - 1 : B ] = 1 <NEWLINE> vector [ B - 1 : B , A - 1 : A ] = 1 <NEWLINE> <NL> <DEDENT> depth = np . zeros ( ( 1 , N ) ) <NEWLINE> que = [ 0 ] <NEWLINE> <NL> try : <NEWLINE> <INDENT> while not que == [ ] : <NEWLINE> room = que [ 0 ] <NEWLINE> que . pop ( 0 ) <NEWLINE> search = np . where ( vector [ room : room + 1 ] == 1 ) [ 1 ] <NEWLINE> for next_room in search : <NEWLINE> <INDENT> if not depth [ : , next_room : next_room + 1 ] == 0 or next_room == 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> depth [ : , next_room : next_room + 1 ] = depth [ : , room : room + 1 ] + 1 <NEWLINE> que . append ( next_room ) <NEWLINE> <DEDENT> <DEDENT> except Exception as e : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> return 0 <NEWLINE> <NL> <DEDENT> if 0 in depth [ : , 1 : ] [ 0 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> for dep in depth [ : , 1 : ] [ 0 ] : <NEWLINE> <INDENT> print ( np . where ( depth == dep - 1 ) [ 1 ] [ 0 ] + 1 ) <NEWLINE> <DEDENT> <DEDENT>
from sys import stdin <NEWLINE> from collections import deque <NEWLINE> <NL> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> ab = [ [ ] for _ in range ( n ) ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , readline ( ) . split ( ) ) <NEWLINE> a -= 1 <NEWLINE> b -= 1 <NEWLINE> ab [ a ] . append ( b ) <NEWLINE> ab [ b ] . append ( a ) <NEWLINE> <DEDENT> queue = [ 0 ] <NEWLINE> ans = [ - 1 ] * n <NEWLINE> ans [ 0 ] = 0 <NEWLINE> while len ( queue ) != 0 : <NEWLINE> <INDENT> now_check = queue . pop ( 0 ) <NEWLINE> for i in ab [ now_check ] : <NEWLINE> <INDENT> if ans [ i ] == - 1 : <NEWLINE> <INDENT> queue . append ( i ) <NEWLINE> ans [ i ] = now_check <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> print ( ans [ i ] + 1 ) <NEWLINE> <DEDENT>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> E = [ [ ] for _ in range ( N ) ] <NEWLINE> for _ in range ( M ) : <NEWLINE> <INDENT> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> E [ A - 1 ] += [ B - 1 ] <NEWLINE> E [ B - 1 ] += [ A - 1 ] <NEWLINE> <NL> <DEDENT> ans = [ - 1 ] * N <NEWLINE> T = [ 0 ] <NEWLINE> while len ( T ) > 0 : <NEWLINE> <INDENT> P = T <NEWLINE> T = [ ] <NEWLINE> for x in P : <NEWLINE> <INDENT> for e in E [ x ] : <NEWLINE> <INDENT> if ans [ e ] == - 1 : <NEWLINE> <INDENT> T += [ e ] <NEWLINE> ans [ e ] = x <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print <STRING> <NEWLINE> for a in ans [ 1 : ] : <NEWLINE> <INDENT> print ( a + 1 ) <NEWLINE> <DEDENT>
import networkx as nx <NEWLINE> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> E = [ list ( map ( input ( ) . split ( ) ) ) for i in range ( M ) ] <NEWLINE> <NL> G = nx . Graph ( ) <NEWLINE> G . add_edges_from ( E ) <NEWLINE> di = nx . predecessor ( G , source = 1 ) <NEWLINE> <NL> print ( <STRING> ) <NEWLINE> for i in range ( 2 , N + 1 ) : <NEWLINE> <INDENT> print ( di [ i ] [ 0 ] ) <NEWLINE> <DEDENT>
from collections import deque <NEWLINE> n , m = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> rutes = [ [ ] ] * n <NEWLINE> visited = [ 0 ] + [ - 1 ] * ( n - 1 ) <NEWLINE> q = deque ( [ 0 ] ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> a , b = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> rutes [ a - 1 ] . append ( b ) <NEWLINE> rutes [ b - 1 ] . append ( a ) <NEWLINE> <NL> <DEDENT> cnt = 0 <NEWLINE> def visit ( x ) : <NEWLINE> <INDENT> for i in rutes [ x - 1 ] : <NEWLINE> <INDENT> if visited [ i ] == - 1 : <NEWLINE> <INDENT> q . append ( i ) <NEWLINE> visited [ i - 1 ] = visited [ x - 1 ] + 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> while len ( q ) > 0 : <NEWLINE> <INDENT> tmp = q . pop ( ) <NEWLINE> visit ( tmp ) <NEWLINE> <NL> <DEDENT> for i in range ( 2 , n + 1 ) : <NEWLINE> <INDENT> print ( visited [ i - 1 ] ) <NEWLINE> <DEDENT>
n , m = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> room = [ [ ] for i in range ( n ) ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> a , b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> room [ a - 1 ] . append ( b - 1 ) <NEWLINE> room [ b - 1 ] . append ( a - 1 ) <NEWLINE> <NL> <NL> <DEDENT> def search ( i ) : <NEWLINE> <INDENT> q = deque ( ) <NEWLINE> q . append ( i ) <NEWLINE> while q : <NEWLINE> <INDENT> x = q . popleft ( ) <NEWLINE> if 0 in room [ x ] : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( len ( room [ x ] ) ) : <NEWLINE> <INDENT> q . append ( room [ x ] [ i ] ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> if 0 in room [ i ] : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a = search ( i ) <NEWLINE> print ( a + 1 ) <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> <NL> <COMMENT> <NL> from fractions import gcd <NEWLINE> from collections import Counter , deque , defaultdict <NEWLINE> from heapq import heappush , heappop , heappushpop , heapify , heapreplace , merge <NEWLINE> from bisect import bisect_left , bisect_right , bisect , insort_left , insort_right , insort <NEWLINE> from itertools import accumulate , product , permutations , combinations , combinations_with_replacement <NEWLINE> import copy <NEWLINE> <NL> N , M = [ int ( _ ) for _ in input ( ) . split ( ) ] <NEWLINE> AB = [ [ int ( _ ) for _ in input ( ) . split ( ) ] for i in range ( M ) ] <NEWLINE> <NL> goal = 1 <NEWLINE> rets = [ ] <NEWLINE> road = { i : [ ] for i in range ( 1 , N + 1 ) } <NEWLINE> <NL> for A , B in AB : <NEWLINE> <INDENT> road [ A ] += [ B ] <NEWLINE> road [ B ] += [ A ] <NEWLINE> <NL> <DEDENT> if not road [ 1 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> retdict = { i : 0 for i in range ( 1 , N + 1 ) } <NEWLINE> retdict_dis = { i : 1000000 for i in range ( 1 , N + 1 ) } <NEWLINE> <NL> def dfs ( bef , mark , ind , dis ) : <NEWLINE> <NL> <INDENT> global retdict , retdict_dis <NEWLINE> if mark [ ind ] == 1 : <NEWLINE> <INDENT> return <NEWLINE> <NL> <DEDENT> mark [ ind ] = 1 <NEWLINE> if retdict_dis [ ind ] > dis : <NEWLINE> <INDENT> retdict [ ind ] = bef <NEWLINE> retdict_dis [ ind ] = dis <NEWLINE> <NL> <DEDENT> bef = ind <NEWLINE> dis += 1 <NEWLINE> <NL> for i in road [ ind ] : <NEWLINE> <INDENT> dfs ( bef , dict . copy ( mark ) , i , dis ) <NEWLINE> <NL> <DEDENT> <DEDENT> dfs ( 0 , { i : 0 for i in range ( 1 , N + 1 ) } , 1 , 0 ) <NEWLINE> <NL> print ( <STRING> ) <NEWLINE> for i in range ( 2 , N + 1 ) : <NEWLINE> <INDENT> print ( retdict [ i ] ) <NEWLINE> <DEDENT>
from collections import deque <NEWLINE> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> map_li = [ [ ] for i in range ( n ) ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> a , b = a - 1 , b - 1 <NEWLINE> map_li [ a ] . append ( b ) <NEWLINE> map_li [ b ] . append ( a ) <NEWLINE> <NL> <DEDENT> ans_li = [ - 1 ] * n <NEWLINE> queue = deque ( [ 0 ] ) <NEWLINE> visited = [ False ] * n <NEWLINE> <NL> while queue : <NEWLINE> <INDENT> x = queue . pop ( 0 ) <NEWLINE> for g in map_li [ x ] : <NEWLINE> <INDENT> if visited [ g ] == False : <NEWLINE> <INDENT> queue . append ( g ) <NEWLINE> if ans_li [ g ] == - 1 : <NEWLINE> <INDENT> ans_li [ g ] = x <NEWLINE> visited [ g ] = True <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if - 1 in ans_li [ 1 : ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> for ans in ans_li [ 1 : ] : <NEWLINE> <INDENT> print ( ans + 1 ) <NEWLINE> <DEDENT> <DEDENT>
from collections import deque <NEWLINE> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <NL> graph = [ [ ] for _ in range ( n + 1 ) ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> graph [ a ] . append ( b ) <NEWLINE> graph [ b ] . append ( a ) <NEWLINE> <NL> <DEDENT> print ( graph ) <NEWLINE> <NL> dist = [ - 1 ] * 2 + [ 0 for i in range ( n - 1 ) ] <NEWLINE> dist [ 1 ] = 0 <NEWLINE> d = deque ( [ 1 ] ) <NEWLINE> print ( d ) <NEWLINE> <NL> while d : <NEWLINE> <INDENT> v = d . popleft ( ) <NEWLINE> graph . remove ( v ) <NEWLINE> for i in graph [ v ] : <NEWLINE> <INDENT> if dist [ i ] == 0 : <NEWLINE> <INDENT> dist [ i ] = v <NEWLINE> d . append ( i ) <NEWLINE> print ( i , <STRING> , dist [ i ] , d ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> ans = dist [ 2 : ] <NEWLINE> print ( * ans , sep = <STRING> ) <NEWLINE>
from collections import defaultdict <NEWLINE> N , M = map ( int , input ( ) . strip ( ) . split ( ) ) <NEWLINE> G = defaultdict ( list ) <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> u , v = map ( int , input ( ) . strip ( ) . split ( ) ) <NEWLINE> G [ u ] . append ( v ) <NEWLINE> G [ v ] . append ( V ) <NEWLINE> <DEDENT> dist = [ ( - 1 , parent ) ] * ( N + 1 ) <NEWLINE> valid = False <NEWLINE> Q = [ 1 ] <NEWLINE> visited = [ False ] * ( N + 1 ) <NEWLINE> while ( len ( Q ) != 0 ) : <NEWLINE> <INDENT> top = Q [ 0 ] <NEWLINE> Q . pop ( 0 ) <NEWLINE> for u in G [ top ] : <NEWLINE> <INDENT> if not visited [ u ] : <NEWLINE> <INDENT> Q . append ( u ) <NEWLINE> dist [ u ] [ 0 ] = 1 + dist [ top ] [ 0 ] <NEWLINE> dist [ u ] [ 1 ] = top <NEWLINE> visited [ u ] = True <NEWLINE> <DEDENT> <DEDENT> <DEDENT> for pair in dist [ 1 : ] : <NEWLINE> <INDENT> if pair [ 0 ] == - 1 : <NEWLINE> <INDENT> valid = True <NEWLINE> print ( <STRING> ) <NEWLINE> return <NEWLINE> <DEDENT> <DEDENT> if not valid : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> for pair in dist [ 1 : ] : <NEWLINE> <INDENT> print ( pair [ 1 ] ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT>
from collections import deque <NEWLINE> <NL> N , M = map ( int , sys . stdin . readline ( ) . split ( ) ) <NEWLINE> p = [ ] <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> p . append ( list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) ) <NEWLINE> <NL> <DEDENT> graph = [ [ ] for _ in range ( N + 1 ) ] <NEWLINE> for pi in p : <NEWLINE> <INDENT> graph [ pi [ 0 ] ] . append ( pi [ 1 ] ) <NEWLINE> graph [ pi [ 1 ] ] . append ( pi [ 0 ] ) <NEWLINE> <NL> <DEDENT> q = deque ( [ 1 ] ) <NEWLINE> p = [ 0 ] * ( N + 1 ) <NEWLINE> p [ 1 ] = 1 <NEWLINE> while q : <NEWLINE> <INDENT> u = q . popleft ( ) <NEWLINE> for v in graph [ u ] : <NEWLINE> <INDENT> if not p [ v ] : <NEWLINE> <INDENT> p [ v ] = u <NEWLINE> q . append ( v ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> result = p [ 2 : ] <NEWLINE> <NL> if all ( result ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> [ print ( r ) for r in result ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
6 9 <NEWLINE> 3 4 <NEWLINE> 6 1 <NEWLINE> 2 4 <NEWLINE> 5 3 <NEWLINE> 4 6 <NEWLINE> 1 5 <NEWLINE> 6 2 <NEWLINE> 4 5 <NEWLINE> 5 6 <NEWLINE>
import queue <NEWLINE> <NL> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> graph = [ [ ] for i in range ( N ) ] <NEWLINE> <NL> for i in range ( M ) : <NEWLINE> <INDENT> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> A -= 1 <NEWLINE> B -= 1 <NEWLINE> graph [ A ] . append ( B ) <NEWLINE> graph [ B ] . append ( A ) <NEWLINE> <NL> <DEDENT> dist = [ - 1 for i in range ( N ) ] <NEWLINE> que = queue . Queue ( ) <NEWLINE> <NL> dist [ 0 ] = 0 <NEWLINE> que . put ( 0 ) <NEWLINE> <NL> <NL> while not que . empty ( ) : <NEWLINE> <INDENT> v = que . get ( ) <NEWLINE> for nv in graph [ v ] : <NEWLINE> <INDENT> if dist [ nv ] != - 1 : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <DEDENT> dist [ nv ] = dist [ v ] + 1 <NEWLINE> que . push ( nv ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> print ( v [ i ] + 1 ) <NEWLINE> <DEDENT>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> A , B = [ ] , [ ] <NEWLINE> dic = { i : [ ] for i in range ( 1 , N + 1 ) } <NEWLINE> for _ in range ( M ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> dic [ a ] . append ( b ) <NEWLINE> dic [ b ] . append ( a ) <NEWLINE> <NL> <DEDENT> node = [ float ( <STRING> ) ] * N <NEWLINE> node [ 0 ] = 0 <COMMENT> <NEWLINE> route = [ 0 ] * N <COMMENT> <NEWLINE> rooms = [ 1 ] <COMMENT> <NEWLINE> st = ( 1 ) <NEWLINE> <NL> for r1 in rooms : <NEWLINE> <INDENT> for r2 in dic [ r1 ] : <NEWLINE> <INDENT> if node [ r1 - 1 ] + 1 <= node [ r2 - 1 ] : <NEWLINE> <INDENT> node [ r2 - 1 ] = node [ r1 - 1 ] + 1 <NEWLINE> route [ r2 - 1 ] = r1 <NEWLINE> if not r2 in st : <NEWLINE> <INDENT> rooms . append ( r2 ) <NEWLINE> st . add ( r2 ) <NEWLINE> <DEDENT> try : <NEWLINE> <INDENT> dic [ r2 ] . remove ( r1 ) <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if float ( <STRING> ) in node : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> for i in route [ 1 : ] : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> import sys <NEWLINE> import numpy as np <NEWLINE> from collections import deque <NEWLINE> <NL> <NL> <COMMENT> <NL> N , M = [ int ( x ) for x in sys . stdin . readline ( ) . split ( ) ] <NEWLINE> g = [ [ ] for _ in range ( M ) ] <NEWLINE> <NL> for _ in range ( M ) : <NEWLINE> <INDENT> a , b = [ int ( x ) for x in sys . stdin . readline ( ) . split ( ) ] <NEWLINE> g [ a ] . append ( b ) <NEWLINE> g [ b ] . append ( a ) <NEWLINE> <NL> <NL> <NL> <DEDENT> quetmp = deque ( [ 1 ] ) <NEWLINE> d = [ None ] * ( N + 1 ) <NEWLINE> d [ 1 ] = 0 <NEWLINE> num_crew = 1 <NEWLINE> while quetmp : <NEWLINE> <INDENT> v = quetmp . popleft ( ) <NEWLINE> for i in g [ v ] : <NEWLINE> <INDENT> print ( i ) <NEWLINE> print ( d [ i ] ) <NEWLINE> if d [ i ] is None : <NEWLINE> <INDENT> d [ i ] = v <NEWLINE> quetmp . append ( i ) <NEWLINE> num_crew = num_crew + 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if num_crew == N : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> print ( d [ i + 1 ] ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import sys <NEWLINE> read = sys . stdin . buffer . read <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> readlines = sys . stdin . buffer . readlines <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> from collections import deque as d <NEWLINE> N , M = map ( int , readline ( ) . split ( ) ) <NEWLINE> m = map ( int , read ( ) . split ( ) ) <NEWLINE> AB = zip ( m , m ) <NEWLINE> graph = [ [ ] for _ in range ( N + 1 ) ] <NEWLINE> for a , b in AB : <NEWLINE> <INDENT> graph [ a ] . append ( b ) <NEWLINE> graph [ b ] . append ( a ) <NEWLINE> <DEDENT> que = [ 1 ] <NEWLINE> stack = [ 1 ] <NEWLINE> ans = [ 0 ] * ( N + 1 ) <NEWLINE> while que : <NEWLINE> <INDENT> x = d . popleft ( que ) <NEWLINE> for i in graph [ x ] : <NEWLINE> <INDENT> if ans [ x ] == 0 : <NEWLINE> <INDENT> ans [ x ] = x <NEWLINE> <DEDENT> stack . append ( i ) <NEWLINE> <DEDENT> <DEDENT> for a in ans [ 2 : ] : <NEWLINE> <INDENT> if a == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> print ( <STRING> . join ( map ( str , ans [ 2 : ] ) <NEWLINE> <NL> <DEDENT> return <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
from collections import deque <NEWLINE> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> G = [ [ ] for _ in range ( N + 1 ) ] <NEWLINE> <NL> for i in range ( M ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> G [ x ] . append ( y ) <NEWLINE> G [ y ] . append ( x ) <NEWLINE> <NL> <DEDENT> USED = [ - 1 ] * ( N + 1 ) <NEWLINE> USED [ 0 ] = 0 <NEWLINE> USED [ 1 ] = 0 <NEWLINE> <NL> Q = deque ( ) <NEWLINE> Q . append ( 1 ) <NEWLINE> <NL> while Q : <NEWLINE> <INDENT> x = Q . pop ( ) <NEWLINE> for t in G [ x ] : <NEWLINE> <INDENT> if USED [ t ] == - 1 : <NEWLINE> <INDENT> Q . appendleft ( t ) <NEWLINE> USED [ t ] = x <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if - 1 in USED : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> print ( * USE [ 2 : ] ) <NEWLINE> <DEDENT>
import sys <NEWLINE> n , m = map ( int , sys . stdin . readline ( ) . rstrip ( <STRING> ) . split ( ) ) <NEWLINE> adj = [ [ ] for i in range ( n + 1 ) ] <NEWLINE> parent = [ - 1 ] * ( n + 1 ) <NEWLINE> for line in sys . stdin : <NEWLINE> <INDENT> a , b = map ( int , line . rstrip ( <STRING> ) . split ( ) ) <NEWLINE> adj [ a ] . append ( b ) <NEWLINE> adj [ b ] . append ( a ) <NEWLINE> <DEDENT> q = queue . Queue ( ) <NEWLINE> q . put ( ( 1 , 0 ) ) <NEWLINE> while ( not q . empty ( ) ) : <NEWLINE> <INDENT> x , p = q . get ( ) <NEWLINE> if parent [ x ] != - 1 : <COMMENT> <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> parent [ x ] = p <NEWLINE> for next in adj [ x ] : <NEWLINE> <INDENT> if parent [ next ] == - 1 : <COMMENT> <NEWLINE> <INDENT> q . put ( ( next , x ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <COMMENT> <NEWLINE> for p in parent [ 2 : ] : <COMMENT> <NEWLINE> <INDENT> print ( p ) <NEWLINE> <DEDENT>
<COMMENT> <NL> def dijkstra_back ( s , t , n , w , cost ) : <NEWLINE> <COMMENT> <NL> <INDENT> prev = [ s ] * n <COMMENT> <NEWLINE> d = [ float ( <STRING> ) ] * n <NEWLINE> used = [ False ] * n <NEWLINE> d [ s ] = 0 <NEWLINE> <NL> while True : <NEWLINE> <INDENT> v = - 1 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if ( not used [ i ] ) and ( v == - 1 ) : <NEWLINE> <INDENT> v = i <NEWLINE> <DEDENT> elif ( not used [ i ] ) and d [ i ] < d [ v ] : <NEWLINE> <INDENT> v = i <NEWLINE> <DEDENT> <DEDENT> if v == - 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> used [ v ] = True <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> if d [ i ] > d [ v ] + cost [ v ] [ i ] : <NEWLINE> <INDENT> d [ i ] = d [ v ] + cost [ v ] [ i ] <NEWLINE> prev [ i ] = v <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> path = [ t ] <NEWLINE> while prev [ t ] != s : <NEWLINE> <INDENT> path . append ( prev [ t ] ) <NEWLINE> prev [ t ] = prev [ prev [ t ] ] <NEWLINE> <DEDENT> path . append ( s ) <NEWLINE> path = path [ : : - 1 ] <NEWLINE> return path <NEWLINE> <NL> <NL> <DEDENT> from scipy . sparse . csgraph import csgraph_from_dense , dijkstra <NEWLINE> <NL> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> edge = [ [ 10 ** 9 for j in range ( N + 1 ) ] for i in range ( N + 1 ) ] <NEWLINE> <NL> for i in range ( M ) : <NEWLINE> <INDENT> a , b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> edge [ a ] [ b ] = 1 <NEWLINE> edge [ b ] [ a ] = 1 <NEWLINE> <NL> <DEDENT> G = csgraph_from_dense ( edge , null_value = 10 ** 9 ) <NEWLINE> d = dijkstra ( G , indices = 1 ) <NEWLINE> ck = 0 <NEWLINE> for i in range ( 2 , len ( d ) ) : <NEWLINE> <INDENT> if d [ i ] == float ( <STRING> ) : <NEWLINE> <INDENT> ck = 1 <NEWLINE> <DEDENT> <DEDENT> if ck == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> for i in range ( 2 , len ( d ) ) : <NEWLINE> <INDENT> d = dijkstra_back ( 1 , i , N , M , edge ) <NEWLINE> print ( d [ - 2 ] ) <NEWLINE> <DEDENT> <DEDENT>
def bfs_opt ( s ) : <NEWLINE> <INDENT> signs [ s ] = 0 <NEWLINE> Q . append ( s ) <NEWLINE> while len ( Q ) > 0 : <NEWLINE> <INDENT> u = Q . popleft ( ) <NEWLINE> for v in rooms [ u ] : <NEWLINE> <INDENT> if signs [ v ] == INFTY : <NEWLINE> <INDENT> signs [ v ] = u <NEWLINE> Q . append ( v ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> rooms = [ [ ] for i in range ( n ) ] <NEWLINE> <NL> <COMMENT> <NL> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> rooms [ a - 1 ] . append ( b - 1 ) <NEWLINE> rooms [ b - 1 ] . append ( a - 1 ) <NEWLINE> <NL> <DEDENT> INFTY = float ( <STRING> ) <NEWLINE> signs = [ INFTY ] * n <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> Q = deque ( ) <NEWLINE> <NL> bfs_opt ( 0 ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> print ( <STRING> ) <NEWLINE> signs = signs [ 1 : ] <NEWLINE> for sign in signs : <NEWLINE> <INDENT> print ( sign + 1 ) <NEWLINE> <DEDENT>
from collections import deque <NEWLINE> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> root = [ set ( ) for i in range ( N + 1 ) ] <NEWLINE> ans = [ 0 for i in range ( N + 1 ) ] <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> root [ a ] . add ( b ) <NEWLINE> root [ b ] . add ( a ) <NEWLINE> <DEDENT> task = deque ( [ 1 ] ) <NEWLINE> itta = { 1 } <NEWLINE> while len ( task ) > 0 : <NEWLINE> <INDENT> now = task . pop ( ) <NEWLINE> additional = root [ now ] - itta <NEWLINE> for i in additional : <NEWLINE> <INDENT> ans [ i ] = now <NEWLINE> itta . add ( i ) <NEWLINE> <DEDENT> task . append ( list ( additional ) ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> for i in range ( 2 , N + 1 ) : <NEWLINE> <INDENT> print ( ans [ i ] ) <NEWLINE> <DEDENT>
from collections import deque <NEWLINE> import sys <NEWLINE> def bfs ( graph , N , start ) : <NEWLINE> <INDENT> visited = [ 0 ] * N <NEWLINE> visited [ start ] = 1 <NEWLINE> que = deque ( [ start ] ) <NEWLINE> while que : <NEWLINE> <INDENT> node = que . popleft ( ) <NEWLINE> for n in graph [ node ] : <NEWLINE> <INDENT> if not visited [ n ] : <NEWLINE> <INDENT> visited [ n ] = node + 1 <NEWLINE> que . append ( n ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return visited <NEWLINE> <NL> <DEDENT> input = sys . stdin . readline <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> graph = [ [ ] for i in range ( N ) ] <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> A , B = map ( lambda n : int ( n ) - 1 , input ( ) . split ( ) ) <NEWLINE> graph [ A ] . append ( B ) <NEWLINE> graph [ B ] . append ( A ) <NEWLINE> <NL> <DEDENT> visited = bfs ( graph , N , 0 ) [ 1 : ] <NEWLINE> if all ( visited ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> print ( * visited , seq = <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> main ( ) <NEWLINE>
from collections import deque <NEWLINE> inf = 10 ** 7 <NEWLINE> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> P = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( M ) ] <NEWLINE> a = [ [ ] for i in range ( N ) ] <NEWLINE> for i in P : <NEWLINE> <INDENT> a [ i [ 0 ] - 1 ] . append ( i [ 1 ] - 1 ) <NEWLINE> a [ i [ 1 ] - 1 ] . append ( i [ 0 ] - 1 ) <NEWLINE> <DEDENT> path = [ - 1 ] * N <NEWLINE> path [ 0 ] = 0 <NEWLINE> checked = [ False ] * N <NEWLINE> stack = deque ( [ ( 0 , 0 ) ] ) <NEWLINE> while ( len ( stack ) != 0 ) : <NEWLINE> <INDENT> kk = stack . pop ( 0 ) <NEWLINE> now = kk [ 0 ] <NEWLINE> pre = kk [ 1 ] <NEWLINE> if not checked [ now ] : <NEWLINE> <INDENT> nextP = a [ now ] <NEWLINE> checked [ now ] = True <NEWLINE> path [ now ] = pre <NEWLINE> for i in nextP : <NEWLINE> <INDENT> stack . append ( ( i , now ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if False in checked : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> for i in path [ 1 : ] : <NEWLINE> <INDENT> print ( i + 1 ) <NEWLINE> <NL> <NL> <NL> <DEDENT> <DEDENT>
( n , m ) , * e = [ [ * map ( int , t . split ( ) ) ] for t in input ( ) ] <NEWLINE> t = [ [ ] for _ in range ( n + 1 ) ] <NEWLINE> for a , b in e : t [ a ] += [ b ] ; t [ b ] += [ a ] <NEWLINE> q = [ 1 ] <NEWLINE> a = [ 0 ] * - ~ n <NEWLINE> while q : q = [ a [ j ] == 0 and ( a . __setitem__ ( j , i ) or j ) for i in q for j in t [ i ] ] <NEWLINE> print ( <STRING> , * a [ 2 : ] ) <NEWLINE>
from collections import deque <NEWLINE> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> def vertex_node ( ) -> list : <NEWLINE> <INDENT> v_c = [ [ ] for _ in range ( n + 1 ) ] <NEWLINE> v = [ i . split ( ) for i in q . split ( <STRING> ) ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> v_c [ a ] . append ( b ) <NEWLINE> v_c [ b ] . append ( a ) <NEWLINE> <DEDENT> return v_c <NEWLINE> <NL> <DEDENT> def bfs ( l ) -> list : <NEWLINE> <INDENT> dist = [ - 1 ] * ( n + 1 ) <NEWLINE> dist [ 0 ] = 0 <NEWLINE> dist [ 1 ] = 0 <NEWLINE> d = deque ( ) <NEWLINE> d . append ( 1 ) <NEWLINE> while d : <NEWLINE> <INDENT> v = d . popleft ( ) <NEWLINE> for i in l [ v ] : <NEWLINE> <INDENT> if dist [ i ] != - 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> dist [ i ] = dist [ v ] + 1 <NEWLINE> d . append ( i ) <NEWLINE> <DEDENT> <DEDENT> return dist <NEWLINE> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> i = vertex_node ( ) <NEWLINE> ans = bfs ( i ) [ 2 : ] <NEWLINE> print ( * ans ) <NEWLINE> <DEDENT>
v <NEWLINE> from collections import deque <NEWLINE> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> l = [ [ 0 ] for _ in range ( n + 1 ) ] <NEWLINE> vi = [ 0 ] * ( n + 1 ) <NEWLINE> <NL> for _ in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> l [ a ] . append ( b ) <NEWLINE> l [ b ] . append ( a ) <NEWLINE> <DEDENT> d = deque ( [ 1 ] ) <NEWLINE> s = set ( [ 1 ] ) <NEWLINE> <NL> while d : <NEWLINE> <INDENT> x = d . popleft ( ) <NEWLINE> for k in l [ x ] : <NEWLINE> <INDENT> if k not in s : <NEWLINE> <INDENT> s . add ( k ) <NEWLINE> d . appendleft ( k ) <NEWLINE> vi [ k ] = x <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> for i in vi [ 2 : ] : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> AB = [ tuple ( map ( int , input ( ) . split ( ) ) ) for i in range ( M ) ] <NEWLINE> <NL> es = [ [ ] for _ in range ( N ) ] <NEWLINE> for a , b in AB : <NEWLINE> <INDENT> es [ a - 1 ] . append ( b - 1 ) <NEWLINE> es [ b - 1 ] . append ( a - 1 ) <NEWLINE> <NL> <DEDENT> ans = [ - 1 ] * N <NEWLINE> ans [ 0 ] = 0 <NEWLINE> <NL> from collections import deque <NEWLINE> que = deque <NEWLINE> que . insert ( 0 ) <NEWLINE> <NL> while que : <NEWLINE> <INDENT> s = que . popleft ( ) <NEWLINE> for v in es [ s ] : <NEWLINE> <INDENT> if ans [ v ] == - 1 : <NEWLINE> <INDENT> ans [ v ] = s + 1 <NEWLINE> que . put ( v ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> print ( * ans [ 1 : ] , sep = <STRING> ) <NEWLINE>
import networkx as nx <NEWLINE> n , m , * s = map ( int , open ( 0 ) . read ( ) . split ( ) ) <NEWLINE> <NL> g = nx . Graph ( ) <NEWLINE> g . add_nodes_from ( [ i for i in range ( 1 , n + 1 ) ] ) <NEWLINE> <NL> for x in s : <NEWLINE> <INDENT> g . add_edge ( x [ 0 ] , x [ 1 ] ) <NEWLINE> <DEDENT> di = nx . predecessor ( g , source = 1 ) <NEWLINE> <NL> if len ( di ) != n : <NEWLINE> <INDENT> print ( <STRING> ) ; exit ( ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> for x in range ( 2 , n + 1 ) : <NEWLINE> <INDENT> print ( di [ x ] [ 0 ] ) <NEWLINE> <DEDENT>
from collections import deque <NEWLINE> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> ab = [ [ ] for i in range ( n + 1 ) ] <NEWLINE> <NL> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> ab [ a ] . append ( b ) <NEWLINE> ab [ b ] . append ( a ) <NEWLINE> <NL> <DEDENT> ans = [ - 1 ] * ( n + 1 ) <NEWLINE> que = deque ( [ 1 ] ) <NEWLINE> <NL> while que : <NEWLINE> <INDENT> q = que . popleft ( ) <NEWLINE> for i in ab [ q ] : <NEWLINE> <INDENT> if ans [ i ] == - 1 : <NEWLINE> <INDENT> que . append ( i ) <NEWLINE> ans [ i ] = q <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> <NL> for i range ( 2 , n + 1 ) : <NEWLINE> <INDENT> print ( ans [ i ] ) <NEWLINE> <DEDENT>
import sys <NEWLINE> from collections import defaultdict , Counter , deque <NEWLINE> from itertools import accumulate , permutations , combinations <NEWLINE> from operator import itemgetter <NEWLINE> from bisect import bisect_left , bisect_right , bisect <NEWLINE> from heapq import heappop , heappush <NEWLINE> from fractions import gcd <NEWLINE> from math import ceil , floor , sqrt , cos , sin , pi <NEWLINE> from copy import deepcopy <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> shirube = [ None ] * ( N + 1 ) <NEWLINE> shirube [ 1 ] = ( 1 , 0 ) <NEWLINE> mmap = [ [ ] for _ in range ( N + 1 ) ] <NEWLINE> for _ in range ( M ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> mmap [ a ] . append ( b ) <NEWLINE> mmap [ b ] . append ( a ) <NEWLINE> <DEDENT> queue = deque ( ) <NEWLINE> queue . appendleft ( ( 1 , 0 ) ) <NEWLINE> while queue : <NEWLINE> <INDENT> current_node , distance = queue . pop ( ) <NEWLINE> for next_node in mmap [ current_node ] : <NEWLINE> <INDENT> new_distance = distance + 1 <NEWLINE> if shirube [ next_node ] is None : <NEWLINE> <INDENT> shirube [ next_node ] = ( current_node , new_distance ) <NEWLINE> queue . appendleft ( ( next_node , new_distance ) ) <NEWLINE> <DEDENT> elif shirube [ next_node ] [ 1 ] > new_distance : <NEWLINE> <INDENT> shirube [ next_node ] = ( current_node , new_distance ) <NEWLINE> queue . appendleft ( ( next_node , new_distance ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> shirube = shirube [ 1 : : ] <NEWLINE> if None in shirube : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> return <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> for s in shirube [ 1 : : ] : <NEWLINE> <INDENT> print ( s [ 0 ] ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>  <NEWLINE>
from collections import deque <NEWLINE> <NL> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> L = [ [ ] for i in range ( n ) ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> L [ a - 1 ] . append ( b - 1 ) <NEWLINE> L [ b - 1 ] . append ( a - 1 ) <NEWLINE> <DEDENT> D = [ float ( <STRING> ) for i in range ( n ) ] <NEWLINE> <NL> def bfs ( ) : <NEWLINE> <INDENT> que = deque ( [ ] ) <NEWLINE> que . append ( 0 ) <NEWLINE> D [ p ] = 0 <NEWLINE> while que : <NEWLINE> <INDENT> p = que . popleft ( ) <NEWLINE> for np in L [ p ] : <NEWLINE> <INDENT> if D [ np ] == float ( <STRING> ) : <NEWLINE> <INDENT> que . append ( np ) <NEWLINE> D [ np ] = p <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> bfs ( ) <NEWLINE> <NL> if sum ( D ) == float ( <STRING> ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> print ( D [ i ] ) <NEWLINE> <DEDENT> <DEDENT>
from collections import deque <NEWLINE> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> dist = [ - 1 ] * ( n + 1 ) <NEWLINE> roots = [ [ ] for i in range ( n + 1 ) ] <NEWLINE> <NL> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> roots [ a ] . append ( b ) <NEWLINE> roots [ b ] . append ( a ) <NEWLINE> <NL> <DEDENT> ans = [ - 1 ] * ( n + 1 ) <NEWLINE> ans [ 1 ] = 0 <NEWLINE> dist [ 1 ] = 0 <NEWLINE> q = deque ( ) <NEWLINE> q . append ( 1 ) <NEWLINE> <NL> while q : <NEWLINE> <INDENT> now = q . popleft ( ) <NEWLINE> <NL> for next_v in roots [ now ] : <NEWLINE> <INDENT> if not dist [ next_v ] == - 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> dist [ next_v ] = dist [ now ] + <NEWLINE> ans [ next_v ] = now <NEWLINE> q . append ( next_v ) <NEWLINE> <DEDENT> <DEDENT> if - 1 in ans [ 1 : ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> for i in range ( 2 , len ( ans ) ) : <NEWLINE> <INDENT> print ( ans [ i ] ) <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> import numpy as np <NEWLINE> n , m = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> a = np . array ( [ 0 ] * m ) <NEWLINE> b = np . array ( [ 0 ] * m ) <NEWLINE> ans = np . array ( [ 0 ] * ( n ) ) <NEWLINE> count = np . array ( [ 0 ] * n ) <NEWLINE> roop = 0 <NEWLINE> Checks = np . array ( [ 0 ] ) <COMMENT> <NEWLINE> Next = np . array ( [ ] ) <COMMENT> <NEWLINE> Li = np . array ( [ 1 ] * n ) <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> a [ i ] , b [ i ] = [ int ( j ) - 1 for j in input ( ) . split ( ) ] <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> while np . sum ( Li ) != 0 : <NEWLINE> <INDENT> roop += 1 <NEWLINE> for check in Checks : <NEWLINE> <INDENT> if np . any ( a == check ) : <NEWLINE> <INDENT> ind = np . where ( a == check ) <NEWLINE> nex = b [ ind ] <NEWLINE> ans [ nex ] = check + 1 <NEWLINE> Li [ nex ] = 0 <NEWLINE> <COMMENT> <NL> <DEDENT> if np . any ( b == check ) : <NEWLINE> <INDENT> ind = np . where ( b == check ) <NEWLINE> nex2 = a [ ind ] <NEWLINE> ans [ nex2 ] = check + 1 <NEWLINE> Li [ nex2 ] = 0 <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> Next = np . append ( Next , nex ) <NEWLINE> Next = np . append ( Next , nex2 ) <NEWLINE> Checks = [ ] <NEWLINE> Checks = Next <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> nex = [ ] <NEWLINE> nex2 = [ ] <NEWLINE> <NL> if roop == 1000 : <NEWLINE> <INDENT> break <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> print ( ans [ 1 : ] ) <NEWLINE>
<COMMENT> <NL> <NL> from fractions import gcd <NEWLINE> <COMMENT> <NL> from collections import Counter , deque , defaultdict <NEWLINE> from heapq import heappush , heappop , heappushpop , heapify , heapreplace , merge <NEWLINE> from bisect import bisect_left , bisect_right , bisect , insort_left , insort_right , insort <NEWLINE> from itertools import accumulate , product , permutations , combinations , combinations_with_replacement <NEWLINE> <NL> import copy <NEWLINE> <NL> N , M = [ int ( _ ) for _ in input ( ) . split ( ) ] <NEWLINE> AB = [ [ int ( _ ) for _ in input ( ) . split ( ) ] for i in range ( M ) ] <NEWLINE> <NL> road = [ [ ] for i in range ( N ) ] <NEWLINE> <NL> for ab in AB : <NEWLINE> <INDENT> road [ ab [ 0 ] - 1 ] += [ ab [ 1 ] - 1 ] <NEWLINE> road [ ab [ 1 ] - 1 ] += [ ab [ 0 ] - 1 ] <NEWLINE> <NL> <DEDENT> rets_ct = [ N for i in range ( N ) ] <NEWLINE> rets = [ 0 for i in range ( N ) ] <NEWLINE> <NL> def dfs ( second , num , ct , done ) : <NEWLINE> <INDENT> global road , rets_ct , rets <NEWLINE> <NL> if ct > rets_ct [ start ] : <NEWLINE> <INDENT> return <NEWLINE> <NL> <DEDENT> if num == 0 : <NEWLINE> <INDENT> rets [ start ] = second <NEWLINE> rets_ct [ start ] = ct <NEWLINE> return <NEWLINE> <NL> <DEDENT> if done [ num ] : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> done [ num ] = 1 <NEWLINE> <NL> ct += 1 <NEWLINE> next = road [ num ] <NEWLINE> for i in next : <NEWLINE> <INDENT> if second == 0 : <NEWLINE> <INDENT> dfs ( i , i , ct , copy . copy ( done ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dfs ( second , i , ct , copy . copy ( done ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for start in range ( 1 , N ) : <NEWLINE> <INDENT> ct = 0 <NEWLINE> done = [ 0 for i in range ( N ) ] <NEWLINE> dfs ( 0 , start , ct , done ) <NEWLINE> <NL> <DEDENT> print ( <STRING> ) <NEWLINE> for i in rets [ 1 : ] : <NEWLINE> <INDENT> print ( i + 1 ) <NEWLINE> <DEDENT>
from collections import deque <NEWLINE> import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> adjacent_list = [ [ ] for i in range ( n + 1 ) ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> adjacent_list [ a ] . append ( b ) <NEWLINE> adjacent_list [ b ] . append ( a ) <NEWLINE> <DEDENT> ans = [ - 1 for i in range ( n + 1 ) ] <NEWLINE> def bfs ( ) : <NEWLINE> <COMMENT> <NL> <INDENT> que = deque ( [ 1 ] ) <NEWLINE> while que : <NEWLINE> <INDENT> node = que . popleft ( ) <NEWLINE> finished . add ( node ) <NEWLINE> for i in adjacent_list [ node ] : <NEWLINE> <INDENT> if ans [ i ] == - 1 : <NEWLINE> <INDENT> que . append ( i ) <NEWLINE> ans [ i ] = node <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> bfs ( ) <NEWLINE> print ( <STRING> ) <NEWLINE> for i in range ( 2 , n + 1 ) : <NEWLINE> <INDENT> print ( ans [ i ] ) <NEWLINE> <DEDENT>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = { i : 0 for i in range ( 1 , N + 1 ) } <NEWLINE> ans [ 1 ] = 10000000 <NEWLINE> route = { i : [ ] for i in range ( 1 , N + 1 ) } <NEWLINE> for _ in range ( M ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> route [ a ] . append ( b ) <NEWLINE> route [ b ] . append ( a ) <NEWLINE> <DEDENT> x = [ 1 ] <NEWLINE> for _ in range ( M ) : <NEWLINE> <INDENT> for i in x : <NEWLINE> <INDENT> tmp = [ ] <NEWLINE> for j in route [ i ] : <NEWLINE> <COMMENT> <NL> <INDENT> count = 0 <NEWLINE> if ans [ j ] == 0 : <NEWLINE> <INDENT> ans [ j ] = i <NEWLINE> count += 1 <NEWLINE> <DEDENT> tmp . append ( j ) <NEWLINE> <DEDENT> <DEDENT> x = tmp <NEWLINE> <COMMENT> <NL> if count = 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> for i in ans . keys ( ) : <NEWLINE> <INDENT> if i != 1 : <NEWLINE> <INDENT> print ( ans [ i ] ) <NEWLINE> <DEDENT> <DEDENT>
from collections import deque <NEWLINE> <NL> R = lambda : map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> n , m = R ( ) <NEWLINE> g = [ [ ] for _ in range ( n ) ] <NEWLINE> for _ in range ( m ) : <NEWLINE> <INDENT> u , v = R ( ) <NEWLINE> g [ u - 1 ] . append ( v - 1 ) <NEWLINE> g [ v - 1 ] . append ( u - 1 ) <NEWLINE> <NL> <DEDENT> r = <STRING> + [ None ] * ( n - 1 ) <NEWLINE> V = [ True ] + [ False ] * ( n - 1 ) <NEWLINE> q = deque ( [ 0 ] ) <NEWLINE> while q : <NEWLINE> <INDENT> u = q . popleft ( ) <NEWLINE> for v in g [ u ] : <NEWLINE> <INDENT> if not V [ v ] : <NEWLINE> <INDENT> V [ v ] = True <NEWLINE> r [ v ] = u + 1 <NEWLINE> q . append ( v ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( * ( [ <STRING> ] , r ) [ all ( r ) ] , sep = <STRING> ) <NEWLINE>
from collections import deque <NEWLINE> <NL> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> edges = [ [ ] for _ in range ( n ) ] <COMMENT> <NEWLINE> <NL> for _ in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> edges [ a - 1 ] . append ( b - 1 ) <NEWLINE> edges [ b - 1 ] . append ( a - 1 ) <NEWLINE> <NL> <DEDENT> todo = deque ( [ 0 , 0 ] ) <NEWLINE> seen = [ - 1 ] * n <NEWLINE> seen [ 0 ] = 0 <NEWLINE> <NL> while todo : <NEWLINE> <INDENT> node , parent = todo . popleft ( ) <COMMENT> <NEWLINE> <NL> for to in edges [ node ] : <NEWLINE> <INDENT> if seen [ to ] != - 1 : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <DEDENT> todo . append ( [ to , node ] ) <NEWLINE> seen [ to ] = node <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> <NL> for parent in seen [ 1 : ] : <NEWLINE> <INDENT> print ( parent + 1 ) <NEWLINE> <DEDENT>
<NL> Copy <NEWLINE> Copy <NEWLINE> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> ab = [ list ( map ( int , input ( ) . split ( ) ) ) for _i in range ( m ) ] <NEWLINE> <NL> visit = [ - 1 for _ in range ( n ) ] <NEWLINE> visit [ 0 ] = 0 <NEWLINE> tree = [ [ ] for _ in range ( n ) ] <NEWLINE> for a , b in ab : <NEWLINE> <INDENT> tree [ a - 1 ] . append ( b - 1 ) <NEWLINE> tree [ b - 1 ] . append ( a - 1 ) <NEWLINE> <NL> <DEDENT> from collections import deque <NEWLINE> q = deque ( [ 0 ] ) <NEWLINE> while q : <NEWLINE> <INDENT> p = q . popleft ( ) <NEWLINE> for i in tree [ p ] : <NEWLINE> <INDENT> if visit [ i ] < 0 : <NEWLINE> <INDENT> visit [ i ] = p <NEWLINE> q . append ( i ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if all ( i >= 0 for i in visit ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> for i in visit [ 1 : ] : <NEWLINE> <INDENT> print ( i + 1 ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> l = [ ] <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> x = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> l . append ( x ) <NEWLINE> <DEDENT> print ( l ) <NEWLINE> m = [ ] <NEWLINE> n = [ [ 1 ] ] <NEWLINE> <NL> for j in range ( M ) : <NEWLINE> <INDENT> for i in range ( M ) : <NEWLINE> <INDENT> for k in range ( len ( n [ j ] ) ) : <NEWLINE> <INDENT> if l [ i ] [ 0 ] == n [ j ] [ k ] or l [ i ] [ 1 ] == n [ j ] [ k ] : <NEWLINE> <INDENT> if l [ i ] [ 0 ] == n [ j ] [ k ] : <NEWLINE> <INDENT> m . append ( l [ i ] [ 1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> m . append ( l [ i ] [ 0 ] ) <NEWLINE> <DEDENT> l [ i ] = [ 0 , 0 ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> n . append ( m ) <NEWLINE> m = [ ] <NEWLINE> print ( n ) <NEWLINE> <NL> <DEDENT> for i in range ( M - 1 ) : <NEWLINE>
def resolve ( ) : <NEWLINE> <INDENT> N , M = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> path = [ [ ] for _ in range ( N ) ] <NEWLINE> for _ in range ( M ) : <NEWLINE> <INDENT> A , B = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> path [ A - 1 ] . append ( B - 1 ) <NEWLINE> path [ B - 1 ] . append ( A - 1 ) <NEWLINE> <DEDENT> visited = [ - 1 ] * N <NEWLINE> que = [ 0 ] <NEWLINE> visited [ 0 ] = 0 <NEWLINE> <NL> while que : <NEWLINE> <INDENT> v = que . pop ( 0 ) <NEWLINE> print ( v , path [ v ] , file = sys . stderr ) <NEWLINE> for nv in path [ v ] : <NEWLINE> <INDENT> if visited [ nv ] != - 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> print ( nv , visited [ v ] + 1 , file = sys . stderr ) <NEWLINE> visited [ nv ] = v + 1 <NEWLINE> que . append ( nv ) <NEWLINE> <NL> <DEDENT> <DEDENT> if - 1 in visited : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> print ( visited [ i + 1 ] ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> resolve ( ) <NEWLINE>
from collections import deque <NEWLINE> <NL> def mapint_inp ( ) : <NEWLINE> <INDENT> return map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <DEDENT> def intinp ( ) : <NEWLINE> <INDENT> return int ( input ( ) ) <NEWLINE> <NL> <NL> <DEDENT> N , M = mapint_inp ( ) <NEWLINE> ABs = [ list ( mapint_inp ( ) ) for _ in range ( N ) ] <NEWLINE> <NL> adjacency_matrix = [ [ ] * ( N + 1 ) for _ in range ( N + 1 ) ] <NEWLINE> <NL> for AB in ABs : <NEWLINE> <INDENT> A , B = AB <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> adjacency_matrix [ A ] . append ( B ) <NEWLINE> adjacency_matrix [ B ] . append ( A ) <NEWLINE> <NL> <DEDENT> result = [ 0 ] * ( N + 1 ) <NEWLINE> <NL> q = deque ( [ 1 ] ) <NEWLINE> while q : <NEWLINE> <INDENT> now = q . popleft ( ) <NEWLINE> for i in adjacency_matrix [ now ] : <NEWLINE> <INDENT> if result [ i ] == 0 : <NEWLINE> <INDENT> result [ i ] == now <NEWLINE> q . append ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> print ( <STRING> . join ( str ( i ) for i in result [ 2 : ] ) ) <NEWLINE>
from sys import stdin <NEWLINE> from heapq import heappush , heappop <NEWLINE> <NL> class Dijkstra : <NEWLINE> <INDENT> def __init__ ( self , N ) : <NEWLINE> <INDENT> self . N = N <COMMENT> <NEWLINE> self . E = [ [ ] for _ in range ( N ) ] <NEWLINE> <NL> <DEDENT> def add_edge ( self , init , end , weight , undirected = False ) : <NEWLINE> <INDENT> self . E [ init ] . append ( ( end , weight ) ) <NEWLINE> if undirected : self . E [ end ] . append ( ( init , weight ) ) <NEWLINE> <NL> <DEDENT> def distance ( self , s ) : <NEWLINE> <INDENT> INF = float ( <STRING> ) <NEWLINE> E , N = self . E , self . N <NEWLINE> self . dist = dist = [ INF ] * N <COMMENT> <NEWLINE> self . prev = prev = [ - 1 ] * N <COMMENT> <NEWLINE> dist [ s ] = 0 <NEWLINE> n_visited = 1 <COMMENT> <NEWLINE> heap = [ ] <NEWLINE> heappush ( heap , ( 0 , s ) ) <NEWLINE> while heap : <NEWLINE> <INDENT> d , v = heappop ( heap ) <NEWLINE> if dist [ v ] < d : continue <NEWLINE> for u , c in E [ v ] : <NEWLINE> <INDENT> temp = d + c <NEWLINE> if dist [ u ] > temp : <NEWLINE> <INDENT> dist [ u ] = temp ; prev [ u ] = v <NEWLINE> heappush ( heap , ( temp , u ) ) <NEWLINE> <DEDENT> <DEDENT> n_visited += 1 <NEWLINE> if n_visited == N : break <NEWLINE> <DEDENT> return dist <NEWLINE> <NL> <DEDENT> def shortest_path ( self , t ) : <NEWLINE> <INDENT> P = [ ] <NEWLINE> prev = self . prev <NEWLINE> while True : <NEWLINE> <INDENT> P . append ( t ) <NEWLINE> t = prev [ t ] <NEWLINE> if t == - 1 : break <NEWLINE> <DEDENT> return P [ : : - 1 ] <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def get_result ( data ) : <NEWLINE> <INDENT> N , M = data [ 0 ] <NEWLINE> A = data [ 1 : ] <NEWLINE> solver = Dijkstra ( N ) <NEWLINE> for val in A : <NEWLINE> <INDENT> solver . add_edge ( val [ 0 ] - 1 , val [ 1 ] - 1 , undirected = True ) <NEWLINE> <DEDENT> _ , prev = solver . distance ( 0 ) <NEWLINE> print ( <STRING> ) <NEWLINE> for p in prev [ 1 : ] : <NEWLINE> <INDENT> print ( p + 1 ) <NEWLINE> <DEDENT> return None <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> raw_data = [ val . rstrip ( ) for val in stdin . readlines ( ) ] <NEWLINE> data = [ list ( map ( int , val . split ( <STRING> ) ) ) for val in raw_data ] <NEWLINE> get_result ( data ) <NEWLINE> <DEDENT>
from math import gcd <NEWLINE> <NL> MOD = 1000000007 <NEWLINE> <NL> def solve ( n , a , b ) : <NEWLINE> <INDENT> zero = 0 <NEWLINE> D = { } <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> p , q = a [ i ] , b [ i ] <NEWLINE> if ( p == 0 ) and ( q == 0 ) : <NEWLINE> <INDENT> zero += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if p < 0 and q < 0 : <NEWLINE> <INDENT> p , q = - p , - q <NEWLINE> <DEDENT> if p == 0 : <NEWLINE> <INDENT> r = abs ( q ) <NEWLINE> <DEDENT> elif q == 0 : <NEWLINE> <INDENT> r = abs ( p ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> r = gcd ( p , q ) <NEWLINE> <DEDENT> k = ( p // r , q // r ) <NEWLINE> if not k in D : <NEWLINE> <INDENT> D [ k ] = 0 <NEWLINE> <DEDENT> D [ k ] += 1 <NEWLINE> <DEDENT> <DEDENT> group = { } <NEWLINE> for ( p , q ) , v in D . items ( ) : <NEWLINE> <INDENT> if ( q , - p ) in group : <NEWLINE> <INDENT> group [ q , - p ] += v elif ( - q , p ) in group : group [ - q , p ] += v <NEWLINE> <DEDENT> else : group [ p , q ] = v pow2 = [ 0 ] * ( n + 1 ) <NEWLINE> <DEDENT> pow2 [ 0 ] = 1 for i in range ( n ) : pow2 [ i + 1 ] = ( pow2 [ i ] * 2 ) % MOD <NEWLINE> ans = 1 for ( p , q ) , v in group . items ( ) : t = pow2 [ D [ p , q ] ] <NEWLINE> <INDENT> hit = False if ( q , - p ) in D : hit = True <NEWLINE> <INDENT> t += pow2 [ D [ q , - p ] ] if ( - q , p ) in D : hit = True <NEWLINE> t += pow2 [ D [ - q , p ] ] ans = ( ans * ( t - hit ) ) % MOD return ( ans + zero - 1 ) % MOD <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> n = int ( input ( ) ) <NEWLINE> a = [ 0 ] * n <NEWLINE> b = [ 0 ] * n <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a [ i ] , b [ i ] = map ( int , input ( ) . split ( ) ) <NEWLINE> <DEDENT> print ( solve ( n , a , b ) ) <NEWLINE>
from math import gcd <NEWLINE> from numpy import sign <NEWLINE> mod = 1000000007 <NEWLINE> N = int ( input ( ) ) <NEWLINE> <NL> if N == 1 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <NL> <DEDENT> d = { } <NEWLINE> counter = 0 <NEWLINE> <NL> f = 0 <NEWLINE> l = 0 <NEWLINE> <NL> for _ in range ( N ) : <NEWLINE> <INDENT> a , b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if a == b == 0 : <NEWLINE> <INDENT> counter += 1 <NEWLINE> <DEDENT> elif a == 0 : <NEWLINE> <INDENT> f += 1 <NEWLINE> <DEDENT> elif b == 0 : <NEWLINE> <INDENT> l += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> g = gcd ( a , b ) <NEWLINE> a , b = a // g , b // g <NEWLINE> if b < 0 : <NEWLINE> <INDENT> a , b = - a , - b <NEWLINE> <DEDENT> if ( a , b ) not in d : <NEWLINE> <INDENT> d [ ( a , b ) ] = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d [ ( a , b ) ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> answer = 1 <NEWLINE> <NL> <NL> group = set ( ) <NEWLINE> for ( p , q ) , v in d . items ( ) : <NEWLINE> <INDENT> invp , invq = - q , p <NEWLINE> if invq < 0 : <NEWLINE> <INDENT> invp , invq = - invp , - invq <NEWLINE> <DEDENT> if not ( invp , invq ) in group : <NEWLINE> <INDENT> group . add ( ( p , q ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> for ( p , q ) , v in group : <NEWLINE> <INDENT> invp , invq = ( sign ( p ) * ( - 1 ) * q , abs ( p ) ) <NEWLINE> if ( invp , invq ) not in d : <NEWLINE> <INDENT> answer *= ( 2 ** d [ ( p , q ) ] ) % mod <NEWLINE> answer = answer % mod <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> answer *= ( ( 2 ** d [ ( p , q ) ] ) + ( 2 ** d [ ( invp , invq ) ] ) - 1 ) % mod <NEWLINE> answer = answer % mod <NEWLINE> <NL> <DEDENT> <DEDENT> answer *= 2 ** f + 2 ** l - 1 <NEWLINE> <NL> print ( ( answer + counter - 1 ) % mod ) <NEWLINE>
from math import gcd <NEWLINE> from sys import setrecursionlimit <NEWLINE> setrecursionlimit ( 4100000 ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> n = int ( input ( ) ) <NEWLINE> <NL> zeros = 0 <NEWLINE> d = { } <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> if x == 0 and y == 0 : <NEWLINE> <INDENT> zeros += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> g = gcd ( x , y ) <NEWLINE> x , y = x / g , y / g <NEWLINE> if ( y < 0 ) or ( y == 0 and x < 0 ) : <NEWLINE> <INDENT> x , y = - x , - y <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> if x <= 0 : <NEWLINE> <INDENT> sq = True <COMMENT> <NEWLINE> x , y = y , - x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> sq = False <NEWLINE> <DEDENT> if sq == True : <NEWLINE> <INDENT> if ( x , y ) in d : <NEWLINE> <INDENT> d [ ( x , y ) ] [ 1 ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d [ ( x , y ) ] = [ 0 , 1 ] <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if ( x , y ) in d : <NEWLINE> <INDENT> d [ ( x , y ) ] [ 0 ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d [ ( x , y ) ] = [ 1 , 0 ] <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> def mod_pow ( a : int , b : int , mod : int ) -> int : <NEWLINE> <INDENT> if b == 0 : <NEWLINE> <INDENT> return 1 % mod <NEWLINE> <DEDENT> elif b % 2 == 0 : <NEWLINE> <INDENT> return ( mod_pow ( a , b // 2 , mod ) ** 2 ) % mod <NEWLINE> <DEDENT> elif b == 1 : <NEWLINE> <INDENT> return a % mod <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return ( ( mod_pow ( a , b // 2 , mod ) ** 2 ) * a ) % mod <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> ans = 1 <NEWLINE> for ( i , j ) in tuple ( d . values ( ) ) : <NEWLINE> <INDENT> now = 1 <NEWLINE> now = ( now + mod_pow ( 2 , i , mod ) - 1 ) % mod <NEWLINE> now = ( mow + mod_pow ( 2 , j , mod ) - 1 ) % mod <NEWLINE> ans = ( ans * now ) % mod <NEWLINE> <NL> <DEDENT> ans -= 1 <NEWLINE> ans += zeros % mod <NEWLINE> ans = ans % mod <NEWLINE> print ( ans ) <NEWLINE>
from fractions import gcd <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> d = { } <NEWLINE> <COMMENT> <NL> MOD = 1000000007 <NEWLINE> nz = 0 <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if a == 0 and b == 0 : <NEWLINE> <INDENT> nz += 1 <NEWLINE> <COMMENT> <NL> <DEDENT> elif a == 0 : <NEWLINE> <INDENT> p = ( 0 , 1 ) <NEWLINE> <DEDENT> elif b == 0 : <NEWLINE> <INDENT> p = ( 1 , 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> c = gcd ( a , b ) <NEWLINE> if b > 0 : <NEWLINE> <INDENT> p = ( a // c , b // c ) <NEWLINE> <DEDENT> else : <COMMENT> <NEWLINE> <INDENT> p = ( - a // c , - b // c ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> if p in d : <NEWLINE> <INDENT> d [ p ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d [ p ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> ans = 1 <NEWLINE> <COMMENT> <NL> while len ( d ) > 0 : <NEWLINE> <INDENT> p , np = d . popitem ( ) <NEWLINE> if p == ( 1 , 0 ) : <NEWLINE> <INDENT> q = ( 0 , 1 ) <NEWLINE> <DEDENT> elif p == ( 0 , 1 ) : <NEWLINE> <INDENT> q = ( 1 , 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> pa , pb = p <NEWLINE> if pa > 0 : <NEWLINE> <INDENT> q = ( - pb , pa ) <NEWLINE> <DEDENT> else : <COMMENT> <NEWLINE> <INDENT> q = ( pb , - pa ) <NEWLINE> <DEDENT> <DEDENT> if q in d : <NEWLINE> <INDENT> nq = d . pop ( q ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> nq = 0 <NEWLINE> <NL> <DEDENT> ans *= ( ( 2 ** np + 2 ** nq - 1 ) % MOD ) <NEWLINE> ans %= MOD <NEWLINE> <NL> <DEDENT> ans -= 1 <NEWLINE> ans += nz <NEWLINE> ans %= MOD <NEWLINE> print ( ans ) <NEWLINE>
import sys <NEWLINE> input = sys . stdin . buffer . readline <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> n = int ( input ( ) ) <NEWLINE> d = { } <NEWLINE> z = 0 <NEWLINE> from math import gcd <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> if x == y == 0 : z += 1 <NEWLINE> else : <NEWLINE> <INDENT> f = gcd ( x , y ) <NEWLINE> x //= f ; y //= f <NEWLINE> if x < 0 : x *= - 1 ; y *= - 1 <NEWLINE> if x == 0 and y < 0 : y = - y <NEWLINE> d [ ( x , y ) ] = 1 if ( x , y ) not in d else d [ ( x , y ) ] += 1 <NEWLINE> <DEDENT> <DEDENT> ans = 1 <NEWLINE> for ( a , s ) in d : <NEWLINE> <INDENT> if d [ ( a , s ) ] == 0 : continue <NEWLINE> ng = 0 <NEWLINE> if ( s , - a ) in d : ng += d [ ( s , - a ) ] ; d [ ( s , - a ) ] = 0 <NEWLINE> if ( - s , a ) in d : ng += d [ ( - s , a ) ] ; d [ ( - s , a ) ] = 0 <NEWLINE> ans *= ( pow ( 2 , d [ ( a , s ) ] , mod ) - 1 + pow ( 2 , ng , mod ) - 1 + 1 ) % mod <NEWLINE> ans %= mod <NEWLINE> d [ ( a , s ) ] = 0 <NEWLINE> <DEDENT> print ( ( ans + z - 1 ) % mod ) <NEWLINE>
from math import gcd <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> AB = [ map ( int , input ( ) . split ( ) ) for _ in range ( N ) ] <NEWLINE> <NL> t = [ ] <NEWLINE> d = { } <NEWLINE> d [ 0 ] [ 0 ] = 0 <NEWLINE> for a , b in AB : <NEWLINE> <INDENT> i = gcd ( a , b ) <NEWLINE> if i != 0 : <NEWLINE> <INDENT> a //= i <NEWLINE> b //= i <NEWLINE> <DEDENT> t . append ( ( a , b ) ) <NEWLINE> d . setdefault ( a , { } ) <NEWLINE> d [ a ] . setdefault ( b , 0 ) <NEWLINE> d [ a ] [ b ] += 1 <NEWLINE> <NL> <DEDENT> used = set ( ) <NEWLINE> result = 1 <NEWLINE> for a , b in t : <NEWLINE> <INDENT> if ( a , b ) in used : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> used . add ( ( a , b ) ) <NEWLINE> if a == 0 and b == 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> i = d [ a ] [ b ] <NEWLINE> j , k , l = 0 , 0 , 0 <NEWLINE> if - a in d and - b in d [ - a ] : <NEWLINE> <INDENT> j = d [ - a ] [ - b ] <NEWLINE> used . add ( ( - a , - b ) ) <NEWLINE> <DEDENT> if - b in d and a in d [ - b ] : <NEWLINE> <INDENT> k = d [ - b ] [ a ] <NEWLINE> used . add ( ( - b , a ) ) <NEWLINE> <DEDENT> if b in d and - a in d [ b ] : <NEWLINE> <INDENT> l = d [ b ] [ - a ] <NEWLINE> used . add ( ( b , - a ) ) <NEWLINE> <DEDENT> result *= pow ( 2 , i + j , 1000000007 ) + pow ( 2 , k + l , 1000000007 ) - 1 <NEWLINE> result %= 1000000007 <NEWLINE> <DEDENT> print ( result + d [ 0 ] [ 0 ] - 1 ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> import sys <NEWLINE> input = sys . stdin . buffer . readline <NEWLINE> from collections import Counter as cc <NEWLINE> from fractions import gcd <NEWLINE> n = int ( input ( ) ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> C_p , C_n = cc ( ) , cc ( ) <NEWLINE> count = 0 <NEWLINE> ans = 1 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if a == 0 and b == 0 : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> gcd_ab = gcd ( a , b ) <NEWLINE> a //= gcd_ab <NEWLINE> b //= gcd_ab <NEWLINE> if b == 0 : <NEWLINE> <INDENT> count_zero_b += 1 <NEWLINE> <DEDENT> elif a == 0 : <NEWLINE> <INDENT> count_zero_a += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if a / b > 0 : <NEWLINE> <INDENT> C_p [ a , b ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> C_n [ a , b ] += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> count_zero = count <NEWLINE> ans *= ( 2 ** count_zero_a + 2 ** count_zero_b - 1 ) % mod <NEWLINE> count += count_zero_a + count_zero_b <NEWLINE> for a , b in C_p : <NEWLINE> <INDENT> if ( - b , a ) in C_n : <NEWLINE> <INDENT> count += C_n [ - b , a ] + C_p [ a , b ] <NEWLINE> ans *= ( 2 ** C_n [ - b , a ] + 2 ** C_p [ a , b ] - 1 ) % mod <NEWLINE> <DEDENT> <DEDENT> ans *= pow ( 2 , n - count , mod ) % mod <NEWLINE> ans += count - 1 <NEWLINE> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
_ , * e = [ [ * map ( int , t . split ( ) ) ] for t in open ( 0 ) ] <NEWLINE> ans = 1 <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> slope_dict = { } <NEWLINE> zeros = 0 <NEWLINE> vect_x = 0 <NEWLINE> for x , y in e : <NEWLINE> <INDENT> if x == y == 0 : <NEWLINE> <INDENT> zeros += 1 <NEWLINE> <DEDENT> elif y == 0 : <NEWLINE> <INDENT> vect_x += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> slope_dict [ x / y ] = slope_dict . get ( x / y , 0 ) + 1 <NEWLINE> <DEDENT> <DEDENT> ans = ans * ( pow ( 2 , vect_x , mod ) + pow ( 2 , slope_dict . get ( 0 , 0 ) , mod ) - 1 ) % mod <NEWLINE> slope_dict . pop ( 0 ) <NEWLINE> for k in slope_dict : <NEWLINE> <INDENT> if - 1 / k in slope_dict : <NEWLINE> <INDENT> if k >= 1 : <NEWLINE> <INDENT> ans = ans * ( pow ( 2 , slope_dict [ k ] , mod ) + <NEWLINE> <INDENT> pow ( 2 , slope_dict [ - 1 / k ] , mod ) - 1 ) % mod <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> ans = ans * ( pow ( 2 , slope_dict [ k ] , mod ) ) % mod <NEWLINE> <DEDENT> <DEDENT> print ( ans + zeros - 1 % mod ) <NEWLINE>
import sys <NEWLINE> import io , os <NEWLINE> input = io . BytesIO ( os . read ( 0 , os . fstat ( 0 ) . st_size ) ) . readline <NEWLINE> from collections import Counter <NEWLINE> from fractions import Fraction <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> S = [ tuple ( map ( int , input ( ) . split ( ) ) ) for i in range ( N ) ] <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> C = Counter ( ) <NEWLINE> PLUS = 0 <NEWLINE> for a , b in S : <NEWLINE> <INDENT> if a == 0 and b == 0 : <NEWLINE> <INDENT> PLUS += 1 <NEWLINE> <DEDENT> elif b != 0 : <NEWLINE> <INDENT> C [ Fraction ( a , b ) ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> C [ float ( <STRING> ) ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> ANS = 1 <NEWLINE> <NL> for x in list ( C . keys ( ) ) : <NEWLINE> <INDENT> if x != float ( <STRING> ) and x != Fraction ( 0 , 1 ) : <NEWLINE> <INDENT> n = x . numerator <NEWLINE> d = x . denominator <NEWLINE> <NL> ANS = ANS * ( pow ( 2 , C [ x ] , mod ) + pow ( 2 , C [ Fraction ( - d , n ) ] , mod ) - 1 ) % mod <NEWLINE> <NL> C [ x ] = 0 <NEWLINE> C [ Fraction ( - d , n ) ] = 0 <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> ANS = ANS * ( pow ( 2 , C [ float ( <STRING> ) ] , mod ) + pow ( 2 , C [ Fraction ( 0 , 1 ) ] , mod ) - 1 ) % mod <NEWLINE> <NL> C [ float ( <STRING> ) ] = 0 <NEWLINE> C [ Fraction ( 0 , 1 ) ] = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ( ANS - 1 + PLUS ) % mod ) <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE> <NL>
import math <NEWLINE> from collections import defaultdict <NEWLINE> <NL> def INP ( ) : return int ( input ( ) ) <NEWLINE> def LINP ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> MOD = 10 * 9 + 7 <NEWLINE> d = defaultdict ( int ) <NEWLINE> zero = 0 <NEWLINE> N = INP ( ) <NEWLINE> print ( N ) <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> A , B = LINP ( ) <NEWLINE> if A == 0 and B == 0 : <NEWLINE> <INDENT> zero += 1 <NEWLINE> continue <NEWLINE> <DEDENT> A = int ( A / math . gcd ( A , B ) ) <NEWLINE> B = int ( B / math . gcd ( A , B ) ) <NEWLINE> minus = ( - 1 ) ** ( ( A < 0 ) + ( B < 0 ) ) <NEWLINE> d [ ( minus * abs ( A ) , abs ( B ) ) ] += 1 <NEWLINE> <NL> <DEDENT> ans = 1 <NEWLINE> seen = set ( ) <NEWLINE> for a , b in d : <NEWLINE> <INDENT> if ( a , b ) not in seen : <NEWLINE> <INDENT> if ( a , b ) in [ ( 0 , 1 ) , ( 1 , 0 ) ] : <NEWLINE> <INDENT> ainv , binv = b , a <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ainv , binv = b * ( 1 if a < 0 else - 1 ) , abs ( a ) <NEWLINE> <DEDENT> new_ans = ( 2 ** d [ ( a , b ) ] - 1 ) <NEWLINE> new_ans *= ( 2 ** d [ ( ainv , binv ) ] - 1 ) if d . get ( ainv , binv ) != None else 0 <NEWLINE> new_ans += 1 <NEWLINE> ans *= new_ans % MOD <NEWLINE> seen . add ( ( a , b ) ) <NEWLINE> seen . add ( ( ainv , binv ) ) <NEWLINE> <DEDENT> <DEDENT> ans = ( ans + zero ) & MOD <NEWLINE> print ( ans ) <NEWLINE>
import sys , bisect , math , itertools , string , queue , copy <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> from collections import Counter , defaultdict , deque <NEWLINE> from itertools import permutations , combinations , combinations_with_replacement <NEWLINE> from heapq import heappop , heappush <NEWLINE> from fractions import gcd <NEWLINE> <COMMENT> <NL> sys . setrecursionlimit ( 10 ** 8 ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> def inp ( ) : return int ( input ( ) ) <NEWLINE> def inpm ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def inpl ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> def inpls ( ) : return list ( input ( ) . split ( ) ) <NEWLINE> def inplm ( n ) : return list ( int ( input ( ) ) for _ in range ( n ) ) <NEWLINE> def inplL ( n ) : return [ list ( input ( ) ) for _ in range ( n ) ] <NEWLINE> def inplT ( n ) : return [ tuple ( input ( ) ) for _ in range ( n ) ] <NEWLINE> def inpll ( n ) : return [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ] <NEWLINE> def inplls ( n ) : return sorted ( [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ] ) <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> n = inp ( ) <NEWLINE> dic = defaultdict ( int ) <NEWLINE> dic1 = defaultdict ( int ) <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> a , b = inpm ( ) <NEWLINE> if a != 0 and b == 0 : <NEWLINE> <INDENT> a = 1 <NEWLINE> <DEDENT> elif a == 0 and b != 0 : <NEWLINE> <INDENT> b = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if not ( a == 0 and b == 0 ) : <NEWLINE> <INDENT> m = gcd ( a , b ) <NEWLINE> a //= m <NEWLINE> b //= m <NEWLINE> <DEDENT> <DEDENT> if a < 0 and b < 0 : <NEWLINE> <INDENT> a = - a <NEWLINE> b = - b <NEWLINE> <DEDENT> if a < 0 and b > 0 : <NEWLINE> <INDENT> a = - a <NEWLINE> b = - b <NEWLINE> <DEDENT> index = <STRING> . join ( [ str ( a ) , str ( b ) ] ) <NEWLINE> dic [ index ] += 1 <NEWLINE> dic1 [ index ] += 1 <NEWLINE> <DEDENT> ans = 1 <NEWLINE> dic2 = defaultdict ( int ) <NEWLINE> for e in dic : <NEWLINE> <INDENT> a , b = map ( int , e . split ( ) ) <NEWLINE> if a == 0 and b == 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> flag = 0 <NEWLINE> if a == 0 and b == 1 : <NEWLINE> <INDENT> rev = <STRING> . join ( [ str ( 1 ) , str ( 0 ) ] ) <NEWLINE> <DEDENT> elif a == 1 and b == 0 : <NEWLINE> <INDENT> rev = <STRING> . join ( [ str ( 0 ) , str ( 1 ) ] ) <NEWLINE> <DEDENT> elif a > 0 and b > 0 : <NEWLINE> <INDENT> rev = <STRING> . join ( [ str ( b ) , str ( - a ) ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> rev = <STRING> . join ( [ str ( - b ) , str ( a ) ] ) <NEWLINE> <DEDENT> if dic1 [ rev ] > 0 and dic2 [ rev ] == 0 : <NEWLINE> <INDENT> dic2 [ rev ] = 1 <NEWLINE> dic2 [ e ] = 1 <NEWLINE> flag = 1 <NEWLINE> <DEDENT> if flag : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> n1 = pow ( 2 , dic [ e ] , mod ) <NEWLINE> n2 = pow ( 2 , dic1 [ rev ] , mod ) <NEWLINE> if n1 == 0 and n2 != 0 : <NEWLINE> <INDENT> ans *= n2 <NEWLINE> <DEDENT> elif n2 == 0 and n1 != 0 : <NEWLINE> <INDENT> ans *= n1 <NEWLINE> <DEDENT> else n1 != 0 and n2 != 0 : <NEWLINE> <INDENT> ans *= ( n1 + n2 - 1 ) <NEWLINE> <DEDENT> ans %= mod <NEWLINE> <DEDENT> print ( ans - 1 + dic [ <STRING> ] ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
from collections import Counter <NEWLINE> mod = 1000000007 <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> a_div_b = [ ] <NEWLINE> a_0 = 0 <NEWLINE> b_0 = 0 <NEWLINE> a_b_0 = 0 <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if a == 0 or b == 0 : <NEWLINE> <INDENT> if a == 0 and b == 0 : <NEWLINE> <INDENT> a_b_0 += 1 <NEWLINE> <DEDENT> elif a == 0 : <NEWLINE> <INDENT> a_0 += 1 <NEWLINE> <DEDENT> else b == 0 : <NEWLINE> <INDENT> b_0 += 1 <NEWLINE> <DEDENT> continue <NEWLINE> <DEDENT> if a * b < 0 : <NEWLINE> <INDENT> a_div_b . append ( a / b ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a_div_b . append ( b / a ) <NEWLINE> <NL> <DEDENT> <DEDENT> cnt = Counter ( a_div_b ) <NEWLINE> cnt2 = sorted ( cnt . items ( ) ) <NEWLINE> lst = [ ] <NEWLINE> total = 0 <NEWLINE> for num , _ in cnt2 : <NEWLINE> <INDENT> if num > 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> a1 = cnt [ num ] <NEWLINE> a2 = cnt [ - num ] <NEWLINE> if a1 * a2 != 0 : <NEWLINE> <INDENT> total += a1 + a2 <NEWLINE> lst . append ( [ a1 , a2 ] ) <NEWLINE> <DEDENT> <DEDENT> if a_0 > 0 and b_0 > 0 : <NEWLINE> <INDENT> total += a_0 + b_0 <NEWLINE> lst . append ( [ a_0 , b_0 ] ) <NEWLINE> <DEDENT> n -= a_b_0 <NEWLINE> ans = pow ( 2 , n - total , mod ) <NEWLINE> for a , b in lst : <NEWLINE> <INDENT> ans = ( ans * ( pow ( 2 , a , mod ) + pow ( 2 , b , mod ) - 1 ) ) % mod <NEWLINE> <DEDENT> ans = ( ans - 1 + a_b_0 ) % mod <NEWLINE> <NL> print ( ans ) <NEWLINE> <NL>
from math import gcd <NEWLINE> n = int ( input ( ) ) <NEWLINE> p = 10 ** 9 + 7 <NEWLINE> iwashi = { } <NEWLINE> bad = 0 <NEWLINE> ans = 1 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> if ( x == 0 and y == 0 ) : <NEWLINE> <INDENT> bad += 1 <NEWLINE> continue <NEWLINE> <DEDENT> elif ( x == 0 ) : <NEWLINE> try : <NEWLINE> <INDENT> iwashi [ ( 0 , - 1 ) ] += 1 <NEWLINE> <DEDENT> except KeyError : <NEWLINE> <INDENT> iwashi [ ( 0 , - 1 ) ] = 1 <NEWLINE> continue <NEWLINE> <DEDENT> elif ( y == 0 ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> iwashi [ ( - 1 , 0 ) ] += 1 <NEWLINE> <DEDENT> <DEDENT> except KeyError : <NEWLINE> <INDENT> iwashi [ ( - 1 , 0 ) ] = 1 <NEWLINE> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> g = gcd ( x , y ) <NEWLINE> x , y = x // g , y // g <NEWLINE> if x < 0 : <NEWLINE> <INDENT> x , y = - x , - y <NEWLINE> <DEDENT> try : <NEWLINE> <INDENT> iwashi [ ( x , y ) ] += 1 <NEWLINE> <DEDENT> except KeyError : <NEWLINE> <INDENT> iwashi [ ( x , y ) ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for x , y in iwashi : <NEWLINE> <INDENT> a = iwashi [ ( x , y ) ] <NEWLINE> if y > 0 : <NEWLINE> <INDENT> rx , ry = y , - x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> rx , ry = y , - x <NEWLINE> <DEDENT> try : <NEWLINE> <INDENT> b = iwashi [ ( rx , ry ) ] <NEWLINE> iwashi [ ( rx , ry ) ] = 0 <NEWLINE> <DEDENT> except KeyError : <NEWLINE> <INDENT> b = 0 <NEWLINE> <DEDENT> ans *= pow ( 2 , a , p ) + pow ( 2 , b , p ) - 1 <NEWLINE> ans %= p <NEWLINE> iwashi [ ( x , y ) ] = 0 <NEWLINE> <DEDENT> print ( ( ans + bad - 1 ) % p ) <NEWLINE>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> from itertools import accumulate <NEWLINE> from itertools import permutations <NEWLINE> from itertools import combinations <NEWLINE> from collections import defaultdict <NEWLINE> from collections import Counter <NEWLINE> import fractions <NEWLINE> import math <NEWLINE> from collections import deque <NEWLINE> from bisect import bisect_left <NEWLINE> from bisect import insort_left <NEWLINE> import itertools <NEWLINE> from heapq import heapify <NEWLINE> from heapq import heappop <NEWLINE> from heapq import heappush <NEWLINE> import heapq <NEWLINE> import numpy as np <NEWLINE> INF = float ( <STRING> ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> N = int ( input ( ) ) <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> AB = [ ] <NEWLINE> x = 0 <NEWLINE> y = 0 <NEWLINE> d = defaultdict ( int ) <NEWLINE> ch = defaultdict ( int ) <NEWLINE> flag = 0 <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if a == 0 and b == 0 : <NEWLINE> <INDENT> flag = 1 <NEWLINE> continue <NEWLINE> <DEDENT> elif a == 0 : <NEWLINE> <INDENT> x += 1 <NEWLINE> continue <NEWLINE> <DEDENT> elif b == 0 : <NEWLINE> <INDENT> y += 1 <NEWLINE> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d = math . gcd ( abs ( a ) , abs ( b ) ) <NEWLINE> a /= d <NEWLINE> b /= d <NEWLINE> c = a / b <NEWLINE> d [ c ] += 1 <NEWLINE> AB . append ( c ) <NEWLINE> <DEDENT> <DEDENT> n = len ( AB ) <NEWLINE> ans = 1 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> cc = AB [ i ] <NEWLINE> if ch [ cc ] != 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> m = d [ cc ] <NEWLINE> ccc = ( - 1 ) / cc <NEWLINE> l = d [ ccc ] <NEWLINE> ans *= ( pow ( 2 , m , MOD ) + pow ( 2 , l , MOD ) - 1 ) <NEWLINE> print ( ans ) <NEWLINE> ch [ cc ] = 1 <NEWLINE> ch [ ccc ] = 1 <NEWLINE> <DEDENT> ans *= ( pow ( 2 , x , MOD ) + pow ( 2 , y , MOD ) - 1 ) <NEWLINE> if flag == 0 : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <DEDENT> ans = ans % MOD <NEWLINE> print ( ans ) <NEWLINE>
from math import gcd <NEWLINE> <NL> mod = 10 ** 9 + 7 <NEWLINE> N = int ( input ( ) ) <NEWLINE> dic = { } <NEWLINE> <NL> zero = 0 <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if a == 0 and b == 0 : <NEWLINE> <INDENT> zero += 1 <NEWLINE> continue <NEWLINE> <DEDENT> elif a == 0 : <NEWLINE> <INDENT> key = ( 0 , 1 ) <NEWLINE> <DEDENT> elif b == 0 : <NEWLINE> <INDENT> key = ( 1 , 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if a < 0 : <NEWLINE> <INDENT> a = - a <NEWLINE> b = - b <NEWLINE> <DEDENT> g = gcd ( a , abs ( b ) ) <NEWLINE> key = ( a // g , b // g ) <NEWLINE> <NL> <DEDENT> if key not in dic : <NEWLINE> <INDENT> dic [ key ] = 0 <NEWLINE> <NL> <DEDENT> dic [ key ] += 1 <NEWLINE> <NL> <DEDENT> ans = 1 <NEWLINE> for k1 , v1 in dic . items ( ) : <NEWLINE> <INDENT> if v1 == 0 : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <DEDENT> if k1 [ 1 ] > 0 : <NEWLINE> <INDENT> k2 = ( k1 [ 1 ] , - k1 [ 0 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> k2 = ( - k1 [ 1 ] , k1 [ 0 ] ) <NEWLINE> <NL> <DEDENT> if k2 not in dic : <NEWLINE> <INDENT> ans *= 2 ** v1 <NEWLINE> ans %= mod <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans *= ( ( 2 ** v1 - 1 ) ) % mod ) + ( ( 2 ** dic [ k2 ] - 1 ) ) % mod ) + 1 <NEWLINE> ans %= mod <NEWLINE> dic [ k2 ] = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> ans = ( ans + zero - 1 ) % mod <NEWLINE> print ( ans ) <NEWLINE>
def ii ( ) : return int ( input ( ) ) <NEWLINE> def iim ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def iil ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> def ism ( ) : return map ( str , input ( ) . split ( ) ) <NEWLINE> def isl ( ) : return list ( map ( str , input ( ) . split ( ) ) ) <NEWLINE> <NL> <COMMENT> <NL> from math import gcd <NEWLINE> <NL> mod = int ( 1e9 + 7 ) <NEWLINE> n = ii ( ) <NEWLINE> cnd = { } <NEWLINE> azero = 0 <NEWLINE> bzero = 0 <NEWLINE> allzero = 0 <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> a , b = iim ( ) <NEWLINE> if a == 0 : <NEWLINE> <INDENT> if b != 0 : <NEWLINE> <INDENT> azero += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> allzero += 1 <NEWLINE> <DEDENT> <DEDENT> elif b == 0 : <NEWLINE> <INDENT> bzero += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> <STRING> <NEWLINE> g = gcd ( a , b ) <NEWLINE> a //= g <NEWLINE> b //= g <NEWLINE> if a < 0 : <NEWLINE> <INDENT> a *= - 1 <NEWLINE> b *= - 1 <NEWLINE> <DEDENT> cnd [ ( a , b ) ] += cnd . get ( ( a , b ) , 0 ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> noreg = 0 <NEWLINE> if azero == 0 or bzero == 0 : <NEWLINE> <INDENT> noreg += max ( azero , bzero ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = ( 2 ** azero % mod + 2 ** bzero % mod - 1 ) % mod <NEWLINE> <NL> <DEDENT> for k , item in cnd : <NEWLINE> <INDENT> a , b = k <NEWLINE> if b > 0 : <NEWLINE> <INDENT> m = cnd . get ( ( - b , a ) , False ) <NEWLINE> if m : <NEWLINE> <INDENT> ans *= ( 2 ** item % mod + 2 ** m % mod - 1 ) % mod <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> noreg += item <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> m = cnd . get ( ( - b , a ) , False ) <NEWLINE> if not m : <NEWLINE> <INDENT> noreg += item <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> print ( int ( ( ans * ( ( 2 ** noreg ) % mod ) - 1 + allzero ) % mod ) ) <NEWLINE>
from math import gcd <NEWLINE> mod = 1000000007 <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> zeros = 0 <NEWLINE> vec = { } <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if a == 0 and b == 0 : <NEWLINE> <INDENT> zeros += 1 <NEWLINE> continue <NEWLINE> <DEDENT> elif a == 0 : <NEWLINE> <INDENT> vec [ ( 0 , 1 ) ] = vec . get ( ( 0 , 1 ) , 0 ) + 1 <NEWLINE> <DEDENT> elif b == 0 : <NEWLINE> <INDENT> vec [ ( 1 , 0 ) ] = vec . get ( ( 1 , 0 ) , 0 ) + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> g = gcd ( a , b ) <NEWLINE> a , b = a // g , b // g <NEWLINE> vec [ ( a , b ) ] = vec . get ( ( a , b ) , 0 ) + 1 <NEWLINE> <DEDENT> <DEDENT> done = set ( ) <NEWLINE> total = 1 <NEWLINE> for ( a , b ) , v in vec . items ( ) : <NEWLINE> <INDENT> if ( - b , a ) in done or ( b , - a ) in done : continue <NEWLINE> done . add ( ( a , b ) ) <NEWLINE> w = vec [ ( - b , a ) ] + vec [ ( b , - a ) ] <NEWLINE> total *= ( pow ( 2 , v , mod ) + pow ( 2 , w , mod ) - 1 ) <NEWLINE> total %= mod <NEWLINE> <DEDENT> print ( ( total + zeros - 1 + mod ) % mod ) <NEWLINE>
import sys <NEWLINE> import numpy as np <NEWLINE> from numba import njit <NEWLINE> <NL> read = sys . stdin . buffer . read <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> readlines = sys . stdin . buffer . readlines <NEWLINE> <NL> INF = 10 ** 9 + 1 <NEWLINE> <NL> def precompute ( N , M , data ) : <NEWLINE> <INDENT> data = data . reshape ( - 1 , 3 ) <NEWLINE> A , B , C = data [ : N ] . T <NEWLINE> D , E , F = data [ N : ] . T <NEWLINE> X = np . unique ( np . concatenate ( [ A , B , D , [ 0 , - INF , INF ] ] ) ) <NEWLINE> Y = np . unique ( np . concatenate ( [ C , E , F , [ 0 , - INF , INF ] ] ) ) <NEWLINE> A = np . searchsorted ( X , A ) . astype ( np . int32 ) <NEWLINE> B = np . searchsorted ( X , B ) . astype ( np . int32 ) <NEWLINE> D = np . searchsorted ( X , D ) . astype ( np . int32 ) <NEWLINE> C = np . searchsorted ( Y , C ) . astype ( np . int32 ) <NEWLINE> E = np . searchsorted ( Y , E ) . astype ( np . int32 ) <NEWLINE> F = np . searchsorted ( Y , F ) . astype ( np . int32 ) <NEWLINE> return A , B , C , D , E , F , X , Y <NEWLINE> <NL> <DEDENT> def solve ( A , B , C , D , E , F , X , Y ) : <NEWLINE> <INDENT> H , W = len ( X ) , len ( Y ) <NEWLINE> N = H * W <NEWLINE> DX = X [ 1 : ] - X [ : - 1 ] <NEWLINE> DY = Y [ 1 : ] - Y [ : - 1 ] <NEWLINE> <NL> def set_ng ( A , B , C , D , E , F , H , W ) : <NEWLINE> <INDENT> ng = np . zeros ( ( H * W , 4 ) , np . bool_ ) <NEWLINE> <NL> for i in range ( len ( A ) ) : <NEWLINE> <INDENT> for x in range ( A [ i ] , B [ i ] ) : <NEWLINE> <INDENT> v = x * W + C [ i ] <NEWLINE> ng [ v ] [ 1 ] = 1 <NEWLINE> ng [ v - 1 ] [ 0 ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( len ( D ) ) : <NEWLINE> <INDENT> for y in range ( E [ i ] , F [ i ] ) : <NEWLINE> <INDENT> v = D [ i ] * W + y <NEWLINE> ng [ v ] [ 3 ] = 1 <NEWLINE> ng [ v - W ] [ 2 ] = 1 <NEWLINE> <DEDENT> <DEDENT> return ng <NEWLINE> <NL> <DEDENT> ng = set_ng ( A , B , C , D , E , F , H , W ) <NEWLINE> x0 , y0 = np . searchsorted ( X , 0 ) , np . searchsorted ( Y , 0 ) <NEWLINE> v0 = x0 * W + y0 <NEWLINE> visited = np . zeros ( N , np . bool_ ) <NEWLINE> visited [ v0 ] = 1 <NEWLINE> stack = np . empty ( N , np . int32 ) <NEWLINE> p = 0 <NEWLINE> ret = 0 <NEWLINE> <NL> def area ( x ) : <NEWLINE> <INDENT> x , y = divmod ( x , W ) <NEWLINE> return np . int64 ( DX [ x ] ) * np . int64 ( DY [ y ] ) <NEWLINE> <NL> <DEDENT> def push ( x ) : <NEWLINE> <INDENT> nonlocal p , ret <NEWLINE> stack [ p ] = x <NEWLINE> visited [ x ] = 1 <NEWLINE> ret += area ( x ) <NEWLINE> p += 1 <NEWLINE> <NL> <DEDENT> def pop ( ) : <NEWLINE> <INDENT> nonlocal p <NEWLINE> p -= 1 <NEWLINE> return stack [ p ] <NEWLINE> <NL> <DEDENT> push ( v0 ) <NEWLINE> move = ( 1 , - 1 , W , - W ) <NEWLINE> while p : <NEWLINE> <INDENT> v = pop ( ) <NEWLINE> for i in range ( 4 ) : <NEWLINE> <INDENT> if ng [ v ] [ i ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> w = v + move [ i ] <NEWLINE> if visited [ w ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> x , y = divmod ( w , W ) <NEWLINE> if x == 0 or x == H - 1 or y == 0 or y == W - 1 : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> push ( w ) <NEWLINE> <DEDENT> <DEDENT> return ret <NEWLINE> <NL> <DEDENT> def cc_export ( ) : <NEWLINE> <INDENT> from numba . pycc import CC <NEWLINE> cc = CC ( <STRING> ) <NEWLINE> signature = <STRING> <NEWLINE> cc . export ( <STRING> , signature ) ( solve ) <NEWLINE> cc . compile ( ) <NEWLINE> <NL> <DEDENT> if sys . argv [ - 1 ] == <STRING> : <NEWLINE> <INDENT> cc_export ( ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> from my_module import solve <NEWLINE> <NL> N , M = map ( int , readline ( ) . split ( ) ) <NEWLINE> data = np . int32 ( read ( ) . split ( ) ) <NEWLINE> <NL> x = solve ( * precompute ( N , M , data ) ) <NEWLINE> if x == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( x ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> from numba import njit <NEWLINE> from bisect import * <NEWLINE> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> A , B , C = zip ( * ( map ( int , input ( ) . split ( ) ) for _ in range ( n ) ) ) <NEWLINE> D , E , F = zip ( * ( map ( int , input ( ) . split ( ) ) for _ in range ( m ) ) ) <NEWLINE> X = sorted ( set ( C + E + F ) ) <NEWLINE> Y = sorted ( set ( A + B + D ) ) <NEWLINE> H = len ( Y ) - 1 <NEWLINE> W = len ( X ) - 1 <NEWLINE> def TX ( i ) : <NEWLINE> <INDENT> return bisect ( X , i ) - 1 <NEWLINE> <DEDENT> def TY ( i ) : <NEWLINE> <INDENT> return bisect ( Y , i ) - 1 <NEWLINE> <DEDENT> U = np . ones ( ( H + 1 , W ) ) <NEWLINE> for d , e , f in zip ( D , E , F ) : <NEWLINE> <INDENT> d , e , f = TY ( d ) , TX ( e ) , TX ( f ) <NEWLINE> U [ d , e : f ] = False <NEWLINE> <DEDENT> L = np . ones ( ( H , W + 1 ) ) <NEWLINE> for a , b , c in zip ( A , B , C ) : <NEWLINE> <INDENT> a , b , c = TY ( a ) , TY ( b ) , TX ( c ) <NEWLINE> L [ a : b , c ] = False <NEWLINE> <DEDENT> S = np . outer ( np . diff ( Y ) , np . diff ( X ) ) <NEWLINE> @ njit <NEWLINE> def f ( i , j ) : <NEWLINE> <INDENT> s = [ ( i , j ) ] <NEWLINE> v = set ( ) <NEWLINE> r = 0 <NEWLINE> while s : <NEWLINE> <INDENT> i , j = s . pop ( ) <NEWLINE> if ( i , j ) in v : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> v . add ( ( i , j ) ) <NEWLINE> if not ( 0 <= i < H and 0 <= j < W ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> r += S [ i ] [ j ] <NEWLINE> if U [ i ] [ j ] : <NEWLINE> <INDENT> s . append ( ( i - 1 , j ) ) <NEWLINE> <DEDENT> if U [ i + 1 ] [ j ] : <NEWLINE> <INDENT> s . append ( ( i + 1 , j ) ) <NEWLINE> <DEDENT> if L [ i ] [ j ] : <NEWLINE> <INDENT> s . append ( ( i , j - 1 ) ) <NEWLINE> <DEDENT> if L [ i ] [ j + 1 ] : <NEWLINE> <INDENT> s . append ( ( i , j + 1 ) ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( r ) <NEWLINE> <DEDENT> <DEDENT> i = bisect ( Y , 0 ) - 1 <NEWLINE> j = bisect ( X , 0 ) - 1 <NEWLINE> f ( i , j ) <NEWLINE>
import sys <NEWLINE> import numpy as np <NEWLINE> from numba import njit <NEWLINE> <NL> read = sys . stdin . buffer . read <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> readlines = sys . stdin . buffer . readlines <NEWLINE> <NL> INF = 10 ** 9 + 1 <NEWLINE> <NL> N , M = map ( int , readline ( ) . split ( ) ) <NEWLINE> data = np . int64 ( read ( ) . split ( ) ) . reshape ( - 1 , 3 ) <NEWLINE> <NL> A = data [ : N , 0 ] <NEWLINE> B = data [ : N , 1 ] <NEWLINE> C = data [ : N , 2 ] <NEWLINE> D = data [ N : , 0 ] <NEWLINE> E = data [ N : , 1 ] <NEWLINE> F = data [ N : , 2 ] <NEWLINE> <NL> X = np . unique ( np . concatenate ( [ A , B , D , [ 0 , - INF , INF ] ] ) ) <NEWLINE> Y = np . unique ( np . concatenate ( [ C , E , F , [ 0 , - INF , INF ] ] ) ) <NEWLINE> DX = X [ 1 : ] - X [ : - 1 ] <NEWLINE> DY = Y [ 1 : ] - Y [ : - 1 ] <NEWLINE> <NL> A , B , D = map ( lambda x : np . searchsorted ( X , x ) , ( A , B , C ) ) <NEWLINE> C , E , F = map ( lambda x : np . searchsorted ( Y , x ) , ( D , E , F ) ) <NEWLINE> <NL> H , W = len ( X ) , len ( Y ) <NEWLINE> N = H * W <NEWLINE> <NL> @ njit <NEWLINE> def set_ng ( A , B , C , D , E , F ) : <NEWLINE> <INDENT> ng = np . zeros ( ( N , 4 ) , np . bool_ ) <NEWLINE> <NL> for i in range ( len ( A ) ) : <NEWLINE> <INDENT> for x in range ( A [ i ] , B [ i ] ) : <NEWLINE> <INDENT> v = x * W + C [ i ] <NEWLINE> ng [ v ] [ 1 ] = 1 <NEWLINE> ng [ v - 1 ] [ 0 ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( len ( D ) ) : <NEWLINE> <INDENT> for y in range ( E [ i ] , F [ i ] ) : <NEWLINE> <INDENT> v = D [ i ] * W + y <NEWLINE> ng [ v ] [ 3 ] = 1 <NEWLINE> ng [ v - W ] [ 2 ] = 1 <NEWLINE> <DEDENT> <DEDENT> return ng <NEWLINE> <NL> <DEDENT> @ njit <NEWLINE> def solve ( ) : <NEWLINE> <INDENT> ng = set_ng ( A , B , C , D , E , F ) <NEWLINE> x0 , y0 = np . searchsorted ( X , 0 ) , np . searchsorted ( Y , 0 ) <NEWLINE> v0 = x0 * W + y0 <NEWLINE> visited = np . zeros ( N , np . bool_ ) <NEWLINE> visited [ v0 ] = 1 <NEWLINE> stack = [ v0 ] <NEWLINE> ret = 0 <NEWLINE> <NL> def area ( x ) : <NEWLINE> <INDENT> x , y = divmod ( x , W ) <NEWLINE> return DX [ x ] * DY [ y ] <NEWLINE> <NL> <DEDENT> def push ( x ) : <NEWLINE> <INDENT> nonlocal ret <NEWLINE> stack . append ( x ) <NEWLINE> visited [ x ] = 1 <NEWLINE> ret += area ( x ) <NEWLINE> <NL> <DEDENT> push ( v0 ) <NEWLINE> move = ( 1 , - 1 , W , - W ) <NEWLINE> while stack : <NEWLINE> <INDENT> v = stack . pop ( ) <NEWLINE> for i in range ( 4 ) : <NEWLINE> <INDENT> if ng [ v ] [ i ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> w = v + move [ i ] <NEWLINE> if visited [ w ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> x , y = divmod ( w , W ) <NEWLINE> if x == 0 or x == H - 1 or y == 0 or y == W - 1 : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> push ( w ) <NEWLINE> <DEDENT> <DEDENT> return ret <NEWLINE> <NL> <DEDENT> x = solve ( ) <NEWLINE> if x == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( x ) <NEWLINE> <DEDENT>
import sys <NEWLINE> import numpy as np <NEWLINE> from numba import njit <NEWLINE> <NL> read = sys . stdin . buffer . read <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> readlines = sys . stdin . buffer . readlines <NEWLINE> <NL> INF = 10 ** 9 + 1 <NEWLINE> <NL> N , M = map ( int , readline ( ) . split ( ) ) <NEWLINE> data = np . array ( read ( ) . split ( ) , np . int64 ) <NEWLINE> A = data [ : : 3 ] <NEWLINE> B = data [ 1 : : 3 ] <NEWLINE> C = data [ 2 : : 3 ] <NEWLINE> <NL> D = A [ N : ] <NEWLINE> E = B [ N : ] <NEWLINE> F = C [ N : ] <NEWLINE> A = A [ : N ] <NEWLINE> B = B [ : N ] <NEWLINE> C = C [ : N ] <NEWLINE> <NL> X = np . unique ( np . concatenate ( [ A , B , D , [ 0 , - INF , INF ] ] ) ) <NEWLINE> Y = np . unique ( np . concatenate ( [ C , E , F , [ 0 , - INF , INF ] ] ) ) <NEWLINE> DX = X [ 1 : ] - X [ : - 1 ] <NEWLINE> DY = Y [ 1 : ] - Y [ : - 1 ] <NEWLINE> <NL> A = np . searchsorted ( X , A ) <NEWLINE> B = np . searchsorted ( X , B ) <NEWLINE> C = np . searchsorted ( Y , C ) <NEWLINE> D = np . searchsorted ( X , D ) <NEWLINE> E = np . searchsorted ( Y , E ) <NEWLINE> F = np . searchsorted ( Y , F ) <NEWLINE> <NL> H , W = len ( X ) , len ( Y ) <NEWLINE> N = H * W <NEWLINE> <NL> @ njit <NEWLINE> def set_ng ( A , B , C , D , E , F ) : <NEWLINE> <INDENT> p = 0 <NEWLINE> head = np . full ( N , - 1 , np . int32 ) <NEWLINE> ng = np . empty ( 4 * N , np . int32 ) <NEWLINE> nxt = np . empty ( 4 * N , np . int32 ) <NEWLINE> <NL> def add ( v , w ) : <NEWLINE> <INDENT> nonlocal p <NEWLINE> nxt [ p ] = head [ v ] <NEWLINE> head [ v ] = p <NEWLINE> ng [ p ] = w <NEWLINE> p += 1 <NEWLINE> <NL> <DEDENT> for i in range ( len ( A ) ) : <NEWLINE> <INDENT> a , b , c = A [ i ] , B [ i ] , C [ i ] <NEWLINE> for x in range ( a , b ) : <NEWLINE> <INDENT> v = x * W + c <NEWLINE> add ( v , v - 1 ) <NEWLINE> add ( v - 1 , v ) <NEWLINE> <DEDENT> <DEDENT> for i in range ( len ( D ) ) : <NEWLINE> <INDENT> d , e , f = D [ i ] , E [ i ] , F [ i ] <NEWLINE> for y in range ( e , f ) : <NEWLINE> <INDENT> v = d * W + y <NEWLINE> add ( v , v - W ) <NEWLINE> add ( v - W , v ) <NEWLINE> <DEDENT> <DEDENT> return head , ng [ : p ] , nxt [ : p ] <NEWLINE> <NL> <DEDENT> head , ng , nxt = set_ng ( A , B , C , D , E , F ) <NEWLINE> <NL> @ njit <NEWLINE> def next_w ( head , ng , nxt , v ) : <NEWLINE> <INDENT> p = head [ v ] <NEWLINE> V = [ v - W , v + W , v - 1 , v + 1 ] <NEWLINE> while p != - 1 : <NEWLINE> <INDENT> V . remove ( ng [ p ] ) <NEWLINE> p = nxt [ p ] <NEWLINE> <DEDENT> return V <NEWLINE> <NL> <DEDENT> x0 , y0 = np . searchsorted ( X , 0 ) , np . searchsorted ( Y , 0 ) <NEWLINE> v0 = x0 * W + y0 <NEWLINE> <NL> @ njit <NEWLINE> def solve ( ) : <NEWLINE> <INDENT> visited = np . zeros ( N , np . bool_ ) <NEWLINE> visited [ v0 ] = 1 <NEWLINE> stack = np . empty ( N , np . int32 ) <NEWLINE> p = 0 <NEWLINE> ret = 0 <NEWLINE> <NL> def area ( x ) : <NEWLINE> <INDENT> x , y = divmod ( x , W ) <NEWLINE> return DX [ x ] * DY [ y ] <NEWLINE> <NL> <DEDENT> def push ( x ) : <NEWLINE> <INDENT> nonlocal p , ret <NEWLINE> stack [ p ] = x <NEWLINE> visited [ x ] = 1 <NEWLINE> <COMMENT> <NL> p += 1 <NEWLINE> <NL> <DEDENT> def pop ( ) : <NEWLINE> <INDENT> nonlocal p <NEWLINE> p -= 1 <NEWLINE> return stack [ p ] <NEWLINE> <NL> <DEDENT> push ( v0 ) <NEWLINE> while p : <NEWLINE> <INDENT> v = pop ( ) <NEWLINE> for w in next_w ( head , ng , nxt , v ) : <NEWLINE> <INDENT> if visited [ w ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> x , y = divmod ( w , W ) <NEWLINE> if x == 0 or x == H - 1 or y == 0 or y == W - 1 : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> push ( w ) <NEWLINE> <DEDENT> <DEDENT> return ret <NEWLINE> <NL> <DEDENT> x = solve ( ) <NEWLINE> if x == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( x ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> from heapq import heappush , heappop <NEWLINE> import sys <NEWLINE> import numpy as np <NEWLINE> <NL> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> input = sys . stdin . buffer . readline <NEWLINE> <COMMENT> <NL> INF = 10 ** 9 + 1 <NEWLINE> <COMMENT> <NL> <NL> <NL> def dp ( * x ) : <COMMENT> <NEWLINE> <INDENT> print ( * x ) <NEWLINE> <NL> <NL> <DEDENT> try : <NEWLINE> <INDENT> profile <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> def profile ( f ) : return f <NEWLINE> <NL> <NL> <DEDENT> def main ( N , M , data ) : <NEWLINE> <INDENT> ABC = data [ : 3 * N ] <NEWLINE> DEF = data [ 3 * N : ] <NEWLINE> A , B , C = [ ABC [ i : : 3 ] for i in range ( 3 ) ] <NEWLINE> D , E , F = [ DEF [ i : : 3 ] for i in range ( 3 ) ] <NEWLINE> <NL> xticks = np . unique ( np . concatenate ( ( E , F , C , np . array ( [ - INF , 0 , INF ] ) ) ) ) <NEWLINE> yticks = np . unique ( np . concatenate ( ( A , B , D , np . array ( [ - INF , 0 , INF ] ) ) ) ) <NEWLINE> width = xticks [ 1 : ] - xticks [ : - 1 ] <NEWLINE> height = yticks [ 1 : ] - yticks [ : - 1 ] <NEWLINE> <NL> <COMMENT> <NL> A = np . searchsorted ( yticks , A ) . astype ( np . int16 ) <NEWLINE> B = np . searchsorted ( yticks , B ) . astype ( np . int16 ) <NEWLINE> C = np . searchsorted ( xticks , C ) . astype ( np . int16 ) <NEWLINE> D = np . searchsorted ( yticks , D ) . astype ( np . int16 ) <NEWLINE> E = np . searchsorted ( xticks , E ) . astype ( np . int16 ) <NEWLINE> F = np . searchsorted ( xticks , F ) . astype ( np . int16 ) <NEWLINE> <NL> GRAPH_WIDTH = len ( xticks ) <NEWLINE> GRAPH_HEIGHT = len ( yticks ) <NEWLINE> NUM_VERTEXES = GRAPH_HEIGHT * GRAPH_WIDTH <NEWLINE> <NL> <COMMENT> <NL> ng_edges = np . zeros ( NUM_VERTEXES , dtype = np . uint8 ) <NEWLINE> <NL> direction = ( - 1 , + 1 , - GRAPH_WIDTH , + GRAPH_WIDTH ) <NEWLINE> <NL> <COMMENT> <NL> for i in range ( N ) : <NEWLINE> <INDENT> x = C [ i ] <NEWLINE> for y in range ( A [ i ] , B [ i ] ) : <NEWLINE> <INDENT> pos = y * GRAPH_WIDTH + x <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> ng_edges [ pos ] |= 0b0001 <COMMENT> <NEWLINE> ng_edges [ pos - 1 ] |= 0b0010 <COMMENT> <NEWLINE> <DEDENT> <DEDENT> A = B = C = 0 <NEWLINE> <NL> <COMMENT> <NL> for i in range ( M ) : <NEWLINE> <INDENT> y = D [ i ] <NEWLINE> for x in range ( E [ i ] , F [ i ] ) : <NEWLINE> <INDENT> pos = y * GRAPH_WIDTH + x <NEWLINE> ng_edges [ pos ] |= 0b0100 <NEWLINE> ng_edges [ pos - GRAPH_WIDTH ] |= 0b1000 <NEWLINE> <DEDENT> <DEDENT> D = E = F = 0 <NEWLINE> <NL> total_area = 0 <NEWLINE> <COMMENT> <NL> visited = set ( ) <NEWLINE> x = np . searchsorted ( xticks , 0 ) <NEWLINE> y = np . searchsorted ( yticks , 0 ) <NEWLINE> start = y * GRAPH_WIDTH + x <NEWLINE> to_visit = [ start ] <NEWLINE> <NL> MASK = np . array ( [ 0b0001 , 0b0010 , 0b0100 , 0b1000 ] , dtype = np . uint8 ) <NEWLINE> while to_visit : <NEWLINE> <INDENT> pos = to_visit . pop ( ) <NEWLINE> y , x = divmod ( pos , GRAPH_WIDTH ) <NEWLINE> if pos in visited : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if y == 0 or y == GRAPH_HEIGHT - 1 or x == 0 or x == GRAPH_WIDTH - 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <NL> <DEDENT> total_area += width [ x ] * height [ y ] <NEWLINE> visited . add ( pos ) <NEWLINE> <COMMENT> <NL> for i in range ( 4 ) : <NEWLINE> <INDENT> if not ( ng_edges [ pos ] & MASK [ i ] ) : <NEWLINE> <INDENT> to_visit . append ( pos + direction [ i ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( total_area ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if sys . argv [ - 1 ] == <STRING> or sys . argv [ - 1 ] == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> from numba . pycc import CC <NEWLINE> cc = CC ( <STRING> ) <NEWLINE> cc . export ( <NEWLINE> <INDENT> <STRING> , <NEWLINE> <STRING> <NEWLINE> <DEDENT> ) ( main ) <NEWLINE> <COMMENT> <NL> cc . compile ( ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if sys . argv [ - 1 ] != <STRING> : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <INDENT> from my_module import main <COMMENT> <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> import numba <NEWLINE> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> data = np . int32 ( sys . stdin . read ( ) . split ( ) ) <NEWLINE> main ( N , M , data ) <NEWLINE> <DEDENT>
import sys <NEWLINE> import numpy as np <NEWLINE> from numba import njit <NEWLINE> <NL> read = sys . stdin . buffer . read <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> readlines = sys . stdin . buffer . readlines <NEWLINE> <NL> INF = 10 ** 9 + 1 <NEWLINE> <NL> N , M = map ( int , readline ( ) . split ( ) ) <NEWLINE> data = np . array ( read ( ) . split ( ) , np . int64 ) <NEWLINE> A = data [ : : 3 ] <NEWLINE> B = data [ 1 : : 3 ] <NEWLINE> C = data [ 2 : : 3 ] <NEWLINE> <NL> D = A [ N : ] <NEWLINE> E = B [ N : ] <NEWLINE> F = C [ N : ] <NEWLINE> A = A [ : N ] <NEWLINE> B = B [ : N ] <NEWLINE> C = C [ : N ] <NEWLINE> <NL> X = np . unique ( np . concatenate ( [ A , B , D , [ 0 , - INF , INF ] ] ) ) <NEWLINE> Y = np . unique ( np . concatenate ( [ C , E , F , [ 0 , - INF , INF ] ] ) ) <NEWLINE> DX = X [ 1 : ] - X [ : - 1 ] <NEWLINE> DY = Y [ 1 : ] - Y [ : - 1 ] <NEWLINE> <NL> A = np . searchsorted ( X , A ) <NEWLINE> B = np . searchsorted ( X , B ) <NEWLINE> C = np . searchsorted ( Y , C ) <NEWLINE> D = np . searchsorted ( X , D ) <NEWLINE> E = np . searchsorted ( Y , E ) <NEWLINE> F = np . searchsorted ( Y , F ) <NEWLINE> <NL> H , W = len ( X ) , len ( Y ) <NEWLINE> N = H * W <NEWLINE> <NL> @ njit <NEWLINE> def set_ng ( A , B , C , D , E , F ) : <NEWLINE> <INDENT> p = 0 <NEWLINE> head = np . full ( N , - 1 , np . int32 ) <NEWLINE> ng = np . empty ( 4 * N , np . int32 ) <NEWLINE> nxt = np . empty ( 4 * N , np . int32 ) <NEWLINE> <NL> def add ( v , w ) : <NEWLINE> <INDENT> nonlocal p <NEWLINE> nxt [ p ] = head [ v ] <NEWLINE> head [ v ] = p <NEWLINE> ng [ p ] = w <NEWLINE> p += 1 <NEWLINE> <NL> <DEDENT> for i in range ( len ( A ) ) : <NEWLINE> <INDENT> a , b , c = A [ i ] , B [ i ] , C [ i ] <NEWLINE> for x in range ( a , b ) : <NEWLINE> <INDENT> v = x * W + c <NEWLINE> add ( v , v - 1 ) <NEWLINE> add ( v - 1 , v ) <NEWLINE> <DEDENT> <DEDENT> for i in range ( len ( D ) ) : <NEWLINE> <INDENT> d , e , f = D [ i ] , E [ i ] , F [ i ] <NEWLINE> for y in range ( e , f ) : <NEWLINE> <INDENT> v = d * W + y <NEWLINE> add ( v , v - W ) <NEWLINE> add ( v - W , v ) <NEWLINE> <DEDENT> <DEDENT> return head , ng [ : p ] , nxt [ : p ] <NEWLINE> <NL> <DEDENT> head , ng , nxt = set_ng ( A , B , C , D , E , F ) <NEWLINE> <NL> @ njit <NEWLINE> def next_w ( head , ng , nxt , v ) : <NEWLINE> <INDENT> p = head [ v ] <NEWLINE> V = [ v - W , v + W , v - 1 , v + 1 ] <NEWLINE> while p != - 1 : <NEWLINE> <INDENT> V . discard ( ng [ p ] ) <NEWLINE> p = nxt [ p ] <NEWLINE> <DEDENT> return V <NEWLINE> <NL> <DEDENT> x0 , y0 = np . searchsorted ( X , 0 ) , np . searchsorted ( Y , 0 ) <NEWLINE> v0 = x0 * W + y0 <NEWLINE> <NL> @ njit <NEWLINE> def solve ( ) : <NEWLINE> <INDENT> visited = np . zeros ( N , np . bool_ ) <NEWLINE> visited [ v0 ] = 1 <NEWLINE> stack = np . empty ( N , np . int32 ) <NEWLINE> p = 0 <NEWLINE> ret = 0 <NEWLINE> <NL> def area ( x ) : <NEWLINE> <INDENT> x , y = divmod ( x , W ) <NEWLINE> return DX [ x ] * DY [ y ] <NEWLINE> <NL> <DEDENT> def push ( x ) : <NEWLINE> <INDENT> nonlocal p , ret <NEWLINE> stack [ p ] = x <NEWLINE> visited [ x ] = 1 <NEWLINE> ret += area ( x ) <NEWLINE> p += 1 <NEWLINE> <NL> <DEDENT> def pop ( ) : <NEWLINE> <INDENT> nonlocal p <NEWLINE> p -= 1 <NEWLINE> return stack [ p ] <NEWLINE> <NL> <DEDENT> push ( v0 ) <NEWLINE> while p : <NEWLINE> <INDENT> v = pop ( ) <NEWLINE> for w in next_w ( head , ng , nxt , v ) : <NEWLINE> <INDENT> if visited [ w ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> x , y = divmod ( w , W ) <NEWLINE> if x == 0 or x == H - 1 or y == 0 or y == W - 1 : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> push ( w ) <NEWLINE> <DEDENT> <DEDENT> return ret <NEWLINE> <NL> <DEDENT> x = solve ( ) <NEWLINE> if x == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( x ) <NEWLINE> <DEDENT>
import sys <NEWLINE> import numpy as np <NEWLINE> from numba import njit , types <NEWLINE> from numba . typed import Dict <NEWLINE> <NL> n , m , * abcdef = map ( int , sys . stdin . buffer . read ( ) . split ( ) ) <NEWLINE> <NL> n3 = n * 3 <NEWLINE> aaa = abcdef [ 0 : n3 : 3 ] <NEWLINE> bbb = abcdef [ 1 : n3 : 3 ] <NEWLINE> ccc = abcdef [ 2 : n3 : 3 ] <NEWLINE> ddd = abcdef [ n3 + 0 : : 3 ] <NEWLINE> eee = abcdef [ n3 + 1 : : 3 ] <NEWLINE> fff = abcdef [ n3 + 2 : : 3 ] <NEWLINE> x_list = { 0 } <NEWLINE> x_list . update ( ccc ) <NEWLINE> x_list . update ( eee ) <NEWLINE> x_list . update ( fff ) <NEWLINE> y_list = { 0 } <NEWLINE> y_list . update ( aaa ) <NEWLINE> y_list . update ( bbb ) <NEWLINE> y_list . update ( ddd ) <NEWLINE> <NL> <NL> @ njit <NEWLINE> def create_dict ( x_list ) : <NEWLINE> <INDENT> d = Dict . empty ( key_type = types . int64 , value_type = types . int64 ) <NEWLINE> for i in range ( len ( x_list ) ) : <NEWLINE> <INDENT> d [ x_list [ i ] ] = i + 1 <NEWLINE> <DEDENT> return d <NEWLINE> <NL> <NL> <DEDENT> x_list = np . array ( sorted ( x_list ) , dtype = np . int64 ) <NEWLINE> y_list = np . array ( sorted ( y_list ) , dtype = np . int64 ) <NEWLINE> x_dict = create_dict ( x_list ) <NEWLINE> y_dict = create_dict ( y_list ) <NEWLINE> row_real = len ( x_list ) <NEWLINE> col_real = len ( y_list ) <NEWLINE> row = row_real + 2 <NEWLINE> col = col_real + 2 <NEWLINE> total = row * col <NEWLINE> <NL> banned_up = np . zeros ( total , dtype = np . int16 ) <NEWLINE> banned_left = np . zeros ( total , dtype = np . int16 ) <NEWLINE> <NL> <NL> @ njit <NEWLINE> def register_ver_lines ( a , b , c , banned_left , x_dict , y_dict ) : <NEWLINE> <INDENT> global row <NEWLINE> if a > b : <NEWLINE> <INDENT> a , b = b , a <NEWLINE> <DEDENT> ai = y_dict [ a ] * row <NEWLINE> bi = y_dict [ b ] * row <NEWLINE> j = x_dict [ c ] <NEWLINE> banned_left [ ai + j ] += 1 <NEWLINE> banned_left [ bi + j ] -= 1 <NEWLINE> <NL> <NL> <DEDENT> @ njit <NEWLINE> def register_hor_lines ( d , e , f , banned_up , x_dict , y_dict ) : <NEWLINE> <INDENT> global row <NEWLINE> if e > f : <NEWLINE> <INDENT> e , f = f , e <NEWLINE> <DEDENT> ri = y_dict [ d ] * row <NEWLINE> ej = x_dict [ e ] <NEWLINE> fj = x_dict [ f ] <NEWLINE> banned_up [ ri + ej ] += 1 <NEWLINE> banned_up [ ri + fj ] -= 1 <NEWLINE> <NL> <NL> <DEDENT> @ njit <NEWLINE> def accumulate_banned ( banned_up , banned_left ) : <NEWLINE> <INDENT> global row , col <NEWLINE> for i in range ( 1 , col ) : <NEWLINE> <INDENT> ri0 = row * ( i - 1 ) <NEWLINE> ri1 = row * i <NEWLINE> for j in range ( 1 , row ) : <NEWLINE> <INDENT> banned_up [ ri1 + j ] += banned_up [ ri1 + j - 1 ] <NEWLINE> banned_left [ ri1 + j ] += banned_left [ ri0 + j ] <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> @ njit <NEWLINE> def dfs ( q , enable , x_list , y_list , moves ) : <NEWLINE> <INDENT> c = q . pop ( ) <NEWLINE> <NL> for dc , banned in moves : <NEWLINE> <INDENT> nc = c + dc <NEWLINE> if dc < 0 : <NEWLINE> <INDENT> if banned [ c ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if banned [ nc ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> <DEDENT> if enable [ nc ] == - 1 : <NEWLINE> <INDENT> return - 1 <NEWLINE> <DEDENT> if enable [ nc ] == 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> q . append ( nc ) <NEWLINE> enable [ nc ] = 1 <NEWLINE> <NL> <DEDENT> i , j = divmod ( c , row ) <NEWLINE> t = y_list [ i - 1 ] <NEWLINE> b = y_list [ i ] <NEWLINE> l = x_list [ j - 1 ] <NEWLINE> r = x_list [ j ] <NEWLINE> return ( b - t ) * ( r - l ) <NEWLINE> <NL> <NL> <DEDENT> @ njit <NEWLINE> def solve ( x_list , y_list , x_dict , y_dict , banned_up , banned_left ) : <NEWLINE> <INDENT> global row , col <NEWLINE> s = row * y_dict [ 0 ] + x_dict [ 0 ] <NEWLINE> enable = np . array ( [ - 1 ] * row + ( [ - 1 ] + [ 0 ] * ( row - 2 ) + [ - 1 ] ) * ( col - 2 ) + [ - 1 ] * row , dtype = np . int8 ) <NEWLINE> enable [ s ] = 1 <NEWLINE> moves = [ ( - row , banned_up ) , ( - 1 , banned_left ) , ( 1 , banned_left ) , ( row , banned_up ) ] <NEWLINE> <NL> q = [ s ] <NEWLINE> ans = 0 <NEWLINE> while q : <NEWLINE> <INDENT> ret = dfs ( q , enable , x_list , y_list , moves ) <NEWLINE> if ret == - 1 : <NEWLINE> <INDENT> return - 1 <NEWLINE> <DEDENT> ans += ret <NEWLINE> <NL> <DEDENT> return ans <NEWLINE> <NL> <NL> <DEDENT> for a , b , c in zip ( aaa , bbb , ccc ) : <NEWLINE> <INDENT> register_ver_lines ( a , b , c , banned_left , x_dict , y_dict ) <NEWLINE> <DEDENT> for d , e , f in zip ( ddd , eee , fff ) : <NEWLINE> <INDENT> register_hor_lines ( d , e , f , banned_up , x_dict , y_dict ) <NEWLINE> <NL> <DEDENT> accumulate_banned ( banned_up , banned_left ) <NEWLINE> <NL> ans = solve ( x_list , y_list , x_dict , y_dict , banned_up , banned_left ) <NEWLINE> print ( ans if ans != - 1 else <STRING> ) <NEWLINE>
import sys <NEWLINE> sys . stdin = open ( <STRING> , <STRING> , encoding = <STRING> ) <NEWLINE> <NL> s = input ( ) <NEWLINE> t = input ( ) <NEWLINE> <NL> if t == s + t [ - 1 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
list = [ input ( ) for i in range ( 2 ) ] <NEWLINE> if list [ 1 ] == list [ 2 ] [ : - 1 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
A = input ( ) <NEWLINE> B = input ( ) <NEWLINE> C = B . rstrip ( ) <NEWLINE> if A == C : <NEWLINE> <INDENT> D = <STRING> <NEWLINE> else : <NEWLINE> <INDENT> D = <STRING> <NEWLINE> <DEDENT> <DEDENT> print ( D ) <NEWLINE>
S = input ( ) <NEWLINE> T = input ( ) <NEWLINE> <NL> if T . startswith ( S ) : <NEWLINE> <INDENT> print ( Yes ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( No ) <NEWLINE> <DEDENT>
S = input ( ) <NEWLINE> T = input ( ) <NEWLINE> <NL> T_ = slice ( T [ : - 1 ] ) <NEWLINE> <NL> if ( S == T_ ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
daude = input ( ) <NEWLINE> daude1 = input ( ) <NEWLINE> return daude == daude1 [ : - 1 ] <NEWLINE>
S = input ( ) <NEWLINE> T = input ( ) <NEWLINE> <NL> if S . length == 0 or S . length >= 11 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( S . length ) : <NEWLINE> <INDENT> if S [ i ] != T [ i ] : <NEWLINE> <INDENT> return print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> if T . length == S . length + 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT>
S = input ( ) <NEWLINE> T = input ( ) <NEWLINE> ns = len ( S ) <NEWLINE> U = str [ : ns ] <NEWLINE> if T == U : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
S = list ( input ( ) ) <NEWLINE> T = list ( input ( ) ) <NEWLINE> <NL> <NL> for i in range ( 0 , len ( S ) - 1 ) : <NEWLINE> <INDENT> if ( S [ i ] != T [ i ] ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> if ( len ( S ) + 1 == len ( T ) ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif ( len ( S ) >= len ( T ) ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif ( len ( S ) + 1 < len ( T ) ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
S = str ( input ( ) ) <NEWLINE> T = str ( input ( ) ) <NEWLINE> li = [ ] <NEWLINE> for i in string . ascii_lowercase : <NEWLINE> <INDENT> H = S + i <NEWLINE> li . append ( H ) <NEWLINE> <DEDENT> if T in li : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
<COMMENT> <NL> S = input ( ) <NEWLINE> T = input ( ) <NEWLINE> <NL> if T . startswith ( S ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else ; <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> t = input ( ) <NEWLINE> flag = 0 <NEWLINE> if s in t : <NEWLINE> <INDENT> if ( len ( t ) - len ( s ) = 1 and s [ 0 ] == t [ 0 ] ) : <NEWLINE> <INDENT> flag = 1 <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) if ( flag ) else print ( <STRING> ) <NEWLINE>
s = input ( ) <NEWLINE> t = input ( ) <NEWLINE> for i in renge ( len ( s ) ) <NEWLINE> <INDENT> if s [ i ] == t [ i ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> if i == ( len ( s ) - 1 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
a = input ( ) <NEWLINE> b = input ( ) <NEWLINE> b . pop ( ) <NEWLINE> if a == b [ : - 1 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> t = input ( ) <NEWLINE> n = 0 <NEWLINE> for i in range ( 0 , len ( s ) ) : <NEWLINE> <INDENT> if ( s [ i ] == t [ i ] ) : <NEWLINE> <INDENT> n = n + 1 <NEWLINE> <DEDENT> <DEDENT> if ( n == len ( s ) ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
S = input ( ) <NEWLINE> T = input ( ) <NEWLINE> if S + 1 in T : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
print ( <STRING> [ input ( ) == input ( [ : - 1 ] ) : : 2 ] ) <NEWLINE>
s , t = input ( ) . split ( ) <NEWLINE> if s == t [ : - 1 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
S = input ( ) <NEWLINE> T = input ( ) <NEWLINE> <NL> if ( T [ : len ( S ) ] == S ) and ( len ( T ) = len ( S ) + 1 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
while ( True ) : <NEWLINE> <INDENT> a = input ( ) <NEWLINE> b = input ( ) <NEWLINE> a = str ( a ) <NEWLINE> b = str ( b ) <NEWLINE> length = len ( a ) <NEWLINE> if a == b [ 0 : length ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
a = [ input ( ) for i in range ( 3 ) ] <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> if a [ 0 ] == a [ 1 ] [ : - 1 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
S = input ( ) <NEWLINE> Y = input ( ) <NEWLINE> if Y = S [ : + 1 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
a = input ( ) <NEWLINE> b = input ( ) <NEWLINE> import syss <NEWLINE> for i in range ( len ( a ) ) : <NEWLINE> <INDENT> if a [ i ] == b [ i ] : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
a = int ( input ( ) ) <NEWLINE> b , c = map ( int , input . split ( ) ) <NEWLINE> s = input ( ) <NEWLINE> print ( { } { } . format ( a + b + c , s ) ) <NEWLINE>
S = str ( input ( ) ) <NEWLINE> T = str ( input ( ) ) <NEWLINE> <NL> if S == T [ 0 : - 1 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
A , B , C , K = map ( int , input ( ) . split ( ) ) <COMMENT> <NEWLINE> <NL> if K <= A : <NEWLINE> <INDENT> print ( K ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> maxvalue = A <NEWLINE> K -= A <NEWLINE> if B >= 0 : <NEWLINE> <INDENT> if K > 0 : <NEWLINE> <INDENT> K = K - B <NEWLINE> if K <= 0 : <NEWLINE> <INDENT> print ( maxvalue ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> maxvalue -= K * - 1 <NEWLINE> print ( maxvalue ) <NEWLINE> <NL> <DEDENT>
s = input ( ) <NEWLINE> t = input ( ) <NEWLINE> if s = input ( ) <NEWLINE> t = input ( ) <NEWLINE> if len ( s ) + 1 == len ( t ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
<INDENT> a = input ( ) <NEWLINE> b = input ( ) <NEWLINE> if ( len ( b ) > len ( a ) ) and ( a == b [ : len ( a ) ] ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
[ a , b , h ] = [ int ( input ( ) ) for i in range ( 3 ) ] <NEWLINE> <NL> <NL> result = ( a + b ) * h // 2 <NEWLINE> print ( result ) <NEWLINE>
s = input ( ) <NEWLINE> t = input ( ) <NEWLINE> <NL> if len ( s ) + 1 == len ( t ) and s in t : <NEWLINE> <INDENT> print ( Yes ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> print ( No ) <NEWLINE> <DEDENT>
a = input ( ) <NEWLINE> b = input ( ) <NEWLINE> if len ( a ) + 1 == len ( b ) and a == b [ 0 : a ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
S = input ( ) <NEWLINE> T = input ( ) <NEWLINE> if S == t [ : - 1 ] and S . islower ( ) == True : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
S , T = input ( ) . split ( <STRING> ) <NEWLINE> if S in T : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
S , T = input ( ) . split ( ) <NEWLINE> print ( <STRING> if <STRING> == <STRING> else <STRING> ) <NEWLINE>
S = input ( ) <NEWLINE> T = input ( ) <NEWLINE> S = list ( S ) <NEWLINE> T = list ( T ) <NEWLINE> l = len ( S ) <NEWLINE> if S == T [ : - 1 ] and l <= 10 and l >= 1 and S . islower ( ) : <NEWLINE> <INDENT> print ( True ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( False ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> t = input ( ) <NEWLINE> if t . starttswith ( s ) and len ( s ) + 1 == len ( t ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
x = str ( input ( ) ) <NEWLINE> y = str ( input ( ) ) <NEWLINE> def idx ( x , y ) : <NEWLINE> <INDENT> if len ( y ) - len ( x ) != 1 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( 0 , len ( x ) ) : <NEWLINE> <INDENT> if x [ i ] != y [ i ] : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> return True <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if idx ( x , y ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
S = input ( ) <NEWLINE> T = input ( ) <NEWLINE> <NL> if s + T [ - 1 ] == T : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> t = input ( ) <NEWLINE> if s == t . remove ( t [ len ( t ) - 1 ] ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
S = input ( ) <NEWLINE> T = input ( ) <NEWLINE> yes = True <NEWLINE> l = len ( S ) <NEWLINE> for i in range l : <NEWLINE> <INDENT> if S [ i ] != T [ i ] : <NEWLINE> <INDENT> yes = False <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if yes : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s = input ( ) . strip ( ) <NEWLINE> s_new = input ( ) . strip ( ) <NEWLINE> if s == s_new [ 0 : len ( s ) ] : <NEWLINE> <INDENT> if len ( s ) + 1 = len ( s_new ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
sys . stdin = f <NEWLINE> <NL> S = input ( ) <NEWLINE> T = input ( ) <NEWLINE> <NL> for i in range ( len ( S ) ) : <NEWLINE> <INDENT> if S [ i ] == T [ i ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
s = str ( input ( ) ) <NEWLINE> t = str ( input ( ) ) <NEWLINE> <NL> if len ( t ) = len ( s ) + 1 and len ( s ) >= 1 and len ( s ) <= 10 and s . islower ( ) and t . islower ( ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
S = input ( ) <NEWLINE> T = input ( ) <NEWLINE> if T [ 0 : len ( T ) - 1 ] = S : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
from math import sqrt <NEWLINE> t = int ( input ( ) ) <NEWLINE> for i in range ( t ) : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> t = input ( ) <NEWLINE> if ( t [ : - 1 ] == s ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <DEDENT> <DEDENT>
s , t = map ( str , input ( ) . split ( ) ) <NEWLINE> <NL> if ( s [ : len ( s ) ] == t [ : len ( s ) ] ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
S = print ( ) <NEWLINE> if str ( T ) == str ( S ) + 1 <NEWLINE> <INDENT> input ( Yes ) <NEWLINE> <DEDENT> else input ( No ) <NEWLINE>
S , T = map ( str , input ( ) . split ( ) ) <NEWLINE> if T [ : - 1 ] == S : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <COMMENT> <NL> <NL> <DEDENT>
<INDENT> S = input ( ) <NEWLINE> T = input ( ) <NEWLINE> if S == T [ 0 : len ( S ) ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
S = input ( ) <NEWLINE> T = input ( ) <NEWLINE> if ( T . startsadwith ( S ) ) and len ( T ) == ( len ( S ) + 1 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> t = input ( ) <NEWLINE> <NL> adjusted_t = t [ : - 1 ] <NEWLINE> <NL> if s == adjuested_t : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
S = input ( ) <NEWLINE> T = input ( ) <NEWLINE> if S == T [ : - 1 ] and len ( len ( S ) == len ( T ) + 1 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s , t = input ( ) . split ( ) <NEWLINE> o = t [ : - 1 ] <NEWLINE> if ( o == s ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s , t = input ( ) . split ( ) <NEWLINE> print ( <STRING> if s == t [ : - 1 ] else <STRING> ) <NEWLINE>
S = input ( ) <NEWLINE> T = input ( ) <NEWLINE> <NL> if S == T [ : : - 1 ] <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
base_name = input ( ) <NEWLINE> new_name = input ( ) <NEWLINE> <NL> if new_name [ : - 1 ] = base_name : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> Town = [ ] <NEWLINE> <COMMENT> <NL> rec = [ - 1 ] * ( n + 1 ) <NEWLINE> idx = 1 <NEWLINE> <COMMENT> <NL> while ( rec [ idx ] == - 1 ) : <NEWLINE> <INDENT> rec [ idx ] = len ( Town ) <NEWLINE> Town . append ( idx ) <NEWLINE> idx = A [ idx - 1 ] <NEWLINE> <NL> <DEDENT> Exce = rec . index ( idx ) <NEWLINE> Cycl = len ( Town ) - Exce <NEWLINE> <NL> if Cycl > k : <NEWLINE> <INDENT> print ( Town [ k ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> k -= Exce <NEWLINE> k %= Cycl <NEWLINE> print ( Town [ Exce + k ] ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> t = input ( ) <NEWLINE> print ( <STRING> s == t [ : - 1 ] else <STRING> ) <NEWLINE>
s = input ( ) <NEWLINE> t = input ( ) <NEWLINE> n = len ( s ) <NEWLINE> if s = t [ : n ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s = str ( input ( ) ) <NEWLINE> t = str ( input ( ) ) <NEWLINE> <NL> r = int ( t . replace ( s , <STRING> ) ) <NEWLINE> if r in range ( 10 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
S = input ( ) <NEWLINE> T = input ( ) <NEWLINE> <NL> T_plus = T [ - 1 ] <NEWLINE> T_a = T [ : - 1 ] <NEWLINE> <NL> if S == T_a : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> print ( <STRING> if S == T else <STRING> ) <NEWLINE> <DEDENT>
S = input ( ) <NEWLINE> T = input ( ) <NEWLINE> <NL> T . pop ( - 1 ) <NEWLINE> <NL> if S == T : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
S = ipnut ( ) <NEWLINE> T = input ( ) <NEWLINE> <NL> if ( S == T [ : len ( S ) - 1 ] ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> mod = 998244353 <NEWLINE> if m == 1 : print ( 0 if k != n - 1 else 1 ) ; exit ( ) <NEWLINE> fact = [ 1 ] * ( n - 1 + 1 ) <NEWLINE> inv = [ 1 ] * ( n - 1 + 1 ) <NEWLINE> for i in range ( 2 , n - 1 + 1 ) : <NEWLINE> <INDENT> fact [ i ] = i * fact [ i - 1 ] % mod <NEWLINE> <DEDENT> inv [ - 1 ] = pow ( fact [ - 1 ] , mod - 2 , mod ) <NEWLINE> for i in range ( n - 1 , 1 , - 1 ) : <NEWLINE> <INDENT> inv [ i - 1 ] = inv [ i ] * i % mod <NEWLINE> <DEDENT> ans = 0 <NEWLINE> po = pow ( m - 1 , n - 1 , mod ) * m % mod <NEWLINE> ue = fact [ n - 1 ] <NEWLINE> iii = pow ( m - 1 , mod - 2 , mod ) % mod <NEWLINE> for i in range ( k + 1 ) : <NEWLINE> <INDENT> ans += ue * inv [ n - 1 - i ] % mod * inv [ i ] % mod * po % mod <NEWLINE> po *= iii <NEWLINE> <DEDENT> print ( ans % mod ) <NEWLINE>
S , T = list ( input ( ) . split ( ) ) <NEWLINE> if T [ : - 1 ] == S : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a = str ( input ( ) ) <NEWLINE> b = str ( input ( ) ) <NEWLINE> c = b [ - 1 ] <NEWLINE> if a + c == b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> n = int ( input ( ) ) <NEWLINE> <NL> unit = { 0 : <STRING> , 1 : <STRING> , 2 : <STRING> , 3 : <STRING> , 4 : <STRING> , 5 : <STRING> , 6 : <STRING> , 7 : <STRING> , 8 : <STRING> , 9 : <STRING> } <NEWLINE> <NL> x = n % 10 <NEWLINE> print ( unit [ x ] ) <NEWLINE>
s = input ( ) <NEWLINE> t = input ( ) <NEWLINE> if s = t [ : - 1 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
T = input ( ) <NEWLINE> <NL> if S == T [ : len ( T ) - 1 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
S = input ( ) <NEWLINE> T = input ( ) <NEWLINE> if T = S + T [ - 1 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT>
s = input ( ) <NEWLINE> t = input ( ) <NEWLINE> <NL> if len ( s ) + 1 == len ( t ) and s in t : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> else : <NEWLINE> print ( <STRING> ) <NEWLINE> <DEDENT>
S = input ( ) <NEWLINE> T = input ( ) <NEWLINE> <NL> if S == T [ : - 2 ] <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
S = input ( ) <NEWLINE> <NL> T = input ( ) <NEWLINE> <NL> x = T [ 0 : - 1 ] <NEWLINE> <NL> if S == x and : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b , c , k = map ( int , input ( ) . split ( ) ) <NEWLINE> if a >= k : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s = k - a <NEWLINE> if a + b >= s : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> c = k - a - b <NEWLINE> print ( a - c ) <NEWLINE> <DEDENT> <DEDENT>
def get_int ( s , si , ei = None ) : <NEWLINE> <COMMENT> <NL> <INDENT> if ei is None : <NEWLINE> <INDENT> value = int ( s [ si : ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> value = int ( s [ si : ei ] ) <NEWLINE> <COMMENT> <NL> <DEDENT> return value <NEWLINE> <NL> <NL> <DEDENT> BIT = 1 <NEWLINE> <NL> str_s = input ( ) <NEWLINE> s = int ( str_s ) <NEWLINE> slen = len ( str_s ) <NEWLINE> <NL> result = 0 <NEWLINE> for i in range ( 2 ** ( slen - 1 ) ) : <NEWLINE> <COMMENT> <NL> <INDENT> s_index = 0 <NEWLINE> for k in range ( slen - 1 ) : <NEWLINE> <INDENT> bit = ( i >> k ) & BIT <NEWLINE> if bit == 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> e_index = k + 1 <NEWLINE> value = get_int ( str_s , s_index , e_index ) <NEWLINE> result += value <NEWLINE> s_index = e_index <NEWLINE> <DEDENT> value = get_int ( str_s , s_index ) <NEWLINE> result += value <NEWLINE> <NL> <DEDENT> print ( result ) <NEWLINE>
S = input ( ) <NEWLINE> T = input ( ) <NEWLINE> return T . startswith ( S ) <NEWLINE>
s = input ( ) <NEWLINE> t = input ( ) <NEWLINE> bool = 0 <NEWLINE> list = [ <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> for i in list : <NEWLINE> <INDENT> if s + i == t : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> bool += 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if bool = 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> town_list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> roop = 0 <NEWLINE> queue = [ 1 ] <NEWLINE> <NL> start = - 1 <NEWLINE> <NL> for now_town in queue : <NEWLINE> <INDENT> if town_list [ now_town - 1 ] in queue : <NEWLINE> <INDENT> start = town_list [ now_town - 1 ] <NEWLINE> break <NEWLINE> <DEDENT> queue . append ( town_list [ now_town - 1 ] ) <NEWLINE> <NL> <DEDENT> if start == - 1 : <NEWLINE> <INDENT> print ( queue [ K ] ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> before_len = queue . index ( start ) <NEWLINE> roop = len ( queue ) - before_len <NEWLINE> <NL> print ( queue [ before_len + ( K - before_len ) % roop ] ) <NEWLINE>
<COMMENT> <NL> <STRING> <NEWLINE> import sys <NEWLINE> import itertools <NEWLINE> <NL> __author__ = <STRING> <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> [ N , M , X ] = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> l = [ ] <NEWLINE> for n in range ( N ) : <NEWLINE> <INDENT> l . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> status = [ 0 ] * M <NEWLINE> for n in range ( N ) : <NEWLINE> <INDENT> for m in range ( M ) : <NEWLINE> <INDENT> status [ m ] += l [ n ] [ m + 1 ] <NEWLINE> <DEDENT> <DEDENT> for v in status : <NEWLINE> <INDENT> if v < X : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> <DEDENT> min_cost = sys . maxsize <NEWLINE> for p in itertools . permutations ( range ( N ) ) : <NEWLINE> <COMMENT> <NL> <INDENT> cost = 0 <NEWLINE> status = [ 0 ] * M <NEWLINE> for n in p : <NEWLINE> <INDENT> cost += l [ n ] [ 0 ] <NEWLINE> if min_cost < cost : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> isCompleted = True <NEWLINE> for m in range ( M ) : <NEWLINE> <INDENT> status [ m ] += l [ n ] [ m + 1 ] <NEWLINE> if status [ m ] < X : <NEWLINE> <INDENT> isCompleted = False <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> if isCompleted : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <INDENT> if cost < min_cost : <NEWLINE> <INDENT> min_cost = cost <NEWLINE> <DEDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if min_cost == sys . maxsize : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( min_cost ) <NEWLINE> <NL> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> t = input ( ) <NEWLINE> if len ( t - s ) == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
S = input ( ) <NEWLINE> T = input ( ) <NEWLINE> <NL> if S == [ T : - 1 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
S = input ( ) <NEWLINE> T = input ( ) <NEWLINE> if s == T [ : - 1 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b , c , d = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if a + b >= d : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( a - ( d - a - b ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> S = input ( ) <NEWLINE> T = input ( ) <NEWLINE> length = len [ S ] - 1 <NEWLINE> <NL> for i in range ( length ) : <NEWLINE> <INDENT> if S [ i ] == T [ i ] : <NEWLINE> <INDENT> i = i + 1 <NEWLINE> if i == len [ T ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT>
s = input ( ) <NEWLINE> t = input ( ) <NEWLINE> l = len ( t ) <NEWLINE> judge = True <NEWLINE> for i in range ( l - 1 ) : <NEWLINE> <INDENT> if s [ i ] == t [ i ] : <NEWLINE> <INDENT> judge = False <NEWLINE> <DEDENT> <DEDENT> if judge == True : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> t = input ( ) <NEWLINE> if len ( s ) + 1 == len ( t ) : <NEWLINE> <INDENT> if all ( s [ i ] == t [ i ] for i in range ( len ( s ) ) ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : print ( <STRING> ) <NEWLINE>
S = input ( ) <NEWLINE> T = input ( ) <NEWLINE> <NL> if ( T [ : - 1 ] == S ) & & ( len ( S ) = len ( T ) - 1 ) : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT>
i = input ( ) <NEWLINE> s = i ( ) <NEWLINE> t = i ( ) <NEWLINE> print ( [ <STRING> , <STRING> ] [ t [ : - 1 ] == s ] ) <NEWLINE>
S = input ( ) <NEWLINE> T = in @ ut ( ) <NEWLINE> <NL> if ( S == T [ : - 1 ] ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
S = list ( input ( ) ) <NEWLINE> T = list ( input ( ) ) <NEWLINE> a = 0 <NEWLINE> for i in range ( 0 , s ) : <NEWLINE> <INDENT> if S [ i ] != T [ i ] : <NEWLINE> <INDENT> a = 1 <NEWLINE> <DEDENT> <DEDENT> if a == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s , t = input ( ) . split ( ) <NEWLINE> <NL> t = t [ : - 1 ] <NEWLINE> <NL> if s == t : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <NL> <NL> <DEDENT>
<COMMENT> <NL> <NL> list = [ input ( ) for i in range ( 3 ) ] <NEWLINE> <NL> S = list [ 0 ] <NEWLINE> T = list [ 1 ] <NEWLINE> <NL> s = len ( S ) <NEWLINE> t = len ( T ) <NEWLINE> <NL> <NL> if t == s + 1 and S == T [ : - 1 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> t = input ( ) <NEWLINE> if t . startswich ( s ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> t = input ( ) <NEWLINE> flag = True <NEWLINE> if ( len ( s ) = len ( t ) - 1 ) : <NEWLINE> <INDENT> x = len ( s ) <NEWLINE> for i in range ( x ) : <NEWLINE> <INDENT> if s [ i ] != t [ i ] : <NEWLINE> <INDENT> flag = False <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if ( flag ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
S , T = input ( ) . split ( ) <NEWLINE> <NL> if S == T [ : len ( S ) ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
S = input ( ) <NEWLINE> T = input ( ) <NEWLINE> <NL> if T . startwith ( <STRING> ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
S , T = map ( input ( ) ) <NEWLINE> <NL> if S == T [ : len ( S ) ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
S = input ( ) <NEWLINE> T = input ( ) <NEWLINE> judge = 0 <NEWLINE> for i in range ( len ( S ) ) : <NEWLINE> <INDENT> if S [ i ] != = T [ i ] : <NEWLINE> <INDENT> judge = 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if judge == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> t = input ( ) <NEWLINE> <NL> if s = t [ : - 1 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
S = input ( ) <NEWLINE> T = input ( ) <NEWLINE> <NL> if T [ : - 1 ] == S : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <INDENT> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
a , b = input ( ) . split ( ) <NEWLINE> if a == b [ 0 : - 1 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
string , string2 = map ( str , input ( ) . split ( ) ) <NEWLINE> string2 = string2 [ 0 : len ( string2 ) - 1 ] <NEWLINE> print ( <STRING> if string == string2 else <STRING> ) <NEWLINE>
s = input ( ) <NEWLINE> t = input ( ) <NEWLINE> if len ( s ) + 1 = len ( t ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s = input ( ) . strip ( ) <NEWLINE> t = input ( ) . strip ( ) <NEWLINE> <NL> print <STRING> if s == t [ : len ( s ) ] and len ( t ) == len ( s ) + 1 else <STRING> <NEWLINE>
S = input ( ) <NEWLINE> T = input ( ) <NEWLINE> <NL> if len ( S ) == len ( T ) - 1 : <NEWLINE> <INDENT> Slis = list ( S ) <NEWLINE> Tlis = list ( T ) <NEWLINE> if str , islower ( Tlis [ - 1 ] ) == True : <NEWLINE> <INDENT> Tlis . remove ( Tlis [ - 1 ] ) <NEWLINE> if Slis == Tlis : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
tmp = input ( ) . split ( <STRING> ) <NEWLINE> S = tmp [ 0 ] <NEWLINE> T = tmp [ 1 ] <NEWLINE> <NL> if T . startwith ( S ) and len ( T ) + len ( S ) == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a <NEWLINE>
s = input ( ) <NEWLINE> t = input ( ) <NEWLINE> <NL> if t = ( s + 1 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a = input ( ) <NEWLINE> b = input ( ) <NEWLINE> <NL> if b [ 0 : - 1 ] == a <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
<INDENT> S = input ( ) <NEWLINE> T = input ( ) <NEWLINE> if S == T [ : - 1 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
A = input ( ) . split ( ) <NEWLINE> S = A [ 0 ] <NEWLINE> T = A [ 1 ] <NEWLINE> s = [ ] <NEWLINE> t = [ ] <NEWLINE> for c in S : <NEWLINE> <INDENT> s . append ( c ) <NEWLINE> <DEDENT> for c in T : <NEWLINE> <INDENT> t . append ( c ) <NEWLINE> <NL> <DEDENT> v = 1 <NEWLINE> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> if not s [ i ] == t [ i ] : <NEWLINE> <INDENT> v = 0 <NEWLINE> <DEDENT> <DEDENT> if v == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
if S [ 0 : ( len ( S ) ) ] == T [ 0 : ( len ( S ) ) ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
S = input ( ) <NEWLINE> T = input ( ) <NEWLINE> if ( S in T ) and ( S [ 0 ] == T [ 0 ] ) <NEWLINE> <INDENT> if ( ( len ( S ) > 1 ) and ( S [ 1 ] == T [ 1 ] ) ) or ( len ( S ) == 1 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT>
from itertools import produce <NEWLINE> <NL> A , B , C , K = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> <NL> <NL> print ( produce ( [ A ] * K , [ B ] * K , [ C ] * K ) ) <NEWLINE>
s , t = input ( ) <NEWLINE> if t [ : - 1 ] == s : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s = input ( ) . trim ( ) <NEWLINE> t = input ( ) . trim ( ) <NEWLINE> <NL> if s in t and s < t and len ( s ) <= 10 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> t = input ( ) <NEWLINE> k = abcdefghijklmnopqrstuvwxwz <NEWLINE> <NL> <NL> if s == t [ : - 1 ] : <NEWLINE> <INDENT> if t [ - 1 ] in k : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
S = int ( input ( <STRING> ) ) <NEWLINE> T = int ( input ( <STRING> ) ) <NEWLINE> <NL> v = <STRING> or <STRING> or <STRING> or <STRING> or <STRING> or <STRING> or <STRING> or <STRING> or <STRING> or <STRING> or <STRING> or <STRING> or <STRING> or <STRING> or <STRING> or <STRING> or <STRING> or <STRING> or <STRING> or <STRING> or <STRING> or <STRING> or <STRING> or <STRING> or <STRING> <NEWLINE> <NL> if S = ( ( v + v + v + v + v + v + v + v + v + v ) or ( v + v + v + v + v + v + v + v + v ) or ( v + v + v + v + v + v + v + v ) or ( v + v + v + v + v + v + v ) or ( v + v + v + v + v + v ) or ( v + v + v + v + v ) or ( v + v + v + v ) or ( v + v + v ) or ( v + v ) or ( v ) <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> if S = ( T + v ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> t = input ( ) <NEWLINE> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> if s [ i ] != t [ i ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <INDENT> quit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
import re <NEWLINE> <NL> a = input ( ) <NEWLINE> b = input ( ) <NEWLINE> <NL> if len ( b ) - len ( a ) == 1 : <NEWLINE> <INDENT> if re . search ( a , b ) is None : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
S = input ( ) <NEWLINE> T = input ( ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( len ( T ) ) : <NEWLINE> <INDENT> if len ( S ) > 10 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if S [ i ] == T [ i ] : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if ans == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
S , T = map ( str , input ( ) . split ( ) ) <NEWLINE> a = T [ - 1 ] <NEWLINE> if T == S + a : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
name = input ( ) <NEWLINE> len_n = len ( name ) <NEWLINE> name2 = input ( ) <NEWLINE> len_n2 = len ( name2 ) <NEWLINE> <NL> if name == name2 [ : - 2 ] & & len_n + 1 == len_n2 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
from numba import njit <NEWLINE> import numpy as np <NEWLINE> <NL> <NL> def main ( S , T ) : <NEWLINE> <INDENT> if len ( T ) - len ( S ) != 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> return <NEWLINE> <DEDENT> count = 0 <NEWLINE> for i in range ( len ( S ) ) : <NEWLINE> <INDENT> if S [ i ] != T [ i ] : <NEWLINE> <INDENT> count += 1 <NEWLINE> if count > 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> return <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> main ( S , T ) <NEWLINE>
s = input ( ) <NEWLINE> t = input ( ) <NEWLINE> <NL> print ( t2 ) <NEWLINE> if s == t2 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
S = input ( ) <NEWLINE> T = input ( ) <NEWLINE> <NL> if T . startswith ( S ) : <NEWLINE> <INDENT> if len ( T ) == ( len ( S ) + 1 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) 1 <NEWLINE> <DEDENT>
import sys <NEWLINE> def LI ( ) : return list ( map ( int , sys . stdin . buffer . readline ( ) . split ( ) ) ) <NEWLINE> def I ( ) : return int ( sys . stdin . buffer . readline ( ) ) <NEWLINE> def LS ( ) : return sys . stdin . buffer . readline ( ) . rstrip ( ) . decode ( <STRING> ) . split ( ) <NEWLINE> def S ( ) : return sys . stdin . buffer . readline ( ) . rstrip ( ) . decode ( <STRING> ) <NEWLINE> def IR ( n ) : return [ I ( ) for i in range ( n ) ] <NEWLINE> def LIR ( n ) : return [ LI ( ) for i in range ( n ) ] <NEWLINE> def SR ( n ) : return [ S ( ) for i in range ( n ) ] <NEWLINE> def LSR ( n ) : return [ LS ( ) for i in range ( n ) ] <NEWLINE> def SRL ( n ) : return [ list ( S ( ) ) for i in range ( n ) ] <NEWLINE> def MSRL ( n ) : return [ [ int ( j ) for j in list ( S ( ) ) ] for i in range ( n ) ] <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> S = S ( ) <NEWLINE> T = S ( ) <NEWLINE> <NL> if len ( S + 1 ) == len ( T ) : <NEWLINE> <INDENT> for i in len ( S ) : <NEWLINE> <INDENT> if S [ i ] != T [ i ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
S = input ( ) <NEWLINE> T = input ( ) <NEWLINE> flag = 1 <NEWLINE> for i in S : <NEWLINE> <INDENT> if not 96 < ord ( s ) and ord ( s ) < 122 : <NEWLINE> <INDENT> flag = 0 <NEWLINE> <NL> <DEDENT> if T [ len ( t ) - 1 ] : <NEWLINE> <INDENT> flag = 0 <NEWLINE> <DEDENT> if not len ( T ) - len ( S ) == 1 : <NEWLINE> <INDENT> flag = 0 <NEWLINE> <DEDENT> if not T [ : - 1 ] == S : <NEWLINE> <INDENT> flag = 0 <NEWLINE> <DEDENT> <DEDENT> print ( Yes if flag == 1 else No ) <NEWLINE>
S , T = input ( ) . split ( ) <NEWLINE> <NL> if S == T [ 0 : - 1 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
<NL> if len ( str1 ) + 1 == len ( str2 ) and str1 == str2 [ : - 1 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b = input ( ) . split ( ) <NEWLINE> <NL> if ( a + b [ - 1 ] ) == b : <NEWLINE> <NL> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
S , T = map ( str , input ( ) . split ( ) ) <NEWLINE> S_list = list ( S ) <NEWLINE> T_list = list ( T ) <NEWLINE> count = 0 <NEWLINE> for i in range ( len ( S ) ) : <NEWLINE> <INDENT> if S [ i ] == T [ i ] : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> if count == len ( S_list ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
first_str = input ( ) <NEWLINE> second_str = input ( ) <NEWLINE> <NL> if first_str == secofirst_str = input ( ) <NEWLINE> second_str = input ( ) <NEWLINE> <NL> <NL> if first_str == second_str [ : len ( first_str ) ] and len ( first_str ) + 1 == len ( second_str ) and second_str [ - 1 ] . islower ( ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
A , B , C , K = map ( int , input ( ) . split ( ) ) <NEWLINE> if A >= K : <NEWLINE> <INDENT> print ( K ) <NEWLINE> <DEDENT> elif A + B >= K : <NEWLINE> <INDENT> print ( A ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( A - ( K - A - B ) ) <NEWLINE> <DEDENT>
a , b = input ( ) . split ( ) <NEWLINE> b = b [ : - 1 ] <NEWLINE> <NL> if a == b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
S = str ( input ( ) ) <NEWLINE> T = str ( input ( ) ) <NEWLINE> t = int ( len ( T ) ) - 2 <NEWLINE> <NL> if S == T [ : t ] <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
def resolve ( ) : <NEWLINE> <INDENT> S , T = input ( ) . split ( ) <NEWLINE> if T [ : - 1 ] == S : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> resolve ( ) <NEWLINE>
s = input ( ) <NEWLINE> t = input ( ) <NEWLINE> n = len ( s ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if s [ i ] != t [ i ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> return 0 <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
from sys import stdin , stdout <NEWLINE> import math , sys <NEWLINE> from itertools import permutations , combinations <NEWLINE> from collections import defaultdict , deque , OrderedDict <NEWLINE> import bisect as bi <NEWLINE> import heapq <NEWLINE> <NL> <STRING> <NEWLINE> <COMMENT> <NL> <NL> sys . stdin = open ( <STRING> , <STRING> ) ; sys . stdout = open ( <STRING> , <STRING> ) ; <NEWLINE> def I ( ) : return ( int ( input ( ) ) ) <NEWLINE> def In ( ) : return ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> a = list ( input ( ) ) <NEWLINE> b = list ( input ( ) ) <NEWLINE> temp = b . pop ( ) <NEWLINE> if a == b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> except : <NEWLINE> <INDENT> pass <NEWLINE> <NL> <DEDENT> <DEDENT> M = 998244353 <NEWLINE> P = 1000000007 <NEWLINE> <NL> if __name__ == <STRING> : <NEWLINE> <INDENT> for _ in range ( 1 ) : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT> <DEDENT>
a , b = [ input ( ) for i in range ( 2 ) ] <NEWLINE> <NL> if a = b [ : - 1 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import sys <NEWLINE> a = sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> b = sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> if a == b [ : - 1 ] : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT>
if S == T [ : - 1 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
S = input ( ) <NEWLINE> T = input ( ) <NEWLINE> <NL> if S . length < 1 | | 10 < S . length : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> elif S . length + 1 == T . length : <NEWLINE> <INDENT> if S + T [ T . length - 1 ] == T : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT>
s , t = input ( ) . split ( ) <NEWLINE> if s == t [ : - 1 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
S = input ( ) <NEWLINE> T = input ( ) <NEWLINE> T . pop ( len ( str ) ) <NEWLINE> if ( T == S ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> t = input ( ) <NEWLINE> if len ( s ) + 1 = len ( t ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
S = input ( ) <NEWLINE> T = input ( ) <NEWLINE> if ( T = S + 1 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a = input ( ) <NEWLINE> b = input ( ) <NEWLINE> <NL> for i in range ( len ( b ) ) : <NEWLINE> <INDENT> if a [ i ] != b [ i ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> if i == len ( b ) - 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
S , T = list ( map ( str , input ( ) . split ( ) ) ) <NEWLINE> <NL> if ( abs ( len ( T ) - len ( S ) ) == 1 ) and ( T [ : - 1 ] == S ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
S = input ( ) <NEWLINE> T = input ( ) <NEWLINE> if ( T [ : - 1 ] == S ) : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT>
s = [ input ( ) for i in range ( 2 ) ] <NEWLINE> if s [ 0 ] = s [ 1 ] [ : - 1 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
S = input ( ) <NEWLINE> T = input ( ) <NEWLINE> <NL> if ( S == T [ 0 : len ( S ) ] ) : <NEWLINE> <INDENT> print ( Yes ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( No ) <NEWLINE> <NL> <NL> <DEDENT>
a = input ( ) <NEWLINE> b = input ( ) <NEWLINE> c = 0 <NEWLINE> if ( len ( a ) + 1 ) != len ( b ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( len ( b ) ) : <NEWLINE> <INDENT> if a [ i ] == b [ i ] : <NEWLINE> <INDENT> c = c + 1 <NEWLINE> <DEDENT> <DEDENT> if c == len ( a ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
s = input ( ) <NEWLINE> t = input ( ) <NEWLINE> <NL> if s [ 0 : len ( s ) ] == t [ 0 : len ( t ) ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> eles : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s = raw_input ( ) <NEWLINE> t = raw_input ( ) <NEWLINE> <NL> ls = len ( s ) <NEWLINE> lt = len ( t ) <NEWLINE> <NL> if lt == ls + 1 and t . startswith ( s ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <NL> <DEDENT>
s = input ( ) <NEWLINE> t = input ( ) <NEWLINE> a = len ( s ) <NEWLINE> <NL> if len ( x ) <= 10 and len ( x ) >= 1 and len ( t ) == len ( s ) + 1 and t [ 0 : a ] == s [ 0 : a ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
S = input ( ) <NEWLINE> T = input ( ) <NEWLINE> <NL> ans = <STRING> <NEWLINE> if len ( S ) + 1 == len ( T ) : <NEWLINE> <INDENT> if T . startswith ( S ) is True : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
s , t = map ( str , input ( ) . split ( ) ) <NEWLINE> l = len ( t ) - 1 <NEWLINE> print ( <STRING> ) if s == t [ : l ] else print ( <STRING> ) <NEWLINE>
str = input ( ) . split ( ) <NEWLINE> a = str [ 0 ] <NEWLINE> a_len = len ( a ) <NEWLINE> b = str [ 1 ] <NEWLINE> b_r = str [ : - 1 ] <NEWLINE> <NL> <NL> if b_r [ 0 ] == a and a_len <= 10 and a_len >= 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a = str ( input ( ) ) <NEWLINE> b = str ( input ( ) ) <NEWLINE> if a = <STRING> and b = <STRING> or a = <STRING> and b = <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a = <STRING> and b = <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
S = str ( input ( ) ) <NEWLINE> T = str ( input ( ) ) <NEWLINE> <NL> if len ( S ) + 1 == len ( T ) and S = T [ : - 1 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s , t = input ( ) . split ( ) <NEWLINE> if ( t [ 0 : - 1 ] == s ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
<INDENT> pass1 = str ( input ( ) ) <NEWLINE> pass2 = str ( input ( ) ) <NEWLINE> <NL> pass2_org = pass2 [ 0 : - 1 ] <NEWLINE> <NL> if pass1 == pass2_org : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
s = input ( ) <NEWLINE> t = input ( ) <NEWLINE> r = t . len ( ) <NEWLINE> if s in t [ 0 , r ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
= input ( ) <NEWLINE> t = input ( ) <NEWLINE> for i in range ( 0 , len ( s ) ) : <NEWLINE> <INDENT> if ( s [ i ] != t [ i ] ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> if ( i == len ( s ) ) : <NEWLINE> <INDENT> if ( len ( s ) == ( len ( t ) - 1 ) ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> ( <STRING> ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> t = input ( ) <NEWLINE> print ( <STRING> if s == t [ : - 1 ] <STRING> ) <NEWLINE>
s = input ( ) <NEWLINE> t = input ( ) <NEWLINE> <NL> flag = True <NEWLINE> for i in range ( s ) : <NEWLINE> <INDENT> if s [ i ] is not t [ i ] : <NEWLINE> <INDENT> flag = False <NEWLINE> <DEDENT> <DEDENT> if flag is True : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> t = input ( ) <NEWLINE> <NL> if ( s == t [ : - 1 ] & len ( s ) + 1 == len ( t ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import math <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> S = input ( ) <NEWLINE> T = input ( ) <NEWLINE> <NL> if S == T [ : - 1 ] and len ( T ) == 1 + len ( S ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> print ( <STRING> ) <NEWLINE> <NL> <NL> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
S = input ( ) <NEWLINE> T = input ( ) <NEWLINE> if S == T [ : len ( T ) - 1 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> else : <NEWLINE> print ( <STRING> ) <NEWLINE> <DEDENT>
S , T = input ( ) . split ( ) <NEWLINE> if S == T [ : len ( S ) - 1 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
print ( <STRING> if input ( ) == input ( ) [ : - 1 ] ) <NEWLINE>
s = input ( ) <NEWLINE> t = input ( ) <NEWLINE> u = t . rstip ( t [ len ( t ) - 1 ] ) <NEWLINE> out = ( <STRING> , <STRING> ) [ s == u ] <NEWLINE> print ( out ) <NEWLINE>
a = input ( ) <NEWLINE> b = inout ( ) <NEWLINE> <NL> if ( a == b [ : len ( a ) - 1 ] ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a = input ( ) <NEWLINE> a = a . split ( ) <NEWLINE> <NL> x = str ( a [ 0 ] ) <NEWLINE> y = str ( a [ 1 ] ) <NEWLINE> <NL> y = y [ : - 1 ] <NEWLINE> <NL> if x == y : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s = [ input ( ) for i in range ( 2 ) ] <NEWLINE> <NL> s_length = len ( s [ 0 ] ) <NEWLINE> s2_length = len ( s [ 1 ] ) <NEWLINE> <NL> if s2_length == s_length + 1 and s [ 0 ] == s [ 1 ] [ : s_length ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) _l <NEWLINE> <DEDENT>
S = input ( ) <NEWLINE> T = input ( ) <NEWLINE> if ( len ( S ) + 1 == len ( T ) ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else ( ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
S = input ( ) <NEWLINE> T = input ( ) <NEWLINE> <NL> s = len ( S ) <NEWLINE> <NL> if S != T [ : s ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> if ( s + 1 ) = len ( T ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
s = input ( ) <NEWLINE> t = input ( ) <NEWLINE> if ( s == t [ 0 : len ( s ) ] & & len ( s ) + 1 == len ( t ) ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s = list ( input ( ) ) <NEWLINE> t = list ( input ( ) ) <NEWLINE> n = int ( len ( t ) ) <NEWLINE> if s = t [ 0 : n - 2 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
S = input ( ) <NEWLINE> T = input ( ) <NEWLINE> <NL> if S == T [ : - 1 ] <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> else : <NEWLINE> print ( <STRING> ) <NEWLINE> <DEDENT>
S = input ( ) <NEWLINE> T = input ( ) <NEWLINE> if S == D [ : len ( S ) ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
<COMMENT> <NL> def main ( ) : <NEWLINE> <INDENT> S , T = map ( int , open ( 0 ) . read ( ) . split ( ) ) <NEWLINE> print ( <STRING> if T [ : - 1 ] == S else <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> a , b , c , k = map ( int , input ( ) . split ( ) ) <NEWLINE> if k <= a : <NEWLINE> <INDENT> print ( k ) <NEWLINE> <DEDENT> elif a < k <= a + b : <NEWLINE> <INDENT> print ( k ) <NEWLINE> <DEDENT> else : <NEWLINE> <COMMENT> <NL> <INDENT> print ( a - ( k - ( a + b ) ) ) <NEWLINE> <DEDENT>
nums = input ( ) <NEWLINE> S , T = nums . split ( <STRING> ) <NEWLINE> <NL> if len ( S ) + 1 != len ( T ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> elif T [ 0 : len ( S ) ] == S : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
S , T = input ( ) <NEWLINE> a = 0 <NEWLINE> for i in range ( len ( S ) ) : <NEWLINE> <INDENT> if S [ i ] != T [ i ] : <NEWLINE> <INDENT> a += 1 <NEWLINE> <DEDENT> <DEDENT> if a == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <NL> <NL> <DEDENT>
def resolve ( ) : <NEWLINE> <INDENT> S = input ( ) <NEWLINE> T = input ( ) <NEWLINE> <NL> if re . match ( <STRING> , S ) and re . match ( S + <STRING> , T ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> resolve ( ) <NEWLINE>
S = input ( ) <NEWLINE> T = input ( ) <NEWLINE> <NL> a = 1 <NEWLINE> if len ( T ) == len ( S ) + 1 : <NEWLINE> <INDENT> for i in range ( len ( S ) ) : <NEWLINE> <INDENT> if S [ i ] == T [ i ] : <NEWLINE> <INDENT> a = 1 <NEWLINE> if a == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> a = 0 <NEWLINE> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> S = input ( ) <NEWLINE> T = input ( ) <NEWLINE> <NL> a = 1 <NEWLINE> if len ( T ) == len ( S ) + 1 : <NEWLINE> <INDENT> for i in range ( len ( S ) ) : <NEWLINE> <INDENT> if S [ i ] == T [ i ] : <NEWLINE> <INDENT> a = 1 <NEWLINE> if a == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> a = 0 <NEWLINE> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> if a == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
S = inputs ( ) <NEWLINE> T = inputs ( ) <NEWLINE> print ( <STRING> if T . startswith ( S ) and len ( T ) == len ( S ) + 1 else <STRING> , flush = True ) <NEWLINE>
S = input ( ) <NEWLINE> T = input ( ) <NEWLINE> if S == T [ : - 1 ] : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT>
moji = [ input ( ) for i in range ( 2 ) ] <NEWLINE> if len ( moji [ 0 ] ) >= 1 and len ( moji [ 0 ] ) <= 10 and len ( moji [ 0 ] ) + 1 = len ( moji [ 1 ] ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
A , B , C , K = input ( ) . split ( ) <NEWLINE> <COMMENT> <NL> ans = 0 <NEWLINE> <NL> for a in range ( int ( K ) ) : <NEWLINE> <INDENT> if int ( A ) == int ( K ) : <NEWLINE> <INDENT> ans = A <NEWLINE> break <NEWLINE> <DEDENT> elif int ( A ) <= int ( K ) : <NEWLINE> <INDENT> ans = A <NEWLINE> <NL> <DEDENT> elif int ( B ) <= int ( K ) : <NEWLINE> <INDENT> ans = A <NEWLINE> <NL> <DEDENT> elif int ( C ) <= int ( K ) : <NEWLINE> <INDENT> ans = ( - 1 * C ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if int ( A ) == int ( K ) : <NEWLINE> <INDENT> print ( K ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( int ( A ) + int ( B ) - int ( C ) ) <NEWLINE> <DEDENT>
userData = input ( ) <NEWLINE> <NL> userDatas = input ( ) <NEWLINE> <NL> if userData == useDatas [ 0 : - 1 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> list_a = [ ] <NEWLINE> list_b = [ ] <NEWLINE> list_a . append ( 1 ) <NEWLINE> count_a = 1 <NEWLINE> count_b = 0 <NEWLINE> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> if i == 1 : <NEWLINE> <INDENT> k = i <NEWLINE> <DEDENT> if a [ k - 1 ] in list_b : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> elif a [ k - 1 ] in list_a : <NEWLINE> <INDENT> list_b . append ( a [ k - 1 ] ) <NEWLINE> count_b += 1 <NEWLINE> <DEDENT> if a [ k - 1 ] not in list_a : <NEWLINE> <INDENT> list_a . append ( a [ k - 1 ] ) <NEWLINE> count_a += 1 <NEWLINE> <DEDENT> k = a [ k - 1 ] <NEWLINE> <COMMENT> <NL> <DEDENT> if count_b != 0 : <NEWLINE> <INDENT> num_k = K - ( count_a - count_b ) <NEWLINE> num_k = num_k % count_b <NEWLINE> if 1 in list_b and list_b [ 0 ] != 1 : <NEWLINE> <COMMENT> <NL> <INDENT> list_b . insert ( 0 , 1 ) <NEWLINE> <DEDENT> print ( list_b [ num_k ] ) <NEWLINE> <DEDENT> elif count_b == 0 : <NEWLINE> <INDENT> print ( list_a [ count_a - 1 ] ) <NEWLINE> <DEDENT>
S = int ( input ( ) ) <NEWLINE> T = int ( input ( ) ) <NEWLINE> <NL> t = word . rstrip ( T ) <NEWLINE> <NL> if S == T : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = input ( ) <NEWLINE> if ( N [ - 1 ] == str ( 3 ) ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif ( int ( N [ - 1 ] ) == 0 or int ( N [ - 1 ] ) == 1 or int ( N [ - 1 ] ) == 6 or int ( N [ - 1 ] ) == 8 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b = ( x for x in input ( ) . split ( ) ) <NEWLINE> t = len ( a ) <NEWLINE> aa = [ ] <NEWLINE> bb = [ ] <NEWLINE> for i in range ( t ) : <NEWLINE> <INDENT> aa . append ( a [ i ] ) <NEWLINE> bb . append ( b [ i ] ) <NEWLINE> <NL> <NL> <DEDENT> if ( aa == bb ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT>
s , t = input ( ) . split ( <STRING> ) <NEWLINE> if t . __contains__ ( s ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s = input ( ) . split ( ) <NEWLINE> a = input ( ) . split ( ) <NEWLINE> if s + a [ - 1 ] == a : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import sys <NEWLINE> n = sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> s = sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> if n = s [ : len ( n ) ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> print ( <STRING> ) <NEWLINE>
s = input ( ) <NEWLINE> t = input ( ) <NEWLINE> <NL> if s == t [ : len ( s ) ] : <NEWLINE> <INDENT> if t [ - 1 ] in <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <INDENT> exit ( 0 ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
S , T = input ( ) . split ( ) <NEWLINE> flag = 0 <NEWLINE> <NL> S_length = len ( S ) <NEWLINE> for num in range ( S_length ) : <NEWLINE> <INDENT> if S [ num ] != T [ num ] : <NEWLINE> <INDENT> flag = - 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if flag == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
a = input ( <STRING> ) <NEWLINE> b = input ( <STRING> ) <NEWLINE> if b [ : - 1 ] == a : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> t = input ( ) <NEWLINE> <NL> if s + t [ - 1 ] == t : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> ~ <NEWLINE>
s , t = input ( ) . split ( ) <NEWLINE> <NL> if t . startswith ( s ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
S = input ( ) <NEWLINE> T = input ( ) <NEWLINE> if S = T [ : - 1 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
x = input ( ) <NEWLINE> y = input ( ) <NEWLINE> <NL> if len ( x ) > 10 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif len ( y ) - len ( x ) != : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif x . islower ( ) == False : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
S = input ( ) <NEWLINE> T = input ( ) <NEWLINE> pareil = True <NEWLINE> for i in range ( 0 , len ( S ) ) : <NEWLINE> <INDENT> if S [ i ] != T [ i ] : <NEWLINE> <INDENT> pareil = False <NEWLINE> <DEDENT> <DEDENT> if pareil : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> t = input ( ) <NEWLINE> slist = list ( s ) <NEWLINE> tlist = list ( t ) <NEWLINE> pass = <STRING> <NEWLINE> for i in range ( len ( slist ) ) : <NEWLINE> <INDENT> if slist [ i ] != tlist [ i ] : <NEWLINE> <INDENT> pass = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> <DEDENT> print ( pass ) <NEWLINE>
int main ( ) { <NEWLINE> <INDENT> string s , t ; <NEWLINE> cin >> s >> t ; <NEWLINE> for ( char c = <STRING> ; c <= <STRING> ; c + + ) <NEWLINE> <INDENT> if ( s + c == t ) puts ( <STRING> ) , exit ( 0 ) ; <NEWLINE> <DEDENT> puts ( <STRING> ) ; <NEWLINE> return 0 ; <NEWLINE> <DEDENT> } <NEWLINE>
S = input ( ) <NEWLINE> T = input ( ) <NEWLINE> <NL> print ( if S == T [ : - 1 ] <STRING> else <STRING> ) <NEWLINE>
s = str ( input ( ) ) <NEWLINE> t = str ( input ( ) ) <NEWLINE> t . depend ( - 1 ) <NEWLINE> if ( s == t ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s = str ( input ( ) ) <NEWLINE> T = str ( input ( ) ) <NEWLINE> t_before = <STRING> <NEWLINE> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> t_before += t [ i ] <NEWLINE> <NL> <DEDENT> if s == t_before : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> n , m , x = map ( int , input ( ) . split ( ) ) <NEWLINE> c = [ None for i in range ( n ) ] <NEWLINE> a = [ None for i in range ( n ) ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> l = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> c [ i ] = l [ 0 ] <NEWLINE> a [ i ] = np . array ( l [ 1 : ] ) <NEWLINE> <DEDENT> mincos = 1000000000000 <NEWLINE> for mask in range ( 2 ** n ) : <NEWLINE> <INDENT> rikai = np . zeros ( m , dtype = <STRING> ) <NEWLINE> cos = 0 <NEWLINE> mm = mask <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if mm % 2 : <NEWLINE> <INDENT> rikai += a [ i ] <NEWLINE> cos += c [ i ] <NEWLINE> <DEDENT> mm //= 2 <NEWLINE> <DEDENT> if np . all ( rikai >= x ) : <NEWLINE> <INDENT> mincos = min ( cos , mincos ) <NEWLINE> <NL> <DEDENT> <DEDENT> if mincos == 1000000000000 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( mincos ) <NEWLINE> <DEDENT>
s , t = input ( ) . split ( <STRING> ) <NEWLINE> if ( t [ 0 : len ( t ) - 1 ] == s ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT>
<COMMENT> <NL> S = input ( ) <NEWLINE> T = input ( ) <NEWLINE> Slist = list ( S ) <NEWLINE> Tlist = list ( T ) <NEWLINE> count = 0 <NEWLINE> for k in range len ( Slist ) : <NEWLINE> <INDENT> if Slist [ k ] == Tlist [ k ] : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> if count == len ( Slist ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import math <NEWLINE> import os <NEWLINE> import random <NEWLINE> import re <NEWLINE> import sys <NEWLINE> <NL> def solution ( s , t ) : <NEWLINE> <INDENT> if ( s [ - 1 ] == t [ - 1 ] ) : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> return <STRING> <NEWLINE> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> fptr = sys . stdout <NEWLINE> <NL> <INDENT> s = input ( ) <NEWLINE> t = input ( ) <NEWLINE> <NL> result = solution ( s , t ) <NEWLINE> <NL> fptr . write ( str ( result ) + <STRING> ) <NEWLINE> <NL> <DEDENT> fptr . close ( ) <NEWLINE> <DEDENT>
if T [ : - 1 ] == S : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> t = input ( ) <NEWLINE> <NL> if s = t [ : - 1 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s = str ( input ( ) ) <NEWLINE> t = str ( input ( ) ) <NEWLINE> for i in range s : <NEWLINE> <INDENT> if s [ i ] != t [ i ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> <DEDENT> if len ( t2 ) == 1 and re . sub ( <STRING> , <STRING> , t2 ) == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
chokudai <NEWLINE> chokudaiz <NEWLINE>
S = input ( ) <NEWLINE> T = input ( ) <NEWLINE> <NL> if len ( T ) - len ( S ) == 1 : <NEWLINE> <INDENT> print ( Yes ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( No ) <NEWLINE> <DEDENT>
s , t = input ( ) . strip ( ) . split ( ) <NEWLINE> if s == t [ : - 1 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> c = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> x = 1 <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> x = c [ x - 1 ] <NEWLINE> <DEDENT> print ( x ) <NEWLINE>
s , t = input ( ) . split ( ) <NEWLINE> if t [ : len ( t ) - 1 ] == s : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b , c , k = ( int ( x ) for x in input ( ) . split ( ) ) <NEWLINE> <NL> if ( k <= a ) : <NEWLINE> <INDENT> print ( a * len ( k ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> sum = a * len ( k ) <NEWLINE> t = k - a <NEWLINE> if ( t <= b ) : <NEWLINE> <INDENT> print ( sum + b * len ( t ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> sum += b * len ( t ) <NEWLINE> t2 = t - c <NEWLINE> print ( sum + c * len ( t2 ) ) <NEWLINE> <DEDENT> <DEDENT>
A , B , C , K = map ( int , input ( ) . split ( ) ) <NEWLINE> m = 0 <NEWLINE> if A - K >= 0 : <NEWLINE> <INDENT> print ( A ) : <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> K = K - A <NEWLINE> if B >= K : <NEWLINE> <INDENT> print ( A ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> K = K - B <NEWLINE> print ( A - K ) <NEWLINE> <NL> <DEDENT> <DEDENT>
A , B , C , K = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> while True : <NEWLINE> <INDENT> nokori = K <NEWLINE> maisu1 = 0 <NEWLINE> maisu2 = 0 <NEWLINE> maisu3 = 0 <NEWLINE> if A <= nokori : <NEWLINE> <INDENT> maisu1 = A <NEWLINE> nokori = nokori - maisu1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> maisu1 = nokori <NEWLINE> break <NEWLINE> <NL> <DEDENT> if B <= nokori : <NEWLINE> <INDENT> maisu2 = B <NEWLINE> nokori = nokori - maisu2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> maisu2 = nokori <NEWLINE> break <NEWLINE> <NL> <DEDENT> maisu3 = nokori <NEWLINE> <NL> <DEDENT> print ( maisu1 - maisu3 ) <NEWLINE>
line = input ( ) . split ( <STRING> ) <NEWLINE> a , b , c , k = line [ 0 ] , line [ 1 ] , line [ 2 ] , line [ 3 ] <NEWLINE> <NL> if a >= k : <NEWLINE> <INDENT> print ( k ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> tmp = k - a <NEWLINE> if b >= tmp : <NEWLINE> <INDENT> print ( a ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> print ( a - ( k - a - b ) ) <NEWLINE>
A , B , C , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> s = - 1 * K * C <NEWLINE> <NL> lc = [ ] <NEWLINE> lc_ = [ ] <NEWLINE> for i in range ( min ( K , A + 1 ) : <NEWLINE> <INDENT> for j in range ( min ( K - i + 1 , B + 1 ) ) : <NEWLINE> <INDENT> lc . append ( [ i , j , K - i - j ] ) <NEWLINE> <NL> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> for i in range ( len ( lc ) ) : <NEWLINE> <INDENT> if lc [ i ] [ 0 ] <= A and lc [ i ] [ 1 ] <= B and lc [ i ] [ 2 ] <= C : <NEWLINE> <COMMENT> <NL> <INDENT> s = max ( s , lc [ i ] [ 0 ] - lc [ i ] [ 2 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( s ) <NEWLINE>
a , b , c , k = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if k <= a : <NEWLINE> <INDENT> print ( k ) <NEWLINE> <DEDENT> elif a < k <= a + b : <NEWLINE> <INDENT> print ( a ) : <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( a - ( k - ( a + b ) ) ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> t = input ( ) <NEWLINE> a = len ( s ) <NEWLINE> <NL> if len ( s ) > 10 or len ( s ) < 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if t [ 0 : a ] != s : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if len ( t ) == len ( s ) + 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
a , b , c , k = map ( int , input ( ) . split ( ) ) <NEWLINE> if a >= k : <NEWLINE> <INDENT> print ( k ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( a - ( ( k - a ) - b ) <NEWLINE> <DEDENT>
if k <= a : <NEWLINE> <INDENT> print ( k ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = k - a <NEWLINE> if x <= b : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( a - ( x - b ) ) <NEWLINE> <DEDENT> <DEDENT>
A , B , C , K = map ( input ( ) . split ( ) ) <NEWLINE> if A >= K : <NEWLINE> <INDENT> print ( K ) <NEWLINE> <DEDENT> elif A + B >= K : <NEWLINE> <INDENT> print ( A ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( A + A + B - K ) <NEWLINE> <DEDENT>
, B , C , K = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( max ( K , A ) + min ( 0 , K - A - B ) ) <NEWLINE>
A , B , C , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if K - A - B > 0 : <NEWLINE> <INDENT> print ( 1 * A - ( K - A - B ) * 1 ) <NEWLINE> <NL> <DEDENT> elif K - A < 0 : <NEWLINE> <INDENT> print ( 1 * K ) <NEWLINE> <NL> <DEDENT> else K - A - B <= 0 : <NEWLINE> <INDENT> print ( 1 * A ) <NEWLINE> <NL> <DEDENT>
A , B , C , K = map ( int , input ( ) . split ( ) ) <NEWLINE> if K <= A : <NEWLINE> <INDENT> print ( K ) <NEWLINE> <DEDENT> else if A + B >= K : <NEWLINE> <INDENT> print ( A ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( A - ( K - A - B ) ) <NEWLINE> <DEDENT>
A , B , C , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if A >= K : <NEWLINE> <INDENT> print ( A ) <NEWLINE> <DEDENT> elif A + B >= K : <NEWLINE> <INDENT> print ( A ) <NEWLINE> <DEDENT> else A + B + C >= K : <NEWLINE> <INDENT> nc = K - A - B <NEWLINE> print ( A - nc ) <NEWLINE> <NL> <DEDENT>
A , B , C , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if K <= A : <NEWLINE> <INDENT> ans = K <NEWLINE> <DEDENT> elif k <= A + B : <NEWLINE> <INDENT> ans = A <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = 2 * A - K <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
A , B , C , K = map ( int , input ( ) . strip ( ) . split ( ) ) <NEWLINE> K = K - A <NEWLINE> if K > 0 : <NEWLINE> <INDENT> Sum = A <NEWLINE> K = K - B <NEWLINE> if K > 0 : <NEWLINE> <INDENT> if K > C : <NEWLINE> <INDENT> print ( Sum - C ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( Sum - K ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( Sum ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( K ) <NEWLINE> <DEDENT>
a , b , c , d = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if a + b >= d : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( a - ( d - a - b ) <NEWLINE> <DEDENT>
A , B , C , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if K <= A : <NEWLINE> <INDENT> print ( str ( K ) ) <NEWLINE> <DEDENT> elif k <= A + B : <NEWLINE> <INDENT> print ( str ( A ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( str ( A - ( C - ( k - ( A + B ) ) ) ) <NEWLINE> <DEDENT>
a , b , c , k = map ( int , input ( ) . split ( ) ) <NEWLINE> if k < a : <NEWLINE> <INDENT> print ( k ) <NEWLINE> <DEDENT> elif k > a and k = < a + b <NEWLINE> <INDENT> print ( a ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 2 * a + b - k ) <NEWLINE> <DEDENT>
<NL> a , b , c , k = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if k < a : <NEWLINE> <INDENT> print ( k ) <NEWLINE> <DEDENT> elif k < a + b : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <DEDENT> nelse : <NEWLINE> <INDENT> print ( 2 * a + b - k ) <NEWLINE> <DEDENT>
A = int ( input ( ) ) <NEWLINE> B = int ( input ( ) ) <NEWLINE> C = int ( input ( ) ) <NEWLINE> K = int ( input ( ) ) <NEWLINE> <NL> if K <= A : <NEWLINE> <INDENT> print ( K ) <NEWLINE> <DEDENT> elif K <= A + B : <NEWLINE> <INDENT> print ( A ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> N = K - A - B <NEWLINE> print ( A - N ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> A , B , C , K = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> if K <= A : <NEWLINE> <INDENT> print ( K ) <NEWLINE> <DEDENT> elif k <= A + B : <NEWLINE> <INDENT> print ( A ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ( K - ( A + B ) ) * ( - 1 ) + A ) <NEWLINE> <DEDENT>
a , b , c , k = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if k <= a : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <DEDENT> elif a < k and k <= a + b : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 2 a + b - k ) <NEWLINE> <DEDENT>
A , B , C , K = int ( input ( ) ) , int ( input ( ) ) , int ( input ( ) ) , int ( input ( ) ) <NEWLINE> <NL> if A >= K : <NEWLINE> <INDENT> print ( K ) <NEWLINE> <DEDENT> elif A + B >= K : <NEWLINE> <INDENT> print ( A ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( A - ( K - A - B ) ) <NEWLINE> <DEDENT>
a , b , c , k = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if a + b = k : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 2 * a - k + b ) <NEWLINE> <NL> <DEDENT>
a , b , c , k = map ( int , input ( ) . split ( ) ) <NEWLINE> if k < a : <NEWLINE> <INDENT> print ( k ) <NEWLINE> <DEDENT> elif k <= a + b : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 2 a + b - k ) <NEWLINE> <DEDENT>
a , b , c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> if a >= k : <NEWLINE> <INDENT> print ( 1 * k ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if b >= ( k - a ) : <NEWLINE> <INDENT> print ( 1 * a + k * 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if c >= ( k - a - b ) : <NEWLINE> <INDENT> print ( 1 * a + 0 * b + ( - 1 ) * k ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
A = int ( input ( ) ) <NEWLINE> B = int ( input ( ) ) <NEWLINE> C = int ( input ( ) ) <NEWLINE> K = int ( input ( ) ) <NEWLINE> if A + B + C >= 2 * 10 ** 9 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif A >= K : <NEWLINE> <INDENT> print ( K ) <NEWLINE> <DEDENT> elif K > A and K < A + B : <NEWLINE> <INDENT> print ( A ) <NEWLINE> <DEDENT> elif K > A + B and K <= A + B + C : <NEWLINE> <INDENT> print ( - 1 * ( K - A - B ) + A ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b , c , k = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> if k > a : <NEWLINE> <INDENT> ans = ans + a <NEWLINE> <INDENT> k = k - a <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> ans = ans + k <NEWLINE> <INDENT> k = 0 <NEWLINE> <DEDENT> <DEDENT> if k > b : <NEWLINE> <INDENT> k = k - b <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> k = 0 <NEWLINE> <DEDENT> if k > c : <NEWLINE> <INDENT> ans = ans - c <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = ans - k <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> print ( ans ) <NEWLINE>
a = input ( ) <NEWLINE> b = input ( ) <NEWLINE> c = input ( ) <NEWLINE> k = input ( ) <NEWLINE> <NL> if ( k < a ) : <NEWLINE> <INDENT> print ( k ) <NEWLINE> <DEDENT> elif ( k > a and k < a + b ) : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <DEDENT> elif ( k > a + b and k < a + b + c ) : <NEWLINE> <INDENT> print ( a - ( k - ( a + b ) ) ) <NEWLINE> <DEDENT>
S = input ( ) <NEWLINE> T = input ( ) <NEWLINE> <NL> if ( S == T [ 0 : len ( S ) ] ) : <NEWLINE> <INDENT> print ( Yes ) <NEWLINE> else : <NEWLINE> <INDENT> print ( No ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT>
a , b , c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = 0 <NEWLINE> if not a < k : <NEWLINE> <INDENT> print ( k ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if not a + b < k : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 2 * a + b - k ) <NEWLINE> <DEDENT> <DEDENT>
a , b , c , k = map ( int , input ( ) . split ( ) ) <NEWLINE> s = 0 <NEWLINE> for in range ( k ) : <NEWLINE> <INDENT> if a > 0 : <NEWLINE> <INDENT> s += 1 <NEWLINE> a -= 1 <NEWLINE> <DEDENT> elif b > 0 : <NEWLINE> <INDENT> b += 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s += - 1 <NEWLINE> <DEDENT> <DEDENT> print ( s ) <NEWLINE>
A , B , C , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> nokori = K - A - B <NEWLINE> <NL> wa = 0 <NEWLINE> wa += A <NEWLINE> <NL> if nokori == 0 : <NEWLINE> <INDENT> a <NEWLINE> <DEDENT> elif C >= nokori : <NEWLINE> <INDENT> wa -= nokori <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> wa -= C <NEWLINE> <NL> <DEDENT> print ( wa ) <NEWLINE>
A , B , C , K = map ( int , input ( ) . split ( ) ) <NEWLINE> if ( A >= K ) : <NEWLINE> <INDENT> print ( K ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> K = K - A <NEWLINE> if ( B >= D ) : <NEWLINE> <INDENT> print ( A ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> K = K - B <NEWLINE> print ( A - K ) <NEWLINE> <DEDENT> <DEDENT>
a , b , c , k = int ( input ( ) ) <NEWLINE> <NL> if k <= a : <NEWLINE> <INDENT> print ( k ) <NEWLINE> <DEDENT> elif k <= a + b : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( a - ( k - ( a + b ) ) ) <NEWLINE> <DEDENT>
A , B , C , K = int ( input ( ) . split ( <STRING> ) ) <NEWLINE> out = 0 <NEWLINE> if A > K : <NEWLINE> <INDENT> print ( K ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> out += A <NEWLINE> K -= A <NEWLINE> if B > K : <NEWLINE> <INDENT> print ( out ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> K -= B <NEWLINE> out -= K <NEWLINE> print ( out ) <NEWLINE> <DEDENT> <DEDENT>
A , B , C , K = inpl ( ) <NEWLINE> if A >= K : <NEWLINE> <INDENT> print ( K ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> if A + B >= K : <NEWLINE> <INDENT> print ( A ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> print ( A - ( K - A - B ) ) <NEWLINE>
2000000000 0 0 200000000 <NEWLINE>
a , b , c , k = list ( map ( input ( ) , split ( ) ) ) <NEWLINE> if a + b >= k : <NEWLINE> <INDENT> print ( min ( a , k ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( a - ( k - a - b ) ) <NEWLINE> <DEDENT>
a , b , c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> if a + b >= d : <NEWLINE> <INDENT> print ( d ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 2 a + b - d ) <NEWLINE> <DEDENT>
a , b , c , k = map ( int , input ( ) . split ( ) ) <NEWLINE> ans <NEWLINE> if ( a >= k ) : <NEWLINE> <INDENT> ans = k <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if ( ( a + b ) >= k ) : <NEWLINE> <INDENT> ans = a <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = k - a - b <NEWLINE> ans = a - x <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
a , b , c , k = map ( int , input ( ) . split ( ) ) <NEWLINE> s = min ( c , k ) <NEWLINE> k -= s <NEWLINE> if k == 0 : <NEWLINE> <INDENT> print ( s ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d = min ( k , b ) <NEWLINE> k -= d : <NEWLINE> if k == 0 : <NEWLINE> <INDENT> print ( s ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> f = min ( k , a ) <NEWLINE> s -= f <NEWLINE> print ( s ) <NEWLINE> <DEDENT> <DEDENT>
a , b , c , k = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> if ( k <= a ) : <NEWLINE> <INDENT> print ( k ) <NEWLINE> <DEDENT> elif ( k <= a + b ) : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = k - ( a + b ) <NEWLINE> <INDENT> print ( a - ans ) <NEWLINE> <DEDENT> <DEDENT>
a , b , c , k = input ( ) . split ( ) <NEWLINE> <NL> if a >= k : <NEWLINE> <INDENT> sum = k <NEWLINE> <DEDENT> elif a + b >= k : <NEWLINE> <INDENT> sum = k <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> sum = a - c <NEWLINE> <NL> <DEDENT> print ( sum ) <NEWLINE>
A , B , C , K = map ( int , input ( ) . split ( ) ) <NEWLINE> if A >= K : <NEWLINE> <INDENT> print ( A ) <NEWLINE> <DEDENT> elif ( A + B ) >= K : <NEWLINE> <INDENT> print ( A ) <NEWLINE> <DEDENT> elif ( A + B + C ) > K : <NEWLINE> <INDENT> print ( A - ( K - A - B ) <NEWLINE> <DEDENT> elif ( A + B + C ) == K : <NEWLINE> <INDENT> print ( A - C ) <NEWLINE> <DEDENT>
A , B , C , K = int ( input ( ) . split ( ) ) <NEWLINE> if A >= K : <NEWLINE> <INDENT> print ( K ) <NEWLINE> <DEDENT> elif ( A + B ) >= K : <NEWLINE> <INDENT> print ( A ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( A - ( K - A ) ) <NEWLINE> <DEDENT>
a , b , c , k = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if a . isdigit ( ) == True and b . isdigit ( ) == True and c . isdigit ( ) == True and k . isdigit ( ) == True : <NEWLINE> <INDENT> a = int ( a ) <NEWLINE> b = int ( b ) <NEWLINE> c = int ( c ) <NEWLINE> k = int ( k ) <NEWLINE> if k >= 1 and k <= ( a + b + c ) and ( a + b + c ) <= 2 * ( 10 ** 9 ) : <NEWLINE> <INDENT> if k <= a : <NEWLINE> <INDENT> print ( k ) <NEWLINE> <DEDENT> elif k > a and k <= ( a + b ) : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( a - ( k - b - a ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
a = int ( input ( ) ) <NEWLINE> b = int ( input ( ) ) <NEWLINE> c = int ( input ( ) ) <NEWLINE> k = int ( input ( ) ) <NEWLINE> <NL> count = 0 <NEWLINE> <NL> if k <= a + b : <NEWLINE> <INDENT> count += a <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> count += a - ( k - ( a + b ) ) <NEWLINE> <DEDENT> print ( count ) <NEWLINE>
a , b , c , k - map ( inat , input ( ) . split ( ) ) <NEWLINE> ans = 0 <NEWLINE> ans += min ( k , a ) <NEWLINE> k -= min ( k , a ) <NEWLINE> k -= min ( k , b ) <NEWLINE> ans -= min ( k , c ) <NEWLINE> print ( ans ) <NEWLINE>
A = int ( input ( ) ) <NEWLINE> B = int ( input ( ) ) <NEWLINE> C = int ( input ( ) ) <NEWLINE> K = int ( input ( ) ) <NEWLINE> <NL> if K > A : <NEWLINE> <INDENT> N = K - A <NEWLINE> all_number = 1 * A <NEWLINE> print ( all_number ) <NEWLINE> <NL> if N > B : <NEWLINE> <INDENT> N = N - B <NEWLINE> if N > C : <NEWLINE> <INDENT> all_number = all_number - 1 * C <NEWLINE> print ( all_number ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> all_number = all_number - 1 * N <NEWLINE> print ( all_number ) <NEWLINE> <NL> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( all_number ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> all_number = 1 * K <NEWLINE> print ( all_number ) <NEWLINE> <DEDENT>
A , B , C , K = map ( int , input ( ) . spliit ( ) ) <NEWLINE> if K <= A : <NEWLINE> <INDENT> print ( K ) <NEWLINE> <NL> <DEDENT> elif K <= A + B : <NEWLINE> <INDENT> print ( A ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> print ( A - ( K - ( A + B ) ) ) <NEWLINE> <DEDENT>
if K < A : <NEWLINE> <INDENT> print ( A ) <NEWLINE> <DEDENT> elif A <= K and B >= ( K - A ) : <NEWLINE> <INDENT> print ( A ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( A - ( K - A - B ) ) <NEWLINE> <DEDENT>
A , B , C , K = int ( input ( ) . split ( ) ) <NEWLINE> if K <= A : <NEWLINE> <INDENT> print ( K ) <NEWLINE> <DEDENT> elif A < K <= A + B : <NEWLINE> <INDENT> print ( A ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( A - ( K - A - B ) ) <NEWLINE> <DEDENT>
A , B , C , K = map ( int , input ( ) . split ( ) ) <NEWLINE> answer = 0 <NEWLINE> if K <= A : <NEWLINE> <INDENT> print ( K ) <NEWLINE> <DEDENT> elif K > A : <NEWLINE> <INDENT> answer = A <NEWLINE> K = K - A <NEWLINE> <DEDENT> if K <= B , K > 0 : <NEWLINE> <INDENT> print ( answer ) <NEWLINE> <DEDENT> elif K > B : <NEWLINE> <INDENT> K = K - B <NEWLINE> <DEDENT> if K <= C , K > 0 : <NEWLINE> <INDENT> answer = answer - K <NEWLINE> print ( answer ) <NEWLINE> <DEDENT>
if __name__ == <STRING> : <NEWLINE> <INDENT> a = int ( input ( ) ) <NEWLINE> b = int ( input ( ) ) <NEWLINE> c = int ( input ( ) ) <NEWLINE> k = int ( input ( ) ) <NEWLINE> <NL> if ( k <= a + b ) : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( a - k + a + b ) <NEWLINE> <DEDENT> <DEDENT>
a , b , c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> h = k - a <NEWLINE> h2 = h - b <NEWLINE> if a > k : <NEWLINE> <INDENT> print ( k ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if h <= b : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( a + h2 * ( - 1 ) ) <NEWLINE> <DEDENT> <DEDENT>
A , B , C , K = map ( int , input ( ) . split ( ) ) <NEWLINE> if A >= K : <NEWLINE> <INDENT> print ( K ) <NEWLINE> <DEDENT> elif : A + B >= K : <NEWLINE> <INDENT> print ( A ) <NEWLINE> <DEDENT> else <NEWLINE> <INDENT> print ( A - ( K - A - B ) ) <NEWLINE> <DEDENT>
A , B , C , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if K <= A : <NEWLINE> <INDENT> print ( A ) <NEWLINE> <DEDENT> elif K <= A + B : <NEWLINE> <INDENT> print ( A ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 2 A + B - K ) <NEWLINE> <DEDENT>
a , b , c , k = map ( int , input ( ) . split ( ) ) <NEWLINE> if k <= a + b : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <DEDENT> elif k <= a + b + c : <NEWLINE> <INDENT> print ( 2 a - k + b ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( a - c ) <NEWLINE> <DEDENT>
A , B , C , K = map ( input ( ) . split ( ) ) <NEWLINE> if A <= K : <NEWLINE> <INDENT> print ( K ) <NEWLINE> <NL> <DEDENT> elif A + B <= K : <NEWLINE> <INDENT> print ( A ) <NEWLINE> <NL> <DEDENT> elif A + B + C <= K : <NEWLINE> <INDENT> print ( A - C ) <NEWLINE> <DEDENT>
, B , C , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( K ) : <NEWLINE> <INDENT> if A > 0 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> A -= 1 <NEWLINE> <DEDENT> elif B > 0 : <NEWLINE> <INDENT> B -= 1 <NEWLINE> <DEDENT> elif C > 0 : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> C -= 1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
abck = input ( ) . split ( <STRING> ) <NEWLINE> a = abck [ 0 ] <NEWLINE> b = abck [ 1 ] <NEWLINE> c = abck [ 2 ] <NEWLINE> k = abck [ 3 ] <NEWLINE> <NL> if k < a : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <DEDENT> elif k < a + b : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( a - ( k - ( a + b ) ) ) <NEWLINE> <NL> <DEDENT>
a , b , c , k = [ int ( i ) i in input ( ) . split ( <STRING> ) ] <NEWLINE> print ( min ( a , k ) - max ( 0 , k - a - b ) ) <NEWLINE>
A , B , C , K = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = 0 <NEWLINE> if ( K <= A ) : <NEWLINE> <INDENT> ans = K <NEWLINE> <DEDENT> else if ( K <= A + B ) : <NEWLINE> <INDENT> ans = A <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = A - ( K - A - B ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
a , b , c , k = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> if k <= a and k - a <= b : <NEWLINE> <INDENT> print ( k ) <NEWLINE> <DEDENT> else <NEWLINE> <INDENT> print ( a - ( k - a - b ) ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> input = sys . stdin . readline <NEWLINE> A , B , C , K = [ int ( x ) for x in input ( ) . strip ( ) . split ( ) ] <NEWLINE> if K <= A + B : <NEWLINE> <INDENT> print ( min ( K , A ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( A - ( K - A - B ) ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
a , b , c , k = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if k <= a : <NEWLINE> <INDENT> print ( k ) <NEWLINE> <DEDENT> elif k <= a + b : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( a - ( k - ( a + b ) ) <NEWLINE> <DEDENT>
S = input ( ) . split ( ) <NEWLINE> A = S [ 0 ] <NEWLINE> B = S [ 1 ] <NEWLINE> C = S [ 2 ] <NEWLINE> K = S [ 3 ] <NEWLINE> <NL> if K <= A : <NEWLINE> <INDENT> print ( K ) <NEWLINE> <DEDENT> elif K - A <= B : <NEWLINE> <INDENT> print ( K ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( K - C ) <NEWLINE> <DEDENT>
if __name__ == <STRING> : <NEWLINE> <INDENT> A = input ( ) <NEWLINE> B = input ( ) <NEWLINE> C = input ( ) <NEWLINE> K = input ( ) <NEWLINE> <NL> a = int ( A ) <NEWLINE> b = int ( B ) <NEWLINE> c = int ( C ) <NEWLINE> k = int ( K ) <NEWLINE> <NL> if a > k : <NEWLINE> <INDENT> print ( k ) <NEWLINE> <DEDENT> elif ( a + b ) > k : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = 2 * a - k + b <NEWLINE> print ( ans ) <NEWLINE> <DEDENT> <DEDENT>
if k <= a : <NEWLINE> <INDENT> print ( k ) <NEWLINE> <DEDENT> elif k <= a + b : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> print ( a - ( k - a - b ) ) <NEWLINE> <DEDENT>
A = int ( input ( ) ) <NEWLINE> B = int ( input ( ) ) <NEWLINE> C = int ( input ( ) ) <NEWLINE> K = int ( input ( ) ) <NEWLINE> remain_A = K - A <NEWLINE> if remain_A <= 0 : <NEWLINE> <INDENT> print ( K ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> remain_B = remain_A - B <NEWLINE> if remain_B <= 0 : <NEWLINE> <INDENT> print ( A ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = ( A * 1 ) + ( B * 0 ) + ( remain_B * ( - 1 ) ) <NEWLINE> print ( ans ) <NEWLINE> <DEDENT> <DEDENT>
2 1 1 3 <NEWLINE>
a , b , b , k = map ( int , input ( ) . split ( ) ) <NEWLINE> p = min ( a , k ) <NEWLINE> s = p <NEWLINE> k -= p <NEWLINE> <NL> q = min ( b , k ) <NEWLINE> k -= q <NEWLINE> s -= k <NEWLINE> <NL> r = min ( c , k ) <NEWLINE> k -= r <NEWLINE> s -= k <NEWLINE> print ( s ) <NEWLINE>
<NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> if K < A : <NEWLINE> <INDENT> ans = K <NEWLINE> <DEDENT> elif K - A <= B and K >= A : <NEWLINE> <INDENT> ans = A <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = A - ( K - A - B ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
A , B , C , K = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <INDENT> if ( K < A ) : <NEWLINE> <INDENT> score = K <NEWLINE> elif ( K >= A and K <= A + B ) : <NEWLINE> <INDENT> score = A <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> score = A - ( K - A - B ) <NEWLINE> <NL> <DEDENT> print ( score ) <NEWLINE> <DEDENT> <DEDENT>
A , B , C , K = map ( int , input . split ( <STRING> ) ) <NEWLINE> if K <= A : <NEWLINE> <INDENT> print ( K ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> K = K - A <NEWLINE> if K <= B : <NEWLINE> <INDENT> print ( A ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> K = K - B <NEWLINE> print ( A - K ) <NEWLINE> <DEDENT> <DEDENT>
a , b , c , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a , b , c , k = map ( int , input ( ) . split ( ) ) <NEWLINE> j = k - ( a + b ) <NEWLINE> j = 0 if j < 0 else j <NEWLINE> print ( a - j if k > a else k ) <NEWLINE>
<COMMENT> <NL> A = input ( ) <NEWLINE> B = input ( ) <NEWLINE> C = input ( ) <NEWLINE> K = input ( ) <NEWLINE> <NL> <COMMENT> <NL> A = int ( A ) <NEWLINE> B = int ( B ) <NEWLINE> C = int ( C ) <NEWLINE> K = int ( K ) <NEWLINE> <NL> <COMMENT> <NL> max_sum = 0 <NEWLINE> <NL> <COMMENT> <NL> max_sum = min ( A , K ) <NEWLINE> K = K - max_sum <NEWLINE> <NL> <COMMENT> <NL> if K > 0 : <NEWLINE> <INDENT> K = K - min ( B , K ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> if K > 0 : <NEWLINE> <INDENT> max_sum = max_sum - min ( K , B ) <NEWLINE> <COMMENT> <NL> <DEDENT> print ( max_sum ) <NEWLINE>
A , B , C , K = input ( ) . split ( ) <NEWLINE> if A >= K : <NEWLINE> <INDENT> print ( K ) <NEWLINE> <DEDENT> elif A + B >= K : <NEWLINE> <INDENT> print ( A ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( A + A + B - K ) <NEWLINE> <DEDENT>
a , b , c , k = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if a >= k : <NEWLINE> <INDENT> Result = k <NEWLINE> <DEDENT> elif a + b >= k > a : <NEWLINE> <INDENT> Result = a <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> Result = 2 a - k + b <NEWLINE> <NL> <DEDENT> print ( Result ) <NEWLINE>
A , B , C , K = input ( ) . split ( <STRING> ) <NEWLINE> if ( A >= K ) : <NEWLINE> <INDENT> print ( A ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if ( K <= A + B ) : <NEWLINE> <INDENT> print ( A ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( A - ( K - A - B ) ) <NEWLINE> <DEDENT> <DEDENT>
S = input ( ) <NEWLINE> T = input ( ) <NEWLINE> <NL> <NL> if len ( S ) + 1 == len ( T ) : <NEWLINE> <INDENT> for i in range ( len ( S ) ) : <COMMENT> <NEWLINE> <INDENT> if S [ i ] == T [ i ] : <NEWLINE> <INDENT> a = <STRING> <NEWLINE> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a = <STRING> <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> if a == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
i = input ( ) . split ( ) <NEWLINE> <NL> a = i [ 0 ] <NEWLINE> b = i [ 1 ] <NEWLINE> c = i [ 2 ] <NEWLINE> d = i [ 3 ] <NEWLINE> <NL> if int ( d ) <= int ( a ) : <NEWLINE> <INDENT> print ( int ( d ) ) <NEWLINE> elif int ( d ) - int ( a ) <= int ( b ) : <NEWLINE> <INDENT> print ( int ( a ) ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( int ( a ) - ( int ( d ) - int ( a ) - int ( b ) ) ) <NEWLINE> <DEDENT>
A , B , C , K = list ( map ( int , input ( ) ) ) <NEWLINE> <NL> if ( A <= K ) : <NEWLINE> <INDENT> print ( K ) <NEWLINE> <DEDENT> elif ( A + B <= K ) : <NEWLINE> <INDENT> print ( A ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( A + ( - 1 ) * ( K - A - B ) ) <NEWLINE> <DEDENT>
A , B , C , K = map ( int , input ( ) . split ( ) ) <NEWLINE> if K < A : <NEWLINE> <INDENT> print ( K ) <NEWLINE> <DEDENT> elif K = < A + B : <NEWLINE> <INDENT> print ( A ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( A + ( K - A - B ) * - 1 ) <NEWLINE> <DEDENT>
a = input ( ) . split <NEWLINE> <NL> sum = 0 <NEWLINE> <NL> sum += 1 * a [ 0 ] <NEWLINE> a [ 3 ] -= a [ 0 ] <NEWLINE> a [ 3 ] -= a [ 1 ] <NEWLINE> <NL> if a [ 2 ] < a [ 3 ] : <NEWLINE> <INDENT> sum -= 1 * a [ 0 ] <NEWLINE> <NL> <DEDENT> print ( sum ) <NEWLINE>
a , b , c , k = int ( input ( ) ) <NEWLINE> total = a * 1 + b * 0 - c * 1 <NEWLINE> print ( int ( total ) ) <NEWLINE>
i = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if i [ 0 ] <= i [ 3 ] : <NEWLINE> <INDENT> saidai = 1 * i [ 0 ] <NEWLINE> <DEDENT> elif : <NEWLINE> <INDENT> saidai = 1 * i [ 3 ] <NEWLINE> <DEDENT> else : <NEWLINE> if i [ 2 ] >= ( i [ 3 ] - i [ 0 ] - i [ 1 ] ) : <NEWLINE> <INDENT> saidai = saidai - 1 * ( i [ 3 ] - i [ 0 ] - i [ 1 ] ) <NEWLINE> <NL> <DEDENT> print ( saidai ) <NEWLINE>
a , b , c , k = list ( map ( input ( ) . split ( ) ) ) <NEWLINE> if k < a : <NEWLINE> <INDENT> return k <NEWLINE> <DEDENT> elif k < a + b : <NEWLINE> <INDENT> return a <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return a - ( k - a - b ) <NEWLINE> <DEDENT>
<COMMENT> <NL> A = int ( input ( ) ) <NEWLINE> B = int ( input ( ) ) <NEWLINE> C = int ( input ( ) ) <NEWLINE> K = int ( input ( ) ) <NEWLINE> <COMMENT> <NL> if K - A < 0 : <COMMENT> <NEWLINE> <INDENT> NA = K <NEWLINE> NB = 0 <NEWLINE> NC = 0 <NEWLINE> <DEDENT> else : <COMMENT> <NEWLINE> <INDENT> NA = A <NEWLINE> if ( K - A ) - B < 0 : <COMMENT> <NEWLINE> <INDENT> NB = K - A <NEWLINE> NC = 0 <NEWLINE> <DEDENT> else : <COMMENT> <NEWLINE> <INDENT> NB = B <NEWLINE> NC = K - A - B <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> sum = NA * 1 + NB * 0 + NC * ( - 1 ) <NEWLINE> <NL> <COMMENT> <NL> print ( sum ) <NEWLINE>
A , B , C , K = [ int ( x ) for x in input ( ) . strip ( ) . split ( ) ] <NEWLINE> k = K <NEWLINE> res = 0 <NEWLINE> if A > K : <NEWLINE> <INDENT> print ( K ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> k -= A <NEWLINE> res += A <NEWLINE> <INDENT> if b > k : <NEWLINE> <INDENT> print ( res ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> k -= b <NEWLINE> if k > 0 : <NEWLINE> <INDENT> res -= k * - 1 <NEWLINE> print ( res ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT>
A , B , C , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <COMMENT> <NL> A = max ( A , K ) <NEWLINE> B = max ( K - A , B ) <NEWLINE> C = max ( K - A - B , C ) <NEWLINE> assert A + B + C >= K <NEWLINE> print ( A - C ) A , B , C , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <COMMENT> <NL> A = min ( A , K ) <NEWLINE> B = min ( K - A , B ) <NEWLINE> C = min ( K - A - B , C ) <NEWLINE> assert A + B + C >= K <NEWLINE> <COMMENT> <NL> print ( A - C ) <NEWLINE>
a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A = a [ 0 ] <NEWLINE> B = a [ 1 ] <NEWLINE> C = a [ 2 ] <NEWLINE> K = a [ 3 ] <NEWLINE> if A > k : <NEWLINE> <INDENT> print ( A ) <NEWLINE> <DEDENT> elif ( A + B ) > K : <NEWLINE> <INDENT> print ( A ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( A - ( K - A - B ) ) <NEWLINE> <DEDENT>
A , B , C , K = map ( int , input ( ) . split ( ) ) <NEWLINE> if ( A >= K ) : <NEWLINE> <INDENT> print ( K ) <NEWLINE> <DEDENT> else if ( A + B >= K ) : <NEWLINE> <INDENT> print ( A ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( A - ( K - A - B ) ) <NEWLINE> <DEDENT>
<NL> if k < a : <NEWLINE> <INDENT> print ( k ) <NEWLINE> <DEDENT> elif a <= k and k <= a + b : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <DEDENT> elif a + b < k and k < a + b + c : <NEWLINE> <INDENT> print ( a - ( k - a - b ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( a - c ) <NEWLINE> <DEDENT>
a , b , c , k = int ( input ( ) . split ( ) ) <NEWLINE> <NL> if a >= k : <NEWLINE> <INDENT> print ( k ) <NEWLINE> <DEDENT> elif a + b >= k : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 2 * a - k - b ) <NEWLINE> <DEDENT>
A , B , C , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if A = > K : <NEWLINE> <INDENT> print ( K ) <NEWLINE> <DEDENT> elif A + B = > K : <NEWLINE> <INDENT> print ( A ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( A + ( K - C ) * ( - 1 ) ) <NEWLINE> <NL> <DEDENT>
a , b , c , k = map ( int , input ( ) . split ( ) ) <NEWLINE> if k <= a : <NEWLINE> <INDENT> print ( k ) <NEWLINE> <DEDENT> if a < k <= a + b : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <DEDENT> ifa + b < k : <NEWLINE> <INDENT> d = 2 * a + b - k <NEWLINE> print ( d ) <NEWLINE> <DEDENT>
a , b , c , k = map ( int , input ( ) . split ( ) ) <NEWLINE> m = min ( k , a ) <NEWLINE> if m == k : <NEWLINE> <INDENT> n = 0 <NEWLINE> l = 0 <NEWLINE> <DEDENT> n = min ( k - a , b ) <NEWLINE> if n == k = a : <NEWLINE> <INDENT> l = 0 <NEWLINE> <DEDENT> l = min ( k - a - b , c ) <NEWLINE> print ( 1 * m + 0 * n + ( - 1 ) * l ) <NEWLINE>
<NL> def resolve ( ) : <NEWLINE> <INDENT> a , b , c , k = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> used = min ( k , a ) <NEWLINE> ans += used * 1 <NEWLINE> k -= used <NEWLINE> used = min ( k , b ) <NEWLINE> k -= used <NEWLINE> ans += k * ( - 1 ) <NEWLINE> print ( ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> unittest . main ( ) <NEWLINE> <DEDENT>
, B , C , K = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = 0 <NEWLINE> if A >= K : <NEWLINE> <INDENT> ans = K <NEWLINE> <DEDENT> elif A < K and K <= A + B : <NEWLINE> <INDENT> ans = A <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = A - ( K - A - B ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
def resolve ( ) : <NEWLINE> <INDENT> a , b , c , k = map ( int , input ( ) . split ( ) ) <NEWLINE> if a + b >= k : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d = k - a - b <NEWLINE> print ( a - d ) <NEWLINE> <DEDENT> <DEDENT> reslove ( ) <NEWLINE>
A , B , C , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if ( A - K < 0 ) : <NEWLINE> <INDENT> if ( A + B - K < 0 ) : <NEWLINE> <INDENT> print ( 2 * A - K + B ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( A ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( K ) <NEWLINE> <DEDENT>
a , b , c , k = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if k < a : <NEWLINE> <INDENT> print ( str ( k ) ) <NEWLINE> <DEDENT> elif k < ( a + b ) : <NEWLINE> <INDENT> print ( str ( a ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( str ( a - c ) ) : <NEWLINE> <DEDENT>
a , b , c , k = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if k = 1 : <NEWLINE> <INDENT> print ( k ) <NEWLINE> <DEDENT> elif k <= a + b : <NEWLINE> <INDENT> print ( k ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> r = k - a - b <NEWLINE> print ( a - r ) <NEWLINE> <DEDENT>
a , b , c , k = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if k = < a : <NEWLINE> <INDENT> print ( 1 * k ) <NEWLINE> <DEDENT> elif a < k and k <= ( a + b ) : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( a - ( ( k - ( a + b ) ) * - 1 ) ) <NEWLINE> <DEDENT>
import math <NEWLINE> ans = False <NEWLINE> a , b , c , k = map ( int , input ( ) . split ( ) <NEWLINE> ans += min ( k , a ) <NEWLINE> k -= min ( k , a ) <NEWLINE> k -= min ( k , b ) <NEWLINE> ans -= min ( k , c ) <NEWLINE> print ( ans ) <NEWLINE>
<INDENT> = input ( ) <NEWLINE> <NL> <DEDENT> A , B , C , K = map ( int , a . split ( ) ) <NEWLINE> <NL> if A >= K : <NEWLINE> <INDENT> print ( K ) <NEWLINE> <DEDENT> elif A + B >= K > A : <NEWLINE> <INDENT> print ( A ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - B - C + K ) <NEWLINE> <DEDENT>
a , b , c , k = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if k <= a : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <DEDENT> elif a < k and k <= a + b : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <DEDENT> elif a + b < k and k <= a + b + c <NEWLINE> <INDENT> print ( a - k + a + b ) <NEWLINE> <DEDENT>
a , b , c , n = map ( int , input ( ) . split ( ) ) <NEWLINE> if a >= n : <NEWLINE> <INDENT> print ( n ) <NEWLINE> <DEDENT> elif n > a and a + b >= n : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 2 a - n + b ) <NEWLINE> <DEDENT>
a , b , c , k = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( min ( ( a - max ( k - a - b , 0 ) ) , k ) <NEWLINE>
a , b , c , k = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( min ( a , k , a - ( k - a - b ) ) <NEWLINE>
a , b , c , k = map ( int , input ( ) . split ( ) ) <NEWLINE> ai = 0 <NEWLINE> bi = 0 <NEWLINE> ci = 0 <NEWLINE> if a >= k : <NEWLINE> <INDENT> ai = k <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ai = a <NEWLINE> if b >= k - ai : <NEWLINE> <INDENT> bi = k - ai <NEWLINE> else : <NEWLINE> <INDENT> bi = b <NEWLINE> ci = k - ai - bi <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ai - ci ) <NEWLINE> <NL>
if n > k : <NEWLINE> <INDENT> print ( n ) <NEWLINE> <DEDENT> elif n + m > k : <NEWLINE> <INDENT> print ( n ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( n - l ) <NEWLINE> <DEDENT>
import math <NEWLINE> if K <= A : <NEWLINE> <INDENT> print ( K ) <NEWLINE> <DEDENT> if A < K <= A + B : <NEWLINE> <INDENT> print ( A ) <NEWLINE> <DEDENT> if A + B < K <= A + B + C : <NEWLINE> <INDENT> print ( A * 2 + B - K ) <NEWLINE> <DEDENT>
A , B , C , K = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if K <= A : <NEWLINE> <INDENT> max = K <NEWLINE> <DEDENT> elif A < K and K <= A + B <NEWLINE> <INDENT> max = A <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> max = A - ( K - ( A + B ) ) <NEWLINE> <NL> <DEDENT> print ( max ) <NEWLINE>
def main ( a , b , c , k ) : <NEWLINE> <INDENT> res = 0 <NEWLINE> if k < a : <NEWLINE> <INDENT> res = k <NEWLINE> <DEDENT> elif a <= k < a + b : <NEWLINE> <INDENT> res = a <NEWLINE> <DEDENT> elif a + b <= k : <NEWLINE> <INDENT> res = a - ( k - ( a + b ) ) <NEWLINE> <DEDENT> return res <NEWLINE> <NL> <DEDENT> a , b , c , k = mi ( ) <NEWLINE> print ( main ( a , b , c , k ) ) <NEWLINE>
a , b , c , k = map ( int , input ( ) . split ( ) ) <NEWLINE> if a < k : <NEWLINE> <INDENT> print ( k ) <NEWLINE> <DEDENT> else if a + b <= k : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( a - ( k - a - b ) ) <NEWLINE> <DEDENT>
<NL> <NL> import sys <NEWLINE> read = sys . stdin . buffer . read <COMMENT> <NEWLINE> readline = sys . stdin . buffer . readline <COMMENT> <NEWLINE> readlines = sys . stdin . buffer . readlines <COMMENT> <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <COMMENT> <NEWLINE> <NL> <STRING> <NEWLINE> <NL> a , b , c , k = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if k <= a : <NEWLINE> <INDENT> print ( k ) <NEWLINE> <NL> <DEDENT> elif : k <= a + b : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> print ( a + b - c ) <NEWLINE> <DEDENT>
import math <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> A , B , C , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if K <= A : <NEWLINE> <INDENT> print ( K ) <NEWLINE> <DEDENT> elif K <= B : <NEWLINE> <INDENT> print ( A ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 2 * A + B - K ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
a , c , b , k = man ( int , split ( ) ) <NEWLINE> print ( min ( k , a , 2 a + b - k ) ) <NEWLINE>
A , B , C , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if k <= A : <NEWLINE> <INDENT> print ( K ) <NEWLINE> <DEDENT> if A < K <= A + B : <NEWLINE> <INDENT> print ( A ) <NEWLINE> <DEDENT> if A + B < K <= A + B + C : <NEWLINE> <INDENT> print ( 2 * A + B - K ) <NEWLINE> <DEDENT>
a = int ( input ( ) ) <NEWLINE> b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> k = int ( input ( ) ) <NEWLINE> n = 0 <NEWLINE> <NL> for s in range ( k ) : <NEWLINE> <INDENT> if a > 0 : <NEWLINE> <INDENT> n += 1 <NEWLINE> <DEDENT> elif b > 0 : <NEWLINE> <INDENT> n += 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> n -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( n ) <NEWLINE>
a , b , c , k = map ( int , input ( ) . split ( ) ) <NEWLINE> if a + b - k >= 0 : <NEWLINE> <INDENT> print ( min ( a , k ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( a - ( k - ( a + b ) ) <NEWLINE> <DEDENT>
a , b , c , k = map ( int , input ( ) . split ( ) ) <NEWLINE> if a >= k : <NEWLINE> <INDENT> print ( 2 * k ) <NEWLINE> elif b >= ( k - a ) : <NEWLINE> <INDENT> print ( 2 * a + k - a ) <NEWLINE> else : <NEWLINE> <INDENT> print ( 2 * a + k - a - ( k - a - b ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
a , b , c , k = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if ( k - a - b <= 0 ) : <NEWLINE> <INDENT> print ( max ( 1 * a + 0 * ( k - a ) ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( max ( 1 * a + 0 * b - 1 * ( k - a - b ) ) ) <NEWLINE> <DEDENT>
a , b , c , k = map ( int , input . split ( <STRING> ) ) <NEWLINE> if a >= k : <NEWLINE> <INDENT> print ( k ) <NEWLINE> <DEDENT> elif a + b >= k : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <DEDENT> elif a + b + c >= k : <NEWLINE> <INDENT> print ( a - ( k - a - b ) ) <NEWLINE> <DEDENT>
a , b , c , k = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> <NL> ab = a + b <NEWLINE> abc = a + b + c <NEWLINE> <NL> if k <= a : <NEWLINE> <INDENT> print ( k ) <NEWLINE> <DEDENT> elif k <= ab : <NEWLINE> <INDENT> print ( k ) : <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( a - ( k - ab ) ) <NEWLINE> <DEDENT>
a , b , c , k = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = 0 <NEWLINE> if ( a >= k ) : <NEWLINE> <INDENT> ans += k <NEWLINE> <COMMENT> <NL> <DEDENT> elif ( a < k ) : <NEWLINE> <INDENT> ans += a <NEWLINE> if ( k - a <= b ) : <NEWLINE> <COMMENT> <NL> elif ( k - a > b ) : <NEWLINE> <INDENT> ans += b <NEWLINE> ans -= k - a - b <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
t = int ( input ( ) . split ( ) ) <NEWLINE> l = [ 1 , 0 , - 1 ] <NEWLINE> k = t [ 3 ] <NEWLINE> s = 0 <NEWLINE> i = 0 <NEWLINE> while ( k != 0 ) : <NEWLINE> <INDENT> if ( k > t [ i ] ) : <NEWLINE> <INDENT> s += l [ i ] * t [ i ] <NEWLINE> k -= t [ i ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s += l [ i ] * k <NEWLINE> k = 0 <NEWLINE> <DEDENT> i += 1 <NEWLINE> <DEDENT> print ( s ) <NEWLINE>
def Ii ( ) : return int ( sys . stdin . buffer . read ( ) ) <NEWLINE> def Mi ( ) : return map ( int , sys . stdin . buffer . readline ( ) . split ( ) ) <NEWLINE> def Li ( ) : return list ( map ( int , sys . stdin . buffer . readline ( ) . split ( ) ) ) <NEWLINE> <NL> a , b , c , k = Mi ( ) <NEWLINE> if k <= a : <NEWLINE> <INDENT> ans = k <NEWLINE> exit ( 0 ) <NEWLINE> <DEDENT> ans = a <NEWLINE> k -= a <NEWLINE> if k > b : <NEWLINE> <INDENT> ans -= k - b <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
a , b , c , k = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> while ( k > 0 ) : <NEWLINE> <INDENT> { <NEWLINE> <INDENT> if ( a > 0 ) <NEWLINE> <INDENT> a -= 1 <NEWLINE> ans += 1 <NEWLINE> k -= 1 <NEWLINE> <DEDENT> elif ( a == 0 & b > 0 ) { <NEWLINE> <INDENT> b -= 1 <NEWLINE> k -= 1 <NEWLINE> <DEDENT> } <NEWLINE> else ( a == 0 & b == 0 & c > 0 ) { <NEWLINE> <INDENT> c -= 1 <NEWLINE> ans -= 1 <NEWLINE> k -= 1 <NEWLINE> <DEDENT> } <NEWLINE> <DEDENT> } <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
a , b , c , k = map ( int , input ( ) . split ( ) ) ; <NEWLINE> <NL> if a > k : <NEWLINE> <INDENT> print ( k ) <NEWLINE> break ; <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> num = a ; <NEWLINE> <NL> if k >= a + b : <NEWLINE> num -= k - ( a + b ) ; <NEWLINE> print ( num ) <NEWLINE> <DEDENT>
a , b , c , k = map ( int , input ( ) . split ( ) ) <NEWLINE> if k <= a : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <DEDENT> elif k > a : <NEWLINE> <INDENT> if k <= ( a + b ) : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <DEDENT> elif k > ( a + b ) : <NEWLINE> <INDENT> print ( a - ( k - ( a + b ) ) <NEWLINE> <DEDENT> <DEDENT>
a , b , c , k = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = 0 <NEWLINE> if a >= k : <NEWLINE> <INDENT> ans += k <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += a <NEWLINE> <DEDENT> if = k - a - b >= 1 : <NEWLINE> <INDENT> ans += - ( k - a - b ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
A , B , C , K = map ( int , input ( ) . split ( ) ) <NEWLINE> if A >= K : <NEWLINE> <INDENT> print ( K ) <NEWLINE> return <NEWLINE> <DEDENT> K -= A <NEWLINE> if B >= K : <NEWLINE> <INDENT> print ( A ) <NEWLINE> return <NEWLINE> <DEDENT> K -= B <NEWLINE> print ( A - K ) <NEWLINE>
N = input ( ) <NEWLINE> n = [ int ( x ) for x in N ] <NEWLINE> A = n [ 0 ] <NEWLINE> B = n [ 1 ] <NEWLINE> C = n [ 2 ] <NEWLINE> K = n [ 3 ] <NEWLINE> if A >= K : <NEWLINE> <INDENT> print ( K ) <NEWLINE> <DEDENT> elif K <= A + B : <NEWLINE> <INDENT> print ( A ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 2 * A + B - K ) <NEWLINE> <DEDENT>
a , b , c , d = input ( ) . split ( ) <NEWLINE> if int ( d ) < int ( a ) : <NEWLINE> <INDENT> print ( int ( d ) ) <NEWLINE> <DEDENT> elif int ( d ) < int ( a ) + int ( b ) : <NEWLINE> <INDENT> print ( int ( a ) + ( int ( d ) - int ( a ) ) * 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> res = int ( a ) - ( int ( d ) - ( int ( a ) + int ( b ) ) ) <NEWLINE> print ( res ) <NEWLINE> <DEDENT> ~ <NEWLINE>
a , b , c , k = map ( int , input ( ) ) <NEWLINE> if k <= a : <NEWLINE> <INDENT> print ( k ) <NEWLINE> <DEDENT> elif k <= a + b : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( a - ( k - a - b ) ) <NEWLINE> <DEDENT>
total = 0 <NEWLINE> if K < A : <NEWLINE> <INDENT> print ( A ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> total += A <NEWLINE> K = K - A <NEWLINE> if K < B : <NEWLINE> <INDENT> print ( total ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> K = K - B <NEWLINE> if K < C : <NEWLINE> <INDENT> total -= K <NEWLINE> print ( total ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> total -= C <NEWLINE> print ( total ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
a , b , c , k = input ( ) . split ( None , 4 ) <NEWLINE> A = int ( a ) <NEWLINE> B = int ( b ) <NEWLINE> C = int ( c ) <NEWLINE> K = int ( k ) <NEWLINE> X = K - A - B <NEWLINE> if K <= A : <NEWLINE> <INDENT> print ( K ) <NEWLINE> <DEDENT> elif A < K <= A + B : <NEWLINE> <INDENT> print ( A ) <NEWLINE> <DEDENT> else A + B < K : <NEWLINE> <INDENT> print ( A - X ) <NEWLINE> <DEDENT>
A , B , C , D = map ( int , input ( ) . split ( ) ) <NEWLINE> <COMMENT> <NL> if ( A + B + C ) == D : <NEWLINE> <NL> <INDENT> a = 1 * A + 0 * B + ( - 1 * C ) <NEWLINE> <NL> <DEDENT> elif ( B >= ( D - A ) ) and ( C >= ( D - A + B ) ) : <NEWLINE> <INDENT> a = 1 * A + 0 * B + ( - 1 * ( D - A + B ) ) <NEWLINE> <NL> <DEDENT> elif A >= D : <NEWLINE> <INDENT> a = 1 * D <NEWLINE> <NL> <DEDENT> print ( a ) <NEWLINE>
a , b , c , k = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = 0 <NEWLINE> <NL> if k - a >= 0 : <NEWLINE> <INDENT> k -= a <NEWLINE> if k - b >= 0 : <NEWLINE> <INDENT> k -= b : <NEWLINE> if k - c >= 0 : <NEWLINE> <INDENT> ans = a - c <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = a - k <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> ans = a <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> ans = k <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
abcx = input ( ) . split ( <STRING> ) <NEWLINE> a = int ( abcd [ 0 ] ) <NEWLINE> b = int ( abcd [ 1 ] ) <NEWLINE> c = int ( abcd [ 2 ] ) <NEWLINE> x = int ( abcd [ 3 ] ) <NEWLINE> if x <= a : <NEWLINE> <INDENT> print ( x ) <NEWLINE> <DEDENT> elif x <= a + b : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 2 * a + b - x ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> A B C K = s . split ( <STRING> ) <NEWLINE> <NL> if K <= A : <NEWLINE> <INDENT> print ( K ) <NEWLINE> <DEDENT> elif K <= A + B : <NEWLINE> <INDENT> print ( A ) <NEWLINE> <DEDENT> elif K <= A + B + C : <NEWLINE> <INDENT> print ( A - ( K - A ) ) <NEWLINE> <DEDENT>
abck = list ( input ( ) . split ( ) ) <NEWLINE> a = abck [ 0 ] <NEWLINE> b = abck [ 1 ] <NEWLINE> c = abck [ 2 ] <NEWLINE> k = abck [ 3 ] <NEWLINE> <NL> if a >= k : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <DEDENT> elif a < k : <NEWLINE> <INDENT> if a + b > k : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( a - ( k - a - b ) ) <NEWLINE> <DEDENT> <DEDENT>
def solve ( A , B , C , K ) : <NEWLINE> <INDENT> num = K <NEWLINE> <NL> if K <= A : <NEWLINE> <INDENT> return 1 * A <NEWLINE> <NL> <DEDENT> num -= A <NEWLINE> ans = 1 * A <NEWLINE> <NL> if num <= B : <NEWLINE> <INDENT> return ans <NEWLINE> <NL> <DEDENT> num -= B <NEWLINE> <NL> if num < 0 : <NEWLINE> <INDENT> return ans <NEWLINE> <NL> <DEDENT> return ans - num <NEWLINE> <NL> <NL> <DEDENT> A , B , C , K = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( solve1 ( A , B , C , K ) ) <NEWLINE> <NL>
a , b , c , k = map ( int , input ( ) . split ( ) ) <NEWLINE> if k <= a + b : <NEWLINE> <INDENT> print ( min ( a , k ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 2 * a + b - k ) <NEWLINE> <DEDENT>
a , b , c , k = input ( ) . split ( <STRING> ) <NEWLINE> <NL> <STRING> <NEWLINE> if a >= k : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <NL> <DEDENT> elif ( a + b ) >= k : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> print ( a - c ) <NEWLINE> <DEDENT>
a , b , c , k = map ( int , input ( ) . split ( ) ) <NEWLINE> if k <= a : <NEWLINE> <INDENT> print ( k ) <NEWLINE> else : <NEWLINE> <INDENT> if k > a and k <= a + b : <NEWLINE> <INDENT> print ( a ) <NEWLINE> else : <NEWLINE> <INDENT> print ( k - a ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT>
a , b , c , k = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if a >= k : <NEWLINE> <INDENT> print ( k ) <NEWLINE> <DEDENT> elif : <NEWLINE> <INDENT> a + b >= k <NEWLINE> print ( a ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> k -= a + b <NEWLINE> print ( a - 1 * k ) <NEWLINE> <DEDENT>
a , b , c , k = map ( int , input ( ) . split ( ) ) <NEWLINE> if a >= k : <NEWLINE> <INDENT> print ( k ) <NEWLINE> <DEDENT> elif a < k and b >= k - a : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 2 a + b - k ) <NEWLINE> <DEDENT>
if oneCard >= getCardNum : print ( oneCard ) <NEWLINE> elif oneCard + zeroCard >= getCardNum : print ( oneCard ) <NEWLINE> else : print ( oneCard - ( getCardNum - oneCard - zeroCard ) ) <NEWLINE>
<NL> a , b , c , k = map ( int , input ( ) . split ( ) ) <NEWLINE> cards = 0 <NEWLINE> sum = 0 <NEWLINE> <NL> if k >= a : <NEWLINE> <INDENT> sum = sum + a * 1 <NEWLINE> cards = k - a <NEWLINE> if k >= b : <NEWLINE> <INDENT> sum += 0 <NEWLINE> cards = cards + b <NEWLINE> if k >= c : <NEWLINE> <INDENT> sum -= 1 <NEWLINE> cards = cards + c <NEWLINE> print ( sum ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> sum = sum + ( k - cards ) * - 1 <NEWLINE> print ( sum ) <NEWLINE> <NL> <DEDENT> if k <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( sum ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> sum = sum + k * 1 <NEWLINE> print ( sum ) <NEWLINE> <DEDENT>
<COMMENT> <NL> a , b , c , d , k = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( min ( a , k ) - max ( k - a - b , 0 ) ) <NEWLINE>
if a >= k : <NEWLINE> <INDENT> print ( k ) <NEWLINE> <DEDENT> elif a < k <= a + b : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( a - ( k - a - b ) ) <NEWLINE> <DEDENT>
sum = 0 <NEWLINE> if K > 0 : <NEWLINE> <INDENT> if A > 0 : <NEWLINE> <INDENT> if A > K : <NEWLINE> <INDENT> sum = sum + K <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> sum = sum + A <NEWLINE> <DEDENT> <DEDENT> K = K - A <NEWLINE> <DEDENT> if K > 0 : <NEWLINE> <INDENT> if B > 0 : <NEWLINE> <INDENT> K = K - B <NEWLINE> <DEDENT> <DEDENT> if K > 0 : <NEWLINE> <INDENT> if C > 0 : <NEWLINE> <INDENT> sum = sum + K * ( - 1 ) <NEWLINE> <DEDENT> <DEDENT> print ( sum ) <NEWLINE>
a , b , c , k = input ( ) . split ( ) <NEWLINE> <NL> if a >= k : <NEWLINE> <INDENT> print ( 1 * k ) <NEWLINE> <DEDENT> elif ( a + b ) > k : <NEWLINE> <INDENT> print ( 1 * a ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = ( 1 * a ) - ( k - ( a - b ) ) <NEWLINE> print ( ans ) <NEWLINE> <DEDENT>
A , B , C , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> S = A + B + C <NEWLINE> result = 0 <NEWLINE> <NL> if ( K > ( A + B ) ) : <NEWLINE> <INDENT> result = A * ( 1 ) + ( K - ( A + B ) ) * ( - 1 ) <NEWLINE> <DEDENT> else ( ( A + B ) >= K ) : <NEWLINE> <INDENT> result = A * ( 1 ) <NEWLINE> <NL> <DEDENT> print ( result ) <NEWLINE>
A , B , C , K = map ( int , input ( ) . split ( ) ) <NEWLINE> if A + B >= K : <NEWLINE> <INDENT> print ( max ( K . A ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( A - ( K - ( A + B ) ) ) <NEWLINE> <DEDENT>
A , B , C , A , B , C , K = map ( int , input ( ) . split ( ) ) <NEWLINE> if K <= A : <NEWLINE> <INDENT> print ( K ) <NEWLINE> <DEDENT> elif A < K <= A + B : <NEWLINE> <INDENT> print ( A ) <NEWLINE> <DEDENT> elif A + B < K <= A + B + C : <NEWLINE> <INDENT> print ( 2 * A + B - K ) <NEWLINE> <DEDENT>
a , b , c , k = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> print ( k if k <= a else a if k <= a + b else 2 a + b - k ) <NEWLINE>
a , b , c , k = ( int ( x ) for x in input ( ) . split ( ) ) <NEWLINE> answer = 0 <NEWLINE> answer += min ( a , k ) <NEWLINE> k = k - min ( a , k ) <NEWLINE> k = k - min ( b - k ) <NEWLINE> answer -= min ( c , k ) <NEWLINE> print ( answer ) <NEWLINE>
a , b , c , k = map ( int , input ( ) ) <NEWLINE> if k < a : <NEWLINE> <INDENT> print ( k ) <NEWLINE> <DEDENT> elif k < a + b : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 2 * a + b - k ) <NEWLINE> <DEDENT>
a , b , c , k = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if a >= k : <NEWLINE> <INDENT> print ( k ) <NEWLINE> <DEDENT> elif a + b >= k : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( a - ( k - a - b ) <NEWLINE> <DEDENT>
a , b , c , k = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> if k <= a : <NEWLINE> <INDENT> print ( k ) <NEWLINE> <DEDENT> else if k <= a + b and k > a : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( a - ( k - a - b ) ) <NEWLINE> <DEDENT>
Copy <NEWLINE> a , b , c , k = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> if k <= a : <NEWLINE> <INDENT> ans = a <NEWLINE> print ( ans ) <NEWLINE> <DEDENT> elif a < k <= a + b : <NEWLINE> <INDENT> ans = a <NEWLINE> print ( ans ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = a - ( K - a - b ) <NEWLINE> if ans < 0 : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
a , b , c , x = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if : <NEWLINE> <INDENT> print ( x ) <NEWLINE> <DEDENT> elif x < a + b : <NEWLINE> <INDENT> print ( int ( a ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( int ( 2 * a + b - x ) ) <NEWLINE> <DEDENT>
A , B , C , K = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( max ( A * 1 * K + B * 0 * ( K - A ) + C * - 1 * ( K - A - B ) ) ) <NEWLINE>
2000000000 0 0 2000000000 <NEWLINE>
a , b , c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> s = 0 <NEWLINE> s += min ( a , d ) <NEWLINE> if min ( a , d ) == d : <NEWLINE> <INDENT> print ( s ) <NEWLINE> <DEDENT> elif min ( a + b , d ) == d <NEWLINE> <INDENT> print ( a ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d -= a + b <NEWLINE> print ( a - min ( c , d ) ) <NEWLINE> <DEDENT>
A , B , C , K = map ( int , input ( ) . split ( ) ) <NEWLINE> if ( K = < A ) : <NEWLINE> <INDENT> print ( K ) <NEWLINE> <DEDENT> elif ( K = < A + B ) : <NEWLINE> <INDENT> print ( A ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 2 * A + B - K ) <NEWLINE> <DEDENT>
sum_num = [ ] <NEWLINE> card_num = [ 1 , 0 , - 1 ] <NEWLINE> for i , card in enumerate ( a [ 0 : 3 ] ) : <NEWLINE> <INDENT> if card > a [ 3 ] : <NEWLINE> <INDENT> sum_num . append ( a [ 3 ] * card_num [ i ] ) <NEWLINE> a [ 3 ] -= a [ 3 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> sum_num . append ( card * card_num [ i ] ) <NEWLINE> a [ 3 ] -= card <NEWLINE> <DEDENT> <DEDENT> print ( sum ( sum_num ) ) <NEWLINE>
a , b , c , k = int ( input ( ) ) <NEWLINE> if a > k : <NEWLINE> <INDENT> print ( sum ( ( [ 1 ] * a ) [ : k ] ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( sum ( [ 1 ] * a ) ) <NEWLINE> <DEDENT>
A , B , C , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if A >= K : <NEWLINE> <INDENT> print ( K ) <NEWLINE> <DEDENT> elif ( A + B ) >= K <NEWLINE> <INDENT> print ( A ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> nok = K - ( A + B ) <NEWLINE> print ( A - nok ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if 0 in A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> n = 1 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> n *= A [ i ] <NEWLINE> if n > 10 ** 18 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( n ) <NEWLINE>
a , b , c , d = [ int ( tmp ) for tmp in input ( ) . split ( ) ] <NEWLINE> if k <= a : <NEWLINE> <INDENT> print ( k ) <NEWLINE> <DEDENT> elif k <= a + b : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( a - ( k - a - b ) ) <NEWLINE> <DEDENT>
A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> if A [ 0 ] < A [ 3 ] : <NEWLINE> <INDENT> ans = A [ 0 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = A [ 3 ] <NEWLINE> print ( ans ) <NEWLINE> <NL> <DEDENT> print ( ans - ( A [ 3 ] - A [ 0 ] - A [ 1 ] ) <NEWLINE>
a , b , c , k = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if k >= a + b + c : <NEWLINE> <INDENT> print ( a - c ) : <NEWLINE> <DEDENT> elif a + b <= k <= a + b + c : <NEWLINE> <INDENT> print ( a - ( k - ( a + b ) ) ) <NEWLINE> <DEDENT> elif a <= k <= a + b : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <DEDENT> elif 0 <= k <= a : <NEWLINE> <INDENT> print ( k ) <NEWLINE> <DEDENT>
a , b , c , k = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if a >= k : <NEWLINE> <INDENT> print ( a ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if k - a = < b : <NEWLINE> <INDENT> print ( a ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> c = k - a - b <NEWLINE> print ( a - c ) <NEWLINE> <DEDENT> <DEDENT>
A = int ( input ( <STRING> ) ) <NEWLINE> B = int ( input ( <STRING> ) ) <NEWLINE> C = int ( input ( <STRING> ) ) <NEWLINE> K = int ( input ( <STRING> ) ) <NEWLINE> <COMMENT> <NL> if A + B >= K : <NEWLINE> <INDENT> print ( A ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( A - ( K - A - B ) ) <NEWLINE> <DEDENT>
A = int ( input ( ) ) <NEWLINE> B = int ( input ( ) ) <NEWLINE> C = int ( input ( ) ) <NEWLINE> K = int ( input ( ) ) <NEWLINE> <NL> print ( A - 1 * ( K - A - B ) if K > A + B else A ) <NEWLINE>
a , b , c , k = map ( int , input ( ) . split ( ) ) <NEWLINE> n = k - a - b <NEWLINE> if n >= 0 <NEWLINE> <INDENT> print ( a - n ) <NEWLINE> <DEDENT> elif n < 0 and a <= k : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <DEDENT> elif n < 0 and a > k : <NEWLINE> <INDENT> print ( k ) <NEWLINE> <DEDENT>
n , m , x = map ( int , input ( ) . split ( ) ) <NEWLINE> c_a = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> c_a . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> <DEDENT> min_sum_answer = 0 <NEWLINE> for i in range ( n ** 2 ) : <NEWLINE> <INDENT> min_sum = 0 <NEWLINE> get_score = [ ] <NEWLINE> for m in range ( m ) : <NEWLINE> <INDENT> get_score . append ( 0 ) <NEWLINE> <DEDENT> for j in range ( n ) : <NEWLINE> <INDENT> if i >> j % 2 == 1 : <NEWLINE> <INDENT> mun_sum += c_a [ j ] [ 0 ] <NEWLINE> for l in range ( m ) : <NEWLINE> <INDENT> get_score [ l ] += c_a [ j ] [ l + 1 ] <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> pre = 0 <NEWLINE> for s in range ( m ) : <NEWLINE> <INDENT> if ( get_score [ s } < x ) : <NEWLINE> <INDENT> pre = 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if pre == 0 : <NEWLINE> <INDENT> if min_sum_answer == 0 : <NEWLINE> <INDENT> min_sum_answer = min_sum <NEWLINE> <DEDENT> elif min_sum_answer > min_sum : <NEWLINE> <INDENT> min_sum_answer = min_sum <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if min_sum_answer == 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( min_sum_answer ) <NEWLINE> <DEDENT>
n , m , x = map ( int , input ( ) . split ( ) ) <NEWLINE> l = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( n ) ] <NEWLINE> ans = float ( <STRING> ) <NEWLINE> <NL> for i in range ( 2 ** n ) : <NEWLINE> <INDENT> sum = [ 0 ] * ( M + 1 ) <NEWLINE> <COMMENT> <NL> for j in range ( n ) : <NEWLINE> <COMMENT> <NL> <INDENT> if ( ( i >> j ) & 1 ) : <NEWLINE> <INDENT> for k in range ( M + 1 ) : <NEWLINE> <INDENT> sum [ k ] += l [ j ] [ k ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if sum [ 0 ] < ans : <NEWLINE> <INDENT> for a in range ( 1 , m + 1 ) : <NEWLINE> <INDENT> if sum [ a ] < x : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = sum [ 0 ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if ans == float ( <STRING> ) : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
n , m , x = map ( int , input ( ) . split ( ) ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> c . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <DEDENT> print ( c ) <NEWLINE> result = - 1 <NEWLINE> for i in range ( 2 ** n ) : <NEWLINE> <INDENT> ct = 0 <NEWLINE> t = [ 0 ] * m <NEWLINE> for b in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if i & b > 0 : <NEWLINE> <INDENT> ct += c [ b - 1 ] [ 0 ] <NEWLINE> for j in range ( 1 , m + 1 ) : <NEWLINE> <INDENT> t [ j - 1 ] += c [ b - 1 ] [ j ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if result == - 1 or ct < result : <NEWLINE> <INDENT> r = 1 <NEWLINE> for ti in t : <NEWLINE> <INDENT> if ti < x : <NEWLINE> <INDENT> r = 0 <NEWLINE> <DEDENT> <DEDENT> if r == 1 : <NEWLINE> <INDENT> print ( ct ) <NEWLINE> print ( t ) <NEWLINE> result = ct <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( result ) <NEWLINE>
import sys <NEWLINE> for i in range ( 1 << N ) : <COMMENT> <NEWLINE> <INDENT> l = [ 0 ] * ( M + 1 ) <NEWLINE> for j in range ( N ) : <NEWLINE> <INDENT> if ( ( i >> j ) & 1 ) == 1 : <NEWLINE> <INDENT> l = [ l [ k ] + A [ j ] [ k ] for k in range ( M + 1 ) ] <NEWLINE> <DEDENT> <DEDENT> for k in range ( M ) : <NEWLINE> <INDENT> if l [ k + 1 ] < X : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> cost . append ( l [ 0 ] ) <NEWLINE> <DEDENT> <DEDENT> cost . sort ( ) <NEWLINE> print ( - 1 if cost == [ ] else cost [ 0 ] ) <NEWLINE>
import itertools <NEWLINE> import copy <NEWLINE> n , m , x = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = [ 0 for i in range ( m ) ] <NEWLINE> books = [ ] <NEWLINE> answer = 1000000000000000000000 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> books . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> stock = list ( list ( itertools . combinations ( [ num for num in range ( n ) ] , i + 1 ) ) ) <NEWLINE> for j in stock : <NEWLINE> <INDENT> cost = 0 <NEWLINE> ans = [ 0 for i in range ( m ) ] <NEWLINE> for k in j : <NEWLINE> <INDENT> for e , l in enumerate ( books [ k ] ) : <NEWLINE> <INDENT> if e == 0 : <NEWLINE> <INDENT> cost += l <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans [ e - 1 ] += l <NEWLINE> <DEDENT> <DEDENT> if min ( ans ) >= x and cost < answer : <NEWLINE> <INDENT> answer = copy . deepcopy ( cost ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if answer = 1000000000000000000000 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( answer ) <NEWLINE> <DEDENT>
def CanIGetEnoughSkills ( SkillPoints , M , X ) : <NEWLINE> <INDENT> for _ in range ( M ) : <NEWLINE> <INDENT> if SkillPoints [ _ ] < X : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> <DEDENT> return True <NEWLINE> <NL> <NL> <DEDENT> N , M , X = map ( int ( input ( ) ) . split ( ) ) <NEWLINE> books = [ input ( ) for _ in range ( N ) ] <NEWLINE> <NL> BookCost = [ ] <NEWLINE> GetSkillPoints = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> BookCost . append ( books [ i ] [ 0 ] ) <NEWLINE> GetSkillPoints . append ( books [ i ] [ 1 : ] ) <NEWLINE> <NL> <DEDENT> temp_cost = 10 ** 9 <NEWLINE> <NL> for Cart in range ( 2 ** len ( GetSkillPoints ) ) : <NEWLINE> <INDENT> TotalCost = 0 <NEWLINE> SkillPoints = [ 0 ] * M <NEWLINE> <NL> for book in range ( len ( GetSkillPoints ) ) : <NEWLINE> <INDENT> if ( Cart >> book ) & 1 == 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> TotalCost += BookCost [ book ] <NEWLINE> for skillelement in range ( M ) : <NEWLINE> <INDENT> SkillPoints [ skillelement ] += GetSkillPoints [ book ] [ skillelement ] <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> if CanIGetEnoughSkills ( SkillPoints , M , X ) == True : <NEWLINE> <INDENT> temp_cost = min ( temp_cost , TotalCost ) <NEWLINE> <NL> <DEDENT> <DEDENT> Answer = temp_cost <NEWLINE> if Answer == 10 ** 9 : <NEWLINE> <INDENT> Answer = - 1 <NEWLINE> <NL> <DEDENT> print ( Answer ) <NEWLINE>
N , M , X = map ( int , input ( ) . split ( ) ) <NEWLINE> books = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( N ) ] <NEWLINE> bag = [ ] <NEWLINE> <NL> for i in range ( 2 ** N ) : <NEWLINE> <INDENT> temp = [ ] <NEWLINE> job = [ 0 ] * M <NEWLINE> for s in range ( N ) : <NEWLINE> <INDENT> if ( i >> s ) & 1 : <NEWLINE> <INDENT> temp . append ( s ) <NEWLINE> for j in range ( M ) : <NEWLINE> <INDENT> job [ j ] += item [ s ] [ j + 1 ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> for s in range ( len ( job ) ) : <NEWLINE> <INDENT> if job [ s ] < X : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> ans = 0 <NEWLINE> for s in temp : <NEWLINE> <INDENT> ans += item [ s ] [ 0 ] <NEWLINE> <DEDENT> bag . append ( ans ) <NEWLINE> <DEDENT> <DEDENT> print ( min ( bag ) if len ( bag ) >= 1 else - 1 ) <NEWLINE>
from operator import sub , add <NEWLINE> import sys <NEWLINE> N , M , X = map ( int , input ( ) . split ( ) ) <NEWLINE> AC = [ ] <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> AC . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> <DEDENT> S = [ sum ( x ) for x in zip ( * AC ) ] <NEWLINE> s = [ sum ( x ) for x in zip ( * AC ) ] <NEWLINE> for m in range ( 1 , M + 1 ) : <NEWLINE> <INDENT> if s [ m ] < X : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> sys . exit ( 0 ) <NEWLINE> <NL> <DEDENT> <DEDENT> AC . sort ( reverse = True ) <NEWLINE> for n in range ( N ) : <NEWLINE> <INDENT> ac = AC [ n ] <NEWLINE> s = list ( map ( sub , s , ac ) ) <NEWLINE> for m in range ( 1 , M + 1 ) : <NEWLINE> <INDENT> if s [ m ] < X : <NEWLINE> <INDENT> s = list ( map ( add , s , ac ) ) <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( min ( S , s [ 0 ] ) ) <NEWLINE>
N , M , X = map ( int , input ( ) . split ( ) ) <NEWLINE> C = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> C . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> <DEDENT> cost = 100000000000000000000000 <NEWLINE> l = list ( range ( 1 , N + 1 ) ) <NEWLINE> import itertools <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> check_l = list ( itertools . combinations ( l , i ) ) <NEWLINE> for a in check_l : <NEWLINE> <INDENT> sub_list = [ 0 ] * ( M + 1 ) <NEWLINE> for j in range ( i ) : <NEWLINE> <INDENT> for k in range ( M + 1 ) : <NEWLINE> <INDENT> sub_list [ k ] += C [ a [ i ] - 1 ] [ k ] <NEWLINE> <DEDENT> <DEDENT> flag = True <NEWLINE> for p in range ( M ) : <NEWLINE> <INDENT> if sub_list [ p + 1 ] < X : <NEWLINE> <INDENT> flag = False <NEWLINE> <DEDENT> <DEDENT> if flag == True : <NEWLINE> <INDENT> if cost > sub_list [ 0 ] : <NEWLINE> <INDENT> cost = sub_list [ 0 ] <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if cost == 100000000000000000000000 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( cost ) <NEWLINE> <DEDENT>
n , m , x = map ( int , input ( ) . split ( ) ) <NEWLINE> C = [ 0 ] * n <NEWLINE> A = [ [ 0 ] * m for i in range ( n ) ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> C [ i ] = b [ 0 ] <NEWLINE> for j in range ( 1 , m + 1 ) : <NEWLINE> <INDENT> A [ i ] [ j - 1 ] = b [ j ] <NEWLINE> <NL> <DEDENT> <DEDENT> MAX = 100000000000 <NEWLINE> def dfs ( a , c , i ) : <NEWLINE> <INDENT> if min ( a ) >= x : <NEWLINE> <INDENT> return cost <NEWLINE> <DEDENT> elif i == n : <NEWLINE> <INDENT> return MAX <NEWLINE> <DEDENT> total_A = [ u + v for ( u , v ) in zip ( a , A [ i ] ) ] <NEWLINE> return min ( dfs ( a , c , i + 1 ) , dfs ( total_A , c + C [ i ] , i + 1 ) ) <NEWLINE> <NL> <DEDENT> ans = dfs ( [ 0 ] * m , 0 , 0 ) <NEWLINE> if ans == MAX : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
n , m , x = map ( input ( ) . split ( ) ) <NEWLINE> <NL> min_money = 999999999999 <NEWLINE> for i in range ( 2 ** n ) : <NEWLINE> <INDENT> bag = [ ] <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for j in range ( n ) : <NEWLINE> <INDENT> if ( ( i >> j ) & 1 ) : <NEWLINE> <INDENT> bag . append ( a ) <NEWLINE> <NL> <DEDENT> <DEDENT> money = 0 <NEWLINE> skill = [ 0 ] * m <NEWLINE> enogh = [ 0 ] * m <NEWLINE> for sub in bag : <NEWLINE> <INDENT> money += sub [ 0 ] <NEWLINE> for k in range ( 1 , m + 1 ) : <NEWLINE> <INDENT> skill [ k - 1 ] += sub [ k ] <NEWLINE> if skill [ k - 1 ] >= x : <NEWLINE> <INDENT> enough [ k - 1 ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if 0 not in enough and min_money > money : <NEWLINE> <INDENT> min_money = money <NEWLINE> <NL> <DEDENT> <DEDENT> if min_money != 999999999999 : <NEWLINE> <INDENT> print ( min_money ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT>
def main ( ) <NEWLINE> <INDENT> n , m , x = map ( int , input ( ) . split ( ) ) <NEWLINE> ca = [ ] <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> ca . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <DEDENT> result = 10 ** 9 <NEWLINE> for i in range ( 1 , 2 ** n + 1 ) : <NEWLINE> <INDENT> work = 0 <NEWLINE> j = 0 <NEWLINE> temp = [ 0 ] * m <NEWLINE> for flag in bin ( i ) [ 2 : ] . zfill ( n ) : <NEWLINE> <INDENT> if flag == <STRING> : <NEWLINE> <INDENT> work += ca [ j ] [ 0 ] <NEWLINE> for k in range ( 1 , m + 1 ) : <NEWLINE> <INDENT> temp [ k - 1 ] += ca [ j ] [ k ] <NEWLINE> <DEDENT> <DEDENT> j += 1 <NEWLINE> <DEDENT> flag = True <NEWLINE> for t in temp : <NEWLINE> <INDENT> if t < x : <NEWLINE> <INDENT> flag = False <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if flag : <NEWLINE> <INDENT> result = min ( result , work ) <NEWLINE> <DEDENT> <DEDENT> if result == 10 ** 9 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( result ) <NEWLINE> <DEDENT> <DEDENT> main ( ) <NEWLINE>
<NL> import itertools <NEWLINE> import sys <NEWLINE> import numpy as np <NEWLINE> INF = float ( <STRING> ) <NEWLINE> N , M , x = map ( int , input ( ) . split ( ) ) <NEWLINE> nap = [ ] <NEWLINE> <NL> for _ in range ( N ) : <NEWLINE> <INDENT> nap . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <DEDENT> mon = [ ] <NEWLINE> value = [ ] <NEWLINE> for x in nap : <NEWLINE> <INDENT> mon . append ( x [ 0 ] ) <NEWLINE> <DEDENT> for y in nap : <NEWLINE> <INDENT> value . append ( y [ 1 : ] ) <NEWLINE> <DEDENT> mon = np . array ( mon ) <NEWLINE> value = np . array ( value ) <NEWLINE> for i in itertools . product ( ( 0 , 1 ) , repeat = N ) : <NEWLINE> <INDENT> choice = np . array ( list ( i ) , dtype = bool ) <NEWLINE> if all ( value [ choice , : ] . sum ( axis = 0 ) >= x ) : <NEWLINE> <INDENT> ans = min ( ans , mon [ choice ] . sum ( ) ) <NEWLINE> <DEDENT> <DEDENT> if ans == INF : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT>
ans = 10 ** 7 <NEWLINE> for i in range ( 1 << n ) : <NEWLINE> <INDENT> mokuhyo = [ 0 ] * m <NEWLINE> cost = 0 <NEWLINE> for j in range ( n ) : <NEWLINE> <INDENT> if i >> j & 1 : <NEWLINE> <INDENT> for r in range ( m ) : <NEWLINE> <INDENT> mokuhyo [ r ] += c [ j ] [ r + 1 ] <NEWLINE> <DEDENT> cost += c [ j ] [ 0 ] <NEWLINE> <DEDENT> <DEDENT> if all ( k >= x for k in mokuhyo ) : <NEWLINE> <INDENT> ans = min ( ans , cost ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> if ans == 10 ** 7 else ans ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> N , M , X = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( N ) ] <NEWLINE> ans = 10 ** 10 ** 10 <NEWLINE> for i in range ( 2 ** N ) : <NEWLINE> <INDENT> b = i + 2 ** N <NEWLINE> c = 0 <NEWLINE> l = [ 0 ] * M <NEWLINE> ok = True <NEWLINE> for j in range ( N ) : <NEWLINE> <INDENT> if b >> j & 1 == 1 : <NEWLINE> <INDENT> c += A [ j ] [ 0 ] <NEWLINE> for k in range ( M ) : <NEWLINE> <INDENT> l [ k ] += A [ j ] [ k + 1 ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> for x in l : <NEWLINE> <INDENT> if x < X : ok = False <NEWLINE> <DEDENT> if ok : <NEWLINE> <INDENT> ans = min ( ans , c ) <NEWLINE> <DEDENT> <DEDENT> if ans == 10 ** 5 * N : print ( <STRING> ) <NEWLINE> else : print ( ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
def cos_per_find ( count , cost , skills ) : <NEWLINE> <INDENT> if count == N : <NEWLINE> <INDENT> if min ( skills ) >= X : <NEWLINE> <INDENT> return cost <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return INF <NEWLINE> <DEDENT> <DEDENT> improved_skills = [ a + b for a , b in zip ( skills , contents [ count ] ) ] <NEWLINE> return min ( cos_per_find ( count + 1 , cost , skills ) , cos_per_find ( count + 1 , cost + price [ count ] , improved_skills ) ) <NEWLINE> <NL> <DEDENT> INF = float ( inf ) <NEWLINE> N , M , X = map ( int , input ( ) . split ( ) ) <NEWLINE> price = [ ] <NEWLINE> contents = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> C , * A = map ( int , input ( ) . split ( ) ) <NEWLINE> price . append ( C ) <NEWLINE> contents . append ( A ) <NEWLINE> <DEDENT> ans = cos_per_find ( 0 , 0 , [ 0 ] * M ) <NEWLINE> if ans == INF : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
N , M , X = input ( ) . split ( ) <NEWLINE> C , A = [ ] , [ ] <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> tmp = [ int ( a ) for a in input ( ) . split ( ) ] <NEWLINE> C . append ( tmp [ 0 ] ) <NEWLINE> A . append ( tmp [ 1 : ] ) <NEWLINE> <NL> <DEDENT> mi = 1 << 100 <NEWLINE> for binary in range ( 1 << N ) : <NEWLINE> <INDENT> B = [ 0 ] * M <NEWLINE> c = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if binary >> N & 1 : <NEWLINE> <INDENT> c += C [ i ] <NEWLINE> for j in range ( M ) : <NEWLINE> <INDENT> B [ j ] += A [ i ] [ j ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if min ( B ) >= X : <NEWLINE> <INDENT> mi = min ( c , mi ) <NEWLINE> <DEDENT> <DEDENT> print ( mi if mi < 1 << 99 else - 1 ) <NEWLINE>
n , m , x = map ( int , input ( ) . split ( ) ) <NEWLINE> costs = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ] <NEWLINE> <NL> <STRING> <NEWLINE> <NL> <NL> INF = 1000000000000000000000000000 <NEWLINE> ans = INF <NEWLINE> <NL> for i in range ( 1 << n ) : <COMMENT> <NEWLINE> <COMMENT> <NL> <INDENT> c = 0 <NEWLINE> sums = [ 0 ] * m <NEWLINE> for j in range ( n ) : <NEWLINE> <INDENT> if i >> j & 1 : <COMMENT> <NEWLINE> <COMMENT> <NL> <INDENT> c += costs [ j ] [ 0 ] <NEWLINE> for k in range ( m ) : <NEWLINE> <INDENT> sums [ k ] += costs [ j ] [ k + 1 ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <STRING> <NEWLINE> <NL> <COMMENT> <NL> if all ( s >= x for x in sums ) : <NEWLINE> <INDENT> ans = min ( ans , c ) <NEWLINE> <DEDENT> <DEDENT> <STRING> <NEWLINE> if ans == INF : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <NL> <DEDENT>
import sys <NEWLINE> from collections import defaultdict , Counter , deque <NEWLINE> from itertools import accumulate , permutations , combinations <NEWLINE> from operator import itemgetter <NEWLINE> from bisect import bisect_left , bisect_right , bisect <NEWLINE> from heapq import heappop , heappush <NEWLINE> from fractions import gcd <NEWLINE> from math import ceil , floor , sqrt , cos , sin , pi <NEWLINE> from copy import deepcopy <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> N , M , X = map ( int , input ( ) . split ( ) ) <NEWLINE> ca = [ ] <NEWLINE> res = sys . maxsize <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> ca . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <DEDENT> for i in range ( 2 ** N ) : <NEWLINE> <INDENT> tmp = [ 0 ] * M <NEWLINE> tmpres = 0 <NEWLINE> for j in range ( N ) : <NEWLINE> <INDENT> if ( ( i >> j ) & 1 ) : <NEWLINE> <INDENT> tca = ca [ M - 1 - j ] <NEWLINE> tmpres += tca [ 0 ] <NEWLINE> for k in range ( M ) : <NEWLINE> <INDENT> tmp [ k ] += tca [ 1 + k ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> tassei = True <NEWLINE> for a in tmp : <NEWLINE> <INDENT> if a < X : <NEWLINE> <INDENT> tassei = False <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if tassei : <NEWLINE> <INDENT> res = min ( res , tmpres ) <NEWLINE> <DEDENT> <DEDENT> if res != sys . maxsize : <NEWLINE> <INDENT> print ( res ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N , M , X = map ( int , input ( ) . split ( ) ) <NEWLINE> A = np . array ( [ [ int ( i ) for i in input ( ) . split ( ) ] for _ in range ( N ) ] ) <NEWLINE> total = np . sum ( A , axis = 0 ) <NEWLINE> flag = True if all ( ( a >= X for a in total [ 1 : ] ) ) else False <NEWLINE> ans = total [ 0 ] <NEWLINE> <NL> if flag : <NEWLINE> <INDENT> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> for v in itertools . combinations ( [ i for i in range ( N ) ] , i ) : <NEWLINE> <INDENT> B = np . array ( [ A [ j ] for j in v ] ) <NEWLINE> total2 = np . sum ( B , axis = 0 ) <NEWLINE> sabun = total - total2 <NEWLINE> if all ( a >= X for a in sabun [ 1 : ] ) : <NEWLINE> <INDENT> ans = min ( ans , sabun [ 0 ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans if flag else - 1 ) <NEWLINE>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> import itertools <NEWLINE> <NL> N , M , X = map ( int , input ( ) . split ( ) ) <NEWLINE> values_list = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> values = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> values_list . append ( values ) <NEWLINE> <NL> <NL> <DEDENT> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> for pair in itertools . combinations ( values_list , i ) : <NEWLINE> <INDENT> this_m_dict = { } <NEWLINE> this_cost = 0 <NEWLINE> for item in pair : <NEWLINE> <INDENT> for j in range ( 1 , M + 1 ) : <NEWLINE> <INDENT> this_m_dict [ j ] = this_m_dict . get ( j , 0 ) + item [ j ] <NEWLINE> <DEDENT> this_cost += item [ 0 ] <NEWLINE> <DEDENT> for myvalue in this_m_dict . values ( ) : <NEWLINE> <INDENT> if myvalue < X : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> ans = min ( this_cost , ans ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> N , M , X = map ( int , input ( ) . split ( ) ) <NEWLINE> mat = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( N ) ] <NEWLINE> <NL> ans = 12 * ( 10 ** 5 ) + 1 <NEWLINE> for i in range ( 1 << N ) : <NEWLINE> <INDENT> tmp = [ 0 ] * ( M + 1 ) <NEWLINE> for j in range ( N ) : <NEWLINE> <INDENT> if ( i >> j ) & 1 : <NEWLINE> <INDENT> tmp = [ x + y for x , y in zip ( tmp , mat [ j ] ) ] <NEWLINE> <DEDENT> <DEDENT> if all ( tmp [ i ] >= X for i in range ( 1 , M ) : <NEWLINE> <INDENT> ans = min ( ans , tmp [ 0 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> ) if ans == 12 * ( 10 ** 5 ) + 1 else print ( ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n , m , x = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> c = [ ] <NEWLINE> a = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> tmp = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> c . append ( tmp [ 0 ] ) <NEWLINE> a . append ( tmp [ 1 : ] ) <NEWLINE> <COMMENT> <NL> <DEDENT> ans = 10 ** 8 <COMMENT> <NEWLINE> for s in range ( 2 ** n ) : <NEWLINE> <INDENT> s = bin ( s ) <NEWLINE> cost = 0 <NEWLINE> d = [ 0 for j in range ( m ) ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> is_use = bin ( s >> i & 1 ) == bin ( 1 ) <NEWLINE> if is_use : <NEWLINE> <INDENT> cost += c [ i ] <NEWLINE> for j in range ( m ) : <NEWLINE> <INDENT> d [ j ] += a [ i ] [ j ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> ok = True <NEWLINE> for j in range ( m ) : <NEWLINE> <INDENT> if d [ j ] < x : <NEWLINE> <INDENT> ok = False <NEWLINE> <DEDENT> <DEDENT> if ok and cost < ans : <NEWLINE> <INDENT> ans = cost <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL>
n , m , x = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> ca = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ] <NEWLINE> <NL> res = float ( <STRING> ) <NEWLINE> <NL> for i in range ( 2 ** n ) : <NEWLINE> <INDENT> sc = 0 <NEWLINE> a = [ 0 ] * m <NEWLINE> for j in range ( n ) : <NEWLINE> <INDENT> if ( ( i >> j ) & 1 ) : <NEWLINE> <INDENT> sc = + ca [ j ] [ 0 ] <NEWLINE> a += ca [ j ] [ 1 : ] <NEWLINE> <DEDENT> <DEDENT> if min ( a ) >= x : <NEWLINE> <INDENT> res = min ( sc , res ) <NEWLINE> <NL> <DEDENT> <DEDENT> if res == INF : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( res ) <NEWLINE> <DEDENT>
from itertools import combinations <NEWLINE> <NL> N , M , X = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> A . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <DEDENT> sum = [ ] <NEWLINE> subsets = [ ] <NEWLINE> for i in range ( len ( A ) + 1 ) : <NEWLINE> <INDENT> for c in combinations ( A , i ) : <NEWLINE> <INDENT> subsets . append ( list ( c ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> for i in subsets : <NEWLINE> <INDENT> tmp = [ 0 ] * ( M + 1 ) <NEWLINE> if len ( i ) == 1 : <NEWLINE> <INDENT> sum . append ( i [ 0 ] ) <NEWLINE> <DEDENT> elif len ( i ) == 0 : <NEWLINE> <INDENT> sum . append ( [ 0 ] * ( M + 1 ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for j in i : <NEWLINE> <INDENT> tmp = list ( map ( lambda a , b : a + b , tmp , j ) ) <NEWLINE> <DEDENT> sum . append ( tmp ) <NEWLINE> <NL> <DEDENT> <DEDENT> min_price = 999999999999999 <NEWLINE> <NL> for i in sum : <NEWLINE> <INDENT> t = 0 <NEWLINE> for j in range ( len ( i ) ) : <NEWLINE> <INDENT> if j == 0 : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> elif X > i [ j ] : <NEWLINE> <INDENT> t = 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if t == 0 <NEWLINE> <INDENT> min_price = min ( min_price , i [ 0 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> if min_price == 999999999999999 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( min_price ) <NEWLINE> <DEDENT>
from itertools import product <NEWLINE> <NL> N , M , X = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( N ) ] <NEWLINE> ans = float ( <STRING> ) <NEWLINE> <NL> for now in product ( range ( 2 ) , N ) : <NEWLINE> <INDENT> res = 0 <NEWLINE> An = [ 0 for _ in range ( M ) ] <NEWLINE> for n in range ( N ) : <NEWLINE> <INDENT> if now [ n ] == 1 : <NEWLINE> <INDENT> res += A [ n ] [ 0 ] <NEWLINE> An = [ An [ j ] + A [ n ] [ j + 1 ] for j in range ( M ) ] <NEWLINE> <DEDENT> <DEDENT> if min ( An ) >= X : <NEWLINE> <INDENT> ans = min ( ans , res ) <NEWLINE> <NL> <DEDENT> <DEDENT> if ans == float ( <STRING> ) : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
n , m , x = map ( int , input ( ) . split ( ) ) <NEWLINE> costs = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ] <NEWLINE> <NL> <STRING> <NEWLINE> <NL> <NL> INF = 1000000000000000000000000000 <NEWLINE> ans = INF <NEWLINE> <NL> for i in range ( 1 << n ) : <COMMENT> <NEWLINE> <COMMENT> <NL> <INDENT> c = 0 <NEWLINE> sums = [ 0 ] * m <NEWLINE> for j in range ( n ) : <NEWLINE> <INDENT> if i >> j & 1 : <COMMENT> <NEWLINE> <COMMENT> <NL> <INDENT> c += costs [ j ] [ 0 ] <NEWLINE> for k in range ( m ) : <NEWLINE> <INDENT> sums [ k ] += costs [ j ] [ k + 1 ] <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <STRING> <NEWLINE> <NL> <INDENT> if min ( sums ) >= x : <NEWLINE> <INDENT> ans = min ( ans , c ) <NEWLINE> <NL> <DEDENT> <DEDENT> <STRING> <NEWLINE> ans = - 1 if ans == INF <NEWLINE> print ( ans ) <NEWLINE> <NL>
import itertools <NEWLINE> n , m , x = map ( in , input ( ) . split ( ) ) <NEWLINE> l = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( n ) ] <NEWLINE> costl = [ ] <NEWLINE> for p in itertools . product ( [ 0 , 1 ] , n ) : <NEWLINE> <INDENT> al = [ 0 ] * m <NEWLINE> cost = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if p [ i ] == 1 : <NEWLINE> <INDENT> cost += l [ i ] [ 0 ] <NEWLINE> for j in range ( 1 , m ) : <NEWLINE> <INDENT> al [ j - 1 ] += l [ i ] [ j ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if all ( mm >= x for mm in m ) : <NEWLINE> <INDENT> costl . append ( cost ) <NEWLINE> <DEDENT> <DEDENT> print ( min ( cost ) ) <NEWLINE> <NL> <NL>
import numpy as np <NEWLINE> n , m , x = map ( int , input ( ) . split ( ) ) <NEWLINE> a = 0 <NEWLINE> b = [ [ np . array ( list ( map ( int , input ( ) . split ( ) ) ) ) ] for i in range ( n ) ] <NEWLINE> for i in range ( 2 ** n ) : <NEWLINE> <INDENT> c = bin ( i ) <NEWLINE> c = <STRING> * ( n - len ( c ) ) + c <NEWLINE> l = np . zeros ( m ) <NEWLINE> q = 0 <NEWLINE> for j in range ( n ) : <NEWLINE> <INDENT> if c [ j ] == <STRING> : <NEWLINE> <INDENT> q += b [ j ] [ 0 ] <NEWLINE> l += b [ j ] <NEWLINE> <DEDENT> <DEDENT> if np . min ( l ) == x : <NEWLINE> <INDENT> a = min ( a , q ) <NEWLINE> <DEDENT> <DEDENT> if a : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <DEDENT>
n , k , x = ( int ( x ) for x in input ( ) . split ( ) ) <NEWLINE> C = [ ] <NEWLINE> A = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> list = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> C . append ( list [ 0 ] ) <NEWLINE> A . append ( list [ 1 : ] ) <NEWLINE> <DEDENT> i = 0 <NEWLINE> case = [ 0 ] * ( 2 ** n ) <NEWLINE> chk = [ ] <NEWLINE> for i in range ( 2 ** n ) : <NEWLINE> <INDENT> chk . append ( [ 0 ] * m ) <NEWLINE> <DEDENT> i = 0 <NEWLINE> for i in range ( 2 ** n ) : <NEWLINE> <INDENT> for j in range ( n ) : <COMMENT> <NEWLINE> <INDENT> if ( ( i >> j ) & 1 ) : <COMMENT> <NEWLINE> <INDENT> case [ i ] += C [ j ] <NEWLINE> for l in range ( m ) : <NEWLINE> <INDENT> chk [ i ] [ l ] += A [ j ] [ l ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> i = 0 <NEWLINE> j = 0 <NEWLINE> ans = [ ] <NEWLINE> flag = [ True ] * ( 2 ** n ) <NEWLINE> for i in range ( 2 ** n ) : <NEWLINE> <INDENT> for j in range ( m ) : <NEWLINE> <INDENT> if chk [ i ] [ j ] < x : <NEWLINE> <INDENT> flag [ i ] = False <NEWLINE> <DEDENT> <DEDENT> if flag [ i ] : <NEWLINE> <INDENT> ans . append ( case [ i ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> if ans == [ ] : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( min ( ans ) ) <NEWLINE> <DEDENT>
n , m , x = map ( int , input ( ) . split ( ) ) <NEWLINE> c = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> l = [ ] <NEWLINE> for i in range ( 2 ** n ) : <NEWLINE> <INDENT> l . append ( format ( i , <STRING> ) . zfill ( n ) ) <NEWLINE> <DEDENT> l1 = [ ] <NEWLINE> for i in range ( len ( l ) ) : <NEWLINE> <INDENT> s = [ 0 ] * ( m + 1 ) <NEWLINE> for j in range ( n ) : <NEWLINE> <INDENT> if l [ i ] [ j ] == <STRING> : <NEWLINE> <INDENT> for k in range ( m + 1 ) : <NEWLINE> <INDENT> s [ k ] += c [ j ] [ k ] <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for o in range ( 1 , m + 1 ) : <NEWLINE> <INDENT> if s [ o ] < x : break <NEWLINE> if o == m : l1 . append ( s [ 0 ] ) <NEWLINE> <DEDENT> <DEDENT> if len ( l1 ) == 0 : print ( - 1 ) <NEWLINE> else : print ( min ( l1 ) ) <NEWLINE>
n , m , x = map ( int , input ( ) . split ( ) ) <NEWLINE> c = [ [ 0 ] * m ] * n <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> c [ i ] = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <DEDENT> ans = 1000000 <NEWLINE> shoki = [ 0 ] * ( m + 1 ) <NEWLINE> <NL> <NL> <NL> def check ( xxx ) : <NEWLINE> <INDENT> tmp = 0 <NEWLINE> for i in range ( 1 , m ) : <NEWLINE> <INDENT> if x > xxx [ i ] : <NEWLINE> <INDENT> tmp = 1 <NEWLINE> <DEDENT> <DEDENT> if tmp == 0 : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return False <NEWLINE> <NL> <DEDENT> <DEDENT> def tashi ( g , h ) : <NEWLINE> <INDENT> shoki = [ 0 ] * ( m + 1 ) <NEWLINE> for i in range ( m + 1 ) : <NEWLINE> <INDENT> shoki [ i ] = g [ i ] + h [ i ] <NEWLINE> <DEDENT> return shoki <NEWLINE> <NL> <NL> <DEDENT> def aaa ( asum , b ) : <NEWLINE> <INDENT> if check ( asum ) : <NEWLINE> <INDENT> ans = min ( ans , asum [ 0 ] ) <NEWLINE> return True <NEWLINE> <DEDENT> if b == n : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> if aaa ( asum , b + 1 ) : <NEWLINE> <INDENT> return check ( asum ) <NEWLINE> <DEDENT> if aaa ( tashi ( asum , c [ b ] ) , b + 1 ) : <NEWLINE> <INDENT> return check ( asum ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if aaa ( shoki , 0 ) : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT>
import itertools <NEWLINE> import numpy as np <NEWLINE> <NL> N , M , X = map ( int , input ( ) . split ( ) ) <NEWLINE> lis_all = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( N ) ] <NEWLINE> <NL> lis_C = np . array ( list ( map ( lambda x : x [ 0 ] , lis_all ) ) ) <NEWLINE> lis_A = np . array ( list ( map ( lambda x : x [ 1 : ] , lis_all ) ) ) <NEWLINE> <NL> row_idx = [ ] <NEWLINE> bools = [ True , False ] <NEWLINE> for boollis in itertools . product ( bools , repeat = M ) : <NEWLINE> <INDENT> row_idx . append ( list ( boollis ) ) <NEWLINE> <NL> <DEDENT> c_min = lis_C . sum ( ) + 100 <NEWLINE> for i in range ( len ( lis_idx ) ) : <NEWLINE> <INDENT> if all ( lis_A [ row_idx [ i ] ] . sum ( axis = 0 ) >= X ) : <NEWLINE> <INDENT> c_min = min ( lis_C [ row_idx [ 1 ] ] . sum ( ) , c_min ) <NEWLINE> <DEDENT> <DEDENT> if c_min > lis_C . sum ( ) : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = c_min <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
ef can_reach_the_goal ( u , x ) : <NEWLINE> <INDENT> return min ( u ) >= x <NEWLINE> <NL> <DEDENT> n , m , x = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> c = [ ] <NEWLINE> a = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ca = [ int ( row ) for row in input ( ) . split ( ) ] <NEWLINE> c . append ( ca [ 0 ] ) <NEWLINE> a . append ( ca [ 1 : ] ) <NEWLINE> <NL> <DEDENT> INF = 10 ** 7 <NEWLINE> min_cost = INF <NEWLINE> for k in range ( 2 ** n ) : <NEWLINE> <INDENT> purchase = [ True if c == <STRING> else False for c in list ( format ( k , <STRING> . format ( n ) ) ) ] <NEWLINE> cost = 0 <NEWLINE> u = [ 0 ] * m <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> cost += c [ i ] if purchase [ i ] else 0 <NEWLINE> for j in range ( m ) : <NEWLINE> <INDENT> u [ j ] += a [ i ] [ j ] if purchase [ i ] else 0 <NEWLINE> <NL> <DEDENT> <DEDENT> if can_reach_the_goal ( u , x ) and cost < min_cost : <NEWLINE> <INDENT> min_cost = cost <NEWLINE> <NL> <DEDENT> <DEDENT> if min_cost == INF : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( min_cost ) <NEWLINE> <DEDENT>
N , M , X = map ( int , input ( ) . split ( ) ) <NEWLINE> book_information = [ ] <NEWLINE> result = 12 * 10 ** 5 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> book_information . append ( input ( ) ) <NEWLINE> <DEDENT> for i in range ( 1 , 1 << N ) : <NEWLINE> <INDENT> bought_book = [ ] <NEWLINE> n = 0 <NEWLINE> skill = [ 0 for j in range ( M ) ] <NEWLINE> for j in range ( N ) : <NEWLINE> <INDENT> if ( i >> j ) & 1 : <NEWLINE> <INDENT> bought_book . append ( book_information [ j - 1 ] ) <NEWLINE> n += 1 <NEWLINE> <DEDENT> <DEDENT> for j in range ( n - 1 ) : <NEWLINE> <INDENT> bought_book_information = list ( map ( bought_book [ j ] . split ( <STRING> ) ) ) <NEWLINE> cost += bought_book_information [ 0 ] <NEWLINE> for k in range ( M ) : <NEWLINE> <INDENT> skill [ k ] += bought_book_information [ k + 1 ] <NEWLINE> <DEDENT> <DEDENT> if all ( x >= X for x in skill ) : <NEWLINE> <INDENT> result = min ( result , cost ) <NEWLINE> <DEDENT> <DEDENT> if result == 12 * 10 ** 5 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( result ) <NEWLINE> <DEDENT>
<COMMENT> <NL> n , m , x = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> import sys <NEWLINE> ca = [ [ int ( c ) for c in l . split ( ) ] for l in sys . stdin ] <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> c = [ ] <NEWLINE> a = [ ] <NEWLINE> for l in range ( n ) : <NEWLINE> <INDENT> c . append ( ca [ l ] [ 0 ] ) <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> for l in range ( n ) : <NEWLINE> <INDENT> del ca [ l ] [ 0 ] <NEWLINE> <COMMENT> <NL> <DEDENT> a = ca <NEWLINE> <NL> INF = float ( <STRING> ) <NEWLINE> min_cost = INF <NEWLINE> <NL> def dfs ( i , cost , learn ) : <NEWLINE> <INDENT> if i == n : <NEWLINE> <INDENT> if min ( learn ) >= x : <NEWLINE> <INDENT> return cost <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return INF <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> new_learn = [ X + Y for ( X , Y ) in zip ( a [ i ] , learn ) ] <NEWLINE> cost = min ( dfs ( i + 1 , cost , learn ) , dfs ( i + 1 , cost + C [ i ] , new_learn ) ) <NEWLINE> return cost <NEWLINE> <NL> <DEDENT> <DEDENT> min_cost = dfs ( 0 , 0 , [ 0 ] * m ) <NEWLINE> <NL> if min_cost == INF : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( min_cost ) <NEWLINE> <NL> <NL> <DEDENT>
import numpy as np <NEWLINE> from itertools import combinations_with_replacement <NEWLINE> <NL> N , M , X = map ( int , input ( ) . split ( ) ) <NEWLINE> CA = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> CA . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> <DEDENT> OK = True <NEWLINE> CA = np . array ( CA ) <NEWLINE> sums = np . sum ( CA , axis = 0 ) <NEWLINE> for i in range ( 1 , M + 1 ) : <NEWLINE> <INDENT> if sums [ i ] < X : <NEWLINE> <INDENT> OK = False <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if OK == False : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <INDENT> min_ = sums [ 0 ] <NEWLINE> hoge = [ ] <NEWLINE> kouho = list ( range ( 1 , N + 1 ) ) <NEWLINE> for i in itertools . combinations_with_replacement ( kouho , N ) : <NEWLINE> <INDENT> hoge . append ( list ( set ( i ) ) ) <NEWLINE> <DEDENT> hoge = list ( map ( list , set ( map ( tuple , hoge ) ) ) ) <NEWLINE> for i in hoge : <NEWLINE> <INDENT> mini_CA = [ ] <NEWLINE> for j in i : <NEWLINE> <INDENT> mini_CA . append ( CA [ j ] ) <NEWLINE> <DEDENT> mini_CA = np . array ( mini_CA ) <NEWLINE> OK2 = True <NEWLINE> sums = np . sum ( mini_CA , axis = 0 ) <NEWLINE> for k in range ( 1 , M + 1 ) : <NEWLINE> <INDENT> if sums [ k ] < X : <NEWLINE> <INDENT> OK2 = False <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if OK2 == True and sums [ 0 ] < min_ : <NEWLINE> <INDENT> min_ = sums [ 0 ] <NEWLINE> <DEDENT> <DEDENT> print ( min_ ) <NEWLINE> <DEDENT>
C = [ ] <NEWLINE> A = [ ] <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> C . append ( l [ 0 ] ) <NEWLINE> A . append ( np . array ( l [ 1 : ] ) ) <NEWLINE> <DEDENT> ans = 10 ** 100 <NEWLINE> for i in range ( 2 ** N ) : <NEWLINE> <INDENT> rikaido = np . zeros ( M ) <NEWLINE> c = 0 <NEWLINE> for j in range ( N ) : <NEWLINE> <INDENT> if ( i >> j ) & 1 : <NEWLINE> <INDENT> c += C [ j ] <NEWLINE> rikaido += A [ j ] <NEWLINE> <DEDENT> <DEDENT> if all ( [ x >= X for x in rikaido ] ) : <NEWLINE> <INDENT> ans = min ( ans , c ) <NEWLINE> <DEDENT> <DEDENT> print ( ans if ans != 10 ** 100 else - 1 ) <NEWLINE>
import itertools <NEWLINE> min_price = 10 ** 9 <NEWLINE> for k in range ( n ) : <NEWLINE> <INDENT> for comb in itertools . combinations ( range ( m ) , k + 1 ) : <NEWLINE> <INDENT> sums = [ 0 ] * m <NEWLINE> price = 0 <NEWLINE> for c in comb : <NEWLINE> <INDENT> price += C [ c ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> sums [ i ] += A [ c ] [ i ] <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> if sum ( [ y >= x for y in sums ] ) == len ( A ) : <NEWLINE> <INDENT> min_price = min ( min_price , price ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if min_price == 10 ** 9 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( min_price ) <NEWLINE> <DEDENT>
N , M , X = map ( int , input ( ) . split ( ) ) <NEWLINE> List = [ list ( map ( int , input ( ) . split ( ) ) ) for n in range ( N ) ] <NEWLINE> INF = 10 ** 7 <NEWLINE> ans = INF <NEWLINE> C_pro = list ( itertools . product ( [ 0 , 1 ] , repeat = N ) ) <NEWLINE> <NL> for c_pro in C_pro : <NEWLINE> <INDENT> count = 0 <NEWLINE> cost = 0 <NEWLINE> ans_list = [ 0 for i in range ( M ) ] <NEWLINE> for c in c_pro : <NEWLINE> <INDENT> if c == 1 : <NEWLINE> <INDENT> cost += List [ count ] [ 0 ] <NEWLINE> ans_list = [ ans + list for ans , list in zip ( ans_list , List [ count ] [ 1 : ] ) ] <NEWLINE> <DEDENT> count += 1 <NEWLINE> <DEDENT> if ans_list >= [ X for i in range ( M ) ] : <NEWLINE> <INDENT> ans = min ( ans , cost ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if ans == INF : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
CA = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( N ) ] <NEWLINE> <NL> A = [ 0 ] * M <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> for k in range ( M ) : <NEWLINE> <INDENT> A [ k ] += CA [ i ] [ k + 1 ] <NEWLINE> <DEDENT> <DEDENT> for i in range ( M ) : <NEWLINE> <INDENT> if A [ i ] < X : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> price = 0 <NEWLINE> ans = 10 ** 10 <NEWLINE> A = [ 0 ] * M <NEWLINE> for i in range ( 2 ** N ) : <NEWLINE> <INDENT> list = [ 1 ] * N <NEWLINE> for j in range ( len ( list ) ) : <NEWLINE> <INDENT> if ( i >> j ) & 1 : <NEWLINE> <INDENT> list [ j ] = 0 <NEWLINE> <DEDENT> for k in range ( N ) : <NEWLINE> <INDENT> if list [ k ] == 1 : <NEWLINE> <INDENT> for s in range ( M ) : <NEWLINE> <INDENT> A [ s ] += CA [ k ] [ s + 1 ] <NEWLINE> <DEDENT> price += CA [ k ] [ 0 ] <NEWLINE> <DEDENT> <DEDENT> if all ( A [ m ] >= X for m in range ( M ) ) : <NEWLINE> <INDENT> ans = min ( ans , price ) <NEWLINE> <DEDENT> <DEDENT> price = 0 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import numpy as np <NEWLINE> n , M , X = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> CA = [ ] <NEWLINE> A = [ ] <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> L = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> CA . append ( L [ : ] ) <NEWLINE> <DEDENT> ans = np . zeros ( M + 1 ) <NEWLINE> <NL> S = [ 0 ] * n <NEWLINE> ANS = list ( ) <NEWLINE> def makeCombination ( ) : <NEWLINE> <INDENT> for i in range ( 0 , n - 1 ) : <NEWLINE> <INDENT> S [ i ] = 0 <NEWLINE> <DEDENT> rec ( 0 , ans ) <NEWLINE> <DEDENT> def rec ( i , ans ) : <NEWLINE> <INDENT> if i == n : <NEWLINE> <INDENT> if all ( ans [ 1 : ] >= X ) == True : <NEWLINE> <INDENT> ANS . append ( ans [ 0 ] ) <NEWLINE> <DEDENT> return <NEWLINE> <DEDENT> rec ( i + 1 , ans ) <NEWLINE> S [ i ] = 1 <NEWLINE> ans = ans + np . array ( CA [ i ] ) <NEWLINE> rec ( i + 1 , ans ) <NEWLINE> S [ i ] = 0 <NEWLINE> <DEDENT> makeCombination ( ) <NEWLINE> ANS . sort ( ) <NEWLINE> if len ( ANS ) >= 1 : <NEWLINE> <INDENT> print ( ANS [ 0 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT>
N , M , X = map ( int , input ( ) . split ( ) ) <NEWLINE> C = [ 0 for i in range ( N ) ] <NEWLINE> A = [ [ ] for i in range ( N ) ] <NEWLINE> min_cost = 10000000000 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> C [ i ] , * A [ i ] = map ( int , input ( ) . split ( ) ) <NEWLINE> <DEDENT> for i in range ( 1 << N ) : <NEWLINE> <INDENT> L = [ 0 for i in range ( M ) ] <NEWLINE> cost = 0 <NEWLINE> for j in range ( N ) : <NEWLINE> <INDENT> if 1 & ( i >> j ) : <NEWLINE> <INDENT> for k in range ( M ) : <NEWLINE> <INDENT> L [ k ] += A [ j ] [ k ] <NEWLINE> <DEDENT> cost += C [ j ] <NEWLINE> <DEDENT> <DEDENT> if min ( L ) >= X : <NEWLINE> <INDENT> min_cost = min ( min_cost , cost ) <NEWLINE> <DEDENT> <DEDENT> if min_cost = 10000000000 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( min_cost ) <NEWLINE> <DEDENT>
import itertools <NEWLINE> n , m , x = map ( int , input ( ) . split ( ) ) <NEWLINE> l = [ [ 0 ] ] * n <NEWLINE> ln = [ 0 ] * m <NEWLINE> kan = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> l [ i ] = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for j in range ( m + 1 ) : <NEWLINE> <INDENT> if j == 0 : <NEWLINE> <INDENT> kan += l [ i ] [ j ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ln [ j - 1 ] += l [ i ] [ j ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if sorted ( ln ) [ 0 ] < x : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> mkan = - 1 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> itr = itertools . combinations ( range ( n ) , i ) <NEWLINE> for comb in itr : <NEWLINE> <INDENT> kan = 0 <NEWLINE> ln = [ 0 ] * m <NEWLINE> for j in comb : <NEWLINE> <INDENT> kan += l [ int ( j ) ] [ 0 ] <NEWLINE> for ii in range ( m ) : <NEWLINE> <INDENT> ln [ ii ] += l [ int ( j ) ] [ ii + 1 ] <NEWLINE> <DEDENT> <DEDENT> if sorted ( ln ) >= x : <NEWLINE> <INDENT> if mkan == - 1 or mkan > kan : <NEWLINE> <INDENT> mkan = kan <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( mkan ) <NEWLINE> <DEDENT>
n , m , x = map ( int , input ( ) . split ( ) ) <NEWLINE> result = 10 ** 9 <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> books = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A = A . append ( books [ 0 ] ) <NEWLINE> C = C . append ( books [ 1 : ] ) <NEWLINE> <DEDENT> for i in range ( 1 << n ) : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> rikaido = [ 0 ] * m <NEWLINE> for j in range ( n ) : <NEWLINE> <INDENT> if ( i << j ) & 1 : <NEWLINE> <INDENT> for k in range ( m ) : <NEWLINE> <INDENT> rikaido [ k ] += C [ j ] [ k ] <NEWLINE> <DEDENT> cnt += A [ j ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> <DEDENT> if min ( rikaido ) >= x : <NEWLINE> <INDENT> result = min ( result , cnt ) <NEWLINE> <DEDENT> <DEDENT> if result == 10 * 9 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( result ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> x , m , n = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> acq2 = 0 <NEWLINE> cost = [ ] <NEWLINE> skill = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ca = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> cost . append ( ca [ 0 ] ) <NEWLINE> skill . append ( np . array ( ca [ 1 : ] ) ) <NEWLINE> <NL> <DEDENT> costmin = 0 <NEWLINE> for a in range ( n ) : <NEWLINE> <INDENT> costmin += cost [ a ] <NEWLINE> <NL> <DEDENT> def tworaw ( num ) : <NEWLINE> <INDENT> if ( num % 2 == 0 ) : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return 1 <NEWLINE> <NL> <DEDENT> <DEDENT> for j in range ( 2 ** n ) : <NEWLINE> <INDENT> buy = [ ] <NEWLINE> cost_temp = 0 <NEWLINE> skill_temp = np . zeros ( m ) <NEWLINE> acq = 1 <NEWLINE> nn = j <NEWLINE> for k in range ( n ) : <NEWLINE> <INDENT> buy . append ( tworaw ( nn ) ) <NEWLINE> nn = nn // 2 <NEWLINE> <NL> <DEDENT> for l in range ( n ) : <NEWLINE> <INDENT> if ( buy [ l ] == 1 ) : <NEWLINE> <INDENT> cost_temp += cost [ l ] <NEWLINE> skill_temp += skill [ l ] <NEWLINE> <NL> <DEDENT> <DEDENT> for b in range ( m ) : <NEWLINE> <INDENT> if ( skill_temp [ b ] < x ) : <NEWLINE> <INDENT> acq = 0 <NEWLINE> break <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if ( acq == 1 ) : <NEWLINE> <INDENT> acq2 = 1 <NEWLINE> if ( cost_temp < costmin ) : <NEWLINE> <INDENT> costmin = cost_temp <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> if ( acq2 == 1 ) : <NEWLINE> <INDENT> print ( int ( costmin ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n , m , x = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c = [ ] <NEWLINE> a = [ ] <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> tmp = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c . append ( tmp [ 0 ] ) <NEWLINE> a . append ( [ ] ) <NEWLINE> <NL> for j in range ( m ) : <NEWLINE> <INDENT> a [ i ] . append ( tmp [ j ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> ab = [ ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> sum = 0 <NEWLINE> for j in range ( n ) : <NEWLINE> <INDENT> sum += a [ j ] [ i ] <NEWLINE> <DEDENT> ab . append ( bool ( sum > x ) ) <NEWLINE> <NL> <DEDENT> print ( all [ ab ] ) <NEWLINE>
import numpy as np <NEWLINE> from itertools import combinations_with_replacement <NEWLINE> <NL> N , M , X = map ( int , input ( ) . split ( ) ) <NEWLINE> CA = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> CA . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> <DEDENT> OK = True <NEWLINE> CA = np . array ( CA ) <NEWLINE> sums = np . sum ( CA , axis = 0 ) <NEWLINE> for i in range ( 1 , M + 1 ) : <NEWLINE> <INDENT> if sums [ i ] < X : <NEWLINE> <INDENT> OK = False <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if OK == False : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> As = [ ] <NEWLINE> for A in combinations_with_replacement ( range ( 0 , N ) , N ) : <NEWLINE> <INDENT> As . append ( tuple ( set ( A ) ) ) <NEWLINE> <DEDENT> print ( As ) <NEWLINE> As = list ( map ( list , set ( As ) ) ) <NEWLINE> min_ = sums [ 0 ] <NEWLINE> for i in hoge : <NEWLINE> <INDENT> mini_CA = [ ] <NEWLINE> for j in i : <NEWLINE> <INDENT> mini_CA . append ( CA [ j ] ) <NEWLINE> <DEDENT> mini_CA = np . array ( mini_CA ) <NEWLINE> OK2 = True <NEWLINE> sums = np . sum ( mini_CA , axis = 0 ) <NEWLINE> for k in range ( 1 , M + 1 ) : <NEWLINE> <INDENT> if sums [ k ] < X : <NEWLINE> <INDENT> OK2 = False <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if OK2 == True and sums [ 0 ] < min_ : <NEWLINE> <INDENT> min_ = sums [ 0 ] <NEWLINE> <DEDENT> <DEDENT> print ( min_ ) <NEWLINE> <DEDENT>
n , m , x = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ [ ] for _ in range ( n ) ] <NEWLINE> cost = [ 0 ] * n <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> c_as = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> cost [ i ] , A [ i ] = c_as [ 0 ] , c_as [ 1 : ] <NEWLINE> <DEDENT> INF = 10 ** 9 <NEWLINE> ans = INF <NEWLINE> for s in range ( 0 , 1 << n ) : <NEWLINE> <INDENT> smart = [ 0 ] * m <NEWLINE> cost_sum = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if ( s >> i ) % 2 == 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> cost_sum += c [ i ] <NEWLINE> for j in range ( m ) : <NEWLINE> <INDENT> smart [ j ] += A [ i ] [ j ] <NEWLINE> <DEDENT> <DEDENT> ok = True <NEWLINE> for j in range ( m ) : <NEWLINE> <INDENT> if smart [ j ] < x : <NEWLINE> <INDENT> ok = False <NEWLINE> <DEDENT> <DEDENT> if ok : <NEWLINE> <INDENT> ans = min ( ans , cost_sum ) <NEWLINE> <DEDENT> <DEDENT> if ans == INF : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
from itertools import product <NEWLINE> N , M , X = map ( int , input ( ) . split ( ) ) <NEWLINE> ca = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( N ) ] <NEWLINE> for i in range ( 1 , M + 1 ) : <NEWLINE> <INDENT> count = 0 <NEWLINE> for j in range ( N ) : <NEWLINE> <INDENT> count += ca [ j ] [ i ] <NEWLINE> <DEDENT> if count < X : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> ans = 10 ** 9 <NEWLINE> for z in product ( ( 0 , 1 ) , repeat = N ) : <COMMENT> <NEWLINE> <INDENT> count = 0 <NEWLINE> count2 = [ 0 ] * M <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if z [ i ] == 1 : <NEWLINE> <INDENT> count += ca [ i ] [ 0 ] <NEWLINE> for j in range ( 1 , M + 1 ) : <NEWLINE> <INDENT> count2 [ j - 1 ] += ca [ i ] [ j ] <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for i in range ( m ) : <NEWLINE> <INDENT> if count2 [ i ] < x : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> ans = min ( count , ans ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n , m , x = [ * map ( int , input ( ) . split ( ) ) ] <NEWLINE> k = [ ] <NEWLINE> ans = 10 ** 6 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> c , * a = [ * map ( int , input ( ) . split ( ) ) ] <NEWLINE> s += c <NEWLINE> k . append ( [ c , * a ] ) <NEWLINE> <NL> <DEDENT> for i in range ( 2 ** n ) : <NEWLINE> <INDENT> cost = 0 <NEWLINE> skills = [ 0 ] * m <NEWLINE> for j in range ( n ) : <NEWLINE> <INDENT> if ( ( i >> j ) & 1 ) : <NEWLINE> <INDENT> cost += k [ j ] [ 0 ] <NEWLINE> for s , t in enumerate ( k [ j ] [ 1 : ] ) : <NEWLINE> <INDENT> skills [ s ] += t <NEWLINE> <DEDENT> if all ( map ( lambda skill : skill >= x , skills ) ) : <NEWLINE> <INDENT> ans = min ( ans , cost ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( - 1 if ans == 10 ** 6 else ans ) <NEWLINE>
n , m , x = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A . sort ( key = lambda x : x [ 0 ] ) <NEWLINE> money = 0 <NEWLINE> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> c = A [ i ] [ 0 ] <NEWLINE> a = A [ i ] [ 1 : ] <NEWLINE> aa = min ( a ) <NEWLINE> money += c <NEWLINE> ans += aa <NEWLINE> if ans >= x : <NEWLINE> <INDENT> print ( money ( ) ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( - 1 ) <NEWLINE>
<NL> n , m , x = [ int ( e ) for e in input ( ) . split ( ) ] <NEWLINE> <NL> import numpy as np <NEWLINE> <NL> all = np . zeros ( n * ( m + 1 ) ) . reshape ( n , m + 1 ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> all [ i ] += [ int ( e ) for e in input ( ) . split ( ) ] <NEWLINE> <NL> <DEDENT> bool_list = np . array ( [ ] ) <NEWLINE> a = [ ] <NEWLINE> b = [ ] <NEWLINE> def make ( n ) : <NEWLINE> <INDENT> if len ( a ) == n : <NEWLINE> <INDENT> b . append ( [ 0 for _ in range ( n ) ] ) <NEWLINE> for i , v in enumerate ( a ) : <NEWLINE> <INDENT> if v == True : <NEWLINE> <INDENT> b [ - 1 ] [ i ] = True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> b [ - 1 ] [ i ] = False <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for i in [ True , False ] : <NEWLINE> <INDENT> a . append ( i ) <NEWLINE> make ( n ) <NEWLINE> a . pop ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> make ( n ) <NEWLINE> c = np . array ( b ) <NEWLINE> <NL> dp = [ 10 ** 10 ] <NEWLINE> <NL> for i in c : <NEWLINE> <INDENT> if all [ i ] [ : , 1 ] . sum ( axis = 0 ) >= x : <NEWLINE> <INDENT> dp = min ( dp , all [ i ] [ : , 0 ] . sum ( axis = 0 ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> if dp == [ 10 ** 10 ] : <NEWLINE> <INDENT> dp = [ - 1 ] <NEWLINE> <DEDENT> print ( int ( dp [ 0 ] ) ) <NEWLINE>
n , m , x = map ( int , input ( ) . split ( ) ) <NEWLINE> arr = [ [ 0 for i in range ( m + 1 ) ] for j in range ( n ) ] <NEWLINE> b = [ 0 ] * 18 <NEWLINE> <NL> flag = 1 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> arr [ i ] = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <DEDENT> for i in range ( 2 ** n ) : <NEWLINE> <INDENT> b = [ 0 ] * 18 <NEWLINE> for j in range ( n ) : <NEWLINE> <INDENT> flag = 1 <NEWLINE> if ( 1 & i >> j ) : <NEWLINE> <INDENT> for s in range ( m + 1 ) : <NEWLINE> <INDENT> b [ s ] = b [ s ] + arr [ j ] [ s ] <NEWLINE> <DEDENT> <DEDENT> for y in range ( 1 , m + 1 ) : <NEWLINE> <INDENT> if ( b [ y ] < x ) : <NEWLINE> <INDENT> flag = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> if flag : <NEWLINE> <INDENT> if ans == - 1 or ans > b [ 0 ] : <NEWLINE> <INDENT> ans = b [ 0 ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from itertools import product <NEWLINE> <NL> N , M , X = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> C = [ ] <NEWLINE> A = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> t = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> C . append ( t [ 0 ] ) <NEWLINE> A . append ( t [ 1 : ] ) <NEWLINE> <NL> <DEDENT> result = float ( <STRING> ) <NEWLINE> for p in product ( [ True , False ] , N ) : <NEWLINE> <INDENT> t = [ 0 ] * M <NEWLINE> c = 0 <NEWLINE> for j in range ( N ) : <NEWLINE> <INDENT> if not p [ j ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> c += C [ j ] <NEWLINE> for k in range ( M ) : <NEWLINE> <INDENT> t [ k ] += A [ j ] [ k ] <NEWLINE> <DEDENT> <DEDENT> if all ( x >= X for x in t ) : <NEWLINE> <INDENT> result = min ( result , c ) <NEWLINE> <DEDENT> <DEDENT> print ( result ) <NEWLINE>
import numpy as np <NEWLINE> import itertools <NEWLINE> <NL> n , m , x = map ( int , input ( ) . split ( ) ) <NEWLINE> calist = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ca = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> calist . append ( ca ) <NEWLINE> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <DEDENT> for j in range ( m ) : <NEWLINE> <INDENT> sum = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> sum += calist [ i ] [ j + 1 ] <NEWLINE> <DEDENT> if sum < x : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> calist = np . array ( calist ) <NEWLINE> dp = float ( <STRING> ) <NEWLINE> <NL> for comb in range ( 1 , m + 1 ) : <NEWLINE> <INDENT> sc = itertools . combinations ( calist , comb ) <NEWLINE> sum = 0 <NEWLINE> a = np . array ( [ 0 for _ in range ( m ) ] ) <NEWLINE> for ca in sc : <NEWLINE> <INDENT> sum += ca [ 0 ] <NEWLINE> a += ca [ 1 : ] <NEWLINE> <DEDENT> if False not in ( a > x ) and sum < dp : <NEWLINE> <INDENT> dp = sum <NEWLINE> <NL> <DEDENT> <DEDENT> print ( dp ) <NEWLINE>
N , M , X = map ( int , input ( ) . split ( ) ) <NEWLINE> C = [ ( list ( map ( int , input ( ) . split ( ) ) ) ) for _ in range ( N ) ] <NEWLINE> <NL> <COMMENT> <NL> ans = 10 ** 10 <NEWLINE> for i in range ( 2 ** N ) : <NEWLINE> <INDENT> U = [ 0 ] * ( M + 1 ) <NEWLINE> for j in range ( N ) : <NEWLINE> <INDENT> if ( ( i >> j ) & 1 ) : <NEWLINE> <INDENT> for k in range ( M + 1 ) : <NEWLINE> <INDENT> U [ k ] += C [ j ] [ k ] <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> if sum ( [ u >= X for u in U [ 1 : ] ] ) == M : <NEWLINE> <INDENT> ans = min ( ans , U [ 0 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> if ans = 10 ** 10 : print ( - 1 ) <NEWLINE> else : print ( ans ) <NEWLINE>
def resolve ( ) : <NEWLINE> <INDENT> N , M , X = map ( int , input ( ) . split ( ) ) <NEWLINE> CA = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( N ) ] <NEWLINE> mxc = float ( <STRING> ) <NEWLINE> for r in range ( N + 1 ) : <NEWLINE> <INDENT> for cmb in itt . combinations ( CA , r ) : <NEWLINE> <INDENT> cost = 0 <NEWLINE> tbl = [ 0 ] * M <NEWLINE> for x in cmb : <NEWLINE> <INDENT> cost += x [ 0 ] <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> tbl [ i ] += x [ i + 1 ] <NEWLINE> <NL> <DEDENT> <DEDENT> for i in tbl : <NEWLINE> <INDENT> if i < X : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> mxc = min ( cost , mxc ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if mxc == float ( <STRING> ) : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( mxc ) <NEWLINE> <NL> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> resolve ( ) <NEWLINE> <DEDENT>
N , M , X = map ( int , input ( ) . split ( ) ) <NEWLINE> Q = [ ] <NEWLINE> B = [ 0 ] * N <NEWLINE> C = [ 0 ] * ( M + 1 ) <NEWLINE> flag = True <NEWLINE> MIN = - 1 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> Q . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> <DEDENT> for i in range ( 2 ** N ) : <NEWLINE> <INDENT> B = [ 0 ] * N <NEWLINE> C = [ 0 ] * ( M + 1 ) <NEWLINE> flag = True <NEWLINE> for j in range ( N ) : <NEWLINE> <INDENT> B [ j ] = ( i >> j ) & 1 <NEWLINE> <NL> <DEDENT> for j in range ( N ) : <NEWLINE> <INDENT> if B [ j ] == 1 : <NEWLINE> <INDENT> for k in range ( M + 1 ) : <NEWLINE> <INDENT> C [ k ] += Q [ j ] [ k ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> for j in range ( 1 , M + 1 ) : <NEWLINE> <INDENT> if C [ j ] < X : <NEWLINE> <INDENT> flag = False <NEWLINE> <DEDENT> if flag == True : <NEWLINE> <INDENT> if MIN == - 1 or MIN > C [ 0 ] : <NEWLINE> <INDENT> MIN = C [ 0 ] <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( MIN ) <NEWLINE> N , M , X = map ( int , input ( ) . split ( ) ) <NEWLINE> Q = [ ] <NEWLINE> B = [ 0 ] * N <NEWLINE> C = [ 0 ] * ( M + 1 ) <NEWLINE> flag = True <NEWLINE> MIN = - 1 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> Q . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> <DEDENT> for i in range ( 2 ** N ) : <NEWLINE> <INDENT> B = [ 0 ] * N <NEWLINE> C = [ 0 ] * ( M + 1 ) <NEWLINE> flag = True <NEWLINE> for j in range ( N ) : <NEWLINE> <INDENT> B [ j ] = ( i >> j ) & 1 <NEWLINE> <NL> <DEDENT> for j in range ( N ) : <NEWLINE> <INDENT> if B [ j ] == 1 : <NEWLINE> <INDENT> for k in range ( M + 1 ) : <NEWLINE> <INDENT> C [ k ] += Q [ j ] [ k ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> for j in range ( 1 , M + 1 ) : <NEWLINE> <INDENT> if C [ j ] < X : <NEWLINE> <INDENT> flag = False <NEWLINE> <DEDENT> if flag == True and ( MIN == - 1 or MIN > C [ 0 ] ) : <NEWLINE> <INDENT> MIN = C [ 0 ] <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( MIN ) <NEWLINE>
<COMMENT> <NL> <NL> N , M , X = map ( int , input ( ) . split ( ) ) <NEWLINE> items = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( N ) ] <NEWLINE> ans = - 1 <NEWLINE> for i in range ( 1 << N ) : <NEWLINE> <INDENT> total = [ 0 ] * ( M + 1 ) <NEWLINE> for j in range ( N ) : <NEWLINE> <INDENT> if ( ( i >> j ) & 1 ) : <COMMENT> <NEWLINE> <INDENT> h = [ x + y for ( x , y ) in zip ( total , items [ j ] ) ] <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> if all ( k >= X for k in h [ 1 : ] ) == True : <NEWLINE> <INDENT> if ans == - 1 : <NEWLINE> <INDENT> ans = h [ 0 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = min ( ans , total [ 0 ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL>
n , m , x = map ( int , input ( ) . split ( ) ) <NEWLINE> ca = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ] <NEWLINE> <NL> <COMMENT> <NL> most_row_price = 10 ** 10 <NEWLINE> for i in range ( 2 ** n ) : <NEWLINE> <INDENT> comb = str ( bin ( i ) [ 2 : ] ) . zfill ( n ) <NEWLINE> <NL> <COMMENT> <NL> money_per_pattern = [ 0 ] * n <COMMENT> <NEWLINE> total_money = 0 <COMMENT> <NEWLINE> for j in range ( n ) : <NEWLINE> <NL> <COMMENT> <NL> <INDENT> if comb [ j ] == <STRING> : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> total_money += ca [ j ] [ 0 ] <NEWLINE> <NL> <COMMENT> <NL> for k in range ( m ) : <NEWLINE> <INDENT> understanding [ k ] += ca [ j ] [ k + 1 ] <NEWLINE> <NL> <DEDENT> <DEDENT> for j in range ( m ) : <NEWLINE> <INDENT> if understanding [ j ] < x : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> most_row_price = min ( total_money , most_row_price ) <NEWLINE> <NL> <DEDENT> <DEDENT> if most_row_price == 10 ** 10 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( most_row_price ) <NEWLINE> <DEDENT>
a , b , import numpy as np <NEWLINE> import itertools <NEWLINE> n , m , x = map ( int , input ( ) . split ( ) ) <NEWLINE> a = np . dot ( [ i for i in itertools . product ( [ 0 , 1 ] , repeat = n ) ] , <NEWLINE> <INDENT> [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ] ) <NEWLINE> <DEDENT> b = np . prod ( a [ : , 1 : ( m + 1 ) ] >= x , axis = 1 , dtype = bool ) <NEWLINE> print ( min ( a [ : , 0 ] [ b ] ) if b . sum ( ) else <STRING> ) <NEWLINE>
import numpy as np <NEWLINE> <NL> N , M , X = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> data = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( N ) ] <NEWLINE> INF = float ( <STRING> ) <NEWLINE> <NL> data_all = [ ] <NEWLINE> c_min = INF <NEWLINE> <NL> for i in range ( 2 ** N ) : <NEWLINE> <INDENT> data_tmp = [ 0 ] * M <NEWLINE> c = 0 <NEWLINE> for j in range ( N ) : <NEWLINE> <INDENT> if ( ( i >> j ) & 1 ) : <NEWLINE> <INDENT> for k in range ( M ) : <NEWLINE> <INDENT> data_tmp [ k ] += data [ j ] [ k + 1 ] <NEWLINE> <DEDENT> c += data [ j ] [ 0 ] <NEWLINE> <DEDENT> <DEDENT> if ( min ( data_tmp ) >= X ) : <NEWLINE> <INDENT> c_min = min ( c , c_min ) <NEWLINE> <NL> <DEDENT> <DEDENT> if ( c_min == INF ) : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( c_min ) <NEWLINE> <NL> <NL> <NL> <DEDENT>
nmx = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> N = nmx [ 0 ] <NEWLINE> M = nmx [ 1 ] <NEWLINE> X = nmx [ 2 ] <NEWLINE> mylist = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> mylist . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <DEDENT> Ans = 10000 * 12 + 1 <NEWLINE> for i in range ( 2 ** N ) : <NEWLINE> <INDENT> A = [ [ 0 ] * M ] <NEWLINE> C = 0 <NEWLINE> for j in range ( N ) : <NEWLINE> <INDENT> if ( i >> j ) & 1 : <NEWLINE> <INDENT> C += mylist [ j ] [ 0 ] <NEWLINE> for k in range ( M ) : <NEWLINE> <INDENT> A [ k ] = A [ k ] + mylist [ j ] [ k + 1 ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if min ( A ) >= X : <NEWLINE> <COMMENT> <NL> <DEDENT> if Ans == 10000 * 12 + 1 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( Ans ) <NEWLINE> <NL> <DEDENT>
def solve ( i , cost , know , x , a ) : <NEWLINE> <INDENT> global res <NEWLINE> if i == len ( a ) : <NEWLINE> <INDENT> for j in range ( m ) : <NEWLINE> <INDENT> if know [ j ] < x : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> <DEDENT> res = min ( res , cost ) <NEWLINE> return <NEWLINE> <DEDENT> solve ( i + 1 , cost , know , x , a ) <NEWLINE> for j in range ( m ) : <NEWLINE> <INDENT> know [ j ] += a [ i ] [ j + 1 ] <NEWLINE> <DEDENT> solve ( i + 1 , cost + a [ i ] [ 0 ] , know , x , a ) <NEWLINE> for j in range ( m ) : <NEWLINE> <INDENT> know [ j ] -= a [ i ] [ j + 1 ] <NEWLINE> <DEDENT> <DEDENT> fin = open ( <STRING> , <STRING> ) <NEWLINE> n , m , x = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> a = [ [ int ( i ) for i in input ( ) . split ( ) ] for j in range ( n ) ] <NEWLINE> know = [ 0 ] * ( m ) <NEWLINE> res = 10 ** 7 <NEWLINE> solve ( 0 , 0 , know , x , a ) <NEWLINE> print ( res if res != 10 ** 7 else - 1 ) <NEWLINE>
if __name__ == <STRING> : <NEWLINE> <INDENT> n , m , x = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> c = [ ] <NEWLINE> a = [ ] <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> c_temp , * a_temp = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c . append ( c_temp ) <NEWLINE> a . append ( a_temp ) <NEWLINE> <NL> <DEDENT> INF = float ( <STRING> ) <NEWLINE> ans = INF <NEWLINE> <NL> for bit in range ( 1 << n ) : <NEWLINE> <INDENT> price = calc_price ( bit ) <NEWLINE> ans = min ( ans , price ) <NEWLINE> <NL> <DEDENT> if ans == INF : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> <DEDENT> def calc_price ( bit ) : <NEWLINE> <INDENT> price_total = 0 <NEWLINE> learn_total = [ 0 ] * m <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> if ( bit >> i ) & 1 : <NEWLINE> <INDENT> price_total += c [ i ] <NEWLINE> learn = a [ i ] <NEWLINE> for j , la in enumerate ( learn ) : <NEWLINE> <INDENT> learn_total [ j ] += la <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> if check ( learn_total ) : <NEWLINE> <INDENT> return price_total <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return INF <NEWLINE> <NL> <DEDENT> <DEDENT> def check ( learn_total ) : <NEWLINE> <INDENT> for i in range ( m ) : <NEWLINE> <INDENT> if learn_total [ i ] < x : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> <DEDENT> return True <NEWLINE> <DEDENT>
import itertools <NEWLINE> n , m , x = map ( int , input ( ) . split ( ) ) <NEWLINE> l = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( n ) ] <NEWLINE> sum = [ 0 ] * m <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( 1 , m + 2 ) : <NEWLINE> <INDENT> sum [ j ] += l [ i ] [ j ] <NEWLINE> <DEDENT> <DEDENT> for ss in sum : <NEWLINE> <INDENT> if ss < x : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> list = [ ] <NEWLINE> for p in itertools . product ( [ 1 , 0 ] , n ) <NEWLINE> <INDENT> cnt = [ 0 ] * m <NEWLINE> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if p [ i ] == 1 : <NEWLINE> <INDENT> ans += l [ i ] [ 0 ] <NEWLINE> list . append ( ans ) <NEWLINE> for j in range ( 1 , m + 1 ) <NEWLINE> <INDENT> cnt [ j ] += l [ i ] [ j ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( min ( list ) ) <NEWLINE>
import itertools as it <NEWLINE> <NL> N , M , X = map ( int , input ( ) . split ( ) ) <NEWLINE> book = [ [ int ( _ ) for _ in input ( ) . split ( ) ] for i in range ( N ) ] <NEWLINE> <NL> combs = it . product ( [ 0 , 1 ] , repeat = N ) <NEWLINE> prices = [ ] <NEWLINE> for comb in combs : <NEWLINE> <COMMENT> <NL> <INDENT> bag = [ 0 ] * M + 1 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if comb [ i ] == 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for j in range ( M + 1 ) : <NEWLINE> <INDENT> bag [ j ] += book [ i ] [ j ] <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if min ( bag [ 1 : ] ) < X : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> prices . append ( bag [ 0 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> if len ( prices ) == 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( min ( prices ) ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> min_cost = 12 * 10 ** 5 <NEWLINE> <NL> <NL> def dfs ( CA , cost , skills , cur , used , min_cost ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <INDENT> skills = [ skills [ i ] + n for i , n in enumerate ( CA [ cur ] [ 1 : ] ) ] <NEWLINE> used += [ cur ] <NEWLINE> cost += CA [ cur ] [ 0 ] <NEWLINE> <NL> if all ( [ s >= X for s in skills ] ) : <NEWLINE> <INDENT> return cost <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> candidates = [ n for n in range ( N ) if n not in used ] <NEWLINE> prev_used = used <NEWLINE> prev_skills = skills <NEWLINE> prev_cost = cost <NEWLINE> for i in candidates : <NEWLINE> <INDENT> min_cost = min ( min_cost , dfs ( CA , prev_cost , prev_skills , i , prev_used , min_cost ) ) <NEWLINE> <DEDENT> <DEDENT> return min_cost <NEWLINE> <NL> <NL> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> Pdb ( ) . set_trace ( ) <NEWLINE> used = [ ] <NEWLINE> cost = 0 <NEWLINE> skills = [ 0 ] * M <NEWLINE> min_cost = min ( min_cost , dfs ( CA , cost , skills , i , used , min_cost ) ) <NEWLINE> <NL> <DEDENT> print ( min_cost ) <NEWLINE>
N , M , X = map ( int , input ( ) . split ( ) ) <NEWLINE> book = [ [ map ( int , input ( ) . split ( ) ) ] for i in range ( N ) ] <NEWLINE> <NL> min_value = - 1 <NEWLINE> for i in range ( 2 ** N ) : <NEWLINE> <INDENT> sum = [ 0 for k in range ( M + 1 ) ] <NEWLINE> for j in range ( N ) : <NEWLINE> <INDENT> if ( i >> j ) & 1 : <NEWLINE> <INDENT> sum = [ x + y for x , y in zip ( sum , book [ N + 1 ] ) ] <NEWLINE> <DEDENT> <DEDENT> if min ( sum [ 1 : ] ) >= X and min_value > sum [ 0 ] : <NEWLINE> <INDENT> min_value = sum [ 0 ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( min_value ) <NEWLINE>
import numpy as np <COMMENT> <NEWLINE> import itertools <NEWLINE> <NL> val = input ( ) <NEWLINE> val = val . split ( <STRING> ) <NEWLINE> val = [ int ( i ) for i in val ] <COMMENT> <NEWLINE> <NL> I = np . zeros ( ( val [ 0 ] , val [ 1 ] + 1 ) ) <NEWLINE> <NL> for i in range ( val [ 0 ] ) : <NEWLINE> <INDENT> val2 = input ( ) <NEWLINE> val2 = val2 . split ( <STRING> ) <NEWLINE> val2 = [ int ( i ) for i in val2 ] <COMMENT> <NEWLINE> I [ i ] = val2 <NEWLINE> <NL> <DEDENT> seq = [ i for i in range ( val [ 0 ] ) ] <COMMENT> <NEWLINE> print ( seq ) <NEWLINE> <NL> for i in range ( val [ 0 ] ) : <NEWLINE> <INDENT> Comb = list ( itertools . combinations ( seq , i + 1 ) ) <NEWLINE> <COMMENT> <NL> for j in Comb : <NEWLINE> <INDENT> Com_list = list ( j ) <NEWLINE> <COMMENT> <NL> I_sum = [ [ I [ k ] [ l + 1 ] for k in Com_list ] for l in range ( val [ 1 ] ) ] <NEWLINE> print ( I_sum ) <NEWLINE> ans = [ sum ( i ) for m in I_sum ] <NEWLINE> print ( <STRING> , ans ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> <DEDENT>
import numpy as np <NEWLINE> N , M , X = map ( int , input ( ) . split ( ) ) <NEWLINE> allList = [ ] <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> allList . append ( np . array ( list ( map ( int , input ( ) . split ( ) ) ) ) ) <NEWLINE> <DEDENT> minnum = 10 ** 7 <NEWLINE> for i in range ( 2 ** N ) : <NEWLINE> <INDENT> skill = [ 0 ] * ( M + 1 ) <NEWLINE> flag = True <NEWLINE> for row in range ( N ) : <NEWLINE> <INDENT> if i & ( 2 ** row ) > 0 : <NEWLINE> <INDENT> skill += allList [ row ] <NEWLINE> <DEDENT> <DEDENT> for i in range ( M ) : <NEWLINE> <INDENT> if skill [ j + 1 ] < X : <NEWLINE> <INDENT> flag = False <NEWLINE> <DEDENT> <DEDENT> if flag : <NEWLINE> <INDENT> minnum = min ( minnum , skill [ 0 ] ) <NEWLINE> <DEDENT> <DEDENT> if minnum == 10 ** 7 : <NEWLINE> <INDENT> minnum = - 1 <NEWLINE> <DEDENT> print ( minnum ) <NEWLINE>
import numpy as np <NEWLINE> <NL> N , M , X = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> ca = [ ] <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> ca . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <DEDENT> ca . sort ( key = lambda x : - x [ 0 ] ) <NEWLINE> ca = np . array ( ca ) <NEWLINE> <COMMENT> <NL> ans = 10000000 <NEWLINE> skill = [ 0 ] * ( M + 1 ) <NEWLINE> <NL> <NL> def DFS ( n , skill ) : <NEWLINE> <INDENT> global ans <NEWLINE> if skill [ 0 ] >= ans : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> if min ( skill [ 1 : ] ) >= X : <NEWLINE> <INDENT> ans = min ( ans , skill [ 0 ] ) <NEWLINE> return <NEWLINE> <DEDENT> if n >= N : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> DFS ( n + 1 , skill ) <NEWLINE> skill = skill + ca [ n ] <NEWLINE> DFS ( n + 1 , s ) <NEWLINE> skill = skill - ca [ n ] <NEWLINE> return <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> DFS ( 0 , skill ) <NEWLINE> if ans == 10000000 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <COMMENT> <NL> <NEWLINE> <DEDENT>
<COMMENT> <NL> import numpy as np <NEWLINE> <NL> N , M , X = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> a . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> <DEDENT> suma = sum ( a [ 0 ] [ ] ) <NEWLINE> print ( suma , a ) <NEWLINE>
<COMMENT> <NL> import numpy as np <NEWLINE> flg = True <NEWLINE> n , m , x = map ( int , input ( ) . split ( ) ) <NEWLINE> algo = [ ] <NEWLINE> tmp = [ ] <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> algo . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> <DEDENT> book = list ( itertools . product ( [ 0 , 1 ] , repeat = n ) ) <NEWLINE> abi = [ 0 for _ in range ( m ) ] <NEWLINE> <NL> for pattern in book : <NEWLINE> <COMMENT> <NL> <INDENT> abi = [ 0 for _ in range ( m ) ] <NEWLINE> money = 0 <NEWLINE> flg = True <NEWLINE> <NL> for i in range ( len ( pattern ) ) : <NEWLINE> <INDENT> for j in range ( m ) : <NEWLINE> <INDENT> abi [ j ] += algo [ i ] [ j + 1 ] * pattern [ i ] <NEWLINE> <DEDENT> money += algo [ i ] [ 0 ] * pattern [ i ] <NEWLINE> <NL> <DEDENT> abi_min = [ p for p in abi if p < x ] <NEWLINE> <NL> if len ( abi_min ) != 0 : <NEWLINE> <INDENT> flg = False <NEWLINE> <DEDENT> if flg : <NEWLINE> <INDENT> print ( money ) <NEWLINE> tmp . append ( money ) <NEWLINE> <NL> <DEDENT> <DEDENT> if len ( tmp ) > 0 : <NEWLINE> <INDENT> print ( min ( tmp ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <NL> <NL> <NL> <NL> <NL> <DEDENT>
n , m , x = map ( int , input ( ) . split ( ) ) <NEWLINE> ca = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ] <NEWLINE> c = [ ca [ i ] [ 0 ] for i in range ( n ) ] <NEWLINE> a = [ ca [ i ] [ 1 : ] for i in range ( n ) ] <NEWLINE> l = 0 <NEWLINE> ans = sum ( c ) <NEWLINE> for i in range ( 2 ** n ) : <NEWLINE> <INDENT> get = [ 0 ] * m <NEWLINE> kari = 0 3 <NEWLINE> for j in range ( n ) : <NEWLINE> <INDENT> if ( i >> j ) & 1 : <COMMENT> <NEWLINE> <INDENT> get = [ x + y for ( x , y ) in zip ( get , a [ j ] ) ] <NEWLINE> kari += c [ j ] <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> if all ( [ k >= x for k in get ] ) : <NEWLINE> <INDENT> ans = min ( ans , kari ) <NEWLINE> l += 1 <NEWLINE> <DEDENT> <DEDENT> if l == 0 : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
from itertools import combinations <NEWLINE> import numpy as np <NEWLINE> <NL> N , M , X = map ( int , input ( ) . split ( ) ) <NEWLINE> list_ = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( N ) ] <NEWLINE> gokei = X <NEWLINE> cost = 100001 <NEWLINE> list_C = [ ] <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> list_C = np . array ( list ( combinations ( list_ , N - i ) ) ) <NEWLINE> count = 0 <NEWLINE> for h in range ( len ( list_C ) ) : <NEWLINE> <NL> <INDENT> if all ( np . sum ( list_C [ h ] , axis = 0 ) [ 1 : ] >= X ) and np . sum ( list_C [ h ] , axis = 0 ) [ 0 ] < cost : <NEWLINE> <INDENT> cost = np . sum ( list_C [ h ] , axis = 0 ) [ 0 ] <NEWLINE> count += 1 <NEWLINE> <NL> <DEDENT> if count == 0 : <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( cost if cost < 100001 else - 1 ) <NEWLINE>
A , B , C , K = ( int ( x ) for x in input ( ) . split ( ) ) <NEWLINE> <NL> if ( K <= A + B ) : <NEWLINE> <INDENT> print ( A ) <NEWLINE> <DEDENT> if ( K > A + B ) : <NEWLINE> <INDENT> print ( A - ( K - A - B ) ) <NEWLINE> <DEDENT>
n , m , X = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> C = [ ] <NEWLINE> A = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> t = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> C . append ( t [ 0 ] ) <COMMENT> <NEWLINE> A . append ( t [ 1 : ] ) <COMMENT> <NEWLINE> <NL> <DEDENT> result = - 1 <COMMENT> <NEWLINE> <COMMENT> <NL> for i in range ( 1 << n ) : <COMMENT> <NEWLINE> <INDENT> t = [ 0 ] * m <COMMENT> <NEWLINE> c = 0 <COMMENT> <NEWLINE> <COMMENT> <NL> for j in range ( n ) : <NEWLINE> <INDENT> if ( i >> j ) & 1 : <COMMENT> <NEWLINE> <INDENT> for k in range ( m ) : <NEWLINE> <INDENT> t [ k ] += A [ j ] [ k ] <COMMENT> <NEWLINE> <DEDENT> c += C [ j ] <COMMENT> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> <DEDENT> if min ( t ) >= x : <NEWLINE> <INDENT> result == min ( result , t ) <NEWLINE> <DEDENT> <DEDENT> if result == 10 ** 9 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( result ) <NEWLINE> <DEDENT>
n , m , x = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> book = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> book . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <DEDENT> ans = 10 ** 5 * n <NEWLINE> for i in product ( [ 0 , 1 ] , repeat = n ) : <NEWLINE> <INDENT> price = 0 <NEWLINE> skill = [ 0 ] * m <NEWLINE> for index_ , bit in enumerate ( i ) : <NEWLINE> <INDENT> if bit : <NEWLINE> <INDENT> for j in range ( m ) : <NEWLINE> <INDENT> skill [ j ] += book [ index_ ] [ j + 1 ] <NEWLINE> price += book [ index_ ] [ 0 ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if all ( v >= x for v in skill ) : <NEWLINE> <INDENT> ans = min ( ans , price ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
A , B , C , K = map ( int , input ( ) . split ( ) ) <NEWLINE> if K <= A : <NEWLINE> <INDENT> print ( K ) <NEWLINE> <DEDENT> elif A <= K <= A + B : <NEWLINE> <INDENT> print ( A ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( A - ( K - A - B ) ) <NEWLINE> <NL> <NL> <NL> <NL> <DEDENT> N , M , X = map ( int , input ( ) . split ( ) ) <NEWLINE> CA_array = list ( ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> CA_list = [ int ( e ) for e in input ( ) . split ( ) ] <NEWLINE> CA_array . append ( CA_list ) <NEWLINE> <NL> <DEDENT> ans = 13 * ( 10 ** 5 ) <NEWLINE> <NL> <COMMENT> <NL> for i in range ( 2 ** ( N ) ) : <COMMENT> <NEWLINE> <INDENT> bit_array = str ( bin ( i ) [ 2 : ] ) . zfill ( ( N ) ) <NEWLINE> <COMMENT> <NL> <NL> CA_on_bit_array = [ 0 for _ in range ( M + 1 ) ] <NEWLINE> <NL> for j in range ( len ( bit_array ) ) : <COMMENT> <NEWLINE> <NL> <INDENT> if bit_array [ j ] == <STRING> : <NEWLINE> <COMMENT> <NL> <INDENT> pass <NEWLINE> <DEDENT> elif bit_array [ j ] == <STRING> : <NEWLINE> <COMMENT> <NL> <INDENT> for k in range ( M + 1 ) : <COMMENT> <NEWLINE> <INDENT> CA_on_bit_array [ k ] += CA_array [ j ] [ k ] <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> for k in range ( 1 , M + 1 ) : <NEWLINE> <INDENT> if CA_on_bit_array [ k ] < X : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if CA_on_bit_array [ 0 ] < ans : <NEWLINE> <INDENT> ans = CA_on_bit_array [ 0 ] <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if ans != 13 * ( 10 ** 5 ) : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT>
import itertools <NEWLINE> import sys <NEWLINE> read = sys . stdin . buffer . read <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> readlines = sys . stdin . buffer . readlines <NEWLINE> <NL> n , m , x = map ( int , readline ( ) . split ( ) ) <NEWLINE> c = [ list ( map ( int , readline ( ) . split ( ) ) ) for _ in range ( n ) ] <NEWLINE> <NL> ans = 10 ** 9 + 7 <NEWLINE> for l in list ( itertools . product ( [ 0 , 1 ] , repeat = n ) ) : <NEWLINE> <INDENT> cart = [ 0 ] * ( m + 1 ) <NEWLINE> for i , a in enumerate ( l ) : <NEWLINE> <INDENT> if a == 1 : <NEWLINE> array = c [ i ] <NEWLINE> cart = list ( map ( lambda x , y : x + y , cart , array ) ) <NEWLINE> <DEDENT> if min ( cart [ 1 : : ] ) >= x : <NEWLINE> <INDENT> ans = min ( ans , cart [ 0 ] ) <NEWLINE> <DEDENT> <DEDENT> print ( ans if ans != 10 ** 9 + 7 else <STRING> ) <NEWLINE>
N , M , X = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> AC = [ ] <NEWLINE> C = [ ] <NEWLINE> A = [ ] <NEWLINE> for n in range ( N ) : <NEWLINE> <INDENT> AC . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> C . append ( AC [ 0 ] ) <NEWLINE> A . append ( AC [ 1 : ] ) <NEWLINE> <DEDENT> ans = 0 <NEWLINE> for n in range ( 2 ** N ) : <NEWLINE> <INDENT> total = 0 <NEWLINE> und = [ 0 ] * M <NEWLINE> for j in range ( N ) : <NEWLINE> <INDENT> if n >> j & 1 : <NEWLINE> <INDENT> total += C [ j ] <NEWLINE> for m in range ( M ) : <NEWLINE> <INDENT> und [ m ] += A [ j ] [ m ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if X <= min ( und ) : <NEWLINE> <INDENT> ans = total <NEWLINE> <DEDENT> <DEDENT> if ans == 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
n , m , x = map ( int , input ( ) . split ( ) ) <NEWLINE> books = [ 0 ] * n <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> books [ i ] = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> <NL> <DEDENT> ans = 10 ** 9 <NEWLINE> for i in range ( 2 ** n ) : <NEWLINE> <INDENT> cost = 0 <NEWLINE> point = [ 0 ] * m <NEWLINE> for j in range ( n ) : <NEWLINE> <INDENT> if ( i >> j ) & 1 : <NEWLINE> <INDENT> for k in range ( 1 , m + 1 ) : <NEWLINE> <INDENT> point [ k - 1 ] += books [ j ] [ k ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> flag = True <NEWLINE> for j in range ( m ) : n , m , x = map ( int , input ( ) . split ( ) ) <NEWLINE> <DEDENT> books = [ 0 ] * n <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> books [ i ] = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> <NL> <DEDENT> ans = 10 ** 9 <NEWLINE> for i in range ( 2 ** n ) : <NEWLINE> <INDENT> cost = 0 <NEWLINE> point = [ 0 ] * m <NEWLINE> for j in range ( n ) : <NEWLINE> <INDENT> if ( i >> j ) & 1 : <NEWLINE> <INDENT> cost += books [ j ] [ 0 ] <NEWLINE> for k in range ( 1 , m + 1 ) : <NEWLINE> <INDENT> point [ k - 1 ] += books [ j ] [ k ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> flag = True <NEWLINE> for j in range ( m ) : <NEWLINE> <INDENT> if point [ j ] < x : <NEWLINE> <INDENT> flag = False <NEWLINE> <DEDENT> <DEDENT> if flag and ans > cost : <NEWLINE> <INDENT> ans = cost <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans if ans != 10 ** 9 else - 1 ) <NEWLINE> <INDENT> if point [ j ] < x : <NEWLINE> <INDENT> flag = False <NEWLINE> if flag and ans > cost : <NEWLINE> <DEDENT> ans = cost <NEWLINE> <NL> <DEDENT> print ( ans if ans != 10 ** 9 else - 1 ) <NEWLINE>
import numpy as np <NEWLINE> import itertools <NEWLINE> <NL> N , M , X = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> Arr = np . zeros ( ( N , M + 1 ) ) <NEWLINE> List = np . zeros ( M ) <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> Arr [ i ] = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <DEDENT> for j in range ( M ) : <NEWLINE> <INDENT> List [ j ] = np . sum ( Arr [ : , j ] ) <NEWLINE> <NL> <DEDENT> if np . any ( List < 10 ) : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> List = sorted ( List ) <NEWLINE> for i in range ( N + 1 ) : <NEWLINE> <INDENT> for team in itertools . combinations ( List , i ) : <NEWLINE> <INDENT> Sum = np . sum ( Arr [ team , : ] ) <NEWLINE> if np . all ( Sum >= 10 ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT>
import itertools <NEWLINE> <NL> N , M , X = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( N ) ] <NEWLINE> <NL> for x in itertools . product ( [ 0 , 1 ] , repeat = 2 ) : <NEWLINE> <INDENT> cost = 0 <NEWLINE> level = [ ] * M <NEWLINE> judge = True <NEWLINE> ans = 1234567 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if a [ i ] == 1 : <NEWLINE> <INDENT> cost += a [ i ] [ 0 ] <NEWLINE> level = [ y + z for ( y , z ) in zip ( level , a [ i ] [ 1 : ] ) ] <NEWLINE> <DEDENT> <DEDENT> for j in range ( M ) : <NEWLINE> <INDENT> if any ( level [ k ] < x for k in range ( M ) ) : <NEWLINE> <INDENT> judge = False <NEWLINE> <DEDENT> <DEDENT> if judge : <NEWLINE> <INDENT> ans = min ( ans , cost ) <NEWLINE> <NL> <DEDENT> <DEDENT> if ans == 1234567 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> import itertools <NEWLINE> N , M , X = map ( int , input ( ) . split ( ) ) <NEWLINE> kumi = [ ] <NEWLINE> pat = list ( range ( N ) ) <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> kumi . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <DEDENT> ans0 = 10 ** 5 * 12 + 1 <NEWLINE> ans = 10 ** 5 * 12 + 1 <NEWLINE> <COMMENT> <NL> test = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> for i2 in itertools . combinations ( kumi , i + 1 ) : <NEWLINE> <INDENT> arr_i2 = np . array ( i2 ) <NEWLINE> arr_i2_sum = arr_i2 . sum ( axis = 0 ) <NEWLINE> if np . all ( arr_i2_sum [ 1 : ] >= X ) : <NEWLINE> <INDENT> if ans > arr_i2_sum [ 0 ] : <NEWLINE> <INDENT> ans = arr_i2_sum [ 0 ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if ans == ans0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) import numpy as np <NEWLINE> <DEDENT> import itertools <NEWLINE> N , M , X = map ( int , input ( ) . split ( ) ) <NEWLINE> kumi = [ ] <NEWLINE> pat = list ( range ( N ) ) <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> kumi . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <DEDENT> ans0 = 10 ** 5 * 12 + 1 <NEWLINE> ans = 10 ** 5 * 12 + 1 <NEWLINE> <COMMENT> <NL> test = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> for i2 in itertools . combinations ( kumi , i + 1 ) : <NEWLINE> <INDENT> arr_i2 = np . array ( i2 ) <NEWLINE> arr_i2_sum = arr_i2 . sum ( axis = 0 ) <NEWLINE> if np . all ( arr_i2_sum [ 1 : ] >= X ) : <NEWLINE> <INDENT> if ans > arr_i2_sum [ 0 ] : <NEWLINE> <INDENT> ans = arr_i2_sum [ 0 ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if ans == ans0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
import itertools <NEWLINE> <NL> N , M , X = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> A = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> A . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> <DEDENT> saisyo = float ( <STRING> ) <NEWLINE> for i in intertools . product ( range ( 2 ) , N ) : <NEWLINE> <INDENT> a = [ 0 ] * M <NEWLINE> gokei = 0 <NEWLINE> for j in range ( N ) : <NEWLINE> <INDENT> if i [ j ] == 1 : <NEWLINE> <INDENT> gokei += A [ j ] [ 0 ] <NEWLINE> for k in range ( 1 , M + 1 ) : <NEWLINE> <INDENT> a [ k - 1 ] += A [ j ] [ k ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if min ( a ) >= X : <NEWLINE> <INDENT> saisyo = min ( saisyo , gokei ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( saisyo if saisyo != float ( <STRING> ) else - 1 ) <NEWLINE>
import itertools <NEWLINE> import numpy as np <NEWLINE> <NL> N , M , X = map ( int , input ( ) . split ( ) ) <NEWLINE> lista = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( N ) ] <NEWLINE> <NL> lista = np . array ( lista ) <NEWLINE> judge = [ X ] * M <NEWLINE> cost = 1200001 <NEWLINE> data = [ a for a in range ( 1 , N + 1 ) ] <COMMENT> <NEWLINE> <NL> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> j = list ( itertools . combinations ( data , i ) ) <NEWLINE> for k in j : <NEWLINE> <INDENT> result = np . array ( [ 0 ] * ( M + 1 ) ) <NEWLINE> for l in k : <NEWLINE> <INDENT> result = result + lista [ l - 1 ] <NEWLINE> if all ( result [ 1 : ] >= judge ) : <NEWLINE> <INDENT> if reslut [ 0 ] < cost : <NEWLINE> <INDENT> cost = result [ 0 ] <NEWLINE> m = k <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> c = 0 <NEWLINE> <NL> try : <NEWLINE> <INDENT> for i in m : <NEWLINE> <INDENT> c += lista [ i - 1 ] [ 0 ] <NEWLINE> <NL> <DEDENT> print ( c ) <NEWLINE> <NL> <DEDENT> except : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> N , M , X = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> books = np . array ( [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( N ) ] ) <NEWLINE> <NL> min_total_cost = 10 ** 9 <NEWLINE> <NL> for i in range ( 2 ** N ) : <NEWLINE> <INDENT> to_read_indexes = np . array ( list ( str ( i ) ) , dtype = int ) <NEWLINE> to_read_books = books [ to_read_indexes , : ] <NEWLINE> total_cost = to_read_books [ : , 0 ] . sum ( ) <NEWLINE> increased_levels = to_read_books [ : , 1 : ] . sum ( axis = 0 ) <NEWLINE> <NL> if min ( increased_levels ) >= X : <NEWLINE> <INDENT> min_total_cost = min ( min_total_cost , total_cost ) <NEWLINE> <NL> <DEDENT> <DEDENT> if min_total_cost == 10 ** 9 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( min_total_cost ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N , M , X = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> A . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> <DEDENT> pr = 10 ** 9 <NEWLINE> for s in range ( 2 ** N ) : <NEWLINE> <INDENT> x_m = [ 0 ] * 13 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> b = ( s >> i ) & 1 <NEWLINE> if b == 1 : <NEWLINE> <INDENT> pr_s += A [ i ] [ 0 ] <NEWLINE> for j in range ( M + 1 ) : <NEWLINE> <INDENT> x_m [ j ] += A [ i ] [ j ] <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> xOk = True <NEWLINE> for j in range ( 1 , M + 1 ) : <NEWLINE> <INDENT> if x_m [ j ] < X : <NEWLINE> <INDENT> xOk = False <NEWLINE> <NL> <DEDENT> <DEDENT> if xOk == True : <NEWLINE> <INDENT> pr = min ( pr , x_m [ 0 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> if pr < 10 ** 9 : <NEWLINE> <INDENT> print ( pr ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> n , m , x = map ( int , input ( ) . split ( ) ) <NEWLINE> c = [ ] <NEWLINE> a = [ ] <NEWLINE> ans = 10 ** 6 <NEWLINE> for x in range ( n ) : <NEWLINE> <INDENT> line = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c . append ( line [ 0 ] ) <NEWLINE> a . append ( line [ 1 : ] ) <NEWLINE> <DEDENT> a = np . array ( a ) <NEWLINE> for i in range ( 2 ** n ) : <NEWLINE> <INDENT> level = np . zeros ( m ) <NEWLINE> price = 0 <NEWLINE> for j in range ( n ) : <NEWLINE> <INDENT> if ( ( i >> j ) & 1 ) : <NEWLINE> <INDENT> level += a [ j ] <NEWLINE> price += c [ j ] <NEWLINE> <DEDENT> <DEDENT> for k in range ( m ) : <NEWLINE> <INDENT> if np . amin ( level ) >= x and price <= ans : <NEWLINE> <INDENT> ans = price <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if ans == 10 ** 6 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> from itertools import combinations_with_replacement <NEWLINE> <NL> N , M , X = map ( int , input ( ) . split ( ) ) <NEWLINE> CA = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> CA . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> <DEDENT> OK = True <NEWLINE> CA = np . array ( CA ) <NEWLINE> sums = np . sum ( CA , axis = 0 ) <NEWLINE> for i in range ( 1 , M + 1 ) : <NEWLINE> <INDENT> if sums [ i ] < X : <NEWLINE> <INDENT> OK = False <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if OK == False : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> As = [ ] <NEWLINE> for A in combinations_with_replacement ( range ( 0 , N ) , N ) : <NEWLINE> <INDENT> As . append ( tuple ( set ( A ) ) ) <NEWLINE> <DEDENT> As = list ( map ( list , set ( As ) ) ) <NEWLINE> min_ = sums [ 0 ] <NEWLINE> for i in hoge : <NEWLINE> <INDENT> mini_CA = [ ] <NEWLINE> for j in i : <NEWLINE> <INDENT> mini_CA . append ( CA [ j - 1 ] ) <NEWLINE> <DEDENT> mini_CA = np . array ( mini_CA ) <NEWLINE> OK2 = True <NEWLINE> sums = np . sum ( mini_CA , axis = 0 ) <NEWLINE> for k in range ( 1 , M + 1 ) : <NEWLINE> <INDENT> if sums [ k ] < X : <NEWLINE> <INDENT> OK2 = False <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if OK2 == True and sums [ 0 ] < min_ : <NEWLINE> <INDENT> min_ = sums [ 0 ] <NEWLINE> <DEDENT> <DEDENT> print ( min_ ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <NL> from itertools import product <NEWLINE> <NL> n , m , x = map ( int , input ( ) . split ( ) ) <NEWLINE> costs = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ] <NEWLINE> <NL> INF = 1000000000000000000000000000 <NEWLINE> ans = INF <NEWLINE> <NL> <NL> lists = list ( product ( list ( range ( 2 ) ) , repeat = n ) ) <NEWLINE> for v in lists : <NEWLINE> <STRING> <NEWLINE> <INDENT> c = 0 <NEWLINE> sums = [ 0 ] * m <NEWLINE> for j in range ( n ) : <NEWLINE> <INDENT> if v [ j ] == 1 : <NEWLINE> <STRING> <NEWLINE> <COMMENT> <NL> <INDENT> c += costs [ j ] [ 0 ] <NEWLINE> for k in range ( m ) : <NEWLINE> <INDENT> sums [ k ] += costs [ j ] [ k + 1 ] <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> if min ( sums ) >= x : <COMMENT> <NEWLINE> <INDENT> ans = min ( ans , c ) <NEWLINE> <DEDENT> <STRING> <NEWLINE> <NL> <NL> <DEDENT> if ans == INF : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
from itertools import combinations <NEWLINE> n , m , x = map ( int , input ( ) . split ( ) ) <NEWLINE> ca = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 10 ** 9 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> for j in combinations ( ca , i ) : <NEWLINE> <INDENT> s = [ 0 ] * ( m + 1 ) <NEWLINE> for k in j : <NEWLINE> <INDENT> for l in range ( m + 1 ) : <NEWLINE> <INDENT> s [ l ] += k [ l ] <NEWLINE> <DEDENT> <DEDENT> if min ( s [ 1 : ] ) <= x : <NEWLINE> <INDENT> ans += min ( ans , s [ 0 ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if ans == 10 ** 9 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
N , M , X = map ( int , input ( ) . split ( ) ) <NEWLINE> C = [ 0 ] * N <NEWLINE> AA = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( N ) ] <NEWLINE> for i in range ( len ( AA ) ) : <NEWLINE> <INDENT> C [ i ] = AA [ i ] [ 0 ] <NEWLINE> A [ i ] = AA [ i ] [ 1 : ] <NEWLINE> <DEDENT> ans = sum ( C ) + 1 <NEWLINE> for p in range ( 2 ** N ) : <NEWLINE> <INDENT> Y = [ 0 ] * M <NEWLINE> cnt = 0 <NEWLINE> for i , c in enumerate ( C ) : <NEWLINE> <INDENT> if p % 2 == 1 : <NEWLINE> <INDENT> cnt += c <NEWLINE> for j , a in enumerate ( A [ i ] ) : <NEWLINE> <INDENT> Y [ j ] += a <NEWLINE> <DEDENT> <DEDENT> p //= 2 <NEWLINE> <DEDENT> ans = min ( ans , cnt ) if min ( Y ) >= X else ans <NEWLINE> <DEDENT> print ( ans if ans <= sum ( C ) else - 1 ) <NEWLINE>
N , M , X = map ( int , input ( ) . split ( ) ) <NEWLINE> l = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> l . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <DEDENT> ans = 10000000 <NEWLINE> for i in range ( 2 ** N ) : <NEWLINE> <INDENT> score = [ 0 ] * M <NEWLINE> coin = 0 <NEWLINE> for j in range ( N ) : <NEWLINE> <INDENT> if i >= 2 ** ( N - 1 - j ) : <NEWLINE> <INDENT> for p in range ( M ) : <NEWLINE> <INDENT> score [ p ] += l [ j ] [ p + 1 ] <NEWLINE> <DEDENT> coin += l [ j ] [ 0 ] <NEWLINE> i -= 2 ** ( N - 1 - j ) <NEWLINE> <DEDENT> <DEDENT> flag = 0 <NEWLINE> for q in range ( M ) : <NEWLINE> <INDENT> if score [ q ] < X : <NEWLINE> <INDENT> flag = 1 <NEWLINE> <DEDENT> <DEDENT> if flag == 0 : <NEWLINE> <INDENT> if ans > coin : <NEWLINE> <INDENT> ans = coin <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if ans = 10000000 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> from itertools import product <NEWLINE> INF = 10 ** 9 <NEWLINE> <NL> N , M , X = map ( int , input ( ) . split ( ) ) <NEWLINE> C = [ None ] * N <NEWLINE> A = [ None ] * N <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> line = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> C [ i ] = line [ 0 ] <NEWLINE> A [ i ] = np . array ( line [ 1 : ] ) <NEWLINE> <NL> <DEDENT> choose = [ True , False ] <NEWLINE> <NL> min_price = INF <NEWLINE> <NL> for s in product ( [ True , False ] , repeat = N ) : <NEWLINE> <INDENT> price = 0 <NEWLINE> knowledge = np . zeros ( M ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if s >> i & 1 : <NEWLINE> <INDENT> knowledge += A [ i ] <NEWLINE> price += C [ i ] <NEWLINE> <DEDENT> <DEDENT> if np . any ( knowledge < X ) : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if min_price == - 1 : <NEWLINE> <INDENT> min_price = price <NEWLINE> <DEDENT> min_price = min ( min_price , price ) <NEWLINE> <NL> <DEDENT> if min_price == INF : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( min_price ) <NEWLINE> <DEDENT>
<COMMENT> <NL> import numpy as np <NEWLINE> import math <NEWLINE> from itertools import combinations <NEWLINE> N , M , X = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> book_dict = { } <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> book_dict [ i ] = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <DEDENT> answer = ( 10 ** 5 * 12 ) + 1 <NEWLINE> for i in range ( N , 0 , - 1 ) : <NEWLINE> <INDENT> current_book_number = 0 <NEWLINE> for v in combinations ( book_dict . keys ( ) , i ) : <NEWLINE> <COMMENT> <NL> <INDENT> search_book = list ( map ( lambda x : book_dict [ x ] , list ( v ) ) ) <NEWLINE> sum_search_book = np . array ( np . sum ( search_book , axis = 0 ) ) <NEWLINE> if ( np . count_nonzero ( sum_search_book [ 1 : ] >= X ) == M ) and sum_search_book [ 0 ] < answer : <NEWLINE> <INDENT> answer = sum_search_book [ 0 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> current_book_number += 1 <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> if current_book_number == int ( math . factorial ( N ) / ( math . factorial ( i ) * math . factorial ( N - i ) ) ) : <NEWLINE> <INDENT> break : <NEWLINE> <NL> <DEDENT> <DEDENT> if answer == ( 10 ** 5 * 12 ) + 1 : <NEWLINE> <INDENT> answer = - 1 <NEWLINE> <NL> <DEDENT> print ( answer ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> N , M , X = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> books = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( N ) ] <NEWLINE> <NL> min_total_cost = 10 ** 9 <NEWLINE> <NL> for i in range ( 2 ** N ) : <NEWLINE> <INDENT> total_cost = 0 <NEWLINE> learned = [ 0 ] * M <NEWLINE> <NL> for j in range ( N ) : <NEWLINE> <INDENT> if ( i >> j ) & 1 : <NEWLINE> <INDENT> cost , points = books [ j ] <NEWLINE> total_cost += cost <NEWLINE> <NL> learned = [ x + y for x , y in zip ( learned , points ) ] <NEWLINE> <NL> <DEDENT> <DEDENT> if min ( learned ) >= X : <NEWLINE> <INDENT> min_total_cost = min ( min_total_cost , total_cost ) <NEWLINE> <NL> <DEDENT> <DEDENT> if min_total_cost == 10 ** 9 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( min_total_cost ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
big_int = 10 ** 9 <NEWLINE> <NL> N , M , X = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> L = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> L . insert ( tuple ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> <DEDENT> def foo ( i ) : <NEWLINE> <INDENT> T = [ 0 for j in range ( M + 1 ) ] <NEWLINE> for j in range ( N ) : <NEWLINE> <INDENT> for k in range ( M + 1 ) : <NEWLINE> <INDENT> T [ k ] += L [ j ] [ k ] * ( i % 2 ) <NEWLINE> i //= 2 <NEWLINE> <DEDENT> <DEDENT> for k in range ( 1 , M + 1 ) : <NEWLINE> <INDENT> if T [ k ] < X : <NEWLINE> <INDENT> return big_int <NEWLINE> <DEDENT> <DEDENT> return T [ 0 ] <NEWLINE> <NL> <DEDENT> ans = big_int <NEWLINE> <NL> for i in range ( 2 ** N ) : <NEWLINE> <INDENT> ans = min ( ans , foo ( i ) ) <NEWLINE> <NL> <DEDENT> if ans == big_int : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
<NL> from fractions import gcd <NEWLINE> from functools import reduce <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> import collections <NEWLINE> import math <NEWLINE> import sys <NEWLINE> sys . setrecursionlimit ( 2000000 ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> n , m , x = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> a = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> t = sum ( b ) - b [ 0 ] <NEWLINE> <COMMENT> <NL> b . append ( b [ 0 ] / t ) <NEWLINE> a . append ( b ) <NEWLINE> <NL> <DEDENT> a_sorted = sorted ( a , key = lambda x : x [ - 1 ] ) <NEWLINE> <COMMENT> <NL> <NL> money = 0 <NEWLINE> point = [ 0 ] * m <NEWLINE> over = [ 0 ] * m <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> fin = True <NEWLINE> money += a_sorted [ i ] [ 0 ] <NEWLINE> for j in range ( m ) : <NEWLINE> <INDENT> point [ j ] += a_sorted [ i ] [ j + 1 ] <NEWLINE> <DEDENT> for j in range ( m ) : <NEWLINE> <INDENT> if point [ j ] < x : <NEWLINE> <INDENT> fin = False <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> over [ j ] = point [ j ] - x <NEWLINE> <DEDENT> <DEDENT> if fin : <NEWLINE> <INDENT> k = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> kouho = True <NEWLINE> for j in range ( m ) : <NEWLINE> <INDENT> if a_sorted [ i ] [ j + 1 ] > over [ j ] : <NEWLINE> <INDENT> kouho = False <NEWLINE> <DEDENT> <DEDENT> if kouho : <NEWLINE> <INDENT> k . append ( i ) <NEWLINE> <DEDENT> <DEDENT> k . sort ( reverse = True ) <NEWLINE> if len ( k ) != 0 : <NEWLINE> <INDENT> for i in range ( len ( k ) ) : <NEWLINE> <INDENT> for j in range ( m ) : <NEWLINE> <INDENT> point [ j ] -= a_sorted [ i ] [ j + 1 ] <NEWLINE> if point [ j ] < x : <NEWLINE> <INDENT> print ( money ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> money -= a_sorted [ i ] [ 0 ] <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> for j in range ( m ) : <NEWLINE> <INDENT> print ( money ) <NEWLINE> exit ( ) <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> print ( - 1 ) <NEWLINE>
n , m , x = map ( int , input ( ) . split ( ) ) <NEWLINE> sL = [ 0 ] * m <NEWLINE> bL = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> book = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> bL . append ( book ) <NEWLINE> <NL> <NL> <DEDENT> def fullS ( currentL , index , allP ) : <NEWLINE> <INDENT> if index > len ( currentL ) : <NEWLINE> <INDENT> if min ( currentL ) >= x : <NEWLINE> <INDENT> return allP <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return - 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if min ( currentL ) >= x : <NEWLINE> <INDENT> return allP <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> op1 = fullS ( currentL , index + 1 , allP ) <NEWLINE> newP = 0 <NEWLINE> newL = [ ] <NEWLINE> for i in range ( len ( bL [ index ] ) ) : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> newP = allP + bL [ index ] [ i ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> newL . append ( currentL [ i - 1 ] + bL [ index ] [ i ] ) <NEWLINE> <DEDENT> <DEDENT> op2 = fullS ( newL , index + 1 , newP ) <NEWLINE> if op1 == - 1 and op2 == - 1 : <NEWLINE> <INDENT> return - 1 <NEWLINE> <DEDENT> elif op1 == - 1 : <NEWLINE> <INDENT> return op2 <NEWLINE> <DEDENT> elif op2 == - 1 : <NEWLINE> <INDENT> return op1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return min ( op1 , op2 ) <NEWLINE> <NL> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( fullS ( sL , 0 , 0 ) ) <NEWLINE>
import itertools <NEWLINE> import numpy as np <NEWLINE> N , M , X = map ( int , input ( ) . split ( ) ) <NEWLINE> lista = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> lista . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <DEDENT> lista = np . array ( lista ) <NEWLINE> cost = 1000000000000000 <NEWLINE> judge = [ X ] * M <NEWLINE> data = [ k for k in range ( 1 , N + 1 ) ] <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> a = list ( itertools . combinations ( data , i ) ) <NEWLINE> for j in a : <NEWLINE> <INDENT> clist = np . array ( [ 0 ] * ( M + 1 ) ) <NEWLINE> for k in j : <NEWLINE> <INDENT> clist = clist + lista [ k - 1 ] <NEWLINE> <DEDENT> if all ( clist [ 1 : ] >= judge ) : <NEWLINE> <INDENT> if clist [ 0 ] < cost : <NEWLINE> <INDENT> cost = clist [ 0 ] <NEWLINE> m = j <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> c = 0 <NEWLINE> for i in m : <NEWLINE> <INDENT> c += lista [ i ] [ 0 ] <NEWLINE> <NL> <DEDENT> print ( c ) <NEWLINE>
import sys <NEWLINE> import numpy as np <NEWLINE> <NL> read = sys . stdin . buffer . read <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> readlines = sys . stdin . buffer . readlines <NEWLINE> <NL> N , M , X = map ( int , readline ( ) . split ( ) ) <NEWLINE> data = np . array ( read ( ) . split ( ) , np . int64 ) <NEWLINE> data = data . reshape ( N , - 1 ) <NEWLINE> C = data [ : , 0 ] <NEWLINE> A = data [ : , 1 : ] <NEWLINE> <NL> cost = np . zeros ( 1 << N , np . int64 ) <NEWLINE> dability = np . zeros ( ( 1 << N , M ) , np . int64 ) <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> cost [ 1 << i : 1 << ( i + 1 ) ] = cost [ : 1 << i ] + C [ i ] <NEWLINE> ability [ 1 << i : 1 << ( i + 1 ) ] = ability [ : 1 << i ] + A [ i ] <NEWLINE> <NL> <DEDENT> ok = np . all ( ability >= X , axis = 1 ) <NEWLINE> <NL> x = cost [ ok ] <NEWLINE> answer = - 1 if len ( x ) == 0 else x . min ( ) <NEWLINE> print ( answer ) <NEWLINE> <NL> <NL>
from itertools import combinations <NEWLINE> import numpy as np <NEWLINE> n , m , x = map ( int , input ( ) . split ( ) ) <NEWLINE> costs = [ ] <NEWLINE> understnding = [ ] <NEWLINE> ans = 10 ** 20 <NEWLINE> <NL> for _ in range ( n ) : <NEWLINE> <INDENT> tmp = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> costs . append ( tmp [ 0 ] ) <NEWLINE> understnding . append ( tmp [ 1 : ] ) <NEWLINE> <NL> <DEDENT> costs = np . array ( costs ) <NEWLINE> understnding = np . array ( understnding ) <NEWLINE> <NL> for i in range ( 2 ** n ) : <NEWLINE> <INDENT> row = str ( bin ( i ) ) . split ( <STRING> ) [ 1 ] <NEWLINE> row = <STRING> * ( n - len ( row_tmp ) ) + row_tmp <NEWLINE> one_index = [ j for j in range ( len ( row ) ) if row [ j ] == <STRING> ] <NEWLINE> cost_sum = np . sum ( costs [ one_index ] ) <NEWLINE> under_sum = np . sum ( understnding [ one_index ] , axis = 0 ) <NEWLINE> if np . all ( under_sum >= x ) and cost_sum < ans : <NEWLINE> <INDENT> ans = cost_sum <NEWLINE> <NL> <DEDENT> <DEDENT> if ans == 10 ** 20 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
import bisect <NEWLINE> N , M , X = map ( int , input ( ) . split ( ) ) <NEWLINE> C = [ 0 ] * N <NEWLINE> A = [ 0 ] * N <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> x = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> C [ i ] = x [ 0 ] <NEWLINE> A [ i ] = [ 0 ] * M <NEWLINE> for j in range ( M ) : <NEWLINE> <INDENT> A [ i ] [ j ] = x [ j + 1 ] <NEWLINE> <DEDENT> <DEDENT> cnt = [ 0 ] * ( 2 ** N ) <NEWLINE> ans_list = [ ] <NEWLINE> for i in range ( 2 ** N ) : <NEWLINE> <INDENT> bag = [ ] <NEWLINE> cnt [ i ] = [ 0 ] * M <NEWLINE> for j in range ( N ) : <COMMENT> <NEWLINE> <INDENT> if ( ( i >> j ) & 1 ) : <COMMENT> <NEWLINE> <INDENT> bag . append ( C [ j ] ) <COMMENT> <NEWLINE> for k in range ( M ) : <NEWLINE> <INDENT> cnt [ i ] [ k ] += A [ j ] [ k ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if bisect . bisect_left ( cnt [ i ] , X ) == 0 : <NEWLINE> <INDENT> ans_list . append ( sum ( bag ) ) <NEWLINE> <DEDENT> <DEDENT> if ans_list == [ ] : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( min ( ans_list ) <NEWLINE> <DEDENT>
N , M , X = map ( int , input ( ) . split ( ) ) <NEWLINE> C = [ 0 ] * N <NEWLINE> A = [ ] <NEWLINE> <NL> for __ in range ( N ) : <NEWLINE> <INDENT> nums = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> C [ __ ] = nums [ 0 ] <NEWLINE> A . append ( nums [ 1 : ] ) <NEWLINE> <DEDENT> mincost = 10e9 <NEWLINE> ok = False <NEWLINE> for i in range ( 1 << N ) : <NEWLINE> <INDENT> cost = 0 <NEWLINE> skill = [ 0 ] * M <NEWLINE> <NL> for u in range ( N ) : <NEWLINE> <INDENT> if i & ( 1 << u ) : <NEWLINE> <INDENT> cost += C [ u ] <NEWLINE> for si , s in enumerate ( A [ u ] ) : <NEWLINE> <INDENT> skill [ si ] += s <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> if all ( [ s >= X for s in skill ] ) : <NEWLINE> <INDENT> ok = True <NEWLINE> if mincost > cost : <NEWLINE> <INDENT> mincost = cost <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( mincost if ok else - 1 ) <NEWLINE> <INDENT> dp <NEWLINE> <DEDENT>
DEBUG = True <NEWLINE> <NL> import time <NEWLINE> <NL> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ int ( i ) - 1 for i in input ( ) . split ( ) ] <NEWLINE> <NL> visited = [ False ] * N <NEWLINE> next = A [ 0 ] <NEWLINE> visited [ 0 ] = True <NEWLINE> K -= 1 <NEWLINE> while not visited [ next ] : <NEWLINE> <INDENT> if DEBUG : <NEWLINE> <INDENT> print ( <STRING> . format ( K , next ) ) <NEWLINE> print ( <STRING> . format ( visited ) ) <NEWLINE> time . sleep ( 0.1 ) <NEWLINE> <DEDENT> if K == 0 : <NEWLINE> <INDENT> print ( next + 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> visited [ next ] = True <NEWLINE> next = A [ next ] <NEWLINE> K -= 1 <NEWLINE> <NL> <DEDENT> K -= 1 <NEWLINE> now = next <NEWLINE> count = 1 <NEWLINE> next = A [ next ] <NEWLINE> while now != next : <NEWLINE> <INDENT> next = A [ next ] <NEWLINE> count += 1 <NEWLINE> <DEDENT> if DEBUG : <NEWLINE> <INDENT> print ( <STRING> . format ( count ) ) <NEWLINE> <NL> <DEDENT> K %= count <NEWLINE> <NL> if DEBUG : <NEWLINE> <INDENT> print ( <STRING> . format ( now , count , K ) ) <NEWLINE> <NL> <DEDENT> while K > 0 : <NEWLINE> <INDENT> if DEBUG : <NEWLINE> <INDENT> print ( <STRING> . format ( now ) ) <NEWLINE> <DEDENT> now = A [ now ] <NEWLINE> K -= 1 <NEWLINE> <NL> <DEDENT> print ( A [ now ] + 1 ) <NEWLINE>
CA = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ] <NEWLINE> <NL> ans = 10 ** 9 <NEWLINE> <NL> for i in range ( 2 ** n ) : <NEWLINE> <INDENT> ls = [ 0 ] * m <NEWLINE> tmp = 0 <NEWLINE> for j in range ( n ) : <NEWLINE> <INDENT> if ( i >> j ) & 1 : <NEWLINE> <INDENT> ls = [ l + a for l , a in zip ( ls , CA [ j ] [ 1 : ] ) ] <NEWLINE> tmp += CA [ j ] [ 0 ] <NEWLINE> <DEDENT> <DEDENT> if all ( i >= x for i in ls ) : <NEWLINE> <INDENT> ans = min ( ans , tmp ) <NEWLINE> <DEDENT> <DEDENT> print ( ans if ans != 10 ** 9 else - 1 ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> if n < k : <NEWLINE> <INDENT> ai = 1 <NEWLINE> aj = set ( ) <NEWLINE> aj . add ( 1 ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ai = a [ ai - 1 ] <NEWLINE> if ai in aj : <NEWLINE> <INDENT> ic2 = i <NEWLINE> ai2 = ai <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> aj . add ( ai ) <NEWLINE> <NL> <DEDENT> <DEDENT> ai = 1 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ai = a [ ai - 1 ] <NEWLINE> if ai == ai2 : <NEWLINE> <INDENT> ic1 = i <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> icyc = ic2 - ic1 <NEWLINE> k2 = ( k - ic1 ) % icyc + ic1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> k2 = k <NEWLINE> <NL> <DEDENT> ai = 1 <NEWLINE> for i in range ( k2 ) : <NEWLINE> <INDENT> ai = a [ ai - 1 ] <NEWLINE> <NL> <DEDENT> print ( ai ) <NEWLINE>
n , k = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> li = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> d = [ 0 for i in range ( n ) ] <NEWLINE> c = [ 1 ] <NEWLINE> nex = 1 <NEWLINE> first = 0 <NEWLINE> flag = 0 <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> nex = li [ nex - 1 ] <NEWLINE> if d [ nex ] : <NEWLINE> <INDENT> first = c . index ( nex ) <NEWLINE> flag = 1 <NEWLINE> break <NEWLINE> <DEDENT> d [ nex - 1 ] = 1 <NEWLINE> c . append ( nex ) <NEWLINE> <DEDENT> if flag : <NEWLINE> <INDENT> k -= first <NEWLINE> k %= len ( c ) - first <NEWLINE> print ( c [ first + k ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( c [ - 1 ] ) <NEWLINE> <DEDENT>
N , K = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> B = [ 0 ] * N <NEWLINE> C = 0 <NEWLINE> D = 0 <NEWLINE> E = [ ] <NEWLINE> for i in range ( K ) : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> B [ i ] += 1 <NEWLINE> C = A [ 0 ] <NEWLINE> D += 1 <NEWLINE> E . append ( C ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> else : <NEWLINE> <INDENT> if B [ C - 1 ] == 0 : <NEWLINE> <INDENT> B [ C - 1 ] += 1 <NEWLINE> C = A [ C - 1 ] <NEWLINE> D += 1 <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> else : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <INDENT> print ( E [ K % D ] ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( C ) <NEWLINE>
while True : <NEWLINE> <INDENT> k -= 1 <NEWLINE> cnt += 1 <NEWLINE> if k == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> dir = a [ dir - 1 ] <NEWLINE> if hash_a [ dir - 1 ] == 0 or hash_a [ dir - 1 ] == 1 or hash_a [ dir - 1 ] == 2 : <NEWLINE> <INDENT> hash_a [ dir - 1 ] += 1 <NEWLINE> if hash_a [ dir - 1 ] == 2 : <NEWLINE> <INDENT> two += 1 <NEWLINE> <DEDENT> <DEDENT> elif hash_a [ dir - 1 ] == 3 : <NEWLINE> <INDENT> k = ( k + cnt ) - ( cnt - ( two * 2 ) ) <NEWLINE> k %= two <NEWLINE> hash_a = [ - k for _ in range ( n ) ] <NEWLINE> <DEDENT> <DEDENT> print ( dir ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> A = tuple ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> s = 1 <NEWLINE> state = [ s ] <NEWLINE> count = { } <NEWLINE> for i in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> s = A [ s - 1 ] <NEWLINE> if s in count : <NEWLINE> <INDENT> start = state . index ( s ) <NEWLINE> end = len ( state ) <NEWLINE> print ( state [ start + ( k - start ) % ( end - start ) ] ) <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> count [ state [ i ] ] = i <NEWLINE> state . append ( s ) <NEWLINE> continue <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( s ) <NEWLINE> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> pos = 0 <NEWLINE> visited = [ 0 ] * N <NEWLINE> move = [ ] <NEWLINE> loop = [ ] <NEWLINE> <NL> while visited [ pos ] != 2 : <NEWLINE> <INDENT> if visited [ pos ] == 0 : <NEWLINE> <INDENT> move . append ( pos ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> loop . append ( pos ) <NEWLINE> <DEDENT> visited [ pos ] += 1 <NEWLINE> pos = A [ pos ] - 1 <NEWLINE> <NL> <DEDENT> if len ( move ) > k : <NEWLINE> <INDENT> print ( move [ k ] + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( roop [ ( K - ( len ( move ) - len ( loop ) ) ) % len ( loop ) ] + 1 ) <NEWLINE> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = input ( ) . split ( ) <NEWLINE> b = [ 0 ] * n <NEWLINE> d = { } <NEWLINE> ind = 1 <NEWLINE> num = 0 <NEWLINE> loop = 1 <NEWLINE> while num == k : <NEWLINE> <INDENT> if b [ ind - 1 ] == 0 : <NEWLINE> <INDENT> b [ ind - 1 ] = - 1 <NEWLINE> d [ ind ] = num <NEWLINE> num += 1 <NEWLINE> ind = int ( a [ ind - 1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> loop = num - d [ ind ] <NEWLINE> sup = d [ ind ] <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if k - sup >= 0 : <NEWLINE> <INDENT> for i in range ( ( k - sup ) % loop ) : <NEWLINE> <INDENT> ind = int ( a [ ind - 1 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ind ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> e = [ False ] * ( N + 1 ) <NEWLINE> idx = 1 <NEWLINE> move = [ ] <NEWLINE> while True : <NEWLINE> <INDENT> if e [ idx ] : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> move . append ( idx ) <NEWLINE> e [ idx ] = True <NEWLINE> idx = A [ idx - 1 ] <NEWLINE> <DEDENT> m = move . index ( idx ) <NEWLINE> c = len ( move ) - m <NEWLINE> <NL> if K <= m : <NEWLINE> <INDENT> print ( D [ K ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( D [ m + ( K - m ) % c ] ) <NEWLINE> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> loopcount = 0 <NEWLINE> tmpPoint = 1 <NEWLINE> vis = { 1 : 0 } <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> Next = A [ tmpPoint - 1 ] <NEWLINE> if Next in vis : <NEWLINE> <INDENT> startat = i <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> loopcount = i - vis [ Next ] + 1 <NEWLINE> break <NEWLINE> <DEDENT> vis [ Next ] = i + 1 <NEWLINE> tmpPoint = Next <NEWLINE> <NL> <DEDENT> if loopcount == 0 : <NEWLINE> <INDENT> print ( tmpPoint ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> if startat + nokori < K : <NEWLINE> <INDENT> nokori = ( K - startat ) % loopcount <NEWLINE> <NL> <DEDENT> tmpPoint = 1 <NEWLINE> for i in range ( startat + nokori ) : <NEWLINE> <INDENT> Next = A [ tmpPoint - 1 ] <NEWLINE> tmpPoint = Next <NEWLINE> <DEDENT> print ( tmpPoint ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A = [ 0 ] + A <NEWLINE> B = [ ] <NEWLINE> C = [ 0 ] + [ - 1 ] * n <NEWLINE> now_city = 1 <NEWLINE> seen = set ( ) <NEWLINE> <NL> <COMMENT> <NL> for i in range ( 1 , len ( A ) ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> if k <= len ( B ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> k = k - len ( B ) <NEWLINE> <COMMENT> <NL> if x == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> way = A [ 0 ] <NEWLINE> List = [ 0 for n in range ( N ) ] <NEWLINE> List [ way - 1 ] += 1 <NEWLINE> count = 0 <NEWLINE> string = <STRING> <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> for i in range ( 10 ** 7 ) : <NEWLINE> <INDENT> way = A [ way - 1 ] <NEWLINE> List [ way - 1 ] += 1 <NEWLINE> count += 1 <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> if max ( List ) == 3 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> string += <STRING> <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> new_list = [ i for i in List if i == 1 ] <NEWLINE> length = len ( new_list ) <NEWLINE> n_list = [ j for j in List if j >= 2 ] <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> amari = ( K - length ) % len ( n_list ) <NEWLINE> <NL> print ( int ( n_list [ amari + 1 ] ) ) <NEWLINE>
from collections import defaultdict <NEWLINE> def main ( ) : <NEWLINE> <INDENT> n , k = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> s = [ ] <NEWLINE> ord = [ - 1 ] * ( n ) <NEWLINE> u = 1 <NEWLINE> while ord [ u ] == - 1 : <NEWLINE> <INDENT> ord [ u ] = len ( s ) <NEWLINE> s . append ( u ) <NEWLINE> u = a [ u - 1 ] <NEWLINE> <DEDENT> l = len ( s ) - ord [ u ] <NEWLINE> if k < ord [ u ] : <NEWLINE> <INDENT> print ( s [ k ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( s [ ( k - ord [ u ] ) % l + ord [ u ] ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> <STRING> <NEWLINE> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
from statistics import median <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> from fractions import gcd <NEWLINE> from itertools import combinations <COMMENT> <NEWLINE> from collections import deque <NEWLINE> from collections import defaultdict <NEWLINE> import bisect <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> import sys <NEWLINE> sys . setrecursionlimit ( 10000000 ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> def readInts ( ) : <NEWLINE> <INDENT> return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <DEDENT> def main ( ) : <NEWLINE> <INDENT> n , k = readInts ( ) <NEWLINE> A = readInts ( ) <NEWLINE> root = [ ] <NEWLINE> ok = True <NEWLINE> l = 0 <NEWLINE> while True : <NEWLINE> <INDENT> if ok : <NEWLINE> <INDENT> a = 1 <NEWLINE> ok = False <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a = root [ - 1 ] <NEWLINE> <DEDENT> if not A [ a - 1 ] in root : <NEWLINE> <INDENT> root . append ( A [ a - 1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> j = 0 <NEWLINE> for i in range ( len ( root ) ) : <NEWLINE> <INDENT> if A [ a - 1 ] == root [ i ] : <NEWLINE> <INDENT> j = i <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> root = root [ j : ] <NEWLINE> l = j <NEWLINE> <COMMENT> <NL> break <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> print ( root [ k % len ( root ) - ( l + 1 ) ] ) <NEWLINE> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> next_city = 1 <NEWLINE> visited = [ ] <NEWLINE> x = [ - 1 ] * n <NEWLINE> while x [ next_city - 1 ] == - 1 : <NEWLINE> <INDENT> visited . append ( next_city ) <NEWLINE> next_city = A [ next_city - 1 ] <NEWLINE> <DEDENT> idx = visited . index ( next_city ) <NEWLINE> visited2 = visited [ idx : ] <NEWLINE> mod = len ( visited2 ) <NEWLINE> x = ( k % mod - idx ) % mod <NEWLINE> print ( visited2 [ x ] ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> genzaichi = 1 <NEWLINE> rireki = set ( ) <NEWLINE> houmon = [ 0 ] * ( N + 1 ) <NEWLINE> flag = 0 <NEWLINE> <NL> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> genzaichi = A [ genzaichi - 1 ] <NEWLINE> if genzaichi not in rireki : <NEWLINE> <INDENT> houmon [ genzaichi ] = i <NEWLINE> rireki . append ( genzaichi ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> roop_from = genzaichi <NEWLINE> x = houmon [ roop_from ] <NEWLINE> roop = i - x <NEWLINE> flag = 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if flag == 0 : <NEWLINE> <INDENT> print ( genzaichi ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> genzaichi = roop_from <NEWLINE> K = ( K - x ) - ( ( K - x ) // roop ) * roop <NEWLINE> for i in range ( K ) : <NEWLINE> <INDENT> genzaichi = A [ genzaichi - 1 ] <NEWLINE> <DEDENT> print ( genzaichi ) <NEWLINE> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A = [ i - 1 for i in A ] <NEWLINE> <NL> check = [ 0 ] * N <NEWLINE> i = 0 <NEWLINE> c = 0 <NEWLINE> check = [ ] <NEWLINE> visited = [ 0 ] * N <NEWLINE> flag = False <NEWLINE> while c <= K : <NEWLINE> <INDENT> if visited [ i ] == 1 : <NEWLINE> <INDENT> flag = True <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> check . append ( i ) <NEWLINE> visited [ i ] = 1 <NEWLINE> i = A [ i ] <NEWLINE> c += 1 <NEWLINE> <DEDENT> <DEDENT> if flag == True : <NEWLINE> <INDENT> X = check [ check . index ( i ) : ] <NEWLINE> print ( 1 + X [ ( K - check . index ( i ) ) % ( len ( check ) - check . index ( i ) ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( i + 1 ) <NEWLINE> <DEDENT>
from collections import Counter <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( lambda x : int ( x ) - 1 , input ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> visited = [ 0 ] * n <NEWLINE> <NL> <NL> def dfs ( v ) : <NEWLINE> <INDENT> if visited [ v ] + 1 == 3 : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> visited [ v ] += 1 <NEWLINE> dfs ( A [ v ] ) <NEWLINE> <NL> <NL> <DEDENT> dfs ( 0 ) <NEWLINE> <NL> c = Counter ( visited ) <NEWLINE> loop_cnt = c [ 2 ] <NEWLINE> init_cnt = c [ 1 ] <NEWLINE> k -= init_cnt <NEWLINE> k %= loop_cnt <NEWLINE> <NL> cnt = 0 <NEWLINE> visited = [ 0 ] * n <NEWLINE> <NL> <NL> ans = 0 <NEWLINE> for _ in range ( k + init_cnt ) : <NEWLINE> <INDENT> ans = A [ ans ] <NEWLINE> <DEDENT> print ( ans + 1 ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ int ( x ) - 1 for x in input ( ) . split ( ) ] <NEWLINE> <NL> <COMMENT> <NL> loop = 0 <NEWLINE> city = 0 <NEWLINE> b = set ( [ 0 ] ) <NEWLINE> while True : <NEWLINE> <INDENT> loop += 1 <NEWLINE> if A [ city ] in b : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> city = A [ city ] <NEWLINE> b . add ( city ) <NEWLINE> <NL> <DEDENT> <DEDENT> loop_start = A [ city ] <NEWLINE> <NL> <COMMENT> <NL> pre = 0 <NEWLINE> city = 0 <NEWLINE> while True : <NEWLINE> <INDENT> pre += 1 <NEWLINE> if A [ city ] == loop_start : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> city = A [ city ] <NEWLINE> <NL> <DEDENT> <DEDENT> if loop > pre : <NEWLINE> <INDENT> loop -= pre <NEWLINE> <NL> <DEDENT> if K < c : <COMMENT> <NEWLINE> <INDENT> city = 0 <NEWLINE> for i in range ( K ) : <NEWLINE> <INDENT> city = A [ city ] <NEWLINE> <DEDENT> print ( city + 1 ) <NEWLINE> <NL> <DEDENT> else : <COMMENT> <NEWLINE> <INDENT> K -= pre <NEWLINE> last = K % loop <NEWLINE> city = loop_start <NEWLINE> <NL> for i in range ( last ) : <NEWLINE> <INDENT> city = A [ city ] <NEWLINE> <DEDENT> print ( city + 1 ) <NEWLINE> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a_l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> town = 1 <NEWLINE> count = 0 <NEWLINE> town_visited = set ( ) <NEWLINE> while count < k : <NEWLINE> <INDENT> town_visited . add ( town ) <NEWLINE> town = a_l [ town - 1 ] <NEWLINE> count += 1 <NEWLINE> if town in town_visited : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> k -= count <NEWLINE> if k = 0 : <NEWLINE> <INDENT> print ( town ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> count = 0 <NEWLINE> town_visited = set ( ) <NEWLINE> while count < k : <NEWLINE> <INDENT> town_visited . add ( town ) <NEWLINE> town = a_l [ town - 1 ] <NEWLINE> count += 1 <NEWLINE> if town in town_visited : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> remain = k % count <NEWLINE> count = 0 <NEWLINE> while count < remain : <NEWLINE> <INDENT> town = a_l [ town - 1 ] <NEWLINE> count += 1 <NEWLINE> <NL> <DEDENT> print ( town ) <NEWLINE>
N , K = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> routs = { } <NEWLINE> location = [ 0 for i in range ( N + 1 ) ] <NEWLINE> tereporter = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> routs [ i ] = tereporter [ i ] - 1 <NEWLINE> <DEDENT> present_location = 0 <NEWLINE> n = 0 <NEWLINE> for i in range ( K ) : <NEWLINE> <INDENT> n += 1 <NEWLINE> present_location = routs [ present_location ] <NEWLINE> if location [ present_location ] == 0 : <NEWLINE> <INDENT> location [ present_location ] = n <NEWLINE> <DEDENT> else : <NEWLINE> loop = n - location [ present_location ] <NEWLINE> if ( K - location [ present_location ] ) % loop == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( ( K - location [ present_location ] ) % loop ) : <NEWLINE> <INDENT> present_location = routs [ present_location ] <NEWLINE> <DEDENT> <DEDENT> break <NEWLINE> <DEDENT> print ( present_location + 1 ) <NEWLINE> <NL>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> visited = [ - 1 ] * ( N + 1 ) <NEWLINE> path = [ ] <NEWLINE> at = 1 <NEWLINE> count = 0 <NEWLINE> while True : <NEWLINE> <INDENT> if visited [ at ] != - 1 : <NEWLINE> <INDENT> loop = count - visited [ at ] <NEWLINE> if K < count : <COMMENT> <NEWLINE> <INDENT> print ( path [ K ] + 1 ) <COMMENT> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( path [ ( K - visited [ at ] ) % loop + visited [ at ] ] + 1 ) <NEWLINE> <DEDENT> break <NEWLINE> <DEDENT> visited [ at ] = count <NEWLINE> count += 1 <NEWLINE> path . append ( at ) <NEWLINE> at = A [ at ] <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> import math <NEWLINE> <NL> <NL> def get_input ( ) -> tuple : <NEWLINE> <INDENT> <STRING> <NEWLINE> N , K = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> return N , K , A <NEWLINE> <NL> <NL> <DEDENT> def main ( N : int , K : int , A : list ) -> None : <NEWLINE> <INDENT> <STRING> <NEWLINE> <COMMENT> <NL> to = [ A ] <NEWLINE> for i in range ( math . ceil ( math . log2 ( K ) ) ) : <NEWLINE> <INDENT> to_i = to [ i ] <NEWLINE> to_next = [ ] <NEWLINE> <COMMENT> <NL> if ( ( K >> i ) & 1 ) : <NEWLINE> <INDENT> for j in range ( N ) : <NEWLINE> <INDENT> to_next . append ( to_i [ to_i [ j ] - 1 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> to . append ( to_next ) <NEWLINE> <NL> <DEDENT> result = 1 <NEWLINE> for i in range ( math . ceil ( math . log2 ( K ) ) ) : <NEWLINE> <INDENT> if ( ( K >> i ) & 1 ) : <NEWLINE> <INDENT> result = to [ i ] [ result - 1 ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( result ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> N , K , A = get_input ( ) <NEWLINE> main ( N , K , A ) <NEWLINE> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> array = input ( ) . split ( ) <NEWLINE> for i in range ( len ( array ) ) : <NEWLINE> <INDENT> array [ i ] = int ( array [ i ] ) <NEWLINE> <NL> <DEDENT> now = 1 <NEWLINE> <NL> history = set ( ) <NEWLINE> start_number = - 1 <NEWLINE> <NL> for i in range ( K ) : <NEWLINE> <INDENT> history . add ( now ) <NEWLINE> now = array [ now - 1 ] <NEWLINE> if ( now in history ) : <NEWLINE> <INDENT> start_number = now <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if not ( start_number == - 1 ) : <NEWLINE> <INDENT> start_ind = history . index ( start_number ) <NEWLINE> length = len ( history ) - start_ind <NEWLINE> mod = ( K - start_ind ) % length <NEWLINE> now = history [ start_ind + mod ] <NEWLINE> <NL> <DEDENT> print ( now ) <NEWLINE>
<COMMENT> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> As = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> As = [ 0 ] + As <NEWLINE> ikisaki = As [ 1 ] <NEWLINE> aru = { 1 } <NEWLINE> itta = [ 1 ] <NEWLINE> imaitta = 1 <NEWLINE> <NL> while not ikisaki in aru : <NEWLINE> <INDENT> imaitta = ikisaki <NEWLINE> ikisaki = As [ ikisaki ] <NEWLINE> itta . append ( imaitta ) <NEWLINE> aru . add ( imaitta ) <NEWLINE> <DEDENT> ind = itta . index ( ikisaki ) <NEWLINE> kurikaesi = itta [ ind : ] <NEWLINE> itidokiri = itta [ : ind ] <NEWLINE> ans = itidokiri [ K - 1 ] if len ( itidokiri ) <= K else kurikaesi [ ( K - len ( itidokiri ) ) % len ( kurikaesi ) ] <NEWLINE> <NL> <NL> return itta , itidokiri , kurikaesi , ans <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <COMMENT> <NL> <INDENT> print ( main ( ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NEWLINE> <DEDENT>
n , k_in = map ( int , input ( ) . split ( ) ) <NEWLINE> a_l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> def f ( s ) : <NEWLINE> <INDENT> a = s <NEWLINE> b = s <NEWLINE> i = 1 <NEWLINE> while True : <NEWLINE> <INDENT> a = a_l [ a - 1 ] <NEWLINE> a = a_l [ a - 1 ] <NEWLINE> b = a_l [ b - 1 ] <NEWLINE> if a == b : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> i += 1 <NEWLINE> <NL> <DEDENT> j = 1 <NEWLINE> a = a_l [ 0 ] <NEWLINE> while True : <NEWLINE> <INDENT> a = a_l [ a - 1 ] <NEWLINE> b = a_l [ b - 1 ] <NEWLINE> if a == b : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> j += 1 <NEWLINE> <NL> <DEDENT> k = 1 <NEWLINE> while True : <NEWLINE> <INDENT> a = a_l [ a - 1 ] <NEWLINE> a = a_l [ a - 1 ] <NEWLINE> b = a_l [ b - 1 ] <NEWLINE> if a == b : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> k += 1 <NEWLINE> <NL> <DEDENT> return j , k <NEWLINE> <NL> <DEDENT> lam , myu = f ( a_l [ 0 ] ) <NEWLINE> <NL> pos = [ ] <NEWLINE> pos . append ( a_l [ 0 ] ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> pos . append ( a_l [ pos [ i ] ] ) <NEWLINE> <NL> <DEDENT> if k_in <= lam : <NEWLINE> <INDENT> print ( pos [ k_in - 1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> k_in = ( k_in - lam ) % myu <NEWLINE> print ( pos [ lam + k_in - 1 ] ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> n , k = map ( int , sys . stdin . buffer . readline ( ) . split ( ) ) <NEWLINE> a = [ 0 ] + list ( map ( int , sys . stdin . buffer . readline ( ) . split ( ) ) ) <NEWLINE> <NL> visited = [ 0 ] * ( n + 1 ) <NEWLINE> town = 1 <NEWLINE> for i in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> town = a [ town ] <NEWLINE> if visited [ town ] == 0 : <NEWLINE> <INDENT> visited [ town ] = i <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cyc = ( k - visited [ town ] ) % ( i + visited [ town ] ) + visited [ town ] <NEWLINE> print ( visited . index ( cyc ) ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( town ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> B = [ ] <NEWLINE> Vector = [ 0 ] * N <NEWLINE> j = 0 <NEWLINE> <NL> for i in range ( 0 , K + 1 ) : <NEWLINE> <INDENT> if Vector [ A [ j ] ] == 1 : <NEWLINE> <INDENT> Value = B . index ( A [ j ] ) <NEWLINE> C = B [ B . index ( A [ j ] ) : : ] <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> B . append ( A [ j ] ) <NEWLINE> Vector [ A [ j ] ] = 1 <NEWLINE> j = A [ j ] - 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if A [ 0 ] == 1 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> elif len ( B ) == K : <NEWLINE> <INDENT> print ( B [ - 1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( C [ ( K - Value - 1 ) % len ( C ) ] ) <NEWLINE> <DEDENT>
<COMMENT> <NL> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A_list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans_list = [ 1 ] <NEWLINE> history_list = [ 0 for _ in range ( N ) ] <NEWLINE> before_town = 1 <NEWLINE> loop_start_town = 10 ** 10 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> now_town = A_list [ before_town - 1 ] <NEWLINE> if history_list [ now_town - 1 ] == 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> ans_list . append ( now_town ) <NEWLINE> before_town = now_town <NEWLINE> <NL> <DEDENT> if len ( ans_list ) >= K : <NEWLINE> <INDENT> print ( ans_list [ K ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> loop_start_idx = ans_list . index ( A_list [ ans_list [ - 1 ] - 1 ] ) <NEWLINE> loop_len = len ( ans_list ) <NEWLINE> ans_list = ans_list [ loop_start_idx : ] <NEWLINE> mod_num = ( K - loop_len ) % ( loop_len - loop_start_idx ) <NEWLINE> print ( ans_list [ mod_num ] ) <NEWLINE> <DEDENT>
def resolve ( ) : <NEWLINE> <INDENT> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ int ( i ) - 1 for i in input ( ) . split ( ) ] <NEWLINE> visited = [ False ] * N <NEWLINE> steps = [ K for i in range ( N ) ] <NEWLINE> <NL> current = 0 <NEWLINE> while True : <NEWLINE> <NL> <INDENT> if K == 0 : <NEWLINE> print ( current + 1 ) <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> if not visited [ current ] : <NEWLINE> <INDENT> visited [ current ] = True <NEWLINE> steps [ current ] = K <NEWLINE> current = A [ current ] <NEWLINE> K -= 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> K = K % ( steps [ current ] - K ) <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> while K != 0 : <NEWLINE> <NL> <INDENT> current = A [ current ] <NEWLINE> K -= 1 <NEWLINE> <DEDENT> print ( current + 1 ) <NEWLINE> <NL> <NL> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> resolve ( ) <NEWLINE> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> from collections import deque <NEWLINE> <NL> ans = deque ( ) <NEWLINE> ans . appendleft ( 1 ) <NEWLINE> count = 1 <NEWLINE> s = - 1 <NEWLINE> zeros = [ 0 ] * n <NEWLINE> <NL> while True : <NEWLINE> <INDENT> if zeros [ a [ count - 1 ] ] == 1 : <NEWLINE> <INDENT> s = a [ count - 1 ] <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans . append ( a [ count - 1 ] ) <NEWLINE> zeros [ count - 1 ] = 1 <NEWLINE> count = a [ count - 1 ] <NEWLINE> <NL> <DEDENT> <DEDENT> ans = list ( ans ) <NEWLINE> if s == - 1 : <NEWLINE> <INDENT> print ( ans [ k ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> t = ans . index ( s ) <NEWLINE> if t >= k : <NEWLINE> <INDENT> print ( ans [ k ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = ans [ t : ] <NEWLINE> print ( ans [ ( k - t ) % len ( ans ) ] ) <NEWLINE> <DEDENT> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> s = 1 <NEWLINE> place = [ s ] <NEWLINE> first = set ( place ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> s = a [ s - 1 ] <NEWLINE> if s in first : <NEWLINE> <INDENT> loops = place . index ( s ) <NEWLINE> loope = len ( place ) <NEWLINE> ans = loops + ( k - loope ) % ( loope - loops ) <NEWLINE> print ( place ( ans ) ) <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> place . append ( s ) <NEWLINE> first . add ( s ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( s ) <NEWLINE> <DEDENT>
N , K = map ( int , ( input ( ) . split ( ) ) ) <NEWLINE> TO = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> visit_flag = [ [ 0 ] * 2 for i in [ 1 ] * N ] <NEWLINE> visit_count = 0 <NEWLINE> first_visit = 0 <NEWLINE> last_visit = 0 <NEWLINE> next_town = 1 <NEWLINE> visit_flag [ 0 ] [ 0 ] = 1 <NEWLINE> visit_flag [ 0 ] [ 1 ] = 0 <NEWLINE> <NL> for i in range ( K ) : <NEWLINE> <INDENT> visit_count += 1 <NEWLINE> next_town = TO [ next_town - 1 ] <NEWLINE> if visit_flag [ next_town - 1 ] [ 0 ] == 0 : <NEWLINE> <INDENT> visit_flag [ next_town - 1 ] [ 0 ] = 1 <NEWLINE> visit_flag [ next_town - 1 ] [ 1 ] = visit_count <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> first_visit = visit_flag [ next_town - 1 ] [ 1 ] <NEWLINE> last_visit = visit_count <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> roop = last_visit - first_visit <NEWLINE> span = visit_flag [ next_town - 1 ] [ 1 ] <NEWLINE> <NL> if K <= roop : <NEWLINE> <INDENT> next_town = 1 <NEWLINE> for i in range ( K ) : <NEWLINE> <INDENT> next_town = TO [ next_town - 1 ] <NEWLINE> <DEDENT> ans = next_town <NEWLINE> <DEDENT> else : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <INDENT> else : <NEWLINE> <INDENT> for i in range ( ( K - span ) % roop ) : <NEWLINE> <INDENT> next_town = TO [ next_town - 1 ] <NEWLINE> ans = next_town <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> pos = 0 <NEWLINE> visit = [ 0 ] * n <NEWLINE> move = [ ] <NEWLINE> loop = [ ] <NEWLINE> while visit [ pos ] != 2 : <NEWLINE> <INDENT> if visit [ pos ] == 0 : <NEWLINE> <INDENT> move . append ( pos ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> loop . append ( pos ) <NEWLINE> <DEDENT> visit [ pos ] += 1 <NEWLINE> pos = a [ pos ] - 1 <NEWLINE> <DEDENT> if len ( move [ k ] ) > k : <NEWLINE> <INDENT> print ( move [ k ] + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( loop [ ( k - ( len ( move ) - len ( loop ) ) ) % len ( loop ) ] + 1 ) <NEWLINE> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> now = 1 <NEWLINE> count = 0 <NEWLINE> a = 0 <NEWLINE> l = [ 1 ] <NEWLINE> b = 0 <NEWLINE> c = 0 <NEWLINE> q = [ True ] * N <NEWLINE> while a == 0 and count < K : <NEWLINE> <INDENT> now = A [ now - 1 ] <NEWLINE> count += 1 <NEWLINE> if q [ now - 1 ] : <NEWLINE> <INDENT> a = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> l . append ( now ) <NEWLINE> q [ now - 1 ] = False <NEWLINE> <NL> <DEDENT> <DEDENT> b = l . index ( now ) <NEWLINE> c = count - b <NEWLINE> if count == K : <NEWLINE> <INDENT> print ( now ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> n = ( ( K - b ) % c ) <NEWLINE> print ( l [ b + n ] ) <NEWLINE> <NL> <DEDENT>
import numpy as np <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> <COMMENT> <NL> from numba import njit <NEWLINE> <NL> <NL> @ njit <NEWLINE> def make_my_route ( route , A , N ) : <NEWLINE> <INDENT> pre = 1 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> now = A [ pre - 1 ] <NEWLINE> route = np . append ( route , now ) <NEWLINE> temp = np . sum ( route == now ) <NEWLINE> if temp == 2 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> pre = now <NEWLINE> <DEDENT> return route <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A = np . array ( A ) <NEWLINE> <NL> route = np . array ( [ 1 ] ) <NEWLINE> <NL> route = make_my_route ( route , A , N ) <NEWLINE> now = route [ - 1 ] <NEWLINE> start = int ( np . where ( route == now ) [ 0 ] [ 0 ] ) <NEWLINE> <NL> if K < start : <NEWLINE> <INDENT> res = route [ K ] <NEWLINE> <DEDENT> elif start + 1 != N : <NEWLINE> <INDENT> K -= start <NEWLINE> loop = route [ start : - 1 ] <NEWLINE> <COMMENT> <NL> M = len ( loop ) <NEWLINE> K %= M <NEWLINE> res = loop [ K ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> res = route [ K ] <NEWLINE> <NL> <DEDENT> print ( res ) <NEWLINE> <NL> <NL> <NL> <DEDENT> main ( ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> Alist = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <COMMENT> <NL> loop_num = 2 * 10 ** 5 <NEWLINE> loop_start_point = - 1 <NEWLINE> point = 1 <NEWLINE> count_list = [ - 1 ] * N <NEWLINE> <NL> for i in range ( K ) : <NEWLINE> <COMMENT> <NL> <INDENT> count_list [ point - 1 ] = i <NEWLINE> nextPoint = Alist [ point - 1 ] <NEWLINE> <NL> if count_list [ nextPoint - 1 ] != - 1 : <NEWLINE> <INDENT> loop_start_point = nextPoint <NEWLINE> loop_num = i - count_list [ loop_start_point - 1 ] + 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> point = nextPoint <NEWLINE> <NL> <DEDENT> if loop_start_point == - 1 : <NEWLINE> <COMMENT> <NL> else : <NEWLINE> <INDENT> point = loop_start_point <NEWLINE> progress_num = ( K - count_list [ loop_start_point - 1 ] ) % loop_num <NEWLINE> for i in range ( progress_num ) : <NEWLINE> <INDENT> point = Alist [ point - 1 ] <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> print ( point ) <NEWLINE> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = [ ] <NEWLINE> b = 1 <NEWLINE> ans = 1 <NEWLINE> while ans : <NEWLINE> <INDENT> a = b <NEWLINE> b = A [ a - 1 ] <NEWLINE> B . append ( b ) <NEWLINE> if len ( B ) == k : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> if B [ - 1 ] == B [ - 2 ] : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> <DEDENT> print ( B [ k - 1 ] ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> memo = [ - 1 ] * N <NEWLINE> checked_num = { } <NEWLINE> <NL> teleporter = A [ 0 ] <NEWLINE> memo [ 0 ] = teleporter <NEWLINE> repeat_point = - 1 <NEWLINE> flag = False <NEWLINE> <NL> for i in range ( 1 , N ) : <NEWLINE> <INDENT> memo [ i ] = A [ teleporter - 1 ] <NEWLINE> teleporter = A [ teleporter - 1 ] <NEWLINE> checked_num [ memo [ i ] ] = None <NEWLINE> if memo [ i ] in checked_num and flag == False : <NEWLINE> <INDENT> repeat_point = i <NEWLINE> flag = True <NEWLINE> <NL> <DEDENT> <DEDENT> start_point = memo . index ( memo [ repeat_point ] ) <NEWLINE> repeat = repeat_point - start_point <NEWLINE> <COMMENT> <NL> <NL> if K <= N : <NEWLINE> <INDENT> print ( memo [ K - 1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> mod = K % repeat <NEWLINE> print ( memo [ mod - 1 ] ) <NEWLINE> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> pos = 0 <NEWLINE> visit = [ 0 ] * N <NEWLINE> move = [ ] <NEWLINE> roop = [ ] <NEWLINE> while visit [ pos ] != 2 : <NEWLINE> <INDENT> if visit [ pos ] == 0 : <NEWLINE> <INDENT> move . append ( pos ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> roop . append ( pos ) <NEWLINE> <DEDENT> visit [ pos ] += 1 <NEWLINE> pos = a [ pos ] - 1 <NEWLINE> <DEDENT> if len ( move ) > K : <NEWLINE> <INDENT> print ( move [ K ] + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( roop [ ( K - ( len ( move ) - len ( roop ) ) ) % len ( roop ) ] + 1 ) <NEWLINE> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ 0 ] + list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> journey = [ 1 ] <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> nxt = a [ journey [ - 1 ] ] <NEWLINE> journey . append ( nxt ) <NEWLINE> <NL> <DEDENT> if K < N : <NEWLINE> <INDENT> print ( journey [ K ] ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> loop_start = N - 1 <NEWLINE> loop_end = N <NEWLINE> <NL> finished = False <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> for j in range ( i + 1 , N + 1 ) : <NEWLINE> <INDENT> if journey [ i ] == journey [ j ] : <NEWLINE> <INDENT> loop_start = i <NEWLINE> loop_end = j <NEWLINE> finished = True <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if finished : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> period = loop_end - loop_start <NEWLINE> <NL> K %= period <NEWLINE> while K < period : <NEWLINE> <INDENT> K += period <NEWLINE> <NL> <DEDENT> print ( journey [ K ] ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> pl = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> cl = [ 0 ] * 2 * n <NEWLINE> res = [ ] <NEWLINE> next = 0 <NEWLINE> for x in range 2 * n : <NEWLINE> <INDENT> if cl [ next ] == 0 : <NEWLINE> <INDENT> cl [ next ] = 1 <NEWLINE> next = pl [ next ] - 1 <NEWLINE> <DEDENT> if cl [ next ] == 1 : <NEWLINE> <INDENT> res . append ( next + 1 ) <NEWLINE> cl [ next ] = 2 <NEWLINE> next = pl [ next ] - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> lroop = len ( res ) <NEWLINE> k -= count . cl ( 1 ) <NEWLINE> num = k % lroop <NEWLINE> print ( res [ num - 1 ] ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( next + 1 ) <NEWLINE> <DEDENT>
N , K = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> p = 1 <NEWLINE> B = [ - 1 ] * N <NEWLINE> B [ 0 ] = 0 <NEWLINE> count = 1 <NEWLINE> while K < count : <NEWLINE> <INDENT> p = A [ p - 1 ] <NEWLINE> if B [ p - 1 ] != - 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> B [ p - 1 ] = count <NEWLINE> count += 1 <NEWLINE> <DEDENT> if K < count : <NEWLINE> <INDENT> print ( p ) <NEWLINE> return <NEWLINE> <DEDENT> K -= count <NEWLINE> K = K % ( count - B [ p - 1 ] ) <NEWLINE> for i in range ( K ) : <NEWLINE> <INDENT> p = A [ p - 1 ] <NEWLINE> <DEDENT> print ( p ) <NEWLINE> <NL> <NL>
import sys <NEWLINE> import numpy as np <NEWLINE> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = np . array ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> A = np . insert ( A , 0 , 0 ) <NEWLINE> <NL> flg = [ False for _ in range ( N + 1 ) ] <NEWLINE> town = [ ] <NEWLINE> i = 1 <NEWLINE> cnt = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> town . append ( i ) <NEWLINE> flg [ i ] = True <NEWLINE> i = A [ i ] <NEWLINE> <NL> <DEDENT> if len ( town ) >= K : <NEWLINE> <INDENT> print ( town [ K ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s = i <NEWLINE> to_s = town . index ( s ) <NEWLINE> loop = len ( town ) - to_s <NEWLINE> print ( town [ ( K - to_s ) % loop + to_s ] ) <NEWLINE> <DEDENT>
if __name__ == <STRING> : <NEWLINE> <INDENT> N , K = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> _town_list = input ( ) . split ( <STRING> ) <NEWLINE> town_list = [ int ( n ) for n in _town_list ] <NEWLINE> <NL> next_town = town_list [ 0 ] <NEWLINE> visited_town = set ( ) <NEWLINE> visited_town . add ( 1 ) <NEWLINE> visited_town . add ( next_town ) <NEWLINE> lst_visited_town = [ 1 ] <NEWLINE> lst_visited_town . append ( next_town ) <NEWLINE> counter = 1 <NEWLINE> <NL> while True : <NEWLINE> <INDENT> counter += 1 <NEWLINE> next_town = town_list [ next_town - 1 ] <NEWLINE> if counter == K : <NEWLINE> <INDENT> print ( next_town ) <NEWLINE> break <NEWLINE> <DEDENT> if next_town in visited_town : <NEWLINE> <INDENT> repeated_town_idx = lst_visited_town . index ( next_town ) <NEWLINE> loop_num = counter - repeated_town_idx <NEWLINE> print ( visited_town [ ( K - repeated_town_idx ) % loop_num + repeated_town_idx ] ) <NEWLINE> break <NEWLINE> <DEDENT> lst_visited_town . append ( next_town ) <NEWLINE> visited_town . add ( next_town ) <NEWLINE> <DEDENT> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ll = [ a [ 0 ] ] <NEWLINE> <NL> for i in range ( 1 , n ) : <NEWLINE> <INDENT> cnt = ll [ i - 1 ] <NEWLINE> if cnt = a [ cnt - 1 ] : <NEWLINE> <INDENT> print ( cnt ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> if a [ cnt - 1 ] == a [ 0 ] : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ll . append ( a [ cnt - 1 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ll [ k % 3 - 1 ] ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> li = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> check = [ 0 ] * ( n + 10 ) <NEWLINE> res = [ ] <NEWLINE> next = 0 <NEWLINE> <NL> for i in range ( k ) : <NEWLINE> <INDENT> if check [ next ] == 0 : <NEWLINE> <INDENT> check [ next ] = 1 <NEWLINE> next = li [ next ] - 1 <NEWLINE> <DEDENT> elif check [ next ] == 1 : <NEWLINE> <INDENT> check [ next ] += 1 <NEWLINE> res . append ( next + 1 ) <NEWLINE> next = li [ next ] - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cnt = len ( res ) <NEWLINE> k -= check . count ( 1 ) <NEWLINE> amari = k % cnt <NEWLINE> print ( res [ amari ] ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( next + 1 ) <NEWLINE> <DEDENT> amari = k % n <NEWLINE> <INDENT> ans = li [ amari - 1 ] <NEWLINE> print ( ans ) <NEWLINE> <DEDENT> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> li = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> check = [ 0 ] * ( n + 10 ) <NEWLINE> res = [ ] <NEWLINE> next = 0 <NEWLINE> <NL> for i in range ( n + 10 ) : <NEWLINE> <INDENT> if check [ next ] == 0 : <NEWLINE> <INDENT> check [ next ] = 1 <NEWLINE> next = li [ next ] - 1 <NEWLINE> <DEDENT> elif check [ next ] == 1 : <NEWLINE> <INDENT> check [ next ] += 1 <NEWLINE> res . append ( next + 1 ) <NEWLINE> next = li [ next ] - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cnt = len ( res ) <NEWLINE> k -= check . count ( 1 ) <NEWLINE> amari = k % cnt <NEWLINE> print ( res [ amari ] ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> amari = k % n <NEWLINE> ans = li [ amari - 1 ] <NEWLINE> print ( ans ) <NEWLINE> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> dic = { } <NEWLINE> wk = 1 <NEWLINE> start = 0 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> wk = a [ wk - 1 ] <NEWLINE> if wk in dic : <NEWLINE> <INDENT> start = dic [ wk ] <NEWLINE> break <NEWLINE> <DEDENT> dic [ wk ] = i <NEWLINE> <DEDENT> end = len ( dic ) <NEWLINE> loopcnt = end - start + 1 <NEWLINE> keys = list ( dic . keys ( ) ) <NEWLINE> if k < start : <NEWLINE> <INDENT> print ( keys [ k - 1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> chk = ( k - start + 1 ) % loopcntac <NEWLINE> if chk == 0 : <NEWLINE> <INDENT> chk = loopcnt <NEWLINE> <DEDENT> print ( keys [ ( start - 1 ) + chk - 1 ] ) <NEWLINE> <DEDENT>
import sys <NEWLINE> import time <NEWLINE> st = time . perf_counter ( ) <NEWLINE> <COMMENT> <NL> <NL> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A = [ i - 1 for i in A ] <NEWLINE> <NL> cnt = [ - 1 ] * N <NEWLINE> cnt [ 0 ] = 0 <NEWLINE> now = 0 <NEWLINE> for i in range ( 1 , 1001001001 ) : <NEWLINE> <INDENT> now = A [ now ] <NEWLINE> if cnt [ now ] == - 1 : <NEWLINE> <INDENT> cnt [ now ] = i <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> circle = i - cnt [ now ] <NEWLINE> t = cnt [ now ] <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if K - t > 0 : <NEWLINE> <INDENT> amari = ( K - t ) % circle <NEWLINE> for _ in range ( amari ) : <NEWLINE> now = A [ now ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> now = 0 <NEWLINE> for i in range ( K ) : <NEWLINE> <INDENT> now = A [ now ] <NEWLINE> <DEDENT> <DEDENT> print ( now + 1 ) <NEWLINE> <NL> <COMMENT> <NL> ed = time . perf_counter ( ) <NEWLINE> print ( <STRING> , ed - st , file = sys . stderr ) <NEWLINE>
a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> z = 0 <NEWLINE> b = [ 1 ] <NEWLINE> c = [ 0 ] * n <NEWLINE> for i in range ( n * 3 ) : <NEWLINE> <INDENT> j = [ a [ b [ i ] - 1 ] ] <NEWLINE> b . extend ( j ) <NEWLINE> c [ a [ b [ i ] - 1 ] - 1 ] = c [ a [ b [ i ] - 1 ] - 1 ] + 1 <NEWLINE> if c [ a [ b [ i ] - 1 ] - 1 ] == 2 : <NEWLINE> <INDENT> z = z + 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if k <= n : <NEWLINE> <INDENT> y = b [ k ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> l = ( k - n ) % z <NEWLINE> y = b [ n + l ] <NEWLINE> <DEDENT> print ( y ) <NEWLINE>
<COMMENT> <NL> import collections <NEWLINE> import itertools as it <NEWLINE> import math <NEWLINE> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> ord_ = [ - 1 ] * ( n + 1 ) <COMMENT> <NEWLINE> s = [ ] <NEWLINE> current = 0 <NEWLINE> while ord_ [ v ] == - 1 : <NEWLINE> <INDENT> ord_ [ v ] = len ( s ) <NEWLINE> s . append ( v ) <NEWLINE> current = a [ current ] - 1 <NEWLINE> <DEDENT> c = len ( s ) - ord_ [ current ] <NEWLINE> l = ord_ [ current ] <NEWLINE> <NL> if k < l : <NEWLINE> <INDENT> print ( s [ k ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> k -= l <NEWLINE> k %= c <NEWLINE> print ( s [ l + k ] ) <NEWLINE> <NL> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> num = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> t = [ - 1 ] * n <NEWLINE> count = 0 <NEWLINE> s = 1 <NEWLINE> <NL> while t [ s - 1 ] == - 1 : <NEWLINE> <INDENT> if count == k : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> t [ s - 1 ] = count <NEWLINE> count += 1 <NEWLINE> s = num [ s - 1 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> z = ( k - t [ s - 1 ] ) % ( count - t [ s - 1 ] ) <NEWLINE> s = t . index ( t [ s - 1 ] + z + 1 ) <NEWLINE> <DEDENT> print ( s ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> cnt = [ - 1 ] * n <NEWLINE> cnt [ 0 ] = 0 <NEWLINE> ary = [ ] <NEWLINE> now = 1 <NEWLINE> ary . append ( now ) <NEWLINE> if k <= n : <NEWLINE> <INDENT> for i in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> now = a [ now - 1 ] <NEWLINE> if i == k : <NEWLINE> <INDENT> print ( now ) <NEWLINE> return <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> now = a [ now - 1 ] <NEWLINE> if cnt [ now - 1 ] != - 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cnt [ now - 1 ] = i <NEWLINE> ary . append ( a [ now - 1 ] ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> print ( ary [ cnt [ now - 1 ] + ( ( k - cnt [ now - 1 ] ) % ( i - cnt [ now - 1 ] ) ) + 1 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ 0 ] + list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> visited = [ False for _ in range ( n + 1 ) ] <NEWLINE> pos = 1 <NEWLINE> x = [ ] <NEWLINE> flg = False <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> if visited [ pos ] == False : <NEWLINE> <INDENT> x . append ( pos ) <NEWLINE> visited [ pos ] = True <NEWLINE> pos = A [ pos ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> flg = True <NEWLINE> pre = x . index ( pos ) <NEWLINE> loop = x [ pre : ] <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if not flg : <NEWLINE> <INDENT> print ( pos ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( loop [ ( k - pre ) % len ( loop ) ] ) <NEWLINE> <DEDENT> ~ <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> q = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> v = [ - 1 ] * ( n + 1 ) <NEWLINE> p = [ ] <NEWLINE> a = 1 <NEWLINE> c = 0 <NEWLINE> while 1 : <NEWLINE> <INDENT> if v [ a ] != - 1 : <NEWLINE> <INDENT> l = c - v [ a ] <NEWLINE> if k < c : <NEWLINE> <INDENT> print ( p [ k ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( p [ ( k - v [ a ] ) % l + v [ a ] ] ) <NEWLINE> <DEDENT> break <NEWLINE> <DEDENT> v [ a ] = c <NEWLINE> c += 1 <NEWLINE> p . append ( a ) <NEWLINE> a = q [ a ] <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> import math <NEWLINE> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A2 = np . zeros ( N ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <COMMENT> <NL> current_town = 0 <NEWLINE> <NL> <NL> <NL> i = 0 <NEWLINE> while i < K : <NEWLINE> <INDENT> current_town = A [ current_town ] <NEWLINE> if A2 [ current_town ] != 0 : <NEWLINE> <INDENT> cycle = i - A2 [ current_town ] <NEWLINE> i = K - ( K - i ) % cycle <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> A2 [ current_town ] = i <NEWLINE> <NL> <DEDENT> <DEDENT> print ( current_town + 1 ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> R = [ False ] * ( N + 1 ) <NEWLINE> D = [ ] <NEWLINE> <NL> p = 1 <NEWLINE> <NL> while True : <NEWLINE> <INDENT> if R [ p ] : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> D . append ( p ) <NEWLINE> R [ p ] = True <NEWLINE> p = A [ p - 1 ] <NEWLINE> <NL> <DEDENT> m = D . index ( p ) <NEWLINE> c = len ( D ) - m <NEWLINE> <NL> if K <= m : <NEWLINE> <INDENT> print ( D [ K ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( D [ m + K - m ] % c ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> N , K = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> As = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> def compute ( city , K ) : <NEWLINE> <INDENT> for i in range ( K ) : <NEWLINE> <COMMENT> <NL> <INDENT> city = As [ city - 1 ] <NEWLINE> <DEDENT> print ( city ) <NEWLINE> <NL> <NL> <DEDENT> if N > K : <NEWLINE> <INDENT> compute ( 1 , K ) <NEWLINE> <NL> <DEDENT> cities_visited = [ False ] * N <NEWLINE> i = 0 <NEWLINE> city = 1 <NEWLINE> city_visited_time = { } <NEWLINE> <NL> while not cities_visited [ city - 1 ] : <NEWLINE> <COMMENT> <NL> <INDENT> cities_visited [ city - 1 ] = True <NEWLINE> city_visited_time [ city - 1 ] = i <NEWLINE> city = As [ city - 1 ] <NEWLINE> i += 1 <NEWLINE> <NL> <DEDENT> loop_start = city_visited_time [ city - 1 ] <NEWLINE> loop_end = i <NEWLINE> <NL> if loop_end - loop_start == 1 : <NEWLINE> <INDENT> return city <NEWLINE> <DEDENT> div = ( K - loop_start ) // ( loop_end - loop_start + 1 ) <NEWLINE> <COMMENT> <NL> compute ( city , K % ( loop_end - loop_start + 1 ) + loop_start + 1 ) <NEWLINE>
<NL> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> A = map ( int , input ( ) . split ( ) ) <NEWLINE> flag = [ True ] * n <NEWLINE> p = 0 <NEWLINE> rt = [ 1 ] <NEWLINE> <NL> while flag [ p ] : <NEWLINE> <INDENT> flag [ p ] = False <NEWLINE> p = A [ p ] - 1 <NEWLINE> rt . append ( p + 1 ) <NEWLINE> <NL> <DEDENT> to_p = rt . index ( rt [ - 1 ] ) <NEWLINE> p2p = rt [ to_p : - 1 ] <NEWLINE> p2p_len = len ( p2p ) <NEWLINE> <NL> if k < p2p_len : <NEWLINE> <INDENT> print ( rt [ k ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( p2p [ ( k - to_p ) % p2p_len ] ) <NEWLINE> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> l = [ ] * n <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> b = [ 0 , 0 ] <NEWLINE> b [ 0 ] += i + 1 <NEWLINE> b [ 1 ] += a [ i ] <NEWLINE> l . append ( b ) <NEWLINE> <DEDENT> c = 0 <NEWLINE> ne = 0 <NEWLINE> l1 = [ 0 ] * n <NEWLINE> while True : <NEWLINE> <INDENT> if c == k : <NEWLINE> <INDENT> print ( l [ ne ] [ 1 ] ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> ne += - ne + l [ ne ] [ 1 ] - 1 <NEWLINE> c += 1 <NEWLINE> if l1 [ ne ] == 0 : l1 [ ne ] += 1 <NEWLINE> else : <NEWLINE> <INDENT> roop_act += ne <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> roop_c = 0 <NEWLINE> while True : <NEWLINE> <INDENT> if c + roop_c == k : <NEWLINE> <INDENT> print ( l [ ne ] [ 1 ] ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> if l1 [ ne ] == 1 : l1 [ ne ] += 1 <NEWLINE> else : break <NEWLINE> ne += - ne + l [ ne ] [ 1 ] - 1 <NEWLINE> roop_c += 1 <NEWLINE> <NL> <DEDENT> re = ( k - c ) % roop_c <NEWLINE> if re == 0 : print ( l [ ne ] [ 0 ] ) <NEWLINE> else : <NEWLINE> <INDENT> for i in range ( re ) : <NEWLINE> <INDENT> if i == re - 1 : print ( l [ ne ] [ 1 ] ) <NEWLINE> ne += - ne + l [ ne ] [ 1 ] - 1 <NEWLINE> <DEDENT> <DEDENT>
def get_keys ( d , val ) : <NEWLINE> <INDENT> return [ k for k , v in d . items ( ) if v == val ] <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> read = lambda : sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> <NL> N , K = map ( int , read ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , read ( ) . split ( ) ) ) <NEWLINE> <NL> g = collections . defaultdict ( int ) <NEWLINE> for i , val in enumerate ( A ) : <NEWLINE> <INDENT> g [ i + 1 ] = val <NEWLINE> <NL> <DEDENT> v = collections . defaultdict ( int ) <NEWLINE> cnt = 0 <NEWLINE> cur = 1 <NEWLINE> p = 0 <NEWLINE> mp = 0 <NEWLINE> while True : <NEWLINE> <INDENT> if v [ cur ] > 0 : <NEWLINE> <INDENT> p = cnt - v [ cur ] <NEWLINE> mp = v [ cur ] <NEWLINE> break <NEWLINE> <DEDENT> v [ cur ] = cnt <NEWLINE> cnt += 1 <NEWLINE> cur = g [ cur ] <NEWLINE> <NL> <DEDENT> print ( get_keys ( v , ( K - mp ) % p + mp ) [ 0 ] if K >= mp else get_keys ( v , K ) [ 0 ] ) <NEWLINE> <NL> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> idx = a [ 0 ] <NEWLINE> hist = [ 1 ] <NEWLINE> flag = 0 <NEWLINE> for i , _ in enumerate ( range ( k ) , start = 1 ) : <NEWLINE> <INDENT> if idx in hist : <NEWLINE> <INDENT> hist . append ( idx ) <NEWLINE> flag = 1 <NEWLINE> break <NEWLINE> <DEDENT> hist . append ( idx ) <NEWLINE> idx = a [ idx - 1 ] <NEWLINE> <NL> <DEDENT> if flag : <NEWLINE> <INDENT> l_start2 , l_end2 = hist . index ( idx ) , i <NEWLINE> surplus = ( k - l_start ) % ( l_end - l_start ) <NEWLINE> print ( hist [ l_start + surplus ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( idx ) <NEWLINE> <DEDENT>
<COMMENT> <NL> from collections import Counter <NEWLINE> from copy import deepcopy <NEWLINE> import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> N , K = ( int ( x ) for x in input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> connection = { } <NEWLINE> for i , v in enumerate ( A ) : <NEWLINE> <INDENT> connection [ i + 1 ] = v <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> passed = [ 1 ] <NEWLINE> nex = connection [ 1 ] <NEWLINE> lap = [ ] <NEWLINE> lap_num = 0 <NEWLINE> pass_set = set ( ) <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> passed . append ( nex ) <NEWLINE> if nex not in pass_set : <NEWLINE> <INDENT> pass_set . add ( nex ) <NEWLINE> nex = connection [ nex ] <NEWLINE> <DEDENT> else : <NEWLINE> <COMMENT> <NL> <INDENT> break <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> indx_s = passed . index ( nex ) + 1 <NEWLINE> indx_f = len ( passed ) <NEWLINE> lap_num = indx_f - indx_s <NEWLINE> <NL> if indx_f < K : <NEWLINE> <INDENT> mod = ( K - indx_s ) % lap_num <NEWLINE> ans = passed [ indx_s + mod ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = passed [ K ] <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> using namespace std ; <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> using ll = long long ; <NEWLINE> using dd = long double ; <NEWLINE> <NL> const int D = 60 ; <NEWLINE> const int MAX_N = 20005 ; <NEWLINE> int to [ D ] [ MAX_N ] ; <NEWLINE> <NL> <NL> int main ( ) { <NEWLINE> <INDENT> int n ; <NEWLINE> ll k ; <NEWLINE> cin >> n >> k ; <NEWLINE> rep ( i , n ) { <NEWLINE> <INDENT> cin >> to [ 0 ] [ i ] ; <NEWLINE> to [ 0 ] [ i ] - - ; <NEWLINE> <DEDENT> } <NEWLINE> <NL> rep ( i , D - 1 ) rep ( j , n ) { <NEWLINE> <INDENT> to [ i + 1 ] [ j ] = to [ i ] [ to [ i ] [ j ] ] ; <NEWLINE> <DEDENT> } <NEWLINE> <NL> int v = 0 ; <NEWLINE> for ( int i = D - 1 ; i >= 0 ; - - i ) { <NEWLINE> <INDENT> ll l = 1 ll << i ; <NEWLINE> if ( l <= k ) { <NEWLINE> <INDENT> v = to [ i ] [ v ] ; <NEWLINE> k -= l ; <NEWLINE> <DEDENT> } <NEWLINE> <DEDENT> } <NEWLINE> cout << v + 1 << endl ; <NEWLINE> <NL> return 0 ; <NEWLINE> <DEDENT> } <NEWLINE> <NL>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> visited = [ 1 ] <NEWLINE> is_visited = [ 0 ] * n <NEWLINE> now = 1 <NEWLINE> step = 0 <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> now = a [ now - 1 ] <NEWLINE> step += 1 <NEWLINE> if is_visited [ now - 1 ] == 0 : <NEWLINE> <INDENT> is_visited [ now - 1 ] = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ind = visited . index ( now ) <NEWLINE> loop = visited [ ind : ] <NEWLINE> tmp = ( k - step ) % len ( loop ) <NEWLINE> now = loop [ tmp ] <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( now ) <NEWLINE>
import sys <NEWLINE> input = lambda : sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> INF = 10 ** 20 <NEWLINE> def I ( ) : return int ( input ( ) ) <NEWLINE> def F ( ) : return float ( input ( ) ) <NEWLINE> def S ( ) : return input ( ) <NEWLINE> def LI ( ) : return [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> def LI_ ( ) : return [ int ( x ) - 1 for x in input ( ) . split ( ) ] <NEWLINE> def LF ( ) : return [ float ( x ) for x in input ( ) . split ( ) ] <NEWLINE> def LS ( ) : return input ( ) . split ( ) <NEWLINE> <NL> def resolve ( ) : <NEWLINE> <INDENT> N , K = LI ( ) <NEWLINE> A = LI_ ( ) <NEWLINE> <NL> ord = [ - 1 ] * N <NEWLINE> <NL> city = 0 <NEWLINE> cnt = 0 <NEWLINE> teleport_path = [ ] <NEWLINE> while ord [ city ] == - 1 : <NEWLINE> <INDENT> ord [ city ] = cnt <NEWLINE> teleport_path . append ( city ) <NEWLINE> city = A [ city ] <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> loop_head = ord [ city ] <NEWLINE> loop_length = len ( teleport_path ) - loop_head <NEWLINE> <COMMENT> <NL> <NL> if K - 1 < loop_head : <NEWLINE> <INDENT> print ( teleport_path [ K ] + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> K = loop_head + ( K - loop_head ) % loop_length <NEWLINE> print ( teleport_path [ K ] + 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> r <NEWLINE> <DEDENT>
import sys <NEWLINE> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> vis = { 0 : 0 } <NEWLINE> now = 0 <NEWLINE> for i in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> now = a [ now ] - 1 <NEWLINE> if now in vis : <NEWLINE> <INDENT> bgn = vis . index ( now ) <NEWLINE> print ( vis [ bgn + ( ( k - bgn ) % ( len ( vis ) - bgn ) ) ] + 1 ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> vis [ i ] = now <NEWLINE> <DEDENT> <DEDENT> print ( vis [ - 1 ] + 1 ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> num = [ 0 for i in range ( n ) ] <NEWLINE> first = [ 0 for i in range ( n ) ] <NEWLINE> first [ 0 ] = 1 <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a [ i ] -= 1 <NEWLINE> <DEDENT> num [ 0 ] = 1 <NEWLINE> loop = 0 <NEWLINE> s = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if num [ a [ s ] ] == 0 : <NEWLINE> <INDENT> num [ a [ s ] ] += 1 <NEWLINE> first [ a [ s ] ] = i <NEWLINE> <DEDENT> if num [ a [ s ] ] == 2 : <NEWLINE> <INDENT> loop1 = loop <NEWLINE> break <NEWLINE> <DEDENT> s = a [ s ] <NEWLINE> <NL> <DEDENT> kai = first [ a [ s ] ] + ( k - first [ a [ s ] ] ) % ( loop1 - first [ a [ s ] ] ) <NEWLINE> s = 0 <NEWLINE> for i in range ( kai ) : <NEWLINE> <INDENT> s = a [ s ] <NEWLINE> <DEDENT> print ( s + 1 ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ int ( i ) - 1 for i in input ( ) . split ( ) ] <NEWLINE> loc = 0 <NEWLINE> cnt1 = 0 <NEWLINE> seen = [ False ] * n <NEWLINE> seen [ 0 ] = True <NEWLINE> while not seen [ loc ] : <NEWLINE> <INDENT> loc = a [ loc ] <NEWLINE> cnt1 += 1 <NEWLINE> if cnt1 == k : <NEWLINE> <INDENT> print ( loc + 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> cnt2 = 0 <NEWLINE> x = loc <NEWLINE> while loc != x : <NEWLINE> <INDENT> loc = a [ loc ] <NEWLINE> cnt2 += 1 <NEWLINE> <DEDENT> cnt1 -= cnt2 <NEWLINE> k = ( k - cnt1 ) % cnt2 <NEWLINE> loc = 0 <NEWLINE> while k > 0 : <NEWLINE> <INDENT> loc = a [ loc ] <NEWLINE> k -= 1 <NEWLINE> <DEDENT> print ( loc + 1 ) <NEWLINE>
from collections import deque <NEWLINE> import numpy as np <NEWLINE> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> An = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> root = deque ( [ 1 ] ) <NEWLINE> check = np . zeros ( n , np . int ) <NEWLINE> check [ 0 ] = 1 <NEWLINE> i = 0 <NEWLINE> dup = 1 <NEWLINE> cnt = 1 <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> temp = An [ i ] <NEWLINE> if check [ temp - 1 ] == 1 : <NEWLINE> <INDENT> dup = temp <NEWLINE> break <NEWLINE> <DEDENT> root . append ( temp ) <NEWLINE> check [ temp - 1 ] = 1 <NEWLINE> i = temp - 1 <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> index = root . index ( dup ) <NEWLINE> if index <= k : <NEWLINE> <INDENT> print ( root [ k - 1 ] ) <NEWLINE> <DEDENT> elif index == cnt - 1 : <NEWLINE> <INDENT> print ( dup ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( root [ ( k - index ) % ( cnt - index ) + index ] ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> As = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> route = [ 0 ] <NEWLINE> pre = 0 <NEWLINE> i = 0 <NEWLINE> r_append = route . append <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> i = As [ i ] - 1 <NEWLINE> if i in route : <NEWLINE> <INDENT> pre = route . index ( i ) <NEWLINE> route = route [ pre : ] <NEWLINE> break <NEWLINE> <DEDENT> r_append ( i ) <NEWLINE> len_route += 1 <NEWLINE> <COMMENT> <NL> <DEDENT> mod = len ( route ) <NEWLINE> print ( route [ ( K - pre ) % mod ] + 1 ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> timestamp = [ 0 ] * n <NEWLINE> position = 1 <NEWLINE> period = 0 <NEWLINE> start = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if timestamp [ position - 1 ] != 0 : <NEWLINE> <INDENT> start = timestamp [ position - 1 ] <NEWLINE> period = i - timestamp [ position - 1 ] <NEWLINE> break <NEWLINE> <DEDENT> timestamp [ position - 1 ] = i <NEWLINE> position = a [ position - 1 ] <NEWLINE> <DEDENT> print ( period , start ) <NEWLINE> <NL> <NL> if k <= start : <NEWLINE> <INDENT> position = 1 <NEWLINE> for i in range ( k - 1 ) : <NEWLINE> <INDENT> position = a [ position - 1 ] <NEWLINE> <DEDENT> print ( position ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> cycle = ( k - start ) % period <NEWLINE> for i in range ( cycle ) : <NEWLINE> <INDENT> position = a [ position - 1 ] <NEWLINE> <DEDENT> print ( position ) <NEWLINE> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> l = [ 1 ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> l . append ( a [ l [ i ] ] ) <NEWLINE> <NL> <DEDENT> p = l . index ( l [ - 1 ] ) <NEWLINE> if k <= n : <NEWLINE> <INDENT> print ( l [ k ] ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> x = ( k - n + 1 ) % ( n - p ) <NEWLINE> if x == 0 : <NEWLINE> <INDENT> print ( l [ n - 1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( l [ x + p - 1 ] ) <NEWLINE> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> d = { } <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> d [ i ] = a [ i - 1 ] <NEWLINE> <NL> <DEDENT> did = set ( 1 ) <NEWLINE> route = [ 1 ] <NEWLINE> <NL> now = 1 <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> now = d [ now ] <NEWLINE> route . append ( now ) <NEWLINE> if now in did : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> did . add ( now ) <NEWLINE> <NL> <DEDENT> if k < 10 ** 6 : <COMMENT> <NEWLINE> <INDENT> now = 1 <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> now = d [ now ] <NEWLINE> <NL> <DEDENT> print ( now ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( len ( route ) ) : <NEWLINE> <INDENT> if route [ i ] == route [ - 1 ] : <NEWLINE> <INDENT> roop = route [ i : - 1 ] <NEWLINE> print ( roop [ ( k - i ) % len ( roop ) ] ) <NEWLINE> exit ( ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT>
Town = [ ] <NEWLINE> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> vis = [ 0 ] * N <NEWLINE> p = 1 <NEWLINE> while vis [ p - 1 ] == 0 : <NEWLINE> <INDENT> Town . append ( p ) <NEWLINE> vis [ p - 1 ] = 1 <NEWLINE> p = A [ p - 1 ] <NEWLINE> <NL> <DEDENT> l = Town . index [ p ] <NEWLINE> <NL> if K < len ( Town ) : <NEWLINE> <INDENT> print ( Town [ K ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( Town [ l + ( K - l ) % ( len ( Town [ l : ] ) ) ] ) <NEWLINE> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , list ( input ( ) . split ( ) ) ) ) <NEWLINE> <NL> exist = [ a [ 0 ] ] <NEWLINE> ex = { } <NEWLINE> <NL> cnt = 1 <NEWLINE> while ( True ) : <NEWLINE> <INDENT> if a [ exist [ - 1 ] - 1 ] in ex : <NEWLINE> <INDENT> idx = exist . index ( a [ exist [ - 1 ] - 1 ] ) <NEWLINE> exist . append ( a [ exist [ - 1 ] - 1 ] ) <NEWLINE> break <NEWLINE> <DEDENT> exist . append ( a [ exist [ - 1 ] - 1 ] ) <NEWLINE> ex [ a [ exist [ - 1 ] - 1 ] ] = 0 <NEWLINE> <NL> cnt += 1 <NEWLINE> if cnt >= k - 1 : <NEWLINE> <INDENT> print ( exist [ - 1 ] ) <NEWLINE> exit ( ) <NEWLINE> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> d = ( k - idx ) % ( cnt - idx ) <NEWLINE> <NL> print ( exist [ d + idx - 1 ] ) <NEWLINE>
a , b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> itta2 = set ( [ ] ) <NEWLINE> mati = 1 <NEWLINE> i = 0 <NEWLINE> itta = [ ] <NEWLINE> t0 = time . time ( ) <NEWLINE> while True : <NEWLINE> <INDENT> if mati in itta2 : <NEWLINE> <INDENT> saisyo = mati <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> itta2 . add ( mati ) <NEWLINE> itta . append ( mati ) <NEWLINE> mati = c [ mati - 1 ] <NEWLINE> i += 1 <NEWLINE> <DEDENT> <DEDENT> print ( time . time ( ) - t0 ) <NEWLINE> risuto2 = set ( [ ] ) <NEWLINE> risuto = [ ] <NEWLINE> t0 = time . time ( ) <NEWLINE> <NL> while True : <NEWLINE> <INDENT> if mati in risuto2 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> risuto2 . add ( mati ) <NEWLINE> risuto . append ( mati ) <NEWLINE> mati = c [ mati - 1 ] <NEWLINE> <DEDENT> <DEDENT> print ( time . time ( ) - t0 ) <NEWLINE> if b <= i - 1 : <NEWLINE> <INDENT> print ( itta [ b ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( risuto [ ( b - i ) % len ( risuto ) ] ) <NEWLINE> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = tuple ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> L = [ 0 for i in range ( N + 1 ) ] <NEWLINE> L [ 1 ] = 1 <NEWLINE> x = 1 <NEWLINE> t = 1 <NEWLINE> while K > 0 : <NEWLINE> <INDENT> t += 1 <NEWLINE> K -= 1 <NEWLINE> x = A [ x ] <NEWLINE> if L [ x ] != 0 : <NEWLINE> <INDENT> p = t - L [ x ] <NEWLINE> K %= p <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> L [ x ] = t <NEWLINE> <NL> <DEDENT> <DEDENT> while K > 0 : <NEWLINE> <INDENT> x = A [ x ] <NEWLINE> K -= 1 <NEWLINE> <DEDENT> print ( x ) <NEWLINE>
<COMMENT> <NL> <NL> from fractions import gcd <NEWLINE> <COMMENT> <NL> from collections import Counter , deque , defaultdict <NEWLINE> from heapq import heappush , heappop , heappushpop , heapify , heapreplace , merge <NEWLINE> from bisect import bisect_left , bisect_right , bisect , insort_left , insort_right , insort <NEWLINE> from itertools import accumulate , product , permutations , combinations , combinations_with_replacement <NEWLINE> <NL> N , K = [ int ( _ ) for _ in input ( ) . split ( ) ] <NEWLINE> A = [ int ( _ ) for _ in input ( ) . split ( ) ] <NEWLINE> <NL> flag = 0 <NEWLINE> done = [ 0 ] * ( N + 1 ) <NEWLINE> <NL> root = [ ] <NEWLINE> ind = 0 <NEWLINE> <NL> ind = A [ 0 ] <NEWLINE> root = [ 1 ] <NEWLINE> done [ 1 ] = 1 <NEWLINE> <NL> while True : <NEWLINE> <NL> <INDENT> if done [ ind ] : <NEWLINE> <INDENT> flag = 1 <NEWLINE> break <NEWLINE> <DEDENT> done [ ind ] = 1 <NEWLINE> <NL> root += [ ind ] <NEWLINE> ind = A [ ind - 1 ] <NEWLINE> <NL> <DEDENT> if flag : <NEWLINE> <INDENT> if len ( root ) < K : <NEWLINE> <INDENT> left = root . index ( ind ) - 1 <NEWLINE> loopcnt = len ( root ) - ( root . index ( ind ) ) <NEWLINE> <NL> root2 = root [ left + 1 : ] <NEWLINE> print ( root2 [ ( K - ( left + 1 ) ) % loopcnt ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( root [ K ] ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( root [ K - 1 ] ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ 0 ] <NEWLINE> A += list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A = np . array ( A ) <NEWLINE> <NL> s_time = time . time ( ) <NEWLINE> i = 1 <NEWLINE> pas = np . zeros ( N ) <NEWLINE> pas [ 0 ] = i <NEWLINE> k = 1 <NEWLINE> pass_set = set ( pas ) <NEWLINE> while k <= K : <NEWLINE> <INDENT> if A [ i ] in pass_set : <NEWLINE> <INDENT> rps = np . where ( pas == ( A [ i ] ) ) [ 0 ] <NEWLINE> ans = A [ i ] <NEWLINE> break <NEWLINE> <DEDENT> pas [ k ] = A [ i ] <NEWLINE> pass_set . add ( A [ i ] ) <NEWLINE> ans = A [ i ] <NEWLINE> i = A [ i ] <NEWLINE> k += 1 <NEWLINE> <NL> <DEDENT> if k >= K : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> rpnum = ( K - rps [ 0 ] ) % ( k - rps ) <NEWLINE> print ( int ( pas [ rps [ 0 ] + rpnum ] ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> main ( ) <NEWLINE>
n , k = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> a = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> <NL> visited = [ - 1 for i in range ( n + 1 ) ] <COMMENT> <NEWLINE> points = [ ] <NEWLINE> order = { } <NEWLINE> x = 1 <NEWLINE> T = - 1 <NEWLINE> <NL> while visited [ x ] == - 1 : <NEWLINE> <INDENT> x = a [ x - 1 ] <COMMENT> <NEWLINE> points . append ( x ) <NEWLINE> visited [ x ] = len ( points ) <NEWLINE> <DEDENT> T = len ( points ) - visited [ x ] <NEWLINE> s = visited [ x ] <NEWLINE> if k < s : <NEWLINE> <INDENT> print ( points [ k ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> k -= s <NEWLINE> mod = k % T <NEWLINE> print ( points [ s + mod ] ) <NEWLINE> <DEDENT>
6 727202214173249351 <NEWLINE> 6 5 2 5 3 2 <NEWLINE> n , k = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> a = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> s = [ ] <NEWLINE> o = [ - 1 ] * ( n + 1 ) <COMMENT> <NEWLINE> c , l = 1 , 0 <COMMENT> <NEWLINE> <NL> v = 1 <NEWLINE> while o [ v ] == - 1 : <NEWLINE> <INDENT> o [ v ] = len ( s ) <NEWLINE> s . append ( v ) <NEWLINE> v = a [ v - 1 ] <NEWLINE> <DEDENT> c = len ( s ) - o [ v ] <NEWLINE> l = o [ v ] <NEWLINE> <NL> if k < l : <NEWLINE> <INDENT> print ( s [ k ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> k -= l <NEWLINE> k %= c <NEWLINE> print ( s [ l + k ] ) <NEWLINE> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ 0 ] + list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> def bin ( arr , val ) : <NEWLINE> <INDENT> left , right = 0 , len ( arr ) - 1 <NEWLINE> while left <= right : <NEWLINE> <INDENT> mid = ( left + right ) // 2 <NEWLINE> if arr [ mid ] == val : return 1 <NEWLINE> elif arr [ mid ] < val : left = mid + 1 <NEWLINE> else : right = mid - 1 <NEWLINE> <DEDENT> return 0 <NEWLINE> <NL> <DEDENT> know = [ ] <NEWLINE> now = 1 <NEWLINE> while not bin ( know , now ) : <NEWLINE> <INDENT> know . append ( now ) <NEWLINE> now = a [ now ] <NEWLINE> <NL> <DEDENT> start = a [ know [ - 1 ] ] <NEWLINE> for i , num in enumerate ( know ) : <NEWLINE> <INDENT> if num == start : loop = know [ i : ] ; break <NEWLINE> <NL> <COMMENT> <NL> <NL> <DEDENT> if k < len ( know ) : <NEWLINE> <INDENT> ans = know [ k ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> k - = len ( know ) <NEWLINE> ans = know [ k % len ( loop ) ] <NEWLINE> <NL> <NL> <DEDENT> print ( ans ) <NEWLINE>
sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> <NL> def teleport ( city , end , teleportmap , count = 1 ) : <NEWLINE> <NL> <INDENT> next_city = teleportmap [ city ] <NEWLINE> <NL> if count == end : <NEWLINE> <INDENT> return next_city <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> return teleport ( next_city , end , teleportmap , count + 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> teleportmap = dict ( zip ( range ( 1 , len ( a ) + 1 ) , a ) ) <NEWLINE> <NL> if k <= n : <NEWLINE> <INDENT> print ( teleport ( 1 , n , teleportmap ) ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> countmap = [ 0 ] * n <NEWLINE> countmap [ 0 ] = 1 <NEWLINE> <NL> next_city = 1 <NEWLINE> for _ in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> next_city = a [ next_city - 1 ] <NEWLINE> countmap [ next_city - 1 ] += 1 <NEWLINE> if countmap [ next_city - 1 ] == 2 : <NEWLINE> <INDENT> start = next_city <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> roop = { } <NEWLINE> for j in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> roop [ start ] = teleportmap [ start ] <NEWLINE> start = roop [ start ] <NEWLINE> <NL> <DEDENT> num_r = len ( roop ) <NEWLINE> <NL> num_until_r = 0 <NEWLINE> for m in teleportmap . keys ( ) : <NEWLINE> <INDENT> if m not in roop and countmap [ m - 1 ] != 0 : <NEWLINE> <INDENT> num_until_r += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> k_r = k - num_until_r <NEWLINE> num_end = k_r % num_r <NEWLINE> <NL> if num_end == 0 : <NEWLINE> <INDENT> print ( next_city ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> print ( teleport ( next_city , num_end , roop ) ) <NEWLINE> <DEDENT> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> p = a [ 0 ] <NEWLINE> s = a [ 0 ] <NEWLINE> g = [ ] <NEWLINE> q = [ ] <NEWLINE> for i in range ( n + 1 ) : <NEWLINE> <INDENT> g . append ( p ) <NEWLINE> p = a [ p - 1 ] <NEWLINE> <DEDENT> for i in range ( len ( g ) ) : <NEWLINE> <INDENT> if g [ i ] == g [ i ] + mod <NEWLINE> <DEDENT> g . reverse ( ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if g [ 0 ] == g [ i + 1 ] : <NEWLINE> <INDENT> mod = i + 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> g . reverse ( ) <NEWLINE> for i in range ( len ( g ) ) : <NEWLINE> <INDENT> if g [ i ] == g [ i ] + mod : <NEWLINE> <INDENT> d = i <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if k <= mod : <NEWLINE> <INDENT> for i in range ( k % mod ) : <NEWLINE> <INDENT> q . append ( s ) <NEWLINE> s = a [ s - 1 ] <NEWLINE> <DEDENT> q . reverse ( ) <NEWLINE> q . append ( 1 ) <NEWLINE> print ( q [ 0 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( g [ d + ( k - d ) % mod ] ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> N , M , X = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ ] <NEWLINE> C = [ ] <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> c , * a = map ( int , input ( ) . split ( ) ) <NEWLINE> C . append ( c ) <NEWLINE> A . append ( a ) <NEWLINE> <DEDENT> A = np . array ( A , dtype = int ) <NEWLINE> ans = 10 ** 7 <NEWLINE> for bit in range ( 2 ** N ) : <NEWLINE> <INDENT> B = np . zeros ( M , dtype = int ) <NEWLINE> cost = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if bit & ( 1 << i ) : <NEWLINE> <INDENT> B += A [ i ] <NEWLINE> cost += C [ i ] <NEWLINE> <DEDENT> <DEDENT> if np . all ( B >= X ) : <NEWLINE> <INDENT> ans = min ( ans , cost ) <NEWLINE> <DEDENT> <DEDENT> print ( ans if ans < 10 ** 7 else - 1 ) <NEWLINE>
dic = { } <NEWLINE> for key , a in zip ( range ( 1 , n + 1 ) , list ( map ( int , input ( ) . split ( ) ) ) ) : <NEWLINE> <INDENT> dic [ key ] = a <NEWLINE> <NL> <DEDENT> keynum = 0 <NEWLINE> log = [ - 1 ] * ( n + 1 ) <NEWLINE> next = dic [ 1 ] <NEWLINE> step = 1 <NEWLINE> log [ next ] = step <NEWLINE> k -= 1 <NEWLINE> while k : <NEWLINE> <INDENT> next = dic [ next ] <NEWLINE> step += 1 <NEWLINE> k -= 1 <NEWLINE> if log [ next ] != - 1 : <NEWLINE> <INDENT> k %= log [ next ] - step <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> log [ next ] = step <NEWLINE> <DEDENT> <DEDENT> print ( next ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = [ 1 ] + a <NEWLINE> def next ( i ) : <NEWLINE> <INDENT> return a [ i ] <NEWLINE> <NL> <DEDENT> z = [ 0 ] * ( n + 1 ) <NEWLINE> <NL> place = 1 <NEWLINE> T = 0 <NEWLINE> interval = 0 <NEWLINE> if k < n : <NEWLINE> <INDENT> for i in range ( k ) : <NEWLINE> <INDENT> place = next ( place ) <NEWLINE> <DEDENT> print ( place ) ; exit ( ) <NEWLINE> <DEDENT> place = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> place = next ( place ) <NEWLINE> if z [ place ] != 0 : <NEWLINE> <INDENT> interval = T - z [ place ] <NEWLINE> break <NEWLINE> <DEDENT> z [ place ] = T <NEWLINE> T += 1 <NEWLINE> <DEDENT> m = ( k - z [ place ] ) % interval <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> place = next ( place ) <NEWLINE> <DEDENT> print ( place ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( lambda x : int ( x ) - 1 , input ( ) . split ( ) ) ) <NEWLINE> <NL> cnts = [ None ] * N <NEWLINE> <NL> pos = 0 <NEWLINE> cnt = 0 <NEWLINE> <NL> while cnt < K : <NEWLINE> <INDENT> if cnts [ pos ] != None : <NEWLINE> <INDENT> loop_size = cnt - cnts [ pos ] <NEWLINE> cnt += ( ( K - cnt ) // loop_size - 1 ) * loop_size <NEWLINE> cnts = [ None ] * N <NEWLINE> <DEDENT> cnts [ pos ] = cnt <NEWLINE> pos = A [ pos ] <NEWLINE> cnt += 1 <NEWLINE> <NL> <DEDENT> print ( pos + 1 ) <NEWLINE>
<COMMENT> <NL> n , k = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> rem = k <NEWLINE> nxt = 1 <NEWLINE> visit = [ ] <NEWLINE> visit_set = { } <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> visit . append ( nxt ) <NEWLINE> visit_set . add ( nxt ) <NEWLINE> nxt = a [ nxt - 1 ] <NEWLINE> <COMMENT> <NL> if nxt in visit_set : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> rem -= 1 <NEWLINE> <NL> <DEDENT> if rem == 0 : <NEWLINE> <INDENT> print ( nxt ) <NEWLINE> <DEDENT> else : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <INDENT> loops = visit [ visit . index ( nxt ) : ] <NEWLINE> print ( loops [ ( rem - 1 ) % len ( loops ) ] ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> a = [ 0 ] * n <NEWLINE> <NL> a = [ int ( s ) for s in input ( ) . split ( ) ] <NEWLINE> <NL> nxt = a [ 0 ] <NEWLINE> <NL> seen = [ 0 ] * n <NEWLINE> seen [ 0 ] = 1 <NEWLINE> <COMMENT> <NL> res = 0 <NEWLINE> flag = 0 <NEWLINE> for i in range ( k - 1 ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <INDENT> if not ( nxt in seen and i > n ) : <NEWLINE> <INDENT> seen [ i + 1 ] = nxt <NEWLINE> nxt = a [ nxt - 1 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> root = i - seen . index ( nxt ) + 1 <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> zansa = ( k - 1 - i ) % root <NEWLINE> res = seen [ seen . index ( nxt ) + zansa ] <NEWLINE> flag = 1 <NEWLINE> break <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if ( flag == 1 ) : <NEWLINE> <INDENT> print ( res ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( nxt ) <NEWLINE> <DEDENT>
class Combination ( ) : <NEWLINE> <INDENT> def __init__ ( self , n , mod = 10 ** 9 + 7 ) : <NEWLINE> <INDENT> self . mod = mod <NEWLINE> self . fac = [ 1 ] * ( n + 1 ) <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> self . fac [ i ] = self . fac [ i - 1 ] * i % self . mod <NEWLINE> <DEDENT> self . invfac = [ 1 ] * ( n + 1 ) <NEWLINE> self . invfac [ n ] = pow ( self . fac [ n ] , self . mod - 2 , self . mod ) <NEWLINE> for i in range ( n - 1 , 0 , - 1 ) : <NEWLINE> <INDENT> self . invfac [ i ] = self . invfac [ i + 1 ] * ( i + 1 ) % self . mod <NEWLINE> <NL> <DEDENT> <DEDENT> def combination ( self , n , r ) : <NEWLINE> <INDENT> ans = self . fac [ n ] * self . invfac [ r ] % self . mod * self . invfac [ n - r ] % self . mod <NEWLINE> if n >= r : <NEWLINE> <INDENT> return ans <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return 0 <NEWLINE> <NL> <DEDENT> <DEDENT> def factorial ( self , i ) : <NEWLINE> <INDENT> return self . fac [ i ] <NEWLINE> <NL> <DEDENT> def invfactorial ( self , i ) : <NEWLINE> <INDENT> return self . invfac [ i ] <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <INDENT> import sys <NEWLINE> def input ( ) : return sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> mod = 998244353 <NEWLINE> c = Combination ( n , mod ) <NEWLINE> ans = 0 <NEWLINE> mex = [ 0 ] * ( k + 1 ) <NEWLINE> mex [ 0 ] = pow ( m - 1 , n - k - 1 , mod ) <NEWLINE> for i in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> mod [ i ] = mex [ i - 1 ] * ( m - 1 ) % mod <NEWLINE> <DEDENT> mex = mex [ : : - 1 ] <NEWLINE> for i in range ( k + 1 ) : <NEWLINE> <INDENT> ans += c . combination ( n - 1 , i ) * mex [ i ] <NEWLINE> ans %= mod <NEWLINE> <DEDENT> ans *= m <NEWLINE> ans %= mod <NEWLINE> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> N , M , K = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> res = [ 0 ] * ( K + 1 ) <NEWLINE> res [ 0 ] = ( M * ( M - 1 ) ** ( N - 1 - K ) ) % p <NEWLINE> p = 998244353 <NEWLINE> for n in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> res [ n ] = ( res [ n - 1 ] * ( N - n ) * pow ( n , p - 2 , p ) ) % p <NEWLINE> <NL> <DEDENT> print ( sum ( res ) % p ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <NL> n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> def cmb ( n , r , p ) : <NEWLINE> <INDENT> if ( r < 0 ) or ( n < r ) : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> r = min ( r , n - r ) <NEWLINE> return fact [ n ] * factinv [ r ] * factinv [ n - r ] % p <NEWLINE> <NL> <DEDENT> p = 998244353 <NEWLINE> N = n + 1 <COMMENT> <NEWLINE> fact = [ 1 , 1 ] <COMMENT> <NEWLINE> factinv = [ 1 , 1 ] <COMMENT> <NEWLINE> inv = [ 0 , 1 ] <COMMENT> <NEWLINE> <NL> for i in range ( 2 , N + 1 ) : <NEWLINE> <INDENT> fact . append ( ( fact [ - 1 ] * i ) % p ) <NEWLINE> inv . append ( ( - inv [ p % i ] * ( p // i ) ) % p ) <NEWLINE> factinv . append ( ( factinv [ - 1 ] * inv [ - 1 ] ) % p ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> beki = [ 1 , m - 1 ] <NEWLINE> for i in range ( 2 , N + 1 ) : <NEWLINE> <INDENT> beki . append ( ( ( beki [ - 1 ] * ( m - 1 ) ) % p ) ) <NEWLINE> <NL> <DEDENT> for x in range ( k + 1 ) : <NEWLINE> <INDENT> ans += m * beki [ n - x - 1 ] % p * cmb ( n - 1 , x , p ) ) % p <NEWLINE> ans = ans % p <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> <NL> N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> def combinations ( n , r ) : <NEWLINE> <INDENT> return math . factorial ( n ) // ( math . factorial ( n - r ) * math . factorial ( r ) ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> col = m <NEWLINE> for k in range ( N - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> now = col <NEWLINE> now *= combinations ( N - 1 , k ) ; <NEWLINE> if k <= K : <NEWLINE> <INDENT> ans += now <NEWLINE> <DEDENT> col *= m - 1 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> import itertools <NEWLINE> import numpy as np <NEWLINE> <NL> MOD = 998244353 <NEWLINE> MAX = 10 ** 5 * 2 + 5 <NEWLINE> <NL> fac = [ 0 for i in range ( MAX ) ] <NEWLINE> finv = [ 0 for i in range ( MAX ) ] <NEWLINE> inv = [ 0 for i in range ( MAX ) ] <NEWLINE> <NL> def comInit ( mod ) : <NEWLINE> <INDENT> fac [ 0 ] , fac [ 1 ] = 1 , 1 <NEWLINE> finv [ 0 ] , finv [ 1 ] = 1 , 1 <NEWLINE> inv [ 1 ] = 1 <NEWLINE> for i in range ( 2 , MAX ) : <NEWLINE> <INDENT> fac [ i ] = fac [ i - 1 ] * i % mod <NEWLINE> inv [ i ] = mod - inv [ mod % i ] * ( mod // i ) % mod <NEWLINE> finv [ i ] = finv [ i - 1 ] * inv [ i ] % mod <NEWLINE> <NL> <DEDENT> <DEDENT> def com ( n , r , mod ) : <NEWLINE> <INDENT> if n < r : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> if n < 0 or r < 0 : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> return fac [ n ] * ( finv [ r ] * finv [ n - r ] % mod ) % mod <NEWLINE> <NL> <DEDENT> comInit ( MOD ) <NEWLINE> <NL> read = sys . stdin . buffer . read <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> readlines = sys . stdin . buffer . readlines <NEWLINE> <NL> n , m , k = map ( int , readline ( ) . split ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> for x in range ( k , - 1 , - 1 ) : <NEWLINE> <INDENT> ans += now * com ( n - 1 , x , MOD ) % MOD <NEWLINE> <COMMENT> <NL> <DEDENT> print ( ans % MOD ) <NEWLINE>
def inverse_mod ( a , mod = 10 ** 9 + 7 ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> return pow ( a , mod - 2 , mod ) <NEWLINE> <NL> <NL> <DEDENT> def combination_mod ( n , r , mod = 10 ** 9 + 7 ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> <NL> r = min ( r , n - r ) <NEWLINE> numerator = denominator = 1 <NEWLINE> for i in range ( r ) : <NEWLINE> <INDENT> numerator = numerator * ( n - i ) % mod <NEWLINE> denominator = denominator * ( i + 1 ) % mod <NEWLINE> <NL> <DEDENT> return numerator * inverse_mod ( denominator , mod ) % mod <NEWLINE> <NL> <NL> <DEDENT> def create_inverses_list ( n , mod ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> <NL> inv_list = [ 1 ] * ( n + 1 ) <NEWLINE> for x in range ( n + 1 ) : <NEWLINE> <INDENT> inv_list [ x ] = ( - ( mod // x ) * inv_list [ mod % x ] ) % mod <NEWLINE> <NL> <DEDENT> return inv_list <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> n_blocks , n_colors , n_max_pairs = map ( int , input ( ) . split ( ) ) <NEWLINE> mod = 998244353 <NEWLINE> <NL> inverses = create_inverses_list ( n_max_pairs , mod ) <NEWLINE> <NL> e1 = n_colors * pow ( n_colors - 1 , n_blocks - 1 , mod ) <NEWLINE> e2 = 1 <NEWLINE> total = e1 * e2 % mod <NEWLINE> <NL> for k in range ( 1 , n_max_pairs + 1 ) : <NEWLINE> <INDENT> e1 = e1 * inverses [ n_colors - 1 ] % mod <NEWLINE> e2 = e2 * ( n_blocks - k ) % mod * inverses [ k ] % mod <NEWLINE> total += e1 * e2 % mod <NEWLINE> total %= mod <NEWLINE> <NL> <DEDENT> print ( total ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import sys , bisect , math , itertools , string , queue , copy <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> from collections import Counter , defaultdict , deque <NEWLINE> from itertools import permutations , combinations <NEWLINE> from heapq import heappop , heappush <NEWLINE> from fractions import gcd <NEWLINE> <COMMENT> <NL> sys . setrecursionlimit ( 10 ** 8 ) <NEWLINE> mod = 998244353 <NEWLINE> def inp ( ) : return int ( input ( ) ) <NEWLINE> def inpm ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def inpl ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> def inpls ( ) : return list ( input ( ) . split ( ) ) <NEWLINE> def inplm ( n ) : return list ( int ( input ( ) ) for _ in range ( n ) ) <NEWLINE> def inplL ( n ) : return [ list ( input ( ) ) for _ in range ( n ) ] <NEWLINE> def inplT ( n ) : return [ tuple ( input ( ) ) for _ in range ( n ) ] <NEWLINE> def inpll ( n ) : return [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ] <NEWLINE> def inplls ( n ) : return sorted ( [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ] ) <NEWLINE> <NL> def extgcd ( a , b ) : <NEWLINE> <INDENT> r = [ 1 , 0 , a ] <NEWLINE> w = [ 0 , 1 , b ] <NEWLINE> while w [ 2 ] != 1 : <NEWLINE> <INDENT> q = r [ 2 ] // w [ 2 ] <NEWLINE> r2 = w <NEWLINE> w2 = [ r [ 0 ] - q * w [ 0 ] , r [ 1 ] - q * w [ 1 ] , r [ 2 ] - q * w [ 2 ] ] <NEWLINE> r = r2 <NEWLINE> w = w2 <NEWLINE> <DEDENT> return [ w [ 0 ] , w [ 1 ] ] <NEWLINE> <DEDENT> def mod_inv ( a , m ) : <NEWLINE> <INDENT> x = extgcd ( a , m ) [ 0 ] <NEWLINE> return ( m + x % m ) % m <NEWLINE> <NL> <DEDENT> def nCk ( n , k ) : <NEWLINE> <INDENT> res = 1 <NEWLINE> a = n - k <NEWLINE> b = k <NEWLINE> for i in range ( 1 , a + b + 1 ) : <NEWLINE> <INDENT> res = res * i % mod <NEWLINE> <DEDENT> for i in range ( 1 , a + 1 ) : <NEWLINE> <INDENT> res = res * mod_inv ( i , mod ) % mod <NEWLINE> <DEDENT> for i in range ( 1 , b + 1 ) : <NEWLINE> <INDENT> res = res * mod_inv ( i , mod ) % mod <NEWLINE> <DEDENT> return res <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> n , m , k = inpm ( ) <NEWLINE> if k == 0 : <NEWLINE> <INDENT> print ( ( m * pow ( m - 1 , n - 1 , mod ) ) % mod ) <NEWLINE> return <NEWLINE> <DEDENT> ans = 0 <NEWLINE> a = ( m * pow ( m - 1 , n - 1 , mod ) ) % mod <NEWLINE> b = 1 <NEWLINE> x = mod_inv ( m - 1 , mod ) <NEWLINE> for i in range ( k + 1 ) : <NEWLINE> <INDENT> ans += ( a * b ) % mod <NEWLINE> ans %= mod <NEWLINE> a = a * x % mod <NEWLINE> b = b * ( n - 1 - i ) % mod <NEWLINE> b = b * mod_inv ( i + 1 , mod ) % mod <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> def main ( ) : <NEWLINE> <INDENT> import sys <NEWLINE> imput = sys . stdin . readline <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <COMMENT> <NL> mod = 998244353 <NEWLINE> <NL> n_ = 4 * 10 ** 5 + 5 <NEWLINE> fun = [ 1 ] * ( n_ + 1 ) <NEWLINE> for i in range ( 1 , n_ + 1 ) : <NEWLINE> <INDENT> fun [ i ] = fun [ i - 1 ] * i % mod <NEWLINE> <DEDENT> rev = [ 1 ] * ( n_ + 1 ) <NEWLINE> rev [ n_ ] = pow ( fun [ n_ ] , mod - 2 , mod ) <NEWLINE> for i in range ( n_ - 1 , 0 , - 1 ) : <NEWLINE> <INDENT> rev [ i ] = rev [ i + 1 ] * ( i + 1 ) % mod <NEWLINE> <DEDENT> def cmb ( n , r ) : <NEWLINE> <INDENT> if n <= 0 or r < 0 or r > n : return 0 <NEWLINE> return fun [ n ] * rev [ r ] % mod * rev [ n - r ] % mod <NEWLINE> <NL> <DEDENT> answer = 0 <NEWLINE> for i in range ( K + 1 ) : <NEWLINE> <INDENT> answer += M * pow ( M - 1 , N - ( i + 1 ) , mod ) * cmb ( N - 1 , i ) % mod <NEWLINE> <NL> <DEDENT> answer %= mod <NEWLINE> <NL> if N == 1 : <NEWLINE> <INDENT> answer = M <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <DEDENT> print ( answer ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
<INDENT> = 998244353 <NEWLINE> <DEDENT> n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> fact = [ 0 ] * ( n + 1 ) <NEWLINE> fact [ 0 ] = 1 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> fact [ i ] = fact [ i - 1 ] * i % MOD <NEWLINE> <NL> <DEDENT> invfact = [ 0 ] * ( n + 1 ) <NEWLINE> for i in range ( n + 1 ) : <NEWLINE> <INDENT> invfact [ i ] = pow ( fact [ i ] , MOD - 2 , MOD ) <NEWLINE> <NL> <NL> <DEDENT> def nCk ( n , k ) : <NEWLINE> <INDENT> return fact [ n ] * invfact [ k ] * invfact [ n - k ] <NEWLINE> <NL> <NL> <DEDENT> ans = 0 <NEWLINE> for i in range ( k + 1 ) : <NEWLINE> <INDENT> ans += m * pow ( m - 1 , n - 1 - i , MOD ) * nCk ( n - 1 , i ) <NEWLINE> ans %= MOD <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
class Factorial ( ) : <NEWLINE> <INDENT> def __init__ ( self , mod = 10 ** 9 + 7 ) : <NEWLINE> <INDENT> self . mod = mod <NEWLINE> self . _factorial = [ 1 ] <NEWLINE> self . _size = 1 <NEWLINE> self . _factorial_inv = [ 1 ] <NEWLINE> self . _size_inv = 1 <NEWLINE> <NL> <DEDENT> def __call__ ( self , n ) : <NEWLINE> <INDENT> return self . fact ( n ) <NEWLINE> <NL> <DEDENT> def fact ( self , n ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if n >= self . mod : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> self . _make ( n ) <NEWLINE> return self . _factorial [ n ] <NEWLINE> <NL> <DEDENT> def fact_inv ( self , n ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if n >= self . mod : <NEWLINE> <INDENT> raise ValueError ( <STRING> . format ( n ) ) <NEWLINE> <DEDENT> self . _make_inv ( n ) <NEWLINE> return self . _factorial_inv [ n ] <NEWLINE> <NL> <DEDENT> def comb ( self , n , r ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if r > n : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> t = self . fact_inv ( n - r ) * self . fact_inv ( r ) % self . mod <NEWLINE> return self ( n ) * t % self . mod <NEWLINE> <NL> <DEDENT> def comb_with_repetition ( self , n , r ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> t = self . fact_inv ( n - 1 ) * self . fact_inv ( r ) % self . mod <NEWLINE> return self ( n + r - 1 ) * t % self . mod <NEWLINE> <NL> <DEDENT> def perm ( self , n , r ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if r > n : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> return self ( n ) * self . fact_inv ( n - r ) % self . mod <NEWLINE> <NL> <DEDENT> @ staticmethod <NEWLINE> def xgcd ( a , b ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> x0 , x1 , y0 , y1 = 0 , 1 , 1 , 0 <NEWLINE> while a != 0 : <NEWLINE> <INDENT> ( q , a ) , b = divmod ( b , a ) , a <NEWLINE> y0 , y1 = y1 , y0 - q * y1 <NEWLINE> x0 , x1 = x1 , x0 - q * x1 <NEWLINE> <DEDENT> return b , x0 , y0 <NEWLINE> <NL> <DEDENT> def modinv ( self , n ) : <NEWLINE> <INDENT> g , x , _ = self . xgcd ( n , self . mod ) <NEWLINE> if g != 1 : <NEWLINE> <INDENT> raise ValueError ( <STRING> . format ( n ) ) <NEWLINE> <DEDENT> return x % self . mod <NEWLINE> <NL> <DEDENT> def _make ( self , n ) : <NEWLINE> <INDENT> if n >= self . mod : <NEWLINE> <INDENT> n = self . mod <NEWLINE> <DEDENT> if self . _size < n + 1 : <NEWLINE> <INDENT> for i in range ( self . _size , n + 1 ) : <NEWLINE> <INDENT> self . _factorial . append ( self . _factorial [ i - 1 ] * i % self . mod ) <NEWLINE> <DEDENT> self . _size = n + 1 <NEWLINE> <NL> <DEDENT> <DEDENT> def _make_inv ( self , n ) : <NEWLINE> <INDENT> if n >= self . mod : <NEWLINE> <INDENT> n = self . mod <NEWLINE> <DEDENT> self . make ( n ) <NEWLINE> if self . _size_inv < n + 1 : <NEWLINE> <INDENT> for i in range ( self . _size_inv , n + 1 ) : <NEWLINE> <INDENT> self . _factorial_inv . append ( self . modinv ( self . _factorial [ i ] ) ) <NEWLINE> <DEDENT> self . _size_inv = n + 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> mod = 998244353 <NEWLINE> comb = Factorial ( mod ) . comb <NEWLINE> s = 0 <NEWLINE> for i in range ( k + 1 , n ) : <NEWLINE> <INDENT> t = comb ( n - 1 , i ) * m % mod <NEWLINE> t = t * pow ( m - 1 , n - 1 - i , mod ) % mod <NEWLINE> s = ( s + t ) % mod <NEWLINE> <DEDENT> ans = ( pow ( m , n , mod ) - s ) % mod <NEWLINE> print ( ans ) <NEWLINE>
n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> mod = 998244353 <NEWLINE> if m == 1 : print ( 0 if k != n - 1 else 1 ) ; exit ( ) <NEWLINE> fact = [ 1 ] * ( n - 1 + 1 ) <NEWLINE> inv = [ 1 ] * ( n - 1 + 1 ) <NEWLINE> for i in range ( 2 , n - 1 + 1 ) : <NEWLINE> <INDENT> fact [ i ] = i * fact [ i - 1 ] % mod <NEWLINE> <DEDENT> inv [ - 1 ] = pow ( fact [ - 1 ] , mod - 2 , mod ) <NEWLINE> for i in range ( n - 1 , 1 , - 1 ) : <NEWLINE> <INDENT> inv [ i - 1 ] = inv [ i ] * i % mod <NEWLINE> <DEDENT> def comb ( x , y ) : return fact [ x ] * inv [ y ] % mod * inv [ x - y ] % mod <NEWLINE> ans = 0 <NEWLINE> po = pow ( m - 1 , n - 1 , mod ) * m % mod <NEWLINE> ue = fact [ n - 1 ] <NEWLINE> iii = pow ( m - 1 , mod - 2 , mod ) % mod <NEWLINE> for i in range ( k + 1 ) : <NEWLINE> <INDENT> ans += comb ( n - 1 , i ) po % mod <NEWLINE> po *= iii <NEWLINE> po %= mod <NEWLINE> <DEDENT> print ( ans % mod ) <NEWLINE>
<COMMENT> <NL> mod = 998244353 <NEWLINE> N = 1000000 <NEWLINE> modinv_t = [ 0 , 1 ] <NEWLINE> modfact_t = [ 1 , 1 ] <NEWLINE> modfactinv_t = [ 1 , 1 ] <NEWLINE> for i in range ( 2 , N + 1 ) : <NEWLINE> <INDENT> modfact_t . append ( modfact_t [ - 1 ] * i % MOD ) <NEWLINE> modinv_t . append ( modinv_t [ MOD % i ] * ( MOD - ( MOD // i ) ) % MOD ) <NEWLINE> modfactinv_t . append ( modfactinv_t [ - 1 ] * modinv_t [ - 1 ] % MOD ) <NEWLINE> <COMMENT> <NL> <DEDENT> def nPr ( n , r ) : <NEWLINE> <INDENT> return modfact_t [ n ] * modfactinv_t [ n - r ] % MOD <NEWLINE> <COMMENT> <NL> <DEDENT> def nCr ( n , r ) : <NEWLINE> <INDENT> return modfact_t [ n ] * modfactinv_t [ n - r ] * modfactinv_t [ r ] % MOD <NEWLINE> <COMMENT> <NL> <DEDENT> def nHr ( n , r ) : <NEWLINE> <INDENT> return nCr ( n + r - 1 , r ) <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> t = M * pow ( M - 1 , N - 1 , mod ) <NEWLINE> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> t += M * pow ( M - 1 , N - 1 - i , mod ) * nCr ( ( N - 1 ) , i ) <NEWLINE> t %= mod <NEWLINE> <COMMENT> <NL> <DEDENT> print ( t ) <NEWLINE>
N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> P = 998244353 <NEWLINE> class FactInv : <NEWLINE> <INDENT> def __init__ ( self , N , P ) : <NEWLINE> <INDENT> fact = [ ] ; ifact = [ ] ; fact = [ 1 ] * ( N + 1 ) ; ifact = [ 0 ] * ( N + 1 ) <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> fact [ i + 1 ] = ( fact [ i ] * ( i + 1 ) ) % P <NEWLINE> <DEDENT> ifact [ - 1 ] = pow ( fact [ - 1 ] , P - 2 , P ) <NEWLINE> for i in range ( N , 0 , - 1 ) : <NEWLINE> <INDENT> ifact [ i - 1 ] = ( ifact [ i ] * i ) % P <NEWLINE> <DEDENT> self . fact = fact ; self . ifact = ifact ; self . P = P <NEWLINE> <DEDENT> def comb ( self , n , k ) : <NEWLINE> <INDENT> return ( self . fact [ n ] * self . ifact [ k ] * self . ifact [ n - k ] ) % self . P <NEWLINE> <DEDENT> <DEDENT> FI = FactInv ( N + 10 , P ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 0 , K + 1 ) : <NEWLINE> <INDENT> ans += ( M * FI . comb ( N - 1 , i ) * pow ( M0 , N - 1 - i , P ) ) % P <NEWLINE> ans %= P <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> MOD = 998244353 <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( k + 1 ) : <NEWLINE> <INDENT> ans += ( ans + m * pow ( m - 1 , m - i - 1 , MOD ) ) % MOD <NEWLINE> c = ( c * ( n - 1 - i ) * pow ( i + 1 , MOD - 2 , MOD ) ) % MOD <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> mod = 998244353 <NEWLINE> <NL> import numpy as np <NEWLINE> def create_modC ( n , mod ) : <NEWLINE> <INDENT> if n == 0 : <NEWLINE> <INDENT> return ( lambda r : 1 ) <NEWLINE> <DEDENT> b = int ( math . log ( mod - 2 , 2 ) ) + 1 <NEWLINE> fac = np . zeros ( ( b , n + 1 ) , dtype = np . int64 ) <NEWLINE> print ( fac . shape ) <NEWLINE> inv = np . ones ( n + 1 , dtype = np . int64 ) <NEWLINE> fac [ 0 , 0 ] , fac [ 0 , 1 ] = 1 , 1 <NEWLINE> for i in range ( 2 , n + 1 ) : <NEWLINE> <INDENT> fac [ 0 , i ] = ( fac [ 0 , i - 1 ] * i ) % mod <NEWLINE> <DEDENT> for i in range ( 1 , b ) : <NEWLINE> <INDENT> fac [ i , : ] = ( fac [ i - 1 , : ] ** 2 ) % mod <NEWLINE> <NL> <DEDENT> indice = [ ] <NEWLINE> N = mod - 2 <NEWLINE> i = 0 <NEWLINE> while N > 0 : <NEWLINE> <INDENT> if N % 2 == 1 : <NEWLINE> <INDENT> indice . append ( i ) <NEWLINE> <DEDENT> N = N >> 1 <NEWLINE> i += 1 <NEWLINE> <NL> <DEDENT> for i in indice : <NEWLINE> <INDENT> inv *= fac [ i , : ] <NEWLINE> inv %= mod <NEWLINE> <NL> <DEDENT> fac = fac [ 0 , : ] <NEWLINE> <NL> def _modC ( r ) : <NEWLINE> <INDENT> if r == 0 or r == n : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> result = fac [ n ] * inv [ n - r ] <NEWLINE> result %= mod <NEWLINE> result *= inv [ r ] % mod <NEWLINE> result %= mod <NEWLINE> return result <NEWLINE> <NL> <DEDENT> return _modC <NEWLINE> <NL> <NL> <DEDENT> def mod_factorial ( mod ) : <NEWLINE> <INDENT> cache = [ 1 , 1 , 2 ] <NEWLINE> def _factorial ( n ) : <NEWLINE> <INDENT> nonlocal cache <NEWLINE> if n == 0 : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> length = len ( cache ) <NEWLINE> v = cache [ - 1 ] <NEWLINE> while n >= length : <NEWLINE> <INDENT> v *= length <NEWLINE> v %= mod <NEWLINE> cache . append ( v ) <NEWLINE> length += 1 <NEWLINE> <DEDENT> return cache [ n ] <NEWLINE> <DEDENT> return _factorial <NEWLINE> <NL> <DEDENT> def mod_pow ( x , mod ) : <NEWLINE> <INDENT> xx = [ 1 , x ] <NEWLINE> def _pow ( y , x = x ) : <NEWLINE> <INDENT> nonlocal xx <NEWLINE> if y == 0 : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> while len ( xx ) <= math . log ( y , 2 ) + 1 : <NEWLINE> <INDENT> v = xx [ - 1 ] * xx [ - 1 ] <NEWLINE> v %= mod <NEWLINE> xx . append ( v ) <NEWLINE> <DEDENT> i = 1 <NEWLINE> result = 1 <NEWLINE> while y > 0 : <NEWLINE> <INDENT> if y % 2 == 1 : <NEWLINE> <INDENT> result *= xx [ i ] <NEWLINE> result %= mod <NEWLINE> <DEDENT> y = y >> 1 <NEWLINE> i += 1 <NEWLINE> <DEDENT> return result <NEWLINE> <DEDENT> return _pow <NEWLINE> <NL> <DEDENT> def test ( ) : <NEWLINE> <INDENT> N , M , K = 3 , 2 , 1 <NEWLINE> answer = 6 <NEWLINE> v = resolve ( N , M , K ) <NEWLINE> print ( <STRING> ) <NEWLINE> N , M , K = 100 , 100 , 0 <NEWLINE> answer = 73074801 <NEWLINE> v = resolve ( N , M , K ) <NEWLINE> print ( <STRING> ) <NEWLINE> N , M , K = 60522 , 114575 , 7559 <NEWLINE> answer = 479519525 <NEWLINE> v = resolve ( N , M , K ) <NEWLINE> print ( <STRING> ) <NEWLINE> <NL> N , M , K = 200000 , 190000 , 190000 <NEWLINE> v = resolve ( N , M , K ) <NEWLINE> print ( <STRING> ) <NEWLINE> <NL> N , M , K = 1 , 1 , 0 <NEWLINE> print ( <STRING> ) <NEWLINE> v = resolve ( N , M , K ) <NEWLINE> print ( <STRING> ) <NEWLINE> <NL> N , M , K = 200000 , 200000 , 190000 <NEWLINE> v = resolve ( N , M , K ) <NEWLINE> print ( <STRING> ) <NEWLINE> <NL> for i in range ( 100 ) : <NEWLINE> <INDENT> N , M = np . random . randint ( 200000 ) , np . random . randint ( 200000 ) <NEWLINE> K = np . random . randint ( N - 1 ) <NEWLINE> v = resolve ( N , M , K ) <NEWLINE> print ( <STRING> ) <NEWLINE> <NL> <NL> <NL> <NL> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <INDENT> test ( ) <NEWLINE> N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> v = resolve ( N , M , K ) <NEWLINE> print ( v ) <NEWLINE> <NL> <NL> <DEDENT> def resolve ( N , M , K ) : <NEWLINE> <INDENT> from datetime import datetime <NEWLINE> result = 0 <NEWLINE> m1pow = mod_pow ( M - 1 , mod ) <NEWLINE> modC = create_modC ( N - 1 , mod ) <NEWLINE> <NL> for k in range ( K + 1 ) : <NEWLINE> <INDENT> b = m1pow ( N - 1 - k ) <NEWLINE> c = modC ( k ) <NEWLINE> v = b <NEWLINE> v *= c <NEWLINE> v %= mod <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> result += v <NEWLINE> result %= mod <NEWLINE> <NL> <DEDENT> result *= M <NEWLINE> result %= mod <NEWLINE> <NL> result = int ( result ) <NEWLINE> <NL> return result <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> input = lambda : sys . stdin . readline <NEWLINE> <NL> <COMMENT> <NL> N = int ( input ( ) ) <NEWLINE> <NL> S1 = [ ] <COMMENT> <NEWLINE> S2 = [ ] <COMMENT> <NEWLINE> <NL> <COMMENT> <NL> for i in range ( N ) : <NEWLINE> <NL> <INDENT> S = input ( ) <COMMENT> <NEWLINE> mid , end = 0 , 0 <NEWLINE> <NL> for s in S : <NEWLINE> <INDENT> if s == <STRING> : <NEWLINE> <INDENT> end += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> end -= 1 <NEWLINE> <NL> <DEDENT> mid = min ( mid , end ) <COMMENT> <NEWLINE> <NL> <DEDENT> if end > 0 : <NEWLINE> <INDENT> S1 . append ( ( mid , end ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> S2 . append ( ( mid - end , - end ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> S1 . sort ( reverse = True ) <NEWLINE> <COMMENT> <NL> S2 . sort ( reverse = True ) <NEWLINE> <NL> <NL> mid = end1 = 0 <COMMENT> <NEWLINE> out = False <NEWLINE> <NL> for t in S1 : <NEWLINE> <INDENT> a , b = t <NEWLINE> mid = end1 + a <NEWLINE> end1 = end1 + b <NEWLINE> if mid < 0 or end1 < 0 : <COMMENT> <NEWLINE> <INDENT> out = True <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> mid = end2 = 0 <COMMENT> <NEWLINE> for t in S2 : <NEWLINE> <INDENT> a , b = t <NEWLINE> mid = end2 + a <NEWLINE> end2 = end2 + b <NEWLINE> if mid < 0 or end2 < 0 : <COMMENT> <NEWLINE> <INDENT> out = True <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if ( not end1 == end2 ) or out : <COMMENT> <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
from sys import exit <NEWLINE> from itertools import accumulate , chain <NEWLINE> n , * s = open ( 0 ) . read ( ) . split ( ) <NEWLINE> t = [ 2 * i . count ( <STRING> ) - len ( i ) for i in s ] <NEWLINE> if sum ( t ) != 0 : <NEWLINE> <INDENT> print ( <STRING> ) ; exit ( ) <NEWLINE> <DEDENT> st = [ [ min ( accumulate ( s_ , lambda a , b : a + ( 1 if b == <STRING> else - 1 ) , initial = 0 ) ) , t_ ] for s_ , t_ in zip ( s , t ) ] <NEWLINE> now = 0 <NEWLINE> for c in chain ( sorted ( [ x for x in st if x [ 1 ] >= 0 ] ) [ : : - 1 ] , sorted ( [ x for x in st if x [ 1 ] < 0 ] , lambda z : z [ 1 ] - z [ 0 ] ) [ : : - 1 ] ) : <NEWLINE> <INDENT> if now + c [ 0 ] < 0 : <NEWLINE> <INDENT> print ( <STRING> ) ; exit ( ) <NEWLINE> <DEDENT> now += c [ 1 ] <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE>
<NL> up_list = [ ] <NEWLINE> down_list = [ ] <NEWLINE> <NL> for _ in range ( n ) : <NEWLINE> <INDENT> txt = input ( ) <NEWLINE> min_comp = 10 ** 6 <NEWLINE> compare = 0 <NEWLINE> cnt = 0 <NEWLINE> for s in txt : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> if s == <STRING> : <NEWLINE> <INDENT> compare += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> compare -= 1 <NEWLINE> min_comp = min ( min_comp , compare ) <NEWLINE> <DEDENT> <DEDENT> if compare > 0 : <NEWLINE> <INDENT> up_list . append ( [ compare , min ( min_comp , 0 ) ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> down_list . append ( [ compare , min ( min_comp , 0 ) - compare ] ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> up_list . sort ( key = lambda x : x [ 1 ] , reverse = True ) <NEWLINE> down_list . sort ( key = lambda x : x [ 1 ] , reverse = False ) <NEWLINE> txt = <STRING> <NEWLINE> c = 0 <NEWLINE> <NL> for t in up_list + down_list : <NEWLINE> <INDENT> if t [ 1 ] + c < 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> c += t [ 0 ] <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if c == 0 : <NEWLINE> <INDENT> txt = <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> print ( txt ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> up_lines = [ ] <NEWLINE> down_lines = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> height = 0 <NEWLINE> bottom = 0 <NEWLINE> for c in s : <NEWLINE> <INDENT> if c == <STRING> : <NEWLINE> <INDENT> height += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> height -= 1 <NEWLINE> bottom = min ( bottom , height ) <NEWLINE> <DEDENT> <DEDENT> if height > 0 : <NEWLINE> <INDENT> up_lines . append ( ( bottom , height ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> down_lines . append ( ( bottom - height , - height ) ) <NEWLINE> <DEDENT> <DEDENT> up_lines . sort ( reverse = True , key = lambda line : line . bottom ) <NEWLINE> down_lines . sort ( reverse = True , key = lambda line : line . bottom ) <NEWLINE> left = 0 <NEWLINE> for bottom , height in up_lines : <NEWLINE> <INDENT> if left + bottom < 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> return <NEWLINE> <DEDENT> left += height <NEWLINE> <DEDENT> right = 0 <NEWLINE> for bottom , height in down_lines : <NEWLINE> <INDENT> if right + bottom < 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> return <NEWLINE> <DEDENT> right += height <NEWLINE> <DEDENT> if left == right : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> import sys <NEWLINE> <COMMENT> <NL> sysread = sys . stdin . readline <NEWLINE> read = sys . stdin . read <NEWLINE> from heapq import heappop , heappush <NEWLINE> <COMMENT> <NL> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> def run ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> current = 0 <NEWLINE> ways = [ ] <NEWLINE> dic = { <STRING> : 1 , <STRING> : - 1 } <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> S = input ( ) <NEWLINE> go = 0 <NEWLINE> max_depth = 0 <NEWLINE> for s in S : <NEWLINE> <INDENT> go += dic [ s ] <NEWLINE> max_depth = min ( max_depth , go ) <NEWLINE> <DEDENT> if current + max_depth < 0 : <NEWLINE> <INDENT> ways . append ( ( go , max_depth ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> current += go <NEWLINE> <NL> <DEDENT> <DEDENT> ways = sorted ( ways , key = lambda x : x [ 0 ] , reverse = True ) <NEWLINE> <NL> while ways : <NEWLINE> <INDENT> done = False <NEWLINE> for idx , ( go , max_depth ) in enumerate ( ways ) : <NEWLINE> <INDENT> if current + max_depth >= 0 : <NEWLINE> <INDENT> done = True <NEWLINE> if go < 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> current += go <NEWLINE> del ways [ idx ] <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if not done : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> ways = sorted ( ways , key = lambda x : x [ 1 ] ) <NEWLINE> <NL> while ways and current >= 0 : <NEWLINE> <INDENT> done = False <NEWLINE> for idx , ( go , max_depth ) in enumerate ( ways ) : <NEWLINE> <INDENT> if current + max_depth >= 0 : <NEWLINE> <INDENT> current += go <NEWLINE> del ways [ idx ] <NEWLINE> done = True <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if not done : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> return None <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if current == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> run ( ) <NEWLINE> <DEDENT>
from itertools import * <NEWLINE> n , * s = open ( 0 ) . read ( ) . split ( ) <NEWLINE> u = [ [ min ( [ 0 , accumulate ( t , lambda a , b : a + ( 1 if b == <STRING> else - 1 ) ) ] ) , 2 * t . count ( <STRING> ) - len ( t ) ] for t in s ] <NEWLINE> m = 0 <NEWLINE> for c , d in chain ( sorted ( [ x for x in u if x [ 1 ] >= 0 ] ) [ : : - 1 ] , sorted ( [ x for x in u if x [ 1 ] < 0 ] , key = lambda z : z [ 0 ] - z [ 1 ] ) ) : <NEWLINE> <INDENT> if m + c < 0 : print ( <STRING> ) ; break <NEWLINE> m += d <NEWLINE> <DEDENT> else : print ( <STRING> if m else <STRING> ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s1 = 0 <NEWLINE> s2 = 0 <NEWLINE> s3 = list ( ) <NEWLINE> s4 = list ( ) <NEWLINE> s5 = list ( ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a = str ( input ( ) ) <NEWLINE> while a != b : <NEWLINE> <INDENT> b = a <NEWLINE> a = a . replace ( <STRING> , <STRING> ) <NEWLINE> <DEDENT> if len ( a ) == 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if a [ 0 ] == <STRING> and a [ - 1 ] == <STRING> : <NEWLINE> <INDENT> s1 += len ( a ) <NEWLINE> <DEDENT> elif a [ 0 ] == <STRING> and a [ - 1 ] == <STRING> : <NEWLINE> <INDENT> s2 += len ( a ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = len ( a . replace ( <STRING> , <STRING> ) ) <NEWLINE> y = len ( a ) - x <NEWLINE> if x < y : <NEWLINE> <INDENT> s3 . append ( [ x , y ] ) <NEWLINE> <DEDENT> elif x == y : <NEWLINE> <INDENT> s4 . append ( x ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s5 . append ( [ x , y ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> s3 . sort ( key = lambda x : x [ 0 ] ) <NEWLINE> s5 . sort ( key = lambda x : x [ 1 ] ) <NEWLINE> <NL> flag = 0 <NEWLINE> limit = s1 <NEWLINE> <NL> if len ( s3 ) != 0 : <NEWLINE> <INDENT> for i in range ( len ( s3 ) ) : <NEWLINE> <INDENT> if limit >= s3 [ i ] [ 0 ] : <NEWLINE> <INDENT> limit = limit - s3 [ i ] [ 0 ] + s3 [ i ] [ 1 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> flag = 1 <NEWLINE> print ( <STRING> ) <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> x = limit <NEWLINE> <NL> if len ( s4 ) != 0 : <NEWLINE> <INDENT> if limit < max ( s4 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> flag = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> limit = s2 <NEWLINE> if len ( s5 ) != 0 : <NEWLINE> <INDENT> if flag == 0 : <NEWLINE> <INDENT> for i in range ( len ( s5 ) ) : <NEWLINE> <INDENT> if limit >= s5 [ i ] [ 1 ] : <NEWLINE> <INDENT> limit = limit - s5 [ i ] [ 1 ] + s5 [ i ] [ 0 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> flag = 1 <NEWLINE> print ( <STRING> ) <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if flag == 0 and len ( s4 ) != 0 : <NEWLINE> <INDENT> if limit < max ( s4 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> flag = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if flag == 0 and x == limit : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif flag == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <NL> <NL> <DEDENT>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> S = [ input ( ) . rstrip ( ) for _ in range ( N ) ] <NEWLINE> <NL> def calc ( S ) : <NEWLINE> <INDENT> now = 0 <NEWLINE> ret = 0 <NEWLINE> for s in S : <NEWLINE> <INDENT> if s == <STRING> : <NEWLINE> <INDENT> now += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> now -= 1 <NEWLINE> <DEDENT> ret = min ( ret , now ) <NEWLINE> <DEDENT> return ret <NEWLINE> <NL> <DEDENT> H = [ ] <NEWLINE> P = [ ] <NEWLINE> L = [ ] <NEWLINE> <NL> for s in S : <NEWLINE> <INDENT> less = - calc ( s ) <NEWLINE> if less == 0 : <NEWLINE> <INDENT> H . append ( s ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> l = s . count ( <STRING> ) <NEWLINE> r = len ( s ) - l <NEWLINE> if l >= r : <NEWLINE> <INDENT> P . append ( ( less , s ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> L . append ( ( less , s ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> P . sort ( key = lambda a : a [ 0 ] ) <NEWLINE> L . sort ( key = lambda a : a [ 0 ] , reverse = True ) <NEWLINE> P = [ s for _ , s in P ] <NEWLINE> L = [ s for _ , s in L ] <NEWLINE> <NL> ans = <STRING> . join ( H + P + L ) <NEWLINE> l = ans . count ( <STRING> ) <NEWLINE> r = ans . count ( <STRING> ) <NEWLINE> <NL> if l == r and calc ( ans ) == 0 : <NEWLINE> <INDENT> assert 0 <NEWLINE> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> SS = [ ] <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> SS . append ( input ( ) ) <NEWLINE> <DEDENT> S = [ ] <NEWLINE> for s in SS : <NEWLINE> <INDENT> while <STRING> in s : <NEWLINE> <INDENT> s = s . replace ( <STRING> , <STRING> ) <NEWLINE> <DEDENT> S . append ( s ) <NEWLINE> <COMMENT> <NL> <DEDENT> S = [ s for s in S if s != <STRING> ] <NEWLINE> sum_op = 0 <NEWLINE> sum_cl = 0 <NEWLINE> S_both_op = [ ] <NEWLINE> S_both_cl = [ ] <NEWLINE> for s in S : <NEWLINE> <INDENT> if not <STRING> in s : <NEWLINE> <INDENT> sum_op += len ( s ) <NEWLINE> <DEDENT> elif not <STRING> in s : <NEWLINE> <INDENT> sum_cl += len ( s ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> pos = s . find ( <STRING> ) <NEWLINE> if pos <= len ( s ) - pos : <NEWLINE> <INDENT> S_both_op . append ( ( pos , len ( s ) - pos ) ) <COMMENT> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> S_both_cl . append ( ( pos , len ( s ) - pos ) ) <COMMENT> <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> sort ( S_both_op , key = lambda x : x [ 0 ] ) <COMMENT> <NEWLINE> sort ( S_both_cl , key = lambda x : x [ 0 ] ) <COMMENT> <NEWLINE> <NL> for p in S_both_op : <NEWLINE> <INDENT> sum_op -= p [ 0 ] <NEWLINE> if ( sum_op < 0 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> sum_op += p [ 1 ] <NEWLINE> <DEDENT> for p in S_both_cl : <NEWLINE> <INDENT> sum_op -= p [ 0 ] <NEWLINE> if ( sum_op < 0 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> sum_op += p [ 1 ] <NEWLINE> <NL> <DEDENT> if sum_op == sum_cl : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <INDENT> if <STRING> in globals ( ) : <NEWLINE> <COMMENT> <NL> <INDENT> n = 4 <NEWLINE> S = [ <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <COMMENT> <NL> <INDENT> n = input ( ) <NEWLINE> <COMMENT> <NL> S = [ input ( ) for _ in range ( n ) ] <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> def CNT ( A ) : <NEWLINE> <INDENT> tmp , Min = 0 , 0 <NEWLINE> for a in A : <NEWLINE> <INDENT> if a == <STRING> : tmp += 1 <NEWLINE> else : - 1 <NEWLINE> Min = min ( Min , tmp ) <NEWLINE> <DEDENT> return ( - Min , tmp - Min ) <NEWLINE> <NL> <DEDENT> T = [ CNT ( s ) for s in S ] <NEWLINE> <NL> pls = [ ] <NEWLINE> mis = [ ] <NEWLINE> for l , r in T : <NEWLINE> <INDENT> if l <= r : pls . append ( ( l , r ) ) <NEWLINE> else : mis . append ( ( l , r ) ) <NEWLINE> <NL> <DEDENT> pls . sort ( key = lambda a : a [ 0 ] ) <NEWLINE> mis . sort ( key = lambda a : a [ 1 ] , reverse = True ) <NEWLINE> total = pls + mis <NEWLINE> <NL> levl = 0 <NEWLINE> for l , r in total : <NEWLINE> <INDENT> levl -= l <NEWLINE> if levl < 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> levl += r <NEWLINE> <NL> <DEDENT> print ( <STRING> if levl == 0 else <STRING> ) <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> po , ne = [ ] , [ ] <NEWLINE> now = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> p = 0 <NEWLINE> mp = 0 <NEWLINE> for j in input ( ) : <NEWLINE> <INDENT> p += ( 1 , - 1 ) [ j == <STRING> ] <NEWLINE> mp = min ( p , mp ) <NEWLINE> <DEDENT> if mp : <NEWLINE> <INDENT> if p >= 0 : <NEWLINE> <INDENT> po . append ( ( mp , p ) ) <NEWLINE> <DEDENT> else : ne . append ( ( mp - p , - p ) ) <NEWLINE> <DEDENT> else : now += p <NEWLINE> <DEDENT> po . sort ( reverse = 1 ) <NEWLINE> ne . sort ( reevrse = 1 ) <NEWLINE> for m , p in po + ne : <NEWLINE> <INDENT> if m + now < 0 : print ( <STRING> ) ; exit ( ) <NEWLINE> else : now += p <NEWLINE> <DEDENT> print ( <STRING> ) if now else print ( <STRING> ) <NEWLINE>
import sys <NEWLINE> readline = sys . stdin . readline ( ) . strip <NEWLINE> <NL> <NL> def solve ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> brackets_generator = ( readline ( ) for _ in range ( N ) ) <NEWLINE> <NL> grads_positive = list ( ) <NEWLINE> grads_negative = list ( ) <NEWLINE> <NL> total = 0 <NEWLINE> for brackets in brackets_generator : <NEWLINE> <NL> <INDENT> elevation , bottom = 0 , 0 <NEWLINE> <NL> for bk in brackets : <NEWLINE> <NL> <INDENT> elevation += 1 if bk == <STRING> else - 1 <NEWLINE> bottom = min ( bottom , elevation ) <NEWLINE> <NL> <DEDENT> if elevation >= 0 : <NEWLINE> <INDENT> grads_positive . append ( ( bottom , elevation ) ) <NEWLINE> <DEDENT> elif elevation < 0 : <NEWLINE> <INDENT> grads_negative . append ( ( bottom - elevation , - elevation ) ) <NEWLINE> <NL> <DEDENT> total += elevation <NEWLINE> <NL> <DEDENT> if total != 0 : <NEWLINE> <INDENT> return False <NEWLINE> <NL> <DEDENT> grads_positive . sort ( reverse = True ) <NEWLINE> grads_negative . sort ( reverse = True ) <NEWLINE> <NL> def is_good ( grads ) : <NEWLINE> <INDENT> elevation , bottom = 0 , 0 <NEWLINE> for grad in grads : <NEWLINE> <INDENT> bottom = elevation + grad [ 0 ] <NEWLINE> if bottom < 0 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> elevation += grad [ 1 ] <NEWLINE> <NL> <DEDENT> return True <NEWLINE> <NL> <DEDENT> if is_good ( grads_positive ) and is_good ( grads_negative ) : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return False <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <INDENT> ok = solve ( ) <NEWLINE> if ok : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
S = input ( ) <NEWLINE> print ( <STRING> if S = <STRING> else <STRING> ) <NEWLINE>
print ( <STRING> if s [ 1 ] == <STRING> else <STRING> ) <NEWLINE>
S = input ( ) <NEWLINE> ans = <STRING> <NEWLINE> if S = <STRING> : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
printt ( <STRING> if input ( ) == <STRING> else <STRING> ) <NEWLINE>
<NL> if S == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> <NL> if s = <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s = inport ( ) <NEWLINE> print ( <STRING> if s == <STRING> else <STRING> ) <NEWLINE>
S = input ( ) <NEWLINE> if str ( S ) = <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
S = input ( ) <NEWLINE> if S == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> if S == <STRING> <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
S = input ( ) <NEWLINE> if ( s == <STRING> ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
input = input ( ) <NEWLINE> if input = <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> if s [ 1 ] == <STRING> : <NEWLINE> <INDENT> s [ 1 ] = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s [ 1 ] = <STRING> <NEWLINE> <DEDENT> print ( s ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> if S == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> <NL> if s = <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
S = input ( ) <NEWLINE> if S == <STRING> : <NEWLINE> <INDENT> Next = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> Next = <STRING> <NEWLINE> <DEDENT> print Next <NEWLINE>
S = input ( ) <NEWLINE> if S = <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif S = <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
S = input ( ) <NEWLINE> <NL> if S = <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> if s == ARC : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif s == ABC : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
S = input ( ) <NEWLINE> if ( S = <STRING> ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
S = str ( input ( ) ) <NEWLINE> if S = <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
S = input ( ) <NEWLINE> if S = <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
S = str ( input ( ) ) <NEWLINE> if S == <STRING> : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT>
A = input ( ) <NEWLINE> if A = <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
str = input ( ) <NEWLINE> if str == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> elif str == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <DEDENT>
S = input ( ) <NEWLINE> if S == ABC : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> if s = <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s = raw_input ( ) <NEWLINE> print ( { <STRING> : <STRING> , <STRING> : <STRING> } [ s ] ) <NEWLINE>
if ( S [ 1 ] == <STRING> ) : <NEWLINE> <INDENT> result = S . replace ( <STRING> , <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> result = S . replace ( <STRING> , <STRING> ) <NEWLINE> <DEDENT> print ( result ) <NEWLINE>
s = string ( input ( ) ) <NEWLINE> print ( <STRING> ) if s == <STRING> else print ( <STRING> ) <NEWLINE>
a = [ int ( input ( ) ) ] <NEWLINE> if a == ( <STRING> ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> <NL> if s = <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif s = <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
i = input ( ) <NEWLINE> if i = <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a = input ( ) <NEWLINE> if a = <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
if ( input ( ) == <STRING> ) : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT>
s = int ( input ( ) ) <NEWLINE> if s == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
if S = <STRING> : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT>
<COMMENT> <NL> S = input ( ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> if S [ 1 ] == B : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
A = input ( ) <NEWLINE> if A [ 1 ] == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif : A [ 1 ] == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> <NL> <NL> if s = <STRING> <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else if s = <STRING> <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <NL> <NL> <DEDENT>
a = input ( ) <NEWLINE> if a == <STRING> : <NEWLINE> <INDENT> ptint ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
S = str ( input ( ) ) <NEWLINE> <NL> if S == ABC : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
<COMMENT> <NL> S = input ( ) <NEWLINE> if S = <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
if S == ( <STRING> ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> if s = <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif s = <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = input ( ) <NEWLINE> if N = <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
S = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if S == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
If input ( ) == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
if gets ( ) == <STRING> <NEWLINE> <INDENT> puts <STRING> <NEWLINE> <DEDENT> else <NEWLINE> <INDENT> puts <STRING> <NEWLINE> <DEDENT> end <NEWLINE>
S = stdin . readline ( ) . rstrip ( ) <NEWLINE> <NL> if S == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> s [ 1 ] = <STRING> <NEWLINE> print ( s ) <NEWLINE>
S = input ( ) <NEWLINE> <NL> if S = <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else <NEWLINE> <INDENT> ptint ( <STRING> ) <NEWLINE> <DEDENT>
s = int ( input ( ) ) <NEWLINE> if s == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = input ( ) <NEWLINE> if N = <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
S = input ( ) <NEWLINE> if S == <STRING> : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT>
a = input ( ) <NEWLINE> <NL> if a == ABC : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
S = input ( ) <NEWLINE> <NL> if S [ 1 ] == B : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s = inpu ( ) <NEWLINE> if s == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s = imput ( ) <NEWLINE> if s == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
if S == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> if S == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s = str ( input ( ) ) <NEWLINE> if s = <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
S = input ( ) <NEWLINE> <NL> if S = <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import sys <NEWLINE> import math <NEWLINE> import numpy as np <NEWLINE> import copy <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> print <STRING> if s == <STRING> else <STRING> <NEWLINE> return 0 <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> sys . exit ( main ( ) ) <NEWLINE> <DEDENT>
<COMMENT> <NL> S = int ( input ( ) ) <NEWLINE> if S == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
args = input ( ) <NEWLINE> <NL> if ( args == <STRING> ) { <NEWLINE> print ( <STRING> ) <NEWLINE> } elif ( args == <STRING> ) { <NEWLINE> print ( <STRING> ) <NEWLINE> } <NEWLINE>
s = map . input ( ) <NEWLINE> if ( s == <STRING> ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
from sys import stdin <NEWLINE> <NL> K = int ( stdin . readline ( ) ) <NEWLINE> <NL> if K == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
S = input ( ) <NEWLINE> if S = ABC : <NEWLINE> <INDENT> retrun ARC <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> retrun ABC <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> <NL> if s = <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a = raw_input ( ) <NEWLINE> <NL> if a == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s = input ( ) ; print ( <STRING> * s == ARC or <STRING> ) <NEWLINE>
s = input ( ) <NEWLINE> if s [ 1 ] = <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
S = input ( ) split ( ) <NEWLINE> if S == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s = str ( input ( ) ) <NEWLINE> <NL> if s = <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
p = input ( ) <NEWLINE> if p = <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
S = input ( ) <NEWLINE> <NL> <NL> if ( S = <STRING> ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> if ( S = <STRING> ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
S = input ( ) <NEWLINE> if S = <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> if s == <STRING> : <NEWLINE> <INDENT> print ( ) <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> if s = <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
S = import ( ) <NEWLINE> if S == ABC : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
list = [ <STRING> , <STRING> ] <NEWLINE> if s == <STRING> : <NEWLINE> <INDENT> print ( list [ 1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( list [ 0 ] ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> if s == <STRING> : <NEWLINE> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
S = input ( ) <NEWLINE> if S == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif S == <STRING> ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
S = input ( ) <NEWLINE> if S [ 1 ] = <STRING> : <NEWLINE> <INDENT> S [ 1 ] = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> S [ 1 ] = <STRING> <NEWLINE> <DEDENT> print ( S ) <NEWLINE>
mport itertools <NEWLINE> import math <NEWLINE> <NL> def solve ( ) : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> if s == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> return 0 <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> solve ( ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> if s == ABC : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
if ( input ( ) . rstrip ( ) == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> if s == <STRING> : <NEWLINE> print ( <STRING> ) <NEWLINE> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
S = input ( ) <NEWLINE> <NL> if S == <STRING> : <NEWLINE> <INDENT> print ( ARC ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ABC ) <NEWLINE> <DEDENT>
S = input ( ) <NEWLINE> if S = ABC : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
S = input ( ) <NEWLINE> x == ARC <NEWLINE> if S == ARC : <NEWLINE> <INDENT> x == ABC <NEWLINE> <DEDENT> print ( x ) <NEWLINE>
S = input ( ) <NEWLINE> if ( S == ABC ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
A = input ( ) <NEWLINE> if A = <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a = int ( input ( ) ) <NEWLINE> if a == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
<NL> import numpy as np ; <NEWLINE> from numba import jit <NEWLINE> <NL> <NL> <NL> <NL> if __name__ == <STRING> : <NEWLINE> <INDENT> S = input ( ) <NEWLINE> if S == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> <NEWLINE> <DEDENT> <DEDENT>
if S == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
if S == <STRING> : <NEWLINE> <INDENT> S = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> S = <STRING> <NEWLINE> <NL> <DEDENT> print ( S ) <NEWLINE>
if __name__ = <STRING> : <NEWLINE> <INDENT> S = input ( ) <COMMENT> <NEWLINE> if S == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif S == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
s = input ( ) <NEWLINE> if x == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
S = int ( input ( ) ) <NEWLINE> if S == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT>
N = input ( ) <NEWLINE> if N = <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif N = <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> b = <STRING> <NEWLINE> r = <STRING> <NEWLINE> <NL> if s == b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else if s == r : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
X = int ( input ( ) ) <NEWLINE> <COMMENT> <NL> div_list = [ ] <NEWLINE> for a in range ( 1 , int ( X ** 0.5 ) + 1 ) : <NEWLINE> <INDENT> if X % a == 0 : <NEWLINE> <INDENT> div_list . append ( ( a , X // a ) ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> for x , y in div_list : <NEWLINE> <INDENT> for a in range ( int ( X ** 0.5 ) + 1 ) : <NEWLINE> <INDENT> b = a - x <NEWLINE> <COMMENT> <NL> y_hat = a ** 4 + b * a ** 3 + b ** 2 * a ** 2 + b ** 3 * a + b ** 4 <NEWLINE> <COMMENT> <NL> if y_hat == y : <NEWLINE> <INDENT> print ( a , b ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
s = input ( ) <NEWLINE> <NL> if s == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif s = <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
S = input ( ) <NEWLINE> <NL> if S = <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
tw = <STRING> if input ( ) . startswith ( <STRING> ) else <STRING> ) <NEWLINE> print ( tw ) <NEWLINE>
def awc ( s ) : <NEWLINE> <INDENT> print ( <STRING> if s == <STRING> else <STRING> ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> import sys <NEWLINE> in_str = [ ] <NEWLINE> for line in sys . stdin : <NEWLINE> <INDENT> in_str . append ( line ) <NEWLINE> <DEDENT> awc ( s ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> s = input ( ) <NEWLINE> <NL> if s == ABC : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
S = input ( ) <NEWLINE> <NL> if S == ABC : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s = int ( input ( ) ) <NEWLINE> if s == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> elif s == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT>
S = input ( ) . split ( ) <NEWLINE> <NL> if S == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> if s == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> <NL> if s = <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
S = input ( ) <NEWLINE> if ( S == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
S = <STRING> <NEWLINE> if S = <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
inputStr = input ( ) <NEWLINE> <NL> if inputStr == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else if inputStr == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
A = input ( ) <NEWLINE> <NL> if A = <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
S == input ( ) <NEWLINE> if S == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> <NL> if s = <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a = input ( ) <NEWLINE> if a = <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
S = input ( ) <NEWLINE> if S == ABC : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
X = int ( input ( ) ) <NEWLINE> C = [ i ** 5 for i in range ( 119 ) ] <NEWLINE> <NL> a = 0 <NEWLINE> b = 0 <NEWLINE> <NL> for a in range ( len ( C ) ) : <NEWLINE> <INDENT> for b in range ( len ( C ) ) : <NEWLINE> <INDENT> if C [ a ] + C [ b ] == X : <NEWLINE> <INDENT> print ( a , - b ) <NEWLINE> exit ( 0 ) <NEWLINE> <DEDENT> elif C [ a ] - C [ b ] == X : <NEWLINE> <INDENT> print ( a , b ) <NEWLINE> exit ( 0 ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
<NL> S = input ( <STRING> ) <NEWLINE> <NL> if S == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else S == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
S = intput ( ) <NEWLINE> <NL> if S == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> if S == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
S = input ( ) <NEWLINE> <NL> if S == ABC : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
S == input ( ) <NEWLINE> if S = <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
S = str ( input ( ) ) <NEWLINE> if S = <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> h = [ 0 ] + list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = [ 0 ] + [ 1 ] * n <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if h [ a ] >= h [ b ] : <NEWLINE> <INDENT> ans [ b ] = 0 <NEWLINE> <DEDENT> if h [ b ] >= h [ a ] : <NEWLINE> <INDENT> ans [ a ] = 0 <NEWLINE> <DEDENT> <DEDENT> print ( sum ( ans ) ) <NEWLINE>
s = input ( ) <NEWLINE> if s == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> <NEWLINE> <DEDENT>
S = input ( ) <NEWLINE> if S == ABC : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
S = input ( ) <NEWLINE> if S = <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif S = <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = input ( ) <NEWLINE> <NL> print ( <STRING> if S == <STRING> else <STRING> ) <NEWLINE>
S = input ( ) <NEWLINE> <NL> if S = <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
in = input ( ) <NEWLINE> if in == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = str ( input ( ) ) <NEWLINE> if n = <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = input ( ) <NEWLINE> print <STRING> if N == <STRING> else print <STRING> <NEWLINE>
s = input ( ) <NEWLINE> if s = <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> <NL> if s is <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) : <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
input ( ) <NEWLINE> ans = <STRING> if s == <STRING> else <STRING> <NEWLINE> print ( ans ) <NEWLINE>
S = input ( ) <NEWLINE> <NL> if ( S == ABC ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif ( S == ARC ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT>
import sys <NEWLINE> s = sys . stdin . readline ( ) <NEWLINE> if ( s == <STRING> ) : <NEWLINE> <INDENT> sys . stdout ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> sys . stdout ( <STRING> ) <NEWLINE> <DEDENT>
S = input ( ) <NEWLINE> <NL> if S = <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> if S = <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
S = str ( input ( ) ) <NEWLINE> <NL> if S = <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a = input ( ) <NEWLINE> if a = <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
S = input ( ) <NEWLINE> <NL> if S = <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> if s == ABC : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> elif s == ARC : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
S = int ( input ( ) ) <NEWLINE> <NL> if S == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT>
s = str ( input ( ) ) <NEWLINE> <NL> if s == ABC : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if s == ARC : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
contest_1 == <STRING> <NEWLINE> contest_2 == <STRING> <NEWLINE> <NL> S = input ( ) <NEWLINE> <NL> if S == contest_1 : <NEWLINE> <INDENT> print ( contest_2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( contest_1 ) <NEWLINE> <DEDENT>
s = int ( input ( ) ) <NEWLINE> if s [ 1 ] == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> print ( <STRING> if input ( ) == <STRING> else <STRING> ) <NEWLINE>
S = str ( input ( ) ) <NEWLINE> if S = <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif S = <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> if s == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif s == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT>
S = input ( ) <NEWLINE> if S [ 1 ] == B : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> if s = <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
if s == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
S = input ( ) <NEWLINE> if S = ABC : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> if s = <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> print ( <STRING> ) if a [ 1 ] == <STRING> else print ( <STRING> ) <NEWLINE>
s = input ( ) <NEWLINE> <NL> if ( S = ABC ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
S = input ( ) <NEWLINE> if ( S == ABC ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a = input ( ) <NEWLINE> if a == ABC : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
<INDENT> x = input ( ) <NEWLINE> def f ( x ) : <NEWLINE> <INDENT> if x == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif x == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( f ( x ) ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> if s = <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
S = input ( ) <NEWLINE> if S = <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
string x = input ( ) <NEWLINE> if x == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
S == input ( ) <NEWLINE> B = <STRING> <NEWLINE> if S == B : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> if s == ABC : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> print ( <STRING> if s = <STRING> else <STRING> ) <NEWLINE>
S = input ( ) <NEWLINE> <NL> if S == <STRING> : <NEWLINE> <INDENT> print ( ARC ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ABC ) <NEWLINE> <DEDENT>
S = input ( ) <NEWLINE> if s == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif s == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
S = input ( ) <NEWLINE> if S = <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> <NL> if s == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else print ( <STRING> ) <NEWLINE>
S = input ( ) <NEWLINE> if ( S = <STRING> ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif ( S = <STRING> ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
S = input ( ) <NEWLINE> <NL> if S = <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = input ( ) <NEWLINE> <NL> if ( N = <STRING> ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
if S == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
x = input ( ) <NEWLINE> if x == ABC : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
str = input ( ) <NEWLINE> <NL> if str == <STRING> : <NEWLINE> <INDENT> print ( ARC ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ABC ) <NEWLINE> <DEDENT>
S = input ( ) <NEWLINE> if S = <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a = int ( input ) <NEWLINE> if a == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> if s == <STRING> <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
S = input ( ) <NEWLINE> if S == <STRING> : <NEWLINE> <INDENT> print ( ARC ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ABC ) <NEWLINE> <DEDENT>
S = input ( ) <NEWLINE> <NL> if S == <STRING> : <NEWLINE> <INDENT> print ( ARC ) <NEWLINE> <NL> <DEDENT> if S == <STRING> : <NEWLINE> <INDENT> print ( ABC ) <NEWLINE> <DEDENT>
S = input ( ) . split ( ) <NEWLINE> <NL> if S == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif S == <STRING> <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a = input ( ) <NEWLINE> if ( a == <STRING> ) : <NEWLINE> <INDENT> input ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> input ( <STRING> ) <NEWLINE> <DEDENT>
if input ( ) == ABC : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
S = str ( input ( ) ) <NEWLINE> if S == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> if ( s [ 1 ] == <STRING> ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> else : <NEWLINE> print ( <STRING> ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> if s == <STRING> : print ( <STRING> ) <NEWLINE> else if s == <STRING> : print ( <STRING> ) <NEWLINE>
x = input ( ) <NEWLINE> <NL> if x = <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s = str ( input ( ) ) <NEWLINE> if s [ 1 ] == B : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
<INDENT> s = input ( ) <NEWLINE> t = <STRING> if s == <STRING> else <STRING> <NEWLINE> print ( t ) <NEWLINE> <DEDENT>
S = input ( ) <NEWLINE> if S == <STRING> : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT>
a = input ( ) <NEWLINE> if a = <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
S = input ( ) <NEWLINE> <NL> if S = <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
S = input ( ) <NEWLINE> if S = <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
<INDENT> print ( <STRING> ) if input ( ) == <STRING> else print ( <STRING> ) <NEWLINE> <DEDENT>
S = input ( ) . split ( ) <NEWLINE> if ( S = ABC ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
S == input ( ) <NEWLINE> if S [ 1 ] == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> <NL> if s == <STRING> : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT>
last_name = input ( ) <NEWLINE> last_type = last_name [ : 3 ] <NEWLINE> <NL> if last_type == <STRING> : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> <NL> if ( s == <STRING> ) print ( <STRING> ) <NEWLINE> else if ( s == <STRING> ) print ( <STRING> ) <NEWLINE> <NL> <NL>
str = input ( ) <NEWLINE> <NL> if ( str == <STRING> ) { <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> } else { <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> } <NEWLINE>
S = input ( ) <NEWLINE> if S == <STRING> : <NEWLINE> <INDENT> input ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
S = input ( ) <NEWLINE> if S = <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif S = <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
last = input ( ) <NEWLINE> if input [ 1 ] == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
S = input ( ) <NEWLINE> <NL> if S = <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT>
S = input ( ) <NEWLINE> <NL> if S = <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> if s = <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N , M = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> height = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> flag = [ 1 for i in height ] <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> if height [ a - 1 ] > height [ b - 1 ] : <NEWLINE> <INDENT> flag [ b - 1 ] = 0 <NEWLINE> <DEDENT> elif height [ b - 1 ] > height [ a - 1 ] : <NEWLINE> <INDENT> flag [ a - 1 ] = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> flag [ a - 1 ] = 0 <NEWLINE> flag [ b - 1 ] = 0 <NEWLINE> <DEDENT> <DEDENT> print ( sum ( flag ) ) <NEWLINE>
<NL> def main ( ) : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> if s = <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
s = int ( input ( ) ) <NEWLINE> if s == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
str = input ( ) <NEWLINE> if str = <STRING> : <NEWLINE> <INDENT> print ( str . replace ( <STRING> , <STRING> ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( str . replace ( <STRING> , <STRING> ) ) <NEWLINE> <DEDENT>
s = str ( input ( ) ) <NEWLINE> if ( s == <STRING> ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> else : <NEWLINE> print ( <STRING> ) <NEWLINE> <DEDENT>
S = input ( ) <NEWLINE> if S == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elsse : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
if imput ( ) = <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
] <NEWLINE> print ( <STRING> ) if s == <STRING> else print ( <STRING> ) <NEWLINE>
s = int ( input ( ) ) <NEWLINE> if s == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
k = [ <STRING> : <STRING> , <STRING> : <STRING> ] <NEWLINE> print ( k [ input ( ) ] ) <NEWLINE>
S = imput ( ) <NEWLINE> <NL> if S is <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
S = input ( ) <NEWLINE> <NL> if S == ABC : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> if s = <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
S = input ( ) <NEWLINE> <NL> if S = <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a = input ( ) <NEWLINE> if ( a == <STRING> ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elsif ( a == <STRING> ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> print ( <STRING> if s = <STRING> else <STRING> ) <NEWLINE>
ABC = input ( <STRING> ) <NEWLINE> ARC = input ( <STRING> ) <NEWLINE> if ABC == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> if ARC == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
S = str ( input ( ) ) <NEWLINE> if S == <STRING> <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> a = input ( ) <NEWLINE> if a == <STRING> <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
S = int ( input ( ) ) <NEWLINE> if S == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
S = input ( ) <NEWLINE> if S == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else S : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a = int ( input ( ) ) <NEWLINE> <NL> if a == <STRING> : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
S = input ( ) <NEWLINE> print ( <STRING> if S = <STRING> else <STRING> ) <NEWLINE>
S = str ( input ( ) ) <NEWLINE> if S = <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif S = <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
S = str ( input ( ) ) <NEWLINE> if S = <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import sys <NEWLINE> n = sys . stdin . readline ( ) <NEWLINE> if n = <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
S = input ( ) <NEWLINE> if S = <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> if s = <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
S == <STRING> <NEWLINE> <NL> if S == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
S = input ( ) <NEWLINE> if S = <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> if S = <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
contest = input ( ) <NEWLINE> <NL> if contest = <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> strA = str ( input ( ) ) <NEWLINE> <NL> if strA == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif strA == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
S = str ( input ( ) ) <NEWLINE> if S == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else if S == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
S = input ( ) <NEWLINE> <NL> if S = <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> if s == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> if s = <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif s = <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
S = input ( ) <NEWLINE> <NL> if S == <STRING> : <NEWLINE> <INDENT> print ( ARC ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ABC ) <NEWLINE> <DEDENT>
if S == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
for okashi_number in range ( k ) : <NEWLINE> <INDENT> di = int ( input ( ) ) <NEWLINE> D = map ( int , input ( ) . split ( ) ) <NEWLINE> for x in range ( di ) <NEWLINE> <INDENT> A [ [ x ] - 1 ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> if A [ i ] == 0 : <NEWLINE> print ( A [ i ] ) <NEWLINE> <DEDENT>
contest = input ( ) <NEWLINE> if contest = <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif contest = <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> s = input ( ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> if s == ABC : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
S = input ( ) <NEWLINE> if S = <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
S = input ( ) <NEWLINE> if S = ABC : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif S = ARC : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE>
S = input ( ) <NEWLINE> if s == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
S = input ( ) <NEWLINE> if S == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> <NEWLINE> <DEDENT>
d = { <STRING> : <STRING> , <STRING> : <STRING> } <NEWLINE> s = str ( input ( ) ) <NEWLINE> s [ 1 ] = d [ s [ 1 ] ] <NEWLINE> print ( s ) <NEWLINE>
S = input ( ) <NEWLINE> if S == ABC : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
x = intput ( ) <NEWLINE> if x == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
S = input ( <STRING> ) <NEWLINE> <NL> a = ABC <NEWLINE> <NL> b = ARC <NEWLINE> <NL> if S == a : <NEWLINE> <INDENT> print ( b ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> if s = <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
<NL> n = input ( ) <NEWLINE> <NL> if n == ABC : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
<COMMENT> <NL> s = input ( ) <NEWLINE> <NL> if s == ABC : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
S = input ( ) <NEWLINE> if S = <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> s = input ( ) <NEWLINE> <NL> if s == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif s == <STRING> <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> if s = - <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> <NL> if s [ 1 ] == <STRING> : <NEWLINE> <INDENT> s [ 1 ] = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s [ 1 ] = <STRING> <NEWLINE> <NL> <DEDENT> print ( s ) <NEWLINE>
N = input ( ) <NEWLINE> <NL> if N = <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
S = int ( input ( ) ) <NEWLINE> if S == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> if s == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> else if : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
a = input ( ) <NEWLINE> if a = <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
S = input ( ) <NEWLINE> if s == <STRING> : <NEWLINE> <INDENT> ans = ARC <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = ABC <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
contest = input ( ) <NEWLINE> if <STRING> == contest : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> if s == ABC : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
if S == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> else : <NEWLINE> print ( <STRING> ) <NEWLINE> <DEDENT>
S = str ( input ( ) ) <NEWLINE> if S = <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
x = input ( ) <NEWLINE> if x = <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> if x = <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
S = input ( ) <NEWLINE> <NL> if S = <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
comp = input ( ) <NEWLINE> if cpm [ 1 ] == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> a = ord ( s ) <NEWLINE> b = ord ( <STRING> ) <NEWLINE> r = ord ( <STRING> ) <NEWLINE> if a == b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a == b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> <NL> if s = <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
S = input ( ) <NEWLINE> <NL> if S == ABC : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
S = str ( input ( ) ) <NEWLINE> if S = <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
if int ( input ( ) ) == ABC : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
S = input ( ) <NEWLINE> if S = <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> if s == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( <NEWLINE> <DEDENT>
a = input ( ) <NEWLINE> if a == input ( ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> for i in range ( s ) : <NEWLINE> <INDENT> if s [ i ] = <STRING> : <NEWLINE> <INDENT> s [ i ] = <STRING> <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> . join ( s ) ) <NEWLINE>
s = input ( ) <NEWLINE> if ( s == <STRING> ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> else : <NEWLINE> print ( <STRING> ) <NEWLINE> <DEDENT>
s = print ( ) <NEWLINE> if s == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else s == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
if S == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> def contest ( N ) : <NEWLINE> <INDENT> if N == <STRING> : <NEWLINE> <INDENT> return ARC <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return ABC <NEWLINE> <DEDENT> <DEDENT> contest ( N ) <NEWLINE>
S = input ( ) <NEWLINE> if S = ABC : <NEWLINE> <INDENT> print ( ARC ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ABC ) <NEWLINE> <DEDENT>
s = char ( input ( ) ) <NEWLINE> if s == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
S = int ( input ( ) ) <NEWLINE> if S = <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <NL> <NL> <NL> <NL> <DEDENT>
s = int ( input ( ) ) <NEWLINE> if s == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : print ( <STRING> ) <NEWLINE>
s = input ( ) <NEWLINE> if s = <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> if input ( ) == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
str = input ( ) <NEWLINE> <NL> if ( str == <STRING> ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> el : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
lw = input ( ) <NEWLINE> if lw = <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> a = <STRING> <NEWLINE> r = <STRING> <NEWLINE> s = input ( ) <NEWLINE> if s == a : <NEWLINE> <INDENT> print ( r ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
a = intput ( <STRING> ) <NEWLINE> if a == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> if ( s [ 1 ] == B ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
S = input ( ) <NEWLINE> <INDENT> if S == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif S == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
s = input ( ) <NEWLINE> if s == <STRING> : print ( <STRING> ) <NEWLINE> else print ( <STRING> ) <NEWLINE>
a = input ( ) <NEWLINE> if a is <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> eles : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
t = input ( ) <NEWLINE> if ( t == <STRING> ) { <NEWLINE> <INDENT> print ( <STRING> ) } <NEWLINE> <DEDENT> else { <NEWLINE> <INDENT> print ( <STRING> ) } <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> import math <NEWLINE> s = input ( ) <NEWLINE> if s == <STRING> <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> <NL> N = int ( input ( <STRING> ) ) <NEWLINE> K = int ( input ( <STRING> ) ) <NEWLINE> A = [ ] <NEWLINE> l = [ ] <NEWLINE> for i in range ( K ) : <NEWLINE> <INDENT> d = int ( input ( <STRING> ) ) <NEWLINE> for j in range ( d ) : <NEWLINE> <INDENT> l_ = int ( input ( <STRING> ) ) <NEWLINE> l . append ( l_ ) <NEWLINE> <DEDENT> A . append ( l ) <NEWLINE> <NL> <DEDENT> a = np . zeros ( ( N , K ) ) <NEWLINE> for i in range ( len ( A ) ) : <NEWLINE> <INDENT> for j in range ( len ( A [ i ] ) ) : <NEWLINE> <INDENT> a [ A [ i ] [ j ] - 1 ] [ i ] = 1 <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> print ( np . count_nonzero ( np . all ( a == 0 , axis = 1 ) ) ) <NEWLINE> <NL>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> tmp_A = [ 0 ] * N <NEWLINE> ans = 0 <NEWLINE> <NL> for i in range ( K ) : <NEWLINE> <INDENT> d = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for j in range ( d ) : <NEWLINE> <INDENT> tmp_A [ A [ j ] - 1 ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> tmp_A [ i ] == 0 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> sweet = [ 0 for i in range ( N ) ] <NEWLINE> for i in range ( K ) : <NEWLINE> <INDENT> input ( ) <NEWLINE> for j in map ( int , input ( ) . split ( ) ) : <NEWLINE> <INDENT> sweet [ j ] = 1 <NEWLINE> <DEDENT> <DEDENT> cnt = 0 <NEWLINE> for k in sweet : <NEWLINE> <INDENT> if k == 0 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> list = [ 0 ] * N <NEWLINE> for _ in range ( K ) : <NEWLINE> <INDENT> d = int ( input ( ) ) <NEWLINE> l2 = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> print ( l2 ) <NEWLINE> for val in l2 : <NEWLINE> <INDENT> list [ val - 1 ] = 1 <NEWLINE> <DEDENT> <DEDENT> print ( N - sum ( list ) ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> P = [ 0 for i in range ( N ) ] <NEWLINE> for i in range ( K ) : <NEWLINE> <INDENT> a = int ( input ( ) ) <NEWLINE> b = list ( map ( int , ( input ( ) . split ( ) ) ) <NEWLINE> for j in range ( a ) : <NEWLINE> <INDENT> P [ b [ j ] - 1 ] = 1 <NEWLINE> <DEDENT> <DEDENT> m = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if P [ i ] == 0 : <NEWLINE> <INDENT> m += 1 <NEWLINE> <DEDENT> <DEDENT> print ( m ) <NEWLINE>
n , k = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> a = list ( 1 for i in range ( n + 1 ) ) <NEWLINE> for z in range ( k ) : <NEWLINE> <INDENT> x = int ( input ( ) ) <NEWLINE> temp = map ( int , input . split ( <STRING> ) ) <NEWLINE> for i in temp : <NEWLINE> <INDENT> a [ i ] += 1 <NEWLINE> c = 0 <NEWLINE> <DEDENT> <DEDENT> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if ( a [ i ] == 0 ) : <NEWLINE> <INDENT> c + + <NEWLINE> <DEDENT> <DEDENT> print ( c ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> tmp = set ( ) <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> input ( ) <NEWLINE> tmp |= set ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <DEDENT> print ( len ( set ( range ( 1 , N + 1 ) ) - tmp ) ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> sunuke = [ ] <NEWLINE> for i in range ( K ) : <NEWLINE> <INDENT> d = int ( input ( ) ) <NEWLINE> okashi = input ( ) . split ( ) <NEWLINE> for i in range ( d ) : <NEWLINE> <INDENT> sunuke . append ( okashi [ i ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> have_okashi = collections . Counter ( sunuke ) <NEWLINE> print ( N - len ( have_okashi ) ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> lst = [ 0 ] * N <NEWLINE> <NL> for i in range ( K ) : <NEWLINE> <INDENT> d = input ( ) <NEWLINE> <INDENT> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for a in A : <NEWLINE> <INDENT> lst [ a - 1 ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( lst . count ( 0 ) ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = [ ] <NEWLINE> for _ in range ( k ) : <NEWLINE> <INDENT> d = list ( int ( input ( ) ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans += a <NEWLINE> <DEDENT> print ( n - len ( set ( ans ) ) ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> x = [ 0 ] * n <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> y = int ( input ( ) ) <NEWLINE> z = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for j in z : <NEWLINE> <INDENT> x [ j - 1 ] += 1 <NEWLINE> <DEDENT> <DEDENT> a = 0 <NEWLINE> for b in x : <NEWLINE> <INDENT> if b == 0 : <NEWLINE> <INDENT> c += 1 <NEWLINE> <DEDENT> <DEDENT> print ( c ) <NEWLINE>
from copy import copy <NEWLINE> from functool import reduce <NEWLINE> <NL> class Sunkune : <NEWLINE> <INDENT> def __init__ ( self ) : <NEWLINE> <INDENT> self . has_snack = False <NEWLINE> <NL> <DEDENT> <DEDENT> n_sunuke , n_v_snacks = [ int ( s ) for s in input ( ) . split ( 2 ) ] <NEWLINE> <NL> all_sunuke = [ copy ( Sunuke ( ) ) for i in range ( n_sunuke ) ] <NEWLINE> <NL> for snack_id in n_v_snacks : <NEWLINE> <INDENT> n_snacks = int ( input ( ) ) <NEWLINE> for sunuke_id in ( int ( s ) for s in input ( ) . split ( ) ) : <NEWLINE> <INDENT> all_sunuke [ s - 1 ] . has_snack = True <NEWLINE> <NL> <DEDENT> <DEDENT> print ( reduce ( lambda n , s : n + ( 0 if s . has_snack else 1 ) , all_sunuke , 0 ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> C = [ 0 for _ in range ( N ) ] <NEWLINE> ct = N <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> d = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for a in A : <NEWLINE> <INDENT> if C [ a - 1 ] == 0 : <NEWLINE> <INDENT> C [ a - 1 ] += 1 <NEWLINE> ct -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ct ) <NEWLINE> <NL>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> lst = [ ] <NEWLINE> for _ in range ( k ) : <NEWLINE> <INDENT> d = int ( input ( ) ) <NEWLINE> lstx = [ int ( input ( ) ) for _ in range ( d ) ] <NEWLINE> lst += lstx <NEWLINE> <DEDENT> setans = set ( lst ) <NEWLINE> print ( n - len ( setans ) ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> susuke = [ 1 ] * N <NEWLINE> <NL> for i in range ( K ) : <NEWLINE> <INDENT> di = int ( input ( ) ) <NEWLINE> ai = map ( int , input ( ) . split ( ) ) <NEWLINE> for j in range ( ai ) : <NEWLINE> <INDENT> susuke [ j - 1 ] = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( sum ( susuke ) ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> n_list = [ 1 ] * n <NEWLINE> for _ in range ( k ) : <NEWLINE> <INDENT> _ = input ( ) <NEWLINE> for i in range ( list ( map ( int , input ( ) . split ( ) ) ) ) : <NEWLINE> <INDENT> n_list [ i - 1 ] = 0 <NEWLINE> <DEDENT> <DEDENT> print ( sum ( n_list ) ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> check = N * [ 0 ] <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> d = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i in a : <NEWLINE> <INDENT> check [ i - 1 ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( check . count ( 0 ) ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> S = [ ] <NEWLINE> b = 0 <NEWLINE> <NL> for i in ( K ) : <NEWLINE> <INDENT> d = input ( ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i in A : <NEWLINE> <INDENT> S [ i ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> for i in ( len ( S ) ) : <NEWLINE> <INDENT> if S [ i ] == 0 : <NEWLINE> <INDENT> b += 1 <NEWLINE> <DEDENT> <DEDENT> print ( b ) <NEWLINE>
<INDENT> = [ int ( x ) for x in input ( ) . split ( <STRING> ) ] <NEWLINE> <NL> <DEDENT> def solve ( n , k ) : <NEWLINE> <INDENT> snukes = [ None ] * n <NEWLINE> victims = 0 <NEWLINE> <NL> for i in range ( k ) : <NEWLINE> <INDENT> snacks = int ( input ( ) ) <NEWLINE> snukes_snacks = [ int ( z ) for z in input ( ) . split ( <STRING> ) ] <NEWLINE> for j in range ( snacks ) : <NEWLINE> <INDENT> snukes [ j - 1 ] = snukes_snacks [ j - 1 ] <NEWLINE> <NL> <DEDENT> <DEDENT> for w in range ( n ) : <NEWLINE> <INDENT> if snukes [ w ] is None : <NEWLINE> <INDENT> victims += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( victims ) <NEWLINE> <NL> <DEDENT> solve ( n , k ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> A = [ ] <NEWLINE> <NL> for i range ( K ) : <NEWLINE> <INDENT> d = int ( input ( ) ) <NEWLINE> A [ i ] = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> <NL> <DEDENT> print ( 3 ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> s = { i + 1 for i in range ( N ) } <NEWLINE> t = { } <NEWLINE> for i in range ( K ) : <NEWLINE> <INDENT> input ( ) <NEWLINE> t |= set ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <DEDENT> print ( len ( s - t ) ) <NEWLINE>
( n , k ) = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> <NL> s = set ( ) <NEWLINE> <NL> for i in range ( k ) : <NEWLINE> <INDENT> input ( ) <NEWLINE> s |= set ( input ( ) . split ) <NEWLINE> <NL> <DEDENT> print ( n - len ( s ) ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> S = set ( ) <NEWLINE> <NL> for n in range ( N ) : <NEWLINE> <INDENT> input ( ) <NEWLINE> S |= set ( input ( ) . split ( ) ) <NEWLINE> <NL> <DEDENT> print ( N - len ( S ) ) <NEWLINE>
N , K = int ( input ( ) . split ( ) ) <NEWLINE> Sunuke = set ( range ( N ) ) <NEWLINE> for i in range ( K ) : <NEWLINE> <INDENT> d = int ( input ( ) ) <NEWLINE> X = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for x in X : <NEWLINE> <INDENT> Sunuke . discard ( x - 1 ) <NEWLINE> <DEDENT> <DEDENT> print ( len ( Sunuke ) ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> P = [ 0 for i in range ( N ) ] <NEWLINE> for i in range ( K ) : <NEWLINE> <INDENT> a = int ( input ( ) ) <NEWLINE> b = list ( map ( int , ( input ( ) . split ( ) ) ) <NEWLINE> for j in range ( a ) : <NEWLINE> <INDENT> P [ b [ j ] - 1 ] = 1 <NEWLINE> <DEDENT> <DEDENT> m = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if P [ i ] == 0 : <NEWLINE> <INDENT> m += 1 <NEWLINE> <DEDENT> <DEDENT> print ( m ) <NEWLINE>
l1 = input ( ) . split ( <STRING> ) <NEWLINE> n = int ( l1 [ 0 ] ) <NEWLINE> k = int ( l1 [ 1 ] ) <NEWLINE> list = [ range ( n ) ] <NEWLINE> kashi = [ ] <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> tmp = input ( ) <NEWLINE> num = input ( ) . split ( <STRING> ) <NEWLINE> kashi . append ( num ) <NEWLINE> <DEDENT> kashi = set ( kashi ) <NEWLINE> print ( n - len ( kashi ) ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = set ( ) <NEWLINE> <NL> for _ in range ( k ) : <NEWLINE> <INDENT> d = int ( input ( ) ) <NEWLINE> a += [ int ( m ) for m in input ( ) . split ( <STRING> ) ] <NEWLINE> <NL> <DEDENT> print ( n - len ( a ) ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = set ( ) <NEWLINE> for _ in range ( K ) : <NEWLINE> <INDENT> d = int ( input ( ) ) <NEWLINE> A . add ( list ( input ( ) . split ( ) ) ) <NEWLINE> <DEDENT> print ( N - len ( A ) ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> s = [ ] <NEWLINE> for i in range ( K ) : <NEWLINE> <INDENT> d = int ( input ( ) ) <NEWLINE> for j in range ( d ) : <NEWLINE> <INDENT> s += [ int ( input ( ) ) ] <NEWLINE> <DEDENT> <DEDENT> s = set ( s ) <NEWLINE> <COMMENT> <NL> s = list ( s ) <NEWLINE> <COMMENT> <NL> s . sort ( ) <NEWLINE> <COMMENT> <NL> print ( N - len ( s ) ) <NEWLINE>
import sys <NEWLINE> def Ii ( ) : return int ( sys . stdin . buffer . readline ( ) ) <NEWLINE> def Mi ( ) : return map ( int , sys . stdin . buffer . readline ( ) . split ( ) ) <NEWLINE> def Li ( ) : return list ( map ( int , sys . stdin . buffer . readline ( ) . split ( ) ) ) <NEWLINE> <NL> n , k = Mi ( ) <NEWLINE> b = [ 1 ] * n <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> d = Ii ( ) <NEWLINE> a = Li ( ) <NEWLINE> for j in a : <NEWLINE> <INDENT> b [ j ] = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( sum ( b ) - 1 ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = list ( ) <NEWLINE> for i in range ( K ) : <NEWLINE> <INDENT> D = int ( input ( ) ) <NEWLINE> L = list ( map ( int , input ( ) , split ( ) ) ) <NEWLINE> ans += L <NEWLINE> ans = list ( set ( ans ) ) <NEWLINE> <DEDENT> print ( N - len ( ans ) ) <NEWLINE>
n , k = list ( map ( int , input ( ) . strip ( ) . split ( ) ) ) <NEWLINE> temp = [ ] <NEWLINE> ans = int ( 0 ) <NEWLINE> for i in range ( k + 1 ) : <NEWLINE> <INDENT> d = int ( input ( ) ) <NEWLINE> li = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for j in range ( d ) : <NEWLINE> <INDENT> temp += str ( li [ j ] ) <NEWLINE> <DEDENT> <DEDENT> for m in range ( n + 1 ) : <NEWLINE> <INDENT> b = str ( m + 1 ) <NEWLINE> a = temp . count ( b ) <NEWLINE> if a == 0 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
if __name__ == <STRING> : <NEWLINE> <INDENT> str_N_K = input ( ) <NEWLINE> <NL> list_N_K = str_N_K . split ( <STRING> ) <NEWLINE> N = int ( list_N_K [ 0 ] ) <NEWLINE> K = int ( list_N_K [ 1 ] ) <NEWLINE> <NL> list_person = [ 0 ] * N <NEWLINE> <NL> for i in range ( K ) : <NEWLINE> <INDENT> d = int ( input ( ) ) <NEWLINE> str_persons = input ( ) <NEWLINE> if ( <STRING> in str_persons ) : <NEWLINE> <INDENT> list_str_persons = str_persons . split ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> list_str_persons = [ str_persons ] <NEWLINE> <NL> <DEDENT> for str_person in list_str_persons : <NEWLINE> <INDENT> int_person = int ( str_person ) <NEWLINE> list_person [ int_person ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> output = 0 <NEWLINE> for person in list_person : <NEWLINE> <INDENT> if person == 0 : <NEWLINE> <INDENT> output += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( output ) <NEWLINE> <NL> <NL> <NL> <DEDENT>
N , K = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> Snack = [ 0 ] * N <NEWLINE> <NL> for i in range ( K ) : <NEWLINE> <INDENT> d = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for j in range ( d ) : <NEWLINE> <INDENT> Snack [ A [ j ] ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> sum = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if ( Snack [ i ] == 0 ) : <NEWLINE> <INDENT> sum += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( sum ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ 0 ] * n <NEWLINE> for i in range ( K ) : <NEWLINE> <INDENT> d = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for l in A : <NEWLINE> <INDENT> a [ l - 1 ] = 1 <NEWLINE> <DEDENT> <DEDENT> print ( a . count ( 0 ) ) <NEWLINE>
<COMMENT> <NL> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> sunuke_list = [ False for i in range ( n ) ] <NEWLINE> <NL> for i in range ( k ) : <NEWLINE> <INDENT> d = int ( input ( ) ) <NEWLINE> has_sunuke_list = input ( ) . split ( ) <NEWLINE> for k in has_sunuke_list : <NEWLINE> <INDENT> sunuke_list [ int ( k ) - 1 ] = True <NEWLINE> <NL> <DEDENT> <DEDENT> print ( sunuke_list . coutn ( False ) ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> x = [ 0 ] * n <NEWLINE> <NL> for i in range ( k ) : <NEWLINE> <INDENT> d = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for j in a : <NEWLINE> <INDENT> x [ j ] = x [ j ] + 1 <NEWLINE> <DEDENT> <DEDENT> print ( x . count ( 0 ) ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ ] <NEWLINE> for i in range ( K ) : <NEWLINE> <INDENT> di = int ( input ( ) ) <NEWLINE> for j in range ( di ) : <NEWLINE> <INDENT> a . append ( map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> a = set ( a ) <NEWLINE> print ( N - len ( a ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> K = int ( input ( ) ) <NEWLINE> ans = [ 1 ] * N <NEWLINE> <NL> for i in range ( 0 , K ) : <NEWLINE> <INDENT> d = int ( input ( ) ) <NEWLINE> table = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for j in range ( 0 , N ) : <NEWLINE> <INDENT> if table . count ( j ) == 0 : <NEWLINE> <INDENT> ans [ j ] = 0 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( 1 - sum ( ans ) ) <NEWLINE>
n , k = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> hoge = [ 1 ] * n <NEWLINE> <NL> for i in range ( k * 2 ) : <NEWLINE> <INDENT> if i % 2 != 0 : <NEWLINE> <INDENT> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for j in a : <NEWLINE> <INDENT> hoge [ j - 1 ] = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( sum ( hoge ) ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> d = [ ] <NEWLINE> for i in range ( k * 2 ) : <NEWLINE> <INDENT> d . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> <DEDENT> ans = [ ] <NEWLINE> for i in range ( 1 , len ( d ) , 2 ) : <NEWLINE> <INDENT> ans . append ( * d [ i ] ) <NEWLINE> <NL> <DEDENT> ans = len ( set ( ans ) ) <NEWLINE> print ( n - ans ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> lst = [ for _ in range ( 1 , n + 1 ) ] <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> x = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = set ( a ) <NEWLINE> for j in b : <NEWLINE> <INDENT> lst . remove ( j ) <NEWLINE> <DEDENT> <DEDENT> print ( len ( lst ) ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> m = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> d = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i in a : <NEWLINE> <INDENT> m = m . append ( i ) <NEWLINE> <DEDENT> <DEDENT> j = set ( m ) <NEWLINE> print ( n - len ( j ) ) <NEWLINE> <NL>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> s = set ( ) <NEWLINE> for i in [ 0 ] * n : <NEWLINE> <INDENT> _ = input ( ) <NEWLINE> s |= set ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <DEDENT> print ( k - len ( s ) ) <NEWLINE>
import sys <NEWLINE> read = sys . stdin . readline <NEWLINE> import time <NEWLINE> import math <NEWLINE> import itertools as it <NEWLINE> def inp ( ) : <NEWLINE> <INDENT> return int ( input ( ) ) <NEWLINE> <DEDENT> def inpl ( ) : <NEWLINE> <INDENT> return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <DEDENT> start_time = time . perf_counter ( ) <NEWLINE> <COMMENT> <NL> <NL> N , K = inpl ( ) <NEWLINE> dp = [ False ] * N <NEWLINE> for i in range ( K ) : <NEWLINE> <INDENT> d = inp ( ) <NEWLINE> A = inpl ( ) <NEWLINE> for a in A : <NEWLINE> <INDENT> dp [ A - 1 ] = True <NEWLINE> <DEDENT> <DEDENT> cnt = 0 <NEWLINE> for bl in dp : <NEWLINE> <INDENT> if not bl : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE> <NL> <COMMENT> <NL> end_time = time . perf_counter ( ) <NEWLINE> print ( <STRING> , end_time - start_time , file = sys . stderr ) <NEWLINE>
s = [ ] <NEWLINE> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> s . append ( 0 ) <NEWLINE> <DEDENT> for i in range ( k ) : <NEWLINE> <INDENT> m = int ( input ( ) ) <NEWLINE> <INDENT> na = list ( map ( int , input ( ) . split ( ) ) <NEWLINE> for j in na : <NEWLINE> <INDENT> s [ j - 1 ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( s . count ( 0 ) ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> import itertools <NEWLINE> <NL> grid = [ ] <NEWLINE> for i in range ( 2 * k ) : <NEWLINE> <INDENT> array = list ( map ( int , input ( ) . strip ( ) . split ( ) ) ) <NEWLINE> grid . append ( array ) <NEWLINE> <DEDENT> for j in range ( k ) : <NEWLINE> <INDENT> l . append ( grid [ 0 + 2 * j + 1 ] ) <NEWLINE> <DEDENT> lis = list ( itertools . chain . from_iterable ( l ) ) <NEWLINE> count = 0 <NEWLINE> for m in range ( n ) : <NEWLINE> <INDENT> if m + 1 in lis : <NEWLINE> <INDENT> count = count + 1 <NEWLINE> <DEDENT> <DEDENT> print ( n - count ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> snk = [ - 1 ] * ( n + 1 ) <NEWLINE> for j in range ( k ) : <NEWLINE> <INDENT> d = input ( ) <NEWLINE> list = map ( int , input ( ) . split ( ) ) <NEWLINE> <INDENT> for i in range ( d ) : <NEWLINE> <INDENT> snk [ list [ i ] ] = 0 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> for j in range ( n ) : <NEWLINE> <INDENT> if snk [ j ] == - 1 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> d = int ( input ( ) ) <NEWLINE> while True : <NEWLINE> <INDENT> val = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> if len ( val ) == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( N - d ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> s = [ ] <NEWLINE> ans = 0 <NEWLINE> for i in range ( K ) : <NEWLINE> <INDENT> d = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i in range ( d ) : <NEWLINE> <INDENT> s . append ( A [ i ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( K ) : <NEWLINE> <INDENT> if s . count ( i ) == 0 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<NL> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ 0 ] * N <NEWLINE> <NL> for i in range ( K ) : <NEWLINE> <INDENT> d = int ( input ( ) ) <NEWLINE> targets = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for j in range ( d ) : <NEWLINE> <INDENT> index = targets [ j - 1 ] <NEWLINE> A [ index ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> count = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if A [ i ] == 0 : <NEWLINE> <INDENT> count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
n , k = int ( input ( ) ) <NEWLINE> f = [ ] <NEWLINE> for _ in range ( k ) : <NEWLINE> <INDENT> x = int ( input ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i in range ( len ( l ) ) : <NEWLINE> <INDENT> f . append ( l [ i ] ) <NEWLINE> <DEDENT> <DEDENT> f = set ( f ) <NEWLINE> print ( n - len ( f ) ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> x = [ c for c in range ( 1 , n + 1 ) ] <NEWLINE> for i in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> d = int ( input ( ) ) <NEWLINE> s = input ( ) . split ( ) <NEWLINE> for b in range ( d ) : <NEWLINE> <INDENT> if int ( s [ b ] ) in x : <NEWLINE> <INDENT> x . remove ( int ( s_i [ b ] ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( len ( x ) ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> sunuke = [ 1 for _ in range ( n ) ] <NEWLINE> for _ in range ( k ) : <NEWLINE> <INDENT> d = int ( input ( ) ) <NEWLINE> for x in list ( map ( int , input ( ) . split ( ) ) : <NEWLINE> <INDENT> sunuke [ x - 1 ] = 0 <NEWLINE> <DEDENT> <DEDENT> print ( sum ( sunuke ) ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> list = [ ] <NEWLINE> for p in range ( k ) : <NEWLINE> <INDENT> m = int ( input ( ) ) <NEWLINE> k_list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for q in k_list : <NEWLINE> <INDENT> if not q in list : <NEWLINE> <INDENT> list . append ( q ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> k_l = len ( k_list ) <NEWLINE> print ( n - k_l ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> lis = [ i for i in range ( 1 , n + 1 ) ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> d = int ( input ( ) ) <NEWLINE> for j in range ( d ) : <NEWLINE> <INDENT> a = int ( input ( ) ) <NEWLINE> if a in lis : <NEWLINE> <INDENT> lis . remove ( a ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( len ( lis ) ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> P = [ 0 for i in range ( N ) ] <NEWLINE> for i in range ( K ) : <NEWLINE> <INDENT> a = int ( input ( ) ) <NEWLINE> b = list ( int , input ( ) . split ( ) ) <NEWLINE> for i in range ( a ) : <NEWLINE> <INDENT> P [ b [ i ] - 1 ] = 1 <NEWLINE> <DEDENT> <DEDENT> m = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if P [ l ] == 0 : <NEWLINE> <INDENT> m += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( m ) <NEWLINE>
def main ( n , a ) : <NEWLINE> <INDENT> indexes = { i + 1 for i in range ( n ) } <NEWLINE> reduced = set ( ) <NEWLINE> for s in a : <NEWLINE> <INDENT> reduced |= s <NEWLINE> <DEDENT> return len ( indexes - reduced ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> S = input ( ) . rstrip ( ) <NEWLINE> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ ] <NEWLINE> for _ in range ( K ) : <NEWLINE> <INDENT> input ( ) <NEWLINE> A . append ( set ( tuple ( map ( int , input ( ) . split ( <STRING> ) ) ) ) ) <NEWLINE> <DEDENT> print ( main ( N , A ) ) <NEWLINE> <DEDENT>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> aaa = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( b * 2 ) ] <NEWLINE> <NL> s = { i + 1 for i in range ( a ) } <NEWLINE> <NL> for i in range ( 1 , a + 1 , 2 ) : <NEWLINE> <INDENT> for k in aaa [ i ] : <NEWLINE> <INDENT> for j in k : <NEWLINE> <INDENT> s . discard ( j ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( len ( s ) ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> flag = [ 1 for i in range ( n ) ] <NEWLINE> for _ in range ( k ) : <NEWLINE> <INDENT> d = int ( input ( ) ) <NEWLINE> for _ in range ( d ) : <NEWLINE> <INDENT> for a in map ( int , input ( ) . split ( ) ) : <NEWLINE> <INDENT> flag [ a - 1 ] = 0 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( sum ( flag ) ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> cnt = [ 0 ] * N <NEWLINE> for i in range ( K ) : <NEWLINE> <INDENT> d = int ( input ( ) ) <NEWLINE> A = list ( map ( int ( ) , input ( ) . split ( ) ) ) <NEWLINE> for a in A : <NEWLINE> <INDENT> cnt [ a - 1 ] = cnt [ a - 1 ] + 1 <NEWLINE> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if cnt [ i ] == 0 : <NEWLINE> <INDENT> ans = ans + 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL>
<COMMENT> <NL> N , K = int ( input ( ) ) <NEWLINE> <NL> d_list = [ ] <NEWLINE> A_list_list = [ ] <NEWLINE> for i in range ( K ) : <NEWLINE> <COMMENT> <NL> <INDENT> d = int ( input ( ) ) <NEWLINE> d_list . append ( d ) <NEWLINE> <COMMENT> <NL> A_list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A_list_list . append ( A_list ) <NEWLINE> <NL> <DEDENT> counter = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if ( ( i + 1 in A_list ) == True ) : <NEWLINE> <INDENT> counter = counter <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> counter = counter + 1 <NEWLINE> <DEDENT> <DEDENT> print ( counter ) <NEWLINE> <NL>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> Sunuke = [ 0 ] * N <NEWLINE> d = list ( ) <NEWLINE> A = list ( ) <NEWLINE> for _ in range ( K ) : <NEWLINE> <INDENT> d = int ( input ( ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for a in A : <NEWLINE> <INDENT> Sunuke [ a - 1 ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for s in Sunuke : <NEWLINE> <INDENT> if s == 0 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
^ CTraceback ( most recent call last ) : <NEWLINE> <INDENT> File <STRING> , line 6 , in < module > <NEWLINE> <INDENT> if x >= x2 and x <= y2 : <NEWLINE> <DEDENT> <DEDENT> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> okashi = [ 0 ] * N <NEWLINE> for i in range ( K ) : <NEWLINE> <INDENT> x = input ( ) <NEWLINE> y = input ( ) . split ( ) <NEWLINE> for j in y : <NEWLINE> <INDENT> okashi [ int ( j ) - 1 ] = 1 <NEWLINE> <DEDENT> <DEDENT> counter = 0 <NEWLINE> <NL> for i in okashi : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> counter = counter + 1 <NEWLINE> <DEDENT> <DEDENT> print ( counter ) <NEWLINE>
n , k = map ( int , input ( ) ) <NEWLINE> total = [ ] <NEWLINE> for _ in range ( k ) : <NEWLINE> <INDENT> d = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for a in A : <NEWLINE> <INDENT> total . append ( a ) <NEWLINE> <DEDENT> <DEDENT> ans = n - len ( set ( total ) ) <NEWLINE> print ( ans ) <NEWLINE> <NL>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> lis = [ 0 ] * b <NEWLINE> for i in range ( a ) : <NEWLINE> <INDENT> c = int ( input ( ) ) <NEWLINE> d = input ( ) . split ( ) <NEWLINE> <NL> for l in range ( c ) : <NEWLINE> <INDENT> lis [ int ( d [ l ] ) - 1 ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> count = 0 <NEWLINE> for i in range ( b ) : <NEWLINE> <INDENT> if ( lis [ i ] == 0 ) : <NEWLINE> <INDENT> count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> P = [ 0 ] * N <NEWLINE> m = 0 <NEWLINE> for i in range ( K ) : <NEWLINE> <INDENT> a = int ( input ( ) ) <NEWLINE> b = list ( int , input ( ) . split ( ) ) <NEWLINE> for j in range ( a ) : <NEWLINE> <INDENT> P [ b [ j ] - 1 ] = 1 <NEWLINE> j += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> for l in range ( N ) : <NEWLINE> <INDENT> if P [ l ] == 1 : <NEWLINE> <INDENT> m += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> peint ( m ) <NEWLINE> <NL>
N = int ( input ( ) ) <NEWLINE> K = int ( input ( ) ) <NEWLINE> A = [ ] <NEWLINE> for i in range ( K ) : <NEWLINE> <INDENT> d = int ( input ( ) ) <NEWLINE> for i in range ( d ) : <NEWLINE> <INDENT> a = int ( input ( ) ) <NEWLINE> A . append ( a ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> ans = len ( list ( set ( A ) ) ) <NEWLINE> print ( N - ans ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> s = [ t for t in range ( 1 , N + 1 ) ] <NEWLINE> for i in range ( K ) : <NEWLINE> <INDENT> d = int ( input ( ) ) <NEWLINE> A = list ( map ( input ( ) . split ( ) ) ) <NEWLINE> if A [ i ] in s : <NEWLINE> <INDENT> s . remove ( A [ i ] ) <NEWLINE> <DEDENT> K -= 1 <NEWLINE> <DEDENT> print ( lne ( s ) ) <NEWLINE>
import numpy as np <NEWLINE> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> l = np . zeros ( n ) <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> d = int ( input ( ) ) <NEWLINE> a = map ( int , input ( ) . split ( ) ) <NEWLINE> for j in range ( d ) : <NEWLINE> <INDENT> l [ a [ j ] - 1 ] = 1 <NEWLINE> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for i in l : <NEWLINE> <INDENT> if ( i == 0 ) : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N , K = [ int ( ipt ) for ipt in input ( ) . split ( <STRING> ) ] <NEWLINE> <NL> sunukekuns = [ str ( i ) for i in range ( N ) ] <NEWLINE> <NL> for k in range ( K ) : <NEWLINE> <INDENT> _ = input ( ) <NEWLINE> sunukekun = input ( ) . split ( <STRING> ) <NEWLINE> for ( kun in sunukekun ) : <NEWLINE> <INDENT> if kun in sunukekuns : <NEWLINE> <INDENT> sunukekuns . remove ( kun ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( len ( sunukekuns ) ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> d = [ ] <NEWLINE> A = [ ] <NEWLINE> c = [ ] <NEWLINE> <NL> for i in range ( k ) : <NEWLINE> <INDENT> d . append ( int ( input ( ) ) ) <NEWLINE> a = input ( ) <NEWLINE> A . append ( [ int ( a [ j ] ) for j in range ( a ) ] ) <NEWLINE> <NL> <DEDENT> for j in range ( k ) : <NEWLINE> <INDENT> for m in range ( d [ j ] ) : <NEWLINE> <INDENT> c . append ( A [ j ] [ m ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( n - len ( set ( c ) ) ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> d = [ ] <NEWLINE> a = [ ] <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> d . append ( int ( input ) ) <NEWLINE> a . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> <DEDENT> aa = [ 0 ] * n <NEWLINE> <NL> for j in a : <NEWLINE> <INDENT> for t in j : <NEWLINE> <INDENT> aa [ t - 1 ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> ans = 0 <NEWLINE> <NL> for z in aa : <NEWLINE> <INDENT> if z == 0 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += 0 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> arr = [ ] <NEWLINE> for _ in range ( k ) : <NEWLINE> . d = int ( input ( ) ) <NEWLINE> <INDENT> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> arr . append ( a ) <NEWLINE> <NL> <DEDENT> oks = [ False ] * n <NEWLINE> for xs in arr : <NEWLINE> <INDENT> for x in xs : <NEWLINE> <INDENT> oks [ x - 1 ] = True <NEWLINE> <NL> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for x in oks : <NEWLINE> <INDENT> if x == False : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> K = int ( input ( ) ) <NEWLINE> l = [ ] <NEWLINE> for k in range ( K ) : <NEWLINE> <INDENT> a = int ( input ( ) ) <NEWLINE> for i in range ( a ) : <NEWLINE> <INDENT> l . append ( int ( input ( ) ) ) <NEWLINE> <DEDENT> <DEDENT> print ( l ) <NEWLINE> for j in range ( N ) : <NEWLINE> <INDENT> if not j + 1 in l : <NEWLINE> <INDENT> print ( j + 1 ) <NEWLINE> <DEDENT> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> m = [ ] <NEWLINE> for _ in range ( 2 * k ) : <NEWLINE> <INDENT> d = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i in a : <NEWLINE> <INDENT> if i not in m : <NEWLINE> <INDENT> m . append ( i ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> mx = max ( m ) <NEWLINE> c = 0 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if ( i not in m ) : <NEWLINE> <INDENT> c += 1 <NEWLINE> <DEDENT> <DEDENT> print ( c ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> lists = [ ] <NEWLINE> for _ in range ( k ) : <NEWLINE> <INDENT> d = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> lists . append ( list ) <NEWLINE> <DEDENT> num = [ 0 ] * n <NEWLINE> for list in lists : <NEWLINE> <INDENT> for __ in range ( len ( list ) ) : <NEWLINE> <INDENT> num [ list [ __ ] - 1 ] += 1 <NEWLINE> <DEDENT> <DEDENT> count = 0 <NEWLINE> for nn in num : <NEWLINE> <INDENT> if nn == 0 : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
for okashi_number in range ( k ) : <NEWLINE> <INDENT> di = int ( input ( ) ) <NEWLINE> D = map ( int , input ( ) . split ( ) ) <NEWLINE> for x in range ( di ) <NEWLINE> <INDENT> A [ [ x ] - 1 ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> if A [ i ] == 0 : <NEWLINE> print ( A [ i ] ) <NEWLINE> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> Sanuke = list ( range ( K ) ) <NEWLINE> <NL> def calc_double ( n ) : <NEWLINE> <INDENT> return n - 1 <NEWLINE> <NL> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> di = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A = map ( calc_double , A ) <NEWLINE> for j in A : <NEWLINE> <INDENT> Sanuke [ j ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> higaisha = 0 <NEWLINE> <NL> for i in Sanuke : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> higaisha += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( higaisha ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> P = [ 0 for i in range ( N ) ] <NEWLINE> for i in range ( K ) : <NEWLINE> <INDENT> a = int ( input ( ) ) <NEWLINE> b = list ( map ( int , ( input ( ) . split ( ) ) ) <NEWLINE> for j in range ( a ) : <NEWLINE> <INDENT> P [ b [ j ] - 1 ] = 1 <NEWLINE> <DEDENT> <DEDENT> m = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if P [ i ] == 0 : <NEWLINE> <INDENT> m += 1 <NEWLINE> <DEDENT> <DEDENT> print ( m ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = set ( ) <NEWLINE> for i in [ 0 ] * k : <NEWLINE> <INDENT> _ = input ( ) <NEWLINE> a . add ( * map ( int , input ( ) . split ( ) ) ) <NEWLINE> <DEDENT> print ( n - len ( a ) ) <NEWLINE>
n = input ( ) . split ( ) <NEWLINE> N = int ( n [ 0 ] ) <NEWLINE> K = int ( n [ 1 ] ) <NEWLINE> s = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( 2 * K + 1 ) ] <NEWLINE> b = list ( range ( N ) ) <NEWLINE> for l in b : <NEWLINE> <INDENT> for i in range ( K ) : <NEWLINE> <INDENT> di = s [ 2 * i ] <NEWLINE> ai = s [ 2 * i + 1 ] <NEWLINE> for k in ai : <NEWLINE> <INDENT> if k == l : <NEWLINE> <INDENT> b . remove ( l ) <NEWLINE> ai . remove ( l ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( len ( b ) ) <NEWLINE>
x = input ( ) . split ( ) <NEWLINE> <NL> n = int ( x [ 0 ] ) <NEWLINE> k = int ( x [ 1 ] ) <NEWLINE> ds = [ ] <NEWLINE> bool_array = [ 0 ] * n <NEWLINE> <NL> for num in range ( k ) : <NEWLINE> <INDENT> di = int ( input ( ) ) <NEWLINE> ajs_input = input ( ) . split ( <STRING> ) <NEWLINE> for j in range ( di ) : <NEWLINE> <INDENT> bool_array [ int ( ajs_input [ j ] ) - 1 ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( n - np . array ( bool_array ) . sum ( ) ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> <COMMENT> <NL> d = [ 0 ] * n <NEWLINE> <COMMENT> <NL> for i in range ( k ) : <NEWLINE> <COMMENT> <NL> <INDENT> m = int ( input ( ) ) <NEWLINE> <COMMENT> <NL> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for j in a : <NEWLINE> <COMMENT> <NL> <INDENT> d [ a [ j ] - 1 ] = 1 <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if d [ i ] == 0 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N , K = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> flag = [ for 1 in range ( N ) ] <NEWLINE> for i in range ( K ) : <NEWLINE> <INDENT> input ( ) <NEWLINE> for j in map ( int , input ( ) . split ( <STRING> ) ) : <NEWLINE> <INDENT> flag [ j - 1 ] = 0 <NEWLINE> <DEDENT> <DEDENT> sum ( flag ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> lis = [ ] <NEWLINE> for i in range ( k * 2 ) : <NEWLINE> <INDENT> lis . append ( input ( ) . split ( ) ) <NEWLINE> <DEDENT> lis2 = [ ] <NEWLINE> j = 1 <NEWLINE> while j < k * 2 : <NEWLINE> <INDENT> for k in lis [ j ] : <NEWLINE> <INDENT> lis2 . append ( k ) <NEWLINE> <DEDENT> j += 2 <NEWLINE> <DEDENT> lis2 = set ( lis2 ) <NEWLINE> print ( n - len ( lis2 ) ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> s = [ ] <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> d = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) ) ) <NEWLINE> s += a <NEWLINE> <DEDENT> print ( n - len ( set ( s ) ) ) <NEWLINE>
n , k = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> h = [ range ( 1 , n + 1 ) ] <NEWLINE> a = [ ] <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> d = int ( input ( ) ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a . append ( * b ) <NEWLINE> <DEDENT> c = set ( a ) <NEWLINE> ans = n - len ( c ) <NEWLINE> print ( ans ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> check = [ 0 ] * N <NEWLINE> <NL> for i in range ( K ) : <NEWLINE> <INDENT> d_i = int ( input ( ) ) <NEWLINE> A_i = map ( int , input ( ) . split ( ) ) <NEWLINE> for j in A_i : <NEWLINE> <INDENT> check [ j ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( sum ( 1 for x in check if x == 0 ) ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> P = [ 0 for i in range ( N ) ] <NEWLINE> for i in range ( K ) : <NEWLINE> <INDENT> a = int ( input ( ) ) <NEWLINE> b = list ( map ( int , ( input ( ) . split ( ) ) ) <NEWLINE> for j in range ( a ) : <NEWLINE> <INDENT> P [ b [ j ] - 1 ] = 1 <NEWLINE> <DEDENT> <DEDENT> m = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if P [ i ] == 0 : <NEWLINE> <INDENT> m += 1 <NEWLINE> <DEDENT> <DEDENT> print ( m ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> A_list = [ ] <NEWLINE> nuske = np . zeros ( n ) <NEWLINE> import numpy as np <NEWLINE> for _ in range ( k ) : <NEWLINE> <INDENT> d = input ( ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i in a : <NEWLINE> <INDENT> nuske [ i - 1 ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> p = 0 <NEWLINE> <NL> for i in range ( len ( nuske ) ) : <NEWLINE> <INDENT> if nuske [ i ] == 0 : <NEWLINE> <INDENT> p += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( p ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> list = [ ] <NEWLINE> for _ in range ( K ) : <NEWLINE> <INDENT> d = int ( input ( ) ) <NEWLINE> S = input ( ) . split ( ) <NEWLINE> list . extend ( S ) <NEWLINE> <DEDENT> num = collections . Counter ( list ) <NEWLINE> print ( N - num ) <NEWLINE> <NL>
n , k = ( int ( i ) for i in input ( ) . split ( ) ) <NEWLINE> l = [ i for i in range ( 1 , n + 1 ) ] <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> d = input ( ) <NEWLINE> for i in input ( ) . split ( ) : <NEWLINE> <INDENT> l [ i ] = 0 <NEWLINE> <DEDENT> <DEDENT> c = 0 <NEWLINE> for i in l : <NEWLINE> <INDENT> if ( i > 0 ) : <NEWLINE> <INDENT> c += 1 <NEWLINE> <DEDENT> <DEDENT> print ( c ) <NEWLINE>
N , K = map ( int , input ( ) ) <NEWLINE> B = [ ] <NEWLINE> for i in range ( K ) : <NEWLINE> <INDENT> D = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for j in A : <NEWLINE> <INDENT> B . append ( j ) <NEWLINE> <DEDENT> <DEDENT> print ( N - len ( set ( B ) ) ) <NEWLINE>
[ n , k ] = map ( int , input ( ) . split ( ) ) <NEWLINE> SET = set ( ) <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> d = int ( input ( ) ) <NEWLINE> <INDENT> tmp = set ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> SET = ( SET | tmp ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( n - int ( len ( SET ) ) ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> l = [ False for _ in range ( N ) ] <NEWLINE> for i in range ( K ) : <NEWLINE> <INDENT> d = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for j in range ( N ) : <NEWLINE> <INDENT> if l [ j ] == A [ j ] : <NEWLINE> <INDENT> l [ j ] = True <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( list . count ( False ) ) <NEWLINE>
n , k = map ( int , imput ( ) . split ( ) ) <NEWLINE> ans = [ 1 ] * n <NEWLINE> <NL> for i in range ( k ) : <NEWLINE> <INDENT> d = int ( input ( ) ) <NEWLINE> for j in list ( map ( int , input ( ) . split ( ) ) ) : <NEWLINE> <INDENT> ans [ j - 1 ] = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans . count ( 1 ) ) <NEWLINE>
import collections <NEWLINE> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> while K > 0 : <NEWLINE> <INDENT> K = K - 1 <NEWLINE> d = int ( input ( ) ) <NEWLINE> a . append ( map ( str , input ( ) . split ( ) ) ) <NEWLINE> <DEDENT> e = collections . Counter ( a ) <NEWLINE> p = N - len ( e ) <NEWLINE> print ( p ) <NEWLINE>
import itertools ^ M <NEWLINE> N , K = list ( map ( int , input ( ) . split ( <STRING> ) ) ) ^ M <NEWLINE> A = list ( itertools . chain . from_iterable ( [ input ( ) . split ( <STRING> ) for i in range ( K ) if input ( ) . split ( <STRING> ) ] ) ) ^ M <NEWLINE> A = list ( map ( int , A ) ) <NEWLINE> none = [ a for a in range ( 1 , K + 1 ) if a not in A ] <NEWLINE> print ( len ( none ) ) <NEWLINE>
<STRING> <NEWLINE> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> input_map = { } <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> d = int ( input ( ) ) <NEWLINE> list = list ( input ( ) . split ( ) ) <NEWLINE> input_map . setdefault ( d , list ) <NEWLINE> <NL> <DEDENT> cnt = 0 <NEWLINE> for key , value in input_map . items ( ) : <NEWLINE> <INDENT> if len ( value ) >= key : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
init = input ( ) . split ( ) <NEWLINE> num = init [ 0 ] <NEWLINE> snacks = init [ 1 ] <NEWLINE> ceck = [ ] <NEWLINE> for i in range ( snacks ) : <NEWLINE> <INDENT> sNum = input ( ) <NEWLINE> if sNum > 1 : <NEWLINE> <INDENT> whos = input ( ) . split ( ) <NEWLINE> for j in range ( sNum ) : <NEWLINE> <INDENT> check . append ( ) = whos [ j ] <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> who = input ( ) <NEWLINE> check . append ( ) = who <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( num ) : <NEWLINE> <INDENT> if not str ( num [ i ] ) in check : <NEWLINE> <INDENT> print ( num ) <NEWLINE> <NL> <NL> <NL> <DEDENT> <DEDENT>
n , k = map ( int , input ( ) , split ( ) ) <NEWLINE> a = [ 0 for i in range ( n ) ] <NEWLINE> <NL> for i in range k : <NEWLINE> <INDENT> d = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) , split ( ) ) ) <NEWLINE> <INDENT> for j in A : <NEWLINE> <INDENT> a [ j - 1 ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( a . count ( 0 ) ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> snukes = [ 0 ] * n <NEWLINE> for _ in range ( k ) : <NEWLINE> <INDENT> d = int ( input ( ) ) <NEWLINE> a = map ( int , input ( ) . split ( ) ) <NEWLINE> for i in a : <NEWLINE> <INDENT> snukes [ i ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( snukes . count ( 0 ) ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> d = [ ] <NEWLINE> a = [ ] <NEWLINE> for i in range ( K ) : <NEWLINE> <INDENT> d . append ( int ( input ( ) ) ) <NEWLINE> a . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> <DEDENT> aa = [ 0 ] * N <NEWLINE> counts = 0 <NEWLINE> <NL> for k in K : <NEWLINE> <INDENT> for j in a [ k ] : <NEWLINE> <INDENT> aa [ j - 1 ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> for x in range ( N + 1 ) : <NEWLINE> <INDENT> if aa [ x - 1 ] == 0 : <NEWLINE> <INDENT> counts += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( counts ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> P = [ 0 for i in range ( N ) ] <NEWLINE> for i in range ( K ) : <NEWLINE> <INDENT> a = int ( input ( ) ) <NEWLINE> b = list ( input ( ) . split ( ) ) <NEWLINE> for j in range ( a ) : <NEWLINE> <INDENT> P [ b [ j ] - 1 ] = 1 <NEWLINE> <DEDENT> <DEDENT> m = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if P [ i ] == 0 : <NEWLINE> <INDENT> m += 1 <NEWLINE> <DEDENT> <DEDENT> print ( m ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> p = [ 1 ] * a <NEWLINE> <NL> while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> input ( ) <NEWLINE> <DEDENT> except EOFError : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> c = input ( ) . split ( ) <NEWLINE> for d in c : <NEWLINE> <INDENT> p [ int ( d ) ] = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( sum ( p ) ) <NEWLINE>
import numpy as np <NEWLINE> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> N_lis = np . zeros ( N ) <NEWLINE> for i in range ( K ) : <NEWLINE> <INDENT> d = int ( input ( ) ) <NEWLINE> sweet = np . array ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <COMMENT> <NL> sweet -= 1 <NEWLINE> for j in sweet : <NEWLINE> <INDENT> N_lis [ j ] += 1 <NEWLINE> <DEDENT> <DEDENT> print ( N_lis ) <NEWLINE> no_sweet = N_lis == 0 <NEWLINE> print ( no_sweet ) <NEWLINE> print ( no_sweet . sum ( ) ) ) <NEWLINE>
N , K = input ( ) . split ( ) <NEWLINE> d = input ( ) <NEWLINE> <NL> print ( N - d ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> output = [ ] <NEWLINE> <NL> for i in range ( k ) : <NEWLINE> <INDENT> d = int ( input ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> output . append ( l ) <NEWLINE> <NL> <DEDENT> print ( n - len ( set ( output ) ) ) <NEWLINE>
<COMMENT> <NL> <NL> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> d = [ 0 ] * K <NEWLINE> <NL> C = [ 0 ] * N <NEWLINE> for i in range ( K ) : <NEWLINE> <INDENT> d [ i ] = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for j in range ( N ) : <NEWLINE> <INDENT> for k in range ( d [ i ] ) : <NEWLINE> <INDENT> if A [ k ] == j + 1 : <NEWLINE> <INDENT> C [ j ] = 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> count = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if C [ i ] == 0 <NEWLINE> count + 1 <NEWLINE> <NL> <NL> <DEDENT> print ( <STRING> . format ( count ) ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> nlist = [ i for i in range ( 1 , N + 1 ) ] <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> d = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> nlist = [ a for a in A if a not in nlist ] <NEWLINE> <DEDENT> print ( len ( nlist ) ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> snuke = [ 0 ] * N <NEWLINE> <NL> for i in range ( K ) : <NEWLINE> <INDENT> d = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for j in range ( d ) : <NEWLINE> <INDENT> snuke [ a [ j ] ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( snuke . count ( 0 ) ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ ] <NEWLINE> from collections import defaultdict as dd <NEWLINE> dc = dd ( lambda : 0 ) <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> d = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i in a : <NEWLINE> <INDENT> dc [ i ] += 1 <NEWLINE> <DEDENT> <DEDENT> cnt = 0 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if d [ i ] == 0 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
n , k = int ( input ( ) ) <NEWLINE> l_n = [ 0 ] * n <NEWLINE> for i in range ( 0 , k ) : <NEWLINE> <INDENT> d = int ( input ( ) ) <NEWLINE> a = int ( input ( ) ) <NEWLINE> for l in a : <NEWLINE> <INDENT> l_n [ l - 1 ] = 1 <NEWLINE> <DEDENT> <DEDENT> print ( l_n . count ( 0 ) ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> number = 0 <NEWLINE> data = [ ] <NEWLINE> nolist = list ( range ( 1 , K + 1 ) ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> number = int ( input ( ) ) <NEWLINE> for j in range ( number ) : <NEWLINE> <INDENT> data = input ( ) . split ( ) <NEWLINE> nolist [ int ( data [ j ] ) - 1 ] = 0 <NEWLINE> <DEDENT> <DEDENT> try : <NEWLINE> <INDENT> for i in range ( N ) : <NEWLINE> <INDENT> nolist . remove ( 0 ) <NEWLINE> <DEDENT> <DEDENT> except : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> print ( len ( nolist ) ) <NEWLINE>
from sys import stdin <NEWLINE> import re <NEWLINE> import bisect <NEWLINE> import numpy as np <NEWLINE> <NL> n , k = map ( int ( ) , stdin . readline ( ) . rstrip ( ) . split ( ) ) <NEWLINE> data = np . zeros ( ( n , k ) , dtype = bool ) <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> _ = stdin . readline ( ) <NEWLINE> line = map ( int ( ) , stdin . readline ( ) . rstrip ( ) . split ( ) ) <NEWLINE> for j in line : <NEWLINE> <INDENT> data [ i ] [ j ] = True <NEWLINE> <NL> <DEDENT> <DEDENT> count = int ( 0 ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if ( data . T [ n ] ) . all ( ) == True : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
<COMMENT> <NL> <NL> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> sunuke = [ 0 ] * N <NEWLINE> for i in k : <NEWLINE> <INDENT> d = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for ai in a : <NEWLINE> <INDENT> sunuke [ ai - 1 ] += 1 <NEWLINE> <DEDENT> <DEDENT> print ( sunuke . count ( 0 ) ) <NEWLINE> <NL>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> c = [ 0 ] * k <NEWLINE> <NL> for i in range ( k ) : <NEWLINE> <INDENT> d = int ( input ( ) ) <NEWLINE> for j in range ( d ) : <NEWLINE> <INDENT> d = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for k in range ( len ( d ) ) : <NEWLINE> <INDENT> c [ d [ k ] ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( c . count ( 0 ) ) <NEWLINE>
<NL> d = [ ] <NEWLINE> A = [ ] <NEWLINE> for i in range ( K ) : <NEWLINE> <INDENT> _d = int ( input ( ) ) <NEWLINE> d . append ( _d ) <NEWLINE> _a = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> A . append ( _a ) <NEWLINE> <NL> <DEDENT> res = [ ] <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> res . append ( i ) <NEWLINE> <NL> <DEDENT> for a in A : <NEWLINE> <INDENT> for _a in a : <NEWLINE> <INDENT> if _a in res : <NEWLINE> <INDENT> res . remove ( _a ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( len ( res ) ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> S = [ 1 ] * N <NEWLINE> <NL> for i in range ( K ) : <NEWLINE> <INDENT> d = int ( input ( ) ) <NEWLINE> t = map ( int , input ( ) . split ( ) ) <NEWLINE> for i in range ( t ) : <NEWLINE> <INDENT> S [ i - 1 ] = 0 <NEWLINE> <DEDENT> <DEDENT> print ( sum ( S ) ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> c = int ( input ( ) ) <NEWLINE> d = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> e = [ input ( ) for _ in range ( b ) ] <NEWLINE> f = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> print ( a - c ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> a = set ( [ ] ) <NEWLINE> for i in range ( K ) : <NEWLINE> <INDENT> d = int ( input ( ) ) <NEWLINE> for i in range ( d ) : <NEWLINE> <INDENT> L = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for x in L : <NEWLINE> <INDENT> a . add ( x ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( N - len ( a ) ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> count = [ 0 ] * ( n + 1 ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> d = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( len ( a ) ) : <NEWLINE> <INDENT> count [ i ] += 1 <NEWLINE> <DEDENT> <DEDENT> print ( count . count ( 0 ) ) <NEWLINE>
S = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> counter = 0 <NEWLINE> nuske = [ ] <NEWLINE> <NL> for k in range ( S [ 0 ] ) : <NEWLINE> <INDENT> nuske . append ( int ( 0 ) ) <NEWLINE> <NL> <DEDENT> for i in range ( S [ 1 ] ) : <NEWLINE> <INDENT> roop = int ( input ( ) ) <NEWLINE> for j in range ( roop ) : <NEWLINE> <INDENT> if roop == 1 : <NEWLINE> <INDENT> temp = int ( input ( ) ) <NEWLINE> nuske [ temp - 1 ] = nuske [ temp - 1 ] + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> temp = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for l in temp : <NEWLINE> <INDENT> nuske [ l - 1 ] = nuske [ l - 1 ] + 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for y in nuske : <NEWLINE> <INDENT> if y == 0 : <NEWLINE> <INDENT> counter += 1 <NEWLINE> <DEDENT> <DEDENT> print ( counter ) <NEWLINE>
sunuke , var = map ( int , input ( ) . split ( ) ) <NEWLINE> loser = [ 1 ] * sunuke <NEWLINE> for i in range ( var ) : <NEWLINE> <INDENT> d = int ( input ( ) ) <NEWLINE> buy = map ( int ( input ( ) . split ( ) ) <NEWLINE> for t in buy : <NEWLINE> <INDENT> winer [ t - 1 ] = 0 <NEWLINE> <DEDENT> <DEDENT> print ( sum ( loser ) ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> withSnacks = [ ] <NEWLINE> for x in range ( K ) : <NEWLINE> <INDENT> nUmsnakes = int ( input ) <NEWLINE> snakes = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> withSnacks . extend ( snakes ) <NEWLINE> <DEDENT> withSnacks = list ( set ( withSnacks ) ) <NEWLINE> count = 0 <NEWLINE> for x in range ( 1 , x + 1 ) : <NEWLINE> <INDENT> if not x in withSnacks : <NEWLINE> <INDENT> count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( count ) <NEWLINE> <NL>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> L = [ 0 for i in range ( N + 1 ) ] <NEWLINE> <NL> for i in range ( K ) : <NEWLINE> <INDENT> d = int ( input ( ) ) <NEWLINE> for j in range ( d ) : <NEWLINE> <INDENT> s = int ( input ( ) ) <NEWLINE> L [ s ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> if L [ i ] == 0 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> ans = 0 <NEWLINE> n , k = map ( int , input ( . split ( ) ) ) <NEWLINE> l = [ 0 ] * n <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> d = int ( input ( ) ) <NEWLINE> s = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for j in s : <NEWLINE> <INDENT> l [ j - 1 ] += 1 <NEWLINE> <DEDENT> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> if l [ i ] == 0 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> P = [ 0 for i in range ( N ) ] <NEWLINE> for i in range ( K ) : <NEWLINE> <INDENT> a = int ( input ( ) ) <NEWLINE> b = list ( int , input ( ) . split ( ) ) <NEWLINE> for j in range ( a ) : <NEWLINE> <INDENT> P [ b [ j ] - 1 ] = 1 <NEWLINE> <DEDENT> <DEDENT> m = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if P [ i ] == 0 : <NEWLINE> <INDENT> m += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( m ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = [ None ] * n <NEWLINE> while k > 0 : <NEWLINE> <INDENT> d = input ( ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <COMMENT> <NL> for i in a : <NEWLINE> <INDENT> ans [ i - 1 ] = d <NEWLINE> <DEDENT> k -= 1 <NEWLINE> <DEDENT> count = 0 <NEWLINE> for item in ans : <NEWLINE> <INDENT> if item == None : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> print ( count ) a <NEWLINE>
N , K = ( int ( x ) for x in input ( ) . split ( ) ) <NEWLINE> lists = [ 0 ] * N <NEWLINE> while 1 : <NEWLINE> <INDENT> tmp = int ( input ( ) ) <NEWLINE> if not tmp : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> have_count = ( int ( x ) for x in input ( ) . split ( ) ) <NEWLINE> for i in have_count : <NEWLINE> <INDENT> lists [ i - 1 ] = 1 <NEWLINE> <DEDENT> <DEDENT> print ( lists . count ( 0 ) ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> snukes = [ 0 ] * N <NEWLINE> for i in range ( K ) : <NEWLINE> <INDENT> d_i = int ( input ( ) ) <COMMENT> <NEWLINE> a_i = map ( int , input ( ) . split ( ) ) <NEWLINE> for a in a_i : <NEWLINE> <INDENT> snukes [ a ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> counter = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if snukes [ i ] == 0 : <NEWLINE> <INDENT> counter += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( counter ) <NEWLINE>
n , k = list ( map ( int , input ( <STRING> ) . split ( ) ) ) <NEWLINE> <NL> sunuke = [ 0 ] * n <NEWLINE> <NL> for i in range ( K ) : <NEWLINE> <INDENT> d = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for j in a : <NEWLINE> <INDENT> sunuke [ j - 1 ] = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( sum ( sunuke ) ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> have_snack = [ 0 for i in range ( N ) ] <NEWLINE> <NL> for k in range ( K ) : <NEWLINE> <INDENT> hito_len = int ( input ( ) ) <NEWLINE> have_hito = map ( int , input ( ) . split ( ) ) <NEWLINE> for hh in range ( have_hito ) : <NEWLINE> <INDENT> have_snack [ hh - 1 ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( have_snack . count ( 0 ) ) <NEWLINE>
import sys <NEWLINE> import itertools <NEWLINE> import heapq <NEWLINE> import numpy as np <NEWLINE> stdin = sys . stdin <NEWLINE> ns = lambda : stdin . readline ( ) . rstrip ( ) <NEWLINE> ni = lambda : int ( stdin . readline ( ) . rstrip ( ) ) <NEWLINE> nm = lambda : map ( int , stdin . readline ( ) . split ( ) ) <NEWLINE> nl = lambda : list ( map ( int , stdin . readline ( ) . split ( ) ) ) <NEWLINE> <NL> N , K = nm ( ) <NEWLINE> A = [ 0 ] * K <NEWLINE> for i in range ( K ) : <NEWLINE> <INDENT> d = int ( input ( ) ) <NEWLINE> tmp = nl ( ) <NEWLINE> for j in range ( d ) : <NEWLINE> <INDENT> A [ tmp [ j ] - 1 ] += 1 <NEWLINE> <DEDENT> <DEDENT> c = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if ( A [ i ] == 0 ) : <NEWLINE> <INDENT> c += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( c ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> for i in range ( K ) : <NEWLINE> <INDENT> input ( ) <NEWLINE> a |= set ( list ( map ( int , input . split ( ) ) ) ) <NEWLINE> <DEDENT> print ( n - len ( a ) ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> mem = set ( ) <NEWLINE> for _ in range ( K ) : <NEWLINE> <INDENT> _ = input ( ) <NEWLINE> mem = mem | { input ( ) . split ( ) } <NEWLINE> <NL> <DEDENT> mem_count = len ( mem ) <NEWLINE> print ( N - mem_count ) <NEWLINE>
n , k = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> d = [ ] <NEWLINE> for _ in range ( k ) : <NEWLINE> <INDENT> x = int ( input ( ) ) <NEWLINE> y = int ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i in y : <NEWLINE> <INDENT> d . append ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> d = set ( d ) <NEWLINE> d = list ( d ) <NEWLINE> print ( n - len ( d ) ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> d = int ( input ( ) ) <NEWLINE> <NL> num = [ int ( input ( ) ) for _ in range ( n ) ] <NEWLINE> <NL> print ( n - d ) <NEWLINE>
import numpy as np <NEWLINE> <NL> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ ] <NEWLINE> for i in range ( K ) : <NEWLINE> <INDENT> d = int ( input ( ) ) <NEWLINE> temp = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A = A + temp <NEWLINE> <DEDENT> hito = np . ones ( N ) <NEWLINE> for i in range ( len ( A ) ) : <NEWLINE> <INDENT> hito [ A [ i ] ] = 0 <NEWLINE> <DEDENT> print ( int ( np . sum ( hito ) ) ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> ANSlist = [ 1 ] * ( N ) <NEWLINE> <NL> for i in range ( K ) : <NEWLINE> <INDENT> I = input ( ) <COMMENT> <NEWLINE> S = list ( input ( ) ) <NEWLINE> for j in range ( len ( S ) ) : <NEWLINE> <INDENT> if S [ j ] != <STRING> : <NEWLINE> <INDENT> ANSlist [ int ( S [ j ] ) - 1 ] = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> ANS = 0 <NEWLINE> <NL> for i in range ( len ( ANSlist [ i ] ) ) : <NEWLINE> <INDENT> if ANSlist [ i ] != 0 : <NEWLINE> <INDENT> ANS += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ANS ) <NEWLINE>
import sys <NEWLINE> import os <NEWLINE> f = open ( <STRING> , <STRING> ) <NEWLINE> sys . stdin = f <NEWLINE> <NL> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> mans = [ 0 ] * n <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> d = input ( ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for aa in a : <NEWLINE> <INDENT> mans [ aa - 1 ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> cnt = 0 <NEWLINE> for m in range ( len ( mans ) ) : <NEWLINE> <INDENT> if mans [ m ] == 0 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ 1 ] * n <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> tmp = map ( int , input ( ) . split ( ) ) <NEWLINE> for j in tmp : <NEWLINE> <INDENT> a [ j - 1 ] = 0 <NEWLINE> <DEDENT> <DEDENT> print ( sum ( a [ j ] ) ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> state = [ 1 for i in range ( N ) ] <NEWLINE> for i in range ( K ) : <NEWLINE> <INDENT> d = int ( input ( ) ) <NEWLINE> for j in range ( d ) : <NEWLINE> <INDENT> x = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for k in x : <NEWLINE> <INDENT> state [ k - 1 ] = 0 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( sum ( state ) ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> for i in range ( k ) : <NEWLINE> <INDENT> d [ i ] = int ( input ( ) ) <NEWLINE> a [ i ] = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> if all ( ( x != i for x in a ) ) : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> d = [ ] <NEWLINE> A = [ ] <NEWLINE> <NL> for i in range ( K ) : <NEWLINE> <INDENT> d . append ( int ( input ( ) ) ) <NEWLINE> A . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> <DEDENT> okashi = [ 0 ] * N <NEWLINE> <NL> for l in range ( N ) : <NEWLINE> <INDENT> for i in A [ l ] : <NEWLINE> <INDENT> okashi [ i - 1 ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> count = 0 <NEWLINE> for i in okashi : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> list_n = [ ] <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> list_n . append ( i ) <NEWLINE> <NL> <DEDENT> t = [ ] <NEWLINE> for i in range ( K ) : <NEWLINE> <INDENT> d = int ( input ( ) ) <NEWLINE> s = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> t += s <NEWLINE> <NL> <DEDENT> s = set ( t ) <NEWLINE> s . sort ( ) <NEWLINE> <NL> cnt = 0 <NEWLINE> for i in list_n : <NEWLINE> <INDENT> if i not in s : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> kids = list ( ) <NEWLINE> sum = 0 <NEWLINE> <NL> for i in k - 1 : <NEWLINE> <INDENT> dustbox = input ( ) <NEWLINE> kids += list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <DEDENT> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if i not in kids : <NEWLINE> <INDENT> sum += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( sum ) <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE>
n , k = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> s = set ( ) <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> s . append ( int ( input ( ) ) ) <NEWLINE> j = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <DEDENT> print ( n - len ( s ) ) <NEWLINE>
nk = list ( input ( ) . split ( ) ) <NEWLINE> n = nk [ 0 ] <NEWLINE> k = nk [ 1 ] <NEWLINE> a = [ ] <NEWLINE> c = 0 <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> d = int ( input ( ) ) <NEWLINE> b = list ( input ( ) . split ( ) ) <NEWLINE> a . extend ( b ) <NEWLINE> <DEDENT> for j in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if j not in a : <NEWLINE> <INDENT> c = c + 1 <NEWLINE> <DEDENT> <DEDENT> print ( c ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> L = [ 1 for i in range ( N ) ] <NEWLINE> for k in range ( K ) : <NEWLINE> <INDENT> d = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . spit ( ) ) ) <NEWLINE> for i in range ( d ) : <NEWLINE> <INDENT> L [ A [ i ] - 1 ] = 0 <NEWLINE> <DEDENT> <DEDENT> print ( sum ( L ) ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> count = 0 <NEWLINE> ans = [ ] <NEWLINE> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> for _ in range ( K ) : <NEWLINE> <INDENT> d = int ( input ( ) ) <NEWLINE> a = [ input ( ) for _ in range ( d ) ] <NEWLINE> ans . append ( a ) <NEWLINE> <DEDENT> for _ in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> if _ not in ans : <NEWLINE> <INDENT> count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( count ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> list_A = [ 1 ] * N <NEWLINE> for i in range ( K ) : <NEWLINE> <INDENT> d = int ( input ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for J range ( d ) : <NEWLINE> <INDENT> if list_A [ l [ j ] - 1 ] == 1 : <NEWLINE> <INDENT> list_A [ l [ j ] - 1 ] = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( list_A . count ( 1 ) ) <NEWLINE> <NL>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> D = [ ] <NEWLINE> A = set ( ) <NEWLINE> for i in range ( K ) : <NEWLINE> <INDENT> D . append ( input ( ) ) <NEWLINE> A . add ( int ( input ( ) ) ) <NEWLINE> <DEDENT> S = len ( A ) <NEWLINE> print ( N - S ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> n = list ( map ( str , range ( 1 , n + 1 ) ) ) <NEWLINE> <NL> for i in range ( k ) : <NEWLINE> <INDENT> _ = input ( ) <NEWLINE> a = input ( ) . split ( ) <NEWLINE> for ai in a : <NEWLINE> <INDENT> n . remove ( ai ) <NEWLINE> <DEDENT> <DEDENT> print ( len ( n ) ) <NEWLINE>
<COMMENT> <NL> <NL> from typing import Iterable <NEWLINE> <NL> <NL> def main ( ) -> None : <NEWLINE> <INDENT> N , K = rmi ( ) <NEWLINE> D , A = [ ] , [ ] <NEWLINE> for n in range ( N ) : <NEWLINE> <INDENT> d = ri ( ) <NEWLINE> D . append ( d ) <NEWLINE> A . append ( rmi ( ) ) <NEWLINE> <DEDENT> target = [ False ] * N <NEWLINE> for k in range ( K ) : <NEWLINE> <INDENT> for a in A [ k ] : <NEWLINE> <INDENT> target [ a ] = True <NEWLINE> <DEDENT> <DEDENT> w ( target . count ( False ) ) <NEWLINE> <NL> <NL> <DEDENT> def r ( ) -> str : <NEWLINE> <INDENT> return input ( ) . strip ( ) <NEWLINE> <NL> <NL> <DEDENT> def ri ( ) -> int : <NEWLINE> <INDENT> return int ( input ( ) ) <NEWLINE> <NL> <NL> <DEDENT> def rmi ( delim : str = <STRING> ) -> int : <NEWLINE> <INDENT> return tuple ( map ( int , input ( ) . split ( delim ) ) ) <NEWLINE> <NL> <NL> <DEDENT> def w ( data ) -> None : <NEWLINE> <INDENT> print ( data ) <NEWLINE> <NL> <NL> <DEDENT> def wm ( data : Iterable ) -> None : <NEWLINE> <INDENT> print ( <STRING> . join ( data ) ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> ans_li = [ 0 for x in range ( a ) ] <NEWLINE> <NL> for i in range ( b ) : <NEWLINE> <INDENT> d = int ( input ( ) ) <NEWLINE> for j in range ( d ) : <NEWLINE> <INDENT> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for ll in l : <NEWLINE> <INDENT> ans_li [ ll - 1 ] += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans_li . count ( 0 ) ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ [ 0 for j in range ( 100 ) ] for i in range ( 100 ) ] <NEWLINE> B = [ 0 for j in range ( N ) ] <NEWLINE> S = 0 <NEWLINE> for i in range ( K ) : <NEWLINE> <INDENT> d = int ( input ( ) ) <NEWLINE> A [ i ] = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <DEDENT> for i in range ( 100 ) : <NEWLINE> <INDENT> for j in range ( 100 ) : <NEWLINE> <INDENT> for k in range ( N ) : <NEWLINE> <INDENT> if A [ i ] [ j ] == k + 1 : <NEWLINE> <INDENT> B [ k ] = 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> if B [ i ] != 1 : <NEWLINE> <INDENT> S += 1 <NEWLINE> <DEDENT> <DEDENT> print ( S ) <NEWLINE>
[ N , K ] = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> all_A = [ ] <NEWLINE> A_ = [ ] <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> all_A . append ( i ) <NEWLINE> <DEDENT> for j in range ( K ) : <NEWLINE> <INDENT> d = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A_ = A_ . append ( A ) <NEWLINE> <DEDENT> all_A = set ( all_A ) ^ set ( A_ ) <NEWLINE> print ( len ( all_A ) ) <NEWLINE>
N , K = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> trickSum = 0 <NEWLINE> result = list ( ) <NEWLINE> while True : <NEWLINE> <INDENT> d = input ( ) <NEWLINE> if d == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> result = result + ( list ( map ( int , input ( ) . split ( <STRING> ) ) ) ) <NEWLINE> <DEDENT> print ( N - len ( set ( result ) ) ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> Aall = set ( range ( 1 , N ) ) <NEWLINE> Ak = [ ] <NEWLINE> for i in range ( N * 2 ) : <NEWLINE> <COMMENT> <NL> <INDENT> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if i % 2 == 1 : <NEWLINE> <INDENT> Ak . extend ( ( A ) ) <NEWLINE> <DEDENT> <DEDENT> print ( len ( Aall - set ( Ak ) ) ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> tmp = [ 0 ] * N <NEWLINE> <NL> for i in range ( K ) : <NEWLINE> <INDENT> input ( ) <NEWLINE> for j in map ( int , input ( ) . split ( ) ) : <NEWLINE> tmp [ j - 1 ] |= 1 <NEWLINE> <DEDENT> print ( sum ( tmp ) ) <NEWLINE>
total , okasi = map ( int , input ( ) . split ( ) ) <NEWLINE> sunuke = [ ] <NEWLINE> for i in range ( okasi ) : <NEWLINE> <INDENT> d = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for a in A : <NEWLINE> <INDENT> sunuke . append ( input ( ) ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> ans = total - len ( set ( sunuke ) ) <NEWLINE> <NL> print ( ans ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> hashmap = dict ( ) <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> d = int ( input ( ) ) <NEWLINE> for j in range ( d ) : <NEWLINE> <INDENT> key = int ( input ( ) ) <NEWLINE> hashmap [ key ] = d <NEWLINE> <DEDENT> <DEDENT> count = 0 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if hashmap . get ( i ) == None : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
<NL> import sys <NEWLINE> import itertools <NEWLINE> <NL> <NL> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> nums = [ ] <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> _ = int ( input ( ) ) <NEWLINE> nums . extend ( [ int ( x . strip ( ) ) for x in input ( ) . split ( <STRING> ) ] ) <NEWLINE> <NL> <DEDENT> print ( N - len ( set ( nums ) ) ) <NEWLINE>
L = [ ] <NEWLINE> <NL> while True : <NEWLINE> <INDENT> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if l : <NEWLINE> <INDENT> L . append ( l ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( L ) <NEWLINE> <NL> N = L [ 0 ] [ 0 ] <NEWLINE> K = L [ 0 ] [ 1 ] <NEWLINE> <NL> Num = list ( range ( 1 , N + 1 , 1 ) ) <NEWLINE> <NL> new_L = L [ 2 : : 2 ] <NEWLINE> <NL> new_LL = sum ( new_L , [ ] ) <NEWLINE> for n in new_LL : <NEWLINE> <INDENT> if n in Num : <NEWLINE> <INDENT> Num . remove ( n ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( len ( Num ) ) <NEWLINE>
N , K = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> flag = [ 1 for i in range ( N ) ] <NEWLINE> for i in range ( K ) : <NEWLINE> <INDENT> input ( ) <NEWLINE> a = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> for j in a : <NEWLINE> <INDENT> flag [ a - 1 ] = 0 <NEWLINE> <DEDENT> <DEDENT> print ( sum ( flag ) ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> snuke = [ 1 for i in range ( n ) ] <NEWLINE> for _ in range ( k ) : <NEWLINE> <INDENT> d = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i in range ( a ) : <NEWLINE> <INDENT> snuke [ i - 1 ] = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( sum ( snuke ) ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> l = [ 0 ] * n <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> d = int ( input ( ) ) <NEWLINE> h = [ int ( input ( ) ) for i in range ( d ) ] <NEWLINE> for j in d : <NEWLINE> <INDENT> l [ j - 1 ] = 1 <NEWLINE> <DEDENT> <DEDENT> print ( l . count ( 0 ) ) <NEWLINE>
whatMan = [ ] <NEWLINE> <NL> N , K = input ( ) . split ( ) <NEWLINE> for i in range ( int ( K ) ) : <NEWLINE> <INDENT> whatMan . extend ( input ( ) . split ( ) ) <NEWLINE> <DEDENT> print ( int ( N ) - set ( whatMan ) . count ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> d = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> dk = [ int ( input ( ) ) for ia in range ( K ) ] <NEWLINE> Ak = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> print ( N - d ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> list1 , list2 , k = [ ] , [ ] , k * 2 <NEWLINE> for x in range ( k ) : <NEWLINE> <INDENT> list1 . append ( input ( ) . split ( ) ) <NEWLINE> <DEDENT> while i < k : <NEWLINE> <INDENT> for j in list1 [ i ] : <NEWLINE> <INDENT> list2 . append ( j ) <NEWLINE> <DEDENT> i += 2 <NEWLINE> <DEDENT> print ( n - len ( set ( list2 ) ) ) <NEWLINE>
N , K = input ( ) . strip ( ) . split ( <STRING> ) <NEWLINE> N = int ( N ) <NEWLINE> K = int ( K ) <NEWLINE> checkbox = [ False for i in range ( N ) ] <NEWLINE> for k in range ( K ) : <NEWLINE> <INDENT> input ( ) <NEWLINE> seq = input ( ) . strip ( ) . split ( <STRING> ) <NEWLINE> for j in seq : <NEWLINE> <INDENT> checkbox [ i ] = True <NEWLINE> <DEDENT> <DEDENT> print ( checkbox . count ( False ) ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> for i in range ( K ) : <NEWLINE> <INDENT> D = list ( int ( input ( ) ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <DEDENT> print ( N - len ( set ( A ) ) ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> L = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> d = int ( input ( ) ) <NEWLINE> if d == 1 : <NEWLINE> <INDENT> A = list ( int ( input ( ) ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <DEDENT> for j in range ( d ) : <NEWLINE> <INDENT> L . append ( A [ j ] ) <NEWLINE> <DEDENT> <DEDENT> print ( N - len ( set ( L ) ) ) <NEWLINE>
N , K = input ( ) . split ( ) <NEWLINE> d = [ ] <NEWLINE> A = [ ] <NEWLINE> <NL> for _ in K : <NEWLINE> <INDENT> d . append ( input ( ) ) <NEWLINE> num = d [ - 1 ] <NEWLINE> for i in num : <NEWLINE> <INDENT> A . append ( input ( ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> for j in max ( d ) + 1 : <NEWLINE> <INDENT> if j + 1 in A : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( j + 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> di = K * 2 <NEWLINE> l = [ ] <NEWLINE> <NL> for i in range ( di ) : <NEWLINE> <INDENT> l . append ( int ( input ( ) ) ) <NEWLINE> <NL> <DEDENT> l1 = [ ] <NEWLINE> x = 1 <NEWLINE> while x < di : <NEWLINE> <INDENT> for j in l [ x ] : <NEWLINE> <INDENT> l1 . append ( j ) <NEWLINE> <DEDENT> x += 2 <NEWLINE> <DEDENT> l1 = set ( l1 ) <NEWLINE> print ( N - len ( l1 ) ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> sunukes = [ 0 for k in range ( N ) ] <NEWLINE> for k in range ( K ) : <NEWLINE> <INDENT> d = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for a in A : <NEWLINE> <INDENT> sunukes [ a ] += 1 <NEWLINE> <DEDENT> assert len ( A ) == d <NEWLINE> <DEDENT> print ( len ( [ k for k in sunukes if k == 0 ] ) ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> t = [ 0 ] * n <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> d = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for a in range A : <NEWLINE> <INDENT> t [ a - 1 ] += 1 <NEWLINE> <DEDENT> <DEDENT> print ( t . count ( 0 ) ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> D = { } <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> D [ i + 1 ] = 0 <NEWLINE> <DEDENT> for i in range ( K ) : <NEWLINE> <INDENT> d = input ( ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for a in A : <NEWLINE> <INDENT> d [ a ] += 1 <NEWLINE> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if D [ i + 1 ] == 0 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<NL> n , m = map ( int , input ( ) . split ( ) ) <COMMENT> <NEWLINE> list_h = list ( map ( int , input ( ) . split ( ) ) ) <COMMENT> <NEWLINE> <COMMENT> <NL> a = [ ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> ai = list ( map ( int , input ( ) . split ( ) ) ) <COMMENT> <NEWLINE> a . append ( ai ) <NEWLINE> <NL> <DEDENT> booler = [ True ] * n <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a_copy = copy . deepcopy ( a ) <NEWLINE> for j in range ( m ) : <NEWLINE> <INDENT> if i in a_copy [ j ] : <NEWLINE> <INDENT> a_copy [ j ] . remove ( i ) <NEWLINE> <COMMENT> <NL> if list_h [ i ] > list_h [ a_copy [ j ] [ 0 ] - 1 ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> booler [ i ] = False <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( booler . count ( True ) ) <NEWLINE>
( N , M ) = input ( ) . split ( ) <NEWLINE> N = int ( N ) <NEWLINE> M = int ( M ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> y = [ 0 ] * N <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> if h [ A - 1 ] >= h [ B - 1 ] : <NEWLINE> <INDENT> y [ B - 1 ] += 1 <NEWLINE> <DEDENT> if h [ B - 1 ] >= h [ a - 1 ] : <NEWLINE> <INDENT> y [ A - 1 ] += 1 <NEWLINE> <DEDENT> <DEDENT> print ( y . count ( 0 ) ) <NEWLINE>
import copy <NEWLINE> <NL> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> l = [ ] <NEWLINE> for i range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> l . append ( [ a , b ] ) <NEWLINE> <NL> <DEDENT> ll = [ 0 ] * n <NEWLINE> <NL> for j in l : <NEWLINE> <INDENT> if h [ j [ 0 ] - 1 ] > h [ j [ 1 ] - 1 ] : <NEWLINE> <INDENT> ll [ j [ 1 ] - 1 ] += 1 <NEWLINE> <DEDENT> elif h [ j [ 0 ] - 1 ] == h [ j [ 1 ] - 1 ] : <NEWLINE> <INDENT> ll [ j [ 1 ] - 1 ] += 1 <NEWLINE> ll [ j [ 0 ] - 1 ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ll [ j [ 0 ] - 1 ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> ans = 0 <NEWLINE> <NL> for k in ll : <NEWLINE> <INDENT> if k == 0 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += 0 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> H = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A = [ 0 ] * M <NEWLINE> B = [ 0 ] * M <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> A [ i ] , B [ i ] = map ( int , input ( ) . split ( ) ) <NEWLINE> A [ i ] -= 1 <NEWLINE> B [ i ] -= 1 <NEWLINE> <DEDENT> lis = [ ] <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> if H [ A [ i ] ] < H [ B [ i ] ] : <NEWLINE> <INDENT> min . append ( A [ i ] ) <NEWLINE> <DEDENT> if H [ A [ i ] ] == H [ B [ i ] ] : <NEWLINE> <INDENT> min . append ( A [ i ] ) <NEWLINE> min . append ( B [ i ] ) <NEWLINE> <DEDENT> if H [ A [ i ] ] > H [ B [ i ] ] : <NEWLINE> <INDENT> min . append ( B [ i ] ) <NEWLINE> <DEDENT> <DEDENT> print ( len ( set ( lis ) ) ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> h = { } <NEWLINE> for k , v in zip ( range ( 1 , n + 1 ) , [ k for k in map ( int , input ( ) . split ( ) ) ] ) : <NEWLINE> <INDENT> h [ k ] = v <NEWLINE> <NL> <DEDENT> miti = [ ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> temp = [ k for k in map ( int , input ( ) . split ( ) ) ] <NEWLINE> miti . append ( temp ) <NEWLINE> <NL> <DEDENT> x = np . zeros ( n ) <NEWLINE> <NL> for i in range ( m ) : <NEWLINE> <INDENT> if h [ miti [ i ] [ 0 ] ] < h [ miti [ i ] [ 1 ] ] : <NEWLINE> <INDENT> x [ miti [ i ] [ 0 ] - 1 ] = + 1 <NEWLINE> <DEDENT> elif h [ miti [ i ] [ 0 ] ] > h [ miti [ i ] [ 1 ] ] : <NEWLINE> <INDENT> x [ miti [ i ] [ 1 ] - 1 ] = + 1 <NEWLINE> <DEDENT> elif h [ miti [ i ] [ 0 ] ] == h [ miti [ i ] [ 1 ] ] : <NEWLINE> <INDENT> x [ miti [ i ] [ 0 ] - 1 ] = + 1 <NEWLINE> x [ miti [ i ] [ 1 ] - 1 ] = + 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( sum ( x == 0 ) ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> high = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> judge = [ <STRING> for i in range ( n ) ] <NEWLINE> <NL> for i in range ( m ) : <NEWLINE> <INDENT> a , b = [ int ( s ) - 1 for i in input ( ) . split ( ) ] <NEWLINE> <NL> if high [ a ] < high [ b ] : <NEWLINE> <INDENT> judge [ a ] = <STRING> <NEWLINE> <DEDENT> elif high [ a ] > high [ b ] : <NEWLINE> <INDENT> judge [ b ] = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> judge [ a ] = <STRING> <NEWLINE> judge [ b ] = <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> print ( judge . count ( <STRING> ) ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> h = list ( map ( int , inpt ( ) . split ( ) ) ) <NEWLINE> ab = [ [ ] for nn in range ( n ) ] <NEWLINE> for mm in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> ab [ a - 1 ] += b - 1 <NEWLINE> ab [ b - 1 ] += a - 1 <NEWLINE> <DEDENT> cnt = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> hi = 0 <NEWLINE> for ll in ab [ i ] : <NEWLINE> <INDENT> hi = max ( hi , h [ ll ] ) <NEWLINE> <DEDENT> if hi == h [ i ] : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> H = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> rlist = { n : [ ] for n in range ( 1 , N + 1 ) } <NEWLINE> cnt = 0 <NEWLINE> for m in range ( 1. M + 1 ) : <NEWLINE> <INDENT> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> rlist [ A ] . append ( B ) <NEWLINE> rlist [ B ] . append ( A ) <NEWLINE> <NL> <DEDENT> for k , v in rlist . items ( ) : <NEWLINE> <INDENT> if len ( v ) == 0 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in v : <NEWLINE> <INDENT> if H [ k - 1 ] <= H [ i - 1 ] : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> s = [ int ( n ) for n in input ( ) . split ( ) ] <NEWLINE> cs = s <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> a -= 1 , b -= 1 <NEWLINE> if ( s [ a ] < s [ b ] ) : <NEWLINE> <INDENT> cs [ a ] = <STRING> <NEWLINE> <DEDENT> else if ( s [ a ] == s [ b ] ) : <NEWLINE> <INDENT> cs [ a ] = <STRING> <NEWLINE> cs [ b ] = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cs [ b ] = <STRING> <NEWLINE> <DEDENT> <DEDENT> print ( cs . count ( <STRING> ) ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
( n , _ ) , h , * t = [ [ * map ( int , t . split ( ) ) ] for t in open ( 0 ) ] <NEWLINE> p = [ 1 ] * n <NEWLINE> for a , b in t : p [ - a ] &= h [ a ] > h [ b ] ; p [ - b ] &= h [ b ] > h [ a ] <NEWLINE> print ( sum ( p ) ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> heights = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> good = [ True ] * N <NEWLINE> for m in range ( 0 , M ) : <NEWLINE> <INDENT> A , B = [ int ( s ) - 1 for s in input . split ( ) ] <NEWLINE> if heights [ A ] >= heights [ B ] : <NEWLINE> <INDENT> good [ B ] = False <NEWLINE> <DEDENT> elif heights [ A ] <= heights [ B ] : <NEWLINE> <INDENT> good [ A ] = False <NEWLINE> <NL> <DEDENT> <DEDENT> count = 0 <NEWLINE> for obs in good : <NEWLINE> <INDENT> if obs : count += 1 <NEWLINE> <NL> <DEDENT> print ( count ) <NEWLINE>
temp = input ( ) . split ( <STRING> ) <NEWLINE> N = int ( temp [ 0 ] ) <NEWLINE> M = int ( temp [ 1 ] ) <NEWLINE> H = input ( ) . split ( <STRING> ) <NEWLINE> good = [ 1 ] * N <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> root = input ( ) . split ( <STRING> ) <NEWLINE> a = int ( root [ 0 ] ) - 1 <NEWLINE> b = int ( root [ 1 ] ) - 1 <NEWLINE> if H [ a ] = > H [ b ] : <NEWLINE> <INDENT> good [ b ] = 0 <NEWLINE> <DEDENT> if H [ a ] < H [ b ] : <NEWLINE> <INDENT> good [ a ] = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( sum ( good ) ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> height = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> road = { } <NEWLINE> <NL> <COMMENT> <NL> for i in range ( K ) : <NEWLINE> <INDENT> a , b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> try : <NEWLINE> <INDENT> road [ a - 1 ] . append ( b - 1 ) <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> road [ a - 1 ] = [ b - 1 ] <NEWLINE> <DEDENT> try : <NEWLINE> <INDENT> road [ b - 1 ] . append ( a - 1 ) <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> road [ b - 1 ] = [ a - 1 ] <NEWLINE> <NL> <DEDENT> <DEDENT> cnt = 0 <NEWLINE> for k , v in road . items ( ) : <NEWLINE> <INDENT> flag = True <NEWLINE> for i in set ( v ) : <NEWLINE> <INDENT> if height [ k ] > height [ i ] : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> flag = False <NEWLINE> <DEDENT> <DEDENT> if flag is True : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> print ( cnt + ( n - len ( d . keys ( ) ) ) ) <NEWLINE>
import re <NEWLINE> import sys <NEWLINE> import math <NEWLINE> import itertools <NEWLINE> import bisect <NEWLINE> from copy import copy <NEWLINE> from collections import deque , Counter <NEWLINE> from decimal import Decimal <NEWLINE> import functools <NEWLINE> def v ( ) : return input ( ) <NEWLINE> def k ( ) : return int ( input ( ) ) <NEWLINE> def S ( ) : return input ( ) . split ( ) <NEWLINE> def I ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def X ( ) : return list ( input ( ) ) <NEWLINE> def L ( ) : return list ( input ( ) . split ( ) ) <NEWLINE> def l ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> def lcm ( a , b ) : return a * b // math . gcd ( a , b ) <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> cnt = 0 <NEWLINE> ans = 0 <NEWLINE> inf = float ( <STRING> ) <NEWLINE> <NL> N = k ( ) <NEWLINE> count = 0 <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> t = N // i <NEWLINE> count += i * t * ( t + 1 ) / 2 <NEWLINE> <DEDENT> print ( int ( count ) ) <NEWLINE>
n , m = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> h = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> hs = [ [ ] for i in range ( n ) ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> a , b = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> hs [ a - 1 ] . append ( h [ b - 1 ] ) <NEWLINE> hs [ b - 1 ] . appned ( h [ a - 1 ] ) <NEWLINE> <DEDENT> c = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if len ( hs [ i ] ) == 0 : <NEWLINE> <INDENT> c += 1 <NEWLINE> <DEDENT> elif h [ i ] > max ( hs [ i ] ) : <NEWLINE> <INDENT> c += 1 <NEWLINE> <DEDENT> <DEDENT> print ( c ) <NEWLINE>
import collections <NEWLINE> num_list = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> height_list = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> way_list = list ( list ( map ( int , input ( ) . split ( ) ) ) for i in range ( num_list [ 1 ] ) ) <NEWLINE> <NL> tower_list = [ i for i in range ( 1 , num_list [ 0 ] + 1 ) ] <NEWLINE> gd_dict = dict ( zip ( tower_list , [ <STRING> for i in range ( 10 ** 5 ) ] ) ) <NEWLINE> <NL> def change_to_bad ( target_list ) : <NEWLINE> <INDENT> if height_list [ target_list [ 0 ] ] > height_list [ target_list [ 1 ] ] : <NEWLINE> <INDENT> gd_dict [ target_list [ 1 ] ] = <STRING> <NEWLINE> <DEDENT> elif height_list [ target_list [ 0 ] ] == height_list [ target_list [ 1 ] ] : <NEWLINE> <INDENT> gd_dict [ target_list [ 0 ] ] = <STRING> <NEWLINE> gd_dict [ target_list [ 1 ] ] = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> gd_dict [ target_list [ 0 ] ] = <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> for i in way_list : <NEWLINE> <INDENT> change_to_bad ( i ) <NEWLINE> <NL> <DEDENT> good_val = collections . Counter ( gd_dict . values ( ) ) [ <STRING> ] <NEWLINE> <NL> good_val <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> H = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = [ i for i in range ( 1 , n + 1 ) ] <NEWLINE> low = [ ] <NEWLINE> load = [ map ( int , input ( ) . split ( ) ) for j in range ( m ) ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> if H [ load [ i ] [ 0 ] - 1 ] == H [ load [ i ] [ 1 ] - 1 ] : <NEWLINE> <INDENT> low . append ( load [ i ] [ 0 ] ) <NEWLINE> low . append ( load [ i ] [ 1 ] ) <NEWLINE> <DEDENT> elif H [ load [ i ] [ 0 ] - 1 ] > H [ load [ i ] [ 1 ] - 1 ] : <NEWLINE> <INDENT> low . append ( load [ i ] [ 1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> low . append ( load [ i ] [ 0 ] ) <NEWLINE> <DEDENT> <DEDENT> low = list ( set ( low ) ) <NEWLINE> for k in low : <NEWLINE> <INDENT> ans . remove ( k ) <NEWLINE> <DEDENT> print ( len ( ans ) ) <NEWLINE>
h = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> l = [ 1 ] * n <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if h [ a - 1 ] >= h [ b - 1 ] : <NEWLINE> <INDENT> l [ b - 1 ] = 0 <NEWLINE> <DEDENT> if h [ b - 1 ] >= h [ a - 1 ] : <NEWLINE> <INDENT> l [ a - 1 ] = 0 <NEWLINE> <DEDENT> <DEDENT> print ( sum ( l ) ) <NEWLINE>
import math <NEWLINE> <NL> x = int ( input ( ) ) <NEWLINE> <NL> end = math . floor ( x ** 0.2 ) <NEWLINE> <NL> for i in range ( 1 , x + 1 ) : <NEWLINE> <INDENT> if x % i == 0 : <NEWLINE> <INDENT> for a in range ( i // 2 , end , 1 ) : <NEWLINE> <INDENT> b = a - i <NEWLINE> if a ** 5 - b ** 5 == x : <NEWLINE> <INDENT> print ( a , b ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT>
<INDENT> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> H = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> LIST = [ 1 for _ in range ( N ) ] <NEWLINE> for _ in range ( M ) : <NEWLINE> <INDENT> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> if H [ A - 1 ] >= H [ B - 1 ] : LIST [ B - 1 ] = 0 <NEWLINE> if H [ A - 1 ] <= H [ B - 1 ] : LIST [ A - 1 ] = 0 <NEWLINE> <DEDENT> print ( sum ( LIST ) ) <NEWLINE> <DEDENT>
h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> x = [ [ ] for _ in range ( n + 1 ) ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> x [ a ] . append ( h [ b - 1 ] ) <NEWLINE> x [ b ] . append ( h [ a - 1 ] ) <NEWLINE> <DEDENT> count = 0 <NEWLINE> for j in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if x [ j ] == [ ] : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if h [ j - 1 ] > max ( x [ j ] ) : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> H = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> C = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( M ) ] <NEWLINE> l = list ( ) <NEWLINE> m = list ( ) <NEWLINE> cnt = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> for j in range ( M ) : <NEWLINE> <INDENT> if i + 1 in C [ j ] : <NEWLINE> <INDENT> l = l + [ H [ C [ j ] [ 0 ] - 1 ] , H [ C [ j ] [ 1 ] - 1 ] ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> <DEDENT> print ( l ) <NEWLINE> if len ( l ) == 0 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> elif H [ i ] == max ( l ) : <NEWLINE> <NL> <NL> elif H [ i ] > max ( l ) : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> l = list ( ) <NEWLINE> m = list ( ) <NEWLINE> <DEDENT> print ( cnt ) <NEWLINE>
n , m = map ( int , input ( ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> tall = [ 0 ] * n <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> a -= 1 <NEWLINE> b -= 1 <NEWLINE> tall [ a ] = max ( tall [ a ] , h [ b ] ) <NEWLINE> tall [ b ] = max ( tall [ b ] , h [ a ] ) <NEWLINE> <DEDENT> res = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if h [ i ] > tall [ i ] : <NEWLINE> <INDENT> res += 1 <NEWLINE> <DEDENT> <DEDENT> print ( res ) <NEWLINE>
N , M = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> height = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> flag = [ 1 for i in renge ( len ( height ) ) ] <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> if height [ a - 1 ] > height [ b - 1 ] : <NEWLINE> <INDENT> flag [ b - 1 ] = 0 <NEWLINE> <DEDENT> elif height [ b - 1 ] > height [ a - 1 ] : <NEWLINE> <INDENT> flag [ a - 1 ] = 0 <NEWLINE> <DEDENT> <DEDENT> print ( sum ( flag ) ) <NEWLINE>
import itertools <NEWLINE> N , M = ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> H = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> AB = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( M ) ] <NEWLINE> HH = { i + 1 : H [ i ] for i in range ( len ( H ) ) } <NEWLINE> count = [ ] <NEWLINE> for i in AB : <NEWLINE> <INDENT> if HH [ i [ 1 ] ] > HH [ i [ 0 ] ] : <NEWLINE> <INDENT> count . append ( i [ 1 ] ) <NEWLINE> <DEDENT> <DEDENT> for i in HH : <NEWLINE> <INDENT> if i in CC : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> count . append ( i ) <NEWLINE> <DEDENT> <DEDENT> print ( len ( list ( set ( count ) ) ) ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> l = [ 1 for _ in range ( n ) ] <NEWLINE> <NL> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if h [ a - 1 ] > h [ b - 1 ] : <NEWLINE> <INDENT> l [ b - 1 ] = 0 <NEWLINE> <DEDENT> elif : <NEWLINE> <INDENT> l [ a - 1 ] = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> l [ a - 1 ] = 0 <NEWLINE> l [ b - 1 ] = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> cnt = 0 <NEWLINE> for i in l : <NEWLINE> <INDENT> if i == 1 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> tmp = [ 0 ] * n <NEWLINE> <NL> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if l [ a - 1 ] >= l [ b - 1 ] : <NEWLINE> <INDENT> tmp [ b - 1 ] = - 1 <NEWLINE> <DEDENT> if l [ a - 1 ] <= l [ b - 1 ] <NEWLINE> <INDENT> tmp [ a - 1 ] = - 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( tmp . count ( 0 ) ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> x = [ ] <NEWLINE> for j in range ( m ) : <NEWLINE> <INDENT> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> s = a [ 0 ] - 1 <NEWLINE> t = a [ 1 ] - 1 <NEWLINE> if h [ s ] <= h [ t ] : <NEWLINE> <INDENT> x . append ( t ) <NEWLINE> <DEDENT> else <NEWLINE> <INDENT> x . append ( s ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( len ( set ( x ) ) ) <NEWLINE> <NL>
n , m = map ( int , readline ( ) . split ( ) ) <NEWLINE> h = list ( map ( int , readline ( ) . split ( ) ) ) <NEWLINE> <NL> l = [ 1 ] * n <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , readline ( ) . split ( ) ) <NEWLINE> if h [ a - 1 ] < h [ b - 1 ] : <NEWLINE> <INDENT> l [ a - 1 ] = 0 <NEWLINE> <DEDENT> elif h [ a - 1 ] > h [ b - 1 ] : <NEWLINE> <INDENT> l [ b - 1 ] = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> l [ a - 1 ] = 0 <NEWLINE> l [ b - 1 ] = 0 <NEWLINE> <DEDENT> <DEDENT> print ( sum ( l ) ) <NEWLINE>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> V = [ True ] * N <NEWLINE> H = [ int ( v ) for v in input ( ) . split ( ) ] <NEWLINE> AB = [ [ map ( int , input ( ) . split ( ) ) ] for _ in range ( M ) ] <NEWLINE> for ab in AB : <NEWLINE> <INDENT> a , b = ab <NEWLINE> a -= 1 <NEWLINE> b -= 1 <NEWLINE> <COMMENT> <NL> if H [ a ] < H [ b ] : <NEWLINE> <INDENT> V [ a ] = False <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> V [ b ] = False <NEWLINE> <NL> <DEDENT> <DEDENT> print ( V . count ( True ) ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> pair = [ ] <NEWLINE> for _ in range ( M ) : <NEWLINE> <INDENT> inp = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> pair . append ( inp ) <NEWLINE> <NL> <DEDENT> loser = [ ] <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> if h [ pair [ i ] [ 0 ] ] < h [ pair [ i ] [ 1 ] ] : <NEWLINE> <INDENT> loser . append ( pair [ i ] [ 0 ] ) <NEWLINE> <DEDENT> elif h [ pair [ i ] [ 0 ] ] > h [ pair [ i ] [ 1 ] ] : <NEWLINE> <INDENT> loser . append ( pair [ i ] [ 1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> loser . append ( pair [ i ] [ 0 ] ) <NEWLINE> loser . append ( pair [ i ] [ 1 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> set_loser = set ( loser ) <NEWLINE> ans = N - int ( len ( set_loser ) ) <NEWLINE> print ( ans ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> H = list ( map ( int , input ( ) . split ) ) <NEWLINE> AB = [ list ( map ( int , input ( ) . split ) ) for _ in range ( M ) ] <NEWLINE> <NL> neighbor_max_heights = [ 0 ] * N <NEWLINE> <NL> for i in range ( M ) : <NEWLINE> <INDENT> a , b = AB [ i ] <NEWLINE> neighbor_max_heights [ b - 1 ] = max ( neighbor_max_heights [ b - 1 ] , H [ a - 1 ] ) <NEWLINE> neighbor_max_heights [ a - 1 ] = max ( neighbor_max_heights [ a - 1 ] , H [ b - 1 ] ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for j in range ( N ) : <NEWLINE> <INDENT> if H [ j - 1 ] > neighbor_max_heights [ j - 1 ] : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<INDENT> import sys <NEWLINE> <DEDENT> input = sys . stdin . readline <NEWLINE> <NL> N , M = ( int ( x ) for x in input ( ) . rstrip ( <STRING> ) . split ( ) ) <NEWLINE> Hs = [ int ( x ) for x in input ( ) . rstrip ( <STRING> ) . split ( ) ] <NEWLINE> nums = [ 1 for x in Hs ] <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> roads = [ int ( x ) for x in input ( ) . rstrip ( <STRING> ) . split ( ) ] <NEWLINE> if Hs [ roads [ 0 ] - 1 ] < Hs [ roads [ 1 ] - 1 ] : <NEWLINE> <INDENT> nums [ roads [ 0 ] - 1 ] = 0 <NEWLINE> <DEDENT> elif Hs [ roads [ 0 ] - 1 ] > Hs [ roads [ 1 ] - 1 ] : <NEWLINE> <INDENT> nums [ roads [ 1 ] - 1 ] = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> nums [ roads [ 0 ] - 1 ] = 0 <NEWLINE> nums [ roads [ 1 ] - 1 ] = 0 <NEWLINE> <DEDENT> <DEDENT> print ( sum ( nums ) ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> H = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> root = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( M ) ] <NEWLINE> <NL> is_min = [ 0 for _ in range ( N ) ] <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> A = root [ i ] [ 0 ] - 1 <NEWLINE> B = root [ i ] [ 1 ] - 1 <NEWLINE> <NL> if H [ A ] > H [ B ] ] : <NEWLINE> <INDENT> is_min [ B ] = 1 <NEWLINE> <NL> <DEDENT> elif H [ A ] == H [ B ] ] : <NEWLINE> <INDENT> is_min [ A ] = 1 <NEWLINE> is_min [ B ] = 1 <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> is_min [ A ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( N - sum ( is_min ) ) <NEWLINE>
n , m = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = [ ] <NEWLINE> b = [ ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> a0 , b0 = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a . append ( a0 ) <NEWLINE> b . append ( b0 ) <NEWLINE> <NL> <DEDENT> count = [ 0 ] * n <NEWLINE> <NL> for i in range ( m ) : <NEWLINE> <INDENT> if h [ a [ i ] - 1 ] <= h [ b [ i ] - 1 ] : <NEWLINE> <INDENT> count [ a [ i ] - 1 ] = 1 <NEWLINE> <DEDENT> if h [ a [ i ] - 1 ] >= h [ b [ i ] - 1 ] : <NEWLINE> count [ b [ i ] - 1 ] = 1 <NEWLINE> <NL> <DEDENT> print ( count . count ( 0 ) ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ab = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( m ) ] <NEWLINE> list = [ 0 ] * n <NEWLINE> for a , b in ab : <NEWLINE> <INDENT> list [ a - 1 ] += max ( list [ a - 1 ] , h [ b - 1 ] ) <NEWLINE> list [ b - 1 ] += max ( list [ b - 1 ] , h [ a - 1 ] ) <NEWLINE> <DEDENT> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if list [ i ] < h [ i ] : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> H = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ma = [ 0 ] * ( N + 1 ) <NEWLINE> cnt = 0 <NEWLINE> for _ in range ( M ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> ma [ a ] = max ( ma [ a ] , H [ b - 1 ] ) <NEWLINE> ma [ b ] = max ( H [ a - 1 ] , ma [ b ] ) <NEWLINE> <DEDENT> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> if H [ i ] > ma [ i ] : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
<NL> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> t = [ 0 ] * N <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> t [ A - 1 ] = max ( t [ A - 1 ] , H [ B - 1 ] ) <NEWLINE> t [ B - 1 ] = max ( t [ B - 1 ] , H [ A - 1 ] ) <NEWLINE> <NL> <DEDENT> ct = 0 <NEWLINE> for j in range ( N ) : <NEWLINE> <INDENT> if H [ j ] > [ j ] : <NEWLINE> <INDENT> ct += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ct ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> good = [ 0 ] * N <NEWLINE> <NL> H = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for j in range ( M ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if ( H [ a - 1 ] == H [ b - 1 ] ) : <NEWLINE> <INDENT> good [ a - 1 ] += 1 <NEWLINE> good [ b - 1 ] += 1 <NEWLINE> <DEDENT> elif ( H [ a - 1 ] < H [ b - 1 ] ) : <NEWLINE> <INDENT> good [ a - 1 ] += 1 <NEWLINE> <DEDENT> elif ( H [ b - 1 ] < H [ a - 1 ] : <NEWLINE> <INDENT> good [ b - 1 ] += 1 <NEWLINE> <DEDENT> <DEDENT> count = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if ( good [ i ] == 0 ) : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
n , m = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> H = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ab = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( m ) ] <NEWLINE> <NL> ans = [ 1 ] * ( n ) <NEWLINE> route = [ 1 ] * ( n ) <NEWLINE> for i in range ( len ( ab ) ) : <NEWLINE> <INDENT> a , b = ab [ i ] <NEWLINE> if H [ a - 1 ] <= H [ b - 1 ] : <NEWLINE> <INDENT> ans [ a - 1 ] = 0 <NEWLINE> <NL> <DEDENT> elif H [ b - 1 ] <= H [ a - 1 ] : <NEWLINE> <INDENT> ans [ b - 1 ] = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( sum ( cnt ) ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = [ 1 ] * n <NEWLINE> <NL> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if h [ a ] >= h [ b ] : <NEWLINE> <INDENT> ans [ b - 1 ] = 0 <NEWLINE> <DEDENT> if h [ a ] <= h [ b ] : <NEWLINE> <INDENT> ans [ a - 1 ] = 0 <NEWLINE> <DEDENT> <DEDENT> print ( sum ( ans ) ) <NEWLINE> <NL> <NL> <NL>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> good = 0 <NEWLINE> <NL> obs = [ [ ] for i in range ( n ) ] <NEWLINE> <NL> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> obs [ a - 1 ] . append ( b ) <NEWLINE> obs [ b - 1 ] . append ( a ) <NEWLINE> <NL> higher = True <NEWLINE> if len ( o ) == 0 : <NEWLINE> <INDENT> good += 1 <NEWLINE> continue <NEWLINE> <DEDENT> o = set ( o ) <NEWLINE> for i in o : <NEWLINE> <INDENT> if h [ idx ] <= h [ i - 1 ] : <NEWLINE> <INDENT> higher = False <NEWLINE> <DEDENT> <DEDENT> if higher : <NEWLINE> <INDENT> good += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( good ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <COMMENT> <NL> l = [ [ ] for _ in range ( n ) ] <NEWLINE> <NL> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> l [ a - 1 ] . append ( b - 1 ) <NEWLINE> l [ b - 1 ] . append ( a - 1 ) <NEWLINE> <NL> <DEDENT> print ( l ) <NEWLINE> <INDENT> av <NEWLINE> <DEDENT> c = 0 <NEWLINE> for j in range ( n ) : <NEWLINE> <INDENT> if len ( l [ j ] ) == 0 : <NEWLINE> <INDENT> c += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> m = 0 <NEWLINE> for k in l [ j ] : <NEWLINE> <INDENT> if h [ j ] <= h [ k ] : <NEWLINE> <INDENT> m = 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if m == 0 : <NEWLINE> <NL> <INDENT> c += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( c ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> h = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> judge = [ True ] * N <NEWLINE> <NL> for i in range ( M ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if h [ a - 1 ] > h [ b - 1 ] : <NEWLINE> <INDENT> judge [ b - 1 ] = False <NEWLINE> <DEDENT> if h [ a - 1 ] < h [ b - 1 ] : <NEWLINE> <INDENT> judge [ a - 1 ] = False <NEWLINE> <DEDENT> if h [ a - 1 ] == h [ b - 1 ] : <NEWLINE> <INDENT> judge [ b - 1 ] = False <NEWLINE> judge [ a - 1 ] = False <NEWLINE> <NL> <DEDENT> <DEDENT> print ( jadge . count ( True ) ) <NEWLINE>
N , M = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> H = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> G = [ ] * N <NEWLINE> <NL> for i in range ( M ) : <NEWLINE> <INDENT> A , B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> G [ A - 1 ] . append ( B - 1 ) <NEWLINE> G [ B - 1 ] . append ( A - 1 ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> self_h = H [ i ] <NEWLINE> <NL> self_max_flag = True <NEWLINE> <NL> for to in range ( G [ i ] ) : <NEWLINE> <INDENT> if ( self_h <= H [ to ] ) : <NEWLINE> <INDENT> self_max_flag = False <NEWLINE> <NL> <DEDENT> <DEDENT> if ( self_max_flag ) : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> min = [ ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if h [ a ] < h [ b ] : <NEWLINE> <INDENT> min . append ( a ) <NEWLINE> <DEDENT> if h [ a ] == h [ b ] : <NEWLINE> <INDENT> min . append ( a ) <NEWLINE> min . append ( b ) <NEWLINE> <DEDENT> if h [ a ] > h [ b ] : <NEWLINE> <INDENT> min . append ( b ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( len ( h ) - len ( set ( min ) ) ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> H = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> preH = [ 0 for i in range ( N ) ] <NEWLINE> <NL> for i in range ( M ) : <NEWLINE> <INDENT> preH . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <DEDENT> ans = [ True ] * N <NEWLINE> <NL> for i in range ( M ) : <NEWLINE> <INDENT> A , B = preH [ i ] <COMMENT> <NEWLINE> <NL> if ( H [ A - 1 ] >= H [ B - 1 ] ) : <NEWLINE> <INDENT> ans [ A - 1 ] = False <NEWLINE> <DEDENT> if ( H [ B - 1 ] >= H [ A - 1 ] ) : <NEWLINE> <INDENT> ans [ B - 1 ] = False <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans . count ( True ) ) <NEWLINE>
def solve ( height , road ) : <NEWLINE> <INDENT> graph = collections . defaultdict ( set ) <NEWLINE> for a , b in road : <NEWLINE> <INDENT> graph [ a ] . add ( b ) <NEWLINE> graph [ b ] . add ( a ) <NEWLINE> <DEDENT> ans = 0 <NEWLINE> no_good = set ( ) <NEWLINE> for k in graph : <NEWLINE> <INDENT> for nei in graph [ k ] : <NEWLINE> <INDENT> if height [ nei - 1 ] >= height [ k - 1 ] : <NEWLINE> <INDENT> no_good . add ( k ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return len ( height ) - len ( no_good ) <NEWLINE> <NL> <DEDENT> obs , k = map ( int , input ( ) . split ( ) ) <NEWLINE> height = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> road = [ ] <NEWLINE> for _ in range ( k ) : <NEWLINE> <INDENT> r = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> road . append ( r ) <NEWLINE> <DEDENT> print ( solve ( height , road ) ) <NEWLINE>
<NL> d = defaultdict ( list ) <NEWLINE> <NL> N , M = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> H = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in range ( M ) : <NEWLINE> <INDENT> a , b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> d [ a - 1 ] . append ( b - 1 ) <NEWLINE> d [ b - 1 ] . append ( a - 1 ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> ng = 0 <NEWLINE> <NL> if ( i not in d ) : <NEWLINE> <INDENT> ans += 1 <NEWLINE> continue <NEWLINE> <NL> <DEDENT> for j in d [ i ] : <NEWLINE> <INDENT> if ( H [ i ] <= H [ j ] ) : ng = 1 <NEWLINE> <DEDENT> if ( ng != 1 ) : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N , M = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> H = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A = [ 0 ] * M <NEWLINE> B = [ 0 ] * M <NEWLINE> <NL> for i in range ( M ) : <NEWLINE> <INDENT> A [ i ] , B [ i ] = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <DEDENT> ans = [ ] * N <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> a = A [ i ] - 1 <NEWLINE> b = B [ i ] - 1 <NEWLINE> if H [ a ] < H [ b ] : <NEWLINE> <INDENT> ans [ a ] = 1 <NEWLINE> <DEDENT> elif H [ a ] > H [ b ] : <NEWLINE> <INDENT> ans [ b ] = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans [ a ] = 0 <NEWLINE> ans [ b ] = 0 <NEWLINE> <DEDENT> <DEDENT> print ( ans . count ( 1 ) ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> H = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> L = [ 0 for in range ( N + 1 ) ] <NEWLINE> <NL> for q in range ( M ) : <NEWLINE> <INDENT> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> if H [ A ] < H [ B ] : <NEWLINE> <INDENT> L [ A ] += 1 <NEWLINE> <DEDENT> elif H [ A ] > H [ B ] : <NEWLINE> <INDENT> L [ B ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> L [ A ] += 1 <NEWLINE> L [ B ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> if L [ i ] == 0 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> N , M = ( int ( x ) for x in input ( ) . split ( ) ) <NEWLINE> H = [ - 1 ] + list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <COMMENT> <NL> observ_H = { } <NEWLINE> connction = { i : set ( ) for i in range ( 1 , N + 1 ) } <NEWLINE> <NL> <COMMENT> <NL> for i in range ( 1 , M + 1 ) : <NEWLINE> <INDENT> a , b = ( int ( x ) for x in input ( ) . split ( ) ) <NEWLINE> connction [ a ] . add ( b ) <NEWLINE> connction [ b ] . add ( a ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> observ_H [ i ] = H [ i ] <NEWLINE> <COMMENT> <NL> <DEDENT> observ_good = { i : <STRING> } <NEWLINE> hantei = <STRING> <NEWLINE> for num , connect in connction . items ( ) : <NEWLINE> <INDENT> hantei = <STRING> <NEWLINE> for saki in connect : <NEWLINE> <INDENT> if observ_H [ num ] > observ_H [ saki ] : <NEWLINE> <INDENT> hantei = <STRING> <NEWLINE> <DEDENT> <DEDENT> if hantei == <STRING> : <NEWLINE> <INDENT> observ_good [ num ] = <STRING> <NEWLINE> <DEDENT> <DEDENT> print ( len ( i ) ) <NEWLINE>
import sys <NEWLINE> import os <NEWLINE> f = open ( <STRING> , <STRING> ) <NEWLINE> sys . stdin = f <NEWLINE> <NL> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> i = 1 <NEWLINE> ViewH = { } <NEWLINE> H_list = input ( ) . split ( ) <NEWLINE> countlist = [ ] <NEWLINE> while i <= N : <NEWLINE> <INDENT> ViewH [ i ] = int ( H_list [ i - 1 ] ) <NEWLINE> countlist . append ( 0 ) <NEWLINE> i += 1 <NEWLINE> <NL> <NL> <DEDENT> for count in range ( M - 1 ) : <NEWLINE> <INDENT> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> if ViewH [ A ] > ViewH [ B ] : <NEWLINE> <INDENT> countlist [ B - 1 ] = 1 <NEWLINE> <DEDENT> elif ViewH [ A ] == ViewH [ B ] : <NEWLINE> <INDENT> countlist [ A - 1 ] = 1 <NEWLINE> countlist [ B - 1 ] = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> countlist [ A - 1 ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( countlist . count ( 0 ) ) <NEWLINE>
point = [ 0 ] * n <NEWLINE> app = [ 0 ] * n <NEWLINE> cnt = [ ] <NEWLINE> <NL> for i in ab : <NEWLINE> <INDENT> app [ i [ 0 ] - 1 ] += 1 <NEWLINE> app [ i [ 1 ] - 1 ] += 1 <NEWLINE> if h [ i [ 0 ] - 1 ] > h [ i [ 1 ] - 1 ] : <NEWLINE> <INDENT> point [ i [ 0 ] - 1 ] += 1 <NEWLINE> <DEDENT> elif h [ i [ 0 ] - 1 ] < h [ i [ 1 ] - 1 ] : <NEWLINE> <INDENT> point [ i [ 1 ] - 1 ] += 1 <NEWLINE> <DEDENT> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> if app [ i ] == point [ i ] : <NEWLINE> <INDENT> cnt . append ( i + 1 ) <NEWLINE> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> H = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> l = [ 1 ] * n <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> if H [ A - 1 ] > H [ B - 1 ] : <NEWLINE> <INDENT> l [ B - 1 ] = 0 <NEWLINE> <DEDENT> elif H [ A - 1 ] < H [ B - 1 ] : <NEWLINE> <INDENT> l [ A - 1 ] = 0 <NEWLINE> <DEDENT> elif H [ A - 1 ] == H [ B - 1 ] : <NEWLINE> <INDENT> l [ A - 1 ] , l [ B - 1 ] = 0 , 0 <NEWLINE> <DEDENT> <DEDENT> print ( l . count ( 1 ) ) <NEWLINE>
N , K = ( int ( i ) for i in input ( ) . split ( ) ) <NEWLINE> H = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = [ 1 ] * N <NEWLINE> for m in range ( M ) : <NEWLINE> <INDENT> a , b = ( int ( i ) for i in input ( ) . split ( ) ) <NEWLINE> if H [ a - 1 ] < H [ b - 1 ] : <NEWLINE> <INDENT> ans [ a - 1 ] = 0 <NEWLINE> <DEDENT> elif H [ a - 1 ] > H [ b - 1 ] : <NEWLINE> <INDENT> ans [ b - 1 ] = 0 <NEWLINE> <DEDENT> <DEDENT> print ( ans . count ( 1 ) ) <NEWLINE>
<COMMENT> <NL> <INDENT> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> HEIGHT_LIST = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ROAD_LIST = [ ] <NEWLINE> for j in range ( M ) : <NEWLINE> <INDENT> ROAD_LIST . append ( <NEWLINE> <INDENT> set ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <DEDENT> ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> COUNT = 0 <NEWLINE> <NL> for i in list ( range ( 1 , N + 1 ) ) : <NEWLINE> <INDENT> unioned_i = set ( [ ] ) <NEWLINE> for k in ROAD_LIST : <NEWLINE> <INDENT> if i in k : <NEWLINE> <INDENT> unioned_i = unioned_i | k <NEWLINE> <DEDENT> <DEDENT> if len ( unioned_i ) == 0 : <NEWLINE> <INDENT> COUNT = COUNT + 1 <NEWLINE> continue <NEWLINE> <DEDENT> HIGHT_i = HEIGHT_LIST [ i - 1 ] <NEWLINE> if HIGHT_i >= max ( <NEWLINE> <INDENT> [ HEIGHT_LIST [ l - 1 ] for l in list ( unioned_i ) ] <NEWLINE> <DEDENT> ) : <NEWLINE> <INDENT> COUNT = COUNT + 1 <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> print ( COUNT ) <NEWLINE> <DEDENT>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> H = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> AB = [ list ( map ( int , input ( ) . split ( ) ) ) for m in range ( M ) ] <NEWLINE> AB = list ( map ( list , set ( map ( tuple , AB ) ) ) ) <NEWLINE> <NL> i = [ ] <NEWLINE> for m in range ( len ( AB ) ) : <NEWLINE> <INDENT> a = AB [ m ] [ 0 ] <NEWLINE> b = AB [ m ] [ 1 ] <NEWLINE> if H [ a - 1 ] >= H [ b - 1 ] : <NEWLINE> <INDENT> i . append ( b - 1 ) <NEWLINE> <DEDENT> elif H [ a - 1 ] <= H [ b - 1 ] : <NEWLINE> <INDENT> i . append ( a - 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> i = list ( set ( i ) ) <NEWLINE> for x in i : <NEWLINE> <INDENT> H [ i ] = 0 <NEWLINE> <NL> <DEDENT> cnt = H . count ( 0 ) <NEWLINE> print ( len ( H ) - cnt ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> Hi = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> path = [ list [ ] for _ in range ( M + 1 ) ] <NEWLINE> <NL> for i in range ( M ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> a -= 1 <NEWLINE> b -= 1 <NEWLINE> path [ a ] . append ( b ) <NEWLINE> path [ b ] . append ( a ) <NEWLINE> <NL> <NL> <DEDENT> goodT = 0 <NEWLINE> T = range ( M + 1 ) <NEWLINE> <NL> for i , p in zip ( T , path ) : <NEWLINE> <INDENT> good = 1 <NEWLINE> if p == [ ] : <NEWLINE> <INDENT> goodT += good <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for t in p : <NEWLINE> <INDENT> if Hi [ i ] <= Hi [ t ] : <NEWLINE> <INDENT> good = 0 <NEWLINE> <DEDENT> <DEDENT> goodT += good <NEWLINE> <NL> <DEDENT> <DEDENT> print ( goodT ) <NEWLINE>
h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> d = [ 1 ] * n <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> a , b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a -= 1 <NEWLINE> b -= 1 <NEWLINE> if h [ a ] > h [ b ] : <NEWLINE> <INDENT> d [ b ] = 0 <NEWLINE> <DEDENT> elif h [ b ] > h [ a ] : <NEWLINE> <INDENT> d [ a ] = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d [ a ] = 0 <NEWLINE> d [ b ] = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( sum ( d ) ) <NEWLINE>
<COMMENT> <NL> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> if __name__ == <STRING> : <NEWLINE> <NL> <INDENT> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> HEIGHT_LIST = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = [ 1 ] * N <NEWLINE> for j in range ( M ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> a -= 1 <NEWLINE> b -= 1 <NEWLINE> height_a = HEIGHT_LIST [ a ] <NEWLINE> height_b = HEIGHT_LIST [ b ] <NEWLINE> <NL> if height_a < height_b : <NEWLINE> <INDENT> ans [ point_a ] = 0 <NEWLINE> <DEDENT> elif height_a > height_b : <NEWLINE> <INDENT> ans [ point_b ] = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans [ point_a ] = 0 <NEWLINE> ans [ point_b ] = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( sum ( ans ) ) <NEWLINE> <DEDENT>
4 3 <NEWLINE> 1 2 3 4 <NEWLINE> 1 3 <NEWLINE> 2 3 <NEWLINE> 2 4 <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> mj = [ ] <NEWLINE> <NL> for i in range ( m ) : <NEWLINE> <INDENT> mj . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> <DEDENT> tower = 0 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <COMMENT> <NL> <INDENT> cnt = 0 <NEWLINE> h_high = 0 <NEWLINE> for j in range ( m ) : <NEWLINE> <INDENT> if i + 1 in mj [ j ] : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> if i == mj [ j ] [ 0 ] - 1 : <NEWLINE> <INDENT> if h [ i ] > h [ mj [ j ] [ 1 ] - 1 ] : <NEWLINE> <INDENT> h_high += 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if h [ i ] > h [ mj [ j ] [ 0 ] - 1 ] : <NEWLINE> <INDENT> h_high += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if cnt == h_high : <NEWLINE> <INDENT> tower += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( len ( tower ) ) <NEWLINE>
h_list = list ( map ( int , input ( ) . split ( ) ) ) <COMMENT> <NEWLINE> newlist = list ( h_list ) <COMMENT> <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if h_list [ a - 1 ] < h_list [ b - 1 ] : <NEWLINE> <INDENT> newlist [ a - 1 ] = 0 <NEWLINE> <DEDENT> elif h_list [ a - 1 ] > h_list [ b - 1 ] : <NEWLINE> <INDENT> newlist [ b - 1 ] = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> newlist [ a - 1 ] = 0 <NEWLINE> newlist [ b - 1 ] = 0 <NEWLINE> <DEDENT> <DEDENT> print ( len ( h_list ) - newlist . count ( 0 ) ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ab = [ 0 ] * m <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> ab [ i ] = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <DEDENT> check = [ 1 ] * n <NEWLINE> <NL> for i in range ( m ) : <NEWLINE> <COMMENT> <NL> <INDENT> if h [ ab [ i ] [ 0 ] - 1 ] = h [ ab [ i ] [ 1 ] - 1 ] : <NEWLINE> <INDENT> check [ ab [ i ] [ 0 ] - 1 ] = 0 <NEWLINE> check [ ab [ i ] [ 1 ] - 1 ] = 0 <NEWLINE> <DEDENT> elif h [ ab [ i ] [ 0 ] - 1 ] < h [ ab [ i ] [ 1 ] - 1 ] : <NEWLINE> <INDENT> check [ ab [ i ] [ 0 ] - 1 ] = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> check [ ab [ i ] [ 1 ] - 1 ] = 0 <NEWLINE> <DEDENT> <DEDENT> print ( sum ( check ) ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> H = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> t = [ 0 ] * N <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> t [ a - 1 ] = max ( t [ a - 1 ] , H [ b - 1 ] ) <NEWLINE> t [ b - 1 ] = max ( t [ b - 1 ] , H [ a - 1 ] ) <NEWLINE> <NL> <DEDENT> res = 0 <NEWLINE> for i range ( N ) : <NEWLINE> <INDENT> if H [ i ] > t [ i ] : <NEWLINE> <INDENT> res += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( res ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> H_tree = [ int ( n ) for n in input ( ) . split ( ) ] <NEWLINE> GOOD_Tree = [ 1 for n in range ( N ) ] <NEWLINE> <NL> for i in range ( M ) : <NEWLINE> <INDENT> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> if H_tree [ A ] <= H_tree [ B ] : GOOD_Tree [ A ] = 0 <NEWLINE> if H_tree [ A ] >= H_tree [ B ] : GOOD_Tree [ B ] = 0 <NEWLINE> <DEDENT> print ( sum ( GOOD_Tree ) ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = [ 1 ] * n <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> ai , bi = map ( int , input ( ) . split ( ) ) <NEWLINE> ab [ i ] = ai <NEWLINE> ab [ i + m ] = bi <NEWLINE> if h [ ai - 1 ] >= h [ bi - 1 ] : <NEWLINE> <INDENT> ans [ bi - 1 ] = 0 <NEWLINE> <DEDENT> elif h [ ai - 1 ] < h [ bi - 1 ] : <NEWLINE> <INDENT> ans [ ai - 1 ] = 0 <NEWLINE> <DEDENT> <DEDENT> print ( sum ( ans ) ) <NEWLINE>
import numpy as np <NEWLINE> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> S = np . zeros ( ( N , N ) ) <NEWLINE> H = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for j in range ( M ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if H [ a - 1 ] < H [ b - 1 ] : <NEWLINE> <INDENT> S [ a - 1 , b - 1 ] = - 1 <NEWLINE> S [ b - 1 , a - 1 ] = 1 <NEWLINE> <DEDENT> elif H [ a - 1 ] > H [ b - 1 ] : <NEWLINE> <INDENT> S [ a - 1 , b - 1 ] = 1 <NEWLINE> S [ b - 1 , a - 1 ] = - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> S [ a - 1 , b - 1 ] = - 1 <NEWLINE> S [ b - 1 , a - 1 ] = - 1 <NEWLINE> <NL> <DEDENT> <DEDENT> s = np . zeros ( N ) <NEWLINE> for k in range ( N + 10 ) : <NEWLINE> <INDENT> s [ k ] = np . any ( S [ k , : ] < 0 ) <NEWLINE> <NL> <DEDENT> print ( len ( [ i for i , x in enumerate ( s ) if x == 0 ] ) ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> H = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> V = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( M ) ] <NEWLINE> <NL> count = 0 <NEWLINE> <NL> dic = { } <NEWLINE> <NL> for i in range ( 1 , N ) : <NEWLINE> <INDENT> dic [ i ] = set ( ) <NEWLINE> <NL> <DEDENT> for hen in V : <NEWLINE> <INDENT> dic [ hen [ 0 ] ] . add ( hen [ 1 ] ) <NEWLINE> dic [ hen [ 1 ] ] . add ( hen [ 0 ] ) <NEWLINE> <NL> <DEDENT> print ( sum ( all ( [ H [ i ] > hs for hs in dic [ i ] ] ) for i in range ( N ) ) ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> H = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> P = [ ] <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> P . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <COMMENT> <NEWLINE> <NL> <DEDENT> ans = [ ] <NEWLINE> <NL> for i in range ( M ) : <NEWLINE> <INDENT> if H [ P [ i ] [ 0 ] - 1 ] > H [ P [ i ] [ 1 ] - 1 ] : <COMMENT> <NEWLINE> <INDENT> ans . append ( [ P [ i ] [ 0 ] ) <NEWLINE> <DEDENT> elif H [ P [ i ] [ 0 ] - 1 ] < H [ P [ i ] [ 1 ] - 1 ] : <COMMENT> <NEWLINE> <INDENT> ans . append ( P [ i ] [ 1 ] ) <NEWLINE> <DEDENT> else : <COMMENT> <NEWLINE> <INDENT> continue <NEWLINE> <NL> <DEDENT> <DEDENT> list = [ ] <NEWLINE> <NL> for j in range ( M ) : <NEWLINE> <INDENT> list += P [ j ] <NEWLINE> <NL> <DEDENT> print ( len ( set ( ans ) ) + N - len ( set ( list ) ) ) <NEWLINE>
import sys <NEWLINE> def input ( ) : <NEWLINE> <INDENT> return list ( map ( int , sys . stdin . readline ( ) . strip ( ) . split ( ) ) ) <NEWLINE> <NL> <DEDENT> n , m = input ( ) <NEWLINE> h = input ( ) <NEWLINE> tmp = [ [ ] for i in range ( n ) ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> a , b = input ( ) <NEWLINE> tmp [ b - 1 ] . append ( a - 1 ) <NEWLINE> tmp [ a - 1 ] . append ( b - 1 ) <NEWLINE> <DEDENT> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> flag = True <NEWLINE> for ele in tmp [ i ] : <NEWLINE> <INDENT> if ( h [ i ] <= h [ ele ] ) : <NEWLINE> <INDENT> flag = False <NEWLINE> <DEDENT> <DEDENT> if ( flag ) : ans += 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
height = list ( map ( int , input ( ) . strip ( ) . split ( ) ) ) <NEWLINE> lst = [ 1 ] * h <NEWLINE> <NL> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . strip ( ) . split ( ) ) <NEWLINE> if height [ a - 1 ] > height [ b - 1 ] : <NEWLINE> <INDENT> lst [ a - 1 ] = 1 <NEWLINE> lst [ b - 1 ] = 0 <NEWLINE> <DEDENT> elif height [ a - 1 ] < height [ b - 1 ] : <NEWLINE> <INDENT> lst [ b - 1 ] = 1 <NEWLINE> lst [ a - 1 ] = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> lst [ b - 1 ] = 0 <NEWLINE> lst [ a - 1 ] = 0 <NEWLINE> <DEDENT> <DEDENT> print ( lst . count ( 1 ) ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> H = list ( map ( int , input ( ) . split ( ) ) ) <COMMENT> <NEWLINE> assert len ( H ) == N <NEWLINE> paths = [ [ ] for i in range ( N ) ] <NEWLINE> for m in range ( M ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> paths [ a ] . append ( b ) <NEWLINE> paths [ b ] . append ( a ) <COMMENT> <NEWLINE> <DEDENT> assert len ( A ) == M <NEWLINE> <NL> count = 0 <NEWLINE> for a in A : <NEWLINE> <INDENT> for b in paths [ b ] : <NEWLINE> <INDENT> if H [ b ] >= H [ a ] : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ma = [ 0 ] * ( n ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a , b = map ( lambda x : int ( x ) - 1 , input ( ) . split ( ) ) <NEWLINE> ma [ a ] = max ( ma [ a ] , h [ b ] ) <NEWLINE> ma [ b ] = max ( h [ a ] , ma [ b ] ) <NEWLINE> <DEDENT> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if h [ i ] > ma [ i ] : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<NL> <NL> i = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> j = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> lis = [ ] <NEWLINE> for i in range ( i [ 0 ] ) : <NEWLINE> <INDENT> tendata = [ i + 1 , j [ i ] , 0 ] <NEWLINE> lis . append ( tendata ) <NEWLINE> <NL> <DEDENT> for i in range ( i [ 1 ] ) : <NEWLINE> <INDENT> miti = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if ( ( lis [ miti [ 0 ] - 1 ] [ 1 ] ) > ( lis [ miti [ 1 ] ] [ 1 ] ) ) : <NEWLINE> <INDENT> lis [ miti [ 0 ] - 1 ] [ 2 ] = ( lis [ miti [ 0 ] - 1 ] [ 2 ] + 100 ) <NEWLINE> lis [ miti [ 1 ] - 1 ] [ 2 ] = ( lis [ miti [ 1 ] - 1 ] [ 2 ] + 2 ) <NEWLINE> <NL> <DEDENT> elif ( ( lis [ miti [ 0 ] - 1 ] [ 1 ] ) < ( lis [ miti [ 1 ] ] [ 1 ] ) ) : <NEWLINE> <INDENT> lis [ miti [ 1 ] - 1 ] [ 2 ] = ( lis [ miti [ 1 ] - 1 ] [ 2 ] + 100 ) <NEWLINE> lis [ miti [ 0 ] - 1 ] [ 2 ] = ( lis [ miti [ 0 ] - 1 ] [ 2 ] + 2 ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> print ( lis ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> h = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> nn = [ 1 ] * n <NEWLINE> for _ in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if h [ a - 1 ] < h [ b - 1 ] : <NEWLINE> nn [ a - 1 ] = 0 <NEWLINE> else : <NEWLINE> nn [ b - 1 ] = 0 <NEWLINE> <NL> <DEDENT> print ( sum ( nn ) ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> final = [ 1 ] * n <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> <INDENT> if h [ a - 1 ] < h [ b - 1 ] : <NEWLINE> <INDENT> final [ a - 1 ] = 0 <NEWLINE> <DEDENT> elif h [ a - 1 ] > h [ b - 1 ] : <NEWLINE> <INDENT> final [ b - 1 ] = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> final [ a - 1 ] = 0 <NEWLINE> final [ b - 1 ] = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( sum ( final ) ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = [ 0 ] * m <NEWLINE> b = [ 0 ] * m <NEWLINE> l = [ 0 ] * n <NEWLINE> count = 0 <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> a [ i ] , b [ i ] = map ( int , input ( ) . split ( ) ) <NEWLINE> l [ a - 1 ] = max ( l [ a - 1 ] , h [ b - 1 ] ) <NEWLINE> l [ b - 1 ] = max ( l [ b - 1 ] , h [ a - 1 ] ) <NEWLINE> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> if h [ i ] > l [ i ] : <NEWLINE> <INDENT> count = count + 1 <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
n , m = map ( int ( input ( ) . split ( ) ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> p = [ 1 ] * n <NEWLINE> max = 0 <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int ( input ( ) . split ( ) ) ) <NEWLINE> if h [ a - 1 ] <= h [ b - 1 ] : <NEWLINE> <INDENT> p [ a - 1 ] = 0 <NEWLINE> <DEDENT> if h [ a - 1 ] >= h [ b - 1 ] : <NEWLINE> <INDENT> p [ b - 1 ] = 0 <NEWLINE> <DEDENT> <DEDENT> print ( sum ( p ) ) <NEWLINE>
<COMMENT> <NL> h_list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> roads = [ ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> roads . append ( [ a , b ] ) <NEWLINE> <COMMENT> <NL> <DEDENT> terrace = [ 1 ] * n <NEWLINE> for road in roads : <NEWLINE> <INDENT> if h_list [ road [ 0 ] - 1 ] > h_list [ road [ 1 ] - 1 ] : <NEWLINE> <INDENT> terrace [ road [ 1 ] - 1 ] = 0 <NEWLINE> <DEDENT> elif h_list [ road [ 0 ] - 1 ] == h_list [ road [ 1 ] - 1 ] : <NEWLINE> <INDENT> terrace [ road [ 0 ] - 1 ] = 0 <NEWLINE> terrace [ road [ 1 ] - 1 ] = 0 <NEWLINE> <DEDENT> elif h_list [ road [ 0 ] - 1 ] < h_list [ road [ 1 ] - 1 ] : <NEWLINE> <INDENT> terrace [ road [ 0 ] - 1 ] = 0 <NEWLINE> <DEDENT> <DEDENT> print ( terrace . count ( 1 ) ) <NEWLINE>
N , M = input ( ) . split ( ) <NEWLINE> height = input ( ) . split ( ) <NEWLINE> able = [ ] <NEWLINE> for n in range ( int ( N ) ) : <NEWLINE> <INDENT> able . append ( [ ] ) <NEWLINE> <DEDENT> for m in range ( int ( M ) ) : <NEWLINE> <INDENT> con = input ( ) . split ( ) <NEWLINE> con [ 0 ] = int ( con [ 0 ] ) - 1 <NEWLINE> con [ 1 ] = int ( con [ 1 ] ) - 1 <NEWLINE> able [ con [ 0 ] ] . append ( height ( con [ 1 ] ) ) <NEWLINE> able [ con [ 1 ] ] . append ( height ( con [ 0 ] ) ) <NEWLINE> <DEDENT> good = [ ] <NEWLINE> for n in range ( int ( N ) ) : <NEWLINE> <INDENT> if len ( able [ n ] ) == 0 : <NEWLINE> <INDENT> good . append ( n ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if int ( height [ n ] ) > max ( able [ n ] ) <NEWLINE> <INDENT> good . append ( n ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( len ( good ) ) <NEWLINE>
import math <NEWLINE> A , B , N = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> arr = [ ] <NEWLINE> for num in range ( N ) : <NEWLINE> <NL> <INDENT> ans = math . floor ( ( A * N ) / B ) - A * math . floor ( N / B ) <NEWLINE> arr . append ( ans ) <NEWLINE> <NL> <DEDENT> arr . sort ( ) <NEWLINE> <NL> print ( arr [ len ( arr ) - 1 ] ) <NEWLINE>
n , m = map ( int , input ( ) . rstrip ( ) . split ( ) ) <NEWLINE> h = map ( int , input ( ) . rstrip ( ) . split ( ) ) <NEWLINE> l = [ ] <NEWLINE> high = [ 0 ] * n <NEWLINE> count = 0 <NEWLINE> <NL> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . rstrip ( ) . split ( ) ) <NEWLINE> l . append ( [ a , b ] ) <NEWLINE> <NL> <DEDENT> for i in l : <NEWLINE> <INDENT> if h [ i [ 0 ] - 1 ] < h [ i [ 1 ] - 1 ] : <NEWLINE> <INDENT> high [ i [ 0 ] - 1 ] += 1 <NEWLINE> <DEDENT> elif h [ i [ 0 ] - 1 ] == h [ i [ 1 ] - 1 ] : <NEWLINE> <INDENT> high [ i [ 0 ] - 1 ] += 1 <NEWLINE> high [ i [ 1 ] - 1 ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> high [ i [ 1 ] - 1 ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> for hi in high : <NEWLINE> <INDENT> if hi == 0 : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> l_n = [ True ] * n <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> elif h [ a - 1 ] >= h [ b - 1 ] : <NEWLINE> <INDENT> l_n [ b - 1 ] = False <NEWLINE> <DEDENT> elif h [ a - 1 ] <= h [ b - 1 ] : <NEWLINE> <INDENT> l_n [ a - 1 ] = False <NEWLINE> <DEDENT> <DEDENT> print ( sum ( l_n ) ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> N , M , * HAB = map ( int , open ( 0 ) . read ( ) . split ( ) ) <NEWLINE> H = [ 0 ] * N <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> H [ i ] = HAB [ i ] <NEWLINE> <DEDENT> A , B = [ 0 ] * M , [ 0 ] * M <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> A [ i ] = HAB [ N + 2 * i + 0 ] - 1 <NEWLINE> B [ i ] = HAB [ N + 2 * i + 1 ] - 1 <NEWLINE> <COMMENT> <NL> <DEDENT> ans = set ( ) <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> a = A [ i ] <NEWLINE> b = B [ i ] <NEWLINE> ha = H [ a ] <NEWLINE> hb = H [ b ] <NEWLINE> if ha < hb : <NEWLINE> <INDENT> ans . add ( a ) <NEWLINE> <DEDENT> elif hb < ha <NEWLINE> <INDENT> ans . add ( b ) <NEWLINE> <DEDENT> <DEDENT> print ( N - len ( ans ) ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> x = [ list ( map ( int , input ( ) . split ( ) ) ) for nesya in range ( m ) ] <NEWLINE> k = [ 1 ] * n <NEWLINE> for route in x : <NEWLINE> <INDENT> h1 = route [ 0 ] - 1 <NEWLINE> h2 = route [ 1 ] - 1 <NEWLINE> if h [ h1 ] < h [ h2 ] : <NEWLINE> <INDENT> k [ h1 ] = 0 <NEWLINE> <DEDENT> elif h [ h1 ] > h [ h2 ] <NEWLINE> <INDENT> k [ h2 ] = 0 <NEWLINE> <DEDENT> <DEDENT> print ( sum ( k ) ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> peaks = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ng_peaks = set ( [ ] ) <NEWLINE> for j in range ( M ) : <NEWLINE> <INDENT> A_j , B_j = map ( int , input ( ) . split ( ) ) <NEWLINE> if peaks [ A_j - 1 ] >= peaks [ B_j - 1 ] : <NEWLINE> <INDENT> ng_peaks . add ( B_j ) <NEWLINE> <DEDENT> if peaks [ A_j - 1 ] = < peaks [ B_j - 1 ] : <NEWLINE> <INDENT> ng_peaks . add ( A_j ) <NEWLINE> <DEDENT> <DEDENT> print ( N - len ( ng_peaks ) ) <NEWLINE>
vn , m = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> hs = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = [ 1 ] * n <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> road = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if hs [ road [ 0 ] - 1 ] <= hs [ road [ 1 ] - 1 ] : <NEWLINE> <INDENT> ans [ road [ 0 ] - 1 ] = 0 <NEWLINE> <DEDENT> if hs [ road [ 0 ] - 1 ] >= hs [ road [ 1 ] - 1 ] : <NEWLINE> <INDENT> ans [ road [ 1 ] - 1 ] = 0 <NEWLINE> <DEDENT> <DEDENT> print ( ans . count ( 0 ) ) <NEWLINE>
import collections <NEWLINE> <NL> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> H = [ int ( input ( ) ) for i in range ( N ) ] <NEWLINE> <NL> X = [ ] <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> Aj , Bj = map ( int , input ( ) . split ( ) ) <NEWLINE> if H [ Aj - 1 ] < H [ Bj - 1 ] : <NEWLINE> <INDENT> X . append ( Aj ) <NEWLINE> <DEDENT> elif H [ Bj - 1 ] < H [ Aj - 1 ] : <NEWLINE> <INDENT> X . append ( Bj ) <NEWLINE> <DEDENT> elif H [ Aj - 1 ] == H [ Bj - 1 ] : <NEWLINE> <INDENT> X . append ( Aj ) <NEWLINE> X . append ( Bj ) <NEWLINE> <NL> <DEDENT> <DEDENT> low_H = collections . Counter ( X ) <NEWLINE> ans = N - len ( low_H ) <NEWLINE> print ( ans ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> q = [ 1 ] * 1 <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if h [ a - 1 ] < h [ b - 1 ] : <NEWLINE> <INDENT> q [ a - 1 ] = 0 <NEWLINE> <DEDENT> elif h [ a - 1 ] > h [ b - 1 ] : <NEWLINE> <INDENT> q [ b - 1 ] = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> q [ a - 1 ] = 0 <NEWLINE> q [ b - 1 ] = 0 <NEWLINE> <DEDENT> <DEDENT> print ( q . count ( 1 ) ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> H = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> s = [ [ 0 ] ] * m <NEWLINE> <NL> for _ in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> s [ a - 1 ] . append ( H [ b - 1 ] ) <NEWLINE> s [ b - 1 ] . append ( H [ a - 1 ] ) <NEWLINE> <NL> <DEDENT> c = 0 <NEWLINE> for j in range ( n ) : <NEWLINE> <INDENT> if H [ j ] > max ( s [ j ] ) : <NEWLINE> <INDENT> c += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( c ) <NEWLINE>
I = map ( int , input ( ) . split ( ) ) <NEWLINE> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> H = [ 0 ] + list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> O = [ 0 ] + [ 1 ] * N <NEWLINE> for _ in range ( M ) : <NEWLINE> <INDENT> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> if H [ A ] <= H [ B ] : <NEWLINE> <INDENT> O [ A ] = 0 <NEWLINE> <DEDENT> if H [ A ] >= H [ B ] : <NEWLINE> <INDENT> O [ B ] = 0 <NEWLINE> <DEDENT> <DEDENT> print ( sum ( O ) ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) <NEWLINE> judge = [ True ] * n <NEWLINE> <NL> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if h [ a - 1 ] >= h [ b - 1 ] : <NEWLINE> <INDENT> judge [ b - 1 ] = False <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> judge [ a - 1 ] = False <NEWLINE> <NL> <DEDENT> <DEDENT> print ( judge . count ( True ) ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> high_list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> highest = [ True ] * N <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) ) <NEWLINE> if ( high_list [ a - 1 ] >= high_list [ b - 1 ] ) : <NEWLINE> <INDENT> highest [ b - 1 ] = False <NEWLINE> <DEDENT> if ( high_list [ a - 1 ] <= high_list [ b - 1 ] ) : <NEWLINE> <INDENT> highest [ a - 1 ] = False <NEWLINE> <DEDENT> <DEDENT> print ( sum ( highest ) ) <NEWLINE> <NL> <NL>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> l = [ 1 ] * ( n + 1 ) <NEWLINE> l [ 0 ] = 0 <NEWLINE> h = list ( map ( int , input ( ) . strip ( ) . split ( ) ) ) <NEWLINE> b_a = b_b = 0 <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if b_a == a and b_b == b : <NEWLINE> <INDENT> l [ a ] = l [ b ] = 0 <NEWLINE> <DEDENT> else if h [ a - 1 ] < h [ b - 1 ] : <NEWLINE> <INDENT> l [ a ] = 0 <NEWLINE> <DEDENT> else if h [ a - 1 ] > h [ b - 1 ] : <NEWLINE> <INDENT> l [ b ] = 0 <NEWLINE> <DEDENT> b_a = a <NEWLINE> b_b = b <NEWLINE> <NL> <DEDENT> print ( sum ( l ) ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> height = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> roads = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( N ) ] <NEWLINE> alone = [ ] <NEWLINE> ans = { } <NEWLINE> b_list = [ ] <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> alone . append ( i ) <NEWLINE> <DEDENT> for road in roads : <NEWLINE> <INDENT> if max ( road ) not in b_list : <NEWLINE> <INDENT> ans [ max ( road ) ] = <STRING> <NEWLINE> b_list . append ( min ( road ) ) <NEWLINE> <DEDENT> elif road [ 0 ] in alone : <NEWLINE> <INDENT> alone . remove ( road [ 0 ] ) <NEWLINE> <DEDENT> elif road [ 1 ] in alone : <NEWLINE> <INDENT> alone . remove ( road [ 1 ] ) <NEWLINE> <DEDENT> <DEDENT> print ( len ( ans ) + len ( alone ) ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> H = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> tunagari = [ [ ] for i in range ( N ) ] <NEWLINE> TF = [ True for i in range ( N ) ] <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> if H [ A - 1 ] > H [ B - 1 ] : <NEWLINE> <INDENT> TF [ B - 1 ] = False <NEWLINE> <DEDENT> elif H [ A - 1 ] < H [ B - 1 ] : <NEWLINE> <INDENT> TF [ A - 1 ] = False : <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> TF [ A - 1 ] = False <NEWLINE> TF [ B - 1 ] = False <NEWLINE> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if TF [ i ] == True : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> yoi = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> yoi . append ( True ) <NEWLINE> <DEDENT> H = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i in ranage ( M ) : <NEWLINE> <INDENT> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> if H [ A - 1 ] <= H [ B - 1 ] : yoi [ A - 1 ] = False <NEWLINE> if H [ B - 1 ] <= H [ A - 1 ] : yoi [ B - 1 ] = False <NEWLINE> <DEDENT> print ( len ( [ 1 for x in yoi if x == True ] ) ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> h = [ 0 ] + list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> roads = [ [ ] for _ in range ( n + 1 ) ] <NEWLINE> cnt = 0 <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> roads [ a ] . append ( b ) <NEWLINE> roads [ b ] . append ( a ) <NEWLINE> <NL> <DEDENT> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> for j in roads [ i ] : <NEWLINE> <INDENT> if h [ i ] <= h [ j ] : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( cnt <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> H = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> A = [ 0 ] * M <NEWLINE> B = [ 0 ] * M <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> A [ i ] , B [ i ] = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <NL> <DEDENT> S = [ 1 ] * N <NEWLINE> <NL> <NL> for m in range ( M ) <NEWLINE> <INDENT> if H [ A [ m ] - 1 ] == H [ B [ m ] - 1 ] : <NEWLINE> <INDENT> S [ A [ m ] - 1 ] = 0 <NEWLINE> S [ B [ m ] - 1 ] = 0 <NEWLINE> <DEDENT> elif H [ A [ m ] - 1 ] <= H [ B [ m ] - 1 ] : <NEWLINE> <INDENT> S [ A [ m ] - 1 ] = 0 <NEWLINE> <DEDENT> elif H [ A [ m ] - 1 ] >= H [ B [ m ] - 1 ] <NEWLINE> <INDENT> S [ B [ m ] - 1 ] = 0 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> print ( sum ( S ) ) <NEWLINE>
<COMMENT> <NL> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> H = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> count = [ 0 ] * M <NEWLINE> A = [ 0 ] * M <NEWLINE> B = [ 0 ] * M <NEWLINE> <NL> for i in range ( M ) : <NEWLINE> <INDENT> A [ i ] , B [ i ] = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <DEDENT> ans = [ 1 ] * N <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> if H [ A [ i ] - 1 ] == H [ B [ i ] - 1 ] : <NEWLINE> <INDENT> ans [ A [ i ] - 1 ] = 0 <NEWLINE> ans [ B [ i ] - 1 ] = 0 <NEWLINE> <DEDENT> elif H [ A [ i ] - 1 ] > H [ B [ i ] - 1 ] : <NEWLINE> <INDENT> ans [ B [ i ] - 1 ] = 0 <NEWLINE> <DEDENT> elif H [ A [ i ] - 1 ] < H [ B [ i ] - 1 ] : <NEWLINE> <INDENT> ans [ A [ i ] - 1 ] = 0 <NEWLINE> <DEDENT> <DEDENT> print ( sum ( ans ) ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> tmp = [ 1 ] * n <NEWLINE> <NL> ab = [ map ( int , input ( ) . split ( ) ) for _ in range ( M ) ] <NEWLINE> a , b = [ list ( i ) for i in zip ( * ab ) ] <NEWLINE> <NL> for i in range ( m ) : <NEWLINE> <INDENT> if h [ a [ i ] - 1 ] > h [ b [ i ] - 1 ] : <NEWLINE> <INDENT> tmp [ b [ i ] - 1 ] = 0 <NEWLINE> <DEDENT> elif h [ a [ i ] - 1 ] < h [ b [ i ] - 1 ] : <NEWLINE> <INDENT> tmp [ a [ i ] - 1 ] = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> tmp [ a [ i ] - 1 ] = 0 <NEWLINE> tmp [ b [ i ] - 1 ] = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( sum ( tmp ) ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> H_tree = [ 0 ] + [ int ( n ) for n in input ( ) . split ( ) ] <NEWLINE> GOOD_tree = [ 0 ] + [ 1 for n in range ( N ) ] <NEWLINE> <NL> for i in range ( M ) : <NEWLINE> <INDENT> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> if H_tree [ A ] <= H_tree [ B ] : GOOD_Tree [ A ] = 0 <NEWLINE> if H_tree [ A ] >= H_tree [ B ] : GOOD_Tree [ B ] = 0 <NEWLINE> <DEDENT> print ( sum ( GOOD_tree ) ) <NEWLINE>
import numpy as np <NEWLINE> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> AB = [ ] <NEWLINE> H = input ( ) . split ( ) <NEWLINE> Hall = [ 1 ] * N <NEWLINE> <NL> <COMMENT> <NL> for i in range ( M ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> AB . append ( [ a , b ] ) <NEWLINE> AH = H [ a - 1 ] <NEWLINE> BH = H [ b - 1 ] <NEWLINE> if AH >= BH : <NEWLINE> <INDENT> Hall [ b - 1 ] = 0 <NEWLINE> <DEDENT> if BH >= AH : <NEWLINE> <INDENT> Hall [ a - 1 ] = 0 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> print ( Hall . count ( 1 ) ) <NEWLINE> import numpy as np <NEWLINE> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> H = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> adj_max = [ 0 ] * N <NEWLINE> ans = 0 <NEWLINE> for _ in range ( M ) : <NEWLINE> <INDENT> tmp1 , tmp2 = map ( int , input ( ) . split ( ) ) <NEWLINE> adj_max [ tmp1 ] = max ( adj_max [ tmp1 ] , H [ tmp2 ] ) <NEWLINE> adj_max [ tmp2 ] = max ( adj_max [ tmp2 ] , H [ tmp1 ] ) <NEWLINE> <DEDENT> for num in range ( N ) : <NEWLINE> <INDENT> if H [ num ] > adj_max [ num ] : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> h = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> a = [ 0 ] * m <NEWLINE> b = [ 0 ] * m <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> a [ i ] , b [ i ] = map ( int , input ( ) . split ( ) ) <NEWLINE> <DEDENT> ind = [ ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> if h [ a [ i ] - 1 ] < h [ b [ i ] - 1 ] : <NEWLINE> <INDENT> ind . append ( a [ i ] ) <NEWLINE> <DEDENT> elif h [ a [ i ] - 1 ] == h [ b [ i ] - 1 ] : <NEWLINE> <INDENT> ind . append ( a [ i ] ) <NEWLINE> ind . append ( b [ i ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ind . append ( b [ i ] ) <NEWLINE> <DEDENT> <DEDENT> ind2 = [ 0 ] * n <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ind2 [ ind [ i ] - 1 ] += 1 <NEWLINE> <DEDENT> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if ind2 [ i ] == 0 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> H = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> s = [ [ 0 ] for i in range ( n ) ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> s [ a - 1 ] . append ( H [ b - 1 ] ) <NEWLINE> s [ b - 1 ] . append ( H [ a - 1 ] ) <NEWLINE> <DEDENT> c = 0 <NEWLINE> for j in range ( n ) : <NEWLINE> <INDENT> if H [ j ] > max ( s [ j ] ) : <NEWLINE> <INDENT> c += 1 <NEWLINE> print ( c ) <NEWLINE> <DEDENT> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> <COMMENT> <NL> h = list ( int , input ( ) ) <NEWLINE> a = [ 0 ] * m <NEWLINE> b = [ 0 ] * m <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> a [ i ] , b [ i ] = map ( int , input ( ) . split ( ) ) <NEWLINE> <DEDENT> list = [ ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> if h [ a [ i ] - 1 ] > h [ b [ i ] - 1 ] : <NEWLINE> <INDENT> list . append ( a [ i ] ) <NEWLINE> <DEDENT> elif h [ a [ i ] - 1 ] == h [ b [ i ] - 1 ] : <NEWLINE> <INDENT> list . append ( a [ i ] ) <NEWLINE> list . append ( b [ i ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> list . append ( b [ i ] ) <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> listans = [ 0 ] * n <NEWLINE> for i in range ( len ( list ) ) : <NEWLINE> <INDENT> listans [ list [ i ] - 1 ] += 1 <NEWLINE> <DEDENT> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if listans [ i ] == 0 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import numpy as np <NEWLINE> <NL> N , M = [ int ( i ) for i in input ( ) . split ( <STRING> ) ] <NEWLINE> H = [ int ( i ) for i in input ( ) . split ( <STRING> ) ] <NEWLINE> mh = np . zeros ( [ N ] ) <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> a , b = [ int ( i ) - 1 for i in input ( ) . split ( <STRING> ) ] <NEWLINE> mh [ a ] = max ( mh [ a ] , h [ b ] ) <NEWLINE> mh [ b ] = max ( mh [ b ] , h [ a ] ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if mh [ i ] < h [ i ] : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> high = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A = [ 0 ] * N <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> A [ a - 1 ] = max ( A [ a - 1 ] , H [ b - 1 ] ) <NEWLINE> A [ b - 1 ] = max ( A [ b - 1 ] , H [ a - 1 ] ) <NEWLINE> <DEDENT> res = sum ( [ H [ i ] > A [ i ] for i in range ( N ) ] ) <NEWLINE> print ( res ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> H = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> H = [ 0 ] + H <NEWLINE> Tree = [ 0 ] + [ 1 ] * N <NEWLINE> for _ in range ( M ) : <NEWLINE> <INDENT> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> if H [ A ] > H [ B ] : <NEWLINE> <INDENT> Tree [ B ] = 0 <NEWLINE> <DEDENT> elif H [ A ] = H [ B ] : <NEWLINE> <INDENT> Tree [ A ] = 0 <NEWLINE> Tree [ B ] = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> Tree [ A ] = 0 <NEWLINE> <DEDENT> <DEDENT> print ( sum ( Tree ) ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> H = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = list ( range ( 1 , N + 1 ) ) <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> ai , bi = map ( int , input ( ) . split ( ) ) <NEWLINE> if H [ ai - 1 ] <= H [ bi - 1 ] : <NEWLINE> <INDENT> a . remove ( ai ) <NEWLINE> <DEDENT> if H [ ai - 1 ] >= H [ bi - 1 ] : <NEWLINE> <INDENT> a . remove ( bi ) <NEWLINE> <DEDENT> <DEDENT> print ( len ( a ) ) <NEWLINE>
if __name__ == <STRING> : <NEWLINE> <INDENT> list_N_M = input ( ) . split ( <STRING> ) <NEWLINE> N = int ( list_N_M [ 0 ] ) <NEWLINE> M = int ( list_N_M [ 1 ] ) <NEWLINE> <NL> list_str_H_all = input ( ) . split ( <STRING> ) <NEWLINE> H = [ 0.0 ] * N <NEWLINE> for i in range ( len ( list_str_H_all ) ) : <NEWLINE> <INDENT> H [ i ] = float ( list_str_H_all [ i ] ) <NEWLINE> <NL> <DEDENT> is_good_vp = [ True ] * N <NEWLINE> <NL> for _ in range ( M ) : <NEWLINE> <INDENT> str_A_B = input ( ) . split ( <STRING> ) <NEWLINE> A = int ( str_A_B [ 0 ] ) <NEWLINE> B = int ( str_A_B [ 1 ] ) <NEWLINE> <NL> if H [ A - 1 ] > H [ B - 1 ] : <NEWLINE> <INDENT> is_good_vp [ B - 1 ] = False <NEWLINE> <DEDENT> elif H [ B - 1 ] > H [ A - 1 ] : <NEWLINE> <INDENT> is_good_vp [ A - 1 ] = False <NEWLINE> <NL> <DEDENT> <DEDENT> output = 0 <NEWLINE> for i in rabge ( N ) : <NEWLINE> <INDENT> if is_good_vp [ i ] : <NEWLINE> <INDENT> output += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( output ) <NEWLINE> <DEDENT>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> N , M = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> H = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <COMMENT> <NL> from collections import defaultdict <NEWLINE> d = defaultdict ( int ) <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> A , B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A -= 1 <NEWLINE> B -= 1 <NEWLINE> if d [ A ] < H [ B ] : <NEWLINE> <INDENT> d [ A ] = H [ B ] : <NEWLINE> <DEDENT> if d [ B ] < H [ A ] : <NEWLINE> <INDENT> d [ B ] = H [ A ] <NEWLINE> <DEDENT> <DEDENT> cnt = 0 <NEWLINE> for idx , h in enumerate ( H ) : <NEWLINE> <INDENT> if d [ idx ] == 0 or h < d [ idx ] : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( cnt ) <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> height = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> lower_list = [ ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> r = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if height [ r [ 0 ] - 1 ] > height [ r [ 1 ] - 1 ] : <NEWLINE> <INDENT> lower_list . append ( r [ 1 ] ) <NEWLINE> <DEDENT> elif height [ r [ 0 ] - 1 ] < height [ r [ 1 ] - 1 ] : <NEWLINE> <INDENT> lower_list . append ( r [ 0 ] , r [ 1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> lower_list . append ( r [ 0 ] ) <NEWLINE> <DEDENT> <DEDENT> count = len ( set ( lower_list ) ) <NEWLINE> print ( n - count ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> H = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> d = [ ] <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> d . append ( ( A - 1 , B - 1 ) ) <NEWLINE> <NL> <DEDENT> cnt = 0 <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> flag = { } <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> flag [ i ] = True <NEWLINE> <NL> <DEDENT> for i in d : <NEWLINE> <INDENT> A = i [ 0 ] <NEWLINE> B = i [ 1 ] <NEWLINE> <COMMENT> <NL> if H [ A ] > H [ B ] and flag [ A ] == True : <NEWLINE> <COMMENT> <NL> else : <NEWLINE> <INDENT> flag [ A ] = False <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> if H [ B ] > H [ A ] and flag [ B ] == True : <NEWLINE> <COMMENT> <NL> else : <NEWLINE> <INDENT> flag [ B ] = False <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> print ( list ( flag . values ( ) ) . count ( True ) ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> count = [ 1 ] * m <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if h [ a - 1 ] > h [ b - 1 ] : <NEWLINE> <INDENT> count [ b - 1 ] = 0 <NEWLINE> <DEDENT> elif h [ a - 1 ] == h [ b - 1 ] : <NEWLINE> <INDENT> count [ a - 1 ] = 0 <NEWLINE> count [ b - 1 ] = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> count [ b - 1 ] = 0 <NEWLINE> <DEDENT> <DEDENT> print ( sum ( count ) ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <STRING> <NEWLINE> <NL> import sys <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> t = [ 0 ] <NEWLINE> x = [ 0 ] <NEWLINE> y = [ 0 ] <NEWLINE> b = 1 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> t += [ a [ 0 ] ] <NEWLINE> x += [ a [ 1 ] ] <NEWLINE> y += [ a [ 2 ] ] <NEWLINE> <NL> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> if ( x [ i ] - x [ i + 1 ] + y [ i ] - y [ i + 1 ] - t [ i ] + t [ i + 1 ] ) % 2 or ( abs ( x [ i ] - x [ i + 1 ] ) + abs ( y [ i ] - y [ i + 1 ] ) - abs ( t [ i ] - t [ i + 1 ] ) ) > 0 : <NEWLINE> <INDENT> b = 0 <NEWLINE> break <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if b == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> pairs = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( m ) ] <NEWLINE> <NL> ans = [ 1 ] * n <NEWLINE> <NL> for i in range ( m ) : <NEWLINE> <INDENT> if h [ pairs [ i ] [ 0 ] - 1 ] < h [ pairs [ i ] [ 1 ] - 1 ] : <NEWLINE> <INDENT> ans [ pairs [ i ] [ 0 ] - 1 ] = 0 <NEWLINE> <DEDENT> elif h [ pairs [ i ] [ 0 ] - 1 ] = h [ pairs [ i ] [ 1 ] - 1 ] : <NEWLINE> <INDENT> ans [ pairs [ i ] [ 0 ] - 1 ] = 0 <NEWLINE> ans [ pairs [ i ] [ 1 ] - 1 ] = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans [ pairs [ i ] [ 1 ] - 1 ] = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( sum ( ans ) ) <NEWLINE>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ab = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( m ) ] <NEWLINE> <NL> h_max = [ 0 for _ in range ( n ) ] <NEWLINE> for a , b in ab : <NEWLINE> <INDENT> h_max [ a - 1 ] = max ( h_max [ a - 1 ] , h [ b - 1 ] ) <NEWLINE> h_max [ b - 1 ] = max ( h_max [ b - 1 ] , h [ a - 1 ] ) <NEWLINE> <NL> <DEDENT> cnt = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if h [ i ] > h_max : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
from collections import defaultdict <NEWLINE> <NL> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> H = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> graph = defaultdict ( list ) <NEWLINE> for _ in range ( M - 1 ) : <NEWLINE> <INDENT> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> graph [ A ] . append ( H [ B - 1 ] ) <NEWLINE> graph [ B ] . append ( H [ A - 1 ] ) <NEWLINE> <NL> <DEDENT> cnt = 0 <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> t = H [ i - 1 ] <NEWLINE> a = max ( graph [ i ] ) <NEWLINE> if t > a : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> H = list ( map ( int , input ( ) . split ( ) ) <NEWLINE> check = [ 0 ] * N <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> if H [ A - 1 ] > H [ B - 1 ] : <NEWLINE> <INDENT> check [ B - 1 ] = check [ B - 1 ] + 1 <NEWLINE> <DEDENT> elif H [ A - 1 ] < H [ B - 1 ] : <NEWLINE> <INDENT> check [ A - 1 ] = check [ A - 1 ] + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> check [ A - 1 ] += 1 <NEWLINE> check [ B - 1 ] += 1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> ans = check . count ( 0 ) <NEWLINE> <NL> print ( ans ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ab = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( m ) ] <NEWLINE> ans = [ 1 ] * n <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> if h [ ab [ i ] [ 0 ] - 1 ] == h [ ab [ i ] [ 1 ] - 1 ] : <NEWLINE> <INDENT> ans [ ab [ i ] [ 0 ] - 1 ] = 0 <NEWLINE> ans [ ab [ i ] [ 1 ] - 1 ] = 0 <NEWLINE> <DEDENT> elif h [ ab [ i ] [ 0 ] - 1 ] > h [ ab [ i ] [ 1 ] ] : <NEWLINE> <INDENT> ans [ ab [ i ] [ 1 ] - 1 ] = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans [ ab [ i ] [ 0 ] - 1 ] = 0 <NEWLINE> <DEDENT> <DEDENT> print ( sum ( ans ) ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> wxyz = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in [ 0 ] * m ] <NEWLINE> <NL> class unionfind ( ) : <NEWLINE> <COMMENT> <NL> <INDENT> def __init__ ( self , size ) : <COMMENT> <NEWLINE> <INDENT> self . size = size <NEWLINE> self . tree_root = list ( range ( self . size ) ) <NEWLINE> self . tree_depth = [ 1 ] * self . size <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> def root ( self , index ) : <NEWLINE> <INDENT> temp_list = [ ] <NEWLINE> temp = self . tree_root [ index ] <NEWLINE> while index != temp : <NEWLINE> <INDENT> temp_list . append ( index ) <NEWLINE> index = temp <NEWLINE> temp = self . tree_root [ index ] <NEWLINE> <DEDENT> for i in temp_list : <NEWLINE> <INDENT> self . tree_root [ i ] = index <NEWLINE> <DEDENT> return index <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> def unite ( self , index1 , index2 ) : <NEWLINE> <INDENT> r1 = self . root ( index1 ) <NEWLINE> r2 = self . root ( index2 ) <NEWLINE> if r1 != r2 : <NEWLINE> <INDENT> d1 , d2 = self . tree_depth [ r1 ] , self . tree_depth [ r2 ] <NEWLINE> if d1 <= d2 : <NEWLINE> <INDENT> self . tree_root [ r1 ] = r2 <NEWLINE> self . tree_depth [ r2 ] = max ( d1 + 1 , d2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . tree_root [ r2 ] = r1 <NEWLINE> self . tree_depth [ r1 ] = max ( d2 + 1 , d1 ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> def same ( self , index1 , index2 ) : <NEWLINE> <INDENT> r1 = self . root ( index1 ) <NEWLINE> r2 = self . root ( index2 ) <NEWLINE> return r1 == r2 <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> def component ( self ) : <NEWLINE> <INDENT> return len ( { self . root ( i ) for i in range ( self . size ) } ) <NEWLINE> <NL> <DEDENT> <DEDENT> u = unionfind ( 2 * n ) <NEWLINE> <NL> for w , x , y , z in wxyz : <NEWLINE> <INDENT> x -= 1 <NEWLINE> y -= 1 <NEWLINE> if w == 1 : <NEWLINE> <INDENT> if z % 2 == 0 : <NEWLINE> <INDENT> u . unite ( x , y ) <NEWLINE> u . unite ( x + n , y + n ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> u . unite ( x , y + n ) <NEWLINE> u . unite ( x + n , y ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( [ <STRING> , <STRING> ] [ u . same ( x , y ) or u . same ( x + n , y + n ) ] ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> main ( ) <NEWLINE>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> def ppp ( n , m , h , ab ) : <NEWLINE> <INDENT> g = [ 1 ] * n <NEWLINE> for l , r in ab : <NEWLINE> <INDENT> if h [ l - 1 ] >= h [ r - 1 ] : <NEWLINE> <INDENT> g [ r - 1 ] = 0 <NEWLINE> <DEDENT> if h [ l - 1 ] <= h [ r - 1 ] : <NEWLINE> <INDENT> g [ l - 1 ] = 0 <NEWLINE> <DEDENT> <DEDENT> print ( sum ( g ) ) <NEWLINE> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ab = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( m ) ] <NEWLINE> ppp ( n , m , h , ab_sorted ) <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = [ 1 ] * n <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if h [ a - 1 ] > h [ b - 1 ] : <NEWLINE> <INDENT> ans [ b - 1 ] = 0 <NEWLINE> <DEDENT> else if h [ b - 1 ] > h [ a - 1 ] : <NEWLINE> <INDENT> ans [ a - 1 ] = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> ans [ a - 1 ] = 0 <NEWLINE> ans [ b - 1 ] = 0 <NEWLINE> <DEDENT> <DEDENT> print ( ans . count ( 1 ) ) <NEWLINE>
import numpy as np <NEWLINE> X = int ( input ( ) ) <NEWLINE> flag = 1 <NEWLINE> for c in range ( np . power ( 10 , 9 ) ) : <NEWLINE> <INDENT> c += 1 <NEWLINE> x = X <NEWLINE> if x % c == 0 : <NEWLINE> <INDENT> x = x // c <NEWLINE> for a in range ( np . power ( 10 , 3 ) ) : <NEWLINE> <INDENT> if ( np . power ( a , 4 ) + np . power ( a , 3 ) * ( a - c ) + np . power ( a , 2 ) * np . power ( a - c , 2 ) + a * np . power ( a - c , 3 ) + np . power ( a - c , 4 ) ) == x : <NEWLINE> <INDENT> print ( a , a - c ) <NEWLINE> flag = 0 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if flag == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> H_tree = map ( int , input ( ) . split ( ) ) <NEWLINE> GOOD_Tree = [ 1 for n in range ( len ( H_tree ) ) ] <NEWLINE> <NL> for n i in range ( M ) : <NEWLINE> <INDENT> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> if H_tree [ A - 1 ] >= H_tree [ B - 1 ] : <NEWLINE> <INDENT> GOOD_tree [ A - 1 ] = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> GOOD_tree [ B - 1 ] = 0 <NEWLINE> <DEDENT> <DEDENT> print ( GOOD_tree . count ( 1 ) ) <NEWLINE>
<COMMENT> <NL> <STRING> <NEWLINE> <NL> import sys <NEWLINE> <COMMENT> <NL> <NL> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> mod = 10 ** 9 + 7 <NEWLINE> <NL> X = int ( input ( ) ) <NEWLINE> <NL> for i in range ( - 2000 , 2001 ) : <NEWLINE> <INDENT> for j in range ( - 2000 , 2001 ) : <NEWLINE> <INDENT> if pow ( i , 5 ) - pow ( j , 5 ) == X : <NEWLINE> <INDENT> print ( i , j ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT>
x = int ( input ( ) ) <NEWLINE> n = 100 <NEWLINE> tes = [ 0 ] <NEWLINE> for i in range ( - 10001 , 10001 ) : <NEWLINE> <INDENT> for j in range ( - 10001 , 10001 ) : <NEWLINE> <INDENT> if pow ( i , 5 ) - pow ( j , 5 ) == x : <NEWLINE> <INDENT> print ( str ( i ) + <STRING> + str ( j ) ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
X = int ( input ( ) ) <NEWLINE> for A in range ( - 120 , 120 ) : <NEWLINE> <INDENT> for B in range ( - 120 , 120 ) : <NEWLINE> <INDENT> if A ** 5 - B ** 5 == X : <NEWLINE> <INDENT> print ( A , B ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
x = int ( input ( ) ) <NEWLINE> c = 0 <NEWLINE> while c - x : i = c % 120 ; j = c % 217 - 98 ; c = i ** 5 - j ** 5 <NEWLINE> print ( i , j ) <NEWLINE>
<NL> <STRING> <NEWLINE> import numpy as np <NEWLINE> <NL> <NL> n = int ( input ( ) ) <NEWLINE> x = n <NEWLINE> pf = { } <NEWLINE> for i in range ( 2 , int ( n ** 0.5 ) + 1 ) : <NEWLINE> <INDENT> while n % i == 0 : <NEWLINE> <INDENT> pf [ i ] = pf . get ( i , 0 ) + 1 <NEWLINE> n //= i <NEWLINE> <DEDENT> <DEDENT> if n > 1 : pf [ n ] = 1 <NEWLINE> <NL> from decimal import Decimal <NEWLINE> <COMMENT> <NL> lis = [ ] <NEWLINE> for b in range ( - 1000000 , 1000000 ) : <NEWLINE> <INDENT> a = b + int ( list ( pf . keys ( ) ) [ 0 ] ) <NEWLINE> siki = Decimal ( a ** 4 + a ** 3 * b + a ** 2 * b ** 2 + a * b ** 3 + b ** 4 ) <NEWLINE> if siki == Decimal ( x / int ( list ( pf . keys ( ) ) [ 0 ] ) ) : <NEWLINE> <INDENT> lis . append ( ( a , b ) ) <NEWLINE> <DEDENT> <DEDENT> print ( * lis [ 0 ] ) <NEWLINE>
x = int ( input ( ) ) <NEWLINE> a = 0 <NEWLINE> b = 0 <NEWLINE> t = 0 <NEWLINE> while a ** 5 < x : <NEWLINE> <INDENT> while b ** 5 < x : <NEWLINE> <INDENT> if a ** + b ** 5 == x : <NEWLINE> <INDENT> print ( a , - b ) <NEWLINE> t = 1 <NEWLINE> break <NEWLINE> <DEDENT> b += 1 <NEWLINE> <DEDENT> if t == 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> a += 1 <NEWLINE> <DEDENT> if t == 0 : <NEWLINE> <INDENT> for i in range ( a + 1 , 10 ** 3 ) : <NEWLINE> <INDENT> for j in range ( 10 ** 3 ) : <NEWLINE> <INDENT> if i ** 5 - j ** 5 == x : <NEWLINE> print ( i , j ) <NEWLINE> t = 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if t == 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> h_l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> cnt = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> h_i = h_l [ i ] <NEWLINE> cnt += sum ( [ 1 for j in range ( i , n ) if ( ( j - i ) == ( h_l [ j ] + h_i ) ) ] ) <NEWLINE> <NL> <NL> <DEDENT> print ( cnt ) <NEWLINE>
import collections <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> X = int ( input ( ) ) <NEWLINE> A , B = 0 , 0 <NEWLINE> for i in range ( - 120 , 120 ) : <NEWLINE> <INDENT> if A == 0 and B == 0 : <NEWLINE> <INDENT> for j in range ( - 120 , 120 ) : <NEWLINE> <INDENT> if i ** 5 - j ** 5 = X : <NEWLINE> <INDENT> A , B = i , j <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> . format ( A , B ) ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
X = int ( input ( ) ) <NEWLINE> for i in range ( - 3000 , 3000 ) : <NEWLINE> <INDENT> for j in range ( - 3000 , 3000 ) : <NEWLINE> <INDENT> if X == ( i ** 5 - j ** 5 ) : <NEWLINE> <INDENT> print ( i , j ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def get_answer ( ) : <NEWLINE> <INDENT> x = int ( input ( ) ) <NEWLINE> <NL> is_get = False <NEWLINE> for a in range ( 1000000000 ) : <NEWLINE> <INDENT> if is_get : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for b in range ( - 1 * a , a , 1 ) : <NEWLINE> <INDENT> if x == a ** 5 - b ** 5 : <NEWLINE> <INDENT> is_get = True <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> if __name__ = <STRING> : <NEWLINE> <INDENT> get_answer ( ) <NEWLINE> <DEDENT>
X = int ( input ( ) ) <NEWLINE> <NL> flag = 0 <NEWLINE> A = 0 <NEWLINE> B = 0 <NEWLINE> <NL> for i in range ( 0 , 100000 ) : <NEWLINE> <INDENT> for j in range ( 0 , i ) : <NEWLINE> <INDENT> if i ** 5 - j ** 5 == X : <NEWLINE> <INDENT> A = i <NEWLINE> B = j <NEWLINE> break <NEWLINE> <DEDENT> elif i ** 5 + j ** 5 == X : <NEWLINE> <INDENT> A = i <NEWLINE> B = j <NEWLINE> break <NEWLINE> <DEDENT> elif - i ** 5 - j ** 5 == X : <NEWLINE> <INDENT> A = - i <NEWLINE> B = j <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( str ( A ) + <STRING> + str ( B ) ) <NEWLINE>
<NL> x = int ( input ( ) ) <NEWLINE> for a in range ( 1 , 100 ) : <NEWLINE> <INDENT> a_5 = a ** 5 <NEWLINE> <NL> if a_5 > x : <NEWLINE> <INDENT> b = 1 <NEWLINE> s = 0 <NEWLINE> while s > x : <NEWLINE> <INDENT> s = a_5 - b ** 5 <NEWLINE> if s == x : <NEWLINE> <INDENT> print ( a , b ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> b += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> elif a_5 < x : <NEWLINE> <INDENT> b = - 1 <NEWLINE> s = 0 <NEWLINE> while s < x : <NEWLINE> <INDENT> s = a_5 - b ** 5 <NEWLINE> if s == x : <NEWLINE> <INDENT> print ( a , b ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> b -= 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( a , 0 ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT>
<INDENT> - * - coding : utf - 8 - * - <NEWLINE> <DEDENT> import math <NEWLINE> import sys <NEWLINE> <NL> X = int ( input ( ) ) <NEWLINE> <NL> for A in range ( - 118 , 190 ) : <NEWLINE> <INDENT> for B in range ( - 119 , 119 ) : <NEWLINE> <INDENT> val = math . pow ( A , 5 ) - math . pow ( B , 5 ) <NEWLINE> if ( val == X ) : <NEWLINE> <INDENT> print ( A , B ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def make_divisors ( n ) : <NEWLINE> <INDENT> divisors = [ ] <NEWLINE> for i in range ( 1 , int ( n ** 0.5 ) + 1 ) : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> divisors . append ( i ) <NEWLINE> if i != n // i : <NEWLINE> <INDENT> divisors . append ( n // i ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> divisors . sort ( ) <NEWLINE> return divisors <NEWLINE> <NL> <DEDENT> x = int ( input ( ) ) <NEWLINE> a = 0 <NEWLINE> b = 0 <NEWLINE> flag = False <NEWLINE> for i in range ( 10 ** 7 ) : <NEWLINE> <INDENT> tmp = ( ( x + i ** 5 ) ** ( 1 / 5 ) ) . real <NEWLINE> if tmp . is_integer ( ) : <NEWLINE> <INDENT> b = i <NEWLINE> a = x + b ** 5 <NEWLINE> flag = True <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if flag == False : <NEWLINE> <INDENT> for i in range ( - 10 ** 7 , 0 ) : <NEWLINE> <INDENT> tmp = ( ( x + i ** 5 ) ** ( 1 / 5 ) ) . real <NEWLINE> if tmp . is_integer ( ) : <NEWLINE> <INDENT> b = i <NEWLINE> a = x + b ** 5 <NEWLINE> flag = True <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( int ( a ) , int ( b ) ) <NEWLINE>
x = int ( input ( ) ) <NEWLINE> b_p = 0 <NEWLINE> b_m = 0 <NEWLINE> <NL> def div ( n ) : <NEWLINE> <INDENT> divs = [ ] <NEWLINE> for i in range ( 1 , int ( n ** 0.5 ) + 1 ) : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> divs . append ( i ) <NEWLINE> if i != n // i : <NEWLINE> <INDENT> divs . append ( n // i ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> divs <NEWLINE> divs += list ( map ( lambda x : x * ( - 1 ) , divs ) ) <NEWLINE> return divs <NEWLINE> <NL> <DEDENT> divs = div ( x ) <NEWLINE> while True : <NEWLINE> <INDENT> for i in divs : <NEWLINE> <INDENT> a_p = i + b_p <NEWLINE> a_m = i + b_m <NEWLINE> if a_p ** 5 == x + b_p ** 5 : <NEWLINE> <INDENT> print ( a_p , b_p ) <NEWLINE> exit ( 1 ) <NEWLINE> <DEDENT> if a_m ** 5 == x + b_m ** 5 : <NEWLINE> <INDENT> print ( a_m , b_m ) <NEWLINE> exit ( 1 ) <NEWLINE> <DEDENT> <DEDENT> b_p += 1 <NEWLINE> b_m -= 1 <NEWLINE> <DEDENT>
from itertools import product <NEWLINE> <NL> x = int ( input ( ) ) <NEWLINE> num = [ i ** 5 for i in range ( - 1000 , 1000 ) ] <NEWLINE> <NL> for a , b in product ( num , repeat = 2 ) : <NEWLINE> <INDENT> if a - b == x : <NEWLINE> <INDENT> print ( int ( a ** 0.2 ) , int ( b ** 0.2 ) ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT>
X = int ( input ( ) ) <NEWLINE> <NL> import sys <NEWLINE> <NL> for i in range ( 1 , 10 ** 9 + 1 ) : <NEWLINE> <INDENT> a = pow ( i , 5 ) <NEWLINE> f_i = pow ( a - X , 0.2 ) <NEWLINE> if f_i . is_integer ( ) == True : <NEWLINE> <INDENT> print ( i , pow ( a - X , 0.2 ) ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT>
X = int ( input ( ) ) <NEWLINE> def make_divisors ( n ) : <NEWLINE> <INDENT> divisors = [ ] <NEWLINE> for i in range ( 1 , int ( n ** 0.5 ) + 1 ) : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> divisors . append ( i ) <NEWLINE> if i != n // i : <NEWLINE> <INDENT> divisors . append ( n // i ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> return divisors <NEWLINE> <DEDENT> L = make_divisors ( X ) <NEWLINE> <COMMENT> <NL> Y = False <NEWLINE> ans = [ ] <NEWLINE> for x in L : <NEWLINE> <INDENT> a = 0 <NEWLINE> while True : <NEWLINE> <INDENT> tmp = a ** 5 - ( a - x ) ** 5 <NEWLINE> if tmp == X : <NEWLINE> <INDENT> Y = True <NEWLINE> ans = [ a , a - x ] <NEWLINE> break <NEWLINE> <DEDENT> if tmp > X : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> a += 1 <NEWLINE> <COMMENT> <NL> <DEDENT> if Y : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> print ( ans [ 0 ] , ans [ 1 ] ) <NEWLINE>
a = int ( input ( ) ) <NEWLINE> for i in range ( - 1000 , 1000 ) : <NEWLINE> <INDENT> for j in range ( - 1000 , 1000 ) : <NEWLINE> <INDENT> if i ** 5 - j ** 5 == a : <NEWLINE> <INDENT> print ( i , j ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
X = int ( input ( ) ) <NEWLINE> a = [ ] <NEWLINE> b = 0 <NEWLINE> flag = True <NEWLINE> for i in range ( 1 , int ( X ** ( 1 / 5 ) ) + 1 ) : <NEWLINE> <INDENT> if ( X % i == 0 ) : <NEWLINE> <INDENT> a . append ( i ) <NEWLINE> <DEDENT> <DEDENT> while ( flag ) : <NEWLINE> <INDENT> for i in range ( len ( a ) ) : <NEWLINE> <INDENT> if ( pow ( b + a [ i ] , 5 ) - pow ( b , 5 ) == X ) : <NEWLINE> <INDENT> print ( <STRING> % ( b + a [ i ] , b ) ) <NEWLINE> flag = False <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> b -= 1 <NEWLINE> if ( - pow ( b , 5 ) > X ) : <NEWLINE> <INDENT> b = int ( X ** ( 1 / 5 ) ) <NEWLINE> <DEDENT> <DEDENT>
X = int ( input ( ) ) <NEWLINE> pow5 = [ pow ( i , 5 ) for i in range ( - 150 , 150 ) ] <NEWLINE> for a in range ( - 150 , 150 ) : <NEWLINE> <INDENT> for b in range ( - 150 , 150 ) : <NEWLINE> <INDENT> if pow5 [ a + 150 ] + pow [ b + 150 ] == X : <NEWLINE> <INDENT> print ( a , b ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
x = int ( input ( ) ) <NEWLINE> for a in range ( 101. - 101 , - 1 ) : <NEWLINE> <INDENT> for b in range ( - 101 , 101 , 1 ) : <NEWLINE> <INDENT> if x == a ** 5 - b ** 5 : <NEWLINE> <INDENT> print ( a , b ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
x = int ( input ( ) ) <NEWLINE> <NL> y = 1000 <NEWLINE> s = - 1000 <NEWLINE> t = - 1000 <NEWLINE> <NL> a = 0 <NEWLINE> b = 0 <NEWLINE> <NL> while s < y : <NEWLINE> <INDENT> t = - y <NEWLINE> while t < y : <NEWLINE> <INDENT> if s ** 5 - t ** 5 == x : <NEWLINE> <INDENT> a = int ( s ) <NEWLINE> b = int ( t ) <NEWLINE> <DEDENT> t += 1 <NEWLINE> <DEDENT> s += 1 <NEWLINE> <NL> <DEDENT> print ( a , b ) <NEWLINE> <NL> <NL> <NL> <NL>
def main ( ) : <NEWLINE> <INDENT> print ( * solve ( ) ) <NEWLINE> <NL> <NL> <DEDENT> def solve ( ) : <NEWLINE> <INDENT> X = int ( input ( ) ) <NEWLINE> N = 10 ** 9 + 7 <NEWLINE> <NL> step = 2 if X % 2 else step = 1 <COMMENT> <NEWLINE> <NL> for x in range ( 1 , N , step ) : <COMMENT> <NEWLINE> <INDENT> if X % x : <COMMENT> <NEWLINE> <INDENT> continue <NEWLINE> <NL> <DEDENT> for a in range ( N ) : <NEWLINE> <INDENT> b = a - x <NEWLINE> <NL> diff = X - ( a ** 5 - b ** 5 ) <NEWLINE> if diff == 0 : <NEWLINE> <INDENT> return a , b <NEWLINE> <NL> <DEDENT> if diff < 0 < b : <NEWLINE> <INDENT> break <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
x = int ( input ( ) ) <NEWLINE> <NL> for a in range ( 10 ** 4 ) : <NEWLINE> <INDENT> for b in range ( 10 ** 4 ) : <NEWLINE> <INDENT> if ( a ** 5 + b ** 5 == x ) : <NEWLINE> <INDENT> print ( a , - b ) <NEWLINE> break <NEWLINE> <DEDENT> elif ( a ** 5 - b ** 5 == x ) : <NEWLINE> <INDENT> print ( a , b ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
X = int ( input ( ) ) <NEWLINE> C = 0 <NEWLINE> for i in range ( - 10000 , 10000 ) : <NEWLINE> <INDENT> if C == 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for j in range ( - 10000 , 10000 ) : <NEWLINE> <INDENT> if i ** 5 - j ** 5 == X : <NEWLINE> <INDENT> print ( i , j ) <NEWLINE> C += 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
x = int ( input ( ) ) <NEWLINE> A = [ i ** 5 for _ in range ( 1500 ) ] <NEWLINE> for i in range ( 1500 ) : <NEWLINE> <INDENT> for j in range ( 1500 ) : <NEWLINE> <INDENT> if A [ i ] == x + A [ j ] : <NEWLINE> <INDENT> print ( A [ i ] , A [ j ] ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
for x in itertools . combinations ( X_list , 2 ) : <NEWLINE> <INDENT> if x [ 0 ] - x [ 1 ] == ans : <NEWLINE> <INDENT> a = abs ( x [ 0 ] ** ( 1 / 5 ) ) <NEWLINE> b = abs ( x [ 1 ] ** ( 1 / 5 ) ) <NEWLINE> if x [ 0 ] < 0 : <NEWLINE> <INDENT> a = a * ( - 1 ) <NEWLINE> <DEDENT> if x [ 1 ] < 0 : <NEWLINE> <INDENT> b = b * ( - 1 ) <NEWLINE> <COMMENT> <NL> <DEDENT> print ( int ( a ) , int ( b ) ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> if x [ 1 ] - x [ 0 ] == ans : <NEWLINE> <INDENT> a = abs ( x [ 1 ] ** ( 1 / 5 ) ) <NEWLINE> b = abs ( x [ 0 ] ** ( 1 / 5 ) ) <NEWLINE> if x [ 1 ] < 0 : <NEWLINE> <INDENT> a = a * ( - 1 ) <NEWLINE> <DEDENT> if x [ 0 ] < 0 : <NEWLINE> <INDENT> b = b * ( - 1 ) <NEWLINE> <COMMENT> <NL> <DEDENT> print ( int ( a ) , int ( b ) ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT>
m = 5 ** 6 <NEWLINE> exec ( <STRING> * 2 * m ) <NEWLINE>
x = int ( input ( ) ) <NEWLINE> <NL> a = int ( x ** ( 1 / 5 ) ) <NEWLINE> b = - 150 <NEWLINE> <NL> flag = 0 <NEWLINE> if flag == 0 : <NEWLINE> <INDENT> for i in range ( a , a + 2000 ) : <NEWLINE> <INDENT> for j in range ( b , b + 2000 ) : <NEWLINE> <INDENT> if i ** 5 - j ** 5 == x : <NEWLINE> <INDENT> print ( i , j ) <NEWLINE> flag = 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if flag == 0 : <NEWLINE> <INDENT> b = 0 <NEWLINE> for i in range ( a , a - 2000 ) : <NEWLINE> <INDENT> for j in range ( b , b - 2000 ) : <NEWLINE> <INDENT> if i ** 5 - j ** 5 == x : <NEWLINE> <INDENT> print ( i , j ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT>
x = int ( input ( <STRING> ) ) <NEWLINE> <NL> can = [ ] <NEWLINE> for a in range ( 10 ** 4 ) : <NEWLINE> <INDENT> if not a in can : <NEWLINE> <INDENT> can . append ( a ** 5 ) <NEWLINE> <NL> <DEDENT> <DEDENT> result = [ ] <NEWLINE> for a in can : <NEWLINE> <INDENT> for b in can : <NEWLINE> <INDENT> if a - b == x : <NEWLINE> <INDENT> ans = <STRING> . format ( int ( a ** ( 1 / 5 ) ) , int ( b ** ( 1 / 5 ) ) ) <NEWLINE> if not ans in result : <NEWLINE> <INDENT> result . append ( ans ) <NEWLINE> <DEDENT> <DEDENT> if a + b == x and a > b : <NEWLINE> <INDENT> ans = <STRING> . format ( int ( a ** ( 1 / 5 ) ) , int ( - 1 * b ** ( 1 / 5 ) ) ) <NEWLINE> if not ans in result : <NEWLINE> <INDENT> result . append ( ans ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for r in result : <NEWLINE> <INDENT> print ( r ) <NEWLINE> <DEDENT>
x = int ( input ( ) ) <NEWLINE> for i in range ( - 1000 , 1000 ) : <NEWLINE> <INDENT> for j in range ( - 1000 , 1000 ) : <NEWLINE> <INDENT> if i ** 5 - j ** 5 == x : <NEWLINE> <INDENT> print ( i , j ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
x = int ( input ( ) ) <NEWLINE> judeg = 0 <NEWLINE> for i in range ( - 200 , 200 ) : <NEWLINE> <INDENT> for j in range ( - 200 , 200 ) : <NEWLINE> <INDENT> if ( i ** 5 - j ** 5 == x ) : <NEWLINE> <INDENT> print ( i , j ) <NEWLINE> judge += 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if ( judge == 1 ) : <NEWLINE> <INDENT> break <NEWLINE> <NL> <NL> <DEDENT> <DEDENT>
X = int ( input ( ) ) <NEWLINE> l = [ ] <NEWLINE> for i in range ( 300 ) : <NEWLINE> <INDENT> a = i ** 5 <NEWLINE> l . append ( a ) <NEWLINE> l . append ( - a ) <NEWLINE> <DEDENT> for j in l : <NEWLINE> <INDENT> for s in l : <NEWLINE> <INDENT> if j - s == X and j != s : <NEWLINE> <INDENT> ans = [ ] <NEWLINE> for i in [ j , s ] : <NEWLINE> <INDENT> aaa = abs ( i ) ** ( 1 / 5 ) <NEWLINE> if i >= 0 : <NEWLINE> <INDENT> ans . append ( int ( aaa ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans . append ( - aaa ) <NEWLINE> <DEDENT> <DEDENT> print ( * ans ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
x = int ( input ( ) ) <NEWLINE> <NL> a = 0 <NEWLINE> while ( True ) : <NEWLINE> <INDENT> a5 = a ** 5 <NEWLINE> b = x - a5 <NEWLINE> b = int ( x ** ( 1 / 5 ) ) <NEWLINE> b5 = b ** 5 <NEWLINE> if a5 - b5 == x : <NEWLINE> <INDENT> break <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> b = x + a5 <NEWLINE> b = int ( x ** ( 1 / 5 ) ) <NEWLINE> b5 = b ** 5 <NEWLINE> if a5 - b5 == x : <NEWLINE> <INDENT> a *= - 1 <NEWLINE> break <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> a += 1 <NEWLINE> <DEDENT> print ( a , b ) <NEWLINE>
X = int ( input ( ) ) <NEWLINE> <NL> for A in range ( 100 ) : <NEWLINE> <INDENT> for B in range ( - 50 , 50 ) : <NEWLINE> <INDENT> if A ** 5 - B ** 5 == X : <NEWLINE> <INDENT> print ( A , B ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
x = int ( input ( ) ) <NEWLINE> a = [ ] <NEWLINE> for i in range ( 220 ) : <NEWLINE> <INDENT> a . append [ i ** 5 ] <NEWLINE> <DEDENT> for i in range ( 220 ) : <NEWLINE> <INDENT> y = x - a [ i ] <NEWLINE> if y in a : <NEWLINE> <INDENT> print ( i , a . index ( y ) ) <NEWLINE> break <NEWLINE> <DEDENT> elif - y in a : <NEWLINE> <INDENT> print ( i , - a . index ( y ) ) <NEWLINE> <DEDENT> <DEDENT>
X = int ( input ( ) ) <NEWLINE> <NL> for i in range ( 10 ** 9 ) : <NEWLINE> <INDENT> if i ** 5 - ( X - i ) ** 5 == X : <NEWLINE> <INDENT> print ( i , X - i ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT>
X = int ( input ( ) ) <NEWLINE> import sys <NEWLINE> for a in range ( - 118 , 120 , 1 ) : <NEWLINE> <INDENT> for b in range ( - 119 , 119 , 1 ) : <NEWLINE> <INDENT> if x == pow ( a , 5 ) - pow ( b , 5 ) : <NEWLINE> <INDENT> print ( x ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
import sys <NEWLINE> import math <NEWLINE> from collections import Counter <NEWLINE> import itertools <NEWLINE> import fractions <NEWLINE> <COMMENT> <NL> <NL> <COMMENT> <NL> def II ( ) : return int ( sys . stdin . readline ( ) ) <NEWLINE> def MI ( ) : return map ( int , sys . stdin . readline ( ) . split ( ) ) <NEWLINE> def MI1 ( ) : return map ( int1 , sys . stdin . readline ( ) . split ( ) ) <NEWLINE> <COMMENT> <NL> def LI ( ) : return list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) <NEWLINE> <COMMENT> <NL> def LLI ( rows_number ) : return [ LI ( ) for _ in range ( rows_number ) ] <NEWLINE> def SR ( ) : return sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> <NL> ascii_lowercase = <STRING> <NEWLINE> ascii_uppercase = <STRING> <NEWLINE> ascii_uppercase2 = <STRING> <NEWLINE> <NL> <COMMENT> <NL> p2D = lambda x : print ( * x , sep = <STRING> ) <NEWLINE> p2E = lambda x : print ( <STRING> . join ( x ) ) <NEWLINE> p2S = lambda x : print ( * x , sep = <STRING> ) <NEWLINE> <NL> <COMMENT> <NL> <NL> <NL> X = II ( ) <NEWLINE> <NL> for i in range ( 0 , 1000000 ) : <NEWLINE> <INDENT> for j in range ( - 1000000 , 1000000 ) : <NEWLINE> <INDENT> if i ** 5 - j ** 5 == X : <NEWLINE> <INDENT> print ( i , j ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
X = int ( input ( ) ) <NEWLINE> cnt = 0 <NEWLINE> for a in range ( - 1000 , 1001 ) : <NEWLINE> <INDENT> for b in range ( - 1000 , 1001 ) : <NEWLINE> <INDENT> if a ** 5 - b ** 5 == X : <NEWLINE> <INDENT> print ( <STRING> + <STRING> ) <NEWLINE> <INDENT> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT>
N , K = map ( int , input ( ) . strip ( ) . split ( <STRING> ) ) ; <NEWLINE> <NL> arr = [ 1 for x in range ( N ) ] ; <NEWLINE> for x in range ( K ) : <NEWLINE> <INDENT> r = input ( ) ; <NEWLINE> for x in map ( int , input ( ) . strip ( ) . split ( <STRING> ) ) : <NEWLINE> <INDENT> arr [ x - 1 ] = 0 ; <NEWLINE> <DEDENT> <DEDENT> print ( sum ( arr ) ) ; <NEWLINE>
x = int ( input ( ) ) <NEWLINE> n = 0 <NEWLINE> for i in range ( 100 ) : <NEWLINE> <INDENT> d [ 0 ] [ i ] = i ** 5 <NEWLINE> d [ i ] [ 0 ] = i ** 5 <NEWLINE> if i ** 5 == x : <NEWLINE> <INDENT> n = i <NEWLINE> <DEDENT> <DEDENT> if n != 0 : <NEWLINE> <INDENT> print ( n , 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( 1 , 100 ) : <NEWLINE> <INDENT> for j in range ( 1 , 100 ) : <NEWLINE> <INDENT> d [ i ] [ j ] = d [ 0 ] [ j ] + d [ i ] [ 0 ] <NEWLINE> if d [ i ] [ j ] > x : <NEWLINE> <INDENT> n = i <NEWLINE> break <NEWLINE> <DEDENT> elif d [ i ] [ j ] == x : <NEWLINE> <INDENT> print ( i , - j ) <NEWLINE> n = i <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if n == i : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
res = { } <NEWLINE> for i in range ( - 1000 , 1000 ) : <NEWLINE> <INDENT> for j in range ( - 1000 , 1000 ) : <NEWLINE> <INDENT> ans = i ** 5 - j ** 5 <NEWLINE> res [ ans ] = ( i , j ) <NEWLINE> <DEDENT> <DEDENT> n = int ( input ( ) ) <NEWLINE> print ( res [ n ] [ 0 ] , res [ n ] [ 1 ] ) <NEWLINE>
if __name__ == <STRING> : <NEWLINE> <INDENT> a = int ( input ( ) ) <NEWLINE> ansdict = { } <NEWLINE> count = 100000 <NEWLINE> mcount = 100000 * - 1 <NEWLINE> <NL> for i in range ( 0 , 100000 ) : <NEWLINE> <INDENT> c = i ** 5 <NEWLINE> ansdict [ i ] = c <NEWLINE> ansdict [ i * - 1 ] = c * - 1 <NEWLINE> <DEDENT> flag = 0 <NEWLINE> <NL> for i in range ( mcount , count ) : <NEWLINE> <INDENT> for j in range ( mcount , count ) : <NEWLINE> <INDENT> ans = ansdict [ j ] - ansdict [ i ] <NEWLINE> if ans == a : <NEWLINE> <INDENT> print ( str ( j ) + <STRING> + str ( i ) ) <NEWLINE> flag += 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if flag == 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
from numba import jit <NEWLINE> import math <NEWLINE> X = int ( input ( ) ) <NEWLINE> <NL> <NL> @ jit <NEWLINE> def solver ( X ) : <NEWLINE> <INDENT> sol = [ ] <NEWLINE> i = 2 <NEWLINE> while i <= math . sqrt ( X ) + 1 : <NEWLINE> <INDENT> if X % i == 0 : <NEWLINE> <INDENT> sol . append ( i ) <NEWLINE> <DEDENT> i += 1 <NEWLINE> <DEDENT> return sol <NEWLINE> <NL> <NL> <DEDENT> if X == 1 : <NEWLINE> <INDENT> print ( 0 , - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> sol = solver ( X ) <NEWLINE> <NL> <NL> for i in sol : <NEWLINE> <INDENT> for s in range ( - 130 130 ) : <NEWLINE> <INDENT> t = s - i <NEWLINE> if s ** 5 - t ** 5 == X : <NEWLINE> <INDENT> print ( s , t ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
x = int ( input ( ) ) <NEWLINE> <NL> for i in range ( - 1 , 10000 ) : <NEWLINE> <INDENT> for j in range ( - 1 , 10000 ) : <NEWLINE> <INDENT> if ( i ** 5 - j ** 5 ) == x : <NEWLINE> <INDENT> print ( i , j ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
x = int ( input ( ) ) <NEWLINE> a = 0 <NEWLINE> b = 0 <NEWLINE> for i in range ( - 1000 , 1000 ) : <NEWLINE> <INDENT> for j in range ( - 1000 , 1000 ) : <NEWLINE> <INDENT> if ( i ** 5 ) - ( j ** 5 ) == x : <NEWLINE> <INDENT> a = i <NEWLINE> b = j <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> . format ( a , b ) ) <NEWLINE>
def main ( x ) : <NEWLINE> <INDENT> for i in range ( 100 ) : <NEWLINE> <INDENT> for j in range ( 100 ) : <NEWLINE> <INDENT> if ( i ** 5 - j ** 5 == x ) : <NEWLINE> <INDENT> print ( str ( i ) + <STRING> + str ( j ) ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if __name__ = <STRING> : <NEWLINE> <INDENT> main ( input ( ) ) <NEWLINE> <DEDENT>
x = int ( input ( ) ) <NEWLINE> for i in range ( - 200 , 201 ) : <NEWLINE> <INDENT> for j in range ( - 200 , 201 ) : <NEWLINE> <INDENT> if i ** 5 - j ** 5 = x : <NEWLINE> <INDENT> print ( i , j ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
X = int ( input ( ) ) <NEWLINE> y = 1 <NEWLINE> z = X <NEWLINE> for i in range ( 2 , int ( ( X ** ( 1 / 2 ) ) ) + 1 ) : <NEWLINE> <INDENT> if X % i == 0 : <NEWLINE> <INDENT> y = i <NEWLINE> z = x // i <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> for a in range ( 10 ** 5 ) : <NEWLINE> <INDENT> b = a - y <NEWLINE> if a ** 4 + ( a ** 3 ) * b + ( a ** 2 ) * ( b ** 2 ) + a * ( b ** 3 ) + b ** 4 == z : <NEWLINE> <INDENT> print ( a , b ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT>
X = int ( input ( ) ) <NEWLINE> for j in range ( 100 ) : <NEWLINE> <INDENT> for i in range ( 100 ) : <NEWLINE> <INDENT> if abs ( pow ( i , 5 ) - X ) == pow ( j , 5 ) : <NEWLINE> <INDENT> if pow ( i , 5 ) - pow ( j , 5 ) == X : <NEWLINE> <INDENT> print ( i , j ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( i , - j ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT>
X = int ( input ( ) ) <NEWLINE> A = 0 <NEWLINE> B = 0 <NEWLINE> while ( True ) : <NEWLINE> <INDENT> while ( True ) : <NEWLINE> <INDENT> if ( A ** 5 ) - ( B ** 5 ) == X : <NEWLINE> <INDENT> print ( <STRING> . format ( A , B ) ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> elif ( ( - 1 * A ) ** 5 ) - ( B ** 5 ) == X : <NEWLINE> <INDENT> print ( <STRING> . format ( - 1 * A , B ) ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> elif ( A ** 5 ) - ( ( - 1 * B ) ** 5 ) == X : <NEWLINE> <INDENT> print ( <STRING> . format ( A , - 1 * B ) ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> elif ( ( - 1 * A ) ** 5 ) - ( ( - 1 * B ) ** 5 ) == X : <NEWLINE> <INDENT> print ( <STRING> . format ( - 1 * A , - 1 * B ) ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> B += 1 <NEWLINE> <DEDENT> <DEDENT> A += 1 <NEWLINE> <DEDENT>
X = int ( input ( ) ) <NEWLINE> flag = False <NEWLINE> for a in range ( - 118 , 120 ) : <NEWLINE> <INDENT> for b in range ( - 119 , 119 ) : <NEWLINE> <INDENT> if a ** 5 - b ** 5 == X : <NEWLINE> <INDENT> print ( <STRING> . format ( a , b ) ) <NEWLINE> flag = True <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if flag : <NEWLINE> <INDENT> breakX = int ( input ( ) ) <NEWLINE> <DEDENT> <DEDENT> flag = False <NEWLINE> for a in range ( - 118 , 120 ) : <NEWLINE> <INDENT> for b in range ( - 119 , 119 ) : <NEWLINE> <INDENT> if a ** 5 - b ** 5 == X : <NEWLINE> <INDENT> print ( <STRING> . format ( a , b ) ) <NEWLINE> flag = True <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if flag : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> X = int ( inout ( ) ) <NEWLINE> a = 1 <NEWLINE> b = 0 <NEWLINE> for a in rangr ( 1 , 120 ) : <NEWLINE> <INDENT> for b in range ( - 119 , a ) : <NEWLINE> <INDENT> if pow ( a , 5 ) - pow ( b , 5 ) == X : <NEWLINE> <INDENT> print ( a , b ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
x = int ( input ( ) ) <NEWLINE> for i in range ( - 1000 , 1000 ) : <NEWLINE> <INDENT> a = i <NEWLINE> for j in range ( - 1000 , 1000 ) : <NEWLINE> <INDENT> b = j <NEWLINE> if a ** 5 - b ** 5 == x : <NEWLINE> <INDENT> am = a <NEWLINE> bm = b <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> c = 0 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( am , bm ) <NEWLINE>
import math <NEWLINE> X = int ( input ( ) ) <NEWLINE> <NL> <NL> def fif_root ( arg ) : <NEWLINE> <INDENT> def root ( ) : <NEWLINE> <INDENT> return math . floor ( math . pow ( x , 1 / 5 ) * pow ( 10 , 10 ) ) / pow ( 10 , 10 ) <NEWLINE> <DEDENT> return list ( map ( lambda x : root ( x ) , arg ) ) <NEWLINE> <NL> <DEDENT> def check_integer ( arg ) : <NEWLINE> <INDENT> return list ( map ( lambda x : x . is_integer ( ) , arg ) ) <NEWLINE> <NL> <DEDENT> a = 0 <NEWLINE> while ( A : = math . pow ( a , 5 ) ) - math . pow ( a - 1 , 5 ) <= X : <NEWLINE> <COMMENT> <NL> <INDENT> root = fif_root ( [ abs ( X - A ) , X + A ] ) <NEWLINE> if True in ( c : = check_integer ( root ) ) : <NEWLINE> <INDENT> idx = c . index ( True ) <NEWLINE> b = int ( root [ idx ] ) <NEWLINE> if idx == 1 : <NEWLINE> <INDENT> a , b = - a , - b <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if X - A >= 0 : <NEWLINE> <INDENT> b = - b <NEWLINE> <DEDENT> <DEDENT> print ( a , b ) <NEWLINE> break <NEWLINE> <DEDENT> a += 1 <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> <NL> def calc ( a , b ) : <NEWLINE> <INDENT> return a ** 5 - b ** 5 <NEWLINE> <NL> <DEDENT> for i in range ( - 10000 , 10001 ) : <NEWLINE> <INDENT> for j in range ( - 10000 , 10001 ) : <NEWLINE> <INDENT> if calc ( i , j ) == n : <NEWLINE> <INDENT> print ( i , j ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
X = int ( input ( ) ) <NEWLINE> for i in range ( - 800 , 800 ) : <NEWLINE> <INDENT> for j in range ( - 800 , 800 ) : <NEWLINE> <INDENT> print ( i ** 5 - j ** 5 ) <NEWLINE> if i ** 5 - j ** 5 == X : <NEWLINE> <INDENT> ans = [ i , j ] <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
X = int ( input ( ) ) <NEWLINE> <NL> N = [ ] <NEWLINE> for i in range ( 66 ) : <NEWLINE> <INDENT> N . append ( i ** 5 ) <NEWLINE> <NL> <DEDENT> for i in reversed ( range ( 100 ) ) : <NEWLINE> <INDENT> for j in reversed ( range ( i ) ) : <NEWLINE> <INDENT> if X == N [ i ] - N [ j ] : <NEWLINE> <INDENT> print ( i , j ) <NEWLINE> break <NEWLINE> <DEDENT> if X == N [ i ] + N [ j ] : <NEWLINE> <INDENT> print ( i , j * - 1 ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def make_divisors ( n ) : <NEWLINE> <INDENT> divisors = [ ] <NEWLINE> for i in range ( 1 , int ( n ** 0.5 ) + 1 ) : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> divisors . append ( i ) <NEWLINE> if i != n // i : <NEWLINE> <INDENT> divisors . append ( n // i ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> divisors . sort ( ) <NEWLINE> return divisors <NEWLINE> <NL> <DEDENT> x = int ( input ( ) ) <NEWLINE> <NL> yakusuu = make_divisors ( x ) <NEWLINE> <NL> for i in yakusuu [ : len ( x ) // 2 + 1 ] : <NEWLINE> <INDENT> y = int ( x / i ) <NEWLINE> if ( y - i ) % 2 == 0 : <NEWLINE> <INDENT> print ( i + ( y - i ) // 2 , i ) <NEWLINE> <DEDENT> <DEDENT>
x = int ( raw_input ( ) ) <NEWLINE> for i in range ( - 120 , 120 ) : <NEWLINE> <INDENT> for j in range ( - 120 , 120 ) : <NEWLINE> <INDENT> if ( math . pow ( i , 5 ) - math . pow ( j , 5 ) == x ) : <NEWLINE> <INDENT> print ( i , <STRING> , j ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
X = int ( input ( ) ) <NEWLINE> <NL> B = [ n ** 5 for n in range ( 300 ) ] <NEWLINE> <NL> A = [ ] <NEWLINE> <NL> for i in range ( 300 ) : <NEWLINE> <INDENT> a = i ** 5 - X if i ** 5 >= X else X - i ** 5 <NEWLINE> A . append ( a ) <NEWLINE> <NL> <DEDENT> for j in range ( 300 ) : <NEWLINE> <INDENT> if A [ j ] in B : <NEWLINE> <INDENT> a = j <NEWLINE> b = B . index ( A [ j ] ) <NEWLINE> if a ** 5 - b ** 5 = X : <NEWLINE> <INDENT> print ( a , b ) <NEWLINE> <DEDENT> elif a ** + b ** 5 = X : <NEWLINE> <INDENT> print ( a , - b ) <NEWLINE> <DEDENT> break <NEWLINE> <DEDENT> <DEDENT>
x = int ( input ( ) ) <NEWLINE> s = { 0 } <NEWLINE> n = 1 <NEWLINE> stop = 0 <NEWLINE> while ( 1 ) : <NEWLINE> <INDENT> N = n ** 5 <NEWLINE> for i in s : <NEWLINE> <INDENT> if N - i == x : <NEWLINE> <INDENT> if i > 0 : <NEWLINE> <INDENT> sig = int ( i // abs ( i ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> sig = 1 <NEWLINE> <DEDENT> print ( n , sig * int ( pow ( abs ( i ) , 1 / 5 ) ) ) <NEWLINE> stop = 1 <NEWLINE> <DEDENT> elif N - i == - x : <NEWLINE> <INDENT> if i > 0 : <NEWLINE> <INDENT> sig = int ( i // abs ( i ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> sig = 1 <NEWLINE> <DEDENT> print ( n , sig * int ( pow ( abs ( i ) , 1 / 5 ) ) ) <NEWLINE> stop = 1 <NEWLINE> <DEDENT> <DEDENT> if stop == 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> s |= { N , - N } <NEWLINE> <DEDENT>
import sys <NEWLINE> x = int ( input ( ) ) <NEWLINE> div = [ ] <NEWLINE> for i in range ( 1 , int ( x ** 0.5 ) + 1 ) : <NEWLINE> <INDENT> if x % i == 0 : <NEWLINE> <INDENT> div . append ( i ) <NEWLINE> if i != n // i : <NEWLINE> <INDENT> div . append ( n // i ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> div . sort ( ) <NEWLINE> div . reverse ( ) <NEWLINE> for i in div : <NEWLINE> <INDENT> for j in range ( 100000 ) : <NEWLINE> <INDENT> a = i + j <NEWLINE> b = j <NEWLINE> other = ( a ** 4 ) + ( a ** 3 ) * b + ( a ** 2 ) * ( b ** 2 ) + a * ( b ** 3 ) + ( b ** 4 ) <NEWLINE> if i * other > x : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if i * other == x : <NEWLINE> <INDENT> print ( a , <STRING> , b ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
import numpy as np <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> x = int ( input ( ) ) <NEWLINE> a = - 119 <NEWLINE> while True : <NEWLINE> <INDENT> for b in range ( - 120 , 120 ) : <NEWLINE> <INDENT> if a ** 5 - b ** 5 == x : <NEWLINE> <INDENT> print ( a , b ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> a += 1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
x = int ( input ( ) <NEWLINE> for i in range ( 120 ) : <NEWLINE> <INDENT> for j in range ( 120 ) : <NEWLINE> <INDENT> if i ** 5 - j ** 5 == x : <NEWLINE> <INDENT> print ( i , j ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
x = int ( input ( ) ) <NEWLINE> i = 0 <NEWLINE> while x - i % i != 0 : <NEWLINE> <INDENT> i += 1 <NEWLINE> <DEDENT> a += i <NEWLINE> b += x - i <NEWLINE> print ( a , b ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> a = 1 <NEWLINE> b = 1 <NEWLINE> for i in range ( - 1000 , 1000 ) : <NEWLINE> <INDENT> for j in range ( - 1000 , 1000 ) : <NEWLINE> <INDENT> if ( ( i ** 5 ) - ( j ** 5 ) == n ) : <NEWLINE> <INDENT> a = i <NEWLINE> b = j <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> % ( a , b ) ) <NEWLINE>
import math <NEWLINE> X = int ( input ( ) ) <NEWLINE> a = math . ceil ( X ** ( 1 / 5 ) ) <NEWLINE> c = 0 <NEWLINE> N = int ( 1e10 ) <NEWLINE> while c <= N : <NEWLINE> <INDENT> c += 1 <NEWLINE> b = math . floor ( ( a ** 5 - X ) ** ( 1 / 5 ) ) <NEWLINE> if a ** 5 - b ** 5 == X : <NEWLINE> <INDENT> print ( a , b ) <NEWLINE> break <NEWLINE> <DEDENT> a += 1 <NEWLINE> <DEDENT>
x = int ( input ( ) ) <NEWLINE> for i in range ( - 118 , 120 ) : <NEWLINE> <INDENT> for j in range ( - 119 , 119 ) : <NEWLINE> <INDENT> if i ** 5 - j ** = x : <NEWLINE> <INDENT> print ( i , j ) <NEWLINE> exit ( 0 ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = input ( ) . split ( ) <NEWLINE> pl = [ ] <NEWLINE> sb = [ ] <NEWLINE> for i in range ( len ( a ) ) : <NEWLINE> <INDENT> pl . append ( i + int ( a [ i ] ) + 1 ) <NEWLINE> if i - int ( a [ i ] ) > 1 : <NEWLINE> <INDENT> sb . append ( i - int ( a [ i ] ) + 1 ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if len ( sb ) == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <NL> <COMMENT> <NL> <INDENT> isb = [ int ( i ) for i in sb ] <NEWLINE> ipl = [ int ( i ) for i in pl ] <NEWLINE> ssb = sorted ( isb ) <NEWLINE> t = min ( ssb ) <NEWLINE> tl = [ 0 ] * max ( ipl ) <NEWLINE> for i in ssb : <NEWLINE> <INDENT> if int ( i ) - 1 < len ( tl ) : <NEWLINE> <INDENT> tl [ int ( i ) - 1 ] += 1 <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> cnt = 0 <NEWLINE> for i in pl : <NEWLINE> <INDENT> if int ( i ) - 1 < len ( tl ) : <NEWLINE> <INDENT> cnt += tl [ int ( i ) - 1 ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE> <NL> <NL> <DEDENT>
n = int ( input ( ) ) <NEWLINE> x = list ( range ( - 10000 , 10000 , 1 ) ) <NEWLINE> <COMMENT> <NL> a = 100 <NEWLINE> b = 100 <NEWLINE> for i in x : <NEWLINE> <INDENT> for j in x : <NEWLINE> <INDENT> if i ** 5 - j ** 5 == n : <NEWLINE> <INDENT> print ( i , end = <STRING> ) <NEWLINE> print ( j ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
x = int ( input ( ) ) <NEWLINE> for i in range ( - 120 , 120 ) : <NEWLINE> <INDENT> for j in range ( - 120.120 ) : <NEWLINE> <INDENT> if i ** 5 - j ** 5 == x : <NEWLINE> <INDENT> print ( i , j ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
x = int ( input ( ) ) <NEWLINE> for i in range ( - 1000 , 1000 ) : <NEWLINE> <INDENT> for j in range ( - 1000 , 1000 ) : <NEWLINE> <INDENT> if i ** 5 - j ** 5 == x : <NEWLINE> <INDENT> print ( i , j ) <NEWLINE> keep = 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if keep == 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> import heapq <NEWLINE> from decimal import Decimal <NEWLINE> <NL> input = sys . stdin . readline <NEWLINE> <NL> x = int ( input ( ) ) <NEWLINE> <NL> <NL> for i in range ( - 1000 , 1000 ) : <NEWLINE> <INDENT> for j in range ( - 1000 , 1000 ) : <NEWLINE> <INDENT> if i ** 5 + j ** 5 == x : <NEWLINE> <INDENT> print ( i , j ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> X = int ( input ( ) ) <NEWLINE> for i in range ( 2000 ) : <NEWLINE> <INDENT> for j in range ( 2000 ) : <NEWLINE> <INDENT> a = i - 1000 <NEWLINE> b = j - 1000 <NEWLINE> if X == a ** 5 - b ** 5 : <NEWLINE> <INDENT> print ( a , end = <STRING> ) <NEWLINE> print ( b ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
import math <NEWLINE> x = int ( input ( ) ) <NEWLINE> <NL> for i in range ( - 1000 , 1000 ) : <NEWLINE> <INDENT> for j in range ( - 1000 , 1000 ) : <NEWLINE> <INDENT> if math . pow ( a , 5 ) == x + math . pow ( b , 5 ) : <NEWLINE> <INDENT> print ( a , b ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
import sys <NEWLINE> <NL> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> <NL> stdin = sys . stdin <NEWLINE> <NL> ni = lambda : int ( ns ( ) ) <NEWLINE> na = lambda : list ( map ( int , stdin . readline ( ) . split ( ) ) ) <NEWLINE> ns = lambda : stdin . readline ( ) . rstrip ( ) <COMMENT> <NEWLINE> <NL> x = ni ( ) <NEWLINE> for a in range ( - 250 , 251 ) : <NEWLINE> <INDENT> for b in range ( - 250 , 251 ) : <NEWLINE> <INDENT> if a ** 5 - b ** 5 == x : <NEWLINE> <INDENT> print ( a , b ) <NEWLINE> exit ( 1 ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
x = int ( input ( ) ) <NEWLINE> a = [ ] <NEWLINE> for i in range ( - 10 ** 4 , 10 ** 4 ) : <NEWLINE> <INDENT> a . append ( i ** 5 ) <NEWLINE> <COMMENT> <NL> <DEDENT> for i in a : <NEWLINE> <INDENT> if x - i in a : <NEWLINE> <INDENT> A = int ( pow ( i , 1 / 5 ) ) <NEWLINE> B = int ( pow ( x - i , 1 / 5 ) ) <NEWLINE> print ( A , B ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> <NL> X = int ( input ( ) ) <NEWLINE> <NL> A_max = 0 <NEWLINE> abs_X = abs ( X ) <NEWLINE> cnt = 0 <NEWLINE> <NL> while 1 : <NEWLINE> <INDENT> if ( cnt ** 5 >= abs_X ) : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> A_max = i <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( A_max ) <NEWLINE> B_max = A_max <NEWLINE> <NL> for i in range ( 0 , A_max + 1 ) : <NEWLINE> <INDENT> for j in range ( 0 , B_max + 1 ) : <NEWLINE> <NL> <INDENT> A = i ** 5 <NEWLINE> B = j ** 5 <NEWLINE> <NL> if ( A + B == X or A - B == X or - A + B == X or - A - B == X ) : <NEWLINE> <INDENT> print ( i , j ) <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> break <NEWLINE> <DEDENT>
X = int ( input ( ) ) <NEWLINE> i = 0 <NEWLINE> while True : <NEWLINE> <INDENT> tmp1 = pow ( X + pow ( i , 5 ) , 1 / 5 ) <NEWLINE> if tmp1 . is_integer ( ) : <NEWLINE> <INDENT> print ( int ( tmp1 ) , i ) <NEWLINE> break <NEWLINE> <DEDENT> tmp2 = pow ( X - pow ( i , 5 ) , 1 / 5 ) <NEWLINE> if tmp2 != complex : <NEWLINE> <INDENT> if tmp2 . is_integer ( ) : <NEWLINE> <INDENT> print ( int ( tmp2 ) , - i ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> i += 1 <NEWLINE> <DEDENT> <DEDENT>
import itertools <NEWLINE> X = int ( input ( ) ) <NEWLINE> <NL> l = [ i for i in range ( - 10000 , 10000 ) ] <NEWLINE> c = itertools . permutations ( l , 2 ) <NEWLINE> for a , b in c : <NEWLINE> <INDENT> if a ** 5 - b ** 5 == X : <NEWLINE> <INDENT> print ( a , b ) <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT>
X = int ( input ( ) ) <NEWLINE> for i in range ( 1 , 10 ** 9 ) : <NEWLINE> <INDENT> if pow ( i , 5 , X - 1 ) == 0 : <NEWLINE> <INDENT> a = i <NEWLINE> <NL> <DEDENT> <DEDENT> print ( a , - 1 ) <NEWLINE>
import math , sys <NEWLINE> X = int ( input ( ) ) <NEWLINE> for a in range ( - 200 , 200 ) : <NEWLINE> <INDENT> a5 == a ** 5 <NEWLINE> for b in range ( - 200 , 200 ) : <NEWLINE> <INDENT> if a5 - b ** 5 == X : <NEWLINE> <INDENT> print ( str ( a ) + <STRING> + str ( b ) ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
import numpy as np <NEWLINE> x = int ( input ( ) ) <NEWLINE> k = 10000 <NEWLINE> a = np . arange ( - k , k ) [ : , np . newaxis ] <NEWLINE> b = np . arange ( - k , k ) <NEWLINE> <NL> res = a ** 5 - b ** 5 == x <NEWLINE> res . nonzero ( ) <NEWLINE> ans = ( np . argwhere ( res ) - k ) [ 0 ] <NEWLINE> print ( ans [ 0 ] , ans [ 1 ] ) <NEWLINE>
a , b , N = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> Ansermax = 0 <NEWLINE> <NL> if b < N : <NEWLINE> <INDENT> N = b <NEWLINE> <NL> <DEDENT> for x in range ( N + 1 ) : <NEWLINE> <NL> <INDENT> Anser = 0 <NEWLINE> <NL> Anser = int ( ( a * x ) // b ) - a * int ( x // b ) <NEWLINE> <NL> if Ansermax < Anser : <NEWLINE> <INDENT> Ansermax = Anser <NEWLINE> <NL> <DEDENT> if x // b >= 1 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( Ansermax ) <NEWLINE>
X = int ( input ( ) ) <NEWLINE> c = 0 <NEWLINE> for i in range ( 100 ) : <NEWLINE> <INDENT> for j in range ( 100 ) : <NEWLINE> <INDENT> if i ** 5 - j ** 5 == X : <NEWLINE> <INDENT> a = i <NEWLINE> b = j <NEWLINE> c += 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if c == 0 : <NEWLINE> <INDENT> for j in range ( 100 ) : <NEWLINE> <INDENT> if i ** 5 + j ** 5 == X : <NEWLINE> a = i <NEWLINE> b = j <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( a b ) <NEWLINE>
<COMMENT> <NL> using namespace std ; <NEWLINE> <NL> void solve ( ) { <NEWLINE> <INDENT> int X ; <NEWLINE> int A , B ; <NEWLINE> cin >> X ; <NEWLINE> for ( A = - 118 ; A < 120 ; A + + ) { <NEWLINE> <INDENT> for ( B = - 119 ; B < A ; B + + ) { <NEWLINE> <INDENT> if ( pow ( A , 5.0 ) - pow ( B , 5.0 ) == X ) { <NEWLINE> <DEDENT> <DEDENT> cout << A << B << endl ; <NEWLINE> goto OUT ; <NEWLINE> <INDENT> } <NEWLINE> } <NEWLINE> <DEDENT> } <NEWLINE> OUT : ; <NEWLINE> <DEDENT> } <NEWLINE> <NL> int main ( ) { <NEWLINE> <INDENT> solve ( ) ; <NEWLINE> return 0 ; <NEWLINE> <DEDENT> } <NEWLINE>
x = int ( input ( ) ) <NEWLINE> <NL> for i in range ( - 1000 , 1000 ) : <NEWLINE> <INDENT> for j in range ( - 1000 , 1000 ) : <NEWLINE> if i ** 5 - j ** 5 == x : <NEWLINE> <INDENT> print ( i , j ) <NEWLINE> <DEDENT> <DEDENT>
x = int ( input ( ) ) <NEWLINE> a = 0 <NEWLINE> while true <NEWLINE> <INDENT> for b in range ( 10 ** 3 ) : <NEWLINE> <INDENT> if a ** 5 - b ** 5 == x : <NEWLINE> <INDENT> print ( a , b ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> elif a ** 5 + b ** 5 == x : <NEWLINE> <INDENT> print ( a , - b ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> elif - a ** 5 + b ** 5 == x : <NEWLINE> <INDENT> print ( - a , - b ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> a += 1 <NEWLINE> <DEDENT>
X = int ( input ( ) ) <NEWLINE> i = 1 <NEWLINE> a = 0 <NEWLINE> b = 0 <NEWLINE> while a == 0 and b == 0 : <NEWLINE> <INDENT> for j in range ( - i , i ) : <NEWLINE> <INDENT> if j ** 5 - i ** 5 == X : <NEWLINE> <INDENT> a = j <NEWLINE> b = i <NEWLINE> <DEDENT> <DEDENT> i = i + 1 <NEWLINE> <DEDENT>
x = int ( input ( ) ) <NEWLINE> for i in range ( - 200 , 200 ) : <NEWLINE> <INDENT> for j in range ( - 200 , 200 ) : <NEWLINE> <INDENT> if i ** 5 - j ** 5 == x ) : <NEWLINE> <INDENT> print ( i , j ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
x = int ( input ( ) ) <NEWLINE> for i in range ( - 1000 : 1000 : 1 ) : <NEWLINE> <INDENT> for j in range ( - 1000 : 1000 : 1 ) : <NEWLINE> <INDENT> if i ** 5 - j ** 5 == x : <NEWLINE> <INDENT> print ( i , j ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
x = int ( input ( ) ) <NEWLINE> for a in range ( 10 ** 4 ) : <NEWLINE> <INDENT> for b in range ( - 10 ** 4 , 10 ** 4 ) : <NEWLINE> <INDENT> if a ** 5 - b ** 5 == X : <NEWLINE> <INDENT> print ( a , b ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> break <NEWLINE> <DEDENT>
for i in range ( 10 ** 8 ) : <NEWLINE> <INDENT> for j in range ( - 10 ** 4 , 10 ** 4 ) : <NEWLINE> <INDENT> if i ** 5 - j ** 5 : <NEWLINE> <INDENT> print ( i . j ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
<COMMENT> <NL> X = int ( input ( ) ) <NEWLINE> Y = [ y ** 5 for y in range ( 100000 ) ] <NEWLINE> for a in range ( 0 , 100000 ) : <NEWLINE> <INDENT> for b in range ( 1 + a , 100000 ) : <NEWLINE> <INDENT> if Y [ a ] - Y [ b ] == X : <NEWLINE> <INDENT> print ( a , b ) <NEWLINE> exit <NEWLINE> <DEDENT> if Y [ a ] + Y [ b ] == X : <NEWLINE> <INDENT> print ( a , - b ) <NEWLINE> exit <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
x = int ( input ( ) ) <NEWLINE> div = make_divisors ( x ) <NEWLINE> def depth_limited ( x , div ) : <NEWLINE> <INDENT> depth = - 50 <NEWLINE> while True : <NEWLINE> <INDENT> depth += 50 <NEWLINE> for t in div : <NEWLINE> <INDENT> for b in range ( depth , depth + 50 ) : <NEWLINE> <INDENT> if x == t * ( 5 * b ** 4 + 10 * b ** 3 * t + 10 * b ** 2 * t ** 2 + 5 * b * t ** 3 + t ** 4 ) : <NEWLINE> <INDENT> return ( b + t , b ) <NEWLINE> <DEDENT> b = - b <NEWLINE> if x == t * ( 5 * b ** 4 + 10 * b ** 3 * t + 10 * b ** 2 * t ** 2 + 5 * b * t ** 3 + t ** 4 ) : <NEWLINE> <INDENT> return ( b + t , b ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> ans = depth_limited ( x , div ) <NEWLINE> print ( str ( ans [ 0 ] ) + <STRING> + str ( ans [ 1 ] ) ) <NEWLINE>
s = int ( input ( ) ) <NEWLINE> a = b = 0 <NEWLINE> for i in range ( - 1000 , 1000 ) : <NEWLINE> <INDENT> for j in range ( - 1000 , 1000 ) : <NEWLINE> <INDENT> if i ** 5 - j ** 5 == s : <NEWLINE> <INDENT> print ( i , j ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
X = int ( input ( ) ) <NEWLINE> <NL> max_a = 128 <NEWLINE> min_a = - 63 <NEWLINE> <NL> for i in range ( - 100 , 100 ) : <NEWLINE> <INDENT> for j in range ( - 100 , 100 ) : <NEWLINE> <INDENT> if i ** 5 - j ** 5 == X <NEWLINE> print ( i , j ) <NEWLINE> exit ( ) <NEWLINE> <NL> <NL> <NL> <NL> <NL> <DEDENT> <DEDENT>
x = int ( input ) <NEWLINE> for i in range ( - 1000 , 1000 ) : <NEWLINE> <INDENT> for j in range ( - 1000 , 1000 ) : <NEWLINE> <INDENT> if i ** 5 == x + j ** 5 : <NEWLINE> <INDENT> print ( i , j ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
import math <NEWLINE> X = int ( input ( ) ) <NEWLINE> res = False <NEWLINE> for A in range ( 1 , 1000 ) : <NEWLINE> <INDENT> for B in range ( - 1000 , A ) : <NEWLINE> <INDENT> if math . pow ( A , 5 ) - math . pow ( B , 5 ) == X : <NEWLINE> <INDENT> res = True <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if res : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( A , B ) <NEWLINE>
<COMMENT> <NL> <NL> import sys <NEWLINE> <NL> X = int ( input ( ) ) <NEWLINE> <NL> powers = { } <NEWLINE> def powered ( i ) : <NEWLINE> <INDENT> if i in powers : <NEWLINE> <INDENT> return powers [ i ] <NEWLINE> <DEDENT> powered = pow ( i , 5 ) <NEWLINE> powers [ i ] = powered <NEWLINE> return powered <NEWLINE> <NL> <DEDENT> for a in range ( 100000 , 0 , - 1 ) : <NEWLINE> <INDENT> for b in range ( 0 , 100000 ) : <NEWLINE> <INDENT> poweredA = powered ( a ) <NEWLINE> poweredB = powered ( b ) <NEWLINE> if poweredA - poweredB == X : <NEWLINE> <INDENT> print ( a , b ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> elif poweredA + poweredB == X : <NEWLINE> <INDENT> print ( a , - b ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
import math <NEWLINE> <NL> x = int ( input ( ) ) <NEWLINE> x_pow = round ( math . pow ( x , 1 / 5 ) ) <NEWLINE> ok = 0 <NEWLINE> <NL> for a in range ( - x_pow - 10 , x_pow + 10 ) : <NEWLINE> <INDENT> for b in range ( - x_pow - 10 , x_pow + 10 ) : <NEWLINE> <INDENT> if a ** 5 - b ** 5 == x : <NEWLINE> <INDENT> print ( a , b ) <NEWLINE> ok = 1 <NEWLINE> eixt ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
x = int ( input ( ) ) <NEWLINE> power5 = [ ( i ** 5 ) for i in range ( 100 ) ] <NEWLINE> for i in range ( 100 ) : <NEWLINE> <INDENT> for j in range ( 100 ) : <NEWLINE> <INDENT> if power [ i ] - power5 [ j ] == x : <NEWLINE> <INDENT> print ( i , j ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> for i in range ( 100 ) : <NEWLINE> <INDENT> for j in range ( 100 ) : <NEWLINE> <INDENT> if power5 [ i ] + power5 [ j ] == x : <NEWLINE> <INDENT> print ( i , - j ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> for i in range ( 100 ) : <NEWLINE> <INDENT> for j in range ( 100 ) : <NEWLINE> <INDENT> if - power5 [ i ] + power5 [ j ] == x : <NEWLINE> <INDENT> print ( - i , - j ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
X = int ( input ( ) ) <NEWLINE> flag = False <NEWLINE> for ai in range ( - 119 , 120 ) : <NEWLINE> <INDENT> for bi in range ( - 120 , 119 ) : <NEWLINE> <INDENT> if ai ** 5 - bi ** 5 == X : <NEWLINE> <INDENT> print ( int ( ai ) , int ( bi ) ) <NEWLINE> <INDENT> flag = True <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if flag : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT>
x = int ( input ( ) ) <NEWLINE> div = make_divisors ( x ) <NEWLINE> <NL> if x == 1 : print ( <STRING> ) <NEWLINE> <NL> for i in range ( len ( div ) // 2 ) : <NEWLINE> <INDENT> u = div [ i * 2 ] <NEWLINE> if len ( div ) % 2 == 1 : v = div [ i * 2 ] <NEWLINE> else : v = div [ i * 2 + 1 ] <NEWLINE> t = int ( v ** ( 1 / 2 ) ) <NEWLINE> for j in range ( t ) : <NEWLINE> <INDENT> a = j <NEWLINE> b = j - u <NEWLINE> if a ** 4 + ( a ** 3 ) * b + ( a ** 2 ) * ( b ** 2 ) + a * ( b ** 3 ) + b ** 4 == v : <NEWLINE> <INDENT> print ( a , b ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
x = int ( input ( ) ) <NEWLINE> for i in range ( - 1000 , 1000 ) : <NEWLINE> <INDENT> for j in range ( - 1000 , 1000 ) : <NEWLINE> <INDENT> if i ** 5 - j ** 5 == x : <NEWLINE> <INDENT> print ( <STRING> . format ( i , j ) ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
X = int ( input ( ) ) <NEWLINE> diff = 1 <NEWLINE> for i in range ( 2 , X ) : <NEWLINE> <INDENT> if X % i == 0 : <NEWLINE> <INDENT> diff = i <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> s = ( 10 ** 9 ) // 2 <NEWLINE> while True : <NEWLINE> <INDENT> ss = s // 2 <NEWLINE> A = ss <NEWLINE> B = ss - diff <NEWLINE> xx = A ** 5 - B ** 5 <NEWLINE> if xx == X : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> elif xx > X : <NEWLINE> <INDENT> s = ss // 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s = ( 3 * ss ) // 4 <NEWLINE> <DEDENT> <DEDENT> print ( int ( A ) , int ( B ) ) <NEWLINE>
x = int ( input ( ) ) <NEWLINE> <NL> for a in range ( 9999 ) : <NEWLINE> <INDENT> for b in range ( 9999 ) : <NEWLINE> <INDENT> if a ** 5 - b ** 5 == x : <NEWLINE> <INDENT> print ( a , b ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
import bisect <NEWLINE> import os <NEWLINE> <NL> X = int ( input ( ) ) <NEWLINE> hist = [ ] <NEWLINE> for a in range ( 100000 ) : <NEWLINE> <INDENT> hist . append ( a ** 5 ) <NEWLINE> i = bisect . bisect_left ( hist , a ** 5 - X ) <NEWLINE> if hist [ i ] == a ** 5 - X : <NEWLINE> <INDENT> print ( a , i ) <NEWLINE> break <NEWLINE> <DEDENT> i = bisect . bisect_left ( hist , X - a ** 5 ) <NEWLINE> if hist [ i ] == X - a ** 5 : <NEWLINE> <INDENT> print ( a , - i ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> import math <NEWLINE> X = int ( input ( ) ) <NEWLINE> <NL> B = - math . floor ( math . pow ( X , 0.2 ) ) <NEWLINE> for b in range ( B , 1000 ) : <NEWLINE> <INDENT> a = int ( math . pow ( X + b ** 5 , 0.2 ) ) <NEWLINE> if a ** 5 - b ** 5 == X : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> tmp = int ( tmp ) <NEWLINE> print ( a , b ) <NEWLINE>
x = int ( input ( ) <NEWLINE> for i in range ( - 200 , 200 ) : <NEWLINE> <INDENT> for j in range ( - 200 , 200 ) : <NEWLINE> <INDENT> if i ** 5 - j ** 5 == x : <NEWLINE> <INDENT> print ( str ( i ) + <STRING> + str ( j ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
x = int ( input ( ) ) <NEWLINE> for i in range ( 120 ) : <NEWLINE> <INDENT> for j in range ( - 119 , a ) : <NEWLINE> <INDENT> if i ** 5 - j ** 5 == x : <NEWLINE> <INDENT> print ( i , j ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
X = int ( input ( ) ) <NEWLINE> for A in range ( - 2500 , 2500 ) : <NEWLINE> <INDENT> for B in range ( - 2500 , 2500 ) : <NEWLINE> <INDENT> if A ** 5 - B ** 5 == X : <NEWLINE> <INDENT> print ( A , B ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> break <NEWLINE> <DEDENT>
X = int ( input ( ) ) <NEWLINE> for i in range ( - 2000 , 2000 ) : <NEWLINE> <INDENT> for j in range ( - 2000 , 2000 ) : <NEWLINE> <INDENT> if i ** 5 - j ** 5 == X : <NEWLINE> <INDENT> print ( i , j ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
x = int ( input ( ) ) <NEWLINE> <NL> for a in range ( 0 , 10 ** 9 ) : <NEWLINE> <INDENT> for b in range ( 0 , 10 ** 9 ) : <NEWLINE> <INDENT> ans = a ** 5 - ( - b ) ** 5 <NEWLINE> if ans == x : <NEWLINE> <INDENT> print ( a , - b ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
X = int ( input ( ) ) <NEWLINE> <NL> for A in range ( 100 ) : <NEWLINE> <INDENT> for B in range ( 100 ) : <NEWLINE> <INDENT> if A ** 5 - B ** 5 == X : <NEWLINE> <INDENT> print ( str ( A ) + <STRING> + str ( B ) ) <NEWLINE> <DEDENT> <DEDENT> break <NEWLINE> <INDENT> if A ** 5 + B ** 5 == X : <NEWLINE> <INDENT> print ( str ( A ) + <STRING> + str ( B ) ) <NEWLINE> <DEDENT> <DEDENT> break <NEWLINE> <DEDENT>
X = int ( input ( ) ) <NEWLINE> for i in range ( - 1500 , 1501 ) : <NEWLINE> <INDENT> for j in range ( - 1500 , 1501 ) : <NEWLINE> <INDENT> if ( i ** 5 ) - ( j ** 5 ) == X : <NEWLINE> <INDENT> print ( i , j ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
X = int ( input ( ) ) <NEWLINE> <NL> for a in range ( - 300 , 300 ) : <NEWLINE> <INDENT> for b in range ( - 300 , 300 ) : <NEWLINE> <INDENT> if a ** 5 - b ** 5 == X : <NEWLINE> <INDENT> print ( str ( A ) + <STRING> + str ( B ) ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
import sys <NEWLINE> <NL> <NL> def resolve ( in_ ) : <NEWLINE> <INDENT> x = int ( in_ . read ( ) ) <NEWLINE> for a in range ( - 118 , 119 + 1 ) : <NEWLINE> <INDENT> for b in range ( - 118 , 119 + 1 ) : <NEWLINE> <INDENT> if x == a ** 5 - b ** 5 : <NEWLINE> <INDENT> return a , b <NEWLINE> <DEDENT> <DEDENT> <DEDENT> raise ValueError ( ) <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> answer = resolve ( sys . stdin . buffer ) <NEWLINE> print ( <STRING> . format ( answer ) ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
X = int ( input ( ) ) <NEWLINE> def modpow ( a , n , mod ) : <NEWLINE> <INDENT> ret = 1 <NEWLINE> while n > 0 : <NEWLINE> <INDENT> if n % 2 == 1 : <NEWLINE> <INDENT> ret = ret * a % mod <NEWLINE> <DEDENT> a *= a <NEWLINE> a = a % mod <NEWLINE> <DEDENT> return ret <NEWLINE> <DEDENT> i = 0 <NEWLINE> L = list ( ) <NEWLINE> while True : <NEWLINE> <INDENT> num = modpow ( i , 5 , X ) <NEWLINE> if num in L : <NEWLINE> <INDENT> j = L . index ( num ) <NEWLINE> ret = <STRING> . format ( i , j ) <NEWLINE> print ( ret ) <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> L . append ( num ) <NEWLINE> i += 1 <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> <NL> X = int ( input ( ) ) <NEWLINE> a = [ i for i in range ( - 10 , 101 ) ] <NEWLINE> b = [ i for i in range ( - 10 , 101 ) ] <NEWLINE> <NL> for i in a : <NEWLINE> <INDENT> for k in b : <NEWLINE> <INDENT> if i ** 5 == X + k ** 5 <NEWLINE> <INDENT> print ( i , k ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
A = - 119 <NEWLINE> while A <= 120 : <NEWLINE> <INDENT> B = - 119 <NEWLINE> while B <= 120 : <NEWLINE> <INDENT> if A ** 5 - B ** 5 == X : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> B += 1 <NEWLINE> <DEDENT> A += 1 <NEWLINE> <NL> <DEDENT> print ( <STRING> % ( A , B ) ) <NEWLINE>
from decimal import Decimal <NEWLINE> X = int ( input ( ) ) <NEWLINE> <NL> B = 1 <NEWLINE> b = 0 <NEWLINE> while True : <NEWLINE> <NL> <INDENT> print ( b ) <NEWLINE> <NL> a = Decimal ( ( X + b ** 5 ) ** ( 1 / 5 ) ) <NEWLINE> <NL> if int ( a ) == a and a > b : <NEWLINE> <INDENT> print ( a , b ) <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if X + ( b - 1 ) ** 5 < 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> b = b - 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> while True : <NEWLINE> <INDENT> print ( B ) <NEWLINE> <NL> A = Decimal ( ( X + B ** 5 ) ** ( 1 / 5 ) ) <NEWLINE> <NL> if int ( A ) == A and A > B : <NEWLINE> <INDENT> print ( A , B ) <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> B = B + 1 <NEWLINE> <DEDENT> <DEDENT>
X = int ( input ( ) ) <NEWLINE> flagp = False <NEWLINE> flagm = False <NEWLINE> for A in range ( - 10 ** 3 , 10 ** 3 ) : <NEWLINE> <INDENT> B5 = A ** 5 - X <NEWLINE> for B in range ( 10 ** 3 ) : <NEWLINE> <INDENT> if B5 == B ** 5 : <NEWLINE> <INDENT> flagp = True <NEWLINE> break <NEWLINE> <DEDENT> elif B5 == - B ** 5 : <NEWLINE> <INDENT> flagm = True <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> raise Exception <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> break <NEWLINE> <DEDENT> if flagp : <NEWLINE> <INDENT> print ( A , B ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( A , - B ) <NEWLINE> <DEDENT>
<NL> from itertools import permutations <NEWLINE> <NL> def power ( base , exp ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if exp < 0 : <NEWLINE> <INDENT> return 1 / power ( base , - exp ) <NEWLINE> <DEDENT> ans = 1 <NEWLINE> while exp : <NEWLINE> <INDENT> if exp & 1 : <NEWLINE> <INDENT> ans *= base <NEWLINE> <DEDENT> exp >>= 1 <NEWLINE> base *= base <NEWLINE> <DEDENT> return ans <NEWLINE> <NL> <DEDENT> def parse ( ) : <NEWLINE> <INDENT> return int ( input ( ) ) <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> X = parse ( ) <NEWLINE> <NL> A = None <NEWLINE> B = None <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> max_val = 1000 <NEWLINE> signs = [ [ 1 , 1 ] , [ - 1 , 1 ] , [ 1 , - 1 ] , [ - 1 , - 1 ] ] <NEWLINE> <NL> for i in range ( 0 , max_val + 1 ) : <NEWLINE> <INDENT> for j in range ( 0 , max_val + 1 ) : <NEWLINE> <INDENT> for sign in signs : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <INDENT> if power ( i * sign [ 0 ] , 5 ) - power ( j * sign [ 1 ] , 5 ) == X : <NEWLINE> <INDENT> A = i * sign [ 0 ] <NEWLINE> B = j * sign [ 1 ] <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( A , B ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
X = int ( input ( ) ) <NEWLINE> for A in range ( 201 ) : <NEWLINE> <INDENT> for B in range ( A ) : <NEWLINE> <INDENT> if A ** 5 - B ** 5 == X : <NEWLINE> <INDENT> Ans = [ A , B ] <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( Ans . split ( ) ) <NEWLINE>
x = int ( input ( ) ) <NEWLINE> for i in range ( - 10000 , 10000 ) : <NEWLINE> <INDENT> for j in range ( - 10000 , 10000 ) : <NEWLINE> <INDENT> if i ** 5 - j ** 5 == x : <NEWLINE> <INDENT> print ( str ( i ) + <STRING> + str ( j ) ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
X = int ( input ( ) ) <NEWLINE> while ( True ) : <NEWLINE> <INDENT> k = breaknum = 0 <NEWLINE> for n in range ( - 118 , 120 ) : <NEWLINE> <INDENT> x = n ** 5 - ( n - k ) ** 5 <NEWLINE> if X == x : <NEWLINE> <INDENT> print ( n ** 5 ) <NEWLINE> breaknum = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> k += 1 <NEWLINE> if breaknum = - 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT>
X = int ( input ( ) ) <NEWLINE> A = 1 <NEWLINE> K = 1 <NEWLINE> while K < X : <NEWLINE> <INDENT> A += 1 <NEWLINE> K = A ** 5 <NEWLINE> <DEDENT> w = 0 <NEWLINE> while w != 1 : <NEWLINE> <INDENT> P = S ** 5 <NEWLINE> Q = P - X <NEWLINE> B = 0 <NEWLINE> while ( Q < B ** 5 ) : <NEWLINE> <INDENT> B += 1 <NEWLINE> <DEDENT> if ( Q == B ** 5 ) : <NEWLINE> <INDENT> w += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> S += 1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> print ( S , B ) <NEWLINE>
def make_divisors ( n ) : <NEWLINE> <INDENT> divisors = [ ] <NEWLINE> for i in range ( 1 , int ( n ** 0.5 ) + 1 ) : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> divisors . append ( i ) <NEWLINE> if i != n // i : <NEWLINE> <INDENT> divisors . append ( n // i ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> return divisors <NEWLINE> <NL> <DEDENT> x = input ( ) <NEWLINE> X = int ( x ) <NEWLINE> <NL> div = make_divisors ( X ) <NEWLINE> <NL> for item in div : <NEWLINE> <INDENT> for A in range ( - 1000 , 1000 ) : <NEWLINE> <INDENT> B = A - item <NEWLINE> <NL> if A ^ 5 - B ^ 5 == X : <NEWLINE> <INDENT> print ( A + <STRING> + B ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def make_divisors ( n ) : <NEWLINE> <INDENT> divisors = [ ] <NEWLINE> for i in range ( 1 , int ( n ** 0.5 ) + 1 ) : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> divisors . append ( i ) <NEWLINE> if i != n // i : <NEWLINE> <INDENT> divisors . append ( n // i ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> divisors . sort ( ) <NEWLINE> return divisors <NEWLINE> <NL> <DEDENT> div = make_divisors ( X ) <NEWLINE> <NL> for d in div : <NEWLINE> <INDENT> i = 1 <NEWLINE> j = i - d <NEWLINE> while True : <NEWLINE> <INDENT> if pow ( i , 5 ) - pow ( j , 5 ) < X : <NEWLINE> <INDENT> i += 1 <NEWLINE> j += 1 <NEWLINE> continue <NEWLINE> <DEDENT> if pow ( i , 5 ) - pow ( j , 5 ) == X : <NEWLINE> <INDENT> print ( i , j ) <NEWLINE> break <NEWLINE> <DEDENT> elif pow ( i , 5 ) - pow ( j , 5 ) > X : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
x = int ( input ( ) ) <NEWLINE> a = 0 <NEWLINE> b = 0 <NEWLINE> <NL> for a_ in range ( - 1000 , 1000 ) : <NEWLINE> <INDENT> for b_ in range ( - 1000 , 1000 ) : <NEWLINE> <INDENT> if a_ ** 5 - b_ ** 5 == x : <NEWLINE> <INDENT> print ( a_ , b_ ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
A = list ( ) <NEWLINE> B = list ( ) <NEWLINE> i = 0 <NEWLINE> X = int ( input ( ) ) <NEWLINE> while ( True ) : <NEWLINE> <INDENT> tmp = i ** 5 <NEWLINE> A . append ( tmp ) <NEWLINE> B . append ( i ) <NEWLINE> if i % 2 == 1 : <NEWLINE> <INDENT> A . append ( tmp * - 1 ) <NEWLINE> B . append ( i ) <NEWLINE> <DEDENT> if tmp >= 10 ** 20 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> i += 1 <NEWLINE> <DEDENT> result = [ 0 , 0 ] <NEWLINE> for i in range ( len ( A ) ) : <NEWLINE> <INDENT> for j in range ( len ( A ) ) : <NEWLINE> <INDENT> if A [ i ] - A [ j ] == X : <NEWLINE> <INDENT> result [ 0 ] = B [ i ] <NEWLINE> result [ 1 ] = B [ j ] <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( * result ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> for a in range ( - 1000 , 1000 ) : <NEWLINE> <INDENT> for b in range ( - 1000 , 1000 ) : <NEWLINE> <INDENT> if a ** 5 - b ** 5 == n : <NEWLINE> <INDENT> print ( a , b ) <NEWLINE> break ; <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> <NL> for i in range ( - 1000 , 1000 ) : <NEWLINE> <INDENT> for for j in range ( - 1000 , 1000 ) : <NEWLINE> <INDENT> if i ** 5 - j ** 5 == n : <NEWLINE> <INDENT> print ( i , j ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
X = int ( input ( ) ) <NEWLINE> <NL> A = 0 <NEWLINE> while True : <NEWLINE> <INDENT> for B in range ( A + 1 ) : <NEWLINE> <INDENT> if A ** 5 + B ** 5 == X : <NEWLINE> <INDENT> print ( A , B ) <NEWLINE> break <NEWLINE> <DEDENT> if A ** 5 - B ** 5 == X : <NEWLINE> <INDENT> print ( A , B ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> A += 1 <NEWLINE> <DEDENT>
a = 0 <NEWLINE> x = int ( input ( ) ) <NEWLINE> <NL> while True : <NEWLINE> <INDENT> b = ( x - a ** 5 ) ** ( 1 / 5 ) <NEWLINE> if b . is_integer ( ) : <NEWLINE> <INDENT> print ( a , int ( b ) ) <NEWLINE> break <NEWLINE> <DEDENT> b = ( a ** 5 - x ) ** ( 1 / 5 ) <NEWLINE> if b . is_integer ( ) : <NEWLINE> <INDENT> print ( a , int ( b ) ) <NEWLINE> break <NEWLINE> <NL> <DEDENT> a += 1 <NEWLINE> <DEDENT>
x = int ( input ( ) ) <NEWLINE> for i in range ( - 10 ** 9 , 10 ** 9 ) : <NEWLINE> <INDENT> for j in range ( - 10 ** 9 , 10 ** 9 ) : <NEWLINE> <INDENT> if i ** 5 - j ** 5 == x : <NEWLINE> <INDENT> print ( i , j ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
<COMMENT> <NL> def meet_condition ( i , j ) : <NEWLINE> <INDENT> pi = pows [ i ] <NEWLINE> pj = pows [ j ] <NEWLINE> <NL> if pi - pj == x : <NEWLINE> <INDENT> return i , j <NEWLINE> <DEDENT> elif pi + pj == x : <NEWLINE> <INDENT> return i , - j <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> pows = [ ] <NEWLINE> <NL> for i in range ( 100 ) : <NEWLINE> <INDENT> pows . append ( pow ( i , 5 ) ) <NEWLINE> <NL> <DEDENT> x = int ( input ( ) ) <NEWLINE> <NL> for i in range ( len ( pows ) ) : <NEWLINE> <INDENT> for j in range ( len ( pows ) ) : <NEWLINE> <INDENT> if meet_condition ( i , j ) != None : <NEWLINE> <INDENT> a , b = meet_condition ( i , j ) <NEWLINE> print ( a , b ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
X = int ( input ( ) ) <NEWLINE> <NL> CNT = 2000 <NEWLINE> <NL> for a in range ( - CNT , CNT ) : <NEWLINE> <INDENT> for b in range ( - CNT , CNT ) : <NEWLINE> <INDENT> if X == a ** 5 - b ** 5 : <NEWLINE> <INDENT> print ( a , b ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <NL> <NL> using ll = long long ; <NEWLINE> using llu = long long unsigned ; <NEWLINE> <NL> int main ( void ) <NEWLINE> { <NEWLINE> <INDENT> // scanf ( <STRING> , ) ; <NEWLINE> // scanf ( <STRING> , ) ; <NEWLINE> // scanf ( <STRING> , ) ; <NEWLINE> // printf ( <STRING> ) ; <NEWLINE> // printf ( <STRING> ) ; <NEWLINE> // printf ( <STRING> ) ; <NEWLINE> <NL> llu fives [ 64000 ] ; <NEWLINE> llu x ; <NEWLINE> scanf ( <STRING> , & x ) ; <NEWLINE> for ( register llu i = 0 ; i < 32000 ; i + + ) <NEWLINE> <INDENT> fives [ i ] = i * i * i * i * i ; <NEWLINE> <DEDENT> for ( register llu i = 32000 ; i < 64000 ; i + + ) <NEWLINE> <INDENT> fives [ i ] = - i * i * i * i * i ; <NEWLINE> <NL> <DEDENT> bool found = false ; <NEWLINE> register llu i , j ; <NEWLINE> for ( i = 0 ; i < 64000 ; i + + ) { <NEWLINE> <INDENT> for ( j = 0 ; j < 64000 ; i + + ) { <NEWLINE> <INDENT> if ( ( fives [ i ] - fives [ j ] ) == x ) { <NEWLINE> <INDENT> found = true ; <NEWLINE> <DEDENT> break ; <NEWLINE> } <NEWLINE> <DEDENT> } <NEWLINE> if ( found ) break ; <NEWLINE> <DEDENT> } <NEWLINE> if ( i > 32000 ) <NEWLINE> <INDENT> i *= - 1 ; <NEWLINE> <DEDENT> if ( j > 32000 ) <NEWLINE> <INDENT> j *= - 1 ; <NEWLINE> <DEDENT> printf ( <STRING> , i , j ) ; <NEWLINE> <NL> return 0 ; <NEWLINE> <DEDENT> } <NEWLINE>
import sys <NEWLINE> X = int ( input ( ) ) <NEWLINE> for A in range ( 1000 ) : <NEWLINE> <INDENT> for B in range ( 1000 ) : <NEWLINE> <INDENT> if A ** 5 - B ** 5 == X : <NEWLINE> <INDENT> print ( A , B ) <NEWLINE> sys . exit ( 1 ) <NEWLINE> <DEDENT> elif A ** 5 + B ** 5 == X : <NEWLINE> <INDENT> print ( A , - B ) <NEWLINE> sys . exit ( 1 ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
<INDENT> x = int ( input ( ) ) <NEWLINE> for a in range ( - 118 , 120 ) : <NEWLINE> <INDENT> for b in range ( - 118 , 120 ) : <NEWLINE> <INDENT> if a ** 5 - b ** 5 == x : <NEWLINE> <INDENT> print ( a , b ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT>
x = int ( input ( ) ) <NEWLINE> if not x == 0 : <NEWLINE> <INDENT> for i in range ( 10000 ) : <NEWLINE> <INDENT> for j in range ( - 10000 , 10000 ) : <NEWLINE> <INDENT> if i ** 5 - j ** 5 == x : <NEWLINE> <INDENT> a = i <NEWLINE> b = j <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( str ( a ) + <STRING> + str ( b ) ) <NEWLINE>
import itertools <NEWLINE> <NL> comb = list ( itertools . product ( [ _ for _ in range ( - 70 , 140 ) ] , repeat = 2 ) ) <NEWLINE> <NL> for c in comb : <NEWLINE> <INDENT> a , b = c [ 0 ] , c [ 1 ] <NEWLINE> if a ** 5 - b ** 5 == x : <NEWLINE> <INDENT> print ( a , b ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT>
x = int ( input ( ) ) <NEWLINE> rep = 10 ** 4 <NEWLINE> for i in range ( rep ) : <NEWLINE> <INDENT> for j in range ( rep ) : <NEWLINE> <INDENT> if ( i - ( rep // 2 ) ) ** 5 - ( j - ( rep // 2 ) ) ** 5 == x : <NEWLINE> <INDENT> print ( i - ( rep // 2 ) , j - ( rep // 2 ) ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def prime_factorize ( n ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> ans = set ( ) <NEWLINE> ans_add = ans . add <NEWLINE> ans_add ( 1 ) <NEWLINE> while n % 2 == 0 : <NEWLINE> <INDENT> ans_add ( 2 ) <NEWLINE> n //= 2 <NEWLINE> <DEDENT> f = 3 <NEWLINE> while f * f <= n : <NEWLINE> <INDENT> if n % f == 0 : <NEWLINE> <INDENT> ans_add ( f ) <NEWLINE> n //= f <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> f += 2 <NEWLINE> <DEDENT> <DEDENT> if n != 1 : <NEWLINE> <INDENT> ans_add ( n ) <NEWLINE> <DEDENT> return ans <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> x = int ( input ( ) ) <NEWLINE> <COMMENT> <NL> insu = prime_factorize ( x ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> b_min = - int ( x ** ( 1 / 5 ) ) <NEWLINE> for n in insu : <NEWLINE> <INDENT> b = b_min <NEWLINE> while 1 : <NEWLINE> <INDENT> a = b <NEWLINE> while 1 : <NEWLINE> <INDENT> a += n <NEWLINE> if a < 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> cand = a ** 5 - b ** 5 <NEWLINE> if cand == x : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> elif cand > x : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> b += 1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> print ( main ( ) ) <NEWLINE> <DEDENT>
<COMMENT> <NL> import math , sys <NEWLINE> x = int ( input ( ) ) <NEWLINE> for a in range ( math . ceil ( math . log10 ( x ) ) ) : <NEWLINE> <INDENT> for b in range ( - 10 ** 9 // 2 , 10 ** 9 // 2 ) : <NEWLINE> <INDENT> if s ** 5 - b ** 5 == x : <NEWLINE> <INDENT> print ( a , b ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
x = int ( input ( ) ) <NEWLINE> for i in range ( - 118 , 120 ) : <NEWLINE> <INDENT> if x - pow ( i , 5 ) >= 0 : <NEWLINE> <INDENT> if pow ( ( x - pow ( i , 5 ) ) , 0.2 ) . is_integer ( ) : <NEWLINE> <INDENT> b = pow ( ( x - pow ( i , 5 ) ) , 0.2 ) <NEWLINE> print ( a , b ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if pow ( - ( x - pow ( i , 5 ) ) , 0.2 ) . is_integre ( ) : <NEWLINE> <INDENT> b = pow ( - ( x - pow ( i , 5 ) ) , 0.2 ) <NEWLINE> print ( a , b ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
X = int ( input ( ) ) <NEWLINE> A = [ 0 ] * 200 <NEWLINE> m = 0 <NEWLINE> n = 0 <NEWLINE> for i in range ( 400 ) : <NEWLINE> <INDENT> A [ i ] = i ** 5 <NEWLINE> <DEDENT> for i in range ( 400 ) : <NEWLINE> <INDENT> x = A [ i ] <NEWLINE> for j in range ( 400 ) : <NEWLINE> <INDENT> y = A [ j ] <NEWLINE> if ( ( x + y ) == X ) : <NEWLINE> <INDENT> m = i <NEWLINE> n = ( - 1 ) * j <NEWLINE> <DEDENT> elif ( ( x - y ) == X ) : <NEWLINE> <INDENT> m = i <NEWLINE> n = j <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( m , n ) <NEWLINE>
import collections <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> L = [ i + j for i , j in enumerate ( A ) ] <NEWLINE> R = [ i - j for i , j in enumerate ( A ) ] <NEWLINE> <NL> l = collections . Counter ( L ) <NEWLINE> r = collections . Counter ( R ) <NEWLINE> <NL> for i in l . keys ( ) : <NEWLINE> <INDENT> ans += l [ i ] * r [ i ] <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
import sys , math , collections , <NEWLINE> input = sys . stdin . readline <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = [ ] <NEWLINE> C = [ ] <NEWLINE> for i , a in enumerate ( A ) : <NEWLINE> <INDENT> B . append ( i + a ) <NEWLINE> C . append ( i - a ) <NEWLINE> <DEDENT> cnt = 0 <NEWLINE> Bc = collections . Counter ( B ) <NEWLINE> Cc = collections . Counter ( C ) <NEWLINE> <NL> for key , val in Bc . items ( ) : <NEWLINE> <INDENT> cnt += val * Cc [ key ] <NEWLINE> <DEDENT> print ( cnt ) <NEWLINE>
from collections import Counter <NEWLINE> n = int ( inputs [ 0 ] ) <NEWLINE> * A , = ( map ( int , inputs [ 1 ] . split ( ) ) ) <NEWLINE> B = Counter ( [ a + i for i , a in enumerate ( A , 1 ) ] ) <NEWLINE> C = Counter ( [ i - a for i , a in enumerate ( A , 1 ) ] ) <NEWLINE> ans = 0 <NEWLINE> for k , v in B . items ( ) : <NEWLINE> <INDENT> if k in C : <NEWLINE> <INDENT> ans += C [ k ] * v <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> dic = { } <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> idx = i + a [ i ] + 1 <NEWLINE> if idx in dic : <NEWLINE> <INDENT> dic [ idx ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dic [ idx ] = 1 <NEWLINE> <DEDENT> <DEDENT> ans = 0 <NEWLINE> j = n - 1 <NEWLINE> while j > 0 : <NEWLINE> <INDENT> target = j + 1 - a [ j ] <NEWLINE> idx = j + 1 + a [ j ] <NEWLINE> if target in dic : <NEWLINE> <INDENT> ans += dic [ target ] <NEWLINE> <DEDENT> dic [ idx ] -= 1 <NEWLINE> j -= 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> arr = map ( int , input ( ) . split ( ) ) <NEWLINE> _sum = [ ] <NEWLINE> _del = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> _sum . append ( arr [ i ] + i + 1 ) <NEWLINE> _del . append ( i + 1 - arr [ i ] ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> int ( input ( ) ) <NEWLINE> <NL> d = { } <NEWLINE> ans = 0 <NEWLINE> for i , height in enumerate ( input ( ) . split ( ) ) : <NEWLINE> <INDENT> height = int ( height ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> got = d . get ( i + height ) or 0 <NEWLINE> d [ i + height ] += got + 1 <NEWLINE> ans += d . get ( i - height ) or 0 <NEWLINE> <NL> <DEDENT> return ans <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> print ( main ( ) ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT>
import numpy as np <NEWLINE> import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> <NL> N = int ( input ( ) ) <NEWLINE> <NL> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A = np . array ( [ a for i in range ( N ) ] ) <NEWLINE> B = np . array ( [ [ a [ i ] ] * N for i in range ( N ) ] ) <NEWLINE> C = A + B <NEWLINE> d = [ i for i in range ( N ) ] <NEWLINE> D = np . array ( [ d for i in range ( N ) ] ) <NEWLINE> E = np . array ( [ [ i ] * N for i in range ( N ) ] ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> ind = D - E <NEWLINE> <COMMENT> <NL> ans = C - ind <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> print ( cnt ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> k = 0 <NEWLINE> if n % 2 == 1 : <NEWLINE> <INDENT> for i in range ( m ) : <NEWLINE> <INDENT> print ( i + 1 , end = <STRING> ) <NEWLINE> print ( n - i ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( ( n + 2 ) // 4 - 1 ) : <NEWLINE> <INDENT> if k >= m : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> print ( i + 1 , end = <STRING> ) <NEWLINE> print ( n - i ) <NEWLINE> k += 1 <NEWLINE> <DEDENT> for i in range ( ( n + 2 ) // 4 - 1 , n // 2 ) : <NEWLINE> <INDENT> if k >= m : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> print ( i + 1 , end = <STRING> ) <NEWLINE> print ( n - i - 1 ) <NEWLINE> k += 1 <NEWLINE> <DEDENT> <DEDENT>
from collections import defaultdict <NEWLINE> enu = enumerate <NEWLINE> def input ( ) : return sys . stdin . readline ( ) [ : - 1 ] <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> cnt = 0 <NEWLINE> d = defaultdict ( int ) <NEWLINE> for i , a in enu ( A ) : <NEWLINE> <INDENT> l = ( i + 1 ) + a <NEWLINE> r = ( i + 1 ) - a <NEWLINE> cnt += d [ r ] <NEWLINE> d [ l ] += 1 <NEWLINE> <NL> <DEDENT> print ( cnt ) <NEWLINE>
from collections import Counter <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> q1 = [ ] <NEWLINE> q2 = [ ] <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> q1 . append ( i + a [ i ] ) <NEWLINE> q2 . append ( i - a [ i ] ) <NEWLINE> <NL> <DEDENT> c2 = Counter ( q2 ) <NEWLINE> <NL> ans = 0 <NEWLINE> for i in c1 . keys ( ) : <NEWLINE> <INDENT> ans += c2 [ i ] <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
import collections <NEWLINE> n = int ( input ( ) ) <NEWLINE> <NL> A = list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> B = [ ( A [ 0 ] + A [ i ] - i ) for i in range ( n ) ] <NEWLINE> b = collections . Counter ( B ) <NEWLINE> ans = 0 <NEWLINE> cnt = 0 <NEWLINE> for i in range ( len ( B ) ) : <NEWLINE> <NL> <INDENT> ans += b [ cnt ] <NEWLINE> if i != 0 : <NEWLINE> <INDENT> cnt += ( B [ i ] - B [ i - 1 ] - 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> a_list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c = [ 0 ] * n <NEWLINE> s = 0 <NEWLINE> for i , a in enumerate ( a_list ) : <NEWLINE> <INDENT> if i + a < n : <NEWLINE> <INDENT> d [ i + a ] += 1 <NEWLINE> <DEDENT> if i - a >= 0 : <NEWLINE> <INDENT> s += d [ i - a ] <NEWLINE> <DEDENT> <DEDENT> print ( s ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import collections <NEWLINE> <NL> input ( ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> map1 = collections . defualtdict ( lambda : 0 ) <NEWLINE> map2 = collections . defaultdict ( lambda : 0 ) <NEWLINE> <NL> for i , v in enumerate ( p ) : <NEWLINE> <INDENT> map1 [ i + v ] += 1 <NEWLINE> map2 [ i - v ] += 1 <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in map1 : <NEWLINE> <INDENT> if i in map2 : <NEWLINE> <INDENT> ans += map2 [ i ] <NEWLINE> <DEDENT> <DEDENT> print ( i ) <NEWLINE>
x = int ( input ( ) ) <NEWLINE> def ans ( x ) : <NEWLINE> <INDENT> for a in range ( 0 , 1000 ) [ : : - 1 ] : <NEWLINE> <INDENT> for b in range ( - 1000 , 1000 ) [ : : - 1 ] : <NEWLINE> <INDENT> if a ** 5 - b ** 5 == x : <NEWLINE> <INDENT> return a , b <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> a , b = ans ( x ) <NEWLINE> print ( a , b ) <NEWLINE>
n = int ( input ( ) . strip ( ) ) <NEWLINE> L = list ( map ( int , input ( ) . strip ( ) . split ( ) ) ) <NEWLINE> seen = set ( ) <NEWLINE> ans = 0 <NEWLINE> for j in range ( n ) : <NEWLINE> <INDENT> if j - L [ j ] in seen : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> seen . add ( A [ j ] + j ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> lst = [ 0 ] * N <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if i + 1 + A [ i ] < n : <COMMENT> <NEWLINE> <INDENT> lst [ i + A [ i ] ] += 1 <NEWLINE> <DEDENT> if i + 1 - A [ i ] >= 1 : <NEWLINE> <INDENT> ans += lst [ i - A [ i ] ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = [ 0 ] * n <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> b [ i ] = i - a [ 0 ] - a [ i ] <NEWLINE> <DEDENT> d = defaultdict ( int ) <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> d [ b [ i ] ] += 1 <NEWLINE> <DEDENT> ans = 0 <NEWLINE> x = 0 <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> ans += d [ x ] <NEWLINE> d [ b [ i + 1 ] ] -= 1 <NEWLINE> x -= - 1 + ( a [ i ] - a [ i + 1 ] ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
from collections import defaultdict <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = np . array ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> ci = defaultdict ( int ) <NEWLINE> cj = defaultdict ( int ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ci [ a [ i ] + i ] += 1 <NEWLINE> cj [ i - a [ i ] ] += 1 <NEWLINE> <DEDENT> cnt = 0 <NEWLINE> for k in ci . keys ( ) : <NEWLINE> <INDENT> cnt += ci [ k ] * cj [ k ] <NEWLINE> <DEDENT> print ( cnt ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> arr = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> memo = [ 0 ] * ( ( 10 ** 9 ) * 2 ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if ( i + 1 ) - arr [ i ] >= 0 : <NEWLINE> <INDENT> ans += memo [ ( i + 1 ) - arr [ i ] ] <NEWLINE> <DEDENT> if ( i + 1 ) + arr [ i ] > 0 : <NEWLINE> <INDENT> memo [ ( i + 1 ) + arr [ i ] ] += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> import numpy as np <NEWLINE> from numba import jit <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> sys . setrecursionlimit ( 10 ** 8 ) <NEWLINE> INF = float ( <STRING> ) <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> <NL> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> H = np . array ( input ( ) . split ( ) , np . int64 ) <NEWLINE> A = np . arange ( 1 , N + 1 ) <NEWLINE> B = np . arange ( 1 , N + 1 ) <NEWLINE> A = A + H <NEWLINE> B = B - H <NEWLINE> ans = 0 <NEWLINE> <NL> @ jit ( nopython = True ) <NEWLINE> def aa ( i ) : <NEWLINE> <INDENT> return N - i - np . count_nonzero ( B [ i : ] - A [ : - i ] ) <NEWLINE> <DEDENT> for i in range ( 1 , N ) : <NEWLINE> <INDENT> ans += aa ( i ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
from collections import Counter <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> r = [ ] <NEWLINE> for i , ai in enumerate ( a ) : <NEWLINE> <INDENT> l . append ( i + ai ) <NEWLINE> r . append ( i - ai ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> b = Counter ( r ) <NEWLINE> for i in l : <NEWLINE> <INDENT> ans += b . get ( i , 0 ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
ef main ( ) : <NEWLINE> <INDENT> from collections import Counter <NEWLINE> n = int ( input ( ) ) <NEWLINE> As = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> <NL> cnts = Counter ( ) <NEWLINE> dp = [ 0 ] * n <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> dp [ i ] = dp [ i - 1 ] + cnts . get ( i - As [ i ] , 0 ) <NEWLINE> cnts [ As [ i ] + i ] += 1 <NEWLINE> <DEDENT> print ( dp [ n - 1 ] ) <NEWLINE> <DEDENT> main ( ) <NEWLINE>
from collections import Counter <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> d = dict ( collections . Counter ( [ i + A [ i - 1 ] for i in range ( 1 , N + 1 ) ] ) ) <NEWLINE> ans = sum ( [ d . get ( i - A [ i - 1 ] , 0 ) for i in range ( 1 , N + 1 ) ] ) <NEWLINE> <NL> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> cnt = defaultdict ( int ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ans += cnt [ i - a [ i ] ] <NEWLINE> cnt [ i + a [ i ] ] += 1 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> <NL> A = tuple ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> dict_ = { } <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> k = ( i + 1 ) - A [ i ] <NEWLINE> if k in dict_ : <NEWLINE> <INDENT> ans += dict [ k ] <NEWLINE> <DEDENT> ad = ( i + 1 ) + A [ i ] <NEWLINE> if ad in dict_ : <NEWLINE> <INDENT> dict_ [ ad ] = dict_ [ ad ] + 1 <NEWLINE> <DEDENT> dict_ [ ad ] = 1 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> count = 0 <NEWLINE> L = [ 0 ] * N <NEWLINE> R = [ 0 ] * N <NEWLINE> hash_L = [ 0 ] * 10000000000 <NEWLINE> hash_R = [ 0 ] * 10000000000 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> L [ i ] = A [ i ] + i <NEWLINE> hash_L [ L [ i ] ] = L [ i ] <NEWLINE> R [ i ] = - A [ i ] + i <NEWLINE> hash_R [ R [ i ] ] = R [ i ] <NEWLINE> <NL> <DEDENT> for i in range ( 2 * N ) : <NEWLINE> <INDENT> if hash_L [ i ] == hash_R [ i ] : <NEWLINE> <INDENT> count = count + 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> . format ( count ) ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> int ( input ( ) ) <NEWLINE> d = { } <NEWLINE> ans = 0 <NEWLINE> for i , height in enumerate ( input ( ) . split ( ) ) : <NEWLINE> <INDENT> d [ i + height ] += 1 <NEWLINE> ans += d [ i - height ] <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> print ( main ( ) ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> n , a , d = int ( input ( ) ) , list ( map ( int , input ( ) . split ( ) ) ) , [ 0 ] * n <NEWLINE> for i , x in enumerate ( a ) : <NEWLINE> <INDENT> if i + x < n : d [ i + x ] += 1 <NEWLINE> <DEDENT> print ( sum ( [ d [ i - x ] for i , x in enumerate ( a ) if i - x >= 0 ] ) ) <NEWLINE> <DEDENT> main ( ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> L = [ ] <NEWLINE> R = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> L . append ( i + A [ i ] ) <NEWLINE> R . append ( i - A [ i ] ) <NEWLINE> <DEDENT> from collections import Counter <NEWLINE> zisyo = R . Counter ( R ) <NEWLINE> ans = 0 <NEWLINE> for i in L : <NEWLINE> <INDENT> ans = ans + get ( i , 0 ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> su = dict ( ) <NEWLINE> sd = dict ( ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if a [ i ] + i + 1 in su : <NEWLINE> <INDENT> su [ a [ i ] + i + 1 ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> su [ a [ i ] + i + 1 ] = 1 <NEWLINE> <DEDENT> if a [ i ] - i - 1 in sd : <NEWLINE> <INDENT> sd [ a [ i ] - i - 1 ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> sd [ a [ i ] - i - 1 ] = 1 <NEWLINE> <DEDENT> <DEDENT> f1 = [ ] <NEWLINE> for d in su : <NEWLINE> <INDENT> f1 . append ( d , su [ d ] ) <NEWLINE> <DEDENT> f1 . sort ( ) <NEWLINE> f = [ ] <NEWLINE> for d in sd : <NEWLINE> <INDENT> f . append ( d , su [ d ] ) <NEWLINE> <DEDENT> f . sort ( ) <NEWLINE> s = 0 <NEWLINE> i1 = n - 1 <NEWLINE> j1 = 0 <NEWLINE> while ( i1 > 0 and j1 < n - 1 ) : <NEWLINE> <INDENT> if ( su [ i1 ] + sd [ j1 ] == 0 ) : <NEWLINE> <INDENT> s += 1 <NEWLINE> i1 -= 1 <NEWLINE> <DEDENT> elif ( su [ i1 ] + sd [ j1 ] > 0 ) : <NEWLINE> <INDENT> i1 -= 1 <NEWLINE> <NL> <DEDENT> elif ( su [ i1 ] + sd [ j1 ] < 0 ) : <NEWLINE> <INDENT> j1 += 1 <NEWLINE> <DEDENT> <DEDENT> print ( s ) <NEWLINE>
<COMMENT> <NL> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> not_good = [ ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if h [ a - 1 ] > h [ b - 1 ] : <COMMENT> <NEWLINE> <INDENT> not_good . append ( b ) <NEWLINE> <DEDENT> elif h [ a - 1 ] == h [ b - 1 ] : <NEWLINE> <INDENT> not_good . append ( a ) <NEWLINE> not_good . append ( b ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> not_good . append ( a ) <NEWLINE> <DEDENT> <DEDENT> ans = 0 <NEWLINE> not_good = list ( set ( not_good ) ) <NEWLINE> not_good . sort ( ) <NEWLINE> <COMMENT> <NL> idx = 0 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if i < not_good [ idx ] : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <COMMENT> <NL> <DEDENT> elif i == not_good [ idx ] : <NEWLINE> <INDENT> idx += 1 <NEWLINE> if idx == len ( not_good ) : <NEWLINE> <INDENT> ans += n - i <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> n , a = map ( int , open ( 0 ) . read ( ) . split ( ) ) ; d , s = [ 0 ] * n , 0 <NEWLINE> for i , x in enumerate ( a ) : <NEWLINE> <INDENT> if i + x < n : d [ i + x ] += 1 <NEWLINE> if i - x >= 0 : s += d [ i - x ] <NEWLINE> <DEDENT> print ( s ) <NEWLINE> <DEDENT> main ( ) <NEWLINE>
<COMMENT> <NL> <NL> <COMMENT> <NL> def input_int ( ) : <NEWLINE> <INDENT> return int ( input ( ) ) <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> def int1 ( x ) : <NEWLINE> <INDENT> return int ( x ) - 1 <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> def input_to_int_map ( ) : <NEWLINE> <INDENT> return map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> def input_to_int_tuple ( ) : <NEWLINE> <INDENT> return tuple ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> def input_to_int_tuple_minus1 ( ) : <NEWLINE> <INDENT> return tuple ( map ( int1 , input ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> a = input_to_int_tuple ( ) <NEWLINE> <NL> from collections import defaultdict <NEWLINE> l = defaultdict ( 0 ) <NEWLINE> r = defaultdict ( 0 ) <NEWLINE> for i , h in enumerate ( a ) : <NEWLINE> <INDENT> no = i + 1 <NEWLINE> l [ no + h ] += 1 <NEWLINE> r [ no - h ] += 1 <NEWLINE> <NL> <DEDENT> ret = 0 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> ret += ( l . get ( i , 0 ) * r . get ( i , 0 ) ) <NEWLINE> <NL> <DEDENT> return ret <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> print ( main ( ) ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> L = [ i + x for i , x in enumerate ( A ) ] <NEWLINE> R = [ i - x for i , x in enumerate ( A ) if i - x > 0 ] <NEWLINE> <NL> P = collections . Counter ( L ) <NEWLINE> Q = collections . Counter ( R ) <NEWLINE> <NL> ans = 0 <NEWLINE> for k , v in P . item ( ) : <NEWLINE> <INDENT> if k in Q : <NEWLINE> <INDENT> ans += v * Q [ k ] <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = [ 0 ] * ( 10 ** 10 ) <NEWLINE> res = 0 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> B [ A [ i ] + i ] += 1 <NEWLINE> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> if i - A [ i ] > 0 : <NEWLINE> <INDENT> res += B [ i - A [ i ] ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( res ) <NEWLINE>
n , * A = map ( int , open ( 0 ) . read ( ) . split ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i , a in enumerate ( A , 1 ) : <NEWLINE> <INDENT> x , y = i + a , i - a <NEWLINE> d [ x ] = d . get ( x , 0 ) + 1 <NEWLINE> ans += d . get ( y , 0 ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
<INDENT> from collections import Counter <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> Y = [ int ( i + A [ i - 1 ] ) for i in range ( 1 , N + 1 ) ] <NEWLINE> Y = Counter ( Y ) <NEWLINE> <NL> cnt = 0 <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> X = i - A [ i - 1 ] <NEWLINE> if X in Y . keys ( ) : <NEWLINE> <INDENT> cnt += Y [ X ] <NEWLINE> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> L , R = { } , { } <NEWLINE> for i , a in enumerate ( A ) : <NEWLINE> <INDENT> l , r = i - a , i + a <NEWLINE> if l in L : L [ l ] = 0 <NEWLINE> if r in R : R [ r ] = 0 <NEWLINE> L [ l ] += 1 <NEWLINE> R [ r ] += 1 <NEWLINE> <NL> <DEDENT> count = 0 <NEWLINE> for x in L : <NEWLINE> <INDENT> if x not in R : continue <NEWLINE> count += L [ x ] * R [ x ] <NEWLINE> <DEDENT> print ( count ) <NEWLINE>
<NL> si = lambda : input ( ) . strip ( ) <NEWLINE> ii = lambda : int ( input ( ) ) <NEWLINE> mii = lambda : map ( int , input ( ) . split ( ) ) <NEWLINE> msi = lambda : map ( str , input ( ) . split ( ) ) <NEWLINE> lmii = lambda : list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> lmsi = lambda : list ( map ( str , input ( ) . split ( ) ) ) <NEWLINE> smii = lambda : sorted ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> <COMMENT> <NL> <NL> N = ii ( ) <NEWLINE> A = lmii ( ) <NEWLINE> <NL> bd = defaultdict ( int ) <NEWLINE> ac = defaultdict ( int ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> a = b = i + 1 <NEWLINE> c = d = A [ i ] <NEWLINE> bd [ b - d ] += 1 <NEWLINE> ac [ a + c ] += 1 <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for k , v in bd . items ( ) : <NEWLINE> <INDENT> ans += v * ac [ k ] <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
n , * abc = map ( int , input ( ) . split ( ) ) <NEWLINE> ip = [ 0 ] * n <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> tmp = input ( ) <NEWLINE> if tmp == <STRING> : <NEWLINE> <INDENT> ip [ i ] = [ 0 , 1 ] <NEWLINE> <DEDENT> elif tmp == <STRING> : <NEWLINE> <INDENT> ip [ i ] = [ 1 , 2 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ip [ i ] = [ 0 , 2 ] <NEWLINE> <DEDENT> <DEDENT> ans = <STRING> <NEWLINE> res = [ 0 ] * n <NEWLINE> s = sum ( abc ) <NEWLINE> if s == 0 : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <DEDENT> elif s == 1 : <NEWLINE> <INDENT> for i in range ( n ) : <NEWLINE> <INDENT> i1 = ip [ i ] [ 0 ] <NEWLINE> i2 = ip [ i ] [ 1 ] <NEWLINE> ABC = ( i1 , i2 ) <NEWLINE> if ABC == ( 0 , 0 ) : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <DEDENT> <STRING> <NEWLINE> elif abc [ i1 ] + abc [ i2 ] == 1 : <NEWLINE> <INDENT> if abc [ i1 ] == 0 : <NEWLINE> <INDENT> abc [ i1 ] += 1 <NEWLINE> abc [ i2 ] -= 1 <NEWLINE> res [ i ] = i1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> abc [ i1 ] -= 1 <NEWLINE> abc [ i2 ] += 1 <NEWLINE> res [ i ] = i2 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> i1 = ip [ 0 ] [ 0 ] <NEWLINE> i2 = ip [ 0 ] [ 1 ] <NEWLINE> if abc [ i1 ] + abc [ i2 ] == 0 : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( n ) : <NEWLINE> <INDENT> i1 = ip [ i ] [ 0 ] <NEWLINE> i2 = ip [ i ] [ 1 ] <NEWLINE> if abc [ i1 ] * abc [ i2 ] == 0 : <NEWLINE> <INDENT> if abc [ i1 ] == 0 : <NEWLINE> <INDENT> abc [ i1 ] += 1 <NEWLINE> abc [ i2 ] -= 1 <NEWLINE> res [ i ] = i1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> abc [ i1 ] -= 1 <NEWLINE> abc [ i2 ] += 1 <NEWLINE> res [ i ] = i2 <NEWLINE> <DEDENT> <DEDENT> elif i + 1 < n and ip [ i + 1 ] != ip [ i ] : <NEWLINE> <INDENT> c = list ( set ( ip [ i ] ) & set ( ip [ i + 1 ] ) ) [ 0 ] <NEWLINE> if i1 == c : <NEWLINE> <INDENT> abc [ i1 ] += 1 <NEWLINE> abc [ i2 ] -= 1 <NEWLINE> res [ i ] = i1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> abc [ i1 ] -= 1 <NEWLINE> abc [ i2 ] += 1 <NEWLINE> res [ i ] = i2 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> abc [ i1 ] += 1 <NEWLINE> abc [ i2 ] -= 1 <NEWLINE> res [ i ] = i1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> dic = { 0 : <STRING> , 1 : <STRING> , 2 : <STRING> } <NEWLINE> if ans == <STRING> : <NEWLINE> <INDENT> for i in range ( n ) : <NEWLINE> <INDENT> print ( dic [ res [ i ] ] ) <NEWLINE> <STRING> <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> <NL> <NL> S , stack = [ ] , [ ] <NEWLINE> N = 0 <NEWLINE> <NL> <NL> def main ( ) -> None : <NEWLINE> <INDENT> global N <NEWLINE> N , A , B , C = rmi ( ) <NEWLINE> for n in range ( N ) : <NEWLINE> <INDENT> S . append ( r ( ) ) <NEWLINE> <DEDENT> enable = dfs ( stack , 0 , A , B , C ) <NEWLINE> w ( <STRING> if enable else <STRING> ) <NEWLINE> if enable : <NEWLINE> <INDENT> wm ( * stack , delim = <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def dfs ( stack , index , a , b , c ) -> bool : <NEWLINE> <INDENT> if N <= index : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> inst = S [ index ] <NEWLINE> if inst == <STRING> : <NEWLINE> <INDENT> if a <= 0 and b <= 0 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> if 0 < a : <NEWLINE> <INDENT> stack . append ( <STRING> ) <NEWLINE> result = dfs ( stack , index + 1 , a - 1 , b + 1 , c ) <NEWLINE> if result : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> stack . pop ( ) <NEWLINE> <DEDENT> <DEDENT> if 0 < b : <NEWLINE> <INDENT> stack . append ( <STRING> ) <NEWLINE> result = dfs ( stack , index + 1 , a + 1 , b - 1 , c ) <NEWLINE> if result : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> stack . pop ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> elif inst == <STRING> : <NEWLINE> <INDENT> if a <= 0 and c <= 0 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> if 0 < a : <NEWLINE> <INDENT> stack . append ( <STRING> ) <NEWLINE> result = dfs ( stack , index + 1 , a - 1 , b , c + 1 ) <NEWLINE> if result : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> stack . pop ( ) <NEWLINE> <DEDENT> <DEDENT> if 0 < c : <NEWLINE> <INDENT> stack . append ( <STRING> ) <NEWLINE> result = dfs ( stack , index + 1 , a + 1 , b , c - 1 ) <NEWLINE> if result : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> stack . pop ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if b <= 0 and c <= 0 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> if 0 < b : <NEWLINE> <INDENT> stack . append ( <STRING> ) <NEWLINE> result = dfs ( stack , index + 1 , a , b - 1 , c + 1 ) <NEWLINE> if result : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> stack . pop ( ) <NEWLINE> <DEDENT> <DEDENT> if 0 < c : <NEWLINE> <INDENT> stack . append ( <STRING> ) <NEWLINE> result = dfs ( stack , index + 1 , a , b + 1 , c - 1 ) <NEWLINE> if result : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> stack . pop ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return False <NEWLINE> <NL> <NL> <DEDENT> def r ( ) -> str : <NEWLINE> <INDENT> return input ( ) . strip ( ) <NEWLINE> <NL> <NL> <DEDENT> def ri ( ) -> int : <NEWLINE> <INDENT> return int ( r ( ) ) <NEWLINE> <NL> <NL> <DEDENT> def rmi ( delim : str = <STRING> ) -> tuple : <NEWLINE> <INDENT> return tuple ( map ( int , input ( ) . split ( delim ) ) ) <NEWLINE> <NL> <NL> <DEDENT> def w ( data ) -> None : <NEWLINE> <INDENT> print ( data ) <NEWLINE> <NL> <NL> <DEDENT> def wm ( * data , delim : str = <STRING> ) -> None : <NEWLINE> <INDENT> print ( delim . join ( map ( str , data ) ) ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 10 ) <NEWLINE> main ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> n = int ( input ( ) ) <NEWLINE> h_list = input ( ) . split ( ) <NEWLINE> h_list = [ int ( h ) for h in h_list ] <NEWLINE> <NL> count = 0 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> a_height = h_list [ i ] <NEWLINE> if i + 21 < n : <NEWLINE> <INDENT> n_aa = i + 21 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> n_aa = n <NEWLINE> <DEDENT> for k in range ( i + 1 + a_height , n_aa ) : <NEWLINE> <INDENT> b_height = h_list [ k ] <NEWLINE> if k - i == a_height + b_height : <NEWLINE> <INDENT> count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> n , a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> s_list = [ input ( ) for _ in [ 0 ] * n ] <NEWLINE> <NL> if a == b == c == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a + b + c == 1 : <NEWLINE> <INDENT> if a == 1 : <NEWLINE> <INDENT> color = <STRING> <NEWLINE> <DEDENT> elif b == 1 : <NEWLINE> <INDENT> color = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> color = <STRING> <NEWLINE> <DEDENT> l = [ ] <NEWLINE> for i in s_list : <NEWLINE> <INDENT> if color not in i : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> return <NEWLINE> <DEDENT> j = list ( i ) <NEWLINE> j . remove ( color ) <NEWLINE> color = j [ 0 ] <NEWLINE> l . append ( color ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> for i in l : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( 1 / 0 ) <NEWLINE> s_list += [ <STRING> ] <NEWLINE> l = [ ] <NEWLINE> for j , i in enumerate ( s_list [ : - 1 ] ) : <NEWLINE> <INDENT> if i == <STRING> : <NEWLINE> <INDENT> if a >= 2 : <NEWLINE> <INDENT> l . append ( <STRING> ) <NEWLINE> a -= 1 <NEWLINE> b += 1 <NEWLINE> <DEDENT> elif b >= 2 : <NEWLINE> <INDENT> l . append ( <STRING> ) <NEWLINE> a += 1 <NEWLINE> b -= 1 <NEWLINE> <DEDENT> elif a == b == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> return <NEWLINE> <DEDENT> elif a == 1 and b == 0 : <NEWLINE> <INDENT> l . append ( <STRING> ) <NEWLINE> a -= 1 <NEWLINE> b += 1 <NEWLINE> <DEDENT> elif a == 0 and b == 1 : <NEWLINE> <INDENT> l . append ( <STRING> ) <NEWLINE> a += 1 <NEWLINE> b -= 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if <STRING> in s_list [ j + 1 ] : <NEWLINE> <INDENT> l . append ( <STRING> ) <NEWLINE> a += 1 <NEWLINE> b -= 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> l . append ( <STRING> ) <NEWLINE> a -= 1 <NEWLINE> b += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> elif i == <STRING> : <NEWLINE> <INDENT> if b >= 2 : <NEWLINE> <INDENT> l . append ( <STRING> ) <NEWLINE> b -= 1 <NEWLINE> c += 1 <NEWLINE> <DEDENT> elif c >= 2 : <NEWLINE> <INDENT> l . append ( <STRING> ) <NEWLINE> b += 1 <NEWLINE> c -= 1 <NEWLINE> <DEDENT> elif b == c == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> return <NEWLINE> <DEDENT> elif b == 1 and c == 0 : <NEWLINE> <INDENT> l . append ( <STRING> ) <NEWLINE> b -= 1 <NEWLINE> c += 1 <NEWLINE> <DEDENT> elif b == 0 and c == 1 : <NEWLINE> <INDENT> l . append ( <STRING> ) <NEWLINE> b += 1 <NEWLINE> c -= 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if <STRING> in s_list [ j + 1 ] : <NEWLINE> <INDENT> l . append ( <STRING> ) <NEWLINE> b += 1 <NEWLINE> c -= 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> l . append ( <STRING> ) <NEWLINE> b -= 1 <NEWLINE> c += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if c >= 2 : <NEWLINE> <INDENT> l . append ( <STRING> ) <NEWLINE> c -= 1 <NEWLINE> a += 1 <NEWLINE> <DEDENT> elif a >= 2 : <NEWLINE> <INDENT> l . append ( <STRING> ) <NEWLINE> c += 1 <NEWLINE> a -= 1 <NEWLINE> <DEDENT> elif c == a == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> return <NEWLINE> <DEDENT> elif c == 1 and a == 0 : <NEWLINE> <INDENT> l . append ( <STRING> ) <NEWLINE> c -= 1 <NEWLINE> a += 1 <NEWLINE> <DEDENT> elif c == 0 and a == 1 : <NEWLINE> <INDENT> l . append ( <STRING> ) <NEWLINE> c += 1 <NEWLINE> a -= 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if <STRING> in s_list [ j + 1 ] : <NEWLINE> <INDENT> l . append ( <STRING> ) <NEWLINE> c += 1 <NEWLINE> a -= 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> l . append ( <STRING> ) <NEWLINE> c -= 1 <NEWLINE> a += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> for i in l : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> main ( ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> N , A , B , C = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> S = [ input ( ) for _ in range ( N ) ] <NEWLINE> D = { <NEWLINE> <INDENT> <STRING> : A + B , <NEWLINE> <STRING> : B + C , <NEWLINE> <STRING> : A + C <NEWLINE> <DEDENT> } <NEWLINE> ans = list ( ) <NEWLINE> for i , s in enumerate ( S ) : <NEWLINE> <INDENT> if D [ s ] == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> return <NEWLINE> <DEDENT> if s == <STRING> : <NEWLINE> <INDENT> if ( D [ <STRING> ] < D [ <STRING> ] ) or ( i < N and S [ i + 1 ] == <STRING> and D [ <STRING> ] == D [ <STRING> ] == 1 ) : <NEWLINE> <INDENT> ans . append ( <STRING> ) <NEWLINE> D [ <STRING> ] += 1 <NEWLINE> D [ <STRING> ] -= 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans . append ( <STRING> ) <NEWLINE> D [ <STRING> ] -= 1 <NEWLINE> D [ <STRING> ] += 1 <NEWLINE> <DEDENT> <DEDENT> elif s == <STRING> : <NEWLINE> <INDENT> if ( D [ <STRING> ] < D [ <STRING> ] ) or ( i < N and S [ i + 1 ] == <STRING> and D [ <STRING> ] == D [ <STRING> ] == 1 ) : <NEWLINE> <INDENT> ans . append ( <STRING> ) <NEWLINE> D [ <STRING> ] += 1 <NEWLINE> D [ <STRING> ] -= 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans . append ( <STRING> ) <NEWLINE> D [ <STRING> ] -= 1 <NEWLINE> D [ <STRING> ] += 1 <NEWLINE> <DEDENT> <DEDENT> else : <COMMENT> <NEWLINE> <INDENT> if ( D [ <STRING> ] < D [ <STRING> ] ) or ( i < N and S [ i + 1 ] == <STRING> and D [ <STRING> ] == D [ <STRING> ] == 1 ) : <NEWLINE> <INDENT> ans . append ( <STRING> ) <NEWLINE> D [ <STRING> ] += 1 <NEWLINE> D [ <STRING> ] -= 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans . append ( <STRING> ) <NEWLINE> D [ <STRING> ] -= 1 <NEWLINE> D [ <STRING> ] += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> for a in ans : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> n , a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> count = { <NEWLINE> <INDENT> <STRING> : a , <NEWLINE> <STRING> : b , <NEWLINE> <STRING> : c <NEWLINE> <DEDENT> } <NEWLINE> queries = [ ] <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> query = tuple ( input ( ) ) <NEWLINE> queries . append ( query ) <NEWLINE> <NL> <NL> <DEDENT> def solve ( plus , minus ) : <NEWLINE> <INDENT> count [ plus ] += 1 <NEWLINE> count [ minus ] += 1 <NEWLINE> ans . append ( plus ) <NEWLINE> <NL> <NL> <DEDENT> ans = [ ] <NEWLINE> for idx , ( x , y ) in enumerate ( queries ) : <NEWLINE> <INDENT> if count [ x ] == count [ y ] == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> if count [ x ] == count [ y ] == 1 : <NEWLINE> <INDENT> if idx == n - 1 : <NEWLINE> <INDENT> solve ( x , y ) <NEWLINE> break <NEWLINE> <NL> <DEDENT> nex = queries [ idx + 1 ] <NEWLINE> if x in nex : <NEWLINE> <INDENT> solve ( x , y ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> solve ( y , x ) <NEWLINE> <NL> <DEDENT> <DEDENT> elif count [ x ] >= count [ y ] : <NEWLINE> <INDENT> solve ( x , y ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> solve ( y , x ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> for c in ans : <NEWLINE> <INDENT> print ( c ) <NEWLINE> <DEDENT>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> n , a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> s_ = input ( ) . split ( ) <NEWLINE> ans = <STRING> <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> s1 , s2 = s_ [ i ] <NEWLINE> if s2 == <STRING> : <NEWLINE> <INDENT> if i != n - 1 : <NEWLINE> <INDENT> if s_ [ i + 1 ] == <STRING> and c == 0 and a <= 1 : <NEWLINE> <INDENT> a , b , ans = ( a + 1 , b - 1 , ans + <STRING> ) <NEWLINE> <DEDENT> elif s_ [ i + 1 ] == <STRING> and c == 0 and b <= 1 : <NEWLINE> <INDENT> a , b , ans = ( a - 1 , b + 1 , ans + <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a , b , ans = ( a - 1 , b + 1 , ans + <STRING> ) if a > b else ( a + 1 , b - 1 , ans + <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> a , b , ans = ( a - 1 , b + 1 , ans + <STRING> ) if a > b else ( a + 1 , b - 1 , ans + <STRING> ) <NEWLINE> <DEDENT> if min ( a , b ) == - 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> elif s1 == <STRING> : <NEWLINE> <INDENT> if i != n - 1 : <NEWLINE> <INDENT> if s_ [ i + 1 ] == <STRING> and b == 0 and a <= 1 : <NEWLINE> <INDENT> a , c , ans = ( a + 1 , c - 1 , ans + <STRING> ) <NEWLINE> <DEDENT> elif s_ [ i + 1 ] == <STRING> and b == 0 and c <= 1 : <NEWLINE> <INDENT> a , c , ans = ( a - 1 , c + 1 , ans + <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a , c , ans = ( a - 1 , c + 1 , ans + <STRING> ) if a > c else ( a + 1 , c - 1 , ans + <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> a , c , ans = ( a - 1 , c + 1 , ans + <STRING> ) if a > c else ( a + 1 , c - 1 , ans + <STRING> ) <NEWLINE> <DEDENT> if min ( a , c ) == - 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if i != n - 1 : <NEWLINE> <INDENT> if s_ [ i + 1 ] == <STRING> and a == 0 and b <= 1 : <NEWLINE> <INDENT> b , c , ans = ( b + 1 , c - 1 , ans + <STRING> ) <NEWLINE> <DEDENT> elif s_ [ i + 1 ] == <STRING> and a == 0 and c <= 1 : <NEWLINE> <INDENT> b , c , ans = ( b - 1 , c + 1 , ans + <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> b , c , ans = ( b - 1 , c + 1 , ans + <STRING> ) if b > c else ( b + 1 , c - 1 , ans + <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> b , c , ans = ( b - 1 , c + 1 , ans + <STRING> ) if b > c else ( b + 1 , c - 1 , ans + <STRING> ) <NEWLINE> <DEDENT> if min ( b , c ) == - 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> for j in range ( n ) : <NEWLINE> <INDENT> print ( ans [ j ] ) <NEWLINE> <NL> <DEDENT> <DEDENT>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> n , * abc = map ( int , input ( ) . split ( ) ) <NEWLINE> s = [ input ( ) for _ in range ( n ) ] <NEWLINE> cond = { <STRING> : ( 0 , 1 ) , <STRING> : ( 0 , 2 ) , <STRING> : ( 1 , 2 ) } <NEWLINE> legend = ( <STRING> , <STRING> , <STRING> ) <NEWLINE> ans = [ ] <NEWLINE> <NL> <NL> def dfs ( i ) : <NEWLINE> <INDENT> if - 1 in abc : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> elif i == n : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> print ( * ans , sep = <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <COMMENT> <NL> <DEDENT> else : <NEWLINE> <INDENT> idx1 , idx2 = cond [ s [ i ] ] <NEWLINE> abc [ idx1 ] += 1 <NEWLINE> abc [ idx2 ] -= 1 <NEWLINE> ans . append ( legend [ idx1 ] ) <NEWLINE> dfs ( i + 1 ) <NEWLINE> ans . pop ( ) <NEWLINE> abc [ idx1 ] -= 1 <NEWLINE> abc [ idx2 ] += 1 <NEWLINE> <NL> abc [ idx1 ] -= 1 <NEWLINE> abc [ idx2 ] += 1 <NEWLINE> ans . append ( legend [ idx2 ] ) <NEWLINE> dfs ( i + 1 ) <NEWLINE> ans . pop ( ) <NEWLINE> abc [ idx1 ] += 1 <NEWLINE> abc [ idx2 ] -= 1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> dfs ( 0 ) <NEWLINE> print ( <STRING> ) <NEWLINE>
N , A , B , C = map ( int , input ( ) . split ( ) ) <NEWLINE> S = [ list ( input ( ) ) for i in range ( N ) ] <NEWLINE> <NL> v = [ A , B , C ] <NEWLINE> id_d = { <STRING> : 0 , <STRING> : 1 , <STRING> : 2 } <NEWLINE> ans = [ 0 ] * N <NEWLINE> for i , s in enumerate ( S ) : <NEWLINE> <INDENT> s1 , s2 = s <NEWLINE> id1 , id2 = id_d [ s1 ] , id_d [ s2 ] <NEWLINE> v1 , v2 = v [ id1 ] , v [ id2 ] <NEWLINE> if v1 == v2 == 0 : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> quit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> pre_s1 , pre_s2 = S [ i - 1 ] <NEWLINE> pre_id1 , pre_id2 = id_d [ pre_s1 ] , id_d [ pre_s2 ] <NEWLINE> if pre_s1 in [ s1 , s2 ] : <NEWLINE> <INDENT> v [ pre_id1 ] += 2 <NEWLINE> v [ pre_id2 ] -= 2 <NEWLINE> ans [ i - 1 ] = pre_s1 <NEWLINE> if v [ pre_id2 ] < 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> quit ( ) <NEWLINE> <DEDENT> <DEDENT> else : <COMMENT> <NEWLINE> <INDENT> v [ pre_id2 ] += 2 <NEWLINE> v [ pre_id1 ] -= 2 <NEWLINE> ans [ i - 1 ] = pre_s2 <NEWLINE> if v [ pre_id1 ] < 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> quit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> v1 , v2 = v [ id1 ] , v [ 1 d2 ] <NEWLINE> if v1 >= v2 : <NEWLINE> <INDENT> ans [ i ] = s2 <NEWLINE> v [ id1 ] -= 1 <NEWLINE> v [ id2 ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans [ i ] = s1 <NEWLINE> v [ id1 ] += 1 <NEWLINE> v [ id2 ] -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> print ( * ans , sep = <STRING> ) <NEWLINE>
n , a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = [ ] <NEWLINE> slist = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> slist . append ( s ) <NEWLINE> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> s = slist [ ] <NEWLINE> if s == <STRING> : <NEWLINE> <INDENT> if a == 0 : <NEWLINE> <INDENT> a += 1 <NEWLINE> b -= 1 <NEWLINE> ans . append ( <STRING> ) <NEWLINE> <DEDENT> elif b == 0 : <NEWLINE> <INDENT> a -= 1 <NEWLINE> b += 1 <NEWLINE> ans . append ( <STRING> ) <NEWLINE> <DEDENT> elif slist [ ( i + 1 ) % n ] == <STRING> : <NEWLINE> <INDENT> if a > b : <NEWLINE> <INDENT> a -= 1 <NEWLINE> b += 1 <NEWLINE> ans . append ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a += 1 <NEWLINE> b -= 1 <NEWLINE> ans . append ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> elif slist [ ( i + 1 ) % n ] == <STRING> : <NEWLINE> <INDENT> a += 1 <NEWLINE> b -= 1 <NEWLINE> ans . append ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a -= 1 <NEWLINE> b += 1 <NEWLINE> ans . append ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> elif s == <STRING> : <NEWLINE> <INDENT> if a == 0 : <NEWLINE> <INDENT> a += 1 <NEWLINE> c -= 1 <NEWLINE> ans . append ( <STRING> ) <NEWLINE> <DEDENT> elif c == 0 : <NEWLINE> <INDENT> a -= 1 <NEWLINE> c += 1 <NEWLINE> ans . append ( <STRING> ) <NEWLINE> <DEDENT> elif slist [ ( i + 1 ) % n ] == <STRING> : <NEWLINE> <INDENT> if a > c : <NEWLINE> <INDENT> a -= 1 <NEWLINE> c += 1 <NEWLINE> ans . append ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a += 1 <NEWLINE> c -= 1 <NEWLINE> ans . append ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> elif slist [ ( i + 1 ) % n ] == <STRING> : <NEWLINE> <INDENT> a += 1 <NEWLINE> c -= 1 <NEWLINE> ans . append ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a -= 1 <NEWLINE> c += 1 <NEWLINE> ans . append ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if b == 0 : <NEWLINE> <INDENT> b += 1 <NEWLINE> c -= 1 <NEWLINE> ans . append ( <STRING> ) <NEWLINE> <DEDENT> elif c == 0 : <NEWLINE> <INDENT> b -= 1 <NEWLINE> c += 1 <NEWLINE> ans . append ( <STRING> ) <NEWLINE> <DEDENT> elif slist [ ( i + 1 ) % n ] == <STRING> : <NEWLINE> <INDENT> if b > c : <NEWLINE> <INDENT> b -= 1 <NEWLINE> c += 1 <NEWLINE> ans . append ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> b += 1 <NEWLINE> c -= 1 <NEWLINE> ans . append ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> elif slist [ ( i + 1 ) % n ] == <STRING> : <NEWLINE> <INDENT> c += 1 <NEWLINE> b -= 1 <NEWLINE> ans . append ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> c -= 1 <NEWLINE> b += 1 <NEWLINE> ans . append ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> if a < 0 or b < 0 or c < 0 : <NEWLINE> <INDENT> ans . clear ( ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if len ( ans ) == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> print ( ans [ i ] ) <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> <NL> f = open ( <STRING> ) <NEWLINE> <NL> <COMMENT> <NL> N , A , B , C = map ( int , f . readline ( ) . split ( ) ) <NEWLINE> stock = [ A , B , C ] <NEWLINE> <NL> s = [ f . readline ( ) . rstrip ( <STRING> ) for _ in range ( N ) ] <NEWLINE> sum_num = sum ( list ( [ A , B , C ] ) ) <NEWLINE> to_char = [ <STRING> , <STRING> , <STRING> ] <NEWLINE> <NL> target = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> target . append ( [ 0 , 1 ] ) <NEWLINE> <DEDENT> elif s [ i ] == <STRING> : <NEWLINE> <INDENT> target . append ( [ 1 , 2 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> target . append ( [ 0 , 2 ] ) <NEWLINE> <DEDENT> <DEDENT> if sum_num == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> elif sum_num == 1 : <NEWLINE> <INDENT> answer = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if stock [ target [ i ] [ 0 ] ] == 1 : <NEWLINE> <INDENT> stock [ target [ i ] [ 0 ] ] -= 1 <NEWLINE> stock [ target [ i ] [ 1 ] ] += 1 <NEWLINE> answer . append ( target [ i ] [ 1 ] ) <NEWLINE> <DEDENT> elif stock [ target [ i ] [ 1 ] ] == 1 : <NEWLINE> <INDENT> stock [ target [ i ] [ 1 ] ] -= 1 <NEWLINE> stock [ target [ i ] [ 0 ] ] += 1 <NEWLINE> answer . append ( target [ i ] [ 0 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> to_char [ answer [ i ] ] <NEWLINE> <DEDENT> <DEDENT> elif sum_num >= 2 : <NEWLINE> <INDENT> if stock [ target [ 0 ] [ 0 ] ] == 0 and stock [ target [ 0 ] [ 1 ] ] == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> if target [ i ] [ 0 ] in target [ i + 1 ] and stock [ target [ i ] [ 1 ] ] >= 1 : <NEWLINE> <INDENT> stock [ target [ i ] [ 0 ] ] += 1 <NEWLINE> stock [ target [ i ] [ 1 ] ] -= 1 <NEWLINE> print ( to_char [ target [ i ] [ 0 ] ] ) <NEWLINE> <DEDENT> elif stock [ target [ i ] [ 0 ] ] >= 1 : <NEWLINE> <INDENT> stock [ target [ i ] [ 1 ] ] += 1 <NEWLINE> stock [ target [ i ] [ 0 ] ] -= 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> stock [ target [ i ] [ 0 ] ] += 1 <NEWLINE> stock [ target [ i ] [ 1 ] ] -= 1 <NEWLINE> print ( to_char [ target [ i ] [ 1 ] ] ) <NEWLINE> <DEDENT> <DEDENT> if stock [ target [ - 1 ] [ 0 ] ] == 0 : <NEWLINE> <INDENT> print ( to_char [ target [ - 1 ] [ 0 ] ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( to_char [ target [ - 1 ] [ 1 ] ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
n , a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = [ ] <NEWLINE> ks = [ input ( ) for _ in range ( n ) ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> k = k [ 0 ] <NEWLINE> if k == <STRING> : <NEWLINE> <INDENT> if a == 0 and b == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> quit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if a > b : <NEWLINE> <INDENT> a -= 1 <NEWLINE> b += 1 <NEWLINE> ans . append ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if a == 1 and b == 1 and len ( ks ) > 1 : <NEWLINE> <INDENT> if ks [ 1 ] == <STRING> : <NEWLINE> <INDENT> b -= 1 <NEWLINE> a += 1 <NEWLINE> ans . append ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a -= 1 <NEWLINE> b += 1 <NEWLINE> ans . append ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> b -= 1 <NEWLINE> a += 1 <NEWLINE> ans . append ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if k == <STRING> : <NEWLINE> <INDENT> if c == 0 and b == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> quit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if c > b : <NEWLINE> <INDENT> c -= 1 <NEWLINE> b += 1 <NEWLINE> ans . append ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if c == 1 and b == 1 and len ( ks ) > 1 : <NEWLINE> <INDENT> if ks [ 1 ] == <STRING> : <NEWLINE> <INDENT> b -= 1 <NEWLINE> c += 1 <NEWLINE> ans . append ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> c -= 1 <NEWLINE> b += 1 <NEWLINE> ans . append ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> b -= 1 <NEWLINE> c += 1 <NEWLINE> ans . append ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if k == <STRING> : <NEWLINE> <INDENT> if a == 0 and c == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> quit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if a > c : <NEWLINE> <INDENT> a -= 1 <NEWLINE> c += 1 <NEWLINE> ans . append ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if a == 1 and c == 1 and len ( ks ) > 1 : <NEWLINE> <INDENT> if ks [ 1 ] == <STRING> : <NEWLINE> <INDENT> a -= 1 <NEWLINE> c += 1 <NEWLINE> ans . append ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> c -= 1 <NEWLINE> a += 1 <NEWLINE> ans . append ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> c -= 1 <NEWLINE> a += 1 <NEWLINE> ans . append ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> del ( ks [ 0 ] ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> for i in ans : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT>
import sys <NEWLINE> n , a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> slist = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> slist . append ( input ( ) ) <NEWLINE> <DEDENT> output = [ ] <NEWLINE> ynflag = True <NEWLINE> <NL> def abc1 ( s ) : <NEWLINE> <INDENT> global a <NEWLINE> global b <NEWLINE> global c <NEWLINE> global output <NEWLINE> global ynflag <NEWLINE> <NL> <NL> if s == <STRING> : <NEWLINE> <INDENT> if a == 1 : <NEWLINE> <INDENT> a -= 1 <NEWLINE> b += 1 <NEWLINE> output . append ( <STRING> ) <NEWLINE> return True <NEWLINE> <DEDENT> elif b == 1 : <NEWLINE> <INDENT> a += 1 <NEWLINE> b -= 1 <NEWLINE> output . append ( <STRING> ) <NEWLINE> return True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> <DEDENT> if s == <STRING> : <NEWLINE> <INDENT> if a == 1 : <NEWLINE> <INDENT> a -= 1 <NEWLINE> c += 1 <NEWLINE> output . append ( <STRING> ) <NEWLINE> return True <NEWLINE> <DEDENT> elif c == 1 : <NEWLINE> <INDENT> a += 1 <NEWLINE> c -= 1 <NEWLINE> output . append ( <STRING> ) <NEWLINE> return True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> <DEDENT> if s == <STRING> : <NEWLINE> <INDENT> if b == 1 : <NEWLINE> <INDENT> b -= 1 <NEWLINE> c += 1 <NEWLINE> output . append ( <STRING> ) <NEWLINE> return True <NEWLINE> <DEDENT> elif c == 1 : <NEWLINE> <INDENT> b += 1 <NEWLINE> c -= 1 <NEWLINE> output . append ( <STRING> ) <NEWLINE> return True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return False <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> def abc2 ( i ) : <NEWLINE> <INDENT> global a <NEWLINE> global b <NEWLINE> global c <NEWLINE> global output <NEWLINE> global slist <NEWLINE> s = slist [ i ] <NEWLINE> <NL> if i == len ( slist ) - 1 : <NEWLINE> <INDENT> tsugi = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> tsugi = slist [ i + 1 ] <NEWLINE> <NL> <DEDENT> elif s == <STRING> : <NEWLINE> <INDENT> if a + b == 0 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> elif a == 1 and b == 1 and c == 0 : <NEWLINE> <INDENT> if tsugi == <STRING> : <NEWLINE> <INDENT> a -= 1 <NEWLINE> b += 1 <NEWLINE> output . append ( <STRING> ) <NEWLINE> return True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a += 1 <NEWLINE> b -= 1 <NEWLINE> output . append ( <STRING> ) <NEWLINE> return True <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if a >= b : <NEWLINE> <INDENT> a -= 1 <NEWLINE> b += 1 <NEWLINE> output . append ( <STRING> ) <NEWLINE> return True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a += 1 <NEWLINE> b -= 1 <NEWLINE> output . append ( <STRING> ) <NEWLINE> return True <NEWLINE> <DEDENT> <DEDENT> <DEDENT> elif s == <STRING> : <NEWLINE> <INDENT> if a + c == 0 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> elif a == 1 and c == 1 and b == 0 : <NEWLINE> <INDENT> if tsugi == <STRING> : <NEWLINE> <INDENT> a -= 1 <NEWLINE> c += 1 <NEWLINE> output . append ( <STRING> ) <NEWLINE> return True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a += 1 <NEWLINE> c -= 1 <NEWLINE> output . append ( <STRING> ) <NEWLINE> return True <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if a >= c : <NEWLINE> <INDENT> a -= 1 <NEWLINE> c += 1 <NEWLINE> output . append ( <STRING> ) <NEWLINE> return True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a += 1 <NEWLINE> c -= 1 <NEWLINE> output . append ( <STRING> ) <NEWLINE> return True <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if b + c == 0 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> elif b == 1 and c == 1 and a == 0 : <NEWLINE> <INDENT> if tsugi == <STRING> : <NEWLINE> <INDENT> b -= 1 <NEWLINE> c += 1 <NEWLINE> output . append ( <STRING> ) <NEWLINE> return True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> b += 1 <NEWLINE> c -= 1 <NEWLINE> output . append ( <STRING> ) <NEWLINE> return True <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if b >= c : <NEWLINE> <INDENT> b -= 1 <NEWLINE> c += 1 <NEWLINE> output . append ( <STRING> ) <NEWLINE> return True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> b += 1 <NEWLINE> c -= 1 <NEWLINE> output . append ( <STRING> ) <NEWLINE> return True <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if a == 0 and b == 0 and c == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> if a + b + c == 1 : <NEWLINE> <INDENT> for s in slist : <NEWLINE> <INDENT> ynflag = abc1 ( s ) <NEWLINE> if not ynflag : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( n ) : <NEWLINE> <INDENT> ynflag = abc2 ( i ) <NEWLINE> if not ynflag : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> for out in output : <NEWLINE> <INDENT> print ( out ) <NEWLINE> <DEDENT> <DEDENT>
def end ( ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <NL> <NL> <DEDENT> n , a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> s = [ input ( ) for i in range ( n ) ] <NEWLINE> log = [ ] <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <COMMENT> <NL> <INDENT> if a == 1 and b == 1 : <NEWLINE> <COMMENT> <NL> <INDENT> if i == n - 1 or s [ i + 1 ] == <STRING> or s [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> a += 1 <NEWLINE> b -= 1 <NEWLINE> log . append ( <STRING> ) <NEWLINE> <COMMENT> <NL> <DEDENT> else : <COMMENT> <NEWLINE> <INDENT> a -= 1 <NEWLINE> b += 1 <NEWLINE> log . append ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> elif a == 0 and b == 0 : <NEWLINE> <INDENT> end ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if a >= b : <NEWLINE> <INDENT> a -= 1 <NEWLINE> b += 1 <NEWLINE> log . append ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a += 1 <NEWLINE> b -= 1 <NEWLINE> log . append ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> elif s [ i ] == <STRING> : <NEWLINE> <COMMENT> <NL> <INDENT> if a == 1 and c == 1 : <NEWLINE> <COMMENT> <NL> <INDENT> if i == n - 1 or s [ i + 1 ] == <STRING> or s [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> a += 1 <NEWLINE> c -= 1 <NEWLINE> log . append ( <STRING> ) <NEWLINE> <COMMENT> <NL> <DEDENT> else : <COMMENT> <NEWLINE> <INDENT> c += 1 <NEWLINE> a -= 1 <NEWLINE> log . append ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> elif a == 0 and c == 0 : <NEWLINE> <INDENT> end ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if a >= c : <NEWLINE> <INDENT> a -= 1 <NEWLINE> c += 1 <NEWLINE> log . append ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a += 1 <NEWLINE> c -= 1 <NEWLINE> log . append ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <COMMENT> <NEWLINE> <COMMENT> <NL> <INDENT> if c == 1 and b == 1 : <NEWLINE> <COMMENT> <NL> <INDENT> if i == n - 1 or s [ i + 1 ] == <STRING> or s [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> c -= 1 <NEWLINE> b += 1 <NEWLINE> log . append ( <STRING> ) <NEWLINE> <COMMENT> <NL> <DEDENT> else : <COMMENT> <NEWLINE> <INDENT> c += 1 <NEWLINE> b -= 1 <NEWLINE> log . append ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> elif a == 0 and c == 0 : <NEWLINE> <INDENT> end ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if b >= c : <NEWLINE> <INDENT> b -= 1 <NEWLINE> c += 1 <NEWLINE> log . append ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> b += 1 <NEWLINE> c -= 1 <NEWLINE> log . append ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> print ( * log , sep = <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
<NL> N , a , b , c , * S = open ( 0 ) . read ( ) . split ( ) <NEWLINE> N , a , b , c = map ( int , ( N , a , b , c ) ) <NEWLINE> <NL> flg = a * b * c == 0 and a + b + c = 2 <NEWLINE> <NL> ans = [ ] <NEWLINE> for i , s in enumerate ( S ) : <NEWLINE> <INDENT> if s == <STRING> : <NEWLINE> <INDENT> if flg and a * b == 1 and i < N - 1 : <NEWLINE> <INDENT> s_ = S [ i + 1 ] <NEWLINE> if s_ == <STRING> : <NEWLINE> <INDENT> ans . append ( <STRING> ) <NEWLINE> a += 1 <NEWLINE> b -= 1 <NEWLINE> continue <NEWLINE> <DEDENT> elif s_ == <STRING> : <NEWLINE> <INDENT> ans . append ( <STRING> ) <NEWLINE> a -= 1 <NEWLINE> b += 1 <NEWLINE> continue <NEWLINE> <NL> <DEDENT> <DEDENT> ans . append ( <STRING> if a > b else <STRING> ) <NEWLINE> if a > b : <NEWLINE> <INDENT> a -= 1 <NEWLINE> b += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a += 1 <NEWLINE> b -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> elif s == <STRING> : <NEWLINE> <INDENT> if flg and a * c == 1 and i < N - 1 : <NEWLINE> <INDENT> s_ = S [ i + 1 ] <NEWLINE> if s_ == <STRING> : <NEWLINE> <INDENT> ans . append ( <STRING> ) <NEWLINE> a += 1 <NEWLINE> c -= 1 <NEWLINE> continue <NEWLINE> <DEDENT> elif s_ == <STRING> : <NEWLINE> <INDENT> ans . append ( <STRING> ) <NEWLINE> a -= 1 <NEWLINE> c += 1 <NEWLINE> continue <NEWLINE> <NL> <DEDENT> <DEDENT> ans . append ( <STRING> if a > c else <STRING> ) <NEWLINE> if a > c : <NEWLINE> <INDENT> a -= 1 <NEWLINE> c += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a += 1 <NEWLINE> c -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> elif s == <STRING> : <NEWLINE> <INDENT> if flg and b * c == 1 and i < N - 1 : <NEWLINE> <INDENT> s_ = S [ i + 1 ] <NEWLINE> if s_ == <STRING> : <NEWLINE> <INDENT> ans . append ( <STRING> ) <NEWLINE> b += 1 <NEWLINE> c -= 1 <NEWLINE> continue <NEWLINE> <DEDENT> elif s_ == <STRING> : <NEWLINE> <INDENT> ans . append ( <STRING> ) <NEWLINE> b -= 1 <NEWLINE> c += 1 <NEWLINE> continue <NEWLINE> <NL> <DEDENT> <DEDENT> ans . append ( <STRING> if b > c else <STRING> ) <NEWLINE> if b > c : <NEWLINE> <INDENT> b -= 1 <NEWLINE> c += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> b += 1 <NEWLINE> c -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if a < 0 or b < 0 or c < 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> [ print ( r ) for r in ans ] <NEWLINE>
sys . setrecursionlimit ( 10 ** 5 + 10 ) <NEWLINE> <NL> N , A , B , C = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> ans = list ( ) <NEWLINE> l = list ( ) <NEWLINE> <NL> for n in range ( N ) : <NEWLINE> <INDENT> l . append ( input ( ) ) <NEWLINE> <NL> <DEDENT> def dfs ( i , a , b , c ) : <NEWLINE> <INDENT> if i == N : <NEWLINE> <INDENT> return True <NEWLINE> <NL> <DEDENT> ss = l [ i ] <NEWLINE> if ss == <STRING> : <NEWLINE> <INDENT> if a == 0 and b == 0 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> if b > 0 and dfs ( i + 1 , a + 1 , b - 1 , c ) : <NEWLINE> <INDENT> ans . append ( <STRING> ) <NEWLINE> return True <NEWLINE> <DEDENT> if a > 0 and dfs ( i + 1 , a - 1 , b + 1 , c ) : <NEWLINE> <INDENT> ans . append ( <STRING> ) <NEWLINE> return True <NEWLINE> <DEDENT> <DEDENT> if ss == <STRING> : <NEWLINE> <INDENT> if a == 0 and c == 0 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> if c > 0 and dfs ( i + 1 , a + 1 , b , c - 1 ) : <NEWLINE> <INDENT> ans . append ( <STRING> ) <NEWLINE> return True <NEWLINE> <DEDENT> if a > 0 and dfs ( i + 1 , a - 1 , b , c + 1 ) : <NEWLINE> <INDENT> ans . append ( <STRING> ) <NEWLINE> return True <NEWLINE> <DEDENT> <DEDENT> if ss == <STRING> : <NEWLINE> <INDENT> if b == 0 and c == 0 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> if c > 0 and dfs ( i + 1 , a , b + 1 , c - 1 ) : <NEWLINE> <INDENT> ans . append ( <STRING> ) <NEWLINE> return True <NEWLINE> <DEDENT> if b > 0 and dfs ( i + 1 , a , b - 1 , c + 1 ) : <NEWLINE> <INDENT> ans . append ( <STRING> ) <NEWLINE> return True <NEWLINE> <DEDENT> <DEDENT> return False <NEWLINE> <NL> <DEDENT> dfs ( 0 , A , B , C ) <NEWLINE> <NL> if len ( ans ) > 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> for x in reversed ( ans ) : <NEWLINE> <INDENT> print ( x ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n , a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> s = [ input ( ) for _ in range ( n ) ] <NEWLINE> if ( a + b + c ) == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> if ( a + b + c ) == 1 or ( a + b + c ) >= 3 : <NEWLINE> <INDENT> ans = [ ] <NEWLINE> for i in s : <NEWLINE> <INDENT> if i == <STRING> : <NEWLINE> <INDENT> if a < b : ans . append ( <STRING> ) ; a += 1 ; b += - 1 ; c += 0 <NEWLINE> else : ans . append ( <STRING> ) ; a += - 1 ; b += 1 ; c += 0 <NEWLINE> <DEDENT> if i == <STRING> : <NEWLINE> <INDENT> if b < c : ans . append ( <STRING> ) ; a += 0 ; b += 1 ; c += - 1 <NEWLINE> else : ans . append ( <STRING> ) ; a += 0 ; b += - 1 ; c += 1 <NEWLINE> <DEDENT> if i == <STRING> : <NEWLINE> <INDENT> if a < c : ans . append ( <STRING> ) ; a += 1 ; b += 0 ; c += - 1 <NEWLINE> else : ans . append ( <STRING> ) ; a += - 1 ; b += 0 ; c += 1 <NEWLINE> <DEDENT> if min ( a , b , c ) < 0 : <NEWLINE> <INDENT> exit ( print ( <STRING> ) ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> for i in ans : print ( i ) <NEWLINE> <DEDENT> if ( a + b + c ) == 2 : <NEWLINE> <INDENT> ans = [ ] <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> if a == b : <NEWLINE> <INDENT> if s [ i + 1 ] == <STRING> : ans . append ( <STRING> ) ; a += 1 ; b += - 1 ; c += 0 <NEWLINE> else : ans . append ( <STRING> ) ; a += - 1 ; b += 1 ; c += 0 <NEWLINE> <DEDENT> elif a < b : ans . append ( <STRING> ) ; a += 1 ; b += - 1 ; c += 0 <NEWLINE> else : ans . append ( <STRING> ) ; a += - 1 ; b += 1 ; c += 0 <NEWLINE> <DEDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> if b == c : <NEWLINE> <INDENT> if s [ i + 1 ] == <STRING> : ans . append ( <STRING> ) ; a += 0 ; b += - 1 ; c += 1 <NEWLINE> else : ans . append ( <STRING> ) ; a += 0 ; b += 1 ; c += - 1 <NEWLINE> <DEDENT> elif b < c : ans . append ( <STRING> ) ; a += 0 ; b += 1 ; c += - 1 <NEWLINE> else : ans . append ( <STRING> ) ; a += 0 ; b += - 1 ; c += 1 <NEWLINE> <DEDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> if a == c : <NEWLINE> <INDENT> if s [ i + 1 ] == <STRING> : ans . append ( <STRING> ) ; a += - 1 ; b += 0 ; c += 1 <NEWLINE> else : ans . append ( <STRING> ) ; a += 1 ; b += 0 ; c += - 1 <NEWLINE> <DEDENT> elif a < c : ans . append ( <STRING> ) ; a += 1 ; b += 0 ; c += - 1 <NEWLINE> else : ans . append ( <STRING> ) ; a += - 1 ; b += 0 ; c += 1 <NEWLINE> if min ( a , b , c ) < 0 : <NEWLINE> exit ( print ( <STRING> ) ) <NEWLINE> <DEDENT> <DEDENT> for i in s [ n - 1 : ] : <NEWLINE> <INDENT> if i == <STRING> : <NEWLINE> <INDENT> if a < b : ans . append ( <STRING> ) ; a += 1 ; b += - 1 ; c += 0 <NEWLINE> else : ans . append ( <STRING> ) ; a += - 1 ; b += 1 ; c += 0 <NEWLINE> <DEDENT> if i == <STRING> : <NEWLINE> <INDENT> if b < c : ans . append ( <STRING> ) ; a += 0 ; b += 1 ; c += - 1 <NEWLINE> else : ans . append ( <STRING> ) ; a += 0 ; b += - 1 ; c += 1 <NEWLINE> <DEDENT> if i == <STRING> : <NEWLINE> <INDENT> if a < c : ans . append ( <STRING> ) ; a += 1 ; b += 0 ; c += - 1 <NEWLINE> else : ans . append ( <STRING> ) ; a += - 1 ; b += 0 ; c += 1 <NEWLINE> <DEDENT> if min ( a , b , c ) < 0 : <NEWLINE> <INDENT> exit ( print ( <STRING> ) ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> for i in ans : print ( i ) <NEWLINE> <DEDENT>
import sys , bisect , math , itertools , string , queue , copy <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> from collections import Counter , defaultdict , deque <NEWLINE> from itertools import permutations , combinations <NEWLINE> from heapq import heappop , heappush <NEWLINE> from fractions import gcd <NEWLINE> <COMMENT> <NL> sys . setrecursionlimit ( 10 ** 8 ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> def inp ( ) : return int ( input ( ) ) <NEWLINE> def inpm ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def inpl ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> def inpls ( ) : return list ( input ( ) . split ( ) ) <NEWLINE> def inplm ( n ) : return list ( int ( input ( ) ) for _ in range ( n ) ) <NEWLINE> def inplL ( n ) : return [ list ( input ( ) ) for _ in range ( n ) ] <NEWLINE> def inplT ( n ) : return [ tuple ( input ( ) ) for _ in range ( n ) ] <NEWLINE> def inpll ( n ) : return [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ] <NEWLINE> def inplls ( n ) : return sorted ( [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ] ) <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> n , a , b , c = inpm ( ) <NEWLINE> s = [ ] <NEWLINE> ans = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> S = input ( ) <NEWLINE> s . append ( S ) <NEWLINE> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> s = S [ i ] <NEWLINE> if s == <STRING> : <NEWLINE> <INDENT> if a == 0 and b == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> return <NEWLINE> <DEDENT> if a == 0 : <NEWLINE> <INDENT> a += 1 <NEWLINE> b -= 1 <NEWLINE> ans . append ( <STRING> ) <NEWLINE> <DEDENT> elif b == 0 : <NEWLINE> <INDENT> a -= 1 <NEWLINE> b += 1 <NEWLINE> ans . append ( <STRING> ) <NEWLINE> <DEDENT> elif a == 1 and b == 1 and i < n - 1 and s != S [ i + 1 ] : <NEWLINE> <INDENT> if S [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> a += 1 <NEWLINE> b -= 1 <NEWLINE> ans . append ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> b += 1 <NEWLINE> a -= 1 <NEWLINE> ans . append ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if a > b : <NEWLINE> <INDENT> a -= 1 <NEWLINE> b += 1 <NEWLINE> ans . append ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a += 1 <NEWLINE> b -= 1 <NEWLINE> ans . append ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if s == <STRING> : <NEWLINE> <INDENT> if a == 0 and c == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> return <NEWLINE> <DEDENT> if a == 0 : <NEWLINE> <INDENT> a += 1 <NEWLINE> c -= 1 <NEWLINE> ans . append ( <STRING> ) <NEWLINE> <DEDENT> elif c == 0 : <NEWLINE> <INDENT> a -= 1 <NEWLINE> c += 1 <NEWLINE> ans . append ( <STRING> ) <NEWLINE> <DEDENT> elif a == 1 and c == 1 and i < n - 1 and s != S [ i + 1 ] : <NEWLINE> <INDENT> if S [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> a += 1 <NEWLINE> c -= 1 <NEWLINE> ans . append ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> c += 1 <NEWLINE> a -= 1 <NEWLINE> ans . append ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if a > c : <NEWLINE> <INDENT> a -= 1 <NEWLINE> c += 1 <NEWLINE> ans . append ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a += 1 <NEWLINE> c -= 1 <NEWLINE> ans . append ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if s == <STRING> : <NEWLINE> <INDENT> if c == 0 and b == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> return <NEWLINE> <DEDENT> if b == 0 : <NEWLINE> <INDENT> b += 1 <NEWLINE> c -= 1 <NEWLINE> ans . append ( <STRING> ) <NEWLINE> <DEDENT> elif c == 0 : <NEWLINE> <INDENT> b -= 1 <NEWLINE> c += 1 <NEWLINE> ans . append ( <STRING> ) <NEWLINE> <DEDENT> elif b == 1 and c == 1 and i < n - 1 and s != S [ i + 1 ] : <NEWLINE> <INDENT> if S [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> b += 1 <NEWLINE> c -= 1 <NEWLINE> ans . append ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> c += 1 <NEWLINE> b -= 1 <NEWLINE> ans . append ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if b > c : <NEWLINE> <INDENT> b -= 1 <NEWLINE> c += 1 <NEWLINE> ans . append ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> b += 1 <NEWLINE> c -= 1 <NEWLINE> ans . append ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> print ( ans [ i ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n , a , b , c = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> s = [ list ( input ( ) ) for _ in range ( n ) ] <NEWLINE> d = { <STRING> : a , <STRING> : b , <STRING> : c } <NEWLINE> ans = [ ] <NEWLINE> for i , [ j , k ] in enumerate ( s ) : <NEWLINE> <INDENT> if d [ j ] == 0 and d [ k ] == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> elif d [ j ] > d [ k ] : <NEWLINE> <INDENT> calc ( k , j ) <NEWLINE> <DEDENT> elif d [ j ] < d [ k ] : <NEWLINE> <INDENT> calc ( j , k ) <NEWLINE> <DEDENT> elif i + 1 != n : <NEWLINE> <INDENT> if j == <STRING> : <NEWLINE> <INDENT> if s [ i + 1 ] [ 1 ] == <STRING> : <NEWLINE> <INDENT> calc ( k , j ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> calc ( j , k ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if s [ i + 1 ] == [ <STRING> , <STRING> ] : <NEWLINE> <INDENT> calc ( k , j ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> calc ( j , k ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> calc ( j , k ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> for i in ans : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT> <DEDENT>
K = int ( input ( ) ) <NEWLINE> A , B = map ( int , input ( ) ) <NEWLINE> if ( A - 1 ) / K == B / K : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
k = int ( input ( ) ) <NEWLINE> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> for i in rage ( a , b ) : <NEWLINE> <INDENT> if i % k == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
k = int ( input ( ) ) <NEWLINE> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> for i in range ( a , b + 1 ) : <NEWLINE> <INDENT> if i % k == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
k = int ( input ( ) ) <NEWLINE> a , b = int ( input ( ) . split ( ) ) <NEWLINE> <NL> if b - a >= k - 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
<COMMENT> <NL> k = int ( input ( ) ) <NEWLINE> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> is_ok = False <NEWLINE> <NL> for i in range ( a , b + 1 ) : <NEWLINE> <INDENT> if i % k == 0 : <NEWLINE> <INDENT> is_ok = true <NEWLINE> <NL> <DEDENT> <DEDENT> if is_ok : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
k = int ( input ( ) ) <NEWLINE> a , b = ( int ( i ) for i in input ( ) . split ( ) ) <NEWLINE> <NL> for i in range ( a , b + 1 ) : <NEWLINE> <INDENT> if i % k == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if A // K < B // K or K == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a = int ( input ( ) ) <NEWLINE> b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> flag = False <NEWLINE> for i in range ( a , b + 1 ) : <NEWLINE> <INDENT> if i % a == 0 : <NEWLINE> flag = True <NEWLINE> break <NEWLINE> <DEDENT> print ( <STRING> if flag else <STRING> ) <NEWLINE> <NL> <NL> <NL> <NL>
k = int ( input ( ) ) <NEWLINE> a , b = map ( int , input ( ) ) <NEWLINE> print ( <STRING> ) if b - a + 1 >= k else print ( <STRING> ) <NEWLINE>
K = int ( input ( ) ) <NEWLINE> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if A // K == B // K : <NEWLINE> <INDENT> if A % K == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
K = int ( input ( ) ) <NEWLINE> A , B = int ( input ( ) . split ( ) ) <NEWLINE> check = False <NEWLINE> for i in range ( 0 , B - A ) : <NEWLINE> <INDENT> if ( B - A - i ) % K == 0 : <NEWLINE> <INDENT> check = True <NEWLINE> <DEDENT> <DEDENT> if check == True : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
k = int ( input ( ) ) <NEWLINE> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( a // k , b // k + 1 ) : <NEWLINE> <INDENT> if a <= k * i <= b : <NEWLINE> <INDENT> ans = 1 <NEWLINE> <DEDENT> <DEDENT> if ans = 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
k = int ( input ( ) <NEWLINE> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> c = 0 <NEWLINE> for i in range ( a , b + 1 ) : <NEWLINE> <INDENT> if i % k == 0 : <NEWLINE> <INDENT> c += 1 <NEWLINE> <DEDENT> <DEDENT> if c == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> k = int ( input ( ) ) <NEWLINE> found = False <NEWLINE> for i in range ( a , b + 1 ) : <NEWLINE> <INDENT> if i % k == 0 : <NEWLINE> <INDENT> found = True <NEWLINE> <DEDENT> <DEDENT> if found : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
K = input ( ) <NEWLINE> ( A , B ) = map ( int , input ( ) . split ( ) ) <NEWLINE> buf = True <NEWLINE> for i in range ( A , B + 1 ) : <NEWLINE> <INDENT> if ( i % K == 0 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> return <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE>
k = int ( input ( ) ) <NEWLINE> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> flg = False <NEWLINE> for i in range ( a , b + 1 ) : <NEWLINE> <INDENT> if i % k = 0 : <NEWLINE> <INDENT> flg = True <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if flg : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
K = int ( input ( ) ) <NEWLINE> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> tmp = A % k <NEWLINE> if ( tmp == 0 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if ( A + ( K - tmp ) <= B ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
<INDENT> k = int ( input ( ) ) <NEWLINE> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( <STRING> if a // k < b // k or a % k == 0 or b % k == 0 else <STRING> ) <NEWLINE> <DEDENT>
k = int ( input ( ) ) <NEWLINE> a , b = map ( int , input ( ) . split ( ) ) ; <NEWLINE> <NL> x = 0 ; <NEWLINE> for i in range ( a , b + 1 ) ; <NEWLINE> <INDENT> if i % k == 0 : <NEWLINE> <INDENT> x += 1 ; <NEWLINE> <NL> <DEDENT> <DEDENT> if x == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
k = input ( ) <NEWLINE> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> han = False <NEWLINE> for i in range ( a , b , 1 ) : <NEWLINE> <INDENT> if i % k == 0 : <NEWLINE> <INDENT> han = True <NEWLINE> <DEDENT> <DEDENT> if han == True : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
K = int ( input ( ) ) <NEWLINE> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> for i in range ( A , B + 1 ) : <NEWLINE> <INDENT> if i % K == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> stop ( ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b , n = map ( int , input ( ) . split ( ) ) <NEWLINE> p = 0 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if p < ( a * i ) // b - a * ( i // b ) : <NEWLINE> <INDENT> p = ( a * i ) // b - a * ( i // b ) <NEWLINE> <DEDENT> <DEDENT> print ( p ) <NEWLINE>
K = int ( input ( ) ) <NEWLINE> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> flag = True <NEWLINE> for i in range ( A : B + 1 ) : <NEWLINE> <INDENT> if i % K == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> flag = False <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if flag : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
K = int ( input ( ) ) <NEWLINE> <NL> ARGS = input ( ) . split ( ) <NEWLINE> A = int ( ARGS [ 0 ] ) <NEWLINE> B = int ( ARGS [ 1 ] ) <NEWLINE> <NL> largest = B / K * K <NEWLINE> if A <= largest <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
K = int ( input ( ) ) <NEWLINE> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> a = 0 <NEWLINE> K_sum = K <NEWLINE> while K <= B : <NEWLINE> <INDENT> if A <= K and K <= B : <NEWLINE> <INDENT> a = 1 <NEWLINE> break <NEWLINE> <DEDENT> K_sum += K <NEWLINE> <NL> <DEDENT> if a == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
K , A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> if A <= B % K == 0 and A or B % K == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
root = int ( input ( ) ) <NEWLINE> ranges = list ( map ( int , input ( ) . slice ( ) ) ) <NEWLINE> flag = False <NEWLINE> <NL> for i in range ( ranges [ 0 ] , ranges [ 1 ] + 1 ) : <NEWLINE> <INDENT> if i % root : <NEWLINE> <INDENT> flag = True <NEWLINE> <NL> <DEDENT> <DEDENT> if flag : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
K = int ( input ( ) ) <NEWLINE> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> for i in range ( A , B + 1 ) : <NEWLINE> <INDENT> if ( i % K == 0 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> if ( i == B and i % K != 0 ) <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT>
k = int ( input ( ) ) <NEWLINE> a , b = map ( int , input ( ) . sprit ( ) ) <NEWLINE> ans = <STRING> <NEWLINE> for i in range ( a , b + 1 ) : <NEWLINE> <INDENT> if i % k == 0 : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL>
k = int ( input ( ) ) <NEWLINE> a , b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in range ( 1000 ) : <NEWLINE> <INDENT> if k * i >= a and k * i = < b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> if k * i > b : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
k = int ( input ( ) ) <NEWLINE> a , b = [ input ( ) for i in range ( 2 ) ] <NEWLINE> if ( b - a + 1 >= k ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
K = int ( input ( ) ) <NEWLINE> A , B = map ( int , input ( ) . spilt ( ) ) <NEWLINE> if ( A <= B / K * K ) { <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> } <NEWLINE> else { <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> } <NEWLINE>
<INDENT> k = int ( input ( ) ) <NEWLINE> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> for i in range ( a , b ) : <NEWLINE> <INDENT> if i % k == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> return <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> <DEDENT> return <NEWLINE> <DEDENT>
K = int ( input ( ) ) <NEWLINE> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> count == 0 <NEWLINE> for i in range ( A , B + 1 ) : <NEWLINE> <INDENT> if i % K == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> count = 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if count == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
text = input ( ) <NEWLINE> rows = text . split ( <STRING> ) <NEWLINE> k = int ( rows [ 0 ] ) <NEWLINE> a = int ( rows [ 1 ] . split ( <STRING> ) [ 0 ] ) <NEWLINE> b = int ( row [ 1 ] . split ( <STRING> ) [ 1 ] ) <NEWLINE> for i in range ( a , b + 1 ) : <NEWLINE> <INDENT> if i % k == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
k = list ( input ( ) ) <NEWLINE> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if a % k == 0 or b % k == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if ( b - a ) // k == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> k = 0 <NEWLINE> if N == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if A [ 0 ] // int ( N ) == A [ 1 ] // int ( N ) and A [ 0 ] % int ( N ) == A [ 1 ] % int ( N ) and A [ 0 ] % int ( N ) == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> elif A [ 0 ] // int ( N ) != A [ 1 ] // int ( N ) and A [ 0 ] % int ( N ) != 0 : <NEWLINE> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
k = int ( input ( ) ) <NEWLINE> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> flag = False <NEWLINE> for i in range ( a , b + 1 ) : <NEWLINE> <INDENT> if i % k == 0 : <NEWLINE> <INDENT> flag = True <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> ) if flag else print ( <STRING> ) <NEWLINE>
k = int ( input ( ) ) <NEWLINE> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> while True : <NEWLINE> <INDENT> if a % k == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> elif : b % k == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif b - a >= k : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT>
K = input ( ) <NEWLINE> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> sa = B - A <NEWLINE> flag = 0 <NEWLINE> <NL> for i in range ( sa + 1 ) : <NEWLINE> <INDENT> if ( A + i ) % K == 0 : <NEWLINE> <INDENT> flag = 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if flag == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
K = int ( input ( ) ) <NEWLINE> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> sum = 0 <NEWLINE> for ( int i = A ; i <= B ; i + + ) <NEWLINE> <INDENT> if i % K == 0 : <NEWLINE> <INDENT> sum += 1 <NEWLINE> <DEDENT> <DEDENT> if sum >= 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
k = int ( input ( ) ) <NEWLINE> a , b = map ( int , input . split ( ) ) <NEWLINE> list = range ( a , b + 1 ) <NEWLINE> for val in list : <NEWLINE> <INDENT> if val % k == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> continue <NEWLINE> <NL> <DEDENT> <DEDENT>
i = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> f = 0 <NEWLINE> for x in range ( i [ 1 ] , i [ 2 ] + 1 ) : <NEWLINE> <INDENT> if x % i [ 0 ] == 0 : <NEWLINE> <INDENT> f = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if f == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import sys <NEWLINE> K = int ( input ( ) ) <NEWLINE> A , B = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> for i in range ( A , B + 1 ) : <NEWLINE> <INDENT> if i % k == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
K = int ( input ( ) ) <NEWLINE> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> n_A = A // K <NEWLINE> n_B = B // K <NEWLINE> if n_B - b_A >= 1 : <NEWLINE> <INDENT> print ( <STRING> ) : <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
K = int ( input ( ) ) <NEWLINE> A , B = map ( int , input ( ) ) <NEWLINE> c = 0 <NEWLINE> <NL> for i in range ( A , B + 1 ) : <NEWLINE> <INDENT> if i % K == 0 : <NEWLINE> <INDENT> c += 1 <NEWLINE> <DEDENT> <DEDENT> if c > 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
k = int ( input ( ) ) <NEWLINE> a , b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> aa = a // k <NEWLINE> bb = b // k <NEWLINE> <NL> if bb - aa = > 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
if a % k == 0 or b % k == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if k == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a // k < b // k : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
K = input ( ) <NEWLINE> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> p = 1 <NEWLINE> for i in range ( a , b + 1 ) : <NEWLINE> <INDENT> if i % K == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> p = 0 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if p == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
target = int ( input ( ) ) <NEWLINE> range_d = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> min_d = range_d [ 0 ] <NEWLINE> max_d = range_d [ 1 ] <NEWLINE> <NL> flag = False <NEWLINE> if max_d < target : <NEWLINE> <INDENT> flag = <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( min_d , max_d + 1 ) : <NEWLINE> <INDENT> if i % target == 0 : <NEWLINE> <INDENT> flag = True <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) if flag else print ( <STRING> ) <NEWLINE> <DEDENT>
k = int ( input ( ) ) <NEWLINE> list = input ( ) . split ( ) <NEWLINE> <NL> if int ( list [ 0 ] ) // k != int ( list [ 1 ] ) // k : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else if int ( list [ 0 ] ) % k == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
K = int ( input ( ) ) <NEWLINE> A , B = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> flag = 0 <NEWLINE> for i in range ( 1 , 1001 ) : <NEWLINE> <INDENT> if ( iK >= A and iK <= B ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> flag = 1 <NEWLINE> break <NEWLINE> if ( flag == 0 ) : <NEWLINE> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
k = int ( input ( ) ) <NEWLINE> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> for i in range ( 1 , 2000 ) : <NEWLINE> <INDENT> x = k * i <NEWLINE> if a <= k and k <= b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> else b < k : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT>
A <NEWLINE> <COMMENT> <NL> K = int ( input ( ) ) <NEWLINE> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <COMMENT> <NL> answer = <STRING> <NEWLINE> for i in range ( A , B + 1 ) : <NEWLINE> <INDENT> if i % K == 0 : <NEWLINE> <INDENT> answer = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <DEDENT> <DEDENT> print ( answer ) <NEWLINE>
K = int ( input ( ) ) <NEWLINE> A = int ( input ( ) . split ( ) [ 0 ] ) <NEWLINE> B = int ( input ( ) . split ( ) [ 1 ] ) <NEWLINE> <NL> for i in range ( A , B + 1 ) : <NEWLINE> <INDENT> if i % K == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
K = int ( input ( ) ) <NEWLINE> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> for i in range ( A , B + 1 ) : <NEWLINE> <INDENT> if i % K == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> <NEWLINE>
<NL> K = int ( input ( ) ) <NEWLINE> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> cnt = 0 <NEWLINE> while true : <NEWLINE> <INDENT> cnt += K <NEWLINE> if a <= cnt <= b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> if b < cnt : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT>
k = int ( input ( ) ) <NEWLINE> a , b = map ( input ( ) . split ( ) ) <NEWLINE> for i in range ( a , b ) : <NEWLINE> <INDENT> if i % k == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
k = int ( input ( ) ) <NEWLINE> a_b = input ( ) . split ( ) [ 1 ] . split ( <STRING> ) <NEWLINE> a = int ( a_b . split ( <STRING> ) [ 0 ] ) <NEWLINE> b = int ( a_b . split ( <STRING> ) [ 1 ] ) <NEWLINE> <NL> for i in range ( 1 , 1000 ) : <NEWLINE> <INDENT> if a <= ( i * k ) <= b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> elif ( i * k ) > b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
k = int ( input ( ) ) <NEWLINE> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> flag = False <NEWLINE> for i in range ( a , b + 1 ) : <NEWLINE> <INDENT> if i % k == 0 : <NEWLINE> <INDENT> flag = true <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if flag : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
M , A , B = ( int ( x ) for x in input ( ) . split ( ) ) <NEWLINE> if B // M - A // M >= 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif A % M = 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import sys <NEWLINE> K = int ( input ( ) ) <NEWLINE> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> for i in range ( a , b + 1 ) : <NEWLINE> <INDENT> if i % K 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
K = int ( input ( ) ) <NEWLINE> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> a = ( B // K ) - ( A // K ) <NEWLINE> <NL> if A == B : <NEWLINE> <INDENT> if A % K = 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if a == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
K = int ( input ( ) ) <NEWLINE> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> n = 1 <NEWLINE> while True : <NEWLINE> <INDENT> if A <= K * n and K * n <= B : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> elif Kn > B : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> n = n + 1 <NEWLINE> <DEDENT>
K , A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> count = 0 <NEWLINE> for i in range ( A , B + 1 ) : <NEWLINE> <INDENT> if i % K == 0 : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> if count > 0 else <STRING> ) <NEWLINE>
k = int ( input ( ) ) <NEWLINE> a , b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if ( k >= a and ( ( k / b ) <= a and ( k / b ) = < b ) ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
k = int ( input ( ) ) <NEWLINE> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> c = k <NEWLINE> while ( c <= b ) : <NEWLINE> <INDENT> if a <= k <= b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> quit ( ) <NEWLINE> c += k <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
K = int ( input ( ) ) <NEWLINE> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> for i in range ( A , B , 1 ) : <NEWLINE> <INDENT> if ( i %= K ) == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
import sys <NEWLINE> K = int ( sys . stdin . readline ( ) ) <NEWLINE> A , B = map ( int , sys . stdin . readline ( ) . split ( ) ) <NEWLINE> for i in range ( A , B + 1 ) : <NEWLINE> <INDENT> if i % K == 0 : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> return <STRING> <NEWLINE> <DEDENT>
k = input ( ) <NEWLINE> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = <STRING> <NEWLINE> while a <= b : <NEWLINE> <INDENT> if a % k = 0 : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a = a + 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
K = int ( input ( ) ) <NEWLINE> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> if A == B : <NEWLINE> <INDENT> if K // A == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if K // A == K // B : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
k = input ( ) <NEWLINE> l = input ( ) . split ( ) <NEWLINE> A , B = l [ 0 ] , l [ 1 ] <NEWLINE> <NL> i = 0 <NEWLINE> while i * k <= B : <NEWLINE> <INDENT> if A <= i * k <= B : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
a = int ( input ( ) ) <NEWLINE> b , c = int ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> d = b // a <NEWLINE> e = c // a <NEWLINE> if d == e : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
<NL> n = int ( input ( ) ) <NEWLINE> m , t = map ( int , input ( ) . split ( ) ) <NEWLINE> if n <= t - m : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif n == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT>
import sys <NEWLINE> <NL> K = input ( ) <NEWLINE> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> for i in range ( A , B + 1 ) : <NEWLINE> <INDENT> if i % K == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
k = int ( input ( ) ) <NEWLINE> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1000 ) : <NEWLINE> <INDENT> j = k * i - a <NEWLINE> if a <= j and j <= b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> elif : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
k = int ( input ( ) ) <NEWLINE> a , b = map ( int , input ( ) ) <NEWLINE> if k == 1 or ( a // k == a / k ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> n = a // k <NEWLINE> m = b // k <NEWLINE> if m - n >= 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
K = int ( input ( ) ) <NEWLINE> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> for i in range ( A , B ) : <NEWLINE> <INDENT> if i % K == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> icount = 0 <NEWLINE> if A [ 2 ] - A [ 1 ] >= A [ 0 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> icount = icount + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( A [ 1 ] : A [ 2 ] + 1 ) : <NEWLINE> <INDENT> if i % A [ 0 ] == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> icount = icount + 1 <NEWLINE> if icount == 1 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if icount == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT>
K = int ( input ( ) ) <NEWLINE> A , B = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> flag = 0 <NEWLINE> for i in range ( 1 , 1001 ) : <NEWLINE> <INDENT> if ( iK >= A and iK <= B ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> flag = 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if ( flag == 0 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
k = int ( input ( ) ) <NEWLINE> a , b = list ( map ( int , input ( ) . slplit ( ) ) ) <NEWLINE> ret = <STRING> <NEWLINE> q = a // k <NEWLINE> if a <= q * k or ( q + 1 ) * k <= b : <NEWLINE> <INDENT> ret = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ret = <STRING> <NEWLINE> <DEDENT> print ( ret ) <NEWLINE>
hage = input ( ) <NEWLINE> hoge = input ( ) <NEWLINE> <NL> renji = hoge [ 0 ] - hoge [ 1 ] <NEWLINE> <NL> e = hage <NEWLINE> <NL> while e <= hage [ 1 ] ; <NEWLINE> <INDENT> if hoge [ 0 ] <= e and hage [ 1 ] >= e ; <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> e = e + hage <NEWLINE> <DEDENT> <DEDENT> if e > hage [ 1 ] or e < hage [ 0 ] ; <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT>
k = int ( input ( ) ) <NEWLINE> a , b = map ( int , input ( ) . split ( ) . split ( <STRING> ) ) <NEWLINE> can = False <NEWLINE> for i in range ( a , b + 1 ) : <NEWLINE> <INDENT> if k % i == 0 : <NEWLINE> <INDENT> can = True <NEWLINE> <DEDENT> <DEDENT> if can : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
X = int ( input ( ) ) <NEWLINE> <NL> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> flag = False <NEWLINE> for x in range ( A , B + 1 ) : <NEWLINE> <INDENT> if x % K == 0 : <NEWLINE> <INDENT> flag = True <NEWLINE> <NL> <DEDENT> <DEDENT> if flag : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
k = int ( input ( ) ) <NEWLINE> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> for i in range ( a , b + 1 ) : <NEWLINE> <INDENT> if ( i % k == 0 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exsi ( ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
k = int ( input ( ) ) <NEWLINE> a = int ( input ( ) ) <NEWLINE> b = int ( input ( ) ) <NEWLINE> c = 0 <NEWLINE> for i in range ( a , b + 1 ) : <NEWLINE> <INDENT> if i % k == 0 : <NEWLINE> <INDENT> c = c + 1 <NEWLINE> <DEDENT> <DEDENT> if c == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import sys <NEWLINE> from numba import njit <NEWLINE> input = sys . stdin . buffer . readline <NEWLINE> <NL> <NL> @ njit <NEWLINE> def main ( ) : <NEWLINE> <INDENT> K = int ( input ( ) ) <NEWLINE> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> for i in range ( A , B + 1 ) : <NEWLINE> <INDENT> if i % K == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> return 0 <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> return 0 <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
A , B = int ( input ( ) ) <NEWLINE> s = int ( input ( ) . split ( ) ) <NEWLINE> if s == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> if s < A : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> if s > B : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE>
k , a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> f = 1 <NEWLINE> while a <= b : <NEWLINE> <INDENT> if ( a % k == 0 ) : <NEWLINE> <INDENT> f = 0 <NEWLINE> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> a += 1 <NEWLINE> <DEDENT> if f : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
K = input ( <STRING> ) <NEWLINE> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> number = False <NEWLINE> for i in range ( A , B + 1 ) : <NEWLINE> <INDENT> if number % K == 0 : <NEWLINE> <INDENT> number = True <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> if number else <STRING> ) <NEWLINE>
k = int ( input ( ) ) <NEWLINE> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> for x in range ( a , b + 1 ) : <NEWLINE> <INDENT> if x % k == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
k = int ( input ( ) ) <NEWLINE> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> res = <STRING> <NEWLINE> for i in range ( a , b + 1 ) : <NEWLINE> <INDENT> if ( ( i % k == 0 ) : <NEWLINE> <INDENT> res = <STRING> <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( res ) <NEWLINE>
ut ( ) ) <NEWLINE> a , b = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> ngflag = True <NEWLINE> while ( a <= b ) : <NEWLINE> <INDENT> if a % k == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> ngflag = False <NEWLINE> break <NEWLINE> <DEDENT> a += 1 <NEWLINE> <DEDENT> if ngflag : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
K = int ( input ( ) ) <NEWLINE> A , = B map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if B // K < A // K : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if a == b and if a % n == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> if ( b - a + 1 ) / n >= 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
i = int ( input ( ) ) <NEWLINE> j , k = int ( input ( ) ) . split ( ) <NEWLINE> l = 0 <NEWLINE> while True : <NEWLINE> <INDENT> if j <= l * i <= k : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> elif l * i > k : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> l += 1 <NEWLINE> <DEDENT>
k = int ( input ( ) ) <NEWLINE> cont = 0 <NEWLINE> a , b = input ( ) . split ( ) <NEWLINE> a = int ( a ) <NEWLINE> b = int ( b ) <NEWLINE> while 1 : <NEWLINE> <INDENT> cont += k <NEWLINE> if a <= cont <= b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> if x > b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT>
if k >= 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> if b - a + 2 >= k : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = input ( ) . split ( ) <NEWLINE> <NL> s = int ( A [ 0 ] ) // N <NEWLINE> if int ( A [ 0 ] ) % N == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if ( s + 1 ) * N >= A [ 1 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
k = input ( <STRING> ) <NEWLINE> a = input ( <STRING> ) <NEWLINE> b = input ( <STRING> ) <NEWLINE> c = int ( a ) <NEWLINE> d = int ( b ) <NEWLINE> l = int ( k ) <NEWLINE> e = d - d % l <NEWLINE> if e >= c : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> <NL> a , b = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> flag = 0 <NEWLINE> for i in range ( a , b + 1 ) : <NEWLINE> <INDENT> if i % k == 0 : <NEWLINE> <INDENT> flag = 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if flag == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
k = int ( input ( ) ) <NEWLINE> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> x = k * ( a // k ) + k <NEWLINE> if k == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif : x >= a and x <= b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
nt ( input ( ) ) <NEWLINE> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if A == B : <NEWLINE> <INDENT> if A % K == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( B - A ) : <NEWLINE> <INDENT> i += A <NEWLINE> if i % K == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
k = int ( input ( ) ) <NEWLINE> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> flag = 0 <NEWLINE> for i in range ( a , b + 1 ) <NEWLINE> <INDENT> if i % k == 0 : <NEWLINE> <INDENT> flag = 1 <NEWLINE> <DEDENT> <DEDENT> if flag == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
k = int ( input ( <STRING> ) ) <NEWLINE> a , b = int ( input ( <STRING> ) ) , int ( input ( <STRING> ) ) <NEWLINE> <NL> res = False <NEWLINE> <NL> for i in range ( a , b + 1 ) : <NEWLINE> <INDENT> if i % k == 0 : <NEWLINE> <INDENT> res = True <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if res == True : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
k = int ( input ( ) ) <NEWLINE> a , b = map ( int , input ( ) . split ) <NEWLINE> largest = ( b // k ) * k <NEWLINE> print ( <STRING> if largest >= a else <STRING> ) <NEWLINE>
K = int ( input ( ) ) <NEWLINE> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> for i in range ( A , B + 1 ) : <NEWLINE> <INDENT> if i % K = 0 : <NEWLINE> <INDENT> return print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> return print ( <STRING> ) <NEWLINE>
k = int ( input ( ) ) <NEWLINE> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = <STRING> <NEWLINE> L = [ i in i for range ( 1 , 1001 ) if i % k == 0 ] <NEWLINE> for j in range ( a , b + 1 ) : <NEWLINE> <INDENT> if j in L : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
K = input ( ) <NEWLINE> A , B = input ( ) . split ( ) 5 <NEWLINE> <NL> k = int ( K ) <NEWLINE> a = int ( A ) <NEWLINE> b = int ( B ) <NEWLINE> <NL> x = a // k <NEWLINE> z = b // k <NEWLINE> <NL> for i in range ( z - x + 1 ) : <NEWLINE> <INDENT> if a <= k * i and k * i <= b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT>
k = int ( input ( ) ) <NEWLINE> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> for i in range ( a , b + 1 ) : <NEWLINE> <INDENT> if i % k == 0 : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> <DEDENT>
A = int ( input ( ) ) <NEWLINE> B , C = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> for i in range ( B , C + 1 ) : <NEWLINE> <INDENT> if i % A = 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
K = int ( input ( ) ) <NEWLINE> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> for i in range ( A , B + 1 ) : <NEWLINE> <INDENT> if ( i >= K and i % K == 0 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
a = int ( input ( ) ) <NEWLINE> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> b = x // a <NEWLINE> c = y // a <NEWLINE> <NL> if c - b <= 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
k = int ( input ) <NEWLINE> a , b = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> ans = <STRING> <NEWLINE> for i in range ( 1000 ) : <NEWLINE> <INDENT> if a <= i * k and i * k <= b : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> K = int ( input ( ) ) <NEWLINE> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if ( A % K == 0 or B % K == 0 or ( B - A >= K and B != A ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
k = int ( input ( ) ) <NEWLINE> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> for i in range ( a , b + 1 ) : <NEWLINE> <INDENT> if i % k == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT>
K = input ( ) <NEWLINE> A , B = [ int ( a ) for a in input ( ) . split ( ) ] <NEWLINE> p = A // K + K <NEWLINE> if A < p and B < p : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
k = int ( input ( ) ) <NEWLINE> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> x = 0 <NEWLINE> <NL> while True : <NEWLINE> <INDENT> x += k <NEWLINE> <NL> if a <= x <= b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> break <NEWLINE> <NL> if x > b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT>
k = input ( ) <NEWLINE> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> ka = a // k <NEWLINE> kb = b // k <NEWLINE> if b - a >= k - 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif kb - ka > 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
K = int ( input ( ) ) <NEWLINE> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = <STRING> <NEWLINE> for i in range ( a , b + 1 ) : <NEWLINE> <INDENT> if i % K == 0 : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <DEDENT> break <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
K = int ( input ( ) ) <NEWLINE> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> c = A / K <NEWLINE> b = c * K <NEWLINE> flag = False <NEWLINE> <NL> if b == B : <NEWLINE> <INDENT> flag = True <NEWLINE> <DEDENT> b += K <NEWLINE> <INDENT> if b <= B : <NEWLINE> <INDENT> flag = True <NEWLINE> <NL> <DEDENT> <DEDENT> if flag == True : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
K = input ( ) <NEWLINE> line = input ( ) . split ( <STRING> ) <NEWLINE> a = False <NEWLINE> for i in range ( int ( line [ 0 ] ) , int ( line [ 1 ] ) ) : <NEWLINE> <INDENT> if i % K == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> a = True <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if a == False : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
K = int ( input ( <STRING> ) ) <NEWLINE> A = int ( input ( <STRING> ) ) <NEWLINE> B = int ( input ( <STRING> ) ) <NEWLINE> word = <STRING> <NEWLINE> for i in range ( A , B + 1 ) : <NEWLINE> <INDENT> if i % K == 0 : <NEWLINE> <INDENT> word = <STRING> <NEWLINE> <DEDENT> <DEDENT> print ( word ) <NEWLINE>
k = input ( ) <NEWLINE> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if k * 4 >= a : <NEWLINE> <INDENT> if k * 4 <= b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
A , B , N = map ( int , input ( ) . split ( ) ) <NEWLINE> f = [ int ( A * x / B ) - ( A * int ( x / B ) ) for x in range ( N + 1 ) ] <NEWLINE> print ( max ( f ) ) <NEWLINE>
k = int ( input ( ) ) <NEWLINE> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> count = 0 <NEWLINE> for i in range ( a , b + 1 ) : <NEWLINE> <INDENT> if ( i % k == 0 ) : <NEWLINE> <INDENT> c = c + 1 <NEWLINE> <DEDENT> <DEDENT> if ( c == 0 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <NL> <DEDENT>
K = int ( input ( ) ) <NEWLINE> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> n = range ( A , B + 1 ) <NEWLINE> ind = range ( B - A ) <NEWLINE> for i in n : <NEWLINE> <INDENT> list . append ( i ) <NEWLINE> <DEDENT> counter = 0 <NEWLINE> <NL> for i in ind : <NEWLINE> <INDENT> if list [ i ] % K == 0 : <NEWLINE> <INDENT> counter += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> counter += 0 <NEWLINE> <DEDENT> <DEDENT> if counter > 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT>
k = int ( input ( ) ) <NEWLINE> a , b = [ int ( x ) for x in input ( ) ] <NEWLINE> res = a // k < b // k or not a % k or not b % k <NEWLINE> print ( <STRING> if res else <STRING> ) <NEWLINE>
K = input ( ) <NEWLINE> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> cnt = 0 <NEWLINE> for i in range ( A , B + 1 ) : <NEWLINE> <INDENT> if ( i % K == 0 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> cnt += 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if ( cnt == 0 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
k = int ( input ( ) ) <NEWLINE> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> for i range ( a , b ) : <NEWLINE> <INDENT> if i % k == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
4 <NEWLINE> 5 7 <NEWLINE>
K = int ( input ( ) ) <NEWLINE> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> i = A // K <NEWLINE> nK = K <NEWLINE> OK = False <NEWLINE> if A - B > K : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> while nK = < B : <NEWLINE> <INDENT> if ( nK >= A ) and ( nK <= B ) : <NEWLINE> <INDENT> OK = True <NEWLINE> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> nK = i * K <NEWLINE> i = i + 1 <NEWLINE> <DEDENT> <DEDENT> if OK == False : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
K = int ( input ( ) ) <NEWLINE> A = int ( input ( ) ) <NEWLINE> B = int ( input ( ) ) <NEWLINE> <NL> if ( <STRING> ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
K = int ( input ( ) ) <NEWLINE> A , B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c = K <NEWLINE> while c <= B : <NEWLINE> <INDENT> if c >= A and c <= B : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> a = int ( input ( ) ) <NEWLINE> b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> while ( True ) : <NEWLINE> <INDENT> for i in range ( a , b + 1 ) : <NEWLINE> <INDENT> if i // a == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> <NL> <NL>
k = int ( input ( ) . split ( ) ) <NEWLINE> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( a , b ) : <NEWLINE> <INDENT> if i % k == 0 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += 0 <NEWLINE> <DEDENT> <DEDENT> if ans >= 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
K = int ( input ( ) ) <NEWLINE> A , B = map ( int , input ( ) . split ) <NEWLINE> c = B - A <NEWLINE> d = c - K <NEWLINE> if d > - 2 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
K = int ( input ( ) ) <NEWLINE> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if A % K == 0 or B % K == 0 <NEWLINE> <INDENT> print <STRING> <NEWLINE> <NL> <DEDENT> elif A <= K * ( A // K + 1 ) and K * ( A // K + 1 ) <= B : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT>
K = int ( input ( ) ) <NEWLINE> A , B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> flag = 0 <NEWLINE> while ( flag == 0 ) : <NEWLINE> <INDENT> if ( A <= K and K <= B ) : <NEWLINE> <INDENT> flag = 1 <NEWLINE> break <NEWLINE> <DEDENT> K += K <NEWLINE> <DEDENT> if ( flag == 0 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
k = int ( input ( ) ) <NEWLINE> a , b = [ int ( i ) for i in input ( ) . split ] <NEWLINE> <NL> if a % k == 0 or ( a % k - b % k ) >= 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
k = input ( ) <NEWLINE> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> for i in range ( a , b ) : <NEWLINE> <INDENT> if i % k == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> if i % k != 0 and i == b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
k = int ( input ( ) ) <NEWLINE> a , b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> while True : <NEWLINE> <INDENT> x += k <NEWLINE> if a <= x <= b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> if x > b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT>
import math <NEWLINE> <NL> a = int ( input ( ) ) <NEWLINE> <COMMENT> <NL> print ( math . ceil ( li [ 0 ] / a ) * a ) <NEWLINE> if li [ 1 ] < math . ceil ( li [ 0 ] / a ) * a : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
K = input ( ) <NEWLINE> A = input ( ) <NEWLINE> B = input ( ) <NEWLINE> <NL> i = 1 <NEWLINE> r = i * K <NEWLINE> while r <= B : <NEWLINE> <INDENT> if r >= A : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif r < A : <NEWLINE> <INDENT> i += 1 <NEWLINE> r = i * K <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
K = int ( input ( ) ) <NEWLINE> AB = input ( ) . split ( ) <NEWLINE> A = int ( AB [ 0 ] ) <NEWLINE> B = int ( AB [ 1 ] ) <NEWLINE> for i in rage ( A , B + 1 ) : <NEWLINE> <INDENT> i = 567 <NEWLINE> if ( i % K == 0 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
K = int ( input ( ) ) <NEWLINE> A , B = input ( ) . split ( ) <NEWLINE> <NL> if B - A >= K - 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
K = int ( input ( ) ) <NEWLINE> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> a = 0 <NEWLINE> for i in range ( A , B + 1 ) : <NEWLINE> <INDENT> if i % k == 0 : <NEWLINE> <INDENT> a += 1 <NEWLINE> <DEDENT> <DEDENT> if a == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
<NL> A , B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in range ( A , B + 1 ) : <NEWLINE> <INDENT> if i % K == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
K = int ( input ( ) . split ( ) ) <NEWLINE> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> n = A // K <NEWLINE> print ( <STRING> if A <= K * n <= B or K * ( n + 1 ) <= B else <STRING> ) <NEWLINE>
m = int ( input ( ) ) <NEWLINE> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if b // k - a // k > 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
K = int ( input ( ) ) <NEWLINE> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> for i in range ( A , B + 1 ) : <NEWLINE> <INDENT> if i % K == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> print ( <STRING> ) <NEWLINE>
K = int ( input ( ) ) <NEWLINE> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> f = <STRING> <NEWLINE> <NL> for i in range ( A , B + 1 ) : <NEWLINE> <INDENT> i % K == 0 : <NEWLINE> <INDENT> f = <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> print ( f ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> temp = list ( map ( int , input ( ) . rstrip ( ) . split ( ) ) ) <NEWLINE> a = temp [ 0 ] <NEWLINE> b = temp [ 2 ] <NEWLINE> if ( b - a ) > n : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif n == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
k = int ( input ( ) ) <NEWLINE> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> for i in range ( a , b + 1 ) : <NEWLINE> <INDENT> if i % k == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s , d = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> c = 0 <NEWLINE> for i in range ( s , d + 1 ) : <NEWLINE> <INDENT> if i % s == 0 : <NEWLINE> <INDENT> c = c + 1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if c != 0 : <NEWLINE> <INDENT> print ( <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
k = int ( input ( ) ) <NEWLINE> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if ( ( a // k ) + 1 ) * k <= b or a % k = 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
c = 0 <NEWLINE> if ( b - a ) > k + 1 : <NEWLINE> <INDENT> c = 1 <NEWLINE> <DEDENT> elif ( a % k ) - ( b % k ) >= 0 : <NEWLINE> <INDENT> c = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> c = 0 <NEWLINE> <DEDENT> if c == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
K = input ( ) <NEWLINE> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> result = False <NEWLINE> for i in range ( A , B + 1 ) : <NEWLINE> <INDENT> if ( i % K ) == 0 : <NEWLINE> <INDENT> result = True <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> if result else <STRING> ) <NEWLINE>
k , x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> if 1 <= x <= y <= 1000 and 1 <= k <= 1000 : <NEWLINE> <INDENT> pass <NEWLINE> <NL> <NL> <NL> <DEDENT> if x % k >> 0 : <NEWLINE> <INDENT> if x <= ( x / k + 1 ) * k <= y : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
k = int ( input ( ) ) <NEWLINE> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> flag = False <NEWLINE> for i in range ( a , b + 1 ) : <NEWLINE> <INDENT> if i // k > 0 ans i % k == 0 : <NEWLINE> <INDENT> flag = True <NEWLINE> <NL> <DEDENT> <DEDENT> if flag : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
k = int ( input ( ) ) <NEWLINE> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> for i in range ( a , b + i ) : <NEWLINE> <INDENT> if i % k == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
k = int ( input ( ) ) <NEWLINE> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if b - a >= k and k < a <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
k = int ( input ( ) ) <NEWLINE> <NL> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> necounter = 0 <NEWLINE> for i in range ( a , b + 1 ) : <NEWLINE> <INDENT> if i % k == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ngcounter += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if ngcounter == b - a + 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
k = int ( input ( ) ) <NEWLINE> a , b = map ( int , input . split ( ) ) <NEWLINE> if b - a > k : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
K = int ( input ( ) ) <NEWLINE> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> result = <STRING> <NEWLINE> for i in range ( A , B + 1 ) : <NEWLINE> <INDENT> if i % K == 0 : <NEWLINE> <INDENT> result = <STRING> <NEWLINE> <DEDENT> <DEDENT> print ( result <NEWLINE>
K = int ( input ( ) ) <NEWLINE> <NL> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> def m ( a , b , c ) : <NEWLINE> <INDENT> for i in ( a , b + 1 ) : <NEWLINE> <INDENT> if i % k == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> return <NEWLINE> print ( <STRING> ) <NEWLINE> return <NEWLINE> <DEDENT> <DEDENT> <DEDENT> m ( a , b , k ) <NEWLINE>
K = input ( <STRING> ) <NEWLINE> A = input ( <STRING> ) <NEWLINE> B = input ( <STRING> ) <NEWLINE> <NL> f = <STRING> <NEWLINE> for i in range ( int ( A ) , int ( B ) ) : <NEWLINE> <INDENT> c = i % int ( K ) <NEWLINE> if c == 0 : <NEWLINE> <INDENT> f = <STRING> <NEWLINE> <DEDENT> <DEDENT> print ( f ) <NEWLINE>
k = int ( input ( ) ) <NEWLINE> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> for i in range ( a , b + 1 ) : <NEWLINE> <INDENT> if i % n == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
K = int ( input ( ) . split ( ) ) <NEWLINE> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> for i in range ( A , B + 1 ) : <NEWLINE> <INDENT> if i % K == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
import math <NEWLINE> <NL> K = input ( ) <NEWLINE> distance = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in range ( distance [ 1 ] - distance [ 0 ] + 1 ) : <NEWLINE> <INDENT> if ( distance [ 0 ] + i ) % K == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
kk = K <NEWLINE> while True : <NEWLINE> <INDENT> if kk >= A and kk <= 600 : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> break <NEWLINE> <DEDENT> elif kk > 600 : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> kk = kk + K <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
k = int ( input ( ) ) <NEWLINE> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> judge = 0 <NEWLINE> for i in range ( b - a + 1 ) : <NEWLINE> <INDENT> if a + i % k = 0 : <NEWLINE> <INDENT> judge = 1 <NEWLINE> <DEDENT> <DEDENT> if judge == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
K = int ( input ( ) ) <NEWLINE> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if A % K == 0 or B % K == 0 or ABS ( B - A ) >= K : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
K = int ( input ( ) ) <NEWLINE> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <NL> for i in range ( 1 , 1000 ) : <NEWLINE> <INDENT> if K * i > 1000 <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if K * i >= A and K * i <= B : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
k = input ( ) <NEWLINE> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> for i in range ( a , b + 1 ) : <NEWLINE> <INDENT> if i % k == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
K = int ( input ( ) ) <NEWLINE> A_b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A = A_B [ 0 ] <NEWLINE> B = A_b [ 1 ] <NEWLINE> m = 1 <NEWLINE> for i in range ( B ) : <NEWLINE> <INDENT> m = i * k <NEWLINE> if ( m > A and m < B ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT>
k , a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> for i in range ( a , b ) : <NEWLINE> <INDENT> if k // i == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT>
import math <NEWLINE> k = input ( ) <NEWLINE> s , t = [ int ( i ) / k for i in input ( ) . split ( ) ] <NEWLINE> <NL> if math . ceil ( s ) <= math . floor ( t ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
k = int ( input ( ) ) <NEWLINE> a , b = map ( input ( ) . split ( ) ) <NEWLINE> for i in range ( a < b ) : <NEWLINE> <INDENT> if range ( a < b ) % k == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
K = int ( input ( ) ) <NEWLINE> score = input ( ) . split ( ) <NEWLINE> if int ( score [ 0 ] < K ) : <NEWLINE> <INDENT> if int ( int ( score [ 0 ] ) / K ) < int ( int ( score [ 1 ] ) / K ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if int ( score [ 0 ] ) % K == int ( score [ 1 ] ) % K : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
K = int ( input ( ) ) <NEWLINE> <NL> A , B = map ( int , input ( ) ) <NEWLINE> <NL> if A // K <= B // K and B % K == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
K = int ( input ( ) ) <NEWLINE> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> i = 0 <NEWLINE> while A <= B : <NEWLINE> <INDENT> if A / K == A // K : <NEWLINE> <INDENT> i = i + 1 <NEWLINE> A = A + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> i = i + 0 <NEWLINE> A = A + 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if i = 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
k = int ( input ( ) ) <NEWLINE> a , b = map ( int , input ( ) split ( ) ) <NEWLINE> ans = <STRING> <NEWLINE> for i in range ( a , b + 1 ) : <NEWLINE> <INDENT> if ( i % k == 0 ) : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL>
k = int ( input ( ) ) <NEWLINE> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if i % k == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE>
a = A // K <NEWLINE> <COMMENT> <NL> C = K * ( a + 1 ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> if C <= B : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
k = int ( input ( ) ) <NEWLINE> a , b = map ( int ( input ( ) . split ( ) ) ) <NEWLINE> <NL> flag = 0 <NEWLINE> for i in range ( a , b + 1 , 1 ) <NEWLINE> <INDENT> if i % k == 0 : <NEWLINE> <INDENT> flag = flag + 1 <NEWLINE> break <NEWLINE> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> elif flag == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s = input ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> a_1 = A [ 0 ] / s <NEWLINE> b_1 = A [ 1 ] / s <NEWLINE> <NL> if b_1 - a_1 > 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
<INDENT> main ( ) : <NEWLINE> <INDENT> K = int ( input ( ) ) <NEWLINE> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> x = list ( range ( K , 1001 , K ) ) <NEWLINE> print ( <STRING> ) if any ( [ A <= i <= B for i in x ] ) else print ( <STRING> ) <NEWLINE> <NL> return <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
k = int ( input ( ) ) <NEWLINE> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> for i in 1000 : <NEWLINE> <INDENT> if a <= k * i <= b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
k = int ( input ( ) ) <NEWLINE> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> i = a / k <NEWLINE> ans = <STRING> <NEWLINE> <NL> while k * i <= b : <NEWLINE> <INDENT> if a <= k * i <= b : ans = <STRING> <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
k = int ( input ( ) ) <NEWLINE> a , b = map ( int , input ( ) , split ( ) ) <NEWLINE> for i in range ( a , b + 1 ) : <NEWLINE> <INDENT> if i % k == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
k = int ( input ( ) ) <NEWLINE> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> for i in range ( a , b + 1 ) : <NEWLINE> <INDENT> if i % k == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
K = int ( input ( ) ) <NEWLINE> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> p = 0 <NEWLINE> for i in range ( 1000 ) : <NEWLINE> <INDENT> if A <= K * i and k * i <= B : <NEWLINE> <INDENT> p = 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if p == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT>
K = int ( input ( ) ) <NEWLINE> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if ( ( A // K != B // K ) | | A % K == 0 | | B % K == 0 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
k = int ( input ( ) ) <NEWLINE> a , b = int ( input ( ) ) <NEWLINE> if b // k - ( a - 1 ) // k >= 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
K = int ( input ( ) ) <NEWLINE> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> for i in range ( A , B + 1 ) <NEWLINE> <INDENT> if i % K == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> quit ( ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
k = int ( input ( ) ) <NEWLINE> l = list ( map ( int , input . split ( ) ) ) <NEWLINE> if l [ 1 ] - l [ 0 ] >= k : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif l [ 0 ] == l [ 1 ] : <NEWLINE> <INDENT> if l [ 0 ] % k == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
K = int ( input ( ) ) <NEWLINE> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> for ( A ; B ; A + + ) : <NEWLINE> <INDENT> if A % K == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
K = int ( input ( ) ) <NEWLINE> A = int ( input ( ) ) <NEWLINE> B = int ( input ( ) ) <NEWLINE> largest = ( B / K ) * K <NEWLINE> if A <= largest : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
k = int ( input ( ) ) <NEWLINE> s = input ( ) . rsprit ( ) . split ( ) <NEWLINE> a = int ( s [ 0 ] ) <NEWLINE> b = int ( s [ 1 ] ) <NEWLINE> f = <STRING> <NEWLINE> for i in range ( a , b ) : <NEWLINE> <INDENT> if i % k == 0 : <NEWLINE> <INDENT> f = <STRING> <NEWLINE> <DEDENT> <DEDENT> print ( f ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = <STRING> <NEWLINE> for i in range ( a , b + 1 ) : <NEWLINE> <INDENT> if i % k == 0 : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if a // k != b // k : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b , n = map ( int , input ( ) . split ( ) ) <NEWLINE> a1 = int ( a * n / b ) - a * int ( n / b ) <NEWLINE> print ( a1 ) <NEWLINE>
k = int ( input ( ) ) <NEWLINE> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> i = 1 <NEWLINE> flag = False <NEWLINE> <NL> while i < b : <NEWLINE> <INDENT> dis = i * k <NEWLINE> if dis >= a and dis <= b : <NEWLINE> <INDENT> flag = True <NEWLINE> break <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if flag : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a = int ( input ( ) ) <NEWLINE> b , c = map ( int , input ( ) ) <NEWLINE> if c - b >= c % a : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
K = int ( input ( ) ) <NEWLINE> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> nK = K <NEWLINE> n = 1 <NEWLINE> ans = <STRING> <NEWLINE> while ( nK = < B ) : <NEWLINE> <INDENT> if nK >= A : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> break <NEWLINE> <DEDENT> n += 1 <NEWLINE> nK = n * K <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
k = int ( input ( ) ) <NEWLINE> a , b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> flg = False <NEWLINE> for i in range ( a , b + 1 ) : <NEWLINE> <INDENT> if i % k == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> flg = True <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) if not ( flg ) <NEWLINE>
mport sys <NEWLINE> K = int ( input ( ) ) <NEWLINE> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> for i in range ( A , B + 1 ) : <NEWLINE> <INDENT> if i % K == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
k = int ( input ( ) ) <NEWLINE> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> for i in range ( a , b + 1 ) : <NEWLINE> <INDENT> if i % k == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <INDENT> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
K = int ( input ( ) ) <NEWLINE> A , B = map ( int , input ( ) . slice ( ) ) <NEWLINE> print ( <STRING> if B - A >= K else <STRING> ) <NEWLINE>
k = int ( input ( ) ) <NEWLINE> [ a , b ] = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> f = 0 <NEWLINE> for i in range ( a , b + 1 ) : <NEWLINE> <INDENT> if i % k == 0 : <NEWLINE> <INDENT> f = 1 <NEWLINE> <DEDENT> <DEDENT> if f : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
k = int ( input ( ) ) <NEWLINE> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> for i in range ( 1 , 1001 ) : <NEWLINE> <INDENT> n == k * i <NEWLINE> if a <= n <= b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> <NL> <NL>
k = int ( input ( ) ) <NEWLINE> a , b = list ( map ( int , input . split ( ) ) ) <NEWLINE> res = 0 <NEWLINE> for i in range ( a , b + 1 ) : <NEWLINE> <INDENT> if ( i % k == 0 ) : <NEWLINE> <INDENT> res = 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if ( res == 1 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a = int ( input ( ) ) <NEWLINE> list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> b = list [ 0 ] // a <NEWLINE> c = list [ 1 ] // a <NEWLINE> <NL> if list [ 1 ] % a == 0 <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> elif c - b >= 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
K = int ( input ( ) ) <NEWLINE> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if B - A >= K - 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif A % K > B % K : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif A % K = 0 or B % K = 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
from math import * <NEWLINE> k = int ( input ( ) ) <NEWLINE> a = int ( input ( ) ) <NEWLINE> b = int ( input ( ) ) <NEWLINE> m = 0 <NEWLINE> while a <= b : <NEWLINE> <INDENT> if a % k == 0 : <NEWLINE> <INDENT> m = 1 <NEWLINE> break <NEWLINE> <DEDENT> a = a + 1 <NEWLINE> <DEDENT> if m == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
k = int ( input ( ) ) <NEWLINE> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if k >= 2 and b - a >= k - 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif k == a or k == b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a < k and k < b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> print k == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
K = int ( input ( ) ) <NEWLINE> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> for i in range ( a , b + 1 ) : <NEWLINE> <INDENT> if i % K == 0 : <NEWLINE> print ( <STRING> ) <NEWLINE> else : <NEWLINE> print ( <STRING> ) <NEWLINE> return <NEWLINE> <DEDENT>
A , B , N = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> MAX = float ( <STRING> ) * ( - 1 ) <NEWLINE> a = int ( A / B ) <NEWLINE> b = B <NEWLINE> if N < B : <NEWLINE> <INDENT> MAX = ( A * N // B ) - A * ( N // B ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> MAX = ( A * ( B - 1 ) // B ) - A * ( ( B - 1 ) // B ) <NEWLINE> <DEDENT> print ( MAX ) <NEWLINE>
k = int ( input ( ) ) <NEWLINE> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> bool flag = true <NEWLINE> for i in range ( a , b + 1 ) : <NEWLINE> <INDENT> if ( a % k == 0 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> flag = false <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if ( flag ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
K = int ( input ( ) ) <NEWLINE> A , B = [ int ( s ) for s in input ( ) . split ( ) ] <NEWLINE> <NL> largest = B // K * K <NEWLINE> <NL> print ( <STRING> if largest >= a else <STRING> ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> K = int ( input ( ) ) <NEWLINE> line = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a , b = line [ 0 ] , line [ 1 ] <NEWLINE> if B < K : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> if ( b - a + 1 ) >= K : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( a , b + 1 ) : <NEWLINE> <INDENT> if i % K == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
S = int ( input ( ) ) <NEWLINE> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> check = false <NEWLINE> ans = 0 <NEWLINE> i = 1 <NEWLINE> while S <= B : <NEWLINE> <INDENT> ans = S * i <NEWLINE> if A <= ans and B >= ans : <NEWLINE> <INDENT> check = true <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if check : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
K = int ( input ( ) ) <NEWLINE> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> for i in range ( A : B + 1 ) : <NEWLINE> <INDENT> if i % K == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import math <NEWLINE> def equation ( a , b , n ) : <NEWLINE> <INDENT> return math . floor ( ( a * n ) / b ) - a * math . floor ( n / b ) <NEWLINE> <DEDENT> d , e , f = map ( int , input ( ) . split ( ) ) <NEWLINE> K = min ( e - 1 , f ) <NEWLINE> print ( equation ( K ) ) <NEWLINE>
k = int ( input ( ) ) <NEWLINE> a , b = map ( int , input ( ) ) <NEWLINE> <NL> answer = <STRING> <NEWLINE> <NL> for i in range ( a , b ) : <NEWLINE> <INDENT> if i % k == 0 : <NEWLINE> <INDENT> answer = <STRING> <NEWLINE> <DEDENT> <DEDENT> print ( answer ) <NEWLINE> <NL>
k = int ( input ( ) ) <NEWLINE> a , b = map ( int , inupt ( ) . split ( ) ) <NEWLINE> for i in range ( a , b + 1 ) : <NEWLINE> <INDENT> if i % k == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif i == b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> for i in range ( a , b + 1 ) : <NEWLINE> <INDENT> if ( i % k == 0 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <INDENT> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
k = int ( input ( ) ) <NEWLINE> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <NL> for i in range ( a , b + 1 ) : <NEWLINE> <INDENT> if i % k == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
k = int ( input ( ) ) <NEWLINE> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> ok = False <NEWLINE> for i in range ( a , b + 1 ) : <NEWLINE> <INDENT> ok = ok or i % k <NEWLINE> <DEDENT> print ( [ <STRING> , <STRING> ] [ ok ] ) <NEWLINE>
k = int ( input ( ) ) <NEWLINE> a = int ( input ( ) ) <NEWLINE> b = int ( input ( ) ) <NEWLINE> <NL> for i in range ( a , b + 1 ) : <NEWLINE> <INDENT> if i % k == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
k = int ( input ( ) ) <NEWLINE> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> for i in range ( a , b + 1 ) : <NEWLINE> <INDENT> if i % k == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <INDENT> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
K = int ( input ( ) ) <NEWLINE> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> for i in range ( A , B + 1 ) : <NEWLINE> <INDENT> if i % K == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
K = int ( input ( ) ) <NEWLINE> arr = list ( map ( int , input ( ) ) ) <NEWLINE> a = arr [ 1 ] % K <NEWLINE> b = arr [ 1 ] - arr [ 0 ] <NEWLINE> if a > b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <STRING> <NEWLINE> import math <NEWLINE> import sys <NEWLINE> import os <NEWLINE> <NL> def isDivisible ( num1 , num2 ) : <NEWLINE> <INDENT> return num1 % num2 == 0 <NEWLINE> <NL> <DEDENT> def binary_search ( n , m , k ) : <NEWLINE> <INDENT> if isDivisible ( n , k ) | isDivisible ( m , k ) : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> elif abs ( n - m ) <= 1 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> mid = math . ceil ( ( n + m ) / 2 ) <NEWLINE> if ( isDivisible ( mid , k ) ) : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> elif mid - n < k : <NEWLINE> <INDENT> return binary_search ( mid + 1 , m , k ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return binary_search ( n , mid - 1 , k ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def solution ( k , n , m ) : <NEWLINE> <INDENT> if k == 1 : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> elif isDivisible ( n , k ) | isDivisible ( m , k ) : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> elif abs ( n - m ) <= 1 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> elif k > m : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return binary_search ( n , m , k ) <NEWLINE> <NL> <NL> <NL> <DEDENT> <DEDENT> input = sys . stdin <NEWLINE> output = sys . stdout <NEWLINE> while True : <NEWLINE> <INDENT> lineElements = input . readline ( ) . rstrip ( <STRING> ) . split ( <STRING> ) <NEWLINE> if ( lineElements [ 0 ] == <STRING> ) : <NEWLINE> <INDENT> break ; <NEWLINE> <DEDENT> if len ( lineElements ) == 1 : <NEWLINE> <INDENT> k = int ( lineElements [ 0 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> n , m = lineElements <NEWLINE> n , m = int ( n ) , int ( m ) <NEWLINE> if solution ( k , n , m ) == True : <NEWLINE> <INDENT> output . writeLine ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> output . writeLine ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
K = int ( input ( ) ) <NEWLINE> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> if K = 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif B - A >= K : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
K = input ( ) <NEWLINE> A = input ( ) <NEWLINE> B = input ( ) <NEWLINE> <NL> list = [ ] <NEWLINE> up = int ( A ) <NEWLINE> <NL> for i in range ( int ( B ) - int ( A ) ) : <NEWLINE> <INDENT> list = list + [ up ] <NEWLINE> up += 1 <NEWLINE> <DEDENT> list = list + [ up ] <NEWLINE> <NL> count = 0 <NEWLINE> <NL> for t in list : <NEWLINE> <INDENT> if int ( t ) % int ( K ) == 0 : <NEWLINE> <INDENT> count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if count == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT>
input = map ( int , [ input ( ) ] + input ( ) . split ( <STRING> ) ) <NEWLINE> [ k , start , end ] = input <NEWLINE> <NL> for i in range ( start , end + 1 ) : <NEWLINE> <INDENT> if i % k == 0 : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> <DEDENT> return False <NEWLINE> <NL>
k = int ( input ( ) ) <NEWLINE> a , b = int ( input ( ) . split ( ) ) <NEWLINE> if k <= b - a : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if b % k <= a % k : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
K = int ( input ( ) ) <NEWLINE> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> A_bai = int ( A / K ) <NEWLINE> B_bai = int ( B / K ) <NEWLINE> <NL> if A_bai != B_bai : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else if ( A % K == 0 ) | | ( B % K == 0 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
k = int ( input ( ) ) <NEWLINE> n = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> d = 0 <NEWLINE> for i in range ( a , b + 1 ) : <NEWLINE> <INDENT> if i % k == 0 : <NEWLINE> <NL> <INDENT> d = 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if d == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
k = input ( ) <NEWLINE> a , b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> isYes = False <NEWLINE> for i in range ( a , b + 1 ) : <NEWLINE> <INDENT> if i % k == 0 : <NEWLINE> <INDENT> isYes = True <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> if isYes else <STRING> ) <NEWLINE>
K = int ( input ( ) ) <NEWLINE> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> for i in range ( A , B + 1 ) : <NEWLINE> <INDENT> if i % K == 0 : <NEWLINE> <INDENT> print ( OK ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> <DEDENT> if i = B : <NEWLINE> <INDENT> print ( NG ) <NEWLINE> <DEDENT>
K = int ( input ( ) ) <NEWLINE> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> a = 0 <NEWLINE> for i in range ( A , B + 1 ) : <NEWLINE> <INDENT> if i % k == 0 : <NEWLINE> <INDENT> a = 1 <NEWLINE> <DEDENT> <DEDENT> if a == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT>
K = int ( input ( ) ) <NEWLINE> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> for i in range ( A , B + 1 ) : <NEWLINE> <INDENT> if i % K == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exec ( ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
a = int ( input ( ) ) <NEWLINE> <NL> low , hi = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> start = a * low // a <NEWLINE> <NL> boolean = False <NEWLINE> <NL> while not ( start > hi ) : <NEWLINE> <INDENT> if lo <= start <= hi : <NEWLINE> <INDENT> boolean = True <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if boolean : print ( <STRING> ) <NEWLINE> else : print ( <STRING> ) <NEWLINE>
c , a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> d = 0 <NEWLINE> <NL> while a <= b : <NEWLINE> <INDENT> if a % c == 0 : <NEWLINE> <INDENT> d = d + 1 ; <NEWLINE> <NL> <DEDENT> a = a + 1 ; <NEWLINE> <NL> <DEDENT> if d == 0 : <NEWLINE> <INDENT> print ( <STRING> ) ; <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) ; <NEWLINE> <DEDENT>
K = int ( input ( ) ) <NEWLINE> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> a = A // K <NEWLINE> b = A % K <NEWLINE> c = B % K <NEWLINE> <NL> if ( b == 0 or c == 0 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if ( 1 < a ) : <NEWLINE> <INDENT> if ( a * K <= B ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> ~ <NEWLINE>
1 <NEWLINE> 11 11 <NEWLINE>
k = int ( input ( ) ) <NEWLINE> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> c = True <NEWLINE> for i in range ( a , b + 1 ) : <NEWLINE> <INDENT> if i % k == 0 : <NEWLINE> <INDENT> print ( OK ) <NEWLINE> c = False <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if c : <NEWLINE> <INDENT> print ( NG ) <NEWLINE> <DEDENT>
k = int ( input ( ) ) <NEWLINE> a , b = map ( int , input ( ) ) <NEWLINE> <NL> ans = <STRING> <NEWLINE> if a % k == 0 : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <DEDENT> elif b % k == 0 : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <DEDENT> elif ( b - a ) / k > 0 : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
k = int ( input ( ) ) <NEWLINE> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> flag = 0 <NEWLINE> for i in range ( 1000 ) : <NEWLINE> <INDENT> if ( a <= k * ( i + 1 ) and ( b >= k * ( i + 1 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> flag = 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if flag != 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
K = int ( input ( ) ) <NEWLINE> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> s = ( B // K ) * K <NEWLINE> if s = > A : <COMMENT> <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
k = int ( input ( ) ) <NEWLINE> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> i = n % k <NEWLINE> if i == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> j = n - i <NEWLINE> <NL> if a > j : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
k = int ( input ( ) ) <NEWLINE> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> flag = 0 <NEWLINE> for i in range ( a , b + 1 ) : <NEWLINE> <INDENT> if i % k == 0 : <NEWLINE> <INDENT> flag = 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if flag = 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> K = int ( input ( ) ) <NEWLINE> ( A , B ) = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> if A % K == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif math . ceil ( A / K ) * K <= B : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
K = int ( input ( ) ) <NEWLINE> A = int ( input ( ) ) <NEWLINE> B = int ( input ( ) ) <NEWLINE> <STRING> <NEWLINE> q = 0 <NEWLINE> <NL> <NL> for i in range ( 1 , 1000 ) : <NEWLINE> <INDENT> if A <= i * K & i * K <= B : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> q = 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if q == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <NL> <DEDENT>
K = int ( input ) <NEWLINE> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> for i range ( A , B + 1 ) : <NEWLINE> <INDENT> if i % K == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
K = int ( input ( ) ) <NEWLINE> A , B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> count = 0 <NEWLINE> while count * K < A : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> if count * K <= B : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
k = int ( inut ( ) ) <NEWLINE> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> for i in range ( b - a ) : <NEWLINE> <INDENT> if ( a + i ) % k == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
k = int ( input ( ) ) ; <NEWLINE> i = list ( map ( int , input ( ) . split ( ) ) ) ; <NEWLINE> <NL> a = int ( i [ 0 ] ) ; <NEWLINE> b = int ( i [ 1 ] ) ; <NEWLINE> flag = False ; <NEWLINE> <NL> while a <= b : <NEWLINE> <INDENT> if a % k == 0 : <NEWLINE> <INDENT> flag = True ; <NEWLINE> break ; <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> continue ; <NEWLINE> <DEDENT> a += 1 ; <NEWLINE> <NL> <DEDENT> if ( flag ) : <NEWLINE> <INDENT> print ( <STRING> ) ; <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) ; <NEWLINE> <NL> <DEDENT>
K = int ( input ( ) ) <NEWLINE> a , b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in range ( a , b + 1 ) <NEWLINE> <INDENT> if i % K == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
k = int ( input ( ) ) <NEWLINE> a , b = map ( int , input ( ) . split ) ) <NEWLINE> <NL> aa = a % k <NEWLINE> bb = b % k <NEWLINE> <NL> if ( b - a > k ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> if ( aa > bb ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> if ( aa == 0 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
x = int ( input ( ) ) <NEWLINE> de = 100 <NEWLINE> count = 0 <NEWLINE> while de < x : <NEWLINE> <INDENT> count += 1 <NEWLINE> de //= 100 <NEWLINE> <DEDENT> print ( count ) <NEWLINE>
import math <NEWLINE> x = int ( raw_input ( ) ) <NEWLINE> now = 100 <NEWLINE> ans = 0 <NEWLINE> while ( now < x ) : <NEWLINE> <INDENT> ans += 1 <NEWLINE> now *= 1.01 <NEWLINE> now = math . floor ( now ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
X = int ( input ( ) ) <NEWLINE> <NL> count = 0 <NEWLINE> save = 100 <NEWLINE> <NL> while save < X : <NEWLINE> <INDENT> save += a / 100 <NEWLINE> save = int ( save ) <NEWLINE> count += 1 <NEWLINE> <NL> <DEDENT> print ( count ) <NEWLINE>
X = int ( input ( ) ) <NEWLINE> year = 0 <NEWLINE> deposit = 100 <NEWLINE> while deposit < x : <NEWLINE> <INDENT> deposit = deposit * 101 // 100 <NEWLINE> year += 1 <NEWLINE> <DEDENT> print ( year ) <NEWLINE>
mport math <NEWLINE> money = 100 <NEWLINE> x = int ( input ( ) ) <NEWLINE> <COMMENT> <NL> cnt = 0 <NEWLINE> while money <= x : <NEWLINE> <INDENT> money += money * 0.01 <NEWLINE> money = int ( money ) <NEWLINE> cnt += 1 <NEWLINE> <COMMENT> <NL> <DEDENT> print ( cnt ) <NEWLINE>
x = int ( input ( ) ) <NEWLINE> import math <NEWLINE> <NL> sum = 0 <NEWLINE> y = 100 <NEWLINE> for i in range ( 200000 ) : <NEWLINE> <INDENT> y = math . floor ( y * 1.01 ) <NEWLINE> if y <= x : <NEWLINE> <INDENT> sum += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> sum = sum <NEWLINE> <DEDENT> <DEDENT> print ( sum + 1 ) <NEWLINE>
m = 100 <NEWLINE> quota = int ( input ( ) ) <NEWLINE> cnt = 0 <NEWLINE> while ( m <= quote ) : <NEWLINE> <INDENT> m = int ( m * 1.01 ) <NEWLINE> cnt += 1 <NEWLINE> <NL> <DEDENT> print ( cnt ) <NEWLINE>
X = int ( input ( ) ) <NEWLINE> Y = 100 <NEWLINE> A = 0 <NEWLINE> While X < Y : <NEWLINE> <INDENT> Y *= 1.01 <NEWLINE> A += 1 <NEWLINE> <DEDENT> print ( A ) <NEWLINE>
<NL> X = int ( input ( ) ) <NEWLINE> m = 100 <NEWLINE> y = 0 <NEWLINE> while True : <NEWLINE> <INDENT> if X <= m : break <NEWLINE> m = math . floor ( m * 1.01 ) <NEWLINE> y += 1 <NEWLINE> <DEDENT> print ( y ) <NEWLINE>
t = int ( input ( ) ) <NEWLINE> a = 0 <NEWLINE> b = 100 <NEWLINE> while b < t : <NEWLINE> <INDENT> b = b * 1.01 <NEWLINE> b = int ( b ) <NEWLINE> a = a + 1 <NEWLINE> <DEDENT> print ( k ) <NEWLINE>
x = int ( input ( ) ) <NEWLINE> for n in 10 ** 10 ** 10 : <NEWLINE> <INDENT> if x <= ( 101 ** n ) / ( 100 ** ( n - 1 ) ) : <NEWLINE> <INDENT> print ( n ) <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> X = int ( input ( ) ) <NEWLINE> <NL> A = 100 <NEWLINE> i = 0 <NEWLINE> <NL> while true : <NEWLINE> <INDENT> if X <= A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> i += 1 <NEWLINE> A = math . floor ( A * 1.1 ) : <NEWLINE> <DEDENT> <DEDENT>
def actual ( x ) : <NEWLINE> <INDENT> amount = 100 <NEWLINE> <NL> count = 0 <NEWLINE> <NL> while True : <NEWLINE> <INDENT> amount *= 1.01 <NEWLINE> amount = math . floor ( amount ) <NEWLINE> <NL> count += 1 <NEWLINE> <NL> if amount >= x : <NEWLINE> <INDENT> return count <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> x = int ( input ( ) ) <NEWLINE> print ( actual ( x ) ) <NEWLINE>
x = int ( input ( ) ) <NEWLINE> d = 0 <NEWLINE> ans = 0 <NEWLINE> while d < x : <NEWLINE> <INDENT> d += d // 100 <NEWLINE> ans += 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
X = int ( input ( ) ) <NEWLINE> s = 100 <NEWLINE> c = 0 <NEWLINE> while s < X : <NEWLINE> <INDENT> s = s + s // 100 <NEWLINE> <INDENT> c = c + 1 <NEWLINE> <DEDENT> <DEDENT> print ( c ) <NEWLINE>
from math import floor <NEWLINE> <NL> def f ( x , y , n ) : <NEWLINE> <INDENT> if x >= y : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> n += 1 <NEWLINE> x += floor ( x * 0.01 ) <NEWLINE> return f ( x , y , n ) <NEWLINE> <NL> <DEDENT> <DEDENT> x = int ( input ( ) ) <NEWLINE> print ( f ( 100 , x , n ) ) <NEWLINE>
num = input ( ) <NEWLINE> a = 100 <NEWLINE> count = 0 <NEWLINE> while count >= 0 : <NEWLINE> <INDENT> a = a * 1.1 <NEWLINE> count = count + 1 <NEWLINE> if a >= num : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
year = 0 <COMMENT> <NEWLINE> money = 100 <COMMENT> <NEWLINE> <NL> <COMMENT> <NL> while money < x : <NEWLINE> <INDENT> money *= 1.01 <NEWLINE> money = int ( money ) <NEWLINE> year += 1 <NEWLINE> <NL> <DEDENT> print ( year ) <NEWLINE>
X = int ( input ( ) ) <NEWLINE> check = false <NEWLINE> ans = 100 <NEWLINE> count = 0 <NEWLINE> while ans < X : <NEWLINE> <INDENT> ans *= 1.01 <NEWLINE> count += 1 <NEWLINE> <DEDENT> print ( count ) <NEWLINE> <NL>
<INDENT> s = 0 <NEWLINE> temp = 100 <NEWLINE> while temp < x : <NEWLINE> <INDENT> s += 1 <NEWLINE> temp = int ( temp * 1.01 ) <NEWLINE> <DEDENT> print ( s ) <NEWLINE> <DEDENT>
from decimal import Decimal <NEWLINE> <NL> X = int ( input ( ) ) <NEWLINE> <NL> money = 100 <NEWLINE> cnt = 0 <NEWLINE> <NL> while money < X : <NEWLINE> <INDENT> money = Decimal ( money * 1.01 ) <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> print ( cnt ) <NEWLINE>
import math <NEWLINE> X = int ( input ( ) . split ) <NEWLINE> Yokin = 100 <NEWLINE> Nen = 0 <NEWLINE> <NL> while X > Yokin : <NEWLINE> <INDENT> Yokin = math . floor ( Yokin * 1.01 ) <NEWLINE> Nen = Nen + 1 <NEWLINE> <NL> <DEDENT> print ( Nen ) <NEWLINE> <NL>
import math <NEWLINE> X = int ( input ( ) ) <NEWLINE> u = 100 <NEWLINE> y = 0 <NEWLINE> while u >= 0 : <NEWLINE> <INDENT> u = math . floor ( u * 1.01 ) <NEWLINE> y += 1 <NEWLINE> <DEDENT> print ( y ) <NEWLINE>
x = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> a = 100 <NEWLINE> While a < x : <NEWLINE> <INDENT> a = a ** 1.01 <NEWLINE> ans += 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
a = int ( input ( ) ) <NEWLINE> p = 100 <NEWLINE> cnt = 0 <NEWLINE> while ( p != a ) : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> print ( cnt ) <NEWLINE>
X = int ( input ( ) ) <NEWLINE> trial = 0 <NEWLINE> p = 100 <NEWLINE> while p <= x : <NEWLINE> <INDENT> trial += 1 <NEWLINE> p = p * 1.01 <NEWLINE> <DEDENT> print ( trial ) <NEWLINE>
req = int ( input ( ) ) <NEWLINE> count = 0 <NEWLINE> p = 100 <NEWLINE> while P < req : <NEWLINE> <INDENT> p += int ( p / 100 ) <NEWLINE> count += 1 <NEWLINE> <NL> <DEDENT> print ( count ) <NEWLINE>
x = int ( input ( ) ) <NEWLINE> year = 0 <NEWLINE> yen = 100 <NEWLINE> while x > yen : <NEWLINE> <INDENT> yen = int ( yen * 1.01 ) <NEWLINE> year += <NEWLINE> <NL> <DEDENT> print ( year ) <NEWLINE>
x = int ( input ( ) ) <NEWLINE> m = 100 <NEWLINE> <NL> import math <NEWLINE> count = 0 <NEWLINE> while True : <NEWLINE> <INDENT> if m >= x : <NEWLINE> <INDENT> print ( count ) <NEWLINE> break <NEWLINE> <DEDENT> x = math . floor ( m * 1.01 ) <NEWLINE> count += 1 <NEWLINE> <NL> <DEDENT>
X = int ( input ( ) ) <NEWLINE> base = 100 <NEWLINE> rt = 0 <NEWLINE> while X > base : <NEWLINE> <INDENT> base = math . floor ( base * 1.01 ) <NEWLINE> rt += 1 <NEWLINE> <DEDENT> print ( rt ) <NEWLINE>
x = int ( input ( ) ) <NEWLINE> <NL> a = 100 <NEWLINE> k = 0 <NEWLINE> while ( 1 ) : <NEWLINE> <INDENT> k += 1 <NEWLINE> a = a + a ( 1 // 100 ) <NEWLINE> if ( a >= x ) : break <NEWLINE> <DEDENT> print ( k ) <NEWLINE>
i = int ( input ( ) ) <NEWLINE> count = 0 <NEWLINE> while i < p : <NEWLINE> <INDENT> p = p * 1.01 <NEWLINE> count += 1 <NEWLINE> <DEDENT> print ( count ) <NEWLINE>
1000000000000000000 k = int ( input ( ) ) <NEWLINE> start = 100 <NEWLINE> i = 0 <NEWLINE> while True : <NEWLINE> <INDENT> i += 1 <NEWLINE> start *= 1.01 <NEWLINE> start = int ( start ) <NEWLINE> if start > k : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> print ( i ) <NEWLINE>
x = input ( ) <NEWLINE> tmp = 100 <NEWLINE> for i in range ( 10000 ) : <NEWLINE> <INDENT> if tmp >= x : <NEWLINE> <INDENT> print ( i ) <NEWLINE> break <NEWLINE> <DEDENT> tmp += tmp // 100 <NEWLINE> <DEDENT>
x = int ( input ( ) ) <NEWLINE> cost = 100 <NEWLINE> while ( cost < x ) : <NEWLINE> <INDENT> cost = cost * 101 // 100 <NEWLINE> ans += 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> X = int ( input ( ) ) <NEWLINE> n = 1 <NEWLINE> Y = 100 ** ( n - 1 ) <NEWLINE> while Y < X : <NEWLINE> <INDENT> n += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( n ) <NEWLINE> <DEDENT>
X = int ( input ( ) ) <NEWLINE> yen = 100 <NEWLINE> count = 0 <NEWLINE> <NL> while True : <NEWLINE> <INDENT> yen *= 1.01 <NEWLINE> count += 1 <NEWLINE> <NL> if int ( year ) >= X : <NEWLINE> <INDENT> print ( count ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT>
x = int ( input ( ) ) <NEWLINE> const_a , count = 100 , 0 <NEWLINE> <NL> while const_a < x : <NEWLINE> <INDENT> a += a // 100 <NEWLINE> count += 1 <NEWLINE> <DEDENT> print ( count ) <NEWLINE>
import sys <NEWLINE> K = int ( input ( ) ) <NEWLINE> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> for i in range ( 1000 ) : <NEWLINE> <INDENT> s = K * i <NEWLINE> if A <= s <= B : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
G = int ( input ( ) ) <NEWLINE> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> Total = <STRING> <NEWLINE> for i in range ( A , B + 1 ) : <NEWLINE> <INDENT> if i % G != 0 : <NEWLINE> <INDENT> Total = <STRING> <NEWLINE> <DEDENT> <DEDENT> print ( Total ) <NEWLINE>
x = int ( input ( ) ) <NEWLINE> t = 0 <NEWLINE> i = 0 <NEWLINE> while t < x : <NEWLINE> <INDENT> t = int ( t * ( 1.01 ) ) <NEWLINE> i += 1 <NEWLINE> <NL> <DEDENT> print ( i ) <NEWLINE>
K = int ( input ( ) ) <NEWLINE> k = K <NEWLINE> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> for i in range ( 1 , B + 1 ) : <NEWLINE> <INDENT> k *= i <NEWLINE> if k > a and k < b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> a = True <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if not a : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
x = int ( input ( ) ) <NEWLINE> <NL> i = 0 <NEWLINE> while a < x : <NEWLINE> <INDENT> a = math . floor ( x * 0.01 ) <NEWLINE> i += 1 <NEWLINE> <DEDENT> print ( i ) <NEWLINE>
x = int ( input ( ) ) <NEWLINE> credit = 100 <NEWLINE> year = 0 <NEWLINE> <NL> <NL> for i in range ( 10 ** 18 ) : <NEWLINE> <COMMENT> <NL> <INDENT> credit = credit // 100 <NEWLINE> if ( x <= credit ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> print ( year ) <NEWLINE> <NL>
X = int ( input ( ) ) <NEWLINE> A = 100 <NEWLINE> Y = 0 <NEWLINE> while A < X : <NEWLINE> <INDENT> A = int ( y * 1.01 ) <NEWLINE> Y += 1 <NEWLINE> <DEDENT> print ( Y ) <NEWLINE>
b = 100 <NEWLINE> x = int ( input ( ) ) <NEWLINE> while ( b < x ) : <NEWLINE> <INDENT> b += b // 100 <NEWLINE> ans += 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> N = int ( input ( ) ) <NEWLINE> <NL> y >= math . log ( 1.01 , N / 100 ) <NEWLINE> print ( y ) <NEWLINE>
x = int ( input ( ) ) <NEWLINE> temp = int ( 100 ) <NEWLINE> <NL> while temp < x : <NEWLINE> <INDENT> temp *= 0.01 <NEWLINE> <NL> <DEDENT> print ( temp ) <NEWLINE>
a = int ( input ( ) ) <NEWLINE> i = 100 // a <NEWLINE> f = 0 <NEWLINE> while i < 1 : <NEWLINE> <INDENT> i = i + i // 100 <NEWLINE> f = f + 1 <NEWLINE> <DEDENT> print ( f ) <NEWLINE>
using namespace std ; <NEWLINE> int main ( ) { <NEWLINE> <INDENT> long long x ; <NEWLINE> cin >> x , <NEWLINE> long long p , yr = 0 ; <NEWLINE> while p < x { <NEWLINE> <INDENT> p += p / 100 <NEWLINE> yr + + <NEWLINE> <DEDENT> } <NEWLINE> cout << yr << endl ; <NEWLINE> return 0 <NEWLINE> <DEDENT> } <NEWLINE>
X = int ( input ( ) ) <NEWLINE> <NL> tmp = 100 <NEWLINE> cnt = <NEWLINE> while tmp < X : <NEWLINE> <INDENT> tmp = tmp + int ( tmp * 0.01 ) <NEWLINE> cnt += 1 <NEWLINE> <NL> <DEDENT> print ( cnt ) <NEWLINE> <NL>
N = int ( input ( ) ) <NEWLINE> <NL> x = 100.0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> x = math . floor ( x * 1.01 ) <NEWLINE> if ( x >= N ) : <NEWLINE> <INDENT> print ( i + 1 ) <NEWLINE> break ; <NEWLINE> <DEDENT> i += 1 <NEWLINE> <DEDENT>
a = int ( input ( ) ) <NEWLINE> t = 100 <NEWLINE> sum = 0 <NEWLINE> while ( t < a ) : <NEWLINE> <INDENT> t = math . floor ( t * 101 / 100 ) <NEWLINE> sum = sum + 1 <NEWLINE> <DEDENT> print ( sum ) <NEWLINE>
x = int ( input ( ) ) <NEWLINE> times = 0 <NEWLINE> money = 100 <NEWLINE> while money < x : <NEWLINE> <INDENT> money * 1.01 <NEWLINE> times += 1 <NEWLINE> <NL> <DEDENT> print ( times ) <NEWLINE>
X = int ( input ( ) ) <NEWLINE> count = 0 <NEWLINE> money = 100 <NEWLINE> <NL> while Ture : <NEWLINE> <INDENT> money = int ( money * 1.01 ) <NEWLINE> count += 1 <NEWLINE> if money >= X : <NEWLINE> <INDENT> print ( count ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT>
X = int ( input ( ) ) <NEWLINE> sum = 0 <NEWLINE> for i in range ( 10000 ) <NEWLINE> <INDENT> if ( 100 * ( ( 1.01 ) ** i ) ) < X : <NEWLINE> <INDENT> sum += 1 <NEWLINE> <DEDENT> <DEDENT> print ( sum ) <NEWLINE>
input1 = input ( ) <NEWLINE> kbai = int ( input1 ) <NEWLINE> <NL> input2 = input ( ) . split ( <STRING> ) <NEWLINE> maxs = int ( input2 [ 0 ] ) <NEWLINE> mins = int ( input2 [ 1 ] ) <NEWLINE> flg = 0 <NEWLINE> ans = 0 <NEWLINE> <NL> while ans < maxs : <NEWLINE> <INDENT> ans = ans + kbai <NEWLINE> if ans >= mins and ans <= maxs : <NEWLINE> <INDENT> flg = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if flg == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import sys <NEWLINE> import math <NEWLINE> def Ii ( ) : return int ( sys . stdin . buffer . readline ( ) ) <NEWLINE> def Mi ( ) : return map ( int , sys . stdin . buffer . readline ( ) . split ( ) ) <NEWLINE> def Li ( ) : return list ( map ( int , sys . stdin . buffer . readline ( ) . split ( ) ) ) <NEWLINE> <NL> x = Ii ( ) <NEWLINE> ans = ( math . log10 ( x ) - 2 ) math . log10 ( 1.01 ) <NEWLINE> k = 100 <NEWLINE> while x > k : <NEWLINE> <INDENT> tax = k // 100 <NEWLINE> k += tax <NEWLINE> ans += 1 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
from sys import stdin <NEWLINE> <NL> X = int ( stdin . readline ( ) ) <NEWLINE> Y = 100 <NEWLINE> <NL> count = 1 <NEWLINE> while True : <NEWLINE> <INDENT> Y += Y * 0.01 <NEWLINE> if Y >= X : <NEWLINE> <INDENT> print ( count ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT>
K = int ( input ( ) ) <NEWLINE> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> C = B - A <NEWLINE> if C >= K : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif A % K == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif B % K == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import math <NEWLINE> X = int ( input ( ) ) <NEWLINE> Y = 100 <NEWLINE> count = 0 <NEWLINE> while Y = < X : <NEWLINE> <INDENT> Y = math . floor ( Y * 1.01 ) <NEWLINE> count += 1 <NEWLINE> <NL> <DEDENT> print ( count ) <NEWLINE> <NL>
K = int ( input ( ) ) <NEWLINE> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> XK = list ( x * K for x in range ( 1 , 1000 // K + 1 ) ) <NEWLINE> for i in XK : <NEWLINE> <INDENT> if ( A <= i ) & ( i <= B ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
X = int ( input ( ) ) <NEWLINE> deposit = 100 <NEWLINE> year = 0 <NEWLINE> while ( deopsit < X ) : <NEWLINE> <INDENT> deposit = deposit * 101 // 100 <NEWLINE> year += 1 <NEWLINE> <DEDENT> print ( year ) <NEWLINE>
t = input ( ) <NEWLINE> import math <NEWLINE> print ( math . log ( t ) - math . log ( 100 ) ) / math . log ( 1.01 ) <NEWLINE>
import math <NEWLINE> X = int ( input ( ) ) <NEWLINE> money = 100 <NEWLINE> y = 1 <NEWLINE> while X > money : <NEWLINE> <INDENT> money += moth . floor ( money * 0.01 ) <NEWLINE> y += 1 <NEWLINE> <NL> <DEDENT> print ( y ) <NEWLINE>
i = 0 <NEWLINE> x = input ( ) <NEWLINE> y = 100 <NEWLINE> while x >= y : <NEWLINE> <INDENT> y = int ( y * 101 / 100 ) <NEWLINE> i += 1 <NEWLINE> <DEDENT> print ( i ) <NEWLINE>
p = int ( input ( ) ) <NEWLINE> k = 100 <NEWLINE> o = 0 <NEWLINE> j = 0 <NEWLINE> while p > k : <NEWLINE> <INDENT> k1 = k + ( k * 101 ) // 10000 <NEWLINE> o += 1 <NEWLINE> <DEDENT> print ( o ) <NEWLINE>
from math import floor , ceil <NEWLINE> X = int ( input ( ) ) <NEWLINE> <NL> p = 100 <NEWLINE> c = 0 <NEWLINE> while cash < X : <NEWLINE> <INDENT> p = floor ( p * 1.01 ) <NEWLINE> c += 1 <NEWLINE> <DEDENT> print ( c ) <NEWLINE>
from math import log <NEWLINE> x = int ( input ( ) ) <NEWLINE> x = x / 100 <NEWLINE> return int ( log ( x ) / log ( 1.01 ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> v = 100 <NEWLINE> count = 0 <NEWLINE> while True : <NEWLINE> <INDENT> if N < v : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> count += 1 <NEWLINE> v *= 1.01 // 1 <NEWLINE> <DEDENT>
x = input ( ) <NEWLINE> ans = 0 <NEWLINE> y = x <NEWLINE> <NL> for i in range ( 10 ** 18 ) : <NEWLINE> <INDENT> y = 100 ** ( 1.01 * i ) <NEWLINE> if y > x : <NEWLINE> <INDENT> ans += 1 <NEWLINE> print ( ans ) <NEWLINE> <DEDENT> <DEDENT>
x = int ( input ) <NEWLINE> m = 100 <NEWLINE> cnt = 0 <NEWLINE> while x > m : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> m = ( m * 1.01 ) // 1 <NEWLINE> <DEDENT> print ( str ( cnt ) ) <NEWLINE>
import math <NEWLINE> x = int ( input ( ) ) <NEWLINE> mon = 100 <NEWLINE> cnt = 0 <NEWLINE> while mon < X : <NEWLINE> <INDENT> mon = math . floor ( mon * 1.01 ) <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> print ( cnt ) <NEWLINE>
import math <NEWLINE> Target = int ( input ( ) ) <NEWLINE> original = 100 <NEWLINE> i = 0 ; <NEWLINE> while ( 1 ) <NEWLINE> <INDENT> i = i + 1 ; <NEWLINE> original = int ( original + original * 0.01 ) <NEWLINE> if ( original > target ) <NEWLINE> <INDENT> print ( i ) <NEWLINE> break ; <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> money = 100 <NEWLINE> year = 0 <NEWLINE> while ( money < n ) { <NEWLINE> <INDENT> year = year + 1 <NEWLINE> money = money * 1.01 <NEWLINE> <DEDENT> } <NEWLINE> print ( year ) <NEWLINE>
x = int ( input ( ) ) <NEWLINE> money = 100 <NEWLINE> i = 0 <NEWLINE> while true : <NEWLINE> <INDENT> money * 1.01 <NEWLINE> i += 1 <NEWLINE> if money >= x : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> print i <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> x = int ( input ( ) ) <NEWLINE> <NL> money = 100 <NEWLINE> i = 0 <NEWLINE> while money < x : <NEWLINE> <INDENT> i += 1 <NEWLINE> money = money * 101 // 100 <NEWLINE> <NL> <DEDENT> print ( i ) <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE>
from decimal import Decimal <NEWLINE> import math <NEWLINE> X = int ( input ( ) ) <NEWLINE> yen = 100 <NEWLINE> n = 1 <NEWLINE> while yen < X : <NEWLINE> <INDENT> yen = decimal ( math . floor ( yen * 1.01 * n ) ) <NEWLINE> if X <= yen : <NEWLINE> <INDENT> print ( n ) <NEWLINE> <DEDENT> n = n + 1 <NEWLINE> <DEDENT>
x = int ( input ( ) ) <NEWLINE> <NL> a = 100 <NEWLINE> i = 0 <NEWLINE> <NL> while a < x : <NEWLINE> <INDENT> i += 1 <NEWLINE> a += a // 100 <NEWLINE> <NL> <NL> <DEDENT> print ( math . floor ( i ) ) <NEWLINE> <NL> <NL>
x = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> a = 100 <NEWLINE> while a < x : <NEWLINE> <INDENT> t = int ( t * 1.01 ) <NEWLINE> ans += 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
X = int ( input ( ) ) <NEWLINE> a = 100 <NEWLINE> for i in range ( 1 , 10 ** 18 ) : <NEWLINE> <INDENT> s = int ( 0.01 * a ) <NEWLINE> a += s <NEWLINE> if X <= a : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT> <DEDENT>
import math <NEWLINE> <NL> X = int ( input ( ) ) <NEWLINE> <NL> cur = 100 <NEWLINE> i = 0 <NEWLINE> <NL> while cur < X : <NEWLINE> <INDENT> cur = math . fllor ( cur * 1.01 ) <NEWLINE> i += 1 <NEWLINE> <NL> <DEDENT> print ( i ) <NEWLINE>
num = int ( input ( ) ) <NEWLINE> year = 0 <NEWLINE> cash = 100 <NEWLINE> while ( True ) { <NEWLINE> <INDENT> cash += int ( cash / 100 ) <NEWLINE> <INDENT> year + + <NEWLINE> <DEDENT> if ( num < cash ) : <NEWLINE> <INDENT> print ( year ) <NEWLINE> break <NEWLINE> <DEDENT> } <NEWLINE> <DEDENT>
import math <NEWLINE> X = int ( input ( ) ) <NEWLINE> a = 0 <NEWLINE> o = 100 <NEWLINE> while True : <NEWLINE> <INDENT> o *= 1.01 <NEWLINE> o = math . floor ( ) <NEWLINE> a += 1 <NEWLINE> if o >= X : <NEWLINE> <INDENT> print ( a ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT>
X = int ( input ( ) ) <NEWLINE> M = 100 <NEWLINE> y = 0 <NEWLINE> while X > M : <NEWLINE> <INDENT> M = int ( M * 1.01 ) <NEWLINE> y += 1 X = int ( input ( ) ) <NEWLINE> <DEDENT> M = 100 <NEWLINE> y = 0 <NEWLINE> while X > M : <NEWLINE> <INDENT> M = int ( M * 1.01 ) <NEWLINE> y += 1 <NEWLINE> <DEDENT> print ( y ) <NEWLINE>
x = int ( input ( ) ) <NEWLINE> <NL> c = 100 <NEWLINE> a = 0 <NEWLINE> while c <= x : <NEWLINE> <INDENT> c *= 0.01 <NEWLINE> c = int ( c ) <NEWLINE> a += 1 <NEWLINE> <DEDENT> print ( a ) <NEWLINE>
from math import floor , ceil <NEWLINE> X = int ( input ( ) ) <NEWLINE> cash = 100 <NEWLINE> count = 0 <NEWLINE> while cash < X : <NEWLINE> <INDENT> cash = floor ( p * 1.01 ) <NEWLINE> count += 1 <NEWLINE> <DEDENT> print ( count ) <NEWLINE>
X = input ( ) <NEWLINE> x = 100 <NEWLINE> for i in range ( 5000 ) : <NEWLINE> <INDENT> x = x * 101 / 100 <NEWLINE> if x >= X : <NEWLINE> <INDENT> print i + 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT>
import math <NEWLINE> from decimal import Decimal <NEWLINE> <NL> X = int ( input ( ) ) <NEWLINE> now = 100 <NEWLINE> year = 0 <NEWLINE> <NL> while True : <NEWLINE> <INDENT> if now >= X : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> now_bad = int ( now * Decimal ( 1.01 ) ) <NEWLINE> year += 1 <NEWLINE> <NL> <DEDENT> print ( year ) <NEWLINE>
import Decimal <NEWLINE> import math <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> x = int ( input ( ) ) <NEWLINE> y = 0 <NEWLINE> p = Decimal ( 100 ) <NEWLINE> while p < x : <NEWLINE> <INDENT> p *= Decimal ( 1.01 ) <NEWLINE> p = math . floor ( p ) <NEWLINE> y += 1 <NEWLINE> <NL> <DEDENT> print ( y ) <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE>
x = int ( input ( ) ) <NEWLINE> count = 0 <NEWLINE> while money < x : <NEWLINE> <INDENT> money = int ( money * 1.01 ) <NEWLINE> count += 1 <NEWLINE> <DEDENT> print ( count ) <NEWLINE>
x = int ( input ( ) ) <NEWLINE> n , y = 100 , 0 <NEWLINE> while n < x : <NEWLINE> <INDENT> n = n % 1.01 <NEWLINE> y = y + 1 <NEWLINE> <DEDENT> print ( y ) <NEWLINE>
x = int ( input ( ) ) <NEWLINE> m = 100 <NEWLINE> i = 0.01 <NEWLINE> y = 0 <NEWLINE> flag = True <NEWLINE> while flag : <NEWLINE> <INDENT> m = math . floor ( m * ( 1 + i ) ) <NEWLINE> y += 1 <NEWLINE> if m >= x : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> print ( y ) <NEWLINE>
X = int ( input ( ) ) <NEWLINE> count = 0 <NEWLINE> a = 100 <NEWLINE> <NL> while True : <NEWLINE> <INDENT> if a > X : <NEWLINE> <INDENT> print ( count ) <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a = math . floor ( a * 1.01 ) <NEWLINE> count = count + 1 <NEWLINE> <DEDENT> <DEDENT>
s = 100 <NEWLINE> x = int ( input ( ) ) <NEWLINE> i = 0 <NEWLINE> While True : <NEWLINE> <INDENT> if s >= x : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> s = s * 1.01 <NEWLINE> i = i + 1 <NEWLINE> <NL> <DEDENT> print ( i + 1 ) <NEWLINE>
y = 0 <NEWLINE> x = float ( input ( ) ) <NEWLINE> i = 100.0 <NEWLINE> while i <= x : <NEWLINE> <INDENT> i = i + ( i * ( 1 // 100 ) ) <NEWLINE> y = y + 1 <NEWLINE> <NL> <DEDENT> print ( y ) <NEWLINE>
x = int ( input ( ) ) <NEWLINE> l = [ 1 ] <NEWLINE> <NL> total = 100 <NEWLINE> rate = 1 <NEWLINE> <NL> year = 0 <NEWLINE> <NL> while total < x : <NEWLINE> <INDENT> total = total + total // 100 <NEWLINE> year += 1 <NEWLINE> <NL> <DEDENT> print ( year ) <NEWLINE>
import math <NEWLINE> temp = 100 <NEWLINE> year = 0 <NEWLINE> while temp < X : <NEWLINE> <INDENT> temp = int ( math . floor ( temp * 1.01 ) ) <NEWLINE> year += 1 <NEWLINE> <DEDENT> print ( year ) <NEWLINE>
import math <NEWLINE> X = int ( input ( ) ) <NEWLINE> <NL> def f ( x ) : <NEWLINE> <INDENT> return math . log ( x ) / 100.01 <NEWLINE> <NL> <DEDENT> print ( math . ceil ( f ( x ) ) ) <NEWLINE>
from math import log , ceil <NEWLINE> x = int ( input ( ) ) <NEWLINE> p = 100 <NEWLINE> r = 0.01 <NEWLINE> <NL> for i in range ( 1 , 3760 + 1 ) : <NEWLINE> <INDENT> c = floor ( p * ( 1.01 ) ** 1 ) <NEWLINE> if c < x : <NEWLINE> <INDENT> p += c - p <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> print ( i ) <NEWLINE>
X = int ( input ( ) ) <NEWLINE> y = 100 <NEWLINE> ans = 0 <NEWLINE> while ( True ) : <NEWLINE> <INDENT> ans + + <NEWLINE> y += y // 100 <NEWLINE> if ( X <= y ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
x = float ( input ( ) ) <NEWLINE> a = float ( 100 ) <NEWLINE> y = 0 <NEWLINE> while a < x : <NEWLINE> <INDENT> a *= 1.01 <NEWLINE> a = a % 1 <NEWLINE> y += 1 <NEWLINE> <DEDENT> print ( y ) <NEWLINE>
X = int ( input ( ) ) <NEWLINE> N = 100 <NEWLINE> for i in range ( 1 : 10000000000 ) : <NEWLINE> <INDENT> N = int ( N * 1.01 ) <NEWLINE> if N >= X : <NEWLINE> <INDENT> print ( i ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT>
from math <NEWLINE> X = int ( input ( ) ) <NEWLINE> def ans165 ( X : int ) : <NEWLINE> <INDENT> cash = 100 <COMMENT> <NEWLINE> count = 0 <NEWLINE> while True : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <INDENT> cash += math . floor ( cash * 0.01 ) <NEWLINE> count += 1 <COMMENT> <NEWLINE> if cash >= X : <COMMENT> <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> return count <NEWLINE> <DEDENT> print ( ans165 ( X ) ) <NEWLINE>
x = int ( input ( ) ) <NEWLINE> <NL> moto = 100 <NEWLINE> <NL> for i in range ( 100000 ) : <NEWLINE> <INDENT> moto = int ( moto * 1.01 ) <NEWLINE> if moto >= x : <NEWLINE> <INDENT> ans = i + 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( ans ] ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> x = int ( input ( ) ) <NEWLINE> <NL> total = 100 <NEWLINE> year = 0 <NEWLINE> <NL> while total < x : <NEWLINE> <INDENT> total = math . floor ( total * 1.01 ) <NEWLINE> year += 1 <NEWLINE> <NL> <DEDENT> print ( year ) <NEWLINE> <NL> <NL> <NL> <DEDENT> main ( ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> b = 100 <NEWLINE> ans = 0 <NEWLINE> while b <= n : <NEWLINE> <INDENT> b *= int ( b * 0.01 ) <NEWLINE> ans += 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
x = int ( input ( ) ) <NEWLINE> Counter = 0 <NEWLINE> Amount = 100 <NEWLINE> <NL> while ( Amount < x ) : <NEWLINE> <INDENT> simpleInterest = finalAmount // 100 <NEWLINE> Amount += simpleInterest <NEWLINE> Counter += 1 <NEWLINE> <DEDENT> print ( Counter ) <NEWLINE>
X = int ( input ( ) ) <NEWLINE> n = 0 <NEWLINE> money = 100 <NEWLINE> while ( money < X ) { <NEWLINE> <INDENT> money = money + money // 100 <NEWLINE> n = n + 1 <NEWLINE> <DEDENT> } <NEWLINE> print ( n ) <NEWLINE>
X = int ( input ( ) ) <NEWLINE> <NL> now = 0 <NEWLINE> cnt = 0 <NEWLINE> while now < X : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> now = int ( now * 1.01 ) <NEWLINE> <DEDENT> print ( cnt ) <NEWLINE>
x = int ( input ( ) ) <NEWLINE> money = 100 <NEWLINE> year = 0 <NEWLINE> <NL> while money < x : <NEWLINE> <INDENT> money += money // 100 ; <NEWLINE> money = math . floor ( money ) <NEWLINE> year += 1 <NEWLINE> <NL> <DEDENT> print ( year ) <NEWLINE>
x = int ( input ( ) ) <NEWLINE> <NL> i = 0 <NEWLINE> c = 100 <NEWLINE> d = 100 <NEWLINE> <NL> while x >= d : <NEWLINE> <INDENT> c = int ( c // 100 ) <NEWLINE> d = d + c <NEWLINE> i = i + 1 <NEWLINE> <NL> <NL> <NL> <DEDENT> print ( i ) <NEWLINE>
N , M , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> tmp = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( Q ) ] <NEWLINE> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> ans = [ 0 ] <NEWLINE> def dfs ( A ) : <NEWLINE> <INDENT> if len ( A ) == N : <NEWLINE> <INDENT> tmp_ans = 0 <NEWLINE> for ele in tmp <NEWLINE> <INDENT> if ele [ 1 ] - ele [ 0 ] == ele [ 2 ] : <NEWLINE> <INDENT> tmp_ans += ele [ - 1 ] <NEWLINE> <DEDENT> <DEDENT> ans [ 0 ] = max ( tmp_ans , ans [ 0 ] ) <NEWLINE> <NL> return <NEWLINE> <NL> <DEDENT> A_min = A [ - 1 ] <NEWLINE> while ( 1 ) : <NEWLINE> <INDENT> if A_min > M : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> A . append ( A_min ) <NEWLINE> dfs ( A ) <NEWLINE> A . pop ( ) <NEWLINE> A_min += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( M ) : <NEWLINE> <INDENT> dfs ( [ i + 1 ] ) <NEWLINE> <NL> <DEDENT> print ( ans [ 0 ] ) <NEWLINE> <NL>
imporrt itertools <NEWLINE> N , M , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ ] <NEWLINE> b = [ ] <NEWLINE> c = [ ] <NEWLINE> d = [ ] <NEWLINE> for i in range ( Q ) : <NEWLINE> <INDENT> ta , tb , tc , td = map ( int , input ( ) . split ( ) ) <NEWLINE> a += [ ta ] <NEWLINE> b += [ tb ] <NEWLINE> c += [ tc ] <NEWLINE> d += [ td ] <NEWLINE> <DEDENT> maxs = 0 <NEWLINE> A = [ 0 for i in range ( N ) ] <NEWLINE> for i in itertools . combination_with_replacement ( A , N ) : <NEWLINE> <INDENT> s = 0 <NEWLINE> for k in range ( Q ) : <NEWLINE> <INDENT> if i [ b [ k ] - 1 ] - i [ a [ k ] - 1 ] == c [ k ] : <NEWLINE> <INDENT> s += d [ k ] <NEWLINE> <DEDENT> <DEDENT> maxs = max ( maxs , s ) <NEWLINE> <NL> <DEDENT> print ( maxs ) <NEWLINE>
import numpy as np <NEWLINE> <NL> n , m , q = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( range ( q ) ) <NEWLINE> b = list ( range ( q ) ) <NEWLINE> c = list ( range ( q ) ) <NEWLINE> d = list ( range ( q ) ) <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> a [ i ] , b [ i ] , c [ i ] , d [ i ] = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <DEDENT> A = np . sort ( np . random . randint ( 1 , m + 1 , n ) ) <NEWLINE> <NL> <NL> def calc_energy ( A ) : <NEWLINE> <INDENT> energy = 0. <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> if ( A [ b [ i ] - 1 ] - A [ a [ i ] - 1 ] ) == c [ i ] : <NEWLINE> <INDENT> energy += d [ i ] <NEWLINE> <DEDENT> <DEDENT> return energy <NEWLINE> <NL> <NL> <DEDENT> T = 20000 <NEWLINE> temperature_init = 10 <NEWLINE> for t in range ( T ) : <NEWLINE> <INDENT> A_prev = np . copy ( A ) <NEWLINE> energy_prev = calc_energy ( A_prev ) <NEWLINE> <NL> idx = np . random . randint ( 0 , n ) <NEWLINE> A [ idx ] = np . random . randint ( 1 , m + 1 ) <NEWLINE> energy = calc_energy ( A ) <NEWLINE> <NL> if np . random . rand ( ) < ( energy - energy_prev ) / temperature : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> A = np . copy ( A_prev ) <NEWLINE> <DEDENT> temperature = temperature_init * ( 1 / ( 1 + t ** 4 ) ) <NEWLINE> <NL> <DEDENT> print ( np . int ( calc_energy ( A ) ) ) <NEWLINE>
n , m , q = map ( int , input ( ) . split ( ) ) <NEWLINE> arr = [ list ( map ( int , input ( ) . split ( ) ) ) for x in range ( q ) ] <NEWLINE> ans = 0 <NEWLINE> <NL> for i1 in range ( 1 , m + 1 ) : <NEWLINE> <INDENT> for i2 in range ( i1 , m + 1 ) : <NEWLINE> <INDENT> for i3 in range ( i2 , m + 1 ) : <NEWLINE> <INDENT> for i4 in range ( i4 , m + 1 ) : <NEWLINE> <INDENT> for i5 in range ( i4 , m + 1 ) : <NEWLINE> <INDENT> for i6 in range ( i5 , m + 1 ) : <NEWLINE> <INDENT> for i7 in range ( 6 , m + 1 ) : <NEWLINE> <INDENT> for i8 in range ( i7 , m + 1 ) : <NEWLINE> <INDENT> for i9 in range ( i8 , m + 1 ) : <NEWLINE> <INDENT> for i10 in range ( i9 , m + 1 ) : <NEWLINE> <INDENT> tmp = 0 <NEWLINE> arrs = [ 0 , i1 , i2 , i3 , i4 , i5 , i6 , i7 , i8 , i9 , i10 ] <NEWLINE> for a , b , c , d in arr : <NEWLINE> <INDENT> if arrs [ b ] - arrs [ a ] == c : <NEWLINE> <INDENT> tmp += d <NEWLINE> <DEDENT> <DEDENT> ans = max ( ans , tmp ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
4 6 10 <NEWLINE> 2 4 1 86568 <NEWLINE> 1 4 0 90629 <NEWLINE> 2 3 0 90310 <NEWLINE> 3 4 1 29211 <NEWLINE> 3 4 3 78537 <NEWLINE> 3 4 2 8580 <NEWLINE> 1 2 1 96263 <NEWLINE> 1 4 2 2156 <NEWLINE> 1 2 0 94325 <NEWLINE> 1 4 3 94328 <NEWLINE>
N , M , Q = map ( int , input ( ) . aplist ( ) ) <NEWLINE> lists = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( Q ) ] <NEWLINE> ans = 0 <NEWLINE> <NL> def calc_score ( A ) : <NEWLINE> <INDENT> score = 0 <NEWLINE> for a , b , c , d in lists : <NEWLINE> <INDENT> if A [ b - 1 ] - A [ a - 1 ] == c : <NEWLINE> <INDENT> score += d <NEWLINE> <DEDENT> <DEDENT> return score <NEWLINE> <NL> <DEDENT> def dfs ( A ) : <NEWLINE> <INDENT> global ans <NEWLINE> if len ( A ) == N : <NEWLINE> <INDENT> score = calc_score ( A ) <NEWLINE> ans = max ( score , ans ) <NEWLINE> return <NEWLINE> <DEDENT> for n in range ( A [ - 1 ] , M + 1 ) : <NEWLINE> <INDENT> dfs ( A + [ n ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> dfs ( [ 1 ] ) <NEWLINE> print ( ans ) <NEWLINE>
def next_array ( array ) : <COMMENT> <NEWLINE> <INDENT> s = - 1 <NEWLINE> for x in array [ : : - 1 ] : <NEWLINE> <INDENT> if x < M : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s -= 1 <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> if s >= - N : <NEWLINE> <INDENT> array [ s ] += 1 <COMMENT> <NEWLINE> if s < - 1 : <NEWLINE> <INDENT> array [ s + 1 : ] = array [ s ] <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> return array <NEWLINE> <NL> <DEDENT> def score ( array , rules ) : <COMMENT> <NEWLINE> <INDENT> scr = 0 <NEWLINE> for rule in rules : <NEWLINE> <INDENT> if ( array [ rule [ 1 ] - 1 ] - array [ rule [ 0 ] - 1 ] == rule [ 2 ] ) : <NEWLINE> <INDENT> scr += rule [ 3 ] <NEWLINE> <NL> <DEDENT> <DEDENT> return scr <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> N , M , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> rules = [ ] <NEWLINE> for i in range ( Q ) : <NEWLINE> <INDENT> a , b , c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> rules . append ( [ a , b , c , d ] ) <NEWLINE> <NL> <DEDENT> array = [ 1 ] * N <NEWLINE> max_scr = 0 <NEWLINE> <NL> while True : <NEWLINE> <INDENT> max_scr = max ( max_scr , score ( array , rules ) ) <NEWLINE> if array [ 0 ] == M : <COMMENT> <NEWLINE> <INDENT> break <NEWLINE> array = next_array ( array ) <COMMENT> <NEWLINE> <NL> <DEDENT> <DEDENT> print ( max_scr ) <NEWLINE>
from itertools import combinations <NEWLINE> N , M , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> P = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( Q ) ] <NEWLINE> <NL> A = list ( itertools . combinations_with_replacement ( range ( 1 , M + 1 ) , N ) ) <NEWLINE> number = len ( A ) <NEWLINE> <NL> amount = 0 <NEWLINE> max_amount = 0 <NEWLINE> for i in range ( number ) : <COMMENT> <NEWLINE> <NL> <INDENT> for j in range ( Q ) : <COMMENT> <NEWLINE> <INDENT> bi = P [ j ] [ 1 ] <NEWLINE> ai = P [ j ] [ 0 ] <NEWLINE> if ( A [ i ] [ bi - 1 ] - A [ i ] [ ai - 1 ] == P [ j ] [ 2 ] ) : <NEWLINE> <INDENT> amount += P [ j ] [ 3 ] <NEWLINE> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> if ( amount >= max_amount ) : <NEWLINE> <INDENT> max_amount = amount <NEWLINE> <NL> <DEDENT> amount = 0 <NEWLINE> <NL> <DEDENT> print ( max_amount ) <NEWLINE>
import sys <NEWLINE> from math import ceil , floor , sqrt , sin , cos , pi <NEWLINE> from itertools import accumulate , permutations , combinations <NEWLINE> from fractions import gcd <COMMENT> <NEWLINE> from collections import deque , Counter <NEWLINE> from operator import itemgetter <NEWLINE> from heapq import heappop , heappush <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> def lcm ( x , y ) : return ( ( x * y ) // gcd ( x , y ) ) <COMMENT> <NEWLINE> <COMMENT> <NL> <NL> n , m , q = map ( int , input ( ) . split ( ) ) <NEWLINE> vec = [ ] <NEWLINE> a = [ ] <NEWLINE> b = [ ] <NEWLINE> c = [ ] <NEWLINE> d = [ ] <NEWLINE> for _ in range ( q ) : <NEWLINE> <INDENT> i , j , k , l = map ( int , input ( ) . split ( ) ) <NEWLINE> a . append ( i - 1 ) <NEWLINE> b . append ( j - 1 ) <NEWLINE> c . append ( k ) <NEWLINE> d . append ( l ) <NEWLINE> <DEDENT> it = a + b <NEWLINE> it = list ( set ( it ) ) <NEWLINE> for i in range ( 1 , m + 1 ) : <NEWLINE> <INDENT> for j in range ( len ( it ) ) : <NEWLINE> <INDENT> vec . append ( i ) <NEWLINE> <DEDENT> <DEDENT> na = [ ] <NEWLINE> nb = [ ] <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> for j in range ( len ( it ) ) : <NEWLINE> <INDENT> if a [ i ] == it [ j ] : <NEWLINE> <INDENT> na . append ( j ) <NEWLINE> <DEDENT> if b [ i ] == it [ j ] : <NEWLINE> <INDENT> nb . append ( j ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for x in combinations ( vec , len ( it ) ) : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> if x [ nb [ i ] ] - x [ na [ i ] ] == c [ i ] : <NEWLINE> <INDENT> cnt += d [ i ] <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> if ans < cnt : <NEWLINE> <INDENT> ans = cnt <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> import sys <NEWLINE> from math import ceil , floor , sqrt , sin , cos , pi <NEWLINE> from itertools import accumulate , permutations , combinations , combinations_with_replacement <NEWLINE> from fractions import gcd <COMMENT> <NEWLINE> from collections import deque , Counter <NEWLINE> from operator import itemgetter <NEWLINE> from heapq import heappop , heappush <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> def lcm ( x , y ) : return ( ( x * y ) // gcd ( x , y ) ) <COMMENT> <NEWLINE> <COMMENT> <NL> <NL> n , m , q = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ ] <NEWLINE> b = [ ] <NEWLINE> c = [ ] <NEWLINE> d = [ ] <NEWLINE> for _ in range ( q ) : <NEWLINE> <INDENT> i , j , k , l = map ( int , input ( ) . split ( ) ) <NEWLINE> a . append ( i - 1 ) <NEWLINE> b . append ( j - 1 ) <NEWLINE> c . append ( k ) <NEWLINE> d . append ( l ) <NEWLINE> <DEDENT> it = a + b <NEWLINE> it = list ( set ( it ) ) <NEWLINE> na = [ ] <NEWLINE> nb = [ ] <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> for j in range ( len ( it ) ) : <NEWLINE> <INDENT> if a [ i ] == it [ j ] : <NEWLINE> <INDENT> na . append ( j ) <NEWLINE> <DEDENT> if b [ i ] == it [ j ] : <NEWLINE> <INDENT> nb . append ( j ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for x in combinations_with_replacement ( range ( 1 , m + 1 ) , len ( it ) ) : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> if x [ nb [ i ] ] - x [ na [ i ] ] == c [ i ] : <NEWLINE> <INDENT> cnt += d [ i ] <NEWLINE> <DEDENT> <DEDENT> if ans < cnt : <NEWLINE> <INDENT> ans = cnt <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
vn , m , q = map ( int , input ( ) . split ( ) ) <NEWLINE> lis = [ ] <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> a , b , c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> lis . append ( ( a , b , c , d ) ) <NEWLINE> <NL> <DEDENT> from itertools import combinations_with_replacement <NEWLINE> <NL> co = list ( combinations_with_replacement ( range ( 1 , m + 1 ) , n ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> for status in co : <NEWLINE> <INDENT> tmp_score = 0 <NEWLINE> for a , b , c , d in lis : <NEWLINE> <INDENT> if status [ b - 1 ] - status [ a - 1 ] == c : <NEWLINE> <INDENT> tmp_score += d <NEWLINE> <DEDENT> <DEDENT> ans = max ( ans , tmp_score ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
N , M , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> vec = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( Q ) ] <NEWLINE> A = itertools . combinations_with_replacement ( range ( 1 , M + 1 ) , N ) <NEWLINE> ans = 0 <NEWLINE> <NL> for a in A : <NEWLINE> <INDENT> tmp = 0 <NEWLINE> for v in vec : <NEWLINE> <INDENT> if ( a [ v [ 1 ] - 1 ] - a [ v [ 0 ] - 1 ] ) == v [ 2 ] : <NEWLINE> <INDENT> tmp += v [ 3 ] <NEWLINE> <DEDENT> <DEDENT> if ans < tmp : <NEWLINE> <INDENT> ans = tmp <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> n , m , q = map ( int , input ( ) . split ( ) ) <NEWLINE> abcd = [ list ( map ( int , inpt ( ) . split ( ) ) ) for _ in range ( q ) ] <NEWLINE> sumlist = [ ] <NEWLINE> for A in math . combinations_with_replacement ( range ( 1 , m + 1 ) , n ) <NEWLINE> <INDENT> sum = 0 <NEWLINE> for a , b , c , d in abcd : <NEWLINE> <INDENT> if A [ b - 1 ] - A [ a - 1 ] == c : <NEWLINE> <INDENT> sum += d <NEWLINE> <DEDENT> sumlist . append ( sum ) <NEWLINE> <DEDENT> <DEDENT> print ( max ( sumlist ) ) <NEWLINE>
import itertools <NEWLINE> <NL> N , M , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> all = [ ] <NEWLINE> for i in range ( Q ) : <NEWLINE> <INDENT> all . append ( list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <DEDENT> x = [ i for i in range ( 1 , M + 1 ) ] <NEWLINE> maxdsum = 0 <NEWLINE> <NL> for A in itertools . combinations_with_replacement ( x , N ) : <NEWLINE> <INDENT> dsum = 0 <NEWLINE> for num in range ( Q ) : <NEWLINE> <INDENT> if A [ all [ num ] [ 1 ] - 1 ] - A [ all [ num ] [ 0 ] - 1 ] == all [ num ] [ 2 ] : <NEWLINE> <INDENT> dsum += all [ num ] [ 3 ] <NEWLINE> <DEDENT> <DEDENT> if maxdsum < dsum : <NEWLINE> <INDENT> maxdsum = dsum <NEWLINE> <DEDENT> <DEDENT> print ( maxdsum ) <NEWLINE>
N , M , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> S = [ 0 ] * Q ; t = 0 ; d = 0 ; A = [ 0 ] * 10 <NEWLINE> for i in range ( Q ) : <NEWLINE> <INDENT> a , b , c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> S [ i ] = [ a , b , c , d ] <NEWLINE> <COMMENT> <NL> <DEDENT> for i1 in range ( M ) : <NEWLINE> <INDENT> for i2 in range ( M ) : <NEWLINE> <INDENT> for i3 in range ( M ) : <NEWLINE> <INDENT> for i4 in range ( M ) : <NEWLINE> <INDENT> for i5 in range ( M ) : <NEWLINE> <INDENT> for i6 in range ( M ) : <NEWLINE> <INDENT> for i7 in range ( M ) : <NEWLINE> <INDENT> for i8 in range ( M ) : <NEWLINE> <INDENT> for i9 in range ( M ) : <NEWLINE> <INDENT> for i10 in range ( M ) : <NEWLINE> <INDENT> A = [ i1 , i2 , i3 , i4 , i5 , i6 , i7 , i8 , i9 , i10 ] <NEWLINE> for i in range ( Q ) : <NEWLINE> <INDENT> if A [ S [ i ] [ 1 ] ] - A [ S [ i ] [ 0 ] ] == S [ i ] [ 2 ] : <NEWLINE> <INDENT> d = d + S [ i ] [ 3 ] <NEWLINE> <DEDENT> <DEDENT> t = max ( t , d ) <NEWLINE> d = 0 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( t ) <NEWLINE>
<COMMENT> <NL> from itertools import product <NEWLINE> N , M , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> ls = [ ] <NEWLINE> for i in range ( Q ) : <NEWLINE> <INDENT> ls . append ( [ int ( j ) for j in input ( ) . split ( ) ] ) <NEWLINE> <DEDENT> arr = list ( range ( 1 , M + 1 ) ) <NEWLINE> ans = 0 <NEWLINE> for x in product ( arr , repeat = N ) : <NEWLINE> <INDENT> cur = 0 <NEWLINE> for y in ls : <NEWLINE> <INDENT> if x [ y [ 1 ] - 1 ] - x [ y [ 0 ] - 1 ] == y [ 2 ] : <NEWLINE> <INDENT> cur += y [ 3 ] <NEWLINE> <DEDENT> <DEDENT> ans = max ( ans , cur ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <COMMENT> <NL> from collections import deque <NEWLINE> N , M , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> ls = [ ] <NEWLINE> for i in range ( Q ) : <NEWLINE> <INDENT> ls . append ( [ int ( j ) for j in input ( ) . split ( ) ] ) <NEWLINE> <DEDENT> arr = list ( range ( 1 , M + 1 ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , M + 1 ) : <NEWLINE> <INDENT> st = deque ( [ ] ) <NEWLINE> st . append ( ( i , str ( i ) ) ) <NEWLINE> while st : <NEWLINE> <INDENT> p , l = st . pop ( ) <NEWLINE> if len ( l ) == N : <NEWLINE> <INDENT> cur = 0 <NEWLINE> for y in ls : <NEWLINE> <INDENT> if int ( l [ y [ 1 ] - 1 ] ) - int ( l [ y [ 0 ] - 1 ] ) == y [ 2 ] : <NEWLINE> <INDENT> cur += y [ 3 ] <NEWLINE> <DEDENT> <DEDENT> ans = max ( ans , cur ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for j in range ( p , M + 1 ) : <NEWLINE> <INDENT> st . append ( ( j , l + str ( j ) ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <COMMENT> <NL> from itertools import combinations <NEWLINE> N , M , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> ls = [ ] <NEWLINE> for i in range ( Q ) : <NEWLINE> <INDENT> ls . append ( [ int ( j ) for j in input ( ) . split ( ) ] ) <NEWLINE> <DEDENT> V = [ [ ] for i in range ( N + 1 ) ] <NEWLINE> for i in range ( 1 , M + 1 ) : <NEWLINE> <INDENT> V [ 1 ] . append ( [ i ] ) <NEWLINE> <NL> <DEDENT> for i in range ( 1 , N ) : <NEWLINE> <INDENT> for v in V [ i ] : <NEWLINE> <INDENT> b = v [ - 1 ] <NEWLINE> for x in range ( b , M + 1 ) : <NEWLINE> <INDENT> V [ i + 1 ] . append ( v + [ x ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for x in V [ - 1 ] : <NEWLINE> <INDENT> cur = 0 <NEWLINE> for z in ls : <NEWLINE> <INDENT> if x [ z [ 1 ] - 1 ] - x [ z [ 0 ] - 1 ] == z [ 2 ] : <NEWLINE> <INDENT> cur += z [ 3 ] <NEWLINE> <DEDENT> <DEDENT> ans = max ( ans , cur ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
from itertools import combinations_with_replacement <NEWLINE> N , M , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> ABCD = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( Q ) ] <NEWLINE> ans = 0 <NEWLINE> for t in combinations_with_replacement ( range ( 1 , M + 1 ) , N ) : <NEWLINE> <INDENT> an = 0 <NEWLINE> for a , b , c , d in ABCD : <NEWLINE> <INDENT> if t [ b - 1 ] - t [ a - 1 ] == c : <NEWLINE> <INDENT> an += d <NEWLINE> <DEDENT> <DEDENT> if ans < an : <NEWLINE> <INDENT> ans = an <NEWLINE> <DEDENT> <DEDENT> print ( an <NEWLINE>
<COMMENT> <NL> <NL> import sys <NEWLINE> sys . stdin = open ( <STRING> ) <NEWLINE> import itertools <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> def dfs ( A ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> global ans <NEWLINE> if len ( A ) == n + 1 : <NEWLINE> <COMMENT> <NL> <INDENT> now = 0 <NEWLINE> for j in range ( q ) : <NEWLINE> <INDENT> if A [ b [ j ] ] - A [ a [ j ] ] == c [ j ] : <NEWLINE> <INDENT> now += d [ j ] <NEWLINE> <DEDENT> <DEDENT> ans = max ( ans , now ) <NEWLINE> return <NEWLINE> <DEDENT> else : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <INDENT> A = A + [ A [ - 1 ] ] <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> while A [ - 1 ] <= m : <NEWLINE> <COMMENT> <NL> <INDENT> dfs ( A ) <NEWLINE> A [ - 1 ] += 1 <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> def dfs2 ( i ) : <NEWLINE> <INDENT> global ans <NEWLINE> for j in range ( num [ i - 1 ] , m ) : <NEWLINE> <INDENT> num [ i ] = j <NEWLINE> if i == n : <NEWLINE> <INDENT> print ( num ) <NEWLINE> now = 0 <NEWLINE> for k in range ( q ) : <NEWLINE> <INDENT> if num [ b [ k ] ] - num [ a [ k ] ] == c [ k ] : <NEWLINE> <INDENT> now += d [ k ] <NEWLINE> <DEDENT> <DEDENT> ans = max ( ans , now ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dfs2 ( i + 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> def solve_combinations_with_replacement ( n , m ) : <NEWLINE> <INDENT> def update_ans ( A ) : <NEWLINE> <INDENT> global ans <NEWLINE> now = 0 <NEWLINE> for j in range ( q ) : <NEWLINE> <INDENT> if A [ b [ j ] - 1 ] - A [ a [ j ] - 1 ] == c [ j ] : <NEWLINE> <INDENT> now += d [ j ] <NEWLINE> <DEDENT> <DEDENT> ans = max ( ans , now ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> global ans <NEWLINE> it = [ i for i in range ( m ) ] <NEWLINE> for A in itertools . combinations_with_replacement ( it , n ) : <NEWLINE> <INDENT> update_ans ( A ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> n , m , q = map ( int , input ( ) . split ( ) ) <NEWLINE> a , b , c , d = [ ] , [ ] , [ ] , [ ] <NEWLINE> ans = 0 <NEWLINE> <NL> for i in range ( q ) : <NEWLINE> <INDENT> ai , bi , ci , di = map ( int , input ( ) . split ( ) ) <NEWLINE> a . append ( ai ) <NEWLINE> b . append ( bi ) <NEWLINE> c . append ( ci ) <NEWLINE> d . append ( di ) <NEWLINE> <NL> <DEDENT> dfs ( [ 1 ] ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <NL> print ( ans ) <NEWLINE>
N , M , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> ABCD = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( Q ) ] <NEWLINE> score = 0 <NEWLINE> for i in range ( 1 , M + 1 ) : <NEWLINE> <INDENT> dfs ( [ i ] ) <NEWLINE> <DEDENT> print ( score ) <NEWLINE> <NL> <NL> def dfs ( l ) : <NEWLINE> <COMMENT> <NL> <INDENT> if judge_end ( l , N ) : <NEWLINE> <INDENT> global score <NEWLINE> <NL> tmp_score = calc_score ( ABCD , l ) <NEWLINE> score = max ( tmp_score , score ) <NEWLINE> return <NEWLINE> <DEDENT> else : <NEWLINE> <COMMENT> <NL> <INDENT> nexts = listup_next ( l [ - 1 ] , M ) <NEWLINE> for x in nexts : <NEWLINE> <INDENT> dfs ( num_list + [ x ] ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> def judge_end ( l , N ) : <NEWLINE> <INDENT> return len ( l ) == N <NEWLINE> <NL> <NL> <DEDENT> def calc_score ( ABCD , l ) : <NEWLINE> <INDENT> s = 0 <NEWLINE> for a , b , c , d in ABCD : <NEWLINE> <INDENT> if l [ b - 1 ] - l [ a - 1 ] == c : <NEWLINE> <INDENT> s += d <NEWLINE> <DEDENT> <DEDENT> return s <NEWLINE> <NL> <NL> <DEDENT> def listup_next ( m , M ) : <NEWLINE> <INDENT> return range ( m , M + 1 ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> import math <NEWLINE> import scipy <NEWLINE> import itertools <NEWLINE> <NL> def score ( arr ) : <NEWLINE> <INDENT> hoge = 0 <NEWLINE> for ai , bi , ci , di in zip ( a , b , c , d ) : <NEWLINE> <INDENT> if arr [ bi - 1 ] - arr [ ai - 1 ] == ci : <NEWLINE> <INDENT> hoge += di <NEWLINE> <DEDENT> <DEDENT> return hoge <NEWLINE> <NL> <DEDENT> def dfs ( arr ) : <NEWLINE> <INDENT> if len ( arr ) == n : <NEWLINE> <INDENT> return score ( arr ) <NEWLINE> <DEDENT> last = arr [ - 1 ] if len ( arr ) > 0 else 0 <NEWLINE> res = 0 <NEWLINE> for i in range ( last , m + 1 ) : <NEWLINE> <INDENT> a . append ( i ) <NEWLINE> res = max ( res , dfs ( arr ) ) <NEWLINE> a . pop ( ) <NEWLINE> <DEDENT> return res <NEWLINE> <NL> <DEDENT> def solve ( ) : <NEWLINE> <INDENT> global a , b , c , d , n , m , q <NEWLINE> n , m , q = map ( int , input ( ) . split ( ) ) <NEWLINE> a , b , c , d = [ 0 ] * q , [ 0 ] * q , [ 0 ] * q , [ 0 ] * q <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> a [ i ] , b [ i ] , c [ i ] , d [ i ] = map ( int , input ( ) . split ( ) ) <NEWLINE> <DEDENT> print ( dfs ( [ ] ) ) <NEWLINE> return 0 <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> solve ( ) <NEWLINE> <DEDENT>
n , m , q = map ( int , input ( ) . split ( ) ) <NEWLINE> abcd = [ ] <NEWLINE> for _ in range ( q ) : <NEWLINE> <INDENT> a , b , c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> abcd . append ( ( a , b , c , d ) ) <NEWLINE> <DEDENT> ans = 0 <NEWLINE> p = [ ] <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> def dfs ( x ) : <NEWLINE> <INDENT> if len ( x ) == n : <NEWLINE> <INDENT> p . append ( x ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( m - x [ - 1 ] + 1 ) : <NEWLINE> <INDENT> dfs ( x + [ x [ - 1 ] + i ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> dfs ( [ 1 ] ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> for x in p : <NEWLINE> <INDENT> r = 0 <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> if x [ abcd [ i ] [ 1 ] - 1 ] - x [ abcd [ i ] [ 0 ] - 1 ] == abcd [ i ] [ 2 ] : <NEWLINE> <INDENT> r += abcd [ i ] [ 3 ] <NEWLINE> <DEDENT> <DEDENT> ans = max ( ans , r ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
N , M , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ 0 ] * Q <NEWLINE> b = [ 0 ] * Q <NEWLINE> c = [ 0 ] * Q <NEWLINE> d = [ 0 ] * Q <NEWLINE> for i in range ( Q ) : <NEWLINE> <INDENT> a [ i ] , b [ i ] , c [ i ] , d [ i ] = map ( int , input ( ) . split ( ) ) <NEWLINE> <DEDENT> import itertools <NEWLINE> for A in itertools . combinations_with_replacement ( range ( 1 , M + 1 ) , N ) : <NEWLINE> <INDENT> ans = 0 <NEWLINE> if i in range ( Q ) : <NEWLINE> <INDENT> s = 0 <NEWLINE> if A [ b [ i ] ] - A [ a [ i ] ] == c [ i ] : <NEWLINE> <INDENT> s += d [ i ] <NEWLINE> <INDENT> ans = max ( ans , s ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N , M , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> <COMMENT> <NL> arr = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( Q ) ] <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> <STRING> <NEWLINE> for i1 in range ( 1 , M + 1 ) : <NEWLINE> <INDENT> for i2 in range ( i1 , M + 1 ) : <NEWLINE> <INDENT> for i3 in range ( i2 , M + 1 ) : <NEWLINE> <INDENT> for i4 in range ( i3 , M + 1 ) : <NEWLINE> <INDENT> for i5 in range ( i4 , M + 1 ) : <NEWLINE> <INDENT> for i6 in range ( i5 , M + 1 ) : <NEWLINE> <INDENT> for i7 in range ( i6 , M + 1 ) : <NEWLINE> <INDENT> for i8 in range ( i7 , M + 1 ) : <NEWLINE> <INDENT> for i9 in range ( i8 , M + 1 ) : <NEWLINE> <INDENT> for i10 in range ( i9 , M + 1 ) : <NEWLINE> <INDENT> tmp = 0 <NEWLINE> <COMMENT> <NL> arrs = { 0 , i1 , i2 , i3 , i4 , i5 , i6 , i7 , i8 , i9 , i10 } <NEWLINE> for a , b , c , d in arr : <NEWLINE> <INDENT> if arrs [ b ] - arrs [ a ] == c : <NEWLINE> <INDENT> tmp += b <NEWLINE> <DEDENT> <DEDENT> ans = max ( ans , tmp ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<NL> import itertools <NEWLINE> <NL> n , m , q = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <NL> n , m , q = map ( int , input ( ) . split ( ) ) <NEWLINE> query = [ ] <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> query . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> <DEDENT> choices = list ( itertools . combinations_with_replacement ( [ i for i in range ( 1 , m + 1 ) ] , n ) ) <NEWLINE> ans = - 1 <NEWLINE> for choice in choices : <NEWLINE> <INDENT> score = 0 <NEWLINE> for q in query : <NEWLINE> <INDENT> if choice [ q [ 1 ] - 1 ] - choice [ q [ 0 ] - 1 ] == q [ 2 ] : <NEWLINE> <INDENT> score += q [ 3 ] <NEWLINE> <DEDENT> <DEDENT> ans = max ( ans , score ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> n , m , q = map ( int , input ( ) . split ( ) ) <NEWLINE> alis , blis , clis , dlis = [ ] , [ ] , [ ] , [ ] <NEWLINE> for _ in range ( q ) : <NEWLINE> <INDENT> a , b , c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> alis . append ( a ) <NEWLINE> blis . append ( b ) <NEWLINE> clis . append ( c ) <NEWLINE> dlis . append ( d ) <NEWLINE> <DEDENT> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> Alist = [ ] <NEWLINE> def dfs ( A ) : <NEWLINE> <INDENT> if len ( A ) == ( n + 1 ) : <NEWLINE> <INDENT> Alist . append ( A ) <NEWLINE> return <NEWLINE> <DEDENT> for i in range ( A [ - 1 ] , m + 1 ) : <NEWLINE> <INDENT> A . append ( i ) <NEWLINE> dfs ( A ) <NEWLINE> <NL> <DEDENT> <DEDENT> dfs ( [ 1 ] ) <NEWLINE> <NL> ans = 0 <NEWLINE> for A in Alist : <NEWLINE> <INDENT> score = 0 <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> if A [ blis [ i ] ] - A [ alis [ i ] ] == clis [ i ] : <NEWLINE> <INDENT> score += dlis [ i ] <NEWLINE> <DEDENT> <DEDENT> ans = max ( ans , score ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
import itertools <NEWLINE> <NL> n , m , q = map ( int , input ( ) . split ( ) ) <NEWLINE> abcd = [ tuple ( map ( int , input ( ) . split ( ) ) ) for _ in range ( Q ) ] <NEWLINE> ans = 0 <NEWLINE> for com in itertools . combinations_with_replacement ( range ( 1 , M + 1 ) , N ) : <NEWLINE> <INDENT> score = sum ( [ d for a , b , c , d in abcd if com [ b - 1 ] - com [ a - 1 ] == c ] ) <NEWLINE> if ans < score : <NEWLINE> <INDENT> ans = score <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n , m , q = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ 0 ] * q <NEWLINE> b = [ 0 ] * q <NEWLINE> c = [ 0 ] * q <NEWLINE> d = [ 0 ] * q <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> a [ i ] , b [ i ] , c [ i ] , d [ i ] = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <DEDENT> s = [ 1 ] * n <NEWLINE> <COMMENT> <NL> num = n - 1 <NEWLINE> ans1 = [ 0 ] * 100000000 <NEWLINE> ans = 0 <NEWLINE> t = 0 <NEWLINE> <NL> while ( s [ 0 ] != m ) : <NEWLINE> <NL> <INDENT> for i in range ( q ) : <NEWLINE> <INDENT> if s [ b [ i ] - 1 ] - s [ a [ i ] - 1 ] == c [ i ] : <NEWLINE> <INDENT> ans += d [ i ] <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> ans1 [ t ] = ans <NEWLINE> t += 1 <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> if s [ num ] < m : <NEWLINE> <INDENT> s [ num ] += 1 <NEWLINE> <DEDENT> elif num > 0 : <NEWLINE> <INDENT> num -= 1 <NEWLINE> temp = s [ num ] + 1 <NEWLINE> if temp < m : <NEWLINE> <INDENT> for i in range ( num , n ) : <NEWLINE> <INDENT> s [ i ] = temp <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> while ( s [ num ] == m ) : <NEWLINE> <INDENT> num -= 1 <NEWLINE> <DEDENT> temp = s [ num ] + 1 <NEWLINE> for i in range ( num , n ) : <NEWLINE> <INDENT> s [ i ] = temp <NEWLINE> <NL> <DEDENT> <DEDENT> num = n - 1 <NEWLINE> <NL> <NL> <NL> <NL> <NL> <NL> <DEDENT> <DEDENT> print ( max ( ans1 ) ) <NEWLINE>
mport itertools <NEWLINE> def main ( ) : <NEWLINE> <INDENT> N , M , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> abcd = [ ] <NEWLINE> for _ in range ( Q ) : <NEWLINE> <INDENT> a , b , c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> abcd . append ( ( a - 1 , b - 1 , c , d ) ) <NEWLINE> <DEDENT> score = 0 <NEWLINE> for ones in list ( itertools . combinations ( [ i for i in range ( N + M - 1 ) ] , M - 1 ) ) : <NEWLINE> <INDENT> temp = [ 0 ] * ( N + M - 1 ) <NEWLINE> for idx in ones : <NEWLINE> <INDENT> temp [ idx ] = 1 <NEWLINE> <DEDENT> A = [ 0 ] * N <NEWLINE> idx = 0 <NEWLINE> sum_ = 0 <NEWLINE> for i in temp : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> A [ idx ] = sum_ + 1 <NEWLINE> idx += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> sum_ += 1 <NEWLINE> <DEDENT> <DEDENT> score_temp = get_score ( A , abcd ) <NEWLINE> if score_temp > score : <NEWLINE> <INDENT> score = score_temp <NEWLINE> <DEDENT> <DEDENT> print ( score ) <NEWLINE> <NL> <NL> <DEDENT> def get_score ( A , abcd ) : <NEWLINE> <INDENT> score = 0 <NEWLINE> for a , b , c , d in abcd : <NEWLINE> <INDENT> if A [ b ] - A [ a ] == c : <NEWLINE> <INDENT> score += d <NEWLINE> <DEDENT> <DEDENT> return score <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> readline = sys . stdin . readline <NEWLINE> <NL> def score ( A ) : <NEWLINE> <INDENT> t = 0 <NEWLINE> for ai , bi , ci , di in zip ( a , b , c , d ) : <NEWLINE> <INDENT> if A [ bi ] - A [ ai ] == ci : <NEWLINE> <INDENT> t += di <NEWLINE> <DEDENT> <DEDENT> return t <NEWLINE> <NL> <DEDENT> def dfs ( A ) : <NEWLINE> <INDENT> if len ( A ) == n : <NEWLINE> <INDENT> return score ( A ) <NEWLINE> <DEDENT> ans = 0 <NEWLINE> prev_last = A [ - 1 ] if len ( A ) > 0 else 0 <NEWLINE> for v in range ( prev_last , m ) : <NEWLINE> <INDENT> A . append ( v ) <NEWLINE> ans = max ( ans , dfs ( A ) ) <NEWLINE> A . pop ( ) <NEWLINE> <DEDENT> return ans <NEWLINE> <NL> <DEDENT> n , m , q = map ( int , readline ( ) . split ( ) ) <NEWLINE> A , B , C , D = [ 0 ] * q , [ 0 ] * q , [ 0 ] * q , [ 0 ] * q <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> a , b , C [ i ] , D [ i ] = map ( int , readline ( ) . split ( ) ) <NEWLINE> A [ i ] = a - 1 <NEWLINE> B [ i ] = b - 1 <NEWLINE> <NL> <DEDENT> print ( dfs ( [ ] ) ) <NEWLINE>
cin = open ( 0 ) . read ( ) . strip ( ) . split ( <STRING> ) <NEWLINE> n , m , q = map ( int , cin [ 0 ] . split ( <STRING> ) ) <NEWLINE> abcd = [ tuple ( map ( int , a . split ( <STRING> ) ) ) for a in cin [ 1 : ] ] <NEWLINE> <NL> ret = 0 <NEWLINE> for case in itertools . combinations_with_replacement ( list ( range ( 1 , m + 1 ) ) , n ) : <NEWLINE> <INDENT> tmp = 0 <NEWLINE> for c in abcd : <NEWLINE> <INDENT> if case [ c [ 1 ] - 1 ] - case [ c [ 0 ] - 1 ] == c [ 2 ] : <NEWLINE> <INDENT> tmp += c [ 3 ] <NEWLINE> <DEDENT> <DEDENT> ret = max ( ret , tmp ) <NEWLINE> <DEDENT> print ( ret ) <NEWLINE>
import math <NEWLINE> import itertools <NEWLINE> <NL> N , M , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ 0 ] * Q <NEWLINE> b = [ 0 ] * Q <NEWLINE> c = [ 0 ] * Q <NEWLINE> d = [ 0 ] * Q <NEWLINE> for i in range ( Q ) : <NEWLINE> <INDENT> a [ i ] , b [ i ] , c [ i ] , d [ i ] = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <NL> <NL> <NL> <NL> <DEDENT> def combinations_count ( n , r ) : <NEWLINE> <INDENT> return math . factorial ( n ) // ( math . factorial ( n - r ) * math . factorial ( r ) ) <NEWLINE> <NL> <NL> <NL> <DEDENT> All = [ 0 ] * M <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> All [ i ] = i + 1 <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> <NL> <COMMENT> <NL> <DEDENT> ans = 0 <NEWLINE> for A in itertools . product ( All , N ) : <NEWLINE> <COMMENT> <NL> <INDENT> print ( A ) <NEWLINE> wa = 0 <NEWLINE> for i in range ( Q ) : <NEWLINE> <INDENT> print ( wa ) <NEWLINE> kari = A [ b [ i ] - 1 ] - A [ a [ i ] - 1 ] <NEWLINE> if kari == c [ i ] : <NEWLINE> <INDENT> wa = wa + d [ i ] <NEWLINE> <DEDENT> <DEDENT> if ans < wa : <NEWLINE> <INDENT> ans = wa <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL>
a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = [ ] <NEWLINE> ans = 0 <NEWLINE> c = [ ] <NEWLINE> for _ in range ( a [ 2 ] ) : <NEWLINE> <INDENT> b . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> <DEDENT> for i in range ( 1 , a [ 1 ] + 1 ) : <NEWLINE> <INDENT> for j in range ( i , a [ 1 ] + 1 ) : <NEWLINE> <INDENT> for k in range ( j , a [ 1 ] + 1 ) : <NEWLINE> <INDENT> c = [ i , j , k ] <NEWLINE> for l in range ( a [ 2 ] ) : <NEWLINE> <INDENT> if c [ b [ l ] [ 1 ] - 1 ] - c [ b [ l ] [ 0 ] - 1 ] == b [ l ] [ 2 ] : <NEWLINE> <INDENT> ans += b [ l ] [ 3 ] <NEWLINE> <DEDENT> <DEDENT> d . append ( ans ) <NEWLINE> ans = 0 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( max ( d ) ) <NEWLINE>
n , m , q = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ 0 ] * q <NEWLINE> b = [ 0 ] * q <NEWLINE> c = [ 0 ] * q <NEWLINE> d = [ 0 ] * q <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> a [ i ] , b [ i ] , c [ i ] , d [ i ] = map ( int , input ( ) . split ( ) ) <NEWLINE> <DEDENT> A_list = [ ] <NEWLINE> for p in itertools . combinations_with_replacement ( range ( 1 , m + 1 ) , n ) : <NEWLINE> <INDENT> A_list . append ( p ) <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> ans = 0 <NEWLINE> for v in A_list : <NEWLINE> <INDENT> cur_score = 0 <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> if v [ b [ i ] - 1 ] - v [ a [ i ] - 1 ] == c [ i ] : <NEWLINE> <INDENT> cur_score += d [ i ] <NEWLINE> <DEDENT> <DEDENT> ans = max ( ans , cur_score ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import itertools <NEWLINE> N , M , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> L = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( Q ) ] <NEWLINE> data = list ( range ( 1 , M + 1 ) ) <NEWLINE> A = list ( itertools . combinations_with_replacement ( data , N ) ) <NEWLINE> max_score = 0 <NEWLINE> <NL> for Ai in A : <NEWLINE> <INDENT> x = 0 <NEWLINE> for a , b , c , d in L : <NEWLINE> <INDENT> if Ai [ b ] - Ai [ a ] == c : <NEWLINE> <INDENT> x += d <NEWLINE> <DEDENT> <DEDENT> max_score = max ( max_score , x ) <NEWLINE> <NL> <DEDENT> print ( max_score ) <NEWLINE>
import itertools as it <NEWLINE> <NL> n , m , q = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> ar = [ [ 0 ] * 4 ] * q <NEWLINE> <NL> for i in range ( q ) : <NEWLINE> <INDENT> ar [ i ] = [ int ( s ) for s in input ( ) . split ( ) ] <NEWLINE> <NL> <DEDENT> A = it . combinations_with_replacement ( list ( range ( 1 , m + 1 ) ) , n ) <NEWLINE> mx = 0 <NEWLINE> <NL> for cnd in A : <NEWLINE> <INDENT> mx_tmp = 0 <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> if ( A [ ar [ i ] [ 1 ] - 1 ] - A [ ar [ i ] [ 0 ] - 1 ] == ar [ i ] [ 2 ] ) : <NEWLINE> <INDENT> mx_tmp += ar [ i ] [ 3 ] <NEWLINE> <DEDENT> <DEDENT> mx = max ( mx , mx_tmp ) <NEWLINE> <NL> <DEDENT> print ( mx ) <NEWLINE>
n , m , q = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ 0 for i in range ( q ) ] <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> a [ i ] = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <DEDENT> for i in range ( 1 , m + 1 ) : <NEWLINE> <INDENT> for j in range ( i , m + 1 ) : <NEWLINE> <INDENT> for k in range ( j , m + 1 ) : <NEWLINE> <INDENT> for s in range ( k , m + 1 ) : <NEWLINE> <INDENT> for p in range ( s , m + 1 ) : <NEWLINE> <INDENT> for l in range ( p , m + 1 ) : <NEWLINE> <INDENT> for e in range ( l , m + 1 ) : <NEWLINE> <INDENT> for u in range ( e , m + 1 ) : <NEWLINE> <INDENT> for v in range ( u , m + 1 ) : <NEWLINE> <INDENT> b = [ 1 , f , c , k , s , p , l , e , u , v ] <NEWLINE> nn = 0 <NEWLINE> for h in range ( q ) : <NEWLINE> <INDENT> if b [ a [ h ] [ 1 ] - 1 ] - b [ a [ h ] [ 0 ] - 1 ] == a [ h ] [ 2 ] : <NEWLINE> <INDENT> nn += a [ h ] [ 3 ] <NEWLINE> <DEDENT> <DEDENT> ans = max ( ans , nn ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<NL> import sys <NEWLINE> import itertools <NEWLINE> import numpy as np <NEWLINE> <NL> read = sys . stdin . buffer . read <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> readlines = sys . stdin . buffer . readlines <NEWLINE> <NL> N , M , Q = map ( int , readline ( ) . split ( ) ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> A = np . array ( list ( itertools . combinations_with_replacement ( range ( 1 , M + 1 ) , N ) ) ) <NEWLINE> <NL> n = len ( A ) <COMMENT> <NEWLINE> score = np . zeros ( n ) [ 0 , 0 , ... , 0 ] <COMMENT> <NEWLINE> <NL> m = map ( int , read ( ) . split ( ) ) <NEWLINE> for a , b , c , d in zip ( m , m , m , m ) : <NEWLINE> <INDENT> cond = A [ : , b - 1 ] - A [ : , a - 1 ] == c <NEWLINE> score += d * cond <NEWLINE> <NL> <DEDENT> print ( score . max ( ) ) <NEWLINE>
import itertools <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> N , M , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> Q = [ ] <NEWLINE> final_score = 0 <NEWLINE> for i in range ( Q ) : <NEWLINE> <INDENT> Q . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <DEDENT> for A in itertools . combinations_with_replacement ( range ( 1 , M + 1 ) , N ) : <NEWLINE> <INDENT> score = 0 <NEWLINE> for q in Q : <NEWLINE> <INDENT> if A [ q [ 1 ] - 1 ] - A [ q [ 0 ] - 1 ] == q [ 2 ] : <NEWLINE> <INDENT> score += q [ 3 ] <NEWLINE> <DEDENT> final_score = max ( [ final_score , score ] ) <NEWLINE> <DEDENT> <DEDENT> print ( final_score ) <NEWLINE> <DEDENT> main ( ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 8 ) <NEWLINE> def ii ( ) : return int ( sys . stdin . readline ( ) ) <NEWLINE> def mi ( ) : return map ( int , sys . stdin . readline ( ) . split ( ) ) <NEWLINE> def li ( ) : return list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) <NEWLINE> def li2 ( N ) : return [ list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) for i in range ( N ) ] <NEWLINE> def dp2 ( ini , i , j ) : return [ [ ini ] * i for i2 in range ( j ) ] <NEWLINE> def dp3 ( ini , i , j , k ) : return [ [ [ ini ] * i for i2 in range ( j ) ] for i3 in range ( k ) ] <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> N , M , Q = mi ( ) <NEWLINE> abcd = li2 ( Q ) <NEWLINE> <NL> <STRING> <NEWLINE> <NL> def dfs ( num , length ) : <NEWLINE> <INDENT> if length == N : <NEWLINE> <INDENT> l . append ( num ) <NEWLINE> return <NEWLINE> <DEDENT> last = int ( num [ - 1 ] ) <NEWLINE> for i in range ( last , M ) : <NEWLINE> <INDENT> dfs ( num + str ( i ) , length + 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> dfs ( <STRING> , 1 ) <NEWLINE> ans = 0 <NEWLINE> for num in l : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> num = list ( map ( int , list ( num ) ) ) <NEWLINE> for i in range ( Q ) : <NEWLINE> <INDENT> if num [ abcd [ i ] [ 1 ] - 1 ] - num [ abcd [ i ] [ 0 ] - 1 ] == abcd [ i ] [ 2 ] : <NEWLINE> <INDENT> cnt += abcd [ i ] [ 3 ] <NEWLINE> <DEDENT> <DEDENT> ans = max ( ans , cnt ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
import numpy as np <NEWLINE> import math <NEWLINE> n , m , q = map ( int , input ( ) . split ( ) ) <NEWLINE> max = 0 <NEWLINE> j = [ ] <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> aa , b , c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> j . append ( [ aa , b , c , d ] ) <NEWLINE> <NL> <DEDENT> a = [ 0 for k in range ( 11 ) ] <NEWLINE> for i1 in range ( 1 , 11 ) : <NEWLINE> <INDENT> a [ 1 ] = i1 <NEWLINE> for i2 in range ( i1 , 11 ) : <NEWLINE> <INDENT> a [ 2 ] = i2 <NEWLINE> for i3 in range ( i2 , 11 ) : <NEWLINE> <INDENT> a [ 3 ] = i3 <NEWLINE> for i4 in range ( i3 , 11 ) : <NEWLINE> <INDENT> a [ 4 ] = i4 <NEWLINE> for i5 in range ( i4 , 11 ) : <NEWLINE> <INDENT> a [ 5 ] = i5 <NEWLINE> for i6 in range ( i5 , 11 ) : <NEWLINE> <INDENT> a [ 6 ] = i6 <NEWLINE> for i7 in range ( i6 , 11 ) : <NEWLINE> <INDENT> a [ 7 ] = i7 <NEWLINE> <INDENT> for i8 in range ( i7 , 11 ) : <NEWLINE> a [ 8 ] = i8 <NEWLINE> <INDENT> for i9 in range ( i8 , 11 ) : <NEWLINE> a [ 9 ] = i9 <NEWLINE> <INDENT> for i10 in range ( i9 , 11 ) : <NEWLINE> a [ 10 ] = i10 <NEWLINE> s = 0 <NEWLINE> for i in j : <NEWLINE> <INDENT> if a [ i [ 1 ] ] - a [ i [ 0 ] ] = i [ 2 ] : <NEWLINE> <INDENT> s += i [ 3 ] <NEWLINE> <DEDENT> <DEDENT> if max < s : <NEWLINE> <INDENT> max = s <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( max ) <NEWLINE> <NL>
import itertools <NEWLINE> N , M , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> L = [ ] <NEWLINE> for _ in range ( Q ) : <NEWLINE> <INDENT> L . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> <DEDENT> A = itertools . combinations_with_replacement ( [ i for i in range ( 1 , M + 1 ) ] , N ) <NEWLINE> count = [ ] <NEWLINE> for a in A : <NEWLINE> <INDENT> temp = 0 <NEWLINE> for l in l : <NEWLINE> <INDENT> if a [ l [ 1 ] - 1 ] - a [ l [ 0 ] - 1 ] == l [ 2 ] : <NEWLINE> <INDENT> temp += l [ 3 ] <NEWLINE> <DEDENT> <DEDENT> count . append ( temp ) <NEWLINE> <DEDENT> print ( max ( count ) ) <NEWLINE>
import numpy as np <NEWLINE> import itertools <NEWLINE> <NL> <NL> N , M , Q = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> <NL> vals = [ ] <NEWLINE> for i in range ( Q ) : <NEWLINE> <INDENT> vals . append ( [ list ( map ( int , input ( ) . split ( <STRING> ) ) ) ] ) <NEWLINE> <NL> <DEDENT> maxv = 0 <NEWLINE> cand = list ( itertools . combinations_with_replacement ( range ( 1 , M + 1 ) , N ) ) <NEWLINE> for c in cand : <NEWLINE> <INDENT> sumv = 0 <NEWLINE> for v in vals : <NEWLINE> <INDENT> if ( c [ v [ 1 ] - 1 ] - c [ v [ 0 ] - 1 ] ) == v [ 2 ] : <NEWLINE> <INDENT> sumv += v [ 3 ] <NEWLINE> <DEDENT> <DEDENT> if maxv < sumv : <NEWLINE> <INDENT> maxv = sumv <NEWLINE> <DEDENT> <DEDENT> print ( maxv ) <NEWLINE>
import itertools <NEWLINE> <NL> def check ( lis , a ) : <NEWLINE> <INDENT> return sum ( ( i [ 3 ] for i in a if lis [ i [ 1 ] - 1 ] - lis [ i [ 0 ] - 1 ] == i [ 2 ] ) ) <NEWLINE> <NL> <DEDENT> n , m , q = map ( int , input ( ) . split ( ) ) <NEWLINE> a = ( ( int ( i ) for i in input ( ) . split ( <STRING> ) ) for j in range ( q ) ) <NEWLINE> ans = 0 <NEWLINE> for i in itertools . combinations_with_replacement ( range ( m ) , n ) : <NEWLINE> <INDENT> ans = max ( ans , check ( i , a ) ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
N , M , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ 0 for _ in range ( Q ) ] <NEWLINE> b = [ 0 for _ in range ( Q ) ] <NEWLINE> c = [ 0 for _ in range ( Q ) ] <NEWLINE> d = [ 0 for _ in range ( Q ) ] <NEWLINE> for k in range ( Q ) : <NEWLINE> <INDENT> a [ k ] , b [ k ] , c [ k ] , d [ k ] = map ( int , input ( ) . split ( ) ) <NEWLINE> <DEDENT> A = [ 1 for _ in range ( N ) ] <NEWLINE> <NL> def point ( A ) : <NEWLINE> <INDENT> p = 0 <NEWLINE> for ai , bi , ci , di in zip ( a , b , c , d ) : <NEWLINE> <INDENT> if A [ bi - 1 ] - A [ ai - 1 ] == ci : <NEWLINE> <INDENT> p += di <NEWLINE> <DEDENT> <DEDENT> return p <NEWLINE> <NL> <DEDENT> def next ( A ) : <NEWLINE> <INDENT> k = 1 <NEWLINE> while k < N + 1 : <NEWLINE> <INDENT> if A [ - k ] < M : <NEWLINE> <INDENT> A [ - k ] += 1 <NEWLINE> return A <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for j in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> A [ - j ] = A [ - k - 1 ] + 1 <NEWLINE> <DEDENT> k += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> ans = max ( ans , point ( [ M for _ in range ( N ) ] ) ) <NEWLINE> while A [ 0 ] < M : <NEWLINE> <INDENT> ans = max ( ans , point ( A ) ) <NEWLINE> A = next ( A ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
N , M , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> A = [ ] <NEWLINE> B = [ ] <NEWLINE> C = [ ] <NEWLINE> D = [ ] <NEWLINE> <NL> for i in range ( Q ) : <NEWLINE> <INDENT> a , b , c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> A . append ( a ) <NEWLINE> B . append ( b ) <NEWLINE> C . append ( c ) <NEWLINE> D . append ( d ) <NEWLINE> <NL> <NL> <DEDENT> def dfs ( nums ) : <NEWLINE> <NL> <INDENT> if len ( nums ) == N + 1 : <NEWLINE> <INDENT> score = 0 <NEWLINE> for j in range ( Q ) : <NEWLINE> <INDENT> if nums [ B [ j ] ] - nums [ A [ j ] ] == C [ j ] : <NEWLINE> <INDENT> score += D [ j ] <NEWLINE> <DEDENT> <DEDENT> return score <NEWLINE> <NL> <DEDENT> max_score = 0 <NEWLINE> for i in range ( nums [ - 1 ] , M + 1 ) : <NEWLINE> <INDENT> new_nums = nums + [ i ] <NEWLINE> max_score = max ( max_score , dfs ( new_nums ) ) <NEWLINE> <NL> <DEDENT> return max_score <NEWLINE> <NL> <DEDENT> nums [ 1 ] <NEWLINE> res = dfs ( nums ) <NEWLINE> print ( res ) <NEWLINE>
4 6 10 <NEWLINE> 2 4 1 86568 <NEWLINE> 1 4 0 90629 <NEWLINE> 2 3 0 90310 <NEWLINE> 3 4 1 29211 <NEWLINE> 3 4 3 78537 <NEWLINE> 3 4 2 8580 <NEWLINE> 1 2 1 96263 <NEWLINE> 1 4 2 2156 <NEWLINE> 1 2 0 94325 <NEWLINE> 1 4 3 94328 <NEWLINE>
from itertools import combinations_with_replacement <NEWLINE> <NL> n , m , q = map ( int , input ( ) . split ( ) ) <NEWLINE> cond = [ ] <NEWLINE> for _ in range ( q ) : <NEWLINE> <INDENT> a , b , c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> a -= 1 <NEWLINE> b -= 1 <NEWLINE> cond . append ( ( a , b , c , d ) ) <NEWLINE> <NL> <NL> <DEDENT> def calc ( l ) : <NEWLINE> <INDENT> score = 0 <NEWLINE> for a , b , c , d in cond : <NEWLINE> <INDENT> if l [ b ] - l [ a ] == c : <NEWLINE> <INDENT> score += d <NEWLINE> <DEDENT> <DEDENT> return score <NEWLINE> <NL> <NL> <DEDENT> ans = 0 <NEWLINE> l = [ 0 ] * n <NEWLINE> l [ 0 ] = 1 <NEWLINE> <NL> <NL> def dfs ( l_len ) : <NEWLINE> <INDENT> if l_len == n : <NEWLINE> <INDENT> ans = max ( ans , calc ( l ) ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> for i in range ( l [ l_len - 1 ] , m + 1 ) : <NEWLINE> <INDENT> l [ l_len ] = i <NEWLINE> dfs ( l_len + 1 ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> dfs ( 0 ) <NEWLINE> print ( ans ) <NEWLINE>
import itertools <NEWLINE> N , M , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> cand = list ( itertools . combinations_with_replacement ( N + M - 1 , N ) ) <NEWLINE> fs = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( Q ) ] <NEWLINE> <NL> def calc ( fs , As ) : <NEWLINE> <INDENT> count = 0 <NEWLINE> for a , b , c , d in fs : <NEWLINE> <INDENT> if As [ b - 1 ] - As [ a - 1 ] == a : <NEWLINE> <INDENT> count += d <NEWLINE> <DEDENT> <DEDENT> return count <NEWLINE> <DEDENT> ans = 0 <NEWLINE> for As in cand : <NEWLINE> <INDENT> ans = max ( ans , calc ( fs , As ) ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
import itertools <NEWLINE> import numpy as np <NEWLINE> <NL> N , M , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> A = np . array ( list ( itertools . combinations_with_replacemeent ( range ( 1 , M + 1 ) , N ) ) ) <NEWLINE> s = np . zeros ( len ( A ) , np . int32 ) <NEWLINE> <NL> for i in range ( Q ) : <NEWLINE> <INDENT> a , b , c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> s += d * ( A [ : , b - 1 ] - A [ : , a - 1 ] == c ) <NEWLINE> <NL> <DEDENT> print ( s . max ( ) ) <NEWLINE>
mport itertools <NEWLINE> <NL> N , M , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> cmb = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( Q ) ] <NEWLINE> <NL> def score ( seq ) : <NEWLINE> <INDENT> s = 0 <NEWLINE> for q in range ( Q ) : <NEWLINE> <INDENT> if seq [ cmb [ q ] [ 1 ] - 1 ] - seq [ cmb [ q ] [ 0 ] - 1 ] == cmb [ q ] [ 2 ] : <NEWLINE> <INDENT> s += cmb [ q ] [ 3 ] <NEWLINE> <DEDENT> <DEDENT> return s <NEWLINE> <NL> <DEDENT> p = [ i for i in range ( 1 , M + 1 ) ] <NEWLINE> A = itertools . combinations_with_replacement ( p , N ) <NEWLINE> ans = 0 <NEWLINE> for a in A : <NEWLINE> <INDENT> ans = max ( ans , score ( a ) ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
N , M , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> abcd = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( Q ) ] <NEWLINE> <NL> q = [ ] <NEWLINE> def dp ( arg ) : <NEWLINE> <INDENT> global N <NEWLINE> if len ( arg ) == N : <NEWLINE> <INDENT> q . append ( arg ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> tmp = 0 if len ( arg ) == 0 else arg [ - 1 ] <NEWLINE> for i in range ( arg [ - 1 ] , M + 1 ) : <NEWLINE> <INDENT> dp ( arg + [ i ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> dp ( [ ] ) <NEWLINE> <NL> ans = 0 <NEWLINE> for A_tmp in q : <NEWLINE> <INDENT> ans_tmp = 0 <NEWLINE> for j , ( aj , bj , cj , dj ) in enumerate ( abcd ) : <NEWLINE> <INDENT> if A_tmp [ bj - 1 ] - A_tmp [ aj - 1 ] == cj : <NEWLINE> <INDENT> ans_tmp += dj <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> ans = max ( ans , ans_tmp ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
import itertools <NEWLINE> N , M , Q = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> src = [ list ( map ( int , input ( ) . split ( ) ) ) for q in range ( Q ) ] <NEWLINE> ML = [ n + 1 for n in range ( M ) ] <NEWLINE> X = list ( itertools . combinations_with_replacement ( ML , N ) ) <NEWLINE> L = [ ] <NEWLINE> for x in X : <NEWLINE> <INDENT> a = 0 <NEWLINE> for s in src : <NEWLINE> <INDENT> if x [ s [ 1 ] ] - x [ s [ 0 ] ] == s [ 2 ] : <NEWLINE> <INDENT> a += s [ 3 ] <NEWLINE> <DEDENT> <DEDENT> L . append ( a ) <NEWLINE> <DEDENT> print ( max ( L ) ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> N , M , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> abcd = [ ] <NEWLINE> for _ in range ( Q ) : <NEWLINE> <INDENT> a , b , c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> abcd . append ( ( a , b , c , d ) ) <NEWLINE> <DEDENT> def dfs ( A ) : <NEWLINE> <INDENT> if len ( A ) == N : <NEWLINE> <COMMENT> <NL> <INDENT> score = 0 <NEWLINE> for ai , bi , ci , di in abcd : <NEWLINE> <INDENT> if A [ bi - 1 ] - A [ ai - 1 ] == ci : <NEWLINE> <INDENT> score += di <NEWLINE> <DEDENT> <DEDENT> return score <NEWLINE> <DEDENT> max_score = 0 <NEWLINE> <COMMENT> <NL> if len ( A ) > 1 : <NEWLINE> <INDENT> prev_last = A [ - 1 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> prev_last = 1 <NEWLINE> <COMMENT> <NL> <DEDENT> for i in range ( prev_last , M + 1 ) : <NEWLINE> <INDENT> A . append ( i ) <NEWLINE> max_score = max ( max_score , dfs ( A ) ) <NEWLINE> A . pop ( ) <NEWLINE> <DEDENT> return max_score <COMMENT> <NEWLINE> <DEDENT> print ( dfs [ ] ) <NEWLINE>
import itertools <NEWLINE> N , M , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> for i in range ( Q ) : <NEWLINE> <INDENT> q_list . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> <DEDENT> q_list = [ ] <NEWLINE> final_score = 0 <NEWLINE> for A in itertools . combinations_with_replacement ( range ( 1 , 11 ) , N ) : <NEWLINE> <INDENT> score = 0 <NEWLINE> for q in q_list : <NEWLINE> <INDENT> if A [ q [ 1 ] - 1 ] - A [ q [ 0 ] - 1 ] == q [ 2 ] : <NEWLINE> <INDENT> score += q [ 3 ] <NEWLINE> <DEDENT> final_score = max ( [ final_score , score ] ) <NEWLINE> <DEDENT> <DEDENT> print ( final_score ) <NEWLINE>
N , M , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> L = [ ] <NEWLINE> for i in range ( Q ) : <NEWLINE> <INDENT> L . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> L [ i ] [ 0 ] -= 1 <NEWLINE> L [ i ] [ 1 ] -= 1 <NEWLINE> <NL> <DEDENT> import itertools <NEWLINE> L = list ( range ( 1 , M + 1 ) ) <NEWLINE> A = list ( itertools . combinations_with_replacement ( L , N ) ) <NEWLINE> ans = 0 <NEWLINE> for i in A : <NEWLINE> <INDENT> tmp = 0 <NEWLINE> for a , b , c , d in L : <NEWLINE> <INDENT> if ( i [ b ] - i [ a ] ) == c : <NEWLINE> <INDENT> tmp += d <NEWLINE> <DEDENT> <DEDENT> ans = max ( ans , tmp ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
from itertools import combinations_with_replacement <NEWLINE> import numpy as np <NEWLINE> <NL> N , M , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> G = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( Q ) ] <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> A = np . array ( list ( itertools . combinations_with_replacement ( range ( 1 , M + 1 ) , N ) ) ) <NEWLINE> scores = np . zeros ( len ( A ) ) <NEWLINE> for g in G : <NEWLINE> <INDENT> a , b , c , d = g <NEWLINE> cond = A [ : , b - 1 ] - A [ : , a - 1 ] == c <NEWLINE> scores += d * cond <NEWLINE> <NL> <DEDENT> print ( scores . max ( ) ) <NEWLINE>
import itertools <NEWLINE> <NL> N , M , Q = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> numbers = [ i for i in range ( 1 , M + 1 ) ] <NEWLINE> array = itertools . combinations_wih_replacement ( numbers , N ) <NEWLINE> <NL> input_data = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( Q ) ] <NEWLINE> <NL> max_score = 0 <NEWLINE> for A in array : <NEWLINE> <INDENT> score = 0 <NEWLINE> for _ in range ( Q ) : <NEWLINE> <INDENT> a , b , c , d = input_data [ _ ] <NEWLINE> a = a - 1 <NEWLINE> b = b - 1 <NEWLINE> if A [ b ] - A [ a ] == c : <NEWLINE> <INDENT> score += d <NEWLINE> <DEDENT> <DEDENT> if score > max_score : <NEWLINE> <INDENT> max_score = score <NEWLINE> <NL> <DEDENT> <DEDENT> print ( max_score ) <NEWLINE>
<COMMENT> <NL> from itertools import combinations_with_replacement <NEWLINE> n , m , q = map ( int , input ( ) . split ( ) ) <NEWLINE> lst = [ ] <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> lst . append ( a ) <NEWLINE> <COMMENT> <NL> <DEDENT> x = 0 <NEWLINE> <COMMENT> <NL> for i in combinations_with_replacement ( range ( 1 , m + 1 ) , n ) : <NEWLINE> <INDENT> s = 0 <NEWLINE> for j in a : <NEWLINE> <INDENT> if i [ j [ 1 ] - 1 ] - i [ j [ 0 ] - 1 ] == j [ 2 ] : <NEWLINE> <INDENT> s += j [ 3 ] <NEWLINE> <DEDENT> <DEDENT> if x < s : <NEWLINE> <INDENT> x = s <NEWLINE> <DEDENT> <DEDENT> print ( x ) <NEWLINE>
import itertools <NEWLINE> n , m , q = map ( int , input ( ) . split ( ) ) <NEWLINE> qs = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( q ) ] <NEWLINE> mids = [ i for i in range ( m ) ] <NEWLINE> <COMMENT> <NL> max_ans = 0 <NEWLINE> for mid in itertools . combinations_with_replacement ( nums , n - 1 ) : <NEWLINE> <INDENT> if sum ( mid ) > m - 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> sum_ans = 0 <NEWLINE> for i in qs : <NEWLINE> <INDENT> sum_mid = 0 <NEWLINE> for j in range ( i [ 0 ] - 1 , i [ 1 ] - 1 ) : <NEWLINE> <INDENT> sum_mid += mid [ j ] <NEWLINE> <DEDENT> if sum_mid == i [ 2 ] : <NEWLINE> <INDENT> sum_ans += i [ 3 ] <NEWLINE> <DEDENT> <DEDENT> if sum_ans > max_ans : <NEWLINE> <INDENT> max_ans = sum_ans <NEWLINE> <NL> <DEDENT> <DEDENT> print ( max_ans ) <NEWLINE>
import itertools <NEWLINE> n , m , q = map ( int , input ( ) . split ( ) ) <NEWLINE> abcd = [ tuple ( map ( int , input ( ) . split ( ) ) ) for _ in range ( q ) ] <NEWLINE> Max = 0 <NEWLINE> for A in itertools . combinations_with_replacement ( range ( 1 , m + 1 ) n ) : <NEWLINE> <COMMENT> <NL> <INDENT> score = 0 <NEWLINE> for ai , bi , ci , di in abcd : <NEWLINE> <INDENT> if A [ bi - 1 ] - A [ ai - 1 ] == ci : <NEWLINE> <INDENT> score += di <NEWLINE> <DEDENT> <DEDENT> Max = max ( Max , score ) <NEWLINE> <COMMENT> <NL> <DEDENT> print ( Max ) <NEWLINE>
<NL> import random <NEWLINE> n , m , q = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> a = [ 0 ] * q <NEWLINE> b = [ 0 ] * q <NEWLINE> c = [ 0 ] * q <NEWLINE> d = [ 0 ] * q <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> a [ i ] , b [ i ] , c [ i ] , d [ i ] = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <DEDENT> A = [ 0 ] * 60 <NEWLINE> <NL> <NL> <NL> l = [ 0 ] * 60 <NEWLINE> for z in range ( 60 ) : <NEWLINE> <INDENT> x = 0 <NEWLINE> for j in range ( q - 1 ) : <NEWLINE> <INDENT> if A [ z [ b [ j ] - 1 ] ] - A [ z [ a [ j ] - 1 ] ] == c [ j ] : <NEWLINE> <INDENT> x = x + int ( d [ j ] ) <NEWLINE> <DEDENT> l [ j ] = x <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> x = 0 <NEWLINE> for j in range ( q - 1 ) : <NEWLINE> <INDENT> if A [ b [ j ] - 1 ] - A [ a [ j ] - 1 ] == c [ j ] : <NEWLINE> <INDENT> x = x + int ( d [ j ] ) <NEWLINE> <DEDENT> l [ j ] = x <NEWLINE> <NL> <DEDENT> print ( max ( l ) ) <NEWLINE>
<COMMENT> <NL> from itertools import itertools . combinations_with_replacement <NEWLINE> N , M , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> abcd = [ ] <NEWLINE> for _ in range ( Q ) : <NEWLINE> <INDENT> abcd . append ( tuple ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <DEDENT> Abase = [ ] <NEWLINE> for a in range ( 1 , M + 1 ) : <NEWLINE> <INDENT> Abase = Abase + [ a ] <NEWLINE> <DEDENT> A = set ( itertools . combinations_with_replacement ( Abase , N ) ) <NEWLINE> ans = 0 <NEWLINE> for i in A : <NEWLINE> <INDENT> temp = 0 <NEWLINE> for j in abcd : <NEWLINE> <INDENT> if i [ j [ 1 ] - 1 ] - i [ j [ 0 ] - 1 ] == j [ 2 ] : <NEWLINE> <INDENT> temp = temp + j [ 3 ] <NEWLINE> <DEDENT> <DEDENT> if temp >= ans : <NEWLINE> <INDENT> ans = temp <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from itertools import product <NEWLINE> <NL> n , m , q = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( q ) ] <NEWLINE> <NL> temp = list ( combinations ( [ i for i in range ( 1 , m + 1 ) ] , n ) ) <NEWLINE> <NL> <NL> ans = 0 <NEWLINE> <NL> for a_temp in temp : <NEWLINE> <INDENT> ans_temp = 0 <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> if a_temp [ a [ i ] [ 1 ] - 1 ] - a_temp [ a [ i ] [ 0 ] - 1 ] == a [ i ] [ 2 ] : <NEWLINE> <INDENT> ans_temp += a [ i ] [ 3 ] <NEWLINE> <DEDENT> <DEDENT> if ans < ans_temp : <NEWLINE> <INDENT> ans = ans_temp <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import itertools <NEWLINE> N , M , Q = input ( ) . split ( ) <NEWLINE> N = int ( N ) <NEWLINE> M = int ( M ) <NEWLINE> Q = int ( Q ) <NEWLINE> num = [ 0 ] * Q <NEWLINE> for i in range ( Q ) : <NEWLINE> <INDENT> num [ i ] = [ list ( map ( int , input ( ) . split ( ) ) ) ] <NEWLINE> <DEDENT> num = list ( range ( 1 , M + 1 ) ) <NEWLINE> A = [ ] <NEWLINE> for v in itertools . combinations ( num , N ) : <NEWLINE> <INDENT> A . append ( list ( v ) ) <NEWLINE> <DEDENT> score = 0 <NEWLINE> for w in A : <NEWLINE> <INDENT> scoreX = 0 <NEWLINE> for j in range ( Q ) : <NEWLINE> <INDENT> b = num [ j ] [ 1 ] <NEWLINE> a = num [ j ] [ 0 ] <NEWLINE> if num [ j ] [ 2 ] == w [ b - 1 ] - w [ a - 1 ] : <NEWLINE> <INDENT> scoreX += num [ j ] [ 3 ] <NEWLINE> <DEDENT> <DEDENT> if scoreX > score : <NEWLINE> <INDENT> score = scoreX <NEWLINE> <DEDENT> <DEDENT> print ( str ( score ) ) <NEWLINE>
<NL> n , m , q = map ( int , input ( ) . split ( ) ) <NEWLINE> num_lst = [ ] <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> num_lst . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <DEDENT> l = list ( range ( 1 , m + 1 ) ) <NEWLINE> A = list ( combinations_with_replacement ( l , n ) ) <NEWLINE> <NL> mx = 0 <NEWLINE> for now_A in A : <NEWLINE> <INDENT> score = 0 <NEWLINE> for nums in num_lst : <NEWLINE> <INDENT> a , b , c , d = nums <NEWLINE> if now_A [ b - 1 ] - now_A [ a - 1 ] == c : <NEWLINE> <INDENT> score += d <NEWLINE> <DEDENT> <DEDENT> mx = max ( mx , score ) <NEWLINE> <DEDENT> print ( mx ) <NEWLINE> <NL> <NL> <NL>
N , M , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> reqs = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( Q ) ] <NEWLINE> <NL> As = [ ] <NEWLINE> <NL> def make ( A ) : <NEWLINE> <INDENT> global As , N , M <NEWLINE> if len ( A ) == N + 1 : <NEWLINE> <INDENT> As . append ( A ) <NEWLINE> <DEDENT> elif : <NEWLINE> <INDENT> for i in range ( A [ len ( A ) - 1 ] , M + 1 ) : <NEWLINE> <INDENT> A . append ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> make ( [ 1 ] ) <NEWLINE> <NL> max = 0 <NEWLINE> for A in As : <NEWLINE> <INDENT> score = 0 <NEWLINE> for req in reqs : <NEWLINE> <INDENT> if A [ req [ 1 ] ] - A [ req [ 0 ] ] == req [ 2 ] : <NEWLINE> <INDENT> score += req [ 3 ] <NEWLINE> <DEDENT> <DEDENT> max = max ( score , max ) <NEWLINE> <NL> <DEDENT> print ( max ) <NEWLINE>
<COMMENT> <NL> N , M , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> matrix = [ ] <NEWLINE> for _ in range ( Q ) : <NEWLINE> <INDENT> c = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> matrix . append ( c ) <NEWLINE> <COMMENT> <NL> <DEDENT> import itertools <NEWLINE> ansscore = 0 <NEWLINE> combi = list ( combinations_with_replacement ( range ( 1 , M + 1 ) , N ) ) <NEWLINE> for i in combi : <NEWLINE> <INDENT> i = list ( i ) <NEWLINE> i . sort ( ) <NEWLINE> score = 0 <NEWLINE> for l in matrix : <NEWLINE> <INDENT> a = l [ 0 ] <NEWLINE> b = l [ 1 ] <NEWLINE> c = l [ 2 ] <NEWLINE> d = l [ 3 ] <NEWLINE> if i [ b - 1 ] - i [ a - 1 ] == c : <NEWLINE> <INDENT> score += d <NEWLINE> <DEDENT> <DEDENT> ansscore = score if score > ansscore else ansscore <NEWLINE> <NL> <DEDENT> print ( ansscore ) <NEWLINE>
N , M , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> v = [ [ ] for _ in range ( Q ) ] <NEWLINE> o = 0 <NEWLINE> for i in range ( Q ) : <NEWLINE> <INDENT> v [ i ] = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <DEDENT> l = list ( itertools . combinations ( range ( M + N ) , N ) ) <NEWLINE> for x in l : <NEWLINE> <INDENT> s = 0 <NEWLINE> a = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> a . append ( x [ i ] - i ) <NEWLINE> <DEDENT> for i in range ( Q ) : <NEWLINE> <INDENT> if a [ l [ i ] [ 2 ] ] - a [ l [ i ] [ 1 ] ] - l [ i ] [ 3 ] == 0 : <NEWLINE> <INDENT> s += l [ i ] [ 4 ] <NEWLINE> <DEDENT> <DEDENT> if s > o : <NEWLINE> <INDENT> o = s <NEWLINE> <DEDENT> <DEDENT> print ( o ) <NEWLINE>
n , m , q = map ( int , input ( ) . split ( ) ) <NEWLINE> cnt = 0 <NEWLINE> for _ in range ( q ) : <NEWLINE> <INDENT> a , b , c , d = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <DEDENT> for i in range ( m - n + 1 ) : <NEWLINE> <INDENT> if b [ i ] - a [ i ] + ( m - n ) == c [ i ] : <NEWLINE> <INDENT> cnt += d [ i ] <NEWLINE> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> import numpy as np <NEWLINE> <NL> from itertools import combinations_with_replacement as CwR <NEWLINE> <NL> <NL> <NL> n , m , q = map ( int , input ( ) . split ( ) ) <NEWLINE> Lis = [ [ int ( e ) for e in input ( ) . split ( ) ] for _ in range ( q ) ] <NEWLINE> <NL> Tables = list ( CwR ( range ( 1 , M + 1 ) , N ) ) <NEWLINE> Sum_cor = [ ] <NEWLINE> for Table in Tables : <NEWLINE> <INDENT> d_sum = 0 <NEWLINE> for l in Lis : <NEWLINE> <INDENT> if Table [ l [ 1 ] - 1 ] - Table [ l [ 0 ] - 1 ] == l [ 2 ] : <NEWLINE> <INDENT> d_sum += l [ 3 ] <NEWLINE> <DEDENT> <DEDENT> Sum_cor . append ( d_sum ) <NEWLINE> <NL> <NL> <DEDENT> print ( max ( Sum_cor ) ) <NEWLINE>
<COMMENT> <NL> <NL> <NL> N , M , Q = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> numbers = [ ] <NEWLINE> for i in range ( Q ) : <NEWLINE> <INDENT> numbers . append ( [ int ( j ) for j in input ( ) . split ( ) ] ) <NEWLINE> <NL> <DEDENT> numbers = sorted ( numbers , key = lambda x : - x [ 1 ] ) <NEWLINE> <COMMENT> <NL> <NL> kouho = [ <STRING> * ( N ) ] <NEWLINE> <COMMENT> <NL> for a , b , c , d in numbers : <NEWLINE> <INDENT> for k in kouho : <NEWLINE> <INDENT> if int ( k [ b - 1 ] ) - int ( k [ a - 1 ] ) != c : <NEWLINE> <INDENT> new_k = k [ : a - 1 ] + str ( int ( k [ b - 1 ] ) - c ) + k [ a : ] <NEWLINE> if str ( int ( k [ b - 1 ] ) - c ) >= 0 : <NEWLINE> <INDENT> kouho . append ( new_k ) <NEWLINE> kouho = list ( set ( kouho ) ) <NEWLINE> <NL> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> answers = [ 0 ] * len ( kouho ) <NEWLINE> for i , k in enumerate ( kouho ) : <NEWLINE> <INDENT> ans = 0 <NEWLINE> for a , b , c , d in numbers : <NEWLINE> <INDENT> if int ( k [ b - 1 ] ) - int ( k [ a - 1 ] ) == c : <NEWLINE> <INDENT> ans += d <NEWLINE> <DEDENT> <DEDENT> answers [ i ] = ans <NEWLINE> <DEDENT> print ( max ( answers ) ) <NEWLINE> <STRING> <NEWLINE>
N , M , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> li = [ ] <NEWLINE> counter = 0 <NEWLINE> n = [ ] <NEWLINE> for s in range ( Q ) : <NEWLINE> <INDENT> li . append ( list ( map ( int , input ( ) . strip ( ) ) ) ) <NEWLINE> <NL> <DEDENT> for i in range ( 10 ** ( N - 1 ) , 10 ** N ) : <NEWLINE> <INDENT> k = str ( i ) <NEWLINE> for q in range ( Q ) : <NEWLINE> <INDENT> if k [ li [ q ] [ 1 ] ] - k [ li [ q ] [ 0 ] ] == k [ li [ q ] [ 2 ] ] : <NEWLINE> <INDENT> counter += k [ li [ q ] [ 3 ] ] <NEWLINE> <DEDENT> n . append ( counter ) <NEWLINE> counter = 0 <NEWLINE> <DEDENT> <DEDENT> print ( max ( n ) ) <NEWLINE>
import itertools <NEWLINE> N , M , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ 0 ] * Q <NEWLINE> b = [ 0 ] * Q <NEWLINE> c = [ 0 ] * Q <NEWLINE> d = [ 0 ] * Q <NEWLINE> for i in range ( Q ) : <NEWLINE> <INDENT> a [ i ] , b [ i ] , c [ i ] , d [ i ] = map ( int , input ( ) . split ( ) ) <NEWLINE> <DEDENT> ans = 0 <NEWLINE> for A in combinations_with_replacement ( range ( 1 , M + 1 ) , N ) : <NEWLINE> <INDENT> tmp = 0 <NEWLINE> for i in range ( Q ) : <NEWLINE> <INDENT> if A [ b [ i ] - 1 ] - A [ a [ i ] - 1 ] == c [ i ] : <NEWLINE> <INDENT> tmp += d [ i ] <NEWLINE> <DEDENT> <DEDENT> ans = max ( ans , tmp ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import itertools <NEWLINE> n , m , q = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ 0 ] * q <NEWLINE> b = [ 0 ] * q <NEWLINE> c = [ 0 ] * q <NEWLINE> d = [ 0 ] * q <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> a [ i ] , b [ i ] , c [ i ] , d [ i ] = map ( int , input ( ) . split ( ) ) <NEWLINE> <DEDENT> ans = 0 <NEWLINE> for A in itertools . combinations_with_replacement ( range ( 1 , m + 1 ) , n ) : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> if A [ b [ i ] - 1 ] - A [ a [ i ] - 1 ] == c [ i ] : <NEWLINE> <INDENT> cnt += d [ i ] <NEWLINE> <DEDENT> <DEDENT> ans = max ( ans , tmp ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import itertools ; n , m , q , * l = map ( int , open ( 0 ) . read ( ) . split ( ) ) ; print ( max ( sum ( d for a , b , c , d in l [ : : 4 ] if i [ b - 1 ] - i [ a - 1 ] == c ) for i in itertools . combinations_with_replacement ( range ( m ) , n ) ) ) <NEWLINE>
from itertools import combinations_with_replacement as comb <NEWLINE> <NL> n , m , q = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> lis = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( q ) ] <NEWLINE> tes = comb ( range ( 1 , m ) ) <NEWLINE> res = 0 <NEWLINE> for i in tes : <NEWLINE> <INDENT> te = 0 <NEWLINE> for a , b , c , d in lis : <NEWLINE> <INDENT> if c == i [ b - 1 ] - i [ a - 1 ] : <NEWLINE> <INDENT> te += d <NEWLINE> <DEDENT> <DEDENT> res = max ( te , res ) <NEWLINE> <DEDENT> print ( res ) <NEWLINE>
from itertools import * ; n , m , q = map ( int , input ( ) . split ( ) ) ; l = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in [ 0 ] * q ] ; print ( max ( sum ( d for a in l if i [ b - 1 ] - i [ a - 1 ] == c ) for i in itertools . combinations_with_replacement ( range ( m ) , n ) ) ) <NEWLINE>
import bisect <NEWLINE> <NL> def lis ( lst ) : <NEWLINE> <INDENT> lis_lst = [ lst [ 0 ] ] <NEWLINE> for i in lst : <NEWLINE> <INDENT> if i > lis_lst [ - 1 ] : <NEWLINE> <INDENT> lis_lst . append ( i ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> lis_lst [ bisect . bisect_left ( lis_lst , i ) ] = i <NEWLINE> <DEDENT> <DEDENT> return len ( lis_lst ) <NEWLINE> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> <NL> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> uv = { } <NEWLINE> for _ in range ( n - 1 ) : <NEWLINE> <INDENT> u , v = map ( int , input ( ) . split ( ) ) <NEWLINE> uv [ v ] = u <NEWLINE> <NL> <DEDENT> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> lst = [ ] <NEWLINE> while i != 1 : <NEWLINE> <INDENT> lst . append ( a [ i - 1 ] ) <NEWLINE> i = uv [ i ] <NEWLINE> <DEDENT> lst . append ( a [ 0 ] ) <NEWLINE> lst . reverse ( ) <NEWLINE> print ( lis ( lst ) ) <NEWLINE> <DEDENT>
import random <NEWLINE> from copy import deepcopy <NEWLINE> <NL> n , m , q = map ( int , input ( ) . split ( ) ) <NEWLINE> l = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( q ) ] <NEWLINE> <NL> gene_length = n <NEWLINE> individual_length = n * 10 <NEWLINE> generation = 100 <NEWLINE> elite_gene = 1 <NEWLINE> individual_mutation = 0.01 <NEWLINE> gene_mutation = 0.01 <NEWLINE> <NL> def get_population ( ) : <NEWLINE> <INDENT> pop = [ ] <NEWLINE> for i in range ( individual_length ) : <NEWLINE> <INDENT> pop . append ( [ random . randrange ( 1 , m + 1 ) for j in range ( gene_length ) ] ) <NEWLINE> <DEDENT> return pop <NEWLINE> <NL> <NL> <DEDENT> def get_fitness ( indiv ) : <NEWLINE> <INDENT> fitness = 0 <NEWLINE> for a , b , c , d in l : <NEWLINE> <INDENT> a -= 1 <NEWLINE> b -= 1 <NEWLINE> if indiv [ b ] - indiv [ a ] == c : <NEWLINE> <INDENT> fitness += d <NEWLINE> <DEDENT> <DEDENT> return fitness <NEWLINE> <NL> <NL> <DEDENT> def elite_selection ( pop ) : <NEWLINE> <INDENT> pop . sort ( reverse = True , key = lambda x : x [ 1 ] ) <NEWLINE> return pop [ : elite_gene + 1 ] <NEWLINE> <NL> <NL> <DEDENT> def two_point_crossover ( parent1 , parent2 ) : <NEWLINE> <INDENT> r1 = random . randint ( 0 , gene_length - 1 ) <NEWLINE> r2 = random . randint ( 0 , gene_length - 1 ) <NEWLINE> child = deepcopy ( parent1 ) <NEWLINE> child [ r1 : r2 ] = parent2 [ r1 : r2 ] <NEWLINE> return child <NEWLINE> <NL> <NL> <DEDENT> pop = [ [ p , get_fitness ( p ) ] for p in get_population ( ) ] <NEWLINE> pop . sort ( reverse = True , key = lambda x : x [ 1 ] ) <NEWLINE> <NL> for g in range ( generation ) : <NEWLINE> <INDENT> elites = elite_selection ( pop ) <NEWLINE> pop = elites <NEWLINE> while len ( pop ) < individual_length : <NEWLINE> <INDENT> if random . random ( ) < individual_mutation : <NEWLINE> <INDENT> child = [ random . randrange ( 1 , m + 1 ) for j in range ( gene_length ) ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> m1 = random . randint ( 0 , len ( elites ) - 1 ) <NEWLINE> m2 = random . randint ( 0 , len ( elites ) - 1 ) <NEWLINE> child = two_point_crossover ( elites [ m1 ] [ 0 ] , elites [ m2 ] [ 0 ] ) <NEWLINE> <DEDENT> pop . append ( [ child , get_fitness ( child ) ] ) <NEWLINE> <NL> n_pop = [ ] <NEWLINE> for i in pop : <NEWLINE> <INDENT> if i not in n_pop : <NEWLINE> <INDENT> n_pop . append ( i ) <NEWLINE> <DEDENT> <DEDENT> pop = n_pop <NEWLINE> <NL> <DEDENT> pop . sort ( reverse = True , key = lambda x : x [ 1 ] ) <NEWLINE> <NL> <DEDENT> ans = pop [ 0 ] [ 1 ] <NEWLINE> print ( ans ) <NEWLINE>
import itertools <NEWLINE> <NL> N , M , Q = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> C = [ ] <NEWLINE> for i in range ( Q ) : <NEWLINE> <INDENT> C . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> <DEDENT> res = 0 <NEWLINE> ls = list ( range ( 1 , M + 1 ) ) <NEWLINE> <NL> for a in itertools . combinations_with_replacement ( ls , N ) : <NEWLINE> <INDENT> p = 0 <NEWLINE> for c in C : <NEWLINE> <INDENT> if a [ c [ 1 ] ] - a [ c [ 0 ] ] == c [ 2 ] : <NEWLINE> <INDENT> p += c [ 3 ] <NEWLINE> <DEDENT> res = max ( res , p ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( res ) <NEWLINE>
<COMMENT> <NL> x = int ( input ( ) ) <NEWLINE> for i in range ( - 73 , 73 ) : <NEWLINE> <INDENT> for j in range ( - 73 , 73 ) : <NEWLINE> <INDENT> print ( i , j ) <NEWLINE> if i ** 5 - j ** 5 == x : <NEWLINE> <INDENT> a = i <NEWLINE> b = j <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( a , b ) <NEWLINE>
<NL> <NL> a , b , n = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = 0 <NEWLINE> <NL> for i in range ( n + 1 , n - a , - 1 ) : <NEWLINE> <INDENT> ans = max ( ans , ( a * i ) // b ) - a * ( i // b ) ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> <NL> import sys <NEWLINE> import pprint <NEWLINE> import math <NEWLINE> <NL> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> <NL> class Logger : <NEWLINE> <INDENT> def __init__ ( self , debug ) : <NEWLINE> <INDENT> self . debug = debug <NEWLINE> <DEDENT> def print ( self , * args ) : <NEWLINE> <INDENT> if self . debug : <NEWLINE> <INDENT> pprint . pprint ( args ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <INDENT> log = Logger ( 1 ) <NEWLINE> a , b , n = map ( int , sys . stdin . readline ( ) . split ( ) ) <NEWLINE> if n < b : <NEWLINE> <INDENT> print ( int ( ( n / b - int ( n / b ) ) * a ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( int ( ( ( b - 1 ) / b - int ( ( b - 1 ) / b ) ) * a ) ) <NEWLINE> <NL> <NL> <NL> <NL> <DEDENT> <DEDENT> main ( ) <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> log = Logger ( 1 ) <NEWLINE> a , b , n = map ( int , sys . stdin . readline ( ) . split ( ) ) <NEWLINE> if n < b : <NEWLINE> <INDENT> print ( int ( ( n / b - int ( n / b ) ) * a ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( int ( ( ( b - 1 ) / b - int ( ( b - 1 ) / b ) ) * a ) ) <NEWLINE> <NL> <NL> <NL> <NL> <DEDENT> <DEDENT> main ( ) <NEWLINE>
A , B , N = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if B > N : <NEWLINE> <INDENT> print ( A * N // B ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( A * ( B - 1 ) // B <NEWLINE> <DEDENT>
a , b , n = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> def f ( x ) : <NEWLINE> <INDENT> return a * x // b - a * ( x // b ) <NEWLINE> <NL> <DEDENT> left = 1 <NEWLINE> right = n <NEWLINE> for _ in range ( 100 ) : <NEWLINE> <INDENT> delta = ( right - left ) / 3 <NEWLINE> midl = left + delta <NEWLINE> midr = midl + delta <NEWLINE> <COMMENT> <NL> if f ( midl ) > f ( midr ) : <NEWLINE> <INDENT> right = midr <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> left = midl <NEWLINE> <DEDENT> <DEDENT> print ( max ( f ( int ( midl ) ) , f ( min ( int ( midl ) + 1 ) , n ) ) ) <NEWLINE>
a , b , n = map ( int , input ( ) . split ( ) ) <NEWLINE> if a == 1 or b == 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> prev = 0 <NEWLINE> <NL> for x in range ( min ( b - 1 , n ) , n + 1 , b ) : <NEWLINE> <INDENT> val = floor ( a * x / b ) - a * floor ( x / b ) <NEWLINE> if val < prev : <NEWLINE> <INDENT> print ( prev ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> prev = val <NEWLINE> <NL> <DEDENT> val = floor ( a * n / b ) - a * floor ( n / b ) <NEWLINE> print ( max ( prev , val ) ) <NEWLINE> <NL>
import math <NEWLINE> a , b , n = map ( int , input ( ) . split ( ) ) <NEWLINE> if n < b : <NEWLINE> <INDENT> x = n <NEWLINE> <DEDENT> else b < n : <NEWLINE> <INDENT> x = b - 1 <NEWLINE> <DEDENT> new = math . floor ( a * x / b ) - a * math . floor ( x / b ) <NEWLINE> print ( new ) <NEWLINE>
<COMMENT> <NL> <NL> inp = input ( ) . split ( <STRING> ) <NEWLINE> A , B , N = int ( inp [ 0 ] ) , int ( inp [ 1 ] ) , int ( inp [ 2 ] ) <NEWLINE> <NL> alpha , beta = math . floor ( A / B ) , A % B <NEWLINE> if B - 1 < N : <NEWLINE> <INDENT> x = B - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = N <NEWLINE> <NL> <DEDENT> print ( math . floor ( A * x / B ) - A * math . floor ( x / B ) ) <NEWLINE>
a , b , n = map ( int ( input ( ) . split ( ) ) <NEWLINE> if b - 1 <= n : <NEWLINE> <INDENT> x = b - 1 <NEWLINE> print ( int ( a * x / b ) - a * int ( x / b ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = n <NEWLINE> print ( int ( a * x / b ) - a * int ( x / b ) ) <NEWLINE> <NL> <NL> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> a , b , n = map ( int , input ( ) . split ( ) ) <NEWLINE> l = [ ] <NEWLINE> if n >= b : <NEWLINE> <INDENT> x = b - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = n <NEWLINE> <DEDENT> print ( math . floor ( ( a * x ) / b ) - a * math . floor ( x / b ) ) <NEWLINE>
a , b , n = map ( int , input ( ) . split ( ) ) <NEWLINE> import math <NEWLINE> if n < b : <NEWLINE> <INDENT> print ( int ( math . floor ( a * n / b ) - a * np . floor ( n / b ) ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( int ( math . floor ( a * ( b - 1 ) / b ) - a * np . floor ( ( b - 1 ) / b ) ) ) <NEWLINE> <DEDENT>
a , b , n = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if b <= n : <NEWLINE> <INDENT> if a % b != 0 <NEWLINE> <INDENT> print ( a - a // b - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( a - a // b ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( int ( n * a / b ) ) <NEWLINE> <DEDENT>
a , b , n = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> def f ( a , b , x ) : <NEWLINE> <INDENT> return ( a * x ) // b - a * ( x // b ) <NEWLINE> <NL> <DEDENT> print ( f ( min ( b - 1 , n ) ) ) <NEWLINE>
a , b , n = map ( int , input ( ) . split ( ) ) <NEWLINE> n % b == 0 : n -= 1 <NEWLINE> print ( ( a * n ) // b - a * ( n // b ) ) <NEWLINE>
A , B , N = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> def calc ( x ) : <NEWLINE> <INDENT> return ( ( A * x ) // B ) - A * ( x // B ) <NEWLINE> <NL> <DEDENT> prit ( max ( calc ( N ) , calc ( B - 1 ) ) ) <NEWLINE>
import math <NEWLINE> A , B , N = map ( int , input ( ) . split ( ) ) <NEWLINE> def kansu ( x ) : <NEWLINE> <INDENT> S = floor ( A * x / B ) <NEWLINE> return S <NEWLINE> <DEDENT> print ( min ( kansu ( N ) , kansu ( B ) ) ) <NEWLINE>
arr = input ( ) . split ( <STRING> ) <NEWLINE> a , b , n = int ( arr [ 0 ] ) , int ( arr [ 1 ] ) , int ( arr [ 2 ] ) <NEWLINE> if b <= n : <NEWLINE> <INDENT> k = a <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> k = ( a * ( ( n - 1 ) ) // b <NEWLINE> <DEDENT> print ( k ) <NEWLINE>
A , B , N = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> def f ( a , b , n ) : <NEWLINE> <INDENT> fl1 = ( a * ( n + 1 ) ) // b <NEWLINE> fl2 = ( n + 1 ) // b <NEWLINE> fl = fl1 - a * fl2 <NEWLINE> return fl <NEWLINE> <NL> <DEDENT> print ( f ( a , b , b - 1 ) if n >= b - 1 else f ( a , b , n ) ) <NEWLINE>
a , b , n = map ( int , ( inpur ( ) . split ( ) ) <NEWLINE> x = min ( b - 1 , n ) <NEWLINE> print ( int ( a * x / b ) - a * int ( x / b ) ) <NEWLINE>
A , B , N = map ( int , input ( ) . split ( ) ) <NEWLINE> maxn = 0 <NEWLINE> if A < B : <NEWLINE> <INDENT> if B / 2 < N : <NEWLINE> <INDENT> t = math . ceil ( B / 2 ) - 1 <NEWLINE> ans = tmp = math . floor ( ( A * t ) / B ) - A * ( math . floor ( t / B ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = tmp = math . floor ( ( A * N ) / B ) - A * ( math . floor ( N / B ) ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for x in range ( 1 , B + 1 ) : <NEWLINE> <INDENT> tmp = math . floor ( ( A * x ) / B ) - A * ( math . floor ( x / B ) ) <NEWLINE> if maxn < tmp : <NEWLINE> <INDENT> maxn = tmp <NEWLINE> <DEDENT> <DEDENT> ans = maxn <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
def cal ( i ) : <NEWLINE> <INDENT> return floor ( a * i / b ) - a * floor ( i / b ) <NEWLINE> <DEDENT> from math import floor <NEWLINE> a , b , n = map ( int , input ( ) . split ( ) ) <NEWLINE> if b - 1 < n : <NEWLINE> <INDENT> ans = cal ( b - 1 ) <NEWLINE> <DEDENT> print ( max ( cal ( ans ) , cal ( 0 ) , cal ( n ) ) ) <NEWLINE>
import math <NEWLINE> a , b , n = map ( int , input ( ) . split ( ) ) <NEWLINE> if b != 1 : <NEWLINE> <INDENT> x = min ( n , b - 1 ) <NEWLINE> while x <= n : <NEWLINE> <INDENT> Max = max ( math . floor ( a * x / b ) - a * math . floor ( x / b ) , Max ) <NEWLINE> x += b <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> Max = 0 <NEWLINE> <DEDENT> print ( Max ) <NEWLINE>
import sys <NEWLINE> from copy import deepcopy <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> <NL> <NL> def dfs ( now ) : <NEWLINE> <INDENT> global ans <NEWLINE> if len ( now ) == N : <NEWLINE> <INDENT> tmp_ans = 0 <NEWLINE> for a , b , c , d in query : <NEWLINE> <INDENT> a -= 1 <NEWLINE> b -= 1 <NEWLINE> if now [ b ] - now [ a ] == c : <NEWLINE> <INDENT> tmp_ans += d <NEWLINE> <DEDENT> <DEDENT> ans = max ( tmp_ans , ans ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( now [ - 1 ] , M + 1 ) : <NEWLINE> <INDENT> tmp = deepcopy ( now ) <NEWLINE> tmp . append ( i ) <NEWLINE> dfs ( tmp ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> N , M , Q = map ( int , input ( ) . split ( ) ) <COMMENT> <NEWLINE> query = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( Q ) ] <NEWLINE> <NL> A = [ 1 ] <NEWLINE> ans = 0 <NEWLINE> dfs ( A ) <NEWLINE> print ( ans ) <NEWLINE>
import math as mt <NEWLINE> A , B , N = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( math . floor ( ( A * N ) / B ) - A * math . floor ( N / B ) ) <NEWLINE>
A , B , N = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( 10 ** 7 ) : <NEWLINE> <INDENT> print ( A * i // B - A * ( i // B ) ) <NEWLINE> ans = max ( ans , A * i // B - A * ( i // B ) ) <NEWLINE> <NL> <DEDENT> for i in range ( 10 ** 7 ) : <NEWLINE> <INDENT> i = N - i <NEWLINE> if i < 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> ans = max ( ans , A * i // B - A * ( i // B ) ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> a , b , n = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> c = b - 1 <NEWLINE> <NL> ans = math . floor ( a * c / b ) - a * floor ( c / b ) <NEWLINE> <NL> print ( ans ) <NEWLINE>
import math <NEWLINE> a , b , n = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if b > n : <NEWLINE> <INDENT> print ( math . floor ( a * n / b ) ) <NEWLINE> <DEDENT> elif n < 2 * b - 1 : <NEWLINE> <INDENT> print ( max ( math . floor ( a * n / b ) - a , math . floor ( a * ( b - 1 ) / b ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( a + math . floor ( ( - 1 ) * a / b ) ) <NEWLINE> <DEDENT>
s = input ( ) . split ( <STRING> ) <NEWLINE> A , B , N = int ( s [ 0 ] ) , int ( s [ 1 ] ) , int ( s [ 2 ] ) <NEWLINE> <NL> def f ( x ) : <NEWLINE> <INDENT> a = np . floor ( A * x / B ) - A * np . floor ( x / B ) <NEWLINE> return a . astype ( int ) <NEWLINE> <NL> <DEDENT> if N < B - 1 : <NEWLINE> <INDENT> print ( f ( N ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( f ( B - 1 ) ) <NEWLINE> <DEDENT>
a , b , n = map ( int , input ( ) . split ( ) ) <NEWLINE> x = [ ] <NEWLINE> x . append ( int ( a * n / b ) <NEWLINE> if n >= b : <NEWLINE> <INDENT> x . append ( int ( a * ( b - 1 ) / b ) <NEWLINE> <DEDENT> print ( max ( x ) ) <NEWLINE>
a , b , n = map ( int , input ( ) . split ( ) ) <NEWLINE> s = n // b <NEWLINE> nmax = ( a * n ) // b - a * ( n // b ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> x = b * s - 1 <NEWLINE> t = ( a * x ) // b - a * b_nn <NEWLINE> if t > nmax : <NEWLINE> <INDENT> nmax = t <NEWLINE> <DEDENT> print ( nmax ) <NEWLINE>
def naive ( a , b , n ) : <NEWLINE> <INDENT> ans = 0 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> ans = max ( ans , int ( ( a * i ) / b ) - a * int ( i / b ) ) <NEWLINE> <DEDENT> return ans <NEWLINE> <NL> <DEDENT> def main ( a , b , n ) : <NEWLINE> <INDENT> ans = 0 <NEWLINE> tmp = [ ] <NEWLINE> for i in range ( max ( n + 1 - a * 10 - 1 , 1 ) , n + 1 ) : <NEWLINE> <INDENT> ans = max ( ans , int ( ( a * i ) / b ) - a * int ( i / b ) ) <NEWLINE> <DEDENT> return ans <NEWLINE> <NL> <NL> <DEDENT> n = 10000 <NEWLINE> for a in range ( 1 , 10 ) : <NEWLINE> <INDENT> for b in range ( 1 , 100 ) : <NEWLINE> <INDENT> if naive ( a , b , n ) != main ( a , b , n ) : <NEWLINE> <INDENT> print ( a , b , naive ( a , b , n ) , main ( a , b , n ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> a , b , n = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> print ( main ( a , b , n ) ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> import math <NEWLINE> <NL> def calcM ( A , B , x ) : <NEWLINE> <INDENT> return math . floor ( A / B * x ) - A * math . floor ( x / B ) <NEWLINE> <NL> <DEDENT> def resolve_v1 ( A , B , N ) : <NEWLINE> <INDENT> maxM = 0 <NEWLINE> for x in range ( N + 1 ) : <COMMENT> <NEWLINE> <INDENT> M = calcM ( A , B , x ) <NEWLINE> maxM = max ( maxM , M ) <NEWLINE> <NL> <DEDENT> return maxM <NEWLINE> <NL> <DEDENT> def resolve_v2 ( A , B , N ) : <NEWLINE> <COMMENT> <NL> <INDENT> maxM = calcM ( A , B , N ) <NEWLINE> <NL> for x in filter ( lambda x : ( x + 1 ) % B == 0 , range ( N + 1 ) ) : <COMMENT> <NEWLINE> <INDENT> maxM = max ( maxM , calcM ( A , B , x ) ) <NEWLINE> <DEDENT> return maxM <NEWLINE> <NL> <NL> <DEDENT> def resolve_v3 ( A , B , N ) : <NEWLINE> <INDENT> maxM = calcM ( A , B , N ) <NEWLINE> if B < N : <NEWLINE> <INDENT> max_x = max ( list ( filter ( lambda x : ( x + 1 ) % B == 0 , range ( N - B , N + 1 ) ) ) , default = N ) <NEWLINE> <COMMENT> <NL> <DEDENT> return max ( maxM , calcM ( A , B , max_x ) ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> A , B , N = map ( int , input ( ) . split ( ) ) <NEWLINE> M = resolve_v3 ( A , B , N ) <NEWLINE> print ( M ) <NEWLINE> <NL> <NL> <DEDENT>
import math <NEWLINE> <NL> A , B , N = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> a = N // B <NEWLINE> <NL> if a == 0 : <NEWLINE> <INDENT> x = N <NEWLINE> <NL> <NL> <DEDENT> elif N % B == 0 : <NEWLINE> <INDENT> x = a * B - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = B * a - 1 <NEWLINE> <NL> <DEDENT> while math . floor ( A * x / B ) == math . floor ( A * ( x - 1 ) / B ) : <NEWLINE> <INDENT> x = x - 1 <NEWLINE> if x == 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> ans = math . floor ( A * x / B ) - A * math . floor ( x / B ) <NEWLINE> ans = max ( ans ) <NEWLINE> <NL> print ( ans ) <NEWLINE>
q = min ( b - 1 , n ) <NEWLINE> ni = int ( a * q / b ) <NEWLINE> if ni > nmax : <NEWLINE> <INDENT> nmax = ni <NEWLINE> <DEDENT> print ( nmax ) <NEWLINE>
from decimal import * <NEWLINE> <NL> <NL> def target ( x ) : <NEWLINE> <INDENT> x = Decimal ( x ) <NEWLINE> return ( A * x ) . divmod ( B ) - A * ( x . divmod ( B ) ) <NEWLINE> <NL> <NL> <DEDENT> A , B , N = map ( int , input ( ) . split ( ) ) <NEWLINE> A = Decimal ( A ) <NEWLINE> B = Decimal ( B ) <NEWLINE> <NL> left = 1 <NEWLINE> right = N <NEWLINE> <NL> while right - left > 1 : <NEWLINE> <INDENT> mid = left + ( right - left ) // 2 <NEWLINE> y = target ( mid ) <NEWLINE> prv = target ( mid - 1 ) <NEWLINE> nxt = target ( mid + 1 ) <NEWLINE> if prv <= y <= nxt : <NEWLINE> <INDENT> left = mid <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> right = mid <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> print ( target ( right ) ) <NEWLINE>
A , B , N = input ( ) . split ( ) <NEWLINE> A = float ( A ) <NEWLINE> B = float ( B ) <NEWLINE> N = float ( N ) <NEWLINE> import math <NEWLINE> value = math . floor ( A * ( B - 1 ) / B ) <NEWLINE> max = 0 <NEWLINE> for i in range ( B ) : <NEWLINE> <INDENT> a = int ( math . floor ( A * x / B ) - A * math . floor ( x / B ) ) <NEWLINE> if a > max : <NEWLINE> <INDENT> max = a <NEWLINE> <DEDENT> <DEDENT> if N < B - 1 : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( value ) <NEWLINE> <DEDENT>
a , b , n = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> x = min ( b . n ) <NEWLINE> print ( int ( a * x / b ) ) <NEWLINE>
A , B , N = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> p = min ( N , B ) <NEWLINE> if p % B == 0 : <NEWLINE> <INDENT> print ( int ( A ( p - 1 ) / B ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( int ( A ( p ) / B ) ) <NEWLINE> <DEDENT>
a , b , n = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( math . floor ( a * min ( ( b - 1 ) , n ) / b ) ) <NEWLINE>
import math <NEWLINE> x = int ( input ( ) ) <NEWLINE> m = 100 <NEWLINE> count = 0 <NEWLINE> while ( m < x ) : <NEWLINE> <INDENT> m += math . floor ( m / 100 ) <NEWLINE> count += 1 <NEWLINE> <DEDENT> print ( count ) <NEWLINE>
<COMMENT> <NL> <NL> from fractions import gcd <NEWLINE> from collections import Counter , deque , defaultdict <NEWLINE> from heapq import heappush , heappop , heappushpop , heapify , heapreplace , merge <NEWLINE> from bisect import bisect_left , bisect_right , bisect , insort_left , insort_right , insort <NEWLINE> from itertools import accumulate , product , permutations , combinations <NEWLINE> <NL> A , B , N = [ int ( _ ) for _ in input ( ) . split ( ) ] <NEWLINE> <NL> def floor ( t ) : <NEWLINE> <INDENT> return t // 1 <NEWLINE> <NL> <DEDENT> ma = 0 <NEWLINE> x = 0 <NEWLINE> a_b = A / B <NEWLINE> <NL> while True : <NEWLINE> <INDENT> if x > N : break <NEWLINE> a = floor ( a_b * x ) - A * floor ( x / B ) <NEWLINE> x += 1 <NEWLINE> if a > ma : <NEWLINE> <INDENT> ma = a <NEWLINE> <NL> <DEDENT> <DEDENT> print ( int ( ma ) ) <NEWLINE>
a , b , n = map ( int , input ( ) . split ( ) ) <NEWLINE> x = ( b - 1 , n ) <NEWLINE> print ( int ( a * x / b ) ) <NEWLINE>
import sys <NEWLINE> import numpy as np <NEWLINE> import re <NEWLINE> from collections import deque , defaultdict , Counter <NEWLINE> from math import ceil , sqrt , hypot , factorial , pi , sin , cos , radians <NEWLINE> from itertools import accumulate , permutations , combinations , product <NEWLINE> from operator import itemgetter , mul <NEWLINE> from copy import deepcopy <NEWLINE> from string import ascii_lowercase , ascii_uppercase , digits <NEWLINE> from bisect import bisect , bisect_left <NEWLINE> from fractions import gcd <NEWLINE> from heapq import heappush , heappop <NEWLINE> from functools import reduce <NEWLINE> def input ( ) : return sys . stdin . readline ( ) . strip ( ) <NEWLINE> def INT ( ) : return int ( input ( ) ) <NEWLINE> def MAP ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def LIST ( ) : return list ( map ( str , input ( ) . split ( ) ) ) <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> INF = float ( <STRING> ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> import math <NEWLINE> <NL> <NL> A , B , N = MAP ( ) <NEWLINE> <NL> <NL> def f ( x , A , B ) : <NEWLINE> <INDENT> return math . floor ( A * x / B ) - A * math . floor ( x / B ) <NEWLINE> <NL> <NL> <DEDENT> x = 0 <NEWLINE> flag = 0 <NEWLINE> while True : <NEWLINE> <INDENT> if f ( x , A , B ) > 0 : <NEWLINE> <INDENT> flag = 1 <NEWLINE> <DEDENT> if f ( x , A , B ) == 0 : <NEWLINE> <INDENT> y = x - 1 <NEWLINE> if flag == 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> x += 1 <NEWLINE> <NL> <DEDENT> if N < y : <NEWLINE> <INDENT> print ( f ( N , A , B ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( f ( y , A , B ) ) <NEWLINE> <DEDENT>
a , b , n = map ( int , input ( ) . split ( ) ) <NEWLINE> max = 0 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if a % b * i % b != 0 : <NEWLINE> <INDENT> if a % b * i % b < a % b <NEWLINE> <INDENT> ans = a * i // b - a * ( i // b ) <NEWLINE> if max < ans : <NEWLINE> <INDENT> max = ans <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( max ) <NEWLINE>
import math <NEWLINE> <NL> A , B , N = map ( int , input ( ) . split ( ) ) <NEWLINE> x = max ( B - 1 , N ) <NEWLINE> print ( math . floor ( ( A * x ) / B ) - A * ( x // B ) <NEWLINE>
A = int ( input ( ) ) <NEWLINE> B = int ( input ( ) ) <NEWLINE> N = int ( input ( ) ) <NEWLINE> print ( int ( A * ( N - 1 ) / B ) - A * int ( ( N - 1 ) / B ) ) <NEWLINE>
A , B , N = map ( int , input ( ) . split ( ) ) <NEWLINE> Y = A * x // B - A * ( x // B ) <NEWLINE> print ( Y ) <NEWLINE>
A , B , N = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> def floor ( x ) : <NEWLINE> <INDENT> out = ( A * x ) // B - A * ( x // B ) <NEWLINE> return out <NEWLINE> <NL> <DEDENT> max = 0 <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> max = max ( floor ( N ) , floor ( B - 1 ) ) <NEWLINE> <NL> print ( max ) <NEWLINE> <NL>
import math <NEWLINE> A , B , N = map ( int , input ( ) . split ( ) ) <NEWLINE> s = math . floor ( ( A * ( B - 1 ) ) / B ) ) <NEWLINE> t = math . floor ( ( A * N ) / B ) ) <NEWLINE> print ( max ( s , t ) ) <NEWLINE>
<COMMENT> <NL> <INDENT> import sys <NEWLINE> import math <NEWLINE> <NL> def solve ( A : int , B : int , N : int ) : <NEWLINE> <NL> <INDENT> x = min ( B - 1 , N ) <NEWLINE> print ( math . floor ( A * x / B ) - A * math . floor ( x / B ) ) <NEWLINE> <NL> return <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> def iterate_tokens ( ) : <NEWLINE> <INDENT> for line in sys . stdin : <NEWLINE> <INDENT> for word in line . split ( ) : <NEWLINE> <INDENT> yield word <NEWLINE> <DEDENT> <DEDENT> <DEDENT> tokens = iterate_tokens ( ) <NEWLINE> A = int ( next ( tokens ) ) <COMMENT> <NEWLINE> B = int ( next ( tokens ) ) <COMMENT> <NEWLINE> N = int ( next ( tokens ) ) <COMMENT> <NEWLINE> solve ( A , B , N ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT> <DEDENT>
from collections import deque <NEWLINE> n , m , q = map ( int , input ( ) . split ( ) ) <NEWLINE> l = list ( list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( q ) ) <NEWLINE> if m < 7 : <NEWLINE> <INDENT> num = [ <STRING> * n ] <NEWLINE> k = deque ( [ <STRING> * n ] ) <NEWLINE> while len ( k ) != 0 : <NEWLINE> <INDENT> h = k . popleft ( ) <NEWLINE> if int ( h [ - 1 ] ) < m : <NEWLINE> <INDENT> num . append ( str ( int ( h ) + 1 ) ) <NEWLINE> num . append ( str ( int ( h ) + 11 ) ) <NEWLINE> num . append ( str ( int ( h ) + 111 ) ) <NEWLINE> k . append ( str ( int ( h ) + 1 ) ) <NEWLINE> k . append ( str ( int ( h ) + 11 ) ) <NEWLINE> k . append ( str ( int ( h ) + 111 ) ) <NEWLINE> <DEDENT> <DEDENT> num = list ( set ( num ) ) <NEWLINE> ma = 0 <NEWLINE> for i in num : <NEWLINE> <INDENT> s = 0 <NEWLINE> for a , b , c , d in l : <NEWLINE> <INDENT> if int ( i [ b - 1 ] ) - int ( i [ a - 1 ] ) == c : <NEWLINE> <INDENT> s += d <NEWLINE> ma = max ( ma , s ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ma ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> l1 = sorted ( l , key = lambda x : x [ 3 ] ) [ : : - 1 ] <NEWLINE> print ( l1 [ 0 ] [ - 1 ] ) <NEWLINE> <DEDENT>
solved_flag = False <NEWLINE> if B == 1 : <NEWLINE> <INDENT> ans = 0 <NEWLINE> solved_flag = True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if B <= N : <NEWLINE> <INDENT> x = B - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = N <NEWLINE> <NL> <DEDENT> <DEDENT> if not solved_flag : <NEWLINE> <INDENT> ans = math . floor ( A * x / B ) - A * math . floor ( x / B ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
def f ( a , b , x ) : <NEWLINE> <INDENT> return int ( a * x / b ) - ( a * int ( x / b ) ) <NEWLINE> <DEDENT> A , B , N = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( f ( A , B , min ( B - 1 , N ) ) <NEWLINE>
a , b , n = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( a * ( b - 1 ) // b ) ) <NEWLINE>
import sys <NEWLINE> import math <NEWLINE> <NL> lines = sys . stdin . readlines ( ) <NEWLINE> <NL> X = lines [ 0 ] . split ( <STRING> ) <NEWLINE> A = int ( X [ 0 ] ) <NEWLINE> B = int ( X [ 1 ] ) <NEWLINE> N = int ( X [ 2 ] ) <NEWLINE> <NL> m = A // B <NEWLINE> j = A % B <NEWLINE> <NL> if N >= B - 1 : <NEWLINE> <INDENT> print ( m * ( B - 1 ) - 1 + j ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> k = B - N <NEWLINE> print ( max ( 0 , j + m * N - math . ceil ( j * k / B ) ) <NEWLINE> <DEDENT>
import math <NEWLINE> a , b , n = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <NL> def calc ( a , b , n ) : <NEWLINE> <INDENT> return int ( math . floor ( ( a * n ) / b ) - ( a * math . floor ( n / b ) ) ) <NEWLINE> <NL> <DEDENT> nn = min ( n , b - 1 ) <NEWLINE> print ( calc ( a , b , nn ) <NEWLINE>
import math <NEWLINE> <NL> A , B , N = ( int ( x ) for x in input ( ) . split ( ) ) <NEWLINE> <COMMENT> <NL> x = B - 1 <NEWLINE> if N < B <NEWLINE> <INDENT> x = N <NEWLINE> <DEDENT> a = math . floor ( A * x / B ) - A * math . floor ( x / B ) <NEWLINE> b = math . floor ( A * N / B ) - A * math . floor ( N / B ) <NEWLINE> <NL> if a > b : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( b ) <NEWLINE> <DEDENT>
<NL> A , B , N = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> x = min ( B - 1 , N ) <NEWLINE> ans = int ( a * x / b ) <NEWLINE> print ( ans ) <NEWLINE>
A , B , N = ( int ( i ) for i in input ( ) . split ( ) ) <NEWLINE> max_num = - 10 ** 100 <NEWLINE> tmp_num = 0 <NEWLINE> cnt = 1 <NEWLINE> flg = False <NEWLINE> while flg == False : <NEWLINE> <INDENT> tmp_num = math . floor ( A * cnt / B ) - A * math . floor ( cnt / B ) <NEWLINE> <COMMENT> <NL> if tmp_num > max_num : <NEWLINE> <INDENT> max_num = tmp_num <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> flg = True <NEWLINE> <DEDENT> <DEDENT> print ( max_num ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> import math <NEWLINE> line = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A , B , N = line [ 0 ] , line [ 1 ] , line [ 2 ] <NEWLINE> <NL> ans = ( N + 1 ) // B <NEWLINE> if ans == 0 : <NEWLINE> <INDENT> print ( math . floor ( A * N / B ) - A * ( i - 1 ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> start = ( math . floor ( A * N / B ) - A * math . floor ( N / B ) ) <NEWLINE> for i in range ( 1 , ans + 1 ) : <NEWLINE> <INDENT> x = i * B - 1 <NEWLINE> start = max ( ( math . floor ( A * x / B ) - A * ( i - 1 ) ) , start ) <NEWLINE> <DEDENT> print ( start ) <NEWLINE> <DEDENT>
import math <NEWLINE> <NL> A , B , N = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> i = 1 <NEWLINE> maxnum = 1 <NEWLINE> while i <= N : <NEWLINE> <INDENT> if ( math . floor ( A * ( i - 1 ) // B ) - A * ( ( i - 1 ) // B ) ) < math . floor ( ( A * ( i ) // B ) - A * ( ( i ) // B ) ) : <NEWLINE> <INDENT> maxnum = math . floor ( ( A * ( i ) // B ) - A * ( ( i ) // B ) ) <NEWLINE> i = i + 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( maxnum ) <NEWLINE>
from collections import defaultdict , deque <NEWLINE> from heapq import heappush , heappop <NEWLINE> from itertools import permutations , accumulate , combinations_with_replacement , compress <NEWLINE> import sys <NEWLINE> import math <NEWLINE> import bisect <NEWLINE> <NL> <NL> def LI ( ) : return [ int ( x ) for x in sys . stdin . readline ( ) . split ( ) ] <NEWLINE> <NL> <NL> def I ( ) : return int ( sys . stdin . readline ( ) ) <NEWLINE> <NL> <NL> def LS ( ) : return [ list ( x ) for x in sys . stdin . readline ( ) . split ( ) ] <NEWLINE> <NL> <NL> def S ( ) : <NEWLINE> <INDENT> res = list ( sys . stdin . readline ( ) ) <NEWLINE> if res [ - 1 ] == <STRING> : <NEWLINE> <INDENT> return res [ : - 1 ] <NEWLINE> <DEDENT> return res <NEWLINE> <NL> <NL> <DEDENT> def IR ( n ) : <NEWLINE> <INDENT> return [ I ( ) for i in range ( n ) ] <NEWLINE> <NL> <NL> <DEDENT> def LIR ( n ) : <NEWLINE> <INDENT> return [ LI ( ) for i in range ( n ) ] <NEWLINE> <NL> <NL> <DEDENT> def SR ( n ) : <NEWLINE> <INDENT> return [ S ( ) for i in range ( n ) ] <NEWLINE> <NL> <NL> <DEDENT> def LSR ( n ) : <NEWLINE> <INDENT> return [ LS ( ) for i in range ( n ) ] <NEWLINE> <NL> <NL> <DEDENT> sys . setrecursionlimit ( 1000000 ) <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> N , M , Q = LI ( ) <NEWLINE> abcd = [ LI ( ) for _ in range ( Q ) ] <NEWLINE> ans = 0 <NEWLINE> <NL> for A in combinations_with_replacement ( range ( 1 , M + 1 ) , N ) : <NEWLINE> <INDENT> tmp = 0 <NEWLINE> for ( a , b , c , d ) in abcd : <NEWLINE> <INDENT> tmp += d if ( A [ b - 1 ] - A [ a - 1 ] == c ) else 0 <NEWLINE> <DEDENT> ans = max ( ans , tmp ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> main ( ) <NEWLINE>
a , b , n = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> x = min ( b - 1 , n ) <NEWLINE> answer = floor ( a * x / b ) - a * floor ( x / b ) <NEWLINE> print ( answer ) <NEWLINE>
a , b , n = map ( int , input ( ) . split ( ) ) <NEWLINE> val = max ( 0 , ( a * n ) // b - a * ( n // b ) , ( a * m ) // b - a * ( m // b ) , ( n // b ) * b - 1 ) <NEWLINE> print ( val ) <NEWLINE>
a , b , n = map ( int , input ( ) . split ( ) ) <NEWLINE> x = 0 <NEWLINE> if n > b : <NEWLINE> <INDENT> x = b <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = n <NEWLINE> <DEDENT> ans1 = int ( a * x / b ) - a * int ( x / b ) <NEWLINE> print ( ans2 ) <NEWLINE>
A , B , N = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> mx = 0 <NEWLINE> <NL> if N < B : <NEWLINE> <INDENT> print ( A * N ) // B <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = ( N // B ) * B - 1 <NEWLINE> print ( ( A * x ) // B - A * ( x // B ) ) <NEWLINE> <DEDENT>
import math <NEWLINE> a , b , n = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> y = b - 1 <NEWLINE> if x < n : <NEWLINE> <INDENT> x = y <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = n <NEWLINE> <NL> <DEDENT> print ( math . floor ( a * x / b ) ) <NEWLINE>
A , B , N = map ( int , input ( ) . split ( ) ) <NEWLINE> x = min ( N , B - 1 ) <NEWLINE> return A * x // B - A * ( x // B ) <NEWLINE>
import math <NEWLINE> a , b , n = map ( int , input ( ) . split ( ) ) <NEWLINE> if b > n : <NEWLINE> <INDENT> print ( math . floor ( a * n / b ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = b - 1 <NEWLINE> print ( math . floor ( a * x / b ) ) <NEWLINE> <DEDENT>
a , b , n = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> x = math . floor ( a * n / b ) - ( a * math . floor ( n / b ) ) <NEWLINE> y = math . floor ( a * b / b ) - ( a * math . floor ( b / b ) ) <NEWLINE> z = math . floor ( a * ( b - 1 ) / b ) - ( a * math . floor ( ( b - 1 ) / b ) ) <NEWLINE> <NL> if b == 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> elif n < b : <NEWLINE> <INDENT> print ( x ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( z ) <NEWLINE> <DEDENT>
A , B , X = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( min ( B - 1 , N ) ) <NEWLINE>
A , B , N = map ( int , input ( ) . split ( ) ) <NEWLINE> S = 0 <NEWLINE> n = N // B <NEWLINE> r = N % B <NEWLINE> if B > N : <NEWLINE> <INDENT> S = ( A * N ) // B <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if r == 0 : <NEWLINE> <INDENT> S = ( A * ( N - 1 ) ) // B - A * ( ( N - 1 ) // B ) ) <NEWLINE> <DEDENT> elif r == B - 1 : <NEWLINE> <INDENT> S = ( A * N ) // B - A * ( N // B ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> S = ( A * ( n * B - 1 ) ) // B - A * ( ( n * B - 1 ) // B ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( S ) <NEWLINE>
a . b . x = map ( int , input ( ) . split ( ) ) <NEWLINE> def f ( x ) : <NEWLINE> <INDENT> return ( a * x ) // b - a * ( x // b ) <NEWLINE> <NL> <DEDENT> print ( f ( min ( b - 1 , n ) ) <NEWLINE>
import math <NEWLINE> A , B , N = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = [ ] <NEWLINE> for x in range ( 0 , 10 ** 3 ) : <NEWLINE> <INDENT> cal = math . floor ( ( A * x ) / B ) - ( int ( A ) * math . floor ( x / B ) ) <NEWLINE> ans . append ( cal ) <NEWLINE> <DEDENT> for x in range ( N - 10 ** 7 , N + 1 ) : <NEWLINE> <INDENT> cal = math . floor ( ( A * x ) / B ) - ( int ( A ) * math . floor ( x / B ) ) <NEWLINE> ans . append ( cal ) <NEWLINE> <DEDENT> print ( max ( ans ) ) <NEWLINE>
A , B , N = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> max - int ( a * min ( B - 1 , N ) / B ) <NEWLINE> print ( max ) <NEWLINE> ~ <NEWLINE>
<COMMENT> <NL> <NL> import math <NEWLINE> <COMMENT> <NL> input_1 = input ( ) <NEWLINE> a = int ( input_1 . split ( <STRING> ) [ 0 ] ) <NEWLINE> b = int ( input_1 . split ( <STRING> ) [ 1 ] ) <NEWLINE> n = int ( input_1 . split ( <STRING> ) [ 2 ] ) <NEWLINE> <NL> <NL> <COMMENT> <NL> score = math . floor ( a / b * math . min ( b - 1 , n ) ) <NEWLINE> print ( score ) <NEWLINE>
import math <NEWLINE> a , b , n = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if b = < n : <NEWLINE> <INDENT> k = math . floor ( n / b ) <NEWLINE> ans = max ( math . floor ( a * ( b - 1 ) / b ) , math . floor ( a * n / b ) - a * math . floor ( n / b ) , math . floor ( a * ( k * b - 1 ) / b ) - a * math . floor ( ( k * b - 1 ) / b ) ) <NEWLINE> print ( ans ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( math . floor ( a * n / b ) ) <NEWLINE> <DEDENT>
n , m , q = map ( int , input ( ) . strip ( ) . split ( ) ) <NEWLINE> L = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( q ) ] <NEWLINE> <NL> possibleA = [ [ i ] * n for i in range ( 1 , m + 1 ) ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( i + 1 , m + 1 ) : <NEWLINE> <NL> <NL> <DEDENT> import math <NEWLINE> a , b , n = map ( int , input ( ) . strip ( ) . split ( ) ) <NEWLINE> if b < n : <NEWLINE> <INDENT> x = n <NEWLINE> <DEDENT> elif n % b <= n % ( b / a ) : <NEWLINE> <INDENT> x = n - n % b - 1 <NEWLINE> <DEDENT> elif ( n % b - n % ( b / a ) + 1 ) // ( b / a ) > a * b : <NEWLINE> <INDENT> x = n - n % b - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = n <NEWLINE> <DEDENT> print ( math . floor ( a * x / b ) - a * math . floor ( x / b ) ) <NEWLINE>
import math <NEWLINE> A , B , N = map ( float , input ( ) . split ( ) ) <NEWLINE> if N = B : <NEWLINE> <INDENT> N = N - 1 <NEWLINE> <DEDENT> ans = math . floor ( ( A * N / B ) ) - A * math . floor ( N / B ) <NEWLINE> print ( int ( ans ) ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> a , b , n = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> def num ( x ) : <NEWLINE> <INDENT> return ( a * x ) // b - a * ( x // b ) <NEWLINE> <NL> <DEDENT> ma = num ( 1 ) <NEWLINE> <NL> for i in range ( 2 , n + 1 ) : <NEWLINE> <INDENT> if num ( i ) > ma : <NEWLINE> <INDENT> ma = num ( i ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if num ( i ) >= num ( i - 1 ) : <NEWLINE> print ( ma ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( ma ) <NEWLINE>
<COMMENT> <NL> a , b , n = map ( int , input ( ) . split ( ) ) <NEWLINE> if n >= b : <NEWLINE> <INDENT> n = b - 1 <NEWLINE> print ( int ( a * n / b ) - ( a * n / b ) ) <NEWLINE> exit ( ) : <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( int ( a * n / b ) ) <NEWLINE> exit ( ) : <NEWLINE> <DEDENT>
import math <NEWLINE> a , b , n = map ( int , input ( ) . split ( ) ) <NEWLINE> <COMMENT> <NL> <NL> <COMMENT> <NL> ans = ( math . floor ( ( a * ( n ) ) / b ) - ( a * math . floor ( n / b ) ) ) <NEWLINE> <NL> <NL> <COMMENT> <NL> if max ( li ) > n : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( max ( li ) ) <NEWLINE> <DEDENT>
import math <NEWLINE> def equation ( a , b , n ) : <NEWLINE> <INDENT> return math . floor ( ( a * x ) / b ) - A * math . floor ( x / B ) <NEWLINE> <DEDENT> d , e , f = map ( int , input ( ) . split ( ) ) <NEWLINE> X = equation ( d , e , f ) <NEWLINE> Y = equation ( d , e , e - 1 ) <NEWLINE> print ( max ( X , Y ) ) <NEWLINE>
a , b , n = map ( int , input ( ) . split ( ) ) <NEWLINE> val = ( a * n ) // b - a * ( n // b ) <NEWLINE> val = max ( val , ( a * m ) // b - a * ( m // b ) ) <NEWLINE> print ( val ) <NEWLINE>
<COMMENT> <NL> <NL> int main ( void ) { <NEWLINE> <INDENT> long long int a , b , n ; <NEWLINE> scanf ( <STRING> , & a , & b , & n ) ; <NEWLINE> printf ( <STRING> , ( a * ( n - 1 ) ) / b - a * ( ( n - 1 ) / b ) ) ; <NEWLINE> return 0 ; <NEWLINE> <DEDENT> } <NEWLINE>
<NL> def resolve ( ) : <NEWLINE> <INDENT> def f ( x ) : <NEWLINE> <INDENT> res = ( A * x ) // B - A * ( x // B ) <NEWLINE> return res <NEWLINE> <NL> <DEDENT> A , B , N = map ( int , input ( ) . split ( ) ) <NEWLINE> x = min ( B - 1 , N ) <NEWLINE> print ( f ( x ) ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> resolve ( ) : <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> a , b , n = map ( int , input ( ) . split ( ) ) <NEWLINE> if b > n : <NEWLINE> <INDENT> print ( int ( a * ( n / b - n // b ) ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( int ( a * ( ( b - 1 ) / b ) ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import math <NEWLINE> <NL> A , B , N = tuple ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> m = 0 <NEWLINE> n = 1 <NEWLINE> <NL> def cal ( x ) : <NEWLINE> <INDENT> return math . floor ( A * x / B ) - A * math . floor ( x / B ) <NEWLINE> <NL> <DEDENT> while n < N : <NEWLINE> <INDENT> c = B * ( math . floor ( ( n + 1 ) / B ) + 1 ) - 1 <NEWLINE> n = min ( N , c ) <NEWLINE> m = max ( cal ( n ) , m ) <NEWLINE> if ( A * x ) % B == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( m ) <NEWLINE>
A , B , N = map ( int , input ( ) . split ( ) ) <NEWLINE> if N >= B - 1 : <NEWLINE> <INDENT> print ( int ( A * ( B - 1 ) / B ) - A * int ( ( B - 1 ) / B ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( int ( A * N / B ) ) - A * int ( N / B ) <NEWLINE> <DEDENT>
A , B , N = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> def f ( x ) : <NEWLINE> <INDENT> return int ( A * x / B ) - A * int ( x / B ) <NEWLINE> <NL> <DEDENT> X = N <NEWLINE> Y = min ( B - 1 , N ) <NEWLINE> <NL> print ( min ( f ( X ) , f ( Y ) ) <NEWLINE>
A , B , N = [ int ( v ) for v in input ( ) . strip ( ) . spilt ( <STRING> ) ] <NEWLINE> <NL> if N < B : <NEWLINE> <INDENT> print ( int ( A * N * B ) - A * int ( N / B ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( int ( A * ( B - 1 ) * B ) - A * int ( ( B - 1 ) / B ) ) <NEWLINE> <DEDENT>
a , b , x = map ( int , input ( ) ) <NEWLINE> print ( a * ( b - 1 ) // b ) <NEWLINE>
import sys , bisect , math , itertools , string , queue , copy <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> from collections import Counter , defaultdict , deque <NEWLINE> from itertools import permutations , combinations <NEWLINE> from heapq import heappop , heappush <NEWLINE> from fractions import gcd <NEWLINE> <COMMENT> <NL> sys . setrecursionlimit ( 10 ** 8 ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> def inp ( ) : return int ( input ( ) ) <NEWLINE> def inpm ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def inpl ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> def inpls ( ) : return list ( input ( ) . split ( ) ) <NEWLINE> def inplm ( n ) : return list ( int ( input ( ) ) for _ in range ( n ) ) <NEWLINE> def inplL ( n ) : return [ list ( input ( ) ) for _ in range ( n ) ] <NEWLINE> def inplT ( n ) : return [ tuple ( input ( ) ) for _ in range ( n ) ] <NEWLINE> def inpll ( n ) : return [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ] <NEWLINE> def inplls ( n ) : return sorted ( [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ] ) <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> a , b , n = inpm ( ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( min ( b + 1 , n + 1 ) ) : <NEWLINE> <INDENT> ans = max ( ans , int ( a * i / b ) - a * int ( i / b ) ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
a , b , n = map ( int , input ( ) . split ( ) ) <NEWLINE> x = min ( b - 1 , n ) <NEWLINE> ans = max ( int ( ( a * x ) / b ) - a * int ( x / b ) ) <NEWLINE> print ( ans ) <NEWLINE>
A , B , N = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> tmp = 0 <NEWLINE> a = 0 <NEWLINE> i = 0 <NEWLINE> <NL> if B > A : <NEWLINE> <INDENT> for i in range ( B - 1 , N + 1 , B ) : <NEWLINE> <INDENT> if ( s : = ( A * i ) // B - A * ( a ) ) > 0 : <NEWLINE> <INDENT> tmp = max ( s , tmp ) <NEWLINE> <DEDENT> else : <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if i >= N - B : <NEWLINE> <INDENT> for i in range ( N , N - N % B - 2 , - 1 ) : <NEWLINE> <INDENT> if ( s : = ( A * i ) // B - A * ( i // B ) ) > 0 : <NEWLINE> <INDENT> tmp = max ( s , tmp ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( tmp ) <NEWLINE>
import math <NEWLINE> A , B , N = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> for i in range ( N + 1 ) : <NEWLINE> <INDENT> num = math . floor ( A * i / B ) - A * math . floor ( i / B ) <NEWLINE> if num > maxnum : <NEWLINE> <INDENT> maxnum = num <NEWLINE> <DEDENT> print ( str ( i ) + <STRING> + str ( num ) + <STRING> + str ( maxnum ) ) <NEWLINE> <DEDENT> print ( maxnum ) <NEWLINE>
a , b , n = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> x = 0 <NEWLINE> ans = 0 <NEWLINE> if n < b : <NEWLINE> <INDENT> x = n <NEWLINE> ans = math . floor ( a * x / b ) - a * math . floor ( x / b ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = n - 1 <NEWLINE> ans = math . floor ( a * x / b ) - a * math . floor ( x / b ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> a , b , n = map ( int , input ( ) . split ( ) ) <NEWLINE> l = gcd ( a , b ) <NEWLINE> print ( a * min ( n , ( b - 1 ) ) // b - a * ( min ( b - 1 , n ) // b ) ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
A , B , N = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ma = 0 <NEWLINE> for i in range ( min ( N , B ) + 1 , 1 ) : <NEWLINE> <INDENT> a = int ( A * i / B ) - A * int ( i / B ) <NEWLINE> if ( a <= A ) : <NEWLINE> <INDENT> if ( ma < a ) : <NEWLINE> <INDENT> ma = a <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ma ) <NEWLINE>
import sys <NEWLINE> from math import sqrt , floor <NEWLINE> <NL> input = sys . stdin . readline <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> <NL> <NL> def I ( ) : <NEWLINE> <INDENT> return int ( input ( ) ) <NEWLINE> <NL> <NL> <DEDENT> def MI ( ) : <NEWLINE> <INDENT> return map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> a , b , n = MI ( ) <NEWLINE> <NL> if b - 1 <= n : <NEWLINE> <INDENT> print ( ( a * ( b - 1 ) ) // b ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ( a * n ) // b ) ) <COMMENT> <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
A , B , N = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <COMMENT> <NL> <NL> r = N if N < B else r = B - 1 <NEWLINE> <NL> print ( A * r // B ) <NEWLINE>
import math <NEWLINE> def func ( i ) : <NEWLINE> <INDENT> return math . floor ( a * i * 1.0 / b ) - a * math . floor ( i * 1.0 / b ) ; <NEWLINE> <NL> <DEDENT> a , b , n = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> print ( max ( func ( b ) , func ( n ) ) <NEWLINE>
import math <NEWLINE> <NL> a , b , n = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if b <= 10 ** 6 <NEWLINE> <INDENT> maxVal = 0 <NEWLINE> <NL> for i in range ( b ) : <NEWLINE> <INDENT> if i > n : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> val = math . floor ( a * i / b ) - a * math . floor ( i / b ) <NEWLINE> if val > maxVal : <NEWLINE> <INDENT> maxVal = val <NEWLINE> <NL> <DEDENT> <DEDENT> print ( maxVal ) <NEWLINE> <DEDENT> elif n > b : <NEWLINE> <INDENT> print ( a - 1 ) <NEWLINE> <DEDENT> elif n == b : <NEWLINE> <INDENT> m = n - 1 <NEWLINE> print ( math . floor ( a * m / b ) - a * math . floor ( m / b ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( math . floor ( a * n / b ) - a * math . floor ( n / b ) ) <NEWLINE> <DEDENT>
temp = list ( map ( int , input ( ) . rstrip ( ) . split ( ) ) ) <NEWLINE> a = temp [ 0 ] <NEWLINE> b = temp [ 1 ] <NEWLINE> n = temp [ 2 ] <NEWLINE> if ( b - 1 ) < n : <NEWLINE> <INDENT> x = ( b - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = n <NEWLINE> <DEDENT> v = ( ( a * x ) // b ) - ( a * ( x // b ) ) <NEWLINE> print v <NEWLINE> <NL>
import math <NEWLINE> a , b , n = map ( int , input ( ) . split ( ) ) <NEWLINE> c = max ( 0 , n // b * b - 1 ) <NEWLINE> ans = mmath . floor ( a * n / b ) - a * math . floor ( n / b ) <NEWLINE> <NL> print ( ans ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> a , b , n = map ( int , input ( ) . split ( ) ) <NEWLINE> aa = min ( b , n ) <NEWLINE> for i in range ( aa , n ) : <NEWLINE> <NL> <INDENT> ans = max ( ans , a * aa // b - a * ( aa // b ) ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
a , b , n = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ ] <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> a . append ( int ( a * i / b ) - 5 * int ( i / b ) ) <NEWLINE> <DEDENT> print ( max ( a ) ) <NEWLINE>
import math <NEWLINE> import collections <NEWLINE> def f ( a , b , x ) : <NEWLINE> <INDENT> return math . floor ( ( a * x ) / b ) - a * math . floor ( x / b ) <NEWLINE> <DEDENT> a , b , n = map ( int , input ( ) . split ( ) ) <NEWLINE> dd = collections . defaultdict ( int ) <NEWLINE> <NL> print ( f ( a , b , min ( b - 1 , x ) ) ) <NEWLINE>
import math <NEWLINE> A , B , N = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> if B > N : <NEWLINE> <INDENT> print ( math . floor ( A * i / B ) - A * math . floor ( i / B ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( math . floor ( A * ( B - 1 ) / B ) ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> import sys <NEWLINE> def input ( ) : return sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> if n % 2 == 0 <NEWLINE> <INDENT> for i in range ( m ) : <NEWLINE> <INDENT> print ( n // 2 - i , n // 2 + i ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( m ) : <NEWLINE> <INDENT> print ( n // 2 - i , n // 2 + i + 2 ) <NEWLINE> <NL> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n , m = [ int ( _ ) for _ in input ( ) ] <NEWLINE> m1 = n // 2 <NEWLINE> for i in range ( min ( m1 // 2 , m ) ) : <NEWLINE> <INDENT> print ( i + 1 , m1 - i ) <NEWLINE> <DEDENT> if m > m1 : <NEWLINE> <INDENT> for i in range ( m - m1 ) : <NEWLINE> <INDENT> print ( m1 + i + 1 , m1 * 2 - i - 1 ) <NEWLINE> <DEDENT> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> N = 2 * m + 1 <NEWLINE> if m % 2 == 0 : <NEWLINE> <INDENT> for i in range ( m // 2 ) : <NEWLINE> <INDENT> print ( i + 1 , m + 1 - i ) <NEWLINE> print ( m + 2 + i , N - i ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( m // 2 ) : <NEWLINE> <INDENT> print ( i + 1 , m - i ) <NEWLINE> print ( m + 1 + i , N - i ) <NEWLINE> <DEDENT> print ( m + 1 + i + 1 , N - i - 1 ) <NEWLINE> <DEDENT>
def resolve ( ) : <NEWLINE> <INDENT> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> print ( str ( N // 2 - i ) + <STRING> + str ( N // 2 + 1 + i ) ) <NEWLINE> <DEDENT> <DEDENT> resolve ( ) : <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> if m % 2 b == 1 : <NEWLINE> <INDENT> for i in range ( m ) : <NEWLINE> <INDENT> print ( str ( i + 1 ) + <STRING> + str ( 2 * m - i ) ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( m / 2 ) : <NEWLINE> <INDENT> print ( str ( i + 1 ) + <STRING> + str ( m - i + 1 ) ) <NEWLINE> <DEDENT> for i in range ( m / 2 ) : <NEWLINE> <INDENT> print ( str ( i + m + 2 ) + <STRING> + str ( 2 * m - i + 1 ) ) <NEWLINE> <DEDENT> <DEDENT>
from sys import stdin <NEWLINE> import sys <NEWLINE> import math <NEWLINE> from functools import reduce <NEWLINE> import functools <NEWLINE> import itertools <NEWLINE> from collections import deque , Counter <NEWLINE> from operator import mul <NEWLINE> import copy <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> import heapq <NEWLINE> <NL> n , m = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if n % 2 == 1 : <NEWLINE> <INDENT> for i in range ( 1 , m + 1 ) : <NEWLINE> <INDENT> print ( i , n - i + 1 ) <NEWLINE> <DEDENT> sys . exit ( ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> a = [ 0 ] * n <NEWLINE> i = 0 <NEWLINE> j = 1 <NEWLINE> while True : <NEWLINE> <INDENT> if a [ i % n ] == 0 and a [ ( i + j ) % n ] == 0 : <NEWLINE> <INDENT> a [ i % n ] = 1 <NEWLINE> a [ ( i + j ) % n ] = 1 <NEWLINE> print ( ( i % n ) + 1 , ( ( i + j ) % n ) + 1 ) <NEWLINE> j = j + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> i = i + 1 <NEWLINE> <NL> <DEDENT> if len ( a ) == m : sys . exit ( ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT>
n , m = map ( int , input . split ( ) ) <NEWLINE> if n % 2 == 0 : <NEWLINE> <INDENT> counter = 0 <NEWLINE> for i in range ( min ( m , n // 4 ) ) : <NEWLINE> <INDENT> print ( i + 1 ) <NEWLINE> print ( n - i ) <NEWLINE> counter += 1 <NEWLINE> <DEDENT> if counter < m : <NEWLINE> <INDENT> for i in range ( n // 4 , m ) : <NEWLINE> <INDENT> print ( i + 1 ) <NEWLINE> print ( n - i - 1 ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( m ) : <NEWLINE> <INDENT> print ( i + 1 ) <NEWLINE> print ( n - i ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> if i % 2 == 0 : <NEWLINE> <INDENT> j = i // 2 <NEWLINE> print ( <STRING> . format ( 1 + j , M + 1 - j ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> j = i // 2 <NEWLINE> print ( <STRING> . format ( M + 2 + i , 2 M + 1 - i ) ) <NEWLINE> <DEDENT> <DEDENT>
<INDENT> print ( a , b ) <NEWLINE> pair += 1 <NEWLINE> a += 1 <NEWLINE> b -= 1 <NEWLINE> <DEDENT>
from collections import defaultdict <NEWLINE> import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 8 ) <NEWLINE> INF = float ( <STRING> ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> eps = 10 ** - 7 <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> <NL> def inp ( ) : <NEWLINE> <INDENT> return int ( input ( ) ) <NEWLINE> <NL> <NL> <DEDENT> def inpl ( ) : <NEWLINE> <INDENT> return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> <DEDENT> N , M = inpl ( ) <NEWLINE> <NL> if N % 2 == 1 : <NEWLINE> <INDENT> for i in range ( M ) : <NEWLINE> <INDENT> print ( i + 1 , N - i - 1 ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> assert False <NEWLINE> if M == 1 : <NEWLINE> <INDENT> print ( 1 , 2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( M ) : <NEWLINE> <INDENT> if i == M - 1 : <NEWLINE> <INDENT> print ( i + 1 , i + 3 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( i + 1 , N - i ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> if N % 2 == 1 : <NEWLINE> <INDENT> for i in range ( M ) : <NEWLINE> <INDENT> print ( i + 1 , N - i ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> middle = ( ( M + 1 ) / 2 ) <NEWLINE> for i in range ( middle ) : <NEWLINE> <INDENT> print ( i + 1 , N - i ) <NEWLINE> <DEDENT> for j in range ( middle , M ) : <NEWLINE> <INDENT> print ( j + 2 , N - j ) <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> <NL> inp = input ( ) . split ( <STRING> ) <NEWLINE> N , M = int ( inp [ 0 ] ) , int ( inp [ 1 ] ) <NEWLINE> <NL> import math <NEWLINE> M2_ceil = math . ceil ( M / 2.0 ) <NEWLINE> M2_flor = math . floor ( M / 2.0 ) <NEWLINE> pairs = [ ] <NEWLINE> for i in range ( M2_ceil ) : <NEWLINE> <INDENT> pairs . append ( [ 1 + i , 1 + i + sizes_even [ i ] + 1 ] ) <NEWLINE> <DEDENT> for i in range ( M2_flor ) : <NEWLINE> <INDENT> pairs . append ( [ 1 + M2_ceil + 1 + i + 1 , 1 + M2_ceil + 1 + i + 1 + sizes_odd [ i ] + 1 ] ) <NEWLINE> <NL> <DEDENT> for pair in pairs : <NEWLINE> <INDENT> print ( pair [ 0 ] , pair [ 1 ] ) <NEWLINE> <DEDENT>
def dp3 ( ini , i , j , k ) : return [ [ [ ini ] * i for i2 in range ( j ) ] for i3 in range ( k ) ] <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> N , M = mi ( ) <NEWLINE> <NL> l = [ i for i in range ( 1 , N + 1 ) ] <NEWLINE> <NL> if N % 2 : <NEWLINE> <INDENT> for i in range ( M ) : <NEWLINE> <INDENT> print ( N // 2 - i , N // 2 + i + 1 ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( M // 2 , M ) : <NEWLINE> <INDENT> print ( 1 + i - M // 2 , N - i + M // 2 ) <NEWLINE> <DEDENT> for i in range ( M // 2 ) : <NEWLINE> <INDENT> print ( N // 2 - i , N // 2 + i + 2 ) <NEWLINE> <DEDENT> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> if n % 2 == 1 : <NEWLINE> <INDENT> for i in range ( m ) : <NEWLINE> <INDENT> print ( m - i , m + 1 + i ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( m ) : <NEWLINE> <INDENT> if 4 * ( i + 1 ) > n : <NEWLINE> <INDENT> print ( m - 1 , m + 2 + i ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> pritn ( m - 1 , m + 1 + i ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
from collections import defaultdict <NEWLINE> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> s = 1 <NEWLINE> f = n <NEWLINE> ans = [ ] <NEWLINE> d = defaultdict ( lambda : False ) <NEWLINE> i = 0 <NEWLINE> <NL> used = [ ] <NEWLINE> while i < m : <NEWLINE> <COMMENT> <NL> <INDENT> tmp = abs ( s - f ) <NEWLINE> a , b = min ( tmp , n - tmp ) , max ( tmp , n - tmp ) <NEWLINE> if d [ a ] or d [ b ] : <NEWLINE> <INDENT> f -= 1 <NEWLINE> continue <NEWLINE> <DEDENT> d [ a ] = True <NEWLINE> d [ b ] = True <NEWLINE> ans . append ( <STRING> ) <NEWLINE> used . append ( s ) <NEWLINE> used . append ( f ) <NEWLINE> s += 1 <NEWLINE> f -= 1 <NEWLINE> i += 1 <NEWLINE> <DEDENT> f = False <NEWLINE> for i in used : <NEWLINE> <INDENT> if i <= 0 or n < i : <NEWLINE> <INDENT> f = True <NEWLINE> <DEDENT> <DEDENT> if f : <NEWLINE> <INDENT> ans = [ ] <NEWLINE> while i < m : <NEWLINE> <COMMENT> <NL> tmp = abs ( s - f ) <NEWLINE> a , b = min ( tmp , n - tmp ) , max ( tmp , n - tmp ) <NEWLINE> if d [ a ] or d [ b ] : <NEWLINE> <INDENT> s += 1 <NEWLINE> continue <NEWLINE> <DEDENT> d [ a ] = True <NEWLINE> d [ b ] = True <NEWLINE> ans . append ( <STRING> ) <NEWLINE> used . append ( s ) <NEWLINE> used . append ( f ) <NEWLINE> s += 1 <NEWLINE> f -= 1 <NEWLINE> i += 1 <NEWLINE> <NL> <DEDENT> print ( <STRING> . join ( ans ) ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if n % 2 == 0 : <NEWLINE> <INDENT> i = 1 <NEWLINE> while i <= m : <NEWLINE> <INDENT> if i < ( n - 2 ) // 2 <NEWLINE> <INDENT> a_i = str ( i ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a_i = str ( i + 1 ) <NEWLINE> <DEDENT> b_i = str ( n - i ) <NEWLINE> <NL> print ( a_i + <STRING> + b_i ) <NEWLINE> i += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> elif n % 2 == 1 : <NEWLINE> <INDENT> for i in range ( 1 , m + 1 ) : <NEWLINE> <INDENT> a_i = str ( i ) <NEWLINE> b_i = str ( n - i ) <NEWLINE> <NL> print ( a_i + <STRING> + b_i ) <NEWLINE> <DEDENT> <DEDENT>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> x = list ( range ( 1 , N + 1 , 1 ) ) <NEWLINE> <NL> for i in range ( 3 ) : <NEWLINE> <INDENT> print ( x . pop ( 0 ) , x . pop ( - 1 ) ) <NEWLINE> <DEDENT>
N , M = map ( int , input ( ) . rstrip ( ) . split ( <STRING> ) ) <NEWLINE> ans = [ [ False for _ in range ( N ) ] for _ in range ( N ) ] <NEWLINE> <NL> if N % 2 == 1 : <NEWLINE> <INDENT> for i in range ( 1 , M + 1 ) : <NEWLINE> <INDENT> print ( str ( i ) + <STRING> + str ( N - i ) ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( 1 , min ( M + 1 , ( N - 1 ) / 2 ) ) : <NEWLINE> <INDENT> print ( str ( i ) + <STRING> + str ( N - i ) ) <NEWLINE> <DEDENT> if ( N - 1 ) // 2 == M : <NEWLINE> <INDENT> print ( str ( N / 2 ) + <STRING> + str ( N / 2 + 1 ) ) <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> import sys <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if M % 2 == 1 : <NEWLINE> <INDENT> for i in range ( M // 2 ) : <NEWLINE> <INDENT> print ( i + 1 , M - i ) <NEWLINE> <DEDENT> for j in range ( N // 2 + 1 ) : <NEWLINE> <INDENT> print ( M + 1 + i , 2 * M + 1 - i ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( M // 2 ) : <NEWLINE> <INDENT> print ( i + 1 , M + 1 - i ) <NEWLINE> <DEDENT> for j in range ( M // 2 ) : <NEWLINE> <INDENT> print ( M + 2 + j , 2 * M + 1 - j ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if n % 2 == 1 : <NEWLINE> <INDENT> for i in range ( m ) : <NEWLINE> <INDENT> print ( n // 2 - i , n // 2 + i + 1 ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> ni = 1 <NEWLINE> while ni < n // 4 and ni <= m : <NEWLINE> <INDENT> print ( l , r ) <NEWLINE> l += 1 <NEWLINE> r -= 1 <NEWLINE> ni += 1 <NEWLINE> <DEDENT> r -= 1 <NEWLINE> while ni <= m : <NEWLINE> <INDENT> print ( l , r ) <NEWLINE> l += 1 <NEWLINE> r -= 1 <NEWLINE> ni += 1 <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> stdin = sys . stdin <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> ni = lambda : int ( ns ( ) ) <NEWLINE> na = lambda : list ( map ( int , stdin . readline ( ) . split ( ) ) ) <NEWLINE> nn = lambda : list ( stdin . readline ( ) . split ( ) ) <NEWLINE> ns = lambda : stdin . readline ( ) . rstrip ( ) <NEWLINE> <NL> n , m = na ( ) <NEWLINE> <NL> if n % 2 == 0 : <NEWLINE> <INDENT> a , b = n // 2 , n // 2 + 1 <NEWLINE> for i in m : <NEWLINE> <INDENT> print ( a , b ) <NEWLINE> a , b = a - 1 , b + 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> a , b = 1 , n <NEWLINE> for i in m : <NEWLINE> <INDENT> print ( a , b ) <NEWLINE> a , b = a + 1 , b - 1 <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> import sys <NEWLINE> <NL> <NL> def solve ( N : int , M : int ) : <NEWLINE> <INDENT> left = 1 <NEWLINE> right = N if N % 2 == 0 else N - 1 <NEWLINE> count = 0 <NEWLINE> if N % 2 == 0 : <NEWLINE> <INDENT> raise Exception <NEWLINE> while count < M : <NEWLINE> <INDENT> if right - left == N // 2 : <NEWLINE> <INDENT> left += 1 <NEWLINE> right -= 1 <NEWLINE> continue <NEWLINE> <DEDENT> print ( left , right ) <NEWLINE> left += 1 <NEWLINE> right -= 1 <NEWLINE> count += 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> while count < M : <NEWLINE> <INDENT> print ( left , right ) <NEWLINE> left += 1 <NEWLINE> right -= 1 <NEWLINE> count += 1 <NEWLINE> <DEDENT> <DEDENT> return <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> def iterate_tokens ( ) : <NEWLINE> <INDENT> for line in sys . stdin : <NEWLINE> <INDENT> for word in line . split ( ) : <NEWLINE> <INDENT> yield word <NEWLINE> <DEDENT> <DEDENT> <DEDENT> tokens = iterate_tokens ( ) <NEWLINE> N = int ( next ( tokens ) ) <COMMENT> <NEWLINE> M = int ( next ( tokens ) ) <COMMENT> <NEWLINE> solve ( N , M ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> print ( m - i + , m + i + 1 ) <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> def using_sqrt ( limit ) : <NEWLINE> <INDENT> n = 0 <NEWLINE> for k in range ( 2 , limit + 1 ) : <NEWLINE> <INDENT> factor = 0 <NEWLINE> <NL> <COMMENT> <NL> if k % 2 == 0 and k != 2 : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> for divisor in range ( 2 , math . floor ( math . sqrt ( k ) ) + 1 ) : <NEWLINE> <INDENT> if k % divisor == 0 : <NEWLINE> <INDENT> factor += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if factor == 0 : <NEWLINE> <INDENT> n += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> return n <NEWLINE> <NL> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> if m % using_sqrt ( i ) == 0 : <NEWLINE> <INDENT> ans = i <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> for j in range ( m ) : <NEWLINE> <INDENT> print ( i + 1 , i + 1 + ans ) <NEWLINE> <DEDENT>
<COMMENT> <NL> from math import gcd <NEWLINE> from collections import defaultdict <NEWLINE> import sys <NEWLINE> <NL> input = sys . stdin . buffer . readline <NEWLINE> <NL> mod = 10 ** 9 + 7 <NEWLINE> n = int ( input ( ) ) <NEWLINE> cnt = 0 <NEWLINE> cnt += n <NEWLINE> zerocnt = 0 <NEWLINE> kumi = defaultdict ( int ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if a == 0 and b == 0 : <NEWLINE> <INDENT> zerocnt += 1 <NEWLINE> continue <NEWLINE> <DEDENT> elif b == 0 : <NEWLINE> <INDENT> kumi [ ( 1 , 0 ) ] += 1 <NEWLINE> kumi [ ( 0 , - 1 ) ] += 0 <NEWLINE> continue <NEWLINE> <DEDENT> elif a == 0 : <NEWLINE> <INDENT> kumi [ ( 0 , - 1 ) ] += 1 <NEWLINE> kumi [ ( 1 , 0 ) ] += 0 <NEWLINE> continue <NEWLINE> <DEDENT> g = gcd ( a , b ) <NEWLINE> a //= g <NEWLINE> b //= g <NEWLINE> if a < 0 : <NEWLINE> <INDENT> a *= - 1 <NEWLINE> b *= - 1 <NEWLINE> <DEDENT> kumi [ ( a , b ) ] += 1 <NEWLINE> kumi [ ( b , - a ) ] += 0 <NEWLINE> <DEDENT> ans = 1 <NEWLINE> cnt -= zerocnt <NEWLINE> for a , b in kumi . keys ( ) : <NEWLINE> <INDENT> if b <= 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> s = kumi [ ( a , b ) ] <NEWLINE> t = kumi [ ( b , - a ) ] <NEWLINE> ans *= pow ( 2 , ( s + t ) , mod ) - ( pow ( 2 , s , mod ) - 1 ) * ( pow ( 2 , t , mod ) - 1 ) <NEWLINE> ans %= mod <NEWLINE> cnt -= s + t <NEWLINE> <DEDENT> if cnt > 0 : <NEWLINE> <INDENT> ans *= pow ( 2 , cnt , mod ) <NEWLINE> ans %= mod <NEWLINE> <DEDENT> print ( ( ans - 1 + zerocnt ) % mod ) <NEWLINE>
<NL> <NL> n , m = [ 0 ] * 2 <NEWLINE> <NL> def format_input ( filename = None ) : <NEWLINE> <INDENT> global n , m <NEWLINE> if filename == None : <NEWLINE> <INDENT> n , m = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <DEDENT> elif filename == <STRING> : <NEWLINE> <INDENT> from random import randint as rng <NEWLINE> n = rng ( 3 , 10 ** 5 ) <NEWLINE> m = rng ( 1 , ( n - 1 ) // 2 ) <NEWLINE> print ( n , m ) <NEWLINE> <NL> <DEDENT> <DEDENT> def get_answer ( ) : <NEWLINE> <INDENT> median = n // 2 <NEWLINE> <NL> for i in range ( m ) : <NEWLINE> <INDENT> if n % 2 == 0 and i = > n // 4 : <NEWLINE> <INDENT> print ( median - i , median + i + 2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( median - i , median + i + 1 ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> format_input ( ) <NEWLINE> <NL> get_answer ( ) <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> if n % 2 != 0 : <NEWLINE> <INDENT> for i in range ( 1 , m + 1 ) : <NEWLINE> <INDENT> print ( i , n + 1 - i ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for i , j in range ( 1 , m + 1 ) , range ( 1 , m + 1 ) : <NEWLINE> <INDENT> if i == n / 2 : <NEWLINE> <INDENT> i += 1 <NEWLINE> <DEDENT> print ( i , n - j ) <NEWLINE> i += 1 <NEWLINE> <DEDENT> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <NL> m = ( n - 1 ) // 2 <NEWLINE> a = ( n - 1 ) // 2 <NEWLINE> d = 1 <NEWLINE> memo = set ( [ ] ) <NEWLINE> cnt = 0 <NEWLINE> for i in range ( m ) : <NEWLINE> <NL> <INDENT> if ( n - d in memo ) or ( d * 2 == n ) ) : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> d += 1 <NEWLINE> <DEDENT> memo . add ( d ) <NEWLINE> if cnt > 1 or a < 1 or a + d > n : <NEWLINE> <INDENT> print ( 1 / 0 ) <NEWLINE> <DEDENT> print ( a , a + d ) <NEWLINE> a -= 1 <NEWLINE> d += 2 <NEWLINE> <DEDENT>
n , m = int ( input ( ) . split ( ) ) <NEWLINE> for i in range ( 0 , m ) : <NEWLINE> <INDENT> if n - 2 * i - 1 > n / 2 : <NEWLINE> <INDENT> print ( i + 1 , n - i ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( i + 1 , n - i - 1 ) <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> import io , os <NEWLINE> input = io . BytesIO ( os . read ( 0 , os . fstat ( 0 ) . st_size ) ) . readline <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = [ 0 ] + list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> E = [ [ ] for i in range ( N + 1 ) ] <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> E [ x ] . append ( y ) <NEWLINE> E [ y ] . append ( x ) <NEWLINE> <NL> <DEDENT> USE = [ 0 ] * ( N + 1 ) <NEWLINE> USE [ 1 ] = 1 <NEWLINE> ANS = [ 0 ] * ( N + 1 ) <NEWLINE> <NL> import bisect <NEWLINE> def dfs ( x , DP ) : <NEWLINE> <COMMENT> <NL> <INDENT> pos = bisect . bisect_left ( DP , A [ x ] ) <NEWLINE> <COMMENT> <NL> if pos < len ( DP ) : <NEWLINE> <INDENT> DP = list ( DP ) <NEWLINE> DP [ pos ] = A [ x ] <NEWLINE> DP = tuple ( DP ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> DP += ( A [ x ] , ) <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> ANS [ x ] = len ( DP ) <NEWLINE> <NL> for to in E [ x ] : <NEWLINE> <INDENT> if USE [ to ] == 0 : <NEWLINE> <INDENT> USE [ to ] = 1 <NEWLINE> dfs ( to , DP ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> dfs ( 1 , tuple ( ) ) <NEWLINE> <NL> print ( * ANS [ 1 : ] ) <NEWLINE> <NL>
from bisect import bisect_left <NEWLINE> import sys <NEWLINE> sys . setrecursionlimit ( 1000000 ) <NEWLINE> <NL> <NL> <NL> def dfs ( p ) : <NEWLINE> <INDENT> ai = a [ p ] <NEWLINE> i = bisect_left ( dp , ai ) <NEWLINE> old = dp [ i ] <NEWLINE> dp [ i ] = ai <NEWLINE> ans [ p ] = bisect_left ( dp , INF ) - 1 <NEWLINE> for child in to [ p ] : <NEWLINE> <INDENT> if ans [ child ] is None : <NEWLINE> <INDENT> dfs ( child ) <NEWLINE> <DEDENT> <DEDENT> dp [ i ] = old <NEWLINE> <NL> <NL> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> a = [ None ] + list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> to = [ [ ] for _ in range ( n + 1 ) ] <NEWLINE> for _ in range ( n - 1 ) : <NEWLINE> <INDENT> u , v = map ( int , input ( ) . split ( ) ) <NEWLINE> to [ u ] . append ( v ) <NEWLINE> to [ v ] . append ( u ) <NEWLINE> <DEDENT> INF = 10 ** 20 <NEWLINE> dp = [ INF ] * ( n + 1 ) <NEWLINE> dp [ 0 ] = - INF <NEWLINE> q = deque ( [ 1 ] ) <NEWLINE> ans = [ None ] * ( n + 1 ) <NEWLINE> dfs ( 1 ) <NEWLINE> print ( <STRING> . join ( list ( map ( str , ans [ 1 : ] ) ) ) ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <NL> from pprint import pprint as pp <NEWLINE> from pprint import pformat as pf <NEWLINE> <NL> import math <NEWLINE> from sortedcontainers import SortedList , SortedDict , SortedSet <NEWLINE> import bisect <NEWLINE> <NL> def solve ( seq ) : <NEWLINE> <INDENT> dp = [ math . inf ] * ( len ( seq ) + 1 ) <NEWLINE> dp [ 0 ] = - 1 * math . inf <NEWLINE> for value in seq : <NEWLINE> <INDENT> key = bisect . bisect_left ( dp , value ) <NEWLINE> dp [ key ] = value <NEWLINE> print ( <STRING> ) <COMMENT> <NEWLINE> print ( dp ) <COMMENT> <NEWLINE> <DEDENT> key = bisect . bisect_left ( dp , math . inf ) <NEWLINE> return key - 1 <NEWLINE> <NL> <DEDENT> class Tree : <NEWLINE> <INDENT> <STRING> <NEWLINE> <NL> DUMMY = 0 <COMMENT> <NEWLINE> <NL> def __init__ ( self , num_node , node_values ) : <NEWLINE> <INDENT> self . node_values = [ - 1 ] + node_values <COMMENT> <NEWLINE> self . edges = [ None ] * ( num_node + 1 ) <COMMENT> <NEWLINE> for i , _ in enumerate ( self . edges ) : <NEWLINE> <INDENT> self . edges [ i ] = set ( ) <NEWLINE> <DEDENT> self . seq = [ self . DUMMY ] * num_node <NEWLINE> <NL> self . dp = [ math . inf ] * ( num_node + 1 ) <NEWLINE> self . dp [ 0 ] = - 1 * math . inf <NEWLINE> self . ans = [ 0 ] * ( num_node + 1 ) <COMMENT> <NEWLINE> <NL> <NL> <DEDENT> def node_values ( self , node_values ) : <NEWLINE> <INDENT> self . node_values = [ - 1 ] + node_values <COMMENT> <NEWLINE> <NL> <DEDENT> def make_edge ( self , a , b ) : <NEWLINE> <INDENT> self . edges [ a ] . add ( b ) <NEWLINE> self . edges [ b ] . add ( a ) <NEWLINE> <NL> <DEDENT> def dps ( self , node_id , prev = 0 , depth = 0 ) : <NEWLINE> <COMMENT> <NL> <INDENT> value = self . node_values [ node_id ] <NEWLINE> key = bisect . bisect_left ( self . dp , value ) <NEWLINE> old_value = self . dp [ key ] <NEWLINE> self . dp [ key ] = value <NEWLINE> self . ans [ node_id ] = max ( key , self . ans [ prev ] ) <NEWLINE> <COMMENT> <NL> for to in self . edges [ node_id ] : <NEWLINE> <INDENT> if to == prev : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> self . dps ( to , node_id , depth + 1 ) <NEWLINE> <COMMENT> <NL> <DEDENT> self . dp [ key ] = old_value <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> num_node = int ( input ( ) ) <NEWLINE> node_values = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> tree = Tree ( num_node , node_values ) <NEWLINE> for i in range ( num_node - 1 ) : <NEWLINE> <INDENT> frm , to = map ( int , input ( ) . split ( ) ) <NEWLINE> tree . make_edge ( frm , to ) <NEWLINE> <DEDENT> tree . dps ( 1 ) <NEWLINE> for a in tree . ans [ 1 : ] : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <NL> <NL> <NL> <DEDENT> print ( <STRING> + <STRING> + <STRING> ) <COMMENT> <NEWLINE> <DEDENT>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if a = < b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
S , W = int ( input ( ) . split ( ) ) <NEWLINE> <NL> if ( S > W ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s , w = map ( int , input ( ) . split ( ) ) <COMMENT> <NEWLINE> if s > w <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
S , W = map ( int , input ( ) . split ( ) ) <NEWLINE> if S < = W : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s = int ( input ( ) ) <NEWLINE> w = int ( input ( ) ) <NEWLINE> <NL> if w >= s : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif w < s : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s , w = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> print ( <STRING> if s = < w else <STRING> ) <NEWLINE>
S , W = map ( int , input . split ( ) ) <NEWLINE> if S <= W : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : print ( <STRING> ) <NEWLINE>
if S <= W : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT>
python3 make . py abc 999 - - num 6 <NEWLINE> <NL> S , W = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> <NL> if S > W : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
<INDENT> S , W = map ( int , input ( ) . split ( ) ) <NEWLINE> <DEDENT> if W >= S : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s , w = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( <STRING> s <= w else <STRING> ) <NEWLINE>
s , w = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if w >= S : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if a = < b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
<NL> <NL> class Main : <NEWLINE> <NL> <INDENT> s1 , s2 = int ( input ( ) . split ( ) ) ; <NEWLINE> <NL> if s1 <= s2 : <NEWLINE> <INDENT> print ( <STRING> ) ; <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) ; <NEWLINE> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> S = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> S . append ( input ( ) ) <NEWLINE> <DEDENT> print ( set ( S ) ) <NEWLINE>
s = int ( input ( ) ) <NEWLINE> w = int ( input ( ) ) <NEWLINE> if ( s <= w ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
S = int ( input ( ) ) <NEWLINE> W = int ( input ( ) ) <NEWLINE> if S > W : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) ) <NEWLINE> <NL> if m >= n : <NEWLINE> <NL> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
S = int ( input ( ) ) <NEWLINE> W = int ( input ( ) ) <NEWLINE> if W >= S : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
S , W = map ( int , input ( ) . split ( ) ) <NEWLINE> print <STRING> if W >= S else <STRING> <NEWLINE>
S W <NEWLINE> if W >= ( S / 2 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT>
S , W = map ( int , input ( ) split ( ) ) <NEWLINE> <COMMENT> <NL> if W >= S : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
def compare ( ) : <NEWLINE> <INDENT> S = int ( input ( ) ) <NEWLINE> W = int ( input ( ) ) <NEWLINE> if S <= W : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> compare ( ) <NEWLINE>
s = int ( input ( ) ) <NEWLINE> w = int ( input ( ) ) <NEWLINE> <NL> if w >= s : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
S , W = map ( int , input ( ) ) <NEWLINE> print ( <STRING> if S > W else <STRING> ) <NEWLINE>
s , w = map ( input ( ) . split ( ) ) <NEWLINE> <NL> if s > w : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s , w = map ( int , input ( ) . split ) <NEWLINE> <NL> if s <= w : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if b >= a : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s , w = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if S > W : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> if S < W : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
S , W = map ( int , input ( ) . split ) <NEWLINE> if S >= W : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
sheep_number = int ( input ( ) ) <NEWLINE> wolf_number = int ( input ( ) ) <NEWLINE> if sheep_number <= wolf_number : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s , w = map ( int , input ( ) . split ( ) ) <NEWLINE> if ( s < w ) <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
S , W = map ( int , input ( ) . split ( ) ) <NEWLINE> if S = < W : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s , w = ( for i in input ( ) . split ( ) ) <NEWLINE> if s > w : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> if w >= s : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
( S , W ) = input ( ) <NEWLINE> if S <= W : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
S = int ( input ( ) ) <NEWLINE> W = int ( input ( ) ) <NEWLINE> if W >= S : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s , w = map ( int , input ( ) ) <NEWLINE> print ( <STRING> if s <= w else <STRING> ) <NEWLINE>
S , W = map ( int , input ( . split ( ) ) ) <NEWLINE> if W >= S : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
S = int ( input ( ) ) <NEWLINE> <NL> W = int ( input ( ) ) <NEWLINE> <NL> if W >= S : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s , w = int ( input ( ) ) . split ( ) <NEWLINE> if w >= s : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
<NL> def main ( ) : <NEWLINE> <INDENT> s , w = map ( int , input ( ) ) <NEWLINE> if w >= s : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
NUM = list ( map ( int , input ( ) . split ) ) <NEWLINE> <NL> if ( NUM [ 0 ] >= NUM [ 1 ] ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif ( NUM [ 0 ] < NUM [ 1 ] ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s , w = list ( map ( int , input ( ) ) ) <NEWLINE> if w >= s : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
S , W = map ( int , input ( ) . split ( ) ) <NEWLINE> if W >= S : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> else : <NEWLINE> print ( <STRING> ) <NEWLINE> <DEDENT>
w , s = list ( map , int ( input ( ) . split ( ) ) ) <NEWLINE> if w >= s : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s , w = int ( input ( ) . split ( ) ) <NEWLINE> if w >= s : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> w = input ( ) <NEWLINE> if s <= w : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
S , W = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if s <= w : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
S , W = map ( int , input . split ( ) ) <NEWLINE> <NL> <INDENT> if S > W : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <NL> <NL> <DEDENT> <DEDENT>
S , W = map ( int . input ( <STRING> ) ) <NEWLINE> if W >= S : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
<INDENT> s , w = input ( ) . split ( ) <NEWLINE> <DEDENT> s = int ( s ) <NEWLINE> w = int ( w ) <NEWLINE> if s > w : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s = input ( ) . split ( ) <NEWLINE> <COMMENT> <NL> if s [ 0 ] = > s [ 1 ] : <NEWLINE> <INDENT> print ( unsafe ) <NEWLINE> else : <NEWLINE> <INDENT> print ( safe ) <NEWLINE> <DEDENT> <DEDENT>
s , w = input ( , ) <NEWLINE> if s >= w : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
S , W = int ( input ( ) . split ( ) ) <NEWLINE> if S <= W : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE>
100 2 <NEWLINE>
S , W = int ( inpit ( ) ) <NEWLINE> <NL> if S <= W : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else S > W : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT>
S , W = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if S = < W : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( <STRING> if S > W else <STRING> ) <NEWLINE>
S , W = int ( input ( ) ) , int ( input ( ) ) <NEWLINE> if S <= W : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
x = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if x [ 0 ] < x [ 1 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
<INDENT> import sys <NEWLINE> <NL> s , w = ( int ( n ) for n in input ( ) . split ( ) ) <NEWLINE> <NL> if ( s <= w ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
s , w = map ( int , input ( ) . split ( ) ) <NEWLINE> if w >= s : <NEWLINE> <INDENT> pritn ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s , w = map ( int , input ( ) ) <NEWLINE> if s <= w : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> <NL> <NL> def count_multi ( s , d ) : <NEWLINE> <INDENT> m = a = np . array ( [ int ( c ) for c in s ] ) <COMMENT> <NEWLINE> keta = 1 <NEWLINE> count = np . count_nonzero ( m == 0 ) <NEWLINE> while len ( m ) > 1 : <NEWLINE> <INDENT> m = ( m [ : - 1 ] * 10 + a [ keta : ] ) % d <NEWLINE> keta += 1 <NEWLINE> count += np . count_nonzero ( m == 0 ) <NEWLINE> <DEDENT> return count <NEWLINE> <NL> <DEDENT> print ( count_multi ( input ( ) . strip ( ) , 2019 ) ) <NEWLINE>
s , w = map ( int , input ( ) . spilt ( ) ) <NEWLINE> <NL> if w >= s : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
S , W = [ int ( s ) for s in input . split ( ) ] <NEWLINE> if W >= S : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s , w = int ( input ( ) ) <NEWLINE> if s > w : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s , w = map ( int , input ( ) . split ( ) ) <NEWLINE> if ( w >= s ) <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
S , W = map ( int , input ( ) . split ( ) ) <NEWLINE> if S > W : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
s , w = map ( int , input ( ) . split ( ) ) <NEWLINE> if s = < w : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
S , W = map ( int , input ( ) . split ( ) ) <NEWLINE> if S = < W : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s , w = int ( input ( ) ) <NEWLINE> <NL> if s <= w : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
S , W = ( int ( x ) for in input ( ) . split ( ) ) <NEWLINE> if W >= S : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
input ( ) . split ( ) <NEWLINE> s = int ( a [ 0 ] ) <NEWLINE> w = int ( a [ 1 ] ) <NEWLINE> <NL> if w >= s : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
S , W = map ( int , input ( ) ) <NEWLINE> <NL> if W >= S : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
S , W = int ( input ( ) . split ( ) ) <NEWLINE> if ( S > W ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
nm = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if ( nm [ 0 ] = < nm [ 1 ] ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else print ( <STRING> ) <NEWLINE>
S = int ( input ( ) ) <NEWLINE> W = int ( input ( ) ) <NEWLINE> <NL> if W >= S : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if a <= b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s , w = map ( int , input . split ( ) ) <NEWLINE> if s > w : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s = int ( input ( ) ) <NEWLINE> w = int ( input ( ) ) <NEWLINE> if ( w >= s ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
S , W = int ( input ( ) ) <NEWLINE> if S > W : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import sys <NEWLINE> args = sys . argv <NEWLINE> <NL> s = int ( args [ 0 ] ) <NEWLINE> w = int ( args [ 1 ] ) <NEWLINE> <NL> if s <= w : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s , w = map ( int , input ( ) . strip ( ) ) <NEWLINE> <NL> if s > w : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
S = input ( ) <NEWLINE> W = input ( ) <NEWLINE> <NL> if int ( S ) <= int ( W ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif int ( S ) > int ( W ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s , w = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if s = < w : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
S , W = map ( int , intput ( ) . split ( ) ) <NEWLINE> <NL> if S <= W : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
from math import factorial as fact <NEWLINE> import math <NEWLINE> import fractions <NEWLINE> import sys <NEWLINE> import itertools <NEWLINE> import numpy as np <NEWLINE> from collections import Counter <NEWLINE> import datetime <NEWLINE> <COMMENT> <NL> def input1 ( ) : <NEWLINE> <INDENT> return int ( input ( ) ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> def input2 ( ) : <NEWLINE> <INDENT> return map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> def input_array ( ) : <NEWLINE> <INDENT> return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <DEDENT> def keta ( N ) : <NEWLINE> <INDENT> return len ( str ( N ) ) <NEWLINE> <NL> <NL> <DEDENT> def input_daytime ( input_time ) : <NEWLINE> <INDENT> time , distance = input_time . split ( ) <NEWLINE> t = time . split ( <STRING> ) <NEWLINE> se = str ( t [ - 1 ] ) . split ( <STRING> ) <NEWLINE> dt1 = datetime . timedelta ( hours = int ( t [ 0 ] ) , minutes = int ( t [ 1 ] ) , seconds = int ( se [ 0 ] ) , milliseconds = int ( se [ 1 ] ) ) <NEWLINE> return dt1 <NEWLINE> <NL> <DEDENT> def combinations ( n , r ) : <NEWLINE> <INDENT> return list ( itertools . combinations ( n , r ) ) <NEWLINE> <NL> <DEDENT> def all_sets ( num_list ) : <NEWLINE> <INDENT> subsets = [ ] <NEWLINE> for i in range ( 2 , len ( num_list ) + 1 ) : <NEWLINE> <INDENT> for c in combinations ( num_list , i ) : <NEWLINE> <INDENT> subsets . append ( c ) <NEWLINE> <DEDENT> <DEDENT> return subsets <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> def ch ( x1 ) : <NEWLINE> <INDENT> cf = [ ] <NEWLINE> for i in range ( 2 , math . sqrt ( x1 ) + 1 ) : <NEWLINE> <INDENT> if x1 % i == 0 : <NEWLINE> <INDENT> cf . append ( i ) <NEWLINE> <DEDENT> <DEDENT> return cf <NEWLINE> <NL> <DEDENT> def CountOneRoots ( x , y ) : <NEWLINE> <COMMENT> <NL> <INDENT> return fact ( x + y ) / fact ( x ) / fact ( y ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> def factorization ( n ) : <NEWLINE> <INDENT> tmp = n <NEWLINE> count = 0 <NEWLINE> for i in range ( 2 , int ( n ** 0.5 ) + 2 ) : <NEWLINE> <INDENT> if tmp % i == 0 : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> while tmp % i == 0 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> tmp //= i <NEWLINE> <DEDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> if tmp != 1 : <NEWLINE> <INDENT> count += 1 <NEWLINE> <NL> <DEDENT> return count <NEWLINE> <NL> <NL> <NL> <DEDENT> s , w = input2 ( ) <NEWLINE> if w >= s2 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <DEDENT>
s = int ( input ( ) ) <NEWLINE> w = int ( input ( ) ) <NEWLINE> <NL> if w >= s : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
S = input ( ) <NEWLINE> W = input ( ) <NEWLINE> if S > W : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a = input ( <STRING> ) <NEWLINE> b = input ( <STRING> ) <NEWLINE> <NL> S = int ( a ) <NEWLINE> W = int ( b ) <NEWLINE> <NL> if S <= W : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
S , W = map ( int , input ( ) . split ( ) ) <NEWLINE> if W >= S : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a = input ( ) . spolit ( ) <NEWLINE> <NL> if int ( a [ 0 ] ) > int ( a [ 1 ] ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if b >= a : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> else : <NEWLINE> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b = map ( int , input ( ) . sprit ( ) ) <NEWLINE> if a <= b : print ( <STRING> ) <NEWLINE> else : print ( <STRING> ) <NEWLINE>
import sys <NEWLINE> int1 = lambda x : int ( x ) - 1 <NEWLINE> read = sys . stdin . buffer . read <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> readlines = sys . stdin . buffer . readlines <NEWLINE> sys . setrecursionlimit ( 500000 ) <NEWLINE> <NL> S , W = map ( int , read ( ) ) <NEWLINE> <NL> if W >= S : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <NL> <DEDENT>
s , w = int ( input ( ) . split ( ) ) <NEWLINE> if s >= w : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> w = input ( ) <NEWLINE> <NL> if int ( s ) > int ( w ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s , w = list ( map ( int , input ( split ( ) ) ) <NEWLINE> <NL> if s > w : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if A <= W : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
sheep = input ( ) <NEWLINE> wolves = input ( ) <NEWLINE> <NL> if sheep > wolves : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s , w = int ( input ( ) . split ( ) ) <NEWLINE> if w >= s : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s , w = int ( input ( ) ) , int ( input ( ) ) <NEWLINE> if w >= s : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
S , W = input ( ) . split ( ) <NEWLINE> if int ( S ) = < int ( W ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
<INDENT> s , w = ( int ( x ) for x in input ( ) . split ( ) ) <NEWLINE> <DEDENT> if s <= w : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
S = int ( input ( ) ) <NEWLINE> W = int ( input ( ) ) <NEWLINE> <NL> if ( S <= W ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <NL> s w = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if s <= w : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
print ( <STRING> ) if input ( ) <= input ( ) else print ( <STRING> ) <NEWLINE>
s , w = input ( ) . split ( ) <NEWLINE> if w >= s : <NEWLINE> <INDENT> print ( <STRING> ) : <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s , w = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if s = < w : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif s > w : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
list = map ( int , input ( ) . split ( ) ) <NEWLINE> S = list [ 0 ] <NEWLINE> W = list [ 1 ] <NEWLINE> if W >= S : print ( <STRING> ) <NEWLINE> else : print ( <STRING> ) <NEWLINE>
s , w = map ( int , input ( ) ) <NEWLINE> if w >= s : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
S = int ( input ( ) ) <NEWLINE> W = int ( input ( ) ) <NEWLINE> <NL> if S < W : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif S > W : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b = raw_input ( ) <NEWLINE> if a < b : <NEWLINE> <INDENT> print ( unsafe ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( safe ) <NEWLINE> <DEDENT>
S , W = map ( int , input ( ) . split ( ) ) <NEWLINE> if S <= W : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s , w = input ( ) . split ( ) <NEWLINE> if int ( w ) >= int ( s ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s , w = [ int ( i ) for i in input ( ) . spli ( ) ] <NEWLINE> if s <= w : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s , w = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if s > w : <NEWLINE> <INDENT> print ( safe ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( unsafe ) <NEWLINE> <DEDENT>
S = int ( ) <NEWLINE> W = int ( ) <NEWLINE> S = input ( ) <NEWLINE> W = input ( ) <NEWLINE> <NL> if S <= W : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
In [ 93 ] : s , w = map ( int , input ( ) . split ( ) ) <NEWLINE> <INDENT> ... : if s <= w : <NEWLINE> ... : print ( <STRING> ) <NEWLINE> ... : else : <NEWLINE> ... : print ( <STRING> ) <NEWLINE> <DEDENT>
S = int ( input ( ) ) <NEWLINE> W = int ( input ( ) ) <NEWLINE> if W >= S : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s , w = int ( input ( ) . split ( ) ) <NEWLINE> <NL> if w >= s : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import collections <NEWLINE> s = input ( ) <NEWLINE> <NL> l = [ int ( s [ - 1 ] ) ] <NEWLINE> d = 10 <NEWLINE> for i in range ( len ( s ) - 2 , - 1 , - 1 ) : <NEWLINE> <INDENT> l . append ( ( l [ - 1 ] + int ( s [ i ] ) * d ) % 2019 ) <NEWLINE> d *= 10 <NEWLINE> d %= 2019 <NEWLINE> <DEDENT> c = collections . Counter ( l ) <NEWLINE> ans = 0 <NEWLINE> for i in c . values ( ) : <NEWLINE> <INDENT> ans += i * ( i - 1 ) // 2 <NEWLINE> <NL> <DEDENT> ans += c [ 0 ] <NEWLINE> <NL> print ( ans ) <NEWLINE>
s = input ( ) <NEWLINE> for i in map ( int , s . split ( ) ) : <NEWLINE> <INDENT> lis . append ( i ) <NEWLINE> <DEDENT> if lis [ 0 ] > lis [ 1 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s , w = map ( int , input ( ) . split ( ) ) <NEWLINE> if s <= w : <NEWLINE> <INDENT> print ( unsafe ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( safe ) <NEWLINE> <DEDENT>
S = int ( input ( ) ) <NEWLINE> W = int ( input ( ) ) <NEWLINE> if W >= S : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s = int ( input ( ) ) <NEWLINE> w = int ( input ( ) ) <NEWLINE> if w >= s : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
seep , wolf = map ( int , input ( ) . rstrip ( ) ) <NEWLINE> <NL> if seep > wolf : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s , w = input ( ) . split ( <STRING> ) <NEWLINE> s = int ( s ) <NEWLINE> w = int ( w ) <NEWLINE> <NL> if s > w : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> pritn ( <STRING> ) <NEWLINE> <DEDENT>
S , W = map ( int , input , split ) <NEWLINE> <NL> if S <= W : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s , w = int ( input ( ) ) <NEWLINE> if w >= s : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
S , W = map ( int , input ( ) . split ( ) ) <NEWLINE> if W >= S : <NEWLINE> <INDENT> print ( unsafe ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( safe ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> w = int ( input ( ) ) <NEWLINE> s = int ( input ( ) ) <NEWLINE> if w >= s : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT>
a , b = map ( int , input . split ( ) ) <NEWLINE> if a <= b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s , w = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> if w >= s : <NEWLINE> <INDENT> print ( unsafe ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( safe ) <NEWLINE> <DEDENT>
S = int ( input ( ) ) <NEWLINE> W = int ( input ( ) ) <NEWLINE> <NL> if S <= W : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
S , W = map ( int ( input ( ) . split ( ) ) ) <NEWLINE> if W >= S : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> if ( N > M ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else if ( N <= M ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
S , W = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if S > W : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> <NEWLINE> <DEDENT>
n , m = map ( int . input ( ) . split ( ) ) <NEWLINE> <NL> if n <= m : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s , w = map ( int , input ( ) ) <NEWLINE> if s <= w : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s = int ( input ( ) ) <NEWLINE> w = int ( input ( ) ) <NEWLINE> if s <= w : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT>
s , w = input ( ) . split ( ) <NEWLINE> if s <= w : <NEWLINE> <INDENT> print ( unsafe ) <NEWLINE> <DEDENT> if s > w : <NEWLINE> <INDENT> print ( safe ) <NEWLINE> <DEDENT>
S = int ( input ( ) ) <NEWLINE> W = int ( input ( ) ) <NEWLINE> if S <= W : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> S = list ( ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> x = input ( ) <NEWLINE> S . append ( x ) <NEWLINE> <NL> <DEDENT> A = set ( S ) <NEWLINE> print ( len ( A ) ) <NEWLINE>
<NL> S , W = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if W = > S : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
S , W = map ( int , input ( ) . split ( ) ) <NEWLINE> input ( <STRING> if S <= W else <STRING> ) <NEWLINE>
S = int ( input ( ) ) <NEWLINE> W = int ( input ( ) ) <NEWLINE> <NL> if W >= S : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
S = int ( input ( ) ) <NEWLINE> W = int ( input ( ) ) <NEWLINE> if W >= S : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s , w = map ( int , input ( ) . split ( ) ) <NEWLINE> if s > w : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> else : <NEWLINE> print ( <STRING> ) <NEWLINE> <DEDENT>
s = int ( input ( <STRING> ) ) <NEWLINE> w = int ( input ( <STRING> ) ) <NEWLINE> if s > w : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s , w = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if ( s > w ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s , w = map ( int . input ( ) . split ( ) ) ; <NEWLINE> if s <= w : <NEWLINE> <INDENT> print ( <STRING> ) ; <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) ; <NEWLINE> <DEDENT>
S , W = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if ( W >= S ) { <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> } else { <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> } <NEWLINE>
S = int ( input ( ) ) <NEWLINE> W = int ( input ( ) ) <NEWLINE> print ( <STRING> if W >= S else <STRING> ) <NEWLINE>
s , w = map ( int , input ( ) . split ( ) ) <NEWLINE> if s > w : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> else : <NEWLINE> print ( <STRING> ) <NEWLINE> <DEDENT>
a <NEWLINE>
S , W = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( <STRING> if S > W <STRING> else ) <NEWLINE>
s = int ( input ( ) ) <NEWLINE> w = int ( input ( ) ) <NEWLINE> if ( s <= w ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> if ( s > w ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s = int ( input ( ) ) <NEWLINE> w = int ( input ( ) ) <NEWLINE> print ( <STRING> if w >= s else <STRING> ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S = [ ] <NEWLINE> ans = N <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> S . append ( input ( ) ) <NEWLINE> flg = 0 <NEWLINE> j = 0 <NEWLINE> while ( flg == 0 and j < i ) : <NEWLINE> <INDENT> if i != j : <NEWLINE> <INDENT> if len ( S [ j ] ) == len ( S [ i ] ) : <NEWLINE> <INDENT> if S [ j ] [ 0 ] == S [ i ] [ 0 ] : <NEWLINE> <INDENT> if S [ j ] == S [ i ] : <NEWLINE> <INDENT> S [ j ] = <STRING> <NEWLINE> ans = ans - 1 <NEWLINE> flg = 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> j = j + 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
if W >= S : print ( <STRING> ) <NEWLINE> else : print ( <STRING> ) <NEWLINE>
S , W = int ( input ( ) . split ( ) ) <NEWLINE> if S < W : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
S , W = map ( int , input ( ) . split ( ) ) <NEWLINE> if S <= w : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
from collections import Counter <NEWLINE> N = list ( input ( ) ) <NEWLINE> M = [ 0 ] <NEWLINE> S = 0 <NEWLINE> K = 1 <NEWLINE> ans = 0 <NEWLINE> <NL> for i in range ( len ( N ) ) : <NEWLINE> <INDENT> S += int ( N [ - i - 1 ] ) * K <NEWLINE> S %= 2019 <NEWLINE> <NL> K *= 10 <NEWLINE> K %= 2019 <NEWLINE> M . append ( S ) <NEWLINE> <NL> <DEDENT> P = Counter ( M ) <NEWLINE> for i in range ( 2020 ) : ans += P [ i ] * ( P [ i ] - 1 ) // 2 <NEWLINE> print ( ans ) <NEWLINE>
print ( <STRING> ) if int ( input ( ) ) <= int ( input ( ) ) else print ( <STRING> ) <NEWLINE>
s , w = int ( input ( ) ) , int ( input ( ) ) <NEWLINE> <NL> if s <= w : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
S , W = map ( int , input ( ) . split ( ) ) <NEWLINE> while 1 <= S <= 100 : <NEWLINE> <INDENT> while 1 <= W <= 100 : <NEWLINE> <INDENT> if S > W : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
tems = list ( map ( lambda x : int ( x ) , input ( ) . split ( ) ) ) <NEWLINE> s = items [ 0 ] <NEWLINE> w = items [ 1 ] <NEWLINE> print ( <STRING> if s > w else <STRING> ) <NEWLINE>
W , S = input ( ) <NEWLINE> <NL> if W >= S : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
sw = input ( ) . split ( ) <NEWLINE> <NL> if sw [ 0 ] > w [ 1 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s , w = map ( int , input ( ) . split ( ) ) <NEWLINE> if s > w : <NEWLINE> <INDENT> print ( safe ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( unsafe ) <NEWLINE> <DEDENT>
S , W = map ( unt , input ( ) . split ( ) ) <NEWLINE> if S > W : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
if S <= W : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
def solve ( ) : <NEWLINE> <INDENT> a , b , c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> x = c / b <NEWLINE> y = a / d <NEWLINE> <NL> <NL> if c % b == 0 and x - y <= 1 : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <NL> <NL> <DEDENT> return <STRING> if x < y else <STRING> <NEWLINE> <NL> <DEDENT> print ( solve ( ) ) <NEWLINE>
S = input ( ) <NEWLINE> W = input ( ) <NEWLINE> <NL> if S > W : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
S , W = map ( int , input ( ) . suplit ( ) ) <NEWLINE> if W >= S : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
S = int ( input ( ) ) <NEWLINE> W = int ( input ( ) ) <NEWLINE> print ( <STRING> ) if W >= S else print ( <STRING> ) <NEWLINE>
S , W = map ( int , input ( ) . split ( ) ) <NEWLINE> if W >= s : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
S , W = int ( input ( ) ) <NEWLINE> <NL> if S < W : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s , w = map ( int , input ( ) ) <NEWLINE> if s < w : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s = int ( input ( ) ) <NEWLINE> w = int ( input ( ) ) <NEWLINE> print ( <STRING> if s > w else <STRING> ) <NEWLINE>
S = int ( input ( ) ) <NEWLINE> W = int ( input ( ) ) <NEWLINE> if ( W >= S ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
for i in range ( 2 ) : <NEWLINE> <INDENT> S , W = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> <DEDENT> if W >= S : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if a <= b : <NEWLINE> <INDENT> print ( unsafe ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( safe ) <NEWLINE> <DEDENT>
s , w = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if s >= w : <NEWLINE> <INDENT> print ( safe ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( unsafe ) <NEWLINE> <DEDENT>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if a > b <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
1 2 <NEWLINE> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( a ) <NEWLINE> print ( b ) <NEWLINE> unsafe <NEWLINE> s = input ( ) <NEWLINE> print ( s ) <NEWLINE>
S , W = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if S = < W : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
if 1 <= W <= 100 and 1 <= S <= 100 and W >= S : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> if 1 <= W <= 100 and 1 <= S <= 100 and W < S : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b = map ( int , input ( ) . split ( <STRING> ) <NEWLINE> if a > b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT>
<INDENT> 1 SW = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <DEDENT> SW = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if ( SW [ 0 ] > SW [ 1 ] ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
A , B = map ( int . input ( ) . split ( ) ) <NEWLINE> <NL> if ( A > B ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
S = int ( input ( <STRING> ) ) <NEWLINE> W = inr ( input ( <STRING> ) ) <NEWLINE> if W >= S : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s = input ( : ) <NEWLINE> w = input ( : ) <NEWLINE> S = int ( s ) <NEWLINE> W = int ( w ) <NEWLINE> if S <= W : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
S , W = map ( int , input . split ( ) ) <NEWLINE> <NL> print ( <STRING> if W >= S else <STRING> ) <NEWLINE>
s , w = map ( int , input ( ) . split ( ) ) <NEWLINE> if s <= w : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> else : <NEWLINE> print ( <STRING> ) <NEWLINE> <DEDENT>
s , w = map ( int , input ( ) . split ( ) ) <NEWLINE> if ( s <= w ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> else : <NEWLINE> print ( <STRING> ) <NEWLINE> <DEDENT>
s , w = map ( int , input ( ) , split ( ) ) <NEWLINE> if w > s : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
S , W = map ( int , input ( ) . split ( ) ) <NEWLINE> if S > W : <NEWLINE> <INDENT> print ( safe ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( unsafe ) <NEWLINE> <DEDENT>
s = int ( input ( ) ) <NEWLINE> w = int ( input ( ) ) <NEWLINE> if s <= w : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s , w = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if s > w : <NEWLINE> <INDENT> return ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return ( <STRING> ) <NEWLINE> <DEDENT>
S , W = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if W >= S : <NEWLINE> <INDENT> print ( unsafe ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( safe ) <NEWLINE> <DEDENT>
S , W = map ( int , input ( ) . split ( ) ) if W >= S : print ( <STRING> ) else : print ( <STRING> ) <NEWLINE>
N = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> if N [ 0 ] / 2 = > N [ 1 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
input_line = input ( ) <NEWLINE> S = int ( input_line [ 0 ] ) <NEWLINE> W = int ( input_line [ 1 ] ) <NEWLINE> if S > W : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
S , W = list ( map ( int , input ( ) split ( ) ) ) <NEWLINE> print ( <STRING> if S > W else <STRING> ) <NEWLINE>
a = input ( ) <NEWLINE> b = input ( ) <NEWLINE> if b >= a : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
<NL> S , W = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> <NL> if S < W : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if b > a : <NEWLINE> <INDENT> priant ( <STRING> ) <NEWLINE> <DEDENT> elif a > b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a = int ( input ( ) ) <NEWLINE> b , c = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> s = input ( ) <NEWLINE> print ( a + b + c , s ) <NEWLINE> <NL>
nums = input ( ) <NEWLINE> S = int ( nums . split ( <STRING> ) [ 0 ] ) <NEWLINE> W = int ( nums . split ( <STRING> ) [ 1 ] ) <NEWLINE> <NL> if W >= S : <NEWLINE> <INDENT> print ( unsafe ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b , c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> if a / d > c / d : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
S = int ( input ( ) ) <NEWLINE> W = int ( input ( ) ) <NEWLINE> <NL> if S < W : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s , w = input ( ) . int ( <STRING> ) <NEWLINE> <NL> s = int ( s ) <NEWLINE> w = int ( w ) <NEWLINE> <NL> if w >= s : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s , w = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if s <= W : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s . w = map ( int , input ( ) . split ( ) ) <NEWLINE> if s <= w : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
li = str . split ( ) <NEWLINE> if ( eval ( li [ 0 ] ) <= eval ( li [ 1 ] ) ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n , m = map ( input , int ( ) . split ( ) ) <NEWLINE> if ( n > m ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s , w = map ( int , input ( ) . split ( ) ) <NEWLINE> if s > f : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
S = int ( input ( ) ) <NEWLINE> W = int ( input ( ) ) <NEWLINE> if W >= S : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s , w = map ( int , input . split ( ) ) <NEWLINE> if w >= s : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s , w = map ( int . input ( ) . split ( ) ) <NEWLINE> print ( <STRING> if w >= s else <STRING> ) <NEWLINE>
try : <NEWLINE> <INDENT> s , w = map ( int , input ( ) . split ( ) ) <NEWLINE> if ( w >= s ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> else : <NEWLINE> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> except : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT>
S = int ( input ( ) ) <NEWLINE> W = int ( input ( ) ) <NEWLINE> if W >= ( S ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
S , W = map ( int , input ( ) . split ( ) ) <NEWLINE> if S = < W : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
S , W = map ( int , input ( ) . split ( ) ) <NEWLINE> <INDENT> if S >= W : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else S < W : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
s , w = input ( ) . split ( ) <NEWLINE> if s > w : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <NL> <NL> <NL> <DEDENT>
s , w = [ int ( x ) for x in input ( ) . splir ( ) ] <NEWLINE> <NL> if ( s > w ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
<NL> a = list . map ( int , input ( ) . split ( ) ) <NEWLINE> if a [ 1 ] >= a [ 0 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s , w = map ( int , input ( ) ) <NEWLINE> if s <= w : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s , w = map ( int , input ( ) ) <NEWLINE> print ( <STRING> if s <= w else <STRING> ) <NEWLINE>
S = input ( ) <NEWLINE> W = input ( ) <NEWLINE> <NL> def sheep_wold ( S = S , W = W ) : <NEWLINE> <INDENT> if S <= W : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
s , w = int ( input ( ) . split ) <NEWLINE> <NL> if w >= s : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
S , W = map ( int12 , input ( ) . split ( ) ) <NEWLINE> if S > W : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
S , W = map ( lambda x : int ( x ) , input ( ) . split ( ) ) <NEWLINE> if S > W : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
W : int <NEWLINE> S : int <NEWLINE> <NL> if W >= S : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
S , W = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if S < W : <NEWLINE> <INDENT> print ( unsafe ) <NEWLINE> <DEDENT> if S > W : <NEWLINE> <INDENT> print ( safe ) <NEWLINE> <DEDENT>
S , W = input ( ) . split ( <STRING> ) <NEWLINE> S = int ( S ) <NEWLINE> <NL> W = int ( W ) <NEWLINE> <NL> if W >= S : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s , w = map ( int , input ( ) ) <NEWLINE> if w >= s : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s , w = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if s < w <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
S = int ( input ( ) ) <NEWLINE> W = int ( input ( ) ) <NEWLINE> if S <= W : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
S , W = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if S > W : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> if S < W : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> if S = W : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s , w = int ( input ( ) ) <NEWLINE> if s <= w : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
S , W = map ( int , intput ( ) . split ( ) ) <NEWLINE> if S <= W : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s , w = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> if w >= n : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : print ( <STRING> ) <NEWLINE>
A , B , C , D = map ( int , input ( ) . split ( ) ) <NEWLINE> while True : <NEWLINE> <INDENT> C = C - B <NEWLINE> if C <= 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> A = A - D <NEWLINE> if A <= 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> if A >= C else <STRING> ) <NEWLINE>
s , w = map ( int ( input ( ) . split ( ) ) ) <NEWLINE> if s <= w : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> read = sys . stdin . buffer . read <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> readlines = sys . stdin . buffer . readlines <NEWLINE> <NL> S , W = map ( int , readline ( ) ) <NEWLINE> <NL> <NL> if S > W : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s = int ( input ( ) ) <NEWLINE> w = int ( input ( ) ) <NEWLINE> if s < w : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s , w = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> res = <STRING> <NEWLINE> if w >= s : <NEWLINE> <INDENT> res = <STRING> <NEWLINE> <DEDENT> print ( res ) <NEWLINE>
S , W = map ( int , input ( ) . split ( ) ) <NEWLINE> if W >= S : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) S , W = map ( int , input ( ) . split ( ) ) <NEWLINE> <DEDENT> if W >= S : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
S , W = ( int ( a ) for a in input ( ) . split ( ) ) <NEWLINE> if S <= W : <NEWLINE> <INDENT> prit ( <STRING> ) <NEWLINE> <DEDENT> else : print ( <STRING> ) <NEWLINE>
<NL> def solve ( ) : <NEWLINE> <INDENT> s = int ( input ( ) ) <NEWLINE> w = int ( input ( ) ) <NEWLINE> <NL> if ( w >= s ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> return <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> solve ( ) <NEWLINE> <DEDENT>
s = int ( input ( ) ) <NEWLINE> w = int ( input ( ) ) <NEWLINE> if w >= s : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s , w = input ( ) <NEWLINE> if s <= w : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import itertools <NEWLINE> s = input ( ) <NEWLINE> count = 0 <NEWLINE> <NL> for i , j in itertools . combinations ( range ( 0 , len ( str ( s ) ) + 1 ) , 2 ) : <NEWLINE> <INDENT> if int ( s [ i : j ] ) % 2019 == 0 : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> print ( s [ i : j ] ) <NEWLINE> <DEDENT> print ( count ) <NEWLINE>
s , w = int ( input ( ) ) <NEWLINE> <NL> if s > w : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s , w = map ( input ( ) . split ( ) , int ) <NEWLINE> print ( <STRING> if w >= s else <STRING> ) <NEWLINE>
S . W = map ( int , input ( ) . split ( ) ) <NEWLINE> if W >= S : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
S = int ( input ( <STRING> ) ) <NEWLINE> W = int ( input ( <STRING> ) ) <NEWLINE> if W >= S : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
S = input ( sheeps : ) <NEWLINE> W = input ( wolfs : ) <NEWLINE> <NL> if S > W : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
S , W = map ( int , input ( ) . split ( ) ) <NEWLINE> if W >= S : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> <NEWLINE> <DEDENT>
<NL> s , w = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <NL> if s > w : <NEWLINE> <INDENT> print ( safe ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( unsafe ) <NEWLINE> <DEDENT>
S = int ( input ( ) ) <NEWLINE> W = int ( input ( ) ) <NEWLINE> if W < S : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s = int ( input ( ) ) <NEWLINE> w = int ( input ( ) ) <NEWLINE> <NL> if w >= s : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
A = int ( input ( ) ) <NEWLINE> B = int ( input ( ) ) <NEWLINE> C = int ( input ( ) ) <NEWLINE> D = int ( input ( ) ) <NEWLINE> while ( A > 0 and C > 0 ) : <NEWLINE> <INDENT> C = C - B <NEWLINE> if C <= 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> A = A - D <NEWLINE> <DEDENT> print ( <STRING> if C <= 0 else <STRING> ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> if ( N <= K ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> <NEWLINE> <DEDENT>
s = int ( input ( ) ) <NEWLINE> w = int ( input ( ) ) <NEWLINE> if w >= s : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s , w = [ int ( s ) for s in intput ( ) . split ( <STRING> ) ] <NEWLINE> if w >= s : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b = map ( int , input ( ) . split ( ) ) ] <NEWLINE> if a <= b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a > b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s , w = map ( int , input ( ) . split ( ) ) <NEWLINE> if n <= m : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s , w = map ( int , input ( ) . split ( ) ) <NEWLINE> if w > s or w = s : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s , w = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if s = < w : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s , w = int ( input ( ) . split ( ) ) <NEWLINE> <NL> if s <= w : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> args = sys . argv <NEWLINE> if int ( args [ 0 ] ) <= int ( args [ 1 ] ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
t_hp , t_at , a_hp , a_at = input ( ) . split ( ) <NEWLINE> while ( int ( t_hp ) > 0 and int ( a_hp ) > 0 ) : <NEWLINE> <INDENT> int ( a_hp ) -= int ( t_at ) <NEWLINE> if int ( a_hp ) <= 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> int ( t_hp ) -= int ( a_at ) <NEWLINE> if int ( t_hp <= 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT>
a , b , c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> for i in range ( 200 ) : <NEWLINE> <INDENT> c = c - b <NEWLINE> if c <= 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> a = a - d <NEWLINE> if a <= 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> a , b , c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> for i in range ( 200 ) : <NEWLINE> <INDENT> c = c - b <NEWLINE> if c <= 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> a = a - d <NEWLINE> <DEDENT> if a <= 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT>
a , b , c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <NL> if ( - ( - c // b ) ) <= ( - ( - a // d ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b , c , d = input ( ) . split ( ) <NEWLINE> a = int ( a ) <NEWLINE> b = int ( b ) <NEWLINE> c = int ( c ) <NEWLINE> d = int ( d ) <NEWLINE> <NL> result = <STRING> <NEWLINE> while True : <NEWLINE> <INDENT> c -= b <NEWLINE> if c = < 0 : <NEWLINE> <INDENT> result = <STRING> <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> a -= d <NEWLINE> if a = < 0 : <NEWLINE> <INDENT> result = <STRING> <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( result ) <NEWLINE> <NL> <NL> <NL>
heart_taka , power_taka , heart_aoki , power_aoki = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> aliveTaka = True <NEWLINE> aliveAoki = True <NEWLINE> while ( aliveTaka ) or ( aliveAoki ) : <NEWLINE> <INDENT> heart_aoki -= power_taka <NEWLINE> heart_taka -= power_aoki <NEWLINE> if heart_aoki <= 0 : <NEWLINE> <INDENT> aliveAoki = False <NEWLINE> <DEDENT> if heart_taka <= 0 : <NEWLINE> <INDENT> aliveTaka = False <NEWLINE> <NL> <DEDENT> <DEDENT> if aliveAoki == False : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> return <STRING> <NEWLINE>
a , b , c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> for i in range ( 100 ) : <COMMENT> <NEWLINE> <INDENT> c -= b <COMMENT> <NEWLINE> <COMMENT> <NL> if c <= 0 > : <COMMENT> <NEWLINE> <INDENT> print ( <STRING> ) <COMMENT> <NEWLINE> break <COMMENT> <NEWLINE> <NL> <DEDENT> a -= d <COMMENT> <NEWLINE> <COMMENT> <NL> if a < 1 : <COMMENT> <NEWLINE> <INDENT> print ( <STRING> ) <COMMENT> <NEWLINE> break <COMMENT> <NEWLINE> <COMMENT> <NL> <NEWLINE> <DEDENT> <DEDENT>
import math <NEWLINE> if ( math . ceil ( a / d ) >= math . ceil ( c / b ) ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
A , B , C , D = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> while A or C > 0 : <NEWLINE> <INDENT> A -= D <NEWLINE> C -= B <NEWLINE> <NL> <DEDENT> if A >= C : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
A , B , C , D = map ( int , input ( ) . split ( ) ) <NEWLINE> while A > 0 & & C > 0 : <NEWLINE> <INDENT> C = C - B <NEWLINE> A = A - D <NEWLINE> <NL> <DEDENT> if C < 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
[ S , W ] = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if W >= S : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
A , B , C , D = map ( int , input ( ) . split ( ) ) <NEWLINE> while True : <NEWLINE> <INDENT> C -= B <NEWLINE> if c <= 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> A -= D <NEWLINE> if a <= 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT>
a = int ( input ( ) ) <NEWLINE> b = int ( input ( ) ) <NEWLINE> c = int ( input ( ) ) <NEWLINE> d = int ( input ( ) ) <NEWLINE> <NL> while a > 0 and c > 0 : <NEWLINE> <INDENT> if c > 0 : <NEWLINE> <INDENT> c += - b <NEWLINE> <NL> <DEDENT> if c <= 0 : <NEWLINE> <INDENT> break <NEWLINE> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> if a > 0 : <NEWLINE> <INDENT> a += - d <NEWLINE> <NL> <DEDENT> if a <= 0 : <NEWLINE> <INDENT> break <NEWLINE> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
s , w = map ( int , input ( ) . split ( ) ) <NEWLINE> if w >= s : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
A , B , C , D = map ( int , input ( ) . split ( ) ) <NEWLINE> for i in range ( 0 , 99 ) : <NEWLINE> <INDENT> C = C - B <NEWLINE> if C <= 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> A = A - D <NEWLINE> <INDENT> if A <= 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT>
a , b , c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> while : <NEWLINE> <INDENT> c = c - b <NEWLINE> if c <= 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> a = a - d <NEWLINE> if a <= 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT>
a , b , c , d = map ( int , input ( ) . split ( ) ) <NEWLINE>  <NEWLINE> while True : <NEWLINE> <COMMENT> <NL> <INDENT> c -= b <NEWLINE> if c <= 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <COMMENT> <NL> <DEDENT> a -= d <NEWLINE> if a <= 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT>
a , b , c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> while True : <NEWLINE> <INDENT> b -= c <NEWLINE> if c <= 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> a -= d <NEWLINE> if a <= 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT>
A , B , C , D = map ( int , input ( ) ) <NEWLINE> if ( A / D < C / B ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
while C > 0 and A > 0 : <NEWLINE> <INDENT> C -= B <NEWLINE> A -= D <NEWLINE> if C <= 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif A <= 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> <DEDENT>
a , b , c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> while True : <NEWLINE> <INDENT> c -= b <NEWLINE> if ( c <= 0 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> a -= d <NEWLINE> if ( a <= 0 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
a , b , c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if a / d > c / b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a / d == c / b : <NEWLINE> <INDENT> if c / b > 0 and a / d == 0 <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> elif a / d + 1 == c / b : <NEWLINE> <INDENT> if c % b == 0 and a % d != 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b , c , d = input ( ) . split ( ) <NEWLINE> print ( <STRING> ) if ( a // d + 1 ) < ( c // b + 1 ) else print ( <STRING> ) <NEWLINE>
while A > 0 and C > 0 : <NEWLINE> <INDENT> C -= B <NEWLINE> if C <= 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> A -= D <NEWLINE> if A <= 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> A , B , C , D = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> while True : <NEWLINE> <INDENT> C = C - B <NEWLINE> A -= D <NEWLINE> print ( C ) <NEWLINE> print ( A ) <NEWLINE> if C <= 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( 1 ) <NEWLINE> <DEDENT> elif A <= 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( 1 ) <NEWLINE> <DEDENT> <DEDENT>
tt , ta , at , aa = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> for i in range ( 100 ) : <NEWLINE> <INDENT> at -= ta <NEWLINE> if at - ta > 0 : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> elif at - ta <= 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> tt -= aa <NEWLINE> elif tt - aa > 0 : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> elif tt - aa <= 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT>
a , b , c , d = map ( int , input ( ) . split ) <NEWLINE> count_T = ( a - 1 ) // b + 1 <NEWLINE> count_A = ( c - 1 ) // d + 1 <NEWLINE> <NL> if count_T <= count_A : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
T_HP , T_Atk , A_HP , A_Atk = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> Takahashi = [ T_HP , T_Atk ] <NEWLINE> Asakura = [ A_HP , A_Atk ] <NEWLINE> <NL> <NL> while True : <NEWLINE> <INDENT> Asakura [ 0 ] - Takahashi [ 1 ] <NEWLINE> if Asakura [ 0 ] < 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <NL> <DEDENT> Takahashi [ 0 ] - Asakura [ 1 ] <NEWLINE> if Takahashi [ 0 ] < 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT>
A , B , C , D = map ( int , imput ( ) . split ( ) ) <NEWLINE> x = C // B <NEWLINE> y = A // D <NEWLINE> if x >= y : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
A , B , C , D = map ( int , input ( ) . split ( ) ) <NEWLINE> win = A / D <NEWLINE> lose = C / B <NEWLINE> if win = > lose : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if lose <= 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if lose - win < 1 and A % D != 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
a , b , c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> while a >= 0 and c >= 0 : <NEWLINE> <INDENT> c = c - b <NEWLINE> if c <= 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( <STRING> ) <NEWLINE> <DEDENT> a = a - d <NEWLINE> if a <= 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
a , b , c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> turn = 0 <NEWLINE> while a > 0 or c > 0 : <NEWLINE> <INDENT> if turn % 2 == 0 : <NEWLINE> <INDENT> c -= b <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a -= d <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> if a > 0 else <STRING> ) <NEWLINE>
print ( C / B ) <NEWLINE> print ( A / D ) <NEWLINE> if ( math . ceil ( C / B ) - math . ceil ( A / D ) ) < 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
<INDENT> vals = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> a = vals [ 0 ] <NEWLINE> b = vals [ 1 ] <NEWLINE> c = vals [ 2 ] <NEWLINE> d = vals [ 3 ] <NEWLINE> res2 = a // d + ( 1 if ( a % d > 0 ) else 0 ) <NEWLINE> res1 = c // b + ( 1 if ( c % b > 0 ) else 0 ) <NEWLINE> res = <STRING> if ( res1 <= res2 ) else <STRING> <NEWLINE> print ( res ) <NEWLINE> <DEDENT>
a , b , c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> for _ in range ( 100 ) : <NEWLINE> <INDENT> a , c -= d , b <NEWLINE> if b < 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> if a < 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT>
a , b , c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> aok = 0 <NEWLINE> while c > 0 : <NEWLINE> <INDENT> c = c - b <NEWLINE> aok += 1 <NEWLINE> <NL> <DEDENT> if ( ( aok - 1 ) * d - a ) = > 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import math <NEWLINE> a , b , c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> d1 = math . ceil ( C / B ) <NEWLINE> d2 = math . ceil ( A / D ) <NEWLINE> <NL> if d1 <= d2 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a = int ( input ( ) ) <COMMENT> <NEWLINE> b = int ( input ( ) ) <NEWLINE> c = int ( input ( ) ) <COMMENT> <NEWLINE> d = int ( input ( ) ) <NEWLINE> flag = True <NEWLINE> while flag : <NEWLINE> <INDENT> c -= b <NEWLINE> if ( c <= 0 ) : <NEWLINE> <INDENT> flag = False <NEWLINE> print ( <STRING> ) <NEWLINE> break <NEWLINE> <NL> <DEDENT> a -= d <NEWLINE> if ( a <= 0 ) : <NEWLINE> <INDENT> falg = False <NEWLINE> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT>
a , b , c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> while True : <NEWLINE> <INDENT> b -= c <NEWLINE> if c <= 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> a -= d <NEWLINE> if a <= 0 : <NEWLINE> print ( <STRING> ) <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT>
a , b , c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> while b < 1 or d < 1 : <NEWLINE> <INDENT> a = a - d <NEWLINE> <INDENT> if a < 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> c = c - b <NEWLINE> <INDENT> if c < 1 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if a < 0 or a == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b , c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> while True : <NEWLINE> <INDENT> c -= b <NEWLINE> if c <= 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> a -= d <NEWLINE> if a <= 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
import math <NEWLINE> a , b , c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> a = math . ceil ( a // d ) <NEWLINE> b = math . ceil ( b // c ) <NEWLINE> if = a <= b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b , c , d = map ( int , input ( ) split ( ) ) <NEWLINE> while ( a > 0 and c > 0 ) : <NEWLINE> <INDENT> c = c - b <NEWLINE> if c <= 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> a = a - d <NEWLINE> <DEDENT> print ( <STRING> if c <= 0 else <STRING> ) <NEWLINE>
a , b , c , d = map ( int , input . split ( ) ) <NEWLINE> while a or c > 0 : <NEWLINE> <INDENT> c = c - b <NEWLINE> if c <= 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> a = a - d <NEWLINE> if a <= 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT>
li = [ input ( ) for i in range ( 4 ) ] <NEWLINE> <NL> while ( ( li [ 0 ] > 0 ) and ( li [ 2 ] > 0 ) ) : <NEWLINE> <INDENT> li [ 2 ] = li [ 2 ] - li [ 1 ] <NEWLINE> <INDENT> if li [ 2 ] <= 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> li [ 0 ] = li [ 0 ] - li [ 3 ] <NEWLINE> <INDENT> if li [ 0 ] <= 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
K = input ( ) . split ( <STRING> ) <NEWLINE> k = [ int ( n ) for n in K ] <NEWLINE> t = k [ 0 ] // k [ 3 ] <NEWLINE> a = k [ 2 ] // k [ 1 ] <NEWLINE> t1 = k [ 0 ] % k [ 3 ] <NEWLINE> a1 = k [ 2 ] % k [ 1 ] <NEWLINE> if t > a : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif t == a and a1 /= 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif t == a and t1 /= 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
<COMMENT> <NL> tairyoku_A , kougeki_B , tairyoku_C , kougeki_D = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> one = int ( tairyoku_A / kougeki_D ) <NEWLINE> two = int ( tairyoku_C / kougeki_B ) <NEWLINE> <NL> <NL> if ( one > two ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b , c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> aoki = c <NEWLINE> takahashi = a <NEWLINE> <NL> for i in range ( 101 ) : <NEWLINE> <INDENT> if takahashi - d > 0 : <NEWLINE> <INDENT> if aoki - b = < 0 : <COMMENT> <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> else : <COMMENT> <NEWLINE> <INDENT> takahashi = takahashi - d <NEWLINE> aoki = aoki - c <NEWLINE> continue <NEWLINE> <DEDENT> <DEDENT> else : <COMMENT> <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT>
a , b , c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> if c % b = < a % d : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b , c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> while True : <NEWLINE> <INDENT> c -= b <NEWLINE> a -= d <NEWLINE> <INDENT> if c <= 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> if a <= 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
A , B , C , D = map ( int , input ( ) . split ( ) ) <NEWLINE> while if A > 0 and C > 0 : <NEWLINE> <INDENT> A -= D <NEWLINE> C -= B <NEWLINE> <DEDENT> if C > 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> C = C - B <NEWLINE> if C <= 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> A = A - D <NEWLINE> if A <= 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT>
A , B , C , D = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> while True : <NEWLINE> <INDENT> C -= B <NEWLINE> if C <= 0 : <NEWLINE> <INDENT> input ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> A -= D <NEWLINE> elif A <= 0 : <NEWLINE> <INDENT> input ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT>
A , B , C , D = [ int ( s ) for s in input ( ) . split ( ) ] <NEWLINE> turn = 0 <NEWLINE> while A > 0 and C > 0 : <NEWLINE> <INDENT> if turn == 0 : <NEWLINE> <INDENT> C -= B <NEWLINE> turn = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> A -= D <NEWLINE> turn = 0 <NEWLINE> <DEDENT> <DEDENT> if A > 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b , c , d = input ( ) . split ( ) <NEWLINE> a = int ( a ) <NEWLINE> b = int ( b ) <NEWLINE> c = int ( c ) <NEWLINE> d = int ( d ) <NEWLINE> while true : <NEWLINE> <INDENT> c = c - b <NEWLINE> if c <= 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> a = a - d <NEWLINE> if a <= 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT>
A , B , C , D = map ( int , input ( ) . split ( ) ) <NEWLINE> for i in 100 : <NEWLINE> <INDENT> C -= B <NEWLINE> A -= D <NEWLINE> if C <= 0 and A <= 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif C > 0 and A <= 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> <DEDENT>
a , b , c , d = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if math . ceil ( c / b ) > math . ceil ( a / d ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT>
a , b , c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> r1 = a // d <NEWLINE> rem1 = a % d <NEWLINE> r2 = c // b <NEWLINE> rem2 = c % b <NEWLINE> if r1 >= r2 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> else : <NEWLINE> print ( <STRING> ) <NEWLINE> <DEDENT>
A , B , C , D = map ( int ( input ( ) . split ( ) ) ) <NEWLINE> while A > 0 and C > 0 : <NEWLINE> <INDENT> C -= B <NEWLINE> if C <= 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> A -= D <NEWLINE> if A <= 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
a , b , c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> while True : <NEWLINE> <INDENT> c = c - b <NEWLINE> if c < = 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> a = a - d <NEWLINE> <DEDENT> if a < = 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT>
A , B , C , D = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> while check : <NEWLINE> <INDENT> C = C - B <NEWLINE> <INDENT> if C <= 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> A = A - D <NEWLINE> if A <= 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
A , B , C , D = map ( int , input ( ) . split ( ) ) <NEWLINE> while A > 0 and C > 0 : <NEWLINE> <INDENT> C = C - B <NEWLINE> A = A - D <NEWLINE> <DEDENT> if : A == 0 : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
TH , TS , AH , AS = map ( int , input ( ) . split ( ) ) <NEWLINE> while Ture : <NEWLINE> <INDENT> AH -= TS <NEWLINE> if AH <= 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> TH -= AS <NEWLINE> if TH <= 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
A , B , C , D = map ( int , input ( ) . split ( ) ) <NEWLINE> STOP = <STRING> <NEWLINE> a = 0 <NEWLINE> while STOP != <STRING> : <NEWLINE> <INDENT> A = A - B <NEWLINE> D = D - C <NEWLINE> if A <= 0 : <NEWLINE> <INDENT> a = 1 <NEWLINE> <DEDENT> if D <= 0 : <NEWLINE> <INDENT> a = 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> <DEDENT> if a == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
A , B , C , D = map ( int , input ( ) . split ( ) ) <NEWLINE> while A > 0 and c > 0 : <NEWLINE> <INDENT> C -= B <NEWLINE> if C <= 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> A -= D <NEWLINE> if A <= 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> import math <NEWLINE> try : <NEWLINE> <INDENT> sys . stdin = open ( <STRING> , <STRING> ) <NEWLINE> sys . stdout = open ( <STRING> , <STRING> ) <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> input = sys . stdin . readline <NEWLINE> for tt in range ( 1 ) : <NEWLINE> <INDENT> a , b , c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> elif math . ceil ( c / b ) - math . ceil ( a / d ) <= 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
import math <NEWLINE> tl , ta , al , aa = map ( int , input ( ) . split ( <STRING> ) <NEWLINE> print ( <STRING> if math . ceil ( al / ta ) < math . ceil ( tl / aa ) else <STRING> ) <NEWLINE>
a , b , c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> takahashi = [ a , b ] if a > b else [ b , a ] <NEWLINE> aoki = [ c , d ] if c > d else [ d , c ] <NEWLINE> attackers = [ takahashi , aoki ] <NEWLINE> attacker = 0 <NEWLINE> <NL> while 0 not in takahashi and 0 not in aoki : <NEWLINE> <INDENT> attackers [ attacker ^ 1 ] [ 1 ] = max ( 0 , attackers [ attacker ^ 1 ] [ 1 ] - attackers [ attacker ] [ 0 ] ) <NEWLINE> attackers [ attacker ^ 1 ] . sort ( reversed = True ) <NEWLINE> attacker = attacker ^ 1 <NEWLINE> <NL> <DEDENT> if 0 in attackers [ 0 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
mport math <NEWLINE> a , b , c , d = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> taka = math . ceil ( c / b ) <NEWLINE> aoki = math . ceil ( a / d ) <NEWLINE> <NL> if taka <= aoki : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
items = list ( input ( ) . split ( ) ) <NEWLINE> <INDENT> T_health = int ( items [ 0 ] ) <NEWLINE> T_strength = int ( items [ 1 ] ) <NEWLINE> A_health = int ( items [ 2 ] ) <NEWLINE> A_strength = int ( items [ 3 ] ) <NEWLINE> while ( T_health > 0 and A_health > 0 ) : <NEWLINE> <INDENT> A_health -= T_strength <NEWLINE> if ( A_health > 0 ) : <NEWLINE> <INDENT> T_health -= A_strength <NEWLINE> <DEDENT> <DEDENT> if ( T_health <= 0 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> if ( A_health <= 0 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
a , b , c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> while ( True ) : <NEWLINE> <INDENT> c -= b <NEWLINE> if ( c <= 0 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> a -= d : <NEWLINE> if ( a <= 0 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT>
t_at , t_hp , a_at , a_hp = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> while True : <NEWLINE> <INDENT> a_hp -= t_at <NEWLINE> if a_hp <= 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> t_hp -= a_at <NEWLINE> if t_hp <= 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT>
N = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> if not N [ 2 ] % N [ 1 ] == 0 : <NEWLINE> <INDENT> c = N [ 2 ] // N [ 1 ] + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> c = N [ 2 ] // N [ 1 ] <NEWLINE> <DEDENT> if not N [ 0 ] % N [ 3 ] == 0 : <NEWLINE> <INDENT> c = N [ 0 ] // N [ 3 ] + 1 <NEWLINE> <NL> d = N [ 0 ] // N [ 3 ] + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d = N [ 0 ] // N [ 3 ] <NEWLINE> <DEDENT> if d = > c : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b , c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> while True : <NEWLINE> <INDENT> c -= b <NEWLINE> if c <= 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> a -= d <NEWLINE> if a <= 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
A = map ( int , input ( ) . split ( ) ) <NEWLINE> while ( A > 0 and C > 0 ) : <NEWLINE> <INDENT> C = C - B <NEWLINE> if C <= 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> A = A - D <NEWLINE> <DEDENT> print ( <STRING> if C <= 0 else <STRING> ) <NEWLINE>
a , b , c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> t_hp = a <NEWLINE> a_hp = c <NEWLINE> while a_hp > 0 or t_hp > 0 : <NEWLINE> <INDENT> a_hp -= b <NEWLINE> t_hp -= d <NEWLINE> <INDENT> if a_hp <= 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> elif t_hp <= 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
A , B , C , D = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> flg = true <NEWLINE> t = false <NEWLINE> while ( flg ) : <NEWLINE> <INDENT> t = true <NEWLINE> C -= B <NEWLINE> if ( C <= 0 ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> t = false <NEWLINE> A -= D <NEWLINE> if ( A <= 0 ) : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> if ( t ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
k = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> t = k [ 0 ] // k [ 3 ] <NEWLINE> a = k [ 2 ] // k [ 1 ] <NEWLINE> if t >= k : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A = list [ 0 ] <NEWLINE> B = list [ 1 ] <NEWLINE> C = list [ 2 ] <NEWLINE> D = list [ 3 ] <NEWLINE> <NL> while A > 0 and B > 0 : <NEWLINE> <INDENT> C = C - B <NEWLINE> if C = < 0 : break <NEWLINE> A = A - D <NEWLINE> <NL> <DEDENT> if A > 0 : print ( <STRING> ) <NEWLINE> else : print ( <STRING> ) <NEWLINE>
import math <NEWLINE> A , B , C , D = map ( int , input ( ) . split ( ) ) <NEWLINE> hpa = math . ceil ( A / D ) <NEWLINE> hhb = math . ceil ( C / B ) <NEWLINE> if ( hpa >= hpb ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
A , B , C , D = map ( int , input ( ) . split ( ) ) <NEWLINE> for num in range ( 0 , ) : <NEWLINE> <INDENT> aoki = C - B <NEWLINE> taka = A - D <NEWLINE> if ( aoki or taka ) <= 0 : break <NEWLINE> else : pass <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> if aoki <= 0 : print ( <STRING> ) <NEWLINE> elif taka <= 0 : print ( <STRING> ) <NEWLINE>
f = True <NEWLINE> while True : <NEWLINE> <INDENT> if f : <NEWLINE> <INDENT> C = C - B <NEWLINE> f = False <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> A = A - D <NEWLINE> f = True <NEWLINE> <DEDENT> if A <= 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> elif C <= 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <DEDENT> <DEDENT>
A , B , C , D = map ( int , input ( ) . split ( ) ) <NEWLINE> if ( C // B ) < ( A // D ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif ( C // B ) = ( A // D ) and A % D = 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b , c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> while a > 0 and c > 0 : <NEWLINE> <INDENT> c = c - b <NEWLINE> a = a - d <NEWLINE> <DEDENT> if a = 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
46 4 40 5 <NEWLINE>
A , B , C , D = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> while True : <NEWLINE> <INDENT> C -= B <NEWLINE> if C <= 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> A -= D <NEWLINE> if A <= 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
A , B , C , D = map ( int , input ( ) . split ( ) ) <NEWLINE> while true : <NEWLINE> <INDENT> A -= D <NEWLINE> B -= C <NEWLINE> if A <= 0 or B <= 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> if A <= 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
, c , d , = map ( int , input ( ) . split ( ) ) <NEWLINE> def func ( a , b , c , d ) : <NEWLINE> <INDENT> while a >= 0 and c >= 0 : <NEWLINE> <INDENT> c -= b <NEWLINE> a -= d <NEWLINE> <DEDENT> return <STRING> if a >= c else <STRING> <NEWLINE> <DEDENT> print ( func ( a , b , c , d ) ) <NEWLINE>
A , B , C , D = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> while A > 0 or B > 0 : <NEWLINE> <INDENT> A -= D <NEWLINE> C -= B <NEWLINE> <DEDENT> if A <= 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif B <= 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT>
a , b , c , d = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> while True : <NEWLINE> <INDENT> c -= b <NEWLINE> if c <= 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> a -= d <NEWLINE> if a <= 0 : <NEWLINE> <INDENT> pinrt ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT>
a , b , c , d == map ( int , input ( ) . split ( ) ) <NEWLINE> if a % d = 0 : <NEWLINE> <INDENT> e = a / d <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> e = a / d + 1 <NEWLINE> <NL> <DEDENT> if c % d == 0 : <NEWLINE> <INDENT> f = c / b <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> f = a / d + 1 <NEWLINE> <NL> <DEDENT> if e > f : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif e == f : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
th , ts , ah , ae = map ( int , input ( ) . split ( ) ) <NEWLINE> while ( th > 0 & & ah > 0 ) : <NEWLINE> <INDENT> ah = ah - ts <NEWLINE> if ( ah <= 0 ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> th = th - ae <NEWLINE> <DEDENT> <DEDENT> if ( th > 0 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
ok = True <NEWLINE> i = 0 <NEWLINE> a , b , c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> k = c // b <NEWLINE> c -= bk <NEWLINE> a -= d ( k ) <NEWLINE> if ( a <= 0 and c != 0 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b , c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> cnt = 0 <NEWLINE> while True : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> if cnt % 2 == 0 : <NEWLINE> <INDENT> s = a - ( cnt / 2 ) * d <NEWLINE> if s <= 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> s = c - ( cnt + 1 ) / 2 * b <NEWLINE> if s <= 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
A , B , C , D = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> while A or C > 0 : <NEWLINE> <INDENT> aoki_hitpoint = C - B <NEWLINE> if aoki_hitpoint <= 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> C = aoki_hitpoint <NEWLINE> <NL> <DEDENT> takahashi_hitpoint = A - D <NEWLINE> if takahashi_hitpoint <= 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> A = takahashi_hitpoint <NEWLINE> <DEDENT> <DEDENT>
a , b , c , d = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> turn = True <NEWLINE> while True : <NEWLINE> <INDENT> if turn : <NEWLINE> <INDENT> c -= b <NEWLINE> if c <= 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> a -= d <NEWLINE> if a <= 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> turn ^= True <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> S , W = map ( int , input ( ) . split ( ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> if S <= W : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
<INDENT> a , b , c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> <DEDENT> ah = a <NEWLINE> ch = c <NEWLINE> while ( 1 ) : <NEWLINE> <INDENT> ah -= d <NEWLINE> ch -= b <NEWLINE> if ( ch <= 0 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> elif ( ah <= 0 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <NL> <NL> <DEDENT> <DEDENT>
from math import inf <NEWLINE> A , B , C , D = map ( int , input ( ) . split ( ) ) <NEWLINE> for i in range ( inf ) : <NEWLINE> <INDENT> if i % 2 == 0 : <NEWLINE> <INDENT> D -= A <NEWLINE> if D == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> B -= C <NEWLINE> if B == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
a , b , c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> while True : <NEWLINE> <INDENT> c -= b <NEWLINE> <INDENT> if c <= 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a -= d <NEWLINE> if a <= 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT>
a , b , c , d = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> while True : <NEWLINE> <INDENT> c -= b <NEWLINE> if c <= 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> a -= d <NEWLINE> if a <= 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT>
<INDENT> a , b , c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> <DEDENT> while ( a > 0 or c > 0 ) : <NEWLINE> <INDENT> c -= b <NEWLINE> a -= d <NEWLINE> <DEDENT> if a <= 0 and c > 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif c <= 0 and a > 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a <= 0 and c <= 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b , c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> flag = <STRING> <NEWLINE> while flag = <STRING> : <NEWLINE> <INDENT> c = c - b <NEWLINE> if c <= 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> a = a - d <NEWLINE> if a <= 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT>
buf = input ( ) . split ( ) <NEWLINE> th = int ( buf [ 0 ] ) <NEWLINE> ts = int ( buf [ 1 ] ) <NEWLINE> ah = int ( buf [ 2 ] ) <NEWLINE> as = int ( buf [ 3 ] ) <NEWLINE> <NL> while True : <NEWLINE> <INDENT> ah -= ts <NEWLINE> if ah <= 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> th -= as <NEWLINE> if th <= 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> if ah <= 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> if th <= 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
A , B , C , D = [ int ( n ) for n in input ( ) . split ( <STRING> ) ] <NEWLINE> <NL> while True : <NEWLINE> <INDENT> C -= B <NEWLINE> if C <= 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> A -= D <NEWLINE> if A <= : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT>
if t_n <= a_n : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
A , B , C , D = map ( int , input ( ) . split ( ) ) <NEWLINE> while A > 0 and c > 0 : <NEWLINE> <INDENT> C -= B <NEWLINE> if C <= 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> A -= D <NEWLINE> if A <= 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT>
a , b , c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> while True : <NEWLINE> <INDENT> if ( c - b ) <= 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> c = c - d <NEWLINE> if a - d <= 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a = a - <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
t , k , c , d = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> while ( t >= 0 or c >= 0 ) : <NEWLINE> <INDENT> c = c - k <NEWLINE> if c <= 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> t = t - d <NEWLINE> if a <= 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT>
S , W = map ( int , input ( ) . split ( ) ) <NEWLINE> if S <= W : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
A = input ( ) <NEWLINE> B = input ( ) <NEWLINE> C = input ( ) <NEWLINE> D = input ( ) <NEWLINE> <NL> int_A = int ( A ) <NEWLINE> int_B = int ( B ) <NEWLINE> int_C = int ( C ) <NEWLINE> int_D = int ( D ) <NEWLINE> <NL> while True : <NEWLINE> <INDENT> int_C -= int_B <NEWLINE> int_A -= int_D <NEWLINE> if int_C <= 0 : <NEWLINE> <INDENT> result = <STRING> <NEWLINE> break <NEWLINE> <DEDENT> if int_A <= 0 : <NEWLINE> <INDENT> result = <STRING> <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( result ) <NEWLINE>
a , b , c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> if c / b = > a / d or c // b = a // d : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
<INDENT> import math <NEWLINE> A , B , C , D = map ( int , input ( ) . split ( ) ) <NEWLINE> turn = math . ceil ( A / D ) <NEWLINE> if turn * B >= C : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> <NL> goods = { } <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> name = input ( ) . rstrip ( ) <NEWLINE> if name in goods . keys ( ) : <NEWLINE> <INDENT> goods [ name ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> goods [ name ] = 1 <NEWLINE> <DEDENT> <DEDENT> print ( len ( goods . keys ( ) ) ) <NEWLINE>
a , b , c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> if a % d > 0 : <NEWLINE> <INDENT> a = a // d + 1 <NEWLINE> <DEDENT> elif a % d == 0 : <NEWLINE> <INDENT> a = a // d <NEWLINE> <DEDENT> if c % b > 0 : <NEWLINE> <INDENT> c = c // b + 1 <NEWLINE> <DEDENT> elif c % b == 0 <NEWLINE> if a >= c : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
A , B , C , D = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> while True : <NEWLINE> <INDENT> C -= B <NEWLINE> if C <= 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> A -= D <NEWLINE> if <= 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT>
a , b , c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = <STRING> <NEWLINE> while True : <NEWLINE> <INDENT> c -= b if c <= 0 <NEWLINE> <INDENT> ans = <STRING> break <NEWLINE> <DEDENT> a -= d if a <= 0 break <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
a , b , c , d = map ( int , input ( ) , split ( ) ) <NEWLINE> turn = 0 <NEWLINE> while a > 0 and c > 0 : <NEWLINE> <INDENT> if turn % 2 == 0 : <NEWLINE> <INDENT> c -= b <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a -= d <NEWLINE> <DEDENT> turn += 1 <NEWLINE> <DEDENT> if turn % 2 == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
line = input ( ) . split ( <STRING> ) <NEWLINE> a = int ( line [ 0 ] ) <NEWLINE> b = int ( line [ 1 ] ) <NEWLINE> c = int ( line [ 2 ] ) <NEWLINE> d = int ( line [ 3 ] ) <NEWLINE> <NL> while a > 0 and c > 0 : <NEWLINE> <INDENT> c = c - b <NEWLINE> if c <= 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> a = a - d <NEWLINE> if a <= 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> line = input ( ) . split ( <STRING> ) <NEWLINE> a = int ( line [ 0 ] ) <NEWLINE> b = int ( line [ 1 ] ) <NEWLINE> c = int ( line [ 2 ] ) <NEWLINE> d = int ( line [ 3 ] ) <NEWLINE> <NL> while a > 0 and c > 0 : <NEWLINE> <INDENT> c = c - b <NEWLINE> if c <= 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> a = a - d <NEWLINE> if a <= 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT>
a , b , c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> while True : <NEWLINE> <INDENT> c - = b <NEWLINE> if c <= 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> a - = d <NEWLINE> if a <= 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT>
[ A , B , C , D ] = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> X = A / D <NEWLINE> Y = C / B <NEWLINE> if ( X - Y ) > 1 <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if Y > X : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
import math <NEWLINE> a , b , c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> if math . ceil ( c / b ) = < math . ceil ( a / d ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
A , B , C , D = map ( int , input ( ) . split ( ) ) <NEWLINE> while A * C > 0 : <NEWLINE> <INDENT> C = C - B <NEWLINE> A = A - D <NEWLINE> <DEDENT> print ( <STRING> A > 0 else <STRING> ) <NEWLINE>
a , b , c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> while True : <NEWLINE> <INDENT> c -= b <NEWLINE> if c <= 0 : <NEWLINE> print ( <STRING> ) <NEWLINE> break <NEWLINE> a -= d <NEWLINE> if a <= 0 : <NEWLINE> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT>
s = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = s [ 0 ] <NEWLINE> b = s [ 2 ] <NEWLINE> c = 0 <NEWLINE> for i in range ( ) : <NEWLINE> <INDENT> if a <= 0 or b <= 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if c == 0 : <NEWLINE> <INDENT> b = b - s [ 1 ] <NEWLINE> c = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a = a - s [ 3 ] <NEWLINE> <DEDENT> <DEDENT> if a <= 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b , c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> while a > 0 and c > 0 : <NEWLINE> <INDENT> c -= b <NEWLINE> if c > 0 : <NEWLINE> <INDENT> a -= d <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> if a <= 0 <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
A , B , C , D = map ( int , input ( ) . split ( ) ) <NEWLINE> Tattack = ceil ( A / D ) <NEWLINE> Aattack = ceil ( C / B ) <NEWLINE> if Tattack >= Aattack : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b , c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> while a > 0 and c > 0 : <NEWLINE> <INDENT> c -= b <NEWLINE> if c > 0 : <NEWLINE> <INDENT> a -= d <NEWLINE> if a <= 0 : <NEWLINE> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT>
th , ts , ah , as = map ( int , input ( ) . spilt ( ) ) <NEWLINE> turn = 1 <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> while ( 1 ) : <NEWLINE> <INDENT> if ( turn ) : <NEWLINE> <INDENT> ah -= ts <NEWLINE> if ( ah <= 0 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> th -= as <NEWLINE> if ( th <= 0 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> turn ^= 1 <NEWLINE> <DEDENT>
import math <NEWLINE> A , B , C , D = map ( int , input ( ) . split ( ) ) <NEWLINE> if ( math . ceil ( C / B ) = < math . ceil ( A / D ) ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
ht , st , ha , sa = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> bool_player = True <COMMENT> <NEWLINE> while ( ht > 0 or st > 0 ) : <NEWLINE> <INDENT> if bool_player : <NEWLINE> <INDENT> ha -= st <NEWLINE> bool_player = False <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ht -= sa <NEWLINE> bool_player = True <NEWLINE> <NL> <DEDENT> <DEDENT> if ht <= 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
A , B , C , D = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> while true : <NEWLINE> <INDENT> if C - B <= 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> C = C - B <NEWLINE> <DEDENT> if A - D <= 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> A = A - D <NEWLINE> <DEDENT> <DEDENT>
arg = input ( ) <NEWLINE> a = ( int ) ( arg . split ( ) ) [ 0 ] <NEWLINE> b = ( int ) ( arg . split ( ) ) [ 1 ] <NEWLINE> c = ( int ) ( arg . split ( ) ) [ 2 ] <NEWLINE> d = ( int ) ( arg . split ( ) ) [ 3 ] <NEWLINE> <NL> while true : <NEWLINE> <INDENT> a = a - d <NEWLINE> if a <= 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> c = c - b <NEWLINE> if c <= 0 : <NEWLINE> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT>
a , b , c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> for i in range ( 200 ) : <NEWLINE> <INDENT> c = c - b <NEWLINE> if c <= 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> a = a - d <NEWLINE> <DEDENT> if a <= 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT>
a , b , c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> while a , b > 0 : <NEWLINE> <INDENT> c -= b <NEWLINE> a -= d <NEWLINE> <DEDENT> if a <= 0 , b > 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif b <= 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
A , B , C , D = map ( int , input ( ) . split ( ) ) <NEWLINE> while True : <NEWLINE> <INDENT> A -= D <NEWLINE> C -= B <NEWLINE> if A < 0 : <NEWLINE> <INDENT> print ( <STRING> ) : <NEWLINE> break <NEWLINE> <DEDENT> if C < 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT>
A , B , C , D = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> while 1 : <NEWLINE> <INDENT> C -= B <NEWLINE> if C <= 0 <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> A -= D <NEWLINE> if A <= 0 <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> <NL> a , b , c , d = map ( int , input ( ) . slice ( ) ) <NEWLINE> <NL> while True : <NEWLINE> <INDENT> c -= b <NEWLINE> if c <= 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> a -= d <NEWLINE> if a <= 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT>
input_list = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> flag = False <NEWLINE> for idx in input_list : <NEWLINE> <INDENT> if idx >= 1 and idx <= 100 : <NEWLINE> <INDENT> flag = True <NEWLINE> <DEDENT> if flag is False : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> turn = 0 <NEWLINE> if flag : <NEWLINE> <INDENT> A , B , C , D = input_list <NEWLINE> continue_flag = True <NEWLINE> while continue_flag : <NEWLINE> <INDENT> if turn % 2 == 0 : <NEWLINE> <INDENT> C -= B <NEWLINE> if C <= 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> continue_flag = False <NEWLINE> <DEDENT> turn += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> A -= D <NEWLINE> if A <= 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> continue_flag = False <NEWLINE> <DEDENT> turn += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT>
def resolve ( ) : <NEWLINE> <INDENT> a , b , c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> A = math . ceil ( c / b ) <NEWLINE> B = math . ceil ( a / d ) <NEWLINE> print ( <STRING> if A <= B else <STRING> ) <NEWLINE> <NL> <DEDENT> resolve ( ) <NEWLINE>
t_hp_str , t_atack_str , a_hp_str , a_atack_str = input ( ) . split ( ) <NEWLINE> t_hp = int ( t_hp_str ) <NEWLINE> t_atack = int ( t_atack_str ) <NEWLINE> a_hp = int ( a_hp_str ) <NEWLINE> a_atack = int ( a_atack_str ) <NEWLINE> <NL> while True : <NEWLINE> <INDENT> if num % 2 == 0 : <NEWLINE> <INDENT> a_hp = a_hp - t_atack <NEWLINE> if a_hp <= 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> t_hp = t_hp - a_atack <NEWLINE> if t_hp <= 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT>
t_hp , t_ap , a_hp , a_ap = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> while t_hp > 0 or a_hp > 0 : <NEWLINE> <INDENT> a_hp -= t_ap <NEWLINE> if a_hp <= 0 : <NEWLINE> <INDENT> return <STRING> <NEWLINE> break <NEWLINE> <NL> <DEDENT> t_hp -= a_ap <NEWLINE> if t_hp <= 0 : <NEWLINE> <INDENT> return <STRING> <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT>
while True : <NEWLINE> <INDENT> C -= B <NEWLINE> if C <= 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> A -= D <NEWLINE> if D <= 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT>
As , Aa , Bs , Ba = map ( int , input ( ) . split ( ) ) <NEWLINE> while Aa > 0 and Ba > 0 : <NEWLINE> <INDENT> Bs += - Aa <NEWLINE> As += - Ba <NEWLINE> <NL> <DEDENT> if Bs <= 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
A , B , C , D = map ( int , input ( ) ) <NEWLINE> print ( <STRING> if C // B <= A // D else <STRING> ) <NEWLINE>
a , b , c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> killcount_a = - ( - C // B ) <NEWLINE> killcount_b = - ( - A // D ) <NEWLINE> <NL> if a <= b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b , c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> while a = < 0 : <NEWLINE> <INDENT> c = c - b <NEWLINE> if c <= 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> a = a - d <NEWLINE> <NL> <DEDENT> print ( <STRING> ) <NEWLINE>
<COMMENT> <NL> HPlist = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> HPlist [ 0 ] = A <NEWLINE> HPlist [ 1 ] = B <NEWLINE> HPlist [ 2 ] = C <NEWLINE> HPlist [ 3 ] = D <NEWLINE> <NL> <NL> <COMMENT> <NL> if C % B == 0 : <NEWLINE> <INDENT> aokiDeath = C // B <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> aokiDeath = C // B + 1 <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> if A % D == 0 : <NEWLINE> <INDENT> takahashiDeath = A // D <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> takahashiDeath = A // D + 1 <NEWLINE> <NL> <DEDENT> if aokiDeath <= takahashiDeath : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import math , sys <NEWLINE> from bisect import bisect_left , bisect_right <NEWLINE> from collections import Counter , defaultdict , deque <NEWLINE> from copy import deepcopy <NEWLINE> from functools import lru_cache <NEWLINE> from heapq import heapify , heappop , heappush <NEWLINE> from itertools import accumulate , combinations , permutations <NEWLINE> input = sys . stdin . readline <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> ns = lambda : input ( ) . strip ( ) <NEWLINE> ni = lambda : int ( input ( ) . strip ( ) ) <NEWLINE> nm = lambda : map ( int , input ( ) . split ( ) ) <NEWLINE> nl = lambda : list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> a , b , c , d = nm ( ) <NEWLINE> while True : <NEWLINE> <INDENT> c -= d <NEWLINE> if c <= 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> a -= d : <NEWLINE> if a <= 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
A , B , C , D = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> t = 0 <NEWLINE> <NL> while True : <NEWLINE> <INDENT> if t = 0 : <NEWLINE> <INDENT> C = C - B <NEWLINE> t = 1 <NEWLINE> if C <= 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> A = A - D <NEWLINE> t = 0 <NEWLINE> if A <= 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
while True : <NEWLINE> <INDENT> C -= B <NEWLINE> A -= D <NEWLINE> if A <= 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> elif C <= 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT>
A = int ( input ( ) ) <NEWLINE> B = int ( input ( ) ) <NEWLINE> C = int ( input ( ) ) <NEWLINE> D = int ( input ( ) ) <NEWLINE> while True : <NEWLINE> <INDENT> C = C - B <NEWLINE> if C <= 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> A = A - D <NEWLINE> if A <= 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> <NL> inputs = input ( ) . split ( <STRING> ) <NEWLINE> <NL> d = inputs [ 0 : 2 ] <NEWLINE> takahashi = { <STRING> : <STRING> , <STRING> : int ( d [ 0 ] ) , <STRING> : int ( d [ 1 ] ) } <NEWLINE> d = inputs [ 2 : 4 ] <NEWLINE> aoki = { <STRING> : <STRING> , <STRING> : int ( d [ 0 ] ) , <STRING> : int ( d [ 1 ] ) } <NEWLINE> <NL> players = [ aoki , takahashi ] <NEWLINE> N = len ( players ) <NEWLINE> <NL> loop = True <NEWLINE> while True : <NEWLINE> <INDENT> for i in range ( N ) : <NEWLINE> <INDENT> players [ i - 1 ] [ <STRING> ] -= players [ i ] [ <STRING> ] <NEWLINE> if players [ i - 1 ] [ <STRING> ] <= 0 : <NEWLINE> <INDENT> if players [ i ] [ <STRING> ] == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> loop = False <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
N = input ( ) . split ( <STRING> ) <NEWLINE> TL = int ( N [ 0 ] ) <NEWLINE> TA = int ( N [ 1 ] ) <NEWLINE> AL = int ( N [ 2 ] ) <NEWLINE> AA = int ( N [ 3 ] ) <NEWLINE> a = 0 <NEWLINE> <NL> while a == 0 : <NEWLINE> <INDENT> AL = AL - TA <NEWLINE> if AL <= 0 : <NEWLINE> <INDENT> a = 1 <NEWLINE> break <NEWLINE> <DEDENT> TA = TA - AA <NEWLINE> if TL <= 0 : <NEWLINE> <INDENT> a = 2 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if a == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a == 2 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
46 4 40 5 <NEWLINE>
MON = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> While True : <NEWLINE> <NL> <INDENT> MON [ 2 ] = MON [ 2 ] - MON [ 1 ] <NEWLINE> if ( MON [ 2 ] <= 0 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <NL> <DEDENT> MON [ 0 ] = MON [ 0 ] - MON [ 3 ] <NEWLINE> if ( MON [ 0 ] <= 0 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT>
a , b , c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> while ( True ) : <NEWLINE> <INDENT> if ( d <= 0 ) : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <DEDENT> c = c - b <NEWLINE> if ( d <= 0 ) : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> break <NEWLINE> <DEDENT> a = a - d <NEWLINE> if ( b <= 0 ) : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <COMMENT> <NL> <NEWLINE>
A , B , C , D = map ( int , input ( ) . split ( ) ) <NEWLINE> if C / B <= A / D | | C / B <= 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b , c , d = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> i = 0 <NEWLINE> while a > 0 or c > 0 : <NEWLINE> <INDENT> if i % 2 == 0 : <NEWLINE> <INDENT> c -= b <NEWLINE> else : <NEWLINE> <INDENT> a -= d <NEWLINE> <DEDENT> <DEDENT> i += 1 <NEWLINE> <DEDENT> print ( <STRING> [ i % 2 : : 2 ] ) <NEWLINE>
a , b , c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> while a > 0 and c > 0 : <NEWLINE> <INDENT> c -= b <NEWLINE> a -= d <NEWLINE> <NL> <NL> <NL> <DEDENT> if a >> o : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <NL> <DEDENT>
a , b , c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> n = 1 <NEWLINE> while c - b * n > 0 and a - d * n > 0 : <NEWLINE> <INDENT> n += 1 <NEWLINE> <DEDENT> if c - bn <= 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
A , B , C , D = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <NL> <NL> Thit = A <NEWLINE> Tatk = B <NEWLINE> Ahit = C <NEWLINE> Aatk = D <NEWLINE> win = False <NEWLINE> <NL> while : <NEWLINE> <INDENT> Ahit = Ahit - Tatk <NEWLINE> if Ahit <= 0 : <NEWLINE> <INDENT> win = True <NEWLINE> break <NEWLINE> <DEDENT> Thit = Thit - Aatk <NEWLINE> if Thit <= 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> if win : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
A = input ( ) <NEWLINE> B = input ( ) <NEWLINE> C = input ( ) <NEWLINE> D = input ( ) <NEWLINE> <NL> int_A = int ( A ) <NEWLINE> int_B = int ( B ) <NEWLINE> int_C = int ( C ) <NEWLINE> int_D = int ( D ) <NEWLINE> <NL> while True : <NEWLINE> <INDENT> int_C -= int_B <NEWLINE> int_A -= int_D <NEWLINE> if int_C <= 0 : <NEWLINE> <INDENT> result = <STRING> <NEWLINE> break <NEWLINE> <DEDENT> if int_A <= 0 : <NEWLINE> <INDENT> result = <STRING> <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( result ) <NEWLINE>
a , b , c , d = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> while True : <NEWLINE> <INDENT> c -= b <NEWLINE> <INDENT> if c <= 0 : <NEWLINE> print ( <STRING> ) <NEWLINE> break <NEWLINE> a -= d <NEWLINE> <DEDENT> if a <= 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT>
a , b , c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> for i in range ( 1 , 1000 ) : <NEWLINE> <INDENT> if ( i % 2 != 0 ) : <NEWLINE> <INDENT> c -= b <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a -= d <NEWLINE> <NL> <DEDENT> if ( a <= 0 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> return <NEWLINE> <DEDENT> elif ( c <= 0 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> return <NEWLINE> <DEDENT> <DEDENT>
a , b , c d = map ( int , input ( ) . split ( ) ) <NEWLINE> aa = a <NEWLINE> cc = c <NEWLINE> for i in range ( a // d + 1 ) : <NEWLINE> <INDENT> cc = cc - b <NEWLINE> print ( cc ) <NEWLINE> if cc < 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break ; <NEWLINE> <DEDENT> aa = aa - d <NEWLINE> print ( aa ) <NEWLINE> if aa < 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break ; <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> <NL> inp = input ( ) . split ( <STRING> ) <NEWLINE> thp = int ( inp [ 0 ] ) <NEWLINE> tat = int ( inp [ 1 ] ) <NEWLINE> ahp = int ( inp [ 2 ] ) <NEWLINE> aat = int ( inp [ 3 ] ) <NEWLINE> <NL> for i in range ( 100 ) ; <NEWLINE> <INDENT> ahp -= tat <NEWLINE> if ahp <= 0 ; <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> thp -= aat <NEWLINE> if thp <= 0 ; <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT>
a , b , c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( <STRING> if - c // b >= - a // d else <STRING> ) a , b , c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( <STRING> if - c // b >= - a // d else <STRING> ) <NEWLINE>
a , b , c , d = , map ( int , input ( ) , split ( ) ) <NEWLINE> hpa = a <NEWLINE> hpc = c <NEWLINE> while ( hpa != 0 ) and ( hpc != 0 ) : <NEWLINE> <INDENT> hpa = hpa - c <NEWLINE> hpc = hpc - a <NEWLINE> <NL> <DEDENT> if hpa = 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> if hpc = 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT>
n = int ( input ) <NEWLINE> lis = [ input ( ) for i in range ( n ) ] <NEWLINE> print ( len ( set ( lis ) ) ) <NEWLINE>
<COMMENT> <NL> from collections import Counter <NEWLINE> n = int ( input ( ) ) <COMMENT> <NEWLINE> l = [ input ( ) for i in range ( n ) ] <COMMENT> <NEWLINE> c = cCounter ( l ) <NEWLINE> <NL> print ( len ( c ) ) <NEWLINE>
N = int ( raw_input ( ) ) <NEWLINE> s = set ( ) <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> S = raw_input ( ) <NEWLINE> s . add ( S ) <NEWLINE> <DEDENT> print ( len ( s ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = map ( chr , input ( ) . split ( ) ) <NEWLINE> print ( len ( set ( A ) ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = set ( ) <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> string = input ( ) <NEWLINE> s . add ( string ) <NEWLINE> <DEDENT> return len ( s ) <NEWLINE> <NL>
N = int ( input ( ) ) <NEWLINE> S = [ input ( ) for _ in range ( N ) ] <NEWLINE> <NL> print ( len ( set ( S ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> s . append ( input ( ) ) <NEWLINE> <NL> <DEDENT> print ( len ( set ( s ) ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> ilist = [ str ( input ( ) ) for i in range ( n ) ] <NEWLINE> <COMMENT> <NL> <NL> dic = { } <NEWLINE> for i in ilist : <NEWLINE> <INDENT> dic [ i ] = 1 <NEWLINE> <NL> <DEDENT> print ( len ( dic ) ) <NEWLINE> ~ <NEWLINE>
n = int ( input ( ) ) <NEWLINE> list = [ input ( ) for _ in range ( n ) ] : <NEWLINE> print ( len ( set ( list ) ) ) <NEWLINE>
group = { } <NEWLINE> for _ in range ( int ( input ( ) ) ) : <NEWLINE> <INDENT> group . add ( input ( ) ) <NEWLINE> <DEDENT> print ( len ( group ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> kk = set ( ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> kk . add ( ) <NEWLINE> <DEDENT> print ( len ( kk ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> items = [ ] <NEWLINE> count = 0 <NEWLINE> for x in range ( N ) : <NEWLINE> <INDENT> thing = input ( ) <NEWLINE> if thing not x in items : <NEWLINE> <INDENT> count += 1 <NEWLINE> items . append ( thing ) <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> N = int ( input ( ) ) <NEWLINE> S = [ input ( ) for i in range ( N ) ] <NEWLINE> count = 0 <NEWLINE> while len ( S ) > 0 : <NEWLINE> <INDENT> [ S for S in S if S != S [ 0 ] ] <NEWLINE> count += 1 <NEWLINE> <NL> <DEDENT> print ( count ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> set1 = set ( [ ] ) <NEWLINE> for _ in range ( ) : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> set1 . add ( s ) <NEWLINE> <NL> <DEDENT> print ( len ( set1 ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> <NL> arr = [ ] <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> arr . append ( input ( ) ) <NEWLINE> <NL> <DEDENT> print ( len ( set ( arr ) ) <NEWLINE>
f = open ( <STRING> , <STRING> ) <NEWLINE> sys . stdin = f <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> l = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> l . append ( input ( ) ) <NEWLINE> <NL> <DEDENT> c = collections . Counter ( l ) <NEWLINE> print ( len ( c ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> S . append ( input ( ) ) <NEWLINE> <NL> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> for j in range ( N ) : <NEWLINE> <INDENT> if S [ i ] == S [ j ] : <NEWLINE> <INDENT> pair += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> pair = ( pair - N ) / 2 <NEWLINE> print ( pair ) <NEWLINE>
import sys <NEWLINE> <NL> def main ( ) : <NEWLINE> <NL> <INDENT> N = int ( input ( ) ) <NEWLINE> <NL> d = { } <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> A = int ( input ( ) ) <NEWLINE> d [ A ] = 0 <NEWLINE> <DEDENT> print ( len ( d ) ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> S = { } <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> S . add ( i ) <NEWLINE> <DEDENT> print ( len ( S ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> set = { } <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> A = str ( input ( ) ) <NEWLINE> set . add ( A ) <NEWLINE> <NL> <DEDENT> print ( len ( set ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> list = list ( input ( ) . split ( ) ) <NEWLINE> list . sort ( ) <NEWLINE> n = 0 <NEWLINE> s = list [ 0 ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if list [ i ] != s : <NEWLINE> <INDENT> n += 1 <NEWLINE> s = list [ i ] <NEWLINE> <DEDENT> <DEDENT> print ( n ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> l = [ ] <NEWLINE> for i in range ( 0 , n ) : <NEWLINE> <INDENT> l . append ( input ( ) ) <NEWLINE> <DEDENT> print ( len ( set ( l ) ) <NEWLINE>
N = int ( input ) <NEWLINE> ans = [ ] <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> ans . append ( s ) <NEWLINE> <DEDENT> print ( len ( list ( set ( ans ) ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S = [ ] <NEWLINE> for j in range ( N ) : <NEWLINE> <INDENT> S [ j ] = input ( ) <NEWLINE> <DEDENT> print ( len ( set ( S ) ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> glist = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> glist . append ( input ( ) ) <NEWLINE> <NL> <DEDENT> print ( lens ( glist ) ) <NEWLINE> <NL>
n = int ( input ( ) ) <NEWLINE> S = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> print ( len ( list ( set ( S ) ) ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> gacha = set ( ) <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> gacha . append ( input ( ) ) <NEWLINE> <DEDENT> print ( len ( gacha ) ) <NEWLINE>
N = input ( ) <NEWLINE> S = [ str ( input ( ) ) for i in range ( N ) ] <NEWLINE> print ( len ( set ( S ) ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S = [ int ( input ( ) ) for i in range ( N ) ] <NEWLINE> <NL> print ( len ( set ( S ) ) ) <NEWLINE>
num = int ( input ( ) ) ; <NEWLINE> <NL> for i in range ( num ) : <NEWLINE> <INDENT> s = input ( ) ; <NEWLINE> if len ( s ) == 1 : <NEWLINE> <INDENT> mylist_1 . append ( s ) ; <NEWLINE> <DEDENT> elif len ( s ) == 2 : <NEWLINE> <INDENT> mylist_2 . append ( s ) ; <NEWLINE> <DEDENT> elif len ( s ) == 3 : <NEWLINE> <INDENT> mylist_3 . append ( s ) ; <NEWLINE> <DEDENT> elif len ( s ) == 4 : <NEWLINE> <INDENT> mylist_4 . append ( s ) ; <NEWLINE> <DEDENT> elif len ( s ) == 5 : <NEWLINE> <INDENT> mylist_5 . append ( s ) ; <NEWLINE> <DEDENT> elif len ( s ) == 6 : <NEWLINE> <INDENT> mylist_6 . append ( s ) ; <NEWLINE> <DEDENT> elif len ( s ) == 7 : <NEWLINE> <INDENT> mylist_7 . append ( s ) ; <NEWLINE> <DEDENT> elif len ( s ) == 8 : <NEWLINE> <INDENT> mylist_8 . append ( s ) ; <NEWLINE> <DEDENT> elif len ( s ) == 9 : <NEWLINE> <INDENT> mylist_9 . append ( s ) ; <NEWLINE> <DEDENT> elif len ( s ) == 10 : <NEWLINE> <INDENT> mylist_10 . append ( s ) ; <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> m1 = len ( list ( set ( mylist_1 ) ) ) ; <NEWLINE> m2 = len ( list ( set ( mylist_2 ) ) ) ; <NEWLINE> m3 = len ( list ( set ( mylist_3 ) ) ) ; <NEWLINE> m4 = len ( list ( set ( mylist_4 ) ) ) ; <NEWLINE> m5 = len ( list ( set ( mylist_5 ) ) ) ; <NEWLINE> m6 = len ( list ( set ( mylist_6 ) ) ) ; <NEWLINE> m7 = len ( list ( set ( mylist_7 ) ) ) ; <NEWLINE> m8 = len ( list ( set ( mylist_8 ) ) ) ; <NEWLINE> m9 = len ( list ( set ( mylist_9 ) ) ) ; <NEWLINE> m10 = len ( list ( set ( mylist_10 ) ) ) ; <NEWLINE> <NL> m = m1 + m2 + m3 + m4 + m5 + m6 + m7 + m8 + m9 + m10 ; <NEWLINE> print ( m ) ; <NEWLINE>
n = input ( ) <NEWLINE> s = [ input ( ) for i in range ( n ) ] <NEWLINE> <NL> print ( len ( list ( set ( s ) ) ) ) <NEWLINE>
a = int ( input ( ) ) <NEWLINE> ar = [ ] <NEWLINE> for i in range ( a ) : <NEWLINE> <INDENT> ar . append ( l ) <NEWLINE> <DEDENT> print ( len ( set ( ar ) ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> l = [ ] <NEWLINE> k = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> S = input ( ) <NEWLINE> l . append ( S ) <NEWLINE> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> a = l . index ( l [ i ] ) <NEWLINE> <DEDENT> except ValueError : <NEWLINE> <INDENT> k += 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( k ) <NEWLINE>
num = int ( input ( ) ) <NEWLINE> <NL> set_ = [ ] <NEWLINE> for i in range ( num ) : <NEWLINE> <INDENT> a = int ( input ( ) ) <NEWLINE> set . append ( a ) <NEWLINE> <NL> <DEDENT> print ( len ( set ( set_ ) ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S = [ input ( ) for i in range ( N ) ] <NEWLINE> return len ( set ( S ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = [ input ( ) for i in range ( n ) ] <NEWLINE> print ( len ( set ( a ) ) <NEWLINE>
import sys , re <NEWLINE> import math <NEWLINE> from collections import deque , defaultdict , Counter <NEWLINE> from math import ceil , sqrt , hypot , factorial , pi , sin , cos , radians <NEWLINE> from itertools import accumulate , permutations , combinations , product <NEWLINE> from operator import itemgetter , mul <COMMENT> <NEWLINE> from copy import deepcopy <NEWLINE> from string import ascii_lowercase , ascii_uppercase , digits <NEWLINE> from bisect import bisect , bisect_left <NEWLINE> from fractions import gcd <COMMENT> <NEWLINE> from heapq import heappush , heappop <NEWLINE> <NL> def input ( ) : return sys . stdin . readline ( ) . strip ( ) <NEWLINE> def INT ( ) : return int ( input ( ) ) <NEWLINE> def MAP ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def LIST ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> INF = float ( <STRING> ) <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> <NL> <COMMENT> <NL> n = INT ( ) <NEWLINE> list = [ ] <NEWLINE> <NL> addFlag = True <NEWLINE> <NL> for x in range ( n ) : <NEWLINE> <INDENT> text = input ( ) <NEWLINE> addFlag = True <NEWLINE> for y in list : <NEWLINE> <INDENT> if text == y : <NEWLINE> <INDENT> addFlag = False <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if addFlag : <NEWLINE> <INDENT> list . append ( text ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( len ( list ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> a_list <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> a_list . append ( input ( ) ) <NEWLINE> <NL> <DEDENT> a_ = set ( a_list ) <NEWLINE> <NL> a_num = len ( a_ ) <NEWLINE> <NL> print ( a_num ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = [ ] <NEWLINE> for _ in range ( input ( ) ) : <NEWLINE> <INDENT> s . append ( input ( ) ) <NEWLINE> <DEDENT> print ( len ( set ( s ) ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = ( input ( ) for _ in range ( n ) ) <NEWLINE> print ( len ( s ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> lis = set ( ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> i = str ( input ( ) ) <NEWLINE> ilen = len ( i ) <NEWLINE> lis . append ( ilen ) <NEWLINE> <NL> <DEDENT> kind = int ( len ( lis ) ) <NEWLINE> print ( kind ) <NEWLINE>
import collections <NEWLINE> n = int ( input ( ) ) <NEWLINE> s = [ input ( ) for i in range ( n ) ] <NEWLINE> c = collections . Counter ( s ) <NEWLINE> print ( len ( a ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S = [ ] <NEWLINE> while True : <NEWLINE> <INDENT> Si = input ( ) <NEWLINE> if Si : <NEWLINE> <INDENT> S . append ( Si ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> g = S [ : N ] <NEWLINE> print ( g ) <NEWLINE>
<COMMENT> <NL> using namespace std ; <NEWLINE> <NL> int main ( ) { <NEWLINE> <INDENT> int N ; <NEWLINE> cin >> N ; <NEWLINE> string S [ N ] ; <NEWLINE> for ( int i = 0 ; i < N ; i + + ) cin >> S [ i ] ; <NEWLINE> int count = 0 ; <NEWLINE> for ( int i = 0 ; i < N ; i + + ) { <NEWLINE> <INDENT> if ( S [ i ] != <STRING> ) { <NEWLINE> <INDENT> for ( int j = i + 1 ; j < N ; j + + ) { <NEWLINE> <INDENT> if ( S [ i ] == S [ j ] ) S [ j ] = <STRING> ; <NEWLINE> <DEDENT> } <NEWLINE> <DEDENT> } <NEWLINE> <DEDENT> } <NEWLINE> for ( int i = 0 ; i < N ; i + + ) { <NEWLINE> <INDENT> if ( S [ i ] != <STRING> ) count + + ; <NEWLINE> <DEDENT> } <NEWLINE> cout << count << endl ; <NEWLINE> <NL> <DEDENT> } <NEWLINE>
S = [ input ( ) for _ in range ( N ) ] <NEWLINE> print ( len ( set ( S ) ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S = [ input ( ) for i in range ( N ) ] <NEWLINE> print ( len ( set ( d ) ) ) <NEWLINE>
import sys <NEWLINE> count = int ( sys . stdin . readline ( ) ) <NEWLINE> zenbu = [ ] <NEWLINE> <NL> for x in range ( count ) : <NEWLINE> <INDENT> keihin = sys . stdin . readline ( ) <NEWLINE> <NL> if not keihin in zenbu : <NEWLINE> <INDENT> zenbu [ len ( zenbu ) ] = keihin <NEWLINE> <DEDENT> <DEDENT> print ( len ( zenbu ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> li = list ( ) <NEWLINE> for i range ( n ) : <NEWLINE> <INDENT> li . append ( str ( input ( ) ) ) <NEWLINE> <NL> <DEDENT> print ( len ( set ( li ) ) ) <NEWLINE> <NL>
import math <NEWLINE> <COMMENT> <NL> I = int ( input ( ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> list = <STRING> . join ( iter ( input , <STRING> ) ) <NEWLINE> print ( len ( set ( list ) ) - 1 ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = set ( ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> s . add ( str ( input ( ) ) . lower ( ) ) <NEWLINE> <DEDENT> print ( len ( x ) ) <NEWLINE> <NL>
mport collections <NEWLINE> S = [ ] <NEWLINE> N = int ( input ( ) ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> S . append ( input ( ) ) <NEWLINE> <DEDENT> print ( len ( collections . Counter ( S ) ) ) <NEWLINE> <NL> <NL> <NL> <NL>
N = int ( input ( ) ) <NEWLINE> n_list = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> n_list . append ( input ( ) ) <NEWLINE> <DEDENT> print ( len ( dict ( Counter ( n_list ) ) ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = [ ] <NEWLINE> A . append ( int ( input ( ) ) ) <NEWLINE> a = set ( A ) <NEWLINE> print ( len ( a ) ) <NEWLINE>
import sys <NEWLINE> a = [ ] <NEWLINE> for l in sys . stdin : <NEWLINE> <INDENT> a . append ( int ( l ) ) <NEWLINE> <DEDENT> a = a [ 1 : ] <NEWLINE> print ( len ( set ( a ) ) ) <NEWLINE>
n = int ( input ) <NEWLINE> ans = len ( set ( [ input ( ) for _ in range ( n ) ] ) ) <NEWLINE> print ( ans ) <NEWLINE>
n = input ( ) <NEWLINE> k = set ( ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> o = input ( ) <NEWLINE> k . append ( o ) ) <NEWLINE> <DEDENT> print ( len ( k ) ) <NEWLINE>
a = map ( int , input ( ) . split ( ) ) <NEWLINE> s = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> print ( len ( set ( s ) ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S = [ input ( ) for i in range ( N ) ] <NEWLINE> S . sort ( ) <NEWLINE> c = 1 <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> if S [ i ] == S [ i + 1 ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> c + + <NEWLINE> <DEDENT> <DEDENT> print ( c ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> S = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> S . append ( int ( input ( ) ) ) <NEWLINE> <DEDENT> T = set ( S ) <NEWLINE> print ( len ( T ) ) <NEWLINE>
from collections import Counter <NEWLINE> n = int ( input ( ) ) <NEWLINE> s = [ input ( ) for i in range ( n ) ] <NEWLINE> c = Counter ( s ) <NEWLINE> c = list ( s . items ( ) ) <NEWLINE> print ( len ( c ) ) <NEWLINE>
import collections <NEWLINE> n = int ( input ( ) ) <NEWLINE> s_list = list ( input ( ) for _ in range ( n ) ) <NEWLINE> c = collections . Ceounter ( s_list ) <NEWLINE> print ( len ( c . keys ( ) ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> ans = { } <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> t = input ( ) <NEWLINE> if t not in ans : <NEWLINE> <INDENT> ans [ t ] = 1 <NEWLINE> <DEDENT> <DEDENT> print ( len ( ans . keys ( ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S = [ input ( ) for i in range ( N ) ] <NEWLINE> print ( count ( set ( S ) ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S = [ input ( ) for _ in range ( N ) ] <NEWLINE> print ( len ( set ( s ) ) ) <NEWLINE>
Row = int ( input ( ) ) <NEWLINE> List = [ ] <NEWLINE> for i in range ( Row ) : <NEWLINE> <INDENT> List . append ( int ( input ( ) ) ) <NEWLINE> <DEDENT> s_l = set ( List ) <NEWLINE> print ( len ( s_l ) ) <NEWLINE>
N = input ( ) <NEWLINE> list = [ input ( ) for i in range ( N ) ] <NEWLINE> print ( len ( set ( list ) ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> obj = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> obj . append ( input ( ) ) <NEWLINE> <DEDENT> dictOfElems = dict ( ) <NEWLINE> for elem in obj : <NEWLINE> <INDENT> if elem in dictOfElems : <NEWLINE> <INDENT> dictOfElems [ elem ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dictOfElems [ elem ] = 1 <NEWLINE> <DEDENT> <DEDENT> print ( len ( dict ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = [ ] <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> s . append ( int ( input ) ) <NEWLINE> <NL> <DEDENT> print ( len ( set ( s ) ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> L = [ ] <NEWLINE> if not ( 1 <= N <= 2 * ( 10 ** 5 ) ) : <NEWLINE> <INDENT> exit ( ) <NEWLINE> <NL> <NL> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> d = input ( ) <NEWLINE> if not ( 1 <= len ( d ) <= 10 ) : <NEWLINE> <INDENT> exit ( ) <NEWLINE> <DEDENT> if not ( d . lower ( ) == d ) : <NEWLINE> <INDENT> exit ( ) <NEWLINE> <DEDENT> L . append ( d ) <NEWLINE> <NL> <DEDENT> print ( len ( set ( L ) ) ) <NEWLINE> root @ stypr - ubuntu : ~ / 1 <COMMENT> <NEWLINE>
n = int ( input ( ) ) <NEWLINE> list = { } <NEWLINE> for x in range ( n ) : <NEWLINE> <INDENT> item = input ( ) <NEWLINE> list [ item ] = x <NEWLINE> <DEDENT> print ( len ( lest ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> <COMMENT> <NL> keihin = [ ] <NEWLINE> <NL> <COMMENT> <NL> for i in range ( N ) : <NEWLINE> <INDENT> if keihin . count ( input ( ) ) == 0 : <NEWLINE> <INDENT> keihin . append ( input ( ) ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> print ( len ( keihin ) ) <NEWLINE>
import sys <NEWLINE> n = int ( input ( ) . strip ( ) ) <NEWLINE> items = set ( ) <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> items |= { sys . readline ( ) . strip ( ) } <NEWLINE> <DEDENT> print ( len ( items ) ) <NEWLINE>
N = input ( ) <NEWLINE> str_list = [ input ( ) for _ in range ( N ) ] <NEWLINE> <NL> print ( len ( set ( str_list ) ) ) <NEWLINE>
import collections <NEWLINE> num = input ( ) <NEWLINE> a = [ input ( ) for i in range ( num ) ] <NEWLINE> clist = collections . Counter ( a ) <NEWLINE> print ( len ( clist ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = set ( ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> s . insert ( input ( ) ) <NEWLINE> <DEDENT> print ( len ( s ) ) <NEWLINE>
n = iinput ( ) ) <NEWLINE> s = list ( ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> s . append ( input ( ) ) <NEWLINE> <DEDENT> print ( len ( set ( s ) ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> set = { } <NEWLINE> for n in range ( n ) : <NEWLINE> <INDENT> set . append ( input ( ) ) <NEWLINE> <DEDENT> print ( len ( set ) ) <NEWLINE>
4 <NEWLINE> aaaa <NEWLINE> a <NEWLINE> aaa <NEWLINE> aa <NEWLINE>
N = int ( input ( ) ) <NEWLINE> s = [ ] <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> s . add ( input ( ) ) <NEWLINE> <NL> <DEDENT> print ( len ( s ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> s [ i ] = str ( input ( ) ) <NEWLINE> <DEDENT> s = list ( set ( s ) ) <NEWLINE> print ( len ( s ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S = [ input ( ) for i in range ( N ) if input ( ) not in S ] <NEWLINE> <NL> print ( len ( S ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> a = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> a . append ( input ( ) ) <NEWLINE> <DEDENT> print ( len ( collections . Counter ( a ) ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> st = set ( ) <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> S = input ( ) <NEWLINE> st . insert ( S ) <NEWLINE> <NL> <DEDENT> print ( len ( st ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = [ ] <NEWLINE> for _ in n : <NEWLINE> <INDENT> i = str ( input ( ) ) <NEWLINE> a . append ( i ) <NEWLINE> <DEDENT> print ( len ( set ( a ) ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> items = set ( ) <NEWLINE> for _ range ( n ) : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> items . add ( s ) <NEWLINE> <DEDENT> print ( len ( items ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> string_list = [ input ( ) for i in range ( n ) ] <NEWLINE> c = collections . Counter ( string_list ) <NEWLINE> print ( len ( c ) ) <NEWLINE> <NL>
n = int ( input ( ) ) <NEWLINE> lists = [ input ( ) for x in range ( n ) ] <NEWLINE> print ( len ( set ( lists ) ) <NEWLINE>
a = int ( input ( ) ) <NEWLINE> b = [ ] <NEWLINE> for i in range ( a ) : <NEWLINE> <INDENT> c = input ( ) <NEWLINE> if c not in b == True : <NEWLINE> <INDENT> b . append ( c ) <NEWLINE> <DEDENT> <DEDENT> print ( ren ( b ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a . apped ( str ( input ( ) ) ) <NEWLINE> <DEDENT> print ( len ( set ( a ) ) ) <NEWLINE>
n = input ( ) <NEWLINE> s = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> s . append ( input ( ) ) <NEWLINE> <NL> <DEDENT> print ( set ( s ) ) <NEWLINE>
import collections <NEWLINE> N = int ( input ( ) ) <NEWLINE> count = 0 <NEWLINE> a = [ ] <NEWLINE> while N > 0 : <NEWLINE> <INDENT> a . append ( input ( ) ) <NEWLINE> N = N - 1 <NEWLINE> <DEDENT> c = collection . Counter ( a ) <NEWLINE> print ( len ( c ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = [ int ( input ( ) ) for i in range ( n ) ] <NEWLINE> S = list ( set ( s ) ) <NEWLINE> print ( len ( S ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> a = { } <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> a += input ( ) <NEWLINE> <DEDENT> print ( len ( a ) ) <NEWLINE>
<COMMENT> <NL> <NL> a , b , c , d = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> <NL> n = max ( [ int ( a / d ) + 1 , int ( c / b ) + 1 ] ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> a -= d <NEWLINE> c -= b <NEWLINE> <COMMENT> <NL> if c <= 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> elif a <= 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> <NL> ans = { } <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> ans . add ( input ( ) ) <NEWLINE> <NL> <DEDENT> print ( len ( ans ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> b = 0 <NEWLINE> <NL> for i in range ( 0 , N ) : <NEWLINE> <INDENT> S [ i ] = input ( ) <NEWLINE> <NL> <DEDENT> b = collections . Counter ( S ) <NEWLINE> print ( len ( S ) ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ma = [ 0 ] * n <NEWLINE> for _ in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> ma [ a - 1 ] = max ( ma [ a - 1 ] , h [ b - 1 ] ) <NEWLINE> ma [ b - 1 ] = max ( ma [ b - 1 ] , h [ a - 1 ] ) <NEWLINE> <COMMENT> <NL> <DEDENT> cnt = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if ma [ i ] < h [ i ] : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE> <NL> <NL> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> SS = set ( ) <NEWLINE> while N = 0 : <NEWLINE> <INDENT> S = input ( ) <NEWLINE> SS . add ( S ) <NEWLINE> N = N - 1 <NEWLINE> <DEDENT> print ( len ( SS ) ) <NEWLINE>
N = input ( ) <NEWLINE> a = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> f = input ( ) <NEWLINE> a . append ( f ) <NEWLINE> <NL> <DEDENT> a = list ( set ( a ) ) <NEWLINE> <NL> print ( len ( a ) ) <NEWLINE>
from collections import Counter <NEWLINE> a = int ( input ( ) ) <NEWLINE> list1 = [ ] <NEWLINE> for i in range ( a ) <NEWLINE> list1 . append ( input ( ) ) <NEWLINE> a = set ( list1 ) <NEWLINE> print ( len ( a ) ) <NEWLINE> <NL>
a = int ( input ( ) ) <NEWLINE> * b , = map ( open ( 0 ) ) <NEWLINE> s = set ( b ) <NEWLINE> print ( min ( a , len ( s ) ) ) <NEWLINE>
<COMMENT> <NL> <NL> n = int ( input ( ) ) <NEWLINE> gacha_list [ input ( ) for i in range ( ) ] <NEWLINE> gacha_prize = list ( set ( gacha_list ( ) ) <NEWLINE> print ( len ( gacha_prize ( ) ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> l = [ ] <NEWLINE> s = { } <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> a = input ( ) <NEWLINE> l . append ( a ) <NEWLINE> <NL> <DEDENT> s = set ( l ) <NEWLINE> print ( len ( s ) <NEWLINE>
import sys <NEWLINE> sys . stdin = open ( <STRING> , <STRING> ) <NEWLINE> sys . stdout = open ( <STRING> , <STRING> ) <NEWLINE> t = int ( input ( ) ) <NEWLINE> s = set ( ) <NEWLINE> for i in range ( t ) : <NEWLINE> <COMMENT> <NL> <INDENT> n = input ( ) <NEWLINE> s . add ( n ) ; <NEWLINE> <DEDENT> print ( len ( s ) ) ; <NEWLINE> <NL>
M = int ( input ( ) ) <NEWLINE> P = [ input ( ) . split ( ) for i in range ( M ) ] <NEWLINE> print ( len ( set ( P ) ) ) <NEWLINE>
import collections <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> a = [ list ( input ( ) for i in range ( n ) ) ] <NEWLINE> b = collections . Counter ( a ) <NEWLINE> print ( len ( b ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = [ int ( input ( ) ) for _ in range ( n ) ] <NEWLINE> ans = set ( ) <NEWLINE> <NL> for i in s : <NEWLINE> <INDENT> ans . add ( i ) <NEWLINE> <NL> <DEDENT> print ( len ( ans ) ) <NEWLINE>
a = map ( int , input ( ) . split ( ) ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> def func ( a , b ) : <NEWLINE> <INDENT> ab = set ( b ) <NEWLINE> return len ( ab ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> s = list ( set ( [ int ( input ( ) ) for _ in range ( n ) ] ) ) <NEWLINE> print ( len ( s ) ) <NEWLINE>
N = int ( inout ( ) ) <NEWLINE> S = list ( input ( ) for i in range ( N ) ) <NEWLINE> print ( len ( set ( S ) ) ) <NEWLINE>
import collections <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> S = [ ] <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> S . append ( input ( ) ) <NEWLINE> <NL> <DEDENT> c = collections . counter ( S ) <NEWLINE> <NL> print ( len ( c ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> S [ i + 1 ] = str ( input ( ) ) <NEWLINE> <DEDENT> print ( len ( set ( S ) ) ) <NEWLINE>
list1 = [ ] <NEWLINE> num = int ( input ( ) ) <NEWLINE> for i in range ( 0 , num ) : <NEWLINE> <INDENT> some = input ( ) <NEWLINE> <INDENT> list1 . append ( some ) <NEWLINE> <DEDENT> <DEDENT> print ( len ( set ( i for i in list1 if i . isalpha ( ) ) ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> a = [ input ( ) for i in range ( N ) ] <NEWLINE> print ( len ( collections . Counter ( a ) ) ) <NEWLINE>
N , * S = map ( open ( 0 ) . read ( ) . split ( ) ) <NEWLINE> print ( len ( set ( S ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> L = [ input ( ) for i in range ( n ) ] <NEWLINE> M = set ( L ) <NEWLINE> print ( len ( M ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> l = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> l . append ( int ( input ( ) ) ) <NEWLINE> <DEDENT> print ( len ( set ( l ) ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> s = input ( ) . split ( ) <NEWLINE> <NL> ans = [ 0 for i in range ( n ) ] <NEWLINE> for i in range ( 0 , n - 1 ) : <NEWLINE> <INDENT> s [ i ] = int ( s [ i ] ) <NEWLINE> ans [ s [ i ] - 1 ] += 1 <NEWLINE> <NL> <DEDENT> for i in range ( 0 , n ) : <NEWLINE> <INDENT> print ( ans [ i ] ) <NEWLINE> <NL> <NL> <DEDENT>
n = int ( input ( ) ) <NEWLINE> S = { input ( ) for 0 in range ( n ) } <NEWLINE> ans = len ( S ) <NEWLINE> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> <NL> Ws = [ s for _ in range ( N ) ] <NEWLINE> <NL> print ( len ( set ( Ws ) ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> items = set ( ) <NEWLINE> for i in range ( 0 , N ) : <NEWLINE> <INDENT> items . add ( input ( ) ) <NEWLINE> <DEDENT> return len ( items ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S = [ input ( ) for i in range ( N ) ] <NEWLINE> a = set ( S ) <NEWLINE> print ( len ( a ) <NEWLINE>
print ( len ( set ( [ input ( ) for _ in range ( int ( input ( ) ) ) ] ) ) <NEWLINE>
from collections import Counter <NEWLINE> N = int ( input ( ) ) <NEWLINE> S = [ ] <NEWLINE> while True : <NEWLINE> <INDENT> S . append ( input ( ) ) <NEWLINE> <NL> <DEDENT> print ( len ( Counter ( S ) ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = [ int ( input ( ) ) for _ in range ( n ) ] <NEWLINE> print ( len ( set ( s ) ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = [ input ( ) for _ in range ( n ) ] <NEWLINE> <NL> print ( len ( type ( s ) ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = [ input ( ) . split ( ) for i in range ( n ) ] <NEWLINE> <NL> c = collections . counter ( a ) <NEWLINE> <NL> print ( len ( c ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> li = [ ] <NEWLINE> while len ( li ) < N : <NEWLINE> <INDENT> li . append ( input ( ) ) <NEWLINE> <DEDENT> print ( len ( set ( lottery ) ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = [ ] <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> a . append ( input ( ) ) <NEWLINE> <DEDENT> as = set ( a ) <NEWLINE> print ( len ( as ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> lst = { } <NEWLINE> <INDENT> for i in range ( n ) : <NEWLINE> <INDENT> lst [ str ( input ( ) ) ] += 1 <NEWLINE> <DEDENT> <DEDENT> print ( len ( lst ) ) <NEWLINE>
S , W = map ( int , input ( ) . split ( ) ) <NEWLINE> if S <= W : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
def actual ( N , s_list ) : <NEWLINE> <INDENT> return len ( set ( s_list ) ) <NEWLINE> <NL> <DEDENT> N = int ( input ( ) ) <NEWLINE> <NL> s_list = [ ] <NEWLINE> <NL> for _ in range ( N ) <NEWLINE> <INDENT> s = input ( ) <NEWLINE> <INDENT> s_list . append ( s ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( actual ( N , s_list ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> L = [ input ( ) ] <NEWLINE> <NL> for _ in range ( N - 1 ) : <NEWLINE> <INDENT> a = input ( ) <NEWLINE> imin = 0 <NEWLINE> imax = len ( L ) - 1 <NEWLINE> l = 0 <NEWLINE> <NL> while ( imin < imax ) : <NEWLINE> <INDENT> l = ( imin + imax ) // 2 <NEWLINE> if ( a == L [ l ] ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> elif ( a > L [ l ] ) : <NEWLINE> <INDENT> imin = min ( l + 1 , len ( L ) - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> imax = max ( l - 1 , 0 ) <NEWLINE> <NL> <DEDENT> <DEDENT> if ( imax == imin ) <NEWLINE> <INDENT> if ( a > L [ imin ] ) : <NEWLINE> <INDENT> L . insert ( imin + 1 , a ) <NEWLINE> <DEDENT> elif ( a < L [ imin ] ) : <NEWLINE> <INDENT> L . insert ( imin , a ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( len ( L ) ) <NEWLINE> N = int ( input ( ) ) <NEWLINE> L = [ input ( ) ] <NEWLINE> <NL> for _ in range ( N - 1 ) : <NEWLINE> <INDENT> a = input ( ) <NEWLINE> imin = 0 <NEWLINE> imax = len ( L ) - 1 <NEWLINE> l = 0 <NEWLINE> <NL> while ( imin < imax ) : <NEWLINE> <INDENT> l = ( imin + imax ) // 2 <NEWLINE> if ( a == L [ l ] ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> elif ( a > L [ l ] ) : <NEWLINE> <INDENT> imin = min ( l + 1 , len ( L ) - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> imax = max ( l - 1 , 0 ) <NEWLINE> <NL> <DEDENT> <DEDENT> if ( imax == imin ) : <NEWLINE> <INDENT> if ( a > L [ imin ] ) : <NEWLINE> <INDENT> L . insert ( imin + 1 , a ) <NEWLINE> <DEDENT> elif ( a < L [ imin ] ) : <NEWLINE> <INDENT> L . insert ( imin , a ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( len ( L ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> L = [ input ( ) for i range ( N ) ] <NEWLINE> M = sorted ( L ) <NEWLINE> print ( len ( M ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = set ( a ) <NEWLINE> print ( len ( a ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> ls = [ ] <NEWLINE> for _ in n : <NEWLINE> <INDENT> ls . append ( input ( ) ) <NEWLINE> <NL> print ( len ( set ( ls ) ) ) <NEWLINE> <DEDENT>
N = input ( ) <NEWLINE> List = list ( input ( ) for i in range ( N ) ) <NEWLINE> print ( len ( set ( List ) ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S = [ input ( ) for i in range ( N + 1 ) ] <NEWLINE> <NL> s = set ( S ) <NEWLINE> <NL> print ( len ( s ) ) <NEWLINE>
import sys <NEWLINE> s = sys . stdin . readlines ( ) <NEWLINE> s = input ( ) . split ( ) <NEWLINE> for i in range ( 1 , len ( s ) ) : <NEWLINE> <INDENT> s . add ( p [ i ] ) <NEWLINE> <DEDENT> print ( len ( set ( s ) ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> li = [ ] <NEWLINE> for si in n : <NEWLINE> <INDENT> si = input ( ) <NEWLINE> li . append ( si ) <NEWLINE> <DEDENT> print ( len ( set ( li ) ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> l = [ input ( ) for i in range ( n ) ] <NEWLINE> <NL> l = set ( l ) <NEWLINE> l = list ( l ) <NEWLINE> print ( sum ( l ) ) <NEWLINE>
from collections import Counter <NEWLINE> N = int ( input ( ) ) <NEWLINE> s = [ input ( ) for i in range ( N ) ] <NEWLINE> c = collections . Counter ( s ) <NEWLINE> print ( len ( c ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> d = { } <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> d [ input ( ) ] = 0 <NEWLINE> <DEDENT> print ( len ( dict ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> l = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> x = input ( ) <NEWLINE> l . append ( x ) <NEWLINE> <DEDENT> s = len ( list ( set ( l ) ) <NEWLINE> print ( s ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> l = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> print ( i ) <NEWLINE> l . append ( input ( ) ) <NEWLINE> <DEDENT> print ( len ( s ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> items = [ input ( ) for _ in range ( n ) ] <NEWLINE> <NL> print ( len ( list ( set ( items ) ) ) <NEWLINE>
import sys ; <NEWLINE> <NL> <NL> class Main : <NEWLINE> <INDENT> s = set ( [ i . sprit ( ) for i in sys . stdin . readlines ( ) ] ) ; <NEWLINE> <NL> print ( len ( s ) ) ; <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> l = { } <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> l . add ( s ) <NEWLINE> <DEDENT> print ( len ( l ) ) <NEWLINE>
a = p . strip ( ) <NEWLINE> l = a . split ( ) <NEWLINE> m = l . pop ( 0 ) <NEWLINE> print ( len ( set ( l ) ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <COMMENT> <NL> ans = defaultdict ( int ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> ans [ s ] += 1 <NEWLINE> <NL> <DEDENT> print ( len ( ans . keys ( ) ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> s = [ input ( ) for i in range ( N ) ] <NEWLINE> memo = [ ] <NEWLINE> <NL> for i in range ( s ) : <NEWLINE> <INDENT> r = s . random . choice ( ) <NEWLINE> if r not in memo : <NEWLINE> <INDENT> memo . append ( r ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( len ( memo ) ) <NEWLINE>
import sys <NEWLINE> import numpy as np <NEWLINE> <NL> def solve ( S ) : <NEWLINE> <INDENT> M = 2019 <NEWLINE> t = 1 <NEWLINE> ans = 0 <NEWLINE> c = np . zeros ( M , dtype = np . int64 ) <NEWLINE> c [ 0 ] = 1 <NEWLINE> r = 0 <NEWLINE> for d in S : <NEWLINE> <INDENT> r = ( d * t + r ) % M <NEWLINE> ans += c [ r ] <NEWLINE> c [ r ] += 1 <NEWLINE> t = t * 10 % M <NEWLINE> <DEDENT> return ans <NEWLINE> <NL> <NL> <NL> <DEDENT> def cc_export ( ) : <NEWLINE> <INDENT> from numba . pycc import CC <NEWLINE> cc = CC ( <STRING> ) <NEWLINE> <INDENT> S = np . array ( [ ] , dtype = np . int32 ) <NEWLINE> <DEDENT> cc . export ( <STRING> , numba . i8 ( numba . typeof ( S ) ) ) ( solve ) <NEWLINE> cc . compile ( ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> import sys <NEWLINE> if sys . argv [ - 1 ] == <STRING> : <NEWLINE> <INDENT> cc_export ( ) <NEWLINE> exit ( 0 ) <NEWLINE> <DEDENT> from my_module import solve <NEWLINE> S = sys . stdin . buffer . readline ( ) . decode ( <STRING> ) . rstrip ( ) <NEWLINE> S = np . array ( [ int ( d ) for d in S [ : : - 1 ] ] , dtype = np . int32 ) <NEWLINE> print ( solve ( S ) ) <NEWLINE> <DEDENT>
from collections import defaultdict <NEWLINE> S = input ( ) <NEWLINE> N = len ( S ) <NEWLINE> <NL> D = defaultdict ( ) <NEWLINE> prev = 0 <NEWLINE> ans = 0 <NEWLINE> for i , s in enumerate ( reversed ( S ) ) : <NEWLINE> <INDENT> cur = prev + pow ( 10 , i , 2019 ) * int ( s ) % 2019 <NEWLINE> ans += D [ cur ] <NEWLINE> D [ cur ] += 1 <NEWLINE> prev = cur <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
from collections import Counter <NEWLINE> S = input ( ) <NEWLINE> S = S + <STRING> <NEWLINE> mod = 2019 <NEWLINE> p = [ - 1 ] * len ( S ) <NEWLINE> r = 0 <NEWLINE> d = 1 <NEWLINE> for i , s in enumerate ( S [ : : - 1 ] ) : <NEWLINE> <INDENT> t = int ( s ) % mod <NEWLINE> r += t * d <NEWLINE> r %= mod <NEWLINE> d = d * 10 % mod <NEWLINE> p [ i ] = r <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> c = Counter ( p ) <NEWLINE> for k , n in c . most_common ( ) : <NEWLINE> <INDENT> if n > 1 ans n % 2 == 0 : <NEWLINE> <INDENT> ans += n // 2 <NEWLINE> <DEDENT> else : break <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <NL> s = input ( ) <NEWLINE> <NL> count = 0 <NEWLINE> counter = Counter ( [ 0 ] ) <NEWLINE> <NL> suffix = 0 <NEWLINE> pow = 1 <NEWLINE> for i in range ( len ( s ) - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> suffix = ( int ( s [ i ] ) * pow + suffix ) % 2019 <NEWLINE> pow = pow * 10 % 2019 <NEWLINE> count += counter [ suffix ] <NEWLINE> counter [ suffix ] += 1 <NEWLINE> <NL> <DEDENT> print ( count ) <NEWLINE>
import sys <NEWLINE> import itertools <NEWLINE> <COMMENT> <NL> import time <NEWLINE> import math <NEWLINE> <NL> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> <NL> from collections import defaultdict <NEWLINE> <NL> read = sys . stdin . buffer . read <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> readlines = sys . stdin . buffer . readlines <NEWLINE> <NL> n = readline ( ) . decode ( ) <NEWLINE> n = list ( reversed ( n ) ) <NEWLINE> <NL> x = 1 <NEWLINE> count = [ 0 for _ in range ( 2019 ) ] <NEWLINE> MOD = 2019 <NEWLINE> acc = 0 <NEWLINE> <NL> count [ 0 ] = 1 <NEWLINE> ans = 0 <NEWLINE> <NL> for c in n : <NEWLINE> <INDENT> a = x * int ( c ) <NEWLINE> acc += a <NEWLINE> acc %= MOD <NEWLINE> ans += count [ acc ] <NEWLINE> count [ acc ] += 1 <NEWLINE> x = ( x * 10 ) % MOD <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
from sys import stdin <NEWLINE> <COMMENT> <NL> <NL> <NL> def merge_sort ( lst , low , high ) : <NEWLINE> <INDENT> if low >= high : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> mid = int ( ( low + high ) / 2 ) <NEWLINE> merge_sort ( lst , low , mid ) <NEWLINE> merge_sort ( lst , mid + 1 , high ) <NEWLINE> for i in range ( low , mid + 1 ) : <NEWLINE> <INDENT> tmp_array [ i ] = lst [ i ] <NEWLINE> <DEDENT> j = high <NEWLINE> for i in range ( mid + 1 , high + 1 ) : <NEWLINE> <INDENT> tmp_array [ i ] = lst [ j ] <NEWLINE> j -= 1 <NEWLINE> <DEDENT> i = low <NEWLINE> j = high <NEWLINE> for k in range ( low , high + 1 ) : <NEWLINE> <INDENT> if tmp_array [ i ] <= tmp_array [ j ] : <NEWLINE> <INDENT> lst [ k ] = tmp_array [ i ] <NEWLINE> i += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> lst [ k ] = tmp_array [ j ] <NEWLINE> j -= 1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> S = stdin . readline ( ) . rstrip ( ) <NEWLINE> N = len ( S ) <NEWLINE> Sp = S <NEWLINE> <NL> res_map = [ 0 for _ in range ( N ) ] <NEWLINE> <NL> aa_list2 = [ 1 ] <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> aa_list2 . append ( ( aa_list2 [ i - 1 ] * 10 ) % 2019 ) <NEWLINE> <NL> <DEDENT> tmp_array = [ None for _ in range ( N ) ] <NEWLINE> res_map [ N - 1 ] = int ( S [ N - 1 ] ) <NEWLINE> index = 1 <NEWLINE> for i in range ( N - 2 , - 1 , - 1 ) : <NEWLINE> <INDENT> res_map [ i ] = ( int ( S [ i ] ) * aa_list2 [ index ] + res_map [ i + 1 ] ) % 2019 <NEWLINE> index += 1 <NEWLINE> <NL> <DEDENT> res_map . sort ( ) <NEWLINE> temp_num = int ( res_map [ 0 ] ) <NEWLINE> index = 1 <NEWLINE> tot = 0 <NEWLINE> <NL> aa_table = [ 0 for i in range ( 2019 ) ] <NEWLINE> aa_table2 = [ 0 for i in range ( 2019 ) ] <NEWLINE> for i in range ( len ( res_map ) ) : <NEWLINE> <INDENT> aa_table2 [ res_map [ i ] ] += 1 <NEWLINE> <NL> <DEDENT> aa_table2 [ 0 ] += 1 <NEWLINE> <NL> <COMMENT> <NL> for i in range ( 1 , N ) : <NEWLINE> <INDENT> if res_map [ i ] < res_map [ i - 1 ] : <NEWLINE> <INDENT> aa = 2 / 0 <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( 1 , len ( res_map ) ) : <NEWLINE> <INDENT> if temp_num == int ( res_map [ i ] ) : <NEWLINE> <INDENT> index += 1 <NEWLINE> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> aa_table [ temp_num ] = index <NEWLINE> index = 1 <NEWLINE> temp_num = int ( res_map [ i ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> aa_table [ 0 ] += 1 <NEWLINE> <NL> for i in range ( 2018 ) : <NEWLINE> <INDENT> if aa_table [ i ] != aa_table2 [ i ] : <NEWLINE> <INDENT> aa = 2 / 0 <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> <DEDENT> <DEDENT> tot = 0 <NEWLINE> for i in range ( 2019 ) : <NEWLINE> <INDENT> tot += int ( ( aa_table [ i ] - 1 ) * aa_table [ i ] / 2 ) <NEWLINE> <NL> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> <DEDENT> print ( tot ) <NEWLINE> <NL>
s = input ( ) <NEWLINE> MOD = 2019 <NEWLINE> r = [ 0 ] * MOD <NEWLINE> r [ 0 ] = 1 <NEWLINE> z = 0 <NEWLINE> t = 0 <NEWLINE> for i in reversed ( s ) : <NEWLINE> <INDENT> z = int ( i ) * pow ( 10 , t , m ) + z <NEWLINE> z %= MOD <NEWLINE> r [ z ] += 1 <NEWLINE> t += 1 <NEWLINE> <DEDENT> print ( sum ( i * ( i - 1 ) // 2 for i in r ) ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> li = list ( range ( N + 1 ) ) <NEWLINE> count = 0 <NEWLINE> <NL> <COMMENT> <NL> for i in range ( M , N + 2 ) : <NEWLINE> <INDENT> small = ( i * ( i - 1 ) ) // 2 <NEWLINE> large = small + li [ - i ] * i <NEWLINE> count += large - small + 1 <NEWLINE> <NL> <DEDENT> print ( count % ( pow ( 10 , 9 ) + 7 ) ) <NEWLINE>
S = input ( ) <NEWLINE> A = [ 0 for i in range ( 2019 ) ] <NEWLINE> x = 0 <NEWLINE> for i in range ( len ( S ) ) : <NEWLINE> <INDENT> p = i + 1 <NEWLINE> a = ( int ( S [ - p ] ) ) 10 ** i % 2019 <NEWLINE> x = ( x + a ) % 2019 <NEWLINE> A [ x ] += 1 <NEWLINE> <DEDENT> ans += A [ i ] <NEWLINE> for i in range ( 2019 ) : <NEWLINE> <INDENT> ans += A [ i ] * ( A [ i ] - 1 ) // 2 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> input = sys . stdin . readline <COMMENT> <NEWLINE> int1 = lambda x : int ( x ) - 1 <NEWLINE> def II ( ) : return int ( input ( ) ) <NEWLINE> <NL> def MI ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def MI1 ( ) : return map ( int1 , input ( ) . split ( ) ) <NEWLINE> <NL> def LI ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> def LI1 ( ) : return list ( map ( int1 , input ( ) . split ( ) ) ) <NEWLINE> def LLI ( rows_number ) : return [ LI ( ) for _ in range ( rows_number ) ] <NEWLINE> <NL> INF = float ( <STRING> ) <NEWLINE> <NL> def solve ( ) : <NEWLINE> <INDENT> S = list ( map ( int , list ( input ( ) ) ) ) <NEWLINE> <NL> S = S [ : : - 1 ] <NEWLINE> <COMMENT> <NL> n = len ( S ) <NEWLINE> mod = 2019 <NEWLINE> <NL> <COMMENT> <NL> A = [ 0 ] * ( n ) <NEWLINE> a = 1 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> A [ i ] = S [ i ] * a <NEWLINE> a = a * 10 % mod <NEWLINE> <COMMENT> <NL> <NL> <COMMENT> <NL> <DEDENT> R = [ 0 ] * ( n + 1 ) <NEWLINE> for j in range ( n ) : <NEWLINE> <INDENT> R [ j + 1 ] = ( R [ j ] + A [ j ] ) % mod <NEWLINE> <COMMENT> <NL> <NL> <COMMENT> <NL> <DEDENT> cnt = { } <NEWLINE> ans = 0 <NEWLINE> for l in range ( 0 , n + 1 ) : <NEWLINE> <INDENT> r = R [ l ] <NEWLINE> ans = ans + cnt . get ( r , 0 ) <NEWLINE> cnt [ r ] = cnt . setdefault ( r , 0 ) + 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> solve ( ) <NEWLINE> <DEDENT>
from collections import Counter <NEWLINE> <NL> <COMMENT> <NL> <NL> S = input ( ) <NEWLINE> S = S [ : : - 1 ] <NEWLINE> <NL> mods = [ 0 ] * ( len ( S ) + 1 ) <NEWLINE> mods [ 0 ] = int ( S [ 0 ] ) % 2019 <NEWLINE> <NL> for i in range ( len ( mods ) - 1 - 1 ) : <NEWLINE> <INDENT> mods [ i + 1 ] = ( int ( S [ i + 1 ] ) * 10 ** ( i + 1 ) + mods [ i ] ) % 2019 <NEWLINE> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <NL> <DEDENT> print ( ans ) <NEWLINE>
<NL> S = str ( input ( ) ) <NEWLINE> l = len ( S ) <NEWLINE> ans = 0 <NEWLINE> <NL> mod = [ 0 ] * 2019 <NEWLINE> mod [ 0 ] += 1 <NEWLINE> t = 0 <NEWLINE> for i in range ( l ) : <NEWLINE> <INDENT> t = int ( S [ l - i : - 1 : - 1 ] ) * pow ( 10 , i , 2019 ) <NEWLINE> mod [ t % 2019 ] += 1 <NEWLINE> <NL> <DEDENT> for j in range ( len ( mod ) ) : <NEWLINE> <INDENT> m = mod [ j ] <NEWLINE> ans = ans + m * ( m - 1 ) // 2 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import collections <NEWLINE> import sys <NEWLINE> S = input ( ) [ : : - 1 ] <NEWLINE> <NL> MOD = 2019 <NEWLINE> X = [ 0 ] <NEWLINE> for i , s in enumerate ( S ) : <NEWLINE> <INDENT> X . append ( ( X [ - 1 ] + int ( s ) * pow ( 10 , i , MOD ) ) % MOD ) <NEWLINE> <NL> <DEDENT> c = collections . Counter ( X ) <NEWLINE> ans = 0 <NEWLINE> for v in C . values ( ) : <NEWLINE> <INDENT> ans += v * ( v - 1 ) // 2 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
s = input ( ) <NEWLINE> c = 0 <NEWLINE> t = [ 0 ] * ( len ( s ) + 1 ) <NEWLINE> for i in [ str ( i * 2019 ) for i in range ( 1 , 10000 ) if <STRING> not in str ( 2019 * i ) ] : <NEWLINE> <INDENT> idx = - 1 <NEWLINE> while s [ idx + 1 : ] . count ( i ) > 0 : <NEWLINE> <INDENT> idx = s [ idx + 1 : ] . find ( i ) <NEWLINE> t [ idx + len ( i ) ] += 1 + t [ idx ] <NEWLINE> c += 1 <NEWLINE> c += t [ idx ] <NEWLINE> <DEDENT> <DEDENT> print ( c ) <NEWLINE>
s = input ( ) <NEWLINE> n = len ( s ) <NEWLINE> s_int = [ 0 ] * n <NEWLINE> x = pow ( 10 , n - 1 ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> s_int [ i ] = int ( s [ i ] * x ) % 2019 <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> <COMMENT> <NL> from numba import njit <NEWLINE> <NL> <NL> @ njit <NEWLINE> def loof ( a , N , memo ) : <NEWLINE> <INDENT> M = np . zeros ( 2019 , dtype = np . int16 ) <NEWLINE> M [ 0 ] += 1 <NEWLINE> T = 0 <NEWLINE> for i in range ( N - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> T = a [ i ] * memo [ N - i - 1 ] + T <NEWLINE> m = T % 2019 <NEWLINE> M [ m ] += 1 <NEWLINE> <DEDENT> return M <NEWLINE> <NL> <NL> <DEDENT> @ njit <NEWLINE> def pow_mod ( a , n , mod ) : <NEWLINE> <INDENT> memo = np . array ( [ 1 ] ) <NEWLINE> if n >= 1 : <NEWLINE> <INDENT> for i in range ( n - 1 ) : <NEWLINE> <INDENT> memo = np . append ( memo , memo [ - 1 ] * a % mod ) <NEWLINE> <DEDENT> return memo <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <INDENT> S = input ( ) . rstrip ( ) <NEWLINE> S = list ( map ( int , list ( S ) ) ) <NEWLINE> a = np . array ( S ) <NEWLINE> <NL> N = len ( a ) <NEWLINE> <NL> memo = pow_mod ( 10 , N , 2019 ) <NEWLINE> M = loof ( a , N , memo ) <NEWLINE> <NL> res = 0 <NEWLINE> <NL> for m in M : <NEWLINE> <INDENT> res += m * ( m - 1 ) // 2 <NEWLINE> <NL> <DEDENT> print ( res ) <NEWLINE> <NL> <NL> <DEDENT> main ( ) <NEWLINE>
s = input ( ) <NEWLINE> <NL> mod = [ 1 ] + [ 0 ] * 2018 <NEWLINE> t = 0 <NEWLINE> a = 0 <NEWLINE> n = len ( s ) <NEWLINE> s = reversed ( s ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> t += int ( s [ i ] ) * ( 10 ** a ) <NEWLINE> a += 1 <NEWLINE> mod [ t % 2019 ] += 1 <NEWLINE> print ( t , t % 2019 ) <NEWLINE> <DEDENT> ans = 0 <NEWLINE> for i in range ( 2019 ) : <NEWLINE> <INDENT> ans += mod [ i ] * ( mod [ i ] - 1 ) // 2 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
S = input ( ) <NEWLINE> T = [ 0 ] * 2019 <NEWLINE> T [ 0 ] = 1 <NEWLINE> t = 0 <NEWLINE> ans = 0 <NEWLINE> dig = 1 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> t = ( t + ( int ( S [ - i - 1 ] ) ) * dig ) % 2019 <NEWLINE> dig = ( dig * 10 ) % 2019 <NEWLINE> T [ t ] += 1 <NEWLINE> <DEDENT> for j in T : <NEWLINE> <INDENT> ans += int ( j * ( j - 1 ) / 2 ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import numpy as np <NEWLINE> s = input ( ) <NEWLINE> y = 2019 <NEWLINE> dp = np . zeros ( y , dtype = <STRING> ) <NEWLINE> tmp = np . zeros ( y , dtype = <STRING> ) <NEWLINE> k = 1 <NEWLINE> r = 0 <NEWLINE> for c in s [ : : - 1 ] : <NEWLINE> <INDENT> i = int ( c ) * k % y <NEWLINE> tmp [ i : ] = dp [ : y - i ] <NEWLINE> tmp [ : i ] = dp [ - i : ] <NEWLINE> tmp [ i ] += 1 <NEWLINE> dp , tmp = tmp , dp <NEWLINE> r += dp [ 0 ] <NEWLINE> k *= 10 <NEWLINE> k %= y <NEWLINE> <DEDENT> print ( r ) 1 <NEWLINE>
s = input ( ) <NEWLINE> result = 0 <NEWLINE> <NL> for i in range ( int ( s ) // 2019 ) : <NEWLINE> <INDENT> b = ( i + 1 ) * 2019 <NEWLINE> result += s . count ( str ( b ) ) <NEWLINE> <NL> <DEDENT> print ( result ) <NEWLINE>
s = input ( ) <NEWLINE> ans = 0 <NEWLINE> sss = [ ] <NEWLINE> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> for j in range ( len ( s ) ) : <NEWLINE> <INDENT> a = s [ i : i + j + 2 ] <NEWLINE> sss . append ( a ) <NEWLINE> <NL> <DEDENT> <DEDENT> sssss = set ( sss ) <NEWLINE> for i in sssss : <NEWLINE> <INDENT> if int ( sssss [ i ] ) % 2019 == 0 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from collections import deque <NEWLINE> s = deque ( input ( ) ) <NEWLINE> n = len ( s ) <NEWLINE> <NL> temp = [ 0 ] * 2019 <NEWLINE> t = 1 <NEWLINE> num = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> num += int ( s . pop ( ) ) * t % 2019 <NEWLINE> temp [ num ] += 1 <NEWLINE> t *= 10 <NEWLINE> <NL> <DEDENT> ans = temp [ 0 ] <NEWLINE> for t in temp : <NEWLINE> <INDENT> if t > 1 : <NEWLINE> <INDENT> ans += t * ( t - 1 ) / 2 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( int ( ans ) ) <NEWLINE>
s_len = len ( s ) <NEWLINE> ref = [ 0 ] * s_len <NEWLINE> <NL> for i in range ( 1 , s_len + 1 ) : <NEWLINE> <INDENT> ref [ - i ] = int ( s [ - i ] ) * pow ( 10 , i , MOD ) % MOD <NEWLINE> <NL> <DEDENT> for i in range ( 1 , s_len ) : <NEWLINE> <INDENT> ref [ - i - 1 ] += ref [ - i ] <NEWLINE> ref [ - i - 1 ] %= MOD <NEWLINE> <NL> <DEDENT> ref_cnt = Counter ( ref ) <NEWLINE> ans = sum ( ref_cnt . values ( ) ) - len ( ref_cnt ) <NEWLINE> <NL> <NL> for i in ref_cnt . values ( ) : <NEWLINE> <INDENT> ans += ( i - 1 ) * ( i - 2 ) // 2 <NEWLINE> <NL> <DEDENT> if 0 in ref : <NEWLINE> <INDENT> ans += ref_cnt [ 0 ] <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> <NL> def readInt ( ) : <NEWLINE> <INDENT> return int ( input ( ) ) <NEWLINE> <NL> <DEDENT> def readInts ( ) : <NEWLINE> <INDENT> return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <DEDENT> def readChars ( ) : <NEWLINE> <INDENT> return input ( ) . split ( ) <NEWLINE> <NL> <DEDENT> s = reversed ( input ( ) ) <NEWLINE> <NL> ai = 0 <NEWLINE> si = [ 0 ] * len ( s ) <NEWLINE> <NL> p = 2019 <NEWLINE> <NL> for i , j in enumerate ( s ) : <NEWLINE> <INDENT> ai = ( int ( j ) * pow ( 10 , i , p ) ) % p <NEWLINE> si [ i ] = ( si [ i - 1 ] + ai ) % p <NEWLINE> <DEDENT> countarr = [ 0 ] * 2019 <NEWLINE> for i in si : <NEWLINE> <INDENT> countarr [ i ] += 1 <NEWLINE> <NL> <DEDENT> res = countarr [ 0 ] <NEWLINE> for i in range ( p ) : <NEWLINE> <INDENT> c = countarr [ i ] <NEWLINE> res += c * ( c - 1 ) // 2 <NEWLINE> <NL> <DEDENT> print ( res ) <NEWLINE>
from collections import Counter <NEWLINE> <NL> S = str ( input ( ) ) <NEWLINE> <NL> memo = [ 0 ] <NEWLINE> d = 0 <NEWLINE> mod = 2019 <NEWLINE> <NL> <NL> for s in S [ : : - 1 ] : <NEWLINE> <INDENT> tmp = int ( s ) * pow ( 10 , d , mod ) % mod <NEWLINE> tmp = memo [ - 1 ] + tmp <NEWLINE> memo . appemd ( tmp % mod ) <NEWLINE> d += 1 <NEWLINE> <NL> <DEDENT> c = Counter ( memo ) <NEWLINE> ans = sum ( v * ( v - 1 ) / 2 for v in c . values ( ) ) <NEWLINE> print ( ans ) <NEWLINE> <NL>
s = input ( ) <NEWLINE> s . reverse ( ) <NEWLINE> MOD = 2019 <NEWLINE> a = [ 0 ] * MOD <NEWLINE> a [ 0 ] = 1 <NEWLINE> c_ = 0 <NEWLINE> ans = 0 <NEWLINE> t = 1 <NEWLINE> for i in s : <NEWLINE> <INDENT> c = ( c_ + int ( i ) * t ) % MOD <NEWLINE> a [ c ] += 1 <NEWLINE> t *= 10 <NEWLINE> t %= MOD <NEWLINE> c_ = c <NEWLINE> <DEDENT> for i in a : <NEWLINE> <INDENT> ans += i * ( i - 1 ) // 2 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
S = input ( ) <NEWLINE> <NL> p = 2019 <NEWLINE> N = len ( S ) <NEWLINE> t = [ 0 ] * ( N + 1 ) <NEWLINE> for i in range ( N - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> k = ( int ( S [ i ] ) * pow ( 10 , N - i - 1 , p ) ) % p <NEWLINE> t [ i ] = ( t [ i + 1 ] + k ) % p <NEWLINE> <DEDENT> t = t [ : N ] <NEWLINE> cnt = [ 0 ] * p <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> cnt [ t [ i ] ] += 1 <NEWLINE> <DEDENT> ans = cnt [ 0 ] <NEWLINE> for i in rxange ( 1 , p ) : <NEWLINE> <INDENT> m = cnt [ i ] <NEWLINE> ans += ( m * ( m - 1 ) ) // 2 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
p = 2019 <NEWLINE> s , a , d , z = reversed ( input ( ) ) , 0 , 0 , [ 0 ] * p <NEWLINE> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> d = ( d + ( int ( s [ i ] ) * pow ( 10 , i , p ) ) ) % p <NEWLINE> z [ d ] += 1 <NEWLINE> <DEDENT> r = z [ 0 ] <NEWLINE> for i in range ( p ) : <NEWLINE> <INDENT> r += z [ i ] * ( z [ i ] - 1 ) // 2 <NEWLINE> <DEDENT> print ( r ) <NEWLINE>
S = str ( input ( ) ) <NEWLINE> remainderDictionary = { } <NEWLINE> <NL> sum = 0 <NEWLINE> x = 1 <NEWLINE> for i in S : <NEWLINE> <INDENT> sum += int ( i ) * x <NEWLINE> remainder = sum % 2019 <NEWLINE> remainderDictionary [ remainder ] += remainderDictionary . get ( remainder , 0 ) + 1 <NEWLINE> x = ( x * 10 ) % 2019 <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in remainderDictionary : <NEWLINE> <INDENT> value = remainderDictionary [ i ] <NEWLINE> ans += value * ( value - 1 ) // 2 <COMMENT> <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
from statistics import median <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> from fractions import gcd <NEWLINE> from itertools import combinations <COMMENT> <NEWLINE> from collections import deque <NEWLINE> from collections import defaultdict <NEWLINE> import bisect <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> import sys <NEWLINE> sys . setrecursionlimit ( 10000000 ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> def readInts ( ) : <NEWLINE> <INDENT> return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <DEDENT> def main ( ) : <NEWLINE> <INDENT> S = input ( ) <NEWLINE> cnt = 0 <NEWLINE> start = 0 <NEWLINE> while start + 4 < len ( S ) : <NEWLINE> <INDENT> for i in range ( start + 4 , len ( S ) + 1 ) : <NEWLINE> <INDENT> if S [ i - 1 ] == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if int ( S [ start : i ] ) % 2019 == 0 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> start += 2 <NEWLINE> <DEDENT> print ( cnt ) <NEWLINE> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> read = sys . stdin . buffer . read <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> readlines = sys . stdin . buffer . readlines <NEWLINE> import numpy as np <NEWLINE> from numba import njit <NEWLINE> <NL> @ njit ( <STRING> ) <NEWLINE> def solve ( S ) : <NEWLINE> <INDENT> dp = np . zeros ( 2019 , np . int64 ) <NEWLINE> pow10 = 1 <NEWLINE> answer = 0 <NEWLINE> for x in S [ : : - 1 ] : <NEWLINE> <INDENT> dp [ 0 ] += 1 <NEWLINE> x = x * pow10 % 2019 <NEWLINE> newdp = np . zeros_like ( dp ) <NEWLINE> newdp [ x : ] += dp [ : - x ] <NEWLINE> newdp [ : x ] += dp [ - x : ] <NEWLINE> answer += newdp [ 0 ] <NEWLINE> pow10 *= 10 <NEWLINE> pow10 %= 2019 <NEWLINE> dp = newdp <NEWLINE> <DEDENT> return answer <NEWLINE> <NL> <NL> <DEDENT> S = np . array ( list ( read ( ) . rstrip ( ) ) , dtype = np . int32 ) - ord ( <STRING> ) <NEWLINE> print ( solve ( S ) ) <NEWLINE>
s = input ( ) <NEWLINE> n = len ( s ) <NEWLINE> l = [ 0 ] * 2019 <NEWLINE> l [ 0 ] = 1 <NEWLINE> k = 0 <NEWLINE> mod = 2019 <NEWLINE> r = 1 <NEWLINE> for i in range ( n - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> k += int ( s [ i ] ) * r <NEWLINE> r *= 10 <NEWLINE> r %= mod <NEWLINE> l [ k ] += 1 <NEWLINE> <DEDENT> ans = 0 <NEWLINE> for i in l : <NEWLINE> <INDENT> ans += i * ( i - 1 ) // 2 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
s = [ int ( a ) for a in input ( ) [ : : - 1 ] ] <NEWLINE> <NL> m = 2019 <NEWLINE> n = len ( S ) <NEWLINE> <NL> f = 0 <NEWLINE> <NL> p = 1 <NEWLINE> <NL> X = [ 0 ] * 2019 <NEWLINE> <NL> X [ 0 ] = 1 <NEWLINE> <NL> q = 0 <NEWLINE> <NL> for a in S : <NEWLINE> <INDENT> f = ( f + a * p ) % m <NEWLINE> q += X [ f ] <NEWLINE> <NL> X [ s ] += 1 <NEWLINE> <NL> p = p * 10 % m <NEWLINE> <NL> <NL> <DEDENT> print ( q ) <NEWLINE>
a = 2019 <NEWLINE> for i in range ( int ( a ** 0.5 ) ) : <NEWLINE> <INDENT> if a % i == 0 : <NEWLINE> <INDENT> print ( i ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT>
<STRING> a / b  <STRING> a , b <STRING> <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> <NL> cnt = [ 0 ] * 2019 <NEWLINE> <COMMENT> <NL> cnt [ 0 ] = 1 <NEWLINE> ans = 0 <NEWLINE> b = 0 <NEWLINE> t = 1 <NEWLINE> for i in s : <NEWLINE> <INDENT> b = b + int ( i ) * t <NEWLINE> amari = b % 2019 <NEWLINE> cnt [ amari ] += 1 <NEWLINE> t *= 10 % 2019 <NEWLINE> <NL> <DEDENT> for i in cnt : <NEWLINE> <INDENT> ans += i * ( i - 1 ) // 2 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> <COMMENT> <NL> import math <NEWLINE> import collections <NEWLINE> <COMMENT> <NL> import bisect <NEWLINE> import itertools <NEWLINE> import fractions <NEWLINE> <COMMENT> <NL> import copy <NEWLINE> import heapq <NEWLINE> import decimal <NEWLINE> <COMMENT> <NL> import queue <NEWLINE> <NL> <COMMENT> <NL> <NL> sys . setrecursionlimit ( 10000001 ) <NEWLINE> INF = 10 ** 16 <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> <COMMENT> <NL> <NL> ni = lambda : int ( sys . stdin . readline ( ) ) <NEWLINE> ns = lambda : map ( int , sys . stdin . readline ( ) . split ( ) ) <NEWLINE> na = lambda : list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> <COMMENT> <NL> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> s = sys . stdin . readline ( ) <NEWLINE> <NL> cnt = [ 0 for _ in range ( 2019 ) ] <NEWLINE> cnt [ 0 ] += 1 <NEWLINE> dec = 1 <NEWLINE> num = 0 <NEWLINE> for i in reversed ( s ) : <NEWLINE> <INDENT> num += int ( i ) * dec <NEWLINE> num %= 2019 <NEWLINE> dec *= 10 <NEWLINE> cnt [ num ] += 1 <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for c in cnt : <NEWLINE> <INDENT> ans += c * ( c - 1 ) // 2 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> n = 0 <NEWLINE> ans = 0 <NEWLINE> mods = [ 0 ] * p <NEWLINE> mods [ 0 ] = 1 <NEWLINE> for i , j in enumerate ( reversed ( s ) ) : <NEWLINE> <INDENT> n += int ( j ) * pow ( 10 , i , 2019 ) <NEWLINE> n %= 2019 <NEWLINE> mods [ n ] += 1 <NEWLINE> <DEDENT> for i in mods : <NEWLINE> <INDENT> ans += i * ( i - 1 ) // 2 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
s = input ( ) [ : : - 1 ] <NEWLINE> ans = 0 <NEWLINE> u = 0 <NEWLINE> d = 1 <NEWLINE> l = [ 0 ] * 2019 <NEWLINE> l [ 0 ] = 1 <NEWLINE> for i in map ( int , s ) : <NEWLINE> <INDENT> u = u + ( i * d ) % 2019 <NEWLINE> l [ u ] += 1 <NEWLINE> d = d * 10 % 2019 <NEWLINE> <DEDENT> for i in l : <NEWLINE> <INDENT> ans += i * ( i - 1 ) // 2 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
s = list ( input ( ) ) <NEWLINE> mods = [ 0 ] * ( len ( s ) ) <NEWLINE> countRemainder = [ 0 ] * 2019 <NEWLINE> cnt = 0 <NEWLINE> <NL> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> mods [ 0 ] = int ( s [ - 1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> mods [ i ] = mods [ i - 1 ] + ( 10 ** i % 2019 ) * int ( s [ len ( s ) - i - 1 ] ) <NEWLINE> <DEDENT> countRemainder [ mods [ i ] ] += 1 <NEWLINE> <NL> <DEDENT> countRemainder [ 0 ] += 1 <NEWLINE> <NL> for i in range ( 2019 ) : <NEWLINE> <INDENT> cnt += int ( countRemainder [ i ] * ( countRemainder [ i ] - 1 ) / 2 ) <NEWLINE> <NL> <DEDENT> print ( cnt ) <NEWLINE> <NL>
s = input ( ) <NEWLINE> s = list ( reversed ( s ) ) <NEWLINE> n = len ( s ) <NEWLINE> dp1 = [ 0 ] * n <NEWLINE> dp2 = [ 0 ] * n <NEWLINE> counting = [ 0 ] * 2019 <NEWLINE> counitng [ 0 ] += 1 <NEWLINE> dp1 [ 0 ] = 1 <NEWLINE> dp2 [ 0 ] = int ( s [ 0 ] ) <NEWLINE> counting [ dp2 [ 0 ] ] += 1 <NEWLINE> if n >= 2 : <NEWLINE> <INDENT> for i in range ( 1 , n ) : <NEWLINE> <INDENT> dp1 [ i ] = ( 10 * dp1 [ i - 1 ] ) % 2019 <NEWLINE> dp2 [ i ] = ( int ( s [ i ] ) * dp1 [ i ] + dp2 [ i - 1 ] ) % 2019 <NEWLINE> counting [ dp2 [ i ] ] += 1 <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> sm = 0 <NEWLINE> for j in range ( 2019 ) : <NEWLINE> <INDENT> sm += int ( counting [ j ] * ( counting [ j ] - 1 ) / 2 ) <NEWLINE> <DEDENT> print ( sm ) <NEWLINE>
S = input ( ) <NEWLINE> MOD = 2019 <NEWLINE> cnt = [ 0 ] * MOD <NEWLINE> cur = 0 <COMMENT> <NEWLINE> cnt [ cur ] = 1 <COMMENT> <NEWLINE> d = 1 <COMMENT> <NEWLINE> for s in for S [ : : - 1 ] : <NEWLINE> <INDENT> cur += int ( s ) * d <COMMENT> <NEWLINE> r %= MOD <NEWLINE> cnt [ cur ] += 1 <NEWLINE> <COMMENT> <NL> d *= 10 <COMMENT> <NEWLINE> d %= MOD <COMMENT> <NEWLINE> <DEDENT> ans = 0 <NEWLINE> for c in cnt : <NEWLINE> <INDENT> ans += c * ( c - 1 ) // 2 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL>
S = str ( input ( ) ) <NEWLINE> <NL> <COMMENT> <NL> A = [ ] <NEWLINE> p = 1 <NEWLINE> for i in range ( len ( S ) ) : <NEWLINE> <INDENT> A . append ( p ) <NEWLINE> p = p * 10 % 2019 <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> X = [ ] <NEWLINE> a = 0 <NEWLINE> for i in range ( len ( S ) ) : <NEWLINE> <INDENT> a = ( a + int ( S [ len ( S ) - i - 1 ] ) * A [ i ] ) % 2019 <NEWLINE> X . append ( a ) <NEWLINE> <DEDENT> X . sort ( ) <NEWLINE> flag = 1 <NEWLINE> n = 0 <NEWLINE> <NL> <COMMENT> <NL> for i in range ( len ( X ) ) : <NEWLINE> <INDENT> if X [ i ] == 0 : <NEWLINE> <INDENT> n += 1 <NEWLINE> <DEDENT> if X [ i ] == X [ i + 1 ] : <NEWLINE> <INDENT> flag += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> n += int ( flag * ( flag - 1 ) / 2 ) <NEWLINE> flag = 1 <NEWLINE> <DEDENT> <DEDENT> if X [ len ( X ) - 1 ] == 0 : <NEWLINE> <INDENT> n += 1 <NEWLINE> <DEDENT> print ( n ) <NEWLINE>
s = input ( ) <NEWLINE> <NL> mod = [ 0 ] * 2019 <NEWLINE> mod [ 0 ] = 1 <NEWLINE> d = 1 <NEWLINE> n = 0 <NEWLINE> ans = 0 <NEWLINE> <NL> for i in reversed ( s ) : <NEWLINE> <INDENT> n += int ( i ) * d <NEWLINE> n %= 2019 <NEWLINE> d *= 10 <NEWLINE> d %= 2019 <NEWLINE> mod [ n % 2019 ] += 1 <NEWLINE> <NL> <DEDENT> for i in mod : <NEWLINE> <INDENT> ans += sum ( i * ( i - 1 ) // 2 ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
S = input ( ) <NEWLINE> cnt = [ 0 ] * 2019 <NEWLINE> cnt [ 0 ] = 1 <NEWLINE> n = 0 <NEWLINE> t = 1 <NEWLINE> for i in reversed ( S ) : <NEWLINE> <INDENT> n += i * t <NEWLINE> n %= 2019 <NEWLINE> cnt [ n ] += 1 <NEWLINE> t *= 10 <NEWLINE> t %= 2019 <NEWLINE> <DEDENT> print ( sum ( i * ( i - 1 ) // 2 for i in cnt ) ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> S = input ( ) [ : : - 1 ] <NEWLINE> ans = 0 <NEWLINE> mods = [ 0 ] * 2019 <NEWLINE> mods [ 0 ] = 1 <NEWLINE> current = 0 <NEWLINE> x = 1 <NEWLINE> for s in S : <NEWLINE> <INDENT> current = ( current + x * int ( s ) ) % 2019 <NEWLINE> mods [ current % 2019 ] += 1 <NEWLINE> x = x * 10 % 2019 <NEWLINE> <NL> <DEDENT> for i in len ( mods ) : <NEWLINE> <INDENT> ans += mods [ i ] * ( mods [ i ] - 1 ) // 2 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> n = len ( s ) <NEWLINE> m = 2019 <NEWLINE> a = 0 <NEWLINE> r = [ 0 for _ in range ( m + 1 ) ] <NEWLINE> r [ 0 ] = 1 <NEWLINE> for i in range ( 0 , n ) : <NEWLINE> <INDENT> z = ( int ( s [ n - i - 1 ] ) * pow ( 10 , i , m ) + z ) % m <NEWLINE> a += r [ z ] <NEWLINE> r [ z ] += 1 <NEWLINE> <DEDENT> print ( a ) <NEWLINE>
<COMMENT> <NL> from __future__ import division , print_function <NEWLINE> <NL> import os <NEWLINE> import sys <NEWLINE> from io import BytesIO , IOBase <NEWLINE> <NL> if sys . version_info [ 0 ] < 3 : <NEWLINE> <INDENT> from __builtin__ import xrange as range <NEWLINE> from future_builtins import ascii , filter , hex , map , oct , zip <NEWLINE> <NL> <NL> <COMMENT> <NL> <NL> <DEDENT> BUFSIZE = 8192 <NEWLINE> <NL> <NL> class FastIO ( IOBase ) : <NEWLINE> <INDENT> newlines = 0 <NEWLINE> <NL> def __init__ ( self , file ) : <NEWLINE> <INDENT> self . _fd = file . fileno ( ) <NEWLINE> self . buffer = BytesIO ( ) <NEWLINE> self . writable = <STRING> in file . mode or <STRING> not in file . mode <NEWLINE> self . write = self . buffer . write if self . writable else None <NEWLINE> <NL> <DEDENT> def read ( self ) : <NEWLINE> <INDENT> while True : <NEWLINE> <INDENT> b = os . read ( self . _fd , max ( os . fstat ( self . _fd ) . st_size , BUFSIZE ) ) <NEWLINE> if not b : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> ptr = self . buffer . tell ( ) <NEWLINE> self . buffer . seek ( 0 , 2 ) , self . buffer . write ( b ) , self . buffer . seek ( ptr ) <NEWLINE> <DEDENT> self . newlines = 0 <NEWLINE> return self . buffer . read ( ) <NEWLINE> <NL> <DEDENT> def readline ( self ) : <NEWLINE> <INDENT> while self . newlines == 0 : <NEWLINE> <INDENT> b = os . read ( self . _fd , max ( os . fstat ( self . _fd ) . st_size , BUFSIZE ) ) <NEWLINE> self . newlines = b . count ( <STRING> ) + ( not b ) <NEWLINE> ptr = self . buffer . tell ( ) <NEWLINE> self . buffer . seek ( 0 , 2 ) , self . buffer . write ( b ) , self . buffer . seek ( ptr ) <NEWLINE> <DEDENT> self . newlines -= 1 <NEWLINE> return self . buffer . readline ( ) <NEWLINE> <NL> <DEDENT> def flush ( self ) : <NEWLINE> <INDENT> if self . writable : <NEWLINE> <INDENT> os . write ( self . _fd , self . buffer . getvalue ( ) ) <NEWLINE> self . buffer . truncate ( 0 ) , self . buffer . seek ( 0 ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> class IOWrapper ( IOBase ) : <NEWLINE> <INDENT> def __init__ ( self , file ) : <NEWLINE> <INDENT> self . buffer = FastIO ( file ) <NEWLINE> self . flush = self . buffer . flush <NEWLINE> self . writable = self . buffer . writable <NEWLINE> self . write = lambda s : self . buffer . write ( s . encode ( <STRING> ) ) <NEWLINE> self . read = lambda : self . buffer . read ( ) . decode ( <STRING> ) <NEWLINE> self . readline = lambda : self . buffer . readline ( ) . decode ( <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def print ( * args , ** kwargs ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> sep , file = kwargs . pop ( <STRING> , <STRING> ) , kwargs . pop ( <STRING> , sys . stdout ) <NEWLINE> at_start = True <NEWLINE> for x in args : <NEWLINE> <INDENT> if not at_start : <NEWLINE> <INDENT> file . write ( sep ) <NEWLINE> <DEDENT> file . write ( str ( x ) ) <NEWLINE> at_start = False <NEWLINE> <DEDENT> file . write ( kwargs . pop ( <STRING> , <STRING> ) ) <NEWLINE> if kwargs . pop ( <STRING> , False ) : <NEWLINE> <INDENT> file . flush ( ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if sys . version_info [ 0 ] < 3 : <NEWLINE> <INDENT> sys . stdin , sys . stdout = FastIO ( sys . stdin ) , FastIO ( sys . stdout ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> sys . stdin , sys . stdout = IOWrapper ( sys . stdin ) , IOWrapper ( sys . stdout ) <NEWLINE> <NL> <NL> <DEDENT> from math import sqrt , floor , factorial , gcd , log <NEWLINE> from collections import deque , Counter , defaultdict <NEWLINE> from itertools import permutations <NEWLINE> from bisect import bisect <NEWLINE> <NL> input = lambda : sys . stdin . readline ( ) . rstrip ( <STRING> ) <NEWLINE> read = lambda : list ( map ( int , input ( ) . strip ( ) . split ( <STRING> ) ) ) <NEWLINE> <NL> <COMMENT> <NL> <NL> <NL> <NL> def solve ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) ; arr = read ( ) <NEWLINE> mex = 0 ; curr = 1 <NEWLINE> ans = [ ] <NEWLINE> last = 0 <NEWLINE> for i in arr : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <INDENT> if curr < i : <NEWLINE> <INDENT> print ( - 1 ) ; exit ( ) <NEWLINE> <DEDENT> if i == mex : <NEWLINE> <INDENT> ans . append ( curr ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans . append ( mex ) <NEWLINE> mex = curr <NEWLINE> curr += 1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> print ( * ans ) <NEWLINE> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> solve ( ) <NEWLINE> <DEDENT>
import collections <NEWLINE> s = input ( ) <NEWLINE> n = len ( s ) <NEWLINE> mod_list = [ 0 ] <NEWLINE> <NL> T = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> T += int ( s [ - 1 - i ] ) * pow ( 10 , i , 2019 ) % 2019 <NEWLINE> T = T % 2019 <NEWLINE> mod_list . append ( T ) <NEWLINE> <NL> <DEDENT> res = collections . Counter ( mod_list ) <NEWLINE> cnt = 0 <NEWLINE> for d in res . values : <NEWLINE> <INDENT> cnt += int ( d * ( d - 1 ) / 2 ) <NEWLINE> <DEDENT> print ( cnt ) <NEWLINE>
s = input ( ) [ : : - 1 ] <NEWLINE> p = 0 <NEWLINE> dp = [ 0 ] * 2019 <NEWLINE> dp [ 0 ] = 1 <NEWLINE> for i in s : <NEWLINE> <INDENT> p = ( p + ( int ( s ) * ( 10 ** ( i ) ) ) ) % 2019 <NEWLINE> dp [ p ] += 1 <NEWLINE> <DEDENT> ans = 0 <NEWLINE> for i in dp : <NEWLINE> <INDENT> ans += i * ( i - 1 ) // 2 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import re <NEWLINE> S = input ( ) <NEWLINE> <COMMENT> <NL> <NL> s = [ ] <NEWLINE> for i in range ( int ( S ) // 2019 // 5 ) : <NEWLINE> <INDENT> s . append ( str ( i * 2019 ) ) <NEWLINE> <NL> <DEDENT> count = 0 <NEWLINE> for i in s : <NEWLINE> <INDENT> S_ = S <NEWLINE> while re . search ( i , S_ ) : <NEWLINE> <COMMENT> <NL> <INDENT> S_ = S_ [ : re . search ( i , S_ ) . start ( ) ] + <STRING> + S_ [ re . search ( i , S_ ) . start ( ) + 1 : ] <NEWLINE> count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
S = input ( ) <NEWLINE> s = S [ : : - 1 ] <NEWLINE> <NL> cnt = [ 0 ] * 2019 <NEWLINE> s [ 0 ] = 1 <NEWLINE> number = 0 <NEWLINE> d = 1 <NEWLINE> <NL> for i in s : <NEWLINE> <INDENT> number += int ( i ) * d <NEWLINE> cnt [ number % 2019 ] += 1 <NEWLINE> d *= 10 <NEWLINE> d = d % 2019 <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in cnt : <NEWLINE> ans += i * ( i - 1 ) // 2 <NEWLINE> <NL> print ( ans ) <NEWLINE>
S = input ( ) <NEWLINE> <NL> r = 1 <NEWLINE> arr = [ 0 ] <NEWLINE> for c in S [ : : - 1 ] : <NEWLINE> <INDENT> arr . append ( ( arr [ - 1 ] + int ( c ) * r ) % 2019 ) <NEWLINE> r *= 10 <NEWLINE> r %= 2019 <NEWLINE> <DEDENT> from collections import Counter <NEWLINE> ctr = Counter ( arr ) <NEWLINE> ans = 0 <NEWLINE> for v in ctr . values ( ) : <NEWLINE> <INDENT> ans += v * v ( v - 1 ) // 2 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
s = input ( ) <NEWLINE> <NL> <NL> <NL> <STRING> <NEWLINE> <NL> <STRING> <NEWLINE> <NL> <NL> <NL> <COMMENT> <NL> cnt = [ 0 ] * 2019 <NEWLINE> <COMMENT> <NL> cnt [ 0 ] = 1 <NEWLINE> <NL> <COMMENT> <NL> fac = 1 <NEWLINE> <NL> for i in range ( len ( s ) ) : <NEWLINE> <COMMENT> <NL> <INDENT> ss = int ( s [ len ( s ) - i - 1 ] ) * fac <NEWLINE> ss %= 2019 <NEWLINE> fac = fac * 10 <NEWLINE> fac %= 2019 <NEWLINE> cnt [ ss ] += 1 <NEWLINE> <NL> <DEDENT> result = 0 <NEWLINE> for c in cnt : <NEWLINE> <INDENT> result += cnt * ( cnt - 1 ) // 2 <NEWLINE> <NL> <DEDENT> print ( result ) <NEWLINE> <NL> <NL> <NL>
p = d = 2019 <NEWLINE> z = [ 0 ] * p <NEWLINE> for i , j in enumerate ( input ( ) [ : : - 1 ] ) : <NEWLINE> <INDENT> d = d + int ( j ) * pow ( 10 , i , p ) <NEWLINE> z [ d % p ] += 1 <NEWLINE> <DEDENT> r = z [ 0 ] <NEWLINE> for i in a : <NEWLINE> <INDENT> r += i * ( i - 1 ) // 2 <NEWLINE> <DEDENT> print ( r ) <NEWLINE>
input ( ) <NEWLINE> s = s [ : : - 1 ] <NEWLINE> n = len ( s ) <NEWLINE> <NL> count = [ 0 ] * 2019 <NEWLINE> count [ 0 ] = 1 <NEWLINE> num , d = 0 , 1 <NEWLINE> <NL> for i in s : <NEWLINE> <INDENT> num += int ( i ) * d <NEWLINE> num %= 2019 <NEWLINE> d *= 10 <NEWLINE> d %= 2019 <NEWLINE> count [ num ] += 1 <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in count : <NEWLINE> <INDENT> ans += i * ( i - 1 ) // 2 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> from collections import Counter <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> MOD = 2019 <NEWLINE> S = input ( ) [ : : - 1 ] <NEWLINE> n = 0 <NEWLINE> x = 1 <NEWLINE> c = Counter ( ) <NEWLINE> ans = 0 <NEWLINE> <NL> for s in S : <NEWLINE> <INDENT> c [ n ] += 1 <NEWLINE> n += int ( s ) * x <NEWLINE> n %= MOD <NEWLINE> ans += c [ n ] <NEWLINE> x = x * 10 % MOD <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import re <NEWLINE> import sys <NEWLINE> <NL> s = sys . stdin . buffer . readline ( ) . rstrip ( ) . decode ( ) <NEWLINE> ans = 0 <NEWLINE> <NL> for i in range ( len ( s ) - 3 ) : <NEWLINE> <INDENT> for j in range ( i , len ( s ) ) : <NEWLINE> <INDENT> if int ( s [ i : j + i ] ) % 2019 == 0 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> <NL> import sys <NEWLINE> stdin = sys . stdin <NEWLINE> <NL> from numba import njit <NEWLINE> <NL> def ns ( ) : return stdin . readline ( ) . rstrip ( ) <NEWLINE> def ni ( ) : return int ( ns ( ) ) <NEWLINE> def na ( ) : return list ( map ( int , stdin . readline ( ) . split ( ) ) ) <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> s = ni ( ) <NEWLINE> n = len ( str ( s ) ) <NEWLINE> <NL> @ njit <NEWLINE> def d ( s , n ) : <NEWLINE> <INDENT> m = [ 0 ] * 2019 <NEWLINE> now = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> now = ( s % 10 ** ( i + 1 ) ) % 2019 <NEWLINE> <COMMENT> <NL> m [ now ] += 1 <NEWLINE> <DEDENT> return m <NEWLINE> <DEDENT> m = d ( s , n ) <NEWLINE> <NL> ans = m [ 0 ] <NEWLINE> for mi in m [ 1 : ] : <NEWLINE> <INDENT> ans += ( mi - 1 ) * mi // 2 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
S = input ( ) <NEWLINE> N = len ( S ) <NEWLINE> <NL> counter = [ 0 ] * 2019 <NEWLINE> counter [ 0 ] = 1 <NEWLINE> T = 0 <NEWLINE> R = 1 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> T = ( T + R * int ( S [ n - i - 1 ] ) ) % 2019 <NEWLINE> R = 10 * R % 2019 <NEWLINE> counter [ T ] += 1 <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in range ( 2019 ) : <NEWLINE> <INDENT> m = counter [ i ] <NEWLINE> ans += m * ( m - 1 ) // 2 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> s = input ( ) <NEWLINE> n = len ( s ) <NEWLINE> s = s [ : : - 1 ] <NEWLINE> accum = [ 0 ] * n <NEWLINE> p = 2019 <NEWLINE> d = dict ( ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> accum [ i ] = int ( s [ i ] ) * pow ( 10 , i , p ) % p <NEWLINE> <DEDENT> for i in range ( n - 1 ) : <NEWLINE> <INDENT> accum [ i + 1 ] += accum [ i ] <NEWLINE> accum [ i + 1 ] %= p <NEWLINE> <DEDENT> accum [ - 1 ] %= p <NEWLINE> ans = 0 <NEWLINE> <COMMENT> <NL> for i in range ( n ) : <NEWLINE> <COMMENT> <NL> <INDENT> if accum [ i ] not in d : <NEWLINE> <INDENT> if accum [ i ] == 0 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> d [ accum [ i ] ] = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if accum [ i ] == 0 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> ans += d [ accum [ i ] ] <NEWLINE> d [ accum [ i ] ] += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = input ( ) <NEWLINE> l = len ( n ) <NEWLINE> mod = [ 0 ] * 2019 <NEWLINE> mod [ 0 ] += 1 <NEWLINE> T = 0 <NEWLINE> d = 1 <COMMENT> <NEWLINE> for i , s in enumerate ( Sr ) : <NEWLINE> <INDENT> T += int ( s ) * d <NEWLINE> T %= 2019 <NEWLINE> d = ( d * 10 ) % 2019 <NEWLINE> <NL> <DEDENT> res = 0 <NEWLINE> for m in mod : <NEWLINE> <INDENT> res += m * ( m - 1 ) / 2 <NEWLINE> <DEDENT> print ( int ( res ) ) <NEWLINE>
s = str ( input ( ) ) [ : : - 1 ] <NEWLINE> <NL> tmp_amari = [ 0 ] * 2019 <NEWLINE> <NL> <COMMENT> <NL> num = 0 <NEWLINE> order = 1 <NEWLINE> for i in s : <NEWLINE> <INDENT> num += int ( i ) * order <NEWLINE> num %= 2019 <NEWLINE> <COMMENT> <NL> tmp_amari [ num ] += 1 <NEWLINE> order *= 10 <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> ans = 0 <NEWLINE> ans += tmp_amari [ 0 ] <NEWLINE> <NL> for i in tmp_print : <NEWLINE> <INDENT> ans += ( i * ( i - 1 ) ) // 2 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
import heapq <NEWLINE> import sys <NEWLINE> input = sys . stdin . buffer . readline <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> <NL> N , M , S = map ( int , input ( ) . split ( ) ) <NEWLINE> edge = [ [ ] for _ in range ( N ) ] <NEWLINE> for _ in range ( M ) : <NEWLINE> <INDENT> u , v , a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> u -= 1 <NEWLINE> v -= 1 <NEWLINE> edge [ u ] . append ( ( v , a , b ) ) <NEWLINE> edge [ v ] . append ( ( u , a , b ) ) <NEWLINE> <DEDENT> CD = tuple ( tuple ( map ( int , input ( ) . split ( ) ) ) for _ in range ( N ) ) <NEWLINE> <NL> inf = 10 ** 18 <NEWLINE> U = N * 50 <NEWLINE> S = min ( S , U ) <NEWLINE> dist = [ [ inf ] * ( U + 1 ) for _ in range ( N ) ] <NEWLINE> dist [ 0 ] [ S ] = 0 <NEWLINE> <NL> que = [ ( 0 , - S , 0 ) ] <COMMENT> <NEWLINE> while que : <NEWLINE> <INDENT> time , silver , now = heapq . heappop ( que ) <NEWLINE> silver = - silver <NEWLINE> if dist [ now ] [ silver ] < time : <NEWLINE> <INDENT> continue <NEWLINE> <COMMENT> <NL> <DEDENT> c , d = CD [ now ] <NEWLINE> n = 1 <NEWLINE> while silver + c * n <= U : <NEWLINE> <INDENT> if dist [ now ] [ silver + c * n ] > time + n * d : <NEWLINE> <INDENT> dist [ now ] [ silver + c * n ] = time + n * d <NEWLINE> heapq . heappush ( que , ( time + n * d , - ( silver + c * n ) , now ) ) <NEWLINE> n += 1 <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> for nxt , s , t in edge [ now ] : <NEWLINE> <INDENT> if silver < s : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if dist [ nxt ] [ silver - s ] > time + t : <NEWLINE> <INDENT> dist [ nxt ] [ silver - s ] = time + t <NEWLINE> heapq . heappush ( que , ( time + t , - ( silver - s ) , nxt ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for i in range ( 1 , N ) : <NEWLINE> <INDENT> print ( min ( dist [ i ] ) ) <NEWLINE> <DEDENT>
from heapq import * <NEWLINE> <NL> T = [ [ 10 ** 18 for _ in range ( 2451 ) ] for _ in range ( N ) ] <NEWLINE> <NL> act = [ [ ] for _ in range ( N ) ] <NEWLINE> <NL> N , M , S = tuple ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in range ( M ) : <NEWLINE> <INDENT> U , V , A , B = tuple ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> U -= 1 <NEWLINE> V -= 1 <NEWLINE> act [ U ] += [ ( V , A , B ) ] <NEWLINE> act [ V ] += [ ( U , A , B ) ] <NEWLINE> <NL> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> C , D = tuple ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> act [ i ] += [ ( i , - C , D ) ] <NEWLINE> <NL> <DEDENT> que = [ ( 0 , 0 , S ) ] <NEWLINE> <NL> while que : <NEWLINE> <INDENT> ( currentT , n , coins ) = heappop ( que ) <NEWLINE> for m , cost , t in act [ n ] : <NEWLINE> <COMMENT> <NL> <INDENT> if coins >= cost and currentT + t < T [ m ] [ min ( 2450 , coins - cost ) ] : <NEWLINE> <INDENT> T [ m ] [ min ( 2450 , coins - cost ) ] = currentT + t <NEWLINE> heappush ( que , ( currentT + t , m , min ( 2450 , coins - cost ) ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for i in range ( 1 , N ) : <NEWLINE> <INDENT> print ( min ( T [ i ] ) ) <NEWLINE> <DEDENT>
from scipy . sparse import * <NEWLINE> ( n , m , s , * D ) , * t = [ map ( int , t . split ( ) ) for t in open ( 0 ) ] <NEWLINE> R , C = [ ] , [ ] <NEWLINE> x = 51 <NEWLINE> r = range ( x * x ) <NEWLINE> for u , v , a , b in t [ : m ] : <NEWLINE> <INDENT> for i in r : k = ( i + a ) * x ; R += k + u , k + v ; C += i * x + v , i * x + u ; D += b , b <NEWLINE> <DEDENT> i = 0 <NEWLINE> for c , d in t [ m : ] : <NEWLINE> <INDENT> i += 1 <NEWLINE> for j in r : R += j * x + i , ; C += ( j + c ) * x + i , ; D += d , <NEWLINE> <DEDENT> d = csgraph . dijkstra ( csr_matrix ( ( D , ( R , C ) ) , [ x * j ] * 2 ) , 1 , min ( j , s ) * x + 1 ) <NEWLINE> for i in range ( 2 , n + 1 ) : print ( int ( min ( d [ i : : x ] ) ) ) <NEWLINE>
<NL> from heapq import heappush , heappop <NEWLINE> def resolve ( ) : <NEWLINE> <INDENT> INF = float ( <STRING> ) <NEWLINE> maxMoney = 2502 <NEWLINE> <NL> def Dijkstra ( g ) : <NEWLINE> <INDENT> ans = { } <NEWLINE> <COMMENT> <NL> dp = [ [ INF ] * ( maxMoney + 1 ) for _ in range ( N ) ] <NEWLINE> <COMMENT> <NL> hq = [ ] <NEWLINE> heappush ( hq , ( 0 , 0 , min ( S , maxMoney ) ) ) <NEWLINE> while hq : <NEWLINE> <INDENT> t , v , s = heappop ( hq ) <NEWLINE> if t > dp [ v ] [ s ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if v not in ans : <NEWLINE> <INDENT> ans [ v ] = t <NEWLINE> if len ( ans ) == N : <NEWLINE> <INDENT> break <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> if s < maxMoney : <NEWLINE> <INDENT> c , d = CD [ v ] <NEWLINE> new_s = min ( s + c , maxMoney ) <NEWLINE> new_t = t + d <NEWLINE> if new_t < dp [ v ] [ new_s ] : <NEWLINE> <INDENT> dp [ v ] [ new_s ] = new_t <NEWLINE> heappush ( hq , ( new_t , v , new_s ) ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> for nv , cost , time in G [ v ] : <NEWLINE> <COMMENT> <NL> <INDENT> if s < cost : <NEWLINE> <INDENT> continue <NEWLINE> <COMMENT> <NL> <DEDENT> new_s = s - cost <NEWLINE> new_t = t + time <NEWLINE> if new_t < dp [ nv ] [ new_s ] : <NEWLINE> <INDENT> dp [ nv ] [ new_s ] = new_t <NEWLINE> heappush ( hq , ( new_t , nv , new_s ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return ans <NEWLINE> <NL> <DEDENT> N , M , S = map ( int , input ( ) . split ( ) ) <NEWLINE> G = [ [ ] for _ in range ( N ) ] <NEWLINE> for _ in range ( M ) : <NEWLINE> <INDENT> u , v , coin , tm = map ( int , input ( ) . split ( ) ) <NEWLINE> u , v = u - 1 , v - 1 <NEWLINE> G [ u ] . append ( ( v , coin , tm ) ) <NEWLINE> G [ v ] . append ( ( u , coin , tm ) ) <NEWLINE> <DEDENT> CD = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( N ) ] <NEWLINE> <NL> ans = Dijkstra ( G ) <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> print ( ans [ i ] ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> resolve ( <NEWLINE> <DEDENT>
import sys <NEWLINE> read = sys . stdin . buffer . read <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> readlines = sys . stdin . buffer . readlines <NEWLINE> <NL> from heapq import heappush , heappop <NEWLINE> <NL> N , M , S = map ( int , readline ( ) . split ( ) ) <NEWLINE> ABC = [ list ( map ( int , readline ( ) . split ( ) ) ) for _ in range ( M ) ] <NEWLINE> m = map ( int , read ( ) . split ( ) ) <NEWLINE> CD = list ( zip ( m , m ) ) <NEWLINE> <NL> graph = [ [ ] for _ in range ( N ) ] <NEWLINE> for u , v , a , b in ABC : <NEWLINE> <INDENT> graph [ u - 1 ] . append ( ( v - 1 , a , b ) ) <NEWLINE> graph [ v - 1 ] . append ( ( u - 1 , a , b ) ) <NEWLINE> <NL> <DEDENT> def f ( ) : <NEWLINE> <INDENT> INF = 10 ** 18 <NEWLINE> arrive = [ False ] * n <NEWLINE> ans = [ ] <NEWLINE> qq = 2500 <NEWLINE> dist = [ [ INF ] * qq for _ in range ( N ) ] <NEWLINE> dist [ 0 ] [ min ( qq - 1 , S ) ] = 0 <NEWLINE> q = [ ( 0 , min ( qq - 1 , S ) , 0 ) ] <NEWLINE> while q : <NEWLINE> <INDENT> st , ss , v = heappop ( q ) <COMMENT> <NEWLINE> if dist [ v ] [ ss ] < st : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if not arrive [ v ] : <NEWLINE> <INDENT> arrive [ v ] = True <NEWLINE> ans . append ( ( v , st ) ) <NEWLINE> if all ( arrive ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> c , d = CD [ v ] <NEWLINE> <COMMENT> <NL> if ss < qq - 1 : <NEWLINE> <INDENT> ns = min ( ss + c , qq - 1 ) <NEWLINE> nt = st + d <NEWLINE> if dist [ v ] [ ns ] > nt : <NEWLINE> <INDENT> dist [ v ] [ ns ] = nt <NEWLINE> heappush ( q , ( nt , ns , v ) ) <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> for nex , g , tt in graph [ v ] : <NEWLINE> <INDENT> if ss - g < 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> dt = st + tt <NEWLINE> if dist [ nex ] [ ss - g ] <= dt : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> dist [ nex ] [ ss - g ] = dt <NEWLINE> heappush ( q , ( dt , ss - g , nex ) ) <NEWLINE> <DEDENT> <DEDENT> return ans <NEWLINE> <NL> <DEDENT> ab = f ( ) <NEWLINE> from operator import itemgetter <NEWLINE> ab = sorted ( ab , key = itemgetter ( 0 ) ) <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> print ( ab [ i ] [ 1 ] ) <NEWLINE> <DEDENT>
from scipy . sparse import * <NEWLINE> ( n , m , s , * D ) , * t = [ map ( int , t . split ( ) ) for t in open ( 0 ) ] <NEWLINE> R , C = [ ] , [ ] <NEWLINE> r = range ( 2501 ) <NEWLINE> for u , v , a , b in t [ : m ] : <NEWLINE> <INDENT> for i in r : k = ( i + a ) * 51 ; R += k + u , k + v ; C += i * 51 + v , i * 51 + u ; D += b , b <NEWLINE> <DEDENT> i = 0 <NEWLINE> for c , d t [ m : ] : <NEWLINE> <INDENT> i += 1 <NEWLINE> for j in r : R += j * 51 + i , ; C += ( j + c ) * 51 + i , ; D += d , <NEWLINE> <DEDENT> d = csgraph . dijkstra ( csr_matrix ( ( D , ( R , C ) ) ) , 1 , min ( 2500 , s ) * 51 + 1 ) <NEWLINE> for i in range ( 2 , n + 1 ) : print ( int ( min ( d [ i : : 51 ] ) ) ) <NEWLINE>
print ( int ( input ( ) ) * math . pi * 2 ) <NEWLINE>
import math <NEWLINE> R = int ( input ( ) ) <NEWLINE> <NL> pi = math . pi <NEWLINE> <NL> print ( 2 * R * pis ) <NEWLINE>
r = int ( input ( ) ) <NEWLINE> <NL> print ( math . pi * 2 * r ) <NEWLINE>
R = int ( input ( ) . split ( ) ) <NEWLINE> print ( 2 * R * 3.14 ) <NEWLINE>
import math <NEWLINE> <NL> r = imt ( input ( ) ) <NEWLINE> pi = math . pi <NEWLINE> ans = 2 * pi * r <NEWLINE> <NL> print ( ans ) <NEWLINE>
import math <NEWLINE> <NL> R = int ( input ( ) ) <NEWLINE> <NL> print ( R * 2 * math . PI ) <NEWLINE>
S = input ( ) <NEWLINE> print ( S * 2 * 3.14 ) <NEWLINE>
mport math <NEWLINE> <NL> b = int ( input ( ) ) <NEWLINE> <NL> print ( math . pi * b * 2 ) <NEWLINE>
import math <NEWLINE> print ( int ( input ( ) ) + 2 * pi ) <NEWLINE>
from math import PI <NEWLINE> r = int ( input ( ) ) <NEWLINE> print ( 2 * PI * r ) <NEWLINE>
import math <NEWLINE> n = input ( ) <NEWLINE> def d ( n ) : <NEWLINE> <INDENT> return math . pi * 2 * n <NEWLINE> <NL> <DEDENT> print ( d ( n ) ) <NEWLINE>
R = input ( ) <NEWLINE> print ( R * 3.141592 ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ b for b in int ( input ( ) ) ] <NEWLINE> def func ( n , a ) : <NEWLINE> <INDENT> if n < sum ( a ) : return - 1 <NEWLINE> else : <NEWLINE> <INDENT> return n - sum ( a ) <NEWLINE> <DEDENT> <DEDENT>
r = int ( input ( ) ) <NEWLINE> print ( 2 *  * r ) <NEWLINE>
R = int ( input ( ) ) <NEWLINE> <NL> print ( 3.14 * math . tau ) <NEWLINE>
import math <NEWLINE> radius = int ( input ( ) ) <NEWLINE> <NL> print ( 2 * math . pi * radius <NEWLINE>
a , b = input ( ) . split ( ) <NEWLINE> lis = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> print ( int ( a ) - sum ( lis ) if int ( a ) > sum ( lis ) else <STRING> ) <NEWLINE>
n = input ( ) <NEWLINE> pi = 3.142592 <NEWLINE> R = 2 * pi * n <NEWLINE> print ( R ) <NEWLINE>
R = int ( input ( ) ) <NEWLINE> <NL> import math <NEWLINE> <NL> print ( 2 * R * math . py ) <NEWLINE>
import numpy as np <NEWLINE> R = input ( ) <NEWLINE> print ( 2 * R * np . pi ) <NEWLINE>
print ( input ( ) * 2 * 3.14 ) <NEWLINE>
import math <NEWLINE> ans = 2 * math . pi * R <NEWLINE> print ( ans ) <NEWLINE>
import math <NEWLINE> N = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> print ( 2 * math . pi * r ) <NEWLINE>
import math <NEWLINE> <NL> def round ( R ) : <NEWLINE> <INDENT> return 2 * R * pi <NEWLINE> <NL> <DEDENT> R = int ( input ( ) ) <NEWLINE> round ( R ) <NEWLINE>
import math <NEWLINE> <NL> return int ( input ( ) ) * 2 * math . pi <NEWLINE>
print ( int ( input ) * 22 / 7 ) <NEWLINE>
import math <NEWLINE> r = int ( input ( ) ) <NEWLINE> ans = 2 * r * pimath . pi <NEWLINE> print ( ans ) <NEWLINE>
a = int ( input ( ) ) <NEWLINE> x = r * 3.14 <NEWLINE> print ( x ) <NEWLINE>
import math <NEWLINE> print ( int ( input ( ) * 2 * math . pi ) <NEWLINE>
import math <NEWLINE> X = 2 * R * math . pi <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> goukei = sum ( A ) <NEWLINE> <NL> if goukei > N : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> print ( N - goukei ) <NEWLINE> <DEDENT>
round = 3.1415 <NEWLINE> <NL> r = input ( ) <NEWLINE> print ( r * 2 * round ) <NEWLINE>
<INDENT> return int ( input ( ) ) <NEWLINE> <DEDENT> def listintinput ( ) : <NEWLINE> <INDENT> return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <DEDENT> def splitintinput ( ) : <NEWLINE> <INDENT> return map ( int , input ( ) . split ( ) ) <NEWLINE> <DEDENT> def factorialsurplus ( x , y , z ) : <COMMENT> <NEWLINE> <INDENT> ret = 1 <NEWLINE> for i in range ( x , y + 1 ) : <NEWLINE> <INDENT> ret = ( ret * i ) % z <NEWLINE> <DEDENT> return ( ret ) <NEWLINE> <DEDENT> def isprime ( x ) : <NEWLINE> <INDENT> if x == 1 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> if x == 2 : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> sq = int ( math . sqrt ( x ) ) <NEWLINE> for i in range ( 2 , sq + 1 ) : <NEWLINE> <INDENT> if x % i == 0 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> <DEDENT> return True <NEWLINE> <DEDENT> def hcfnaive ( a , b ) : <COMMENT> <NEWLINE> <INDENT> if ( b == 0 ) : <NEWLINE> <INDENT> return a <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return hcfnaive ( b , a % b ) <NEWLINE> <NL> <DEDENT> <DEDENT> R = intinput ( ) <NEWLINE> print ( 2 * R * 3.1415 ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> import math <NEWLINE> print ( 2 * math . pi ( ) * n ) <NEWLINE>
r = int ( input ( ) <NEWLINE> <NL> print ( 2 * r * 3.141592 ) <NEWLINE>
import math <NEWLINE> print ( ( int ( input ( ) ) * 2 * math . pi ( ) ) <NEWLINE>
import math <NEWLINE> <NL> R = input ( ) <NEWLINE> Z = R * 2 * math . pi <NEWLINE> print ( Z ) <NEWLINE>
import math <NEWLINE> r = input ( ) <NEWLINE> print ( 2 * r * math . pi ) <NEWLINE>
import math <NEWLINE> A = int ( input ( ) ) <NEWLINE> a = a * 2 * math . pi <NEWLINE> print ( a ) <NEWLINE>
r = input ( ) <NEWLINE> print ( 2 * 3.14 * r ) <NEWLINE>
r = input ( ) <NEWLINE> print ( 2 * r * 3.1415 ) <NEWLINE>
r = int ( input ( ) ) <NEWLINE> return 2 * 3.14 * r <NEWLINE>
R = input ( int ( ) ) <NEWLINE> R = R * 2 * ( 22 / 7 ) <NEWLINE> print ( R , end = <STRING> ) <NEWLINE>
r = int ( input ( ) ) <NEWLINE> print ( 2 * r * math . pi ) <NEWLINE>
r = int ( input ( ) ) <NEWLINE> e = r * math . pi * 2 <NEWLINE> print ( e ) <NEWLINE>
import math <NEWLINE> R = int ( input ( ) ) <NEWLINE> L = R * math . pie <NEWLINE> print ( L ) <NEWLINE>
import math <NEWLINE> r = int ( input ) ) <NEWLINE> print ( math . pi * 2 * r ) <NEWLINE>
a = int ( input ( ) ) <NEWLINE> print ( 3.14  * a * a ) <NEWLINE>
print ( 6.283 * input ( ) ) <NEWLINE>
import math <NEWLINE> <NL> a = int ( input ( ) . split ( ) ) <NEWLINE> print ( 2 * math . pi * a ) <NEWLINE>
from sys import stdin <NEWLINE> a = stdin . readline ( ) . rstrip ( ) <NEWLINE> <COMMENT> <NL> pi = 3.14159265 <NEWLINE> r = 2 * pi * a <NEWLINE> print ( r ) <NEWLINE>
import math <NEWLINE> a = int ( input ( ) <NEWLINE> print ( 2 * a * math . pi ) <NEWLINE>
def a ( R ) <NEWLINE> <INDENT> b = 6.28 * { } . format ( R ) <NEWLINE> return b <NEWLINE> <NL> <DEDENT> print ( b ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> a = list ( map ( int , ( input ( ) . split ( ) ) ) ) <NEWLINE> list_a = [ 0 ] * 2 * 100001 <NEWLINE> for i in a : <NEWLINE> <INDENT> list_a [ i ] += 1 <NEWLINE> <DEDENT> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> print ( list_a [ i ] ) <NEWLINE> <DEDENT>
a = int ( input ( ) ) <NEWLINE> print ( 2 * a * pi ) <NEWLINE>
print ( 2 * int ( input ( ) * 3.141592653589 ) ) <NEWLINE>
import numpy as np <NEWLINE> r = int ( input ( ) ) <NEWLINE> <NL> return 2 * r * np . pi <NEWLINE>
print ( R * 2 * 3.14 ) <NEWLINE>
import math <NEWLINE> r = int ( input ( ) ) <NEWLINE> print ( 2 * math . pi r ) <NEWLINE>
import math <NEWLINE> print ( int ( input ) * 2 * math . pi ) <NEWLINE>
R = input ( ) <NEWLINE> i = R * 3.141592 * 2 <NEWLINE> print ( i ) <NEWLINE>
import numpy as np <NEWLINE> <NL> def calculate_length ( int radius ) : <NEWLINE> <INDENT> return 2.0 * radius * np . pi <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> radius = int ( input ( ) ) <NEWLINE> print ( calculate_rength ( radius ) ) <NEWLINE> <DEDENT>
import math <NEWLINE> r = input ( ) <NEWLINE> print ( 2 * math . pi * r ) <NEWLINE>
r = int ( input ( ) ) <NEWLINE> prinrt ( 2 * r * 3.141592 ) <NEWLINE>
pi = 3.141592653589793238462643383279 <NEWLINE> <NL> a = input ( ) <NEWLINE> ans = a * 2 * pi <NEWLINE> print ( ans ) <NEWLINE>
import math <NEWLINE> r = int ( input ( ) ) <NEWLINE> print ( 2 * math . PI * r ) <NEWLINE>
import math <NEWLINE> r = int ( imput ( ) ) <NEWLINE> print ( 2 * math . pi * r ) <NEWLINE>
import math <NEWLINE> R = int ( intput ( ) ) <NEWLINE> <NL> print ( 2 * math . pi * R ) <NEWLINE>
import math <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> r = int ( input ( ) ) <NEWLINE> print ( <STRING> . format ( 2 * r * math . pi ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import math <NEWLINE> <NL> r = input ( ) <NEWLINE> l = 2 * math . pi * r <NEWLINE> print ( l ) <NEWLINE>
import math <NEWLINE> <NL> r = int ( import ( ) ) <NEWLINE> <NL> print ( r * math . pi * 2 ) <NEWLINE>
nm = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> n , m = nm [ 0 ] , nm [ 1 ] <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> sam = sum ( a ) <NEWLINE> ans = n - sam <NEWLINE> if ans >= 0 : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT>
radius = int ( input ( ) ) <NEWLINE> answer = 2 * math . pi * radius <NEWLINE> print ( answer ) <NEWLINE>
<COMMENT> <NL> import math <NEWLINE> <NL> <NL> def solve ( * args : str ) -> str : <NEWLINE> <INDENT> r = int ( args [ 0 ] ) <NEWLINE> <NL> return str ( 2 * math . pi ( ) * r ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> print ( solve ( * ( open ( 0 ) . read ( ) . splitlines ( ) ) ) ) <NEWLINE> <DEDENT>
r = int ( imput ( ) ) <NEWLINE> print ( 6.28 * r ) <NEWLINE>
import math <NEWLINE> n = int ( input ( ) ) <NEWLINE> print ( 2 * n * pi ) <NEWLINE>
import math <NEWLINE> <NL> R = int ( input ( ) ) <NEWLINE> <NL> print float ( R * 2 * math . pi ( ) ) <NEWLINE>
s = int ( input ( ) ) <NEWLINE> print ( int ( s * 3.14 ) <NEWLINE>
import math <NEWLINE> <NL> if __name__ == <STRING> : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> print ( N * N ( math . pi ) <NEWLINE> <DEDENT>
import math <NEWLINE> a = int ( input ( ) ) <NEWLINE> print ( 2. math . pi * a ) <NEWLINE>
import numpy as np <NEWLINE> R = int ( input ( ) ) <NEWLINE> circle = float ( R * 2 * np . pi ) ) <NEWLINE> print ( circle ) <NEWLINE>
<INDENT> print ( int ( input ( ) ) * 6.3 ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> import math <NEWLINE> math . pi <NEWLINE> <NL> R = int ( intput ( ) ) <NEWLINE> print ( math . pi * 2 * R ) <NEWLINE>
num = int ( input ( ) ) <NEWLINE> print ( num * 2 * 3. 1415926535 ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> play = n - sum ( a ) <NEWLINE> if play < 0 : play = - 1 <NEWLINE> <NL> <NL> print ( play ) <NEWLINE>
import math <NEWLINE> <NL> R = ( input ( ) ) <NEWLINE> print ( 2 * math . pi * R ) <NEWLINE>
import math <NEWLINE> print ( math . pi ( ) * int ( input ( ) ) ) <NEWLINE>
def resolve ( ) : <NEWLINE> <INDENT> R = int ( input ( ) ) <NEWLINE> <NL> print ( R * 2 * math . pi ) <NEWLINE> <NL> <NL> <DEDENT> resolve ( ) <NEWLINE>
r = input ( ) <NEWLINE> print ( 2 * int ( r ) * math . pi ) <NEWLINE>
import math <NEWLINE> print ( 2 * math . pi * int ( input ) ) <NEWLINE>
import math <NEWLINE> <NL> r = int ( input ) <NEWLINE> <NL> k = math . pi <NEWLINE> <NL> l = 2 * k * r <NEWLINE> <NL> print ( l ) <NEWLINE>
import math <NEWLINE> <NL> R = int ( input ( ) ) <NEWLINE> <NL> print ( 2 * math . pai * R ) <NEWLINE>
from math import pi <NEWLINE> def cicle ( hankei ) : <NEWLINE> <INDENT> return 2 * hankei * pi <NEWLINE> <NL> <DEDENT> circle ( 1 ) <NEWLINE> circle ( 73 ) <NEWLINE>
import math <NEWLINE> print ( int ( input ( ) ) * 2 * math . PI ) <NEWLINE>
import . math <NEWLINE> a = int ( input ( ) ) <NEWLINE> print ( 2 * math . pi * a ) <NEWLINE>
import math <NEWLINE> <NL> R = str ( input ( ) ) <NEWLINE> <NL> circum = R * 2 * math . pi <NEWLINE> <NL> print ( circum ) <NEWLINE>
r = int ( input ( ) ) <NEWLINE> print ( 2 * pi * r ) <NEWLINE>
a = input ( ) <NEWLINE> print 3.14 * 2 * a <NEWLINE>
a = float ( input ( ) ) <NEWLINE> b = 2 * 3.14 . a <NEWLINE> print ( b ) <NEWLINE>
r = int ( input ( ) ) <NEWLINE> inport math <NEWLINE> print ( r * 2 * math . pi ) <NEWLINE>
R = map ( int , input ( ) ) <NEWLINE> print ( 2 * R * 3.14 ) <NEWLINE>
r = int ( input ( ) ) <NEWLINE> <NL> ans = 2 * math . pi * r <NEWLINE> print ( ans ) <NEWLINE>
import math <NEWLINE> <NL> print ( 2 * math . pi * input ( ) ) <NEWLINE>
print ( int ( input ) * 2 * 3.1415 ) <NEWLINE>
r = int ( input ( ) ) <NEWLINE> import math <NEWLINE> print ( 2 * r * math . PI ) <NEWLINE>
import math <NEWLINE> print ( ~ - float ( input ( ) ) * 2 * math . pi ) <NEWLINE>
R = int ( input ( ) ) <NEWLINE> print ( 2 *  * R ) <NEWLINE>
import math <NEWLINE> n = int ( input ( ) ) <NEWLINE> print ( n * 2 * math . p ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> num = [ 0 ] * N <NEWLINE> for i in A : <NEWLINE> <INDENT> num [ i - 1 ] += 1 <NEWLINE> <NL> <DEDENT> for j in range ( len ( num ) ) : <NEWLINE> <INDENT> print ( num [ j ] ) <NEWLINE> <DEDENT>
r = int ( input ( ) ) <NEWLINE> import math <NEWLINE> print ( math . pi ( ) * r ** 2 ) <NEWLINE>
import math <NEWLINE> R = int ( input ) <NEWLINE> ans = math . pi * 2 * R <NEWLINE> print ( ans ) <NEWLINE>
import math <NEWLINE> R = int ( input ( ) ) <NEWLINE> circumference = 2 * math . pi * R <NEWLINE> print ( <STRING> % circumference ( ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> print ( str ( 2 * math . pi * n ) ) <NEWLINE>
import math <NEWLINE> float R <NEWLINE> R = float ( input ( ) ) <NEWLINE> print ( 2 * R * math . pi ) <NEWLINE>
import math <NEWLINE> r = int ( input ( ) ) <NEWLINE> print ( pi * 2 * r ) <NEWLINE>
import sys <NEWLINE> import math <NEWLINE> from collections import deque <NEWLINE> input = lambda : sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> Yes = lambda boolean : print ( <STRING> ) if boolean else print ( <STRING> ) <NEWLINE> YES = lambda boolean : print ( <STRING> ) if boolean else print ( <STRING> ) <NEWLINE> aint = lambda : int ( input ( ) ) <NEWLINE> ints = lambda : list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> is_even = lambda x : True if x % 2 == 0 else False <NEWLINE> zeros2d = lambda r , c : [ [ 0 for col in range ( c ) ] for row in range ( r ) ] <NEWLINE> <NL> R = aint ( ) <NEWLINE> print ( 2 * R * math . pi ( ) ) <NEWLINE>
R = int , input ( ) <NEWLINE> print ( float ( R * 3.14 * 2 ) ) <NEWLINE>
r = int ( input ( ) ) <NEWLINE> print ( 2 * pi * r ) <NEWLINE>
import math <NEWLINE> n = int ( input ( ) ) <NEWLINE> print ( n * math . pi ( ) ) <NEWLINE>
N , M = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if N < sum ( A ) : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( N - sum ( A ) ) <NEWLINE> <DEDENT>
<NL> import math <NEWLINE> a = int ( input ( ) ) <NEWLINE> print ( 2 * math . py : a ) <NEWLINE> <NL> <NL> <NL> <NL>
N = input ( ) <NEWLINE> <NL> print ( 2 * N * 3.1416 ) <NEWLINE>
R = input ( ) <NEWLINE> print ( R * 6.28 ) <NEWLINE>
import math <NEWLINE> print ( int ( input ( ) ) * 2 * math . py ) <NEWLINE>
r = int ( input ( ) ) <NEWLINE> a = 2 * pi * r <NEWLINE> print ( a ) <NEWLINE>
R = int . input ( ) <NEWLINE> print ( 2 * 3.14159 * R ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> x = N * 2.1415926535897 <NEWLINE> print x <NEWLINE>
import math <NEWLINE> R = float ( import ( ) ) <NEWLINE> L = 2 * math . pi * R <NEWLINE>
<INDENT> n = int ( input ( ) ) <NEWLINE> print ( n * 3.1415923535897932 ) <NEWLINE> <DEDENT>
import fractions <NEWLINE> pi = fractions . pi <NEWLINE> R = int ( input ( ) ) <NEWLINE> print ( 2 * pi * R ) <NEWLINE>
import math <NEWLINE> a = input ( ) <NEWLINE> print ( froat ( a ) * 2 * math . py ) <NEWLINE>
import math <NEWLINE> r = int ( input ( ) ) <NEWLINE> print ( r * 2 * math . pai ) <NEWLINE>
r = ( int input ( ) ) <NEWLINE> print ( 6.3 * r ) <NEWLINE>
r = int ( input ( ) ) <NEWLINE> print ( 2 * r * 3. 141592653 ) <NEWLINE>
import . math <NEWLINE> x = int ( input ( ) ) <NEWLINE> y = 2 * math . pi * x <NEWLINE> print ( y ) <NEWLINE>
import math <NEWLINE> pi = math . pi <NEWLINE> r = int ( input ( ) ) <NEWLINE> len = 2 * pi * r <NEWLINE> return len <NEWLINE>
a = int ( input ( ) ) <NEWLINE> b = a * pi ( ) <NEWLINE> print ( b ) <NEWLINE>
R = input ( ) <NEWLINE> print ( 2 * 3.14 * R ) <NEWLINE>
R = float ( input ( ) ) <NEWLINE> <NL> print ( 2 * R * math . pi ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> bs = [ 0 for _ in range ( n ) ] <NEWLINE> for x in a : <NEWLINE> <INDENT> bs [ x - 1 ] += 1 <NEWLINE> <NL> <NL> <DEDENT> for x in bs : <NEWLINE> <INDENT> print ( x ) <NEWLINE> <NL> <DEDENT>
import math <NEWLINE> if __name__ = <STRING> : <NEWLINE> <INDENT> R = eval ( input ( ) ) <NEWLINE> <INDENT> print ( math . pi * R ** 2 ) <NEWLINE> <DEDENT> <DEDENT>
import math <NEWLINE> print ( int ( input ( ) * 2 * math . pi ) <NEWLINE>
if __name__ == <STRING> : <NEWLINE> <INDENT> import math <NEWLINE> t = int ( raw_input ( ) ) <NEWLINE> print ( t * math . pi ) <NEWLINE> <DEDENT>
import sys <NEWLINE> import socket <NEWLINE> form math import pi <NEWLINE> <NL> hostnames = [ <STRING> , <STRING> , <STRING> ] <NEWLINE> input_file = <STRING> <NEWLINE> if socket . gethostname ( ) in hostnames : <NEWLINE> <INDENT> sys . stdin = open ( input_file ) <NEWLINE> <NL> <NL> <DEDENT> def read_int_list ( ) : <NEWLINE> <INDENT> return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> <DEDENT> def read_int ( ) : <NEWLINE> <INDENT> return int ( input ( ) ) <NEWLINE> <NL> <NL> <DEDENT> def read_str_list ( ) : <NEWLINE> <INDENT> return input ( ) . split ( ) <NEWLINE> <NL> <NL> <DEDENT> def read_str ( ) : <NEWLINE> <INDENT> return input ( ) <NEWLINE> <NL> <NL> <DEDENT> def solve ( ) : <NEWLINE> <INDENT> r = read_int ( ) <NEWLINE> return 2 * pi * r <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> res = solve ( ) <NEWLINE> print ( res ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import math <NEWLINE> <NL> r = int ( input ( ) ) <NEWLINE> print ( 2 * math . PI * r ) <NEWLINE>
R = input ( ) <NEWLINE> print ( 2 * R * 3.14159265 ) <NEWLINE>
import math <NEWLINE> <NL> r = int ( input ( ) ) <NEWLINE> <NL> h = R * R * math . pi <NEWLINE> <NL> print ( h ) <NEWLINE>
R = int ( input ) <NEWLINE> print ( R * 6.28 ) <NEWLINE>
import math <NEWLINE> r = input ( ) <NEWLINE> circ = 2 * math . pi * r <NEWLINE> print ( circ ) <NEWLINE>
R = input ( ) <NEWLINE> print ( R * 2 * 3.141 ) <NEWLINE>
<COMMENT> <NL> <INDENT> import math <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> if ( __name__ == <STRING> ) : <NEWLINE> <COMMENT> <NL> <INDENT> r = int ( input ( ) ) <NEWLINE> <NL> pi = 3.141592 <NEWLINE> ans = pi * r * 2.0 <NEWLINE> print ( ans ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <NEWLINE> <DEDENT> <DEDENT>
print ( input ( ) * 2 * 3.14 ) <NEWLINE>
import math <NEWLINE> n = int ( input ( ) ) <NEWLINE> circumference = 2 * pi * n <NEWLINE> print ( circumference ) <NEWLINE>
R = int ( input ( ) ) <NEWLINE> pai = 3.14 <NEWLINE> <INDENT> print ( R * 2 * pai ) <NEWLINE> <DEDENT>
def resolve ( ) : <NEWLINE> <INDENT> r = int ( input ( ) ) <NEWLINE> print ( 2 * r * math . pi ) <NEWLINE> <DEDENT> resolve ( ) <NEWLINE>
import math <NEWLINE> print ( 2 * int ( input ( ) * math . pi ) ) <NEWLINE>
r = input ( ) <NEWLINE> <NL> s = 2.0 * 3.14159265 * r <NEWLINE> <NL> print ( s ) <NEWLINE>
import pi <NEWLINE> <NL> r = int ( input ( ) ) <NEWLINE> <NL> x = 2 * r * pi <NEWLINE> <NL> print ( x ) <NEWLINE>
<COMMENT> <NL> import numpy as np <NEWLINE> <NL> r = int ( input ( ) ) <NEWLINE> <NL> ans = r * 2 * np . pi ( ) <NEWLINE> <NL> print ( ans ) <NEWLINE>
import math <NEWLINE> r = int ( input ) <NEWLINE> print ( math . pi * r * 2 ) <NEWLINE>
import math <NEWLINE> n = float ( input ( ) ) <NEWLINE> n *= 2 <NEWLINE> print ( n * math . pi <NEWLINE>
import numpy as np <NEWLINE> N = int ( input ( ) ) <NEWLINE> my_result = N * np ( pi ) <NEWLINE> print ( my_result ) <NEWLINE>
r = int ( input ( ) ) <NEWLINE> print ( numpy . pi * 2 * r ) <NEWLINE>
def actual ( r ) : <NEWLINE> <INDENT> return 2 * r * math . pi <NEWLINE> <NL> <DEDENT> r = int ( input ( ) ) <NEWLINE> print ( actual ( r ) ) <NEWLINE>
import math <NEWLINE> r = int ( input ( ) ) <NEWLINE> print ( 2 * pi * r ) <NEWLINE>
import math <NEWLINE> print ( math . pi * input ( ) * 2 ) <NEWLINE>
import math <NEWLINE> R = int ( input ) <NEWLINE> <NL> print ( 2 * math . pi * R ) <NEWLINE>
<NL> print ( 2 * math . pi * ( int ( input ( ) ) ) ) <NEWLINE>
r = input ( ) <NEWLINE> r = r * 6.282 <NEWLINE> <NL> print ( r ) <NEWLINE>
enshu = int ( input ( R ) ) <NEWLINE> print ( enshu * 2 * 3.141592 ) <NEWLINE> <NL>
import math <NEWLINE> r = input ( ) <NEWLINE> print ( 2 * math . pi * r ) <NEWLINE> quit ( ) <NEWLINE>
r = int ( input ( ) ) <NEWLINE> p = 22 / 7 <NEWLINE> print ( 2 * pi * r ) <NEWLINE>
print ( int ( input ( ) ) * 6.28 <NEWLINE>
import math . pi as pi <NEWLINE> r = input ( ) <NEWLINE> print ( r * r * pi ) <NEWLINE>
import math <NEWLINE> <NL> R = ( int ) input ( ) <NEWLINE> <NL> print ( 2 * math . pi * R ) <NEWLINE>
import math <NEWLINE> n = int ( input ( ) ) <NEWLINE> print ( 2 * n * math . pi ( ) ) <NEWLINE>
import math <NEWLINE> R = int ( input ( ) ) <NEWLINE> print ( 2 * R * math . pi <NEWLINE>
import math <NEWLINE> pi = math . pi <NEWLINE> a = int ( input ( ) ) <NEWLINE> print ( pi * a <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> L = sum ( A ) <NEWLINE> if L > N : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( N - L ) <NEWLINE> <DEDENT>
import math <NEWLINE> <NL> r = int ( input ( ) ) <NEWLINE> l = 2 * math . py * r <NEWLINE> print ( l ) <NEWLINE>
a = int ( input ( ) ) <NEWLINE> <NL> print ( a *  ) <NEWLINE>
R = int ( input ( ) ) <NEWLINE> print ( R * pi * 2 ) <NEWLINE>
r = input ( ) <NEWLINE> print ( r * 2 * 3.14 ) <NEWLINE>
R = map ( int , input ( ) ) <NEWLINE> <NL> cir = 2 * R * 3.1415 <NEWLINE> <NL> ptint ( cir ) <NEWLINE>
r = int ( input ( <STRING> ) ) <NEWLINE> print ( 2 * r * math . pi ) <NEWLINE>
import math <NEWLINE> <NL> R = int ( input ( ) ) <NEWLINE> return 2 * math . pi * R <NEWLINE>
r = int ( input ( ) ) <NEWLINE> print ( r * pi ) <NEWLINE>
N = input ( ) <NEWLINE> <NL> if N [ 0 ] != <STRING> and N [ 1 ] != <STRING> and N [ 2 ] != <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import math <NEWLINE> n = int ( input ( ) ) <NEWLINE> def func ( n ) <NEWLINE> <INDENT> return math . pi * n * 2 <NEWLINE> <DEDENT> print ( func ( n ) ) <NEWLINE>
num = int ( input ( ) ) <NEWLINE> print ( math . pi * 2 * num ) <NEWLINE>
r = int ( input ( ) ) <NEWLINE> print ( 2 r * 3.14 ) <NEWLINE>
n , m = list ( map ( int , input ( ) . rstrip ( ) . split ( ) ) ) <NEWLINE> total = sum ( [ int ( i ) for i in input ( ) . rstrip ( ) . split ( ) ] ) <NEWLINE> result = - 1 if n < total else n - total <NEWLINE> print ( result ) <NEWLINE>
a = input ( ) <NEWLINE> print ( 6.28318530717958623200 * a ) <NEWLINE>
s = input ( ) <NEWLINE> <NL> l = 2 s * 3.14 <NEWLINE> <NL> print ( l ) <NEWLINE>
R = int ( input ( ) ) <NEWLINE> print ( 2 * math . pi * R ) <NEWLINE>
r = input ( ) <NEWLINE> R = 2 * 3.1415 * r <NEWLINE> print ( R ) <NEWLINE>
r = int ( input ( ) ) <NEWLINE> ans = 2 r * 3.14 <NEWLINE> print ( ans ) <NEWLINE>
a = input ( ) <NEWLINE> print ( a * 2 * 3.1415 ) <NEWLINE>
R = int . input ( ) <NEWLINE> print ( R * 2 * 3.14 ) <NEWLINE>
n = input <NEWLINE> R = 2 * 3.1415926535 * n <NEWLINE> print ( R ) <NEWLINE>
R = int , input ( ) <NEWLINE> import math <NEWLINE> def circleround ( s ) : <NEWLINE> <INDENT> s = R * math . pi * 2 <NEWLINE> <DEDENT> s = R * math . pi * 2 <NEWLINE> print ( s ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = n * 2 * math . pi <NEWLINE> print ( a ) <NEWLINE>
import math <NEWLINE> 2 * math . pi * R <NEWLINE>
r = int ( input ) <NEWLINE> print ( 2 * r * 3.1415 ) <NEWLINE>
import math <NEWLINE> a = int ( input ( ) ) <NEWLINE> print ( str ( 2 a * math . pi ) ) <NEWLINE>
import math <NEWLINE> print ( int ( input ( ) * math . pi * 2 ) ) <NEWLINE>
import math <NEWLINE> N = input ( ) <NEWLINE> print ( N * math . pi ) <NEWLINE>
import math <NEWLINE> R = float ( imput ( ) ) <NEWLINE> <NL> ans = 2 * R * PI <NEWLINE> <NL> print ( ans ) <NEWLINE>
import math <NEWLINE> <NL> R = int ( input ( ) ) <NEWLINE> print ( 2 * math . pie * R ) <NEWLINE>
import math <NEWLINE> <NL> a = int ( input ) <NEWLINE> <NL> print ( 2 * a * math . pi ) <NEWLINE>
r = int ( input ( ) <NEWLINE> print ( 2 * r * 3.141592 ) <NEWLINE>
r = int ( input ( ) ) <NEWLINE> print ( 2 * r * pi ) <NEWLINE>
<INDENT> r = int ( input ( ) ) <NEWLINE> <DEDENT> print ( R * 2 * 3.14159265359 ) <NEWLINE>
i = int ( input ( ) ) <NEWLINE> l = 2 * i * math . pi <NEWLINE> print ( l ) <NEWLINE>
a = int ( input ( ) ) <NEWLINE> printf ( a * 2 * 3.1415926535 ) <NEWLINE>
R = input ( ) <NEWLINE> print ( R * 3.1415 ) <NEWLINE>
R = input ( ) <NEWLINE> print ( R * 3.1415926 ) <NEWLINE>
r = int ( input ( ) ) <NEWLINE> def cir ( r ) : <NEWLINE> <INDENT> return math . pi * r ** 2 <NEWLINE> <DEDENT> print ( cir ( r ) ) <NEWLINE>
a = int ( input ( ) ) <NEWLINE> <INDENT> import math <NEWLINE> print ( 2 * a * math . pi ) <NEWLINE> <NL> <DEDENT>
r = int ( input ( ) ) <NEWLINE> print ( math . pi * 2 * r ) <NEWLINE>
import math <NEWLINE> <NL> R = int ( input ( ) ) <NEWLINE> a = 2 * R * pi . math <NEWLINE> <NL> print ( a ) <NEWLINE>
import math <NEWLINE> N = int ( inpit ( ) ) <NEWLINE> print math . pi * N <NEWLINE>
r = int ( input ( ) ) <NEWLINE> print ( 2 * math . pi * r ) <NEWLINE>
r = input ( ) <NEWLINE> print ( 3.141 * 2 * r ) <NEWLINE>
import math <NEWLINE> def solve ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> print ( round ( 2 * math . pi * n , 2 ) ) <NEWLINE> <NL> <NL> <DEDENT> for _ in range ( int ( input ( ) ) ) : <NEWLINE> <INDENT> solve ( ) <NEWLINE> <DEDENT>
x = map ( int , input ( ) ) <NEWLINE> print ( 2 * x * 3.14 ) <NEWLINE>
PI = 3.141 <NEWLINE> r = int ( input ( ) ) <NEWLINE> print ( 2 * 1 PI * r ) <NEWLINE>
r = int ( input ( ) ) <NEWLINE> l = math . pi * 2 * r <NEWLINE> print ( l ) <NEWLINE>
import numpy <NEWLINE> print ( input ( ) * 2 * numpy . pi ) <NEWLINE>
R = float ( input ( ) ) <NEWLINE> L = 2 * math . pi * R <NEWLINE> print ( L ) <NEWLINE>
import mathmatics <NEWLINE> r = int ( input ( ) ) <NEWLINE> print ( 2 * r * pi ) <NEWLINE>
import math <NEWLINE> math . pi <NEWLINE> R = int ( input ( ) ) <NEWLINE> print ( R * 2 * pi ) <NEWLINE>
R = int , input ( ) <NEWLINE> r = 2 * 3.14159265358979 * R <NEWLINE> print ( r ) <NEWLINE>
import . math <NEWLINE> R = int ( input ( ) ) <NEWLINE> print ( 2 * R * math . pi ) <NEWLINE>
R = str ( input ( ) ) <NEWLINE> length == 2 * 3.14 * int ( R ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> nissuu = sum ( A ) <NEWLINE> <NL> if nissuu > N : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( N - nissuu ) <NEWLINE> <DEDENT>
r = input ( ) <NEWLINE> print ( r * 2 * 3.14 ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for x in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> print ( p . count ( x ) ) <NEWLINE> <NL> <DEDENT>
r = input ( ) <NEWLINE> print ( r * 2 * 3.141 ) <NEWLINE>
import math <NEWLINE> R = int ( input ( ) ) <NEWLINE> l = 2 * ( math . pi ) * R <NEWLINE> <NL> print ( l ) 1 <NEWLINE>
from math import pi <NEWLINE> radius = int ( input ( ) ) <NEWLINE> circumfernece = 2 * pi * radius <NEWLINE> print ( circumference ) <NEWLINE>
from math import pi <NEWLINE> print ( int ( input ( ) * 2 * pi ) <NEWLINE>
import math <NEWLINE> <NL> a = ( int ) input ( ) <NEWLINE> print ( 2 * math . pi * a ) <NEWLINE>
import . math <NEWLINE> x = int ( input ( ) ) <NEWLINE> y = 2 * math . pi * x <NEWLINE> print ( y ) <NEWLINE>
R = input ( ) <NEWLINE> print ( 2 * 3.14 * R ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> A = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> s = sum ( A ) <NEWLINE> if N - s < 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( N - s ) <NEWLINE> <DEDENT>
a = int ( input ( ) ) <NEWLINE> print ( 2 a * 3.1415926535 ) <NEWLINE>
R = int ( input ( ) ) <NEWLINE> en = 2 * R 3.14 <NEWLINE> print ( en ) <NEWLINE>
<INDENT> print ( int ( input ( R ) ) * 6.3 ) <NEWLINE> <DEDENT>
import math <NEWLINE> print ( r * 2 * math . pi ) <NEWLINE>
import math <NEWLINE> print ( int ( input ( ) * 2 * math . pi ) <NEWLINE>
map = input ( int ( ) ) <NEWLINE> print ( 2 * 3.14 * R ) <NEWLINE>
import math <NEWLINE> <NL> R = input ( ) <NEWLINE> print ( 2 * math . pi * R ) <NEWLINE>
import math <NEWLINE> s = int ( input ( ) ) <NEWLINE> print ( s * 2 * math . pie ) <NEWLINE>
<COMMENT> <NL> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> R = input ( int ( ) ) <NEWLINE> return R * 2 * 3.1415 <NEWLINE> <NL> <NL> <DEDENT> print ( main ( ) ) <NEWLINE>
import math <NEWLINE> R = int ( input ( ) ) <NEWLINE> print ( 2 * math . pi * r ) <NEWLINE>
r = input ( ) <NEWLINE> <NL> print ( <STRING> . format ( 2 * 3.1415 * r ) ) <NEWLINE>
import math <NEWLINE> R = range ( 1 , 100 ) <NEWLINE> def Circle ( R ) : <NEWLINE> <INDENT> return 2 * math . pi * R <NEWLINE> <NL> <DEDENT> Circle ( R ) <NEWLINE>
print ( 6.28 * int ( input ( ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = [ int ( _ ) for _ in input ( ) . split ( ) ] <NEWLINE> b = [ 0 for _ in range ( n ) ] <NEWLINE> for i in a : <NEWLINE> <INDENT> b [ i - 1 ] += 1 <NEWLINE> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> print ( b [ i ] ) <NEWLINE> <DEDENT>
import math <NEWLINE> <NL> S = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> N = S [ 0 ] <NEWLINE> M = S [ 1 ] <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = N - sum ( A ) <NEWLINE> if ans < 0 : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> a = int ( input ) <NEWLINE> print ( math . pi * 2 * a ) <NEWLINE>
import math <NEWLINE> R = input ( ) <NEWLINE> a = 2 * R * math . pi <NEWLINE> print ( round ( a , 3 ) ) <NEWLINE>
r = input ( ) <COMMENT> <NEWLINE> ans = r * 2 * 3.14 <NEWLINE> print ( ans ) <NEWLINE>
R = inpup ( ) <NEWLINE> print ( 6.282 * ( int ( R ) ) ** 2 ) <NEWLINE>
import math <NEWLINE> R = input ( ) <NEWLINE> l = 2 * R * math . pi <NEWLINE> print ( l ) <NEWLINE>
print ( int ( iinput ( ) ) * 3.1415 ) <NEWLINE>
R = ( float . input ( ) ) <NEWLINE> <NL> print ( R ** 2 * 3.141592 ) <NEWLINE>
r = int ( input ( ) ) <NEWLINE> print ( 2 * math . pi * r ) <NEWLINE>
import math <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> R = input ( ) <NEWLINE> if 1 <= R <= 100 : <NEWLINE> <INDENT> answer = float ( R ) * 2 / math . pi <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT> print ( answer ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
r = int ( input ( ) ) <NEWLINE> import math <NEWLINE> print ( math . pi * R * 2 ) <NEWLINE>
print ( float ( input ( ) ) * 2 * 3.14 <NEWLINE>
from math import pi <NEWLINE> <NL> r = input ( ) <NEWLINE> <NL> print ( 2 * r * pi ) <NEWLINE>
print ( 2 * r * 3.14159265359 ) <NEWLINE>
a = int ( input ( ) ) <NEWLINE> print ( a * pi * 2 ) <NEWLINE>
r = int ( input ( ) ) <NEWLINE> <NL> print ( math . pi * r * 2 ) <NEWLINE>
import sys <NEWLINE> sys . stdin = open ( <STRING> , <STRING> ) <NEWLINE> sys . stdout = open ( <STRING> , <STRING> ) <NEWLINE> import math <NEWLINE> a = int ( input ( ) ) <NEWLINE> print ( 2 * math . pi * a ) <NEWLINE> <NL> <NL> <COMMENT> <NL>
r = int ( input ( ) ) <NEWLINE> import numpy <NEWLINE> <NL> print ( math . pi * 2 * r ) <NEWLINE>
R = input ( ) <NEWLINE> print ( 2 * R * 3.14159265 ) <NEWLINE>
print ( float ( 2 * r * 3.14 ) ) <NEWLINE>
import math <NEWLINE> <NL> r = input ( ) <NEWLINE> pi_ = round ( math . pi , 4 ) <NEWLINE> print ( 2 * r * pi_ ) <NEWLINE>
import math <NEWLINE> <NL> print ( int ( input ( ) ) * 2 * math . pi ( ) ) <NEWLINE>
r = input ( ) <COMMENT> <NEWLINE> ans = r * 2 * 3.14 <NEWLINE> print ( ans ) <NEWLINE>
X = 3.14159265 * 2 * R <NEWLINE> print ( X ) <NEWLINE>
import math <NEWLINE> <NL> r = int ( input ( ) ) <NEWLINE> <NL> print ( r * 2 * math . PI ) <NEWLINE>
import math <NEWLINE> n = int ( input ( ) ) <NEWLINE> ptint ( 2 * n * math . pi ) <NEWLINE>
import math <NEWLINE> R = int ( input ( ) ) <NEWLINE> print ( 2 * R * math . Pi ) <NEWLINE>
import math <NEWLINE> r = int ( input ( ) ) <NEWLINE> print ( float ( r * 2 * ( math . pi ) ) ) 73 <NEWLINE>
import math <NEWLINE> N , M = input ( ) . split ( ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> N = int ( N ) <NEWLINE> if N >= sum ( A ) : <NEWLINE> <INDENT> print ( N - sum ( A ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> r = input ( ) <NEWLINE> <NL> s = 2 * r * 3.1415926 <NEWLINE> print ( s ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> <NL> r = int ( input ( ) ) <NEWLINE> <NL> print ( 2 * np . pu * r ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> A = int ( input ( ) ) <NEWLINE> N -= M <NEWLINE> <DEDENT> if N >= 0 : <NEWLINE> <INDENT> print ( N ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
if __name__ == <STRING> : <NEWLINE> <INDENT> x = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> y = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> num = 0 <NEWLINE> for i in y : <NEWLINE> <INDENT> num += i <NEWLINE> <DEDENT> if x [ 0 ] < y : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : print ( x [ 0 ] - y ) <NEWLINE> <DEDENT>
N , M = input ( ) . split ( ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> S = sum ( A ) <NEWLINE> <NL> if N - S >= 0 : <NEWLINE> <INDENT> print ( N - S ) <NEWLINE> <DEDENT> else : print ( <STRING> ) <NEWLINE>
import numpy as np <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> M = int ( input ( ) ) <NEWLINE> A = np . array ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> Needed = np . sum ( A ) <NEWLINE> if Needed > N : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( N - Needed ) <NEWLINE> <DEDENT>
<COMMENT> <NL> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> val = sum ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> if val > m : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else <NEWLINE> <INDENT> print ( m - val ) <NEWLINE> <DEDENT>
n , m = int ( input . split ( ) ) <NEWLINE> s = 0 <NEWLINE> for i in input . split ( ) : <NEWLINE> <INDENT> s = s + i <NEWLINE> <DEDENT> if s > n : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( n - s ) <NEWLINE> <NL> <DEDENT>
N , M = map ( int , inuput ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> total = 0 <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> total += A [ i ] <NEWLINE> <NL> <DEDENT> if N - total >= 0 : <NEWLINE> <INDENT> print ( N - total ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> s = 0 <NEWLINE> for i in a : <NEWLINE> <INDENT> s += i <NEWLINE> <DEDENT> if s > a : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( a - s ) <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in range ( m ) : <NEWLINE> <INDENT> n -= A ( i ) <NEWLINE> <NL> <DEDENT> if n < 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( n ) <NEWLINE> <DEDENT>
n , m = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> print ( max ( n - sum ( a ) , - 1 ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> M = int ( input ( ) ) <NEWLINE> <NL> A = 0 <NEWLINE> <NL> for i in range ( M ) : <NEWLINE> <INDENT> A += int ( input ( ) ) <NEWLINE> <NL> <DEDENT> if M < A : <NEWLINE> <INDENT> print ( N - A ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT>
<NL> N , M = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> A = [ int ( a ) for a input ( ) ] <NEWLINE> tmp = N - sum ( A ) <NEWLINE> if tmp >= 0 : <NEWLINE> <INDENT> print ( tmp ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> A = [ ] <NEWLINE> <NL> for i in range ( M ) : <NEWLINE> <INDENT> A . append ( int ( input ( ) . split ( ) ) ) <NEWLINE> <NL> <DEDENT> gokei = int ( sum ( A ) ) <NEWLINE> <NL> if N - gokei < 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> print ( N - gokei ) <NEWLINE> <DEDENT>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> height = [ input ( ) for i in range ( M ) ] <NEWLINE> sum = N - sum ( height ) <NEWLINE> <NL> if ( sum >= 0 ) : <NEWLINE> <INDENT> print ( sum ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
timeofholiday = int ( input ( ) ) <NEWLINE> sum = 0 <NEWLINE> homework_num = int ( input ( ) ) <NEWLINE> for i in range ( homework_num ) : <NEWLINE> <INDENT> a = int ( input ( ) ) <NEWLINE> sum += a <NEWLINE> <NL> <DEDENT> if sum > timeofholiday : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( timeofholiday - sum ) <NEWLINE> <DEDENT>
a , n = input ( ) . split ( ) <NEWLINE> a = int ( a ) <NEWLINE> n = int ( n ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> c = 0 <NEWLINE> for i in range n : <NEWLINE> <INDENT> c += p [ i ] <NEWLINE> <NL> <DEDENT> if c > a : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( a - c ) <NEWLINE> <DEDENT>
print ( int ( input ( ) ) * 6.283 ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> list = [ map ( int , input ( ) . split ( ) ) ] <NEWLINE> <NL> if count ( list ) > N : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( N - count ( list ) ) <NEWLINE> <DEDENT>
N , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( 0 , M ) : <NEWLINE> <INDENT> ans = ans + l [ i ] <NEWLINE> <NL> <DEDENT> if ( ans > N ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( N - ans ) <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( 0. split ( ) ) ) ) <NEWLINE> t = 0 <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> t += A [ i ] <NEWLINE> <DEDENT> if t > n : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( n - t ) <NEWLINE> <NL> <DEDENT>
m = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> if sum ( a ) - n < 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( sum ( a ) - n ) <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> for num in input ( ) . split ( ) : <NEWLINE> <INDENT> n -= num <NEWLINE> <DEDENT> print ( n if n >= 0 else - 1 ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> As = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> vacation = n - sum ( As ) <NEWLINE> if vacation < 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print vacation <NEWLINE> <DEDENT>
N , M = map ( int , input ( ) . split ) <NEWLINE> lis = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> s = 0 <NEWLINE> for i in lis : <NEWLINE> <INDENT> s += i <NEWLINE> <DEDENT> if N - s < 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( N - s ) <NEWLINE> <DEDENT>
n , m = int ( input ( ) . split ( ) ) <NEWLINE> a = int ( input ( ) . split ( ) ) <NEWLINE> if sum ( a ) > n : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( n - sum ( a ) ) <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> m -= a [ i ] <NEWLINE> <DEDENT> if m >= 0 : <NEWLINE> <INDENT> print m <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print - 1 <NEWLINE> <DEDENT>
S = input ( ) . split ( ) <NEWLINE> N = S [ 0 ] <NEWLINE> N = int ( N ) <NEWLINE> del S [ 0 ] <NEWLINE> M = S [ 0 ] <NEWLINE> M = int ( M ) <NEWLINE> del S [ 0 ] <NEWLINE> s = 0 <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> s = s + int ( S [ i ] ) <NEWLINE> <DEDENT> if s > N : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( N - s ) <NEWLINE> <DEDENT>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = N - sum ( A ) : <NEWLINE> if sum ( A ) < N <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
N , M = input ( ) . split ( ) <NEWLINE> N = int ( N ) <NEWLINE> M = int ( M ) <NEWLINE> <NL> temp = sum ( input ( ) . split ( ) ) <NEWLINE> <NL> if N - temp > - 1 : <NEWLINE> <INDENT> print ( N - temp ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> print ( max ( N - sum ( A ) , - 1 ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> M = int ( input ( ) ) <NEWLINE> <NL> a = [ input ( ) . split ( ) for i in range ( M ) ] <NEWLINE> <NL> if sum ( a ) > N : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> print ( N - sum ( a ) ) <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> li = input ( ) . split ( ) <NEWLINE> b = 0 <NEWLINE> for a in li : <NEWLINE> <INDENT> b = b + a <NEWLINE> <DEDENT> if n >= b : <NEWLINE> <INDENT> print ( n - b ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n , m = map ( int ( input ( ) . split ( ) ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> sum = sum ( a ) <NEWLINE> if n - sum >= 0 : <NEWLINE> <INDENT> print ( n - sum ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT>
day = list ( int ( input ( ) ) ) <NEWLINE> ans = list ( int ( input ( ) ) ) <NEWLINE> num = 0 <NEWLINE> for i in range ( 0 , len ( ans ) ) : <NEWLINE> <INDENT> num += ans [ i ] <NEWLINE> <NL> <DEDENT> target = day [ 0 ] - num <NEWLINE> <NL> if target >= 0 : <NEWLINE> <INDENT> print ( target ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
data = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <COMMENT> <NL> <NL> N = data [ 0 ] <COMMENT> <NEWLINE> M = data [ 1 ] <COMMENT> <NEWLINE> <NL> A = 0 <COMMENT> <NEWLINE> <NL> for i in range ( 2 , M + 2 ) : <NEWLINE> <COMMENT> <NL> <INDENT> A += data [ i ] <NEWLINE> <NL> <DEDENT> if A <= N : <NEWLINE> <INDENT> print ( N - A ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> print ( max ( - 1 , N - sum ( A ) ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> M = int ( input ( ) ) <NEWLINE> list = [ ] <NEWLINE> homework = 0 <NEWLINE> <NL> for A in range ( 0 , M ) : <NEWLINE> <INDENT> list . append ( int ( input ( ) ) ) <NEWLINE> homework = homework + list [ A ] <NEWLINE> <NL> <DEDENT> play = N - homework <NEWLINE> <NL> if play < 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( play ) <NEWLINE> <DEDENT>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) <NEWLINE> print ( max ( - 1 , N - sum ( A ) ) ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 10000000 ) <NEWLINE> <NL> <COMMENT> <NL> dxdy = ( ( 1 , 0 ) , ( 0 , 1 ) ) <NEWLINE> <COMMENT> <NL> def pin ( type = int ) : <NEWLINE> <INDENT> return map ( type , input ( ) . rstrip ( ) . split ( ) ) <NEWLINE> <DEDENT> from math import gcd <NEWLINE> <NL> <COMMENT> <NL> def resolve ( ) : <NEWLINE> <INDENT> N , M = pin ( ) <NEWLINE> A = ( pin ( ) ) <NEWLINE> t = ( N ) - sum ( A ) <NEWLINE> <COMMENT> <NL> ans = t if t > - 1 else - 1 <NEWLINE> print ( ans ) <NEWLINE> <NL> <DEDENT> import sys <NEWLINE> from io import StringIO <NEWLINE> import unittest <NEWLINE> <NL> <NL> class TestClass ( unittest . TestCase ) : <NEWLINE> <INDENT> def assertIO ( self , input , output ) : <NEWLINE> <INDENT> stdout , stdin = sys . stdout , sys . stdin <NEWLINE> sys . stdout , sys . stdin = StringIO ( ) , StringIO ( input ) <NEWLINE> resolve ( ) <NEWLINE> sys . stdout . seek ( 0 ) <NEWLINE> out = sys . stdout . read ( ) [ : - 1 ] <NEWLINE> sys . stdout , sys . stdin = stdout , stdin <NEWLINE> self . assertEqual ( out , output ) <NEWLINE> <NL> <DEDENT> def test__1 ( self ) : <NEWLINE> <INDENT> input = <STRING> <NEWLINE> output = <STRING> <NEWLINE> self . assertIO ( input , output ) <NEWLINE> <NL> <DEDENT> def test__2 ( self ) : <NEWLINE> <INDENT> input = <STRING> <NEWLINE> output = <STRING> <NEWLINE> self . assertIO ( input , output ) <NEWLINE> <NL> <DEDENT> def test__3 ( self ) : <NEWLINE> <INDENT> input = <STRING> <NEWLINE> output = <STRING> <NEWLINE> self . assertIO ( input , output ) <NEWLINE> <NL> <DEDENT> def test__4 ( self ) : <NEWLINE> <INDENT> input = <STRING> <NEWLINE> output = <STRING> <NEWLINE> self . assertIO ( input , output ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <COMMENT> <NL> <NL> <STRING> <NEWLINE> <INDENT> resolve ( ) <COMMENT> <NEWLINE> <NL> <DEDENT>
N , M <NEWLINE> A = sum ( [ int ( x ) for x in input ( ) . split ( ) ] ) <NEWLINE> if N - M < 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( N - M ) <NEWLINE> <DEDENT>
m , n = map ( int , input ( ) . split ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> s += l [ i ] <NEWLINE> <DEDENT> print ( max ( m - s , - 1 ) ) <NEWLINE>
r = int ( input ( ) ) <NEWLINE> pi = 3.14159265358979 <NEWLINE> print ( 2 * r * pi ) <NEWLINE>
N , M = list ( map ( int , sys . stdin . readline ( ) . rstrip ( ) . split ( ) ) ) <NEWLINE> A = list ( map ( int , sys . stdin . readline ( ) . rstrip ( ) . split ( ) ) ) <NEWLINE> <NL> s = 0 <NEWLINE> for n in range ( M ) : <NEWLINE> <INDENT> s += A [ n ] <NEWLINE> <NL> <DEDENT> s -= N <NEWLINE> if s < 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( s ) <NEWLINE> <DEDENT>
<COMMENT> <NL> N , M = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <COMMENT> <NL> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> number_of_days_required = sum ( A ) <NEWLINE> maximum_hangout_days = N - number_of_days_required <NEWLINE> if maximum_hangout_days >= 0 : <NEWLINE> <INDENT> print ( maximum_hangout_days ) <NEWLINE> else : <NEWLINE> print ( - 1 ) <NEWLINE> <DEDENT>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> A = 0 <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> A = A + int ( input ( ) ) <NEWLINE> <DEDENT> ans = N - A <NEWLINE> if ans >= 0 : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT>
<INDENT> = map ( int , input ( ) . split ( ) ) <NEWLINE> <DEDENT> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> s = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> s += l [ i ] <NEWLINE> <DEDENT> print ( max ( m - s , - 1 ) ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , iuput ( ) . split ( ) ) ) <NEWLINE> a_sum = sum ( a ) <NEWLINE> x = n - a_sum <NEWLINE> if x >= 0 : <NEWLINE> <INDENT> print ( x ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ int ( input ( ) ) for _ in range ( M ) ] <NEWLINE> s_A = sum ( A ) <NEWLINE> <NL> if N - s_A >= 0 : <NEWLINE> <INDENT> print ( N - s_A ) <NEWLINE> <DEDENT> if N - s_A < 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <NL> <DEDENT>
N , M = map ( int , input ( ) . split ( ) ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> su = l . sum ( ) <NEWLINE> if N < su : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( N - su ) <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> li = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> res = n - li . sum ( ) <NEWLINE> if res >= 0 : <NEWLINE> <INDENT> print ( res ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ map ( int , input ( ) . split ( ) ) for i in range ( m ) ] <NEWLINE> b = sum ( a ) <NEWLINE> if n - a < 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( int ( n - a ) ) <NEWLINE> <DEDENT>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> daystofinish = sum ( A ) <NEWLINE> print ( N - daystofinish ) <NEWLINE> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> daystofinish = sum ( A ) <NEWLINE> if N - daystofinish < 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( N - daystofinish ) <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ int ( b ) for b in input ( ) ] <NEWLINE> def func ( n , a ) : <NEWLINE> <INDENT> if n < sum ( a ) : return <STRING> <NEWLINE> else : <NEWLINE> <INDENT> return n - sum ( a ) <NEWLINE> <DEDENT> <DEDENT> print ( func ( n , a ) ) <NEWLINE>
import numpy as np <NEWLINE> <NL> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> sumA = np . sum ( A ) <NEWLINE> remain = N - sumA <NEWLINE> <NL> if remain >= 0 : <NEWLINE> <INDENT> print ( remain ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> M = int ( input ( ) ) <NEWLINE> array = list ( map ( int , input ( ) . strip ( ) . split ( ) ) ) <NEWLINE> if ( N >= sum ( array ) ) : <NEWLINE> <INDENT> print ( N - sum ( array ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> A_sum = 0 <NEWLINE> <NL> for i in range ( M ) : <NEWLINE> <INDENT> A_sum += int ( input ( ) ) <NEWLINE> <NL> <DEDENT> if ( N - A_sum ) > 0 : <NEWLINE> <INDENT> print ( N - A_sum ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> a_ = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> sum = sum ( s_ ) <NEWLINE> res = n - sum <NEWLINE> <NL> if ( res < 0 ) : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( res ) <NEWLINE> <DEDENT>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> a = [ int ( input ( ) ) for i in range ( M ) ] <NEWLINE> <NL> if ( N >= sum ( a ) ) : <NEWLINE> <INDENT> print ( N - sum ( a ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT>
if __name__ == <STRING> : <NEWLINE> <INDENT> N , M = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> arr = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> res = N - sum ( arr ) <NEWLINE> if res < 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> hw_days = 0 <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> hw_days += int ( input ( ) ) <NEWLINE> <DEDENT> print ( n - hw_days if ( n - hw_days ) > 0 else - 1 ) <NEWLINE>
import math <NEWLINE> print ( 2 * math . pi * int ( input ( ) ) ) <NEWLINE>
n , m = map ( int ( input ( ) . split ( ) ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> print ( max ( - 1 , n - sum ( a ) ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> M = int ( input ( ) ) <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> N = N - int ( input ( ) ) <NEWLINE> <DEDENT> if N >= 0 : <NEWLINE> <INDENT> print ( N ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT>
N = ( ) <NEWLINE> M = ( ) <NEWLINE> A = ( ) <NEWLINE> <NL> N = int ( input ( <STRING> ) ) <NEWLINE> M = int ( input ( <STRING> ) ) <NEWLINE> <NL> for i in range ( 0 , M ) : <NEWLINE> <INDENT> A = int ( input ( <STRING> ) ) <NEWLINE> N = ( N - A ) <NEWLINE> <NL> <DEDENT> if N < 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( N ) <NEWLINE> <DEDENT>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> A = [ int ( input ( ) ) for i in range ( M ) ] <NEWLINE> <NL> print ( N - sum ( A ) ) <NEWLINE>
a = input ( ) . split ( ) <NEWLINE> <NL> N = int ( a [ 0 ] ) <NEWLINE> M = int ( a [ 1 ] ) <NEWLINE> <NL> <NL> b = 0 <NEWLINE> c = [ ] <NEWLINE> <NL> while True : <NEWLINE> <INDENT> if b >= M : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> e = int ( input ( ) ) <NEWLINE> c . append ( e ) <NEWLINE> b += 1 <NEWLINE> <NL> <DEDENT> d = 0 <NEWLINE> <NL> for i in c : <NEWLINE> <INDENT> d += int ( i ) <NEWLINE> <NL> <DEDENT> if d > N : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( N - d ) <NEWLINE> <DEDENT>
import math <NEWLINE> r = int ( input ( ) ) <NEWLINE> print ( 2 * r * math . pi ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input . split ( ) ) ) <NEWLINE> s = sum ( a ) <NEWLINE> if n < s : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( n - a ) <NEWLINE> <DEDENT>
list = int ( input ( ) . split ( ) ) <NEWLINE> N = list [ 0 ] <NEWLINE> <NL> list_1 = int ( input ( ) . split ( ) ) <NEWLINE> M = sum ( list_1 ) <NEWLINE> <NL> if M - N > 0 : <NEWLINE> <INDENT> print ( M - N ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT>
n , m = input ( ) . split ( ) <NEWLINE> add = 0 <NEWLINE> n = int ( n ) <NEWLINE> m = int ( m ) <NEWLINE> lst = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i in lst : <NEWLINE> <INDENT> add += i <NEWLINE> <DEDENT> if add > n : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> elif ( add = n ) : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( n - add ) <NEWLINE> <DEDENT>
R = int ( input ( ) ) <NEWLINE> <NL> print ( 2 * R * 3.1415926535897 ) <NEWLINE>
N , M = ( int ( x ) for x in input . split ( ) ) <NEWLINE> <NL> hw = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> <NL> hwsum = 0 <NEWLINE> <NL> for n in range ( len ( hw ) - 1 ) : <NEWLINE> <INDENT> hwsum += hw [ n ] <NEWLINE> <NL> <DEDENT> if hwsum <= N : <NEWLINE> <INDENT> print ( N - hwsum ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> A = sum ( list ( map ( int , input ( . split ( ) ) ) ) ) <NEWLINE> if A <= n : <NEWLINE> <INDENT> print ( n - A ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> t = sum ( A ) <NEWLINE> if N < t : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( N - A ) <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> c = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> total = 0 <NEWLINE> <NL> for i in range m : <NEWLINE> <INDENT> total += c [ i ] <NEWLINE> <NL> <DEDENT> if ( ( n - total ) >= 0 ) : <NEWLINE> <INDENT> print ( n - total ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( i for i in input ( ) . suplt ) <NEWLINE> <NL> all_homework_day = sum ( a ) <NEWLINE> <NL> if all_homework_day <= n : <NEWLINE> <INDENT> play_day = all_homework_day <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> play_day = - 1 <NEWLINE> <NL> <DEDENT> print ( play_day ) <NEWLINE>
n , m = map ( int , input ( ) > split ( ) ) <NEWLINE> homework = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if n >= sum ( homework ) : <NEWLINE> <INDENT> print ( n - sum ( homework ) ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT>
N , M = input ( ) . split ( ) <NEWLINE> <NL> N = int ( N ) <NEWLINE> M = int ( M ) <NEWLINE> <NL> a = input ( ) . split ( ) <NEWLINE> <NL> a = int ( a ) <NEWLINE> <NL> <NL> if sam ( a ) < N : <NEWLINE> <INDENT> print ( N - sam ( a ) ) <NEWLINE> <NL> <DEDENT> if sam ( a ) > N : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> homework = A . sum ( ) <NEWLINE> print ( n - m if n - m >= 0 else - 1 ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ int ( input ( ) ) for _ in range ( M ) ] <NEWLINE> <NL> s = sum ( A ) <NEWLINE> ans = - 1 <NEWLINE> if N >= s : ans = N - s <NEWLINE> print ( ans ) <NEWLINE>
N , M = [ int ( s ) for s in input ( ) . split ( <STRING> ) ] <NEWLINE> A = [ int ( s ) for s in input ( ) . split ( <STRING> ) ] <NEWLINE> <NL> task_days = sum ( A ) <NEWLINE> <NL> if N < task_days : <NEWLINE> <INDENT> return - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return N - task_days <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input . split ( ) ) ) <NEWLINE> A = 0 <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> A += a [ i ] <NEWLINE> <DEDENT> if ( A <= N ) : <NEWLINE> <INDENT> print ( N - A ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <COMMENT> <NL> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A_sum = 0 <NEWLINE> for i in range ( 0 , n ) : <NEWLINE> <INDENT> A_sum += A [ i ] <NEWLINE> <COMMENT> <NL> <DEDENT> x = N - A_sum <NEWLINE> if x < N : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( x ) <NEWLINE> <DEDENT>
N , M = map ( int ( input ( ) . split ( ) ) ) <NEWLINE> A = list ( map ( int ( input ( ) . split ( ) ) ) ) <NEWLINE> sumA = sum ( A ) <NEWLINE> if N - sumA < 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( N - sumA ) <NEWLINE> <DEDENT>
def actual ( n , m , a_list ) : <NEWLINE> <INDENT> a_sum = sum ( a_list ) <NEWLINE> <NL> if n >= a_sum : <NEWLINE> <INDENT> return n - a_sum <NEWLINE> <NL> <DEDENT> return - 1 <NEWLINE> <NL> <DEDENT> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> a_list = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> print ( actual ( n , m , a_list ) ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> sumA = 0 <NEWLINE> <NL> for i in A : <NEWLINE> <INDENT> sumA = sumA + A [ i ] <NEWLINE> <NL> <DEDENT> if sumA > N : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( N - sumA ) <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ 0 ] * m <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> a [ i ] = int ( input ( ) ) <NEWLINE> <NL> <DEDENT> ans = n - sum ( a ) <NEWLINE> if ans > 0 : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> l = sum ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> print ( n - s if s <= n else - 1 ) <NEWLINE>
N , M = map ( int , input . split ( ) ) <NEWLINE> a = list ( map ( int , input . split ( ) ) ) <NEWLINE> if N - sum ( a ) >= 0 : <NEWLINE> <INDENT> print ( N - sum ( a ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = n <NEWLINE> <NL> for i in range ( m ) : <NEWLINE> <INDENT> ans -= a [ m ] <NEWLINE> if ans < 0 : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n , m = map ( int , input ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> s = sum ( l ) <NEWLINE> if n - s < 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( n - s ) <NEWLINE> <DEDENT>
from b import resolve <NEWLINE> import sys <NEWLINE> from io import StringIO <NEWLINE> import unittest <NEWLINE> <NL> class TestClass ( unittest . TestCase ) : <NEWLINE> <INDENT> def assertIO ( self , input , output ) : <NEWLINE> <INDENT> stdout , stdin = sys . stdout , sys . stdin <NEWLINE> sys . stdout , sys . stdin = StringIO ( ) , StringIO ( input ) <NEWLINE> resolve ( ) <NEWLINE> sys . stdout . seek ( 0 ) <NEWLINE> out = sys . stdout . read ( ) [ : - 1 ] <NEWLINE> sys . stdout , sys . stdin = stdout , stdin <NEWLINE> self . assertEqual ( out , output ) <NEWLINE> <DEDENT> def test__1 ( self ) : <NEWLINE> <INDENT> input = <STRING> <NEWLINE> output = <STRING> <NEWLINE> self . assertIO ( input , output ) <NEWLINE> <DEDENT> def test__2 ( self ) : <NEWLINE> <INDENT> input = <STRING> <NEWLINE> output = <STRING> <NEWLINE> self . assertIO ( input , output ) <NEWLINE> <DEDENT> def test__3 ( self ) : <NEWLINE> <INDENT> input = <STRING> <NEWLINE> output = <STRING> <NEWLINE> self . assertIO ( input , output ) <NEWLINE> <DEDENT> def test__4 ( self ) : <NEWLINE> <INDENT> input = <STRING> <NEWLINE> output = <STRING> <NEWLINE> self . assertIO ( input , output ) <NEWLINE> <DEDENT> def test_Sample_Input_1 ( self ) : <NEWLINE> <INDENT> input = <STRING> <NEWLINE> output = <STRING> <NEWLINE> self . assertIO ( input , output ) <NEWLINE> <DEDENT> def test_Sample_Input_2 ( self ) : <NEWLINE> <INDENT> input = <STRING> <NEWLINE> output = <STRING> <NEWLINE> self . assertIO ( input , output ) <NEWLINE> <DEDENT> def test_Sample_Input_3 ( self ) : <NEWLINE> <INDENT> input = <STRING> <NEWLINE> output = <STRING> <NEWLINE> self . assertIO ( input , output ) <NEWLINE> <DEDENT> def test_Sample_Input_4 ( self ) : <NEWLINE> <INDENT> input = <STRING> <NEWLINE> output = <STRING> <NEWLINE> self . assertIO ( input , output ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> unittest . main ( ) <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> hwdsum = 0 <NEWLINE> k = 0 <NEWLINE> while k <= m - 1 : <NEWLINE> <INDENT> sum += a [ k ] <NEWLINE> <NL> <DEDENT> if n - sum >= 0 : <NEWLINE> <INDENT> print ( str ( sum ) ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <NL> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> li = [ ] <NEWLINE> ai = map ( int , input ( ) . split ( ) ) <NEWLINE> li . append ( ai ) <NEWLINE> k = sum ( li ) <NEWLINE> if k <= n : <NEWLINE> <INDENT> print ( n - k ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
<COMMENT> <NL> n , m = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> <INDENT> arr = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <DEDENT> s = sum ( arr ) <NEWLINE> if s > n : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> elif s == n : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( n - s ) <NEWLINE> <NL> <DEDENT>
a = input ( ) . split ( <STRING> ) <NEWLINE> b = input ( ) . split ( <STRING> ) <NEWLINE> c = 0 <NEWLINE> for i in b : <NEWLINE> <INDENT> c += int ( i ) <NEWLINE> <DEDENT> if a >= c : <NEWLINE> <INDENT> print ( a - c ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ map ( int , input ( ) . split ( ) ) ] <NEWLINE> print ( max ( n - sum ( a ) ) , - 1 ) <NEWLINE>
n , m = map ( int , input ( ) ) <NEWLINE> a = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> s = sum ( a ) <NEWLINE> if n < s : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( n - s ) <NEWLINE> <DEDENT>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> m = 0 <NEWLINE> for i in range ( 0 , len ( list ) ) : <NEWLINE> <INDENT> m = m + list [ i ] <NEWLINE> <NL> <DEDENT> if N - m >= 0 : <NEWLINE> print ( N - m ) <NEWLINE> elif N - m < 0 : <NEWLINE> print ( - 1 ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = N <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> ans = ans - A [ i ] <NEWLINE> <DEDENT> if ans < 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
<COMMENT> <NL> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <COMMENT> <NL> A_list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> sum_ = 0 <NEWLINE> for i in range ( len ( A_list ) ) : <NEWLINE> <INDENT> sum_ = sum + A_list [ i ] <NEWLINE> <NL> <DEDENT> ans = N - sum_ <NEWLINE> <NL> print ( ans ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map , int ( ) . input ( ) ) <NEWLINE> x = sum ( a ) <NEWLINE> if n < x : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( n - x ) <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . split ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ct = 0 <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> ct += a [ i ] <NEWLINE> <NL> <DEDENT> if n - ct >= 0 : <NEWLINE> <INDENT> print ( n - ct ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> L = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> X = X + L [ i ] <NEWLINE> <DEDENT> if N - X < 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( N - X ) <NEWLINE> <DEDENT>
n , m = input ( ) . split ( ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> print ( max ( n - sum ( a ) , - 1 ) ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ) ) <NEWLINE> <NL> homework = sum ( a ) <NEWLINE> <NL> if homework > N : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> print ( N - homework ) <NEWLINE> <DEDENT>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( M ) ] <NEWLINE> <NL> w = sum ( A ) <NEWLINE> <NL> r = N - w <NEWLINE> <NL> if r < 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( r ) <NEWLINE> <DEDENT>
vacationDayCount , homeworkCount = map ( int , input ( ) . split ( ) ) <NEWLINE> requiredDayList = list ( map ( int , input . split ( ) ) ) <NEWLINE> <NL> playableDayCount = vacationDayCount - sum ( requiredDayList ) <NEWLINE> <NL> if ( playableDayCount >= 0 ) : <NEWLINE> <INDENT> print ( playableDayCount ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if N - sum ( a ) >= 0 : <NEWLINE> <INDENT> print ( N - sum ( a ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n , m = [ int ( i ) for i in input ( ) ] <NEWLINE> list = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> a = n - sum ( list ) <NEWLINE> if a >= 0 : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> n = int ( input ( ) ) <NEWLINE> m = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <COMMENT> <NL> answer = n - sum ( a ) <NEWLINE> <NL> if answer > 0 : <NEWLINE> <INDENT> print ( answer ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> s = sum ( a ) <NEWLINE> <NL> if n - a > 0 : <NEWLINE> <INDENT> print ( n - a ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> ls = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for a in range ( ls ) : <NEWLINE> <INDENT> n -= a <NEWLINE> <DEDENT> print ( max ( - 1 , n ) ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( int ( input ( ) ) . split ( ) ) <NEWLINE> tmp = n - sum ( A ) <NEWLINE> <NL> if tmp >= 0 : <NEWLINE> <INDENT> print ( tmp ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT>
input_line = input ( ) . split ( <STRING> ) <NEWLINE> days = input_line [ 0 ] <NEWLINE> assignments = input_line [ 1 ] <NEWLINE> <NL> input_assign = input ( ) . split ( <STRING> ) <NEWLINE> <NL> how_many_days = sum ( input_assign ) <NEWLINE> <NL> len = days - how_many_days <NEWLINE> if len < 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( len ) <NEWLINE> <DEDENT>
N , M = int ( input ( ) . split ( ) ) <NEWLINE> A = input . split ( ) <NEWLINE> total = 0 <NEWLINE> for i in range ( A ) : <NEWLINE> <INDENT> total = total + A [ i ] <NEWLINE> <NL> <DEDENT> if total <= N : <NEWLINE> <INDENT> print ( N - total ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
NM = list ( map ( int , input ( ) . split ( ) ) <NEWLINE> N , M = NM [ 0 ] , NM [ 1 ] <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> x = 0 <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> x += a [ i ] <NEWLINE> <NL> <DEDENT> if x > N : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( N - x ) <NEWLINE> <DEDENT>
N , M = [ int ( s ) for s in input ( ) . split ( ) ] <NEWLINE> A = [ int ( a ) for a in input ( ) . split ( ) ] <NEWLINE> <NL> d = N - sum ( A ) <NEWLINE> <NL> if d > 0 : <NEWLINE> <INDENT> return d <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return - 1 <NEWLINE> <DEDENT>
314 15 <NEWLINE> 9 26 5 35 8 9 79 3 23 8 46 2 6 43 3 <NEWLINE>
N , M , A_i = ( int , input ( ) . split ( ) ) <NEWLINE> A = 0 <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> A += A_i <NEWLINE> <DEDENT> if N < A : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> print ( N - A ) <NEWLINE> <DEDENT>
import math <NEWLINE> a = input ( ) . split ( ) <NEWLINE> n , m = int ( a [ 0 ] ) , int ( a [ 1 ] ) <NEWLINE> f = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> s = 0 <NEWLINE> fl = 0 <NEWLINE> s = sum ( a ) <NEWLINE> if ( s >= n ) : <NEWLINE> <INDENT> print ( s - n ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> m = int ( input ( ) ) <NEWLINE> l1 = [ ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> ai = int ( input ( ) ) <NEWLINE> l1 . append ( ai ) <NEWLINE> <DEDENT> s = sum ( l1 ) <NEWLINE> r = ( n - s ) <NEWLINE> if r >= 0 : <NEWLINE> <INDENT> print ( r ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) , split ( ) ) ) <NEWLINE> a = sum ( A ) <NEWLINE> <NL> if N >= a : <NEWLINE> <INDENT> print ( int ( N - a ) ) <NEWLINE> <DEDENT> if N < a : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> a_data = input ( ) <NEWLINE> a = a_data . split ( <STRING> ) <NEWLINE> <NL> sum = 0 <NEWLINE> <COMMENT> <NL> for item as a : <NEWLINE> <INDENT> sum += int ( item ) <NEWLINE> <NL> <DEDENT> if sum > N : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( N - sum ) <NEWLINE> <DEDENT>
x , y = map ( int , input ( ) . spilit ( ) ) <NEWLINE> array = list ( map ( int , input ( ) . spilit ( ) ) ) <NEWLINE> su = sum ( array ) <NEWLINE> a = x - su <NEWLINE> if a > - 1 : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> d = n - sum ( a ) <NEWLINE> if ( a < 0 ) : <NEWLINE> <INDENT> d = - 1 <NEWLINE> <DEDENT> pritn ( d ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) , split ( ) ) ) <NEWLINE> a = int ( sum ( A ) ) <NEWLINE> <NL> if n >= a : <NEWLINE> <INDENT> print ( n - a ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT>
n , len ( a ) = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c = n - sum ( a ) <NEWLINE> print ( c ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> import sys <NEWLINE> import math <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> input = sys . stdin . readline <NEWLINE> r = int ( input ( ) ) <NEWLINE> print ( 2 * r * math . pi ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) ) <NEWLINE> ai = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> sumday = sum ( ai ) <NEWLINE> if n - sumday < 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( n - sumday ) <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( max ( n - sum ( list ( map ( int , input ( ) . split ( ) ) ) ) ) , - 1 ) <NEWLINE>
n , m = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> total = 0 <NEWLINE> for i in a : <NEWLINE> <INDENT> total += a <NEWLINE> <DEDENT> if n < total : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( n - total ) <NEWLINE> <DEDENT>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( max ( N - sum ( [ int ( x ) for x in input . split ( ) ] ) , - 1 ) ) <NEWLINE>
n , m = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> res = n - sum ( a ) <NEWLINE> print ( res if res >= 0 else - 1 <NEWLINE>
day , assignment = map ( int , input ( ) . split ( ) ) <NEWLINE> assignment_time = map ( int , input ( ) . split ( ) ) <NEWLINE> if sum ( assignment_time ) > N : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( N - sum ( assignment_time ) ) <NEWLINE> <DEDENT>
A = [ ] <NEWLINE> <NL> N = input ( ) <NEWLINE> M = input ( ) <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> A = A . append ( input ( ) ) <NEWLINE> <DEDENT> rest = N - sum ( A ) <NEWLINE> <NL> if rest >= 0 : <NEWLINE> <INDENT> print ( rest ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> A = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> play_days = copy . copy ( N ) <NEWLINE> for i in A : <NEWLINE> <INDENT> play_days -= i <NEWLINE> <DEDENT> if play_days < 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( play_days ) <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> sum = - 314 <NEWLINE> for i in a : <NEWLINE> <INDENT> sum += a <NEWLINE> <DEDENT> if sum < 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( sum ) <NEWLINE> <DEDENT>
NM = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> A = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> N = NM [ 0 ] <NEWLINE> M = NM [ 1 ] <NEWLINE> <NL> if NM >= sum ( A ) : <NEWLINE> <INDENT> print ( NM - sum ( A ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> sum = sum ( a ) <NEWLINE> if sum <= n : <NEWLINE> <INDENT> print ( n - sum ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> main ( ) <NEWLINE>
def resolve ( ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> count = 0 <NEWLINE> <NL> for c in range ( b ) : <NEWLINE> <INDENT> count += A [ c ] <NEWLINE> <NL> <DEDENT> print ( a - count ) <NEWLINE> <NL> resolve ( ) <NEWLINE> <DEDENT>
N = map ( int , input ( ) . split ( ) ) [ 0 ] <NEWLINE> A = map ( int , input ( ) . split ( ) ) <NEWLINE> sum = 0 <NEWLINE> for i in A : <NEWLINE> <INDENT> sum += A <NEWLINE> <DEDENT> if sum > N : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( N - sum ) <NEWLINE> <DEDENT>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ 0 ] * M <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> A [ i ] = int ( input ( ) ) <NEWLINE> <DEDENT> SUM = sum ( A ) <NEWLINE> if SUM > N : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( N - SUM ) <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i in range ( 0 , m + 1 ) : <NEWLINE> <INDENT> n -= a [ i ] <NEWLINE> <DEDENT> if n <= 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( n ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> M = int ( input ( ) ) <NEWLINE> List = [ int ( input ( ) ) for i in range ( M ) ] <NEWLINE> <NL> for i in range ( M ) : <NEWLINE> <INDENT> N = N - i <NEWLINE> if N < 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( N ) <NEWLINE>
N , M = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> S = 0 <NEWLINE> for i in M : <NEWLINE> <INDENT> S += A [ i ] <NEWLINE> <DEDENT> print ( N - S ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> print ( max ( n - sum ( a ) ) , - 1 ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> A = sorted ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = N - sum ( A ) <NEWLINE> if = N - sum ( A ) >= 0 : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> counter = 0 <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> counter += A [ i ] <NEWLINE> <NL> <DEDENT> if N - conter >= 0 : <NEWLINE> <INDENT> print ( N - counter ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT>
a = int ( input ( ) ) <NEWLINE> b = int ( input ( ) ) <NEWLINE> c = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> d = sum ( c ) <NEWLINE> <NL> if ( a - d ) < 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( a - d ) <NEWLINE> <NL> <NL> <NL> <NL> <DEDENT>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> homework = 0 <NEWLINE> <NL> for a in A : <NEWLINE> <INDENT> homework += a <NEWLINE> <NL> <DEDENT> if N > hemework : <NEWLINE> <INDENT> print ( N - homework ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> c = [ i for i in input ( ) . split ( ) ] <NEWLINE> <NL> print ( a - sum ( c ) if a >= sum ( c ) else <STRING> ) <NEWLINE>
a = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> Ai = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> n = a [ 0 ] <NEWLINE> days = 0 <NEWLINE> for i in range ( a [ 1 ] ) : <NEWLINE> <INDENT> days += Ai [ i ] <NEWLINE> <DEDENT> if days > n : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( n - days ) <NEWLINE> <DEDENT>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> daytofinish = sum ( A ) <NEWLINE> print ( N - daytofinish ) <NEWLINE> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> daytofinish = sum ( A ) <NEWLINE> if N - daytofinish < 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( N - daytofinish ) <NEWLINE> <DEDENT>
N , m = input ( ) . split ( ) <NEWLINE> M = int ( m ) <NEWLINE> L1 = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = - 1 <NEWLINE> if sum ( L1 ) <= N : <NEWLINE> <INDENT> ans = N - sum ( L1 ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
def resolve ( ) : <NEWLINE> <INDENT> input ( ) . split ( ) <NEWLINE> map ( int , input ( ) . split ( ) ) <NEWLINE> list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <DEDENT> resolve ( ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> an = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> sum_a = sum ( an ) <NEWLINE> if an - sum_a < 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( an - sum_a ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ int ( a ) for a input ( ) . split ( ) ] <NEWLINE> <NL> Asum = sum ( A ) <NEWLINE> if Asum > N : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( N - Asum ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = n - sum ( a ) <NEWLINE> <NL> if ans < 0 : <NEWLINE> <INDENT> return - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return ans <NEWLINE> <DEDENT>
j = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> n = j [ 0 ] <NEWLINE> m = j [ 1 ] <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> s = int ( 0 ) <NEWLINE> for i in range [ 0 , m ] : <NEWLINE> <INDENT> s += a [ i ] <NEWLINE> <DEDENT> if n - s < 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( n - s ) <NEWLINE> <DEDENT>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i in range ( M + 1 ) : <NEWLINE> <INDENT> N -= a [ i ] <NEWLINE> <DEDENT> print ( N if N > 0 else <STRING> ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> list_ = [ ] <NEWLINE> for i in range ( b ) : <NEWLINE> <INDENT> c = int ( input ( ) ) <NEWLINE> list_ . append ( c ) <NEWLINE> <DEDENT> d = sum ( list_ ) <NEWLINE> print ( a - d ) <NEWLINE> <NL> <NL>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> a = 0 <NEWLINE> for _ in range ( m ) : <NEWLINE> <INDENT> a += int ( input ( ) ) <NEWLINE> <DEDENT> if a > n : print ( - 1 ) <NEWLINE> else : print ( n - a ) <NEWLINE>
N = input ( ) <NEWLINE> N = int ( N ) <NEWLINE> M = input ( ) <NEWLINE> M = int ( M ) <NEWLINE> <NL> sum = 0 <NEWLINE> for num in range ( M ) : <NEWLINE> <INDENT> a = input ( ) <NEWLINE> a = int ( a ) <NEWLINE> sum = sum + a <NEWLINE> <NL> <DEDENT> nokori = N - sum <NEWLINE> if nokori >= 0 : <NEWLINE> <INDENT> print ( nokori ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> s = sum ( a ) <NEWLINE> if sum > n : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( n - s ) <NEWLINE> <DEDENT>
import math <NEWLINE> import numpy as np <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> N , M = ( int ( x ) for x in input ( ) . split ( ) ) <NEWLINE> A = [ int ( x ) for x in input ( ) . split ( M ) ] <NEWLINE> <NL> for i in range ( M ) : <NEWLINE> <INDENT> N = N - A [ i ] <NEWLINE> <NL> <DEDENT> if N < 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( N ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> a = input ( ) . split ( ) <NEWLINE> <NL> a = sum ( int ( i ) for i in a ) <NEWLINE> <NL> asobi = n - a <NEWLINE> if asobi = > 0 : <NEWLINE> <INDENT> print ( asobi ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT>
print ( <STRING> ) <NEWLINE> N = int ( input ( ) ) <NEWLINE> print ( <STRING> ) <NEWLINE> M = int ( input ( ) ) <NEWLINE> <NL> for i in range ( M ) : <NEWLINE> <INDENT> Ai = int ( input ( ) ) <NEWLINE> N = N - Ai <NEWLINE> <NL> <DEDENT> if N >= 0 : <NEWLINE> <INDENT> print ( N ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> N = - 1 <NEWLINE> print ( N ) <NEWLINE> <DEDENT>
n , m = map ( int , input . split ( ) ) <NEWLINE> a = list ( map ( int , input . split ( ) ) ) <NEWLINE> sum = 0 <NEWLINE> for i in a : <NEWLINE> <INDENT> sum += i <NEWLINE> <DEDENT> if n >= sum : <NEWLINE> <INDENT> print ( n - sum ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> a = 0 <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> b = int ( input ( ) ) <NEWLINE> a += b <NEWLINE> <NL> <DEDENT> day_count = N - a <NEWLINE> <NL> if day_count >= 0 : <NEWLINE> <INDENT> print ( day ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT>
n , m = input ( ) . split ( ) <NEWLINE> a = [ i for i in input . split ( ) ] <NEWLINE> if sum ( a ) > n : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( m - sum ( a ) ) <NEWLINE> <DEDENT>
N , M = map ( int , input ( ) . sprit ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . sprit ( ) ) ) <NEWLINE> <NL> enjoy = N - sum ( A ) <NEWLINE> <NL> if N >= sum ( A ) : <NEWLINE> <INDENT> print ( enjoy ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . strip ( ) . split ( <STRING> ) ) <NEWLINE> <NL> homework = list ( n , m ) <NEWLINE> <NL> day = n - sum ( homework ) <NEWLINE> <NL> if day >= 0 : <NEWLINE> <NL> <INDENT> print ( day ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <NL> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT>
N , M = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> sum = 0 <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> sum += A [ i ] <NEWLINE> <DEDENT> if N - sum < 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( N - sum ) <NEWLINE> <DEDENT>
N , M = [ map ( int , input ( . split ( ) ) ) ] <NEWLINE> <NL> works = [ map ( int , input ( ) . split ( ) ) ] <NEWLINE> <NL> ans = N <NEWLINE> <NL> for i in range ( M ) : <NEWLINE> <INDENT> ans -= works [ i ] <NEWLINE> <NL> <DEDENT> if ans < 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> daytofinish = sum ( A ) <NEWLINE> print ( N - daytofinish ) <NEWLINE> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> daytofinish = sum ( A ) <NEWLINE> if N - daytofinish < 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( N - daytofinish ) <NEWLINE> <DEDENT>
n , m = input ( ) . split ( ) ; <NEWLINE> a = input ( ) . split ( ) ; <NEWLINE> <NL> a_sum = sum ( a ) ; <NEWLINE> <NL> if n - a_sum < 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( n - a_sum ) <NEWLINE> <NL> <DEDENT>
<NL> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i in range ( M ) <NEWLINE> <INDENT> N = N - A [ i ] <NEWLINE> <DEDENT> if N >= 0 <NEWLINE> <INDENT> print ( N ) <NEWLINE> <DEDENT> else <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ ] <NEWLINE> A = input ( ) . split ( ) <NEWLINE> A = [ int ( n ) for n in A ] <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> N -= A [ i ] <NEWLINE> <DEDENT> print ( N ) <NEWLINE> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ ] <NEWLINE> A = input ( ) . split ( ) <NEWLINE> A = [ int ( n ) for n in A ] <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> N -= A [ i ] <NEWLINE> <DEDENT> if N >= 0 : <NEWLINE> <INDENT> print ( N ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> def ILI ( ) : return list ( map ( int , sys . stdin . readline ( ) . rstrip ( ) . split ( ) ) ) <NEWLINE> def ISI ( ) : return map ( int , sys . stdin . readline ( ) . rstrip ( ) . split ( ) ) <NEWLINE> <NL> n , m = ISI ( ) <NEWLINE> l = ILI ( ) <NEWLINE> if n - sum8 ( l ) < : print ( - 1 ) <NEWLINE> else : print ( n - sum ( l ) ) <NEWLINE>
n , m = ( int ( i ) for i in input ( ) . split ( ) ) <NEWLINE> l = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> if ( sum ( l ) >= n ) : <NEWLINE> <INDENT> print ( n - sum ( l ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 <NEWLINE> <DEDENT>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> s = sum ( A ) <NEWLINE> <NL> print ( max ( N - A , - 1 ) ) <NEWLINE>
D , n = map ( int , input ( ) . split ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . spliy ( ) ) ) <NEWLINE> print ( D - sum ( l ) ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> N = N - M <NEWLINE> if = 0 < N : <NEWLINE> <INDENT> print ( N ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> li = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> g = n - sum ( li ) <NEWLINE> if g >= 0 : <NEWLINE> <INDENT> print g <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print - 1 <NEWLINE> <DEDENT>
a , _ = map ( int , input ( ) . split ( ) ) <NEWLINE> li = [ x for x in input ( ) . split ( ) ] <NEWLINE> s = sum ( li ) <NEWLINE> print ( a - s ) <NEWLINE>
m , n = map ( int , input ( ) . split ( ) ) <NEWLINE> a = input ( ) . split ( ) <NEWLINE> while n > 0 : <NEWLINE> <INDENT> m = m - a [ n - 1 ] <NEWLINE> n = n - 1 <NEWLINE> <DEDENT> if m >= 0 : <NEWLINE> <INDENT> print ( m ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT>
int a [ 10010 ] ; <NEWLINE> int main ( ) { <NEWLINE> <INDENT> int n , m ; <NEWLINE> scanf ( <STRING> , & n , & m ) ; <NEWLINE> for ( int i = 0 ; i < m ; i + + ) scanf ( <STRING> , & a [ i ] ) ; <NEWLINE> int s = 0 ; <NEWLINE> for ( int i = 0 ; i < m ; i + + ) s += a [ i ] ; <NEWLINE> if ( s > n ) { <NEWLINE> <INDENT> printf ( <STRING> ) ; <NEWLINE> <DEDENT> } else { <NEWLINE> <INDENT> printf ( <STRING> , n - s ) ; <NEWLINE> <DEDENT> } <NEWLINE> <DEDENT> } <NEWLINE>
N = int ( input ( ) ) <NEWLINE> M = int ( input ( ) ) <NEWLINE> <NL> A = [ input ( ) for i in range ( M ) ] <NEWLINE> <NL> x = N <NEWLINE> <COMMENT> <NL> for j in range ( M ) : <NEWLINE> <INDENT> x = x - int ( A [ j ] ) <NEWLINE> j += 1 <NEWLINE> <NL> <DEDENT> if x < 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> print ( x ) <NEWLINE> <DEDENT>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> flag = True <NEWLINE> <NL> for i in A : <NEWLINE> N = N - i <NEWLINE> if N < 0 : <NEWLINE> flag = False <NEWLINE> break <NEWLINE> <NL> if flag == True : <NEWLINE> <INDENT> print ( N ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> mm = [ ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> s = int ( input ( ) ) <NEWLINE> mm . append ( s ) <NEWLINE> <DEDENT> a = n - sum ( mm ) <NEWLINE> if a >= 0 : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <DEDENT> else : print ( - 1 ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ int ( x ) * M for x in input ( ) . split ( ) ] <NEWLINE> <NL> if N - sum ( A ) >= 0 : <NEWLINE> <INDENT> print ( N - A . sum ( ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> A = np . array ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> tot = np . sum ( A ) <NEWLINE> <NL> if tot > N : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( N - tot ) <NEWLINE> <DEDENT>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <COMMENT> <NEWLINE> ans = 0 <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> ans += a [ i ] <NEWLINE> <DEDENT> if ans <= n : <NEWLINE> <INDENT> print ( n - ans ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> main ( ) <NEWLINE>
tot , n = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if tot >= a . sum ( ) : <NEWLINE> <INDENT> print ( tot - a . sum ( ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> l = list ( map ( int , input ( . split ( ) ) ) ) <NEWLINE> ans = n - sum ( l ) <NEWLINE> if ans < 0 : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ int ( input ( ) . split ( ) ) for i in range ( M ) ] <NEWLINE> <NL> if ( sum ( A ) == N ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif ( sum ( A ) > N ) : <NEWLINE> <INDENT> print ( N - sum ( A ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b = map ( int , input ( ) . split ) <NEWLINE> c = input ( ) . split ( ) <NEWLINE> l = [ ] <NEWLINE> for i in c : <NEWLINE> <INDENT> l . append ( int ( i ) ) <NEWLINE> <DEDENT> if sum ( l ) > a : <NEWLINE> <INDENT> print ( - 1 , end = <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( a - sum ( l ) , end = <STRING> ) <NEWLINE> <DEDENT>
n , m = ( int ( i ) for i in input ( ) . split ( ) ) <NEWLINE> a = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> s = sum ( a ) <NEWLINE> if n - a >= 0 : <NEWLINE> <INDENT> print ( n - a ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> A = input ( ) . split ( ) <NEWLINE> if sum ( A ) > N : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( N - sum ( A ) ) <NEWLINE> <DEDENT>
atcoder - tools : The pre - rendered templates are not found . <COMMENT> <NEWLINE> import sys <NEWLINE> <NL> <NL> def solve ( N : int , M : int , A : <STRING> ) : <NEWLINE> <INDENT> play = N - sum ( A ) <NEWLINE> if play > - 1 : <NEWLINE> <INDENT> print ( play ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <INDENT> def iterate_tokens ( ) : <NEWLINE> <INDENT> for line in sys . stdin : <NEWLINE> <INDENT> for word in line . split ( ) : <NEWLINE> <INDENT> yield word <NEWLINE> <DEDENT> <DEDENT> <DEDENT> tokens = iterate_tokens ( ) <NEWLINE> N = int ( next ( tokens ) ) <COMMENT> <NEWLINE> M = int ( next ( tokens ) ) <COMMENT> <NEWLINE> A = [ int ( next ( tokens ) ) for _ in range ( M ) ] <COMMENT> <NEWLINE> solve ( N , M , A ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> A = sum ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> print ( max ( - 1 , N - A ) ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = max ( N - sum ( A ) ) <NEWLINE> print ( ans ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> s = sum ( a ) <NEWLINE> if ( n = > s ) : <NEWLINE> <INDENT> print ( n - s ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
NM = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> N , M = NM [ 0 ] , NM [ 1 ] <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if sum ( a ) > N : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( N - sum ( A ) ) <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> l = list ( ) <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> k = int ( input ( ) ) <NEWLINE> l . append ( k ) <NEWLINE> <DEDENT> s = sum ( l ) <NEWLINE> <NL> ans = n - s <NEWLINE> if ans >= 0 : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> M = int ( input ( ) ) <NEWLINE> arr = list ( map ( int , input ( ) . rstrip ( ) . split ( ) ) ) <NEWLINE> summ = 0 <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> summ += arr [ i ] <NEWLINE> <DEDENT> if summ >= N : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( N - summ ) <NEWLINE> <DEDENT>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) , split ( ) ) ) <NEWLINE> sum = sum ( A ) <NEWLINE> if sum > N : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = N - sum <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
/ usr / local / bin / python3 .8 / Users / tmohiro / Desktop / Atcoder / ABC163 / B . py <NEWLINE> 314 15 <NEWLINE> 9 26 5 35 8 9 79 3 23 8 46 2 6 43 3 <NEWLINE> 9 <NEWLINE> <NL> Process finished with exit code 0 <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if n - sum ( a ) <= 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else print ( n - sum ( a ) ) <NEWLINE>
mn = input ( ) . split ( ) <NEWLINE> mn = [ int ( x ) for x in mn ] <NEWLINE> n = mn [ 0 ] <NEWLINE> m = mn [ 1 ] <NEWLINE> a = input ( ) . split ( ) <NEWLINE> a = [ int ( x ) for x in a ] <NEWLINE> <NL> <NL> total = sum ( a ) <NEWLINE> if n - total < 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> prtin ( n - total ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> A = [ ] <NEWLINE> for l in sys . stdin : <NEWLINE> <INDENT> A . append ( int ( l ) ) <NEWLINE> <NL> <DEDENT> need_day = sum ( A ) <NEWLINE> <NL> if N < need_day : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( N - need_day ) <NEWLINE> <DEDENT>
import bisect , collections , copy , heapq , itertools , math , numpy , string <NEWLINE> import sys <NEWLINE> f = open ( <STRING> , <STRING> ) <NEWLINE> sys . stdin = f <NEWLINE> <NL> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> As = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> d = sum ( As ) <NEWLINE> if N < d : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( N - d ) <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> s = sum ( l ) <NEWLINE> if s > l : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( l - s ) <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> sum = 0 <NEWLINE> for i in m : <NEWLINE> <INDENT> sum += A [ i ] <NEWLINE> <NL> <DEDENT> ans = n - sum <NEWLINE> if ans >= 0 : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> days = 0 <NEWLINE> <NL> for i in range ( m ) : <NEWLINE> <INDENT> days += a [ i ] <NEWLINE> <NL> <DEDENT> remaining = n - days <NEWLINE> <NL> if remaining < 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( remainig ) <NEWLINE> <DEDENT>
m = int ( input ( ) ) <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = m - sum ( a ) <NEWLINE> <NL> if ans < 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <NL> <DEDENT>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if N >= sum ( A ) : <NEWLINE> <INDENT> print ( N - A ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT>
m , n = int ( input ( ) ) <NEWLINE> li = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if sum ( li ) > m : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( m - sum ( li ) ) <NEWLINE> <DEDENT>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> homeworks = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> print ( - 1 if sum ( homeworks ) > N else sum ( homeworks ) - N ) ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> lst = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> plus = 0 <NEWLINE> for a in range ( lst ) : <NEWLINE> <INDENT> plus += a <NEWLINE> <DEDENT> if plus <= N : <NEWLINE> <INDENT> print ( N - plus ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> homework = 0 <NEWLINE> for i in range ( l [ 1 ] ) : <NEWLINE> <INDENT> homework = homework + l [ i + 2 ] <NEWLINE> <DEDENT> free = l [ 0 ] - homework <NEWLINE> if free < 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( free ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> m = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> print ( n - sum ( a ) ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ 0 ] * M <NEWLINE> for i in M : <NEWLINE> <INDENT> A [ i ] = int ( input ( ) ) <NEWLINE> N -= A [ i ] <NEWLINE> <NL> <DEDENT> if N < 0 : <NEWLINE> <INDENT> N = - 1 <NEWLINE> <NL> <DEDENT> print ( N ) <NEWLINE>
N M = map ( int , input ( ) . split ( ) ) <NEWLINE> List = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> print ( N - sum ( List ) if N - sum ( List ) >= 0 else - 1 ) <NEWLINE>
n , m = map ( int , input ( ) ) <NEWLINE> a = sum ( [ int ( i ) for i in input ( ) . split ( ) ] ) <NEWLINE> <NL> print ( n - a if n - a >= 0 else <STRING> ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> m = int ( input ( ) ) <NEWLINE> li = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if n - sum ( li ) >= 0 : <NEWLINE> <INDENT> print ( n - sum ( li ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT>
m , n = map ( int , input ( ) . split ( ) ) <NEWLINE> a = 0 <NEWLINE> for i in range ( m ) <NEWLINE> <INDENT> a += int ( input ( ) ) <NEWLINE> <NL> <DEDENT> n = n - a <NEWLINE> if a <= - 2 : <NEWLINE> <INDENT> a = - 1 <NEWLINE> <NL> <DEDENT> print ( a ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> list_1 = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> i = 0 <NEWLINE> sum = 0 <NEWLINE> <NL> while i <= M : <NEWLINE> <INDENT> sum = sum + list_1 [ i ] <NEWLINE> i = i + 1 <NEWLINE> <NL> <DEDENT> if sum > N : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> print ( sum - N ) <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> lst = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> if n - lst . sum ( ) >= 0 : <NEWLINE> <INDENT> print ( n - lst . sum ( ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT>
N , M = map ( int , input ( ) . sprit ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = sum ( A ) <NEWLINE> ans = N - a <NEWLINE> if ans >= 0 : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <NL> <NL> <DEDENT>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> A = 0 <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> s = int ( input ( ) ) <NEWLINE> A += s <NEWLINE> <NL> <DEDENT> sub = N - A <NEWLINE> <NL> if sub >= 0 : <NEWLINE> <INDENT> print ( sub ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> l = list ( map ( int , input ( ) ) ) <NEWLINE> k = sum ( l ) <NEWLINE> if k > n : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( n - k ) <NEWLINE> <DEDENT>
NM = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> N = NM [ 0 ] <NEWLINE> M = NM [ 1 ] <NEWLINE> Alist = [ ] <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> Alist . append ( int ( input ( ) ) ) <NEWLINE> <DEDENT> daysNeeded = sum ( Alist ) <NEWLINE> if daysNeeded > N : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( M - daysNeeded ) <NEWLINE> <DEDENT>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> A_list = list ( map ( int , input . split ( ) ) ) <NEWLINE> <NL> avail = N - sum ( A_list ) <NEWLINE> <NL> if avail >= 0 : <NEWLINE> <INDENT> print ( avail ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT>
N , M = map ( int , input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) ) ) <NEWLINE> print ( N - sum ( A ) ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if np . sum ( p ) > M : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( N - np . sum ( p ) ) <NEWLINE> <DEDENT>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> A = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> ans1 = sum ( A ) <NEWLINE> ans2 = N - ans1 <NEWLINE> <NL> if sns2 < 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans2 ) <NEWLINE> <DEDENT>
n , m = map ( int ( input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if n >= sum ( a ) : <NEWLINE> <INDENT> print ( n - sum ( a ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT>
summer_vacation , amount_of_homework = map ( int , input ( ) . split ( ) ) <NEWLINE> a = map ( int , input ( ) . split ( ) ) <NEWLINE> homework_list = list [ a ] <NEWLINE> <NL> total_days = 0 <NEWLINE> <NL> for i in homework_list : <NEWLINE> <INDENT> total_days += i <NEWLINE> <NL> <DEDENT> if summer_vacation >= total_days : <NEWLINE> <INDENT> print ( summer_vacation - total_days ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ int ( input ( ) ) for _ in range ( M ) ] <NEWLINE> <NL> days = sum ( A ) <NEWLINE> <NL> if days <= N : <NEWLINE> <INDENT> print ( N - days ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> a = 0 <NEWLINE> a += map ( int , input ( ) . split ( ) ) <NEWLINE> if ( n > a ) : <NEWLINE> <INDENT> print ( <STRING> , n - a ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> , <NEWLINE> <DEDENT>
<COMMENT> <NL> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , inout ( ) . split ( ) ) ) <NEWLINE> print ( - 1 if sum ( a ) >= n else n - sum ( a ) ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> day_list = input ( ) . split ( ) <NEWLINE> <NL> t = 0 <NEWLINE> <NL> for A in day_list : <NEWLINE> <INDENT> t += A <NEWLINE> <NL> <DEDENT> if N - t < 0 : print ( - 1 ) <NEWLINE> else : print ( N - t ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> sum = 0 <NEWLINE> <NL> for i in A : <NEWLINE> <INDENT> sum += i <NEWLINE> <NL> <DEDENT> if sum > N : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( n - sum ) <NEWLINE> <DEDENT>
from operator import add <NEWLINE> import functools <NEWLINE> <NL> <NL> n = int ( input ( ) ) <NEWLINE> m = int ( input ( ) ) <NEWLINE> list_homework = input ( ) . split ( <STRING> ) <NEWLINE> list_homework = [ int ( list_homework [ i ] ) for i in range ( len ( list_homework ) ) ] <NEWLINE> <NL> rest_day = n - functools . reduce ( add , list_homework ) <NEWLINE> <NL> if rest_day >= 0 : <NEWLINE> <INDENT> print ( rest_day ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n , m = list ( map ( int , input ( ) . split ( ) ) <NEWLINE> print ( max ( n - sum ( list ( map ( int , input ( ) . split ( ) ) ) ) , 0 ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> res = rep ( 0 , N ) <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> res [ A [ i ] - 1 ] += 1 <NEWLINE> <DEDENT> for i in res : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT>
from collection import counter <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> c = counter ( a ) <NEWLINE> <NL> for _ in c : <NEWLINE> <INDENT> print ( _ ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> li = [ ] <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> q = p . count ( i ) <NEWLINE> li . append ( q ) <NEWLINE> <DEDENT> nl = li . split ( <STRING> ) <NEWLINE> print ( nl ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> L = [ 0 ] * ( N + 1 ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> L [ A [ i ] ] += 1 <NEWLINE> <DEDENT> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> print ( L [ i ] ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = [ 0 ] * n <NEWLINE> for aa in a : <NEWLINE> <INDENT> ans [ aa - 1 ] += 1 <NEWLINE> <DEDENT> print ( ans sep = <STRING> ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = [ 0 ] * N <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> ans [ A [ i ] - 1 ] += 1 <NEWLINE> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> print ( ans [ i ] ) <NEWLINE> <NL> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = [ 0 ] * N <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> ans [ A [ i ] - 1 ] += 1 <NEWLINE> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> print ( ans [ i ] ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> l = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> l . append ( 0 ) <NEWLINE> <DEDENT> for j in a : <NEWLINE> <INDENT> l [ j - 1 ] += 1 <NEWLINE> <DEDENT> for k in l : <NEWLINE> <INDENT> print ( s ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> l = [ 0 ] * N <NEWLINE> numpy . sort ( a ) <NEWLINE> for i in a : <NEWLINE> <INDENT> l [ i - 1 ] += 1 <NEWLINE> <DEDENT> for i in l : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> submap = { } <NEWLINE> for each in a : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> submap [ i ] += 1 <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> submap [ i ] = 1 <NEWLINE> <DEDENT> <DEDENT> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> print ( submap [ i ] ) <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> <DEDENT>
def resolve ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = [ 0 ] * n <NEWLINE> for i in a : <NEWLINE> ans [ i - 1 ] += 1 <NEWLINE> for i in ans : <NEWLINE> print ( i ) <NEWLINE> <DEDENT> resolve ( ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> ans . append . ( 0 ) <NEWLINE> <DEDENT> for i in range ( N - 1 ) : <NEWLINE> <INDENT> ans [ A [ i ] ] += 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> count = 0 <NEWLINE> for i in N - 1 : <NEWLINE> <INDENT> if i == <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = [ 0 ] * n <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> b [ a [ i ] ] += 1 <NEWLINE> <NL> <DEDENT> for e in b : <NEWLINE> <INDENT> print ( e ) <NEWLINE> <DEDENT>
from itertools import repeat <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> lis = list ( map ( int , input . split ( ) ) ) <NEWLINE> d = [ [ 0 ] for i in repeat ( None , n ) ] <NEWLINE> <NL> for i in lis : <NEWLINE> <INDENT> d [ i - 1 ] [ 0 ] += 1 <NEWLINE> <NL> <DEDENT> for i in d : <NEWLINE> <INDENT> print ( i [ 0 ] ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> josi = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> count = [ 0 ] * N <NEWLINE> n = 0 <NEWLINE> while n < N - 1 : <NEWLINE> <INDENT> count [ josi [ n ] ] = count [ josi [ n ] ] + 1 <NEWLINE> n = n + 1 <NEWLINE> <DEDENT> n = 0 <NEWLINE> while n < N : <NEWLINE> <INDENT> print ( count [ n ] ) <NEWLINE> <NL> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = map ( int , input ( ) . split ( ) ) <NEWLINE> c = [ ] <NEWLINE> for i in range N : <NEWLINE> <INDENT> c [ i ] = 0 <NEWLINE> <DEDENT> for j in A : <NEWLINE> <INDENT> c [ j - 1 ] += 1 <NEWLINE> <NL> <DEDENT> for C in c : <NEWLINE> <INDENT> print ( C ) <NEWLINE> <DEDENT>
import collections <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = deque ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> C = collections . Counter ( A ) <NEWLINE> <NL> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> if i in C . keys ( ) : <NEWLINE> <INDENT> print ( C [ i ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = [ 0 ] * N <NEWLINE> for _i in range ( N ) : <NEWLINE> <INDENT> ans [ A [ i ] - 1 ] += 1 <NEWLINE> <NL> <DEDENT> for x in ans : <NEWLINE> <INDENT> print ( x ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> A = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> <NL> B = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> B . append ( 0 ) <NEWLINE> <NL> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> e = int ( A [ N - i - 1 ] ) <NEWLINE> B [ e ] += 1 <NEWLINE> <NL> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> print ( B [ i ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> ans = [ 0 ] * n <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ans [ a [ i ] - 1 ] += 1 <NEWLINE> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> print ( ans [ i ] ) <NEWLINE> <DEDENT>
n = int ( input ( ) . strip ( ) . split ( ) ) <NEWLINE> arr = [ int ( i ) for i in input ( ) . strip ( ) . split ( ) ] <NEWLINE> result = { i : 0 for i in range ( 1 , n + 1 ) } <NEWLINE> for i , j in enumerate ( arr , 2 ) : <NEWLINE> <INDENT> result [ j ] += 1 <NEWLINE> <NL> <DEDENT> for i in result . values ( ) : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = [ int ( 0 ) ] * n <NEWLINE> l = list ( map ( int , input . ( ) . split ( ) ) ) <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> a [ l [ i ] ] = a [ l [ i ] ] + 1 <NEWLINE> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> print ( a [ i ] ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> s = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> l = [ 0 ] * n <NEWLINE> while i < n - 2 : <NEWLINE> <INDENT> l [ s [ i ] - 1 ] += 1 <NEWLINE> i += 1 <NEWLINE> <DEDENT> for _ in range ( n ) : <NEWLINE> <INDENT> print ( l [ _ ] ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = [ int ( s ) for s in input ( ) . split ( <STRING> ) ] <NEWLINE> R = [ 0 ] * ( A + 1 ) <NEWLINE> for a in A : <NEWLINE> <INDENT> R [ a - 1 ] += 1 <NEWLINE> <DEDENT> for a in R : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> l = [ 0 ] * n <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> if a [ i ] > 0 : <NEWLINE> <INDENT> l [ a [ i ] - 1 ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> print ( l [ i ] ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> n = int ( input ( ) ) <NEWLINE> jousi = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = np . zeros ( n ) <NEWLINE> for i in range ( len ( jousi ) ) : <NEWLINE> <INDENT> a [ jousi [ i ] - 1 ] += 1 <NEWLINE> <DEDENT> for i in range ( len ( a ) ) : <NEWLINE> print ( int ( a [ i ] ) ) <NEWLINE>
import collections as c <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = c . Counter ( a ) <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> print ( b [ i ] ) <NEWLINE> <DEDENT>
<NL> N = int ( input ( ) ) <NEWLINE> A = np . array ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> ans = np . zeros ( N ) <NEWLINE> for a in A : <NEWLINE> <INDENT> ans [ a - 1 ] += 1 <NEWLINE> <DEDENT> for o in ans : <NEWLINE> <INDENT> print ( int ( o ) ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> last = A [ N - 2 ] <NEWLINE> for i in range ( 1 , last + 1 ) : <NEWLINE> <INDENT> print ( A . count ( i ) ) <NEWLINE> <DEDENT> for i in range ( last + 1 , N + 1 ) <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = dict ( ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> b [ i + 1 ] = 0 <NEWLINE> <NL> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> b [ a [ i ] ] += 1 <NEWLINE> <NL> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> print ( b [ i + 1 ] ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> boss_list = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> import collections <NEWLINE> c = collections . Counter ( boss_list ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> print ( boss_list [ i + 1 ] ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> works = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> print ( works . count ( i ) ) <NEWLINE> works . remove ( i ) <NEWLINE> <DEDENT>
from numba import jit <NEWLINE> import numpy as np <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> ansSet = set ( A ) <NEWLINE> <NL> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> if i in ansSet : <NEWLINE> <INDENT> print ( A . count ( i ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> <DEDENT>
EN = input ( ) . split ( ) <NEWLINE> Bc = [ 0 ] * int ( EN [ 0 ] ) <NEWLINE> <NL> tmp = input ( ) . split ( ) <NEWLINE> BossN = [ int ( s ) for s in tmp ] <NEWLINE> <NL> for i in tmp : <NEWLINE> <NL> <INDENT> Bc [ i - 1 ] = Bc [ i - 1 ] + 1 <NEWLINE> <NL> <DEDENT> print ( * Bc , sep = <STRING> ) <NEWLINE>
import collections <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = Collections . Counter ( A ) <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> print ( a [ i ] ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> def count ( n , a ) : <NEWLINE> <INDENT> c = 0 <NEWLINE> for i in range ( n + 1 ) : <NEWLINE> <INDENT> if a [ i ] == n : <NEWLINE> <INDENT> c += 1 <NEWLINE> <DEDENT> <DEDENT> return c <NEWLINE> <DEDENT> for j in range ( N ) : <NEWLINE> <INDENT> print ( count ( j + 1 , A ) ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> A = [ 0 ] * ( n + 1 ) <NEWLINE> A [ a ] += 0 for a in input ( ) . split ( ) <NEWLINE> <NL> for e in A [ 1 : ] : <NEWLINE> <INDENT> print ( e ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> ls = list ( map ( int , input ( ) ) ) <NEWLINE> anls = [ 0 ] * ( N + 1 ) <NEWLINE> for i in ls : <NEWLINE> <INDENT> anls [ i ] += 1 <NEWLINE> <DEDENT> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> print ( anls [ i ] ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a_list = map ( int input ( ) . split ( ) ) <NEWLINE> nl = { str ( i ) : 0 for i in range ( n ) } <NEWLINE> for a in a_list : <NEWLINE> <INDENT> nl [ str ( a - 1 ) ] += 1 <NEWLINE> <DEDENT> for v in nl . values ( ) : <NEWLINE> <INDENT> print ( <STRING> . format ( v ) ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c = [ ] * n <NEWLINE> for x in a : <NEWLINE> <INDENT> c [ x - 1 ] += 1 <NEWLINE> <DEDENT> for x in c : <NEWLINE> <INDENT> print ( x ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = [ 0 ] * n <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ans [ a [ i ] - 1 ] += 1 <NEWLINE> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> print ( ans [ i ] ) <NEWLINE> <DEDENT>
<NL> a = int ( input ( ) ) <NEWLINE> lists = list ( map ( int , input ( ) . split ( ) ) ) <COMMENT> <NEWLINE> <NL> num = [ 0 ] * a <NEWLINE> <NL> def mi ( x ) : <NEWLINE> <NL> <NL> <INDENT> return int ( x - 1 ) <NEWLINE> <NL> <DEDENT> y = list ( map ( mi , lists ) ) <NEWLINE> <NL> for i in range ( a ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <INDENT> num [ y [ i ] ] += 1 <NEWLINE> <DEDENT> for i in range ( a ) : <NEWLINE> <INDENT> print ( num [ i ] ) <NEWLINE> <NL> <DEDENT>
N = int ( input ( ) ) <NEWLINE> As = np . array ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> res = [ 0 ] * N <NEWLINE> for a in As : <NEWLINE> <INDENT> res [ a - 1 ] += 1 <NEWLINE> <DEDENT> for r in res : <NEWLINE> <INDENT> print ( r ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> buka = [ 0 ] * n <NEWLINE> for i in a : <NEWLINE> <INDENT> s [ i ] = s [ i ] + 1 <NEWLINE> <DEDENT> for i in buka : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> arr = [ 0 for i in range ( n ) ] <NEWLINE> for i in a : <NEWLINE> <INDENT> arr [ a - 1 ] += 1 <NEWLINE> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> print ( arr [ i ] ) <NEWLINE> <DEDENT>
ans = [ 0 ] * int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> for a in A : <NEWLINE> <INDENT> ans [ a ] += 1 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
import collections <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> ac = collections . Counter ( a ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> print ( a [ i + 1 ] ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) - 1 <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> r = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> r . append ( 0 ) <NEWLINE> r [ a [ i ] - 1 ] += 1 <NEWLINE> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> print ( r [ i ] ) <NEWLINE> <DEDENT> print ( 0 ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> x = A [ 0 ] * N <NEWLINE> for i in A : <NEWLINE> <INDENT> x [ i - 1 ] += 1 <NEWLINE> <DEDENT> for j in x : <NEWLINE> <INDENT> print ( j ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> print ( a . count ( i , 1 , i ) ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( int , input ( ) . split ( ) ) <NEWLINE> <NL> L = [ ] <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> L . append ( 0 ) <NEWLINE> <NL> <DEDENT> for i in range ( N - 1 ) : <NEWLINE> <INDENT> L [ A [ i ] ] += 1 <NEWLINE> <NL> <DEDENT> for j in range ( N - 1 ) : <NEWLINE> <INDENT> print ( L [ j ] ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> A = [ 0 for i in range ( n ) ] <NEWLINE> for aa in a : <NEWLINE> <INDENT> A [ a ] += 1 <NEWLINE> <DEDENT> for aa in A : <NEWLINE> <INDENT> print ( aa ) <NEWLINE> <DEDENT>
import collections <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ac = collections . Counter ( a ) <NEWLINE> <NL> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> print ( a [ i ] ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> lst = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> lst2 = [ 0 for i in range ( n ) ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> x = lst [ i ] <NEWLINE> lst2 [ x - 1 ] = lst2 [ x - 1 ] + 1 <NEWLINE> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> print ( lst2 [ i ] ) <NEWLINE> <DEDENT>
def resolve ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> woker = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> woker_count = collections . Counter ( woker ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> print ( woker_count [ i + 1 ] ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> resolve ( ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> from collections import defaultdict as ddict <NEWLINE> for n in range ( N - 1 ) : <NEWLINE> <INDENT> A . append ( int ( input ( ) ) ) <NEWLINE> <NL> <DEDENT> B = ddict ( int ) <NEWLINE> for a in A : <NEWLINE> <INDENT> B [ a - 1 ] += 1 <NEWLINE> <DEDENT> for n in range ( N ) : <NEWLINE> <INDENT> print ( B [ n ] ) <NEWLINE> <DEDENT>
from collections import Counter <NEWLINE> N = int ( input ( ) ) <NEWLINE> a = list ( input ( ) . split ( ) ) <NEWLINE> fact_count = Counter ( a ) <NEWLINE> for i in range ( 1 , N + 1 ) <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> print ( fact_count [ i ] ) <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> l = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> l . append ( 0 ) <NEWLINE> <DEDENT> for x in A : <NEWLINE> <INDENT> l ( x - 1 ) += 1 <NEWLINE> <DEDENT> for s in l : <NEWLINE> <INDENT> print ( s ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> m = input ( ) . split ( ) <NEWLINE> m = [ int ( i ) for i in m ] <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> l . append ( 0 ) <NEWLINE> <DEDENT> for i in m : <NEWLINE> <INDENT> ind = i - 1 <NEWLINE> l [ ind ] += 1 <NEWLINE> <DEDENT> for i in l : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT>
ar = [ 0 ] * n <NEWLINE> <NL> for i in range ( n - 1 ) : <NEWLINE> <INDENT> ar [ a [ i ] ] += 1 <NEWLINE> <NL> <DEDENT> tmp = ar . pop ( 0 ) <NEWLINE> ar . append ( tmp ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> print ( ar [ i ] ) <NEWLINE> <DEDENT>
import collection <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> count = collections . Counter ( A ) <NEWLINE> for n in range ( N ) : <NEWLINE> <INDENT> print ( count [ n + 1 ] ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> As = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = [ 0 for _ in range ( N ) ] <NEWLINE> <NL> for a in As <NEWLINE> <INDENT> ans [ a - 1 ] += 1 <NEWLINE> <NL> <DEDENT> print ( ans , sep = <STRING> ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input . split ( ) ) ) <NEWLINE> <NL> ans = [ 0 ] * N <NEWLINE> <NL> for i in A : <NEWLINE> <INDENT> ans [ i - 1 ] += 1 <NEWLINE> <NL> <DEDENT> for j in ans : <NEWLINE> <INDENT> print ( j ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> s = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> z = [ ] * n <NEWLINE> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> z [ s [ i ] - 1 ] += 1 <NEWLINE> <DEDENT> for j in range ( n ) : <NEWLINE> <INDENT> print ( z [ j ] ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> boss_list = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> <NL> boss_list = sorted ( boss_list ) <NEWLINE> <NL> <NL> for i in range ( 1 , n + 1 ) : <NEWLINE> <COMMENT> <NL> <INDENT> boss_count = 0 <NEWLINE> while ( True ) : <NEWLINE> <INDENT> index = 0 <NEWLINE> if boss_list [ index ] == i : <NEWLINE> <INDENT> boss_count += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> del boss_list [ : boss_count ] <NEWLINE> print ( boss_count ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> answer = [ 0 ] * n <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> answer [ a [ i ] ] += 1 <NEWLINE> <NL> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> print ( answer [ i ] ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) ) ) <NEWLINE> <NL> result = [ 0 ] * N <NEWLINE> <NL> for a in A : <NEWLINE> <INDENT> result [ a - 1 ] += 1 <NEWLINE> <NL> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> print ( result [ i ] ) <NEWLINE> <DEDENT>
import collections <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> <COMMENT> <NL> s = [ ] <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <COMMENT> <NL> <INDENT> s . append ( int ( input ( ) ) ) <NEWLINE> <NL> <DEDENT> ct = collections . Counter ( s ) <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> print ( ct [ i + 1 ] ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> jousi = { } <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> itmp = str ( i ) <NEWLINE> jousi [ itmp ] = 0 <NEWLINE> <DEDENT> for i in range ( N - 1 ) : <NEWLINE> <INDENT> atmp = str ( a [ i ] ) <NEWLINE> jousi [ atmp ] += 1 <NEWLINE> <DEDENT> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> print ( jousi [ str ( i ) ] ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = input ( ) . split ( ) <NEWLINE> A . insert ( 0 , 0 ) <NEWLINE> x = [ 0 ] * N <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> x [ A [ i ] - 1 ] += 1 <NEWLINE> <DEDENT> for j in range ( N ) : <NEWLINE> <INDENT> print ( x [ j ] ) <NEWLINE> <DEDENT>
from collections import Counter <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> s = mapt ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> data = Counter ( s ) <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> print ( data . get ( i , 0 ) ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> b = [ 0 ] * N <NEWLINE> for i in A : <NEWLINE> <INDENT> result [ i - 1 ] += 1 <NEWLINE> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> print ( b [ i ] ) <NEWLINE> <DEDENT>
s = list ( open ( 0 ) ) <NEWLINE> s = input ( ) <NEWLINE> <NL> j = [ 0 ] * int ( s ) <NEWLINE> <NL> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i in range ( int ( s ) - 1 ) : <NEWLINE> <INDENT> j [ a [ i ] ] += 1 <NEWLINE> <DEDENT> for i in range ( len ( j ) - 1 ) : <NEWLINE> <INDENT> print ( j [ ( i + 1 ) ] ) <NEWLINE> <NL> <DEDENT> print ( 0 ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> countlist = [ 0 for i in range ( n ) ] <NEWLINE> for j in range ( n ) : <NEWLINE> <INDENT> countlist [ a [ j ] - 1 ] += 1 <NEWLINE> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> print ( countlist [ i ] ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a_list = [ int ( i ) for i in input ( ) . split ( <STRING> ) ] <NEWLINE> <NL> c = collections . Counter ( a_list ) <NEWLINE> [ print ( c [ i + 1 ] ) for i in range ( n ) ] <NEWLINE>
N = int ( input ( ) ) <NEWLINE> emp = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> list . sort ( ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> print ( emp . index ( i + 2 ) - emp . index ( i + 1 ) ) <NEWLINE> <DEDENT>
def function ( n , list1 ) : <NEWLINE> <INDENT> ans = [ 0 ] * n <NEWLINE> for i in list1 : <NEWLINE> <INDENT> ans [ i - 1 ] += 1 <NEWLINE> <DEDENT> string = <STRING> <NEWLINE> for i in range ( len ( ans ) ) : <NEWLINE> <INDENT> if i < len ( ans ) - 1 : <NEWLINE> <INDENT> string += ans [ i ] + <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> string += ans [ i ] <NEWLINE> <DEDENT> <DEDENT> return string <NEWLINE> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> list1 = input ( ) . split ( ) <NEWLINE> list1 = [ int ( i ) for i in list1 ] <NEWLINE> print ( function ( n , list1 ) ) <NEWLINE>
import collections <NEWLINE> n = int ( input ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> cnt = collections . Counter ( A ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> print ( cnt [ i ] ) <NEWLINE> <DEDENT>
<INDENT> = int ( input ( ) ) <NEWLINE> <DEDENT> a_list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a_list = [ ( i + 2 , s ) for i , s in enumerate ( a_list ) ] <NEWLINE> a_list = sorted ( a_list , key = lambda x : x [ 1 ] ) <NEWLINE> count = 0 <NEWLINE> boss = 1 <NEWLINE> for a in a_list : <NEWLINE> <INDENT> if a [ 1 ] == boss : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> diff = a [ 1 ] - boss <NEWLINE> for _ in range ( diff ) : <NEWLINE> <INDENT> print ( count ) <NEWLINE> count = 0 <NEWLINE> <DEDENT> boss = a [ 1 ] <NEWLINE> count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> for _ in range ( N - a_list [ - 1 ] [ 1 ] + 1 ) : <NEWLINE> <INDENT> print ( count ) <NEWLINE> count = 0 <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> arr = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> ans = [ 0 for i in range ( n + 1 ) ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ans [ arr [ i ] - 1 ] += 1 <NEWLINE> <DEDENT> for i in ans : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT>
s = int ( input ( ) ) <NEWLINE> e_list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> m_list = [ ] <NEWLINE> for i in range ( 1 , s + 1 ) : <NEWLINE> <INDENT> m_list [ i ] = e_list . count ( i ) <NEWLINE> <NL> <DEDENT> for i in m_list : <NEWLINE> <INDENT> print ( m_list [ i ] ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> b = [ len ( i for i in a if i == j ) for j in range ( n + 1 ) ] <NEWLINE> print ( b [ 1 : ] ) <NEWLINE>
from sys import stdin <NEWLINE> import numpy as np <NEWLINE> N = list ( map ( int , ( stdin . readline ( ) . strip ( ) . split ( ) ) ) ) [ 0 ] <NEWLINE> A = list ( map ( int , ( stdin . readline ( ) . strip ( ) . split ( ) ) ) ) . sort ( ) <NEWLINE> moji = A [ 0 ] <NEWLINE> count = 1 <NEWLINE> i = 0 <NEWLINE> length = len ( A ) - 1 <NEWLINE> j = 0 <NEWLINE> sougou = 0 <NEWLINE> while ( i != length ) : <NEWLINE> <NL> <INDENT> if moji == A [ i + 1 ] : <NEWLINE> <INDENT> count += 1 <NEWLINE> i += 1 <NEWLINE> j += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> sougou += 1 <NEWLINE> print ( count ) <NEWLINE> count = 1 <NEWLINE> j = 1 <NEWLINE> i += 1 <NEWLINE> moji = A [ i ] <NEWLINE> <DEDENT> <DEDENT> if j >= 1 : <NEWLINE> <INDENT> sougou += 1 <NEWLINE> print ( count ) <NEWLINE> <DEDENT> for _ in range ( N - sougou ) : print ( 0 ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) ) ) <NEWLINE> <NL> out = [ 0 ] * n <NEWLINE> <NL> for aa in a : <NEWLINE> <INDENT> out [ a ] += 1 <NEWLINE> <NL> <DEDENT> for o in range ( len ( out ) ) : <NEWLINE> <INDENT> print ( o ) <NEWLINE> <DEDENT>
num = input ( ) <NEWLINE> hoge = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> count = 0 <NEWLINE> fuga = 0 <NEWLINE> <NL> for i in range ( 1 , len ( hoge ) ) : <NEWLINE> <INDENT> if hoge [ i ] != hoge [ i - 1 ] : <NEWLINE> <INDENT> print ( i - count ) <NEWLINE> fuga += 1 <NEWLINE> count = i <NEWLINE> if i == len ( hoge ) - 1 : <NEWLINE> <INDENT> print ( i + 1 - count ) <NEWLINE> fuga += 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if i == len ( hoge ) - 1 : <NEWLINE> <INDENT> print ( i + 1 - count ) <NEWLINE> fuga += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> for i in range ( fuga , num ) : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT>
a = [ 0 ] * int ( input ( ) ) <NEWLINE> for i in input ( ) . split ( ) : a [ int ( i ) - 1 ] += 1 <NEWLINE> for i in range ( N ) : print ( <STRING> ) <NEWLINE>
from collections import Counter <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ac = Counter ( a ) <NEWLINE> ad = list ( ac . values ( ) ) <NEWLINE> ad . sort ( ) <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> print ( ad [ i ] ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> s = [ 0 for _ in range ( n ) ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> s [ a [ i ] - 1 ] += 1 <NEWLINE> <DEDENT> for t in s : print ( t ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> id = [ 0 for _ in range ( n ) ] <NEWLINE> for i in range ( len ( a ) ) : <NEWLINE> <INDENT> id [ a [ i ] - 1 ] += 1 <NEWLINE> <NL> <DEDENT> for i in id : <NEWLINE> <INDENT> print ( i <NEWLINE> <DEDENT>
<COMMENT> <NL> from sys import stdin <NEWLINE> <NL> <NL> def solve ( tc ) : <NEWLINE> <INDENT> n = int ( stdin . readline ( ) . strip ( ) ) <NEWLINE> ai = list ( map ( int , stdin . readline ( ) . split ( ) ) ) <NEWLINE> <NL> adj = [ [ ] for i in range ( n ) ] <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> adj [ ai [ i ] - 1 ] . append ( i + 1 ) <NEWLINE> <NL> <DEDENT> for children in adj : <NEWLINE> <INDENT> print ( len ( children ) ) <NEWLINE> <NL> <NL> <NL> <DEDENT> <DEDENT> LOCAL_TEST = not __debug__ <NEWLINE> if LOCAL_TEST : <NEWLINE> <INDENT> infile = __file__ . split ( <STRING> ) [ 0 ] + <STRING> <NEWLINE> stdin = open ( infile , <STRING> ) <NEWLINE> <NL> <DEDENT> tcs = int ( stdin . readline ( ) . strip ( ) ) <NEWLINE> tc = 1 <NEWLINE> while tc <= tcs : <NEWLINE> <INDENT> solve ( tc ) <NEWLINE> tc += 1 <NEWLINE> <DEDENT>
import sys <NEWLINE> import os <NEWLINE> import math <NEWLINE> <NL> def file_input ( ) : <NEWLINE> <INDENT> f = open ( <STRING> , <STRING> ) <NEWLINE> sys . stdin = f <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> file_input ( ) <NEWLINE> <NL> N = [ 0 ] * int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in A : <NEWLINE> <INDENT> N [ i - 1 ] += 1 <NEWLINE> <NL> <DEDENT> for i in N : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> anss = [ 0 ] * n <NEWLINE> for _ in a : <NEWLINE> <INDENT> anss [ a - 1 ] += 1 <NEWLINE> <DEDENT> for ans in anss : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
<COMMENT> <NL> n = int ( input ( ) ) <NEWLINE> <NL> <COMMENT> <NL> a = ( int ( x ) for x in input ( ) . split ( ) ) <NEWLINE> <NL> <COMMENT> <NL> ans = [ 0 ] * n <NEWLINE> <NL> for i in range ( n - 1 ) : <NEWLINE> <INDENT> ans [ a [ i ] - 1 ] = ans [ a [ i ] - 1 ] + 1 <NEWLINE> <NL> <DEDENT> for i in ans : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A_list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans_list = [ 0 ] * ( N + 1 ) <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> ans_list [ A_list [ i ] ] += 1 <NEWLINE> <DEDENT> for j in range ( N + 1 ) : <NEWLINE> <INDENT> print ( ans_list [ j + 1 ] ) <NEWLINE> <DEDENT>
ninnzuu = ( int ) ( input ( ) ) <NEWLINE> joushi = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> buka = [ 0 for i in range ( ninnzuu ) ] <NEWLINE> for i in range ( 1 , ninnzuu + 1 ) : <NEWLINE> <INDENT> buka [ joushi [ i ] - 1 ] += 1 <NEWLINE> <DEDENT> for i in range ( ninnzuu ) : <NEWLINE> <INDENT> print ( buka [ i ] ) <NEWLINE> <DEDENT>
<INDENT> - * - coding : utf - 8 - * - <NEWLINE> <NL> <DEDENT> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> sheet = [ 0 ] * ( N ) <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> sheet [ A [ i ] - 1 ] = sheet [ A [ i ] - 1 ] + 1 <NEWLINE> <NL> <NL> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> print ( <STRING> . format ( sheet [ i ] ) ) <NEWLINE> <DEDENT>
M = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = collections . Counter ( A ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> num = 1 <NEWLINE> <NL> while num <= M : <NEWLINE> <INDENT> print ( B [ num ] ) <NEWLINE> num += 1 <NEWLINE> <DEDENT>
from collections import Counter <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> s = Counter ( a ) <NEWLINE> for v in s . values ( ) : <NEWLINE> <INDENT> print ( v ) <NEWLINE> <DEDENT> for i in range ( n - len ( ans ) ) : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <NL> <DEDENT>
A = input ( ) . split ( ) <NEWLINE> N = int ( A [ 0 ] ) <NEWLINE> del A [ 0 ] <NEWLINE> B = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> B . append ( 0 ) <NEWLINE> <DEDENT> for i in range ( N - 1 ) : <NEWLINE> <INDENT> B [ int ( A [ i ] ) - 1 ] += 1 <NEWLINE> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> print ( B [ i ] ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> result = [ 0 ] * N <NEWLINE> for a in A : <NEWLINE> <INDENT> result [ a - 1 ] += 1 <NEWLINE> <DEDENT> print ( <STRING> . join ( result ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> jyoshi = [ 0 ] * n <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> jyo = a [ i ] <NEWLINE> jyoshi [ jyo - 1 ] = jyoshi [ jyo - 1 ] + 1 <NEWLINE> <NL> <DEDENT> for k in jyoshi : <NEWLINE> <INDENT> print k <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> D = { i : [ ] for i in range ( N ) } <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> D [ i ] . append ( A [ i ] - 1 ) <NEWLINE> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> print ( len ( D [ i ] ) ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = [ 0 ] * N <NEWLINE> for i in [ int ( s ) for s in input ( ) . split ( ) ] : <NEWLINE> <INDENT> A [ i - 1 ] += 1 <NEWLINE> <NL> <DEDENT> for j in range ( N + 1 ) : <NEWLINE> <INDENT> print ( A [ j ] ) <NEWLINE> <DEDENT>
10 <NEWLINE> 1 1 1 1 1 1 1 1 1 <NEWLINE>
def management ( N , array ) : <NEWLINE> <INDENT> res = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> res [ array [ i ] ] += 1 <NEWLINE> for j in range ( len ( res ) ) : <NEWLINE> print ( res [ j ] ) <NEWLINE> <NL> <NL> <NL> <DEDENT> <DEDENT> N = int ( input ( ) ) <NEWLINE> array = list ( map ( int , input ( ) . split ( ) ) <NEWLINE> managememt ( N , array ) ) <NEWLINE>
import numpy as np <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = np . array ( input ( ) . split ( ) ) <NEWLINE> buka = [ 0 for i in range ( n ) ] <NEWLINE> <NL> for i in a : <NEWLINE> <INDENT> buka [ i ] += 1 <NEWLINE> <NL> <DEDENT> for i in buka : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> <NL> <NL> if __name__ == <STRING> : <NEWLINE> <INDENT> List = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( 2 ) ] <NEWLINE> N = List [ 0 ] [ 0 ] <NEWLINE> buka = np . array ( List [ 1 ] [ : ] ) <NEWLINE> <NL> <NL> l_out = np . zeros ( N , dtype = int ) <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> l_out [ buka [ i ] - 1 ] += 1 <NEWLINE> <NL> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> print ( l_out [ i ] ) <NEWLINE> <NL> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = [ - 1 , - 1 ] + list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> cnt = [ 0 ] * ( n + 1 ) <NEWLINE> for i in range ( 2 , n + 1 ) : <NEWLINE> <INDENT> cnt [ a [ i ] += 1 <NEWLINE> <NL> <DEDENT> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> print ( cnt [ i ] ) <NEWLINE> <DEDENT>
<INDENT> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> from collections import Counter <NEWLINE> x = Counter ( a ) <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> print ( x [ i ] ) <NEWLINE> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = [ 0 ] * n <NEWLINE> for i in A : <NEWLINE> <INDENT> ans [ i - 1 ] += 1 <NEWLINE> <DEDENT> for j in ans : <NEWLINE> <INDENT> print ( j ) <NEWLINE> <DEDENT>
<NL> from collections import Counter <NEWLINE> def resolve ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> C = Counter ( A ) <NEWLINE> <NL> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> print ( C [ i ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> unittest . main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> t = [ 0 ] * ( n + 1 ) <NEWLINE> l = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> for i in range ( 2 , n + 1 ) : <NEWLINE> <INDENT> t [ l [ i ] ] += 1 <NEWLINE> <DEDENT> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> print ( t [ i ] ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> s = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> t = [ ] <NEWLINE> cnt = 2 <NEWLINE> for a in s : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> t [ a - 1 ] . append ( cnt ) <NEWLINE> <DEDENT> except IndexError : <NEWLINE> <INDENT> for _ in range ( a - len ( t ) ) : <NEWLINE> <INDENT> t . append ( [ ] ) <NEWLINE> t [ - 1 ] . append ( cnt ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> for i in range ( n - 1 ) : <NEWLINE> <INDENT> print ( len ( t [ i ] ) ) <NEWLINE> <DEDENT> print ( 0 ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> dp = [ 0 ] * n <NEWLINE> <NL> for i in a : <NEWLINE> <INDENT> b [ i - 1 ] += 1 <NEWLINE> <NL> <DEDENT> for _ in b : <NEWLINE> <INDENT> print ( _ ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> buka = [ 0 ] * n <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> buka [ int ( input ( ) ) - 1 ] += 1 <NEWLINE> <DEDENT> print ( * buka , sep = <STRING> ) <NEWLINE>
import numpy as np <NEWLINE> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> n = N - np . sum ( A ) <NEWLINE> if ( n >= 0 ) : <NEWLINE> <INDENT> print ( n ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT>
B = { } <COMMENT> <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> for i in range ( N ) : <NEWLINE> <COMMENT> <NL> print ( B ) <NEWLINE> for j in A : <NEWLINE> <COMMENT> <NL> print ( B ) <NEWLINE> for k in B . values ( ) : <NEWLINE> <INDENT> print ( k ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> N = int ( input ( ) ) <NEWLINE> A_list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> index = np . arange ( 1 , N + 1 ) <NEWLINE> ans = [ <STRING> . format ( i ) for A_list . count ( i ) in range ( 1 , N + 1 ) ] <NEWLINE> print ( ans ) <NEWLINE>
from collections import deafualtdict <NEWLINE> n = int ( input ( ) ) <NEWLINE> ar = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> d = defaultdict ( int ) <NEWLINE> for i in ar : <NEWLINE> <INDENT> d [ i ] += 1 <NEWLINE> <DEDENT> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if i in d . keys ( ) : <NEWLINE> <INDENT> print ( d [ i ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> <DEDENT>
<INDENT> n = int ( input ( ) ) <NEWLINE> <INDENT> boss = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> mem = list ( range ( 1 , n + 1 ) ) <NEWLINE> h_map = dict . fromkeys ( mem , 0 ) <NEWLINE> for i in boss : <NEWLINE> <INDENT> h_map [ i ] += 1 <NEWLINE> <DEDENT> for i in mem : <NEWLINE> <INDENT> print ( h_map [ i ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> n = [ 0 ] * N <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> n [ A [ i ] - 1 ] += 1 <NEWLINE> <NL> <DEDENT> for j in range ( N ) : <NEWLINE> <INDENT> print ( n [ j ] ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> num_subordinates = [ 0 for _ in N ] <NEWLINE> for a in A : <NEWLINE> <INDENT> + + num_subordinates [ a ] <NEWLINE> <NL> <DEDENT> for n in num_subordinates : <NEWLINE> <INDENT> print ( n ) <NEWLINE> <DEDENT>
import sys <NEWLINE> import math <NEWLINE> import re <NEWLINE> from collections import deque , defaultdict , Counter <NEWLINE> from math import ceil , sqrt , hypot , factorial , pi , sin , cos , radians <NEWLINE> from itertools import accumulate , permutations , combinations , product <NEWLINE> from operator import itemgetter , mul <NEWLINE> from copy import deepcopy <NEWLINE> from string import ascii_lowercase , ascii_uppercase , digits <NEWLINE> from bisect import bisect , bisect_left <NEWLINE> from fractions import gcd <NEWLINE> from heapq import heappush , heappop <NEWLINE> from functools import reduce <NEWLINE> import numpy as np <NEWLINE> from scipy . sparse . csgraph import shortest_path , floyd_warshall , dijkstra , bellman_ford , johnson <NEWLINE> from scipy . sparse import csr_matrix <NEWLINE> import itertools <NEWLINE> def input ( ) : return sys . stdin . readline ( ) . strip ( ) <NEWLINE> def INT ( ) : return int ( input ( ) ) <NEWLINE> def MAP ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def LIST ( ) : return list ( map ( str , input ( ) . split ( ) ) ) <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> INF = float ( <STRING> ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> N = INT ( ) <NEWLINE> A = LIST ( ) <NEWLINE> A = sorted ( A ) <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> count = 0 <NEWLINE> for j in range ( i , N - 1 ) : <NEWLINE> <INDENT> if int ( A [ j ] ) == i + 1 : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = [ 0 ] * N <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> ans [ A [ i ] - 1 ] += 1 <NEWLINE> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> print ( ans [ i ] ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> <NL> n = input ( ) <NEWLINE> a = np . array ( [ int ( i ) for i in input ( ) . split ( ) ] ) <NEWLINE> for i in range ( int ( n ) ) : <NEWLINE> <INDENT> print ( a . count ( i + 1 ) ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = a . sort ( ) <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> print ( a . count ( i ) ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> l = [ 0 ] * N <NEWLINE> for i in range ( N + 1 ) : <NEWLINE> <INDENT> l [ A [ i ] - 1 ] += 1 <NEWLINE> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> print ( l [ i ] ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> arr = [ 0 ] * N <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> A = int ( input ( ) ) <NEWLINE> arr [ A - 1 ] += 1 <NEWLINE> <DEDENT> for i in range ( 0 , N ) : <NEWLINE> <INDENT> print ( arr [ i ] ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = [ 0 ] * N <NEWLINE> for a in A : <NEWLINE> <INDENT> ans [ a - 1 ] += 1 <NEWLINE> <DEDENT> for n in ans : <NEWLINE> print ( n ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> lst = [ ] <NEWLINE> <NL> for i in range ( 1 , max ( a ) + 1 ) : <NEWLINE> <INDENT> count = a . count ( i ) <NEWLINE> lst . append ( count ) <NEWLINE> <DEDENT> lst . append ( 0 ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> print ( lst [ i ] ) <NEWLINE> <DEDENT>
import math <NEWLINE> def main ( ) : <NEWLINE> <INDENT> N = map ( int , input ( ) ) <NEWLINE> l = [ int ( _ ) for _ in input ( ) . split ( ) ] <NEWLINE> count_list = [ 0 ] * N <NEWLINE> for i in l : <NEWLINE> <INDENT> index = i - 1 <NEWLINE> count_list [ index ] += 1 <NEWLINE> <NL> <DEDENT> for out in count_list : <NEWLINE> <INDENT> print ( out + <STRING> ) <NEWLINE> <DEDENT> <DEDENT> main ( ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> import sys <NEWLINE> import math <NEWLINE> import bisect <NEWLINE> from fractions import gcd <NEWLINE> from itertools import count , permutations <NEWLINE> from functools import lru_cache <NEWLINE> from collections import deque , defaultdict <NEWLINE> from pprint import pprint <NEWLINE> <NL> INF = float ( <STRING> ) <NEWLINE> <NL> ii = lambda : int ( input ( ) ) <NEWLINE> mis = lambda : map ( int , input ( ) . split ( ) ) <NEWLINE> lmis = lambda : list ( mis ( ) ) <NEWLINE> lmtx = lambda h : [ list ( map ( int , lmis ( ) ) ) for _ in range ( h ) ] <NEWLINE> sys . setrecursionlimit ( 1000000000 ) <NEWLINE> <NL> <NL> def lcm ( a , b ) : <NEWLINE> <INDENT> return ( a * b ) // gcd ( a , b ) <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> n = ii ( ) <NEWLINE> alist = lmis ( ) <NEWLINE> <NL> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> print ( str ( alist . count ( i ) ) ) <NEWLINE> <DEDENT>
A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> l = [ 0 ] * int ( input ( ) ) <NEWLINE> for i in A : <NEWLINE> <INDENT> l [ i - 1 ] += 1 <NEWLINE> <DEDENT> print ( * l ) <NEWLINE>
<COMMENT> <NL> n = int ( input ( ) ) <NEWLINE> a = input ( ) . split ( ) <NEWLINE> lis = [ 0 for i in range ( n ) ] <NEWLINE> count = 0 <NEWLINE> <NL> for i in a : <NEWLINE> <INDENT> lis [ int ( i - 1 ) ] += 1 <NEWLINE> <NL> <DEDENT> for i in lis : <NEWLINE> <INDENT> print ( <STRING> . format ( i ) ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = [ None for _ in range ( N ) ] <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> B [ i ] = A . count ( i ) <NEWLINE> <DEDENT> for j in range ( N ) : <NEWLINE> <INDENT> print ( B [ j ] ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> answer = [ 0 ] * n <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> answer [ a [ i ] - 1 ] += 1 <NEWLINE> <NL> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> print ( answer [ i ] ) <NEWLINE> <DEDENT>
N = input ( ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> result = [ 0 ] * N <NEWLINE> <NL> for i in range ( N - 1 ) : <NEWLINE> <INDENT> result [ A [ i ] - 1 ] += 1 <NEWLINE> <NL> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> print ( result [ i ] ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> num = [ 0 ] * n <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> for i in range ( 0 , n - 1 ) : <NEWLINE> <INDENT> num [ A [ i ] ] += 1 <NEWLINE> <NL> <DEDENT> for k in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> print ( num [ k ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> main ( ) <NEWLINE>
<INDENT> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> if n < k : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> exit ( 0 ) <NEWLINE> <NL> <DEDENT> MOD = pow ( 10 , 9 ) + 7 <NEWLINE> count = 0 <NEWLINE> while n + 1 >= k : <NEWLINE> <INDENT> minv = k * ( k - 1 ) // 2 <NEWLINE> maxv = ( ( n + 1 ) * n // 2 ) - ( ( n - k ) * ( n - k + 1 ) // 2 ) <NEWLINE> <NL> count += ( maxv - minv + 1 ) <NEWLINE> count %= MOD <NEWLINE> k += 1 <NEWLINE> <NL> <DEDENT> print ( count ) <NEWLINE> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> import math <NEWLINE> import itertools <NEWLINE> <NL> <NL> <NL> def cal ( num , r , count ) : <NEWLINE> <NL> <INDENT> for v in itertools . combinations ( range ( num ) , r ) : <NEWLINE> <INDENT> count [ sum ( v ) ] += 1 <NEWLINE> <DEDENT> real_count = 0 <NEWLINE> for i in count : <NEWLINE> <INDENT> if i > 0 : <NEWLINE> <INDENT> real_count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> return real_count <NEWLINE> <NL> <DEDENT> total = 0 <NEWLINE> while K <= N + 1 : <NEWLINE> <INDENT> count = [ 0 ] * 1000000000 <NEWLINE> total += cal ( N + 1 , K , count ) <NEWLINE> K += 1 <NEWLINE> <NL> <DEDENT> total = total % ( 10 ** 9 + 7 ) <NEWLINE> print ( total ) <NEWLINE>
import math . fact <NEWLINE> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> def combination_mod ( n , r , mod ) : <NEWLINE> <INDENT> if ( r < 0 ) or ( n < r ) : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> r = min ( r , n - r ) <NEWLINE> return fact [ n ] * factinv [ r ] * factinv [ n - r ] % mod <NEWLINE> <NL> <DEDENT> mod = 10 ** 9 + 7 <NEWLINE> fact = [ 1 , 1 ] <NEWLINE> factinv = [ 0 , 1 ] <NEWLINE> inv = [ 0 , 1 ] <NEWLINE> total = 0 <NEWLINE> <NL> for i in range ( 2 , N + 1 ) : <NEWLINE> <INDENT> fact . append ( ( fact [ - 1 ] * i ) % mod ) <NEWLINE> inv . append ( ( - inv [ mod % i ] * ( mod // i ) ) % mod ) <NEWLINE> factinv . append ( ( factinv [ - 1 ] * inv [ - 1 ] ) % mod ) <NEWLINE> <NL> <DEDENT> for i in range ( K , N + 1 ) : <NEWLINE> <INDENT> total += combination_mod ( N , i , mod ) % mod <NEWLINE> <NL> <DEDENT> print ( total ) <NEWLINE>
def main ( N = None , K = None ) : <NEWLINE> <INDENT> if not N : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> K = int ( input ( ) ) <NEWLINE> <DEDENT> ans = ( K - N - 2 ) * ( 2 * K * K - K * ( N + 2 ) - N * N - N - 6 ) // 6 <NEWLINE> ans %= 10 ** 9 + 7 <NEWLINE> print ( ans ) <NEWLINE> return ans <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <INDENT> main ( ) <NEWLINE> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> premin = 0 <NEWLINE> premax = 0 <NEWLINE> ans = 0 <NEWLINE> list = [ i for i in range ( n + 1 ) ] <NEWLINE> for x in range ( n + 2 ) : <NEWLINE> <INDENT> premin = sum ( list [ x ] ) <NEWLINE> premax = sum ( list [ n + 1 - x ] ) <NEWLINE> if x < k : continue <NEWLINE> ans += ( premax - premin + 1 ) <NEWLINE> if ans >= mod : ans %= mod <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
mod = 10 ** 9 + 7 <NEWLINE> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> for i in range ( k , n + 1 ) : <NEWLINE> <INDENT> ans += i * ( n - i + 1 ) <NEWLINE> ans %= MOD <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE> <NL>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( 1 , N + 2 ) : <NEWLINE> <INDENT> saisyo += i - 1 <NEWLINE> saidai += N - i + 1 <NEWLINE> if i >= K : <NEWLINE> <INDENT> ans += ( saidai - saisyo + 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans % ( 10 ** 9 + 7 ) ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <COMMENT> <NL> <NL> <NL> def calc ( x ) : <NEWLINE> <INDENT> a = x * ( x - 1 ) // 2 <NEWLINE> b = ( 2 N - x + 1 ) * x // 2 <NEWLINE> return a - b + 1 <NEWLINE> <NL> <NL> <DEDENT> for i in range ( K , N + 2 ) : <NEWLINE> <INDENT> ans = calc ( i ) <NEWLINE> tot = += ans <NEWLINE> <NL> <DEDENT> tot /= 10 ** 9 + 7 <NEWLINE> <NL> print ( tot ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> n = [ i for i in range ( N + 1 ) ] <NEWLINE> mod = 10 ** 9 + 7141421 35623 <NEWLINE> <NL> min_value = [ 0 ] * ( N + 1 ) <NEWLINE> max_value = [ 0 ] * ( N + 1 ) <NEWLINE> min_value [ 0 ] = 0 <NEWLINE> max_value [ 0 ] = N <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> min_value [ i ] = min_value [ i - 1 ] + n [ i ] <NEWLINE> max_value [ i ] = max_value [ i - 1 ] + n [ - ( i + 1 ) ] <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in range ( K - 1 , N + 1 ) : <NEWLINE> <INDENT> ans += max_value [ i ] - min_value [ i ] + 1 <NEWLINE> ans %= mod <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> cnt = [ 0 ] * ( N - K + 2 ) <NEWLINE> <NL> cnt_all = 0 <NEWLINE> mod = 1000000007 <NEWLINE> <NL> for i in range ( K , N + 2 ) : <NEWLINE> <INDENT> cnt [ i ] = i * N - i * ( i - 1 ) + 1 <NEWLINE> <NL> <DEDENT> for i in range ( N - K + 2 ) : <NEWLINE> <INDENT> cnt_all += cnt [ i ] <NEWLINE> <NL> <DEDENT> print ( cnt_all % mod ) <NEWLINE>
MOD = 10 ** 9 + 7 <NEWLINE> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> def calc ( a ) : <NEWLINE> <INDENT> smallest = a * ( a - 1 ) / 2 <NEWLINE> largest = smallest + a * ( n - a + 1 ) <NEWLINE> return latgest - smallest + 1 <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for a in range ( k , n + 2 ) : <NEWLINE> <INDENT> ans += calc ( a ) <NEWLINE> ans %= MOD <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> using namespace std ; <NEWLINE> <NL> const int MOD = 1000000007 ; <NEWLINE> int main ( ) { <NEWLINE> <INDENT> long long N , K ; <NEWLINE> cin >> N >> K ; <NEWLINE> long long M = N + 1 , L = K - 1 ; <NEWLINE> long long res = M * ( M * M + 5 ) / 6 + L * ( L * L * 2 + L * 3 - 5 - M * ( L + 1 ) * 3 ) / 6 ; <NEWLINE> cout << res % MOD << endl ; <NEWLINE> <DEDENT> } <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = 0 <NEWLINE> <NL> for i in range ( k , n + 2 ) : <NEWLINE> <INDENT> a = 0.5 * i * ( i - 1 ) <NEWLINE> b = 0.5 * n * ( n + 1 ) - 0.5 * ( n - i ) * ( n - i + 1 ) <NEWLINE> ans += int ( b - a + 1 ) <NEWLINE> <NL> <DEDENT> print ( ans % ( 10 ** 9 + 7 ) <NEWLINE>
import numpy as np <NEWLINE> import functools <NEWLINE> import math <NEWLINE> import collections <NEWLINE> import scipy <NEWLINE> import fractions <NEWLINE> import itertools <NEWLINE> <NL> def solve ( ) : <NEWLINE> <INDENT> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> small = 0 <NEWLINE> large = 0 <NEWLINE> ans = 0 <NEWLINE> for i in range ( 0 , n + 1 ) : <NEWLINE> <INDENT> small += i <NEWLINE> large += n - i <NEWLINE> if i + 1 >= k : <NEWLINE> <INDENT> ans = ( ans + ( large - small + 1 ) ) % mod <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> return 0 <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> solve ( ) <NEWLINE> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = 0 <NEWLINE> temp_max = N <NEWLINE> temp_min = 0 <NEWLINE> for i in range ( K , N + 2 ) : <NEWLINE> <INDENT> temp_max += N - i + 1 <NEWLINE> temp_min += i - 1 <NEWLINE> ans += temp_max - temp_min + 1 <NEWLINE> <DEDENT> print ( ans % ( 10 ** 9 + 7 ) <NEWLINE>
from heapq import heappush , heappop <NEWLINE> from itertools import permutations , accumulate , combinations <NEWLINE> import math <NEWLINE> import bisect <NEWLINE> import numpy as np <NEWLINE> from collections import defaultdict , deque <NEWLINE> from operator import itemgetter <NEWLINE> import sys <NEWLINE> <NL> input = sys . stdin . readline <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( k , n + 2 ) : <NEWLINE> <INDENT> ans += i * ( n - i + 1 ) + 1 <NEWLINE> <DEDENT> print ( ans % MOD ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> s = 0 <NEWLINE> <NL> for i in range ( K , N + 2 ) : <NEWLINE> <INDENT> s += i * N + 1 - i * ( i - 1 ) <NEWLINE> <NL> <DEDENT> print ( s % ( 10 ** 9 + 7 ) ) <NEWLINE>
N , K = map ( int , input . split ( ) ) <NEWLINE> x = 100000007 <NEWLINE> <NL> A = ( N - 1 ) * N * ( N + 1 ) // 2 <NEWLINE> B = N * ( N + 1 ) * ( 2 * N + 1 ) // 6 <NEWLINE> C = N * K * ( K + 1 ) // 2 <NEWLINE> D = ( K - 1 ) * K * ( K + 1 ) // 3 <NEWLINE> <NL> Ans = ( A - B - C + D ) % x <NEWLINE> <NL> print ( Ans ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> total = 0 <NEWLINE> for i in range ( k , n + 2 ) : <NEWLINE> <INDENT> total += i ( n + 1 - i ) + 1 <NEWLINE> total %= 10 ** 9 + 7 <NEWLINE> <DEDENT> print ( total ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> wa = 0 <NEWLINE> for i in range ( N + 1 - k + 1 ) : <NEWLINE> <INDENT> n = i + K <NEWLINE> min = ( n ) * ( 0 + n - 1 ) / 2 <NEWLINE> max = ( n ) * ( N - n + 1 + N ) / 2 <NEWLINE> <NL> wa = max - min + wa <NEWLINE> <NL> <DEDENT> print ( wa ) <NEWLINE>
n , k , s = list ( map ( int , input ( ) . split ( ) ) ) , 0 <NEWLINE> for i in range ( k , n + 2 ) : <NEWLINE> <INDENT> s += i * ( n + n - ( i - 1 ) ) // 2 + 1 - ( i * ( i - 1 ) ) // 2 <NEWLINE> <DEDENT> print ( s % ( 1000000007 ) ) <NEWLINE>
n , k = ( int ( x ) for x in input ( ) . split ( ) ) <NEWLINE> for i in range ( k , n + 2 ) : <NEWLINE> <INDENT> base = n * i - ( i * ( i - 1 ) ) + 1 <NEWLINE> <COMMENT> <NL> res = res + base <NEWLINE> <NL> <DEDENT> resu = res % 1000000007 <NEWLINE> <NL> print ( resu ) <NEWLINE>
from math import factorial <NEWLINE> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> def count ( x , y ) : <NEWLINE> <INDENT> a = factorial ( x ) / factorial ( y ) / factorial ( x - y ) <NEWLINE> return a <NEWLINE> <NL> <DEDENT> if ( a + 1 == b ) : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> count = 0 <NEWLINE> for i in range ( a - b + 2 ) : <NEWLINE> <INDENT> count += count ( a , i + b ) <NEWLINE> <DEDENT> print ( count ) <NEWLINE> <DEDENT>
N = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> N = NK [ 0 ] ; K = NK [ 1 ] <NEWLINE> <NL> result = 0 <NEWLINE> for i in range ( K , N + 2 ) : <NEWLINE> <INDENT> result += i * ( N - i + 1 ) + 1 <NEWLINE> <NL> <DEDENT> print ( result ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = [ 0 ] * n <NEWLINE> <NL> for i in l : <NEWLINE> <INDENT> ans [ i - 1 ] += 1 <NEWLINE> <NL> <DEDENT> for j in ans : <NEWLINE> <INDENT> print ( j ) <NEWLINE> <DEDENT>
mport itertools <NEWLINE> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> l = list ( range ( n + 1 ) ) <NEWLINE> ad = 0 <NEWLINE> for i in list ( range ( k , n + 2 ) ) : <NEWLINE> <INDENT> l2 = list ( itertools . combinations ( l , r = i ) ) <NEWLINE> se = set ( map ( sum , l2 ) ) <NEWLINE> ad += len ( se ) <NEWLINE> <DEDENT> print ( ad ) <NEWLINE>
def i1str ( ) : <NEWLINE> <INDENT> return input ( ) <NEWLINE> <NL> <NL> <DEDENT> def istrs ( n = None ) : <NEWLINE> <INDENT> if n is None : <NEWLINE> <INDENT> return input ( ) . split ( ) <NEWLINE> <DEDENT> a = [ ] <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> a . append ( istrs ( ) ) <NEWLINE> <DEDENT> return a <NEWLINE> <NL> <NL> <DEDENT> def i1num ( ) : <NEWLINE> <INDENT> return int ( input ( ) ) <NEWLINE> <NL> <NL> <DEDENT> def inums ( n = None ) : <NEWLINE> <INDENT> if n is None : <NEWLINE> <INDENT> return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <DEDENT> a = [ ] <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> a . append ( inums ( ) ) <NEWLINE> <DEDENT> return a <NEWLINE> <NL> <NL> <DEDENT> def ostrs ( l , sp = <STRING> ) : <NEWLINE> <INDENT> print ( sp . join ( l ) ) <NEWLINE> <NL> <NL> <DEDENT> def onums ( l , sp = <STRING> ) : <NEWLINE> <INDENT> print ( sp . join ( map ( str , l ) ) ) <NEWLINE> <NL> <NL> <DEDENT> def solve ( n , aii ) : <NEWLINE> <INDENT> dp = [ [ 0 for _ in range ( n + 1 ) ] for _ in range ( n + 1 ) ] <NEWLINE> <NL> for x in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> ai , i = aii [ x - 1 ] <NEWLINE> dp [ x ] [ 0 ] = dp [ x - 1 ] [ 0 ] + ai * ( i - x + 1 ) <NEWLINE> dp [ 0 ] [ x ] = dp [ 0 ] [ x - 1 ] + ai * ( n - x - i ) <NEWLINE> <NL> <DEDENT> for s in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> for x in range ( 1 , s ) : <NEWLINE> <INDENT> y = s - x <NEWLINE> ai , i = aii [ s - 1 ] <NEWLINE> dp [ x ] [ y ] = max ( dp [ x - 1 ] [ y ] + ai * ( i - x + 1 ) , <NEWLINE> <INDENT> dp [ x ] [ y - 1 ] + ai * ( n - y - i ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> res = 0 <NEWLINE> for x in range ( n + 1 ) : <NEWLINE> <INDENT> if dp [ x ] [ n - x ] > res : <NEWLINE> <INDENT> res = dp [ x ] [ n - x ] <NEWLINE> <DEDENT> <DEDENT> return res <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> n = i1num ( ) <NEWLINE> a = inums ( ) <NEWLINE> aii = sorted ( [ ( a [ i ] , i ) for i in range ( n ) ] , reverse = True ) <NEWLINE> print ( solve ( n , aii ) ) <NEWLINE> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> a = 1 <NEWLINE> for i in range ( k , n + 1 ) : <NEWLINE> <INDENT> mmin = summ ( i - 1 ) <NEWLINE> mmax = summ ( n , n - i ) <NEWLINE> m = mmax - mmin + 1 <NEWLINE> a += m <NEWLINE> <NL> <DEDENT> k = 10 ** 9 + 7 <NEWLINE> print ( int ( a % k ) ) <NEWLINE> <NL> <NL> def summ ( n , nn = 0 ) : <NEWLINE> <INDENT> nn = max ( nn , 0 ) <NEWLINE> return n * ( n + 1 ) / 2 - nn * ( nn + 1 ) / 2 <NEWLINE> <DEDENT>
S = input ( ) <NEWLINE> l = len ( S ) <NEWLINE> <NL> a = 0 <NEWLINE> count = 0 <NEWLINE> <NL> for i in range ( l ) : <NEWLINE> <INDENT> a = int ( S [ l - i - 1 ] ) <NEWLINE> for j in range ( i + 1 , l ) : <NEWLINE> <INDENT> if int ( S [ l - j - 1 ] ) != 0 : <NEWLINE> <INDENT> a += int ( S [ l - j - 1 ] ) * 10 ** ( j - i ) <NEWLINE> if j - i > 2 : <NEWLINE> <INDENT> if a % 2019 == 0 : <NEWLINE> <INDENT> count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> c = 0 <NEWLINE> for i in range ( K , N + 1 + 1 ) : <NEWLINE> <INDENT> ma = ( ( N + N - ( i - 1 ) ) * i ) / 2 <NEWLINE> mi = ( ( 0 + i - 1 ) * i ) / 2 <NEWLINE> c += int ( ma - mi + 1 ) <NEWLINE> c %= ( 10 ** 9 + 7 ) <NEWLINE> <DEDENT> print ( c ) <NEWLINE>
<COMMENT> <NL> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <COMMENT> <NL> answer = 0 <NEWLINE> for i in range ( K , N + 2 ) : <NEWLINE> <INDENT> answer += ( ( N * ( N + 1 ) // 2 ) - ( ( N - i ) * ( N - i + 1 ) // 2 ) - ( i * ( i - 1 ) // 2 ) + 1 ) % mod <NEWLINE> <NL> <DEDENT> print ( answer % mod ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> import sys <NEWLINE> from io import StringIO <NEWLINE> import unittest <NEWLINE> <NL> mod = 10 ** 9 + 7 <NEWLINE> <NL> def modinv ( a , mod ) : <NEWLINE> <INDENT> return pow_mod ( a , mod - 2 , mod ) <NEWLINE> <NL> <DEDENT> def pow_mod ( a , b , mod ) : <NEWLINE> <INDENT> x = 1 <NEWLINE> while b > 0 : <NEWLINE> <INDENT> if b & 1 : <NEWLINE> <INDENT> x = ( x * a ) % mod <NEWLINE> <DEDENT> a = ( a ** 2 ) % mod <NEWLINE> b //= 2 <NEWLINE> <NL> <DEDENT> return x <NEWLINE> <NL> <DEDENT> def comb ( n , r , mod ) : <NEWLINE> <INDENT> combsum = 1 <NEWLINE> for i in range ( n - r + 1 , n + 1 ) : <NEWLINE> <INDENT> combsum = ( combsum * i ) % mod <NEWLINE> <DEDENT> for i in range ( 1 , r + 1 ) : <NEWLINE> <INDENT> combsum = ( combsum * inv [ i ] ) % mod <NEWLINE> <DEDENT> return combsum <NEWLINE> <NL> <DEDENT> inv = [ modinv ( i , mod ) for i in range ( 0 , 2 * 10 ** 5 ) ] <NEWLINE> <NL> def yn ( b ) : <NEWLINE> <INDENT> print ( <STRING> if b == 1 else <STRING> ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> def resolve ( ) : <NEWLINE> <INDENT> readline = sys . stdin . readline <NEWLINE> <NL> n , k = map ( int , readline ( ) . rstrip ( ) . split ( ) ) <NEWLINE> <NL> a = 0 <NEWLINE> z = 0 <NEWLINE> ans = 0 <NEWLINE> n += 1 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> a += i <NEWLINE> z += ( n - i + 1 ) <NEWLINE> cnt = z - a + 1 <NEWLINE> if i >= k : <NEWLINE> <INDENT> ans += cnt <NEWLINE> ans %= mod <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> return <NEWLINE> <NL> <DEDENT> if <STRING> not in globals ( ) : <NEWLINE> <INDENT> resolve ( ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT>
s_1 = 0 <NEWLINE> s_2 = 0 <NEWLINE> s_3 = 0 <NEWLINE> mod = 1000000007 <NEWLINE> ans = 0 <NEWLINE> for i in range ( k , n + 2 ) : <NEWLINE> <INDENT> s_1 = ( n + n + 1 - i ) * i / 2 <NEWLINE> s_2 = ( 0 + i - 1 ) * i / 2 <NEWLINE> s_3 += s_1 + 1 - s_2 <NEWLINE> <DEDENT> ans = s_3 % 1000000007 <NEWLINE> print ( <STRING> . format ( ans ) ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <COMMENT> <NEWLINE> ans = 0 <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> <COMMENT> <NL> for k in range ( K , N + 2 ) : <COMMENT> <NEWLINE> <INDENT> upper = k * ( 2 N - ( k - 1 ) ) // 2 <NEWLINE> lower = k * ( k - 1 ) // 2 <NEWLINE> ans += upper - lower + 1 <NEWLINE> ans %= MOD <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
M = int ( input ( ) ) <NEWLINE> K = int ( input ( ) ) <NEWLINE> <NL> sum = 0 <NEWLINE> <NL> for j in range ( K , M + 2 ) : <NEWLINE> <INDENT> temp = j * ( M - j + 1 ) + 1 <NEWLINE> if temp > ( 10 ^ 9 + 7 ) : <NEWLINE> <INDENT> temp = temp % ( 10 ^ 9 + 7 ) <NEWLINE> <DEDENT> sum += temp <NEWLINE> <NL> <DEDENT> print ( sum ) <NEWLINE>
<NL> <NL> def main ( ) : <NEWLINE> <INDENT> mod = 10 ** 9 + 7 <NEWLINE> cnt = 0 <NEWLINE> for i in range ( k , n + 2 ) : <NEWLINE> <INDENT> l = ( i - 1 ) * i // 2 <NEWLINE> h = ( n + n - i + 1 ) * i // 2 <NEWLINE> cnt += h - l + 1 <NEWLINE> <DEDENT> print ( cnt % mod ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> using namespace std ; <NEWLINE> <NL> int main ( ) { <NEWLINE> <INDENT> long long n , k ; <NEWLINE> cin >> n >> k ; <NEWLINE> long long ans = 0 ; <NEWLINE> <NL> for ( int i = k ; i <= n + 1 ; + + i ) { <NEWLINE> <INDENT> ans += i * ( n - i + 1 ) + 1 ; <NEWLINE> ans %= 1000000007 ; <NEWLINE> <DEDENT> } <NEWLINE> cout << ans << endl ; <NEWLINE> <DEDENT> } <NEWLINE>
def sum_part ( N , k ) : <NEWLINE> <INDENT> return k * ( 2 * N - k + 1 ) / 2 - k * ( k - 1 ) / 2 + 1 <NEWLINE> <NL> <DEDENT> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = 0 <NEWLINE> for k in range ( K , N + 2 ) <NEWLINE> <INDENT> ans += sum_part ( N , k ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
import np <NEWLINE> <NL> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> p = 10 ** 9 + 7 <NEWLINE> Nlist = [ ] <NEWLINE> ReNlist = [ ] <NEWLINE> Ans = 0 <NEWLINE> for i in range ( N + 1 ) : <NEWLINE> <INDENT> Nlist . append ( i ) <NEWLINE> ReNlist . append ( N - i ) <NEWLINE> <DEDENT> Nlist = np . array ( Nlist ) . cumsum <NEWLINE> ReNlist = np . array ( ReNlist ) . cumsum <NEWLINE> for i range ( K , N + 1 ) : <NEWLINE> <INDENT> Ans += ReNlist [ K - 1 ] - Nlist [ K - 1 ] <NEWLINE> Ans = Ans % p <NEWLINE> <DEDENT> print ( Ans ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) ; mod = 10 ** 9 + 7 ; print ( ( n * ( n + 1 ) * ( n + 2 ) // 6 - k * ( k - 1 ) * ( 3 * n - 2 * k + 4 ) // 6 + n - k + 2 ) % mod <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> import sys <NEWLINE> from io import StringIO <NEWLINE> import unittest <NEWLINE> <NL> mod = 10 ** 9 + 7 <NEWLINE> <NL> def modinv ( a , mod ) : <NEWLINE> <INDENT> return pow_mod ( a , mod - 2 , mod ) <NEWLINE> <NL> <DEDENT> def pow_mod ( a , b , mod ) : <NEWLINE> <INDENT> x = 1 <NEWLINE> while b > 0 : <NEWLINE> <INDENT> if b & 1 : <NEWLINE> <INDENT> x = ( x * a ) % mod <NEWLINE> <DEDENT> a = ( a ** 2 ) % mod <NEWLINE> b //= 2 <NEWLINE> <NL> <DEDENT> return x <NEWLINE> <NL> <DEDENT> def comb ( n , r , mod ) : <NEWLINE> <INDENT> combsum = 1 <NEWLINE> for i in range ( n - r + 1 , n + 1 ) : <NEWLINE> <INDENT> combsum = ( combsum * i ) % mod <NEWLINE> <DEDENT> for i in range ( 1 , r + 1 ) : <NEWLINE> <INDENT> combsum = ( combsum * inv [ i ] ) % mod <NEWLINE> <DEDENT> return combsum <NEWLINE> <NL> <DEDENT> inv = [ modinv ( i , mod ) for i in range ( 0 , 2 * 10 ** 5 ) ] <NEWLINE> <NL> def yn ( b ) : <NEWLINE> <INDENT> print ( <STRING> if b == 1 else <STRING> ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> def resolve ( ) : <NEWLINE> <INDENT> readline = sys . stdin . readline <NEWLINE> <NL> n , k = map ( int , readline ( ) . rstrip ( ) . split ( ) ) <NEWLINE> <NL> a = 0 <NEWLINE> z = 0 <NEWLINE> ans = 0 <NEWLINE> n += 1 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> a += i <NEWLINE> z += ( n - i + 1 ) <NEWLINE> cnt = z - a + 1 <NEWLINE> if i >= k : <NEWLINE> <INDENT> ans += cnt <NEWLINE> ans %= mod <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> return <NEWLINE> <NL> <DEDENT> if <STRING> not in globals ( ) : <NEWLINE> <INDENT> resolve ( ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = np . array ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> ABI = sorted ( ( ( a , i ) for i , a in enumerate ( A , 1 ) ) , reverse = True ) <NEWLINE> prev = [ 0 ] <NEWLINE> for k , ( a , i ) in enumerate ( ABI ) <NEWLINE> <INDENT> curr = [ 0 ] * ( k + 2 ) <NEWLINE> for l in range ( k + 1 ) : <NEWLINE> <INDENT> curr [ l ] = max ( curr [ l ] , prev [ l ] + a * abs ( N - i - ( k - l ) ) ) <NEWLINE> curr [ l + 1 ] = prev [ l ] + a * abs ( i - l - 1 ) <NEWLINE> <DEDENT> prev = curr <NEWLINE> <DEDENT> print ( max ( prev ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> table = [ ] <NEWLINE> <NL> for i , a in enumerate ( A ) : <NEWLINE> <INDENT> table . append ( [ a , i ] ) <NEWLINE> <DEDENT> table . sort ( ) <NEWLINE> <NL> <COMMENT> <NL> DP = [ [ 0 for i in range ( N + 1 ) ] for j in range ( N + 1 ) ] <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <COMMENT> <NL> <INDENT> baby , pos = table . pop ( ) <NEWLINE> for x in range ( i + 1 ) : <NEWLINE> <INDENT> y = i - x <NEWLINE> <NL> <COMMENT> <NL> DP [ x ] [ 0 ] = DP [ x - 1 ] [ 0 ] + baby * abs ( pos - x + 1 ) ) <NEWLINE> DP [ 0 ] [ y ] = DP [ x ] [ y - 1 ] + baby * abs ( pos - ( N - y ) ) <NEWLINE> if x & y : <NEWLINE> <INDENT> DP [ x ] [ y ] = max ( ( DP [ x - 1 ] [ y ] + baby * abs ( pos - x + 1 ) ) , ( DP [ x ] [ y - 1 ] + baby * abs ( pos - ( N - y ) ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for i in range ( N + 1 ) : <NEWLINE> <INDENT> ans = max ( ans , DP [ i ] [ N - i ] ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> <NL> ABI = sorted ( ( ( a , i ) for i , a in enumerate ( A , 1 ) ) , reverse = True ) <NEWLINE> prev = [ 0 ] <NEWLINE> for k , ( a , i ) in enumerate ( ABI ) : <NEWLINE> <INDENT> curr = [ 0 ] * ( k + 2 ) <NEWLINE> for l in range ( k + 1 ) : <NEWLINE> <INDENT> curr [ l ] = max ( curr [ l ] , prev [ l ] + abs ( N - i - k + l ) * a ) <NEWLINE> curr [ l + 1 ] = prev [ l ] + abs ( i - l - 1 ) * a <NEWLINE> <NL> <DEDENT> prev = curr <NEWLINE> <NL> <DEDENT> print ( max ( prev ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> <NL> def solve ( a , i , prev ) : <NEWLINE> <INDENT> r = N - len ( prev ) - i + 1 <NEWLINE> p = - i * a <NEWLINE> for j , s in enumerate ( prev ) : <NEWLINE> <INDENT> yield max ( p + abs ( j - i ) * a , s + abs ( j + r ) * a ) <NEWLINE> p = s <NEWLINE> <DEDENT> yield s + abs ( len ( prev ) - i ) * a <NEWLINE> <NL> <DEDENT> pd = [ 0 ] <NEWLINE> A = map ( int , input ( ) . split ( ) ) <NEWLINE> for a , i in sorted ( ( ( a , i ) for i , a in enumerate ( A , 1 ) ) , reverse = True ) : <NEWLINE> <INDENT> pd = [ * solve ( a , i , pd ) ] <NEWLINE> <NL> <DEDENT> print ( max ( prev ) ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> AA = [ ( v , i ) for i , v in enumerate ( A ) ] <NEWLINE> AA . sort ( reverse = True ) <NEWLINE> dp = [ [ 0 ] * ( N + 1 ) for _ in range ( N + 1 ) ] <NEWLINE> for i , ( a , b ) in enumerate ( AA , start = 1 ) : <NEWLINE> <INDENT> for x in range ( i + 1 ) : <NEWLINE> <INDENT> y = i - x <NEWLINE> if y == 0 : <NEWLINE> <INDENT> dp [ x ] [ y ] = dp [ x - 1 ] [ y ] + abs ( b - x + 1 ) * a <NEWLINE> <DEDENT> elif x == 0 : <NEWLINE> <INDENT> dp [ x ] [ y ] = dp [ x ] [ y - 1 ] + abs ( N - y - b ) * a <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dp [ x ] [ y ] = max ( dp [ x - 1 ] [ y ] + abs ( b - x + 1 ) * a , dp [ x ] [ y - 1 ] + abs ( N - y - b ) * a ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> for i in range ( N + 1 ) : <NEWLINE> <INDENT> r = max ( r , dp [ i ] [ N - i ] ) <NEWLINE> <DEDENT> return r <NEWLINE> <DEDENT> print ( main ( ) ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 2 ** 2000 ) <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = [ ( i , v ) for i , v in enumerate ( a ) ] <NEWLINE> a . sort ( key = lambda x : x [ 1 ] , reverse = True ) <NEWLINE> <NL> dp = [ [ - 1 ] * ( m + 1 ) for m in range ( n + 1 ) ] <NEWLINE> <COMMENT> <NL> def f ( m , l ) : <NEWLINE> <INDENT> if m == n : return 0 <NEWLINE> if dp [ m ] [ l ] != - 1 : return dp [ m ] [ l ] <NEWLINE> r = n - m + l - 1 <NEWLINE> i , v = a [ m ] <NEWLINE> if i >= l : dp [ m + 1 ] [ l + 1 ] = f ( m + 1 , l + 1 ) <NEWLINE> if i <= r : dp [ m + 1 ] [ l ] = f ( m + 1 , l ) <NEWLINE> return max ( dp [ m + 1 ] [ l + 1 ] + v * ( i - l ) , dp [ m + 1 ] [ l ] + v * ( r - i ) ) <NEWLINE> <DEDENT> print ( f ( 0 , 0 ) ) <NEWLINE>
<COMMENT> <NL> <NL> def numba_compile ( numba_config ) : <NEWLINE> <INDENT> import os , sys <NEWLINE> if sys . argv [ - 1 ] == <STRING> : <NEWLINE> <INDENT> from numba import njit <NEWLINE> from numba . pycc import CC <NEWLINE> cc = CC ( <STRING> ) <NEWLINE> for func , signature in numba_config : <NEWLINE> <INDENT> globals ( ) [ func . __name__ ] = njit ( signature ) ( func ) <NEWLINE> cc . export ( func . __name__ , signature ) ( func ) <NEWLINE> <DEDENT> cc . compile ( ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> elif os . name == <STRING> : <NEWLINE> <INDENT> exec ( <STRING> ) <NEWLINE> for func , _ in numba_config : <NEWLINE> <INDENT> globals ( ) [ func . __name__ ] = vars ( ) [ func . __name__ ] <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> from numba import njit <NEWLINE> for func , signature in numba_config : <NEWLINE> <INDENT> globals ( ) [ func . __name__ ] = njit ( signature , cache = True ) ( func ) <NEWLINE> <DEDENT> print ( <STRING> , file = sys . stderr ) <NEWLINE> <NL> <DEDENT> <DEDENT> import numpy as np <NEWLINE> <NL> def sort_edges ( edges_ ) : <NEWLINE> <INDENT> M = len ( edges_ ) <NEWLINE> edges = np . empty ( ( M * 2 , 2 ) , dtype = np . int64 ) <NEWLINE> edges [ : M ] = edges_ <NEWLINE> edges [ M : ] = edges_ [ : , : : - 1 ] <NEWLINE> order = np . argsort ( edges [ : , 0 ] ) <COMMENT> <NEWLINE> edges = edges [ order , 1 ] <NEWLINE> c = np . cumsum ( np . bincount ( edges_ . ravel ( ) ) ) <NEWLINE> lefts = np . zeros ( len ( c ) + 1 , dtype = np . int64 ) <NEWLINE> lefts [ 1 : ] = c <NEWLINE> return edges , lefts <NEWLINE> <NL> <DEDENT> def eular_tour ( edges , lefts , root ) : <NEWLINE> <COMMENT> <NL> <INDENT> n = len ( lefts ) - 1 <NEWLINE> stack = [ root ] <NEWLINE> tour = [ 0 ] * 0 <NEWLINE> firsts = np . full ( n , - 100 , dtype = np . int64 ) <NEWLINE> lasts = np . full ( n , - 100 , dtype = np . int64 ) <NEWLINE> parents = np . full ( n , - 100 , dtype = np . int64 ) <NEWLINE> while stack : <NEWLINE> <INDENT> v = stack . pop ( ) <NEWLINE> if firsts [ v ] >= 0 : <NEWLINE> <INDENT> lasts [ v ] = len ( tour ) <NEWLINE> tour . append ( - v ) <COMMENT> <NEWLINE> continue <NEWLINE> <DEDENT> p = parents [ v ] <NEWLINE> firsts [ v ] = len ( tour ) <NEWLINE> tour . append ( v ) <NEWLINE> stack . append ( v ) <NEWLINE> for u in edges [ lefts [ v ] : lefts [ v + 1 ] ] : <NEWLINE> <INDENT> if p != u : <NEWLINE> <INDENT> parents [ u ] = v <NEWLINE> stack . append ( u ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> tour = np . array ( tour , dtype = np . int64 ) <NEWLINE> return tour , firsts , lasts , parents <NEWLINE> <NL> <DEDENT> def solve ( N , C , AB ) : <NEWLINE> <INDENT> edges , lefts = sort_edges ( AB ) <NEWLINE> tour , firsts , lasts , parents = eular_tour ( edges , lefts , 1 ) <NEWLINE> Siz = lasts - firsts + 1 >> 1 <NEWLINE> Cnt = np . zeros ( N + 1 , dtype = np . int64 ) <NEWLINE> Ans = np . zeros ( N + 1 , dtype = np . int64 ) <NEWLINE> Cnt_old = np . empty_like ( Cnt ) <NEWLINE> Siz_tmp = np . full_like ( Cnt , 1 ) <NEWLINE> for v in tour : <NEWLINE> <INDENT> if v >= 0 : <NEWLINE> <INDENT> p = parents [ v ] <NEWLINE> if p != - 100 : <NEWLINE> <INDENT> Cnt [ C [ p ] ] = N - Siz [ v ] <COMMENT> <NEWLINE> <NL> <DEDENT> color = C [ v ] <NEWLINE> Cnt_old [ v ] = Cnt [ color ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> v = - v <NEWLINE> Ans [ C [ v ] ] += N - Siz_tmp [ v ] + 1 - Cnt_old [ v ] <NEWLINE> Cnt [ C [ v ] ] = Cnt_old [ v ] + Siz_tmp [ v ] <NEWLINE> <NL> p = parents [ v ] <NEWLINE> if p != - 100 : <NEWLINE> <INDENT> Siz_tmp [ p ] += Siz [ v ] <NEWLINE> Ans [ C [ p ] ] += Siz [ v ] * ( N - Siz_tmp [ p ] + 1 - Cnt_old [ p ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> return Ans [ 1 : ] <NEWLINE> <NL> <NL> <DEDENT> numba_compile ( [ <NEWLINE> <INDENT> [ sort_edges , <STRING> ] , <NEWLINE> [ eular_tour , <STRING> ] , <NEWLINE> [ solve , <STRING> ] , <NEWLINE> <DEDENT> ] ) <NEWLINE> <NL> <NL> import sys <NEWLINE> def main ( ) : <NEWLINE> <INDENT> input = sys . stdin . buffer . readline <NEWLINE> read = sys . stdin . buffer . read <NEWLINE> N = int ( input ( ) ) <NEWLINE> C = np . empty ( N + 1 , dtype = np . int64 ) <NEWLINE> C [ 1 : ] = input ( ) . split ( ) <NEWLINE> AB = np . array ( read ( ) . split ( ) , dtype = np . int64 ) . reshape ( N - 1 , 2 ) <NEWLINE> Ans = solve ( N , C , AB ) <NEWLINE> print ( <STRING> . join ( map ( str , Ans . tolist ( ) ) ) ) <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE>
import sys <NEWLINE> read = sys . stdin . buffer . read <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> readlines = sys . stdin . buffer . readlines <NEWLINE> import numpy as np <NEWLINE> <NL> <NL> def solve ( N , C , AB ) : <NEWLINE> <INDENT> def edges_to_array ( A , B , N , M ) : <NEWLINE> <INDENT> head = np . full ( N + 1 , - 1 , np . int32 ) <NEWLINE> nxt = np . empty ( M + M , np . int32 ) <NEWLINE> to = np . empty ( M + M , np . int32 ) <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> a = A [ i ] <NEWLINE> b = B [ i ] <NEWLINE> nxt [ i << 1 ] = head [ a ] <NEWLINE> to [ i << 1 ] = b <NEWLINE> head [ a ] = i << 1 <NEWLINE> nxt [ i << 1 | 1 ] = head [ b ] <NEWLINE> to [ i << 1 | 1 ] = a <NEWLINE> head [ b ] = i << 1 | 1 <NEWLINE> <DEDENT> return head , nxt , to <NEWLINE> <NL> <DEDENT> def EulerTour ( head , nxt , to , root = 1 ) : <NEWLINE> <INDENT> N = len ( head ) - 1 <NEWLINE> parent = np . zeros_like ( head ) <NEWLINE> ind_L = np . empty_like ( head ) <NEWLINE> ind_R = np . empty_like ( head ) <NEWLINE> tour = np . empty ( N + N , np . int32 ) <NEWLINE> stack = np . empty ( N + N , np . int32 ) <NEWLINE> stack [ 0 ] = - root <NEWLINE> stack [ 1 ] = root <NEWLINE> t = - 1 <NEWLINE> s = 2 <NEWLINE> while s > 0 : <NEWLINE> <INDENT> s -= 1 <NEWLINE> v = stack [ s ] <NEWLINE> t += 1 <NEWLINE> tour [ t ] = v <NEWLINE> if v > 0 : <NEWLINE> <INDENT> ind_L [ v ] = t <NEWLINE> p = parent [ v ] <NEWLINE> k = head [ v ] <NEWLINE> while k != - 1 : <NEWLINE> <INDENT> w = to [ k ] <NEWLINE> if w == p : <NEWLINE> <INDENT> k = nxt [ k ] <NEWLINE> continue <NEWLINE> <DEDENT> parent [ w ] = v <NEWLINE> stack [ s ] = - w <NEWLINE> s += 1 <NEWLINE> stack [ s ] = w <NEWLINE> s += 1 <NEWLINE> k = nxt [ k ] <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> ind_R [ - v ] = t <NEWLINE> <DEDENT> <DEDENT> return tour , ind_L , ind_R , parent <NEWLINE> <NL> <DEDENT> head , nxt , to = edges_to_array ( AB [ : : 2 ] , AB [ 1 : : 2 ] , N , N - 1 ) <NEWLINE> tour , ind_L , ind_R , parent = EulerTour ( head , nxt , to ) <NEWLINE> removed = np . zeros ( N + 1 , np . int64 ) <NEWLINE> answer = np . full_like ( removed , N * ( N + 1 ) // 2 ) <NEWLINE> memo = np . zeros_like ( answer ) <NEWLINE> for v in tour : <NEWLINE> <INDENT> if v > 0 : <NEWLINE> <INDENT> memo [ v ] = removed [ C [ parent [ v ] ] ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> v = - v <NEWLINE> removed [ C [ v ] ] += 1 <NEWLINE> p = parent [ v ] <NEWLINE> x = ( ind_R [ v ] - ind_L [ v ] ) // 2 + 1 <COMMENT> <NEWLINE> x -= removed [ C [ p ] ] - memo [ v ] <NEWLINE> answer [ C [ p ] ] -= x * ( x + 1 ) // 2 <NEWLINE> removed [ C [ p ] ] += x <NEWLINE> <DEDENT> <DEDENT> for i , x in enumerate ( removed ) : <NEWLINE> <INDENT> x = N - x <NEWLINE> answer [ i ] -= x * ( x + 1 ) // 2 <NEWLINE> <DEDENT> return answer <NEWLINE> <NL> <NL> <DEDENT> def cc_export ( ) : <NEWLINE> <INDENT> from numba . pycc import CC <NEWLINE> cc = CC ( <STRING> ) <NEWLINE> cc . export ( <STRING> , <STRING> ) <NEWLINE> cc . compile ( ) <NEWLINE> <NL> <NL> <DEDENT> try : <NEWLINE> <INDENT> from my_module import solve <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> cc_export ( ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> N = int ( readline ( ) ) <NEWLINE> C = np . zeros ( N + 1 , np . int32 ) <NEWLINE> C [ 1 : ] = np . array ( readline ( ) . split ( ) , np . int32 ) <NEWLINE> AB = np . array ( read ( ) . split ( ) , np . int32 ) <NEWLINE> answer = solve ( N , C , AB ) <NEWLINE> print ( <STRING> . join ( answer [ 1 : ] . astype ( str ) ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> if 7 in n : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
num = input ( ) <NEWLINE> flag = False <NEWLINE> for i in range ( num ) : <NEWLINE> <INDENT> if num [ i ] == <STRING> : <NEWLINE> <INDENT> flag = True <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if flag : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s = int ( input ( ) ) <NEWLINE> a = [ int ( c ) for c in s ] <NEWLINE> if a [ 0 ] == 7 or a [ 1 ] == 7 or a [ 2 ] == 7 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
x = input ( ) <NEWLINE> for y in x : <NEWLINE> <INDENT> if y == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> print ( <STRING> ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> h = N // 100 <NEWLINE> t = ( N - h ) // 10 <NEWLINE> o = N - h - t <NEWLINE> if h = 7 or t = 7 or o = 7 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = input ( ) <NEWLINE> if <STRING> in S : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = list ( input ( ) ) <NEWLINE> if N in <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = std ( input ( ) ) <NEWLINE> <NL> a = N . split ( ) <NEWLINE> <NL> if 7 in a : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT>
N = int ( input ( ) ) <NEWLINE> <NL> hyaku = N // 100 <NEWLINE> resi = N - ( 100 * hyaku ) <NEWLINE> ju = resi // 10 <NEWLINE> iti = resi % 10 <NEWLINE> <NL> n = hyaku * ju * iti <NEWLINE> <NL> if n % 7 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> N = int ( input ( ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> for i in rang ( 0 , 2 ) : <NEWLINE> <INDENT> if ( n % 10 == 7 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> n /= 10 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b , c = input ( ) <NEWLINE> <NL> if ( a == <STRING> | | b == <STRING> | | c == <STRING> ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = input ( ) <NEWLINE> if n . count ( 7 ) == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = inport ( ) <NEWLINE> if <STRING> in n : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = input ( ) <NEWLINE> cnt = 0 <NEWLINE> for i in n : <NEWLINE> <INDENT> if i = <STRING> : <NEWLINE> <INDENT> cnt = 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if cnt == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> <NL> a == N // 100 <NEWLINE> b == ( N - ( a * 100 ) ) // 10 <NEWLINE> c == ( N - ( a * 100 + b * 10 ) ) <NEWLINE> <NL> if ( a == 7 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s = str ( N ) <NEWLINE> <NL> if s [ 0 ] == <STRING> or s [ 1 ] == <STRING> or s [ 2 ] == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = int ( Input ( <STRING> ) ) <NEWLINE> if N % 10 == 7 | | ( N - N % 10 ) / 10 % 10 == 7 | | ( N - N % 100 ) / 100 == 7 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
is_lucky = any ( i == <STRING> for i in input ( ) . split ( ) ) <NEWLINE> print ( <STRING> if is_luckey else <STRING> ) <NEWLINE>
n = input ( ) <NEWLINE> <NL> for i in range ( len ( n ) ) : <NEWLINE> <INDENT> if n [ i ] = <STRING> : <NEWLINE> <INDENT> count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if count > 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
if 7 in N : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import sys <NEWLINE> read = sys . stdin . buffer . read <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> readlines = sys . stdin . buffer . readlines <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> x = read ( ) <NEWLINE> if <STRING> in x : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a = list ( int ( input ( ) ) ) <NEWLINE> if 7 in a : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = list ( map ( int , input ( ) ) <NEWLINE> if n [ i ] == 7 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> if N . count ( 7 ) > 0 : <NEWLINE> <INDENT> print ( Yes ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( No ) <NEWLINE> <DEDENT>
x = input <NEWLINE> <NL> for i in range ( 3 ) <NEWLINE> <INDENT> if x [ i ] == <STRING> <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> else <NEWLINE> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT>
<NL> s = raw_input ( ) <NEWLINE> if <STRING> in s : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT>
N = 123 <NEWLINE> N_sp = N . split ( <STRING> ) <NEWLINE> <NL> if ( N_sp == 7 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
N = str ( input ( ) ) <NEWLINE> <NL> if <STRING> in N : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> )  <NEWLINE> <DEDENT>
n = input ( ) <NEWLINE> if not n [ 0 ] == 7 and n [ 1 ] == 7 and n [ 2 ] == 7 : <NEWLINE> <INDENT> print ( No ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( Yes ) <NEWLINE> <DEDENT>
import sys <NEWLINE> n = int ( input ( ) ) <NEWLINE> <NL> for _ in range ( 3 ) : <NEWLINE> <INDENT> if n % 10 == 7 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( 1 ) <NEWLINE> <DEDENT> n = n // 10 <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE>
if <STRING> in str ( N ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = input ( ) <NEWLINE> <NL> if 7 in N : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = n . find ( <STRING> ) <NEWLINE> if a > - 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
item = input ( ) <NEWLINE> if 7 in item : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a = list ( int ( input ( ) ) ) <NEWLINE> if 7 in a == True : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> if N . count ( 7 ) > 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s = intput ( ) <NEWLINE> <NL> if ( <STRING> in s ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> if N [ 0 ] == <STRING> or N [ 1 ] == <STRING> or N [ 2 ] == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> <NL> for e in s : <NEWLINE> <INDENT> if e = <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s = list [ map ( int , input ( ) . split ( ) ) ] <NEWLINE> a = s . count ( 7 ) <NEWLINE> if a == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = str ( input ( ) ) <NEWLINE> if n [ 0 ] = <STRING> or n [ 1 ] = <STRING> or n [ 2 ] = <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = input ( ) <NEWLINE> if 7 in n : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> <NL> if 7 in n : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> if 7 in N : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> n = abc <NEWLINE> if a == 7 or b == 7 or c == 7 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> has = False <NEWLINE> for n in N : <NEWLINE> <INDENT> if n == 7 : <NEWLINE> <INDENT> has = True <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if has : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = input ( ) <NEWLINE> if N in 7 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = input ( ) <NEWLINE> if 7 in n : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
<NL> has_seven = False <NEWLINE> N = str ( input ( ) ) <NEWLINE> for i in range ( len ( N ) ) : <NEWLINE> <INDENT> if N [ i ] == <STRING> : <NEWLINE> <INDENT> has_seven = True <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if has_seven : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <NL> <DEDENT>
a , b , c = map ( int , input ( ) ) <NEWLINE> <NL> if a * b * c == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif : a * b * c % 7 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : print ( <STRING> ) <NEWLINE>
print ( <STRING> if all ( [ i = <STRING> for i in input ( ) ] ) else <STRING> ) <NEWLINE>
Source Code <NEWLINE> <NL> Copy <NEWLINE> Copy <NEWLINE> i = input ( ) <NEWLINE> if <STRING> in i : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = str ( input ( ) ) <NEWLINE> if n . count ( 7 ) >= 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
num = map ( int , input ( ) . split ( ) ) <NEWLINE> for i in num : <NEWLINE> <INDENT> if num [ i ] == 7 : <NEWLINE> <INDENT> break <NEWLINE> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = input ( ) <NEWLINE> list ( n ) <NEWLINE> han = False <NEWLINE> for i in n : <NEWLINE> <INDENT> print ( i ) <NEWLINE> if i == <STRING> : <NEWLINE> <INDENT> han = True <NEWLINE> <DEDENT> <DEDENT> if han = True : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
S = input ( ) <NEWLINE> X = 0 <NEWLINE> for i in range ( 3 ) : <NEWLINE> <INDENT> if A [ i ] == 7 : <NEWLINE> <INDENT> X += 1 <NEWLINE> <DEDENT> <DEDENT> if X == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = input ( ) <NEWLINE> <NL> n = input ( ) <NEWLINE> if <STRING> in N : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = input ( ) <NEWLINE> for idx in len ( N ) : <NEWLINE> <INDENT> if N [ idx ] == str ( 7 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = str ( input ( ) ) <NEWLINE> enc = 0 <NEWLINE> <NL> for char in list ( N ) : <NEWLINE> <INDENT> if char == <STRING> : <NEWLINE> <INDENT> enc += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if enc >= 1 : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT>
n = input ( ) <NEWLINE> <NL> fizz = [ ] <NEWLINE> buzz = [ ] <NEWLINE> fizzbuzz = [ ] <NEWLINE> other = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if ( i % 3 != 0 ) & ( i % 5 != 0 ) : <NEWLINE> <INDENT> other . append ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> b = 0 <NEWLINE> for i in range ( len ( other ) ) : <NEWLINE> <INDENT> b += other [ i ] <NEWLINE> <NL> <DEDENT> print ( b ) <NEWLINE>
n = input ( ) <NEWLINE> flag = 0 <NEWLINE> for i in n : <NEWLINE> <INDENT> if i == <STRING> : <NEWLINE> <INDENT> flag = 1 <NEWLINE> <DEDENT> <DEDENT> if flag == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> if N . count ( <STRING> ) == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = list ( int , input ( ) ) <NEWLINE> if n [ 0 ] == 7 or n [ 1 ] == 7 or n [ 2 ] == 7 <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = <NEWLINE> if N % 7 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> I = input ( ) <NEWLINE> <NL> R = 0 <NEWLINE> G = 0 <NEWLINE> B = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if ( I [ i ] == <STRING> ) : <NEWLINE> <INDENT> R += 1 <NEWLINE> <DEDENT> if ( I [ i ] == <STRING> ) : <NEWLINE> <INDENT> G += 1 <NEWLINE> <DEDENT> if ( I [ i ] == <STRING> ) : <NEWLINE> <INDENT> B += 1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> sum = R * G * B <NEWLINE> count = 0 <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> for j in range ( i + 1 , N ) : <NEWLINE> <INDENT> if I [ i ] != I [ j ] : <NEWLINE> <INDENT> k = j + j - i <NEWLINE> if k >= N : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if I [ i ] != I [ k ] and I [ j ] != I [ k ] : <NEWLINE> <INDENT> count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( sum - count ) <NEWLINE>
import sys <NEWLINE> <NL> input = sys . stdin . readline <NEWLINE> <NL> N = input ( ) . split ( ) <NEWLINE> <NL> for i in range ( 3 ) : <NEWLINE> <INDENT> if N [ i ] == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
N = input ( ) <NEWLINE> if N [ 0 ] = <STRING> or N [ 1 ] = <STRING> or N [ 2 ] = <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = input ( ) <NEWLINE> <NL> if <STRING> in n : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
n = input ( ) . split <NEWLINE> <NL> if n [ len ( n ) ] == 7 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif n [ len ( n ) - 1 ] == 7 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif n [ len ( n ) - 2 ] == 7 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = input ( ) <NEWLINE> return <STRING> in n <NEWLINE>
a = int ( input ( ) ) <NEWLINE> if <STRING> in a : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = innput ( ) <NEWLINE> <NL> if <STRING> in n : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s = str ( input ( ) ) <NEWLINE> print ( <STRING> if s [ 0 ] = <STRING> or s [ 1 ] = <STRING> or s [ 2 ] = <STRING> else <STRING> ) <NEWLINE>
import re <NEWLINE> seven = re . pattern ( <STRING> ) <NEWLINE> print ( <STRING> ) if seven . match ( input ( ) ) else <STRING> <NEWLINE>
word = input ( ) . split ( ) <NEWLINE> <COMMENT> <NL> if word [ 0 ] == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif word [ 1 ] == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif word [ 2 ] == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> <NL> if n . count ( 7 ) != 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> print ( <STRING> ) <NEWLINE>
str = input ( ) <NEWLINE> if str [ 0 ] == <STRING> or str [ 1 ] == <STRING> or str [ 2 ] == <STRING> : print ( <STRING> ) <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a = int ( input ( ) ) <NEWLINE> b = a // 100 <NEWLINE> c = a // 10 - b * 10 <NEWLINE> d = a % 10 <NEWLINE> if b != 7 and c != 7 and d != 7 : <NEWLINE> <INDENT> print ( No ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( Yes ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> num = map ( int , str ( n ) ) <NEWLINE> if num [ - 1 ] == <STRING> or num [ - 3 ] == <STRING> or num [ - 2 ] == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = [ ] <NEWLINE> for n in range ( 3 ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> <DEDENT> if n == 7 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> if N [ 0 ] == 7 or N [ 1 ] == 7 or N [ 2 ] == 7 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
number = int ( input ( ) ) <NEWLINE> <NL> if 7 in number : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = list ( str ( input ( ) ) ) <NEWLINE> <NL> cnt = 0 <NEWLINE> for i in range ( 0 , len ( n ) ) : <NEWLINE> <INDENT> if int ( s [ i ] ) == 7 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> cnt += 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if cnt == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = intput ( ) <NEWLINE> <NL> print ( <STRING> if <STRING> in N else <STRING> ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> str ( N ) <NEWLINE> listN = sorted ( N ) <NEWLINE> if listN . count ( <STRING> ) >= 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = input ( ) <NEWLINE> if 7 in n : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a = int ( N ) // 100 <NEWLINE> b = ( int ( N ) - a * 100 ) // 10 <NEWLINE> c = int ( N ) - 100 * a - 10 * b <NEWLINE> A = ( a == 7 ) <NEWLINE> B = ( b == 7 ) <NEWLINE> C = ( c == 7 ) <NEWLINE> print ( a ) <NEWLINE> print ( b ) <NEWLINE> print ( c ) <NEWLINE> if A == True or B == True or C == True : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a = input ( ) <NEWLINE> b = [ int ( c ) for c in a ] <NEWLINE> <NL> d = len ( a ) <NEWLINE> e = b + 1 <NEWLINE> i = 0 <NEWLINE> while i < e : <NEWLINE> <INDENT> e = a [ i ] <NEWLINE> if e == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> elif e == a : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> i += 1 <NEWLINE> <DEDENT>
N = input ( ) <NEWLINE> ans = <STRING> <NEWLINE> for i in range ( len ( N ) ) : <NEWLINE> <INDENT> if N [ i ] == 7 : <NEWLINE> <INDENT> global ans <NEWLINE> ans = <STRING> <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> <NL> if N [ 0 ] == <STRING> or N [ 1 ] == <STRING> or N [ 2 ] == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
<INDENT> N = list ( input ( ) ) <NEWLINE> if ( <STRING> in N ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> if N [ 0 ] == 7 or N [ 1 ] == 7 or N [ 2 ] == 7 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = input ( ) <NEWLINE> <NL> def a ( N ) : <NEWLINE> <INDENT> for c in N : <NEWLINE> <INDENT> if c = <STRING> : <NEWLINE> <INDENT> return <STRING> <NEWLINE> return <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( a ( N ) ) <NEWLINE>
N = input ( ) <NEWLINE> oh = N // 100 <NEWLINE> ot = ( N - oh * 100 ) // 10 <NEWLINE> oo = N - oh * 100 - ot * 10 <NEWLINE> if oh == 7 or ot == 7 or oo == 7 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = input ( ) <NEWLINE> n = str ( n ) <NEWLINE> t = <STRING> <NEWLINE> for i in n ; <NEWLINE> <INDENT> if i == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <INDENT> t = <STRING> <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if t == <STRING> : print ( <STRING> ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> if 7 in n : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : print ( <STRING> ) <NEWLINE>
s = input ( ) . split ( ) <NEWLINE> ans = <STRING> <NEWLINE> for e in s : <NEWLINE> <INDENT> if e = <STRING> : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> if <STRING> in list ( n ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = str ( input ( ) ) <NEWLINE> count = 0 <NEWLINE> <NL> for i in n : <NEWLINE> <INDENT> if ( i == <STRING> ) : <NEWLINE> <INDENT> count + + <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if ( count != 0 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = str ( input ( ) ) <NEWLINE> <NL> for char in chars : <NEWLINE> <INDENT> if int ( char ) == 7 : <NEWLINE> <INDENT> n = 1 <NEWLINE> <NL> <DEDENT> if n != 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> if n == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
l = int ( input ( ) ) <NEWLINE> if 7 in l : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
x = input ( ) <NEWLINE> for i in range ( len ( x ) ) : <NEWLINE> <INDENT> if x [ i ] == <STRING> : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> <DEDENT>
n = map ( int , input . split ( ) ) <NEWLINE> if <STRING> in n : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = 7 <NEWLINE> if N > = 100 and N <= 999 : <NEWLINE> <INDENT> print ( Yes ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( No ) <NEWLINE> <DEDENT>
= input ( ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 3 ) : <NEWLINE> <INDENT> if int ( n [ i ] ) == 7 : <NEWLINE> <INDENT> ans = 1 <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> if ans == 1 else <STRING> ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> a = str ( N ) <NEWLINE> if a in 7 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
def find_7 ( num ) : <NEWLINE> <INDENT> num_list = list ( map ( int , str ( num ) ) ) <NEWLINE> count = 0 <NEWLINE> for x in num_list : <NEWLINE> <INDENT> count += 1 <NEWLINE> if x == 7 : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> elif count == len ( num_list ) : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> print ( find_7 ( ) ) <NEWLINE> <DEDENT>
N = input ( ) <NEWLINE> <NL> if N in 7 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> m = list ( n ) <NEWLINE> <NL> if m . count ( 7 ) > 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> H = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> A = [ 0 ] * ( N + 1 ) <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> A [ x ] = max ( A [ x ] , H [ y - 1 ] ) <NEWLINE> A [ y ] = max ( A [ y ] , H [ x - 1 ] ) <NEWLINE> <NL> <DEDENT> count = 0 <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> if H [ i - 1 ] > A [ i ] : <NEWLINE> <INDENT> count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
n = input ( ) <NEWLINE> if 7 in n : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = input ( ) <NEWLINE> <NL> a = 0 <NEWLINE> for i in range ( 3 ) : <NEWLINE> <INDENT> if N [ i ] == <STRING> : <NEWLINE> <INDENT> a = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if a = 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
<COMMENT> <NL> from collections import defaultdict , deque <NEWLINE> from heapq import heappush , heappop <NEWLINE> from itertools import permutations , accumulate <NEWLINE> import sys <NEWLINE> import math <NEWLINE> import bisect <NEWLINE> def LI ( ) : return [ int ( x ) for x in sys . stdin . readline ( ) . split ( ) ] <NEWLINE> def I ( ) : return int ( sys . stdin . readline ( ) ) <NEWLINE> def LS ( ) : return [ list ( x ) for x in sys . stdin . readline ( ) . split ( ) ] <NEWLINE> def S ( ) : <NEWLINE> <INDENT> res = list ( sys . stdin . readline ( ) ) <NEWLINE> if res [ - 1 ] == <STRING> : <NEWLINE> <INDENT> return res [ : - 1 ] <NEWLINE> <DEDENT> return res <NEWLINE> <DEDENT> def IR ( n ) : <NEWLINE> <INDENT> return [ I ( ) for i in range ( n ) ] <NEWLINE> <DEDENT> def LIR ( n ) : <NEWLINE> <INDENT> return [ LI ( ) for i in range ( n ) ] <NEWLINE> <DEDENT> def SR ( n ) : <NEWLINE> <INDENT> return [ S ( ) for i in range ( n ) ] <NEWLINE> <DEDENT> def LSR ( n ) : <NEWLINE> <INDENT> return [ LS ( ) for i in range ( n ) ] <NEWLINE> <NL> <DEDENT> sys . setrecursionlimit ( 1000000 ) <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> A = LI ( ) <NEWLINE> print ( A . index ( 0 ) + 1 ) <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE>
n = input ( ) <NEWLINE> first = n // 100 <NEWLINE> second = ( n % 100 ) // 10 <NEWLINE> third = ( n % 10 ) <NEWLINE> <NL> if ( first == 7 or second == 7 or third == 7 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = input ( ) <NEWLINE> <NL> print ( <STRING> if <STRING> str ( N ) else <STRING> ) <NEWLINE>
N = input ( ) <NEWLINE> a = int ( N [ 0 ] ) <NEWLINE> b = int ( N [ 1 ] ) <NEWLINE> c = int ( N [ 2 ] ) <NEWLINE> <NL> if a = 7 or b = 7 or c = 7 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
<COMMENT> <NL> list = list ( str ( input ( ) ) <NEWLINE> <NL> flag = 0 <NEWLINE> <NL> for i in list : <NEWLINE> <INDENT> if i == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> flag = 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if flag == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = input ( ) <NEWLINE> <NL> flag = 0 <NEWLINE> if N [ 0 ] == <STRING> : <NEWLINE> <INDENT> flag = 1 <NEWLINE> <DEDENT> if N [ 1 ] == <STRING> : <NEWLINE> <INDENT> flag = 1 <NEWLINE> <DEDENT> if N [ 2 ] == <STRING> : <NEWLINE> <INDENT> flag = 1 <NEWLINE> <NL> <DEDENT> if flag = 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> if n % 10 = 7 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> n = n // 10 <NEWLINE> if n % 10 = 7 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else if n // 10 = 7 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> if 7 in S : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s = int ( input ( ) . split ( ) ) <NEWLINE> for i in s : <NEWLINE> <INDENT> if i == 7 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
N = input ( ) <NEWLINE> <NL> for s in N : <NEWLINE> <INDENT> if s == <STRING> : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> <DEDENT> return <STRING> <NEWLINE>
n = [ i for i in raw_input ( ) ] <NEWLINE> print <STRING> if <STRING> in n else <STRING> <NEWLINE>
a = input ( ) <NEWLINE> if 7 in a : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = int ( input ( ) . rstrip ) <NEWLINE> count = 0 <NEWLINE> for i in N : <NEWLINE> <INDENT> if i == 7 : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> if count > 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
string = inout ( ) <NEWLINE> t = False <NEWLINE> for i in range ( len ( string ) ) : <NEWLINE> <INDENT> if string [ i ] == 7 : <NEWLINE> <INDENT> t = True <NEWLINE> <DEDENT> <DEDENT> if t == True : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import sys <NEWLINE> a = sys . argv [ 1 ] <NEWLINE> if <STRING> in a : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = str ( input ( ) ) <NEWLINE> if N in 7 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a = int ( input ( ) ) <NEWLINE> for _ in range ( 3 ) : <NEWLINE> <INDENT> if a % 10 == 7 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> a /= 10 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = input ( ) <NEWLINE> if n [ 0 ] == <STRING> or n [ 1 ] == <STRING> or n [ 2 ] == <STRING> <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
S = list ( input ( ) ) <NEWLINE> if S . count ( 7 ) == 0 : <NEWLINE> <INDENT> print ( No ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( Yes ) <NEWLINE> <NL> <DEDENT>
n = input ( ) <NEWLINE> if s [ 0 ] == 7 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> if s [ 1 ] == 7 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> if s [ 2 ] == 7 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = input ( ) <NEWLINE> <NL> for char in N : <NEWLINE> <INDENT> if char = <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
n = input ( ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( len ( n ) ) : <NEWLINE> <INDENT> if n [ i ] == <STRING> : <NEWLINE> ans += 1 <NEWLINE> <DEDENT> print ( <STRING> if ans > 0 else <STRING> ) <NEWLINE>
N = input ( ) <NEWLINE> <NL> if <STRING> in N : <NEWLINE> <INDENT> print ( Yes ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( No ) <NEWLINE> <DEDENT>
N = input ( ) <NEWLINE> if <STRING> in N : <NEWLINE> <INDENT> print ( <STRING> ) : <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import sys <NEWLINE> n = input ( ) <NEWLINE> for i in n : <NEWLINE> <INDENT> if i == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <INDENT> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
<NL> <NL> <NL> N = input ( ) <NEWLINE> <NL> N1 = N [ ] <NEWLINE> print ( N1 ) <NEWLINE> if N [ 0 ] == <STRING> or N [ 1 ] == <STRING> or N [ 2 ] == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT>
import sys <NEWLINE> <NL> X = int , input ( ) <NEWLINE> test = list ( X ) <NEWLINE> print ( test ) <NEWLINE> for num in test : <NEWLINE> <INDENT> tmp = int ( num ) <NEWLINE> if tmp == 7 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
n = input ( ) <NEWLINE> print ( <STRING> if 7 in n else <STRING> ) <NEWLINE>
N = input ( ) <NEWLINE> l = [ int ( i ) for i in l ] <NEWLINE> if 7 is in l : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> return <STRING> <NEWLINE>
a = input ( ) <NEWLINE> if a . count ( 7 ) == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = str ( input ( ) ) <NEWLINE> a = 0 <NEWLINE> for i in range ( len ( n ) ) : <NEWLINE> <INDENT> if int ( n [ i ] ) == 7 : <NEWLINE> <INDENT> a = 1 <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if a == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> if <STRING> in N : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> if n % 10 == 7 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> n = n // 10 <NEWLINE> if n % 10 == 7 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> n = n // 10 : <NEWLINE> if n % 10 == 7 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
s = int ( input ( ) ) <NEWLINE> if 7 in s : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a = int ( input ( ) ) <NEWLINE> if 7 in a : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = input ( ) <NEWLINE> if <STRING> in N <NEWLINE> print ( <STRING> ) <NEWLINE> if not <STRING> in N <NEWLINE> print ( <STRING> ) <NEWLINE>
n = int ( input ) <NEWLINE> count = 0 <NEWLINE> tenwari = n % 10 <NEWLINE> baiwari = n % 100 <NEWLINE> ichi = tenwari <NEWLINE> jyu = ( baiwari - tenwari ) // 10 <NEWLINE> hyaku = ( n - jyu * 10 - ichi ) // 100 <NEWLINE> <NL> if ichi != 7 : <NEWLINE> <INDENT> count = count + 1 <NEWLINE> <DEDENT> if jyu != 7 : <NEWLINE> <INDENT> count = count + 1 <NEWLINE> <DEDENT> if hyaku != 7 : <NEWLINE> <INDENT> count = count + 1 <NEWLINE> <NL> <DEDENT> if count == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
l = list ( map ( int , input ( ) ) ) <NEWLINE> if 7 in list : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
if <STRING> in n : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = input ( ) <NEWLINE> s = str ( N ) <NEWLINE> s1 = s [ - 1 ] <NEWLINE> s2 = s [ - 2 ] <NEWLINE> s3 = s [ - 3 ] <NEWLINE> if s1 == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> elif s2 == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> elif s3 == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT>
A = int ( input ( ) ) <NEWLINE> <NL> B = A // 10 <NEWLINE> C = B // 10 <NEWLINE> <NL> <INDENT> if A % 10 == 7 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> elif B % 10 == 7 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> elif C % 10 == 7 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = input ( ) <NEWLINE> s = int ( n / 100 ) <NEWLINE> if s == 7 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> elif n % 10 == 7 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> elif n % 100 >= 70 and n % 100 < 80 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
in = input ( ) <NEWLINE> ok = 0 <NEWLINE> for i in range ( len ( in ) ) : <NEWLINE> <INDENT> if ( in [ i ] == <STRING> ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> ok = 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if ( ok == 0 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n , m , o = input ( ) . split ( ) <NEWLINE> <NL> if n != <STRING> and m != <STRING> and o != <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> <NL> if <STRING> in n : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
<INDENT> = list ( input ( ) ) <NEWLINE> <DEDENT> if <STRING> in n : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = input ( ) <NEWLINE> <NL> flag = 0 <NEWLINE> for i in range ( len ( N ) ) : <NEWLINE> <INDENT> if N [ i ] == <STRING> : <NEWLINE> <INDENT> flag = 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if flag == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> <NEWLINE> <DEDENT>
N = input ( ) <NEWLINE> if <STRING> in S : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <NL> <NL> import sys <NEWLINE> import math <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> fileoperation = 1 <NEWLINE> if ( fileoperation ) : <NEWLINE> <INDENT> orig_stdout = sys . stdout <NEWLINE> orig_stdin = sys . stdin <NEWLINE> inputfile = open ( <STRING> , <STRING> ) <NEWLINE> outputfile = open ( <STRING> , <STRING> ) <NEWLINE> sys . stdin = inputfile <NEWLINE> sys . stdout = outputfile <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> mod = 1000000007 <NEWLINE> <NL> <COMMENT> <NL> def nospace ( l ) : <NEWLINE> <INDENT> ans = <STRING> . join ( str ( i ) for i in l ) <NEWLINE> return ans <NEWLINE> <NL> <NL> <NL> <COMMENT> <NL> <DEDENT> t = 1 <NEWLINE> for tt in range ( t ) : <NEWLINE> <INDENT> n = str ( input ( ) ) <NEWLINE> if <STRING> in n : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> if ( fileoperation ) : <NEWLINE> <INDENT> sys . stdout = orig_stdout <NEWLINE> sys . stdin = orig_stdin <NEWLINE> inputfile . close ( ) <NEWLINE> outputfile . close ( ) <NEWLINE> <DEDENT>
no = input ( ) <NEWLINE> c = false <NEWLINE> while no > 0 : <NEWLINE> <INDENT> if no % 10 == 7 : <NEWLINE> <INDENT> c = true <NEWLINE> <DEDENT> <DEDENT> if c == true : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = input ( ) <NEWLINE> c = 0 <NEWLINE> for x in n : <NEWLINE> <INDENT> if x == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> c += 1 <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> <DEDENT> if c = 3 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = input ( ) <NEWLINE> ans = <STRING> <NEWLINE> for s in n : <NEWLINE> <INDENT> if s == <STRING> <NEWLINE> ans = <STRING> <NEWLINE> break <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
<INDENT> l = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> <NL> <DEDENT> if l [ 0 ] == 7 or l [ 1 ] == 7 or l [ 2 ] == 7 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> if N [ 0 ] != 7 and N [ 1 ] != 7 and N [ 2 ] != 7 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
i = input ( ) <NEWLINE> i1 = int ( i / 100 ) <NEWLINE> i2 = int ( ( i - i1 * 100 ) / 10 ) <NEWLINE> i3 = i - i1 * 100 - i2 * 10 <NEWLINE> <NL> if ( i1 == 7 or i2 == 7 or i3 == 7 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a = input ( ) <NEWLINE> if a % 10 == 7 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif ( a % 100 ) // 10 == 7 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif ( a // 100 ) == 7 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
S = input ( ) <NEWLINE> if S . count ( 7 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = str ( input ( ) ) <NEWLINE> if N . isin ( <STRING> ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s = list ( map ( int , input ( ) ) ) <NEWLINE> for i in s : <NEWLINE> <INDENT> if i == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> return <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
N = input ( ) <NEWLINE> while N != 0 : <NEWLINE> <INDENT> if N % 10 == 7 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> return <NEWLINE> <DEDENT> N = N // 10 <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> return <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> if n [ 0 ] == 7 or n [ 1 ] == 7 or n [ 2 ] == 7 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> a = int ( N / 100 ) <NEWLINE> b = int ( ( N - a * 100 ) / 10 ) <NEWLINE> c = int ( N - 100 * a - 10 * b ) <NEWLINE> l = int ( ) <NEWLINE> if a * b * c == 7 l : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
S = input ( ) <NEWLINE> if <STRING> in S : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
lucky = input ( ) <NEWLINE> a = int ( lucky [ 1 ] ) <NEWLINE> b = int ( lucky [ 2 ] ) <NEWLINE> c = int ( lucky [ 3 ] ) <NEWLINE> <NL> if ( a == 7 ) or ( b == 7 ) or ( c == 7 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
<INDENT> N = input ( ) <NEWLINE> <NL> <DEDENT> flg = False <COMMENT> <NEWLINE> for i in N : <COMMENT> <NEWLINE> <INDENT> if i == <STRING> : <NEWLINE> <INDENT> flg = True <COMMENT> <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if flg : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a = str ( input ( ) ) <NEWLINE> if a [ 0 ] or a [ 1 ] or a [ 2 ] == 7 : <NEWLINE> <NL> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
x = input ( ) <NEWLINE> a = x [ 0 ] <NEWLINE> b = x [ 1 ] <NEWLINE> c = x [ 2 ] <NEWLINE> if a == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> elif b == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> elif c == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = input ( ) <NEWLINE> <NL> if n [ 0 ] == <STRING> or n [ 1 ] == <STRING> or n [ 2 ] == <STRING> : <NEWLINE> <INDENT> print ( Yes ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = input ( ) <NEWLINE> i = 7 <NEWLINE> if i in n : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
List = [ int ( input ( ) ) for i in range ( n ) ] <NEWLINE> if ( List . index ( 7 ) ) print ( <STRING> ) : <NEWLINE> <INDENT> else : print ( <STRING> ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> <NL> if N in 7 : <NEWLINE> <INDENT> print ( Yes ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( No ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = n // 100 <NEWLINE> b = n % 100 // 10 <NEWLINE> c = n % 10 <NEWLINE> if a = 7 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif b = 7 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif c = 7 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> l = len ( N ) <NEWLINE> for i in range ( l ) : <NEWLINE> <INDENT> if N [ i ] == 7 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
for i in str ( n ) : <NEWLINE> <INDENT> if i == str ( 7 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
n = input ( ) <NEWLINE> <NL> if s [ 0 ] == <STRING> or s [ 1 ] == <STRING> or s [ 2 ] == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> import re <NEWLINE> <NL> if int ( input ( ) ) > 100 and int ( input ( ) ) <= 999 : <NEWLINE> <INDENT> x = str ( input ( ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit <NEWLINE> <NL> <DEDENT> if re . match ( <STRING> , x ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> <NL> print ( <STRING> if <STRING> in str ( N ) ) <NEWLINE>
print ( <STRING> if 7 in list ( int ( input ( ) ) ) else <STRING> ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> if 7 in n : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s = str ( input ( ) ) <NEWLINE> if s [ 0 ] == 7 or s [ 1 ] == 7 or s [ 2 ] == 7 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> 9 <NEWLINE> <DEDENT>
N = str ( input ( ) ) <NEWLINE> result = any ( True if m == <STRING> else False for n in N ) <NEWLINE> <NL> <NL> if result ; <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> else ; <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = list ( int ( input ( ) ) ) <NEWLINE> ans = <STRING> <NEWLINE> for i in range ( 0 , len ( n ) ) : <NEWLINE> <INDENT> if n [ i ] = 7 <NEWLINE> ans = <STRING> <NEWLINE> break <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n = input ( ) <NEWLINE> if <STRING> in n : <NEWLINE> <INDENT> prnt ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> <NL> if n in 7 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif n not in 7 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = str ( input ( ) ) <NEWLINE> <NL> for i in range ( len ( n ) ) : <NEWLINE> <INDENT> if n [ i ] == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> if i == n - 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
n = input ( ) ; <NEWLINE> if n // 100 = 7 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif n // 10 = 7 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif n % 10 = 7 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
x = input ( ) <NEWLINE> if <STRING> in x : <NEWLINE> <INDENT> print ( Yes ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( No ) <NEWLINE> <DEDENT>
N = iter ( list ( input ( ) . split ( ) ) ) <NEWLINE> <NL> if next ( N ) == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> else print ( <STRING> ) <NEWLINE>
N = input ( ) <NEWLINE> for i in range 3 : <NEWLINE> <INDENT> if N [ i ] == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
N = input ( ) <NEWLINE> for i in range ( len ( N ) ) : <NEWLINE> <INDENT> if N [ i ] = <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> match_flg = 0 <NEWLINE> for nn in N : <NEWLINE> <INDENT> if ( nn == <STRING> ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> match_flg = 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if ( match_flg == 0 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = input ( ) <NEWLINE> print ( <STRING> if 7 in N else <STRING> ) <NEWLINE>
<COMMENT> <NL> input ( nm ) <NEWLINE> num = int ( nm ) <NEWLINE> num3 = num / 100 <NEWLINE> num2 = num / 10 % 10 <NEWLINE> num1 = num % 10 <NEWLINE> if ( num3 == 7 or num2 == 7 or num1 == 7 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <NL> <DEDENT>
if <STRING> in N : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a = input ( ) <NEWLINE> if <STRING> in a : <NEWLINE> <INDENT> print ( Yes ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( No ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> <NL> n = str ( n ) <NEWLINE> <NL> flag = 0 <NEWLINE> <NL> for i in n : <NEWLINE> <INDENT> if ( i != <STRING> ) : <NEWLINE> <INDENT> flag = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> flag = 1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if flag = 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> if n in 7 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT>
N = int ( input ( ) ) <NEWLINE> if 7 in N : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = input ( ) <NEWLINE> if <STRING> in j : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> for <STRING> in list ( s ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a = input ( ) <NEWLINE> i = 0 <NEWLINE> while i < len ( s ) : <NEWLINE> <INDENT> j = s [ i : i + 1 ] <NEWLINE> if j == 7 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> i += 1 <NEWLINE> <DEDENT>
a , b , c = input ( ) <NEWLINE> if a == <STRING> or b == <STRING> or c == <STRING> : <NEWLINE> <INDENT> print ( Yes ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( No ) <NEWLINE> <DEDENT>
N = input ( ) <NEWLINE> n = [ int ( c ) for c in s ] <NEWLINE> for ni in n : <NEWLINE> <INDENT> if ni == 7 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
<COMMENT> <NL> import sys <NEWLINE> N = sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> <NL> if <STRING> in N : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> import sys <NEWLINE> N = int ( sys . stdin . readline ( ) ) <NEWLINE> total = 0 <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> if i % 3 != 0 and i % 5 != 0 : <NEWLINE> <INDENT> total += i <NEWLINE> <NL> <DEDENT> <DEDENT> print ( total ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = N // 100 <NEWLINE> M = N % 100 <NEWLINE> <NL> B = M // 10 <NEWLINE> C = M % 10 <NEWLINE> <NL> if 7 in [ A , B , C ] : <NEWLINE> <INDENT> print ( Yes ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( No ) <NEWLINE> <DEDENT>
num = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> <NL> for i in range ( 2 ) : <NEWLINE> <INDENT> if num [ i ] == 7 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> elif num [ i ] != 7 : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> elif i == 2 & num [ i ] != 7 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
N = str ( input ( ) ) <NEWLINE> if str [ 0 ] == <STRING> or str [ 1 ] == <STRING> or str [ 2 ] == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> <NL> ans = <STRING> <NEWLINE> <NL> if n // 100 == 7 or n // 10 == 7 or n % 10 == 7 ( n // 10 ) % 10 == 7 : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
s = input ( ) <NEWLINE> a = [ int ( c ) for c in s ] <NEWLINE> <NL> if bool ( a [ 0 ] != 7 and a [ 1 ] != 7 and a [ 2 ] != 7 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = input ( ) <NEWLINE> n = 0 <NEWLINE> if N [ 0 ] == <STRING> : <NEWLINE> <INDENT> n += 1 <NEWLINE> <DEDENT> if N [ 1 ] == <STRING> : <NEWLINE> <INDENT> n += 1 <NEWLINE> <DEDENT> if N [ 2 } == <STRING> : <NEWLINE> <INDENT> n += 1 <NEWLINE> <NL> <DEDENT> if n > 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
input = x : <NEWLINE> if <STRING> in x : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
num = int ( input ( ) ) <NEWLINE> list = list ( num ) <NEWLINE> count = 0 <NEWLINE> <NL> for i in range ( 3 ) : <NEWLINE> <INDENT> if list [ i ] == 7 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if count == 3 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> None <NEWLINE> <DEDENT>
n = list ( input ( ) ) <NEWLINE> ans = <STRING> <NEWLINE> for i in range ( len ( n ) ) : <NEWLINE> <INDENT> if n [ i ] = <STRING> : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<INDENT> DVSR = 1000000007 <NEWLINE> def POW ( x , y ) : return pow ( x , y , DVSR ) <NEWLINE> def INV ( x , d = DVSR ) : return pow ( x , d - 2 , d ) <NEWLINE> def DIV ( x , y , d = DVSR ) : return ( x * INV ( y , d ) ) % d <NEWLINE> def LI ( ) : return [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> def LF ( ) : return [ float ( x ) for x in input ( ) . split ( ) ] <NEWLINE> def LS ( ) : return input ( ) . split ( ) <NEWLINE> def II ( ) : return int ( input ( ) ) <NEWLINE> <NL> n = II ( ) <NEWLINE> n = str ( n ) <NEWLINE> if <STRING> in n : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> lA = list ( str ( N ) ) <NEWLINE> flag = 0 <NEWLINE> for _ in range ( 3 ) : <NEWLINE> <INDENT> lA [ i ] == <STRING> : <NEWLINE> <INDENT> flag += 1 <NEWLINE> <DEDENT> <DEDENT> if flag != 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
S = input ( ) <NEWLINE> <NL> for i in range ( 3 ) : <NEWLINE> <INDENT> if S [ i ] == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> list ( N ) <NEWLINE> <NL> if N in 7 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = input ( ) <NEWLINE> <NL> if N [ 0 ] == 7 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else if N [ 1 ] == 7 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else if N [ 2 ] == 7 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
A = input ( ) <NEWLINE> for a in range ( 3 ) : <NEWLINE> <INDENT> if A [ a ] == <STRING> : <NEWLINE> <INDENT> print ( yes ) <NEWLINE> break <NEWLINE> <DEDENT> if a == 2 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
n = str ( N ) <NEWLINE> if n . find ( <STRING> ) != - 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a = int ( input ( ) ) <NEWLINE> toprint = False <NEWLINE> while a > 0 : <NEWLINE> <INDENT> last_digit = a % 10 <NEWLINE> a = a // 10 <NEWLINE> if last_digit == 7 : <NEWLINE> <INDENT> toprint = True <NEWLINE> <NL> <DEDENT> if toprint == True : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> if <STRING> in N : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = input ( ) <NEWLINE> print ( <STRING> if N . contains ( <STRING> ) else <STRING> ) <NEWLINE>
import math <NEWLINE> N = int ( input ( ) ) <NEWLINE> if N % 10 == 7 : <NEWLINE> <INDENT> print ( Yes ) <NEWLINE> <DEDENT> elif ( N - N % 10 ) % 100 == 70 : <NEWLINE> <INDENT> print ( Yes ) <NEWLINE> <DEDENT> elif N / 100 == 7 : <NEWLINE> <INDENT> print ( Yes ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( No ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> f = 0 <NEWLINE> c = 0 <NEWLINE> while n > 0 : <NEWLINE> <INDENT> c = n % 10 <NEWLINE> if c == 7 : <NEWLINE> <INDENT> f = 1 <NEWLINE> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> if f == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
numbers = str ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for ( i = 0 ; i < 3 ; i + + ) { <NEWLINE> <INDENT> if ( numbers [ i ] == <STRING> ) <NEWLINE> <INDENT> ans = 1 <NEWLINE> <DEDENT> <DEDENT> } <NEWLINE> if ( ans == 0 ) { <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> } else { <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> } <NEWLINE>
l , m , n = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = <STRING> <NEWLINE> if l == 7 or m == 7 or n == 7 : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> f = 0 <NEWLINE> a = N // 100 <NEWLINE> b = ( N - a * 100 ) // 10 <NEWLINE> c = N - a * 100 - b * 10 <NEWLINE> if a == 7 or b == 7 or c == 7 : <NEWLINE> <INDENT> f = 1 <NEWLINE> <DEDENT> if f == 1 : <NEWLINE> <INDENT> print ( Yes ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( No ) <NEWLINE> <DEDENT>
import sys <NEWLINE> n = input ( ) <NEWLINE> for i in n : <NEWLINE> <INDENT> if i == <STRING> <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( 0 ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> <NL>
N = list ( input ( ) ) <NEWLINE> for i in range ( 2 ) : <NEWLINE> <INDENT> if N [ i ] = 7 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
flg = 0 <NEWLINE> for s in n : <NEWLINE> <INDENT> if s == <STRING> : <NEWLINE> <INDENT> print ( s ) <NEWLINE> flg = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if flg == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = int ( imput ( ) ) <NEWLINE> for i in range ( 3 ) : <NEWLINE> <INDENT> if ( N % 10 ) == 7 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> N = N // 10 <NEWLINE> <DEDENT> if N != 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a = input ( ) <NEWLINE> if a . count ( 7 ) >= 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
Num = int ( input ( ) ) <NEWLINE> if <STRING> in Num : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a = list ( map ( int , input ( ) . sprit ( ) ) ) <NEWLINE> b = True <NEWLINE> for i in a <NEWLINE> <INDENT> if i == 7 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <INDENT> b = False <NEWLINE> break ; <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
p = list ( int ( input ( ) ) ) <NEWLINE> a = ( p [ 0 ] ) <NEWLINE> b = ( p [ 1 ] ) <NEWLINE> c = ( p [ 2 ] ) <NEWLINE> if a == 7 or b == 7 or c == 7 : <NEWLINE> <INDENT> print ( Yes ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( No ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> <NL> if <STRING> in n : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT>
n = input ( ) <NEWLINE> judge = False <NEWLINE> for i in range ( len ( n ) ) : <NEWLINE> <INDENT> if n [ i ] == 7 : <NEWLINE> <INDENT> judge = True <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if judge == True : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <NL> <DEDENT>
n = input ( ) <NEWLINE> print ( <STRING> if s . count ( <STRING> ) >= 1 else <STRING> ) <NEWLINE>
a = [ int ( input ( ) ) for i in range ( 3 ) ] <NEWLINE> b = a [ 1 ] <NEWLINE> c = a [ 1 ] <NEWLINE> d = a [ 2 ] <NEWLINE> if b == 7 or c == 7 or d == 7 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = input ( ) <NEWLINE> <INDENT> if N [ 0 ] == <STRING> or N [ 1 ] == <STRING> or N [ 2 ] == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
n = input ( ) <NEWLINE> if n [ 0 ] == <STRING> or n [ 1 ] == <STRING> or n [ 2 ] == <STRING> : <NEWLINE> <INDENT> print ( Yes ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> flag = 1 <NEWLINE> <NL> n_1 = ( n - ( n // 10 ) * 10 ) <NEWLINE> n_10 = ( n - ( n // 100 ) * 100 - n_1 ) // 10 <NEWLINE> n_100 = ( n - n_1 - n_10 * 10 ) // 100 <NEWLINE> <NL> if ( n_1 != 7 & & n_10 != 7 & & n_100 != 7 ) : <NEWLINE> <INDENT> flag = 0 <NEWLINE> <NL> <DEDENT> if flag == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
S = input ( ) <NEWLINE> if S // 100 == 7 : <NEWLINE> <INDENT> print ( Yes ) <NEWLINE> <DEDENT> elif ( S % 100 ) // 10 == 7 : <NEWLINE> <INDENT> print ( Yes ) <NEWLINE> <DEDENT> elif ( S % 100 ) % 10 == 7 : <NEWLINE> <INDENT> print ( Yes ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( No ) <NEWLINE> <DEDENT>
N = input ( ) <NEWLINE> for i in N : <NEWLINE> <INDENT> if i == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> return 0 <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> <NL>
data = input ( ) . split ( <STRING> ) <NEWLINE> res = <STRING> <NEWLINE> for i in data : <NEWLINE> <INDENT> if i == <STRING> : <NEWLINE> <INDENT> res = <STRING> <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( res ) <NEWLINE>
N = input ( ) <NEWLINE> def d ( N ) : <NEWLINE> <INDENT> return <STRING> if <STRING> in N else <STRING> <NEWLINE> <DEDENT> print ( d ( n ) ) <NEWLINE>
input_string = input ( ) <NEWLINE> while n < len ( input_string ) : <NEWLINE> <INDENT> if n == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> n += 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT>
A <NEWLINE> <COMMENT> <NL> N = int ( input ( ) ) <NEWLINE> <NL> <COMMENT> <NL> if <STRING> in str ( N ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
A = list ( int ( input ( ) ) ) <NEWLINE> <NL> if A [ 0 ] == 7 or A [ 1 ] == 7 or A [ 2 ] == 7 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s = <STRING> <NEWLINE> if s [ 0 ] = 7 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif s [ 1 ] = 7 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif s [ 2 ] = 7 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = input ( ) <NEWLINE> if <STRING> in s : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> if 7 in n : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT>
inp = input ( ) <NEWLINE> if inp . contains ( <STRING> ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> else : <NEWLINE> print ( <STRING> ) <NEWLINE> <DEDENT>
N = input ( ) <NEWLINE> <NL> if N [ 0 ] == <STRING> or N [ 1 ] == <STRING> or N [ 2 ] == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> else : <NEWLINE> print ( <STRING> ) <NEWLINE> <DEDENT>
n = input ( ) : <NEWLINE> A = [ 0 , 0 , 0 ] <NEWLINE> bool = 0 <NEWLINE> for i in range ( 3 ) : <NEWLINE> <INDENT> A [ i ] = N % 10 <NEWLINE> N = ( N - A [ i ] ) / 10 <NEWLINE> if A [ i ] == 7 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> bool = 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if bool == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = input ( ) <NEWLINE> if 7 in n : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> if 7 in n : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = int , input ( ) <NEWLINE> <NL> M = str ( N ) <NEWLINE> print ( M ) <NEWLINE> <NL> L = list ( map ( int , M ) ) <NEWLINE> print ( L ) <NEWLINE> <NL> if L [ 0 ] == 7 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> elif L [ 1 ] == 7 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> elif L [ 2 ] == 7 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N , X , Y = map ( int , input ( ) . split ( ) ) <NEWLINE> l = [ 0 ] * N - 1 <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> ans = min ( abs ( i - j ) , abs ( X - i ) + 1 + abs ( j - Y ) , abs ( Y - i ) + 1 + abs ( j - X ) ) <NEWLINE> l [ ans ] += 1 <NEWLINE> <DEDENT> <DEDENT> for t in l : <NEWLINE> <INDENT> print ( t ) <NEWLINE> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <DEDENT>
N = list ( input ( ) ) <NEWLINE> <NL> for i in N : <NEWLINE> <INDENT> if i == <STRING> <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = input ( ) <NEWLINE> if N [ 0 ] != <STRING> and N [ 1 ] != <STRING> N [ 2 ] != <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = list ( int ( input ( ) ) ) <NEWLINE> <NL> if 7 in n : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
def main ( ) : <COMMENT> <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> NUM = list ( str ( N ) ) <NEWLINE> NUM = list ( map ( int , NUM ) ) <NEWLINE> <COMMENT> <NL> for i in NUM : <NEWLINE> <INDENT> if int ( i ) == 7 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( 1 ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE>
N = input ( ) <NEWLINE> N = N . replace ( <STRING> ) <NEWLINE> print ( <STRING> if len ( N ) < 3 else <STRING> ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> if int ( N [ 0 ] ) == 7 , or int ( N [ 1 ] ) == 7 , int ( N [ 2 ] ) == 7 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
if N [ 0 ] == <STRING> or N [ 1 ] == <STRING> or N [ 2 ] == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( list ( input ( ) ) ) <NEWLINE> if 7 in n : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = input ( ) <NEWLINE> <NL> if 7 in N : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
answer = <STRING> <NEWLINE> for i in str ( N ) : <NEWLINE> <INDENT> if i == <STRING> : <NEWLINE> <INDENT> answer = <STRING> <NEWLINE> <DEDENT> <DEDENT> return answer <NEWLINE>
n = input ( ) <NEWLINE> if 7 in n : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
<COMMENT> <NL> N = input ( ) <NEWLINE> if <STRING> in a : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = str ( input ( ) ) <NEWLINE> print ( <STRING> , <STRING> ) [ N [ 0 ] != <STRING> and N [ 1 ] != <STRING> and N [ 2 ] != <STRING> ] <NEWLINE>
N = str ( input ( ) ) <NEWLINE> <NL> if N [ - 1 ] = <STRING> or N [ - 2 ] = <STRING> or N [ - 3 ] = <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a = int ( input ( ) ) <NEWLINE> aa = list ( str ( a ) ) <NEWLINE> n = 0 <NEWLINE> for i in range ( len ( aa ) ) : <NEWLINE> <INDENT> b = int ( aa [ i ] ) <NEWLINE> <INDENT> if b == 7 : <NEWLINE> <INDENT> n += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> n = n <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if n > 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
<NL> def main ( ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <INDENT> a = int ( input ( ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <NL> if <STRING> in a : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <COMMENT> <NL> <INDENT> main ( ) <NEWLINE> <DEDENT>
<INDENT> N = input ( ) <NEWLINE> a = <STRING> <NEWLINE> for n in N : <NEWLINE> <INDENT> if n == <STRING> : <NEWLINE> <INDENT> a = <STRING> <NEWLINE> <DEDENT> <DEDENT> print ( a ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> <NL> ans = count ( n ) <NEWLINE> <NL> if ans >= 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = input ( ) ; <NEWLINE> <NL> if N [ 0 ] == <STRING> or N [ 1 ] == <STRING> or N [ 2 ] == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) ; <NEWLINE> else : <NEWLINE> print ( <STRING> ) ; <NEWLINE> <DEDENT>
n = list ( input ( ) ) <NEWLINE> if int ( n [ 0 ] ) == 7 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if int ( n [ 1 ] ) == 7 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> else : <NEWLINE> if int ( n [ 2 ] ) == 7 : <NEWLINE> print ( <STRING> ) <NEWLINE> <INDENT> else : <NEWLINE> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
s = input ( ) <NEWLINE> f = False <NEWLINE> for i in s : <NEWLINE> <INDENT> if i == <STRING> : <NEWLINE> <INDENT> f = True <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if f : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = str ( inut ( ) ) <NEWLINE> if int ( N [ 0 ] ) == 7 or int ( N [ 1 ] ) == 7 or int ( N [ 2 ] ) == 7 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
x = int ( input ( ) ) <NEWLINE> j = False <NEWLINE> for i in range ( len ( x ) ) : <NEWLINE> <INDENT> if x [ i ] == 7 : <NEWLINE> <INDENT> j = True <NEWLINE> <DEDENT> <DEDENT> if j : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> flag = 0 <NEWLINE> while n > 0 : <NEWLINE> <INDENT> if n % 10 == 7 : <NEWLINE> <INDENT> flag += 1 <NEWLINE> n /= 10 <NEWLINE> <DEDENT> <DEDENT> if flag > 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> main ( ) <NEWLINE>
n = input ( ) <NEWLINE> n = int ( n ) <NEWLINE> if ( n % 10 == 7 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
n = input ( ) <NEWLINE> if n . count ( ) == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
if N [ 0 ] == <STRING> or N [ 1 ] == <STRING> or N [ 2 ] == <STRING> : print ( <STRING> ) <NEWLINE> else : print ( <STRING> ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> if 7 in n : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
count = 0 <NEWLINE> n = int ( input ( ) ) <NEWLINE> l = list ( map ( str , input ( ) ) ) <NEWLINE> i = 0 <NEWLINE> while i <= n - 3 : <NEWLINE> <INDENT> j = i + 1 <NEWLINE> while i + 1 <= j and j <= n - 2 : <NEWLINE> <INDENT> if l [ i ] == l [ j ] : <NEWLINE> <INDENT> j += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> k = j + 1 <NEWLINE> while j + 1 <= k and k <= n - 1 and k - j != j - i : <NEWLINE> <INDENT> if l [ i ] != l [ j ] and l [ j ] != l [ k ] : <NEWLINE> <INDENT> count += 1 <NEWLINE> k += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> k += 1 <NEWLINE> <DEDENT> <DEDENT> j += 1 <NEWLINE> <DEDENT> <DEDENT> i += 1 <NEWLINE> <DEDENT> print ( count ) <NEWLINE>
n = input ( ) <NEWLINE> for ni in n : <NEWLINE> <INDENT> if ni == <STRING> <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> quit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
n = input ( ) <NEWLINE> N = str ( n ) <NEWLINE> if <STRING> in N : <NEWLINE> <INDENT> print ( yes ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( no ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> n = input ( ) <NEWLINE> if n . count ( 7 ) > 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
a = input ( ) <NEWLINE> third = a % 100 <NEWLINE> second = a % 10 - thrid * 10 <NEWLINE> first = a - ( third * 100 + second * 10 ) <NEWLINE> if ( third == 7 or second == 7 or first == 7 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = list ( int ( input ( ) ) ) <NEWLINE> answer = <STRING> <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> if N [ i ] == 7 : <NEWLINE> <INDENT> answer = <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> print ( answer ) <NEWLINE>
N = input ( ) <NEWLINE> if int ( N [ 2 ] ) = 7 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif int ( N [ 1 ] ) = 7 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif int ( N [ 0 ] ) = 7 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
A = input ( ) <NEWLINE> <NL> if A in <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
N = input ( ) <NEWLINE> <NL> if N [ - 1 ] == 7 or N [ - 2 ] == 7 or N [ - 3 ] == 7 : <NEWLINE> <INDENT> print ( Yes ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( No ) <NEWLINE> <DEDENT>
i = input ( ) <NEWLINE> ans = <STRING> if <STRING> in 1 else <STRING> <NEWLINE> print ( ans ) <NEWLINE>
N = input ( ) <NEWLINE> if N [ 0 ] = <STRING> or N [ 1 ] = <STRING> or N [ 2 ] = <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = input ( ) <NEWLINE> count = 0 <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> if N [ i ] == 7 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> count += 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if count == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> if <STRING> in n : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
vv = list ( input ( ) ) <NEWLINE> <NL> ccc = <STRING> in vv <NEWLINE> <NL> if ccc = True : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = input ( ) <NEWLINE> judge = <STRING> <NEWLINE> for i in 3 : <NEWLINE> <INDENT> if N [ i ] == 7 : <NEWLINE> <INDENT> judge = <STRING> <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( judge ) <NEWLINE>
n = input ( ) <NEWLINE> if n < 100 or n > 999 : <NEWLINE> <INDENT> x = len ( n ) <NEWLINE> for i in range ( x ) : <NEWLINE> <INDENT> if n [ i ] is <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> flg = 0 <NEWLINE> if n [ 0 ] == 7 : <NEWLINE> <INDENT> flg = 1 <NEWLINE> <DEDENT> if n [ 1 ] == 7 : <NEWLINE> <INDENT> flg = 1 <NEWLINE> <DEDENT> if n [ 2 ] == 7 : <NEWLINE> <INDENT> flg = 1 <NEWLINE> <NL> <DEDENT> if flg == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s = str ( N ) <NEWLINE> if s . count ( <STRING> ) > 0 : <NEWLINE> <INDENT> print ( True ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( False ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> if n [ 1 ] == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> if n [ 2 ] == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> if n [ 3 ] == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = input ( ) <NEWLINE> if 7 in N : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> print ( <STRING> if <STRING> in n else <STRING> ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S = list ( input ( ) ) <NEWLINE> Sum = 0 <NEWLINE> for k in range ( 3 , N + 1 ) : <NEWLINE> <INDENT> for j in range ( 2 , k ) : <NEWLINE> <INDENT> for i in range ( 1 , j ) : <NEWLINE> <INDENT> if abs ( j - i ) != abs ( k - j ) : <NEWLINE> <INDENT> if S [ i - 1 ] != S [ j - 1 ] and S [ j - 1 ] != S [ k - 1 ] and S [ k - 1 ] != S [ i - 1 ] : <NEWLINE> <INDENT> Sum += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( Sum ) <NEWLINE>
N = input ( ) <NEWLINE> <NL> for i in range ( len ( N ) ) : <NEWLINE> <INDENT> if N [ i ] == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <INDENT> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
n = input ( ) <NEWLINE> print <STRING> if ( n . count ( <STRING> ) ) >= 1 else : <STRING> <NEWLINE>
N = int ( input ( ) ) <NEWLINE> <NL> [ int ( N ) for c in str ( N ) ] <NEWLINE> <NL> if 7 in N : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = input ( ) <NEWLINE> <NL> if <STRING> in N : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> else : <NEWLINE> print ( <STRING> ) <NEWLINE> <DEDENT>
N = str ( input ( ) ) <NEWLINE> if <STRING> in N : <NEWLINE> <INDENT> print ( <STRING> ) : <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s = str ( n ) <NEWLINE> flag = 0 <NEWLINE> <COMMENT> <NL> array = list ( map ( int , s ) ) <NEWLINE> <COMMENT> <NL> for i in array : <NEWLINE> <INDENT> if i == 7 : <NEWLINE> <INDENT> flag = 1 <NEWLINE> <DEDENT> <DEDENT> if flag == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = input ( ) <NEWLINE> if 7 in N : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a = input ( ) <NEWLINE> cnt = 0 <NEWLINE> for i in a : : <NEWLINE> <INDENT> if i == <STRING> : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( [ <STRING> , <STRING> ] [ cnt ] ) <NEWLINE>
N = input ( ) <NEWLINE> if <STRING> in N : <NEWLINE> <INDENT> pritn ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = input ( ) <NEWLINE> flag = false <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if N [ i ] == <STRING> : <NEWLINE> <INDENT> flag = true <NEWLINE> <DEDENT> <DEDENT> if flag : print ( <STRING> ) <NEWLINE> else : print ( <STRING> ) <NEWLINE>
import sys <NEWLINE> N = int ( input ) <NEWLINE> <NL> for i in range ( len ( N ) ) : <NEWLINE> <INDENT> if N [ i ] == 7 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
N = input ( ) <NEWLINE> x = N . count ( 7 ) <NEWLINE> print ( <STRING> if x > 0 <NEWLINE> <INDENT> else <STRING> ) <NEWLINE> <DEDENT>
import math <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> A = input ( ) <NEWLINE> B = input ( ) <NEWLINE> C = input ( ) <NEWLINE> <NL> bool = False <NEWLINE> <NL> if A == <STRING> : <NEWLINE> <INDENT> bool = True <NEWLINE> <NL> <DEDENT> elif B == <STRING> : <NEWLINE> <INDENT> bool = True <NEWLINE> <NL> <DEDENT> elif C == <STRING> : <NEWLINE> <INDENT> bool = True <NEWLINE> <NL> <NL> <DEDENT> if bool == True : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
in = input ( ) <NEWLINE> for i in range ( len ( in ) ) : <NEWLINE> <INDENT> if ( in [ i ] == <STRING> ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( 0 ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> s = input ( ) <NEWLINE> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> if ( s [ i ] == <STRING> ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( 0 ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
n = int ( input ) <NEWLINE> Flag = False <NEWLINE> for i in n : <NEWLINE> <INDENT> if i == 7 : <NEWLINE> <INDENT> Flag = True <NEWLINE> <DEDENT> <DEDENT> if Flag : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
x = map ( str , input ( ) ) <NEWLINE> a = str [ 0 ] <NEWLINE> b = str [ 1 ] <NEWLINE> c = str [ 2 ] <NEWLINE> <NL> if a == 7 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif b == 7 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif c == 7 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = str ( input ( ) ) <NEWLINE> flag = 0 <NEWLINE> for i in range ( len ( N ) ) : <NEWLINE> <INDENT> if int ( N [ i ] ) == 7 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> flag = 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> 101 if flag == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
print ( ( N * ( N + 1 ) / 2 ) - ( ( N // 3 ) * ( ( N // 3 ) + 1 ) / 2 ) - ( ( N // 5 ) * ( ( N // 5 ) + 1 ) / 2 ) + ( ( N // 15 ) * ( ( N // 15 ) + 1 ) / 2 ) ) <NEWLINE>
n = input ( ) <NEWLINE> sum = 0 <NEWLINE> <NL> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if i % 3 != 0 and i % 5 != 0 : <NEWLINE> <INDENT> sum += i <NEWLINE> <NL> <DEDENT> <DEDENT> print ( sum ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( N + 1 ) : <NEWLINE> <INDENT> if i % 3 != 0 and a % 5 != 0 : <NEWLINE> <INDENT> ans += i <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> <NL> for i in range ( 1 : n + 1 ) : <NEWLINE> <INDENT> if i % 5 != 0 and i % 3 != 0 : <NEWLINE> <INDENT> ans += i <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) . split ( ) ) <NEWLINE> <NL> print ( sum ( [ n + 1 for n in range ( N ) if ( n + 1 ) % 3 != 0 and ( n + 1 ) % 5 != 0 ] ) ) <NEWLINE>
n = int ( inupt ( ) ) <NEWLINE> sum = 0 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if n % 3 == 0 or n % 5 == 0 : <NEWLINE> <INDENT> sum += i <NEWLINE> <NL> <DEDENT> <DEDENT> print ( sum ) <NEWLINE>
<INDENT> i = int ( input ( ) ) <NEWLINE> i1 = i * ( i + 1 ) / 2 <NEWLINE> i2 = i // 3 <NEWLINE> i3 = i // 5 <NEWLINE> i4 = i2 * ( i2 + 1 ) / 2 <NEWLINE> i5 = i3 * ( i3 + 1 ) / 2 <NEWLINE> i6 = i // 15 <NEWLINE> i7 = i6 * ( i6 + 1 ) / 2 <NEWLINE> print ( i1 - i4 - i5 + i6 ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = [ ] <NEWLINE> for i in range ( N + 1 ) : <NEWLINE> <INDENT> if i + 1 % 3 != 0 and i + 1 % 5 != 0 <NEWLINE> <INDENT> A . append ( i ) <NEWLINE> <DEDENT> <DEDENT> print ( sum ( A ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> <NL> sum = 0 <NEWLINE> <NL> for i in N + 1 : <NEWLINE> <INDENT> if i % 3 == 0 or i % 5 == 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> sum += i <NEWLINE> <NL> <DEDENT> <DEDENT> print ( sum ) <NEWLINE>
N = input ( ) <NEWLINE> xx = 0 <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> if ( ( i % 3 != 0 ) & ( i % 5 != 0 ) ) : <NEWLINE> <INDENT> xx += i <NEWLINE> <DEDENT> <DEDENT> print ( xx ) <NEWLINE>
N = input ( ) <NEWLINE> sum = 0 <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> if i % 3 != 0 and i % 5 != 0 : <NEWLINE> <COMMENT> <NL> <INDENT> sum += i <NEWLINE> <DEDENT> <DEDENT> print ( sum ) <NEWLINE>
ans = 0 <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> if 0 != i % 3 and 0 != i % 5 : <NEWLINE> <INDENT> ans += i <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> an = [ a for a in range ( 1 , n + 1 ) ] <NEWLINE> o = [ ] <NEWLINE> def ass ( an ) : <NEWLINE> <INDENT> for c in an <NEWLINE> <INDENT> if c % 3 == 0 or c % 5 == 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> o . append ( c ) <NEWLINE> <DEDENT> <DEDENT> return sum ( o ) <NEWLINE> <DEDENT> print ( ass ( an ) ) <NEWLINE>
print ( sum ( [ i for i in range ( int ( input ( ) + 1 ) ) if ( i % 3 != 0 and i % 5 != 0 ) ] ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> <NL> total = sum ( [ i for i in range ( 1 , N + 1 ) if i % 3 != 0 and i % 5 != 0 ] <NEWLINE> print ( total ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> sum = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if i % 3 == 0 : <NEWLINE> elif i % 5 == 0 : <NEWLINE> else : <NEWLINE> <INDENT> sum += i <NEWLINE> <DEDENT> <DEDENT> print ( sum ) <NEWLINE>
import sys , os <NEWLINE> <NL> if __name__ == <STRING> : <NEWLINE> <INDENT> N = input ( ) <NEWLINE> s = 0 <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> if i % 3 == 0 or i % 5 == 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s += i <NEWLINE> <DEDENT> <DEDENT> print ( s ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> res = 0 <NEWLINE> for i in range ( N + 1 ) : <NEWLINE> <INDENT> if i % 3 != 0 & & i % 5 != 0 : <NEWLINE> <INDENT> res += i <NEWLINE> <DEDENT> <DEDENT> print ( res ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if i + 1 % 3 and i + 1 % 5 or i + 1 % 3 or i + 1 % 5 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> global S = S + 1 + i <NEWLINE> <NL> <NL> <DEDENT> <DEDENT>
import math <NEWLINE> <COMMENT> <NL> I = int ( input ( ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> a = 0 <NEWLINE> for num in range ( I ) : <NEWLINE> <INDENT> if num % 3 == 0 and num % 5 == 0 : <NEWLINE> <NL> elif num % 3 == 0 : <NEWLINE> <NL> elif num % 5 == 0 : <NEWLINE> <NL> else : <NEWLINE> <INDENT> a = a + num <NEWLINE> <NL> <DEDENT> <DEDENT> print ( a ) <NEWLINE>
a = int ( input ( ) ) <NEWLINE> b = ( ( a // 3 ) * ( 3 + ( 3 * ( a // 3 ) ) ) ) * ( 1 / 2 ) <NEWLINE> c = ( ( a // 5 ) * ( 5 + ( 5 * ( a // 5 ) ) ) ) * ( 1 / 2 ) <NEWLINE> d = ( ( a // 15 ) * ( 15 + ( 15 * ( a // 15 ) ) ) ) * ( 1 / 2 ) <NEWLINE> e = ( a ( 1 + a ) * ( 1 / 2 ) ) - ( b + c - d ) <NEWLINE> print ( e ) <NEWLINE>
def solve ( string ) : <NEWLINE> <INDENT> return str ( sum ( i for i in range ( n + 1 ) if i % 3 > 1 and i % 5 > 1 ) ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> import sys <NEWLINE> print ( solve ( sys . stdin . read ( ) . strip ( ) ) ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> S = 0 <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> if i % 3 == 0 or i % 5 == 0 or ( i % 3 == 0 and i % 5 == 0 ) : <NEWLINE> continue <NEWLINE> S += i <NEWLINE> <DEDENT> print ( S ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> print ( ( n + n ** 2 - 3 - 3 ( n // 3 ) - 3 ( ( n // 3 ) ** 2 ) - 5 ( n // 5 ) - 5 ( ( n // 5 ) ** 2 ) + 15 ( n // 15 ) + 15 ( ( n // 15 ) ** 2 ) ) / 2 ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> total = 0 <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> if i % 3 == 0 or i % 5 == 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> t = t + i <NEWLINE> <DEDENT> print ( total ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> print ( sum ( i for i in range ( i , n + 1 ) if i % 3 and i % 5 ) ) <NEWLINE>
a = int ( input ( ) ) <NEWLINE> b = [ ] <NEWLINE> if a <= 1000000 : <NEWLINE> for i in range ( a ) : <NEWLINE> <INDENT> if i % 15 == 0 : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> elif i % 3 == 0 : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> elif i % 5 == 0 : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> b . append ( i ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> print ( sum ( b ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> <NL> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> if i % 3 == 0 or i % 5 == 0 or i % 15 == 0 : <NEWLINE> <INDENT> continue <NEWLINE> cal += i <NEWLINE> <NL> <DEDENT> <DEDENT> print ( cal ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> sum = 0 <NEWLINE> for i in range ( n + 1 ) : <NEWLINE> <INDENT> not ( i % 3 == 0 and i % 5 == 0 ) : <NEWLINE> <INDENT> sum += i <NEWLINE> <DEDENT> <DEDENT> print ( sum ) <NEWLINE>
N = input ( ) <NEWLINE> tip = <STRING> <NEWLINE> if ( N [ 0 ] == 7 ) or ( N [ 1 ] == 7 ) or ( N [ 2 ] == 7 ) : <NEWLINE> <INDENT> tip = <STRING> <NEWLINE> <DEDENT> print ( tip ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if ( ( i % 3 == 0 ) and ( i % 5 == 0 ) ) : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> elif ( i % 3 == 0 ) : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> elif ( ( i % 5 == 0 ) ) : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> c += i <NEWLINE> <DEDENT> <DEDENT> print ( c ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> <NL> sum = 0 <NEWLINE> while a in range ( N + 1 ) : <NEWLINE> <INDENT> if a % 3 != 0 and a % 5 != 0 : <NEWLINE> <INDENT> sum = sum + a <NEWLINE> a = a + 1 <NEWLINE> <DEDENT> else : a = a + 1 <NEWLINE> <DEDENT> print ( sum ) <NEWLINE>
c = [ ] <NEWLINE> for i in range ( 1 , 3 * N1 ) : <NEWLINE> <INDENT> if i % 3 != 0 and i % 5 != 0 : <NEWLINE> <INDENT> c . append ( i ) <NEWLINE> print ( i ) <NEWLINE> <DEDENT> if i == N1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> sum ( c ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = 0 <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> if i % 3 != 0 and i % 5 != 0 : <NEWLINE> <INDENT> s += i <NEWLINE> <DEDENT> <DEDENT> print ( s ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> m = 0 <NEWLINE> <NL> for i in rane ( n + 1 ) : <NEWLINE> <INDENT> if n % 3 != 0 and n % 5 != 0 : <NEWLINE> <INDENT> m += i <NEWLINE> <NL> <DEDENT> <DEDENT> print ( m ) <NEWLINE> <NL>
N = int ( input ( ) ) <NEWLINE> for i in range ( 1 , 1 + N ) : <NEWLINE> <INDENT> if N % 3 != 0 or N % 5 != 0 : <NEWLINE> <INDENT> x += i <NEWLINE> <DEDENT> <DEDENT> print ( x ) <NEWLINE>
a = int ( input ( ) ) <NEWLINE> total = 0 <NEWLINE> while i < a : <NEWLINE> <INDENT> if i % 5 != 0 and i % 3 != 0 : <NEWLINE> <INDENT> total += a <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> <DEDENT> print ( total ) <NEWLINE>
print ( sum ( [ i for i in ( list ( range ( 1 , int ( input ( ) ) + 1 ) ) if i % 3 != 0 and i % 5 != 0 ] ) ) <NEWLINE>
import numpy as np <NEWLINE> <NL> <COMMENT> <NL> n = int ( input ( ) ) <NEWLINE> <NL> <COMMENT> <NL> def element_check ( before , after , matirx ) : <NEWLINE> <INDENT> diff = after - before <NEWLINE> if diff == 1 : <NEWLINE> <INDENT> a = np . delete ( matirx , - 1 ) <NEWLINE> return a <NEWLINE> <DEDENT> if diff == 2 : <NEWLINE> <INDENT> a = np . delete ( matirx , - 1 ) <NEWLINE> b = np . delete ( a , - 1 ) <NEWLINE> return b <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> def multiples_3 ( matrix ) : <NEWLINE> <COMMENT> <NL> <INDENT> m_de = np . delete ( fizzbuzz_list , [ 2 , 3 ] , axis = 1 ) <NEWLINE> <COMMENT> <NL> f_list = np . zeros ( j , dtype = object ) . reshape ( - 1 , 1 ) <NEWLINE> f_list . fill ( <STRING> ) <NEWLINE> <COMMENT> <NL> result = np . concatenate ( [ m_de , f_list ] , 1 ) <NEWLINE> return result <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> j = - ( - n // 3 ) <NEWLINE> <NL> <COMMENT> <NL> fizzbuzz_list = np . arange ( 1 , n + 1 , dtype = object ) <NEWLINE> <COMMENT> <NL> before_size = fizzbuzz_list . size <NEWLINE> <COMMENT> <NL> fizzbuzz_list . resize ( ( j , 3 ) ) <NEWLINE> <NL> <COMMENT> <NL> fizzbuzz_list = multiples_3 ( fizzbuzz_list ) <NEWLINE> <NL> <COMMENT> <NL> n_b_1 = np . arange ( 3 , j , 5 ) <NEWLINE> n_b_2 = np . arange ( 1 , j , 5 ) <NEWLINE> <NL> fizzbuzz_list [ n_b_1 , 0 ] = <STRING> <NEWLINE> fizzbuzz_list [ n_b_2 , 1 ] = <STRING> <NEWLINE> <NL> <COMMENT> <NL> n_fb = np . arange ( 4 , j , 5 ) <NEWLINE> fizzbuzz_list [ n_fb , 2 ] = <STRING> <NEWLINE> <NL> <COMMENT> <NL> result = element_check ( before_size , fizzbuzz_list . ravel ( ) . size , fizzbuzz_list . ravel ( ) ) <NEWLINE> <NL> print ( np . sum ( result ) ) <NEWLINE> <NL> <COMMENT> <NL>
N = input ( ) <NEWLINE> Sum = 0 <NEWLINE> <NL> for k in range ( N ) : <NEWLINE> <INDENT> i = k + 1 <NEWLINE> <NL> if i % 3 != 0 : <NEWLINE> <INDENT> if i % 5 != 0 : <NEWLINE> <INDENT> Sum = Sum + i <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( Sum ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> l = [ ] <NEWLINE> sum = 0 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if i % 3 == 0 and i % 5 == 0 : <NEWLINE> <INDENT> l . apoend ( <STRING> ) <NEWLINE> <DEDENT> elif i % 3 == 0 and i % 5 != 0 : <NEWLINE> <INDENT> l . append ( <STRING> ) <NEWLINE> <DEDENT> elif i % 5 == 0 and i % 3 != 0 : <NEWLINE> <INDENT> l . append ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> l . append ( i ) <NEWLINE> sum += i <NEWLINE> <DEDENT> <DEDENT> print ( sum ) <NEWLINE> <NL> <NL>
N = input ( ) <NEWLINE> sum = 0 <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> if i % 3 != 0 and i % 5 != 0 : <NEWLINE> <INDENT> sum += i <NEWLINE> <NL> <DEDENT> <DEDENT> print ( sum ) <NEWLINE>
<NL> N = input ( ) <NEWLINE> N = int ( N ) <NEWLINE> <NL> s_all = sum ( N ) <NEWLINE> fizz = sum ( list ( range ( 3 , N , 3 ) ) ) <NEWLINE> buzz = sum ( list ( range ( 5 , N , 5 ) ) ) <NEWLINE> <NL> fb = sum ( list ( range ( 15 , N , 15 ) ) ) <NEWLINE> <NL> print ( s_all - fizz - buzz + fb ) <NEWLINE>
str = input ( ) <NEWLINE> if str [ 0 ] == <STRING> or str [ 1 ] == <STRING> or str [ 2 ] == <STRING> : print ( <STRING> ) <NEWLINE> else : print ( <STRING> ) <NEWLINE>
import math <NEWLINE> Nstring = int ( input ( ) ) <NEWLINE> ans = ( N * ( N + 1 ) ) / 2 <NEWLINE> ans = ans - math . floor ( N / 3 ) <NEWLINE> ans = ans - math . floor ( N / 5 ) <NEWLINE> ans = ans + math . floor ( N / 15 ) <NEWLINE> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> <NL> print ( sum ( filter ( lambda x : x % 3 != 0 or x % 5 != , range ( N ) ) ) ) <NEWLINE> <NL>
n = int ( input ( ) ) <NEWLINE> sum = 0 <NEWLINE> <NL> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if i % 3 != 0 & & i % 5 != 0 : <NEWLINE> <INDENT> sum += i <NEWLINE> <NL> <DEDENT> <DEDENT> print ( sum ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> output_list = [ ] <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> if i % 3 == 0 or i % 5 == 0 or i % 15 == 0 : <NEWLINE> else : <NEWLINE> <INDENT> output_list . append ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( sum ( output_list ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( n + 1 ) : <NEWLINE> <INDENT> if not ( i % 3 == 0 or i % 5 == 0 ) : <NEWLINE> ans += i <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
n = input ( ) <NEWLINE> sum = 0 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if i % 3 == 0 or i % 5 == 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> sum += i <NEWLINE> <DEDENT> <DEDENT> print ( sum ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> sum = 0 <NEWLINE> <NL> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> if i % 3 == 0 or i % 5 == 0 : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += i <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<NL> <NL> N = int ( input ( ) ) <NEWLINE> <NL> fizzbuzz = [ ] <NEWLINE> <NL> for i in range ( 1 , N ) : <NEWLINE> <INDENT> if i % 15 == 0 : <NEWLINE> <INDENT> fizzbuzz . append ( <STRING> ) <NEWLINE> <DEDENT> elif i % 3 == 0 : <NEWLINE> <INDENT> fizzbuzz . append ( <STRING> ) <NEWLINE> <DEDENT> elif i % 5 == 0 : <NEWLINE> <INDENT> fizzbuzz . append ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> fizzbuzz . append ( str ( i ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> num = [ int ( s ) for s in fizzbuzz ] <NEWLINE> print ( int ( sum ( num ) ) L ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> sum = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if i % 5 != 0 and i % 3 = 0 : <NEWLINE> <INDENT> sum = sum + 1 <NEWLINE> <DEDENT> <DEDENT> print ( sum ) <NEWLINE>
n = int ( input ) <NEWLINE> count = 0 <NEWLINE> for i in range ( 0 , n ) : <NEWLINE> <INDENT> if ( i + 1 ) % 3 == 0 : <NEWLINE> <INDENT> count = count <NEWLINE> <DEDENT> elif ( i + 1 ) % 5 == 0 : <NEWLINE> <INDENT> count = count <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> count = count + i + 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> N = input ( ) <NEWLINE> sum = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> i = i + 1 <NEWLINE> if i % 3 == 0 or i % 5 == 0 or i % 15 == 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> sum = sum + i <NEWLINE> <NL> <DEDENT> <DEDENT> print ( sum ) <NEWLINE> <NL> <NL> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N = input ( ) <NEWLINE> <NL> k = N // 3 <NEWLINE> l = N // 5 <NEWLINE> m = N // 15 <NEWLINE> <NL> sum = ( N * ( N + 1 ) / 2 ) - ( 3 * ( - 1 + 3 ** k ) / 2 ) - ( 5 * ( - 1 + 5 ** l ) / 4 ) + ( 15 * ( - 1 + 15 ** k ) / 14 ) <NEWLINE> print ( sum ) <NEWLINE>
N = input ( ) <NEWLINE> <NL> list = [ i for i in range ( 1 , N + 1 ) if ( i % 3 != 0 or i % 5 != 0 ) ] <NEWLINE> print ( sum ( list ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> fb = long ( 0 ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if ( i % 5 != 0 and i % 3 != 0 ) : <NEWLINE> <INDENT> fb = fb + i <NEWLINE> <NL> <DEDENT> <DEDENT> print ( fb ) <NEWLINE>
n = input ( ) <NEWLINE> sum = 0 <NEWLINE> <NL> for i in range ( 1 , n + 1 , 1 ) : <NEWLINE> <INDENT> if ( i % 3 == 0 or i % 5 == 0 ) : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> sum += i <NEWLINE> <NL> <DEDENT> print ( sum ) <NEWLINE> <NL>
asn = int ( 0 ) <NEWLINE> for i in range ( int ( input ( ) ) ) : <NEWLINE> <INDENT> if i % 3 != 0 and i % 5 != 0 : <NEWLINE> <INDENT> ans += i <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
ef to_fizzbuzz ( number ) : <NEWLINE> <INDENT> if number % 15 == 0 : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <NL> <DEDENT> if number % 3 == 0 : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <NL> <DEDENT> if number % 5 == 0 : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> return str ( number ) <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> <COMMENT> <NL> fblist = [ ] <NEWLINE> for number in range ( 1 , 10 ** 6 ) : <NEWLINE> <INDENT> result = to_fizzbuzz ( number ) <NEWLINE> fblist . append ( result ) <NEWLINE> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <DEDENT> n_list = fblist [ 0 : N ] <NEWLINE> <COMMENT> <NL> <NL> n_numlist = [ ] <NEWLINE> <NL> for s in n_list : <NEWLINE> <INDENT> if s . isdigit ( ) == True : <NEWLINE> <INDENT> n_numlist . append ( int ( s ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( sum ( n_numlist ) ) <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> re = 0 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if ( i % 3 != 0 ) and ( i % 5 != 0 ) <NEWLINE> <INDENT> re += i <NEWLINE> <DEDENT> <DEDENT> print ( re ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if i % 3 != 0 and i % 5 != 0 : <NEWLINE> <INDENT> ans += i <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
i = int ( input ) <NEWLINE> fizz = [ ] <NEWLINE> for x in i : <NEWLINE> <INDENT> if x % 3 == 0 and x % 5 == 0 : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> elif x % 3 == 0 : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> elif x % 5 == 0 : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> fizz . append ( i ) <NEWLINE> <DEDENT> <DEDENT> print ( sum ( fizz ) ) <NEWLINE>
import sys <NEWLINE> import numpy as np <NEWLINE> n = int ( input ( ) ) <NEWLINE> A = np . arrange ( N + 1 ) <NEWLINE> count = 0 <NEWLINE> <NL> for i in range ( N + 1 ) : <NEWLINE> <INDENT> if A [ i ] % 3 != 0 and A [ i ] % 5 != 0 and A [ i ] % 15 != 0 : <NEWLINE> count = count + A [ i ] <NEWLINE> <DEDENT> print ( count ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> print ( sum ( [ i for i in range ( 1 , n + 1 ) if and i % 5 != 0 and i % 3 != 0 ] ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> sum = 0 <NEWLINE> <NL> if ( 1 <= N <= 10 ** 6 ) : <NEWLINE> <NL> <INDENT> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if ( i % 3 == 0 ) and ( i % 5 == 0 ) : <NEWLINE> <INDENT> n = <STRING> <NEWLINE> <DEDENT> elif ( i % 3 == 0 ) : <NEWLINE> <INDENT> n = <STRING> <NEWLINE> <DEDENT> elif ( i % 5 == 0 ) : <NEWLINE> <INDENT> n = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> sum += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( sum ) <NEWLINE>
a = input ( ) <NEWLINE> lists = [ i + 1 for i in range ( a ) ] <NEWLINE> for t in lists : <NEWLINE> <INDENT> if t % 5 == 0 : <NEWLINE> <INDENT> lists . remove ( t ) <NEWLINE> <DEDENT> elif t % 3 == 0 : <NEWLINE> <INDENT> lists . remove ( t ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( sum ( lists ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> sum_ = 0 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if i % 15 != 0 : <NEWLINE> <INDENT> sum += i <NEWLINE> <NL> <DEDENT> <DEDENT> print ( sum_ ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> total = 0 <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> if i % 3 != 0 and i % 5 != 0 : <NEWLINE> <INDENT> total += i <NEWLINE> <DEDENT> <DEDENT> print ( total ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if ( i % 3 == 0 ) and ( i % 5 == 0 ) : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if ( i % 3 == 0 ) : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if ( i % 5 == 0 ) : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> ans += i <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <DEDENT> main ( <NEWLINE>
for i in range ( n ) : <NEWLINE> <INDENT> if i % 3 != 0 and i % 5 != 0 : <NEWLINE> <INDENT> ans += i <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> <INDENT> total = 0 <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <DEDENT> if i % 3 != 0 and i % 5 = 0 <NEWLINE> <INDENT> total += i <NEWLINE> print ( total ) <NEWLINE> <DEDENT>
N = input ( ) ; <NEWLINE> sum = 0 ; <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> num = i + 1 ; <NEWLINE> if num % 3 != 0 and num % 5 != 0 : <NEWLINE> <INDENT> sum += num ; <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> pass ; <NEWLINE> <NL> <DEDENT> <DEDENT> print ( num ) <NEWLINE> <NL>
N = int ( input ( ) ) <NEWLINE> a = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> x = i + 1 <NEWLINE> if x % 3 != 0 andx % 5 != 0 : <NEWLINE> <INDENT> a += x <NEWLINE> <DEDENT> <DEDENT> print ( x ) <NEWLINE>
print ( sum ( [ x for x in range ( a , int ( input ( ) ) + 1 ) if ( x % 3 != 0 ) and ( x % 5 != 0 ) ] ) ) <NEWLINE>
n = input ( ) <NEWLINE> i = 1 <NEWLINE> result = 0 <NEWLINE> while ( i <= n ) : <NEWLINE> <INDENT> if ( i % 3 != 0 and i % 5 != 0 ) : <NEWLINE> <INDENT> result += i <NEWLINE> <DEDENT> i += 1 <NEWLINE> <DEDENT> print ( result ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> l = i for i in range ( 1 , int ( input ( ) ) + 1 ) if i % 3 != 0 and i % 5 != 0 <NEWLINE> s = sum ( l ) <NEWLINE> print ( s ) <NEWLINE>
n = input ( ) <NEWLINE> b = 0 <NEWLINE> s = 0 <NEWLINE> for i in n : <NEWLINE> <INDENT> if i % 3 == 0 or i % 5 == 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s += i <NEWLINE> <NL> <DEDENT> <DEDENT> print ( s ) <NEWLINE>
x = input ( ) <NEWLINE> N = 0 <NEWLINE> <NL> for i in range ( x ) : <NEWLINE> <INDENT> if i % 3 == 0 and i % 5 == 0 : <NEWLINE> <INDENT> i = <STRING> <NEWLINE> <DEDENT> elif i % 3 == 0 : <NEWLINE> <INDENT> i = <STRING> <NEWLINE> <DEDENT> elif i % 5 == 0 : <NEWLINE> <INDENT> i = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> N = i + N <NEWLINE> <NL> <DEDENT> <DEDENT> print ( N ) <NEWLINE>
N = input ( ) <NEWLINE> a = 0 <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> if i % 5 != 0 and i % 3 != 0 : <NEWLINE> <INDENT> a += i <NEWLINE> <DEDENT> <DEDENT> print ( a ) <NEWLINE>
n = input ( ) <NEWLINE> total = 0 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> if ( i % 3 != 0 ) and ( i % 5 != 0 ) : <NEWLINE> <INDENT> total += i <NEWLINE> <NL> <DEDENT> <DEDENT> print ( total ) <NEWLINE>
A = int ( input ( ) ) <NEWLINE> total = 0 L <NEWLINE> for x in range ( A + 1 ) : <NEWLINE> <INDENT> if x % 5 != 0 and x % 3 != 0 : <NEWLINE> <INDENT> total += x <NEWLINE> <DEDENT> <DEDENT> print ( x ) <NEWLINE>
<COMMENT> <NL> <NL> n = int ( input ( ) ) <NEWLINE> total = 0 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if ( i % 3 ) != 0 and ( i % 5 ) != 0 : <NEWLINE> <INDENT> total += <NEWLINE> <DEDENT> <DEDENT> print ( total ) <NEWLINE>
import sys <NEWLINE> <NL> X = input ( ) <NEWLINE> count = 0 <NEWLINE> for num in range ( X ) : <NEWLINE> <INDENT> if not num % 3 == 0 or num % 5 == 0 : <NEWLINE> <INDENT> count = count + num <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
print ( <STRING> if input ( ) . find ( <STRING> ) >= 0 else <STRING> ) <NEWLINE> n = int ( input ( ) ) + 1 <NEWLINE> a = set ( range ( 0 , n ) ) <NEWLINE> fs = set ( range ( 0 , n , 3 ) ) <NEWLINE> bs = set ( range ( 0 , n , 5 ) ) <NEWLINE> print ( sum ( a - fs - bs ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> sum = 0 <NEWLINE> <NL> for i in range [ n + 1 ] : <NEWLINE> <INDENT> if i % 3 == 1 or i % 3 == 2 : <NEWLINE> <INDENT> if i % 5 == 1 or i % 5 == 2 or i % 5 == 3 or i % 5 == 4 : <NEWLINE> <INDENT> sum += i <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print sum <NEWLINE>
n = input ( a ) <NEWLINE> n . remove ( <STRING> , <STRING> , <STRING> ) <NEWLINE> print ( sum ( n ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> list = [ ] <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> if ( i + 1 ) % 3 == 0 : <NEWLINE> <NL> elif ( i + 1 ) % 5 == 0 : <NEWLINE> <NL> else : <NEWLINE> <INDENT> list . append ( i + 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( sum ( list ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> k = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> j = i + 1 <NEWLINE> if ( j % 3 != 0 ) & & ( j % 5 != 0 ) : <NEWLINE> <INDENT> k = k + j <NEWLINE> <DEDENT> <DEDENT> print ( k ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> a = [ i for i in range ( N + 1 ) ] <NEWLINE> for i in range ( N + 1 ) : <NEWLINE> <INDENT> if i % 3 == 0 or i % 5 == 0 : <NEWLINE> <INDENT> del ( a [ i ] ) <NEWLINE> <DEDENT> <DEDENT> sum ( a ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> cnt += 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if i % 5 != 0 and i % 3 != 0 : <NEWLINE> <INDENT> cnt += i <NEWLINE> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
n = list ( range ( 1 , int ( input ( ) ) + 1 ) ) <NEWLINE> print ( sum [ i for i in n if i % 3 != 0 and i % 5 != 0 ] ) <NEWLINE>
n = input ( ) <NEWLINE> sum = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if i % 3 != 0 and i % 5 != 0 : <NEWLINE> <INDENT> sum += i <NEWLINE> <NL> <DEDENT> <DEDENT> print ( sum ) <NEWLINE>
f = t // 5 <NEWLINE> tt = t // 3 <NEWLINE> ff = t // 15 <NEWLINE> f = ( f * ( f + 1 ) // 2 ) * 5 <NEWLINE> tt = ( tt * ( tt + 1 ) // 2 ) * 3 <NEWLINE> ff = ( ff * ( ff + 1 ) // 2 ) * 15 <NEWLINE> print ( t * ( t + 1 ) // 2 - f - tt + ff ) <NEWLINE>
n = input ( ) <NEWLINE> sum1 = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if not ( i % 3 == 0 or i % 5 == 0 ) : <NEWLINE> <INDENT> sum1 = sum1 + i <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> sum1 = sum1 <NEWLINE> <DEDENT> <DEDENT> print ( sum1 ) <NEWLINE>
n = int ( iniput ( ) ) <NEWLINE> sm = 0 <NEWLINE> for i in range ( 1 , n + 1 , 1 ) : <NEWLINE> <INDENT> if i % 3 and i % 5 : <NEWLINE> <INDENT> sm += i <NEWLINE> <DEDENT> <DEDENT> print ( sm ) <NEWLINE>
N = input ( ) <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> if i % 3 != 0 and i % 5 != 0 : <NEWLINE> <INDENT> ans += i <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = input ( int ( ) ) <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> if i % 15 == 0 : <NEWLINE> <INDENT> i = <STRING> <NEWLINE> <DEDENT> elif i % 3 == 0 : <NEWLINE> <INDENT> i = <STRING> <NEWLINE> <DEDENT> elif i % 5 == 0 : <NEWLINE> <INDENT> i = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> i = i <NEWLINE> print ( sum ( i ) ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> count = 0 ; <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> if i % 3 != 0 & & i % 5 != 0 : <NEWLINE> <INDENT> count += i <NEWLINE> <NL> <DEDENT> <DEDENT> print ( i ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if i % 3 != 0 and i % 5 = != 0 : <NEWLINE> <INDENT> ans = ans + i <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = input ( ) <NEWLINE> <NL> <NL> count = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if N % 15 == 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> elif N % 3 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> elif N % 5 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> count += i <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> i = 1 <NEWLINE> for i in N + 1 : <NEWLINE> <INDENT> if not i % 3 == 0 or i % 5 == 0 : <NEWLINE> <INDENT> m += i <NEWLINE> <NL> <DEDENT> <DEDENT> print ( m ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> sum = 0 <NEWLINE> for i in range ( 1 , n + 1 ) <NEWLINE> <INDENT> if i % 3 != 0 and i % 5 != 0 : <NEWLINE> <INDENT> sum += i <NEWLINE> <DEDENT> <DEDENT> print ( sum ) <NEWLINE>
seq = raw_input ( ) <NEWLINE> <NL> total = int ( 0 ) <NEWLINE> for i in range ( 1 , int ( seq ) + 1 , 1 ) : <NEWLINE> <INDENT> if ( ( i % 3 ) != 0 ) and ( ( i % 5 ) != 0 ) : <NEWLINE> <INDENT> total = total + i <NEWLINE> <DEDENT> <DEDENT> print ( total ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> L = [ 0 if x // 3 == 0 or x // 5 == 0 else x for x in range ( 1 , 16 ) ] <NEWLINE> Q = N // 15 <NEWLINE> R = N % 15 <NEWLINE> S = 30 * Q * ( Q + 1 ) + sum ( L [ R - 1 ] ) <NEWLINE> print ( S ) <NEWLINE>
s = input ( ) . split ( ) <NEWLINE> n = int ( s ) <NEWLINE> sum = 0 <NEWLINE> for i range ( 1 , n + 1 ) : <NEWLINE> <INDENT> print ( n ) <NEWLINE> if ( ( i mod 3 ) != 0 ) and ( ( i mod 5 ) != 0 ) : <NEWLINE> <INDENT> sum += i <NEWLINE> <DEDENT> <DEDENT> print ( sum ) <NEWLINE>
* x , = range ( int ( input ( ) ) + 1 ) ; x [ : : 3 ] = x [ : : 5 ] = 0 ; print ( sum ( x ) ) <NEWLINE>
a = [ ] <NEWLINE> b = [ ] <NEWLINE> for i in range ( input ( ) ) : <NEWLINE> <INDENT> if i % 3 != 0 and i % 5 != 0 : <NEWLINE> <INDENT> a . append ( i ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> b . append ( i ) <NEWLINE> <DEDENT> <DEDENT> print ( sum ( a ) ) <NEWLINE>
N = int ( input ( ) ) : <NEWLINE> cnt = 0 <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> if i % 3 == 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if i % 5 == 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if i % 15 == 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cnt += i <NEWLINE> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
<INDENT> m = int ( input ( ) ) <NEWLINE> <NL> def fizz_buzz ( i ) : <NEWLINE> <INDENT> fizz = i % 3 <NEWLINE> buzz = i % 5 <NEWLINE> <NL> return ( fizz > 0 ) & & ( buzz > 1 ) <NEWLINE> <NL> <DEDENT> res = 0 <NEWLINE> <NL> for i in range ( m ) : <NEWLINE> <INDENT> use_i = i + 1 <NEWLINE> if fizz_buzz ( use_i ) : <NEWLINE> <INDENT> res += use_i <NEWLINE> <NL> <DEDENT> <DEDENT> print ( res ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> <NL> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if i % 3 == 0 or i % 5 == 0 : <NEWLINE> <INDENT> sum += i <NEWLINE> <DEDENT> <DEDENT> print ( sum ) <NEWLINE>
a = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> i = 1 <NEWLINE> while i <= a : <NEWLINE> <INDENT> if i % 3 == 0 : <NEWLINE> <INDENT> i += 1 <NEWLINE> continue <NEWLINE> <DEDENT> elif i % 5 == 0 : <NEWLINE> <INDENT> i += 1 <NEWLINE> continue <NEWLINE> <DEDENT> ans += a <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
n = list ( range ( 1 , input ( ) + 1 ) ) <NEWLINE> n = ( [ i for i in n if i % 3 != 0 and i % 5 != 0 ] ) <NEWLINE> print ( sum ( n ) ) <NEWLINE>
n = map ( int , input ( ) . split ( ) ) <NEWLINE> num = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if ( i % 3 != 0 ) and ( i % 5 != 0 ) : <NEWLINE> <INDENT> num += i <NEWLINE> <DEDENT> <DEDENT> print ( num ) <NEWLINE>
n = input ( ) <NEWLINE> ans = 0 <NEWLINE> <NL> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if i % 3 != 0 and i % 5 != 0 : <NEWLINE> <INDENT> ans += i <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> result = 0 <NEWLINE> a <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if i % 3 == 0 and i % 5 == 0 : <NEWLINE> <INDENT> a = result <NEWLINE> <DEDENT> elif i % 3 == 0 : <NEWLINE> <INDENT> a = result <NEWLINE> <DEDENT> elif i % 5 == 0 : <NEWLINE> <INDENT> a = result <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> result = result + i <NEWLINE> <NL> <DEDENT> <DEDENT> print ( result ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> seq = [ i for in range ( 1 , N ) <NEWLINE> count = 0 <NEWLINE> for t in range ( len ( seq ) ) : <NEWLINE> <INDENT> if seq [ t ] % 3 != 0 or seq [ t ] % 5 != 0 : <NEWLINE> <INDENT> count += seq [ t ] <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
x = input ( ) <NEWLINE> sum = 0 <NEWLINE> for i in range ( x + 1 ) : <NEWLINE> <INDENT> if i % 3 or i % 5 : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> sum += i <NEWLINE> <DEDENT> <DEDENT> print ( sum ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> sum = 0 <NEWLINE> <NL> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if i % 15 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif i % 3 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif i % 5 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> sum = sum + i <NEWLINE> <DEDENT>
N = input ( ) <NEWLINE> N = int ( N ) <NEWLINE> <NL> allsum = ( N + 1 ) * int ( N / 2 ) <NEWLINE> <NL> fum = int ( N / 3 ) <NEWLINE> bsum = int ( N / 5 ) <NEWLINE> fbsum = int ( N / 15 ) <NEWLINE> <NL> print ( allsum - fsum * 3 - bsum * 5 + fbsum * 15 ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if i % 3 != 0 ans i % 5 != 0 : <NEWLINE> <INDENT> ans += i <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<INDENT> fizzBuzz = [ ] <NEWLINE> inputNumber = int ( input ( ) ) <NEWLINE> for i in range ( inputNumber + 1 ) : <NEWLINE> <INDENT> if i % 3 == 0 and i % 5 == 0 : <NEWLINE> <INDENT> metCondition = <STRING> <NEWLINE> <DEDENT> elif i % 5 == 0 : <NEWLINE> <INDENT> metCondition = <STRING> <NEWLINE> <DEDENT> elif i % 3 == 0 : <NEWLINE> <INDENT> metCondition = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> metCondition = i <NEWLINE> <DEDENT> fizzBuzz . append ( metCondition ) <NEWLINE> <DEDENT> metCondition_2 = [ num for num in fizzBuzz if isinstance ( num , ( int , float ) ) ] <NEWLINE> print ( sum ( metCondition_2 ) ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> sum = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if n % 3 != = 0 and n % 5 != = 0 : <NEWLINE> <INDENT> sum += i <NEWLINE> <DEDENT> <DEDENT> print ( sum ) <NEWLINE>
import sys <NEWLINE> a = sys . argv [ 1 ] <NEWLINE> t = sum ( [ i for i in range ( int ( a ) + 1 ) if i % 5 != 0 and i % 3 != 0 ] ) <NEWLINE> print ( t ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if i % 3 != 0 and i % 5 != 0 <NEWLINE> <INDENT> ans += i <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> if ( i % 3 == 0 ) and ( i % 5 == 0 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif i % 3 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif i % 5 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( str ( number ) ) <NEWLINE> <NL> <DEDENT> <DEDENT>
x = 0 <NEWLINE> n = input ( input ( ) ) <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if i % 3 != 0 and i % 5 != 0 : <NEWLINE> <INDENT> x += i <NEWLINE> <DEDENT> <DEDENT> print ( x ) <NEWLINE>
n = input ( ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if i % 3 == 0 or i % 5 == 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> ans += i <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range1 , ( N + 1 ) : <NEWLINE> <INDENT> if i % 3 != 0 and i % 5 != 0 : <NEWLINE> <INDENT> ans += i <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> summ = 0 <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> if i % 3 != 0 and i % 5 != 0 : <NEWLINE> <INDENT> summ += i <NEWLINE> <DEDENT> <DEDENT> print ( summ ) n = int ( input ( ) ) <NEWLINE> summ = 0 <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> if i % 3 != 0 and i % 5 != 0 : <NEWLINE> <INDENT> summ += i <NEWLINE> <DEDENT> <DEDENT> print ( summ ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , i + 1 ) : <NEWLINE> <INDENT> if i % 3 != 0 and i % 5 != 0 : <NEWLINE> <INDENT> ans += i <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = input ( ) <NEWLINE> s = 0 <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> if i % 3 == 0 and i % 5 == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> elif i % 3 == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> elif i % 5 == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s += i <NEWLINE> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> if ( N + 1 ) % != 3 and ( N + 1 ) % != 5 : <NEWLINE> <INDENT> ans += i <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
FizzBuzz = int ( input ( ) ) <NEWLINE> <NL> Sum = [ ] <NEWLINE> for i in range ( FizzBizz ) : <NEWLINE> <INDENT> if FizzBuzz [ i ] % 3 == 0 and FizzBuzz [ i ] % 5 == 0 : <NEWLINE> <INDENT> Sum . append ( i ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> Sum . append ( 0 ) <NEWLINE> <DEDENT> <DEDENT> print ( sum ( Sum ) ) <NEWLINE>
a = int ( input ( ) ) <NEWLINE> b = [ ] <NEWLINE> for i in range ( a + 1 ) : <NEWLINE> <INDENT> if i % 3 == 0 : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> elif i 5 5 == 0 : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> b . append ( i ) <NEWLINE> <DEDENT> <DEDENT> c = sum ( b ) <NEWLINE> print ( c ) <NEWLINE>
k = 0 <NEWLINE> int n = int ( input ( ) ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if i % 3 != 0 and i % 5 != 0 : <NEWLINE> <INDENT> k += i <NEWLINE> <NL> <DEDENT> <DEDENT> print ( k ) <NEWLINE>
<INDENT> = int ( input ( ) ) <NEWLINE> <DEDENT> l = [ i for i in range ( 1 , n + 1 ) ] <NEWLINE> nl = [ ] <NEWLINE> <NL> for a in l : <NEWLINE> <INDENT> if a % 15 != 0 or a % 5 != 0 or a % 3 != 0 : <NEWLINE> <INDENT> nl . append ( a ) <NEWLINE> <DEDENT> <DEDENT> print ( sum ( nl ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1. n + 1 ) : <NEWLINE> <INDENT> if i % 3 == 0 or i % 5 == 0 : <NEWLINE> <INDENT> ans += i <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = input ( ) <NEWLINE> fizz = list ( ) <NEWLINE> for i in range ( int ( N + 1 ) ) : <NEWLINE> <INDENT> if not i // 3 == 0 or not i // 5 == 0 : <NEWLINE> <INDENT> fizz . append ( i ) <NEWLINE> <DEDENT> <DEDENT> print ( sum ( fizz ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> m = n // 15 <NEWLINE> l = n % 15 <NEWLINE> x = 60 * ( m ** 2 ) <NEWLINE> y = [ 0 , 1 , 2 , 0 , 4 , 0 , 0 , 7 , 8 , 0 , 0 , 11 , 0 , 13 , 14 , 0 ] <NEWLINE> for i in range ( 1 , l + 1 ) : <NEWLINE> <INDENT> if ( y [ i ] != 0 ) : <NEWLINE> <INDENT> x += y [ i ] + m * 15 <NEWLINE> <DEDENT> <DEDENT> print ( x ) a <NEWLINE>
N = int ( input ( ) ) <COMMENT> <NEWLINE> <NL> A = [ ] <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <COMMENT> <NL> <INDENT> if i % 3 == 0 : <NEWLINE> <INDENT> A . append ( 0 ) <NEWLINE> <DEDENT> elif i % 5 == 0 : <NEWLINE> A . append ( 0 ) <NEWLINE> else : <NEWLINE> <INDENT> A . append ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( sum ( A ) ) <NEWLINE>
n = longlong ( input ( ) ) <NEWLINE> <NL> a = 0 <NEWLINE> <NL> <NL> for i in n : <NEWLINE> <INDENT> if ( n % i * 3 == 0 and n % i * 5 == 0 ) : <NEWLINE> <INDENT> a += i <NEWLINE> elif ( n % i * 3 == 0 ) : <NEWLINE> a += i <NEWLINE> elif ( n % i * 5 == 0 ) : <NEWLINE> a += i <NEWLINE> <DEDENT> <DEDENT> print ( i ) <NEWLINE> <NL> <NL>
n = int ( input ( ) ) <NEWLINE> n3 = n // 3 <NEWLINE> s3 = ( ( n3 ) * 3 ) ( n3 + 1 ) // 2 <NEWLINE> n5 = n // 5 <NEWLINE> s5 = ( ( n5 ) * 5 ) ( n5 + 1 ) // 2 <NEWLINE> n15 = n // 15 <NEWLINE> s15 = ( ( n15 ) * 15 ) ( n15 + 1 ) // 2 <NEWLINE> <NL> s = n * ( n + 1 ) // 2 <NEWLINE> s = s - s3 - s5 + s15 <NEWLINE> print ( s ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = [ ] <NEWLINE> for i in range ( 1 : n + 1 ) : <NEWLINE> <INDENT> if a % 3 == 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> elif a % 5 == 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else <NEWLINE> <INDENT> s . append ( i ) <NEWLINE> <DEDENT> <DEDENT> print ( sum ( s ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> count = 0 <NEWLINE> for i in range ( N + 1 ) : <NEWLINE> <INDENT> if i % 3 != 0 and i % 5 != 0 : <NEWLINE> print ( i ) <NEWLINE> <DEDENT> print ( count ) <NEWLINE>
n = input ( ) <NEWLINE> <NL> sum = 0 <NEWLINE> <NL> for i in int ( n ) : <NEWLINE> <INDENT> if ( i % 3 != 0 ) & ( i % 5 != 0 ) : <NEWLINE> <INDENT> sum += i <NEWLINE> <DEDENT> <DEDENT> print ( sum ) <NEWLINE>
N = input ( ) <NEWLINE> <NL> a = 0 <NEWLINE> <NL> for val in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> if val % 3 != 0 and val % 3 != 0 : <NEWLINE> <INDENT> a += val <NEWLINE> <NL> <DEDENT> <DEDENT> print ( a ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> a = N // 3 <NEWLINE> b = N // 5 <NEWLINE> c = N // 15 <NEWLINE> <NL> ans = ( N * ( N + 1 ) / 2 ) - 3 * a ( a + 1 ) / 2 - 5 * b ( b + 1 ) / 2 + 15 * c ( c + 1 ) / 2 <NEWLINE> print ( int ( ans ) ) <NEWLINE>
input = int ( input ( ) ) <NEWLINE> a = [ ] <NEWLINE> while ( i <= input ) : <NEWLINE> <INDENT> if i % 3 == 0 or i % 5 == 0 : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a . append ( i ) <NEWLINE> <DEDENT> i += 1 <NEWLINE> <NL> <DEDENT> print ( sum ( a ) ) <NEWLINE> <NL>
N = input ( ) <NEWLINE> S = 0 <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> if i % 3 == 0 or i % 5 == 0 or ( i % 3 == 0 and i % 5 == 0 ) : <NEWLINE> <INDENT> continue <NEWLINE> S += i <NEWLINE> <NL> <DEDENT> <DEDENT> print ( S ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> <NL> org_sum = 1 / 2 * N * ( N + 1 ) <NEWLINE> div3 = N // 3 <NEWLINE> sum3 = 3 / 2 * div3 * ( div3 + 1 ) <NEWLINE> div5 = N // 5 <NEWLINE> sum5 = 5 / 2 * div5 * ( div5 + 1 ) <NEWLINE> div15 = N // 15 <NEWLINE> sum15 = 15 / 2 * div15 * ( div15 + 1 ) <NEWLINE> <NL> return org_sum - sum3 - sum5 + sum15 <NEWLINE>
N = int ( input ( ) ) <NEWLINE> ln = [ i for i in range ( 1 , N + 1 ) ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if ln [ i ] % 3 == 0 : <NEWLINE> <INDENT> nl . pop ( i ) <NEWLINE> <DEDENT> elif ln [ i ] % 5 == 0 : <NEWLINE> <INDENT> nl . pop ( i ) <NEWLINE> <DEDENT> elif ln [ i ] % 15 == 0 : <NEWLINE> <INDENT> nl . pop ( i ) <NEWLINE> <DEDENT> <DEDENT> print ( sum ( nl ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> fizzbuzz = [ i for i in range ( n + 1 ) if i % 5 != 0 and i % 3 != 0 ] <NEWLINE> print ( sum ( fizzbuss ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> long sum = 0 <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> if i % 3 == 0 and i % 5 == 0 : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> elif i % 3 == 0 : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> elif i % 5 == 0 : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> sum += i <NEWLINE> <DEDENT> <DEDENT> print ( sum ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> sum = 0 <NEWLINE> <NL> for i in range ( n + 1 ) : <NEWLINE> <INDENT> if i % 3 == 0 : <NEWLINE> <INDENT> print ( Fizz ) <NEWLINE> <DEDENT> elif i % 5 == 0 : <NEWLINE> <INDENT> print ( Buzz ) <NEWLINE> <DEDENT> elif i % 15 == 0 : <NEWLINE> <INDENT> print ( FizzBuzz ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> sum += i <NEWLINE> <NL> <DEDENT> <DEDENT> print ( sum ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> K = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> s = i % 3 <NEWLINE> t = i % 5 <NEWLINE> <INDENT> if s != 0 and t != 0 : <NEWLINE> <INDENT> K += i <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( K ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> if N >= 2 : <NEWLINE> <INDENT> An = [ [ ] for _ in range ( 1 , N ) ] <NEWLINE> <COMMENT> <NL> for s in range ( 1 , N ) : <NEWLINE> <COMMENT> <NL> <INDENT> if s % 3 == 0 : <NEWLINE> <INDENT> An [ s ] = 0 <NEWLINE> <DEDENT> elif s % 5 == 0 : <NEWLINE> <INDENT> An [ s ] = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> An [ s ] = int ( s ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> ans = int ( sum ( An ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = int ( 1 ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a . sort ( ) <NEWLINE> print ( a ) <NEWLINE> if a [ - m ] > 1 / ( 4 * m ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> l = [ i for i in range ( 1 , n + 1 ) ] <NEWLINE> l = list ( filter ( lambda x : x % 3 != 0 , l ) ) <NEWLINE> l = list ( filter ( lambda x ; x % 5 != 0 , l ) ) <NEWLINE> print ( sum ( l ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> sum = 0 <NEWLINE> for i in range ( N + 1 ) : <NEWLINE> <INDENT> if ( i % 3 != 0 and i % 5 != 0 ) : <NEWLINE> <INDENT> sum += i <NEWLINE> <NL> <DEDENT> if ( i > ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> l = 1 <NEWLINE> li = [ ] <NEWLINE> while l < n + 1 : <NEWLINE> <INDENT> if l % 3 == 0 and l % 5 == 0 or l % 3 == 0 or l % 5 == 0 : <NEWLINE> <INDENT> li . append ( l ) <NEWLINE> l += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> li += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( li ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> count = 0 <NEWLINE> for in range ( n ) : <NEWLINE> <INDENT> if i % 3 > 0 and i % 5 > 0 : <NEWLINE> <INDENT> count += i <NEWLINE> <NL> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
print ( sum ( [ n for n in range ( 1 , int ( inpt ( ) ) ) if ( n % 3 != 0 ) and ( n % 5 != 0 ) ] ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> <NL> count = 0 <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> num = int ( input ( ) ) <NEWLINE> <INDENT> if num % 3 == 0 and num % 5 == 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> elif num % 3 == 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> elif num % 5 == 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> count += num <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
x = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( x + 1 ) : <NEWLINE> <INDENT> if ( i % 3 != 0 ) and ( i % 5 != 0 ) : <NEWLINE> <INDENT> a += i <NEWLINE> <NL> <DEDENT> <DEDENT> print ( a ) <NEWLINE>
import numpy <NEWLINE> a = np . array ( [ i for i in range ( 1 , int ( input ( ) ) + 1 ) ] ) <NEWLINE> print ( a [ np . where ( ( a % 3 != 0 ) & ( a % 5 != 0 ) ) ] . sum ( ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if i % 3 != 0 and i % 5 != 0 : <NEWLINE> <INDENT> a += i <NEWLINE> <DEDENT> <DEDENT> print ( i ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> a = 0 <NEWLINE> <NL> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> if i % 3 == 0 and i % 5 == 0 : <NEWLINE> <INDENT> a = <STRING> <NEWLINE> <DEDENT> elif i % 3 == 0 : <NEWLINE> <INDENT> a = <STRING> <NEWLINE> <DEDENT> elif i % 5 == 0 : <NEWLINE> <INDENT> a = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a = a + i <NEWLINE> <NL> <DEDENT> <DEDENT>
n = int ( intput ( ) ) <NEWLINE> cnt = 0 <NEWLINE> for i in range ( n + 1 ) : <NEWLINE> <INDENT> if i % 3 != 0 : <NEWLINE> <INDENT> if i % 5 != 0 : <NEWLINE> <INDENT> cnt = cnt + i <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
N = input ( ) <NEWLINE> <NL> s = 0 <NEWLINE> for n in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> if n % 3 != 0 and n % 5 != 0 : <NEWLINE> <INDENT> s += n <NEWLINE> <DEDENT> <DEDENT> print ( s ) <NEWLINE>
N = int , input ( ) <NEWLINE> sum = 0 <NEWLINE> <NL> <COMMENT> <NL> for i in range ( N ) : <NEWLINE> <INDENT> if i % 3 == 0 : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> elif i % 5 == 0 : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> elif i % 15 == 0 : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> sum += i <NEWLINE> <NL> <DEDENT> <DEDENT> print ( sum ) <NEWLINE>
import math <NEWLINE> <NL> x = int256 ( input ( ) ) <NEWLINE> s = math . floor ( x / 3 ) <NEWLINE> f = math . floor ( x / 5 ) <NEWLINE> sf = math . floor ( x / 15 ) <NEWLINE> <NL> s_sum = math . floor ( 3 * s * ( s + 1 ) / 2 ) <NEWLINE> f_sum = math . floor ( 5 * f * ( f + 1 ) / 2 ) <NEWLINE> sf_sum = math . floor ( 15 * sf * ( sf + 1 ) / 2 ) <NEWLINE> <NL> sum = s_sum + f_sum - sf_sum <NEWLINE> print ( math . floor ( sum ) ) <NEWLINE>
import sys <NEWLINE> n = int ( sys . stdin ) <NEWLINE> print ( sum ( i for i in range ( 1 , n + 1 ) if i % 3 and i % 5 ) ) <NEWLINE>
N = input ( ) <NEWLINE> lit_N = [ ] <NEWLINE> for i in range ( int ( N ) + 1 ) : <NEWLINE> <INDENT> if i % 5 == 0 and i % 3 == 0 : <NEWLINE> <INDENT> lit_N . append ( <STRING> ) <NEWLINE> <DEDENT> elif i % 3 == 0 : <NEWLINE> <INDENT> lit_N . append ( <STRING> ) <NEWLINE> <DEDENT> elif i % 5 == 0 : <NEWLINE> <INDENT> lit_N . append ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> lit_N . append ( i ) <NEWLINE> <DEDENT> <DEDENT> print ( sum ( filter ( int , lit_N [ 1 : ] ) ) ) <NEWLINE>
term = int ( input ( ) ) <NEWLINE> sum = 0 <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> if i % 3 != 0 and i % 5 != 0 : <NEWLINE> <INDENT> sum += i <NEWLINE> <DEDENT> <DEDENT> print ( sum ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> Q = 0 <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> if ( i % 3 != = 0 and i % 5 != = 0 ) : <NEWLINE> <INDENT> Q += i <NEWLINE> <DEDENT> <DEDENT> print ( Q ) <NEWLINE>
a = 0 <NEWLINE> N = input ( ) <NEWLINE> n = int ( N ) <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if i % 5 != 0 and i % 3 != 0 : <NEWLINE> <INDENT> a = a + i <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> <DEDENT> return ( a ) <NEWLINE>
N = int ( input ) <NEWLINE> <NL> print ( sum ( i for i in range ( 1 , N + 1 ) if i % 3 == 0 or i % 5 == 0 ) ) <NEWLINE>
mxn = 10 ** 6 + 11 <NEWLINE> arr = [ ] <NEWLINE> for i in range ( 1 , mxn ) : <NEWLINE> <INDENT> if i % 3 == 0 and i % 5 == 0 : <NEWLINE> <INDENT> arr . append ( 0 ) <NEWLINE> <DEDENT> elif i % 3 == 0 : <NEWLINE> <INDENT> arr . append ( 0 ) <NEWLINE> <DEDENT> elif i % 5 == 0 : <NEWLINE> <INDENT> arr . append ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> arr . append ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> n = int ( input ( ) ) <NEWLINE> print ( sum [ : n ] ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> res = 0 <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> if i % 15 == 0 : <NEWLINE> <INDENT> dp = 0 <NEWLINE> <DEDENT> elif i % 5 == 0 : <NEWLINE> <INDENT> dp = 0 <NEWLINE> <DEDENT> elif i % 3 == 0 : <NEWLINE> <INDENT> dp = 0 <NEWLINE> <DEDENT> else :  <NEWLINE> <INDENT> dp = i <NEWLINE> <DEDENT> res = res + dp <NEWLINE> <DEDENT> print ( res ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> FBSum = 0 <NEWLINE> for i in N : <NEWLINE> <INDENT> j = i + 1 <NEWLINE> if j % 3 != 0 and j % 5 != 0 : <NEWLINE> FBSum += j <NEWLINE> <NL> <DEDENT> print ( FBSum ) <NEWLINE>
import sys <NEWLINE> n = sys . stdin . readline ( ) <NEWLINE> t = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if i % 3 != 0 or i % 5 != 0 : <NEWLINE> <INDENT> t += i <NEWLINE> <DEDENT> <DEDENT> print ( t ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( n + 1 ) : <NEWLINE> <INDENT> if a % 3 != 0 and a % 5 != 0 : <NEWLINE> <INDENT> ans += i <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL>
a = long ( input ( ) ) <NEWLINE> j = 0 <NEWLINE> for i in range ( a ) : <NEWLINE> <INDENT> if i % 3 == 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if i % 5 == 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> j += i <NEWLINE> <DEDENT> <DEDENT> print ( j ) <NEWLINE>
N = str ( input ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> if i % 3 != 0 and i % 5 != 0 : <NEWLINE> <INDENT> ans += i <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from math import gcd <NEWLINE> K = int ( iniput ( ) ) <NEWLINE> sum_gcd = [ 0 ] * 201 <NEWLINE> ans = 0 <NEWLINE> <NL> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> sum_gcd [ gcd ( i , j ) ] += 1 <NEWLINE> <DEDENT> <DEDENT> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for k in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> ans += sum_gcd [ i ] * gcd ( i , k ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> from functools import reduce <NEWLINE> <NL> def gcd ( * numbers ) : <NEWLINE> <INDENT> return reduce ( math . gcd , numbers ) <NEWLINE> <DEDENT> n = 200 <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> for k in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> ans += ( gcd ( i , j , k ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from fractions import gcd <NEWLINE> import math <NEWLINE> K = int ( input ( ) ) <NEWLINE> Sum = 0 <NEWLINE> for i in range ( K ) : <NEWLINE> <INDENT> for j in range ( K ) : <NEWLINE> <INDENT> for k in range ( K ) : <NEWLINE> <INDENT> x = math . gcd ( i + 1 , j + 1 ) <NEWLINE> y = math . gcd ( i + 1 , k + 1 ) <NEWLINE> Sum = Sum + math . gcd ( x , y ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( Sum ) <NEWLINE>
import sys , re , os <NEWLINE> from collections import deque , defaultdict , Counter <NEWLINE> from math import gcd , ceil , sqrt , hypot , factorial , pi , sin , cos , radians <NEWLINE> from itertools import permutations , combinations , product , accumulate <NEWLINE> from operator import itemgetter , mul <NEWLINE> from copy import deepcopy <NEWLINE> from string import ascii_lowercase , ascii_uppercase , digits <NEWLINE> from fractions import gcd <NEWLINE> <NL> def input ( ) : return sys . stdin . readline ( ) . strip ( ) <NEWLINE> def INT ( ) : return int ( input ( ) ) <NEWLINE> def MAP ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def S_MAP ( ) : return map ( str , input ( ) . split ( ) ) <NEWLINE> def LIST ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> def S_LIST ( ) : return list ( map ( str , input ( ) . split ( ) ) ) <NEWLINE> <NL> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> INF = float ( <STRING> ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> c = 0 <NEWLINE> K = INT ( ) <NEWLINE> ans = 0 <NEWLINE> <NL> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> a = gcd ( i , j ) <NEWLINE> for k in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> b = gcd ( a , k ) <NEWLINE> ans += b <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
K = int ( input ( ) ) <NEWLINE> <NL> import math <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> a = gcd ( i , j ) <NEWLINE> for k in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> ans += gcd ( a , k ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL>
import math <NEWLINE> from functools import reduce <NEWLINE> <NL> <NL> def gcd_list ( numbers ) : <NEWLINE> <INDENT> return reduce ( math . gcd , numbers ) <NEWLINE> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> l1 = range ( 1 , n + 1 ) <NEWLINE> l2 = range ( 1 , n + 1 ) <NEWLINE> l3 = range ( 1 , n + 1 ) <NEWLINE> <NL> count = 0 <NEWLINE> <NL> for i in l1 : <NEWLINE> <INDENT> for j in l2 : <NEWLINE> <INDENT> te = gcd ( i , j ) <NEWLINE> for k in l3 : <NEWLINE> <INDENT> count += ( te , k ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
import fractions <NEWLINE> K = int ( input ( ) ) <NEWLINE> out = 0 <NEWLINE> L = [ 0 ] * K <NEWLINE> gcd = [ [ 0 ] * K for i in range ( K ) ] <NEWLINE> for i in range ( 1 , 201 ) : <NEWLINE> <INDENT> for j in range ( 1 , 201 ) : <NEWLINE> <INDENT> A = fractions . gcd ( i , j ) <NEWLINE> gcd [ i - 1 ] [ j - 1 ] = A <NEWLINE> L [ A - 1 ] += 1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> for i in range ( 1 , 201 ) : <NEWLINE> <INDENT> for j in range ( 1 , 201 ) : <NEWLINE> <INDENT> out += gcd [ i - 1 ] [ j - 1 ] * L [ j - 1 ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( out ) <NEWLINE>
mport math <NEWLINE> k = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> gcd1 = math . gcd ( i , j ) <NEWLINE> for l in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> gcd2 = math . gcd ( gcd1 , l ) <NEWLINE> ans += gcd2 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> import math <NEWLINE> ans = 0 <NEWLINE> n = int ( input ( ) ) <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> t = math . gcd ( i , j ) <NEWLINE> for k in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> ans += math . gcd ( t , k ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from fractions import gcd <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> <NL> t = 0 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> for k in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> ans = gcd ( i , gcd ( j , k ) ) <NEWLINE> t += ans <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( t ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> k = int ( s ) <NEWLINE> n = 3 <NEWLINE> ans = { } <NEWLINE> for i in reversed ( range ( 1 , k + 1 ) ) : <NEWLINE> <INDENT> ans [ i ] = math . floor ( k / i ) ** n <NEWLINE> l = 2 <NEWLINE> j = i * l <NEWLINE> while j <= k : <NEWLINE> <INDENT> ans [ i ] = ans [ i ] - ans [ j ] <NEWLINE> l += 1 <NEWLINE> j = i * l <NEWLINE> <DEDENT> <DEDENT> res = 0 <NEWLINE> for i in ans : <NEWLINE> <INDENT> res += i * ans [ i ] <NEWLINE> <DEDENT> print ( res ) <NEWLINE>
import math <NEWLINE> k = int ( input ( ) ) <NEWLINE> sum = [ ] <NEWLINE> for a in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for b in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> ab = math . gcd ( a , b ) <NEWLINE> for c in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> sum += math . gcd ( ab , c ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( sum ) <NEWLINE>
import math <NEWLINE> import numpy <NEWLINE> K = int ( input ( ) ) <NEWLINE> <NL> total = 0 <NEWLINE> tmp = 0 <NEWLINE> <INDENT> for a in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for b in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> tmp = math . gcd ( a , b ) <NEWLINE> <INDENT> for c in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> total += math . gcd ( tmp , c ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( total ) <NEWLINE>
from math import gcd <NEWLINE> <NL> K = int ( input ( ) ) ; <NEWLINE> gcd = 0 ; <NEWLINE> <NL> for a in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for b in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for c in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> gcd += gcd ( gcd ( a , b ) , c ) ; <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( gcd ) <NEWLINE>
function GCM ( x , y ) : <NEWLINE> <INDENT> if x == y : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> if x < y : <NEWLINE> <INDENT> s = x <NEWLINE> x = y <NEWLINE> y = s <NEWLINE> <NL> <DEDENT> a = x % y <NEWLINE> if a == 0 : <NEWLINE> <INDENT> return y <NEWLINE> <DEDENT> return GCM ( y , a ) <NEWLINE> <NL> <DEDENT> k = int ( input ( ) ) <NEWLINE> res = 0 <NEWLINE> same1 = 0 <NEWLINE> same2 = 0 <NEWLINE> rate = [ 6 , 3 , 1 ] <NEWLINE> for p in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for q in range ( p , k + 1 ) : <NEWLINE> <INDENT> same1 = int ( p == q ) <NEWLINE> gcm = GCM ( q , p ) <NEWLINE> for r in range ( q , k + 1 ) : <NEWLINE> <INDENT> same2 = int ( q == r ) <NEWLINE> gcm = GCM ( r , gcm ) <NEWLINE> res += gcm * rate [ same1 + same2 ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( res ) <NEWLINE> <NL> <NL> <NL> <NL> <NL>
import math <NEWLINE> from functools import reduce <NEWLINE> <NL> def gcd ( * numbers ) : <NEWLINE> <INDENT> return reduce ( math . gcd , numbers ) <NEWLINE> <NL> <DEDENT> K = int ( input ( ) ) <NEWLINE> <NL> sum1 = 0 <NEWLINE> sum2 = 0 <NEWLINE> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for k in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> if i = < j = < k : <NEWLINE> <INDENT> sum1 += gcd ( i , j , k ) <NEWLINE> <DEDENT> if i == j == k : <NEWLINE> <INDENT> sum2 += gcd ( i , j , k ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( sum1 * 3 - sum2 * 2 ) <NEWLINE>
from math import gcd <NEWLINE> k = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> sub += gcd ( i , j ) <NEWLINE> for l in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> ans += gcd ( sub , l ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> n = int ( input ( ) ) <NEWLINE> lis = [ [ 0 ] * n for i in range ( n ) ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( n ) : <NEWLINE> <INDENT> lis [ i ] [ j ] = math . gcd ( i + 1 , j + 1 ) <NEWLINE> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( n ) : <NEWLINE> <INDENT> for k in range ( n ) : <NEWLINE> <INDENT> ans += lis [ i ] [ lis [ k ] [ j ] ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
k = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> from fractions import gcd <NEWLINE> import functools <NEWLINE> for a in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for b in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for c in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> @ functools . lru_cache ( None ) <NEWLINE> def gc ( x , y ) : <NEWLINE> <INDENT> if x > y : <NEWLINE> <INDENT> x , y = y , x <NEWLINE> <DEDENT> return gcd ( x , y ) <NEWLINE> <NL> <DEDENT> ans += gcd ( a , gcd ( b , c ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL>
from fractions import gcd <NEWLINE> N = int ( input ( ) ) <NEWLINE> <NL> ll = [ i for i in range ( 1 , N + 1 ) ] <NEWLINE> ans = 0 <NEWLINE> <NL> for i in ll : <NEWLINE> <INDENT> for j in ll : <NEWLINE> <INDENT> s = gcd ( i , j ) <NEWLINE> for k in ll : <NEWLINE> <INDENT> ans += gcd ( s , k ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> from functools import reduce <NEWLINE> <NL> <NL> dic = { } <NEWLINE> ans = 0 <NEWLINE> n = int ( input ( ) ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( n ) : <NEWLINE> <INDENT> for k in range ( n ) : <NEWLINE> <INDENT> key = ( i + 1 ) * ( j + 1 ) * ( k + 1 ) <NEWLINE> if key in dic : <NEWLINE> <INDENT> ans = ans + dic [ key ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> val = gcd ( gcd ( i + 1 , j + 1 ) , k + 1 ) <NEWLINE> dic [ key ] = val <NEWLINE> ans = ans + val <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> from functools import reduce <NEWLINE> k = int ( input ( ) ) <NEWLINE> def gcd ( * numbers ) : <NEWLINE> <INDENT> return reduce ( math . gcd , numbers ) <NEWLINE> <DEDENT> ans = 0 <NEWLINE> for i in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for j in range ( j , k + 1 ) : <NEWLINE> <INDENT> for l in range ( l , k + 1 ) : <NEWLINE> <INDENT> if l == i : <NEWLINE> <INDENT> ans += gcd ( i , j , l ) <NEWLINE> <DEDENT> elif i == j or j == l : <NEWLINE> <INDENT> ans += 2 * gcd ( i , j , l ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += gcd ( i , j , l ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <STRING> <NEWLINE> <NL> <STRING> <NEWLINE> <NL> <STRING> <NEWLINE> <NL> <STRING> <NEWLINE> <STRING> <NEWLINE> <STRING> <NEWLINE> <NL> <COMMENT> <NL> <STRING> <NEWLINE> <NL> <COMMENT> <NL> <STRING> <NEWLINE> <NL> <COMMENT> <NL> <STRING> <NEWLINE> <NL> <COMMENT> <NL> <STRING> <NEWLINE> <NL> def readInts ( ) : <NEWLINE> <INDENT> return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <DEDENT> mod = 10 ** 9 + 7 <NEWLINE> def main ( ) : <NEWLINE> <INDENT> from fractions import gcd <NEWLINE> from functools import reduce <NEWLINE> k = int ( input ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> for a in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for b in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for c in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> ans += reduce ( gcd , ( a , b , c ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
K = int ( input ( ) ) <NEWLINE> <NL> import fractions <NEWLINE> <NL> res = 0 <NEWLINE> <NL> <NL> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for l in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> a = list ( [ i , j , l ] ) <NEWLINE> ans = a [ 0 ] <NEWLINE> for n in range ( 1 , 3 ) : <NEWLINE> <INDENT> ans = fractions . gcd ( ans , a [ n ] ) <NEWLINE> <DEDENT> res += ans <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( res ) <NEWLINE>
import math <NEWLINE> K = int ( input ( ) ) <NEWLINE> <NL> sum = 0 <NEWLINE> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> temp = math . gcd ( i , j ) <NEWLINE> for m in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> sum = sum + math . gcv ( temp , m ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( sum ) <NEWLINE>
import fractions <NEWLINE> import itertools <NEWLINE> <NL> k = int ( input ( ) ) <NEWLINE> tot = 0 <NEWLINE> for l , m , n in itertools . product ( range ( 1 , k + 1 ) , range ( 1 , k + 1 ) , range ( 1 , k + 1 ) ) : <NEWLINE> <INDENT> ans = fractions . gcd ( m , l % m ) <NEWLINE> ans = fractions . gcd ( ans , n ) <NEWLINE> tot += ans <NEWLINE> <DEDENT> print ( tot ) <NEWLINE>
<COMMENT> <NL> <STRING> <NEWLINE> <NL> import math <NEWLINE> <NL> K = 200 <COMMENT> <NEWLINE> <NL> answer = 0 <NEWLINE> for a in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for b in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for c in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> answer += math . gcd ( math . gcd ( a , b ) , c ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( answer ) <NEWLINE> <NL>
N = int ( input ( ) ) <NEWLINE> sum = 0 <NEWLINE> import math <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> for j in range ( N ) : <NEWLINE> <INDENT> t = gcd ( i + 1 , j + 1 ) <NEWLINE> for k in range ( N ) : <NEWLINE> <INDENT> sum = sum + gcd ( t , k + 1 ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( sum ) <NEWLINE>
k = input ( ) <NEWLINE> sumk = 0 <NEWLINE> for i in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for a in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for b in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for c in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> gcd = 1 <NEWLINE> m = min ( a , b , c ) <NEWLINE> for x in range ( 1 , m + 1 ) : <NEWLINE> <INDENT> if ( a % x == 0 and b % x == 0 and c % x == 0 ) : <NEWLINE> <INDENT> gcd = x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> gcd = gcd <NEWLINE> sumk = sumk + gcd <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( sumk ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> k = int ( input ( ) ) <NEWLINE> r = 0 <NEWLINE> for ia in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for ib in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for ic in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> t1 = gcd ( ib , ic ) <NEWLINE> r += gcd ( t1 , ia ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( r ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
from fractions import gcd <NEWLINE> from functools import reduce <NEWLINE> <NL> <NL> ans = 0 <NEWLINE> K = int ( input ( ) ) <NEWLINE> for a in ( range ( 1 , K + 1 ) ) : <NEWLINE> <INDENT> for b in range ( a , K + 1 ) : <NEWLINE> <INDENT> for c in range ( b , K + 1 ) : <NEWLINE> <INDENT> n = 0 <NEWLINE> if a == b == c : <NEWLINE> <INDENT> n = 1 <NEWLINE> <DEDENT> elif a == b or b == c or c == a : <NEWLINE> <INDENT> n = 3 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> n = 6 <NEWLINE> <DEDENT> ans += n * reduce ( gcd , [ a , b , c ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from itertools import combinations <NEWLINE> import math <NEWLINE> n = int ( input ( ) <NEWLINE> ans = 0 <NEWLINE> for r in range ( 1 , 4 ) : <NEWLINE> <INDENT> if r > n : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for x in combinations ( [ x + 1 for x in range ( n ) ] , r ) : <NEWLINE> <INDENT> if len ( x ) == 1 : <NEWLINE> <INDENT> ans += x [ 0 ] <NEWLINE> <DEDENT> elif len ( x ) == 2 : <NEWLINE> <INDENT> ans += math . gcd ( x [ 0 ] , x [ 1 ] ) * 6 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> tmp = math . gcd ( x [ 0 ] , x [ 1 ] ) <NEWLINE> ans += math . gcd ( x [ 2 ] , tmp ) * 6 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
def gcd ( a , b ) : <NEWLINE> <INDENT> if a < b : <NEWLINE> <INDENT> tmp = a <NEWLINE> a = b <NEWLINE> b = tmp <NEWLINE> <DEDENT> r = a % b <NEWLINE> while r != 0 : <NEWLINE> <INDENT> a = b <NEWLINE> b = r <NEWLINE> r = a % b <NEWLINE> <DEDENT> return b <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> K = int ( input ( ) ) <NEWLINE> list_ = [ ] <NEWLINE> sum_ = 0 <NEWLINE> for i in range ( K ) : <NEWLINE> <INDENT> for j in range ( K ) : <NEWLINE> <INDENT> a = gcd ( i , j ) <NEWLINE> list_ . append ( a ) <NEWLINE> <DEDENT> <DEDENT> for i in list_ : <NEWLINE> <INDENT> for j in range ( K ) : <NEWLINE> <INDENT> a = gcd ( i , j ) <NEWLINE> sum_ += a <NEWLINE> <DEDENT> <DEDENT> print ( sum_ ) <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE>
import itertools <NEWLINE> import math <NEWLINE> import fractions <NEWLINE> import functools <NEWLINE> k = int ( input ( ) ) <NEWLINE> <NL> <NL> <NL> sum = 0 <NEWLINE> for i in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> gcd1 = fractions . gcd ( i , j ) <NEWLINE> for l in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> sum += fractions . gcd ( gcd1 , l ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( sum ) <NEWLINE>
def gcd ( a , b ) : <NEWLINE> <INDENT> if b == 0 : <NEWLINE> <INDENT> return a <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return gcd ( b , a % b ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> k = input ( ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> d = gcd ( i , j ) <NEWLINE> for l in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> if d != 1 : <NEWLINE> <INDENT> ans += gcd ( d , l ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> <NL> K = int ( input ( ) ) + 1 <NEWLINE> d = 0 <NEWLINE> <NL> for i in range ( 1 , K ) : <NEWLINE> <INDENT> for j in range ( 1 , K ) : <NEWLINE> <INDENT> for k in range ( 1 , K ) : <NEWLINE> <INDENT> d = gcd ( i , j , k ) + d <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( d ) <NEWLINE>
<NL> import itertools <NEWLINE> import numpy as np <NEWLINE> from numba import jit <NEWLINE> <NL> <NL> @ jit <NEWLINE> def gcd ( a , b ) : <NEWLINE> <INDENT> if a < b : <NEWLINE> <INDENT> a , b = b , a <NEWLINE> <DEDENT> if ( a % b == 0 ) : <NEWLINE> <INDENT> return b <NEWLINE> <DEDENT> return ( gcd ( a % b , b ) ) <NEWLINE> <NL> <NL> <DEDENT> def gcd3 ( a , b , c ) : <NEWLINE> <INDENT> return gcd ( gcd ( a , b ) , c ) <NEWLINE> <NL> <NL> <DEDENT> N = input ( ) <NEWLINE> a = [ int ( N ) for k in range ( 3 ) ] <NEWLINE> range_list = list ( map ( lambda x : range ( 1 , x + 1 ) , a ) ) <NEWLINE> prd_list = itertools . product ( * range_list ) <NEWLINE> <NL> <COMMENT> <NL> <NL> gcds = [ gcd3 ( * prd ) for prd in prd_list ] <NEWLINE> <NL> s = np . sum ( gcds ) <NEWLINE> <NL> print ( s ) <NEWLINE>
import fractions <NEWLINE> from functools import reduce <NEWLINE> <NL> def gcd ( * numbers ) : <NEWLINE> <INDENT> return reduce ( fractions . gcd , numbers ) <NEWLINE> <NL> <DEDENT> def gcd_list ( numbers ) : <NEWLINE> <INDENT> return reduce ( fractions . gcd , numbers ) <NEWLINE> <DEDENT> K = int ( input ( ) ) <NEWLINE> <NL> count = 0 <NEWLINE> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for j in range ( i , K + 1 ) : <NEWLINE> <INDENT> for k in range ( j , K + 1 ) : <NEWLINE> <INDENT> if i == j and j == k : <NEWLINE> <INDENT> kake = 1 <NEWLINE> <DEDENT> elif i == j or j == k or i == k : <NEWLINE> <INDENT> kake = 3 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> kake = 6 <NEWLINE> <DEDENT> count += gcd ( i , j , k ) * kake <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
import itertools <NEWLINE> import math <NEWLINE> import fractions <NEWLINE> import functools <NEWLINE> k = int ( input ( ) ) <NEWLINE> h_list = [ ] <NEWLINE> <NL> <NL> for i in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for l in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> h_list . append ( [ i , j , l ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> sum = 0 <NEWLINE> for i in range ( len ( h_list ) ) : <NEWLINE> <INDENT> a = fractions . gcd ( h_list [ i ] [ 0 ] , h_list [ i ] [ 1 ] ) <NEWLINE> sum += fractions . gcd ( a , h_list [ i ] [ 2 ] ) <NEWLINE> <NL> <DEDENT> print ( sum ) <NEWLINE>
from math import gcd <NEWLINE> k = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> <NL> for s in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for t in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for u in range ( 1 , k + 1 ) : <NEWLINE> ans += gcd ( gcd ( s , t ) , u ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import math as np <NEWLINE> K = int ( input ( ) ) <NEWLINE> s = 0 <NEWLINE> d = 0 <NEWLINE> for a in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> if a % 2 == 0 : <NEWLINE> <INDENT> for b in range ( 2 , K + 1 , 2 ) : <NEWLINE> <INDENT> if a > b : <NEWLINE> <INDENT> if a % b == 0 : <NEWLINE> <INDENT> d = b <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d = np . gcd ( a % b , b ) <NEWLINE> <DEDENT> <DEDENT> if a < b : <NEWLINE> <INDENT> if b % a == 0 : <NEWLINE> <INDENT> d = a <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d = np . gcd ( b % a , a ) <NEWLINE> <DEDENT> <DEDENT> if a == b : <NEWLINE> <INDENT> d = a <NEWLINE> <DEDENT> for c in range ( 2 , K + 1 , 2 ) : <NEWLINE> <INDENT> if c > d : <NEWLINE> <INDENT> if c % d == 0 : <NEWLINE> <INDENT> s += d <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s += np . gcd ( c % d , d ) <NEWLINE> <DEDENT> <DEDENT> if c < d : <NEWLINE> <INDENT> if d % c == 0 : <NEWLINE> <INDENT> s += c <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s += np . gcd ( d % c , c ) <NEWLINE> <DEDENT> <DEDENT> if c == d : <NEWLINE> <INDENT> s += c <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if a % 2 == 1 : <NEWLINE> <INDENT> for b in range ( 1 , K + 1 , 2 ) : <NEWLINE> <INDENT> if a > b : <NEWLINE> <INDENT> if a % b == 0 : <NEWLINE> <INDENT> d = b <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d = np . gcd ( a % b , b ) <NEWLINE> <DEDENT> <DEDENT> if a < b : <NEWLINE> <INDENT> if b % a == 0 : <NEWLINE> <INDENT> d = a <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d = np . gcd ( b % a , a ) <NEWLINE> <DEDENT> <DEDENT> if a == b : <NEWLINE> <INDENT> d = a <NEWLINE> <DEDENT> for c in range ( 1 , K + 1 , 2 ) : <NEWLINE> <INDENT> if c > d : <NEWLINE> <INDENT> if c % d == 0 : <NEWLINE> <INDENT> s += d <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s += np . gcd ( c % d , d ) <NEWLINE> <DEDENT> <DEDENT> if c < d : <NEWLINE> <INDENT> if d % c == 0 : <NEWLINE> <INDENT> s += c <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s += np . gcd ( d % c , c ) <NEWLINE> <DEDENT> <DEDENT> if c == d : <NEWLINE> <INDENT> s += c <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if K % 2 == 0 : <NEWLINE> <INDENT> s += K ** 3 - ( K // 2 ) ** 3 - ( k // 2 + 1 ) ** 3 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s += K ** 3 - ( K // 2 ) ** 3 - ( k // 2 ) ** 3 <NEWLINE> <DEDENT> <DEDENT> print ( s ) <NEWLINE>
import math <NEWLINE> <NL> K = int ( input ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> x = math . gcd ( i , j ) <NEWLINE> for k in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> count += math . gcd ( x , k ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from math import math <NEWLINE> <NL> k = int ( input ( ) ) <NEWLINE> count = 0 <NEWLINE> for i in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for l in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> count += gcd ( gcd ( j , l ) , i ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
k = int ( input ( ) ) <NEWLINE> sum = 0 <NEWLINE> for a in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for b in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> g1 = math . gcd ( a , b ) <NEWLINE> for c in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> sum += math . gcd ( g1 , c ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( sum ) <NEWLINE>
import math <NEWLINE> from functools import reduce <NEWLINE> <NL> K = int ( input ( ) ) <NEWLINE> sum = 0 <NEWLINE> <NL> def gcd ( * numbers ) : <NEWLINE> <INDENT> return reduce ( math . gcd , numbers ) <NEWLINE> <NL> <DEDENT> for i in range ( K ) : <NEWLINE> <INDENT> for j in range ( K ) : <NEWLINE> <INDENT> tmp = math . gcd ( i + 1 , j + 1 ) <NEWLINE> for k in range ( K ) : <NEWLINE> <INDENT> sum += gcd ( g , k + 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( sum ) <NEWLINE>
K = int ( input ( ) ) <NEWLINE> <NL> x = np . arange ( 1 , K + 1 ) <NEWLINE> nums = np . gcd . outer ( np . gcd . outer ( x , x ) , x ) <NEWLINE> print ( nums . sum ( ) ) <NEWLINE>
import sys <NEWLINE> read = sys . stdin . read <NEWLINE> readlines = sys . stdin . readlines <NEWLINE> def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> <NL> rr = [ i for i , c in enumerate ( s ) if c == <STRING> ] <NEWLINE> g = [ i for i , c in enumerate ( s ) if c == <STRING> ] <NEWLINE> b = [ i for i , c in enumerate ( s ) if c == <STRING> ] <NEWLINE> <NL> r = len ( rr ) * len ( g ) * len ( b ) <NEWLINE> for rre in rr : <NEWLINE> <INDENT> for ge in g : <NEWLINE> <INDENT> for be in b : <NEWLINE> <INDENT> r -= rre * 2 == ge + be <NEWLINE> r -= ge * 2 == rre + be <NEWLINE> r -= be * 2 == ge + rre <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( r ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
from fractions import gcd <NEWLINE> from functools import reduce <NEWLINE> import itertools <NEWLINE> k = int ( input ( ) ) <NEWLINE> a = [ i for i in range ( 1 , k + 1 ) ] <NEWLINE> s = 0 <NEWLINE> <COMMENT> <NL> s = int ( k * ( k + 1 ) / 2 ) <NEWLINE> <COMMENT> <NL> for q in itertools . combinations ( a , 2 ) : <NEWLINE> <INDENT> s += reduce ( gcd , q ) * 3 * 2 <NEWLINE> <DEDENT> for t in itertools . combinations ( a , 3 ) : <NEWLINE> <INDENT> s += reduce ( gcd , t ) * 6 <NEWLINE> <DEDENT> print ( s ) <NEWLINE>
k = int ( input ( ) ) <NEWLINE> <NL> gcache = { } <NEWLINE> s = 0 <NEWLINE> <NL> for a in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for b in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> tup = ( min ( a , b ) , max ( a , b ) ) <NEWLINE> if tup not in gcache : <NEWLINE> <INDENT> gc = math . gcd ( tup [ 0 ] , tup [ 1 ] ) <NEWLINE> gcache [ tup ] = gc <NEWLINE> <DEDENT> gc = gcache [ tup ] <NEWLINE> for c in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> tup = ( min ( c , gc ) , max ( c , gc ) ) <NEWLINE> if tup not in gcache : <NEWLINE> <INDENT> gc = math . gcd ( tup [ 0 ] , tup [ 1 ] ) <NEWLINE> gcache [ tup ] = gc <NEWLINE> <DEDENT> gc = gcache [ tup ] <NEWLINE> s += gc <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( s ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> result = [ 0 ] * n ** 3 <NEWLINE> for a in range ( n ) : <NEWLINE> <INDENT> for b in range ( n ) : <NEWLINE> <INDENT> for c in range ( n ) : <NEWLINE> <INDENT> if a > b : <NEWLINE> <INDENT> result [ n * n * a + n * b + c ] = result [ n * n * b + n * a + c ] <NEWLINE> <DEDENT> elif b > c : <NEWLINE> <INDENT> result [ n * n * a + n * b + c ] = result [ n * n * a + n * c + b ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> result [ n * n * a + n * b + c ] = gcd ( a + 1 , gcd ( b + 1 , c + 1 ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( sum ( result ) ) <NEWLINE>
from math import gdc <NEWLINE> K = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> <NL> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for l in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> ans += gcd ( gcd ( i , j ) , l ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
k = int ( input ( ) ) <NEWLINE> <NL> import math <NEWLINE> ans = sum ( list ( range ( k + 1 ) ) ) <NEWLINE> ans1 = 0 <NEWLINE> ans2 = 0 <NEWLINE> for i in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> ans1 += math . gcd ( i , j ) <NEWLINE> <NL> <DEDENT> <DEDENT> ans = ans + ans1 * 3 <NEWLINE> <NL> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , i ) : <NEWLINE> <INDENT> for l in range ( 1 , l ) : <NEWLINE> <INDENT> ans2 += math . gcd ( math . gcd ( i , j ) , l ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> ans += ans2 * 6 <NEWLINE> print ( ans ) <NEWLINE>
import math <NEWLINE> count = 0 <NEWLINE> for p in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for q in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for r in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> count += math . gcd ( math . gcd ( p , q ) , r ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> k = int ( input ( ) ) <NEWLINE> k1 = k + 1 <NEWLINE> <NL> sum = 0 <NEWLINE> for i in range ( 1 , k1 ) : <NEWLINE> <INDENT> for j in range ( 1 , k1 ) : <NEWLINE> <INDENT> for m in range ( 1 , k1 ) : <NEWLINE> <INDENT> sum += math . gcd ( math . gcd ( i , j ) , m ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( sum ) <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> d = { } <NEWLINE> if n == 1 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> for a in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> for b in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> p = math . gcd ( a , b ) <NEWLINE> if d . get ( p ) != None : <NEWLINE> <INDENT> d [ p ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d [ p ] = 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> for c in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> for e in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> p = math . gcd ( c , e ) <NEWLINE> ans += d [ e ] * p <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
K = int ( input ( ) ) <NEWLINE> def gcd ( x , y ) : <NEWLINE> <INDENT> a , b = x , y <NEWLINE> while b != 0 : <NEWLINE> <INDENT> a , b = b , a % b <NEWLINE> <DEDENT> return a <NEWLINE> <DEDENT> gcds = [ [ 0 for j in range ( K ) ] for i in range ( K ) ] <NEWLINE> for i in range ( K ) : <NEWLINE> <INDENT> for j in range ( K ) : <NEWLINE> <INDENT> gcds [ i ] [ j ] = gcd ( i + 1 , j + 1 ) <NEWLINE> <DEDENT> <DEDENT> S = 0 <NEWLINE> for i in range ( K ) : <NEWLINE> <INDENT> for j in range ( K ) : <NEWLINE> <INDENT> for k in range ( K ) : <NEWLINE> <INDENT> S += gcds [ gcds [ i ] [ j ] ] [ k ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( S ) <NEWLINE>
k = int ( input ( ) ) <NEWLINE> s = 0 <NEWLINE> for a in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for b in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> ab = math . gcd ( a , b ) <NEWLINE> for c in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> s += math . gcd ( ab , c ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( s ) <NEWLINE>
rom math import gcd <NEWLINE> <NL> k = int ( input ( ) ) <NEWLINE> total = 0 <NEWLINE> for a in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> t = gcd ( a , b ) <NEWLINE> for b in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for c in range ( 1 , k + 1 ) : <NEWLINE> <COMMENT> <NL> <INDENT> total += gcd ( t , c ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( total ) <COMMENT> <NEWLINE>
import fractions <NEWLINE> <NL> K = int ( input ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> a = [ ] <NEWLINE> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> tmp = fractions . gcd ( i , j ) <NEWLINE> for k in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> ans += fractions . gcd ( tmp , k ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
k = int ( input ( ) ) <NEWLINE> import fractions <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for j in range ( i , k + 1 ) : <NEWLINE> <INDENT> for l in range ( j , k + 1 ) : <NEWLINE> <INDENT> tmp = fractions . gcd ( i , j ) <NEWLINE> tmp = fractions . gcd ( tmp , l ) <NEWLINE> if i == j == l : <NEWLINE> <INDENT> ans += tmp <NEWLINE> <DEDENT> elif i == j or j == l or l == i : <NEWLINE> <INDENT> ans += 3 * tmp <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += 6 * tmp <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
k = int ( input ( ) ) <NEWLINE> <NL> count = [ pow ( k // max ( i , 1 ) , 3 , mod ) for i in range ( k + 1 ) ] <NEWLINE> <NL> for i in range ( k , 0 , - 1 ) : <NEWLINE> <INDENT> for j in range ( 2 * i , k + 1 , i ) : <NEWLINE> <INDENT> count [ i ] -= count [ j ] <NEWLINE> <NL> <DEDENT> <DEDENT> sum_ = 0 <NEWLINE> for i in range ( k + 1 ) : <NEWLINE> <INDENT> sum_ += i * count [ i ] <NEWLINE> <NL> <DEDENT> print ( sum_ ) <NEWLINE>
from math import gcd <NEWLINE> k = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for a in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for b in range ( a , k + 1 ) : <NEWLINE> <INDENT> ab = gcd ( a , b ) <NEWLINE> for c in range ( c , k + 1 ) : <NEWLINE> <INDENT> g = gcd ( ab , c ) <NEWLINE> if a == b == c : <NEWLINE> <INDENT> ans += g <NEWLINE> <DEDENT> elif a != b != c != a : <NEWLINE> <INDENT> ans += g * 6 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += g * 3 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
k = int ( input ( ) ) <NEWLINE> <NL> from math import gcd <NEWLINE> <NL> res = 0 <NEWLINE> <NL> for n in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for i in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , k + 1 ) : <NEWLINE> <NL> <INDENT> res += math . gcd ( math . gcd ( n , i ) , j ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( res ) <NEWLINE>
import math <NEWLINE> import sys <NEWLINE> read = sys . stdin . buffer . read <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> readlines = sys . stdin . buffer . readlines <NEWLINE> <NL> k = int ( read ( ) ) <NEWLINE> ans = 0 <NEWLINE> for a in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> for b in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> n = math . gcd ( a , b ) <NEWLINE> for c in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> ans += math . gcd ( n , c ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
mport math <NEWLINE> from functools import reduce <NEWLINE> <NL> def gcd ( * numbers ) : <NEWLINE> <INDENT> return reduce ( math . gcd , numbers ) <NEWLINE> <NL> <NL> <DEDENT> N = int ( input ( ) ) <NEWLINE> S = 0 <NEWLINE> T = 0 <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , N + 1 ) : <NEWLINE> <INDENT> for k in range ( j + 1 , N + 1 ) : <NEWLINE> <INDENT> S += gcd ( i , j , k ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , N + 1 ) : <NEWLINE> <INDENT> T += gcd ( i , j , j ) <NEWLINE> T += gcd ( i , j , j ) <NEWLINE> <DEDENT> <DEDENT> print ( 6 * S + 3 * T + N * ( N + 1 ) // 2 ) <NEWLINE>
from fractions import gcd <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> <NL> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> for k in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> temp = gcd ( i , j ) <NEWLINE> ans += gcd ( temp , k ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import collections <NEWLINE> <NL> K = int ( input ( ) ) <NEWLINE> <NL> a = [ ] <NEWLINE> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> a . append ( gcd ( i , j ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> col = collections . Counter ( a ) <NEWLINE> <NL> sum = 0 <NEWLINE> for k in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for key , value in col . items ( ) : <NEWLINE> <INDENT> sum += gcd ( k , key ) * value <NEWLINE> <DEDENT> <DEDENT> print ( sum ) <NEWLINE>
from math <NEWLINE> <NL> k = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> <NL> for a in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> if i == 1 : <NEWLINE> <INDENT> ans += k * k <NEWLINE> continue <NEWLINE> <DEDENT> for b in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> n = math . gcd ( a , b ) <NEWLINE> if n == 1 : <NEWLINE> <INDENT> ans += k <NEWLINE> continue <NEWLINE> <DEDENT> for c in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> ans += math . gcd ( n , c ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
K = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> <NL> for i in range ( K ) : <NEWLINE> <INDENT> i = i + 1 <NEWLINE> for k in range ( K ) : <NEWLINE> <INDENT> k = k + 1 <NEWLINE> for j in range ( K ) : <NEWLINE> <INDENT> j = j + 1 <NEWLINE> <NL> ans += gcd ( gcd ( i , k ) , j ) <NEWLINE> j = j + 1 <NEWLINE> <DEDENT> k = k + 1 <NEWLINE> <DEDENT> i = i + 1 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL>
a = int ( input ( ) ) <NEWLINE> import math <NEWLINE> print ( sum ( gcd ( gcd ( i , j ) , k ) for i in range ( 1 , a + 1 ) for j in range ( 1 , a + 1 ) for k in range ( 1 , a + 1 ) ) ) <NEWLINE>
import math <NEWLINE> from itertools import combinations <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> k = int ( input ( ) ) <NEWLINE> res = 0 <NEWLINE> memo = [ [ 0 for _ in range ( k + 1 ) ] for _ in range ( k + 1 ) ] <NEWLINE> for i ian range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for j in range ( i , k + 1 ) : <NEWLINE> <INDENT> tmp = math . gcd ( i , j ) <NEWLINE> memo [ i ] [ j ] = tmp <NEWLINE> memo [ j ] [ i ] = tmp <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> res += i <NEWLINE> <NL> <DEDENT> for c in combinations ( range ( 1 , k + 1 ) , 2 ) : <NEWLINE> <INDENT> ab = memo [ c [ 0 ] , c [ 1 ] ] <NEWLINE> res += ab * 6 <NEWLINE> <NL> <DEDENT> for c in combinations ( range ( 1 , k + 1 ) , 3 ) : <NEWLINE> <INDENT> ab = memo [ c [ 0 ] , c [ 1 ] ] <NEWLINE> abc = memo [ ab , c [ 2 ] ] <NEWLINE> res += abc * 6 <NEWLINE> <DEDENT> print ( res ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
from functools import reduce <NEWLINE> <NL> k = int ( input ( ) ) <NEWLINE> <NL> wa = 0 <NEWLINE> <NL> for a in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for b in range ( a + 1 , k + 1 ) : <NEWLINE> <INDENT> for c in range ( b + 1 , k + 1 ) : <NEWLINE> <INDENT> li = [ a , b , c ] <NEWLINE> wa += reduce ( math . gcd , li ) * 6 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for a in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for b in range ( a + 1 , k + 1 ) : <NEWLINE> <INDENT> wa += math . gcd ( a , b ) * 6 <NEWLINE> <NL> <DEDENT> <DEDENT> for a in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> wa += a <NEWLINE> <NL> <DEDENT> print ( wa ) <NEWLINE>
k = int ( input ( ) ) <NEWLINE> import fractions <NEWLINE> l = [ ] <NEWLINE> ans = 0 <NEWLINE> for a in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for b in range ( a , k + 1 ) : <NEWLINE> <INDENT> for c in range ( b , k + 1 ) : <NEWLINE> <INDENT> l = [ a , b , c ] <NEWLINE> d = l [ 0 ] <NEWLINE> for i in range ( 1 , 3 ) : <NEWLINE> <INDENT> d = fractions . gcd ( d , l [ i ] ) <NEWLINE> <DEDENT> if a != b and b != c and a != c : <NEWLINE> <INDENT> ans += d * 6 <NEWLINE> <DEDENT> elif ( a == b and a != c ) or ( a == c and a != b ) or ( b == c and a != b ) : <NEWLINE> <INDENT> ans += d * 3 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += d <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> <NL> <INDENT> k = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> <NL> for h in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for i in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> l = math . gcd ( h , i ) <NEWLINE> for j in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> ans += math . gcd ( l , j ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
from math import math <NEWLINE> <NL> K = int ( input ( ) ) <NEWLINE> cnt = 0 <NEWLINE> <NL> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for k in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> cnt += gcd ( gcd ( i , j ) , k ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
from fractions import gcd <NEWLINE> <NL> K = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> t = gcd ( i , j ) <NEWLINE> for k in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> ans += gcd ( k , t ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> import fractions <NEWLINE> <NL> k = input ( ) <NEWLINE> <NL> sum = 0 <NEWLINE> for a in range ( k ) : <NEWLINE> <INDENT> for b in range ( k ) : <NEWLINE> <INDENT> x = fractions . gcd ( a + 1 , b + 1 ) <NEWLINE> for c in range ( k ) : <NEWLINE> <INDENT> y = fractions . gcd ( x , c + 1 ) <NEWLINE> sum += y <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( sum ) <NEWLINE>
import math <NEWLINE> k = int ( input ( ) ) <NEWLINE> sum = 0 <NEWLINE> for a in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for b in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> x = gcd ( a , b ) <NEWLINE> for c in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> sum += gcd ( x , c ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( sum ) <NEWLINE>
K = int ( input ( ) ) <NEWLINE> <NL> from fractions import gcd <NEWLINE> <COMMENT> <NL> <NL> d = { } <NEWLINE> d2 = { } <NEWLINE> <NL> def f ( x , y , z ) : <NEWLINE> <INDENT> s = gcd ( x , y ) <NEWLINE> t = gcd ( s , z ) <NEWLINE> return t <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for j in range ( i , K + 1 ) : <NEWLINE> <INDENT> for k in range ( j , K + 1 ) : <NEWLINE> <INDENT> if i == j == k : <NEWLINE> <INDENT> ans += f ( i , j , k ) <NEWLINE> <DEDENT> elif i == j or j == k : <NEWLINE> <INDENT> ans += 3 * f ( i , j , k ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += 6 * f ( i , j , k ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from Math import gcd <NEWLINE> <NL> K = int ( input ( ) ) <NEWLINE> <NL> result = 0 <NEWLINE> for a in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for b in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for c in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> result += gcd ( c , gcd ( a , b ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( result ) <NEWLINE>
import math <NEWLINE> k = int ( input ( ) ) + 1 <NEWLINE> for i in range ( 1 , k ) : <NEWLINE> <INDENT> for j in range ( 1 , k ) : <NEWLINE> <INDENT> temp = math . gcd ( i , j ) <NEWLINE> for x in range ( 1 , k ) : <NEWLINE> <INDENT> sum += math . gcd ( temp , x ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( sum ) <NEWLINE>
from math import gcd <NEWLINE> k = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> v = gcd ( i , j ) <NEWLINE> for m in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> ans += math . gcd ( v , m ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import itertools <NEWLINE> from fractions import gcd <NEWLINE> <NL> K = int ( input ( ) ) <NEWLINE> l = range ( 1 , K + 1 ) <NEWLINE> ans = sum ( l ) <NEWLINE> <NL> for a , b in itertools . combinations ( l , 2 ) : <NEWLINE> <INDENT> ans += gcd ( a , b ) * 6 <NEWLINE> <NL> <DEDENT> for a , b , c in itertools . combinations ( l , 3 ) : <NEWLINE> <INDENT> ans += gcd ( gcd ( a , b ) , c ) * 6 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
n = input ( ) <NEWLINE> total = 0 <NEWLINE> <NL> <COMMENT> <NL> def gcd ( a , b ) : <NEWLINE> <INDENT> if b == 0 : <NEWLINE> <INDENT> return a <NEWLINE> <NL> <DEDENT> return gcd ( b , a % b ) <NEWLINE> <NL> <DEDENT> total = total + n * ( n + 1 ) / 2 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n ) : <NEWLINE> <INDENT> total = total + 6 * gcd ( j + 1 , i + 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n ) : <NEWLINE> <INDENT> for k in range ( j + 1 , n ) : <NEWLINE> <INDENT> l = gcd ( j + 1 , k + 1 ) <NEWLINE> if i < l : <NEWLINE> <INDENT> total = total + 6 * gcd ( l , i + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> total = total + 6 * gcd ( i + 1 , l ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( int ( total ) ) <NEWLINE>
import fractions <NEWLINE> k = int ( input ( ) ) <NEWLINE> ans = k ** 3 - ( k - 1 ) ** 3 <NEWLINE> for a in range ( 2 , k + 1 ) : <NEWLINE> <INDENT> for b in range ( 2 , k + 1 ) : <NEWLINE> <INDENT> for c in range ( 2 , k + 1 ) : <NEWLINE> <INDENT> ans += fractions . gcd ( a , fractions . gcd ( b , c ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from fractions import gcd <NEWLINE> n = int ( input ( ) ) <NEWLINE> gcdf = 0 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> for k in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> gcdf = gcdf + gcd ( i , gcd ( j , k ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( gcdf ) <NEWLINE>
from fractions import gcd <NEWLINE> k = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for a in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for b in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for c in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> ans += gcd ( gcd ( a , b ) , c ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
def main ( ) : <COMMENT> <NEWLINE> <INDENT> k = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for l in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> ans += gcd ( gcd ( i , j ) , l ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <COMMENT> <NEWLINE> <DEDENT>
from fractions import gcd <NEWLINE> k = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for p in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for q in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for r in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> ans += gcd ( p , gcd ( q , r ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> from functools import reduce <NEWLINE> K = 200 <NEWLINE> ans = 0 <NEWLINE> def gcd ( * numbers ) : <NEWLINE> <INDENT> return reduce ( math . gcd , numbers ) <NEWLINE> <DEDENT> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for k in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> ans += gcd ( i , j , k ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import math , string , itertools , fractions , heapq , collections , re , array , bisect , sys , random , time , copy , functools <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> from queue import PriorityQueue <NEWLINE> from fractions import gcd <NEWLINE> inf = 10 ** 20 <NEWLINE> eps = 1.0 / 10 ** 10 <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> dd = [ ( - 1 , 0 ) , ( 0 , 1 ) , ( 1 , 0 ) , ( 0 , - 1 ) ] <NEWLINE> ddn = [ ( - 1 , 0 ) , ( - 1 , 1 ) , ( 0 , 1 ) , ( 1 , 1 ) , ( 1 , 0 ) , ( 1 , - 1 ) , ( 0 , - 1 ) , ( - 1 , - 1 ) ] <NEWLINE> def LI ( ) : return [ int ( x ) for x in sys . stdin . readline ( ) . split ( ) ] <NEWLINE> def LI_ ( ) : return [ int ( x ) - 1 for x in sys . stdin . readline ( ) . split ( ) ] <NEWLINE> def LF ( ) : return [ float ( x ) for x in sys . stdin . readline ( ) . split ( ) ] <NEWLINE> def LS ( ) : return sys . stdin . readline ( ) . split ( ) <NEWLINE> def _I ( ) : return int ( sys . stdin . readline ( ) ) <NEWLINE> def _F ( ) : return float ( sys . stdin . readline ( ) ) <NEWLINE> def _pf ( s ) : return print ( s , flush = True ) <NEWLINE> def gcd ( * numbers ) : <NEWLINE> <INDENT> return functools . reduce ( math . gcd , numbers ) <NEWLINE> <DEDENT> def make_divisors ( n ) : <NEWLINE> <INDENT> divisors = [ ] <NEWLINE> for i in range ( 1 , int ( n ** 0.5 ) + 1 ) : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> divisors . append ( i ) <NEWLINE> if i != n // i : <NEWLINE> <INDENT> divisors . append ( n // i ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> divisors . sort ( reverse = True ) <NEWLINE> return divisors <NEWLINE> <NL> <DEDENT> K = _I ( ) <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for k in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> ans += math . gcd ( math . gcd ( i , j ) , k ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> exit ( ) <NEWLINE>
from fractions import gcd <NEWLINE> from math import gcd <NEWLINE> <NL> total = 0 <NEWLINE> for a in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for b in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for c in range ( 1 , k + 1 ) : <NEWLINE> <COMMENT> <NL> <INDENT> total += gcd ( a , gcd ( b , c ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( total ) <NEWLINE>
import fractions <NEWLINE> from functools import reduce <NEWLINE> <NL> k = int ( input ( ) ) <NEWLINE> <NL> result = 0 <NEWLINE> <NL> def gcd ( * numbers ) : <NEWLINE> <INDENT> return reduce ( fractions . gcd , numbers ) <NEWLINE> <NL> <DEDENT> for a in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for b in range ( a , k + 1 ) : <NEWLINE> <INDENT> for c in range ( b , k + 1 ) : <NEWLINE> <INDENT> if a == b == c : <NEWLINE> <INDENT> result += a <NEWLINE> <DEDENT> elif a == b and a != c : <NEWLINE> <INDENT> result += gcd ( a , c ) * 3 <NEWLINE> <DEDENT> elif a == c and a != b : <NEWLINE> <INDENT> result += gcd ( a , b ) * 3 <NEWLINE> <DEDENT> elif b == c and a != b : <NEWLINE> <INDENT> result += gcd ( a , b ) * 3 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> result += gcd ( a , b , c ) * 6 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( result ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <NL> import math <NEWLINE> <NL> k = int ( input ( ) ) + 1 <NEWLINE> ans = 0 <NEWLINE> for a in range ( 1 , k ) : <NEWLINE> <INDENT> for b in range ( 1 , k ) : <NEWLINE> <INDENT> g = math . gcd ( a , b ) <NEWLINE> for c in range ( 1 , k ) : <NEWLINE> <INDENT> ans += gcd ( g , c ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> from functools import reduce <NEWLINE> import itertools <NEWLINE> <NL> def gcd ( * numbers ) : <NEWLINE> <INDENT> return reduce ( math . gcd , numbers ) <NEWLINE> <NL> <DEDENT> k = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> <NL> seq = [ i for i in range ( 1 , k + 1 ) ] <NEWLINE> b = list ( itertools . combinations_with_replacement ( seq , 3 ) ) <NEWLINE> <NL> for a in b : <NEWLINE> <INDENT> if a [ 0 ] == a [ 1 ] == a [ 2 ] : <NEWLINE> <INDENT> ans += gcd ( a [ 0 ] , a [ 1 ] , a [ 2 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += gcd ( a [ 0 ] , a [ 1 ] , a [ 2 ] ) * ( n + 1 ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> <NL> A = int ( input ( ) ) <NEWLINE> <COMMENT> <NL> ans = 0 <NEWLINE> import math <NEWLINE> <NL> <NL> for i in range ( 1 , A + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , A + 1 ) : <NEWLINE> <INDENT> for k in range ( 1 , A + 1 ) : <NEWLINE> <INDENT> ans += gcd ( gcd ( i , j ) , k ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
@ lru_cache ( maxsize = 10 ** 5 ) <NEWLINE> def cached_gcd ( i , j ) : <NEWLINE> <INDENT> return math . gcd ( i , j ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> total = 0 <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> g = cached_gcd ( j , i ) <NEWLINE> for k in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> total += cached_gcd ( k , g ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( total ) <NEWLINE> <NL> <DEDENT>
from colloctions import Counter <NEWLINE> from scipy import gcd <NEWLINE> <NL> def sum_of_gcd ( N ) : <NEWLINE> <INDENT> temp = [ gcd ( i , k ) for i in range ( 1 , N + 1 ) for k in range ( 1 , N + 1 ) ] <NEWLINE> counts = Counter ( temp ) <NEWLINE> return sum ( [ gcd ( i , c ) * counts [ c ] for i in range ( 1 , N + 1 ) for c in counts . keys ( ) ] ) <NEWLINE> <NL> <DEDENT> print ( sum_of_gcd ( int ( input ( ) ) ) ) <NEWLINE>
from fractions import gcd <NEWLINE> n = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> for k in range ( i , n + 1 ) : <NEWLINE> <INDENT> for _ in range ( k , n + 1 ) : <NEWLINE> <INDENT> g = gcd ( gcd ( i , k ) , _ ) <NEWLINE> if i == _ : <NEWLINE> <INDENT> ans += g <NEWLINE> <DEDENT> elif i == k or k == _ : <NEWLINE> <INDENT> ans += g * 3 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += g * 6 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<NL> import fractions <NEWLINE> from functools import reduce <NEWLINE> <NL> <NL> k = int ( input ( ) ) <NEWLINE> <NL> def gcd ( * numbers ) : <NEWLINE> <INDENT> return reduce ( fractions . gcd , numbers ) <NEWLINE> <NL> <DEDENT> k += 1 <NEWLINE> ans = 0 <NEWLINE> <NL> for i in range ( 1 , k ) : <NEWLINE> <INDENT> for j in range ( i , k ) : <NEWLINE> <COMMENT> <NL> <INDENT> if i == j : <NEWLINE> <INDENT> ans += gcd ( i , j ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += gcd ( i , j ) * 6 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for i in range ( 1 , k ) : <NEWLINE> <INDENT> for j in range ( ( i + 1 ) , k ) : <NEWLINE> <INDENT> for h in range ( ( j + 1 ) , k ) : <NEWLINE> <COMMENT> <NL> <INDENT> ans += gcd ( i , j , h ) * 6 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
k = int ( input ( ) ) + 1 <NEWLINE> from math import gcd <NEWLINE> print ( sum ( gcd ( gcd ( i , j ) , r ) for i in range ( 1 , k ) for j in range ( 1 , k ) for r in range ( 1 , k ) ) <NEWLINE> k = int ( input ( ) ) + 1 <NEWLINE> from math import gcd <NEWLINE> print ( sum ( gcd ( gcd ( i , j ) , r ) for i in range ( 1 , k ) for j in range ( 1 , k ) for r in range ( 1 , k ) ) ) <NEWLINE>
import fractions <NEWLINE> from functools import reduce <NEWLINE> import itertools <NEWLINE> k = int ( input ( ) ) <NEWLINE> l = list ( range ( 1 , k + 1 ) ) <NEWLINE> ans = 0 <NEWLINE> def gcd ( * numbers ) : <NEWLINE> <INDENT> return reduce ( fractions . gcd , numbers ) <NEWLINE> <DEDENT> for v in itertools . product ( l , repeat = 3 ) : <NEWLINE> <INDENT> ans += gcd ( * list ( v ) ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
from fractions import gcd <NEWLINE> k = int ( input ( ) ) <NEWLINE> r1 = [ ] <NEWLINE> r2 = [ ] <NEWLINE> for l in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for m in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> r1 . append ( gcd ( l , m ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( len ( r1 ) ) : <NEWLINE> <INDENT> for j in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> r2 . append ( gcd ( r1 [ i ] , j ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( sum ( r2 ) ) <NEWLINE>
import math <NEWLINE> from functools import reduce <NEWLINE> <NL> def gcd ( * numbers ) : <NEWLINE> <INDENT> return reduce ( math . gcd , numbers ) <NEWLINE> <NL> <DEDENT> k = int ( input ( ) ) <NEWLINE> r = 0 <NEWLINE> l = [ ] <NEWLINE> <NL> for i in range ( k ) : <NEWLINE> <INDENT> for j in range ( k ) : <NEWLINE> <INDENT> for l in range ( k ) : <NEWLINE> <INDENT> if i <= j and j <= k : <NEWLINE> <INDENT> l . append ( [ i + 1 , j + 1 , k + 1 ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for s in l : <NEWLINE> <INDENT> r += gcd ( s [ 0 ] , s [ 1 ] , s [ 2 ] ) <NEWLINE> <DEDENT> print ( r ) <NEWLINE>
import math <NEWLINE> from functools import reduce <NEWLINE> import itertools <NEWLINE> import numpy as np <NEWLINE> <NL> <NL> def gcd_list ( numbers ) : <NEWLINE> <INDENT> return reduce ( math . gcd , numbers ) <NEWLINE> <NL> <NL> <DEDENT> K = int ( input ( ) ) <NEWLINE> <NL> l = [ i for i in range ( 1 , K + 1 ) ] <NEWLINE> <NL> temp_1 = np . array ( [ ] ) <NEWLINE> for j in itertools . combinations ( l , 3 ) : <NEWLINE> <INDENT> temp_1 = np . append ( temp_1 , gcd_list ( list ( j ) ) ) <NEWLINE> <NL> <DEDENT> a = np . sum ( temp_1 ) * 6 <NEWLINE> <NL> temp_2 = np . array ( [ ] ) <NEWLINE> <NL> for j in itertools . combinations ( l , 2 ) : <NEWLINE> <INDENT> temp_2 = np . append ( temp_2 , gcd_list ( list ( j [ 0 ] , j [ 0 ] , j [ 1 ] ) ) ) <NEWLINE> temp_2 = np . append ( temp_2 , gcd_list ( list ( j [ 0 ] , j [ 1 ] , j [ 1 ] ) ) ) <NEWLINE> <NL> <DEDENT> b = np . sum ( temp_2 ) * 3 <NEWLINE> <NL> temp_3 = np . array ( [ ] ) <NEWLINE> for i in l : <NEWLINE> <INDENT> temp_3 = np . append ( temp_3 , gcd_list ( [ i , i , i ] ) ) <NEWLINE> <NL> <DEDENT> print ( int ( np . sum ( temp_3 ) + a + b ) ) <NEWLINE>
import fractions <NEWLINE> <NL> K = input ( ) <NEWLINE> <NL> Sum = 0 <NEWLINE> k = int ( K ) <NEWLINE> <NL> for A in range ( k ) : <NEWLINE> <INDENT> a = A + 1 <NEWLINE> for B in range ( k ) : <NEWLINE> <INDENT> b = B + 1 <NEWLINE> gcd_ab = fractions . gcd ( a , b ) <NEWLINE> for C in range ( k ) : <NEWLINE> <INDENT> c = C + 1 <NEWLINE> <NL> Sum = Sum + fractions . gcd ( gcd_ab , c ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( Sum ) <NEWLINE>
import fractions as fr <NEWLINE> k = int ( input ( ) ) <NEWLINE> ans = ( k + 1 ) * k // 2 <NEWLINE> tttt = [ [ 0 ] * ( k + 1 ) for _ in range ( k + 1 ) ] <NEWLINE> for i in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> if i == j : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if tttt [ i ] [ j ] != 0 : <NEWLINE> <INDENT> g = tttt [ i ] [ j ] <NEWLINE> ans += 3 * g <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> g = fr . gcd ( i , j ) <NEWLINE> tttt [ i ] [ j ] = g <NEWLINE> tttt [ j ] [ i ] = g <NEWLINE> ans += 3 * g <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for i in range ( 1 , k - 1 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , k ) : <NEWLINE> <INDENT> for l in range ( j + 1 , k + 1 ) : <NEWLINE> <INDENT> temp = tttt [ i ] [ j ] <NEWLINE> temp2 = tttt [ temp ] [ l ] <NEWLINE> ans += 6 * tee <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
k = int ( input ( ) ) <NEWLINE> import fractions <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> an = fractions . gcd ( i , j ) <NEWLINE> for s in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> anse = fractions . gcd ( s , an ) <NEWLINE> ans += anse <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
K = int ( input ( ) ) <NEWLINE> <NL> if K == 1 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <NL> <DEDENT> def f ( K ) : <NEWLINE> <INDENT> s = 0 <NEWLINE> count = 0 <NEWLINE> for i in range ( 2 , K + 1 ) : <NEWLINE> <INDENT> if K % i != 1 : <NEWLINE> <INDENT> s += i <NEWLINE> count += 1 <NEWLINE> <DEDENT> <DEDENT> return 3 * K + s - count <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> ans = 0 <NEWLINE> for i in range ( 2 , K + 1 ) : <NEWLINE> <INDENT> ans += f ( K ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
from math import gcd <NEWLINE> z = range ( 1 , 1 + int ( input ( ) ) ) <NEWLINE> y = 0 <NEWLINE> for a in z : <NEWLINE> <INDENT> for b in z : <NEWLINE> <INDENT> for c in z : <NEWLINE> <INDENT> y += reduce ( gcd , ( a , b , c ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( y ) <NEWLINE>
import fractions as ma <NEWLINE> n = int ( input ( ) ) <NEWLINE> total = 0 <NEWLINE> <NL> for a in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> for b in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> d = ma . gcd ( a , b ) <NEWLINE> for c in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> total += ma . gcd ( d , c ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( total ) <NEWLINE>
import math <NEWLINE> import itertools <NEWLINE> GCD_over_150 = [ 4548003 , 4616104 , 4718640 , 4812789 , 4918561 , 5003286 , 5131848 , 5205481 , 5299011 , 5392008 , 5521384 , 5610705 , 5739009 , 5818390 , 5930196 , 6052893 , 6156139 , 6239472 , 6402720 , 6493681 , 6623853 , 6741078 , 6864016 , 6953457 , 7094451 , 7215016 , 7359936 , 7475145 , 7593865 , 7689630 , 7886244 , 7984165 , 8130747 , 8253888 , 8403448 , 8523897 , 8684853 , 8802826 , 8949612 , 9105537 , 9267595 , 9376656 , 9574704 , 9686065 , 9827097 , 9997134 , 10174780 , 10290813 , 10493367 , 10611772 , 10813692 ] <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> if N < 150 : <NEWLINE> <INDENT> GCD = [ ] <NEWLINE> GCD1 = [ ] <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> GCD . append ( i ) <NEWLINE> <DEDENT> for i in itertools . product ( GCD , repeat = 3 ) : <NEWLINE> GCD1 . append ( math . gcd ( math . gcd ( i [ 0 ] , i [ 1 ] ) , i [ 2 ] ) ) <NEWLINE> print ( sum ( GCD1 ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( GCD_over_150 [ N - 150 ] ) <NEWLINE> <DEDENT>
x = np . arange ( 1 , K + 1 ) <NEWLINE> nums = np . gcd . outer ( np . gcd . outer ( x , x ) , x ) <NEWLINE>
import itertools <NEWLINE> import fractions <NEWLINE> from functools import reduce <NEWLINE> k = int ( input ( ) ) <NEWLINE> num = [ ] <NEWLINE> for i in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> num . append ( i ) <NEWLINE> num . append ( i ) <NEWLINE> num . append ( i ) <NEWLINE> <DEDENT> permutation_num = set ( itertools . permutations ( num , 3 ) ) <NEWLINE> x = [ ] <NEWLINE> for j in permutation_num : <NEWLINE> <INDENT> y = reduce ( fractions . gcd , j ) <NEWLINE> x . append ( y ) <NEWLINE> <NL> <DEDENT> print ( sum ( x ) ) <NEWLINE>
import math <NEWLINE> import fractions <NEWLINE> import bisect <NEWLINE> import collections <NEWLINE> import itertools <NEWLINE> import heapq <NEWLINE> import string <NEWLINE> import sys <NEWLINE> import copy <NEWLINE> from decimal import * <NEWLINE> from collections import deque <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> INF = float ( <STRING> ) <COMMENT> <NEWLINE> def gcd ( a , b ) : return fractions . gcd ( a , b ) <COMMENT> <NEWLINE> def lcm ( a , b ) : return ( a * b ) // fractions . gcd ( a , b ) <COMMENT> <NEWLINE> def iin ( ) : return int ( sys . stdin . readline ( ) ) <COMMENT> <NEWLINE> def ifn ( ) : return float ( sys . stdin . readline ( ) ) <COMMENT> <NEWLINE> def isn ( ) : return sys . stdin . readline ( ) . split ( ) <COMMENT> <NEWLINE> def imn ( ) : return map ( int , sys . stdin . readline ( ) . split ( ) ) <COMMENT> <NEWLINE> def imnn ( ) : return map ( lambda x : int ( x ) - 1 , sys . stdin . readline ( ) . split ( ) ) <COMMENT> <NEWLINE> def fmn ( ) : return map ( float , sys . stdin . readline ( ) . split ( ) ) <COMMENT> <NEWLINE> def iln ( ) : return list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) <COMMENT> <NEWLINE> def iln_s ( ) : return sorted ( iln ( ) ) <COMMENT> <NEWLINE> def iln_r ( ) : return sorted ( iln ( ) , reverse = True ) <COMMENT> <NEWLINE> def fln ( ) : return list ( map ( float , sys . stdin . readline ( ) . split ( ) ) ) <COMMENT> <NEWLINE> def join ( l , s = <STRING> ) : return s . join ( l ) <COMMENT> <NEWLINE> def perm ( l , n ) : return itertools . permutations ( l , n ) <COMMENT> <NEWLINE> def perm_count ( n , r ) : return math . factorial ( n ) // math . factorial ( n - r ) <COMMENT> <NEWLINE> def comb ( l , n ) : return itertools . combinations ( l , n ) <COMMENT> <NEWLINE> def comb_count ( n , r ) : return math . factorial ( n ) // ( math . factorial ( n - r ) * math . factorial ( r ) ) <COMMENT> <NEWLINE> def two_distance ( a , b , c , d ) : return ( ( c - a ) ** 2 + ( d - b ) ** 2 ) ** .5 <COMMENT> <NEWLINE> def m_add ( a , b ) : return ( a + b ) % MOD <NEWLINE> def print_list ( l ) : print ( * l , sep = <STRING> ) <NEWLINE> def Yes ( ) : print ( <STRING> ) <NEWLINE> def No ( ) : print ( <STRING> ) <NEWLINE> def YES ( ) : print ( <STRING> ) <NEWLINE> def No ( ) : print ( <STRING> ) <NEWLINE> <NL> def sieves_of_e ( n ) : <NEWLINE> <INDENT> is_prime = [ True ] * ( n + 1 ) <NEWLINE> is_prime [ 0 ] = False <NEWLINE> is_prime [ 1 ] = False <NEWLINE> for i in range ( 2 , int ( n ** 0.5 ) + 1 ) : <NEWLINE> <INDENT> if not is_prime [ i ] : continue <NEWLINE> for j in range ( i * 2 , n + 1 , i ) : is_prime [ j ] = False <NEWLINE> <DEDENT> return is_prime <NEWLINE> <DEDENT> K = iin ( ) <NEWLINE> <NL> ans = 0 <NEWLINE> for a in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for b in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for c in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> tmp = math . gcd ( a , b ) <NEWLINE> tmp = math . gcd ( tmp , c ) <NEWLINE> ans += tmp <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> import math <NEWLINE> import fractions <NEWLINE> import bisect <NEWLINE> import collections <NEWLINE> import itertools <NEWLINE> import heapq <NEWLINE> import string <NEWLINE> import sys <NEWLINE> import copy <NEWLINE> from decimal import * <NEWLINE> from collections import deque <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> INF = float ( <STRING> ) <COMMENT> <NEWLINE> def gcd ( a , b ) : return fractions . gcd ( a , b ) <COMMENT> <NEWLINE> def lcm ( a , b ) : return ( a * b ) // fractions . gcd ( a , b ) <COMMENT> <NEWLINE> def iin ( ) : return int ( sys . stdin . readline ( ) ) <COMMENT> <NEWLINE> def ifn ( ) : return float ( sys . stdin . readline ( ) ) <COMMENT> <NEWLINE> def isn ( ) : return sys . stdin . readline ( ) . split ( ) <COMMENT> <NEWLINE> def imn ( ) : return map ( int , sys . stdin . readline ( ) . split ( ) ) <COMMENT> <NEWLINE> def imnn ( ) : return map ( lambda x : int ( x ) - 1 , sys . stdin . readline ( ) . split ( ) ) <COMMENT> <NEWLINE> def fmn ( ) : return map ( float , sys . stdin . readline ( ) . split ( ) ) <COMMENT> <NEWLINE> def iln ( ) : return list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) <COMMENT> <NEWLINE> def iln_s ( ) : return sorted ( iln ( ) ) <COMMENT> <NEWLINE> def iln_r ( ) : return sorted ( iln ( ) , reverse = True ) <COMMENT> <NEWLINE> def fln ( ) : return list ( map ( float , sys . stdin . readline ( ) . split ( ) ) ) <COMMENT> <NEWLINE> def join ( l , s = <STRING> ) : return s . join ( l ) <COMMENT> <NEWLINE> def perm ( l , n ) : return itertools . permutations ( l , n ) <COMMENT> <NEWLINE> def perm_count ( n , r ) : return math . factorial ( n ) // math . factorial ( n - r ) <COMMENT> <NEWLINE> def comb ( l , n ) : return itertools . combinations ( l , n ) <COMMENT> <NEWLINE> def comb_count ( n , r ) : return math . factorial ( n ) // ( math . factorial ( n - r ) * math . factorial ( r ) ) <COMMENT> <NEWLINE> def two_distance ( a , b , c , d ) : return ( ( c - a ) ** 2 + ( d - b ) ** 2 ) ** .5 <COMMENT> <NEWLINE> def m_add ( a , b ) : return ( a + b ) % MOD <NEWLINE> def print_list ( l ) : print ( * l , sep = <STRING> ) <NEWLINE> def Yes ( ) : print ( <STRING> ) <NEWLINE> def No ( ) : print ( <STRING> ) <NEWLINE> def YES ( ) : print ( <STRING> ) <NEWLINE> def No ( ) : print ( <STRING> ) <NEWLINE> <NL> def sieves_of_e ( n ) : <NEWLINE> <INDENT> is_prime = [ True ] * ( n + 1 ) <NEWLINE> is_prime [ 0 ] = False <NEWLINE> is_prime [ 1 ] = False <NEWLINE> for i in range ( 2 , int ( n ** 0.5 ) + 1 ) : <NEWLINE> <INDENT> if not is_prime [ i ] : continue <NEWLINE> for j in range ( i * 2 , n + 1 , i ) : is_prime [ j ] = False <NEWLINE> <DEDENT> return is_prime <NEWLINE> <NL> <DEDENT> K = iin ( ) <NEWLINE> <NL> ans = 0 <NEWLINE> for a in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for b in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for c in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> if a == 1 or b == 1 or c == 1 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> elif a == b == c : <NEWLINE> <INDENT> ans += a <NEWLINE> <DEDENT> elif a == b : <NEWLINE> <INDENT> ans += math . gcd ( a , c ) <NEWLINE> <DEDENT> elif a == c : <NEWLINE> <INDENT> ans += math . gcd ( b , c ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> tmp = math . gcd ( a , b ) <NEWLINE> if tmp == 1 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> tmp = math . gcd ( tmp , c ) <NEWLINE> ans += tmp <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
K = int ( input ( ) ) <NEWLINE> result = 0 <NEWLINE> import fractions <NEWLINE> <NL> for a in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for b in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> d = fractions . gcd ( a , b ) <NEWLINE> for c in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> result += fractions . gcd ( d , c ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( result ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> import math <NEWLINE> from fractions import gcd <NEWLINE> s = 0 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> for k in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> s += math . gcd ( math . gcd ( i , j ) , k ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( s ) <NEWLINE>
import sys <NEWLINE> import os <NEWLINE> import fractions <NEWLINE> import itertools <NEWLINE> <NL> def file_input ( ) : <NEWLINE> <INDENT> f = open ( <STRING> , <STRING> ) <NEWLINE> sys . stdin = f <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <COMMENT> <NL> <INDENT> K = int ( input ( ) ) <NEWLINE> <COMMENT> <NL> sum = 0 <NEWLINE> <NL> combi_l = itertools . combinations_with_replacement ( range ( 1 , K + 1 ) , 3 ) <NEWLINE> <COMMENT> <NL> <NL> for combi in combi_l : <NEWLINE> <COMMENT> <NL> <INDENT> if combi [ 0 ] == combi [ 1 ] == combi [ 2 ] : <NEWLINE> <INDENT> sum += fractions . gcd ( fractions . gcd ( combi [ 0 ] , combi [ 1 ] ) , combi [ 2 ] ) <NEWLINE> <DEDENT> elif combi [ 0 ] == combi [ 1 ] or combi [ 1 ] == combi [ 2 ] or combi [ 2 ] == combi [ 0 ] : <NEWLINE> <INDENT> sum += 3 * fractions . gcd ( fractions . gcd ( combi [ 0 ] , combi [ 1 ] ) , combi [ 2 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> sum += 6 * fractions . gcd ( fractions . gcd ( combi [ 0 ] , combi [ 1 ] ) , combi [ 2 ] ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> print ( sum ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = 0 <NEWLINE> for i in range ( n + 1 ) : <NEWLINE> <INDENT> for j in range ( n + 1 ) : <NEWLINE> <INDENT> for k in range ( n + 1 ) : <NEWLINE> <INDENT> a += g [ g [ i ] [ j ] ] [ k ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( a ) <NEWLINE>
def gcd ( a , b , c ) : <NEWLINE> <INDENT> import fractions <NEWLINE> lis = [ a , b , c ] <NEWLINE> gc = lis [ 0 ] <NEWLINE> for i in range ( 0 , 3 ) : <NEWLINE> <INDENT> gc = fractions . gcd ( gc , lis [ i ] ) <NEWLINE> <DEDENT> return gc <NEWLINE> <DEDENT> def main ( ) : <NEWLINE> <INDENT> K = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for p in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for s in range ( p , K + 1 ) : <NEWLINE> <INDENT> for k in range ( s , K + 1 ) : <NEWLINE> <INDENT> if p == s == k : <NEWLINE> <INDENT> ans += p <NEWLINE> <DEDENT> elif p == s or s == k or p == k : <NEWLINE> <INDENT> ans += 3 * gcd ( p , s , k ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += 6 * gcd ( p , s , k ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> K = int ( input ( ) ) <NEWLINE> a = np . arange ( a , K + 1 ) <NEWLINE> b = np . gcd . outer ( np . gcd . outer ( a , a ) , a ) <NEWLINE> print ( np . sum ( b ) ) <NEWLINE>
def debug ( arg ) : <NEWLINE> <INDENT> if __debug__ : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> import sys <NEWLINE> print ( arg , file = sys . stderr ) <NEWLINE> <NL> <NL> <NL> <DEDENT> <DEDENT> k = ( int ( x ) for x in input ( ) . split ( ) ) <NEWLINE> <NL> n = 3 <NEWLINE> c = { } <NEWLINE> t = 0 <NEWLINE> for x in range ( k , 0 , - 1 ) : <NEWLINE> <INDENT> c [ x ] = ( k // x ) ** n <NEWLINE> c [ x ] = c [ x ] - sum ( c [ x * y ] for y in range ( 2 , k // x + 1 ) ) <NEWLINE> s = c [ x ] * x <NEWLINE> t += s <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> print ( t ) <NEWLINE>
k = int ( input ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> for a in range ( 1 , k ) : <NEWLINE> <INDENT> for b in range ( 1 , k ) : <NEWLINE> <INDENT> for c in range ( 1 , k ) : <NEWLINE> <INDENT> ans += gcd ( a , b , c ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> import queue <NEWLINE> from collections import defaultdict <NEWLINE> <NL> def readInt ( ) : <NEWLINE> <INDENT> return int ( input ( ) ) <NEWLINE> <DEDENT> def readInts ( ) : <NEWLINE> <INDENT> return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <DEDENT> def readChar ( ) : <NEWLINE> <INDENT> return input ( ) <NEWLINE> <DEDENT> def readChars ( ) : <NEWLINE> <INDENT> return input ( ) . split ( ) <NEWLINE> <DEDENT> def factorization ( n ) : <NEWLINE> <INDENT> res = [ ] <NEWLINE> if n % 2 == 0 : <NEWLINE> <INDENT> res . append ( 2 ) <NEWLINE> <DEDENT> for i in range ( 3 , math . floor ( n // 2 ) + 1 , 2 ) : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> c = 0 <NEWLINE> for j in res : <NEWLINE> <INDENT> if i % j == 0 : <NEWLINE> <INDENT> c = 1 <NEWLINE> <DEDENT> <DEDENT> if c == 0 : <NEWLINE> <INDENT> res . append ( i ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return res <NEWLINE> <DEDENT> def fact2 ( n ) : <NEWLINE> <INDENT> p = factorization ( n ) <NEWLINE> res = [ ] <NEWLINE> for i in p : <NEWLINE> <INDENT> c = 0 <NEWLINE> z = n <NEWLINE> while 1 : <NEWLINE> <INDENT> if z % i == 0 : <NEWLINE> <INDENT> c += 1 <NEWLINE> z /= i <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> res . append ( [ i , c ] ) <NEWLINE> <DEDENT> return res <NEWLINE> <DEDENT> def fact ( n ) : <COMMENT> <NEWLINE> <INDENT> ans = 1 <NEWLINE> m = n <NEWLINE> for _i in range ( n - 1 ) : <NEWLINE> <INDENT> ans *= m <NEWLINE> m -= 1 <NEWLINE> <DEDENT> return ans <NEWLINE> <DEDENT> def comb ( n , r ) : <COMMENT> <NEWLINE> <INDENT> l = min ( r , n - r ) <NEWLINE> m = n <NEWLINE> u = 1 <NEWLINE> for _i in range ( l ) : <NEWLINE> <INDENT> u *= m <NEWLINE> m -= 1 <NEWLINE> <DEDENT> return u // fact ( l ) <NEWLINE> <DEDENT> def printQueue ( q ) : <NEWLINE> <INDENT> r = q <NEWLINE> ans = [ 0 ] * r . qsize ( ) <NEWLINE> for i in range ( r . qsize ( ) - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> ans [ i ] = r . get ( ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> K = readInt ( ) <NEWLINE> d = defaultdict ( int ) <NEWLINE> ans = 0 <NEWLINE> for a in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for b in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> x = gcd ( a , b ) <NEWLINE> for c in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> ans += gcd ( x , c ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> from functools import reduce <NEWLINE> <NL> def gcd ( * numbers ) : <NEWLINE> <INDENT> return reduce ( math . gcd , numbers ) <NEWLINE> <NL> <DEDENT> def gcd_list ( numbers ) : <NEWLINE> <INDENT> return reduce ( math . gcd , numbers ) <NEWLINE> <NL> <DEDENT> K = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for a in range ( 1 , 200 + 1 ) : <NEWLINE> <INDENT> for b in range ( 1 , 200 + 1 ) : <NEWLINE> <INDENT> for c in range ( 1 , 200 + 1 ) : <NEWLINE> <INDENT> ans += gcd ( a , b , c ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from collections import defaultdict , deque <NEWLINE> import sys <NEWLINE> import heapq <NEWLINE> import bisect <NEWLINE> import math <NEWLINE> import itertools <NEWLINE> import string <NEWLINE> import queue <NEWLINE> import copy <NEWLINE> import time <NEWLINE> <COMMENT> <NL> from fractions import gcd <NEWLINE> <NL> sys . setrecursionlimit ( 10 ** 8 ) <NEWLINE> INF = float ( <STRING> ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> eps = 10 ** - 7 <NEWLINE> <NL> def inp ( ) : return int ( sys . stdin . readline ( ) ) <NEWLINE> <NL> def inp_list ( ) : return list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) <NEWLINE> <NL> def lcm ( x , y ) : return ( x * y ) // gcd ( x , y ) <NEWLINE> <NL> <NL> def gcd_3 ( x , y , z ) : <NEWLINE> <INDENT> return gcd ( gcd ( x , y ) , z ) <NEWLINE> <NL> <DEDENT> K = inp ( ) <NEWLINE> <NL> <COMMENT> <NL> ans = 0 <NEWLINE> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for j in range ( i , K + 1 ) : <NEWLINE> <INDENT> for k in range ( j , K + 1 ) : <NEWLINE> <INDENT> a = gcd_3 ( i , j , k ) <NEWLINE> if i == j == k : <NEWLINE> <INDENT> ans += a <NEWLINE> <DEDENT> elif i == j or j == k : <NEWLINE> <INDENT> ans += a * 3 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += a * 3 * 2 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from fractions import gcd <NEWLINE> N = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( N + 1 ) : <NEWLINE> <INDENT> for k in range ( N + 1 ) : <NEWLINE> <INDENT> for l in range ( N + 1 ) : <NEWLINE> <INDENT> ans += gcd ( gcd ( i , j ) , k ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> max_codiv = [ ] <NEWLINE> <NL> <COMMENT> <NL> n = int ( input ( ) ) <NEWLINE> <NL> import math <NEWLINE> <COMMENT> <NL> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> i_j = math . gcd ( i , j ) <NEWLINE> <INDENT> for k in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> i_j_k = math . gcd ( i_j , k ) <NEWLINE> max_codiv . append ( i_j_k ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( sum ( max_codiv ) ) <NEWLINE>
from fractions import gcd <NEWLINE> k = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for l in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> a = ( i , j , l ) <NEWLINE> if len ( a ) == 1 : <NEWLINE> <INDENT> ans = ans + i <NEWLINE> <DEDENT> elif len ( a ) == 2 : <NEWLINE> <INDENT> ans = ans + gcd ( a [ 0 ] , a [ 1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = ans + gcd ( a [ 0 ] , gcd ( a [ 1 ] , a [ 2 ] ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from math import gcd <NEWLINE> g = [ 201 * [ 0 ] for _ in range ( 201 ) ] <NEWLINE> for i in range ( 1 , 201 ) : <NEWLINE> <INDENT> for j in range ( i , 201 ) : <NEWLINE> <INDENT> g [ i ] [ j ] = gcd ( i , j ) <NEWLINE> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for i in range ( 1 , 201 ) : <NEWLINE> <INDENT> for j in range ( 1 , 201 ) : <NEWLINE> <INDENT> for k in range ( 1 , 201 ) : <NEWLINE> <INDENT> m = g [ min ( i , j ) ] [ max ( i , j ) ] <NEWLINE> ans += g [ min ( k , m ) ] [ max ( k , m ) ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> N = N + 1 <NEWLINE> sum = 0 <NEWLINE> <NL> import math <NEWLINE> <NL> def gcd ( * numbers ) : <NEWLINE> <INDENT> return reduce ( math . gcd , numbers ) <NEWLINE> <NL> <DEDENT> for i in range ( 1 , N ) : <NEWLINE> <INDENT> for j in range ( 1 , N ) : <NEWLINE> <INDENT> for k in range ( 1 , N ) : <NEWLINE> <INDENT> sum += gcd ( gcd ( i , j ) , k ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( sum ) <NEWLINE>
from collections import defaultdict , deque <NEWLINE> import sys <NEWLINE> import heapq <NEWLINE> import bisect <NEWLINE> import math <NEWLINE> import itertools <NEWLINE> import string <NEWLINE> import queue <NEWLINE> import copy <NEWLINE> import time <NEWLINE> <COMMENT> <NL> from fractions import gcd <NEWLINE> <NL> sys . setrecursionlimit ( 10 ** 8 ) <NEWLINE> INF = float ( <STRING> ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> eps = 10 ** - 7 <NEWLINE> <NL> def inp ( ) : return int ( sys . stdin . readline ( ) ) <NEWLINE> <NL> def inp_list ( ) : return list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) <NEWLINE> <NL> def lcm ( x , y ) : return ( x * y ) // gcd ( x , y ) <NEWLINE> <NL> <NL> def gcd_3 ( x , y , z ) : <NEWLINE> <INDENT> return gcd ( gcd ( x , y ) , z ) <NEWLINE> <NL> <DEDENT> K = inp ( ) <NEWLINE> <NL> <COMMENT> <NL> ans = 0 <NEWLINE> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for j in range ( i , K + 1 ) : <NEWLINE> <INDENT> for k in range ( j , K + 1 ) : <NEWLINE> <INDENT> a = gcd_3 ( i , j , k ) <NEWLINE> if i == j == k : <NEWLINE> <INDENT> ans += a <NEWLINE> <DEDENT> elif i == j or j == k : <NEWLINE> <INDENT> ans += a * 3 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += a * 3 * 2 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import fractions <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> <NL> total = 0 <NEWLINE> <NL> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> total += i <NEWLINE> <NL> <DEDENT> for i in range ( 1 , N ) : <NEWLINE> <INDENT> for j in range ( i + 1 , N + 1 ) : <NEWLINE> <INDENT> total += ( fractions . gcd ( i , j ) * 6 ) <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( 1 , N - 1 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , N ) : <NEWLINE> <INDENT> for k in range ( j + 1 , N + 1 ) : <NEWLINE> <INDENT> total += ( fractions . gcd ( fractions . gcd ( i , j ) , k ) * 6 ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( total ) <NEWLINE>
from fractions import gcd <NEWLINE> k = int ( input ( ) ) <NEWLINE> sum = 0 <NEWLINE> for a in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for b in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for c in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> sum += gcd ( gcd ( a , b ) , c ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( sum ) <NEWLINE>
import math <NEWLINE> from collections import Counter <NEWLINE> <NL> K = int ( input ( ) ) <NEWLINE> <NL> memo = { frozenset ( ( i , j ) ) : math . gcd ( i , j ) <NEWLINE> <INDENT> for i in range ( 1 , K + 1 ) for j in range ( i , K + 1 ) } <NEWLINE> <NL> <DEDENT> counter = Counter ( [ memo [ frozenset ( ( i , j ) ) ] <NEWLINE> <INDENT> for i in range ( 1 , K + 1 ) for j in range ( 1 , K + 1 ) ] ) <NEWLINE> <NL> <DEDENT> total = 0 <NEWLINE> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for value , count = counter . items ( ) : <NEWLINE> <INDENT> total += memo [ frozenset ( ( i , value ) ) ] * count <NEWLINE> <NL> <DEDENT> <DEDENT> print ( total ) <NEWLINE>
import math <NEWLINE> K = 200 <NEWLINE> ans = 0 <NEWLINE> for a in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for b in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for c in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> tempgcd = math . gcd ( a , b ) <NEWLINE> ans = ans + math . gcd ( tempgcd , c ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
k = int ( input ( ) ) <NEWLINE> sum = 0 <NEWLINE> for a in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for b in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for c in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> sum += gcd ( a , gcd ( b , c ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( sum ) <NEWLINE>
from fractions import gcd <NEWLINE> k = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for a in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for b in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for c in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> ans += gcd ( gcd ( a , b ) , c ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from gcd import math <NEWLINE> K = int ( input ( ) ) <NEWLINE> res = 0 <NEWLINE> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for k in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> res = res + gcd ( gcd ( i , j ) , k ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( res ) <NEWLINE>
from fractions import gcd <NEWLINE> n = int ( input ( ) ) <NEWLINE> cnt = 0 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> a = gcd ( i , j ) <NEWLINE> for k in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> cnt += gcd ( a , k ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
k = int ( input ( ) ) <NEWLINE> def gcd1 ( a , b ) : <NEWLINE> <INDENT> while True : <NEWLINE> <INDENT> if ( a < b ) : <NEWLINE> <INDENT> a , b = b , a <NEWLINE> <DEDENT> c = a % b <NEWLINE> if ( c == 0 ) : <NEWLINE> <INDENT> return ( b ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a = b <NEWLINE> b = c <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> def gcd2 ( a , b , c ) : <NEWLINE> <INDENT> tmp = gcd1 ( a , b ) <NEWLINE> ans = gcd1 ( tmp , c ) <NEWLINE> return ( ans ) <NEWLINE> <NL> <DEDENT> count = 0 <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> for j in range ( i , k ) : <NEWLINE> <INDENT> for l in range ( j , k ) : <NEWLINE> <INDENT> tmp = gcd ( i + 1 , j + 1 , l + 1 ) <NEWLINE> if ( i == j == l ) : <NEWLINE> <INDENT> count = count + tmp <NEWLINE> <DEDENT> elif ( i == j or j == l ) : <NEWLINE> <INDENT> count = count + tmp * 3 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> count = count + tmp * 6 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
import fractions <NEWLINE> k = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> <NL> for a in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for b in range ( 1 , a + 1 ) : <NEWLINE> <INDENT> for c in range ( 1 , b + 1 ) : <NEWLINE> <INDENT> g_ab = fractions . gcd ( a , b ) <NEWLINE> g_abc = fractions . gcd ( g_ab , c ) <NEWLINE> if a != b != c : <NEWLINE> <INDENT> ans += g_abc * 6 <NEWLINE> <DEDENT> elif a == b == c : <NEWLINE> <INDENT> ans += g_abc <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += g_abc * 3 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
K = int ( input ( ) ) <NEWLINE> total = 0 <NEWLINE> <NL> def gdc ( x , y ) : <NEWLINE> <INDENT> if x % y == 0 : <NEWLINE> <INDENT> return y <NEWLINE> <DEDENT> return gdc ( y , x % y ) <NEWLINE> <NL> <DEDENT> for a in range ( K ) : <NEWLINE> <INDENT> for b in range ( a , K ) : <NEWLINE> <INDENT> for c in range ( b , K ) : <NEWLINE> <INDENT> if a == b and b == c : <NEWLINE> <INDENT> total += gdc ( c + 1 , gdc ( b + 1 , a + 1 ) ) <NEWLINE> <DEDENT> elif a == b or b == c or a == c : <NEWLINE> <INDENT> total += 3 * gdc ( c + 1 , gdc ( b + 1 , a + 1 ) ) <NEWLINE> <DEDENT> eles : <NEWLINE> <INDENT> total += 6 * gdc ( c + 1 , gdc ( b + 1 , a + 1 ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( total ) <NEWLINE>
from itertools import product <NEWLINE> <NL> def gcb ( a , b ) : <NEWLINE> <INDENT> if a < b : <NEWLINE> <INDENT> a , b = b , a <NEWLINE> <DEDENT> if b == 0 : <NEWLINE> <INDENT> gcb_table [ a ] [ b ] = a <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if gcb_table [ a ] [ b ] == - 1 : <NEWLINE> <INDENT> gcb_table [ a ] [ b ] = gcb ( b , a % b ) <NEWLINE> <DEDENT> <DEDENT> return gcb_table [ a ] [ b ] <NEWLINE> <NL> <DEDENT> k = int ( input ( ) ) <NEWLINE> gcb_table = [ [ - 1 for _ in range ( k + 1 ) ] for _ in range ( k + 1 ) ] <NEWLINE> <NL> for i in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> temp = gcb ( i , j ) <NEWLINE> gcb_table [ i ] [ j ] = temp <NEWLINE> gcb_table [ j ] [ i ] = temp <NEWLINE> <NL> <DEDENT> <DEDENT> res = 0 <NEWLINE> l_k = range ( 1 , k + 1 ) <NEWLINE> for part in itertools . product ( l_k , l_k , l_k ) : <NEWLINE> <INDENT> gcb_first = gcb_table [ part [ 0 ] ] [ part [ 1 ] ] <NEWLINE> res += gcb_table [ gcb_first ] [ part [ 2 ] ] <NEWLINE> <DEDENT> print ( res ) <NEWLINE>
import math <NEWLINE> <NL> K = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> <NL> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> ab = math . gcd ( a , b ) <NEWLINE> for k in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> ans += math . gcd ( ab , c ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> <NL> h = itertools . combinations_with_replacement ( list ( range ( 1 , N + 1 ) ) , 3 ) <NEWLINE> <NL> import math <NEWLINE> from functools import reduce <NEWLINE> <NL> def gcd ( * numbers ) : <NEWLINE> <INDENT> return reduce ( math . gcd , numbers ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for n1 , n2 , n3 in h : <NEWLINE> <INDENT> if n1 == n2 == n3 : <NEWLINE> <INDENT> ans += gcd ( n1 , n2 , n3 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += gcd ( n1 , n2 , n3 ) * 3 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> <NL> from fractions import gcd <NEWLINE> from collections import Counter , deque , defaultdict <NEWLINE> from heapq import heappush , heappop , heappushpop , heapify , heapreplace , merge <NEWLINE> from bisect import bisect_left , bisect_right , bisect , insort_left , insort_right , insort <NEWLINE> from itertools import accumulate , product , permutations , combinations , combinations_with_replacement <NEWLINE> <NL> K = int ( input ( ) ) <NEWLINE> <NL> ret = 0 <NEWLINE> for a in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for b in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> n = gcd ( a , b ) <NEWLINE> for c in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> ret += gcd ( n , c ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ret ) <NEWLINE>
import fractions <NEWLINE> import itertools <NEWLINE> <NL> k = int ( input ( ) ) <NEWLINE> <NL> gcd_map = [ [ - 1 for i in range ( 1 , k + 1 ) ] for j in range ( 1 , k + 1 ) ] <NEWLINE> <NL> ans = 0 <NEWLINE> for a in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for b in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for c in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> if gcd_map [ a - 1 ] [ b - 1 ] == - 1 : <NEWLINE> <INDENT> gab = fractions . gcd ( a , b ) <NEWLINE> gcd_map [ a - 1 ] [ b - 1 ] = gab <NEWLINE> gcd_map [ b - 1 ] [ a - 1 ] = gab <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> gab = gcd_map [ a - 1 ] [ b - 1 ] <NEWLINE> <NL> <DEDENT> if gcd_map [ gab - 1 ] [ c - 1 ] == - 1 : <NEWLINE> <INDENT> gbc = fractions . gcd ( gab , c ) <NEWLINE> gcd_map [ gab - 1 ] [ c - 1 ] = gbc <NEWLINE> gcd_map [ c - 1 ] [ gab - 1 ] = gbc <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> gbc = gcd_map [ gab - 1 ] [ c - 1 ] <NEWLINE> <NL> <DEDENT> ans += gbc <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL>
import math <NEWLINE> k = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , j + 1 ) : <NEWLINE> <INDENT> gcd1 = math . gcd ( i , j ) <NEWLINE> for l in range ( 1 , l + 1 ) : <NEWLINE> <INDENT> gcd2 = math . gcd ( gcd1 , l ) <NEWLINE> ans += gcd2 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import math , string , itertools , fractions , heapq , collections , re , array , bisect , sys , copy , functools <NEWLINE> import time , random <NEWLINE> <NL> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> inf = 10 ** 20 <NEWLINE> eps = 1.0 / 10 ** 10 <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> mod2 = 998244353 <NEWLINE> dd = [ ( - 1 , 0 ) , ( 0 , 1 ) , ( 1 , 0 ) , ( 0 , - 1 ) ] <NEWLINE> ddn = [ ( - 1 , 0 ) , ( - 1 , 1 ) , ( 0 , 1 ) , ( 1 , 1 ) , ( 1 , 0 ) , ( 1 , - 1 ) , ( 0 , - 1 ) , ( - 1 , - 1 ) ] <NEWLINE> <NL> def LI ( ) : return list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) <NEWLINE> def LLI ( ) : return [ list ( map ( int , l . split ( ) ) ) for l in sys . stdin . readlines ( ) ] <NEWLINE> def LI_ ( ) : return [ int ( x ) - 1 for x in sys . stdin . readline ( ) . split ( ) ] <NEWLINE> def LF ( ) : return [ float ( x ) for x in sys . stdin . readline ( ) . split ( ) ] <NEWLINE> def LS ( ) : return sys . stdin . readline ( ) . split ( ) <NEWLINE> def I ( ) : return int ( sys . stdin . readline ( ) ) <NEWLINE> def F ( ) : return float ( sys . stdin . readline ( ) ) <NEWLINE> def S ( ) : return input ( ) <NEWLINE> def pf ( s ) : return print ( s , flush = True ) <NEWLINE> def pe ( s ) : return print ( str ( s ) , file = sys . stderr ) <NEWLINE> def JA ( a , sep ) : return sep . join ( map ( str , a ) ) <NEWLINE> def JAA ( a , s , t ) : return s . join ( t . join ( map ( str , b ) ) for b in a ) <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> k = I ( ) <NEWLINE> r = 0 <NEWLINE> for a , b , c in itertools . combinations_with_replacement ( range ( 1 , k + 1 ) , 3 ) : <NEWLINE> <INDENT> g = fractions . gcd ( fractions . gcd ( a , b ) , c ) <NEWLINE> if a == b : <NEWLINE> <INDENT> if b == c : <NEWLINE> <INDENT> r += g <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> r += g * 3 <NEWLINE> <DEDENT> <DEDENT> elif b == c : <NEWLINE> <INDENT> r += g * 3 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> r += g * 6 <NEWLINE> <NL> <DEDENT> <DEDENT> return r <NEWLINE> <NL> <NL> <DEDENT> print ( main ( ) ) <NEWLINE> <NL> <NL> <NL>
import fractions <NEWLINE> k = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for l in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> a = fractions . gcd ( i , j ) <NEWLINE> a = fractions . gcd ( a , l ) <NEWLINE> ans += a <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
k = int ( input ( ) ) <NEWLINE> import fractions <NEWLINE> x = 0 <NEWLINE> c = 0 <NEWLINE> d = 0 <NEWLINE> for i in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for j in range ( i , k + 1 ) : <NEWLINE> <INDENT> for k in range ( j , k + 1 ) : <NEWLINE> <INDENT> d = fractions . gcd ( i , j ) <NEWLINE> c = fractions . gcd ( d , k ) <NEWLINE> if i != j and j != k : <NEWLINE> <INDENT> x += 6 * c <NEWLINE> <DEDENT> elif i == j == k : <NEWLINE> <INDENT> x += c <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x += 3 * c <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( x ) <NEWLINE>
from fractions import gcd <NEWLINE> n = int ( input ( ) ) <NEWLINE> g = 0 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> for k in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> g += gcd ( gcd ( i , j ) , k ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( g ) <NEWLINE> <NL>
N = int ( input ( ) ) <NEWLINE> s = 0 <NEWLINE> for i in range ( 0 , N ) : <NEWLINE> <INDENT> if ( i + 1 ) % 3 1 = 0 or ( i + 1 ) % 5 != 0 : <NEWLINE> <INDENT> s = s + ( i + 1 ) <NEWLINE> <DEDENT> <DEDENT> print ( s ) <NEWLINE>
from fractions import gcd <NEWLINE> <NL> k = int ( input ( ) ) <NEWLINE> <NL> res = 0 <NEWLINE> mul = [ 0 , 1 , 3 , 6 ] <NEWLINE> for a in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for b in range ( a , k + 1 ) : <NEWLINE> <INDENT> for c in range ( b , k + 1 ) : <NEWLINE> <INDENT> res += gcd ( gcd ( a , b ) , c ) * mul [ len ( { a , b , c } ) ] <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( res ) <NEWLINE>
form math import gcd <NEWLINE> num = ( int ) ( input ( ) ) <NEWLINE> total = 0 <NEWLINE> <NL> for i in range ( 1 , num + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , num + 1 ) : <NEWLINE> <INDENT> sub = gcd ( i , j ) <NEWLINE> for k in range ( 1 , num + 1 ) : <NEWLINE> <INDENT> total += gcd ( sub , k ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( total ) <NEWLINE>
import math <NEWLINE> K = int ( input ( ) ) <NEWLINE> s = 0 <NEWLINE> for a in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for b in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> x = math . gcd ( a , b ) <NEWLINE> for c in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> s += gcd ( x , c ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( s ) <NEWLINE>
from math import gcd <NEWLINE> <NL> k = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for l in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> ans += gcd ( math . gcd ( i , j ) , l ) <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import itertools <NEWLINE> import fractions <NEWLINE> <NL> N = input ( ) <NEWLINE> N = int ( N ) <NEWLINE> <NL> l = list ( itertools . combinations_with_replacement ( list ( range ( 1 , N + 1 ) ) , 3 ) ) <NEWLINE> s_all = 0 <NEWLINE> for nums in l : <NEWLINE> <INDENT> count = 0 <NEWLINE> ans = nums [ 0 ] <NEWLINE> for i in range ( 1 , 3 ) : <NEWLINE> <INDENT> ans = fractions . gcd ( ans , nums [ i ] ) <NEWLINE> <DEDENT> a , b , c = nums [ 0 ] , nums [ 1 ] , nums [ 2 ] <NEWLINE> if a == b : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> if a == c : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> if b == c : <NEWLINE> <INDENT> count += 1 <NEWLINE> <NL> <DEDENT> if count == 0 : <NEWLINE> <INDENT> num = 6 <NEWLINE> <DEDENT> elif count == 1 : <NEWLINE> <INDENT> num = 3 <NEWLINE> <DEDENT> elif count == 3 : <NEWLINE> <INDENT> num = 1 <NEWLINE> <DEDENT> s_all += ans * num <NEWLINE> <DEDENT> print ( s_all ) <NEWLINE>
<NL> import fractions <NEWLINE> K = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> <NL> for n in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for m in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for l in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> gcd = fractions . gcd ( n , m ) <NEWLINE> gcd = fractions . gcd ( gcd , l ) <NEWLINE> <NL> ans += gcd <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> <NL> import math <NEWLINE> <NL> K = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> <NL> for a in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for b in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> ab = math . gcd ( a , b ) <NEWLINE> <NL> for c in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> ans += math . gcd ( ab , c ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
K = int ( sys . stdin . readline ( ) . rstrip ( ) ) <NEWLINE> <NL> def gcd ( a , b ) : <NEWLINE> <NL> <INDENT> if a < b : <NEWLINE> <INDENT> a , b = b , a <NEWLINE> <DEDENT> while a % b != 0 : <NEWLINE> <INDENT> a , b = b , a % b <NEWLINE> <DEDENT> return b <NEWLINE> <NL> <DEDENT> cnt1 = 0 <NEWLINE> cnt2 = 0 <NEWLINE> cnt3 = 0 <NEWLINE> for n1 in range ( K ) : <NEWLINE> <INDENT> for n2 in range ( K ) : <NEWLINE> <INDENT> temp = gcd ( n1 + 1 , n2 + 1 ) <NEWLINE> for n3 in range ( K ) : <NEWLINE> <INDENT> cnt3 += gcd ( temp , n3 + 1 ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> ans = cnt1 + cnt2 + cnt3 <NEWLINE> print ( ans ) <NEWLINE>
from math import gcd <NEWLINE> K = int ( input ( ) ) <NEWLINE> plus = 0 <NEWLINE> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for a in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> x = gcd ( i , a ) <NEWLINE> for j in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> plus += gcd ( x , j ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( plus ) <NEWLINE>
from math import gcd <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> K = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for a in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for b in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> p = gcd ( a , b ) <NEWLINE> if p == 1 : <NEWLINE> <INDENT> ans += p * K <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for c in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> ans += gcd ( p , c ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import fractions <NEWLINE> n = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> f = fractions . gcd ( i , j ) <NEWLINE> for k in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> ans += fractions . gcd ( f , k ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from math import gcd <NEWLINE> key = int ( input ( ) ) <NEWLINE> sin = 0 <NEWLINE> for i in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> tmp = gcd ( i , j ) <NEWLINE> for m in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> sin += gcd ( m , tmp ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( sin ) <NEWLINE>
import math <NEWLINE> n = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> for k in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> ans += gcd ( gcd ( i , j ) , k ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
k = int ( input ( ) ) <NEWLINE> total = 0 <NEWLINE> <NL> for a in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for b in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> if gcd ( a , b ) == 1 : <NEWLINE> <INDENT> total += 1 * k <NEWLINE> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for c in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> total += gcd ( a , b , c ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( total ) <NEWLINE>
import math <NEWLINE> <NL> ans = 0 <NEWLINE> ans += 0.5 * k * ( k + 1 ) <NEWLINE> <COMMENT> <NL> <NL> for a in range ( 1 , k ) : <NEWLINE> <INDENT> for b in range ( a + 1 , k + 1 ) : <NEWLINE> <INDENT> n = math . gcd ( a , b ) <NEWLINE> ans += n * 6 <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> for i in range ( 1 , k - 1 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , k ) : <NEWLINE> <INDENT> for k in range ( j + 1 , k + 1 ) : <NEWLINE> <INDENT> d = math . gcd ( i , j ) <NEWLINE> ans += math . gcd ( d , k ) * 6 <NEWLINE> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> print ( int ( ans ) ) <NEWLINE>
import fractions <NEWLINE> x = 0 <NEWLINE> K = int ( input ( ) ) <NEWLINE> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for h in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> if i == j and j == h : <NEWLINE> <INDENT> x = x + i <NEWLINE> <DEDENT> elif i == j or j == h : <NEWLINE> <INDENT> x = x + fractions . gcd ( i , h ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = x + fractions . gcd ( i , fractions . gcd ( j , h ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( x ) <NEWLINE>
from fractions import gcd <NEWLINE> k = int ( input ( ) ) <NEWLINE> <NL> res = 0 <NEWLINE> for a in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for b in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> t = gcd ( a , b ) <NEWLINE> for c in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> res += gcd ( t , c ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( res ) <NEWLINE>
import math <NEWLINE> <NL> num = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for a in num : <NEWLINE> <INDENT> for b in num : <NEWLINE> <INDENT> for c in num : <NEWLINE> <INDENT> ans += math . gcd ( a , b , c ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from itertools import product <NEWLINE> N = ( input ( ) ) <NEWLINE> d = 0 <NEWLINE> res = [ ele for ele in product ( range ( 1 , N + 1 ) , repeat = 3 ) ] <NEWLINE> a = ( res ) <NEWLINE> for i in a : <NEWLINE> <INDENT> if i [ 0 ] == i [ 1 ] == i [ 2 ] : <NEWLINE> <INDENT> d = d + i [ 0 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d = d + 1 <NEWLINE> <DEDENT> <DEDENT> print ( d ) <NEWLINE>
import fractions <NEWLINE> <NL> <NL> from functools import reduce <NEWLINE> K = int ( input ( ) ) <NEWLINE> <NL> def gcd_list ( numbers ) : <NEWLINE> <INDENT> return reduce ( fractions . gcd , numbers ) <NEWLINE> <NL> <NL> <DEDENT> count = 0 <NEWLINE> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for j in range ( i , K + 1 ) : <NEWLINE> <INDENT> for k in range ( j , K + 1 ) : <NEWLINE> <INDENT> if i == j and j == k and k == i : <NEWLINE> <INDENT> n = 1 <NEWLINE> <DEDENT> elif i == j or j == k or k == i : <NEWLINE> <INDENT> n = 3 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> n = 6 <NEWLINE> <DEDENT> count += n * gcd_list ( [ i , j , k ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
from itertools import ( <NEWLINE> <INDENT> accumulate , <COMMENT> <NEWLINE> groupby , <COMMENT> <NEWLINE> permutations , <COMMENT> <NEWLINE> combinations , <COMMENT> <NEWLINE> product , <COMMENT> <NEWLINE> combinations_with_replacement , <COMMENT> <NEWLINE> <DEDENT> ) <NEWLINE> <NL> import fractions <NEWLINE> from functools import reduce <NEWLINE> <NL> def gcd ( * numbers ) : <NEWLINE> <INDENT> return reduce ( fractions . gcd , numbers ) <NEWLINE> <NL> <DEDENT> def gcd_list ( numbers ) : <NEWLINE> <INDENT> return reduce ( fractions . gcd , numbers ) <NEWLINE> <NL> <NL> <DEDENT> N = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i , j , k in combinations_with_replacement ( range ( 1 , N + 1 ) , 3 ) : <NEWLINE> <INDENT> if i == j == k : <NEWLINE> <INDENT> ans += i <NEWLINE> <DEDENT> elif i == j : <NEWLINE> <INDENT> ans += gcd ( i , k ) * 3 <NEWLINE> <DEDENT> elif j == k : <NEWLINE> <INDENT> ans += gcd ( j , i ) * 3 <NEWLINE> <DEDENT> elif i == k : <NEWLINE> <INDENT> ans += gcd ( i , j ) * 3 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += gcd_list ( [ i , j , k ] ) * 6 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from fractions import gcd <NEWLINE> K = int ( input ( ) ) <NEWLINE> <NL> def gcd3 ( a , b , c ) : <NEWLINE> <INDENT> x = gcd ( a , b ) <NEWLINE> y = gcd ( x , c ) <NEWLINE> return y <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> <COMMENT> <NL> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for j in range ( i , K + 1 ) : <NEWLINE> <INDENT> for k in range ( j , K + 1 ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <INDENT> x = gcd3 ( i , j , k ) <NEWLINE> if i == j : <NEWLINE> <INDENT> if j == k : <NEWLINE> <INDENT> ans += x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += 3 * x <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if i == k : <NEWLINE> <INDENT> ans += 3 * x <NEWLINE> <DEDENT> elif j == k : <NEWLINE> <INDENT> ans += 3 * x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += 6 * x <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> read = sys . stdin . buffer . read <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> readlines = sys . stdin . buffer . readlines <NEWLINE> import numpy as np <NEWLINE> <NL> K = int ( float ( read ( ) ) <NEWLINE> <NL> x = np . arange ( 1 , K + 1 ) <NEWLINE> nums = np . gcd . outer ( np . gcd . outer ( x , x ) , x ) <NEWLINE> print ( nums . sum ( ) ) <NEWLINE>
a = int ( input ( ) ) <NEWLINE> from math import gcd <NEWLINE> b = 0 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> for k in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> b += gcd ( gcd ( i , j ) , k ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( b ) <NEWLINE>
import math <NEWLINE> from functools import reduce <NEWLINE> k = int ( input ( ) ) <NEWLINE> l = [ a , b , c ] <NEWLINE> gcd = [ ] <NEWLINE> def gcd_list ( numbers ) : <NEWLINE> <INDENT> return reduce ( math . gcd , numbers ) <NEWLINE> <DEDENT> for l [ 0 ] in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for l [ 1 ] in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for l [ 2 ] in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> gcd . append ( gcd_list ( l ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( sum ( gcd ) ) <NEWLINE>
<INDENT> import sys , os , math <NEWLINE> <NL> def get_cd ( n ) : <NEWLINE> <INDENT> cd = [ ] <NEWLINE> for i in range ( 1 , int ( n / 2 ) + 1 ) : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> cd . append ( i ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> <DEDENT> cd . append ( n ) <NEWLINE> return cd <NEWLINE> <NL> <DEDENT> def get_gcd ( a , b , c , cd_d ) : <NEWLINE> <INDENT> if 1 in [ a , b , c ] : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cd = sorted ( list ( set ( cd_d [ a ] ) & set ( cd_d [ b ] ) & set ( cd_d [ c ] ) ) ) <NEWLINE> return cd [ - 1 ] <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> k = int ( input ( ) ) <NEWLINE> cc_d = { } <NEWLINE> for i in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> cc_d [ i ] = get_cd ( i ) <NEWLINE> <NL> <DEDENT> computed_d = { } <NEWLINE> s = 0 <NEWLINE> for a in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for b in range ( a , k + 1 ) : <NEWLINE> <INDENT> for c in range ( b , k + 1 ) : <NEWLINE> <INDENT> if a == b == c : <NEWLINE> <INDENT> s += a <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> gcd = get_gcd ( a , b , c , cc_d ) <NEWLINE> if a != b != c : <NEWLINE> <INDENT> s += gcd * 6 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s += gcd * 3 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( s ) <NEWLINE> <DEDENT> <DEDENT>
import math <NEWLINE> n = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> jj = math . gcd ( i , j ) <NEWLINE> <INDENT> for k in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> ans += math . gcd ( jj , k ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> <NL> k = int ( imput ( ) ) <NEWLINE> n = 0 <NEWLINE> <NL> for i in range ( 1 , k + 1 ) <NEWLINE> <INDENT> for j in range ( 1 , k + 1 ) <NEWLINE> <INDENT> a = math . gcd ( i , j ) <NEWLINE> for l in range ( 1 , k + 1 ) <NEWLINE> <INDENT> b = math . gcd ( a , l ) <NEWLINE> n += b <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( n ) <NEWLINE>
k = int ( input ( ) ) <NEWLINE> <NL> def gcd2 ( a , b ) : <NEWLINE> <INDENT> return gcd2 ( b , a % b ) <NEWLINE> <NL> <DEDENT> def gcd3 ( a , b , c ) : <NEWLINE> <INDENT> return gcd2 ( gcd2 ( a , b ) , c ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for j in range ( i , k + 1 ) : <NEWLINE> <INDENT> for m in range ( j , k + 1 ) : <NEWLINE> <INDENT> if i == j == m : <NEWLINE> <INDENT> ans += gcd3 ( i , j , m ) <NEWLINE> <DEDENT> elif i == j or j == m : <NEWLINE> <INDENT> ans += gcd3 ( i , j , m ) * 3 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += gcd3 ( i , j , m ) * 6 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> <NL> def better_gcd ( a , b , c ) : <NEWLINE> <INDENT> tup = set ( ( a , b , c ) ) <NEWLINE> kinds = len ( tup ) <NEWLINE> if kinds == 3 : <NEWLINE> <INDENT> return math . gcd ( a , math . gcd ( b , c ) ) * 6 <NEWLINE> <DEDENT> elif kinds == 2 : <NEWLINE> <INDENT> return math . gcd ( * tup ) * 3 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return a <NEWLINE> <NL> <DEDENT> <DEDENT> ans = 0 <NEWLINE> cands = list ( itertools . combinations_with_replacement ( range ( 200 ) , 3 ) ) <NEWLINE> for c in cands : <NEWLINE> <INDENT> ans += better_gcd ( * c ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import fractions <NEWLINE> K = int ( input ( ) ) <NEWLINE> total = 0 <NEWLINE> <NL> for a in range ( K ) : <NEWLINE> <INDENT> for b in range ( a , K ) : <NEWLINE> <INDENT> for c in range ( b , K ) : <NEWLINE> <INDENT> total += fractsion . gcd ( a + 1 , fractions . gcd ( b + 1 , c + 1 ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> total *= 6 <NEWLINE> <NL> for a in range ( K ) : <NEWLINE> <INDENT> for b in range ( a , K ) : <NEWLINE> <INDENT> total += fractions . gcd ( a + 1 , b + 1 ) <NEWLINE> <DEDENT> <DEDENT> total *= 6 <NEWLINE> <NL> for a in range ( K ) : <NEWLINE> <INDENT> total += ( a + 1 ) <NEWLINE> <NL> <DEDENT> print ( total ) <NEWLINE>
import sys <NEWLINE> from fractions import gcd <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> K = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for k in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> ans += gcd ( gcd ( i , j ) , k ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> <NL> K = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for k in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> ans += gcd ( gcd ( i , j ) , k ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from fractions import gcd <NEWLINE> k = int ( input ( ) ) <NEWLINE> result = 0 <NEWLINE> <NL> <COMMENT> <NL> for i in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for j in range ( i , k + 1 ) : <NEWLINE> <INDENT> for m in range ( j , k + 1 ) : <NEWLINE> <INDENT> if i == j == m : <NEWLINE> <INDENT> result += i <NEWLINE> <DEDENT> elif i == j or j == m : <NEWLINE> <INDENT> result += gcd ( i , m ) * 3 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> result += gcd ( i , gcd ( j , m ) ) * 6 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( result ) <NEWLINE>
from fractions import gcd <NEWLINE> <NL> K = int ( input ( ) ) <NEWLINE> <NL> res = 0 <NEWLINE> tmp = 0 <NEWLINE> d = [ ] <NEWLINE> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for k in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> if i == j and j == k : <NEWLINE> <INDENT> res += i <NEWLINE> <DEDENT> elif i == j : <NEWLINE> <INDENT> res += gcd ( i , k ) <NEWLINE> <DEDENT> elif i == k : <NEWLINE> <INDENT> res += gcd ( j , k ) <NEWLINE> <DEDENT> elif j == k : <NEWLINE> <INDENT> res += gcd ( i , j ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> res += gcd ( gcd ( i , j ) , k ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( res ) <NEWLINE>
import math <NEWLINE> from functools import reduce <NEWLINE> <NL> def gcd ( * numbers ) : <NEWLINE> <INDENT> return reduce ( math . gcd , numbers ) <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> K = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> <COMMENT> <NL> for i in range ( 1 , K + 1 , 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , K + 1 , 1 ) : <NEWLINE> <INDENT> for k in range ( 1 , K + 1 , 1 ) : <NEWLINE> <INDENT> ans += gcd ( i , j , k ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> return ans <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
k = int ( input ( ) ) <NEWLINE> <NL> def gcd2 ( a , b ) : <NEWLINE> <INDENT> if b == 0 : <NEWLINE> <INDENT> return a <NEWLINE> <DEDENT> return gcd2 ( b , a % b ) <NEWLINE> <NL> <DEDENT> def gcd3 ( a , b , c ) : <NEWLINE> <INDENT> return gcd2 ( gcd2 ( a , b ) , c ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for a in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for b in range ( i , k + 1 ) : <NEWLINE> <INDENT> for c in range ( j , k + 1 ) : <NEWLINE> <INDENT> if a == b == c : <NEWLINE> <INDENT> ans += gcd3 ( a , b , c ) <NEWLINE> <DEDENT> elif a == b or b == c : <NEWLINE> <INDENT> ans += gcd3 ( a , b , c ) * 3 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += gcd3 ( a , b , c ) * 6 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from math import gcd <NEWLINE> ans = 0 <NEWLINE> K = int ( input ( ) ) <NEWLINE> <NL> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for k in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> ans = ans + gcd ( gcd ( i , j ) , k ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from fractions import gcd <NEWLINE> from math import ceil , floor , sqrt , cos , sin , pi , factorial <NEWLINE> from functools import reduce <NEWLINE> import sys <NEWLINE> read = sys . stdin . buffer . read <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> readlines = sys . stdin . buffer . readlines <NEWLINE> sys . setrecursionlimit ( 10 ** 8 ) <NEWLINE> INF = float ( <STRING> ) <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> def lcm_base ( a , b ) : <NEWLINE> <INDENT> return ( a * b ) // gcd ( a , b ) <NEWLINE> <NL> <DEDENT> def lcm_list ( numbers ) : <NEWLINE> <INDENT> return reduce ( lcm_base , numbers , 1 ) <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> k = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for a in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for b in range ( a , k + 1 ) : <NEWLINE> <INDENT> for c in range ( b , k + 1 ) : <NEWLINE> <INDENT> if a == b and b == c : <NEWLINE> <INDENT> ans += a <NEWLINE> <DEDENT> elif a == b or b == c : <NEWLINE> <INDENT> ans += gcd ( gcd ( a , b ) , c ) * 3 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += gcd ( gcd ( a , b ) , c ) * 6 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
from functools import reduce <NEWLINE> from itertools import product <NEWLINE> <NL> def gcd ( a , b ) : <NEWLINE> <INDENT> while b : a , b = b , a % b <NEWLINE> return a <NEWLINE> <NL> <DEDENT> def gcd_list ( A ) : return reduce ( gcd , A ) <NEWLINE> <NL> K = int ( input ( ) ) <NEWLINE> S = K * ( K + 1 ) // 2 <NEWLINE> for a , b in combinations ( range ( 1 , K + 1 ) , 2 ) : <NEWLINE> <INDENT> S += 6 * gcd ( a , b ) <NEWLINE> <DEDENT> for a , b , c in combinations ( range ( 1 , K + 1 ) , 3 ) : <NEWLINE> <INDENT> S += 6 * gcd_list ( ( a , b , c ) ) <NEWLINE> <DEDENT> print ( S ) <NEWLINE>
from math import gcd <NEWLINE> K = int ( input ( ) ) <NEWLINE> <NL> c = 0 <NEWLINE> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> k = gcd ( i , j ) <NEWLINE> <INDENT> for l in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> a = gcd ( k , l ) <NEWLINE> c += a <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( c ) <NEWLINE>
from fractions import gcd <NEWLINE> <NL> k = int ( input ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for l in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> ans += gcd ( gcd ( i , j ) , l ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
K = int ( input ( ) ) <NEWLINE> <NL> import fractions <NEWLINE> <NL> A = [ ] <NEWLINE> sum = 0 <NEWLINE> <NL> for i in range ( K ) : <NEWLINE> <INDENT> for j in range ( K ) : <NEWLINE> <INDENT> A . append ( fractions . gcd ( i + 1 , j + 1 ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> for g in A : <NEWLINE> <INDENT> for i in range ( K ) : <NEWLINE> <INDENT> sum += fractions . gcd ( g , i + 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( sum ) <NEWLINE>
import math <NEWLINE> <NL> K = int ( input ( ) ) <NEWLINE> S = 0 <NEWLINE> <NL> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for k in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> S += gcd ( gcd ( i , j ) , k ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( S ) <NEWLINE>
def mapint_inp ( ) : <NEWLINE> <INDENT> return map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <DEDENT> def intinp ( ) : <NEWLINE> <INDENT> return int ( input ( ) ) <NEWLINE> <NL> <DEDENT> import math <NEWLINE> from functools import reduce <NEWLINE> import itertools <NEWLINE> <NL> K = intinp ( ) <NEWLINE> <NL> def gcd ( * num ) : <NEWLINE> <INDENT> return reduce ( math . gcd , num ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> if i == 1 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> continue <NEWLINE> <DEDENT> for j in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> if i == 1 : <NEWLINE> ans += 1 <NEWLINE> continue <NEWLINE> for k in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> if i == 1 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> continue <NEWLINE> <DEDENT> ans += gcd ( i , j , k ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import fractions <NEWLINE> <NL> K = int ( input ( ) ) <NEWLINE> g = 0 <NEWLINE> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , i + 1 ) : <NEWLINE> <INDENT> for k in range ( 1 , j + 1 ) : <NEWLINE> <INDENT> a = fractions . gcd ( i , j ) <NEWLINE> b = fractions . gcd ( a , k ) <NEWLINE> if i != j != k : <NEWLINE> <INDENT> g += b * 6 <NEWLINE> <DEDENT> elif i == j == k : <NEWLINE> <INDENT> g += b <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> g += b * 3 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( g ) <NEWLINE>
import math <NEWLINE> k = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> <NL> for a in range ( k ) : <NEWLINE> <INDENT> for b in range ( k ) : <NEWLINE> <INDENT> d = math . gcd ( a + 1 , b + 1 ) <NEWLINE> for c in range ( k ) : <NEWLINE> <INDENT> ans += math ( d , c + 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import fractions <NEWLINE> k = int ( input ( ) ) <NEWLINE> <NL> l = [ [ - 1 for _ in range ( k + 1 ) ] for _ in range ( k + 1 ) ] <NEWLINE> <NL> sum = 0 <NEWLINE> for x1 in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for x2 in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for x3 in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for i in range ( 1 , 2 ) : <NEWLINE> <INDENT> if l [ x1 ] [ x2 ] == - 1 : <NEWLINE> <INDENT> ans = fractions . gcd ( x1 , x2 ) <NEWLINE> l [ x1 ] [ x2 ] = ans <NEWLINE> l [ x2 ] [ x1 ] = ans <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = l [ x1 ] [ x2 ] <NEWLINE> <DEDENT> if l [ ans ] [ x3 ] == - 1 : <NEWLINE> <INDENT> ans1 = fractions . gcd ( ans , x3 ) <NEWLINE> l [ ans ] [ x3 ] = ans1 <NEWLINE> l [ x3 ] [ ans ] = ans1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans1 = l [ ans ] [ x3 ] <NEWLINE> <NL> <DEDENT> sum += ans1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( sum ) <NEWLINE>
k = int ( input ( ) ) <NEWLINE> from fractions import gcd <NEWLINE> from functools import reduce <NEWLINE> <NL> x = 0 <NEWLINE> for a in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for b in range ( a , k + 1 ) : <NEWLINE> <INDENT> for c in range ( b , k + 1 ) : <NEWLINE> <INDENT> if len ( { a , b , c } ) == 1 : <NEWLINE> <INDENT> x += reduce ( gcd , [ a , b , c ] ) <NEWLINE> <DEDENT> elif len ( { a , b , c } ) == 2 : <NEWLINE> <INDENT> x += 3 * reduce ( gcd , [ a , b , c ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x += 6 * reduce ( gcd , [ a , b , c ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( x ) <NEWLINE>
import fractions <NEWLINE> K = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for n in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> tmp = fractions . gcd ( i , j ) <NEWLINE> ans += fractions . gcd ( tmp , n ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from math import gcd <NEWLINE> N = int ( input ( ) ) <NEWLINE> sum = 0 <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , N + 1 ) : <NEWLINE> tmp = gcd ( j , k ) <NEWLINE> <INDENT> for k in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> sum += gcd ( i , tmp ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( sum ) <NEWLINE>
k = int ( input ( ) ) <NEWLINE> import fractions <NEWLINE> import itertools <NEWLINE> sum_g = 0 <NEWLINE> l = list ( itertools . product ( [ i for i in range ( 1 , k + 1 ) ] , repeat = 3 ) ) <NEWLINE> for p , q , r in l : <NEWLINE> <INDENT> ans = p <NEWLINE> ans = fractions . gcd ( ans , q ) <NEWLINE> ans = fractions . gcd ( ans , r ) <NEWLINE> sum_g += ans <NEWLINE> ans = 0 <NEWLINE> <DEDENT> print ( sum_g ) <NEWLINE>
a = int ( input ( ) ) <NEWLINE> s = 0 <NEWLINE> for i in range ( a ) : <NEWLINE> <INDENT> for j in range ( a ) : <NEWLINE> <INDENT> for k in range ( a ) : <NEWLINE> <INDENT> for n in range ( min ( i , j , k ) + 1 ) : <NEWLINE> <INDENT> if a % ( n + 1 ) == 0 and b % ( n + 1 ) == 0 and c % ( n + 1 ) == 0 : <NEWLINE> <INDENT> gcd = n + 1 <NEWLINE> <DEDENT> <DEDENT> s = s + gcd <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( s ) <NEWLINE>
import fractions <NEWLINE> import itertools <NEWLINE> k = int ( input ( ) ) <NEWLINE> <NL> ans = k * ( k + 1 ) // 2 <NEWLINE> l = [ int ( i ) for i in range ( 1 , k + 1 ) ] <NEWLINE> for i in itertools . combinations ( l , 3 ) : <NEWLINE> <INDENT> ans += fractions . gcd ( fractions . gcd ( i [ 0 ] , i [ 1 ] ) , i [ 2 ] ) * 6 <NEWLINE> <NL> <DEDENT> for i in itertools . combinations ( l , 2 ) : <NEWLINE> <INDENT> ans += fractions . gcd ( i [ 0 ] , i [ 1 ] ) * 6 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
def gcd ( a , b ) : <NEWLINE> <INDENT> while b : <NEWLINE> <INDENT> a , b = b , a % b <NEWLINE> <DEDENT> return a <NEWLINE> <NL> <NL> <DEDENT> K = int ( input ( ) ) <NEWLINE> <NL> sum_gcd = 0 <NEWLINE> cand = itertools . combinations ( K , 3 ) ) <NEWLINE> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> g = gcd ( i , j ) <NEWLINE> for k in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> sum_gcd += gcd ( g , k ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( sum_gcd ) <NEWLINE>
import math <NEWLINE> <NL> K = int ( input ( ) ) <NEWLINE> <NL> Sum = [ ] <NEWLINE> for a in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for b in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> gcd2 = math . gcd ( i . j ) <NEWLINE> for c in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> gcd = math . gcd ( gcd2 , c ) <NEWLINE> Sum . append ( gcd ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( sum ( Sum ) ) <NEWLINE>
from fractions import gcd <NEWLINE> <NL> k = int ( input ( ) ) <NEWLINE> count = 0 <NEWLINE> <NL> for i in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for j in range ( i , k + 1 ) : <NEWLINE> <INDENT> for l in range ( j , k + 1 ) : <NEWLINE> <INDENT> if i == j and j == l : <NEWLINE> <INDENT> count += i <NEWLINE> <DEDENT> elif i == j : <NEWLINE> <INDENT> x = gcd ( i , l ) <NEWLINE> count += x * 3 <NEWLINE> <DEDENT> elif j == l : <NEWLINE> <INDENT> x = gcd ( i , l ) <NEWLINE> count += x * 3 <NEWLINE> <DEDENT> elif l == i : <NEWLINE> <INDENT> x = gcd ( i , j ) <NEWLINE> count += x * 3 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = gcd ( i , j ) <NEWLINE> x = gcd ( x , l ) <NEWLINE> count += x * 6 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
import itertools <NEWLINE> import fractions <NEWLINE> from functools import reduce <NEWLINE> <NL> <NL> def gcd ( * numbers ) : <NEWLINE> <INDENT> return reduce ( fractions . gcd , numbers ) <NEWLINE> <NL> <NL> <DEDENT> k = int ( input ( ) ) <NEWLINE> n = [ ] <NEWLINE> for i in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> n . append ( i ) <NEWLINE> <DEDENT> res = 0 <NEWLINE> for v in itertools . product ( n , repeat = 3 ) : <NEWLINE> <INDENT> res += gcd ( v [ 0 ] , v [ 1 ] , v [ 2 ] ) <NEWLINE> <DEDENT> print ( res ) <NEWLINE>
import itertools <NEWLINE> from collections import Counter <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> <NL> C = Counter ( S ) <NEWLINE> r = C [ <STRING> ] <NEWLINE> g = C [ <STRING> ] <NEWLINE> b = C [ <STRING> ] <NEWLINE> <NL> <NL> cnt = r * g * b <NEWLINE> <NL> for i in range ( 0 , N - 2 ) : <NEWLINE> <INDENT> for j in range ( i , N - 1 ) : <NEWLINE> <INDENT> k = j + j - i <NEWLINE> if k < N : <NEWLINE> <INDENT> if S [ i ] != S [ j ] and S [ i ] != S [ k ] and S [ j ] != S [ k ] ) : <NEWLINE> <INDENT> cnt -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> ans = 0 <NEWLINE> r = g = b = 0 <NEWLINE> R = [ 0 for _ in range ( n ) ] <NEWLINE> G = [ 0 for _ in range ( n ) ] <NEWLINE> B = [ 0 for _ in range ( n ) ] <NEWLINE> for i in range ( i ) : <NEWLINE> <INDENT> if s [ i ] = <STRING> : r += 1 <NEWLINE> elif s [ i ] = <STRING> : g += 1 <NEWLINE> else : b += 1 <NEWLINE> R [ i ] = r <NEWLINE> G [ i ] = g <NEWLINE> B [ i ] = b <NEWLINE> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> if s [ i ] = <STRING> : ans += G [ i ] * ( B [ - 1 ] - B [ i ] ) + B [ i ] * ( G [ - 1 ] - G [ i ] ) <NEWLINE> elif s [ i ] = <STRING> : ans += R [ i ] * ( B [ - 1 ] - B [ i ] ) + B [ i ] * ( R [ - 1 ] - R [ i ] ) <NEWLINE> else : ans += R [ i ] * ( G [ - 1 ] - G [ i ] ) + G [ i ] * ( R [ - 1 ] - R [ i ] ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
from numba import njit <NEWLINE> from sys import stdin <NEWLINE> def S ( ) : return stdin . readline ( ) . rstrip ( ) <NEWLINE> def I ( ) : return int ( stdin . readline ( ) . rstrip ( ) ) <NEWLINE> <NL> @ njit <NEWLINE> def main ( ) : <NEWLINE> <INDENT> n = I ( ) <NEWLINE> s = list ( S ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( n - 2 ) : <NEWLINE> <INDENT> color = { s [ i ] } <NEWLINE> for j in range ( i + 1 , n - 1 ) : <NEWLINE> <INDENT> if not s [ j ] in color : <NEWLINE> <INDENT> color . add ( s [ j ] ) <NEWLINE> for k in range ( j + 1 , n ) : <NEWLINE> <INDENT> if not s [ k ] in color : <NEWLINE> <INDENT> if k - j != j - i : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> color = { s [ i ] } <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> s = list ( input ( ) ) <NEWLINE> ans = s . count ( <STRING> ) * s . count ( <STRING> ) * s . count ( <STRING> ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> s [ i ] = 1 <NEWLINE> elif s [ i ] == <STRING> : <NEWLINE> <INDENT> s [ i ] = 2 <NEWLINE> <DEDENT> elif s [ i ] == <STRING> : <NEWLINE> <INDENT> s [ i ] = 4 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n ) : <NEWLINE> <INDENT> k = 2 * j - i <NEWLINE> if k >= n : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if s [ i ] + s [ j ] + s [ k ] == 7 : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = str ( input ( ) ) <NEWLINE> t = len ( s ) <NEWLINE> <COMMENT> <NL> r = set ( ) <NEWLINE> g = set ( ) <NEWLINE> b = set ( ) <NEWLINE> a = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> r . add ( i ) <NEWLINE> <DEDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> g . add ( i ) <NEWLINE> <DEDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> b . add ( i ) <NEWLINE> <DEDENT> <DEDENT> d = len ( r ) * len ( g ) * len ( b ) <NEWLINE> for ri in r : <NEWLINE> <INDENT> for gi in g : <NEWLINE> <INDENT> if 2 ri - gi in b : <NEWLINE> <INDENT> d -= 1 <NEWLINE> <DEDENT> if 2 gi - ri in b : <NEWLINE> <INDENT> d -= 1 <NEWLINE> <DEDENT> if ( gi + ri ) / 2 in b : <NEWLINE> <INDENT> d -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( d ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S = list ( input ( ) ) <NEWLINE> ans = S . count ( <STRING> ) * S . count ( <STRING> ) * S . count ( <STRING> ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if S [ i ] == <STRING> : <NEWLINE> <INDENT> S [ i ] = 1 <NEWLINE> <DEDENT> elif S [ i ] == <STRING> : <NEWLINE> <INDENT> S [ i ] <NEWLINE> <DEDENT> elif S [ i ] == <STRING> : <NEWLINE> <INDENT> S [ i ] = 4 <NEWLINE> <DEDENT> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> for j in range ( i + 1 , N ) : <NEWLINE> <INDENT> k = 2 * j - i <NEWLINE> if k >= N : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if S [ i ] + S [ j ] + S [ k ] == 7 : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> compte = 0 <NEWLINE> r = [ ] <NEWLINE> g = [ ] <NEWLINE> b = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> r . append ( i ) <NEWLINE> <DEDENT> elif s [ i ] == <STRING> : <NEWLINE> <INDENT> g . append ( i ) <NEWLINE> <DEDENT> elif s [ i ] == <STRING> : <NEWLINE> <INDENT> b . append ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( 1 , n - 1 ) : <NEWLINE> <INDENT> if n % 2 == 0 : <NEWLINE> <INDENT> if i < n // 2 : <NEWLINE> <INDENT> for j in range ( 1 , i + 1 ) : <NEWLINE> <INDENT> if s [ i ] != s [ i - j ] and s [ i ] != s [ i + j ] and s [ i + j ] != s [ i - j ] : <NEWLINE> <INDENT> compte += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for j in range ( 1 , n - i ) : <NEWLINE> <INDENT> if s [ i ] != s [ i - j ] and s [ i ] != s [ i + j ] and s [ i + j ] != s [ i - j ] : <NEWLINE> <INDENT> compte += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if i < ( n - 1 ) // 2 : <NEWLINE> <INDENT> for j in range ( 1 , i + 1 ) : <NEWLINE> <INDENT> if s [ i ] != s [ i - j ] and s [ i ] != s [ i + j ] and s [ i + j ] != s [ i - j ] : <NEWLINE> <INDENT> compte += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> elif i == ( n - 1 ) // 2 : <NEWLINE> <INDENT> for j in range ( 1 , n - i ) : <NEWLINE> <INDENT> if s [ i ] != s [ i - j ] and s [ i ] != s [ i + j ] and s [ i + j ] != s [ i - j ] : <NEWLINE> <INDENT> compte += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> elif i > ( n - 1 ) // 2 : <NEWLINE> <INDENT> for j in range ( 1 , n - i ) : <NEWLINE> <INDENT> if s [ i ] != s [ i - j ] and s [ i ] != s [ i + j ] and s [ i + j ] != s [ i - j ] : <NEWLINE> <INDENT> compte += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( len ( r ) * len ( g ) * len ( b ) - count ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> cnt = 0 <NEWLINE> a = [ <STRING> , <STRING> , <STRING> ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> x = a . remove ( s [ i ] ) <NEWLINE> for j in range ( i + 1 , n ) : <NEWLINE> <INDENT> if s [ i ] != s [ j ] : <NEWLINE> <INDENT> qw = s <NEWLINE> x . remove ( s [ j ] ) <NEWLINE> k = j - 1 <NEWLINE> if j + k < n : <NEWLINE> <INDENT> qw [ j + k ] = <STRING> <NEWLINE> <DEDENT> q = x . pop ( 0 ) <NEWLINE> cnt += qw . count ( q ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> <STRING> <NEWLINE> color_num = defaultdict ( int ) <NEWLINE> num_subst = 0 <NEWLINE> <NL> for i in range ( len ( S ) - 1 ) : <NEWLINE> <INDENT> color_num [ S [ i ] ] += 1 <NEWLINE> for j in range ( i + 1 , len ( S ) ) : <NEWLINE> <INDENT> if S [ i ] != S [ j ] : <NEWLINE> <INDENT> diff = j - i <NEWLINE> idx = j + diff <NEWLINE> if idx < len ( S ) and S [ idx ] != S [ i ] and S [ idx ] != S [ j ] : <NEWLINE> <INDENT> num_subst += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> color_num [ S [ len ( S ) - 1 ] ] += 1 <NEWLINE> total_num_comb = color_num [ <STRING> ] * color_num [ <STRING> ] * color_num [ <STRING> ] <NEWLINE> print ( total_num_comb - num_subst ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import itertools <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> out = S . count ( <STRING> ) * S . count ( <STRING> ) * S . count ( <STRING> ) <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> for j in range ( N - i * 2 ) : <NEWLINE> <INDENT> if ( S [ j ] , S [ j + i ] , S [ j + i * 2 ] ) in RGBs : <NEWLINE> <INDENT> out -= 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( out ) <NEWLINE>
a = int ( input ( ) ) <NEWLINE> moji = input ( ) <NEWLINE> r = [ ] <NEWLINE> g = [ ] <NEWLINE> b = [ ] <NEWLINE> for i in range ( a ) : <NEWLINE> <INDENT> if moji [ i ] == <STRING> : <NEWLINE> <INDENT> r . append ( i ) <NEWLINE> <DEDENT> elif moji [ i ] == <STRING> : <NEWLINE> <INDENT> g . append ( i ) <NEWLINE> <DEDENT> elif moji [ i ] == <STRING> : <NEWLINE> <INDENT> b . append ( i ) <NEWLINE> <DEDENT> <DEDENT> res = len ( r ) * len ( g ) * len ( b ) <NEWLINE> if len ( r ) == 0 or len ( g ) == 0 or len ( b ) == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> min_len = { r : 0 , g : 1 , b : 2 } <NEWLINE> if len ( r ) > len ( g ) : <NEWLINE> <INDENT> tmp = min_len [ r ] <NEWLINE> min_len [ r ] = min_len [ g ] <NEWLINE> min_len [ g ] = tmp <NEWLINE> <DEDENT> if len ( g ) > len ( b ) : <NEWLINE> <INDENT> tmp = min_len [ g ] <NEWLINE> min_len [ g ] = min_len [ b ] <NEWLINE> min_len [ b ] = tmp <NEWLINE> <DEDENT> if len ( b ) > len ( r ) : <NEWLINE> <INDENT> tmp = min_len [ b ] <NEWLINE> min_len [ b ] = min_len [ r ] <NEWLINE> min_len [ r ] = tmp <NEWLINE> <NL> <DEDENT> for key , value in min_len . items ( ) : <NEWLINE> <INDENT> if value == 0 : <NEWLINE> <INDENT> a1 = key <NEWLINE> <DEDENT> elif value == 1 : <NEWLINE> <INDENT> a2 = key <NEWLINE> <DEDENT> elif value == 2 : <NEWLINE> <INDENT> a3 = key <NEWLINE> <NL> <DEDENT> <DEDENT> for i in a1 : <NEWLINE> <INDENT> for j in a2 : <NEWLINE> <INDENT> if - abs ( i - j ) + min ( i , j ) in a3 : <NEWLINE> <INDENT> res -= 1 <NEWLINE> <DEDENT> if abs ( i - j ) + max ( i , j ) in a3 : <NEWLINE> <INDENT> res -= 1 <NEWLINE> <DEDENT> if abs ( i - j ) % 2 == 0 and int ( abs ( i - j ) / 2 ) + min ( i , j ) in a3 : <NEWLINE> <INDENT> res -= 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( res ) <NEWLINE> <DEDENT>
from numba import njit <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> R = 0 <NEWLINE> G = 0 <NEWLINE> B = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> s = S [ i ] <NEWLINE> if s == <STRING> : <NEWLINE> <INDENT> R += 1 <NEWLINE> <DEDENT> elif s == <STRING> : <NEWLINE> <INDENT> G += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> B += 1 <NEWLINE> <DEDENT> <DEDENT> ans = R * G * B <NEWLINE> <NL> @ njit <NEWLINE> def calc ( ans ) : <NEWLINE> <INDENT> for i in range ( N - 2 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , N - 1 ) : <NEWLINE> <INDENT> if 0 <= j + j - i < N : <NEWLINE> <INDENT> si = S [ i ] <NEWLINE> sj = S [ j ] <NEWLINE> sk = S [ 2 * j - i ] <NEWLINE> if si != sj and sj != sk and sk != si : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> return ans <NEWLINE> <DEDENT> print ( calc ( ans ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> <NL> r_cnt = S . count ( <STRING> ) <NEWLINE> g_cnt = S . count ( <STRING> ) <NEWLINE> b_cnt = S . count ( <STRING> ) <NEWLINE> <NL> ans = r_cnt * g_cnt * b_cnt <NEWLINE> <NL> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> for d in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> j = i + d <NEWLINE> k = j + d <NEWLINE> if k > N : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if S [ i ] != S [ j ] and S [ j ] != S [ k ] and S [ k ] != S [ i ] : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from collections import Counter <NEWLINE> n = int ( input ( ) ) <NEWLINE> s_ = input ( ) <NEWLINE> s = Couter ( s_ ) <NEWLINE> rgb = s [ <STRING> ] * s [ <STRING> ] * s [ <STRING> ] <NEWLINE> cnt = 0 <NEWLINE> for i in range ( len ( s_ ) ) : <NEWLINE> <INDENT> for j in range ( i + 1 , len ( s_ ) ) : <NEWLINE> <INDENT> h = j - i + j <NEWLINE> if h < n : <NEWLINE> <INDENT> if s_ [ i ] != s_ [ j ] and s_ [ h ] != s_ [ j ] and s_ [ i ] != s_ [ h ] : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( rgb - cnt ) <NEWLINE>
 <NEWLINE> <NL> Copy <NEWLINE> Copy <NEWLINE> N = int ( input ( ) ) <NEWLINE> <NL> S = list ( input ( ) ) <NEWLINE> m = 0 <NEWLINE> <NL> a = S . count ( <STRING> ) <NEWLINE> b = S . count ( <STRING> ) <NEWLINE> c = S . count ( <STRING> ) <NEWLINE> <NL> num = a * b * c <NEWLINE> <NL> for i in range ( N - 2 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , N - 1 ) : <NEWLINE> <INDENT> k = 2 * j - i <COMMENT> <NEWLINE> if k > N - 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> elif S [ i ] != S [ j ] and S [ j ] != S [ k ] and S [ k ] != S [ i ] : <NEWLINE> <INDENT> m += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( num - m ) <NEWLINE>
import collections <NEWLINE> N = int ( input ( ) ) <NEWLINE> S = list ( input ( ) ) <NEWLINE> s = collections . Counter ( S ) <NEWLINE> m = s [ <STRING> ] * s [ <STRING> ] * s [ <STRING> ] <NEWLINE> s = 0 <NEWLINE> for i in range ( 1 , N - 1 ) : <NEWLINE> <INDENT> for j in range ( i , N ) : <NEWLINE> <INDENT> k = 2 * j - i <NEWLINE> if S [ i ] != S [ j ] and S [ i ] != S [ k ] and S [ j ] != S [ k ] : <NEWLINE> <INDENT> s += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( m - s ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S = list ( input ( ) ) <NEWLINE> <NL> a = S [ 0 ] <NEWLINE> res = 0 <NEWLINE> <NL> for i in range ( 1 , N - 2 ) : <NEWLINE> <INDENT> if a == S [ i ] : <NEWLINE> <INDENT> b = S [ i ] <NEWLINE> for j in range ( j , N - 1 ) : <NEWLINE> <INDENT> if i == j : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> c = S [ j ] <NEWLINE> if a != b and b != c and a != c : <NEWLINE> <INDENT> res += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( res ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> <NL> r = s . count ( <STRING> ) <NEWLINE> g = s . count ( <STRING> ) <NEWLINE> b = s . count ( <STRING> ) <NEWLINE> <NL> ans = r * g * b <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> for d in range ( 1 , n ) : <NEWLINE> <INDENT> j = i + d <NEWLINE> k = j + d <NEWLINE> if k > n : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if s [ i ] != s [ j ] and s [ i ] != s [ k ] and s [ j ] != s [ k ] : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> ans = s . count ( <STRING> ) * s . coufnt ( <STRING> ) * s . count ( <STRING> ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( i , n - 1 ) : <NEWLINE> <INDENT> k = 2 * j - i <NEWLINE> if k >= n : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if s [ i ] != s [ j ] and s [ i ] != s [ k ] and s [ j ] != s [ k ] : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<INDENT> from collections import Counter <NEWLINE> <DEDENT> N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> ans = S . count ( <STRING> ) * S . count ( <STRING> ) * S . count ( <STRING> ) <NEWLINE> <NL> <NL> for i in range ( N ) : <NEWLINE> <INDENT> for j in range ( 1 , N ) : <NEWLINE> <INDENT> a = i + j <NEWLINE> b = i + j + j <NEWLINE> if ( b >= N ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> l = S [ i ] <NEWLINE> m = S [ a ] <NEWLINE> r = S [ b ] <NEWLINE> if l != m and m != r and r != l : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
def quest_d ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> <NL> index_dict = { <NEWLINE> <INDENT> <STRING> : 0 , <NEWLINE> <STRING> : 0 , <NEWLINE> <STRING> : 0 <NEWLINE> <DEDENT> } <NEWLINE> for index in range ( len ( S ) ) : <NEWLINE> <INDENT> index_dict [ S [ index ] ] = index_dict [ S [ index ] ] + 1 <NEWLINE> <NL> <DEDENT> if index_dict [ <STRING> ] * index_dict [ <STRING> ] * index_dict [ <STRING> ] == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> rrr = combi_three ( index_dict [ <STRING> ] ) <NEWLINE> ggg = combi_three ( index_dict [ <STRING> ] ) <NEWLINE> bbb = combi_three ( index_dict [ <STRING> ] ) <NEWLINE> rrg = combi_three ( index_dict [ <STRING> ] + index_dict [ <STRING> ] ) <NEWLINE> ggb = combi_three ( index_dict [ <STRING> ] + index_dict [ <STRING> ] ) <NEWLINE> bbr = combi_three ( index_dict [ <STRING> ] + index_dict [ <STRING> ] ) <NEWLINE> <NL> i = 0 <NEWLINE> sum = 0 <NEWLINE> while i < len ( S ) : <NEWLINE> <INDENT> a = S [ i ] <NEWLINE> j = i <NEWLINE> while j < len ( S ) - 1 : <NEWLINE> <INDENT> j += 1 <NEWLINE> if S [ j ] == a : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <DEDENT> k = 2 * j - i <NEWLINE> if k < len ( S ) : <NEWLINE> <INDENT> b = S [ j ] <NEWLINE> if S [ k ] != a and S [ k ] != b : <NEWLINE> <INDENT> sum += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> i += 1 <NEWLINE> <DEDENT> print ( combi_three ( N ) - sum - rrg - bbr - ggb + rrr + ggg + bbb ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> quest_d ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> <NL> ans = S . count ( <STRING> ) * S . count ( <STRING> ) * S . count ( <STRING> ) <NEWLINE> <NL> tmp = 0 <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> for j in range ( i , N ) : <NEWLINE> <INDENT> if j - i + j < N : <NEWLINE> <INDENT> if S [ i ] == S [ j ] and S [ j ] == S [ j - i + j ] and S [ i ] == S [ j - i + j ] <NEWLINE> <INDENT> tmp += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> ans = ans - tmp <NEWLINE> print ( ans ) <NEWLINE>
from collections import Counter <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> <NL> r = S . count ( <STRING> ) <NEWLINE> g = S . count ( <STRING> ) <NEWLINE> b = S . count ( <STRING> ) <NEWLINE> <NL> sum = r * g * b <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> for j in range ( i + 1 , N ) : <NEWLINE> <INDENT> k = 2 * j - i <NEWLINE> if not S [ i ] == S [ j ] and not S [ j ] == S [ k ] and not S [ k ] == S [ i ] : <NEWLINE> <INDENT> sum -= 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( sum ) <NEWLINE>
import sys <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> N = int ( input ( ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> S = str ( input ( ) ) <NEWLINE> r = S . count ( <STRING> ) <NEWLINE> g = S . count ( <STRING> ) <NEWLINE> b = S . count ( <STRING> ) <NEWLINE> ans = ( r * g * b ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> ans = ( len ( r2 ) * len ( g2 ) * len ( b2 ) ) <NEWLINE> for i in range ( N - 2 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , N - 1 ) : <NEWLINE> <INDENT> k = 2 * j - i <NEWLINE> if k < N and S [ i ] != S [ j ] and S [ j ] != S [ k ] and S [ k ] != S [ i ] : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from itertools import product <NEWLINE> <NL> x1 = int ( input ( ) ) <NEWLINE> x2 = input ( ) <NEWLINE> <NL> R_i = [ i for i , x in enumerate ( x2 ) if x == <STRING> ] <NEWLINE> G_i = [ i for i , x in enumerate ( x2 ) if x == <STRING> ] <NEWLINE> B_i = { i for i , x in enumerate ( x2 ) if x == <STRING> } <NEWLINE> <NL> R = len ( R_i ) <NEWLINE> G = len ( G_i ) <NEWLINE> <COMMENT> <NL> <NL> xs = map ( sorted , product ( R_i , G_i ) ) <NEWLINE> <NL> s = 0 <NEWLINE> for a in xs : <NEWLINE> <INDENT> k = a [ 1 ] * 2 - a [ 0 ] <COMMENT> <NEWLINE> if k in B_i : <NEWLINE> <INDENT> s += 1 <NEWLINE> <DEDENT> i = a [ 0 ] * 2 - a [ 1 ] <COMMENT> <NEWLINE> if i in B_i : <NEWLINE> <INDENT> s += 1 <NEWLINE> <DEDENT> j = ( a [ 0 ] + a [ 1 ] ) / 2 <NEWLINE> if j . is_integer ( ) : <NEWLINE> <INDENT> j = int ( j ) <NEWLINE> if j in B_i : <NEWLINE> <INDENT> s += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( R * G * B - s ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> <COMMENT> <NL> ans = 0 <NEWLINE> for i in range ( n - 2 ) : <NEWLINE> <INDENT> s1 = s [ i ] <NEWLINE> for j in range ( i + 1 , n - 1 ) : <NEWLINE> <INDENT> s2 = s [ j ] <NEWLINE> <INDENT> if s1 == s2 : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s [ 2 * j - i ] != s1 and s [ 2 * j - i ] != s2 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from collections import Counter <NEWLINE> <NL> <NL> def main ( N = None , S = None ) : <NEWLINE> <INDENT> if not N or not S : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> S = int ( input ( ) ) <NEWLINE> <DEDENT> c = Counter ( S ) <NEWLINE> ans = c [ <STRING> ] * c [ <STRING> ] * c [ <STRING> ] <NEWLINE> for hop in range ( 1 , N // 2 ) : <NEWLINE> <INDENT> for start in range ( N ) : <NEWLINE> <INDENT> i = start <NEWLINE> j = start + hop <NEWLINE> k = start + hop * 2 <NEWLINE> if k >= N : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if S [ i ] != S [ j ] and S [ i ] != S [ k ] and S [ j ] != S [ k ] : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> return ans <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <INDENT> main ( ) <NEWLINE> <DEDENT>
def solve ( n , s ) : <NEWLINE> <NL> <INDENT> r_list = [ i for i in range ( n ) if s [ i ] == <STRING> ] <NEWLINE> g_list = [ i for i in range ( n ) if s [ i ] == <STRING> ] <NEWLINE> <COMMENT> <NL> b_dict = { i : 1 for i in range ( n ) if s [ i ] == <STRING> } <NEWLINE> <NL> res = len ( r_list ) * len ( g_list ) * len ( b_list ) <NEWLINE> for i in r_list : <NEWLINE> <INDENT> for j in g_list : <NEWLINE> <COMMENT> <NL> <INDENT> m , n = min ( i , j ) , max ( i , j ) <NEWLINE> if n + ( n - m ) in b_dict . keys ( ) : <NEWLINE> <INDENT> res -= 1 <NEWLINE> <DEDENT> if m - ( n - m ) in b_dict . keys ( ) : <NEWLINE> <INDENT> res -= 1 <NEWLINE> <DEDENT> if ( n - m ) % 2 == 0 and ( n + m ) // 2 in b_dict . keys ( ) : <NEWLINE> <INDENT> res -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> return res <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> res = solve ( n , s ) <NEWLINE> print ( res ) <NEWLINE> <NL> <NL> <DEDENT> def test ( ) : <NEWLINE> <INDENT> assert solve ( 4 , <STRING> ) == 1 <NEWLINE> assert solve ( 39 , <STRING> ) == 1800 <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> test ( ) <NEWLINE> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> r = 0 <NEWLINE> g = 0 <NEWLINE> for i in range ( s ) : <NEWLINE> <INDENT> if i == <STRING> : <NEWLINE> <INDENT> r += 1 <NEWLINE> <DEDENT> elif i == <STRING> : <NEWLINE> <INDENT> g += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> c = r * g * ( n - r - g ) <NEWLINE> for j in range ( 1 , n ) : <NEWLINE> <INDENT> for i in range ( 1 , min ( j , n - j - 1 ) + 1 ) : <NEWLINE> <INDENT> if s [ j ] != s [ j + i ] and s [ j ] != s [ j - i ] and s [ j - i ] != s [ j + 1 ] : <NEWLINE> <INDENT> c -= 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( c ) <NEWLINE>
<COMMENT> <NL> <NL> from fractions import gcd <NEWLINE> from collections import Counter , deque , defaultdict <NEWLINE> from heapq import heappush , heappop , heappushpop , heapify , heapreplace , merge <NEWLINE> from bisect import bisect_left , bisect_right , bisect , insort_left , insort_right , insort <NEWLINE> from itertools import accumulate , product , permutations , combinations , combinations_with_replacement <NEWLINE> <NL> import copy <NEWLINE> N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> <NL> ct = 0 <NEWLINE> <NL> def dfs ( index , RGB , indexs ) : <NEWLINE> <INDENT> global ct <NEWLINE> if RGB [ S [ index ] ] == 1 : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> RGB [ S [ index ] ] = 1 <NEWLINE> indexs += [ index ] <NEWLINE> <NL> if len ( indexs ) == 2 : <NEWLINE> <NL> <INDENT> for key , value in RGB . items ( ) : <NEWLINE> <INDENT> if value == 0 : <NEWLINE> <INDENT> ct += Counter ( S [ index + 1 : ] ) [ key ] <NEWLINE> h = indexs [ 1 ] + indexs [ 1 ] - indexs [ 0 ] + 1 <NEWLINE> if 0 < h <= N and S [ h - 1 ] == key : <NEWLINE> <INDENT> ct -= 1 <NEWLINE> <NL> <DEDENT> return <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for i in range ( index + 1 , N ) : <NEWLINE> <INDENT> dfs ( i , RGB . copy ( ) , copy . copy ( indexs ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> dfs ( i , { <STRING> : 0 , <STRING> : 0 , <STRING> : 0 } , [ ] ) <NEWLINE> <NL> <DEDENT> print ( ct ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> <NL> R = [ ] <NEWLINE> G = [ ] <NEWLINE> B = [ ] <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> R . append ( i ) <NEWLINE> <DEDENT> elif s [ i ] == <STRING> : <NEWLINE> <INDENT> G . append ( i ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> B . append ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> ans = len ( R ) * len ( G ) * len ( B ) <NEWLINE> for i in range ( n - 2 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n - 1 ) : <NEWLINE> <INDENT> k = 2 * j - i <NEWLINE> if k < n : <NEWLINE> <INDENT> if ( s [ i ] = s [ j ] ) and ( s [ i ] = s [ k ] ) and ( s [ j ] = s [ k ] ) : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> <NL> S = list ( input ( ) ) <NEWLINE> m = 0 <NEWLINE> <NL> a = S . count ( <STRING> ) <NEWLINE> b = S . count ( <STRING> ) <NEWLINE> c = S . count ( <STRING> ) <NEWLINE> <NL> num = a * b * c <NEWLINE> <NL> for i in range ( N - 2 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , N ) : <NEWLINE> <INDENT> k = 2 * j - i <NEWLINE> if k >= n - 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> elif S [ i ] != S [ j ] != S [ k ] : <NEWLINE> <INDENT> m += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( num - m ) <NEWLINE>
from numba import jit <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> R = [ ] <NEWLINE> G = [ ] <NEWLINE> B = [ ] <NEWLINE> <NL> @ jit <NEWLINE> def f ( ) : <NEWLINE> <INDENT> for i in range ( n ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> R . append ( i ) <NEWLINE> <DEDENT> elif s [ i ] == <STRING> : <NEWLINE> <INDENT> G . append ( i ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> B . append ( i ) <NEWLINE> <DEDENT> <DEDENT> r = len ( R ) <NEWLINE> g = len ( G ) <NEWLINE> b = len ( B ) <NEWLINE> if r == 0 or g == 0 or b == 0 : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = r * g * b <NEWLINE> m = 0 <NEWLINE> for j in range ( 1 , n - 1 ) : <NEWLINE> <INDENT> for k in range ( 1 , min ( j , n - 1 - j ) + 1 ) : <NEWLINE> <INDENT> lt = s [ j - k ] <NEWLINE> md = s [ j ] <NEWLINE> rt = s [ j + k ] <NEWLINE> if lt != md and md != rt and rt != lt : <NEWLINE> <INDENT> m += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return ans - m <NEWLINE> <DEDENT> <DEDENT> print ( f ( ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = str ( input ( ) ) <NEWLINE> <NL> R = [ ] <NEWLINE> G = [ ] <NEWLINE> B = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> R . append ( i + 1 ) <NEWLINE> <DEDENT> elif s [ i ] == <STRING> : <NEWLINE> <INDENT> G . append ( i + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> B . append ( i + 1 ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> ans = 0 <NEWLINE> <NL> for i in range ( len ( R ) ) : <NEWLINE> <INDENT> for j in range ( len ( G ) ) : <NEWLINE> <INDENT> test += len ( B ) <NEWLINE> temp = 0 <NEWLINE> if 2 * R [ i ] - G [ j ] > 0 and 2 * R [ i ] - G [ j ] <= n : <NEWLINE> <INDENT> if s [ 2 * R [ i ] - G [ j ] - 1 ] == <STRING> : <NEWLINE> <INDENT> temp += 1 <NEWLINE> <DEDENT> <DEDENT> if 2 * G [ j ] - R [ i ] > 0 and 2 * G [ j ] - R [ i ] <= n : <NEWLINE> <INDENT> if s [ 2 * G [ j ] - R [ i ] - 1 ] == <STRING> : <NEWLINE> <INDENT> temp += 1 <NEWLINE> <DEDENT> <DEDENT> if ( R [ i ] + G [ j ] ) % 2 == 0 : <NEWLINE> <INDENT> if s [ ( R [ i ] + G [ j ] ) // 2 - 1 ] == <STRING> : <NEWLINE> <INDENT> temp += 1 <NEWLINE> <DEDENT> <DEDENT> ans += len ( B ) - temp <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> <NL> r_cnt = s . count ( <STRING> ) <NEWLINE> g_cnt = s . count ( <STRING> ) <NEWLINE> b_cnt = s . count ( <STRING> ) <NEWLINE> <NL> ans = r_cnt * g_cnt * b_cnt <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> for d in range ( n ) : <NEWLINE> <INDENT> j = i + d <NEWLINE> k = j + d <NEWLINE> if s [ i ] != s [ j ] and s [ j ] != s [ k ] and s [ k ] != s [ i ] : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
def calc ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> s = list ( input ( ) ) <NEWLINE> cnt1 = 0 <NEWLINE> cnt2 = 0 <NEWLINE> cnt3 = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> cnt1 += 1 <NEWLINE> s [ i ] = 1 <NEWLINE> <DEDENT> elif s [ i ] == <STRING> : <NEWLINE> <INDENT> cnt2 += 1 <NEWLINE> s [ i ] = 2 <NEWLINE> <DEDENT> elif s [ i ] == <STRING> : <NEWLINE> <INDENT> cnt3 += 1 <NEWLINE> s [ i ] = 4 <NEWLINE> <DEDENT> <DEDENT> ans = cnt1 * cnt2 * cnt3 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n ) : <NEWLINE> <INDENT> k = 1 * j - i <NEWLINE> <INDENT> if k >= n : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if s [ i ] + s [ j ] + s [ k ] == 7 : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <DEDENT> calc ( ) <NEWLINE>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> s_li = list ( input ( ) . rstrip ( ) ) <NEWLINE> <NL> r_li = [ ] <NEWLINE> g_li = [ ] <NEWLINE> b_li = [ ] <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> if s_li [ i ] == <STRING> : <NEWLINE> <INDENT> r . append ( i ) <NEWLINE> <DEDENT> elif s_li [ i ] == <STRING> : <NEWLINE> <INDENT> g . append ( i ) <NEWLINE> <DEDENT> elif s_li [ i ] == <STRING> : <NEWLINE> <INDENT> b . append ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> if ( len ( r_li ) < 1 or len ( g_li ) < 1 ) or len ( b_li ) < 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> all_c = len ( r_li ) * len ( g_li ) * len ( b_li ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n ) : <NEWLINE> <INDENT> k = 2 * j - i <NEWLINE> if k >= n : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <DEDENT> if ( s_li [ i ] != s_li [ j ] and s_li [ j ] != s_li [ k ] ) and s_li [ i ] != s_li [ k ] : <NEWLINE> <INDENT> all_c -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( all_c ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import collections <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> <NL> lenR = S . count ( <STRING> ) <NEWLINE> lenG = S . count ( <STRING> ) <NEWLINE> lenB = S . count ( <STRING> ) <NEWLINE> <NL> count = 0 <NEWLINE> for i in range ( N - 2 ) : <NEWLINE> <INDENT> for j in range ( i , N - 1 ) : <NEWLINE> <INDENT> if 2 * j - i > N : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if ( S [ i ] != S [ j ] ) and ( S [ i ] != S [ 2 * j - i ] ) and ( S [ j ] != S [ 2 * j - i ] ) : <NEWLINE> <INDENT> count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( lenR * lenG * lenB - count ) <NEWLINE>
from collections import Counter <NEWLINE> n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> <NL> c = Counter ( list ( s ) ) <NEWLINE> ans = 1 <NEWLINE> for i in list ( c . values ) : <NEWLINE> <INDENT> ans *= i <NEWLINE> <DEDENT> for i in range ( n - 2 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n - 1 ) : <NEWLINE> <INDENT> k = j + ( j - i ) <NEWLINE> if k >= n : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if s [ i ] != s [ j ] and s [ j ] != s [ k ] and s [ k ] != s [ i ] : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = str ( input ( ) ) <NEWLINE> <NL> R , G , B = [ ] , [ ] , [ ] <NEWLINE> for i , c in enumerate ( s ) : <NEWLINE> <INDENT> if c == <STRING> : R . append ( i ) <NEWLINE> elif c == <STRING> : G . append ( i ) <NEWLINE> else : B . append ( i ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for r in R : <NEWLINE> <INDENT> for g in G : <NEWLINE> <INDENT> if r < g : x , y = r , g <NEWLINE> else : x , y = g , r <NEWLINE> <NL> ans += len ( X3 ) <NEWLINE> if x * 2 - y >= 0 : <NEWLINE> <INDENT> if s [ x * 2 - y ] == <STRING> : ans -= 1 <NEWLINE> <DEDENT> if ( x + y ) % 2 == 0 : <NEWLINE> <INDENT> if s [ ( x + y ) // 2 ] == <STRING> : ans -= 1 <NEWLINE> <DEDENT> if y * 2 - x < len ( s ) : <NEWLINE> <INDENT> if s [ y * 2 - x ] == <STRING> : ans -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> <NL> RN = S . count ( <STRING> ) <NEWLINE> GN = S . sount ( <STRING> ) <NEWLINE> BN = S . count ( <STRING> ) <NEWLINE> <NL> ans = RN * GN * BN <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> for d in range ( N ) : <NEWLINE> <INDENT> j = i + d <NEWLINE> k = i + 2 * d <NEWLINE> if k >= N : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if S [ i ] != S [ j ] and S [ j ] != S [ k ] and S [ k ] != S [ i ] : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> r = len ( S . replace ( <STRING> , <STRING> ) . replace ( <STRING> , <STRING> ) ) <NEWLINE> g = len ( S . replace ( <STRING> , <STRING> ) . replace ( <STRING> , <STRING> ) ) <NEWLINE> b = N - r - g <NEWLINE> <NL> ans = r * g <NEWLINE> ans = ans * b <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> for j in range ( i , int ( ( N + i ) / 2 + 1 ) ) : <NEWLINE> <INDENT> k = 2 * j - i <NEWLINE> <INDENT> if k < N : <NEWLINE> <INDENT> s = S [ i ] + S [ j ] + S [ k ] <NEWLINE> if ( <STRING> in s ) & ( <STRING> in s ) & ( <STRING> in s ) : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> from itertools import combinations <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> k = int ( input ( ) ) <NEWLINE> res = 0 <NEWLINE> memo = [ [ 0 for _ in range ( k + 1 ) ] for _ in range ( k + 1 ) ] <NEWLINE> for i ian range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for j in range ( i , k + 1 ) : <NEWLINE> <INDENT> tmp = math . gcd ( i , j ) <NEWLINE> memo [ i ] [ j ] = tmp <NEWLINE> memo [ j ] [ i ] = tmp <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> res += i <NEWLINE> <NL> <DEDENT> for c in combinations ( range ( 1 , k + 1 ) , 2 ) : <NEWLINE> <INDENT> ab = memo [ c [ 0 ] , c [ 1 ] ] <NEWLINE> res += ab * 6 <NEWLINE> <NL> <DEDENT> for c in combinations ( range ( 1 , k + 1 ) , 3 ) : <NEWLINE> <INDENT> ab = memo [ c [ 0 ] , c [ 1 ] ] <NEWLINE> abc = memo [ ab , c [ 2 ] ] <NEWLINE> res += abc * 6 <NEWLINE> <DEDENT> print ( res ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
<NL> n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> <NL> kumikazu = s . count ( <STRING> ) * s . count ( <STRING> ) * s . count ( <STRING> ) <NEWLINE> <NL> for i in range ( n - 2 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n - 1 ) : <NEWLINE> <INDENT> k = 2 * j - i <NEWLINE> if k >= n : <NEWLINE> <INDENT> if ( s [ i ] != s [ j ] ) and ( s [ i ] != s [ k ] ) and ( s [ j ] != s [ k ] ) : <NEWLINE> <INDENT> kumikazu -= 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT>
from numba import njit <NEWLINE> import numpy as np <NEWLINE> import sys <NEWLINE> read = sys . stdin . read <NEWLINE> readline = sys . stdin . readline <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> S = np . array ( list ( read ( ) . rstrip ( ) ) , np . int8 ) <NEWLINE> <NL> R = np . sum ( S == ord ( <STRING> ) ) <NEWLINE> B = np . sum ( S == ord ( <STRING> ) ) <NEWLINE> G = np . sum ( S == ord ( <STRING> ) ) <NEWLINE> <NL> <NL> @ njit <NEWLINE> def f ( S ) : <NEWLINE> <INDENT> N = len ( S ) <NEWLINE> ret = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> for j in range ( i + 1 , N ) : <NEWLINE> <INDENT> k = j + j - i <NEWLINE> if k >= N : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if S [ i ] != S [ j ] and S [ i ] != S [ k ] and S [ j ] != S [ k ] : <NEWLINE> <INDENT> ret += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return ret <NEWLINE> <NL> <NL> <DEDENT> answer = R * B * G - f ( S ) <NEWLINE> print ( answer ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> <NL> r_cnt = s . count ( <STRING> ) <NEWLINE> g_cnt = s . count ( <STRING> ) <NEWLINE> b_cnt = s . count ( <STRING> ) <NEWLINE> <NL> ans = r_cnt * g_cnt * b_cnt <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> for j in range ( i , N ) : <NEWLINE> <INDENT> k = 2 * j - i <NEWLINE> if k > N : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> elif S [ i ] != S [ j ] and S [ j ] != S [ k ] and S [ k ] != S [ i ] : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> <NL> ans = S . count ( <STRING> ) * S . count ( <STRING> ) * S . count ( <STRING> ) <NEWLINE> for i in range ( n - 2 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n - 1 ) : <NEWLINE> <INDENT> k = j + 1 <NEWLINE> if k < n and S [ i ] != S [ j ] and S [ i ] != S [ k ] and S [ j ] != S [ k ] : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> <NL> answer = s . count ( <STRING> ) * s . count ( <STRING> ) * s . count ( <STRING> ) <NEWLINE> <NL> for i in range ( n - 2 ) : <NEWLINE> <INDENT> j = 0 <NEWLINE> while ( ( i + 1 ) + ( j - i ) * 2 <= n ) : <NEWLINE> <INDENT> if s [ i ] != s [ j ] and s [ j ] != s [ ( i + 1 ) + ( j - i ) * 2 ] and s [ i ] != s [ ( i + 1 ) + ( j - i ) * 2 ] : <NEWLINE> <INDENT> answer -= 1 <NEWLINE> j += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( answer ) <NEWLINE>
mport sys <NEWLINE> read = sys . stdin . buffer . read <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> readlines = sys . stdin . buffer . readlines <NEWLINE> import numpy as np <NEWLINE> from numba import njit <NEWLINE> <NL> MOD = 10 ** 9 + 7 <NEWLINE> <NL> N = int ( readline ( ) ) <NEWLINE> S = np . array ( list ( read ( ) . rstrip ( ) ) , np . int8 ) <NEWLINE> <NL> R = np . sum ( S == ord ( <STRING> ) ) <NEWLINE> B = np . sum ( S == ord ( <STRING> ) ) <NEWLINE> G = np . sum ( S == ord ( <STRING> ) ) <NEWLINE> <NL> @ njit <NEWLINE> def f ( S ) : <NEWLINE> <INDENT> N = len ( S ) <NEWLINE> ret = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> for j in range ( i + 1 , N ) : <NEWLINE> <INDENT> k = j + j - i <NEWLINE> if k >= N : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if S [ i ] != S [ j ] and S [ i ] != S [ k ] and S [ j ] != S [ k ] : <NEWLINE> <INDENT> ret += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return ret <NEWLINE> <NL> <DEDENT> answer = R * B * G - f ( S ) <NEWLINE> print ( answer ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> R = set ( ) <NEWLINE> G = set ( ) <NEWLINE> B = set ( ) <NEWLINE> for i in range ( s ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> R . add ( i ) <NEWLINE> <DEDENT> elif s [ i ] == <STRING> : <NEWLINE> <INDENT> B . add ( i ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> G . add ( i ) <NEWLINE> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for r in R : <NEWLINE> <INDENT> for g in G : <NEWLINE> <INDENT> ans += len ( B ) <NEWLINE> if 2 * r - g in B : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <DEDENT> if 2 * g - r in B : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <DEDENT> if not ( r + g ) & 1 and ( r + g ) // 2 in B : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from collections import defaultdict , deque <NEWLINE> import sys <NEWLINE> import heapq <NEWLINE> import bisect <NEWLINE> import math <NEWLINE> import itertools <NEWLINE> import string <NEWLINE> import queue <NEWLINE> import copy <NEWLINE> import time <NEWLINE> <COMMENT> <NL> from fractions import gcd <NEWLINE> <NL> sys . setrecursionlimit ( 10 ** 8 ) <NEWLINE> INF = float ( <STRING> ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> eps = 10 ** - 7 <NEWLINE> <NL> <NL> def inp ( ) : return int ( sys . stdin . readline ( ) ) <NEWLINE> <NL> <NL> def inp_list ( ) : return list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> def lcm ( x , y ) : return ( x * y ) // gcd ( x , y ) <NEWLINE> <NL> <NL> N = inp ( ) <NEWLINE> S = input ( ) <NEWLINE> <NL> <STRING> <NEWLINE> <NL> r = S . count ( <STRING> ) <NEWLINE> g = S . count ( <STRING> ) <NEWLINE> b = S . count ( <STRING> ) <NEWLINE> <COMMENT> <NL> <NL> <NL> cnt = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> for j in range ( i + 1 , N ) : <NEWLINE> <INDENT> k = j + ( j - i ) <COMMENT> <NEWLINE> if S [ i ] != S [ j ] and S [ j ] != S [ k ] and S [ k ] != S [ i ] : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( r * g * b - cnt ) <NEWLINE>
import sys <NEWLINE> import collections <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> input = sys . stdin . readline <NEWLINE> N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> A = S . count ( <STRING> ) * S . count ( <STRING> ) * S . count ( <STRING> ) <NEWLINE> total = 0 <NEWLINE> for j in range ( 1 , N - 1 ) : <NEWLINE> <INDENT> for i in range ( j ) : <NEWLINE> <INDENT> k = 2 * j - i <NEWLINE> order += 1 <NEWLINE> if k < len ( S ) : <NEWLINE> <INDENT> if S [ i ] != S [ j ] and S [ i ] != S [ k ] and S [ j ] != S [ k ] : <NEWLINE> <INDENT> total += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( A - total ) <NEWLINE> <NL> <NL> <DEDENT> def main2 ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> A = S . count ( <STRING> ) * S . count ( <STRING> ) * S . count ( <STRING> ) <NEWLINE> order = 0 <NEWLINE> for i in range ( N - 2 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , N - 1 ) : <NEWLINE> <INDENT> order += 1 <NEWLINE> if 2 * j - i < N : <NEWLINE> <INDENT> if S [ i ] != S [ j ] and S [ i ] != S [ 2 * j - i ] and S [ j ] != S [ 2 * j - i ] : <NEWLINE> <INDENT> A -= 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( A ) <NEWLINE> print ( order ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> str = input ( ) <NEWLINE> count = str . count ( <STRING> ) * str . count ( <STRING> ) * str . count ( <STRING> ) <NEWLINE> count0 = 0 <NEWLINE> for i in range ( 0 , n - 2 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , ( n + i ) / 2 ) : <NEWLINE> <INDENT> k = 2 * j - i <NEWLINE> if str [ k ] != str [ i ] and str [ k ] != str [ j ] and str [ i ] != str [ j ] : <NEWLINE> <INDENT> count0 = count0 + 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( count - count0 ) <NEWLINE>
import numpy as np <NEWLINE> N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> <NL> c = S . count <NEWLINE> r , g , b = c ( <STRING> ) , c ( <STRING> ) , c ( <STRING> ) <NEWLINE> <NL> ans = r * g * b <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> for d in range ( N ) : <NEWLINE> <INDENT> j = i + d <NEWLINE> k = j * d <NEWLINE> if k >= n : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if S [ i ] != S [ j ] and S [ j ] != S [ k ] and S [ i ] != S [ i ] : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> from math import floor , ceil , sqrt , factorial , log <NEWLINE> from heapq import heappop , heappush , heappushpop <NEWLINE> from collections import Counter , defaultdict , deque <NEWLINE> from itertools import accumulate , permutations , combinations , product , combinations_with_replacement <NEWLINE> from bisect import bisect_left , bisect_right <NEWLINE> from copy import deepcopy <NEWLINE> from operator import itemgetter <NEWLINE> from fractions import gcd <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> inf = float ( <STRING> ) <NEWLINE> ninf = - float ( <STRING> ) <NEWLINE> <NL> <COMMENT> <NL> def ii ( ) : return int ( sys . stdin . readline ( ) . rstrip ( ) ) <COMMENT> <NEWLINE> def mii ( ) : return map ( int , sys . stdin . readline ( ) . rstrip ( ) . split ( ) ) <NEWLINE> def limii ( ) : return list ( mii ( ) ) <COMMENT> <NEWLINE> def lin ( n : int ) : return [ ii ( ) for _ in range ( n ) ] <NEWLINE> def llint ( n : int ) : return [ limii ( ) for _ in range ( n ) ] <NEWLINE> <COMMENT> <NL> def ss ( ) : return sys . stdin . readline ( ) . rstrip ( ) <COMMENT> <NEWLINE> def mss ( ) : return sys . stdin . readline ( ) . rstrip ( ) . split ( ) <NEWLINE> def limss ( ) : return list ( mss ( ) ) <COMMENT> <NEWLINE> def lst ( n : int ) : return [ ss ( ) for _ in range ( n ) ] <NEWLINE> def llstr ( n : int ) : return [ limss ( ) for _ in range ( n ) ] <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> n = ii ( ) <NEWLINE> s = list ( ss ( ) ) <NEWLINE> rarr = [ ] <NEWLINE> garr = [ ] <NEWLINE> barr = [ ] <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> rarr . append ( i ) <NEWLINE> <DEDENT> elif s [ i ] == <STRING> : <NEWLINE> <INDENT> garr . append ( i ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> barr . append ( i ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> ans = len ( rarr ) * len ( barr ) * len ( garr ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> for r in rarr : <NEWLINE> <INDENT> for b in barr : <NEWLINE> <COMMENT> <NL> <INDENT> if r - b > 0 and ( r + r - b in garr ) : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> elif b - r > 0 and ( b + b - r in garr ) : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> if r - b > 0 and ( r - b ) % 2 == 0 and b + ( ( r - b ) // 2 ) in garr : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <NL> <DEDENT> elif b - r > 0 and ( b - r ) % 2 == 0 and r + ( ( b - r ) // 2 ) in garr : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> if r - b > 0 and b - ( r - b ) in garr : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <NL> <DEDENT> elif b - r > 0 and r - ( b - r ) in garr : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> import math <NEWLINE> import itertools <NEWLINE> import bisect <NEWLINE> from copy import copy <NEWLINE> from collections import deque , Counter <NEWLINE> from decimal import Decimal <NEWLINE> import functools <NEWLINE> def s ( ) : return input ( ) <NEWLINE> def k ( ) : return int ( input ( ) ) <NEWLINE> def S ( ) : return input ( ) . split ( ) <NEWLINE> def I ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def X ( ) : return list ( input ( ) ) <NEWLINE> def L ( ) : return list ( input ( ) . split ( ) ) <NEWLINE> def l ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> def lcm ( a , b ) : return a * b // math . gcd ( a , b ) <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> cnt = 0 <NEWLINE> ans = 0 <NEWLINE> inf = float ( <STRING> ) <NEWLINE> <NL> n = k ( ) <NEWLINE> s = s ( ) <NEWLINE> r = s . count ( <STRING> ) <NEWLINE> g = s . count ( <STRING> ) <NEWLINE> b = s . count ( <STRING> ) <NEWLINE> ans = r * g * b <NEWLINE> for i in range ( n - 2 ) : <NEWLINE> <INDENT> for j in range ( ( n - i + 1 ) // 2 ) : <NEWLINE> <INDENT> if s [ i ] != s [ i + j ] and s [ i + j ] != s [ i + 2 * j ] and s [ i + 2 * j ] != s [ i ] : <NEWLINE> <INDENT> a -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( a ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = list ( input ( ) ) <NEWLINE> <NL> ri = [ i for i , x in enumerate ( s ) if x == <STRING> ] <NEWLINE> gi = [ i for i , x in enumerate ( s ) if x == <STRING> ] <NEWLINE> bi = [ i for i , x in enumerate ( s ) if x == <STRING> ] <NEWLINE> <NL> ans = len ( ri ) * len ( gi ) * len ( bi ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> for d in range ( n ) : <NEWLINE> <INDENT> j = i + d <NEWLINE> k = i + 2 * d <NEWLINE> if s [ i ] != s [ j ] and s [ j ] != s [ k ] and s [ k ] != s [ i ] : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> <NL> num = len ( s ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( num ) : <NEWLINE> <INDENT> a = set ( s [ i ] ) <NEWLINE> for j in range ( i + 1 , num ) : <NEWLINE> <INDENT> if s [ j ] in a : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> a . add ( s [ j ] ) <NEWLINE> for k in range ( j + 1 , num ) : <NEWLINE> <INDENT> if s [ k ] in a or j - i == k - j : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> ans += 1 <NEWLINE> <DEDENT> a . remove ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = list ( input ( ) ) <NEWLINE> ans = s . count ( <STRING> ) * s . count ( <STRING> ) * s . count ( <STRING> ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> s [ i ] = 1 <NEWLINE> <DEDENT> elif s [ i ] == <STRING> : <NEWLINE> <INDENT> s [ i ] <NEWLINE> <DEDENT> elif s [ i ] == <STRING> : <NEWLINE> <INDENT> s [ i ] = 4 <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n ) : <NEWLINE> <INDENT> k = 2 * j - i <NEWLINE> if k >= n : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if s [ i ] + s [ j ] + s [ k ] == 7 : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from itertools import product as pro <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> s = str ( input ( ) ) <NEWLINE> <NL> r = [ i for i in range ( n ) if s [ i ] == <STRING> ] <NEWLINE> g = [ i for i in range ( n ) if s [ i ] == <STRING> ] <NEWLINE> b = [ i for i in range ( n ) if s [ i ] == <STRING> ] <NEWLINE> cnt = len ( r ) * len ( g ) * len ( b ) <NEWLINE> <NL> len = max ( len ( r ) , len ( g ) , len ( b ) ) <NEWLINE> if len == len ( r ) : <NEWLINE> <INDENT> max1 = set ( r ) <NEWLINE> min1 = g <NEWLINE> min2 = b <NEWLINE> <NL> <DEDENT> if len == len ( g ) : <NEWLINE> <INDENT> max1 = set ( g ) <NEWLINE> min1 = r <NEWLINE> min2 = b <NEWLINE> <NL> <DEDENT> if len == len ( b ) : <NEWLINE> <INDENT> max1 = set ( b ) <NEWLINE> min1 = g <NEWLINE> min2 = r <NEWLINE> <NL> <DEDENT> for i , j in pro ( min1 , min2 ) : <NEWLINE> <INDENT> if 2 * j - i in max1 : <NEWLINE> <INDENT> cnt -= 1 <NEWLINE> <DEDENT> if 2 * i - j in max1 : <NEWLINE> <INDENT> cnt -= 1 <NEWLINE> <DEDENT> if ( i + j ) / 2 in max1 : <NEWLINE> <INDENT> cnt -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
_input = input <NEWLINE> <COMMENT> <NL> allinputs = iter ( input ( ) . splitlines ( ) ) <NEWLINE> input = lambda : next ( allinputs ) <NEWLINE> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> <NL> RGB_num = [ 0 ] * 3 <NEWLINE> <NL> for c in S : <NEWLINE> <INDENT> if c == <STRING> : <NEWLINE> <INDENT> RGB_num [ 0 ] += 1 <NEWLINE> <DEDENT> elif c == <STRING> : <NEWLINE> <INDENT> RGB_num [ 1 ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> RGB_num [ 2 ] += 1 <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> joken2 = 0 <NEWLINE> <NL> print ( S [ 0 ] ) <NEWLINE> for i in range ( N - 2 ) : <NEWLINE> <COMMENT> <NL> <INDENT> for j in range ( min ( i + 1 , N - i - 2 ) ) : <NEWLINE> <INDENT> if S [ i + 1 ] != S [ i - j ] and S [ i + 1 ] != S [ i + j + 2 ] and S [ i - j ] != S [ i + j + 2 ] : <NEWLINE> <INDENT> joken2 += 1 <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> joken1 = RGB_num [ 0 ] * RGB_num [ 1 ] * RGB_num [ 2 ] <NEWLINE> <NL> print ( joken1 - joken2 ) <NEWLINE> <NL> input = _input <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = str ( input ( ) ) <NEWLINE> rn = s . count ( <STRING> ) <NEWLINE> gn = s . count ( <STRING> ) <NEWLINE> bn = s . count ( <STRING> ) <NEWLINE> <NL> ct = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n ) : <NEWLINE> <INDENT> k = 2 * j - i <NEWLINE> if k = n : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> elif s [ i ] != s [ j ] and s [ j ] != s [ k ] and s [ i ] != s [ k ] : <NEWLINE> <INDENT> ct += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( rn * gn * bn - ct ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> result = 0 <NEWLINE> <STRING> <NEWLINE> r = S . count ( <STRING> ) <NEWLINE> g = S . count ( <STRING> ) <NEWLINE> b = S . count ( <STRING> ) <NEWLINE> target = set ( <STRING> ) <NEWLINE> result = r * g * b <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> for j in range ( 1 , min ( i , ( N - i + 1 ) ) + 1 ) : <NEWLINE> <INDENT> if target == set ( S [ i ] + S [ i - j ] + S [ j + i ] ) : <NEWLINE> <INDENT> result -= 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( result ) <NEWLINE>
import collections <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> res = 0 <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> num = collections . Counter ( s ) <NEWLINE> <COMMENT> <NL> num_r = num [ <STRING> ] <NEWLINE> num_g = num [ <STRING> ] <NEWLINE> num_b = n - num_r - num_g <NEWLINE> count_2 = 0 <NEWLINE> for x in range ( 1 , int ( n / 2 ) + 1 ) : <NEWLINE> <INDENT> for i in range ( n - 2 * x - i ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <INDENT> if ( i + 2 * x < n and s [ i ] != s [ i + x ] and s [ i + x ] != s [ i + 2 * x ] and s [ i ] != s [ i + 2 * x ] ) : <NEWLINE> <INDENT> count_2 += 1 <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> res = num_r * num_g * num_b - count_2 <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> print ( res ) <NEWLINE>
M = 1000000007 <NEWLINE> <NL> <NL> def main ( N = None , K = None ) : <NEWLINE> <INDENT> if not N or not K : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> K = int ( input ( ) ) <NEWLINE> <DEDENT> ans = 0 <NEWLINE> gcds = { } <NEWLINE> for X in range ( K , 0 , - 1 ) : <NEWLINE> <INDENT> gcds [ X ] = int ( pow ( K // X , N , M ) ) <NEWLINE> n = 1 <NEWLINE> while True : <NEWLINE> <INDENT> n += 1 <NEWLINE> if n * X > K : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> gcds [ X ] -= gcds [ n * X ] <NEWLINE> <DEDENT> ans += gcds [ X ] * X <NEWLINE> <DEDENT> ans %= M <NEWLINE> print ( ans ) <NEWLINE> return ans <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <INDENT> main ( ) <NEWLINE> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> c = 10 ** 9 + 7 <NEWLINE> tm = [ 0 ] + [ 1 ] * k <NEWLINE> a = k // 2 <NEWLINE> ans = k * ( k + 1 ) // 2 - a * ( a + 1 ) // 2 <NEWLINE> for i in range ( k // 2 , 0 , - 1 ) : <NEWLINE> <INDENT> a = k // i <NEWLINE> t = ( left_bin ( a , n , c ) - sum ( [ tm [ j * i ] for j in range ( 2 , a + 1 ) ] ) ) % c <NEWLINE> ans = ( ans + t * i ) % c <NEWLINE> tm [ i ] = t <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
MOD = 10 ** 9 + 7 <NEWLINE> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> L = [ 0 ] * ( k + 1 ) <NEWLINE> <NL> for i in range ( k , 0 , - 1 ) : <NEWLINE> <INDENT> L [ i ] = pow ( k // i , n , mod ) <NEWLINE> for j in range ( 2 , k // i + 1 ) : <NEWLINE> <INDENT> L [ i ] -= L [ i * j ] <NEWLINE> <NL> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for i in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> ans = ( ans + i * L [ i ] ) % MOD <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> import copy <NEWLINE> import random <NEWLINE> import bisect <COMMENT> <NEWLINE> import fractions <COMMENT> <NEWLINE> import math <NEWLINE> import sys <NEWLINE> import collections <NEWLINE> <NL> mod = 10 ** 9 + 7 <NEWLINE> sys . setrecursionlimit ( mod ) <COMMENT> <NEWLINE> <NL> d = collections . deque ( ) <NEWLINE> def LI ( ) : return list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) <NEWLINE> <NL> N , K = LI ( ) <NEWLINE> <NL> <COMMENT> <NL> <STRING> <NEWLINE> <NL> x_cnt = [ 0 for i in range ( K + 1 ) ] <NEWLINE> for x in range ( N , 0 , - 1 ) : <NEWLINE> <COMMENT> <NL> <INDENT> tmp = pow ( K // x , N , mod ) <NEWLINE> for x_n in range ( x + x , N + 1 , x ) : <NEWLINE> <INDENT> tmp -= x_cnt [ x_n ] <NEWLINE> <DEDENT> x_cnt [ x ] = tmp % mod <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> ans += i * x_cnt [ i ] <NEWLINE> ans %= mod <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <NL> <NL>
N , K = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> l = [ 0 ] * ( K + 1 ) <NEWLINE> ans = 0 <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> for x in range ( K , 0 , - 1 ) : <NEWLINE> <INDENT> l [ x ] = pow ( ( K // x ) , N , mod ) <NEWLINE> for y in range ( 2 * x , K + 1 , x ) : <NEWLINE> <INDENT> l [ x ] -= l [ y ] <NEWLINE> l [ x ] = pow ( l [ i ] , 1 , mod ) <NEWLINE> <DEDENT> ans += l [ x ] * x <NEWLINE> ans = pow ( ans , 1 , mod ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> MOD = 1000000007 <NEWLINE> n , k = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> d = [ pow ( k , n , MOD ) for i in range ( 1 , k + 1 ) ] <NEWLINE> <NL> for i in range ( k , 0 , - 1 ) : <COMMENT> <NEWLINE> <INDENT> for j in range ( i * 2 , k + 1 , i ) : <COMMENT> <NEWLINE> <COMMENT> <NL> <INDENT> d [ i ] -= d [ j ] <NEWLINE> d [ i ] %= MOD <NEWLINE> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for i , item in enumerate ( d ) : <NEWLINE> <INDENT> ans += i * item <NEWLINE> ans %= MOD <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a0 , a1 , a2 , b0 , b1 , b2 = A [ 0 ] , 0 , 0 , A [ 1 ] , 0 , 0 <NEWLINE> for a in A [ 2 : ] : <NEWLINE> <INDENT> a0 , a1 , a2 , b0 , b1 , b2 = ( <NEWLINE> <INDENT> b0 , <NEWLINE> max ( b1 , a0 ) , <NEWLINE> max ( b2 , a1 ) , <NEWLINE> a0 + a , <NEWLINE> a1 + a , <NEWLINE> a2 + a ) <NEWLINE> <NL> <DEDENT> <DEDENT> if N & 1 : <NEWLINE> <INDENT> return max ( b2 , a1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return max ( a0 , b1 ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> print ( main ( ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> <NL> remain = [ [ 0 , 0 , 0 ] ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> r , g , b = remain [ - 1 ] <NEWLINE> if s [ - i - 1 ] == <STRING> : <NEWLINE> <INDENT> r = r + 1 <NEWLINE> <DEDENT> elif s [ - i - 1 ] == <STRING> : <NEWLINE> <INDENT> g = g + 1 <NEWLINE> <DEDENT> elif s [ - i - 1 ] == <STRING> : <NEWLINE> <INDENT> b = b + 1 <NEWLINE> <NL> <DEDENT> remain . append ( [ r , g , b ] ) <NEWLINE> <NL> <DEDENT> total = 0 <NEWLINE> for i in range ( n - 2 ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> for j in range ( i + 1 , n ) : <NEWLINE> <INDENT> if s [ j ] == <STRING> : <NEWLINE> <INDENT> total += remain [ - j - 1 ] [ 2 ] <NEWLINE> if i + ( ( j - i ) * 2 ) < n : <NEWLINE> <INDENT> if s [ i + ( ( j - i ) * 2 ) ] == <STRING> : <NEWLINE> <INDENT> total -= 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> elif s [ j ] == <STRING> : <NEWLINE> <INDENT> total += remain [ - j - 1 ] [ 1 ] <NEWLINE> if i + ( ( j - i ) * 2 ) < n : <NEWLINE> <INDENT> if s [ i + ( ( j - i ) * 2 ) ] == <STRING> : <NEWLINE> <INDENT> total -= 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> elif s [ i ] == <STRING> : <NEWLINE> <INDENT> for j in range ( i + 1 , n ) : <NEWLINE> <INDENT> if s [ j ] == <STRING> : <NEWLINE> <INDENT> total += remain [ - j - 1 ] [ 0 ] <NEWLINE> if i + ( ( j - i ) * 2 ) < n : <NEWLINE> <INDENT> if s [ i + ( ( j - i ) * 2 ) ] == <STRING> : <NEWLINE> <INDENT> total -= 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> elif s [ j ] == <STRING> : <NEWLINE> <INDENT> total += remain [ - j - 1 ] [ 2 ] <NEWLINE> if i + ( ( j - i ) * 2 ) < n : <NEWLINE> <INDENT> if s [ i + ( ( j - i ) * 2 ) ] == <STRING> : <NEWLINE> <INDENT> total -= 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> elif s [ i ] == <STRING> : <NEWLINE> <INDENT> for j in range ( i + 1 , n ) : <NEWLINE> <NL> <INDENT> if s [ j ] == <STRING> : <NEWLINE> <INDENT> total += remain [ - j - 1 ] [ 1 ] <NEWLINE> if i + ( ( j - i ) * 2 ) < n : <NEWLINE> <INDENT> if s [ i + ( ( j - i ) * 2 ) ] == <STRING> : <NEWLINE> <INDENT> total -= 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> elif s [ j ] == <STRING> : <NEWLINE> <INDENT> total += remain [ - j - 1 ] [ 0 ] <NEWLINE> if i + ( ( j - i ) * 2 ) < n : <NEWLINE> <INDENT> if s [ i + ( ( j - i ) * 2 ) ] == <STRING> : <NEWLINE> <INDENT> total -= 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( total ) <NEWLINE>
def factorization ( n ) : <NEWLINE> <INDENT> arr = [ ] <NEWLINE> temp = n <NEWLINE> for i in range ( 2 , int ( - ( - n ** 0.5 // 1 ) ) + 1 ) : <NEWLINE> <INDENT> if temp % i == 0 : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> while temp % i == 0 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> temp //= i <NEWLINE> <DEDENT> arr . append ( [ i , cnt ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> if temp != 1 : <NEWLINE> <INDENT> arr . append ( [ temp , 1 ] ) <NEWLINE> <NL> <DEDENT> if arr == [ ] : <NEWLINE> <INDENT> arr . append ( [ n , 1 ] ) <NEWLINE> <NL> <DEDENT> return arr <NEWLINE> <NL> <DEDENT> import numpy as np <NEWLINE> M = int ( 10 ** 9 ) + 7 <NEWLINE> n , k = [ int ( c ) for c in input ( ) . split ( ) ] <NEWLINE> nums = [ 0 ] * ( k + 1 ) <NEWLINE> nums = np . zeros ( ( k + 1 ) , dtype = int ) <NEWLINE> for i in range ( k , 0 , - 1 ) : <NEWLINE> <INDENT> tmp = ( pow ( k // i , n , M ) <NEWLINE> tmp -= nums [ ( 2 * i ) : : i ] . sum ( ) <NEWLINE> nums [ i ] += tmp <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> print ( ( np . arange ( k + 1 ) * nums ) . sum ( ) % M ) <NEWLINE>
import sys <NEWLINE> import numpy as np <NEWLINE> read = sys . stdin . buffer . read <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> readlines = sys . stdin . buffer . readlines <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> N , K = map ( int , readline ( ) . split ( ) ) <NEWLINE> d = [ 0 ] * ( K + 1 ) <NEWLINE> for i in range ( K , 0 , - 1 ) : <NEWLINE> <INDENT> t = K // i <NEWLINE> cnt = pow ( t , N , MOD ) <NEWLINE> for j in range ( 2 , t + 1 ) : <NEWLINE> <INDENT> cnt -= d [ i * j ] <NEWLINE> cnt %= mod <NEWLINE> <DEDENT> d [ i ] = cnt <NEWLINE> <DEDENT> ans = 0 <NEWLINE> for num , cnt in enumerate ( d ) : <NEWLINE> <INDENT> ans += num * cnt <NEWLINE> ans %= MOD <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> using namespace std ; <NEWLINE> typedef long long ll ; <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> int k ; <NEWLINE> int memo [ 200 + 1 ] [ 200 + 1 ] ; <NEWLINE> ll N = 1000000000 + 7 ; <NEWLINE> <NL> int gcd ( int x , int y ) { <NEWLINE> <INDENT> if ( y == 0 ) { <NEWLINE> <INDENT> return x ; <NEWLINE> <DEDENT> } <NEWLINE> return gcd ( y , x % y ) ; <NEWLINE> <DEDENT> } <NEWLINE> <NL> int main ( ) { <NEWLINE> <INDENT> cin >> k ; <NEWLINE> int ans = 0 ; <NEWLINE> for ( int a = 1 ; a <= k ; a + + ) { <NEWLINE> <INDENT> for ( int b = 1 ; b <= k ; b + + ) { <NEWLINE> <INDENT> for ( int c = 1 ; c <= k ; c + + ) { <NEWLINE> <INDENT> ans += gcd ( gcd ( a , b ) , c ) % N ; <NEWLINE> <DEDENT> } <NEWLINE> <DEDENT> } <NEWLINE> <DEDENT> } <NEWLINE> cout << ans << endl ; <NEWLINE> return 0 ; <NEWLINE> <DEDENT> } <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> dp = [ 0 ] * ( k + 1 ) <NEWLINE> mod = int ( 1e9 + 7 ) <NEWLINE> for i in range ( k , 0 , - 1 ) : <NEWLINE> <INDENT> sm = 0 <NEWLINE> for j in range ( 2 * i , k + 1 , i ) : <NEWLINE> <INDENT> sm = ( sm + dp [ j ] ) % mod <NEWLINE> <DEDENT> dp [ i ] = pow ( k // i , n , mod ) - sm <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> ans += ( dp [ i ] % mod * i % mod ) % mod <NEWLINE> <DEDENT> print ( ans % mod ) <NEWLINE>
import math <NEWLINE> <NL> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> P = 10 ** 9 + 7 <NEWLINE> <NL> L = [ 0 ] * K <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> L [ i ] = pow ( K // ( i + 1 ) , N - 1 , P ) <NEWLINE> <NL> <DEDENT> def culc ( x ) : <NEWLINE> <INDENT> f = K // i <NEWLINE> r = K - f <NEWLINE> if r == 1 : <NEWLINE> <INDENT> return ( f * ( N - 1 ) ) % P <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> y = pow ( r , N - 1 ) - 1 <NEWLINE> return ( ( f * y ) // ( r - 1 ) ) % P <NEWLINE> <NL> <DEDENT> <DEDENT> for j in range ( 1 , K ) : <NEWLINE> <INDENT> L [ 0 ] += culc ( j + 1 ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for k in range ( K ) : <NEWLINE> <INDENT> ans += ( ( k + 1 ) * L [ k ] ) % P <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE> <NL>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> MOD = 10 ** 9 + 7 <NEWLINE> <NL> cache = { } <NEWLINE> def f ( k , n ) : <NEWLINE> <INDENT> if k == 1 : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> if k in cache : <NEWLINE> <INDENT> return cache [ k ] <NEWLINE> <DEDENT> result = pow ( k , n , MOD ) <NEWLINE> for i in range ( 2 , k + 1 ) : <NEWLINE> <INDENT> result -= f ( k // i , n ) <NEWLINE> result %= MOD <NEWLINE> <DEDENT> cache [ k ] = result <NEWLINE> return result <NEWLINE> <NL> <NL> <DEDENT> result = 0 <NEWLINE> for i in range ( K + 1 ) : <NEWLINE> <INDENT> result += f ( K // i , N ) * i <NEWLINE> result %= MOD <NEWLINE> <DEDENT> print ( result ) <NEWLINE>
import math <NEWLINE> K = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> for k in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> ans += math . gcd ( i , math . gcd ( j , k ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> DP_odd = [ 0 , 0 , A [ 0 ] ] <NEWLINE> DP_even = [ 0 , max ( A [ 0 ] , A [ 1 ] ) ] <NEWLINE> <NL> if N >= 3 : <NEWLINE> <INDENT> DP_odd = [ DP_even [ 0 ] , max ( DP_odd [ 1 ] + A [ i ] , DP_even [ 1 ] ) , DP_odd [ 2 ] + A [ 2 ] ] <NEWLINE> <NL> <DEDENT> for i in range ( 3 , N ) : <NEWLINE> <INDENT> if ( i + 1 ) % 2 == 1 : <NEWLINE> <INDENT> DP_odd = [ max ( DP_odd [ 0 ] + A [ i ] , DP_even [ 0 ] ) , max ( DP_odd [ 1 ] + A [ i ] , DP_even [ 1 ] ) , DP_odd [ 2 ] + A [ i ] ] <NEWLINE> print ( DP_odd ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> DP_even = [ max ( DP_even [ 0 ] + A [ i ] , DP_odd [ 1 ] ) , max ( DP_even [ 1 ] + A [ i ] , DP_odd [ 2 ] ) ] <NEWLINE> print ( DP_even ) <NEWLINE> <NL> <DEDENT> <DEDENT> if N % 2 == 1 : <NEWLINE> <INDENT> ans = DP_odd [ 1 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = DP_even [ 1 ] <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
<NL> n = int ( input ( ) ) <NEWLINE> a_list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if n % 2 == 0 : <COMMENT> <NEWLINE> <INDENT> dp = [ [ - float ( <STRING> ) for _ in range ( n ) ] for __ in range ( 2 ) ] <NEWLINE> dp [ 1 ] [ - 1 ] = a_list [ - 1 ] <NEWLINE> <NL> for j in reversed ( range ( 2 ) ) : <NEWLINE> <INDENT> for i in reversed ( range ( n ) ) : <NEWLINE> <INDENT> if j == 2 and i >= n - 2 : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> elif j == 2 : <NEWLINE> <INDENT> dp [ j ] [ i ] = dp [ j ] [ i + 2 ] + a_list [ i ] <NEWLINE> <DEDENT> elif i == n - 2 : <NEWLINE> <INDENT> dp [ j ] [ i ] = dp [ j + 1 ] [ i + 1 ] <NEWLINE> <DEDENT> elif i > n - 2 : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dp [ j ] [ i ] = max ( dp [ j + 1 ] [ i + 1 ] , dp [ j ] [ i + 2 ] + a_list [ i ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( dp [ 0 ] [ 0 ] ) <NEWLINE> <DEDENT> else : <COMMENT> <NEWLINE> <INDENT> dp = [ [ - float ( <STRING> ) for _ in range ( n ) ] for __ in range ( 3 ) ] <NEWLINE> dp [ 2 ] [ - 1 ] = a_list [ - 1 ] <NEWLINE> <NL> for j in reversed ( range ( 3 ) ) : <NEWLINE> <INDENT> for i in reversed ( range ( n ) ) : <NEWLINE> <INDENT> if j == 2 and i >= n - 2 : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> elif j == 2 : <NEWLINE> <INDENT> dp [ j ] [ i ] = dp [ j ] [ i + 2 ] + a_list [ i ] <NEWLINE> <DEDENT> elif i == n - 2 : <NEWLINE> <INDENT> dp [ j ] [ i ] = dp [ j + 1 ] [ i + 1 ] <NEWLINE> <DEDENT> elif i > n - 2 : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dp [ j ] [ i ] = max ( dp [ j + 1 ] [ i + 1 ] , dp [ j ] [ i + 2 ] + a_list [ i ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( dp [ 0 ] [ 0 ] ) <NEWLINE> <DEDENT>
from collections import defaultdict , Counter <NEWLINE> from heapq import heapify , heappop , heappush <NEWLINE> from sys import stdin <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> a = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> if n % 2 == 0 : <NEWLINE> <INDENT> v = [ [ None for j in range ( 2 ) ] for i in range ( n ) ] <NEWLINE> v [ 0 ] [ 0 ] = a [ 0 ] <NEWLINE> v [ 1 ] [ 1 ] = a [ 1 ] <NEWLINE> for i in range ( 2 , n ) : <NEWLINE> <INDENT> for j in range ( 2 ) : <NEWLINE> <INDENT> c = [ ] <NEWLINE> if v [ i - 2 ] [ j ] is not None : <NEWLINE> <INDENT> c . append ( v [ i - 2 ] [ j ] ) <NEWLINE> <DEDENT> if j >= 1 and i >= 3 : <NEWLINE> <INDENT> if v [ i - 3 ] [ j - 1 ] is not None : <NEWLINE> <INDENT> c . append ( v [ i - 3 ] [ j - 1 ] ) <NEWLINE> <DEDENT> <DEDENT> if len ( c ) == 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> v [ i ] [ j ] = max ( c ) + a [ i ] <NEWLINE> <DEDENT> <DEDENT> c = [ v [ n - 1 ] [ j ] for j in range ( 2 ) ] <NEWLINE> print ( max ( c ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> v = [ [ None for j in range ( 3 ) ] for i in range ( n ) ] <NEWLINE> v [ 0 ] [ 0 ] = a [ 0 ] <NEWLINE> v [ 1 ] [ 1 ] = a [ 1 ] <NEWLINE> v [ 2 ] [ 0 ] = a [ 0 ] + a [ 2 ] <NEWLINE> v [ 2 ] [ 2 ] = a [ 2 ] <NEWLINE> for i in range ( 3 , n ) : <NEWLINE> <INDENT> for j in range ( 3 ) : <NEWLINE> <INDENT> c = [ ] <NEWLINE> if v [ i - 2 ] [ j ] is not None : <NEWLINE> <INDENT> c . append ( v [ i - 2 ] [ j ] ) <NEWLINE> <DEDENT> if j >= 1 : <NEWLINE> <INDENT> if v [ i - 3 ] [ j - 1 ] is not None : <NEWLINE> <INDENT> c . append ( v [ i - 3 ] [ j - 1 ] ) <NEWLINE> <DEDENT> <DEDENT> if j >= 2 and i >= 4 : <NEWLINE> <INDENT> if v [ i - 4 ] [ j - 2 ] is not None : <NEWLINE> <INDENT> c . append ( v [ i - 4 ] [ j - 2 ] ) <NEWLINE> <DEDENT> <DEDENT> if len ( c ) == 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> v [ i ] [ j ] = max ( c ) + a [ i ] <NEWLINE> <DEDENT> <DEDENT> c = [ v [ n - 1 ] [ j ] for j in range ( 3 ) if v [ n - 1 ] [ j ] is not None ] <NEWLINE> print ( max ( c ) ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def input ( ) : return stdin . readline ( ) . rstrip ( ) <NEWLINE> <NL> <NL> main ( ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> * A , = map ( int , input ( ) . split ( ) ) <NEWLINE> inf = 10 ** 18 <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> DP = [ ( None , None ) for i in range ( n ) ] <NEWLINE> DP [ 0 ] = ( 0 , A [ 0 ] ) <NEWLINE> DP [ 1 ] = ( 0 , max ( A [ 0 ] , A [ 1 ] ) ) <NEWLINE> for i in range ( 2 , n ) : <NEWLINE> <INDENT> if i % 2 == 0 : <NEWLINE> <INDENT> DP [ i ] [ 0 ] = max ( DP [ i - 2 ] [ 0 ] + A [ i ] , DP [ i - 1 ] [ 1 ] ) <NEWLINE> DP [ i ] [ 1 ] = DP [ i - 2 ] [ 1 ] + A [ i ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> DP [ i ] [ 0 ] = max ( DP [ i - 2 ] [ 0 ] + A [ i ] , DP [ i - 1 ] [ 0 ] ) <NEWLINE> DP [ i ] [ 1 ] = max ( DP [ i - 2 ] [ 1 ] + A [ i ] , DP [ i - 1 ] [ 1 ] ) <NEWLINE> <DEDENT> <DEDENT> if n % 2 == 0 : <NEWLINE> <INDENT> print ( DP [ n - 1 ] [ 1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( DP [ n - 1 ] [ 0 ] ) <NEWLINE> <DEDENT>
n , * l = open ( 0 ) ; n = int ( n ) ; l = list ( map ( int , l . split ( ) ) ) <NEWLINE> p = [ 0 ] * n ; d = [ 0 ] * n <NEWLINE> for i in range ( n ) : p [ i ] = l [ i ] + p [ i - 2 ] ; d [ i ] = max ( p [ i - 1 ] if ( i & 1 ) else d [ i - 1 ] , l [ i ] + d [ i - 2 ] ) <NEWLINE> print ( d [ - 1 ] ) <NEWLINE>
import collections <NEWLINE> import math <NEWLINE> <NL> N , * A = map ( int , open ( 0 ) . read ( ) . split ( ) ) <NEWLINE> a = dict ( enumerate ( A , 1 ) ) <NEWLINE> dp = collections . defaultdict ( int ) <NEWLINE> dp [ 1 , 1 ] = a [ 1 ] <NEWLINE> <NL> for i in range ( 2 , N + 1 ) : <NEWLINE> <INDENT> jj = range ( math . floor ( i // 2 - 1 ) , math . ceil ( ( i + 1 ) // 2 ) + 1 ) <NEWLINE> debug ( jj ) <NEWLINE> for j in jj : <NEWLINE> <INDENT> x = dp [ i - 2 , j - 1 ] + a [ i ] <NEWLINE> y = dp [ i - 1 , j ] <NEWLINE> dp [ i , j ] = max ( x , y ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( dp [ N , N // 2 ] ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> * A , = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if N % 2 == 0 : <NEWLINE> <INDENT> 1 / 0 <NEWLINE> ans = max ( sum ( A [ : : 2 ] ) , sum ( A [ 1 : : 2 ] ) ) <NEWLINE> print ( ans ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> INF = 2 * 10 ** 9 <NEWLINE> dp = [ [ - INF ] * N for _ in [ 0 ] * 3 ] <NEWLINE> dp [ 0 ] [ 0 ] = A [ 0 ] <NEWLINE> dp [ 1 ] [ 1 ] = A [ 1 ] <NEWLINE> dp [ 2 ] [ 2 ] = A [ 2 ] <NEWLINE> for i in range ( 2 , N , 2 ) : <NEWLINE> <INDENT> a = A [ i ] <NEWLINE> dp [ 0 ] [ i ] = dp [ 0 ] [ i - 2 ] + a <NEWLINE> <DEDENT> for i in range ( 3 , N ) : <NEWLINE> <INDENT> a = A [ i ] <NEWLINE> dp [ 1 ] [ i ] = max ( dp [ 1 ] [ i - 2 ] , dp [ 0 ] [ i - 3 ] ) + a <NEWLINE> <DEDENT> for i in range ( 4 , N , 2 ) : <NEWLINE> <INDENT> a = A [ i ] <NEWLINE> dp [ 2 ] [ i ] = max ( dp [ 2 ] [ i - 2 ] , dp [ 1 ] [ i - 3 ] , dp [ 0 ] [ i - 4 ] ) + a <NEWLINE> <DEDENT> print ( dp [ 2 ] [ - 1 ] ) <NEWLINE> <DEDENT>
input ( ) <NEWLINE> aa = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> bb = [ 0 ] * len ( aa ) <NEWLINE> bb [ 0 ] = aa [ 0 ] <NEWLINE> bb [ 1 ] = aa [ 1 ] <NEWLINE> for i in range ( 2 , len ( aa ) ) : <NEWLINE> <INDENT> bb [ i ] = bb [ i - 2 ] + aa [ i ] <NEWLINE> <NL> <DEDENT> sum0 = bb [ len ( aa ) - 2 ] <NEWLINE> sum1 = bb [ len ( aa ) - 1 ] <NEWLINE> ret = sum1 <NEWLINE> if len ( aa ) % 2 == 0 : <NEWLINE> <INDENT> ret = max ( ret , sum0 ) <NEWLINE> <DEDENT> if len ( aa ) % 2 : <NEWLINE> <INDENT> sum0 = bb [ len ( aa ) - 1 ] <NEWLINE> sum1 = bb [ len ( aa ) - 2 ] <NEWLINE> for i in range ( len ( aa ) // 2 ) : <NEWLINE> <INDENT> ret = max ( ret , sum0 - aa [ 2 * i ] ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> for i in range ( 0 , len ( aa ) // 2 ) : <NEWLINE> <INDENT> try : <NEWLINE> <COMMENT> <NL> <INDENT> ret = max ( ret , bb [ i ] - bb [ i + 3 ] + sum1 + aa [ i + 3 ] ) <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> 0 <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> for i in range ( 0 , len ( aa ) // 2 ) : <NEWLINE> <INDENT> try : <NEWLINE> <COMMENT> <NL> <INDENT> ret = max ( ret , bb [ 2 * i + 1 ] - bb [ 2 * i + 4 ] + sum0 + aa [ 2 * i + 4 ] ) <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> 0 <NEWLINE> <DEDENT> <DEDENT> print ( ret ) <NEWLINE>
a , b , c = ( int , input ( ) . split ( ) ) <NEWLINE> print ( c , a , b ) <NEWLINE>
import sys <NEWLINE> <NL> <NL> if __name__ == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
x , y , z = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( z x y ) <NEWLINE>
import sys <NEWLINE> <NL> read = sys . stdin . buffer . read <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> readlines = sys . stdin . buffer . readlines <NEWLINE> <NL> X , Y , Z = map ( int , readline ( ) ) <NEWLINE> <NL> A , B , C = Z , X , Y <NEWLINE> <NL> print ( A , B , C ) <NEWLINE>
import sys <NEWLINE> readline = sys . stdin . readline ( ) <NEWLINE> A , B , C = map ( int , readline ( ) . split ( ) ) <NEWLINE> print ( C , A , B ) <NEWLINE>
x , y , z = list ( map ( int , input ( ) ) ) <NEWLINE> x , y = y , x <NEWLINE> x , z = z , x <NEWLINE> print ( x , y , z ) <NEWLINE>
X , Y , Z = map ( int , input ( ) ) <NEWLINE> print ( str ( Z ) + <STRING> + str ( X ) + <STRING> + str ( Y ) ) <NEWLINE>
<INDENT> = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <DEDENT> m = [ ] <NEWLINE> for i in range ( 2 ) : <NEWLINE> <INDENT> m . append ( n [ i ] ) <NEWLINE> n . pop ( i ) <NEWLINE> n . append ( m [ i ] ) <NEWLINE> <NL> <DEDENT> for i in range ( 3 ) : <NEWLINE> <INDENT> print ( str ( n [ i ] ) + <STRING> , end = <STRING> ) <NEWLINE> <DEDENT>
x , y , z = map ( int , input ( ) . splilt ( ) ) <NEWLINE> t = 0 <NEWLINE> t = x ; x = y ; y = t ; <NEWLINE> t = x ; x = z ; z = t ; <NEWLINE> print ( x , y , z ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> x = [ n - k * i for i in range ( n // k + 2 ) ] <NEWLINE> x [ - 1 ] = abs ( x [ - 1 ] ) <NEWLINE> print ( min ( x ) ) <NEWLINE>
N , K = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> if abs ( N ) % K == 0 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> M = abs ( N ) % K <NEWLINE> S = abs ( M - K ) <NEWLINE> <DEDENT> print ( min ( M , S ) ) <NEWLINE>
x , y , z = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( z x y ) <NEWLINE>
X , Y , Z = int ( input ( ) . split ( ) ) <NEWLINE> print ( <STRING> . format ( Z , X , Y ) ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> a = int ( input ( ) ) <NEWLINE> <COMMENT> <NL> b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> <COMMENT> <NL> s = input ( ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> print ( <STRING> ) <NEWLINE>
x , y , z = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( z + <STRING> + x + <STRING> + y ) <NEWLINE>
x , y , z = map ( int , input ( ) . split ( ) ) : <NEWLINE> print ( z + <STRING> + x + <STRING> + y ) <NEWLINE>
x , y , z = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( z + <STRING> + x + <STRING> + y ) <NEWLINE>
A , B , C = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> A , B = B , A <NEWLINE> A , C = C , A <NEWLINE> print ( A , B , C ) A , B , C = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> A , B = B , A <NEWLINE> A , C = C , A <NEWLINE> print ( A , B , C ) <NEWLINE>
X , Y , Z = input ( ) <NEWLINE> print ( Z , X , Y ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> print ( b , a ) <NEWLINE>
x , y , z = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> a = z <NEWLINE> <NL> z = y <NEWLINE> y = x <NEWLINE> x = a <NEWLINE> <NL> print ( x y z ) <NEWLINE>
X = int ( input ( ) ) <NEWLINE> Y = int ( input ( ) ) <NEWLINE> Z = int ( input ( ) ) <NEWLINE> print ( Z , X , Y ) <NEWLINE>
A , B , C = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> print ( ( C , A , B ) . split ( ) ) <NEWLINE>
x , y , z = map ( input ( ) . split ( ) ) <NEWLINE> print ( z , y , x ) <NEWLINE>
num = input ( ) . split ( ) <NEWLINE> print ( num [ 2 , num [ 0 ] , num [ 1 ] ) <NEWLINE>
a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> a = b , b = a <NEWLINE> a = c , c = a <NEWLINE> print ( a b c ) <NEWLINE>
a = input ( ) <NEWLINE> b = input ( ) <NEWLINE> c = input ( ) <NEWLINE> d = int <NEWLINE> <NL> d = a <NEWLINE> a = b <NEWLINE> b = d <NEWLINE> d = c <NEWLINE> c = a <NEWLINE> a = d <NEWLINE> print ( a , b , c ) <NEWLINE>
A , B , C = X , Y , Z = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> A = Y <NEWLINE> B = X <NEWLINE> A = Z <NEWLINE> C = X <NEWLINE> <NL> print ( str ( A ) + <STRING> + str ( B ) + <STRING> + str ( C ) ) <NEWLINE>
x , y , z = map ( int , input ( ) . split ( ) ) <NEWLINE> li = [ z , x , y ] <NEWLINE> print ( <STRING> . join ( li ) ) <NEWLINE>
X , Y , Z = map ( int , input ( ) ) <NEWLINE> print ( Z , X , Y ) <NEWLINE>
a , b , c = map ( string , input ( ) . split ( ) ) <NEWLINE> print ( c + <STRING> + a + <STRING> + b ) <NEWLINE>
X , Y , Z = map ( int , input ( ) . sp ; split ( ) ) <NEWLINE> print ( Z , X , Y ) <NEWLINE>
a = input ( ) . split ( ) <NEWLINE> print ( a [ 3 ] + <STRING> + a [ 1 ] + <STRING> + a [ 2 ] ) <NEWLINE>
x = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( x [ 2 ] , x [ 0 ] , x [ 1 ] ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> def sa ( x ) : <NEWLINE> <INDENT> if x < 0 : <NEWLINE> <INDENT> return abs ( x ) <NEWLINE> <DEDENT> return abs ( sa ( x - k ) - k ) <NEWLINE> <DEDENT> print ( sa ( n ) ) <NEWLINE>
x , y , z = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( z + <STRING> + x + <STRING> + y ) <NEWLINE>
x , y , z = map ( int , input ( ) split ( ) ) <NEWLINE> print ( z , x , y ) <NEWLINE>
n , m = input ( ) . split ( ) n , m = input ( ) . split ( ) <NEWLINE> n = int ( n ) <NEWLINE> m = int ( m ) <NEWLINE> arr = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> minn = sum ( arr ) * ( 1 / ( 4 * m ) ) <NEWLINE> t = 0 <NEWLINE> for i in arr : <NEWLINE> <INDENT> if i >= minn : <NEWLINE> <INDENT> t += 1 <NEWLINE> <DEDENT> <DEDENT> if t >= m : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
, M = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> cnt = 0 <NEWLINE> th = sum ( A ) / ( 4 * M ) <NEWLINE> <NL> for i in range ( len ( A ) ) : <NEWLINE> <INDENT> if A [ i ] >= th : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> ans = <STRING> if cnt >= M else <STRING> <NEWLINE> print ( ans ) <NEWLINE>
n , m = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> sum = sum ( A ) <NEWLINE> for a in A : <NEWLINE> <INDENT> if a * 4 * m < sum : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> if cnt >= m : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
_ , m = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> cnt = 0 <NEWLINE> temp = sum ( a ) <NEWLINE> for v in a : <NEWLINE> <INDENT> if v >= a / ( 4 * m ) : cnt += 1 <NEWLINE> <DEDENT> if cnt >= m : print ( <STRING> ) <NEWLINE> else : print ( <STRING> ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> limit = sum ( a ) / ( 4 * m ) <NEWLINE> c = 0 <NEWLINE> for aa in a : <NEWLINE> <INDENT> if a >= limit : <NEWLINE> <INDENT> c += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> <DEDENT> if c == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> s = sum ( A ) <NEWLINE> A = sorted ( A ) <NEWLINE> ans = <STRING> <NEWLINE> for i in M : <NEWLINE> <INDENT> if A [ i ] < s / ( 4 * M ) : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = sorted ( a , reverse = <STRING> ) n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = [ 0 ] * n <NEWLINE> b = sorted ( a , reverse = True ) <NEWLINE> c = sum ( a ) <NEWLINE> if ( b [ m - 1 ] >= c / ( 4 * m ) ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ int ( input ( ) ) for i in range ( x ) ] <NEWLINE> T = sum ( A ) <NEWLINE> a = 0 <NEWLINE> for i in range ( x ) : <NEWLINE> <INDENT> if A [ i ] < 1 / ( 4 * T ) : <NEWLINE> <INDENT> a += 1 <NEWLINE> <DEDENT> <DEDENT> if a >= y : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , int , input ( ) ) ) <NEWLINE> k = sum ( a ) / ( 4 * m ) <NEWLINE> x = 0 <NEWLINE> for i in a : <NEWLINE> <INDENT> if a >= k : <NEWLINE> <INDENT> x += 1 <NEWLINE> <DEDENT> <DEDENT> if x >= m : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> def vote ( a , m ) : <NEWLINE> <INDENT> a . sort ( reverse = True ) <NEWLINE> if a [ m - 1 ] >= sum ( a ) / ( 4 * m ) : <NEWLINE> <INDENT> return True <NEWLINE> else : <NEWLINE> return False <NEWLINE> <NL> <DEDENT> <DEDENT> ans = <STRING> if vote ( A , M ) else <STRING> <NEWLINE> print ( ans ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> in_list = input ( ) . split <NEWLINE> vote_list = [ int ( i ) for i in in_list ] <NEWLINE> <NL> ans = 0 <NEWLINE> for ai in vote_list : <NEWLINE> <INDENT> if ai >= 1 / ( 4 * m ) * sum ( vote_list ) : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if ans < m : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b = map ( iNt , input ( ) . split ( ) ) <NEWLINE> c = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c = [ i for i in c if i > a / ( 4 * b ) ] <NEWLINE> if len ( c ) < b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> sum_a = sum ( a ) <NEWLINE> a = a . sort ( ) <NEWLINE> cnt = 0 <NEWLINE> for i in a : <NEWLINE> <INDENT> if i >= 1 / ( 4 * sum_a ) : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> if cnt >= M : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> list = [ int ( i ) for i input ( ) . split ( ) ] <NEWLINE> <NL> total = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if i >= ( sum ( list ) / ( 4 * M ) ) : <NEWLINE> <INDENT> total = total + 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if total >= M : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
mn = input ( ) . split ( ) <NEWLINE> ob = input ( ) . split ( ) <NEWLINE> <NL> n = int ( mn [ 0 ] ) <NEWLINE> m = int ( mn [ 1 ] ) <NEWLINE> <NL> votes = 0 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> ob [ i ] = int ( ob [ i ] ) <NEWLINE> votes += ob [ i ] <NEWLINE> <NL> <DEDENT> ob . sort ( reverse = true ) <NEWLINE> <NL> line = votes / 4 / m <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> for i in range ( m ) : <NEWLINE> <INDENT> if ob [ i ] <= line : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if ans == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import math <NEWLINE> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a . sort ( ) <NEWLINE> if a ( n - m ) < math . ceil ( sum ( a ) // ( 4 * m ) ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
<INDENT> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> S = sum ( A ) <NEWLINE> cnt = 0 <NEWLINE> for a in A : <NEWLINE> <INDENT> if a >= S / ( 4 * M ) : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> if cnt >= M : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = 0 <NEWLINE> C = 0 <NEWLINE> <NL> for i in range ( list ( A ) ) : <NEWLINE> <INDENT> c += A [ i ] <NEWLINE> <NL> <DEDENT> for i in range ( list ( A ) ) : <NEWLINE> <INDENT> if A [ i ] >= 1 / ( 4 * M ) : <NEWLINE> <INDENT> B += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if B >= M : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> b = sum ( a ) / 4 <NEWLINE> count = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if a [ i ] >= b : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if ans >= m : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> list = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> print ( <STRING> if list [ - 1 * M ] >= sum ( list ) / 4 M else ( <STRING> ) ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> a = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> a_list = [ ] <NEWLINE> for i in a [ : m ] : <NEWLINE> <INDENT> if sum ( a ) / ( a * m ) > i : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a_list . append ( i ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> A = deque ( sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) ) <NEWLINE> for a in A : <NEWLINE> <INDENT> if N / ( 4 * M ) > a : <NEWLINE> <INDENT> A . pop ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> if len ( A ) >= M else <STRING> ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ) ) ) <NEWLINE> sum = 0 <NEWLINE> ans = <STRING> <NEWLINE> for i in range ( len ( A ) ) : <NEWLINE> <INDENT> sum += A [ i ] <NEWLINE> <DEDENT> judge = sum / ( 4 * M ) <NEWLINE> for i in ramge ( len ( A ) ) : <NEWLINE> <INDENT> if A [ i ] < judge : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> S = sum ( A ) <NEWLINE> cnt = 0 <NEWLINE> for a in A : <NEWLINE> <INDENT> if a >= S / ( 4 * M ) : <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> if cnt >= M : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> li = list ( map ( int , input ( ) . split ( ) ) <NEWLINE> ans = 0 <NEWLINE> aaa = soted ( li reverse = True ) <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> if aaa [ i ] * 4 m >= sum ( li ) : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> if ans == m : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT>
n , m = input ( ) . split ( ) <NEWLINE> n = int ( n ) <NEWLINE> m = int ( m ) <NEWLINE> c = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> c += a [ i ] <NEWLINE> <DEDENT> v = c / ( 4 * m ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a . sort ( reverse = True ) <NEWLINE> if a [ m - 1 ] < v : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
<NL> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> cnt = 0 <NEWLINE> <NL> for i in a : <NEWLINE> <INDENT> if ( s / ( 4 * m ) ) <= i : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> if cnt == m : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if cnt < m : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a_sort = a . sorted ( ) <NEWLINE> sum = 0 <NEWLINE> for i in a : <NEWLINE> <INDENT> sum += i <NEWLINE> <NL> <DEDENT> for j in ( 1 , m + 1 ) : <NEWLINE> <INDENT> if j <= 1 / ( 4 * m ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A = sorted ( A , reverse = True ) <NEWLINE> if A [ M - 1 ] < ( Sum ( A ) / ( 4 * M ) ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> a = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = 0 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> if a [ i ] >= sum ( a ) * ( 1 / ( 4 * m ) ) : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if ans >= m : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> import math <NEWLINE> import collections <NEWLINE> import fractions <NEWLINE> import itertools <NEWLINE> <NL> def mput ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def lput ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> def iput ( ) : return int ( input ( ) ) <NEWLINE> <NL> def solve ( ) : <NEWLINE> <INDENT> n , m = mput ( ) <NEWLINE> a = lput ( ) <NEWLINE> line = sum ( A ) / ( 4 * m ) <NEWLINE> bit = 0 <NEWLINE> for i in a : <NEWLINE> <INDENT> if i >= line : <NEWLINE> <INDENT> bit += 1 <NEWLINE> <DEDENT> <DEDENT> if bit >= m : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> return 0 <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> solve ( ) <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> all_sum = sum ( a ) <NEWLINE> standard = all_sum / ( 4 * M ) <NEWLINE> ans = 0 <NEWLINE> <NL> for i in a : <NEWLINE> <INDENT> if i >= standard : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if ans >= m : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> N = N % K <NEWLINE> min_num = 0 <NEWLINE> while True : <NEWLINE> <INDENT> if ( N == 0 ) : <NEWLINE> <INDENT> min_num = N <NEWLINE> break <NEWLINE> <DEDENT> elif N in history : <NEWLINE> <INDENT> min_num = min ( history ) <NEWLINE> break <NEWLINE> <DEDENT> history . append ( N ) <NEWLINE> N = abs ( N - K ) <NEWLINE> <NL> <DEDENT> print ( min_num ) <NEWLINE> <NL> <NL>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> def main ( ) : <NEWLINE> <NL> <INDENT> N = int ( input ( ) ) <NEWLINE> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> L = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N , K = int ( input ( ) ) <NEWLINE> <NL> while N <= int ( K / 2 ) : <NEWLINE> <INDENT> N = min ( [ abs ( N - K ) , N % K ] ) <NEWLINE> <NL> <DEDENT> print ( N ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> x = N % K <NEWLINE> <NL> print ( min ( x , abs ( x - K ) ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> n = n % k <NEWLINE> print ( min ( abs ( n - k ) ) , n ) <NEWLINE>
from ctypes import c_longlong as ll <NEWLINE> <NL> n = ll ( input ( <STRING> ) ) <NEWLINE> m = ll ( input ( <STRING> ) ) <NEWLINE> n = n % m <NEWLINE> print ( min ( n , m - n ) ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> <COMMENT> <NL> num = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <COMMENT> <NL> num = sorted ( num , reverse = True ) <NEWLINE> <COMMENT> <NL> sum_num = sum ( num ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> if num [ m - 1 ] < sum_num / ( 4 * m ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = 0 <NEWLINE> n %= m <NEWLINE> ans = ( min ( n , ( m - n ) ) <NEWLINE> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> print ( min ( N % K , K - N % K ) ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> x1 = n % k <NEWLINE> x2 = k - x1 <NEWLINE> print ( min [ x1 , x2 ] ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( min [ N % K , K - N % K ] ) <NEWLINE>
import sys <NEWLINE> n , k = map ( int , sys . stdin . buffer . read ( ) . split ( ) ) <NEWLINE> rem = n % k <NEWLINE> print ( min ( rem , k - rem ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> print ( min ( N % K , K - t ) ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = 10e20 <NEWLINE> if n % k == 0 : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> while ans >= n : <NEWLINE> <INDENT> ans = abs ( n - k ) <NEWLINE> n = abs ( n - k ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( <STRING> ) ) <NEWLINE> k = int ( input ( <STRING> ) ) <NEWLINE> s = n % k <NEWLINE> ss = k - s <NEWLINE> if ( s < ss ) : <NEWLINE> <INDENT> print ( s ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ss ) <NEWLINE> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> N = N % K <NEWLINE> <NL> print ( min ( N , abs ( N - K ) ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> num = sum ( a ) <NEWLINE> cnt = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if a [ i ] < num / ( 4 * m ) : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> if cnt >= m : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
ans = 0 <NEWLINE> for i in range ( 1000000000000000000 ) : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> from fractions import gcd <NEWLINE> from itertools import combinations , permutations , accumulate , product <COMMENT> <NEWLINE> <COMMENT> <NL> from collections import deque , defaultdict , Counter <NEWLINE> import decimal <NEWLINE> import re <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> import sys <NEWLINE> sys . setrecursionlimit ( 10000000 ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <COMMENT> <NL> def readInts ( ) : <NEWLINE> <INDENT> return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <DEDENT> def I ( ) : <NEWLINE> <INDENT> return int ( input ( ) ) <NEWLINE> <DEDENT> dic = defaultdict ( int ) <NEWLINE> n , k = readInts ( ) <NEWLINE> if k == 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> elif n == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> elif n == 1 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> while True : <NEWLINE> <INDENT> if dic [ n ] : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dic [ n ] = 1 <NEWLINE> n = abs ( n - k ) <NEWLINE> <DEDENT> <DEDENT> m = float ( <STRING> ) <NEWLINE> for k , v in dic . items ( ) : <NEWLINE> <INDENT> m = min ( m , k ) <NEWLINE> <DEDENT> print ( m ) <NEWLINE> <DEDENT>
import numpy <NEWLINE> n = numpy . int64 ( n ) <NEWLINE> m = numpy . int64 ( m ) <NEWLINE> n = n % m <NEWLINE> print ( min ( n , m - n ) ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> s = n % k <NEWLINE> print ( min ( s , abs ( k - s ) ) <NEWLINE>
n , k = map ( int , input ( ) split ( ) ) <NEWLINE> <NL> while True : <NEWLINE> <INDENT> x = n <NEWLINE> n = abs ( n - k ) <NEWLINE> if x == n : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> print ( n ) <NEWLINE> <NL> <DEDENT>
K = int ( input ( ) ) <NEWLINE> number = [ ] <NEWLINE> for i in range ( 3234566668 ) : <NEWLINE> <INDENT> k = str ( i ) <NEWLINE> if all ( [ abs ( int ( k [ j ] ) - int ( k [ j - 1 ] ) ) <= 1 for j in range ( 1 , len ( k ) ) ] ) : <NEWLINE> <INDENT> number . append ( k ) <NEWLINE> <DEDENT> <DEDENT> print ( number [ K ] ) <NEWLINE>
K = int ( input ( ) ) <NEWLINE> ANS = [ ] <NEWLINE> for i in range ( 1 , 10 ** 5 ) : <NEWLINE> <INDENT> LEN = len ( str ( i ) ) <NEWLINE> STR = str ( i ) <NEWLINE> if LEN == 1 : <NEWLINE> <INDENT> ANS += [ i ] <NEWLINE> <DEDENT> for k in range ( LEN - 1 ) : <NEWLINE> <INDENT> if abs ( int ( STR [ k ] ) - int ( STR [ k + 1 ] ) ) > 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if k == LEN - 2 : <NEWLINE> <INDENT> ANS += [ i ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> i = 10 ** 5 <NEWLINE> while i < 10 ** 7 : <NEWLINE> <INDENT> LEN = len ( str ( i ) ) <NEWLINE> STR = str ( i ) <NEWLINE> if LEN == 1 : <NEWLINE> <INDENT> ANS += [ i ] <NEWLINE> <DEDENT> for k in range ( LEN - 1 ) : <NEWLINE> <INDENT> if abs ( int ( STR [ k ] ) - int ( STR [ k + 1 ] ) ) > 1 : <NEWLINE> <INDENT> i += 10 * ( LEN - ( k + 2 ) ) <NEWLINE> break <NEWLINE> <DEDENT> if k == LEN - 2 : <NEWLINE> <INDENT> ANS += [ i ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> ans = ANS [ K - 1 ] <NEWLINE> print ( ans ) <NEWLINE>
k = int ( input ( ) ) <NEWLINE> stack = list ( range ( 1 , 10 ) ) <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> num = stack . pop ( 0 ) <NEWLINE> if ( m : = num % 10 ) == 0 : <NEWLINE> <INDENT> stack . append ( [ num * 10 + m , num * 10 + m + 1 ] ) <NEWLINE> <DEDENT> elif m == 9 : <NEWLINE> <INDENT> stack . append ( [ num * 1 + m - 1 , num * 10 + m ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> stack . append ( [ num * 10 + m - 1 , num * 10 + m , num * 10 + m + 1 ] ) <NEWLINE> <DEDENT> <DEDENT> print ( num ) <NEWLINE>
K = int ( input ( ) ) <NEWLINE> nums = [ i for i in range ( 1 , 10 ) ] <NEWLINE> for i in range ( K ) : <NEWLINE> <INDENT> a = nums . pop ( 0 ) <NEWLINE> if a % 10 != 0 : <NEWLINE> <INDENT> nums . append ( a * 10 + % 10 - 1 ) <NEWLINE> <NL> <DEDENT> nums . append ( a * 10 + a % 10 ) <NEWLINE> <NL> if a % 10 != 9 : <NEWLINE> <INDENT> nums . append ( a * 10 + a % 10 + 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( a ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> lst = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> s = 0 <NEWLINE> total = sum ( lst ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if lst [ i ] >= total / ( 4 * m ) : <NEWLINE> <INDENT> s += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if s >= m : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <NL> <DEDENT>
from collections import deque <NEWLINE> K = int ( input ( ) ) <NEWLINE> q = deque ( str ( i ) for i in range ( 1 , 10 ) ) <NEWLINE> cnt = 9 <NEWLINE> if K < 10 : <NEWLINE> <INDENT> print ( K ) ; return <NEWLINE> <DEDENT> while True : <NEWLINE> <INDENT> tmp = q . popleft ( ) <NEWLINE> las = int ( tmp [ - 1 ] ) <NEWLINE> for i in range ( las - 1 , las + 2 ) : <NEWLINE> <INDENT> if 0 <= i <= 9 : <NEWLINE> <INDENT> q . append ( tmp + str ( i ) ) <NEWLINE> cnt += 1 <NEWLINE> if cnt == K : <NEWLINE> <INDENT> print ( q . pop ( ) ) ; return <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT>
from collections import deque <NEWLINE> K = int ( input ( ) ) <NEWLINE> queue = deque ( [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 ] ) <NEWLINE> count = 1 <NEWLINE> while count <= K : <NEWLINE> <INDENT> num = queue . popleft ( ) <NEWLINE> if num % 10 != 0 : <NEWLINE> <INDENT> queue . append ( num * 10 + num % 10 - 1 ) <NEWLINE> <DEDENT> queue . append ( num * 10 + num % 10 ) <NEWLINE> if num % != 9 : <NEWLINE> <INDENT> queue . append ( num * 10 + num % 10 + 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( num ) <NEWLINE>
que = queue . Queue ( ) <NEWLINE> <NL> for i in range ( 1 , 10 ) : <NEWLINE> <INDENT> que . put ( i ) <NEWLINE> <NL> <DEDENT> for i in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> ans = que . get ( ) <NEWLINE> keta1 = ans % 10 <NEWLINE> if keta1 == 0 : <NEWLINE> <INDENT> append_list = [ ans * 10 , ans * 10 + 1 ] <NEWLINE> <DEDENT> elif keta1 == 9 : <NEWLINE> <INDENT> append_list = [ ans * 10 + 8 , ans * 10 + 9 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> append_list = [ ans * 10 + keta1 - 1 , ans * 10 + keta1 , ans * 10 + keta1 + 1 ] <NEWLINE> <DEDENT> for item in append_list : <NEWLINE> <INDENT> que . put ( item ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import itertools <NEWLINE> from collections import deque , defaultdict , Counter <NEWLINE> from itertools import accumulate <NEWLINE> import bisect <NEWLINE> from heapq import heappop , heappush , heapify <NEWLINE> import math <NEWLINE> from copy import deepcopy <NEWLINE> import queue <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> Mod = 1000000007 <NEWLINE> def sieve_of_eratosthenes ( n ) : <NEWLINE> <INDENT> if not isinstance ( n , int ) : <NEWLINE> <INDENT> raise TypeError ( <STRING> ) <NEWLINE> <DEDENT> if n < 2 : <NEWLINE> <INDENT> raise ValueError ( <STRING> ) <NEWLINE> <DEDENT> prime = [ 1 ] * ( n + 1 ) <NEWLINE> for i in range ( 2 , int ( math . sqrt ( n ) ) + 1 ) : <NEWLINE> <INDENT> if prime [ i ] == 1 : <NEWLINE> <INDENT> for j in range ( 2 * i , n + 1 ) : <NEWLINE> <INDENT> if j % i == 0 : <NEWLINE> <INDENT> prime [ j ] = 0 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> res = [ ] <NEWLINE> for i in range ( 2 , n + 1 ) : <NEWLINE> <INDENT> if prime [ i ] == 1 : <NEWLINE> <INDENT> res . append ( i ) <NEWLINE> <DEDENT> <DEDENT> return res <NEWLINE> <NL> <NL> <DEDENT> class UnionFind : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . parent = [ i for i in range ( n + 1 ) ] <NEWLINE> self . rank = [ 0 for i in range ( n + 1 ) ] <NEWLINE> <NL> <DEDENT> def findroot ( self , x ) : <NEWLINE> <INDENT> if x == self . parent [ x ] : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> y = self . parent [ x ] <NEWLINE> y = self . findroot ( self . parent [ x ] ) <NEWLINE> return y <NEWLINE> <NL> <DEDENT> <DEDENT> def union ( self , x , y ) : <NEWLINE> <INDENT> px = self . findroot ( x ) <NEWLINE> py = self . findroot ( y ) <NEWLINE> if px < py : <NEWLINE> <INDENT> self . parent [ y ] = px <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . parent [ px ] = py <NEWLINE> <NL> <DEDENT> <DEDENT> def same_group_or_no ( self , x , y ) : <NEWLINE> <INDENT> return self . findroot ( x ) == self . findroot ( y ) <NEWLINE> <NL> <DEDENT> <DEDENT> def main ( ) : <COMMENT> <NEWLINE> <INDENT> def divisor ( n ) : <NEWLINE> <INDENT> res = [ ] <NEWLINE> for i in range ( 1 , int ( np . sqrt ( n ) ) + 1 ) : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> res . append ( i ) <NEWLINE> j = n // i <NEWLINE> if j != i : res . append ( j ) <NEWLINE> <DEDENT> <DEDENT> res . sort ( reverse = True ) <NEWLINE> return res [ : : - 1 ] <NEWLINE> <DEDENT> n = int ( input ( ) ) <NEWLINE> div1 = divisor ( n - 1 ) <NEWLINE> div2 = divisor ( n ) <NEWLINE> ans = len ( div1 ) - 1 <NEWLINE> for d in div2 : <NEWLINE> <INDENT> if d == 1 : continue <NEWLINE> nn = n <NEWLINE> while nn % d == 0 : <NEWLINE> <INDENT> nn //= d <NEWLINE> <DEDENT> if nn % d == 1 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <COMMENT> <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> if n == 2 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> elif n == 3 : <NEWLINE> <INDENT> print ( 2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <COMMENT> <NL> <INDENT> print ( len ( make_divisors ( n - 1 ) ) + 1 ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> <NL> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> ABC = np . zeros ( ( N , 3 ) ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> ABC [ i ] [ 0 ] , ABC [ i ] [ 1 ] , ABC [ i ] [ 2 ] = map ( int , input ( ) . split ( ) ) <NEWLINE> <DEDENT> DEF = np . zeros ( ( M , 3 ) ) <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> DEF [ i ] [ 0 ] , DEF [ i ] [ 1 ] , DEF [ i ] [ 2 ] = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> x_co = { - 10 ** 9 - 1 , 10 ** 9 + 1 } <NEWLINE> y_co = { - 10 ** 9 - 1 , 10 ** 9 + 1 } <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> x_co . add ( ABC [ i ] [ 0 ] ) <NEWLINE> x_co . add ( ABC [ i ] [ 1 ] ) <NEWLINE> y_co . add ( ABC [ i ] [ 2 ] ) <NEWLINE> <DEDENT> for i in range ( M ) : <NEWLINE> <INDENT> x_co . add ( DEF [ i ] [ 0 ] ) <NEWLINE> y_co . add ( DEF [ i ] [ 1 ] ) <NEWLINE> y_co . add ( DEF [ i ] [ 2 ] ) <NEWLINE> <NL> <DEDENT> x_co = np . array ( sorted ( list ( x_co ) ) ) <NEWLINE> y_co = np . array ( sorted ( list ( y_co ) ) ) <NEWLINE> xL = len ( x_co ) - 1 <NEWLINE> yL = len ( y_co ) - 1 <NEWLINE> x_co_d = { x_co [ i ] : i for i in range ( xL + 1 ) } <NEWLINE> y_co_d = { y_co [ i ] : i for i in range ( yL + 1 ) } <NEWLINE> <NL> <COMMENT> <NL> s_ex_tate = np . zeros ( ( yL + 1 , xL ) ) <NEWLINE> s_ex_yoko = np . zeros ( ( xL + 1 , yL ) ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> a = x_co_d [ ABC [ i ] [ 0 ] ] <NEWLINE> b = x_co_d [ ABC [ i ] [ 1 ] ] <NEWLINE> c = y_co_d [ ABC [ i ] [ 2 ] ] <NEWLINE> s_ex_tate [ c ] [ a : b ] = 1 <NEWLINE> <DEDENT> for i in range ( M ) : <NEWLINE> <INDENT> d = x_co_d [ DEF [ i ] [ 0 ] ] <NEWLINE> e = y_co_d [ DEF [ i ] [ 1 ] ] <NEWLINE> f = y_co_d [ DEF [ i ] [ 2 ] ] <NEWLINE> s_ex_yoko [ d ] [ e : f ] = 1 <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> for i in range ( xL ) : <NEWLINE> <INDENT> if x_co [ i + 1 ] > 0 : <NEWLINE> <INDENT> xf = [ i ] <NEWLINE> break <NEWLINE> <DEDENT> if x_co [ i + 1 ] == 0 : <NEWLINE> <INDENT> xf = [ i , i + 1 ] <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> for i in range ( yL ) : <NEWLINE> <INDENT> if y_co [ i + 1 ] > 0 : <NEWLINE> <INDENT> yf = [ i ] <NEWLINE> break <NEWLINE> <DEDENT> if y_co [ i + 1 ] == 0 : <NEWLINE> <INDENT> yf = [ i , i + 1 ] <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> def sq ( x , y ) : <NEWLINE> <INDENT> return int ( ( x_co [ x + 1 ] - x_co [ x ] ) * ( y_co [ y + 1 ] - y_co [ y ] ) ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> Q = [ ] <NEWLINE> <COMMENT> <NL> houmon = np . zeros ( ( xL , yL ) ) <NEWLINE> ans = 0 <NEWLINE> is_inf = False <NEWLINE> for x in xf : <NEWLINE> <INDENT> for y in yf : <NEWLINE> <INDENT> houmon [ x ] [ y ] = 1 <NEWLINE> Q . append ( ( x , y ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> while Q : <NEWLINE> <INDENT> x , y = Q . pop ( ) <NEWLINE> if x in [ 0 , xL - 1 ] or y in [ 0 , yL - 1 ] : <NEWLINE> <INDENT> is_inf = True <NEWLINE> break <NEWLINE> <DEDENT> ans += sq ( x , y ) <NEWLINE> if ( not houmon [ x - 1 ] [ y ] ) and ( not s_ex_yoko [ x ] [ y ] ) : <NEWLINE> <INDENT> houmon [ x - 1 ] [ y ] = True <NEWLINE> Q . append ( ( x - 1 , y ) ) <NEWLINE> <DEDENT> if ( not houmon [ x ] [ y - 1 ] ) and ( not s_ex_tate [ y ] [ x ] ) : <NEWLINE> <INDENT> houmon [ x ] [ y - 1 ] = True <NEWLINE> Q . append ( ( x , y - 1 ) ) <NEWLINE> <DEDENT> if ( not houmon [ x + 1 ] [ y ] ) and ( not s_ex_yoko [ x + 1 ] [ y ] ) : <NEWLINE> <INDENT> houmon [ x + 1 ] [ y ] = True <NEWLINE> Q . append ( ( x + 1 , y ) ) <NEWLINE> <DEDENT> if ( not houmon [ x ] [ y + 1 ] ) and ( not s_ex_tate [ y + 1 ] [ x ] ) : <NEWLINE> <INDENT> houmon [ x ] [ y + 1 ] = True <NEWLINE> Q . append ( ( x , y + 1 ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> if is_inf : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
import math <NEWLINE> def prime_factorize ( n ) : <NEWLINE> <INDENT> a = [ n ] <NEWLINE> for i in range ( 2 , math . floor ( n ** 0.5 ) + 1 ) : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> a . append ( i ) <NEWLINE> if n // i != i : <NEWLINE> <INDENT> a . append ( n // i ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return a <NEWLINE> <NL> <DEDENT> N = int ( input ( ) ) <NEWLINE> prime_n = prime_factorize ( N ) <NEWLINE> prime_n_1 = prime_factorize ( N - 1 ) <NEWLINE> <NL> ans = 0 <NEWLINE> for i in prime_n : <NEWLINE> <INDENT> n = copy . deepcopy ( N ) <NEWLINE> while ( n % i ) == 0 : <NEWLINE> <INDENT> n = n // i <NEWLINE> <DEDENT> if ( n % i ) == 1 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> ans += len ( prime_n_1 ) <NEWLINE> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> ans = set ( ) <NEWLINE> <NL> def check ( N , k ) : <NEWLINE> <INDENT> if k < 2 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> N //= k <NEWLINE> while N : <NEWLINE> <INDENT> if ( N - 1 ) % k == 0 : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> if N % k : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> N //= k <NEWLINE> <NL> <DEDENT> <DEDENT> for k in range ( 1 , int ( N ** 0.5 ) + 1 ) : <NEWLINE> <INDENT> if ( N - 1 ) % k == 0 : <NEWLINE> <INDENT> ans . add ( k ) <NEWLINE> ans . add ( ( N - 1 ) // k ) <NEWLINE> <DEDENT> if N % k == 0 : <NEWLINE> <INDENT> if check ( N , k ) : <NEWLINE> <INDENT> ans . add ( k1 ) <NEWLINE> <DEDENT> if check ( N , N // k ) : <NEWLINE> <INDENT> ans . add ( k2 ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> ans . remove ( 1 ) <NEWLINE> print ( len ( ans ) ) <NEWLINE>
coffee = str ( input ( ) ) <NEWLINE> iff3 = coffee [ 3 ] <NEWLINE> iff4 = coffee [ 4 ] <NEWLINE> iff5 = coffee [ 5 ] <NEWLINE> iff6 = coffee [ 6 ] <NEWLINE> if iff3 == iff4 : <NEWLINE> <INDENT> if iff5 == iff6 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> if iff5 != iff6 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> if iff3 != iff4 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> S = input ( ) . split ( ) <NEWLINE> if S [ 2 ] == S [ 3 ] and S [ 4 ] == S [ 5 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s = list ( map ( str , input ( ) . split ( ) ) ) <NEWLINE> if s [ 2 ] == s [ 3 ] and s [ 4 ] == s [ 5 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
S = input ( ) <NEWLINE> if S [ 2 ] == S [ 3 ] andS [ 4 ] == S [ 5 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
S = input ( ) <NEWLINE> if S [ 2 ] == S [ 3 ] and S [ 4 ] == S [ 5 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> if s [ 2 ] == s [ 3 ] & & s [ 4 ] == s [ 5 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> ans = <STRING> <NEWLINE> <NL> if s [ 2 ] == s [ 3 ] & & s [ 4 ] == s [ 5 ] : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
s = int ( input ( ) ) <NEWLINE> if s [ 2 ] == s [ 3 ] and s [ 4 ] == s [ 5 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = input ( ) <NEWLINE> if s [ 2 ] == s [ 3 ] and s [ 4 ] == s [ 5 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = input ( ) <NEWLINE> if N [ 2 ] == N [ 3 ] : and N [ 4 ] == N [ 5 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> <NL> if s [ 2 ] == s [ 3 ] ans s [ 4 ] == s [ 5 ] : print ( <STRING> ) <NEWLINE> else : print ( <STRING> ) <NEWLINE>
S = input ( ) <NEWLINE> <NL> if S [ 2 ] == S [ 3 ] andS [ 4 ] == S [ 5 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> if ( s [ 2 ] != s [ 3 ] | | s [ 4 ] != s [ 5 ] ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b , c , d , e , f = input ( ) <NEWLINE> if c == d and e == f : <NEWLINE> <INDENT> print ( <NEWLINE> <DEDENT>
S = int ( input ( ) ) <NEWLINE> <NL> check = S [ 2 ] == S [ 3 ] and S [ 4 ] == S [ 5 ] <NEWLINE> <NL> print ( <STRING> if check else <STRING> ) <NEWLINE>
s = list ( input ( ) ) <NEWLINE> <NL> if s [ 2 ] == s [ 3 ] & s [ 4 ] == s [ 5 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> if ( s [ 2 ] == s [ 3 ] & & s [ 4 ] == s [ 5 ] ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s = input ( ) . split ( ) <NEWLINE> if s [ 2 ] == s [ 3 ] and s [ 4 ] == s [ 5 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
cof = input ( ) <NEWLINE> if cof [ 2 ] == cof [ 3 ] & cof [ 4 ] == cof [ 5 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s = list [ input ( ) ] <NEWLINE> if s [ 2 ] == s [ 3 ] and s [ 4 ] == s [ 5 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a = list . input ( ) <NEWLINE> <NL> if a [ 2 ] == a [ 3 ] and a [ 4 ] == a [ 5 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
x = input ( ) <NEWLINE> a = x // 500 * 1000 <NEWLINE> b = x % 500 // 5 * 5 <NEWLINE> print ( a + b ) <NEWLINE>
x = int ( input ( ) ) <NEWLINE> i = 0 <NEWLINE> u = 0 <NEWLINE> while 500 >= x : <NEWLINE> <INDENT> x -= 500 <NEWLINE> i += 1 <NEWLINE> <DEDENT> while >= 5 : <NEWLINE> <INDENT> x -= 5 <NEWLINE> u += 1 <NEWLINE> <DEDENT> print ( 5 * i + u ) <NEWLINE>
x = input ( ) <NEWLINE> <NL> print ( x // 500 + x % 500 // 5 * 5 ) <NEWLINE>
def atc_160b ( X : int ) -> int : <NEWLINE> <INDENT> return X // 500 * 1000 + X % 500 // 5 * 5 <NEWLINE> <NL> <DEDENT> X_input = input ( ) <NEWLINE> print ( atc_160b ( X_input ) ) <NEWLINE>
x = input ( int ( ) ) <NEWLINE> a = x // 500 <NEWLINE> b = ( x % 500 ) // 5 <NEWLINE> h = a * 1000 + b * 5 <NEWLINE> print ( h ) <NEWLINE>
x = int ( input ( ) ) <NEWLINE> glad = x // * 1000 + x % 500 // 5 * 5 <NEWLINE> print ( glad ) <NEWLINE>
money = int ( input ( ) ) <NEWLINE> <NL> gohyakuen = money // 500 <NEWLINE> <NL> goen = ( money - ( gohyaken * 500 ) ) // 5 <NEWLINE> <NL> happy = 1000 * gohyakuen + 5 * goen <NEWLINE> <NL> print ( happy ) <NEWLINE>
x = int ( input ( ) ) <NEWLINE> print ( 1000 * ( n // 500 ) + 5 * ( ( n // 500 ) // 5 ) ) <NEWLINE>
yen = int ( input ( ) ) <NEWLINE> <STRING> <NEWLINE> happy = 1000 * int ( yen // 500 ) + 5 * int ( ( yen - ( 500 * int ( yen // 500 ) ) ) // 5 ) <NEWLINE> <NL> print ( hap ) py ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> div , mod = divmod ( N , 5000 ) <NEWLINE> div2 = ( mod , 5 ) <NEWLINE> print ( 5000 * div + 5 * div2 ) <NEWLINE>
x = int ( input ( ) ) <NEWLINE> <NL> if n != 0 : <NEWLINE> <INDENT> ans1 = n // 500 <NEWLINE> sub = n - ( ans1 * 500 ) <NEWLINE> ans2 = sub // 5 <NEWLINE> <NL> print ( ( ans1 * 1000 ) + ( ans2 * 5 ) ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT>
five_hundred = int ( X / 500 ) <NEWLINE> five = int ( ( X - five_hundred * 500 ) / 5 ) <NEWLINE> print ( five_hundred * 1000 + five * 5 ) <NEWLINE>
x = int ( input ( ) ) <NEWLINE> ( a , b ) = divmod ( x / 500 ) <NEWLINE> print ( a * 1000 + b // 5 * 5 ) <NEWLINE>
n = input ( ) <NEWLINE> k = n % 500 <NEWLINE> n -= k * 500 <NEWLINE> n //= 5 <NEWLINE> print ( k * 1000 + n * 5 ) <NEWLINE>
x = input ( ) <NEWLINE> print ( ( ( x // 500 ) * 1000 ) + ( ( x % 500 // 5 ) * 5 ) ) <NEWLINE>
x = int ( input ( ) ) <NEWLINE> <NL> a = x // 500 <NEWLINE> b = x - ( a * 500 ) <NEWLINE> c = b // 5 <NEWLINE> print ( sum ( ( a * 1000 ) + ( c * 5 ) ) ) <NEWLINE>
K , N = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> temp = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> tmep += min ( A [ i ] , K - A [ i ] ) <NEWLINE> <DEDENT> print ( min ( A [ - 1 ] - A [ 0 ] , temp ) <NEWLINE>
A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> <NL> A = sorted ( A ) <NEWLINE> L = [ ] <NEWLINE> ANS = 0 <NEWLINE> <NL> A_max = max ( A ) <NEWLINE> <NL> for i in range ( N - 1 ) : <NEWLINE> <INDENT> L . append ( abs ( A [ i + 1 ] - A [ i ] ) ) <NEWLINE> <NL> <DEDENT> L . append ( K + A [ 0 ] - A_max ) <NEWLINE> <NL> L = sorted ( L ) <NEWLINE> <NL> <NL> L . pop ( - 1 ) <NEWLINE> <NL> for i in range ( len ( L ) ) : <NEWLINE> <INDENT> ANS = ANS + L [ i ] <NEWLINE> <NL> <DEDENT> print ( ANS ) <NEWLINE>
k , n = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = [ ] <NEWLINE> <NL> for i in range ( 1 , n ) : <NEWLINE> <INDENT> b . append ( a [ i ] - a [ i - 1 ] ) <NEWLINE> <DEDENT> b . append ( k - a [ n - 1 ] + a [ 0 ] ) <NEWLINE> <NL> b . sorted ( b ) <NEWLINE> <NL> print ( sum ( b [ : - 1 ] ) ) <NEWLINE>
K , N = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> A = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> <NL> c = A [ 0 ] + ( K - A [ N - 1 ] ) <NEWLINE> <NL> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> d = max ( c , A [ i ] - A [ i - 1 ] ) <NEWLINE> <NL> <DEDENT> print ( K - d ) <NEWLINE>
k , n = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if a [ i ] >= k / 2 <NEWLINE> <INDENT> a [ i ] = a [ i ] - k <NEWLINE> <DEDENT> <DEDENT> print ( max ( a ) - min ( a ) ) <NEWLINE>
k , n = ( int ( i ) for i in input ( ) . split ( ) ) <NEWLINE> st [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> st = sorted ( st ) <NEWLINE> st . append ( st [ 0 ] + k ) <NEWLINE> <NL> diffs = [ st [ i + 1 ] - st [ i ] for i in range ( n ) ] <NEWLINE> <NL> print ( k - max ( diffs ) ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> for x in range ( n - 1 ) : <NEWLINE> <INDENT> b = a [ x + 1 ] - a [ x ] <NEWLINE> ans = max ( ans , b ) <NEWLINE> <NL> <DEDENT> c = k - a [ n - 1 ] + a [ 0 ] <NEWLINE> <NL> print ( max ( ans , c ) ) <NEWLINE>
K , N = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int ( input ( ) . split ( ) ) ) ) <NEWLINE> <NL> K . append ( A [ 0 ] + K ) <NEWLINE> l = K + 1 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> l = min ( l , A [ i + 1 ] - A [ i ] ) <NEWLINE> <NL> <DEDENT> print ( K - l ) <NEWLINE>
k , n = map ( int ( input ( ) . split ( ) ) ) <NEWLINE> al = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> dtlst = [ al [ 0 ] ] <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> dtlst . append ( al [ i ] - al [ i - 1 ] ) <NEWLINE> <DEDENT> dtlst . append ( k - al [ - 1 ] + al [ 0 ] ) <NEWLINE> <NL> print ( k - max ( dtlst ) ) <NEWLINE>
K , N = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> A = list ( [ int ( x ) for x in input ( ) . split ( ) ] ) <NEWLINE> <NL> result = [ ] <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> if i == N - 1 : <NEWLINE> <INDENT> result . append ( K - A [ i ] + A [ 0 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> result . appnd ( A [ i + 1 ] - A [ i ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> result . sort ( ) <NEWLINE> <NL> print ( sum ( result [ : - 1 ] ) ) <NEWLINE>
k , n = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> a = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> <NL> c = a [ 0 ] + ( k - a [ n - 1 ] ) <NEWLINE> <NL> d = max ( c , [ a [ i ] - a [ i - 1 ] for i in range ( 1 , n ) ] ) <NEWLINE> <NL> print ( k - d ) <NEWLINE>
import numpy as np <NEWLINE> K , N = map ( int , input ( ) . split ( ) ) <NEWLINE> A = input ( ) . split ( ) <NEWLINE> diff = np . append ( np . array ( A [ 1 : ] ) - np . array ( A [ : - 1 ] ) , K - A [ - 1 ] ) <NEWLINE> diff = np . delete ( diff , np . argmax ( diff ) ) <NEWLINE> print ( diff . sum ( ) ) <NEWLINE>
k , n = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = [ ] <NEWLINE> <NL> for i in ( 1 , n ) : <NEWLINE> <INDENT> b . append ( a [ i ] - a [ i - 1 ] ) <NEWLINE> <DEDENT> b . append ( k - a [ n - 1 ] + a [ 0 ] ) <NEWLINE> b = sorted ( b ) <NEWLINE> <NL> print ( sum ( b [ : - 1 ] ) ) <NEWLINE>
k , n = map ( int , input ( ) . spliut ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = a [ 0 ] + ( k - a [ - 1 ] ) <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> ans = max ( ans , a [ i + 1 ] - a [ i ] ) <NEWLINE> <DEDENT> print ( k - ans ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> g = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> tmp = a [ i + 1 ] - a [ i ] <NEWLINE> if tmp > g : <NEWLINE> <INDENT> g = tmp <NEWLINE> <NL> <DEDENT> <DEDENT> print ( k - g ) <NEWLINE>
k , n = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 10 ** 6 + 1 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ans = min ( a [ - 1 ] - a [ i ] ) <NEWLINE> a . append ( a [ i ] + k ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> L = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( M ) ] <NEWLINE> dict = { } <NEWLINE> <NL> if M == 0 : <NEWLINE> <INDENT> if N == 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 10 ** ( N - 1 ) ) <NEWLINE> <DEDENT> exit ( ) <NEWLINE> <NL> <DEDENT> for x in L : <NEWLINE> <INDENT> dict . setdefault ( x [ 0 ] , [ ] ) <NEWLINE> dict [ x [ 0 ] ] . append ( x [ 1 ] ) <NEWLINE> <DEDENT> dict . setdefault ( 1 , [ 1 ] ) <NEWLINE> <NL> for k , v in dict . items ( ) : <NEWLINE> <INDENT> dict [ k ] = set ( v ) <NEWLINE> <NL> <DEDENT> ansList = [ <STRING> ] * N <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if i + 1 in dict : <NEWLINE> <INDENT> ansList [ i ] = str ( list ( dict [ i + 1 ] ) [ 0 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> isZeroHead = 2 <= N and ansList [ 0 ] == <STRING> <NEWLINE> isOverlapping = any ( [ 2 <= len ( v ) for v in dict . values ( ) ] ) <NEWLINE> ans = - 1 if isZeroHead or isOverlapping else int ( <STRING> . join ( ansList ) ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> print ( ans ) <NEWLINE>
k , n = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) + [ k + a [ 0 ] ] <NEWLINE> print ( k - max ( [ a [ i + 1 ] - a [ i ] for i in range ( n ) ] ) ) <NEWLINE>
k , n = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a . append ( k + a [ 0 ] ) <NEWLINE> <NL> for i in range ( 1 , n ) : <NEWLINE> <INDENT> l = max ( a [ i ] - a [ i - 1 ] ) <NEWLINE> <NL> <DEDENT> print ( k - l ) <NEWLINE>
k , n = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = [ ] <NEWLINE> <NL> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> b . append ( a [ i ] - a [ i - 1 ] ) <NEWLINE> <DEDENT> b . append ( k - a [ n ] + a [ 0 ] ) <NEWLINE> b = sorted ( b ) <NEWLINE> <NL> print ( sum ( b [ : n - 1 ] ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> x = 0 <NEWLINE> a = [ ] <NEWLINE> for i in range ( 2 , N , 2 ) : <NEWLINE> <INDENT> while i % 2 == 0 : <NEWLINE> <INDENT> i //= 2 <NEWLINE> x += 1 <NEWLINE> <DEDENT> a . append ( x ) <NEWLINE> x = 0 <NEWLINE> <DEDENT> a = sorted ( a ) <NEWLINE> a = a [ : : - 1 ] <NEWLINE> print ( a [ 0 ] ) <NEWLINE>
k , n = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> a = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> <NL> b = a [ 0 ] + ( k - a [ n - 1 ] ) <NEWLINE> <NL> c = [ a [ i ] - a [ i - 1 ] for i in range ( 1 , n ) ] <NEWLINE> <NL> d = max ( b , c ) <NEWLINE> <NL> print ( d ) <NEWLINE>
k , n = map ( int , input ( ) . split ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> diff = [ ] <NEWLINE> l . append ( l [ 0 ] + k ) <NEWLINE> <NL> for i in range ( n - 1 ) : <NEWLINE> <INDENT> diff . append ( l [ n + 1 ] - l [ n ] ) <NEWLINE> <NL> <DEDENT> print ( sum ( diff ) - max ( diff ) ) <NEWLINE>
K , N = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> l = [ ] <NEWLINE> p = A [ - 1 ] - K <NEWLINE> for a in A : <NEWLINE> <INDENT> l . append ( a - l ) <NEWLINE> p = a <NEWLINE> <DEDENT> print ( sum ( l ) - max ( l ) ) <NEWLINE>
k , n = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> Ai = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> kyori = [ ] <NEWLINE> <NL> for x in range ( n - 1 ) : <NEWLINE> <INDENT> kyori . append ( Ai [ x + 1 ] - Ai [ x ] ) <NEWLINE> <NL> <DEDENT> kyori . append ( Ai [ 0 ] + k - Ai [ n - 1 ] ) <NEWLINE> <NL> kyoto . remove ( max ( kyori ) ) <NEWLINE> <NL> print ( sum ( kyori ) ) <NEWLINE>
from numba . np . ufunc import parallel <NEWLINE> from numba import njit , prange <NEWLINE> <NL> <NL> @ njit ( cache = True , parallel = True ) <NEWLINE> def solve ( n , x , y ) : <NEWLINE> <INDENT> ans = [ 0 ] * ( n - 1 ) <NEWLINE> for i in prange ( n ) : <NEWLINE> <INDENT> for j in prange ( n ) : <NEWLINE> <INDENT> c = min ( abs ( i - j ) , abs ( i - x ) + abs ( j - y ) + 1 , abs ( i - y ) + abs ( j - x ) + 1 ) <NEWLINE> if c : <NEWLINE> <INDENT> ans [ c - 1 ] += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return ans <NEWLINE> <NL> <NL> <DEDENT> n , x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> x -= 1 <NEWLINE> y -= 1 <NEWLINE> ans = solve ( n , x , y ) <NEWLINE> for ai in ans : <NEWLINE> <INDENT> print ( ai // 2 ) <NEWLINE> <DEDENT>
from collections import deque <NEWLINE> from collections import Counter <NEWLINE> N , X , Y = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> res = deque ( ) <NEWLINE> <NL> for x in range ( 1 , N ) : <NEWLINE> <INDENT> for y in range ( x + 1 , N + 1 ) : <NEWLINE> <INDENT> res . append ( min ( [ abs ( x - y ) , 1 + abs ( X - x ) + abs ( Y - y ) ) ) <NEWLINE> <DEDENT> <DEDENT> resd = Counter ( res ) <NEWLINE> <NL> for i in range ( 1 , N ) : <NEWLINE> <INDENT> if i in resd . keys ( ) : <NEWLINE> <INDENT> print ( resd [ i ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> <DEDENT>
import numpy as np <NEWLINE> <NL> def solve ( N , X , Y ) : <NEWLINE> <INDENT> def bfs ( v ) : <NEWLINE> <INDENT> q = [ v ] <NEWLINE> Distance = [ - 1 ] * ( N + 1 ) <NEWLINE> Distance [ v ] = 0 <NEWLINE> distance = 1 <NEWLINE> while q : <NEWLINE> <INDENT> q_new = [ ] <NEWLINE> for v in q : <NEWLINE> <INDENT> u = v - 1 <NEWLINE> if u >= 1 and Distance [ u ] == - 1 : <NEWLINE> <INDENT> Distance [ u ] = distance <NEWLINE> q_new . append ( u ) <NEWLINE> <DEDENT> u = v + 1 <NEWLINE> if u <= N and Distance [ u ] == - 1 : <NEWLINE> <INDENT> Distance [ u ] = distance <NEWLINE> q_new . append ( u ) <NEWLINE> <DEDENT> if v == X : <NEWLINE> <INDENT> u = Y <NEWLINE> if Distance [ u ] == - 1 : <NEWLINE> <INDENT> Distance [ u ] = distance <NEWLINE> q_new . append ( u ) <NEWLINE> <DEDENT> <DEDENT> elif v == Y : <NEWLINE> <INDENT> u = X <NEWLINE> if Distance [ u ] == - 1 : <NEWLINE> <INDENT> Distance [ u ] = distance <NEWLINE> q_new . append ( u ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> distance += 1 <NEWLINE> q = q_new <NEWLINE> <DEDENT> return Distance <NEWLINE> <NL> <DEDENT> Ans = np . zeros ( N , dtype = np . int64 ) <NEWLINE> for v in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> Distance = bfs ( v ) <NEWLINE> for d in Distance [ v + 1 : ] : <NEWLINE> <INDENT> Ans [ d ] += 1 <NEWLINE> <DEDENT> <DEDENT> return Ans [ 1 : ] <NEWLINE> <NL> <DEDENT> numba_compile ( [ <NEWLINE> <INDENT> [ solve , <STRING> ] <NEWLINE> <DEDENT> ] ) <NEWLINE> <NL> N , X , Y = map ( int , input ( ) . split ( ) ) <NEWLINE> Ans = solve ( N , X , Y ) <NEWLINE> print ( <STRING> . join ( map ( str , Ans . tolist ( ) ) ) ) <NEWLINE>
n , x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> cnt_l = [ 0 ] * n <NEWLINE> from collections import deque <NEWLINE> <COMMENT> <NL> def bfs ( start ) : <NEWLINE> <INDENT> queue = deque ( ) <NEWLINE> queue . append ( start ) <NEWLINE> step_counts = [ - 1 ] * ( n + 1 ) <NEWLINE> step_counts [ start ] = 0 <NEWLINE> while ( queue ) : <NEWLINE> <INDENT> i = queue . popleft ( ) <NEWLINE> cnt = step_counts [ i ] <NEWLINE> <COMMENT> <NL> if ( i == x ) : <NEWLINE> <INDENT> nex_l = ( i - 1 , y , i + 1 ) <NEWLINE> elif ( i == y ) : <NEWLINE> <INDENT> nex_l = ( i - 1 , x , i + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> nex_l = ( i - 1 , i + 1 ) <NEWLINE> <NL> <DEDENT> cnt += 1 <NEWLINE> for j in nex_l : <NEWLINE> <COMMENT> <NL> <INDENT> if ( j < 1 or n < j ) : <NEWLINE> <INDENT> continue <NEWLINE> <COMMENT> <NL> if ( step_counts [ j ] != - 1 ) : <NEWLINE> <INDENT> continue <NEWLINE> queue . append ( j ) <NEWLINE> step_counts [ j ] = cnt <NEWLINE> cnt_l [ cnt ] += 1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> bfs ( i ) <NEWLINE> <NL> <DEDENT> for i in range ( 1 , n ) : <NEWLINE> <COMMENT> <NL> <INDENT> print ( cnt_l [ i ] // 2 ) <NEWLINE> <DEDENT>
N , X , Y = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> t = [ 0 ] * ( N - 1 ) <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> for j in range ( i + 1 , N + 1 ) : <NEWLINE> <INDENT> t [ min ( j - i , abs ( X - i ) + 1 + abs ( Y - j ) ) - 1 ] += 1 <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> print ( * result , sep = <STRING> ) <NEWLINE>
X , Y , A , B , C = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> C = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A . sort ( ) <NEWLINE> B . sort ( ) <NEWLINE> C . sort ( <NEWLINE> ans = 0 <NEWLINE> <NL> for i in range ( X ) : <NEWLINE> <INDENT> if A [ - 1 ] >= C [ - 1 ] : <NEWLINE> <INDENT> ans += A [ - 1 ] <NEWLINE> A . pop ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += C [ - 1 ] <NEWLINE> C . pop ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( Y ) : <NEWLINE> <INDENT> if B [ - 1 ] >= C [ - 1 ] : <NEWLINE> <INDENT> ans += B [ - 1 ] <NEWLINE> B . pop ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += C [ - 1 ] <NEWLINE> C . pop ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
( x , y , a , b , c ) , p , q , r = [ map ( int , o . split ( ) ) for o in open ( 0 ) ] <NEWLINE> print ( sum ( sorted ( sorted ( p ) [ - x : ] + sorted ( q ) [ - y : ] + r ) [ - x - y : ] ) ) <NEWLINE>
from collections import deque <NEWLINE> <NL> X , Y , A , B , C = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> p = deque ( sorted ( [ int ( x ) for x in input ( ) . split ( ) ] ) ) <NEWLINE> q = deque ( sorted ( [ int ( x ) for x in input ( ) . split ( ) ] ) ) <NEWLINE> r = deque ( sorted ( [ int ( x ) for x in input ( ) . split ( ) ] ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( X ) : <NEWLINE> <INDENT> if p [ 0 ] >= r [ 0 ] : <NEWLINE> <INDENT> ans += p . popleft ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += r . popleft ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( Y ) : <NEWLINE> <INDENT> if q [ 0 ] >= r [ 0 ] : <NEWLINE> <INDENT> ans += q . popleft ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += r . popleft ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
x , y , a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> p = sorted ( list ( map ( int , input ( ) . split ( ) ) ) , reverse = True ) <NEWLINE> q = sorted ( list ( map ( int , input ( ) . split ( ) ) ) , reverse = True ) <NEWLINE> r = sorted ( list ( map ( int , input ( ) . split ( ) ) ) , reverse = True ) <NEWLINE> pq = sorted ( p [ : x ] + q [ : y ] ) <NEWLINE> ans = sum ( pq ) <NEWLINE> i = 0 <NEWLINE> while i < min ( a + b , c ) : <NEWLINE> <INDENT> if r [ i ] <= pq [ i ] : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> ans += r [ i ] - pq [ i ] <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import numpy as np <NEWLINE> <COMMENT> <NL> fin = open ( <STRING> ) <NEWLINE> inp = fin . readline <NEWLINE> <NL> X , Y , A , B , C = map ( int , inp ( ) . split ( ) ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> red = list ( map ( int , inp ( ) . split ( ) ) ) <NEWLINE> green = list ( map ( int , inp ( ) . split ( ) ) ) <NEWLINE> white = list ( map ( int , inp ( ) . split ( ) ) ) <NEWLINE> red . sort ( reverse = True ) <NEWLINE> green . sort ( reverse = True ) <NEWLINE> white . sort ( reverse = True ) <NEWLINE> fin . close ( ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> idr = 0 <NEWLINE> idg = 0 <NEWLINE> idw = 0 <NEWLINE> <NL> total = 0.0 <NEWLINE> countr = 0 <NEWLINE> countg = 0 <NEWLINE> countw = 0 <NEWLINE> while X > countr and Y > countg and ( X + Y > countr + countg + countw ) : <NEWLINE> <INDENT> if red [ idr ] >= green [ idg ] : <NEWLINE> <INDENT> if idw >= C or red [ idr ] >= white [ idw ] : <NEWLINE> <COMMENT> <NL> <INDENT> total += red [ idr ] <NEWLINE> idr += 1 <NEWLINE> countr += 1 <NEWLINE> <DEDENT> elif idw < C : <NEWLINE> <COMMENT> <NL> <INDENT> total += white [ idw ] <NEWLINE> idw += 1 <NEWLINE> countw += 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if idw >= C or green [ idg ] >= white [ idw ] : <NEWLINE> <COMMENT> <NL> <INDENT> total += green [ idg ] <NEWLINE> idg += 1 <NEWLINE> countg += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <COMMENT> <NL> <INDENT> total += white [ idw ] <NEWLINE> idw += 1 <NEWLINE> countw += 1 <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> if Y <= countg : <NEWLINE> <INDENT> while X > countr + countw : <NEWLINE> <COMMENT> <NL> <INDENT> if idw < C and red [ idr ] < white [ idw ] : <NEWLINE> <COMMENT> <NL> <INDENT> total += white [ idw ] <NEWLINE> idw += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <COMMENT> <NL> <INDENT> total += red [ idr ] <NEWLINE> idr += 1 <NEWLINE> <DEDENT> countr += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if X <= countr : <NEWLINE> <INDENT> while Y > countg + countw : <NEWLINE> <COMMENT> <NL> <INDENT> if idw < C and green [ idg ] < white [ idw ] : <NEWLINE> <COMMENT> <NL> <INDENT> total += white [ idw ] <NEWLINE> idw += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <COMMENT> <NL> <INDENT> total += green [ idg ] <NEWLINE> idg += 1 <NEWLINE> <DEDENT> countg += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( int ( total ) ) <NEWLINE>
x , y , a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> li_p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> li_q = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> li_r = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> li_p . sort ( reverse = True ) <NEWLINE> li_q . sort ( reverse = True ) <NEWLINE> li_r . sort ( reverse = True ) <NEWLINE> p , q = [ ] , [ ] <NEWLINE> for i in range ( x ) : <NEWLINE> <INDENT> r . append ( li_p [ i ] ) <NEWLINE> <DEDENT> for i in range ( y ) : <NEWLINE> <INDENT> r . append ( li_q [ i ] ) <NEWLINE> <DEDENT> for i in range ( c ) : <NEWLINE> <INDENT> r . append ( li_r [ i ] ) <NEWLINE> <DEDENT> r . sort ( reverse = True ) <NEWLINE> print ( sum ( r [ : x + y ] ) ) <NEWLINE>
2 2 4 4 4 <NEWLINE> 11 12 13 14 <NEWLINE> 21 22 23 24 <NEWLINE> 1 2 3 4 <NEWLINE>
X , Y , A , B , C = map ( int , input ( ) . split ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> q = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> r = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> x = X - 1 <NEWLINE> y = Y - 1 <NEWLINE> <NL> p = sorted ( p , reverse = True ) <NEWLINE> q = sorted ( q , reverse = True ) <NEWLINE> r = sorted ( r , reverse = True ) <NEWLINE> <NL> <COMMENT> <NL> <NL> if p [ x ] >= q [ y ] : <NEWLINE> <INDENT> a = q [ y ] <NEWLINE> f = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a = p [ x ] <NEWLINE> f = 2 <NEWLINE> <DEDENT> while a < r [ 0 ] and len ( r ) >= 1 : <NEWLINE> <COMMENT> <NL> <INDENT> if f == 1 : <NEWLINE> <COMMENT> <NL> <INDENT> q [ y ] = r [ 0 ] <NEWLINE> y -= 1 <NEWLINE> r . pop ( 0 ) <NEWLINE> <DEDENT> elif f == 2 : <NEWLINE> <COMMENT> <NL> <INDENT> p [ x ] = r [ 0 ] <NEWLINE> x -= 1 <NEWLINE> r . pop ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <COMMENT> <NL> <INDENT> break <NEWLINE> <NL> <COMMENT> <NL> <NL> <DEDENT> if ( y == - 1 and x >= 0 ) or ( x >= 0 and p [ x ] < q [ y ] ) : <NEWLINE> <COMMENT> <NL> <INDENT> a = p [ x ] <NEWLINE> f = 2 <NEWLINE> <DEDENT> elif ( x == - 1 and y >= 0 ) or ( y >= 0 and p [ x ] >= q [ y ] ) : <NEWLINE> <COMMENT> <NL> <INDENT> a = q [ y ] <NEWLINE> f = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <COMMENT> <NL> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> ans = 0 <NEWLINE> <COMMENT> <NL> for i in p [ : X ] : <NEWLINE> <INDENT> ans += i <NEWLINE> <DEDENT> for i in q [ : Y ] : <NEWLINE> <INDENT> ans += i <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
def numba_compile ( numba_config ) : <NEWLINE> <INDENT> import os , sys <NEWLINE> if sys . argv [ - 1 ] == <STRING> : <NEWLINE> <INDENT> from numba import njit <NEWLINE> from numba . pycc import CC <NEWLINE> cc = CC ( <STRING> ) <NEWLINE> for func , signature in numba_config : <NEWLINE> <INDENT> globals ( ) [ func . __name__ ] = njit ( signature ) ( func ) <NEWLINE> cc . export ( func . __name__ , signature ) ( func ) <NEWLINE> <DEDENT> cc . compile ( ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> elif os . name == <STRING> : <NEWLINE> <INDENT> exec ( <STRING> ) <NEWLINE> for func , _ in numba_config : <NEWLINE> <INDENT> globals ( ) [ func . __name__ ] = vars ( ) [ func . __name__ ] <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> from numba import njit <NEWLINE> for func , signature in numba_config : <NEWLINE> <INDENT> globals ( ) [ func . __name__ ] = njit ( signature , cache = True ) ( func ) <NEWLINE> <DEDENT> print ( <STRING> , file = sys . stderr ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> import numpy as np <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> def pow_mod ( base , exp ) : <COMMENT> <NEWLINE> <COMMENT> <NL> <INDENT> exp %= mod - 1 <NEWLINE> res = 1 <NEWLINE> while exp : <NEWLINE> <INDENT> if exp % 2 : <NEWLINE> <INDENT> res = res * base % mod <NEWLINE> <DEDENT> base = base * base % mod <NEWLINE> exp //= 2 <NEWLINE> <DEDENT> return res <NEWLINE> <NL> <DEDENT> def comb_cunstruct ( n ) : <NEWLINE> <COMMENT> <NL> <INDENT> fac = np . empty ( n + 1 , dtype = np . int64 ) <NEWLINE> facinv = np . empty ( n + 1 , dtype = np . int64 ) <NEWLINE> fac [ 0 ] = f = 1 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> f = f * i % mod <NEWLINE> fac [ i ] = f <NEWLINE> <DEDENT> f = pow_mod ( f , - 1 ) <NEWLINE> for i in range ( n , - 1 , - 1 ) : <NEWLINE> <INDENT> facinv [ i ] = f <NEWLINE> f = f * i % mod <NEWLINE> <DEDENT> return fac , facinv <NEWLINE> <NL> <DEDENT> def comb ( n , r , fac , facinv ) : <NEWLINE> <COMMENT> <NL> <INDENT> return fac [ n ] * facinv [ r ] % mod * facinv [ n - r ] % mod <NEWLINE> <NL> <DEDENT> def rerooting ( n , edges , fac , facinv ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <INDENT> identity = ( 1 , 0 ) <NEWLINE> def merge ( a , b ) : <NEWLINE> <INDENT> return a [ 0 ] * b [ 0 ] % mod * comb ( a [ 1 ] + b [ 1 ] , a [ 1 ] , fac , facinv ) % mod , a [ 1 ] + b [ 1 ] <NEWLINE> <DEDENT> def add_node ( value , idx ) : <NEWLINE> <INDENT> return value [ 0 ] , value [ 1 ] + 1 <NEWLINE> <DEDENT> merge ( identity , identity ) <NEWLINE> <NL> G = [ [ 0 ] * 0 for _ in range ( n ) ] <NEWLINE> G_idxs = [ [ 0 ] * 0 for _ in range ( n ) ] <COMMENT> <NEWLINE> for idx_edges in range ( n - 1 ) : <NEWLINE> <INDENT> a , b = edges [ idx_edges ] <NEWLINE> G_idxs [ a ] . append ( len ( G [ b ] ) ) <NEWLINE> G_idxs [ b ] . append ( len ( G [ a ] ) ) <NEWLINE> G [ a ] . append ( b ) <NEWLINE> G [ b ] . append ( a ) <NEWLINE> <COMMENT> <NL> <DEDENT> parents = [ 0 ] * n <NEWLINE> order = [ ] <COMMENT> <NEWLINE> stack = [ 0 ] <NEWLINE> parents [ 0 ] = - 1 <NEWLINE> while stack : <NEWLINE> <INDENT> v = stack . pop ( ) <NEWLINE> p = parents [ v ] <NEWLINE> order . append ( v ) <NEWLINE> for u in G [ v ] : <NEWLINE> <INDENT> if p != u : <NEWLINE> <INDENT> stack . append ( u ) <NEWLINE> parents [ u ] = v <NEWLINE> <DEDENT> <DEDENT> <DEDENT> subtree_res = [ [ identity ] * len ( Gv ) for Gv in G ] <NEWLINE> <COMMENT> <NL> for v in order [ : 0 : - 1 ] : <NEWLINE> <INDENT> p = parents [ v ] <NEWLINE> result = identity <NEWLINE> for idx_Gv , ( u , subtree_res_v_i ) in enumerate ( zip ( G [ v ] , subtree_res [ v ] ) ) : <NEWLINE> <INDENT> if p == u : <NEWLINE> <INDENT> parent_idx = idx_Gv <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> result = merge ( result , subtree_res_v_i ) <NEWLINE> <DEDENT> <DEDENT> idx_p2v = G_idxs [ v ] [ parent_idx ] <NEWLINE> subtree_res [ p ] [ idx_p2v ] = add_node ( result , v ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> results = [ identity ] * n <NEWLINE> for v in order : <NEWLINE> <INDENT> subtree_res_v = subtree_res [ v ] <NEWLINE> cum = identity <NEWLINE> cum_from_tail = [ identity ] <NEWLINE> for r in subtree_res_v [ : 0 : - 1 ] : <NEWLINE> <INDENT> cum = merge ( r , cum ) <NEWLINE> cum_from_tail . append ( cum ) <NEWLINE> <DEDENT> cum_from_tail . reverse ( ) <NEWLINE> cum = identity <NEWLINE> for r , cum_t , u , idx_u2v in zip ( subtree_res_v , cum_from_tail , G [ v ] , G_idxs [ v ] ) : <NEWLINE> <INDENT> result = add_node ( merge ( cum , cum_t ) , v ) <NEWLINE> subtree_res [ u ] [ idx_u2v ] = result <NEWLINE> cum = merge ( cum , r ) <NEWLINE> <DEDENT> results [ v ] = add_node ( cum , v ) <NEWLINE> <DEDENT> return np . array ( results ) <NEWLINE> <NL> <NL> <DEDENT> numba_compile ( [ <NEWLINE> <INDENT> [ pow_mod , <STRING> ] , <NEWLINE> [ comb_cunstruct , <STRING> ] , <NEWLINE> [ comb , <STRING> ] , <NEWLINE> [ rerooting , <STRING> ] , <NEWLINE> <DEDENT> ] ) <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> AB = np . array ( sys . stdin . read ( ) . split ( ) , dtype = np . int64 ) . reshape ( N - 1 , 2 ) - 1 <NEWLINE> fac , facinv = comb_cunstruct ( 202020 ) <NEWLINE> Ans = rerooting ( N , AB , fac , facinv ) <NEWLINE> print ( <STRING> . join ( map ( str , Ans [ : , 0 ] . tolist ( ) ) ) ) <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE>
import math <NEWLINE> <NL> <NL> def combinations_count ( n , r ) : <NEWLINE> <INDENT> return math . factorial ( n ) // ( math . factorial ( n - r ) * math . factorial ( r ) ) <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( combinations_count ( n , 2 ) + combinations_count ( m , 2 ) ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import math <NEWLINE> def comb ( n , r ) : <NEWLINE> <INDENT> return math . factorial ( n ) // ( math . factorial ( n - r ) * math . factorial ( r ) ) <NEWLINE> <NL> <DEDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> if ( n <= 1 ) and ( m <= 1 ) : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if n == 0 : <NEWLINE> <INDENT> ans = comb ( m , 2 ) <NEWLINE> <DEDENT> elif m == 0 : <NEWLINE> <INDENT> ans = comb ( n , 2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = comb ( n , 2 ) + comb ( m , 2 ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from math import factorial <NEWLINE> <NL> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> def comb ( n , k ) : <NEWLINE> <INDENT> return int ( factorial ( n ) / factorial ( k ) / factorial ( n - k ) ) <NEWLINE> <NL> <DEDENT> res = comb ( M , 2 ) + comb ( N , 2 ) <NEWLINE> <NL> print ( res ) <NEWLINE>
n , m = map ( input ( ) . split ( ) ) <NEWLINE> <NL> a = n * ( n - 1 ) / 2 + m * ( m - 1 ) / 2 <NEWLINE> <NL> print ( str ( a ) ) <NEWLINE>
n , m = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> ans = 0 <NEWLINE> if ( n >= 2 ) : <NEWLINE> <INDENT> ans += n * ( n - 1 ) // 2 <NEWLINE> <NL> <DEDENT> if ( m >= 2 ) : <NEWLINE> <INDENT> ans += m * ( m - 1 ) // 2 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> pattern_even = ( N - 1 ) * N / 2 <NEWLINE> pattern_odd = ( M - 1 ) * M / 2 <NEWLINE> <NL> return ( pattern_even + pattern_odd ) <NEWLINE>
n , m = map ( int , input ( ) ) <NEWLINE> print ( n * ( n - 1 ) // 2 + m * ( m - 1 ) // 2 ) <NEWLINE>
N , M = map ( int , input ( ) ) <NEWLINE> <NL> if N >= 2 : <NEWLINE> <INDENT> gyu = N * ( N - 1 ) // 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> gyu = 0 <NEWLINE> <NL> <DEDENT> if M >= 2 : <NEWLINE> <INDENT> ki = M * ( M - 1 ) // 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ki = 0 <NEWLINE> <NL> <DEDENT> print ( gyu + ki ) <NEWLINE>
n , m = map ( int , unput ( ) . split ( ) ) <NEWLINE> c = 0 <NEWLINE> if n >= 2 : <NEWLINE> <INDENT> c += n * ( n - 1 ) / 2 <NEWLINE> <DEDENT> if m >= 2 : <NEWLINE> <INDENT> c += n * ( n - 1 ) / 2 <NEWLINE> <DEDENT> print ( c ) <NEWLINE>
a , b = map ( int , input ( ) . split ( <STRING> ) <NEWLINE> print ( a * ( a - 1 ) / 2 + b * ( b - 1 ) / 2 ) <NEWLINE>
import math <NEWLINE> <NL> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> ans1 = 0 <NEWLINE> if N > 1 : <NEWLINE> <INDENT> ans1 = math . factorial ( N ) / math . factorial ( N - 2 ) / 2 <NEWLINE> <DEDENT> ans2 = 0 <NEWLINE> if N > 1 : <NEWLINE> <INDENT> ans2 = math . factorial ( M ) / math . factorial ( M - 2 ) / 2 <NEWLINE> <DEDENT> print ( int ( ans1 + ans2 ) ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( N * ( N - 1 ) // 2 + M * ( M - 1 ) // 2 ) ) <NEWLINE>
even , odd = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> def f ( n ) : <NEWLINE> <INDENT> if n == 1 or n == 0 : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return n * f ( n - 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( int ( f ( even ) / ( f ( even - 2 ) * 2 ) + f ( odd ) / ( f ( odd - 2 ) * 2 ) ) ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> import math <NEWLINE> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> if n < 2 : <NEWLINE> <INDENT> x = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = math . factorial ( n ) // ( math . factorial ( n - 2 ) * math . factorial ( 2 ) ) <NEWLINE> <NL> <DEDENT> if m < 0 : <NEWLINE> <INDENT> y = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> y = math . factorial ( m ) // ( math . factorial ( m - 2 ) * math . factorial ( 2 ) ) <NEWLINE> <NL> <DEDENT> print ( x + y ) <NEWLINE>
import math <NEWLINE> <NL> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> Nf = math . factorial ( N ) / math . factorial ( N - 2 ) / 2 <NEWLINE> <NL> <COMMENT> <NL> Mf = math . factorial ( M ) / math . factorial ( M - 2 ) / 2 <NEWLINE> <NL> ans = int ( Nf + Mf ) <NEWLINE> <NL> print ( ans ) <NEWLINE>
l = int ( input ( ) ) <NEWLINE> <NL> import numpy as np <NEWLINE> result = 0 <NEWLINE> for x in np . arange ( l / 3 - 0.1 , l / 3 + 0.1 , 0.1 ) : <NEWLINE> <INDENT> for y in np . arange ( x , l / 3 + 0.1 , 0.1 ) : <NEWLINE> <INDENT> z = l - ( x + y ) <NEWLINE> if z <= 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> v = x * y * z <NEWLINE> result = max ( v , result ) <NEWLINE> <DEDENT> <DEDENT> print ( result ) <NEWLINE>
<NL> N , M = map ( int , readline ( ) . split ( ) ) <NEWLINE> <NL> print ( N * ( N - 1 ) / 2 + M * ( M - 1 ) / 2 ) <NEWLINE>
n , m = map ( int , input ( ) ) <NEWLINE> print ( int ( ( n * ( n - 1 ) / 2 + m * ( m - 1 ) * 2 ) ) ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( n ( n - 1 ) / 2 + m ( m - 1 ) / 2 ) <NEWLINE>
import math <NEWLINE> n , m = input ( ) . split ( ) <NEWLINE> n = int ( n ) <NEWLINE> m = int ( m ) <NEWLINE> <NL> print ( int ( math . factorial ( n ) / ( 2 * math . factorial ( n - 2 ) ) + math . factorial ( m ) / ( 2 * math . factorial ( m - 2 ) ) ) ) <NEWLINE> <NL>
n = int ( input ( ) ) <NEWLINE> m = int ( input ( ) ) <NEWLINE> k = ( n * ( n - 1 ) ) // 2 <NEWLINE> j = ( m * ( m - 1 ) ) // 2 <NEWLINE> print ( j + k ) <NEWLINE>
N , M = map ( int , input ( ) split ( ) ) <NEWLINE> ans = N * ( N - 1 ) / 2 + M * ( M - 1 ) / 2 <NEWLINE> ans = int ( ) <NEWLINE> print ( ans ) <NEWLINE>
nm = input ( ) <NEWLINE> n = int ( nm [ 0 ] ) <NEWLINE> m = int ( nm [ 1 ] ) <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> n1 = n * ( n - 1 ) / 2 <NEWLINE> <NL> n2 = m * ( m - 1 ) / 2 <NEWLINE> <NL> ans = n1 + n2 <NEWLINE> <NL> print ( ans ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> print ( ( ( n + ( n - 1 ) ) + m ( m - 1 ) ) / 2 ) <NEWLINE>
from math import factorial <NEWLINE> <NL> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if N == 0 : <NEWLINE> <INDENT> combN = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> combN = factorial ( N ) // ( factorial ( N - 2 ) * factorial ( 2 ) ) <NEWLINE> <NL> <DEDENT> if M == 0 : <NEWLINE> <INDENT> combM = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> combM = factorial ( M ) // ( factorial ( M - 2 ) * factorial ( 2 ) ) <NEWLINE> <NL> <DEDENT> print ( combN + combM ) <NEWLINE>
import math <NEWLINE> <NL> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <NL> def combinations_count ( n , r ) : <NEWLINE> <INDENT> return math . factorial ( n ) // ( math . factorial ( n - r ) * math . factorial ( r ) ) <NEWLINE> <NL> <NL> <DEDENT> ans = combinations_count ( m , 2 ) + combinations_count ( n , 2 ) <NEWLINE> <NL> print ( ans ) <NEWLINE>
n , m = map ( int , input ( ) ) <NEWLINE> ans = n * ( n - 1 ) / 2 + m * ( m - 1 ) / 2 <NEWLINE> print ( ans ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( int ( n * ( n + 1 ) / 2 + m * ( m + 1 ) / 2 ) <NEWLINE>
S = input ( ) <NEWLINE> L = len ( S ) <NEWLINE> ans = <STRING> <NEWLINE> <INDENT> if S [ : ( L - 1 ) / 2 ] == S [ ( L - 1 ) / 2 - 1 : : - 1 ] and S [ L + 3 / 2 - 1 : ] == S [ : ( L + 3 / 2 ) - 2 : - 1 ] : <NEWLINE> ans = <STRING> <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
def partpall ( s , n ) : <NEWLINE> <INDENT> if s != s [ : : - 1 ] : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return True <NEWLINE> <NL> <DEDENT> <DEDENT> def pall ( s , n ) : <NEWLINE> <INDENT> if s != s [ : : - 1 ] : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> return partpall ( s [ n // 2 + 1 : ] , n ) and partpall ( s [ : n // 2 ] , n ) <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> s = <STRING> <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> if pall ( s , n ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> c = int ( ( len ( s ) - 1 ) / 2 ) <NEWLINE> ans = ( list ( s ) == list ( reversed ( s ) and list ( s [ : c ] ) == list ( reversed ( s [ : c ] ) ) and list ( s [ ( c + 1 ) : ] ) == list ( reversed ( s [ ( c + 1 ) : ] ) ) ) <NEWLINE> print ( [ <STRING> , <STRING> ] [ ans ] ) <NEWLINE>
s = input ( ) <NEWLINE> n = len ( s ) <NEWLINE> <NL> t = s [ : ( n - 1 ) // 2 ] <NEWLINE> u = s [ ( n + 3 ) // 2 : ] <NEWLINE> <NL> if ( s == s [ : : - 1 ] <NEWLINE> <INDENT> and len ( t ) > 0 and len ( u ) > 0 and <NEWLINE> and t == t [ : : - 1 ] <NEWLINE> and u == u [ : : - 1 ] ) : <NEWLINE> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT>
n = len ( s ) <NEWLINE> x = n // 2 <NEWLINE> a = s [ 0 : x ] <NEWLINE> b = s [ x + 1 : ] <NEWLINE> if a == b : print ( <STRING> ) <NEWLINE> else : print ( <STRING> ) <NEWLINE>
w = input ( ) <NEWLINE> l = len ( w ) <NEWLINE> flag = True <NEWLINE> for i in range ( ( l - 1 ) / 2 ) : <NEWLINE> <INDENT> if w [ i ] != w [ l - i - 1 ] : <NEWLINE> <INDENT> flag = False <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> mid = ( l - 1 ) / 2 <NEWLINE> mid_mid = mid // 2 <NEWLINE> for i in range ( mid_mid + 1 ) : <NEWLINE> <INDENT> if w [ i ] != w [ mid - i - 1 ] or not flag : <NEWLINE> <INDENT> flag = False <NEWLINE> break <NEWLINE> <DEDENT> if w [ i + mid + 1 ] != w [ l - i - 1 ] : <NEWLINE> <INDENT> flag = False <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if flag : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> n = len ( s ) <NEWLINE> s1 = s [ 0 : n // 2 ] <NEWLINE> s2 = s [ n // 2 + 1 : n ] <NEWLINE> if s = s [ : : - 1 ] and s1 = s1 [ : : - 1 ] and s2 = s2 [ : : - 1 ] : print ( <STRING> ) <NEWLINE> else : print ( <STRING> ) <NEWLINE>
def is_kaibun ( st ) : <NEWLINE> <INDENT> f = True <NEWLINE> for x , y in zip ( st , st [ : : - 1 ] ) : <NEWLINE> <INDENT> if x != y : <NEWLINE> <INDENT> f = False <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> return f <NEWLINE> <NL> <DEDENT> S = input ( ) <NEWLINE> ans = False <NEWLINE> if is_kaibun ( S ) : <NEWLINE> <INDENT> if is_kaibun ( S [ : ( len ( S ) - 1 ) / 2 + 1 ] ) : <NEWLINE> <INDENT> ans = is_kaibun ( S [ ( len ( S ) + 3 ) / 2 + 1 ] ) <NEWLINE> <DEDENT> <DEDENT> if ans : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
S = input ( ) <NEWLINE> N = len ( S ) <NEWLINE> <NL> if S == S [ : : - 1 ] : <NEWLINE> <INDENT> if S [ : ( n - 1 ) // 2 ] == S [ ( n + 1 ) // 2 : ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> n = s <NEWLINE> <NL> if s == reversed ( s ) and s [ 0 : ( n - 1 ) // 2 ] == reverses ( s [ 0 : ( n - 1 ) // 2 ] ) and s [ ( ( n + 3 ) // 2 ) - 1 : n ] == reversed ( s [ ( ( n + 3 ) // 2 ) - 1 : n ] ) : <NEWLINE> print ( <STRING> ) <NEWLINE> <NL> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
string = input ( ) <NEWLINE> <NL> def palindrome ( inp ) : <NEWLINE> <INDENT> if inp == inp [ : : - 1 ] : return True <NEWLINE> else : return False <NEWLINE> <NL> <DEDENT> if palindrome ( string ) and palindrome ( string [ : int ( ( len ( string ) + 1 ) / 2 ) ] and palindrome ( string [ int ( ( len ( string ) + 3 ) / 2 ) : ] : print ( <STRING> ) <NEWLINE> else : print ( <STRING> ) <NEWLINE>
for i in range ( 1 , n1 + 1 ) : <NEWLINE> <INDENT> if s [ i - 1 ] != s [ - i ] or s1 [ i - 1 ] != s1 [ - i ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
s = str ( input ( ) ) <NEWLINE> n = len ( s ) <NEWLINE> new_n1 = ( n - 1 ) / 2 <NEWLINE> new_s1 = s [ : new_n ] <NEWLINE> <NL> new_n2 = ( n + 3 ) / 2 <NEWLINE> new_s2 = s [ new_nw : ] <NEWLINE> <NL> for i in range ( new_n1 ) : <NEWLINE> <INDENT> if new_s1 [ i ] != new_s1 [ n - i + 1 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> pass <NEWLINE> <NL> <DEDENT> <DEDENT> for j in range ( new_n2 ) : <NEWLINE> <INDENT> if new_s2 [ j ] != new_s2 [ n - j + 1 ] : <NEWLINE> <INDENT> prin ( <STRING> ) <NEWLINE> <DEDENT> else <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <NL> <NL> <DEDENT> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> s1 = s [ : int ( ( len ( s ) - 1 ) / 2 ) ] <NEWLINE> s2 = s [ int ( ( len ( s ) + 3 ) / 2 - 1 ) : ] <NEWLINE> rs1 = s1 [ : : - 1 ] <NEWLINE> rs2 = s2 [ : : - 1 ] <NEWLINE> <NL> if s1 == rs1 and s2 == rs2 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> return <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE> a <NEWLINE>
a = int ( input ( ) ) <NEWLINE> c = len ( a ) <NEWLINE> b = a [ : ( c - 1 ) // 2 ] <NEWLINE> d = a [ ( c + 3 ) // 2 : ] <NEWLINE> if a == a [ : : - 1 ] and b == b [ : : - 1 ] and d == d [ : : - 1 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( N * ( N - 1 ) // 2 + M * ( M - 1 ) // 2 ) <NEWLINE> <NL> S = input ( ) <NEWLINE> T = S [ : ( len ( S ) - 1 ) // 2 - 1 ] <NEWLINE> U = S [ ( len ( S ) + 3 ) // 2 - 1 : ] <NEWLINE> if S == S [ : : - 1 ] : <NEWLINE> <INDENT> if T == T [ : : - 1 ] : <NEWLINE> <INDENT> if U == U [ : : - 1 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : print ( <STRING> ) <NEWLINE> <DEDENT> else : print ( <STRING> ) <NEWLINE> <DEDENT> else : print ( <STRING> ) <NEWLINE>
string = input ( ) <NEWLINE> mid = len ( s ) // 2 <NEWLINE> <NL> gnirts = reversed ( string ) <NEWLINE> print ( gnirts ) <NEWLINE> if ( string != gnirts or string [ : mid - 1 ] != gnirts [ mid + 1 : ] or string [ mid + 1 : ] != gnirts [ : mid - 1 ] ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE>
def pal ( s ) : <NEWLINE> <INDENT> rev = <STRING> <NEWLINE> for a in s : <NEWLINE> <INDENT> rev = a + rev <NEWLINE> <DEDENT> return s == rev <NEWLINE> <NL> <DEDENT> s = input ( ) <NEWLINE> def sub ( s ) : <NEWLINE> <INDENT> if pal ( s ) : <NEWLINE> <INDENT> n = len ( s ) <NEWLINE> if pal ( s [ 0 : ( n - 1 ) / 2 ] ) : <NEWLINE> <INDENT> if pal ( s [ ( n + 3 ) / 2 : n - 1 ] ) : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return False <NEWLINE> <DEDENT> if sub ( s ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
def check ( a ) : <NEWLINE> <INDENT> for i in range ( int ( len ( a ) / 2 ) ) : <NEWLINE> <INDENT> if a [ i ] != a [ - ( i + 1 ) ] : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> <DEDENT> return True <NEWLINE> <NL> <DEDENT> S = input ( ) <NEWLINE> if kaibun ( S ) : <NEWLINE> <INDENT> a = S [ 0 : int ( len ( S ) / 2 ) ] <NEWLINE> b = S [ int ( len ( S ) / 2 ) + 1 : len ( S ) ] <NEWLINE> if kaibun ( a ) and kaibun ( b ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
S = input ( ) <NEWLINE> S1 = S [ : int ( ( len ( s ) - 1 ) / 2 ) ] <NEWLINE> S2 = S [ int ( ( len ( s ) + 3 ) / 2 ) - 1 : ] <NEWLINE> print ( <STRING> if S == S [ : : - 1 ] and S1 == S1 [ : : - 1 ] and S2 == S2 [ : : - 1 ] else <STRING> ) <NEWLINE>
import sys <NEWLINE> import math <NEWLINE> import itertools <NEWLINE> import bisect <NEWLINE> from copy import copy <NEWLINE> from collections import deque , Counter <NEWLINE> from decimal import Decimal <NEWLINE> def s ( ) : return input ( ) <NEWLINE> def k ( ) : return int ( input ( ) ) <NEWLINE> def S ( ) : return input ( ) . split ( ) <NEWLINE> def I ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def X ( ) : return list ( input ( ) ) <NEWLINE> def L ( ) : return list ( input ( ) . split ( ) ) <NEWLINE> def l ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> def lcm ( a , b ) : return a * b // math . gcd ( a , b ) <NEWLINE> def gcd ( * numbers ) : reduce ( math . gcd , numbers ) <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> count = 0 <NEWLINE> ans = 0 <NEWLINE> inf = float ( <STRING> ) <NEWLINE> <NL> S = s ( ) <NEWLINE> n = len ( S ) <NEWLINE> a = S [ : N // 2 ] <NEWLINE> b = S [ N // 2 + 1 : ] <NEWLINE> print ( <STRING> if a == a [ : : - 1 ] == b == b [ : : - 1 ] else <STRING> ) <NEWLINE>
l = int ( input ( ) ) <NEWLINE> print ( ( l / 3 ) ** 3 ) <NEWLINE>
s = input ( ) <NEWLINE> n = len ( s ) <NEWLINE> p = n // 2 <NEWLINE> t = 1 <NEWLINE> <NL> for i in range ( p ) : <NEWLINE> <INDENT> if s [ i ] == s [ p - 1 - i ] : <NEWLINE> <INDENT> t = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> t = 0 <NEWLINE> break ; <NEWLINE> <NL> <DEDENT> <DEDENT> x = 1 <NEWLINE> <NL> for i in range ( p ) : <NEWLINE> <INDENT> if s [ p + 1 + i ] == s [ n - 1 - i ] : <NEWLINE> <INDENT> x = 1 <NEWLINE> else : <NEWLINE> x = 0 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> y = 1 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> if s [ i ] == s [ n - 1 - i ] : <NEWLINE> <INDENT> y = 1 <NEWLINE> else : <NEWLINE> y = 0 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if ( t == 1 and x == 1 and y == 1 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> l = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if ( ( i % 3 ) != 0 ) and ( ( i % 5 ) != 0 ) : <NEWLINE> <INDENT> l . append ( i ) <NEWLINE> <DEDENT> <DEDENT> print ( sum ( l ) ) <NEWLINE>
S = str ( input ( ) ) <NEWLINE> N = len ( S ) <NEWLINE> if S != S [ : : - 1 ] : <COMMENT> <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> S1 = S [ : ( N - 1 ) / 2 ] <COMMENT> <NEWLINE> S2 = S [ ( N + 3 ) / 2 : ] <COMMENT> <NEWLINE> if S1 == S1 [ : : - 1 ] and S2 == S2 [ : : - 1 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
S = input ( ) <NEWLINE> N = len ( S ) <NEWLINE> <NL> def isp ( s ) : <NEWLINE> <INDENT> n = len ( s ) <NEWLINE> for i in range ( n // 2 - 1 ) : <NEWLINE> <INDENT> if s [ i ] != s [ n - 1 - i ] : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> <DEDENT> return True <NEWLINE> <NL> <DEDENT> if isp ( S ) and isp ( S [ 0 : ( N - 1 ) / 3 ] ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> a = s . sort ( ) <NEWLINE> if s != s . sort ( ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> if s [ 0 : len ( s ) // 2 ] == a [ 0 : len ( s ) // 2 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> t = s [ : : - 1 ] <NEWLINE> n = len ( s ) <NEWLINE> a = s [ : ( N - 1 ) // 2 ] <NEWLINE> b = t [ : ( n + 3 ) // 2 ] <NEWLINE> <NL> if s == t and a == a [ : : - 1 ] and b == b [ : : - 1 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
def is_p ( s ) : <NEWLINE> <INDENT> return s == s [ : : - 1 ] <NEWLINE> <DEDENT> s = input ( ) <NEWLINE> n = len ( s ) <NEWLINE> l , r = ( n - 1 ) // 2 , l + 1 <NEWLINE> print ( <STRING> if is_p ( s ) and is_p ( s [ : l ] ) and is_p ( s [ r : ] ) else <STRING> ) <NEWLINE>
s = input ( ) <NEWLINE> l = len ( s ) <NEWLINE> a = s [ : ( l - 1 ) / 2 ] <NEWLINE> b = len ( a ) <NEWLINE> print ( <STRING> if s [ : ( l - 1 ) / 2 ] == s [ ( l + 1 ) / 2 : ] and a [ : ( b - 1 ) / 2 ] == a [ ( b + 1 ) / 2 : ] else <STRING> ) <NEWLINE>
print ( ( int ( input ) ) ** 3 / 27 ) <NEWLINE>
L = int ( input ( ) ) <NEWLINE> ans = [ 0 ] <NEWLINE> for i in range ( 1 , 350 ) : <NEWLINE> <INDENT> for j in range ( 1 , 350 ) : <NEWLINE> <INDENT> for k in range ( 1 , 350 ) : <NEWLINE> <INDENT> if i + j + k == L : <NEWLINE> <INDENT> ans . append ( i * j * k ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( max ( ans ) ) <NEWLINE>
L = input ( ) <NEWLINE> <NL> returnVal = ( L / 3 ) ** 3 <NEWLINE> print ( returnVal ) <NEWLINE>
l = int ( input ( ) ) <NEWLINE> print ( L ** 3 / 27 ) <NEWLINE>
from decimal import Decimal <NEWLINE> a = input ( ) . split ( ) <NEWLINE> b = Decimal ( a / 3 ) <NEWLINE> print ( b * b * b ) <NEWLINE>
num = int ( input ( ) ) <NEWLINE> <NL> number = num / 3 <NEWLINE> print ( number * number * number ) a <NEWLINE>
print ( int ( input ( ) / 3 ** 3 ) ) <NEWLINE>
<NL> if __name__ == <STRING> : <NEWLINE> <NL> <INDENT> n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <COMMENT> <NL> d = Counter ( A ) <NEWLINE> <NL> d2 = dict ( ) <NEWLINE> <COMMENT> <NL> for k , v in d . items ( ) : <NEWLINE> <INDENT> d2 [ k ] = ( v * ( v - 1 ) ) // 2 <NEWLINE> <DEDENT> ans_sum = sum ( d2 . values ( ) ) <NEWLINE> <NL> <COMMENT> <NL> for i in A : <NEWLINE> <INDENT> ans = 0 <NEWLINE> if i in d2 : <NEWLINE> <COMMENT> <NL> <INDENT> tmp = d [ i ] - 1 <NEWLINE> before = d2 [ i ] <NEWLINE> after = ( tmp * ( tmp - 1 ) ) // 2 <NEWLINE> ans = ans_sum - ( before - after ) <NEWLINE> print ( ans ) <NEWLINE> <DEDENT> else : <NEWLINE> <COMMENT> <NL> <INDENT> print ( ans_sum ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
from math import factorial <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> index = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> val = [ 0 ] * max ( index ) <NEWLINE> for i in index : <NEWLINE> <INDENT> val [ i - 1 ] += 1 <NEWLINE> <DEDENT> total = 0 <NEWLINE> for i in val : <NEWLINE> <INDENT> if i >= 2 : <NEWLINE> <INDENT> total += comb ( i , 2 , exact = True ) <NEWLINE> <DEDENT> <DEDENT> for i in index : <NEWLINE> <INDENT> if val [ i - 1 ] >= 2 : <NEWLINE> <INDENT> print ( total - ( comb ( val [ i - 1 ] , 2 , exact = True ) - comb ( val [ i - 1 ] - 1 , 2 , exact = True ) ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( total ) <NEWLINE> <DEDENT> <DEDENT>
import sys , bisect , math , itertools , string , queue , copy <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> from collections import Counter , defaultdict , deque <NEWLINE> from itertools import permutations , combinations <NEWLINE> from heapq import heappop , heappush <NEWLINE> from fractions import gcd <NEWLINE> input = sys . stdin . readline <NEWLINE> sys . setrecursionlimit ( 10 ** 8 ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> def inp ( ) : return int ( input ( ) ) <NEWLINE> def inpm ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def inpl ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> def inpls ( ) : return list ( input ( ) . split ( ) ) <NEWLINE> def inplm ( n ) : return list ( int ( input ( ) ) for _ in range ( n ) ) <NEWLINE> def inplL ( n ) : return [ list ( input ( ) ) for _ in range ( n ) ] <NEWLINE> def inplT ( n ) : return [ tuple ( input ( ) ) for _ in range ( n ) ] <NEWLINE> def inpll ( n ) : return [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ] <NEWLINE> def inplls ( n ) : return sorted ( [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ] ) <NEWLINE> <NL> n = inp ( ) <NEWLINE> a = inpl ( ) <NEWLINE> kosuu = [ 0 ] * ( 200000 + 1 ) <NEWLINE> cnt = [ 0 ] * ( 200000 + 1 ) <NEWLINE> ans = [ 0 ] * ( 200000 + 1 ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> kosuu [ a [ i ] ] += 1 <NEWLINE> <NL> <DEDENT> s = 0 <NEWLINE> for i in kosuu : <NEWLINE> <INDENT> s += i * ( i - 1 ) // 2 <NEWLINE> <NL> <DEDENT> for i in range ( n ) <NEWLINE> <INDENT> tmp = kosuu [ a [ i ] ] <NEWLINE> <COMMENT> <NL> print ( s - max ( 0 , tmp - 1 ) ) <NEWLINE> <DEDENT>
n = ( int ) ( nput ( ) ) <NEWLINE> a = input ( ) . split ( ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a [ i ] = ( int ) ( a [ i ] ) <NEWLINE> <NL> <DEDENT> dic = { } <NEWLINE> sum = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if not a [ i ] in dic : <NEWLINE> <INDENT> dic [ a [ i ] ] = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dic [ a [ i ] ] += 1 <NEWLINE> sum += dic [ a [ i ] ] - 1 <NEWLINE> <NL> <DEDENT> <DEDENT> for i in a : <NEWLINE> <INDENT> print ( sum - dic [ i ] + 1 ) <NEWLINE> <NL> <DEDENT>
import collections <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> c = collections . Counter ( a ) <NEWLINE> <NL> print ( c ) <NEWLINE> <NL> for i in c . values ( ) : <NEWLINE> <INDENT> s += i * ( i - 1 ) // 2 <COMMENT> <NEWLINE> <NL> <DEDENT> for j in a : <NEWLINE> <INDENT> f = c [ j ] <NEWLINE> print ( s - ( f - 1 ) ) <COMMENT> <NEWLINE> <NL> <DEDENT> <STRING> <NEWLINE>
import collections <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> arr = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> cnt = collectioms . Counter ( arr ) <NEWLINE> total = 0 <NEWLINE> <NL> for key in cnt . keys ( ) : <NEWLINE> <INDENT> total += cnt [ key ] * ( cnt [ key ] - 1 ) // 2 <NEWLINE> <NL> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> tmp = total <NEWLINE> tmp -= cnt [ arr [ i ] ] * ( cnt [ arr [ i ] ] - 1 ) // 2 <NEWLINE> tmp += ( cnt [ arr [ i ] ] - 1 ) * ( cnt [ arr [ i ] ] - 2 ) // 2 <NEWLINE> print ( tmp ) <NEWLINE> <DEDENT>
def resolve ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> a = tuple ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A = collections . Counter ( a ) <NEWLINE> cnt_0 = 0 <NEWLINE> for i in A . values ( ) : <NEWLINE> <INDENT> cnt_0 += int ( i * ( i - 1 ) / 2 ) <NEWLINE> <DEDENT> for i in a : <NEWLINE> <INDENT> cnt_1 = A [ i ] - 1 <NEWLINE> print ( cnt_0 - cnt_1 ) <NEWLINE> <DEDENT> <DEDENT> resolve ( ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> d = [ 0 ] * ( n + 1 ) <NEWLINE> answer = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> d [ a [ i ] ] += 1 <NEWLINE> <DEDENT> for j in range ( n ) : <NEWLINE> <INDENT> answer += ( d [ j ] * ( d [ j ] - 1 ) ) // 2 <NEWLINE> <DEDENT> for k in range ( n ) <NEWLINE> <INDENT> print ( answer + 1 - ( d [ a [ k ] ] ) ) <NEWLINE> <DEDENT>
rom collections import Counter <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> count = Counter ( A ) <NEWLINE> vals = count . values ( ) <NEWLINE> sum_ = 0 <NEWLINE> for v in vals : <NEWLINE> <INDENT> if v >= 2 : sum_ += v * ( v - 1 ) <NEWLINE> <DEDENT> sum_ //= 2 <NEWLINE> <NL> for k in range ( N ) : <NEWLINE> <INDENT> if count [ A [ k ] ] < 2 : print ( sum_ ) <NEWLINE> else : print ( sum_ + 1 - count [ A [ k ] ] ) <NEWLINE> <DEDENT>
h , w , kk = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> s = [ list ( map ( int , list ( input ( ) ) ) ) for i in range ( h ) ] <NEWLINE> l = [ ] <NEWLINE> for i in range ( 2 ** ( h - 1 ) ) : <NEWLINE> <INDENT> ll = [ 0 ] <NEWLINE> for j in range ( h - 1 ) : <NEWLINE> <INDENT> if i & 2 ** j : <NEWLINE> <INDENT> ll . append ( ll [ - 1 ] + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ll . append ( ll [ - 1 ] ) <NEWLINE> <DEDENT> <DEDENT> l . append ( ll ) <NEWLINE> <NL> <DEDENT> mc = w + h <NEWLINE> for i in l : <NEWLINE> <INDENT> c = [ 0 for i in range ( h ) ] <NEWLINE> cc = 0 <NEWLINE> f = 1 <NEWLINE> <COMMENT> <NL> for j in range ( w ) : <NEWLINE> <COMMENT> <NL> <INDENT> ff = 0 <NEWLINE> for k in range ( h ) : <NEWLINE> <INDENT> c [ i [ k ] ] += s [ k ] [ j ] <NEWLINE> <DEDENT> for k in range ( h ) : <NEWLINE> <INDENT> if c [ k ] > kk : <NEWLINE> <INDENT> ff = 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if ff : <NEWLINE> <INDENT> if f : <NEWLINE> <INDENT> cc = w + h <NEWLINE> print ( c ) <NEWLINE> break <NEWLINE> <DEDENT> cc += 1 <NEWLINE> c = [ 0 for i in range ( h ) ] <NEWLINE> for k in range ( h ) : <NEWLINE> <INDENT> c [ i [ k ] ] += s [ k ] [ j ] <NEWLINE> <DEDENT> <DEDENT> f = 0 <NEWLINE> <COMMENT> <NL> <DEDENT> if mc > cc + len ( set ( i ) - 1 ) : <NEWLINE> <INDENT> mc = cc <NEWLINE> <DEDENT> <DEDENT> print ( mc ) <NEWLINE>
H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> map = [ ] <NEWLINE> INF = 10 ** 8 <NEWLINE> for _ in range ( H ) : <NEWLINE> <INDENT> map . append ( input ( ) ) <NEWLINE> <NL> <DEDENT> dp = [ [ 0 for i in range ( W ) ] for i in range ( H ) ] <NEWLINE> <NL> for i in range ( H ) : <NEWLINE> <INDENT> for j in range ( W ) : <NEWLINE> <INDENT> if i == 0 and j == 0 : <NEWLINE> <INDENT> if map [ i ] [ j ] == <STRING> : <NEWLINE> <INDENT> dp [ i ] [ j ] = 1 <NEWLINE> <DEDENT> <DEDENT> elif i == 0 : <NEWLINE> <INDENT> flag = 0 <NEWLINE> if map [ i ] [ j ] == <STRING> and map [ i ] [ j - 1 ] == <STRING> : <NEWLINE> <INDENT> flag = 1 <NEWLINE> <DEDENT> dp [ i ] [ j ] = flag + dp [ i ] [ j - 1 ] <NEWLINE> <DEDENT> elif j == 0 : <NEWLINE> <INDENT> flag = 0 <NEWLINE> if map [ i ] [ j ] == <STRING> and map [ i - 1 ] [ j ] == <STRING> : <NEWLINE> <INDENT> flag = 1 <NEWLINE> <DEDENT> dp [ i ] [ j ] = flag + dp [ i - 1 ] [ j ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> flag1 = 0 <NEWLINE> flag2 = 0 <NEWLINE> if map [ i ] [ j ] == <STRING> and map [ i ] [ j - 1 ] == <STRING> : <NEWLINE> <INDENT> flag1 = 1 <NEWLINE> <DEDENT> if map [ i ] [ j ] == <STRING> and map [ i - 1 ] [ j ] == <STRING> : <NEWLINE> <INDENT> flag2 = 1 <NEWLINE> <DEDENT> dp [ i ] [ j ] = min ( dp [ i ] [ j - 1 ] + flag1 , dp [ i - 1 ] [ j ] + flag2 ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> pritn ( dp [ H - 1 ] [ W - 1 ] ) <NEWLINE>
import math , string , itertools , fractions , heapq , collections , re , array , bisect , sys , random , time , copy <NEWLINE> <NL> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> inf = 10 ** 20 <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> stdin = sys . stdin <NEWLINE> <NL> ni = lambda : int ( ns ( ) ) <NEWLINE> na = lambda : list ( map ( int , stdin . readline ( ) . split ( ) ) ) <NEWLINE> ns = lambda : stdin . readline ( ) . rstrip ( ) <COMMENT> <NEWLINE> <NL> h , w = na ( ) <NEWLINE> m = [ ] <NEWLINE> m = [ ns ( ) for _ in range ( h ) ] <NEWLINE> dp = [ [ inf ] * w for _ in range ( h ) ] <NEWLINE> dp [ 0 ] [ 0 ] = int ( m [ 0 ] [ 0 ] == <STRING> ) <NEWLINE> for x in range ( 1 , w ) : <NEWLINE> <INDENT> dp [ 0 ] [ x ] = dp [ 0 ] [ x - 1 ] + ( int ( m [ 0 ] [ x ] == <STRING> ) if m [ 0 ] [ x - 1 ] == <STRING> else 0 ) <NEWLINE> <DEDENT> for y in range ( 1 , h ) : <NEWLINE> <INDENT> dp [ y ] [ 0 ] = dp [ y - 1 ] [ 0 ] + ( int ( S [ y ] [ 0 ] == <STRING> ) if S [ y - 1 ] [ 0 ] == <STRING> else 0 ) <NEWLINE> for x in range ( 1 , W ) : <NEWLINE> <INDENT> dp [ y ] [ x ] = min ( <NEWLINE> <INDENT> dp [ y ] [ x - 1 ] + ( int ( S [ y ] [ x ] == <STRING> ) if S [ y ] [ x - 1 ] == <STRING> else 0 ) , <NEWLINE> dp [ y - 1 ] [ x ] + ( int ( S [ y ] [ x ] == <STRING> ) if S [ y - 1 ] [ x ] == <STRING> else 0 ) <NEWLINE> <DEDENT> ) <NEWLINE> <DEDENT> <DEDENT> print ( dp [ - 1 ] [ - 1 ] ) <NEWLINE>
print ( [ 1 , 1 , 1 , 2 , 1 , 2 , 1 , 5 , 2 , 2 , 1 , 5 , 1 , 2 , 1 , 14 , 1 , 5 , 1 , 5 , 2 , 2 , 1 , 15 , 2 , 2 , 5 , 4 , 1 , 4 , 1 , 51 ] [ int ( input ( ) ) - 1 ] <NEWLINE>
H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> import math <NEWLINE> if H == 1 or W == 1 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> if H % 2 == 0 : <NEWLINE> <INDENT> print ( H // 2 * W ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( int ( H // 2 * W + math . ceil ( W / 2 ) ) ) <NEWLINE> <DEDENT>
import math <NEWLINE> a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> if ( math . sqrt ( a ) + math . sqrt ( b ) <= math . sqrt ( c ) ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
K = int ( input ( ) ) <NEWLINE> <NL> A = list ( 1 , 1 , 1 , 2 , 1 , 2 , 1 , 5 , 2 , 2 , 1 , 5 , 1 , 2 , 1 , 14 , 1 , 5 , 1 , 5 , 2 , 2 , 1 , 15 , 2 , 2 , 5 , 4 , 1 , 4 , 1 , 51 ) <NEWLINE> <NL> Print ( A [ K - 1 ] ) <NEWLINE>
a = [ 1 , 1 , 1 , 2 , 1 , 2 , 1 , 5 , 2 , 2 , 1 , 5 , 1 , 2 , 1 , 14 , 1 , 5 , 1 , 5 , 2 , 2 , 1 , 15 , 2 , 2 , 5 , 4 , 1 , 4 , 1 , 51 ] <NEWLINE> k = int ( input ( ) ) <NEWLINE> print ( a ( k - 1 ) ) <NEWLINE>
k = int ( input ( ) ) <NEWLINE> a = [ 1 , 1 , 1 , 2 , 1 , 2 , 1 , 5 , 2 , 2 , 1 , 5 , 1 , 2 , 1 , 14 , 1 , 5 , 1 , 5 , 2 , 2 , 1 , 15 , 2 , 2 , 5 , 4 , 1 , 4 , 1 , 51 ] <NEWLINE> pritn ( a [ k ] ) <NEWLINE>
a = [ 1 , 1 , 1 , 2 , 1 , 2 , 1 , 5 , 2 , 2 , 1 , 5 , 1 , 2 , 1 , 14 , 1 , 5 , 1 , 5 , 2 , 2 , 1 , 15 , 2 , 2 , 5 , 4 , 1 , 4 , 1 , 51 ] <NEWLINE> <NL> x = int ( input ( ) ) <NEWLINE> print ( a [ x - 1 ] <NEWLINE>
a = { 0 , 1 , 1 , 1 , 2 , 1 , 2 , 1 , 5 , 2 , 2 , 1 , 5 , 1 , 2 , 1 , 14 , <NEWLINE> <INDENT> 1 , 5 , 1 , 5 , 2 , 2 , 1 , 15 , 2 , 2 , 5 , 4 , 1 , 4 , 1 , 51 } <NEWLINE> <DEDENT> print ( a [ int ( input ( ) ) ] ) <NEWLINE>
H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = H * W <NEWLINE> if ans % 2 == 1 : <NEWLINE> <INDENT> print ( ans // 2 + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans // 2 <NEWLINE> <DEDENT>
a , b = map ( int , input ( ) ) <NEWLINE> ans = 0 <NEWLINE> if a * b % 2 == 0 : <NEWLINE> <INDENT> print ( a * b / 2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ( a * b - 1 ) / 2 + 1 ) <NEWLINE> <DEDENT>
h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> <INDENT> print ( ( h * w + 1 ) // 2 ) <NEWLINE> <DEDENT>
if A == 1 or B == 1 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> elif ( A * B ) % 2 == 0 : <NEWLINE> <INDENT> print ( A * B // 2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( A * B // 2 + 1 ) <NEWLINE> <DEDENT>
<COMMENT> <NL> H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> k = H * W <NEWLINE> if k % 2 == 0 : <NEWLINE> <INDENT> print ( int ( k / 2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( int ( k / 2 ) + 1 ) <NEWLINE> <DEDENT>
h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if h == 1 or w == 1 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if ( h * w ) % 2 == 0 : <NEWLINE> <INDENT> print ( ( h * w ) // 2 ) <NEWLINE> <DEDENT> elif : <NEWLINE> <INDENT> print ( ( ( h * W ) // 2 ) + 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT>
H , W = map ( int , input ( ) . split ) <NEWLINE> S = H * W <NEWLINE> if S % 2 == 1 : <NEWLINE> <INDENT> print ( H * W // 2 + 1 ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> print ( H * W / 2 ) <NEWLINE> <DEDENT>
<COMMENT> <NL> H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> count = 0 <NEWLINE> if H == 1 or W == 1 : <COMMENT> <NEWLINE> if H % 2 == 0 : <NEWLINE> <INDENT> count = ( H // 2 ) * W <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> count = ( H // 2 ) * W + ( ( W + 2 - 1 ) // 2 ) <COMMENT> <NEWLINE> <DEDENT> print ( count ) <NEWLINE>
a = [ int ( c ) for c in input ( ) . split ( ) ] <NEWLINE> r = a [ 0 ] * a [ 1 ] <NEWLINE> if a [ 0 ] == 1 or a [ 1 ] == 1 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else r % 2 == 0 : <NEWLINE> <INDENT> print ( int ( r / 2 ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( int ( r / 2 + 1 ) ) <NEWLINE> <DEDENT>
h , w = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> answer = ( h * w ) / 2 + ( h * w ) % 2 <NEWLINE> print ( answer ) <NEWLINE>
a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> if ( ( c - a - b > 0 ) and ( ( c - a - b ) ** 2 > 4 ab ) ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if 4 * a * b > ( c - a - b ) * ( c - a - b ) <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> x = c - b - a <NEWLINE> if x > 0 & & a * b * 4 < x * x : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import math <NEWLINE> <NL> from typing import List <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> a , b , c = input ( ) . split ( <STRING> ) <NEWLINE> <NL> if si ( [ a , b , c ] ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def si ( nums : List [ str ] ) -> bool : <NEWLINE> <INDENT> a , b , c = nums <NEWLINE> a *= 10 ** 8 <NEWLINE> b *= 10 ** 8 <NEWLINE> c *= 10 ** 8 <NEWLINE> <NL> if int ( math . sqrt ( a ) ) + int ( math . sqrt ( b ) ) < int ( math . sqrt ( c ) ) : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return False <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import math <NEWLINE> from decimal import Decimal <NEWLINE> a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if Decimal . sqrt ( a ) + Decimal . sqrt ( b ) < Decimal . sqrt ( c ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
<COMMENT> <NL> import decimal <NEWLINE> a , b , c = input ( ) . split ( ) <NEWLINE> a , b , c = map ( decimal . Decimal , [ a , b , c ] ) <NEWLINE> rta , rtb , rtc = map ( math . sqrt , [ a , b , c ] ) <NEWLINE> sqrt = decimal . Decimal ( 0.5 ) <NEWLINE> if a ** sqrt + b ** sqrt < c ** sqrt : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
<NL> def main ( ) : <NEWLINE> <INDENT> a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> rhs = c - a - b <NEWLINE> lhs = 4 * a * b <NEWLINE> if rhs > 0 and lhs ** 2 < rhs : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> main ( <NEWLINE>
from collections import deque <NEWLINE> import sys <NEWLINE> n = int ( input ( ) ) <NEWLINE> if n == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> q = deque ( [ ] ) <NEWLINE> q . append ( ( 1 , <STRING> , 1 ) ) <NEWLINE> cur = 1 <NEWLINE> while cur != n : <NEWLINE> <INDENT> num = len ( q ) <NEWLINE> j = 0 <NEWLINE> while j < num : <NEWLINE> <INDENT> a , b , c = q . popleft ( ) <NEWLINE> for i in range ( 1 , c + 2 ) : <NEWLINE> <INDENT> q . append ( ( i , b + chr ( 96 + i ) , max ( map ( int , list ( b + chr ( 96 + i ) ) ) ) ) <NEWLINE> <DEDENT> j += 1 <NEWLINE> <DEDENT> cur += 1 <NEWLINE> <NL> <DEDENT> for i in range ( len ( q ) ) : <NEWLINE> <INDENT> a , b , c = q . popleft ( ) <NEWLINE> print ( b ) <NEWLINE> <NL> <DEDENT>
N = int ( input ( ) ) <NEWLINE> string = [ 0 for i in range ( N ) ] <NEWLINE> calc_str = lambda : <STRING> . join ( list ( chr ( i + ord ( <STRING> ) ) for i in string ) ) <NEWLINE> chr_a = ord ( <STRING> ) <NEWLINE> print ( calc_str ( ) ) <NEWLINE> now = N - 2 <NEWLINE> <NL> <NL> while True : <NEWLINE> <INDENT> if string [ now + 1 ] - max ( string [ : now + 1 ] ) > 0 : <NEWLINE> <INDENT> if now == 0 : break <NEWLINE> string [ now + 1 ] = 0 <NEWLINE> now -= 1 <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> string [ now + 1 ] += 1 <NEWLINE> now = N - 2 <NEWLINE> <NL> print ( calc_str ( ) ) <NEWLINE> <DEDENT> <DEDENT>
s = input ( ) <NEWLINE> <NL> n = s . count ( <STRING> ) <NEWLINE> print ( <STRING> if n * 2 == len ( n ) else <STRING> ) <NEWLINE>
s = input ( ) <NEWLINE> if len ( s ) % 2 == 0 : <NEWLINE> <INDENT> for i in len ( s ) // 2 : <NEWLINE> <INDENT> if s [ 2 * i ] != <STRING> and s [ 2 * i + 1 ] != <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> p = <STRING> <NEWLINE> a = 0 <NEWLINE> if len ( s ) % 2 == 0 : <NEWLINE> <INDENT> for i in range ( len ( s ) // 2 + 1 ) : <NEWLINE> <INDENT> if str ( s [ a ] + s [ a + 1 ] ) == <STRING> : <NEWLINE> <INDENT> p = <STRING> <NEWLINE> a = a + 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> p = <STRING> <NEWLINE> break ; <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( p ) <NEWLINE>
s = input ( ) <NEWLINE> if s in hi : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> if len ( s ) % 2 = 0 and s == <STRING> * len ( s ) // 2 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> if s == <STRING> * len ( s ) // 2 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
A , B , M = map ( int , input ( ) . split ( ) ) <NEWLINE> F = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> M = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> C = [ ] <NEWLINE> <NL> for _ in range ( M ) : <NEWLINE> <INDENT> x , y , c = map ( int , input ( ) . split ( ) ) <NEWLINE> x -= 1 <NEWLINE> y -= 1 <NEWLINE> C . append ( ( x , y , c ) ) <NEWLINE> <NL> <DEDENT> minF = min ( F ) <NEWLINE> minM = min ( M ) <NEWLINE> ans = minF + minM <NEWLINE> <NL> for x , y , z in C : <NEWLINE> <INDENT> tmp = F [ x ] + F [ y ] - z <NEWLINE> if tmp < ans : <NEWLINE> <INDENT> ans = tmp <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<NL> A , B , M = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = min ( a ) + min ( b ) <NEWLINE> <NL> for _ in range ( M ) : <NEWLINE> <INDENT> x , y , c = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = min ( a [ x - 1 ] + b [ y - 1 ] - c , ans ) <NEWLINE> <NL> <DEDENT> prins ( ans ) <NEWLINE>
a , b , m = map ( int , input ( ) . split ( ) ) <NEWLINE> a_price = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b_price = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> coupon = [ ] <NEWLINE> for _ in range ( m ) : <NEWLINE> <INDENT> coupon . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> <DEDENT> a_copy = a_price . copy ( ) <NEWLINE> a_copy . sort ( ) <NEWLINE> b_copy = b_price . copy ( ) <NEWLINE> b_copy . sort ( ) <NEWLINE> a_min = a_copy [ 0 ] <NEWLINE> b_min = b_copy [ 0 ] <NEWLINE> min = a_min + b_min <NEWLINE> totals = [ min ] <NEWLINE> for list in coupon : <NEWLINE> <INDENT> tmp = a_list [ list [ 0 ] - 1 ] + b_list [ list [ 1 ] - 1 ] - list [ 2 ] <NEWLINE> totals . append ( tmp ) <NEWLINE> <NL> <DEDENT> totals . sort ( ) <NEWLINE> ans = totals [ 0 ] <NEWLINE> <NL> print ( ans ) <NEWLINE>
S = str ( input ( ) ) <NEWLINE> if len ( set ( S ) ) = 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> else : <NEWLINE> print ( Yes ) <NEWLINE> <DEDENT>
s = raw_input ( ) <NEWLINE> if ( s == <STRING> or s == <STRING> ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> <NL> if s = <STRING> or s = <STRING> : print ( <STRING> ) <NEWLINE> else : print ( <STRING> ) <NEWLINE>
s = set ( input ( ) . split ( <STRING> ) ) <NEWLINE> if len ( s ) == 2 : print ( <STRING> ) <NEWLINE> else : print ( <STRING> ) <NEWLINE>
s = input ( ) <NEWLINE> if AAA or BBB : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
S = input ( ) <NEWLINE> <NL> if S = <STRING> or <STRING> : print ( <STRING> ) <NEWLINE> else : print ( <STRING> ) <NEWLINE>
s = input ( ) <NEWLINE> ans = <STRING> <NEWLINE> <NL> if ( s == <STRING> | | s == <STRING> ) : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> S = input ( ) <NEWLINE> <NL> if not ( len ( S ) == 3 and ( <STRING> in S or <STRING> in S ) ) : sys . exit ( ) <NEWLINE> <NL> print ( <STRING> ) if S = <STRING> or S = <STRING> else print ( <STRING> ) <NEWLINE>
S = input ( ) <NEWLINE> if ( S = <STRING> or S = <STRING> ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> if s == <STRING> or s = <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
print ( <STRING> if S != <STRING> and S != <STRING> else <STRING> ) <NEWLINE>
S = input ( ) <NEWLINE> <NL> if <STRING> in S and <STRING> in S : <NEWLINE> <INDENT> prnt ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ptint ( <STRING> ) <NEWLINE> <DEDENT>
S = inpit ( ) <NEWLINE> <NL> ans = <STRING> <NEWLINE> <NL> if ( S == <STRING> ) or ( S == <STRING> ) : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
word = input ( ) <NEWLINE> a , b = 0 <NEWLINE> <NL> for i in word : <NEWLINE> <INDENT> if i == <STRING> : <NEWLINE> <INDENT> a = a + 1 <NEWLINE> <DEDENT> elif i == <STRING> : <NEWLINE> <INDENT> b = b + 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if a == 0 or b == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> <NL> if s = <STRING> or s = <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s = int ( input ( ) ) <NEWLINE> if s == <STRING> or s == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
S = input ( ) <NEWLINE> if S == <STRING> or S = <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
S = input ( ) <NEWLINE> if S == <STRING> or S = <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = input ( ) <NEWLINE> if all ( n == <STRING> or n == <STRING> ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
S = input ( ) <NEWLINE> if S [ 0 ] == S [ 1 ] and S [ 1 ] == S [ 2 ] : <NEWLINE> print ( <STRING> ) <NEWLINE> else : <NEWLINE> print ( <STRING> ) <NEWLINE>
s = input ( ) <NEWLINE> s . sort ( ) <NEWLINE> if s [ 0 ] != s [ 1 ] or s [ 1 ] != s [ 2 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
S = input ( ) <NEWLINE> if S = <STRING> or S = <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
<COMMENT> <NL> s = input ( ) <NEWLINE> print ( <STRING> if len ( set ( s ) ) == else <STRING> ) <NEWLINE>
S = input ( ) . split ( ) <NEWLINE> <NL> if S [ 0 ] == S [ 1 ] == S [ 2 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> if ( s = <STRING> or s = <STRING> ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
print ( ( <STRING> , <STRING> ) [ input ( ) in <STRING> or <STRING> ] ) <NEWLINE>
S = input ( ) <NEWLINE> print ( <STRING> if S == <STRING> or S == = <STRING> else <STRING> ) <NEWLINE>
s = input ( ) <NEWLINE> print ( <STRING> if s == <STRING> or s = <STRING> else <STRING> ) <NEWLINE>
S = input ( ) <NEWLINE> a = S . count ( <STRING> ) <NEWLINE> b = S . count ( <STRING> ) <NEWLINE> if a == 3 or b == 3 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
S = str ( input ( ) ) <NEWLINE> if S [ 1 ] + S [ 2 ] == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif S [ 2 ] + S [ 3 ] == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s = intput ( ) <NEWLINE> if s == <STRING> or s == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
print ( <STRING> if len ( set ( input ( ) ) == 1 else <STRING> ) <NEWLINE>
import sys <NEWLINE> print ( <STRING> if set ( sys . stdin . read ( ) . strip ( ) ) >= 2 else <STRING> ) <NEWLINE>
s = input ( ) <NEWLINE> if <STRING> , <STRING> in s : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> if a [ 0 ] == a [ 1 ] == a [ 2 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n , a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = n / ( a + b ) <NEWLINE> <INDENT> if n % ( a + b ) >= a : <NEWLINE> <INDENT> ans += a <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += n % ( a + b ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n , a , b = map ( int , input ( ) split ( ) ) <NEWLINE> div = n // ( a + b ) <NEWLINE> mod = n % ( a + b ) <NEWLINE> print ( div * a + min ( mod , a ) ) <NEWLINE>
n , a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> c == n % ( a + b ) <NEWLINE> if c > a : <NEWLINE> <INDENT> print ( a * ( n // ( a + b ) ) + a ) <NEWLINE> <DEDENT> elif c <= a <NEWLINE> <INDENT> print ( a * ( n // ( a + b ) ) + c ) <NEWLINE> <DEDENT>
N , A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> N , A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = N // ( A + B ) * A <NEWLINE> rem = N % ( A + B ) <NEWLINE> ans += min ( rem , A ) <NEWLINE> print ( ans ) <NEWLINE>
n , a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> s = a + b <NEWLINE> if n % s == 0 : <NEWLINE> <INDENT> print ( int ( n / s ) * a ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if n % s >= a : <NEWLINE> <INDENT> print ( int ( n // s + 1 ) * a ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( int ( n // s + ) * a + n % s ) <NEWLINE> <DEDENT> <DEDENT>
n = input ( ) <NEWLINE> A = input ( ) <NEWLINE> B = input ( ) <NEWLINE> z = A + B <NEWLINE> if n % z <= A : <NEWLINE> <INDENT> print ( int ( n / z ) * A + n % z ) <NEWLINE> <DEDENT> elif A <= n % z <= z : <NEWLINE> <INDENT> print ( int ( n / z ) * A ) <NEWLINE> <DEDENT>
N , A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> a = N // ( A + B ) <NEWLINE> if N % ( A + B ) == 0 : <NEWLINE> <INDENT> print ( a * A ) <NEWLINE> <DEDENT> elif N % ( A + B ) >= A : <NEWLINE> <INDENT> print ( a * A + A ) ) <NEWLINE> <DEDENT> elif N % ( A + B ) < A : <NEWLINE> <INDENT> print ( a * A + ( N % ( A + B ) ) ) <NEWLINE> <DEDENT>
n , a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if a != 0 : <NEWLINE> <INDENT> answer = n // ( a + b ) <NEWLINE> remainder = n % ( a + b ) <NEWLINE> print ( answer * a ) + min ( a , remainder ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT>
N , A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( N // ( A + B ) * A + min ( A , N % ( A + B ) ) <NEWLINE>
n , a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> x = n // ( a + b ) <NEWLINE> y = n - C1 * ( a + b ) <NEWLINE> if y >= a : <NEWLINE> <INDENT> y = a <NEWLINE> <DEDENT> print ( a * x + y ) <NEWLINE>
n , a , b = [ int ( i ) for i in input ( ) . split ] <NEWLINE> <NL> if a + b == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> c , r = n // ( a + b ) , n % ( a + b ) <NEWLINE> nblue = c * a + min ( a , r ) <NEWLINE> print ( nblue ) <NEWLINE> <DEDENT>
<COMMENT> <NL> import math <NEWLINE> <NL> count = 0 <NEWLINE> num , blue_num , red_num = map ( int , input ( ) . split ( ) ) <NEWLINE> all_ball = blue_num + red_num <NEWLINE> count = num // ( all_ball ) <NEWLINE> rest = n % all_ball <NEWLINE> print ( count * all_ball + min ( rest , blue_num ) ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> n , a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> q , mod = divmod ( n , ( a + b ) ) <NEWLINE> x = mod if mod < n else x = n <NEWLINE> print ( q * a + x ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
<INDENT> N , A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> i = N // ( A + B ) <NEWLINE> b = i * A <NEWLINE> t = N % ( A + B ) <NEWLINE> <NL> if t > A : <NEWLINE> <INDENT> t = A <NEWLINE> <NL> <DEDENT> print ( b + t ) <NEWLINE> <DEDENT>
a = [ i for i in range ( int ( ( A - 1 ) * 100 / 8 ) , int ( ( A + 1 ) * 100 / 8 ) ) ] <NEWLINE> b = [ i for i in range ( int ( ( B - 1 ) * 100 / 10 ) , int ( ( B + 1 ) * 100 / 10 ) ) ] <NEWLINE> <NL> a = [ i for i in a if int ( i * 0.08 ) == A ] <NEWLINE> b = [ i for i in b if int ( i * 0.10 ) == B ] <NEWLINE> <NL> ans = list ( set ( a ) & set ( b ) ) <NEWLINE> if ans and min ( ans ) > 0 : <NEWLINE> <INDENT> print ( min ( ans ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT>
a , b = map ( int , input ( ) ) <NEWLINE> <NL> e = 0 <NEWLINE> t = 0 <NEWLINE> <NL> for i in range ( 1 , 100 ) : <NEWLINE> <INDENT> if a <= i * 0.08 < a + 1 : <NEWLINE> <INDENT> e = i <NEWLINE> <DEDENT> if b <= i * 0.1 < b + 1 : <NEWLINE> <INDENT> t = i <NEWLINE> <DEDENT> if e == t : <NEWLINE> <INDENT> print ( e ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( - 1 ) <NEWLINE>
import math <NEWLINE> <NL> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> volume_A = A / 0.08 <NEWLINE> volume_B = B / 0.1 <NEWLINE> <NL> min_A , max_A = volume_A , volume_A <NEWLINE> range_A = 1 / 0.08 <NEWLINE> min_B , max_B = volume_B , volume_B <NEWLINE> range_B = 1 / 0.1 <NEWLINE> <NL> for i in range ( math . floor ( volume_A - range_A ) , math . ceil ( volume_A + range_A ) ) : <NEWLINE> <INDENT> if math . floor ( i * 0.08 ) == A : <NEWLINE> <INDENT> min_A = min ( min_A , i ) <NEWLINE> max_A = max ( max_A , i ) <NEWLINE> <NL> <DEDENT> <DEDENT> for j in range ( math . floor ( volume_B - range_B ) , math . ceil ( volume_B + range_B ) ) : <NEWLINE> <INDENT> if math . floor ( j * 0.1 ) == B : <NEWLINE> <INDENT> min_B = min ( min_B , j ) <NEWLINE> max_B = max ( max_B , j ) <NEWLINE> <NL> <DEDENT> <DEDENT> ans_A = set ( ) <NEWLINE> for i in range ( min_A , max_A + 1 ) : <NEWLINE> <INDENT> ans_A . add ( i ) <NEWLINE> <NL> <DEDENT> ans_B = set ( ) <NEWLINE> for j in range ( min_B , max_B + 1 ) : <NEWLINE> <INDENT> ans_B . add ( j ) <NEWLINE> <NL> <DEDENT> ans = ans_A & ans_B <NEWLINE> <NL> if len ( ans ) == 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( min ( ans ) ) <NEWLINE> <DEDENT>
a , b = map ( int ( input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in range ( 1300 ) : <NEWLINE> <INDENT> if i == a * 12.5 and b * 10 : <NEWLINE> <INDENT> print ( i ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( - 1 ) <NEWLINE>
a_s = a / 1.08 <NEWLINE> a_t = ( a + 1 ) / 1.08 <NEWLINE> b_s = b / 1.1 <NEWLINE> b_t = ( b + 1 ) / 1.1 <NEWLINE> <NL> a0 = int ( a_s ) <NEWLINE> a1 = int ( a_t ) <NEWLINE> b0 = int ( b_s ) <NEWLINE> b1 = int ( b_t ) <NEWLINE> <NL> <NL> if ( a_s - a0 ) > 0 : <NEWLINE> <INDENT> a0 += 1 <NEWLINE> <DEDENT> if ( a_t - a1 ) <= 0 : <NEWLINE> <INDENT> a1 -= 1 <NEWLINE> <DEDENT> if ( b_s - b0 ) > 0 : <NEWLINE> <INDENT> b0 += 1 <NEWLINE> <DEDENT> if ( b_t - b1 ) <= 0 : <NEWLINE> <INDENT> b1 -= 1 <NEWLINE> <NL> <DEDENT> lista = [ i for i in range ( a0 , a1 + 1 ) ] <NEWLINE> listb = [ i for i in range ( b0 , b1 + 1 ) ] <NEWLINE> <NL> ansl = [ ] <NEWLINE> for j in range ( len ( lista ) ) : <NEWLINE> <INDENT> if lista [ j ] in listb : <NEWLINE> <INDENT> ansl . append ( lista [ j ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> if not ansl == [ ] : <NEWLINE> <INDENT> ans = ansl [ 0 ] <NEWLINE> print ( ans ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = - 1 <NEWLINE> for i in range ( 10000 , - 1 , - 1 ) : <NEWLINE> <INDENT> money0 = int ( i * 0.08 ) <NEWLINE> money1 = int ( i * 0.1 ) <NEWLINE> if money0 == a and money1 == b : <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> for i in range ( 10000 ) : <NEWLINE> <INDENT> if int ( i * 0.08 ) == A and int ( i * 0.1 ) == B : <NEWLINE> <INDENT> print ( i ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> x1 = a * 100 // 8 <NEWLINE> x2 = b * 10 <NEWLINE> <INDENT> if x1 // 10 == b : <NEWLINE> <INDENT> print ( x1 ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT>
import math <NEWLINE> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> eight = [ ] <NEWLINE> i = 0 <NEWLINE> ten = [ ] <NEWLINE> for a in range ( 1 , 1001 ) : <NEWLINE> <INDENT> if math . floor ( a * 0.08 ) == A : <NEWLINE> <INDENT> eight . append ( a ) <NEWLINE> <DEDENT> if math . floor ( a * 0.1 ) == B : <NEWLINE> <INDENT> ten . append ( a ) <NEWLINE> <NL> <DEDENT> <DEDENT> for a in eight : <NEWLINE> <INDENT> if a in ten : <NEWLINE> <INDENT> print ( a ) <NEWLINE> i = 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if i = 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> for x in range ( 101 ) : <NEWLINE> <INDENT> if ( x * 1.08 ) // 1 == a + x and ( x * 1.10 ) // 1 == b + x and x // 1 = int ( x ) : <NEWLINE> <INDENT> print ( int ( x ) ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( - 1 ) <NEWLINE>
import sys <NEWLINE> <NL> A , B = map ( float , input ( ) . split ( ) ) <NEWLINE> <NL> val_1 = A / 0.08 <NEWLINE> val_2 = B / 0.10 <NEWLINE> <NL> i = 1 <NEWLINE> <NL> if int ( val_1 ) == int ( val_2 ) : <NEWLINE> <INDENT> print ( int ( val_1 ) ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if val_1 > val_2 : <NEWLINE> <INDENT> while val_1 != val_2 : <NEWLINE> <INDENT> val_2 = ( B + 0.1 * i ) / 0.1 <NEWLINE> i += 1 <NEWLINE> if val_1 < val_2 : <NEWLINE> <DEDENT> print ( - 1 ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> print ( int ( val_1 ) ) <NEWLINE> elif val_1 < val_2 : <NEWLINE> <INDENT> while val_1 != val_2 : <NEWLINE> <INDENT> val_1 = ( A + 0.1 * i ) / 0.1 <NEWLINE> i += 1 <NEWLINE> if val_1 > val_2 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( int ( val_1 ) ) <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> S = input ( ) <NEWLINE> Q = int ( input ( ) ) <NEWLINE> key = 1 <NEWLINE> <NL> for i in sys . stdin : <NEWLINE> <INDENT> if i [ 0 ] == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> if i [ 0 ] == <STRING> : <NEWLINE> <INDENT> key = - key <NEWLINE> <NL> <DEDENT> if key == 1 : <NEWLINE> <INDENT> if i [ 2 ] == <STRING> : <NEWLINE> <INDENT> S = i [ 4 ] + S <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> S = S + i [ 4 ] <NEWLINE> <NL> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if i [ 2 ] == <STRING> : <NEWLINE> <INDENT> S = i [ 4 ] + S <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> S = S + i [ 4 ] <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> print ( S [ : : key ] ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> from fractions import gcd <NEWLINE> from itertools import combinations , permutations , accumulate , product <COMMENT> <NEWLINE> <COMMENT> <NL> from collections import deque , defaultdict , Counter <NEWLINE> import decimal <NEWLINE> import re <NEWLINE> import math <NEWLINE> import bisect <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> import sys <NEWLINE> sys . setrecursionlimit ( 10000000 ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> from sys import stdin <NEWLINE> readline = stdin . readline <NEWLINE> def readInts ( ) : <NEWLINE> <INDENT> return list ( map ( int , readline ( ) . split ( ) ) ) <NEWLINE> <DEDENT> def readTuples ( ) : <NEWLINE> <INDENT> return tuple ( map ( int , readline ( ) . split ( ) ) ) <NEWLINE> <DEDENT> def I ( ) : <NEWLINE> <INDENT> return int ( readline ( ) ) <NEWLINE> <DEDENT> s = input ( ) <NEWLINE> q = I ( ) <NEWLINE> straight = True <NEWLINE> ans = deque ( s ) <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> A = input ( ) . split ( ) <NEWLINE> if A [ 0 ] == <STRING> : <NEWLINE> <INDENT> straight = not straight <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if straight : <NEWLINE> <INDENT> if A [ 1 ] == <STRING> : <NEWLINE> <INDENT> ans . append ( A [ 2 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans . appendleft ( A [ 2 ] ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if A [ 1 ] == <STRING> : <NEWLINE> <INDENT> ans . appendleft ( A [ 2 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans . append ( A [ 2 ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if straight : <NEWLINE> <INDENT> print ( * ans , sep = <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( * an [ : : - 1 ] , sep = <STRING> ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> s = [ ] <NEWLINE> r = [ ] <NEWLINE> for i in S : <NEWLINE> <INDENT> s . append ( i ) <NEWLINE> <DEDENT> t = 1 <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> qv = list ( input ( ) . split ( ) ) <NEWLINE> if qv [ 0 ] == <STRING> : <NEWLINE> <INDENT> t ^= 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if int ( qv [ 1 ] ) ^ t == 0 or int ( qv [ 1 ] ) ^ t == 2 : <NEWLINE> <INDENT> r . append ( qv [ 2 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s . append ( qv [ 2 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if t == 0 : <NEWLINE> <INDENT> ss = s . copy ( ) <NEWLINE> s = [ ] <NEWLINE> for j in range ( len ( ss ) ) : <NEWLINE> <INDENT> s . append ( ss [ - 1 - j ] ) <NEWLINE> <DEDENT> ans = s <NEWLINE> ans . extend ( r ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> rr = r . copy ( ) <NEWLINE> r = [ ] <NEWLINE> for j in range ( len ( rr ) ) : <NEWLINE> <INDENT> r . append ( rr [ - 1 - j ] ) <NEWLINE> <DEDENT> ans = r <NEWLINE> ans . extend ( s ) <NEWLINE> <DEDENT> answer = <STRING> . join ( ans ) <NEWLINE> print ( answer ) <NEWLINE>
from collections import deque <NEWLINE> <NL> z = list ( input ( ) ) <NEWLINE> Q = deque ( ) <NEWLINE> Q . append ( z ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> <NL> cnt = 0 <NEWLINE> <NL> for i in range ( q ) : <NEWLINE> <INDENT> x = input ( ) <NEWLINE> if x [ 0 ] == <STRING> : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> cnt %= 2 <NEWLINE> <NL> <DEDENT> elif x [ 0 ] == <STRING> : <NEWLINE> <INDENT> if x [ 2 ] == <STRING> : <NEWLINE> <INDENT> if cnt % 2 == 0 : <NEWLINE> <INDENT> Q . appendleft ( x [ 4 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> Q . append ( x [ 4 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if cnt % 2 == 0 : <NEWLINE> <INDENT> Q . append ( x [ 4 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> Q . appendleft ( x [ 4 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if cnt % 2 == 1 : <NEWLINE> <INDENT> Q . reverse ( ) <NEWLINE> <NL> <NL> <DEDENT> print ( <STRING> . join ( Q ) ) <NEWLINE>
from collections import deque <NEWLINE> <NL> z = list ( input ( ) ) <NEWLINE> Q = deque ( ) <NEWLINE> Q . append ( ( z ) ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> <NL> cnt = 0 <NEWLINE> <NL> for i in range ( q ) : <NEWLINE> <INDENT> x = input ( ) <NEWLINE> if x [ 0 ] == <STRING> : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> cnt %= 2 <NEWLINE> <NL> <DEDENT> elif x [ 0 ] == <STRING> : <NEWLINE> <INDENT> if x [ 2 ] == <STRING> : <NEWLINE> <INDENT> if cnt % 2 == 0 : <NEWLINE> <INDENT> Q . appendleft ( x [ 4 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> Q . append ( x [ 4 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if cnt % 2 == 0 : <NEWLINE> <INDENT> Q . append ( x [ 4 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> Q . appendleft ( x [ 4 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if cnt % 2 == 1 : <NEWLINE> <INDENT> Q . reverse ( ) <NEWLINE> <NL> <NL> <DEDENT> print ( <STRING> . join ( Q ) ) <NEWLINE>
s = input ( ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> h = 0 <NEWLINE> m = <STRING> <NEWLINE> u = <STRING> <NEWLINE> for _ in range ( q ) : <NEWLINE> <INDENT> d = input ( ) <NEWLINE> if <STRING> in d : <NEWLINE> <INDENT> a , b , c = map ( str , d . split ( ) ) <NEWLINE> if b == <STRING> : <NEWLINE> <INDENT> if h % 2 == 0 : <NEWLINE> <INDENT> u += c <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> m += c <NEWLINE> <NL> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if h % 2 == 0 : <NEWLINE> <INDENT> m += c <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> u += c <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> h += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> M = list ( m ) <NEWLINE> G = list ( reversed ( M ) ) <NEWLINE> s = G + s + u <NEWLINE> if h % 2 == 0 : <NEWLINE> <INDENT> print ( s ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> f = list ( s ) <NEWLINE> g = list ( reversed ( f ) ) <NEWLINE> print ( <STRING> . join ( g ) ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> q = int ( ionput ( ) ) <NEWLINE> h , t = [ ] , [ ] <NEWLINE> p = 0 <NEWLINE> <NL> for i in range ( q ) : <NEWLINE> <INDENT> c = input ( ) . split ( ) <NEWLINE> if c [ 0 ] == <STRING> : <NEWLINE> <INDENT> h , t = t , h <NEWLINE> p = 1 - p <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if c [ 1 ] == <STRING> : <NEWLINE> <INDENT> h . append ( c [ 2 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> t . append ( c [ 2 ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if p == 1 : <NEWLINE> <INDENT> s = s [ : : - 1 ] <NEWLINE> <DEDENT> print ( <STRING> . join ( h [ : : - 1 ] ) + s + <STRING> . join ( t ) ) <NEWLINE>
import sys <NEWLINE> from collections import defaultdict <NEWLINE> <NL> def solve ( ) : <NEWLINE> <INDENT> input = sys . stdin . readline <NEWLINE> N , P = map ( int , input ( ) . split ( ) ) <NEWLINE> S = input ( ) . strip ( <STRING> ) <NEWLINE> modSum = 0 <NEWLINE> modSum = int ( S [ 0 ] ) % P <NEWLINE> modDict = defaultdict ( int ) <NEWLINE> ans = 0 <NEWLINE> <NL> if P == 2 or P == 5 : <NEWLINE> <INDENT> for i in range ( N ) : <NEWLINE> <INDENT> if int ( S [ i ] ) % P == 0 : <NEWLINE> <INDENT> ans += i + 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> modDict [ modSum [ 0 ] ] += 1 <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> modSum = ( ( modSum * 10 ) + int ( S [ i ] ) ) % P <NEWLINE> modDict [ modSum ] += 1 <NEWLINE> <NL> <DEDENT> for key in modDict : <NEWLINE> <INDENT> v = modDict [ key ] <NEWLINE> if key > 0 : ans += v * ( v - 1 ) // 2 <NEWLINE> else : ans += v + ( v * ( v - 1 ) // 2 ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> return 0 <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> solve ( ) <NEWLINE> <DEDENT>
inport math <NEWLINE> n = int ( input ( ) ) <NEWLINE> print ( math . ceil ( n / 2 ) ) <NEWLINE>
import io <NEWLINE> import sys <NEWLINE> <NL> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> sc = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( m ) ] <NEWLINE> <NL> d = { } <NEWLINE> <NL> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> d [ i ] = None <NEWLINE> <NL> <DEDENT> for itm in sc : <NEWLINE> <INDENT> if ( d [ itm [ 0 ] ] == None ) | ( d [ itm [ 0 ] ] == itm [ 1 ] ) : <NEWLINE> <INDENT> d [ itm [ 0 ] ] = itm [ 1 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> l = list ( d . values ( ) ) <NEWLINE> if l == [ 0 ] : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> elif l [ 0 ] == 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> l = [ 0 if x == None else x for x in l ] <NEWLINE> l [ 0 ] = [ 1 if x == 0 else x for x in l ] <NEWLINE> l = map ( str , l ) <NEWLINE> print ( <STRING> . join ( l ) ) <NEWLINE> <DEDENT>
n = input ( ) <NEWLINE> print ( ( n // 2 ) + ( n % 2 ) ) <NEWLINE>
a = iint ( input ( ) ) <NEWLINE> print ( a / 2 if a % 2 == 1 else a // 2 + 1 ) <NEWLINE>
import math <NEWLINE> N = int ( input ( ) . split ( ) ) <NEWLINE> print ( math . ceil ( N / 2 ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> print ( ( N + 1 / 2 ) <NEWLINE>
if n % 2 == 0 : <NEWLINE> <INDENT> ans = n / 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = n // 2 + 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
<NL> def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> if n % 2 = 1 : <NEWLINE> <INDENT> print ( n // 2 + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( n / 2 ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = input ( ) <NEWLINE> if n % 2 == 0 : <NEWLINE> <INDENT> print ( n / 2 ) <NEWLINE> <DEDENT> if not n % 2 == 0 : <NEWLINE> <INDENT> print ( n / 2 + 1 ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> <NL> print ( N // 2 + ( if N % 2 != 0 ) ) <NEWLINE>
N , X = 6 , 1 <NEWLINE> ARR = [ 1 , 6 , 1 , 2 , 0 , 4 ] <NEWLINE> <NL> N , X = 3 , 3 <NEWLINE> ARR = [ 2 , 2 , 2 ] <NEWLINE> <NL> N , X = 5 , 9 <NEWLINE> ARR = [ 3 , 1 , 4 , 1 , 5 ] <NEWLINE> <NL> N , X = 2 , 0 <NEWLINE> ARR = [ 5 , 5 ] <NEWLINE> <NL> N , X = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> ARR = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> def calculate ( n , x , arr ) : <NEWLINE> <INDENT> result = 0 <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> sSum = arr [ i - 1 ] + arr [ i ] <NEWLINE> if sSum <= x : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <DEDENT> diff = sSum - x <NEWLINE> <NL> if diff <= arr [ i ] : <NEWLINE> <INDENT> arr [ i ] -= diff <NEWLINE> result += diff <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> result += diff <NEWLINE> arr [ i ] = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( result ) <NEWLINE> <NL> <NL> <DEDENT> calculate ( N , X , ARR ) <NEWLINE>
x = int ( input ( ) ) <NEWLINE> <NL> print ( n + 1 // 2 ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> import math <NEWLINE> print ( math . celi ( N / 2 ) ) <NEWLINE>
<NL> num = int ( input ( ) ) <NEWLINE> if num % 2 == 0 : <NEWLINE> <INDENT> print ( n / 2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( n / 2 + 1 ) <NEWLINE> <DEDENT>
print ( int ( input ) + 1 // 2 ) <NEWLINE>
n = int ( input ) <NEWLINE> if n % 2 == 0 : <NEWLINE> <INDENT> print ( int ( n * 0.5 ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( int ( 0.5 * n ) + 1 ) <NEWLINE> <DEDENT>
num = int ( input ( ) ) <NEWLINE> if num % 2 == 0 : <NEWLINE> <INDENT> ans = num / 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = math . floor ( num // 2 ) + 1 <NEWLINE> <DEDENT> print ( int ( ans ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> pritn ( ( N + 1 ) // 2 ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> prnit ( N // 2 + N % 2 ) <NEWLINE>
pages = int ( input ( ) ) <NEWLINE> papers = round ( pages / 2 + pages % 2 ) <NEWLINE> <NL> if pages % 2 = 0 : <NEWLINE> <INDENT> print ( papers ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( pages / 2 + pages % 2 - 1 ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> if n % 2 = 0 : <NEWLINE> <INDENT> print ( n // 2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( n // 2 + 1 ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> <INDENT> if N % 2 == 1 : <NEWLINE> <INDENT> print ( ( N + 1 ) / 2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( N / 2 ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> main ( ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> if n % 2 = 1 : <NEWLINE> <INDENT> print ( n // 2 + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( n / 2 ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> N = map ( int , open ( 0 ) . read ( ) . split ( ) ) <NEWLINE> print ( - ( - N // 2 ) ) <NEWLINE> <NL> <NL> <DEDENT> main ( ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> if n % 2 = 0 : <NEWLINE> <INDENT> print ( n // 2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( n // 2 + 1 ) <NEWLINE> <DEDENT>
n = int ( inpur ( ) ) <NEWLINE> <NL> if n % 2 == 0 : <NEWLINE> <INDENT> print ( int ( n / 2 ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( int ( ( n / 2 ) + 1 ) ) <NEWLINE> <DEDENT>
a = int ( input ( ) ) <NEWLINE> if a % 2 = 0 : <NEWLINE> <INDENT> print ( str ( int ( a // 2 ) ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( str ( int ( a // 2 ) + 1.0 ) ) <NEWLINE> <DEDENT>
import math <NEWLINE> n int ( input ( ) ) <NEWLINE> print ( math . ceil ( n / 2 ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> print int ( n // 2 ) + n % 2 <NEWLINE>
a = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( 3 ) ] <NEWLINE> n = int ( input ( ) ) <NEWLINE> b = [ i for i in range ( n ) ] <NEWLINE> <NL> for i in range ( 3 ) : <NEWLINE> <INDENT> for j in range ( 3 ) : <NEWLINE> <INDENT> if a [ i ] [ j ] in b : <NEWLINE> <INDENT> a [ i ] [ j ] == 0 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> if any ( i . count ( 0 ) == 3 for i in a ) ) <NEWLINE> print ( <STRING> if any ( i . count ( 0 ) == 3 for i in zip ( * a ) ) ) <NEWLINE>
60 88 34 <NEWLINE> 92 41 43 <NEWLINE> 65 73 48 <NEWLINE> 10 <NEWLINE> 60 <NEWLINE> 43 <NEWLINE> 88 <NEWLINE> 11 <NEWLINE> 48 <NEWLINE> 73 <NEWLINE> 65 <NEWLINE> 41 <NEWLINE> 92 <NEWLINE> 34 <NEWLINE>
p , r = input , range <NEWLINE> A = sum ( [ list ( map ( int , p ( ) . split ( ) ) ) for _ in r ( 3 ) ] , [ ] ) <NEWLINE> b = [ int ( p ( ) ) for _ in r ( int ( p ( ) ) ) ] <NEWLINE> print ( <STRING> [ [ v for v in [ 7 , 56 , 73 , 84 , 146 , 273 , 292 , 448 ] if sum ( 1 << i for i in r ( 9 ) if A [ i ] in b ) & v == v ] : : 2 ] ) <NEWLINE>
l = [ map ( int , input ( ) . split ( ) ) for i in range ( 3 ) ] <NEWLINE> N = int ( input ( ) ) <NEWLINE> q = [ int ( input ( ) ) for i in range ( N ) ] <NEWLINE> <NL> for i in range ( 3 ) : <NEWLINE> <INDENT> for j in range ( 3 ) : <NEWLINE> <INDENT> for k in range ( N ) : <NEWLINE> <INDENT> if l [ i ] [ j ] == q [ k ] : <NEWLINE> <INDENT> l [ i ] [ j ] == 0 <NEWLINE> <NL> <DEDENT> if l [ 0 ] [ 0 ] == 0 and l [ 0 ] [ 1 ] == 0 and l [ 0 ] [ 2 ] == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> elif l [ 1 ] [ 0 ] == 0 and l [ 1 ] [ 1 ] == 0 and l [ 1 ] [ 2 ] == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> elif l [ 2 ] [ 0 ] == 0 and l [ 2 ] [ 1 ] == 0 and l [ 2 ] [ 2 ] == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> elif l [ 0 ] [ 0 ] == 0 and l [ 1 ] [ 1 ] == 0 and l [ 2 ] [ 2 ] == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> elif l [ 0 ] [ 2 ] == 0 and l [ 1 ] [ 1 ] == 0 and l [ 2 ] [ 0 ] == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> elif l [ 0 ] [ 0 ] == 0 and l [ 1 ] [ 0 ] == 0 and l [ 2 ] [ 0 ] == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> elif l [ 0 ] [ 1 ] == 0 and l [ 1 ] [ 1 ] == 0 and l [ 2 ] [ 1 ] == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> elif l [ 0 ] [ 2 ] == 0 and l [ 1 ] [ 2 ] == 0 and l [ 2 ] [ 2 ] == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
bingo = [ ] <NEWLINE> for i in range ( 3 ) : <NEWLINE> <INDENT> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> bingo . append ( a ) <NEWLINE> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> b = int ( input ( ) ) <NEWLINE> for j in range ( 3 ) : <NEWLINE> <INDENT> if b in bingo [ i ] : <NEWLINE> <INDENT> bingo [ i ] [ bingo [ i ] . index ( b ) ] = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> def hantei ( l ) : <NEWLINE> <INDENT> for i in range ( 3 ) : <NEWLINE> <INDENT> if all ( [ l [ i ] [ j ] == 0 for j in range ( 3 ) ] ) : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <NL> <DEDENT> elif all ( [ l [ j ] [ i ] == 0 for j in range ( 3 ) ] ) : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <NL> <DEDENT> elif l [ 0 ] [ 0 ] == 0 and l [ 1 ] [ 1 ] == 0 and l [ 2 ] [ 2 ] == 0 : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <NL> <DEDENT> elif l [ 0 ] [ 2 ] == 0 and l [ 1 ] [ 1 ] == 0 and l [ 2 ] [ 0 ] == 0 : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( hantei ( bingo ) ) <NEWLINE> <NL>
a_1 = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a_2 = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a_3 = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = [ a_1 , a_2 , a_3 ] <NEWLINE> n = int ( input ( ) ) : <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> h = int ( input ( ) ) <NEWLINE> for j in range ( 3 ) : <NEWLINE> <INDENT> for k in range ( 3 ) : <NEWLINE> <INDENT> if ( a [ j ] [ k ] == h ) : <NEWLINE> <INDENT> a [ j ] [ k ] = 0 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> ans = <STRING> <NEWLINE> for i in range ( 3 ) : <NEWLINE> <INDENT> if ( a [ i ] [ 0 ] == 0 ) and ( a [ i ] [ 0 ] == a [ i ] [ 1 ] ) and ( a [ i ] [ 1 ] == a [ i ] [ 2 ] ) : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <DEDENT> <DEDENT> for i in range ( 3 ) : <NEWLINE> <INDENT> if ( a [ 0 ] [ i ] == 0 ) and ( a [ 0 ] [ i ] == a [ 1 ] [ i ] ) and ( a [ 1 ] [ i ] == a [ 2 ] [ i ] ) : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <DEDENT> <DEDENT> if ( ( a [ 0 ] [ 0 ] == 0 ) and ( a [ 1 ] [ 1 ] == a [ 2 ] [ 2 ] ) and ( a [ 0 ] [ 0 ] == a [ 1 ] [ 1 ] ) ) or ( ( a [ 0 ] [ 2 ] == 0 ) and ( a [ 1 ] [ 1 ] == a [ 2 ] [ 0 ] ) and ( a [ 0 ] [ 2 ] == a [ 1 ] [ 1 ] ) ) : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE> <NL>
<COMMENT> <NL> using namespace std ; <NEWLINE> void print ( ) { <NEWLINE> <INDENT> cout << endl ; <NEWLINE> <DEDENT> } <NEWLINE> template < class Head , class ... Tail > <NEWLINE> void print ( Head & & head , Tail & & ... tail ) { <NEWLINE> <INDENT> cout << head ; <NEWLINE> if ( sizeof ... ( tail ) != 0 ) <NEWLINE> <INDENT> cout << <STRING> ; <NEWLINE> <DEDENT> print ( forward < Tail > ( tail ) ... ) ; <NEWLINE> <DEDENT> } <NEWLINE> template < class T > <NEWLINE> void print ( vector < T > & vec ) { <NEWLINE> <INDENT> for ( auto & a : vec ) { <NEWLINE> <INDENT> cout << a ; <NEWLINE> if ( & a != & vec . back ( ) ) <NEWLINE> <INDENT> cout << <STRING> ; <NEWLINE> <DEDENT> <DEDENT> } <NEWLINE> cout << endl ; <NEWLINE> <DEDENT> } <NEWLINE> template < class T > <NEWLINE> void print ( vector < vector < T >> & df ) { <NEWLINE> <INDENT> for ( auto & vec : df ) { <NEWLINE> <INDENT> print ( vec ) ; <NEWLINE> <DEDENT> } <NEWLINE> <DEDENT> } <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> using ll = long long ; <NEWLINE> const int INF = 100100100 ; <NEWLINE> <NL> vector < vector < int >> A ( 3 ) ; <NEWLINE> <NL> bool bingo ( vector < int > B ) { <NEWLINE> <INDENT> int cnt1 = 0 ; <NEWLINE> for ( int b : B ) { <NEWLINE> <INDENT> rep ( y , 3 ) { <NEWLINE> <INDENT> rep ( x , 3 ) { <NEWLINE> <INDENT> if ( A [ y ] [ x ] == b ) { <NEWLINE> <INDENT> + + cnt1 ; <NEWLINE> <DEDENT> } <NEWLINE> <DEDENT> } <NEWLINE> <DEDENT> } <NEWLINE> <DEDENT> } <NEWLINE> if ( cnt1 == 3 ) return true ; <NEWLINE> int cnt2 = 0 ; <NEWLINE> for ( int b : B ) { <NEWLINE> <INDENT> rep ( y , 3 ) { <NEWLINE> <INDENT> rep ( x , 3 ) { <NEWLINE> <INDENT> if ( A [ x ] [ y ] == b ) { <NEWLINE> <INDENT> + + cnt2 ; <NEWLINE> <DEDENT> } <NEWLINE> <DEDENT> } <NEWLINE> <DEDENT> } <NEWLINE> <DEDENT> } <NEWLINE> if ( cnt2 == 3 ) return true ; <NEWLINE> int cnt3 = 0 ; <NEWLINE> for ( int b : B ) { <NEWLINE> <INDENT> rep ( i , 3 ) { <NEWLINE> <INDENT> if ( b == A [ i ] [ i ] ) + + cnt3 ; <NEWLINE> <DEDENT> } <NEWLINE> <DEDENT> } <NEWLINE> if ( cnt3 == 3 ) { <NEWLINE> <INDENT> return true ; <NEWLINE> <DEDENT> } <NEWLINE> <NL> int cnt4 = 0 ; <NEWLINE> for ( int b : B ) { <NEWLINE> <INDENT> rep ( i , 3 ) { <NEWLINE> <INDENT> if ( b == A [ 2 - i ] [ i ] ) + + cnt4 ; <NEWLINE> <DEDENT> } <NEWLINE> <DEDENT> } <NEWLINE> if ( cnt4 == 3 ) { <NEWLINE> <INDENT> return true ; <NEWLINE> <DEDENT> } <NEWLINE> return false ; <NEWLINE> <DEDENT> } <NEWLINE> <NL> int main ( ) { <NEWLINE> <INDENT> vector < int > row ( 3 ) ; <NEWLINE> rep ( i , 3 ) { <NEWLINE> <INDENT> rep ( j , 3 ) { <NEWLINE> <INDENT> cin >> row [ j ] ; <NEWLINE> <DEDENT> } <NEWLINE> A [ i ] = row ; <NEWLINE> <DEDENT> } <NEWLINE> int N ; <NEWLINE> cin >> N ; <NEWLINE> vector < int > B ( N ) ; <NEWLINE> rep ( i , N ) { <NEWLINE> <INDENT> cin >> B [ i ] ; <NEWLINE> <DEDENT> } <NEWLINE> <NL> bool flag = bingo ( B ) ; <NEWLINE> <NL> if ( flag ) { <NEWLINE> <INDENT> print ( <STRING> ) ; <NEWLINE> <DEDENT> } <NEWLINE> else { <NEWLINE> <INDENT> print ( <STRING> ) ; <NEWLINE> <DEDENT> } <NEWLINE> <NL> <NL> <NL> return 0 ; <NEWLINE> <DEDENT> } <NEWLINE>
A11 , A12 , A13 = input ( ) . split ( <STRING> ) <NEWLINE> A21 , A22 , A23 = input ( ) . split ( <STRING> ) <NEWLINE> A31 , A32 , A33 = input ( ) . split ( <STRING> ) <NEWLINE> A11 = int ( A11 ) <NEWLINE> A12 = int ( A12 ) <NEWLINE> A13 = int ( A13 ) <NEWLINE> A21 = int ( A21 ) <NEWLINE> A22 = int ( A22 ) <NEWLINE> A23 = int ( A23 ) <NEWLINE> A31 = int ( A31 ) <NEWLINE> A32 = int ( A32 ) <NEWLINE> A33 = int ( A33 ) <NEWLINE> N = int ( input ( ) ) <NEWLINE> b = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> bi = int ( input ( ) ) <NEWLINE> b . append ( bi ) <NEWLINE> <DEDENT> if A11 in b and A12 in b and A13 in b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif A21 in b and A22 in b and A23 in b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif A31 in b and A32 in b and A33 in b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif A11 in b and A21 in b and A31 in b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif A12 in band A22 in b and A32 in b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif A13 in b and A23 in b and A33 in b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif A11 in b and A22 in b and A33 in b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif A13 in b and A22 in b and A31 in b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
map_list = [ int , input ( ) . split ( ) for x in range ( 3 ) ] <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a = int ( input ( ) ) <NEWLINE> <DEDENT>
A . append ( input ( ) . split ( ) ) <NEWLINE> A . append ( input ( ) . split ( ) ) <NEWLINE> A . append ( input ( ) . split ( ) ) <NEWLINE> N = int ( input ( ) ) <NEWLINE> b = [ input ( ) for _ in range ( N ) ] <NEWLINE> <NL> <COMMENT> <NL> for i in range ( N ) : <NEWLINE> <INDENT> for j in range ( 3 ) : <NEWLINE> <INDENT> if b [ i ] in A [ j ] : A [ j ] [ A [ j ] . index ( b [ i ] ) ] = True <NEWLINE> <NL> <DEDENT> <DEDENT> if ( A [ 0 ] [ 0 ] and A [ 1 ] [ 0 ] and A [ 2 ] [ 0 ] ) or ( A [ 0 ] [ 1 ] and A [ 1 ] [ 1 ] and A [ 2 ] [ 1 ] ) or ( A [ 0 ] [ 2 ] and A [ 1 ] [ 2 ] and A [ 2 ] [ 2 ] ) or ( A [ 0 ] [ 0 ] and A [ 0 ] [ 1 ] and A [ 0 ] [ 2 ] ) or ( A [ 1 ] [ 0 ] and A [ 1 ] [ 1 ] and A [ 1 ] [ 2 ] ) or ( A [ 2 ] [ 0 ] and A [ 2 ] [ 1 ] and A [ 2 ] [ 2 ] ) or ( A [ 0 ] [ 0 ] and A [ 1 ] [ 1 ] and A [ 2 ] [ 2 ] ) or ( A [ 0 ] [ 2 ] and A [ 1 ] [ 1 ] and A [ 2 ] [ 0 ] ) : print ( <STRING> ) <NEWLINE> else : print ( <STRING> ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> top = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> middle = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> bottom = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> N = int ( input ( ) ) <NEWLINE> taken = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> taken . append ( int ( input ( ) ) ) <NEWLINE> <NL> <DEDENT> bingo = [ ] <NEWLINE> bingo . append ( top ) <NEWLINE> bingo . append ( middle ) <NEWLINE> bingo . append ( bottom ) <NEWLINE> temp = [ top [ 0 ] , middle [ 0 ] , bottom [ 0 ] ] <NEWLINE> bingo . append ( temp ) <NEWLINE> temp = [ top [ 1 ] , middle [ 1 ] , bottom [ 1 ] ] <NEWLINE> bingo . append ( temp ) <NEWLINE> temp = [ top [ 2 ] , middle [ 2 ] , bottom [ 2 ] ] <NEWLINE> bingo . append ( temp ) <NEWLINE> temp = [ top [ 0 ] , middle [ 1 ] , bottom [ 2 ] ] <NEWLINE> bingo . append ( temp ) <NEWLINE> temp = [ top [ 2 ] , middle [ 1 ] , bottom [ 0 ] ] <NEWLINE> bingo . append ( 0 ) <NEWLINE> <NL> <NL> cnt = 0 <NEWLINE> flag = 0 <NEWLINE> for i in range ( len ( bingo ) ) : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> for j in range ( len ( bingo [ i ] ) ) : <NEWLINE> <INDENT> if bingo [ i ] [ j ] in taken : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> if cnt == 3 : <NEWLINE> <INDENT> flag += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if flag > 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> main ( ) <NEWLINE>
A = list ( map ( lambda x : ( int ( x ) , False ) , input ( ) . split ( ) ) ) <NEWLINE> A += list ( map ( lambda x : ( int ( x ) , False ) , input ( ) . split ( ) ) ) <NEWLINE> A += list ( map ( lambda x : ( int ( x ) , False ) , input ( ) . split ( ) ) ) <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> for a , b in A : <NEWLINE> <INDENT> if a == n : <NEWLINE> <INDENT> b = True <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if ( A [ 0 ] [ 1 ] and ( ( A [ 1 ] [ 1 ] and A [ 2 ] [ 1 ] ) or ( A [ 3 ] [ 1 ] and A [ 6 ] [ 1 ] ) or ( A [ 4 ] [ 1 ] and A [ 8 ] [ 1 ] ) ) or ( A [ 1 ] [ 1 ] and A [ 4 ] [ 1 ] and A [ 7 ] [ 1 ] ) or ( A [ 2 ] [ 1 ] and A [ 5 ] [ 1 ] and A [ 8 ] [ 1 ] ) or ( A [ 3 ] [ 1 ] and A [ 4 ] [ 1 ] and A [ 5 ] [ 1 ] ) or ( A [ 6 ] [ 1 ] and A [ 7 ] [ 1 ] and A [ 8 ] [ 1 ] ) or ( A [ 2 ] [ 1 ] and A [ 4 ] [ 1 ] and A [ 6 ] [ 1 ] ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
A = [ [ j for j in list ( map ( int , input ( ) . split ( ) ) ) ] for i in range ( 3 ) ] <NEWLINE> N = int ( input ( ) ) <NEWLINE> B = [ ] <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> b = int ( input ( ) ) <NEWLINE> for r in A : <NEWLINE> <INDENT> for i in range ( len ( r ) ) : <NEWLINE> <INDENT> if r [ i ] == b : <NEWLINE> <INDENT> r [ i ] = 0 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> ans = False <NEWLINE> for i in range ( 3 ) : <NEWLINE> <INDENT> if sum ( A [ i ] ) == 0 : <NEWLINE> <INDENT> ans = True <NEWLINE> <DEDENT> <DEDENT> if not ans : <NEWLINE> <INDENT> for i in range ( 3 ) : <NEWLINE> <INDENT> if A [ 0 ] [ i ] + A [ 1 ] [ i ] + A [ 2 ] [ i == 0 : <NEWLINE> <INDENT> ans = True <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if not ans : <NEWLINE> <INDENT> if A [ 0 ] [ 0 ] + A [ 1 ] [ 1 ] + A [ 2 ] [ 2 ] == 0 : <NEWLINE> <INDENT> ans = True <NEWLINE> <DEDENT> elif A [ 0 ] [ 2 ] + A [ 1 ] [ 1 ] + A [ 2 ] [ 0 ] == 0 : <NEWLINE> <INDENT> ans = True <NEWLINE> <DEDENT> <DEDENT> if ans : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> a = [ list ( input ( ) ) for i in range ( 3 ) ] <NEWLINE> a = np . ravel ( a ) <NEWLINE> n = int ( input ( ) ) <NEWLINE> b = [ input ( ) for i in range ( n ) ] <NEWLINE> <NL> ans = <STRING> <NEWLINE> def check ( a , b ) : <NEWLINE> <INDENT> return set ( a ) . issubset ( b ) <NEWLINE> <NL> <DEDENT> for i in range ( 3 ) : <NEWLINE> <INDENT> if check ( a [ i * 3 : i * 3 + 2 ] , b ) or check ( a [ i : i + 6 : 3 ] , b ) or check ( a [ 0 : 8 : 4 ] , b ) or check ( a [ 2 : 6 : 2 ] , b ) : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
Aij = [ input ( ) . split ( ) for l in range ( 3 ) ] <NEWLINE> N = int ( input ( ) ) <NEWLINE> b = [ int ( input ( ) ) for i in range ( N ) ] <NEWLINE> for j in range ( 3 ) : <NEWLINE> <INDENT> for k in range ( 3 ) : <NEWLINE> <INDENT> for n in range ( N ) : <NEWLINE> <INDENT> if int ( Aij [ j ] [ k ] ) == b [ n ] : <NEWLINE> <INDENT> Aij [ j ] [ k ] = <STRING> <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if ( A [ 0 ] [ 0 ] == A [ 0 ] [ 1 ] == A [ 0 ] [ 2 ] == 0 ) or ( A [ 1 ] [ 0 ] == A [ 1 ] [ 1 ] == A [ 1 ] [ 2 ] == 0 ) or ( A [ 2 ] [ 0 ] == A [ 2 ] [ 1 ] == A [ 2 ] [ 2 ] == 0 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif Aij [ 0 ] [ 0 ] == <STRING> and Aij [ 0 ] [ 1 ] == <STRING> and Aij [ 0 ] [ 2 ] == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif Aij [ 1 ] [ 0 ] == <STRING> and Aij [ 1 ] [ 1 ] == <STRING> and Aij [ 1 ] [ 2 ] == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif Aij [ 2 ] [ 0 ] == <STRING> and Aij [ 2 ] [ 1 ] == <STRING> and Aij [ 2 ] [ 2 ] == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif Aij [ 0 ] [ 0 ] == <STRING> and Aij [ 1 ] [ 1 ] == <STRING> and Aij [ 2 ] [ 2 ] == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif Aij [ 0 ] [ 2 ] == <STRING> and Aij [ 1 ] [ 1 ] == <STRING> and Aij [ 2 ] [ 0 ] == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a = [ ] <NEWLINE> for i in range ( 3 ) : <NEWLINE> <INDENT> a . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <DEDENT> n = input ( ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> b = int ( input ( ) ) <NEWLINE> for j in range ( 3 ) : <NEWLINE> <INDENT> for k in range ( 3 ) : <NEWLINE> <INDENT> if a [ i ] [ j ] == b : <NEWLINE> <INDENT> a [ i ] [ j ] = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for l in range ( 3 ) : <NEWLINE> <INDENT> if a [ l ] [ 0 ] == 0 and a [ l ] [ 1 ] == 0 and a [ l ] [ 2 ] == 0 : <NEWLINE> <INDENT> ans = 1 <NEWLINE> break <NEWLINE> <DEDENT> elif a [ 0 ] [ l ] == 0 and a [ 1 ] [ l == 0 and a [ 2 ] [ l ] == : <NEWLINE> <INDENT> ans = 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if ans == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a [ 1 ] [ 1 ] == 0 and a [ 2 ] [ 2 ] == 0 and a [ 0 ] [ 0 ] == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a [ 0 ] [ 2 ] == 0 and a [ 1 ] [ 1 ] == 0 and a [ 2 ] [ 0 ] == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
A = [ ] <NEWLINE> A += input ( ) . split ( ) <NEWLINE> A += input ( ) . split ( ) <NEWLINE> A += input ( ) . split ( ) <NEWLINE> N = int ( input ( ) ) <NEWLINE> b = [ input ( ) for _ in range ( N ) ] <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> if b [ i ] in A : <NEWLINE> <INDENT> A [ A . index ( b [ i ] ) ] = <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> if ( A [ 0 ] == <STRING> and A [ 3 ] == <STRING> and A [ 6 ] == <STRING> ) or ( A [ 1 ] == <STRING> and A [ 4 ] == <STRING> and A [ 7 ] == <STRING> ) <NEWLINE> or ( A [ 2 ] == <STRING> and A [ 5 ] == <STRING> and A [ 8 ] == <STRING> ) or ( A [ 0 ] == <STRING> and A [ 1 ] == <STRING> and A [ 2 ] == <STRING> ) <NEWLINE> or ( A [ 3 ] == <STRING> and A [ 4 ] == <STRING> and A [ 5 ] == <STRING> ) or ( A [ 6 ] == <STRING> and A [ 7 ] == <STRING> and A [ 8 ] == <STRING> ) <NEWLINE> or ( A [ 0 ] == <STRING> and A [ 4 ] == <STRING> and A [ 8 ] == <STRING> ) or ( A [ 2 ] == <STRING> and A [ 4 ] == <STRING> and A [ 6 ] == <STRING> ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : print ( <STRING> ) <NEWLINE>
a1 = input ( <STRING> ) . split ( <STRING> ) <NEWLINE> a2 = input ( <STRING> ) . split ( <STRING> ) <NEWLINE> a3 = input ( <STRING> ) . split ( <STRING> ) <NEWLINE> lista = [ ] <NEWLINE> listmp = [ ] <NEWLINE> for k in range ( 3 ) : <NEWLINE> <INDENT> listmp += [ int ( a1 [ i ] ) ] <NEWLINE> <DEDENT> lista += [ listmp ] <NEWLINE> listmp = [ ] <NEWLINE> for k in range ( 3 ) : <NEWLINE> <INDENT> listmp += [ int ( a2 [ i ] ) ] <NEWLINE> <DEDENT> lista += [ listmp ] <NEWLINE> listmp = [ ] <NEWLINE> for k in range ( 3 ) : <NEWLINE> <INDENT> listmp += [ int ( a3 [ i ] ) ] <NEWLINE> <DEDENT> lista += [ listmp ] <NEWLINE> n = int ( input ( <STRING> ) ) <NEWLINE> listn = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> t = int ( input ( <STRING> ) ) <NEWLINE> listn += [ t ] <NEWLINE> <DEDENT> for i in range ( 3 ) : <NEWLINE> <INDENT> for k in range ( 3 ) : <NEWLINE> <INDENT> if ( lista [ i ] [ k ] in listn ) : <NEWLINE> <INDENT> lista [ i ] [ k ] = 0 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> p = 0 <NEWLINE> for i in range ( 3 ) : <NEWLINE> <INDENT> s = 0 <NEWLINE> for k in range ( 3 ) : <NEWLINE> <INDENT> s += lista [ i ] [ k ] <NEWLINE> <NL> if ( s == 0 ) : <NEWLINE> <INDENT> p = 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> for i in range ( 3 ) : <NEWLINE> <INDENT> s = 0 <NEWLINE> for k in range ( 3 ) : <NEWLINE> <INDENT> s += lista [ k ] [ i ] <NEWLINE> <NL> if ( s == 0 ) : <NEWLINE> <INDENT> p = 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> s = 0 <NEWLINE> for i in range ( 3 ) : <NEWLINE> <INDENT> s += lista [ i ] [ i ] <NEWLINE> <DEDENT> if ( s == 0 ) : <NEWLINE> <INDENT> p = 1 <NEWLINE> <DEDENT> s = 0 <NEWLINE> for i in range ( 3 ) : <NEWLINE> <INDENT> s += lista [ i ] [ 2 - i ] <NEWLINE> <DEDENT> if ( s == 0 ) : <NEWLINE> <INDENT> p = 1 <NEWLINE> <DEDENT> if ( p == 1 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <NL> <NL> <DEDENT>
def resolve ( ) : <NEWLINE> <INDENT> A = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( 3 ) ] <NEWLINE> N = int ( input ( ) ) <NEWLINE> B = [ int ( input ( ) ) for _ in range ( N ) ] <NEWLINE> punch = [ [ False for _ in range ( 3 ) ] for _ in range ( 3 ) ] <NEWLINE> for i in range ( 3 ) : <NEWLINE> <INDENT> for j in range ( 3 ) : <NEWLINE> <INDENT> if A [ i ] [ j ] in B : <NEWLINE> <INDENT> punch [ i ] [ j ] = True <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( punch , file = sys . stderr ) <NEWLINE> ans = <STRING> <NEWLINE> for i in range ( 3 ) : <NEWLINE> <INDENT> if False not in punch [ i ] : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> break <NEWLINE> <DEDENT> for j in range ( 3 ) : <NEWLINE> <INDENT> if not punch [ j ] [ i ] : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if ( punch [ 0 ] [ 0 ] and punch [ 1 ] [ 1 ] and punch [ 2 ] [ 2 ] ) or ( <NEWLINE> <INDENT> punch [ 0 ] [ 2 ] and punch [ 1 ] [ 1 ] and punch [ 2 ] [ 0 ] ) : <NEWLINE> ans = <STRING> <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> resolve ( ) <NEWLINE>
<COMMENT> <NL> A = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( 3 ) ] <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> <NL> B = [ int ( input ( ) ) for i in range ( N ) ] <NEWLINE> <NL> C = [ [ 0 , 0 , 0 ] , [ 0 , 0 , 0 ] , [ 0 , 0 , 0 ] ] <NEWLINE> Ans = <STRING> <NEWLINE> <NL> for i in range ( 3 ) : <NEWLINE> <INDENT> for j in range ( 3 ) : <NEWLINE> <INDENT> if A [ i ] [ j ] in B : <COMMENT> <NEWLINE> <INDENT> C [ i ] [ j ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for i in range ( 3 ) : <NEWLINE> <INDENT> if C [ i ] [ 1 ] + C [ i ] [ 2 ] + C [ i ] [ 3 ] == 3 : <NEWLINE> <INDENT> Ans = <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( 3 ) : <NEWLINE> <INDENT> if C [ 1 ] [ i ] + C [ 2 ] [ i ] + C [ 3 ] [ i ] == 3 : <NEWLINE> <INDENT> Ans = <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> if C [ 1 ] [ 1 ] + C [ 2 ] [ 2 ] + C [ 3 ] [ 2 ] == 3 or C [ 1 ] [ 3 ] + C [ 2 ] [ 2 ] + C [ 3 ] [ 1 ] == 3 : <NEWLINE> <INDENT> Ans = <STRING> <NEWLINE> <NL> <DEDENT> print ( Ans ) <NEWLINE> <NL>
A = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( 3 ) ] <NEWLINE> N = int ( input ( ) ) <NEWLINE> b = [ int ( input ( ) ) for _ in range ( N ) ] <NEWLINE> <NL> field = 0 <NEWLINE> for v in b : <NEWLINE> <INDENT> for i in range ( 9 ) : <NEWLINE> <INDENT> if A [ i // 3 ] [ i % 3 ] == v : <NEWLINE> <INDENT> f |= 1 << i <NEWLINE> <DEDENT> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for v in [ 7 , 56 , 73 , 84 , 146 , 273 , 292 , 448 ] : <NEWLINE> <INDENT> ans |= f & v == v ; <NEWLINE> <DEDENT> print ( <STRING> if ans else <STRING> ) <NEWLINE>
A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> C = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> X = A + B + C <NEWLINE> n = int ( input ( ) ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> y = int ( input ( ) ) <NEWLINE> X = [ <STRING> if j == y else j for j in x ] <NEWLINE> <DEDENT> if X [ 0 ] == X [ 3 ] == X [ 6 ] == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif X [ 1 ] == X [ 4 ] == X [ 7 ] == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif X [ 2 ] == X [ 5 ] == X [ 8 ] == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif X [ 0 ] == X [ 1 ] == X [ 2 ] == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif X [ 3 ] == X [ 4 ] == X [ 5 ] == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif X [ 6 ] == X [ 7 ] == X [ 8 ] == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif X [ 0 ] == X [ 4 ] == X [ 8 ] == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif X [ 2 ] == X [ 4 ] == X [ 6 ] == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
al = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( 3 ) ] <NEWLINE> al = sum ( a , [ ] ) <NEWLINE> n = int ( input ( ) ) <NEWLINE> bl = [ int ( input ( ) ) for i in range ( n ) ] <NEWLINE> check = [ 0 for i in range ( 9 ) ] <NEWLINE> <NL> for b in bl : <NEWLINE> <INDENT> if b in al : <NEWLINE> <INDENT> check [ al . index ( b ) ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if [ 1 , 1 , 1 ] in [ check [ : 3 ] , check [ 3 : 6 ] , check [ 6 : ] , check [ 0 : 7 : 3 ] , check [ 1 : 8 : 3 ] , check [ 2 : 9 : 3 ] , check [ 0 : 9 : 4 ] , check [ 3 : 8 : 2 ] ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> import math <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> d = [ a [ 0 ] , b [ 0 ] , c [ 0 ] ] <NEWLINE> e = [ a [ 1 ] , b [ 1 ] , c [ 1 ] ] <NEWLINE> f = [ a [ 2 ] , b [ 2 ] , c [ 2 ] ] <NEWLINE> g = [ a [ 0 ] , b [ 1 ] , c [ 2 ] ] <NEWLINE> h = [ a [ 2 ] , b [ 1 ] , c [ 0 ] ] <NEWLINE> n = int ( input ( ) ) <NEWLINE> listB = [ int ( input ( ) ) for x in range ( n ) ] <NEWLINE> C = itertools . combinations ( listB , 3 ) <NEWLINE> if a in C or b in C or c in C or d in C or e in C or f in C or g in C or h in C : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> main ( ) <NEWLINE>
for _ in range ( 3 ) : <NEWLINE> <INDENT> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <DEDENT> N = int ( input ( ) ) <NEWLINE> <NL> for _ in range ( N ) : <NEWLINE> <INDENT> b = int ( input ( ) ) <NEWLINE> for y in range ( 3 ) : <NEWLINE> <INDENT> for x in range ( 3 ) : <NEWLINE> <INDENT> if A [ y ] [ x ] == b : <NEWLINE> <INDENT> A [ y ] [ x ] = - 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for y in range ( 3 ) : <NEWLINE> <INDENT> f = True <NEWLINE> for x in range ( 3 ) : <NEWLINE> <INDENT> if A [ y ] [ x ] != - 1 : <NEWLINE> <INDENT> f = False <NEWLINE> <DEDENT> <DEDENT> if f : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> for x in range ( 3 ) : <NEWLINE> <INDENT> f = True <NEWLINE> for y in range ( 3 ) : <NEWLINE> <INDENT> if A [ y ] [ x ] != - 1 : <NEWLINE> <INDENT> f = False <NEWLINE> <DEDENT> <DEDENT> if f : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> f = True <NEWLINE> for x in range ( 3 ) : <NEWLINE> <INDENT> if A [ x ] [ x ] != - 1 : <NEWLINE> <INDENT> f = False <NEWLINE> <DEDENT> <DEDENT> if f : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> f = True <NEWLINE> for x in range ( 3 ) : <NEWLINE> <INDENT> if A [ 2 - x ] [ x ] != - 1 : <NEWLINE> <INDENT> f = False <NEWLINE> <DEDENT> <DEDENT> if f : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> print ( <STRING> ) <NEWLINE>
a = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( 3 ) ] <NEWLINE> N = int ( input ( ) ) <NEWLINE> b = [ int ( input ( ) ) for _ in range ( 10 ) ] <NEWLINE> <NL> c = [ [ 0 for _ in range ( 3 ) ] for _ in range ( 3 ) ] <NEWLINE> result = <STRING> <NEWLINE> <NL> for i in range ( 3 ) : <NEWLINE> <INDENT> for j in range ( 3 ) : <NEWLINE> <INDENT> if a [ j ] [ i ] in b : <NEWLINE> <INDENT> c [ j ] [ i ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for i in range ( 3 ) : <NEWLINE> <INDENT> if c [ i ] [ 0 ] == c [ i ] [ 1 ] == c [ i ] [ 2 ] == 1 : <NEWLINE> <INDENT> result = <STRING> <NEWLINE> break <NEWLINE> <DEDENT> elif c [ 0 ] [ i ] == c [ 1 ] [ i ] == c [ 2 ] [ i ] == 1 : <NEWLINE> <INDENT> result = <STRING> <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if c [ 0 ] [ 0 ] == c [ 1 ] [ 1 ] == c [ 2 ] [ 2 ] == 1 : <NEWLINE> <INDENT> result = <STRING> <NEWLINE> <DEDENT> elif c [ 0 ] [ 2 ] == c [ 1 ] [ 1 ] == c [ 2 ] [ 0 ] == 1 : <NEWLINE> <INDENT> result = <STRING> <NEWLINE> <NL> <DEDENT> if result == <STRING> : <NEWLINE> <INDENT> result = <STRING> <NEWLINE> <NL> <DEDENT> print ( result ) <NEWLINE>
b = [ ] <NEWLINE> for i in range ( 3 ) : <NEWLINE> <INDENT> lst = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b . append ( lst ) <NEWLINE> <DEDENT> n = int ( input ( ) ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a = int ( input ( ) ) <NEWLINE> for j in range ( 3 ) : <NEWLINE> <INDENT> for k in range ( 3 ) : <NEWLINE> <INDENT> if ( b [ j ] [ k ] == a ) : <NEWLINE> <INDENT> b [ j ] [ k ] = 0 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if ( b [ 0 ] [ 0 ] = b [ 0 ] [ 1 ] = b [ 0 ] [ 2 ] or b [ 1 ] [ 0 ] = b [ 1 ] [ 1 ] = b [ 1 ] [ 2 ] or b [ 2 ] [ 0 ] = b [ 2 ] [ 1 ] = b [ 2 ] [ 2 ] or b [ 0 ] [ 0 ] = b [ 1 ] [ 0 ] = b [ 2 ] [ 0 ] or b [ 0 ] [ 1 ] = b [ 1 ] [ 1 ] = b [ 2 ] [ 1 ] or b [ 0 ] [ 2 ] = b [ 1 ] [ 2 ] = b [ 2 ] [ 2 ] or b [ 0 ] [ 0 ] = b [ 1 ] [ 1 ] = b [ 2 ] [ 2 ] or b [ 0 ] [ 2 ] = b [ 1 ] [ 1 ] = b [ 2 ] [ 0 ] ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
A = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( 3 ) ] <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> <NL> for j in range ( n ) : <NEWLINE> <INDENT> b = int ( input ( ) ) <NEWLINE> for l in range ( 3 ) : <NEWLINE> <INDENT> if A [ l ] [ 0 ] == b : <NEWLINE> <INDENT> A [ l ] [ 0 ] = 0 <NEWLINE> <DEDENT> if A [ l ] [ 1 ] == b : <NEWLINE> <INDENT> A [ l ] [ 1 ] = 0 <NEWLINE> <DEDENT> if A [ l ] [ 2 ] == b : <NEWLINE> <INDENT> A [ l ] [ 2 ] = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if A [ 0 ] [ 0 ] == A [ 1 ] [ 1 ] == A [ 2 ] [ 2 ] == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif A [ 0 ] [ 2 ] == A [ 1 ] [ 1 ] == A [ 2 ] [ 0 ] == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif for k in range ( 3 ) : <NEWLINE> <INDENT> if A [ k ] [ 0 ] == A [ k ] [ 1 ] == A [ k ] [ 2 ] == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif A [ 0 ] [ k ] == A [ 1 ] [ k ] == A [ 2 ] [ k ] == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
bingo_list = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( 3 ) ] <NEWLINE> bingo_list = sum ( bingo_list , [ ] ) <NEWLINE> n = int ( input ( ) ) <NEWLINE> bingo_number = [ int ( input ( ) ) for i in range ( n ) ] <NEWLINE> check_list = [ 0 for i in range ( 9 ) ] <NEWLINE> <NL> for j in bingo_number : <NEWLINE> <INDENT> if j in bingo_list : <NEWLINE> <INDENT> check_list [ bingo_list . index ( j ) ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if [ 1 , 1 , 1 ] in [ check_list [ : 3 ] , check_list [ 3 : 6 ] , check_list [ 6 : ] , check_list [ 0 : 7 : 3 ] , check_list [ 1 : 8 : 3 ] check_list [ 2 : 9 : 3 ] , check_list [ 0 : 9 : 4 ] , check_list [ 2 : 8 : 2 ] ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
A = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( 3 ) ] <NEWLINE> N = int ( input ( ) ) <NEWLINE> B = [ int ( input ( ) ) for _ in range ( N ) ] <NEWLINE> <NL> for b in B : <NEWLINE> <INDENT> if i in range ( 3 ) : <NEWLINE> <INDENT> for j in range ( 3 ) : <NEWLINE> <INDENT> if A [ i ] [ j ] == b : <NEWLINE> <INDENT> A [ i ] [ j ] = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for i in range ( 3 ) : <NEWLINE> <INDENT> if A [ i ] [ 0 ] == A [ i ] [ 1 ] == A [ i ] [ 2 ] == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> if A [ 0 ] [ i ] == A [ 1 ] [ i ] == A [ 2 ] [ i ] == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> if A [ 0 ] [ 0 ] == A [ 1 ] [ 1 ] == A [ 2 ] [ 2 ] == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <NL> <DEDENT> if A [ 0 ] [ 2 ] == A [ 1 ] [ 1 ] == A [ 2 ] [ 0 ] == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <NL> <DEDENT> print ( <STRING> ) <NEWLINE>
A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> C = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> X = A + B + C <NEWLINE> N = int ( input ( ) ) <NEWLINE> L = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> K = int ( input ( ) ) <NEWLINE> L . append ( K ) <NEWLINE> <DEDENT> ck = <STRING> <NEWLINE> if A [ 1 ] in L and A [ 2 ] in L and A [ 3 ] in L : <NEWLINE> <INDENT> ck == <STRING> <NEWLINE> <DEDENT> elif B [ 1 ] in L and B [ 2 ] in L and B [ 3 ] in L : <NEWLINE> <INDENT> ck == <STRING> <NEWLINE> <DEDENT> elif C [ 1 ] in L and C [ 2 ] in L and C [ 3 ] in L : <NEWLINE> <INDENT> ck == <STRING> <NEWLINE> <DEDENT> elif A [ 1 ] in L and B [ 1 ] in L and C [ 1 ] in L : <NEWLINE> <INDENT> ck == <STRING> <NEWLINE> <DEDENT> elif A [ 2 ] in L and B [ 2 ] in L and C [ 2 ] in L : <NEWLINE> <INDENT> ck == <STRING> <NEWLINE> <DEDENT> elif A [ 3 ] in L and B [ 3 ] in L and C [ 3 ] in L : <NEWLINE> <INDENT> ck == <STRING> <NEWLINE> <DEDENT> elif A [ 1 ] in L and B [ 2 ] in L and C [ 3 ] in L : <NEWLINE> <INDENT> ck = <STRING> <NEWLINE> <DEDENT> elif A [ 3 ] in L and B [ 2 ] in L and C [ 1 ] in L : <NEWLINE> <INDENT> ck = <STRING> <NEWLINE> <DEDENT> print ( ck ) <NEWLINE>
A = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( 3 ) ] <NEWLINE> N = int ( input ( ) ) <NEWLINE> B = [ ] <NEWLINE> for j in range ( N ) : <NEWLINE> <INDENT> b = int ( input ( ) ) <NEWLINE> B . append ( b ) <NEWLINE> <DEDENT> A = np . array ( A ) <NEWLINE> B = np . array ( B ) <NEWLINE> boolean_matrix = np . isin ( A , B ) <NEWLINE> if boolean_matrix . sum ( axis = 1 ) . max ( ) >= 3 or boolean_matrix . sum ( axis = 0 ) . max ( ) >= 3 or np . diag ( boolean_matrix ) . sum ( ) >= 3 or np . diag ( np . fliplr ( boolean_matrix ) ) . sum ( ) >= 3 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
l = list ( map ( int , imput ( ) . split ( ) ) ) <NEWLINE> l += list ( map ( int , imput ( ) . split ( ) ) ) <NEWLINE> l += list ( map ( int , imput ( ) . split ( ) ) ) <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> <NL> ans_list = [ False ] * 9 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> num = int ( input ( ) ) <NEWLINE> if num in l : <NEWLINE> <INDENT> index = l . index ( num ) <NEWLINE> ans_list [ index ] = True <NEWLINE> <NL> <DEDENT> <DEDENT> if ans_list [ 0 ] and ans_list [ 1 ] and ans_list [ 2 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif ans_list [ 0 ] and ans_list [ 3 ] and ans_list [ 6 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif ans_list [ 3 ] and ans_list [ 4 ] and ans_list [ 5 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif ans_list [ 6 ] and ans_list [ 7 ] and ans_list [ 8 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif ans_list [ 1 ] and ans_list [ 4 ] and ans_list [ 7 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif ans_list [ 2 ] and ans_list [ 5 ] and ans_list [ 8 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif ans_list [ 0 ] and ans_list [ 4 ] and ans_list [ 8 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif ans_list [ 2 ] and ans_list [ 4 ] and ans_list [ 6 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
A = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( 3 ) ] <NEWLINE> N = int ( input ( ) ) <NEWLINE> <NL> val = 0 <NEWLINE> flag = False <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> b = int ( input ( ) ) <NEWLINE> for j in range ( 3 ) : <NEWLINE> <INDENT> for k in range ( 3 ) : <NEWLINE> <INDENT> if A [ j ] [ k ] == b : <NEWLINE> <INDENT> A [ j ] [ k ] = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> val = 0 <NEWLINE> for i in range ( 3 ) : <NEWLINE> <INDENT> val += A [ i ] <NEWLINE> <DEDENT> if val == 0 : <NEWLINE> <INDENT> flag = True <NEWLINE> <NL> <DEDENT> val = A [ 0 ] [ 2 ] + A [ 1 ] [ 1 ] + A [ 2 ] [ 0 ] <NEWLINE> if val == 0 : <NEWLINE> <INDENT> flag = True <NEWLINE> <NL> <DEDENT> for i in range ( 3 ) : <NEWLINE> <INDENT> if sum ( A [ i ] ) == 0 : <NEWLINE> <INDENT> flag = True <NEWLINE> <NL> <DEDENT> val = 0 <NEWLINE> for j in range ( 3 ) : <NEWLINE> <INDENT> val += A [ j ] [ i ] <NEWLINE> <DEDENT> if val == 0 : <NEWLINE> <INDENT> flag = True <NEWLINE> <NL> <DEDENT> <DEDENT> if flag == True : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
ans = np . full ( N + 1 , - 1 ) <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> if ( ans [ s [ i ] ] == - 1 ) : <NEWLINE> <INDENT> ans [ s [ i ] ] = c [ i ] <NEWLINE> <DEDENT> elif ( ans [ s [ i ] ] != c [ i ] ) : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> if ( ans [ 1 ] == 0 ) and ( N != 1 ) : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> if ( ans [ 1 ] == - 1 ) and ( n != 1 ) : <NEWLINE> <INDENT> ans [ 1 ] = 1 <NEWLINE> <DEDENT> ans = np . where ( ans == - 1 , 0 , ans ) <NEWLINE> Ans = 0 <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> Ans += 10 ** ( N - i ) * ans [ i ] <NEWLINE> <DEDENT> print ( int ( Ans ) ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> q = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( m ) ] <NEWLINE> for i in range ( 10 ** n ) : <NEWLINE> <INDENT> i = str ( i ) <NEWLINE> f = 1 <NEWLINE> for j in q : <NEWLINE> <INDENT> if i [ j [ 0 ] - 1 ] != str ( j [ 1 ] ) : <NEWLINE> <INDENT> f = 0 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if f : <NEWLINE> <INDENT> print ( i ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> s = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( b ) ] <NEWLINE> s = sum ( s , [ ] ) <NEWLINE> L = [ - 1 ] * [ 0 ] * ( a - 1 ) <NEWLINE> ans = 0 <NEWLINE> ab = 10 ** ( a - 1 ) <NEWLINE> <NL> for i in range ( b ) : <NEWLINE> <INDENT> if L [ s [ i * 2 ] - 1 ] == 0 : <NEWLINE> <INDENT> L [ s [ i * 2 ] - 1 ] = s [ i * 2 + 1 ] <NEWLINE> <DEDENT> if L [ s [ i * 2 ] - 1 ] != 0 and L [ s [ i * 2 ] - 1 ] == s [ i * 2 + 1 ] : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> if L [ s [ i * 2 ] - 1 ] != 0 and L [ s [ i * 2 ] - 1 ] != s [ i * 2 + 1 ] : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if ans == 0 : <NEWLINE> <INDENT> if a == 1 and b == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> if a != 1 and b == 0 : <NEWLINE> <INDENT> print ( ab ) <NEWLINE> <DEDENT> if b != 0 and L [ 0 ] == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> if b != 0 and L [ 0 ] == - 1 : <NEWLINE> <INDENT> T = <STRING> . join ( map ( str , L [ 1 : a ] ) ) <NEWLINE> ab = ab + int ( T ) <NEWLINE> print ( ab ) <NEWLINE> <DEDENT> if b != 0 and L [ 0 ] != - 1 : <NEWLINE> <INDENT> T = <STRING> . join ( map ( str , L ) ) <NEWLINE> print ( T ) <NEWLINE> <DEDENT> <DEDENT> if ans != 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> SC = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( M ) ] <NEWLINE> <NL> for X in range ( 10 ** N ) : <NEWLINE> <INDENT> X = str ( X ) <NEWLINE> <NL> <COMMENT> <NL> if len ( X ) == N and all ( X [ s - 1 ] == str ( c ) for s , c in SC ) : <NEWLINE> <INDENT> print ( X [ s - 1 ] ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> sc = [ map ( int , input ( ) . split ( ) ) for _ in range ( m ) ] <NEWLINE> s , c = [ list ( i ) for i in zip ( * sc ) ] <NEWLINE> <NL> <NL> <NL> for i in range ( 10 ** n ) : <NEWLINE> <INDENT> ans = str ( i ) <NEWLINE> if len ( i ) == n and all ( [ i [ s [ j ] - 1 ] == str ( c [ j ] ) for j in range ( m ) ] ) : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> exit ( ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> print ( - 1 ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> sc = [ ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> sc . append ( tuple ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> <NL> <DEDENT> for i in range ( 10 ** ( n - 1 ) , 10 ** n ) : <NEWLINE> <INDENT> s = str ( i ) <NEWLINE> flag = True <NEWLINE> if len ( s ) == n and all ( [ s [ sc [ j ] [ 0 ] - 1 ] == str ( sc [ j ] [ 1 ] ) for j in range ( m ) ) ] : <NEWLINE> <INDENT> print ( s ) <NEWLINE> exit ( 0 ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL>
import sys <NEWLINE> import time <NEWLINE> import math <NEWLINE> import itertools as it <NEWLINE> def inpl ( ) : <NEWLINE> <INDENT> return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <DEDENT> st = time . perf_counter ( ) <NEWLINE> <COMMENT> <NL> <NL> N , M = inpl ( ) <NEWLINE> dp = [ - 1 ] * N <NEWLINE> for _ in range ( M ) : <NEWLINE> <INDENT> s , c = inpl ( ) <NEWLINE> s -= 1 <NEWLINE> if dp [ s ] not in [ - 1 , c ] : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> dp [ s ] = c <NEWLINE> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> if N == 1 : <NEWLINE> <INDENT> if dp [ i ] == - 1 : <NEWLINE> <INDENT> print ( 0 , end = <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( dp [ i ] , end = <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> if dp [ i ] == - 1 : <NEWLINE> <INDENT> print ( 1 , end = <STRING> ) <NEWLINE> <DEDENT> elif dp [ i ] == 0 <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( dp [ i ] , end = <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if dp [ i ] == - 1 : <NEWLINE> <INDENT> print ( 0 , end = <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( dp [ i ] , end = <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ) <NEWLINE> <COMMENT> <NL> ed = time . perf_counter ( ) <NEWLINE> print ( <STRING> , ed - st , file = sys . stderr ) <NEWLINE>
if __name__ == <STRING> : <NEWLINE> <INDENT> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> S = [ ] <NEWLINE> C = [ ] <NEWLINE> <NL> for i in range ( M ) : <NEWLINE> <INDENT> s , c = map ( int , input ( ) . split ( ) ) <NEWLINE> s -= 1 <NEWLINE> S . append ( s ) <NEWLINE> C . append ( c ) <NEWLINE> <NL> <DEDENT> for num in range ( pow ( 10 , N - 1 ) - 1 , pow ( 10 , N ) ) : <NEWLINE> <INDENT> st_num = str ( num ) <NEWLINE> cnt = 0 <NEWLINE> for m in range ( M ) : <NEWLINE> <INDENT> if int ( st_num [ S [ m ] ] ) == C [ m ] : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> if cnt == M : <NEWLINE> <INDENT> print ( st_num ) <NEWLINE> quit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( - 1 ) <NEWLINE> <DEDENT>
if M == 0 : <NEWLINE> <INDENT> if N >= 2 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( 0 ) <NEWLINE> <DEDENT> elif N == 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( 0 ) <NEWLINE> <NL> <DEDENT> <DEDENT> if N != 1 and A [ 0 ] [ 0 ] == 1 and A [ 0 ] [ 1 ] == 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( 0 ) <NEWLINE> <DEDENT> i = 1 <NEWLINE> j = len ( A ) <NEWLINE> while i < j : <NEWLINE> <INDENT> if A [ i ] [ 0 ] == A [ i - 1 ] [ 0 ] and A [ i ] [ 1 ] == A [ i - 1 ] [ 1 ] : <NEWLINE> <INDENT> A . pop ( i ) <NEWLINE> j -= 1 <NEWLINE> continue <NEWLINE> <DEDENT> elif A [ i ] [ 0 ] == A [ i - 1 ] [ 0 ] and A [ i ] [ 1 ] != A [ i - 1 ] [ 1 ] : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( 0 ) <NEWLINE> <DEDENT> i += 1 <NEWLINE> <DEDENT> ans = [ None ] * N <NEWLINE> <NL> for i , j in A : <NEWLINE> <INDENT> ans [ i - 1 ] = j <NEWLINE> <NL> <DEDENT> for i in range ( len ( ans ) ) : <NEWLINE> <INDENT> if ans [ i ] == None : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> ans [ i ] = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans [ i ] = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> . join ( map ( str , ans ) ) ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> SC = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( M ) ] <NEWLINE> D = { } <NEWLINE> ans = [ <STRING> ] * N <NEWLINE> ans [ 0 ] = <STRING> <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> if SC [ i ] [ 0 ] not in D : <NEWLINE> <INDENT> D [ SC [ i ] [ 0 ] ] = SC [ i ] [ 1 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if D [ SC [ i ] [ 0 ] ] != SC [ i ] [ 1 ] : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for k , v in D . items ( ) : <NEWLINE> <INDENT> ans [ k - 1 ] = str ( v ) <NEWLINE> <NL> <DEDENT> ans = - 1 if ans [ 0 ] == <STRING> else int ( <STRING> . join ( ans ) ) <NEWLINE> print ( as ) <NEWLINE>
import sys <NEWLINE> <NL> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> S = [ ] <NEWLINE> C = [ ] <NEWLINE> for m in range ( M ) : <NEWLINE> <INDENT> s , c = map ( int , input ( ) . split ( ) ) <NEWLINE> S . append ( s ) <NEWLINE> C . append ( c ) <NEWLINE> <NL> <DEDENT> for i in range ( 10 ** N ) : <NEWLINE> <INDENT> tes = str ( i ) <NEWLINE> flag = True <NEWLINE> if len ( tes ) < N : <NEWLINE> <INDENT> flag = False <NEWLINE> <DEDENT> for s , c in zip ( S , C ) : <NEWLINE> <INDENT> if tes [ s - 1 ] != str ( c ) : <NEWLINE> <INDENT> flag = False <NEWLINE> <DEDENT> <DEDENT> if flag : <NEWLINE> <INDENT> print ( tes ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> print ( - 1 ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> sc = list ( [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( M ) ] ) <NEWLINE> <NL> <NL> for i in range ( 10 ** ( N - 1 ) - 1 , 10 ** N ) : <NEWLINE> <INDENT> count = 0 <NEWLINE> str_i = str ( i ) <NEWLINE> for j in range ( M ) : <NEWLINE> <INDENT> if str_i [ sc [ j ] [ 0 ] - 1 ] == str ( sc [ j ] [ 1 ] ) : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> if count == M : <NEWLINE> <INDENT> print ( i ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( - 1 ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> s = [ 0 ] * m <NEWLINE> c = [ 0 ] * m <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> s [ i ] , c [ i ] = map ( int , input ( ) . split ( ) ) <NEWLINE> <DEDENT> if max ( s ) > n : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> k1 = [ 100 , 10 , 1 ] <NEWLINE> an = [ ] <NEWLINE> zeros = [ ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> if c [ i ] == 0 : <NEWLINE> <INDENT> zeros . append ( s [ i ] ) <NEWLINE> <DEDENT> an . append ( c [ i ] * k1 [ s [ i ] - 1 ] ) <NEWLINE> <NL> <DEDENT> for i in range ( m ) : <NEWLINE> <INDENT> for j in range ( m ) : <NEWLINE> <INDENT> if s [ i ] == s [ j ] : <NEWLINE> <INDENT> if c [ i ] != c [ j ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if len ( sum ( an ) ) != n : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> if 10 ** max ( zeros ) > sum ( an ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> for i in range ( m ) : <NEWLINE> <INDENT> if an . count ( an [ i ] ) != 1 : <NEWLINE> <INDENT> an [ i ] = 0 <NEWLINE> <DEDENT> <DEDENT> if sum ( an ) == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> print ( sum ( an ) ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> s , c = [ ] , [ ] <NEWLINE> for _ in range ( m ) : <NEWLINE> <INDENT> s_ , c_ = map ( int , input ( ) . split ( ) ) <NEWLINE> s . append ( s_ ) <NEWLINE> c . append ( c_ ) <NEWLINE> <NL> <DEDENT> flg = False <NEWLINE> for i in range ( 10 ** n ) : <NEWLINE> <INDENT> for j in range ( m ) : <NEWLINE> <INDENT> if str ( i ) [ s [ j ] - 1 ] != str ( c [ j ] ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( i ) <NEWLINE> flg = True <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if not flg : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT>
import sys <NEWLINE> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> cc = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( M ) ] <NEWLINE> if [ 0 , 1 ] in cc : <NEWLINE> <INDENT> if N != 1 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT> a , b = [ 0 ] * N , [ <STRING> ] * N <NEWLINE> for [ i , j ] in cc : <NEWLINE> <INDENT> a [ i - 1 ] = j <NEWLINE> if b [ i - 1 ] != <STRING> or b [ i - 1 ] != j : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> sys . exit <NEWLINE> <DEDENT> b [ i - 1 ] = j <NEWLINE> <DEDENT> if a [ 0 ] = 0 : <NEWLINE> <INDENT> a [ 0 ] = 1 <NEWLINE> <DEDENT> c = <STRING> <NEWLINE> for i in a : <NEWLINE> <INDENT> c = c + str ( i ) <NEWLINE> <DEDENT> print ( c ) <NEWLINE> <NL> <NL>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> L = [ - 1 ] * n <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if L [ a - 1 ] != - 1 : <NEWLINE> <INDENT> if L [ a - 1 ] != b : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> L [ a - 1 ] = b <NEWLINE> <DEDENT> if a == 1 and b == 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> for i in range ( len ( L ) ) : <NEWLINE> <INDENT> if L [ i ] == - 1 : <NEWLINE> <INDENT> L [ i ] = 0 <NEWLINE> <DEDENT> <DEDENT> L = list ( map ( int , L ) ) <NEWLINE> print ( <STRING> . join ( L ) ) <NEWLINE>
import sys <NEWLINE> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = [ 0 ] * n <NEWLINE> for _ in range ( m ) : <NEWLINE> <INDENT> s , c = map ( int , input ( ) . split ( ) ) <NEWLINE> if ans [ s - 1 ] != 0 and ans [ s - 1 ] != c : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> if s == 1 and c == 0 and n != 1 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> ans [ s - 1 ] = c <NEWLINE> <DEDENT> if ans [ 0 ] == 0 and n != 0 : <NEWLINE> num = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> num += ans [ i ] * ( 10 ** ( n - i - 1 ) ) <NEWLINE> <DEDENT> print ( num ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> n , m = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> dcon = [ set ( ) for _ in range ( n ) ] <NEWLINE> for _ in range ( m ) : <NEWLINE> <INDENT> s , c = tuple ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> dcon [ s - 1 ] . add ( c ) <NEWLINE> <NL> <DEDENT> if any ( len ( d ) > 1 for d in dcon ) : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> digits = [ 0 ] if n == 1 else [ 1 ] + [ 0 ] * ( n - 1 ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if d : <NEWLINE> <INDENT> digits [ i ] = d . pop ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> . join ( map ( str , digits ) ) ) <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> sc = list ( list ( input ( ) . split ( ) ) for _ in range ( M ) ) <NEWLINE> <NL> li = [ <STRING> ] * N <NEWLINE> <NL> for i in range ( M ) : <NEWLINE> <INDENT> j = li [ int ( sc [ i ] [ 0 ] ) - 1 ] <NEWLINE> if j == <STRING> : li [ int ( sc [ i ] [ 0 ] ) - 1 ] = sc [ i ] [ 1 ] <NEWLINE> elif j != sc [ i ] [ 1 ] : return - 1 <NEWLINE> <NL> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> if li [ 0 ] == <STRING> and N != 1 : return - 1 <NEWLINE> if li [ 0 ] == <STRING> : <NEWLINE> <INDENT> if N == 1 : li [ 0 ] = <STRING> <NEWLINE> elif : li [ 0 ] = <STRING> <NEWLINE> <DEDENT> <DEDENT> elif li [ i ] == <STRING> : li [ i ] = <STRING> <NEWLINE> <NL> <DEDENT> return <STRING> . join ( li ) <NEWLINE> <NL> <DEDENT> print ( main ( ) ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> rules = [ ] <NEWLINE> <NL> for x in range ( m ) : <NEWLINE> <INDENT> rules . append ( list ( map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <DEDENT> def get_ans ( ) : <NEWLINE> <INDENT> if m == 0 : <NEWLINE> <INDENT> return ( 10 ** ( n - 1 ) * int ( bool ( 1 < n ) ) ) <NEWLINE> <NL> <DEDENT> for i in range ( 10 ** ( n - 1 ) * int ( bool ( 1 < n ) ) , 10 ** n ) : <NEWLINE> <INDENT> for j , rule in enumerate ( rules ) : <NEWLINE> <NL> <INDENT> if int ( str ( i ) [ rule [ 0 ] - 1 ] ) == rule [ 1 ] : <NEWLINE> <INDENT> if j == len ( rules ) - 1 : <NEWLINE> <INDENT> return ( i ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> return ( - 1 ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> print ( get_ans ( ) ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> ans = [ - 1 ] * N <NEWLINE> <NL> for i in range ( M ) : <NEWLINE> <INDENT> s , c = map ( int , input ( ) . split ( ) ) <NEWLINE> if ans [ s - 1 ] != - 1 and ans [ s - 1 ] != c : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> t [ s - 1 ] = c <NEWLINE> <NL> <DEDENT> if N != 1 : <NEWLINE> <INDENT> if ans [ 0 ] == 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> if ans [ 0 ] == - 1 : <NEWLINE> <INDENT> ans [ 0 ] = 1 <NEWLINE> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> if ans [ i ] == - 1 : <NEWLINE> <INDENT> ans [ i ] = 0 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if ans [ 0 ] == - 1 : <NEWLINE> <INDENT> ans [ 0 ] = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( * ans , sep = <STRING> ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> import sys <NEWLINE> from io import StringIO <NEWLINE> import unittest <NEWLINE> <NL> <NL> class TestClass ( unittest . TestCase ) : <NEWLINE> <INDENT> def assertIO ( self , input , output ) : <NEWLINE> <INDENT> stdout , stdin = sys . stdout , sys . stdin <NEWLINE> sys . stdout , sys . stdin = StringIO ( ) , StringIO ( input ) <NEWLINE> resolve ( ) <NEWLINE> sys . stdout . seek ( 0 ) <NEWLINE> out = sys . stdout . read ( ) [ : - 1 ] <NEWLINE> sys . stdout , sys . stdin = stdout , stdin <NEWLINE> self . assertEqual ( out , output ) <NEWLINE> <NL> <DEDENT> def test__1 ( self ) : <NEWLINE> <INDENT> input = <STRING> <NEWLINE> output = <STRING> <NEWLINE> self . assertIO ( input , output ) <NEWLINE> <NL> <DEDENT> def test__2 ( self ) : <NEWLINE> <INDENT> input = <STRING> <NEWLINE> output = <STRING> <NEWLINE> self . assertIO ( input , output ) <NEWLINE> <NL> <DEDENT> def test__3 ( self ) : <NEWLINE> <INDENT> input = <STRING> <NEWLINE> output = <STRING> <NEWLINE> self . assertIO ( input , output ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def resolve ( ) : <NEWLINE> <INDENT> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> SC = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( M ) ] <NEWLINE> SC = set ( map ( tuple , SC ) ) <NEWLINE> SC = list ( set ( SC ) ) <NEWLINE> SC . sort ( ) <NEWLINE> <NL> ans = - 1 <NEWLINE> for i in range ( 10 ** N ) : <NEWLINE> <INDENT> si = str ( i ) <NEWLINE> for sc in SC : <NEWLINE> <INDENT> s , c = sc <NEWLINE> if si [ s - 1 ] != str ( c ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> ans = i <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <COMMENT> <NL> <INDENT> resolve ( ) <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> if m = 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> sc = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( m ) ] <NEWLINE> ans = - 1 <NEWLINE> s = [ [ 0 for i in range ( 2 ) ] for i in range ( n ) ] <NEWLINE> for j in range ( 10 ** n ) : <NEWLINE> <INDENT> k = str ( j ) <NEWLINE> for l in range ( len ( k ) ) : <NEWLINE> <INDENT> s [ l ] [ 0 ] = l + 1 <NEWLINE> s [ l ] [ 1 ] = int ( k [ l ] ) <NEWLINE> <DEDENT> if all ( elm in s for elm in sc ) == 1 : <NEWLINE> <INDENT> ans = j <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> l = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( m ) ] <NEWLINE> <NL> num = [ - 1 ] * n <NEWLINE> <NL> for i in l : <NEWLINE> <INDENT> if num [ i [ 0 ] - 1 ] == - 1 or num [ i [ 0 ] - 1 ] == i [ 1 ] : <NEWLINE> <INDENT> num [ i [ 0 ] - 1 ] = i [ 1 ] <NEWLINE> <DEDENT> elif i [ 0 ] == 1 and i [ 1 ] == 0 and n == 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> if num [ 0 ] == 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> elif n = 1 and num [ 0 ] == - 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( len ( num ) ) : <NEWLINE> <INDENT> if num [ i ] == - 1 and i == 0 : <NEWLINE> <INDENT> num [ i ] = 1 <NEWLINE> <DEDENT> elif num [ i ] == - 1 : <NEWLINE> <INDENT> num [ i ] = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( * num , sep = <STRING> ) <NEWLINE> <DEDENT>
S = input ( ) <NEWLINE> Q = int ( input ( ) ) <NEWLINE> <NL> c2 = 0 <NEWLINE> query = [ ] <NEWLINE> for i in range ( Q ) : <NEWLINE> <INDENT> q = [ x for x in input ( ) . split ( ) ] <NEWLINE> T = int ( q [ 0 ] ) <NEWLINE> if T == 1 : <NEWLINE> <INDENT> query . append ( [ T ] ) <NEWLINE> <DEDENT> else : <COMMENT> <NEWLINE> <INDENT> F , C = int ( q [ 1 ] ) , q [ 2 ] <NEWLINE> query . append ( [ T , F , C ] ) <NEWLINE> c2 += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> while len ( query ) > c2 + 1 : <NEWLINE> <INDENT> print ( query ) <NEWLINE> T1 = query [ i ] [ 0 ] <NEWLINE> if T1 == 1 : <NEWLINE> <INDENT> T2 = query [ i + 1 ] [ 0 ] <NEWLINE> if T2 == 1 : <NEWLINE> <INDENT> query = query [ : i ] + query [ i + 2 : ] <NEWLINE> <DEDENT> if T2 == 2 : <NEWLINE> <INDENT> F , C = query [ i + 1 ] [ 1 ] , query [ i + 1 ] [ 2 ] <NEWLINE> if F == 1 : <NEWLINE> <INDENT> query [ i ] = [ 2 , 2 , C ] <NEWLINE> query [ i + 1 ] = [ 1 ] <NEWLINE> <DEDENT> else : <COMMENT> <NEWLINE> <INDENT> query [ i ] = [ 2 , 1 , C ] <NEWLINE> query [ i + 1 ] = [ 1 ] <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> M = c2 + 1 <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> T = query [ i ] [ 0 ] <NEWLINE> if T == 1 : <NEWLINE> <INDENT> L = len ( S ) <NEWLINE> S = S [ L - 1 : : - 1 ] <NEWLINE> <DEDENT> else : <COMMENT> <NEWLINE> <INDENT> F , C = query [ i ] [ 1 ] , query [ i ] [ 2 ] <NEWLINE> if F == 1 : <NEWLINE> <INDENT> S = C + S <NEWLINE> <DEDENT> else : <COMMENT> <NEWLINE> <INDENT> S = S + C <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( S ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> s_c = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( M ) ] <NEWLINE> <NL> if N == 1 : <NEWLINE> <INDENT> a , b = 0 , 10 ** N <NEWLINE> <DEDENT> elif N >= 2 : <NEWLINE> <INDENT> a , b = 10 ** ( N - 1 ) , 10 ** N <NEWLINE> <NL> <DEDENT> ans = <STRING> <NEWLINE> for i in range ( a , b ) : <NEWLINE> <INDENT> flag = True <NEWLINE> for j in range ( M ) : <NEWLINE> <INDENT> if str ( i ) [ s_c [ j ] [ 0 ] - 1 ] != str ( s_c [ j ] [ 1 ] ) : <NEWLINE> <INDENT> flag = False <NEWLINE> <DEDENT> <DEDENT> if flag : <NEWLINE> <INDENT> ans = i <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <NL> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> arr = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( m ) ] <NEWLINE> if n == 1 : <NEWLINE> <INDENT> for i in range ( 10 ) : <NEWLINE> <INDENT> tmp = str ( i ) <NEWLINE> flag = True <NEWLINE> for j in range ( m ) : <NEWLINE> <INDENT> if tmp [ arr [ j ] [ 0 ] - 1 ] != str ( arr [ j ] [ 1 ] ) : <NEWLINE> <INDENT> flag = False <NEWLINE> <DEDENT> <DEDENT> if flag == True : <NEWLINE> <INDENT> print ( i ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( 10 ** ( n - 1 ) , 10 ** n ) : <NEWLINE> <INDENT> tmp = str ( i ) <NEWLINE> flag = True <NEWLINE> for j in range ( m ) : <NEWLINE> <INDENT> if tmp [ arr [ j ] [ 0 ] - 1 ] != str ( arr [ j ] [ 1 ] ) : <NEWLINE> <INDENT> flag = False <NEWLINE> <DEDENT> <DEDENT> if flag == True : <NEWLINE> <INDENT> print ( i ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = [ - 1 ] * n <NEWLINE> exist = True <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> s , c = map ( int , input ( ) . split ( ) ) <NEWLINE> if ( n != 1 and ( s , c ) == ( 1 , 0 ) ) or ( ans [ s - 1 ] != - 1 and ans [ s - 1 ] != c ) : <NEWLINE> <INDENT> exist = False <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans [ s - 1 ] = c <NEWLINE> <NL> <DEDENT> <DEDENT> if exist : <NEWLINE> <INDENT> for i in range ( n ) : <NEWLINE> if n != 1 and i == 0 : <NEWLINE> <INDENT> if ans [ i ] == - 1 : <NEWLINE> <INDENT> ans [ i ] = 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if ans [ i ] == - 1 : <NEWLINE> <INDENT> ans [ i ] = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( * ans , sep = <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = [ <STRING> ] * n <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> s , c = map ( int , input ( ) . split ( ) ) <NEWLINE> if s == 1 and c == 0 and n != 1 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> break <NEWLINE> <DEDENT> if ans [ s - 1 ] != <STRING> and c != ans [ s - 1 ] : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> break <NEWLINE> <DEDENT> ans [ s - 1 ] = c <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if n == 1 and int ( ans [ 0 ] ) == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> break <NEWLINE> <DEDENT> elif ans [ 0 ] == <STRING> : <NEWLINE> <INDENT> ans [ 0 ] = <STRING> <NEWLINE> <DEDENT> ans = map ( str , ans ) <NEWLINE> print ( <STRING> . join ( ans ) ) <NEWLINE> <DEDENT>
n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> stock = [ set ( ) for i in range ( n ) ] <NEWLINE> ter = [ 0 ] * n <NEWLINE> ans = [ 0 ] * n <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> stock [ a - 1 ] . append ( b - 1 ) <NEWLINE> stock [ b - 1 ] . append ( a - 1 ) <NEWLINE> ans [ a - 1 ] -= 1 <NEWLINE> ans [ b - 1 ] -= 1 <NEWLINE> <DEDENT> def dfs ( j , k ) : <NEWLINE> <INDENT> size [ k ] += 1 <NEWLINE> for next_j in stock [ j ] : <NEWLINE> <INDENT> if ter [ next_j ] == 0 : <NEWLINE> <INDENT> ter [ next_j ] = k <NEWLINE> dfs ( next_j , k ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> total = 0 <NEWLINE> size = [ 0 ] * ( n + 1 ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if ter [ i ] == 0 : <NEWLINE> <INDENT> total += 1 <NEWLINE> ter [ i ] = total <NEWLINE> dfs ( i , total ) <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> ans [ i ] += size [ ter [ i ] ] - 1 <NEWLINE> <DEDENT> for i in range ( k ) : <NEWLINE> <INDENT> c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> if ter [ c - 1 ] == ter [ d - 1 ] : <NEWLINE> <INDENT> ans [ c - 1 ] -= 1 <NEWLINE> ans [ d - 1 ] -= 1 <NEWLINE> <DEDENT> <DEDENT> for i in range ( n - 1 ) : <NEWLINE> <INDENT> print ( ans [ i ] , end = <STRING> ) <NEWLINE> <DEDENT> print ( ans [ n - 1 ] ) <NEWLINE>
import resource ; <NEWLINE> <COMMENT> <NL> sys . setrecursionlimit ( 100000 ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> class UnionFind : <NEWLINE> <INDENT> <STRING> <NEWLINE> <NL> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . node = [ - 1 ] * n <NEWLINE> <NL> <DEDENT> def unite ( self , x , y ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> <COMMENT> <NL> _x , _y = self . find ( x ) , self . find ( y ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> if _x == _y : <NEWLINE> <INDENT> return False <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> if abs ( self . node [ _x ] ) < abs ( self . node [ _y ] ) : <NEWLINE> <INDENT> self . node [ _x ] , self . node [ _y ] = self . node [ _y ] , self . node [ _x ] <NEWLINE> <COMMENT> <NL> <DEDENT> self . node [ _x ] += self . node [ _y ] <NEWLINE> <COMMENT> <NL> self . node [ _y ] = _x <NEWLINE> return True <NEWLINE> <NL> <DEDENT> def find ( self , x ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> _val = self . node [ x ] <NEWLINE> <COMMENT> <NL> if _val < 0 : <NEWLINE> <INDENT> return x <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> self . node [ x ] = self . find ( _val ) <NEWLINE> return self . node [ x ] <NEWLINE> <NL> <DEDENT> def same ( self , x , y ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> return self . find ( x ) == self . find ( y ) <NEWLINE> <NL> <DEDENT> def size ( self , x ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> return abs ( self . node [ self . find ( x ) ] ) <NEWLINE> <NL> <DEDENT> def __str__ ( self ) : <NEWLINE> <INDENT> return str ( self . node ) <NEWLINE> <NL> <DEDENT> <DEDENT> N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> uf = UnionFind ( N ) <NEWLINE> friend = [ 0 ] * N <NEWLINE> block = [ [ ] for _ in range ( N ) ] <NEWLINE> <NL> for _ in range ( M ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> a , b = a - 1 , b - 1 <NEWLINE> uf . unite ( a , b ) <NEWLINE> friend [ a ] , friend [ b ] = friend [ a ] + 1 , friend [ b ] + 1 <NEWLINE> <NL> <DEDENT> for _ in range ( K ) : <NEWLINE> <INDENT> c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> c , d = c - 1 , d - 1 <NEWLINE> block [ c ] . append ( d ) <NEWLINE> block [ d ] . append ( c ) <NEWLINE> <NL> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> ans = uf . size ( i ) - friend [ i ] - 1 <NEWLINE> for j in block [ i ] : <NEWLINE> <INDENT> if uf . same ( i , j ) : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> . format ( ans ) , end = <STRING> ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE>
import numpy as np <NEWLINE> import scipy . sparse as sps <NEWLINE> import scipy . misc as spm <NEWLINE> import collections as col <NEWLINE> import functools as func <NEWLINE> import itertools as ite <NEWLINE> import fractions as frac <NEWLINE> import math as ma <NEWLINE> from math import cos , sin , tan , sqrt <NEWLINE> import cmath as cma <NEWLINE> import copy as cp <NEWLINE> import sys <NEWLINE> import re <NEWLINE> import bisect as bs <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> EPS = sys . float_info . epsilon <NEWLINE> PI = np . pi ; EXP = np . e ; INF = np . inf <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> <NL> def sinput ( ) : return sys . stdin . readline ( ) . strip ( ) <NEWLINE> def iinput ( ) : return int ( sinput ( ) ) <NEWLINE> def imap ( ) : return map ( int , sinput ( ) . split ( ) ) <NEWLINE> def fmap ( ) : return map ( float , sinput ( ) . split ( ) ) <NEWLINE> def iarr ( n = 0 ) : <NEWLINE> <INDENT> if n : return [ 0 for _ in range ( n ) ] <NEWLINE> else : return list ( imap ( ) ) <NEWLINE> <DEDENT> def farr ( ) : return list ( fmap ( ) ) <NEWLINE> def sarr ( n = 0 ) : <NEWLINE> <INDENT> if n : return [ <STRING> for _ in range ( n ) ] <NEWLINE> else : return sinput ( ) . split ( ) <NEWLINE> <DEDENT> def adj ( n ) : return [ [ ] for _ in range ( n ) ] <NEWLINE> <NL> class unionfind : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . parent = [ i for i in range ( n ) ] <NEWLINE> self . size = [ 1 for i in range ( n ) ] <NEWLINE> <DEDENT> def find ( self , a ) : <NEWLINE> <INDENT> if a == self . parent [ a ] : return a <NEWLINE> else : self . parent [ a ] = find ( self , self . parent [ a ] ) ; return self . parent [ a ] <NEWLINE> <DEDENT> def unite ( self , a , b ) : <NEWLINE> <INDENT> pa , pb = self . find ( self , a ) , self . find ( self , b ) <NEWLINE> if pa == pb : return <NEWLINE> else : self . parent [ pb ] = pa ; self . size [ pa ] += self . size [ pb ] <NEWLINE> <DEDENT> def same ( self , a , b ) : return find ( self , a ) == find ( self , b ) <NEWLINE> <NL> <NL> <DEDENT> n , m , k = imap ( ) <NEWLINE> ab = np . array ( [ iarr ( ) for i in range ( n ) ] ) - 1 <NEWLINE> <COMMENT> <NL> uf = unionfind ( n ) <NEWLINE> <NL> f = iarr ( n ) <NEWLINE> for a , b in ab : <NEWLINE> <INDENT> uf . unite ( a , b ) <NEWLINE> f [ a ] += 1 ; f [ b ] += 1 <NEWLINE> <NL> <DEDENT> ng = iarr ( n ) <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> c , d = imap ( ) <NEWLINE> if uf . same ( c , d ) : ng [ c ] += 1 ; ng [ d ] += 1 <NEWLINE> <NL> <DEDENT> anss = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ans = uf . size ( i ) - f [ i ] - ng [ i ] - 1 <NEWLINE> anss . append ( ans ) <NEWLINE> <DEDENT> print ( * anss ) <NEWLINE>
import numpy as np <NEWLINE> from scipy . sparse . csgraph import connected_components <NEWLINE> from scipy . sparse import csr_matrix <NEWLINE> <NL> import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> n , m , k = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> frends_num = [ 0 for i in range ( n ) ] <NEWLINE> def make_frends ( m , n ) : <NEWLINE> <INDENT> data = [ 1 for i in range ( m ) ] <NEWLINE> <NL> row = [ ] <NEWLINE> col = [ ] <NEWLINE> for k in range ( m ) : <NEWLINE> <INDENT> i , j = [ int ( l ) for l in input ( ) . split ( ) ] <NEWLINE> new_i = min ( i , j ) - 1 <NEWLINE> new_j = max ( i , j ) - 1 <NEWLINE> row . append ( new_i ) <NEWLINE> col . append ( new_j ) <NEWLINE> frends_num [ new_i ] += 1 <NEWLINE> frends_num [ new_j ] += 1 <NEWLINE> <DEDENT> frend_sparce_matrix = csr_matrix ( ( data , ( row , col ) ) , shape = ( n , n ) ) <NEWLINE> return frend_sparce_matrix <NEWLINE> <NL> <NL> <DEDENT> frends = make_frends ( m , n ) <NEWLINE> l , labels = connected_components ( frends ) <NEWLINE> labels <NEWLINE> labels = list ( labels ) <NEWLINE> <NL> class Group : <NEWLINE> <INDENT> def __init__ ( self , labels ) : <NEWLINE> <INDENT> self . labels = labels <NEWLINE> self . group_num = [ 0 for i in range ( l ) ] <NEWLINE> for i in labels : <NEWLINE> <INDENT> self . group_num [ i ] += 1 <NEWLINE> <DEDENT> <DEDENT> def get_group_num ( self , i ) : <NEWLINE> <INDENT> return self . group_num [ self . labels [ i ] ] <NEWLINE> <NL> <DEDENT> <DEDENT> group = Group ( labels ) <NEWLINE> <NL> <NL> def get_frend_num ( i ) : <NEWLINE> <INDENT> return frends_num [ i ] <NEWLINE> <NL> <NL> <DEDENT> def make_block ( k , n ) : <NEWLINE> <INDENT> block_num = [ 0 for i in range ( n ) ] <NEWLINE> for p in range ( k ) : <NEWLINE> <INDENT> i , j = [ int ( l ) - 1 for l in input ( ) . split ( ) ] <NEWLINE> new_i = min ( i , j ) <NEWLINE> new_j = max ( i , j ) <NEWLINE> if labels [ new_i ] == labels [ new_j ] : <NEWLINE> <INDENT> block_num [ i ] += 1 <NEWLINE> block_num [ j ] += 1 <NEWLINE> <DEDENT> <DEDENT> return block_num <NEWLINE> <NL> <DEDENT> block = make_block ( k , n ) <NEWLINE> <NL> def get_block_num ( i ) : <NEWLINE> <INDENT> return block [ i ] <NEWLINE> <NL> <DEDENT> ans = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ans . append ( str ( group . get_group_num ( i ) - 1 - get_frend_num ( i ) - get_block_num ( i ) ) ) <NEWLINE> <DEDENT> print ( <STRING> . join ( ) ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> from collections import Counter <NEWLINE> <NL> def dfs ( nw ) : <NEWLINE> <INDENT> for nx in B [ nw ] : <NEWLINE> <INDENT> if V [ nx ] == - 1 : <NEWLINE> <INDENT> V [ nx ] = cnt <NEWLINE> dfs ( nx ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> F = [ [ ] for _ in range ( n ) ] <NEWLINE> B = [ [ ] for _ in range ( n ) ] <NEWLINE> n , m , k = list ( map ( int , sys . stdin . readaline ( ) . split ( ) ) ) <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( lambda x : int ( x ) - 1 , map ( int , sys . stdin . readline ( ) . split ( ) ) ) <NEWLINE> F [ a ] . append ( b ) <NEWLINE> F [ b ] . append ( a ) <NEWLINE> <DEDENT> for i in range ( k ) : <NEWLINE> <INDENT> c , d = map ( lambda x : int ( x ) - 1 , map ( int , sys . stdin . readline ( ) . split ( ) ) ) <NEWLINE> F [ c ] . append ( d ) <NEWLINE> F [ d ] . append ( c ) <NEWLINE> <NL> <DEDENT> V = [ - 1 ] * n <NEWLINE> cnt = 1 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if V [ i ] == - 1 : <NEWLINE> <INDENT> V [ i ] = cnt <NEWLINE> dfs ( i ) <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> cV = Counter ( V ) <NEWLINE> ans = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ans . append ( cV [ V [ i ] ] - 1 - len ( F [ i ] ) - sum ( [ V [ b ] == V [ i ] for b in B [ i ] ] ) ) <NEWLINE> <NL> <DEDENT> print ( * ans ) <NEWLINE>
from collections import Counter <NEWLINE> <NL> class Unionfind ( ) : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . n = n <NEWLINE> self . parents = [ - 1 ] * ( n + 1 ) <NEWLINE> <NL> <DEDENT> def find ( self , x ) : <NEWLINE> <INDENT> if ( self . parents [ x ] < 0 ) : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . parents [ x ] = self . find ( self . parents [ x ] ) <NEWLINE> return self . parents [ x ] <NEWLINE> <NL> <DEDENT> <DEDENT> def union ( self , x , y ) : <NEWLINE> <INDENT> x = self . find ( x ) <NEWLINE> y = self . find ( y ) <NEWLINE> <NL> if ( x == y ) : <NEWLINE> <INDENT> return <NEWLINE> <NL> <DEDENT> if ( self . parents [ x ] > self . parents [ y ] ) : <NEWLINE> <INDENT> x , y = y , x <NEWLINE> <NL> <DEDENT> self . parents [ x ] += self . parents [ y ] <NEWLINE> self . parents [ y ] = x <NEWLINE> <NL> <DEDENT> def size ( self , x ) : <NEWLINE> <INDENT> return - self . parents [ self . find ( x ) ] <NEWLINE> <NL> <DEDENT> def same ( self , x , y ) : <NEWLINE> <INDENT> return self . find ( x ) == self . find ( y ) <NEWLINE> <NL> <DEDENT> def members ( self , x ) : <NEWLINE> <INDENT> root = self . find ( x ) <NEWLINE> return [ i for i in range ( self . n ) if self . find ( i ) == root ] <NEWLINE> <NL> <DEDENT> def roots ( self ) : <NEWLINE> <INDENT> return [ i for i , x in enumerate ( self . parents ) if x < 0 ] <NEWLINE> <NL> <DEDENT> def group_count ( self ) : <NEWLINE> <INDENT> return len ( self . roots ( ) ) <NEWLINE> <NL> <DEDENT> def all_group_members ( self ) : <NEWLINE> <INDENT> return { r : self . members ( r ) for r in self . roots ( ) } <NEWLINE> <NL> <DEDENT> def __str__ ( self ) : <NEWLINE> <INDENT> return <STRING> . join ( <STRING> . format ( r , self . members ( r ) ) for r in self . roots ( ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> N , M , K = map ( int , input ( ) . split ( ) ) <NEWLINE> uf = Unionfind ( N ) <NEWLINE> f = [ 0 for _ in range ( N ) ] <NEWLINE> n = [ 0 for _ in range ( N ) ] <NEWLINE> <NL> for _ in range ( M ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> a -= 1 <NEWLINE> b -= 1 <NEWLINE> uf . union ( a , b ) <NEWLINE> <NL> f [ a ] += 1 <NEWLINE> f [ b ] += 1 <NEWLINE> <NL> <DEDENT> for _ in range ( K ) : <NEWLINE> <INDENT> c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> c -= 1 <NEWLINE> d -= 1 <NEWLINE> if ( uf . same ( c , d ) ) : <NEWLINE> <INDENT> n [ c ] += 1 <NEWLINE> n [ d ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> ans = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> ans . append ( uf . size ( i ) - f [ i ] - n [ i ] - 1 ) <NEWLINE> <NL> <DEDENT> print ( * ans ) v <NEWLINE>
n , m , k = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> f_adj_list = [ [ ] for i in range ( n ) ] <NEWLINE> b_adj_list = [ [ ] for i in range ( n ) ] <NEWLINE> <NL> for i in range ( m ) : <NEWLINE> <INDENT> _ , __ = map ( int , input ( ) . split ( ) ) <NEWLINE> _ -= 1 <NEWLINE> __ -= 1 <NEWLINE> f_adj_list [ _ ] . append ( __ ) <NEWLINE> f_adj_list [ __ ] . append ( _ ) <NEWLINE> <NL> <DEDENT> for j in range ( k ) : <NEWLINE> <INDENT> _ , __ = map ( int , input ( ) . split ( ) ) <NEWLINE> _ -= 1 <NEWLINE> __ -= 1 <NEWLINE> b_adj_list [ _ ] . append ( __ ) <NEWLINE> b_adj_list [ __ ] . append ( _ ) <NEWLINE> <NL> <NL> <DEDENT> group_id = [ None for i in range ( n ) ] <NEWLINE> for i in range ( n ) : <NEWLINE> <COMMENT> <NL> <INDENT> newly_visited = [ i ] <NEWLINE> group_id [ i ] = i <NEWLINE> while len ( newly_visited ) > 0 : <NEWLINE> <INDENT> now = newly_visited . pop ( ) <NEWLINE> for j in f_adj_list [ now ] : <NEWLINE> <INDENT> if group_id [ j ] is not None : continue <NEWLINE> newly_visited . append ( j ) <NEWLINE> group_id [ j ] = i <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> from collections import Counter <NEWLINE> cnt = Counter ( group_id ) <NEWLINE> <COMMENT> <NL> <NL> ans_list = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ans = cnt [ group_id [ i ] ] <NEWLINE> ans -= 1 <COMMENT> <NEWLINE> ans -= len ( f_adj_list [ i ] ) <COMMENT> <NEWLINE> for j in b_adj_list [ i ] : <NEWLINE> <INDENT> if group_id [ i ] == group_id [ j ] : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <DEDENT> <DEDENT> ans_list . append ( ans ) <NEWLINE> <NL> <DEDENT> print ( <STRING> . join ( ans_list ) ) <NEWLINE>
<COMMENT> <NL> from operator import or_ <NEWLINE> <NL> <NL> class SegmentTree : <NEWLINE> <INDENT> _f = None <NEWLINE> _data = None <NEWLINE> _offset = None <NEWLINE> _size = None <NEWLINE> <NL> def __init__ ( self , size , f ) : <NEWLINE> <INDENT> self . _f = f <NEWLINE> self . _size = size <NEWLINE> t = 1 <NEWLINE> while t < size : <NEWLINE> <INDENT> t *= 2 <NEWLINE> <DEDENT> self . _offset = t - 1 <NEWLINE> self . _data = [ 0 ] * ( t * 2 - 1 ) <NEWLINE> <NL> <DEDENT> def build ( self , iterable ) : <NEWLINE> <INDENT> f = self . _f <NEWLINE> data = self . _data <NEWLINE> data [ self . _offset : self . _offset + self . _size ] = iterable <NEWLINE> for i in range ( self . _offset - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> data [ i ] = f ( data [ i * 2 + 1 ] , data [ i * 2 + 2 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> def update ( self , index , value ) : <NEWLINE> <INDENT> f = self . _f <NEWLINE> data = self . _data <NEWLINE> i = self . _offset + index <NEWLINE> data [ i ] = value <NEWLINE> while i >= 1 : <NEWLINE> <INDENT> i = ( i - 1 ) // 2 <NEWLINE> data [ i ] = f ( data [ i * 2 + 1 ] , data [ i * 2 + 2 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> def query ( self , start , stop ) : <NEWLINE> <INDENT> def iter_segments ( data , l , r ) : <NEWLINE> <INDENT> while l < r : <NEWLINE> <INDENT> if l & 1 == 0 : <NEWLINE> <INDENT> yield data [ l ] <NEWLINE> <DEDENT> if r & 1 == 0 : <NEWLINE> <INDENT> yield data [ r - 1 ] <NEWLINE> <DEDENT> l = l // 2 <NEWLINE> r = ( r - 1 ) // 2 <NEWLINE> <DEDENT> <DEDENT> f = self . _f <NEWLINE> it = iter_segments ( self . _data , start + self . _offset , <NEWLINE> <INDENT> stop + self . _offset ) <NEWLINE> <DEDENT> result = next ( it ) <NEWLINE> for e in it : <NEWLINE> <INDENT> result = f ( result , e ) <NEWLINE> <DEDENT> return result <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> <NL> st = SegmentTree ( N , or_ ) <NEWLINE> st . build ( S ) <NEWLINE> <NL> Q = int ( input ( ) ) <NEWLINE> for _ in range ( Q ) : <NEWLINE> <INDENT> q = input ( ) . split ( ) <NEWLINE> if q [ 0 ] == <STRING> : <NEWLINE> <INDENT> i , c = q [ 1 : ] <NEWLINE> i = int ( i ) - 1 <NEWLINE> st . update ( i , c ) <NEWLINE> <DEDENT> elif q [ 0 ] == <STRING> : <NEWLINE> <INDENT> l , r = map ( int , q [ 1 : ] ) <NEWLINE> print ( bin ( st . query ( l - 1 , r ) ) . count ( <STRING> ) ) <NEWLINE> <DEDENT> <DEDENT>
import numpy as np <NEWLINE> from scipy . optimize import fmin <NEWLINE> <NL> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> XYC = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( n ) ] <NEWLINE> <NL> X = np . array ( XYC [ : : 3 ] , dtype = np . float ) <NEWLINE> Y = np . array ( XYC [ 1 : : 3 ] , dtype = np . float ) <NEWLINE> C = np . array ( XYC [ 2 : : 3 ] , dtype = np . float ) <NEWLINE> def f ( xy ) : <NEWLINE> <INDENT> x , y = xy <NEWLINE> times = ( X - x ) * ( X - x ) + ( Y - y ) * ( Y - y ) <NEWLINE> times = C * np . sqrt ( times ) <NEWLINE> times = np . sort ( times ) <NEWLINE> return times [ k - 1 ] <NEWLINE> <DEDENT> ansx = [ fmin ( f , ( x , y ) , disp = False , ftol = 10 ** ( - 7 ) , initial_simplex = [ ( x + 100 , y ) , ( x - 100 , y + 100 ) , ( x - 100 , y - 100 ) ] ) for x , y , c in XYC ] <NEWLINE> ansy = list ( map ( lambda x : f ( x ) , ansx ) ) <NEWLINE> print ( min ( ansy ) ) <NEWLINE>
import numpy as np <NEWLINE> from scipy . optimize import fmin <NEWLINE> import sys <NEWLINE> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> Z = list ( map ( int , sys . stdin . buffer . read ( ) . split ( ) ) ) <NEWLINE> X = np . array ( Z [ : : 3 ] , dtype = np . float ) <NEWLINE> Y = np . array ( Z [ 1 : : 3 ] , dtype = np . float ) <NEWLINE> C = np . array ( Z [ 2 : : 3 ] , dtype = np . float ) <NEWLINE> Z = [ Z [ i * 3 : i * 3 + 3 ] for i in range ( n ) ] <NEWLINE> def f ( x ) : <NEWLINE> <INDENT> x , y = x <NEWLINE> t = np . sort ( C * np . sqrt ( ( X - x ) * ( X - x ) + ( Y - y ) * ( Y - y ) ) ) <NEWLINE> return t [ k - 1 ] <NEWLINE> <DEDENT> A = [ fmin ( f , ( x , y ) , disp = False , ftol = 10 ** ( - 7 ) , initial_simplex = [ ( x + 0.5 , y ) , ( x - 0.5 , y + 0.5 ) , ( x - 0.5 , y - 0.5 ) ] ) for x , y , c in Z ] <NEWLINE> B = list ( map ( lambda x : f ( x ) , A ) ) <NEWLINE> print ( min ( B ) ) <NEWLINE>
N , R = map ( int , input ( ) . split ) <NEWLINE> if N < 10 : <NEWLINE> <INDENT> R = R - 100 * ( 10 - N ) <NEWLINE> print ( R ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( R ) <NEWLINE> <DEDENT>
