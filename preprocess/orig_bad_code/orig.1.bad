<COMMENT> <NL> <NL> x = map ( int , ( raw_input ( ) . split ( ) ) ) <NEWLINE> <NL> if x [ 0 ] < x [ 1 ] ) < x [ 2 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a = input b = input c = input <NEWLINE> if a < b < c print Yes <NEWLINE>
data = input ( ) <NEWLINE> x = [ ] <NEWLINE> x = data . split ( ) <NEWLINE> a = int ( x [ 0 ] ) <NEWLINE> b = int ( x [ 1 ] ) <NEWLINE> c = int ( x [ 2 ] ) <NEWLINE> <NL> <NL> if ( a < b < c ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
inl = map ( int . raw_input ( ) . split ( ) ) <NEWLINE> <NL> a = inl [ 0 ] <NEWLINE> b = inl [ 1 ] <NEWLINE> c = inl [ 2 ] <NEWLINE> <NL> if a < b and b < c : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT>
[ a , b , c ] = [ int ( x ) for x in input ( ) . split ] <NEWLINE> if a < b < c : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b , c = map ( int , raw_input ( ) . split ( ) <NEWLINE> if a < b and b < c : <NEWLINE> <INDENT> c = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> c = <STRING> <NEWLINE> <DEDENT> print c <NEWLINE>
import sys <NEWLINE> a , b , c = map ( int , sys . stdin . readline ( ) . split ( ) ) <NEWLINE> if a < b & & b < c : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b , c = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <INDENT> if a < b < c : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
nums = input ( ) . split ( ) <NEWLINE> a = int ( nums [ 0 ] ) <NEWLINE> b = int ( nums [ 1 ] ) <NEWLINE> c = int ( nums [ 2 ] ) <NEWLINE> if a < b < c : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b , c = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if a < b and b < c : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
m = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if m [ 0 ] < m [ 1 ] < m [ 2 ] : <NEWLINE> <INDENT> print Yes <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print No <NEWLINE> <DEDENT>
a , b , c = map ( int , raw_input ( ) ) <NEWLINE> if a < b < c : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b , c = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> <NL> if a < b and b < c : <NEWLINE> <INDENT> print yes <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print no <NEWLINE> <DEDENT>
a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if ( a < b and b < c ) : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT>
a , b , c = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if a < b < c : <NEWLINE> <INDENT> print yes <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print no <NEWLINE> <DEDENT>
a , b , c = input ( ) . split ( ) <NEWLINE> <NL> <COMMENT> <NL> b = int ( b ) <NEWLINE> c = int ( c ) <NEWLINE> <NL> if a < b < c : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
array = input ( ) . split ( ) <NEWLINE> if ( int ( array [ 0 ] ) > int ( array [ 1 ] ) and int ( array [ 1 ] ) > int ( array [ 2 ] ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
l1 = list ( input ( ) . split ( <STRING> ) ) <NEWLINE> l2 = list ( input ( ) . split ( <STRING> ) ) <NEWLINE> l1 . sort ( ) <NEWLINE> if l1 == l2 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a = raw_input ( ) <NEWLINE> a = a . split ( ) <NEWLINE> for i in range ( 0 , len ( a ) ) : <NEWLINE> <INDENT> a [ i ] = int ( a [ i ] ) <NEWLINE> <DEDENT> b = sorted ( a ) <NEWLINE> for i in range ( 0 , len ( a ) ) : <NEWLINE> <INDENT> if ( a [ i ] != b [ i ] or a [ i ] == a [ i + 1 ] ) : <NEWLINE> <INDENT> print <STRING> <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if ( i == len ( a ) - 1 ) : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT>
a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> if a < b < c : <NEWLINE> <INDENT> print ( Yes ) <NEWLINE> <DEDENT>
nums = input ( ) . split ( ) <NEWLINE> a = int ( nums [ 0 ] ) <NEWLINE> b = int ( nums [ 1 ] ) <NEWLINE> c = unt ( nums [ 2 ] ) <NEWLINE> if a < b < c : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> <NL> if a [ 0 ] < a [ 1 ] < a [ 2 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
num = input ( ) . split ( ) ; <NEWLINE> a = int ( num [ 0 ] ) ; <NEWLINE> b = int ( num [ 1 ] ) ; <NEWLINE> c = int ( num [ 2 ] ) ; <NEWLINE> <NL> if a < b & & b < c : <NEWLINE> <INDENT> print ( <STRING> ) ; <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) ; <NEWLINE> <DEDENT>
a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> if a < b < c : print ( <STRING> ) <NEWLINE> elif : print ( <STRING> ) <NEWLINE>
a , b , c = map ( int , input ( ) . split ) <NEWLINE> if a < b < c : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> if a < b : <NEWLINE> <INDENT> if b < c : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
z = input ( ) <NEWLINE> a , b , c = z . split ( ) <NEWLINE> <NL> if int ( a ) < int ( b ) & & int ( b ) < int ( c ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
( a , b , c ) = input ( ) . rstrip ( ) . split ( ) <NEWLINE> a = int ( a ) <NEWLINE> b = int ( b ) <NEWLINE> c = int ( c ) <NEWLINE> <NL> if a < b < c : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else ; <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
( a , b , c ) = input ( ) . rstrip ( ) . split ( ) <NEWLINE> a = int ( a ) <NEWLINE> b = int ( b ) <NEWLINE> c = int ( c ) <NEWLINE> <NL> if a < b < c <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
li = [ int ( input ( ) . split ( ) ) for i in range ( 3 ) ] <NEWLINE> if li [ 0 ] < li [ 1 ] and li [ 1 ] < li [ 2 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
<NL> <NL> [ a , b , c ] = map ( int , intput ( ) . split ( ) ) <NEWLINE> <NL> print ( { True : <STRING> , False : <STRING> } [ a < b < c ] ) <NEWLINE>
num = raw_input ( ) . split ( <STRING> ) <NEWLINE> <NL> a = num [ 0 ] <NEWLINE> b = num [ 1 ] <NEWLINE> c = num [ 2 ] <NEWLINE> <NL> if a < b and b < c : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <NL> <DEDENT>
a , b , c = map ( int , input ( ) . split ( ) ) ) <NEWLINE> if a < b < c : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> if a < b & & b < c : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
num = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if ( num [ 0 ] < num [ 1 ] & & num [ 1 ] < num [ 2 ] & & num [ 0 ] < num [ 2 ] ) : print ( <STRING> ) <NEWLINE> else : print ( <STRING> ) <NEWLINE>
def isIncremental ( a , b , c ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if a >= b : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> elif b >= c : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> ival = input ( ) . split ( <STRING> ) <NEWLINE> print ( isIncremental ( int ( ival [ 0 ] ) , int ( ival [ 1 ] ) , int ( ival [ 2 ] ) ) <NEWLINE> <DEDENT>
a , b , c = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if ( a < b and b < c ) : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> else <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT>
a , b , c = map ( int , input ( ) , split ( ) ) <NEWLINE> if a < b and b < c : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> a , b , c = input ( ) . split ( ) <NEWLINE> if ( a < B < c ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
num_list = input . split ( ) <NEWLINE> a = int ( num_list [ 0 ] ) <NEWLINE> b = int ( num_list [ 1 ] ) <NEWLINE> c = int ( num_list [ 2 ] ) <NEWLINE> if a > b > c : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = input ( ) . split ( ) <NEWLINE> <NL> n = n . split ( ) <NEWLINE> n = [ int ( i ) for i in n ] <NEWLINE> if ( n [ 0 ] < n [ 1 ] and n [ 1 ] < n [ 2 ] ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( <STRING> , <STRING> if a < b & & b < c else <STRING> ) <NEWLINE>
a , b , c = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> <NL> if a > b and b > c : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT>
a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> print <STRING> if a < b and b < c else <STRING> <NEWLINE>
a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if a < b < c : <NEWLINE> print ( <STRING> ) <NEWLINE> else : <NEWLINE> print ( <STRING> ) <NEWLINE>
i = j = k = 0 <NEWLINE> n = <STRING> <NEWLINE> m = <STRING> <NEWLINE> l = <STRING> <NEWLINE> <NL> line = input ( ) <NEWLINE> <NL> while line [ i ] != <STRING> : <NEWLINE> <INDENT> n = n + line [ i ] <NEWLINE> i += 1 <NEWLINE> <NL> <DEDENT> while line [ i ] != <STRING> : <NEWLINE> <INDENT> l = l + line [ i ] <NEWLINE> i += 1 <NEWLINE> <NL> <DEDENT> while i < len ( line ) : <NEWLINE> <INDENT> m = m + line [ i ] <NEWLINE> i += 1 <NEWLINE> <NL> <DEDENT> n = int ( n ) <NEWLINE> l = int ( l ) <NEWLINE> m = int ( m ) <NEWLINE> <NL> if n < l and l < m : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if a < b amd b < c : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s = input ( ) . split ( ) <NEWLINE> a = int ( s . [ 0 ] ) <NEWLINE> b = int ( s . [ 1 ] ) <NEWLINE> c = int ( s . [ 2 ] ) <NEWLINE> <NL> if ( ( c > b ) and ( b > a ) ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a = int ( input ( ) ) <NEWLINE> b = int ( input ( ) ) <NEWLINE> c = int ( input ( ) ) <NEWLINE> if a < b and b < c : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b , c = [ int ( i ) for i input ( ) . split ( ) ] <NEWLINE> if a < b < c : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b , c = mapt ( int , raw_input ( ) . split ( ) ) <NEWLINE> if a < b and b < c : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT>
<NL> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if a [ 0 ] = < a [ 1 ] = < a [ 2 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
nums = input ( ) . split ( ) <NEWLINE> a = int ( nums [ 0 ] ) <NEWLINE> b = int ( nums [ 1 ] ) <NEWLINE> c = int ( nums [ 2 ] ) <NEWLINE> if a < b < c : <NEWLINE> <INDENT> print ( Yes ) <NEWLINE> <DEDENT>
a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if ( a < b & & b < c ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
l = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> <NL> a = l [ 0 ] <NEWLINE> b = l [ 1 ] <NEWLINE> c = l [ 2 ] <NEWLINE> <NL> if a < b & & b < c : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT>
abc = input ( ) . split ( ) <NEWLINE> if ( int ( abc [ 0 ] ) < int ( abc [ 1 ] ) and int ( abc [ 1 ] < int ( abc [ 2 ] ) ) ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b , c = [ int ( i ) for i in intput ( ) . split ( ) ] <NEWLINE> if a < b < c : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
<NL> using namespace std ; <NEWLINE> <NL> int main ( ) <NEWLINE> { <NEWLINE> <INDENT> int a = 0 , b = 0 , c = 0 ; <NEWLINE> <NL> cin >> a >> b >> c ; <NEWLINE> <NL> if ( a < c ) { <NEWLINE> <INDENT> if ( a < b & & b < c ) <NEWLINE> <INDENT> cout << <STRING> << endl ; <NEWLINE> <DEDENT> else <NEWLINE> <INDENT> cout << <STRING> << endl ; <NEWLINE> <DEDENT> <DEDENT> } <NEWLINE> else <NEWLINE> <INDENT> cout << <STRING> << endl ; <NEWLINE> <NL> <DEDENT> return 0 ; <NEWLINE> <DEDENT> } <NEWLINE>
a = int ( input ( ) ) <NEWLINE> b = int ( input ( ) ) <NEWLINE> c = int ( input ( ) ) <NEWLINE> <NL> if a < b and b < c : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
nums = input ( ) . split ( ) <NEWLINE> a = int ( nums [ 1 ] ) <NEWLINE> b = int ( nums [ 3 ] ) <NEWLINE> c = int ( nums [ 8 ] ) <NEWLINE> if a < b < c : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b , c = map ( int , input ( ) . spilit ( ) ) <NEWLINE> <NL> if a < b < c : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b , c = map ( int , raw_input ( ) . split ( <STRING> ) ) <NEWLINE> <NL> if a < b and b < c : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> else <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT>
a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> if a < b < c : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> <NEWLINE> <DEDENT>
<NL> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( <STRING> + ( <STRING> if a == b else <STRING> if a < b else <STRING> ) + <STRING> ) <NEWLINE>
a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> if a < b & & b < c : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b , c = input ( ) . split ( ) <NEWLINE> a = int ( a ) <NEWLINE> b = int ( b ) <NEWLINE> c = int ( c ) <NEWLINE> <NL> if a < b : <NEWLINE> <INDENT> if b < c : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <NL> <DEDENT>
a , b , c = [ int ( i ) for i in input ( ) ] <NEWLINE> <NL> if a < b < c : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b , c = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if a < b and b < c : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT>
a , b , c = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if a < b & & b < c : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> else <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT>
l = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> a = l [ 0 ] <NEWLINE> b = l [ 1 ] <NEWLINE> if a < b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a > b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> l = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> a = l [ 0 ] <NEWLINE> b = l [ 1 ] <NEWLINE> c = l [ 2 ] <NEWLINE> if a < b < c : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
num = input ( ) . split ( ) <NEWLINE> <INDENT> a = int ( num [ 0 ] ) <NEWLINE> b = int ( num [ 1 ] ) <NEWLINE> c = int ( num [ 2 ] ) <NEWLINE> <DEDENT> if a < b < c : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b , c = map ( int , input ( ) . split ) <NEWLINE> if a > b > c : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b , c = map ( int , input ( ) , split ( ) ) <NEWLINE> <NL> if a < b < c : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b , c = input_raw ( ) . split ( ) <NEWLINE> if a < b < c : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT>
a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> if a < b < c : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> Print ( <STRING> ) <NEWLINE>
a , b , c = [ int ( i ) for i in input ( ) split ( ) ] <NEWLINE> if a < b < c : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
nums = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if nums [ 3 ] > nums [ 2 ] and nums [ 2 ] > nums [ 1 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> import fileinput <NEWLINE> import math <NEWLINE> <NL> def main ( ) : <NEWLINE> <NL> <INDENT> for line in fileinput . input ( ) : <NEWLINE> <INDENT> a , b , c = map ( int , line . strip ( ) . split ( ) ) <NEWLINE> <NL> if ( a < b & & b < c ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> if b <= a : <NEWLINE> <INDENT> print ( No ) <NEWLINE> <DEDENT> elif c <= b : <NEWLINE> <INDENT> print ( No ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( Yes ) <NEWLINE> <DEDENT>
a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> if a < b : <NEWLINE> <INDENT> if b < c : <NEWLINE> <INDENT> print <STRING> <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
a , b , c = int [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> if a < b < c : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
x = input ( ) . split ( <STRING> ) <NEWLINE> a = int ( x [ 0 ] ) <NEWLINE> b = int ( x [ 1 ] ) <NEWLINE> c = int ( x [ 2 ] ) <NEWLINE> <NL> if a <= b <= c : <NEWLINE> <INDENT> print ( a , b , c ) <NEWLINE> <DEDENT> elif a <= c <= b <NEWLINE> <INDENT> print ( a , c , b ) <NEWLINE> <DEDENT> elif b <= a <= c : <NEWLINE> <INDENT> print ( b , a , c ) <NEWLINE> <DEDENT> elif c <= a <= b : <NEWLINE> <INDENT> print ( c , a , b ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( c , b , a ) <NEWLINE> <DEDENT>
a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> if a < b & & b < c : print ( <STRING> ) <NEWLINE> else : print ( <STRING> ) <NEWLINE>
A = int ( input ( ) ) <NEWLINE> if ( 0 <= A and A <= 100 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b , c = map ( int , raw_input ( ) . split ( <STRING> ) ) <NEWLINE> if a < b and b < c : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT>
<NL> a = [ int ( s ) for s in raw_input ( ) . split ( ) ] <NEWLINE> if a [ 0 ] < a [ 1 ] < a [ 2 ] : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> else <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT>
<COMMENT> <NL> a , b , c = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if a < b < c : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT>
a , b , c = map ( int , split ( input ( ) ) ) <NEWLINE> <NL> if ( a < b < c ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> if a < b & & b < c : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
tmp = input ( ) <NEWLINE> tmp = tmp . split ( <STRING> ) <NEWLINE> x , y = map ( int , tmp ) <NEWLINE> if x == y : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> elif x > y : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
abc = input ( ) . split ( ) <NEWLINE> a = int ( a ) <NEWLINE> b = int ( b ) <NEWLINE> c = int ( c ) <NEWLINE> if a < b and b < c : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT>
<COMMENT> <NL> <NL> list = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> a = list [ 0 ] <NEWLINE> b = list [ 1 ] <NEWLINE> c = list [ 2 ] <NEWLINE> <NL> if a < b & & b < c : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT>
abc = input ( ) . split ( ) <NEWLINE> a = int ( abc [ 0 ] ) <NEWLINE> b = int ( abc [ 1 ] ) <NEWLINE> c = int ( abc [ 2 ] ) <NEWLINE> if a < B and b < c : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT>
[ a , b , c ] = int ( input ( ) . split ( ) ) <NEWLINE> if a < b < c : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
as , bs , cs = input ( ) . split ( <STRING> ) <NEWLINE> <NL> a = int ( as ) <NEWLINE> b = int ( bs ) <NEWLINE> c = int ( cs ) <NEWLINE> <NL> if a < b < c : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
<NL> nums = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> if a < b and b < c : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> x = sys . stdin . readline ( ) <NEWLINE> <NL> a_list = x . split ( <STRING> ) <NEWLINE> <NL> if int ( a_list [ 0 ] ) < int ( a_list [ 1 ] ) and int ( a_list [ 1 ] ) < int ( a_list [ 2 ] ) : <NEWLINE> <INDENT> print Yes <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> print No <NEWLINE> <DEDENT>
a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if ( a < b & & b < c ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b , c , = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if a < b < c : <NEWLINE> <INDENT> print ( Yes ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( No ) <NEWLINE> <DEDENT>
a , b , c = [ int ( x ) for x input ( ) . split ( ) ] <NEWLINE> if a < b < c : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT>
nums = input ( ) . split ( ) <NEWLINE> a = int ( nums [ 0 ] ) <NEWLINE> b = int ( nums [ 1 ] ) <NEWLINE> c = int ( nums [ 2 ] ) <NEWLINE> if a < b < c : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif ; <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> s = <STRING> <NEWLINE> <NL> if a < b : <NEWLINE> <INDENT> s = <STRING> <NEWLINE> <DEDENT> elif a > b : <NEWLINE> <INDENT> s = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s = <STRING> <NEWLINE> <NL> <DEDENT> print ( s ) <NEWLINE>
A , B , C = list ( ma ( int , input ( ) . split ( ) ) ) <NEWLINE> if A < B < C : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> prit ( <STRING> ) <NEWLINE> <DEDENT>
a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> <INDENT> if a < b < c : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
string = input ( ) <NEWLINE> a , b , c = map ( int , ( string . split ( <STRING> ) ) ) <NEWLINE> if a < b & & b < c <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b , c = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if a < b < c : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT>
inputStr = raw_input ( ) . split ( <STRING> ) <NEWLINE> a = int ( inputStr [ 0 ] ) <NEWLINE> b = int ( inputStr [ 1 ] ) <NEWLINE> c = int ( inputStr [ 2 ] ) <NEWLINE> if a < b & b < c : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> if a < b < c : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elde : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
d = input ( ) <NEWLINE> a , b , c = map ( d . split ( ) ) <NEWLINE> <NL> if ( a < b ) and ( b < c ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
data = [ int ( i ) for i in input . split ( ) ] <NEWLINE> out = <STRING> . join ( [ str ( i ) for i in sorted ( data ) ] ) <NEWLINE> print ( out ) <NEWLINE>
nums = input ( ) . split ( ) <NEWLINE> a = int ( nums [ 0 ] ) <NEWLINE> b = int ( nums [ 1 ] ) <NEWLINE> c = int ( nums [ 2 ] ) <NEWLINE> <NL> S = sort ( a , b , c ) <NEWLINE> print ( S ) <NEWLINE>
a , b , c = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if a < b : <NEWLINE> <INDENT> a = tmp <NEWLINE> a = b <NEWLINE> b = tmp <NEWLINE> <DEDENT> elif b < c : <NEWLINE> <INDENT> b = tmp <NEWLINE> b = c <NEWLINE> c = tmp <NEWLINE> <DEDENT> elif a < c : <NEWLINE> <INDENT> a = tmp <NEWLINE> a = c <NEWLINE> c = tmp <NEWLINE> <DEDENT> print a b c <NEWLINE>
nums = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> sort_nums = sort . nums <NEWLINE> print ( <STRING> . join ( sort_nums ) ) <NEWLINE>
a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( <STRING> . join ( sorted ( [ a , b , c ] ) ) ) <NEWLINE>
d = map ( int , input ( ) . split ( ) ) <NEWLINE> d . sort ( ) <NEWLINE> print ( d [ 0 ] ) <NEWLINE>
a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if a < b : <NEWLINE> <INDENT> if b < c : <NEWLINE> <INDENT> print ( a , b , c ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( a , c , b ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if a < c : <NEWLINE> <INDENT> print ( b , a , c ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( b , c , a ) <NEWLINE> <NL> <DEDENT>
list = sorted ( map ( int , raw_input ( ) . split ( ) ) ) <NEWLINE> strlist = map ( str , list ) <NEWLINE> print strlist [ 0 ] + <STRING> + strlist [ 1 ] + <STRING> + strlist [ 2 ] <NEWLINE>
number = [ for i in input ( ) . split ( ) ] <NEWLINE> number . sort ( ) <NEWLINE> print ( <STRING> . join ( number ) ) <NEWLINE> <NL> <NL>
input ( ) <NEWLINE> print ( * sorted ( input ( ) . split ( ) ) ) <NEWLINE>
seq = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> <NL> print <STRING> <NEWLINE> for i in range ( len ( seq ) ) : <NEWLINE> <INDENT> for j in range ( i , len ( seq ) - 1 ) : <NEWLINE> <INDENT> if seq [ i ] > seq [ j + 1 ] : <NEWLINE> <INDENT> a = seq [ j + 1 ] <NEWLINE> seq [ j + 1 ] = seq [ i ] <NEWLINE> seq [ i ] = a <NEWLINE> <DEDENT> print i , j + 1 , seq <NEWLINE> <DEDENT> <DEDENT>
x = input ( ) . split ( ) <NEWLINE> y = list ( map ( int , x ) ) <NEWLINE> ( i ) in sorted ( y ) <NEWLINE> print ( i ) <NEWLINE>
a = input ( ) <NEWLINE> b = input ( ) <NEWLINE> c = input ( ) <NEWLINE> <NL> abc = [ a , b , c ] <NEWLINE> abc . sort ( ) <NEWLINE> print ( abc ) <NEWLINE>
j = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> def sort ( ) : <NEWLINE> <INDENT> while i < len ( j ) - 1 : <NEWLINE> <INDENT> if j [ i ] > j [ i + 1 ] : <NEWLINE> <INDENT> j [ i ] , j [ i + 1 ] = j [ i + 1 ] , j [ i ] <NEWLINE> <DEDENT> i = i + 1 <NEWLINE> <DEDENT> <DEDENT> sort ( ) <NEWLINE> sort ( ) <NEWLINE>
a , b , c = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> list = [ a , b , c ] <NEWLINE> ilst . sort ( ) <NEWLINE> for i in list : <NEWLINE> <INDENT> print i <NEWLINE> <DEDENT>
print ( sorted ( input ( ) . split ( ) ) ) . join ( <STRING> ) <NEWLINE>
nums = input ( ) . split ( ) <NEWLINE> a = int ( num [ 0 ] ) <NEWLINE> b = int ( num [ 1 ] ) <NEWLINE> c = int ( num [ 2 ] ) <NEWLINE> <NL> if a > b : <NEWLINE> <INDENT> tmp = a <NEWLINE> a = b <NEWLINE> b = tmp <NEWLINE> <DEDENT> if b > c : <NEWLINE> <INDENT> tmp = b <NEWLINE> b = c <NEWLINE> c = tmp <NEWLINE> <DEDENT> if a > b : <NEWLINE> <INDENT> tmp = a <NEWLINE> a = b <NEWLINE> b = tmp <NEWLINE> <DEDENT> print ( a , b , c ) <NEWLINE>
<COMMENT> <NL> <NL> print ( * . sorted ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE>
a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> a , b , c . sort ( ) <NEWLINE> print <STRING> . format ( a [ 0 ] , b [ 1 ] , c [ 2 ] ) <NEWLINE>
i = input ( ) . split ( <STRING> ) <NEWLINE> <NL> W = int ( i [ 0 ] ) <NEWLINE> H = int ( i [ 1 ] ) <NEWLINE> x = int ( i [ 2 ] ) <NEWLINE> y = int ( i [ 3 ] ) <NEWLINE> r = int ( i [ 4 ] ) <NEWLINE> <NL> if x - r >= 0 and y - r >= 0 and x + r <= W and y + r <= H : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = input ( ) . split ( ) <NEWLINE> m = int ( n [ 0 ] ) <NEWLINE> c = int ( n [ 1 ] ) <NEWLINE> d = int ( n [ 2 ] ) <NEWLINE> n . sort ( ) <NEWLINE> print ( m [ 0 ] , c [ 1 ] , d [ 2 ] ) <NEWLINE>
1 data = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> data . sort ( ) <NEWLINE> print ( <STRING> . format ( data [ 0 ] , data [ 1 ] , data [ 2 ] ) ) <NEWLINE>
nums = int ( input ( ) . split ( ) ) <NEWLINE> nums . sort ( ) <NEWLINE> print ( nums [ 0 ] , nums [ 1 ] , nums [ 2 ] ) <NEWLINE>
list = sorted ( [ int ( x ) for x in input ( ) . split ( ) ] ) <NEWLINE> print ( list [ 0 ] + <STRING> + list [ 1 ] + <STRING> + list [ 2 ] ) <NEWLINE>
<COMMENT> <NL> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> a . reverse ( ) <NEWLINE> <NL> print ( * a ) <NEWLINE>
x = list ( map ( int , input ( ) ) ) <NEWLINE> x . sort ( ) <NEWLINE> print ( x [ 0 ] , x [ 1 ] , x [ 2 ] ) <NEWLINE>
a , b , c = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> num = [ a , b , c ] <NEWLINE> num . sort ( ) <NEWLINE> for i in num <NEWLINE> <INDENT> print i <NEWLINE> <DEDENT>
a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> if ( a < b ) : <NEWLINE> <INDENT> w = a ; a = b ; b = w ; <NEWLINE> <DEDENT> if ( b < c ) : <NEWLINE> <INDENT> w = b ; b = c ; c = w ; <NEWLINE> <DEDENT> if ( a < b ) <NEWLINE> <INDENT> w = a ; a = b ; b = w ; <NEWLINE> <DEDENT> print ( <STRING> ) ; <NEWLINE> <NL> <NL>
hoge = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ret = sorted ( hoge ) <NEWLINE> print ( str ( ret [ 0 ] + <STRING> + str ( ret [ 1 ] ) + <STRING> + str ( ret [ 2 ] ) ) <NEWLINE>
x = raw_input ( ) . split ( ) <NEWLINE> m = map ( int , x ) <NEWLINE> <NL> m . sort ( ) <NEWLINE> a = m [ 0 ] <NEWLINE> b = m [ 1 ] <NEWLINE> c = m [ 2 ] <NEWLINE> <NL> print a , b , c <NEWLINE>
num = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> num . sort ( ) <NEWLINE> print ( num [ 0 ] , num [ 1 ] , num [ 2 ] <NEWLINE>
num = raw_input ( ) . split ( ) <NEWLINE> a = num [ 0 ] <NEWLINE> b = num [ 1 ] <NEWLINE> c = num [ 2 ] <NEWLINE> <NL> if a < b : <NEWLINE> <INDENT> if b < c : <NEWLINE> <INDENT> print <STRING> % ( a , b , c ) <NEWLINE> <DEDENT> if c < b : <NEWLINE> <INDENT> if a < c : <NEWLINE> <INDENT> print <STRING> % ( a , c , b ) <NEWLINE> <DEDENT> if c < a : <NEWLINE> <INDENT> print <STRING> % ( c , a , b ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if b < a : <NEWLINE> <INDENT> if a < c : <NEWLINE> <INDENT> print <STRING> % ( b , a , c ) <NEWLINE> <DEDENT> if c < a : <NEWLINE> <INDENT> if b < c : <NEWLINE> <INDENT> print <STRING> % ( b , c , a ) <NEWLINE> <DEDENT> if c < b : <NEWLINE> <INDENT> print <STRING> % ( c , b , a ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
a = list ( int , input ( ) . split ( ) ) <NEWLINE> a . sort ( ) <NEWLINE> print ( a [ 0 ] , a [ 1 ] , a [ 2 ] ) <NEWLINE>
nums = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> nums_sort = sorted ( nums ) <NEWLINE> nums_str = map ( str , nums ) <NEWLINE> print <STRING> <STRING> <STRING> . format ( nums_str ) <NEWLINE>
input_lines = raw_input ( ) <NEWLINE> n1_n2_n3 = input_lines . rstrip ( ) . split ( <STRING> ) <NEWLINE> n1 = int ( n1_n2_n3 [ 0 ] ) <NEWLINE> n2 = int ( n1_n2_n3 [ 1 ] ) <NEWLINE> n3 = int ( n1_n2_n3 [ 2 ] ) <NEWLINE> num_list = [ ] <NEWLINE> num_list . append ( n1 ) <NEWLINE> num_list . append ( n2 ) <NEWLINE> num_list . append ( n3 ) <NEWLINE> num_list . sort ( ) <NEWLINE> print str ( num_list [ 0 ] ) + <STRING> + str ( num_list [ 1 ] ) + <STRING> + str ( num_list [ 2 ] ) + <STRING> <NEWLINE>
a = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> print ( <STRING> . join ( sorted ( a ) ) ) <NEWLINE>
A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> print ( sort ( A ) ) <NEWLINE>
al = list ( map ( int , raw_input ( ) . split ( ) ) ) <NEWLINE> al = sorted ( al ) <NEWLINE> print ( al [ 0 ] , al [ 1 ] , al [ 2 ] ) <NEWLINE>
l = list ( input ( ) . split ( ) ) <NEWLINE> print ( <STRING> a . join ( map ( str , sorted ( l ) ) ) ) <NEWLINE>
a = input ( ) <NEWLINE> b = list ( map ( int , a . split ( ) ) ) <NEWLINE> b . sort ( ) <NEWLINE> print ( b [ 0 ] + <STRING> + b [ 1 ] + <STRING> + b [ 2 ] ) <NEWLINE>
import sys <NEWLINE> <NL> x = sys . stdin . readline ( ) <NEWLINE> a1 , b1 , c1 = x . split ( <STRING> ) <NEWLINE> <NL> a = int ( a1 ) <NEWLINE> b = int ( b1 ) <NEWLINE> c = int ( c1 ) <NEWLINE> <NL> max = a <NEWLINE> mid = a <NEWLINE> min = a <NEWLINE> <NL> if max < b : <NEWLINE> <INDENT> max = b <NEWLINE> <DEDENT> elif min > b : <NEWLINE> <INDENT> min = b <NEWLINE> <DEDENT> if max < c : <NEWLINE> <INDENT> mid = max <NEWLINE> max = c <NEWLINE> <DEDENT> elif min > c : <NEWLINE> <INDENT> mid = min <NEWLINE> min = c <NEWLINE> <NL> <DEDENT> print ( <STRING> ) , % ( max , mid , min ) <NEWLINE>
<COMMENT> <NL> input = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> input . sort ( ) <NEWLINE> print ( str ( input_str [ 0 ] ) + <STRING> + str ( input_str [ 1 ] ) + <STRING> + str ( input_str [ 2 ] ) ) <NEWLINE>
num = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> <NL> num . sort ( ) <NEWLINE> <NL> print ( num [ 0 ] , num [ 1 ] , num [ 2 ] ) <NEWLINE>
list = raw_input ( ) . split ( <STRING> ) <NEWLINE> list . sort ( ) <NEWLINE> print ( <STRING> . join ( list ) ) <NEWLINE>
a = input ( ) <NEWLINE> <INDENT> b = a . split ( ) <NEWLINE> c = list ( ) <NEWLINE> for d in b : <NEWLINE> <INDENT> c . append ( int ( d ) ) <NEWLINE> <DEDENT> d = sorted ( c ) <NEWLINE> print ( d [ 0 ] , d [ 1 ] , d [ 2 ] ) <NEWLINE> <NL> <DEDENT>
a = map ( int , input ( ) . split ( ) ) <NEWLINE> a . sort ( ) <NEWLINE> for i in range ( 3 ) : <NEWLINE> <INDENT> print ( a [ i ] ) , <NEWLINE> <DEDENT>
N = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> <NL> a = N [ 0 ] <NEWLINE> b = N [ 1 ] <NEWLINE> c = N [ 2 ] <NEWLINE> <NL> if a < b < c : <NEWLINE> <INDENT> print <STRING> % ( a , b , c ) <NEWLINE> <DEDENT> elif a < c < b : <NEWLINE> <INDENT> print <STRING> % ( a , c , b ) <NEWLINE> <DEDENT> elif b < a < c : <NEWLINE> <INDENT> print <STRING> % ( b , a , c ) <NEWLINE> <DEDENT> elif b < c < a : <NEWLINE> <INDENT> print <STRING> % ( b , c , a ) <NEWLINE> <DEDENT> elif c < a < b : <NEWLINE> <INDENT> print <STRING> % ( c , a , b ) <NEWLINE> <DEDENT> else c < b < a : <NEWLINE> <INDENT> print <STRING> % ( c , b , a ) <NEWLINE> <DEDENT>
a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = sorted ( a ) <NEWLINE> <STRING> . join ( a ) <NEWLINE>
x = input ( ) . split ( <STRING> ) <NEWLINE> x = list ( map ( int , x ) ) . sort ( ) <NEWLINE> <NL> print ( x [ 0 ] , x [ 1 ] , x [ 2 ] ) <NEWLINE>
nums = list ( map ( ( int , input ( ) . split ( ) ) ) ) <NEWLINE> nums . sort ( ) <NEWLINE> print ( nums [ 0 ] , nums [ 1 ] , nums [ 2 ] ) <NEWLINE> <NL>
nums = input ( ) . split ( ) <NEWLINE> a = int ( nums [ 0 ] ) <NEWLINE> b = int ( nums [ 1 ] ) <NEWLINE> c = int ( nums [ 2 ] ) <NEWLINE> sorted ( a , b , c ) <NEWLINE>
a , b , c = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> <NL> if a > c : <NEWLINE> <INDENT> k = c <NEWLINE> c = a <NEWLINE> a = k <NEWLINE> <DEDENT> if c < b : <NEWLINE> <INDENT> k = b <NEWLINE> b = c <NEWLINE> c = k <NEWLINE> <DEDENT> if b < a <NEWLINE> <INDENT> k = b <NEWLINE> b = a <NEWLINE> a = k <NEWLINE> <DEDENT> a , b , c = map ( str , ( a , b , c ) ) <NEWLINE> print ( a + <STRING> + b + <STRING> + c ) <NEWLINE>
list1 = input ( ) . split ( <STRING> ) <NEWLINE> list2 = list ( map ( int , list1 ) ) <NEWLINE> list3 = list2 . sort ( ) <NEWLINE> list4 = list ( map ( str , list3 ) ) <NEWLINE> answer_string = <STRING> . join ( list4 ) <NEWLINE> <NL> print ( answer_string ) <NEWLINE>
l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> l . sort ( ) <NEWLINE> print ( l [ 0 ] , l [ 1 ] , l [ [ 2 ] ) <NEWLINE>
x = input ( ) <NEWLINE> <NL> for i in x : <NEWLINE> <NL> <INDENT> if x == 0 : <NEWLINE> break <NEWLINE> <NL> print ( <STRING> + i + <STRING> + x ) <NEWLINE> <DEDENT>
inputlines = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> li = inputlines . sort ( ) <NEWLINE> print ( <STRING> . join ( map ( str , li ) ) ) <NEWLINE>
[ a , b , c ] = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> min = min ( a , b , c ) <NEWLINE> max = max ( a , b , c ) <NEWLINE> nokori = sam ( a , b , c ) - min - max <NEWLINE> <NL> print ( min , nokori , max ) <NEWLINE>
x , y , z = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> s = [ x , y , z ] <NEWLINE> <NL> print ( str ( sorted ( s ) ) <NEWLINE>
import sys <NEWLINE> l = [ int ( i ) for i in sys . stdin . readline ( ) . split ( ) ] <NEWLINE> l . sort ( ) <NEWLINE> print ( <STRING> . join ( l ) ) <NEWLINE>
a = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> print <STRING> . join ( sorted ( a ) ) <NEWLINE>
a , b , c = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> max_min = sorted ( a , b , c ) <NEWLINE> for i in range ( len ( max_min ) ) : <NEWLINE> <INDENT> print max_min [ i ] , <NEWLINE> <DEDENT>
a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> if a > b : <NEWLINE> <INDENT> x = a <NEWLINE> a = b <NEWLINE> b = x <NEWLINE> <DEDENT> else : <NEWLINE> if b > c : <NEWLINE> <INDENT> y = c <NEWLINE> c = b <NEWLINE> b = y <NEWLINE> <DEDENT> else : <NEWLINE> if a > b : <NEWLINE> <INDENT> x = a <NEWLINE> a = b <NEWLINE> b = x <NEWLINE> <DEDENT> else : <NEWLINE> print ( a , b , c ) <NEWLINE>
a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if a <= b : <NEWLINE> <INDENT> if b <= c : <NEWLINE> <INDENT> print ( <STRING> . format ( a , b , c ) ) <NEWLINE> <DEDENT> else if c <= a : <NEWLINE> <INDENT> print ( <STRING> . format ( c , a , b ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> . format ( a , c , b ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if a <= c : <NEWLINE> <INDENT> print ( <STRING> . format ( b , a , c ) ) <NEWLINE> <DEDENT> else if c <= b : <NEWLINE> <INDENT> print ( <STRING> . format ( c , b , a ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> . format ( b , c , a ) ) <NEWLINE> <DEDENT> <DEDENT>
List = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> print ( <STRING> . join ( [ i for i in sorted ( List ) ] ) ) <NEWLINE>
s <NEWLINE>
numbers = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> numbers . sort ( ) <NEWLINE> print ( numbers [ 0 ] numbers [ 1 ] numbers [ 2 ] ) <NEWLINE>
nums = input ( ) , split ( ) <NEWLINE> a = int ( nums [ 0 ] ) <NEWLINE> b = int ( nums [ 1 ] ) <NEWLINE> c = int ( nums [ 2 ] ) <NEWLINE> if a <= b <= c : <NEWLINE> <INDENT> print ( a , b , c ) <NEWLINE> <DEDENT> elif a <= c <= b : <NEWLINE> <INDENT> print ( a , c , b ) <NEWLINE> <DEDENT> elif b <= a <= c : <NEWLINE> <INDENT> print ( b , a , c ) <NEWLINE> <DEDENT> elif b <= c <= a : <NEWLINE> <INDENT> print ( b , c , a ) <NEWLINE> <DEDENT> elif c <= a <= b : <NEWLINE> <INDENT> print ( c , a , b ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( c , b , a ) <NEWLINE> <DEDENT>
x = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> x = x . sort ( ) <NEWLINE> print ( <STRING> . format ( x [ 0 ] , x [ 1 ] , x [ 2 ] ) ) <NEWLINE>
a = list ( raw_input ( ) . split ( <STRING> ) ) ) <NEWLINE> b = map ( int , a ) <NEWLINE> b . sort ( ) <NEWLINE> print <STRING> . join ( map ( str , b ) ) <NEWLINE>
i = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> i . sort ( ) <NEWLINE> for x in i : <NEWLINE> <INDENT> print x , <NEWLINE> <DEDENT> print <STRING> <NEWLINE>
a , b , c = map ( raw_input ( ) . split ( ) ) <NEWLINE> temp = 0 <NEWLINE> <NL> if b < c : <NEWLINE> <INDENT> temp = b <NEWLINE> b = c <NEWLINE> c = temp <NEWLINE> <DEDENT> if a < b : <NEWLINE> <INDENT> temp = a <NEWLINE> a = b <NEWLINE> b = temp <NEWLINE> <NL> <DEDENT> print <STRING> . format ( a , b , c ) <NEWLINE>
s = input ( ) . split ( ) <NEWLINE> a = int ( s [ 0 ] ) <NEWLINE> b = int ( s [ 1 ] ) <NEWLINE> c = int ( s [ 2 ] ) <NEWLINE> num = [ a , b , c ] <NEWLINE> num . sort ( ) <NEWLINE> print ( str ( num [ 0 ] ) + <STRING> + str ( num [ 1 ] ) + <STRING> + str ( num [ 2 ] ) ) ) <NEWLINE>
d = raw_input ( ) <NEWLINE> d = d . split ( <STRING> ) <NEWLINE> d = list ( map ( int , d ) ) <NEWLINE> d = d . sort ( ) <NEWLINE> a = str ( d [ 0 ] ) <NEWLINE> b = str ( d [ 1 ] ) <NEWLINE> c = str ( d [ 2 ] ) <NEWLINE> print a + <STRING> + b + <STRING> + c <NEWLINE>
l = list ( map ( int , raw_input ( ) . split ( ) ) ) <NEWLINE> L = sorted ( l ) <NEWLINE> print ( L [ 0 ] , L [ 1 ] , L [ 2 ] ) <NEWLINE>
n = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> n . sort ( ) <NEWLINE> print ( n [ 0 ] , n [ 1 ] , n [ 2 ] , sep = ( ) ) <NEWLINE>
print ( sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE>
num_sorted = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> print ( <STRING> . format ( num_sorted . sort ( ) [ 0 ] , num_sorted . sort ( ) [ 1 ] , num_sorted . sort ( ) [ 2 ] ) ) <NEWLINE>
l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> print <STRING> . join ( map ( str , sorted ( l ) ) ) <NEWLINE>
a , b , c = sorted ( input ( ) . split ( ) ) <NEWLINE> <INDENT> print ( a , b , c ) <NEWLINE> <DEDENT>
table = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i in range ( 2 , 0 , - 1 ) : <NEWLINE> <INDENT> k = 0 <NEWLINE> while k < i : <NEWLINE> <INDENT> if table [ k ] > table [ k + 1 ] : <NEWLINE> <INDENT> table [ k ] , table [ k + 1 ] = table [ k + 1 ] , table [ k ] <NEWLINE> k += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( table [ 0 ] , table [ 1 ] , table [ 2 ] ) <NEWLINE>
a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> print ( sort ( a ) ) <NEWLINE>
z = [ input ( i ) for i in input ( ) . split ( ) ] <NEWLINE> z = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> z . sort ( ) <NEWLINE> print ( <STRING> . format ( z [ 0 ] , z [ 1 ] , z [ 2 ] ) ) <NEWLINE>
a = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> <NL> a . sort ( ) <NEWLINE> for i in range ( len ( a ) ) : <NEWLINE> <INDENT> print <STRING> % ( a [ i ] ) , <NEWLINE> <DEDENT> print <STRING> <NEWLINE>
li = sorted ( list ( int , input ( ) . split ( ) ) ) <NEWLINE> print ( * li ) <NEWLINE>
if __name__ == <STRING> : <NEWLINE> <INDENT> x = input ( ) . split ( <STRING> ) <NEWLINE> a = int ( x [ 0 ] ) <NEWLINE> b = int ( x [ 1 ] ) <NEWLINE> c = int ( x [ 2 ] ) <NEWLINE> <NL> if a > b and b > c : <NEWLINE> <INDENT> print ( <NEWLINE> <NL> <DEDENT> <DEDENT>
num = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> list = [ ] <NEWLINE> <NL> for i in num : <NEWLINE> <INDENT> if ( i == 0 ) : list . append ( num [ i ] ) <NEWLINE> else : <NEWLINE> <INDENT> if ( list [ i - 1 ] > num [ i ] ) : <NEWLINE> <INDENT> list . append = list [ i ] <NEWLINE> list [ i - 1 ] = num [ i ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> l . sort ( ) <NEWLINE> for i in l : <NEWLINE> <INDENT> if i == len ( l ) - 1 : <NEWLINE> <INDENT> print ( l [ i ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( l [ i ] , end = <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
data = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> data . sort ( ) <NEWLINE> print ( <STRING> . format [ data [ 0 ] , data [ 1 ] , data [ 2 ] ] ) <NEWLINE>
a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> d = sorted ( [ a , b , c ] ) <NEWLINE> print <STRING> . format ( d [ 0 ] , d [ 1 ] , d [ 2 ] ) <NEWLINE>
a , b , c = raw_input ( ) . split ( ) <NEWLINE> a , b , c = map ( int , ( a , b , c ) ) <NEWLINE> ls = list ( ( a , b , c ) ) <NEWLINE> ls . sort ( ) <NEWLINE> string_ans = <STRING> <NEWLINE> for k in ls : <NEWLINE> <INDENT> string = <STRING> <NEWLINE> string = str ( k ) + <STRING> <NEWLINE> string_ans = string_ans + string <NEWLINE> <DEDENT> print string_ans <NEWLINE>
nums = input ( ) . split ( ) <NEWLINE> a = int ( nums [ 0 ] ) <NEWLINE> b = int ( nums [ 1 ] ) <NEWLINE> c = int ( nums [ 2 ] ) <NEWLINE> <NL> if a > b : <NEWLINE> <INDENT> tmp = a <NEWLINE> a = b <NEWLINE> b = tmp <NEWLINE> <DEDENT> if b > c : <NEWLINE> <INDENT> tmp = b <NEWLINE> b = c <NEWLINE> c = tmp <NEWLINE> <DEDENT> if a > b : <NEWLINE> <INDENT> tmp = a <NEWLINE> a = b <NEWLINE> b = tmp <NEWLINE> <NL> <DEDENT> pritn ( a , b , c ) <NEWLINE>
a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> if a > b : <NEWLINE> <INDENT> i = a <NEWLINE> a = b <NEWLINE> b = i <NEWLINE> <DEDENT> if b > c : <NEWLINE> <INDENT> i = b <NEWLINE> b = c <NEWLINE> c = b <NEWLINE> <DEDENT> if a > c : <NEWLINE> <INDENT> i = a <NEWLINE> a = c <NEWLINE> c = i <NEWLINE> <NL> <DEDENT> str = <STRING> <NEWLINE> print ( str . format ( d = a , e = b , f = c ) <NEWLINE>
num_list = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> print <STRING> . join ( map ( str , sorted ( numlist ) ) <NEWLINE>
a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> if a = < b : <NEWLINE> <INDENT> if b < c : <NEWLINE> <INDENT> x = a <NEWLINE> y = b <NEWLINE> z = c <NEWLINE> <DEDENT> elif b > c : <NEWLINE> <INDENT> if c < a : <NEWLINE> <INDENT> x = c <NEWLINE> y = a <NEWLINE> z = b <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = a <NEWLINE> y = c <NEWLINE> z = b <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if a = > b : <NEWLINE> <INDENT> if b > c : <NEWLINE> <INDENT> x = c <NEWLINE> y = b <NEWLINE> z = a <NEWLINE> <DEDENT> elif b < c : <NEWLINE> <INDENT> if c < a : <NEWLINE> <INDENT> x = b <NEWLINE> y = c <NEWLINE> z = a <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = b <NEWLINE> y = a <NEWLINE> z = c <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> print ( str ( x ) + <STRING> + str ( y ) + <STRING> + str ( z ) ) <NEWLINE>
a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> x = a , b , c <NEWLINE> x . sort ( ) <NEWLINE> print ( x ) <NEWLINE>
data = int ( input ( ) ) <NEWLINE> list = data . split ( <STRING> ) <NEWLINE> <NL> list . sort ( ) <NEWLINE> <NL> print ( <STRING> . format ( list [ 0 ] , list [ 1 ] , list [ 2 ] ) ) <NEWLINE>
list = [ i for i in input ( ) . split ( ) ] <NEWLINE> print ( <STRING> . join ( [ int ( i ) for i in sorted ( list ) ] ) ) <NEWLINE>
a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> if a > b : <NEWLINE> <INDENT> temp = a <NEWLINE> a = b <NEWLINE> b = temp <NEWLINE> <DEDENT> if b > c : <NEWLINE> <INDENT> temp = b <NEWLINE> b = c <NEWLINE> c = temp <NEWLINE> <DEDENT> if a > b : <NEWLINE> <INDENT> temp = a <NEWLINE> a = b <NEWLINE> b = temp <NEWLINE> <DEDENT> print ( srt ( a ) + <STRING> + str ( b ) + <STRING> + str ( c ) <NEWLINE> <NL> <NL> <NL>
a , b , c = map ( int , raw_input ( <STRING> ) ) <NEWLINE> <NL> l = [ ] <NEWLINE> l . append ( a ) <NEWLINE> l . append ( b ) <NEWLINE> l . append ( c ) <NEWLINE> <NL> l = sorted ( l ) <NEWLINE> print str ( l [ 0 ] ) + <STRING> + str ( l [ 1 ] ) + <STRING> + str ( l [ 2 ] ) <NEWLINE>
p = [ x , y , z ] <NEWLINE> x , y , z = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> p . sort ( ) <NEWLINE> print ( p ) <NEWLINE>
a = list ( map ( input ( ) . split ( ) ) ) <NEWLINE> a . sort ( ) <NEWLINE> <NL> print ( a [ 0 ] , a [ 1 ] , a [ 2 ] ) <NEWLINE>
a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> x = [ a , b , c ] <NEWLINE> x . sort ( ) <NEWLINE> <NL> print ( x [ 0 ] ) <NEWLINE> print ( x [ 1 ] ) <NEWLINE> Print ( x [ 2 ] ) <NEWLINE>
inp = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> l = inp . sort ( ) <NEWLINE> print ( l [ 0 ] , l [ 1 ] , l [ 2 ] ) <NEWLINE>
x = sorted ( [ int ( i ) for i in input ( ) . split ( ) ] ) <NEWLINE> print ( <STRING> . format ( x ) ) <NEWLINE>
a = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> a . sort ( ) <NEWLINE> print a [ 0 ] , a [ 1 ] , a [ 3 ] <NEWLINE>
z = input ( ) <NEWLINE> l = z . split ( ) <NEWLINE> l . sort ( ) <NEWLINE> print ( <STRING> % l [ 0 ] , l [ 1 ] , l [ 2 ] ) <NEWLINE>
num = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> num . sort ( ) <NEWLINE> print ( num [ ] ) <NEWLINE>
a , b , c = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> lists = [ a , b , c ] <NEWLINE> new_list = sorted ( lists ) <NEWLINE> print new_lists [ 0 ] , new_lists [ 1 ] , new_lists [ 2 ] <NEWLINE>
a , b , c = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> l = [ a , b , c ] . sort ( ) <NEWLINE> print l [ 0 ] , l [ 1 ] , l [ 2 ] <NEWLINE>
a = sorted ( map ( int , raw_input ( ) . split ( ) ) ) <NEWLINE> ans = <STRING> <NEWLINE> for item in a : <NEWLINE> <INDENT> ans += <STRING> % ( item ) <NEWLINE> <DEDENT> print ans <NEWLINE>
a , b , c = map ( int , input ( ) , split ( ) ) <NEWLINE> if a > b : <NEWLINE> <INDENT> a , b = b , a <NEWLINE> <DEDENT> if b > c : <NEWLINE> <INDENT> c , b = b , c <NEWLINE> <DEDENT> if a > b : <NEWLINE> <INDENT> a , b = b , a <NEWLINE> <DEDENT> print ( a , b , c ) <NEWLINE> <NL>
a = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> a . sort ( ) <NEWLINE> print ( <STRING> , join ( map ( str , a ) ) ) <NEWLINE> <NL> <NL>
nums = [ int ( e ) for e in input ( ) . split ( ) ] <NEWLINE> for i in range ( len ( nums ) ) : <NEWLINE> <INDENT> for j in range ( i ) : <NEWLINE> <INDENT> if nums [ i ] < nums [ j ] : <NEWLINE> <INDENT> a = nums [ i ] <NEWLINE> nums [ i ] = nums [ j ] <NEWLINE> nums [ j ] = a <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> nums_2 = <STRING> . join ( nums ) <NEWLINE> print ( nums_2 ) <NEWLINE>
<COMMENT> <NL> <NL> a , b , c = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> <NL> numlist = [ a , b , c ] <NEWLINE> <NL> numlist . sorted ( ) <NEWLINE> print ( numlist ) <NEWLINE>
x = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> print ( <STRING> . format ( sorted ( x ) ) ) <NEWLINE>
L = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> L . sort ( ) <NEWLINE> print <STRING> . join ( L ) <NEWLINE>
a , b , c = input . split ( ) <NEWLINE> a = int ( 3 ) <NEWLINE> b = int ( 2 ) <NEWLINE> c = int ( 4 ) <NEWLINE> numbers = [ a , b , c ] <NEWLINE> numbers . sort ( ) <NEWLINE> print ( numbers ) <NEWLINE>
a , b , c = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> <NL> def check ( i , j ) : <NEWLINE> <INDENT> if i > j : <NEWLINE> <INDENT> temp = i <NEWLINE> i = j <NEWLINE> j = temp <NEWLINE> <NL> <DEDENT> <DEDENT> check ( a , b ) <NEWLINE> check ( b , c ) <NEWLINE> check ( a , b ) <NEWLINE> <NL> print a , b , c <NEWLINE>
print ( * sorted ( map ( int , i . split ( ) ) ) ) <NEWLINE>
<COMMENT> <NL> <NL> num = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> bubble_sort ( num ) <NEWLINE> print ( num [ 0 ] , num [ 1 ] , num [ 2 ] ) <NEWLINE> <NL> def bubble_sort ( arr ) : <NEWLINE> <INDENT> change = True <NEWLINE> while change : <NEWLINE> <INDENT> change = False <NEWLINE> for i in range ( len ( arr ) - 1 ) : <NEWLINE> <INDENT> if arr [ i ] > arr [ i + 1 ] : <NEWLINE> <INDENT> arr [ i ] , arr [ i + 1 ] = arr [ i + 1 ] , arr [ i ] <NEWLINE> change = True <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return arr <NEWLINE> <DEDENT>
data = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> data . sort ( ) <NEWLINE> print ( <STRING> . format ( data [ 0 ] , data [ 2 ] ) ) <NEWLINE>
a , b , c = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> n = [ a , b , c ] <NEWLINE> x = n . sort ( ) <NEWLINE> for i in x : <NEWLINE> <INDENT> print i , <NEWLINE> <DEDENT>
a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> if a < b : <NEWLINE> <INDENT> if a < c : <NEWLINE> <INDENT> if b < c : <NEWLINE> <INDENT> print ( a , b , c ) <NEWLINE> else : <NEWLINE> <INDENT> print ( a , c , b ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( c , a , b ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if b < c : <NEWLINE> <INDENT> if a < c : <NEWLINE> <INDENT> print ( b , a , c ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( b , c , a ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( c , b , a ) <NEWLINE> <DEDENT> <DEDENT>
y = list ( map ( int , x ) ) <NEWLINE> a = y [ 0 ] <NEWLINE> b = y [ 1 ] <NEWLINE> c = y [ 2 ] <NEWLINE> d = sorted ( [ a , b , c ] ) <NEWLINE> print ( <STRING> . format ( d [ 0 ] , d [ 1 ] , d [ 2 ] ) ) <NEWLINE>
a = list ( int ( i ) for i in input ( ) . split ( ) ) <NEWLINE> a . sort ( ) <NEWLINE> b = <STRING> . join ( a ) <NEWLINE>
n = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if n [ 0 ] = < n [ 1 ] = < n [ 2 ] : <NEWLINE> <INDENT> a = n [ 0 ] <NEWLINE> b = n [ 1 ] <NEWLINE> c = n [ 2 ] <NEWLINE> <DEDENT> elif n [ 0 ] = < n [ 2 ] = < n [ 1 ] : <NEWLINE> <INDENT> a = n [ 0 ] <NEWLINE> b = n [ 2 ] <NEWLINE> c = n [ 1 ] <NEWLINE> <DEDENT> elif n [ 1 ] = < n [ 0 ] = < n [ 2 ] : <NEWLINE> <INDENT> a = n [ 1 ] <NEWLINE> b = n [ 0 ] <NEWLINE> c = n [ 2 ] <NEWLINE> <DEDENT> elif n [ 1 ] = < n [ 2 ] = < n [ 0 ] : <NEWLINE> <INDENT> a = n [ 1 ] <NEWLINE> b = n [ 2 ] <NEWLINE> c = n [ 0 ] <NEWLINE> <DEDENT> elif n [ 2 ] = < n [ 0 ] = < n [ 1 ] : <NEWLINE> <INDENT> a = n [ 2 ] <NEWLINE> b = n [ 0 ] <NEWLINE> c = n [ 1 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a = n [ 2 ] <NEWLINE> b = n [ 1 ] <NEWLINE> c = n [ 0 ] <NEWLINE> <DEDENT> print a , b , c <NEWLINE>
a , b , c = [ int ( x ) in x for input ( ) . split ( ) ] <NEWLINE> if a < b < c : <NEWLINE> <INDENT> print ( a , b , c , sep = <STRING> ) <NEWLINE> <DEDENT> elif a < c < b : <NEWLINE> <INDENT> print ( a , c , b , sep = <STRING> ) <NEWLINE> <DEDENT> elif b < a < c : <NEWLINE> <INDENT> print ( b , a , c , sep = <STRING> ) <NEWLINE> <DEDENT> elif b < c < a : <NEWLINE> <INDENT> print ( b , c , a , sep = <STRING> ) <NEWLINE> <DEDENT> elif c < a < b : <NEWLINE> <INDENT> print ( c , a , b , sep = <STRING> ) <NEWLINE> <DEDENT> elif c < b < a : <NEWLINE> <INDENT> print ( c , b , a , sep = <STRING> ) <NEWLINE> <NL> <DEDENT>
l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> l . sort ( ) <NEWLINE> print <STRING> . join ( l ) <NEWLINE>
<NL> <STRING> <NEWLINE> a , b , c = map ( int , input ( ) . split ) <NEWLINE> if a > b : <NEWLINE> <INDENT> a , b = b , a <NEWLINE> <NL> <DEDENT> if b > c : <NEWLINE> <INDENT> b , c = c , b <NEWLINE> <NL> <DEDENT> if a > b : <NEWLINE> <INDENT> a , b = b , a <NEWLINE> <NL> <DEDENT> print ( a , b , c ) <NEWLINE>
N = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> <NL> if N [ 0 ] < N [ 1 ] < N [ 2 ] : <NEWLINE> <INDENT> print <STRING> % ( N [ 0 ] , N [ 1 ] , N [ 2 ] ) <NEWLINE> <DEDENT> elif N [ 0 ] < N [ 2 ] < N [ 1 ] : <NEWLINE> <INDENT> print <STRING> % ( N [ 0 ] , N [ 1 ] , N [ 2 ] ) <NEWLINE> <DEDENT> elif N [ 1 ] < N [ 0 ] < N [ 2 ] : <NEWLINE> <INDENT> print <STRING> % ( N [ 1 ] , N [ 0 ] , N [ 2 ] ) <NEWLINE> <DEDENT> elif N [ 1 ] < N [ 2 ] < N [ 0 ] : <NEWLINE> <INDENT> print <STRING> % ( N [ 1 ] , N [ 2 ] , N [ 0 ] ) <NEWLINE> <DEDENT> elif N [ 2 ] < N [ 0 ] < N [ 1 ] : <NEWLINE> <INDENT> print <STRING> % ( N [ 2 ] , N [ 0 ] , N [ 1 ] ) <NEWLINE> <DEDENT> else N [ 2 ] < N [ 1 ] < N [ 0 ] : <NEWLINE> <INDENT> print <STRING> % ( N [ 2 ] , N [ 1 ] , N [ 0 ] ) <NEWLINE> <DEDENT>
x = list ( map ( int , input ( ) . split ( ) ) <NEWLINE> print ( <STRING> . join ( map ( str , sorted ( x ) ) ) ) <NEWLINE> <NL> <NL>
x = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> num = x . sort ( ) <NEWLINE> print ( num [ 0 ] , num [ 1 ] , num [ 2 ] ) <NEWLINE>
a , b , c = [ int ( x ) for x in raw_input ( ) . split ( <STRING> ) ] <NEWLINE> list = [ a , b , c ] <NEWLINE> list_2 = [ ] <NEWLINE> <NL> for x in range ( len ( list ) ) : <NEWLINE> <INDENT> mini = min ( list ) <NEWLINE> list_2 . append ( mini ) <NEWLINE> list . remove ( mini ) <NEWLINE> <NL> <DEDENT> for x in range ( 0 , len ( list_2 ) ) : <NEWLINE> <INDENT> a = list_2 [ x ] <NEWLINE> <NL> if x == 0 : <NEWLINE> <INDENT> req = str ( a ) + <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> req += str ( a ) + <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> q = req . rstrip ( ) <NEWLINE> print ( req ) <NEWLINE>
a , b , c = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> <NL> if a < b : <NEWLINE> <INDENT> if c < a : <NEWLINE> <INDENT> print ( % d , % d , % d ) % c , a , b <NEWLINE> <DEDENT> elif b < c : <NEWLINE> <INDENT> print ( % d , % d , % d ) % a , b , c <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( % d , % d , % d ) % a , c , b <NEWLINE> <NL> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if c < b : <NEWLINE> <INDENT> print ( % d , % d , % d ) % c , b , a <NEWLINE> <DEDENT> elif a < c : <NEWLINE> <INDENT> print ( % d , % d , % d ) % b , a , c <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( % d , % d , % d ) % b , c , a <NEWLINE> <DEDENT> <DEDENT>
InData = input ( ) . split <NEWLINE> Indata = map ( int , InData ) <NEWLINE> sorted = sorted ( InData ) <NEWLINE> print ( <STRING> . join ( map ( str , sorted ) ) ) <NEWLINE>
if __name__ == <STRING> : <NEWLINE> <INDENT> a , b , c = input ( ) . split ( ) <NEWLINE> a , b , c = int ( a ) , int ( b ) , int ( c ) <NEWLINE> <NL> ans = [ a , b , c ] . sorted ( ) <NEWLINE> print ( ans [ 0 ] , ans [ 1 ] , ans [ 2 ] ) <NEWLINE> <DEDENT>
a , b , c = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> <NL> if ( a < b < c ) : <NEWLINE> <INDENT> print a b c <NEWLINE> <DEDENT> elif ( a < c < b ) : <NEWLINE> <INDENT> print a c b <NEWLINE> <DEDENT> elif ( b < a < c ) : <NEWLINE> <INDENT> print b a c <NEWLINE> <DEDENT> elif ( b < c < a ) : <NEWLINE> <INDENT> print b c a <NEWLINE> <DEDENT> elif ( c < a < b ) : <NEWLINE> <INDENT> print c a b <NEWLINE> <DEDENT> elif ( c < b < a ) : <NEWLINE> <INDENT> print c b a <NEWLINE> <DEDENT>
um = input ( ) . split ( ) <NEWLINE> num . sort ( ) <NEWLINE> print ( num [ 0 ] , num [ 1 ] , num [ 2 ] ) <NEWLINE>
i = j = k = 0 <NEWLINE> n = <STRING> <NEWLINE> m = <STRING> <NEWLINE> l = <STRING> <NEWLINE> <NL> line = input ( ) <NEWLINE> <NL> while line [ i ] != <STRING> : <NEWLINE> <INDENT> n = n + line [ i ] <NEWLINE> i += 1 <NEWLINE> <NL> <DEDENT> i += 1 <NEWLINE> while line [ i ] != <STRING> : <NEWLINE> <INDENT> l = l + line [ i ] <NEWLINE> i += 1 <NEWLINE> <NL> <DEDENT> while i < len ( line ) : <NEWLINE> <INDENT> m = m + line [ i ] <NEWLINE> i += 1 <NEWLINE> <NL> <DEDENT> n = int ( n ) <NEWLINE> l = int ( l ) <NEWLINE> m = int ( m ) <NEWLINE> <NL> out = [ n , m , l ] <NEWLINE> out = out . sort ( ) <NEWLINE> <NL> print ( out [ 0 ] , end = <STRING> ) <NEWLINE> print ( out [ 1 ] , end = <STRING> ) <NEWLINE> print ( out [ 2 ] ) <NEWLINE>
tmp = b <NEWLINE> <INDENT> b = c <NEWLINE> c = tmp <NEWLINE> <DEDENT> if ( a > b ) : <NEWLINE> <INDENT> tmp = a <NEWLINE> a = b <NEWLINE> b = tmp <NEWLINE> <DEDENT> print str ( a ) + <STRING> + str ( b ) + <STRING> + str ( c ) <NEWLINE>
a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> if a <= b <= c : print ( a , b , c ) <NEWLINE> if b < a <= c : print ( b , a , c ) <NEWLINE> if a <= c <= b : print ( a , c , b ) <NEWLINE> if b < c <= a : print ( b , c , a ) <NEWLINE> if c < a <= b : print ( c , a , b ) <NEWLINE> if c <= b <= a : print ( c , b , a <NEWLINE>
[ a , b , c ] = raw_input ( ) . split ( <STRING> ) <NEWLINE> a = int ( a ) <NEWLINE> b = int ( b ) <NEWLINE> c = int ( c ) <NEWLINE> t = sort ( [ a , b , c ] ) <NEWLINE> print t [ 0 ] , t [ 1 ] , t [ 2 ] <NEWLINE>
num = input ( ) . split ( <STRING> ) <NEWLINE> n = [ int ( i ) for i in num ] <NEWLINE> n = sorted ( n ) <NEWLINE> print ( <STRING> . join ( n ) ) <NEWLINE>
map ( int , input ( ) . split ( ) ) . sort ( ) <NEWLINE>
a = map ( int , input ( ) . split ( ) ) <NEWLINE> a . sort ( ) <NEWLINE> for i in 3 : <NEWLINE> <INDENT> print ( list ( a [ i ] ) , <STRING> ) <NEWLINE> <DEDENT>
<NL> a = list ( map ( int , input ( ) ) ) <NEWLINE> a . sort ( ) <NEWLINE> print ( a [ 0 ] , a [ 1 ] , a [ 2 ] ) <NEWLINE>
print ( sort ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE>
array = input ( ) . split ( ) . sort ( ) <NEWLINE> <NL> for i in array : <NEWLINE> <INDENT> print ( i , end = <STRING> ) <NEWLINE> <DEDENT>
a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> num . sort ( ) <NEWLINE> print ( a [ 0 ] , a [ 1 ] , a [ 2 ] ) <NEWLINE>
a , b , c = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> <NL> d = [ ] <NEWLINE> d . append ( a , b , c ) <NEWLINE> d . sort ( ) <NEWLINE> print d <NEWLINE>
( a , b , c ) = input ( ) . rstrip . split ( <STRING> ) <NEWLINE> a = int ( a ) <NEWLINE> b = int ( b ) <NEWLINE> c = int ( c ) <NEWLINE> <NL> if a < b < c : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a < c < b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif b <= a <= c : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif b <= c <= a : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif c <= a <= b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> a . sort ( ) <NEWLINE> <NL> print ( a [ 0 ] , a [ 1 ] , a [ 2 ] ) <NEWLINE>
num = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> num . sort ( ) <NEWLINE> print ( <STRING> . join ( map ( int , num ) ) ) <NEWLINE>
x = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> y = x . sort ( ) <NEWLINE> print ( y [ 0 ] , y [ 1 ] , y [ 2 ] ) <NEWLINE>
a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> sort ( a ) <NEWLINE> print ( str ( a [ 0 ] ) + <STRING> + str ( a [ 1 ] ) + <STRING> + str ( a [ 2 ] ) ) <NEWLINE>
l = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> <NL> l . sort ( ) <NEWLINE> <NL> print ( str ( l [ 0 ] + <STRING> + strl [ 1 ] + <STRING> + str [ 2 ] ) <NEWLINE>
l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> sorted_list = sorted ( l ) <NEWLINE> print ( <STRING> . format ( l [ 0 ] , l [ 1 ] , l [ 2 ] ) <NEWLINE> <NL>
<COMMENT> <NL> <COMMENT> <NL> a , b , c = input ( ) . split ( ) <NEWLINE> if ( a <= b <= c ) : <NEWLINE> <INDENT> print ( <STRING> % ( a , b , c ) ) <NEWLINE> <DEDENT> if ( a >= b >= c ) : <NEWLINE> <INDENT> print ( <STRING> % ( c , b , a ) ) <NEWLINE> <DEDENT> if ( a > c > b ) : <NEWLINE> <INDENT> print ( <STRING> % ( a , c , b ) ) <NEWLINE> <DEDENT> if ( b > a >= c ) : <NEWLINE> <INDENT> print ( <STRING> % ( b , a , c ) ) <NEWLINE> <DEDENT> if ( b > c > a ) : <NEWLINE> <INDENT> print ( <STRING> % ( b , c , a ) ) <NEWLINE> <DEDENT> if ( c > b >= a ) : <NEWLINE> <INDENT> print ( <STRING> % ( c , b , a ) ) <NEWLINE> <DEDENT> if ( c > a > b ) : <NEWLINE> <INDENT> print ( <STRING> % ( c , a , b ) ) <NEWLINE> <DEDENT>
x = map ( int , input ( ) . split ( ) ) <NEWLINE> x . sort ( ) <NEWLINE> print ( x ) <NEWLINE>
a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a . sort ( ) <NEWLINE> print ( a [ 0 ] + <STRING> + a [ 1 ] + <STRING> + a [ 2 ] ) <NEWLINE>
a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> if a < b < c : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif <NEWLINE>
n = raw_input ( ) <NEWLINE> k = n . split ( n ) <NEWLINE> k . sort ( ) <NEWLINE> print k [ 0 ] , <NEWLINE> print k [ 1 ] , <NEWLINE> print k [ 2 ] <NEWLINE>
a , b , c = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> <NL> aa = [ , , , ] <NEWLINE> aa [ 0 ] = a <NEWLINE> aa [ 1 ] = b <NEWLINE> aa [ 2 ] = c <NEWLINE> <NL> sorted ( aa ) <NEWLINE> <NL> print aa [ 0 ] , aa [ 1 ] , aa [ 2 ] <NEWLINE>
a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> if a <= b <= c : <NEWLINE> <INDENT> print ( <STRING> , format ( a , b , c ) ) <NEWLINE> <DEDENT> elif a <= c <= b : <NEWLINE> <INDENT> print ( <STRING> , format ( a , c , b ) ) <NEWLINE> <DEDENT> elif b <= a <= c : <NEWLINE> <INDENT> print ( <STRING> , format ( b , a , c ) ) <NEWLINE> <DEDENT> elif b <= c <= a : <NEWLINE> <INDENT> print ( <STRING> , format ( b , c , a ) ) <NEWLINE> <DEDENT> elif c <= a <= b : <NEWLINE> <INDENT> print ( <STRING> , format ( c , a , b ) ) <NEWLINE> <DEDENT> elif c <= b <= a : <NEWLINE> <INDENT> print ( <STRING> , format ( c , b , a ) ) <NEWLINE> <DEDENT>
S = input ( ) <NEWLINE> L = S . split ( ) <NEWLINE> <NL> a = L [ 0 ] <NEWLINE> b = L [ 1 ] <NEWLINE> c = L [ 2 ] <NEWLINE> <NL> a = int ( a ) <NEWLINE> b = int ( b ) <NEWLINE> c = int ( c ) <NEWLINE> l = [ a , b , c ] <NEWLINE> <NL> min_1 = min ( a , b , c ) <NEWLINE> <COMMENT> <NL> l . remove ( min_1 ) <NEWLINE> <NL> min_2 = min ( l ) <NEWLINE> <NL> l . remove ( min_2 ) <NEWLINE> <NL> min_3 = l [ 0 ] <NEWLINE> <NL> min_1 = str ( min_1 ) <NEWLINE> min_2 = str ( min_2 ) <NEWLINE> min_3 = str ( min_3 ) <NEWLINE> <NL> print min_3 + <STRING> + min_2 + <STRING> + min_1 <NEWLINE>
print ( * sorted . map ( int , input ( ) . split ( ) ) ) <NEWLINE>
abc_s = input ( ) <NEWLINE> abc_a = abc_s . split ( <STRING> ) <NEWLINE> abc = [ int ( x ) for x in abc_a ] <NEWLINE> <NL> sorted = False <NEWLINE> <NL> while sorted == False : <NEWLINE> <INDENT> sorted = True <NEWLINE> if abc [ 0 ] > abc [ 1 ] : <NEWLINE> <INDENT> sorted == False <NEWLINE> tmp = abc [ 0 ] <NEWLINE> abc [ 0 ] = abc [ 1 ] <NEWLINE> abc [ 1 ] = tmp <NEWLINE> <DEDENT> if abc [ 1 ] > abc [ 2 ] : <NEWLINE> <INDENT> sorted == False <NEWLINE> tmp = abc [ 1 ] <NEWLINE> abc [ 1 ] = abc [ 2 ] <NEWLINE> abc [ 2 ] = tmp <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> . format ( abc ) ) <NEWLINE>
a , b , c = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> <NL> if a < b < c : <NEWLINE> <INDENT> print <STRING> % ( a , b , c ) <NEWLINE> <DEDENT> elif a < c < b : <NEWLINE> <INDENT> print <STRING> % ( a , c , b ) <NEWLINE> <DEDENT> elif b < a < c : <NEWLINE> <INDENT> print <STRING> % ( b , a , c ) <NEWLINE> <DEDENT> elif b < c < a : <NEWLINE> <INDENT> print <STRING> % ( b , c , a ) <NEWLINE> <DEDENT> elif c < a < b : <NEWLINE> <INDENT> print <STRING> % ( c , a , b ) <NEWLINE> <DEDENT> else c < b < a : <NEWLINE> <INDENT> print <STRING> % ( c , b , a ) <NEWLINE> <DEDENT>
a = [ raw_input ( ) . split ( <STRING> ) ] <NEWLINE> a . sort ( ) <NEWLINE> print <STRING> % ( a [ 0 ] , a [ 1 ] , a [ 2 ] ) <NEWLINE>
print ( * sorted ( input ( ) . split ( ) ) ) ) <NEWLINE>
a = map ( int , input ( ) . split ( ) ) <NEWLINE> a . sort ( ) <NEWLINE> print ( a [ 0 ] , a [ 1 ] , a [ 2 ] ) <NEWLINE>
print ( <STRING> . join ( [ str ( i ) for i in sorted ( [ int ( w ) for w in input ( ) . split ( ) ] ) ] ) <NEWLINE>
<COMMENT> <NL> <NL> n = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> n . sort ( ) <NEWLINE> print str ( n [ 0 ] ) + str ( n [ 1 ] ) + str ( n [ 2 ] ) <NEWLINE>
a = map ( int , input ( ) ) <NEWLINE> a . sort ( ) <NEWLINE> maped_list = map ( str , a ) <NEWLINE> mojiretu = <STRING> . join ( maped_list ) <NEWLINE> print ( mojiretu ) <NEWLINE> <NL>
a = list . map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> a . sort ( ) <NEWLINE> <NL> print ( a [ 0 ] , a [ 1 ] , a [ 2 ] ) <NEWLINE> <NL>
x = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> x . sort ( ) <NEWLINE> print ( <STRING> . format ( x [ 0 ] , x [ 1 ] , x [ 2 ] ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <NL> var = raw_input ( ) . split ( ) <NEWLINE> <NL> var = map ( int , var ) <NEWLINE> <NL> if var [ 0 ] > var [ 1 ] : <NEWLINE> <INDENT> tmp = var [ 0 ] <NEWLINE> var [ 0 ] = var [ 1 ] <NEWLINE> var [ 1 ] = tmp <NEWLINE> <NL> <DEDENT> if var [ 0 ] > var [ 2 ] : <NEWLINE> <INDENT> tmp = var [ 0 ] <NEWLINE> var [ 0 ] = var [ 2 ] <NEWLINE> var [ 2 ] = tmp <NEWLINE> <NL> <DEDENT> if var [ 1 ] > var [ 2 ] : <NEWLINE> <INDENT> tmp = var [ 1 ] <NEWLINE> var [ 1 ] = var [ 2 ] <NEWLINE> var [ 2 ] = tmp <NEWLINE> <NL> <DEDENT> prini var [ 0 ] , var [ 1 ] , var [ 2 ] <NEWLINE>
a = list ( map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> a . sort <NEWLINE> print ( * a ) <NEWLINE>
<COMMENT> <NL> na = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <COMMENT> <NL> ns . sort ( ) <NEWLINE> <COMMENT> <NL> print ( ns ) <NEWLINE> print ( * ns ) <NEWLINE> <NL>
l = sorted ( map ( int , raw_input ( ) . split ( ) ) ) <NEWLINE> print ( l [ 0 ] , l [ 1 ] , l [ 2 ] ) <NEWLINE>
data = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> data . sort ( ) <NEWLINE> print ( <STRING> . format ( data [ 0 ] , data [ 1 ] , data [ 2 ] ) <NEWLINE>
list = int ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> uplist = sorted ( list ) <NEWLINE> <NL> print ( <STRING> . join ( map ( str , uplist ) ) <NEWLINE>
x = raw_input ( ) . split ( ) <NEWLINE> m = map ( int , x ) <NEWLINE> <NL> sort ( m ) <NEWLINE> <NL> a = m [ 0 ] <NEWLINE> b = m [ 1 ] <NEWLINE> c = m [ 2 ] <NEWLINE> <NL> print a , b , c <NEWLINE>
<COMMENT> <NL> <NL> a = [ int ( i ) for i in input ( ) . rstrip ( ) . split ( ) ] <NEWLINE> rectangle = [ a [ 0 ] , a [ 1 ] ] <NEWLINE> circleCenter = [ a [ 2 ] , a [ 3 ] ] <NEWLINE> circleRadius = a [ 4 ] <NEWLINE> <NL> if a [ 2 ] - a [ 4 ] >= 0 and a [ 2 ] + a [ 4 ] <= a [ 0 ] : <NEWLINE> <INDENT> if a [ 3 ] - [ 4 ] >= 0 and a [ 3 ] + a [ 4 ] <= a [ 1 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT>
W , H , x , y , r = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if ( x - r ) < 0 <NEWLINE> <INDENT> or ( y - r ) < 0 <NEWLINE> or ( x + r ) > W <NEWLINE> or ( y + r ) > H : <NEWLINE> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
X , Y , x , y , r = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> if ( 0 <= ( y - r ) and ( y + r ) <= Y ) and ( 0 <= ( x - r ) and ( x + r ) <= X ) <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
W , H , x , y , r = map ( int , input ( ) split ( ) ) <NEWLINE> if r < x and x < W - r and r < y and y < H - r : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
w , h , x , y , r = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> <NL> if x < r : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> elif y < r : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> elif w - x < r : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> elif h - y < r : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> print <STRING> <NEWLINE>
w , h , x , y , r = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( <STRING> if r <= x <= w - r & & r <= y <= h - r else <STRING> ) <NEWLINE>
<NL> W , H , x , y , r = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if r <= x and x <= W and r <= y and y <= H : <NEWLINE> <INDENT> print ( Yes ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( No ) <NEWLINE> <DEDENT>
W , H , x , y , r = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> right = x + abs ( r ) <NEWLINE> left = x - abs ( r ) <NEWLINE> top = y + abs ( r ) <NEWLINE> bottom = y - abs ( r ) <NEWLINE> <NL> if right < W and left >= 0 and top < H and bottom >= 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> else : <NEWLINE> print ( <STRING> ) <NEWLINE> <NL> <DEDENT>
W , H , x , y , r = map ( int , input ( ) . split ( ) ) <NEWLINE> if r = < x = < ( W - r ) and r = < y = < ( H - r ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
def pred ( W , H , x , y , r ) <NEWLINE> <INDENT> if x - r < 0 or y - r < 0 or x + r > W or y + r > H : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return True <NEWLINE> <NL> <DEDENT> <DEDENT> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> print ( <STRING> if pred ( * a ) else <STRING> ) <NEWLINE>
W , H , x , y , r = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> If x >= r and y >= r and W >= ( x + r ) and H >= ( y + r ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
W , H , x , y , r = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> <NL> if ( r <= x <= W - r ) AND ( r < y < H - r ) : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> [ Width , Height , x , y , r ] = [ int ( x ) for x in sys . stdin . readline ( ) . stlip ( ) ] <NEWLINE> <NL> lower_x = r <NEWLINE> lower_y = r <NEWLINE> upper_x = Width - r <NEWLINE> upper_y = Height - r <NEWLINE> <NL> if lower_x <= x <= upper_x and lower_y <= y <= upper_y : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
w , h , x , y , r = map ( int , input ( ) . split ( ) ) <NEWLINE> if x >= r and x = < w - r and y >= r and y = < h - r : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT>
W , H , x , y , r = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if ( x + r ) <= W and ( x - r ) >= 0 and ( y + r ) <= H and ( y - r ) >= 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> <NEWLINE> <DEDENT>
W , H , x , y , r = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> print <STRING> if ( W >= ( x + r ) ) and ( H >= ( y + r ) ) else <STRING> <NEWLINE>
list = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> x0 = list [ 2 ] - list [ 4 ] <NEWLINE> y0 = list [ 3 ] - list [ 4 ] <NEWLINE> x1 = list [ 2 ] + list [ 4 ] <NEWLINE> y1 = list [ 3 ] + list [ 4 ] <NEWLINE> <NL> if x0 >= 0 and y0 >= 0 and x1 = < list [ 0 ] and y1 = < list [ 1 ] : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT>
W , H , x , y , r = list ( map ( int , input ( ) . split ( ) ) <NEWLINE> if ( r <= x <= W - r ) & ( r <= y <= H - y ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
W , H , x , y , r = int ( input ( ) . split ( ) ) <NEWLINE> if ( x < r or y < r ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif ( x > ( W - r ) or y > ( H - r ) ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
5 4 2 4 1 <NEWLINE>
a , b , c , d , r = map ( int , input ( ) . split ( ) ) <NEWLINE> a -= r * 2 <NEWLINE> b -= r * 2 <NEWLINE> c -= r <NEWLINE> d -= r <NEWLINE> <NL> if 0 < c and 0 < d and 0 < a and 0 < b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
w , h , x , y , r = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> <NL> if 0 <= x - r and x + r <= w and 0 <= y - r and y + r <= h : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
if __name__ == <STRING> : <NEWLINE> <INDENT> l = input ( ) . split ( ) <NEWLINE> <NL> for i in range ( l ) : <NEWLINE> <INDENT> l [ i ] = int ( l [ i ] ) <NEWLINE> <DEDENT> W , H , x , y , r = l [ 0 ] , l [ 1 ] , l [ 2 ] , l [ 3 ] , l [ 4 ] <NEWLINE> <NL> if x >= r and y >= r : <NEWLINE> <INDENT> if x <= W - r and y <= H - r : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT>
i = iinput ( ) . split ( <STRING> ) <NEWLINE> <NL> W = int ( i [ 0 ] ) <NEWLINE> H = int ( i [ 1 ] ) <NEWLINE> x = int ( i [ 2 ] ) <NEWLINE> y = int ( i [ 3 ] ) <NEWLINE> r = int ( i [ 4 ] ) <NEWLINE> <NL> if x - r >= 0 and y - r >= 0 and x + r <= W and y + r <= H : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
w , h , x , y , r = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if x >= r and y >= r and x + r <= w an y + r <= h : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT>
m = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> W = m [ 0 ] <NEWLINE> H = m [ 1 ] <NEWLINE> x = m [ 2 ] <NEWLINE> y = m [ 3 ] <NEWLINE> r = m [ 4 ] <NEWLINE> <NL> <NL> if 0 <= x - r and x + r <= W : <NEWLINE> <INDENT> if 0 <= y - r and y + r <= H : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> <DEDENT> print <STRING> <NEWLINE>
w , h , x , y , r = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> <INDENT> if w - r > x and h - r > y and x > 0 and y > 0 : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT>
W , H , x , y , r = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if x >= r and y >= r and r + y <= H and r + x <= W : <NEWLINE> print <STRING> <NEWLINE> else : <NEWLINE> print <STRING> <NEWLINE>
W , H , x , y , r = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> <NL> if x >= r and x <= W - r and y >= r and y <= H - r : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <NL> <DEDENT>
W , H , x , y , r = map ( int , input ( ) . split ( ) ) <NEWLINE> if y + r <= H and y > r and x + r < W and x > r : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
W , H , x , y , r = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> w , h = W - r , h = r <NEWLINE> <NL> if x < 0 and w < x and y < 0 and h < y : print ( <STRING> ) <NEWLINE> <NL> else : print ( <STRING> ) <NEWLINE> <NL>
num = list ( map ( int , input ( ) . split ) ) <NEWLINE> <NL> circle_px = num [ 2 ] + num [ 4 ] <NEWLINE> circle_mx = num [ 2 ] - num [ 4 ] <NEWLINE> <NL> circle_py = num [ 3 ] + num [ 4 ] <NEWLINE> circle_my = num [ 3 ] - num [ 4 ] <NEWLINE> <NL> if ( circle_px <= num [ 0 ] and circle_mx >= 0 and circle_py <= num [ 1 ] and circle_py >= 0 ) : print ( <STRING> ) <NEWLINE> else : print ( <STRING> ) <NEWLINE>
ciar = input ( ) . split ( ) <NEWLINE> W = int ( ciar [ 0 ] ) <NEWLINE> H = int ( ciar [ 1 ] ) <NEWLINE> x = int ( ciar [ 2 ] ) <NEWLINE> y = int ( ciar [ 3 ] ) <NEWLINE> r = int ( ciar [ 4 ] ) <NEWLINE> if ( x + r ) <= W and ( x - r ) >= 0 : <NEWLINE> <INDENT> if ( y + r ) <= H and ( y - r ) >= 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
WHxyr = list ( map ( int , input ( ) , split ( ) ) ) <NEWLINE> x_max = WHxyr [ 0 ] - WHxyr [ 4 ] <NEWLINE> y_max = WHxyr [ 1 ] - WHxyr [ 4 ] <NEWLINE> if x >= r and x <= x_max : <NEWLINE> <INDENT> if y >= r and y <= y_max : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
W , H , r , x , y = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> print ( <STRING> if 0 <= x - r <= x + r = W and 0 <= y - r <= y + r = H else <STRING> ) <NEWLINE>
( w , h , x , y , r ) = input ( ) . sprit ( <STRING> ) <NEWLINE> w = int ( w ) <NEWLINE> h = int ( h ) <NEWLINE> x = int ( x ) <NEWLINE> y = int ( y ) <NEWLINE> r = int ( r ) <NEWLINE> <NL> if 0 + r <= x <= w - r and 0 + r <= y <= h - r : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
<INDENT> w , h , x , y , r = map ( int , input ( ) . split ( ) ) <NEWLINE> <DEDENT> if x - r >= 0 and x + r <= w and y - r >= 0 and y + r <= h : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
H , W , x , y , r = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if - r < = y <= H - r : <NEWLINE> <INDENT> if - r < = x <= W - r : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
W , H , x , y , r = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> <NL> if r <= x and x <= W - r : <NEWLINE> <INDENT> if r <= y and y <= H - r : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> print <STRING> <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT>
W , H , x , y , r = map ( int , input ( ) , split ( ) ) <NEWLINE> if ( ( x - r ) >= 0 ) and ( ( x + r ) <= W ) : <NEWLINE> <INDENT> if ( ( y - r ) >= 0 ) and ( ( y + r ) <= H ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
W , H , x , y , r = [ int ( ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> if ( r > x ) or ( r > w - x ) or ( r > y ) or ( r > H - y ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> ( H , W ) = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> if H == W == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> for a in range ( H ) : <NEWLINE> <INDENT> for b in range ( W ) : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> <DEDENT>
W , H , x , y , r = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> if x + r <= W and y - >= 0 and x - r >= 0 and y + r <= H : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
W = int ( raw_input ( ) ) <NEWLINE> H = int ( raw_input ( ) ) <NEWLINE> x = int ( raw_input ( ) ) <NEWLINE> y = int ( raw_input ( ) ) <NEWLINE> r = int ( raw_input ( ) ) <NEWLINE> <NL> if x <= W - r and x >= r and y <= H - r and y >= r : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT>
W , H , x , y , r = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( <STRING> if r <= x <= W - r & & r <= y <= H - r else <STRING> ) <NEWLINE>
w , h , x , y , r = input ( ) . split ( <STRING> ) <NEWLINE> if int ( x ) < int ( w ) - int ( r ) : <NEWLINE> elif int ( x ) > int ( r ) : <NEWLINE> elif int ( y ) < int ( h ) - int ( r ) : <NEWLINE> elif int ( y ) > int ( r ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
W . H , x , y , = [ int ( i ) for i in input ( ) . aplit ( ) ] <NEWLINE> <NL> if x + r <= W and y - r >= 0 and x - r >= 0 and y + <= H : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
W , H , x , y , r = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if x + r <= W and y + r <= H : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> else <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT>
w , h , x , y , r = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if r = < x <= w - r and r = < y <= h - r : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
W , H , x , y , r = input ( ) . split ( ) <NEWLINE> w = int ( ) <NEWLINE> H = int ( ) <NEWLINE> x = int ( ) <NEWLINE> y = int ( ) <NEWLINE> r = int ( ) <NEWLINE> if x - r >= 0 and y - r >= 0 and x + r <= w and y + r <= h : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
<NL> w , h , x , y , r = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if x >= r and < x <= ( w - r ) : <NEWLINE> <INDENT> if y >= r and y <= ( h - r ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
W , H , x , y , r = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if x - r >= 0 & & y - r >= 0 & & x + r <= W & & y + r <= H : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT>
w , h , x , w , y , r = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if ( x - r ) >= 0 and ( x + r ) <= w : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
W , H , x , y , r = map ( int , input ( ) . split ( ) ) <NEWLINE> if ( 0 <= x - r and x + r <= W ) and ( 0 <= y - r and y + r <= h ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
W , H , x , y , r = map ( int , raw_input ( ) . split ) ) <NEWLINE> <NL> if 0 <= ( x - r ) and ( x + r ) <= W and 0 <= ( y - r ) and ( y + r ) <= H : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT>
list = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> W = list [ 0 ] <NEWLINE> H = list [ 1 ] <NEWLINE> x = list [ 2 ] <NEWLINE> y = list [ 3 ] <NEWLINE> r = list [ 4 ] <NEWLINE> <NL> if x - r < 0 : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> elif x + r > W : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> elif y - r < 0 : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> elif y + r > H : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT>
w , h , x , y , r = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> <NL> if ( x + r ) = < w and ( y + r ) = < h : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
__author__ = <STRING> <NEWLINE> _project_ = <STRING> <NEWLINE> <NL> class BoundingBox : <NEWLINE> <INDENT> def __init__ ( self , width , height ) : <NEWLINE> <INDENT> self . width = width ; <NEWLINE> self . height = height ; <NEWLINE> <NL> <DEDENT> def CalculateBox ( self , x , y , r ) : <NEWLINE> <INDENT> if x >= r and x <= ( self . width - r ) and y >= r and y <= ( self . height - r ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> width = int ( input ( ) ) <NEWLINE> height = int ( input ( ) ) <NEWLINE> x = int ( input ( ) ) <NEWLINE> y = int ( input ( ) ) <NEWLINE> r = int ( input ( ) ) <NEWLINE> <NL> Box = BoundingBox ( width , height ) <NEWLINE> Box . CalculateBox ( x , y , r ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> W , H , x , y , r = map ( int , input ( ) . split ( ) ) <NEWLINE> if W >= 2 * r AND H >= 2 * r AND W <= x + r AND H <= y + r : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
W , H , x , y , r = map ( int , input ( ) . split ( ) ) <NEWLINE> if min ( [ x , y ] >= r ) and x <= ( W - r ) and y <= ( H - r ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> list_1 = input ( ) . split ( <STRING> ) <NEWLINE> list_2 = list ( map ( int , list_1 ) ) <NEWLINE> <NL> w = list_2 [ 0 ] <NEWLINE> h = list_2 [ 1 ] <NEWLINE> x = list_2 [ 2 ] <NEWLINE> y = list_2 [ 3 ] <NEWLINE> r = list_2 [ 4 ] <NEWLINE> <NL> checker_boy ( x + r , w ) <NEWLINE> checker_boy ( x - r , w ) <NEWLINE> checker_boy ( y + r , h ) <NEWLINE> checker_boy ( y - r , h ) <NEWLINE> <NL> print ( <STRING> ) <NEWLINE> <NL> def checker_boy ( x_r , n ) : <NEWLINE> <INDENT> if x_r == 0 : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> if n * x_r / x_r * x_r >= 0 : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT>
W , H , x , y , r = map ( int , raw_input ( ) ) <NEWLINE> if x + r <= W and y + r <= H : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT>
w , h , x , y , r = map ( int , input ( ) . split ( ) ) <NEWLINE> if x < r or y < r or x + r > w or y + r > h : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <NL>
w , h , x , y , r = map ( int , input ( ) . split ( ) ) <NEWLINE> if x - r = > 0 and r + x = < w and y - r > 0 and r + y < h : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
W , H , x , y , r = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if x - r < 0 : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> elif x + r > W : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> elif y - r < 0 : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> elif y + r > H : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT>
inl = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> <NL> if inl [ 0 ] >= inl [ 2 ] + inl [ 4 ] and inl [ 2 ] + inl [ 4 ] >= 0 and inl [ 1 ] >= inl [ 3 ] + inl [ 4 ] and inl [ 3 ] + inl [ 4 ] >= 0 <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT>
W , H , x , y , r = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( <STRING> if ( x - r ) < 0 or ( x + r ) > w or ( y - r ) < 0 or ( y + r ) > h else <STRING> ) <NEWLINE>
W , H , x , y , r = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> print ( <STRING> if x < r or x + r > W or y < r y + r > H else <STRING> ) <NEWLINE>
W , H , x , y , r , = map ( int , input ( ) . split ( ) ) <NEWLINE> if ( x - r < 0 or x + r > W ) and ( ) ( y - r < 0 or y + r > H ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif ( x - r >= 0 and x + r <= W ) and ( ) ( y - r >= 0 and y + r <= H ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
W = int ( input ( ) ) <NEWLINE> H = int ( input ( ) ) <NEWLINE> x = int ( input ( ) ) <NEWLINE> y = int ( input ( ) ) <NEWLINE> r = int ( input ( ) ) <NEWLINE> if x - r < 0 or y - r < 0 or x + r > W or y + r > H : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT>
deglist = raw_input ( ) . split ( <STRING> ) <NEWLINE> W = deglist [ 0 ] <NEWLINE> H = deglist [ 1 ] <NEWLINE> x = deglist [ 2 ] <NEWLINE> y = deglist [ 3 ] <NEWLINE> r = deglist [ 4 ] <NEWLINE> <NL> if x >= r and x <= ( W - r ) and r <= y and y <= ( H - r ) : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT>
if __name__ == <STRING> : <NEWLINE> <INDENT> z = input ( ) . split ( <STRING> ) <NEWLINE> W = z [ 0 ] <NEWLINE> H = z [ 1 ] <NEWLINE> x = z [ 2 ] <NEWLINE> y = z [ 3 ] <NEWLINE> r = z [ 4 ] <NEWLINE> if x - r < 0 or x + r > W : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> if y - r < 0 or y + r > H : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <NL> <NL> <NL> <NL> <DEDENT> <DEDENT>
w , h , x , y , r = map ( int , input ( ) . split ( ) ) <NEWLINE> if w - r >= x and h - r >= y <NEWLINE>
import warnings <NEWLINE> <NL> data = map ( float , raw_input ( ) . split ( ) ) <NEWLINE> <NL> w = data [ 0 ] <NEWLINE> h = data [ 1 ] <NEWLINE> x = data [ 2 ] <NEWLINE> y = data [ 3 ] <NEWLINE> r = data [ 4 ] <NEWLINE> <NL> if ( x > r and x < ( w - r ) and y > r and y < ( h - r ) ) : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT>
W , H , x , y , z = map ( int , input ( ) . split ( ) ) <NEWLINE> if ( x - r >= 0 and x + r <= W ) and ( y - r >= 0 and y + r <= H ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
w , h , x , y , r = map ( int , input . split ( ) ) <NEWLINE> if ( x < r or y < r or x + r > w or y + r > h ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
def circle_in_rectangle ( radius , pos , height , width ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> ( x , y ) = pos <NEWLINE> if x < radius or x > width - radius : <NEWLINE> <INDENT> return False <NEWLINE> <NL> <DEDENT> if y < radius or y > height - radius : <NEWLINE> <INDENT> return False <NEWLINE> <NL> <DEDENT> return True <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <NL> <INDENT> ( w , h , x , y , r ) = input ( ) . split ( <STRING> ) <NEWLINE> <NL> if circle_in_rectangle ( int ( r ) , ( int ( x ) , int ( y ) ) , int ( h ) , int ( w ) ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> ~ <NEWLINE>
x = input ( ) . split ( ) <NEWLINE> W = int ( x [ 0 ] ) <NEWLINE> H = int ( x [ 1 ] ) <NEWLINE> x = int ( x [ 2 ] ) <NEWLINE> y = int ( x [ 3 ] ) <NEWLINE> r = int ( x [ 4 ] ) <NEWLINE> <NL> if W >= ( x + r ) and H >= ( y + r ) and ( x - r ) >= 0 and ( y - r ) >= 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
i = input ( ) . split ( <STRING> ) <NEWLINE> W = int ( i [ 0 ] ) <NEWLINE> H = int ( i [ 1 ] ) <NEWLINE> x = int ( i [ 2 ] ) <NEWLINE> y = int ( i [ 3 ] ) <NEWLINE> r = int ( i [ 4 ] ) <NEWLINE> <NL> if x - r >= 0 and y - r >= 0 and x + r <= W and y + r <= H : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else ( <STRING> ) <NEWLINE>
W , H , x , y , r = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> if ( 0 <= x - r <= W ) and ( 0 <= x + r <= w ) : <NEWLINE> <INDENT> if ( 0 <= y - r <= H ) and ( 0 <= y + r <= H ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
w , h , x , y , r = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( [ <STRING> , <STRING> ] [ ( r <= x <= w - r ) * ( r <= y <= h - r ) ] ) in <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> W , H , x , y , r = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if r <= x and r <= y and x + r <= W y + r <= H : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT>
W , H , x , y , r = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> <NL> if x + r < W and x - r < W and y + r < H and y - r < H <NEWLINE> <INDENT> print <STRING> <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT>
W , H , x , y , r = map ( int , input ( ) . split ( ) ) <NEWLINE> if x >= r and x + r <= W and y >= r and y + r <= H <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
W , H , x , y , r = map ( int , input ( ) . split ( ) ) <NEWLINE> if W - x > r & & x > r & & H - y > r & & y > r : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
W , H , x , y , r = [ int ( i ) for i in input ( ) . split ] <NEWLINE> <NL> <NL> if x + r <= W and y - r >= 0 and x - r >= 0 and y + r <= H : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
W , H , x , y , r = map ( int , input ( ) . split ( ) ) <NEWLINE> if r <= x <= W - r and r <= y <= H - r <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
string = input ( ) <NEWLINE> if x - r = > 0 & y - r = > 0 & x + r = < W & y + r = < H : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
ciar = input ( ) . split ( <STRING> ) <NEWLINE> W , H , x , y , r = [ ciar [ 0 ] , ciar [ 1 ] , ciar [ 2 ] , ciar [ 3 ] , ciar [ 4 ] ] <NEWLINE> if x - r >= 0 and x + r <= W : <NEWLINE> <INDENT> if ( y + r ) <= H : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
W , H , x , y , r = ( int ( i ) for i in input ( ) . split ( ) ) <NEWLINE> <NL> if x - r < 0 or x + r > W or y - r < 0 or y + r > H : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT>
X , H , x , y , r = [ int ( ) for i in input ( ) . split ( ) ] <NEWLINE> if x - r < 0 or x + r > W : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> elif y - r < 0 or y + r > H : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> elif x < r : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> elif y < r : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
w , h , x , y , r = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( [ <STRING> , <STRING> ] [ r , r <= x , y <= w - r , h - r ] ) <NEWLINE>
W , H , r , x , y = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> print ( <STRING> if 0 <= x - r <= x + r = W and 0 <= y - r <= y + r = H else <STRING> ) <NEWLINE>
w , h , x , y , r = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> a = True <NEWLINE> <NL> if x < r or w - r < x : <NEWLINE> <INDENT> a = False <NEWLINE> <NL> <DEDENT> if y < r or h - r < y : <NEWLINE> <INDENT> a = False <NEWLINE> <NL> <NL> <DEDENT> if a = True : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT>
W , H , x , y , r = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if ( ( 2 * r <= ( x + r ) <= W ) & ( 2 * r <= ( y + r ) <= H ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT>
W , H , x , y , r = map ( int , input . split ( ) ) <NEWLINE> if x - r >= 0 and y - r >= 0 and x + r <= W and y + r <= H : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> else : print <STRING> <NEWLINE>
W , H , x , y , r = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if x - r >= 0 and y - r >= 0 and x + r = < W and y + r = < H : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b , x , y , r = map ( int , input ( ) . split ( ) ) <NEWLINE> if ( x + r ) > w or ( y + r ) > h or ( x - r ) < 0 or ( y - r ) < 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT>
W , H , x , y , r = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if not ( - 100 <= x and y <= 100 and 0 < W <= 100 and 0 < H <= 100 and 0 < r <= 100 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <COMMENT> <NL> <DEDENT> elif W - r <= x <= W + r and H - r <= y <= H + r <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
W , H , x , y , r = input ( ) . split ( ) <NEWLINE> <NL> if r = < x and x = < W - r : <NEWLINE> <INDENT> if r = < y and y = < H - r : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> W , H , x , y , r = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> if ( ( x - r ) >= 0 ) and ( ( x + r ) = < W ) and ( ( y - r ) >= 0 ) and ( ( y + r ) <= H ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
( W , H , x , y , r ) = [ int ( i ) for i in input ( ) . rstrip ( ) . split ( ) ] <NEWLINE> <NL> if x + r <= W and x - r >= 0 and y + r <= H and x - r >= 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
w , h , x , y , r = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> <NL> f = 0 <NEWLINE> if x + r > w : <NEWLINE> <INDENT> f = 1 <NEWLINE> <DEDENT> if y + r > h : <NEWLINE> <INDENT> f = 1 <NEWLINE> <DEDENT> if r > x : <NEWLINE> <INDENT> f = 1 <NEWLINE> <DEDENT> if r > y : <NEWLINE> <INDENT> f = 1 <NEWLINE> <DEDENT> if f == 0 : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> else print <STRING> <NEWLINE>
n = raw_input ( ) <NEWLINE> k = n . split ( <STRING> ) <NEWLINE> <NL> W = int ( k [ 0 ] ) <NEWLINE> H = int ( k [ 1 ] ) <NEWLINE> x = int ( k [ 2 ] ) <NEWLINE> y = int ( k [ 3 ] ) <NEWLINE> r = int ( k [ 4 ] ) <NEWLINE> f = 0 <NEWLINE> <NL> if x - r >= 0 : <NEWLINE> <INDENT> if x + r <= W : <NEWLINE> <INDENT> if y - r >= 0 : <NEWLINE> <INDENT> if y + r <= H <NEWLINE> <INDENT> print <STRING> <NEWLINE> f = 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if f == 0 : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT>
w , h , x , y , r = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if x - r <= 0 or y - r <= 0 or x + r = > w or y + r = > h : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT>
W , H , x , y , r = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if r <= x <= W - r and r <= y <= H - r : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a = [ ] <NEWLINE> for i in range ( 5 ) : <NEWLINE> <INDENT> a . append ( input ( ) ) <NEWLINE> <DEDENT> W = list [ 0 ] <NEWLINE> H = list [ 1 ] <NEWLINE> x = list [ 2 ] <NEWLINE> y = list [ 3 ] <NEWLINE> r = list [ 4 ] <NEWLINE> <NL> if x - r < 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif x + r > W : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif y - r < 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif y + r > H : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
numbers = [ ] <NEWLINE> n = raw_input ( ) <NEWLINE> numbers = n . split ( <STRING> ) <NEWLINE> for i in range ( 5 ) : <NEWLINE> <INDENT> numbers [ i ] = int ( numbers [ i ] ) <NEWLINE> <DEDENT> W = numbers [ 0 ] <NEWLINE> H = numbers [ 1 ] <NEWLINE> x = numbers [ 2 ] <NEWLINE> y = numbers [ 3 ] <NEWLINE> r = numbers [ 4 ] <NEWLINE> <NL> if x - r = > 0 and y - r = > 0 and x + r <= W and y + r <= H : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT>
W , H , x , y , r = mao ( int , input ( ) . split ( ) ) <NEWLINE> if x - r >= 0 and x + r <= W and y - r >= 0 and y + r <= 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
W , H , x , y , r = raw_input ( ) . split ( <STRING> ) <NEWLINE> if ( x + r ) < W and 0 < ( x - r ) and 0 < ( y - r ) and ( y + r ) < H : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT>
( W , H , x , y , r ) = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> nums = input ( ) . split ( ) <NEWLINE> W = int ( nums [ 0 ] ) <NEWLINE> H = int ( nums [ 1 ] ) <NEWLINE> x = int ( nums [ 2 ] ) <NEWLINE> y = int ( nums [ 3 ] ) <NEWLINE> r = int ( nums [ 4 ] ) <NEWLINE>
W , H , x , y , r = raw_input ( ) <NEWLINE> W , H , x , y , r = map ( int , ( W , H , x , y , r ) ) <NEWLINE> def isXok ( W , H , x , y , r ) : <NEWLINE> <INDENT> if x - r < 0 or x + r > W : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> <DEDENT> def isYok ( W , H , x , y , r ) : <NEWLINE> <INDENT> if y - r < 0 or y + r > H : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> <DEDENT> if isXok ( W , H , x , y , r ) and isXok ( W , H , x , y , r ) : <NEWLINE> <INDENT> print True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print False <NEWLINE> <DEDENT>
You are not allowed to see this code . <NEWLINE>
input = <STRING> <COMMENT> <NEWLINE> w , h , x , y , r = input1 . split ( ) <NEWLINE> <NL> top = y + r <NEWLINE> bottom = y - r <NEWLINE> left = x - r <NEWLINE> right = x + r <NEWLINE> <NL> if h >= top and bottom >= and right >= top and left >= 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
W , H , x , y , r = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <NL> if x - r : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif x + r : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif y - r : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif y + r : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> <NEWLINE> <DEDENT>
inputs = input ( ) . split ( <STRING> ) <NEWLINE> inputs = list ( map ( int , inputs ) ) <NEWLINE> <NL> W = inputs [ 0 ] <NEWLINE> H = inputs [ 1 ] <NEWLINE> x = inputs [ 2 ] <NEWLINE> y = inputs [ 3 ] <NEWLINE> r = inputs [ 4 ] <NEWLINE> <NL> if r <= x and x <= W - r and <NEWLINE> <INDENT> r <= y and y <= H - r : <NEWLINE> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
if x - r < 0 or y - r < 0 or x + r > W or y + r > H : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
input_str = input ( ) . split ( <STRING> ) <NEWLINE> W = int ( input_str [ 0 ] ) <NEWLINE> H = int ( input_str [ 1 ] ) <NEWLINE> x = int ( input_str [ 2 ] ) <NEWLINE> y = int ( input_str [ 3 ] ) <NEWLINE> r = int ( input_str [ 4 ] ) <NEWLINE> <NL> print ( <STRING> if x - r >= 0 and x + r = < W and y - r >= 0 and y + r <= H else <STRING> ) <NEWLINE>
W , H , x , y , r = map ( int , input ( ) . split ( ) ) <NEWLINE> if r <= x and x <= W - r and r <= y and y <= H - r : <NEWLINE> <INDENT> print ( Yes ) <NEWLINE> <DEDENT> else : print ( No ) <NEWLINE>
return <NEWLINE>
W , H , x , y , r = [ int ( i ) for i input ( ) . split ( ) ] <NEWLINE> if x < 0 or y < 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif x + r <= W and y + r <= H : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
w , h , x , y , r = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if ( w - r = > x = > r ) and ( h - r = > y = > r ) : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT>
W , H , x , y , r = int ( input ( ) . splite ( ) ) <NEWLINE> if x + r < W and y + r < H : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
[ W , H , x , y , r ] = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> if ( 0 = < x = < W ) and ( 0 = < y = < H ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
in = input ( ) . split ( <STRING> ) <NEWLINE> <NL> W = int ( in [ 0 ] ) <NEWLINE> H = int ( in [ 1 ] ) <NEWLINE> x = int ( in [ 2 ] ) <NEWLINE> y = int ( in [ 3 ] ) <NEWLINE> r = int ( in [ 4 ] ) <NEWLINE> <NL> if x - r >= 0 and y - r >= 0 and x + r <= W and y + r <= H : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
X = raw_input ( ) . split ( ) <NEWLINE> if X [ 2 ] + X [ 4 ] < X [ 0 ] and X [ 2 ] - X [ 4 ] > 0 and X [ 3 ] + X [ 4 ] < X [ 1 ] and X [ 3 ] - X [ 4 ] > 0 : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT>
a , b = input ( ) . split ( ) <NEWLINE> x = int ( a ) <NEWLINE> y = int ( b ) <NEWLINE> <NL> if x < y : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif x > y : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif x == y : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT>
W , H , x , y , r = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> if x - r >= 0 and x + r <= W : <NEWLINE> <INDENT> if y - r >= 0 and y + r <= H : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT>
W , H , x , y , r = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> if x - r >= 0 and x + r = < W : <NEWLINE> <INDENT> if y - r >= 0 and y + r <= H : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
W , H , x , y , r = map ( int , raw_input ( ) . split ( <STRING> ) ) <NEWLINE> print <STRING> if r <= x <= W - r and r <= y <= H - r else <STRING> <NEWLINE>
W , H , x , y , r = map ( int , input ( ) . split ( ) ) <NEWLINE> if x >= r and x + r <= W and y >= r and y + r <= H : <NEWLINE> print ( <STRING> ) <NEWLINE> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
W , H , x , y , r = input ( ) . split ( ) <NEWLINE> <NL> if x + r > W or y + r > H or x - r < 0 or y - r < 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
<COMMENT> <NL> s = input ( ) . split ( ) <NEWLINE> w = int ( s [ 0 ] ) <NEWLINE> h = int ( s [ 1 ] ) <NEWLINE> x = int ( s [ 2 ] ) <NEWLINE> y = int ( s [ 3 ] ) <NEWLINE> r = int ( s [ 4 ] ) <NEWLINE> <NL> if ( x - r = > 0 and x + r <= w and y - r = > 0 and y + r <= h ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
W , H , x , y , r = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if r < x and r < y and y < ( h - r ) and x < ( W - r ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
int main ( void ) { <NEWLINE> <INDENT> int w , h , x , y , r ; <NEWLINE> scanf ( <STRING> , & w , & h , & x , & y , & r ) ; <NEWLINE> if ( w < x + r | | h < y + r | | 0 > x - r | | 0 > y - r ) { <NEWLINE> <INDENT> printf ( <STRING> ) ; <NEWLINE> <DEDENT> } <NEWLINE> else { <NEWLINE> <INDENT> printf ( <STRING> ) ; <NEWLINE> <DEDENT> } <NEWLINE> return 0 ; <NEWLINE> <DEDENT> } <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> W , H , x , y , r = map ( int , input ( ) . split ( ) ) <NEWLINE> if x - r >= 0 AND y - r >= 0 AND W >= x + r and H >= y + r : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
W , H , x , y , r = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if W + r <= x <= W - r & & H + r <= y <= H - r : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> def string_five_numbers_spliter ( ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> w , h , x , y , r = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> return w , h , x , y , r <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <INDENT> w , h , x , y , r = string_five_numbers_spliter ( ) <NEWLINE> <NL> if not ( x + r < 0 ) and not ( y + r < 0 ) and <NEWLINE> <INDENT> not ( x + r > w ) and not ( y + r > h ) : <NEWLINE> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
W , H , x , y , r = map ( int , input ( ) . split ( ) ) <NEWLINE> if x + r = < W and x - r = > 0 and y + r = < H and y - r = > 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
W , H , x , y , r = map ( int , input ( ) . split ( ) ) <NEWLINE> if x + r <= W and x - r >= 0 and y + r <= H and y - r >= 0 : <NEWLINE> <INDENT> printf ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> printf ( <STRING> ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> elements [ ] = input ( ) . split ( ) <NEWLINE> w = elements [ 0 ] <NEWLINE> h = elements [ 1 ] <NEWLINE> x = elements [ 2 ] <NEWLINE> y = elements [ 3 ] <NEWLINE> r = elements [ 4 ] <NEWLINE> <NL> if x <= 0 OR y <= 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> elif x >= r AND y >= r : <NEWLINE> <INDENT> if x + r <= w AND y + r <= h : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT>
W , H , x , y , r = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> if x + r <= W and y = r >= 0 and x - r >= 0 and y + r <= H : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
ciar = input ( ) . split ( ) <NEWLINE> W , H , x , y , r = [ ciar [ 0 ] , ciar [ 1 ] , ciar [ 2 ] , ciar [ 3 ] , ciar [ 4 ] ] <NEWLINE> if ( x + r ) <= W and ( x - r ) >= 0 : <NEWLINE> <INDENT> if ( y + r ) <= H and ( y - r ) >= 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
W , H , x , y , r = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> print <STRING> if 0 = < ( x + r ) = < W and 0 = < ( y + r ) = < H else <STRING> <NEWLINE>
W , H , x , y , r = map ( int , input ( ) . split ( ) ) <NEWLINE> if ( x - r < 0 | | x + r > W | | y - r < 0 | | y + r > H ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
x = input ( ) . split ( <STRING> ) <NEWLINE> w = int ( x [ 0 ] ) <NEWLINE> h = int ( x [ 1 ] ) <NEWLINE> x = int ( x [ 2 ] ) <NEWLINE> y = int ( x [ 3 ] ) <NEWLINE> r = int ( x [ 4 ] ) <NEWLINE> if x - r < 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif w < x + r : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif y - r < 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif h < y + r : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> W , H , x , y , r = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> if ( ( x - r ) >= 0 ) and ( ( x + r ) <= W ) and ( ( y - r ) >= 0 ) and ( ( y + r ) <= H ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
m = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if 0 <= m [ 3 ] - m [ 5 ] and m [ 3 ] + m [ 5 ] <= m [ 1 ] and 0 <= m [ 4 ] - m [ 5 ] and m [ 4 ] + m [ 5 ] <= m [ 2 ] : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT>
w = int ( n [ 0 ] ) <NEWLINE> h = int ( n [ 1 ] ) <NEWLINE> x = int ( n [ 2 ] ) <NEWLINE> y = int ( n [ 3 ] ) <NEWLINE> r = int ( n [ 4 ] ) <NEWLINE> if w > h and h > x and x > y and y > r : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
W = int ( input ( ) ) <NEWLINE> H = int ( input ( ) ) <NEWLINE> x = int ( input ( ) ) <NEWLINE> y = int ( input ( ) ) <NEWLINE> r = int ( input ( ) ) <NEWLINE> <NL> if x - r >= 0 and x - r >= 0 and x + r <= W and y + r <= H : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
S = raw_input ( ) . split ( <STRING> ) <NEWLINE> for i in range ( 0 , len ( S ) ) : <NEWLINE> <INDENT> S [ i ] = int ( S [ i ] ) <NEWLINE> <NL> <DEDENT> if 0 < x + r & x + r < w & 0 < y + r & y + r < h : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
d = raw_input ( ) . split ( <STRING> ) <NEWLINE> l = list ( map ( int , d ) ) <NEWLINE> if ( i [ 2 ] > 0 and i [ 3 ] > 0 ) : <NEWLINE> <INDENT> if ( l [ 0 ] >= ( l [ 2 ] + l [ 4 ] ) ) : <NEWLINE> <INDENT> if ( l [ 1 ] >= ( l [ 3 ] + l [ 4 ] ) ) : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT>
Indata = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> W , H , x , y , r = [ int ( i ) for i in Indata ] <NEWLINE> x_right = x + r <NEWLINE> x_left = x - r <NEWLINE> y_on = y + r <NEWLINE> y_under = y - r <NEWLINE> <NL> if x_right > W | | x_left < 0 | | y_on > H | | y_under < 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
W , H , x , y , r = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> <NL> if ( r = < x = < ( W - r ) ) and ( r = < y = < ( H - r ) ) : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <NL> var = raw_input ( ) . split ( ) <NEWLINE> <NL> var = map ( int , var ) <NEWLINE> <NL> if 0 < var [ 2 ] - var [ 4 ] or 0 < var [ 3 ] - var [ 4 ] : <NEWLINE> <INDENT> print <STRING> <NEWLINE> return None <NEWLINE> <DEDENT> elif var [ 0 ] < var [ 2 ] + var [ 4 ] or var [ 1 ] > var [ 3 ] + var [ 4 ] : <NEWLINE> <INDENT> print <STRING> <NEWLINE> return None <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT>
import sys <NEWLINE> for i , x in enumerate ( map ( int , sys . stdin ( ) ) ) : <NEWLINE> <INDENT> if x == 0 or not x : <NEWLINE> <INDENT> break ; <NEWLINE> <DEDENT> print ( <STRING> . format ( i + 1 , x ) ) <NEWLINE> <DEDENT>
a = [ ] <NEWLINE> while True : <NEWLINE> <INDENT> n = input ( ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> a . append ( n ) <NEWLINE> <DEDENT> i = 0 <NEWLINE> for case in a : <NEWLINE> <INDENT> i += 1 <NEWLINE> print <STRING> + str ( i ) + <STRING> + str ( case ) <NEWLINE> <DEDENT>
i = 1 ; count = 1 <NEWLINE> while 1 : <NEWLINE> <INDENT> i = input ( ) <NEWLINE> if i == 0 : break <NEWLINE> <NL> print ( <STRING> . format ( count , i ) ) <NEWLINE> count += 1 <NEWLINE> <DEDENT>
li = [ ] <NEWLINE> while ( a != 0 ) : <NEWLINE> <INDENT> a = int ( input ( ) ) <NEWLINE> li . append ( a ) <NEWLINE> <DEDENT> for i in range ( 1 , len ( li ) + 1 ) : <NEWLINE> <INDENT> if li [ i ] != 0 : <NEWLINE> <INDENT> print ( <STRING> . format ( i , li [ i ] ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT>
x_list = [ ] <NEWLINE> while 1 : <NEWLINE> <INDENT> x = input ( ) <NEWLINE> x_list . append ( x ) <NEWLINE> if x == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> for x in x_list : <NEWLINE> <INDENT> if x == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> print <STRING> + str ( x_list . index ( x ) + 1 ) + <STRING> + str ( x ) <NEWLINE> <DEDENT>
i = 0 <NEWLINE> while input ( ) != 0 : <NEWLINE> <INDENT> i += 1 <NEWLINE> print ( <STRING> , i , <STRING> , input ( ) , sep = <STRING> ) <NEWLINE> <NL> <DEDENT>
counter = 0 <NEWLINE> <NL> while True : <NEWLINE> <INDENT> counter += 1 <NEWLINE> x = int ( input ( ) ) <NEWLINE> if x == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> print ( <STRING> + counter + <STRING> + x ) <NEWLINE> <DEDENT>
i = 1 <NEWLINE> while True : <NEWLINE> <INDENT> x = int ( input ( ) ) <NEWLINE> if x == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> print ( <STRING> , <STRING> , i , <STRING> , <STRING> , x ) <NEWLINE> i += <NEWLINE> <DEDENT>
i = 1 <NEWLINE> while True : <NEWLINE> <INDENT> x = int ( input ( ) ) ) <NEWLINE> if ( x == 0 ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> i += 1 <NEWLINE> <DEDENT>
count = 1 <NEWLINE> t = [ ] <NEWLINE> while True : <NEWLINE> <INDENT> x = input ( <STRING> ) <NEWLINE> if x == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> t . append ( <STRING> , str ( count ) + <STRING> , x ) <NEWLINE> count = int ( count ) + 1 <NEWLINE> <NL> <DEDENT> <DEDENT> for i in t : <NEWLINE> <INDENT> print ( t [ i ] ) <NEWLINE> <DEDENT>
i = 0 <NEWLINE> while 1 : <NEWLINE> <INDENT> i += 1 <NEWLINE> x = raw_input ( ) <NEWLINE> if x == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> print ( <STRING> . format ( i , v ) ) <NEWLINE> <DEDENT>
import sys <NEWLINE> i = 1 <NEWLINE> while True : <NEWLINE> <INDENT> x = sys . stdin . readline ( ) . strip ( ) <NEWLINE> if x == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> print ( <STRING> % ( i , x ) ) <NEWLINE> i += 1 <NEWLINE> <DEDENT>
input_array = [ ] <NEWLINE> <NL> while True : <NEWLINE> <INDENT> input_num = int ( raw_input ( ) ) <NEWLINE> if input_num == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> input_array . append ( input_num ) <NEWLINE> <NL> <DEDENT> for x in range ( 0 , len ( input_array ) ) : <NEWLINE> <INDENT> print ( <STRING> + str ( input_array [ x ] ) ) . format ( x + 1 ) <NEWLINE> <DEDENT>
l = [ ] <NEWLINE> y = 1 <NEWLINE> while True : <NEWLINE> <INDENT> x = input ( ) <NEWLINE> if x == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> l . append ( x ) <NEWLINE> print ( <STRING> . format ( y , x ) ) <NEWLINE> y += 1 <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> lists = sys . stdin ( ) . readlines ( ) <NEWLINE> <NL> for i , int ( line ) in enumerate ( lists ) : <NEWLINE> <INDENT> if ( line [ i ] != 0 ) : <NEWLINE> <INDENT> print <STRING> % ( i , line [ i ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> i = 1 <NEWLINE> <NL> while True : <NEWLINE> <INDENT> x = int ( input ( ) ) <NEWLINE> if x == 0 : <NEWLINE> <INDENT> break : <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> % ( i , x ) ) <NEWLINE> i + + <NEWLINE> <DEDENT> <DEDENT>
n = 1 <NEWLINE> x = int ( input ( ) ) <NEWLINE> while x != 0 : <NEWLINE> <INDENT> print ( <STRING> . format ( n , x ) <NEWLINE> n = n + 1 <NEWLINE> x = int ( input ( ) ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> print ( <STRING> + input ( ) ) <NEWLINE> <DEDENT>
x = 10000 <NEWLINE> i = 1 <NEWLINE> while x : <NEWLINE> <INDENT> x = input ( ) <NEWLINE> if x == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> print ( <STRING> . format ( i , x ) ) <NEWLINE> i += 1 <NEWLINE> <DEDENT>
i = 1 <NEWLINE> while True : <NEWLINE> <INDENT> x = int ( input ( ) ) <NEWLINE> if x == 0 break : <NEWLINE> print ( <STRING> . format ( i , x ) ) <NEWLINE> i += 1 <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> i = 1 <NEWLINE> for x in sys . stdin : <NEWLINE> <INDENT> if int ( x ) == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> print <STRING> % ( i , x ) <NEWLINE> i += 1 <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> a = 0 <NEWLINE> while True : <NEWLINE> <INDENT> i = int ( sys . stdin . readline ( ) ) <NEWLINE> if ( b == 0 ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> b += 1 <NEWLINE> print ( <STRING> + str ( a ) + <STRING> , a ) <NEWLINE> <DEDENT>
n = [ ] <NEWLINE> line = <STRING> <NEWLINE> i = 0 <NEWLINE> while line != <STRING> : <NEWLINE> <INDENT> line = input ( ) <NEWLINE> if line != <STRING> <NEWLINE> <INDENT> n . append ( int ( line ) ) <NEWLINE> i = i + 1 <NEWLINE> print ( i ) <NEWLINE> <DEDENT> <DEDENT> for x in range ( len ( n ) ) : <NEWLINE> <INDENT> print ( <STRING> % ( x , n [ x ] ) ) <NEWLINE> <DEDENT>
data = input ( ) <NEWLINE> counter = 1 <NEWLINE> while data != 0 : <NEWLINE> <INDENT> print ( <STRING> + str ( counter ) + <STRING> + str ( data ) ) <NEWLINE> <DEDENT> print ( <STRING> + counter + <STRING> + data ) <NEWLINE>
i = 1 <NEWLINE> while 1 : <NEWLINE> <INDENT> a = input ( ) <NEWLINE> if a == 0 : break <NEWLINE> print ( <STRING> ) <NEWLINE> i += 1 <NEWLINE> <DEDENT>
num = 1 <NEWLINE> while True ; <NEWLINE> <INDENT> x = int ( input ( ) ) <NEWLINE> if x == 0 ; break <NEWLINE> print ( <STRING> . fromat ( num , x ) ) <NEWLINE> <NL> num += 1 <NEWLINE> <DEDENT>
a = [ ] <NEWLINE> for line in sys . stdin : <NEWLINE> <INDENT> if line = <STRING> <NEWLINE> <INDENT> a . append ( int ( line ) ) <NEWLINE> if len ( a > 10000 ) : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for i in range ( len ( a ) ) : <NEWLINE> <INDENT> print ( <STRING> , i + 1 , <STRING> , a [ i ] , sep = <STRING> ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> x = int ( input ( ) ) <NEWLINE> if x == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> print ( <STRING> . format ( i , x ) ) <NEWLINE> i += 1 <NEWLINE> <DEDENT>
i = 0 <NEWLINE> while 1 : <NEWLINE> <INDENT> x = int ( input ( ) ) <NEWLINE> if x == 0 : break <NEWLINE> i += 1 <NEWLINE> print <STRING> % ( i , x ) <NEWLINE> <DEDENT> break <NEWLINE> <NL>
import sys <NEWLINE> cnt = 1 <NEWLINE> while 1 : <NEWLINE> <INDENT> x = sys . stdin . readline ( ) . strip ( ) <NEWLINE> if x == <STRING> <NEWLINE> <INDENT> break ; <NEWLINE> <DEDENT> print ( <STRING> % ( cnt , x ) ) <NEWLINE> cnt += 1 <NEWLINE> <DEDENT>
if __name__ == <STRING> : <NEWLINE> <NL> <INDENT> numbers = [ ] <NEWLINE> <NL> while True : <NEWLINE> <INDENT> x = int ( raw_input ( ) ) <NEWLINE> if x == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> numbers . append ( x ) <NEWLINE> <NL> <DEDENT> i = 1 <NEWLINE> <NL> for n in numbers : <NEWLINE> <INDENT> print <STRING> % ( i , n ) <NEWLINE> i += 1 <NEWLINE> <DEDENT> <DEDENT>
i = 0 <NEWLINE> <NL> while True : <NEWLINE> <INDENT> c = int ( input ( ) ) <NEWLINE> ifc == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> i = i + 1 <NEWLINE> print <STRING> % ( i , c ) <NEWLINE> <DEDENT>
x = int ( input ( ) ) <NEWLINE> i = 1 <NEWLINE> while x != 0 : <NEWLINE> <INDENT> print ( <STRING> . format ( i , x ) ) <NEWLINE> i += 1 <NEWLINE> <DEDENT>
i = 1 <NEWLINE> x = int ( input ( ) ) <NEWLINE> while x > 0 : <NEWLINE> <INDENT> print ( <STRING> . format ( h , x ) ) <NEWLINE> x = int ( input ( ) ) <NEWLINE> i += 1 <NEWLINE> <DEDENT>
<INDENT> i = 0 <NEWLINE> <DEDENT> while 1 : <NEWLINE> <INDENT> x = raw_input ( ) <NEWLINE> i = i + 1 <NEWLINE> if x == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> print <STRING> % ( i , x ) <NEWLINE> <DEDENT>
a = [ ] <NEWLINE> while ( 1 ) : <NEWLINE> <INDENT> n = input ( ) <NEWLINE> if ( n == 0 ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> a . append ( n ) <NEWLINE> <DEDENT>
s = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> i = 1 <NEWLINE> while True : <NEWLINE> <INDENT> if s [ i - 1 ] == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> + str ( i ) + <STRING> + str ( s [ i - 1 ] ) ) <NEWLINE> i += 1 <NEWLINE> <DEDENT> <DEDENT>
i = 1 <NEWLINE> while True : <NEWLINE> <INDENT> x = int ( input ( ) ) <NEWLINE> if x == 0 : break <NEWLINE> print ( <STRING> . format ( i , n ) ) <NEWLINE> i += 1 <NEWLINE> <DEDENT>
i = 1 <NEWLINE> while True : <NEWLINE> <INDENT> s = int ( input ) <NEWLINE> if s == 0 : break <NEWLINE> print ( <STRING> ) <NEWLINE> <DEDENT>
<NL> x = [ ] <NEWLINE> while True : <NEWLINE> <INDENT> i = int ( raw_input ( ) ) <NEWLINE> if i == 0 : <NEWLINE> <INDENT> break ; <NEWLINE> <DEDENT> x . append ( i ) <NEWLINE> <DEDENT> X = iter ( x ) <NEWLINE> i = 1 <NEWLINE> for a in X : <NEWLINE> <INDENT> print ( <STRING> % ( i , a ) ) <NEWLINE> i += 1 <NEWLINE> <DEDENT>
lis = [ ] <NEWLINE> while True : <NEWLINE> <INDENT> if input ( ) == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> lis . append ( input ( ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( len ( lis ) ) : <NEWLINE> <INDENT> print ( <STRING> % ( i , lis [ i ] ) ) <NEWLINE> <DEDENT>
count = 0 <NEWLINE> while 1 : <NEWLINE> <INDENT> count += 1 <NEWLINE> a = input ( ) <NEWLINE> if a == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> + str ( count ) + <STRING> + str ( a ) ) <NEWLINE> <NL> <DEDENT> <DEDENT>
a = 0 <NEWLINE> while True : <NEWLINE> <INDENT> x = int ( input ( ) ) <NEWLINE> a += 1 <NEWLINE> if x == 0 : break <NEWLINE> print ( <STRING> . format ( a . x ) ) <NEWLINE> <DEDENT>
i = 0 <NEWLINE> while True : <NEWLINE> <INDENT> x = int ( raw_input ( ) ) <NEWLINE> if x == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> i += 1 <NEWLINE> i = str ( i ) <NEWLINE> x = str ( x ) <NEWLINE> print <STRING> % ( i , x ) <NEWLINE> <DEDENT>
from __future__ import division , print_function <NEWLINE> from sys import stdin <NEWLINE> <NL> i = 1 <NEWLINE> for line in stdin : <NEWLINE> <INDENT> x = int ( line ) <NEWLINE> if not x : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> print <STRING> . format ( i , x ) <NEWLINE> i += 1 <NEWLINE> <DEDENT>
i = 1 <NEWLINE> while true : <NEWLINE> <INDENT> a = raw_input ( ) <NEWLINE> if a = <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> print <STRING> % ( i , a ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> x = int ( input ( ) ) <NEWLINE> print ( x ) <NEWLINE> <DEDENT> if x = 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT>
i = 1 <NEWLINE> while True : <NEWLINE> <INDENT> x = int ( input ( ) ) <NEWLINE> if x : print ( <STRING> . format ( i , x ) ) else break <NEWLINE> i += 1 <NEWLINE> <DEDENT>
i = 1 <NEWLINE> while True : <NEWLINE> <INDENT> hoge = input ( ) <NEWLINE> if hoge == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> print ( <STRING> + str ( i ) + <STRING> + hoge ) <NEWLINE> i += 1 <NEWLINE> <DEDENT>
import sys <NEWLINE> a = 1 <NEWLINE> <NL> While 1 : <NEWLINE> <INDENT> x = sys . stdin . readline ( ) . strip ( ) <NEWLINE> if x == 0 : <NEWLINE> <INDENT> break ; <NEWLINE> <DEDENT> print ( <STRING> . format ( a , x ) ) <NEWLINE> a += 1 <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> x = int ( input ( <STRING> ) ) <NEWLINE> <NL> i = 1 <NEWLINE> <NL> while x != 0 : <NEWLINE> <INDENT> print ( <STRING> . format ( i , x ) ) <NEWLINE> i = i + 1 ; <NEWLINE> <NL> <NL> <DEDENT>
count = 0 <NEWLINE> while True : <NEWLINE> <INDENT> x = raw_input ( ) <NEWLINE> count += 1 <NEWLINE> if x == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> print ( <STRING> + str ( count ) + <STRING> + x ) <NEWLINE> <NL> <DEDENT>
while True : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> if x == 0 and y == 0 : <NEWLINE> break <NEWLINE> <DEDENT> if x > y : <NEWLINE> <INDENT> print ( y , x ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( x , y ) <NEWLINE> <DEDENT>
x = int ( input ( ) ) <NEWLINE> i = 1 ; <NEWLINE> while True : <NEWLINE> <INDENT> if x == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
cnt = 1 <NEWLINE> c = int ( input ( ) ) <NEWLINE> while c != 0 : <NEWLINE> <INDENT> print ( <STRING> . format ( cnt ) . format ( c ) ) <NEWLINE> c = int ( input ( ) ) <NEWLINE> cnt += 1 <NEWLINE> <DEDENT>
i = 0 <NEWLINE> x = int ( input ( ) ) <NEWLINE> while x = int ( input ( ) ) != 0 : <NEWLINE> <INDENT> i = i + 1 <NEWLINE> print ( <STRING> + str ( i ) + <STRING> + str ( x ) ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> i = 0 <NEWLINE> while True : <NEWLINE> <INDENT> x = int ( input ( ) ) ; <NEWLINE> i += 1 <NEWLINE> if x == 0 : break <NEWLINE> print ( <STRING> . format ( c , i ) ) <NEWLINE> <DEDENT>
count = 1 <NEWLINE> while True : <NEWLINE> <INDENT> x = int ( input ( ) . strip ( ) ) <NEWLINE> if x == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> . format ( count , x ) ) <NEWLINE> count += 1 <NEWLINE> <DEDENT> <DEDENT>
flag = 0 <NEWLINE> i = 0 <NEWLINE> while flag == 0 : <NEWLINE> <INDENT> num = input ( ) <NEWLINE> if num == 0 or num == <STRING> : <NEWLINE> <INDENT> flag = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> . format ( i + 1 , num ) ) <NEWLINE> i = i + 1 <NEWLINE> num = int ( input ( ) ) <NEWLINE> <DEDENT> <DEDENT>
i = 0 <NEWLINE> while True : <NEWLINE> <INDENT> x = input ( ) <NEWLINE> i += 1 <NEWLINE> print <STRING> + str ( i ) + <STRING> + str ( x ) <NEWLINE> <DEDENT>
i = 0 <NEWLINE> while 1 : <NEWLINE> <INDENT> x = raw_index ( ) <NEWLINE> i = i + 1 <NEWLINE> if x == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> print <STRING> % ( i , x ) <NEWLINE> <DEDENT>
i = 0 <NEWLINE> <NL> while True : <NEWLINE> <INDENT> num = int ( input ( ) ) <NEWLINE> if num == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> print ( <STRING> . format ( i , num ) ) <NEWLINE> i + + <NEWLINE> <NL> <DEDENT>
i = 1 <NEWLINE> while ( 1 ) : <NEWLINE> <INDENT> x = int ( raw_input ( ) ) <NEWLINE> if x == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> print <STRING> % ( i , x ) : <NEWLINE> i = i + 1 <NEWLINE> <DEDENT>
num = 0 <NEWLINE> while ( true ) : <NEWLINE> <INDENT> x = sys . stdin . readline ( ) <NEWLINE> num += 1 <NEWLINE> if x == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> print ( <STRING> . % num , x ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> i = 0 <NEWLINE> <NL> while True : <NEWLINE> <INDENT> i += 1 <NEWLINE> n = input ( ) <NEWLINE> if n == 0 : break <NEWLINE> print ( <STRING> + str ( i ) + <STRING> + n ) <NEWLINE> <DEDENT> <DEDENT> main ( ) <NEWLINE> <NL>
<COMMENT> <NL> <COMMENT> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> i = 1 <NEWLINE> values = [ ] <NEWLINE> while True : <NEWLINE> <INDENT> x = int ( raw_input ( ) ) <NEWLINE> if x == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> values . append ( x ) <NEWLINE> <NL> <DEDENT> for i in range ( len ( values ) ) : <NEWLINE> <INDENT> print <STRING> , ( i + 1 ) , <STRING> , values [ i ] <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
a = 1 <NEWLINE> while True : <NEWLINE> <INDENT> x = raw_input ( ) <NEWLINE> if x != 0 : <NEWLINE> <NL> <INDENT> print ( <STRING> + str ( a ) + <STRING> + x ) <NEWLINE> a += 1 <NEWLINE> <DEDENT> elif x == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT>
for i in range ( ) : <NEWLINE> <INDENT> inpu = int ( input ( ) ) <NEWLINE> if inpu == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> % ( i , inpu ) ) <NEWLINE> <DEDENT> <DEDENT>
<NL> <INDENT> x = int ( input ( ) ) <NEWLINE> int i = 0 ; <NEWLINE> while ( 1 ) { <NEWLINE> <INDENT> scanf ( <STRING> , & x ) ; <NEWLINE> if ( x == 0 ) break ; <NEWLINE> printf ( <STRING> , + + i , x ) ; <NEWLINE> <NL> <DEDENT> <DEDENT>
for i in range ( 1 , 100000000000 ) <NEWLINE> <INDENT> x = int ( input ( ) ) <NEWLINE> if x == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> print ( <STRING> + str ( i ) + <STRING> + str ( x ) ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> i = input ( ) <NEWLINE> if i != 0 : <NEWLINE> <INDENT> print <STRING> % i <NEWLINE> <DEDENT> else : False <NEWLINE> <DEDENT>
a = [ ] <NEWLINE> while True : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> break <NEWLINE> <INDENT> a . append ( n ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> for i in range ( len ( a ) ) : <NEWLINE> <INDENT> print ( <STRING> . format ( i + 1 , a [ i ] ) ) <NEWLINE> <DEDENT>
c = 0 <NEWLINE> while True : <NEWLINE> <INDENT> a = raw_input ( ) <NEWLINE> if a == 0 : break <NEWLINE> c += 1 <NEWLINE> print <STRING> % ( c , a ) <NEWLINE> <DEDENT>
l <NEWLINE> <NL>
i = 0 <NEWLINE> while 1 : <NEWLINE> <INDENT> a = int ( input ( ) ) <NEWLINE> if ( a == 0 ) break <NEWLINE> i += 1 <NEWLINE> print ( <STRING> . format ( i , a ) ) <NEWLINE> <DEDENT>
for i , x in enumerate ( ( input ( ) ) . strip ( ) ) : <NEWLINE> <INDENT> x = int ( input ( ) ) <NEWLINE> if x == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> print ( <STRING> + str ( i ) + <STRING> + x ) <NEWLINE> <DEDENT>
import sys <NEWLINE> i = 1 <NEWLINE> for a in sys . stdin : a = a . strip ( ) <NEWLINE> <INDENT> if a == <STRING> : break <NEWLINE> print ( <STRING> ) <NEWLINE> i += 1 <NEWLINE> <DEDENT>
i = 0 <NEWLINE> while True : <NEWLINE> <INDENT> i + + <NEWLINE> x = int ( input ( ) ) <NEWLINE> if x == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> . format ( i , x ) ) <NEWLINE> <DEDENT> <DEDENT>
i = 1 <NEWLINE> while ( True ) : <NEWLINE> <NL> <INDENT> x = int ( raw_input ( ) ) <NEWLINE> if x != 0 : <NEWLINE> <INDENT> print <STRING> + str ( i ) + <STRING> + str ( x ) <NEWLINE> i += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT>
i = 1 <NEWLINE> while True : <NEWLINE> <INDENT> n = input ( ) <NEWLINE> if n != 0 : <NEWLINE> <INDENT> print <STRING> % ( str ( i ) , str ( n ) ) <NEWLINE> i = i + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT>
count = 0 <NEWLINE> while x != 0 : <NEWLINE> <INDENT> x = int ( input ( ) ) <NEWLINE> print ( <STRING> . format ( count ) ) <NEWLINE> count += 1 <NEWLINE> <DEDENT>
import abc <NEWLINE> <NL> c = 0 <NEWLINE> while True : <NEWLINE> <INDENT> i = int ( abc . stdin . readline ( ) ) <NEWLINE> if ( i == 0 ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> c += 1 <NEWLINE> print ( <STRING> + str ( c ) + <STRING> , i ) <NEWLINE> <DEDENT>
i = 1 <NEWLINE> while ( 1 ) : <NEWLINE> <INDENT> x = raw_input ( ) <NEWLINE> if x == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> print <STRING> % ( i , x ) <NEWLINE> i += 1 <NEWLINE> <DEDENT>
i = 0 <NEWLINE> <NL> while 1 : <NEWLINE> <INDENT> x = raw_input ( ) <NEWLINE> i += 1 <NEWLINE> if x == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> print <STRING> % i , x <NEWLINE> <DEDENT>
i = 0 <NEWLINE> while True : <NEWLINE> <INDENT> i += 1 <NEWLINE> n = input ( ) <NEWLINE> if ( n == 0 ) : break <NEWLINE> print ( <STRING> + str ( i ) + <STRING> + str ( n ) ) <NEWLINE> <DEDENT>
x = int ( input ( ) ) <NEWLINE> i = 1 <NEWLINE> while x != <STRING> : <NEWLINE> <INDENT> print ( <STRING> % ( i , x ) ) <NEWLINE> x = int ( input ( ) ) <NEWLINE> i += 1 <NEWLINE> <DEDENT>
count = 0 <NEWLINE> while True : <NEWLINE> <INDENT> count = count + 1 <NEWLINE> a = input ( ) <NEWLINE> b = len ( a ) <NEWLINE> if b == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> + str ( count ) + <STRING> + str ( a ) ) <NEWLINE> <NL> <DEDENT> <DEDENT>
<NL> import sys <NEWLINE> cnt = 1 <NEWLINE> while 1 : <NEWLINE> <INDENT> x = sys . stdin . readline ( ) . strip ( ) <NEWLINE> if x == <STRING> : <NEWLINE> <INDENT> break : <NEWLINE> <DEDENT> print ( <STRING> % ( cnt , x ) ) <NEWLINE> cnt += 1 <NEWLINE> <DEDENT>
i = 1 <NEWLINE> while True : <NEWLINE> <INDENT> n = input ( ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> print <STRING> + str ( i ) + <STRING> + str ( n ) <NEWLINE> i += 1 <NEWLINE> <DEDENT>
a = [ ] <NEWLINE> while True : <NEWLINE> <INDENT> n = input ( ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> a . append ( n ) <NEWLINE> <NL> <DEDENT> for i in range ( a ) : <NEWLINE> <INDENT> print ( <STRING> + str ( i ) + <STRING> + str ( a [ i ] ) ) <NEWLINE> <DEDENT>
import sys <NEWLINE> c = 0 <NEWLINE> for line in sys . stdin : <NEWLINE> <INDENT> if line = <STRING> : break <NEWLINE> c += 1 <NEWLINE> print <STRING> % ( c , int ( line ) ) <NEWLINE> <DEDENT>
i = 1 <NEWLINE> <NL> while True : <NEWLINE> <INDENT> x = map ( int , input ( ) ) <NEWLINE> if x = False : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> print ( <STRING> , i , <STRING> , x ) <NEWLINE> <NL> <NL> <DEDENT>
i = 0 <NEWLINE> while True : <NEWLINE> <INDENT> i += 1 <NEWLINE> a = input ( ) <NEWLINE> if a == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> + str ( i ) <STRING> + str ( a ) ) <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> sum = 1 ; <NEWLINE> for i in sys . stdin . strip ( ) : <NEWLINE> <INDENT> if i != <STRING> : <NEWLINE> <INDENT> print ( <STRING> . format ( sum , i ) ) <NEWLINE> sum += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> <NL> a = [ ] <NEWLINE> <NL> while True : <NEWLINE> <INDENT> n = input ( ) : <NEWLINE> if n == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> a . append ( n ) <NEWLINE> <NL> <DEDENT> for i in range ( len ( a ) ) : <NEWLINE> <INDENT> print ( <STRING> % ( i + 1 , a [ i ] ) ) <NEWLINE> <NL> <NL> <NL> <DEDENT>
import sys <NEWLINE> count = 1 <NEWLINE> While True : <NEWLINE> <INDENT> x = sys . stdin . readline ( ) . strip ( ) <NEWLINE> if x == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> print ( <STRING> % ( count , x ) ) <NEWLINE> count = count + 1 <NEWLINE> <DEDENT>
import sys <NEWLINE> count = 1 <NEWLINE> while True : <NEWLINE> <INDENT> x = sys . stdin . readline ( ) . strip ( ) <NEWLINE> if x == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> print ( <STRING> . format ( count , x ) ) <NEWLINE> count += 1 <NEWLINE> <DEDENT>
<COMMENT> <NL> count = 1 <NEWLINE> input = input ( ) . split ( <STRING> ) <NEWLINE> for i in input : <NEWLINE> <INDENT> print ( <STRING> % ( count , i ) ) <NEWLINE> count += 1 <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> i = 0 <NEWLINE> x = 1 <NEWLINE> <NL> while x != 0 : <NEWLINE> <INDENT> x = sys . stdin . readline ( ) <NEWLINE> i += 1 <NEWLINE> print <STRING> , % ( i , x ) <NEWLINE> <DEDENT>
i = 1 <NEWLINE> while ( a = input ( ) ) != 0 : <NEWLINE> <INDENT> print <STRING> % ( i , a ) <NEWLINE> i = i + 1 <NEWLINE> <DEDENT>
c = 1 <NEWLINE> while True : <NEWLINE> <INDENT> x = int ( input ( ) . split ( ) ) <NEWLINE> if x == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> print ( <STRING> , c , <STRING> , x , sep = <STRING> ) <NEWLINE> c += 1 <COMMENT> <NEWLINE> <DEDENT>
x = input ( ) <NEWLINE> counter = 0 <NEWLINE> while True : <NEWLINE> <INDENT> if x == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> counter = counter + 1 <NEWLINE> return ( <STRING> % ( counter , x ) ) <NEWLINE> <DEDENT> <DEDENT>
count = 1 <NEWLINE> while True : <NEWLINE> x = input ( ) . strip ( ) <NEWLINE> if x == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> print ( <STRING> % ( count , x ) ) <NEWLINE> count = count + 1 <NEWLINE>
import sys <NEWLINE> cnt = 1 <NEWLINE> while 1 : <NEWLINE> <INDENT> x = sys . stdin . readline ( ) . strip ( ) <NEWLINE> if x == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> print ( <STRING> . format ( cnt , x ) ) <NEWLINE> cnt += 1 <NEWLINE> <DEDENT>
i = int ( input ( ) ) <NEWLINE> l = 1 <NEWLINE> while i != 0 : <NEWLINE> <INDENT> print <STRING> + str ( l ) + <STRING> + str ( i ) <NEWLINE> l = l + 1 <NEWLINE> i = int ( input ( ) ) <NEWLINE> <DEDENT>
for i in range ( 10000 ) : <NEWLINE> <INDENT> print ( <STRING> . format ( i + 1 , int ( input ( ) ) ) <NEWLINE> <DEDENT>
import sys <NEWLINE> cnt = 1 <NEWLINE> num = sys . stdin . readline ( ) . strip ( ) <NEWLINE> while num != <STRING> : <NEWLINE> <INDENT> print ( <STRING> + cnt + <STRING> num ) <NEWLINE> cnt += 1 <NEWLINE> num = sys . stdin . readline ( ) . strip ( ) <NEWLINE> <DEDENT>
i = 1 <NEWLINE> while i > 0 : <NEWLINE> <INDENT> x = input ( ) <NEWLINE> print ( <STRING> , i , end = <STRING> ) <NEWLINE> print ( <STRING> , x ) <NEWLINE> if x == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT>
i = 1 <NEWLINE> <NL> while 1 : <NEWLINE> <INDENT> x = input ( ) <NEWLINE> if x == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> + i + <STRING> + x <NEWLINE> i += 1 <NEWLINE> <DEDENT> <DEDENT>
i = 0 <NEWLINE> n = ( int ) raw_input ( ) <NEWLINE> while n != 0 : <NEWLINE> <INDENT> i = i + 1 <NEWLINE> print <STRING> . format ( i , n ) <NEWLINE> n = ( int ) raw_input ( ) <NEWLINE> <DEDENT>
import warnings <NEWLINE> <NL> for i in range ( 99999999 ) : <NEWLINE> <INDENT> data = input ( ) <NEWLINE> if ( data == 0 ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> + str ( i ) + <STRING> + str ( data ) <NEWLINE> <DEDENT> <DEDENT>
sentinel = <STRING> <NEWLINE> cn = 1 <NEWLINE> for line in iter ( input , sentinel ) : <NEWLINE> <INDENT> print ( <STRING> . format ( cn , line ) ) <NEWLINE> cn = cn + 1 <NEWLINE> <DEDENT>
i = 1 <NEWLINE> x = int ( input ( ) ) <NEWLINE> while x != 0 : <NEWLINE> <INDENT> print ( <STRING> . format ( i , x ) ) <NEWLINE> x = int ( input ( ) ) <NEWLINE> i = i + <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> i = 1 <NEWLINE> while True : <NEWLINE> <INDENT> x = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> if x == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> print <STRING> % ( i , x ) <NEWLINE> i += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> main ( ) <NEWLINE>
a = input ( ) <NEWLINE> b = 1 <NEWLINE> while ( a != - 1 ) : <NEWLINE> <INDENT> print ( <STRING> + str ( b ) + <STRING> + str ( a ) ) <NEWLINE> b = b + 1 <NEWLINE> a = input ( ) <NEWLINE> <DEDENT>
i = 1 <NEWLINE> while True : <NEWLINE> <INDENT> x = int ( input ( ) ) <NEWLINE> if ( x == 0 ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> i + + <NEWLINE> <NL> <DEDENT>
i = 1 <NEWLINE> while true : <NEWLINE> <INDENT> x = int ( input ( ) ) <NEWLINE> if x == 0 : break <NEWLINE> print ( <STRING> . format ( i , x ) ) <NEWLINE> i += 1 <NEWLINE> <DEDENT>
<INDENT> while True : <NEWLINE> <INDENT> ( x , y ) = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> if x == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> if x > y : <NEWLINE> <INDENT> a = y <NEWLINE> y = x <NEWLINE> x = a <NEWLINE> <NL> <DEDENT> print ( x , y ) <NEWLINE> <DEDENT> <DEDENT>
count = 1 <NEWLINE> <NL> whie ( true ) : <NEWLINE> <INDENT> x = input ( ) . strip ( ) <NEWLINE> if x == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> print ( <STRING> % ( count , x ) ) <NEWLINE> count = count + 1 ; <NEWLINE> <DEDENT>
c = 1 <NEWLINE> while True : <NEWLINE> <INDENT> n = input ( ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> print ( <STRING> . format ( c , n ) ) <NEWLINE> c += 1 <NEWLINE> <DEDENT>
<COMMENT> <NL> <STRING> <NEWLINE> <NL> <COMMENT> <NL> i = 1 <NEWLINE> while 1 : <NEWLINE> <INDENT> n = int ( raw_input ( ) ) <NEWLINE> if ( n != 0 ) : <NEWLINE> <INDENT> print <STRING> , <STRING> , i , <STRING> , <STRING> , n <NEWLINE> i += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT>
n = 1 <NEWLINE> while True : <NEWLINE> <INDENT> if int ( input ( ) ) == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> print ( <STRING> + n + <STRING> + str ( input ( ) ) ) <NEWLINE> n += 1 <NEWLINE> <DEDENT>
i = 1 <NEWLINE> while True : <NEWLINE> <INDENT> x = int ( raw_input ( ) ) <NEWLINE> if x == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> % ( i , x ) <NEWLINE> <DEDENT> i = i + 1 <NEWLINE> <DEDENT>
while ( 1 ) : <NEWLINE> <NL> <INDENT> l = map ( int , input ( ) . split ( ) ) <COMMENT> <NEWLINE> i = 1 <NEWLINE> li = list ( l ) <NEWLINE> <NL> while ( 1 ) : <NEWLINE> <INDENT> if list [ i - 1 ] != 0 : <NEWLINE> <INDENT> print ( <STRING> + str ( i ) + <STRING> + str ( list [ i - 1 ] ) ) <NEWLINE> i = i + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
import sys <NEWLINE> i = 0 <NEWLINE> while True : <NEWLINE> <INDENT> x = sys . stdin . readline ( ) . strip ( ) <NEWLINE> if x == <STRING> : <NEWLINE> <INDENT> break ; <NEWLINE> <DEDENT> print ( <STRING> % ( i + 1 , x ) ) <NEWLINE> i += 1 <NEWLINE> <DEDENT>
import sys <NEWLINE> for i , x in map ( int , sys . stdin ) : <NEWLINE> <INDENT> if not x : break <NEWLINE> print ( <STRING> . format ( i , x ) ) <NEWLINE> <DEDENT>
c = 0 <NEWLINE> while true : <NEWLINE> <INDENT> x = int ( input ( ) ) <NEWLINE> c += 1 <NEWLINE> if x == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> print ( <STRING> . format ( c , x ) ) <NEWLINE> <DEDENT>
count = 1 <NEWLINE> <NL> while True : <NEWLINE> <INDENT> x = int ( input ( ) ) <NEWLINE> if x != 0 : <NEWLINE> <INDENT> print ( <STRING> . format ( count , x ) <NEWLINE> count += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT>
i = 1 <NEWLINE> while 1 : <NEWLINE> <INDENT> x = input ( ) . int ( ) <NEWLINE> if i > 10000 or x = 0 or ( 1 <= x <= 10000 ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> print ( <STRING> + str ( i ) + <STRING> + x ) <NEWLINE> <DEDENT>
import sys <NEWLINE> while True : <NEWLINE> <INDENT> x = sys . stdin . readline ( ) . strip ( ) <NEWLINE> if x == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> print ( <STRING> % ( i , x ) ) <NEWLINE> i += 1 <NEWLINE> <DEDENT>
a = [ ] <NEWLINE> while True : <NEWLINE> <INDENT> a = input ( ) <NEWLINE> if a == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> a . append ( input ( ) ) <NEWLINE> <DEDENT> i = 1 <NEWLINE> for num in a : <NEWLINE> <INDENT> print <STRING> . format ( i , num ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> list_line = sys . stdin . readlines ( ) <NEWLINE> <NL> list_line = list ( map ( sprit , list_line ) ) <COMMENT> <NEWLINE> <NL> counter = 1 <NEWLINE> for i in list_line : <NEWLINE> <INDENT> if i != <STRING> : <NEWLINE> <INDENT> print ( <STRING> % ( counter , i ) ) <NEWLINE> counter += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> counter = 1 <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> count = 1 <NEWLINE> while True : <NEWLINE> <INDENT> input = raw_input ( ) <NEWLINE> if input == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> text = <STRING> + <STRING> . join ( map ( str , ( count , input ) ) ) <NEWLINE> print ( text ) <NEWLINE> count += 1 <NEWLINE> <DEDENT>
a = int ( input ( ) ) <NEWLINE> i = 0 <NEWLINE> <NL> while a != 0 : <NEWLINE> <INDENT> print ( <STRING> + i + <STRING> + a ) <NEWLINE> i += 1 <NEWLINE> a = int ( input ( ) ) <NEWLINE> <DEDENT>
count = 1 <NEWLINE> while ( 1 ) : <NEWLINE> <INDENT> x = raw_input ( ) <NEWLINE> if ( x == <STRING> ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> count = str ( count ) <NEWLINE> print ( <STRING> + count + <STRING> + x ) <NEWLINE> count = int ( count ) <NEWLINE> count += 1 <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> c = 0 <NEWLINE> for line in sys . stdin : <NEWLINE> <INDENT> if int ( line ) == 0 : <NEWLINE> <INDENT> break <NEWLINE> c += 1 <NEWLINE> print <STRING> % ( c , line ) , <NEWLINE> <DEDENT> <DEDENT>
<NL> <NL> import sys <NEWLINE> for i , ws in enumerate ( sys . stdin , 1 ) : <NEWLINE> <INDENT> w = ws [ : - 1 ] <NEWLINE> if w == <STRING> : break <NEWLINE> print <STRING> % ( i , w ) <NEWLINE> <NL> <NL> <NL> <DEDENT> Compile Error Logs : <NEWLINE> <NL> You are not authorized to see the message . <NEWLINE> <NL> <NL> Status <NEWLINE>
i = 0 <NEWLINE> while True : <NEWLINE> <INDENT> i , n = input ( ) , i + 1 <NEWLINE> if n == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> print <STRING> % ( i + 1 , n ) <NEWLINE> <DEDENT>
i = 0 <NEWLINE> while True : <NEWLINE> <INDENT> i += 1 <NEWLINE> x = input ( ) <NEWLINE> if x == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> + str ( i ) + <STRING> + str ( x ) ) <NEWLINE> <DEDENT> <DEDENT>
<STRING> <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> i = 1 <NEWLINE> while True : <NEWLINE> <INDENT> x = int ( raw_input ( ) . strip ( ) ) <NEWLINE> if x == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> print <STRING> % ( i , x ) <NEWLINE> i += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
i = 0 <NEWLINE> while True : <NEWLINE> <INDENT> i += 1 <NEWLINE> num = raw_input ( ) <NEWLINE> if len ( num ) == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> print <STRING> % ( i , num ) <NEWLINE> <DEDENT>
for i in range ( 10000 ) <NEWLINE> <INDENT> line = int ( input ( ) ) <NEWLINE> if line == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> print ( <STRING> . format ( i + 1 , line ) ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> for index , line in sys . stdin : <NEWLINE> <INDENT> value = int ( line . strip ( ) ) <NEWLINE> print ( <STRING> . format ( index , value ) ) <NEWLINE> <DEDENT>
x = input ( ) <NEWLINE> i = 1 <NEWLINE> while ( x != <STRING> ) : <NEWLINE> <INDENT> print ( <STRING> . format ( i , x ) ) ; <NEWLINE> i += 1 ; <NEWLINE> <DEDENT>
import sys <NEWLINE> i = 1 <NEWLINE> while True : <NEWLINE> <INDENT> x = sys . stdin . readline ( ) . strip ( ) <NEWLINE> if x == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> print ( <STRING> % ( i , x ) ) <NEWLINE> i += 1 <NEWLINE> <DEDENT>
import sys <NEWLINE> lines = sys . stdin . readlines ( ) <NEWLINE> for i in range ( lines . length ) : <NEWLINE> <INDENT> a = int ( lines [ i ] ) <NEWLINE> if ( a == 0 ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> . format ( i + 1 , a ) ) <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> count = 1 <NEWLINE> While True : <NEWLINE> <INDENT> x = sys . stdin . readlie ( ) . atrip ( ) <NEWLINE> if x == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> print ( <STRING> % ( count , x ) ) <NEWLINE> count = count + 1 <NEWLINE> <DEDENT>
for i in input ( ) : <NEWLINE> <INDENT> print ( Case i : int ( input ( ) ) ) <NEWLINE> <DEDENT>
for i in range ( 10000 ) <NEWLINE> <INDENT> x = int ( input ( ) ) <NEWLINE> if x == 0 : break <NEWLINE> print ( <STRING> % ( i + 1 , x ) ) <NEWLINE> <DEDENT>
for i in range ( 10000 ) : <NEWLINE> <INDENT> j = ( int ) input ( ) <NEWLINE> if j == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> print ( <STRING> . format ( i , j ) ) <NEWLINE> <DEDENT>
i = 0 <NEWLINE> while True : <NEWLINE> <INDENT> x = int ( input ( ) ) <NEWLINE> if x == 0 : <NEWLINE> break <NEWLINE> <STRING> <NEWLINE> i = i + 1 <NEWLINE> <NL> <DEDENT>
i = 0 <NEWLINE> a = [ ] <NEWLINE> while True : <NEWLINE> <INDENT> x = raw_input ( ) . split ( ) <NEWLINE> print x [ 0 ] <NEWLINE> if int ( x [ 0 ] ) == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a . append ( x ) <NEWLINE> <DEDENT> <DEDENT> f = [ ] <NEWLINE> for j in range ( len ( a ) ) : <NEWLINE> <INDENT> f . append ( str ( j + 1 ) + <STRING> ) <NEWLINE> print <STRING> , <STRING> . join ( map ( str , f ) ) , <STRING> . join ( map ( str , a [ j ] ) ) <NEWLINE> <DEDENT>
a = 1 <NEWLINE> while 1 : <NEWLINE> <INDENT> i = int ( raw_input ( ) ) <NEWLINE> if i == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> % ( a , i ) <NEWLINE> a += 1 <NEWLINE> <DEDENT> <DEDENT>
ret = [ ] <NEWLINE> while True : <NEWLINE> <INDENT> n = input ( ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> ret += [ n ] <NEWLINE> <NL> <DEDENT> for i , x in enumerate ( ret ) : <NEWLINE> <INDENT> print <STRING> % ( i + 1 , x ) <NEWLINE> <DEDENT>
count = 0 <NEWLINE> <NL> while True : <NEWLINE> <INDENT> x = int ( input ( ) ) <NEWLINE> count += 1 <NEWLINE> <INDENT> if x == 0 : <NEWLINE> break <NEWLINE> <DEDENT> print ( <STRING> . format ( count , x ) ) <NEWLINE> <DEDENT>
i = 1 <NEWLINE> <NL> while true : <NEWLINE> <INDENT> x = input ( ) <NEWLINE> if x == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> print ( <STRING> + str ( i ) + <STRING> + str ( x ) ) <NEWLINE> i += 1 <NEWLINE> <DEDENT>
import sys <NEWLINE> cnt = 1 <NEWLINE> while 1 : <NEWLINE> <INDENT> x = sys . stdin . readline ( ) . strip ( ) <NEWLINE> if x == <STRING> : <NEWLINE> <INDENT> break ; <NEWLINE> <DEDENT> print ( <STRING> % ( cnt , x ) ) <NEWLINE> cnt + + <NEWLINE> <DEDENT>
i = 0 <NEWLINE> x = input ( ) <NEWLINE> while x != <STRING> : <NEWLINE> <INDENT> print ( <STRING> str ( i ) <STRING> x ) <NEWLINE> x = input ( ) <NEWLINE> i += 1 <NEWLINE> <DEDENT>
count = 1 <NEWLINE> while 1 : <NEWLINE> <INDENT> x = int ( raw_input ( ) ) <NEWLINE> if x == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> print <STRING> . format ( count += 1 , x ) <NEWLINE> <DEDENT>
c = 0 <NEWLINE> while True : <NEWLINE> <INDENT> x == int ( input ( ) ) <NEWLINE> if x == 0 : <NEWLINE> <INDENT> break ; <NEWLINE> <DEDENT> c += 1 <NEWLINE> print ( <STRING> , str ( c ) = <STRING> , x ) <NEWLINE> <DEDENT>
i = 1 <NEWLINE> while True : <NEWLINE> <INDENT> x = int ( input ) <NEWLINE> if x == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> i += 1 <NEWLINE> <DEDENT>
i = 0 <NEWLINE> while 1 : <NEWLINE> <INDENT> x = raw_input ( ) <NEWLINE> i += 1 <NEWLINE> if x == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> print <STRING> % ( i , x ) <NEWLINE> <DEDENT>
counter = 1 <NEWLINE> while true : <NEWLINE> <INDENT> x = int ( input ( ) ) <NEWLINE> if x == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> . format ( counter , x ) ) <NEWLINE> counter = counter + 1 <NEWLINE> <NL> <DEDENT> <DEDENT>
sum = 0 <NEWLINE> while 1 : <NEWLINE> <INDENT> x = raw_input ( ) <NEWLINE> sum = sum + 1 <NEWLINE> if x == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> print <STRING> % ( i , x ) <NEWLINE> <DEDENT>
x = [ ] <NEWLINE> <NL> while True : <NEWLINE> <INDENT> u = input ( ) <NEWLINE> if u is <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x . append ( int ( u ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> for i , n in enumerate ( x ) : <NEWLINE> <INDENT> print ( <STRING> . format ( i + 1 , n ) ) <NEWLINE> <NL> <DEDENT>
count = 1 <NEWLINE> count = int ( count ) <NEWLINE> while True : <NEWLINE> <INDENT> num = input ( ) <NEWLINE> if num == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> print ( <STRING> . format ( count , num ) ) <NEWLINE> count = count + 1 <NEWLINE> <DEDENT>
i = 1 <NEWLINE> while True : <NEWLINE> <INDENT> x = int ( input ( ) ) <NEWLINE> if x == 0 : <NEWLINE> <INDENT> break <NEWLINE> print ( <STRING> . format ( i , x ) ) <NEWLINE> i += 1 <NEWLINE> <NL> <DEDENT> <DEDENT>
from itertools import count <NEWLINE> <NL> for i in count ( 1 ) : <NEWLINE> <INDENT> if i == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT> <DEDENT>
cases = [ ] <NEWLINE> while True : <NEWLINE> <INDENT> n = input ( ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> cases . append ( n ) <NEWLINE> <NL> <DEDENT> length = len ( cases ) <NEWLINE> <NL> for n in range ( length ) : <NEWLINE> <INDENT> print ( <STRING> + str ( n + 1 ) + <STRING> + str ( cases [ n ] ) ) <NEWLINE> <DEDENT>
i = 0 <NEWLINE> <NL> while True : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> <INDENT> if n == 0 : break <NEWLINE> <NL> <INDENT> print ( <STRING> . format ( i , n ) ) <NEWLINE> <NL> i += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
w = <STRING> <NEWLINE> a = [ ] <NEWLINE> i = 0 <NEWLINE> while ( w != <STRING> ) : <NEWLINE> <INDENT> w = input ( ) <NEWLINE> a . append ( w ) <NEWLINE> <DEDENT> a . remove ( <STRING> ) <NEWLINE> for k in a : <NEWLINE> <INDENT> i += 1 <NEWLINE> print ( <STRING> . format ( i , k ) ) <NEWLINE> <DEDENT>
i = 1 <NEWLINE> x = input ( ) <NEWLINE> while ( x != 0 ) : <NEWLINE> <INDENT> print ( <STRING> . format ( i , x ) ) <NEWLINE> i += 1 <NEWLINE> x = input ( ) <NEWLINE> <DEDENT>
a = [ ( int ( i ) for i in input ( ) . split ( ) ) if i > 0 else break ] <NEWLINE> for i in range ( 0 , len ( a ) ) : <NEWLINE> <INDENT> print ( <STRING> , i + 1 , <STRING> , a [ i ] , sep = <STRING> ) <NEWLINE> <DEDENT>
a5 = [ ] <NEWLINE> while True : <NEWLINE> <INDENT> x = int ( input ( ) ) <NEWLINE> if x == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> a5 . append ( x ) <NEWLINE> <DEDENT> j = 0 <NEWLINE> for i in a5 : <NEWLINE> <INDENT> print ( <STRING> + j + 1 + <STRING> + i ) <NEWLINE> j = j + 1 <NEWLINE> <DEDENT>
c = 0 <NEWLINE> while True : <NEWLINE> <INDENT> a = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if a == 0 : break <NEWLINE> c += 1 <NEWLINE> print <STRING> % ( c , a ) <NEWLINE> <DEDENT>
lis = [ ] <NEWLINE> a = raw_input ( ) <NEWLINE> while a != <STRING> : <NEWLINE> <INDENT> lis . append ( a ) <NEWLINE> a = int ( raw_input ( ) ) <NEWLINE> <NL> <DEDENT> for i , v in enumerate ( lis ) : <NEWLINE> <INDENT> print <STRING> % ( i + 1 , v ) <NEWLINE> <DEDENT>
x = [ ] <NEWLINE> <NL> while true : <NEWLINE> <INDENT> a = input <NEWLINE> if a == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x . append ( a ) <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( len ( x ) ) : <NEWLINE> <INDENT> print <STRING> % ( i + 1 , x [ i ] ) <NEWLINE> <DEDENT>
nums [ ] <NEWLINE> num = input ( ) <NEWLINE> nums . append ( num ) <NEWLINE> <NL> while num != 0 : <NEWLINE> <INDENT> num = input ( ) <NEWLINE> nums . append ( num ) <NEWLINE> <NL> <DEDENT> for i in range ( len ( nums ) ) : <NEWLINE> <INDENT> print <STRING> % ( i + 1 , nums [ i ] ) <NEWLINE> <DEDENT>
for i in range ( 10000 ) : <NEWLINE> <INDENT> x = int ( input ( ) ) <NEWLINE> <INDENT> if ( x == 0 ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> print ( <STRING> , i + 1 , <STRING> , x ) <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> <NL> a = [ ] <NEWLINE> for line in sys . stdin . readlines : <NEWLINE> <INDENT> count = 0 <NEWLINE> for j in line : <NEWLINE> a . append ( j ) <NEWLINE> <INDENT> for i in a : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> + str ( count ) + <STRING> + str ( i ) ) <NEWLINE> <DEDENT> <DEDENT>
<NL> inputs = [ ] <NEWLINE> <NL> for i in range ( 10000 ) : <NEWLINE> <INDENT> inputraw = input ( ) <NEWLINE> if inputraw == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> inputs . append ( inputraw ) <NEWLINE> <NL> <DEDENT> for i , input in enumerate ( inputs ) : <NEWLINE> <INDENT> print ( <STRING> + str ( i ) + <STRING> + str ( input ) + <STRING> ) ) <NEWLINE> <DEDENT>
i = 1 <NEWLINE> while 1 : <NEWLINE> <INDENT> x = raw_input ( ) <NEWLINE> if x == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> print <STRING> % ( i , x ) <NEWLINE> i + = 1 <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <NL> <INDENT> data_set = [ ] <NEWLINE> while True : <NEWLINE> <INDENT> n = input ( ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> data_set . append ( n ) <NEWLINE> <NL> <DEDENT> case = 1 <NEWLINE> for n in data_set : <NEWLINE> <INDENT> print <STRING> % ( case , n ) <NEWLINE> case += 1 <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> <NL> check = True <NEWLINE> i = 0 <NEWLINE> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <INDENT> print ( <STRING> + str ( i ) + <STRING> + x ) <NEWLINE> <DEDENT>
c = 1 <NEWLINE> while True : <NEWLINE> <INDENT> print ( <STRING> . format ( c , input ( ) ) ) <NEWLINE> c += 1 <NEWLINE> <DEDENT>
num = 1 <NEWLINE> while True : <NEWLINE> <INDENT> x = int ( input ( ) ) <NEWLINE> if x == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else <NEWLINE> <INDENT> print ( <STRING> . format ( num , x ) ) <NEWLINE> num += 1 <NEWLINE> <DEDENT> <DEDENT>
c = 1 <NEWLINE> while True : <NEWLINE> <INDENT> if x == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> print ( <STRING> , c , <STRING> , x , sep = <STRING> ) <NEWLINE> c += 1 <NEWLINE> <NL> <DEDENT>
counter = 0 <NEWLINE> while 1 : <NEWLINE> <INDENT> i = int ( input ( ) ) <NEWLINE> if i == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> counter += 1 <NEWLINE> print ( <STRING> . format ( counter , i ) <NEWLINE> <DEDENT>
i = 1 <NEWLINE> while True : <NEWLINE> <INDENT> x = int ( input ( ) ) <NEWLINE> if x == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> print ( <STRING> . format ( i , x ) ) <NEWLINE> i += 1 <NEWLINE> <DEDENT>
with open ( <STRING> , <STRING> , encoding = <STRING> ) as input : <NEWLINE> <INDENT> s = input . readline ( ) <NEWLINE> i = 1 <NEWLINE> while True : <NEWLINE> <INDENT> print ( <STRING> . format ( i , s ) ) <NEWLINE> i += 1 <NEWLINE> s = input ( ) <NEWLINE> if s == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
a = [ ] <NEWLINE> x = 1 <NEWLINE> while True : <NEWLINE> <INDENT> n = input ( ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> a . append ( n ) <NEWLINE> x += 1 <NEWLINE> <DEDENT> print ( <STRING> , x , <STRING> , a ) <NEWLINE>
i = 1 <NEWLINE> x = input ( ) <NEWLINE> while x : <NEWLINE> <INDENT> print ( <STRING> . format ( i , x ) ) <NEWLINE> x = input ( ) <NEWLINE> i += 1 <NEWLINE> <DEDENT>
cnt = 1 <NEWLINE> while 1 : <NEWLINE> <INDENT> x = int ( raw_input ( ) ) <NEWLINE> if x == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> print <STRING> % ( cnt , x ) <NEWLINE> cnt += 1 ; <NEWLINE> <DEDENT>
import sys <NEWLINE> c = 1 <NEWLINE> for i in sys . stdin . readlines ( ) . strip ( ) : <NEWLINE> <INDENT> if i == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> + str ( c ) + <STRING> + <STRING> + str ( i ) ) <NEWLINE> c = c + 1 <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> [ x . strip ( ) for x in sys . stdin . readlines ( ) ] <NEWLINE> cnt = 1 <NEWLINE> for i in x : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> + repr ( cnt ) + <STRING> + repr ( int ( i ) ) ) <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> <DEDENT>
i = 1 <NEWLINE> while True : <NEWLINE> x = int ( input ( ) ) <NEWLINE> if x == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> . format ( i , x ) ) <NEWLINE> i += 1 <NEWLINE> <NL> <DEDENT>
count = 0 <NEWLINE> <NL> while True : <NEWLINE> <NL> <INDENT> x = raw_input ( ) <NEWLINE> <NL> count += 1 <NEWLINE> <NL> if x == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> print ( <STRING> + str ( count ) + <STRING> + x ) <NEWLINE> <DEDENT>
n = [ ] <NEWLINE> <NL> i = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> N = len [ i ] <NEWLINE>
i = 1 <NEWLINE> while True : <NEWLINE> <INDENT> x = int ( input ( ) . strip ( ) ) <NEWLINE> if x == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) . format ( i x ) <NEWLINE> i += 1 <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> cnt = 1 <NEWLINE> while 1 : <NEWLINE> <INDENT> x = sys . stdin . readline ( ) . strip ( ) <NEWLINE> if x == <STRING> : <NEWLINE> <INDENT> break ; <NEWLINE> <DEDENT> print ( <STRING> ) . format ( cnt , x ) <NEWLINE> cnt += 1 <NEWLINE> <DEDENT>
i = 0 <NEWLINE> while True : <NEWLINE> <INDENT> x = input ( ) <NEWLINE> if x == 0 : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> i += 1 <NEWLINE> print ( <STRING> % ( i , x ) ) <NEWLINE> <DEDENT>
i = 1 <NEWLINE> while True : <NEWLINE> <INDENT> n = input ( ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> print ( <STRING> . format ( i , n ) ) <NEWLINE> i += 1 <NEWLINE> <DEDENT>
for i , w in enumerate ( sys . stdin ) : <NEWLINE> <INDENT> print <STRING> % str ( i + 1 ) + w [ : - 1 ] <NEWLINE> <DEDENT>
i = 1 <NEWLINE> while 1 : <NEWLINE> <INDENT> if not ( x = int ( input ( ) ) ) : break <NEWLINE> print ( <STRING> . format ( i , x ) ) <NEWLINE> i += 1 <NEWLINE> <DEDENT>
import sys <NEWLINE> a = 1 <NEWLINE> <NL> for x in sys . stdin . readlines ( ) . strip ( ) : <NEWLINE> <INDENT> if x == <STRING> : <NEWLINE> <INDENT> break ; <NEWLINE> <DEDENT> print ( <STRING> . format ( a , x ) ) <NEWLINE> a += 1 <NEWLINE> <DEDENT>
array = [ ] <NEWLINE> x = input ( ) <NEWLINE> while x != 0 : <NEWLINE> <INDENT> array . append ( x ) <NEWLINE> x = input ( ) <NEWLINE> <DEDENT> for i , x in enumerate ( array ) : <NEWLINE> <INDENT> print ( <STRING> % ( i + 1 , x ) ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> for i in range ( 10 ** 9 ) <NEWLINE> <INDENT> print ( <STRING> + str ( i + 1 ) + <STRING> + str ( n ) ) <NEWLINE> n = int ( input ( ) ) <NEWLINE> if n == 0 : exit ( ) <NEWLINE> <DEDENT>
i = 1 <NEWLINE> while True : <NEWLINE> <INDENT> n = input ( ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> print ( <STRING> , i , <STRING> , n , sep = <STRING> ) <NEWLINE> <DEDENT>
import sys , itertools <NEWLINE> <NL> for count , input in zip ( itertools . count ( 1 ) , sys . stdin ) : <NEWLINE> <INDENT> if int ( input ) == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> print ( <STRING> . format ( count , input ) <NEWLINE> <DEDENT>
i = 1 <NEWLINE> x = int ( input ( ) ) <NEWLINE> while : <NEWLINE> <INDENT> if y == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> print ( f <STRING> ) <NEWLINE> i += 1 <NEWLINE> <NL> <DEDENT>
list = [ ] <NEWLINE> while True : <NEWLINE> <INDENT> if ( int ( input ( ) ) == 0 ) : break <NEWLINE> else : list . append ( int ( input ( ) ) ) <NEWLINE> <NL> <NL> <DEDENT> for i in len ( list ) : <NEWLINE> <INDENT> print ( <STRING> % ( i , list [ i ] ) ) <NEWLINE> <DEDENT>
<INDENT> 1 count = 1 <NEWLINE> 2 <NEWLINE> 3 while True : <NEWLINE> 4 x = int ( input ( ) ) <NEWLINE> 5 if x != 0 : <NEWLINE> 6 print ( <STRING> . format ( count , x ) ) <NEWLINE> 7 count += 1 <NEWLINE> 8 <NEWLINE> 9 else : <NEWLINE> 10 break <NEWLINE> <DEDENT>
i = 0 <NEWLINE> while 1 : <NEWLINE> <INDENT> i += 1 <NEWLINE> v = raw_input ( ) <NEWLINE> if not v : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> print ( <STRING> . format ( i , v ) ) <NEWLINE> <DEDENT>
i = 0 <NEWLINE> while True : <NEWLINE> <INDENT> i += 1 <NEWLINE> x = raw_input ( ) <NEWLINE> if x == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> print <STRING> % ( i , x ) <NEWLINE> <DEDENT>
i = 0 <NEWLINE> <NL> while 1 : <NEWLINE> <INDENT> i += 1 <NEWLINE> x = input ( ) <NEWLINE> if x == 0 : <NEWLINE> <INDENT> k = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> % ( i , x ) <NEWLINE> <DEDENT> <DEDENT>
case = [ ] <NEWLINE> i = j = 0 <NEWLINE> <NL> while True : <NEWLINE> <INDENT> num = int ( input ( ) ) <NEWLINE> if num == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> case . append ( num ) <NEWLINE> i += 1 <NEWLINE> <NL> <DEDENT> while j < i : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> print ( j + 1 , end = <STRING> ) <NEWLINE> print ( case [ j ] ) <NEWLINE> <DEDENT>
i = 1 <NEWLINE> while input ( ) != 0 : <NEWLINE> <INDENT> x = int ( input ( ) ) <NEWLINE> print ( <STRING> , format ( i , x ) ) <NEWLINE> i += 1 <NEWLINE> <DEDENT>
while 1 : <NEWLINE> <INDENT> x = int ( raw_input ( ) ) <NEWLINE> if x ~ = 0 : <NEWLINE> <INDENT> print <STRING> . format ( x ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> cnt = 1 <NEWLINE> <NL> while 1 <NEWLINE> <INDENT> num = sys . stdin . readline ( ) . strip ( ) <NEWLINE> if num == <STRING> : <NEWLINE> <INDENT> break ; <NEWLINE> <DEDENT> print ( <STRING> . format ( cnt , num ) ) <NEWLINE> cnt += 1 <NEWLINE> <DEDENT>
n = [ ] <NEWLINE> n = n . append ( int ( input ( ) ) ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if n [ i ] == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> print ( <STRING> , i + 1 , <STRING> , n [ i ] , sep = <STRING> ) <NEWLINE> <DEDENT>
count = 0 <NEWLINE> while true : <NEWLINE> <INDENT> count += 1 <NEWLINE> n = int ( input ( ) ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> print ( <STRING> + str ( count ) + <STRING> + str ( n ) ) <NEWLINE> <DEDENT>
i = 0 <NEWLINE> while ( True ) : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> print ( <STRING> % ( i + 1 , s ) ) <NEWLINE> i += 1 <NEWLINE> <DEDENT>
<NL> i = 0 <NEWLINE> while 1 : <NEWLINE> <INDENT> x = raw_input ( ) <NEWLINE> i += 1 <NEWLINE> if x == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> print ( <STRING> . format ( i , v ) ) <NEWLINE> <DEDENT>
c = 0 <NEWLINE> while True : <NEWLINE> <INDENT> x = int ( input ( ) ) <NEWLINE> if x == 0 ; <NEWLINE> <INDENT> break : <NEWLINE> <NL> <DEDENT> c += 1 <NEWLINE> print ( <STRING> , str ( c ) + <STRING> , x ) <NEWLINE> <DEDENT>
x = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> i = 0 <NEWLINE> while x [ i ] < > 0 : <NEWLINE> <INDENT> print <STRING> % ( i , x [ i ] ) <NEWLINE> i += 1 <NEWLINE> <DEDENT>
cnt = 1 <NEWLINE> c = input ( ) <NEWLINE> while c != 0 : <NEWLINE> <INDENT> print ( <STRING> + str ( cnt ) + <STRING> + c ) <NEWLINE> c = input ( ) <NEWLINE> cnt += 1 <NEWLINE> <DEDENT>
c = 1 <NEWLINE> while True : <NEWLINE> <INDENT> x = int ( input ( ) ) <NEWLINE> if x == 0 : return <NEWLINE> print ( <STRING> . format ( c , x ) ) <NEWLINE> c += 1 <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> if __name__ == <STRING> : <NEWLINE> <INDENT> i = 1 <NEWLINE> for line in sys . stdin . read ( ) . splitlines ( ) : <NEWLINE> <INDENT> if line == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> print <STRING> % ( i , line ) <NEWLINE> i += <NEWLINE> <DEDENT> <DEDENT>
a = [ ] <NEWLINE> while True : <NEWLINE> <INDENT> n = input ( ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a . append ( n ) <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( 0 , len ( a ) ) : <NEWLINE> <INDENT> print <STRING> + i + <STRING> + a [ i ] <NEWLINE> <DEDENT>
a = [ ] <NEWLINE> count = 0 <NEWLINE> while True : <NEWLINE> <INDENT> count += 1 <NEWLINE> n = input ( ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> print ( <STRING> + str ( count ) + <STRING> + n ) <NEWLINE> <DEDENT>
num = 1 <NEWLINE> for i in int ( input ( ) ) : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> print ( <STRING> . format ( num , i ) ) <NEWLINE> num += 1 <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> i = 0 <NEWLINE> while True : <NEWLINE> <INDENT> i += 1 <NEWLINE> x = input ( ) <NEWLINE> if x == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> print <STRING> , i , <STRING> , x <NEWLINE> <DEDENT>
import sys <NEWLINE> a = 1 <NEWLINE> for b in sys . stdin : b = b . strip ( ) <NEWLINE> <INDENT> if b == <STRING> : break <NEWLINE> print ( <STRING> ) <NEWLINE> a += 1 <NEWLINE> <DEDENT>
<NL> num = 1 <NEWLINE> <NL> While True : <NEWLINE> <INDENT> x = int ( input ( ) ) <NEWLINE> if x == 0 : break <NEWLINE> print ( <STRING> . format ( num , x ) ) <NEWLINE> num += 1 <NEWLINE> <DEDENT>
a = [ ] <NEWLINE> while True : <NEWLINE> <INDENT> n = input ( ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> a . append ( n ) <NEWLINE> <DEDENT> for i in range ( len ( a ) ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a = 1 <NEWLINE> while 1 : <NEWLINE> <INDENT> x = int ( raw_input ( ) ) <NEWLINE> if x == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> print <STRING> % ( a , x ) <NEWLINE> cnt += 1 ; <NEWLINE> <DEDENT>
i = 1 <NEWLINE> while true : <NEWLINE> <INDENT> x = int ( input ( ) ) <NEWLINE> if x == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> print ( <STRING> % ( i , x ) ) <NEWLINE> i += 1 <NEWLINE> <DEDENT>
n = 10 <NEWLINE> i = 1 <NEWLINE> while n != 0 : <NEWLINE> <INDENT> n = raw_input ( ) <NEWLINE> i = i + 1 <NEWLINE> print <STRING> + str ( i ) + <STRING> + str ( n ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> input ( <STRING> ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> import sys <NEWLINE> <NL> i = 0 <NEWLINE> for line in sys . stdin : <NEWLINE> <INDENT> if line [ 0 ] == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> i += 1 <NEWLINE> print <STRING> % ( i , line ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> import sys <NEWLINE> <NL> i = 1 <NEWLINE> while True : <NEWLINE> <INDENT> a = int ( raw_input ( ) ) <NEWLINE> if a == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> print <STRING> % ( i , a ) <NEWLINE> i += 1 <NEWLINE> <DEDENT>
sum = 0 <NEWLINE> while 1 : <NEWLINE> <INDENT> x = raw_input <NEWLINE> sum += 1 <NEWLINE> if x == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> print <STRING> % ( sum , x ) <NEWLINE> <NL> <DEDENT>
i = 0 <NEWLINE> While True : <NEWLINE> <INDENT> x = int ( input ( ) ) <NEWLINE> if x == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> i += 1 <NEWLINE> print ( <STRING> . format ( i , x ) ) <NEWLINE> <DEDENT> <DEDENT>
while 1 : <NEWLINE> <INDENT> i = 1 <NEWLINE> j = int ( input ) <NEWLINE> if j == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> print ( <STRING> , str ( i ) + <STRING> , j ) <NEWLINE> i += 1 <NEWLINE> <DEDENT>
i = 1 <NEWLINE> <NL> x = int ( input ( ) ) <NEWLINE> if x == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> print ( <STRING> . format ( i , x ) ) <NEWLINE> i += 1 <NEWLINE>
v = int ( raw_input ( ) ) <NEWLINE> i = 1 <NEWLINE> while v != 0 : <NEWLINE> <INDENT> print ( <STRING> + str ( i ) + <STRING> + str ( v ) ) <NEWLINE> <DEDENT>
input = - 1 <NEWLINE> cnt = 1 <NEWLINE> output = [ ] <NEWLINE> while input != 0 : <NEWLINE> <INDENT> input = input ( ) <NEWLINE> if input == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> output += <STRING> + cnt + <STRING> + input <NEWLINE> <NL> <DEDENT> for x in output : <NEWLINE> <INDENT> print ( x ) <NEWLINE> <DEDENT>
i = 1 <NEWLINE> while True : <NEWLINE> <INDENT> n = input ( ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> print <STRING> % ( i , n ) <NEWLINE> i += 1 <NEWLINE> <DEDENT>
count = 0 <NEWLINE> while true : <NEWLINE> <INDENT> count += 1 <NEWLINE> a = int ( input ( ) ) <NEWLINE> if a == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> print ( <STRING> . format ( count , a ) ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> x = int ( input ( ) ) <NEWLINE> if x == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> . format ( i , x ) ) <NEWLINE> <DEDENT> <DEDENT>
i = 1 <NEWLINE> while True : <NEWLINE> <INDENT> a = input ( ) <NEWLINE> if a == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> + str ( i ) + <STRING> + a ) <NEWLINE> i += 1 <NEWLINE> <DEDENT> <DEDENT>
j = 0 <NEWLINE> While ( True ) : <NEWLINE> <INDENT> temp = raw_input ( ) <NEWLINE> i = int ( temp ) <NEWLINE> j += 1 <NEWLINE> if i != 0 : <NEWLINE> <INDENT> print ( <STRING> + str ( j ) + <STRING> + str ( i ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT>
while True : <NEWLINE> <INDENT> x , y = sorted ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if ( x == 0 ) and ( y == 0 ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> print ( * a ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> input = input ( ) <NEWLINE> a , b = map ( int , input . split ( ) ) <NEWLINE> if ( a == b ) : <NEWLINE> <INDENT> if ( a == 0 ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> if ( a < b ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT>
dataset = [ ] <NEWLINE> while True : <NEWLINE> <INDENT> x = int ( input ( ) ) <NEWLINE> if not ( x >= 1 and x <= 10000 ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> elif len ( dataset ) >= 10000 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> elif x is not 0 : <NEWLINE> <INDENT> dataset . append ( x ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> for index , number in enumerate ( dataset ) : <NEWLINE> <INDENT> print ( <STRING> . format ( index + 1 , str ( number ) ) ) <NEWLINE> <DEDENT>
while 1 : <NEWLINE> <INDENT> x = input ( ) <NEWLINE> y = input ( ) <NEWLINE> if x == 0 and y == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if x < y : <NEWLINE> <INDENT> print x y <NEWLINE> <DEDENT> if x > y : <NEWLINE> <INDENT> print y x <NEWLINE> <DEDENT> <DEDENT>
x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> while True <NEWLINE> <INDENT> if x == 0 and y == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> elif x < y : <NEWLINE> <INDENT> print ( x , y ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( y , x ) <NEWLINE> <NL> <DEDENT> <DEDENT>
x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> while ( x != 0 & & y != 0 ) : <NEWLINE> <INDENT> if x <= y : <NEWLINE> <INDENT> print ( x , y ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( y , x ) <NEWLINE> <NL> <DEDENT> x = int ( input ( ) ) <NEWLINE> y = int ( input ( ) ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> if x == 0 and y == 0 : <NEWLINE> break <NEWLINE> <DEDENT> if x > y : <NEWLINE> <INDENT> print ( y , x ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( x , y ) <NEWLINE> <DEDENT>
while 1 : <NEWLINE> <INDENT> x , y = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> <INDENT> if x == 0 and y == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if x > y : <NEWLINE> <INDENT> print <STRING> % ( y , x ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> % ( x , y ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT>
def Hantei ( a , b ) : <NEWLINE> <INDENT> if a <= b : <NEWLINE> <INDENT> print ( <STRING> . format ( a , b ) ) <NEWLINE> <DEDENT> elif a > b : <NEWLINE> <INDENT> print ( <STRING> . format ( b , a ) ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> while True : <NEWLINE> <INDENT> a , b = input ( ) . split ( ) <NEWLINE> if ( a == 0 ) and ( b == 0 ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> Hantei ( int ( a ) , int ( b ) ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> for i in sys . stdin : <NEWLINE> <INDENT> i = i . split ( <STRING> ) <NEWLINE> x , y = int ( i [ 0 ] ) , int ( i [ 1 ] ) <NEWLINE> if x == y == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> elif x <= y : <NEWLINE> <INDENT> print ( <STRING> . format ( x , y ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> pritn ( <STRING> . format ( y , x ) ) <NEWLINE> <DEDENT> <DEDENT>
<NL> while True : <NEWLINE> <NL> <INDENT> x , y = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> <NL> if x == 0 and y == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> elif x > y : <NEWLINE> <INDENT> print ( x + <STRING> + y ) <NEWLINE> <NL> <DEDENT> elif x < y or x == y : <NEWLINE> <INDENT> print ( y + <STRING> + x ) <NEWLINE> <DEDENT> <DEDENT>
for i in range ( 3001 ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if a <= b : <NEWLINE> <INDENT> print ( a , b ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( b , a ) <NEWLINE> <DEDENT> <DEDENT>
num = input ( ) . split ( <STRING> ) <NEWLINE> x = num [ 0 ] <NEWLINE> y = num [ 1 ] <NEWLINE> <NL> if x > y : <NEWLINE> <INDENT> tmp = x <NEWLINE> x = y <NEWLINE> y = tmp <NEWLINE> <NL> <DEDENT> elif x = y = 0 : <NEWLINE> <INDENT> exit ( ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> print ( x + <STRING> + y ) <NEWLINE>
while True <NEWLINE> <INDENT> a , b = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if a == 0 and b == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if a < b : <NEWLINE> <INDENT> print <STRING> % ( b , a ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> % ( a , b ) <NEWLINE> <DEDENT> <DEDENT>
repetition = True <NEWLINE> while repetition == True : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> if a > b : <NEWLINE> <INDENT> a , b = b , a <NEWLINE> <DEDENT> print ( <STRING> % ( a , b ) ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> i = input ( ) <NEWLINE> if i == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> i . sort ( ) <NEWLINE> print ( i ) <NEWLINE> <DEDENT> <DEDENT>
while True : <NEWLINE> <INDENT> x , y = sorted ( [ int ( x ) for x in input ( ) . split ] ) <NEWLINE> if x == 0 and y == 0 : break <NEWLINE> print ( x , y ) <NEWLINE> <NL> <DEDENT>
while True : <NEWLINE> <INDENT> ( x , y ) = ( int ( i ) for i in input ( ) . split ( ) ) <NEWLINE> if x = 0 and y = 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> elif x <= y : <NEWLINE> <INDENT> print ( x , y ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( y , x ) <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> for c in sys . stdin : <NEWLINE> <INDENT> a , b = sorted ( map ( int , c . split ( ) ) ) <NEWLINE> if a = b == 0 : break <NEWLINE> print ( a , b ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> for i , ws in enumerate ( sys . stdin , 1 ) : <NEWLINE> <INDENT> list = map ( int , ws [ : - 1 ] . split ( ) ) <NEWLINE> <NL> if list [ 0 ] == 0 and list [ 1 ] == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> print ( <STRING> . join ( map ( str , list . sort ( ) ) ) ) <NEWLINE> <DEDENT>
( x , y ) = [ int ( i ) for i in input ( ) . rstrip ( ) . split ( <STRING> ) ] <NEWLINE> <NL> while True : <NEWLINE> <INDENT> if x == 0 and y == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> print ( <STRING> . format ( x , y ) ) <NEWLINE> <DEDENT>
while ( 1 ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) _split ( ) ) <NEWLINE> if x == 0 and y == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> print <STRING> % ( min ( x , y ) , max ( x , y ) ) <NEWLINE> <DEDENT>
while 1 : <NEWLINE> <INDENT> x , y = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if x and y == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if x <= y : <NEWLINE> <INDENT> print <STRING> % ( x , y ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> % ( y , x ) <NEWLINE> <DEDENT> <DEDENT>
list = [ ] <NEWLINE> while True : <NEWLINE> <INDENT> num = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if ( num [ 0 ] == 0 and num [ 1 ] == 0 ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if ( num [ 0 ] > num [ 1 ] ) : <NEWLINE> <INDENT> print ( <STRING> % ( num [ 1 ] , num [ 0 ] ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> % ( num [ 0 ] , num [ 1 ] ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT>
while True : <NEWLINE> <INDENT> a = input <NEWLINE> x , y = map ( int , a . split ( ) ) <NEWLINE> if x * y == 0 : break <NEWLINE> if x > y : print ( <STRING> ) <NEWLINE> else : print ( a ) <NEWLINE> <DEDENT>
import sys <NEWLINE> for i in sys . stdin . readlines ( ) : <NEWLINE> <INDENT> l = i . split ( ) <NEWLINE> a = l [ 0 ] <NEWLINE> b = l [ 1 ] <NEWLINE> if a == 0 and b == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> elif a > b <NEWLINE> <INDENT> print ( b , a ) <NEWLINE> <DEDENT> else <NEWLINE> <INDENT> print ( a , b ) <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> while 1 : <NEWLINE> <INDENT> a , b = sys . stdin . readline ( ) . split ( ) <NEWLINE> if a == 0 and b == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if a < b : print ( a , b ) <NEWLINE> else : print ( b , a ) <NEWLINE> <DEDENT>
a , b = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> <NL> if a >= b : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> else <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> while 1 : <NEWLINE> <INDENT> a , b = map ( int , sys . stdin . readline ( ) . split ( ) ) <NEWLINE> if a == b == 0 : <NEWLINE> break <NEWLINE> <DEDENT>
import sys <NEWLINE> while True : <NEWLINE> <INDENT> x , y = sys . stdin . readline ( ) . split ( ) <NEWLINE> if x == 0 and y == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> if x > y : <NEWLINE> <INDENT> print ( y , x ) <NEWLINE> <DEDENT> print ( x , y ) <NEWLINE> <DEDENT>
a = [ ] <NEWLINE> while 1 : <NEWLINE> <INDENT> n = input ( ) <NEWLINE> if n == <STRING> : break <NEWLINE> x , y = map ( int , n . split ( ) ) <NEWLINE> print ( y , x ) if x > y else : print ( n ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> if x == 0 and y == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if x >= y : <NEWLINE> <INDENT> print <STRING> % ( y , x ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> % ( x , y ) <NEWLINE> <DEDENT> <DEDENT>
while True : <NEWLINE> <INDENT> a , b = sort ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if ( a == 0 ) and ( b == 0 ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> print ( a , b ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> case = input ( ) . split ( ) <NEWLINE> int ( case [ 0 ] ) <NEWLINE> int ( case [ 1 ] ) <NEWLINE> <NL> if case [ 0 ] == 0 and case [ 1 ] == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> case . sort ( ) <NEWLINE> print ( case [ 0 ] , case [ 1 ] ) <NEWLINE> <DEDENT> <DEDENT>
while True : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if a < b : <NEWLINE> <INDENT> print ( a , b ) <NEWLINE> <DEDENT> elif b <= a : <NEWLINE> <INDENT> print ( b , a ) <NEWLINE> <DEDENT> elif a == 0 and b == 0 : <NEWLINE> <INDENT> print ( a , b ) <NEWLINE> break ; <NEWLINE> <DEDENT> <DEDENT>
<NL> while True : <NEWLINE> <INDENT> x , y = raw_input ( ) . split ( ) <NEWLINE> <COMMENT> <NL> if x == 0 and y == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if x > y : <NEWLINE> <INDENT> x , y = map ( str , ( x , y ) ) <NEWLINE> print x + <STRING> + y <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x , y = map ( str , ( x , y ) ) <NEWLINE> print y + <STRING> + x <NEWLINE> <DEDENT> <DEDENT>
while true : <NEWLINE> <NL> <INDENT> ary = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if ary [ 0 ] + ary [ 1 ] == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> ary . sort ( ) <NEWLINE> <NL> print ( ary [ 0 ] , ary [ 1 ] ) <NEWLINE> <NL> <NL> <NL> <NL> <DEDENT>
list = [ ] <NEWLINE> while True : <NEWLINE> <INDENT> line = raw_input ( ) . split ( <STRING> ) <NEWLINE> if line [ 0 ] == 0 and line [ 1 ] == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> line = map ( int , line ) <NEWLINE> <COMMENT> <NL> if line [ 0 ] > line [ 1 ] : <NEWLINE> <INDENT> temp = line [ 0 ] <NEWLINE> line [ 0 ] = line [ 1 ] <NEWLINE> line [ 1 ] = temp <NEWLINE> <DEDENT> print <STRING> . join ( map ( str , line ) ) <NEWLINE> <DEDENT>
( a , b , c ) = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> cnt = 0 <NEWLINE> for i in range ( a , b + 1 ) : <NEWLINE> <INDENT> if ( c % i ) == 0 : <NEWLINE> <INDENT> cnt = cnt + 1 <NEWLINE> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
for i in range ( 3000 ) : <NEWLINE> <INDENT> x , y = [ int ( s ) for s in input ( ) . split ( ) ] <NEWLINE> if x > y : <NEWLINE> <INDENT> print ( <STRING> . format ( y , x ) ) <NEWLINE> <DEDENT> elif x <= y : <NEWLINE> <INDENT> print ( <STRING> . format ( x , y ) ) <NEWLINE> <DEDENT> elif x == 0 and y == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT>
a = input ( ) . split ( ) <NEWLINE> b = int ( a [ 0 ] ) <NEWLINE> c = int ( a [ 1 ] ) <NEWLINE> a . sort ( [ 0 ] , [ 1 ] ) <NEWLINE> if c == 0 : <NEWLINE> <INDENT> print ( b [ 0 ] , c [ 0 ] ) <NEWLINE> <DEDENT>
While True : <NEWLINE> <INDENT> a = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if a == [ 0 , 0 ] : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if a [ 0 ] > a [ 1 ] : print ( str ( a [ 1 ] ) + <STRING> + str ( a [ 0 ] ) ) <NEWLINE> else : print ( str ( a [ 0 ] ) + <STRING> + str ( a [ 1 ] ) ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ) <NEWLINE> if ( x , y ) == ( 0 , 0 ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if x < y : <NEWLINE> <INDENT> print ( x , y ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( y , x ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT>
a = [ ] <NEWLINE> while 1 : <NEWLINE> <INDENT> n = input ( ) <NEWLINE> if n == <STRING> : break <NEWLINE> a . append ( n ) <NEWLINE> <DEDENT> for s in a : <NEWLINE> <INDENT> print ( * sorted ( map ( int , a . split ( ) ) ) ) <NEWLINE> <DEDENT>
a = [ ] <NEWLINE> import sys <NEWLINE> for s . strip ( ) in sys . stdin : <NEWLINE> <INDENT> if s == <STRING> : break <NEWLINE> a . append ( s ) <NEWLINE> <DEDENT> for t in a : <NEWLINE> <INDENT> x , y = map ( int , t . split ( ) ) <NEWLINE> print ( <STRING> ) if x > y else print ( t ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> x = input ( ) . split <NEWLINE> y = [ int ( x [ 0 ] ) , int ( x [ 1 ] ) ] <NEWLINE> if y [ 0 ] == 0 and y [ 1 ] == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> elif y [ 0 ] < y [ 1 ] : <NEWLINE> <INDENT> print ( <STRING> . format ( y [ 0 ] , y [ 1 ] ) ) <NEWLINE> <DEDENT> elif y [ 0 ] > y [ 1 ] : <NEWLINE> <INDENT> print ( <STRING> . format ( y [ 1 ] , y [ 0 ] ) ) <NEWLINE> <DEDENT> <DEDENT>
x = [ ] <NEWLINE> while True : <NEWLINE> <INDENT> x = input ( ) . split ( ) <NEWLINE> x . sort ( ) <NEWLINE> a , b = map ( int , x ) <NEWLINE> print ( a , b ) <NEWLINE> if a == None , b == None : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT>
while True : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> if x > y : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif x <= y : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif x == 0 and y == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT>
while 1 : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if ( a == 0 and b == 0 ) : break <NEWLINE> print ( sorted [ a , b ] ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> if x == 0 and y == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> elif x <= y : <NEWLINE> <INDENT> print ( x , y ) <NEWLINE> <DEDENT> else x > y : <NEWLINE> <INDENT> print ( y , x ) <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> <NL> for line in sys . stdin : <NEWLINE> <INDENT> a , b = int ( line . split ( ) ) <NEWLINE> if ( a <= b ) <NEWLINE> <INDENT> print ( a , b ) <NEWLINE> <DEDENT> else <NEWLINE> <INDENT> print ( b , a ) <NEWLINE> <DEDENT> <DEDENT>
while True : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if x < y : <NEWLINE> <INDENT> print ( x , y ) <NEWLINE> <NL> <DEDENT> elif y < x : <NEWLINE> <INDENT> print ( y , x ) <NEWLINE> <NL> <DEDENT> elif x and y != 0 : <NEWLINE> <INDENT> print ( x , y ) <NEWLINE> <NL> <DEDENT> <DEDENT>
import sys <NEWLINE> ff = sys . stdin <NEWLINE> while True : <NEWLINE> <INDENT> a , b = map ( int , ff . readline ( ) . split ( ) ) <NEWLINE> if ( a == 0 ) and ( b == 0 ) : <NEWLINE> break <NEWLINE> <INDENT> if a < b : print ( a , b ) <NEWLINE> else : print ( b , a ) <NEWLINE> <DEDENT> <DEDENT>
while True : <NEWLINE> <INDENT> x = list ( int ( i ) for i in input ( ) . split ( ) ) <NEWLINE> x . sort ( ) <NEWLINE> print ( x [ 0 ] , x [ 1 ] , sep = <STRING> ) <NEWLINE> <DEDENT>
for i in range ( 0 , 3000 ) : <NEWLINE> <INDENT> array = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> print ( array ) <NEWLINE> if array [ 0 ] == 0 and array [ 1 ] == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> . join ( map ( str , sorted ( array ) ) ) ) <NEWLINE> <DEDENT> <DEDENT>
while True : <NEWLINE> <INDENT> a , b = input ( ) . split ( ) <NEWLINE> if a == 0 and b == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if int ( a ) > int ( b ) : <NEWLINE> <INDENT> print ( b + <STRING> + a ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( a + <STRING> + b ) <NEWLINE> <DEDENT> <DEDENT>
a = [ ] <NEWLINE> import sys <NEWLINE> for s in sys . stdin : <NEWLINE> <INDENT> s = s . strip ( ) <NEWLINE> if s == <STRING> : break <NEWLINE> a . append ( s ) <NEWLINE> <DEDENT> for t in a : <NEWLINE> <INDENT> print ( * sorted ( map ( int , t ) ) ) <NEWLINE> <DEDENT>
while 1 : <NEWLINE> <INDENT> if x == 0 and y == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if x > y : <NEWLINE> <INDENT> temp = x <NEWLINE> x = y <NEWLINE> y = temp <NEWLINE> <DEDENT> <DEDENT> print <STRING> . format ( x , y ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> while 1 : <NEWLINE> <INDENT> str = sys . stdin . readline ( ) . strip ( ) <NEWLINE> if str == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> print ( map ( int , str . split ( <STRING> ) ) . sort ) <NEWLINE> <DEDENT>
ans = [ ] <NEWLINE> while True : <NEWLINE> <INDENT> arr = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if arr [ 0 ] == 0 and arr [ 1 ] == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> arr . sort ( ) <NEWLINE> ans . append ( arr ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> <NL> for x in ans : <NEWLINE> <INDENT> print ( <STRING> . join ( map ( str , x ) ) ) <NEWLINE> <DEDENT>
for i in range ( 3000 ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if a == b == 0 <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> if a < b : <NEWLINE> <INDENT> print ( a , b ) <NEWLINE> <DEDENT> else <NEWLINE> <INDENT> print ( b , a ) <NEWLINE> <NL> <NL> <NL> <DEDENT> <DEDENT>
import sys <NEWLINE> <NL> while True : <NEWLINE> <INDENT> a , b = map ( int , sys . stdin . readline ( ) ) <NEWLINE> if ( a == 0 ) & ( b == 0 ) : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> if a < b : print ( a , b ) <NEWLINE> else : print ( b , a ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> x , y = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if ( x == y == 0 ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> elif ( x > y ) : <NEWLINE> <INDENT> print x y <NEWLINE> <DEDENT> elif ( x <= y ) : <NEWLINE> <INDENT> print y x <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> <NL> n = sys . stdin . readlines ( ) <NEWLINE> for i in n : <NEWLINE> <INDENT> a , b = [ int ( x ) for x in i . split ( ) ] <NEWLINE> if a == 0 and b == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if a > b : <NEWLINE> <INDENT> print ( a + <STRING> + b ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( b + <STRING> + a ) <NEWLINE> <DEDENT> <DEDENT>
while 1 : <NEWLINE> <INDENT> a , b = sorted ( map ( int , raw_input ( ) . split ( ) ) ) <NEWLINE> if a + b = 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print a , b <NEWLINE> <DEDENT> <DEDENT>
list = [ ] <NEWLINE> while list [ 0 ] != 0 or list [ 1 ] != 0 : <NEWLINE> <INDENT> list = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> print ( <STRING> . join ( map ( str , sorted ( list ) ) ) ) <NEWLINE> <NL> <NL> <DEDENT>
while True : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if a == 0 and b == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if a <= b : <NEWLINE> print ( a , b ) <NEWLINE> else : <NEWLINE> <INDENT> a , b = b , a <NEWLINE> print ( a , b ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> for i in range ( 0 , 10001 ) : <NEWLINE> <INDENT> if x == 0 & & y == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if x > y : <NEWLINE> <INDENT> temp = int ( x ) <NEWLINE> x = y <NEWLINE> y = temp <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT>
count = 1 <NEWLINE> <NL> while True : <NEWLINE> <INDENT> a , b = int ( input ( ) ) <NEWLINE> <NL> if a != 0 and b != 0 and a < b : <NEWLINE> <INDENT> a , b = a , b <NEWLINE> <NL> <DEDENT> if a != 0 and b != 0 and b < a : <NEWLINE> <INDENT> a , b = b , a <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> for i in sys . stdin . readlines ( ) : <NEWLINE> <INDENT> l = list ( int , i . split ( <STRING> ) ) <NEWLINE> a = l [ 0 ] <NEWLINE> b = l [ 1 ] <NEWLINE> if a == 0 and b == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> sorted ( l ) <NEWLINE> print ( l [ 0 ] , l [ 1 ] ) <NEWLINE> <DEDENT> <DEDENT>
a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if a < b < c : <NEWLINE> <INDENT> result = <STRING> <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> result = <STRING> <NEWLINE> <NL> <DEDENT> print ( result ) <NEWLINE> <NL>
x , y = input ( ) . split ( ) <NEWLINE> x = int ( x ) <NEWLINE> y = int ( y ) <NEWLINE> i = 0 <NEWLINE> if x == 0 asd y == 0 : <NEWLINE> <INDENT> if x > y : <NEWLINE> <INDENT> i = x <NEWLINE> x = y <NEWLINE> y = i <NEWLINE> <NL> <DEDENT> fmt = <STRING> <NEWLINE> s = fmt . format ( a = x , b = y ) <NEWLINE> print ( s ) <NEWLINE> <DEDENT>
for i in range ( 3000 ) : <NEWLINE> <INDENT> a = input ( ) . split ( ) <NEWLINE> x = int ( a [ 0 ] ) <NEWLINE> y = int ( a [ 1 ] ) <NEWLINE> if x == y : <NEWLINE> <INDENT> print ( x , y ) <NEWLINE> <DEDENT> elif x < y : <NEWLINE> <INDENT> print ( x , y ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( y , x ) <NEWLINE> <NL> <DEDENT> <DEDENT>
num = [ ] <NEWLINE> while True : <NEWLINE> <INDENT> n = input ( ) <NEWLINE> a , b = [ int ( x ) for x in n . split ( ) ] <NEWLINE> if a == 0 and b == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> num . append ( [ a , b ] ) <NEWLINE> <NL> <DEDENT> for ls in num : <NEWLINE> <INDENT> ls . sort ( ) <NEWLINE> print ( <STRING> . format ( ls [ 0 ] , ls [ 1 ] ) <NEWLINE> <DEDENT>
while 1 : <NEWLINE> <INDENT> x , y = map ( int , raw_input ( ) . split ) <NEWLINE> if x == 0 and y == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> min = min ( x , y ) <NEWLINE> max = max ( x , y ) <NEWLINE> print <STRING> , % ( min , max ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> x = [ a , b ] <NEWLINE> if a = 0 and b = 0 : break <NEWLINE> x . sort ( ) <NEWLINE> print ( x [ 0 ] , x [ 1 ] ) <NEWLINE> <NL> <DEDENT>
while True : <NEWLINE> <INDENT> [ x , y ] = map ( int , input ( ) . split ( ) ) <NEWLINE> if x == y == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> print ( min ( x , y ) max ( x , y ) ) <NEWLINE> <DEDENT>
while True <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ) <NEWLINE> if ( x , y ) == ( 0 , 0 ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if x < y : <NEWLINE> <INDENT> print ( x , y ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( y , x ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
while True : <NEWLINE> <INDENT> a , b = sorted ( [ int ( x ) for x in input ( ) . split ] ) <NEWLINE> if a == 0 and b == 0 : break <NEWLINE> print ( a , b ) <NEWLINE> <DEDENT>
int main ( ) { <NEWLINE> int a , b ; <NEWLINE> while ( true ) { <NEWLINE> scanf ( <STRING> , & a , & b ) ; <NEWLINE> if ( ( a == 0 ) & & ( b == 0 ) ) break ; <NEWLINE> if ( a <= b ) printf ( <STRING> , a , b ) ; <NEWLINE> if ( a > b ) printf ( <STRING> , b , a ) ; <NEWLINE> } <NEWLINE> return 0 ; <NEWLINE> } <NEWLINE>
for True : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> if x + y == 0 : break <NEWLINE> if x > y : x , y = y , x <NEWLINE> print ( x , y ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> if ( x + y == 0 ) : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> if ( x > y ) :  <NEWLINE> <INDENT> print ( y , x ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( x , y ) <NEWLINE> <DEDENT> <DEDENT>
for i in range ( 3000 ) : <NEWLINE> <INDENT> string = input ( ) <NEWLINE> numbers = string . split ( <STRING> ) <NEWLINE> x , y = numbers <NEWLINE> if x = 0 and y = 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> elif x < y : <NEWLINE> <INDENT> print ( x , y ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( y , x ) <NEWLINE> <DEDENT> <DEDENT>
list1 = [ ] <NEWLINE> while True : <NEWLINE> <INDENT> x = str ( input ( <STRING> ) ) <NEWLINE> if x == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> list1 . append ( x ) <NEWLINE> <NL> <DEDENT> <DEDENT> for i , v in enumerate ( list1 ) : <NEWLINE> <INDENT> x , y = map ( int , v . split ( ) ) <NEWLINE> if x < y : <NEWLINE> <INDENT> print ( str ( x ) + <STRING> + str ( y ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( str ( y ) + <STRING> + str ( x ) ) <NEWLINE> <DEDENT> <DEDENT>
i = j = x = y = 0 <NEWLINE> <NL> while i >= 0 : <NEWLINE> <INDENT> line = input ( ) <NEWLINE> while line [ j ] != <STRING> : <NEWLINE> <INDENT> x = x + line [ j ] <NEWLINE> j += 1 <NEWLINE> <DEDENT> while j < len ( line ) : <NEWLINE> <INDENT> y = y + line [ j ] <NEWLINE> j += 1 <NEWLINE> <NL> <DEDENT> x = int ( x ) <NEWLINE> y = int ( y ) <NEWLINE> <NL> if x == 0 and y == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> if x >= y : <NEWLINE> <INDENT> print ( y , end = <STRING> ) <NEWLINE> print ( x ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> print ( x , end = <STRING> ) <NEWLINE> print ( y ) <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> for xy in sys . stdin : <NEWLINE> <INDENT> x , y = xy . split ( ) <NEWLINE> i if x == <STRING> and y == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> elif int ( x ) > int ( y ) : <NEWLINE> <INDENT> x , y = y , x <NEWLINE> <DEDENT> print ( <STRING> % ( x , y ) ) <NEWLINE> <DEDENT>
while 1 : <NEWLINE> <INDENT> x , y = map ( int , raw_input ( ) . split ( ) ) . sort ( ) <NEWLINE> if y == 0 : break <NEWLINE> print x , y <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> x , y = map ( int , raw_input . split ( ) ) <NEWLINE> if x == 0 and y == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> elif x < y : <NEWLINE> <INDENT> print <STRING> % ( x , y ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> % ( y , x ) <NEWLINE> <DEDENT> <DEDENT>
cnt = 1 <NEWLINE> output = [ ] <NEWLINE> while True : <NEWLINE> <INDENT> data += input ( ) . split ( ) <NEWLINE> if data [ 0 ] == 0 and data [ 1 ] == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> output += [ str ( data [ 1 ] ) + <STRING> + str ( data [ 0 ] ) ] <NEWLINE> <NL> <DEDENT> for line in output : <NEWLINE> <INDENT> print ( line ) <NEWLINE> <DEDENT>
import sys <NEWLINE> def number ( ) : <NEWLINE> <INDENT> while True : <NEWLINE> <INDENT> a , b = map ( int ( input ( ) . split ( ) ) ) <NEWLINE> if a == 0 and b == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if a < b : <NEWLINE> <INDENT> print ( a , b ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( b , a ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> number ( ) <NEWLINE> <DEDENT>
<NL> import sys <NEWLINE> while True : <NEWLINE> <INDENT> x , y = map ( int , sys . stdin . inputline ( ) . split ( ) ) <NEWLINE> if x == 0 & y == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if x <= y : <NEWLINE> <INDENT> print ( x , y ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( y , x ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
while True : <NEWLINE> <INDENT> line = input ( ) . split ( ) <NEWLINE> if line == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if int ( line [ 0 ] ) < int ( line [ 1 ] ) : <NEWLINE> <INDENT> print ( <STRING> . format ( line [ 0 ] , line [ 1 ] ) ) <NEWLINE> <DEDENT> else : print ( <STRING> . format ( line [ 1 ] , line [ 0 ] ) ) <NEWLINE> <DEDENT>
<NL> while True : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if a , b == 0 , 0 : break <NEWLINE> if a > b : a , b = b , a <NEWLINE> print ( <STRING> ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> x , y = sorted ( map ( raw_input ( ) . split ( ) ) ) <NEWLINE> if x == y == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> print x , y <NEWLINE> <DEDENT>
S = raw_input ( ) . split ( <STRING> ) <NEWLINE> S [ 0 ] = int ( S [ 0 ] ) <NEWLINE> S [ 1 ] = int ( S [ 1 ] ) <NEWLINE> <NL> while S [ 0 ] != 0 or S [ 1 ] != 0 : <NEWLINE> <INDENT> if ( S [ 0 ] < S [ 1 ] ) : <NEWLINE> <INDENT> print ( str ( S [ 0 ] ) + <STRING> + str ( S [ 1 ] ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( str ( S [ 1 ] ) + <STRING> + str ( S [ 0 ] ) ) <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> while True : <NEWLINE> <INDENT> a , b = map ( int , sys . stdin . readline ( ) . split ( ) ) <NEWLINE> if ( a == 0 ) & ( b == 0 ) : <NEWLINE> <INDENT> break <NEWLINE> if a < b : print ( a , b ) <NEWLINE> else : print ( b , a ) <NEWLINE> <DEDENT> <DEDENT>
while True : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if x == 0 and y == 0 : <NEWLINE> <INDENT> break ; <NEWLINE> <NL> <DEDENT> elif x = > y : <NEWLINE> <INDENT> print ( str ( x ) + <STRING> + str ( y ) ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> print ( str ( y ) + <STRING> + str ( x ) ) <NEWLINE> <NL> <DEDENT> <DEDENT>
while True : <NEWLINE> <INDENT> x = input ( ) . split ( ) <NEWLINE> if x == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> x = list ( map ( int , x ) ) <NEWLINE> x = sorted ( x ) <NEWLINE> a , b = x [ 0 ] , x [ 1 ] <NEWLINE> print ( <STRING> . format ( a , b ) ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> results = list ( map ( str , sorted ( map ( int , input ( ) . split ( ) ) ) ) ) <NEWLINE> if len ( results ) == len ( list ( filter ( lambda item : item == <STRING> , results ) ) ) <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> print <STRING> . join ( results ) <NEWLINE> <DEDENT>
from __future__ import division , print_function <NEWLINE> from sys import stdin <NEWLINE> <NL> for line in stdin : <NEWLINE> <INDENT> a , b = map ( int , line . split ( ) ) <NEWLINE> if ( a == 0 and b == 0 ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if a > b : <NEWLINE> <INDENT> print b , a <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print a , b <NEWLINE> <DEDENT> <DEDENT>
while 1 : <NEWLINE> <INDENT> x , y = map ( int , row_input ( ) . split ( ) ) <NEWLINE> if x == 0 and y == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> n = [ x , y ] <NEWLINE> n . sort ( ) <NEWLINE> print n [ 0 ] , n [ 1 ] <NEWLINE> <DEDENT> <DEDENT>
while True : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> if ( x == y == 0 ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else if ( x > y ) : <NEWLINE> <INDENT> print ( y , x ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( x , y ) <NEWLINE> <DEDENT> <DEDENT>
a = [ ] <NEWLINE> while True : <NEWLINE> <INDENT> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if b [ 0 ] == <STRING> and b [ 1 ] == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> b . sort ( ) <NEWLINE> a . append ( b ) <NEWLINE> <NL> <NL> <DEDENT> for i in a : <NEWLINE> <INDENT> print ( i [ 0 ] , i [ 1 ] ) <NEWLINE> <DEDENT>
while 1 : <NEWLINE> <INDENT> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if a == 0 and b == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> print ( min ( a ) , max ( a ) ) <NEWLINE> <DEDENT>
<NL> def check ( lis ) : <NEWLINE> <INDENT> if lis [ 0 ] > lis [ 1 ] : <NEWLINE> <INDENT> return lis [ : : - 1 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return lis <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> while True : <NEWLINE> <INDENT> l = list ( map ( int , input ( ) . spilt ( ) ) ) <NEWLINE> if sum ( l ) == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> print ( * check ( l ) ) <NEWLINE> <NL> <DEDENT>
a , b = [ int ( i ) for i in input ( ) , split ( ) ] <NEWLINE> <NL> <NL> d = a // b <NEWLINE> r = a % b <NEWLINE> f = a / b <NEWLINE> <NL> <NL> print ( <STRING> . format ( d , r , f ) ) <NEWLINE>
while True : <NEWLINE> <INDENT> if any ( [ int ( x ) for x in input ( ) . split ( ) ] ) : <NEWLINE> <INDENT> [ a , b ] = sorted ( [ int ( x ) for x in input ( ) . split ( ) ] ) <NEWLINE> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT>
d = 0 <NEWLINE> <NL> while d == 0 : <NEWLINE> <INDENT> i = raw_input ( ) <NEWLINE> x , y = i . split ( ) <NEWLINE> x = int ( x ) <NEWLINE> y = int ( y ) <NEWLINE> <NL> if x == 0 and y == 0 : <NEWLINE> <INDENT> d = 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if x > y : <NEWLINE> <INDENT> tmp = y <NEWLINE> y = x <NEWLINE> x = tmp <NEWLINE> <DEDENT> print ( <STRING> % ( x , y ) ) <NEWLINE> <DEDENT> <DEDENT>
<INDENT> while ( True ) : <NEWLINE> <INDENT> poyo = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if poyo [ 0 ] == 0 and poyo [ 1 ] == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> poyo . sort ( ) <NEWLINE> print poyo [ 0 ] , poyo [ 1 ] <NEWLINE> <DEDENT> <DEDENT>
stack = [ ] <NEWLINE> while True : <NEWLINE> <INDENT> a = raw_input ( ) <NEWLINE> if a == <STRING> : break <NEWLINE> for i , b in enumerate ( a . split ( ) ) : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> x = int ( b ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> y = int ( b ) <NEWLINE> <DEDENT> if x <= y : <NEWLINE> <INDENT> stack . append ( x ) <NEWLINE> stack . append ( y ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> stack . append ( y ) <NEWLINE> stack . append ( x ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> for i , c in enumerate ( stack ) : <NEWLINE> <INDENT> w = i % 2 <NEWLINE> if w == 0 : <NEWLINE> <INDENT> x = int ( c ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> y = int ( c ) <NEWLINE> print x , y <NEWLINE> <DEDENT> <DEDENT>
while True : <NEWLINE> <INDENT> x , y = [ int ( i ) for i in sys . stdin . readline ( ) . split ( <STRING> ) ] <NEWLINE> if x == 0 & y == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> elif x <= y : <NEWLINE> <INDENT> print ( x , y ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( y , x ) <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> for line in sys . stdin ; <NEWLINE> <INDENT> items_sorted = sorted ( line . split ( ) , reverse = True ) <NEWLINE> print ( <STRING> . format ( items_sorted [ 0 ] , items_sorted [ 1 ] ) ) <NEWLINE> <DEDENT>
x = 1 <NEWLINE> y = 1 <NEWLINE> <NL> while x != 0 or y != 0 : <NEWLINE> <INDENT> n = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> x = n [ 0 ] <NEWLINE> y = n [ 1 ] <NEWLINE> if x == 0 and y == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> elif x <= y : <NEWLINE> <INDENT> print x , y <NEWLINE> <DEDENT> elif x > y : <NEWLINE> <INDENT> print y , x1 <NEWLINE> <DEDENT> <DEDENT>
while True : <NEWLINE> <INDENT> x , y = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> if x > y : <NEWLINE> <INDENT> print ( y , x ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( x , y ) <NEWLINE> <NL> <NL> <NL> <NL> <DEDENT> <DEDENT>
import sys <NEWLINE> while True : <NEWLINE> <INDENT> a , b = map ( int , stdin . readline ( ) . split ( ) ) <NEWLINE> if a == 0 and b == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if a < b : print ( a , b ) <NEWLINE> else : print ( b , a ) <NEWLINE> <DEDENT>
while 1 : <NEWLINE> <INDENT> x , y = map ( raw_input ( ) . split ( ) ) <NEWLINE> if x == 0 and y == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if y >= x : <NEWLINE> <INDENT> print <STRING> % ( x , y ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> % ( y , x ) <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> while True : <NEWLINE> <INDENT> ab = sys . stdin . readline ( ) . split ( ) <NEWLINE> a = ab [ 0 ] . strip <NEWLINE> b = ab [ 1 ] . strip <NEWLINE> if a == 0 and b == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <NL> i = 1 <NEWLINE> x = 1 <NEWLINE> while x != 0 and y != 0 : <NEWLINE> <INDENT> xy = raw_input ( ) . split ( ) <NEWLINE> x = int ( xy [ 0 ] ) <NEWLINE> y = int ( xy [ 1 ] ) <NEWLINE> if x == 0 and y == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if x < y : <NEWLINE> <INDENT> print x , y <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print y , x <NEWLINE> <DEDENT> <DEDENT>
while True : <NEWLINE> <INDENT> x = int ( input ( ) . split ( ) ) <NEWLINE> <NL> if x [ 0 ] == 0 and x [ 1 ] == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> if x [ 0 ] > x [ 1 ] : <NEWLINE> <INDENT> print ( x [ 1 ] , x [ 0 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( x [ 0 ] , x [ 1 ] ) <NEWLINE> <DEDENT> <DEDENT>
a , b = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> print min ( a . b ) , max ( a , b ) <NEWLINE>
while True : <NEWLINE> <INDENT> x = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if x == y == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> print ( min ( x ) , max ( x ) ) <NEWLINE> <DEDENT>
<NL> <NL> <NL> while True : <NEWLINE> <INDENT> x , y = map ( int , raw_input . split ( ) ) <NEWLINE> if x == y == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <NL> <DEDENT> if x < y : <NEWLINE> <INDENT> print <STRING> % ( x , y ) <NEWLINE> <DEDENT> elif x > y : <NEWLINE> <INDENT> print <STRING> % ( y , x ) <NEWLINE> <DEDENT> elif x == y : <NEWLINE> <INDENT> print <STRING> % ( x , y ) <NEWLINE> <NL> <DEDENT> <DEDENT>
while True : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if x == 0 and b == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if a < b : <NEWLINE> <INDENT> print ( <STRING> . format ( a , b ) ) <NEWLINE> <DEDENT> elif a > b : <NEWLINE> <INDENT> print ( <STRING> . format ( b , a ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
a , b = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> while a , b != 0 , 0 <NEWLINE> print b , a <NEWLINE>
while ( True ) : <NEWLINE> <INDENT> temp = raw_input ( ) <NEWLINE> temp_list = temp . split ( ) <NEWLINE> x = int ( temp_list [ 0 ] ) <NEWLINE> y = int ( temp_list [ 1 ] ) <NEWLINE> if x == y and x == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( str ( min ( [ x , y ] ) ) + <STRING> + str ( max ( [ x , y ] ) ) <NEWLINE> <NL> <DEDENT> <DEDENT>
while True : <NEWLINE> <INDENT> ( x , y ) = [ int ( i ) for i in sys . stdin . readline ( ) . split ( <STRING> ) ] <NEWLINE> if x == 0 and y == 0 <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if x > y : <NEWLINE> <INDENT> z = x <NEWLINE> x = y <NEWLINE> y = z <NEWLINE> <DEDENT> print ( x , y ) <NEWLINE> <DEDENT>
while 1 : <NEWLINE> <INDENT> x , y = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if x == 0 and y == 0 <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> elif x < y <NEWLINE> <INDENT> print <STRING> % ( x , y ) <NEWLINE> <DEDENT> elif y < x <NEWLINE> <INDENT> print <STRING> % ( y , x ) <NEWLINE> <DEDENT> <DEDENT>
while True : <NEWLINE> <INDENT> x , y = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if x == 0 and y == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> elif x > y : <NEWLINE> <INDENT> print y , x <NEWLINE> <DEDENT> else x <= y : <NEWLINE> <INDENT> print x , y <NEWLINE> <NL> <DEDENT> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> while True : <NEWLINE> <INDENT> xy = [ int ( v ) for v in raw_input ( ) . split ( ) ] <NEWLINE> if sum ( xy ) == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> print <STRING> . join ( [ str ( v ) for v in sorted ( xy ) ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> ( x , y ) = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <DEDENT> print ( x , y ) <NEWLINE>
while True : <NEWLINE> <INDENT> 4 a , b = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> 5 <NEWLINE> 6 if a == 0 and b == 0 : <NEWLINE> 7 break <NEWLINE> 8 else : <NEWLINE> 9 if a > b : <NEWLINE> 10 print b , a <NEWLINE> 11 else : <NEWLINE> 12 print a , b <NEWLINE> <DEDENT>
import sys <NEWLINE> while ( True ) : <NEWLINE> <INDENT> x , y = map ( int ( sys . stdin . readline ( ) ) ) <NEWLINE> if x == 0 and y == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if x < y : <NEWLINE> <INDENT> print ( <STRING> % ( x , y ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> % ( y , x ) ) <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> while True : <NEWLINE> <INDENT> ( x , y ) = [ int ( i ) for i in sys . stdin . readline ( ) . split ( ) ] <NEWLINE> if x == 0 == y : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if x > y : <NEWLINE> <NL> print ( x , y ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> x , y = map ( int , inpu ( ) . split ( ) ) <NEWLINE> if x == 0 and y == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> if x > y : <NEWLINE> <INDENT> z = x <NEWLINE> x = y <NEWLINE> y = z <NEWLINE> <NL> <DEDENT> print ( x , y ) <NEWLINE> <NL> <DEDENT>
while True : <NEWLINE> <INDENT> x , y = map ( int , raw_input ( ) . split ( <STRING> ) ) <NEWLINE> if ( x , y ) == ( 0 , 0 ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> elif ( x < y ) : <NEWLINE> <INDENT> print x , y <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print y , x <NEWLINE> <DEDENT> <DEDENT>
while True : <NEWLINE> <INDENT> x , y = map ( int ( input ( ) . split ( ) ) <NEWLINE> if ( x , y ) == ( 0 , 0 ) : break <NEWLINE> if x < y : <NEWLINE> <INDENT> print ( x , y ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( y , x ) <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> for a . strip ( ) in sys . stdin : <NEWLINE> <INDENT> if a == <STRING> : break <NEWLINE> print ( * sorted ( map ( int , a . split ( ) ) ) ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> x , y = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> if x == 0 and y == 0 : <NEWLINE> <INDENT> break <NEWLINE> if x >= y : <NEWLINE> print ( y , x ) <NEWLINE> elif x < y : <NEWLINE> print ( x , y ) <NEWLINE> <DEDENT> <DEDENT>
<STRING> <NEWLINE> <COMMENT> <NL> import sys <NEWLINE> <NL> <COMMENT> <NL> for inputData in sys . stdin : <NEWLINE> <INDENT> inputData = inputData . split ( <STRING> ) <NEWLINE> inputData01 , inputData02 = int ( inputData [ 0 ] ) , int ( inputData [ 1 ] ) <NEWLINE> <COMMENT> <NL> if inputData01 == 0 : <NEWLINE> <INDENT> if inputData02 == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> if inputData01 > inputData02 : <NEWLINE> <INDENT> outputData01 = inputData02 <NEWLINE> outputData02 = inputData01 <NEWLINE> <DEDENT> elif inputData01 < inputData02 : <NEWLINE> <INDENT> outputData01 = inputData01 <NEWLINE> outputData02 = inputData02 <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> print ( ( outputData01 ) , ( outputData02 ) ) ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> while 1 : <NEWLINE> <INDENT> str = sys . stdin . readline ( ) . strip ( ) <NEWLINE> a , b = sorted ( str . split ( <STRING> ) , key = int ) <NEWLINE> if a , b == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> print ( a , b ) <NEWLINE> <DEDENT>
x , y = input ( ) . split ( ) <NEWLINE> x = int ( x ) <NEWLINE> y = int ( y ) <NEWLINE> while True : <NEWLINE> <INDENT> if x == 0 and y == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> if x < y : <NEWLINE> <INDENT> print ( y , x ) <NEWLINE> <DEDENT> if x > y : <NEWLINE> <INDENT> print ( x , y ) <NEWLINE> <NL> <NL> <DEDENT>
while True : <NEWLINE> <INDENT> a = input ( ) . split ( ) <NEWLINE> if a == [ 0 , 0 ] : <NEWLINE> <INDENT> quit ( ) <NEWLINE> <DEDENT> print ( * a [ : : - 1 ] ) <NEWLINE> <DEDENT>
x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> while not ( x == 0 and y == 0 ) : <NEWLINE> <INDENT> if x < y : print ( x , y ) <NEWLINE> else : print ( y , x ) <NEWLINE> <DEDENT>
1 inport sys <NEWLINE> for i in sys . stdin . readlines ( ) : <NEWLINE> <INDENT> a , b = i . strip ( ) . split ( ) <NEWLINE> if a == <STRING> and b == <STRING> : <NEWLINE> <INDENT> break ; <NEWLINE> <NL> <DEDENT> if int ( a ) < int ( b ) : <NEWLINE> <INDENT> print ( <STRING> . format ( a , b ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> . format ( b , a ) ) <NEWLINE> <DEDENT> <DEDENT>
while True : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if ( a , b ) == ( 0 , 0 ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> elif a > b : <NEWLINE> <INDENT> c = a <NEWLINE> a = b <NEWLINE> b = c <NEWLINE> <DEDENT> else : <NEWLINE> print ( <STRING> . format ( a , b ) ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ) <NEWLINE> if x == 0 and y == 0 : <NEWLINE> <INDENT> brake <NEWLINE> <NL> <DEDENT> if x <= y : <NEWLINE> <INDENT> print ( x , y ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( y , x ) <NEWLINE> <DEDENT> <DEDENT>
while 1 : <NEWLINE> <INDENT> x , y = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if x == 0 and y == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> elif y > x : <NEWLINE> <INDENT> print <STRING> & ( y , x ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> & ( x , y ) <NEWLINE> <DEDENT> <DEDENT>
while True : <NEWLINE> <INDENT> x , y = ( int ( x ) for x in input ( ) . split ( ) ) <NEWLINE> if x == <STRING> and y == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if x > y : <NEWLINE> <INDENT> print ( str ( x ) + <STRING> + str ( y ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( str ( y ) + <STRING> + str ( x ) ) <NEWLINE> <NL> <DEDENT> <DEDENT>
import sys <NEWLINE> <NL> ff = sys . stdin <NEWLINE> <NL> while True : <NEWLINE> <INDENT> a , b = map ( int , ff . readline ( ) . split ( ) ) <NEWLINE> if ( a == 0 ) & ( b == 0 ) : <NEWLINE> break <NEWLINE> elif a < b : <NEWLINE> <INDENT> print ( a , b ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( b , a ) <NEWLINE> <DEDENT> <DEDENT>
a = [ ] <NEWLINE> while True : <NEWLINE> <INDENT> n = input ( ) <NEWLINE> if int ( n ) == 0 : break <NEWLINE> a . append ( n ) <NEWLINE> <DEDENT> for s in a : <NEWLINE> <INDENT> x , y = map ( int , s . split ( ) ) <NEWLINE> if x > y : print ( <STRING> ) <NEWLINE> else : print ( s ) <NEWLINE> <DEDENT>
x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> if x == 0 and y == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if x <= y : <NEWLINE> <INDENT> print ( x , y ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( y , x ) <NEWLINE> <NL> <NL> <DEDENT>
while True : <NEWLINE> <INDENT> a = sorted ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if a == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> print ( * a ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> x , y = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if x == 0 and y == 0 : <NEWLINE> <NL> <NL> <NL> <NL> <NL> <NL> <DEDENT>
while True : <NEWLINE> a , b = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> if a == 0 and b == 0 : break <NEWLINE> elif a < b : <NEWLINE> print ( a , b ) <NEWLINE> else : <NEWLINE> print ( b , a ) <NEWLINE> <NL>
while True : <NEWLINE> <INDENT> x , y = sorted ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if x == y and y == 0 : <NEWLINE> print ( x , y ) <NEWLINE> x , y = sorted ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> while ( True ) : <NEWLINE> <INDENT> x , y = map ( int , sys . stdin . readline ( ) . split ( ) ) <NEWLINE> if x == 0 and y == 0 : <NEWLINE> <INDENT> sys . exist ( ) <NEWLINE> <DEDENT> elif x < y : <NEWLINE> <INDENT> print ( x , y ) <NEWLINE> <DEDENT> elif x > y : <NEWLINE> <INDENT> print ( y , x ) <NEWLINE> <DEDENT> <DEDENT>
while True : <NEWLINE> <INDENT> ( x , y ) = [ int ( i ) for i in sys . stdin . readline ( ) . split ( ) ] <NEWLINE> if x == 0 == y : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if x > y : <NEWLINE> <INDENT> z = x <NEWLINE> x = y <NEWLINE> y = z <NEWLINE> <NL> <DEDENT> print ( x , y ) <NEWLINE> <DEDENT>
while 1 : <NEWLINE> <INDENT> x , y = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if x == 0 and y == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> print min ( x , y ) , max ( x , y ) ) <NEWLINE> <DEDENT>
<NL> n = [ ] <NEWLINE> line = <STRING> <NEWLINE> while line != [ 0 , 0 ] : <NEWLINE> <INDENT> line = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> n . append ( line ) <NEWLINE> <DEDENT> for i in range ( len ( n ) - 1 ) : <NEWLINE> <INDENT> print ( <STRING> % ( n [ i ] [ 0 ] if n [ i ] [ 0 ] >= n [ i ] [ 1 ] else n [ i ] [ 1 ] , n [ i ] [ 0 ] if n [ i ] [ 0 ] <= n [ i ] [ 1 ] else n [ i ] [ 1 ] ) ) javascript : void ( 0 ) <NEWLINE> <DEDENT>
while 1 : <NEWLINE> <INDENT> x , y = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if x == 0 and y == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if x > y : <NEWLINE> <INDENT> print <STRING> % ( y , x ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> % ( x , y ) <NEWLINE> <DEDENT> <DEDENT>
You are not allowed to see this code . <NEWLINE>
while True : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . sprit ( ) ) <NEWLINE> if ( a == 0 and b == 0 ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if a > b : <NEWLINE> <INDENT> swap = a <NEWLINE> a = b <NEWLINE> b = swap <NEWLINE> <NL> <DEDENT> print ( <STRING> % ( a , b ) ) <NEWLINE> <NL> <NL> <DEDENT>
<COMMENT> <NL> for c in range ( 3000 ) : <NEWLINE> <INDENT> l = input ( ) . strip ( ) . split ( ) <NEWLINE> x = int ( l [ 0 ] ) <NEWLINE> y = int ( l [ 1 ] ) <NEWLINE> if ( x < 1 and y < 0 ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> elif ( x > y ) : <NEWLINE> <INDENT> print ( <STRING> . format ( y , x ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> . format ( x , y ) ) <NEWLINE> <DEDENT> <DEDENT>
x = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> while str ( x ) != <STRING> : <NEWLINE> <INDENT> a = int ( x ) . sort ( ) <NEWLINE> for i in range ( 2 ) : <NEWLINE> <INDENT> print ( str ( a [ 0 ] ) , str ( a [ 1 ] ) ) <NEWLINE> <DEDENT> x = input ( ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> x , y = map ( int , raw_input . split ( ) ) <NEWLINE> if x == 0 and y == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if x < y : <NEWLINE> <INDENT> print <STRING> % ( x , y ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> % ( y , x ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
while True : <NEWLINE> <INDENT> x , y = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> y = input ( ) <NEWLINE> if x == y == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> print min ( x , y ) , max ( x , y ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> a = [ int ( i ) for i in input ( ) . split ( <STRING> ) ] <NEWLINE> num1 = a [ 0 ] <NEWLINE> num2 = a [ 1 ] <NEWLINE> if num1 == 0 and num2 == 0 : <NEWLINE> elif num1 <= num2 : <NEWLINE> <INDENT> print ( num1 , num2 ) <NEWLINE> <DEDENT> elif num1 > num2 : <NEWLINE> <INDENT> print ( num2 , num1 ) <NEWLINE> <DEDENT> <DEDENT>
while True : <NEWLINE> <INDENT> x , y = sorted [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> if ( x , y ) == ( 0 , 0 ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> print ( x , y ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> while True : <NEWLINE> <INDENT> a , b = map ( int , sys . stdin . readline ( ) . stlip ( ) ) <NEWLINE> if ( a == 0 ) & ( b == 0 ) : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> if a < b : print ( a , b ) <NEWLINE> else : print ( b , a ) <NEWLINE> <DEDENT>
listx = [ ] <NEWLINE> listy = [ ] <NEWLINE> while True : <NEWLINE> <INDENT> x , y = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if x == 0 and y == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> list . append ( x ) <NEWLINE> list . append ( y ) <NEWLINE> <NL> <DEDENT> listx . sort ( ) <NEWLINE> listy . sort ( ) <NEWLINE> <NL> for i in range ( len ( listx ) ) : <NEWLINE> <INDENT> print <STRING> , ( listx [ i ] , listy [ i ] ) <NEWLINE> <DEDENT>
x = int ( input ( ) ) <NEWLINE> y = int ( input ( ) ) <NEWLINE> if x < y : <NEWLINE> <INDENT> print ( x , y ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( y , x ) <NEWLINE> <DEDENT>
while ( True ) : <NEWLINE> <INDENT> i , j = input ( ) . split ( ) <NEWLINE> <NL> if a != 0 and b != 0 : <NEWLINE> <INDENT> if int ( i ) <= int ( j ) : <NEWLINE> <INDENT> print ( <STRING> . format ( i , j ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> . format ( j , i ) ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT>
while 1 : <NEWLINE> <INDENT> x = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if x == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> x . sort ( ) <NEWLINE> print x [ 0 ] + <STRING> + x [ 1 ] <NEWLINE> <DEDENT>
<INDENT> while True : <NEWLINE> <INDENT> x , y = sorted ( map ( int , raw_input ( ) . split ( ) ) ) <NEWLINE> if x == y == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> print x , y <NEWLINE> <DEDENT> <DEDENT>
while True : <NEWLINE> <INDENT> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if sum ( a ) == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> print ( <STRING> . join . ( list ( map ( str , sorted ( a ) ) ) ) ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> [ a , b , c ] = [ int ( x ) for x in sys . stdin . readline ( ) ] <NEWLINE> <NL> counter = 0 <NEWLINE> for value in range ( a , b + 1 ) : <NEWLINE> <INDENT> if c / value == 0 : <NEWLINE> <INDENT> counter += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( counter ) <NEWLINE>
( a , b , c ) = [ int ( i ) for i in input ( ) . split <NEWLINE>
temp = raw_input ( ) <NEWLINE> temp_list = temp . split ( ) <NEWLINE> a = temp_list [ 0 ] <NEWLINE> b = temp_list [ 1 ] <NEWLINE> c = temp_list [ 2 ] <NEWLINE> <NL> count = 0 <NEWLINE> for i in range ( a , b + 1 ) : <NEWLINE> <INDENT> if c / i == 0 : <NEWLINE> <INDENT> count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
j = 0 <NEWLINE> input = input ( ) <NEWLINE> a , b , c = map ( int , input . split ( ) ) <NEWLINE> for i in range ( a , b + 1 ) : <NEWLINE> <INDENT> if c % i == 0 <NEWLINE> <INDENT> j += 1 <NEWLINE> <DEDENT> <DEDENT> print ( j ) <NEWLINE>
a , b , c = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> i = 0 <NEWLINE> for i in range ( a , b + 1 , 1 ) : <NEWLINE> <INDENT> if c % i == 0 : <NEWLINE> <INDENT> i = i + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <NL> <DEDENT> print ( i ) <NEWLINE>
a , b , c = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> count = 0 <NEWLINE> for d in range ( a , b + 1 ) <NEWLINE> <INDENT> if c % d == 0 : count += 1 <NEWLINE> <DEDENT> print ( count ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> d = a // b <NEWLINE> r = a % b <NEWLINE> f = a / b <NEWLINE> print ( d , r , f ) <NEWLINE>
a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> i = a <NEWLINE> j = 0 <NEWLINE> if ( a <= i and i <= b ) : <NEWLINE> <INDENT> if ( c % i = 0 ) : <NEWLINE> <INDENT> i += 1 <NEWLINE> j += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> i += 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( j ) <NEWLINE> <NL> <DEDENT>
( a , b , c ) = [ int ( i ) for i in input ( ) . rstrip ( ) . split ( ) ] <NEWLINE> <NL> count = 0 <NEWLINE> for x in range ( a , b + 1 ) : <NEWLINE> <INDENT> if c % x == 0 : <NEWLINE> <INDENT> count + + <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
a , b , c = [ int ( i ) for i in input ( ) rstrip ( ) . split ( <STRING> ) ] <NEWLINE> cnt = 0 <NEWLINE> for i in range ( a , b + 1 ) : <NEWLINE> <INDENT> if c % i == 0 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
import sys <NEWLINE> <NL> count = 0 <NEWLINE> <NL> for line in sys . stdin : <NEWLINE> <INDENT> array = line . readLine ( ) . split ( <STRING> ) <NEWLINE> a = array [ 0 ] <NEWLINE> b = array [ 1 ] <NEWLINE> c = array [ 3 ] <NEWLINE> <NL> if ( a < 1 or a > 10000 ) or ( b < 1 or b > 10000 ) or ( c < 1 or c > 10000 ) : <NEWLINE> <INDENT> sys . exit ( ) <NEWLINE> <NL> <DEDENT> for x in xrange ( a , b ) : <NEWLINE> <INDENT> if c % x == 0 : <NEWLINE> <INDENT> count = count + 1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> print count <NEWLINE> <DEDENT>
a , b c = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> total = 0 <NEWLINE> for d in range ( a , b + 1 ) : <NEWLINE> <INDENT> if c % d == 0 : <NEWLINE> <INDENT> total += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( total ) <NEWLINE>
( a , b , c ) [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> <NL> count = 0 <NEWLINE> for d in range ( a , b + 1 ) : <NEWLINE> <INDENT> if c % d == 0 : <NEWLINE> <INDENT> count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> count = 0 <NEWLINE> for i in range ( a , b + 1 ) : <NEWLINE> <INDENT> d = c % i <NEWLINE> <INDENT> if d == 0 : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
counter = 0 <NEWLINE> a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> for i in range ( a , b ) : <NEWLINE> <INDENT> if ( ( c % i ) == 0 ) counter = counter + 1 <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> <NL>
a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> d = 0 <NEWLINE> while a != b + 1 : <NEWLINE> <INDENT> if c % a == 0 : <NEWLINE> <INDENT> d += 1 <NEWLINE> a += 1 <NEWLINE> <DEDENT> <DEDENT> print ( d ) <NEWLINE>
a , b , c = input ( ) . split ( ) <NEWLINE> count = 0 <NEWLINE> for i in range ( a , b + 1 ) : <NEWLINE> <INDENT> if c % i == 0 : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
import sys <NEWLINE> <NL> if __name__ == <STRING> : <NEWLINE> <INDENT> a , b , c = map ( int , sys . stdin . read ( ) . split ( ) ) <NEWLINE> print len ( i for i in range ( a , b + 1 ) if c % i == 0 ) <NEWLINE> <DEDENT>
count = 0 <NEWLINE> for i in range ( x [ 0 ] , x [ 1 ] ) : <NEWLINE> <INDENT> if x [ 2 ] % i == 0 : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> x = 0 <NEWLINE> for i in range ( a , b + 1 ) : <NEWLINE> <INDENT> if c % % i == 0 : <NEWLINE> <INDENT> x += x + 1 <NEWLINE> <DEDENT> print ( x ) <NEWLINE> <NL> <DEDENT>
, b , c = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> <NL> count = 0 <NEWLINE> for n in range ( a , b + 1 ) : <NEWLINE> <INDENT> if c % a == 0 : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> a += 1 <NEWLINE> <NL> <DEDENT> print ( <STRING> . format ( count ) ) <NEWLINE>
a , b , c = map ( int , input ( ) . strip ( ) ) <NEWLINE> answer = 0 <NEWLINE> <NL> for i in range ( a , b + 1 ) : <NEWLINE> <INDENT> if c % i == 0 : <NEWLINE> <INDENT> answer += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( answer ) <NEWLINE>
a , b , c = map ( int , input ( ) . sprit ( ) ) <NEWLINE> <NL> count = 0 : <NEWLINE> for x in range ( a , b + 1 ) <NEWLINE> <INDENT> if c % x == 0 : <NEWLINE> <INDENT> count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
<INDENT> ( a , b , c ) = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <DEDENT> count = 0 <NEWLINE> for i in range ( a , b ) : <NEWLINE> <INDENT> if ( c % i ) == 0 : <NEWLINE> <INDENT> count = count + 1 <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE> ~ <NEWLINE>
x = input ( ) . split ( <STRING> ) <NEWLINE> a = int ( x [ 0 ] ) <NEWLINE> b = int ( x [ 1 ] ) <NEWLINE> c = int ( x [ 2 ] ) <NEWLINE> count = 0 <NEWLINE> for i in range ( a , b + 1 ) : <NEWLINE> <INDENT> if c % i == 0 : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> Print ( count ) <NEWLINE>
a , b , c = map ( int , input ( ) ) <NEWLINE> count = 0 <NEWLINE> for i in range ( a , b + 1 ) : <NEWLINE> <INDENT> if c % i == 0 : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> print ( count ) <NEWLINE> <DEDENT>
N = input ( ) . split ( ) <NEWLINE> <NL> a = int ( N [ 0 ] ) <NEWLINE> b = int ( N [ 1 ] ) <NEWLINE> c = int ( N [ 2 ] ) <NEWLINE> <NL> count = 0 <NEWLINE> for i in range [ a , b ] : <NEWLINE> <INDENT> d = c % i <NEWLINE> if d == 0 : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
a , b , c = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> <NL> count = 0 <NEWLINE> for d in xrange ( a , b + 1 ) : <NEWLINE> <INDENT> if c % d == 0 : count += 1 <NEWLINE> <DEDENT> print ( count ) <NEWLINE> <NL>
a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> d = 0 <NEWLINE> for i in range ( a , b + 1 ) <NEWLINE> <INDENT> if c % i == 0 : <NEWLINE> <INDENT> d += 1 <NEWLINE> <DEDENT> <DEDENT> print ( d ) <NEWLINE>
while True : <NEWLINE> <INDENT> x , y = ( int ( x ) for x in input ( ) . split ( ) ) <NEWLINE> <NL> if x == 0 and y == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if x < y : <NEWLINE> <INDENT> print ( str ( x ) + <STRING> + str ( y ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( str ( y ) + <STRING> + str ( x ) ) <NEWLINE> <DEDENT> <DEDENT>
a , b , c = input ( ) . split ( ) <NEWLINE> a = int ( ) <NEWLINE> b = int ( ) <NEWLINE> c = int ( ) <NEWLINE> aaa = 0 <NEWLINE> for x in range ( a , b + 1 ) : <NEWLINE> <INDENT> if x % c == 0 : <NEWLINE> <INDENT> aaa += 1 <NEWLINE> <DEDENT> <DEDENT> print ( aaa ) <NEWLINE> <NL> <NL> <NL>
a , b , c = input ( ) <NEWLINE> n = 0 <NEWLINE> for i in range ( a , b + 1 ) : <NEWLINE> <INDENT> if c % i == 0 : <NEWLINE> <INDENT> n = n + 1 <NEWLINE> <DEDENT> <DEDENT> print ( n ) <NEWLINE>
a , b , N = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> divisors_list = [ ] <NEWLINE> for i in range ( a , b ) : <NEWLINE> <INDENT> divisor = N % i <NEWLINE> if divisor == 0 : <NEWLINE> <INDENT> divisors_list . append ( divisor ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( len ( divisors_list ) ) <NEWLINE> a , b , N = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> divisors_list = [ ] <NEWLINE> for i in range ( a , b ) : <NEWLINE> <INDENT> divisor = N % i <NEWLINE> if divisor == 0 : <NEWLINE> <INDENT> divisors_list . append ( divisor ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( len ( divisors_list ) ) <NEWLINE>
a , b , c = map ( int , input ( ) , split ( ) ) <NEWLINE> print ( len ( [ x for x in range ( a , b + 1 ) if ( c % x ) == 0 ] ) ) <NEWLINE>
a , b = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> d = a // b <NEWLINE> r = a % b <NEWLINE> f = a / b <NEWLINE> <NL> print ( <STRING> . format ( d , r , f ) ) <NEWLINE>
a , b , c = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> total = 0 <NEWLINE> <NL> for i in range ( a , b + 1 ) : <NEWLINE> <INDENT> if c % 1 == 0 : <NEWLINE> <INDENT> totale += 1 <NEWLINE> <DEDENT> <DEDENT> print ( totale ) <NEWLINE>
a , b , c = [ input ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> total = 0 <NEWLINE> for d in range ( a , b + 1 ) : <NEWLINE> <INDENT> if c % d == 0 : <NEWLINE> <INDENT> total += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( total ) <NEWLINE>
cnt = 0 <NEWLINE> a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> while True : <NEWLINE> <INDENT> if b - a <= 0 : break <NEWLINE> for i in range ( a , b ) : <NEWLINE> <INDENT> if ( c % a == 0 ) : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> a += 1 <NEWLINE> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE> <DEDENT>
( a , b , c ) [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> <NL> count = 0 <NEWLINE> for d in range ( a , b + 1 ) : <NEWLINE> <INDENT> if c % d == 0 : <NEWLINE> <INDENT> count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
p = 0 <NEWLINE> a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> for ( int x = a ; x <= b ; x + + ) : <NEWLINE> <INDENT> if c % x == 0 : <NEWLINE> <INDENT> p += 1 <NEWLINE> <DEDENT> <DEDENT> print ( p ) <NEWLINE>
<COMMENT> <NL> x = [ ] <NEWLINE> a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> for i in range ( a , b ) : <NEWLINE> <INDENT> if c % i == 0 : <NEWLINE> <INDENT> x . append ( i ) <NEWLINE> <DEDENT> <DEDENT> print ( len ( x ) ) <COMMENT> <NEWLINE> x = [ ] <NEWLINE> a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> for i in range ( a , b + 1 ) : <NEWLINE> <INDENT> if c % i == 0 : <NEWLINE> <INDENT> x . append ( i ) <NEWLINE> <DEDENT> <DEDENT> print ( len ( x ) ) <NEWLINE>
5 14 80 <NEWLINE>
a , b , c = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> k = 0 <NEWLINE> <NL> for i in range ( a , b ) : <NEWLINE> <INDENT> if c % i == 0 and != b : <NEWLINE> <INDENT> k += 1 <NEWLINE> <DEDENT> elif a == b and b == c : <NEWLINE> <INDENT> k = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print k <NEWLINE>
num = [ int ( n ) for n in input ( ) . split ( <STRING> ) ] <NEWLINE> <NL> a = num [ 1 ] <NEWLINE> b = num [ 2 ] <NEWLINE> c = num [ 3 ] <NEWLINE> <NL> count = 0 <NEWLINE> for i in range ( a , b + 1 ) : <NEWLINE> <INDENT> if c % i == 0 : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
a , b , c = map ( input ( ) . split ( ) ) <NEWLINE> d = 0 <NEWLINE> x = 0 <NEWLINE> for x in range ( a , b + 1 ) : <NEWLINE> <INDENT> if c % x == 0 : d += 1 <NEWLINE> <DEDENT> print ( d ) <NEWLINE>
nums = [ ] <NEWLINE> while True : <NEWLINE> <INDENT> num = [ int ( e ) for e in input ( ) . split ( ) ] <NEWLINE> if num [ 0 ] == 0 and num [ 1 ] == 0 and num [ 2 ] == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> nums . append ( num ) <NEWLINE> <NL> <DEDENT> for i in range ( len ( nums ) ) : <NEWLINE> <INDENT> yakusuu = [ ] <NEWLINE> yakusuu_count = 0 <NEWLINE> for j in range ( 1 , nums [ i ] [ 2 ] + 1 ) : <NEWLINE> <INDENT> if nums [ i ] [ 2 ] % j == 0 : <NEWLINE> <INDENT> yakusuu . append ( j ) <NEWLINE> <DEDENT> <DEDENT> for k in range ( len ( yakusuu ) ) : <NEWLINE> <INDENT> if nums [ i ] [ 0 ] <= yakusuu [ k ] and yakusuu [ k ] <= nums [ i ] [ 1 ] : <NEWLINE> <INDENT> yakusuu_count += 1 <NEWLINE> <DEDENT> <DEDENT> print ( yakusuu_count ) <NEWLINE> <DEDENT>
a , b , c = [ input ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> <NL> total = 0 <NEWLINE> for d in range ( a , b + 1 ) : <NEWLINE> <INDENT> if c % d == 0 : <NEWLINE> <INDENT> total += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( total ) <NEWLINE>
a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> g = 0 <NEWLINE> while a <= b : <NEWLINE> <INDENT> if c % i == 0 : <NEWLINE> <INDENT> g = g + 1 <NEWLINE> <DEDENT> a = a + 1 <NEWLINE> <DEDENT> print ( g ) <NEWLINE>
a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> count = 0 <NEWLINE> for i in range ( a : b + 1 ) : <NEWLINE> <INDENT> if c % i == 0 : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
count = 0 <NEWLINE> a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> for i in range ( a , b ) <NEWLINE> <INDENT> if c % i == 0 : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> <NL>
a , b , c = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> nums = 0 <NEWLINE> for i in range ( a , c + 1 ) <NEWLINE> <INDENT> if i % b == 0 or b % i == 0 : <NEWLINE> <INDENT> nums = nums + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> pass <NEWLINE> <NL> <DEDENT> <DEDENT> print ( nums ) <NEWLINE>
a , b , c = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> i = a <NEWLINE> j = 0 <NEWLINE> for i in range ( b - a + 1 ) : <NEWLINE> <INDENT> if c % i == 0 : <NEWLINE> <INDENT> j = j + 1 <NEWLINE> <DEDENT> <DEDENT> print <STRING> % ( j ) <NEWLINE>
a , b , c = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> count = 0 <NEWLINE> for i in rang ( a , b + 1 ) : <NEWLINE> <INDENT> if c % i == 0 : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> print count <NEWLINE>
a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> d = 0 <NEWLINE> for i in ( range ( a , b + 1 ) ) <NEWLINE> <INDENT> if c % i == 0 : <NEWLINE> <INDENT> d += 1 <NEWLINE> <DEDENT> <DEDENT> print ( d ) <NEWLINE>
a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> n = 0 <NEWLINE> for i in range ( a , b + 1 ) <NEWLINE> <INDENT> if c % i == 0 : <NEWLINE> <INDENT> n += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> n = n <NEWLINE> <DEDENT> <DEDENT> print ( n ) <NEWLINE>
a , b , c = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> for i in range ( a , b ) : <NEWLINE> <INDENT> if c % i == 0 : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> print count <NEWLINE>
<COMMENT> <NL> <NL> a = [ ] <NEWLINE> a , b , c = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> for i in range ( a , b ) : <NEWLINE> <INDENT> if c % i == 0 : <NEWLINE> <INDENT> n += 1 <NEWLINE> <DEDENT> <DEDENT> print n <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> data = [ ] <NEWLINE> while 1 : <NEWLINE> <INDENT> n = input ( ) . split ( ) <NEWLINE> a = int ( n [ 0 ] ) <NEWLINE> b = int ( n [ 1 ] ) <NEWLINE> c = int ( n [ 2 ] ) <NEWLINE> div = 0 <NEWLINE> <NL> for i in range ( a , b ) : <NEWLINE> <INDENT> if c % i == 0 : <NEWLINE> <INDENT> div += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( div ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
count = 0 <NEWLINE> a , b , c = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> while 1 : <NEWLINE> <INDENT> if c % a == 0 : <NEWLINE> count += 1 <NEWLINE> elif a == b : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> a += 1 <NEWLINE> <DEDENT> print count <NEWLINE>
a , b , c = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> cnt = 0 <NEWLINE> for i in range ( a , b + 1 ) <NEWLINE> <INDENT> if c % i == 0 : cnt += 1 <NEWLINE> <DEDENT> print ( cnt ) <NEWLINE>
a , b , c = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> t = 0 <NEWLINE> for n in range ( a , b + 1 ) <NEWLINE> <INDENT> if c % n == 0 : <NEWLINE> <INDENT> t += 1 <NEWLINE> <DEDENT> <DEDENT> print t <NEWLINE>
<COMMENT> <NL> <NL> def string_three_numbers_spliter ( ) : <NEWLINE> <INDENT> a , b , c = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> return a , b , c <NEWLINE> <NL> <NL> <DEDENT> def count_nums_of_factors_of_c_in_a_and_b ( a , b , c ) : <NEWLINE> <INDENT> count = 0 <NEWLINE> for i in range ( 1 , c + 1 ) : <NEWLINE> <INDENT> if ( c % i == 0 ) : <NEWLINE> <INDENT> if i >= a and i <= b : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return count <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> a , b , c = string_three_numbers_spliter ( ) <NEWLINE> print ( count_nums_of_divisors_of_c_in_a_and_b ( a , b , c ) ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> n = 0 <NEWLINE> for i in range ( a , b + 1 ) : if c % i == 0 : n += 1 <NEWLINE> print ( n ) <NEWLINE>
a , b , c = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> sum = 0 <NEWLINE> for i in range ( a , b ) : <NEWLINE> <INDENT> if c % i == 0 : <NEWLINE> <INDENT> sum = sum + 1 <NEWLINE> <DEDENT> else <NEWLINE> <INDENT> sum = sum <NEWLINE> <DEDENT> <DEDENT> print sum <NEWLINE>
a , b , c = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> a for i in ( 1 , 10001 ) : <NEWLINE> b for i in ( 1 , 10001 ) : <NEWLINE> c = a == b <NEWLINE> <NL> <NL>
m = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> c = 0 <NEWLINE> <NL> <NL> <INDENT> for i in xrange ( m [ 0 ] , m [ 1 ] + 1 ) : <NEWLINE> <INDENT> if m [ 2 ] % i == 0 : <NEWLINE> <INDENT> c = c + 1 <NEWLINE> <DEDENT> <DEDENT> print c <NEWLINE> <DEDENT>
a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> array = [ ] <NEWLINE> l = b - a <NEWLINE> <NL> for i in range ( l ) : <NEWLINE> <INDENT> n = c % i ; i += 1 <NEWLINE> if n == 0 : <NEWLINE> <INDENT> array . append ( i ) <NEWLINE> print ( len ( array ) ) <NEWLINE> <NL> <DEDENT> <DEDENT>
import sys <NEWLINE> num = sys . maxint <NEWLINE> for i in range ( num ) : <NEWLINE> <INDENT> for j in range ( num ) : <NEWLINE> <INDENT> for k in range ( num ) : <NEWLINE> <INDENT> print <STRING> * num <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
a , b , c = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> ans = [ ] <NEWLINE> for i in range ( a , b + 1 ) : <NEWLINE> <INDENT> if c % i == 0 : <NEWLINE> <INDENT> ans . append ( i ) <NEWLINE> <DEDENT> <DEDENT> return ans <NEWLINE>
a , b , c = map ( i , input ( ) . split ( ) ) <NEWLINE> ret = 0 <NEWLINE> for i in range ( a , b + 1 ) : <NEWLINE> <INDENT> if c % i == 0 : <NEWLINE> <INDENT> ret += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ret ) <NEWLINE>
a , b , c = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> n = 0 <NEWLINE> <NL> for i in range ( a , b + 1 ) : <NEWLINE> <INDENT> if c % i == 0 <NEWLINE> <INDENT> n = n + 1 <NEWLINE> <DEDENT> <DEDENT> print n <NEWLINE>
a , b , c = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> lst = [ ] <NEWLINE> for i in range ( a , b + 1 ) : <NEWLINE> <INDENT> if c % i == 0 : <NEWLINE> <INDENT> lst . append ( i ) <NEWLINE> <DEDENT> <DEDENT> return len ( lst ) <NEWLINE>
a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> d = [ i for i in range ( a , b + 1 ) ] <NEWLINE> count = 0 <NEWLINE> for i in range ( len ( d ) ) : <NEWLINE> <INDENT> if c % i == 0 : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
a , b , c = [ input ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> total = 0 <NEWLINE> for d in range ( a , b + 1 ) : <NEWLINE> <INDENT> if c % d == 0 : <NEWLINE> <INDENT> total += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( total ) <NEWLINE>
( a , b , c ) = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> count = 0 <NEWLINE> for i in range ( a , b ) : <NEWLINE> <INDENT> if c % n == 0 : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
a , b , c = map ( int , raw ( input ( ) . split ) <NEWLINE> print len ( [ x for x in range ( a , b + 1 ) if c % x == 0 ] ) <NEWLINE>
a , b , c = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> total = 0 <NEWLINE> for d in range ( a , b + 1 ) : <NEWLINE> <NL> <INDENT> if c % d == 0 : <NEWLINE> total += 1 <NEWLINE> <NL> <DEDENT> print ( total ) <NEWLINE>
<INDENT> a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> count = 0 <NEWLINE> for i in range ( a , b ) : <NEWLINE> <INDENT> if c % i == 0 : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE> <DEDENT>
i = 0 <NEWLINE> while True : <NEWLINE> <INDENT> a , b , c = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for d in range ( a , b + 1 ) : <NEWLINE> <INDENT> if ( c % d == 0 ) : <NEWLINE> <INDENT> i += 1 <NEWLINE> <DEDENT> <DEDENT> print ( str ( i ) ) <NEWLINE> <DEDENT>
a , b , c = [ int ( i ) for i in input ( ) . split ( ) ) <NEWLINE> <NL> total = 0 <NEWLINE> for d in range ( a , b + 1 ) : <NEWLINE> <NL> <INDENT> if c % d == 0 : <NEWLINE> <INDENT> total += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( total ) <NEWLINE>
a , b , c = [ int ( i ) for i in raw_input ( ) ] <NEWLINE> num = 0 <NEWLINE> for i in range ( a , b + 1 ) : <NEWLINE> <INDENT> if c % i == 0 : <NEWLINE> <INDENT> num += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print num <NEWLINE>
a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if 1 <= a , b , c <= 10000 and a <= b : <NEWLINE> <INDENT> l = [ i for i in range ( a , b + 1 ) if c % a == 0 ] <NEWLINE> <DEDENT> print ( len ( l ) ) <NEWLINE>
a , b , c = map ( int , input ( ) . split ( ) ) ) <NEWLINE> cnt = 0 <NEWLINE> for i in range ( a , b + 1 , 1 ) : <NEWLINE> <INDENT> if ( c % i == 0 ) : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
i = 0 <NEWLINE> a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> for x in range ( a + 1 , b ) <NEWLINE> <INDENT> if c % x == 0 : i += 1 <NEWLINE> <DEDENT> print ( i ) <NEWLINE>
a , b , c = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> <NL> for x in range ( a , b ) : <NEWLINE> <INDENT> if c % x == 0 : <NEWLINE> <INDENT> print x <NEWLINE> i += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print i <NEWLINE>
( a , b , c ) = ( int ( i ) for i in input ( ) . sprit ( ) ) <NEWLINE> <NL> count = 0 <NEWLINE> <NL> for i in range ( a , b + 1 ) : <NEWLINE> <INDENT> if c % i == 0 : <NEWLINE> <INDENT> count += 1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> j = 0 <NEWLINE> while i in range ( a , b + 1 ) <NEWLINE> <INDENT> if c % i == 0 : <NEWLINE> <INDENT> j += 1 <NEWLINE> <DEDENT> <DEDENT> print ( j ) <NEWLINE> <NL>
a , b , c = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> <NL> sum = 0 <NEWLINE> <NL> for i in len ( a , b ) : <NEWLINE> <INDENT> if c % a == 0 : <NEWLINE> <INDENT> sum = sum + 1 <NEWLINE> <DEDENT> <DEDENT> print <STRING> <NEWLINE>
a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> for i in range ( a , b ) : <NEWLINE> <INDENT> if i % c == 0 : <NEWLINE> <INDENT> result += str ( c ) + <STRING> <NEWLINE> <DEDENT> <DEDENT> print ( result ) <NEWLINE>
count = 0 <NEWLINE> a = b = c = <STRING> <NEWLINE> <NL> <NL> line = input ( ) <NEWLINE> <NL> while line [ i ] != <STRING> : <NEWLINE> <INDENT> a = a + line [ i ] <NEWLINE> i += 1 <NEWLINE> <NL> <DEDENT> i += 1 <NEWLINE> while line [ i ] != <STRING> : <NEWLINE> <INDENT> b = b + line [ i ] <NEWLINE> i += 1 <NEWLINE> <NL> <DEDENT> i += 1 <NEWLINE> while i < len ( line ) : <NEWLINE> <INDENT> c = c + line [ i ] <NEWLINE> i += 1 <NEWLINE> <NL> <DEDENT> a = int ( a ) <NEWLINE> b = int ( b ) <NEWLINE> c = int ( c ) <NEWLINE> <NL> while a <= b : <NEWLINE> <INDENT> if c % a == 0 : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> a += 1 <NEWLINE> <NL> <DEDENT> print ( count ) <NEWLINE>
a , b , c = map ( int , input ( ) . aplit ( ) ) <NEWLINE> print ( len ( [ x for x in range ( a , b + 1 ) if c % x == 0 ] ) ) <NEWLINE>
a , b , c = map ( int , input_raw ( ) . split ( ) ) <NEWLINE> sum = 0 <NEWLINE> <NL> for i in range ( a , b + 1 ) : <NEWLINE> <INDENT> if c % i == 0 : <NEWLINE> <INDENT> sum = sum + 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print sum <NEWLINE>
a , b , c = map ( int , Input ( ) . split ( ) ) <NEWLINE> <NL>
a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> n = 0 <NEWLINE> for i in range ( a , b + 1 ) : if c % i == 0 : n += 1 <NEWLINE> print ( n ) <NEWLINE>
count = 0 <NEWLINE> a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> for i in range ( a , b + 1 ) <NEWLINE> <INDENT> if c % i == 0 : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> count = 1 <NEWLINE> <NL> for i in range ( a , b + 1 ) : <NEWLINE> <INDENT> if c % i = 0 : <NEWLINE> <INDENT> count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
( a , b , c ) = ( int ( i ) for i in input ( ) . split ( ) ) <NEWLINE> count = 0 <NEWLINE> for i in range ( a , ( b + 1 ) ) <NEWLINE> <INDENT> if c % i == 0 : <NEWLINE> <INDENT> count + 1 <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
a , b , c = ( int ( i ) for i in input ( ) . split ( ) ) <NEWLINE> divisor = 0 <NEWLINE> for i in range ( a , b + 1 ) : <NEWLINE> <INDENT> if c % i == 0 : <NEWLINE> <INDENT> divisor += 1 <NEWLINE> <DEDENT> <DEDENT> print ( str ( divicor ) ) <NEWLINE>
a , b , c = [ input ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> total = 0 <NEWLINE> for d in range ( a , b + 1 ) : <NEWLINE> <INDENT> if c % d == 0 : <NEWLINE> <INDENT> total += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( total ) <NEWLINE>
a , b , c = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> count = 0 <NEWLINE> a = < b <NEWLINE> <NL> for x in range ( a , b ) : <NEWLINE> <INDENT> if c % x == 0 : <NEWLINE> <INDENT> count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
a , b , c = map ( int , raw_input ( ) . split ) <NEWLINE> <NL> count = 0 <NEWLINE> for x in range ( a , b + 1 ) : <NEWLINE> <INDENT> if c % x == 0 : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> for i in range ( a , b + 1 ) : <NEWLINE> <INDENT> if c % i == 0 : <NEWLINE> <INDENT> count = int ( count + 1 ) <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE> <NL>
my_value = input ( ) <NEWLINE> my_value_list = ( [ int ( x ) for x in my_value . split ( ) ] ) <NEWLINE> <NL> count = 0 <NEWLINE> for i in range ( my_value_list [ 0 ] , my_value_list [ 1 ] + 1 ) : <NEWLINE> <INDENT> if my_value_list [ ] % i == 0 : <NEWLINE> <INDENT> count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> count = 0 <NEWLINE> while a <= b : <NEWLINE> <INDENT> if c % a == 0 : <NEWLINE> <INDENT> count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
a , b , c = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> total = 0 <NEWLINE> for d in range ( a , b + 1 ) <NEWLINE> <INDENT> if c % d == 0 : <NEWLINE> <INDENT> total += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( total ) <NEWLINE>
a , b , c = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> <NL> if a == b and a == c : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> ptn = 1 <NEWLINE> <NL> <DEDENT> if a == b and a != c : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> ptn = 2 <NEWLINE> <NL> <DEDENT> cnt = 0 <NEWLINE> <NL> for i in range ( a , b ) : <NEWLINE> <INDENT> if c % i == 0 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if ptn != 1 and ptn != 2 : <NEWLINE> <INDENT> print ( cnt ) <NEWLINE> <DEDENT>
n = 0 <NEWLINE> a , b , c = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i in range ( a , b ) : <NEWLINE> <INDENT> if true : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> x = c % i <NEWLINE> if x == 0 : <NEWLINE> <INDENT> n += 1 <NEWLINE> <DEDENT> <DEDENT> print ( n ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> d = a // b <NEWLINE> r = a % b <NEWLINE> f = float ( a / b ) <NEWLINE> print ( <STRING> ) <NEWLINE>
list1 = input ( ) . split ( <STRING> ) <NEWLINE> list1 = list ( map ( int , list1 ) ) <NEWLINE> a = list1 [ 0 ] <NEWLINE> b = list1 [ 1 ] <NEWLINE> <NL> <NL> ans1 = a // b <NEWLINE> ans1 = str ( ans1 ) <NEWLINE> ans2 = a % b <NEWLINE> ans2 = str ( ans2 ) <NEWLINE> ans3 = a / b <NEWLINE> ans3 = str ( ans3 ) <NEWLINE> <NL> print ( <STRING> . format ( ans1 , ans2 , ans3 ) ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( a / / b , a % b , float ( a / b ) ) <NEWLINE>
a , b = map ( int , input ( ) , split ( ) ) <NEWLINE> print ( a // b , a % b , a / b ) <NEWLINE>
a , b = [ int ( n ) for n in src . readline ( ) . split ( ) ] <NEWLINE> print ( <STRING> % ( a // b , a % b , a / b ) ) <NEWLINE>
<COMMENT> <NL> <NL> l = input ( ) . split ( ) <NEWLINE> <NL> a = int ( l [ 0 ] ) <NEWLINE> b = int ( l [ 1 ] ) <NEWLINE> <NL> <NL> <NL> if 1 <= a and b <= 10 * 9 : <NEWLINE> <INDENT> d = a / b <NEWLINE> r = a % b <NEWLINE> f = float ( a ) / b <NEWLINE> <NL> print <STRING> % ( d , r , f ) <NEWLINE> <DEDENT>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( <STRING> . format ( a // b , a % b , ( a / b ) ) <NEWLINE>
deglist = raw_input ( ) . split ( <STRING> ) <NEWLINE> a = int ( deglist [ 0 ] ) <NEWLINE> b = int ( deglist [ 1 ] ) <NEWLINE> <NL> d = a / b <NEWLINE> r = a % b <NEWLINE> f = 1.0 * a / b <NEWLINE> <NL> print ( <STRING> . format ( d , r , f ) ) <NEWLINE>
a , b = [ int ( i ) for i in input ( ) . split ( <STRING> ) ] <NEWLINE> num1 = int ( a / b ) <NEWLINE> num2 = a % b <NEWLINE> num3 = <STRING> . format ( a / b ) <NEWLINE> <NL> print ( a , b , c ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( a // b , a % b , { : .10 f } . format ( a / b ) ) <NEWLINE>
a , b = input ( ) . split ( ) <NEWLINE> a = int ( a ) <NEWLINE> b = int ( b ) <NEWLINE> a // b = d <NEWLINE> d = int ( d ) <NEWLINE> a % b = r <NEWLINE> r = int ( r ) <NEWLINE> a / b = f <NEWLINE> f = float ( f ) <NEWLINE> print ( d , r , f ) <NEWLINE>
a = input ( ) <NEWLINE> b = input ( ) <NEWLINE> <NL> q = a / b <NEWLINE> r = a % b <NEWLINE> q_f = float ( a ) / float ( b ) <NEWLINE> <NL> print q , r , q_f <NEWLINE>
from decimal import * <NEWLINE> a , b = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> d = a / b <NEWLINE> r = a % b <NEWLINE> Decimal ( f ) = Decimal ( a ) / Decimal ( b ) <NEWLINE> print <STRING> . format ( d , r , Decimal ( f ) ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( <STRING> % ( a / b , a % b , a / b ) ) <NEWLINE>
a , b = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> c = a / b <NEWLINE> d = a % b <NEWLINE> e = float ( a ) / float ( b ) <NEWLINE> print ( <STRING> % ( c , d , e ) <NEWLINE>
a , b = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> print <STRING> % ( a , b , a , b , a / float ( b ) ) <NEWLINE>
<NL> nums = [ int ( e ) for e in input ( ) . split ( ) ] <NEWLINE> a = int ( nums [ 0 ] / nums [ 1 ] ) <NEWLINE> b = int ( nums [ 0 ] % nums [ 1 ] ) <NEWLINE> c = decimaru ( nums [ 0 ] / nums [ 1 ] ) <NEWLINE> print ( a , b , c ) <NEWLINE>
a , b = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> d = a // b <NEWLINE> r = a % b <NEWLINE> r = a / b <NEWLINE> <NL> print ( <STRING> . format ( d , r , f ) ) <NEWLINE>
a , b = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> c = double ( a ) <NEWLINE> d = double ( b ) <NEWLINE> <NL> print <STRING> % ( a / b , a % b , c / d ) <NEWLINE>
a , b = map ( input ( ) . split ( ) ) <NEWLINE> print ( a // b ) <NEWLINE> print ( a % b ) <NEWLINE> print ( a / b ) <NEWLINE>
a , op , b = map ( str , input ( ) . split ( ) ) <NEWLINE> a = int ( a ) <NEWLINE> b = int ( b ) <NEWLINE> <NL> print ( <STRING> , a / b , a % b , a / b ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> x = a // b <NEWLINE> y = a % b <NEWLINE> g = a / b <NEWLINE> print ( <STRING> , format ( x , y , g ) ) <NEWLINE>
z = input ( ) <NEWLINE> a = list ( map ( int , z . split ( ) ) ) <NEWLINE> print ( <STRING> format ( a [ 0 ] // a [ 1 ] , a [ 0 ] % a [ 1 ] , a [ 0 ] / a [ 1 ] ) ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> d = a // b <NEWLINE> r = a % b <NEWLINE> f = float ( a ) / float ( b ) <NEWLINE> <NL> print ( <STRING> . format ( d , r , f ) ) <NEWLINE>
a , b = ( int ( x ) for x in input ( ) . split ( ) ) <NEWLINE> <NL> d = a // b <NEWLINE> r = a % b <NEWLINE> ( float ) f = ( float ) a / ( float ) b <NEWLINE> <NL> print ( str ( d ) + <STRING> + str ( r ) + <STRING> + str ( f ) ) <NEWLINE> <NL>
mport sys <NEWLINE> a , b = map ( int , sys . stdin . readline ( ) . split ( ) ) <NEWLINE> <NL> d = a % b <NEWLINE> r = a - b * d <NEWLINE> f = a / b <NEWLINE> <NL> print ( d , r , f ) <NEWLINE>
def getCal ( a , b ) : <NEWLINE> <INDENT> return a // b , a % b , float ( a / b ) <NEWLINE> <NL> <DEDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> d , r , f = getCal ( a , b ) <NEWLINE> <NL> print ( <STRING> . format ( d , r , f ) ) <NEWLINE>
a , b = map ( int , raw_input ( ) ) <NEWLINE> print a / b , a % b , float ( a ) / b <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( a // b a % b a / b ) <NEWLINE>
S = raw_input ( ) . split ( <STRING> ) <NEWLINE> S [ 0 ] = int ( S [ 0 ] ) <NEWLINE> S [ 1 ] = int ( S [ 1 ] ) <NEWLINE> <NL> d = str ( S [ 0 ] / S [ 1 ] ) <NEWLINE> r = str ( S [ 0 ] % S [ 1 ] ) <NEWLINE> f = str ( 1.0 * S [ 0 ] / S [ 1 ] ) <NEWLINE> <NL> print ( d + <STRING> + r + <STRING> + format ( f , <STRING> ) ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> d = a // b <NEWLINE> r = a % b <NEWLINE> f = a / b <NEWLINE> <NL> print ( <STRING> . format ( d , r , f ) ) <NEWLINE> <NL>
s = input ( ) . split ( ) <NEWLINE> a , b = int ( s [ 0 ] ) , int ( s [ 1 ] ) <NEWLINE> print ( <STRING> . format ( a // b , a % b , a / b ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> d = ( int ) a / b <NEWLINE> r = a % b <NEWLINE> f = a / b <NEWLINE> print ( <STRING> % ( d , r , f ) ) <NEWLINE> <NL>
a , b = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> d = a / b <NEWLINE> r = a % b <NEWLINE> f = float ( a / b ) <NEWLINE> print % d , % d , % f , % ( d , r , f ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( <STRING> % a // b , a % b , a / b ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> d = str ( a // b ) <NEWLINE> r = str ( a % b ) <NEWLINE> f = str ( a / b ) <NEWLINE> print ( <STRING> . format ( d , r , f ) ) <NEWLINE>
import math <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> data = [ ] <NEWLINE> n = input ( ) . split ( ) <NEWLINE> a = int ( n [ 0 ] ) <NEWLINE> b = int ( n [ 1 ] ) <NEWLINE> <NL> divans = a / b <NEWLINE> intdiv = int ( divans ) <NEWLINE> divr = a % b <NEWLINE> <NL> print ( <STRING> . format ( intdiv , divr , divans ) ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
a , b = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> print <STRING> % ( a / b , a % b , ( double ) a / b ) <NEWLINE>
x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> d = x // y <NEWLINE> r = x % y <NEWLINE> f = x / y <NEWLINE> print ( <STRING> ) <NEWLINE> <NL>
while True : <NEWLINE> <INDENT> i = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if i [ 1 ] == 0 : break <NEWLINE> else : print i [ 0 ] / i [ 1 ] , i [ 0 ] % i [ 1 ] , float ( i [ 0 ] ) / i [ 1 ] <NEWLINE> <DEDENT>
a , b = [ float ( i ) for i in input ( ) . split ( ) ] <NEWLINE> d = int ( a / b ) <NEWLINE> r = int ( a ) % int ( b ) <NEWLINE> f = a / b <NEWLINE> f2 = round ( decimal . Decimal ( f ) , 10 ) <NEWLINE> print ( str ( d ) + <STRING> + str ( r ) + <STRING> + str ( f2 ) ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> d = a // b <NEWLINE> r = a % b <NEWLINE> f = float ( a / b ) <NEWLINE> print ( <STRING> . format ( d , r , f ) ) <NEWLINE>
print ( a // b , a % b , <STRING> . format ( a / b ) ) <NEWLINE>
a , b = list ( map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> d = a // b <NEWLINE> r = a % b <NEWLINE> f = a / b <NEWLINE> <NL> print ( d , r , f ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( a // b , a % b . <STRING> . format ( a / b ) ) <NEWLINE>
x = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a , b = x [ 0 ] , x [ 1 ] <NEWLINE> print ( str ( a // b ) + <STRING> + str ( a % b ) + <STRING> <NEWLINE>
( a , b ) = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> d = a // b <NEWLINE> r = a % b <NEWLINE> f = a / b <NEWLINE> <NL> <NL> print ( <STRING> % ( d , r , f ) ) <NEWLINE>
a , b = map ( int , raw_input ( ) ) <NEWLINE> d = a / b <NEWLINE> r = a % b <NEWLINE> f = 1.0 * a / b <NEWLINE> print d , r , f <NEWLINE>
a , b ) = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> while True : <NEWLINE> <INDENT> d = a // b <NEWLINE> r = a % b <NEWLINE> f = a / b <NEWLINE> print ( <STRING> . format ( d , r , f ) ) <NEWLINE> break <NEWLINE> <DEDENT>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( <STRING> . format ( a // b , a % b , a / b ) ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <NL> print ( <STRING> . format ( int ( a // b ) , int ( a % b ) , float ( a / b ) ) ) <NEWLINE> <NL>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> <INDENT> 2 print ( <STRING> . format ( a // b , a % b , a / b ) ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> a , b = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> print <STRING> % ( a / b , a % b , ( float ) a / b ) <NEWLINE>
a , b = list ( map ( int , input ( ) . split ) ) <NEWLINE> <NL> d = int ( a / b ) <NEWLINE> r = a % b <NEWLINE> f = a / b <NEWLINE> <NL> print ( d , r , f ) <NEWLINE>
l = raw_input ( ) <NEWLINE> k = l . split ( ) <NEWLINE> a = 0.0 <NEWLINE> b = 0.0 <NEWLINE> a = int ( k [ 0 ] ) <NEWLINE> b = int ( k [ 1 ] ) <NEWLINE> <COMMENT> <NL> print int ( ( a - ( a % b ) ) / b ) , <NEWLINE> print int ( a % b ) , <NEWLINE> a *= 1.0 <NEWLINE> b *= 1.0 <NEWLINE> if b == 1 : <NEWLINE> <INDENT> print a * 1.0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if a / b > 0.0000002 : <NEWLINE> <INDENT> print a / b <NEWLINE> <DEDENT> else : print 0.00000001 .99999982 <NEWLINE> <DEDENT>
a , b = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> <NL> print ( <STRING> % ( a // b , a % b , a / float ( b ) ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> d = a // b <NEWLINE> r = a % b <NEWLINE> f = a / b <NEWLINE> <NL> print ( <STRING> . format ( d , r , f ) ) <NEWLINE>
i = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> print ( <STRING> . format ( i [ 0 ] // i [ 1 ] , i [ 0 ] % i [ 1 ] , float ( i [ 0 ] ) / float ( i [ 1 ] ) ) <NEWLINE>
import math <NEWLINE> nums = list ( map ( int , input ( ) . split ( ) ) <NEWLINE> a = nums [ 0 ] <NEWLINE> b = nums [ 1 ] <NEWLINE> print ( a // b ) <NEWLINE> print ( a % b ) <NEWLINE> print ( float ( a / b ) ) <NEWLINE>
a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> count = 0 <NEWLINE> for i in range ( a , b + 1 ) : <NEWLINE> <INDENT> if c % i == 0 : <NEWLINE> <INDENT> count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> ( a , b ) = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> print <STRING> % ( a / b , a % b , a / float ( b ) ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
a , b = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> d = int ( a / b ) <NEWLINE> r = a % b <NEWLINE> float ( f ) = float ( a ) / b <NEWLINE> <NL> print <STRING> , d , r , f <NEWLINE>
input ( ) <NEWLINE> data = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> print ( min ( data ) , max ( data ) , sum ( data ) ) <NEWLINE>
while True : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if a <= 0 or b <= 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> elif a > 10 ** 9 or b > 10 ** 9 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d = int ( a / b ) <NEWLINE> r = int ( a % b ) <NEWLINE> f = float ( a / b ) <NEWLINE> print ( d , r , <STRING> . format ( f ) ) <NEWLINE> <DEDENT> <DEDENT>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> int d = a / b <NEWLINE> r = a % b <NEWLINE> f = a / b <NEWLINE> <NL> print ( d , r , f ) <NEWLINE>
x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> print ( int ( x / y ) , x % y , double ( x / y ) ) <NEWLINE> <NL> <NL>
list = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> print list [ 0 ] / list [ 1 ] , list [ 0 ] % list [ 1 ] , <STRING> % ( 1.0 * list [ 0 ] / list [ 1 ] ) <NEWLINE>
[ a , b ] = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> print ( a // b ) <NEWLINE> print ( a % b ) <NEWLINE> print ( { : .5 f } . format ( a / b ) ) <NEWLINE>
a , b = int ( input ( ) ) <NEWLINE> <NL> d = a // b <NEWLINE> r = a % b <NEWLINE> f = a / b <NEWLINE> <NL> print ( d , r , f ) <NEWLINE>
a , b = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> d = a // b <NEWLINE> r = a % b <NEWLINE> f = a / b <NEWLINE> <NL> print ( <STRING> . format ( d , r , f ) <NEWLINE>
a , b , c = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> d = a / b <NEWLINE> r = a % b <NEWLINE> A = float ( a ) <NEWLINE> B = float ( b ) <NEWLINE> f = A / B <NEWLINE> print <STRING> % ( d , r , f ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> s = a // b <NEWLINE> r = a % b <NEWLINE> f = a / b <NEWLINE> print ( s , r , double ( f ) ) <NEWLINE>
a , b = gets . split . map ( & : to_i ) <NEWLINE> printf <STRING> , a / b , a % b , a . to_f / b <NEWLINE>
x , y , z = input ( ) . split ( ) <NEWLINE> a = int ( x ) <NEWLINE> b = int ( y ) <NEWLINE> c = int ( z ) <NEWLINE> <NL> count = 0 <NEWLINE> num = a <NEWLINE> <NL> while num <= b : <NEWLINE> <INDENT> if c % num == 0 : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> num += 1 <NEWLINE> <NL> <DEDENT> print ( count ) <NEWLINE>
a , b = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> d = a / b <NEWLINE> r = a % b <NEWLINE> f = a // b <NEWLINE> <NL> print ( d r f ) <NEWLINE>
( a , b ) = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> <NL> x = a // b <NEWLINE> y = a % b <NEWLINE> z = a / b <NEWLINE> <NL> print ( <STRING> . format ( x , y , z ) ) <NEWLINE>
a , b = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> print ( <STRING> , % ( a // b , a % b , a / float ( b ) ) ) <NEWLINE>
a , b = map ( float , input ( ) . split ( ) ) <NEWLINE> print ( a // b , a % b , <STRING> . format ( a / b ) ) <NEWLINE>
a , b = int ( input ( ) . split ( <STRING> ) ) <NEWLINE> d = a // b <NEWLINE> r = a % b <NEWLINE> f = a / b <NEWLINE> <NL> print ( d , r , f , sep = <STRING> ) <NEWLINE>
import sys <NEWLINE> <NL> a , b = [ int ( val ) for val in sys . stdin . readline ( ) . split ( <STRING> ) ] <NEWLINE> print ( <STRING> . format ( a / b , a % b , float ( a ) / float ( b ) ) ) <NEWLINE>
a , b = input ( ) . split ( ) <NEWLINE> <NL> a = int ( a ) <NEWLINE> b = int ( b ) <NEWLINE> <NL> d = a // b <NEWLINE> r = a % b <NEWLINE> f = a / b <NEWLINE> <NL> fmt = <STRING> <NEWLINE> s = fmt . <NEWLINE> format ( v = d , c = r , n = f ) <NEWLINE> print ( s ) <NEWLINE>
a , b = [ int ( e ) for e in input ( ) . split ( ) ] <NEWLINE> print ( <STRING> . format ( a // b , a % b , a / b ) ) <NEWLINE>
a , b = map ( double , raw_input ( ) . split ( ) ) <NEWLINE> <NL> print <STRING> % ( a / b , a % b , a / b ) <NEWLINE>
a , b = [ int ( i ) for in input ( ) . split ( ) ] <NEWLINE> print ( a // b , int ( a % b ) , float ( a % b ) ) <NEWLINE>
( a , b ) = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> d = int ( a / b ) <NEWLINE> r = a % b <NEWLINE> f = a / b <NEWLINE> print ( <STRING> % ( d , r , f ) ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( , a // b , a % b , <STRING> ) <NEWLINE>
<COMMENT> <NL> <NL> import sys <NEWLINE> <NL> num = str ( raw_input ( ) ) . split ( <STRING> ) <NEWLINE> <NL> a = int ( num [ 0 ] ) <NEWLINE> b = int ( num [ 1 ] ) <NEWLINE> <NL> d = a / b - a % b <NEWLINE> r = a % b <NEWLINE> float f = a / b <NEWLINE> <NL> print str ( d + <STRING> + r + <STRING> + f ) <NEWLINE> <NL> sys . exit ( ) <NEWLINE>
a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( int ( a / b ) , a % b , a / b ) <NEWLINE>
import math <NEWLINE> <NL> data = input ( ) . split ( ) <NEWLINE> a = int ( data [ 0 ] ) <NEWLINE> b = int ( data [ 1 ] ) <NEWLINE> <NL> d = math . float ( a / b ) <NEWLINE> r = a % b <NEWLINE> f = a / b <NEWLINE> <NL> print ( d , <STRING> , r , <STRING> , f ) <NEWLINE>
<COMMENT> <NL> <NL> a , b = ( int ( i ) for i in input ( ) . split ( ) ) <NEWLINE> <NL> print ( int ( a / b ) , end = <STRING> ) <NEWLINE> print ( a % b , end = <STRING> ) <NEWLINE> print ( <STRING> . format ( float ( a ) / float ( b ) ) ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) ) <NEWLINE> print ( <STRING> % ( a // b , a % b , a / b ) ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> ptint ( <STRING> . format ( a // b , a % b , a / b ) ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> d = int ( a / b ) <NEWLINE> r = a % b <NEWLINE> f = a / b <NEWLINE> print ( a , b , c ) <NEWLINE>
a , b = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> d = a // b <NEWLINE> r = a % b <NEWLINE> f = a / b <NEWLINE> <NL> print ( <STRING> . format ( d . r . f ) ) <NEWLINE>
print ( <STRING> . format ( <NEWLINE> <INDENT> ( lambda a , b : ( a // b , a % b , a / b ) ) ( <NEWLINE> <INDENT> * map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <DEDENT> <DEDENT>
x = input ( ) . split ( ) <NEWLINE> a = int ( x [ 0 ] ) <NEWLINE> b = int ( x [ 1 ] ) <NEWLINE> print ( <STRING> % ( a // b , a % b , a / b ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> d = a // b <NEWLINE> r = a % b <NEWLINE> f = a / b <NEWLINE> print ( d , r , <STRING> . format ) ( f ) <NEWLINE>
a , b , c = map ( int , input ( ) . split ( ) ) ; <NEWLINE> count = 0 ; <NEWLINE> for i in range ( a , b + 1 ) : <NEWLINE> <INDENT> d = c % i ; <NEWLINE> if d == 0 : <NEWLINE> <INDENT> count = count + 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> % count ) <NEWLINE>
a , b = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> <NL> d = a / b <NEWLINE> r = a % b <NEWLINE> f = float ( a ) / float ( b ) <NEWLINE> <NL> print <STRING> % d , r , f <NEWLINE>
<COMMENT> <NL> <NL> n = 0 <NEWLINE> a , b , c = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> for i in range ( a , b + 1 ) : <NEWLINE> <INDENT> if c % i == 0 : <NEWLINE> <INDENT> n += 1 <NEWLINE> <DEDENT> <DEDENT> print n <NEWLINE>
a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> sum = 0 <NEWLINE> result = 0 <NEWLINE> while b >= a : <NEWLINE> <INDENT> result = c % a <NEWLINE> if result == 0 : <NEWLINE> <INDENT> sum += 1 <NEWLINE> <DEDENT> a += 1 <NEWLINE> <DEDENT> print ( sum ) <NEWLINE> <NL>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( a // b , a % b , { : a / b } ) <NEWLINE>
inp = input ( ) . split <NEWLINE> inp = [ int ( x ) for x in inp ] <NEWLINE> print ( inp [ 0 ] / inp [ 1 ] , end = <STRING> ) <NEWLINE> print ( inp [ 0 ] % inp [ 1 ] , end = <STRING> ) <NEWLINE> print ( inp [ 0 ] / float ( inp [ 1 ] ) ) <NEWLINE>
a , b = map ( int , raw_input ( ) . split ( <STRING> ) ) <NEWLINE> d , r = divmod ( a , b ) <NEWLINE> f = a / b <NEWLINE> print ( <STRING> % ( d , r , f ) ) <NEWLINE>
a , b = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> print ( % d , % d , % f , % ( a // b , a % b , a / b ) ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> d = a // b <NEWLINE> r = a % b <NEWLINE> f = a / b <NEWLINE> print ( <STRING> . join ( map ( str [ d , r , f ] ) ) ) <NEWLINE>
a , b = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> d = a / b <NEWLINE> e = a % b <NEWLINE> print ( <STRING> % ( d , e , float ( a ) / float ( b ) ) <NEWLINE>
a , b = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> <NL> d = a / b <NEWLINE> r = a % b <NEWLINE> f = double ( a / b ) <NEWLINE> <NL> print <STRING> % ( d , r , f ) <NEWLINE>
( a , b ) = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> <NL> x = a // b <NEWLINE> y = a % b <NEWLINE> z = a / b <NEWLINE> <NL> print ( <STRING> . format ( x , y , z ) ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( int ( a // b ) , int ( a % b ) , float ( a / b ) <NEWLINE>
( a , b ) = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> <NL> di = a // b <NEWLINE> m = a % b <NEWLINE> df = a / b <NEWLINE> <NL> print ( <STRING> . format ( ) . di , m , df ) ) <NEWLINE>
a , b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> d = int ( a / b ) <NEWLINE> r = int ( a % b ) <NEWLINE> f = float ( a / b ) <NEWLINE> print ( <STRING> . format ( d , r , f ) ) <NEWLINE>
print ( int ( input ( ) ) / int ( input ( ) ) ) <NEWLINE>
( a , b ) = [ int ( i ) for i in input ( ) . split ( <STRING> ) ] <NEWLINE> print ( repr ( a // b ) + <STRING> + repr ( a % b ) + <STRING> + ( <STRING> % ( a / b ) ) <NEWLINE>
import sys <NEWLINE> for line in sys . stdin : <NEWLINE> <INDENT> p = line . strip ( <STRING> ) . index ( <STRING> ) <NEWLINE> a , b = line [ : p ] , line [ p + 1 : ] <NEWLINE> a , b = int ( a ) , int ( b ) <NEWLINE> print <STRING> % ( a / b , a % b , 1.0 * a / b ) <NEWLINE> <DEDENT>
( a , b ) = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <INDENT> d = int ( a / b ) <NEWLINE> r = a % b <NEWLINE> f = a / b <NEWLINE> print ( <STRING> % ( d , r , f ) ) <NEWLINE> <DEDENT>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> d = a / b <NEWLINE> r = a % b <NEWLINE> f = float ( a ) / b <NEWLINE> print ( { } , { } , { } . format ( d , r , f ) ) <NEWLINE>
[ a , b ] = map ( raw_input ( ) . split ( ) ) <NEWLINE> x = long ( a ) <NEWLINE> y = long ( b ) <NEWLINE> z = float ( x ) <NEWLINE> w = float ( y ) <NEWLINE> d = x / y <NEWLINE> r = x % y <NEWLINE> f = 1.0000 * z / y <NEWLINE> print d , r , f <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( a // b , a % b , <STRING> ( a / b ) ) <NEWLINE>
a , b = ( int , input ( ) . split ( ) ) <NEWLINE> print ( <STRING> . format ( a // b , a % b , a / b ) ) <NEWLINE> <NL>
a , b , c = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> d = a // b <NEWLINE> r = a % b <NEWLINE> f = a / b <NEWLINE> <NL> print ( <STRING> . format ( d , r , f ) ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( a // b , a % b , <STRING> / format ( a / b ) ) <NEWLINE>
m = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> a = m [ 0 ] <NEWLINE> b = m [ 1 ] <NEWLINE> <NL> d = a / b <NEWLINE> r = a % b <NEWLINE> f = l .0 * a / b <NEWLINE> <NL> print int ( d ) , int ( r ) , float ( f ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> d = a // b <NEWLINE> r = int ( a % b ) <NEWLINE> f = a / b <NEWLINE> print ( d , r , f , sep ( <STRING> ) ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( int ( a / b ) , a % b , <STRING> format ( a / b ) ) <NEWLINE>
nums = [ ] <NEWLINE> nums = input ( <STRING> ) . split ( ) <NEWLINE> print ( nums [ 0 ] // nums [ 1 ] , nums [ 0 ] % nums [ 1 ] , nums [ 0 ] / nums [ 1 ] ) <NEWLINE>
( a , b ) = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> <NL> x = a // b <NEWLINE> y = a % b <NEWLINE> z = a / b <NEWLINE> <NL> print ( <STRING> . format ( x , y , z ) ) ; <NEWLINE>
a , b = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> <NL> int ( d ) = a / b <NEWLINE> int ( r ) = a % b <NEWLINE> float ( f ) = a / b <NEWLINE> <NL> print <STRING> % ( d , r , f ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( <STRING> ) <NEWLINE>
a , b = map ( double , raw_input ( ) . split ( ) ) <NEWLINE> int x , y <NEWLINE> double z <NEWLINE> x = a / b <NEWLINE> y = a % b <NEWLINE> z = a / b <NEWLINE> print x y z <NEWLINE>
import math <NEWLINE> <NL> r = float ( input ( ) ) <NEWLINE> x = 2 * math . pi * r <NEWLINE> y = r / 2 * r / 2 * Math . pi <NEWLINE> <NL> print ( <STRING> . format ( x , y ) ) <NEWLINE>
import math <NEWLINE> <NL> r = input ( ) <NEWLINE> <NL> s = math . pi * r ** 2 <NEWLINE> l = 2.0 * pi * r <NEWLINE> <NL> print s , l <NEWLINE>
import math <NEWLINE> def main ( ) : <NEWLINE> <INDENT> r = [ int ( i ) for i in input ( ) . sprit ( ) ] <NEWLINE> print ( <STRING> % ( r ** 2 * math . pi , 2 * r * math . pi ) ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import math <NEWLINE> r = float ( input ( ) ) <NEWLINE> C = math . pi <NEWLINE> print ( <STRING> ) . format ( C * r ** 2 , C * 2 * r ) <NEWLINE>
import math <NEWLINE> r = double ( input ( ) ) <NEWLINE> print ( <STRING> . format ( r * r * math . pi ) , <STRING> . format ( r * 2 * math . pi ) ) <NEWLINE>
import math <NEWLINE> <NL> r = int ( raw_input ( ) ) <NEWLINE> s = float ( r ) * r * math . pi <NEWLINE> l = float ( r ) * 2 * math . pi <NEWLINE> print s , l <NEWLINE>
import numpy as np <NEWLINE> <NL> r = input ( ) <NEWLINE> <NL> a = r ** 2 * np . pi <NEWLINE> b = r * 2 * np . pi <NEWLINE> <NL> print a , b <NEWLINE>
import math <NEWLINE> i = float ( raw_input ( ) ) <NEWLINE> print <STRING> % ( i * i * math . pi , 2 * i * math . pi ) <NEWLINE>
r = float ( raw_input ( ) ) <NEWLINE> print <STRING> % ( r * r * pi , 2 * pi * r ) <NEWLINE>
r = float ( input ( ) ) <NEWLINE> p = 3.14159265 <NEWLINE> print ( p * r * r 2 * p * r ) <NEWLINE>
a = float ( input ( ) ) <NEWLINE> <NL> print ( a * a * pi , 2 * a * pi ) <NEWLINE>
import math <NEWLINE> a = int ( raw_input ( ) ) <NEWLINE> print a * 2 * math . pi , a * a * math . pi <NEWLINE>
r = float ( input ( ) ) <NEWLINE> print ( math . pi * ( r ** 2 ) , 2 * math . pi * r ) <NEWLINE>
import sys <NEWLINE> <NL> if __name__ == <STRING> : <NEWLINE> <INDENT> r = int ( sys . stdin . read ( ) ) <NEWLINE> pi = 3.14159265359 <NEWLINE> print <STRING> % ( pi * r * r , 2 * pi * r ) <NEWLINE> <DEDENT>
import math <NEWLINE> r == float ( input ( ) ) <NEWLINE> print ( r ** 2 * math . pi , r * 2 * math . pi ) <NEWLINE>
pi = 3.141592653589793 <NEWLINE> r = float ( input ( ) ) <NEWLINE> print ( <STRING> . format ( np . pi * r ** 2 , 2 * np . pi * r ) ) <NEWLINE>
r = float ( input ( ) ) <NEWLINE> <NL> s = r * r * math . pi <NEWLINE> l = r * 2 * math . pi <NEWLINE> <NL> print ( <STRING> % ( s , l ) ) <NEWLINE>
import math <NEWLINE> r = int ( raw_input ( ) ) <NEWLINE> print <STRING> % ( math . pi * r * r , 2 * math . pi * r ) <NEWLINE>
from math import pi <NEWLINE> r = int ( raw_input ( ) ) <NEWLINE> print ( <STRING> % ( pi * r ** 2 , 2 * pi * r ) ) <NEWLINE>
import math <NEWLINE> r = raw_input ( ) <NEWLINE> area = r * r * math . pi * 1.0 <NEWLINE> cir = 2 * r * math . pi * 1.0 <NEWLINE> print <STRING> % ( area , cir ) <NEWLINE>
import math <NEWLINE> <NL> r = float ( raw_input ( ) ) <NEWLINE> <NL> S = r ** 2 * pi <NEWLINE> R = 2 * r * pi <NEWLINE> <NL> print <STRING> % ( S , R ) <NEWLINE>
r = double ( input ( ) ) <NEWLINE> import math <NEWLINE> d = r * r * math . pi <NEWLINE> l = 2 * r * math . pi <NEWLINE> print ( <STRING> % ( d , l ) ) <NEWLINE>
r = int ( raw_input ( ) ) <NEWLINE> pi = 3.14159265358 <NEWLINE> <NL> s = r * r * pi <NEWLINE> l = 2 * r * pi <NEWLINE> <NL> print s , l <NEWLINE>
from math import pi <NEWLINE> r = float ( input ( ) ) <NEWLINE> print ( <STRING> . format ( r * r * math . pi , 2 * r * math . pi ) ) <NEWLINE> <NL>
<INDENT> r = float ( input ( ) ) <NEWLINE> x = 3.14159265359 * r * 2 <NEWLINE> y = 3.14159265359 * r ** 2 <NEWLINE> print ( <STRING> . format ( x , y ) ) <NEWLINE> <DEDENT>
r = int ( raw_input ( ) ) <NEWLINE> pai = 3.1415 <NEWLINE> print ( <STRING> % ( r * r * pai , 2 * pai * r ) ) <NEWLINE>
import math <NEWLINE> r = input ( ) <NEWLINE> <NL> print ( <STRING> % ( r * r * math . pi , 2 * r * math . pi ) ) <NEWLINE> <NL>
r = raw_input ( ) <NEWLINE> r = float ( r ) <NEWLINE> a = r * r * 3.141592653 <NEWLINE> b = 2 * r 3.141592653 <NEWLINE> print <STRING> % ( a , b ) <NEWLINE>
import math <NEWLINE> <NL> n = int ( raw_input ( ) ) <NEWLINE> print n * n * math . pi , 2 * n * math . pi <NEWLINE>
<COMMENT> <NL> import math <NEWLINE> n = list ( map ( float , input ( ) . split ( ) ) ) <NEWLINE> print ( <STRING> . format ( n [ 0 ] * n [ 0 ] * math . pi ) , n [ 0 ] * 2 * math . pi ) <NEWLINE>
import math <NEWLINE> r = int ( raw_input ( ) ) <NEWLINE> print r * r * math . pi , 2 * r * math . pi <NEWLINE>
import math <NEWLINE> <NL> r = float ( input ( ) ) <NEWLINE> <NL> a = r * r * pi <NEWLINE> <NL> b = 2 * pi * r <NEWLINE> <NL> print ( a , b ) <NEWLINE>
import math <NEWLINE> a = input ( ) <NEWLINE> pi = 3.1415926535897 <NEWLINE> print ( <STRING> . format ( pi * a * 2 , pi * a * a ) ) <NEWLINE>
import math <NEWLINE> r = float ( input ( ) ) <NEWLINE> a = r * r * math . pi ( ) <NEWLINE> b = 2 r * math . pi ( ) <NEWLINE> print ( a , b ) <NEWLINE>
from math import math <NEWLINE> print ( int ( input ( ) ) ** 2 * math . pi ) <NEWLINE>
pi = math . pi <NEWLINE> r = float ( input ( ) ) <NEWLINE> print ( <STRING> . format ( r * r * pi , 2 * r * pi ) ) <NEWLINE> <NL>
import math <NEWLINE> <NL> r = int ( raw_input ( ) ) <NEWLINE> l = math . pi * 2 * r <NEWLINE> s = math . pi * r * r <NEWLINE> print <STRING> % ( s , l ) <NEWLINE>
x = raw_input ( ) <NEWLINE> r = int ( x ) <NEWLINE> s = r * r * 3.14159265359 <NEWLINE> l = 2 * r * 3.14159265359 <NEWLINE> print <STRING> % ( s , l ) <NEWLINE>
from math import pi <NEWLINE> <NL> r = foat ( input ( ) ) <NEWLINE> <NL> s = pi * r * r <NEWLINE> <NL> p = 2 * pi * r <NEWLINE> <NL> print ( s , p ) <NEWLINE> <NL>
import math <NEWLINE> r = float ( input ( ) ) <NEWLINE> <NL> print ( math . PI * r ** 2 , 2 * math . PI * r ) <NEWLINE> <NL>
s = float ( i ) ** 2 * 3.14159265359 <NEWLINE> l = float ( i ) * 2 * 3.14159265359 <NEWLINE> print ( s , l ) <NEWLINE> <NL>
r = input ( ) <NEWLINE> a = r * r * math . pi <NEWLINE> b = 2 * r * math . pi <NEWLINE> print <STRING> % ( a , b ) <NEWLINE>
<NL> pi = 3.141592653589 <NEWLINE> <NL> r = float ( input ( ) ) <NEWLINE> <NL> print ( r * r * pi , 2 * pi * r <NEWLINE>
r = float ( input ( ) ) <NEWLINE> x = r * r * 3.14159265 <NEWLINE> y = r * 2 * 3.14159265 <NEWLINE> print ( <STRING> , format ( x , y ) ) <NEWLINE> <NL>
r = float ( input ( ) . split ( ) ) <NEWLINE> print ( <STRING> % ( r ** 2 * 3.14 , 2 * r * 3.14 ) ) <NEWLINE>
from math import pi <NEWLINE> r = ( int , input ( ) ) <NEWLINE> print ( <STRING> . format ( pi * r * r , 2 * pi * r ) ) <NEWLINE>
import math <NEWLINE> r = int ( raw_input ( ) ) <NEWLINE> V = r * r * math . pi <NEWLINE> S = 2 * r * math . pi <NEWLINE> <NL> print <STRING> % ( V , S ) <NEWLINE>
a , b = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> <NL> print ( <STRING> . format ( int ( a / b ) , a % b , a / b ) ) <NEWLINE>
<COMMENT> <NL> <NL> l = raw_input ( ) <NEWLINE> <NL> <NL> r = int ( l ) <NEWLINE> <NL> import math <NEWLINE> S = math . pi * r ** 2 <NEWLINE> <NL> C = 2 * math . pi * r <NEWLINE> <NL> print <STRING> % ( S , C ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> d = a // b <NEWLINE> r = a % b <NEWLINE> f = a / b <NEWLINE> print ( <STRING> . format ( d , r , f ) ) <NEWLINE>
import math <NEWLINE> <NL> r = float ( input ( ) ) <NEWLINE> area = math . pi * r * r <NEWLINE> circumference = 2 * math . pi * r <NEWLINE> print ( area , circumferene ) <NEWLINE>
import math <NEWLINE> <NL> r = imput ( ) <NEWLINE> <NL> print ( <STRING> % ( math . pi * r ** 2 , 2 * math . pi * r ) ) <NEWLINE>
from math import pi <NEWLINE> r = float ( input ( ) ) <NEWLINE> area = r * r * pi <NEWLINE> cir = ( r + r ) * pi <NEWLINE> print ( <STRING> ) <NEWLINE> <NL>
import math . pi <NEWLINE> <NL> r = float ( input ( ) ) <NEWLINE> <NL> s = math . pi * ( r ** 2 ) <NEWLINE> <NL> p = 2 * math . pi * r <NEWLINE> <NL> print ( s , p ) <NEWLINE> <NL>
import math <NEWLINE> <NL> r = floatinput ( ) ) <NEWLINE> <NL> print ( <STRING> ) <NEWLINE> <NL>
pi = 3.14159265358979324 <NEWLINE> m = 2 ** 1000 <NEWLINE> r_ = m * float ( input ( ) ) <NEWLINE> S = ( pi * r_ ** 2 ) / ( m ** 2 ) <NEWLINE> l = ( 2 * pi * r_ ) / m <NEWLINE> print S , <NEWLINE> print l <NEWLINE>
from math import pi <NEWLINE> <NL> r = float ( input ( ) ) <NEWLINE> area = lambda r : r * r * pi <NEWLINE> length = lambda r : r * 2 * pi <NEWLINE> <NL> print ( <STRING> . format ( length ( r ) , area ( r ) ) <NEWLINE>
import math <NEWLINE> r = float ( input ( ) ) <NEWLINE> print ( float ( r * r * pi ) , float ( 2 * r * pi ) ) <NEWLINE>
import sys <NEWLINE> <NL> pi = 3.141592653589 <NEWLINE> <NL> r = int ( raw_input ( ) ) <NEWLINE> <NL> area = r * r * pi <NEWLINE> length = 2 * r * pi <NEWLINE> <NL> print str ( area ) + <STRING> + str ( length ) + <STRING> <NEWLINE> <NL> sys . exit ( ) <NEWLINE>
from math import pi <NEWLINE> r = int ( raw_input ( ) ) <NEWLINE> print <STRING> % ( pi * r ** 2 , 2 * pi * r ) <NEWLINE>
import math <NEWLINE> <NL> r = flaot ( input ( ) ) <NEWLINE> <NL> <COMMENT> <NL> a = r * r * math . pi <NEWLINE> <NL> <COMMENT> <NL> b = 2 * r * math . pi <NEWLINE> <NL> print ( <STRING> % ( a , b ) ) <NEWLINE>
import math <NEWLINE> r = float [ input ( ) ] <NEWLINE> <NL> s = r * r * math . pi <NEWLINE> l = r * 2 * math . pi <NEWLINE> <NL> print ( <STRING> . format ( s , l ) ) <NEWLINE>
x = float ( input ( ) ) <NEWLINE> print ( <STRING> % ( x * x * 3.141592 , x * 2 * 3.141592 ) ) <NEWLINE>
import math <NEWLINE> r = float ( ) . input ( ) <NEWLINE> c = r * r * math . pi <NEWLINE> cf = r * 2 * math . pi <NEWLINE> print ( <STRING> . format ( c , cf ) ) <NEWLINE>
a = input ( ) <NEWLINE> a = float ( a ) <NEWLINE> <NL> p = math . pi <NEWLINE> <NL> b = a * a * p <NEWLINE> c = a * 2 * p <NEWLINE> print ( <STRING> % b , <STRING> % c ) <NEWLINE>
import math <NEWLINE> r = double ( input ( ) ) <NEWLINE> print ( <STRING> . format ( math . pi * r * r , math . pi * r * 2 ) ) <NEWLINE>
from math import pi //  <NEWLINE> r = float ( input ( ) ) <NEWLINE> area = r * r * pi <NEWLINE> cir = ( r + r ) * pi <NEWLINE> print ( <STRING> ) <NEWLINE>
r = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> pi = 3.14 <NEWLINE> s = float ( r ) * r * pi <NEWLINE> l = float ( r ) * 2 * pi <NEWLINE> <NL> print <STRING> % ( s , l ) <NEWLINE>
import sys <NEWLINE> import math <NEWLINE> <NL> class Circle : <NEWLINE> <INDENT> def output ( self , r ) : <NEWLINE> <INDENT> print <STRING> % ( math . pi * r * r , 2.0 * math . pi * r ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> cir = Circle ( ) <NEWLINE> r = int ( raw_input ( ) ) <NEWLINE> cir . output ( r ) <NEWLINE> <DEDENT>
import math <NEWLINE> r = input ( ) <NEWLINE> print <STRING> math . pi * ( r ** 2 ) , 2 * r * math . pi <NEWLINE>
import math <NEWLINE> <NL> r = float ( input ( ) ) <NEWLINE> x = math . pi <NEWLINE> <NL> print ( x * r * r + <STRING> + 2 * x ** r ) <NEWLINE>
imporot math <NEWLINE> r = float ( input ( ) ) <NEWLINE> <NL> print ( <STRING> % ( r * r * math . pi , 2 * r * math . pi ) ) <NEWLINE>
<COMMENT> <NL> <NL> import sys <NEWLINE> from math import pi <NEWLINE> <NL> <NL> def area_of_circle ( radius ) : <NEWLINE> <INDENT> return pi * radius ** 2 <NEWLINE> <NL> <NL> <DEDENT> def circumference_of_circle ( radius ) : <NEWLINE> <INDENT> return 2 * pi * radius <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> r = ( sys . stdin . readline ( ) ) <NEWLINE> print ( <STRING> % ( area_of_circle ( r ) , circumference_of_circle ( r ) ) ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
from math import pi <NEWLINE> <NL> r = floot ( input ( ) ) <NEWLINE> print ( <STRING> . format ( r * r * pi , 2 * r * pi ) ) <NEWLINE>
<COMMENT> <NL> from math import pi <NEWLINE> <NL> r = float ( input ( ) ) <NEWLINE> area = r ** 2 * pi <NEWLINE> circumference = r * pi * 2 <NEWLINE> <NL> print ( <STRING> . format ( area , circumference ) ) <NEWLINE>
r = int ( input ( ) ) <NEWLINE> import math <NEWLINE> print ( <STRING> % ( math . pi * r * r , math . pi * 2 * r ) ) <NEWLINE>
import math <NEWLINE> r = float ( input ( ) ) <NEWLINE> s = r * r * math . pi <NEWLINE> l = r * 2 * math . pi <NEWLINE> print ( <STRING> % ( s , l ) ) ( a , b ) <NEWLINE>
import math <NEWLINE> <NL> r = float ( input ( ) ) <NEWLINE> s = math . pai * r ** 2 <NEWLINE> l = 4 * math . pai * r ** 3 / 3 <NEWLINE> print ( s , l ) <NEWLINE> <NL>
import math <NEWLINE> r = float ( input ( ) ) <NEWLINE> <NL> s = r * r * math . pi <NEWLINE> l = r * 2 * math . pi <NEWLINE> <NL> print ( <STRING> format ( s , l ) ) <NEWLINE>
r = input ( ) <NEWLINE> S = r ** 2 * pi <NEWLINE> l = 2 * pi * r <NEWLINE> print ( <STRING> , format ( S , l ) ) <NEWLINE>
import math <NEWLINE> <NL> r = float ( raw_input ( ) ) <NEWLINE> print <STRING> . format ( math . pi * r * r , s * math . pi * r ) <NEWLINE>
r = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> print ( <STRING> ( float ( 2 * M_PI * r ) , float ( r * r * M_PI ) ) <NEWLINE>
import math <NEWLINE> <NL> r = input ( ) <NEWLINE> print ( r ** 2 * math . pi , r * 2 * math . pi ) <NEWLINE>
a = list ( map ( float , input ( ) . split ( ) ) ) <NEWLINE> print ( <STRING> ) <NEWLINE> <NL>
import sys <NEWLINE> import math <NEWLINE> <NL> r = float ( sys . stdin . readline ( ) ) <NEWLINE> print ( <STRING> % ( r ** 2 * math . pi , r * 2 * math , pi ) ) <NEWLINE>
string = input ( ) <NEWLINE> number = int ( string [ 0 ] ) <NEWLINE> print ( number ^ 2 * 3.14159 , number * 2 * 3.14159 ) <NEWLINE>
import math <NEWLINE> r = raw_input ( ) <NEWLINE> print <STRING> % ( r * r * math . pi , r * 2 * math . pi ) <NEWLINE>
r = input ( ) <NEWLINE> import math <NEWLINE> print ( <STRING> . format ( r ** 2 * math . pi , 2 * r * math . pi ) ) <NEWLINE>
a = map ( float , raw_input ( ) . split ( ) ) <NEWLINE> <NL> Pi = float ( 3.141592658979 ) <NEWLINE> <NL> print ( <STRING> % ( a * a * Pi , 2 * a * Pi ) ) <NEWLINE>
from math import pi <NEWLINE> r = float ( input ( ) ) <NEWLINE> area = r * r * pi <NEWLINE> cir = ( r + r ) * pi <NEWLINE> pirnt ( <STRING> ) <NEWLINE>
import ans1 <NEWLINE> import ans2 <NEWLINE> <NL> r = float ( ans1 . stdin . readline ( ) ) <NEWLINE> print ( <STRING> % ( r ** 2 * ans2 . pi , r * 2 * ans2 . pi ) ) <NEWLINE>
r = input ( ) <NEWLINE> <NL> s = r * r * 3.14159265358979 <NEWLINE> l = 2 * r * 3.14159265358979 <NEWLINE> <NL> print ( s , end = <STRING> ) <NEWLINE> print ( l ) <NEWLINE>
r = int ( raw_input ( ) ) <NEWLINE> <NL> menseki = r ** 2 * 3.141592 <NEWLINE> shuu = 2 * r * 3.141592 <NEWLINE> <NL> print ( <STRING> . format ( menseki , shuu ) ) <NEWLINE>
import math <NEWLINE> r = input ( ) <NEWLINE> m = r ** 2 * 3.14 <NEWLINE> l = r * 2 * 3.14 <NEWLINE> print ( <STRING> . format ( m , l ) ) <NEWLINE>
import math <NEWLINE> <NL> r = input ( ) <NEWLINE> <NL> <COMMENT> <NL> S = math . pi * r ** 2 <NEWLINE> <COMMENT> <NL> L = math . pi * r * 2 <NEWLINE> <NL> print <STRING> % ( S , L ) <NEWLINE>
import math <NEWLINE> print <STRING> % ( r * r * math . pi , 2 * r * math . pi ) <NEWLINE>
import math <NEWLINE> r = float ( input ( ) ) <NEWLINE> v = math . pi * r ^ 2 <NEWLINE> s = math . pi * r * 2 <NEWLINE> <NL> print ( <STRING> % ( v , s ) ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> import math <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> r = int ( raw_input ( ) ) <NEWLINE> print round ( math . pi * ( r ** 2 ) , 5 ) , round ( math . pi * 2 * r , 5 ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
<INDENT> r = float ( input ( ) ) <NEWLINE> <DEDENT> z = r * r * 3.141592 <NEWLINE> l = 2 * r * 3.141592 <NEWLINE> print ( <STRING> . format ( z , l ) ) <NEWLINE>
import math <NEWLINE> r = map ( float , raw_input ( ) ) <NEWLINE> a = r [ 0 ] * r [ 0 ] * math . pi <NEWLINE> b = 2 * r [ 0 ] * math . pi <NEWLINE> print <STRING> % ( a , b ) <NEWLINE>
import math <NEWLINE> r = float ( input ( ) ) <NEWLINE> print <STRING> % ( math . pi * r ^ 2 , 2 * math . pi * r ) <NEWLINE>
import math <NEWLINE> p = math . pi <NEWLINE> r = int ( input ( ) ) <NEWLINE> <NL> print ( <STRING> , format ( 2 * r * p , r * r * p ) ) <NEWLINE> <NL>
import math : <NEWLINE> <NL> r = float ( raw_input ( ) ) <NEWLINE> <NL> S = math . pi * r ** 2 <NEWLINE> l = 2 * r * math . pi <NEWLINE> <NL> print <STRING> % ( S , l ) <NEWLINE>
r = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> print r [ 0 ] * r [ 0 ] * 3.141592653589793 <NEWLINE> print r [ 0 ] * 2 * 3.141592653589793 <NEWLINE>
import math <NEWLINE> <NL> r = map ( float , input ( ) ) <NEWLINE> <NL> S = math . pi * r * r <NEWLINE> l = 2 * r * math . pi <NEWLINE> <NL> print ( <STRING> . format ( S , l ) ) <NEWLINE>
<COMMENT> <NL> from math import pi <NEWLINE> r = float ( raw_input ( ) . split ( ) ) <NEWLINE> print <STRING> . format ( pi * r * r , 2 * pi * r ) <NEWLINE>
from math import pi <NEWLINE> r = float ( input ( ) ) <NEWLINE> print ( format ( r ** 2 * pi , <STRING> ) , format ( r * pi * 2 , <STRING> ) ) <NEWLINE>
import math <NEWLINE> a = int ( raw_input ( ) ) <NEWLINE> <NL> b = ( pow ( a , 2 ) * math . pi ) <NEWLINE> c = 2 * a * math . pi <NEWLINE> print format ( b , <STRING> ) , format ( c , <STRING> ) <NEWLINE>
import sys <NEWLINE> import math <NEWLINE> <NL> value = int ( sys . stdin . readline ( ) ) <NEWLINE> <NL> print round ( math . pi * value * value , 7 ) , round ( 2.0 * math . pi * value , 7 ) <NEWLINE>
import math <NEWLINE> r = double ( input ( ) ) <NEWLINE> m = r * r * math . pi <NEWLINE> s = 2 * r * math . pi <NEWLINE> print ( m , s ) <NEWLINE>
r = float ( input ( ) ) <NEWLINE> <NL> l = 2 * math . pi * r <NEWLINE> s = r * r * math . pi <NEWLINE> <NL> print <STRING> % ( s , l ) <NEWLINE>
import math <NEWLINE> r = float ( input ( ) ) <NEWLINE> pi = math . pi <NEWLINE> s = ( r ** 2 ) * pi <NEWLINE> l = 2 * r * pi <NEWLINE> print s , l <NEWLINE>
import math <NEWLINE> r = input ( ) <NEWLINE> print <STRING> % ( math . pi * r * r , math . pi * r * 2 ) <NEWLINE>
from math import pi <NEWLINE> r = froat ( input ( ) ) <NEWLINE> s = pi * r * r <NEWLINE> l = 2 * pi * r <NEWLINE> print ( s , l ) <NEWLINE>
r = fload ( input ( ) ) <NEWLINE> import math <NEWLINE> print ( r ** 2 * math . pi , 2 * math . pi * r ) <NEWLINE>
import math <NEWLINE> <NL> PI = math . pi <NEWLINE> <NL> r = input ( ) <NEWLINE> <NL> area = float ( 2 * PI + r ) <NEWLINE> circumference = float ( PI * r * r ) <NEWLINE> print ( <STRING> . format ( area , circumference ) ) <NEWLINE>
r = float ( input ( ) ) <NEWLINE> <NL> s = r * r * math . pi <NEWLINE> l = r * 2 * math . pi <NEWLINE> <NL> print ( <STRING> format ( s , l ) ) <NEWLINE>
import math <NEWLINE> r = float ( input ( ) ) <NEWLINE> <NL> s = r * r * math . pi <NEWLINE> a = r * 2 * math . pi <NEWLINE> <NL> print ( <STRING> . format ( s , l ) ) <NEWLINE>
r = int ( raw_input ( ) ) <NEWLINE> p = 3.141592 <NEWLINE> print p * float ( r ) ** 2 , <NEWLINE> print 2.0 * p * float ( r ) <NEWLINE>
import math <NEWLINE> <NL> r = float ( input ( ) ) <NEWLINE> <NL> <NL> s = r * r * pi <NEWLINE> l = 2 * r * pi <NEWLINE> <NL> print ( <STRING> . format ( s , l ) ) <NEWLINE>
from math import pi <NEWLINE> <NL> r = float ( input ( ) ) <NEWLINE> print ( r * r * math . pi , 2 * r * math . pi ) <NEWLINE>
import math <NEWLINE> <NL> r = float ( input ( ) ) <NEWLINE> s = r * r * math . PI <NEWLINE> l = ( r + r ) * math . PI <NEWLINE> <NL> print ( <STRING> . format ( s , l ) ) <NEWLINE>
from math import pi <NEWLINE> r = int ( raw_input ( ) ) <NEWLINE> print <STRING> % ( pi * pow ( r , 2 ) , 2 * pi * r ) <NEWLINE>
import math <NEWLINE> <NL> r = float ( input ( ) ) <NEWLINE> <NL> s = r ** 2 * math . pi <NEWLINE> v = 2 * math . pi * r <NEWLINE> <NL> print ( <STRING> . format ( s , V ) ) <NEWLINE>
import math <NEWLINE> r = int ( raw_input ( ) ) <NEWLINE> a = round ( math . pi * r ** 2 , 6 ) <NEWLINE> l = round ( math . pi * r * 2 , 6 ) <NEWLINE> print a , <NEWLINE> print l <NEWLINE>
r = float ( input ( ) ) <NEWLINE> import math <NEWLINE> pi = round ( math . pi , 7 ) <NEWLINE> length = round ( r * 2 * pi , 6 ) <NEWLINE> area = round ( r ** 2 * pi , 6 ) <NEWLINE> print ( float ( length ) + <STRING> + float ( area ) ) <NEWLINE>
from math import pi <NEWLINE> r = float ( input ( ) ) <NEWLINE> print ( <STRING> . format ( r * r * pi , 2 * pi * r ) ) <NEWLINE> <NL> from math import pi <NEWLINE> <NL> r = float ( input ( ) ) <NEWLINE> <NL> print ( <STRING> . format ( r * r * pi , 2 * pi * r ) ) <NEWLINE>
<COMMENT> <NL> <NL> import math <NEWLINE> <NL> r = float ( raw_input ( ) ) <NEWLINE> print <STRING> % ( r * r * math . pi , 2 * r * mat . pi ) <NEWLINE>
import math <NEWLINE> <NL> k = int ( raw_input ( ) ) <NEWLINE> <NL> s = k * k * math . pi <NEWLINE> t = 2 * k * math . pi <NEWLINE> <NL> print <STRING> % ( s , t ) <NEWLINE>
import math <NEWLINE> <NL> r = float ( input ( ) ) <NEWLINE> <NL> s = r * r * pi <NEWLINE> x = 2 * r * pi <NEWLINE> <NL> print ( <STRING> . format ( s , x ) ) <NEWLINE> <NL>
o = int ( raw_input ( ) ) <NEWLINE> print o * o * 3.141592653589 , o * 2 * 3.141592653589 <NEWLINE>
import math <NEWLINE> <NL> r = float ( input ( ) ) <NEWLINE> <NL> print ( <STRING> ) <NEWLINE>
import < math . h > <NEWLINE> r = float ( input ( ) ) <NEWLINE> a = math . pi * r * r <NEWLINE> l = 2 * math . pi * r <NEWLINE> print ( <STRING> ) <NEWLINE> <NL>
a , op , b = input ( ) . split ( ) <NEWLINE> a = int ( a ) <NEWLINE> b = int ( b ) <NEWLINE> while True : <NEWLINE> <INDENT> if ( op is <STRING> ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> elif ( op is <STRING> ) : <NEWLINE> <INDENT> x = a + b <NEWLINE> <DEDENT> elif ( op is <STRING> ) : <NEWLINE> <INDENT> x = a - b <NEWLINE> <DEDENT> elif ( op is <STRING> ) : <NEWLINE> <INDENT> x = a * b <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = a // b <NEWLINE> <DEDENT> <DEDENT>
while True : <NEWLINE> <INDENT> a = input ( ) <NEWLINE> if <STRING> in a : break <NEWLINE> if <STRING> in a : /= // <NEWLINE> eval ( a ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> ( a , op , b ) = input ( ) . split ( ) <NEWLINE> a = int ( a ) <NEWLINE> b = int ( b ) <NEWLINE> <NL> if op = <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> elif op = <STRING> : <NEWLINE> <INDENT> print ( a + b ) <NEWLINE> <DEDENT> elif op = <STRING> : <NEWLINE> <INDENT> print ( a - b ) <NEWLINE> <DEDENT> elif op = <STRING> : <NEWLINE> <INDENT> print ( a * b ) <NEWLINE> <DEDENT> elif op = <STRING> : <NEWLINE> <INDENT> print ( a // b ) <NEWLINE> <DEDENT> <DEDENT>
from itertools import takewhile <NEWLINE> ( lambda * _ : None ) ( * map ( print , <NEWLINE> <INDENT> map ( eval , <NEWLINE> <INDENT> map ( lambda s : s . replace ( <STRING> , <STRING> ) , <NEWLINE> <INDENT> takewhile ( lambda s : <STRING> not in s , <NEWLINE> <INDENT> iter ( input , <STRING> ) ) ) ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <NL> import sys <NEWLINE> <NL> if __name__ == <STRING> : <NEWLINE> <INDENT> line = None <NEWLINE> while 1 : <NEWLINE> <INDENT> line = raw_input ( ) <NEWLINE> if line == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> a , op , b = line . split ( ) <NEWLINE> if op == <STRING> : <NEWLINE> <INDENT> print int ( a ) + int ( b ) <NEWLINE> <DEDENT> elif op == <STRING> : <NEWLINE> <INDENT> print int ( a ) - int ( b ) <NEWLINE> <DEDENT> elif op == <STRING> : <NEWLINE> <INDENT> print int ( a ) * int ( b ) <NEWLINE> <DEDENT> elif op == <STRING> : <NEWLINE> <INDENT> print int ( a ) / int ( b ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT>
while True : <NEWLINE> <INDENT> a , op , b = input ( ) . sprit ( ) <NEWLINE> a = int ( a ) <NEWLINE> b = int ( b ) <NEWLINE> <NL> if op == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> if op == <STRING> : <NEWLINE> <INDENT> print ( a + b ) <NEWLINE> <NL> <DEDENT> if op == <STRING> : <NEWLINE> <INDENT> print ( a - b ) <NEWLINE> <NL> <DEDENT> if op == <STRING> : <NEWLINE> <INDENT> print ( a * b ) <NEWLINE> <NL> <DEDENT> if op == <STRING> : <NEWLINE> <INDENT> print ( a % b ) <NEWLINE> <DEDENT> <DEDENT>
a , op , b = input ( ) . split ( ) <NEWLINE> while True : <NEWLINE> <INDENT> if op == <STRING> : print ( a + b ) <NEWLINE> elif op == <STRING> : print ( a - b ) <NEWLINE> elif op == <STRING> : print ( a / b ) <NEWLINE> elif op == <STRING> : print ( a * b ) <NEWLINE> else : break <NEWLINE> <DEDENT>
while 1 : <NEWLINE> <INDENT> k = input ( ) split ( ) <NEWLINE> k [ 0 ] = int ( k [ 0 ] ) <NEWLINE> k [ 2 ] = int ( k [ 2 ] ) <NEWLINE> <NL> if k [ 1 ] == <STRING> : <NEWLINE> <INDENT> break : <NEWLINE> <DEDENT> elif k [ 1 ] == <STRING> : <NEWLINE> <INDENT> print ( k [ 0 ] + k [ 2 ] ) <NEWLINE> <DEDENT> elif k [ 1 ] == <STRING> : <NEWLINE> <INDENT> print ( k [ 0 ] - k [ 2 ] ) <NEWLINE> <DEDENT> elif k [ 1 ] == <STRING> : <NEWLINE> <INDENT> print ( k [ 0 ] * k [ 2 ] ) <NEWLINE> <DEDENT> elif k [ 1 ] == <STRING> : <NEWLINE> <INDENT> print ( k [ 0 ] / k [ 2 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT>
import sys <NEWLINE> <NL> for v in iter ( sys . stdin . readline ) <NEWLINE> <INDENT> a , op , b = v . split ( ) <NEWLINE> a = int ( a ) <NEWLINE> b = int ( b ) <NEWLINE> if op == <STRING> : <NEWLINE> <INDENT> print ( a + b ) <NEWLINE> <DEDENT> elif op == <STRING> : <NEWLINE> <INDENT> print ( a - b ) <NEWLINE> <DEDENT> elif op == <STRING> : <NEWLINE> <INDENT> print ( a * b ) <NEWLINE> <DEDENT> elif op == <STRING> : <NEWLINE> <INDENT> print ( a / b ) <NEWLINE> <DEDENT> elif op == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT>
while True : <NEWLINE> <INDENT> a , op , b = input ( ) . split ( ) <NEWLINE> a , b = map ( int , ( a , b ) ) <NEWLINE> if op == <STRING> : <NEWLINE> <INDENT> None <NEWLINE> <DEDENT> elif op == <STRING> : <NEWLINE> <INDENT> print ( str ( int ( a + b ) ) ) <NEWLINE> <DEDENT> elif op == <STRING> : <NEWLINE> <INDENT> print ( str ( int ( a - b ) ) ) <NEWLINE> <DEDENT> elif op == <STRING> : <NEWLINE> <INDENT> print ( str ( int ( a * b ) ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( str ( int ( a // b ) ) ) <NEWLINE> <DEDENT> <DEDENT>
while 1 : <NEWLINE> <INDENT> x = raw_input ( ) . split ( ) <NEWLINE> a , op , b = int ( x [ 0 ] ) , x [ 1 ] , int ( x [ 2 ) <NEWLINE> if op == <STRING> : <NEWLINE> <INDENT> print a + b <NEWLINE> <DEDENT> elif op == <STRING> : <NEWLINE> <INDENT> print a - b <NEWLINE> <DEDENT> elif op == <STRING> : <NEWLINE> <INDENT> print a / b <NEWLINE> <DEDENT> elif op == <STRING> : <NEWLINE> <INDENT> print a * b <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT>
while True : <NEWLINE> ( a , op , b ) = [ int ( i ) if i . isdigit ( ) else i for i in input ( ) . split ( ) ] <NEWLINE> <NL> <INDENT> if op == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> if op == <STRING> : <NEWLINE> <INDENT> print ( a + b ) <NEWLINE> <NL> <DEDENT> if op == <STRING> : <NEWLINE> <INDENT> print ( a - b ) <NEWLINE> <NL> <DEDENT> if op == <STRING> : <NEWLINE> <INDENT> print ( a * b ) <NEWLINE> <NL> <DEDENT> if op == <STRING> : <NEWLINE> <INDENT> print ( a // b ) <NEWLINE> <DEDENT> <DEDENT>
str = raw_input ( ) <NEWLINE> a = map ( int , str [ 0 ] ) <NEWLINE> op = str [ 1 ] <NEWLINE> b = map ( int , str [ 2 ] ) <NEWLINE> <NL> if op == <STRING> : <NEWLINE> <INDENT> print a + b <NEWLINE> <DEDENT> elif op == <STRING> : <NEWLINE> <INDENT> print a - b <NEWLINE> <DEDENT> elif op == <STRING> : <NEWLINE> <INDENT> print a * b <NEWLINE> <DEDENT> elif op == <STRING> : <NEWLINE> <INDENT> print a / b <NEWLINE> <DEDENT>
x = input ( ) . split ( ) <NEWLINE> if x [ 1 ] == <STRING> : <NEWLINE> <INDENT> y = int ( x [ 0 ] ) + int ( x [ 2 ] ) <NEWLINE> print ( y ) <NEWLINE> <DEDENT> elif x [ 1 ] == <STRING> : <NEWLINE> <INDENT> y = int ( x [ 0 ] ) - int ( x [ 2 ] ) <NEWLINE> print ( y ) <NEWLINE> <DEDENT> elif x [ 1 ] == <STRING> : <NEWLINE> <INDENT> y = int ( x [ 0 ] ) * int ( x [ 2 ] ) <NEWLINE> print ( y ) <NEWLINE> <DEDENT> elif x [ 1 ] == <STRING> : <NEWLINE> <INDENT> y = int ( x [ 0 ] ) // int ( x [ 2 ] ) <NEWLINE> print ( y ) <NEWLINE> <DEDENT> elif x [ 1 ] == <STRING> : <NEWLINE>
while True : <NEWLINE> <INDENT> table = map ( int , input ( ) . split ( ) ) <NEWLINE> a = int ( table [ 0 ] ) <NEWLINE> op = table [ 1 ] <NEWLINE> b = int ( table [ 2 ] ) <NEWLINE> <NL> if op == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> if op == <STRING> : <NEWLINE> <INDENT> print ( <STRING> % ( a + b ) ) <NEWLINE> <DEDENT> elif op == <STRING> : <NEWLINE> <INDENT> print ( <STRING> % ( a - b ) ) <NEWLINE> <DEDENT> elif op == <STRING> : <NEWLINE> <INDENT> print ( <STRING> % ( a * b ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> % ( a % b ) ) <NEWLINE> <DEDENT> <DEDENT>
while True : <NEWLINE> ( a , op , b ) = [ int ( i ) if i . isdigit ( ) else i for i in input ( ) . split ( ) ] <NEWLINE> <NL> if op == <STRING> : <NEWLINE> break <NEWLINE> elif op == <STRING> : <NEWLINE> print ( a + b ) <NEWLINE> elif op == <STRING> : <NEWLINE> print ( a - b ) <NEWLINE> elif op == <STRING> : <NEWLINE> print ( a * b ) <NEWLINE> else op == <STRING> : <NEWLINE> print ( a // b ) <NEWLINE>
<NL> while 1 : <NEWLINE> <INDENT> a , op , b = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if op == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> elif op == <STRING> : <NEWLINE> <INDENT> print a + b <NEWLINE> <DEDENT> elif op == <STRING> : <NEWLINE> <INDENT> print a - b <NEWLINE> <DEDENT> elif op == <STRING> : <NEWLINE> <INDENT> print a / b <NEWLINE> <DEDENT> elif op == <STRING> : <NEWLINE> <INDENT> print a * b <NEWLINE> <DEDENT> <DEDENT>
while True : <NEWLINE> <INDENT> a , op , b = map ( istr , input ( ) . split ( ) ) <NEWLINE> a = int ( a ) <NEWLINE> b = int ( b ) <NEWLINE> if op == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if op == <STRING> : <NEWLINE> <INDENT> print ( a + b ) <NEWLINE> <DEDENT> elif op == <STRING> : <NEWLINE> <INDENT> print ( a - b ) <NEWLINE> <DEDENT> elif op == <STRING> : <NEWLINE> <INDENT> print ( a * b ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( int ( a / b ) ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT>
while 0 == 0 : <NEWLINE> <INDENT> i = map ( str , raw_input ( ) . split ( ) ) <NEWLINE> i [ 0 ] = int ( i [ 0 ] ) <NEWLINE> i [ 2 ] = int ( i [ 2 ] ) <NEWLINE> if i [ 1 ] == <STRING> : <NEWLINE> <INDENT> print i [ 0 ] + i [ 2 ] <NEWLINE> <DEDENT> elif i [ 1 ] == <STRING> : <NEWLINE> <INDENT> print i [ 0 ] - i [ 2 ] <NEWLINE> <DEDENT> elif i [ 1 ] == <STRING> : <NEWLINE> <INDENT> print i [ 0 ] * i [ 2 ] <NEWLINE> <DEDENT> elif i [ 1 ] == <STRING> : <NEWLINE> <INDENT> print i [ 0 ] / i [ 2 ] <NEWLINE> <DEDENT> elif i [ 1 ] == <STRING> : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> <DEDENT>
a = [ ] <NEWLINE> while True : <NEWLINE> <INDENT> x = map ( raw_input ( ) . split ( ) ) <NEWLINE> if x [ 1 ] == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if x [ 1 ] == <STRING> : <NEWLINE> <INDENT> a . append ( int ( x [ 0 ] + int ( x [ 2 ] ) ) ) <NEWLINE> <DEDENT> if x [ 1 ] == <STRING> : <NEWLINE> <INDENT> a . append ( int ( x [ 0 ] - int ( x [ 2 ] ) ) ) <NEWLINE> <DEDENT> if x [ 1 ] == <STRING> : <NEWLINE> <INDENT> a . append ( int ( x [ 0 ] * int ( x [ 2 ] ) ) ) <NEWLINE> <DEDENT> if x [ 1 ] == <STRING> : <NEWLINE> <INDENT> a . append ( int ( x [ 0 ] / int ( x [ 2 ] ) ) ) <NEWLINE> <DEDENT> <DEDENT> for i in range ( len ( a ) ) : <NEWLINE> <INDENT> print a [ i ] <NEWLINE> <DEDENT>
ops = [ ] <NEWLINE> kekka = [ ] <NEWLINE> <NL> while True : <NEWLINE> <INDENT> op = [ e for e in input ( ) . split ( ) ] <NEWLINE> if op [ 1 ] == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> ops . append ( op ) <NEWLINE> <NL> <DEDENT> for i in range ( len ( ops ) ) : <NEWLINE> <INDENT> if ops [ i ] [ 1 ] == <STRING> : <NEWLINE> <INDENT> sum = int ( ops [ i ] [ 0 ] ) + int ( ops [ i ] [ 2 ] ) <NEWLINE> kekka . append ( sum ) <NEWLINE> <DEDENT> elif ops [ i ] [ 1 ] == <STRING> : <NEWLINE> <INDENT> hiku = int ( ops [ i ] [ 0 ] ) - int ( ops [ i ] [ 2 ] ) <NEWLINE> kekka . append ( hiku ) <NEWLINE> <DEDENT> elif ops [ i ] [ 1 ] == <STRING> : <NEWLINE> <INDENT> kakeru = int ( ops [ i ] [ 0 ] ) * int ( ops [ i ] [ 2 ] ) <NEWLINE> kekka . append ( kakeru ) <NEWLINE> <DEDENT> elif ops [ i ] [ 1 ] == <STRING> : <NEWLINE> <INDENT> waru = floor ( int ( ops [ i ] [ 0 ] ) / int ( ops [ i ] [ 2 ] ) ) <NEWLINE> kekka . append ( waru ) <NEWLINE> <NL> <DEDENT> <DEDENT> for j in kekka : <NEWLINE> <INDENT> print ( int ( j ) ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> a , op , b = raw_input ( ) . split ( ) <NEWLINE> if op == <STRING> : break <NEWLINE> if op == <STRING> : print int ( a ) + int ( b ) <NEWLINE> if op == <STRING> : print int ( a ) - int ( b ) <NEWLINE> if op == <STRING> : print int ( a ) int ( b ) <NEWLINE> if op == <STRING> : print int ( a ) / int ( b ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> a , b , c = input ( ) . split ( ) <NEWLINE> if b == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> a = int ( a ) <NEWLINE> c = int ( c ) <NEWLINE> if b == <STRING> : <NEWLINE> <INDENT> print ( a + b ) <NEWLINE> <DEDENT> if b == <STRING> : <NEWLINE> <INDENT> print ( a - b ) <NEWLINE> <DEDENT> if b == <STRING> : <NEWLINE> <INDENT> print ( a * b ) <NEWLINE> <DEDENT> if b == <STRING> : <NEWLINE> <INDENT> print ( a / b ) <NEWLINE> <NL> <DEDENT> <DEDENT>
while True : <NEWLINE> <INDENT> a , op , b = raw_input ( ) . split ( ) <NEWLINE> a = int ( a ) <NEWLINE> b = int ( b ) <NEWLINE> <NL> if op == <STRING> : a += c <NEWLINE> elif op == <STRING> : a -= c <NEWLINE> elif op == <STRING> : a *= c <NEWLINE> elif op == <STRING> : a /= c <NEWLINE> elif op == <STRING> : break <NEWLINE> print a <NEWLINE> <DEDENT>
import math <NEWLINE> <NL> while True : <NEWLINE> <INDENT> a , op , b = map ( str , input ( ) . split ( ) ) <NEWLINE> a = int ( a ) <NEWLINE> b = int ( b ) <NEWLINE> if 0 < a < 20001 and 0 < b < 20001 : <NEWLINE> <INDENT> if op == <STRING> : <NEWLINE> <INDENT> answer = a + b <NEWLINE> print ( answer ) <NEWLINE> <NL> <DEDENT> elif op == <STRING> : <NEWLINE> <INDENT> answer = a - b <NEWLINE> print ( answer ) <NEWLINE> <NL> <DEDENT> elif op == <STRING> : <NEWLINE> <INDENT> answer = a * b <NEWLINE> print ( answer ) <NEWLINE> <NL> <DEDENT> elif op == <STRING> : <NEWLINE> <INDENT> answer = a / b <NEWLINE> print ( math . floor ( answer ) ) <NEWLINE> <NL> <DEDENT> elif op == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> <DEDENT>
def calcinput ( ) : <NEWLINE> <INDENT> a = input ( ) . split ( ) <NEWLINE> a [ 0 ] = int ( a [ 0 ] ) <NEWLINE> a [ 2 ] = int ( a [ 2 ] ) <NEWLINE> return a <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> while True : <NEWLINE> <INDENT> a = calcinput ( ) <NEWLINE> if a [ 1 ] == <STRING> : break <NEWLINE> a = a [ 0 ] ; op = a [ 1 ] ; b = a [ 2 ] <NEWLINE> if op == <STRING> : print ( a + b ) <NEWLINE> elif op == <STRING> : print ( a - b ) <NEWLINE> elif op == <STRING> : print ( a * b ) <NEWLINE> elif op == <STRING> : print ( a // b ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> ( a , op , b ) = input ( ) . split ( ) <NEWLINE> if op == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> a = int ( a ) <NEWLINE> b = int ( b ) <NEWLINE> elif op == <STRING> : <NEWLINE> <INDENT> print ( a + b ) <NEWLINE> <DEDENT> elif op == <STRING> : <NEWLINE> <INDENT> print ( a - b ) <NEWLINE> <DEDENT> elif op == <STRING> : <NEWLINE> <INDENT> print ( a * b ) <NEWLINE> <DEDENT> elif op == <STRING> : <NEWLINE> <INDENT> print ( a // b ) <NEWLINE> <DEDENT> <DEDENT> ~ <NEWLINE>
<INDENT> a , b , c = input ( ) . split ( ) <NEWLINE> a = int ( a ) <NEWLINE> c = int ( c ) <NEWLINE> <NL> if b == <STRING> : <NEWLINE> <INDENT> print ( a + c ) <NEWLINE> <DEDENT> elif b == <STRING> : <NEWLINE> <INDENT> print ( a - c ) <NEWLINE> <DEDENT> elif b == <STRING> : <NEWLINE> <INDENT> print ( a * c ) <NEWLINE> <DEDENT> elif b == <STRING> : <NEWLINE> <INDENT> print ( a // c ) <NEWLINE> <DEDENT> <DEDENT>
While True : <NEWLINE> <INDENT> ( a , op , b ) = input ( ) . split ( ) <NEWLINE> a = int ( a ) <NEWLINE> b = int ( b ) <NEWLINE> <NL> if op = <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> elif op = <STRING> : <NEWLINE> <INDENT> print ( a + b ) <NEWLINE> <DEDENT> elif op = <STRING> : <NEWLINE> <INDENT> print ( a - b ) <NEWLINE> <DEDENT> elif op = <STRING> : <NEWLINE> <INDENT> print ( a * b ) <NEWLINE> <DEDENT> elif op = <STRING> : <NEWLINE> <INDENT> print ( a / b ) <NEWLINE> <DEDENT> <DEDENT>
While True : <NEWLINE> <INDENT> ( a , op , b ) = input ( ) . split ( ) <NEWLINE> a = int ( a ) <NEWLINE> b = int ( b ) <NEWLINE> <NL> if op == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> elif op == <STRING> : <NEWLINE> <INDENT> print ( a + b ) <NEWLINE> <NL> <DEDENT> elif op == <STRING> : <NEWLINE> <INDENT> print ( a - b ) <NEWLINE> <NL> <DEDENT> elif op == <STRING> : <NEWLINE> <INDENT> print ( a * b ) <NEWLINE> <NL> <DEDENT> elif op == <STRING> : <NEWLINE> <INDENT> print ( a // b ) <NEWLINE> <DEDENT> <DEDENT>
import math <NEWLINE> while True : <NEWLINE> <INDENT> s = input ( ) . split ( ) <NEWLINE> if s [ 0 ] == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> elif s [ 1 ] == <STRING> : <NEWLINE> <INDENT> print ( int ( s [ 0 ] ) + int ( s [ 2 ] ) ) <NEWLINE> <DEDENT> elif s [ 1 ] == <STRING> : <NEWLINE> <INDENT> print ( int ( s [ 0 ] ) - int ( s [ 2 ] ) ) <NEWLINE> <DEDENT> elif s [ 1 ] == <STRING> : <NEWLINE> <INDENT> print ( int ( s [ 0 ] ) * int ( s [ 2 ] ) ) <NEWLINE> <DEDENT> elif s [ 1 ] == <STRING> : <NEWLINE> <INDENT> print ( math . floor ( int ( s [ 0 ] ) / int ( s [ 2 ] ) ) ) <NEWLINE> <DEDENT> <DEDENT>
sols = [ ] <NEWLINE> while True : <NEWLINE> <INDENT> x = list ( input ( ) . split ( ) ) <NEWLINE> a = int ( x [ 0 ] ) <NEWLINE> b = int ( x [ 2 ] ) <NEWLINE> oprnd = x [ 1 ] <NEWLINE> if oprnd == <STRING> : <NEWLINE> <INDENT> sols . append ( a + b ) <NEWLINE> <DEDENT> elif oprnd == <STRING> : <NEWLINE> <INDENT> sols . append ( a - b ) <NEWLINE> <DEDENT> elif oprnd == <STRING> : <NEWLINE> <INDENT> sols . append ( a * b ) <NEWLINE> <DEDENT> elif oprnd == <STRING> : <NEWLINE> <INDENT> sols . append ( a / b ) <NEWLINE> <DEDENT> elif oprnd == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> if len ( sols == 1 ) : <NEWLINE> <INDENT> print ( sols ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in len ( sols ) : <NEWLINE> <INDENT> print ( sols [ i ] ) <NEWLINE> <DEDENT> <DEDENT>
while : <NEWLINE> <INDENT> a , op , b = list ( map , input ( ) . split ( ) ) <NEWLINE> if op == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> a = int ( a ) <NEWLINE> b = int ( b ) <NEWLINE> if op == <STRING> : <NEWLINE> <INDENT> print ( a + b ) <NEWLINE> <DEDENT> elif op == <STRING> : <NEWLINE> <INDENT> print ( a - b ) <NEWLINE> <DEDENT> elif op == <STRING> : <NEWLINE> <INDENT> print ( a * b ) <NEWLINE> <DEDENT> elif op == <STRING> : <NEWLINE> <INDENT> print ( a / b ) <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> <NL> import sys <NEWLINE> <NL> equation = raw_input ( ) . split ( <STRING> ) <NEWLINE> <NL> a = int ( equation [ 0 ] ) <NEWLINE> b = int ( equation [ 2 ] ) <NEWLINE> mark = equation [ 1 ] <NEWLINE> <NL> if mark == <STRING> : <NEWLINE> <INDENT> sys . exit ( ) <NEWLINE> <DEDENT> elif mark == <STRING> : <NEWLINE> <INDENT> print str ( a + b ) + <STRING> <NEWLINE> <DEDENT> elif mark == <STRING> : <NEWLINE> <INDENT> print str ( a - b ) + <STRING> <NEWLINE> <DEDENT> elif mark == <STRING> : <NEWLINE> <INDENT> print str ( a * b ) + <STRING> <NEWLINE> <DEDENT> elif mark == <STRING> : <NEWLINE> <INDENT> print str ( a / b ) + <STRING> <NEWLINE> <NL> <DEDENT> sys . exit ( ) <NEWLINE>
while 1 : <NEWLINE> <INDENT> a , op , b = raw_input ( ) . split ( ) <NEWLINE> if ( a == b == <STRING> and op == <STRING> ) : break <NEWLINE> a , b = map ( int , [ a , b ] ) <NEWLINE> ans = 0 <NEWLINE> if op == <STRING> : <NEWLINE> <INDENT> ans = a + b <NEWLINE> <DEDENT> elif op == <STRING> : <NEWLINE> <INDENT> ans = a - b <NEWLINE> <DEDENT> elif op == <STRING> : <NEWLINE> <INDENT> ans = a * b <NEWLINE> <DEDENT> elif op == <STRING> : <NEWLINE> <INDENT> ans = a / b <NEWLINE> <DEDENT> print ans <NEWLINE> <DEDENT>
while ( True ) : <NEWLINE> <INDENT> f = input ( ) <NEWLINE> s = f . split ( ) <NEWLINE> if ( s [ 1 ] == <STRING> ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if ( s [ 1 ] == <STRING> ) : <NEWLINE> <INDENT> print ( ( int ) ( s [ 0 ] ) // ( int ) ( s [ 1 ] ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( eval ( f ) ) <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> import sys <NEWLINE> <NL> op = { <STRING> : lambda x , y : x + y , <NEWLINE> <INDENT> <STRING> : lambda x , y : x - y , <NEWLINE> <STRING> : lambda x , y : x / y , <NEWLINE> <STRING> : lambda x , y : x * y } <NEWLINE> <NL> <DEDENT> while True : <NEWLINE> <INDENT> a , op_ , b = sys . readline ( ) . split ( ) <NEWLINE> if op_ == <STRING> : break <NEWLINE> a1 , b1 = int ( a ) , int ( b ) <NEWLINE> <NL> print op [ op_ ] ( a1 , b1 ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> ax , op , bx = raw_input ( ) . split ( ) <NEWLINE> ax = int ( a ) <NEWLINE> bx = int ( b ) <NEWLINE> if op == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> elif op == <STRING> : <NEWLINE> <INDENT> print ( ax + bx ) <NEWLINE> <DEDENT> elif op == <STRING> : <NEWLINE> <INDENT> print ( ax - bx ) <NEWLINE> <DEDENT> elif op == <STRING> : <NEWLINE> <INDENT> print ( ax * bx ) <NEWLINE> <DEDENT> elif op == <STRING> : <NEWLINE> <INDENT> print ( ax / bx ) <NEWLINE> <DEDENT> <DEDENT>
while True : <NEWLINE> <INDENT> a , op , b = input ( ) . split ( ) <NEWLINE> if op = <STRING> : <NEWLINE> <INDENT> print ( a + b ) <NEWLINE> <DEDENT> if op = <STRING> : <NEWLINE> <INDENT> print ( a - b ) <NEWLINE> <DEDENT> if op = <STRING> : <NEWLINE> <INDENT> print ( a * b ) <NEWLINE> <DEDENT> if op = <STRING> : <NEWLINE> <INDENT> print ( a / b ) <NEWLINE> <DEDENT> if op = <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> while True : <NEWLINE> <INDENT> line = raw_input ( ) . split ( ) <NEWLINE> a = int ( line [ 0 ] ) <NEWLINE> op = line [ 1 ] <NEWLINE> b = int ( line [ 2 ] ) <NEWLINE> answer = 0 <NEWLINE> if op == <STRING> : <NEWLINE> <INDENT> answer = a + b <NEWLINE> <DEDENT> elif op == <STRING> : <NEWLINE> <INDENT> answer = a - b <NEWLINE> <DEDENT> elif op == <STRING> : <NEWLINE> <INDENT> answer = a * b <NEWLINE> <DEDENT> elif op == <STRING> : <NEWLINE> <INDENT> answer = a / b <NEWLINE> <DEDENT> elif op == <STRING> and a == 0 and b == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> print <STRING> % answer <NEWLINE> <DEDENT>
<NL> while true : <NEWLINE> <INDENT> a , op , b = raw_input ( ) . split ( ) <NEWLINE> if op == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> elif op == <STRING> : <NEWLINE> <INDENT> print int ( a ) + int ( b ) <NEWLINE> <DEDENT> elif op == <STRING> : <NEWLINE> <INDENT> print int ( a ) - int ( b ) <NEWLINE> <DEDENT> elif op == <STRING> : <NEWLINE> <INDENT> print int ( a ) * int ( b ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print int ( a ) / int ( b ) <NEWLINE> <DEDENT> <DEDENT>
while true : <NEWLINE> <NL> <INDENT> x = raw_input ( ) . split ( ) <NEWLINE> a = int ( x [ 0 ] ) <NEWLINE> op = x [ 1 ] <NEWLINE> b = int ( x [ 2 ] ) <NEWLINE> <NL> if op == <STRING> : <NEWLINE> <INDENT> print a + b <NEWLINE> <DEDENT> elif op == <STRING> : <NEWLINE> <INDENT> print a - b <NEWLINE> <DEDENT> elif op == <STRING> : <NEWLINE> <INDENT> print a * b <NEWLINE> <DEDENT> elif op == <STRING> : <NEWLINE> <INDENT> print a / b <NEWLINE> <DEDENT> elif op == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT>
<INDENT> while True : <NEWLINE> <INDENT> a , op , b = input ( ) . split ( ) <NEWLINE> a = int ( a ) <NEWLINE> b = int ( b ) <NEWLINE> <NL> if op == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> if op == <STRING> : <NEWLINE> <INDENT> print ( a + b ) <NEWLINE> <NL> <DEDENT> if op == <STRING> : <NEWLINE> <INDENT> print ( a - b ) <NEWLINE> <NL> <DEDENT> if op == <STRING> : <NEWLINE> <INDENT> print ( a * b ) <NEWLINE> <NL> <DEDENT> if op == <STRING> : <NEWLINE> <INDENT> print ( a // b ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
while True : <NEWLINE> <INDENT> a , op , b = input ( ) . split ( ) <NEWLINE> a , b = int ( a ) , int ( b ) <NEWLINE> if op == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> elif op == <STRING> : <NEWLINE> <INDENT> print ( a + b ) + 1 <NEWLINE> <DEDENT> elif op == <STRING> : <NEWLINE> <INDENT> print ( a - b ) <NEWLINE> <DEDENT> elif op == <STRING> : <NEWLINE> <INDENT> print ( a * b ) <NEWLINE> <DEDENT> elif op == <STRING> : <NEWLINE> <INDENT> print ( a // b ) <NEWLINE> <DEDENT> <DEDENT>
while True : <NEWLINE> <INDENT> table = input ( ) . split ( ) <NEWLINE> <NL> a = int ( table [ 0 ] ) <NEWLINE> op = table [ 1 ] <NEWLINE> b = int ( table [ - 1 ] ) <NEWLINE> <NL> if op = <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> if op = <STRING> : <NEWLINE> <INDENT> print ( a + b ) <NEWLINE> <DEDENT> elif op = <STRING> : <NEWLINE> <INDENT> print ( a - b ) <NEWLINE> <DEDENT> elif op = <STRING> : <NEWLINE> <INDENT> print ( a * b ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( a // b ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT>
while True : <NEWLINE> <INDENT> ( a , op , b ) = input ( ) . split ( ) <NEWLINE> a = int ( a ) <NEWLINE> b = int ( b ) <NEWLINE> <NL> if op = <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> elif op = <STRING> : <NEWLINE> <INDENT> print ( a + b ) <NEWLINE> <DEDENT> elif op = <STRING> : <NEWLINE> <INDENT> print ( a - b ) <NEWLINE> <DEDENT> elif op = <STRING> : <NEWLINE> <INDENT> print ( a * b ) <NEWLINE> <DEDENT> elif op = <STRING> : <NEWLINE> <INDENT> print ( a / b ) <NEWLINE> <DEDENT> <DEDENT>
while True : <NEWLINE> <INDENT> data = raw_input ( ) . split ( <STRING> ) <NEWLINE> a = int ( data [ 0 ] ) <NEWLINE> op = data [ 1 ] <NEWLINE> b = int ( data [ 2 ] ) <NEWLINE> <NL> if op = <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> elif op == <STRING> : <NEWLINE> <INDENT> ans = a + b <NEWLINE> <DEDENT> elif op == <STRING> : <NEWLINE> <INDENT> ans = a - b <NEWLINE> <DEDENT> elif op == <STRING> : <NEWLINE> <INDENT> ans = a * b <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = a / b <NEWLINE> <NL> <DEDENT> print ans <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> a , op , b = raw_input ( ) . split ( ) <NEWLINE> if op == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if op == <STRING> : <NEWLINE> <INDENT> print int ( a ) + int ( b ) <NEWLINE> <DEDENT> elif op == <STRING> : <NEWLINE> <INDENT> print int ( a ) - int ( b ) <NEWLINE> <DEDENT> elif op == <STRING> : <NEWLINE> <INDENT> print int ( a ) * int ( b ) <NEWLINE> <DEDENT> elif op == <STRING> : <NEWLINE> <INDENT> print int ( a ) / int ( b ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
import math <NEWLINE> <NL> data = input ( ) . split ( ) <NEWLINE> a = int ( data [ 0 ] ) <NEWLINE> b = data [ 1 ] <NEWLINE> c = int ( data [ 2 ] ) <NEWLINE> <NL> ans = [ ] <NEWLINE> while True : <NEWLINE> <INDENT> if b == <STRING> : <NEWLINE> <INDENT> ans += a + c <NEWLINE> <DEDENT> elif b == <STRING> : <NEWLINE> <INDENT> ans += a - c <NEWLINE> <DEDENT> elif b == <STRING> : <NEWLINE> <INDENT> ans += a * c <NEWLINE> <DEDENT> elif b == <STRING> : <NEWLINE> <INDENT> ans += math . floor ( a / c ) <NEWLINE> <DEDENT> elif b == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> for output in ans : <NEWLINE> <INDENT> print ( output ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> a , op , b = map ( str , input ( ) . split ( ) ) <NEWLINE> if op == <STRING> : <NEWLINE> <INDENT> print ( int ( a ) + int ( b ) ) <NEWLINE> <DEDENT> elif op == <STRING> : <NEWLINE> <INDENT> print ( int ( a ) - int ( b ) ) <NEWLINE> <DEDENT> elif op == <STRING> : <NEWLINE> <INDENT> printf ( int ( a ) * int ( b ) ) <NEWLINE> <DEDENT> elif op == <STRING> : <NEWLINE> <INDENT> printf ( int ( a ) // int ( b ) ) <NEWLINE> <DEDENT> elif op == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT>
<INDENT> while True : <NEWLINE> <INDENT> x = input ( ) . split ( <STRING> ) <NEWLINE> a = int ( x [ 0 ] ) <NEWLINE> op = x [ 1 ] <NEWLINE> b = int ( x [ 2 ] ) <NEWLINE> if op == <STRING> : <NEWLINE> <INDENT> print ( a + b ) <NEWLINE> <DEDENT> elif op == <STRING> : <NEWLINE> <INDENT> print ( a - b ) <NEWLINE> <DEDENT> elif op == <STRING> : <NEWLINE> <INDENT> print ( a * b ) <NEWLINE> <DEDENT> elif op == <STRING> : <NEWLINE> <INDENT> print ( a / b ) <NEWLINE> <DEDENT> elif op == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
while 1 : <NEWLINE> <INDENT> a , op , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if op == <STRING> : <NEWLINE> <INDENT> print ( int ( a ) + int ( b ) ) <NEWLINE> <DEDENT> elif op == <STRING> : <NEWLINE> <INDENT> print ( int ( a ) - int ( b ) ) <NEWLINE> <DEDENT> elif op == <STRING> : <NEWLINE> <INDENT> print ( int ( a ) * int ( b ) ) <NEWLINE> <DEDENT> elif op == <STRING> : <NEWLINE> <INDENT> print ( int ( a ) // int ( b ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT>
<NL> while 1 : <NEWLINE> <INDENT> a , op , b = map ( str , raw_input ( ) . split ( ) ) <NEWLINE> <INDENT> a = int ( a ) <NEWLINE> b = int ( b ) <NEWLINE> <NL> <DEDENT> if op == <STRING> : <NEWLINE> <INDENT> x = a + b <NEWLINE> <DEDENT> elif op == <STRING> : <NEWLINE> <INDENT> x = a - b <NEWLINE> <DEDENT> elif op == <STRING> : <NEWLINE> <INDENT> x = a * b <NEWLINE> <DEDENT> elif op == <STRING> : <NEWLINE> <INDENT> x = a / b <NEWLINE> <DEDENT> elif op == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> print <STRING> % ( x ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> a , op , b = map ( str , input ( ) . split ( <STRING> ) ) <NEWLINE> if a == 0 and b == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> a , b = int ( a ) , int ( b ) <NEWLINE> if op == <STRING> : <NEWLINE> <INDENT> c = a + b <NEWLINE> <DEDENT> elif op == <STRING> : <NEWLINE> <INDENT> c = a - b <NEWLINE> <DEDENT> elif op == <STRING> : <NEWLINE> <INDENT> c = a * b <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> c = a / b <NEWLINE> <DEDENT> print ( c ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <NL> <INDENT> ary = input ( ) . split ( ) <NEWLINE> <NL> if ary [ 1 ] = <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> if ary [ 1 ] = <STRING> : <NEWLINE> <INDENT> ans = int ( ary [ 0 ] ) + int ( ary [ 2 ] ) <NEWLINE> <NL> <DEDENT> if ary [ 1 ] = <STRING> : <NEWLINE> <INDENT> ans = int ( ary [ 0 ] ) - int ( ary [ 2 ] ) <NEWLINE> <NL> <DEDENT> if ary [ 1 ] = <STRING> : <NEWLINE> <INDENT> ans = int ( ary [ 0 ] ) * int ( ary [ 2 ] ) <NEWLINE> <NL> <DEDENT> if ary [ 1 ] = <STRING> : <NEWLINE> <INDENT> ans = int ( ary [ 0 ] ) / int ( ary [ 2 ] ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT>
wihle True : <NEWLINE> <INDENT> a , op , b = map ( str , raw_input ( ) . split ( ) ) <NEWLINE> <NL> if op in <STRING> : <NEWLINE> <INDENT> print int ( a ) + int ( b ) <NEWLINE> <DEDENT> elif op in <STRING> : <NEWLINE> <INDENT> print int ( a ) - int ( b ) <NEWLINE> <DEDENT> elif op in <STRING> : <NEWLINE> <INDENT> print int ( a ) * int ( b ) <NEWLINE> <DEDENT> elif op in <STRING> : <NEWLINE> <INDENT> print int ( a ) / int ( b ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break ; <NEWLINE> <DEDENT> <DEDENT>
while True : <NEWLINE> <INDENT> a , op , b = input ( ) . split ( <STRING> ) <NEWLINE> if op == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> elif op == <STRING> : <NEWLINE> <INDENT> print ( int ( a ) + int ( b ) ) <NEWLINE> <DEDENT> elif op == <STRING> : <NEWLINE> <INDENT> print ( int ( a ) - int ( b ) ) <NEWLINE> <DEDENT> elif op == <STRING> : <NEWLINE> <INDENT> print ( int ( a ) * int ( b ) ) <NEWLINE> <DEDENT> elif op == <STRING> : <NEWLINE> <INDENT> print ( int ( a ) / / int ( b ) ) <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> <NL> l = [ ] <NEWLINE> for input in sys . stdin : <NEWLINE> <INDENT> l . append ( input . split ( ) ) <NEWLINE> <DEDENT> for i in range ( 0 , len ( l ) ) : <NEWLINE> <INDENT> if ( l [ i ] [ 1 ] == <STRING> ) : <NEWLINE> <INDENT> print int ( l [ i ] [ 0 ] ) + int ( l [ i ] [ 2 ] ) <NEWLINE> <DEDENT> elif ( l [ i ] [ 1 ] == <STRING> ) : <NEWLINE> <INDENT> print int ( l [ i ] [ 0 ] ) - int ( l [ i ] [ 2 ] ) <NEWLINE> <DEDENT> elif ( l [ i ] [ 1 ] == <STRING> ) : <NEWLINE> <INDENT> print int ( l [ i ] [ 0 ] ) * int ( l [ i ] [ 2 ] ) <NEWLINE> <DEDENT> elif ( l [ i ] [ 1 ] == <STRING> ) : <NEWLINE> <INDENT> print int ( l [ i ] [ 0 ] ) / int ( l [ i ] [ 2 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> <DEDENT>
i = 100 <NEWLINE> for i in range ( i ) : <NEWLINE> <INDENT> a_list = [ str ( x ) for x in input ( ) . split ( ) ] <NEWLINE> a = int ( a_list [ 0 ] ) <NEWLINE> b = int ( a_list [ 2 ] ) <NEWLINE> op = a_list [ 1 ] <NEWLINE> if op == <STRING> : <NEWLINE> <INDENT> ab = a + b <NEWLINE> print ( ab ) <NEWLINE> i = i + 1 <NEWLINE> continue <NEWLINE> <DEDENT> elif op == <STRING> : <NEWLINE> <INDENT> ab = a - b <NEWLINE> print ( ab ) <NEWLINE> i = i + 1 <NEWLINE> continue <NEWLINE> <DEDENT> elif op == <STRING> : <NEWLINE> <INDENT> ab = a * b <NEWLINE> print ( ab ) <NEWLINE> i = i + 1 <NEWLINE> continue <NEWLINE> <DEDENT> elif op == <STRING> : <NEWLINE> <INDENT> ab = a // b <NEWLINE> print ( ab ) <NEWLINE> i = i + 1 <NEWLINE> continue <NEWLINE> <DEDENT> elif op == <STRING> : <NEWLINE> <INDENT> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT>
a , op , b = input ( ) . split ( ) <NEWLINE> <NL> ans = int ( a ) op int ( b ) <NEWLINE> <NL> print ( ans ) <NEWLINE>
<NL> <NL> while 1 : <NEWLINE> <INDENT> s == input ( ) <NEWLINE> if <STRING> in s : break <NEWLINE> print ( int ( eval ( s ) ) ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> a , op , b = raw_input ( ) . split <NEWLINE> a , b = map ( int , [ a , b ] ) <NEWLINE> <NL> if op == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> if op == <STRING> : <NEWLINE> <INDENT> print ( a + b ) <NEWLINE> <DEDENT> elif op == <STRING> : <NEWLINE> <INDENT> print ( a - b ) <NEWLINE> <DEDENT> elif op == <STRING> : <NEWLINE> <INDENT> print ( a * b ) <NEWLINE> <DEDENT> elif op == <STRING> : <NEWLINE> <INDENT> print ( a / b ) <NEWLINE> <DEDENT> <DEDENT>
while True : <NEWLINE> <INDENT> a , op , b = input ( ) . split ( ) <NEWLINE> a = int ( a ) <NEWLINE> a = int ( b ) <NEWLINE> <NL> if op == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> if op == <STRING> : <NEWLINE> <INDENT> print ( a + b ) <NEWLINE> <NL> <DEDENT> if op == <STRING> : <NEWLINE> <INDENT> print ( a - b ) <NEWLINE> <NL> <DEDENT> if op == <STRING> : <NEWLINE> <INDENT> print ( a * b ) <NEWLINE> <NL> <DEDENT> if op == <STRING> : <NEWLINE> <INDENT> print ( a // b ) <NEWLINE> <DEDENT> <DEDENT>
while True : <NEWLINE> <INDENT> a , op b = input ( ) . split ( ) <NEWLINE> <NL> if op == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> elif op == <STRING> : <NEWLINE> <INDENT> print ( int ( a ) + int ( b ) ) <NEWLINE> <DEDENT> elif op == <STRING> : <NEWLINE> <INDENT> print ( int ( a ) - int ( b ) ) <NEWLINE> <DEDENT> elif op == <STRING> : <NEWLINE> <INDENT> print ( int ( a ) * int ( b ) ) <NEWLINE> <DEDENT> elif op == <STRING> : <NEWLINE> <INDENT> print ( int ( a ) // int ( b ) ) <NEWLINE> <NL> <DEDENT> <DEDENT>
<NL> a = [ ] <NEWLINE> while True : <NEWLINE> <INDENT> m , n , o = input ( ) <NEWLINE> m = int ( m ) <NEWLINE> o = int ( o ) <NEWLINE> if n == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if n == <STRING> : <NEWLINE> <INDENT> a . append ( m + o ) <NEWLINE> <DEDENT> elif n == <STRING> : <NEWLINE> <INDENT> a . append ( m - o ) <NEWLINE> <DEDENT> elif n == <STRING> : <NEWLINE> <INDENT> a . append ( m * o ) <NEWLINE> <DEDENT> elif n == <STRING> : <NEWLINE> <INDENT> a . append ( m / o ) <NEWLINE> <NL> <DEDENT> <DEDENT> for i in a : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> result = 0 <NEWLINE> i = input ( ) . split ( ) <NEWLINE> if i [ 1 ] == <STRING> : <NEWLINE> <INDENT> result = int ( i [ 0 ] ) + int ( i [ 2 ] ) <NEWLINE> <DEDENT> elif i [ 1 ] == <STRING> : <NEWLINE> <INDENT> result = int ( i [ 0 ] ) - int ( i [ 2 ] ) <NEWLINE> <DEDENT> elif i [ 1 ] == <STRING> : <NEWLINE> <INDENT> result = int ( i [ 0 ] ) * int ( i [ 2 ] ) <NEWLINE> <DEDENT> elif i [ 1 ] == <STRING> : <NEWLINE> <INDENT> result = int ( i [ 0 ] ) // int ( i [ 2 ] ) <NEWLINE> <DEDENT> print ( result ) <NEWLINE> <DEDENT>
while ( 1 ) : <NEWLINE> <INDENT> a , b , op = raw_input ( ) . split ( ) <NEWLINE> a = int ( a ) <NEWLINE> b = int ( b ) <NEWLINE> if op == <STRING> : <NEWLINE> <INDENT> print ( a + b ) <NEWLINE> <DEDENT> elif op == <STRING> : <NEWLINE> <INDENT> print ( a - b ) <NEWLINE> <DEDENT> elif op == <STRING> : <NEWLINE> <INDENT> print ( a * b ) <NEWLINE> <DEDENT> elif op == <STRING> : <NEWLINE> <INDENT> print ( a / b ) <NEWLINE> <DEDENT> elif op == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT>
while True : <NEWLINE> <INDENT> inp = input ( ) <NEWLINE> x , y = ( int ( inp [ 0 ] ) , int ( inp [ 2 ] ) ) <NEWLINE> op = inp [ 1 ] <NEWLINE> if op == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if op == <STRING> : <NEWLINE> <INDENT> print ( x + y ) <NEWLINE> <DEDENT> elif op == <STRING> : <NEWLINE> <INDENT> print ( x - y ) <NEWLINE> <DEDENT> elif op == <STRING> : <NEWLINE> <INDENT> print ( x * y ) <NEWLINE> <DEDENT> elif op == <STRING> : <NEWLINE> <INDENT> print ( x // y ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT>
while True : <NEWLINE> <INDENT> a , op , b = input ( ) . split ( ) ) <NEWLINE> int ( a ) <NEWLINE> int ( b ) <NEWLINE> if op == <STRING> : <NEWLINE> <INDENT> print ( a + b ) <NEWLINE> <DEDENT> elif op == <STRING> : <NEWLINE> <INDENT> print ( a - b ) <NEWLINE> <DEDENT> elif op == <STRING> : <NEWLINE> <INDENT> print ( a * b ) <NEWLINE> <DEDENT> elif op == <STRING> : <NEWLINE> <INDENT> print ( a / b ) <NEWLINE> <DEDENT> elif op == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT>
while True : <NEWLINE> <INDENT> Input = raw_input ( ) . split ( ) <NEWLINE> <NL> a = int ( Input [ 0 ] ) <NEWLINE> op = Input [ 1 ] <NEWLINE> b = int ( Input [ 2 ] ) <NEWLINE> <NL> if op == <STRING> : <NEWLINE> <INDENT> ans = a + b <NEWLINE> print ans <NEWLINE> <DEDENT> elif op == <STRING> : <NEWLINE> <INDENT> ans = a - b <NEWLINE> print ans <NEWLINE> <DEDENT> elif op == <STRING> : <NEWLINE> <INDENT> ans = a / b <NEWLINE> print ans <NEWLINE> <DEDENT> elif op == <STRING> : <NEWLINE> <INDENT> ans = a * b <NEWLINE> print ans <NEWLINE> <DEDENT> elif op == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <NL> <NL> <NL> <DEDENT> <DEDENT> Compile Error Logs : <NEWLINE> <NL> You are not authorized to see the message . <NEWLINE> <NL> <NL> Status <NEWLINE> Judge : 5 / 5 Python CPU : 00.01 sec Memory : 6436 KB Length : 376 B 2016 - 0 1 - 27 11 : 43 2016 - 0 1 - 27 11 : 43 <NEWLINE> Results for testcases <NEWLINE> Case <COMMENT> <NEWLINE> <INDENT> Case <COMMENT> <NEWLINE> Case <COMMENT> <NEWLINE> Case <COMMENT> <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> a , op , b = input ( ) . split ( ) <NEWLINE> a = int ( a ) <NEWLINE> b = int ( b ) <NEWLINE> <NL> if op == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <NL> <NL> <DEDENT> if op == <STRING> : <NEWLINE> <INDENT> print ( a + b ) <NEWLINE> <NL> <DEDENT> if op == <STRING> : <NEWLINE> <INDENT> print ( a - b ) <NEWLINE> <NL> <DEDENT> if op == <STRING> : <NEWLINE> <INDENT> print ( a * b ) <NEWLINE> <NL> <DEDENT> if op == <STRING> : <NEWLINE> <INDENT> print ( a / b ) <NEWLINE> <NL> break <NEWLINE> <DEDENT> <DEDENT>
a , o , b = input ( ) . split ( ) <NEWLINE> a , b = map ( int , ( a , b ) ) <NEWLINE> print ( a + b if o == <STRING> : else a - b if o == <STRING> : else a * b if o == <STRING> : else a / b ) <NEWLINE>
import sys , operator <NEWLINE> <NL> list = { <STRING> : operator . add , <STRING> : operator . sub , <STRING> : operator . mul , <STRING> : operator . div } <NEWLINE> <NL> for line in sys . stdin : <NEWLINE> <INDENT> a , op , b = line . split ( ) <NEWLINE> if op == <STRING> : break <NEWLINE> print ( int ( list [ op ] ( a , b ) ) ) <NEWLINE> <DEDENT>
a , op , b = ( str ( i ) for i in input ( ) . split ( ) ) <NEWLINE> if op != <STRING> : <NEWLINE> <INDENT> if op == <STRING> : print ( int ( a ) + int ( b ) ) <NEWLINE> if op == <STRING> : print ( int ( a ) - int ( b ) ) <NEWLINE> if op == <STRING> : print ( int ( a ) * int ( b ) ) <NEWLINE> if op == <STRING> and int ( a ) % int ( b ) == 0 : print ( int ( a ) // int ( b ) ) <NEWLINE> else : print ( int ( a ) % int ( b ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> a , op , b = ( str , input ( ) . split ( ) ) <NEWLINE> <NL> a = int ( a ) <NEWLINE> b = int ( b ) <NEWLINE> if op == <STRING> : <NEWLINE> <INDENT> print ( a + b ) <NEWLINE> <DEDENT> elif op == <STRING> : <NEWLINE> <INDENT> print ( a - b ) <NEWLINE> <DEDENT> elif op == <STRING> : <NEWLINE> <INDENT> print ( a * b ) <NEWLINE> <DEDENT> elif op == <STRING> : <NEWLINE> <INDENT> print ( a / b ) <NEWLINE> <DEDENT> elif op == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT>
a , op , b = input ( ) . split ( ) <NEWLINE> a = int ( a ) <NEWLINE> b = int ( b ) <NEWLINE> if op == <STRING> : <NEWLINE> <INDENT> print ( a + b ) <NEWLINE> <DEDENT> elif op == <STRING> : <NEWLINE> <INDENT> print ( a - b ) <NEWLINE> <DEDENT> elif op == <STRING> : <NEWLINE> <INDENT> print ( a * b ) <NEWLINE> <DEDENT> elif op == <STRING> : <NEWLINE> <INDENT> print ( a // b ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT>
s [ 1 ] = <STRING> <NEWLINE> while s [ 1 ] != <STRING> : <NEWLINE> <INDENT> s = raw_input ( ) . split ( ) <NEWLINE> if s [ 1 ] == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> a = int ( s [ 0 ] ) <NEWLINE> b = int ( s [ 2 ] ) <NEWLINE> if s [ 1 ] == <STRING> : <NEWLINE> <INDENT> print a + b <NEWLINE> <DEDENT> if s [ 1 ] == <STRING> : <NEWLINE> <INDENT> print a - b <NEWLINE> <DEDENT> if s [ 1 ] == <STRING> : <NEWLINE> <INDENT> print a * b <NEWLINE> <DEDENT> if s [ 1 ] == <STRING> : <NEWLINE> <INDENT> print a / b <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> for line in sys . stdin : <NEWLINE> <INDENT> a , b , c = line . split ( ) <NEWLINE> a , c = int ( a ) , int ( c ) <NEWLINE> p = <STRING> . index ( b ) <NEWLINE> if p = 0 : a += c <NEWLINE> elif p == 1 : a -= c <NEWLINE> elif p == 2 : a *= c <NEWLINE> elif p == 3 : a /= c <NEWLINE> elif p == 4 : break <NEWLINE> print a <NEWLINE> <DEDENT>
x = input ( ) . split ( ) <NEWLINE> a = int ( x [ 0 ] ) <NEWLINE> op = x [ 1 ] <NEWLINE> b = int ( x [ 2 ] ) <NEWLINE> for i in I : <NEWLINE> <INDENT> if op == <STRING> : <NEWLINE> <INDENT> A = a + b <NEWLINE> prnit ( A ) <NEWLINE> <DEDENT> elif op == <STRING> : <NEWLINE> <INDENT> B = a - b <NEWLINE> print ( B ) <NEWLINE> <DEDENT> elif op == <STRING> : <NEWLINE> <INDENT> C = a * b <NEWLINE> print ( C ) <NEWLINE> <DEDENT> elif op == <STRING> : <NEWLINE> <INDENT> D = a // b <NEWLINE> print ( D ) <NEWLINE> <DEDENT> elif op == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT>
while True : <NEWLINE> <INDENT> a , op , b = input ( ) . split ( ) <NEWLINE> a = int ( a ) <NEWLINE> b = int ( b ) <NEWLINE> if op = <STRING> : <NEWLINE> <INDENT> print ( a + b ) <NEWLINE> <DEDENT> elif op = <STRING> : <NEWLINE> <INDENT> print ( a - b ) <NEWLINE> <DEDENT> elif op = <STRING> : <NEWLINE> <INDENT> print ( a * b ) <NEWLINE> <DEDENT> elif op = <STRING> : <NEWLINE> <INDENT> print ( a // b ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT>
while 1 : <NEWLINE> <INDENT> s = raw_input ( ) . split ( ) <NEWLINE> a , b = s [ 0 ] , s [ 2 ] <NEWLINE> op = s [ 1 ] <NEWLINE> <NL> if op == <STRING> : <NEWLINE> <INDENT> print <STRING> % ( a + b ) <NEWLINE> <DEDENT> elif op == <STRING> : <NEWLINE> <INDENT> print <STRING> % ( a - b ) <NEWLINE> <DEDENT> elif op == <STRING> : <NEWLINE> <INDENT> print <STRING> % ( a * b ) <NEWLINE> <DEDENT> elif op == <STRING> : <NEWLINE> <INDENT> print <STRING> % ( a / b ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> a , op , c = sys . stdin . readline ( ) . split ( ) <NEWLINE> def ope ( a , op , b ) : <NEWLINE> <INDENT> if op == <STRING> : ret = a + b <NEWLINE> if op == <STRING> : ret = a - b <NEWLINE> if op == <STRING> : ret = a * b <NEWLINE> if op == <STRING> : ret = a / b <NEWLINE> return ret <NEWLINE> <DEDENT> print ( ope ( a , op , b ) ) <NEWLINE>
while 1 : <NEWLINE> <INDENT> a , b , c = raw_input ( ) . split ( ) <NEWLINE> if b == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> a = int ( a ) <NEWLINE> c = int ( c ) <NEWLINE> if b == <STRING> : <NEWLINE> <INDENT> print a + c <NEWLINE> <DEDENT> elif b == <STRING> : <NEWLINE> <INDENT> print a * c <NEWLINE> <DEDENT> elif b == <STRING> <NEWLINE> <INDENT> print a // c <NEWLINE> <DEDENT> <DEDENT>
while True : <NEWLINE> <INDENT> a , op , b = map ( str , raw_input ( ) . split ( ) ) <NEWLINE> if op == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if op == <STRING> : <NEWLINE> <INDENT> op = <STRING> <NEWLINE> <DEDENT> formula = a + op + b <NEWLINE> print ( eval ( formula ) ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> table = input ( ) . split ( ) <NEWLINE> <DEDENT> a = int ( table [ 0 ] ) <NEWLINE> op = table [ 1 ] <NEWLINE> b = int ( table [ 2 ] ) <NEWLINE> <NL> if op == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> elif op == <STRING> : <NEWLINE> <INDENT> print ( <STRING> % ( a + b ) ) <NEWLINE> <DEDENT> elif op == <STRING> : <NEWLINE> <INDENT> print ( <STRING> % ( a - b ) ) <NEWLINE> <DEDENT> elif op == <STRING> : <NEWLINE> <INDENT> print ( <STRING> % ( a * b ) ) <NEWLINE> <DEDENT> elif op == <STRING> : <NEWLINE> <INDENT> print ( <STRING> % ( a / b ) ) <NEWLINE> <NL> <NL> <DEDENT>
while 1 : <NEWLINE> <INDENT> a , b , c = map ( str , input ( ) . split ( ) ) <NEWLINE> a , c = int ( a ) , int ( c ) <NEWLINE> if b == <STRING> : <NEWLINE> <INDENT> print ( a + c ) <NEWLINE> <DEDENT> elif b == <STRING> : print ( a - c ) <NEWLINE> elif b == <STRING> : print ( a * c ) <NEWLINE> elif b == <STRING> : print ( a / c ) <NEWLINE> else : break <NEWLINE> <DEDENT>
<NL> flag = 0 <NEWLINE> while flag == 0 : <NEWLINE> <INDENT> a , b , c = [ i for i in input ( ) . split ( ) ] ) <NEWLINE> if b == <STRING> : <NEWLINE> <INDENT> flag = 1 <NEWLINE> break <NEWLINE> <DEDENT> elif b == <STRING> : <NEWLINE> <INDENT> n = int ( a ) + int ( c ) <NEWLINE> <DEDENT> elif b == <STRING> : <NEWLINE> <INDENT> n = int ( a ) - int ( c ) <NEWLINE> <DEDENT> elif b == <STRING> : <NEWLINE> <INDENT> n = int ( a ) * int ( c ) <NEWLINE> <DEDENT> elif b == <STRING> : <NEWLINE> <INDENT> n = int ( a ) / int ( c ) <NEWLINE> <DEDENT> print ( int ( b ) <NEWLINE> <DEDENT>
while True <NEWLINE> <INDENT> a , op , b = input ( ) . split ( ) <NEWLINE> a = float ( a ) <NEWLINE> b = float ( b ) <NEWLINE> if op == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if op == <STRING> : <NEWLINE> <INDENT> ans = a + b <NEWLINE> <DEDENT> elif op == <STRING> : <NEWLINE> <INDENT> ans = a - b <NEWLINE> <DEDENT> elif op == <STRING> : <NEWLINE> <INDENT> ans = a * b <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> rem = a % b <NEWLINE> if rem == 0 : <NEWLINE> <INDENT> ans = a / b <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = int ( a / b ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
<INDENT> while True : <NEWLINE> <INDENT> x = input ( ) . split ( <STRING> ) <NEWLINE> a = int ( x [ 0 ] ) <NEWLINE> op = x [ 1 ] <NEWLINE> b = int ( x [ 2 ] ) <NEWLINE> if ( op == <STRING> ) : <NEWLINE> <INDENT> print ( a + b ) <NEWLINE> <DEDENT> elif ( op == <STRING> ) : <NEWLINE> <INDENT> print ( a - b ) <NEWLINE> <DEDENT> elif ( op == <STRING> ) : <NEWLINE> <INDENT> print ( a * b ) <NEWLINE> <DEDENT> elif ( op == <STRING> ) : <NEWLINE> <INDENT> print ( a / b ) <NEWLINE> <DEDENT> elif ( op == <STRING> ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
while 1 : <NEWLINE> <NL> x , op , y = raw_input ( ) . split ( ) <NEWLINE> <NL> if op == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> x = int ( x ) <NEWLINE> y = int ( y ) <NEWLINE> <NL> if op == <STRING> : <NEWLINE> <INDENT> print x + y <NEWLINE> <DEDENT> elif op == <STRING> : <NEWLINE> <INDENT> print x - y <NEWLINE> <DEDENT> elif op == <STRING> : <NEWLINE> <INDENT> print x * y <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print x / y <NEWLINE> <DEDENT>
while ( 1 ) : <NEWLINE> <INDENT> x = raw_input ( ) <NEWLINE> x = x . split ( <STRING> ) <NEWLINE> if ( x == <STRING> ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> a = int ( x [ 0 ] ) <NEWLINE> op = str ( x [ 1 ] ) <NEWLINE> b = int ( x [ 2 ] ) <NEWLINE> if ( op == <STRING> ) : <NEWLINE> <INDENT> print a + b <NEWLINE> <DEDENT> elif ( op == <STRING> ) : <NEWLINE> <INDENT> print a - b <NEWLINE> <DEDENT> elif ( op == <STRING> ) : <NEWLINE> <INDENT> print a * b <NEWLINE> <DEDENT> elif ( op == <STRING> ) : <NEWLINE> <INDENT> print a / b <NEWLINE> <DEDENT> <DEDENT>
while ( True ) : <NEWLINE> <INDENT> a , op , b = map ( input ( ) . spilt ( ) ) <NEWLINE> a = int ( a ) <NEWLINE> b = int ( b ) <NEWLINE> if ( op == <STRING> ) : <NEWLINE> <INDENT> print ( a + b ) <NEWLINE> <DEDENT> elif ( op == <STRING> ) : <NEWLINE> <INDENT> print ( a - b ) <NEWLINE> <DEDENT> elif ( op == <STRING> ) : <NEWLINE> <INDENT> print ( a * b ) <NEWLINE> <DEDENT> elif ( op == <STRING> ) : <NEWLINE> <INDENT> print ( a // b ) <NEWLINE> <DEDENT> elif ( op == <STRING> ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT>
while True : <NEWLINE> <INDENT> s = raw_input ( ) . split <NEWLINE> a = int ( s [ 0 ] ) <NEWLINE> op = s [ 1 ] <NEWLINE> b = int ( s [ 2 ] ) <NEWLINE> if op == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> elif op == <STRING> : <NEWLINE> <INDENT> print ( a + b ) <NEWLINE> <DEDENT> elif op == <STRING> : <NEWLINE> <INDENT> print ( a - b ) <NEWLINE> <DEDENT> elif op == <STRING> : <NEWLINE> <INDENT> print ( a * b ) <NEWLINE> <DEDENT> elif op == <STRING> : <NEWLINE> <INDENT> print ( a / b ) <NEWLINE> <DEDENT> <DEDENT>
while True : <NEWLINE> <INDENT> a , op , b = input ( ) . split ( ) <NEWLINE> a = int ( a ) <NEWLINE> b = int ( b ) <NEWLINE> if op == <STRING> : <NEWLINE> <INDENT> print ( a + b ) <NEWLINE> <DEDENT> elif op == <STRING> : <NEWLINE> <INDENT> print ( a - b ) <NEWLINE> <DEDENT> elif op == <STRING> : <NEWLINE> <INDENT> print ( a * b ) <NEWLINE> <DEDENT> elif op == <STRING> : <NEWLINE> <INDENT> print ( a // b ) <NEWLINE> <DEDENT> <DEDENT>
while True : <NEWLINE> <INDENT> a , op , b = input ( ) <NEWLINE> <NL> if op == <STRING> : <NEWLINE> <INDENT> print ( int ( a ) + int ( b ) ) <NEWLINE> <NL> <DEDENT> if op == <STRING> : <NEWLINE> <INDENT> print ( a - b ) <NEWLINE> <NL> <DEDENT> elif op == <STRING> : <NEWLINE> <INDENT> print ( a * b ) <NEWLINE> <NL> <DEDENT> elif op == <STRING> : <NEWLINE> <INDENT> print ( a / b ) <NEWLINE> <NL> <DEDENT> elif op == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT>
while True : <NEWLINE> <INDENT> a , b , c = map ( str , raw_input ( ) . split ( ) ) <NEWLINE> a , c = int ( a ) , int ( c ) <NEWLINE> if b == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if b == <STRING> : <NEWLINE> <INDENT> print ( a + c ) <NEWLINE> <DEDENT> elif b == <STRING> : <NEWLINE> <INDENT> print ( a - c ) <NEWLINE> <DEDENT> elif b == <STRING> <NEWLINE> <INDENT> print ( a * c ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( a // c ) <NEWLINE> <DEDENT> <DEDENT>
while True : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> op = map ( str , input ( ) . split ( ) ) <NEWLINE> if op == <STRING> : <NEWLINE> <INDENT> print ( a + b ) <NEWLINE> <DEDENT> elif op == <STRING> : <NEWLINE> <INDENT> print ( a - b ) <NEWLINE> <DEDENT> elif op == <STRING> : <NEWLINE> <INDENT> print ( a * b ) <NEWLINE> <DEDENT> elif op == <STRING> : <NEWLINE> <INDENT> print ( a / b ) <NEWLINE> <DEDENT> elif op == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT>
while True : <NEWLINE> <INDENT> a , b , c = map ( str , input ( ) . split ( ) ) <NEWLINE> a = int ( a ) <NEWLINE> c = int ( c ) <NEWLINE> if ( c == <STRING> ) : <NEWLINE> <INDENT> print ( a + b ) <NEWLINE> <DEDENT> elif ( c == <STRING> ) : <NEWLINE> <INDENT> print ( a - b ) <NEWLINE> <DEDENT> elif ( c == <STRING> ) : <NEWLINE> <INDENT> print ( a * b ) <NEWLINE> <DEDENT> elif ( c == <STRING> ) <NEWLINE> <INDENT> print ( a / b ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT>
while True : <NEWLINE> <INDENT> _exp = raw_input ( ) <NEWLINE> if _exp == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> print ( eval ( _exp ) ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> a = raw_input ( ) <NEWLINE> if a == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> b = a . split ( ) <NEWLINE> for i , c in enumerate ( b ) : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> x = int ( c ) <NEWLINE> <DEDENT> elif i == 1 : <NEWLINE> <INDENT> y = c <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> z = int ( c ) <NEWLINE> <DEDENT> <DEDENT> if y == <STRING> : <NEWLINE> <INDENT> w = x + z <NEWLINE> <DEDENT> elif y == <STRING> : <NEWLINE> <INDENT> w = x - z <NEWLINE> <DEDENT> elif y == <STRING> : <NEWLINE> <INDENT> w = x * z <NEWLINE> <DEDENT> elif y == <STRING> : <NEWLINE> <INDENT> w = x / z <NEWLINE> <DEDENT> print w <NEWLINE> <DEDENT>
while 1 : <NEWLINE> <INDENT> a , o , b = input ( ) . split ( ) <NEWLINE> if o == <STRING> : break <NEWLINE> a , b = int ( a , b ) <NEWLINE> print ( a + b if o == <STRING> else a - b if o == <STRING> else a * b if o == <STRING> else a // b ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> a , op , b = input ( ) . split ( ) <NEWLINE> a = int ( a ) <NEWLINE> b = int ( b ) <NEWLINE> <NL> if op == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if op == <STRING> : <NEWLINE> <INDENT> ans = a + b <NEWLINE> <DEDENT> elif op == <STRING> : <NEWLINE> <INDENT> ans = a - b <NEWLINE> <DEDENT> elif op == <STRING> : <NEWLINE> <INDENT> ans = a * b <NEWLINE> <DEDENT> else op == <STRING> : <NEWLINE> <INDENT> ans = a / b <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> a , b , c = input ( ) . split ( ) <NEWLINE> if b == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> elif b == <STRING> : <NEWLINE> <INDENT> d = int ( a ) + int ( c ) <NEWLINE> <DEDENT> elif b == <STRING> : <NEWLINE> <INDENT> d = int ( a ) - int ( c ) <NEWLINE> <DEDENT> elif b == <STRING> : <NEWLINE> <INDENT> d = int ( a ) * int ( c ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d = int ( a ) / int ( c ) <NEWLINE> <DEDENT> print ( int ( d ) <NEWLINE> <DEDENT>
<INDENT> while True : <NEWLINE> <INDENT> ( a , op , b ) = [ int ( i ) if i . isdigit ( ) else i for i in input ( ) . split ( ) ] <NEWLINE> <NL> if op == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> elif op == <STRING> : <NEWLINE> <INDENT> print ( a + b ) <NEWLINE> <DEDENT> elif op == <STRING> : <NEWLINE> <INDENT> print ( a - b ) <NEWLINE> <DEDENT> elif op == <STRING> : <NEWLINE> <INDENT> print ( a * b ) <NEWLINE> <DEDENT> elif op == <STRING> : <NEWLINE> <INDENT> print ( a // b ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
while True : s = int ( input ( ) ) <NEWLINE> <INDENT> if <STRING> in s : break <NEWLINE> print ( eval ( s ) ) <NEWLINE> <DEDENT>
<NL> my_value_list = [ ] <NEWLINE> <NL> while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> my_value_list . append ( input ( ) . split ( ) ) <NEWLINE> <DEDENT> except EOFError : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> for i in my_value_list : <NEWLINE> <INDENT> if my_value_list [ i ] [ 2 ] == <STRING> : <NEWLINE> <INDENT> print ( int ( my_value_list [ i ] [ ] ) + int ( my_value_list [ i ] [ 2 ] ) ) <NEWLINE> <DEDENT> elif my_value_list [ i ] [ 2 ] == <STRING> : <NEWLINE> <INDENT> print ( int ( my_value_list [ i ] [ 0 ] ) - int ( my_value_list [ i ] [ 2 ] ) ) <NEWLINE> <DEDENT> elif my_value_list [ i ] [ 2 ] == <STRING> : <NEWLINE> <INDENT> print ( int ( my_value_list [ i ] [ 0 ] ) // int ( my_value_list [ i ] [ 2 ] ) ) <NEWLINE> <DEDENT> elif my_value_list [ i ] [ 2 ] == <STRING> : <NEWLINE> <INDENT> print ( int ( my_value_list [ i ] [ 0 ] ) * int ( my_value_list [ i ] [ 2 ] ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> <NL> while True : <NEWLINE> <INDENT> A = raw_input ( ) . split ( ) <NEWLINE> if A [ 1 ] == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if A [ 1 ] == <STRING> : <NEWLINE> <INDENT> print ( int ( A [ 0 ] ) + int ( A [ 2 ] ) <NEWLINE> <DEDENT> if A [ 1 ] == <STRING> : <NEWLINE> <INDENT> print ( int ( A [ 0 ] ) - int ( A [ 2 ] ) <NEWLINE> <DEDENT> if A [ 1 ] == <STRING> : <NEWLINE> <INDENT> print ( int ( A [ 0 ] ) * int ( A [ 2 ] ) <NEWLINE> <DEDENT> if A [ 1 ] == <STRING> : <NEWLINE> <INDENT> print ( int ( A [ 0 ] ) / int ( A [ 2 ] ) <NEWLINE> <NL> <NL> <NL> <DEDENT> <DEDENT>
while True : <NEWLINE> <INDENT> a , op , c = map ( str , input ( ) . split ( ) ) <NEWLINE> a = int ( a ) <NEWLINE> b = int ( b ) <NEWLINE> if op == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if op == <STRING> : <NEWLINE> <INDENT> print ( a + b ) <NEWLINE> <DEDENT> if op == <STRING> : <NEWLINE> <INDENT> print ( a - b ) <NEWLINE> <DEDENT> if op == <STRING> : <NEWLINE> <INDENT> print ( a * b ) <NEWLINE> <DEDENT> if op == <STRING> : <NEWLINE> <INDENT> print ( a // b ) <NEWLINE> <DEDENT> <DEDENT>
while True : <NEWLINE> <INDENT> a , op , b = map ( str , raw_input ( ) . split ( ) ) <NEWLINE> a = int ( a ) <NEWLINE> b = int ( b ) <NEWLINE> <NL> if ( op == <STRING> ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if ( op == <STRING> ) : <NEWLINE> <INDENT> print s + b <NEWLINE> <DEDENT> elif ( op == <STRING> ) : <NEWLINE> <INDENT> print a - b <NEWLINE> <DEDENT> elif ( op == <STRING> ) : <NEWLINE> <INDENT> print a * b <NEWLINE> <DEDENT> elif ( op == <STRING> ) : <NEWLINE> <INDENT> print a / b <NEWLINE> <DEDENT> <DEDENT>
while True : <NEWLINE> <INDENT> a , op , b = input ( ) . split ( ) <NEWLINE> <NL> if op == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> elif op == <STRING> : <NEWLINE> <INDENT> print ( <STRING> . format ( a + b ) ) <NEWLINE> <DEDENT> elif op == <STRING> : <NEWLINE> <INDENT> print ( <STRING> . format ( a - b ) ) <NEWLINE> <DEDENT> elif op == <STRING> : <NEWLINE> <INDENT> print ( <STRING> . format ( a // b ) ) <NEWLINE> <DEDENT> elif op == <STRING> : <NEWLINE> <INDENT> print ( <STRING> . format ( a * b ) ) <NEWLINE> <DEDENT> <DEDENT>
while True : <NEWLINE> <INDENT> a , op , b = map ( str , raw_input ( ) . split ( ) ) <NEWLINE> a = int ( a ) <NEWLINE> b = int ( b ) <NEWLINE> <NL> if op == <STRING> : <NEWLINE> <INDENT> print a + b <NEWLINE> <DEDENT> elif op == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> elif op == <STRING> : <NEWLINE> <INDENT> print a - b <NEWLINE> <DEDENT> elif op == <STRING> : <NEWLINE> <INDENT> print a / b <NEWLINE> <DEDENT> elif op == <STRING> : <NEWLINE> <INDENT> ptint a * b <NEWLINE> <DEDENT> <DEDENT>
while 1 : <NEWLINE> <INDENT> a , op , b = map ( raw_input ( ) . split ( ) ) <NEWLINE> A = int ( a ) <NEWLINE> B = int ( b ) <NEWLINE> <NL> if op == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> elif op == <STRING> : <NEWLINE> <INDENT> print A + B <NEWLINE> <DEDENT> elif op == <STRING> : <NEWLINE> <INDENT> print A - B <NEWLINE> <DEDENT> elif op == <STRING> : <NEWLINE> <INDENT> print A * B <NEWLINE> <DEDENT> elif op == <STRING> : <NEWLINE> <INDENT> print A / B <NEWLINE> <DEDENT> <DEDENT>
i = 0 <NEWLINE> <NL> while i == 0 : <NEWLINE> <INDENT> x = raw_input ( ) <NEWLINE> a , op , b = x . split ( ) <NEWLINE> a = int ( a ) <NEWLINE> b = int ( b ) <NEWLINE> <NL> if <STRING> == <STRING> : <NEWLINE> <INDENT> print ( <STRING> & ( a + b ) ) <NEWLINE> <DEDENT> elif <STRING> == <STRING> : <NEWLINE> <INDENT> print ( <STRING> & ( a - b ) ) <NEWLINE> <DEDENT> elif <STRING> == <STRING> : <NEWLINE> <INDENT> print ( <STRING> & ( a * b ) ) <NEWLINE> <DEDENT> elif <STRING> == <STRING> : <NEWLINE> <INDENT> print ( <STRING> & ( a / b ) ) <NEWLINE> <DEDENT> elif <STRING> == <STRING> : <NEWLINE> <INDENT> i == 1 <NEWLINE> <DEDENT> <DEDENT>
while True : <NEWLINE> <INDENT> a , op , b = raw_input ( ) . split <NEWLINE> if op == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if op == <STRING> : <NEWLINE> <INDENT> print a + b <NEWLINE> <DEDENT> elif op == <STRING> : <NEWLINE> <INDENT> print a - b <NEWLINE> <DEDENT> elif op == <STRING> : <NEWLINE> <INDENT> print a * b <NEWLINE> <DEDENT> elif op == <STRING> : <NEWLINE> <INDENT> print a / b <NEWLINE> <DEDENT> <DEDENT>
while True : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> if <STRING> in data : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> print ( int ( eval ( s ) ) ) <NEWLINE> <DEDENT>
from sys import stdin <NEWLINE> <NL> while True : <NEWLINE> <INDENT> a , op , b = stdin . readline ( ) . rstrip ( ) . split ( ) <NEWLINE> else if op == <STRING> : <NEWLINE> <INDENT> print ( int ( a ) + int ( b ) ) <NEWLINE> <DEDENT> else if op == <STRING> : <NEWLINE> <INDENT> print ( int ( a ) - int ( b ) ) <NEWLINE> <DEDENT> else if op == <STRING> : <NEWLINE> <INDENT> print ( int ( a ) * int ( b ) ) <NEWLINE> <DEDENT> else if op == <STRING> : <NEWLINE> <INDENT> print ( int ( a ) // int ( b ) ) <NEWLINE> <DEDENT> else : <COMMENT> <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT>
import sys <NEWLINE> <NL> a , b , c = sys . stdin . realine . split ( ) <NEWLINE> if b == <STRING> : <NEWLINE> <INDENT> d = a + c <NEWLINE> print ( d ) <NEWLINE> <DEDENT> if b == <STRING> : <NEWLINE> <INDENT> d = a - c <NEWLINE> print ( d ) <NEWLINE> <DEDENT> if b == <STRING> : <NEWLINE> <INDENT> d = a * c <NEWLINE> print ( d ) <NEWLINE> <DEDENT> if b == <STRING> : <NEWLINE> <INDENT> d = a // c <NEWLINE> print ( d ) <NEWLINE> <DEDENT>
a , op , b = input ( ) . split ( ) <NEWLINE> a = int ( a ) <NEWLINE> b = int ( b ) <NEWLINE> if op == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> elif op == <STRING> : <NEWLINE> <INDENT> print ( a + b ) <NEWLINE> <DEDENT> elif op == <STRING> : <NEWLINE> <INDENT> print ( a - b ) <NEWLINE> <DEDENT> elif op == <STRING> : <NEWLINE> <INDENT> print ( a * b ) <NEWLINE> <DEDENT> elif op == <STRING> : <NEWLINE> <INDENT> print ( a // b ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> l = [ ] <NEWLINE> for line in sys . stdin . readline ( ) : <NEWLINE> <INDENT> l . append ( line ) <NEWLINE> <NL> <DEDENT> for i in l : <NEWLINE> <INDENT> a , op , b = i . split ( ) <NEWLINE> if op == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> print eval ( i ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> a , op , b = map ( str , input ( ) split ( ) ) <NEWLINE> if op == <STRING> : <NEWLINE> <INDENT> s = int ( a ) + int ( b ) <NEWLINE> <DEDENT> elif op == <STRING> : <NEWLINE> <INDENT> s = int ( a ) - int ( b ) <NEWLINE> <DEDENT> elif op == <STRING> : <NEWLINE> <INDENT> s = int ( a ) * int ( b ) <NEWLINE> <DEDENT> elif op == <STRING> : <NEWLINE> <INDENT> s = int ( a ) // int ( b ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> print ( s ) <NEWLINE>
l = raw_input ( ) <NEWLINE> k = l . split ( ) <NEWLINE> a = int ( k [ 0 ] ) <NEWLINE> b = k [ 3 ] <NEWLINE> c = int ( k [ 2 ] ) <NEWLINE> <COMMENT> <NL> if b = <STRING> : <NEWLINE> <INDENT> print a + b <NEWLINE> <DEDENT> if b = <STRING> : <NEWLINE> <INDENT> print a - b <NEWLINE> <DEDENT> if b = <STRING> : <NEWLINE> <INDENT> print a * b <NEWLINE> <DEDENT> if b = <STRING> : <NEWLINE> <INDENT> print a / b <NEWLINE> <DEDENT>
while op != <STRING> : <NEWLINE> <INDENT> a , op , b = map ( str , input ( ) . split ( ) ) <NEWLINE> a , b = int ( a ) , int ( b ) <NEWLINE> <NL> if op == <STRING> : <NEWLINE> <INDENT> output = a + b <NEWLINE> <DEDENT> elif op == <STRING> : <NEWLINE> <INDENT> output = a - b <NEWLINE> <DEDENT> elif op == <STRING> : <NEWLINE> <INDENT> output = a * b <NEWLINE> <DEDENT> elif op == <STRING> : <NEWLINE> <INDENT> output = a // b <NEWLINE> <DEDENT> print ( output ) <NEWLINE> <DEDENT>
while 1 : <NEWLINE> <INDENT> l = raw_input ( ) <NEWLINE> if l . find ( <STRING> ) == 2 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> print eval ( l ) <NEWLINE> <DEDENT>
<INDENT> from sys import stdin <NEWLINE> <NL> <DEDENT> while True : <NEWLINE> <INDENT> ( a , op , b ) = stdin . readline ( ) . split ( <STRING> ) <NEWLINE> a = int ( a ) <NEWLINE> b = int ( b ) <NEWLINE> if op == <STRING> : <NEWLINE> <INDENT> break ; <NEWLINE> <DEDENT> elif op == <STRING> : <NEWLINE> <INDENT> print ( a + b ) <NEWLINE> <DEDENT> elif op == <STRING> : <NEWLINE> <INDENT> print ( a - b ) <NEWLINE> <DEDENT> elif op == <STRING> : <NEWLINE> <INDENT> print ( a * b ) <NEWLINE> <DEDENT> elif op == <STRING> : <NEWLINE> <INDENT> print ( a // b ) <NEWLINE> <DEDENT> <DEDENT>
while True : <NEWLINE> <INDENT> a , op , b = input ( ) . split ( ) <NEWLINE> a = int ( a ) <NEWLINE> b = int ( b ) <NEWLINE> if op == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( a op b ) <NEWLINE> <DEDENT> <DEDENT>
a = [ ] <NEWLINE> while True : <NEWLINE> <INDENT> n = input ( ) <NEWLINE> if n . find ( <STRING> ) > 0 : break <NEWLINE> a . append ( n ) <NEWLINE> <DEDENT> for s in a : <NEWLINE> <INDENT> t = s . split ( ) <NEWLINE> if t [ 1 ] == <STRING> : print ( int ( t [ 0 ] ) // int ( t [ 2 ] ) ) <NEWLINE> else : print ( eval ( <STRING> . join ( t ) ) <NEWLINE> <DEDENT>
x = raw_input ( ) . split ( ) <NEWLINE> a , op , b = int ( x [ 0 ] ) , x [ 1 ] , int ( x [ 2 ] ) <NEWLINE> if op == <STRING> : <NEWLINE> <INDENT> print a + b <NEWLINE> <DEDENT> elif op == <STRING> : <NEWLINE> <INDENT> print a - b <NEWLINE> <DEDENT> elif op == <STRING> : <NEWLINE> <INDENT> print a * b <NEWLINE> <DEDENT> elif op == <STRING> : <NEWLINE> <INDENT> print a / b <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <NL> <NL> <NL> <DEDENT>
def cal ( a , op , b ) : <NEWLINE> <NL> <INDENT> if op == <STRING> : <NEWLINE> <INDENT> r = a + b <NEWLINE> <DEDENT> elif op == <STRING> : <NEWLINE> <INDENT> r = a + b <NEWLINE> <DEDENT> elif op == <STRING> : <NEWLINE> <INDENT> r = a * b <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> r = a / b <NEWLINE> <DEDENT> return r <NEWLINE> <NL> <DEDENT> while 1 : <NEWLINE> <INDENT> a , op , b = raw_input ( ) . split ( ) <NEWLINE> if op == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cal ( int ( a ) , op , int ( b ) ) <NEWLINE> print r <NEWLINE> <DEDENT> <DEDENT>
while ( true ) : <NEWLINE> <INDENT> a , op , b = input ( ) . split ( ) <NEWLINE> <NL> if ( op == <STRING> ) : <NEWLINE> <INDENT> print ( int ( a ) + int ( b ) ) <NEWLINE> <DEDENT> elif ( op == <STRING> ) : <NEWLINE> <INDENT> print ( int ( a ) - int ( b ) ) <NEWLINE> <DEDENT> elif ( op == <STRING> ) : <NEWLINE> <INDENT> print ( int ( a ) * int ( b ) ) <NEWLINE> <DEDENT> elif ( op == <STRING> ) : <NEWLINE> <INDENT> print ( int ( a ) // int ( b ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT>
while ( True ) : <NEWLINE> <INDENT> a , op , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if ( op == <STRING> ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> elif ( op == <STRING> ) : <NEWLINE> <INDENT> print ( a + b ) <NEWLINE> <DEDENT> elif ( op == <STRING> ) : <NEWLINE> <INDENT> print ( a - b ) <NEWLINE> <DEDENT> elif ( op == <STRING> ) : <NEWLINE> <INDENT> print ( a * b ) <NEWLINE> <DEDENT> elif ( op == <STRING> ) : <NEWLINE> <INDENT> print ( a // b ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT>
<COMMENT> <NL> <NL> while True : <NEWLINE> <INDENT> a , op , b = map ( str , raw_input ( ) . split ( ) ) <NEWLINE> a = int ( a ) <NEWLINE> b = int ( b ) <NEWLINE> if op == <STRING> : <NEWLINE> <INDENT> print a + b <NEWLINE> <DEDENT> elif op == <STRING> : <NEWLINE> <INDENT> print a - b <NEWLINE> <DEDENT> elif op == <STRING> : <NEWLINE> <INDENT> print a * b <NEWLINE> <DEDENT> elif op == <STRING> : <NEWLINE> <INDENT> print a / b <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> <DEDENT>
while True : <NEWLINE> <INDENT> l = input ( ) <NEWLINE> if l [ 1 ] == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> print ( eval ( l ) ) <NEWLINE> <NL> <DEDENT>
while True : <NEWLINE> <INDENT> ( a , op , b ) = [ int ( i ) if i . isdigit ( ) else i for i in input ( ) ] <NEWLINE> <NL> if op == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> elif op == <STRING> : <NEWLINE> <INDENT> print ( a + b ) <NEWLINE> <DEDENT> elif op == <STRING> : <NEWLINE> <INDENT> print ( a - b ) <NEWLINE> <DEDENT> elif op == <STRING> : <NEWLINE> <INDENT> print ( a * b ) <NEWLINE> <DEDENT> elif op == <STRING> : <NEWLINE> <INDENT> print ( a // b ) <NEWLINE> <DEDENT> <DEDENT>
While True : <NEWLINE> <INDENT> a , op , b = input ( ) . split ( ) <NEWLINE> a , b = int ( a ) , int ( b ) <NEWLINE> op_dict = { <STRING> : ( lambda x , y : x + y ) , <NEWLINE> <INDENT> <STRING> : ( lambda x , y : x - y ) , <NEWLINE> <STRING> : ( lambda x , y : x * y ) , <NEWLINE> <STRING> : ( lambda x , y : x // y ) , <NEWLINE> <STRING> : <STRING> } <NEWLINE> <DEDENT> func = op_dict [ op ] <NEWLINE> if func == <STRING> : break <NEWLINE> print ( <STRING> % int ( func ( a , b ) ) ) <NEWLINE> <DEDENT>
inport sys <NEWLINE> str = [ ] <NEWLINE> for line in sys . stdin . readlines ( ) <NEWLINE> <INDENT> str . append ( line . rstrip ( ) ) <NEWLINE> <DEDENT> num = len ( str ) <NEWLINE> for i in range ( num ) <NEWLINE> <INDENT> s = str . split ( <STRING> ) <NEWLINE> a = int ( s [ 0 ] ) <NEWLINE> b = s [ 1 ] <NEWLINE> c = s [ 2 ] <NEWLINE> if b == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if b == <STRING> : <NEWLINE> <INDENT> print ( a + c ) <NEWLINE> <DEDENT> if b == <STRING> : <NEWLINE> <INDENT> print ( a - c ) <NEWLINE> <DEDENT> if b == <STRING> : <NEWLINE> <INDENT> print ( a * c ) <NEWLINE> <DEDENT> if b == <STRING> <NEWLINE> <INDENT> print ( int ( a / c ) ) <NEWLINE> <DEDENT> <DEDENT>
import math <NEWLINE> def solve ( input_text ) : <NEWLINE> <INDENT> for line in input_text : <NEWLINE> <INDENT> op = line [ 1 ] <NEWLINE> a = int ( line [ 0 ] ) <NEWLINE> b = int ( line [ 2 ] ) <NEWLINE> ans = 0 <NEWLINE> <NL> if op == <STRING> : <NEWLINE> <INDENT> ans = a + b <NEWLINE> <DEDENT> if op == <STRING> : <NEWLINE> <INDENT> ans = a - b <NEWLINE> <DEDENT> if op == <STRING> : <NEWLINE> <INDENT> ans = a * b <NEWLINE> <DEDENT> if op == <STRING> : <NEWLINE> <INDENT> ans = math . float ( a / b ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> <DEDENT> def answer ( ) : <NEWLINE> <INDENT> input_text = [ ] <NEWLINE> line = [ ] <NEWLINE> <NL> while True : <NEWLINE> <NL> <INDENT> line = input ( ) <NEWLINE> line = line . split ( <STRING> ) <NEWLINE> if line [ 1 ] == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> input_text . append ( line ) <NEWLINE> <NL> <DEDENT> solve ( input_text ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> answer ( ) <NEWLINE> <DEDENT>
l = [ str ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> a = int ( l [ 0 ] ) <NEWLINE> b = int ( l [ 2 ] ) <NEWLINE> op = l [ 1 ] <NEWLINE> <NL> while True : <NEWLINE> <NL> <INDENT> if op == <STRING> : <NEWLINE> <INDENT> print ( a + b ) <NEWLINE> <NL> <DEDENT> elif op == <STRING> : <NEWLINE> <INDENT> print ( a - b ) <NEWLINE> <NL> <DEDENT> elif op == <STRING> : <NEWLINE> <INDENT> print ( a * b ) <NEWLINE> <NL> <DEDENT> elif op == <STRING> : <NEWLINE> <INDENT> print ( a // b ) <NEWLINE> <NL> <DEDENT> elif op == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT>
<STRING> <NEWLINE> <COMMENT> <NL> import sys <NEWLINE> <NL> <COMMENT> <NL> for inputData in sys . stdin : <NEWLINE> <INDENT> a , op , b = map ( int , input ( ) . split ( ) ) <NEWLINE> retVal = 0 <NEWLINE> <NL> <COMMENT> <NL> if op == <STRING> : <NEWLINE> <COMMENT> <NL> <INDENT> break <NEWLINE> <DEDENT> elif op == <STRING> : <NEWLINE> <INDENT> retVal = int ( a ) + int ( b ) <NEWLINE> <DEDENT> elif op == <STRING> : <NEWLINE> <INDENT> retVal = int ( a ) - int ( b ) <NEWLINE> <DEDENT> elif op == <STRING> : <NEWLINE> <INDENT> retVal = int ( a ) * int ( b ) <NEWLINE> <DEDENT> elif op == <STRING> : <NEWLINE> <INDENT> retVal = int ( a ) / int ( b ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> retVal = 0 <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> print ( retVal ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> a , op , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if op == <STRING> : <NEWLINE> <INDENT> result = a + b <NEWLINE> <DEDENT> if op == <STRING> : <NEWLINE> <INDENT> result = a - b <NEWLINE> <DEDENT> if op == <STRING> : <NEWLINE> <INDENT> result = a * b <NEWLINE> <DEDENT> if op == <STRING> : <NEWLINE> <INDENT> result = a / b <NEWLINE> <DEDENT> if op == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> print ( result ) <NEWLINE> <DEDENT>
while ( True ) : <NEWLINE> <INDENT> instr = input ( ) <NEWLINE> if ( instr == <STRING> ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> a , op , b = instr . split ( ) <NEWLINE> a = int ( a ) <NEWLINE> b = int ( b ) <NEWLINE> if op == <STRING> : <NEWLINE> <INDENT> print ( <STRING> . format ( a + b ) ) <NEWLINE> <DEDENT> elif op == <STRING> : <NEWLINE> <INDENT> print ( <STRING> . format ( a - b ) ) <NEWLINE> <DEDENT> elif op == <STRING> : <NEWLINE> <INDENT> print ( <STRING> . format ( a * b ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> . format ( int ( a / b ) ) ) <NEWLINE> <DEDENT> <DEDENT>
x , b , z = input ( ) . split ( ) <NEWLINE> a = int ( x ) <NEWLINE> c = int ( z ) <NEWLINE> while b != <STRING> : <NEWLINE> <INDENT> if b == <STRING> : <NEWLINE> <INDENT> print ( a + c ) <NEWLINE> <DEDENT> elif b == <STRING> : <NEWLINE> <INDENT> print ( int ( a ) - int ( c ) ) <NEWLINE> <DEDENT> elif b == <STRING> : <NEWLINE> <INDENT> print ( a * c ) <NEWLINE> <DEDENT> elif b == <STRING> : <NEWLINE> <INDENT> print ( int ( a / c ) ) <NEWLINE> <DEDENT> a , b , c = input ( ) . split ( ) <NEWLINE> <DEDENT>
input ( ) <NEWLINE> n = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( min ( n ) , max ( n ) , sum ( n ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> ns = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> print ( min ( ns ) , max ( ns ) , sum ( ns ) <NEWLINE>
input ( ) <NEWLINE> x = [ map ( int , input ( ) . split ( <STRING> ) ) ] <NEWLINE> print ( min ( x ) , max ( x ) , sum ( x ) ) <NEWLINE>
import math <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( min ( a ) , max ( a ) , sum ( a ) ) <NEWLINE>
input ( ) <NEWLINE> <NL> a = list ( map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> sum = 0 <NEWLINE> <NL> for x in a : <NEWLINE> <INDENT> sum += x <NEWLINE> <NL> <DEDENT> print ( min ( a ) , max ( a ) , sum ) <NEWLINE>
input ( ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) <NEWLINE> print ( min ( l ) , max ( l ) , sum ( l ) ) <NEWLINE>
import sys <NEWLINE> input ( ) <NEWLINE> x = list ( map ( int , sys . stdin . readlines ( ) . split ( ) ) ) <NEWLINE> print ( <STRING> . format ( min ( x ) , max ( x ) , sum ( x ) ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> sum = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> sum += l [ i ] <NEWLINE> <NL> <DEDENT> print ( min ( l ) , max ( l ) , sum ( l ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> max = - 10000000 <NEWLINE> min = 100000000 <NEWLINE> sum = 0 <NEWLINE> a = input ( ) . split ( ) <NEWLINE> for i in range ( 0 , n ) : <NEWLINE> <INDENT> sum += a [ i ] <NEWLINE> if int ( a [ i ] ) >= max : max = a [ i ] <NEWLINE> if int ( a [ i ] ) <= min : min = a [ i ] <NEWLINE> <NL> <DEDENT> print ( min , max , sum ) <NEWLINE>
a = input ( ) <NEWLINE> a = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> print ( str ( min ( a ) ) + <STRING> + max ( a ) + <STRING> + sum ( a ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> lis = list ( map ( int , input ( ) split ( <STRING> ) ) ) <NEWLINE> big_num = 1000000 <NEWLINE> max_num , min_num , sum = - 1 * big_num , big_num , 0 <NEWLINE> for i in lis : <NEWLINE> <INDENT> if i > max_num : <NEWLINE> <INDENT> max_num = i <NEWLINE> <DEDENT> if i < min_num : <NEWLINE> <INDENT> min_num = i <NEWLINE> <DEDENT> sum += i <NEWLINE> <DEDENT> print ( <STRING> % ( min_num , max_num , sum ) ) <NEWLINE>
n = input ( ) <NEWLINE> k = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> print ( <STRING> ) % ( min ( x ) , max ( x ) , sum ( x ) ) <NEWLINE>
n = input ( ) <NEWLINE> a = input ( ) . split ( <STRING> ) <NEWLINE> nums = [ int ( str ) for str in a ] <NEWLINE> sum = 0 <NEWLINE> nums . sort ( ) <NEWLINE> max = num [ n - 1 ] <NEWLINE> min = num [ 0 ] <NEWLINE> for i in nums : <NEWLINE> <INDENT> sum += i <NEWLINE> <DEDENT> print ( <STRING> . format ( min , max , sum ) ) <NEWLINE>
n = input ( ) <NEWLINE> lis = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> mn = lis [ 0 ] <NEWLINE> mx = li [ 0 ] <NEWLINE> for t in lis : <NEWLINE> <INDENT> if mn > t : <NEWLINE> <INDENT> mn = t <NEWLINE> <DEDENT> if mx < t : <NEWLINE> <INDENT> mx = t <NEWLINE> <DEDENT> <DEDENT> print mn , mx , sum ( lis ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( min ( a ) , max ( a ) , sum ( a ) ) <NEWLINE>
LEN = int ( input ( ) ) <NEWLINE> mem = [ ] <NEWLINE> for i in range ( 0 , LEN ) : <NEWLINE> <INDENT> mem . append ( int ( input ( ) ) ) <NEWLINE> LEN -= 1 <NEWLINE> if LEN == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> print ( min ( mem ) , max ( mem ) , sum ( mem ) ) <NEWLINE> <NL>
n = int ( input ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> sum = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> sum += l [ i ] <NEWLINE> <NL> <DEDENT> print ( sum ( l ) ) <NEWLINE>
input ( ) <NEWLINE> data = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> print ( min ( data ) , max ( data ) , sum ( data ) ) <NEWLINE> ~ <NEWLINE>
<INDENT> input ( ) <NEWLINE> <NL> <DEDENT> data = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> print ( min ( data ) , max ( data ) , sum ( data ) ) <NEWLINE>
<COMMENT> <NL> <NL> k = input ( ) <NEWLINE> a = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> <NL> b = sorted ( a ) <NEWLINE> <NL> min = b [ 0 ] <NEWLINE> Max = b [ k - 1 ] <NEWLINE> <NL> sum = 0 <NEWLINE> for i in b : <NEWLINE> <INDENT> sum += i <NEWLINE> <NL> <DEDENT> print ( <STRING> % ( min , Max , sum ) <NEWLINE> <NL>
n = input ( ) <NEWLINE> integer = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> min = integer [ 0 ] <NEWLINE> max = integer [ 0 ] <NEWLINE> sum = 0 <NEWLINE> <NL> for i in range ( len ( integer ) ) : <NEWLINE> <INDENT> if max < i : <NEWLINE> <INDENT> max = i <NEWLINE> <DEDENT> if i < min : <NEWLINE> <INDENT> min = i <NEWLINE> <DEDENT> sum += i <NEWLINE> <NL> <DEDENT> print ( min + <STRING> + max + <STRING> + sum ) <NEWLINE>
n = input ( ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> <NL> <DEDENT> print min ( a ) , max ( a ) , sum ( a ) <NEWLINE>
n = input ( ) . split ( ) <NEWLINE> max = max ( int ( n ) ) <NEWLINE> min = min ( int ( n ) ) <NEWLINE> sum = sum ( int ( n ) ) <NEWLINE> answer = <STRING> <NEWLINE> print ( answer . format ( max , min , sum ) ) <NEWLINE>
<INDENT> n = int ( input ( ) ) <NEWLINE> i = 0 <NEWLINE> <NL> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> Max = l [ 0 ] <NEWLINE> Min = l [ 0 ] <NEWLINE> for i in range ( 0 , n ) : <NEWLINE> <NL> <INDENT> if l [ i ] > Max : l [ i ] , Max = Max , l [ i ] <NEWLINE> if l [ i ] < Min : l [ i ] , Min = Min , l [ i ] <NEWLINE> <NL> sum = 0 <NEWLINE> sum += l [ i ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> <NL>
input ( ) <NEWLINE> date = input ( ) . split ( ) <NEWLINE> <NL> minimum = min ( date ) <NEWLINE> maximum = max ( date ) <NEWLINE> total = sum ( date ) <NEWLINE> <NL> print ( minimum , maximum , total ) <NEWLINE>
def min ( a , i ) : <NEWLINE> <INDENT> for t in range ( 0 , i ) : <NEWLINE> <INDENT> if a [ 0 ] > a [ t ] : <NEWLINE> <INDENT> a [ 0 ] = a [ t ] <NEWLINE> <DEDENT> <DEDENT> return a [ 0 ] <NEWLINE> <NL> <DEDENT> def max ( a , i ) : <NEWLINE> <INDENT> for t in range ( 0 , i ) : <NEWLINE> <INDENT> if a [ 0 ] < a [ t ] : <NEWLINE> <INDENT> a [ 0 ] = a [ t ] <NEWLINE> <DEDENT> <DEDENT> return a [ 0 ] <NEWLINE> <NL> <DEDENT> def sum ( a , i ) : <NEWLINE> <INDENT> for t in range ( 1 , i ) : <NEWLINE> <INDENT> a [ 0 ] += a [ t ] <NEWLINE> <DEDENT> return a [ 0 ] <NEWLINE> <NL> <DEDENT> i = int ( raw_input ( ) ) <NEWLINE> a = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> print <STRING> % ( min ( a , i ) max ( a , i ) sum ( a , i ) ) <NEWLINE>
input ( ) <NEWLINE> a = [ int ( i ) , for i in input ( ) . split ( ) ] <NEWLINE> print ( min ( a ) , max ( a ) , sum ( a ) ) <NEWLINE>
input ( ) <NEWLINE> nums = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> maximium = max ( nums ) <NEWLINE> minimium = min ( nums ) <NEWLINE> sums = 0 <NEWLINE> for r in range ( len ( nums ) ) : <NEWLINE> <INDENT> sums += nums [ r ] <NEWLINE> <NL> <DEDENT> print ( maxinium , minimium , sums ) <NEWLINE>
num = int ( input ( ) ) <NEWLINE> data = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> data . sort ( ) <NEWLINE> <NL> min = data [ 0 ] <NEWLINE> max = data [ - 1 ] <NEWLINE> avg = 0 <NEWLINE> <NL> for tmp in data : <NEWLINE> <INDENT> avg += tmp <NEWLINE> <NL> <DEDENT> print ( min , max , avg ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = [ int ( input ( ) ) for i in range ( n ) ] <NEWLINE> print ( min ( a ) , max ( a ) , sum ( a ) ) <NEWLINE>
a = int ( input ( ) ) <NEWLINE> max = 0 <NEWLINE> min = 10000 <NEWLINE> sum = 0 <NEWLINE> for i in range ( 0 , a ) : <NEWLINE> <INDENT> b = int ( input ( ) ) <NEWLINE> if ( max <= b ) : <NEWLINE> <INDENT> max = b <NEWLINE> <DEDENT> if ( min >= b ) : <NEWLINE> <INDENT> min = b <NEWLINE> <DEDENT> sum += b ; <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> <NL>
n = int ( input ( ) ) <NEWLINE> n_list = [ int ( i ) for i in input ( ) . split ( <STRING> ) ] <NEWLINE> mini = min ( n_list ) <NEWLINE> maxi = max ( n_list ) <NEWLINE> total = sum ( n_list ) <NEWLINE> <NL> print ( <STRING> . format ( mini , maxi , total ) <NEWLINE>
n = input ( ) <NEWLINE> lst = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> print ( min ( lst ) , max ( lst ) , sum ( lst ) ) <NEWLINE>
n = int ( raw_input ( ) ) <NEWLINE> a = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> sm = 0 <NEWLINE> <NL> for i in xrange ( 0 , len ( a ) ) : <NEWLINE> <INDENT> for j in xrange ( i + 1 , len ( a ) ) : <NEWLINE> <INDENT> if a [ i ] > a [ j ] : <NEWLINE> <INDENT> temp = a [ i ] <NEWLINE> a [ i ] = a [ j ] <NEWLINE> a [ j ] = temp <NEWLINE> <DEDENT> <DEDENT> sm = sm + a [ i ] <NEWLINE> <NL> <NL> <DEDENT> print a [ 0 ] , a [ len ( a ) - 1 ] , sm <NEWLINE>
n = int ( input ( ) ) <NEWLINE> nums = input ( ) . split ( ) <NEWLINE> su = 0 <NEWLINE> ma = - 1000000 <NEWLINE> mi = 1000000 <NEWLINE> <NL> for v in range ( n ) : <NEWLINE> <INDENT> num = int ( nums [ v ] ) <NEWLINE> print ( num ) <NEWLINE> if num > ma : <NEWLINE> <INDENT> ma = num <NEWLINE> print ( <STRING> , ma ) <NEWLINE> <DEDENT> if num < mi : <NEWLINE> <INDENT> mi = num <NEWLINE> print ( <STRING> , mi ) <NEWLINE> <DEDENT> su += num <NEWLINE> <NL> <DEDENT> print ( mi , ma , su ) <NEWLINE> <NL> } <NEWLINE>
n = int ( input ( ) <NEWLINE> table = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> data_max = max ( table ) <NEWLINE> data_min = min ( table ) <NEWLINE> data_sum = sum ( table ) <NEWLINE> <NL> print ( data_min , data_max , data_sum ) <NEWLINE> <NL> <NL> <NL>
n = int ( input ( ) ) <NEWLINE> a = [ int ( i ) for i in input ( ) . split ] <NEWLINE> print ( min ( a ) , max ( a ) , sum ( a ) ) <NEWLINE> <NL>
input ( ) <NEWLINE> <NL> input ( ) <NEWLINE> <NL> data = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> print ( min ( data ) , max ( data ) , sum ( data ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> L = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( min ( L ) , max ( L ) , sum ( L ) ) <NEWLINE>
x = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> x . pop ( 0 ) <NEWLINE> <NL> M = max ( x ) <NEWLINE> m = min ( x ) <NEWLINE> s = sum ( x ) <NEWLINE> <NL> print ( <STRING> . format ( m , M , s ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> sum = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> sum += l [ i ] <NEWLINE> <NL> <DEDENT> print ( min ( list ) , max ( list ) , sum ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> ns = int ( input . spit ( ) ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ns [ i ] = int ( ns [ i ] ) <NEWLINE> <DEDENT> asum = sum ( ns ) <NEWLINE> amin = min ( ns ) <NEWLINE> amax = max ( ns ) <NEWLINE> <NL> print ( amin , amax , asum ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> list = sorted ( [ int ( x ) for x in input ( ) . split ( ) ] ) <NEWLINE> print ( a [ 0 ] , a [ - 1 ] , sum ( list ) ) <NEWLINE>
num = int ( input ( ) ) <NEWLINE> lis = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> sum = 0 <NEWLINE> min = list [ 0 ] <NEWLINE> max = list [ 0 ] <NEWLINE> for i in range ( num ) : <NEWLINE> <INDENT> if ( min > list [ i ] ) : min = list [ i ] <NEWLINE> if ( max < list [ i ] ) : max = list [ i ] <NEWLINE> sum = sum + list [ i ] <NEWLINE> <NL> <DEDENT> print ( <STRING> % ( min , max , sum ) ) <NEWLINE>
count = input ( ) <NEWLINE> data = [ int ( i ) for i in input ( ) . sprit ( ) ] <NEWLINE> <INDENT> print ( min ( data ) , max ( data ) , sum ( data ) , ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> print ( sum ( a ) ) <NEWLINE> print ( max ( a ) ) <NEWLINE> print ( min ( a ) ) <NEWLINE>
n = input ( ) <NEWLINE> N = input ( ) . split ( ) <NEWLINE> sum = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> sum += N [ i ] <NEWLINE> <NL> <DEDENT> print <STRING> % ( min ( N ) , max ( N ) , sum ) <NEWLINE>
n = input ( ) <NEWLINE> ns = list ( map ( int , input ( ) . split ( ) ) <NEWLINE> print ( min ( ns ) , max ( ns ) , sum ( ns ) ) <NEWLINE>
x = input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> print ( <STRING> % ( min ( a ) , max ( a ) , sum ( a ) ) ) <NEWLINE>
<COMMENT> <NL> <NL> import sys <NEWLINE> <NL> <NL> def string_to_list_spliter ( ) : <NEWLINE> <INDENT> n = sys . stdin . readline ( ) <NEWLINE> lst = [ int ( i ) for i in sys . stdin . readline ( ) . split ( ) ] <NEWLINE> return lst <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> lst = string_to_list_spliter ( ) <NEWLINE> print ( min ( lst ) , max ( lst ) , sum ( ) ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> l = [ map ( int , l . split ( ) ) for line in sys . stdin ] <NEWLINE> n = l [ 0 ] <NEWLINE> l = l [ 1 ] <NEWLINE> <NL> print <STRING> % ( min ( l ) , max ( l ) , sum ( l ) ) <NEWLINE>
n = input ( ) <NEWLINE> n = int ( n ) <NEWLINE> seq = input ( ) . split ( ) <NEWLINE> sumNum = 0 <NEWLINE> minNum = 1000000 <NEWLINE> maxNum = 0 <NEWLINE> for numT in sew : <NEWLINE> <INDENT> num = int ( numT ) <NEWLINE> if ( num > maxNum ) : <NEWLINE> <INDENT> maxNum = num <NEWLINE> <DEDENT> elif ( num < minNum ) : <NEWLINE> <INDENT> minNum = num <NEWLINE> <DEDENT> sumNum += num <NEWLINE> <DEDENT> print ( minNum , maxNum , sumNum ) <NEWLINE>
<INDENT> n = int ( raw_input ( ) ) <NEWLINE> <NL> ls = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> mi = min ( ls ) <NEWLINE> ma = max ( ls ) <NEWLINE> su = sum ( ls ) <NEWLINE> print <STRING> % ( mi , ma , su ) <NEWLINE> <DEDENT>
n = input ( ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> list = input ( ) <NEWLINE> <DEDENT> print <STRING> % ( min ( list ) , max ( list ) , sum ( list ) ) <NEWLINE>
<COMMENT> <NL> n = input ( ) <NEWLINE> n = int ( n ) <NEWLINE> j = 0 <NEWLINE> f = 0 <NEWLINE> li = [ ] <NEWLINE> while n > 0 : <NEWLINE> <INDENT> n -= 1 <NEWLINE> f = input ( ) <NEWLINE> f = int ( f ) <NEWLINE> li . append ( f ) <NEWLINE> <DEDENT> mn = min ( li ) <NEWLINE> mx = max ( li ) <NEWLINE> sm = sum ( li ) <NEWLINE> print ( mn , mx , sm ) <NEWLINE>
FirstLine = input ( ) <NEWLINE> myList = list ( [ int ( i ) for i in input ( ) . split ( ) ] ) <NEWLINE> print ( min ( A ) , max ( A ) , sum ( A ) ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> lst = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> print ( min ( numlst ) , max ( numlst ) , sum ( numlst ) ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <NL> <DEDENT>
n = int ( raw_input ( ) ) <NEWLINE> a = raw_input ( ) . split ( ) <NEWLINE> max = a [ 0 ] <NEWLINE> min = a [ 0 ] <NEWLINE> sum = 0 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> if max < a [ i ] : <NEWLINE> <INDENT> max = a [ i ] <NEWLINE> <DEDENT> if min > a [ i ] : <NEWLINE> <INDENT> min = a [ i ] <NEWLINE> <DEDENT> sum += a [ i ] <NEWLINE> <NL> <DEDENT> print <STRING> % ( max , min , sum ) <NEWLINE>
input ( ) <NEWLINE> nums = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> print ( min ( mums ) , max ( nums ) , sum ( nums ) ) <NEWLINE>
import math <NEWLINE> def solve ( input_text ) : <NEWLINE> <INDENT> for line in input_text : <NEWLINE> <INDENT> op = line [ 1 ] <NEWLINE> a = int ( line [ 0 ] ) <NEWLINE> b = int ( line [ 2 ] ) <NEWLINE> ans = 0 <NEWLINE> <NL> if op == <STRING> : <NEWLINE> <INDENT> ans = a + b <NEWLINE> <DEDENT> if op == <STRING> : <NEWLINE> <INDENT> ans = a - b <NEWLINE> <DEDENT> if op == <STRING> : <NEWLINE> <INDENT> ans = a * b <NEWLINE> <DEDENT> if op == <STRING> : <NEWLINE> <INDENT> ans = math . floor ( a / b ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> <DEDENT> def answer ( ) : <NEWLINE> <INDENT> input_text = [ ] <NEWLINE> line = [ ] <NEWLINE> <NL> while True : <NEWLINE> <NL> <INDENT> line = input ( ) <NEWLINE> line = line . split ( <STRING> ) <NEWLINE> if line [ 1 ] == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> input_text . append ( line ) <NEWLINE> <NL> <DEDENT> solve ( input_text ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> answer ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> l = [ ] <NEWLINE> for i in range ( 0 , n ) : <NEWLINE> <INDENT> x = input ( ) <NEWLINE> l . append ( int ( x ) ) <NEWLINE> <NL> <DEDENT> print ( max ( l ) , min ( l ) , sum ( l ) ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> n = int ( input ( ) ) <NEWLINE> sum = 0 <NEWLINE> min = 1000001 <NEWLINE> max = - 1000001 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> num = int ( input ( ) ) <NEWLINE> sum += i <NEWLINE> if max < i : <NEWLINE> <INDENT> max = i <NEWLINE> <DEDENT> if min > i : <NEWLINE> <INDENT> min = i <NEWLINE> <NL> <DEDENT> <DEDENT> print ( str ( min ) + <STRING> + str ( max ) + <STRING> + str ( sum ) ) <NEWLINE>
n = input ( ) <NEWLINE> a = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a . append ( int ( raw_input ( ) ) ) <NEWLINE> <DEDENT> print <STRING> % ( min ( a ) , max ( a ) , sum ( a ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> data = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> print ( <STRING> % ( min ( data ) , max ( data ) , sum ( data ) ) ) ) <NEWLINE>
n = input ( ) <NEWLINE> m = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> a = 0 <NEWLINE> for i in xrange ( n ) : <NEWLINE> <INDENT> a += m [ i ] <NEWLINE> <NL> <DEDENT> print min ( m ) , max ( m ) , a <NEWLINE> <NL> <NL> <NL> Compile Error Logs : <NEWLINE> <NL> You are not authorized to see the message . <NEWLINE> <NL> <NL> Status <NEWLINE>
n = int ( input ( ) ) <NEWLINE> n = input ( ) . split ( ) <NEWLINE> for i in range ( len ( n ) ) : <NEWLINE> <INDENT> n [ i ] = int ( n [ i ] ) <NEWLINE> <DEDENT> s = sum ( n ) <NEWLINE> m = min ( n ) <NEWLINE> ma = max ( n ) <NEWLINE> print ( m ma s ) <NEWLINE>
input ( ) <NEWLINE> s = [ int ( i ) for i in input ( ) . split ] <NEWLINE> print ( min ( s ) , max ( s ) , sum ( s ) ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> my_value = int ( input ( ) ) <NEWLINE> my_value_list_str = input ( ) . split ( ) <NEWLINE> <NL> my_value_list = [ int ( i ) for i in my_value_list_str ] <NEWLINE> my_value_list . sort ( ) <NEWLINE> <NL> print ( <STRING> . format ( my_value_list [ my_value ] , my_value_list [ 0 ] , sum ( my_value_list ) ) ) <NEWLINE>
input ( ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) <NEWLINE> print ( min ( A ) , max ( A ) , sum ( A ) ) <NEWLINE>
sum = 0 <NEWLINE> max = - 10000000 <NEWLINE> min = 10000000 <NEWLINE> <NL> input ( ) <NEWLINE> <NL> data = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> <NL> print ( min ( data ) , max ( data ) , sum ( data ) ) <NEWLINE>
flag = 0 <NEWLINE> while flag == 0 : <NEWLINE> <INDENT> a , b , c = [ i for i in input ( ) . split ( ) ] <NEWLINE> if b == <STRING> : <NEWLINE> <INDENT> flag = 1 <NEWLINE> break <NEWLINE> <DEDENT> elif b == <STRING> : <NEWLINE> <INDENT> n = int ( a ) + int ( c ) <NEWLINE> <DEDENT> elif b == <STRING> : <NEWLINE> <INDENT> n = int ( a ) - int ( c ) <NEWLINE> <DEDENT> elif b == <STRING> : <NEWLINE> <INDENT> n = int ( a ) * int ( c ) <NEWLINE> <DEDENT> elif b == <STRING> : <NEWLINE> <INDENT> n = int ( a ) / int ( c ) <NEWLINE> <DEDENT> print ( int ( n ) ) <NEWLINE> <DEDENT>
x = [ int ( v ) for v in input ( ) . split ( ) ] <NEWLINE> del x [ 0 ] <NEWLINE> print ( min ( x ) , max ( x ) , sum ( x ) ) <NEWLINE>
while True : <NEWLINE> <INDENT> l = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> num = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if len ( num ) != 1 : <NEWLINE> <INDENT> print <STRING> % ( min ( num ) , max ( num ) , sum ( num ) ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> i = 0 <NEWLINE> <NL> x = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> mx = max ( x ) <NEWLINE> mn = min ( x ) <NEWLINE> sum = 0 <NEWLINE> <NL> while i < n : <NEWLINE> <INDENT> sum = sum + x [ i ] <NEWLINE> i += 1 <NEWLINE> <NL> <DEDENT> print ( mn , mx , sum ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> print ( min ( a ) , max ( a ) , sum ( a ) ) <NEWLINE>
p ( long , raw_input ( ) . split ( ) ) <NEWLINE> max = max ( n ) <NEWLINE> min = min ( n ) <NEWLINE> sum = sum ( n ) <NEWLINE> print <STRING> % ( min , max , sum ) <NEWLINE>
n = int ( raw_input ( ) ) <NEWLINE> a = [ 0 ] * n <NEWLINE> sum = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a [ i ] = int ( raw_input ( ) ) <NEWLINE> sum = sum + a [ i ] <NEWLINE> <DEDENT> a . sort ( ) <NEWLINE> <NL> print <STRING> <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = map ( int , input ( ) . split ( ) ) <NEWLINE> min_a = min ( a ) <NEWLINE> max_a = max ( a ) <NEWLINE> sum_a = max ( a ) <NEWLINE> print ( min_a , max_a , sum_a ) <NEWLINE>
n = input ( ) <NEWLINE> a = map ( int , input ( ) . split ( ) ) <NEWLINE> min = a [ 0 ] <NEWLINE> max = a [ 0 ] <NEWLINE> sum = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if min > a [ i ] : <NEWLINE> <INDENT> min = a [ i ] <NEWLINE> <DEDENT> if max < a [ i ] : <NEWLINE> <INDENT> max = a [ i ] <NEWLINE> <DEDENT> sum += a [ i ] <NEWLINE> <DEDENT> print min , max , sum <NEWLINE>
n = input ( ) <NEWLINE> l = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> print ( <STRING> . join ( [ str ( min ( l ) ) , str ( max ( l ) ) , str ( sum ( l ) ) ] ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> print ( <STRING> % ( min ( l ) , max ( l ) , sum ( l ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> ns = input ( ) . split ( ) <NEWLINE> for i in range ( len ( ns ) ) : <NEWLINE> <INDENT> ns [ i ] = int ( ns [ i ] ) <NEWLINE> <DEDENT> a = sum ( ns ) <NEWLINE> i = min ( ns ) <NEWLINE> u = max ( ns ) <NEWLINE> print ( amin , amax , asum ) <NEWLINE>
n = int raw_input ( ) <NEWLINE> a = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> print min ( a ) , max ( a ) , sum ( a ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> ns = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( min ( ns ) , max ( ns ) , sum ( ns ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = input ( ) . split ( ) <NEWLINE> for i in range ( n ) <NEWLINE> <INDENT> a [ i ] = int ( a [ i ] ) <NEWLINE> <NL> <DEDENT> print ( <STRING> . format ( min ( a ) , max ( a ) , sum ( a ) ) ) <NEWLINE>
input ( ) <NEWLINE> li = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( min ( li ) , max ( li ) , sum ( li ) ) <NEWLINE>
input ( ) <NEWLINE> array = list ( map ( int , a [ 1 ] . split ( ) ) ) <NEWLINE> print ( min ( array ) , max ( array ) , sum ( array ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a . sort ( ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( len ( a ) ) : <NEWLINE> <INDENT> ans += a [ i ] <NEWLINE> <DEDENT> print ( <STRING> % a [ 0 ] , a [ len ( a ) - 1 ] , ans ) <NEWLINE>
n = input ( ) <NEWLINE> a = input ( ) . split ( ) <NEWLINE> s = 0 <NEWLINE> m = a [ 0 ] <NEWLINE> M = a [ 0 ] <NEWLINE> for i in range ( 0 , n ) : <NEWLINE> <INDENT> s = s + a [ i ] <NEWLINE> if m > a [ i ] : <NEWLINE> <INDENT> m = a [ i ] <NEWLINE> <DEDENT> if M < a [ i ] : <NEWLINE> <INDENT> M = a [ i ] <NEWLINE> <DEDENT> <DEDENT> print m , M , s <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = [ int ( input ( ) ) for i in range ( n ) ] <NEWLINE> print ( <STRING> . format ( min ( a ) , max ( a ) , sum ( a ) ) ) <NEWLINE> <NL>
n = input ( ) <NEWLINE> sum = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> a . sort ( ) <NEWLINE> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> sum += a [ i ] <NEWLINE> <DEDENT> print <STRING> % ( a [ 0 ] , a [ n - 1 ] , sum ) <NEWLINE>
input ( ) <NEWLINE> li = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i in li : <NEWLINE> <INDENT> sum += i <NEWLINE> <DEDENT> print ( min ( li ) , max ( li ) , sum ) <NEWLINE>
input ( ) <NEWLINE> i = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( <STRING> ) <NEWLINE>
n = input ( ) <NEWLINE> l = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> max = l [ 0 ] <NEWLINE> min = l [ 0 ] <NEWLINE> s = 0 <NEWLINE> for i in range ( n + 1 ) : <NEWLINE> <INDENT> if max < l [ i ] : <NEWLINE> <INDENT> max = l [ i ] <NEWLINE> <DEDENT> if min > l [ i ] : <NEWLINE> <INDENT> min = l [ i ] <NEWLINE> <DEDENT> s += s + l [ i ] <NEWLINE> <DEDENT> print min , max , s <NEWLINE>
input ( ) <NEWLINE> <NL> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> s = 0 <NEWLINE> <NL> for i in len ( a ) : <NEWLINE> <INDENT> s = s + i <NEWLINE> <NL> <DEDENT> print ( min ( a ) , max ( a ) , s ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list [ map ( int . input ( ) . split ( ) ) ] <NEWLINE> <NL> <NL> print ( min ( a ) , max ( a ) , sum ( a ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( min ( a ) , max ( a ) , sum ( a ) ) <NEWLINE>
num = int ( input ( ) ) <NEWLINE> array = [ int ( input ( ) ) for i in range ( num ) ] <NEWLINE> <NL> print ( min ( array ) , max ( array ) , sum ( array ) ) <NEWLINE>
import numpy as np <NEWLINE> a = input ( ) <NEWLINE> input = np . array ( map ( int , raw_input ( ) . split ( ) ) ) <NEWLINE> print np . delete ( input , 0 ) . min ( axis = 0 ) , input . max ( axis = 0 ) , input . sum ( axis = 0 ) <NEWLINE>
n = input ( ) <NEWLINE> s = 0 <NEWLINE> a = input ( ) <NEWLINE> b = a . split ( <STRING> ) <NEWLINE> c = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> c . append ( int ( b [ i ] ) ) <NEWLINE> <NL> <DEDENT> for u in c : <NEWLINE> <INDENT> s = s + u <NEWLINE> <NL> <DEDENT> print ( min ( c ) , max ( c ) , s ) <NEWLINE>
input ( ) <NEWLINE> xs = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( <STRING> . join ( map ( str , [ f ( list ( xs ) ) for f in [ min , max , sum ] ] ) ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> r = input ( ) . split ( ) <NEWLINE> for i in range ( len ( r ) ) : <NEWLINE> <INDENT> r [ i ] = int ( r [ i ] ) <NEWLINE> <DEDENT> s = sum ( r ) <NEWLINE> m = min ( r ) <NEWLINE> ma = max ( r ) <NEWLINE> print ( m ma s ) <NEWLINE>
n = input ( ) <NEWLINE> a = map ( int raw_input ( ) . split ( ) ) <NEWLINE> print ( <STRING> ) % ( min ( a ) , max ( a ) , sum ( a ) ) <NEWLINE>
n = int ( input ( ) . rstrip ( ) ) <NEWLINE> min = 1000000 <NEWLINE> max = - 1000000 <NEWLINE> sum = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> x = int ( input ( ) . rstrip ( ) ) <NEWLINE> if x < min : <NEWLINE> <INDENT> min = x <NEWLINE> <DEDENT> if x > max : <NEWLINE> <INDENT> max = x <NEWLINE> <DEDENT> sum += x <NEWLINE> <DEDENT> print ( <STRING> , % ( min , max , sum ) ) <NEWLINE>
Num = int ( input ( ) ) <NEWLINE> Indata = [ 0 ] * num <NEWLINE> Indata = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> MinVal = min ( Indata ) <NEWLINE> MaxVal = max ( Indata ) <NEWLINE> SumVal = sum ( Indata ) <NEWLINE> <NL> print ( MinVal , MaxVal , SumVal ) <NEWLINE>
first = input ( ) <NEWLINE> hantei = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> print ( <STRING> . format ( min ( hantei ) , max ( hantei ) , sum ( hantei ) ) <NEWLINE>
<NL> n = int ( input ( ) ) <NEWLINE> dat = list ( map ( int . input ( ) . split ( ) ) ) <NEWLINE> print ( min ( dat ) . max ( dat ) . sum ( dat ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> num = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> print ( <STRING> . format ( mix ( num ) , max ( num ) , sum ( num ) ) <NEWLINE> <NL>
n = raw_input ( ) <NEWLINE> data = raw_input ( ) . split ( <STRING> ) <NEWLINE> <NL> <COMMENT> <NL> <NL> minimum = 1000001 <NEWLINE> maximum = 0 <NEWLINE> goukei = 0 <NEWLINE> <NL> for i in data : <NEWLINE> <INDENT> if i < minimum : <NEWLINE> <INDENT> minimum = i <NEWLINE> <DEDENT> if i > maximum : <NEWLINE> <INDENT> maximum = i <NEWLINE> <DEDENT> goukei += i <NEWLINE> <NL> <DEDENT> print ( <STRING> . format ( minimum , maximum , goukei ) ) <NEWLINE>
date1 , date2 = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = min ( date1 ) <NEWLINE> b = max ( date1 ) <NEWLINE> c = sum ( date1 ) <NEWLINE> print ( a b c ) <NEWLINE> <NL>
input ( ) <NEWLINE> nums = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> print ( min ( nums ) , max ( nums ) , <NEWLINE>
n = input ( ) <NEWLINE> <NL> a = raw_input ( ) . split ( ) <NEWLINE> <NL> min = a [ 0 ] <NEWLINE> max = a [ 0 ] <NEWLINE> sum = a [ 0 ] <NEWLINE> <NL> for num in range ( len ( a - 1 ) ) <NEWLINE> <INDENT> if num > max : <NEWLINE> <INDENT> max = num <NEWLINE> <DEDENT> if num < min : <NEWLINE> <INDENT> min = num <NEWLINE> <DEDENT> sum += num <NEWLINE> <NL> <DEDENT> print ( <STRING> ) % ( min , max , sum ) <NEWLINE>
input ( ) <NEWLINE> <NL> data = [ int ( x ) for x in input ( ) . input ( ) ] <NEWLINE> <NL> print ( min ( data ) , max ( data ) , sum ( data ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> min = 1000000 ; max = - 1000000 ; sum = 0 ; <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> x = int ( input ( ) ) <NEWLINE> sum += x <NEWLINE> if min > x : <NEWLINE> <INDENT> min = x <NEWLINE> <DEDENT> if max < x : <NEWLINE> <INDENT> max = x <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> . format ( min , max , sum ) ) <NEWLINE> <NL> <NL>
n = int ( input ( ) ) <NEWLINE> a = map ( int ( ) , input ( ) . split ( ) ) <NEWLINE> as = a . sort ( ) <NEWLINE> max = as [ - 1 ] <NEWLINE> mum = as [ 0 ] <NEWLINE> sum = sum ( as ) <NEWLINE> print ( <STRING> . format ( mum , max , sum ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> nums = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> <NL> maxnum = - 1000000 <NEWLINE> minnum = 1000000 <NEWLINE> total = 0 <NEWLINE> <NL> for item in nums : <NEWLINE> <INDENT> if maxnum < item : <NEWLINE> <INDENT> maxnum = item <NEWLINE> <DEDENT> elif minnum > item : <NEWLINE> <INDENT> minnum = item <NEWLINE> <DEDENT> else : <NEWLINE> <NL> <NL> <DEDENT> for item in nums : <NEWLINE> <INDENT> total += item <NEWLINE> <NL> <DEDENT> print ( str ( minnum ) + <STRING> + str ( maxnum ) + <STRING> + str ( total ) ) <NEWLINE>
input ( ) <NEWLINE> data = input ( ) . split ( ) <NEWLINE> <NL> minimum = min ( data ) <NEWLINE> maximum = max ( data ) <NEWLINE> total = sum ( data ) <NEWLINE> <NL> print ( minimum , maximum , total ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> first = int ( input ( ) ) <NEWLINE> min = first <NEWLINE> max = first <NEWLINE> sum = first <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> x = int ( input ( ) ) <NEWLINE> if x > max : <NEWLINE> <INDENT> max = x <NEWLINE> <DEDENT> if x < min : <NEWLINE> <INDENT> min = x <NEWLINE> <DEDENT> sum += x <NEWLINE> <NL> <DEDENT> print ( min , max , sum ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> max = - 1000001 ; min = 1000001 ; g = 0 ; i = 0 ; <NEWLINE> num = list ( ) <NEWLINE> while i < n : <NEWLINE> <INDENT> j = int ( input ( ) . split ( ) ) <NEWLINE> if max < j : <NEWLINE> <INDENT> max = j <NEWLINE> <DEDENT> if min > j : <NEWLINE> <INDENT> min = j <NEWLINE> <DEDENT> g += j <NEWLINE> i += 1 <NEWLINE> <DEDENT> print ( min , max , g ) <NEWLINE>
n = input ( ) <NEWLINE> sum = 0 <NEWLINE> <NL> for i in range ( 0 , n - 1 ) : <NEWLINE> <INDENT> x = input ( ) <NEWLINE> m [ i ] = x <NEWLINE> sum = sum + m [ i ] <NEWLINE> <NL> <DEDENT> min = min ( m [ i ] for i in range ( 0 , n - 1 ) ) <NEWLINE> max = max ( m [ i ] for i in range ( 0 , n - 1 ) ) <NEWLINE> <NL> print <STRING> % ( min , max , sum ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> min0 = 100000 <NEWLINE> max0 = - 100000 <NEWLINE> sum0 = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> x = int ( input ( ) ) <NEWLINE> min0 = min ( min0 , x ) <NEWLINE> max0 = max ( max0 , x ) <NEWLINE> sum0 += x <NEWLINE> <NL> <DEDENT> print ( min0 , max0 , sum0 ) <NEWLINE> <NL>
from __future__ import print_function <NEWLINE> while ( 1 ) : <NEWLINE> <INDENT> x = raw_input ( ) <NEWLINE> if ( x == <STRING> ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> x = x . split ( <STRING> ) <NEWLINE> h = int ( x [ 0 ] ) <NEWLINE> w = int ( x [ 1 ] ) <NEWLINE> for i in range ( 0 , h ) : <NEWLINE> <INDENT> for j in range ( 0 , w ) : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> H , W = [ int ( i ) for i in input ( ) . split ( ) <NEWLINE> if H == W == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for h in range ( h ) : <NEWLINE> <INDENT> for w in range ( w ) : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <NL> <DEDENT> print ( ) <NEWLINE> <NL> <DEDENT> print ( ) <NEWLINE> <DEDENT>
<INDENT> ( m , n ) = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if n == 0 and m == 0 : break <NEWLINE> else : print ( ( ( <STRING> * n ) <STRING> ) * m ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> while True : <NEWLINE> <INDENT> data = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> H = data [ 0 ] <NEWLINE> W = data [ 1 ] <NEWLINE> <NL> if H == 0 and W == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( H ) : <NEWLINE> <INDENT> for j in range ( W ) : <NEWLINE> <INDENT> sys . stdout . write ( <STRING> ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> using namespace std ; <NEWLINE> int main ( void ) { <NEWLINE> <INDENT> int H , W ; <NEWLINE> int i , j ; <NEWLINE> while ( 1 ) { <NEWLINE> <INDENT> cin >> H ; <NEWLINE> cin >> W ; <NEWLINE> i = 0 ; <NEWLINE> j = 0 ; <NEWLINE> for ( i = 0 ; i < H ; i + + ) { <NEWLINE> <INDENT> for ( j = 0 ; j < W ; j + + ) { <NEWLINE> <INDENT> cout << <STRING> ; <NEWLINE> } <NEWLINE> <DEDENT> cout << endl ; <NEWLINE> } <NEWLINE> cout << endl ; <NEWLINE> if ( H == 0 & & W == 0 ) <NEWLINE> break ; <NEWLINE> <DEDENT> } <NEWLINE> <DEDENT> return 0 ; <NEWLINE> <DEDENT> } <NEWLINE> <NL>
for i in range ( 10000 ) : <NEWLINE> <INDENT> H , W = input ( ) . split ( ) ) <NEWLINE> if H == <STRING> and W == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> s = <STRING> <NEWLINE> for j in range ( int ( W ) ) : <NEWLINE> <INDENT> s = s + <STRING> <NEWLINE> <DEDENT> for k in range ( int ( H ) ) : <NEWLINE> <INDENT> print ( s ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> if H == 0 and W == 0 : break <NEWLINE> for i in range ( H ) <NEWLINE> <INDENT> print ( ( <STRING> * W + <STRING> ) ) <NEWLINE> <DEDENT> <DEDENT>
while 1 : <NEWLINE> <INDENT> H , W = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if H == W == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> print <STRING> <NEWLINE> for i in range ( H ) : <NEWLINE> <INDENT> print <STRING> * W <NEWLINE> <DEDENT> <DEDENT>
while True : <NEWLINE> <INDENT> a , b = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if a == 0 and b == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for i in range ( a ) : <NEWLINE> <INDENT> print <STRING> * b <NEWLINE> <DEDENT> <DEDENT>
data = [ ] <NEWLINE> while 1 : <NEWLINE> <INDENT> H , W = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if H == 0 and W == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> data . append ( [ H , W ] ) <NEWLINE> <NL> <DEDENT> for h , w in data : <NEWLINE> <INDENT> for i in xrange ( h ) : <NEWLINE> <INDENT> for j in xrange ( w ) : <NEWLINE> <INDENT> if j == w - 1 : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> , <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> if H == W == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for i in range ( H ) : <NEWLINE> <INDENT> print ( <COMMENT> <NEWLINE> <NL> <DEDENT> print ( ) <NEWLINE> <DEDENT>
while 1 : <NEWLINE> <INDENT> H , W = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if H == 0 and W == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for i in range ( H ) : <NEWLINE> <INDENT> print <STRING> * W <NEWLINE> <DEDENT> print <STRING> <NEWLINE> <DEDENT>
i , j = 0 <NEWLINE> while True : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if a == 0 and b == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for j in range ( a + 1 ) : <NEWLINE> <INDENT> for i in range ( b + 1 ) : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> <DEDENT> <DEDENT>
a = [ ] <NEWLINE> while True : <NEWLINE> <INDENT> l = input ( ) . split <NEWLINE> if l == [ 0 , 0 ] : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> a . append ( l ) <NEWLINE> <NL> <NL> <DEDENT> for i in range ( len ( a ) ) : <NEWLINE> <INDENT> H , W = a [ i ] <NEWLINE> print ( <STRING> * W ) <NEWLINE> print ( ( <STRING> + <STRING> * ( W - 2 ) + <STRING> + <STRING> ) * ( H - 2 ) , end = <STRING> ) <COMMENT> <NEWLINE> print ( <STRING> * W ) <NEWLINE> print ( <STRING> ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> ( H , W ) = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> if H == W == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> for hc in range ( H ) : <NEWLINE> <INDENT> for wc in range ( W ) : <NEWLINE> print ( <STRING> , end = <STRING> ) <NEWLINE> <NL> <DEDENT> print ( ) <NEWLINE> <NL> <DEDENT> print ( ) <NEWLINE>
while True : <NEWLINE> <INDENT> H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> s = <STRING> <NEWLINE> for i in range ( H ) : <NEWLINE> <INDENT> if H == 0 and W == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = s * W <NEWLINE> print ( x ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
H , W = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> for i in range ( H ) : <NEWLINE> <INDENT> print <STRING> * W <NEWLINE> <DEDENT>
while 1 : <NEWLINE> <INDENT> w , h = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if w == h == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for i in range ( w ) : <NEWLINE> <INDENT> print <STRING> * h <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> <NL> while True : <NEWLINE> <INDENT> height , width = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if height + width == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> . join ( [ <STRING> * width ] * height ) <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> <NL> import sys <NEWLINE> <NL> while 1 : <NEWLINE> <INDENT> num = raw_input ( ) . split ( <STRING> ) <NEWLINE> <NL> H = int ( num [ 0 ] ) <NEWLINE> W = int ( num [ 1 ] ) <NEWLINE> wide = <STRING> <NEWLINE> for i in range ( W ) : <NEWLINE> <INDENT> wide += <STRING> <NEWLINE> <NL> <DEDENT> if H == 0 and W == 0 : sys . exit ( ) <NEWLINE> <NL> for i in range ( H ) : <NEWLINE> <INDENT> print wide + <STRING> <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> while ( 1 ) : <NEWLINE> <INDENT> H , W = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if H == 0 and W == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for i in range ( H ) : <NEWLINE> <INDENT> for j in range ( W ) : <NEWLINE> <INDENT> sys . stdout . write ( <STRING> ) <NEWLINE> <DEDENT> print <STRING> <NEWLINE> <DEDENT> print <STRING> <NEWLINE> <DEDENT>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> for i in range ( a ) : <NEWLINE> <INDENT> for j in range ( b ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> return <NEWLINE> <DEDENT> / n <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> while True : <NEWLINE> <INDENT> line = map ( str , raw_input ( ) . split ( ) ) <NEWLINE> H = int ( line [ 0 ] ) <NEWLINE> W = int ( line [ 1 ] ) <NEWLINE> if H + W : <NEWLINE> <INDENT> for i in range ( H ) : <NEWLINE> <INDENT> print <STRING> * W <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT>
while True : <NEWLINE> <INDENT> H , W = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> if H == w == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> for h in range ( H ) : <NEWLINE> <INDENT> for w in range ( W ) : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> <NL> <DEDENT> print ( ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> H , W = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> for i in range ( H ) : <NEWLINE> <INDENT> width = <STRING> <NEWLINE> for j in range ( W ) : <NEWLINE> <INDENT> width += <STRING> <NEWLINE> <DEDENT> print width <NEWLINE> <DEDENT> print <STRING> <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> if H == W == 0 : <NEWLINE> <INDENT> break ; <NEWLINE> <DEDENT> for i in range ( x ) : <NEWLINE> <INDENT> print ( <STRING> * y ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> <NL> <DEDENT>
while 1 : <NEWLINE> <INDENT> H , W = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> a = W <NEWLINE> b = H <NEWLINE> if b == a == 0 : break <NEWLINE> while 1 : <NEWLINE> <INDENT> while W >= 1 : <NEWLINE> <INDENT> W = W - 1 <NEWLINE> print <STRING> , <NEWLINE> <DEDENT> print <STRING> , <NEWLINE> H = H - 1 <NEWLINE> W = a <NEWLINE> if H <= 0 : break <NEWLINE> <DEDENT> print <STRING> , <NEWLINE> <DEDENT>
hile True : <NEWLINE> <INDENT> H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> if H == 0 and W == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> print ( ( <STRING> * W + <STRING> ) * H + <STRING> ) <NEWLINE> <DEDENT>
while 1 : <NEWLINE> <INDENT> if h == 0 and w == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> h , w = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> for i in range ( h ) : <NEWLINE> <INDENT> print ( <STRING> * w ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT>
while True : <NEWLINE> <INDENT> x = input ( ) . split ( ) <NEWLINE> h = int ( x [ 0 ] ) <NEWLINE> w = int ( x [ 0 ] ) <NEWLINE> if a == 0 and b == 0 : break <NEWLINE> for i in range ( h ) : <NEWLINE> <INDENT> print ( <STRING> * w ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> <DEDENT>
while H != 0 and W != 0 : <NEWLINE> <INDENT> H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> for i in range ( H ) : <NEWLINE> <INDENT> for j in range ( W ) : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> if W == 0 and H == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> while 1 : <NEWLINE> <INDENT> H , W = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if H == 0 and W == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for i in range ( H ) : <NEWLINE> <INDENT> for j in range ( W ) : <NEWLINE> <INDENT> sys . stdout . write ( <STRING> ) <NEWLINE> <DEDENT> sys . stdout . write ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> while 1 > 0 : <NEWLINE> <INDENT> height , width = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if height == 0 and width == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for i in range ( height ) : <NEWLINE> <INDENT> for j in range ( width ) : <NEWLINE> <INDENT> sys . stdout . write ( <STRING> ) <NEWLINE> <DEDENT> print <STRING> <NEWLINE> <DEDENT> <DEDENT>
H , W = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> for _ in range ( H ) : <NEWLINE> <INDENT> print <STRING> * W <NEWLINE> <DEDENT>
while true : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if a == 0 and b == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for i in range ( a ) : <NEWLINE> <INDENT> print ( <STRING> * b ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> <DEDENT>
while 1 : <NEWLINE> <INDENT> H , W = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> <NL> if H == 0 and W == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for i in range ( H ) : <NEWLINE> <INDENT> print ( <STRING> * W ) <NEWLINE> <DEDENT> <DEDENT>
while True : <NEWLINE> <INDENT> h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> for i in range ( h ) : <NEWLINE> <INDENT> print ( <STRING> * w ) <NEWLINE> <DEDENT> <DEDENT>
while True : <NEWLINE> <INDENT> x = input ( ) . split ( ) <NEWLINE> H = x [ 0 ] <NEWLINE> W = x [ 1 ] <NEWLINE> if H == 0 and W == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for i in range ( 0 , H ) : <NEWLINE> <INDENT> print <STRING> * W <NEWLINE> <DEDENT> print <STRING> <NEWLINE> <DEDENT>
import sys <NEWLINE> while 1 : <NEWLINE> <INDENT> H , W = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> sys . stdout . write ( <STRING> ) <NEWLINE> if H == 0 and W == 0 : <NEWLINE> <INDENT> break ; <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for x in range ( H ) : <NEWLINE> <INDENT> for y in range ( W ) : <NEWLINE> <INDENT> sys . stdout . write ( <STRING> ) <NEWLINE> <DEDENT> sys . stdout . write ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
a = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> while a != [ 0 , 0 ] : <NEWLINE> <INDENT> for i in xrange ( a [ 0 ] ) : <NEWLINE> <INDENT> print <STRING> * a [ 1 ] <NEWLINE> <DEDENT> a = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <NL> <INDENT> H , W = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> <NL> if H == 0 and W == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> for i in range ( 0 , H ) : <NEWLINE> <INDENT> print <STRING> * W <NEWLINE> <NL> print <STRING> <NEWLINE> <DEDENT> <DEDENT>
while True : <NEWLINE> <INDENT> h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> if h == 0 : break <NEWLINE> for _ in range ( h ) : <NEWLINE> <INDENT> print ( <STRING> . join ( [ <STRING> ] ** w ) ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> <DEDENT>
<NL> h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> <INDENT> for i in range ( h ) : <NEWLINE> <INDENT> print ( <STRING> * w ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> h , w = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if h == 0 and w == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( h ) : <NEWLINE> <INDENT> print <STRING> * w <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
h = - 1 <NEWLINE> w = - 1 <NEWLINE> <NL> while ( h != 0 ) and ( w != 0 ) : <NEWLINE> <INDENT> input = map ( int , raw_input ( ) . split ( <STRING> ) ) <NEWLINE> h = input [ 0 ] <NEWLINE> w = input [ 1 ] <NEWLINE> <NL> i = 0 <NEWLINE> j = 0 <NEWLINE> line = <STRING> <NEWLINE> <NL> while j < w : <NEWLINE> <INDENT> line += <STRING> <NEWLINE> j += 1 <NEWLINE> <NL> <DEDENT> while i < h : <NEWLINE> <INDENT> print line <NEWLINE> i += 1 <NEWLINE> <NL> <COMMENT> <NL> <NEWLINE> <DEDENT> <DEDENT>
while 1 : <NEWLINE> <INDENT> H , W = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if H == 0 and W == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for i in H : <NEWLINE> <INDENT> print <STRING> * W <NEWLINE> <DEDENT> print <STRING> <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> if h + w == 0 : break <NEWLINE> for x in range ( 1 , h + 1 ) : <NEWLINE> print ( <STRING> * w ) <NEWLINE> print ( ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> H , W = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> <INDENT> if H == 0 and W == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> print ( ( <STRING> * W + <STRING> ) * H ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> ls = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if ls [ 0 ] == 0 and ls [ 1 ] == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for h in xrange ( ls [ 0 ] ) : <NEWLINE> <INDENT> for w in xrange ( ls [ 1 ] ) : <NEWLINE> <INDENT> print <STRING> , <NEWLINE> <DEDENT> print <STRING> <NEWLINE> <DEDENT> print <STRING> <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> H , W = [ int ( i ) for i in input ( ) . sprit ( ) ] <NEWLINE> if H == W == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> for h in range ( H ) : <NEWLINE> <INDENT> for w in range ( W ) : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <NL> <DEDENT> print ( ) <NEWLINE> <NL> <DEDENT> print ( ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> h , w = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if h == 0 and w == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( h ) : <NEWLINE> <INDENT> print <STRING> * w , <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
import sys <NEWLINE> while True : <NEWLINE> <INDENT> h , w = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if h == 0 and w == 0 : break <NEWLINE> for i in range ( 0 , h ) : <NEWLINE> <INDENT> for j in range ( 0 , w ) : <NEWLINE> <INDENT> sys . stdout . write ( <STRING> ) <NEWLINE> <DEDENT> print <NEWLINE> <DEDENT> <DEDENT>
while True : <NEWLINE> <INDENT> H , W = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> if H == 0 and W == 0 : break <NEWLINE> for a in range ( H ) : <NEWLINE> <INDENT> for b in range ( W ) : <NEWLINE> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT>
while ( True ) : <NEWLINE> <INDENT> H , W = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> <NL> if H == 0 and W == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> for i in range ( H ) : <NEWLINE> <INDENT> print <STRING> * W <NEWLINE> <DEDENT> <DEDENT>
x = True <NEWLINE> while x == True : <NEWLINE> <NL> <INDENT> m = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> <NL> if m [ 0 ] == 0 and m [ 1 ] == 0 : <NEWLINE> <INDENT> x = False <NEWLINE> <NL> <DEDENT> for i in xrange ( m [ 0 ] ) : <NEWLINE> <INDENT> print <STRING> * m [ 1 ] <NEWLINE> <DEDENT> print <STRING> <NEWLINE> <DEDENT>
while 1 : <NEWLINE> <INDENT> h , w = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if ( h , w ) == ( 0 , 0 ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> print ( <STRING> * w + <STRING> ) * h + <STRING> <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> m = input ( ) . split ( ) <NEWLINE> h = int ( m [ 0 ] ) <NEWLINE> w = int ( m [ 1 ] ) <NEWLINE> if a == b == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for i in range ( h ) : <NEWLINE> <INDENT> for j in range ( w ) : <NEWLINE> <INDENT> print ( <STRING> * w ) <NEWLINE> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> <NL> <NL> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <NL> import sys <NEWLINE> <NL> if __name__ == <STRING> : <NEWLINE> <INDENT> while 1 : <NEWLINE> <INDENT> line = raw_input ( ) <NEWLINE> if line == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> a , b = line . split ( ) <NEWLINE> for i in range ( a ) : <NEWLINE> <INDENT> print <STRING> * b <NEWLINE> <DEDENT> print <NEWLINE> <NL> <DEDENT> <DEDENT>
num = input ( ) <NEWLINE> tate = int ( num ) <NEWLINE> side = int ( num ) <NEWLINE> for i in tate : <NEWLINE> <INDENT> for j in side : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> j += 1 <NEWLINE> <DEDENT> i += 1 <NEWLINE>
while True : <NEWLINE> <INDENT> H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if H == 0 | W == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> countW , countH = 0 , 0 <NEWLINE> <NL> while True : <NEWLINE> <INDENT> if countH == H : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> while True : <NEWLINE> <INDENT> if countW == W : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> countW = 0 <NEWLINE> break <NEWLINE> <DEDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> countW += 1 <NEWLINE> <DEDENT> countH += 1 <NEWLINE> <NL> print ( ) <NEWLINE> <DEDENT> <DEDENT>
while True : <NEWLINE> <INDENT> H = int ( input ( ) ) <NEWLINE> W = int ( input ( ) ) <NEWLINE> if H == 0 and W == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for i in range ( H ) : <NEWLINE> <INDENT> print ( <STRING> * W ) <NEWLINE> <DEDENT> <DEDENT>
while 1 : <NEWLINE> <INDENT> H , W = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if H == 0 and W == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a = <STRING> <NEWLINE> <NL> for i in range ( W ) : <NEWLINE> <INDENT> a += <STRING> <NEWLINE> <DEDENT> for i in range ( H ) : <NEWLINE> <INDENT> print a + <STRING> <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
while 1 : <NEWLINE> <INDENT> H , W = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if H == 0 and W == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for i in range ( H ) : <NEWLINE> <INDENT> print <STRING> * W <NEWLINE> <DEDENT> <DEDENT>
while 1 : <NEWLINE> <INDENT> H , W = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> for i in range ( H ) : <NEWLINE> <INDENT> print <STRING> * W <NEWLINE> <DEDENT> print <STRING> <NEWLINE> if H == W == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT>
While True : <NEWLINE> <INDENT> h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> if h == 0 and w == 0 : <NEWLINE> <INDENT> quit ( ) <NEWLINE> <DEDENT> for i in range ( h ) : <NEWLINE> <INDENT> print ( <STRING> * w ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> <DEDENT>
if __name__ == <STRING> : <NEWLINE> <INDENT> ct = 0 <NEWLINE> while True : <NEWLINE> <INDENT> nums = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> H = nums [ 0 ] <NEWLINE> W = nums [ 1 ] <NEWLINE> if H == 0 : <NEWLINE> <INDENT> if W == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> if ct != 0 : <NEWLINE> <INDENT> print <NEWLINE> <NL> <DEDENT> s = <STRING> <NEWLINE> j = 0 <NEWLINE> while j < W : <NEWLINE> <INDENT> s += <STRING> <NEWLINE> j += 1 <NEWLINE> <NL> <DEDENT> i = 0 <NEWLINE> while i < H : <NEWLINE> <INDENT> print s <NEWLINE> i += 1 <NEWLINE> <DEDENT> ct += 1 <NEWLINE> <DEDENT> <DEDENT>
while True : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if a == 0 and b == 0 : <NEWLINE> <INDENT> breal <NEWLINE> <DEDENT> for i in range ( a ) : <NEWLINE> <INDENT> print ( <STRING> * b ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
while 1 : <NEWLINE> H , W = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if H == 0 and W == 0 : <NEWLINE> break <NEWLINE> print ( ( <STRING> * W + <STRING> ) * H ) <NEWLINE>
while True : <NEWLINE> <INDENT> H , W = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> if H == W == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> for h in range ( h ) : <NEWLINE> <INDENT> for w in range ( w ) : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <NL> <DEDENT> print ( ) <NEWLINE> <NL> <DEDENT> print ( ) <NEWLINE> <DEDENT>
<NL> while True : <NEWLINE> <INDENT> entry = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> H = entry [ 0 ] <NEWLINE> W = entry [ 1 ] <NEWLINE> if H == 0 and W == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for i in range ( H ) : <NEWLINE> <INDENT> for j in range ( W ) : <NEWLINE> <INDENT> print <STRING> , <NEWLINE> <DEDENT> print <STRING> <NEWLINE> <DEDENT> print <STRING> <NEWLINE> <DEDENT>
h = 1 <NEWLINE> w = 1 <NEWLINE> while True : <NEWLINE> <INDENT> nums = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> if h == 0 and w == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> h = nums [ 0 ] <NEWLINE> w = nums [ 1 ] <NEWLINE> <NL> for i in range ( h ) : <NEWLINE> <INDENT> for j in range ( w ) : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> h , w = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if h == 0 and w == 0 : <NEWLINE> break <NEWLINE> <NL> for i in range ( h ) : <NEWLINE> <INDENT> print <STRING> * w <NEWLINE> print <STRING> <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> while True : <NEWLINE> <INDENT> x = sys . stdin . readline ( ) . strip ( ) <NEWLINE> if x == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> a = list ( map ( int , x . strip ( ) ) ) <NEWLINE> for i in range ( a [ 0 ] ) : <NEWLINE> <INDENT> print ( <STRING> * a [ 1 ] ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> if ( H , W ) = = 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for i in range ( H ) : <NEWLINE> <INDENT> print ( <STRING> * W ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> x = [ int ( z ) for z in input ( ) . split ( <STRING> ) ] <NEWLINE> for h in range ( 0 , x [ 0 ] ) : <NEWLINE> <INDENT> for w in range ( 0 , x [ 1 ] ) : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> x , y = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if x + y == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( x ) : <NEWLINE> <INDENT> print y * <STRING> <NEWLINE> <DEDENT> print <STRING> <NEWLINE> <DEDENT> <DEDENT>
x = <STRING> <NEWLINE> while True : <NEWLINE> <INDENT> H , W = map ( int ( input ( ) . split ( ) ) ) <NEWLINE> if ( H * W == 0 ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for i in range ( H ) : <NEWLINE> <INDENT> print ( x * W ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT>
import sys <NEWLINE> <NL> while True : <NEWLINE> <INDENT> nums = [ int ( val ) for val in sys . stdin . readline ( ) . split ( <STRING> ) ] <NEWLINE> for i in range ( nums [ 0 ] ) : <NEWLINE> <INDENT> print ( <STRING> * nums [ 1 ] ) <NEWLINE> <DEDENT> print <NEWLINE> <DEDENT>
import sys <NEWLINE> while 1 : <NEWLINE> <INDENT> H , W = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if H == 0 and W == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for h in range ( 0 , H ) : <NEWLINE> <INDENT> for w in range ( 0 , W ) : <NEWLINE> <INDENT> sys . stdout . write ( <STRING> ) <NEWLINE> <DEDENT> print <STRING> <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
nums = [ ] <NEWLINE> while True : <NEWLINE> <INDENT> in_line = raw_input ( ) . split ( ) <NEWLINE> h = int ( in_line [ 0 ] ) <NEWLINE> w = int ( in_line [ 1 ] ) <NEWLINE> if h == 0 and w == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> nums . append ( [ h , w ] ) <NEWLINE> <DEDENT> <DEDENT> for num in nums : <NEWLINE> <INDENT> for i in range ( 0 , num [ 0 ] ) : <NEWLINE> <INDENT> print <STRING> * num [ 1 ] <NEWLINE> <DEDENT> <DEDENT>
def print_fig ( h , w ) : <NEWLINE> <INDENT> for _ in range ( h ) : <NEWLINE> <INDENT> print ( <STRING> * w ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> while True : <NEWLINE> <INDENT> x = input ( ) . split ( ) <NEWLINE> print_fig ( int ( x [ 0 ] ) , int ( x [ 1 ] ) ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> while True : <NEWLINE> <INDENT> h , w = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if h == w == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for i in xrange ( h ) : <NEWLINE> <INDENT> print ( <STRING> * w ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> h , w = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> <NL> if h == 0 and w == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> for i in range ( 0 , h ) : <NEWLINE> <INDENT> for j in range ( 0 , w ) : <NEWLINE> <INDENT> print <STRING> , <NEWLINE> <DEDENT> <DEDENT> print <STRING> <NEWLINE> <DEDENT>
while 1 : <NEWLINE> <INDENT> h , w = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if h == 0 and w == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for i in range ( h ) : <NEWLINE> <INDENT> print <STRING> * w <NEWLINE> <DEDENT> <DEDENT>
while True : <NEWLINE> <INDENT> H , W = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if ( H + W ) == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> printW = [ <STRING> ] * W <NEWLINE> if W != 0 : <NEWLINE> <INDENT> for h in range ( H ) : <NEWLINE> <INDENT> print <STRING> . join ( printW ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def az12 ( ) : <NEWLINE> <INDENT> while True : <NEWLINE> <INDENT> xs = raw_input ( ) . split ( ) <NEWLINE> H , W = int ( xs [ 0 ] ) , int ( xs [ 1 ] ) <NEWLINE> if H == 0 and W == 0 : break <NEWLINE> for i in range ( 0 , H ) : <NEWLINE> <INDENT> print <STRING> * W <NEWLINE> <DEDENT> <DEDENT> <DEDENT> az12 ( ) <NEWLINE>
while True : <NEWLINE> <INDENT> H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> if H == 0 and W == 0 : <NEWLINE> <INDENT> for i in range ( H ) : <NEWLINE> <INDENT> print ( W * <STRING> ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> h , w = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> for i in range ( h ) : <NEWLINE> <INDENT> for j in range ( w ) : <NEWLINE> <INDENT> sys . stdout . write ( <STRING> ) <NEWLINE> <DEDENT> if i != h - 1 : print <STRING> , <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> x , y = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if x == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in xrange ( x ) : <NEWLINE> <INDENT> for j in xrange ( y ) : <NEWLINE> <INDENT> print <STRING> , <NEWLINE> <DEDENT> print <STRING> <NEWLINE> <DEDENT> <DEDENT> print <STRING> <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> data = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if data [ 0 ] == 0 and data [ 1 ] == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( data [ 0 ] ) : <NEWLINE> <INDENT> for j in range ( data [ 1 ] ) : <NEWLINE> <INDENT> print <STRING> , <NEWLINE> <DEDENT> print <NEWLINE> <DEDENT> print <NEWLINE> <DEDENT> <DEDENT>
H , W = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> <NL> for i in range ( W ) : <NEWLINE> <INDENT> print <STRING> * H <NEWLINE> <DEDENT>
import sys <NEWLINE> while 1 : <NEWLINE> <INDENT> H , W = map ( int , sys . stdin . readline ( ) . split ( ) ) <NEWLINE> print ( ( <STRING> * W + <STRING> ) * H ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> a , b = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if a + b == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in xrange ( a ) : <NEWLINE> <INDENT> print <STRING> * b <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
while True : <NEWLINE> <INDENT> H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> if H == 0 and W == 0 : break <NEWLINE> for y in range ( 0 , H ) : <NEWLINE> <INDENT> for x in range ( 0 , W ) : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <NL> <DEDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
import warnings <NEWLINE> import sys <NEWLINE> <NL> args = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> <NL> h = args [ 0 ] <NEWLINE> w = args [ 1 ] <NEWLINE> <NL> for i in range ( h ) : <NEWLINE> <INDENT> for j in range ( w ) : <NEWLINE> <INDENT> sys . stdout . write ( <STRING> ) <NEWLINE> <DEDENT> print <STRING> <NEWLINE> <DEDENT>
while 1 ; <NEWLINE> <INDENT> H = input ( ) <NEWLINE> W = input ( ) <NEWLINE> <NL> <INDENT> for i in range ( H ) ; { <NEWLINE> <INDENT> for k in range ( W ) ; { <NEWLINE> <INDENT> print <STRING> <NEWLINE> } <NEWLINE> print <STRING> <NEWLINE> if ( H = 0 and W = 0 ) ; <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> } <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> x = [ ] <NEWLINE> for line in sys . stdin : <NEWLINE> <INDENT> h , w = line . split ( ) <NEWLINE> h , w = int ( h ) , int ( w ) <NEWLINE> if h == 0 and w == 0 : break <NEWLINE> x . append ( [ h , w ] ) <NEWLINE> <NL> <DEDENT> for i in range ( len ( x ) ) : <NEWLINE> <INDENT> h , w = x [ i ] <NEWLINE> s = <STRING> * w <NEWLINE> for j in range ( h ) : print s <NEWLINE> if i != len ( x ) - 1 : print <STRING> <NEWLINE> <DEDENT>
while 1 : <NEWLINE> <INDENT> H , W = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> <NL> if H == 0 and W == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for i in range ( H ) : <NEWLINE> <INDENT> print <STRING> * W <NEWLINE> <DEDENT> print <STRING> <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> while True : <NEWLINE> <INDENT> a = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if a == [ 0 , 0 ] : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for i in range ( a [ 0 ] ) : <NEWLINE> <INDENT> print ( <STRING> * a [ 1 ] ) <NEWLINE> print ( <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT>
while True : <NEWLINE> <INDENT> y , x = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> if y and x == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for i in range ( y ) : <NEWLINE> <INDENT> print ( <STRING> * x ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> if H == 0 and W == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> print ( H , W ) <NEWLINE> i = 0 <NEWLINE> j = 0 <NEWLINE> while True : <NEWLINE> <INDENT> while True : <NEWLINE> <INDENT> if j == W and i == H : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> if j == W : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> i += 1 <NEWLINE> <DEDENT> j += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
while True : <NEWLINE> <INDENT> a , b = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> <NL> if a + b == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> else <NEWLINE> <INDENT> for i in range ( a ) : <NEWLINE> <INDENT> print b * <STRING> <NEWLINE> <DEDENT> print <STRING> <NEWLINE> <DEDENT> <DEDENT>
while 1 : <NEWLINE> <INDENT> h , w = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if h == 0 and w == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for i in range ( h ) : <NEWLINE> <INDENT> print <STRING> * w <NEWLINE> <DEDENT> <DEDENT>
while True : <NEWLINE> <INDENT> H , W = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if ( H == 0 and W == 0 ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for n in range ( 0 , H ) : <NEWLINE> <INDENT> s = <STRING> <NEWLINE> for m in range ( 0 , W ) : <NEWLINE> <INDENT> s += <STRING> <NEWLINE> <DEDENT> print ( s ) <NEWLINE> <DEDENT> print ( <STRING> <NEWLINE> <DEDENT> <DEDENT>
H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> while True : <NEWLINE> <INDENT> if ( H + W == 0 ) : break <NEWLINE> <NL> for i in range ( H ) : <NEWLINE> <INDENT> print ( <STRING> * W ) <NEWLINE> <NL> <DEDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT>
while 1 : <NEWLINE> <INDENT> h , w = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if h == w == 0 : break <NEWLINE> for i in range ( h ) : <NEWLINE> <INDENT> print <STRING> * w <NEWLINE> <DEDENT> <DEDENT>
while True : <NEWLINE> <INDENT> H , W = map ( int , raw_input ( ) . split ( ) <NEWLINE> if H == W == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for i in range ( H ) : <NEWLINE> <INDENT> print <STRING> * W <NEWLINE> <DEDENT> print <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> x = input ( ) . split ( ) <NEWLINE> x_int = [ int ( i ) for i in x ] <NEWLINE> <NL> for i in range ( x_int [ 0 ] ) : <NEWLINE> <INDENT> z = <STRING> * x_int [ 1 ] <NEWLINE> print ( z ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> <DEDENT>
while 1 : <NEWLINE> <INDENT> h , w = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if h == 0 and w == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for number in range ( h ) : <NEWLINE> <INDENT> print <STRING> * w <NEWLINE> <DEDENT> print <STRING> <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> H , W = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> if H == W == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> for h in range ( h ) : <NEWLINE> <INDENT> for w in range ( w ) : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <NL> <DEDENT> print ( ) <NEWLINE> <NL> <DEDENT> print ( ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> ( m , n ) = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if n == 0 and m == 0 : break <NEWLINE> for i in xrange ( m ) : <NEWLINE> <INDENT> print <STRING> * n <NEWLINE> <DEDENT> print <STRING> <NEWLINE> <DEDENT>
import sys <NEWLINE> while ( True ) : <NEWLINE> <INDENT> H , W = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if ( H == 0 and W == 0 ) : break <NEWLINE> for i in range ( 0 , H ) : <NEWLINE> <INDENT> for j in range ( 0 , W ) : <NEWLINE> <INDENT> sys . stdout . write ( <STRING> ) <NEWLINE> <DEDENT> else : print <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> <NL> for v in iter ( sys . stdin , <STRING> ) : <NEWLINE> <INDENT> h , w = map ( int , v . split ( ) ) <NEWLINE> <NL> for i in range ( h + 1 ) : <NEWLINE> <INDENT> print ( <STRING> * w ) <NEWLINE> <NL> <DEDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
while 1 : <NEWLINE> <INDENT> h , w = map ( int , raw_input ( ) . split ( <STRING> ) ) <NEWLINE> if not ( h or w ) : break <NEWLINE> for _ in range ( 0 , h ) : <NEWLINE> <INDENT> print <STRING> * w <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> h , w = [ int ( x ) for x in raw_input ( ) . split ( <STRING> ) ] <NEWLINE> <NL> if h > 300 or w > 300 : <NEWLINE> <INDENT> return <NEWLINE> <NL> <DEDENT> for x in range ( h ) : <NEWLINE> <INDENT> x_line = [ ] <NEWLINE> for y in range ( w ) : <NEWLINE> <INDENT> x_line . append ( <STRING> ) <NEWLINE> <DEDENT> print <STRING> . join ( x_line ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> ( H , W ) = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> if H == W == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> for a range ( H ) : <NEWLINE> <INDENT> for b in range ( W ) : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> H , W = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if H == W == 0 : <NEWLINE> <INDENT> print ( ( <STRING> * W + <STRING> ) * H ) <NEWLINE> <DEDENT> <DEDENT>
<STRING> <NEWLINE> <COMMENT> <NL> import sys <NEWLINE> <NL> <COMMENT> <NL> for inputData in sys . stdin : <NEWLINE> <INDENT> inputData = inputData . split ( <STRING> ) <NEWLINE> H , W = int ( inputData [ 0 ] ) , int ( inputData [ 1 ] ) <NEWLINE> if H == 0 and W == 0 <NEWLINE> <INDENT> break ; <NEWLINE> <NL> <DEDENT> for cntH in H <NEWLINE> <INDENT> print ( <STRING> , * H ) <NEWLINE> <DEDENT> <DEDENT>
while True : <NEWLINE> <INDENT> ( H , W ) = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> if H == W == 0 : break <NEWLINE> for h in range ( H ) : print ( <STRING> * w ) <NEWLINE> print ( ) <NEWLINE> <DEDENT>
class PrintARectangle : <NEWLINE> <INDENT> def output ( self , H , W ) : <NEWLINE> <INDENT> s = <STRING> <NEWLINE> for w in range ( W ) : <NEWLINE> <INDENT> s += <STRING> <NEWLINE> <DEDENT> for h in range ( H ) : <NEWLINE> <INDENT> print s <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> pr = PrintARectangle ( ) <NEWLINE> while True : <NEWLINE> <INDENT> h , w = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if h == 0 and w == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> pr . output ( h , w ) <NEWLINE> <DEDENT> <DEDENT>
while True : <NEWLINE> <INDENT> ( H , W ) = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> if H == W == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <NL> <DEDENT> for hc in range ( H ) : <NEWLINE> <INDENT> for wc in range ( W ) : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <NL> <DEDENT> print ( ) <NEWLINE> <NL> print ( ) <NEWLINE> <DEDENT> <DEDENT>
while True : <NEWLINE> <INDENT> h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> x , y = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> <NL> for i in range ( x ) : <NEWLINE> <INDENT> print <STRING> * y <NEWLINE> <DEDENT> print <STRING> <NEWLINE> <NL> if x == 0 and y == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT>
while True : <NEWLINE> <INDENT> h , w = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if ( h == 0 ) and ( w == 0 ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for i in xrange ( h ) : <NEWLINE> <INDENT> line = <STRING> <NEWLINE> for j in xrange ( w ) : <NEWLINE> <INDENT> line += <STRING> <NEWLINE> <DEDENT> print line <NEWLINE> <DEDENT> <DEDENT>
while True : <NEWLINE> <INDENT> H , W = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> if H == w == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> for h in range ( H ) : <NEWLINE> <INDENT> for w in range ( W ) : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <NL> <DEDENT> print ( ) <NEWLINE> <NL> <DEDENT> print ( ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> h , w = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if h + w == 0 : break <NEWLINE> <NL> for y in xrange ( h ) : <NEWLINE> <INDENT> print ( <STRING> * w ) <NEWLINE> <DEDENT> <DEDENT>
from __future__ import print_function <NEWLINE> <NL> x = raw_input ( ) <NEWLINE> H , W = x . split ( ) <NEWLINE> <NL> H = int ( H ) <NEWLINE> W = int ( W ) <NEWLINE> <NL> for i in range ( H ) : <NEWLINE> <INDENT> for j in range ( W ) : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> H , W = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> for h in range ( h ) : <NEWLINE> <INDENT> for w in range ( w ) : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <NL> <DEDENT> print ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ) <NEWLINE>
while True : <NEWLINE> <INDENT> H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> if W == 0 and H == 0 : <NEWLINE> <INDENT> break <NEWLINE> for i in range ( H ) : <NEWLINE> print ( <STRING> * W ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> H , W = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if H , W == 0 , 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for k in range ( H ) : <NEWLINE> <INDENT> print <STRING> * W <NEWLINE> <DEDENT> print <STRING> <NEWLINE> <DEDENT>
H = 1 <NEWLINE> W = 1 <NEWLINE> while True : <NEWLINE> <INDENT> if H + W == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> l = raw_input ( ) <NEWLINE> k = l . split ( ) <NEWLINE> H = int ( k [ 0 ] ) <NEWLINE> W = int ( k [ 1 ] ) <NEWLINE> for i in range ( H ) : <NEWLINE> <INDENT> print <STRING> * W <NEWLINE> <DEDENT> print <STRING> <NEWLINE> <DEDENT> <DEDENT>
h = [ ] <NEWLINE> w = [ ] <NEWLINE> while True : <NEWLINE> <INDENT> a , b = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> h . append ( a ) <NEWLINE> w . append ( b ) <NEWLINE> if a == 0 and b == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> for h , w in zip ( h , w ) : <NEWLINE> <INDENT> if h == 0 and w == 0 : <NEWLINE> <INDENT> break ; <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> r = <STRING> <NEWLINE> for x in xrange ( w - 1 ) : <NEWLINE> <INDENT> r = r + <STRING> <NEWLINE> <DEDENT> for x in xrange ( h ) : <NEWLINE> print r <NEWLINE> <DEDENT> print <STRING> <NEWLINE> <DEDENT>
while 1 : <NEWLINE> <INDENT> h , w = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if h == w == 0 : break <NEWLINE> print <STRING> * w <NEWLINE> for i in range ( h - 2 ) : <NEWLINE> <INDENT> if w >= 2 : <NEWLINE> <INDENT> print <STRING> + <STRING> * ( w - 2 ) + <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> <DEDENT> print <STRING> * w <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> if not h and not w : break <NEWLINE> print ( <STRING> * w + <STRING> + ( <STRING> + <STRING> * w - 2 + <STRING> ) * h - 2 + <STRING> * w + <STRING> ) <NEWLINE> <DEDENT>
a = <STRING> <NEWLINE> b = <STRING> <NEWLINE> <NL> while True : <NEWLINE> <INDENT> h , w = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if h == 0 and w == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if w <= 2 : <NEWLINE> <INDENT> for i in range ( h ) : <NEWLINE> <INDENT> print a * w <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( h ) : <NEWLINE> <INDENT> if i == 0 or i == h - 1 : <NEWLINE> <INDENT> print a * w <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print a + b * ( w - 2 ) + a <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT>
3 4 <NEWLINE> 5 6 <NEWLINE> 3 3 <NEWLINE> 0 0 <NEWLINE>
while 1 : <NEWLINE> <INDENT> H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> if H == 0 and W == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> print ( <STRING> ) * W <NEWLINE> for i in range ( H - 2 ) : <NEWLINE> <INDENT> print ( <STRING> + <STRING> * ( W - 2 ) + <STRING> ) <NEWLINE> <DEDENT> print ( <STRING> ) * W <NEWLINE> print ( <STRING> ) <NEWLINE> <DEDENT>
whlie True : <NEWLINE> <INDENT> HW = input ( ) . split ( ) <NEWLINE> HW = [ int ( x ) for x in HW ] <NEWLINE> if HW [ 0 ] == 0 : break <NEWLINE> print ( <STRING> * HW [ 1 ] ) <NEWLINE> for i in range ( HW [ 0 ] - 2 ) : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> print ( <STRING> * ( HW [ 1 ] - 2 ) , end = <STRING> ) <NEWLINE> <DEDENT> print ( <STRING> * HW [ 1 ] ) <NEWLINE> print ( ) <NEWLINE> <DEDENT>
While True : <NEWLINE> <INDENT> H , W = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if H == W == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> print <STRING> * W <NEWLINE> for i in xrange ( H - 2 ) : <NEWLINE> <INDENT> print <STRING> + <STRING> * ( W - 2 ) + <STRING> <NEWLINE> <DEDENT> print <STRING> * W <NEWLINE> print <NEWLINE> <DEDENT>
H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> while not ( H == 0 and W == 0 ) : <NEWLINE> <INDENT> print ( <STRING> * W ) <NEWLINE> for i in range ( H - 2 ) : <NEWLINE> <INDENT> print ( <STRING> + <STRING> * ( W - 2 ) + <STRING> ) <NEWLINE> <DEDENT> print ( <STRING> * W ) <NEWLINE> print ( ) <NEWLINE> <NL> <DEDENT>
while True : <NEWLINE> <INDENT> h , w = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if ( h == 0 and w == 0 ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for i in range ( 0 , h ) : <NEWLINE> <INDENT> if i == 0 or i == h - 1 : <NEWLINE> <INDENT> print ( <STRING> * w ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> + <STRING> * ( w - 2 ) + <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT>
while true : <NEWLINE> H , W = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> <NL> <INDENT> if W == 0 and H == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> elif : <NEWLINE> print <STRING> * W + <STRING> <NEWLINE> <NL> print ( <STRING> + <STRING> * ( W - 2 ) + <STRING> + <STRING> ) * ( H - 2 ) <NEWLINE> print <STRING> * W + <STRING> <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> while True : <NEWLINE> <INDENT> a = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> print ( <STRING> * a [ 1 ] ) <NEWLINE> for i in range ( a [ 0 ] - 2 ) : <NEWLINE> <INDENT> b = <STRING> * ( a [ 1 ] - 2 ) <NEWLINE> print ( <STRING> + b + <STRING> ) <NEWLINE> <DEDENT> print ( <STRING> * a [ 1 ] ) <NEWLINE> print ( <STRING> ) <NEWLINE> if a == [ 0 , 0 ] : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT>
while True : <NEWLINE> <INDENT> H , W = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> if H == W == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <NL> <DEDENT> for a in <NEWLINE> <DEDENT> for h in range ( H ) : <NEWLINE> <INDENT> for h in range ( W ) : <NEWLINE> <INDENT> if h == 0 or h == H - 1 or w == 0 or w == W - 1 : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ) <NEWLINE> <NL> print ( ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> k = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> H = k [ 0 ] <NEWLINE> W = k [ 1 ] <NEWLINE> if H + W == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> * W <NEWLINE> if H == 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if H == 2 : <NEWLINE> <INDENT> print <STRING> * W <NEWLINE> <DEDENT> if H > 2 : <NEWLINE> <INDENT> for i in range ( H - 2 ) : <NEWLINE> <INDENT> print <STRING> + <STRING> * ( W - 2 ) + <STRING> <NEWLINE> <DEDENT> print <STRING> * W <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
import sys <NEWLINE> <NL> while True : <NEWLINE> <INDENT> h , w = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if h == 0 and w == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> i , j = [ 0 , 0 ] <NEWLINE> for num in range ( h ) : <NEWLINE> <INDENT> j = 0 <NEWLINE> if i == 0 or i == h - 1 : <NEWLINE> <INDENT> print <STRING> * w <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for nnum in range ( w ) : <NEWLINE> <INDENT> if j == 0 : <NEWLINE> <INDENT> sys . stdout . write ( <STRING> ) <NEWLINE> j += 1 <NEWLINE> <DEDENT> elif j == w - 1 : <NEWLINE> <INDENT> sys . stdout . write ( <STRING> ) <NEWLINE> j += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> sys . stdout . write ( <STRING> ) <NEWLINE> j += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> i += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
while True : <NEWLINE> <INDENT> h , w = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if h == w == 0 : break <NEWLINE> for i in xrange ( h ) : <NEWLINE> <INDENT> if i == 0 or i == h - 1 : print <STRING> * w <NEWLINE> else : print <STRING> + <STRING> * ( w - 2 ) + <STRING> <NEWLINE> <DEDENT> <DEDENT>
while 1 : <NEWLINE> <INDENT> w , h = map ( int , raw_input ( ) . split ( ) ) ; a , b = <STRING> ; print a * h + b + ( a + <STRING> * ( h - 2 ) + a + b ) * ( w - 2 ) + a * h + b <NEWLINE> if w == 0 : break <NEWLINE> <DEDENT>
import sys <NEWLINE> while 1 : <NEWLINE> <INDENT> H , W = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if H == 0 and W == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for i in range ( H ) : <NEWLINE> <INDENT> for j in range ( W ) : <NEWLINE> <INDENT> if i == 0 or i == H - 1 or j == 0 or j == W - 1 : <NEWLINE> <INDENT> sys . stdout . write ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> sys . stdout . write ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> sys . stdout . write ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
while 1 : <NEWLINE> <INDENT> H , W = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> <NL> if ( H == 0 and W == 0 ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for i in range ( H ) : <NEWLINE> <INDENT> if ( i == 0 ) : <NEWLINE> <INDENT> print <STRING> * W <NEWLINE> <DEDENT> elif ( i == H - 1 ) : <NEWLINE> <INDENT> print <STRING> * W <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> * <NEWLINE> print <STRING> * ( W - 2 ) <NEWLINE> print <STRING> * <NEWLINE> <NL> <DEDENT> <DEDENT> print <STRING> <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> a , b = 5 , 10 <NEWLINE> if a == 0 and b == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for i in range ( a ) : <NEWLINE> <INDENT> if i == 0 or i == ( a - 1 ) : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> print ( <STRING> * ( b - 2 ) , end = <STRING> ) <NEWLINE> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> * b ) <NEWLINE> <DEDENT> <DEDENT> print ( ) <NEWLINE> <NL> <DEDENT>
while True : <NEWLINE> <INDENT> H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> if W == 0 and H == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for i in range ( H ) : <NEWLINE> <INDENT> if i == 0 or i == H - 1 : <NEWLINE> <INDENT> print ( <STRING> * W ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> + <STRING> * ( W - 2 ) + <STRING> ) <NEWLINE> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
<INDENT> while True : <NEWLINE> <INDENT> H , W = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if H == W == 0 : break <NEWLINE> print <STRING> * W <NEWLINE> for i in range ( H - 2 ) : <NEWLINE> <INDENT> print <STRING> + <STRING> * ( W - 2 ) + <STRING> <NEWLINE> <DEDENT> print <STRING> * W + <STRING> <NEWLINE> <DEDENT> <DEDENT>
while ( True ) : <NEWLINE> <INDENT> h , w = map ( int , input ( ) ) <NEWLINE> if h == 0 and w == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> rect = <STRING> * w + <STRING> <NEWLINE> rect += ( <STRING> + <STRING> * ( w - 2 ) + <STRING> ) * ( h - 2 ) <NEWLINE> rect = <STRING> * w + <STRING> <NEWLINE> print ( rect ) <NEWLINE> <DEDENT>
while 1 : <NEWLINE> <INDENT> n = input ( ) . split ( ) <NEWLINE> w = int ( x [ 0 ] ) <NEWLINE> h = int ( x [ 1 ] ) <NEWLINE> if h == w == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for i in range ( h ) : <NEWLINE> <INDENT> if i == 0 or i == h - 1 : <NEWLINE> <INDENT> print ( <STRING> * w ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> <STRING> * ( w - 2 ) , <STRING> ) <NEWLINE> <DEDENT> <DEDENT> print ( ) <NEWLINE> <DEDENT>
H , W = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> while H | W != 0 : <NEWLINE> <INDENT> for i in range ( H ) : <NEWLINE> <INDENT> if i == 0 or i == H - 1 : <NEWLINE> <INDENT> print <STRING> * W <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> + <STRING> * W - 2 + <STRING> <NEWLINE> <DEDENT> <DEDENT> print <STRING> <NEWLINE> H , W = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> <DEDENT>
for i in range ( 100000 ) : <NEWLINE> <INDENT> H , W = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> if H + W == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> print ( <STRING> * W ) <NEWLINE> for j in range ( h - 2 ) : <NEWLINE> <INDENT> print ( <STRING> + <STRING> * ( W - 2 ) + <STRING> ) <NEWLINE> <DEDENT> print ( <STRING> * W ) <NEWLINE> print ( <STRING> ) <NEWLINE> <NL> <DEDENT>
while ( 1 ) : <NEWLINE> <INDENT> H , W = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if H == 0 and W == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for i in range ( H ) : <NEWLINE> <INDENT> if i == 0 or i == H - 1 : <NEWLINE> <INDENT> print <STRING> * W <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> + <STRING> * ( W - 2 ) <STRING> <COMMENT> <NEWLINE> <DEDENT> <DEDENT> print <STRING> <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> num = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if ( num [ 0 ] == 0 and num [ 1 ] == 0 ) : break <NEWLINE> else : <NEWLINE> <INDENT> flag = False <NEWLINE> for i in range ( num [ 0 ] ) : <NEWLINE> <INDENT> str = <STRING> <NEWLINE> if ( i == 0 or i == num [ 0 ] - 1 ) : flag = True <NEWLINE> else : flag = False <NEWLINE> for j in range ( num [ 1 ] ) : <NEWLINE> <INDENT> if ( j == 0 or j == num [ 1 ] - 1 or flag = True ) : <NEWLINE> <INDENT> str = str + <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> str = str + <STRING> <NEWLINE> <DEDENT> <DEDENT> print ( str ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> <NL> <DEDENT> <DEDENT>
while True : <NEWLINE> <INDENT> H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> if H == 0 and W == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for i in range ( H ) : <NEWLINE> <INDENT> if i != 0 or i != H - 1 : <NEWLINE> <INDENT> print ( <STRING> + <STRING> * ( W - 2 ) + <STRING> ) <NEWLINE> <DEDENT> else print ( <STRING> * W ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> if ( h == 0 ) and ( w == 0 ) : <NEWLINE> <INDENT> break <NEWLINE> else : <NEWLINE> print ( <STRING> * w ) <NEWLINE> for I in range ( h - 2 ) : <NEWLINE> print ( <STRING> + <STRING> * ( w - 2 ) + <STRING> ) <NEWLINE> print ( <STRING> * w ) <NEWLINE> <NL> <DEDENT> <DEDENT>
while True : <NEWLINE> <INDENT> h , w = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if h == 0 and w == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for i in range ( h ) : <NEWLINE> <INDENT> if i == 0 or i == h - 1 : <NEWLINE> <INDENT> print <STRING> * w <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> + <STRING> * ( w - 2 ) + <STRING> <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
import sys <NEWLINE> while 1 > 0 : <NEWLINE> <INDENT> height , width = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if height == 0 and width == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for i in range ( width ) : <NEWLINE> <INDENT> sys . stdout . write ( <STRING> ) <NEWLINE> <DEDENT> print <STRING> <NEWLINE> for i in range ( height - 2 ) : <NEWLINE> <INDENT> sys . stdout . write ( <STRING> ) <NEWLINE> for j in range ( width - 2 ) : <NEWLINE> <INDENT> sys . stdout . write ( <STRING> ) <NEWLINE> <DEDENT> sys . stdout . write ( <STRING> ) <NEWLINE> print <STRING> <NEWLINE> <DEDENT> for i in range ( width ) : <NEWLINE> <INDENT> sys . stdout . write ( <STRING> ) <NEWLINE> <DEDENT> print <STRING> <NEWLINE> <DEDENT> print <NEWLINE>
while 1 : <NEWLINE> <INDENT> H , W = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> <NL> if H == 0 and W == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> * W <NEWLINE> for i in xrange ( H - 2 ) : <NEWLINE> <INDENT> print <STRING> + <STRING> * ( W - 2 ) + <STRING> <NEWLINE> <DEDENT> print <STRING> * W <NEWLINE> <DEDENT> <DEDENT>
while True : <NEWLINE> <INDENT> h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> if h == 0 and w == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( h ) : <NEWLINE> <INDENT> if i == 0 or i == ( h - 1 ) <NEWLINE> <INDENT> print ( <STRING> * w ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> + <STRING> * ( w - 2 ) + <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ) <NEWLINE> <DEDENT>
for i in range ( 10000 ) : <NEWLINE> <INDENT> H , W = input ( ) . split ( ) <NEWLINE> if H == 0 and W == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> s = <STRING> <NEWLINE> t = <STRING> <NEWLINE> for j in range ( int ( W ) ) : <NEWLINE> <INDENT> s += <STRING> <NEWLINE> if j == 0 or j == int ( W ) - 1 : <NEWLINE> <INDENT> t += <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> t += <STRING> <NEWLINE> <DEDENT> <DEDENT> for k in range ( int ( H ) ) : <NEWLINE> <INDENT> if k == 0 or k == int ( H ) - 1 : <NEWLINE> <INDENT> print ( s ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( t ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> if H == 0 and W == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( H ) : <NEWLINE> <INDENT> for j in range ( W ) : <NEWLINE> <INDENT> if : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> <DEDENT> print ( ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> H , W = [ int ( i ) for i in input ( ) . split ] <NEWLINE> if H == W == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> for h in range ( H ) : <NEWLINE> <INDENT> for w in range ( W ) : <NEWLINE> <INDENT> if h == 0 or h == H - 1 or w == 0 or w == W - 1 : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ) <NEWLINE> <NL> <DEDENT> print ( ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> if h == 0 : break <NEWLINE> print ( ( <STRING> * w ) ) <NEWLINE> for _ in range ( h - 2 ) : print ( <STRING> + <STRING> * ( w - 2 ) + <STRING> ) ) <NEWLINE> print ( ( <STRING> * w ) ) <NEWLINE> print ( ) <NEWLINE> <DEDENT>
while 1 : <NEWLINE> <INDENT> H , W = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if H == 0 and W == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> print <STRING> * W <NEWLINE> for i in range ( 1 , H - 1 ) : <NEWLINE> <INDENT> print <STRING> + <STRING> * ( W - 2 ) + <STRING> <NEWLINE> <DEDENT> print <STRING> * W <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> H , W = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> if H == W == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> for i in range ( H ) : <NEWLINE> <INDENT> for i in range ( W ) : <NEWLINE> <INDENT> if h == 0 or h == H - 1 or w == 0 or w == W - 1 : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ) <NEWLINE> <NL> <DEDENT> print ( ) <NEWLINE>
while True : <NEWLINE> <INDENT> ( H , W ) = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> if H == W == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> for hc in range ( H ) : <NEWLINE> <INDENT> for wc in range ( W ) : <NEWLINE> <INDENT> if hc == 0 or hc == H - 1 or wc == 0 or wc == W - 1 : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> print ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> H , W = map ( int , raw_input ( ) . split ( <STRING> ) ) <NEWLINE> if ( H == W == 0 ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> print ( <STRING> * W + <STRING> + ( <STRING> + <STRING> * ( W - 2 ) + <STRING> + <STRING> ) * ( H - 2 ) + <STRING> * W ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> if h == w == 0 : break <NEWLINE> print ( <STRING> * w + <STRING> + <STRING> + <STRING> * ( w - 2 ) + <STRING> ) * ( h - 2 ) + <STRING> * w + <STRING> ) <NEWLINE> <DEDENT>
while 1 : <NEWLINE> <INDENT> H , W = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if h == w == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> * w <NEWLINE> for i in range ( h - 2 ) : <NEWLINE> <INDENT> if w >= 2 : <NEWLINE> <INDENT> print <STRING> + <STRING> * ( w - 2 ) + <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> <DEDENT> print <STRING> * w <NEWLINE> print <STRING> <NEWLINE> <DEDENT> <DEDENT>
while 1 : <NEWLINE> <INDENT> w , h = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if ( w == 0 ) : break <NEWLINE> a , b = <STRING> ; print a * h + b + ( a + <STRING> * ( h - 2 ) + a + b ) * ( w - 2 ) + a * h <NEWLINE> <DEDENT>
for vertical in range ( h + 1 ) : <NEWLINE> <INDENT> for horizontal in range ( vertical ) : <NEWLINE> <INDENT> if horizontal == 0 or horizontal == vertical - 1 or vertical == h : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if H == 0 and W == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> print ( <STRING> * W ) <NEWLINE> <NL> for i in range ( 1 , H - 1 ) : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> for j in range ( 1 , W - 1 ) : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <NL> <DEDENT> print ( <STRING> * W ) <NEWLINE> <NL> print ( <STRING> ) <NEWLINE>
while True : <NEWLINE> <INDENT> H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> s = <STRING> <NEWLINE> a = H <NEWLINE> b = <STRING> <NEWLINE> for i in range ( H ) : <NEWLINE> <INDENT> if 1 < a < H : <NEWLINE> <INDENT> y = s + b * ( W - 2 ) + s <NEWLINE> print ( y ) <NEWLINE> a -= 1 <NEWLINE> <DEDENT> elif a == H or a == 1 : <NEWLINE> <INDENT> x = s * W <NEWLINE> print ( x ) <NEWLINE> a -= 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> H == 0 and W == 0 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
data_h = [ ] <NEWLINE> data_w = [ ] <NEWLINE> while True : <NEWLINE> <INDENT> h , w = ( int ( i ) for i in input ( ) . split ( ) ) <NEWLINE> if h == w == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> data_h . append ( h ) <NEWLINE> data_w . append ( w ) <NEWLINE> <NL> <DEDENT> <DEDENT> for count in range ( len ( data_h ) ) : <NEWLINE> <INDENT> h = data_h [ count ] <NEWLINE> w = data_w [ count ] <NEWLINE> for i in range ( h ) : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> for j in range ( w ) : <NEWLINE> <INDENT> if i == 0 or i == range ( h ) or i == ( range ( h ) - 1 ) : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> ( m , n ) = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if n == 0 and m == 0 : break <NEWLINE> <COMMENT> <NL> for i in xrange ( m ) : <NEWLINE> <INDENT> if i == 0 or i == m - 1 : <NEWLINE> <INDENT> print <STRING> * n <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> + <STRING> * ( n - 2 ) + <STRING> <NEWLINE> <DEDENT> <DEDENT> print <STRING> <NEWLINE> <DEDENT>
while True : <NEWLINE> <NL> <INDENT> H , W = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> <NL> if H == 0 and W == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> print <STRING> * W <NEWLINE> for i in range ( H - 2 ) : <NEWLINE> <INDENT> print <STRING> + ( <STRING> * ( W - 2 ) ) + <STRING> <NEWLINE> <DEDENT> print <STRING> * W <NEWLINE> <NL> print <STRING> <NEWLINE> <DEDENT>
while ( True ) : <NEWLINE> <INDENT> H , W = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> <NL> if H == 0 and W == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> for i in range ( H ) : <NEWLINE> <INDENT> if i == 0 or i == H - 1 : <NEWLINE> <INDENT> print <STRING> * W <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> + <STRING> * ( W - 2 ) + <STRING> <NEWLINE> <DEDENT> print <NEWLINE> <DEDENT> <DEDENT>
while True : <NEWLINE> <INDENT> h , w = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if h == w == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> print ( <STRING> * w ) <NEWLINE> print ( <STRING> + <STRING> * ( w - 2 ) + <STRING> ) * ( h - 2 ) , <NEWLINE> print ( <STRING> * w ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> ( H , W ) = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> if H == W == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> for hc in range ( H ) : <NEWLINE> for wc in range ( W ) : <NEWLINE> <INDENT> if hc == 0 or hc == H - 1 or wc == 0 or wc == W - 1 : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> <DEDENT> print ( ) <NEWLINE> print ( ) <NEWLINE> <DEDENT> <DEDENT>
def draw ( h , w ) : <NEWLINE> <INDENT> print ( <STRING> * w ) <NEWLINE> for i in range ( h - 2 ) : <NEWLINE> <INDENT> print ( <STRING> + ( <STRING> * ( w - 2 ) ) + <STRING> ) <NEWLINE> <DEDENT> print ( <STRING> * w ) <NEWLINE> <NL> <DEDENT> while True : <NEWLINE> <INDENT> h , w = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if h == 0 and w == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> draw ( h , w ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> H , W = [ int ( i ) fir i in input ( ) . split ( ) ] <NEWLINE> if H == W == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> for h in range ( H ) : <NEWLINE> <INDENT> for w in range ( W ) : <NEWLINE> <INDENT> if h == 0 or h == H - 1 or w == 0 or w == W - 1 : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ) <NEWLINE> <NL> <DEDENT> print ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> while True : <NEWLINE> <INDENT> h , w = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if h == w == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> print ( w * <STRING> ) <NEWLINE> for i in xrange ( h - 2 ) : <NEWLINE> <INDENT> print ( <STRING> . format ( <STRING> * ( w - 2 ) ) ) <NEWLINE> <DEDENT> print ( w * <STRING> ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> H , W = [ int ( i ) for in input ( ) . split ( ) ] <NEWLINE> if H == 0 and W == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for line in list ( range ( 1 , H + 1 , 1 ) ) : <NEWLINE> <INDENT> for column in list ( range ( 1 , W + 1 , 1 ) ) : <NEWLINE> <INDENT> if line == 1 or line == H : <NEWLINE> <INDENT> if column == W : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if column == 1 : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> elif column == W : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> line = sys . stdin . readline ( ) <NEWLINE> while line : <NEWLINE> <INDENT> H , W = map ( int , line . split ( ) ) <NEWLINE> if H == 0 and W == 0 : <NEWLINE> <INDENT> break ; <NEWLINE> <DEDENT> print <STRING> * W <NEWLINE> for i in range ( 0 , H - 2 ) : <NEWLINE> <INDENT> print <STRING> + <STRING> * ( W - 2 ) + <STRING> <NEWLINE> <DEDENT> print <STRING> * W <NEWLINE> line = sys . stdin . readline ( ) <NEWLINE> <DEDENT>
while 1 : <NEWLINE> <INDENT> H , W = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if H == 0 and W == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( H ) : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> print ( <STRING> * W ) <NEWLINE> <DEDENT> elif i == H - 1 : <NEWLINE> <INDENT> print ( <STRING> * W ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> + <STRING> * ( W - 2 ) + <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT>
while True : <NEWLINE> <INDENT> h , w = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> <NL> if h == 0 and w == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> hcnt = 1 <NEWLINE> for i in range ( 0 , h ) : <NEWLINE> <INDENT> wid = <STRING> <NEWLINE> if hcnt == 1 or hcnt == h : <NEWLINE> <INDENT> for j in range ( 0 , w ) : <NEWLINE> <INDENT> wid += <STRING> <NEWLINE> <DEDENT> print wid <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> wid += <STRING> <NEWLINE> for j in range ( 1 , w - 1 ) : <NEWLINE> <INDENT> wid += <STRING> <NEWLINE> <DEDENT> wid += <STRING> <NEWLINE> print wid <NEWLINE> <DEDENT> hcnt += 1 <NEWLINE> <DEDENT> <DEDENT>
while 1 : <NEWLINE> <INDENT> h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> if h == w == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for i in range ( h ) : <NEWLINE> <INDENT> if i == 0 or i == h - 1 : <NEWLINE> <INDENT> print <STRING> * w <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> + <STRING> * ( w - 2 ) + <STRING> <NEWLINE> <DEDENT> <DEDENT> print <STRING> <NEWLINE> <DEDENT>
while 1 : <NEWLINE> <INDENT> H , W = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if ( H == 0 and W == 0 ) : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> print ( <STRING> * W ) <NEWLINE> for i in range ( 1 , H - 1 ) : <NEWLINE> <INDENT> print ( <STRING> + <STRING> * ( W - 2 ) + <STRING> ) <NEWLINE> <DEDENT> print ( <STRING> * W ) <NEWLINE> print <STRING> <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> H , W = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> if H == W == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for i in range ( H ) : <NEWLINE> <INDENT> if i == 0 or i == H - 1 : <NEWLINE> <INDENT> print ( <STRING> * W ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> . join ( * [ <STRING> if c == 0 or c == W - 1 else <STRING> for c in range ( W ) ] ) ) <NEWLINE> <DEDENT> <DEDENT> print ( ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> ( H , W ) = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> if H == W == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> for hc in range ( H ) : <NEWLINE> <INDENT> if hc == 0 or hc == H - 1 : <NEWLINE> <INDENT> print ( <STRING> * W ) <NEWLINE> else : <NEWLINE> print ( <STRING> + <STRING> * ( W - 2 ) + <STRING> ) <NEWLINE> <DEDENT> <DEDENT> print ( ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if a == 0 and b == 0 : break <NEWLINE> f = [ [ 0 for i in range ( a ) ] for j in range ( b ) ] <NEWLINE> for i in range ( a ) : <NEWLINE> <INDENT> for j in range ( b ) : <NEWLINE> <INDENT> if i == 0 or i == a - 1 or j == 0 or j == b - 1 : <NEWLINE> <INDENT> f [ i ] [ j ] = 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> for i in range ( a ) : <NEWLINE> <INDENT> for j in range ( b ) : <NEWLINE> <INDENT> if f [ i ] [ j ] == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> print ( ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> if H == 0 and W == 0 : <NEWLINE> break <NEWLINE> print ( <STRING> * W ) <NEWLINE> for i in range ( H - 2 ) : <NEWLINE> print ( <STRING> + <STRING> * ( W - 2 ) + <STRING> ) <NEWLINE> print ( <STRING> * W ) <NEWLINE> print ( ) <NEWLINE> <DEDENT>
while 1 : <NEWLINE> <INDENT> H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> if W == 0 and H == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> print <STRING> * W <NEWLINE> for i in range ( 1 , H - 1 ) : <NEWLINE> <INDENT> print ( <STRING> + ( <STRING> * ( W - 2 ) ) + <STRING> ) <NEWLINE> <DEDENT> print <STRING> * W <NEWLINE> print <STRING> <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> for i in range ( h ) : <NEWLINE> <INDENT> if i == 0 or i == h - 1 : <NEWLINE> <INDENT> print ( <STRING> * w ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> + <STRING> * ( w - 2 ) + <STRING> ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
if __name__ == <STRING> : <NEWLINE> while True : <NEWLINE> <INDENT> H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> if H == W == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for i in range ( 1 , H ) : <NEWLINE> <INDENT> if i == 1 : <NEWLINE> <INDENT> print ( <STRING> * W ) <NEWLINE> <DEDENT> elif i == H : <NEWLINE> <INDENT> print ( <STRING> * W ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> , <STRING> * ( W - 2 ) , <STRING> ) <NEWLINE> <DEDENT> <DEDENT> print ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> import sys <NEWLINE> while True : <NEWLINE> <INDENT> array = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if array [ 0 ] == 0 and array [ 1 ] == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for i in range ( array [ 0 ] ) : <NEWLINE> <INDENT> for j in range ( array [ 1 ] ) : <NEWLINE> <INDENT> if i == 0 or i == array [ 0 ] - 1 : <NEWLINE> <INDENT> sys . stdout . write ( <STRING> ) <NEWLINE> <DEDENT> elif j == 0 or j == array [ 1 ] - 1 : <NEWLINE> <INDENT> sys . stdout . write ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> sys . stdout . write ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print <NEWLINE> print <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
while True : <NEWLINE> <INDENT> H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> if H == 0 and W == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> countH , countW = 0 , 0 <NEWLINE> while True : <NEWLINE> <INDENT> if countH == H : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if countH == 0 or countH == H - 1 : <NEWLINE> <NL> <INDENT> while True : <NEWLINE> <INDENT> if countW == W : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> countW += 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> while True : <NEWLINE> <INDENT> if countW == W - 2 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> countW += 1 <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> <DEDENT> countW = 0 <NEWLINE> countH += 1 <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> <DEDENT> ~ <NEWLINE>
while True : <NEWLINE> <INDENT> H , W = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if H == W == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for i in range ( H ) : <NEWLINE> <INDENT> if i == 0 or i == H - 1 : <NEWLINE> <INDENT> print <STRING> * W <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> + <STRING> * ( W - 2 ) + <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT>
while True : <NEWLINE> <INDENT> h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> if w + h == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> line = <STRING> <NEWLINE> for idx , y in enumerate ( h ) : <NEWLINE> <INDENT> if idx == 0 or idx == h - 1 : <NEWLINE> <INDENT> line = <STRING> * w <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> line = <STRING> + <STRING> * ( w - 2 ) + <STRING> <NEWLINE> <DEDENT> print ( line ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> <NL> <DEDENT>
while True : <NEWLINE> <INDENT> H , W = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if H == W == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> elif H != 0 or W != 0 : <NEWLINE> <INDENT> print ( ( <STRING> * W + <STRING> ) + ( <STRING> + <STRING> * ( W - 2 ) + <STRING> + <STRING> ) * ( H - 2 ) + ( <STRING> * W + <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
while True : <NEWLINE> <INDENT> H , W = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if H == 0 and W == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> print <STRING> * W <NEWLINE> for i in range ( H - 1 ) : <NEWLINE> <INDENT> if W > 2 : <NEWLINE> <INDENT> print <STRING> + <STRING> * ( W - 2 ) + <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> * W <NEWLINE> <DEDENT> <DEDENT> print <STRING> * W <NEWLINE> print <STRING> <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> H , W = [ int ( i ) , for i in input ( ) . split ( ) ] <NEWLINE> if H == W == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> for h in range ( H ) : <NEWLINE> <INDENT> for w in range ( W ) : <NEWLINE> <INDENT> if h == 0 or h == H - 1 or w == 0 or w == W - 1 : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <NL> print ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> [ W , H ] = [ int ( x ) for x in raw_input ( ) . split ( ) ] <NEWLINE> if [ W , H ] == [ 0 , 0 ] : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> print ( <STRING> * W ) <NEWLINE> counter = 0 <NEWLINE> while counter < H - 1 : <NEWLINE> <INDENT> print ( <STRING> + <STRING> * ( W - 2 ) + <STRING> ) <NEWLINE> <DEDENT> print ( <STRING> * W ) <NEWLINE> <DEDENT>
while 1 : <NEWLINE> <INDENT> w , h = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if w == h == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for i in range ( w - 1 ) : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> print <STRING> * h <NEWLINE> <DEDENT> if i == w - 2 : <NEWLINE> <INDENT> print <STRING> * h <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> + <STRING> * ( h - 2 ) + <STRING> <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <NL> def draw_topbottom ( n ) : <NEWLINE> <INDENT> a = <STRING> <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a += <STRING> <NEWLINE> <DEDENT> print a <NEWLINE> <NL> <DEDENT> def draw_middle ( n ) : <NEWLINE> <INDENT> a = <STRING> <NEWLINE> for i in range ( n - 2 ) : <NEWLINE> <INDENT> a += <STRING> <NEWLINE> <DEDENT> a += <STRING> <NEWLINE> print a <NEWLINE> <NL> <DEDENT> while 1 : <NEWLINE> <INDENT> HW = raw_input ( ) . split ( ) <NEWLINE> H = int ( HW [ 0 ] ) <NEWLINE> W = int ( HW [ 1 ] ) <NEWLINE> <NL> if H == 0 and W == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> draw_topbottom ( W ) <NEWLINE> for i in range ( H - 2 ) : <NEWLINE> <INDENT> draw_middle ( W ) <NEWLINE> <DEDENT> draw_topbottom ( W ) <NEWLINE> <DEDENT>
<INDENT> while True : <NEWLINE> <INDENT> data = [ int ( x ) for x in input ( ) . split ( <STRING> ) ] <NEWLINE> H = data [ 0 ] <NEWLINE> W = data [ 1 ] <NEWLINE> <NL> if H == 0 and W == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> for i in range ( H ) : <NEWLINE> <INDENT> if i == 0 or i == H - 1 : <NEWLINE> <INDENT> print ( <STRING> * W ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> + <STRING> * ( W - 2 ) + <STRING> ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT>
<COMMENT> <NL> <NL> while True : <NEWLINE> <INDENT> line = map ( str , raw_input ( ) . split ( ) ) <NEWLINE> H = int ( line [ 0 ] ) <NEWLINE> W = int ( line [ 1 ] ) <NEWLINE> if H + W : <NEWLINE> <INDENT> for i in range ( H ) : <NEWLINE> <INDENT> if i == 0 or i == ( H - 1 ) : <NEWLINE> <INDENT> print <STRING> * W <NEWLINE> <DEDENT> elif : <NEWLINE> <INDENT> print <STRING> + <STRING> * ( W - 2 ) + <STRING> <NEWLINE> <DEDENT> <DEDENT> print <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT>
while True : <NEWLINE> <INDENT> ( H , W ) = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> if H == W == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> for a in range ( H ) : <NEWLINE> <INDENT> for b in range ( w ) : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> h , w = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if h == w == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> ret += <STRING> * w + <STRING> <NEWLINE> ret += ( <STRING> + <STRING> * ( w - 2 ) + <STRING> ) * ( h - 2 ) <NEWLINE> ret += <STRING> * w + <STRING> <NEWLINE> <DEDENT> print ret , <NEWLINE>
while True : <NEWLINE> <INDENT> h , w = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if h + w == 0 : break <NEWLINE> <NL> print <STRING> * w <NEWLINE> for y in xrange ( h - 2 ) <NEWLINE> <INDENT> print <STRING> + <STRING> * ( w - 2 ) + <STRING> <NEWLINE> <NL> <DEDENT> print <STRING> * w <NEWLINE> print <NEWLINE> <DEDENT>
s = input ( ) . split ( ) <NEWLINE> t = [ int ( i ) for i in s ] <NEWLINE> H = t [ 0 ] <NEWLINE> W = t [ 1 ] <NEWLINE> while True : <NEWLINE> <INDENT> if H == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> * W ) <NEWLINE> for i in range ( H - 2 ) : <NEWLINE> <INDENT> print ( <STRING> + <STRING> * ( W - 2 ) + <STRING> ) <NEWLINE> <DEDENT> print ( <STRING> * W ) <NEWLINE> print ( ) <NEWLINE> <DEDENT> <DEDENT>
while True : <NEWLINE> <INDENT> H , W = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if ( H == 0 and W == 0 ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for n in range ( H ) : <NEWLINE> <INDENT> s = <STRING> <NEWLINE> for m in range ( W ) : <NEWLINE> <INDENT> if ( ( n % 2 == 1 ) and ( m % 2 == 0 ) ) or5 6 ( ( n % 2 == 0 ) and ( m % 2 == 1 ) ) : <NEWLINE> <INDENT> s += <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s += <STRING> <NEWLINE> <DEDENT> <DEDENT> print ( s ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> while 1 : <NEWLINE> <INDENT> H , W = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if H == 0 and W == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for h in range ( H ) : <NEWLINE> <INDENT> for w in range ( W ) : <NEWLINE> <INDENT> if ( h + w ) % 2 == 0 : <NEWLINE> <INDENT> sys . stdout . write ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> sys . stdout . write ( <STRING> ) <NEWLINE> print <STRING> <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT>
H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> while true : <NEWLINE> <INDENT> if H == 0 and W == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for h in range ( H ) : <NEWLINE> <INDENT> if h % 2 == 0 : <NEWLINE> <INDENT> print ( <STRING> * ( W // 2 ) + <STRING> * ( W % 2 ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> * ( W // 2 ) + <STRING> * ( W % 2 ) ) <NEWLINE> <DEDENT> <DEDENT> print ( ) <NEWLINE> <NL> H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> <DEDENT>
while 1 : <NEWLINE> <INDENT> H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> if H == 0 and W == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> col1 = <STRING> * ( W + 1 ) // 2 <NEWLINE> col2 = <STRING> * ( W + 1 ) // 2 <NEWLINE> print ( ( col1 [ : W ] + <STRING> + col2 [ : W ] + <STRING> ) * ( H // 2 ) + ( col1 [ : W ] + <STRING> ) * H % 2 ) <NEWLINE> <DEDENT>
count = 0 <NEWLINE> while True : <NEWLINE> <INDENT> h , w = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if h == w == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for j in range ( h ) : <NEWLINE> <INDENT> str1 = <STRING> <NEWLINE> if count == 0 : <NEWLINE> <INDENT> for i in range ( w ) : <NEWLINE> <INDENT> if i % 2 == 1 : <NEWLINE> <INDENT> str1 += <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> str1 += <STRING> <NEWLINE> <DEDENT> <DEDENT> print str1 <NEWLINE> count = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( w ) : <NEWLINE> <INDENT> if i % 2 == 1 : <NEWLINE> <INDENT> str1 += <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> str1 += <STRING> <NEWLINE> <DEDENT> <DEDENT> print str1 <NEWLINE> count = 0 <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
while ( True ) : <NEWLINE> <INDENT> h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> if ( h == 0 and w == 0 ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for i in range ( h ) : <NEWLINE> <INDENT> s = <STRING> <NEWLINE> for j in range ( w ) : <NEWLINE> <INDENT> s += <STRING> if ( ( i + j ) % 2 == 0 ) else s += <STRING> <NEWLINE> <DEDENT> print ( s ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> <NL> <DEDENT>
import sys <NEWLINE> lines = sys . stdin . readlines ( ) <NEWLINE> for line in lines : <NEWLINE> <INDENT> H , W = map ( int , line . split ( ) ) <NEWLINE> if H == W == 0 : break <NEWLINE> for i in range ( H ) : <NEWLINE> <INDENT> unit = <STRING> if i % 2 == 0 else <STRING> <NEWLINE> print ( ( unit * ( W + 1 ) // 2 ) [ 1 : W ] ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> H , W = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if H == W == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for i in range ( H ) : <NEWLINE> <INDENT> if W == 1 and i % 2 == 1 : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> elif W == 1 abd i % 2 == 0 : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> elif i % 2 == 0 : <NEWLINE> <INDENT> print <STRING> * ( W / 2 ) + <STRING> * ( W % 2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> * ( W / 2 ) + <STRING> * ( W % 2 ) <NEWLINE> <DEDENT> <DEDENT> print <NEWLINE> <NL> <DEDENT>
<COMMENT> <NL> <NL> while True : <NEWLINE> <INDENT> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if a == [ 0 , 0 ] : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if a [ 1 ] % 2 == 0 : <NEWLINE> <INDENT> b1 = <STRING> * int ( a [ 1 ] / 2 ) <NEWLINE> b2 = <STRING> * int ( a [ 1 ] / 2 ) <NEWLINE> <DEDENT> if a [ 1 ] % 2 == 1 : <NEWLINE> <INDENT> b1 = <STRING> * int ( ( a [ 1 ] - 1 ) / 2 ) + <STRING> <NEWLINE> b2 = <STRING> * int ( ( a [ 1 ] - 1 ) / 2 ) + <STRING> <NEWLINE> <NL> <DEDENT> if a [ 0 ] % 2 == 0 : <NEWLINE> <INDENT> for i in range ( a [ 0 ] / 2 ) : <NEWLINE> <INDENT> print ( b1 ) <NEWLINE> print ( b2 ) <NEWLINE> <DEDENT> <DEDENT> if a [ 0 ] % 2 == 1 : <NEWLINE> <INDENT> for i in range ( ( a [ 0 ] - 1 ) / 2 ) : <NEWLINE> <INDENT> print ( b1 ) <NEWLINE> print ( b2 ) <NEWLINE> <DEDENT> print ( b1 ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT>
while True : <NEWLINE> <INDENT> h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> if h == 0 and w == 0 : break <NEWLINE> <NL> for i in range ( h ) : <NEWLINE> <INDENT> for j in range ( w ) : <NEWLINE> <INDENT> if ( i + j ) % 2 == 0 : print ( <STRING> , end == <STRING> ) <NEWLINE> else : print ( <STRING> , end == <STRING> ) <NEWLINE> if j == w - 1 : print ( ) <NEWLINE> <DEDENT> <DEDENT> print ( ) <NEWLINE> <NL> <NL> <DEDENT>
import sys <NEWLINE> <NL> <NL> def calc_cell ( x , y ) : <NEWLINE> <INDENT> return <STRING> if ( x + y ) % 2 else <STRING> <NEWLINE> <NL> <NL> <DEDENT> def print_chessboard ( height , width ) : <NEWLINE> <INDENT> for y in range ( height ) : <NEWLINE> <INDENT> l = [ ] <NEWLINE> for x in range ( width ) : <NEWLINE> <INDENT> l . append ( calc_cell ( x , y ) ) <NEWLINE> <DEDENT> print <STRING> . join ( l ) <NEWLINE> <DEDENT> print <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> while True : <NEWLINE> <INDENT> h , w = map ( int , sys . stdin . readline ( ) . split ( ) ) <NEWLINE> print_chessboard ( h , w ) <NEWLINE> <NL> if not h or not w : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
while True : <NEWLINE> <INDENT> ( H , W ) = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> if H == Q == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> for hc in range ( H ) : <NEWLINE> <INDENT> for wc in range ( W ) : <NEWLINE> <INDENT> if ( hc + wc ) % 2 == 0 : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> <DEDENT> print ( ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> if H == W == 0 : <NEWLINE> <INDENT> break ; <NEWLINE> <DEDENT> for i in range ( 0 , H ) : <NEWLINE> <INDENT> if i % 2 == 1 : <NEWLINE> <INDENT> for j in range ( 0 , W ) : <NEWLINE> <INDENT> if j % 2 == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> if j % 2 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> if i % 2 == 0 : <NEWLINE> for j in range ( 0 , W ) : <NEWLINE> if j % 2 == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> if j % 2 == 0 : <NEWLINE> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> a = <STRING> <NEWLINE> b = <STRING> <NEWLINE> c = <STRING> <NEWLINE> d = <STRING> <NEWLINE> <NL> def bw ( n ) : <NEWLINE> <INDENT> if n % 2 == 0 : <NEWLINE> <INDENT> print ( ( n // 2 ) * a ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ( n // 2 ) * a + b ) <NEWLINE> <NL> <DEDENT> <DEDENT> def wb ( n ) : <NEWLINE> <INDENT> if n % 2 == 0 : <NEWLINE> <INDENT> print ( ( n // 2 ) * c ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ( n // 2 ) * c + d ) <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( 1 , H + 1 ) : <NEWLINE> <INDENT> if i % 2 == 0 : <NEWLINE> <INDENT> wb ( W ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> bw ( W ) <NEWLINE> <DEDENT> <DEDENT> print ( ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> flag = 0 <NEWLINE> line = input ( ) . split ( ) <NEWLINE> h = int ( line [ 0 ] ) <NEWLINE> w = int ( line [ 1 ] ) <NEWLINE> <NL> if h == 0 and w == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> for i in range ( h ) : <NEWLINE> <INDENT> if i % 2 == 0 : <NEWLINE> <INDENT> for j in range ( w ) : <NEWLINE> <INDENT> if ( j % 2 == 0 ) : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for j in range ( w ) : <NEWLINE> <INDENT> if ( j % 2 == 0 ) : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ) <NEWLINE> <INDENT> print ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
while True : <NEWLINE> <INDENT> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = a [ 0 ] <NEWLINE> c = a [ 1 ] <NEWLINE> if b == c == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for i in range ( 1 , b + 1 ) : <NEWLINE> <INDENT> if i % 2 != 0 : <NEWLINE> <INDENT> if c % 2 == 0 : <NEWLINE> <INDENT> print ( <STRING> * ( c / 2 ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> * ( c // 2 ) + <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if c % 2 == 0 : <NEWLINE> <INDENT> print ( <STRING> * ( c / 2 ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> * ( c // 2 ) + <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> ( H , W ) = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> if H == W == 0 ; <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> for hc in range ( H ) : <NEWLINE> <INDENT> for wc in range ( W ) : <NEWLINE> <INDENT> if ( hc + wc ) % 2 == 0 : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> <DEDENT> print ( ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> ( H , W ) [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> if H == W == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> for hc in range ( H ) : <NEWLINE> <INDENT> for wc in range ( W ) : <NEWLINE> <INDENT> if ( hc + wc ) % 2 == 0 : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> <DEDENT> print ( ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> <DEDENT>
True : <NEWLINE> <INDENT> H , W = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> if H == W == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> for h in range ( H ) : <NEWLINE> <INDENT> for w in range ( W ) : <NEWLINE> <INDENT> if ( h + w ) % 2 == 0 : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ) <NEWLINE> <DEDENT> <DEDENT>
while True : <NEWLINE> <INDENT> ( H , W ) = [ int ( i ) for i in inpput ( ) . split ( ) ] <NEWLINE> if H == W == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> for hc in range ( H ) : <NEWLINE> <INDENT> for wc in range ( W ) : <NEWLINE> <INDENT> if ( hc + wc ) % 2 == 0 : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> . end = <STRING> ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> <DEDENT> <DEDENT>
while True : <NEWLINE> <NL> <INDENT> H , W = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if ( H == 0 and W == 0 ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for i in range ( H ) : <NEWLINE> <INDENT> if i % 2 == 0 : <NEWLINE> <INDENT> if W % 2 == 0 : <NEWLINE> <INDENT> print <STRING> * ( W / 2 ) <NEWLINE> <DEDENT> elif W % 2 == 1 : <NEWLINE> <INDENT> print <STRING> * ( W / 2 ) + <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> elif i % 2 == 1 : <NEWLINE> <INDENT> if W % 2 == 0 : <NEWLINE> <INDENT> print <STRING> * ( W / 2 ) <NEWLINE> <DEDENT> elif W % 2 == 1 : <NEWLINE> <INDENT> print <STRING> * ( W / 2 ) + <STRING> <NEWLINE> <DEDENT> <DEDENT> print <STRING> <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> write = sys . stdout . write <NEWLINE> while True : <NEWLINE> <INDENT> h , w = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if h == w == 0 : break <NEWLINE> for i in xrange ( h ) : <NEWLINE> <INDENT> l = [ ( <STRING> if i % 2 == j % 2 == 0 else ( <STRING> if ( i % 2 == 1 and j % 2 == 0 ) or ( i % 2 == 0 and j % 2 == 1 ) else <STRING> ) for j in xrange ( w ) ] <NEWLINE> for i in l : <NEWLINE> <INDENT> write ( i ) <NEWLINE> <DEDENT> print <STRING> <NEWLINE> <DEDENT> print <STRING> <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> H , W = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> if H == W == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for h in range ( H ) : <NEWLINE> <INDENT> for w in range ( w ) : <NEWLINE> <INDENT> if ( h + w ) % 2 == 0 : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> elif <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> <DEDENT> print ( ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> <DEDENT>
l = [ ] <NEWLINE> while True : <NEWLINE> <INDENT> h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> if ( h , w ) == ( 0 , 0 ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> l . append ( [ h , w ] ) <NEWLINE> <DEDENT> <DEDENT> for i in l : <NEWLINE> <INDENT> r1 = <STRING> <NEWLINE> r2 = <STRING> <NEWLINE> for jin range ( i [ 1 ] // 2 ) : <NEWLINE> <INDENT> r1 += <STRING> <NEWLINE> r2 += <STRING> <NEWLINE> <DEDENT> if i [ 1 ] % 2 == 1 : <NEWLINE> <INDENT> r1 += <STRING> <NEWLINE> r2 += <STRING> <NEWLINE> <DEDENT> for m in range ( i [ 0 ] // 2 ) : <NEWLINE> <INDENT> print ( r1 ) <NEWLINE> print ( r2 ) <NEWLINE> <DEDENT> if i [ 0 ] % 2 == 1 : <NEWLINE> <INDENT> print ( r1 ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> <DEDENT>
while 1 : <NEWLINE> <INDENT> H , W = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if H == W == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for h in range ( H ) : <NEWLINE> <INDENT> if h % 2 == 0 : <NEWLINE> <INDENT> if W % 2 == 0 : <NEWLINE> <INDENT> print ( <STRING> * ( W // 2 ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> * ( W // 2 ) + <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if W % 2 == 0 : <NEWLINE> <INDENT> print ( <STRING> * ( W // 2 ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> * ( W // 2 ) + <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT>
while ( True ) : <NEWLINE> <INDENT> H , W = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if H == 0 and W == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> l1 = <STRING> <NEWLINE> for i in range ( W ) : <NEWLINE> <INDENT> if i % 2 == 0 : <NEWLINE> <INDENT> l1 += <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> l1 += <STRING> <NEWLINE> <DEDENT> <DEDENT> l1 += <STRING> <NEWLINE> l2 = <STRING> <NEWLINE> for i in range ( W ) : <NEWLINE> <INDENT> if i % 2 == 0 : <NEWLINE> <INDENT> l2 += <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> l2 += <STRING> <NEWLINE> <DEDENT> <DEDENT> l2 += <STRING> <NEWLINE> <NL> l = <STRING> <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if i % 2 == 0 : <NEWLINE> <INDENT> l += l1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> l += l2 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( l ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> point = <STRING> <NEWLINE> sharp = <STRING> <NEWLINE> <NL> while True : <NEWLINE> <INDENT> H , W = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if H == W == 0 : <NEWLINE> <INDENT> print <NEWLINE> break <NEWLINE> <DEDENT> for h in xrange ( H ) : <NEWLINE> <INDENT> for w in xrange ( W ) : <NEWLINE> <INDENT> if h % 2 == 0 : <NEWLINE> <INDENT> if w % 2 == 0 : <NEWLINE> <INDENT> print sharp , <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print point , <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if w % 2 == 0 : <NEWLINE> <INDENT> print point , <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print sharp , <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print <NEWLINE> <DEDENT> print <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> input = input ( ) . split ( ) <NEWLINE> H = int ( input [ 0 ] ) <NEWLINE> W = int ( input [ 1 ] ) <NEWLINE> if H == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for i in range ( 1 , H + 1 ) : <NEWLINE> <INDENT> if i % 2 != 0 : <NEWLINE> <INDENT> if W % 2 == 0 : <NEWLINE> <INDENT> print ( <STRING> * ( W // 2 ) ) <NEWLINE> <DEDENT> if W % 2 != 0 : <NEWLINE> <INDENT> print ( <STRING> * ( W // 2 ) + <STRING> ) <NEWLINE> <DEDENT> <DEDENT> if i % 2 == 0 : <NEWLINE> <INDENT> if W % 2 == 0 : <NEWLINE> <INDENT> print ( <STRING> * ( W // 2 ) ) <NEWLINE> <DEDENT> if W % 2 != 0 : <NEWLINE> <INDENT> print ( <STRING> * ( W // 2 ) + <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> h , w = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if h == 0 and w == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( h ) : <NEWLINE> <INDENT> s = <STRING> <NEWLINE> for j in range ( w ) : <NEWLINE> <INDENT> if ( i + j ) % 2 == 0 : <NEWLINE> <INDENT> s += <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s += <STRING> <NEWLINE> <DEDENT> <DEDENT> print s <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
while 1 : <NEWLINE> <INDENT> H , W = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if ( H , W ) == ( 0 , 0 ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for k in range ( H ) : <NEWLINE> <INDENT> if k % 2 == 0 and W % 2 == 0 : <NEWLINE> <INDENT> print <STRING> * ( W / 2 ) <NEWLINE> <DEDENT> elif k % 2 == 0 and W % 2 == 1 : <NEWLINE> <INDENT> print <STRING> * ( W / 2 ) + <STRING> <NEWLINE> <DEDENT> elif k % 2 == 1 and W % 2 == 0 : <NEWLINE> <INDENT> print <STRING> * ( W / 2 ) <NEWLINE> <DEDENT> elif k % 2 == 1 and W % 2 == 1 : <NEWLINE> <INDENT> print <STRING> * ( W / 2 ) + <STRING> <NEWLINE> <DEDENT> print <STRING> <NEWLINE> <DEDENT> <DEDENT>
def chess ( h , w ) : <NEWLINE> <INDENT> if ( h + w ) % 2 == 0 : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> return <STRING> <NEWLINE> <NL> <DEDENT> while True : <NEWLINE> <INDENT> H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> if H == 0 and W == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for i in range ( H ) : <NEWLINE> <INDENT> for j in range ( W ) : <NEWLINE> <INDENT> print ( chess ( I , j ) , end = <STRING> ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> <NL> <DEDENT>
while True : <NEWLINE> <INDENT> height , width = [ int ( x ) for x in input ( ) . split ( <STRING> ) ] <NEWLINE> if height == width == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> col1 = <STRING> * 150 <NEWLINE> col2 = <STRING> * 150 <NEWLINE> col_set = col , 1 [ : width ] + <STRING> + col1 [ : width ] + <STRING> <NEWLINE> print ( col_set * ( height // 2 ) + ( col1 [ : width ] + <STRING> ) * ( height % 2 ) ) <NEWLINE> <DEDENT>
while 1 : <NEWLINE> <INDENT> H , W = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> <NL> if H == 0 and W == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for i in range ( 0 , H ) : <NEWLINE> <INDENT> if i % 2 == 0 : <NEWLINE> <INDENT> if W % 2 == 0 : <NEWLINE> <INDENT> print <STRING> * ( W / 2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> * ( w / 2 ) + <STRING> <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if W % 2 == 0 : <NEWLINE> <INDENT> print <STRING> * ( W / 2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> * ( w / 2 ) + <STRING> <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print <STRING> <NEWLINE> <DEDENT>
import sys <NEWLINE> while True : <NEWLINE> <INDENT> H , W = map ( int , raw_input ( ) . split ( <STRING> ) ) <NEWLINE> if ( H == W == 0 ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for h in range ( 0 , H ) : <NEWLINE> <INDENT> for w in range ( 0 , W ) : <NEWLINE> <INDENT> if ( ( w + h ) % 2 == 0 ) : <NEWLINE> <INDENT> sys . stdout . write ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> sys . stdout . write ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
while True : <NEWLINE> <INDENT> H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> if H == 0 and W == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for i in range ( int ( H / 2 ) ) : <NEWLINE> <INDENT> if W % 2 == 0 : <NEWLINE> <INDENT> print ( <STRING> * int ( W / 2 ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> * int ( W / 2 ) + <STRING> ) <NEWLINE> <DEDENT> if W % 2 == 0 <NEWLINE> <INDENT> print ( <STRING> * int ( W / 2 ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> * int ( W / 2 ) + <STRING> ) <NEWLINE> <DEDENT> <DEDENT> if H % 2 != 0 <NEWLINE> <INDENT> if W % 2 == 0 : <NEWLINE> <INDENT> print ( <STRING> * int ( W / 2 ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> * int ( W / 2 ) + <STRING> ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if H == W == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for i in range ( H ) : <NEWLINE> <INDENT> print ( ( <STRING> * w ) [ i % 2 : ] [ : w ] ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> <NL> <DEDENT>
while 1 : <NEWLINE> <INDENT> H , W = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if H + W == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for i in range ( H ) : <NEWLINE> <INDENT> if i % 2 == 0 : <NEWLINE> <INDENT> if W % 2 == 0 : <NEWLINE> <INDENT> print <STRING> * ( W / 2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> * ( W / 2 ) + <STRING> <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if W % 2 == 0 : <NEWLINE> <INDENT> print <STRING> * ( W / 2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> * ( W / 2 ) + <STRING> <NEWLINE> print <STRING> <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT>
while True : <NEWLINE> <INDENT> h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> if h == 0 & w == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for i in range ( h ) : <NEWLINE> <INDENT> print ( <STRING> * w [ i % 2 : ] [ : w ] ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> ( H , W ) = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> if H == W == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for i in range ( H ) : <NEWLINE> <INDENT> for j in range ( W ) : <NEWLINE> <INDENT> if ( i + j ) % 2 == 0 : print ( <STRING> , end = <STRING> ) <NEWLINE> else : p0rint ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> a , b = input ( ) . split ( ) <NEWLINE> h = int ( a ) <NEWLINE> w = int ( b ) <NEWLINE> if a == 0 and b == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for i in range ( h ) : <NEWLINE> <INDENT> if i % 2 == 0 : <NEWLINE> <INDENT> print ( <STRING> * ( w / 2 ) ) <NEWLINE> if w == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> elif w == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> * ( ( w + 1 ) / 2 ) - 1 ) ) <NEWLINE> if w == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import sys <NEWLINE> line = sys . stdin . readline ( ) <NEWLINE> while line : <NEWLINE> <INDENT> H , W = map ( int , line . split ( ) ) <NEWLINE> if H == 0 and W == 0 : break ; <NEWLINE> <INDENT> for i in range ( 0 , H ) : <NEWLINE> <INDENT> for j in range ( 0 , W ) : <NEWLINE> <INDENT> if ( i + j ) % 2 == 0 : sys . stdout . write ( <STRING> ) <NEWLINE> else : sys . stdout . write ( <STRING> ) <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print <STRING> <NEWLINE> <DEDENT> line = sys . stdin . readline ( ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> H , W = [ int ( i ) for i in input . split ( ) ] <NEWLINE> if H == W == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <NL> <DEDENT> for h in range ( H ) : <NEWLINE> <INDENT> for w in range ( w ) : <NEWLINE> <INDENT> if ( h + w ) % 2 == 0 : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> end = <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> print ( ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> while True : <NEWLINE> <INDENT> h , w = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> for i in range ( 0 , h ) : <NEWLINE> <INDENT> for j in range ( 0 , w ) : <NEWLINE> <NL> <INDENT> if ( i + j ) % 2 == 0 : sys . stdout . write ( <STRING> ) <NEWLINE> else : sys . stdout . write ( <STRING> ) <NEWLINE> <NL> <DEDENT> print <STRING> <NEWLINE> <DEDENT> print <STRING> <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> W = input ( ) <NEWLINE> H = input ( ) <NEWLINE> if H == 0 and W == 0 : break <NEWLINE> <NL> for i in range ( 0 , H ) : <NEWLINE> <INDENT> for j in range ( 0 , W ) : <NEWLINE> <INDENT> if ( i + j ) % 2 == 0 : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
while 1 : <NEWLINE> <INDENT> H , W = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if ( H , W ) == ( 0 , 0 ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for k in range ( H ) : <NEWLINE> <INDENT> if k % 2 == 0 and W % 2 == 0 : <NEWLINE> <INDENT> print <STRING> * ( W / 2 ) <NEWLINE> <DEDENT> elif k % 2 == 0 and W % 2 == 1 : <NEWLINE> <INDENT> print <STRING> * ( W / 2 ) + <STRING> <NEWLINE> <DEDENT> elif k % 2 == 1 and W % 2 == 0 : <NEWLINE> <INDENT> print <STRING> * ( W / 2 ) <NEWLINE> <DEDENT> elif k % 2 == 1 and W % 2 == 1 : <NEWLINE> <INDENT> print <STRING> * ( W / 2 ) + <STRING> <NEWLINE> <DEDENT> print <STRING> <NEWLINE> <DEDENT> <DEDENT>
while 1 : <NEWLINE> <INDENT> h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> if h == w == 0 : break <NEWLINE> for y in range ( h ) : <NEWLINE> <INDENT> for x in range ( w ) : <NEWLINE> <INDENT> if ( x + y ) % 2 == 0 : print ( <STRING> , end = <STRING> ) <NEWLINE> else print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> h , w = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if ( h == 0 and w == 0 ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> wi = int ( w ) <NEWLINE> for i in range ( 0 , h ) : <NEWLINE> <INDENT> if i % 2 == 0 : <NEWLINE> <INDENT> if w % 2 == 0 : print ( <STRING> * ( wi / 2 ) ) <NEWLINE> else : print ( <STRING> * ( wi / 2 ) + <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if w % 2 == 0 : print ( <STRING> * ( wi / 2 ) ) <NEWLINE> else : print ( <STRING> * ( wi / 2 ) + <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT>
while 1 : <NEWLINE> <INDENT> h , w = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if h == w == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> for i in range ( 0 , h / 2 ) : <NEWLINE> <INDENT> print ( <STRING> * ( w / 2 ) + <STRING> * ( w % 2 ) ) <NEWLINE> print ( <STRING> * ( w / 2 ) + <STRING> * ( w % 2 ) ) <NEWLINE> <NL> <DEDENT> if h % 2 == 1 : <NEWLINE> <INDENT> print ( <STRING> * ( w / 2 ) + <STRING> * ( w % 2 ) ) <NEWLINE> <NL> <DEDENT> print <STRING> <NEWLINE> <DEDENT>
H , W = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> <NL> while True : <NEWLINE> <INDENT> if H == 0 and W == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for i in range ( 0 , H / 2 ) : <NEWLINE> <INDENT> print ( <STRING> * ( W / 2 ) + <STRING> * ( W % 2 ) ) <NEWLINE> print ( <STRING> * ( W / 2 ) + <STRING> * ( W % 2 ) ) <NEWLINE> <DEDENT> if H % 2 == 1 : <NEWLINE> <INDENT> print ( <STRING> * ( W / 2 ) + <STRING> * ( W % 2 ) ) <NEWLINE> <DEDENT> print <STRING> <NEWLINE> <NL> <NL> <DEDENT>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> cnt = 1 <NEWLINE> while a != 0 : <NEWLINE> <INDENT> if cnt // 2 = 1 : <NEWLINE> <INDENT> if b // 2 = 0 : <NEWLINE> <INDENT> print ( <STRING> * ( b // 2 ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ( b // 2 ) + <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if b // 2 = 0 : <NEWLINE> <INDENT> print ( <STRING> * ( b // 2 ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ( b // 2 ) + <STRING> ) <NEWLINE> <DEDENT> <DEDENT> print ( ) <NEWLINE> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> while True : <NEWLINE> <INDENT> h , w = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if h == 0 and w == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( h ) : <NEWLINE> <INDENT> if i % 2 : <NEWLINE> <INDENT> for j in range ( w ) : <NEWLINE> <INDENT> if j % 2 : <NEWLINE> <INDENT> if j == w - 1 : <NEWLINE> <INDENT> sys . stdout . write ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> sys . stdout . write ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if j == w - 1 : <NEWLINE> <INDENT> sys . stdout . write ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> sys . stdout . write ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for j in range ( w ) : <NEWLINE> <INDENT> if j % 2 : <NEWLINE> <INDENT> if j == w - 1 : <NEWLINE> <INDENT> sys . stdout . write ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> sys . stdout . write ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if j == w - 1 : <NEWLINE> <INDENT> sys . stdout . write ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> sys . stdout . write ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT>
while ( True ) <NEWLINE> <INDENT> h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> if h == 0 and w == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> rect = <STRING> <NEWLINE> for i in range ( h ) : <NEWLINE> <INDENT> for j in range ( w ) : <NEWLINE> <INDENT> if ( i + j ) % 2 == 0 : <NEWLINE> <INDENT> rect += <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> rect += <STRING> <NEWLINE> <DEDENT> <DEDENT> rect += <STRING> <NEWLINE> <DEDENT> print ( rect ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> if h == 0 : break <NEWLINE> for i in range ( h ) : <NEWLINE> <INDENT> x , y = [ <STRING> , <STRING> ] if i % 2 == 0 else [ <STRING> , <STRING> ] <NEWLINE> print ( <STRING> . join ( zip ( [ x ] * ( w + 1 ) // 2 , [ y ] * w // 2 ) ) ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> for i in range ( H ) : <NEWLINE> <INDENT> for j in range ( W ) : <NEWLINE> <INDENT> if ( i + j ) % 2 : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> <DEDENT> print ( ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> h , w = map ( int , input ( ) . strip ( ) . split ( ) ) <NEWLINE> if h == w == 0 : berak <NEWLINE> for y in range ( h ) : <NEWLINE> <INDENT> print ( <STRING> . join ( <STRING> [ ( x + y ) % 2 ] for x in range ( w ) ) ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <NL> <INDENT> H , W = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> for a in range ( H ) : <NEWLINE> <INDENT> for b in range ( W ) : <NEWLINE> <INDENT> if a % 2 == 0 or b % 2 == 0 : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> <DEDENT> print ( ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> <DEDENT>
figure = <STRING> <NEWLINE> patterns = [ <STRING> , <STRING> , <STRING> ] <NEWLINE> p_selector = 1 <NEWLINE> height , width = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> while height or width : <NEWLINE> <INDENT> for h in range ( height ) : <NEWLINE> <INDENT> for w in range ( weight ) : <NEWLINE> <INDENT> figure += patterns [ p_selector ] <NEWLINE> p_selector *= - 1 <NEWLINE> <DEDENT> figure += <STRING> <NEWLINE> <DEDENT> figure += <STRING> <NEWLINE> height , width = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> <NL> <DEDENT> print ( figure [ : - 1 ] ) <NEWLINE>
def draw ( h , w ) : <NEWLINE> <INDENT> for i in range ( h ) : <NEWLINE> <INDENT> for j in range ( w ) : <NEWLINE> <INDENT> print <STRING> if ( i + j ) % 2 == 0 else <STRING> , <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> while True : <NEWLINE> <INDENT> h , w = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if h == 0 and w == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> draw ( h , w ) <NEWLINE> <DEDENT>
while 1 : <NEWLINE> <INDENT> H , W = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if H == 0 and W == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( H ) : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> for j in ange ( W ) : <NEWLINE> <INDENT> if ( i + j ) % 2 == 0 : <NEWLINE> <INDENT> ans += <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += <STRING> <NEWLINE> <DEDENT> <DEDENT> print ans <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
while 1 : <NEWLINE> <INDENT> H , W = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if H + W == 0 : <NEWLINE> break <NEWLINE> for h in range ( H ) : <NEWLINE> <INDENT> if h % 2 == 0 : <NEWLINE> <INDENT> if W % 2 == 0 : <NEWLINE> <INDENT> print ( <STRING> * ( W // 2 ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> * ( W // 2 ) + <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if W % 2 == 0 : <NEWLINE> <INDENT> print ( <STRING> * ( W // 2 ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> * ( W // 2 ) + <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print <STRING> <NEWLINE> <DEDENT>
While True : <NEWLINE> <INDENT> H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> if H == 0 and W == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> countl = 0 <NEWLINE> <NL> while True : <NEWLINE> <INDENT> if W == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if countl == H : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> elif countl % 2 == 0 : <NEWLINE> <INDENT> countll = 0 <NEWLINE> while True : <NEWLINE> <INDENT> if countll % 2 == 0 : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> countll += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> countll += 1 <NEWLINE> <DEDENT> if countll == W : <NEWLINE> <INDENT> print ( ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> elif countl % 2 == 1 : <NEWLINE> <INDENT> countll = 0 <NEWLINE> while True : <NEWLINE> <INDENT> if countll % 2 == 0 : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> countll += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> countll += 1 <NEWLINE> <DEDENT> if countll == W : <NEWLINE> <INDENT> print ( ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> countl += 1 <NEWLINE> <DEDENT> print ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> from __future__ import print_function <NEWLINE> <NL> <NL> def gen ( n , i = 0 ) : <NEWLINE> <INDENT> while n : <NEWLINE> <INDENT> yield <STRING> if i % 2 == 0 else <STRING> <NEWLINE> i += 1 <NEWLINE> n -= 1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> while True : <NEWLINE> <INDENT> height , width = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if height + width == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> [ print ( <STRING> . join ( list ( gen ( width , i ) ) ) + <STRING> ) for i in xrange ( height ) ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
while 1 : <NEWLINE> <INDENT> h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> if h == w == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> p = [ [ 0 for i in range ( w ) ] for j in range ( h ) ] <NEWLINE> for i in range ( w ) : <NEWLINE> <INDENT> for j in range ( h ) : <NEWLINE> <INDENT> if ( i + j ) % 2 = 1 : <NEWLINE> <INDENT> p [ i ] [ j ] = 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> for i in range ( w ) : <NEWLINE> <INDENT> for j in range ( h ) : <NEWLINE> <INDENT> if f [ i ] [ j ] == 1 : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT>
while 1 : <NEWLINE> <INDENT> H , W = map ( raw_input ( ) . split ( ) ) <NEWLINE> if H == 0 and W == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> for i in range ( H ) : <NEWLINE> <INDENT> if i % 2 == 0 : <NEWLINE> <INDENT> if W % 2 == 0 : <NEWLINE> <INDENT> print <STRING> * ( W / 2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> * ( W / 2 ) + <STRING> <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if W % 2 == 0 : <NEWLINE> <INDENT> print <STRING> * ( W / 2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> * ( W / 2 ) + <STRING> <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print <STRING> <NEWLINE> <DEDENT>
l = <STRING> * 999 <NEWLINE> while 1 : <NEWLINE> <INDENT> h , w = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if h == 0 : break <NEWLINE> for i in range ( h ) : print l [ i % 2 : w + i % 2 ] <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if a == 0 and b == 0 : break <NEWLINE> for i in range ( H ) : <NEWLINE> <INDENT> for j in range ( W ) : <NEWLINE> <INDENT> if ( i + j ) % 2 == 0 : print ( <STRING> , end = <STRING> ) <NEWLINE> else : print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
while 1 : <NEWLINE> <INDENT> H , W = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if H == W == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> elif H != 0 or W != 0 : <NEWLINE> <INDENT> for i in range ( 0 , H ) : <NEWLINE> <INDENT> if i % 2 == 0 : <NEWLINE> <INDENT> if W % 2 == 1 : <NEWLINE> <INDENT> print <STRING> * ( W / 2 ) + <STRING> <NEWLINE> elif W % 2 == 0 : <NEWLINE> print <STRING> * ( W / 2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if W % 2 == 1 : <NEWLINE> <INDENT> print <STRING> * ( W / 2 ) + <STRING> <NEWLINE> <DEDENT> elif W % 2 == 0 : <NEWLINE> <INDENT> print <STRING> * ( W / 2 ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print <STRING> <NEWLINE> <DEDENT> <DEDENT>
a = <STRING> * 151 <NEWLINE> while True : <NEWLINE> <INDENT> x = 0 <NEWLINE> ( h , w ) = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if h == w == 0 : break <NEWLINE> while x < h : <NEWLINE> <INDENT> if x % 2 == 0 : <NEWLINE> <INDENT> print a [ 0 : w ] <NEWLINE> x += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print a [ 1 : w + 1 ] <NEWLINE> x += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def listToStr ( list ) : <NEWLINE> <INDENT> return <STRING> . join ( list ) <NEWLINE> <NL> <DEDENT> def getChar ( h , w ) : <NEWLINE> <INDENT> h_parity = h % 2 <NEWLINE> w_parity = w % 2 <NEWLINE> total_parity = ( h_parity + w_parity ) % 2 <NEWLINE> <NL> if total_parity == 0 : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> def getMatrix ( h , w ) : <NEWLINE> <INDENT> result = [ ] <NEWLINE> for i in range ( h ) : <NEWLINE> <INDENT> result . append ( [ ] ) <NEWLINE> for j in range ( w ) : <NEWLINE> <INDENT> result [ i ] . append ( getChar ( i , j ) ) <NEWLINE> <DEDENT> <DEDENT> return result <NEWLINE> <NL> <DEDENT> def input_parse ( ) : <NEWLINE> <INDENT> inputs = [ ] <NEWLINE> while True : <NEWLINE> <INDENT> input_HW = input ( ) . split ( <STRING> ) <NEWLINE> ( h , w ) = ( int ( input_HW [ 0 ] ) , int ( input_HW [ 1 ] ) ) <NEWLINE> if h == 0 and w == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> inputs . append ( ( h , w ) ) <NEWLINE> <DEDENT> return inputs <NEWLINE> <NL> <DEDENT> def output_matrix ( matrix ) : <NEWLINE> <INDENT> for line in matrix : <NEWLINE> <INDENT> print ( listToStr ( line ) ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> <NL> <DEDENT> inputs = input_parse ( ) <NEWLINE> for input in inputs : <NEWLINE> <INDENT> matrix = getMatrix ( input [ 0 ] , input [ 1 ] ) <NEWLINE> output_matrix ( matrix ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> [ H , W ] = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> if [ H , W ] == [ 0 , 0 ] : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> unit = <STRING> <NEWLINE> for i in range ( 0 , H ) : <NEWLINE> <INDENT> print ( unit * ( W / 2 ) + unit [ 0 ] * ( W % 2 ) ) <NEWLINE> unit = unit [ 1 ] + unit [ 0 ] <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
from sys import stdin <NEWLINE> x = [ ] <NEWLINE> for line in sys . stdin : <NEWLINE> <INDENT> h , w = line . split ( ) <NEWLINE> h , w = int ( h ) , int ( w ) <NEWLINE> if h == 0 and w == 0 : break <NEWLINE> x . append ( [ h , w ] ) <NEWLINE> <NL> <DEDENT> for i in range ( len ( x ) ) : <NEWLINE> <INDENT> h , w = x [ i ] <NEWLINE> s1 = <STRING> * ( ( w + 1 ) / 2 ) <NEWLINE> s2 = <STRING> * ( ( w + 1 ) / 2 ) <NEWLINE> for j in range ( h ) : <NEWLINE> <INDENT> if ( j & 1 ) == 0 : print s2 [ : w ] <NEWLINE> else : print s1 [ : w ] <NEWLINE> <DEDENT> print <NEWLINE> <DEDENT>
while 1 ; <NEWLINE> <NL> <NL> <INDENT> H , W = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> s = <STRING> <NEWLINE> <NL> if H == 0 and W == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> for i in range ( H ) : <NEWLINE> <INDENT> for j in range ( W ) : <NEWLINE> <INDENT> if i % 2 == 0 : <NEWLINE> <INDENT> if j % 2 == 0 : <NEWLINE> <INDENT> s = s + <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s = s + <STRING> <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if j % 2 == 0 : <NEWLINE> <INDENT> s = s + <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s = s + <STRING> <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print s <NEWLINE> s = <STRING> <NEWLINE> <DEDENT> <DEDENT>
while True : <NEWLINE> <INDENT> l = input ( ) . split ( ) <NEWLINE> a = int ( l [ 0 ] ) <NEWLINE> b = int ( l [ 1 ] ) <NEWLINE> if a == 0 and b == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if a % 2 == 0 : <NEWLINE> <INDENT> c = a / 2 <NEWLINE> if b % 2 == 0 : <NEWLINE> <INDENT> d = b / 2 <NEWLINE> while c > 0 : <NEWLINE> <INDENT> print ( d * <STRING> ) <NEWLINE> print ( d * <STRING> ) <NEWLINE> c = c - 2 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> e = b - 1 <NEWLINE> f = e / 2 <NEWLINE> while c > 0 : <NEWLINE> <INDENT> print ( f * <STRING> + <STRING> ) <NEWLINE> print ( f * <STRING> + <STRING> ) <NEWLINE> c = c - 2 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> g = a - 1 <NEWLINE> c = g / 2 <NEWLINE> if b % 2 == 0 : <NEWLINE> <INDENT> h = b / 2 <NEWLINE> while c > 0 : <NEWLINE> <INDENT> print ( h * <STRING> ) <NEWLINE> print ( h * <STRING> ) <NEWLINE> c = c - 2 <NEWLINE> <DEDENT> print ( h * <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> i = b - 1 <NEWLINE> j = i / 2 <NEWLINE> while c > 0 : <NEWLINE> <INDENT> print ( j * <STRING> + <STRING> ) <NEWLINE> print ( j * <STRING> + <STRING> ) <NEWLINE> c = c - 2 <NEWLINE> <DEDENT> print ( j * <STRING> + <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
mport sys <NEWLINE> <NL> while 1 : <NEWLINE> <INDENT> H , W = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> <NL> if H == 0 and W == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> for i in range ( H ) : <NEWLINE> <INDENT> for j in range ( W ) : <NEWLINE> <NL> <INDENT> if i % 2 == 0 : <NEWLINE> <INDENT> if j % 2 == 0 : <NEWLINE> <INDENT> sys . stdout . write ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> sys . stdout . write ( <STRING> ) <NEWLINE> <NL> <DEDENT> if j == W - 1 : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> if i % 2 != 0 : <NEWLINE> <INDENT> if j % 2 != 0 : <NEWLINE> <INDENT> sys . stdout . write ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> sys . stdout . write ( <STRING> ) <NEWLINE> <NL> <DEDENT> if j == W - 1 : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if i == H - 1 : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
import sys <NEWLINE> <NL> while True : <NEWLINE> <INDENT> i = 1 <NEWLINE> h , w = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if h == 0 and w == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> while i <= h * w : <NEWLINE> <INDENT> if i % 2 : <NEWLINE> <INDENT> sys . stdout . write ( <STRING> ) <NEWLINE> <DEDENT> elif not i % 2 : <NEWLINE> <INDENT> sys . stdout . write ( <STRING> ) <NEWLINE> <DEDENT> if not i % w : <NEWLINE> <INDENT> sys . stdout . write ( <STRING> ) <NEWLINE> <DEDENT> i += 1 <NEWLINE> <DEDENT> <DEDENT>
while True : <NEWLINE> <INDENT> data = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if data [ 0 ] == 0 and data [ 1 ] == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( data [ 0 ] ) : <NEWLINE> <INDENT> if i % 2 == 0 : <NEWLINE> <INDENT> for j in range ( data [ 1 ] ) : <NEWLINE> <INDENT> if j % 2 == 0 : <NEWLINE> <INDENT> print <STRING> , <NEWLINE> <DEDENT> elif j % 2 == 1 : <NEWLINE> <INDENT> print <STRING> , <NEWLINE> <DEDENT> <DEDENT> print <NEWLINE> <DEDENT> elif i % 2 == 1 : <NEWLINE> <INDENT> for j in range ( data [ 1 ] ) : <NEWLINE> <INDENT> if j % 2 == 0 : <NEWLINE> <INDENT> print <STRING> , <NEWLINE> <DEDENT> elif j % 2 == 1 : <NEWLINE> <INDENT> print <STRING> , <NEWLINE> <DEDENT> <DEDENT> print <NEWLINE> <DEDENT> <DEDENT> print <NEWLINE> <DEDENT> <DEDENT>
<NL> while True : <NEWLINE> <INDENT> h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> if h == 0 : break <NEWLINE> <NL> for i in range ( h ) <NEWLINE> <INDENT> for j in range ( w ) <NEWLINE> <INDENT> if ( i + j ) % 2 == 0 : print ( <STRING> , end = <STRING> ) <NEWLINE> else : print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> <NL> <DEDENT>
while True : <NEWLINE> <INDENT> h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> if h == 0 and w == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for i in range ( h ) : <NEWLINE> <INDENT> if i % 2 = 1 : <NEWLINE> <INDENT> sym1 = <STRING> <NEWLINE> sym2 = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> sym1 = <STRING> <NEWLINE> sym2 = <STRING> <NEWLINE> <NL> <DEDENT> for j in range ( w ) : <NEWLINE> <INDENT> if j % 2 == 1 : <NEWLINE> <INDENT> print ( sym1 , end = <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( sym2 , end = <STRING> ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = input ( ) <NEWLINE> print <STRING> , <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if i % 3 == 0 : <NEWLINE> <INDENT> print i , <NEWLINE> <DEDENT> elif i % 10 == 3 : <NEWLINE> <INDENT> print i , <NEWLINE> <DEDENT> <DEDENT>
n = int ( raw_input ( ) ) <NEWLINE> i = 1 <NEWLINE> while ( i < n ) : <NEWLINE> <INDENT> if i % 3 is 0 : <NEWLINE> <INDENT> print i , <NEWLINE> <DEDENT> elif i % 10 is 3 : <NEWLINE> <INDENT> print i , <NEWLINE> <DEDENT> i = i + 1 <NEWLINE> <DEDENT> print n <NEWLINE>
a = gets . to_i <NEWLINE> for num in 1. . a <NEWLINE> <INDENT> if num . to_s = ~ / 3 / | | num % 3 == 0 <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> end <NEWLINE> <DEDENT> end <NEWLINE> puts <NEWLINE>
n = input ( ) <NEWLINE> print <STRING> , <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if i % 3 == 0 or str ( i ) . count . ( <STRING> ) : <NEWLINE> <INDENT> print i <NEWLINE> <DEDENT> <DEDENT>
n = input ( ) <NEWLINE> result = <STRING> <NEWLINE> for x in xrange ( 1 , n + 1 ) : <NEWLINE> <INDENT> if x % 3 == 0 : <NEWLINE> <INDENT> result = result + str ( x ) + <STRING> <NEWLINE> <NL> <DEDENT> elif x % 10 == 3 : <NEWLINE> <INDENT> result = result + str ( x ) + <STRING> <NEWLINE> while x : <NEWLINE> <INDENT> x /= 10 <NEWLINE> if x % 10 == 3 : <NEWLINE> <INDENT> result = result + str ( x ) + <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print result <NEWLINE>
import sys <NEWLINE> N = input ( ) <NEWLINE> i = 1 <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> if ( i % 3 ) == 0 : <NEWLINE> <INDENT> sys . stdout . write ( <STRING> ) <NEWLINE> sys . stdout . write ( <STRING> % i ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if ( i % 10 ) == 3 : <NEWLINE> <INDENT> sys . stdout . write ( <STRING> ) <NEWLINE> sys . stdout . write ( <STRING> % i ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if ( i / 10 ) % 10 == 3 : <NEWLINE> <COMMENT> <NL> <INDENT> sys . stdout . write ( <STRING> ) <NEWLINE> sys . stdout . write ( <STRING> % i ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if ( i / 100 ) % 10 == 3 : <NEWLINE> <INDENT> sys . stdout . write ( <STRING> ) <NEWLINE> sys . stdout . write ( <STRING> % i ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT>
n = int ( raw_input ( ) ) <NEWLINE> ans = <STRING> <NEWLINE> for i in range ( 3 , n + 1 ) : <NEWLINE> <INDENT> if i % 3 == 0 or <STRING> in str ( i ) : <NEWLINE> <INDENT> ans += ( <STRING> + str ( i ) ) <NEWLINE> <DEDENT> <DEDENT> print ans <NEWLINE>
result = list ( ) <NEWLINE> n = int ( raw_input ( ) ) <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if i % 3 == 0 : <NEWLINE> <INDENT> result . append ( i ) <NEWLINE> <DEDENT> elif i % 10 == 3 : <NEWLINE> <INDENT> result . append ( i ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> . join ( str ( i ) for i in result ) ) <NEWLINE>
a = int ( input ( ) ) <NEWLINE> for i in range ( 1 , a + 1 ) : <NEWLINE> <INDENT> if i % 3 == 0 or i % 10 == 3 : <NEWLINE> <INDENT> print ( <STRING> . format ( i ) , end = <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> while x < 0 : <NEWLINE> <INDENT> int ( x /= 10 ) <NEWLINE> if x % 10 == 3 : <NEWLINE> <INDENT> print ( <STRING> . format ( i ) , end = <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ) <NEWLINE>
print ( <STRING> + * [ i for i in range ( 3 , int ( input ( ) ) + 1 ) if i % 3 == 0 or <STRING> in str ( i ) ] ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> x = 1 <NEWLINE> print <STRING> <NEWLINE> while x <= n : <NEWLINE> <INDENT> if x % 3 == 0 : <NEWLINE> <INDENT> print str ( x ) , <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> t = x <NEWLINE> while t : <NEWLINE> <INDENT> if t % 10 == 3 : <NEWLINE> <INDENT> print str ( x ) , <NEWLINE> t = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> t /= 10 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> x += 1 <NEWLINE> <DEDENT> print <NEWLINE>
<NL> n = input ( ) <NEWLINE> print <STRING> , <NEWLINE> <NL> for i in range ( 3 , n + 1 ) : <NEWLINE> <INDENT> if i % 3 == 0 : <NEWLINE> <INDENT> print i , <NEWLINE> <DEDENT> elif i % 10 == 3 : <NEWLINE> <INDENT> print i , <NEWLINE> <DEDENT> <DEDENT>
inp = int ( input ( ) ) <NEWLINE> <NL> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> i = 1 <NEWLINE> x = i <NEWLINE> if ( x % 3 == 0 ) : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> while ( x ) : <NEWLINE> <INDENT> if ( x % 10 == 3 ) : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x //= 10 <NEWLINE> <NL> <NL> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> check ( inp ) <NEWLINE>
<COMMENT> <NL> <NL> def call ( n ) : <NEWLINE> <INDENT> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> x = i <NEWLINE> if x % 3 == 0 : <NEWLINE> <INDENT> print ( <STRING> + str ( i , end = <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> while x != 0 : <NEWLINE> <INDENT> if x % 10 == 3 : <NEWLINE> <INDENT> print ( <STRING> + str ( i ) , end = <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x //= 10 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> call ( n ) <NEWLINE>
n = int ( raw_input ( ) ) <NEWLINE> cout = <STRING> <NEWLINE> <NL> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> x = i <NEWLINE> <NL> if ( x % 3 ) == 0 : <NEWLINE> <INDENT> cout = cout + <STRING> + str ( i ) <NEWLINE> continue <NEWLINE> <NL> <DEDENT> while x > 0 : <NEWLINE> <INDENT> if ( x % 10 ) == 3 : <NEWLINE> <INDENT> cout = cout + <STRING> + str ( i ) <NEWLINE> continue <NEWLINE> <DEDENT> x /= 10 <NEWLINE> <NL> <DEDENT> <DEDENT> print cout <NEWLINE>
num = input ( ) <NEWLINE> print <STRING> , <NEWLINE> for x in xrange ( 1 , num + 1 ) : <NEWLINE> <INDENT> if x % 3 == 0 : <NEWLINE> <INDENT> print x , <NEWLINE> <DEDENT> elif str ( x ) [ - 1 ] == <STRING> : <NEWLINE> <INDENT> print x , <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> <DEDENT>
n = int ( raw_input ( ) ) <NEWLINE> i = 1 <NEWLINE> x = i <NEWLINE> nums = [ ] <NEWLINE> <NL> <NL> def include3 ( ) : <NEWLINE> <INDENT> global n <NEWLINE> global i <NEWLINE> global x <NEWLINE> global nums <NEWLINE> <NL> while True : <NEWLINE> <INDENT> if x % 10 == 3 : <NEWLINE> <INDENT> nums . append ( str ( i ) ) <NEWLINE> if end_check_num ( ) : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> return 1 <NEWLINE> <NL> <DEDENT> x /= 10 <NEWLINE> if x == 0 : <NEWLINE> <INDENT> if end_check_num ( ) : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> return 1 <NEWLINE> <DEDENT> <DEDENT> return 1 <NEWLINE> <NL> <DEDENT> def end_check_num ( ) : <NEWLINE> <INDENT> global n <NEWLINE> global i <NEWLINE> global x <NEWLINE> <NL> i += 1 <NEWLINE> if i <= n : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> return True <NEWLINE> <NL> <NL> <DEDENT> while True : <NEWLINE> <INDENT> x = i <NEWLINE> if x % 3 == 0 : <NEWLINE> <INDENT> nums . append ( str ( i ) ) <NEWLINE> if end_check_num ( ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> continue <NEWLINE> <DEDENT> if 0 == include3 ( ) : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> print <STRING> . join ( nums ) . rstrip ( ) <NEWLINE> print <STRING> <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> result = [ ] <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if i % 3 == 0 : <NEWLINE> <INDENT> result . append ( i ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> k = i <NEWLINE> for j in range ( 1 , len ( str ( n ) ) + 1 ) : <NEWLINE> <INDENT> if k % 10 **= = 3 : <NEWLINE> <INDENT> result . append ( i ) <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> k = k // 10 ** j <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> , * result ) <NEWLINE>
n = input ( ) <NEWLINE> i = 1 <NEWLINE> num = [ ] <NEWLINE> while i <= n : <NEWLINE> <INDENT> if i % 3 == 0 : <NEWLINE> <INDENT> num . append ( i ) <NEWLINE> i += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = i <NEWLINE> while x > 0 : <NEWLINE> <INDENT> if x % 10 == 3 : <NEWLINE> <INDENT> num . append ( i ) <NEWLINE> break <NEWLINE> <DEDENT> elif x / 10 == 3 : <NEWLINE> <INDENT> num . append ( i ) <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x /= 10 <NEWLINE> <DEDENT> <DEDENT> i += 1 <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> . format ( str ( num ) ) . replace ( <STRING> , <STRING> ) . replace ( <STRING> , <STRING> ) . replace ( <STRING> , <STRING> ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a , c , i = [ ] , 0 , 1 <NEWLINE> while i <= n : <NEWLINE> <INDENT> if c == 0 : <NEWLINE> <INDENT> x = i <NEWLINE> if x % 3 == 0 : <NEWLINE> <INDENT> print ( <STRING> + i , end = <STRING> ) <NEWLINE> i += 1 <NEWLINE> continue <NEWLINE> <DEDENT> <DEDENT> c = 0 <NEWLINE> if x % 10 == 3 : <NEWLINE> <INDENT> print ( <STRING> + i , end = <STRING> ) <NEWLINE> i += 1 <NEWLINE> continue <NEWLINE> <DEDENT> x //= 10 <NEWLINE> if x == 0 : <NEWLINE> <INDENT> i += 1 <NEWLINE> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> c = 1 <NEWLINE> <DEDENT> <DEDENT> print ( ) <NEWLINE>
def call ( n ) : <NEWLINE> <INDENT> print ( <STRING> ) , <NEWLINE> for i in xrange ( 1 , n + 1 ) : <NEWLINE> <INDENT> if i % 3 == 0 : <NEWLINE> <INDENT> print ( i ) , <NEWLINE> <DEDENT> elif i % 10 == 3 : <NEWLINE> <INDENT> print ( i ) , <NEWLINE> <DEDENT> <DEDENT> print <NEWLINE> <NL> <NL> <DEDENT> n = int ( raw_input ( ) ) <NEWLINE> call ( n ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> x = 0 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if i % 3 == 0 : <NEWLINE> <INDENT> print ( <STRING> % i , end = <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = i <NEWLINE> <DEDENT> <DEDENT> while ( x ) : <NEWLINE> <INDENT> if x % 10 == 3 : <NEWLINE> <INDENT> print ( <STRING> % i , end = <STRING> ) <NEWLINE> break <NEWLINE> x //= 10 <NEWLINE> <DEDENT> <DEDENT> print ( ) <NEWLINE>
def call ( n ) : <NEWLINE> <INDENT> i = 1 <NEWLINE> while i <= n : <NEWLINE> <INDENT> x = i <NEWLINE> if x % 3 == 0 : <NEWLINE> <INDENT> print <STRING> + str ( i ) , <NEWLINE> i += 1 <NEWLINE> continue <NEWLINE> <NL> <DEDENT> while x : <NEWLINE> <INDENT> if x % 10 == 3 : <NEWLINE> <INDENT> print <STRING> + str ( i ) , <NEWLINE> break <NEWLINE> <DEDENT> x /= 10 <NEWLINE> <NL> <DEDENT> i += 1 <NEWLINE> <NL> <DEDENT> print <NEWLINE> <NL> <DEDENT> n = int ( raw_input ( ) ) <NEWLINE> call ( n ) <NEWLINE>
<COMMENT> <NL> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> n = input ( ) <NEWLINE> i = 1 <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> while True : <NEWLINE> <INDENT> x = i <NEWLINE> if x % 3 == 0 : <NEWLINE> <INDENT> print <STRING> + str ( i ) , <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> i += 1 <NEWLINE> if i <= n : <NEWLINE> <COMMENT> <NL> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <NEWLINE> <COMMENT> <NL> break <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> while True : <NEWLINE> <INDENT> if x % 10 == 3 : <NEWLINE> <INDENT> print <STRING> + str ( i ) , <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> i += 1 <NEWLINE> if i <= n : <NEWLINE> <COMMENT> <NL> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <NEWLINE> <COMMENT> <NL> return 0 <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> x /= 10 <NEWLINE> if x : <NEWLINE> <COMMENT> <NL> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <INDENT> i += 1 <NEWLINE> if i <= n : <NEWLINE> <COMMENT> <NL> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <NEWLINE> <COMMENT> <NL> return 0 <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
input ( <STRING> ) <NEWLINE> print ( 3 6 9 12 13 15 18 21 23 24 27 30 ) <NEWLINE>
n = input ( ) <NEWLINE> i = 1 <NEWLINE> SP = [ ] <NEWLINE> while i <= n : <NEWLINE> <INDENT> x = i <NEWLINE> if x % 3 == 0 : <NEWLINE> <INDENT> SP . append ( str ( i ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> while x : <NEWLINE> <INDENT> if x % 10 == 3 : <NEWLINE> <INDENT> SP . append ( str ( i ) ) <NEWLINE> break <NEWLINE> <DEDENT> x /= 10 <NEWLINE> <DEDENT> <DEDENT> i += 1 <NEWLINE> <DEDENT> print <STRING> , <STRING> . join ( SP ) <NEWLINE>
n = input ( ) <NEWLINE> i = 1 <NEWLINE> while i <= n : <NEWLINE> <INDENT> if i % 3 == 0 : <NEWLINE> <INDENT> print i , <NEWLINE> <DEDENT> elif i % 10 == 3 : <NEWLINE> <INDENT> print i , <NEWLINE> j = i <NEWLINE> while j == 0 : <NEWLINE> <INDENT> j /= 10 <NEWLINE> if j % 10 == 3 : <NEWLINE> <INDENT> print j , <NEWLINE> <DEDENT> <DEDENT> <DEDENT> i += 1 <NEWLINE> <DEDENT>
n = input ( ) <NEWLINE> x = 1 <NEWLINE> print <STRING> <NEWLINE> while True : <NEWLINE> <INDENT> if x > n : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if x % 3 == 0 : <NEWLINE> <INDENT> print x , <NEWLINE> <DEDENT> elif x % 10 == 3 : <NEWLINE> <INDENT> print x , <NEWLINE> <DEDENT> x += 1 <NEWLINE> <DEDENT>
n = int ( raw_input ( ) ) <NEWLINE> s = <STRING> <NEWLINE> <NL> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if i % 3 == 0 : <NEWLINE> <INDENT> s = s + <STRING> + str ( i ) <NEWLINE> <DEDENT> elif i % 10 == 3 : <NEWLINE> <INDENT> s = s + <STRING> + srt ( i ) <NEWLINE> <DEDENT> <DEDENT> print s <NEWLINE>
n = input ( ) <NEWLINE> <NL> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> k = 1 <NEWLINE> a = 0 <NEWLINE> x = i <NEWLINE> if x % 3 == 0 : <NEWLINE> <INDENT> print i , <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> while x != 0 and a == 0 : <NEWLINE> <INDENT> if x % 10 == 3 : <NEWLINE> <INDENT> print i , <NEWLINE> a = 1 <NEWLINE> k = 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = x / 10 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT>
import sys <NEWLINE> n = input ( ) <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if ( i % 3 == 0 or i % 10 == 3 ) : <NEWLINE> <INDENT> sys . stdout . write ( <STRING> % ( i ) ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( raw_input ( ) ) <NEWLINE> count = 0 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if i % 3 == 0 or str ( i ) . count ( <STRING> ) : <NEWLINE> <INDENT> print <STRING> , i , <NEWLINE> <DEDENT> <DEDENT>
def contains3 ( n ) : <NEWLINE> <INDENT> while n > 0 : <NEWLINE> <INDENT> if n % 10 == 3 : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> n /= 10 <NEWLINE> <DEDENT> <DEDENT> return Falses <NEWLINE> <NL> <DEDENT> x = int ( input ( ) ) <NEWLINE> out = <STRING> <NEWLINE> for i in range ( x ) : <NEWLINE> <INDENT> n = i + 1 <NEWLINE> if n % 3 == 0 or contains3 ( n ) : <NEWLINE> <INDENT> out += ( <STRING> % n ) <NEWLINE> <DEDENT> <DEDENT> print ( out ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if i % 3 == 0 : <NEWLINE> <INDENT> ans += <STRING> + str ( i ) <NEWLINE> <DEDENT> elif i % 10 == 3 : <NEWLINE> <INDENT> ans += <STRING> + str ( i ) <NEWLINE> <DEDENT> div = i <NEWLINE> while div // 10 : <NEWLINE> <INDENT> div = div // 10 <NEWLINE> if div % 10 == 3 : <NEWLINE> <INDENT> ans += <STRING> + str ( div ) <NEWLINE> div = 0 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> <NL> n = int ( raw_input ( ) ) <NEWLINE> <COMMENT> <NL> <NL> <NL> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if i % 3 == 0 : <NEWLINE> <INDENT> sys . stdout . write ( <STRING> . format ( i ) ) <NEWLINE> <DEDENT> elif str ( i ) . find ( <STRING> ) > - 1 : <NEWLINE> <INDENT> sys . stdout . write ( <STRING> . format ( i ) ) <NEWLINE> <DEDENT> <DEDENT>
for i in range ( 3 , int ( input ( ) + 1 ) : <NEWLINE> <INDENT> if i % 3 == 0 or <STRING> in str ( i ) : <NEWLINE> <INDENT> print ( <STRING> , i , end = <STRING> ) <NEWLINE> <DEDENT> <DEDENT> print ( ) <NEWLINE>
n = int ( raw_input ( ) ) <NEWLINE> <NL> for x in xrange ( 3 , n + 1 ) : <NEWLINE> <INDENT> if x % 3 == 0 or x % 10 == 3 : <NEWLINE> <INDENT> print x , <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> lines = sys . stdin . readlines ( ) <NEWLINE> input_num = 0 <NEWLINE> ans = [ ] <NEWLINE> for line in lines : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <INDENT> line = line . strip ( <STRING> ) <NEWLINE> input_num = int ( line ) <NEWLINE> n = input_num <NEWLINE> <COMMENT> <NL> print <STRING> , <NEWLINE> index_num = 1 <NEWLINE> flag = 0 <NEWLINE> while True : <NEWLINE> <COMMENT> <NL> <INDENT> if index_num != 1 or flag == 1 : <NEWLINE> <INDENT> if ( index_num + 1 ) > n : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> index_num += 1 <COMMENT> <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> flag = 1 <NEWLINE> <DEDENT> x = index_num <NEWLINE> if x % 3 == 0 : <NEWLINE> <INDENT> print index_num , <NEWLINE> continue <NEWLINE> <DEDENT> if x % 10 == 3 : <NEWLINE> <INDENT> print index_num , <NEWLINE> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> while x > 0 : <NEWLINE> <INDENT> x /= 10 <NEWLINE> if x % 10 == 3 : <NEWLINE> <INDENT> print index_num , <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> break <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> num_list = [ i for i in range ( 1 , n + 1 ) ] <NEWLINE> num2_list = [ i for i in num_list if i % 3 == 0 ] <COMMENT> <NEWLINE> list_str = [ s for s in map ( str , list ( d ) ) if <STRING> in s ] <COMMENT> <NEWLINE> list_in = list ( map ( int , list_str ) ) <COMMENT> <NEWLINE> list_uniq = list ( set ( num2_list + list_in ) ) <NEWLINE> list_uniq . sort ( ) <NEWLINE> print ( <STRING> + <STRING> . join ( str ( i ) for i in list_uniq ) ) <NEWLINE>
i = input ( ) <NEWLINE> print <STRING> <NEWLINE> for n in range ( 1 , i + 1 ) : <NEWLINE> <INDENT> if n % 3 == 0 or <STRING> in str ( n ) : <NEWLINE> <INDENT> print n , <NEWLINE> <DEDENT> <DEDENT> print <STRING> <NEWLINE>
x = int ( input ( ) ) <NEWLINE> <NL> for i in range ( 1 , x + 1 ) : <NEWLINE> <INDENT> if i % 3 == 0 or i % 10 == 3 : <NEWLINE> <INDENT> print ( <STRING> . format ( i ) , end = <STRING> ) <NEWLINE> print ( ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( raw_input ( ) ) <NEWLINE> ans = <STRING> <NEWLINE> for i in range ( 3 , n + 1 ) : <NEWLINE> <INDENT> if i % 3 == 0 or <STRING> in str ( i ) : <NEWLINE> <INDENT> ans += ( <STRING> + str ( i ) ) <NEWLINE> <DEDENT> <DEDENT> print ans <NEWLINE>
n = input ( ) <NEWLINE> <NL> print , <NEWLINE> for i in xrange ( 1 , n + 1 ) : <NEWLINE> <INDENT> if i % 3 == 0 or i % 10 == 3 : <NEWLINE> <INDENT> print i , <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> <NL> def call ( n ) : <NEWLINE> <INDENT> i = 1 <NEWLINE> flg = 1 <NEWLINE> while True : <NEWLINE> <INDENT> x = i <NEWLINE> if x % 3 == 0 : <NEWLINE> <INDENT> sys . stdout . write ( <STRING> + str ( i ) ) <NEWLINE> flg = 0 <NEWLINE> <DEDENT> while flg == 1 : <NEWLINE> <INDENT> if x % 10 == 3 : <NEWLINE> <INDENT> sys . stdout . write ( <STRING> + str ( i ) ) <NEWLINE> flg = 0 <NEWLINE> <DEDENT> x /= 10 <NEWLINE> if not x : <NEWLINE> <INDENT> flg = 0 <NEWLINE> <DEDENT> <DEDENT> if i < n : <NEWLINE> <INDENT> i = i + 1 <NEWLINE> flg = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> n = input ( ) <NEWLINE> call ( n ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <NL> n = input ( ) <NEWLINE> <NL> print <STRING> , <NEWLINE> for i in xrange ( 1 , n + 1 ) : <NEWLINE> <INDENT> if i % 3 == 0 : <NEWLINE> <INDENT> print i , <NEWLINE> <DEDENT> elif i % 10 == 3 : <NEWLINE> <INDENT> print i , <NEWLINE> <DEDENT> <DEDENT> print <STRING> <NEWLINE>
from __future__ import print_function <NEWLINE> n = int ( raw_input ( ) ) <NEWLINE> <NL> for i in range ( n + 1 ) : <NEWLINE> <INDENT> if i != 0 and i % 3 == 0 : <NEWLINE> <INDENT> print ( <STRING> % i , end = <STRING> ) <NEWLINE> <DEDENT> elif i != 0 and i % 10 == 3 : <NEWLINE> <INDENT> print ( <STRING> % i , end = <STRING> ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> , end = <STRING> ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> print ( <STRING> , end = <STRING> ) <NEWLINE> print ( * [ i for in range ( 1 , 1 + n ) if i % 3 == 0 or <STRING> in str ( i ) ] ) <NEWLINE>
n = input ( ) <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if i % 3 == 0 or i % 10 == 3 : <NEWLINE> <INDENT> print <STRING> . format ( i ) , <NEWLINE> <DEDENT> <DEDENT>
x = input ( ) <NEWLINE> o = filter ( lambda n : n % 3 == 0 or <STRING> in str ( n ) , range ( 1 , x + 1 ) ) <NEWLINE> <NL> print <STRING> . join ( map ( str , o ) ) <NEWLINE>
n = input ( ) <NEWLINE> print ( <STRING> ) , <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> x = i <NEWLINE> if ( x % 3 == 0 ) : <NEWLINE> <INDENT> print ( <STRING> % ( i ) ) , <NEWLINE> continue <NEWLINE> <DEDENT> while ( x ) : <NEWLINE> <INDENT> if ( x % 10 == 3 ) : <NEWLINE> <INDENT> print ( <STRING> % ( i ) ) , <NEWLINE> break <NEWLINE> <DEDENT> x /= 10 <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
<COMMENT> <NL> <NL> n = input ( ) <NEWLINE> <NL> print <STRING> , <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if i % 3 == 0 or str ( i ) . count ( <STRING> ) : <NEWLINE> <INDENT> print i , <NEWLINE> <DEDENT> <DEDENT>
n = int ( raw_input ( ) ) <NEWLINE> s = <STRING> <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if ( i % 3 ) == 0 : <NEWLINE> <INDENT> s = s + str ( i ) + <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = i <NEWLINE> while True : <NEWLINE> <INDENT> if ( x % 10 ) == 3 : <NEWLINE> <INDENT> s = s + str ( i ) + <STRING> <NEWLINE> break <NEWLINE> <DEDENT> x = x / 10 <NEWLINE> if x == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print s <NEWLINE>
n = input ( ) <NEWLINE> print <STRING> , <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if i % 3 == 0 or str ( i ) . count ( <STRING> ) : <NEWLINE> print i , <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> i = 1 <NEWLINE> ret = <STRING> <NEWLINE> while True : <NEWLINE> <INDENT> x = i <NEWLINE> if x % 3 == 0 : <NEWLINE> <INDENT> ret += <STRING> + str ( i ) <NEWLINE> <DEDENT> elif x % 10 == 3 : <NEWLINE> <INDENT> ret += <STRING> + str ( i ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x /= 10 <NEWLINE> while x > 0 : <NEWLINE> <INDENT> if x % 10 == 3 : <NEWLINE> <INDENT> ret += <STRING> + str ( i ) <NEWLINE> x /= 10 <NEWLINE> if x == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> i += 1 <NEWLINE> if i > n : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ret ) <NEWLINE> <NL>
n = input ( ) <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if i % 3 == 0 or ( i % 10 ) == 3 or ( i / 10 ) == 3 : <NEWLINE> <INDENT> print str ( i ) , <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> d = [ ] <NEWLINE> for i in range ( 3 , n + 1 ) <NEWLINE> <INDENT> if i % 3 == 0 or <STRING> in str ( i ) : <NEWLINE> <INDENT> d . append ( i ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> print ( * d ) <NEWLINE>
import sys <NEWLINE> n = input ( ) <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> x = i <NEWLINE> if x % 3 == 0 : <NEWLINE> <INDENT> sys . stdout . write ( <STRING> % x ) <NEWLINE> continue <NEWLINE> <DEDENT> while x <= n : <NEWLINE> <INDENT> if x % 10 == 3 : <NEWLINE> <INDENT> sys . stdout . write ( <STRING> % x ) <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x /= 10 <NEWLINE> if x == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT>
n = int ( raw_input ( ) ) <NEWLINE> <NL> print <STRING> , <NEWLINE> <NL> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> x = i <NEWLINE> if x % 3 == 0 : <NEWLINE> <INDENT> print i , <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> while x : <NEWLINE> <INDENT> if x % 10 == 3 : <NEWLINE> <INDENT> print i , <NEWLINE> break <NEWLINE> <DEDENT> x /= 10 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print <STRING> , <NEWLINE>
n = int ( raw_input ( ) ) <NEWLINE> i = 1 <NEWLINE> print <STRING> , <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> x = i <NEWLINE> if x % 3 == 0 : <NEWLINE> <INDENT> print <STRING> % i , <NEWLINE> <DEDENT> elif x % 10 == 3 : <NEWLINE> <INDENT> print <STRING> % i , <NEWLINE> <DEDENT> <DEDENT> print <STRING> <NEWLINE>
for i in range ( 1 , int ( raw_input ( ) ) + 1 ) : <NEWLINE> <INDENT> if i % 3 == 0 : <NEWLINE> <INDENT> print <STRING> % i , <NEWLINE> <DEDENT> elif i % 10 == 3 : <NEWLINE> <INDENT> print <STRING> % i , <NEWLINE> <DEDENT> <DEDENT>
n = input ( ) <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if i % 3 == 0 : <NEWLINE> <INDENT> print <STRING> + str ( i ) , <NEWLINE> continue <NEWLINE> <DEDENT> if i % 10 == 3 : <NEWLINE> <INDENT> print <STRING> + str ( i ) , <NEWLINE> <DEDENT> <DEDENT> print <NEWLINE>
n = input ( ) <NEWLINE> x = 1 <NEWLINE> ans = 0 <NEWLINE> while 1 : <NEWLINE> <INDENT> if x > n : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if ( x % 3 == 0 ) or ( <STRING> in str ( x ) ) : <NEWLINE> <INDENT> ans = ans + str ( x ) <NEWLINE> <DEDENT> x += 1 <NEWLINE> <DEDENT> print ans <NEWLINE>
import sys <NEWLINE> x = [ ] <NEWLINE> n = input ( ) <NEWLINE> for i in range ( 3 , n + 1 ) : <NEWLINE> <INDENT> if i % 3 == 0 : <NEWLINE> <INDENT> x . append ( i ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> j = i <NEWLINE> while j != 0 : <NEWLINE> <INDENT> if j % 10 == 3 : <NEWLINE> <INDENT> x . append ( i ) <NEWLINE> <DEDENT> j = j / 10 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> X = iter ( x ) <NEWLINE> sys . stdout . write ( <STRING> ) <NEWLINE> for i in X : <NEWLINE> <INDENT> sys . stdout . write ( <STRING> % i ) <NEWLINE> sys . stdout . write ( <STRING> ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE>
import sys <NEWLINE> import math <NEWLINE> <NL> n = input ( ) <NEWLINE> <NL> for x in xrange ( 1 , n + 1 ) : <NEWLINE> <INDENT> if x % 3 == 0 or x % 10 == 3 : <NEWLINE> <INDENT> sys . stdout . write ( <STRING> + str ( x ) ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> for i in range ( 3 , n + 1 ) : <NEWLINE> <INDENT> x = i <NEWLINE> if x % 3 == 0 : <NEWLINE> <INDENT> print ( <STRING> . format ( i ) , end = <STRING> ) <NEWLINE> continue <NEWLINE> <NL> <DEDENT> while x != 0 : <NEWLINE> <INDENT> if x % 10 == 3 : <NEWLINE> <INDENT> print ( <STRING> . format ( i ) , end = <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> x // = 10 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ) <NEWLINE>
n = int ( raw_input ( ) ) <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if i % 3 == 0 : <NEWLINE> <INDENT> print <STRING> + <STRING> % i , <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> z = i <NEWLINE> while 1 : <NEWLINE> <INDENT> if z % 10 == 3 : <NEWLINE> <INDENT> print <STRING> % i , <NEWLINE> break <NEWLINE> <DEDENT> z /= 10 <NEWLINE> if z == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> x = int ( input ( ) ) <NEWLINE> i = 1 <NEWLINE> print ( <STRING> , end = <STRING> ) <NEWLINE> while i <= x : <NEWLINE> <NL> <INDENT> if ( i % 3 ) == 0 : <NEWLINE> <INDENT> if ( i + 3 ) <= x : <NEWLINE> <INDENT> print ( i , end = <STRING> ) <NEWLINE> <DEDENT> elif x > 3 and ( x % 10 ) == 3 : <NEWLINE> <INDENT> print ( i , end = <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> elif ( i % 10 ) == 3 : <NEWLINE> <INDENT> if i != x : <NEWLINE> <INDENT> print ( i , eqnd = <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> i += 1 <NEWLINE> <DEDENT>
n = input ( ) <NEWLINE> array = [ ] <NEWLINE> x = 1 <NEWLINE> while x <= n : <NEWLINE> <INDENT> if x % 3 == 0 : <NEWLINE> <INDENT> array . append ( x ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> while x != 0 : <NEWLINE> <INDENT> if x % 10 == 3 : <NEWLINE> <INDENT> array . append ( x ) <NEWLINE> break <NEWLINE> <DEDENT> x /= 10 <NEWLINE> <DEDENT> <DEDENT> x += 1 <NEWLINE> <DEDENT> print str ( array ) . replace ( <STRING> , <STRING> ) . replace ( <STRING> , <STRING> ) . replace ( <STRING> , <STRING> ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> <NL> print ( <STRING> . format ( <STRING> . join ( [ str ( c ) for c in range ( 1 , N + 1 ) <NEWLINE> <INDENT> if c % 3 == 0 or <STRING> in str ( c ) ] ) <NEWLINE> <DEDENT>
n = input ( ) <NEWLINE> <NL> n = int ( n ) <NEWLINE> <NL> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if <STRING> in str ( i ) <NEWLINE> <INDENT> print ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT>
n = input ( ) <NEWLINE> x = 1 <NEWLINE> print <STRING> <NEWLINE> while True : <NEWLINE> <INDENT> if x > n : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if ( x % 3 == 0 ) or ( <STRING> in str ( x ) ) : <NEWLINE> <INDENT> print x <NEWLINE> <NL> x = x + 1 <NEWLINE> <DEDENT> <DEDENT>
x = input ( ) <NEWLINE> y = [ ] <NEWLINE> for i in range ( x + 1 ) : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if i % 3 == 0 : <NEWLINE> <INDENT> y . append ( str ( i ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> z = i <NEWLINE> while 1 : <NEWLINE> <INDENT> if z < 10 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> z -= 10 <NEWLINE> <DEDENT> <DEDENT> if z == 3 : <NEWLINE> <INDENT> y . append ( str ( i ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print <STRING> . join ( y ) <NEWLINE>
n = int ( raw_input ( ) ) <NEWLINE> for i in range ( 3 , n + 1 ) : <NEWLINE> <INDENT> if i % 3 == 0 or <STRING> in str ( i ) : <NEWLINE> <INDENT> print <STRING> + str ( i ) , <NEWLINE> <DEDENT> <DEDENT> print <NEWLINE>
n = input ( ) <NEWLINE> <NL> print <STRING> , <NEWLINE> for i in xrange ( 1 , n + 1 ) : <NEWLINE> <INDENT> x = i <NEWLINE> if x % 3 == 0 : <NEWLINE> <INDENT> print i , <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> while x : <NEWLINE> <INDENT> if x % 10 == 3 : <NEWLINE> <INDENT> print i , <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT>
<COMMENT> <NL> <NL> n = input ( ) <NEWLINE> <NL> l = raw_input ( ) . split ( ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> l . append ( i ) <NEWLINE> <NL> <DEDENT> l . reverse ( ) <NEWLINE> <NL> print l <NEWLINE>
input ( ) <NEWLINE> data = input ( ) . split ( ) . reverse ( ) <NEWLINE> data . reverse ( ) <NEWLINE> print ( <STRING> . join ( data ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> print ( * list ( reversed ( map ( int , input ( ) . split ( ) ) ) ) ) <NEWLINE>
n = raw_input ( ) <NEWLINE> a = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> <NL> for i in range ( 0 , n ) : <NEWLINE> <INDENT> print a [ n - i - 1 ] , <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> a = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( <STRING> . join ( sorted ( a , reverse = True ) ) ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = raw_input ( ) <NEWLINE> a = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> print a [ - i - 1 ] , <NEWLINE> <DEDENT>
<COMMENT> <NL> using namespace std ; <NEWLINE> int main ( void ) { <NEWLINE> <NL> <INDENT> int i , n ; <NEWLINE> int x [ 101 ] ; <NEWLINE> <NL> cin >> n ; <NEWLINE> <NL> for ( i = 0 ; i < n ; i + + ) { <NEWLINE> <INDENT> cin >> x [ i ] ; <NEWLINE> <DEDENT> } <NEWLINE> <NL> for ( i = n - 1 ; i >= 0 ; i - - ) { <NEWLINE> <INDENT> if ( i == 0 ) { <NEWLINE> <INDENT> cout << x [ i ] << endl ; <NEWLINE> <DEDENT> } <NEWLINE> else { <NEWLINE> <INDENT> cout << x [ i ] << <STRING> ; <NEWLINE> <DEDENT> } <NEWLINE> <DEDENT> } <NEWLINE> <NL> cout << endl ; <NEWLINE> <NL> return 0 ; <NEWLINE> <DEDENT> } <NEWLINE> <NL>
cnt = int ( input ( ) ) <NEWLINE> li = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> re_li = li [ : : - 1 ] <NEWLINE> print ( <STRING> . join ( map ( int , re_li ) ) ) <NEWLINE> <NL>
n = input ( ) <NEWLINE> int i <NEWLINE> while True : <NEWLINE> <INDENT> if i == n : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> a [ i ] = input ( ) . split <NEWLINE> a [ i ] = a [ n - i ] <NEWLINE> print ( a [ i ] ) <NEWLINE> <DEDENT>
import sys <NEWLINE> n = input ( ) <NEWLINE> m = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> m2 = [ 0 for i in xrange ( n ) ] <NEWLINE> <NL> for i in xrange ( n ) : <NEWLINE> <INDENT> m2 [ n - i - 1 ] = m [ i ] <NEWLINE> <NL> <DEDENT> for i in xrange ( n ) : <NEWLINE> <INDENT> stdout . write ( str ( m2 [ i ] ) ) <NEWLINE> stdout . write ( <STRING> ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <NL> <INDENT> l = input ( ) . split ( ) <NEWLINE> h = int ( l [ 0 ] ) <NEWLINE> w = int ( l [ 1 ] ) <NEWLINE> <NL> if h == 0 and w == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> flag = 0 <NEWLINE> <NL> for i in range ( h * ( w + 1 ) ) : <NEWLINE> <INDENT> if ( i + 1 ) % ( w + 1 ) == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> if w % 2 == 0 : <NEWLINE> <INDENT> flag += 1 <NEWLINE> <DEDENT> if i == h * ( w + 1 ) - 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if flag % 2 == 0 : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> flag += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> flag += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT>
input ( ) <NEWLINE> <NL> data = input . split ( ) <NEWLINE> <NL> data . reverse ( ) <NEWLINE> [ print ( x , end = <STRING> ) for x in data ] <NEWLINE> print ( ) <NEWLINE>
n = raw_input ( ) <NEWLINE> array = raw_input ( ) . split ( ) <NEWLINE> for i in reversed ( range ( n ) ) : <NEWLINE> <INDENT> print i , <NEWLINE> <DEDENT>
input ( ) <NEWLINE> l = raw_input ( ) . split ( ) <NEWLINE> print <STRING> . join ( l [ : : - 1 ] <NEWLINE>
class ReversingNumbers : <NEWLINE> <INDENT> def output ( self , a ) : <NEWLINE> <INDENT> s = <STRING> <NEWLINE> a . reverse ( ) <NEWLINE> for i in range ( len ( a ) - 1 ) : <NEWLINE> <INDENT> s += <STRING> % ( a [ i ] ) <NEWLINE> <DEDENT> s += <STRING> % ( a . index ( len ( a ) - 1 ) ) <NEWLINE> print s <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> rn = ReversingNumbers ( ) <NEWLINE> raw_input ( ) <NEWLINE> a = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> rn . output ( a ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> inp = map ( int , input ( ) . split ( ) ) <NEWLINE> inp . reverse ( ) <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> print ( inp [ i ] , <STRING> , sep = <STRING> , end = <STRING> ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> a = [ input ( ) for i in range ( N ) ] <NEWLINE> <NL> while i > 0 : <NEWLINE> <INDENT> print ( a [ i ] , end = <STRING> ) <NEWLINE> i -= 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( a [ i ] ) <NEWLINE> <DEDENT>
first = input ( ) <NEWLINE> seconds = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> print ( <STRING> . join ( seconds . reverse ( ) ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> n_list = [ int ( i ) for i in input ( ) . split ( <STRING> ) ] <NEWLINE> n_list . reverse ( ) <NEWLINE> print ( <STRING> . join ( map ( str , a ) ) ) <NEWLINE>
input ( ) <NEWLINE> a = input ( ) . split ( ) <NEWLINE> a . reverse ( ) <NEWLINE> print ( <STRING> join ( a ) ) <NEWLINE>
i = input ( ) <NEWLINE> i = int ( i ) <NEWLINE> lis = [ ] <NEWLINE> for j in range ( i ) : <NEWLINE> <INDENT> f = input ( ) <NEWLINE> f = int ( f ) <NEWLINE> lis . append ( f ) <NEWLINE> <NL> <NL> <DEDENT> lis . sort ( reverse = True ) <NEWLINE> print ( lis ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> print ( <STRING> . format ( a [ n - i ] ) , end = <STRING> ) <NEWLINE> <DEDENT> print ( <STRING> . format ( a [ 0 ] ) ) <NEWLINE>
input ( ) <NEWLINE> a = input ( ) . split ( ) <NEWLINE> a . reverse ( ) <NEWLINE> print ( <STRING> / join ( a ) ) <NEWLINE>
num + input ( ) <NEWLINE> jun = input ( ) . split ( ) <NEWLINE> gyaku = reversed ( jun ) <NEWLINE> print ( * gyaku ) <NEWLINE>
put ( ) <NEWLINE> a = input ( ) . split ( ) <NEWLINE> a . reverse ( ) <NEWLINE> print ( <STRING> . join ( a ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> l . reverse ( ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> if i >= 1 : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> print ( a [ i ] , end = <STRING> ) <NEWLINE> <DEDENT> print ( ) <NEWLINE>
input ( ) <NEWLINE> a = input ( ) . split ( ) <NEWLINE> print ( <STRING> . join ( a . reverse ( ) ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> list = [ i for i in input ( ) . split ( ) ] . reverse ( ) <NEWLINE> print ( <STRING> . join ( list ) ) <NEWLINE>
a = [ ] <NEWLINE> for i in range ( input ( ) ) : <NEWLINE> <INDENT> a . append ( input ( ) ) <NEWLINE> <DEDENT> print sorted ( a , reverse = True ) <NEWLINE>
n = int ( input ) <NEWLINE> lst = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> print ( <STRING> . join ( lst [ : : - 1 ] ) ) <NEWLINE>
import sys <NEWLINE> while True : <NEWLINE> <INDENT> n = 0 <NEWLINE> s = sys . stdin . readline ( ) <NEWLINE> if s == <STRING> : break <NEWLINE> for i in range ( len ( s ) - 1 ) : <NEWLINE> <INDENT> n += int ( s [ i ] ) <NEWLINE> <DEDENT> print ( n ) <NEWLINE> <DEDENT>
input ( ) <NEWLINE> l = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> l . reverse ( ) <NEWLINE> print ( <STRING> . join ( map ( str , l ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = a [ : : - 1 ] <NEWLINE> print ( <STRING> . join ( a ) ) <NEWLINE>
n = input ( ) <NEWLINE> lst = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> print <STRING> . join ( lst [ : : - 1 ] ) <NEWLINE>
n = int ( raw_input ( ) ) <NEWLINE> num = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> num . sort ( revers = True ) <NEWLINE> print num <NEWLINE>
n = input ( ) <NEWLINE> a = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> ans = [ ] <NEWLINE> b = <STRING> <NEWLINE> for i in reversed ( a ) : <NEWLINE> <INDENT> ans . append ( i ) <NEWLINE> <DEDENT> for j in range ( n ) : <NEWLINE> <INDENT> b += str ( ans [ j ] ) + <STRING> <NEWLINE> <DEDENT> print b <NEWLINE>
n = int ( input ( ) ) <NEWLINE> print ( <STRING> . join ( input ( ) . split ( ) ) . reveres ( ) ) <NEWLINE>
n = input ( ) <NEWLINE> print ( <STRING> . join ( input ( ) . split ( ) ) . reveres ) <NEWLINE>
n = int ( raw_input ( ) ) <NEWLINE> a = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> a . reverse ( ) <NEWLINE> for i in n : <NEWLINE> <INDENT> print i , <NEWLINE> <DEDENT>
n = int ( input ) <NEWLINE> a = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> for i in range ( n , - 1 , - 1 ) : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> print ( a [ i ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( a [ i ] , end = <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> import math <NEWLINE> <NL> n = input ( ) <NEWLINE> a = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> a . reverse ( ) <NEWLINE> <NL> for i in xrange ( n ) : <NEWLINE> <INDENT> sys . stdout . write ( str ( a [ i ] ) ) <NEWLINE> if i < n - 1 : <NEWLINE> <INDENT> sys . stdout . write ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
a = [ ] <NEWLINE> for _ in range ( int ( input ( ) ) ) : <NEWLINE> <INDENT> a . append ( input ( ) ) <NEWLINE> <DEDENT> a . reverse ( ) <NEWLINE> print ( <STRING> . join ( a ) ) <NEWLINE>
n = input ( ) <NEWLINE> a = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> a . reverse ( ) <NEWLINE> for i in a <NEWLINE> <INDENT> print i <NEWLINE> <DEDENT>
( n , m ) = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> A = [ ] <NEWLINE> b = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> A . append ( [ int ( j ) for j in input ( ) . split ( ) ] ) <NEWLINE> <NL> <DEDENT> for i in ronge ( m ) : <NEWLINE> <INDENT> b . append ( int ( input ( ) ) ) <NEWLINE> <NL> <NL> <DEDENT> for i in range ( n ) : <NEWLINE> m = 0 <NEWLINE> for j in range ( m ) : <NEWLINE> <INDENT> s += A [ j ] [ j ] * b [ j ] <NEWLINE> print ( s ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> n = input ( ) <NEWLINE> a = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> sys . stdout . write ( str ( a [ n - i - 1 ] ) ) <NEWLINE> sys . stdout . write ( <STRING> ) <NEWLINE> <DEDENT> print <NEWLINE>
r = int ( input ( ) ) <NEWLINE> a = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> <NL> a . reverse ( ) <NEWLINE> prnt = <STRING> <NEWLINE> for i in range ( 0 , r - 2 ) : <NEWLINE> <INDENT> prnt += a [ i ] <NEWLINE> prnt += <STRING> <NEWLINE> <NL> <DEDENT> prnt += a [ r - 1 ] <NEWLINE> print prnt <NEWLINE>
<COMMENT> <NL> <NL> x = input ( ) <NEWLINE> a = input ( ) . split ( ) <NEWLINE> a = a [ : : - 1 ] <NEWLINE> for i in range ( len ( a ) ) : <NEWLINE> <INDENT> b += a [ i ] + <STRING> <NEWLINE> <DEDENT> print ( b [ : - 1 ] ) <NEWLINE> <NL>
input ( ) <NEWLINE> line = reverse ( input ( ) . split ( ) ) <NEWLINE> print ( <STRING> . join ( line ) ) <NEWLINE>
import sys <NEWLINE> n = input ( ) <NEWLINE> a = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> sys . stdout . write ( <STRING> % a [ n - i - 1 ] ) <NEWLINE> if i != n - 1 : <NEWLINE> <INDENT> sys . stdout . write ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a . reverse ( ) <NEWLINE> a = list ( map ( str , a ) <NEWLINE> print ( <STRING> . join ( a ) ) <NEWLINE>
input ( ) <NEWLINE> date = input ( ) . split ( ) . <NEWLINE> date . reverse ( ) <NEWLINE> print ( <STRING> . join ( date ) ) <NEWLINE>
input ( ) <NEWLINE> data = input ( ) , split ( ) <NEWLINE> data . reverse ( ) <NEWLINE> print ( <STRING> . join ( data ) ) <NEWLINE>
n = int ( raw_input ( ) ) <NEWLINE> a = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> print a [ n - i ] , <NEWLINE> <DEDENT>
input ( ) <NEWLINE> a = list ( int , input ( ) ) <NEWLINE> print ( a [ : : - 1 ] ) <NEWLINE>
<COMMENT> <NL> n = int ( input ( ) ) <NEWLINE> lst = map ( int , input ( ) . split ( ) ) <NEWLINE> for i in range ( n - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> print ( <STRING> % lst [ i ] , end = <STRING> ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> for i in range ( 1 , n ) : <NEWLINE> <INDENT> print ( str ( a [ - i ] ) + <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> print ( a [ 0 ] ) <NEWLINE>
while True : <NEWLINE> <INDENT> sute = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> num = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> for i in range ( len ( num ) - 1 ) : <NEWLINE> <INDENT> print <STRING> % num [ len ( num ) - i - 1 ] , <NEWLINE> <DEDENT> print num [ 0 ] <NEWLINE> <DEDENT>
<INDENT> input ( ) <NEWLINE> <DEDENT> A = [ i for i in input ( ) . split ( ) ] <NEWLINE> A . reverse ( ) <NEWLINE> print ( <STRING> . join ( A ) ) <NEWLINE>
n = raw_input ( ) . split ( ) <NEWLINE> x = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> <NL> if n == 0 : break <NEWLINE> x . reverse ( ) <NEWLINE> print ( x ) <NEWLINE>
dummy = input ( ) <NEWLINE> print ( <STRING> . join ( input ( ) . split ( ) . reverse ( ) ) ) <NEWLINE>
n = input ( ) <NEWLINE> a = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> for i in range ( len ( a ) - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> print a [ i ] , <NEWLINE> <DEDENT> print <STRING> <NEWLINE> <NL>
n = int ( input ( ) ) <NEWLINE> s = list ( map ( int , input ( ) . strip ( ) . split ( <STRING> ) ) ) <NEWLINE> t = n // 2 <NEWLINE> <NL> for i in range ( 0 , t ) : <NEWLINE> <INDENT> s [ i ] , s [ n - i ] = s [ n - i ] , s [ i ] <NEWLINE> <NL> <DEDENT> for i in range ( 0 , len ( s ) ) : <NEWLINE> <INDENT> if i != len ( s - 1 ) : <NEWLINE> <INDENT> print ( s [ i ] , end = <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( s [ i ] ) <NEWLINE> <NL> <DEDENT> <DEDENT>
p = input ( ) <NEWLINE> n = raw_input ( ) . split ( ) <NEWLINE> n . reverse ( ) <NEWLINE> s = <STRING> <NEWLINE> for i in xrange ( len ( n ) ) : <NEWLINE> <INDENT> s += n [ i ] + <STRING> <NEWLINE> <DEDENT> print s <NEWLINE>
input ( ) <NEWLINE> print ( <STRING> . join ( input ( ) . split ( ) [ : : - 1 ] ) <NEWLINE>
n = input ( ) <NEWLINE> a = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> a . reverse ( ) <NEWLINE> <NL> for i in n : <NEWLINE> <INDENT> print i <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> a = [ input ( ) for i in range ( N ) ] <NEWLINE> <NL> b = [ ] <NEWLINE> j = N - 1 <NEWLINE> <NL> while j >= 0 : <NEWLINE> <INDENT> b . append ( a [ j ] ) <NEWLINE> j -= 1 <NEWLINE> <NL> <DEDENT> print ( b ) <NEWLINE>
n = input ( ) <NEWLINE> a = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> a . reverse ( ) <NEWLINE> print ( <STRING> . join ( a ) ) <NEWLINE>
import sys <NEWLINE> n = input ( ) <NEWLINE> a = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> sys . stdout . write ( str ( a [ n - 1 - i ] ) ) <NEWLINE> if i != n - 1 : <NEWLINE> <INDENT> sys . stdout . write ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a . reverse ( ) <NEWLINE> print ( <STRING> . join ( a ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = [ int ( input ( ) ) for i in range ( n - 1 ) ] <NEWLINE> <NL> for i in ( reversed ( a ) ) : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT>
print ( a [ : : - 1 ] . rsplit ( <STRING> , 1 ) [ 0 ] ) <NEWLINE>
import sys <NEWLINE> n = input ( ) <NEWLINE> a_n = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> j = - 1 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> print ( <STRING> ) , <NEWLINE> sys . stdout . write ( str ( a_n [ j ] ) ) <NEWLINE> j -= 1 <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE>
while True : <NEWLINE> <INDENT> n = int ( raw_input ( ) ) <NEWLINE> m = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> m . sort ( ) <NEWLINE> h = - 1 <NEWLINE> for i in xrange ( n ) : <NEWLINE> <INDENT> print str ( m [ h ] ) , <NEWLINE> h -= 1 <NEWLINE> <DEDENT> print <NEWLINE> <DEDENT>
<COMMENT> <NL> using namespace std ; <NEWLINE> int main ( void ) { <NEWLINE> <INDENT> int n , i , j ; <NEWLINE> <NL> cin >> n ; <NEWLINE> int a [ n ] ; <NEWLINE> <NL> for ( i = 0 ; i < n ; i + + ) { <NEWLINE> <INDENT> cin >> a [ i ] ; <NEWLINE> <DEDENT> } <NEWLINE> <NL> <NL> <NL> for ( j = n - 1 ; j >= 0 ; j - - ) { <NEWLINE> <INDENT> if ( j == 0 ) <NEWLINE> <INDENT> cout << a [ j ] << endl ; <NEWLINE> <DEDENT> else <NEWLINE> <INDENT> cout << a [ j ] << <STRING> ; <NEWLINE> <DEDENT> <DEDENT> } <NEWLINE> <NL> <DEDENT> } <NEWLINE> <NL>
n = raw_input ( ) <NEWLINE> ls = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> ls . reverse ( ) <NEWLINE> for i in range ( len ( ls ) ) : <NEWLINE> <INDENT> print ls [ i ] , <NEWLINE> <DEDENT> print <STRING> <NEWLINE>
n = input ( ) <NEWLINE> a = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> <NL> print <STRING> . format ( a [ : : - 1 ] ) . replace ( <STRING> , <STRING> ) . replace ( <STRING> , <STRING> ) . replace ( <STRING> , <STRING> ) <NEWLINE>
n = input ( ) <NEWLINE> a_list == list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if n == len ( a_list ) : <NEWLINE> <INDENT> r_list = reversed ( a_list ) <NEWLINE> numbers = <STRING> . join ( a_list ) <NEWLINE> print ( numbers ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> n = input ( ) <NEWLINE> ai = raw_input ( ) <NEWLINE> ai = map ( int , ai . split ( ) ) <NEWLINE> <NL> for i in reversed ( range ( 1 , n ) ) : <NEWLINE> <INDENT> sys . stdout . write ( str ( ai [ i ] ) + <STRING> ) <NEWLINE> <DEDENT> print ai [ i - 1 ] <NEWLINE>
class itp1_6a : <NEWLINE> <INDENT> def reverse ( self , n , a ) : <NEWLINE> <INDENT> s = <STRING> <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if i == n + 1 : <NEWLINE> <INDENT> s += str ( a [ - 1 * i ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s += str ( a [ - 1 * i ] ) + <STRING> <NEWLINE> <DEDENT> <DEDENT> print s <NEWLINE> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> n = input ( ) <NEWLINE> a = map ( int , raw_input ( ) . split ( <STRING> ) ) <NEWLINE> run = itp1_6a ( ) <NEWLINE> run . reverse ( n , a ) <NEWLINE> <DEDENT>
n = int ( raw_input ( ) ) <NEWLINE> a = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> a . reverse ( ) <NEWLINE> for i in range ( len ( n ) ) : <NEWLINE> <INDENT> print a <NEWLINE> <DEDENT>
n = int ( raw_input ( ) ) <NEWLINE> <NL> card = { <STRING> : [ 0 ] * 13 , <STRING> : [ 0 ] * 13 , <STRING> : [ 0 ] * 13 , <STRING> : [ 0 ] * 13 } <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> mark , nums = raw_input ( ) . split ( ) <NEWLINE> deck [ mark ] [ int ( nums ) - 1 ] = 1 <NEWLINE> <NL> <DEDENT> for i in [ <STRING> , <STRING> , <STRING> , <STRING> ] : <NEWLINE> <INDENT> for j in range ( 13 ) : <NEWLINE> <INDENT> if deck [ i ] [ j ] == 0 : <NEWLINE> <INDENT> print <STRING> % ( i , j + 1 ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
cardlist = [ [ i for i in range ( 1 , 14 ) ] for j in range ( 4 ) ] <NEWLINE> n = int ( input ( ) ) <NEWLINE> for s in range ( 0 , n ) : <NEWLINE> <INDENT> x , y = ( input ( ) . split ( ) ) <NEWLINE> y = int ( y ) <NEWLINE> if x == <STRING> : <NEWLINE> <INDENT> cardlist [ 0 ] . remove ( y ) <NEWLINE> <DEDENT> elif x == <STRING> : <NEWLINE> <INDENT> cardlist [ 1 ] . remove ( y ) <NEWLINE> <DEDENT> elif x == <STRING> : <NEWLINE> <INDENT> cardlist [ 2 ] . remove ( y ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cardlist [ 3 ] . remove ( y ) <NEWLINE> <DEDENT> <DEDENT> for i in cardlist [ 0 ] : <NEWLINE> <INDENT> print ( <STRING> , z ) <NEWLINE> <DEDENT> for i in cardlist [ 1 ] : <NEWLINE> <INDENT> print ( <STRING> , z ) <NEWLINE> <DEDENT> for i in cardlist [ 2 ] : <NEWLINE> <INDENT> print ( <STRING> , z ) <NEWLINE> <DEDENT> for i in cardlist [ 3 ] : <NEWLINE> <INDENT> print ( <STRING> , z ) <NEWLINE> <NL> <DEDENT>
Cards = [ <NEWLINE> <INDENT> <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> <NEWLINE> <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> <NEWLINE> <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> <NEWLINE> <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> <NEWLINE> <DEDENT> ] <NEWLINE> <NL> n = input ( ) <NEWLINE> <NL> for i in range ( int ( n ) ) : <NEWLINE> <INDENT> rm = input ( ) <NEWLINE> Cards . remove ( rm ) <NEWLINE> <NL> <DEDENT> for i in range ( 52 - int ( n ) ) : <NEWLINE> <INDENT> print ( Cards . pop ( 0 ) ) <NEWLINE> <DEDENT>
cards = [ ] <NEWLINE> symbol = [ <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> for sym in symbol : <NEWLINE> <INDENT> for i in range ( 1 , 14 ) : <NEWLINE> <INDENT> cards . append ( sym + <STRING> + str ( i ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> n = int ( input ( ) ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> cards . remove ( input ( ) ) <NEWLINE> <NL> <DEDENT> for card in cards : <NEWLINE> <INDENT> print ( card ) <NEWLINE> <DEDENT>
all = set ( ) <NEWLINE> for i in [ <STRING> , <STRING> , <STRING> , <STRING> ] : <NEWLINE> <INDENT> for j in range ( 1 , 14 ) : <NEWLINE> <INDENT> all = all . add ( <STRING> . format ( str ( i ) , str ( j ) ) ) <NEWLINE> <DEDENT> <DEDENT> n = input ( ) . split ( ) <NEWLINE> while o < n : <NEWLINE> <INDENT> a = input ( ) . split ( ) <NEWLINE> t += str ( a [ 0 ] ) <NEWLINE> r += str ( a [ 1 ] ) <NEWLINE> o += 1 <NEWLINE> <DEDENT> all2 = set ( ) <NEWLINE> for y in t : <NEWLINE> <INDENT> for u in r : <NEWLINE> <INDENT> all2 = all2 . add ( <STRING> . format ( str ( y ) , str ( u ) ) <NEWLINE> <DEDENT> <DEDENT> print ( all - all2 ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> cards = [ s + <STRING> + str ( i ) for i in range ( 1 , 14 ) ] for s in [ <STRING> , <STRING> , <STRING> , <STRING> ] ] <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> suit , num = input ( ) . split ( <STRING> ) <NEWLINE> if suit == <STRING> : <NEWLINE> <INDENT> cards [ 0 ] [ int ( num ) - 1 ] = 0 <NEWLINE> <DEDENT> elif suit == <STRING> : <NEWLINE> <INDENT> cards [ 1 ] [ int ( num ) - 1 ] = 0 <NEWLINE> <DEDENT> elif suit == <STRING> : <NEWLINE> <INDENT> cards [ 2 ] [ int ( num ) - 1 ] = 0 <NEWLINE> <DEDENT> elif suit == <STRING> : <NEWLINE> <INDENT> cards [ 3 ] [ int ( num ) - 1 ] = 0 <NEWLINE> <DEDENT> <DEDENT> for s in cards : <NEWLINE> <INDENT> for i in s : <NEWLINE> <INDENT> if i != 0 : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
suit = { <STRING> : 0 , <STRING> : 1 , <STRING> : 2 , <STRING> : 3 } <NEWLINE> suit_keys = list ( suit . keys ( ) ) <NEWLINE> deck = [ [ suit_keys [ i ] + <STRING> + str ( j + 1 ) for j in range ( 13 ) ] for i in range ( 4 ) ] <NEWLINE> for _ in range ( int ( input ( ) ) ) : <NEWLINE> <INDENT> card = input ( ) . split ( ) <NEWLINE> deck [ suit [ card [ 0 ] ] ] [ int ( card [ 1 ] ) ] = <STRING> <NEWLINE> <DEDENT> for i in range ( 4 ) : <NEWLINE> <INDENT> for j in deck [ i ] : <NEWLINE> <INDENT> if j != <STRING> : <NEWLINE> <INDENT> print ( j ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
e = [ input ( ) for _ in [ 0 ] * int ( input ( ) ) ] <NEWLINE> for s in <STRING> : <NEWLINE> <INDENT> for r in range ( 1 , 14 ) : <NEWLINE> <INDENT> if <STRING> not in e : print ( s , r ) <NEWLINE> <DEDENT> <DEDENT>
z = input ( ) <NEWLINE> d = { } <NEWLINE> <NL> L = [ <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> for i in L : <NEWLINE> <INDENT> for j in range ( 1 , 14 ) : <NEWLINE> <INDENT> d [ i ] = d . get ( i , [ ] ) + [ str ( j ) ] <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> while 1 : <NEWLINE> <INDENT> x = raw_input ( ) . split ( ) <NEWLINE> if x [ 0 ] == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d [ x [ 0 ] ] . remove ( x [ 1 ] ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> for i in L : <NEWLINE> <INDENT> for j in sorted ( d [ i ] ) : <NEWLINE> <INDENT> print i + <STRING> + j <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> lst = [ ( a , b ) for a in [ <STRING> , <STRING> , <STRING> , <STRING> ] for b in range ( 1 , 14 ) ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a , b = input ( ) . split ( ) <NEWLINE> b = int ( b ) <NEWLINE> lst . remove ( a , b ) <NEWLINE> <DEDENT> for ( a , b ) in lst : <NEWLINE> <INDENT> print ( a , b ) <NEWLINE> <DEDENT>
d = { <STRING> : [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 ] , <NEWLINE> <INDENT> <STRING> : [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 ] , <NEWLINE> <STRING> : [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 ] , <NEWLINE> <STRING> : [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 ] } <NEWLINE> <DEDENT> n = int ( input ( ) ) <NEWLINE> for i in range ( n ) : <NEWLINE> <COMMENT> <NL> <INDENT> N , M = map ( str , data [ i ] [ 0 ] . split ( ) ) <NEWLINE> d [ N ] [ int ( M ) - 1 ] = <STRING> <NEWLINE> <NL> <DEDENT> for j in range ( len ( d ) ) : <NEWLINE> <INDENT> if j == 1 : <NEWLINE> <INDENT> list_d = d [ <STRING> ] <NEWLINE> c = <STRING> <NEWLINE> <DEDENT> elif j == 2 : <NEWLINE> <INDENT> list_d = d [ <STRING> ] <NEWLINE> c = <STRING> <NEWLINE> <DEDENT> elif j == 3 : <NEWLINE> <INDENT> list_d = d [ <STRING> ] <NEWLINE> c = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> list_d = d [ <STRING> ] <NEWLINE> c = <STRING> <NEWLINE> <DEDENT> for i in range ( len ( list_d ) ) : <NEWLINE> <INDENT> if ( list_d [ i ] != <STRING> ) : <NEWLINE> <INDENT> print ( c , list_d [ i ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
Sp = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 ] <NEWLINE> Hu = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 ] <NEWLINE> Cr = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 ] <NEWLINE> Dy = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 ] <NEWLINE> <NL> num = int ( input ( ) ) <NEWLINE> i = 0 <NEWLINE> while i < num : <NEWLINE> <INDENT> suit , n = raw_input ( ) . split <NEWLINE> n = int ( n ) <NEWLINE> if suit == <STRING> : <NEWLINE> <INDENT> Sp [ n - 1 ] = 0 <NEWLINE> <DEDENT> elif suit == <STRING> : <NEWLINE> <INDENT> Hu [ n - 1 ] = 0 <NEWLINE> <DEDENT> elif suit == <STRING> : <NEWLINE> <INDENT> Cr [ n - 1 ] = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> Dy [ n - 1 ] = 0 <NEWLINE> <DEDENT> i += 1 <NEWLINE> <NL> <DEDENT> for i in Sp : <NEWLINE> <INDENT> if i != 0 : <NEWLINE> <INDENT> print <STRING> , i <NEWLINE> <NL> <DEDENT> <DEDENT> for i in Hu : <NEWLINE> <INDENT> if i != 0 : <NEWLINE> <INDENT> print <STRING> , i <NEWLINE> <NL> <DEDENT> <DEDENT> for i in Cr : <NEWLINE> <INDENT> if i != 0 : <NEWLINE> <INDENT> print <STRING> , i <NEWLINE> <NL> <DEDENT> <DEDENT> for i in Dy : <NEWLINE> <INDENT> if i != 0 : <NEWLINE> <INDENT> print <STRING> , i <NEWLINE> <DEDENT> <DEDENT>
r4 = range ( 4 ) <NEWLINE> r13 = range ( 13 ) <NEWLINE> cards = [ [ 0 for i in r13 ] for j in r4 ] <NEWLINE> while True : <NEWLINE> <INDENT> n = input ( ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> s1 , s2 = raw_input ( ) . split ( ) <NEWLINE> s1 = <STRING> . index ( s1 ) <NEWLINE> s2 = int ( s2 ) - 1 <NEWLINE> print s1 , s2 <NEWLINE> cards [ s1 ] [ s2 ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> for j in r4 : <NEWLINE> <INDENT> for i in r13 : <NEWLINE> <INDENT> if cards [ j ] [ i ] == 0 : print <STRING> [ j ] , i + 1 <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> i = 0 <NEWLINE> <NL> card_S = [ ] <NEWLINE> card_H = [ ] <NEWLINE> card_C = [ ] <NEWLINE> card_D = [ ] <NEWLINE> <NL> while i < n : <NEWLINE> <INDENT> mark , num = input ( ) . split ( ) <NEWLINE> if mark == S : <NEWLINE> <INDENT> card_S . append ( int ( num ) ) <NEWLINE> <DEDENT> elif mark == H : <NEWLINE> <INDENT> card_H . append ( int ( num ) ) <NEWLINE> <DEDENT> elif mark == C : <NEWLINE> <INDENT> card_C . append ( int ( num ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> card_D . append ( int ( num ) ) <NEWLINE> <DEDENT> i += 1 <NEWLINE> <NL> <DEDENT> i = 1 <NEWLINE> while i < 14 : <NEWLINE> <INDENT> if not ( i in card_S ) : <NEWLINE> <INDENT> print ( <STRING> + str ( i ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> i = 1 <NEWLINE> while i < 14 : <NEWLINE> <INDENT> if not ( i in card_H ) : <NEWLINE> <INDENT> print ( <STRING> + str ( i ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> i = 1 <NEWLINE> while i < 14 : <NEWLINE> <INDENT> if not ( i in card_C ) : <NEWLINE> <INDENT> print ( <STRING> + str ( i ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> i = 1 <NEWLINE> while i < 14 : <NEWLINE> <INDENT> if not ( i in card_D ) : <NEWLINE> <INDENT> print ( <STRING> + str ( i ) ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> d = { } <COMMENT> <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> card = input ( ) <NEWLINE> d [ card ] = 1 <NEWLINE> <NL> <COMMENT> <NL> <NL> <DEDENT> for c in [ <STRING> , <STRING> , <STRING> , <STRING> ] : <NEWLINE> <INDENT> for n in range ( 1 , 13 ) : <NEWLINE> <INDENT> key = c + <STRING> + str ( n ) <NEWLINE> if not key in cards : <NEWLINE> <INDENT> print ( key ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
S = [ ] <NEWLINE> H = [ ] <NEWLINE> C = [ ] <NEWLINE> D = [ ] <NEWLINE> for i in ( S , H , C , D ) : <NEWLINE> <INDENT> for k in range ( 1 , 13 + 1 ) : <NEWLINE> <INDENT> i . append ( k ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> for u in range ( 0 , int ( input ( ) ) ) : <NEWLINE> <INDENT> x , y = ( i for i in input ( ) . split ( ) ) <NEWLINE> if x == <STRING> : <NEWLINE> <INDENT> S . remove ( int ( y ) ) <NEWLINE> <DEDENT> elif x == <STRING> : <NEWLINE> <INDENT> H . remove ( int ( y ) ) <NEWLINE> <DEDENT> elif x == <STRING> : <NEWLINE> <INDENT> H . remove ( int ( y ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> D . remove ( int ( y ) ) <NEWLINE> <DEDENT> <DEDENT> if len ( S ) > 0 : <NEWLINE> <INDENT> for s in range ( 0 , len ( S ) ) : <NEWLINE> <INDENT> print ( <STRING> , S [ s ] ) <NEWLINE> <DEDENT> <DEDENT> if len ( H ) > 0 : <NEWLINE> <INDENT> for h in range ( 0 , len ( H ) ) : <NEWLINE> <INDENT> print ( <STRING> , H [ h ] ) <NEWLINE> <DEDENT> <DEDENT> if len ( C ) > 0 : <NEWLINE> <INDENT> for c in range ( 0 , len ( C ) ) : <NEWLINE> <INDENT> print ( <STRING> , C [ c ] ) <NEWLINE> <DEDENT> <DEDENT> if len ( D ) > 0 : <NEWLINE> <INDENT> for d in range ( 0 , len ( D ) ) : <NEWLINE> <INDENT> print ( <STRING> , D [ d ] ) <NEWLINE> <DEDENT> <DEDENT>
def main ( ) : <NEWLINE> <NL> <INDENT> deck = set ( ) <NEWLINE> for item in range ( 1 , 14 ) : <NEWLINE> <INDENT> deck = deck | { ( <STRING> + str ( item ) ) } <NEWLINE> deck = deck | { ( <STRING> + str ( item ) ) } <NEWLINE> deck = deck | { ( <STRING> + str ( item ) ) } <NEWLINE> deck = deck | { ( <STRING> + str ( item ) ) } <NEWLINE> <DEDENT> suits_order = [ <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> cards = [ input ( ) for i in range ( n ) ] <NEWLINE> remains = sorted ( sorted ( list ( deck - set ( cards ) ) , key = lambda x : suit_order . index ( x [ : 1 ] ) ) , key = lambda x : int ( x [ 2 : ] ) ) <NEWLINE> for item in remains : <NEWLINE> <INDENT> print ( item ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> main ( ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> k = input ( ) . split ( ) <NEWLINE> if k [ 0 ] == <STRING> : <NEWLINE> <INDENT> for i in range ( 1 , 14 ) : <NEWLINE> <INDENT> if int ( k [ 1 ] ) == i : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s = list ( ) <NEWLINE> s . append ( i ) <NEWLINE> s . sort ( ) <NEWLINE> sl = len ( s ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if k [ 0 ] == <STRING> : <NEWLINE> <INDENT> for i in range ( 1 , 14 ) : <NEWLINE> <INDENT> if int ( k [ 1 ] ) == i : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> h = list ( ) <NEWLINE> h . append ( i ) <NEWLINE> h . sort ( ) <NEWLINE> hl = len ( h ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if k [ 0 ] == <STRING> : <NEWLINE> <INDENT> for i in range ( 1 , 14 ) : <NEWLINE> <INDENT> if int ( k [ 1 ] ) == i : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> c = list ( ) <NEWLINE> c . append ( i ) <NEWLINE> c . sort ( ) <NEWLINE> cl = len ( c ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if k [ 0 ] == <STRING> : <NEWLINE> <INDENT> for i in range ( 1 , 14 ) : <NEWLINE> <INDENT> if int ( k [ 1 ] ) == i : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d = list ( ) <NEWLINE> d . append ( i ) <NEWLINE> d . sort ( ) <NEWLINE> dl = len ( d ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for i in range ( 1 , sl ) : <NEWLINE> <INDENT> print ( <STRING> . format ( s [ i ] ) ) <NEWLINE> <NL> <DEDENT> for i in range ( 1 , hl + 1 ) : <NEWLINE> <INDENT> print ( <STRING> . format ( h [ i ] ) ) <NEWLINE> <NL> <DEDENT> for i in range ( 1 , dl + 1 ) : <NEWLINE> <INDENT> print ( <STRING> . format ( d [ i ] ) ) <NEWLINE> <NL> <DEDENT> for i in range ( 1 , cl + 1 ) : <NEWLINE> <INDENT> print ( <STRING> . format ( c [ i ] ) ) <NEWLINE> <DEDENT>
def to_str ( symbol , num ) : <NEWLINE> <INDENT> return <STRING> . format ( symbol , num ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> symbols = [ <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> cards = [ to_str ( x , y ) for x in symbols for y in range ( 1 , 14 ) ] <NEWLINE> n = int ( input ( ) ) <NEWLINE> if n == 52 : return None <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> cards . remove ( input ( ) ) <NEWLINE> <DEDENT> print ( <STRING> . join ( cards ) ) <NEWLINE> <DEDENT>
n = int ( raw_input ( ) ) <NEWLINE> lst = [ ] <NEWLINE> <COMMENT> <NL> for i in [ <STRING> , <STRING> , <STRING> , <STRING> ] : <NEWLINE> <INDENT> for j in xrange ( 1 , 14 ) : <NEWLINE> <INDENT> lst . append ( <STRING> . format ( ( i , j ) ) <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> for i in xrange ( 0 , n ) : <NEWLINE> <INDENT> a = raw_input ( ) <NEWLINE> lst . remove ( a ) <NEWLINE> <COMMENT> <NL> <DEDENT> for i in lst : <NEWLINE> <INDENT> print i <NEWLINE> <DEDENT>
n = int ( raw_input ( ) ) <NEWLINE> s = range ( 1 , 14 ) <NEWLINE> h = range ( 1 , 14 ) <NEWLINE> c = range ( 1 , 14 ) <NEWLINE> d = range ( 1 , 14 ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> kd , r = raw_input ( ) . split ( ) <NEWLINE> if kd == <STRING> : <NEWLINE> <INDENT> s [ int ( r ) - 1 ] = 0 <NEWLINE> <DEDENT> elif kd == <STRING> : <NEWLINE> <INDENT> h [ int ( r ) - 1 ] = 0 <NEWLINE> <DEDENT> elif kd == <STRING> : <NEWLINE> <INDENT> c [ int ( r ) - 1 ] = 0 <NEWLINE> <DEDENT> elif kd == <STRING> : <NEWLINE> <INDENT> d [ int ( r ) - 1 ] = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> a = <STRING> <NEWLINE> for i in range ( 13 ) : <NEWLINE> <INDENT> if s [ i ] != 0 : <NEWLINE> <INDENT> print a + str ( s [ i ] ) <NEWLINE> <DEDENT> <DEDENT> a = <STRING> <NEWLINE> for i in range ( 13 ) : <NEWLINE> <INDENT> if h [ i ] != 0 : <NEWLINE> <INDENT> print a + str ( h [ i ] ) <NEWLINE> <DEDENT> <DEDENT> a = <STRING> <NEWLINE> for i in range ( 13 ) : <NEWLINE> <INDENT> if c [ i ] != 0 : <NEWLINE> <INDENT> print a + str ( c [ i ] ) <NEWLINE> <DEDENT> <DEDENT> a = <STRING> <NEWLINE> for i in range ( 13 ) : <NEWLINE> <INDENT> if d [ i ] != 0 : <NEWLINE> <INDENT> print a + str ( d [ i ] ) <NEWLINE> <DEDENT> <DEDENT>
n = input ( ) <NEWLINE> <NL> S = range ( 1 , 14 ) <NEWLINE> H = range ( 1 , 14 ) <NEWLINE> C = range ( 1 , 14 ) <NEWLINE> D = range ( 1 , 14 ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> m , k = raw_input ( ) . split ( ) <NEWLINE> if m == <STRING> : <NEWLINE> <INDENT> S [ int ( k ) - 1 ] = 0 <NEWLINE> <DEDENT> elif m == <STRING> : <NEWLINE> <INDENT> H [ int ( k ) - 1 ] = 0 <NEWLINE> <DEDENT> elif m == <STRING> : <NEWLINE> <INDENT> C [ int ( k ) - 1 ] = 0 <NEWLINE> <DEDENT> elif m == <STRING> : <NEWLINE> <INDENT> D [ int ( k ) - 1 ] = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( 0 , 13 ) : <NEWLINE> <INDENT> if S [ i ] != 0 : <NEWLINE> <INDENT> print <STRING> + str ( S [ i ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( 0 , 13 ) : <NEWLINE> <INDENT> if h [ i ] != 0 : <NEWLINE> <INDENT> print <STRING> + str ( H [ i ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( 0 , 13 ) : <NEWLINE> <INDENT> if C [ i ] != 0 : <NEWLINE> <INDENT> print <STRING> + str ( C [ i ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( 0 , 13 ) : <NEWLINE> <INDENT> if d [ i ] != 0 : <NEWLINE> <INDENT> print <STRING> + str ( D [ i ] ) <NEWLINE> <DEDENT> <DEDENT>
cards = { <NEWLINE> <INDENT> <STRING> : [ 0 for - in range ( 13 ) ] , <NEWLINE> <STRING> : [ 0 for - in range ( 13 ) ] , <NEWLINE> <STRING> : [ 0 for - in range ( 13 ) ] , <NEWLINE> <STRING> : [ 0 for - in range ( 13 ) ] , <NEWLINE> <DEDENT> } <NEWLINE> n = int ( input ( ) ) <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> ( s , r ) = input ( ) . split ( ) <NEWLINE> cards [ s ] [ int ( r ) - 1 ] = 1 <NEWLINE> <NL> <DEDENT> for s in ( <STRING> <STRING> <STRING> <STRING> ) : <NEWLINE> <INDENT> ( s , r ) = input ( ) . split ( ) <NEWLINE> cards [ s ] [ int ( r ) + 1 ] = - 1 <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> card = { <STRING> : [ 0 ] * 13 , <STRING> : [ 0 ] * 13 , <STRING> : [ 0 ] * 13 , <STRING> : [ 0 ] * 13 } <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> mark , number = input ( ) . split ( ) <NEWLINE> card [ mark ] [ int ( number ) - 1 ] = 1 <NEWLINE> <NL> <NL> <DEDENT> for a in ( <STRING> , <STRING> , <STRING> , <STRING> ) : <NEWLINE> <INDENT> for b in range ( 13 ) : <NEWLINE> <INDENT> if cards [ a ] [ b ] == 0 : <NEWLINE> <INDENT> print ( a , b + 1 ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> cards = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> s , a = input ( ) . split ( ) <NEWLINE> cards . append ( ( s , a ) ) <NEWLINE> <DEDENT> l = [ ( s , a ) for s in <STRING> and a in range ( 1 , 14 ) and ( s , a ) not in cards ] <NEWLINE> for b in l : <NEWLINE> <INDENT> print ( s + <STRING> + a ) <NEWLINE> <DEDENT>
cardlist = [ [ i for i in range ( 1 , 13 ) ] for j in range ( 4 ) ] <NEWLINE> n = int ( input ( ) ) <NEWLINE> for s in range ( 0 , n ) : <NEWLINE> <INDENT> x , y = map ( str , input ( ) . split ( ) ) <NEWLINE> y = int ( y ) <NEWLINE> if x == <STRING> : <NEWLINE> <INDENT> cardlist [ 0 ] . remove ( y ) <NEWLINE> <DEDENT> elif x == <STRING> : <NEWLINE> <INDENT> cardlist [ 1 ] . remove ( y ) <NEWLINE> <DEDENT> elif x == <STRING> : <NEWLINE> <INDENT> cardlist [ 2 ] . remove ( y ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cardlist [ 3 ] . remove ( y ) <NEWLINE> <DEDENT> <DEDENT> for z in cardlist [ 0 ] : <NEWLINE> <INDENT> print ( <STRING> , z ) <NEWLINE> <DEDENT> for z in cardlist [ 1 ] : <NEWLINE> <INDENT> print ( <STRING> , z ) <NEWLINE> <DEDENT> for z in cardlist [ 2 ] : <NEWLINE> <INDENT> print ( <STRING> , z ) <NEWLINE> <DEDENT> for z in cardlist [ 3 ] : <NEWLINE> <INDENT> print ( <STRING> , z ) <NEWLINE> <DEDENT>
n = int ( raw_input ( ) ) <NEWLINE> <NL> i = 0 <NEWLINE> s = [ ] <NEWLINE> h = [ ] <NEWLINE> c = [ ] <NEWLINE> d = [ ] <NEWLINE> <NL> def order_list ( list ) : <NEWLINE> <INDENT> l = len ( list ) <NEWLINE> for i in xrange ( l ) : <NEWLINE> <INDENT> j = i + 1 <NEWLINE> while j < l : <NEWLINE> <INDENT> if list [ i ] > list [ j ] : <NEWLINE> <INDENT> temp = list [ i ] <NEWLINE> list [ i ] = list [ j ] <NEWLINE> list [ j ] = temp <NEWLINE> <DEDENT> j += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> return list <NEWLINE> <NL> <DEDENT> def not_enough_cards ( mark , list ) : <NEWLINE> <INDENT> list = order_list ( list ) <NEWLINE> i = 0 <NEWLINE> for x in xrange ( 1 , 14 ) : <NEWLINE> <INDENT> if x != list [ i ] : <NEWLINE> <INDENT> print mark + <STRING> + str ( x ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> i += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> while i < n : <NEWLINE> <INDENT> line = raw_input ( ) . split ( <STRING> ) <NEWLINE> line [ 1 ] = int ( line [ 1 ] ) <NEWLINE> if line [ 0 ] == <STRING> : <NEWLINE> <INDENT> s . append ( line [ 1 ] ) <NEWLINE> <DEDENT> elif line [ 0 ] == <STRING> : <NEWLINE> <INDENT> h . append ( line [ 1 ] ) <NEWLINE> <DEDENT> elif line [ 0 ] == <STRING> : <NEWLINE> <INDENT> c . append ( line [ 1 ] ) <NEWLINE> <DEDENT> elif line [ 0 ] == <STRING> : <NEWLINE> <INDENT> d . append ( line [ 1 ] ) <NEWLINE> <DEDENT> i += 1 <NEWLINE> <NL> <DEDENT> not_enough_cards ( <STRING> , s ) <NEWLINE> not_enough_cards ( <STRING> , h ) <NEWLINE> not_enough_cards ( <STRING> , c ) <NEWLINE> not_enough_cards ( <STRING> , d ) <NEWLINE>
n = input ( ) <NEWLINE> d = { } <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> card = input ( ) <NEWLINE> d [ card ] = True <NEWLINE> <NL> <NL> <DEDENT> for c in [ <STRING> , <STRING> , <STRING> , <STRING> ] : <NEWLINE> <INDENT> for i in brange ( 1 , 13 ) : <NEWLINE> <INDENT> card = c + <STRING> + str ( n ) <NEWLINE> if not key in d : <NEWLINE> <INDENT> print ( key ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
card = { <STRING> : [ 0 ] * 13 , <NEWLINE> <INDENT> <STRING> : [ 0 ] * 13 , <NEWLINE> <STRING> : [ 0 ] * 13 , <NEWLINE> <STRING> : [ 0 ] * 13 <NEWLINE> <DEDENT> } <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> <NL> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> m , num = input ( ) . split ( ) <NEWLINE> num = int ( num ) <NEWLINE> card [ m ] [ num - 1 ] = 1 <NEWLINE> <NL> <DEDENT> for c in [ <STRING> , <STRING> , <STRING> , <STRING> ] : <NEWLINE> <INDENT> for j in range ( 1 , 14 ) : <NEWLINE> <INDENT> if ( card [ c ] [ i ] == 0 ) : <NEWLINE> <INDENT> print ( m , str ( j ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
<STRING> <NEWLINE> <NL> <NL> import re <NEWLINE> <NL> <COMMENT> <NL> <NL> n = int ( input ( ) ) <NEWLINE> i = 0 <NEWLINE> while i < n : <NEWLINE> <INDENT> eCard . append ( input ( ) ) <NEWLINE> i += 1 <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> S = [ ] <NEWLINE> H = [ ] <NEWLINE> D = [ ] <NEWLINE> C = [ ] <NEWLINE> <NL> missingS = [ ] <NEWLINE> missingH = [ ] <NEWLINE> missingD = [ ] <NEWLINE> missingC = [ ] <NEWLINE> <NL> <NL> def assortSuit ( s , sc ) : <NEWLINE> <INDENT> i = 0 <NEWLINE> <NL> <COMMENT> <NL> while i < int ( len ( eCard ) ) : <NEWLINE> <INDENT> if re . match ( s , eCard [ i ] ) : <NEWLINE> <INDENT> Smatch = re . search ( <STRING> , eCard [ i ] ) <NEWLINE> sc . append ( int ( Smatch . group ( ) ) ) <COMMENT> <NEWLINE> <DEDENT> i += 1 <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> assortSuit ( <STRING> , S ) <NEWLINE> assortSuit ( <STRING> , H ) <NEWLINE> assortSuit ( <STRING> , D ) <NEWLINE> assortSuit ( <STRING> , C ) <NEWLINE> <NL> def selectMissingCards ( c , mc ) : <NEWLINE> <INDENT> c . sort ( ) <NEWLINE> <COMMENT> <NL> smallerC = 1 <NEWLINE> while smallerC < c [ 0 ] : <NEWLINE> <INDENT> mc . append ( smallerC ) <NEWLINE> smallerC += 1 <NEWLINE> <NL> <NL> <DEDENT> i = 0 <NEWLINE> <NL> while i < len ( c ) - 1 : <NEWLINE> <INDENT> m = c [ i + 1 ] - c [ i ] <NEWLINE> <NL> if m > 1 : <NEWLINE> <INDENT> h = 1 <NEWLINE> while h < m : <NEWLINE> <INDENT> mc . append ( c [ i ] + h ) <NEWLINE> h += 1 <NEWLINE> <DEDENT> <DEDENT> i += 1 <NEWLINE> <DEDENT> largerC = c [ i ] + 1 <NEWLINE> while largerC <= 13 : <NEWLINE> <INDENT> mc . append ( largerC ) <NEWLINE> largerC += 1 <NEWLINE> <NL> <NL> <NL> <DEDENT> <DEDENT> selectMissingCards ( S , missingS ) <NEWLINE> selectMissingCards ( H , missingH ) <NEWLINE> selectMissingCards ( D , missingD ) <NEWLINE> selectMissingCards ( C , missingC ) <NEWLINE> <NL> <STRING> <NEWLINE> <NL> missingCards = [ ] <NEWLINE> <NL> def allMissingCards ( mc , s ) : <NEWLINE> <COMMENT> <NL> <INDENT> i = 0 <NEWLINE> while i < len ( mc ) : <NEWLINE> <INDENT> missingCards . append ( s + str ( mc [ i ] ) ) <NEWLINE> i += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> allMissingCards ( missingS , <STRING> ) <NEWLINE> allMissingCards ( missingH , <STRING> ) <NEWLINE> allMissingCards ( missingD , <STRING> ) <NEWLINE> allMissingCards ( missingC , <STRING> ) <NEWLINE> <NL> <COMMENT> <NL> <NL> i = 0 <NEWLINE> while i < len ( missingCards ) : <NEWLINE> <INDENT> print ( missingCards [ i ] ) <NEWLINE> i += 1 <NEWLINE> <NL> <NL> <NL> <DEDENT> <STRING> <NEWLINE>
n = int ( input ( ) ) <NEWLINE> card = [ ] <NEWLINE> for suit in [ <STRING> , <STRING> , <STRING> , <STRING> ] : <NEWLINE> <INDENT> for rank in list ( map ( str , range ( 1 , 14 ) ) ) : <NEWLINE> <INDENT> card . append ( suit + <STRING> + rank + <STRING> ) <NEWLINE> <DEDENT> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> card . remove ( input ( ) ) <NEWLINE> <DEDENT> for c in card : <NEWLINE> <INDENT> print ( c ) <NEWLINE> <NL> <DEDENT>
n = input ( ) <NEWLINE> s = c = h = d = range ( 1 , 14 ) <NEWLINE> trump = { <STRING> : s , <STRING> : c , <STRING> : h , <STRING> : d } <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> suit , num = raw_input ( ) . split ( ) <NEWLINE> num = int ( num ) <NEWLINE> trump [ suit ] . remove ( num ) <NEWLINE> <DEDENT> for suit in [ <STRING> , <STRING> , <STRING> , <STRING> ] : <NEWLINE> <INDENT> for num in trump [ suit ] : <NEWLINE> <INDENT> print ( <STRING> % ( suit , num ) ) <NEWLINE> <DEDENT> <DEDENT>
r = range <NEWLINE> v = input <NEWLINE> l = [ [ i for i in r ( 1 , 14 ) ] for j in r ( 4 ) ] <NEWLINE> d = { <STRING> : 0 , <STRING> : 1 , <STRING> : 2 , <STRING> : 3 } <NEWLINE> n = { 0 : <STRING> , 1 : <STRING> , 2 : <STRING> , 3 : <STRING> } <NEWLINE> for i in r ( int ( v ( ) ) ) : <NEWLINE> <INDENT> x , y = v ( ) . split ( ) <NEWLINE> l [ d [ x ] ] . remove ( int ( y ) ) <NEWLINE> <DEDENT> for i in l : <NEWLINE> <INDENT> for k in i : <NEWLINE> <INDENT> print ( n [ index ( i ) ] , k ) <NEWLINE> <DEDENT> <DEDENT>
n = input ( ) <NEWLINE> data = [ ] <NEWLINE> a = [ ] <NEWLINE> for i in [ <STRING> , <STRING> , <STRING> , <STRING> ] : <NEWLINE> <INDENT> for j in map ( str , xrange ( 1 , 14 ) ) : <NEWLINE> <INDENT> data . append ( i + j ) <NEWLINE> <DEDENT> <DEDENT> for i in xrange ( n ) : <NEWLINE> <INDENT> data . remove ( raw_input ( ) ) <NEWLINE> <DEDENT> for i in xrange ( len ( data ) ) : <NEWLINE> <INDENT> print data [ i ] <NEWLINE> <DEDENT>
S = [ i + 1 for i in xrange ( 13 ) ] <NEWLINE> H = [ i + 1 for i in xrange ( 13 ) ] <NEWLINE> C = [ i + 1 for i in xrange ( 13 ) ] <NEWLINE> D = [ i + 1 for i in xrange ( 13 ) ] <NEWLINE> <COMMENT> <NL> <NL> n = input ( ) <NEWLINE> for i in xrange ( n ) : <NEWLINE> <INDENT> c , a = raw_input ( ) . split ( ) <NEWLINE> if c == <STRING> : <NEWLINE> <INDENT> del S [ int ( a ) - 1 ] <NEWLINE> <DEDENT> elif c == <STRING> : <NEWLINE> <INDENT> del H [ int ( a ) - 1 ] <NEWLINE> <DEDENT> elif c == <STRING> : <NEWLINE> <INDENT> del C [ int ( a ) - 1 ] <NEWLINE> <DEDENT> elif c == <STRING> : <NEWLINE> <INDENT> del D [ int ( a ) - 1 ] <NEWLINE> <NL> <DEDENT> <DEDENT> for i in xrange ( len ( S ) ) : <NEWLINE> <INDENT> print <STRING> + str ( S [ i ] ) <NEWLINE> <NL> <DEDENT> for i in xrange ( len ( H ) ) : <NEWLINE> <INDENT> print <STRING> + str ( H [ i ] ) <NEWLINE> <NL> <DEDENT> for i in xrange ( len ( C ) ) : <NEWLINE> <INDENT> print <STRING> + str ( C [ i ] ) <NEWLINE> <NL> <DEDENT> for i in xrange ( len ( D ) ) : <NEWLINE> <INDENT> print <STRING> + str ( D [ i ] ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> using namespace std ; <NEWLINE> <NL> int main ( ) { <NEWLINE> <INDENT> int n , card [ 13 * 4 ] = { 0 } ; <NEWLINE> <NL> cin >> n ; <NEWLINE> for ( int i = 0 ; i < n ; i + + ) { <NEWLINE> <INDENT> char s ; <NEWLINE> int r ; <NEWLINE> cin >> s >> r ; <NEWLINE> switch ( s ) { <NEWLINE> <INDENT> case <STRING> : card [ 13 * 0 + r - 1 ] = 1 ; break ; <NEWLINE> case <STRING> : card [ 13 * 1 + r - 1 ] = 1 ; break ; <NEWLINE> case <STRING> : card [ 13 * 2 + r - 1 ] = 1 ; break ; <NEWLINE> case <STRING> : card [ 13 * 3 + r - 1 ] = 1 ; break ; <NEWLINE> <DEDENT> } <NEWLINE> <DEDENT> } <NEWLINE> <NL> for ( int i = 0 ; i < 13 * 4 ; i + + ) { <NEWLINE> <INDENT> if ( card [ i ] > 0 ) { <NEWLINE> <INDENT> if ( i < 13 * 1 ) cout << <STRING> ; <NEWLINE> else if ( i < 13 * 2 ) cout << <STRING> ; <NEWLINE> else if ( i < 13 * 3 ) cout << <STRING> ; <NEWLINE> else cout << <STRING> ; <NEWLINE> cout << i % 13 + 1 << endl ; <NEWLINE> <DEDENT> } <NEWLINE> <DEDENT> } <NEWLINE> <NL> return 0 ; <NEWLINE> <DEDENT> } <NEWLINE>
cardset = [ <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> n = input ( ) <NEWLINE> while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> cardset . remove ( str ( input ( ) ) ) <NEWLINE> <DEDENT> except ValueError : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> for x in cardset : <NEWLINE> <INDENT> print ( x ) <NEWLINE> <NL> <DEDENT>
cards = { <NEWLINE> <INDENT> <STRING> : [ r for f in range ( 1 , 13 + 1 ) ] , <NEWLINE> <STRING> : [ r for f in range ( 1 , 13 + 1 ) ] , <NEWLINE> <STRING> : [ r for f in range ( 1 , 13 + 1 ) ] , <NEWLINE> <STRING> : [ r for f in range ( 1 , 13 + 1 ) ] , <NEWLINE> } <NEWLINE> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> for nc in range ( n ) : <NEWLINE> <INDENT> ( s , r ) = input ( ) . split ( ) <NEWLINE> index = cards [ s ] . index ( int ( r ) ) <NEWLINE> del cards [ s ] [ index ] <NEWLINE> <NL> <DEDENT> for s in [ <STRING> , <STRING> , <STRING> , <STRING> ] : <NEWLINE> <INDENT> for r in cards [ s ] : <NEWLINE> <INDENT> print ( s , r ) <NEWLINE> <DEDENT> <DEDENT>
l = [ x + <STRING> + y for x in [ <STRING> , <STRING> , <STRING> , <STRING> ] for y in [ str ( i ) for i in range ( 1 , 14 ) ] ] <NEWLINE> n = int ( input ( ) ) <NEWLINE> while n > 0 : <NEWLINE> <INDENT> l . remove ( input ( ) ) <NEWLINE> n += 1 <NEWLINE> <DEDENT> for i in l : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT>
47 <NEWLINE> S 10 <NEWLINE> S 11 <NEWLINE> S 12 <NEWLINE> S 13 <NEWLINE> H 1 <NEWLINE> H 2 <NEWLINE> S 6 <NEWLINE> S 7 <NEWLINE> S 8 <NEWLINE> S 9 <NEWLINE> H 6 <NEWLINE> H 8 <NEWLINE> H 9 <NEWLINE> H 10 <NEWLINE> H 11 <NEWLINE> H 4 <NEWLINE> H 5 <NEWLINE> S 2 <NEWLINE> S 3 <NEWLINE> S 4 <NEWLINE> S 5 <NEWLINE> H 12 <NEWLINE> H 13 <NEWLINE> C 1 <NEWLINE> C 2 <NEWLINE> D 1 <NEWLINE> D 2 <NEWLINE> D 3 <NEWLINE> D 4 <NEWLINE> D 5 <NEWLINE> D 6 <NEWLINE> D 7 <NEWLINE> C 3 <NEWLINE> C 4 <NEWLINE> C 5 <NEWLINE> C 6 <NEWLINE> C 7 <NEWLINE> C 8 <NEWLINE> C 9 <NEWLINE> C 10 <NEWLINE> C 11 <NEWLINE> C 13 <NEWLINE> D 9 <NEWLINE> D 10 <NEWLINE> D 11 <NEWLINE> D 12 <NEWLINE> D 13 <NEWLINE>
a = int ( input ( ) ) <NEWLINE> b = [ ] <NEWLINE> S = [ ] <NEWLINE> H = [ ] <NEWLINE> C = [ ] <NEWLINE> D = [ ] <NEWLINE> check = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 ] <NEWLINE> for i in range ( a ) : <NEWLINE> <INDENT> b . append ( input ( ) . split ( ) ) <NEWLINE> <DEDENT> for i in range ( len ( b ) ) : <NEWLINE> <INDENT> if b [ i ] [ 0 ] == <STRING> : <NEWLINE> <INDENT> S . append ( int ( b [ i ] [ 1 ] ) ) <NEWLINE> <DEDENT> elif b [ i ] [ 0 ] == <STRING> : <NEWLINE> <INDENT> H . append ( int ( b [ i ] [ 1 ] ) ) <NEWLINE> <DEDENT> elif b [ i ] [ 0 ] == <STRING> : <NEWLINE> <INDENT> C . append ( int ( b [ i ] [ 1 ] ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> D . append ( int ( b [ i ] [ 1 ] ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> set_S = list ( set ( check ) - set ( S ) ) . sort ( ) <NEWLINE> set_H = list ( set ( check ) - set ( H ) ) . sort ( ) <NEWLINE> set_C = list ( set ( check ) - set ( C ) ) . sort ( ) <NEWLINE> set_D = list ( set ( check ) - set ( D ) ) . sort ( ) <NEWLINE> <NL> for i in set_S : <NEWLINE> <INDENT> print ( <STRING> , i ) <NEWLINE> <DEDENT> for i in set_H : <NEWLINE> <INDENT> print ( <STRING> , i ) <NEWLINE> <DEDENT> for i in set_C : <NEWLINE> <INDENT> print ( <STRING> , i ) <NEWLINE> <DEDENT> for i in set_D : <NEWLINE> <INDENT> print ( <STRING> , i ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> cards = { } <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> card = input ( ) <NEWLINE> cards [ card ] = 1 <NEWLINE> <NL> <DEDENT> for c in [ <STRING> , <STRING> , <STRING> , <STRING> ] : <NEWLINE> <INDENT> for n in range ( 1 , 14 ) : <NEWLINE> <INDENT> card = c + <STRING> + str ( n ) <NEWLINE> if not key in cards : <NEWLINE> <INDENT> print ( key ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
<COMMENT> <NL> <NL> import sys <NEWLINE> <NL> <NL> def init_card_deck ( ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <INDENT> card_deck = { <STRING> : [ ] , <STRING> : [ ] , <STRING> : [ ] , <STRING> : [ ] } <NEWLINE> n = int ( sys . stdin . readline ( ) ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> lst = [ card for card in sys . stdin . readline ( ) . split ( ) ] <NEWLINE> card_deck [ lst [ 0 ] ] . append ( lst [ 1 ] ) <NEWLINE> <NL> <DEDENT> return card_deck <NEWLINE> <NL> <NL> <DEDENT> def print_missing_cards ( card_deck ) : <NEWLINE> <INDENT> card_symbols = [ <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> missing_cards = <STRING> <NEWLINE> <NL> for i in card_symbols : <NEWLINE> <INDENT> for card in range ( 1 , 14 ) : <NEWLINE> <INDENT> if not str ( card ) in card_deck [ i ] : <NEWLINE> <INDENT> print ( i , card ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <INDENT> print ( find_missing_cards ( init_card_deck ( ) ) ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = input ( ) <NEWLINE> lst = [ ( a , b ) for a in [ <STRING> , <STRING> , <STRING> , <STRING> ] for b in range ( 1 , 14 ) ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a , b = input ( ) . split ( ) <NEWLINE> lst . remove ( ( a , int ( b ) ) ) <NEWLINE> <DEDENT> for ( a , b ) in lst : <NEWLINE> <INDENT> print ( a , b ) <NEWLINE> <DEDENT>
import sys <NEWLINE> slist = [ i for i in range ( 1 , 14 ) ] <NEWLINE> hlist = [ i for i in range ( 1 , 14 ) ] <NEWLINE> clist = [ i for i in range ( 1 , 14 ) ] <NEWLINE> dlist = [ i for i in range ( 1 , 14 ) ] <NEWLINE> for line in sys . stdin : <NEWLINE> <INDENT> suit , rank = line . split ( ) <NEWLINE> rankn = int ( rank ) <NEWLINE> if suit = <STRING> : <NEWLINE> <INDENT> if rankn in slist : <NEWLINE> <INDENT> slist . pop ( rankn - 1 ) <NEWLINE> <DEDENT> <DEDENT> elif suit = <STRING> : <NEWLINE> <INDENT> if rankn in hlist : <NEWLINE> <INDENT> hlist . pop ( rankn - 1 ) <NEWLINE> <DEDENT> <DEDENT> elif suit = <STRING> : <NEWLINE> <INDENT> if rankn in clist : <NEWLINE> <INDENT> clist . pop ( rankn - 1 ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if rankn in dlist : <NEWLINE> <INDENT> dlist . pop ( rankn - 1 ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
s = [ i + 1 for i in range ( 13 ) ] <NEWLINE> h = [ i + 1 for i in range ( 13 ) ] <NEWLINE> c = [ i + 1 for i in range ( 13 ) ] <NEWLINE> d = [ i + 1 for i in range ( 13 ) ] <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> for cnt in range ( n ) <NEWLINE> <INDENT> e , n = input ( ) . split ( ) <NEWLINE> if e == <STRING> : s [ int ( n ) - 1 ] = 0 <NEWLINE> elif e == <STRING> : h [ int ( n ) - 1 ] = 0 <NEWLINE> elif e == <STRING> : c [ int ( n ) - 1 ] = 0 <NEWLINE> elif e == <STRING> : d [ int ( n ) - 1 ] = 0 <NEWLINE> <NL> <DEDENT> for i in s : <NEWLINE> <INDENT> if i != 0 : print ( <STRING> + repr ( i ) ) <NEWLINE> <DEDENT> for i in h : <NEWLINE> <INDENT> if i != 0 : print ( <STRING> + repr ( i ) ) <NEWLINE> <DEDENT> for i in c : <NEWLINE> <INDENT> if i != 0 : print ( <STRING> + repr ( i ) ) <NEWLINE> <DEDENT> for i in d : <NEWLINE> <INDENT> if i != 0 : print ( <STRING> + repr ( i ) ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> cards = [ <STRING> . format ( type , order ) for type in ( <STRING> , <STRING> , <STRING> , <STRING> ) for order in range ( 1 , 14 ) ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> card = input ( ) <NEWLINE> cards . remove ( card ) <NEWLINE> <DEDENT> for rest in cards <NEWLINE> <INDENT> print ( rest ) <NEWLINE> <DEDENT>
n = input ( ) <NEWLINE> d = { <STRING> : [ none ] * 13 , <STRING> : [ none ] * 13 , <STRING> : [ none ] * 13 , <STRING> : [ none ] * 13 } <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> x , y = raw_input ( ) . split ( ) <NEWLINE> d [ x ] [ int ( y ) - 1 ] = True <NEWLINE> <NL> <DEDENT> for k in [ <STRING> , <STRING> , <STRING> , <STRING> ] : <NEWLINE> <INDENT> for i in range ( 13 ) : <NEWLINE> <INDENT> if d [ k ] [ i ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> print ( <STRING> % ( k , i + 1 ) ) <NEWLINE> <DEDENT> <DEDENT>
n = input ( ) <NEWLINE> a = [ raw_input ( ) for _ in range ( n ) ] <NEWLINE> b = [ ] <NEWLINE> for i in [ <STRING> , <STRING> , <STRING> , <STRING> ] : <NEWLINE> <INDENT> for j in range ( 1 , 14 ) : <NEWLINE> <INDENT> b . append ( i + str ( j ) ) <NEWLINE> <DEDENT> <DEDENT> for i in a : <NEWLINE> <INDENT> b . remove ( i ) <NEWLINE> <DEDENT> print <STRING> . join ( b ) <NEWLINE>
n = input ( ) ; a = [ ] ; b = <STRING> <NEWLINE> for i in range ( 4 * 13 ) : a . append ( b [ i / 13 ] + <STRING> + str ( i % 13 + 1 ) ) <NEWLINE> for i in range ( n ) : a . remove ( raw_input ( ) ) <NEWLINE> for i in c : print i <NEWLINE>
suit = { <STRING> : 0 , <STRING> : 1 , <STRING> : 2 , <STRING> : 3 } <NEWLINE> suit_keys = list ( suit . keys ( ) ) <NEWLINE> deck = [ [ suit_keys [ i ] + <STRING> + str ( j + 1 ) for j in range ( 13 ) ] for i in range ( 4 ) ] <NEWLINE> for _ in range ( int ( input ( ) ) ) : <NEWLINE> <INDENT> card = input ( ) . split ( ) <NEWLINE> del deck [ suit [ card [ 0 ] ] ] [ int ( card [ 1 ] ) - 1 ] <NEWLINE> <DEDENT> for i in range ( 4 ) : <NEWLINE> <INDENT> for j in deck [ i ] : <NEWLINE> <INDENT> print ( j ) <NEWLINE> <NL> <DEDENT> <DEDENT>
a = [ ] ; n = input ( ) <NEWLINE> for i in range ( 52 ) : <NEWLINE> <INDENT> a . append ( <STRING> [ i / 13 ] + <STRING> + str ( i % 13 + 1 ) ) <NEWLINE> if i < n : a . remove ( raw_input ( ) ) <NEWLINE> <DEDENT> for i in a : print i <NEWLINE>
n = int ( input ( ) ) <NEWLINE> cards = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> s , r = input ( ) . split ( ) <NEWLINE> cards . append ( ( s , int ( r ) ) ) <NEWLINE> <DEDENT> for s , r in [ ( s , r ) for s in <STRING> for r in range ( 1 , 14 ) if not in cards ] : <NEWLINE> <INDENT> print ( s , r ) <NEWLINE> <DEDENT>
n = input ( ) <NEWLINE> S = [ <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> H = [ <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> C = [ <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> D = [ <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> cards [ S , H , C , D ] <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> x = raw_input ( ) <NEWLINE> if <STRING> in x : <NEWLINE> <INDENT> cards [ 0 ] . remove ( x ) <NEWLINE> <DEDENT> if <STRING> in x : <NEWLINE> <INDENT> cards [ 1 ] . remove ( x ) <NEWLINE> <DEDENT> if <STRING> in x : <NEWLINE> <INDENT> cards [ 2 ] . remove ( x ) <NEWLINE> <DEDENT> if <STRING> in x : <NEWLINE> <INDENT> cards [ 3 ] . remove ( x ) <NEWLINE> <NL> <DEDENT> <DEDENT> for j in range ( 4 ) : <NEWLINE> <INDENT> for i in cards [ j ] : <NEWLINE> <INDENT> print i <NEWLINE> <DEDENT> <DEDENT>
card = [ ] <NEWLINE> suit = [ <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> for s in suit : <NEWLINE> <INDENT> for i in range ( 1 , 14 ) : <NEWLINE> <INDENT> card . append ( s + <STRING> + str ( i ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> n = int ( input ( ) ) <NEWLINE> for i in range ( n ) <NEWLINE> <INDENT> card . remove ( input ( ) ) <NEWLINE> <NL> <DEDENT> for c in card : <NEWLINE> <INDENT> print ( c ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> x = int ( input ( ) ) <NEWLINE> a = 0 <NEWLINE> s = 0 <NEWLINE> h = 0 <NEWLINE> c = 0 <NEWLINE> d = 0 <NEWLINE> lists = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 ] <NEWLINE> listh = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 ] <NEWLINE> listc = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 ] <NEWLINE> listd = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 ] <NEWLINE> <NL> while a < x : <NEWLINE> <INDENT> l = raw_input ( ) . split ( ) <NEWLINE> a += 1 <NEWLINE> m = l [ 0 ] <NEWLINE> n = int ( l [ 1 ] ) <NEWLINE> <NL> if m == <STRING> : <NEWLINE> <INDENT> s += 1 <NEWLINE> lists . remove ( n ) <NEWLINE> <DEDENT> if m == <STRING> : <NEWLINE> <INDENT> h += 1 <NEWLINE> listh . remove ( n ) <NEWLINE> <DEDENT> if m == <STRING> : <NEWLINE> <INDENT> c += 1 <NEWLINE> listc . remove ( n ) <NEWLINE> <DEDENT> if m == <STRING> : <NEWLINE> <INDENT> d += 1 <NEWLINE> listd . remove ( n ) <NEWLINE> <NL> <DEDENT> <DEDENT> for ss in lists : <NEWLINE> <INDENT> print <STRING> <STRING> % ss <NEWLINE> <DEDENT> for hh in listh : <NEWLINE> <INDENT> print <STRING> <STRING> % hh <NEWLINE> <DEDENT> for cc in listc : <NEWLINE> <INDENT> print <STRING> <STRING> % cc <NEWLINE> <DEDENT> for dd in listd : <NEWLINE> <INDENT> print <STRING> <STRING> % dd <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> n = int ( input ( ) ) <NEWLINE> s = [ ] <NEWLINE> h = [ ] <NEWLINE> c = [ ] <NEWLINE> d = [ ] <NEWLINE> <NL> for i in range ( 13 ) : <NEWLINE> <INDENT> s . append ( i + 1 ) <NEWLINE> h . append ( i + 1 ) <NEWLINE> c . append ( i + 1 ) <NEWLINE> d . append ( i + 1 ) <NEWLINE> <NL> <DEDENT> for j in range ( n ) : <NEWLINE> <INDENT> x = list ( input ( ) . split ( ) ) <NEWLINE> if x [ 0 ] is <STRING> : <NEWLINE> <INDENT> s . remove ( int ( x [ 1 ] ) ) <NEWLINE> <DEDENT> elif x [ 0 ] is <STRING> : <NEWLINE> <INDENT> h . remove ( int ( x [ 1 ] ) ) <NEWLINE> <DEDENT> elif x [ 0 ] is <STRING> : <NEWLINE> <INDENT> c . remove ( int ( x [ 1 ] ) ) <NEWLINE> <DEDENT> elif x [ 0 ] is <STRING> : <NEWLINE> <INDENT> d . remove ( int ( x [ 1 ] ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> if len ( s ) != 0 : <NEWLINE> <INDENT> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> print ( <STRING> . format ( <STRING> , s [ i ] ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> if len ( h ) != 0 : <NEWLINE> <INDENT> for i in range ( len ( h ) ) : <NEWLINE> <INDENT> print ( <STRING> . format ( <STRING> , h [ i ] ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> if len ( c ) != 0 : <NEWLINE> <INDENT> for i in range ( len ( c ) ) : <NEWLINE> <INDENT> print ( <STRING> . format ( <STRING> , c [ i ] ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> while len ( d ) != 0 : <NEWLINE> <INDENT> for i in range ( len ( d ) ) : <NEWLINE> <INDENT> print ( <STRING> . format ( <STRING> , d [ i ] ) ) <NEWLINE> <DEDENT> <DEDENT>
n = input ( ) <NEWLINE> x = { <STRING> : [ ] , <STRING> : [ ] , <STRING> : [ ] , <STRING> : [ ] } <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a = raw_input ( ) . split ( ) <NEWLINE> x [ a [ 0 ] ] . append ( int ( a [ 1 ] ) ) <NEWLINE> <DEDENT> for key in [ <STRING> , <STRING> , <STRING> , <STRING> ] : <NEWLINE> <INDENT> for i in range ( 13 ) : <NEWLINE> <INDENT> for j in x [ key ] : <NEWLINE> <INDENT> if i + 1 == j : break <NEWLINE> <DEDENT> else : print key , i + 1 <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> <NL> import sys <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <INDENT> card_deck = { <STRING> : [ ] , <STRING> : [ ] , <STRING> : [ ] , <STRING> : [ ] } <NEWLINE> card_symbols = [ <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> <NL> lst = [ card for card in sys . stdin . readline ( ) . split ( ) ] <NEWLINE> card_deck [ lst [ 0 ] ] . append ( lst [ 1 ] ) <NEWLINE> <NL> for key , value in card_deck . items ( ) : <NEWLINE> <INDENT> card_deck [ key ] . sort ( ) <NEWLINE> <NL> <DEDENT> for i in card_symbols : <NEWLINE> <INDENT> for card in range ( 1 , 13 ) : <NEWLINE> <INDENT> if not str ( card ) in card_deck [ i ] : <NEWLINE> <INDENT> print ( i , card ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
cards = { <NEWLINE> <INDENT> <STRING> : [ 0 for _ in range ( 13 ) ] , <NEWLINE> <STRING> : [ 0 for _ in range ( 13 ) ] , <NEWLINE> <STRING> : [ 0 for _ in range ( 13 ) ] , <NEWLINE> <STRING> : [ 0 for _ in range ( 13 ) ] , <NEWLINE> <DEDENT> } <NEWLINE> n = int ( input ( ) ) <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> ( s , r ) = input . ( ) . split ( ) <NEWLINE> cards [ s ] [ int ( r ) - 1 ] = 1 <NEWLINE> <NL> <DEDENT> for s in ( <STRING> , <STRING> , <STRING> , <STRING> , ) : <NEWLINE> <INDENT> for r in range ( 13 ) : <NEWLINE> <INDENT> if cards [ s ] [ r ] == 0 : <NEWLINE> <INDENT> print ( s , r + 1 ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
cards = [ ] <NEWLINE> for s in [ <STRING> , <STRING> , <STRING> , <STRING> ] : <NEWLINE> <INDENT> for n in range ( 1 , 14 , 1 ) : <NEWLINE> <INDENT> cards += [ <STRING> % ( s , n ) ] <NEWLINE> <NL> <DEDENT> <DEDENT> input_cards = [ ] <NEWLINE> input_cards = raw_input ( ) <NEWLINE> while True : <NEWLINE> <INDENT> input_card = raw_input ( ) <NEWLINE> cards . remove ( input_card ) <NEWLINE> <NL> for card in cards : <NEWLINE> <INDENT> print ( card ) <NEWLINE> <DEDENT> <DEDENT>
data = [ <NEWLINE> <INDENT> <STRING> . format ( s , r ) <NEWLINE> for s in ( <STRING> , <STRING> , <STRING> , <STRING> ) <NEWLINE> for r in range ( 1 , 13 , + 1 ) <NEWLINE> ] <NEWLINE> <NL> <DEDENT> count = int ( input ( ) ) <NEWLINE> for c in range ( count ) : <NEWLINE> <INDENT> card = input ( ) <NEWLINE> data . remove ( card ) <NEWLINE> <NL> <DEDENT> for c in data : <NEWLINE> <INDENT> print ( c ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> s = [ input ( ) for i in range ( N ) ] <NEWLINE> lost_list = [ ] <NEWLINE> taro_card = [ ] <NEWLINE> card_list = [ ] <NEWLINE> for i in s : <NEWLINE> <INDENT> taro_card . append ( s . split ( ) ) <NEWLINE> <DEDENT> for i in range ( 1 , 14 ) : <NEWLINE> <INDENT> card_list . append ( [ <STRING> , str ( i ) ] ) <NEWLINE> card_list . append ( [ <STRING> , str ( i ) ] ) <NEWLINE> card_list . append ( [ <STRING> , str ( i ) ] ) <NEWLINE> card_list . append ( [ <STRING> , str ( i ) ] ) <NEWLINE> <DEDENT> for i in taro_card : <NEWLINE> <INDENT> if i not in card_list : <NEWLINE> <INDENT> lost_list . append ( i ) <NEWLINE> <DEDENT> <DEDENT> for i in lost_list : <NEWLINE> <INDENT> print ( <STRING> . format ( i [ 0 ] , i [ 1 ] ) ) <NEWLINE> <DEDENT>
S = [ ] <NEWLINE> H = [ ] <NEWLINE> C = [ ] <NEWLINE> D = [ ] <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> mark , num = [ x for x in input ( ) . split ( ) ] <NEWLINE> if mark == <STRING> : <NEWLINE> <INDENT> S . append ( int ( num ) ) <NEWLINE> <NL> <DEDENT> elif mark == <STRING> : <NEWLINE> <INDENT> H . append ( int ( num ) ) <NEWLINE> <NL> <DEDENT> elif mark == <STRING> : <NEWLINE> <INDENT> C . append ( int ( num ) ) <NEWLINE> <NL> <DEDENT> else : <COMMENT> <NEWLINE> <INDENT> D . append ( int ( num ) ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> for i in range ( 1 , 14 ) : <NEWLINE> <INDENT> if not i in S : <NEWLINE> <INDENT> print ( <STRING> , i ) <NEWLINE> <DEDENT> <DEDENT> for i in range ( 1 , 14 ) : <NEWLINE> <INDENT> if not i in H : <NEWLINE> <INDENT> print ( <STRING> , i ) for i in range ( 1 , 14 ) : <NEWLINE> <DEDENT> <DEDENT> for i in range ( 1 , 14 ) : <NEWLINE> <INDENT> if not i in C : <NEWLINE> <INDENT> print ( <STRING> , i ) for i in range ( 1 , 14 ) : <NEWLINE> <DEDENT> <DEDENT> for i in range ( 1 , 14 ) : <NEWLINE> <INDENT> if not i in D : <NEWLINE> <INDENT> print ( <STRING> , i ) <NEWLINE> <DEDENT> <DEDENT>
l = [ ] <NEWLINE> <NL> for x in [ <STRING> , <STRING> , <STRING> , <STRING> ] : <NEWLINE> <INDENT> for y in [ str ( i + 1 ) for i in range ( 13 ) ] : <NEWLINE> <INDENT> l += [ x + <STRING> + y ] <NEWLINE> <NL> <DEDENT> <DEDENT> for n in range ( int ( input ( ) ) : <NEWLINE> <INDENT> l . remove ( input ( ) ) <NEWLINE> <DEDENT> for i in l : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> a = [ input ( ) . split ( ) for i in range ( N ) ] <NEWLINE> Set = { } <NEWLINE> n = list ( range ( 1 , 14 ) ) <NEWLINE> Set [ <STRING> ] = n . copy ( ) <NEWLINE> Set [ <STRING> ] = n . copy ( ) <NEWLINE> Set [ <STRING> ] = n . copy ( ) <NEWLINE> Set [ <STRING> ] = n . copy ( ) <NEWLINE> <NL> for suit , num in a : <NEWLINE> <INDENT> Set [ suit ] . remove ( num ) <NEWLINE> <NL> <DEDENT> for i in Set [ <STRING> ] : <NEWLINE> <INDENT> print ( <STRING> . format ( i ) ) <NEWLINE> <DEDENT> for i in Set [ <STRING> ] : <NEWLINE> <INDENT> print ( <STRING> . format ( i ) ) <NEWLINE> <DEDENT> for i in Set [ <STRING> ] : <NEWLINE> <INDENT> print ( <STRING> . format ( i ) ) <NEWLINE> <DEDENT> for i in Set [ <STRING> ] : <NEWLINE> <INDENT> print ( <STRING> . format ( i ) ) <NEWLINE> <DEDENT>
a = { } <NEWLINE> for s in [ <STRING> , <STRING> , <STRING> , <STRING> ] : <NEWLINE> <INDENT> a . update ( { <STRING> : 0 for i in range ( 1 , 14 ) } ) <NEWLINE> <DEDENT> n = int ( input ( ) ) <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> print ( s ) <NEWLINE> del a [ s ] <NEWLINE> <NL> <DEDENT> a = list ( a ) <NEWLINE> for i in len ( a ) : <NEWLINE> <INDENT> print ( a [ i ] ) <NEWLINE> <NL> <NL> <NL> <NL> <DEDENT>
suits = { <STRING> : 0 , <STRING> : 1 , <STRING> : 2 , <STRING> : 3 } <NEWLINE> cards = [ [ 0 for i2 in range ( 13 ) ] for i1 in ( <STRING> , <STRING> , <STRING> , <STRING> ) ] <NEWLINE> n = int ( input ( ) ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> ( suit , rank ) = input ( ) . split ( <STRING> ) <NEWLINE> cards [ suits [ suit ] ] [ int ( rank ) ] = 1 <NEWLINE> <NL> <DEDENT> for suit in ( <STRING> , <STRING> , <STRING> , <STRING> ) : <NEWLINE> <INDENT> for number in range ( 13 ) : <NEWLINE> <INDENT> if cards [ suits [ suit ] ] [ number + 1 ] != 1 : <NEWLINE> <INDENT> print ( suit , number + 1 ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
cards = [ <NEWLINE> <INDENT> <STRING> . format ( s , r ) for s in ( <STRING> , <STRING> , <STRING> , <STRING> ) for r in range ( 1 , 13 + 1 ) <NEWLINE> <DEDENT> ] <NEWLINE> <NL> count = int ( input ( ) <NEWLINE> <NL> for n in range ( count ) : <NEWLINE> <INDENT> card = input ( ) <NEWLINE> cards . remove ( card ) <NEWLINE> <NL> <DEDENT> for n in cards : <NEWLINE> <INDENT> print ( n ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> cards = [ ( mark , num ) for mark in [ <STRING> , <STRING> , <STRING> , <STRING> ] for num in range ( 1 , 14 ) ] <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> mark , num = input ( ) . split ( ) <NEWLINE> cards . remove ( ( mark , int ( num ) ) ) <NEWLINE> <DEDENT> for ( mark , num ) in cards : <NEWLINE> <INDENT> print ( mak , num ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> SUITS = [ <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> exist_cards = { suit : [ ] for suit in suits } <NEWLINE> <NL> n = input ( ) <NEWLINE> <NL> for line in sys . stdin : <NEWLINE> <INDENT> suit , number = line . split ( ) <NEWLINE> exist_cards [ suit ] . append ( int ( number ) ) <NEWLINE> <NL> <NL> <DEDENT> for suit in SUITS : <NEWLINE> <INDENT> for i in range ( 1 , 14 ) : <NEWLINE> <INDENT> if i not in exist_cards [ suit ] : <NEWLINE> <INDENT> print ( suit , i ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> card = { <NEWLINE> <INDENT> <STRING> : [ False for _ in range ( 13 ) ] , <NEWLINE> <STRING> : [ False for _ in range ( 13 ) ] , <NEWLINE> <STRING> : [ False for _ in range ( 13 ) ] , <NEWLINE> <STRING> : [ False for _ in range ( 13 ) ] <NEWLINE> <DEDENT> } <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> mark , num = map ( int , input ( ) . split ( ) ) <NEWLINE> card [ mark ] [ num - 1 ] = True <NEWLINE> <NL> <DEDENT> for mark in <STRING> : <NEWLINE> <INDENT> for num in range ( 13 ) : <NEWLINE> <INDENT> if card [ mark ] [ num ] is False : <NEWLINE> <INDENT> print ( mark , num + 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = [ [ ] ] * 4 <NEWLINE> s , h , c , d = [ ] , [ ] , [ ] , [ ] <NEWLINE> for i in range ( n ) <NEWLINE> <INDENT> m , r = input ( ) . split ( ) <NEWLINE> if m == <STRING> <NEWLINE> <INDENT> s . append ( int ( r ) ) <NEWLINE> elif m == <STRING> <NEWLINE> s . append ( int ( r ) ) <NEWLINE> elif m == <STRING> <NEWLINE> s . append ( int ( r ) ) <NEWLINE> elif m == <STRING> <NEWLINE> s . append ( int ( r ) ) <NEWLINE> <DEDENT> <DEDENT> for i in range ( 1 , 14 ) : <NEWLINE> <INDENT> if i not in s : <NEWLINE> <INDENT> print ( <STRING> , str ( i ) ) <NEWLINE> <DEDENT> <DEDENT> for i in range ( 1 , 14 ) : <NEWLINE> <INDENT> if i not in h : <NEWLINE> <INDENT> print ( <STRING> , str ( i ) ) <NEWLINE> <DEDENT> <DEDENT> for i in range ( 1 , 14 ) : <NEWLINE> <INDENT> if i not in c : <NEWLINE> <INDENT> print ( <STRING> , str ( i ) ) <NEWLINE> <DEDENT> <DEDENT> for i in range ( 1 , 14 ) : <NEWLINE> <INDENT> if i not in d : <NEWLINE> <INDENT> print ( <STRING> , str ( i ) ) <NEWLINE> <DEDENT> <DEDENT>
s = range ( 1 , 14 ) <NEWLINE> h = range ( 1 , 14 ) <NEWLINE> c = range ( 1 , 14 ) <NEWLINE> d = range ( 1 , 14 ) <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> while n > 0 : <NEWLINE> <INDENT> x = input ( ) . split ( <STRING> ) <NEWLINE> if x [ 0 ] == <STRING> : <NEWLINE> <INDENT> s [ x [ 1 ] - 1 ] = 0 <NEWLINE> <DEDENT> elif x [ 0 ] == <STRING> : <NEWLINE> <INDENT> h [ x [ 1 ] - 1 ] = 0 <NEWLINE> <DEDENT> elif x [ 0 ] == <STRING> : <NEWLINE> <INDENT> c [ x [ 1 ] - 1 ] = 0 <NEWLINE> <DEDENT> elif x [ 0 ] == <STRING> : <NEWLINE> <INDENT> d [ x [ 1 ] - 1 ] = 0 <NEWLINE> <DEDENT> n -= 1 <NEWLINE> <NL> <DEDENT> for t in s : <NEWLINE> <INDENT> if t != 0 : print ( <STRING> % t ) <NEWLINE> <DEDENT> for t in h : <NEWLINE> <INDENT> if t != 0 : print ( <STRING> % t ) <NEWLINE> <DEDENT> for t in c : <NEWLINE> <INDENT> if t != 0 : print ( <STRING> % t ) <NEWLINE> <DEDENT> for t in d : <NEWLINE> <INDENT> if t != 0 : print ( <STRING> % t ) <NEWLINE> <DEDENT>
s = [ 0 ] * 13 <NEWLINE> h = [ 0 ] * 13 <NEWLINE> c = [ 0 ] * 13 <NEWLINE> d = [ 0 ] * 13 <NEWLINE> <NL> num = int ( input ( ) ) <NEWLINE> for i in range ( num ) : <NEWLINE> <INDENT> m , n = input ( ) . split ( ) <NEWLINE> x = int ( n ) - 1 <NEWLINE> if m == <STRING> : <NEWLINE> <INDENT> s [ x ] = 1 <NEWLINE> <DEDENT> elif m == <STRING> : <NEWLINE> <INDENT> h [ x ] = 1 <NEWLINE> <DEDENT> elif m == <STRING> : <NEWLINE> <INDENT> c [ x ] = 1 <NEWLINE> <DEDENT> elif m == <STRING> : <NEWLINE> <INDENT> d [ x ] = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( 13 ) : <NEWLINE> <INDENT> if s [ i ] == 0 : <NEWLINE> <INDENT> print ( <STRING> % i + 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( 13 ) : <NEWLINE> <INDENT> if h [ i ] == 0 : <NEWLINE> <INDENT> print ( <STRING> % i + 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( 13 ) : <NEWLINE> <INDENT> if c [ i ] == 0 : <NEWLINE> <INDENT> print ( <STRING> % i + 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( 13 ) : <NEWLINE> <INDENT> if d [ i ] == 0 : <NEWLINE> <INDENT> print ( <STRING> % i + 1 ) <NEWLINE> <NL> <NL> <NL> <NL> <DEDENT> <DEDENT>
fullcards = { <NEWLINE> <INDENT> <STRING> : set ( range ( 1 , 14 ) ) , <NEWLINE> <STRING> : set ( range ( 1 , 14 ) ) , <NEWLINE> <STRING> : set ( range ( 1 , 14 ) ) , <NEWLINE> <STRING> : set ( range ( 1 , 14 ) ) <NEWLINE> } <NEWLINE> <DEDENT> cards = { <NEWLINE> <INDENT> <STRING> : set ( { } ) , <NEWLINE> <STRING> : set ( { } ) , <NEWLINE> <STRING> : set ( { } ) , <NEWLINE> <STRING> : set ( { } ) <NEWLINE> } <NEWLINE> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> line = input ( ) <NEWLINE> suit , rank = line . split ( ) <NEWLINE> rank = int ( rank ) <NEWLINE> cards [ suit ] . add ( rank ) <NEWLINE> <DEDENT> for s in [ <STRING> , <STRING> , <STRING> , <STRING> ] : <NEWLINE> <INDENT> for r in fullcards [ s ] - cards [ s ] : <NEWLINE> <INDENT> print ( <STRING> % ( s , r ) ) <NEWLINE> <DEDENT> <DEDENT>
def tonum ( suit ) : <NEWLINE> <INDENT> if suit == <STRING> : return 0 <NEWLINE> if suit == <STRING> : return 1 <NEWLINE> if suit == <STRING> : return 2 <NEWLINE> if suit == <STRING> : return 3 <NEWLINE> <NL> <DEDENT> def tosuit ( num ) : <NEWLINE> <INDENT> suits = [ <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> return suits [ num ] <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> cards = [ i for i in range ( 52 ) ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a = input ( ) . split ( ) <NEWLINE> cards . remove ( tonum ( a [ 0 ] ) * 13 + int ( a [ 1 ] ) ) <NEWLINE> <DEDENT> cards . reverse ( ) <NEWLINE> for i in cards : <NEWLINE> <INDENT> print ( tosuit ( i // 13 ) + <STRING> + ( i % 13 ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> cards = [ ] <NEWLINE> patterns = [ <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> each_card = list ( map ( str , input ( ) . strip ( ) ) ) <NEWLINE> each_card [ 1 ] = int ( each_card [ 1 ] ) <NEWLINE> cards . append ( each_card ) <NEWLINE> <DEDENT> for p in patterns : <NEWLINE> <INDENT> for r in range ( 1 , 13 + 1 ) : <NEWLINE> <INDENT> if [ p , r ] in cards : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( p + <STRING> + str ( r ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> cards = [ [ 0 for i in range ( 13 ) ] for j in range ( 4 ) ] <NEWLINE> s2n = { <STRING> : 0 , <STRING> : 1 , <STRING> : 2 , <STRING> : 3 } <NEWLINE> n2s = <STRING> <NEWLINE> n = int ( input ( ) ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> card = list ( input ( ) . split ( ) ) <NEWLINE> card [ 1 ] = int ( card [ 1 ] ) <NEWLINE> if card [ 0 ] == <STRING> : <NEWLINE> <INDENT> suit = 0 <NEWLINE> <DEDENT> elif card [ 0 ] == <STRING> : <NEWLINE> <INDENT> suit = 1 <NEWLINE> <DEDENT> elif card [ 0 ] == <STRING> : <NEWLINE> <INDENT> suit = 2 <NEWLINE> <DEDENT> elif card [ 0 ] == <STRING> : <NEWLINE> <INDENT> suit = 3 <NEWLINE> <DEDENT> cards [ suit ] [ card [ 1 ] - 1 ] = 1 <NEWLINE> <DEDENT> for i in range ( 4 ) : <NEWLINE> <INDENT> for j in range ( 13 ) : <NEWLINE> <INDENT> if not ( cards [ i ] [ j ] ) : <NEWLINE> <INDENT> print ( n2s [ i ] , j + 1 ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
NumberOfSheet = int ( input ( ) ) <NEWLINE> OwnedCards = [ [ str ( i ) for i in input ( ) . split ( ) ] for loop in range ( NumberOfSheet ) ] <NEWLINE> S = [ int ( 0 ) for i in range ( 13 ) ] <NEWLINE> H = [ int ( 0 ) for i in range ( 13 ) ] <NEWLINE> C = [ int ( 0 ) for i in range ( 13 ) ] <NEWLINE> D = [ int ( 0 ) for i in range ( 13 ) ] <NEWLINE> for i in OwnedCards : <NEWLINE> <INDENT> if i [ 0 ] == <STRING> or i [ 0 ] == <STRING> or i [ 0 ] == <STRING> or i [ 0 ] == <STRING> : <NEWLINE> <INDENT> if i [ 0 ] == <STRING> : S [ int ( i [ 1 ] ) - 1 ] = 1 <NEWLINE> if i [ 0 ] == <STRING> : H [ int ( i [ 1 ] ) - 1 ] = 1 <NEWLINE> if i [ 0 ] == <STRING> : C [ int ( i [ 1 ] ) - 1 ] = 1 <NEWLINE> if i [ 0 ] == <STRING> : D [ int ( i [ 1 ] ) - 1 ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( 13 ) : if S [ i ] == 0 : print ( <STRING> , i + 1 ) <NEWLINE> for i in range ( 13 ) : if H [ i ] == 0 : print ( <STRING> , i + 1 ) <NEWLINE> for i in range ( 13 ) : if C [ i ] == 0 : print ( <STRING> , i + 1 ) <NEWLINE> for i in range ( 13 ) : if D [ i ] == 0 : print ( <STRING> , i + 1 ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> egara = [ <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> remind = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> remind . append ( input ( ) ) <NEWLINE> <NL> <DEDENT> for i in range ( 4 ) : <NEWLINE> <INDENT> for j in range ( 1 , 14 ) : <NEWLINE> <INDENT> if egara [ i ] + str ( j ) not in a : <NEWLINE> <INDENT> print ( egara [ i ] + str ( j ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> cards = { } <COMMENT> <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> card = input ( ) <NEWLINE> cards [ card ] = 1 <NEWLINE> <NL> <COMMENT> <NL> <NL> <DEDENT> for c in range [ <STRING> , <STRING> , <STRING> , <STRING> ] : <NEWLINE> <INDENT> for n in range ( 1 , 13 ) : <NEWLINE> <INDENT> key = C + <STRING> + str ( n ) <NEWLINE> if not key in cards : <NEWLINE> <INDENT> print ( key ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT>
a = <STRING> <NEWLINE> for i in range ( 52 ) : a += <STRING> [ i / 13 ] + <STRING> + str ( i % 13 + 1 ) + <STRING> <NEWLINE> for i in range ( input ( ) ) : a = a . replace ( raw_input ( ) + <STRING> , <STRING> ) <NEWLINE> print a <NEWLINE>
import sys <NEWLINE> i = 0 <NEWLINE> x = [ ] <NEWLINE> for line in sys . stdin : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> x . append ( int ( line ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s1 = <STRING> . index ( line [ 0 ] ) <NEWLINE> s2 = int ( line [ 2 : ] ) <NEWLINE> x . append ( ( s1 , s2 ) ) <NEWLINE> <DEDENT> i = 1 <NEWLINE> <NL> <DEDENT> r4 = range ( 4 ) <NEWLINE> r13 = range ( 13 ) <NEWLINE> lx = x . pop ( 0 ) <NEWLINE> cards = [ [ 0 for i in r13 ] for j in r4 ] <NEWLINE> for j , i in x : cards [ j ] [ i - 1 ] = 1 <NEWLINE> <NL> for j in r4 : <NEWLINE> <INDENT> for i in r13 : <NEWLINE> <INDENT> if cards [ j ] [ i ] == 0 : print <STRING> [ j ] , str ( i + 1 ) <NEWLINE> <DEDENT> <DEDENT> print <NEWLINE>
S_cards = [ ] <NEWLINE> H_cards = [ ] <NEWLINE> C_cards = [ ] <NEWLINE> D_cards = [ ] <NEWLINE> <NL> for i in range ( 1 , 14 ) : <NEWLINE> <INDENT> S_cards . append ( i ) <NEWLINE> H_cards . append ( i ) <NEWLINE> C_cards . append ( i ) <NEWLINE> D_cards . append ( i ) <NEWLINE> <NL> <DEDENT> now_cards = int ( input ( ) ) <NEWLINE> for i in range ( 0 , now_cards ) : <NEWLINE> <INDENT> kind_num = [ ] <NEWLINE> kind_num = input ( ) . split ( ) <NEWLINE> if kind_num [ 0 ] == <STRING> : <NEWLINE> <INDENT> S_cards . remove ( int ( kind_num [ 1 ] ) <NEWLINE> <DEDENT> elif kind_num [ 0 ] == <STRING> : <NEWLINE> <INDENT> H_cards . remove ( int ( kind_num [ 1 ] ) <NEWLINE> <DEDENT> elif kind_num [ 0 ] == <STRING> : <NEWLINE> <INDENT> C_cards . remove ( int ( kind_num [ 1 ] ) <NEWLINE> <DEDENT> elif kind_num [ 0 ] == <STRING> : <NEWLINE> <INDENT> D_cards . remove ( int ( kind_num [ 1 ] ) <NEWLINE> <DEDENT> <DEDENT> for i in range ( 0 , len ( S_cards ) ) : <NEWLINE> <INDENT> print ( <STRING> , S_cards [ i ] ) <NEWLINE> <DEDENT> for i in range ( 0 , len ( H_cards ) ) : <NEWLINE> <INDENT> print ( <STRING> , H_cards [ i ] ) <NEWLINE> <DEDENT> for i in range ( 0 , len ( C_cards ) ) : <NEWLINE> <INDENT> print ( <STRING> , C_cards [ i ] ) <NEWLINE> <DEDENT> for i in range ( 0 , len ( D_cards ) ) : <NEWLINE> <INDENT> print ( <STRING> , D_cards [ i ] ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> cards = [ ] <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> s , r = input ( ) . split ( ) <NEWLINE> cards . append ( ( s , int ( r ) ) ) <NEWLINE> <DEDENT> for s in <STRING> : <NEWLINE> <INDENT> for r in range ( 1 , 14 ) <NEWLINE> <INDENT> if ( s , r ) not in cards : <NEWLINE> <INDENT> print ( s , r ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> cards = { } <COMMENT> <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> card = input ( ) <NEWLINE> cards [ card ] = 1 <NEWLINE> <NL> <COMMENT> <NL> <NL> <DEDENT> for c in [ <STRING> , <STRING> , <STRING> , <STRING> ] : <NEWLINE> <INDENT> for n in rarge ( 1 , 14 ) : <NEWLINE> <INDENT> key = c + <STRING> + str ( n ) <NEWLINE> if not key in cards : <NEWLINE> <INDENT> print ( key ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
cards = { <NEWLINE> <INDENT> <STRING> : [ 0 ] * 13 , <NEWLINE> <STRING> : [ 0 ] * 13 , <NEWLINE> <STRING> : [ 0 ] * 13 , <NEWLINE> <STRING> : [ 0 ] * 13 <NEWLINE> <DEDENT> } <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> s , num = input ( ) . split ( ) <NEWLINE> c [ s ] [ int ( num ) - 1 ] = 1 <NEWLINE> <NL> <DEDENT> for i in [ <STRING> , <STRING> , <STRING> , <STRING> ] : <NEWLINE> <INDENT> for j in range ( 13 ) : <NEWLINE> <INDENT> if [ i ] [ j ] == 0 : <NEWLINE> <INDENT> print ( i , j + ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> count = 0 <NEWLINE> card = { <STRING> : card_ ( ) , <STRING> : card_ ( ) , <STRING> : card_ ( ) , <STRING> : card_ ( ) } <NEWLINE> while count < n : <NEWLINE> <INDENT> i = list ( input ( ) . split ( <STRING> ) ) <NEWLINE> card [ i [ 0 ] ] -= { int ( i [ 1 ] ) } <NEWLINE> count += 1 <NEWLINE> <NL> <DEDENT> mark = [ <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> for m in mark : <NEWLINE> <INDENT> for c in sorted ( card [ m ] ) : <NEWLINE> <INDENT> print ( <STRING> % ( m , c ) ) <NEWLINE> <DEDENT> <DEDENT>
tramps = { <NEWLINE> <INDENT> <STRING> : [ 0 ] * 13 , <NEWLINE> <STRING> : [ 0 ] * 13 , <NEWLINE> <STRING> : [ 0 ] * 13 , <NEWLINE> <STRING> : [ 0 ] * 13 <NEWLINE> <DEDENT> } <NEWLINE> <COMMENT> <NL> <NL> <COMMENT> <NL> n = int ( input ( ) ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> kind , num = input ( ) . split ( ) <NEWLINE> tramps [ kind ] [ num - 1 ] = 1 <NEWLINE> <NL> <DEDENT> for i in [ <STRING> , <STRING> , <STRING> , <STRING> ] : <NEWLINE> <INDENT> for j in range ( 13 ) : <NEWLINE> <INDENT> tramp = tramps [ i ] [ j ] <NEWLINE> if tramp == 0 : <NEWLINE> <INDENT> print ( tramps ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT>
table = [ [ 0 for i in range ( 13 ) ] for j in range ( 4 ) ] <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> <NL> i = 0 <NEWLINE> while i < n : <NEWLINE> <INDENT> s , num = input ( ) . split ( ) <NEWLINE> num = int ( num ) <NEWLINE> <NL> if s == <STRING> : <NEWLINE> <INDENT> table [ 0 ] [ n - 1 ] = 1 <NEWLINE> <DEDENT> elif s == <STRING> : <NEWLINE> <INDENT> table [ 1 ] [ n - 1 ] = 1 <NEWLINE> <DEDENT> elif s == <STRING> : <NEWLINE> <INDENT> table [ 2 ] [ n - 1 ] = 1 <NEWLINE> <DEDENT> else : <COMMENT> <NEWLINE> <INDENT> table [ 3 ] [ n - 1 ] = 1 <NEWLINE> <NL> <DEDENT> i += 1 <NEWLINE> <NL> <DEDENT> for i , elem_i in enumerate ( table ) : <NEWLINE> <INDENT> for j , elem_j in enumerate ( elem_i ) : <NEWLINE> <INDENT> if elem_j == 1 : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <DEDENT> if i == 0 : <NEWLINE> <INDENT> s_str = <STRING> <NEWLINE> <DEDENT> elif i == 1 : <NEWLINE> <INDENT> s_str = <STRING> <NEWLINE> <DEDENT> elif i == 2 : <NEWLINE> <INDENT> s_str = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s_str = <STRING> <NEWLINE> <DEDENT> print ( s_str + <STRING> + str ( j + 1 ) ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> <NL> T = [ [ 0 for j in range ( 13 ) ] for m in range ( 4 ) ] <NEWLINE> format ( T ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> a , b = input ( ) . split ( ) <NEWLINE> b = int ( b ) <NEWLINE> <NL> if a == <STRING> : <NEWLINE> <INDENT> T [ 0 ] [ b - 1 ] = 1 <NEWLINE> <DEDENT> elif a == <STRING> : <NEWLINE> <INDENT> T [ 1 ] [ b - 1 ] = 1 <NEWLINE> <DEDENT> elif a == <STRING> : <NEWLINE> <INDENT> T [ 2 ] [ b - 1 ] = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> T [ 3 ] [ b - 1 ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> for j in range ( 4 ) : <NEWLINE> <INDENT> for i in range ( 13 ) : <NEWLINE> <INDENT> if T [ j ] [ i ] == 0 : <NEWLINE> <INDENT> if c == 0 : <NEWLINE> <INDENT> K = <STRING> <NEWLINE> <DEDENT> elif c == 1 : <NEWLINE> <INDENT> K = <STRING> <NEWLINE> <DEDENT> elif c == 2 : <NEWLINE> <INDENT> K = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> K = <STRING> <NEWLINE> <DEDENT> <DEDENT> print ( K , d + 1 ) <NEWLINE> <DEDENT> <DEDENT>
all_cards = [ [ ] , [ ] , [ ] , [ ] ] <NEWLINE> for i in range ( 4 ) : <NEWLINE> <INDENT> for j in range ( 13 ) : <NEWLINE> <INDENT> all_cards [ i ] . append ( j + 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> n = int ( raw_input ( ) ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> card = raw_input ( ) . split ( ) <NEWLINE> if card [ 0 ] == <STRING> : <NEWLINE> <INDENT> all_cards [ 0 ] . remove ( card [ 1 ] ) <NEWLINE> <DEDENT> elif card [ 0 ] == <STRING> : <NEWLINE> <INDENT> all_cards [ 1 ] . remove ( card [ 1 ] ) <NEWLINE> <DEDENT> elif card [ 0 ] == <STRING> : <NEWLINE> <INDENT> all_cards [ 2 ] . remove ( card [ 1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> all_cards [ 3 ] . remove ( card [ 1 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( len ( all_cards [ 0 ] ) ) : <NEWLINE> <INDENT> print ( <STRING> . format ( all_cards [ 0 ] [ i ] ) ) <NEWLINE> <DEDENT> for i in range ( len ( all_cards [ 1 ] ) ) : <NEWLINE> <INDENT> print ( <STRING> . format ( all_cards [ 1 ] [ i ] ) ) <NEWLINE> <DEDENT> for i in range ( len ( all_cards [ 2 ] ) ) : <NEWLINE> <INDENT> print ( <STRING> . format ( all_cards [ 2 ] [ i ] ) ) <NEWLINE> <DEDENT> for i in range ( len ( all_cards [ 3 ] ) ) : <NEWLINE> <INDENT> print ( <STRING> . format ( all_cards [ 3 ] [ i ] ) ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> s_l = h_l = c_l = d_l = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 ] <NEWLINE> <NL> for i in range ( 0 , n ) : <NEWLINE> <INDENT> mark , num = input ( ) . split ( ) <NEWLINE> if mark == <STRING> : <NEWLINE> <INDENT> s_l . remove ( int ( num ) ) <NEWLINE> <DEDENT> if mark == <STRING> : <NEWLINE> <INDENT> h_l . remove ( int ( num ) ) <NEWLINE> <DEDENT> if mark == <STRING> : <NEWLINE> <INDENT> c_l . remove ( int ( num ) ) <NEWLINE> <DEDENT> if mark == <STRING> : <NEWLINE> <INDENT> d_l . remove ( int ( num ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> for s in s_l : <NEWLINE> <INDENT> print ( <STRING> . format ( s ) ) <NEWLINE> <DEDENT> for h in h_l : <NEWLINE> <INDENT> print ( <STRING> . format ( h ) ) <NEWLINE> <DEDENT> for c in c_l : <NEWLINE> <INDENT> print ( <STRING> . format ( c ) ) <NEWLINE> <DEDENT> for d in d_l : <NEWLINE> <INDENT> print ( <STRING> . format ( d ) ) <NEWLINE> <DEDENT>
cards = [ [ 0 for i in range ( 13 ) ] for j in range ( 4 ) ] <NEWLINE> <NL> pattern = [ <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> <NL> ch_list = [ ] <NEWLINE> rank_list_0 = [ ] <NEWLINE> while n > 0 : <NEWLINE> <INDENT> ch , rank = input ( ) . split ( ) <NEWLINE> ch_list . append ( ch ) <NEWLINE> rank_list_0 . append ( rank ) <NEWLINE> n = n - 1 <NEWLINE> <NL> <DEDENT> rank_list = [ int ( rank_list ) for rank_list in rank_list_0 ] <NEWLINE> <NL> for ( chlist , ranklist ) in zip ( ch_list , rank_list ) : <NEWLINE> <INDENT> cards [ pattern . index ( chlist ) ] [ ranklist - 1 ] = 1 <NEWLINE> <NL> <DEDENT> for i in range ( 0 , 3 ) : <NEWLINE> <INDENT> for j in range ( 0 , 12 ) <NEWLINE> <INDENT> if cards [ i ] [ j ] == 0 : <NEWLINE> <INDENT> print ( pattern [ i ] , j + 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> S , H , C , D = [ 0 for i in range ( 13 ) ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> data = input ( ) . split ( ) <NEWLINE> num = int ( data [ 1 ] ) <NEWLINE> if data [ 0 ] == <STRING> : <NEWLINE> <INDENT> S [ num - 1 ] = 1 <NEWLINE> <DEDENT> elif data [ 0 ] == <STRING> : <NEWLINE> <INDENT> H [ num - 1 ] = 1 <NEWLINE> <DEDENT> elif data [ 0 ] == <STRING> : <NEWLINE> <INDENT> C [ num - 1 ] = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> D [ num - 1 ] = 1 <NEWLINE> <DEDENT> <DEDENT> for j in range ( 13 ) : <NEWLINE> <INDENT> if S [ j ] == 0 : <NEWLINE> <INDENT> print ( <STRING> % ( j + 1 ) ) <NEWLINE> <DEDENT> <DEDENT> for j in range ( 13 ) : <NEWLINE> <INDENT> if H [ j ] == 0 : <NEWLINE> <INDENT> print ( <STRING> % ( j + 1 ) ) <NEWLINE> <DEDENT> <DEDENT> for j in range ( 13 ) : <NEWLINE> <INDENT> if C [ j ] == 0 : <NEWLINE> <INDENT> print ( <STRING> % ( j + 1 ) ) <NEWLINE> <DEDENT> <DEDENT> for j in range ( 13 ) : <NEWLINE> <INDENT> if D [ j ] == 0 : <NEWLINE> <INDENT> print ( <STRING> % ( j + 1 ) ) <NEWLINE> <DEDENT> <DEDENT>
cards = { <NEWLINE> <INDENT> <STRING> : [ 0 for _ in range ( 13 ) ] , <NEWLINE> <STRING> : [ 0 for _ in range ( 13 ) ] , <NEWLINE> <STRING> : [ 0 for _ in range ( 13 ) ] , <NEWLINE> <STRING> : [ 0 for _ in range ( 13 ) ] , <NEWLINE> } <NEWLINE> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> <NL> for _ in range ( n ) : <NEWLINE> <INDENT> ( s , r ) = input ( ) . split ( ) <NEWLINE> r = int ( r ) <NEWLINE> cards [ s ] [ r - 1 ] = r <NEWLINE> <NL> <DEDENT> for s in ( <STRING> , <STRING> , <STRING> , <STRING> ) : <NEWLINE> <INDENT> for r in range ( 13 ) : <NEWLINE> <INDENT> if cards [ s ] [ r ] == 0 : <NEWLINE> <INDENT> print ( <STRING> , format ( s , r + 1 ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
n = int ( raw_input ( ) ) <NEWLINE> s = range ( 1 , 14 ) <NEWLINE> h = range ( 1 , 14 ) <NEWLINE> c = range ( 1 , 14 ) <NEWLINE> d = range ( 1 , 14 ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> hd , r = raw_input ( ) . split ( ) <NEWLINE> if hd == <STRING> : <NEWLINE> <INDENT> s [ int ( r ) - 1 ] = 0 <NEWLINE> <DEDENT> elif hd == <STRING> : <NEWLINE> <INDENT> h [ int ( r ) - 1 ] = 0 <NEWLINE> <DEDENT> elif hd == <STRING> : <NEWLINE> <INDENT> c [ int ( r ) - 1 ] = 0 <NEWLINE> <DEDENT> elif hd == <STRING> : <NEWLINE> <INDENT> d [ int ( r ) - 1 ] = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> a = <STRING> <NEWLINE> for i in range ( 13 ) : <NEWLINE> <INDENT> if s [ i ] != 0 : <NEWLINE> <INDENT> print a + str ( s [ i ] ) <NEWLINE> <DEDENT> <DEDENT> a = <STRING> <NEWLINE> for i in range ( 13 ) : <NEWLINE> <INDENT> if h [ i ] != 0 : <NEWLINE> <INDENT> print a + str ( h [ i ] ) <NEWLINE> <DEDENT> <DEDENT> a = <STRING> <NEWLINE> for i in range ( 13 ) : <NEWLINE> <INDENT> if c [ i ] != 0 : <NEWLINE> <INDENT> print a + str ( c [ i ] ) <NEWLINE> <DEDENT> <DEDENT> a = <STRING> <NEWLINE> for i in range ( 13 ) : <NEWLINE> <INDENT> if d [ i ] != 0 : <NEWLINE> <INDENT> print a + str ( d [ i ] ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( raw_input ( ) ) <NEWLINE> <NL> a = [ ] <NEWLINE> for i in [ <STRING> , <STRING> , <STRING> , <STRING> ] : <NEWLINE> <INDENT> for j in xrange ( 1 , 14 ) : <NEWLINE> <INDENT> a . append ( <STRING> . format ( i , j ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> for i in xrange ( 0 , n ) : <NEWLINE> <INDENT> b = raw_input ( ) <NEWLINE> a . remove ( b ) <NEWLINE> <NL> <DEDENT> print <STRING> . join ( a ) , <NEWLINE>
data = [ <STRING> . format ( s , r ) for s in ( <STRING> , <STRING> , <STRING> , <STRING> ) for r in range ( 1 , 13 , + 1 ) ] <NEWLINE> <NL> count = int ( input ( ) ) <NEWLINE> for c in range ( count ) : <NEWLINE> <INDENT> card = input ( ) <NEWLINE> data . remove ( card ) <NEWLINE> <NL> <DEDENT> for c in data : <NEWLINE> <INDENT> print ( c ) <NEWLINE> <DEDENT>
n = input ( ) <NEWLINE> <NL> a = [ ] <NEWLINE> flag = { } <NEWLINE> for j in range ( 1 , 14 ) : <NEWLINE> <INDENT> flag [ ( <STRING> , j ) ] = 0 <NEWLINE> flag [ ( <STRING> , j ) ] = 0 <NEWLINE> flag [ ( <STRING> , j ) ] = 0 <NEWLINE> flag [ ( <STRING> , j ) ] = 0 <NEWLINE> <NL> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> temp = map ( str , raw_input ( ) . split ( ) ) <NEWLINE> a . append ( ( temp [ 0 ] , temp [ 1 ] ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> if ( a [ i ] [ 0 ] == <STRING> ) : <NEWLINE> <COMMENT> <NL> <INDENT> for j in range ( 1 , 14 ) : <NEWLINE> <INDENT> if ( int ( a [ i ] [ 1 ] ) == j ) : <NEWLINE> <COMMENT> <NL> <INDENT> flag [ ( <STRING> , j ) ] = 1 <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> if ( a [ i ] [ 0 ] == <STRING> ) : <NEWLINE> <INDENT> for j in range ( 1 , 14 ) : <NEWLINE> <INDENT> if ( int ( a [ i ] [ 1 ] ) == j ) : <NEWLINE> <INDENT> flag [ ( <STRING> , j ) ] = 1 <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> if ( a [ i ] [ 0 ] == <STRING> ) : <NEWLINE> <INDENT> for j in range ( 1 , 14 ) : <NEWLINE> <INDENT> if ( int ( a [ i ] [ 1 ] ) == j ) : <NEWLINE> <INDENT> flag [ ( <STRING> , j ) ] = 1 <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> if ( a [ i ] [ 0 ] == <STRING> ) : <NEWLINE> <INDENT> for j in range ( 1 , 14 ) : <NEWLINE> <INDENT> if ( int ( a [ i ] [ 1 ] ) == j ) : <NEWLINE> <INDENT> flag [ ( <STRING> , j ) ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for j in range ( 1 , 14 ) : <NEWLINE> <INDENT> if ( flag [ ( <STRING> , j ) ] == 0 ) : <NEWLINE> <INDENT> print <STRING> <STRING> <STRING> % ( j ) <NEWLINE> <DEDENT> <DEDENT> for j in range ( 1 , 14 ) : <NEWLINE> <INDENT> if ( flag [ ( <STRING> , j ) ] == 0 ) : <NEWLINE> <INDENT> print <STRING> <STRING> <STRING> % ( j ) <NEWLINE> <DEDENT> <DEDENT> for j in range ( 1 , 14 ) : <NEWLINE> <INDENT> if ( flag [ ( <STRING> , j ) ] == 0 ) : <NEWLINE> <INDENT> print <STRING> <STRING> <STRING> % ( j ) <NEWLINE> <DEDENT> <DEDENT> for j in range ( 1 , 14 ) : <NEWLINE> <INDENT> if ( flag [ ( <STRING> , j ) ] == 0 ) : <NEWLINE> <INDENT> print <STRING> <STRING> <STRING> % ( j ) <NEWLINE> <NL> <DEDENT> <DEDENT> exit ( 0 ) <NEWLINE>
n = input ( ) <NEWLINE> <COMMENT> <NL> a = [ raw_input ( ) for i in range ( n ) ] <NEWLINE> j = 0 <NEWLINE> for i in range ( 1 , 53 ) : <NEWLINE> <INDENT> for j in range ( n ) ; <NEWLINE> <INDENT> if a [ j ] == <STRING> % i : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> elif j == n - 1 : <NEWLINE> <INDENT> print <STRING> % i <NEWLINE> <DEDENT> <DEDENT> <DEDENT> or i in range ( 1 , 53 ) : <NEWLINE> <INDENT> for j in range ( n ) ; <NEWLINE> <INDENT> if a [ j ] == <STRING> % i : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> elif j == n - 1 : <NEWLINE> <INDENT> print <STRING> % i <NEWLINE> <DEDENT> <DEDENT> <DEDENT> or i in range ( 1 , 53 ) : <NEWLINE> <INDENT> for j in range ( n ) ; <NEWLINE> <INDENT> if a [ j ] == <STRING> % i : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> elif j == n - 1 : <NEWLINE> <INDENT> print <STRING> % i <NEWLINE> <DEDENT> <DEDENT> <DEDENT> or i in range ( 1 , 53 ) : <NEWLINE> <INDENT> for j in range ( n ) ; <NEWLINE> <INDENT> if a [ j ] == <STRING> % i : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> elif j == n - 1 : <NEWLINE> <INDENT> print <STRING> % i <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
n = input ( ) <NEWLINE> S = [ ] <NEWLINE> H = [ ] <NEWLINE> C = [ ] <NEWLINE> D = [ ] <NEWLINE> i = 1 <NEWLINE> while True : <NEWLINE> <INDENT> if i > n : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> card = raw_input ( ) . split ( ) <NEWLINE> mark = card [ 0 ] <NEWLINE> num = int ( card [ 1 ] ) <NEWLINE> <NL> if mark == <STRING> : <NEWLINE> <INDENT> S . append ( num ) <NEWLINE> <DEDENT> elif mark == <STRING> : <NEWLINE> <INDENT> H . append ( num ) <NEWLINE> <DEDENT> elif mark == <STRING> : <NEWLINE> <INDENT> C . append ( num ) <NEWLINE> <DEDENT> elif mark == <STRING> : <NEWLINE> <INDENT> D . append ( num ) <NEWLINE> <NL> <DEDENT> i += 1 <NEWLINE> <DEDENT> print <STRING> <NEWLINE> diff_S = set ( range ( 1 , 14 ) ) - set ( S ) <NEWLINE> for s in sorted ( diff_S ) : <NEWLINE> <INDENT> print <STRING> % s <NEWLINE> <DEDENT> diff_H = set ( range ( 1 , 14 ) ) - set ( H ) <NEWLINE> for h in sorted ( diff_H ) : <NEWLINE> <INDENT> print <STRING> % h <NEWLINE> <DEDENT> diff_C = set ( range ( 1 , 14 ) ) - set ( C ) <NEWLINE> for c in sorted ( diff_C ) : <NEWLINE> <INDENT> print <STRING> % c <NEWLINE> <DEDENT> diff_D = set ( range ( 1 , 14 ) ) - set ( D ) <NEWLINE> for d in sorted ( diff_D ) : <NEWLINE> <INDENT> print <STRING> % d <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> cards = [ [ 0 for i in range ( 13 ) ] for j in range ( 4 ) ] <NEWLINE> n = int ( input ( ) ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> card = list ( input ( ) . split ( ) ) <NEWLINE> card [ 1 ] = int ( card [ 1 ] ) <NEWLINE> if card [ 0 ] == <STRING> : <NEWLINE> <INDENT> suit = 0 <NEWLINE> <DEDENT> elif card [ 0 ] == <STRING> : <NEWLINE> <INDENT> suit = 1 <NEWLINE> <DEDENT> elif card [ 0 ] == <STRING> : <NEWLINE> <INDENT> suit = 2 <NEWLINE> <DEDENT> elif card [ 0 ] == <STRING> : <NEWLINE> <INDENT> suit = 3 <NEWLINE> <DEDENT> cards [ suit ] [ card [ 1 ] - 1 ] = 1 <NEWLINE> <DEDENT> for i in range ( 4 ) : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> suit = <STRING> <NEWLINE> <DEDENT> elif i == 1 : <NEWLINE> <INDENT> suit = <STRING> <NEWLINE> <DEDENT> elif i == 2 : <NEWLINE> <INDENT> suit = <STRING> <NEWLINE> <DEDENT> elif i == 3 : <NEWLINE> <INDENT> suit = <STRING> <NEWLINE> <DEDENT> for j in range ( 13 ) : <NEWLINE> <INDENT> if not ( cards [ i ] [ j ] ) : <NEWLINE> <INDENT> print ( suit , j + 1 ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
x = input ( ) <NEWLINE> S = H = C = D = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 ] <NEWLINE> for i in range ( x ) : <NEWLINE> <INDENT> mark , num = map ( str , raw_input ( ) . split ( ) ) <NEWLINE> if mark == <STRING> : <NEWLINE> <INDENT> S . remove ( int ( num ) ) <NEWLINE> <DEDENT> elif mark == <STRING> : <NEWLINE> <INDENT> H . remove ( int ( num ) ) <NEWLINE> <DEDENT> elif mark == <STRING> : <NEWLINE> <INDENT> C . remove ( int ( num ) ) <NEWLINE> <DEDENT> elif mark == <STRING> : <NEWLINE> <INDENT> D . remove ( int ( num ) ) <NEWLINE> <DEDENT> <DEDENT> for i in range ( len ( S ) ) : <NEWLINE> <INDENT> print <STRING> + str ( S [ i ] ) <NEWLINE> <DEDENT> for i in range ( len ( H ) ) : <NEWLINE> <INDENT> print <STRING> + str ( H [ i ] ) <NEWLINE> <DEDENT> for i in range ( len ( C ) ) : <NEWLINE> <INDENT> print <STRING> + str ( C [ i ] ) <NEWLINE> <DEDENT> for i in range ( len ( D ) ) : <NEWLINE> <INDENT> print <STRING> + str ( D [ i ] ) <NEWLINE> <DEDENT>
data = [ <NEWLINE> <INDENT> <STRING> . format ( s , r ) <NEWLINE> for s in ( <STRING> , <STRING> , <STRING> , <STRING> ) ] <NEWLINE> for r in range ( 1 , 13 + 1 ) <NEWLINE> ] <NEWLINE> <NL> <DEDENT> count = int ( input ( ) ) <NEWLINE> for c in range ( count ) : <NEWLINE> <INDENT> card = input ( ) <NEWLINE> data . remove ( card ) <NEWLINE> <NL> <DEDENT> for c in data : <NEWLINE> <INDENT> print ( c ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> sets = [ <STRING> . format ( m , r ) for m in [ <STRING> , <STRING> , <STRING> , <STRING> ] for r in range ( 1 , 14 ) ] <NEWLINE> [ sets . remove ( input ( ) ) for a in range ( n ) ] <NEWLINE> print ( b ) for b in sets <NEWLINE>
sCard = [ 0 ] * 13 <NEWLINE> hCard = [ 0 ] * 13 <NEWLINE> cCard = [ 0 ] * 13 <NEWLINE> dCard = [ 0 ] * 13 <NEWLINE> <NL> callNum = int ( input ( ) ) <NEWLINE> <NL> for cardLoop in range ( callNum - 1 ) : <NEWLINE> <INDENT> symbol , cardNum = input ( ) . split ( ) <NEWLINE> cardNum = int ( cardNum ) <NEWLINE> if symbol == <STRING> : <NEWLINE> <INDENT> sCard [ cardNum - 1 ] = cardNum <NEWLINE> <DEDENT> elif symbol == <STRING> : <NEWLINE> <INDENT> hCard [ cardNum - 1 ] = cardNum <NEWLINE> <DEDENT> elif symbol == <STRING> : <NEWLINE> <INDENT> cCard [ cardNum - 1 ] = cardNum <NEWLINE> <DEDENT> elif symbol == <STRING> : <NEWLINE> <INDENT> dCard [ cardNum - 1 ] = cardNum <NEWLINE> <NL> <DEDENT> <DEDENT> sLack = 0 <NEWLINE> hCard = 0 <NEWLINE> cCard = 0 <NEWLINE> dCard = 0 <NEWLINE> <NL> for cardLoop in range ( 13 ) : <NEWLINE> <INDENT> if sCard [ cardLoop ] == 0 : <NEWLINE> <INDENT> sLack = sLack + 1 <NEWLINE> <DEDENT> elif hCard [ cardLoop ] == 0 : <NEWLINE> <INDENT> hLack = hLack + 1 <NEWLINE> <DEDENT> elif cCard [ cardLoop ] == 0 : <NEWLINE> <INDENT> cLack = cLack + 1 <NEWLINE> <DEDENT> elif dCard [ cardLoop ] == 0 : <NEWLINE> <INDENT> dLack = dLack + 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> + str ( sLack ) ) <NEWLINE> print ( <STRING> + str ( hLack ) ) <NEWLINE> print ( <STRING> + str ( cLack ) ) <NEWLINE> print ( <STRING> + str ( dLack ) ) <NEWLINE>
for i in range ( 52 ) : <NEWLINE> <INDENT> for j in range ( 1 , 5 ) : <NEWLINE> <INDENT> for k in range ( 1 , 14 ) : <NEWLINE> <INDENT> cardlist [ i ] = [ j , k ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> luckcard = [ ] <NEWLINE> num = int ( input ( ) ) <NEWLINE> for i in range ( num ) : <NEWLINE> <INDENT> card [ i ] = [ int ( x ) for x in input ( ) . split ( ) if x . isdigit ( ) ] <NEWLINE> count = 1 <NEWLINE> while True : <NEWLINE> <INDENT> if card [ i ] == cardlist [ count ] : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> luckcard . append ( card [ i ] ) <NEWLINE> <DEDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> luckcard . replace ( <STRING> , <STRING> ) . replace ( <STRING> , <STRING> ) . replace ( <STRING> , <STRING> ) . replace ( <STRING> , <STRING> ) <NEWLINE> luckcard . sort ( ) <NEWLINE> for i in range ( 52 - n ) : <NEWLINE> <INDENT> luckcard [ i ] [ 0 ] . replace ( <STRING> , <STRING> ) . replace ( <STRING> , <STRING> ) . replace ( <STRING> , <STRING> ) . replace ( <STRING> , <STRING> ) <NEWLINE> print ( <STRING> . format ( luckcard [ 0 ] , luckcard [ 1 ] ) ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> cards = { } <COMMENT> <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> card = input ( ) <NEWLINE> cards [ card ] = 1 <NEWLINE> <NL> <COMMENT> <NL> <NL> <DEDENT> for c in [ <STRING> , <STRING> , <STRING> , <STRING> ] : <NEWLINE> <INDENT> for n in range ( 1 , 14 ) : <NEWLINE> <INDENT> card = c + <STRING> + str ( n ) <NEWLINE> if not key in cards : <NEWLINE> <INDENT> print ( key ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
n = input ( ) <NEWLINE> S = [ range ( 1 , 14 ) for j in range ( 4 ) ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ip = raw_input ( ) . split ( ) <NEWLINE> if ip [ 0 ] == <STRING> : <NEWLINE> <INDENT> S [ 0 ] . remove ( ip [ 1 ] ) <NEWLINE> <DEDENT> elif ip [ 0 ] == <STRING> : <NEWLINE> <INDENT> S [ 1 ] . remove ( ip [ 1 ] ) <NEWLINE> <DEDENT> elif ip [ 0 ] == <STRING> : <NEWLINE> <INDENT> S [ 2 ] . remove ( ip [ 1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> S [ 3 ] . remove ( ip [ 1 ] ) <NEWLINE> <DEDENT> <DEDENT> for i in S [ 0 ] : <NEWLINE> <INDENT> print <STRING> + i <NEWLINE> <DEDENT> for i in S [ 1 ] : <NEWLINE> <INDENT> print <STRING> + i <NEWLINE> <DEDENT> for i in S [ 2 ] : <NEWLINE> <INDENT> print <STRING> + i <NEWLINE> <DEDENT> for i in S [ 3 ] : <NEWLINE> <INDENT> print <STRING> + i <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> x = { 0 : <STRING> , 1 : <STRING> , 2 : <STRING> , 3 : <STRING> } <NEWLINE> c = [ [ 0 ] * 13 , [ 0 ] * 13 , [ 0 ] * 13 , [ 0 ] * 13 ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a , b = input ( ) . split ( ) <NEWLINE> if a == <STRING> : <NEWLINE> <INDENT> c [ 0 ] . insert ( b , b ) <NEWLINE> <DEDENT> elif a == <STRING> : <NEWLINE> <INDENT> c [ 1 ] . insert ( b , b ) <NEWLINE> <DEDENT> elif a == <STRING> : <NEWLINE> <INDENT> c [ 2 ] . insert ( b , b ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> c [ 3 ] . insert ( b , b ) <NEWLINE> <DEDENT> <DEDENT> for i in range ( 4 ) : <NEWLINE> <INDENT> for j in range ( 13 ) : <NEWLINE> <INDENT> if c [ i ] [ j ] == 0 : <NEWLINE> <INDENT> print ( x [ i ] , j ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> spade = hart = club = diamond = { 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 } <NEWLINE> trump = [ spade , hart , club , diamond ] <NEWLINE> suit_def = [ <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> card = list ( input ( ) . split ( ) ) <NEWLINE> suit = card [ 0 ] <NEWLINE> number = int ( card [ 1 ] ) <NEWLINE> if suit == <STRING> : <NEWLINE> <INDENT> spade . remove ( number ) <NEWLINE> <DEDENT> elif suit == <STRING> : <NEWLINE> <INDENT> hart . remove ( number ) <NEWLINE> <DEDENT> elif suit == <STRING> : <NEWLINE> <INDENT> club . remove ( number ) <NEWLINE> <DEDENT> elif suit == <STRING> : <NEWLINE> <INDENT> diamond . remove ( number ) <NEWLINE> <NL> <DEDENT> <DEDENT> for i , j in zip ( trump , suit_def ) : <NEWLINE> <INDENT> for k in i : <NEWLINE> <INDENT> print ( j , k ) <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> <NL> SUITS = ( <STRING> , <STRING> , <STRING> , <STRING> ) <NEWLINE> cards = { suit : { i for i in range ( 1 , 14 ) } for suit in SUITS } <NEWLINE> <NL> n = input ( ) <NEWLINE> <NL> for line in sys . stdin : <NEWLINE> <INDENT> suit , number = line . split ( ) <NEWLINE> cards [ suit ] . discard ( int ( number ) ) <NEWLINE> <NL> <DEDENT> for suit in SUITS : <NEWLINE> <INDENT> for i in cards [ suit ] : <NEWLINE> print ( suit , i ) <NEWLINE> <NL> <NL> <NL> <NL> <NL> <DEDENT>
n = int ( raw_input ( ) ) <NEWLINE> s = range ( 1 , 14 ) <NEWLINE> h = range ( 1 , 14 ) <NEWLINE> c = range ( 1 , 14 ) <NEWLINE> d = range ( 1 , 14 ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> q , r = raw_input ( ) . split ( ) <NEWLINE> if q == <STRING> : <NEWLINE> <INDENT> s [ int ( r ) - 1 ] = 0 <NEWLINE> <DEDENT> elif q == <STRING> : <NEWLINE> <INDENT> h [ int ( r ) - 1 ] = 0 <NEWLINE> <DEDENT> elif q == <STRING> : <NEWLINE> <INDENT> c [ int ( r ) - 1 ] = 0 <NEWLINE> <DEDENT> elif q == <STRING> : <NEWLINE> <INDENT> d [ int ( r ) - 1 ] = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> a = <STRING> <NEWLINE> for i in range ( 13 ) : <NEWLINE> <INDENT> if s [ i ] != 0 : <NEWLINE> <INDENT> print a + str ( s [ i ] ) <NEWLINE> <DEDENT> <DEDENT> a = <STRING> <NEWLINE> for i in range ( 13 ) : <NEWLINE> <INDENT> if h [ i ] != 0 : <NEWLINE> <INDENT> print a + str ( h [ i ] ) <NEWLINE> <DEDENT> <DEDENT> a = <STRING> <NEWLINE> for i in range ( 13 ) : <NEWLINE> <INDENT> if c [ i ] != 0 : <NEWLINE> <INDENT> print a + str ( c [ i ] ) <NEWLINE> <DEDENT> <DEDENT> a = <STRING> <NEWLINE> for i in range ( 13 ) : <NEWLINE> <INDENT> if d [ i ] != 0 : <NEWLINE> <INDENT> print a + str ( d [ i ] ) <NEWLINE> <DEDENT> <DEDENT>
c = { <NEWLINE> <INDENT> <STRING> : [ 1 ] * 13 , <NEWLINE> <STRING> : [ 1 ] * 13 , <NEWLINE> <STRING> : [ 1 ] * 13 , <NEWLINE> <STRING> : [ 1 ] * 13 <NEWLINE> <DEDENT> } <NEWLINE> n = int ( input ( ) ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a , b = input ( ) . split <NEWLINE> c [ a ] [ int ( b ) - 1 ] = 0 <NEWLINE> <DEDENT> for i in [ <STRING> , <STRING> , <STRING> , <STRING> ] : <NEWLINE> <INDENT> for j in range ( 13 ) : <NEWLINE> <INDENT> if c [ i ] [ j ] == 1 : <NEWLINE> <INDENT> print ( i , j + 1 ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT>
cards = [ [ False ] * 14 for i in range ( 4 ) ] <NEWLINE> n = int ( input ( ) ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> suit , rank = input ( ) . split ( ) <NEWLINE> r = int ( rank ) <NEWLINE> if suit == <STRING> : <NEWLINE> <INDENT> s == 0 <NEWLINE> <DEDENT> elif suit == <STRING> : <NEWLINE> <INDENT> s == 1 <NEWLINE> <DEDENT> elif suit == <STRING> : <NEWLINE> <INDENT> s == 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s == 3 <NEWLINE> <DEDENT> cards [ s ] [ r ] = True <NEWLINE> <NL> <DEDENT> name = [ <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> for s in range ( 4 ) : <NEWLINE> <INDENT> for r in range ( 1 , 14 ) : <NEWLINE> <INDENT> if cards [ s ] [ r ] : <NEWLINE> <INDENT> print ( name [ s ] , r ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
data = { <NEWLINE> <INDENT> <STRING> : [ 0 for _ in range ( 13 ) ] , <NEWLINE> <STRING> : [ 0 for _ in range ( 13 ) ] , <NEWLINE> <STRING> : [ 0 for _ in range ( 13 ) ] , <NEWLINE> <STRING> : [ 0 for _ in range ( 13 ) ] , <NEWLINE> <DEDENT> } <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> ( s , r ) = input ( ) . split ( ) <NEWLINE> index = cards [ s ] . index ( int ( r ) ) <NEWLINE> cards [ s ] [ int ( r ) - 1 ] = 1 <NEWLINE> <NL> <DEDENT> for s in [ <STRING> , <STRING> , <STRING> , <STRING> ] : <NEWLINE> <INDENT> for r in range ( 13 ) : <NEWLINE> <INDENT> if data [ s ] [ r ] == 0 : <NEWLINE> <INDENT> print ( s , r + 1 ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
import itertools <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> a = [ input ( ) for _ in range ( n ) ] <NEWLINE> <NL> suits = [ <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> cards = [ <STRING> % ( s , r ) for s , r in suits , range ( 1 , 14 ) ] <NEWLINE> answers = [ c for c in cards if c not in a ] <NEWLINE> for card in answers : <NEWLINE> <INDENT> print ( card ) <NEWLINE> <NL> <DEDENT>
<COMMENT> <NL> import sys <NEWLINE> n = input ( ) <NEWLINE> array = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> array . append ( map ( int , raw_input ( ) . split ( ) ) ) <NEWLINE> <DEDENT> array . sort ( ) <NEWLINE> result = [ [ ] ] <NEWLINE> index = 0 <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> if ( array [ i - 1 ] [ 0 : 3 ] == array [ i ] [ 0 : 3 ] ) : <NEWLINE> <INDENT> if ( result [ index ] [ 3 ] ) : <NEWLINE> <INDENT> result [ index ] [ 3 ] += array [ i ] [ 3 : ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> result [ index ] [ 0 : 3 ] = array [ i ] [ 0 : 3 ] <NEWLINE> result [ index ] [ 3 ] = array [ i ] [ 3 : ] <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> index += 1 <NEWLINE> <DEDENT> <DEDENT> for i in range ( 4 ) : <NEWLINE> <INDENT> for j in range ( 3 ) : <NEWLINE> <INDENT> for k in range ( 10 ) : <NEWLINE> <INDENT> sys . stdout . write ( <STRING> ) <NEWLINE> if ( i == array [ j ] [ 0 ] - 1 and k == array [ j ] [ 2 ] - 1 ) : <NEWLINE> <INDENT> print array [ j ] [ 3 ] , <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print 0 , <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if ( i != 3 ) : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT>
data = [ ] <NEWLINE> for i in xrange ( 4 ) : <NEWLINE> <INDENT> tou = [ ] <NEWLINE> data . append ( tou ) <NEWLINE> for j in xrange ( 3 ) : <NEWLINE> <INDENT> kai = [ 0 for k in xrange ( 10 ) ] <NEWLINE> tou . append ( kai ) <NEWLINE> <DEDENT> <DEDENT> n = int ( raw_input ( ) ) <NEWLINE> for i in xrange ( n ) : <NEWLINE> <INDENT> b , f , r , v = map ( int , raw_input ( ) . split ( <STRING> ) ) <NEWLINE> data [ b - 1 ] [ f - 1 ] [ r - 1 ] += v <NEWLINE> <DEDENT> for tou in data : <NEWLINE> <INDENT> if not tou is data [ 0 ] : <NEWLINE> <INDENT> print <STRING> * 20 <NEWLINE> <DEDENT> for kai in tou : <NEWLINE> <INDENT> print <STRING> . join ( map ( str , kai ) ) <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> n = input ( ) <NEWLINE> a = [ [ [ 0 ] * 10 for i in range ( 3 ) ] for i in range ( 4 ) ] <NEWLINE> for i in xrange ( n ) : <NEWLINE> <INDENT> b = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> a [ b [ 0 ] - 1 ] [ b [ 1 ] - 1 ] [ b [ 2 ] - 1 ] += b [ 3 ] <NEWLINE> <NL> <DEDENT> for i in range ( 4 ) : <NEWLINE> <INDENT> for j in range ( 3 ) : <NEWLINE> <INDENT> for k in range ( 10 ) : <NEWLINE> <INDENT> sys . stdout . write ( <STRING> % a [ i ] [ j ] [ k ] ) <NEWLINE> <DEDENT> print <STRING> <NEWLINE> <DEDENT> if i != 3 <NEWLINE> print <STRING> * 20 <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> k = [ [ [ 0 for x in range ( 10 ) ] for x in range ( 3 ) ] for x in range ( 4 ) ] <NEWLINE> n = int ( input ( ) ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> b , f , r , v = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> k [ b - 1 ] [ f - 1 ] [ r - 1 ] += v <NEWLINE> <NL> <DEDENT> for b in range ( 4 ) : <NEWLINE> <INDENT> for f in range ( 3 ) : <NEWLINE> <INDENT> print ( <STRING> . join ( map ( str , k [ b ] [ f ] ) ) ) <NEWLINE> <DEDENT> if b != 3 : <NEWLINE> <INDENT> print ( <STRING> * 20 ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> main ( ) <NEWLINE> <NL> def arr ( n ) : <NEWLINE> <INDENT> return [ None ] * n <NEWLINE> <DEDENT>
n = int ( raw_input ( ) ) <NEWLINE> <NL> Mem = [ [ [ 0 for i in range ( 10 ) ] for j in range ( 3 ) ] for k in range ( 4 ) ] <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> C = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> Mem [ C [ 0 ] - 1 ] [ C [ 1 ] - 1 ] [ C [ 2 ] - 1 ] += C [ 3 ] <NEWLINE> <NL> <DEDENT> for i in range ( 4 ) : <NEWLINE> <INDENT> for j in range ( 3 ) : <NEWLINE> <INDENT> print <STRING> , <NEWLINE> for k in range ( 10 ) : <NEWLINE> <INDENT> print Mem [ i ] [ j ] [ k ] , <NEWLINE> <DEDENT> print <STRING> <NEWLINE> <DEDENT> if i != 3 : <NEWLINE> <INDENT> print <STRING> * 20 <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> <NL> x = [ ] <NEWLINE> i = 0 <NEWLINE> for line in sys . stdin : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> lx = int ( line ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x . append ( [ int ( i ) for i in line . split ( ) ] ) <NEWLINE> <DEDENT> i = 1 <NEWLINE> <NL> <DEDENT> rb = range ( 4 ) <NEWLINE> rf = range ( 3 ) <NEWLINE> rr = range ( 10 ) <NEWLINE> rooms = [ [ [ 0 for i in rr ] for j in rf ] for k in rb ] <NEWLINE> for e in x : <NEWLINE> <INDENT> i , j , k , l = e <NEWLINE> rooms [ i - 1 ] [ j - 1 ] [ k - 1 ] += l <NEWLINE> <NL> <DEDENT> for i in rb : <NEWLINE> <INDENT> for j in rf : <NEWLINE> <INDENT> print <STRING> , <NEWLINE> for k in rr : <NEWLINE> <INDENT> print rooms [ i ] [ j ] [ k ] , <NEWLINE> <DEDENT> print <NEWLINE> <DEDENT> if i < len ( rb ) - 1 : print <STRING> * 20 <NEWLINE> <DEDENT>
habitant_dictionary = { } <NEWLINE> for building in range ( 1 , 4 + 1 ) : <NEWLINE> <INDENT> habitant_dictionary [ building ] = [ 0 ] * 30 <NEWLINE> <NL> <DEDENT> information_number = int ( raw_input ( ) ) <NEWLINE> while 0 < information_number : <NEWLINE> <INDENT> data = [ int ( x ) for x in raw_input ( ) . split ( ) ] <NEWLINE> habitant_dictionary [ data [ 0 ] ] [ ( int ( data [ 1 ] ) - 1 ) * 10 + ( int ( data [ 2 ] ) - 1 ) ] += int ( data [ 3 ] ) <NEWLINE> information_number -= 1 <NEWLINE> <NL> <DEDENT> for building in range ( 1 , 4 + 1 ) : <NEWLINE> <INDENT> for i in range ( 0 , 30 , 10 ) : <NEWLINE> <INDENT> print ( <STRING> . join ( [ str ( x ) for x in habitant_dictionary [ building ] [ i : i + 10 ] ] ) ) <NEWLINE> <DEDENT> if building is not 4 : <NEWLINE> <INDENT> print ( <STRING> * 20 ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> house = [ ] <NEWLINE> for i in range ( 4 ) : <NEWLINE> <INDENT> house . append ( [ ] ) <NEWLINE> for j in range ( 3 ) : <NEWLINE> <INDENT> house [ i ] . append ( [ ] ) <NEWLINE> for k in range ( 10 ) : <NEWLINE> <INDENT> house [ i ] [ j ] . append ( 0 ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> b , f , r , v = map ( int , input ( ) . split ( ) ) <NEWLINE> house [ b ] [ f ] [ r ] += v <NEWLINE> <NL> <NL> <DEDENT> for i in range ( 4 ) : <NEWLINE> <INDENT> for j in range ( 3 ) : <NEWLINE> <INDENT> for k in range ( 10 ) : <NEWLINE> <INDENT> print ( <STRING> , house [ i ] [ j ] [ k ] , end = <STRING> ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> <DEDENT> if b < 3 : <NEWLINE> <INDENT> print ( <STRING> * 20 ) <NEWLINE> <DEDENT> <DEDENT>
import numpy as np <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> class ryou : <NEWLINE> <INDENT> def flinit ( self ) : <NEWLINE> <INDENT> room = list ( ) <NEWLINE> for i in range ( 10 ) : <NEWLINE> <INDENT> room += [ 0 ] <NEWLINE> <DEDENT> return room <NEWLINE> <NL> <COMMENT> <NL> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> def kaijo ( x ) : <NEWLINE> <INDENT> print <STRING> , <NEWLINE> for i in range ( len ( x ) - 1 ) : <NEWLINE> <INDENT> print str ( x [ i ] ) , <NEWLINE> <DEDENT> print str ( x [ len ( x ) - 1 ] ) <NEWLINE> <NL> <NL> <COMMENT> <NL> <NL> <DEDENT> floor_11 = ryou ( ) . flinit ( ) <NEWLINE> floor_12 = ryou ( ) . flinit ( ) <NEWLINE> floor_13 = ryou ( ) . flinit ( ) <NEWLINE> floor_21 = ryou ( ) . flinit ( ) <NEWLINE> floor_22 = ryou ( ) . flinit ( ) <NEWLINE> floor_23 = ryou ( ) . flinit ( ) <NEWLINE> floor_31 = ryou ( ) . flinit ( ) <NEWLINE> floor_32 = ryou ( ) . flinit ( ) <NEWLINE> floor_33 = ryou ( ) . flinit ( ) <NEWLINE> floor_41 = ryou ( ) . flinit ( ) <NEWLINE> floor_42 = ryou ( ) . flinit ( ) <NEWLINE> floor_43 = ryou ( ) . flinit ( ) <NEWLINE> <NL> <NL> fldic = { <STRING> : floor_11 , <NEWLINE> <INDENT> <STRING> : floor_12 , <NEWLINE> <STRING> : floor_13 , <NEWLINE> <STRING> : floor_21 , <NEWLINE> <STRING> : floor_22 , <NEWLINE> <STRING> : floor_23 , <NEWLINE> <STRING> : floor_31 , <NEWLINE> <STRING> : floor_32 , <NEWLINE> <STRING> : floor_33 , <NEWLINE> <STRING> : floor_41 , <NEWLINE> <STRING> : floor_42 , <NEWLINE> <STRING> : floor_43 <NEWLINE> } <NEWLINE> <NL> <COMMENT> <NL> <NL> <NL> <COMMENT> <NL> <DEDENT> n = int ( raw_input ( ) ) <NEWLINE> <NL> <COMMENT> <NL> <NL> for l in range ( n ) : <NEWLINE> <INDENT> list_mojiretsu = raw_input ( ) . split ( <STRING> ) <NEWLINE> henka = map ( int , list_mojiretsu ) <NEWLINE> fldic [ str ( henka [ 0 ] ) + str ( henka [ 1 ] ) ] [ henka [ 2 ] - 1 ] += henka [ 3 ] <NEWLINE> <NL> <COMMENT> <NL> <NL> <NL> <NL> <DEDENT> kaijo ( floor_11 ) <NEWLINE> kaijo ( floor_12 ) <NEWLINE> kaijo ( floor_13 ) <NEWLINE> print <STRING> <NEWLINE> kaijo ( floor_21 ) <NEWLINE> kaijo ( floor_22 ) <NEWLINE> kaijo ( floor_23 ) <NEWLINE> print <STRING> <NEWLINE> kaijo ( floor_31 ) <NEWLINE> kaijo ( floor_32 ) <NEWLINE> kaijo ( floor_33 ) <NEWLINE> print <STRING> <NEWLINE> kaijo ( floor_41 ) <NEWLINE> kaijo ( floor_42 ) <NEWLINE> kaijo ( floor_43 ) <NEWLINE> <NL> print <STRING> <NEWLINE> <COMMENT> <NL> <NEWLINE>
L = [ [ [ 0 for i in range ( 10 ) ] for j in range ( 3 ) ] for k in range ( 4 ) ] <NEWLINE> <NL> for x in range ( int ( input ( ) ) ) : <NEWLINE> <INDENT> n = raw_input ( ) . split ( ) <NEWLINE> b = int ( n [ 0 ] ) <NEWLINE> f = int ( n [ 1 ] ) <NEWLINE> r = int ( n [ 2 ] ) <NEWLINE> v = int ( n [ 3 ] ) <NEWLINE> <NL> L [ b - 1 ] [ f - 1 ] [ r - 1 ] += v <NEWLINE> <NL> <DEDENT> for i in L : <NEWLINE> <INDENT> for j in i : <NEWLINE> <INDENT> print <STRING> , <NEWLINE> for k in j : <NEWLINE> <INDENT> print <STRING> . format ( k ) , <NEWLINE> <DEDENT> print <STRING> <NEWLINE> <DEDENT> if i is not L [ 3 ] : print <STRING> * 20 , <STRING> <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> k = [ [ [ 0 for x in range ( 10 ) ] for x in range ( 3 ) ] for x in range ( 4 ) ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> b , f , r , v = map ( int ( raw_input ( ) . split ( ) ) <NEWLINE> k [ b - 1 ] [ f - 1 ] [ r - 1 ] += v <NEWLINE> <DEDENT> for b in range ( 4 ) : <NEWLINE> <INDENT> for f in range ( 3 ) : <NEWLINE> <INDENT> print ( <STRING> + <STRING> . join ( map ( str , k [ b ] [ f ] ) ) ) <NEWLINE> <DEDENT> if b != 3 : <NEWLINE> <INDENT> print ( <STRING> * 20 ) <NEWLINE> <DEDENT> <DEDENT>
l = [ [ [ 0 for i in xrange ( 10 ) ] for j in xrange ( 3 ) ] for k in xrange ( 4 ) ] <NEWLINE> s = <STRING> * 20 + <STRING> <NEWLINE> n = input ( ) <NEWLINE> for i in xrange ( n ) : <NEWLINE> <INDENT> b , f , r , v = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> l [ b - 1 ] [ f - 1 ] [ r - 1 ] += v <NEWLINE> <DEDENT> for i in xrange ( 4 ) : <NEWLINE> <INDENT> for j in xrange ( - 3 , 0 ) : <NEWLINE> <INDENT> print <STRING> + <STRING> . join ( map ( str , l [ i ] [ j ] ) ) <NEWLINE> if i < 3 or j < - 1 : print <NEWLINE> <DEDENT> if i < 3 : print s <NEWLINE> <DEDENT>
import sys <NEWLINE> n = int ( raw_input ( ) ) <NEWLINE> <NL> building_a = [ [ 0 for j in range ( 11 ) ] for i in range ( 4 ) ] <NEWLINE> building_b = [ [ 0 for j in range ( 11 ) ] for i in range ( 4 ) ] <NEWLINE> building_c = [ [ 0 for j in range ( 11 ) ] for i in range ( 4 ) ] <NEWLINE> building_d = [ [ 0 for j in range ( 11 ) ] for i in range ( 4 ) ] <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> b , f , r , v = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if b == 1 : <NEWLINE> <INDENT> building_a [ f ] [ r ] += v <NEWLINE> <DEDENT> elif b == 2 : <NEWLINE> <INDENT> building_b [ f ] [ r ] += v <NEWLINE> <DEDENT> elif b == 3 : <NEWLINE> <INDENT> building_c [ f ] [ r ] += v <NEWLINE> <DEDENT> elif b == 4 : <NEWLINE> <INDENT> building_d [ f ] [ r ] += v <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( 1 , 4 ) : <NEWLINE> <INDENT> for j in range ( 1 , 11 ) : <NEWLINE> <INDENT> print building_a [ i ] [ j ] , <NEWLINE> <DEDENT> print <NEWLINE> <DEDENT> for i in range ( 20 ) : <NEWLINE> <INDENT> sys . stdout . write ( <STRING> ) <NEWLINE> <DEDENT> print <NEWLINE> <NL> for i in range ( 1 , 4 ) : <NEWLINE> <INDENT> for j in range ( 1 , 11 ) : <NEWLINE> <INDENT> print building_b [ i ] [ j ] , <NEWLINE> <DEDENT> print <NEWLINE> <DEDENT> for i in range ( 20 ) : <NEWLINE> <INDENT> sys . stdout . write ( <STRING> ) <NEWLINE> <DEDENT> print <NEWLINE> <NL> for i in range ( 1 , 4 ) : <NEWLINE> <INDENT> for j in range ( 1 , 11 ) : <NEWLINE> <INDENT> print building_c [ i ] [ j ] , <NEWLINE> <DEDENT> print <NEWLINE> <DEDENT> for i in range ( 20 ) : <NEWLINE> <INDENT> sys . stdout . write ( <STRING> ) <NEWLINE> <DEDENT> print <NEWLINE> <NL> for i in range ( 1 , 4 ) : <NEWLINE> <INDENT> for j in range ( 1 , 11 ) : <NEWLINE> <INDENT> print building_d [ i ] [ j ] , <NEWLINE> <DEDENT> print <NEWLINE> <DEDENT>
cards = { <NEWLINE> <INDENT> <STRING> : [ 0 for _ in range ( 13 ) ] , <NEWLINE> <STRING> : [ 0 for _ in range ( 13 ) ] , <NEWLINE> <STRING> : [ 0 for _ in range ( 13 ) ] , <NEWLINE> <STRING> : [ 0 for _ in range ( 13 ) ] , <NEWLINE> <DEDENT> } <NEWLINE> n = int ( input ( ) ) <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> ( s , r ) = input ( ) . split ( ) <NEWLINE> cards [ s ] [ int ( r ) - 1 ] = 1 <NEWLINE> <NL> <DEDENT> for s in ( <STRING> , <STRING> , <STRING> , <STRING> ) : <NEWLINE> <INDENT> for r in range ( 13 ) : <NEWLINE> <INDENT> if cards [ s ] [ r ] == 0 : <NEWLINE> <INDENT> print ( s , r + 1 ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
import numpy as np <NEWLINE> a = np . array ( [ [ 0 ] * 10 ] * 12 ) <NEWLINE> n = int ( input ( ) ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> b , f , r , v = map ( int , input ( ) . split ( ) ) <NEWLINE> a [ 3 * b - 4 + f , r - 1 ] += v <NEWLINE> <DEDENT> for i in range ( 12 ) : <NEWLINE> <INDENT> if i > 0 and i % 3 == 0 : <NEWLINE> <INDENT> print ( <STRING> * 20 ) <NEWLINE> <DEDENT> print ( <STRING> + <STRING> . join ( a [ i , ] ) ) <NEWLINE> <DEDENT>
l = [ [ [ 0 for r in range ( 10 ) ] for f in range ( 3 ) ] for b in range ( 4 ) ] <NEWLINE> n = int ( input ( ) ) <NEWLINE> for num in range ( n ) : <NEWLINE> <INDENT> b , f , r , v = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> data [ b - 1 ] [ f - 1 ] [ r - 1 ] += v <NEWLINE> <DEDENT> for b in range ( 4 ) : <NEWLINE> <INDENT> for f in range ( 3 ) : <NEWLINE> <INDENT> for r in range ( 10 ) : <NEWLINE> <INDENT> print ( <STRING> , l [ b ] [ f ] [ r ] , end = <STRING> ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> <DEDENT> if b != 3 : <NEWLINE> <INDENT> print ( <STRING> * 20 ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( raw_input ( ) ) <NEWLINE> buildings = [ [ [ 0 for i in range ( 10 ) ] for j in range ( 3 ) ] for k in range ( 4 ) ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> b , f , r , v = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> buildings [ b - 1 ] [ f - 1 ] [ r - 1 ] += v <NEWLINE> <COMMENT> <NL> <DEDENT> for i in range ( 4 ) : <NEWLINE> <INDENT> for j in range ( 3 ) : <NEWLINE> <INDENT> ln = <STRING> <NEWLINE> for k in range ( 10 ) : <NEWLINE> <INDENT> ln += str ( buildings [ i ] [ j ] [ k ] ) <NEWLINE> <DEDENT> print ln <NEWLINE> <DEDENT> if i != 3 : print <STRING> * 20 <NEWLINE> <DEDENT>
data = [ [ [ 0 for r in range ( 10 ) ] for f in range ( 3 ) ] for b in range ( 4 ) ] <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> <NL> for _ in range ( n ) : <NEWLINE> <INDENT> ( b , f , r , v ) = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> data [ b - 1 ] [ f - 1 ] [ r - 1 ] += v <NEWLINE> <NL> <DEDENT> for b in range ( 4 ) : <NEWLINE> <INDENT> for f in range ( 3 ) : <NEWLINE> <INDENT> for r in range ( 10 ) : <NEWLINE> <INDENT> print ( <STRING> , data [ b ] [ f ] [ r ] , end = <STRING> ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> <DEDENT> print ( <STRING> * 20 ) <NEWLINE> <DEDENT> ~ <NEWLINE>
rooms = [ [ [ 0 for i in range ( 10 ) ] for j in range ( 3 ) ] for h in range ( 4 ) ] <NEWLINE> n = input ( ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> b , f , r , v = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> rooms [ b - 1 ] [ f - 1 ] [ r - 1 ] = rooms [ b - 1 ] [ f - 1 ] [ r - 1 ] + v <NEWLINE> <NL> <DEDENT> for i in range ( len ( rooms ) ) : <NEWLINE> <INDENT> for j in rooms [ i ] : <NEWLINE> <INDENT> print <STRING> . join ( map ( str , j ) ) <NEWLINE> <DEDENT> if i != 3 : print <STRING> * 20 <NEWLINE> <DEDENT>
data = [ <NEWLINE> <INDENT> [ [ 0 for r in range ( 10 ) ] for f in range ( 3 ) ] for <NEWLINE> <DEDENT> ] <NEWLINE> <NL> count = int ( input ( ) ) <NEWLINE> for c in range ( count ) : <NEWLINE> <INDENT> b , f , r , v = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> data [ b - 1 ] [ f - 1 ] [ r - 1 ] += v <NEWLINE> <NL> <DEDENT> for bi , b in enumerate ( data ) : <NEWLINE> <INDENT> for f in b : <NEWLINE> <INDENT> for r in f : <NEWLINE> <INDENT> print ( <STRING> . format ( r ) , end = <STRING> ) <NEWLINE> <NL> <DEDENT> print ( ) <NEWLINE> <NL> <DEDENT> if bi < 3 : <NEWLINE> <INDENT> print ( <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = [ ] <NEWLINE> <NL> a = [ [ [ 0 ] * 10 for _ in range ( 3 ) ] for _ in range ( 4 ) ] <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> b , f , r , v = map ( int , input ( ) . split ( ) ) <NEWLINE> a [ b ] [ f ] [ r ] += v <NEWLINE> <NL> <DEDENT> for i in range ( 4 ) : <NEWLINE> <INDENT> for j in range ( 3 ) : <NEWLINE> <INDENT> print ( * a [ i ] [ j ] ) <NEWLINE> <DEDENT> print ( <STRING> * 20 ) <NEWLINE> <NL> <NL> <DEDENT>
% time <NEWLINE> num = input ( ) <NEWLINE> L = [ ] <NEWLINE> house = [ ] <NEWLINE> for i in range ( int ( num ) ) : <NEWLINE> <INDENT> k = input ( ) . split ( ) <NEWLINE> k [ 0 ] = int ( k [ 0 ] ) <NEWLINE> k [ 1 ] = int ( k [ 1 ] ) <NEWLINE> k [ 2 ] = int ( k [ 2 ] ) <NEWLINE> k [ 3 ] = int ( k [ 3 ] ) <NEWLINE> L . append ( k ) <NEWLINE> <NL> <DEDENT> for i in range ( 3 ) : <NEWLINE> <INDENT> a = [ <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> b = [ <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> c = [ <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> d = [ <STRING> * 20 ] <NEWLINE> house . append ( [ a , b , c , d ] ) <NEWLINE> <NL> <DEDENT> a = [ <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> b = [ <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> c = [ <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> house . append ( [ a , b , c ] ) <NEWLINE> <NL> for i in L : <NEWLINE> <INDENT> house [ i [ 0 ] - 1 ] [ i [ 1 ] - 1 ] [ i [ 2 ] ] = str ( i [ 3 ] ) <NEWLINE> <NL> <DEDENT> for i in house : <NEWLINE> <INDENT> for j in i : <NEWLINE> <INDENT> k = <STRING> . join ( j ) <NEWLINE> print ( k ) <NEWLINE> <NL> <DEDENT> <DEDENT>
data = [ None ] * 4 <NEWLINE> for i in xrange ( 4 ) : <NEWLINE> <INDENT> data [ i ] = [ None ] * 3 <NEWLINE> for j in xrange ( 3 ) : <NEWLINE> <INDENT> data [ i ] [ j ] = [ 0 ] * 10 <NEWLINE> <NL> <DEDENT> <DEDENT> n = input ( ) <NEWLINE> for i in xrange ( n ) : <NEWLINE> <INDENT> line = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> data [ line [ 0 ] - 1 ] [ line [ 1 ] - 1 ] [ line [ 2 ] - 1 ] += line [ 3 ] <NEWLINE> <NL> <DEDENT> for i in xrange ( 4 ) : <NEWLINE> <INDENT> for j in xrange ( 3 ) : <NEWLINE> <INDENT> s = <STRING> <NEWLINE> for k in xrange ( 9 ) : <NEWLINE> <INDENT> s += str ( data [ i ] [ j ] [ k ] ) <NEWLINE> s += <STRING> <NEWLINE> <DEDENT> s += str ( data [ i ] [ j ] [ 9 ] ) <NEWLINE> print s <NEWLINE> <DEDENT> if i < 3 : <NEWLINE> <INDENT> print <STRING> * 20 <NEWLINE> <DEDENT> <DEDENT>
n = int ( raw_input ( ) ) <NEWLINE> l = [ [ [ 0 for i in range ( 10 ) ] for j in range ( 3 ) ] for k in range ( 4 ) ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> b , f , r , v = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> l [ b - 1 ] [ f - 1 ] [ r - 1 ] += v <NEWLINE> <DEDENT> for i in range ( 4 ) : <NEWLINE> <INDENT> if i != 0 : <NEWLINE> <INDENT> print <STRING> , <NEWLINE> print <STRING> <NEWLINE> <DEDENT> for j in range ( 3 ) : <NEWLINE> <INDENT> print <STRING> , <NEWLINE> for k in range ( 9 ) : <NEWLINE> <INDENT> print <STRING> % l [ i ] [ j ] [ k ] , <NEWLINE> <DEDENT> print l [ i ] [ j ] [ 9 ] <NEWLINE> <DEDENT> <DEDENT>
Residents = [ [ [ 0 for i in range ( 10 ) ] for j in range ( 3 ) ] for k in range ( 4 ) ] <NEWLINE> n = int ( input ( ) ) <NEWLINE> for l in range ( n ) : <NEWLINE> <INDENT> b , f , r , v = list ( map ( int , input ( ) . split ( ) ) <NEWLINE> Residents [ b - 1 ] [ f - 1 ] [ r - 1 ] += v <NEWLINE> <DEDENT> for k in range ( 4 ) : <NEWLINE> <INDENT> for j in range ( 3 ) : <NEWLINE> <INDENT> print ( <STRING> + <STRING> . join ( map ( str , Residents [ k ] [ j ] ) ) ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import sys <NEWLINE> import numpy as np <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> lines = sys . stdin . readlines ( ) <NEWLINE> <NL> <COMMENT> <NL> rooms = [ 0 ] * 10 <NEWLINE> floors = [ rooms ] * 3 <NEWLINE> buildings = [ floors ] * 4 <NEWLINE> <NL> data_num = 0 <NEWLINE> <NL> for index , line in enumerate ( lines ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <INDENT> line = line . strip ( <STRING> ) <NEWLINE> elems = line . split ( <STRING> ) <NEWLINE> if index == 0 : <NEWLINE> <INDENT> data_num = int ( elems [ 0 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> b = int ( elems [ 0 ] ) - 1 <COMMENT> <NEWLINE> f = int ( elems [ 1 ] ) - 1 <COMMENT> <NEWLINE> r = int ( elems [ 2 ] ) - 1 <COMMENT> <NEWLINE> v = int ( elems [ 3 ] ) <COMMENT> <NEWLINE> <COMMENT> <NL> print buildings [ b ] [ f ] [ r ] <NEWLINE> ans = [ ] <NEWLINE> for b_i in range ( 0 , 4 ) : <NEWLINE> <INDENT> b_list = [ ] <NEWLINE> for f_i in range ( 0 , 3 ) : <NEWLINE> <INDENT> f_list = [ ] <NEWLINE> for r_i in range ( 0 , 10 ) : <NEWLINE> <INDENT> if b == b_i and f == f_i and r == r_i : <NEWLINE> <INDENT> f_list . append ( buildings [ b_i ] [ f_i ] [ r_i ] + v ) <NEWLINE> <DEDENT> else : <NEWLINE> <COMMENT> <NL> <INDENT> f_list . append ( buildings [ b_i ] [ f_i ] [ r_i ] ) <NEWLINE> <DEDENT> <DEDENT> b_list . append ( f_list ) <NEWLINE> <DEDENT> ans . append ( b_list ) <NEWLINE> <COMMENT> <NL> <DEDENT> buildings = ans <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> for b_i in range ( 0 , 4 ) : <NEWLINE> <INDENT> for f_i in range ( 0 , 3 ) : <NEWLINE> <INDENT> for r_i in range ( 0 , 10 ) : <NEWLINE> <INDENT> sys . stdout . write ( <STRING> % buildings [ b_i ] [ f_i ] [ r_i ] ) <NEWLINE> <DEDENT> sys . stdout . write ( <STRING> ) <NEWLINE> <DEDENT> print <STRING> <NEWLINE> <NL> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
data = [ [ [ 0 for r in range ( 10 ) ] for r in range ( 3 ) ] for b in range ( 4 ) ] <NEWLINE> n = int ( input ( ) ) <NEWLINE> <NL> for _ in range ( n ) : <NEWLINE> <INDENT> ( b , f , r , v ) = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> <DEDENT> for b in range ( 4 ) : <NEWLINE> <INDENT> for f in range ( 3 ) : <NEWLINE> <INDENT> for r in range ( 10 ) : <NEWLINE> print ( <STRING> , data [ b ] [ f ] [ r ] , end = <STRING> ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> <DEDENT> print ( <STRING> * 20 ) <NEWLINE>
house = [ [ [ 0 for col in range ( 10 ) ] for row in range ( 3 ) ] for layer in range ( 4 ) ] <NEWLINE> n = int ( raw_input ( ) ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> input_line = raw_input ( ) . split ( ) <NEWLINE> house [ int ( input_line [ 0 ] ) - 1 ] [ int ( input_line [ 1 ] ) - 1 ] [ int ( input_line [ 2 ] ) - 1 ] += int ( input_line [ 3 ] ) <NEWLINE> <DEDENT> for i in range ( 0 , 4 ) : <NEWLINE> <INDENT> if i != 0 : <NEWLINE> <INDENT> print <STRING> * 20 <NEWLINE> <DEDENT> for j in range ( 0 , 3 ) : <NEWLINE> <INDENT> for k in range ( 0 , 10 ) : <NEWLINE> <INDENT> if k == 9 : <NEWLINE> <INDENT> print house [ i ] [ j ] [ k ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print house [ i ] [ j ] [ k ] , <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT>
s = [ [ [ 0 for i in range ( 10 ) ] for j in range ( 3 ) ] for k in range ( 4 ) ] <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> b , f , r , v = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> s [ b - 1 ] [ f - 1 ] [ r - 1 ] += v <NEWLINE> <NL> <DEDENT> for b in range ( 4 ) : <NEWLINE> <INDENT> for f in range ( 3 ) : <NEWLINE> <INDENT> print ( <STRING> + <STRING> . join ( map ( str , s [ b ] [ f ] ) ) ) <NEWLINE> <DEDENT> if b != 3 : <NEWLINE> <INDENT> print ( <STRING> * 20 ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
bilt1 = [ 0 ] * 30 <NEWLINE> bilt2 = [ 0 ] * 30 <NEWLINE> bilt3 = [ 0 ] * 30 <NEWLINE> bilt4 = [ 0 ] * 30 <NEWLINE> <NL> sha = <STRING> * 20 <NEWLINE> count = 0 ; <NEWLINE> <NL> x = input ( ) <NEWLINE> for i in range ( x ) : <NEWLINE> <INDENT> b , f , r , v = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if b == 1 : <NEWLINE> <INDENT> bilt1 [ ( ( f - 1 ) * 10 ) + ( r - 1 ) ] = bilt1 [ ( ( f - 1 ) * 10 ) + ( r - 1 ) ] + v <NEWLINE> <DEDENT> elif b == 2 : <NEWLINE> <INDENT> bilt2 [ ( ( f - 1 ) * 10 ) + ( r - 1 ) ] = bilt2 [ ( ( f - 1 ) * 10 ) + ( r - 1 ) ] + v <NEWLINE> <DEDENT> elif b == 3 : <NEWLINE> <INDENT> bilt3 [ ( ( f - 1 ) * 10 ) + ( r - 1 ) ] = bilt3 [ ( ( f - 1 ) * 10 ) + ( r - 1 ) ] + v <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> bilt4 [ ( ( f - 1 ) * 10 ) + ( r - 1 ) ] = bilt4 [ ( ( f - 1 ) * 10 ) + ( r - 1 ) ] + v <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( 3 ) : <NEWLINE> <INDENT> print <STRING> + str ( bilt1 [ i * 10 ] ) , <NEWLINE> for j in range ( 9 ) : <NEWLINE> <INDENT> print bilt1 [ ( i * 10 ) + ( j + 1 ) ] , <NEWLINE> <DEDENT> print <STRING> <NEWLINE> <DEDENT> print sha <NEWLINE> <NL> for i in range ( 3 ) : <NEWLINE> <INDENT> print <STRING> + str ( bilt1 [ i * 10 ] ) , <NEWLINE> for j in range ( 9 ) : <NEWLINE> <INDENT> print bilt2 [ ( i * 10 ) + ( j + 1 ) ] , <NEWLINE> <DEDENT> print <STRING> <NEWLINE> <DEDENT> print sha <NEWLINE> <NL> for i in range ( 3 ) : <NEWLINE> <INDENT> print <STRING> + str ( bilt1 [ i * 10 ] ) , <NEWLINE> for j in range ( 9 ) : <NEWLINE> <INDENT> print bilt3 [ ( i * 10 ) + ( j + 1 ) ] , <NEWLINE> <DEDENT> print <STRING> <NEWLINE> <DEDENT> print sha <NEWLINE> <NL> for i in range ( 3 ) : <NEWLINE> <INDENT> print <STRING> + str ( bilt1 [ i * 10 ] ) , <NEWLINE> for j in range ( 9 ) : <NEWLINE> <INDENT> print bilt4 [ ( i * 10 ) + ( j + 1 ) ] , <NEWLINE> <DEDENT> print <STRING> <NEWLINE> <DEDENT>
data = [ [ [ 0 for r in range ( 10 ) ] for f range ( 3 ) ] for b in range ( 4 ) ] <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> for nc in range ( n ) : <NEWLINE> <INDENT> ( b , f , r , v ) = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> data [ b - 1 ] [ f - 1 ] [ r - 1 ] += v <NEWLINE> <NL> <NL> <DEDENT> for b in range ( 4 ) : <NEWLINE> <INDENT> for f in range ( 3 ) : <NEWLINE> <INDENT> for r in range ( 10 ) : <NEWLINE> <INDENT> print ( <STRING> . format ( data [ b ] [ f ] [ r ] ) , end = <STRING> ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> <DEDENT> print ( <STRING> * 20 ) <NEWLINE> <DEDENT>
bilding = [ [ [ 0 for x in range ( 10 ) ] for x in range ( 3 ) ] for x in range ( 4 ) ] <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> b , f , r , v = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> bilding [ b - 1 ] [ f - 1 ] [ r - 1 ] += v <NEWLINE> <NL> <DEDENT> for i in range ( 4 ) : <NEWLINE> <INDENT> for j in range ( 3 ) : <NEWLINE> <INDENT> print ( <STRING> + <STRING> . join ( str , bilding [ i ] [ j ] ) ) <NEWLINE> <DEDENT> if i % 4 != 0 : <NEWLINE> <INDENT> print <STRING> * 20 <NEWLINE> <DEDENT> <DEDENT>
data = [ <NEWLINE> <INDENT> [ [ 0 for r in range ( 10 ) ] for f in range ( 3 ) ] for b in range ( 4 ) <NEWLINE> <DEDENT> ] <NEWLINE> <NL> count = int ( input ( ) ) <NEWLINE> for c in range ( count ) : <NEWLINE> <INDENT> b , f , r , v = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> data [ b - 1 ] [ f - 1 ] [ r - 1 ] += v <NEWLINE> <NL> <DEDENT> for bi , b in enumerate ( data ) : <NEWLINE> <INDENT> for f in b : <NEWLINE> <INDENT> for r in f : <NEWLINE> <INDENT> print ( <STRING> . format ( r ) , end = <STRING> ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> print ( ) <NEWLINE> <DEDENT> if bi < 3 : <NEWLINE> <INDENT> print ( <STRING> * 20 ) <NEWLINE> <DEDENT> <DEDENT>
a = [ [ [ 0 for r in range ( 10 ) ] for f in range ( 3 ) ] for b in range ( 4 ) ] <NEWLINE> ans = <STRING> <NEWLINE> <NL> n = input ( ) <NEWLINE> for i in range ( 0 , n ) : <NEWLINE> <INDENT> b , f , r , v = map ( int , raw_input ( ) . split ( <STRING> ) ) <NEWLINE> a [ b - 1 ] [ f - 1 ] [ r - 1 ] += v <NEWLINE> <NL> <DEDENT> for b in range ( 4 ) : <NEWLINE> <INDENT> for f in range ( 3 ) : <NEWLINE> <INDENT> for r in range ( 10 ) : <NEWLINE> <INDENT> ans += <STRING> + str ( a [ b ] [ f ] [ r ] ) <NEWLINE> <DEDENT> ans += <STRING> <NEWLINE> <DEDENT> if ( b != 3 ) : <NEWLINE> <INDENT> ans += <STRING> * 20 + <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
home = [ [ [ 0 for r in range ( 10 ) ] for f in range ( 3 ) ] for b in range ( 4 ) ] <NEWLINE> n = int ( raw_input ( ) ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> b , f , r , v = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> home [ b - 1 ] [ f - 1 ] [ r - 1 ] += v <NEWLINE> <NL> <DEDENT> for i in range ( 4 ) : <NEWLINE> <INDENT> for j in range ( 3 ) : <NEWLINE> <INDENT> print <STRING> , <NEWLINE> print <STRING> . join ( map ( str , home [ i ] [ j ] ) ) <NEWLINE> if j == 2 and i != 3 <NEWLINE> <INDENT> print <STRING> * 20 <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
<COMMENT> <NL> <NL> class residence ( object ) : <NEWLINE> <INDENT> def __init__ ( self ) : <NEWLINE> <INDENT> one = [ 0 ] * 10 <NEWLINE> two = [ 0 ] * 10 <NEWLINE> three = [ 0 ] * 10 <NEWLINE> self . all = [ one , two , three ] <NEWLINE> <NL> <DEDENT> <DEDENT> residences = [ ] <NEWLINE> <NL> for i in xrange ( 4 ) : <NEWLINE> <INDENT> residences . append ( residence ( ) ) <NEWLINE> <NL> <DEDENT> n = int ( raw_input ( ) ) <NEWLINE> <NL> for i in xrange ( n ) : <NEWLINE> <INDENT> b , f , r , v = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> residences [ b - 1 ] . all [ f - 1 ] [ r - 1 ] += v <NEWLINE> <NL> <DEDENT> for i , residence in enumerate ( residences ) : <NEWLINE> <INDENT> for floor in residence . all : <NEWLINE> <INDENT> for index , num in enumerate ( floor ) : <NEWLINE> <INDENT> if index == len ( floor ) - 1 : <NEWLINE> <INDENT> print num <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print num , <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if i != len ( residences ) - 1 : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> <DEDENT>
inf = int ( input ( ) ) <NEWLINE> i = 0 <NEWLINE> table = [ ] <NEWLINE> buil = [ [ [ 0 ] * 10 for i in range ( 3 ) ] for i in range ( 4 ) ] <NEWLINE> <NL> while ( i < inf ) : <NEWLINE> <INDENT> b , f , r , v = map ( int , input ( ) . split ( ) ) <NEWLINE> b -= 1 <NEWLINE> f -= 1 <NEWLINE> r -= 1 <NEWLINE> buil [ b ] [ f ] [ r ] += c <NEWLINE> if buil [ b ] [ f ] [ r ] > 9 : buil [ b ] [ f ] [ r ] = 9 <NEWLINE> elif buil [ b ] [ f ] [ r ] < 0 : buil [ b ] [ f ] [ r ] = 0 <NEWLINE> i += 1 <NEWLINE> <NL> <DEDENT> for i in range ( 4 ) : <NEWLINE> <INDENT> if i != 0 : print ( <STRING> * 20 ) <NEWLINE> for j in range ( 3 ) : <NEWLINE> <INDENT> for k in range ( 10 ) : <NEWLINE> <INDENT> print ( <STRING> % ( buil [ i ] [ j ] [ k ] ) , end = <STRING> ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT>
of = [ [ 0 for i in range ( 10 ) ] for j in range ( 12 ) ] <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> b , f , r , v = map ( int , input ( ) . split ( ) ) <NEWLINE> of [ 3 * ( b - 1 ) + f ] [ r ] += v <NEWLINE> <NL> <DEDENT> for i in range ( 12 ) : <NEWLINE> <INDENT> if i % 3 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> for j in range ( 10 ) : <NEWLINE> <INDENT> print ( <STRING> , of [ i ] [ j ] , sep = <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
build = range ( 1 , 5 ) <NEWLINE> floor = range ( 1 , 4 ) <NEWLINE> dic = { } <NEWLINE> for b in build : <NEWLINE> <INDENT> dic [ b ] = { } <NEWLINE> for f in floor : <NEWLINE> <INDENT> dic [ b ] [ f ] = [ 0 ] * 10 <NEWLINE> <NL> <DEDENT> <DEDENT> n = input ( ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> info = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> dic [ info [ 0 ] ] [ info [ 1 ] ] [ info [ 2 ] - 1 ] += info [ 3 ] <NEWLINE> if dic [ info [ 0 ] ] [ info [ 1 ] ] [ info [ 2 ] - 1 ] > 9 : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> for b in build : <NEWLINE> <INDENT> for f in floor : <NEWLINE> <INDENT> print <STRING> , <NEWLINE> print <STRING> . join ( map ( str , dic [ b ] [ f ] ) ) <NEWLINE> <DEDENT> if b != 4 : <NEWLINE> <INDENT> print <STRING> * 20 <NEWLINE> <DEDENT> <DEDENT>
rooms = [ ] <NEWLINE> rooms . append ( [ [ 0 for i in range ( 10 ) ] for j in range ( 3 ) ] ) <NEWLINE> rooms . append ( [ [ 0 for i in range ( 10 ) ] for j in range ( 3 ) ] ) <NEWLINE> rooms . append ( [ [ 0 for i in range ( 10 ) ] for j in range ( 3 ) ] ) <NEWLINE> rooms . append ( [ [ 0 for i in range ( 10 ) ] for j in range ( 3 ) ] ) <NEWLINE> <NL> num = int ( raw_input ( ) ) <NEWLINE> for i in range ( num ) : <NEWLINE> <INDENT> b , f , r , v = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> rooms [ b - 1 ] [ f - 1 ] [ r - 1 ] += v <NEWLINE> <NL> <DEDENT> for number , room in enumerate ( rooms ) : <NEWLINE> <INDENT> for row in room : <NEWLINE> <INDENT> print <STRING> , <NEWLINE> for r in row : <NEWLINE> <INDENT> print <STRING> % r , <NEWLINE> <DEDENT> print <STRING> , <NEWLINE> <DEDENT> if len ( rooms ) - 1 > number : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
a = [ [ [ 0 ] * 10 ] * 3 ] * 4 <NEWLINE> for _ in range ( int ( input ( ) ) ) : <NEWLINE> <INDENT> b , f , r , v = map ( int , input ( ) . split ( ) ) <NEWLINE> a [ b - 1 ] [ f - 1 ] [ r - 1 ] += v <NEWLINE> <DEDENT> for i in range ( 4 ) : <NEWLINE> <INDENT> for j in range ( 3 ) : <NEWLINE> <INDENT> print ( <STRING> . join ( a [ i ] [ j ] ) ) <NEWLINE> <DEDENT> if i != 3 : print ( <STRING> * 20 ) <NEWLINE> <DEDENT>
dic = { } <NEWLINE> for b in range ( 1 , 5 ) : <NEWLINE> <INDENT> for f in range ( 1 , 4 ) : <NEWLINE> <INDENT> for r in range ( 1 , 11 ) : <NEWLINE> <INDENT> dic [ ( b , f , r ) ] = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> n = int ( raw_input ( ) ) <NEWLINE> for k in range ( n ) : <NEWLINE> <INDENT> b , f , r , v = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> dic [ ( b , f , r ) ] += v <NEWLINE> <NL> <DEDENT> j = 0 <NEWLINE> for b in range ( 1 , 5 ) : <NEWLINE> <INDENT> for f in range ( 1 , 4 ) : <NEWLINE> <INDENT> ls = [ ] <NEWLINE> for r in range ( 1 , 11 ) : <NEWLINE> <INDENT> ls . append ( dic [ ( b , f , r ) ] ) <NEWLINE> <DEDENT> print <STRING> . join ( map ( str , ls ) ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> if j < 3 : <NEWLINE> <INDENT> print <STRING> * 20 <NEWLINE> <DEDENT> j += 1 <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> data = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ] <NEWLINE> nums = [ [ [ 0 for i in range ( 10 ) ] for i in range ( 3 ) ] for i in range ( 4 ) ] <NEWLINE> for d in data : <NEWLINE> <INDENT> nums [ d [ 0 ] - 1 ] [ d [ 1 ] - 1 ] [ d [ 2 ] - 1 ] += d [ 3 ] <NEWLINE> <DEDENT> for i in range ( 4 ) : <NEWLINE> <INDENT> for j in range ( 3 ) : <NEWLINE> <INDENT> for k in range ( 10 ) : <NEWLINE> <INDENT> print ( <STRING> + nums [ i ] [ j ] [ k ] , end = <STRING> ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> <DEDENT> if i != 3 : <NEWLINE> <INDENT> print ( <STRING> * 20 ) <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> <NL> S = [ [ [ 0 for k in xrange ( 10 ) ] for j in xrange ( 3 ) ] for i in xrange ( 4 ) ] <NEWLINE> <NL> n = input ( ) <NEWLINE> <NL> for l in xrange ( n ) : <NEWLINE> <INDENT> b , f , r , v = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> S [ b - 1 ] [ f - 1 ] [ r - 1 ] += v <NEWLINE> <NL> <DEDENT> for k in xrange ( 4 ) : <NEWLINE> <INDENT> for j in xrange ( 3 ) : <NEWLINE> <INDENT> for i in xrange ( 9 ) : <NEWLINE> <INDENT> tmp = str ( S [ k ] [ j ] [ i ] ) + <STRING> <NEWLINE> sys . stdout . write ( tmp ) <NEWLINE> <DEDENT> print <STRING> % S [ k ] [ j ] [ 9 ] <NEWLINE> <DEDENT> if k != 3 : <NEWLINE> <INDENT> print <STRING> * 20 <NEWLINE> <DEDENT> <DEDENT>
_1_1 = [ ] <NEWLINE> _1_2 = [ ] <NEWLINE> _1_3 = [ ] <NEWLINE> _2_1 = [ ] <NEWLINE> _2_2 = [ ] <NEWLINE> _2_3 = [ ] <NEWLINE> _3_1 = [ ] <NEWLINE> _3_2 = [ ] <NEWLINE> _3_3 = [ ] <NEWLINE> _4_1 = [ ] <NEWLINE> _4_2 = [ ] <NEWLINE> _4_3 = [ ] <NEWLINE> for i in range ( 10 ) : <NEWLINE> <INDENT> _1_1 . append ( 0 ) <NEWLINE> _1_2 . append ( 0 ) <NEWLINE> _1_3 . append ( 0 ) <NEWLINE> _2_1 . append ( 0 ) <NEWLINE> _2_2 . append ( 0 ) <NEWLINE> _2_3 . append ( 0 ) <NEWLINE> _3_1 . append ( 0 ) <NEWLINE> _3_2 . append ( 0 ) <NEWLINE> _3_3 . append ( 0 ) <NEWLINE> _4_1 . append ( 0 ) <NEWLINE> _4_2 . append ( 0 ) <NEWLINE> _4_3 . append ( 0 ) <NEWLINE> <DEDENT> N = int ( input ( ) ) <NEWLINE> s = [ input ( ) for i in range ( N ) ] <NEWLINE> bfrv = [ ] <NEWLINE> for i in s : <NEWLINE> <INDENT> bfrv . append ( i . split ( ) ) <NEWLINE> <DEDENT> for i in bfrv : <NEWLINE> <INDENT> if int ( i [ 0 ] ) == 1 and int ( i [ 1 ] ) == 1 : <NEWLINE> <INDENT> _1_1 [ int ( i [ 2 ] ) - 1 ] += int ( i [ 3 ] ) <NEWLINE> <DEDENT> elif int ( i [ 0 ] ) == 1 and int ( i [ 1 ] ) == 2 : <NEWLINE> <INDENT> _1_2 [ int ( i [ 2 ] ) - 1 ] += int ( i [ 3 ] ) <NEWLINE> <DEDENT> elif int ( i [ 0 ] ) == 1 and int ( i [ 1 ] ) == 3 : <NEWLINE> <INDENT> _1_3 [ int ( i [ 2 ] ) - 1 ] += int ( i [ 3 ] ) <NEWLINE> <DEDENT> elif int ( i [ 0 ] ) == 2 and int ( i [ 1 ] ) == 1 : <NEWLINE> <INDENT> _2_1 [ int ( i [ 2 ] ) - 1 ] += int ( i [ 3 ] ) <NEWLINE> <DEDENT> elif int ( i [ 0 ] ) == 2 and int ( i [ 1 ] ) == 2 : <NEWLINE> <INDENT> _2_2 [ int ( i [ 2 ] ) - 1 ] += int ( i [ 3 ] ) <NEWLINE> <DEDENT> elif int ( i [ 0 ] ) == 2 and int ( i [ 1 ] ) == 3 : <NEWLINE> <INDENT> _2_3 [ int ( i [ 2 ] ) - 1 ] += int ( i [ 3 ] ) <NEWLINE> <DEDENT> elif int ( i [ 0 ] ) == 3 and int ( i [ 1 ] ) == 1 : <NEWLINE> <INDENT> _3_1 [ int ( i [ 2 ] ) - 1 ] += int ( i [ 3 ] ) <NEWLINE> <DEDENT> elif int ( i [ 0 ] ) == 3 and int ( i [ 1 ] ) == 2 : <NEWLINE> <INDENT> _3_2 [ int ( i [ 2 ] ) - 1 ] += int ( i [ 3 ] ) <NEWLINE> <DEDENT> elif int ( i [ 0 ] ) == 3 and int ( i [ 1 ] ) == 3 : <NEWLINE> <INDENT> _3_3 [ int ( i [ 2 ] ) - 1 ] += int ( i [ 3 ] ) <NEWLINE> <DEDENT> elif int ( i [ 0 ] ) == 4 and int ( i [ 1 ] ) == 1 : <NEWLINE> <INDENT> _4_1 [ int ( i [ 2 ] ) - 1 ] += int ( i [ 3 ] ) <NEWLINE> <DEDENT> elif int ( i [ 0 ] ) == 4 and int ( i [ 1 ] ) == 2 : <NEWLINE> <INDENT> _4_2 [ int ( i [ 2 ] ) - 1 ] += int ( i [ 3 ] ) <NEWLINE> <DEDENT> elif int ( i [ 0 ] ) == 4 and int ( i [ 1 ] ) == 3 : <NEWLINE> <INDENT> _4_3 [ int ( i [ 2 ] ) - 1 ] += int ( i [ 3 ] ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> , * _1_1 ) <NEWLINE> print ( <STRING> , * _1_2 ) <NEWLINE> print ( <STRING> , * _1_3 ) <NEWLINE> pritn ( <STRING> * 20 ) <NEWLINE> print ( <STRING> , * _2_1 ) <NEWLINE> print ( <STRING> , * _2_2 ) <NEWLINE> print ( <STRING> , * _2_3 ) <NEWLINE> print ( <STRING> * 20 ) <NEWLINE> print ( <STRING> , * _3_1 ) <NEWLINE> print ( <STRING> , * _3_2 ) <NEWLINE> print ( <STRING> , * _3_3 ) <NEWLINE> print ( <STRING> * 20 ) <NEWLINE> print ( <STRING> , * _4_1 ) <NEWLINE> print ( <STRING> , * _4_2 ) <NEWLINE> print ( <STRING> , * _4_3 ) <NEWLINE>
<COMMENT> <NL> <NL> dic = { } <NEWLINE> bui = [ k for k in range ( 1 , 5 ) ] <NEWLINE> flo = [ k for k in range ( 1 , 4 ) ] <NEWLINE> roo = [ k for k in range ( 1 , 11 ) ] <NEWLINE> <NL> for b in bui : <NEWLINE> <INDENT> for f in flo : <NEWLINE> <INDENT> for r in roo : <NEWLINE> <INDENT> dic [ ( b , f , r ) ] = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> n = input ( ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> list = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> b = list [ 0 ] <NEWLINE> f = list [ 1 ] <NEWLINE> r = list [ 2 ] <NEWLINE> dic [ ( b , f , r ) ] += list [ 3 ] <NEWLINE> <NL> <DEDENT> for b in bui : <NEWLINE> <INDENT> for f in flo : <NEWLINE> <INDENT> print <STRING> , <NEWLINE> for r in roo : <NEWLINE> <INDENT> print dic [ ( b , f , r ) ] , <NEWLINE> <DEDENT> print <STRING> <NEWLINE> <DEDENT> if b < 4 : <NEWLINE> <INDENT> print <STRING> * 20 <NEWLINE> <DEDENT> <DEDENT>
Adr = [ [ [ 0 for r in range ( 10 ) ] for f in range ( 3 ) ] for b in range ( 4 ) ] <NEWLINE> <NL> n = input ( ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> Inf = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> <NL> Adr [ Inf [ 0 ] - 1 ] [ Inf [ 1 ] - 1 ] [ Inf [ 2 ] - 1 ] += Inf [ 3 ] <NEWLINE> <NL> <DEDENT> for b in range ( 4 ) : <NEWLINE> <INDENT> for f in range ( 3 ) : <NEWLINE> <INDENT> print <STRING> , <NEWLINE> for r in range ( 10 ) : <NEWLINE> <INDENT> if r != 9 : <NEWLINE> <INDENT> print Adr [ b ] [ f ] [ r ] , <NEWLINE> <DEDENT> if r == 9 : <NEWLINE> <INDENT> print Adr [ b ] [ f ] [ r ] <NEWLINE> <DEDENT> <DEDENT> print <STRING> <NEWLINE> <NL> <DEDENT> if b < 3 : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> <DEDENT>
house_info = [ [ [ 0 for i in xrange ( 10 ) ] for j in xrange ( 3 ) ] for k in xrange ( 4 ) ] <NEWLINE> <NL> n = input ( ) <NEWLINE> <NL> for i in xrange ( n ) : <NEWLINE> <INDENT> b , f , r , v = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> house_info [ b - 1 ] [ f - 1 ] [ r - 1 ] = v <NEWLINE> <NL> <DEDENT> for i in xrange ( 4 ) : <NEWLINE> <INDENT> for j in xrange ( 3 ) : <NEWLINE> <INDENT> result = <STRING> . join ( map ( str , house_info [ i ] [ j ] ) ) <NEWLINE> print result <NEWLINE> <DEDENT> if i < 3 : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> <DEDENT>
data = [ [ [ 0 for r in range ( 10 ) ] for f in range ( 3 ) ] for b in range ( 4 ) ] <NEWLINE> ans = <STRING> <NEWLINE> n = input ( ) <NEWLINE> for i in range ( 0 , n ) : <NEWLINE> <INDENT> b , f , r , v = map ( int , raw_input ( ) . split ( <STRING> ) ) <NEWLINE> data [ b - 1 ] [ f - 1 ] [ r - 1 ] += v <NEWLINE> <NL> <DEDENT> for b in range ( 4 ) : <NEWLINE> <INDENT> for f in range ( 3 ) : <NEWLINE> <INDENT> for r in range ( 10 ) : <NEWLINE> <INDENT> ans += <STRING> + str ( a [ b ] [ f ] [ r ] ) <NEWLINE> <DEDENT> if ( b != 3 or f != 2 or r != 9 ) : <NEWLINE> <INDENT> ans += <STRING> <NEWLINE> <DEDENT> <DEDENT> if ( b != 3 ) : <NEWLINE> <INDENT> ans += <STRING> * 20 + <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
data = [ <NEWLINE> <INDENT> [ [ 0 for r in range ( 10 ) ] for f in range ( 3 ) ] for b in range ( 4 ) <NEWLINE> <DEDENT> ] <NEWLINE> <NL> <NL> count = int ( input ( ) ) <NEWLINE> for c in range ( count ) : <NEWLINE> <INDENT> b , f , r , v = [ int ( i ) i in input ( ) . split ( ) ] <NEWLINE> data [ b - 1 ] [ f - 1 ] [ r - 1 ] += v <NEWLINE> <NL> <DEDENT> for bi , b in enumerate ( data ) : <NEWLINE> <INDENT> for f in b : <NEWLINE> <INDENT> for r in f : <NEWLINE> <INDENT> print ( <STRING> . format ( r ) , end = <STRING> ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> <NL> <DEDENT> if bi < 3 : <NEWLINE> <INDENT> print ( <STRING> * 20 ) <NEWLINE> <DEDENT> <DEDENT>
l = [ [ [ 0 for i in range ( 10 ) ] for j in range ( 3 ) ] for k in range ( 4 ) ] <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> b , f , r , v = [ int ( i ) for input ( ) . split ( ) ] <NEWLINE> l [ b - 1 ] [ f - 1 ] [ r - 1 ] += v <NEWLINE> <NL> <DEDENT> for b in range ( 4 ) : <NEWLINE> <INDENT> for f in range ( 3 ) : <NEWLINE> <INDENT> out = <STRING> <NEWLINE> for r in range ( 10 ) : <NEWLINE> <INDENT> out += <STRING> + str ( l [ b ] [ f ] [ r ] ) <NEWLINE> <DEDENT> print ( out ) <NEWLINE> <DEDENT> if 3 != b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <NL> n = input ( ) <NEWLINE> <NL> A = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> A . append ( raw_input ( ) . split ( ) ) <NEWLINE> <NL> <DEDENT> buil1 = [ [ 0 for i in range ( 10 ) ] for j in range ( 3 ) ] <NEWLINE> buil2 = [ [ 0 for i in range ( 10 ) ] for j in range ( 3 ) ] <NEWLINE> buil3 = [ [ 0 for i in range ( 10 ) ] for j in range ( 3 ) ] <NEWLINE> buil4 = [ [ 0 for i in range ( 10 ) ] for j in range ( 3 ) ] <NEWLINE> <NL> b = [ ] <NEWLINE> f = [ ] <NEWLINE> r = [ ] <NEWLINE> v = [ ] <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> b . append ( int ( A [ i ] [ 0 ] ) ) <NEWLINE> f . append ( int ( A [ i ] [ 1 ] ) ) <NEWLINE> r . append ( int ( A [ i ] [ 2 ] ) ) <NEWLINE> v . append ( int ( A [ i ] [ 3 ] ) ) <NEWLINE> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> if b [ i ] == 1 : <NEWLINE> <INDENT> buil1 [ f [ i ] - 1 ] [ r [ i ] - 1 ] += v [ i ] <NEWLINE> <DEDENT> elif b [ i ] == 2 : <NEWLINE> <INDENT> buil2 [ f [ i ] - 1 ] [ r [ i ] - 1 ] += v [ i ] <NEWLINE> <DEDENT> elif b [ i ] == 3 : <NEWLINE> <INDENT> buil3 [ f [ i ] - 1 ] [ r [ i ] - 1 ] += v [ i ] <NEWLINE> <DEDENT> elif b [ i ] == 4 : <NEWLINE> <INDENT> buil4 [ f [ i ] - 1 ] [ r [ i ] - 1 ] += v [ i ] <NEWLINE> <NL> <NL> <NL> <DEDENT> <DEDENT> for i in range ( 3 ) : <NEWLINE> <INDENT> print <STRING> , <NEWLINE> for j in range ( 10 ) : <NEWLINE> <INDENT> print buil1 [ i ] [ j ] , <NEWLINE> <DEDENT> print <STRING> <NEWLINE> <NL> <DEDENT> print <STRING> * 20 <NEWLINE> for i in range ( 3 ) : <NEWLINE> <INDENT> print <STRING> , <NEWLINE> for j in range ( 10 ) : <NEWLINE> <INDENT> print buil2 [ i ] [ j ] , <NEWLINE> <DEDENT> print <STRING> <NEWLINE> <NL> <DEDENT> print <STRING> * 20 <NEWLINE> for i in range ( 3 ) : <NEWLINE> <INDENT> print <STRING> , <NEWLINE> for j in range ( 10 ) : <NEWLINE> <INDENT> print buil3 [ i ] [ j ] , <NEWLINE> <DEDENT> print <STRING> <NEWLINE> <NL> <DEDENT> print <STRING> * 20 <NEWLINE> for i in range ( 3 ) : <NEWLINE> <INDENT> print <STRING> , <NEWLINE> for j in range ( 10 ) : <NEWLINE> <INDENT> print buil4 [ i ] [ j ] , <NEWLINE> <DEDENT> print <STRING> <NEWLINE> <NL> <NL> <DEDENT>
data = [ <NEWLINE> <INDENT> [ [ 0 for r in range ( 10 ) ] for f in range ( 3 ) ] for b in range ( 4 ) <NEWLINE> <DEDENT> ] <NEWLINE> <NL> <COMMENT> <NL> n = int ( input ( ) ) <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> ( b , f , r , v ) = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> data [ b - 1 ] [ f - 1 ] [ r - 1 ] += v <NEWLINE> <NL> <DEDENT> for b in range ( 4 ) : <NEWLINE> <INDENT> for f in range ( 3 ) : <NEWLINE> <INDENT> for r in range ( 10 ) : <NEWLINE> <NL> <DEDENT> <DEDENT> for bi , b in enumerate ( data ) : <NEWLINE> <INDENT> for f in b : <NEWLINE> <INDENT> for r in f : <NEWLINE> <INDENT> print ( <STRING> . format ( r ) , end = <STRING> ) <NEWLINE> <NL> <DEDENT> print ( ) <NEWLINE> <NL> <DEDENT> if bi < 3 : <NEWLINE> <INDENT> print ( <STRING> * 20 ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( raw_input ( ) ) <NEWLINE> <NL> info = [ [ [ 0 for i in range ( 10 ) ] for j in range ( 3 ) ] for k in range ( 4 ) ] <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> b , f , r , v = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> b , f , r = b - 1 , f - 1 , r - 1 <NEWLINE> info [ b ] [ f ] [ r ] += v <NEWLINE> <NL> <DEDENT> sharp = False <NEWLINE> for i in info : <NEWLINE> <INDENT> if sharp : <NEWLINE> <INDENT> print <STRING> * 20 <NEWLINE> <DEDENT> for j in i : <NEWLINE> <INDENT> print <STRING> . join ( map ( str , j ) ) <NEWLINE> <DEDENT> sharp = True <NEWLINE> <DEDENT>
n = input ( ) <NEWLINE> house = [ [ [ ] , [ ] , [ ] ] , [ [ ] , [ ] , [ ] ] , [ [ ] , [ ] , [ ] ] , [ [ ] , [ ] , [ ] ] ] <NEWLINE> for i in range ( 4 ) : <NEWLINE> <INDENT> for j in range ( 3 ) : <NEWLINE> <INDENT> for k in range ( 10 ) : <NEWLINE> <INDENT> house [ i ] [ j ] . append ( 0 ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> b , f , r , v = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> house [ b - 1 ] [ f - 1 ] [ r - 1 ] += v <NEWLINE> <DEDENT> for i in range ( 4 ) : <NEWLINE> <INDENT> for j in range ( 3 ) : <NEWLINE> <INDENT> print ( <STRING> . join ( map ( str , house [ i ] [ j ] ) ) ) <NEWLINE> <DEDENT> if i != 3 : <NEWLINE> <INDENT> print ( <STRING> * 20 ) <NEWLINE> <DEDENT> <DEDENT>
def out ( bnum ) : <NEWLINE> <INDENT> print ( <STRING> + str ( bnum [ <STRING> ] ) . replace ( <STRING> , <STRING> ) [ 1 : 10 * 2 ] ) <NEWLINE> print ( <STRING> + str ( bnum [ <STRING> ] ) . replace ( <STRING> , <STRING> ) [ 1 : 10 * 2 ] ) <NEWLINE> print ( <STRING> + str ( bnum [ <STRING> ] ) . replace ( <STRING> , <STRING> ) [ 1 : 10 * 2 ] ) <NEWLINE> <NL> <DEDENT> def init ( bnum ) : <NEWLINE> <INDENT> bnum = { <STRING> : [ 0 ] * 10 , <STRING> : [ 0 ] * 10 , <STRING> : [ 0 ] * 10 } <NEWLINE> return bnum <NEWLINE> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> b1 = init ( b1 ) <NEWLINE> b2 = init ( b2 ) <NEWLINE> b3 = init ( b3 ) <NEWLINE> b4 = init ( b4 ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> b , f , r , v = input ( ) . split ( ) <NEWLINE> f += <STRING> <NEWLINE> rint = int ( r ) - 1 <NEWLINE> vint = int ( v ) <NEWLINE> if b == <STRING> : <NEWLINE> <INDENT> b1 [ f ] [ rint ] += vint <NEWLINE> <DEDENT> elif b == <STRING> : <NEWLINE> <INDENT> b2 [ f ] [ rint ] += vint <NEWLINE> <DEDENT> elif b == <STRING> : <NEWLINE> <INDENT> b3 [ f ] [ rint ] += vint <NEWLINE> <DEDENT> elif b == <STRING> : <NEWLINE> <INDENT> b4 [ f ] [ rint ] += vint <NEWLINE> <NL> <DEDENT> <DEDENT> out ( b1 ) <NEWLINE> print ( <STRING> * 20 ) <NEWLINE> out ( b2 ) <NEWLINE> print ( <STRING> * 20 ) <NEWLINE> out ( b3 ) <NEWLINE> print ( <STRING> * 20 ) <NEWLINE> out ( b4 ) <NEWLINE>
def perl ( ) : <NEWLINE> <INDENT> for i in range ( 4 ) : <NEWLINE> <INDENT> for j in range ( 3 ) : <NEWLINE> <INDENT> for k in range ( 10 ) : <NEWLINE> <INDENT> print l [ i ] [ j ] [ k ] , <NEWLINE> <DEDENT> print <NEWLINE> <DEDENT> if i != 3 : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> n = int ( raw_input ( ) ) <NEWLINE> l = [ [ [ 0 for k in range ( 10 ) ] for j in range ( 3 ) ] for i in range ( 4 ) ] <NEWLINE> for N in range ( n ) : <NEWLINE> <INDENT> e = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> b = e [ 0 ] - 1 <NEWLINE> f = e [ 1 ] - 1 <NEWLINE> r = e [ 2 ] - 1 <NEWLINE> l [ b ] [ f ] [ r ] += e [ 3 ] <NEWLINE> <DEDENT> perl ( ) <NEWLINE>
import sys <NEWLINE> <NL> n = input ( ) <NEWLINE> a_uni = [ [ [ 0 for i in range ( 10 ) ] for i in range ( 3 ) ] for i in range ( 4 ) ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> b , f , r , v = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> a_uni [ b - 1 ] [ f - 1 ] [ r - 1 ] += v <NEWLINE> <DEDENT> for i in range ( 4 ) : <NEWLINE> <INDENT> for j in range ( 3 ) : <NEWLINE> <INDENT> for k in range ( 10 ) : <NEWLINE> <INDENT> if k == 9 : <NEWLINE> <INDENT> print ( a_uni [ i ] [ j ] [ k ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> sys . stdout . write ( str ( a_uni [ i ] [ j ] [ k ] ) ) <NEWLINE> sys . stdout . write ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if not i == 3 : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> <DEDENT>
l = [ 0 ] * 120 <NEWLINE> s = <STRING> * 20 <NEWLINE> for i in range ( input ( ) ) : b , f , r , v = map ( int , raw_input ( ) . split ( ) ) ; l [ b * 30 + f * 10 + r - 41 ] += v <NEWLINE> print <STRING> , <NEWLINE> for i in range ( 120 ) : <NEWLINE> <INDENT> print l [ i ] , ; j = i + 1 <NEWLINE> if j == 120 : break <NEWLINE> if j % 30 == 0 : print <STRING> + s , <NEWLINE> if j % 10 == 0 : print ; print <STRING> , <NEWLINE> <DEDENT>
def print_residence ( residence ) : <NEWLINE> <INDENT> for i in range ( 4 ) : <NEWLINE> <INDENT> for j in range ( 3 ) : <NEWLINE> <INDENT> print <STRING> . join ( map ( str , residence [ i ] [ j ] ) ) <NEWLINE> <DEDENT> if i != 3 : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> n = int ( raw_input ( ) ) <NEWLINE> residence = [ [ [ 0 ] * 10 for i in range ( 3 ) ] for j in range ( 4 ) ] <NEWLINE> <COMMENT> <NL> <NL> for i in range ( n ) : <NEWLINE> <INDENT> info = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> residence [ info [ 0 ] - 1 ] [ info [ 1 ] - 1 ] [ info [ 2 ] - 1 ] += info [ 3 ] <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> print_residence ( residence ) <NEWLINE>
import sys <NEWLINE> <NL> n = input ( ) <NEWLINE> x = { } <NEWLINE> <NL> for i in range ( 1 , 5 ) : <NEWLINE> <INDENT> for j in range ( 1 , 4 ) : <NEWLINE> <INDENT> for k in range ( 1 , 11 ) : <NEWLINE> <INDENT> x [ ( i , j , k ) ] = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> b , f , r , v = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> x [ ( b , f , r ) ] += v <NEWLINE> <NL> <DEDENT> for i in range ( 1 , 5 ) : <NEWLINE> <INDENT> for j in range ( 1 , 4 ) : <NEWLINE> <INDENT> for k in range ( 1 , 11 ) : <NEWLINE> <INDENT> sys . stdout . write ( <STRING> ) <NEWLINE> sys . stdout . write ( str ( x [ ( i , j , k ) ] ) ) <NEWLINE> <DEDENT> print <NEWLINE> <DEDENT> if ( i != 4 ) : <NEWLINE> <INDENT> for l in range ( 20 ) : <NEWLINE> <INDENT> sys . stdout . write ( <STRING> ) <NEWLINE> <DEDENT> print <NEWLINE> <DEDENT> <DEDENT> print <NEWLINE> exit ( 0 ) <NEWLINE>
a = [ ] <NEWLINE> for i in xrange ( 0 , 4 ) : <NEWLINE> <INDENT> b = [ ] <NEWLINE> for j in xrange ( 0 , 3 ) : <NEWLINE> <INDENT> b . append ( [ 0 ] * 10 ) <NEWLINE> <DEDENT> a . append ( b ) <NEWLINE> <DEDENT> n = int ( raw_input ( ) ) <NEWLINE> for i in xrange ( 0 , n ) : <NEWLINE> <INDENT> b , f , r , v = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> a [ b - 1 ] [ f - 1 ] [ r - 1 ] += v <NEWLINE> <DEDENT> for i , arr in enumerate ( a ) : <NEWLINE> <INDENT> for j in arr : <NEWLINE> <INDENT> print <STRING> . join ( map ( str , j ) ) <NEWLINE> <DEDENT> if i != len ( a ) - 1 : <NEWLINE> <INDENT> print <STRING> * 20 <NEWLINE> <DEDENT> <DEDENT>
n = input ( ) <NEWLINE> arr = [ map ( int , raw_input ( ) . split ( ) ) for _ in range ( n ) ] <NEWLINE> <NL> tou = [ [ [ 0 for i in range ( 10 ) ] for j in range ( 3 ) ] for k in range ( 4 ) ] <NEWLINE> <NL> for line in arr : <NEWLINE> <INDENT> b , f , r , v = line <NEWLINE> tou [ b - 1 ] [ f - 1 ] [ r - 1 ] = tou [ b - 1 ] [ f - 1 ] [ r - 1 ] + v <NEWLINE> <NL> <DEDENT> for i in range ( 4 ) : <NEWLINE> <INDENT> for j in range ( 3 ) : <NEWLINE> <INDENT> print <STRING> . join ( map ( str , tou [ i ] [ j ] ) ) <NEWLINE> <DEDENT> if i < 3 : <NEWLINE> <INDENT> print <STRING> * 20 <NEWLINE> <DEDENT> <DEDENT>
house = [ [ [ 0 for i in range ( 10 ) ] for j in range ( 3 ) ] for k in range ( 4 ) ] <NEWLINE> n = int ( input ( ) ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> b , f , r , v = map ( int , input ( ) . split ( ) ) <NEWLINE> house [ b ] [ f ] [ r ] += v <NEWLINE> <NL> <DEDENT> for i in range ( 4 ) : <NEWLINE> <INDENT> for j in range ( 3 ) : <NEWLINE> <INDENT> for k in range ( 10 ) : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> if k != 9 : <NEWLINE> <INDENT> print ( house [ i ] [ j ] [ k ] , end = <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( house [ i ] [ j ] [ k ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if i < 3 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
house = { 1 : [ [ 0 for i in range ( 10 ) ] for j in range ( 3 ) ] , 2 : [ [ 0 for i in range ( 10 ) ] for j in range ( 3 ) ] , <NEWLINE> <INDENT> 3 : [ [ 0 for i in range ( 10 ) ] for j in range ( 3 ) ] , 4 : [ [ 0 for i in range ( 10 ) ] for j in range ( 3 ) ] } <NEWLINE> <DEDENT> n = int ( input ( ) ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> building , floor , room , people_numbers = [ int ( j ) for j in input ( ) . split ( ) ] <NEWLINE> house [ building ] [ floor - 1 ] [ room - 1 ] = people_numbers <NEWLINE> <NL> <DEDENT> partition = <STRING> * 20 <NEWLINE> for i in range ( 4 ) : <NEWLINE> <INDENT> for j in range ( 3 ) : <NEWLINE> <INDENT> print ( <STRING> + * house [ i + 1 ] [ j ] ) <NEWLINE> if j == 2 and i != 3 : print ( partition ) <NEWLINE> <DEDENT> <DEDENT>
date = [ [ [ 0 for r in range ( 10 ) ] for f in range ( 3 ) ] for b in range ( 4 ) ] <NEWLINE> n = int ( input ( ) ) <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> ( b , f , r , v ) = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> data [ b - 1 ] [ f - 1 ] [ r - 1 ] += v <NEWLINE> <NL> <DEDENT> for b in range ( 4 ) : <NEWLINE> <INDENT> for f in range ( 3 ) : <NEWLINE> <INDENT> for r in range ( 10 ) : <NEWLINE> <INDENT> print ( <STRING> , data [ b ] [ f ] [ r ] , end = <STRING> ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> <DEDENT> if b < 3 : <NEWLINE> <INDENT> print ( <STRING> * 20 ) <NEWLINE> <DEDENT> <DEDENT>
def showrooms ( building , floor , rooms ) : <NEWLINE> <INDENT> for x in xrange ( 0 , floor ) : <NEWLINE> <INDENT> for y in xrange ( 0 , rooms ) : <NEWLINE> <INDENT> print building [ x ] [ y ] , <NEWLINE> <DEDENT> print <STRING> <NEWLINE> <DEDENT> <DEDENT> FLOOR = 3 <NEWLINE> ROOMS = 10 <NEWLINE> n = input ( ) <NEWLINE> building1 = [ [ 0 for i in range ( ROOMS ) ] for j in range ( FLOOR ) ] <NEWLINE> building2 = [ [ 0 for i in range ( ROOMS ) ] for j in range ( FLOOR ) ] <NEWLINE> building3 = [ [ 0 for i in range ( ROOMS ) ] for j in range ( FLOOR ) ] <NEWLINE> building4 = [ [ 0 for i in range ( ROOMS ) ] for j in range ( FLOOR ) ] <NEWLINE> <COMMENT> <NL> for x in xrange ( 0 , n ) : <NEWLINE> <INDENT> b , f , r , v = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> f = f - 1 <NEWLINE> r = r - 1 <NEWLINE> if b == 1 : <NEWLINE> <INDENT> building1 [ f ] [ r ] = v <NEWLINE> <DEDENT> elif b == 2 : <NEWLINE> <INDENT> building2 [ f ] [ r ] = v <NEWLINE> <DEDENT> elif b == 3 : <NEWLINE> <INDENT> building3 [ f ] [ r ] = v <NEWLINE> <DEDENT> elif b == 4 : <NEWLINE> <INDENT> building4 [ f ] [ r ] = v <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> showrooms ( building1 , FLOOR , ROOMS ) <NEWLINE> print <STRING> <NEWLINE> showrooms ( building2 , FLOOR , ROOMS ) <NEWLINE> print <STRING> <NEWLINE> showrooms ( building3 , FLOOR , ROOMS ) <NEWLINE> print <STRING> <NEWLINE> showrooms ( building4 , FLOOR , ROOMS ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> tenants = { } <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> tenant = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> key = <STRING> <NEWLINE> if key in d : <NEWLINE> <INDENT> d [ key ] += v <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d [ key ] = v <NEWLINE> <NL> <DEDENT> b = tenant [ 0 ] <NEWLINE> f = tenant [ 1 ] <NEWLINE> r = tenant [ 2 ] <NEWLINE> v = tenant [ 3 ] <NEWLINE> <NL> <DEDENT> for b in range ( 1 , 5 ) : <NEWLINE> <INDENT> for f in range ( 1 , 4 ) : <NEWLINE> <INDENT> for r in range ( 1 , 11 ) : <NEWLINE> <INDENT> key = <STRING> <NEWLINE> if key in d : <NEWLINE> <INDENT> print ( <STRING> + str ( d [ key ] ) , end = <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> + str ( 0 ) , end = <STRING> ) <NEWLINE> <DEDENT> if r == 10 : <NEWLINE> <INDENT> print ( ) <NEWLINE> <DEDENT> if r == 10 and f == 3 and b != 4 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT>
house = [ <NEWLINE> [ 0 for i in range ( 10 ) ] , <NEWLINE> [ 0 for i in range ( 10 ) ] , <NEWLINE> [ 0 for i in range ( 10 ) ] , <NEWLINE> [ <STRING> for i in range ( 20 ) ] , <NEWLINE> [ 0 for i in range ( 10 ) ] , <NEWLINE> [ 0 for i in range ( 10 ) ] , <NEWLINE> [ 0 for i in range ( 10 ) ] , <NEWLINE> [ <STRING> for i in range ( 20 ) ] , <NEWLINE> [ 0 for i in range ( 10 ) ] , <NEWLINE> [ 0 for i in range ( 10 ) ] , <NEWLINE> [ 0 for i in range ( 10 ) ] , <NEWLINE> [ <STRING> for i in range ( 20 ) ] , <NEWLINE> [ 0 for i in range ( 10 ) ] , <NEWLINE> [ 0 for i in range ( 10 ) ] , <NEWLINE> [ 0 for i in range ( 10 ) ] ] <NEWLINE> <COMMENT> <NL> for i in range ( 1 ) : <NEWLINE> <INDENT> b , f , r , v = map ( int , input ( ) . split ( ) ) <NEWLINE> if b == 1 : <NEWLINE> <INDENT> house [ f - 1 + ( b - 1 ) * 4 ] [ r - 1 ] += v <NEWLINE> <DEDENT> elif b == 2 : <NEWLINE> <INDENT> house [ f - 1 + ( b - 1 ) * 4 ] [ r - 1 ] += v <NEWLINE> <DEDENT> elif b == 3 : <NEWLINE> <INDENT> house [ f - 1 + ( b - 1 ) * 4 ] [ r - 1 ] += v <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> house [ f - 1 + ( b - 1 ) * 4 ] [ r - 1 ] += v <NEWLINE> <DEDENT> for i in range ( len ( house ) ) : <NEWLINE> <INDENT> if ( i + 1 ) % 4 == 0 : <NEWLINE> <INDENT> print ( <STRING> . join ( str ( i ) for i in house [ i ] ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> , <STRING> . join ( str ( i ) for i in house [ i ] ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> lst = [ [ [ 0 ] * 10 for i in range ( 0 , 3 ) ] for j in range ( 0 , 4 ) ] <NEWLINE> for k in range ( n ) : <NEWLINE> <INDENT> b , f , r , v = map ( int , input ( ) . split ( ) ) <NEWLINE> lst [ b - 1 ] [ f - 1 ] [ r - 1 ] += v <NEWLINE> <DEDENT> x = 0 <NEWLINE> for i in range ( 4 ) : <NEWLINE> <INDENT> if x != 0 : print ( <STRING> * 20 ) <NEWLINE> x += 1 <NEWLINE> for a in range ( 3 ) : <NEWLINE> <INDENT> for b in range ( 10 ) : <NEWLINE> <INDENT> print ( <STRING> , % ( lst [ i ] [ a ] [ b ] ) , end = <STRING> ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> <DEDENT> <DEDENT>
a = [ [ [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] , [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] , [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] ] , <NEWLINE> [ [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] , [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] , [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] ] , <NEWLINE> <INDENT> [ [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] , [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] , [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] ] , <NEWLINE> [ [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] , [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] , [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] ] ] <NEWLINE> <DEDENT> n = input ( ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> b , f , r , v = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> a [ b - 1 ] [ f - 1 ] [ r - 1 ] += v <NEWLINE> <DEDENT> print <STRING> . join ( map ( str , a [ 0 ] [ 0 ] ) ) <NEWLINE> print <STRING> . join ( map ( str , a [ 0 ] [ 1 ] ) ) <NEWLINE> print <STRING> . join ( map ( str , a [ 0 ] [ 2 ] ) ) <NEWLINE> print <STRING> <NEWLINE> print <STRING> . join ( map ( str , a [ 1 ] [ 0 ] ) ) <NEWLINE> print <STRING> . join ( map ( str , a [ 1 ] [ 1 ] ) ) <NEWLINE> print <STRING> . join ( map ( str , a [ 1 ] [ 2 ] ) ) <NEWLINE> print <STRING> <NEWLINE> print <STRING> . join ( map ( str , a [ 2 ] [ 0 ] ) ) <NEWLINE> print <STRING> . join ( map ( str , a [ 2 ] [ 1 ] ) ) <NEWLINE> print <STRING> . join ( map ( str , a [ 2 ] [ 2 ] ) ) <NEWLINE> print <STRING> <NEWLINE> print <STRING> . join ( map ( str , a [ 3 ] [ 0 ] ) ) <NEWLINE> print <STRING> . join ( map ( str , a [ 3 ] [ 1 ] ) ) <NEWLINE> print <STRING> . join ( map ( str , a [ 3 ] [ 2 ] ) ) <NEWLINE>
<NL> import sys <NEWLINE> <NL> def check ( x_list , f , r , v ) : <NEWLINE> <INDENT> x_list [ f ] [ r ] += v <NEWLINE> <NL> <DEDENT> def peo ( x_list ) : <NEWLINE> <INDENT> for i in range ( 3 ) : <NEWLINE> <INDENT> for j in range ( 10 ) : <NEWLINE> <INDENT> print ( <STRING> ) , <NEWLINE> sys . stdout . write ( <STRING> % ( x_list [ i ] [ j ] ) ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> A_bill = [ [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] , [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] , [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] ] <NEWLINE> B_bill = [ [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] , [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] , [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] ] <NEWLINE> C_bill = [ [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] , [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] , [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] ] <NEWLINE> D_bill = [ [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] , [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] , [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] ] <NEWLINE> <NL> n = input ( ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> x = raw_input ( ) <NEWLINE> b , f , r , v = x . split ( ) <NEWLINE> b = int ( b ) <NEWLINE> f = int ( f ) <NEWLINE> r = int ( r ) <NEWLINE> v = int ( v ) <NEWLINE> <NL> if b == 1 : <NEWLINE> <INDENT> check ( A_bill , f - 1 , r - 1 , v ) <NEWLINE> <DEDENT> elif b == 2 : <NEWLINE> <INDENT> check ( B_bill , f - 1 , r - 1 , v ) <NEWLINE> <DEDENT> elif b == 3 : <NEWLINE> <INDENT> check ( C_bill , f - 1 , r - 1 , v ) <NEWLINE> <DEDENT> elif b == 4 : <NEWLINE> <INDENT> check ( D_bill , f - 1 , r - 1 , v ) <NEWLINE> <NL> <DEDENT> <DEDENT> peo ( A_bill ) <NEWLINE> print ( <STRING> ) <NEWLINE> peo ( B_bill ) <NEWLINE> print ( <STRING> ) <NEWLINE> peo ( C_bill ) <NEWLINE> print ( <STRING> ) <NEWLINE> peo ( D_bill ) <NEWLINE>
n = int ( raw_input ( ) ) <NEWLINE> <NL> room = [ [ [ 0 for i in range ( 10 ) ] for j in range ( 3 ) ] for k in range ( 4 ) ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> b , f , r , v = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> room [ b - 1 ] [ f - 1 ] [ r - 1 ] += v <NEWLINE> <NL> <DEDENT> for i in range ( 4 ) : <NEWLINE> <INDENT> for j in range ( 3 ) : <NEWLINE> <INDENT> print <STRING> , <NEWLINE> for k in range ( 10 ) : <NEWLINE> <INDENT> print <STRING> % ( room [ i ] [ j ] [ k ] ) , <NEWLINE> <DEDENT> print <STRING> <NEWLINE> <DEDENT> if i != 3 : <NEWLINE> <INDENT> print <STRING> * 20 <NEWLINE> <DEDENT> <DEDENT>
while True : <NEWLINE> <INDENT> [ a , b , c ] = [ x for x in input ( ) . split ( ) ] <NEWLINE> a , b = int ( a ) , int ( b ) <NEWLINE> if a == 0 and b == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> elif op == <STRING> : <NEWLINE> <INDENT> print ( a + b ) <NEWLINE> <DEDENT> elif op == <STRING> : <NEWLINE> <INDENT> print ( a - b ) <NEWLINE> <DEDENT> elif op == <STRING> : <NEWLINE> <INDENT> print ( a * b ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( a // b ) <NEWLINE> <DEDENT> <DEDENT>
<NL> <NL> k1 = [ [ 0 for i in xrange ( 10 ) ] for j in xrange ( 3 ) ] <NEWLINE> k2 = [ [ 0 for i in xrange ( 10 ) ] for j in xrange ( 3 ) ] <NEWLINE> k3 = [ [ 0 for i in xrange ( 10 ) ] for j in xrange ( 3 ) ] <NEWLINE> k4 = [ [ 0 for i in xrange ( 10 ) ] for j in xrange ( 3 ) ] <NEWLINE> <NL> n = input ( ) <NEWLINE> for i in xrange ( n ) : <NEWLINE> <INDENT> m = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if m [ 0 ] == 1 : <NEWLINE> <INDENT> k1 [ m [ 1 ] - 1 ] [ m [ 2 ] - 1 ] = k1 [ m [ 1 ] - 1 ] [ m [ 2 ] - 1 ] + m [ 3 ] <NEWLINE> <DEDENT> elif m [ 0 ] == 2 : <NEWLINE> <INDENT> k2 [ m [ 1 ] - 1 ] [ m [ 2 ] - 1 ] = k2 [ m [ 1 ] - 1 ] [ m [ 2 ] - 1 ] + m [ 3 ] <NEWLINE> <DEDENT> elif m [ 0 ] == 3 : <NEWLINE> <INDENT> k3 [ m [ 1 ] - 1 ] [ m [ 2 ] - 1 ] = k3 [ m [ 1 ] - 1 ] [ m [ 2 ] - 1 ] + m [ 3 ] <NEWLINE> <DEDENT> elif m [ 0 ] == 4 : <NEWLINE> <INDENT> k4 [ m [ 1 ] - 1 ] [ m [ 2 ] - 1 ] = k4 [ m [ 1 ] - 1 ] [ m [ 2 ] - 1 ] + m [ 3 ] <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> for i in xrange ( 3 ) : <NEWLINE> <INDENT> for j in xrange ( 10 ) : <NEWLINE> <INDENT> print k1 [ i ] [ j ] , <NEWLINE> <DEDENT> if j == 9 : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> print <STRING> * 20 <NEWLINE> <NL> for i in xrange ( 3 ) : <NEWLINE> <INDENT> for j in xrange ( 10 ) : <NEWLINE> <INDENT> print k2 [ i ] [ j ] , <NEWLINE> <DEDENT> if j == 9 : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> print <STRING> * 20 <NEWLINE> <NL> for i in xrange ( 3 ) : <NEWLINE> <INDENT> for j in xrange ( 10 ) : <NEWLINE> <INDENT> print k3 [ i ] [ j ] , <NEWLINE> <DEDENT> if j == 9 : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> print <STRING> * 20 <NEWLINE> <NL> for i in xrange ( 3 ) : <NEWLINE> <INDENT> for j in xrange ( 10 ) : <NEWLINE> <INDENT> print k4 [ i ] [ j ] , <NEWLINE> <DEDENT> if j == 9 : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> apart = [ [ [ 0 for i in range ( 10 ) ] for j in range ( 3 ) ] for k in range ( 4 ) ] <NEWLINE> for joho in range ( n ) : <NEWLINE> <INDENT> x = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> apart [ x [ 2 ] ] [ x [ 1 ] ] [ x [ 0 ] ] += x [ 3 ] <NEWLINE> <NL> <DEDENT> for tou in range ( 4 ) : <NEWLINE> <INDENT> for stair in range ( 3 ) : <NEWLINE> <INDENT> for room in range ( 10 ) : <NEWLINE> <INDENT> print ( <STRING> , apart [ tou ] [ stair ] [ room ] , sep = <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> <DEDENT> if tou != 3 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT>
<COMMENT> <NL> <NL> n = int ( input ( ) ) <NEWLINE> houses = 4 <NEWLINE> floors = 3 <NEWLINE> rooms = 10 <NEWLINE> <NL> official = [ [ [ 0 for k in range ( rooms ) ] for j in range ( floors ) ] for i in range ( houses ) ] <NEWLINE> print ( official ) <NEWLINE> <NL> for a in range ( n ) : <NEWLINE> <INDENT> info = [ int ( x ) for x in input ( ) . rstrip ( ) . split ( ) ] <NEWLINE> b = info [ 0 ] - 1 <NEWLINE> f = info [ 1 ] - 1 <NEWLINE> r = info [ 2 ] - 1 <NEWLINE> v = info [ 3 ] <NEWLINE> currentFloor = official [ b ] [ f ] <NEWLINE> print ( currentFloor ) <NEWLINE> currentFloor [ r ] += v <NEWLINE> <NL> <DEDENT> print ( official ) <NEWLINE> <NL> for i in range ( houses ) : <NEWLINE> <INDENT> for j in range ( floors ) : <NEWLINE> <INDENT> for k in range ( rooms ) : <NEWLINE> <INDENT> print ( <STRING> + official [ i ] [ j ] [ k ] , end = <STRING> ) <NEWLINE> <DEDENT> <DEDENT> if i < houses - 1 : <NEWLINE> <INDENT> print ( <STRING> * 20 ) <NEWLINE> <NL> <DEDENT> <DEDENT>
mport sys <NEWLINE> def reviewRe ( ) : <NEWLINE> <COMMENT> <NL> <INDENT> for area in range ( 4 ) : <NEWLINE> <INDENT> for floor in range ( 3 ) : <NEWLINE> <INDENT> sys . stdout . write ( <STRING> ) <NEWLINE> print <STRING> . join ( map ( str , residence [ area ] [ floor ] [ : ] ) ) <NEWLINE> <DEDENT> print <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> def move_in ( ) : <NEWLINE> <INDENT> n = input ( ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> b , f , r , v = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> adding ( b , f , r , v ) <NEWLINE> <NL> <DEDENT> <DEDENT> def adding ( b , f , r , v ) : <NEWLINE> <INDENT> residence [ b - 1 ] [ f - 1 ] [ r - 1 ] = v <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> residence = [ [ [ 0 for room in range ( 10 ) ] for floor in range ( 3 ) ] for area in range ( 4 ) ] <NEWLINE> move_in ( ) <NEWLINE> reviewRe ( ) <NEWLINE> <DEDENT>
date = [ <NEWLINE> <INDENT> [ [ 0 for r in range ( 10 ) ] for f in range ( 3 ) ] for b in range ( 4 ) <NEWLINE> ] <NEWLINE> <NL> <DEDENT> count = int ( input ( ) ) <NEWLINE> for c in range ( count ) : <NEWLINE> <INDENT> b , f , r , v = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> data [ b - 1 ] [ f - 1 ] [ r - 1 ] += v <NEWLINE> <NL> <DEDENT> for bi , b in enumerate ( data ) : <NEWLINE> <INDENT> for f in b : <NEWLINE> <INDENT> for r in f : <NEWLINE> <INDENT> print ( <STRING> . format ( r ) , end = <STRING> ) <NEWLINE> <NL> <DEDENT> print ( ) <NEWLINE> <DEDENT> if bi < 3 : <NEWLINE> <INDENT> print ( <STRING> * 20 ) <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> A = [ [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] , [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] , [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] ] <NEWLINE> B = [ [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] , [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] , [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] ] <NEWLINE> C = [ [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] , [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] , [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] ] <NEWLINE> D = [ [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] , [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] , [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] ] <NEWLINE> l = [ ] <NEWLINE> N = int ( raw_input ( ) ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> ( b , f , r , v ) = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if b == 1 : A [ f - 1 ] [ r - 1 ] += v <NEWLINE> elif b == 2 : B [ f - 1 ] [ r - 1 ] += v <NEWLINE> elif b == 3 : C [ f - 1 ] [ r - 1 ] += v <NEWLINE> elif b == 4 : D [ f - 1 ] [ r - 1 ] += v <NEWLINE> <NL> <DEDENT> for j in A : <NEWLINE> <INDENT> print <STRING> . join ( map ( str , j ) ) <NEWLINE> <DEDENT> print <STRING> * 20 <NEWLINE> for k in B : <NEWLINE> <INDENT> print <STRING> . join ( map ( str , k ) ) <NEWLINE> <DEDENT> print <STRING> * 20 <NEWLINE> for l in C : <NEWLINE> <INDENT> print <STRING> . join ( map ( str , l ) ) <NEWLINE> <DEDENT> print <STRING> * 20 <NEWLINE> for m in D : <NEWLINE> <INDENT> print <STRING> . join ( map ( str , m ) ) <NEWLINE> <DEDENT>
lst = [ [ [ 0 for i in range ( 10 ) ] for j in range ( 3 ) ] for k in range ( 4 ) ] <NEWLINE> n = int ( input ( ) ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> b , f , r , v = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> lst [ b - 1 ] [ f - 1 ] [ r - 1 ] = v <NEWLINE> <DEDENT> for i in range ( 4 ) : <NEWLINE> <INDENT> if i != 0 : <NEWLINE> <INDENT> print <STRING> + <STRING> * 20 <NEWLINE> <DEDENT> for j in range ( 3 ) : <NEWLINE> <INDENT> pri = <STRING> <NEWLINE> for k in range ( 10 ) : <NEWLINE> <INDENT> pri += <STRING> + str ( lst [ i ] [ j ] [ k ] ) <NEWLINE> <DEDENT> print <STRING> + pri <NEWLINE> <DEDENT> <DEDENT>
from __future__ import print_function <NEWLINE> n = int ( raw_input ( ) ) <NEWLINE> bilding1 = [ [ <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ] , <NEWLINE> <INDENT> [ <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ] , <NEWLINE> [ <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> ] <NEWLINE> <DEDENT> bilding2 = [ [ <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ] , <COMMENT> <NEWLINE> <INDENT> [ <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ] , <COMMENT> <NEWLINE> [ <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> ] <NEWLINE> <DEDENT> bilding3 = [ [ <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ] , <COMMENT> <NEWLINE> <INDENT> [ <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ] , <COMMENT> <NEWLINE> [ <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> ] <NEWLINE> <DEDENT> bilding4 = [ [ <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ] , <COMMENT> <NEWLINE> <INDENT> [ <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ] , <COMMENT> <NEWLINE> [ <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> ] <NEWLINE> <DEDENT> bilding = [ ] <NEWLINE> bilding . append ( bilding1 ) <NEWLINE> bilding . append ( bilding2 ) <NEWLINE> bilding . append ( bilding3 ) <NEWLINE> bilding . append ( bilding4 ) <NEWLINE> <NL> for i in range ( 0 , n ) : <NEWLINE> <INDENT> inf = raw_input ( ) <NEWLINE> inf = inf . split ( <STRING> ) <NEWLINE> b = int ( inf [ 0 ] ) - 1 <NEWLINE> f = int ( inf [ 1 ] ) - 1 <NEWLINE> r = int ( inf [ 2 ] ) - 1 <NEWLINE> v = int ( inf [ 3 ] ) <NEWLINE> bilding [ b ] [ f ] [ r ] = int ( bilding [ b ] [ f ] [ r ] ) + v <NEWLINE> if ( r == 0 ) : <NEWLINE> <INDENT> bilding [ b ] [ f ] [ r ] = <STRING> + str ( bilding [ b ] [ f ] [ r ] ) + <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> bilding [ b ] [ f ] [ r ] = str ( bilding [ b ] [ f ] [ r ] ) + <STRING> <NEWLINE> <DEDENT> <DEDENT> count = 0 <NEWLINE> for j in range ( 0 , 4 ) : <NEWLINE> <INDENT> for k in range ( 0 , 3 ) : <NEWLINE> <INDENT> for l in range ( 0 , 10 ) : <NEWLINE> <INDENT> print ( ( bilding [ j ] [ k ] [ l ] ) , end = <STRING> ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> <DEDENT> if ( count < 3 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT>
rb = range ( 4 ) <NEWLINE> rf = range ( 3 ) <NEWLINE> rr = range ( 10 ) <NEWLINE> rooms = [ [ [ 0 for i in rr ] for j in rf ] for k in rb ] <NEWLINE> while True : <NEWLINE> <INDENT> lx = int ( raw_input ( ) ) <NEWLINE> for i in range ( lx ) : <NEWLINE> <INDENT> b , f , r , v = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> rooms [ b - 1 ] [ f - 1 ] [ r - 1 ] += v <NEWLINE> <NL> <DEDENT> <DEDENT> for i in rb : <NEWLINE> <INDENT> for j in rf : <NEWLINE> <INDENT> print <STRING> , <NEWLINE> for k in rr : <NEWLINE> <INDENT> print rooms [ i ] [ j ] [ k ] , <NEWLINE> <DEDENT> print <NEWLINE> <DEDENT> if i < len ( rb ) - 1 : <NEWLINE> <INDENT> print <STRING> * 20 <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = [ [ [ 0 for b in range ( 10 ) ] for b in range ( 3 ) ] for b in range ( 4 ) ] <NEWLINE> <NL> for b in ranbe ( n ) : <NEWLINE> <INDENT> b , f , r , v = map ( int , input ( ) . split ( ) ) <NEWLINE> a [ b - 1 ] [ f - 1 ] [ r - 1 ] += v <NEWLINE> <NL> <DEDENT> for c in range ( 4 ) : <NEWLINE> <INDENT> for d in range ( 3 ) : print ( <STRING> , * a [ c ] [ d ] ) <NEWLINE> if c != 3 : print ( <STRING> * 20 ) <NEWLINE> <DEDENT>
a = [ [ [ 0 for i in range ( 10 ) ] for i in range ( 3 ) ] for i in range ( 4 ) ] <NEWLINE> for i in range ( 4 ) : <NEWLINE> <INDENT> a . append ( np . zeros ( ( 3 , 10 ) , dtype = int ) ) <NEWLINE> <DEDENT> border = <STRING> * 20 <NEWLINE> n = int ( input ( ) ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> b , f , r , v = map ( int , input ( ) . split ( ) ) <NEWLINE> a [ b - 1 ] [ f - 1 ] [ r - 1 ] += v <NEWLINE> <NL> <DEDENT> for i in range ( 4 ) : <NEWLINE> <INDENT> for k in a [ i ] : <NEWLINE> <INDENT> for l in k : <NEWLINE> <INDENT> print ( <STRING> . format ( l ) , end = <STRING> ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> <DEDENT> if i != 3 : <NEWLINE> <INDENT> print ( border ) <NEWLINE> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> buildings = [ [ [ 0 ] * 10 ] * 3 ] * 4 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> b , f , r , num = map ( int , input ( ) . split ( ) ) <NEWLINE> buildings [ b - 1 ] [ f - 1 ] [ r - 1 ] += num <NEWLINE> <NL> <DEDENT> for i in range ( 4 ) : <NEWLINE> <INDENT> for j in range ( 3 ) : <NEWLINE> <INDENT> for k in range ( 10 ) : <NEWLINE> <INDENT> print ( <STRING> . format ( buildings [ k ] [ j ] [ i ] ) , end = <STRING> ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> <DEDENT> if i != 3 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
n , m = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> matrix = [ ] <NEWLINE> for ni in range ( n ) : <NEWLINE> <INDENT> matrix . append ( [ int ( a ) for a in input ( ) . split ] ) <NEWLINE> <NL> <DEDENT> vector = [ ] <NEWLINE> for mi in range ( m ) : <NEWLINE> <INDENT> vector . append ( int ( input ( ) ) ) <NEWLINE> <NL> <NL> <DEDENT> for ni in range ( n ) : <NEWLINE> <INDENT> sum = 0 <NEWLINE> for mi in range ( m ) : <NEWLINE> <INDENT> sum += matrix [ ni ] [ mi ] * vector [ mi ] <NEWLINE> <NL> <DEDENT> print ( sum ) <NEWLINE> <DEDENT>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ [ ] * b for i in range ( a ) ] <NEWLINE> B = [ ] * b <NEWLINE> <NL> for i in range ( a ) : <NEWLINE> <INDENT> A [ i ] = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <DEDENT> for i in range ( b ) : <NEWLINE> <INDENT> B [ i ] = int ( input ( ) ) <NEWLINE> <NL> <DEDENT> for i in range ( a ) : <NEWLINE> <INDENT> s = 0 <NEWLINE> for j in range ( b ) : <NEWLINE> <INDENT> s += A [ i ] [ j ] * B [ j ] <NEWLINE> <DEDENT> print ( s ) <NEWLINE> <DEDENT>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> mat = [ [ 0 for m in range ( M ) ] for n in range ( N ) ] <NEWLINE> vec = [ 0 for m in range ( M ) ] <NEWLINE> <NL> for n in range ( N ) : <NEWLINE> <INDENT> mat [ n ] = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <DEDENT> for m in range ( m ) : <NEWLINE> <INDENT> vec [ m ] = int ( input ( ) ) <NEWLINE> <NL> <DEDENT> c = 0 <NEWLINE> for n in range ( N ) : <NEWLINE> <INDENT> for m in range ( M ) : <NEWLINE> <INDENT> c += mat [ n ] [ m ] * vec [ m ] <NEWLINE> <DEDENT> print ( c ) <NEWLINE> c = 0 <NEWLINE> <DEDENT>
n , m = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> matrix = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> matrix . append ( map ( int , raw_input ( ) . split ( ) ) ) <NEWLINE> <NL> <DEDENT> vector = [ ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> vector . append ( int ( raw_input ( ) ) ) <NEWLINE> <NL> <DEDENT> for i in range ( m ) : <NEWLINE> <INDENT> for j in range ( n ) : <NEWLINE> <INDENT> print sum ( [ vector [ j ] * matrix [ i ] [ j ] ] ) <NEWLINE> <DEDENT> <DEDENT>
n , m = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> <NL> A = [ [ 0 for j in range ( m ) ] for i in range ( n ) ] <NEWLINE> b = [ 0 for j in range ( m ) ] <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> A [ i ] = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> <DEDENT> for j in range ( m ) : <NEWLINE> <INDENT> b [ j ] = raw_input ( ) <NEWLINE> <NL> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> c = 0 <NEWLINE> for j in range ( m ) : <NEWLINE> <INDENT> c += A [ i ] [ j ] * b [ j ] <NEWLINE> <DEDENT> print c <NEWLINE> <DEDENT>
( n , m ) = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> A = [ ] <NEWLINE> for nc in range ( n ) : <NEWLINE> <INDENT> A . append ( [ int ( i ) for i in input ( ) . split ( ) ] ) <NEWLINE> <NL> <DEDENT> b = [ ] <NEWLINE> for mc in range ( m ) : <NEWLINE> <INDENT> b . append ( [ int ( input ( ) ) ) <NEWLINE> <NL> <DEDENT> product = [ ] <NEWLINE> for nc in range ( n ) : <NEWLINE> <INDENT> total = 0 <NEWLINE> for mc in range ( m ) : <NEWLINE> <INDENT> total += A [ nc ] [ mc ] * b [ mc ] <NEWLINE> <NL> <DEDENT> product . append ( total ) <NEWLINE> <NL> <DEDENT> [ print ( p ) for p in product ] <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ [ None ] * n ] <NEWLINE> b = [ None ] * m <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a [ i ] = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <DEDENT> for i in range ( m ) : <NEWLINE> <INDENT> b [ i ] = int ( input ( ) ) <NEWLINE> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> c = 0 <NEWLINE> for j in range ( m ) : <NEWLINE> <INDENT> c += a [ i ] [ j ] * b [ j ] <NEWLINE> <DEDENT> print ( c ) <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ ] <NEWLINE> b = [ ] <NEWLINE> z = [ ] <NEWLINE> x = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a += [ [ int ( i ) for i in input ( ) . split ( ) ] ] <NEWLINE> <DEDENT> for i in range ( m ) : <NEWLINE> <INDENT> b += [ [ int ( i ) for i in input ( ) . split ( ) ] ] <NEWLINE> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( m ) : <NEWLINE> <INDENT> z += [ a [ i ] [ j ] * b [ j ] [ 0 ] ] <NEWLINE> <DEDENT> x += [ sum ( z ) ] <NEWLINE> z = [ ] <NEWLINE> <DEDENT> for i in range ( m ) : <NEWLINE> <INDENT> print ( x [ i ] ) <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ ] <NEWLINE> B = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> A . append ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <DEDENT> for i in range ( m ) : <NEWLINE> <INDENT> B . append ( int ( input ( ) ) ) <NEWLINE> <NL> <DEDENT> C = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> C . append ( 0 ) <NEWLINE> for j in range ( m ) : <NEWLINE> <INDENT> C [ i ] += int ( A [ i ] [ j ] ) * B [ j ] <NEWLINE> <DEDENT> print ( C [ i ] ) <NEWLINE> <DEDENT>
m = input ( ) <NEWLINE> n = input ( ) <NEWLINE> i = 0 <NEWLINE> j = 0 <NEWLINE> list = [ ] <NEWLINE> while i < m : <NEWLINE> <INDENT> while j < n : <NEWLINE> <INDENT> k = input ( ) <NEWLINE> list . append ( k ) <NEWLINE> j += 1 <NEWLINE> <DEDENT> i += 1 <NEWLINE> <DEDENT> i = 0 <NEWLINE> list2 = [ ] <NEWLINE> while i < n : <NEWLINE> <INDENT> k = input ( ) <NEWLINE> list2 . append ( k ) <NEWLINE> i += 1 <NEWLINE> <DEDENT> i = 0 <NEWLINE> j = 0 <NEWLINE> k = 0 <NEWLINE> while i < m : <NEWLINE> <INDENT> while j < n : <NEWLINE> <INDENT> t = list [ j + k ] <NEWLINE> s = list2 [ j ] <NEWLINE> sum += t * s <NEWLINE> j += 1 <NEWLINE> <DEDENT> print ( sum ) <NEWLINE> i += 1 <NEWLINE> k += 4 <NEWLINE> <DEDENT>
( n , m ) = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> A = [ ] <NEWLINE> b = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> A . append ( [ int ( j ) for j in input ( ) . split ( ) ] ) <NEWLINE> <NL> for i in range ( m ) : <NEWLINE> b . append ( int ( input ( ) ) ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> s = 0 <NEWLINE> <DEDENT> for j in range ( m ) : <NEWLINE> <INDENT> s += A [ i ] [ j ] * b [ j ] <NEWLINE> <DEDENT> print ( s ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ list ( map ( int , input ( ) . split ( ) ) for _ in range ( n ) ] <NEWLINE> b = [ int ( input ( ) ) for _ in range ( m ) ] <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> print ( sum ( a [ _ ] [ i ] * b [ i ] for i in range ( m ) ) ) <NEWLINE> <DEDENT>
n , m = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> a = [ [ 0 for i in range ( m ) ] for j in range ( n ) ] <NEWLINE> b = [ 0 for i in range ( m ) ] <NEWLINE> c = [ 0 for i in range ( m ) ] <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> x = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> for j in range ( m ) : <NEWLINE> <INDENT> a [ i ] [ j ] = x [ j ] <NEWLINE> <DEDENT> <DEDENT> for i in range ( m ) : <NEWLINE> <INDENT> b [ i ] = int ( raw_input ( ) ) <NEWLINE> <NL> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( m ) : <NEWLINE> <INDENT> c [ i ] += a [ i ] [ j ] * b [ j ] <NEWLINE> <DEDENT> print c [ i ] <NEWLINE> <DEDENT>
( n , m ) = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> A = [ ] <NEWLINE> b = [ ] <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> A . append ( [ int ( j ) for j in input ( ) . split ( ) ] ) <NEWLINE> <NL> <DEDENT> for i in range ( m ) : <NEWLINE> <INDENT> b . append ( int ( input ( ) ) ) <NEWLINE> <NL> <DEDENT> c = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> m = 0 <NEWLINE> for j in range ( m ) : <NEWLINE> <INDENT> s += A [ i ] [ j ] = b [ j ] <NEWLINE> <DEDENT> print ( s ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> import sys <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> m , n = [ int ( col_row ) for col_row in sys . stdin . readline ( ) . split ( ) ] <NEWLINE> matrix = [ [ 0 for col in range ( m ) ] for row in range ( n ) ] <NEWLINE> vector = [ 0 for col in range ( m ) ] <NEWLINE> <NL> for row in range ( n ) : <NEWLINE> <INDENT> lst = [ int ( element ) for element in sys . stdin . readline ( ) . split ( ) ] <NEWLINE> for col in range ( m ) : <NEWLINE> <INDENT> matrix [ row ] [ col ] += lst [ col ] <NEWLINE> <NL> <DEDENT> <DEDENT> for row in range ( m ) : <NEWLINE> <INDENT> lst = [ int ( element ) for element in sys . stdin . readline ( ) . split ( ) ] <NEWLINE> vector [ row ] += lst [ 0 ] <NEWLINE> <NL> <DEDENT> for row in range ( n ) : <NEWLINE> <INDENT> sum_of_row = 0 <NEWLINE> for col in range ( m ) : <NEWLINE> <INDENT> sum_of_row += matrix [ row ] [ col ] * vector [ col ] <NEWLINE> <COMMENT> <NL> <DEDENT> print ( sum_of_row ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> import numpy as np <NEWLINE> <NL> A = [ ] <NEWLINE> n , m = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> for _ in xrange ( n ) : <NEWLINE> <INDENT> A . append ( map ( int , raw_input ( ) . split ( ) ) ) <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> b = [ ] <NEWLINE> for _ in xrange ( m ) : <NEWLINE> <INDENT> b . append ( input ( ) ) <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> Ab = [ sum ( [ A [ i ] [ j ] * b [ j ] for j in xrange ( m ) ] ) for i in xrange ( n ) ] <NEWLINE> <COMMENT> <NL> for x in Ab : <NEWLINE> <INDENT> print x <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ input ( ) . split ( ) for _ in [ 0 ] * n ] <NEWLINE> b = [ input ( ) for _ in [ 0 ] * m ] <NEWLINE> for a in A : print ( sum ( x * y for x , y in map ( int , zip ( a , b ) ) ) ) <NEWLINE>
n , m = [ int ( input ( ) . split ( <STRING> ) ] <NEWLINE> <NL> a = [ [ int ( i ) for i in input ( ) . split ( <STRING> ) ] for _ in range ( n ) ] <NEWLINE> b = [ ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> b . append ( int ( input ( ) ) ) <NEWLINE> <NL> <NL> <DEDENT> for x in range ( n ) : <NEWLINE> <INDENT> result = 0 <NEWLINE> for y in range ( m ) : <NEWLINE> <INDENT> result += a [ x ] [ y ] * b [ y ] <NEWLINE> <DEDENT> print ( result ) <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ [ 0 ] * m for _ in range ( n ) ] <NEWLINE> b = [ 0 ] * m <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a [ i ] = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <DEDENT> for i in range ( m ) : <NEWLINE> <INDENT> b [ i ] = int ( input ( ) ) <NEWLINE> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> c = None <NEWLINE> for j in range ( m ) : <NEWLINE> <INDENT> c += a [ i ] [ j ] * b [ j ] <NEWLINE> <DEDENT> print ( c ) <NEWLINE> <NL> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> a = [ [ 0 for i in range ( n ) ] for j in range ( m ) ] <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> a_tmp = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for j in range ( m ) : <NEWLINE> <INDENT> a [ i ] [ j ] = a_tmp [ j ] <NEWLINE> <NL> <DEDENT> <DEDENT> b = [ ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> b . append ( int ( input ( ) ) ) <NEWLINE> <NL> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> c = 0 <NEWLINE> for j in range ( m ) : <NEWLINE> <INDENT> c += a [ i ] [ j ] * b [ j ] <NEWLINE> <DEDENT> print ( c ) <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ] <NEWLINE> b = [ int ( input ( ) ) for _ in range ( m ) ] <NEWLINE> [ print ( sum ( [ j * k for j , k in zip ( a [ i ] , b ] ) ) for i in range ( n ) ] <NEWLINE> ~ <NEWLINE>
import numpy as np <NEWLINE> n = int ( input ( ) ) <NEWLINE> m = int ( input ( ) ) <NEWLINE> <NL> A = [ [ input ( ) for i in range ( n ) ] for i in range ( m ) ] <NEWLINE> b = [ input ( ) for j in range ( m ) ] <NEWLINE> <NL> c = A . dot ( b ) <NEWLINE> print ( c ) <NEWLINE>
n , m = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> a = [ ] <NEWLINE> b = [ ] <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> a . append ( map ( int , raw_input ( ) . split ( ) ) ) <NEWLINE> <DEDENT> for i in range ( m ) : <NEWLINE> <INDENT> b . append ( input ( ) ) <NEWLINE> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> for j in range ( m ) : <NEWLINE> <INDENT> ans += a [ i ] [ j ] * b [ j ] <NEWLINE> <DEDENT> print ans : <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> n_l = [ ] <NEWLINE> ans = [ 0 , 0 , 0 ] <NEWLINE> <NL> for _ in range ( n ) : <NEWLINE> <INDENT> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> n_l . append ( l ) <NEWLINE> <DEDENT> for x in range ( m ) : <NEWLINE> <INDENT> p = int ( input ( ) ) <NEWLINE> for o in n : <NEWLINE> <INDENT> n_l [ o ] *= p <NEWLINE> <DEDENT> <DEDENT> for i in n_l : <NEWLINE> <INDENT> print ( sum ( i ) ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> n , m = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> mx = [ ] * n <NEWLINE> for i in xrange ( n ) : <NEWLINE> <INDENT> mx [ i ] = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> <NL> <DEDENT> v = [ 0 ] * m <NEWLINE> for i in xrange ( m ) : <NEWLINE> <INDENT> v [ i ] = input ( ) <NEWLINE> <NL> <DEDENT> for i in xrange ( n ) : <NEWLINE> <INDENT> t = 0 <NEWLINE> for j in xrange ( m ) : <NEWLINE> <INDENT> t += mx [ i ] [ j ] * v [ j ] <NEWLINE> <DEDENT> print t <NEWLINE> <DEDENT>
<STRING> <NEWLINE> <NL> from operator import add <NEWLINE> from functools import reduce <NEWLINE> <NL> <COMMENT> <NL> n = int ( input ( ) ) <NEWLINE> m = int ( input ( ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> a = [ list ( map ( int , input ( ) . split ( ) ) ) for n in range ( n ) ] <NEWLINE> <COMMENT> <NL> <NL> b = [ int ( input ( ) ) for n in range ( m ) ] <NEWLINE> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> c = [ ] <NEWLINE> for n in range ( n ) : <NEWLINE> <INDENT> c . append ( [ a [ n ] [ m ] * b [ m ] for m in range ( m ) ] ) <NEWLINE> <NL> <COMMENT> <NL> <NL> <DEDENT> d = [ reduce ( add , c [ n ] ) for n in range ( len ( c ) ) ] <NEWLINE> <NL> <NL> <NL> <COMMENT> <NL> <NL> [ print ( d [ i ] ) for i in range ( len ( d ) ) ] <NEWLINE> <NL>
import numpy as np <NEWLINE> N , M = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> matrix = [ ] <NEWLINE> array = [ ] <NEWLINE> for n in range ( N ) : <NEWLINE> <INDENT> tmp = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if len ( tmp ) > M : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> matrix . append ( tmp ) <NEWLINE> <DEDENT> matrix = np . array ( matrix ) <NEWLINE> <NL> for m in range ( M ) : <NEWLINE> <INDENT> tmp = input ( ) <NEWLINE> array . append ( tmp ) <NEWLINE> <DEDENT> array = np . array ( array ) <NEWLINE> <NL> multi = np . dot ( matrix , array ) <NEWLINE> for i in list ( multi ) : <NEWLINE> <INDENT> print i <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ [ int ( i ) for i in input ( ) . split ( ) ] for j in range ( n ) ] <NEWLINE> b = [ ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> b . append ( int ( input ( ) ) ) <NEWLINE> <DEDENT> ans = [ 0 for i in range ( m ) ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( m ) : <NEWLINE> <INDENT> ans [ i ] += A [ i ] [ j ] * b [ j ] <NEWLINE> <DEDENT> <DEDENT> for i in ans : <NEWLINE> <INDENT> print ( i ) ) <NEWLINE> <DEDENT>
( n , m ) = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> A = [ ] <NEWLINE> for nc in range ( n ) : <NEWLINE> <INDENT> A . append ( [ int ( i ) for i in input ( ) . split ( ) ] ) <NEWLINE> <NL> <DEDENT> b = [ ] <NEWLINE> for mc in range ( m ) : <NEWLINE> <INDENT> b . append ( int ( i ) for i in input ( ) ) <NEWLINE> <NL> <DEDENT> product = [ ] <NEWLINE> for nc in range ( n ) : <NEWLINE> <INDENT> total = 0 <NEWLINE> for mc in range ( m ) : <NEWLINE> <INDENT> total += A [ nc ] [ mc ] * b [ mc ] <NEWLINE> <NL> <DEDENT> product . append ( total ) <NEWLINE> <NL> <DEDENT> [ print ( p ) for p in product ] <NEWLINE>
n , m = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> matrix = [ ] <NEWLINE> for ni in range ( n ) : <NEWLINE> <INDENT> matrix . append ( [ int ( a ) for a in input ( ) . split ( ) ] ) <NEWLINE> <NL> <DEDENT> vector = [ ] <NEWLINE> for mi in range ( n ) : <NEWLINE> <INDENT> vector . append ( int ( input ( ) ) ) <NEWLINE> <NL> <DEDENT> b = [ ] <NEWLINE> for ni in range ( n ) : <NEWLINE> <INDENT> sum = 0 <NEWLINE> for mi in range ( m ) : <NEWLINE> <INDENT> sum += matrix [ ni ] [ mi ] * vector [ mi ] <NEWLINE> <NL> <DEDENT> print ( sum ) <NEWLINE> <DEDENT>
( m , m ) = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> A = [ ] <NEWLINE> b = [ ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> A . append ( [ int ( j ) for j in input ( ) . split ( ) ] ) <NEWLINE> <NL> <DEDENT> for i in range ( m ) : <NEWLINE> <INDENT> b . apped ( int ( input ( ) ) ) <NEWLINE> <NL> <DEDENT> c = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> s = 0 <NEWLINE> for j in range ( m ) : <NEWLINE> <INDENT> m += A [ n ] [ m ] * b [ m ] <NEWLINE> <DEDENT> print ( m ) <NEWLINE> <DEDENT>
t ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> matrix = [ ] <NEWLINE> for ni in range ( n ) : <NEWLINE> <INDENT> matrix . append ( [ int ( a ) for a in input ( ) . split ( ) ] ) <NEWLINE> <NL> <DEDENT> vector = [ ] <NEWLINE> for mi in range ( m ) : <NEWLINE> <INDENT> vector . append ( int ( input ( ) ) ) <NEWLINE> <NL> <DEDENT> for ni in range ( n ) : <NEWLINE> <INDENT> sum = 0 <NEWLINE> for mi in range ( m ) : <NEWLINE> <INDENT> sum += matrix [ ni ] [ mi ] * vector [ mi ] <NEWLINE> <NL> <DEDENT> print ( sum ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <NL> m , n = tuple ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = [ [ 0 for j in range ( n ) ] for i in range ( m ) ] <NEWLINE> b = [ 0 for j in range ( n ) ] <NEWLINE> c = [ 0 for i in range ( m ) ] <NEWLINE> <NL> for i in range ( m ) : <NEWLINE> <INDENT> tmplst = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for j in range ( n ) : <NEWLINE> <INDENT> a [ i ] [ j ] = tmplst [ j ] <NEWLINE> <NL> <DEDENT> <DEDENT> for j in range ( n ) : <NEWLINE> <INDENT> b [ j ] = int ( input ( ) ) <NEWLINE> <NL> <DEDENT> for i in range ( m ) : <NEWLINE> <INDENT> for j in range ( n ) : <NEWLINE> <INDENT> c [ i ] += a [ i ] [ j ] * b [ j ] <NEWLINE> print ( c [ i ] ) <NEWLINE> <NL> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n , m = input ( ) <NEWLINE> A = [ ] <NEWLINE> b = [ ] <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> A += [ map ( int , raw_input ( ) . split ( ) ) ] <NEWLINE> <NL> <DEDENT> for j in range ( m ) : <NEWLINE> <INDENT> b += [ input ( ) ] <NEWLINE> <NL> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> c = 0 <NEWLINE> for j in range ( m ) : <NEWLINE> <INDENT> c += A [ i ] [ j ] * b [ j ] <NEWLINE> <DEDENT> print c <NEWLINE> <DEDENT>
n , m = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A = [ [ 0 for w in range ( m ) ] for h in range ( n ) ] <NEWLINE> B = [ 0 for h in range ( m ) ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> A [ i ] = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <DEDENT> for i in range ( m ) : <NEWLINE> <INDENT> B [ i ] = int ( input ( ) ) <NEWLINE> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> c = 0 <NEWLINE> for = j in range ( m ) : <NEWLINE> <INDENT> c += A [ i ] [ j ] * B [ j ] <NEWLINE> print ( c ) <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> n , m = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> <NL> a = [ [ 0 ] * m for i in xrange ( n ) ] <NEWLINE> <NL> b = [ 0 ] * m <NEWLINE> <NL> for i in xrange ( n ) : <NEWLINE> <INDENT> tmp = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> for j in xrange ( m ) : <NEWLINE> <INDENT> a [ i ] [ j ] = tmp [ j ] <NEWLINE> <DEDENT> <DEDENT> for i in xrange ( m ) : <NEWLINE> <INDENT> b [ i ] = input ( ) <NEWLINE> <DEDENT> for i in xrange ( n ) : <NEWLINE> <INDENT> tmp = 0 <NEWLINE> for j in xrange ( m ) : <NEWLINE> <INDENT> tmp += a [ i ] [ j ] * b [ j ] <NEWLINE> <DEDENT> print tmp <NEWLINE> <DEDENT>
bfr = [ [ [ 0 for _ in range ( 10 ) ] for _ in range ( 3 ) ] for _ in range ( 4 ) ] <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> b , f , r , v = map ( int , input ( ) . split ( ) ) <NEWLINE> bfr [ b - 1 ] [ f - 1 ] [ r - 1 ] += v <NEWLINE> <DEDENT> for b in range ( 4 ) : <NEWLINE> <INDENT> for f in range ( 3 ) : <NEWLINE> <INDENT> print ( <STRING> + <STRING> . join ( map ( str , bfr [ b ] [ f ] ) ) ) <NEWLINE> <DEDENT> if b != 3 : <NEWLINE> <INDENT> print ( <STRING> * 20 ) <NEWLINE> <DEDENT> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> lst = [ [ ] * m for i in range ( n ) ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> lst [ i ] = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <DEDENT> lst2 = [ [ ] * 1 for i in range ( m ) ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> lst2 [ i ] = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> x = 0 <NEWLINE> for j in range ( m ) : <NEWLINE> <INDENT> x = x + lst [ i ] [ j ] * lst2 [ j ] <NEWLINE> <DEDENT> print ( <STRING> % ( x ) ) <NEWLINE> <NL> <DEDENT>
n , m = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a = [ ] <NEWLINE> a . append ( map ( int , raw_input ( ) . split ( ) ) ) <NEWLINE> <DEDENT> for i in range ( m ) : <NEWLINE> <INDENT> b = [ ] <NEWLINE> b . append ( input ( ) ) <NEWLINE> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> ans = 0 <NEWLINE> for j in range ( m ) : <NEWLINE> <INDENT> ans += a [ i ] [ j ] * b [ j ] <NEWLINE> <DEDENT> <DEDENT> print ans <NEWLINE>
( n , m ) = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> a = [ [ ] ] <NEWLINE> b = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> A . append ( [ int ( j ) for j in input ( ) . split ( ) ] <NEWLINE> <NL> <DEDENT> for i in range ( m ) : <NEWLINE> <INDENT> b . append ( int ( input ( ) ) ) <NEWLINE> <NL> <DEDENT> c = [ ] <NEWLINE> for i range ( n ) : <NEWLINE> <INDENT> s = 0 <NEWLINE> for j in range ( m ) : <NEWLINE> <INDENT> m += A [ i ] [ j ] * b [ j ] <NEWLINE> print ( s ) <NEWLINE> <DEDENT> <DEDENT>
( n , m ) = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> A = [ ] <NEWLINE> b = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> A . append ( [ int ( j ) for j in input ( ) . split ( ) ] ) <NEWLINE> <NL> <DEDENT> for i in ronge ( m ) : <NEWLINE> <INDENT> b . append ( int ( input ( ) ) ) <NEWLINE> <NL> <NL> <DEDENT> for i in range ( n ) : <NEWLINE> m = 0 <NEWLINE> for j in range ( m ) : <NEWLINE> <INDENT> s += A [ j ] [ j ] * b [ j ] <NEWLINE> print ( s ) <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> a = [ 0 ] * n <NEWLINE> b = [ 0 ] * m <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> a [ i ] = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> b [ i ] = int ( input ( ) ) <NEWLINE> <NL> <DEDENT> for i in range ( m ) : <NEWLINE> <INDENT> ret = 0 <NEWLINE> for j in range ( n ) : <NEWLINE> <INDENT> ret += a [ i ] [ j ] * b [ j ] <NEWLINE> <DEDENT> print ( ret ) <NEWLINE> <NL> <NL> <DEDENT>
( n , m ) = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> A = [ ] <NEWLINE> b = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> A . oppend ( [ int ( j ) for j in input ( ) . split ( ) ] ) <NEWLINE> <NL> <DEDENT> for i in range ( m ) : <NEWLINE> <INDENT> b . oppend ( int ( input ( ) ) ) <NEWLINE> <NL> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> s = 0 <NEWLINE> for j in range ( m ) : <NEWLINE> <INDENT> s += A [ i ] [ j ] * b [ j ] <NEWLINE> <DEDENT> print ( s ) <NEWLINE> <DEDENT>
( n , m ) = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <INDENT> A = [ [ ] ] <NEWLINE> b = [ ] <NEWLINE> for i input range ( n ) : <NEWLINE> <INDENT> A . append ( [ int ( j ) for j in input ( ) . split ( ) ] ) <NEWLINE> <NL> <DEDENT> for i in range ( m ) : <NEWLINE> <INDENT> b . append ( int ( input ( ) ) ) <NEWLINE> <NL> <DEDENT> c = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> s = 0 <NEWLINE> for j in range ( m ) <NEWLINE> <INDENT> s += A [ n ] [ m ] * b [ m ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
n , m = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> A = [ ] <NEWLINE> b = [ ] <NEWLINE> s = 0 <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> A . append ( [ int ( j ) for j in input ( ) . split ( ) ] ) <NEWLINE> <NL> <DEDENT> for i in range ( m ) : <NEWLINE> <INDENT> b . append ( int ( input ( ) ) ) <NEWLINE> <NL> <DEDENT> for i in range ( n ) : <NEWLINE> <NL> <INDENT> for j in range ( m ) : <NEWLINE> <INDENT> s += A [ i ] [ j ] * b [ j ] <NEWLINE> <DEDENT> <DEDENT> print ( s ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ [ 0 ] * m ] for i in range ( n ) ] <NEWLINE> b = [ 0 ] * m <NEWLINE> c = [ 0 ] * n <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> w = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for j in range ( m ) : <NEWLINE> <INDENT> a [ i ] [ j ] = w [ j ] <NEWLINE> <NL> <DEDENT> <DEDENT> for j in range ( m ) : <NEWLINE> <INDENT> b [ j ] = int ( input ( ) ) <NEWLINE> <NL> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( m ) : <NEWLINE> <INDENT> c [ i ] += a [ i ] [ j ] * b [ j ] <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> print ( c [ i ] ) <NEWLINE> <DEDENT>
( n , m ) = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> A = [ [ ] ] <NEWLINE> b = [ ] <NEWLINE> <NL> <NL> for i in range ( n ) : <NEWLINE> <INDENT> A . append ( [ int ( j ) for j in input ( ) . split ( ) ] ) <NEWLINE> <NL> <DEDENT> for i in range ( m ) : <NEWLINE> <INDENT> b . append ( int ( input ( ) ) ) <NEWLINE> <NL> <NL> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> c = 0 <NEWLINE> <NL> for j in range ( m ) : <NEWLINE> <INDENT> c += A [ i ] [ j ] * b [ j ] <NEWLINE> <NL> <DEDENT> print ( c ) <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ ] <NEWLINE> b = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a += list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <DEDENT> for i in range ( m ) : <NEWLINE> <INDENT> b . append ( int ( input ( ) ) ) <NEWLINE> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> c = 0 <NEWLINE> for j in range ( m ) : <NEWLINE> <INDENT> c += a [ i ] [ j ] * b [ j ] <NEWLINE> <DEDENT> print ( c ) <NEWLINE> <DEDENT>
( n , m ) = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> A = [ ] <NEWLINE> B = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> A . append ( [ int ( j ) for j in input ( ) . split ( ) ] ) <NEWLINE> <NL> <DEDENT> for i in range ( m ) : <NEWLINE> <INDENT> B . append ( int ( input ( ) ) ) <NEWLINE> <NL> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> s = 0 <NEWLINE> for j in range ( m ) : <NEWLINE> <INDENT> m += A [ i ] [ j ] * B [ j ] <NEWLINE> <DEDENT> print ( s ) <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> a = [ [ ] for _ in range ( n ) ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a [ i ] = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = [ 0 for _ in range ( m ) ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> b [ i ] = int ( input ( ) ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> d = 0 <NEWLINE> for j in range ( m ) : <NEWLINE> <INDENT> d += a [ i ] [ j ] * b [ j ] <NEWLINE> <NL> <DEDENT> print ( d ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> Mat = [ [ ] ] <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> row = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> Mat . append ( row ) <NEWLINE> <NL> <DEDENT> b = [ ] <NEWLINE> <NL> for j in range ( m ) : <NEWLINE> <INDENT> b . append ( int ( input ( ) ) ) <NEWLINE> <NL> <DEDENT> c = [ 0 for k in range ( n ) ] <NEWLINE> <NL> for l in range ( n ) : <NEWLINE> <INDENT> for l2 in range ( m ) : <NEWLINE> <INDENT> c [ l ] += ( Mat [ l ] [ l2 ] * b [ l2 ] ) <NEWLINE> <DEDENT> print ( c [ l ] ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> <NL> <NL> <COMMENT> <NL> <NL> def zero ( n ) : <NEWLINE> <INDENT> c = list ( ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> c += [ 0 ] <NEWLINE> <DEDENT> return c <NEWLINE> <NL> <COMMENT> <NL> <NL> <DEDENT> f_input = map ( int , raw_input ( ) . split ( <STRING> ) ) <NEWLINE> <NL> <NL> vec = f_input [ 0 ] <NEWLINE> col = f_input [ 1 ] <NEWLINE> <NL> <NL> <COMMENT> <NL> null = list ( ) <NEWLINE> for i in range ( vec ) : <NEWLINE> <INDENT> null . append ( zero ( col ) ) <NEWLINE> <COMMENT> <NL> <DEDENT> cvarea = np . matrix ( null ) <NEWLINE> <NL> <NL> k = list ( ) <NEWLINE> for i in range ( col ) : <NEWLINE> <INDENT> k += [ [ 0 ] ] <NEWLINE> <DEDENT> k = np . matrix ( k ) <NEWLINE> varea = k <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> <NL> <NL> <NL> <COMMENT> <NL> <NL> for i in range ( vec ) : <NEWLINE> <INDENT> N = map ( int , raw_input ( ) . split ( <STRING> ) ) <NEWLINE> <COMMENT> <NL> M = np . matrix ( N ) <NEWLINE> <COMMENT> <NL> cvarea [ i ] += N <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> for i in range ( col ) : <NEWLINE> <INDENT> N = int ( raw_input ( ) ) <NEWLINE> varea [ i ] += N <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> sol = cvarea * varea <NEWLINE> for i in range ( vec ) : <NEWLINE> <INDENT> print int ( sol [ i ] ) <NEWLINE> <DEDENT>
n , m = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> a , b = [ ] , [ ] <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> a . append ( map ( int , raw_input ( ) . split ( ) ) ) <NEWLINE> <DEDENT> for _ in range ( m ) : <NEWLINE> <INDENT> b . append ( int ( raw_input ( ) ) ) <NEWLINE> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> c [ i ] = 0 <NEWLINE> for j in range ( m ) : <NEWLINE> <INDENT> c [ i ] += a [ i ] [ j ] * b [ j ] <NEWLINE> <DEDENT> print c [ i ] <NEWLINE> <DEDENT>
n , m = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> matrix = [ ] <NEWLINE> for ni in range ( n ) : <NEWLINE> <INDENT> matrix . append ( [ int ( a ) for a in input ( ) . split ( ) ] ) <NEWLINE> <NL> <DEDENT> vector = [ ] <NEWLINE> for mi in range ( m ) : <NEWLINE> <INDENT> vector . append ( int ( input ( ) ) ) <NEWLINE> <NL> <DEDENT> for ni in range ( n ) : <NEWLINE> <NL> <INDENT> sum = 0 <NEWLINE> for mi in rannge ( m ) : <NEWLINE> <INDENT> sum += matrix [ ni ] [ mi ] * vector [ mi ] <NEWLINE> <NL> print ( sum ) <NEWLINE> <DEDENT> <DEDENT>
n , m = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> matrix = [ ] <NEWLINE> for ni in range ( n ) : <NEWLINE> <INDENT> matrix . append ( [ int ( a ) for a in input ( ) . split ] ) <NEWLINE> <NL> <DEDENT> vector = [ ] <NEWLINE> for mi in range ( m ) : <NEWLINE> <INDENT> vector . append ( int ( input ( ) ) ) <NEWLINE> <NL> <NL> <DEDENT> print ( matrix ) <NEWLINE> print ( ) <NEWLINE> print ( vector ) <NEWLINE>
<NL> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ list ( map ( int , input ( ) . split ( ) ) ) for f in range ( n ) ] <NEWLINE> b = [ int ( input ( ) ) for g in range ( m ) ] <NEWLINE> [ print ( sum ( [ j * k for j , k in zip ( a [ i ] , b ] ) ) for i in range ( n ) ] <NEWLINE>
n , m = map ( int , input ( ) . strip ( ) . split ( ) ) <NEWLINE> a = [ [ 0 for j in range ( m ) ] for i in range ( n ) ] <NEWLINE> b = [ [ 0 ] for j in range ( m ) ] <NEWLINE> c = [ [ 0 ] for j in range ( n ) ] <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> a [ i ] = list ( map ( int , input ( ) . strip ( ) . split ( ) ) ) <NEWLINE> <NL> <DEDENT> for i in range ( m ) : <NEWLINE> <INDENT> b [ i ] = [ int ( input ( ) ) ] <NEWLINE> <NL> <NL> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( m ) : <NEWLINE> <INDENT> c [ 0 ] [ i ] += a [ j ] [ i ] * b [ 0 ] [ j ] <NEWLINE> <DEDENT> print ( c [ 0 ] [ i ] ) <NEWLINE> <DEDENT>
n , m = [ int ( i ) for i in input ( ) . split ( ) <NEWLINE> <NL> matrix = [ ] <NEWLINE> for ni in range ( n ) : <NEWLINE> <INDENT> matrix . append ( [ int ( a ) for a in input ( ) . split ( ) ] ) <NEWLINE> <NL> <DEDENT> vector = [ ] <NEWLINE> for mi in range ( m ) : <NEWLINE> <INDENT> vector . append ( int ( input ( ) ) ) <NEWLINE> <NL> <DEDENT> b = [ ] <NEWLINE> for ni in range ( n ) : <NEWLINE> <INDENT> sum = 0 <NEWLINE> for mi in range ( m ) : <NEWLINE> <INDENT> sum += matrix [ ni ] [ mi ] * vector [ mi ] <NEWLINE> <NL> <DEDENT> print ( sum ) <NEWLINE> <DEDENT>
( n , m ) = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> A = [ ] <NEWLINE> b = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> A . append ( [ int ( j ) for j in input ( ) . split ( ) ] ) <NEWLINE> <NL> <DEDENT> for i in range ( m ) : <NEWLINE> <INDENT> b . append ( int ( input ( ) ) ) <NEWLINE> <NL> <DEDENT> print ( A ) <NEWLINE> print ( b ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> s = 0 <NEWLINE> for j in range ( m ) : <NEWLINE> <INDENT> m += A [ i ] [ j ] * b [ j ] <NEWLINE> <DEDENT> print ( s ) <NEWLINE> <DEDENT>
def solve ( n , m , a , b ) : <NEWLINE> <INDENT> res = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> s = [ a [ i ] [ j ] * b [ j ] for j in range ( m ) ] <NEWLINE> res . append ( sum ( s ) ) <NEWLINE> <DEDENT> return res <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> n , m = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> a = [ map ( int , raw_input ( ) . split ( ) ) for _ in range ( n ) ] <NEWLINE> b = [ int ( i ) for i in input ( ) ) for _ in range ( m ) ] <NEWLINE> for x in solve ( n , m , a , b ) : <NEWLINE> <DEDENT> print ( x ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> List1 = [ [ 0 for i in range ( m ) ] for i in range ( n ) ] <NEWLINE> for x in range ( n ) : <NEWLINE> <INDENT> List1 [ x ] = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <DEDENT> List2 = [ int ( input ( ) ) for _ in range ( n ) ] <NEWLINE> sum = [ 0 for i in range ( n ) ] <NEWLINE> for x in range ( n ) : <NEWLINE> <INDENT> for y in range ( m ) : <NEWLINE> <INDENT> sum [ x ] += List1 [ x ] [ y ] * List2 [ y ] <NEWLINE> <DEDENT> <DEDENT> for x in range ( n ) : <NEWLINE> <INDENT> print ( sum [ x ] ) <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ input ( ) . split ( ) for _ in range ( n ) ] <NEWLINE> b = [ input ( ) for _ in range ( m ) ] <NEWLINE> for a in A : <NEWLINE> <INDENT> print ( sum ( int ( x ) * int ( y ) for x , y in zip ( a , b ) ) ) <NEWLINE> <DEDENT>
n , m = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a . append ( [ int ( j ) for j in input ( ) . split ( ) ] ) <NEWLINE> <DEDENT> b = [ ] <NEWLINE> for i in range ( m ) <NEWLINE> <INDENT> b . append ( int ( input ( ) ) ) <NEWLINE> <DEDENT> for j in range ( n ) : <NEWLINE> <INDENT> s = 0 <NEWLINE> for j in range ( m ) : <NEWLINE> <INDENT> s += a [ i ] [ j ] * b [ j ] <NEWLINE> <DEDENT> print ( s ) <NEWLINE> <NL> <DEDENT>
a , b = map ( int , raw_input ( ) . split ) <NEWLINE> gA = [ ] <NEWLINE> gb = [ ] <NEWLINE> for i in range ( a ) : <NEWLINE> <INDENT> gA . append ( map ( int , raw_input ( ) . split ( ) ) ) <NEWLINE> <DEDENT> for i in range ( b ) : <NEWLINE> <INDENT> gb . append ( input ( ) ) <NEWLINE> <DEDENT> for i in range ( a ) : <NEWLINE> <INDENT> ans = 0 <NEWLINE> for j in range ( b ) : <NEWLINE> <INDENT> ans += gA [ i ] [ j ] * gb [ j ] <NEWLINE> <DEDENT> print ans <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> lst = [ [ ] for i in range ( n ) ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> lst [ i ] = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <DEDENT> lst2 = [ [ ] * 1 for i in range ( m ) ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> lst2 [ i ] = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> x = 0 <NEWLINE> for j in range ( m ) : <NEWLINE> <INDENT> x = x + lst [ i ] [ j ] * lst2 [ j ] <NEWLINE> <DEDENT> print ( <STRING> % ( x ) ) <NEWLINE> <DEDENT>
[ n , m ] = [ int ( x ) for x in raw_input ( ) . split ( ) ] <NEWLINE> A = [ ] <NEWLINE> B = [ 0 ] * m <NEWLINE> <NL> counter = 0 <NEWLINE> while counter < n : <NEWLINE> <INDENT> A . append ( [ int ( x ) for x in raw_input ( ) . split ( ) ] ) <NEWLINE> counter += 1 <NEWLINE> <NL> <DEDENT> B [ counter ] = [ int ( raw_input ( ) ) for j in range ( m ) ] <NEWLINE> <NL> counter = 0 <NEWLINE> while counter < n : <NEWLINE> <INDENT> result = 0 <NEWLINE> for j in range ( m ) : <NEWLINE> <INDENT> result += A [ counter ] [ j ] * B [ j ] <NEWLINE> <DEDENT> print ( result ) <NEWLINE> counter += 1 <NEWLINE> <DEDENT>
a , b = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> A = [ map ( int , raw_input ( ) . split ( ) ) for _ in x range ( a ) ] <NEWLINE> B = [ input ( ) for _ in x range ( b ) ] <NEWLINE> C = [ sum ( [ A [ i ] [ j ] * B [ j ] for j in x range ( b ) ] ) for i in x range ( a ) ] <NEWLINE> for x in C : <NEWLINE> <INDENT> print x <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ] <NEWLINE> b = [ int ( input ( ) ) for _ in range ( m ) ] <NEWLINE> for i in a : <NEWLINE> <INDENT> c = 0 <NEWLINE> for j , k in i , b : <NEWLINE> <INDENT> c += j * k <NEWLINE> <DEDENT> print ( c ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> m , f , r = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if m + f + r == - 3 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> if m == - 1 or f == - 1 : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> elif m + f >= 80 : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> elif m + f >= 65 : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> elif m + f >= 50 : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> elif m + f >= 30 <NEWLINE> <INDENT> if r >= 50 : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> <DEDENT>
num = [ ] <NEWLINE> while True : <NEWLINE> <INDENT> l = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if l [ 0 ] == l [ 1 ] == l [ 2 ] == - 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> sum = l [ 0 ] + l [ 1 ] <NEWLINE> if sum >= 80 : <NEWLINE> <INDENT> num . append ( <STRING> ) <NEWLINE> <DEDENT> elif sum >= 65 : <NEWLINE> num . append ( <STRING> ) <NEWLINE> elif sum >= 50 : <NEWLINE> num . append ( <STRING> ) <NEWLINE> elif sum >= 30 : <NEWLINE> <INDENT> if l [ 2 ] >= 50 : <NEWLINE> num . append ( <STRING> ) <NEWLINE> else : <NEWLINE> num . append ( <STRING> ) <NEWLINE> <DEDENT> else <NEWLINE> num . append ( <STRING> ) <NEWLINE> <NL> <DEDENT> for i in range ( len ( num ) ) : <NEWLINE> <INDENT> print num [ i ] <NEWLINE> <DEDENT>
l = [ ] <NEWLINE> while True : <NEWLINE> <INDENT> m , f , r = map ( int , input ( ) . split ( ) ) <NEWLINE> if m == f == r == - 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> l . append ( [ m , f , r ] ) <NEWLINE> <DEDENT> <DEDENT> for i in l : <NEWLINE> <INDENT> s = <STRING> <NEWLINE> x = i [ 0 ] + i [ 1 ] <NEWLINE> if i [ 0 ] == - 1 or i [ 1 ] == - 1 : <NEWLINE> <INDENT> s = <STRING> <NEWLINE> <DEDENT> elif x >= 80 : <NEWLINE> <INDENT> s = <STRING> <NEWLINE> <DEDENT> elif x >= 65 : <NEWLINE> <INDENT> s = <STRING> : <NEWLINE> <DEDENT> elif x >= 50 : <NEWLINE> <INDENT> s = <STRING> : <NEWLINE> <DEDENT> elif x >= 30 : <NEWLINE> <INDENT> s = <STRING> <NEWLINE> if i [ 2 ] >= 50 : <NEWLINE> <INDENT> s = <STRING> <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> s = <STRING> <NEWLINE> <DEDENT> print ( s ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> import sys <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> while True : <NEWLINE> <COMMENT> <NL> <INDENT> m , f , r = [ int ( score ) for score in lines . split ( ) ] <NEWLINE> if m == f == r == - 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if m == - 1 or f == - 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif m + f >= 80 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif 80 > m + f >= 65 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif 65 > m + f >= 50 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif 50 > m + f >= 30 : <NEWLINE> <INDENT> if r >= 50 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> elif m + f < 30 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> m , f , r = map ( int , input ( ) . split ( ) ) <NEWLINE> g = m + f <NEWLINE> if m == - 1 and f == - 1 and r == - 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> elif m == - 1 or g == - 1 or g > 30 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif g >= 80 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif 65 <= g < 80 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif 50 <= g < 65 or 30 <= g < 50 and r >= 50 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif 30 <= g < 50 <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
while 1 : <NEWLINE> <INDENT> m , f , r = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> <COMMENT> <NL> score = m + f <NEWLINE> if m == - 1 or f == - 1 <NEWLINE> <INDENT> if r == - 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : print <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if score >= 80 : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if score >= 65 : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if score >= 50 or ( score >= 30 and r >= 50 ) : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if score >= 30 : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT>
while True : <NEWLINE> <INDENT> m , f , r = map ( raw_int , input ( ) . split ( ) ) <NEWLINE> s = m + f <NEWLINE> if m == - 1 and f == - 1 and r == - 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> elif m == - 1 or f == - 1 or s < 30 : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> elif s < 50 and r < 50 : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> elif s < 65 : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> elif s < 80 : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> <DEDENT>
int main ( void ) { <NEWLINE> <INDENT> int m , f , r ; <NEWLINE> scanf ( <STRING> , & m , & f , & r ) ; <NEWLINE> while ( m != - 1 | | f != - 1 | | r != - 1 ) { <NEWLINE> <INDENT> if ( m == - 1 | | f == - 1 ) printf ( <STRING> ) ; <NEWLINE> else if ( m + f >= 80 ) printf ( <STRING> ) ; <NEWLINE> else if ( m + f >= 65 ) printf ( <STRING> ) ; <NEWLINE> else if ( m + f >= 50 ) printf ( <STRING> ) ; <NEWLINE> else if ( m + f >= 30 ) { <NEWLINE> <INDENT> if ( r >= 50 ) printf ( <STRING> ) ; <NEWLINE> else printf ( <STRING> ) ; <NEWLINE> <DEDENT> } <NEWLINE> else printf ( <STRING> ) ; <NEWLINE> scanf ( <STRING> , & m , & f , & r ) ; <NEWLINE> <DEDENT> } <NEWLINE> return 0 ; <NEWLINE> <DEDENT> } <NEWLINE>
while True : <NEWLINE> <INDENT> m , f , r = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> if m == f == r - 1 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> total = m + f <NEWLINE> if m == - 1 or f == - 1 or total < 30 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> elif total < 50 and r < 50 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> elif total < 65 or r >= 50 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> elif total < 80 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
<NL> <INDENT> while True : <NEWLINE> m , f , r = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> if m == f == r == - 1 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> total = m + f <NEWLINE> if m == - 1 or f == - 1 or total < 30 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> elif total < 50 and r < 50 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> elif total < 65 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif total < 80 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
while True : <NEWLINE> <INDENT> m , f , r = map ( int , input ( ) . split ( ) ) <NEWLINE> if m == f == r == - 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if m == - 1 or f == - 1 : <NEWLINE> <INDENT> print ( F ) <NEWLINE> <DEDENT> elif ( m + f ) <= 80 : <NEWLINE> <INDENT> print ( A ) <NEWLINE> <DEDENT> elif ( m + f ) <= 65 : <NEWLINE> <INDENT> print ( B ) <NEWLINE> <DEDENT> elif ( m + f ) <= 50 : <NEWLINE> <INDENT> print ( C ) <NEWLINE> <DEDENT> elif ( m + f ) <= 30 and r <= 50 : <NEWLINE> <INDENT> print ( C ) <NEWLINE> <DEDENT> elif ( m + f ) <= 30 : <NEWLINE> <INDENT> print ( D ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( F ) <NEWLINE> <DEDENT> <DEDENT>
while True : <NEWLINE> <INDENT> m , f , r = map ( int , input ( ) . split ( ) ) <NEWLINE> if m + f + r = - 3 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if m == - 1 or f == - 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> S = m + f <NEWLINE> if S >= 80 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif S >= 65 and S < 80 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif S >= 50 and S < 65 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif S >= 30 and S < 50 : <NEWLINE> <INDENT> if r >= 50 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
while True : <NEWLINE> <INDENT> numlist = list ( int ( i ) for i in input ( ) . split ( ) ) <NEWLINE> mid = numlist [ 0 ] <NEWLINE> final = numlist [ 1 ] <NEWLINE> retest = numlist [ 2 ] <NEWLINE> <NL> sum = mid + final <NEWLINE> <NL> if mid == - 1 or final == - 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif mid == - 1 and final == - 1 and retest == - 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> elif sum >= 80 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif 80 > sum >= 65 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif 65 > sum >= 50 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif 50 > sum >= 30 and retest < 50 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif 50 > sum >= 30 and retest >= 50 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif sum < 30 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
while ( 1 ) : <NEWLINE> <INDENT> m , f , r = map ( int , input ( ) . split ( ) ) <NEWLINE> if m == - 1 and f == - 1 and r == - 1 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> if m == - 1 or f = - 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif m + f >= 80 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif m + f >= 65 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif m + f >= 50 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif m + f >= 30 : <NEWLINE> <INDENT> if r >= 50 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> <NL> while True : <NEWLINE> <INDENT> a = sys . stdin . readlines ( ) <NEWLINE> for i in range ( len ( a ) ) : <NEWLINE> <INDENT> b = a [ i ] . split ( ) <NEWLINE> m = int ( b [ 0 ] ) <NEWLINE> f = int ( b [ 1 ] ) <NEWLINE> r = int ( b [ 2 ] ) <NEWLINE> if m * f < 0 and r != - 1 : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> elif m == - 1 and f == - 1 and r == - 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if m + f >= 80 : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> elif 80 > m + f >= 65 : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> elif 65 > m + f >= 50 : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> elif 50 > m + f >= 30 and r < 50 : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> elif 50 > m + f >= 30 and r >= 50 : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> elif 30 > m + f : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT>
num = [ ] <NEWLINE> while True : <NEWLINE> <INDENT> m , f , r = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if m = - 1 : <NEWLINE> <INDENT> m = 0 <NEWLINE> <DEDENT> if f = - 1 : <NEWLINE> <INDENT> f = 0 <NEWLINE> <NL> <DEDENT> ans = m + f <NEWLINE> if m == f == r == - 1 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> if ans >= 80 : <NEWLINE> <INDENT> num . append ( <STRING> ) <NEWLINE> <DEDENT> elif ( 65 <= ans ) and ( ans < 80 ) : <NEWLINE> <INDENT> num . append ( <STRING> ) <NEWLINE> <DEDENT> elif ( 50 <= ans ) and ( ans < 65 ) : <NEWLINE> <INDENT> num . append ( <STRING> ) <NEWLINE> <DEDENT> elif ( 30 <= ans ) and ( ans < 50 ) : <NEWLINE> <INDENT> if r >= 50 : <NEWLINE> <INDENT> num . append ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> num . append ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( len ( num ) ) : <NEWLINE> <INDENT> print num [ i ] <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> ( m , f , r ) = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> if m == f == r == - 1 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> total = m + f <NEWLINE> if m == - 1 or f == - 1 or total < 30 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif total < 50 and r < 50 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif total < 65 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif total < 80 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> ~ <NEWLINE>
while True : <NEWLINE> <INDENT> m , f , r = map ( int , input ( ) . split ( ) ) <NEWLINE> if m == f == r == - 1 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> if s >= 80 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif s >= 65 and s < 80 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif ( s >= 50 and s < 65 ) or f >= 50 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif s >= 30 and s < 50 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <NL> <NL> <DEDENT> <DEDENT>
while ( 1 ) : <NEWLINE> <INDENT> m , f , r = map ( int , input ( ) . split ( ) ) <NEWLINE> if m == - 1 and f == - 1 and r == - 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> elif m == - 1 or f == - 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif m + f >= 80 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif m + f >= 65 and m + f < 80 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif m + f >= 50 and m + f < 65 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif m + f >= 30 and m + f < 50 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif r >= 50 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <NL> <NL> <NL> <DEDENT> <DEDENT>
while True : <NEWLINE> <INDENT> m , f , r = map ( int . input ( ) . split ( ) ) <NEWLINE> if m + f + r == - 3 : break <NEWLINE> if m == - 1 or f == - 1 or r == - 1 : <STRING> <NEWLINE> elif m + f >= 80 : s = <STRING> <NEWLINE> elif m + f >= 65 : s = <STRING> <NEWLINE> elif m + f >= 50 : s = <STRING> <NEWLINE> elif m + f >= 30 and r >= 50 : s = <STRING> <NEWLINE> elif m + f >= 30 : s = <STRING> <NEWLINE> else : <STRING> <NEWLINE> print ( str ( s ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> m , f , r = [ int ( i ) for i in input ( ) . split ] <NEWLINE> <NL> if m == f == r == - 1 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> total = m + f <NEWLINE> if m == - 1 or f == - 1 or total < 30 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> elif total < 50 and r < 50 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> elif total < 65 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> elif total < 80 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
while True : <NEWLINE> <INDENT> m , f , r = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> if m == f == r == - 1 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> elif m == - 1 or f == - 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> elif m + f >= 80 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> elif 65 <= m + f < 80 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> elif 50 <= m + f < 65 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> elif 30 <= m + f < 50 : <NEWLINE> <INDENT> if r > 50 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> else <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
While True : <NEWLINE> <INDENT> m , f , r = map ( int , input ( ) . split ( ) ) <NEWLINE> if m == f == r == - 1 : break <NEWLINE> a = m + f <NEWLINE> if m == - 1 or f == - 1 : print ( <STRING> ) <NEWLINE> elif a >= 80 : print ( <STRING> ) <NEWLINE> elif a >= 65 : print ( <STRING> ) <NEWLINE> elif a >= 50 : print ( <STRING> ) <NEWLINE> elif a >= 30 : <NEWLINE> <INDENT> if r >= 50 : print ( <STRING> ) <NEWLINE> else : print ( <STRING> ) <NEWLINE> <DEDENT> else : print ( <STRING> ) <NEWLINE> <DEDENT>
j <NEWLINE>
while True : <NEWLINE> <INDENT> ( m , f , r ) = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> if m == f == r == - 1 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> mf = m + f <NEWLINE> if mf <= 80 : <NEWLINE> <INDENT> priftf ( <STRING> ) <NEWLINE> <DEDENT> elif 65 <= mf <= 79 : <NEWLINE> <INDENT> printf ( <STRING> ) <NEWLINE> <DEDENT> elif 50 <= mf <= 64 | | r >= 50 : <NEWLINE> <INDENT> printf ( <STRING> ) <NEWLINE> <DEDENT> elif 30 <= mf <= 49 : <NEWLINE> <INDENT> printf ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> printf ( <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT>
while ( True ) <NEWLINE> <INDENT> m , f , r = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if m == - 1 and f == - 1 and r == - 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if m == - 1 or f == - 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif m + f >= 80 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif m + f >= 65 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif m + f >= 50 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif m + f >= 30 : <NEWLINE> <INDENT> if r >= 50 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
True : <NEWLINE> <INDENT> line = raw_input ( ) <NEWLINE> if line == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> middle , final , re = map ( int , line . split ( ) ) <NEWLINE> if middle == - 1 or final == - 1 : <NEWLINE> <INDENT> grade = <STRING> <NEWLINE> <DEDENT> elif middle + final >= 80 : <NEWLINE> <INDENT> grade = <STRING> <NEWLINE> <DEDENT> elif 65 <= middle + final < 80 : <NEWLINE> <INDENT> grade = <STRING> <NEWLINE> <DEDENT> elif 50 <= middle + final < 65 : <NEWLINE> <INDENT> grade = <STRING> <NEWLINE> <DEDENT> elif 30 <= middle + final < 50 : <NEWLINE> <INDENT> if 50 <= re : <NEWLINE> <INDENT> grade = <STRING> <NEWLINE> <DEDENT> grade = <STRING> <NEWLINE> <DEDENT> elif middle + final < 30 : <NEWLINE> <INDENT> grade = <STRING> <NEWLINE> <DEDENT> print grade <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> while True : <NEWLINE> <INDENT> n = sys . stdin . readline ( ) [ : - 1 ] <NEWLINE> <NL> if n = <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> marks = [ int ( m ) for m in n . split ( ) ] <NEWLINE> <NL> mt_points , retest = marks [ 0 ] + marks [ 1 ] , marks [ 2 ] <NEWLINE> <NL> if - 1 in marks [ : - 1 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> continue <NEWLINE> <DEDENT> elif mt_points >= 80 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> continue <NEWLINE> <DEDENT> elif mt_points >= 65 and 80 > mt_points : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> continue <NEWLINE> <DEDENT> elif mt_points >= 50 and 65 > mt_points : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> continue <NEWLINE> <DEDENT> elif mt_points >= 30 and 50 > mt_points : <NEWLINE> <INDENT> if retest >= 50 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> continue <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> continue <NEWLINE> <DEDENT> elif 30 > mt_points : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
while True : <NEWLINE> <INDENT> ( m , f , r ) = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> if m == f == r == - 1 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> mf = m + f <NEWLINE> <NL> if m == - 1 or f == - 1 of mf < 30 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif mf < 50 and r < 50 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif mf < 65 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif mf < 80 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
test = [ ] <NEWLINE> while True : <NEWLINE> <INDENT> tmp = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> for i in tmp : <NEWLINE> <INDENT> if i == - 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> test . append ( tmp ) <NEWLINE> <DEDENT> <DEDENT> for a in test : <NEWLINE> <INDENT> if a [ 0 ] + a [ 1 ] >= 80 : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> elif 80 > a [ 0 ] + a [ 1 ] >= 65 : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> elif 65 > a [ 0 ] + a [ 1 ] >= 50 : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> elif 50 > a [ 0 ] + a [ 1 ] >= 30 and a [ 2 ] < 50 : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> elif a [ 2 ] >= 50 : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> elif a [ 0 ] + a [ 1 ] < 30 : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> <DEDENT>
n , m = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> A = [ [ 0 for i in range ( m ) ] for i in range ( n ) ] <NEWLINE> B = [ 0 for i in range ( m ) ] <NEWLINE> <NL> <NL> for i in range ( n ) : <NEWLINE> <INDENT> A [ i ] = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> <DEDENT> for i in range ( m ) : <NEWLINE> <INDENT> B [ i ] = input ( ) <NEWLINE> <NL> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> sum = 0 <NEWLINE> for j in range ( m ) : <NEWLINE> <INDENT> sum += A [ i ] [ j ] * B [ j ] <NEWLINE> <DEDENT> print sum <NEWLINE> <DEDENT>
while 1 : <NEWLINE> <INDENT> m , f , r = map ( int , input ( ) . split ( ) ) <NEWLINE> if m == - 1 or f == - 1 or m + f < 30 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif 80 <= m + f : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif 65 <= m + f < 80 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif 50 <= m + f < 65 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif 30 <= m + f < 50 : <NEWLINE> <INDENT> if r >= 50 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> elif m == - 1 and f == - 1 and r == - 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT>
while 1 : <NEWLINE> <INDENT> m , f , r = raw_input ( ) . split ( ) <NEWLINE> sum = m + f <NEWLINE> if sum == - 2 : break <NEWLINE> elif min ( m , f ) == - 1 : print <STRING> <NEWLINE> elif sum > 80 : print <STRING> <NEWLINE> elif sum > 65 : print <STRING> <NEWLINE> elif sum > 50 : print <STRING> <NEWLINE> elif sum > 30 : <NEWLINE> <INDENT> if r > 50 : print <STRING> <NEWLINE> else : print <STRING> <NEWLINE> <DEDENT> else : print <STRING> <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> m , f , r = map ( int , input ( ) . split ( ) ) <NEWLINE> if m == - 1 and f == - 1 and r == - 1 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> elif m == - 1 or f == - 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif m + f >= 80 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif m + f >= 65 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif m + f >= 50 or ( r >= 50 and m + f >= 30 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif m + f >= 30 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif m + f < 30 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <NL> <NL> <DEDENT> <DEDENT>
while True : <NEWLINE> <INDENT> m , f , r = map ( int , input ( ) . split ( ) ) <NEWLINE> if m == f == r == - 1 : break <NEWLINE> <NL> if ( m == - 1 ) or ( f == - 1 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> if ( m + f >= 80 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> if ( 65 <= m + f ) and ( m + f < 80 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> if ( 50 <= m + f ) and ( m + f < 60 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> if ( 30 <= m + f ) and ( m + f < 50 ) : <NEWLINE> <INDENT> if ( 50 <= r ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> if ( m + f < 30 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
while True : <NEWLINE> if m == - 1 or f == - 1 or m + f < 30 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> elif m + f >= 80 : <NEWLINE> print ( <STRING> ) <NEWLINE> elif m + f >= 65 : <NEWLINE> print ( <STRING> ) <NEWLINE> elif m + f >= 50 : <NEWLINE> print ( <STRING> ) <NEWLINE> elif m + f >= 30 : <NEWLINE> print ( <STRING> if r >= 50 else <STRING> ) <NEWLINE> <DEDENT>
import sys <NEWLINE> while True : <NEWLINE> <INDENT> data = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if data [ 0 ] == data [ 1 ] == data [ 2 ] == - 1 : break <NEWLINE> <NL> if data [ 0 ] != - 1 and data [ 1 ] != - 1 : <NEWLINE> <INDENT> sum = data [ 0 ] + data [ 1 ] <NEWLINE> <DEDENT> if data [ 2 ] != - 1 and sum < data [ 2 ] <NEWLINE> <INDENT> sum = data [ 2 ] <NEWLINE> if sum >= 50 : <NEWLINE> <INDENT> sum = 50 <NEWLINE> <DEDENT> elif sum < 50 : <NEWLINE> <INDENT> sum = 0 <NEWLINE> <DEDENT> <DEDENT> if data [ 0 ] == - 1 or data [ 1 ] == - 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif sum < 30 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif 30 <= sum < 50 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif 50 <= sum < 65 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif 65 <= sum <= 79 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif 80 <= sum : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT>
while True : <NEWLINE> <INDENT> points = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if points == [ - 1 , - 1 , - 1 ] : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> gou = points [ 0 ] + points [ 1 ] <NEWLINE> if - 1 in points [ 0 ] or - 1 in points [ 1 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif gou >= 80 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif 65 <= gou < 80 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif 50 <= gou < 65 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif 30 <= gou < 50 : <NEWLINE> <INDENT> if points [ 2 ] >= 50 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
while True : <NEWLINE> <INDENT> m , f , r = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if m == - 1 and f == - 1 and r == - 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> elif m == - 1 or f == - 1 : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> elif m + f >= 80 : <NEWLINE> <INDENT> print <STRING> a <NEWLINE> <DEDENT> elif m + f >= 65 : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> elif m + f >= 50 : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> elif m + f >= 30 and f >= 50 : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> elif m + f >= 30 : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> <DEDENT>
<INDENT> if m == f == r == - 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if m == - 1 or f == - 1 or m + f < 30 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif m + f >= 80 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif 80 > m + f >= 65 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif ( 65 > m + f >= 50 ) or ( 50 > m + f >= 35 and r >= 50 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
while True : <NEWLINE> <INDENT> ( m , f , r ) = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> if m == f == r == - 1 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> total = m + f <NEWLINE> if m == - 1 or f == - 1 or total < 30 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif total < 50 and r < 5 - : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif total < 65 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif total < 85 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
while True : <NEWLINE> <INDENT> m , f , r = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> if m == f == r == - 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> elif m or f == - 1 : <NEWLINE> <INDENT> return F <NEWLINE> <NL> <DEDENT> elif m + f >= 80 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif 65 <= m + f < 80 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif 50 <= m + f < 65 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif 30 <= m + f < 50 : <NEWLINE> <INDENT> if r >= 50 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> elif m + f < 30 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
while 1 : <NEWLINE> <INDENT> m , f , r = map ( int , input ( ) . split ( ) ) ; s = m + f <NEWLINE> if m * f < - 1 : break <NEWLINE> if m == - 1 or f == - 1 or s < 30 : print ( <STRING> ) <NEWLINE> elif s > 79 : print ( <STRING> ) <NEWLINE> elif s > 64 : print ( <STRING> ) <NEWLINE> elif s > 49 or r > 49 : print ( <STRING> ) <NEWLINE> else : print ( <STRING> ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> m , f , r = map ( int , input ( ) . split ( ) ) <NEWLINE> if m == f == r == - 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> elif ( m + f ) >= 80 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif ( m + f ) < 80 and ( m + f ) >= 65 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif ( ( m + f ) < 65 and ( m + f ) >= 50 ) or ( ( ( m + f ) < 50 and ( m + f ) >= 30 and ( m != - 1 and f != - 1 ) ) and r >= 50 ) <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif ( m + f ) < 50 and ( m + f ) >= 30 and ( m != - 1 and f != - 1 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
while True : <NEWLINE> <INDENT> ( m , f , r ) = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> if m == f == r == - 1 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> total = m + f <NEWLINE> if m == - 1 or f == - 1 or total < 30 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif total < 50 and r < 50 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif total < 65 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif total < 80 : <NEWLINE> <INDENT> print ( <STRING> ) : <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
while True : <NEWLINE> <INDENT> m , f , v = [ int ( n ) for n in input ( ) . split ( ) ] <NEWLINE> <NL> if m == f == v == - 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> sum = m + f <NEWLINE> if m == - 1 or f == - 1 <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif 80 <= sum : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif 65 <= sum < 80 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif 50 <= sum < 65 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif 30 <= sum < 50 : <NEWLINE> <INDENT> if 50 <= v : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
while True : <NEWLINE> <INDENT> m , f , r = map ( int , input ( ) . split ( ) ) <NEWLINE> if m == - 1 and f == - 1 and r == - 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> elif m == - 1 or f == - 1 : <NEWLINE> <INDENT> grade = <STRING> <NEWLINE> <DEDENT> elif ( m + f ) >= 80 : <NEWLINE> <INDENT> grade = <STRING> <NEWLINE> <DEDENT> elif ( m + f ) = > 65 : <NEWLINE> <INDENT> grade = <STRING> <NEWLINE> <DEDENT> elif ( m + f ) = > 50 : <NEWLINE> <INDENT> grade = <STRING> <NEWLINE> <DEDENT> elif ( m + f ) = > 30 : <NEWLINE> <INDENT> if r > 50 : <NEWLINE> <INDENT> grade = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> grade = <STRING> <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> grade = <STRING> <NEWLINE> <DEDENT> print ( grade ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <NL> <INDENT> ( m , f , r ) = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> if m == f == - 1 : <NEWLINE> <INDENT> break <NEWLINE> <NL> total = m + f <NEWLINE> if m == - 1 or == - 1 or total < 30 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif total < 50 and r < 50 : <NEWLINE> print ( <STRING> ) <NEWLINE> elif total < 65 : <NEWLINE> print ( <STRING> ) <NEWLINE> elif total < 80 : <NEWLINE> print ( <STRING> ) <NEWLINE> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
while True : <NEWLINE> <INDENT> m , f , r = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> m + f = s <NEWLINE> if m == - 1 and f == - 1 and r == - 1 : break <NEWLINE> elif m == - 1 or f == - 1 or r < 30 : g = 4 <NEWLINE> elif 30 <= s and s < 50 : <NEWLINE> <INDENT> if r <= 50 : g = 2 <NEWLINE> else : g = 3 <NEWLINE> <DEDENT> elif 50 <= s and s < 65 : g = 2 <NEWLINE> elif 65 <= s and s < 70 : g = 1 <NEWLINE> else : g = 0 <NEWLINE> print <STRING> [ g ] <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> m , f , r = map ( int , input ( ) . split ( ) ) <NEWLINE> if ( m , f , r ) = ( - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if m + f >= 80 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif m + f >= 65 and m + f < 80 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif m + f >= 50 and m + f < 65 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif m + f >= 30 and m + f < 50 : <NEWLINE> <INDENT> if r >= 50 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> while True : <NEWLINE> <INDENT> m , f , r = map ( int , input ( ) . split ( ) ) <NEWLINE> if m + f >= 80 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif m + f >= 65 and m + f < 80 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif m + f >= 50 and m + f < 65 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif m + f >= 30 and m + f < 50 : <NEWLINE> <INDENT> if r >= 50 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> elif m + f < 30 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
while True : <NEWLINE> <INDENT> ( m , f , r ) = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> if m == f == r == - 1 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> mf = m + f <NEWLINE> <NL> if m == - 1 or f == - 1 mf < 30 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif mf < 50 and r < 50 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif mf < 65 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif mf < 80 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
for _ in [ None ] * 50 : <NEWLINE> <INDENT> m , f , r = map ( int , input ( ) . split ( ) ) <NEWLINE> result = <STRING> <NEWLINE> if m == f == r == - 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if m == - 1 or f == - 1 or m + f < 30 : <NEWLINE> <INDENT> result = <STRING> <NEWLINE> <DEDENT> elif m + f > 80 : <NEWLINE> <INDENT> result = <STRING> <NEWLINE> <DEDENT> elif 80 > m + f >= 65 : <NEWLINE> <INDENT> result = <STRING> <NEWLINE> <DEDENT> elif 65 > m + f >= 50 : <NEWLINE> <INDENT> result = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> result = <STRING> if r >= 50 else result = <STRING> <NEWLINE> <DEDENT> print ( result ) <NEWLINE> <NL> <DEDENT>
while True : <NEWLINE> <INDENT> m , f , r = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> if m == f == r == - 1 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> elif m or f == - 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> elif m + f >= 80 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> elif m + f >= 65 < 79 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> elif m + f >= 50 < 64 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> elif m + f >= 30 < 49 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> elif m + f >= 50 < 49 : <NEWLINE> <INDENT> r >= 50 : <NEWLINE> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> elif m + f < 30 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
student_info = [ ] <NEWLINE> while True : <NEWLINE> <INDENT> s = map ( int , raw_input ( ) . split ( <STRING> ) ) <NEWLINE> <NL> if s [ 0 ] is s [ 1 ] is s [ 2 ] is - 1 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> student_info . append ( s ) <NEWLINE> <NL> <DEDENT> score_info = [ ] <NEWLINE> for s in student_info : <NEWLINE> <INDENT> if s [ 0 ] == - 1 or s [ 1 ] == - 1 : <NEWLINE> <INDENT> score_info . append ( <STRING> ) <NEWLINE> <NL> <DEDENT> elif s [ 0 ] + s [ 1 ] >= 80 : <NEWLINE> <INDENT> score_info . append ( <STRING> ) <NEWLINE> <NL> <DEDENT> elif 65 <= s [ 0 ] + s [ 1 ] < 80 : <NEWLINE> <INDENT> score_info . appned ( <STRING> ) <NEWLINE> <NL> <DEDENT> elif 50 <= s [ 0 ] + s [ 1 ] < 65 : <NEWLINE> <INDENT> score_info . append ( <STRING> ) <NEWLINE> <NL> <DEDENT> elif 30 <= s [ 0 ] + s [ 1 ] < 50 : <NEWLINE> <INDENT> if s [ 2 ] >= 50 : <NEWLINE> <INDENT> score_info . append ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> score_info . append ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> score_info . append ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> for i in score_info : <NEWLINE> <INDENT> print i <NEWLINE> <DEDENT>
<NL> while True : <NEWLINE> <INDENT> m , f , r = list ( map ( int , input ( ) ) ) <NEWLINE> if m == f == r == - 1 : break <NEWLINE> s = m + r <NEWLINE> print ( <STRING> if m * f < 0 or s < 30 else <STRING> if 30 <= s < 50 and r < 50 else <STRING> if 50 <= s < 65 or m >= 50 else <STRING> if 65 <= s < 80 else <STRING> ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> m , f , r = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> if m == f == r == - 1 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> total = m + f <NEWLINE> if m == - 1 or f == - 1 or total < 30 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> elif total < 50 and r < 50 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> elif total < 65 <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> elif total < 80 : <NEWLINE> <INDENT> pirnt ( <STRING> ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
while True : <NEWLINE> <INDENT> m , f , r = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> if m == f == r == - 1 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> total = m + f <NEWLINE> if m == - 1 or f == - 1 or total < 30 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> elif total < 50 anfd r < 50 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> elif total < 65 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> elif total < 80 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
m , f , r = map ( int , input ( ) . split ( ) ) <NEWLINE> if m == - 1 or f == - 1 or m + f < 30 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif m == f == r == - 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> elif m + f >= 80 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif 65 <= m + f < 80 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif 50 <= m + f < 65 or r >= 50 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
def solve ( n , x ) : <NEWLINE> <INDENT> count = 0 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n + 1 ) : <NEWLINE> <INDENT> k = x - i - j <NEWLINE> if j < b and b <= n : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return count // 6 <NEWLINE> <NL> <DEDENT> while True : <NEWLINE> <INDENT> n , x = map ( int , input ( ) . split ( ) ) <NEWLINE> if n == x == 0 : <NEWLINE> <INDENT> break ; <NEWLINE> <DEDENT> print ( solve ( n , x ) ) <NEWLINE> <DEDENT>
from itertools import combinations <NEWLINE> while True : <NEWLINE> <INDENT> n , x = map ( int , input ( ) . split ( ) ) <NEWLINE> if n == x == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> print ( sum ( a + b + c == x for a , b , c in combinations ( range ( 1 , n + 1 ) , 3 ) ) <NEWLINE> <NL> <DEDENT>
while True : <NEWLINE> <INDENT> ( n , x ) = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> if n == x == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> for a in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> for b in range ( a + 1 , n + 1 ) : <NEWLINE> <INDENT> for c in range ( b + 1 , n + 1 ) : <NEWLINE> <INDENT> count = 0 <NEWLINE> if ( a + b + c ) == x : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> elif ( a + b + c ) > x : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE> <DEDENT> ~ <NEWLINE>
<COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> result = [ ] <NEWLINE> n = [ ] <NEWLINE> x = [ ] <NEWLINE> <NL> while 1 : <NEWLINE> <INDENT> temp = input ( ) . split ( ) <NEWLINE> if temp [ 0 ] == <STRING> and temp [ 1 ] == <STRING> : <NEWLINE> <INDENT> break ; <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> n . append ( int ( temp [ 0 ] ) ) <NEWLINE> x . append ( int ( temp [ 1 ] ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( len ( n ) ) : <NEWLINE> <INDENT> count = 0 <NEWLINE> for n1 in range ( 1 , n [ i ] + 1 - 2 ) : <NEWLINE> <INDENT> for n2 in range ( n1 + 1 , n [ i ] + 1 - 1 ) : <NEWLINE> <INDENT> for n3 in range ( n2 + 1 , n [ i ] + 1 ) : <NEWLINE> <INDENT> sum = n1 + n2 + n3 <NEWLINE> if sum == x [ i ] : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> result . append ( count ) <NEWLINE> <NL> <DEDENT> for i in range ( len ( result ) - 1 ) : <NEWLINE> <INDENT> print ( <STRING> . format ( result [ i ] ) , end = <STRING> ) <NEWLINE> <NL> <DEDENT> print ( result [ i + 1 ] ) <NEWLINE>
( n , x ) = map ( int , input ( ) . split ( ) ) <NEWLINE> while True : <NEWLINE> <INDENT> if n == 0 and x == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> c = 0 <NEWLINE> for i in range ( 1 , n - 1 ) : <NEWLINE> <INDENT> for j in range ( i , n ) : <NEWLINE> <INDENT> for k in range ( j , n + 1 ) : <NEWLINE> <INDENT> s = i + j + k <NEWLINE> if s == x : <NEWLINE> <INDENT> c += 1 <NEWLINE> <DEDENT> if s > x : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> if s > x : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> if s > x : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> print ( c ) <NEWLINE> <DEDENT>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = 0 <NEWLINE> while not ( N == 0 and M == 0 ) : <NEWLINE> <INDENT> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> for j in range ( i , N + 1 ) : <NEWLINE> <INDENT> k = M - i - j <NEWLINE> if ( i == j or i == k or j == k ) : pass <NEWLINE> elif ( i + j + k == M ) : ans += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
e , a = map ( int , input ( ) . split ( ) ) <NEWLINE> cnt = 0 <NEWLINE> while True : <NEWLINE> <INDENT> if e == 0 and a == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for i in range ( 1 , a + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , a + 1 ) : <NEWLINE> <INDENT> if j <= i : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <DEDENT> X = a - ( i + j ) <NEWLINE> if X > j and X <= a : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> n , x = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if n == 0 and x == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> a = 0 <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n ) : <NEWLINE> <INDENT> b = x - ( i + j ) <NEWLINE> if b > j and b <= n : <NEWLINE> <INDENT> a += 1 <NEWLINE> <DEDENT> <DEDENT> print ( a ) <NEWLINE> <DEDENT> <DEDENT>
while True : <NEWLINE> <INDENT> n , x = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> if n == x == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> count = 0 <NEWLINE> for s in range ( 1 , n - 1 ) : <NEWLINE> <INDENT> for m in range ( s + 1 , n ) : <NEWLINE> <INDENT> for e in range ( m + 1 , n + 1 ) : <NEWLINE> <INDENT> if x == sum ( s , m , e ) : <NEWLINE> <INDENT> count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> ( n , x ) = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> if n == x == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> count = 0 <NEWLINE> for a in range ( x , 0 , step = - 1 ) : <NEWLINE> <INDENT> for b in range ( a - 1 , 0 , step = - 1 ) : <NEWLINE> <INDENT> if sum ( a , b ) > x : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for c in range ( b - 1 , 0 , step = - 1 ) : <NEWLINE> <INDENT> if sum ( a , b , c ) == x : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <STRING> <NEWLINE> <INDENT> print ( count ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> n , x = map ( int , input ( ) . split ( ) ) <NEWLINE> if n == 0 and x == 0 : break <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , i ) : <NEWLINE> <INDENT> for k in range ( 1 , j ) : <NEWLINE> <INDENT> if i + j + k == x : a = a + 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( a ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> import itertools : <NEWLINE> <NL> while True : <NEWLINE> <INDENT> n , x = map ( int , input ( ) . split ( ) ) <NEWLINE> if n == 0 and x == 0 : break <NEWLINE> count = 0 <NEWLINE> for a , b , c in itertools . permutations ( range ( n ) , 3 ) : <NEWLINE> <INDENT> if a + b + c == x : count += 1 <NEWLINE> <DEDENT> print count <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> <COMMENT> <NL> fin = sys . stdin <NEWLINE> <NL> while True : <NEWLINE> <INDENT> [ m , f , r ] = list ( map ( int , fin . readline ( ) . split ( ) ) ) <NEWLINE> <NL> if m == - 1 and f == - 1 and r == - 1 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> sum_mf = m + f <NEWLINE> if m == - 1 or f == - 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif sum_mf >= 80 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif sum_mf >= 65 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif sum_mf >= 50 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif sum_mf >= 30 : <NEWLINE> <INDENT> if r >= 50 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
from itertools import combinations <NEWLINE> while True : <NEWLINE> <INDENT> n , x = map ( int , input ( ) . split ( ) ) <NEWLINE> if n == x == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> print ( len ( 1 for a , b , c in combinations ( range ( 1 , n + 1 ) , 3 ) if a + b + c == x ) ) <NEWLINE> <NL> <DEDENT>
def counter ( n , x ) : <NEWLINE> <INDENT> count = 0 <NEWLINE> for i in range ( n - 2 ) : <NEWLINE> <INDENT> for j in range ( 1 , n - 1 ) : <NEWLINE> <INDENT> for k in range ( 2 , n ) : <NEWLINE> <INDENT> if i + j + k == x : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> return count <NEWLINE> <NL> <DEDENT> while True : <NEWLINE> <INDENT> n , x = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( counter ( n , x ) ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> def main ( ) : <NEWLINE> <NL> <INDENT> while True : <NEWLINE> <INDENT> n , x = map ( int , input ( ) . split ( ) ) <NEWLINE> if ( ( n == 0 ) and ( x == 0 ) ) : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> count = 0 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> for k in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if ( ( i < j ) and ( j < k ) and i + j + k == x ) : <NEWLINE> count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = 0 <NEWLINE> while 1 : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if a == 0 and b == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( 1 , a + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , i ) : <NEWLINE> <INDENT> for k in range ( 1 , j ) : <NEWLINE> <INDENT> if i + j + k = b : <NEWLINE> <INDENT> n += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( n ) <NEWLINE> <NL> <DEDENT> <DEDENT>
n , x = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> <NL> if n == x == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> count = 0 <NEWLINE> for s in range ( 1 , n // 2 + 1 ) : <NEWLINE> <INDENT> for e in range ( n , n // 2 + 1 , - 1 ) : <NEWLINE> <INDENT> m = x - s - e <NEWLINE> if m != s and m != e and m <= n and m > s and m < e : <NEWLINE> <INDENT> count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( count ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> cou = 0 <NEWLINE> n , x = map ( int , input ( ) . split ( ) ) <NEWLINE> if n == 0 and x == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for i in range ( 1 , x ) : <NEWLINE> <INDENT> for j in range ( j , x ) : <NEWLINE> <INDENT> k = x - i - j <NEWLINE> if i <= n and j <= n and k <= n : <NEWLINE> <INDENT> cou += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( cou ) <NEWLINE> <NL> <DEDENT>
while ( 1 ) : <NEWLINE> <INDENT> n , x = map ( int , input ( ) . split ( ) ) <NEWLINE> t = 0 <NEWLINE> if n == x == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n + 1 ) : <NEWLINE> <INDENT> for k in range ( k + 1 , n + 1 ) : <NEWLINE> <INDENT> if i + j + k == x : <NEWLINE> <INDENT> if i != j and j != k and k != i : <NEWLINE> <INDENT> t += 1 <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( t ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> a = 0 <NEWLINE> num = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if num [ 0 ] == 0 and n [ 1 ] == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( 1 , num [ 0 ] + 1 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , num [ 0 ] + 1 ) : <NEWLINE> <INDENT> for k in range ( j + 1 , num [ 0 ] + 1 ) : <NEWLINE> <INDENT> if i + j + k == num [ 1 ] : <NEWLINE> <INDENT> a += 1 <NEWLINE> print ( i , j , k ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT>
( n , x ) = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> count = 0 <NEWLINE> for a in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> for b in range ( a + 1 , n + 1 ) : <NEWLINE> <INDENT> for c in range ( b + 1 , n + 1 ) : <NEWLINE> <INDENT> if n = x = 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> elif a + b + c == 9 : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
while True : <NEWLINE> <INDENT> n , x = map ( int , input ( ) . split ( ) ) <NEWLINE> if n = 0 and x = 0 : break <NEWLINE> ans = 0 <NEWLINE> for a in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> for b in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if b <= a : continue <NEWLINE> c = x - ( a + b ) <NEWLINE> if c > b and c <= n : ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> % ( ans ) ) <NEWLINE> <NL> <DEDENT>
while True : <NEWLINE> <INDENT> ( n , x ) = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> if n == x == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> count = 0 <NEWLINE> for a in range ( 1 , n + 1 = 2 ) : <NEWLINE> <INDENT> for b in range ( a + 1 , n + 1 - 1 ) : <NEWLINE> <INDENT> for c in range ( b + 1 , n + 1 ) : <NEWLINE> <INDENT> if ( a + b + c ) == x : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> n , x = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> if n == x == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> count = 0 <NEWLINE> for s in range ( 1 , n - 1 ) : <NEWLINE> <INDENT> for m in range ( s + 1 , n ) : <NEWLINE> <INDENT> for e in range ( m + 1 , n + 1 ) : <NEWLINE> <INDENT> if x == sum ( s , m , e ) : <NEWLINE> <INDENT> count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE> <DEDENT>
while 1 : <NEWLINE> <INDENT> n , x = map ( int , input ( ) . split ( ) ) <NEWLINE> if n + x == 0 : break <NEWLINE> print ( sum ( [ 1 for j in range ( 2 , x - i ) for i in range ( 3 , n + 1 ) if x - i - j < j < i ] ) ) <NEWLINE> <DEDENT>
def countCombinationsNumpy ( n , x , size = 3 ) : <NEWLINE> <INDENT> dp = np . zeros ( ( x + 1 , size + 1 ) , dtype = int ) <NEWLINE> dp [ 0 , 0 ] = 1 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> dp [ i : , 1 : ] += dp [ : - i , : - 1 ] <NEWLINE> print ( dp ) <NEWLINE> <DEDENT> return dp [ - 1 , - 1 ] <NEWLINE> <NL> <NL> <NL> <DEDENT> while True : <NEWLINE> <INDENT> m , n = ( int ( x ) for x in input ( ) . split ( ) ) <NEWLINE> if m == 0 and n == 0 : <NEWLINE> <INDENT> quit ( ) <NEWLINE> <DEDENT> ans = countCombinations ( m , n ) <NEWLINE> print ( ans ) <NEWLINE> <DEDENT>
import itertools <NEWLINE> while True : <NEWLINE> <INDENT> ( n , x ) = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> if n == x == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> print ( [ 1 if sum ( ) == x else 0 for i in itertools . combinations ( range ( 1 , n + 1 ) , 3 ) ] ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> n , x = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if n == 0 & & x == 0 : break <NEWLINE> count = 0 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n + 1 ) : <NEWLINE> <INDENT> for k in range ( j + 1 , n + 1 ) : <NEWLINE> <INDENT> print str ( i ) + <STRING> + str ( j ) + <STRING> + str ( k ) <NEWLINE> if i + j + k == x : <NEWLINE> <DEDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> print count <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> k = map ( int , raw_input ( ) . split ( <STRING> ) ) <NEWLINE> ct = 0 <NEWLINE> a = 0 <NEWLINE> b = 0 <NEWLINE> c = 0 <NEWLINE> max = k [ 0 ] <NEWLINE> sum = k [ 1 ] <NEWLINE> a = max + 1 <NEWLINE> <NL> while True : <NEWLINE> <INDENT> a -= 1 <NEWLINE> b = a - 1 <NEWLINE> c = sum - a - b <NEWLINE> if not a > b > c : <NEWLINE> <INDENT> print ct <NEWLINE> break <NEWLINE> <DEDENT> while a > b > c : <NEWLINE> <INDENT> if a > b > c > 0 : <NEWLINE> <INDENT> ct += 1 <NEWLINE> <DEDENT> b -= 1 <NEWLINE> c += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
while True : <NEWLINE> <INDENT> ( n , x ) = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> if n == x == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> cnt = 0 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n + 1 ) : <NEWLINE> <INDENT> for k in range ( j + 1 , n + 1 ) : <NEWLINE> <INDENT> if ( i + j + k ) == x : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> elif ( i + j + K ) > x : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print cnt <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <STRING> <NEWLINE> <NL> while True : <NEWLINE> <INDENT> inp = input ( ) . strip ( ) . split ( <STRING> ) <NEWLINE> n = int ( inp [ 0 ] ) + 1 <NEWLINE> x = int ( inp [ 1 ] ) <NEWLINE> cnt = 0 <NEWLINE> if n < 1 and x < 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for i in range ( 1 , n - 2 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n - 1 ) : <NEWLINE> <INDENT> for k in range ( j + 1 , n ) : <NEWLINE> <INDENT> t = i + j + k <NEWLINE> if t == x : <NEWLINE> <INDENT> cnt = cnt + 1 <NEWLINE> <DEDENT> elif t > x : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> n , x = map ( int , raw_input ( ) . split ( ) <NEWLINE> if n == 0 and x == 0 : break <NEWLINE> c = 0 <NEWLINE> for i in range ( 1 , n / 3 + 1 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n / 2 + 1 ) : <NEWLINE> <INDENT> ij = i + j <NEWLINE> for k in range ( j + 1 , n + 1 ) : <NEWLINE> <INDENT> if ij + k == x : <NEWLINE> <INDENT> c += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print c <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> n , x = map ( int , input ( ) . split ( ) ) <NEWLINE> if n == x == 0 : break <NEWLINE> c = 0 <NEWLINE> for i in range ( math . ceil ( n / 3 ) , n + 1 ) : <NEWLINE> <INDENT> c += ( n - i ) // 2 <NEWLINE> <DEDENT> print ( c ) <NEWLINE> <DEDENT>
count_a = [ ] <NEWLINE> pos = 0 <NEWLINE> while True : <NEWLINE> <INDENT> n , x = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> count = 0 <NEWLINE> if n == x == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( 1 , ( n + 1 ) ) : <NEWLINE> <INDENT> for j in range ( i + 1 , ( n + 1 ) ) : <NEWLINE> <INDENT> for k in range ( j + s1 , ( n + 1 ) ) : <NEWLINE> <INDENT> if ( i != j ) and ( j != k ) and ( i != k ) : <NEWLINE> <INDENT> if ( i + j + k ) == x : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> count_a . append ( count ) <NEWLINE> pos = pos + 1 <NEWLINE> <NL> <DEDENT> <DEDENT> for i in count_a : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT>
e , a = map ( int , input ( ) . split ( ) ) <NEWLINE> cnt = 0 <NEWLINE> while True : <NEWLINE> <INDENT> if e == 0 and a == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for i in range ( 1 , a + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , a + 1 ) : <NEWLINE> <INDENT> if j <= i : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <DEDENT> X = a - ( i + j ) <NEWLINE> if X > j and X <= a : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
while True : <NEWLINE> <INDENT> n , x = map ( int , input ( ) . split ( ) ) <NEWLINE> count = 0 <NEWLINE> if n == x == 0 : break <NEWLINE> else : <NEWLINE> for i in range ( 1 , n - 1 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n ) : <NEWLINE> <INDENT> for k in range ( j + 1 , n + 1 ) : <NEWLINE> <INDENT> if i + j + k == x : <NEWLINE> <INDENT> count = count + 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
<STRING> <NEWLINE> n , x = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> while True : <NEWLINE> <NL> <COMMENT> <NL> <INDENT> if n == x == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> ansCnt = 0 <NEWLINE> for cnt1 in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> for cnt2 in range ( cnt1 + 1 , n + 1 ) : <NEWLINE> <INDENT> for cnt3 in range ( cnt2 + 1 , n + 1 ) : <NEWLINE> <INDENT> if cnt1 + cnt2 + cnt3 == x : <NEWLINE> <INDENT> ansCnt += 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ansCnt ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> n , x = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if n == 0 and x == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> count = 0 <NEWLINE> for i in range ( 1 , n - 2 ) : <NEWLINE> <INDENT> for j in range ( i , n - 1 ) : <NEWLINE> <INDENT> k in range ( j , n ) : <NEWLINE> <INDENT> if i + j + k == x : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print count <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> n , x = map ( int , input ( ) . split ( ) ) <NEWLINE> if n == x == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> d = o <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n + 1 ) : <NEWLINE> <INDENT> k = x - ( i + j ) <NEWLINE> if k >= 1 and k <= n and k > j : <NEWLINE> <INDENT> d += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( d ) <NEWLINE> <NL> <NL> <DEDENT>
import itertools <NEWLINE> <NL> def main ( ) : <NEWLINE> <NL> <INDENT> data = [ ] <NEWLINE> while True : <NEWLINE> <INDENT> n , x = map ( int , input ( ) . split ( ) ) <NEWLINE> if [ n , x ] == [ 0 , 0 ] : break <NEWLINE> data . append ( [ n , x ] ) <NEWLINE> <NL> <DEDENT> for [ n , x ] in data : <NEWLINE> <INDENT> _set = set ( range ( 1 , n + 1 ) ) <NEWLINE> comb = set ( itertools . combinations ( _list , 3 ) ) <NEWLINE> print ( sum ( ( True if sum ( i ) == x else False ) for i in comb ) ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> main ( ) <NEWLINE>
while True : <NEWLINE> <INDENT> n , x = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if n == 0 and x == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> ct = 0 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n + 1 ) : <NEWLINE> <INDENT> for k in range ( j + 1 , n + 1 ) : <NEWLINE> <INDENT> if ( i + j + k ) == x : <NEWLINE> <INDENT> ct += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ct <NEWLINE> <DEDENT> ~ <NEWLINE>
s = [ ] <NEWLINE> while True : <NEWLINE> <INDENT> n , x = map ( int , input ( ) . strip ( ) . split ( ) ) <NEWLINE> if n == x == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> c = 0 <NEWLINE> for i in range ( 1 , x / 3 ) : <NEWLINE> <INDENT> c += max ( 0 , ( i + 1 - x ) // 2 + n ) <NEWLINE> <DEDENT> s . append ( str ( c ) ) <NEWLINE> <DEDENT> print ( <STRING> . join ( s ) ) <NEWLINE>
while True : <NEWLINE> <INDENT> ( n , x ) = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> if n == x == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> count = 0 <NEWLINE> for a int range ( 1 , n + 1 - 2 ) : <NEWLINE> <INDENT> for b in range ( a + 1 , n + 1 - 1 ) : <NEWLINE> <INDENT> for c in range ( b + 1 , n + 1 ) : <NEWLINE> <INDENT> if ( a + b + c ) == x : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> n , x = map ( int , input ( ) . split ( ) ) <NEWLINE> if ( n == x == 0 ) : <NEWLINE> break <NEWLINE> <NL> count = 0 <NEWLINE> for a in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> for b in range ( a + 1 , n + 1 ) : <NEWLINE> <INDENT> for c in range ( b + 1 , n + 1 ) : <NEWLINE> <INDENT> Sum = a + b + c <NEWLINE> if ( Sum == x ) : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE> <DEDENT>
from itertools import combinations as comb <NEWLINE> def get_ans ( ) : <NEWLINE> <INDENT> m , n = ( int ( x ) for x in input ( ) . split ( ) ) <NEWLINE> if m == 0 and n == 0 : <NEWLINE> <INDENT> quit ( ) <NEWLINE> <DEDENT> ans = 0 <NEWLINE> for nums in comb ( list ( range ( 1 , min ( m , n - 3 ) ) ) ) : <NEWLINE> <INDENT> if sum ( nums ) == n : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> while True : <NEWLINE> <INDENT> get_ans ( ) <NEWLINE> <DEDENT>
while ( 1 ) : <NEWLINE> <INDENT> count = 0 <NEWLINE> inp = raw_input ( ) . split ( <STRING> ) <NEWLINE> if inp == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for i in range ( 1 , int ( inp [ 0 ] ) + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , int ( inp [ 0 ] ) + 1 ) : <NEWLINE> <INDENT> if i != j : <NEWLINE> <INDENT> sum = i + j <NEWLINE> if sum == int ( inp [ 1 ] ) : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print count <NEWLINE> <DEDENT>
<COMMENT> <NL> a = int ( 0 ) <NEWLINE> m = int ( 0 ) <NEWLINE> while True : <NEWLINE> <INDENT> n , x = map ( int , input ( ) . split ( ) ) <NEWLINE> if n == 0 and x == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> j = i + 1 <NEWLINE> for j in range ( n ) : <NEWLINE> <INDENT> h = i + 2 <NEWLINE> for h in range ( n ) : <NEWLINE> <INDENT> if i + k + h == x : <NEWLINE> <INDENT> k = k + 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( k ) <NEWLINE> <NL> <NL> <DEDENT>
( n , m ) = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> for i in range ( 1 , n - 1 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n ) : <NEWLINE> <INDENT> for k in range ( j + 1 , n + 1 ) : <NEWLINE> <INDENT> if i + j + k == x : ans += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ans <NEWLINE>
while True : <NEWLINE> <INDENT> ( n , x ) = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> if n == x == 0 <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT>
while True : <NEWLINE> <INDENT> ( n , x ) = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> if n == x == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> dataset = [ ] <NEWLINE> for a in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> for b in range ( a + 1 , n + 1 ) : <NEWLINE> <INDENT> for c in range ( b + 1 , n + 1 ) : <NEWLINE> <INDENT> if sum ( [ a , b , c ] ) == x : <NEWLINE> <INDENT> count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE> <DEDENT>
Answer = [ ] <NEWLINE> flg = 1 <NEWLINE> <NL> def Taxed ( p , q ) : <NEWLINE> <INDENT> T = int ( p * ( 1 + q / 100 ) ) <NEWLINE> return T <NEWLINE> <NL> <DEDENT> while flg > 0 : <NEWLINE> <INDENT> inp = input ( ) . split ( ) <NEWLINE> x = int ( inp [ 0 ] ) <NEWLINE> y = int ( inp [ 1 ] ) <NEWLINE> s = int ( inp [ 2 ] ) <NEWLINE> <NL> flg = x ** 2 + y ** 2 + s ** 2 <NEWLINE> if flg == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> M = 0 <NEWLINE> for i in range ( 1 , s - 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , s - 1 ) : <NEWLINE> <INDENT> a = Taxed ( i , x ) <NEWLINE> b = Taxed ( j , x ) <NEWLINE> if ( a + b ) == s : <NEWLINE> <INDENT> M_temp = Taxed ( i , y ) + Taxed ( j , y ) <NEWLINE> M = max ( M , M_temp ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> Answer . append ( M ) <NEWLINE> <NL> <DEDENT> for k in range ( 0 , len ( Answer ) ) : <NEWLINE> <INDENT> print ( Answer [ k ] ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> n , x = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> if n == x == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> count = 0 <NEWLINE> for s in range ( 1 , n - 1 ) : <NEWLINE> <INDENT> for m in range ( s + 1 , n ) : <NEWLINE> <INDENT> for e in range ( m + 1 , n + 1 ) : <NEWLINE> <INDENT> if x == sum ( s , m , e ) : <NEWLINE> <INDENT> count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> n , x = map ( int , input ( ) . split ( ) ) <NEWLINE> if n == 0 and x == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : 0 <NEWLINE> <INDENT> if n + 1 + n + n - 1 <= x : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n + 1 ) : <NEWLINE> <INDENT> for k in range ( j + 1 , n + 1 ) : <NEWLINE> <INDENT> if i + j + k == x : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
while True : <NEWLINE> <INDENT> n , x = map ( int , input ( ) . split ( ) ) <NEWLINE> if n == 0 and x == 0 : break <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , i ) : <NEWLINE> <INDENT> for k in range ( 1 , j ) : <NEWLINE> <INDENT> if i + j + k == x : a += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( a ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> def numinput ( ) : <NEWLINE> <INDENT> a = input ( ) . split ( ) <NEWLINE> for i in range ( len ( a ) ) : <NEWLINE> <INDENT> a [ i ] = int ( a [ i ] ) <NEWLINE> <DEDENT> return a <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> while True : <NEWLINE> <INDENT> a = numinput ( ) <NEWLINE> n = a [ 0 ] ; x = a [ 1 ] <NEWLINE> if n == 0 and x == 0 : break <NEWLINE> <COMMENT> <NL> count = 0 <NEWLINE> for i in range ( 1 , ( x // 3 ) + 1 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , ( x // 3 ) + 1 ) : <NEWLINE> <INDENT> if j < x - i - j : count + + <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
<NL> n = input ( ) <NEWLINE> <NL> count = 0 <NEWLINE> x = input ( ) <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> for j in range ( n ) : <NEWLINE> <INDENT> for k in range ( n + 1 ) : <NEWLINE> <INDENT> if i + j + k == x : count += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
while 1 : <NEWLINE> <INDENT> n , x = map ( int , input ( ) . split ( ) ) <NEWLINE> if n + x == 0 : break <NEWLINE> for i in range ( 3 , n + 1 ) : <NEWLINE> <INDENT> for j in range ( 2 , x - i ) : <NEWLINE> <INDENT> if x - i - j < j < i : <NEWLINE> <INDENT> c += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( c ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> p = 0 <NEWLINE> n , x = map ( int , input ( ) . split ( ) ) <NEWLINE> if n == 0 and x == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for i + 1 in range ( n ) : <NEWLINE> <INDENT> for j + 2 in range ( n ) : <NEWLINE> <INDENT> if i == j : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for k + 3 in range ( n ) : <NEWLINE> <INDENT> if i == k or j == k : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> g = i + j + k <NEWLINE> if x == p : <NEWLINE> <INDENT> p += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT>
while 1 : <NEWLINE> <INDENT> n , x = map ( int , input ( ) . split ( ) ) <NEWLINE> count == 0 <NEWLINE> if n == 0 and x == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n + 1 ) : <NEWLINE> <INDENT> for k in range ( j + 1 , n + 1 ) : <NEWLINE> <INDENT> if i + j + k == x : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE> <DEDENT>
<NL> <NL> BIG_NUM = 2000000000 <NEWLINE> MOD = 1000000007 <NEWLINE> EPS = 0.000000001 <NEWLINE> <NL> <NL> <NL> while True : <NEWLINE> <INDENT> N , X = map ( int , input ( ) . split ( ) ) <NEWLINE> if N == 0 and X == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> ans = 0 <NEWLINE> for a in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> for b in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> if b <= a : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> c = X - ( a + b ) <NEWLINE> if c > b and c <= N : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> % ( ans ) ) <NEWLINE> <NL> <DEDENT> Compile Error Logs : <NEWLINE> <NL> Status <NEWLINE> Judge : 4 / 4 Python3 CPU : 00 : 0 7 sec Memory : 5608 KB Length : 369 B 2019 - 0 5 - 27 14 : 40 <NEWLINE> Results for testcases <NEWLINE> Case <COMMENT> <NEWLINE> Case <COMMENT> <NEWLINE> Case <COMMENT> <NEWLINE> Case <COMMENT> <NEWLINE> Case <COMMENT> <NEWLINE> < prev | / | next > <NEWLINE> <NL> Judge Input <COMMENT> <NEWLINE> <NL> <NL> <NL> <NL>
def transnum ( int : n ) : <NEWLINE> <INDENT> if n % 3 != 0 : <NEWLINE> <INDENT> return n + 3 - n % 3 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return n <NEWLINE> <NL> <DEDENT> <DEDENT> while True : <NEWLINE> <INDENT> x , n = tuple ( int ( i ) for i in input ( ) . split ( ) ) <NEWLINE> r = 0 <NEWLINE> if x == n == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> amin = n // 3 + 1 <NEWLINE> amax = 2 * transnum ( n ) // 3 <NEWLINE> if amax > x : <NEWLINE> <INDENT> amax = x <NEWLINE> <NL> <DEDENT> A = [ j for j in range ( amin , amax + 1 ) ] <NEWLINE> <NL> <COMMENT> <NL> <NL> for a in A : <NEWLINE> <INDENT> bmin = ( n - a ) // 3 + 1 <NEWLINE> bmax = 2 * transnum ( n - a ) // 3 <NEWLINE> if bmax > a : <NEWLINE> <INDENT> bmax = a <NEWLINE> <NL> <DEDENT> B = [ j for j in range ( bmin , bmax ) if j + j != n - a ] <NEWLINE> <COMMENT> <NL> for b in B : <NEWLINE> <INDENT> cmin = ( n - a - b ) // 3 + 1 <NEWLINE> cmax = 2 * transnum ( n - a - b ) // 3 <NEWLINE> if cmax > b : <NEWLINE> <INDENT> cmax = b <NEWLINE> <DEDENT> C = [ k for k in range ( cmin , cmax ) if k == n - a - b ] <NEWLINE> <COMMENT> <NL> r += len ( C ) <NEWLINE> C . clear ( ) <NEWLINE> <DEDENT> B . clear ( ) <NEWLINE> <NL> <DEDENT> print ( r ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> n , x = map ( int ( input ( ) . split ( ) ) ) <NEWLINE> if n == x == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> Sum = 0 <NEWLINE> count = 0 <NEWLINE> for a in range ( 1 , n ) : <NEWLINE> <INDENT> for b in range ( 1 , n ) : <NEWLINE> <INDENT> for c in range ( 1 , n ) : <NEWLINE> <INDENT> Sum = a + b + c <NEWLINE> if Sum == x : <NEWLINE> <INDENT> count = count + 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE> <DEDENT>
while 1 : <NEWLINE> <INDENT> n , x = map ( int , input ( ) . split ( ) ) <NEWLINE> counter = 0 <NEWLINE> if n == 0 and x == 0 : <NEWLINE> <INDENT> break <NEWLINE> <COMMENT> <NL> <DEDENT> y = ( x + 3 ) // 3 <NEWLINE> for a in range ( y , n + 1 ) : <NEWLINE> <INDENT> for b in range ( 2 , a ) : <NEWLINE> if ( x - a - b ) > 0 and ( x - a - b ) < b : <NEWLINE> <INDENT> counter += 1 <NEWLINE> <DEDENT> <DEDENT> print ( counter ) <NEWLINE> <DEDENT>
while 1 : <NEWLINE> <INDENT> n , x = map ( int , input ( ) . split ( ) ) <NEWLINE> if n == 0 and x == 0 : break <NEWLINE> print ( len ( [ 1 for a in range ( 1 , n + 1 ) , for b in range ( a + 1 , n + 1 ) , for c in range ( b + 1 , n + 1 ) , a + b + c == x ] ) ) <NEWLINE> <DEDENT>
def solve ( sup , rest , digit , used1 , used2 ) : <NEWLINE> <INDENT> if digit == 0 : <NEWLINE> <INDENT> if rest == 0 : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> <DEDENT> sum = 0 <NEWLINE> for i in range ( 1 , sup + 1 ) : <NEWLINE> <INDENT> if i != used1 and i != used2 : <NEWLINE> <INDENT> if used1 == 0 : <NEWLINE> <INDENT> sum += solve ( sup , rest - i , digit - 1 , i , used2 ) <NEWLINE> <DEDENT> elif used2 == 0 : <NEWLINE> <INDENT> sum += solve ( sup , rest - i , digit - 1 , used1 , i ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> sum += solve ( sup , rest - i , digit - 1 , used1 , used2 ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return sum <NEWLINE> <NL> <DEDENT> N = [ ] <NEWLINE> X = [ ] <NEWLINE> while True : <NEWLINE> <INDENT> n , x = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if ( n , x ) == ( 0 , 0 ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> N . append ( n ) <NEWLINE> X . append ( x ) <NEWLINE> <DEDENT> for i in range ( len ( N ) ) : <NEWLINE> <INDENT> print ( <STRING> % ( solve ( N [ i ] , X [ i ] , 3 , 0 , 0 ) / 6 ) ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> n , x = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> if n == x == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> count = 0 <NEWLINE> for s in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> for m in range ( s + 1 , n ) : <NEWLINE> <INDENT> for e in range ( m + 1 , n + 1 ) : <NEWLINE> <INDENT> if x == sum ( s , m , e ) : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE> <DEDENT>
while ( True ) : <NEWLINE> <INDENT> n , x = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> if ( n == 0 and x == 0 ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> t = 0 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> for k range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if ( i < j < k and i + j + k == x ) : <NEWLINE> <INDENT> t += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( t ) <NEWLINE> <DEDENT>
from itertools import combinations as comb <NEWLINE> def get_ans ( m , n ) : <NEWLINE> <INDENT> ans = sum ( 1 for nums in comb ( range ( 1 , min ( m + 1 , n - 2 ) ) , 2 ) if ( n - sum ( nums ) > 0 and n - sum ( nums ) not in nums ) ) ) <NEWLINE> return ans <NEWLINE> <NL> <DEDENT> while True : <NEWLINE> <INDENT> m , n = ( int ( x ) for x in input ( ) . split ( ) ) <NEWLINE> if m == 0 and n == 0 : <NEWLINE> <INDENT> quit ( ) <NEWLINE> <DEDENT> ans = get_ans ( m , n ) <NEWLINE> print ( ans ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> while True : <NEWLINE> <INDENT> n , x = [ int ( val ) for val in sys . stdin . readline ( ) . split ( <STRING> ) ] <NEWLINE> if 0 == n and 0 == x : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> cnt = 0 <NEWLINE> ave = x / 3 <NEWLINE> for i in range ( 1 , ave ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n ) : <NEWLINE> <INDENT> if x <= ( i + j ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for k in range ( j + 1 , n + 1 ) : <NEWLINE> <INDENT> s = ( i + j + k ) <NEWLINE> if x == s : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> break <NEWLINE> <DEDENT> elif x < s : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> ( n , x ) = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> for a in range ( 1 , n + 1 - 2 ) : <NEWLINE> <INDENT> for b in range ( a + 1 , n + 1 - 1 ) : <NEWLINE> <INDENT> for c in range ( b + 1 , n + 1 ) : <NEWLINE> <INDENT> if ( a + b + c ) == x : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE> <DEDENT>
def search ( nmax , n , x ) : <NEWLINE> <INDENT> if n > nmax : return 0 <NEWLINE> if x < 0 : return 0 <NEWLINE> if x == 0 : return 1 <NEWLINE> return search ( nmax , n + 1 , x ) + search ( nmax , n + 1 , x - n ) <NEWLINE> <NL> <DEDENT> while 1 : <NEWLINE> <INDENT> n , x = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if n == 0 and x == 0 : break <NEWLINE> <NL> num = search ( n , 0 , x ) <NEWLINE> print ( num ) <NEWLINE> <DEDENT>
while ( True ) : <NEWLINE> <INDENT> n , x = map ( int , input ( ) . spilt ( ) ) <NEWLINE> if n == 0 and x == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> for k in range ( i + 1 , n + 1 ) : <NEWLINE> <INDENT> for l in range ( k + 1 , n + 1 ) : <NEWLINE> <INDENT> if i + k + l == x : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE> <DEDENT> <DEDENT>
iranai = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> iru = [ [ int ( i ) for i in input ( ) . split ( ) ] for i in range ( iranai [ 0 ] ) ] <NEWLINE> mikitani = [ ] <NEWLINE> son = [ ] <NEWLINE> num = 0 <NEWLINE> mikicount = 0 <NEWLINE> <NL> for i in range ( iranai [ 0 ] ) : <NEWLINE> <INDENT> for i2 in range ( iranai [ 1 ] ) : <NEWLINE> <INDENT> num += iru [ i ] [ i2 ] <NEWLINE> <DEDENT> mikitani . append ( num ) <NEWLINE> num = 0 <NEWLINE> <NL> <DEDENT> for i in range ( iranai [ 1 ] ) : <NEWLINE> <INDENT> for i2 in range ( iranai [ 0 ] ) : <NEWLINE> <INDENT> num += iru [ i2 ] [ i ] <NEWLINE> <DEDENT> son . append ( num ) <NEWLINE> num = 0 <NEWLINE> <NL> <DEDENT> for i in range ( iranai [ 0 ] ) : <NEWLINE> <INDENT> for i2 in range ( iranai [ 1 ] ) : <NEWLINE> <INDENT> print ( iru [ i ] [ i2 ] , end = <STRING> ) <NEWLINE> if i2 = iranai [ 2 ] - 1 : <NEWLINE> <INDENT> print ( mikitani [ i ] ) <NEWLINE> <DEDENT> <DEDENT> mikicount += mikitani [ i ] <NEWLINE> <DEDENT> son . append ( mikicount ) <NEWLINE> <NL> for i in range ( len ( son ) ) : <NEWLINE> <INDENT> if i == len ( son ) - 1 : <NEWLINE> <INDENT> print ( son [ i ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( son [ i ] , end = <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
r , c = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> a = [ [ 0 for i in range ( c + 1 ) ] for j in range ( r + 1 ) ] <NEWLINE> <NL> for i in range ( r ) : <NEWLINE> <INDENT> a_tmp = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for j in range ( c ) : <NEWLINE> <INDENT> a [ i ] [ j ] = a_tmp [ j ] <NEWLINE> a [ i ] [ c + 1 ] += a_tmp [ j ] <NEWLINE> a [ r + 1 ] [ j ] += a_tmp [ j ] <NEWLINE> a [ r + 1 ] [ c + 1 ] += a_tmp [ j ] <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( r + 1 ) : <NEWLINE> <INDENT> print ( <STRING> . join ( str ( x ) for x in a [ i ] ) ) <NEWLINE> <DEDENT>
r , c = map ( int , input ( ) . split ( ) ) <NEWLINE> for i in range ( c ) : <NEWLINE> <INDENT> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a . append ( sum ( a ) ) <NEWLINE> print ( * a ) <NEWLINE> <DEDENT>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> sum = 0 <NEWLINE> for n in range ( N ) : <NEWLINE> <INDENT> arr = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> arr . append ( sum ( arr ) ) <NEWLINE> print ( <STRING> . join ( arr ) ) <NEWLINE> <DEDENT>
r , c = map ( int , input ( ) . split ( ) ) <NEWLINE> a , b = [ ] , [ 0 ] * c <NEWLINE> for i in range ( r ) : <NEWLINE> <INDENT> x = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b += x <NEWLINE> print ( * x , end = <STRING> ) <NEWLINE> print ( sum ( x ) ) <NEWLINE> <DEDENT> print ( * b , end = <STRING> ) <NEWLINE> <INDENT> print ( sum ( b ) ) <NEWLINE> <DEDENT>
<COMMENT> <NL> using namespace std ; <NEWLINE> int main ( ) { <NEWLINE> <INDENT> int r , c , t ; <NEWLINE> t = 0 ; <NEWLINE> cin >> r >> c ; <NEWLINE> int R [ c + 1 ] = { } ; <NEWLINE> int S [ c + 1 ] = { } ; <NEWLINE> for ( int i = 0 ; i < r ; i + + ) { <NEWLINE> <INDENT> for ( int x = 0 ; x < c ; x + + ) { <NEWLINE> <INDENT> cin >> R [ x ] ; <NEWLINE> cout << R [ x ] << <STRING> ; <NEWLINE> <DEDENT> } <NEWLINE> for ( int x = 0 ; x < c ; x + + ) { <NEWLINE> <INDENT> t += R [ x ] ; <NEWLINE> <DEDENT> } <NEWLINE> <DEDENT> cout << t << endl ; <NEWLINE> for ( int b = 0 ; b < c ; b + + ) { <NEWLINE> <INDENT> S [ b ] += R [ b ] ; <NEWLINE> <DEDENT> } <NEWLINE> R [ c + 1 ] = { } ; <NEWLINE> t = 0 ; <NEWLINE> } <NEWLINE> for ( int x = 0 ; x < c ; x + + ) { <NEWLINE> <INDENT> cout << S [ x ] << <STRING> ; <NEWLINE> S [ c ] += S [ x ] ; <NEWLINE> <DEDENT> } <NEWLINE> cout << S [ c ] << endl ; <NEWLINE> <DEDENT> } <NEWLINE>
<COMMENT> <NL> <NL> import numpy as np <NEWLINE> import matplotlib . pyplot as plt <NEWLINE> import sys <NEWLINE> <NL> printf = sys . stdout . write <NEWLINE> <NL> <NL> mat = [ ] <NEWLINE> new_map = [ ] <NEWLINE> <NL> r , c = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> for i in range ( r ) : <NEWLINE> <INDENT> mat = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> new_map . append ( mat ) <NEWLINE> <NL> <NL> <DEDENT> for i in range ( r ) : <NEWLINE> <INDENT> new_map [ i ] . append ( sum ( new_map [ i ] [ : ] ) ) <NEWLINE> for j in range ( c ) : <NEWLINE> <INDENT> print new_map [ i ] [ j ] , <NEWLINE> <DEDENT> printf ( <STRING> + str ( new_map [ i ] [ j + 1 ] ) + <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> for j in range ( c + 1 ) : <NEWLINE> <INDENT> a = 0 <NEWLINE> for i in range ( r ) : <NEWLINE> <INDENT> a += new_map [ i ] [ j ] <NEWLINE> <DEDENT> if j == c : <NEWLINE> <INDENT> printf ( <STRING> + str ( a ) + <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print a , <NEWLINE> <DEDENT> <DEDENT>
r , c = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> data = [ ] <NEWLINE> sum_row = [ 0 ] * ( c + 1 ) <NEWLINE> for ri in range ( r ) : <NEWLINE> <INDENT> data . append ( [ int ( i ) for i in input ( ) . split ( ) ] ) <NEWLINE> data [ ri ] . append ( sum ( data [ ri ] ) ) <NEWLINE> print ( <STRING> . join ( str [ d ] for d in data [ ri ] ) ) <NEWLINE> for ci in range ( c + 1 ) : <NEWLINE> <INDENT> sum_row [ ci ] += data [ ri ] [ ci ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> . join ( [ str ( s ) for s in sum_row ] ) ) <NEWLINE>
r , c = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> data = [ ] <NEWLINE> sum_row = [ 0 ] * ( c + 1 ) <NEWLINE> <NL> for ri in range ( r ) : <NEWLINE> <INDENT> data . append ( [ int ( i ) for i in input ( ) . split ( ) ] ) <NEWLINE> data [ ri ] . append ( sum ( data [ ri ] ) ) <NEWLINE> print ( <STRING> . join ( data [ ri ] ) ) <NEWLINE> for ci in range ( c + 1 ) : <NEWLINE> <INDENT> sum_row [ ci ] += data [ ri ] [ ci ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> . join ( [ str ( s ) for s in sum_row ] ) ) <NEWLINE>
r , c = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> data = [ ] <NEWLINE> sum_row = [ 0 ] * ( c + 1 ) <NEWLINE> <NL> for ri in range ( r ) : <NEWLINE> <INDENT> data [ ri ] . append ( [ int ( i ) for i in input ( ) . split ( ) ] ) <NEWLINE> data [ ri ] . append ( sum ( data [ ri ] ) ) <NEWLINE> print ( <STRING> . join ( [ str ( d ) for d in data [ ri ] ] ) ) <NEWLINE> for ci in range ( c + 1 ) : <NEWLINE> <INDENT> sum_row [ ci ] += data [ ri ] [ ci ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> . join ) <NEWLINE> <NL> from pprint import pprint <NEWLINE> pprint ( data ) <NEWLINE> pprint ( sum_row ) <NEWLINE>
r , c = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> <NL> data = [ 0 for i in range ( r ) ] <NEWLINE> temp = [ 0 for i in range ( c ) ] <NEWLINE> <NL> out = <STRING> <NEWLINE> <NL> for i in range ( r ) : <NEWLINE> <INDENT> data [ i ] = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> <NL> <DEDENT> for i in range ( r ) : <NEWLINE> <INDENT> data [ i ] . append ( 0 ) <NEWLINE> data [ i ] [ c ] = sum ( data [ i ] ) <NEWLINE> <DEDENT> for i in range ( c ) : <NEWLINE> <INDENT> for j in range ( r ) : <NEWLINE> <INDENT> temp [ i ] += data [ j ] [ i ] <NEWLINE> <DEDENT> <DEDENT> temp . append ( sum ( temp ) ) <NEWLINE> data . append ( temp ) <NEWLINE> <NL> for i in range ( r + 1 ) : <NEWLINE> <INDENT> for j in range ( c + 1 ) : <NEWLINE> <INDENT> out += str ( data [ i ] [ j ] ) + <STRING> <NEWLINE> <DEDENT> out += <STRING> <NEWLINE> <DEDENT> print out <NEWLINE>
r , c = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> sum_c = [ 0 for x in range ( r ) ] <NEWLINE> sum_r = [ 0 for x in range ( c ) ] <NEWLINE> sum = 0 <NEWLINE> <NL> for i in range ( r ) : <NEWLINE> <INDENT> column = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> for j in range ( c ) : <NEWLINE> <INDENT> sum_c [ i ] += column [ j ] <NEWLINE> sum_r [ j ] += column [ j ] <NEWLINE> sum += column [ j ] <NEWLINE> <DEDENT> <DEDENT> X <NEWLINE>
table = [ ] <NEWLINE> r , c = map ( int , input ( ) . strip ( ) . split ( ) ) <NEWLINE> [ table . append ( input ( ) . strip ( ) . split ( ) ) for i in range ( r ) ] <NEWLINE> <NL> print ( table ) <NEWLINE> for j in range ( r + 1 ) : <NEWLINE> <INDENT> for k in range ( c + 1 ) : <NEWLINE> <INDENT> if j == r and k != c : <NEWLINE> <INDENT> lastrow = sum ( map ( int , [ table [ x ] [ k ] for x in range ( r ) ] ) ) <NEWLINE> table [ - 1 ] . append ( lastrow ) <NEWLINE> <DEDENT> if k == c : <NEWLINE> <INDENT> print ( sum ( map ( int , table [ j ] ) ) ) <NEWLINE> break <NEWLINE> <DEDENT> print ( table [ j ] [ k ] , end = <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
r , c = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> data = [ ] <NEWLINE> sum_row = [ 0 ] * ( c + 1 ) <NEWLINE> <NL> for ri in range ( r ) : <NEWLINE> <INDENT> data [ ri ] . append ( [ int ( i ) for i in input ( ) . split ( ) ] ) <NEWLINE> data [ ri ] . append ( sum ( data [ ri ] ) ) <NEWLINE> print ( <STRING> . join ( [ str ( d ) for d in data [ ri ] ] ) ) <NEWLINE> for ci in range ( c + 1 ) : <NEWLINE> <INDENT> sum_row [ ci ] += data [ ri ] [ ci ] <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> from pprint import pprint <NEWLINE> pprint ( data ) <NEWLINE> pprint ( sum_row ) <NEWLINE>
<COMMENT> <NL> <NL> r , c = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> mat = { } <NEWLINE> for i in range ( 1 , r + 1 ) : <NEWLINE> <INDENT> col = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> for j in range ( 1 , c + 1 ) : <NEWLINE> <INDENT> mat [ ( i , j ) ] = col [ j - 1 ] <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( 1 , r + 1 ) : <NEWLINE> <INDENT> mat [ ( i , c + 1 ) ] = 0 <NEWLINE> for j in range ( 1 , c + 1 ) : <NEWLINE> <INDENT> mat [ ( i , c + 1 ) ] += mat [ ( i , j ) ] <NEWLINE> <NL> <DEDENT> <DEDENT> for j in range ( 1 , c + 2 ) : <NEWLINE> <INDENT> mat [ ( r + 1 , j ) ] = 0 <NEWLINE> for i in range ( 1 , r + 1 ) : <NEWLINE> <INDENT> mat [ ( r + 1 , j ) ] += mat [ ( i , j ) ] <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( 1 , r + 2 ) : <NEWLINE> <INDENT> buf = <STRING> <NEWLINE> for j in range ( 1 , c + 2 ) : <NEWLINE> <INDENT> buf += str ( mat [ ( i , j ) ] ) + <STRING> <NEWLINE> <DEDENT> print buf <NEWLINE> <DEDENT>
r , c = [ int ( i ) for i in input ( ) . split ( <STRING> ) ] <NEWLINE> s_row = [ 0 for x in range ( c + 1 ) ] <NEWLINE> <NL> for i in range ( r ) : <NEWLINE> <INDENT> row = [ int ( n ) for n in input ( ) . split ( <STRING> ) ] <NEWLINE> row = row . append ( sum ( row ) ) <NEWLINE> print ( <STRING> . join ( [ str ( s ) for s in row ] ) ) <NEWLINE> s_row = [ x + y for x , y in zip ( s_row , row ) ] <NEWLINE> <DEDENT> print ( <STRING> . join ( [ str ( s1 ) for s1 in s_row ] ) ) <NEWLINE>
import sys <NEWLINE> <NL> p = 0 <NEWLINE> x1 = [ ] <NEWLINE> for line in open ( <STRING> , <STRING> ) : <COMMENT> <NEWLINE> <INDENT> x = [ int ( i ) for i in line . split ( ) ] <NEWLINE> if p == 0 : <NEWLINE> <INDENT> r , c = x <NEWLINE> p = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x1 . append ( x ) <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( r ) : <NEWLINE> <INDENT> x1 [ i ] . append ( sum ( x1 [ i ] ) ) <NEWLINE> <DEDENT> x = [ ] <NEWLINE> for j in range ( c + 1 ) : <NEWLINE> <INDENT> s = 0 <NEWLINE> for i in range ( r ) : <NEWLINE> <INDENT> s += x1 [ i ] [ j ] <NEWLINE> <DEDENT> x . append ( s ) <NEWLINE> <DEDENT> x1 . append ( x ) <NEWLINE> <NL> for i in range ( r + 1 ) : <NEWLINE> <INDENT> for j in range ( c + 1 ) : <NEWLINE> <INDENT> print x1 [ i ] [ j ] , <NEWLINE> <DEDENT> print <NEWLINE> <DEDENT>
r , c = map ( int , input ( ) . split ( ) ) <NEWLINE> matrix = [ [ 0 for i in range ( c + 1 ) ] for j in range ( r + 1 ) ] <NEWLINE> for i in range ( r ) : <NEWLINE> <INDENT> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for j in range ( c ) : <NEWLINE> <INDENT> matrix [ i ] [ j ] = a [ j ] <NEWLINE> <DEDENT> matrix [ i ] [ c ] = sum ( a ) <NEWLINE> <DEDENT> for l in range ( c + 1 ) : <NEWLINE> <INDENT> for m in range ( r ) : <NEWLINE> <INDENT> matrix [ r ] [ l ] += matrix [ m ] [ l ] <NEWLINE> <NL> <DEDENT> <DEDENT> for cv in range ( r + 1 ) : <NEWLINE> <INDENT> for fv in range ( c + 1 ) : <NEWLINE> <INDENT> print ( matrix [ cv ] [ fv ] , end = <STRING> ) <NEWLINE> if fv != c : <NEWLINE> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> <DEDENT>
i , j = map ( int , input ( ) . split ( ) ) <NEWLINE> listA = [ ] <NEWLINE> for i in range ( i ) : <NEWLINE> <INDENT> listA . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> listA [ n ] . append ( sum ( listA [ n ] ) ) <NEWLINE> <DEDENT> listA . append ( [ ] ) <NEWLINE> for n in range ( j + 1 ) : <NEWLINE> <INDENT> number = 0 <NEWLINE> for m in range ( i ) : <NEWLINE> <INDENT> number += listA [ m ] [ n ] <NEWLINE> <DEDENT> listA [ i ] . append ( number ) <NEWLINE> <DEDENT> for n in range ( i + 1 ) : <NEWLINE> <INDENT> print ( <STRING> . join ( map ( str , listA [ n ] ) ) ) <NEWLINE> <NL> <DEDENT>
r , c = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> A = [ ] <NEWLINE> for i in range ( r ) : <NEWLINE> <INDENT> A . append ( map ( int , raw_input ( ) . split ( ) ) ) <NEWLINE> A [ i ] . append ( sum ( A [ i ] ) ) <NEWLINE> <DEDENT> A . append ( [ sum ( [ A [ i ] [ j ] for i in range ( r ) ] ) for j in range ( c ) ] ) <NEWLINE> print ( A ) <NEWLINE> for i in range ( r ) : <NEWLINE> <INDENT> print ( <STRING> . join ( A [ i ] ) ) <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ ] <NEWLINE> b = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a = [ list ( map ( int , input ( ) . split ( ) ) ) ] <NEWLINE> a [ i ] += [ sum ( a [ i ] ) ] <NEWLINE> <DEDENT> for i in range ( m ) : <NEWLINE> <INDENT> b += [ a [ : ] [ i ] ] <NEWLINE> a += [ b ] <NEWLINE> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> print ( * a [ i ] ) <NEWLINE> <DEDENT>
r , c = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> m = [ ] <NEWLINE> ans = [ ] <NEWLINE> <NL> for i in range ( r ) : <NEWLINE> <INDENT> a = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> m . append ( a ) <NEWLINE> sum = 0 <NEWLINE> for j in range ( c ) <NEWLINE> <INDENT> print ( a [ j ] ) , <NEWLINE> sum += a [ j ] <NEWLINE> <DEDENT> print ( sum ) <NEWLINE> <DEDENT> total = 0 <NEWLINE> for i in range ( c ) : <NEWLINE> <INDENT> sum = 0 <NEWLINE> for j in range ( r ) : <NEWLINE> <INDENT> sum += m [ j ] [ i ] <NEWLINE> <DEDENT> print ( sum ) , <NEWLINE> total += sum <NEWLINE> <DEDENT> print ( total ) <NEWLINE>
<COMMENT> <NL> <NL> r , c = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = [ ] <NEWLINE> line_sum = 0 <NEWLINE> <NL> for i in range ( r ) : <NEWLINE> <INDENT> a . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> <DEDENT> for i in range ( r ) : <NEWLINE> <INDENT> for j in range ( c + 1 ) : <NEWLINE> <INDENT> if j == c : <NEWLINE> <INDENT> print ( <STRING> . format ( sum ( a [ i ] ) ) ) <NEWLINE> line_sum += sum ( a [ i ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> . format ( a [ i ] [ j ] ) , end = <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for i in range ( c + 1 ) : <NEWLINE> <INDENT> column_sum = 0 <NEWLINE> for j in range ( r ) : <NEWLINE> <INDENT> column_sum += a [ j ] [ i ] <NEWLINE> <NL> <DEDENT> print ( <STRING> . format ( column_sum ) , end = <STRING> ) <NEWLINE> <NL> <DEDENT> print ( line_sum ) <NEWLINE>
<COMMENT> <NL> import sys <NEWLINE> <NL> r , c = map ( int , input ( ) . split ( ) ) <NEWLINE> list = [ [ 0 for i in range ( r + 1 ) ] for j in range ( c + 1 ) ] <NEWLINE> <NL> a = [ input ( ) . split ( ) for k in range ( c ) ] <NEWLINE> <NL> for l in range ( r ) : <NEWLINE> <INDENT> for m in range ( c ) : <NEWLINE> <INDENT> list [ l ] [ c ] += int ( a [ l ] [ m ] ) <NEWLINE> list [ r ] [ m ] += int ( a [ l ] [ m ] ) <NEWLINE> list [ l ] [ m ] = int ( a [ l ] [ m ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> for n in range ( r ) : <NEWLINE> <INDENT> list [ r ] [ c ] += list [ n ] [ c ] <NEWLINE> <NL> <DEDENT> for o in range ( r + 1 ) : <NEWLINE> <INDENT> for p in range ( c + 1 ) : <NEWLINE> <INDENT> print ( list [ o ] [ p ] , <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
r , c = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> matrix = [ ] <NEWLINE> for i in range ( r ) : <NEWLINE> <INDENT> matrix . append ( map ( int , raw_input ( ) . split ( ) ) ) <NEWLINE> <NL> <DEDENT> a = [ 0 for j in range ( c ) ] <NEWLINE> <NL> matrix . append ( a ) <NEWLINE> <NL> for i in range ( r ) : <NEWLINE> <INDENT> sum = 0 <NEWLINE> for j in range ( c ) : <NEWLINE> <INDENT> sum += matrix [ i ] [ j ] <NEWLINE> <DEDENT> matrix [ i ] . append ( sum ) <NEWLINE> <NL> <DEDENT> for j in range ( c ) : <NEWLINE> <INDENT> sum = 0 <NEWLINE> for i in range ( r ) : <NEWLINE> <INDENT> sum += matrix [ i ] [ j ] <NEWLINE> <DEDENT> matrix [ r ] [ j ] = sum <NEWLINE> <NL> <DEDENT> sum = 0 <NEWLINE> for j in range ( c ) : <NEWLINE> <INDENT> sum += matrix [ r ] [ j ] <NEWLINE> <DEDENT> matrix [ r ] . append ( sum ) <NEWLINE> <NL> for i in range ( r ) : <NEWLINE> <INDENT> for j in range ( c + 1 ) : <NEWLINE> <INDENT> print matrix [ i ] [ j ] , <NEWLINE> <DEDENT> print <STRING> <NEWLINE> <NL> <DEDENT> for j in range ( c ) : <NEWLINE> <INDENT> print matrix [ r ] [ j ] , <NEWLINE> <NL> <DEDENT> print matrix [ r ] [ c ] <NEWLINE>
r , c = [ int ( i ) for i in input ( ) . split ] <NEWLINE> <NL> data = [ ] <NEWLINE> sum_row = [ 0 ] * ( c + 1 ) <NEWLINE> <NL> for ri in range ( r ) : <NEWLINE> <INDENT> data . append ( [ int ( i ) for i in input ( ) . split ( ) ] ) <NEWLINE> data [ ri ] . append ( sum ( data [ ri ] ) ) <NEWLINE> print ( <STRING> . join ( [ str ( d ) for d in data [ ri ] ] ) ) <NEWLINE> for ci in range ( c * 1 ) : <NEWLINE> <INDENT> sum_row [ ci ] += data [ ri ] [ ci ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> . join ( [ str ( s ) for s in sum_row ] ) ) <NEWLINE> <NL> from pprint import pprint <NEWLINE> pprint ( data ) <NEWLINE> pprint ( sum_row ) <NEWLINE>
r , c = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> data = [ ] <NEWLINE> sum_row = [ 0 ] * ( c + 1 ) <NEWLINE> <NL> for ri in range ( r ) : <NEWLINE> <INDENT> data . append ( [ int ( i ) for i in input . split ( ) ] ) <NEWLINE> data [ ri ] . append ( sum ( data [ ri ] ) ) <NEWLINE> print ( <STRING> , join ( data [ str ( d ) for d in data [ ri ] ] ) ) <NEWLINE> for ci in renge ( c + 1 ) : <NEWLINE> <INDENT> sum_row [ ci ] += data [ ri ] [ ci ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> . join ( [ str ( s ) for s in sum_row ] ) ) <NEWLINE>
li = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> mtx = [ [ ] for _ in range ( li [ 0 ] ) ] <NEWLINE> li_sum = [ 0 for _ in range ( li [ 1 ] + 1 ) ] <NEWLINE> <NL> for i in range ( li [ 0 ] ) : <NEWLINE> <INDENT> a = input ( ) <NEWLINE> mtx [ i ] = list ( map ( int , a . split ( ) ) ) <NEWLINE> print ( a , end = <STRING> ) <NEWLINE> print ( <STRING> , sum ( mtx [ i ] ) , sep = <STRING> ) <NEWLINE> <NL> for j in range ( li [ j ] ) : <NEWLINE> <INDENT> li_sum [ j ] += mtx [ i ] [ j ] <NEWLINE> <DEDENT> li_sum [ j ] += sum ( mtx [ i ] ) <NEWLINE> <NL> <DEDENT> print ( <STRING> . join ( map ( str , li_sum ) ) ) <NEWLINE>
( r , c ) = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> table = [ ] <NEWLINE> for rc in range ( r ) : <NEWLINE> <INDENT> table . append ( [ int ( i ) for i in input ( ) . split ( ) ] ) <NEWLINE> <NL> <DEDENT> table . append ( [ 0 for _ in range ( c + 1 ) ] ) <NEWLINE> <NL> for rc in range ( r ) : <NEWLINE> <INDENT> row_total = 0 <NEWLINE> for cc in range ( c ) : <NEWLINE> <INDENT> table [ r ] [ cc ] += table [ rc ] [ cc ] <NEWLINE> row_total += table [ rc ] [ cc ] <NEWLINE> <NL> <DEDENT> table [ rc ] . append ( row_total ) <NEWLINE> table [ r ] [ c ] += row_total <NEWLINE> <NL> <DEDENT> for row in table : <NEWLINE> <INDENT> print ( <STRING> . join ( [ str ( column ) for column in row ] ) ) <NEWLINE> <NL> <INDENT> print ( ) <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <STRING> <NEWLINE> inp = input ( ) . strip ( ) . split ( <STRING> ) <NEWLINE> row = int ( inp [ 0 ] ) <NEWLINE> col = int ( inp [ 1 ] ) <NEWLINE> <NL> cells = [ [ 0 for r in range ( row + 1 ) ] for c in range ( col + 1 ) ] <NEWLINE> for r in range ( row ) : <NEWLINE> <INDENT> inp = input ( ) . strip ( ) . split ( <STRING> ) <NEWLINE> for c in range ( col ) : <NEWLINE> <INDENT> cells [ r ] [ c ] = int ( inp [ c ] ) <NEWLINE> cells [ row ] [ c ] += cells [ r ] [ c ] <NEWLINE> cells [ r ] [ col ] += cells [ r ] [ c ] <NEWLINE> <DEDENT> cells [ row ] [ col ] += cells [ r ] [ col ] <NEWLINE> <NL> <DEDENT> for r in range ( row + 1 ) : <NEWLINE> <INDENT> print ( <STRING> . join ( map ( str , cells [ r ] ) ) ) <NEWLINE> <DEDENT>
r , c = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> l = [ ] <NEWLINE> for i in range ( r ) : l . append ( map ( int , raw_input ( ) . split ( ) ) ) <NEWLINE> l . append ( [ 0 ] * c ) <NEWLINE> for i in range ( c ) : <NEWLINE> <INDENT> for j in range ( r ) : l [ c - 1 ] [ i ] += l [ j ] [ i ] <NEWLINE> l [ i ] . append ( sum ( l [ i ] ) ) <NEWLINE> <DEDENT> for i in range ( r + 1 ) : print <STRING> . join ( map ( str , l [ i ] ) ) <NEWLINE>
r , c = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ ] <NEWLINE> for i in range ( r ) : <NEWLINE> <INDENT> a . append ( list ( map ( int , input ( ) , split ( ) ) ) ) <NEWLINE> <DEDENT> for line in arr : <NEWLINE> <INDENT> line . append ( sum ( line ) ) <NEWLINE> <DEDENT> arr . append ( [ sum ( [ line [ i ] for line in arr ] ) for i in range ( c + 1 ) ] ) <NEWLINE> for line in arr : <NEWLINE> <INDENT> print ( line ) <NEWLINE> <NL> <DEDENT>
def sum ( l ) : <NEWLINE> <INDENT> s = 0 <NEWLINE> for i in l : <NEWLINE> <INDENT> s += i <NEWLINE> <DEDENT> return s <NEWLINE> <DEDENT> r , c = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> su = [ 0 ] * c <NEWLINE> for i in range ( r ) : <NEWLINE> <INDENT> l = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> for j in l : print j , <NEWLINE> print sum ( l ) <NEWLINE> for j in range ( c ) : su [ j ] += l [ j ] <NEWLINE> <DEDENT> for j in su : print j , <NEWLINE> <INDENT> print sum ( su ) <NEWLINE> <DEDENT>
r , c = map ( int , raw_input ( ) . split ( <STRING> ) ) <NEWLINE> table1 = [ [ 0 for j in range ( c ) ] for i in range ( r ) ] <NEWLINE> for i in range ( r ) : <NEWLINE> <INDENT> table1 [ i ] = map ( int , raw_input ( ) . split ( <STRING> ) ) <NEWLINE> <NL> <DEDENT> table2 = [ [ 0 for j in range ( c + 1 ) ] for i in range ( r + 1 ) ] <NEWLINE> for i in range ( r ) : <NEWLINE> <INDENT> for j in range ( c ) : <NEWLINE> <INDENT> table2 [ i ] [ j ] = table1 [ i ] [ j ] <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( r ) : <NEWLINE> <INDENT> for j in range ( c ) : <NEWLINE> <INDENT> table2 [ i ] [ c ] += table2 [ i ] [ j ] <NEWLINE> table2 [ r ] [ j ] += table2 [ i ] [ j ] <NEWLINE> <DEDENT> table2 [ r ] [ c ] += table2 [ i ] [ c ] <NEWLINE> <NL> <DEDENT> ans = <STRING> <NEWLINE> for i in range ( r + 1 ) : <NEWLINE> <INDENT> for j in range ( c + 1 ) : <NEWLINE> <INDENT> ans += str ( table2 [ i ] [ j ] ) <NEWLINE> if j != c + 1 : <NEWLINE> <INDENT> ans += <STRING> <NEWLINE> <DEDENT> <DEDENT> if i != r + 1 : <NEWLINE> <INDENT> ans += <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> print ans <NEWLINE>
( r , c ) [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> table = [ ] <NEWLINE> for rc in range ( r ) : <NEWLINE> <INDENT> table . append ( [ int ( i ) for i in input ( ) . split ( ) ] ) <NEWLINE> <NL> <DEDENT> table . append ( [ 0 for _ in range ( c + 1 ) ] ) <NEWLINE> <NL> for rc in range ( r ) : <NEWLINE> <INDENT> row_total = 0 <NEWLINE> for cc in range ( c ) : <NEWLINE> <INDENT> table [ r ] [ cc ] += table [ rc ] [ cc ] <NEWLINE> row_total += table [ rc ] [ cc ] <NEWLINE> <NL> <DEDENT> table [ rc ] . append ( row_total ) <NEWLINE> table [ r ] [ c ] += row_total <NEWLINE> <NL> <DEDENT> for row in table : <NEWLINE> <INDENT> print ( <STRING> . join ( [ str ( column ) for column in row ] ) ) <NEWLINE> <DEDENT>
r , c = ( int ( x ) for x in input ( ) . split ( ) ) <NEWLINE> <NL> table = [ ] <NEWLINE> i = 0 <NEWLINE> <NL> while i < r <NEWLINE> <INDENT> table [ 0 ] = list ( int ( x ) for x in input ( ) . split ( ) ) <NEWLINE> i += 1 <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> i , j = 0 , 0 <NEWLINE> while i < r <NEWLINE> <INDENT> sum = 0 <NEWLINE> while j < c <NEWLINE> <INDENT> if j != 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> print ( <STRING> + teble [ i ] [ j ] , end = <STRING> ) <NEWLINE> sum += table [ i ] [ j ] <NEWLINE> j += 1 <NEWLINE> if j == c : <NEWLINE> <INDENT> print ( <STRING> + sum ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> i , j = 0 <NEWLINE> while j < c : <NEWLINE> <INDENT> while i < r : <NEWLINE> i += 1 <NEWLINE> <DEDENT>
r , c = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> data = [ [ int ( i ) for i in input ( ) . split ( ) ] for j in range ( r ) ) ] <NEWLINE> ans = [ data [ i ] + [ sum ( data [ i ] ) ] for i in range ( r ) ] <NEWLINE> last_ans = ans + [ [ sum ( [ ans [ i ] [ j ] for i in range ( r ) ] ) for j in range ( c + 1 ) ] ] <NEWLINE> for i in last_ans : <NEWLINE> <INDENT> print ( * i ) <NEWLINE> <DEDENT>
r , c = map ( int , input ( ) . strip ( ) . split ( ) ) <NEWLINE> l = [ [ ] for i in range ( r ) ] . append ( [ 0 for j in range ( c + 1 ) ] ) <NEWLINE> for i in range ( r ) : <NEWLINE> <INDENT> l [ i ] = list ( map ( int , input ( ) . strip ( ) . split ( ) ) ) <NEWLINE> l [ i ] . append ( sum ( l [ i ] [ 0 : c ] ) ) <NEWLINE> l [ r ] = [ l [ r ] [ j ] + l [ i ] [ j ] for j in range ( c + 1 ) ] <NEWLINE> print ( <STRING> . join ( map ( str , l [ i ] ) ) ) <NEWLINE> <DEDENT> print ( <STRING> . join ( map ( str , l [ r ] ) ) ) <NEWLINE>
r , c = map ( int , input ( ) . split ( ) ) <NEWLINE> mat = [ ] <NEWLINE> <NL> for x in range ( r ) : <NEWLINE> <INDENT> for y in range ( c ) : <NEWLINE> <INDENT> mat . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> for x in range ( r ) : <NEWLINE> <INDENT> rsum = 0 <NEWLINE> for y in range ( c ) : <NEWLINE> <INDENT> rsum += mat [ x ] [ y ] <NEWLINE> <DEDENT> mat [ x ] . append ( rsum ) <NEWLINE> <NL> <DEDENT> mat . append ( [ ] ) <NEWLINE> <NL> for x in range ( c ) : <NEWLINE> <INDENT> csum = 0 <NEWLINE> for y in range ( r ) : <NEWLINE> <INDENT> csum += mat [ y ] [ x ] <NEWLINE> <DEDENT> mat [ r ] . append ( csum ) <NEWLINE> <NL> <DEDENT> for x in range ( r ) : <NEWLINE> <INDENT> for y in range ( c ) : <NEWLINE> <INDENT> print ( <STRING> . format ( mat [ x ] [ y ] ) , end = <STRING> ) <NEWLINE> <DEDENT> print ( mat [ x ] [ c ] ) <NEWLINE> <NL> <DEDENT> for x in range ( c - 1 ) : <NEWLINE> <INDENT> print ( <STRING> . format ( mat [ r ] [ x ] ) , end = <STRING> ) <NEWLINE> <DEDENT> print ( mat [ r ] [ c - 1 ] ) <NEWLINE>
while True : <NEWLINE> <INDENT> ( a , op , b ) = input ( ) . split ( ) <NEWLINE> a = int ( a ) <NEWLINE> b = int ( b ) <NEWLINE> <NL> if op == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> elif op == <STRING> : <NEWLINE> <INDENT> print ( a + b ) <NEWLINE> <NL> <DEDENT> elif op == <STRING> : <NEWLINE> <INDENT> print ( a - b ) <NEWLINE> <NL> <DEDENT> elif op == <STRING> : <NEWLINE> <INDENT> print ( a * b ) <NEWLINE> <NL> <DEDENT> elif op == <STRING> : <NEWLINE> <INDENT> print ( a // b ) <NEWLINE> <DEDENT> <DEDENT>
r , c = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> data = [ ] <NEWLINE> sum_row = [ 0 ] * ( c + 1 ) <NEWLINE> <NL> for ri in range ( r ) : <NEWLINE> <INDENT> data [ ri ] . append ( [ int ( i ) for i in input ( ) . split ( ) ] ) <NEWLINE> data [ ri ] . append ( sum ( data [ ri ] ) ) <NEWLINE> print ( <STRING> . join ( [ str ( d ) for d in data [ ri ] ] ) ) <NEWLINE> for ci in range ( c + 1 ) : <NEWLINE> <INDENT> sum_row [ ci ] += data [ ri ] [ ci ] <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> . join ( [ str ( s ) for s in sum_row ] ) ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> al = [ ] <NEWLINE> b_lis = [ ] <NEWLINE> <NL> for _ in range ( a ) : <NEWLINE> <INDENT> g = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> g . append ( sum ( g ) ) <NEWLINE> al . append ( g ) <NEWLINE> <DEDENT> for i in range ( b + 1 ) : <NEWLINE> <INDENT> p = 0 <NEWLINE> for j in range ( a ) : <NEWLINE> <INDENT> p += al [ j ] [ i ] <NEWLINE> <DEDENT> b_lis . append ( p ) <NEWLINE> <DEDENT> al_1 . append ( ( b_lis ) ) <NEWLINE> for i in al_1 : <NEWLINE> <INDENT> print ( <STRING> . join ( [ str ( v ) for v in i ] ) ) <NEWLINE> <DEDENT>
r , c = map ( int , input ( ) . split ( ) ) <NEWLINE> tbl = [ [ 0 ] * c for i in range ( r + 1 ) ] <NEWLINE> for i in range ( r ) : <NEWLINE> <INDENT> tbl [ i ] = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <DEDENT> for i in range ( c ) : <NEWLINE> <INDENT> for j in renge ( r ) : <NEWLINE> <INDENT> tbl [ r ] [ i ] += tbl [ j ] [ i ] <NEWLINE> <DEDENT> <DEDENT> for i in rnage ( r + 1 ) : <NEWLINE> <INDENT> m = 0 <NEWLINE> for j in range ( c ) : <NEWLINE> <INDENT> m += tbl [ i ] [ j ] <NEWLINE> print ( tbl [ i ] [ j ] , end = <STRING> ) <NEWLINE> <DEDENT> print ( m ) <NEWLINE> <DEDENT>
def show2dlist ( nlist , r , c ) : <NEWLINE> <INDENT> for x in xrange ( 0 , r ) : <NEWLINE> <INDENT> for y in xrange ( 0 , c ) : <NEWLINE> <INDENT> print nlist [ x ] [ y ] , <NEWLINE> <DEDENT> print <STRING> <NEWLINE> <DEDENT> <DEDENT> def showlist ( nlist , nlistlen ) : <NEWLINE> <INDENT> for x in xrange ( nlistlen ) : <NEWLINE> <INDENT> print nlist [ x ] , <NEWLINE> <NL> <DEDENT> <DEDENT> r , c = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> table = [ [ 0 for x in xrange ( c ) ] for y in xrange ( r ) ] <NEWLINE> i = 0 <NEWLINE> for x in xrange ( r ) : <NEWLINE> <INDENT> table [ i ] = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> i += 1 <NEWLINE> <COMMENT> <NL> <DEDENT> csumlist = [ 0 for x in xrange ( 0 , c + 1 ) ] <NEWLINE> for x in xrange ( 0 , r ) : <NEWLINE> <INDENT> table [ x ] . append ( sum ( table [ x ] ) ) <NEWLINE> for y in xrange ( 0 , c + 1 ) : <NEWLINE> <INDENT> csumlist [ y ] += table [ x ] [ y ] <NEWLINE> <DEDENT> <DEDENT> show2dlist ( table , r , c + 1 ) <NEWLINE> showlist ( csumlist , c + 1 ) <NEWLINE>
r , c = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> data = [ ] <NEWLINE> sum_row = [ 0 ] * ( c + 1 ) <NEWLINE> <NL> for ri in range ( r ) : <NEWLINE> <INDENT> data . append ( [ int ( i ) for i in input ( ) . split ( ) ] ) <NEWLINE> data [ ri ] . append ( sum ( data [ ri ] ) ) <NEWLINE> print ( <STRING> . join ( [ str ( d ) for d in data [ ri ] ] ) ) <NEWLINE> for ci in range ( c + 1 ) : <NEWLINE> <INDENT> sum_row [ ci ] += data [ ri ] [ ci ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> . join ( [ str ( s ) for d in sum_row ] ) ) <NEWLINE>
( r , c ) = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> src = [ ] <NEWLINE> for _ in range ( r ) : <NEWLINE> <INDENT> row = ( [ int ( i ) for i in input ( ) . split ( ) ] ) <NEWLINE> row . append ( sum ( row ) ) <NEWLINE> src . append ( row ) <NEWLINE> <NL> <DEDENT> last_row = [ 0 for _ in range ( c + 1 ) ] <NEWLINE> for rc in range ( r ) : <NEWLINE> <INDENT> for cc in range ( c ) : <NEWLINE> <INDENT> last_row += src [ rc ] [ cc ] <NEWLINE> <DEDENT> <DEDENT> src . append ( last_row ) <NEWLINE> <NL> for rc in range ( r + 1 ) : <NEWLINE> <INDENT> print ( <STRING> . join ( [ str ( a ) for a in src [ rc ] ] ) ) <NEWLINE> <DEDENT>
r , c = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> data = [ ] <NEWLINE> sum_row = [ 0 ] * ( c + 1 ) <NEWLINE> <NL> for ri in range ( r ) : <NEWLINE> <INDENT> data . append ( [ int ( i ) for i in input ( ) . sprit ( ) ] ) <NEWLINE> data [ ri ] . append ( sum ( data [ ri ] ) ) <NEWLINE> print ( <STRING> . join ( [ str ( d ) for d in data [ ri ] ] ) ) <NEWLINE> for ci in range ( c + 1 ) : <NEWLINE> <INDENT> sum_row [ ci ] += data [ ri ] [ ci ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> . join ( [ str ( s ) for s in sum_row ] ) ) <NEWLINE>
r , c = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> a = [ map ( int , raw_input ( ) . split ( ) ) for _ in xrange ( r ) ] <NEWLINE> s = [ sum ( a [ i ] ) for i in xrange ( r ) ] <NEWLINE> sums , l = 0 , [ ] <NEWLINE> for i in xrange ( r ) : <NEWLINE> <INDENT> a [ i ] . append ( s [ i ] ) <NEWLINE> <DEDENT> for i in xrange ( c + 1 ) : <NEWLINE> <INDENT> for j in xrange ( r ) : <NEWLINE> <INDENT> sums += a [ j ] [ i ] <NEWLINE> <DEDENT> l . append ( sums ) <NEWLINE> sums = 0 <NEWLINE> <DEDENT> a . append ( l ) <NEWLINE> for i in a : <NEWLINE> <INDENT> for j in xrange ( c + 1 ) : <NEWLINE> <INDENT> print i [ j ] , <NEWLINE> <DEDENT> print <STRING> <NEWLINE> <DEDENT>
( r , c ) = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> src = [ ] <NEWLINE> for _ in range ( r ) : <NEWLINE> <INDENT> row = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> row . append ( sum ( row ) ) <NEWLINE> src . append ( row ) <NEWLINE> <NL> <DEDENT> last_row = [ 0 for _ in range ( c ) ] <NEWLINE> for rc in range ( r ) : <NEWLINE> <INDENT> for cc in range ( c ) : <NEWLINE> <INDENT> last_row [ cc ] += src [ rc ] [ cc ] <NEWLINE> <DEDENT> <DEDENT> src = append ( last_row ) <NEWLINE> <NL> <NL> for _ in range ( r + 1 ) : <NEWLINE> <INDENT> print ( <STRING> . join ( [ str ( a ) for a in src [ rc ] ] ) ) <NEWLINE> <DEDENT>
r , c = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> l = [ ] <NEWLINE> for i in range ( r ) : <NEWLINE> <INDENT> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> l . append ( a . append ( sum ( a ) ) ) <NEWLINE> <DEDENT> b = [ ] <NEWLINE> for i in range ( c + 1 ) : <NEWLINE> <INDENT> c = 0 <NEWLINE> for j in range ( r ) : <NEWLINE> <INDENT> c += l [ j ] [ i ] <NEWLINE> <DEDENT> b . append ( c ) <NEWLINE> <DEDENT> l . append ( b ) <NEWLINE> <NL> for i in l : <NEWLINE> <INDENT> print ( <STRING> . join ( i ) ) <NEWLINE> <DEDENT>
r , c = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> a = [ [ 0 for i in range ( r ) ] for j in range ( c ) ] <NEWLINE> for i in range ( c ) : <NEWLINE> <INDENT> row = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> for j in range ( r ) : <NEWLINE> <INDENT> a [ i ] [ j ] = row [ j ] <NEWLINE> <DEDENT> <DEDENT>
r , c = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> A = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( c ) ] <NEWLINE> for i in range ( c ) : <NEWLINE> <INDENT> for j in range ( r ) : <NEWLINE> <INDENT> print ( A [ i ] [ j ] , end = <STRING> ) <NEWLINE> <DEDENT> print ( sum ( A [ i ] ) ) <NEWLINE> <DEDENT> for i in range ( c ) : <NEWLINE> <INDENT> ans = 0 <NEWLINE> for j in range ( r ) : <NEWLINE> <INDENT> ans += A [ j ] [ i ] <NEWLINE> <DEDENT> print ( ans , end = <STRING> ) <NEWLINE> <DEDENT> print ( sum ( map ( sum , A ) ) ) <NEWLINE> <NL>
( r , c ) = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> last_row = [ 0 for _ in range ( c + 1 ) ] <NEWLINE> <NL> for _ in range ( r ) : <NEWLINE> <INDENT> row = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> for cc in range ( c ) : <NEWLINE> <INDENT> last_row [ cc ] += int ( row [ cc ] ) <NEWLINE> print ( row [ cc ] , end = <STRING> ) <NEWLINE> <NL> <DEDENT> print ( sum ( row ) ) <NEWLINE> <NL> <DEDENT> last_row [ - 1 ] = sum ( last_row ) <NEWLINE> print ( <STRING> . join ( [ str ( a ) for a in last_row ] ) <NEWLINE>
r , c = map ( int , input ( ) . split ( ) ) <NEWLINE> table = [ ] <NEWLINE> for i in range ( r ) : <NEWLINE> <INDENT> table . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <DEDENT> for i in table : <NEWLINE> <INDENT> i . append ( sum ( i ) ) <NEWLINE> <DEDENT> b = [ ] <NEWLINE> for i in range ( c ) : <NEWLINE> <INDENT> b . append ( sum ( list ( table [ k for k in range ( r ) ] [ i ] ) ) ) <NEWLINE> <DEDENT> b . append ( sum ( b ) ) <NEWLINE> for i in table : <NEWLINE> <INDENT> print ( <STRING> . join ( map ( str , i ) ) ) <NEWLINE> <DEDENT> print ( <STRING> . join ( map ( str , b ) ) ) <NEWLINE>
r , c = input ( ) . split ( ) <NEWLINE> r = int ( r ) <NEWLINE> c = int ( c ) <NEWLINE> <NL> a = [ 0 ] * c <NEWLINE> <NL> for i in range ( r ) : <NEWLINE> <INDENT> a [ i ] = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a [ i ] . append ( sum ( a [ i ] ) ) <NEWLINE> print ( * a [ i ] ) <NEWLINE> <NL> <DEDENT> b = list ( zip ( * a ) ) <NEWLINE> print ( * [ sum ( b [ i ] ) for i in range ( len ( b ) ) ] ) <NEWLINE>
( n , m , l ) = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> A = [ ] <NEWLINE> for nc in range ( n ) : <NEWLINE> <INDENT> A . append ( [ int ( i ) for i in input ( ) . split ( ) ] ) <NEWLINE> <NL> <DEDENT> B = [ ] <NEWLINE> for mc in range ( m ) : <NEWLINE> <INDENT> B . append ( [ int ( i ) for i in input ( ) . split ( ) ] ) <NEWLINE> <NL> <DEDENT> product = [ ] <NEWLINE> <NL> for nc in range ( n ) : <NEWLINE> <INDENT> for lc in range ( l ) : <NEWLINE> <INDENT> if lc == l - 1 : <NEWLINE> <INDENT> print ( product [ nc ] [ lc ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( product [ nc ] [ lc ] , <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
n , m , l = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( n ) ] <NEWLINE> b = [ list ( map ( int , input ( ) . split ( ) ) ) for j in range ( m ) ] <NEWLINE> num = [ [ 0 for i in range ( l ) ] for j in range ( n ) ] <NEWLINE> for k in range ( n ) : <NEWLINE> <INDENT> for i in range ( l ) : <NEWLINE> <INDENT> for j in range ( m ) : <NEWLINE> <INDENT> num [ k ] [ i ] += a [ k ] [ j ] * b [ j ] [ i ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> print ( <STRING> . join ( map ( num [ i ] ) ) ) <NEWLINE> <NL> <NL> <DEDENT>
( n , m , l ) = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> A = [ ] <NEWLINE> for nc in range ( n ) : <NEWLINE> <INDENT> A . append ( [ int ( i ) for i in input ( ) . split ( ) ] ) <NEWLINE> <DEDENT> B = [ ] <NEWLINE> for mc in range ( m ) : <NEWLINE> <INDENT> B . append ( [ int ( i ) for i in input ( ) . split ( ) ] ) <NEWLINE> <NL> <DEDENT> product = [ [ 0 for d in range ( l ) ] for dd in range ( ) ] <NEWLINE> <NL> for nc in range ( n ) : <NEWLINE> <INDENT> for lc in range ( l ) : <NEWLINE> <INDENT> for mc in range ( m ) : <NEWLINE> <INDENT> product [ nc ] [ lc ] += A [ nc ] [ mc ] * B [ mc ] [ lc ] <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for r in product : <NEWLINE> <INDENT> print ( <STRING> . join ( [ str ( d ) for d in r ] ) ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> def input_number ( ) : <NEWLINE> <INDENT> for i in range ( n ) : <NEWLINE> <INDENT> adding = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> A . append ( adding ) <NEWLINE> <DEDENT> for i in range ( m ) : <NEWLINE> <INDENT> adding = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> B . append ( adding ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> n , m , l = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> A = [ ] <NEWLINE> B = [ ] <NEWLINE> ans = [ [ 0 for i in range ( n ) ] for j in range ( l ) ] <NEWLINE> input_number ( ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( l ) : <NEWLINE> <INDENT> for k in range ( m ) : <NEWLINE> <INDENT> ans [ i ] [ j ] += A [ i ] [ k ] * B [ k ] [ j ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( l ) : <NEWLINE> <INDENT> sys . stdout . write ( <STRING> % ans [ i ] [ j ] ) <NEWLINE> if j != l - 1 : <NEWLINE> <INDENT> sys . stdout . write ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> sys . stdout . write ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
n , m , l = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> matA = [ map ( int , raw_input ( ) . split ( ) ) for i in range ( m ) ] <NEWLINE> matB = [ map ( int , raw_input ( ) . split ( ) ) for j in range ( l ) ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( l ) : <NEWLINE> <INDENT> print sum ( [ A [ i ] [ k ] * B [ k ] [ j ] for k in range ( m ) ] ) , <NEWLINE> <DEDENT> print <NEWLINE> <DEDENT>
n , m , l = map ( int , input ( ) . split ( ) ) <NEWLINE> lst = [ [ ] for i in range ( n ) ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> lst [ i ] = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <DEDENT> lst2 = [ [ ] for j in range ( m ) ] <NEWLINE> for i in rnage ( m ) : <NEWLINE> <INDENT> lst2 [ j = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> x = 0 <NEWLINE> for j in range ( m ) : <NEWLINE> <INDENT> x = x + lst [ i ] [ j ] * lst2 [ j ] [ i ] <NEWLINE> <DEDENT> print ( x ) <NEWLINE> <DEDENT>
n , m , l = map ( int , raw_input ( ) . split ( <STRING> ) ) <NEWLINE> A = [ [ 0 for j in range ( m ) ] for i in range ( n ) ] <NEWLINE> B = [ [ 0 for j in range ( l ) ] for i in range ( m ) ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> A [ i ] = map ( int , raw_input ( ) . split ( <STRING> ) ) <NEWLINE> <DEDENT> for i in range ( m ) : <NEWLINE> <INDENT> B [ i ] = map ( int , raw_input ( ) . split ( <STRING> ) ) <NEWLINE> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( l ) : <NEWLINE> <INDENT> sum = 0 <NEWLINE> for k in range ( m ) : <NEWLINE> <INDENT> sum += A [ i ] [ k ] * B [ k ] [ j ] <NEWLINE> <DEDENT> print sum , <NEWLINE> <DEDENT> if i < n - 1 : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> <DEDENT>
n , m , l = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> A = [ ] <NEWLINE> B = [ ] <NEWLINE> C = [ ] <NEWLINE> <NL> for ni in range ( n ) : <NEWLINE> <INDENT> A . append ( [ int ( i ) for mi in input ( ) . split ( ) ] ) <NEWLINE> <NL> <DEDENT> for mi in range ( m ) : <NEWLINE> <INDENT> B . append ( [ int ( i ) for i in input ( ) . split ( ) ] ) <NEWLINE> <NL> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> C . append ( [ ] ) <NEWLINE> for j in range ( l ) : <NEWLINE> <INDENT> C [ i ] . append ( 0 ) <NEWLINE> for k in range ( m ) : <NEWLINE> <INDENT> C [ i ] [ j ] += A [ i ] [ k ] * B [ k ] [ j ] <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for ni in range ( l ) : <NEWLINE> <INDENT> print ( <STRING> , join ( [ str ( s ) for s in C [ ni ] ] ) ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> mat1 = { } <NEWLINE> mat2 = { } <NEWLINE> <NL> n , m , l = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> list = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> for j in range ( 1 , m + 1 ) : <NEWLINE> <INDENT> mat1 [ ( i , j ) ] = list [ j - 1 ] <NEWLINE> <NL> <DEDENT> <DEDENT> for j in range ( 1 , m + 1 ) : <NEWLINE> <INDENT> list = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> for k in range ( 1 , l + 1 ) : <NEWLINE> <INDENT> mat2 [ ( j , k ) ] = list [ k - 1 ] <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> buf = <STRING> <NEWLINE> for k in range ( 1 , l + 1 ) : <NEWLINE> <INDENT> res = 0 <NEWLINE> for j in range ( 1 , m + 1 ) : <NEWLINE> <INDENT> res += mat1 [ ( i , j ) ] * mat2 [ ( j , k ) ] <NEWLINE> <DEDENT> buf += str ( res ) + <STRING> <NEWLINE> <DEDENT> buf . rsplit ( ) <NEWLINE> print buf <NEWLINE> <DEDENT>
n , m , l = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> a = [ map ( int , raw_input ( ) . split ( ) ) for _ in range ( n ) ] <NEWLINE> b = [ map ( int , raw_input ( ) . split ( ) ) for _ in range ( m ) ] <NEWLINE> c = [ [ 0 for i in range ( n ) ] for j in range ( l ) ] <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( l ) : <NEWLINE> <INDENT> s = 0 <NEWLINE> for k in range ( m ) : <NEWLINE> <INDENT> s += a [ i ] [ k ] * b [ k ] [ j ] <NEWLINE> <DEDENT> c [ i ] [ j ] = s <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> print <STRING> . join ( map ( str , c [ i ] ) ) <NEWLINE> <DEDENT>
n , m , l = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> <NL> A = [ ] <NEWLINE> B = [ ] <NEWLINE> AB = [ [ ] for i in range ( n ) ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> A . append ( map ( int , raw_input ( ) . split ( ) ) ) <NEWLINE> <DEDENT> for j in range ( m ) : <NEWLINE> <INDENT> B . append ( map ( int , raw_input ( ) . split ( ) ) ) <NEWLINE> <NL> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> for k in range ( l ) : <NEWLINE> <INDENT> sum = 0 <NEWLINE> for j in range ( m ) : <NEWLINE> <INDENT> sum += A [ i ] [ j ] * B [ j ] [ k ] <NEWLINE> <DEDENT> AB [ i ] . append ( sum ) <NEWLINE> <DEDENT> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> print ( <STRING> . format ( AB [ i ] ) . replace ( <STRING> , <STRING> ) . replace ( <STRING> , <STRING> ) . replace ( <STRING> , <STRING> ) ) <NEWLINE> <NL> <DEDENT>
n , m , l = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> x = [ ] <NEWLINE> y = [ ] <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> x . append ( a ) <NEWLINE> <NL> <DEDENT> for i in range ( m ) : <NEWLINE> <INDENT> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> y . append ( b ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> a = 0 <NEWLINE> b = [ ] <NEWLINE> ans = [ ] <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( m ) : <NEWLINE> <INDENT> for k in range ( l ) : <NEWLINE> <INDENT> a += x [ i ] [ k ] * y [ k ] [ j ] <NEWLINE> <COMMENT> <NL> <DEDENT> b . append ( a ) <NEWLINE> a = 0 <NEWLINE> <DEDENT> b = list ( map ( str , b ) ) <NEWLINE> b = <STRING> . join ( b ) <NEWLINE> ans . append ( b ) <NEWLINE> b = [ ] <NEWLINE> <NL> <DEDENT> [ print ( ans [ i ] ) for i in range ( len ( ans ) ) ] <NEWLINE>
n , m , l = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ input ( ) . split ( ) for _ in range ( n ) ] <NEWLINE> b = [ input ( ) . split ( ) for _ in rnage ( m ) ] <NEWLINE> c = [ [ 0 ] * l for _ in range ( n ) ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( l ) : <NEWLINE> <INDENT> for k in range ( m ) : <NEWLINE> <INDENT> c [ i ] [ j ] = int ( a [ i ] [ k ] ) * int ( b [ k ] [ j ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> print ( * c ) <NEWLINE> <DEDENT>
<NL> n , m , l = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> A = [ ] <NEWLINE> B = [ ] <NEWLINE> C = [ ] <NEWLINE> <NL> for ni in range ( n ) : <NEWLINE> <INDENT> A . append ( [ int ( i ) for i in input ( ) . split ( ) ] ) <NEWLINE> <NL> <DEDENT> for mi in range ( m ) : <NEWLINE> <INDENT> B . append ( [ int ( i ) for i in input ( ) . split ( ) ] ) <NEWLINE> <NL> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> C . append ( [ ] ) <NEWLINE> for j in range ( l ) : <NEWLINE> <INDENT> c . append ( 0 ) <NEWLINE> for k in range ( m ) : <NEWLINE> <INDENT> C [ i ] [ j ] += A [ i ] [ k ] * B [ k ] [ j ] <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for ni in range ( n ) : <NEWLINE> <INDENT> print ( <STRING> . join ( [ str ( s ) for s in C [ ni ] ] ) ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> m , f , r = map ( int , input ( ) . split ( ) ) <NEWLINE> if m == - 1 and f == - 1 and r == - 1 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> if m == - 1 or f == - 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif m + f >= 80 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif 65 <= m + f : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif 50 <= m + f : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif 30 <= m + f : <NEWLINE> <INDENT> if r >= 50 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
n , m , l = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> <NL> A , B = [ ] , [ ] <NEWLINE> for ni in range ( n ) : <NEWLINE> <INDENT> A . append ( map ( int , raw_input ( ) . split ( ) ) ) <NEWLINE> <NL> <DEDENT> for mi in range ( m ) : <NEWLINE> <INDENT> B . append ( map ( int , raw_input ( ) . split ( ) ) ) <NEWLINE> <NL> <DEDENT> _B = list ( map ( list , zip ( * B ) ) ) <NEWLINE> <NL> for a in A : <NEWLINE> <INDENT> for b in _B : <NEWLINE> <INDENT> result = 0 <NEWLINE> for i , j in zip ( a , b ) : <NEWLINE> <INDENT> result += i * j <NEWLINE> <DEDENT> print <STRING> % result , <NEWLINE> <DEDENT> print <STRING> , <NEWLINE> <DEDENT>
n , m , l = [ int ( x ) for x in raw_input ( ) . split ( ) ] <NEWLINE> <NL> A = [ ] <NEWLINE> for idx in range ( 0 , n ) : <NEWLINE> <INDENT> A . append ( [ int ( x ) for x in raw_input ( ) . split ( ) ] ) <NEWLINE> <NL> <DEDENT> B = [ ] <NEWLINE> for idx in range ( 0 , m ) : <NEWLINE> <INDENT> B . append ( [ int ( x ) for x in raw_input ( ) . split ( ) ] ) <NEWLINE> <NL> <DEDENT> for line in range ( 0 , n ) : <NEWLINE> <INDENT> result_list = [ ] <NEWLINE> for idx1 in range ( 0 , l ) : <NEWLINE> <INDENT> sum = 0 <NEWLINE> for idx2 in range ( 0 , m ) : <NEWLINE> <INDENT> sum += A [ line ] [ idx2 ] * B [ idx2 ] [ idx1 ] <NEWLINE> <DEDENT> result_list . append ( sum ) <NEWLINE> <NL> <DEDENT> result_str = <STRING> <NEWLINE> for result in result_list : <NEWLINE> <INDENT> result_str += str ( result ) + <STRING> <NEWLINE> <DEDENT> print result_str + <STRING> <NEWLINE> <DEDENT>
l , m , n = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ [ 0 for i in range ( m ) ] for i in range ( l ) ] <NEWLINE> b = [ [ 0 for i in range ( n ) ] for i in range ( m ) ] <NEWLINE> c = [ [ 0 for i in range ( n ) ] for i in range ( l ) ] <NEWLINE> <NL> for i in range ( l ) : <NEWLINE> <INDENT> a [ i ] = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> <NL> <DEDENT> for i in range ( m ) : <NEWLINE> <INDENT> b [ i ] = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> <NL> <DEDENT> for i in range ( l ) : <NEWLINE> <INDENT> for j in range ( n ) : <NEWLINE> <INDENT> for k in range ( m ) : <NEWLINE> <INDENT> c [ i ] [ j ] += ( a [ i ] [ m ] * b [ m ] [ j ] ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> . join ( [ str ( x ) for x in c [ i ] ] ) ) <NEWLINE> <DEDENT>
<INDENT> n , m , L = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <DEDENT> a = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ] <NEWLINE> b = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( m ) ] <NEWLINE> c = [ [ sum ( ak * bk for ak , bk in zip ( ai , bj ) ) for bj in zip ( * b ) ] for ai in a ] <NEWLINE> <NL> for ci in c : <NEWLINE> <INDENT> print ( * ci ) <NEWLINE> <DEDENT>
<COMMENT> <NL> using namespace std ; <NEWLINE> <NL> int main ( ) { <NEWLINE> <INDENT> int n , m , l , a [ 110 ] [ 110 ] = { 0 } , b [ 110 ] [ 110 ] = { 0 } ; <NEWLINE> long long c [ 110 ] [ 110 ] = { 0 } ; <NEWLINE> cin >> n >> m >> l ; <NEWLINE> for ( int i = 0 ; i < n ; i + + ) <NEWLINE> <INDENT> for ( int j = 0 ; j < m ; j + + ) <NEWLINE> <INDENT> cin >> a [ i ] [ j ] ; <NEWLINE> <DEDENT> <DEDENT> for ( int i = 0 ; i < m ; i + + ) <NEWLINE> <INDENT> for ( int j = 0 ; j < l ; j + + ) <NEWLINE> <INDENT> cin >> b [ i ] [ j ] ; <NEWLINE> <NL> <DEDENT> <DEDENT> for ( int i = 0 ; i < n ; i + + ) <NEWLINE> <INDENT> for ( int j = 0 ; j < l ; j + + ) <NEWLINE> <INDENT> for ( int k = 0 ; k < m ; k + + ) <NEWLINE> <INDENT> c [ i ] [ j ] += a [ i ] [ k ] * b [ k ] [ j ] ; <NEWLINE> <DEDENT> <DEDENT> <DEDENT> for ( int i = 0 ; i < n ; i + + ) { <NEWLINE> <INDENT> for ( int j = 0 ; j < l - 1 ; j + + ) <NEWLINE> <INDENT> cout << c [ i ] [ j ] << <STRING> ; <NEWLINE> <DEDENT> cout << c [ i ] [ l - 1 ] << endl ; <NEWLINE> <DEDENT> } <NEWLINE> <DEDENT> } <NEWLINE>
n , m , l = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ ] <NEWLINE> B = [ ] <NEWLINE> C = [ [ 0 ] * l for i in range ( n ) ] <NEWLINE> for x in range ( n ) : <NEWLINE> <INDENT> A [ x ] . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> <DEDENT> for x in range ( m ) : <NEWLINE> <INDENT> B [ x ] . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> <DEDENT> for x in range ( n ) : <NEWLINE> <INDENT> for y in range ( l ) : <NEWLINE> <INDENT> sum = 0 <NEWLINE> for z in range ( m ) : <NEWLINE> <INDENT> sum += A [ x ] [ z ] * B [ z ] [ y ] <NEWLINE> <DEDENT> C [ x ] [ y ] = sum <NEWLINE> <NL> <DEDENT> <DEDENT> for x in range ( n ) : <NEWLINE> <INDENT> for y in range ( l - 1 ) : <NEWLINE> <INDENT> print ( <STRING> . format ( C [ x ] [ y ] ) , end = <STRING> ) <NEWLINE> <DEDENT> print ( C [ x ] [ l - 1 ] ) <NEWLINE> <NL> <DEDENT>
n , m , l , = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> A = [ ] <NEWLINE> B = [ ] <NEWLINE> C = [ ] <NEWLINE> <NL> for ni in range ( n ) : <NEWLINE> <INDENT> A . append ( [ int ( i ) for i in input ( ) . split ( ) ] ) <NEWLINE> <NL> <DEDENT> for mi in range ( m ) : <NEWLINE> <INDENT> B . append ( [ int ( i ) for i in input ( ) . split ( ) ] ) <NEWLINE> <NL> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( l ) : <NEWLINE> <INDENT> C [ i ] . append ( 0 ) <NEWLINE> for k in range ( m ) : <NEWLINE> <INDENT> C [ i ] [ j ] += A [ i ] [ k ] * B [ k ] [ j ] <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for li in range ( n ) : <NEWLINE> <INDENT> print ( <STRING> . join ( [ str ( s ) for s in C [ li ] ] ) ) <NEWLINE> <DEDENT>
<NL> ( n , m , l ) = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> <NL> A = [ ] <NEWLINE> for i in xrange ( 0 , n ) : <NEWLINE> <INDENT> line_A = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> A . append ( line_A ) <NEWLINE> <NL> <DEDENT> B = [ ] <NEWLINE> for j in xrange ( 0 , m ) : <NEWLINE> <INDENT> line_B = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> B . append ( line_B ) <NEWLINE> <NL> <DEDENT> C = [ ] <NEWLINE> for x in xrange ( 0 , n ) : <NEWLINE> <INDENT> temp_list = [ ] <NEWLINE> for y in xrange ( 0 , l ) : <NEWLINE> <INDENT> temp = 0 <NEWLINE> for z in xrange ( 0 , m ) : <NEWLINE> <INDENT> temp = temp + A [ x ] [ z ] * B [ z ] [ y ] <NEWLINE> <NL> <DEDENT> temp_list . append ( temp ) <NEWLINE> <NL> <DEDENT> C . append ( temp_list ) <NEWLINE> temp_list = [ ] <NEWLINE> <NL> <NL> <DEDENT> for k in xrange ( 0 , n ) : <NEWLINE> <INDENT> if k > 0 : <NEWLINE> <INDENT> print <NEWLINE> <DEDENT> for h in xrange ( 0 , l ) : <NEWLINE> <DEDENT>
n , m , l = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ ] <NEWLINE> b = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <DEDENT> for j in range ( m ) : <NEWLINE> <INDENT> b . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <DEDENT> for k in range ( n ) : <NEWLINE> <INDENT> for o in range ( l ) : <NEWLINE> <INDENT> sum = 0 <NEWLINE> for p in range ( m ) : <NEWLINE> <INDENT> sum += a [ n ] [ m ] * b [ m ] [ l ] <NEWLINE> <DEDENT> print ( sum , end = <STRING> ) <NEWLINE> if o != l - 1 : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> <DEDENT> print ( ) <NEWLINE> <DEDENT>
n , m , l = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ ] <NEWLINE> b = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <DEDENT> for j in range ( m ) : <NEWLINE> <INDENT> b . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> <DEDENT> c = [ [ 0 for k in range ( l ) ] for i in range ( n ) ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> for k in range ( l ) : <NEWLINE> <INDENT> for j in range ( m ) : <NEWLINE> <INDENT> c [ i ] [ k ] += int ( a [ i ] [ j ] * b [ j ] [ k ] ) <NEWLINE> for i in range ( n ) : <NEWLINE> <DEDENT> <DEDENT> print ( c [ i ] ) <NEWLINE> <DEDENT>
n , m , l = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( n ) ] <NEWLINE> B = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( m ) ] <NEWLINE> C = [ [ 0 ] * l for i in range ( n ) ] <NEWLINE> <NL> for x in range ( n ) : <NEWLINE> <INDENT> for y in range ( m ) : <NEWLINE> <INDENT> for z in range ( l ) : <NEWLINE> <INDENT> C [ x ] [ y ] += A [ x ] [ z ] * B [ z ] [ y ] <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for row in range ( n ) : <NEWLINE> <INDENT> print ( <STRING> % ( C [ row ] [ 0 ] ) , end = <STRING> ) <NEWLINE> for col in range ( 1 , l ) : <NEWLINE> <INDENT> print ( <STRING> % ( C [ row ] [ col ] ) , end = <STRING> ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> <NL> <DEDENT>
<COMMENT> <NL> <NL> n , m , l = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> mat_A = [ ] <COMMENT> <NEWLINE> mat_B = [ ] <COMMENT> <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> mat_A . append ( map ( int , raw_input ( ) . split ( ) ) ) <NEWLINE> <NL> <DEDENT> for j in range ( m ) : <NEWLINE> <INDENT> mat_B . append ( map ( int , raw_input ( ) . split ( ) ) ) <NEWLINE> <NL> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> c = [ 0 for g in range ( n ) ] <NEWLINE> for j in range ( l ) : <NEWLINE> <INDENT> for k in range ( m ) : <NEWLINE> <INDENT> c [ j ] += mat_A [ i ] [ k ] * mat_B [ k ] [ j ] <NEWLINE> <DEDENT> <DEDENT> print <STRING> . join ( map ( str , c ) ) <NEWLINE> <DEDENT>
n , m , l = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ ] <NEWLINE> b = [ ] <NEWLINE> c = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> c . append ( [ 0 for k in range ( l ) ] ) <NEWLINE> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> a . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <DEDENT> for i in range ( m ) : <NEWLINE> <INDENT> b . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <DEDENT> for s in range ( n ) : <NEWLINE> <INDENT> for t in range ( m ) : <NEWLINE> <INDENT> elm = 0 <NEWLINE> for u in range ( l ) : <NEWLINE> <INDENT> elm += a [ s ] [ t ] * b [ t ] [ u ] <NEWLINE> <DEDENT> c [ s ] [ t ] = elm <NEWLINE> <DEDENT> <DEDENT> for i in c : <NEWLINE> <INDENT> print ( <STRING> . join ( str , i ) ) <NEWLINE> <DEDENT>
n , m , l = map ( int , input ( ) . split ( ) ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a += [ list ( map ( int , input ( ) . split ( ) ) ) ] <NEWLINE> <NL> <DEDENT> for i in range ( m ) : <NEWLINE> <INDENT> b += [ list ( map ( int , input ( ) . split ( ) ) ) ] <NEWLINE> <NL> <DEDENT> c = [ [ a [ i ] [ k ] * b [ k ] [ i ] for i in range ( n ) ] for k in range ( l ) ] <NEWLINE> print ( c ) <NEWLINE>
import numpy as np <NEWLINE> import sys <NEWLINE> <NL> n , m , l = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> a = [ ] <NEWLINE> b = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a . append ( map ( int , raw_input ( ) . split ( ) ) ) <NEWLINE> <DEDENT> for i in range ( m ) : <NEWLINE> <INDENT> b . append ( map ( int , raw_input ( ) . split ( ) ) ) <NEWLINE> <NL> <DEDENT> a = np . matrix ( a ) <NEWLINE> b = np . matrix ( b ) <NEWLINE> <NL> c = a * b <NEWLINE> <NL> for i in xrange ( n ) : <NEWLINE> <INDENT> for j in xrange ( l - 1 ) : <NEWLINE> <INDENT> sys . stdout . write ( str ( c [ i , j ] ) + <STRING> ) <NEWLINE> <DEDENT> print c [ i , l - 1 ] <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> s = raw_input ( ) . strip ( ) <NEWLINE> print s . swapcase ( ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
fAIR , LATER , OCCASIONALLY CLOUDY . <NEWLINE>
swapcase ( input ( ) ) <NEWLINE>
print ( input . swapcase ( ) ) <NEWLINE>
<COMMENT> <NL> <NL> line = raw_input ( ) <NEWLINE> result = <STRING> <NEWLINE> for s in line : <NEWLINE> <INDENT> if s . isalpha ( ) : <NEWLINE> <INDENT> if s . isupper ( ) : <NEWLINE> <INDENT> result += s . lower ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> result += s . upper ( ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print result += s <NEWLINE> <NL> <DEDENT> <DEDENT> print result <NEWLINE>
print ( input ( ) . swapcase ( ) ) ) <NEWLINE> <NL>
Target = input ( ) <NEWLINE> Target . swapcases ( ) <NEWLINE> print ( Target ) <NEWLINE> <NL>
print ( sys . stdin . readline ( ) . rstrip ( ) . swapcase ( ) ) <NEWLINE>
string = input ( ) <NEWLINE> print ( string . swapcase ( ) <NEWLINE>
s = input ( ) <NEWLINE> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> if s [ i ] . islower ( ) : <NEWLINE> <INDENT> s [ i ] = s [ i ] . upper ( ) <NEWLINE> <DEDENT> elif s [ i ] . isupper ( ) : <NEWLINE> <INDENT> s [ i ] = s [ i ] . lower ( ) <NEWLINE> <DEDENT> <DEDENT> print ( s ) <NEWLINE>
s = input ( ) ; ans = <STRING> <NEWLINE> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> if s [ i ] . islower ( ) : <NEWLINE> <INDENT> ans += s [ i ] . upper ( ) , end = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += s [ i ] . lower ( ) , end = <STRING> <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
while 1 : <NEWLINE> <INDENT> input = raw_input ( ) <NEWLINE> output = <STRING> <NEWLINE> <NL> for i in input : <NEWLINE> <INDENT> if i . islower ( ) : <NEWLINE> <INDENT> output += i . upper ( ) <NEWLINE> <DEDENT> elif i . isupper ( ) : <NEWLINE> <INDENT> output += i . lower ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( output ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> using namespace std ; <NEWLINE> <NL> int main ( ) { <NEWLINE> <INDENT> string s ; <NEWLINE> getline ( cin , s ) ; <NEWLINE> for ( int i = 0 ; i < s . size ( ) ; i + + ) { <NEWLINE> <INDENT> if ( s [ i ] >= <STRING> & & s [ i ] <= <STRING> ) <NEWLINE> <INDENT> s [ i ] += <STRING> - <STRING> ; <NEWLINE> <DEDENT> else if ( s [ i ] >= <STRING> & & s [ i ] <= <STRING> ) <NEWLINE> <INDENT> s [ i ] -= <STRING> - <STRING> ; <NEWLINE> <DEDENT> <DEDENT> } <NEWLINE> cout << s << endl ; <NEWLINE> <DEDENT> } <NEWLINE>
using namespace std ; <NEWLINE> <NL> typedef long long ll ; <NEWLINE> <NL> int main ( ) { <NEWLINE> <INDENT> string str ; getline ( cin , str ) ; <NEWLINE> for ( int i = 0 ; i < str . size ( ) ; + + i ) { <NEWLINE> <INDENT> char c = str [ i ] ; <NEWLINE> if ( <STRING> <= c & & c <= <STRING> ) cout << ( char ) ( c - <STRING> + <STRING> ) ; <NEWLINE> else if ( <STRING> <= c & & c <= <STRING> ) cout << ( char ) ( c - <STRING> + <STRING> ) ; <NEWLINE> else cout << c ; <NEWLINE> <DEDENT> } <NEWLINE> cout << endl ; <NEWLINE> <DEDENT> } <NEWLINE>
s = input ( ) <NEWLINE> p = input ( ) <NEWLINE> print ( <STRING> if p in s + s else <STRING> ) <NEWLINE>
z = <STRING> <NEWLINE> for x in raw_input ( ) : <NEWLINE> <INDENT> if x . islower ( ) : <NEWLINE> <INDENT> z += x . upper ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> z += x . lower ( ) , <NEWLINE> <NL> <DEDENT> <DEDENT> print z <NEWLINE>
print ( input . swapcase ( ) ) <NEWLINE>
for c in input ( ) : <NEWLINE> <INDENT> if c . islower ( ) : <NEWLINE> <INDENT> s += c . upper ( ) <NEWLINE> <DEDENT> elif c . isupper ( ) : <NEWLINE> <INDENT> s += c . lower ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s += c <NEWLINE> <DEDENT> <DEDENT> print ( s ) <NEWLINE>
import sys <NEWLINE> str = raw_input ( ) <NEWLINE> for a in list ( str ) : <NEWLINE> <INDENT> if a . islower ( ) : <NEWLINE> <INDENT> sys . stdout . write ( a . upper ( ) ) <NEWLINE> <DEDENT> elif a . isupper ( ) : <NEWLINE> <INDENT> sys . stdout . write ( a . lower ( ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> sys . stdout . write ( a ) <NEWLINE> <DEDENT> <DEDENT>
tr_in = input ( ) <NEWLINE> print ( str_in . swapcase ( ) ) <NEWLINE>
print input ( ) . strip ( <STRING> ) . swapcase ( ) <NEWLINE>
a = [ str ( i ) for i in range ( <STRING> ) ] <NEWLINE> a . upper ( ) <NEWLINE>
Import sys <NEWLINE> my_str = input ( ) <NEWLINE> <NL> for i in range ( len ( my_str ) ) : <NEWLINE> <INDENT> if <STRING> <= my_str [ i ] <= <STRING> : <NEWLINE> <INDENT> sys . stdout . write ( my_str [ i ] . upper ( ) , end = <STRING> ) <NEWLINE> <DEDENT> elif <STRING> <= my_str [ i ] <= <STRING> : <NEWLINE> <INDENT> sys . stdout . write ( my_str [ i ] . lower ( ) , end = <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> sys . stdout . write ( my_str [ i ] , end = <STRING> ) <NEWLINE> <DEDENT> <DEDENT> sys . stdout . write ( <STRING> ) <NEWLINE>
A = input ( ) <NEWLINE> upper ( A [ 0 ] ) <NEWLINE> for i in range ( len ( A ) : <NEWLINE> <INDENT> if i > 0 : <NEWLINE> <INDENT> lower ( A [ i ] ) <NEWLINE> <DEDENT> <DEDENT> print ( A ) <NEWLINE>
import sys <NEWLINE> <NL> for line in sys . stdin : <NEWLINE> <INDENT> print line . swapcase ( ) <NEWLINE> <DEDENT>
print ( swapcase ( input ( ) ) ) <NEWLINE>
print ( input ( ) . swapcase ( ) ) <NEWLINE> <NL> s = input ( ) <NEWLINE> <NL> for c in s : <NEWLINE> <INDENT> if c . islower ( ) : <NEWLINE> <INDENT> print ( c . upper ( ) , end = <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( c . lower ( ) , end = <STRING> ) <NEWLINE> <DEDENT> <DEDENT> print ( ) <NEWLINE>
words = input ( ) . split ( <STRING> ) <NEWLINE> for word in words : <NEWLINE> <INDENT> for w in word : <NEWLINE> <INDENT> if w . isalpha == True : <NEWLINE> <INDENT> if w . isupper ( ) == True : <NEWLINE> <INDENT> w . lower ( ) <NEWLINE> elif w . islower == True : <NEWLINE> <INDENT> w . upper ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> . join ( words ) ) <NEWLINE> <NL>
text = input ( ) <NEWLINE> <NL> for i in range ( len ( text ) ) : <NEWLINE> <INDENT> code = ord ( text [ i ] ) <NEWLINE> if ord ( <STRING> ) <= code <= ord ( <STRING> ) : <NEWLINE> <INDENT> result += chr ( code + 32 ) <NEWLINE> <DEDENT> elif ord ( <STRING> ) <= code <= ord ( <STRING> ) : <NEWLINE> <INDENT> result += chr ( code - 32 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> result += chr ( code ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( result ) <NEWLINE>
while True : <NEWLINE> <INDENT> x = list ( input ( ) ) <NEWLINE> if x == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> sum = 0 <NEWLINE> for i in range ( len ( x ) ) : <NEWLINE> <INDENT> sum += int ( x [ i ] ) <NEWLINE> <DEDENT> print ( sum ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> x = str ( raw_input ( ) ) <NEWLINE> if x == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> sum = 0 <NEWLINE> for i in range ( len ( x ) ) : <NEWLINE> <INDENT> sum += int ( x [ i ] ) <NEWLINE> <DEDENT> print sum <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> num = input ( ) <NEWLINE> <NL> print = sum ( map ( int , list ( str ( num ) ) ) ) <NEWLINE> if num == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT>
print ( sum ( [ int ( x [ i ] ) for i in range ( len ( x ) ) ] ) ) <NEWLINE> <NL>
<COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> using namespace std ; <NEWLINE> <NL> char init_str [ MAXSIZE ] = { } ; <NEWLINE> <NL> <NL> int main ( ) <NEWLINE> { <NEWLINE> <INDENT> char str [ MAXSIZE ] ; <NEWLINE> int sum ; <NEWLINE> <NL> while ( 1 ) { <NEWLINE> <INDENT> strcpy ( str , init_str ) ; <NEWLINE> scanf ( <STRING> , & str ) ; <NEWLINE> if ( ( int ) ( str [ 0 ] - <STRING> ) != 0 ) { <NEWLINE> <INDENT> sum = 0 ; <NEWLINE> for ( int i = 0 ; ( i < MAXSIZE & & ( str [ i ] != <STRING> ) ) ; i + + ) { <NEWLINE> <INDENT> sum += ( int ) ( str [ i ] - <STRING> ) ; <NEWLINE> <DEDENT> } <NEWLINE> cout << sum << endl ; <NEWLINE> <DEDENT> } <NEWLINE> else break ; <NEWLINE> <DEDENT> } <NEWLINE> return 0 ; <NEWLINE> <DEDENT> } <NEWLINE>
while True : <NEWLINE> <INDENT> data = int ( input ( ) ) <NEWLINE> if data == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> sum == 0 <NEWLINE> while <NEWLINE> <DEDENT>
x = map ( input ( int , list ( x ) ) <NEWLINE> if 0 != x [ 0 ] : <NEWLINE> <INDENT> print sum ( x ) <NEWLINE> <DEDENT>
<COMMENT> <NL> while ( 1 ) : <NEWLINE> <INDENT> n = str ( input ( ) ) <NEWLINE> <NL> if n : <NEWLINE> <INDENT> ans = 0 <NEWLINE> for x in n : <NEWLINE> <INDENT> ans += int ( x ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT>
while True : <NEWLINE> <INDENT> data = input ( ) <NEWLINE> if data [ 0 ] == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> print ( sum ( [ int ( i ) for i in data ] ) ) <NEWLINE> <NL> <DEDENT> for str in iter ( input , <STRING> ) : <NEWLINE> <INDENT> print ( sum ( int ( c ) for c in str ) ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> x = input ( ) <NEWLINE> if x == 0 : <NEWLINE> <INDENT> quit ( ) <NEWLINE> <NL> <DEDENT> print ( sum ( [ int ( _ ) for _ in str ( x ) ] ) ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> input = list ( map ( int , list ( input ( ) ) ) ) <NEWLINE> if input == [ 0 ] : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( sum ( input ) ) <NEWLINE> <DEDENT> <DEDENT>
while 1 : <NEWLINE> <INDENT> x = input ( ) <NEWLINE> if x [ 0 ] == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> print ( sum ( int ( i ) for i in x ) ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> n = sum ( list ( map ( int , list ( input ( ) ) ) ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> print ( n ) <NEWLINE> <DEDENT>
<INDENT> while 1 : <NEWLINE> <INDENT> x = sum ( map ( int , list ( input ( ) ) ) ) <NEWLINE> if x == 0 : break <NEWLINE> print ( x ) <NEWLINE> <DEDENT> <DEDENT>
while True : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> if s == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> a = 0 <NEWLINE> for i in s : <NEWLINE> <INDENT> a += int ( s [ i ] ) <NEWLINE> <DEDENT> print ( a ) <NEWLINE> <NL> <DEDENT>
list1 = [ ] <NEWLINE> while True : <NEWLINE> <INDENT> x = str ( input ( ) ) <NEWLINE> if x == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in x : <NEWLINE> <INDENT> result += int ( i ) <NEWLINE> list1 . append ( result ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> sum ( list1 ) <NEWLINE>
while True : <NEWLINE> <INDENT> num = str ( input ( ) ) <NEWLINE> if ( num == 0 ) : break <NEWLINE> ret = 0 <NEWLINE> for i in num : <NEWLINE> <INDENT> ret += int ( i ) <NEWLINE> <DEDENT> print ( ret ) <NEWLINE> <DEDENT>
<COMMENT> <NL> using namespace std ; <NEWLINE> int main ( int argc , char const * argv [ ] ) <NEWLINE> { <NEWLINE> <INDENT> string s ; <NEWLINE> while ( cin >> s , s != <STRING> ) { <NEWLINE> <INDENT> int sum = 0 ; <NEWLINE> for ( int i = 0 ; i < s . size ( ) ; i + + ) sum += s [ i ] - <STRING> ; <NEWLINE> <DEDENT> cout << sum << endl ; <NEWLINE> } <NEWLINE> return 0 ; <NEWLINE> <DEDENT> } <NEWLINE>
while 1 : <NEWLINE> <INDENT> x = [ int ( i ) for i in input ( ) ] <NEWLINE> if x == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> print ( sum ( list ( x ) ) ) <NEWLINE> <DEDENT>
a = [ ] <NEWLINE> while True : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> a . append ( n ) <NEWLINE> <NL> <DEDENT> for i in range ( len ( a ) ) : <NEWLINE> <INDENT> b = list ( str ( a [ i ] ) ) <NEWLINE> sum = 0 <NEWLINE> for j in b : <NEWLINE> <INDENT> sum += int ( j ) <NEWLINE> <DEDENT> print ( sum ) ) ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> x = input ( ) <NEWLINE> if x == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> print ( sum ( int ( z ) for z in x ) ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> x = input ( ) <NEWLINE> if x == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> ns = [ ] <NEWLINE> for n in x : <NEWLINE> ns . append ( int ( n ) ) <NEWLINE> print ( sum ( ns ) ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> table = str ( input ( ) ) <NEWLINE> if table [ 0 ] == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> print ( sum ( int ( num ) for num in table ( num ) ) ) <NEWLINE> <NL> <DEDENT>
a = 0 <NEWLINE> <NL> while True : <NEWLINE> <INDENT> z = str ( input ( ) ) <NEWLINE> if z == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for i in z : <NEWLINE> <INDENT> k = int ( i ) <NEWLINE> a += k <NEWLINE> <DEDENT> print ( a ) <NEWLINE> a = 0 <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> n = list ( map ( int , input ( ) ) ) <NEWLINE> if n [ 0 ] == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( n . sum ( ) ) <NEWLINE> <DEDENT> <DEDENT>
while True : <NEWLINE> <INDENT> a = 0 <NEWLINE> data = input ( ) <NEWLINE> if data == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> a += data <NEWLINE> <DEDENT> print ( a ) <NEWLINE>
while True : <NEWLINE> <INDENT> data = int ( input ( ) ) <NEWLINE> if data == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> print ( sum ( [ int ( i ) for i in data ] ) ) <NEWLINE> <DEDENT>
go = 1 <NEWLINE> while go == 1 : <NEWLINE> <INDENT> a = str ( input ( ) ) <NEWLINE> alist = list ( a ) <NEWLINE> if a == 0 : <NEWLINE> <INDENT> go = 0 <NEWLINE> exit <NEWLINE> <DEDENT> sum = 0 <NEWLINE> for i in alist : <NEWLINE> <INDENT> i = int ( i ) <NEWLINE> sum += i <NEWLINE> <DEDENT> if go == 1 : <NEWLINE> <INDENT> print ( sum ) <NEWLINE> <DEDENT> <DEDENT>
while True : <NEWLINE> <INDENT> n = input ( ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> s = list ( n ) <NEWLINE> a = [ int ( i ) for i in s ] <NEWLINE> print ( sum ( a ) ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> x = input ( ) <NEWLINE> if x == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> sum = 0 <NEWLINE> while x != 0 : <NEWLINE> <INDENT> sum += x % 10 <NEWLINE> x = x // 10 <NEWLINE> <NL> <DEDENT> print ( sum ) <NEWLINE> <DEDENT>
while ( True ) : <NEWLINE> <INDENT> x = 0 <NEWLINE> for i in input ( ) : <NEWLINE> <INDENT> x += int ( i ) <NEWLINE> <DEDENT> print ( x ) <NEWLINE> <DEDENT>
while 1 : <NEWLINE> <INDENT> n = input ( ) <NEWLINE> if int ( n ) == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> sum = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> sum += int ( i ) <NEWLINE> <DEDENT> print ( sum ) <NEWLINE> <DEDENT>
while 1 : <NEWLINE> <INDENT> n = raw_input ( ) <NEWLINE> if x == <STRING> : break ; <NEWLINE> print reduce ( lambda x , y : x + int ( y ) , n , 0 ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> a = raw_input ( ) <NEWLINE> if a == 0 : break <NEWLINE> sum ( [ int ( i ) for i in a ] ) <NEWLINE> <DEDENT>
<COMMENT> <NL> while True : <NEWLINE> <INDENT> kazu = [ int ( x ) for x in input ( ) ] <NEWLINE> if kazu == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> print ( <STRING> . format ( sum ( kazu ) ) ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> value = [ int ( x ) for x in raw_input ( ) . split ( ) ] <NEWLINE> if value == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> print ( sum ( value ) ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> x = input ( ) <NEWLINE> if x == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> print ( sum ( int ( s ) for s in x ) ) <NEWLINE> <DEDENT>
while ( 1 ) : <NEWLINE> <INDENT> word = input ( ) <NEWLINE> if ( word = <STRING> ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> result = 0 <NEWLINE> for i in word : <NEWLINE> <INDENT> result += int ( i ) <NEWLINE> <DEDENT> print ( result ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> a = input ( ) <NEWLINE> if a == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> print ( sum ( [ int ( b ) for b in list ( a ) ] ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> x = input ( ) <NEWLINE> if x = <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> cnt = 0 <NEWLINE> for i in x : <NEWLINE> <INDENT> num = int ( i ) <NEWLINE> cnt += num <NEWLINE> <DEDENT> print ( cnt ) <NEWLINE> <DEDENT>
a = True <NEWLINE> while a : <NEWLINE> <INDENT> l = map ( int , list ( input ( ) ) ) <NEWLINE> if l [ 0 ] != 0 : <NEWLINE> <INDENT> print ( sum ( l ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a = False <NEWLINE> <DEDENT> <DEDENT>
True : <NEWLINE> <INDENT> input = raw_input ( ) <NEWLINE> if input == <STRING> : break <NEWLINE> print sum ( map ( int , input ) ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> x = int ( raw_input ( ) ) <NEWLINE> if x == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> sum = 0 <NEWLINE> for i in range ( len ( x ) ) : <NEWLINE> <INDENT> sum += x [ i ] <NEWLINE> <DEDENT> print sum <NEWLINE> <DEDENT>
lst = [ ] <NEWLINE> while True : <NEWLINE> <INDENT> lst . append ( input ( ) ) <NEWLINE> if 0 in lst : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> for i in lst : <NEWLINE> <INDENT> sum = 0 <NEWLINE> for j in range ( len ( i ) ) : <NEWLINE> <INDENT> sum += i [ j ] <NEWLINE> <DEDENT> print ( sum ) <NEWLINE> <DEDENT>
while 1 : <NEWLINE> <INDENT> a = int ( input ( ) ) <NEWLINE> if a == 0 : <NEWLINE> break <NEWLINE> a = str ( a ) <NEWLINE> print ( [ a [ i ] for i in range ( len ( a ) ) ] ) <NEWLINE> <DEDENT>
while 1 : <NEWLINE> <INDENT> input = raw_input ( ) <NEWLINE> num = len ( input ) <NEWLINE> input = int ( input ) <NEWLINE> <NL> count = 0 <NEWLINE> for i in range ( num , 0 , - 1 ) : <NEWLINE> <INDENT> value = int ( input / 10 ** ( i - 1 ) ) <NEWLINE> input -= value * 10 ** ( i - 1 ) <NEWLINE> count += value <NEWLINE> <NL> <DEDENT> print ( count ) <NEWLINE> <DEDENT>
import sys <NEWLINE> while True : <NEWLINE> <INDENT> x = input ( ) <NEWLINE> if x == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> sum = 0 <NEWLINE> for i in range ( len ( x ) ) : <NEWLINE> sum += int ( x [ i ] ) <NEWLINE> <NL> <DEDENT> print ( sum ) <NEWLINE> <DEDENT>
while 1 : <NEWLINE> <INDENT> x = input ( ) <NEWLINE> if x == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> print sum ( map ( int , x ) ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <NL> <INDENT> x = input ( ) <NEWLINE> <NL> if x == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> length = len ( x ) <NEWLINE> tot = 0 <NEWLINE> <NL> for i in range ( length ) : <NEWLINE> <INDENT> tot += int ( x [ i : i + 1 ] ) <NEWLINE> <DEDENT> print ( tot ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> Target = <STRING> <NEWLINE> for line in sys . stdin . readlines : <NEWLINE> <INDENT> Target += line . rstrip ( <STRING> ) <NEWLINE> <DEDENT> for i in range ( 26 ) : <NEWLINE> <INDENT> print ( chr ( i + 97 ) , <STRING> , Target . count ( chr ( i + 97 ) ) ) <NEWLINE> <DEDENT>
sentence = <STRING> <NEWLINE> while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> sentence += input ( ) . lower ( ) <NEWLINE> except : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for i in range ( ord ( <STRING> ) , ord ( <STRING> ) + 1 ) : <NEWLINE> <INDENT> print ( <STRING> . format ( chr ( i ) , sentence . count ( chr ( i ) ) ) ) <NEWLINE> <DEDENT>
count = { } <COMMENT> <NEWLINE> for i in range ( 26 ) : <NEWLINE> <INDENT> count [ ( i ) ] = 0 <NEWLINE> <NL> <DEDENT> while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> text = raw_input ( ) <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for i in range ( len ( text ) ) : <NEWLINE> <INDENT> if ( ord ( text [ i ] ) >= ord ( <STRING> ) and ord ( text [ i ] ) <= ord ( <STRING> ) ) : <NEWLINE> <INDENT> count [ ( ord ( text [ i ] ) ) - ord ( <STRING> ) ] += 1 <NEWLINE> <DEDENT> if ( ord ( text [ i ] ) >= ord ( <STRING> ) and ord ( text [ i ] ) <= ord ( <STRING> ) ) : <NEWLINE> <INDENT> count [ ( ord ( text [ i ] ) ) - ord ( <STRING> ) ] += 1 <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> for i in range ( 26 ) : <NEWLINE> <INDENT> print <STRING> % ( unichr ( i + ord ( <STRING> ) ) , count [ ( i ) ] ) <NEWLINE> <DEDENT>
count = [ 0 for i in range ( 26 ) ] <NEWLINE> alpha = <STRING> <NEWLINE> while True : <NEWLINE> <INDENT> sentence = input ( ) <NEWLINE> if sentence == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for letter in sentence : <NEWLINE> <INDENT> letter . lower ( ) <NEWLINE> num = 0 <NEWLINE> for j in alpha : <NEWLINE> <INDENT> if letter == j : <NEWLINE> <INDENT> count [ num ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> num += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> num = 0 <NEWLINE> for k in alpha : <NEWLINE> <INDENT> print ( k + <STRING> + str ( count [ num ] ) ) <NEWLINE> num += 1 <NEWLINE> <DEDENT>
import string <NEWLINE> <NL> count = { x : 0 for x in string . ascii_lowercase } <NEWLINE> lines = <STRING> <NEWLINE> <NL> while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> lines += input ( ) . lower ( ) <NEWLINE> <DEDENT> except EOFError : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> for c in lines : <NEWLINE> <INDENT> if <STRING> <= c <= <STRING> : <NEWLINE> <INDENT> count [ c ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> for key in string . ascii_lowercase : <NEWLINE> <INDENT> print ( <STRING> . format ( key , count [ key ] ) ) <NEWLINE> <DEDENT>
Sp = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 ] <NEWLINE> Hu = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 ] <NEWLINE> Cr = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 ] <NEWLINE> Dy = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 ] <NEWLINE> <NL> num = int ( input ( ) ) <NEWLINE> i = 0 <NEWLINE> <NL> while i < num : <NEWLINE> <INDENT> suit , n = raw_input ( ) . split ( ) <NEWLINE> n = int ( n ) <NEWLINE> if suit == <STRING> : <NEWLINE> <INDENT> Sp [ n - 1 ] = 0 <NEWLINE> <DEDENT> elif suit == <STRING> : <NEWLINE> <INDENT> Hu [ n - 1 ] = 0 <NEWLINE> <DEDENT> elif suit == <STRING> : <NEWLINE> <INDENT> Cr [ n - 1 ] = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> Dy [ n - 1 ] = 0 <NEWLINE> <DEDENT> i += 1 <NEWLINE> <NL> <DEDENT> for i in Sp : <NEWLINE> <INDENT> if i != 0 : <NEWLINE> <INDENT> print <STRING> , i <NEWLINE> <NL> <DEDENT> <DEDENT> for i in Hu : <NEWLINE> <INDENT> if i != 0 : <NEWLINE> <INDENT> print <STRING> , i <NEWLINE> <NL> <DEDENT> <DEDENT> for i in Cr : <NEWLINE> <INDENT> if i != 0 : <NEWLINE> <INDENT> print <STRING> , i <NEWLINE> <NL> <DEDENT> <DEDENT> for i in Dy : <NEWLINE> <INDENT> if i != 0 : <NEWLINE> <INDENT> print <STRING> , i <NEWLINE> <NL> <DEDENT> <DEDENT>
using namespace std ; <NEWLINE> <NL> int main ( void ) { <NEWLINE> <INDENT> char c ; <NEWLINE> int num [ 26 ] = { } ; <NEWLINE> while ( scanf ( <STRING> , & c ) != EOF ) { <NEWLINE> <INDENT> c = tolower ( c ) ; <NEWLINE> if ( c >= <STRING> & & c <= <STRING> ) num [ c - <STRING> ] + + ; <NEWLINE> <DEDENT> } <NEWLINE> for ( int i = 0 ; i < 26 ; i + + ) { <NEWLINE> <INDENT> printf ( <STRING> , i + <STRING> , num [ i ] ) ; <NEWLINE> <DEDENT> } <NEWLINE> return 0 ; <NEWLINE> <DEDENT> } <NEWLINE>
<COMMENT> <NL> import sys <NEWLINE> <NL> charList = list ( <STRING> ) <NEWLINE> lines = sys . stdin . readlines ( ) <NEWLINE> totalSentence = [ ] <NEWLINE> for s in range ( lines ) : <NEWLINE> <INDENT> sentence = list ( input ( ) . rstrip ( ) . lower ( ) ) <NEWLINE> <COMMENT> <NL> for c in range ( sentence ) : <NEWLINE> <INDENT> totalSentence . append ( c ) <NEWLINE> <NL> <DEDENT> <DEDENT> for char in charList : <NEWLINE> <INDENT> count = 0 <NEWLINE> for i in range ( len ( totalSentence ) ) : <NEWLINE> <INDENT> if totalSentence [ i ] == char : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> print ( char + <STRING> + str ( count ) ) <NEWLINE> <NL> <DEDENT>
import string <NEWLINE> count = { x : 0 for x in string . ascii_lowercase } <NEWLINE> <NL> s = input ( ) . lower ( ) <NEWLINE> <NL> for c in s : <NEWLINE> <INDENT> if <STRING> <= c <= <STRING> : <NEWLINE> <INDENT> count [ c ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> for key , num in count : <NEWLINE> <INDENT> print ( <STRING> . format ( key , num ) ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> s = <STRING> <NEWLINE> for line in sys . stdin : <NEWLINE> <INDENT> s . append ( line ) <NEWLINE> <DEDENT> s . lower ( ) <NEWLINE> for str in list ( <STRING> ) : <NEWLINE> <INDENT> print ( * [ str , <STRING> , s . count ( str ) ] ) <NEWLINE> <DEDENT>
count = { } <COMMENT> <NEWLINE> for i in range ( 26 ) : <NEWLINE> <INDENT> count [ ( i ) ] = 0 <NEWLINE> <NL> <DEDENT> text = [ ] <NEWLINE> while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> text = raw_input ( ) <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for i in range ( len ( text ) ) : <NEWLINE> <INDENT> if ( ord ( text [ i ] ) >= ord ( <STRING> ) and ord ( text [ i ] ) <= ord ( <STRING> ) ) : <NEWLINE> <INDENT> count [ ( ord ( text [ i ] ) ) - ord ( <STRING> ) ] += 1 <NEWLINE> <DEDENT> if ( ord ( text [ i ] ) >= ord ( <STRING> ) and ord ( text [ i ] ) <= ord ( <STRING> ) ) : <NEWLINE> <INDENT> count [ ( ord ( text [ i ] ) ) - ord ( <STRING> ) ] += 1 <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> for i in range ( 26 ) : <NEWLINE> <INDENT> print <STRING> % ( unichr ( i + ord ( <STRING> ) ) , count [ ( i ) ] ) <NEWLINE> <DEDENT>
a = { x : 0 for x in range ( ord ( <STRING> ) , ord ( <STRING> ) + 1 ) } <NEWLINE> <NL> while True : <NEWLINE> <INDENT> text = input ( ) <NEWLINE> if text == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for x in text : <NEWLINE> <INDENT> a [ ord ( x . lower ( ) ) ] += 1 <NEWLINE> <NL> <DEDENT> for x in range ( ord ( <STRING> ) , ord ( <STRING> ) + 1 ) : <NEWLINE> <INDENT> print ( chr ( x ) , <STRING> , a [ x ] ) <NEWLINE> <DEDENT> <DEDENT>
alpha = ( chr ( i ) for i in range ( 97 , 97 + 26 ) ) <NEWLINE> l = [ ] <NEWLINE> while True : <NEWLINE> <INDENT> s = list ( input ( ) . lower ( ) ) <NEWLINE> if not s : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> l += s <NEWLINE> <DEDENT> count = { a : l . count ( a ) for a in alpha } <NEWLINE> for k in sorted ( count ) : <NEWLINE> <INDENT> print ( <STRING> % ( k , count [ k ] ) ) <NEWLINE> <DEDENT>
uppers = <STRING> <NEWLINE> lowers = <STRING> <NEWLINE> s = [ ] <NEWLINE> while len ( s ) < 1200 : <NEWLINE> <INDENT> s += list ( input ( ) ) <NEWLINE> <DEDENT> for i in range ( 26 ) : <NEWLINE> <INDENT> print ( lowers [ i ] + <STRING> + str ( s . count ( uppers [ i ] ) + s . count ( lowers [ i ] ) ) ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> letter = <STRING> <NEWLINE> While True : <NEWLINE> <INDENT> table = [ 0 ] * 26 <NEWLINE> try : <NEWLINE> <INDENT> input_str = input ( ) <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for A in input_str : <NEWLINE> <INDENT> index = 0 <NEWLINE> for B in letter : <NEWLINE> <INDENT> if A == B or A == B . upper ( ) : <NEWLINE> <INDENT> table [ index ] += 1 <NEWLINE> break <NEWLINE> index += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for i in range ( len ( letter ) ) : <NEWLINE> <INDENT> print ( <STRING> % ( letter [ i ] , table [ i ] ) ) <NEWLINE> <NL> <DEDENT> <DEDENT>
import sys <NEWLINE> <NL> inp = sys . stdin ( ) <NEWLINE> counter = { } <NEWLINE> <NL> for text in inp : <NEWLINE> <INDENT> for a in text : <NEWLINE> <INDENT> a = a . lower ( ) <NEWLINE> counter [ a ] = counter . get ( a , 0 ) + 1 <NEWLINE> <NL> <DEDENT> <DEDENT> for x in range ( 26 ) : <NEWLINE> <INDENT> a = chr ( ord ( <STRING> ) + x ) <NEWLINE> print ( <STRING> . format ( a , counter . get ( a , 0 ) ) , sep = <STRING> ) <NEWLINE> <DEDENT>
import sys <NEWLINE> import io <NEWLINE> import re <NEWLINE> az = [ <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> sum_az = [ 0 for x in range ( 26 ) ] <NEWLINE> <NL> for x in sys . stdin . read ( ) . lower ( ) <NEWLINE> <INDENT> for i in range ( 26 ) : <NEWLINE> <INDENT> if x == az [ i ] : <NEWLINE> <INDENT> sum_az [ i ] += 1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> for i in range ( 26 ) : <NEWLINE> <INDENT> print ( <STRING> % ( az [ i ] , sum_az [ i ] ) ) <NEWLINE> <DEDENT>
a = <STRING> <NEWLINE> while 1 : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> b += input ( ) . lower ( ) <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> for i in range ( 26 ) : <NEWLINE> <INDENT> print ( a [ i ] , <STRING> , b . count ( a [ i ] ) ) <NEWLINE> <DEDENT>
dic = [ [ <STRING> , 0 ] , [ <STRING> , 0 ] , [ <STRING> , 0 ] , [ <STRING> , 0 ] , [ <STRING> , 0 ] , [ <STRING> , 0 ] , [ <STRING> , 0 ] , [ <STRING> , 0 ] , [ <STRING> , 0 ] , [ <STRING> , 0 ] , [ <STRING> , 0 ] , [ <STRING> , 0 ] , [ <STRING> , 0 ] , [ <STRING> , 0 ] , [ <STRING> , 0 ] , [ <STRING> , 0 ] , [ <STRING> , 0 ] , [ <STRING> , 0 ] , [ <STRING> , 0 ] , [ <STRING> , 0 ] , [ <STRING> , 0 ] , [ <STRING> , 0 ] , [ <STRING> , 0 ] , [ <STRING> , 0 ] , [ <STRING> , 0 ] , [ <STRING> , 0 ] ] <NEWLINE> while True : <NEWLINE> <INDENT> s = raw_input ( ) <NEWLINE> if s == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for i in s : <NEWLINE> <INDENT> for j in range ( 0 , 26 ) : <NEWLINE> <INDENT> if dic [ j ] [ 0 ] == i . lower ( ) : <NEWLINE> <INDENT> dic [ j ] [ 1 ] += 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for i in range ( 0 , 26 ) : <NEWLINE> <INDENT> print dic [ i ] [ 0 ] , <STRING> , dic [ i ] [ 1 ] <NEWLINE> <DEDENT>
import string <NEWLINE> <NL> alphabets = { k : 0 for k in string . ascii_lowercase } <NEWLINE> <NL> for c in input ( ) . lower ( ) : <NEWLINE> <INDENT> if c == <STRING> : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> alphabets [ c ] += 1 <NEWLINE> <NL> <DEDENT> for c , n in sorted ( alphabets . items ( ) ) : <NEWLINE> <INDENT> print ( <STRING> . format ( c , n ) ) <NEWLINE> <DEDENT>
import sys <NEWLINE> str = [ ] <NEWLINE> for line in sys . stdin : <NEWLINE> <INDENT> str . append ( line ) <NEWLINE> <DEDENT> s = <STRING> . join ( str ) . lower <NEWLINE> s = list ( s ) <NEWLINE> for i in range ( 97 , 97 + 26 ) : <NEWLINE> <INDENT> count = 0 <NEWLINE> for j in s : <NEWLINE> <INDENT> if chr ( i ) == j : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> print ( chr ( i ) , <STRING> , count ) <NEWLINE> <DEDENT>
count = { } <NEWLINE> from string import ascii_lowercase <NEWLINE> for c in ascii_lowercase : <NEWLINE> <INDENT> count [ c ] = 0 <NEWLINE> <DEDENT> str = input ( ) <NEWLINE> while str : <NEWLINE> <INDENT> sum = 0 <NEWLINE> for c in str : <NEWLINE> <INDENT> if c . isalpha ( ) : <NEWLINE> <INDENT> count [ c . lower ( ) ] += 1 <NEWLINE> <DEDENT> <DEDENT> str = input ( ) <NEWLINE> <DEDENT> for c in ascii_lowercase : <NEWLINE> <INDENT> print ( c , <STRING> , count [ c ] ) <NEWLINE> <DEDENT>
alphabet = <STRING> <NEWLINE> dictionary = { } <NEWLINE> for character in alphabet : <NEWLINE> <INDENT> dictionary [ character ] = 0 <NEWLINE> <NL> <DEDENT> for character in raw_input ( ) : <NEWLINE> <INDENT> if character . lower ( ) in dictionary : <NEWLINE> <INDENT> dictionary [ character . lower ( ) ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> for character in alphabet : <NEWLINE> <INDENT> print ( character + <STRING> + dictionary [ character ] ) <NEWLINE> <DEDENT>
a_dict = { chr ( a ) : 0 for a in range ( 97 , 123 ) } <NEWLINE> while True : <NEWLINE> <INDENT> S = input ( ) . lower ( ) <NEWLINE> if not S : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for c in S : <NEWLINE> <INDENT> if c in a_dict : <NEWLINE> <INDENT> a_dict [ c ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for k , v in a_dict . items ( ) : <NEWLINE> <INDENT> print ( <STRING> . format ( k , v ) ) <NEWLINE> <NL> <DEDENT>
import sys <NEWLINE> <NL> alist = list ( <STRING> ) <NEWLINE> r = { } <NEWLINE> for al in alist : <NEWLINE> <INDENT> r [ al ] = 0 <NEWLINE> <NL> <DEDENT> line = sys . stdin . read ( ) . lower <NEWLINE> <NL> for i in range ( len ( line ) ) : <NEWLINE> <INDENT> if line [ i ] in r . keys ( ) : <NEWLINE> <INDENT> r [ line [ i ] ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> for k , v in r . items ( ) : <NEWLINE> <INDENT> print ( <STRING> . format ( k , v ) ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> string = str ( ) <NEWLINE> <NL> for line in sys . stdin : <NEWLINE> <INDENT> string += line . lower ( ) <NEWLINE> <NL> <DEDENT> string = input ( ) . lower ( ) <NEWLINE> alph = [ <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> <NL> for letter in alph : <NEWLINE> <INDENT> sum = 0 <NEWLINE> n = - 1 <NEWLINE> while True : <NEWLINE> <INDENT> n = string . find ( letter , n + 1 ) <NEWLINE> if n == - 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> sum += 1 <NEWLINE> <DEDENT> print ( <STRING> . format ( letter , sum ) ) <NEWLINE> <DEDENT>
table2 = { n : 0 for n in <STRING> } <NEWLINE> while True : <NEWLINE> <INDENT> x = input ( ) <NEWLINE> if not x : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for i in x . lower ( ) : <NEWLINE> <INDENT> if i in table2 : <NEWLINE> <INDENT> table2 [ i ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for m , n in table2 . items ( ) : <NEWLINE> <INDENT> print ( <STRING> . format ( m , n ) ) <NEWLINE> <DEDENT>
a = raw_input ( ) <NEWLINE> d = { } <NEWLINE> for i in <STRING> : <NEWLINE> <INDENT> d [ i ] = 0 <NEWLINE> <DEDENT> for i in a : <NEWLINE> <INDENT> d [ i ] += 1 <NEWLINE> <DEDENT> for i in <STRING> : <NEWLINE> <INDENT> print i , <STRING> , d [ i ] <NEWLINE> <DEDENT>
s = [ int ( 0 ) for i in range ( 26 ) ] <NEWLINE> for s in input ( ) : <NEWLINE> <INDENT> x = input ( ) <NEWLINE> if x [ len ( list ( x ) ) - 1 ] == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for i in range ( len ( list ( x ) ) ) : <NEWLINE> <INDENT> if 97 <= ord ( list ( x ) [ i ] . lower ( ) ) <= 122 : <NEWLINE> <INDENT> s [ ord ( list ( x ) [ i ] . lower ( ) ) - 97 ] = s [ ord ( list ( x ) [ i ] . lower ( ) ) - 97 ] + 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for i in range ( 26 ) : <NEWLINE> <INDENT> print ( chr ( 97 + i ) , <STRING> , s [ i ] ) <NEWLINE> <DEDENT>
import string <NEWLINE> az = list ( string . ascii_lowercase ) <NEWLINE> li = [ 0 for a in range ( len ( az ) ) ] <NEWLINE> <NL> while True : <NEWLINE> <INDENT> a = raw_input ( ) <NEWLINE> try : <NEWLINE> <INDENT> if a != <STRING> : <NEWLINE> <INDENT> for b in list ( a ) : <NEWLINE> <INDENT> if b . lower ( ) in az : <NEWLINE> <INDENT> tmp = az . index ( b . lower ( ) ) <NEWLINE> li [ tmp ] = li [ tmp ] + 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> except : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> for c in range ( len ( az ) ) : <NEWLINE> <INDENT> print az [ c ] + <STRING> + str ( li [ c ] ) <NEWLINE> <DEDENT>
text = <STRING> <NEWLINE> while True : <NEWLINE> <INDENT> s = input ( ) . lower ( ) <NEWLINE> if s == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> text += s <NEWLINE> <DEDENT> for i in <STRING> : <NEWLINE> <INDENT> print ( i + <STRING> + str ( text . count ( i ) ) ) <NEWLINE> <COMMENT> <NL> <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> table = <STRING> <NEWLINE> <NL> sentence = sys . stdin . read ( ) <NEWLINE> sentence1 = str ( entence . lower ( ) ) <NEWLINE> for i in table : <NEWLINE> <INDENT> print ( i + <STRING> + str ( sentence1 . count ( i ) ) ) <NEWLINE> <DEDENT>
count = { } <NEWLINE> for i in range ( 97 , 97 + 26 ) : <NEWLINE> <INDENT> count [ chr ( i ) ] = 0 <NEWLINE> <NL> <DEDENT> text = [ ] <NEWLINE> text_out = <STRING> <NEWLINE> while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> text . append ( input ( ) ) <NEWLINE> <DEDENT> except EOFError : <NEWLINE> <INDENT> text_out = <STRING> . join ( text ) <NEWLINE> <NL> <DEDENT> <DEDENT> text_lower = text_out . lower ( ) <NEWLINE> <NL> for letter in text_lower : <NEWLINE> <INDENT> if letter in count : <NEWLINE> <INDENT> count [ letter ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> for x , y in sorted ( count . items ( ) ) : <NEWLINE> <INDENT> print ( <STRING> . format ( x , y ) ) <NEWLINE> <DEDENT>
sen = raw_input ( ) <NEWLINE> a = [ ] <NEWLINE> b = [ ] <NEWLINE> c = [ ] <NEWLINE> d = [ ] <NEWLINE> e = [ ] <NEWLINE> f = [ ] <NEWLINE> g = [ ] <NEWLINE> h = [ ] <NEWLINE> i = [ ] <NEWLINE> j = [ ] <NEWLINE> k = [ ] <NEWLINE> l = [ ] <NEWLINE> m = [ ] <NEWLINE> n = [ ] <NEWLINE> o = [ ] <NEWLINE> p = [ ] <NEWLINE> q = [ ] <NEWLINE> r = [ ] <NEWLINE> s = [ ] <NEWLINE> t = [ ] <NEWLINE> u = [ ] <NEWLINE> v = [ ] <NEWLINE> x = [ ] <NEWLINE> y = [ ] <NEWLINE> z = [ ] <NEWLINE> w = [ ] <NEWLINE> count = { <STRING> : a , <STRING> : b , <STRING> : c , <STRING> : d , <STRING> : e , <STRING> : f , <STRING> : g , <STRING> : h , <STRING> : i , <STRING> : j , <STRING> : k , <STRING> : l , <STRING> : m , <STRING> : n , <STRING> : o , <STRING> : p , <STRING> : q , <STRING> : r , <STRING> : s , <STRING> : t , <STRING> : u , <STRING> : v , <STRING> : w , <STRING> : x , <STRING> : y , <STRING> : z } <NEWLINE> for i in range ( len ( sen ) ) : <NEWLINE> <INDENT> if sen [ i ] . isalpha ( ) : <NEWLINE> <INDENT> count [ sen [ i ] . lower ( ) ] . append ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> for char in sorted ( count . keys ( ) ) : <NEWLINE> <INDENT> print ( <STRING> % ( char , len ( count [ char ] ) ) ) <NEWLINE> <DEDENT>
t = list ( raw_input ( ) . lower ( ) ) <NEWLINE> c = [ 0 for i in range ( 26 ) ] <NEWLINE> for i in range ( len ( t ) ) : <NEWLINE> <INDENT> c [ ord ( t [ i ] ) - ord ( <STRING> ) ] += 1 <NEWLINE> <DEDENT> for i in range ( 26 ) : <NEWLINE> <INDENT> print chr ( ord ( <STRING> ) + i ) , <STRING> , c [ i ] <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> import sys <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> text = str ( ) <NEWLINE> alphabets = <STRING> <NEWLINE> <NL> for line in sys . stdin ( ) : <NEWLINE> <INDENT> text += line . lower ( ) <NEWLINE> <NL> <DEDENT> for alphabet in alphabets : <NEWLINE> <INDENT> print ( <STRING> % ( alphabet , text . count ( alphabet ) ) ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <NL> import sys <NEWLINE> <NL> sents = [ ] <NEWLINE> for line in sys . stdin : <NEWLINE> <INDENT> sents . append ( input ( ) ) <NEWLINE> <NL> <DEDENT> dic = { chr ( x ) : 0 for x in range ( ord ( <STRING> ) , ord ( <STRING> ) + 1 ) } <NEWLINE> <NL> for sent in sents : <NEWLINE> <INDENT> for c in sent : <NEWLINE> <INDENT> x = c . lower ( ) <NEWLINE> if ord ( <STRING> ) <= ord ( x ) and ord ( x ) <= ord ( <STRING> ) : <NEWLINE> <INDENT> dic [ x ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for k , v in dic . items ( ) : <NEWLINE> <INDENT> print ( k + <STRING> + str ( v ) ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> array = <STRING> <NEWLINE> for line in sys . stdin : <NEWLINE> <INDENT> array += line <NEWLINE> <NL> <DEDENT> char = [ <STRING> for _ in range ( len ( array ) ) ] <NEWLINE> for i in range ( len ( array ) ) : <NEWLINE> <INDENT> char [ i ] = array [ i : i + 1 ] <NEWLINE> <NL> <DEDENT> count = [ 0 for _ in range ( 26 ) ] <NEWLINE> for c in char : <NEWLINE> <INDENT> for i in range ( 26 ) : <NEWLINE> <INDENT> if c == chr ( i + ord ( <STRING> ) ) or c == chr ( i + ord ( <STRING> ) ) : <NEWLINE> <INDENT> count [ i ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for i in range ( 26 ) : <NEWLINE> <INDENT> print ( <STRING> . format ( chr ( i + ord ( <STRING> ) ) , alp [ i ] ) ) <NEWLINE> <DEDENT>
import string <NEWLINE> text = <STRING> <NEWLINE> while True : <NEWLINE> <INDENT> text += input ( ) . lower ( ) <NEWLINE> for char in string . ascii_lowercase : <NEWLINE> <INDENT> print ( char , <STRING> , text . count ( char ) ) <NEWLINE> <NL> <DEDENT> <DEDENT>
word = [ chr ( i ) for i in range ( 97 , 97 + 26 ) ] <NEWLINE> word_number = [ ] <NEWLINE> line = <STRING> <NEWLINE> while ( 1 ) : <NEWLINE> <INDENT> temp_line = input ( ) <NEWLINE> line += temp_line <NEWLINE> if temp_line == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> for target in word : <NEWLINE> <INDENT> count = 0 <NEWLINE> for character in line : <NEWLINE> <INDENT> if character . lower ( ) == target : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> word_number . append ( count ) <NEWLINE> <NL> <DEDENT> for i in range ( 26 ) : <NEWLINE> <INDENT> print ( <STRING> . format ( word [ i ] , word_number [ i ] ) ) <NEWLINE> <DEDENT>
a = sorted ( raw_input ( ) . lower ( ) ) <NEWLINE> for i in range ( 97 , 123 ) : <NEWLINE> <INDENT> print <STRING> % ( chr ( i ) , a . count ( chr ( i ) ) ) <NEWLINE> <NL> <DEDENT>
from string import ascii_lowercase <NEWLINE> table = dict ( zip ( ascii_lowercase , [ 0 for _ in range ( len ( ascii_lowercase ) ) ] ) ) <NEWLINE> for s in input ( ) . split ( ) : <NEWLINE> <INDENT> for c in s : <NEWLINE> <INDENT> table [ c . lower ( ) ] += 1 <NEWLINE> <DEDENT> <DEDENT> for k , v in table . items ( ) : <NEWLINE> <INDENT> print ( <STRING> . format ( k , v ) ) <NEWLINE> <NL> <DEDENT>
alphabet = [ <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> cnt = 26 * [ 0 ] <NEWLINE> Input = <STRING> <NEWLINE> loop = True <NEWLINE> <NL> while loop : <NEWLINE> <INDENT> I = input ( ) <NEWLINE> if not I : <NEWLINE> <INDENT> loop = False <NEWLINE> <DEDENT> Input += I <NEWLINE> <NL> <DEDENT> for i1 in range ( len ( alphabet ) ) : <NEWLINE> <INDENT> for i2 in range ( len ( Input ) ) : <NEWLINE> <INDENT> if <STRING> <= Input [ i2 ] <= <STRING> : <NEWLINE> <INDENT> w = Input [ i2 ] . lower ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> w = Input [ i2 ] <NEWLINE> <DEDENT> if alphabet [ i1 ] == w : <NEWLINE> <INDENT> cnt [ i1 ] += 1 <NEWLINE> <DEDENT> <DEDENT> print ( alphabet [ i1 ] + <STRING> + str ( cnt [ i1 ] ) ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> a = sys . stdin . readline <NEWLINE> alphabet = <STRING> <NEWLINE> <NL> for i in alphabet : <NEWLINE> <INDENT> print ( i + <STRING> + str ( a . lower ( ) . count ( i ) ) ) <NEWLINE> <DEDENT>
import sys <NEWLINE> s = sys . stdin . readlines ( ) . lower ( ) <NEWLINE> for i in <STRING> : <NEWLINE> <INDENT> print ( i , <STRING> , s . count ( i ) ) <NEWLINE> <DEDENT>
from string import ascii_lowercase as letters <NEWLINE> <NL> data = <STRING> <NEWLINE> while True : <NEWLINE> <INDENT> temp = input ( ) <NEWLINE> if temp == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> data += temp . lower ( ) <NEWLINE> <DEDENT> <DEDENT> <STRING> <NEWLINE> print ( <STRING> ) <NEWLINE>
<NL> alphabet = [ 0 ] * 26 <NEWLINE> i = 0 ; <NEWLINE> for j in range ( 97 , 123 ) : <NEWLINE> <INDENT> alphabet [ i ] = chr ( j ) <NEWLINE> i += 1 <NEWLINE> <DEDENT> al_count = [ 0 ] * 26 <NEWLINE> while True : <NEWLINE> <INDENT> words = raw_input ( ) . lower ( ) . split ( ) <NEWLINE> for k in words : <NEWLINE> <INDENT> for l in list ( k ) : <NEWLINE> <INDENT> if l == <STRING> : <NEWLINE> <INDENT> al_count [ 0 ] += 1 <NEWLINE> <DEDENT> elif l == <STRING> : <NEWLINE> <INDENT> al_count [ 1 ] += 1 <NEWLINE> <DEDENT> elif l == <STRING> : <NEWLINE> <INDENT> al_count [ 2 ] += 1 <NEWLINE> <DEDENT> elif l == <STRING> : <NEWLINE> <INDENT> al_count [ 3 ] += 1 <NEWLINE> <DEDENT> elif l == <STRING> : <NEWLINE> <INDENT> al_count [ 4 ] += 1 <NEWLINE> <DEDENT> elif l == <STRING> : <NEWLINE> <INDENT> al_count [ 5 ] += 1 <NEWLINE> <DEDENT> elif l == <STRING> : <NEWLINE> <INDENT> al_count [ 6 ] += 1 <NEWLINE> <DEDENT> elif l == <STRING> : <NEWLINE> <INDENT> al_count [ 7 ] += 1 <NEWLINE> <DEDENT> elif l == <STRING> : <NEWLINE> <INDENT> al_count [ 8 ] += 1 <NEWLINE> <DEDENT> elif l == <STRING> : <NEWLINE> <INDENT> al_count [ 9 ] += 1 <NEWLINE> <DEDENT> elif l == <STRING> : <NEWLINE> <INDENT> al_count [ 10 ] += 1 <NEWLINE> <DEDENT> elif l == <STRING> : <NEWLINE> <INDENT> al_count [ 11 ] += 1 <NEWLINE> <DEDENT> elif l == <STRING> : <NEWLINE> <INDENT> al_count [ 12 ] += 1 <NEWLINE> <DEDENT> elif l == <STRING> : <NEWLINE> <INDENT> al_count [ 13 ] += 1 <NEWLINE> <DEDENT> elif l == <STRING> : <NEWLINE> <INDENT> al_count [ 14 ] += 1 <NEWLINE> <DEDENT> elif l == <STRING> : <NEWLINE> <INDENT> al_count [ 15 ] += 1 <NEWLINE> <DEDENT> elif l == <STRING> : <NEWLINE> <INDENT> al_count [ 16 ] += 1 <NEWLINE> <DEDENT> elif l == <STRING> : <NEWLINE> <INDENT> al_count [ 17 ] += 1 <NEWLINE> <DEDENT> elif l == <STRING> : <NEWLINE> <INDENT> al_count [ 18 ] += 1 <NEWLINE> <DEDENT> elif l == <STRING> : <NEWLINE> <INDENT> al_count [ 19 ] += 1 <NEWLINE> <DEDENT> elif l == <STRING> : <NEWLINE> <INDENT> al_count [ 20 ] += 1 <NEWLINE> <DEDENT> elif l == <STRING> : <NEWLINE> <INDENT> al_count [ 21 ] += 1 <NEWLINE> <DEDENT> elif l == <STRING> : <NEWLINE> <INDENT> al_count [ 22 ] += 1 <NEWLINE> <DEDENT> elif l == <STRING> : <NEWLINE> <INDENT> al_count [ 23 ] += 1 <NEWLINE> <DEDENT> elif l == <STRING> : <NEWLINE> <INDENT> al_count [ 24 ] += 1 <NEWLINE> <DEDENT> elif l == <STRING> : <NEWLINE> <INDENT> al_count [ 25 ] += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if words == [ ] : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> for i in range ( 26 ) : <NEWLINE> <INDENT> print <STRING> % ( alphabet [ i ] , al_count [ i ] ) <NEWLINE> <DEDENT>
alpha = <STRING> <NEWLINE> m = { k : 0 for k in alpha } <NEWLINE> <NL> while True : <NEWLINE> <INDENT> line = input ( ) <NEWLINE> if not line : <NEWLINE> <INDENT> break ; <NEWLINE> <DEDENT> for s in line : <NEWLINE> <INDENT> s = s . lower ( ) <NEWLINE> if s in m : <NEWLINE> <INDENT> m [ s ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for s in alpha : <NEWLINE> <INDENT> print ( <STRING> % ( s , m [ s ] ) ) <NEWLINE> <DEDENT>
word = <STRING> <NEWLINE> while True : <NEWLINE> <INDENT> w = input ( ) . lower ( ) <NEWLINE> if w == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> word += w <NEWLINE> <DEDENT> <DEDENT> for a in alphabet : <NEWLINE> <INDENT> print ( a + <STRING> + str ( word . count ( a ) ) ) <NEWLINE> <NL> <DEDENT>
a = [ ] <NEWLINE> while True : <NEWLINE> <INDENT> b = input ( ) <NEWLINE> if b == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a = a + [ str ( x ) for x in b . lower ( ) . replace ( <STRING> , <STRING> , 100 ) ] <NEWLINE> <DEDENT> print ( a ) <NEWLINE> <DEDENT> for i in <STRING> : <NEWLINE> <INDENT> counter = 0 <NEWLINE> for j in a : <NEWLINE> <INDENT> if i == j : <NEWLINE> <INDENT> counter += 1 <NEWLINE> <DEDENT> <DEDENT> print ( str ( i ) + <STRING> + str ( counter ) ) <NEWLINE> <DEDENT>
st = <STRING> <NEWLINE> num = [ 0 for i in range ( 26 ) ] <NEWLINE> while ( st != <STRING> ) : <NEWLINE> <INDENT> st = input ( ) . lower ( ) <NEWLINE> for k in range ( len ( st ) ) : <NEWLINE> <INDENT> if ord ( st [ k ] ) <= 122 and ord ( st [ k ] ) >= 97 : <NEWLINE> <INDENT> num [ ord ( st [ k ] ) - 97 ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for i in range ( 26 ) : <NEWLINE> <INDENT> print ( <STRING> . format ( chr ( i + 97 ) , num [ i ] ) ) <NEWLINE> <DEDENT>
a = [ 0 ] * 26 <NEWLINE> w = <STRING> <NEWLINE> try : <NEWLINE> <INDENT> while True : <NEWLINE> <INDENT> s = list ( input ( ) . upper ( ) ) <NEWLINE> for i in s : <NEWLINE> <INDENT> if i == <STRING> : <NEWLINE> <INDENT> a [ 0 ] += 1 <NEWLINE> <DEDENT> elif i == <STRING> : <NEWLINE> <INDENT> a [ 1 ] += 1 <NEWLINE> <DEDENT> elif i == <STRING> : <NEWLINE> <INDENT> a [ 2 ] += 1 <NEWLINE> <DEDENT> elif i == <STRING> : <NEWLINE> <INDENT> a [ 3 ] += 1 <NEWLINE> <DEDENT> elif i == <STRING> : <NEWLINE> <INDENT> a [ 4 ] += 1 <NEWLINE> <DEDENT> elif i == <STRING> : <NEWLINE> <INDENT> a [ 5 ] += 1 <NEWLINE> <DEDENT> elif i == <STRING> : <NEWLINE> <INDENT> a [ 6 ] += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> elif i == <STRING> : <NEWLINE> <INDENT> a [ 7 ] += 1 <NEWLINE> <DEDENT> elif i == <STRING> : <NEWLINE> <INDENT> a [ 8 ] += 1 <NEWLINE> <DEDENT> elif i == <STRING> : <NEWLINE> <INDENT> a [ 9 ] += 1 <NEWLINE> <DEDENT> elif i == <STRING> : <NEWLINE> <INDENT> a [ 10 ] += 1 <NEWLINE> <DEDENT> elif i == <STRING> : <NEWLINE> <INDENT> a [ 11 ] += 1 <NEWLINE> <DEDENT> elif i == <STRING> : <NEWLINE> <INDENT> a [ 12 ] += 1 <NEWLINE> <DEDENT> elif i == <STRING> : <NEWLINE> <INDENT> a [ 13 ] += 1 <NEWLINE> <DEDENT> elif i == <STRING> : <NEWLINE> <INDENT> a [ 14 ] += 1 <NEWLINE> <DEDENT> elif i == <STRING> : <NEWLINE> <INDENT> a [ 15 ] += 1 <NEWLINE> <DEDENT> elif i == <STRING> : <NEWLINE> <INDENT> a [ 16 ] += 1 <NEWLINE> <DEDENT> elif i == <STRING> : <NEWLINE> <INDENT> a [ 17 ] += 1 <NEWLINE> <DEDENT> elif i == <STRING> : <NEWLINE> <INDENT> a [ 18 ] += 1 <NEWLINE> <DEDENT> elif i == <STRING> : <NEWLINE> <INDENT> a [ 19 ] += 1 <NEWLINE> <DEDENT> elif i == <STRING> : <NEWLINE> <INDENT> a [ 20 ] += 1 <NEWLINE> <DEDENT> elif i == <STRING> : <NEWLINE> <INDENT> a [ 21 ] += 1 <NEWLINE> <DEDENT> elif i == <STRING> : <NEWLINE> <INDENT> a [ 22 ] += 1 <NEWLINE> <INDENT> elif i == <STRING> : <NEWLINE> <INDENT> a [ 23 ] += 1 <NEWLINE> <DEDENT> elif i == <STRING> : <NEWLINE> <INDENT> a [ 24 ] += 1 <NEWLINE> <DEDENT> elif i == <STRING> : <NEWLINE> <INDENT> a [ 25 ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> except EOFError : <NEWLINE> <INDENT> pass <NEWLINE> <NL> <DEDENT> for i in range ( 26 ) : <NEWLINE> <INDENT> print ( w [ i : i + 1 ] , <STRING> , str ( a [ i ] ) ) <NEWLINE> <DEDENT>
count = [ 0 for i in range ( 26 ) ] <NEWLINE> while ( 1 ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> str = str ( raw_input ( ) . lower ( ) ) <NEWLINE> <DEDENT> except EOFError : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> for i in range ( len ( str ) ) : <NEWLINE> <INDENT> k = 97 <NEWLINE> for j in range ( 26 ) : <NEWLINE> <INDENT> if str [ i ] == chr ( k ) : <NEWLINE> <INDENT> count [ j ] += 1 <NEWLINE> <DEDENT> k += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> k = 97 <NEWLINE> for i in range ( 26 ) : <NEWLINE> <INDENT> print <STRING> % ( chr ( k ) , count [ i ] ) <NEWLINE> k += 1 <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> dic = { } <NEWLINE> for i in range ( ord ( <STRING> ) , ord ( <STRING> ) + 1 ) : <NEWLINE> <INDENT> dic [ chr ( i ) ] = 0 <NEWLINE> <NL> <DEDENT> while True : <NEWLINE> <INDENT> buf = str ( raw_input ( ) ) . lower ( ) <NEWLINE> if not buf : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for i in range ( len ( buf ) ) : <NEWLINE> <INDENT> if buf [ i ] . isalpha ( ) : <NEWLINE> <INDENT> dic [ buf [ i ] ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for i in range ( ord ( <STRING> ) , ord ( <STRING> ) + 1 ) : <NEWLINE> <INDENT> print <STRING> % ( chr ( i ) , dic [ chr ( i ) ] ) <NEWLINE> <DEDENT>
import sys <NEWLINE> from collections import Counter <NEWLINE> <NL> c = Counter ( ) <NEWLINE> for line in sys . stdin . readlines ( ) : <NEWLINE> <INDENT> c . update ( line . lower ( ) ) <NEWLINE> <DEDENT> for a in <STRING> : <NEWLINE> <INDENT> print a + <STRING> , c . get ( a , 0 ) <NEWLINE> <DEDENT>
s = [ ] <NEWLINE> while True : <NEWLINE> <INDENT> x = raw_input ( ) <NEWLINE> if x == <STRING> : break <NEWLINE> s . append ( x . lower ( ) ) <NEWLINE> <DEDENT> s = <STRING> . join ( s ) <NEWLINE> <NL> for i in range ( 26 ) : <NEWLINE> <INDENT> c = chr ( i + 97 ) <NEWLINE> print <STRING> % ( c , s . count ( c ) ) <NEWLINE> <DEDENT>
<COMMENT> <NL> import sys <NEWLINE> mo = <STRING> <NEWLINE> moji_m = <STRING> <NEWLINE> while mo != <STRING> : <NEWLINE> <INDENT> mo = input ( ) . rstrip ( ) <NEWLINE> moji_m += mo <NEWLINE> <NL> <DEDENT> moji = list ( moji_m . lower ( ) ) <NEWLINE> moji_l = list ( <STRING> ) <NEWLINE> moji_c = [ 0 for i in range ( 26 ) ] <NEWLINE> <NL> for i in moji : <NEWLINE> <COMMENT> <NL> <INDENT> if i . isalpha ( ) == False : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> moji_c [ moji_l . index ( i ) ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( 26 ) : <NEWLINE> <INDENT> print ( str ( moji_l [ i ] ) + <STRING> + str ( moji_c [ i ] ) ) <NEWLINE> <DEDENT>
dic = { } <NEWLINE> for i in xrange ( 97 , 123 ) : <NEWLINE> <INDENT> dic . setdefault ( chr ( i ) , 0 ) <NEWLINE> <NL> <DEDENT> input = raw_input ( ) <NEWLINE> flag = False <NEWLINE> while input != <STRING> : <NEWLINE> <INDENT> for i in xrange ( len ( input ) ) : <NEWLINE> <INDENT> if input [ i ] . lower ( ) in dic : <NEWLINE> <INDENT> dic [ input [ i ] . lower ( ) ] += 1 <NEWLINE> <DEDENT> elif input [ i ] == <STRING> : <NEWLINE> <INDENT> flag = True <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if flag == True : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> input = raw_input ( ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> for i in xrange ( 97 , 123 ) : <NEWLINE> <INDENT> print chr ( i ) + <STRING> + str ( dic [ chr ( i ) ] ) <NEWLINE> <DEDENT>
import string <NEWLINE> <NL> count = { x : 0 for x in string . ascii_lowercase } <NEWLINE> lines = <STRING> <NEWLINE> <NL> while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> lines += input ( ) . lower ( ) <NEWLINE> <DEDENT> except EOFError : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> fpr c in lines : <NEWLINE> <INDENT> if <STRING> <= c <= <STRING> : <NEWLINE> count [ c ] += 1 <NEWLINE> <NL> <DEDENT> for key in string . ascii lowercase : <NEWLINE> <INDENT> print ( <STRING> . format ( key , count [ key ] ) ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> input_line = sys . stdin . read ( ) <NEWLINE> <NL> ch = [ <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <NEWLINE> <INDENT> <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> <NL> <DEDENT> sl = input_line . lower ( ) <NEWLINE> <NL> for c in ch : <NEWLINE> <INDENT> print ( <STRING> . format ( c , s . count ( c ) ) ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> int main ( ) { <NEWLINE> <INDENT> int alpha ; <NEWLINE> int cnt [ 256 ] = { 0 } ; <NEWLINE> while ( ( alpha = getchar ( ) ) != EOF ) { <NEWLINE> <INDENT> alpha = tolower ( alpha ) ; <NEWLINE> cnt [ alpha ] + + ; <NEWLINE> <DEDENT> } <NEWLINE> for ( alpha = <STRING> ; alpha <= <STRING> ; alpha + + ) { <NEWLINE> <INDENT> printf ( <STRING> , alpha , cnt [ alpha ] ) ; <NEWLINE> <DEDENT> } <NEWLINE> return 0 ; <NEWLINE> <DEDENT> } <NEWLINE>
s = <STRING> <NEWLINE> while True : <NEWLINE> <INDENT> t = input ( ) <NEWLINE> if len ( t ) == 0 : break <NEWLINE> s += t . lower ( ) <NEWLINE> <NL> <DEDENT> for c in <STRING> : <NEWLINE> <INDENT> print ( <STRING> . format ( c , s . count ( c ) ) ) <NEWLINE> <DEDENT>
l = [ 0 ] * 26 <NEWLINE> for h in sys . stdin : <NEWLINE> <INDENT> for i in h : <NEWLINE> <INDENT> k = ord ( i . lower ( ) ) <NEWLINE> if 96 < k < 123 : l [ k - 97 ] += 1 <NEWLINE> <DEDENT> <DEDENT> for i in range ( 26 ) : print chr ( i + 97 ) , <STRING> , l [ i ] <NEWLINE>
<COMMENT> <NL> <NL> def numinput ( ) : <NEWLINE> <INDENT> a = input ( ) . split ( ) <NEWLINE> for i in range ( len ( a ) ) : <NEWLINE> <INDENT> a [ i ] = int ( a [ i ] ) <NEWLINE> <DEDENT> return a <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> counts = [ ] <NEWLINE> for i in range ( 26 ) : counts . append ( 0 ) <NEWLINE> <NL> while True : <NEWLINE> <INDENT> string = input ( ) <NEWLINE> if not len ( string ) : break <COMMENT> <NEWLINE> for k in range ( len ( string ) ) : <NEWLINE> <INDENT> c = string [ k ] <NEWLINE> if 97 <= ord ( c ) <= 122 : <NEWLINE> <INDENT> counts [ ord ( c ) - 97 ] += 1 <NEWLINE> <DEDENT> elif 65 <= ord ( c ) <= 90 : <NEWLINE> <INDENT> counts [ ord ( c ) - 65 ] += 1 <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> for i in range ( 26 ) : <NEWLINE> <INDENT> print ( chr ( 97 + i ) + <STRING> + str ( counts [ i ] ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> import io <NEWLINE> import re <NEWLINE> import math <NEWLINE> <COMMENT> <NL> i = [ 0 ] * 127 <NEWLINE> <COMMENT> <NL> for x in sys . stdin . read ( ) . lower : <NEWLINE> <INDENT> i [ ord ( x ) ] += 1 <NEWLINE> <DEDENT> for y in range ( ord ( <STRING> ) , ord ( <STRING> ) + 1 ) : <NEWLINE> <INDENT> print chr ( y ) + <STRING> + i [ y ] <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> import sys <NEWLINE> <NL> a = sys . stdin . readlines ( ) <NEWLINE> <NL> for i in a : <NEWLINE> <INDENT> b = [ ] <NEWLINE> for j in i : <NEWLINE> <INDENT> b . append ( j . lower ( ) ) <NEWLINE> <DEDENT> for i in range ( 97 , 97 + 26 ) : <NEWLINE> <INDENT> print chr ( i ) + <STRING> + str ( b . count ( chr ( i ) ) ) <NEWLINE> <DEDENT> <DEDENT>
x = <STRING> <NEWLINE> while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> x += str ( input ( ) ) <NEWLINE> <DEDENT> except ValueError : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> <DEDENT> alist = list ( x ) <NEWLINE> alphabet = [ <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> ALPHABET = [ <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> aa = [ 0 ] * 27 <NEWLINE> for num in alist : <NEWLINE> <INDENT> itr = 0 <NEWLINE> for alp in alphabet : <NEWLINE> <INDENT> if num == alp : <NEWLINE> <INDENT> aa [ itr ] += 1 <NEWLINE> <DEDENT> itr += 1 <NEWLINE> <DEDENT> itr = 0 <NEWLINE> for ALP in ALPHABET : <NEWLINE> <INDENT> if num == ALP : <NEWLINE> <INDENT> aa [ itr ] += 1 <NEWLINE> <DEDENT> itr += 1 <NEWLINE> <DEDENT> <DEDENT> for i in range ( 26 ) : <NEWLINE> <INDENT> print ( <STRING> . format ( alphabet [ i ] , aa [ i ] ) ) <NEWLINE> <DEDENT>
<COMMENT> <NL> alfa_list = [ chr ( i ) for i in range ( 97 , 97 + 26 ) ] <NEWLINE> count_list = [ ] <NEWLINE> lines = [ ] <NEWLINE> while ( 1 ) : <NEWLINE> <INDENT> read_line = raw_input ( ) <NEWLINE> if read_line == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> lines . append ( read_line ) <NEWLINE> <DEDENT> char_line = str ( lines ) . lower ( ) <NEWLINE> for ch in alfa_list : <NEWLINE> <INDENT> count_list . append ( char_line . count ( ch ) ) <NEWLINE> <DEDENT> for i in range ( 26 ) : <NEWLINE> <INDENT> print <STRING> . format ( alfa_list [ i ] , count_list [ i ] ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> p = raw_input ( ) . lower ( ) <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> ip += p <NEWLINE> <DEDENT> alphabet = <STRING> <NEWLINE> for i in alphabet : <NEWLINE> <INDENT> print i + <STRING> + str ( ip . count ( i ) ) <NEWLINE> <DEDENT>
<COMMENT> <NL> bigALlist = list ( <STRING> ) <NEWLINE> smoALlist = list ( <STRING> ) <NEWLINE> cnt = [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] <NEWLINE> while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> text = list ( input ( ) ) <NEWLINE> for j in range ( len ( bigALlist ) ) : <NEWLINE> <INDENT> for i in text : <NEWLINE> <INDENT> if ( bigALlist [ j ] in i ) or ( smoALlist [ j ] in i ) : <NEWLINE> <INDENT> cnt [ j ] = cnt + 1 <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> . format ( smoALlist [ j ] , cnt ) ) <NEWLINE> <DEDENT> <DEDENT> except EOFError : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT>
lit = raw_input ( ) . lower ( ) <NEWLINE> Dic = { <STRING> : 0 , <STRING> : 0 , <STRING> : 0 , <STRING> : 0 , <STRING> : 0 , <STRING> : 0 , <STRING> : 0 , <STRING> : 0 , <STRING> : 0 , <STRING> : 0 , <STRING> : 0 , <STRING> : 0 , <STRING> : 0 , <STRING> : 0 , <STRING> : 0 , <STRING> : 0 , <STRING> : 0 , <STRING> : 0 , <STRING> : 0 , <STRING> : 0 , <STRING> : 0 , <STRING> : 0 , <STRING> : 0 , <STRING> : 0 , <STRING> : 0 , <STRING> : 0 } <NEWLINE> for i in lit : <NEWLINE> <INDENT> Dic [ i ] += 1 <NEWLINE> <DEDENT> Key = Dic . keys ( ) <NEWLINE> Key . sort ( ) <NEWLINE> for key in Key : <NEWLINE> <INDENT> print key , <STRING> , Dic [ key ] <NEWLINE> <DEDENT>
from collections import OrderedDict as od <NEWLINE> <NL> <NL> dic = od ( ) <NEWLINE> for s in <STRING> : <NEWLINE> <INDENT> dic [ s ] = 0 <NEWLINE> <NL> <DEDENT> x = <STRING> <NEWLINE> while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> x += line <NEWLINE> <DEDENT> except EOFError : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> for key , value in dic . items ( ) : <NEWLINE> <INDENT> value = x . count ( key ) <NEWLINE> print ( key , <STRING> , value ) <NEWLINE> <DEDENT>
import string <NEWLINE> <NL> count = { x : 0 for x in string . ascii_lowercase } <NEWLINE> <NL> s = input ( ) . lower ( ) <NEWLINE> <NL> for c in s : <NEWLINE> <INDENT> if <STRING> <= c <= <STRING> : <NEWLINE> <INDENT> count [ c ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> for key , num in count : <NEWLINE> <INDENT> print ( <STRING> . format ( key , num ) ) <NEWLINE> <DEDENT>
alpha = <STRING> <NEWLINE> counts = { key : 0 for key in alpha } <NEWLINE> while True : <NEWLINE> <INDENT> t = input ( ) <NEWLINE> if t == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for s in t : <NEWLINE> <INDENT> c = s . lower ( ) <NEWLINE> if c in alpha : <NEWLINE> <INDENT> counts [ c ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for key in sorted ( counts ) : <NEWLINE> <INDENT> print ( key + <STRING> + str ( counts [ key ] ) ) <NEWLINE> <DEDENT>
a = <STRING> <NEWLINE> b = [ 0 for i in range ( len ( a ) ) ] <NEWLINE> while True : <NEWLINE> <INDENT> S = raw_input ( ) . lower ( ) <NEWLINE> if S == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for j in range ( 26 ) : <NEWLINE> <INDENT> b [ j ] += S . count ( a [ j ] ) <NEWLINE> <DEDENT> <DEDENT> for i in range ( len ( a ) ) : <NEWLINE> <INDENT> print str ( a [ i ] ) + <STRING> + str ( b [ i ] ) <NEWLINE> <DEDENT>
str = input ( ) . split ( ) <NEWLINE> s = <STRING> . join ( str ) . lower <NEWLINE> s = list ( s ) <NEWLINE> for i in range ( 97 , 97 + 26 ) : <NEWLINE> <INDENT> count = 0 <NEWLINE> for j in s : <NEWLINE> <INDENT> if chr ( i ) == j : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> print ( chr ( i ) , <STRING> , count ) <NEWLINE> print ( <STRING> ) <NEWLINE> <NL> <DEDENT>
import sys <NEWLINE> import string <NEWLINE> <NL> dic = { } <NEWLINE> for c in string . ascii_lowercase : <NEWLINE> <INDENT> dic [ c ] = 0 <NEWLINE> <NL> <DEDENT> for c in sys . stdin . read ( ) . lower ( ) : <NEWLINE> <INDENT> if c . isalpha ( ) : <NEWLINE> <INDENT> dic [ c ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> for c in dic : <NEWLINE> <INDENT> print ( c + <STRING> + dic [ c ] ) <NEWLINE> <DEDENT>
import string <NEWLINE> <NL> count = { x : 0 for x in string . ascii_lowercase } <NEWLINE> lines = <STRING> <NEWLINE> while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> lines += input ( ) . lower ( ) <NEWLINE> <DEDENT> except EOFError : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> for c in s : <NEWLINE> <INDENT> if <STRING> <= c <= <STRING> : <NEWLINE> <INDENT> count [ c ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> for key in string . ascii_lowercase : <NEWLINE> <INDENT> print ( <STRING> . format ( key , count [ key ] ) ) <NEWLINE> <DEDENT>
try : <NEWLINE> <INDENT> s = <STRING> <NEWLINE> while True : <NEWLINE> <INDENT> s = s + input ( ) . lower ( ) <NEWLINE> <DEDENT> <DEDENT> except EOFError : <NEWLINE> [ print ( chr ( o ) + <STRING> + str ( s . count ( chr ( o ) ) ) ) for o in range ( ord ( <STRING> ) , ord ( <STRING> ) + 1 ) ] <NEWLINE>
import sys <NEWLINE> data = <STRING> <NEWLINE> for line in sys . stdin : <NEWLINE> <INDENT> sentence += line . lower ( ) <NEWLINE> <DEDENT> for i in data : <NEWLINE> <INDENT> print ( i + <STRING> + str ( sentence . count ( i ) ) ) <NEWLINE> <DEDENT>
import string <NEWLINE> <NL> count = { x : 0 for x in string . ascii_lowercase } <NEWLINE> lines = <STRING> <NEWLINE> <NL> while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> lines += input ( ) . lower ( ) <NEWLINE> <DEDENT> except EOFError : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> for c in lines : <NEWLINE> <INDENT> if <STRING> <= c <= <STRING> : <NEWLINE> <INDENT> count [ c ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> for key in string . ascii lowercase : <NEWLINE> <INDENT> print ( <STRING> . format ( key , count [ key ] ) ) <NEWLINE> <DEDENT>
cnt_dict = { key : 0 for key in <STRING> } <NEWLINE> string = input ( ) . lower ( ) <NEWLINE> for i in string : <NEWLINE> <INDENT> if i == <STRING> : continue <NEWLINE> cnt_dict [ i ] += 1 <NEWLINE> <DEDENT> for i in cnt_dict : <NEWLINE> <INDENT> print ( i + <STRING> + str ( cnt_dict [ i ] ) ) <NEWLINE> <DEDENT>
<NL> <INDENT> while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> yield <STRING> . join ( raw_input ( ) . strip ( ) ) <NEWLINE> <DEDENT> except EOFError : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> inlist = list ( get_input ( ) ) <NEWLINE> instr = <STRING> . join ( inlist ) <NEWLINE> instr = instr . lower ( ) <NEWLINE> ascstart = 97 <NEWLINE> ascfin = 122 <NEWLINE> strlist = [ 0 for i in xrange ( 97 , 122 + 1 ) ] <NEWLINE> <COMMENT> <NL> for x in xrange ( len ( instr ) ) : <NEWLINE> <INDENT> if ord ( instr [ x ] ) < ascstart or ord ( instr [ x ] ) > ascfin : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> strlist [ ord ( instr [ x ] ) - ascstart ] += 1 <NEWLINE> <NL> <DEDENT> for x in xrange ( ascstart , ascfin + 1 ) : <NEWLINE> <INDENT> print <STRING> % ( chr ( x ) , strlist [ x - ascstart ] ) <NEWLINE> <DEDENT>
ans = [ 0 for i in range ( 26 ) ] <NEWLINE> while True : <NEWLINE> <INDENT> a = input ( ) . upper ( ) <NEWLINE> if a == <STRING> : break <NEWLINE> S = list ( map ( ord , a ) ) <NEWLINE> S = [ e for e in S if 64 < e < 91 ] <NEWLINE> for i in S : <NEWLINE> <INDENT> ans [ i - 65 ] += 1 <NEWLINE> <DEDENT> <DEDENT> for i in range ( 26 ) : <NEWLINE> <INDENT> print ( <STRING> . format ( chr ( 97 + i ) , ans [ i ] ) ) <NEWLINE> <DEDENT>
<COMMENT> <NL> a = list ( raw_input ( ) . split ( ) . lower ( ) ) <NEWLINE> dict = { } <NEWLINE> for i in range ( 26 ) : <NEWLINE> <INDENT> dict [ chr ( ord ( <STRING> ) + i ) ] = 0 <NEWLINE> <DEDENT> for i in a : <NEWLINE> <INDENT> for key , value in dict . items ( ) : <NEWLINE> <INDENT> if key == i : <NEWLINE> <INDENT> dict [ key ] += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> for key , value in sorted ( dict . items ( ) ) : <NEWLINE> <INDENT> print <STRING> % ( key , value ) <NEWLINE> <NL> <DEDENT>
alp = [ ] <NEWLINE> txt = [ ] <NEWLINE> for i in range ( 97 , 97 + 26 ) : <NEWLINE> <INDENT> alp . append ( chr ( i ) ) <NEWLINE> <DEDENT> while True : <NEWLINE> <INDENT> if input ( ) == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a = input ( ) <NEWLINE> for i in a : <NEWLINE> <INDENT> txt . append ( str . lower ( i ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for i in alp : <NEWLINE> <INDENT> num = 0 <NEWLINE> for j in txt : <NEWLINE> <INDENT> if i == j : <NEWLINE> <INDENT> num += 1 <NEWLINE> <DEDENT> <DEDENT> print ( i + <STRING> + str ( num ) ) <NEWLINE> <NL> <DEDENT>
alphabetTable = dict . fromkeys ( [ chr ( i ) for i in range ( 97 , 123 ) ] , 0 ) <NEWLINE> <NL> while True : <NEWLINE> <INDENT> text = input ( ) <NEWLINE> <NL> if len ( text ) == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> for i in range ( len ( text ) ) : <NEWLINE> <INDENT> if text [ i ] . lower ( ) in alphabetTable : <NEWLINE> <INDENT> alphabetTable [ text [ i ] . lower ( ) ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> sortedTable = sorted ( alphabetTable . keys ( ) ) <NEWLINE> for r in sortedTable : <NEWLINE> <INDENT> print ( r , <STRING> , alphabetTable [ r ] ) <NEWLINE> <DEDENT>
import sys <NEWLINE> while True : <NEWLINE> <INDENT> S = sys . stdin . readlines ( ) . lower ( ) <NEWLINE> a = [ 0 for i in range ( 26 ) ] <NEWLINE> for c in S : <NEWLINE> <INDENT> if ord ( c ) >= 97 and ord ( c ) <= 122 : <NEWLINE> <INDENT> i = ord ( c ) - 97 <NEWLINE> a [ i ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( 26 ) : <NEWLINE> <INDENT> print ( <STRING> . format ( chr ( i + 97 ) , a [ i ] ) ) <NEWLINE> <DEDENT> <DEDENT>
s = list ( input ( ) ) <NEWLINE> res = [ 0 for i in range ( 26 ) ] <NEWLINE> for i in s : <NEWLINE> <INDENT> if i . isalnum ( ) : <NEWLINE> <INDENT> i = i . lower ( ) <NEWLINE> res [ ord ( s ) - ord ( <STRING> ) ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( 26 ) : <NEWLINE> <INDENT> s = chr ( ord ( i ) + ord ( <STRING> ) ) + <STRING> + str ( res [ i ] ) <NEWLINE> print ( s ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> charas = <STRING> <NEWLINE> <NL> data = [ ] <NEWLINE> for line in sys . stdin : <NEWLINE> <INDENT> data . append ( line ) <NEWLINE> <DEDENT> for chara in chara : <NEWLINE> <INDENT> for row in data : <NEWLINE> <INDENT> cnt = row . count ( chara ) <NEWLINE> cnt += row . count ( chara . upper ( ) ) <NEWLINE> <DEDENT> print ( <STRING> . format ( chara , cnt ) ) <NEWLINE> <DEDENT>
import string as st <NEWLINE> string = [ ] <NEWLINE> low_s = [ ] <NEWLINE> while True : <NEWLINE> <INDENT> s = input ( ) <COMMENT> <NEWLINE> string = list ( string ) <COMMENT> <NEWLINE> if not s : <COMMENT> <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> string . extend ( s ) <COMMENT> <NEWLINE> string = map ( str , string ) <NEWLINE> string = <STRING> . join ( string ) <NEWLINE> low_s = string . lower ( ) <NEWLINE> print ( low_s ) <NEWLINE> <DEDENT> for i in range ( len ( st . ascii_lowercase ) ) : <NEWLINE> <INDENT> print ( <STRING> . format ( st . ascii_lowercase [ i ] , low_s . count ( st . ascii_lowercase [ i ] ) ) ) <NEWLINE> <DEDENT>
docs = <STRING> <NEWLINE> while True : <NEWLINE> <INDENT> docs += ( raw_input ( ) . lower ( ) ) <NEWLINE> if docs [ len ( docs ) - 1 ] == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> for ascii_num in range ( 97 , 123 ) : <NEWLINE> <INDENT> print <STRING> % ( chr ( ascii_num ) , docs . count ( chr ( ascii_num ) ) ) <NEWLINE> <DEDENT>
a = [ 0 for i in range ( 26 ) ] <NEWLINE> while 1 : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> if s == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> print ( s ) <NEWLINE> for i in s : <NEWLINE> <INDENT> if i . isalnum ( ) : <NEWLINE> <INDENT> c = ord ( i . lower ( ) ) <NEWLINE> a [ c - 97 ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for i in range ( 26 ) : <NEWLINE> <INDENT> print ( chr ( i + 97 ) + <STRING> + str ( a [ i ] ) ) <NEWLINE> <DEDENT>
import string <NEWLINE> <NL> count = { x : 0 for x in string . ascii_lowercase } <NEWLINE> lines = <STRING> <NEWLINE> <NL> while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> lines += input ( ) . lower ( ) <NEWLINE> <DEDENT> except EOFError : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> for c in s : <NEWLINE> <INDENT> if <STRING> <= c <= <STRING> : <NEWLINE> <INDENT> count [ c ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> for key in string . ascii_lowercase : <NEWLINE> <INDENT> print ( <STRING> . format ( key , count [ key ] ) ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> p = raw_input ( ) <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> ip += p . lower ( ) <NEWLINE> <DEDENT> alphabet = <STRING> <NEWLINE> for i in alphabet : <NEWLINE> <INDENT> print i + <STRING> + str ( ip . count ( i ) ) <NEWLINE> <DEDENT>
import sys <NEWLINE> from collections import Counter <NEWLINE> m = Counter ( sys . stdin . read . lower ( ) ) <NEWLINE> for i in <STRING> : <NEWLINE> <INDENT> print ( i , <STRING> , m [ i ] ) <NEWLINE> <DEDENT>
st = [ ] <NEWLINE> while True : <NEWLINE> <INDENT> n = input ( ) <NEWLINE> <NL> if n == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> st += n . lower ( ) <NEWLINE> char = <STRING> <NEWLINE> <NL> for i in range ( len ( char ) ) : <NEWLINE> <INDENT> print ( char [ i ] , <STRING> , st . count ( char [ i ] ) ) <NEWLINE> <DEDENT> <DEDENT>
table = [ 0 ] * 26 <NEWLINE> string = [ ] <NEWLINE> while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> string += list ( input ( ) ) <NEWLINE> <DEDENT> except EOFError : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> for s in string : <NEWLINE> <INDENT> n = ord ( s . lower ( ) ) - 97 <NEWLINE> if n >= 0 and n <= 25 : <NEWLINE> <INDENT> table [ n ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> for idx , s in enumerate ( table ) : <NEWLINE> <INDENT> print ( chr ( idx + 97 ) + <STRING> + str ( s ) <NEWLINE> <DEDENT>
import string <NEWLINE> <NL> count = { x : 0 for x in string . ascii_lowercase } <NEWLINE> <NL> s = input ( ) <NEWLINE> <NL> for c in s : <NEWLINE> <INDENT> if <STRING> <= c <= <STRING> : <NEWLINE> <INDENT> count [ c ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> for key , num in count : <NEWLINE> <INDENT> print ( <STRING> . format ( key , num ) ) <NEWLINE> <DEDENT>
l = <STRING> <NEWLINE> mp = [ 0 for _ in list ( l ) ] <NEWLINE> <NL> while True : <NEWLINE> <INDENT> in_data = list ( filter ( lambda x : 97 <= ord ( x ) <= 122 , raw_input ( ) . lower ( ) ) ) <NEWLINE> <NL> for s in in_data : <NEWLINE> <INDENT> mp [ ord ( s ) - 97 ] += 1 <NEWLINE> <NL> <DEDENT> for i , j in zip ( l , mp ) : <NEWLINE> <INDENT> print <STRING> % ( i , j ) <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> <NL> chash = { } <NEWLINE> for i in range ( ord ( <STRING> ) , ord ( <STRING> ) ) : <NEWLINE> <INDENT> chash [ chr ( i ) ] = 0 <NEWLINE> <NL> <DEDENT> lines = sys . stdin . readlines ( ) . rstrip ( ) <NEWLINE> for i in range ( len ( lines ) ) : <NEWLINE> <INDENT> for j in range ( len ( lines [ i ] ) ) : <NEWLINE> <INDENT> if lines [ i ] [ j ] . isalpha ( ) : <NEWLINE> <INDENT> chash [ lines [ i ] [ j ] . lower ( ) ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for i in range ( ord ( <STRING> ) , ord ( <STRING> ) ) : <NEWLINE> <INDENT> print ( <STRING> . format ( chr ( i ) , chash [ chr ( i ) ] ) ) <NEWLINE> <DEDENT>
import string <NEWLINE> sen = input ( ) . lower ( ) <NEWLINE> <NL> char_dic = { i : 0 for i in string . ascii_lowercase } <NEWLINE> <NL> for j in sen : <NEWLINE> <INDENT> if j in char_dic : <NEWLINE> <INDENT> char_dic [ j ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> pass <NEWLINE> <NL> <DEDENT> <DEDENT> for k in string . ascii_letters : <NEWLINE> <INDENT> print ( <STRING> . format ( k , char_dic [ k ] ) ) <NEWLINE> <NL> <DEDENT>
counts = [ 0 ] * 26 <NEWLINE> <NL> while True : <NEWLINE> <INDENT> s = str ( input ( ) ) <NEWLINE> if s == <STRING> : break <NEWLINE> <NL> for c in s : <NEWLINE> <INDENT> o = ord ( c ) <NEWLINE> if o >= 65 and o <= 90 : <NEWLINE> <INDENT> counts [ o - 65 ] += 1 <NEWLINE> <DEDENT> elif o >= 97 and o <= 122 : <NEWLINE> <INDENT> counts [ o - 97 ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for i in range ( len ( counts ) ) : <NEWLINE> <INDENT> print ( chr ( i + 97 ) + <STRING> + str ( counts [ i ] ) ) <NEWLINE> <NL> <DEDENT>
alpha = [ <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> C = [ ] <NEWLINE> b = <STRING> <NEWLINE> while True : <NEWLINE> <INDENT> a = input ( ) <NEWLINE> a = a . lower ( ) <NEWLINE> b += a <NEWLINE> if a == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> for i in range ( len ( alpha ) ) : <NEWLINE> <INDENT> k = b . count ( alpha [ i ] ) <NEWLINE> C . append ( k ) <NEWLINE> <DEDENT> for i in range ( len ( alpha ) ) : <NEWLINE> <INDENT> print ( alpha [ i ] + <STRING> , C [ i ] ) <NEWLINE> <DEDENT>
alphabet = [ <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <NEWLINE> <INDENT> <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <NEWLINE> <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> <NL> <DEDENT> dic = { } <NEWLINE> for c in alphabet : <NEWLINE> <INDENT> dic [ c ] = 0 <NEWLINE> <NL> <DEDENT> while True : <NEWLINE> <INDENT> string = list ( input ( ) . rstrip ( ) . lower ( ) ) <NEWLINE> if string == [ ] : break <NEWLINE> <NL> for c in string : <NEWLINE> <INDENT> if c in alphabet : <NEWLINE> <INDENT> dic [ c ] = dic [ c ] + 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for key in dic : <NEWLINE> <INDENT> print ( <STRING> . format ( key , dic [ key ] ) ) <NEWLINE> <DEDENT>
import string <NEWLINE> count = { x : 0 for x in string . ascii_lowercase } <NEWLINE> lines = <STRING> <NEWLINE> <NL> while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> lines += input ( ) . lower ( ) <NEWLINE> <DEDENT> except EOFError : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> for c in lines : <NEWLINE> <INDENT> if <STRING> <= c <= <STRING> : <NEWLINE> <INDENT> count [ c ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> for key in string . ascii_lowercase : <NEWLINE> <INDENT> print ( <STRING> . format ( key , count ( key ) ) ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <NL> char_list = [ ] <NEWLINE> while ( True ) : <NEWLINE> <INDENT> str_in = input ( ) <NEWLINE> if str_in == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> char_list . append ( [ i for i in str_in . lower ( ) ] ) <NEWLINE> <COMMENT> <NL> <DEDENT> char_dict = { i : 0 for i in <STRING> } <NEWLINE> for i in range ( len ( char_list ) ) : <NEWLINE> <INDENT> for j in char_list [ i ] : <NEWLINE> <INDENT> if j in char_dict : <NEWLINE> <INDENT> char_dict [ j ] += 1 <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> for i in char_dict : <NEWLINE> <INDENT> print ( i + <STRING> . format ( char_dict [ i ] ) ) <NEWLINE> <NL> <DEDENT>
import sys <NEWLINE> <NL> data = sys . stdin ( ) . read ( ) <NEWLINE> for i in range ( 0x61 , 0x7b ) : <NEWLINE> <INDENT> print ( <STRING> % ( i , data . lower ( ) . count ( chr ( i ) ) ) ) <NEWLINE> <DEDENT>
import sys <NEWLINE> str = [ ] <NEWLINE> for line in sys . stdin : <NEWLINE> <INDENT> str . append ( line ) <NEWLINE> <DEDENT> s = <STRING> . join ( str ) . lower <NEWLINE> s = list ( s ) <NEWLINE> for i in range ( 97 , 97 + 26 ) : <NEWLINE> <INDENT> count = 0 <NEWLINE> for j in s : <NEWLINE> <INDENT> if chr ( i ) == j : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> print ( chr ( i ) , <STRING> , count ) <NEWLINE> <DEDENT>
list_str2 = [ 0 for i in range ( 26 ) ] <NEWLINE> <NL> while ( 1 ) : <NEWLINE> <INDENT> list_str1 = list ( input ( ) ) <NEWLINE> print ( list_str1 ) <NEWLINE> if list_str1 == [ ] : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for i in range ( len ( list_str1 ) ) : <NEWLINE> <INDENT> if 97 <= ord ( list_str1 [ i ] . lower ( ) ) <= 122 : <NEWLINE> <INDENT> list_str2 [ ord ( list_str1 [ i ] . lower ( ) ) - 97 ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for i in range ( 26 ) : <NEWLINE> <INDENT> print ( chr ( 97 + i ) + <STRING> + str ( list_str2 [ i ] ) ) <NEWLINE> <DEDENT>
def find_word ( sent , word , s ) : <NEWLINE> <INDENT> w = word <NEWLINE> if len ( w ) > 0 : <NEWLINE> <INDENT> if sent . find ( w ) >= 0 : <NEWLINE> <INDENT> return s <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s += 1 <NEWLINE> return find_word ( sent , w [ : - 1 ] , s ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> return - 1 <NEWLINE> <NL> <DEDENT> <DEDENT> sent = raw_input ( ) <NEWLINE> word = raw_input ( ) <NEWLINE> <NL> s = find_word ( sent , word , s ) <NEWLINE> if s == - 1 : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s = word [ len ( word ) - s : len ( word ) ] <NEWLINE> <NL> if sent . find ( s ) >= 0 : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> <DEDENT>
i = input <NEWLINE> p = print <NEWLINE> s = i ( ) <NEWLINE> p = i ( ) <NEWLINE> ( s + s ) . count ( p ) if p ( <STRING> ) else p ( <STRING> ) <NEWLINE>
import sys <NEWLINE> s1 = raw_input ( ) <NEWLINE> s2 = raw_input ( ) <NEWLINE> <NL> <NL> for idx , s in enumerate ( s1 ) : <NEWLINE> <INDENT> if s2 [ 0 ] != s : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <DEDENT> s1_idx = idx <NEWLINE> s2_idx = 0 <NEWLINE> while True : <NEWLINE> <NL> <INDENT> s1_now = s1 [ s1_idx : ] <NEWLINE> s2_now = s2 [ s2_idx : ] <NEWLINE> if len ( s1_now ) >= len ( s2_now ) : <NEWLINE> <INDENT> if s2_now in s1_now : <NEWLINE> <INDENT> print <STRING> <NEWLINE> sys . exit ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if s2_now . startswith ( s1_now ) : <NEWLINE> <INDENT> s1_idx = 0 <NEWLINE> s2_idx += len ( s1_now ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print <STRING> <NEWLINE>
def check ( s , p ) : <NEWLINE> <INDENT> count = 0 <NEWLINE> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> for j in range ( len ( p ) ) : <NEWLINE> <INDENT> if s [ ( i + j ) % len ( s ) ] != p [ j ] : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> count += 1 <NEWLINE> <DEDENT> if count == len ( p ) : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> <DEDENT> return False <NEWLINE> <NL> <DEDENT> s , p = raw_input ( ) <NEWLINE> flag = check ( s , p ) <NEWLINE> if flag : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
ring_str = input ( ) <NEWLINE> str = input ( ) <NEWLINE> <NL> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> if i == 0 and ring_str . find ( s ) != - 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> if i != 0 and ring_str . find ( s [ : i ] ) == len ( ring_str ) - len ( s [ : i ] ) : <NEWLINE> <INDENT> if s [ i : ] == ring_str [ : len ( s [ i : ] ) ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if i == len ( s ) - 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
s = input ( ) <NEWLINE> p = input ( ) <NEWLINE> print ( <STRING> if p in s + s ) <NEWLINE>
half_ring = raw_input ( ) <NEWLINE> ring = s * 2 <NEWLINE> target = raw_input ( ) <NEWLINE> f = 0 <NEWLINE> <NL> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> if ring [ i : i + len ( target ) ] == target : <NEWLINE> <INDENT> f = 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if f == 1 : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT>
s = input ( ) * 2 <NEWLINE> p = input ( ) <NEWLINE> print ( <STRING> if p in e else <STRING> ) <NEWLINE>
def saiki ( stri , i , nagasa ) : <NEWLINE> <INDENT> if stri [ 0 , i ] == stri [ 1 , i ] : <NEWLINE> <INDENT> if ( nagasa == 1 ) : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> nagasa -= 1 <NEWLINE> stri . pop ( 0 ) <NEWLINE> i += 1 <NEWLINE> saiki ( stri , i , nagasa ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> return 0 <NEWLINE> <NL> <DEDENT> <DEDENT> import sys <NEWLINE> input_str = sys . stdin . readlines ( ) <NEWLINE> inputs = list ( input_str ) <NEWLINE> <NL> for i in range ( len ( stri [ 0 ] ) ) : <NEWLINE> <INDENT> if saiki ( inputs [ 0 , i ] , i , len ( inputs [ 1 ] ) ) == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if i == len ( stri [ 0 ] ) - 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> pass <NEWLINE> <DEDENT> <DEDENT>
s1 = input ( ) <NEWLINE> s2 = input ( ) <NEWLINE> <NL> if s2 in s1 + s1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s = print ( ) <NEWLINE> p = print ( ) <NEWLINE> <NL> s *= 2 <NEWLINE> if s . find ( p ) != - 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
data = input ( ) <NEWLINE> target = input ( ) <NEWLINE> <NL> start = 0 <NEWLINE> flag = <STRING> <NEWLINE> for i in target : <NEWLINE> <INDENT> if ( data [ start : ] . find ( i ) ) : <NEWLINE> <INDENT> start = data [ start : ] . find ( i ) <NEWLINE> <DEDENT> elif ( data [ : start ] . find ( i ) ) : <NEWLINE> <INDENT> start = data . [ : start ] . find ( i ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> if ( i == target [ - 1 ] ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT>
ring = raw_input ( ) * 2 <NEWLINE> word = raw_input ( ) <NEWLINE> <NL> flag = 0 <NEWLINE> counter = 0 <NEWLINE> while counter < len ( ring / 2 ) : <NEWLINE> <INDENT> if ring [ counter : counter + len ( word ) ] == word : <NEWLINE> <INDENT> flag = 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if flag : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> for j in range ( len ( p ) ) : <NEWLINE> <INDENT> t = 0 <NEWLINE> if p [ j ] == s [ ( i + j ) % len ( s ) ] : <NEWLINE> <INDENT> t = t + 1 <NEWLINE> <COMMENT> <NL> <DEDENT> else : <NEWLINE> <INDENT> t = 0 <NEWLINE> <DEDENT> if t == len ( p ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if t < len ( p ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> p = input ( ) <NEWLINE> if s in ( p ** 2 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
p , s = [ input ( ) for i in range ( 2 ) ] <NEWLINE> p = p * 100 <NEWLINE> if a in p : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
sam = input ( ) <NEWLINE> ans = input ( ) <NEWLINE> for i in range ( len ( ans ) ) : <NEWLINE> <INDENT> if ( ans [ : i ] in sam ) == False : break <NEWLINE> <NL> <DEDENT> print ( ans [ : i - 1 ] ) <NEWLINE> print ( ans [ i - 1 : ] ) <NEWLINE> print ( sam [ : len ( ans [ i - 1 : ] ) ] ) <NEWLINE> <NL> if ( ( ans [ i - 1 : ] ) in sam [ : len ( ans [ i - 1 : ] ) ] ) == True and len ( ans ) != 1 : print ( <STRING> ) <NEWLINE> elif ( ans in sam ) == True : print ( <STRING> ) <NEWLINE> else : print ( <STRING> ) : print ( <STRING> ) <NEWLINE>
s = input ( ) <NEWLINE> p = input ( ) <NEWLINE> <NL> s *= 2 <NEWLINE> <NL> if s . finr ( p ) != - 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
target = input ( ) <NEWLINE> data = <STRING> <NEWLINE> while True : <NEWLINE> <INDENT> tmp = input ( ) <NEWLINE> if ( tmp == <STRING> ) : break <NEWLINE> data += tmp <NEWLINE> <NL> <DEDENT> print ( <STRING> % ( data . lower ( ) . count ( target . lower ( ) ) ) ) <NEWLINE>
W = input ( ) <NEWLINE> print ( ( ( sys . stdin . read ( ) ) . lower ( ) ) . count ( W ) ) <NEWLINE>
import sys <NEWLINE> W = input ( ) <NEWLINE> print ( sys . stdin . read ( ) . lower ( ) . split ( ) . count ( W ) <NEWLINE>
word = input ( ) <NEWLINE> while ( 1 ) : <NEWLINE> <INDENT> sentence = input ( ) <NEWLINE> if sentence == <STRING> <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> snt = sentence . lower ( ) <NEWLINE> <NL> <NL> <DEDENT> cnt = sentence . count ( word ) <NEWLINE> print ( cnt ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> w = input ( ) . lower ( ) <NEWLINE> c = 0 <NEWLINE> while True : <NEWLINE> <INDENT> t = input ( ) <NEWLINE> if <STRING> in t : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> c += t . lower ( ) . split ( ) lower ( ) . count ( w ) <NEWLINE> <DEDENT> print ( c ) <NEWLINE>
W = raw_input ( ) . lower ( ) <NEWLINE> c = 0 <NEWLINE> <NL> while True : <NEWLINE> <INDENT> T = raw_input ( ) . lower ( ) <NEWLINE> if T == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> Ti = T . split ( ) <NEWLINE> for i in Ti : <NEWLINE> <INDENT> if i == W : <NEWLINE> <INDENT> c += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> % ( c , ) ) <NEWLINE>
def check ( s , p ) : <NEWLINE> <INDENT> if s == p : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return 0 <NEWLINE> <NL> <DEDENT> <DEDENT> word = input ( ) . lower ( ) <NEWLINE> print ( word ) <NEWLINE> count = 0 <NEWLINE> while 1 : <NEWLINE> <INDENT> array = input ( ) . lower ( ) <NEWLINE> if array == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> print ( array ) <NEWLINE> for i in range ( len ( array ) - len ( word ) + 1 ) : <NEWLINE> <INDENT> if array [ i : i + len ( word ) ] == word : <NEWLINE> <INDENT> count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
w = input ( ) <NEWLINE> cnt = collections . Counter ( ) <NEWLINE> while True : <NEWLINE> <INDENT> s = [ 1 if i . lower ( ) == w else <STRING> if i == <STRING> else 0 for i in input ( ) . split ( ) ] <NEWLINE> if <STRING> in s : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> print ( s . count ( 1 ) ) <NEWLINE>
word = input ( ) . lower ( ) <NEWLINE> texts = [ ] <NEWLINE> while TRUE : <NEWLINE> <INDENT> str = input ( ) <NEWLINE> if str == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> texts . extend ( [ s . lower ( ) for s in str . split ( ) ] ) <NEWLINE> <NL> <NL> <DEDENT> ans = texts . count ( word ) <NEWLINE> <NL> print ( ans ) <NEWLINE>
w = input ( ) <NEWLINE> ll = list ( ) <NEWLINE> while True : <NEWLINE> <INDENT> T = input ( ) <NEWLINE> T = T . lower ( ) <NEWLINE> if T == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> t = T . split ( ) <NEWLINE> for i in t : <NEWLINE> <INDENT> ll . append ( i ) <NEWLINE> <DEDENT> <DEDENT> ans = ll . count ( w ) <NEWLINE> print ( ans ) <NEWLINE> <NL>
W = input ( ) <NEWLINE> <NL> count = 0 <NEWLINE> while True : <NEWLINE> <INDENT> line = input ( ) <NEWLINE> if line == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <NL> for s in line . lower ( ) split ( ) : <NEWLINE> if s == W : <NEWLINE> <INDENT> count += 1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
<COMMENT> <NL> <NL> word = input ( ) <NEWLINE> cnt = 0 <NEWLINE> <NL> while True : <NEWLINE> <INDENT> sentence = list ( map ( str , input ( ) . split ( ) ) ) <NEWLINE> for i in range ( len ( sentence ) ) : <NEWLINE> <INDENT> if sentence [ i ] == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> elif word == sentence [ i ] : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> pass <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ctn ) <NEWLINE>
key = raw_input ( ) . upper ( ) <NEWLINE> c = <STRING> <NEWLINE> while True : <NEWLINE> <INDENT> s = raw_input ( ) <NEWLINE> if s == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> c = c + <STRING> + s . upper ( ) <NEWLINE> <NL> <DEDENT> total = 0 <NEWLINE> ks = key [ 0 ] <NEWLINE> for i in range ( len ( c ) ) : <NEWLINE> <INDENT> if c [ i ] == ks : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> for k in range ( len ( key ) ) : <NEWLINE> <INDENT> if c [ i + k ] == key [ k ] : <NEWLINE> <INDENT> cnt = cnt + 1 <NEWLINE> <DEDENT> <DEDENT> if cnt == len ( key ) : <NEWLINE> <INDENT> total = total + 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print total <NEWLINE>
def main ( ) : <NEWLINE> <NL> <INDENT> Counter = 0 <NEWLINE> Text_W = input ( ) <NEWLINE> while True : <NEWLINE> <INDENT> Text_T = input ( ) . lower ( ) <NEWLINE> if <STRING> in Text_T : <NEWLINE> <INDENT> temp = Text_T . split ( ) <NEWLINE> for i in range ( len ( temp ) ) : <NEWLINE> <INDENT> Counter += 1 if Text_W == temp [ i ] else 0 <NEWLINE> <DEDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> temp = Text_T . split ( ) <NEWLINE> for i in range ( len ( temp ) ) : <NEWLINE> <INDENT> Counter += 1 if Text_W == temp [ i ] else 0 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( Counter ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <NL> <DEDENT>
c = 0 <NEWLINE> result = 0 <NEWLINE> while True : <NEWLINE> <INDENT> st = raw_input ( ) <NEWLINE> if c == 0 : <NEWLINE> <INDENT> s_str = st <NEWLINE> <DEDENT> elif <STRING> in st : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> c = c + 1 <NEWLINE> if s_str in st : <NEWLINE> <INDENT> result = result + st . split ( <STRING> ) . count ( s_str ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print result <NEWLINE>
a = [ ] <NEWLINE> while 1 : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> if s == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s = list ( s . split ( <STRING> ) ) <NEWLINE> s = list ( s [ 0 ] . split ( ) ) <NEWLINE> a . append ( s ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( a . count ( a [ 0 ] ) - 1 ) <NEWLINE>
ans = [ ] <NEWLINE> W = raw_input ( ) <NEWLINE> while True : <NEWLINE> <INDENT> i = raw_input ( ) <NEWLINE> if i == <STRING> : break <NEWLINE> ans += [ j . lower ( ) for j in i . split ( ) ] <NEWLINE> <DEDENT> print ans . count ( W ) <NEWLINE>
w = raw_input ( ) <NEWLINE> W = w . lower ( ) <NEWLINE> Text = [ ] <NEWLINE> while True : <NEWLINE> <INDENT> text = raw_input ( ) <NEWLINE> if text == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> Text . extend ( text . split ( ) ) <NEWLINE> <DEDENT> for i in range ( len ( Text ) ) : <NEWLINE> <INDENT> Text [ i ] = Text [ i ] . lower ( ) <NEWLINE> <DEDENT> print ( <STRING> % Text . count ( W ) ) <NEWLINE>
w = input ( ) . lower ( ) <NEWLINE> t = 0 <NEWLINE> while True : <NEWLINE> <INDENT> s = input ( ) . lower ( ) <NEWLINE> if s == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> t += s . count ( w ) <NEWLINE> <DEDENT> print ( t ) <NEWLINE>
target = raw_input ( ) <NEWLINE> ct = 0 <NEWLINE> flag = 0 <NEWLINE> while True : <NEWLINE> <INDENT> line = raw_input ( ) . split ( <STRING> ) <NEWLINE> for i in line : <NEWLINE> <INDENT> if i . lower ( ) == target . lower : <NEWLINE> <INDENT> ct += 1 <NEWLINE> <DEDENT> elif i . lower ( ) == <STRING> : <NEWLINE> <INDENT> print ct <NEWLINE> flag = 1 <NEWLINE> <DEDENT> <DEDENT> if flag == 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT>
w = input ( ) <NEWLINE> cnt = 0 <NEWLINE> while ( True ) : <NEWLINE> <INDENT> t = input ( ) <NEWLINE> if t == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> t = t . lower <NEWLINE> tlist = t . split ( ) <NEWLINE> for i in tlist : <NEWLINE> <INDENT> if i == w : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
import sys <NEWLINE> W = input ( ) <NEWLINE> print ( sys . stdin . read ( ) . rstrip ( <STRING> ) . lower ( ) . split ( <STRING> ) . count ( ) ) <NEWLINE>
W = input ( ) <NEWLINE> s = 0 <NEWLINE> while True : <NEWLINE> <INDENT> T = list ( input ( ) ) <NEWLINE> if T == [ <STRING> ] : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in T : <NEWLINE> <INDENT> if i == W : <NEWLINE> <INDENT> s += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( s ) <NEWLINE> <NL>
search_s = input ( ) <NEWLINE> cnt = 0 <NEWLINE> while True : <NEWLINE> <INDENT> word_list = input ( ) . lower ( ) . split ( ) <NEWLINE> if word_list [ 0 ] == <STRING> : break <NEWLINE> for word in word_list : <NEWLINE> <INDENT> if word == search_s : cnt += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
W = input ( ) <NEWLINE> count = 0 <NEWLINE> while True : <NEWLINE> <INDENT> T = input ( ) . split ( <STRING> ) <NEWLINE> if T == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> count += T . count ( W ) <NEWLINE> print ( count ) <NEWLINE> <NL> <NL> <DEDENT>
word = input ( ) <NEWLINE> number = 0 <NEWLINE> while True : <NEWLINE> <INDENT> row = input ( ) <NEWLINE> if row == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> row . replace ( <STRING> , <STRING> ) <NEWLINE> row . replace ( <STRING> , <STRING> ) <NEWLINE> row . replace ( <STRING> , <STRING> ) <NEWLINE> wordlist = list ( row . lower ( ) . split ( ) ) <NEWLINE> number += wordlist . count ( word . lower ( ) ) <NEWLINE> <DEDENT> print ( number <NEWLINE>
key_word = input ( ) . lower ( ) <NEWLINE> counter = 0 <NEWLINE> while True : <NEWLINE> <INDENT> sentences = input ( ) . lower ( ) . split ( ) <NEWLINE> if sentences == [ <STRING> ] : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for sent in sentences : <NEWLINE> <INDENT> if sent == key_word : <NEWLINE> <INDENT> counter += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( counter ) <NEWLINE> <NL>
W = input ( ) <NEWLINE> <NL> count = 0 <NEWLINE> while True : <NEWLINE> <INDENT> line = input ( ) <NEWLINE> if line == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> for s in line . lower ( ) . split ( ) : <NEWLINE> <INDENT> if s = W : <NEWLINE> <INDENT> count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
word = raw_input ( ) <NEWLINE> counter = 0 <NEWLINE> while True : <NEWLINE> <INDENT> line = raw_input ( ) <NEWLINE> if line == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> counter += line . lower ( ) . split ( <STRING> ) . count ( word ) <NEWLINE> <NL> <DEDENT> print counter <NEWLINE>
w = input ( ) <NEWLINE> c = 0 <NEWLINE> while True : <NEWLINE> <INDENT> t = input ( ) . lower ( ) <NEWLINE> if t == <STRING> : <NEWLINE> <INDENT> print ( c ) <NEWLINE> break <NEWLINE> <DEDENT> c += t . lower ( ) . split ( ) . count ( w ) <NEWLINE> <DEDENT>
import sys <NEWLINE> w = sys . stdin . readline ( ) . strip ( ) . lower ( ) <NEWLINE> t = sys . stdin . read ( ) . lower . split ( ) <NEWLINE> print ( w , t ) <NEWLINE>
W = input ( ) . lower ( ) <NEWLINE> <NL> count = 0 <NEWLINE> while True : <NEWLINE> <INDENT> line = input ( ) <NEWLINE> if line == <STRING> <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> for s in line . lower ( ) . split ( ) : <NEWLINE> <INDENT> if s == W : <NEWLINE> <INDENT> count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
W = input ( ) <NEWLINE> count = 0 <NEWLINE> while True : <NEWLINE> <INDENT> line = input ( ) <NEWLINE> if line == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> for s in line . lower . split ( ) : <NEWLINE> <INDENT> if s == W : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
a = input ( ) <NEWLINE> cnt = 0 <NEWLINE> while 1 : <NEWLINE> <INDENT> c = input ( ) . lower ( ) <NEWLINE> if c = <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> cnt += c . split ( ) . count ( a ) <NEWLINE> <DEDENT> print ( cnt ) <NEWLINE>
target = input ( ) <NEWLINE> <NL> count = 0 <NEWLINE> while True : <NEWLINE> <INDENT> line = input ( ) . lower <NEWLINE> if line == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> for word in line . split ( ) : <NEWLINE> <INDENT> if word . lower == target . lower : <NEWLINE> <INDENT> count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
W = input ( ) <NEWLINE> <NL> count = 0 <NEWLINE> while True : <NEWLINE> <INDENT> line = input ( ) <NEWLINE> if line == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> for s in line . lower . split ( ) : <NEWLINE> <INDENT> if s == W : <NEWLINE> <INDENT> count += 1 <NEWLINE> <NL> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
import sys <NEWLINE> <NL> w = sys . stdin . readline ( ) . rstrip ( ) . lower ( ) <NEWLINE> cnt = 0 <NEWLINE> while True : <NEWLINE> <INDENT> lines = sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> if not lines : <NEWLINE> break <NEWLINE> words = lines . split ( <STRING> ) <NEWLINE> for i in range ( len ( words ) ) : <NEWLINE> <INDENT> if w == words [ i ] . lower ( ) : <NEWLINE> cnt = cnt + 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
w = raw_input ( ) . lower ( ) <NEWLINE> sum = 0 <NEWLINE> while True : <NEWLINE> <INDENT> t = raw_input ( ) . split ( ) <NEWLINE> if t == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> sum += t . lower ( ) . count ( w ) <NEWLINE> <DEDENT> <DEDENT> print sum <NEWLINE>
W = raw_input ( ) . lower ( ) <NEWLINE> T = [ ] <NEWLINE> while True : <NEWLINE> <INDENT> t = input ( ) <NEWLINE> if t == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> T += t . lower ( ) . split ( ) <NEWLINE> <DEDENT> <DEDENT> print ( T ) <NEWLINE> print ( T . count ( W ) ) <NEWLINE>
cnt = 0 <NEWLINE> s = input ( ) . lower ( ) <NEWLINE> while 1 : <NEWLINE> <INDENT> line = input ( ) <NEWLINE> if line == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for s in line . lower ( ) . split ( ) : <NEWLINE> <DEDENT> print ( cnt ) <NEWLINE>
tt = input ( ) <NEWLINE> a = <STRING> <NEWLINE> while True : <NEWLINE> <INDENT> text = input ( ) . upper <NEWLINE> if text == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> a += text <NEWLINE> <DEDENT> print ( a . count ( tt ) ) <NEWLINE>
W = input ( ) <NEWLINE> <NL> while True : <NEWLINE> <INDENT> line = input ( ) <NEWLINE> if line == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> for s in line . lower ( ) . split ( ) : <NEWLINE> <INDENT> if s == W : <NEWLINE> <INDENT> count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
word = input ( ) <NEWLINE> text = [ ] <NEWLINE> c = 0 <NEWLINE> while True : <NEWLINE> <INDENT> read = input ( ) . lower ( ) . split ( ) <NEWLINE> if read [ 0 ] == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> text . append ( read ) <NEWLINE> <DEDENT> <DEDENT> for i in text : <NEWLINE> <INDENT> for n in i : <NEWLINE> <INDENT> if word in ne : <NEWLINE> <INDENT> c += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( c ) <NEWLINE>
import sys <NEWLINE> print ( sys . stdin . read ( ) . split ( ) . count ( input ( ) ) ) <NEWLINE>
<COMMENT> <NL> W = raw_input ( ) . lower ( ) <NEWLINE> array = [ ] <NEWLINE> cnt = 0 <NEWLINE> while True : <NEWLINE> <INDENT> line = raw_input ( ) <NEWLINE> if line == <STRING> <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> split = line . lower ( ) . split ( ) <NEWLINE> for s in split : <NEWLINE> <INDENT> array . append ( s ) <NEWLINE> <DEDENT> <DEDENT> for word in array : <NEWLINE> <INDENT> if W == word : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> print cnt <NEWLINE> <NL>
word = input ( ) . lower ( ) <NEWLINE> how_int = 0 <NEWLINE> while True : <NEWLINE> <INDENT> letters = input ( ) <NEWLINE> if letters == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for i in letters . lower ( ) . split ( ) : <NEWLINE> <INDENT> if i == word : <NEWLINE> <INDENT> how_in += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( how_in ) <NEWLINE>
w0 = raw_input ( ) . lower ( ) <NEWLINE> c = 0 <NEWLINE> while True : <NEWLINE> <INDENT> s = raw_input ( ) <NEWLINE> if s == <STRING> : break <NEWLINE> for w in s . . lower ( ) . split ( ) : <NEWLINE> <INDENT> if w == w0 : <NEWLINE> <INDENT> c += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print c <NEWLINE>
<COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> import re <NEWLINE> <NL> count = 0 <NEWLINE> <NL> w = input ( ) . lower ( ) <NEWLINE> <NL> while 1 : <NEWLINE> <INDENT> string = input ( ) . lower ( ) <NEWLINE> if string == <STRING> : <NEWLINE> <INDENT> break ; <NEWLINE> <NL> <DEDENT> string = string . split ( ) <NEWLINE> for i in string : <NEWLINE> <INDENT> count += w == i <NEWLINE> <NL> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
<NL> w = input ( ) . casefold ( ) <NEWLINE> word_count = 0 <NEWLINE> while True : <NEWLINE> <INDENT> line = input ( ) . casefold ( ) <NEWLINE> if line == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> word = line . split ( ) <NEWLINE> word_count += word . count ( w ) <NEWLINE> <DEDENT> print ( word_count ) <NEWLINE>
W = input ( ) <NEWLINE> T = [ ] <NEWLINE> while 1 : <NEWLINE> <INDENT> a = input ( ) <NEWLINE> if <STRING> == a : break <NEWLINE> T += [ s . lower ( ) for s in a . split ( ) ] <NEWLINE> <DEDENT> print ( T . count ( W ) ) <NEWLINE>
w = input ( ) <NEWLINE> li = list ( input ( ) . split ( ) . lower ( ) ) <NEWLINE> cnt = 0 <NEWLINE> for i in range ( len ( li ) ) : <NEWLINE> <INDENT> if w == li [ i ] : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
W = input ( ) <NEWLINE> <COMMENT> <NL> t = 0 <NEWLINE> <NL> while ( 1 ) : <NEWLINE> <INDENT> char_list = list ( x . lower ( ) for x in input ( ) . split ( ) ) <NEWLINE> <COMMENT> <NL> if char_list [ 0 ] == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> for i in range ( len ( char_list ) ) : <NEWLINE> <INDENT> if W == char_list [ i ] : <NEWLINE> <INDENT> t += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( t ) <NEWLINE>
<COMMENT> <NL> <NL> import sys <NEWLINE> <NL> w = sys . stdin . readline ( ) . strip ( ) <NEWLINE> count = 0 <NEWLINE> <NL> while True : <NEWLINE> <INDENT> t = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if <STRING> in t : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> for i in range ( len ( t ) ) : <NEWLINE> <INDENT> if t [ i ] . lower ( ) == w : <NEWLINE> <INDENT> count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE> <NL>
W = input ( ) . rstrip ( ) <NEWLINE> text = <STRING> <NEWLINE> while True : <NEWLINE> <INDENT> line = input ( ) . rstrip ( ) <NEWLINE> text += line if line == <STRING> : break <NEWLINE> <DEDENT> print ( text . count ( W ) ) <NEWLINE>
s = raw_input ( ) <NEWLINE> s = s [ : - 1 ] <NEWLINE> cnt = 0 <NEWLINE> while True : <NEWLINE> <INDENT> text = raw_input ( ) <NEWLINE> if <STRING> == text [ 0 : - 1 ] : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> while text . find ( s ) >= 0 : <NEWLINE> <INDENT> text = text [ text . find ( s ) + len ( s ) : ] <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> print cnt <NEWLINE>
<COMMENT> <NL> w = raw_input ( ) . upper ( ) <NEWLINE> c = 0 <NEWLINE> while 1 : <NEWLINE> <INDENT> t = raw_input ( ) . upper ( ) <NEWLINE> if t == <STRING> : break <NEWLINE> tt = t . split ( ) <NEWLINE> c += tt . count ( w ) <NEWLINE> <DEDENT> print c <NEWLINE>
import sys <NEWLINE> <NL> keyword = input ( ) . lowercase ( ) <NEWLINE> count = 0 <NEWLINE> for line in sys . stdin : <NEWLINE> <INDENT> count += sum ( [ 1 for word in line . lowercase ( ) . split ( ) if word == keyword ] ) <NEWLINE> <NL> <DEDENT> print ( count ) <NEWLINE>
a , s = 0 , input ( ) <NEWLINE> while ( True ) : <NEWLINE> <INDENT> t = input ( ) . split ( ) <NEWLINE> if t [ 0 ] == <STRING> : <NEWLINE> <INDENT> print ( a ) <NEWLINE> quit ( ) <NEWLINE> <DEDENT> for i in t : <NEWLINE> <INDENT> if i . lower ( ) in lis : <NEWLINE> <INDENT> a += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
string = [ ] <NEWLINE> W = input ( ) <COMMENT> <NEWLINE> while True : <NEWLINE> <INDENT> T = input ( ) <COMMENT> <NEWLINE> if T == <STRING> : <COMMENT> <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> string . append ( T ) <COMMENT> <NEWLINE> <DEDENT> count = 0 <NEWLINE> for i in range ( len ( string ) ) : <NEWLINE> <INDENT> string [ i ] = string [ i ] . lower ( ) <NEWLINE> string [ i ] = string [ i ] . split ( <STRING> ) <NEWLINE> for j in range ( len ( string [ i ] ) ) : <NEWLINE> <INDENT> if W == string [ i ] [ j ] : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
<COMMENT> <NL> <NL> def numinput ( ) : <NEWLINE> <INDENT> a = input ( ) . split ( ) <NEWLINE> for i in range ( len ( a ) ) : <NEWLINE> <INDENT> a [ i ] = int ( a [ i ] ) <NEWLINE> <DEDENT> return a <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> W = input ( ) . upper ( ) <COMMENT> <NEWLINE> line = <STRING> <NEWLINE> count = 0 <NEWLINE> while True : <NEWLINE> <INDENT> line = input ( ) . split ( ) <NEWLINE> if line == <STRING> : break <NEWLINE> for i in range ( len ( line ) ) : <NEWLINE> <INDENT> word = line [ i ] . upper ( ) <NEWLINE> if W == word : count += 1 <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
W = input ( ) <NEWLINE> <NL> T = [ ] <NEWLINE> while True : <NEWLINE> <INDENT> R = input ( ) . lower ( ) <NEWLINE> if R == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> T . append ( R ) <NEWLINE> <NL> <DEDENT> T = <STRING> . join ( T ) <NEWLINE> print ( T . count ( W ) ) <NEWLINE>
W = input ( ) <NEWLINE> <NL> count = 0 <NEWLINE> while True : <NEWLINE> <INDENT> line = input ( ) <NEWLINE> if line == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> for s in line . lower ( ) . split ( ) : <NEWLINE> <INDENT> if s == W : <NEWLINE> <INDENT> count += 1 <NEWLINE> <NL> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> print ( count <NEWLINE>
import sys <NEWLINE> <NL> w = input ( ) <NEWLINE> t = sys . stdin . read ( ) . split ( ) <NEWLINE> print ( t . lower ( ) . count ( w ) ) <NEWLINE>
w = input ( ) . lower ( ) <NEWLINE> n = 0 <NEWLINE> while True : <NEWLINE> <INDENT> t = input ( ) <NEWLINE> if t == <STRING> : break <NEWLINE> n += t . lower . count ( w ) <NEWLINE> <DEDENT> print ( n ) <NEWLINE>
import sys <NEWLINE> s = sys . stdin . read ( ) . split ( ) <NEWLINE> print ( s [ 1 : ] . split ( ) . count ( s [ 0 ] ) ) <NEWLINE>
word = input ( ) <NEWLINE> <NL> string = input ( ) . lower ( ) <NEWLINE> last = <STRING> <NEWLINE> <NL> while last != <STRING> : <NEWLINE> <INDENT> last = input ( ) . lower ( ) <NEWLINE> string += last <NEWLINE> <NL> <DEDENT> print ( string . count ( word ) ) <NEWLINE>
a = raw_input ( ) . lower ( ) <NEWLINE> s = 0 <NEWLINE> while True : <NEWLINE> <INDENT> b = raw_input ( ) . lower ( ) <NEWLINE> if b == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> s += b . count ( a ) <NEWLINE> <DEDENT> print s <NEWLINE>
word = raw_input ( ) <NEWLINE> sen = [ ] <NEWLINE> ct = 0 <NEWLINE> while 1 : <NEWLINE> <INDENT> sen = map ( str , raw_input ( ) . split ( <STRING> ) ) <NEWLINE> if sen [ - 1 : 0 ] == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : continue <NEWLINE> <DEDENT> for i in sen : <NEWLINE> <INDENT> i . lower ( ) <NEWLINE> if i == word : <NEWLINE> <INDENT> ct += 1 <NEWLINE> <DEDENT> else : continue <NEWLINE> <DEDENT> print ( ct ) <NEWLINE>
wor = input ( ) . upper ( ) <NEWLINE> <NL> import re <NEWLINE> while True : <NEWLINE> <INDENT> tes = input ( ) <NEWLINE> if tes == <STRING> : break <NEWLINE> tes = tes . upper ( ) <NEWLINE> m = re . findall ( wor , tes ) <NEWLINE> cou += len ( m ) <NEWLINE> <NL> <DEDENT> print ( cou ) <NEWLINE>
W = input ( ) <NEWLINE> <NL> while True : <NEWLINE> <INDENT> line = input ( ) <NEWLINE> if line == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> for s in line . lower ( ) . split ( ) : <NEWLINE> <INDENT> if s == W : <NEWLINE> <INDENT> count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
a = raw_input ( ) . lower ( ) <NEWLINE> c = 0 <NEWLINE> while 1 : <NEWLINE> <INDENT> b = raw_input ( ) . lower ( ) <NEWLINE> if b . strip ( ) == <STRING> : break <NEWLINE> pos = 0 <NEWLINE> while b . find ( a , pos ) != - 1 : <NEWLINE> <INDENT> pos = b . find ( a ) + 1 <NEWLINE> c += 1 <NEWLINE> <DEDENT> <DEDENT> print c <NEWLINE>
w = input ( ) <NEWLINE> cnt = 0 <NEWLINE> while True : <NEWLINE> <INDENT> t = input ( ) . lower ( ) <NEWLINE> if t == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if w in t . split ( ) : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE> <NL>
W = input ( ) . lower ( ) <NEWLINE> T = <STRING> <NEWLINE> while True : <NEWLINE> <INDENT> t = input ( ) . lower ( ) <NEWLINE> if t == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> T += t <NEWLINE> <DEDENT> print ( T . count ( W ) ) <NEWLINE>
w = input ( ) <NEWLINE> count = 0 <NEWLINE> while True : <NEWLINE> <INDENT> t = input ( ) . lower <NEWLINE> if t == <STRING> : break <NEWLINE> count += t . count ( w ) <NEWLINE> <DEDENT> print ( int ( count ) ) <NEWLINE>
c = 0 <NEWLINE> s = <STRING> <NEWLINE> p = input ( ) . upper ( ) <NEWLINE> while True : <NEWLINE> <INDENT> s1 = input ( ) <NEWLINE> if s1 == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> s += s1 <NEWLINE> <DEDENT> <DEDENT> a = s . upper ( ) . split ( ) <NEWLINE> for i in a : <NEWLINE> <INDENT> if p in i : <NEWLINE> <INDENT> c += 1 <NEWLINE> <DEDENT> <DEDENT> print ( c ) <NEWLINE>
cards = input ( ) <NEWLINE> shuffle = input ( ) <NEWLINE> <NL> while shuffle != <STRING> : <NEWLINE> <INDENT> n = int ( shuffle ) <NEWLINE> cards = cards [ n : ] + cards [ : n ] <NEWLINE> shuffle = input ( ) <NEWLINE> <NL> <DEDENT> print ( cards ) <NEWLINE>
s = input ( ) <NEWLINE> while s != <STRING> : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> h = int ( input ( ) ) <NEWLINE> s = s [ h : ] + s [ : h ] <NEWLINE> <DEDENT> print ( s ) <NEWLINE> s = input ( ) <NEWLINE> <NL> <DEDENT>
while True : <NEWLINE> <INDENT> cards = raw_input ( ) <NEWLINE> if cards == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> shuffle_num = int ( raw_input ( ) ) <NEWLINE> counter = 0 <NEWLINE> while counter < num : <NEWLINE> <INDENT> h = int ( raw_input ) <NEWLINE> cards = cards [ h : ] + cards [ : h ] <NEWLINE> num += 1 <NEWLINE> <DEDENT> print ( cards ) <NEWLINE> <DEDENT>
while ( 1 ) : <NEWLINE> <INDENT> n = input ( ) <NEWLINE> if n == <STRING> : <NEWLINE> <INDENT> exit ( ) <NEWLINE> <DEDENT> m = int ( input ( ) ) <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> h = int ( input ( ) ) <NEWLINE> n = n [ h : ] + n [ 0 : h ] <NEWLINE> <DEDENT> print ( n ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> C = input ( ) <NEWLINE> if C == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> count = int ( input ( ) ) <NEWLINE> shuffle = [ int ( input ( ) for i in range ( count ) ) ] <NEWLINE> for h in shuffle : <NEWLINE> <INDENT> C = C [ h : ] + C [ : h ] <NEWLINE> <DEDENT> print ( C ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> al = input ( ) <NEWLINE> m = int ( input ( ) ) <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> if n == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> al = al [ n : ] + al [ : n ] <NEWLINE> <DEDENT> <DEDENT> print ( al ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> text = input ( ) <NEWLINE> if text == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> count = int ( input ( ) ) <NEWLINE> for c in range ( count ) : <NEWLINE> <INDENT> index = int ( input ( ) ) <NEWLINE> text - text [ index : ] + text [ : index ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( text ) <NEWLINE>
while True : <NEWLINE> <INDENT> card = raw_input ( ) <NEWLINE> if card == <STRING> <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> m = int ( raw_input ( ) ) <NEWLINE> for shuffle in range ( m ) : <NEWLINE> <INDENT> h = int ( raw_input ( ) ) <NEWLINE> card = card [ h : ] + card [ : h ] <NEWLINE> <DEDENT> print card <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> W = list ( input ( ) ) <NEWLINE> if W [ 0 ] == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> times = int ( input ( ) ) <NEWLINE> for i in range ( times ) : <NEWLINE> <INDENT> h = int ( input ( ) ) <NEWLINE> W = W [ h : ] + W [ 0 : h ] <NEWLINE> <DEDENT> print ( X ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> _ = input ( ) <NEWLINE> if _ == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for i in range ( int ( input ( ) ) ) : <NEWLINE> <INDENT> l = int ( input ( ) ) <NEWLINE> _ = _ [ l : ] + [ : l ] <NEWLINE> <DEDENT> print ( _ ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> s = raw_input ( ) <NEWLINE> if s == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> for i in int ( raw_input ( ) ) : <NEWLINE> <INDENT> h = int ( raw_input ( ) ) <NEWLINE> s = s [ h : ] + s [ 0 : h ] <NEWLINE> <NL> <DEDENT> print ( s ) <NEWLINE> <DEDENT>
<NL> def shuffle ( text , n ) : <NEWLINE> <INDENT> return text [ n + 1 : ] + text [ : n ] <NEWLINE> <NL> <DEDENT> while True : <NEWLINE> <INDENT> sent = input ( ) <NEWLINE> if sent == <STRING> : break <NEWLINE> m = int ( input ( ) ) <NEWLINE> hs = [ int ( input ( ) ) for i in range ( m ) ] <NEWLINE> <NL> for h in hs : <NEWLINE> <INDENT> sent = shuffle ( sent ) <NEWLINE> <NL> <DEDENT> print ( sent ) <NEWLINE> <DEDENT>
A = input ( ) <NEWLINE> while ( A != <STRING> ) : <NEWLINE> <INDENT> m = int ( input ) <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> h = int ( input ( ) ) <NEWLINE> A = A [ h : ] + A [ : h ] <NEWLINE> <DEDENT> print ( A ) <NEWLINE> A = input ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> <NL> taro = 0 <NEWLINE> hanako = 0 <NEWLINE> for ni in range ( n ) : <NEWLINE> <INDENT> t , h = input ( ) . split ( ) <NEWLINE> <NL> if t < h : <NEWLINE> <INDENT> hanako += 3 <NEWLINE> <DEDENT> elif t > h : <NEWLINE> <INDENT> taro += 3 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> hanako += 1 <NEWLINE> taro += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( taro , hanako ) <NEWLINE>
from collections import deque <NEWLINE> <NL> <NL> def shuffle ( target , num ) : <NEWLINE> <INDENT> que = deque ( list ( target ) ) <NEWLINE> [ que . append ( que . popleft ( ) ) for _ in range ( int ( num ) ) ] <NEWLINE> return <STRING> . join ( que ) <NEWLINE> <NL> <DEDENT> text = input ( ) <NEWLINE> count = input ( ) <NEWLINE> while text != <STRING> : <NEWLINE> <INDENT> for _ in range ( int ( count ) ) : <NEWLINE> <INDENT> n = input ( ) <NEWLINE> text = shuffle ( text , n ) <NEWLINE> <DEDENT> print ( text ) <NEWLINE> text = input ( ) <NEWLINE> count = input ( ) <NEWLINE> <NL> <DEDENT>
mport sys <NEWLINE> <NL> BIG_NUM = 2000000000 <NEWLINE> MOD = 1000000007 <NEWLINE> EPS = 0.000000001 <NEWLINE> <NL> NUM = 20005 <NEWLINE> <NL> table = [ <STRING> ] * NUM <NEWLINE> <NL> <NL> while True : <NEWLINE> <NL> <INDENT> T = str ( input ( ) ) <NEWLINE> if T == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> left = 0 <NEWLINE> right = 0 <NEWLINE> <COMMENT> <NL> for i in range ( len ( T ) ) : <NEWLINE> <COMMENT> <NL> <INDENT> table [ left + right ] = T [ right ] <NEWLINE> right += 1 <NEWLINE> <NL> <DEDENT> num_suffle = int ( input ( ) ) <NEWLINE> <NL> for loop in range ( num_suffle ) : <NEWLINE> <INDENT> pick_num = int ( input ( ) ) <NEWLINE> <COMMENT> <NL> for i in range ( pick_num ) : <NEWLINE> <INDENT> table [ right + i ] = table [ left + i ] <NEWLINE> <DEDENT> left += pick_num <NEWLINE> right += pick_num <NEWLINE> <NL> <DEDENT> for i in range ( left , right ) : <NEWLINE> <INDENT> print ( <STRING> % ( table [ i ] ) , end = <STRING> ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> if s . isdigit ( ) : <NEWLINE> <INDENT> strings = strings [ len ( strings ) - int ( s ) - 1 : ] + strings [ : int ( s ) ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> strings = s <NEWLINE> <DEDENT> print ( strings ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> if s == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> for mi in range ( m ) : <NEWLINE> <INDENT> h = int ( input ( ) ) <NEWLINE> <NL> s = s [ : h ] + s [ h : ] <NEWLINE> <NL> <DEDENT> print ( s ) <NEWLINE> <DEDENT>
<COMMENT> <NL> import sys <NEWLINE> lines = sys . stdin . readlines ( ) <NEWLINE> l = 0 <NEWLINE> while not ( <STRING> in lines [ l ] ) : <NEWLINE> <INDENT> s = lines [ l ] . replace ( <STRING> , <STRING> ) <NEWLINE> n = int ( lines [ l + 1 ] ) <NEWLINE> l += 2 <NEWLINE> t = sum ( map ( int , lines [ l , l + n ] ) ) % len ( s ) <NEWLINE> print s [ t : ] + s [ : t ] <NEWLINE> l += n <NEWLINE> <DEDENT>
w = input ( ) <NEWLINE> <NL> ccount = 0 <NEWLINE> while True : <NEWLINE> <INDENT> line = input ( ) <NEWLINE> if line == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <NL> for s in line . lower ( ) . split ( ) : <NEWLINE> <INDENT> if s == W : <NEWLINE> <INDENT> count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ) <NEWLINE>
str = input ( ) <NEWLINE> while not str == <STRING> : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> str = str [ n : ] + [ : n - 1 ] <NEWLINE> <DEDENT> print ( str ) <NEWLINE> str = input ( ) <NEWLINE> <DEDENT>
while 1 : <NEWLINE> <INDENT> a = input ( ) <NEWLINE> if a . isdigit ( ) : <NEWLINE> <INDENT> if c > 0 : c += int ( a ) <NEWLINE> else : c = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if c != 0 : print ( ( s * 2 ) [ c % l - 1 : ] [ : l ] ) <NEWLINE> if <STRING> == a : break <NEWLINE> s = a ; l = len ( s ) ; c = 0 <NEWLINE> <DEDENT> <DEDENT>
while True : <NEWLINE> <INDENT> a = input ( ) <NEWLINE> if a == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> else : <NEWLINE> n = int ( input ( ) ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> h = int ( input ( ) ) <NEWLINE> a = a [ h : ] + a [ : h ] <NEWLINE> <DEDENT> <DEDENT> print ( a ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> s = input ( ) . split ( ) <NEWLINE> if s == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> card = [ x for x in s ] <NEWLINE> for i in range ( int ( input ( ) ) ) : <NEWLINE> <INDENT> h = int ( input ( ) ) <NEWLINE> card = card [ h : ] + card [ : h ] <NEWLINE> <DEDENT> print ( <STRING> . join ( card ) ) <NEWLINE> <DEDENT>
x = list ( input ( ) ) <NEWLINE> import re <NEWLINE> p = <STRING> <NEWLINE> <NL> while True : <NEWLINE> <INDENT> s = str ( input ( ) ) <NEWLINE> if not re . match ( p , s ) : <NEWLINE> <INDENT> print ( a + b ) <NEWLINE> x = list ( input ( ) ) <NEWLINE> <DEDENT> elif s == <STRING> : <NEWLINE> <INDENT> print ( a + b ) <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a , b = x [ : len ( x ) - int ( s ) ] , x [ - int ( s ) : ] <NEWLINE> <DEDENT> <DEDENT>
def shuffle ( l , h ) : <NEWLINE> <INDENT> l . extend ( l [ 0 : h ] ) <NEWLINE> del l [ 0 : h ] <NEWLINE> <NL> <DEDENT> while True : <NEWLINE> <INDENT> card_list = list ( raw_input ( ) ) <NEWLINE> if card_list == [ <STRING> ] : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> m = input ( ) <NEWLINE> h_count = [ 0 ] * m <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> h_count [ i ] = input ( ) <NEWLINE> shuffle ( card_list , h_count [ i ] ) <NEWLINE> <DEDENT> print ( <STRING> . join ( card_list ) ) <NEWLINE> <DEDENT> <DEDENT>
while True : <NEWLINE> <INDENT> s = raw_input ( ) <NEWLINE> if s == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> for i in range ( int ( raw_input ( ) ) ) : <NEWLINE> <INDENT> h = int ( raw_input ( ) ) <NEWLINE> s = s [ h : ] + s [ 0 : h ] <NEWLINE> <NL> <DEDENT> print ( s ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> if s == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <NL> m = int ( input ( ) ) <NEWLINE> for mi in range ( m ) : <NEWLINE> h = int ( input ( ) ) <NEWLINE> s = s [ h : ] + s [ : h ] <NEWLINE> <NL> <NL> print ( s ) <NEWLINE> <DEDENT> <DEDENT>
while 1 : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> if s == <STRING> : break <NEWLINE> n = input ( ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> h = int ( input ( ) ) <NEWLINE> s = s [ h : ] + s [ : h ] <NEWLINE> <DEDENT> print ( s ) <NEWLINE> <DEDENT>
while 1 : <NEWLINE> <INDENT> w = raw_input ( ) <NEWLINE> if w == <STRING> : break <NEWLINE> n = int ( raw_input ( ) ) <NEWLINE> for i in xrange ( n ) : <NEWLINE> <INDENT> l = int ( raw_input ( ) ) <NEWLINE> w = w [ l : ] + l [ : l ] <NEWLINE> <DEDENT> print w <NEWLINE> <DEDENT>
<COMMENT> <NL> import sys <NEWLINE> lines = sys . stdin . readlines ( ) <NEWLINE> l = 0 <NEWLINE> while lines [ l ] != <STRING> : <NEWLINE> <INDENT> s = lines [ l ] . replace ( <STRING> , <STRING> ) <NEWLINE> n = lines [ l + 1 ] <NEWLINE> l += 2 <NEWLINE> t = sum ( [ lines [ i ] for i in xrange ( l , l + n ) ] ) % len ( s ) <NEWLINE> print s [ t : ] + s [ : t ] <NEWLINE> l += n <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> cards = str ( input ( ) ) <NEWLINE> if cards == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> p = str ( input ( ) ) <NEWLINE> cards = cards [ p : ] + cards [ : p ] <NEWLINE> <DEDENT> print ( cards ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> st , sh = 0 , 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> t , h = map ( str , input ( ) . split ( ) ) <NEWLINE> if ord ( t [ 0 ] ) > ord ( h [ 0 ] ) : <NEWLINE> <INDENT> st += 3 <NEWLINE> <DEDENT> elif ord ( t [ 0 ] ) < ord ( h [ 0 ] ) : <NEWLINE> <INDENT> sh += 3 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> m = h if len ( t ) > len ( h ) else t <NEWLINE> l = 1 <NEWLINE> for j in range ( m ) : <NEWLINE> <INDENT> if ord ( t [ j ] ) > ord ( h [ j ] ) : <NEWLINE> <INDENT> st += 3 <NEWLINE> j = m <NEWLINE> l = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> sh += 3 <NEWLINE> j = m <NEWLINE> l = 0 <NEWLINE> <DEDENT> <DEDENT> if l : <NEWLINE> <INDENT> st += 1 <NEWLINE> sh += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( st , sh ) <NEWLINE>
<NL> Taro = 0 <NEWLINE> Hanako = 0 <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> T , H = map ( str , input ( ) . split ( ) ) <NEWLINE> if T > H : <NEWLINE> <INDENT> Taro += 3 <NEWLINE> <DEDENT> elif T = H : <NEWLINE> <INDENT> Taro += 1 <NEWLINE> Hanako += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> Hanako += 3 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( Taro , Hanako ) <NEWLINE> <NL>
n = int ( input ( ) ) <NEWLINE> tp = 0 <NEWLINE> hp = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> tarou , hanako = map ( str , input ( ) . split ( ) ) <NEWLINE> if ( tarou > hanko ) : <NEWLINE> <INDENT> tp += 3 <NEWLINE> <DEDENT> elif ( tarou < hanako ) : <NEWLINE> <INDENT> hp += 3 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> tp += 1 <NEWLINE> hp += 1 <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> % ( tp , hp ) ) <NEWLINE>
dic = { <STRING> : 5 , <STRING> : 4 , <STRING> : 3 , <STRING> : 2 , <STRING> : 1 } <NEWLINE> taro_p = 0 <NEWLINE> hana_p = 0 <NEWLINE> for i in range ( input ( ) ) : <NEWLINE> <INDENT> taro , hana = raw_input ( ) . split ( <STRING> ) <NEWLINE> if dic [ taro ] > dic [ hana ] : <NEWLINE> <INDENT> taro_p = taro_p + 3 <NEWLINE> hana_p = hana_p + 0 <NEWLINE> <DEDENT> elif dic [ taro ] < dic [ hana ] : <NEWLINE> <INDENT> taro_p = taro_p + 0 <NEWLINE> hana_p = hana_p + 3 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> taro_p = taro_p + 1 <NEWLINE> hana_p = hana_p + 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print taro_p , hana_p <NEWLINE>
score = [ 0 , 0 ] <NEWLINE> <NL> n = int ( raw_input ( ) ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> t , h = raw_input ( ) . split ( ) <NEWLINE> if t < h : <NEWLINE> <INDENT> score [ 1 ] += 3 <NEWLINE> <DEDENT> elif t > h : <NEWLINE> <INDENT> score [ 0 ] += 3 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> score [ ] += 1 <NEWLINE> <DEDENT> <DEDENT> print score [ 0 ] , score [ 1 ] <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <NL> n = int ( input ( ) ) <NEWLINE> turns = [ input ( ) for i in range ( n ) ] <NEWLINE> <NL> taro , hanako = 0 , 0 <NEWLINE> for turn in turns : <NEWLINE> <INDENT> t , h = turn . split ( <STRING> ) <NEWLINE> min_len = len ( t ) if len ( t ) <= len ( h ) else len ( h ) <NEWLINE> <NL> win_flag = 0 <COMMENT> <NEWLINE> for i in range ( min_len ) : <NEWLINE> <INDENT> if ord [ t ] < ord [ h ] : <NEWLINE> <INDENT> win_flag = 1 <NEWLINE> <DEDENT> elif ord [ h ] < ord [ t ] : <NEWLINE> <INDENT> win_flag = - 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if win_flag == 0 : <NEWLINE> <INDENT> if len ( t ) < len ( h ) : <NEWLINE> <INDENT> win_flag = 1 <NEWLINE> <DEDENT> elif len ( h ) < len ( t ) : <NEWLINE> <INDENT> win_flag = - 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if win_flag == - 1 : <NEWLINE> <INDENT> taro += 3 <NEWLINE> <DEDENT> elif win_flag == 1 : <NEWLINE> <INDENT> hanako += 3 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> taro += 1 <NEWLINE> hanako += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( taro , hanako ) <NEWLINE>
round = int ( raw_input ( ) ) <NEWLINE> score = { <STRING> : 0 , <STRING> : 0 } <NEWLINE> counter = 0 <NEWLINE> while counter < round : <NEWLINE> <INDENT> [ taro , hanako ] = raw_input . split ( ) <NEWLINE> if taro < hanako : <NEWLINE> <INDENT> score [ <STRING> ] += 3 <NEWLINE> <DEDENT> elif taro > hanako : <NEWLINE> <INDENT> score [ <STRING> ] += 3 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> score [ <STRING> ] += 1 <NEWLINE> score [ <STRING> ] += 1 <NEWLINE> <DEDENT> counter += 1 <NEWLINE> <NL> <DEDENT> print score [ <STRING> ] , score [ <STRING> ] <NEWLINE>
t , h = 0 , 0 <NEWLINE> int ( input ( ) ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a , b = input ( ) . split ( ) <NEWLINE> if a > b : <NEWLINE> <INDENT> h += 3 <NEWLINE> <DEDENT> elif a < b : <NEWLINE> <INDENT> t += 3 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> t += 1 <NEWLINE> h += 1 <NEWLINE> <DEDENT> <DEDENT> print ( t , h ) <NEWLINE>
n = int ( raw_input ( ) ) <NEWLINE> p = [ 0 , 0 ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> c = [ 0 for i in range ( 100 ) ] <NEWLINE> c = map ( list , raw_input ( ) . split ( ) ) <NEWLINE> m = 0 <NEWLINE> while 1 : <NEWLINE> <INDENT> if c [ 0 ] == c [ 1 ] : <NEWLINE> <INDENT> p [ 0 ] += 1 <NEWLINE> p [ 1 ] += 1 <NEWLINE> break <NEWLINE> <DEDENT> elif c [ 0 ] [ m ] < c [ 1 ] [ m ] : <NEWLINE> <INDENT> p [ 1 ] += 3 <NEWLINE> break <NEWLINE> <DEDENT> elif c [ 1 ] [ m ] < c [ 0 ] [ m ] : <NEWLINE> <INDENT> p [ 0 ] += 3 <NEWLINE> break <NEWLINE> <DEDENT> m += 1 <NEWLINE> <DEDENT> <DEDENT> print p [ 0 ] , p [ 1 ] <NEWLINE>
ap , bp = 0 <NEWLINE> n = int ( input ( ) ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a , b = input ( ) . split ( ) <NEWLINE> if a > b : <NEWLINE> <INDENT> ap += 3 <NEWLINE> <DEDENT> elif a == b : <NEWLINE> <INDENT> bp += 3 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> bp += 3 <NEWLINE> <DEDENT> print ( ap , bp ) <NEWLINE> <DEDENT>
n = input ( ) <COMMENT> <NEWLINE> taro = 0 <NEWLINE> hanako = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> x = map ( str , raw_input ( ) . split ( ) ) <COMMENT> <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> if ( x [ 0 ] > x [ 1 ] ) : <NEWLINE> <INDENT> taro += 3 <NEWLINE> <DEDENT> elif ( x [ 0 ] == x [ 1 ] ) : <NEWLINE> <INDENT> taro += 1 <NEWLINE> hanako += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> hanako += 3 <NEWLINE> <DEDENT> <DEDENT> print <STRING> % ( taro , hanako ) <NEWLINE> exit ( 0 ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> taro = 0 <NEWLINE> hanako = 0 <NEWLINE> for ni in range ( n ) : <NEWLINE> <INDENT> t , h = int ( ) . split ( ) <NEWLINE> <NL> if t < h : <NEWLINE> <INDENT> hanako += 3 <NEWLINE> <DEDENT> elif t > h : <NEWLINE> <INDENT> taro += 3 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> hanako += 1 <NEWLINE> taro += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( taro , hanako ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> taro = 0 <NEWLINE> hanako = 0 <NEWLINE> for ni in range ( n ) : <NEWLINE> <INDENT> t , h = input ( ) . split ( ) <NEWLINE> <NL> if t < h : <NEWLINE> <INDENT> hanako += 3 <NEWLINE> <DEDENT> elif t > h : <NEWLINE> <INDENT> taro += 3 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> hanako += 1 <NEWLINE> taro += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( taro . hanako ) <NEWLINE>
t = 0 <NEWLINE> h = 0 <NEWLINE> for i in range ( int ( input ( ) ) ) : <NEWLINE> <INDENT> l = input ( ) . split ( ) <NEWLINE> if l [ 0 ] = l [ 1 ] : <NEWLINE> <INDENT> t += 1 <NEWLINE> h += 1 <NEWLINE> <DEDENT> elif l [ 0 ] > l [ 1 ] : t += 3 <NEWLINE> else : h += 3 <NEWLINE> <DEDENT> print ( t , h ) <NEWLINE>
turn = int ( input ( ) ) <NEWLINE> ten = [ 0 , 0 ] <NEWLINE> <NL> for _ in range ( turn ) : <NEWLINE> <INDENT> hikaku = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if hikaku [ 0 ] < hikaku [ 1 ] : <NEWLINE> <INDENT> ten [ 1 ] += 3 <NEWLINE> <NL> <DEDENT> elif hikaku [ 0 ] > hikaku [ 1 ] : <NEWLINE> <INDENT> ten [ 0 ] += 3 <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> ten [ 0 ] += 1 <NEWLINE> ten [ 1 ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> . join ( map ( str , ten ) ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = 0 <NEWLINE> b = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> A , B = map ( str , input ( ) . split ( ) ) <NEWLINE> if A > B : <NEWLINE> <INDENT> a += 3 <NEWLINE> <DEDENT> elif B > A : <NEWLINE> <INDENT> b += 3 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a += 1 <NEWLINE> b += 1 <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> . ( a , b ) ) <NEWLINE>
<COMMENT> <NL> <NL> import sys <NEWLINE> <NL> printf = sys . stdout . write <NEWLINE> <NL> taro = 0 <NEWLINE> hanako = 0 <NEWLINE> <NL> x = input ( ) <NEWLINE> for i in range ( x ) : <NEWLINE> <INDENT> word = map ( str , raw_input ( ) . split ( ) ) <NEWLINE> if word [ 0 ] > word [ 1 ] : <NEWLINE> <INDENT> taro += 3 <NEWLINE> <DEDENT> elif word [ 0 ] < word [ 1 ] : <NEWLINE> <INDENT> hanako += 3 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> taro += 1 <NEWLINE> hanako += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print str ( taro ) + <STRING> , <NEWLINE> printf ( str ( hanako ) ) <NEWLINE>
<COMMENT> <NL> <NL> n = int ( input ( ) . rstrip ( ) ) <NEWLINE> toku = [ 0 , 0 ] <NEWLINE> narabe = [ ] <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> taro , hana = input ( ) . rstrip ( ) . split ( ) <NEWLINE> if taro == hana : <NEWLINE> <INDENT> toku [ 0 ] += 1 <NEWLINE> toku [ 1 ] += 1 <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> narabe = [ taro , hana ] <NEWLINE> narabe . sort ( ) <NEWLINE> toku [ 0 ] += narabe . index ( taro ) * 3 <NEWLINE> toku [ 1 ] += narabe . index ( hana ) * 3 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> . join ( toku ) ) <NEWLINE>
str = raw_input ( ) <NEWLINE> q = input ( ) <NEWLINE> for ans in range ( q ) : <NEWLINE> <INDENT> ans = raw_input ( ) <NEWLINE> ans1 = ans . split ( <STRING> ) <NEWLINE> if ans1 [ 0 ] == <STRING> : <NEWLINE> <INDENT> str = str [ 0 : int ( ans1 [ 1 ] ) ] + ans1 [ 3 ] + str [ int ( ans1 [ 2 ] ) + 1 : len ( str ) ] <NEWLINE> <DEDENT> if ans1 [ 0 ] == <STRING> : <NEWLINE> <INDENT> str = str [ 0 : int ( ans1 [ 1 ] ) ] + ans1 [ 3 ] + str [ int ( ans1 [ 1 ] ) : int ( ans1 [ 2 ] ) + 1 ] [ : : - 1 ] + str [ int ( ans1 [ 2 ] ) + 1 : len ( str ) ] <NEWLINE> <DEDENT> if ans1 [ 0 ] == <STRING> : <NEWLINE> <INDENT> print str [ int ( ans1 [ 1 ] ) : int ( ans1 [ 2 ] ) + 1 ] <NEWLINE> <DEDENT> <DEDENT>
s = input ( ) <NEWLINE> n = int ( input ( ) ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a = list ( input ( ) . split ( ) ) <NEWLINE> temp = s [ int ( a [ 1 ] ) : int ( a [ 2 ] ) + 1 ] <NEWLINE> if a [ 0 ] == <STRING> : <NEWLINE> <INDENT> temp3 = a [ 3 ] <NEWLINE> s = list ( s ) <NEWLINE> seq = 0 <NEWLINE> for i in range ( int ( a [ 1 ] ) , int ( a [ 2 ] ) + 1 ) : <NEWLINE> <INDENT> s [ i ] = temp3 [ seq ] <NEWLINE> seq += 1 <NEWLINE> <DEDENT> <DEDENT> elif a [ 0 ] == <STRING> : <NEWLINE> <INDENT> temp2 = temp [ : : - 1 ] <NEWLINE> s = s . replace ( temp , temp2 , 1 ) <NEWLINE> <DEDENT> elif a [ 0 ] == <STRING> : <NEWLINE> <INDENT> print ( temp ) <NEWLINE> <NL> <DEDENT> <DEDENT>
s = raw_input ( ) <NEWLINE> n = int ( raw_input ( ) ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> message = raw_input ( ) . split ( <STRING> ) <NEWLINE> a , b = int ( message [ 1 ] ) , int ( message [ 2 ] ) <NEWLINE> <NL> if message [ 0 ] == <STRING> : <NEWLINE> <INDENT> print ( s [ a : b + 1 ] ) <NEWLINE> <DEDENT> elif message [ 0 ] == <STRING> : <NEWLINE> <INDENT> s [ a : b + 1 ] = s [ a : b + 1 ] [ : : - 1 ] <NEWLINE> <DEDENT> elif message [ 0 ] == <STRING> : <NEWLINE> <INDENT> s = s [ : a ] + message [ 3 ] + s [ b : ] <NEWLINE> <DEDENT> <DEDENT>
s = input ( ) <NEWLINE> n = int ( input ( ) ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> t = input ( ) . split ( ) <NEWLINE> cmd , a , b = t [ 0 ] , int ( t [ 1 ] ) , int ( t [ 2 ] ) <NEWLINE> if cmd == <STRING> : <NEWLINE> <INDENT> print ( s [ a : b + 1 ] ) <NEWLINE> <DEDENT> elif cmd == <STRING> : <NEWLINE> <INDENT> s = s [ : a ] + s [ a : b ] . reverse ( ) + s [ b : ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s = s [ : a ] + t [ 3 ] + s [ b : ] <NEWLINE> <DEDENT> <DEDENT>
s = input ( ) <NEWLINE> for i in range ( int ( input ( ) ) ) : <NEWLINE> <INDENT> c = list ( map ( str , input ( ) . split ( ) ) ) <NEWLINE> a , b = int ( c [ 1 ] ) , int ( c [ 2 ] ) <NEWLINE> if c [ 0 ] == <STRING> : <NEWLINE> <INDENT> print ( s [ a : b + 1 ] ) <NEWLINE> <DEDENT> elif c [ 0 ] == <STRING> : <NEWLINE> <INDENT> s = s [ : a ] + s [ a : b + 1 ] [ : : - 1 ] + s [ b + 1 : ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s = s [ : a ] + c [ 3 ] + c [ b + 1 : ] <NEWLINE> <NL> <DEDENT> <DEDENT>
s = input ( ) <NEWLINE> n = int ( input ( ) ) <NEWLINE> for i in ragne ( n ) : <NEWLINE> <INDENT> cmd = input ( ) . split ( ) <NEWLINE> a , b = map ( int , [ cmd [ 1 ] , cmd [ 2 ] ] ) <NEWLINE> if cmd [ 0 ] [ 0 ] == <STRING> : print ( s ) <NEWLINE> elif cmd [ 0 ] == <STRING> : <NEWLINE> <INDENT> s = s [ : a ] + cmd [ 3 ] + s [ b + 1 : ] <NEWLINE> <DEDENT> elif cmd [ 0 ] == <STRING> : <NEWLINE> <INDENT> s = s [ : a ] + s [ a : b + 1 ] [ : : - 1 ] + s [ b + 1 : ] <NEWLINE> <DEDENT> <DEDENT>
s = input ( ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> <NL> for qi in range ( q ) : <NEWLINE> <INDENT> command = input ( ) . split ( ) <NEWLINE> <NL> a = command [ 1 ] <NEWLINE> b = command [ 2 ] <NEWLINE> if command [ 0 ] == <STRING> : <NEWLINE> <INDENT> print ( s [ a : b + 1 ] ) <NEWLINE> <DEDENT> elif command [ 0 ] == <STRING> : <NEWLINE> <INDENT> s = s [ : a ] + reversed ( s [ a : b + 1 ] ) + s [ b + 1 : ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> p = command [ 3 ] <NEWLINE> s = s [ : a ] + p + s [ b + 1 : ] <NEWLINE> <DEDENT> <DEDENT>
s = input ( ) <NEWLINE> q = input ( ) <NEWLINE> <NL> for qi in range ( q ) : <NEWLINE> <INDENT> command = input ( ) . split ( ) <NEWLINE> a = int ( command [ 1 ] ) <NEWLINE> b = int ( command [ 2 ] ) <NEWLINE> if command [ 0 ] == <STRING> : <NEWLINE> <INDENT> print ( s [ a : b + 1 ] ) <NEWLINE> <DEDENT> elif command [ 0 ] == <STRING> : <NEWLINE> <INDENT> s = s [ : a ] + s [ a : b + 1 ] [ : : - 1 ] + s [ b + 1 : ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> p = command [ 3 ] <NEWLINE> s = s [ : a ] + p + s [ b + 1 : ] <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> <NL> string = input ( ) <NEWLINE> commandAmount = int ( input ( ) ) <NEWLINE> <NL> for i in range ( commandAmount ) : <NEWLINE> <INDENT> command = input ( ) . rstrip ( ) . split ( ) <NEWLINE> start = int ( command [ 1 ] ) <NEWLINE> end = int ( command [ 2 ] ) <NEWLINE> if command [ 0 ] == <STRING> : <NEWLINE> <COMMENT> <NL> elif command [ 0 ] == <STRING> : <NEWLINE> <INDENT> replacedString = list ( string ) <NEWLINE> a = replacedString [ start ] <NEWLINE> b = replacedString [ end ] <NEWLINE> replacedString = string . translate ( str . maketrans ( a + b , b + a ) ) <NEWLINE> string = <STRING> . join ( replacedString ) <NEWLINE> <COMMENT> <NL> <DEDENT> elif command [ 0 ] == <STRING> : <NEWLINE> <INDENT> string = string . translate ( str . maketrans ( string [ start : end + 1 ] , command [ 3 ] ) ) <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> <DEDENT>
def f1 ( a , b , s ) : <NEWLINE> <INDENT> print ( s [ a : b + 1 ] ) <NEWLINE> return s <NEWLINE> <NL> <DEDENT> def f2 ( a , b , s ) : <NEWLINE> <INDENT> temp = s [ a : b + 1 ] <NEWLINE> return s [ : a ] + temp [ : : - 1 ] + s [ b + 1 : ] <NEWLINE> <NL> <DEDENT> def f3 ( a , b , p , s ) : <NEWLINE> <INDENT> return s [ : a ] + p + s [ b + 1 : ] <NEWLINE> <DEDENT> <STRING> <NEWLINE> data = <STRING> <NEWLINE> q = 1 <NEWLINE> functions = { <STRING> : f1 , <STRING> : f2 , <STRING> : f3 } <NEWLINE> <NL> for i in range ( q ) : <NEWLINE> <INDENT> temp = [ s if s . isalpha ( ) else int ( s ) for s in input ( ) . split ( <STRING> ) ] <NEWLINE> f = temp . pop ( 0 ) <NEWLINE> data = functions [ f ] ( * temp , data ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> n = int ( input ( ) ) <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> line = input ( ) . split ( ) <NEWLINE> command , args = line [ 0 ] , line [ 1 : ] <NEWLINE> if command == <STRING> : <NEWLINE> <INDENT> s = s [ : args [ 0 ] ] + args [ 2 ] + s [ args [ 1 ] : ] <NEWLINE> <DEDENT> elif command == <STRING> : <NEWLINE> <INDENT> s = s [ : args [ 0 ] ] + str ( reversed ( s [ args [ 0 ] : args [ 1 ] ] ) ) + s [ args [ 1 ] : ] <NEWLINE> <DEDENT> elif command == <STRING> : <NEWLINE> <INDENT> print ( s ) <NEWLINE> <DEDENT> <DEDENT>
x = input ( ) <NEWLINE> for i in range ( int ( input ( ) ) ) : <NEWLINE> <INDENT> a = input ( ) . split ( ) <NEWLINE> <NL> <NL> if a [ 0 ] == <STRING> : <NEWLINE> <INDENT> for i in range ( 1 , len ( a ) ) : <NEWLINE> <INDENT> a [ i ] = int ( a [ i ] ) <NEWLINE> <DEDENT> print ( x [ a [ 1 ] : a [ 2 ] + 1 ] ) <NEWLINE> <DEDENT> elif a [ 0 ] == <STRING> : <NEWLINE> <INDENT> for i in range ( 1 , len ( a ) - 1 ) : <NEWLINE> <INDENT> a [ i ] = int ( a [ i ] ) <NEWLINE> <DEDENT> x = x [ : a [ 1 ] ] + a [ 3 ] + x [ a [ 2 ] : ] <NEWLINE> <DEDENT> elif a [ 0 ] == <STRING> : <NEWLINE> <INDENT> for i in range ( 1 , len ( a ) ) : <NEWLINE> <INDENT> a [ i ] = int ( a [ i ] ) <NEWLINE> <DEDENT> x [ a [ 1 ] : a [ 2 ] ] = x [ a [ 2 ] : a [ 1 ] : - 1 ] <NEWLINE> <NL> <DEDENT> <DEDENT>
string = input ( ) <NEWLINE> n = int ( input ( ) ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> command = input ( ) . split ( ) <NEWLINE> c_n = command [ 0 ] <NEWLINE> c_i1 = command [ 1 ] <NEWLINE> c_i2 = command [ 2 ] <NEWLINE> if c_n == <STRING> : <NEWLINE> <INDENT> print ( string [ c_i1 : c_i2 ] ) <NEWLINE> <DEDENT> elif c_n == <STRING> : <NEWLINE> <INDENT> string = string [ : c_i1 ] + string [ c_i1 : c_i2 ] [ : : - 1 ] + string [ c_i2 : ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> string = string [ : c_i1 ] + command [ 3 ] + string [ c_i2 ] <NEWLINE> <DEDENT> <DEDENT>
if __name__ == <STRING> : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> code = input ( ) . split ( ) <NEWLINE> op , a , b = code [ 0 ] , int ( code [ 1 ] ) , int ( code [ 2 ] ) <NEWLINE> if op == <STRING> : <NEWLINE> <INDENT> print ( s [ a : b + 1 ] ) <NEWLINE> <DEDENT> elif op == <STRING> : <NEWLINE> <INDENT> s = s [ : a ] + s [ a : b + 1 ] [ : : - 1 ] + s [ b + 1 : ] <NEWLINE> <DEDENT> elif op == <STRING> : <NEWLINE> <INDENT> s = s [ : a ] + p + s [ b + 1 : ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
s = input ( ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> <NL> for qi in range ( q ) : <NEWLINE> <INDENT> command = input ( ) . split ( ) <NEWLINE> <NL> a = int ( command [ 1 ] ) <NEWLINE> b = int ( command [ 2 ] ) <NEWLINE> if command [ 0 ] == <STRING> : <NEWLINE> <INDENT> print ( s [ a : b + 1 ] ) <NEWLINE> <DEDENT> elif command [ 1 ] == <STRING> : <NEWLINE> <INDENT> s = s [ : a ] + s [ a : b + 1 ] [ : : - 1 ] + s [ b + 1 : ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> p = command [ 3 ] <NEWLINE> s = s [ : a ] + p + s [ b + 1 : ] <NEWLINE> <DEDENT> <DEDENT>
s = input ( ) <NEWLINE> n = int ( input ( ) ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> order , a , b , * c = input ( ) . split ( ) <NEWLINE> a = int ( a ) <NEWLINE> b = int ( b ) <NEWLINE> if order == <STRING> : <NEWLINE> <INDENT> s = s [ : a ] + c + s [ b + 1 : ] <NEWLINE> <DEDENT> elif order [ 0 ] == <STRING> : <NEWLINE> <INDENT> s = s [ : a ] + s [ : : - 1 ] [ a : b + 1 ] + s [ b + 1 : ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( s [ a : b + 1 ] ) <NEWLINE> <DEDENT> <DEDENT>
data = input ( ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> for _ in range ( q ) : <NEWLINE> <INDENT> op = list ( map ( str , input ( ) . split ( ) ) ) <NEWLINE> a = int ( op [ 1 ] ) <NEWLINE> b = int ( op [ 2 ] ) + 1 <NEWLINE> if ( op [ 0 ] == <STRING> ) : <NEWLINE> <INDENT> print ( data [ a : b ] ) <NEWLINE> <DEDENT> elif ( op [ 0 ] == <STRING> ) : <NEWLINE> <INDENT> data = data [ : a ] + data [ a : b ] [ : : - 1 ] + data [ : b ] <NEWLINE> <DEDENT> elif ( op [ 0 ] == <STRING> ) : <NEWLINE> <INDENT> data = data [ : a ] + q + data [ b : ] <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <NL> str = input ( ) <NEWLINE> op_num = int ( input ( ) ) <NEWLINE> for i in range ( op_num ) : <NEWLINE> <INDENT> op = input ( ) . split ( ) <NEWLINE> a = int ( op [ 1 ] ) <NEWLINE> b = int ( op [ 2 ] ) <NEWLINE> if op [ 0 ] == <STRING> : <NEWLINE> <INDENT> str = str . replace ( str [ a : b + 1 ] , op [ 3 ] ) <NEWLINE> <DEDENT> elif op [ 0 ] == <STRING> : <NEWLINE> <COMMENT> <NL> <INDENT> str = str [ : a ] + str [ a : b + 1 ] [ : : - 1 ] + str [ b + 1 : ] <NEWLINE> <DEDENT> else op [ 0 ] == <STRING> : <NEWLINE> <INDENT> print ( str [ a : b + 1 ] ) <NEWLINE> <DEDENT> <DEDENT>
def transformate ( s , command ) : <NEWLINE> <INDENT> command , * op = command . split ( ) <NEWLINE> <NL> op [ 0 ] = int ( op [ 0 ] ) <NEWLINE> op [ 1 ] = int ( op [ 1 ] ) <NEWLINE> <NL> if command == <STRING> : <NEWLINE> <INDENT> return s [ 0 : op [ 0 ] ] + op [ 2 ] + s [ op [ 1 ] + 1 : ] <NEWLINE> <DEDENT> elif command == <STRING> : <NEWLINE> <INDENT> return s [ 0 : op [ 0 ] ] + s [ op [ 0 ] : op [ 1 ] + 1 ] [ : : - 1 ] + s [ op [ 1 ] + 1 : ] <NEWLINE> <DEDENT> elif command == <STRING> : <NEWLINE> <INDENT> print ( output ) <NEWLINE> return s <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> for _ in range ( int ( input ( ) ) ) : <NEWLINE> <INDENT> s = transformate ( s , input ( ) ) <NEWLINE> <NL> <DEDENT> <DEDENT>
<COMMENT> <NL> <NL> s = str ( raw_input ( ) ) <NEWLINE> q = int ( raw_input ( ) ) <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> line = map ( str , raw_input ( ) . split ( ) ) <NEWLINE> com = line [ 0 ] <NEWLINE> a = int ( line [ 1 ] ) <NEWLINE> b = int ( line [ 2 ] ) <NEWLINE> if com == <STRING> : <NEWLINE> <INDENT> print s [ a : b + 1 ] <NEWLINE> <DEDENT> elif com == <STRING> : <NEWLINE> <INDENT> len = len ( s ) <NEWLINE> s = s [ 0 : a ] + s [ - len + b : - len + a - 1 : - 1 ] + s [ b + 1 : ] <NEWLINE> <DEDENT> elif com == <STRING> : <NEWLINE> <INDENT> p = line [ 3 ] <NEWLINE> s = s . replace ( s [ a : b + 1 ] , p ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> <DEDENT>
round = int ( input ( ) ) <NEWLINE> T_pt = 0 <NEWLINE> H_pt = 0 <NEWLINE> <NL> for i in range ( round ) : <NEWLINE> <INDENT> pair = raw_input ( ) . split ( <STRING> ) <NEWLINE> T_card = pair [ 0 ] . lower ( ) <NEWLINE> H_card = pair [ 1 ] . lower ( ) <NEWLINE> <NL> if T_card < H_card : <NEWLINE> <INDENT> H_pt += 3 <NEWLINE> <DEDENT> elif T_card > H_card : <NEWLINE> <INDENT> T_pt += 3 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> T_pt += 1 <NEWLINE> H_pt += 1 <NEWLINE> <DEDENT> <DEDENT> print T_pt , H_pt <NEWLINE>
str = input ( ) <NEWLINE> n = int ( input ( ) ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> s = input ( ) . split ( ) <NEWLINE> a = int ( s [ 1 ] ) <NEWLINE> b = int ( s [ 2 ] ) <NEWLINE> if s [ 0 ] == <STRING> : <NEWLINE> <INDENT> str = str [ : a ] + s [ 3 ] + str [ b : ] <NEWLINE> <DEDENT> elif s [ 0 ] == <STRING> : <NEWLINE> <INDENT> str = str [ : a ] + reversed ( str [ a : b ] ) + str [ b : ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( str [ a : b ] ) <NEWLINE> <DEDENT> <DEDENT>
s = input ( ) <NEWLINE> for _ in range ( int ( input ( ) ) ) : <NEWLINE> <INDENT> a = input ( ) . split ( ) <NEWLINE> o = a [ 0 ] ; i = int ( a [ 1 ] ) ; j = int ( a [ 2 ] ) + 1 <NEWLINE> if <STRING> == o [ 0 ] : print ( s [ i : j ] ) <NEWLINE> else : <NEWLINE> <INDENT> t = ( s [ i : j ] [ : : - 1 ] , a [ 3 ] ) [ <STRING> == o [ 2 ] ] <NEWLINE> s = s [ 0 : i ] + t + s [ j : ] <NEWLINE> <DEDENT> <DEDENT>
s = list ( raw_input ( ) ) <NEWLINE> for loop in xrange ( input ( ) ) : <NEWLINE> <INDENT> c = raw_input ( ) . split ( ) <NEWLINE> if c [ 0 ] == <STRING> : <NEWLINE> <INDENT> s [ int ( c [ 1 ] ) : int ( c [ 2 ] ) + 1 ] = list ( c [ 3 ] ) <NEWLINE> <DEDENT> if c [ 0 ] == <STRING> : <NEWLINE> <INDENT> s [ int ( c [ 1 ] ) : int ( c [ 2 ] ) + 1 ] = s [ int ( c [ 1 ] ) : int ( c [ 2 ) + 1 ] [ : : - 1 ] <NEWLINE> <DEDENT> if c [ 0 ] == <STRING> : <NEWLINE> <INDENT> print <STRING> . join ( s [ int ( c [ 1 ] ) : int ( c [ 2 ] ) + 1 ] <NEWLINE> <DEDENT> <DEDENT>
n = input ( ) <NEWLINE> l = [ <STRING> , <STRING> , <STRING> ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> c = map ( str , raw_input ( ) . split ( ) ) <NEWLINE> if c [ 0 ] == l [ 0 ] : <NEWLINE> <INDENT> print w [ int ( c [ 1 ] ) : int ( c [ 2 ] ) + 1 ] <NEWLINE> <DEDENT> elif c [ 0 ] == l [ 1 ] : <NEWLINE> <INDENT> w = w [ : int ( c [ 1 ] ) ] + c [ 3 ] + w [ int ( c [ 2 ] ) + 1 : ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> w = w [ int ( c [ 1 ] ) : int ( c [ 2 ] ) + 1 ] [ : : - 1 ] + w [ int ( c [ 2 ] ) + 1 : ] <NEWLINE> <DEDENT> <DEDENT>
<INDENT> s = s [ 0 : a ] + s [ a : b + 1 ] [ : : - 1 ] + s [ b + 1 : ] <NEWLINE> <DEDENT>
def pushBack ( lists , x ) : <NEWLINE> <INDENT> return lists . insert ( - 1 , x ) <NEWLINE> <NL> <DEDENT> def randomAccess ( lists , p ) : <NEWLINE> <INDENT> print ( lists [ p ] ) <NEWLINE> <NL> <DEDENT> def popBack ( lists ) : <NEWLINE> <INDENT> return lists . pop ( - 1 ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> l = list ( ) <NEWLINE> n = int ( input ( ) ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> j = input ( ) . split ( ) <NEWLINE> <NL> if int ( j [ 0 ] ) == 0 : <NEWLINE> <INDENT> pushBack ( l , x ) <NEWLINE> <DEDENT> elif int ( j [ 0 ] ) == 1 : <NEWLINE> <INDENT> randomAccess ( l , x ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> popBack ( l ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT>
cnt = int ( input ( ) ) <NEWLINE> a = [ ] <NEWLINE> for i in range ( cnt ) : <NEWLINE> <INDENT> li = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if li [ 0 ] == 0 : <NEWLINE> <INDENT> a . append ( n ) <NEWLINE> <DEDENT> elif li [ 0 ] == 1 : <NEWLINE> <INDENT> print ( a [ n ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a . pop ( - 1 ) <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> <NL> from collections import deque <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> word = deque ( ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> command , num = map ( int , input ( ) . split ( ) ) <NEWLINE> if command == 0 : <NEWLINE> <INDENT> word . append ( num ) <NEWLINE> <DEDENT> elif command == 1 : <NEWLINE> <INDENT> print ( <STRING> . format ( word [ num ] ) ) <NEWLINE> <DEDENT> elif command == 2 : <NEWLINE> <INDENT> word . pop ( ) <NEWLINE> <NL> <DEDENT> <DEDENT>
from collections import deque <NEWLINE> <NL> def push ( duque , d , x ) : <NEWLINE> <INDENT> if d == 0 : <NEWLINE> <INDENT> duque . append ( x ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> duque . insert ( len ( duque ) , x ) <NEWLINE> <DEDENT> return duque . appendleft ( x ) <NEWLINE> <NL> <DEDENT> def randomAccess ( duque , p ) : <NEWLINE> <INDENT> print ( duque . index ( p ) ) <NEWLINE> <NL> <DEDENT> def pop ( duque , d ) : <NEWLINE> <INDENT> if d == 0 : <NEWLINE> <INDENT> duque . pop ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> duque . popleft ( ) <NEWLINE> <DEDENT> return duque <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> l = deque ( [ ] ) <NEWLINE> n = int ( input ( ) ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> j = input ( ) . split ( ) <NEWLINE> <NL> if int ( j [ 0 ] ) == 0 : <NEWLINE> <INDENT> push ( l , int ( j [ 1 ] ) , int ( j [ 2 ] ) ) <NEWLINE> <DEDENT> elif int ( j [ 0 ] ) == 1 : <NEWLINE> <INDENT> randomAccess ( l , int ( j [ 1 ] ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> pop ( l , int ( j [ 1 ] ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
<COMMENT> <NL> <NL> class Deque2 ( object ) : <NEWLINE> <INDENT> def __init__ ( self ) : <NEWLINE> <INDENT> self . a = list ( ) <NEWLINE> <NL> <DEDENT> def push ( self , d , x ) : <NEWLINE> <INDENT> if d == 0 : <NEWLINE> <INDENT> self . a = [ x ] + self . a <NEWLINE> <DEDENT> elif d == 1 : <NEWLINE> <INDENT> self . a . append ( x ) <NEWLINE> <NL> <DEDENT> <DEDENT> def randomAccess ( self , p ) : <NEWLINE> <INDENT> print self . a [ p ] <NEWLINE> <NL> <DEDENT> def pop ( self , d ) : <NEWLINE> <INDENT> if d == 0 : <NEWLINE> <INDENT> self . a = self . a [ 1 : ] <NEWLINE> <DEDENT> elif d == 1 : <NEWLINE> <INDENT> self . a = self . a [ : - 1 ] <NEWLINE> <NL> <DEDENT> <DEDENT> def __repr__ ( self ) : <NEWLINE> <INDENT> return <STRING> . join ( [ str ( i ) for i in self . a ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> d = Deque2 ( ) <NEWLINE> q = int ( raw_input ( ) ) <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> query = [ int ( j ) for j in raw_input ( ) . split ( ) ] <NEWLINE> if query [ 0 ] == 0 : <NEWLINE> <INDENT> d . push ( query [ 1 ] , query [ 2 ] ) <NEWLINE> <DEDENT> elif query [ 0 ] == 1 : <NEWLINE> <INDENT> d . randomAccess ( query [ 1 ] ) <NEWLINE> <DEDENT> elif query [ 0 ] == 2 : <NEWLINE> <INDENT> d . pop ( query [ 1 ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
cnt = int ( input ( ) ) <NEWLINE> a = [ ] <NEWLINE> for i in range ( cnt ) : <NEWLINE> <INDENT> li = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if li [ 0 ] == 0 : <NEWLINE> <INDENT> if li [ 1 ] == 0 : <NEWLINE> <INDENT> a . insert ( 0 , li [ 2 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a . insert ( - 1 , li [ 2 ] ) <NEWLINE> <DEDENT> <DEDENT> if li [ 0 ] == 1 : <NEWLINE> <INDENT> print ( a [ li [ 1 ] ] ) <NEWLINE> <DEDENT> if li [ 0 ] == 2 : <NEWLINE> <INDENT> if li [ 1 ] == 0 : <NEWLINE> <INDENT> a . popleft ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a . pop ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
a , b , c = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> print ( <STRING> . format ( min ( [ a , b , c ] , max ( [ a , b , c ] ) ) ) <NEWLINE> <NL>
nums = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> <NL> max = - float ( <STRING> ) <NEWLINE> min = flaot ( <STRING> ) <NEWLINE> for num in nums : <NEWLINE> <INDENT> if num > max : max = num <NEWLINE> if num < min : min = num <NEWLINE> <NL> <DEDENT> print ( min , max ) <NEWLINE> <NL>
n = int ( input ( ) ) <NEWLINE> nums = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> <NL> q = int ( input ( ) ) <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> op = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> if op [ 0 ] == 0 : <NEWLINE> <INDENT> min = float ( <STRING> ) <NEWLINE> for num in nums [ op [ 1 ] , op [ 2 ] ] : <NEWLINE> <INDENT> if num < min : min = num <NEWLINE> <DEDENT> print ( min ) <NEWLINE> <DEDENT> elif op [ 0 ] == 1 : <NEWLINE> <INDENT> max = - float ( <STRING> ) <NEWLINE> for num in nums [ op [ 1 ] , op [ 2 ] ] : <NEWLINE> <INDENT> if num < max : max = num <NEWLINE> <DEDENT> print ( max ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) <NEWLINE> m = int ( input ( ) ) <NEWLINE> b = list ( map ( int , input ( ) ) ) <NEWLINE> <NL> la = len ( a ) <NEWLINE> lb = len ( b ) <NEWLINE> l = min ( la , lb ) <NEWLINE> <NL> for i in range ( l ) : <NEWLINE> <INDENT> if a [ i ] < b [ i ] : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> break <NEWLINE> <DEDENT> elif a [ i ] > b [ i ] : <NEWLINE> <INDENT> print ( 2 ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if la < lb : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 2 ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> <NL> def binary_search ( val ) : <NEWLINE> <INDENT> left , right = 0 , n - 1 <NEWLINE> while right - left >= 1 : <NEWLINE> <INDENT> mid = ( right + left ) // 2 <NEWLINE> if a [ mid ] == val : return 1 <NEWLINE> if a [ mid ] < val : <NEWLINE> <INDENT> left = mid <NEWLINE> <DEDENT> elif val < a [ mid ] : <NEWLINE> <INDENT> right = mid <NEWLINE> <DEDENT> <DEDENT> return 0 <NEWLINE> <NL> <DEDENT> q = int ( input ( ) ) <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> k = int ( input ( ) ) <NEWLINE> print ( binary_search ( k ) ) <NEWLINE> <NL> <DEDENT>
from enum import Enum <NEWLINE> <NL> <NL> class Color ( Enum ) : <NEWLINE> <INDENT> BLACK = 0 <NEWLINE> RED = 1 <NEWLINE> <NL> @ staticmethod <NEWLINE> def flip ( c ) : <NEWLINE> <INDENT> return [ Color . RED , Color . BLACK ] [ c . value ] <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> class Node : <NEWLINE> <INDENT> __slots__ = ( <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ) <NEWLINE> <NL> def __init__ ( self , key , value ) : <NEWLINE> <INDENT> self . key = key <NEWLINE> self . value = value <NEWLINE> self . left = Leaf <NEWLINE> self . right = Leaf <NEWLINE> self . size = 1 <NEWLINE> self . color = Color . RED <NEWLINE> <NL> <DEDENT> def is_red ( self ) : <NEWLINE> <INDENT> return self . color == Color . RED <NEWLINE> <NL> <DEDENT> def is_black ( self ) : <NEWLINE> <INDENT> return self . color == Color . BLACK <NEWLINE> <NL> <DEDENT> def __str__ ( self ) : <NEWLINE> <INDENT> if self . color == Color . RED : <NEWLINE> <INDENT> key = <STRING> . format ( self . key ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> key = <STRING> . format ( self . key ) <NEWLINE> <DEDENT> return <STRING> . format ( key , self . size , <NEWLINE> <INDENT> self . left , self . right ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> class LeafNode ( Node ) : <NEWLINE> <INDENT> def __init__ ( self ) : <NEWLINE> <INDENT> self . key = None <NEWLINE> self . value = None <NEWLINE> self . left = None <NEWLINE> self . right = None <NEWLINE> self . size = 0 <NEWLINE> self . color = None <NEWLINE> <NL> <DEDENT> def is_red ( self ) : <NEWLINE> <INDENT> return False <NEWLINE> <NL> <DEDENT> def is_black ( self ) : <NEWLINE> <INDENT> return False <NEWLINE> <NL> <DEDENT> def __str__ ( self ) : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> Leaf = LeafNode ( ) <NEWLINE> <NL> <NL> class RedBlackBinarySearchTree : <NEWLINE> <INDENT> <STRING> <NEWLINE> <NL> def __init__ ( self ) : <NEWLINE> <INDENT> self . root = Leaf <NEWLINE> <NL> <DEDENT> def put ( self , key , value = None ) : <NEWLINE> <INDENT> def _put ( node ) : <NEWLINE> <INDENT> if node is Leaf : <NEWLINE> <INDENT> node = Node ( key , value ) <NEWLINE> <DEDENT> if node . key > key : <NEWLINE> <INDENT> node . left = _put ( node . left ) <NEWLINE> <DEDENT> elif node . key < key : <NEWLINE> <INDENT> node . right = _put ( node . right ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> node . value = value <NEWLINE> <NL> <DEDENT> node = self . _restore ( node ) <NEWLINE> <NL> node . size = node . left . size + node . right . size + 1 <NEWLINE> return node <NEWLINE> <NL> <DEDENT> self . root = _put ( self . root ) <NEWLINE> self . root . color = Color . BLACK <NEWLINE> <NL> <DEDENT> def _rotate_left ( self , node ) : <NEWLINE> <INDENT> assert node . right . is_red ( ) <NEWLINE> x = node . right <NEWLINE> node . right = x . left <NEWLINE> x . left = node <NEWLINE> x . color = node . color <NEWLINE> node . color = Color . RED <NEWLINE> node . size = node . left . size + node . right . size + 1 <NEWLINE> return x <NEWLINE> <NL> <DEDENT> def _rotate_right ( self , node ) : <NEWLINE> <INDENT> assert node . left . is_red ( ) <NEWLINE> x = node . left <NEWLINE> node . left = x . right <NEWLINE> x . right = node <NEWLINE> x . color = node . color <NEWLINE> node . color = Color . RED <NEWLINE> node . size = node . left . size + node . right . size + 1 <NEWLINE> return x <NEWLINE> <NL> <DEDENT> def _flip_colors ( self , node ) : <NEWLINE> <INDENT> node . color = Color . flip ( node . color ) <NEWLINE> node . left . color = Color . flip ( node . left . color ) <NEWLINE> node . right . color = Color . flip ( node . right . color ) <NEWLINE> return node <NEWLINE> <NL> <DEDENT> def __contains__ ( self , key ) : <NEWLINE> <INDENT> def _contains ( node ) : <NEWLINE> <INDENT> if node is Leaf : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> if node . key > key : <NEWLINE> <INDENT> return _contains ( node . left ) <NEWLINE> <DEDENT> elif node . key < key : <NEWLINE> <INDENT> return _contains ( node . right ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> <DEDENT> return _contains ( self . root ) <NEWLINE> <NL> <DEDENT> def get ( self , key ) : <NEWLINE> <INDENT> def _get ( node ) : <NEWLINE> <INDENT> if node is Leaf : <NEWLINE> <INDENT> return None <NEWLINE> <DEDENT> if node . key > key : <NEWLINE> <INDENT> return _get ( node . left ) <NEWLINE> <DEDENT> elif node . key < key : <NEWLINE> <INDENT> return _get ( node . right ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return node . value <NEWLINE> <DEDENT> <DEDENT> return _get ( self . root ) <NEWLINE> <NL> <DEDENT> def delete ( self , key ) : <NEWLINE> <INDENT> def _delete ( node ) : <NEWLINE> <INDENT> if node is Leaf : <NEWLINE> <INDENT> return Leaf <NEWLINE> <NL> <DEDENT> if node . key > key : <NEWLINE> <INDENT> if node . left is Leaf : <NEWLINE> <INDENT> return self . _balance ( node ) <NEWLINE> <DEDENT> if not self . _is_red_left ( node ) : <NEWLINE> <INDENT> node = self . _red_left ( node ) <NEWLINE> <DEDENT> node . left = _delete ( node . left ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if node . left . is_red ( ) : <NEWLINE> <INDENT> node = self . _rotate_right ( node ) <NEWLINE> <DEDENT> if node . key == key and node . right is Leaf : <NEWLINE> <INDENT> return Leaf <NEWLINE> <DEDENT> elif node . right is Leaf : <NEWLINE> <INDENT> return self . _balance ( node ) <NEWLINE> <DEDENT> if not self . _is_red_right ( node ) : <NEWLINE> <INDENT> node = self . _red_right ( node ) <NEWLINE> <DEDENT> if node . key == key : <NEWLINE> <INDENT> x = self . _find_min ( node . right ) <NEWLINE> node . key = x . key <NEWLINE> node . value = x . value <NEWLINE> node . right = self . _delete_min ( node . right ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> node . right = _delete ( node . right ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if self . is_empty ( ) : <NEWLINE> <INDENT> raise ValueError ( <STRING> ) <NEWLINE> <DEDENT> if not self . root . left . is_red ( ) and not self . root . right . is_red ( ) : <NEWLINE> <INDENT> self . root . color = Color . RED <NEWLINE> <DEDENT> self . root = _delete ( self . root ) <NEWLINE> if not self . is_empty ( ) : <NEWLINE> <INDENT> self . root . color = Color . BLACK <NEWLINE> <NL> <DEDENT> <DEDENT> def delete_max ( self ) : <NEWLINE> <INDENT> if self . is_empty ( ) : <NEWLINE> <INDENT> raise ValueError ( <STRING> ) <NEWLINE> <DEDENT> if not self . root . left . is_red ( ) and not self . root . right . is_red ( ) : <NEWLINE> <INDENT> self . root . color = Color . RED <NEWLINE> <DEDENT> self . root = self . _delete_max ( self . root ) <NEWLINE> if not self . is_empty ( ) : <NEWLINE> <INDENT> self . root . color = Color . BLACK <NEWLINE> <NL> <DEDENT> <DEDENT> def _delete_max ( self , node ) : <NEWLINE> <INDENT> if node . left . is_red ( ) : <NEWLINE> <INDENT> node = self . _rotate_right ( node ) <NEWLINE> <DEDENT> if node . right is Leaf : <NEWLINE> <INDENT> return Leaf <NEWLINE> <NL> <DEDENT> if not self . _is_red_right ( node ) : <NEWLINE> <INDENT> node = self . _red_right ( node ) <NEWLINE> <DEDENT> node . right = self . _delete_max ( node . right ) <NEWLINE> <NL> <DEDENT> def _red_right ( self , node ) : <NEWLINE> <INDENT> node = self . _flip_colors ( node ) <NEWLINE> if node . left . left . is_red ( ) : <NEWLINE> <INDENT> node = self . _rotate_right ( node ) <NEWLINE> <DEDENT> return node <NEWLINE> <NL> <DEDENT> def _is_red_right ( self , node ) : <NEWLINE> <INDENT> return ( node . right . is_red ( ) or <NEWLINE> <INDENT> ( node . right . is_black ( ) and node . right . left . is_red ( ) ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> def delete_min ( self ) : <NEWLINE> <INDENT> if self . is_empty ( ) : <NEWLINE> <INDENT> raise ValueError ( <STRING> ) <NEWLINE> <NL> <DEDENT> if not self . root . left . is_red ( ) and not self . root . right . is_red ( ) : <NEWLINE> <INDENT> self . root . color = Color . RED <NEWLINE> <DEDENT> self . root = self . _delete_min ( self . root ) <NEWLINE> if not self . is_empty ( ) : <NEWLINE> <INDENT> self . root . color = Color . BLACK <NEWLINE> <NL> <DEDENT> <DEDENT> def _delete_min ( self , node ) : <NEWLINE> <INDENT> if node . left is Leaf : <NEWLINE> <INDENT> return Leaf <NEWLINE> <NL> <DEDENT> if not self . _is_red_left ( node ) : <NEWLINE> <INDENT> node = self . _red_left ( node ) <NEWLINE> <DEDENT> node . left = self . _delete_min ( node . left ) <NEWLINE> return self . _balance ( node ) <NEWLINE> <NL> <DEDENT> def _red_left ( self , node ) : <NEWLINE> <INDENT> node = self . _flip_colors ( node ) <NEWLINE> if node . right . left . is_red ( ) : <NEWLINE> <INDENT> node . right = self . _rotate_right ( node . right ) <NEWLINE> node = self . _rotate_left ( node ) <NEWLINE> <DEDENT> return node <NEWLINE> <NL> <DEDENT> def _is_red_left ( self , node ) : <NEWLINE> <INDENT> return ( node . left . is_red ( ) or <NEWLINE> <INDENT> ( node . left . is_black ( ) and node . left . left . is_red ( ) ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> def _balance ( self , node ) : <NEWLINE> <INDENT> if node . right . is_red ( ) : <NEWLINE> <INDENT> node = self . _rotate_left ( node ) <NEWLINE> <DEDENT> return self . _restore ( node ) <NEWLINE> <NL> <DEDENT> def _restore ( self , node ) : <NEWLINE> <INDENT> if node . right . is_red ( ) and not node . left . is_red ( ) : <NEWLINE> <INDENT> node = self . _rotate_left ( node ) <NEWLINE> <DEDENT> if node . left . is_red ( ) and node . left . left . is_red ( ) : <NEWLINE> <INDENT> node = self . _rotate_right ( node ) <NEWLINE> <DEDENT> if node . left . is_red ( ) and node . right . is_red ( ) : <NEWLINE> <INDENT> node = self . _flip_colors ( node ) <NEWLINE> <NL> <DEDENT> node . size = node . left . size + node . right . size + 1 <NEWLINE> return node <NEWLINE> <NL> <DEDENT> def is_empty ( self ) : <NEWLINE> <INDENT> return self . root is Leaf <NEWLINE> <NL> <DEDENT> def is_balanced ( self ) : <NEWLINE> <INDENT> if self . is_empty ( ) : <NEWLINE> <INDENT> return True <NEWLINE> <NL> <DEDENT> try : <NEWLINE> <INDENT> left = self . _depth ( self . root . left ) <NEWLINE> right = self . _depth ( self . root . right ) <NEWLINE> return left == right <NEWLINE> <DEDENT> except Exception : <NEWLINE> <INDENT> return False <NEWLINE> <NL> <DEDENT> <DEDENT> @ property <NEWLINE> def depth ( self ) : <NEWLINE> <INDENT> return self . _depth ( self . root ) <NEWLINE> <NL> <DEDENT> def _depth ( self , node ) : <NEWLINE> <INDENT> if node is Leaf : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> if node . right . is_red ( ) : <NEWLINE> <INDENT> raise Exception ( <STRING> ) <NEWLINE> <DEDENT> left = self . _depth ( node . left ) <NEWLINE> right = self . _depth ( node . right ) <NEWLINE> if left != right : <NEWLINE> <INDENT> raise Exception ( <STRING> ) <NEWLINE> <DEDENT> if node . is_red ( ) : <NEWLINE> <INDENT> return left <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return 1 + left <NEWLINE> <NL> <DEDENT> <DEDENT> def __len__ ( self ) : <NEWLINE> <INDENT> return self . root . size <NEWLINE> <NL> <DEDENT> @ property <NEWLINE> def max ( self ) : <NEWLINE> <INDENT> if self . is_empty ( ) : <NEWLINE> <INDENT> raise ValueError ( <STRING> ) <NEWLINE> <DEDENT> return self . _max ( self . root ) <NEWLINE> <NL> <DEDENT> def _max ( self , node ) : <NEWLINE> <INDENT> x = self . _find_max ( node ) <NEWLINE> return x . key <NEWLINE> <NL> <DEDENT> def _find_max ( self , node ) : <NEWLINE> <INDENT> if node . right is Leaf : <NEWLINE> <INDENT> return node <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return self . _find_max ( node . right ) <NEWLINE> <NL> <DEDENT> <DEDENT> @ property <NEWLINE> def min ( self ) : <NEWLINE> <INDENT> if self . is_empty ( ) : <NEWLINE> <INDENT> raise ValueError ( <STRING> ) <NEWLINE> <DEDENT> return self . _min ( self . root ) <NEWLINE> <NL> <DEDENT> def _min ( self , node ) : <NEWLINE> <INDENT> x = self . _find_min ( node ) <NEWLINE> return x . key <NEWLINE> <NL> <DEDENT> def _find_min ( self , node ) : <NEWLINE> <INDENT> if node . left is Leaf : <NEWLINE> <INDENT> return node <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return self . _find_min ( node . left ) <NEWLINE> <NL> <DEDENT> <DEDENT> def __iter__ ( self ) : <NEWLINE> <INDENT> def inorder ( node ) : <NEWLINE> <INDENT> if node is Leaf : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> yield from inorder ( node . left ) <NEWLINE> yield node . value <NEWLINE> yield from inorder ( node . right ) <NEWLINE> <DEDENT> yield from inorder ( self . root ) <NEWLINE> <NL> <DEDENT> def range ( self , min_ , max_ ) : <NEWLINE> <INDENT> def _range ( node ) : <NEWLINE> <INDENT> if node is Leaf : <NEWLINE> <INDENT> return <NEWLINE> <NL> <DEDENT> if node . key > max_ : <NEWLINE> <INDENT> yield from _range ( node . left ) <NEWLINE> <DEDENT> elif node . key < min_ : <NEWLINE> <INDENT> yield from _range ( node . right ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> yield from _range ( node . left ) <NEWLINE> yield ( node . key , node . value ) <NEWLINE> yield from _range ( node . right ) <NEWLINE> <NL> <DEDENT> <DEDENT> if min_ > max_ : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> yield from _range ( self . root ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> class Map : <NEWLINE> <NL> <INDENT> def __init__ ( self ) : <NEWLINE> <INDENT> self . tree = RedBlackBinarySearchTree ( ) <NEWLINE> <NL> <DEDENT> def __getitem__ ( self , key ) : <NEWLINE> <INDENT> if key in self . tree : <NEWLINE> <INDENT> return self . tree . get ( key ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> raise IndexError ( <STRING> . format ( key ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> def __setitem__ ( self , key , value ) : <NEWLINE> <INDENT> self . tree . put ( key , value ) <NEWLINE> <NL> <DEDENT> def __delitem__ ( self , key ) : <NEWLINE> <INDENT> if key in self . tree : <NEWLINE> <INDENT> self . tree . delete ( key ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> raise IndexError ( <STRING> . format ( key ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> def __len__ ( self ) : <NEWLINE> <INDENT> return len ( self . tree ) <NEWLINE> <NL> <DEDENT> def items ( self ) : <NEWLINE> <INDENT> for k , v in self . tree : <NEWLINE> <INDENT> yield ( k , v ) <NEWLINE> <NL> <DEDENT> <DEDENT> def range ( self , min_ , max_ ) : <NEWLINE> <INDENT> for k , v in self . tree . range ( min_ , max_ ) : <NEWLINE> <INDENT> yield ( k , v ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> def run ( ) : <NEWLINE> <INDENT> q = int ( input ( ) ) <NEWLINE> m = Map ( ) <NEWLINE> <NL> for _ in range ( q ) : <NEWLINE> <INDENT> command , * args = input ( ) . split ( ) <NEWLINE> if command == <STRING> : <NEWLINE> <INDENT> key = args [ 0 ] <NEWLINE> value = int ( args [ 1 ] ) <NEWLINE> m [ key ] = value <NEWLINE> <DEDENT> elif command == <STRING> : <NEWLINE> <INDENT> key = args [ 0 ] <NEWLINE> try : <NEWLINE> <INDENT> print ( m [ key ] ) <NEWLINE> <DEDENT> except IndexError : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> <DEDENT> elif command == <STRING> : <NEWLINE> <INDENT> key = args [ 0 ] <NEWLINE> try : <NEWLINE> <INDENT> del m [ key ] <NEWLINE> <DEDENT> except IndexError : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> <DEDENT> elif command == <STRING> : <NEWLINE> <INDENT> low , hi = args <NEWLINE> for k , v in m . range ( low , hi ) : <NEWLINE> <INDENT> print ( k , v ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> raise ValueError ( <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> run ( ) <NEWLINE> <DEDENT>
def simple_prime_factrize ( x ) : <NEWLINE> <INDENT> pfs = [ ] <NEWLINE> for y in range ( 2 , math . ceil ( math . sqrt ( x ) ) ) : <NEWLINE> <INDENT> if x == 1 : break <NEWLINE> while True : <NEWLINE> <INDENT> if x % y == 0 : <NEWLINE> <INDENT> pfs . append ( y ) <NEWLINE> x = x / y <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if len ( pfs ) == 0 : <NEWLINE> <INDENT> pfs . append ( x ) <NEWLINE> <DEDENT> return pfs <NEWLINE> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> print ( str ( n ) + <STRING> + <STRING> . join ( [ str ( x ) for x in simple_prime_factrize ( n ) ] ) ) <NEWLINE>
n = input ( ) <NEWLINE> l = [ ] <NEWLINE> l += [ str ( n ) + <STRING> ] <NEWLINE> while 1 : <NEWLINE> <INDENT> if n == 1 : break <NEWLINE> for i in range ( 2 , n + 1 ) : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> n /= i <NEWLINE> l += [ i ] <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print <STRING> . join ( map ( str , l ) ) <NEWLINE>
n = input ( ) <NEWLINE> l = [ ] <NEWLINE> l += [ str ( n ) + <STRING> ] <NEWLINE> while 1 : <NEWLINE> <INDENT> if n == 1 : break <NEWLINE> for i in xrange ( 2 , n + 1 ) : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> n /= i <NEWLINE> l += [ i ] <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print <STRING> . join ( map ( str , l ) ) <NEWLINE>
p = lambda x : print ( x , end = <STRING> ) <NEWLINE> m = n = input ( ) ; p ( n + <STRING> ) <NEWLINE> n = int ( n ) <NEWLINE> while n % 2 == 0 and n > 3 : p ( 2 ) ; n //= 2 <NEWLINE> d = 3 <NEWLINE> while d * d < m and n > d : <NEWLINE> <INDENT> if n % d > 0 : d += 2 <NEWLINE> else : p ( d ) ; n //= d <NEWLINE> <DEDENT> print ( n ) <NEWLINE>
p = lambda x : print ( x , end = <STRING> ) <NEWLINE> n = input ( ) : p ( n + <STRING> ) <NEWLINE> n = int ( n ) ; s = n ** .5 <NEWLINE> while n % 2 == 0 and n > 3 : p ( 2 ) ; n //= 2 <NEWLINE> d = 3 <NEWLINE> while s > d and n > d : <NEWLINE> <INDENT> if n % d == 0 : p ( d ) ; n //= d <NEWLINE> else : d += 2 <NEWLINE> <DEDENT> print ( n ) <NEWLINE>
n = input ( ) <NEWLINE> N = n <NEWLINE> a = [ ] <NEWLINE> <NL> while n > 1 : <NEWLINE> <INDENT> for i in range ( 2 , N + 1 ) : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> n = n / i <NEWLINE> a . append ( str ( i ) ) <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print str ( N ) + <STRING> + <STRING> . join ( a ) <NEWLINE> <NL>
n = input ( ) <NEWLINE> l = [ ] <NEWLINE> l += [ str ( n ) + <STRING> ] <NEWLINE> i = 2 <NEWLINE> while i * i <= n : <NEWLINE> <INDENT> while n % i == 0 : <NEWLINE> <INDENT> l += [ i ] <NEWLINE> <DEDENT> i += 1 <NEWLINE> <DEDENT> if n > 1 : l += [ n ] <NEWLINE> print <STRING> . join ( map ( str , l ) ) <NEWLINE>
import math <NEWLINE> <NL> s = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> print <STRING> % ( math . pow ( s [ 0 ] , s [ 1 ] ) % 1000000007 ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <NL> <STRING> <NEWLINE> <NL> import sys <NEWLINE> <NL> <NL> def mod_pow ( x , n , _mod ) : <NEWLINE> <INDENT> res = 1 <NEWLINE> while n > 0 : <NEWLINE> <COMMENT> <NL> <INDENT> if n % 2 : <NEWLINE> <INDENT> res = res * x % _mod <NEWLINE> <DEDENT> x = pow ( x , 2 ) % _mod <NEWLINE> n //= 1 <NEWLINE> <DEDENT> return res <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> _input = sys . stdin . readlines ( ) <NEWLINE> n1 , n2 = map ( int , _input [ 0 ] . split ( ) ) <NEWLINE> M = 1000000007 <NEWLINE> <COMMENT> <NL> print ( mod_pow ( n1 , n2 , M ) ) <NEWLINE> <DEDENT>
m , n = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> N = n <NEWLINE> M = 10 ** 9 + 7 <NEWLINE> <NL> ans = m <NEWLINE> c = 1 <NEWLINE> while n > 1 : <NEWLINE> <INDENT> ans = ans ** 2 <NEWLINE> ans %= M <NEWLINE> n /= 2 <NEWLINE> c *= 2 <NEWLINE> <NL> <DEDENT> print ( ans * ( m ** ( N - c ) ) ) % M <NEWLINE>
m , n = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( pow ( m , n , int ( 1e9 ) + 7 ) ) javascript : void ( 0 ) <NEWLINE>
d = 1000000007 <NEWLINE> <NL> def pow_rem ( x , n ) : <NEWLINE> <INDENT> if n == 0 : <NEWLINE> <INDENT> return x ** n % d <NEWLINE> <DEDENT> if n % 2 == 0 : <NEWLINE> <INDENT> return pow_rem ( x , n // 2 ) ** 2 % d <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return ( ( pow_rem ( x , n // 2 ) ** 2 ) * x ) % d <NEWLINE> <NL> <DEDENT> <DEDENT> def solve ( ) : <NEWLINE> <INDENT> m , n = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( pow_rem ( m , n ) <NEWLINE> <NL> <DEDENT> solve ( ) <NEWLINE>
print ( pow ( int ( input ( ) ) , int ( input ( ) ) , int ( 1e9 + 7 ) ) ) <NEWLINE>
import math <NEWLINE> print ( math . pow ( map ( int , input ( ) ) ) ) <NEWLINE>
import math <NEWLINE> def sieve ( n ) : <NEWLINE> <INDENT> p = [ 1 ] * ( n + 1 ) <NEWLINE> p [ 0 ] = p [ 1 ] = 0 <NEWLINE> <NL> for i in range ( math . ceil ( ( n + 1 ) ** 0.5 ) ) : <NEWLINE> <INDENT> if p [ i ] : <NEWLINE> <INDENT> for j in range ( 2 * i , len ( p ) , i ) : <NEWLINE> <INDENT> p [ j ] = 0 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return p <NEWLINE> <NL> <DEDENT> def prime_factor ( n ) : <NEWLINE> <INDENT> p = sieve ( int ( n ** 0.5 ) ) <NEWLINE> factor = [ ] <NEWLINE> for pi in compress ( count ( 0 ) , p ) : <NEWLINE> <INDENT> while n % pi == 0 : <NEWLINE> <INDENT> n //= pi <NEWLINE> factor . append ( pi ) <NEWLINE> <NL> <DEDENT> <DEDENT> if n != 1 : <NEWLINE> <INDENT> factor . append ( n ) <NEWLINE> <DEDENT> return factor <NEWLINE> <NL> <DEDENT> from collections import Counter <NEWLINE> from sys import stdin <NEWLINE> readline = stdin . readline <NEWLINE> <NL> n = int ( readline ( ) ) <NEWLINE> c = [ Counter ( prime_factor ( ai ) ) for ai in map ( int , readline ( ) . split ( ) ) ] <NEWLINE> s = set ( ) <NEWLINE> for ci in c : <NEWLINE> <INDENT> s . update ( ci . keys ( ) ) <NEWLINE> <NL> <DEDENT> ret = 1 <NEWLINE> for i in [ i ** max ( ci [ i ] for ci in c ) for i in s ] : <NEWLINE> <INDENT> ret *= i <NEWLINE> <DEDENT> print ( ret ) <NEWLINE>
import sys <NEWLINE> <NL> def multiple_all ( x ) : <NEWLINE> <INDENT> count = 1 <NEWLINE> for i in range ( 0 , len ( x ) ) : <NEWLINE> <INDENT> count *= x [ i ] <NEWLINE> <DEDENT> return count <NEWLINE> <NL> <DEDENT> def least_common_multiple ( x ) : <NEWLINE> <INDENT> for i in range ( min ( x ) , multiple_all ( x ) ) : <NEWLINE> <INDENT> j = 0 <NEWLINE> while ( j < len ( x ) ) : <NEWLINE> <INDENT> if ( i % x [ j ] != 0 ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> j += 1 <NEWLINE> <DEDENT> if ( j == len ( x ) ) : <NEWLINE> <INDENT> return i <NEWLINE> <DEDENT> <DEDENT> return multiple_all ( x ) <NEWLINE> <NL> <DEDENT> l = [ ] <NEWLINE> for input in sys . stdin : <NEWLINE> <INDENT> l . append ( input . split ( ) ) <NEWLINE> <DEDENT> l = l [ 1 : ] <NEWLINE> temp = [ ] <NEWLINE> for i in range ( 0 , len ( l [ 0 ] ) ) : <NEWLINE> <INDENT> temp . append ( int ( l [ 0 ] [ i ] ) ) <NEWLINE> <DEDENT> print least_common_multiple ( temp ) <NEWLINE>
def gcd ( a , b ) : <NEWLINE> <INDENT> if b == 0 : <NEWLINE> <INDENT> return a <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return gcd ( b , a % b ) <NEWLINE> <NL> <DEDENT> <DEDENT> n = int ( raw_input ( ) ) <NEWLINE> an = map ( int , raw_input ( ) ) <NEWLINE> l = a [ 0 ] <NEWLINE> <NL> for i in range ( 1 , len ( a ) - 1 ) : <NEWLINE> <INDENT> b = a [ i ] <NEWLINE> g = gcd ( l , b ) <NEWLINE> l = a * b / g <NEWLINE> <DEDENT> print l <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <NL> <STRING> <NEWLINE> <NL> import sys <NEWLINE> <NL> <NL> def is_prime ( n ) : <NEWLINE> <INDENT> if n == 2 : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> elif n < 2 or not n % 2 : <NEWLINE> <INDENT> return False <NEWLINE> <NL> <DEDENT> return pow ( 2 , n - 1 , n ) == 1 <NEWLINE> <NL> <NL> <DEDENT> def min_prime_factor ( n ) : <NEWLINE> <INDENT> if is_prime ( n ) : <NEWLINE> <INDENT> return n <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> k = 2 <NEWLINE> while True : <NEWLINE> <INDENT> if not n % k : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> k += 1 <NEWLINE> <DEDENT> <DEDENT> return k <NEWLINE> <NL> <NL> <DEDENT> def phi ( n ) : <NEWLINE> <INDENT> ans = n <NEWLINE> while True : <NEWLINE> <INDENT> p = min_prime_factor ( n ) <NEWLINE> if n == 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> while n % p == 0 : <NEWLINE> <COMMENT> <NL> <INDENT> n //= p <NEWLINE> <DEDENT> ans *= ( 1 - 1 / p ) <NEWLINE> <DEDENT> return int ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> _input = sys . stdin . readlines ( ) <NEWLINE> n1 = int ( _input [ 0 ] ) <NEWLINE> print ( phi ( n1 ) ) <NEWLINE> <DEDENT>
p = 1 ; a = [ ] <NEWLINE> n = int ( input ( ) ) ; s = n ** .5 <NEWLINE> while n % 2 == 0 and n > 3 : a += [ 2 ] ; n //= 2 <NEWLINE> d = 3 <NEWLINE> while s > d and n > d : <NEWLINE> <INDENT> if n % d == 0 : a += [ d ] ; n //= d <NEWLINE> else : d += 2 <NEWLINE> <DEDENT> a += [ n ] <NEWLINE> for f in set ( a ) : <NEWLINE> <INDENT> p *= f ** a . count ( f ) * ( 1 - 1 / f ) <NEWLINE> <DEDENT> print ( int ( p ) <NEWLINE>
from itertools import compress , count <NEWLINE> def prime_factor ( n ) : <NEWLINE> <INDENT> p = sieve ( int ( n ** 0.5 ) ) <NEWLINE> factor = [ ] <NEWLINE> for pi in compress ( count ( 0 ) , p ) : <NEWLINE> <INDENT> while n % pi == 0 : <NEWLINE> <INDENT> n //= pi <NEWLINE> factor . append ( pi ) <NEWLINE> <NL> <DEDENT> <DEDENT> if n != 1 : <NEWLINE> <INDENT> factor . append ( n ) <NEWLINE> <DEDENT> return factor <NEWLINE> <NL> <DEDENT> from sys import stdin <NEWLINE> from functools import reduce <NEWLINE> from operator import mul <NEWLINE> from collections import Counter <NEWLINE> readline = stdin . readline <NEWLINE> <NL> print ( reduce ( mul , ( pow ( p , k ) - pow ( p , k - 1 ) for p , k in Counter ( prime_factor ( int ( readline ( ) ) ) ) . items ( ) ) ) ) <NEWLINE>
def mark ( s , x ) : <NEWLINE> <INDENT> for i in xrange ( x + x , len ( s ) , x ) : <NEWLINE> <INDENT> s [ i ] = False <NEWLINE> <NL> <DEDENT> <DEDENT> def sieve ( n ) : <NEWLINE> <INDENT> s = [ True ] * n <NEWLINE> for x in xrange ( 2 , int ( n ** 0.5 ) + 1 ) : <NEWLINE> <INDENT> if s [ x ] : mark ( s , x ) <NEWLINE> <DEDENT> return [ i for i in xrange ( 0 , n ) if s [ i ] and i > 1 ] <NEWLINE> <NL> <DEDENT> n = input ( ) <NEWLINE> tmpn = n <NEWLINE> primes = sieve ( n / 2 + 1 ) <NEWLINE> <COMMENT> <NL> anslist = [ ] <NEWLINE> x = 0 <NEWLINE> while True : <NEWLINE> <INDENT> if tmpn == 1 : <NEWLINE> <INDENT> f = True <NEWLINE> break <NEWLINE> <DEDENT> if x > len ( primes ) - 1 : <NEWLINE> <INDENT> f = False <NEWLINE> break <NEWLINE> <DEDENT> if tmpn % primes [ x ] == 0 : <NEWLINE> <INDENT> anslist . append ( primes [ x ] ) <NEWLINE> tmpn = tmpn / primes [ x ] <NEWLINE> x -= 1 <NEWLINE> <DEDENT> x += 1 <NEWLINE> <COMMENT> <NL> <DEDENT> if f : <NEWLINE> <INDENT> ansset = set ( anslist ) <NEWLINE> <COMMENT> <NL> ans = n <NEWLINE> for tmp in ansset : <NEWLINE> <INDENT> ans *= ( 1 - 1.0 / tmp ) <NEWLINE> <DEDENT> print int ( ans ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print n - 1 <NEWLINE> <DEDENT>
n = int ( raw_input ( ) ) <NEWLINE> now = n <NEWLINE> i = 2 <NEWLINE> while i <= n and now != 1 : <NEWLINE> <INDENT> if now % i == 0 : <NEWLINE> <INDENT> n = n * ( i - 1 ) / i <NEWLINE> while now % i == 0 : <NEWLINE> <INDENT> now /= i <NEWLINE> <DEDENT> <DEDENT> i += 1 <NEWLINE> <DEDENT> print n <NEWLINE>
<COMMENT> <NL> <NL> <NL> def vector_minus ( v1 , v2 ) : <NEWLINE> <INDENT> return [ elm1 - elm2 for elm1 , elm2 in zip ( v1 , v2 ) ] <NEWLINE> <NL> <NL> <DEDENT> def scalar_multi ( scalar , vector ) : <NEWLINE> <INDENT> return [ scalar * elm for elm in vector ] <NEWLINE> <NL> <NL> <DEDENT> def gcd ( n1 , n2 ) : <NEWLINE> <INDENT> if n1 < n2 : <NEWLINE> <INDENT> n1 , n2 = n2 , n1 <NEWLINE> <NL> <DEDENT> if n1 == n2 or n2 == 0 : <NEWLINE> <INDENT> return n1 <NEWLINE> <DEDENT> n1 , n2 = n2 , ( n1 % n2 ) <NEWLINE> return gcd ( n1 , n2 ) <NEWLINE> <NL> <NL> <DEDENT> def solve_int ( number1 , number2 ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if number1 < number2 : <NEWLINE> <INDENT> reverse_flag = 1 <NEWLINE> n1 , n2 = number2 , number1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> reverse_flag = 0 <NEWLINE> n1 , n2 = number1 , number2 <NEWLINE> <DEDENT> quotient1 = [ ] <NEWLINE> coeff1 = [ 1 , 0 ] <NEWLINE> quotient2 = [ ] <NEWLINE> coeff2 = [ 0 , 1 ] <NEWLINE> <NL> while True : <NEWLINE> <INDENT> quotient1 . append ( n1 // n2 ) <NEWLINE> coeff1 = vector_minus ( coeff1 , scalar_multi ( n1 // n2 , coeff2 ) ) <NEWLINE> if n1 % n2 == 1 : <NEWLINE> <INDENT> if reverse_flag : <NEWLINE> <INDENT> return coeff1 [ 1 ] , coeff1 [ 0 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return coeff1 [ 0 ] , coeff1 [ 1 ] <NEWLINE> <NL> <DEDENT> <DEDENT> r_memo = n1 % n2 <NEWLINE> quotient2 . append ( n2 // r_memo ) <NEWLINE> coeff2 = vector_minus ( coeff2 , scalar_multi ( n2 // r_memo , coeff1 ) ) <NEWLINE> if n2 % r_memo == 1 : <NEWLINE> <INDENT> if reverse_flag : <NEWLINE> <INDENT> return coeff2 [ 1 ] , coeff2 [ 0 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return coeff2 [ 0 ] , coeff2 [ 1 ] <NEWLINE> <NL> <DEDENT> <DEDENT> n1 , n2 = n1 % n2 , n2 % r_memo <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def modify_solution ( x_sp_s , y_sp_s , n1 , n2 ) : <NEWLINE> <INDENT> if x_sp_s > y_sp_s : <NEWLINE> <INDENT> m2 = x_sp_s // n2 <NEWLINE> return modify_solution ( x_sp_s - ( m2 + 1 ) * n2 , y_sp_s + ( m2 + 1 ) * n1 , n1 , n2 ) <NEWLINE> <NL> <DEDENT> x_memo , y_memo = x_sp_s , y_sp_s <NEWLINE> if abs ( x_sp_s + n2 ) + abs ( y_sp_s - n1 ) < ( abs ( x_memo ) + abs ( y_memo ) ) : <NEWLINE> <INDENT> m = y_sp_s // n1 <NEWLINE> if m == 0 : <NEWLINE> <INDENT> return x_sp_s + n2 , y_sp_s - n1 <NEWLINE> <DEDENT> return modify_solution ( x_sp_s + m * n2 , y_sp_s - m * n1 , n1 , n2 ) <NEWLINE> <DEDENT> if abs ( x_sp_s + n2 ) + abs ( y_sp_s - n1 ) == ( abs ( x_memo ) + abs ( y_memo ) ) : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> return x_memo , y_memo <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> right_side = gcd ( a , b ) <NEWLINE> if right_side > 1 : <NEWLINE> <INDENT> a //= right_side <NEWLINE> b //= right_side <NEWLINE> <NL> <DEDENT> x_sp , y_sp = solve_int ( a , b ) <NEWLINE> x_sp , y_sp = modify_solution ( x_sp , y_sp , a , b ) <NEWLINE> print ( x_sp , y_sp ) <NEWLINE> <NL> <DEDENT>
r , s = map ( int , input ( ) . split ( ) ) <NEWLINE> a = d = 1 , b = c = 0 <NEWLINE> while r : <NEWLINE> <INDENT> q = r // s <NEWLINE> r , s , a , c , b , d = s , r % s , c , a - q * c , d , b - q * d <NEWLINE> <DEDENT> print ( a , b ) <NEWLINE>
import sys <NEWLINE> import itertools <NEWLINE> <NL> def sieve ( n ) : <NEWLINE> <INDENT> is_prime = [ True ] * ( n + 1 ) <NEWLINE> prime_list = [ ] <NEWLINE> <NL> is_prime [ 0 ] = is_prime [ 1 ] = False <NEWLINE> prime_list . append ( 2 ) <NEWLINE> <NL> for i in range ( 3 , n + 1 , 2 ) : <NEWLINE> <INDENT> if is_prime [ i ] : prime_list . append ( i ) <NEWLINE> for j in range ( i * i , n + 1 , i ) : <NEWLINE> <INDENT> is_prime [ j ] = False <NEWLINE> <DEDENT> <DEDENT> return prime_list <NEWLINE> <NL> <DEDENT> primes = sieve ( 40000 ) <NEWLINE> <NL> def factoriaztion ( n ) : <NEWLINE> <INDENT> ret = [ ] <NEWLINE> for prime in primes : <NEWLINE> <INDENT> while n % prime == 0 : <NEWLINE> <INDENT> ret . append ( prime ) <NEWLINE> n /= prime <NEWLINE> <DEDENT> if n == 1 : break <NEWLINE> <DEDENT> if n > 1 : ret . append ( ( n , 1 ) ) <NEWLINE> return ret <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> n = sys . stdin . readline ( ) <NEWLINE> n = int ( n ) <NEWLINE> factors = factoriaztion ( n ) <NEWLINE> factors = itertools . groupby ( factors ) <NEWLINE> <NL> ans = 1 <NEWLINE> <NL> for k , v in factors : <NEWLINE> <INDENT> l = len ( list ( v ) ) <NEWLINE> ans = ans * ( k ** l - k ** ( l - 1 ) ) <NEWLINE> <NL> <DEDENT> sys . stdout . write ( str ( ans ) + <STRING> ) <NEWLINE> <NL> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <NL> <NL> <STRING> <NEWLINE> <NL> import sys <NEWLINE> <NL> <NL> def ext_euclid ( a , b ) : <NEWLINE> <INDENT> if b == 0 : <NEWLINE> <INDENT> return 1 , 0 , a <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x , y , q = ext_euclid ( b , a % b ) <NEWLINE> x , y = y , ( x - ( a // b ) * y ) <NEWLINE> return x , y <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> _input = sys . stdin . readlines ( ) <NEWLINE> n1 , n2 = map ( int , _input [ 0 ] . split ( ) ) <NEWLINE> print ( * ext_euclid ( n1 , n2 ) ) <NEWLINE> <DEDENT>
a , b = map ( int , input . split ( ) ) <NEWLINE> print ( a + b ) <NEWLINE>
a = int ( input ( ) ) <NEWLINE> b = int ( input ( ) ) <NEWLINE> print ( a + b ) <NEWLINE>
a , b = [ int ( i ) for i in input ( ) . split ( ) ] ) <NEWLINE> print ( a - b ) <NEWLINE>
print ( <STRING> * int ( inout ( ) ) ) <NEWLINE>
K = input ( ) <NEWLINE> print ( K * ACL ) <NEWLINE>
print ( <STRING> * int ( input ( ) ) <NEWLINE>
k = int ( input ( ) ) <NEWLINE> print ( k * ACL ) <NEWLINE>
num = ( input ( ) ) <NEWLINE> a = <STRING> <NEWLINE> for _ in range ( num ) : <NEWLINE> <INDENT> a += <STRING> <NEWLINE> <DEDENT> print ( a ) <NEWLINE>
k = input ( ) <NEWLINE> print ( k * <STRING> ) <NEWLINE>
print ( <STRING> * int ( input ( ) ) <NEWLINE>
k = int ( input ( ) ) <NEWLINE> <NL> if k = 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> if k = 2 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> if k = 3 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> if k = 4 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> if k = 5 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a = input ( ) <NEWLINE> print ( <STRING> * a ) <NEWLINE>
K = int ( input ( ) ) <NEWLINE> print ( <STRING> * k ) <NEWLINE>
a = input ( ) <NEWLINE> a = <STRING> * a <NEWLINE> print ( a ) <NEWLINE>
k = input ( ) <NEWLINE> str = <STRING> <NEWLINE> for _ in range ( k ) : <NEWLINE> <INDENT> str += <STRING> <NEWLINE> <DEDENT> print ( str ) <NEWLINE>
x = input ( ) <NEWLINE> print ( <STRING> * x ) <NEWLINE>
K = int ( input ( ) ) <NEWLINE> print ( [ ACL ] * K ) <NEWLINE>
k = input ( ) <NEWLINE> ans = [ ] <NEWLINE> for i in range ( int ( k ) ) : <NEWLINE> <INDENT> ans . append ( <STRING> ) <NEWLINE> <NL> <DEDENT> print ( <STRING> . joint ( ans ) ) <NEWLINE>
k = input ( ) <NEWLINE> <NL> for loop in range ( k ) : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT>
k = input ( ) <NEWLINE> text = <STRING> * k <NEWLINE> print ( k ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> C = <STRING> <NEWLINE> print ( ACL * N ) <NEWLINE>
for i in range ( int ( intput ( ) ) ) : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> print ( ) <NEWLINE>
<COMMENT> <NL> n = int ( input ( ) ) <NEWLINE> s = <STRING> <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> s += <STRING> <NEWLINE> <DEDENT> print ( s ) <NEWLINE>
k = int ( input ( ) ) <NEWLINE> s = <STRING> <NEWLINE> for i in range ( K ) : <NEWLINE> <INDENT> s += <STRING> <NEWLINE> <DEDENT> print ( s ) <NEWLINE>
K = input ( ) <NEWLINE> print ( <STRING> * K ) <NEWLINE>
print ( <STRING> * ( int ( input ( ) ) ) <NEWLINE>
a = input ( ) <NEWLINE> K = int ( a ) <NEWLINE> <NL> x = <STRING> <NEWLINE> <NL> for i in K : <NEWLINE> <INDENT> print ( x , end = <STRING> ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> k = int ( input ) <NEWLINE> <NL> for _ in range ( k ) : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
K = input ( ) <NEWLINE> r = <STRING> <NEWLINE> for i in range ( 1 , int ( k ) ) : <NEWLINE> <INDENT> r = <STRING> + r <NEWLINE> <DEDENT> print ( r ) <NEWLINE>
if __name__ == <STRING> : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> print ( <STRING> * k ) <NEWLINE> <DEDENT>
spam = <STRING> <NEWLINE> print ( spam * K ) <NEWLINE>
num = int ( input ( ) ) <NEWLINE> print ( ACL * num ) <NEWLINE>
K = int ( input ( ) ) <NEWLINE> A = <STRING> <NEWLINE> for i in range ( K ) : <NEWLINE> <INDENT> A += ACL <NEWLINE> <NL> <DEDENT> print ( A ) <NEWLINE>
print ( input ( ) * <STRING> ) <NEWLINE>
K = int ( <STRING> ) <NEWLINE> if K == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif K == 2 : <NEWLINE> <INDENT> print ( <STRING> * 2 ) <NEWLINE> <DEDENT> elif K == 3 : <NEWLINE> <INDENT> print ( <STRING> * 3 ) <NEWLINE> <DEDENT> elif K == 4 : <NEWLINE> <INDENT> print ( <STRING> * 4 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> * 5 ) <NEWLINE> <DEDENT>
k = int ( input ( ) ) <NEWLINE> print ( <STRING> * k <NEWLINE>
k = int ( input ( ) ) <NEWLINE> <NL> print ( <STRING> * K ) <NEWLINE>
n = input ( ) <NEWLINE> s = <STRING> <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> s += <STRING> <NEWLINE> <DEDENT> print ( s ) <NEWLINE>
k = int ( input ( ) ) <NEWLINE> <NL> for ( int i = 0 ; i + + ; i < k ) <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
k = int ( input ( ) ) <NEWLINE> print ( ACL * k ) <NEWLINE>
<COMMENT> <NL> import os <NEWLINE> import sys <NEWLINE> from io import BytesIO , IOBase <NEWLINE> <NL> def ii ( ) : return int ( input ( ) ) <NEWLINE> def si ( ) : return input ( ) <NEWLINE> def mi ( ) : return map ( int , input ( ) . strip ( ) . split ( <STRING> ) ) <NEWLINE> def li ( ) : return list ( mi ( ) ) <NEWLINE> <NL> def main ( ) : <NEWLINE> <COMMENT> <NL> <INDENT> k = ii ( ) <NEWLINE> return <STRING> * k <NEWLINE> <NL> <DEDENT> print ( main ( ) ) <NEWLINE> <NL> <NL> <COMMENT> <NL> <NL> BUFSIZE = 8192 <NEWLINE> <NL> <NL> class FastIO ( IOBase ) : <NEWLINE> <INDENT> newlines = 0 <NEWLINE> <NL> def __init__ ( self , file ) : <NEWLINE> <INDENT> self . _fd = file . fileno ( ) <NEWLINE> self . buffer = BytesIO ( ) <NEWLINE> self . writable = <STRING> in file . mode or <STRING> not in file . mode <NEWLINE> self . write = self . buffer . write if self . writable else None <NEWLINE> <NL> <DEDENT> def read ( self ) : <NEWLINE> <INDENT> while True : <NEWLINE> <INDENT> b = os . read ( self . _fd , max ( os . fstat ( self . _fd ) . st_size , BUFSIZE ) ) <NEWLINE> if not b : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> ptr = self . buffer . tell ( ) <NEWLINE> self . buffer . seek ( 0 , 2 ) , self . buffer . write ( b ) , self . buffer . seek ( ptr ) <NEWLINE> <DEDENT> self . newlines = 0 <NEWLINE> return self . buffer . read ( ) <NEWLINE> <NL> <DEDENT> def readline ( self ) : <NEWLINE> <INDENT> while self . newlines == 0 : <NEWLINE> <INDENT> b = os . read ( self . _fd , max ( os . fstat ( self . _fd ) . st_size , BUFSIZE ) ) <NEWLINE> self . newlines = b . count ( <STRING> ) + ( not b ) <NEWLINE> ptr = self . buffer . tell ( ) <NEWLINE> self . buffer . seek ( 0 , 2 ) , self . buffer . write ( b ) , self . buffer . seek ( ptr ) <NEWLINE> <DEDENT> self . newlines -= 1 <NEWLINE> return self . buffer . readline ( ) <NEWLINE> <NL> <DEDENT> def flush ( self ) : <NEWLINE> <INDENT> if self . writable : <NEWLINE> <INDENT> os . write ( self . _fd , self . buffer . getvalue ( ) ) <NEWLINE> self . buffer . truncate ( 0 ) , self . buffer . seek ( 0 ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> class IOWrapper ( IOBase ) : <NEWLINE> <INDENT> def __init__ ( self , file ) : <NEWLINE> <INDENT> self . buffer = FastIO ( file ) <NEWLINE> self . flush = self . buffer . flush <NEWLINE> self . writable = self . buffer . writable <NEWLINE> self . write = lambda s : self . buffer . write ( s . encode ( <STRING> ) ) <NEWLINE> self . read = lambda : self . buffer . read ( ) . decode ( <STRING> ) <NEWLINE> self . readline = lambda : self . buffer . readline ( ) . decode ( <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> sys . stdin , sys . stdout = IOWrapper ( sys . stdin ) , IOWrapper ( sys . stdout ) <NEWLINE> input = lambda : sys . stdin . readline ( ) . rstrip ( <STRING> ) <NEWLINE> <NL> <COMMENT> <NL> <NL> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
<INDENT> K = int ( input ( ) ) <NEWLINE> <DEDENT> print ( <STRING> * K ) <NEWLINE>
return <STRING> * int ( input ( ) ) <NEWLINE>
k = input ( ) <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = [ <STRING> ] * n <NEWLINE> print ( <STRING> , join ( a ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> ptint ( <STRING> * n ) <NEWLINE>
k = input ( ) <NEWLINE> output = <STRING> * k <NEWLINE> print ( output ) <NEWLINE>
K = input ( ) <NEWLINE> <NL> if K == 1 : <NEWLINE> <INDENT> print ( <STRING> ) : <NEWLINE> <DEDENT> elif K == 2 : <NEWLINE> <INDENT> print ( <STRING> ) : <NEWLINE> <DEDENT> elif K == 3 : <NEWLINE> <INDENT> print ( <STRING> ) : <NEWLINE> <DEDENT> elif K == 4 : <NEWLINE> <INDENT> print ( <STRING> ) : <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) : <NEWLINE> <DEDENT>
<COMMENT> <NL> k = int ( input ( ) ) <NEWLINE> <NL> str = <STRING> <NEWLINE> for i in k : <NEWLINE> <INDENT> str += <STRING> <NEWLINE> <NL> <DEDENT> print ( str ) <NEWLINE>
print ( <STRING> * int ( input ) ) <NEWLINE>
k = int ( input ( ) ) <NEWLINE> print ( k ** <STRING> ) <NEWLINE>
import sys <NEWLINE> <NL> arg = sys . argv <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> for i in range ( arg [ 0 ] ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
k = int ( input ( ) ) <NEWLINE> a = <STRING> <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> a += ACL <NEWLINE> <DEDENT> print ( a ) <NEWLINE>
class UnionFind ( ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . n = n <NEWLINE> self . parents = [ - 1 ] * n <NEWLINE> <NL> <DEDENT> def find ( self , x ) : <NEWLINE> <COMMENT> <NL> <INDENT> if self . parents [ x ] < 0 : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . parents [ x ] = self . find ( self . parents [ x ] ) <NEWLINE> return self . parents [ x ] <NEWLINE> <NL> <DEDENT> <DEDENT> def unite ( self , x , y ) : <NEWLINE> <COMMENT> <NL> <INDENT> x = self . find ( x ) <NEWLINE> y = self . find ( y ) <NEWLINE> if x == y : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> if self . parents [ x ] > self . parents [ y ] : <NEWLINE> <INDENT> x , y = y , x <NEWLINE> <DEDENT> self . parents [ x ] += self . parents [ y ] <NEWLINE> self . parents [ y ] = x <NEWLINE> <NL> <DEDENT> def size ( self , x ) : <NEWLINE> <COMMENT> <NL> <INDENT> return - self . parents [ self . find ( x ) ] <NEWLINE> <NL> <DEDENT> def same ( self , x , y ) : <NEWLINE> <COMMENT> <NL> <INDENT> return self . find ( x ) == self . find ( y ) <NEWLINE> <NL> <DEDENT> def members ( self , x ) : <NEWLINE> <COMMENT> <NL> <INDENT> root = self . find ( x ) <NEWLINE> return [ i for i in range ( self . n ) if self . find ( i ) == root ] <NEWLINE> <NL> <DEDENT> def roots ( self ) : <NEWLINE> <COMMENT> <NL> <INDENT> return [ i for i , x in enumerate ( self . parents ) if x < 0 ] <NEWLINE> <NL> <DEDENT> def group_count ( self ) : <NEWLINE> <COMMENT> <NL> <INDENT> return len ( self . roots ( ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> uni = UnionFind ( n ) <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> uni . unite ( a - 1 , b - 1 ) <NEWLINE> <NL> <DEDENT> cnt = [ 0 ] * ( n ) <NEWLINE> for aa in uni . par : <NEWLINE> <INDENT> cnt [ aa ] = 1 <NEWLINE> <NL> <DEDENT> print ( sum ( cnt ) - 1 ) <NEWLINE>
<COMMENT> <NL> class UnionFind ( ) : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . n = n <NEWLINE> self . parents = [ - 1 ] * n <NEWLINE> <NL> <DEDENT> def find ( self , x ) : <NEWLINE> <INDENT> if self . parents [ x ] < 0 : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . parents [ x ] = self . find ( self . parents [ x ] ) <NEWLINE> return self . parents [ x ] <NEWLINE> <NL> <DEDENT> <DEDENT> def union ( self , x , y ) : <NEWLINE> <INDENT> x = self . find ( x ) <NEWLINE> y = self . find ( y ) <NEWLINE> <NL> if x == y : <NEWLINE> <INDENT> return <NEWLINE> <NL> <DEDENT> if self . parents [ x ] > self . parents [ y ] : <NEWLINE> <INDENT> x , y = y , x <NEWLINE> <NL> <DEDENT> self . parents [ x ] += self . parents [ y ] <NEWLINE> self . parents [ y ] = x <NEWLINE> <NL> <DEDENT> def size ( self , x ) : <NEWLINE> <INDENT> return - self . parents [ self . find ( x ) ] <NEWLINE> <NL> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <INDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> uf = UnionFind ( n ) <NEWLINE> for _ in range ( m ) : <NEWLINE> <INDENT> a , b = map ( lambda x : int ( x ) - 1 , input ( ) . split ( ) ) <NEWLINE> uf . union ( a , b ) <NEWLINE> <DEDENT> print ( len ( uf . groups ( ) ) - 1 ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
from atcoder import dsu <NEWLINE> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> ab = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( m ) ] <NEWLINE> ds = dsu . DSU ( n ) <NEWLINE> for i in ab : <NEWLINE> <INDENT> ds . merge ( i [ 0 ] - 1 , i [ 1 ] - 1 ) <NEWLINE> <NL> <DEDENT> s = ds . groups ( ) <NEWLINE> ans = 0 <NEWLINE> for i in s : <NEWLINE> <INDENT> if len ( i ) == 1 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
class UnionFind ( ) : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . n = n <NEWLINE> self . parents = [ - 1 ] * n <NEWLINE> <NL> <DEDENT> def find ( self , x ) : <NEWLINE> <INDENT> if self . parents [ x ] < 0 : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . parents [ x ] = self . find ( self . parents [ x ] ) <NEWLINE> return self . parents [ x ] <NEWLINE> <NL> <DEDENT> <DEDENT> def union ( self , x , y ) : <NEWLINE> <INDENT> x = self . find ( x ) <NEWLINE> y = self . find ( y ) <NEWLINE> <NL> if x == y : <NEWLINE> <INDENT> return <NEWLINE> <NL> <DEDENT> if self . parents [ x ] > self . parents [ y ] : <NEWLINE> <INDENT> x , y = y , x <NEWLINE> <NL> <DEDENT> self . parents [ x ] += self . parents [ y ] <NEWLINE> self . parents [ y ] = x <NEWLINE> <NL> <DEDENT> def size ( self , x ) : <NEWLINE> <INDENT> return - self . parents [ self . find ( x ) ] <NEWLINE> <NL> <DEDENT> def same ( self , x , y ) : <NEWLINE> <INDENT> return self . find ( x ) == self . find ( y ) <NEWLINE> <NL> <DEDENT> def members ( self , x ) : <NEWLINE> <INDENT> root = self . find ( x ) <NEWLINE> return [ i for i in range ( self . n ) if self . find ( i ) == root ] <NEWLINE> <NL> <DEDENT> def roots ( self ) : <NEWLINE> <INDENT> return [ i for i , x in enumerate ( self . parents ) if x < 0 ] <NEWLINE> <NL> <DEDENT> def group_count ( self ) : <NEWLINE> <INDENT> return len ( self . roots ( ) ) <NEWLINE> <NL> <DEDENT> def all_group_members ( self ) : <NEWLINE> <INDENT> return { r : self . members ( r ) for r in self . roots ( ) } <NEWLINE> <NL> <DEDENT> def __str__ ( self ) : <NEWLINE> <INDENT> return <STRING> . join ( <STRING> . format ( r , self . members ( r ) ) for r in self . roots ( ) ) <NEWLINE> <DEDENT> <DEDENT> uf = UnionFind ( N ) <NEWLINE> for _ in range ( M ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> uf . union ( a - 1 , b - 1 ) <NEWLINE> <DEDENT> print ( len ( uf . roots ( ) ) - 1 ) <NEWLINE>
header_code = <STRING> <NEWLINE> <NL> code = <STRING> <NEWLINE> <NL> <NL> import os , sys , getpass <NEWLINE> <NL> if sys . argv [ - 1 ] == <STRING> : <NEWLINE> <INDENT> code = code . replace ( <STRING> , getpass . getuser ( ) ) <NEWLINE> open ( <STRING> , <STRING> ) . write ( header_code ) <NEWLINE> open ( <STRING> , <STRING> ) . write ( code ) <NEWLINE> os . system ( <STRING> ) <NEWLINE> sys . exit ( 0 ) <NEWLINE> <NL> <NL> <DEDENT> from atcoder import Dsu , ReadInt <NEWLINE> <NL> N , M = ReadInt ( 2 ) <NEWLINE> <NL> edge = [ ReadInt ( 2 ) for i in range ( M ) ] <NEWLINE> <NL> dsu = Dsu ( N ) <NEWLINE> count = 0 <NEWLINE> for e in edge : <NEWLINE> <INDENT> a , b = e <NEWLINE> a , b = a - 1 , b - 1 <NEWLINE> if not dsu . same ( a , b ) : <NEWLINE> <INDENT> dsu . merge ( a , b ) <NEWLINE> count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
from collections import deque <NEWLINE> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> g = [ [ ] for _ in range ( n ) ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> g [ a - 1 ] . append ( b - 1 ) <NEWLINE> g [ b - 1 ] . append ( a - 1 ) <NEWLINE> <NL> <DEDENT> checked = [ False ] * n <NEWLINE> q = deque ( [ ] ) <NEWLINE> cnt = 0 <NEWLINE> <NL> <COMMENT> <NL> <NL> for i in range ( n ) : <NEWLINE> <INDENT> if checked [ i ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> checked [ i ] = True <NEWLINE> q . append ( i ) <NEWLINE> while q : <NEWLINE> <INDENT> v = q . pop ( ) <NEWLINE> s = g [ v ] <NEWLINE> for j in s : <NEWLINE> <INDENT> if checked [ j ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> checked [ j ] = True <NEWLINE> q . append ( j ) <NEWLINE> <DEDENT> <DEDENT> cnt += 1 <NEWLINE> <NL> <DEDENT> print ( cnt - 1 <NEWLINE>
from numba import jit <NEWLINE> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> def func ( N , M ) : <NEWLINE> <INDENT> group = [ ] <NEWLINE> tf = [ ] <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> if A not in tf and B not in tf : <NEWLINE> <INDENT> tf . append ( A ) <NEWLINE> tf . append ( B ) <NEWLINE> group . append ( [ A , B ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if A in tf and B in tf : <NEWLINE> <INDENT> a , b = 0 , 0 <NEWLINE> for j in range ( len ( group ) ) : <NEWLINE> <INDENT> if A in group [ j ] : <NEWLINE> <INDENT> a = j <NEWLINE> if b != 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> elif B in group [ j ] : <NEWLINE> <INDENT> b = j <NEWLINE> if a != 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> group [ a ] . extend ( group [ b ] ) <NEWLINE> del group [ b ] <NEWLINE> <DEDENT> elif A not in tf : <NEWLINE> <INDENT> tf . append ( A ) <NEWLINE> for j in range ( len ( group ) ) : <NEWLINE> <INDENT> if B in group [ j ] : <NEWLINE> <INDENT> group [ j ] . append ( A ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> elif B not in tf : <NEWLINE> <INDENT> tf . append ( B ) <NEWLINE> for j in range ( len ( group ) ) : <NEWLINE> <INDENT> if A in group [ j ] : <NEWLINE> <INDENT> group [ j ] . append ( B ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> num = N - len ( tf ) <NEWLINE> return len ( group ) + num - 1 <NEWLINE> <DEDENT> print ( func ( N , M ) ) <NEWLINE>
class UnionFind ( ) : <NEWLINE> <INDENT> def __init__ ( self , N ) : <NEWLINE> <INDENT> self . N = N <NEWLINE> self . parents = [ - 1 ] * N <NEWLINE> <NL> <DEDENT> def root ( self , x ) : <NEWLINE> <INDENT> if self . parents [ x ] < 0 : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . parents [ x ] = self . root ( self . parents [ x ] ) <NEWLINE> return self . parents [ x ] <NEWLINE> <NL> <DEDENT> <DEDENT> def unite ( self , x , y ) : <NEWLINE> <INDENT> x = self . root ( x ) <NEWLINE> y = self . root ( y ) <NEWLINE> <NL> if x == y : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> if self . parents [ x ] > self . parents [ y ] : <NEWLINE> <INDENT> x , y = y , x <NEWLINE> <DEDENT> self . parents [ x ] += self . parents [ y ] <NEWLINE> self . parents [ y ] = x <NEWLINE> <NL> <DEDENT> def size ( self , x ) : <NEWLINE> <INDENT> return - self . parents [ self . root ( x ) ] <NEWLINE> <NL> <DEDENT> <DEDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> uf = UnionFind ( n ) <NEWLINE> <NL> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> a -= 1 <NEWLINE> b -= 1 <NEWLINE> uf . unite ( a , b ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ans = max ( ans , uf . size ( i ) ) <NEWLINE> <NL> <DEDENT> print ( n - str ( ans ) ) <NEWLINE>
import sys <NEWLINE> if sys . argv [ - 1 ] == <STRING> : <NEWLINE> <INDENT> import os <NEWLINE> import re <NEWLINE> with open ( __file__ ) as f : <NEWLINE> <INDENT> source = f . read ( ) . split ( <STRING> <STRING> ) <NEWLINE> <DEDENT> for s in source [ 1 : ] : <NEWLINE> <INDENT> s = re . sub ( <STRING> , <STRING> , s ) <NEWLINE> sp = s . split ( maxsplit = 1 ) <NEWLINE> if os . path . dirname ( sp [ 0 ] ) : <NEWLINE> <INDENT> os . makedirs ( os . path . dirname ( sp [ 0 ] ) , exist_ok = True ) <NEWLINE> <DEDENT> with open ( sp [ 0 ] , <STRING> ) as f : <NEWLINE> <INDENT> f . write ( sp [ 1 ] ) <NEWLINE> <DEDENT> <DEDENT> from nbmodule import cc cc . compile ( ) import numpy as np <NEWLINE> <DEDENT> from numpy import int64 <NEWLINE> from nbmodule import solve <NEWLINE> <NL> <NL> f = open ( 0 ) <NEWLINE> N , M = [ int ( x ) for x in f . readline ( ) . split ( ) ] <NEWLINE> AB = np . fromstring ( f . read ( ) , dtype = int64 , sep = <STRING> ) . reshape ( ( - 1 , 2 ) ) <NEWLINE> ans = solve ( N , AB ) <NEWLINE> print ( ans ) <NEWLINE> <NL> <STRING> <NEWLINE>
import collections <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> def dfs ( visited , v , adj ) : <NEWLINE> <INDENT> visited [ v ] = True <NEWLINE> for i in adj [ v ] : <NEWLINE> <INDENT> if not visited [ i ] : <NEWLINE> <INDENT> dfs ( visited , i , adj ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> adj = collections . defaultdict ( list ) <NEWLINE> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> visited = [ False ] * n <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> u , v = map ( int , input ( ) . split ( ) ) <NEWLINE> adj [ u - 1 ] . append ( v - 1 ) <NEWLINE> adj [ v - 1 ] . append ( u - 1 ) <NEWLINE> <DEDENT> c = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if not visited [ i ] : <NEWLINE> <INDENT> dfs ( visited , i , adj ) <NEWLINE> c += 1 <NEWLINE> <DEDENT> <DEDENT> print ( c - 1 ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <NL> import atcoder . dsu <NEWLINE> <NL> <NL> <COMMENT> <NL> def solve ( N , M , A , B ) : <NEWLINE> <INDENT> dsu = atcoder . dsu . DSU ( N ) <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> dsu . merge ( A [ i ] - 1 , B [ i ] - 1 ) <NEWLINE> <DEDENT> num_groups = len ( dsu . groups ( ) ) <NEWLINE> return num_groups - 1 <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ None for _ in range ( M ) ] <NEWLINE> B = [ None for _ in range ( M ) ] <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> A [ i ] , B [ i ] = map ( int , input ( ) . split ( ) ) <NEWLINE> <DEDENT> b = solve ( N , M , A , B ) <NEWLINE> print ( b ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
def dfs ( v ) : <NEWLINE> <INDENT> visited [ v ] = 1 <NEWLINE> for i in AB [ v ] : <NEWLINE> <INDENT> if visited [ i ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> dfs ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <INDENT> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> AB = [ [ ] for _ in range ( N ) ] <NEWLINE> <NL> for _ in range ( M ) : <NEWLINE> <INDENT> a , b = map ( lambda x : int ( x ) - 1 , input ( ) . split ( ) ) <NEWLINE> AB [ a ] . append ( b ) <NEWLINE> AB [ b ] . append ( a ) <NEWLINE> <NL> <DEDENT> visited = [ 0 ] * N <NEWLINE> cnt = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if visited [ i ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> dfs ( i ) <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> print ( cnt - 1 ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> roads = [ ] <NEWLINE> <NL> for _ in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if a < b : <NEWLINE> <INDENT> roads . append ( [ a , b ] . sort ( ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> roads . append ( [ b , a ] . sort ( ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> group = [ i for i in range ( n ) ] <NEWLINE> <NL> group2 = [ ] <NEWLINE> <NL> while group2 != group : <NEWLINE> <INDENT> group2 = group <NEWLINE> for road in roads : <NEWLINE> <INDENT> group [ road [ 1 ] - 1 ] = group [ road [ 0 ] - 1 ] <NEWLINE> <NL> <DEDENT> <DEDENT> counter = 1 <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> if group [ i ] != group [ i + 1 ] : <NEWLINE> <INDENT> counter += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( counter - 1 ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( max ( n - m - 1 ) , 0 ) <NEWLINE>
<COMMENT> <NL> def input2 ( ) : <NEWLINE> <INDENT> return map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> def input_array ( ) : <NEWLINE> <INDENT> return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <DEDENT> n , m = input2 ( ) <NEWLINE> AB = [ input_array ( ) for _ in range ( m ) ] <NEWLINE> <NL> <NL> uf = UnionFind ( n ) <NEWLINE> for ab in AB : <NEWLINE> <INDENT> a = ab [ 0 ] <NEWLINE> b = ab [ 1 ] <NEWLINE> uf . union ( a - 1 , b - 1 ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in uf . parents : <NEWLINE> <INDENT> if i < 0 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans - 1 ) <NEWLINE>
import sys <NEWLINE> if sys . argv [ - 1 ] == <STRING> : <NEWLINE> <INDENT> import os <NEWLINE> import re <NEWLINE> with open ( __file__ ) as f : <NEWLINE> <INDENT> source = f . read ( ) . split ( <STRING> <STRING> ) <NEWLINE> <DEDENT> for s in source [ 1 : ] : <NEWLINE> <INDENT> s = re . sub ( <STRING> , <STRING> , s ) <NEWLINE> sp = s . split ( maxsplit = 1 ) <NEWLINE> if os . path . dirname ( sp [ 0 ] ) : <NEWLINE> <INDENT> os . makedirs ( os . path . dirname ( sp [ 0 ] ) , exist_ok = True ) <NEWLINE> <DEDENT> with open ( sp [ 0 ] , <STRING> ) as f : <NEWLINE> <INDENT> f . write ( sp [ 1 ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> import numpy as np <NEWLINE> from numpy import int64 <NEWLINE> from numba import njit <NEWLINE> from numba . types import i8 <NEWLINE> import nbacl . segtree as seg <NEWLINE> <NL> <NL> @ njit ( ( i8 , i8 , i8 [ : ] ) , cache = True ) <NEWLINE> def solve ( N , K , A ) : <NEWLINE> <INDENT> dp = np . zeros ( 300_001 , dtype = int64 ) <NEWLINE> d = seg . segtree ( dp , max ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> x = seg . prod ( d , max , A [ i ] - K , A [ i ] + K + 1 ) + 1 <NEWLINE> seg . set ( d , max , A [ i ] , x ) <NEWLINE> <DEDENT> return seg . all_prod ( d ) <NEWLINE> <NL> <NL> <DEDENT> f = open ( 0 ) <NEWLINE> N , K = [ int ( x ) for x in f . readline ( ) . split ( ) ] <NEWLINE> A = np . fromstring ( f . read ( ) , dtype = int64 , sep = <STRING> ) <NEWLINE> ans = solve ( N , K , A ) <NEWLINE> print ( ans ) <NEWLINE> <NL> <STRING> <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <NL> <NL> code_segtree = <STRING> <NEWLINE> code_setup = <STRING> <NEWLINE> <NL> import os <NEWLINE> import sys <NEWLINE> if sys . argv [ - 1 ] == <STRING> or os . getcwd ( ) != <STRING> : <NEWLINE> <INDENT> with open ( <STRING> , <STRING> ) as f : <NEWLINE> <INDENT> f . write ( code_segtree ) <NEWLINE> <DEDENT> with open ( <STRING> , <STRING> ) as f : <NEWLINE> <INDENT> f . write ( code_setup ) <NEWLINE> <DEDENT> os . system ( <STRING> ) <NEWLINE> <NL> <DEDENT> from atcoder import SegTree <NEWLINE> <NL> <NL> input = sys . stdin . buffer . readline <NEWLINE> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ int ( input ( ) ) for _ in range ( N ) ] <NEWLINE> <NL> op = lambda a , b : a if a > b else b <NEWLINE> e = 0 <NEWLINE> seg = SegTree ( op , e , 303030 ) <NEWLINE> for a in A : <NEWLINE> <INDENT> seg . set ( a , seg . prod ( a - K , a + K + 1 ) + 1 ) <NEWLINE> <DEDENT> ans = seg . all_prod ( ) <NEWLINE> print ( ans ) <NEWLINE>
code = <STRING> <NEWLINE> import os , sys <NEWLINE> if sys . argv [ - 1 ] == <STRING> : <NEWLINE> <INDENT> open ( <STRING> , <STRING> ) . write ( code ) <NEWLINE> os . system ( <STRING> ) <NEWLINE> <DEDENT> import solve <NEWLINE>
import sys <NEWLINE> import os <NEWLINE> import numpy as np <NEWLINE> <NL> def solve ( inp ) : <NEWLINE> <INDENT> MOD = 998244353 <NEWLINE> <NL> def bit_length ( x ) : <NEWLINE> <INDENT> ret = 0 <NEWLINE> while x : <NEWLINE> <INDENT> x >>= 1 <NEWLINE> ret += 1 <NEWLINE> <DEDENT> return ret <NEWLINE> <NL> <DEDENT> e = 0 <NEWLINE> id_x = - 1 <NEWLINE> <NL> n = inp [ 0 ] <NEWLINE> q = inp [ 1 ] <NEWLINE> X = inp [ 2 : : 3 ] <NEWLINE> Y = inp [ 3 : : 3 ] <NEWLINE> REP = inp [ 4 : : 3 ] <NEWLINE> log = bit_length ( n - 1 ) <NEWLINE> size = 1 << log <NEWLINE> d = [ e ] * ( 2 * size ) <NEWLINE> lz = [ id_x ] * size <NEWLINE> <NL> <NL> def op ( a , b ) : <NEWLINE> <INDENT> a1 , a2 = a >> 32 , a % ( 1 << 32 ) <NEWLINE> b1 , b2 = b >> 32 , b % ( 1 << 32 ) <NEWLINE> c1 = ( a1 + b1 ) % MOD <NEWLINE> c2 = ( a2 + b2 ) % MOD <NEWLINE> return ( c1 << 32 ) + c2 <NEWLINE> <NL> <NL> <DEDENT> def mapping ( x , a ) : <NEWLINE> <INDENT> if x == - 1 : <NEWLINE> <INDENT> return a <NEWLINE> <DEDENT> a1 , a2 = a >> 32 , a % ( 1 << 32 ) <NEWLINE> c1 = ( x * a2 ) % MOD <NEWLINE> c2 = a2 <NEWLINE> return ( c1 << 32 ) + c2 <NEWLINE> <NL> <NL> <DEDENT> def composition ( x , y ) : <NEWLINE> <INDENT> if x == - 1 : <NEWLINE> <INDENT> return y <NEWLINE> <DEDENT> return x <NEWLINE> <NL> <NL> <COMMENT> <NL> <NL> <NL> <DEDENT> def update ( k ) : <NEWLINE> <INDENT> d [ k ] = op ( d [ 2 * k ] , d [ 2 * k + 1 ] ) <NEWLINE> <NL> <NL> <DEDENT> def all_apply ( k , f ) : <NEWLINE> <INDENT> d [ k ] = mapping ( f , d [ k ] ) <NEWLINE> if k < size : <NEWLINE> <INDENT> lz [ k ] = composition ( f , lz [ k ] ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def push ( k ) : <NEWLINE> <INDENT> all_apply ( 2 * k , lz [ k ] ) <NEWLINE> all_apply ( 2 * k + 1 , lz [ k ] ) <NEWLINE> lz [ k ] = id_x <NEWLINE> <NL> <NL> <DEDENT> def build ( arr ) : <NEWLINE> <INDENT> assert len ( arr ) == n <NEWLINE> for j in range ( n ) : <NEWLINE> <INDENT> d [ size + j ] = arr [ j ] <NEWLINE> <DEDENT> for j in range ( size - 1 , 0 , - 1 ) : <NEWLINE> <INDENT> update ( j ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def set ( p , x ) : <NEWLINE> <INDENT> assert 0 <= p < n <NEWLINE> p += size <NEWLINE> for i in range ( 1 , log + 1 ) [ : : - 1 ] : <NEWLINE> <INDENT> push ( p >> i ) <NEWLINE> <DEDENT> d [ p ] = x <NEWLINE> for i in range ( 1 , log + 1 ) : <NEWLINE> <INDENT> update ( p >> i ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def get ( p ) : <NEWLINE> <INDENT> assert 0 <= p < n <NEWLINE> p += size <NEWLINE> for i in range ( 1 , log + 1 ) : <NEWLINE> <INDENT> push ( p >> i ) <NEWLINE> <DEDENT> return d [ p ] <NEWLINE> <NL> <NL> <DEDENT> def prod ( l , r ) : <NEWLINE> <INDENT> assert 0 <= l <= r <= n <NEWLINE> if l == r : <NEWLINE> <INDENT> return e <NEWLINE> <DEDENT> l += size <NEWLINE> r += size <NEWLINE> for i in range ( 1 , log + 1 ) [ : : - 1 ] : <NEWLINE> <INDENT> if ( ( l >> i ) << i ) != l : <NEWLINE> <INDENT> push ( l >> i ) <NEWLINE> <DEDENT> if ( ( r >> i ) << i ) != r : <NEWLINE> <INDENT> push ( r >> i ) <NEWLINE> <DEDENT> <DEDENT> sml = smr = e <NEWLINE> while l < r : <NEWLINE> <INDENT> if l & 1 : <NEWLINE> <INDENT> sml = op ( sml , d [ l ] ) <NEWLINE> l += 1 <NEWLINE> <DEDENT> if r & 1 : <NEWLINE> <INDENT> r -= 1 <NEWLINE> smr = op ( d [ r ] , smr ) <NEWLINE> <DEDENT> l >>= 1 <NEWLINE> r >>= 1 <NEWLINE> <DEDENT> return op ( sml , smr ) <NEWLINE> <NL> <NL> <DEDENT> def all_prod ( ) : <NEWLINE> <INDENT> return d [ 1 ] <NEWLINE> <NL> <NL> <DEDENT> def apply ( p , f ) : <NEWLINE> <INDENT> assert 0 <= p < n <NEWLINE> p += size <NEWLINE> for i in range ( 1 , log + 1 ) [ : : - 1 ] : <NEWLINE> <INDENT> push ( p >> i ) <NEWLINE> <DEDENT> d [ p ] = mapping ( f , d [ p ] ) <NEWLINE> for i in range ( 1 , log + 1 ) : <NEWLINE> <INDENT> update ( p >> i ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def range_apply ( l , r , f ) : <NEWLINE> <INDENT> assert 0 <= l <= r <= n <NEWLINE> if l == r : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> l += size <NEWLINE> r += size <NEWLINE> for i in range ( log , 0 , - 1 ) : <NEWLINE> <INDENT> if ( ( l >> i ) << i ) != l : <NEWLINE> <INDENT> push ( l >> i ) <NEWLINE> <DEDENT> if ( ( r >> i ) << i ) != r : <NEWLINE> <INDENT> push ( ( r - 1 ) >> i ) <NEWLINE> <DEDENT> <DEDENT> l2 = l <NEWLINE> r2 = r <NEWLINE> while l < r : <NEWLINE> <INDENT> if l & 1 : <NEWLINE> <INDENT> all_apply ( l , f ) <NEWLINE> l += 1 <NEWLINE> <DEDENT> if r & 1 : <NEWLINE> <INDENT> r -= 1 <NEWLINE> all_apply ( r , f ) <NEWLINE> <DEDENT> l >>= 1 <NEWLINE> r >>= 1 <NEWLINE> <DEDENT> l = l2 <NEWLINE> r = r2 <NEWLINE> for i in range ( 1 , log + 1 ) : <NEWLINE> <INDENT> if ( ( l >> i ) << i ) != l : <NEWLINE> <INDENT> update ( l >> i ) <NEWLINE> <DEDENT> if ( ( r >> i ) << i ) != r : <NEWLINE> <INDENT> update ( ( r - 1 ) >> i ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> def max_right ( l , g ) : <NEWLINE> <INDENT> assert 0 <= l <= n <NEWLINE> <COMMENT> <NL> if l == n : <NEWLINE> <INDENT> return n <NEWLINE> <DEDENT> l += size <NEWLINE> for i in range ( 1 , log + 1 ) [ : : - 1 ] : <NEWLINE> <INDENT> push ( l >> i ) <NEWLINE> <DEDENT> sm = e <NEWLINE> while True : <NEWLINE> <INDENT> while l % 2 == 0 : <NEWLINE> <INDENT> l >>= 1 <NEWLINE> <DEDENT> if not g ( op ( sm , d [ l ] ) ) : <NEWLINE> <INDENT> while l < size : <NEWLINE> <INDENT> push ( l ) <NEWLINE> l = 2 * l <NEWLINE> if g ( op ( sm , d [ l ] ) ) : <NEWLINE> <INDENT> sm = op ( sm , d [ l ] ) <NEWLINE> l += 1 <NEWLINE> <DEDENT> <DEDENT> return l - size <NEWLINE> <DEDENT> sm = op ( sm , d [ l ] ) <NEWLINE> l += 1 <NEWLINE> if ( l & - l ) == l : <NEWLINE> <INDENT> return n <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> def min_left ( r , g ) : <NEWLINE> <INDENT> assert 0 <= r <= n <NEWLINE> assert g ( e ) <NEWLINE> if r == 0 : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> r += size <NEWLINE> for i in range ( 1 , log + 1 ) [ : : - 1 ] : <NEWLINE> <INDENT> push ( ( r - 1 ) >> i ) <NEWLINE> <DEDENT> sm = e <NEWLINE> while True : <NEWLINE> <INDENT> r -= 1 <NEWLINE> while r > 1 and r % 2 : <NEWLINE> <INDENT> r >>= 1 <NEWLINE> <DEDENT> if not g ( op ( d [ r ] , sm ) ) : <NEWLINE> <INDENT> while r < size : <NEWLINE> <INDENT> push ( r ) <NEWLINE> r = 2 * r + 1 <NEWLINE> if g ( op ( d [ r ] , sm ) ) : <NEWLINE> <INDENT> sm = op ( d [ r ] , sm ) <NEWLINE> r -= 1 <NEWLINE> <DEDENT> <DEDENT> return r + 1 - size <NEWLINE> <DEDENT> sm = op ( d [ r ] , sm ) <NEWLINE> if ( r & - r ) == r : <NEWLINE> <INDENT> return 0 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> A = np . zeros ( n , dtype = np . int64 ) <NEWLINE> tmp = 1 <NEWLINE> for i in range ( n - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> A [ i ] = ( tmp << 32 ) + tmp <NEWLINE> tmp *= 10 <NEWLINE> tmp %= MOD <NEWLINE> <NL> <DEDENT> build ( A ) <NEWLINE> <NL> ans = np . zeros ( q , dtype = np . int64 ) <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> range_apply ( X [ i ] - 1 , Y [ i ] , REP [ i ] ) <NEWLINE> ans [ i ] = all_prod ( ) >> 32 <NEWLINE> <NL> <DEDENT> return <STRING> . join ( map ( str , ans ) ) <NEWLINE> <NL> <NL> <DEDENT> if sys . argv [ - 1 ] == <STRING> : <NEWLINE> <INDENT> from numba . pycc import CC <NEWLINE> <NL> cc = CC ( <STRING> ) <NEWLINE> cc . export ( <STRING> , <STRING> ) ( solve ) <NEWLINE> cc . compile ( ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> if os . name == <STRING> : <NEWLINE> <COMMENT> <NL> <INDENT> from my_module import solve <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> from numba import njit <NEWLINE> <NL> solve = njit ( <STRING> , cache = True ) ( solve ) <NEWLINE> print ( <STRING> , file = sys . stderr ) <NEWLINE> <NL> <DEDENT> inp = np . fromstring ( sys . stdin . read ( ) , dtype = np . int64 , sep = <STRING> ) <NEWLINE> ans = solve ( inp ) <NEWLINE> print ( ans ) <NEWLINE>
def numba_compile ( numba_config ) : <NEWLINE> <INDENT> import os , sys <NEWLINE> if sys . argv [ - 1 ] == <STRING> : <NEWLINE> <INDENT> from numba import njit <NEWLINE> from numba . pycc import CC <NEWLINE> cc = CC ( <STRING> ) <NEWLINE> for func , signature in numba_config : <NEWLINE> <INDENT> globals ( ) [ func . __name__ ] = njit ( signature ) ( func ) <NEWLINE> cc . export ( func . __name__ , signature ) ( func ) <NEWLINE> <DEDENT> cc . compile ( ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> elif os . name == <STRING> : <NEWLINE> <INDENT> exec ( <STRING> ) <NEWLINE> for func , _ in numba_config : <NEWLINE> <INDENT> globals ( ) [ func . __name__ ] = vars ( ) [ func . __name__ ] <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> from numba import njit <NEWLINE> for func , signature in numba_config : <NEWLINE> <INDENT> globals ( ) [ func . __name__ ] = njit ( signature , cache = True ) ( func ) <NEWLINE> <DEDENT> print ( <STRING> , file = sys . stderr ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> import sys <NEWLINE> import numpy as np <NEWLINE> <NL> <NL> def solve ( N , Q , LRD ) : <NEWLINE> <INDENT> mod = 998244353 <NEWLINE> p = 1 <NEWLINE> n = 0 <NEWLINE> p10 = np . empty ( 202020 , dtype = np . int64 ) <NEWLINE> n11 = np . empty ( 202020 , dtype = np . int64 ) <NEWLINE> for i in range ( 202020 ) : <NEWLINE> <INDENT> p10 [ i ] = p <NEWLINE> n11 [ i ] = n <NEWLINE> p = p * 10 % mod <NEWLINE> n = ( n * 10 + 1 ) % mod <NEWLINE> <NL> <DEDENT> identity = 0 <NEWLINE> sqrtN = 1024 <NEWLINE> n_buckets = N // sqrtN + 1 <NEWLINE> Data_val = np . ones ( n_buckets * sqrtN , dtype = np . int64 ) <NEWLINE> Data_val [ N : ] = 0 <NEWLINE> Bucket_val = np . full ( n_buckets , n11 [ sqrtN ] , dtype = np . int64 ) <NEWLINE> Lazy = np . full ( n_buckets , identity , dtype = np . int64 ) <NEWLINE> M = N % sqrtN <NEWLINE> Bucket_val [ n_buckets - 1 ] = n11 [ M ] <NEWLINE> <NL> def eval_data ( k ) : <NEWLINE> <INDENT> if Lazy [ k ] != identity : <NEWLINE> <INDENT> l , r = k * sqrtN , ( k + 1 ) * sqrtN <NEWLINE> for i in range ( l , r ) : <NEWLINE> <INDENT> Data_val [ i ] = Lazy [ k ] <NEWLINE> <DEDENT> Lazy [ k ] = identity <NEWLINE> <NL> <DEDENT> <DEDENT> def apply ( s , t , f ) : <NEWLINE> <INDENT> for k in range ( s // sqrtN , ( t - 1 ) // sqrtN + 1 ) : <NEWLINE> <INDENT> l , r = k * sqrtN , ( k + 1 ) * sqrtN <NEWLINE> if s <= l and r <= t : <NEWLINE> <INDENT> Bucket_val [ k ] = f * n11 [ sqrtN ] % mod <NEWLINE> Lazy [ k ] = f <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> eval_data ( k ) <NEWLINE> for i in range ( max ( l , s ) , min ( r , t ) ) : <NEWLINE> <INDENT> Data_val [ i ] = f <NEWLINE> <DEDENT> Bucket_val [ k ] = 0 <NEWLINE> for i in range ( l , min ( r , N ) ) : <NEWLINE> <INDENT> Bucket_val [ k ] = ( Bucket_val [ k ] * 10 + Data_val [ i ] ) % mod <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> def get ( i ) : <NEWLINE> <INDENT> k = i // sqrtN <NEWLINE> eval_data ( k ) <NEWLINE> return Data_val [ i ] <NEWLINE> <NL> <DEDENT> def all_prod ( ) : <NEWLINE> <INDENT> res = 0 <NEWLINE> for k in range ( n_buckets - 1 ) : <NEWLINE> <INDENT> res = ( res * p10 [ sqrtN ] + Bucket_val [ k ] ) % mod <NEWLINE> <DEDENT> res = ( res * p10 [ M ] + Bucket_val [ n_buckets - 1 ] ) % mod <NEWLINE> return res <NEWLINE> <NL> <DEDENT> Ans = np . zeros ( Q , dtype = np . int64 ) <NEWLINE> for i in range ( Q ) : <NEWLINE> <INDENT> l , r , d = LRD [ i ] <NEWLINE> apply ( l - 1 , r , d ) <NEWLINE> ans = all_prod ( ) <NEWLINE> Ans [ i ] = ans <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> return Ans <NEWLINE> <NL> <NL> <DEDENT> numba_compile ( [ <NEWLINE> <INDENT> [ solve , <STRING> ] <NEWLINE> <DEDENT> ] ) <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> N , Q = map ( int , sys . stdin . buffer . readline ( ) . split ( ) ) <NEWLINE> LRD = np . array ( sys . stdin . buffer . read ( ) . split ( ) , dtype = np . int64 ) . reshape ( Q , 3 ) <NEWLINE> Ans = solve ( N , Q , LRD ) <NEWLINE> print ( <STRING> . join ( map ( str , Ans . tolist ( ) ) ) ) <NEWLINE> <NL> <NL> <DEDENT> main ( ) <NEWLINE>
import os <NEWLINE> import sys <NEWLINE> from heapq import heappop , heappush <NEWLINE> <NL> import numpy as np <NEWLINE> <NL> <NL> <COMMENT> <NL> <NL> def solve ( inp ) : <NEWLINE> <INDENT> def ceil_pow2 ( n ) : <NEWLINE> <INDENT> x = 0 <NEWLINE> while 1 << x < n : <NEWLINE> <INDENT> x += 1 <NEWLINE> <DEDENT> return x <NEWLINE> <NL> <DEDENT> def bit_scan_forward ( n ) : <NEWLINE> <INDENT> x = 0 <NEWLINE> while n & 1 == 0 : <NEWLINE> <INDENT> n >>= 1 <NEWLINE> x += 1 <NEWLINE> <DEDENT> return x <NEWLINE> <NL> <DEDENT> def pow_mod ( x , n , m ) : <NEWLINE> <INDENT> r = 1 <NEWLINE> y = x % m <NEWLINE> while n : <NEWLINE> <INDENT> if n & 1 : <NEWLINE> <INDENT> r = ( r * y ) % m <NEWLINE> <DEDENT> y = y * y % m <NEWLINE> n >>= 1 <NEWLINE> <DEDENT> return r <NEWLINE> <NL> <DEDENT> def get_primitive_root ( m ) : <NEWLINE> <INDENT> if m == 2 : return 1 <NEWLINE> if m == 167772161 : return 3 <NEWLINE> if m == 469762049 : return 3 <NEWLINE> if m == 754974721 : return 11 <NEWLINE> if m == 998244353 : return 3 <NEWLINE> divs = [ 2 ] <NEWLINE> x = ( m - 1 ) // 2 <NEWLINE> while x & 1 == 0 : <NEWLINE> <INDENT> x >>= 1 <NEWLINE> <DEDENT> i = 3 <NEWLINE> while i * i <= x : <NEWLINE> <INDENT> if x % i == 0 : <NEWLINE> <INDENT> divs . append ( i ) <NEWLINE> x //= i <NEWLINE> while x % i == 0 : <NEWLINE> <INDENT> x //= i <NEWLINE> <DEDENT> <DEDENT> i += 2 <NEWLINE> <DEDENT> if x > 1 : <NEWLINE> <INDENT> divs . append ( x ) <NEWLINE> <DEDENT> g = 2 <NEWLINE> while True : <NEWLINE> <INDENT> ok = True <NEWLINE> for d in divs : <NEWLINE> <INDENT> if pow_mod ( g , ( m - 1 ) // d , m ) == 1 : <NEWLINE> <INDENT> ok = False <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if ok : <NEWLINE> <INDENT> return g <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> def butterfly_prepare ( mod , primitive_root ) : <NEWLINE> <INDENT> sum_e = np . zeros ( 30 , np . int64 ) <NEWLINE> sum_ie = np . zeros ( 30 , np . int64 ) <NEWLINE> es = np . zeros ( 30 , np . int64 ) <NEWLINE> ies = np . zeros ( 30 , np . int64 ) <NEWLINE> cnt2 = bit_scan_forward ( mod - 1 ) <NEWLINE> e = pow_mod ( primitive_root , ( mod - 1 ) >> cnt2 , mod ) <NEWLINE> ie = pow_mod ( e , mod - 2 , mod ) <NEWLINE> for i in range ( cnt2 , 1 , - 1 ) : <NEWLINE> <INDENT> es [ i - 2 ] = e <NEWLINE> ies [ i - 2 ] = ie <NEWLINE> e = e * e % mod <NEWLINE> ie = ie * ie % mod <NEWLINE> <DEDENT> now_e = 1 <NEWLINE> now_ie = 1 <NEWLINE> for i in range ( cnt2 - 1 ) : <NEWLINE> <INDENT> sum_e [ i ] = es [ i ] * now_e % mod <NEWLINE> sum_ie [ i ] = ies [ i ] * now_ie % mod <NEWLINE> now_e = now_e * ies [ i ] % mod <NEWLINE> now_ie = now_ie * es [ i ] % mod <NEWLINE> <DEDENT> return sum_e , sum_ie <NEWLINE> <NL> <DEDENT> def butterfly ( aaa , mod , sum_e ) : <NEWLINE> <INDENT> n = aaa . size <NEWLINE> h = ceil_pow2 ( n ) <NEWLINE> <NL> for ph in range ( 1 , h + 1 ) : <NEWLINE> <INDENT> w = 1 << ( ph - 1 ) <NEWLINE> p = 1 << ( h - ph ) <NEWLINE> now = 1 <NEWLINE> for s in range ( w ) : <NEWLINE> <INDENT> offset = s << ( h - ph + 1 ) <NEWLINE> for i in range ( p ) : <NEWLINE> <INDENT> l = aaa [ i + offset ] <NEWLINE> r = aaa [ i + offset + p ] * now % mod <NEWLINE> aaa [ i + offset ] = ( l + r ) % mod <NEWLINE> aaa [ i + offset + p ] = ( l - r ) % mod <NEWLINE> <DEDENT> now = now * sum_e [ bit_scan_forward ( ~ s ) ] % mod <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> def butterfly_inv ( aaa , mod , sum_ie ) : <NEWLINE> <INDENT> n = aaa . size <NEWLINE> h = ceil_pow2 ( n ) <NEWLINE> <NL> for ph in range ( h , 0 , - 1 ) : <NEWLINE> <INDENT> w = 1 << ( ph - 1 ) <NEWLINE> p = 1 << ( h - ph ) <NEWLINE> inow = 1 <NEWLINE> for s in range ( w ) : <NEWLINE> <INDENT> offset = s << ( h - ph + 1 ) <NEWLINE> for i in range ( p ) : <NEWLINE> <INDENT> l = aaa [ i + offset ] <NEWLINE> r = aaa [ i + offset + p ] <NEWLINE> aaa [ i + offset ] = ( l + r ) % mod <NEWLINE> aaa [ i + offset + p ] = ( ( l - r ) * inow ) % mod <NEWLINE> <DEDENT> inow = inow * sum_ie [ bit_scan_forward ( ~ s ) ] % mod <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> MOD = 998244353 <NEWLINE> primitive_root = get_primitive_root ( MOD ) <NEWLINE> sum_e , sum_ie = butterfly_prepare ( MOD , primitive_root ) <NEWLINE> <NL> def convolution ( aaa , bbb , MOD ) : <NEWLINE> <INDENT> n = aaa . size <NEWLINE> m = bbb . size <NEWLINE> z = 1 << ceil_pow2 ( n + m - 1 ) <NEWLINE> raaa = np . zeros ( z , np . int64 ) <NEWLINE> rbbb = np . zeros ( z , np . int64 ) <NEWLINE> raaa [ : n ] = aaa <NEWLINE> rbbb [ : m ] = bbb <NEWLINE> butterfly ( raaa , MOD , sum_e ) <NEWLINE> butterfly ( rbbb , MOD , sum_e ) <NEWLINE> ccc = raaa * rbbb % MOD <NEWLINE> butterfly_inv ( ccc , MOD , sum_ie ) <NEWLINE> iz = pow_mod ( z , MOD - 2 , MOD ) <NEWLINE> result = ccc [ : n + m - 1 ] * iz % MOD <NEWLINE> return result <NEWLINE> <NL> <DEDENT> def mod_pow ( x , a , MOD ) : <NEWLINE> <INDENT> ret = 1 <NEWLINE> cur = x <NEWLINE> while a : <NEWLINE> <INDENT> if a & 1 : <NEWLINE> <INDENT> ret = ret * cur % MOD <NEWLINE> <DEDENT> cur = cur * cur % MOD <NEWLINE> a >>= 1 <NEWLINE> <DEDENT> return ret <NEWLINE> <NL> <DEDENT> def precompute_factorials ( n , MOD ) : <NEWLINE> <INDENT> factorials = np . ones ( n + 1 , dtype = np . int64 ) <NEWLINE> for m in range ( 2 , n + 1 ) : <NEWLINE> <INDENT> factorials [ m ] = factorials [ m - 1 ] * m % MOD <NEWLINE> <DEDENT> inversions = np . ones ( n + 1 , dtype = np . int64 ) <NEWLINE> inversions [ n ] = mod_pow ( factorials [ n ] , MOD - 2 , MOD ) <NEWLINE> for m in range ( n , 2 , - 1 ) : <NEWLINE> <INDENT> inversions [ m - 1 ] = inversions [ m ] * m % MOD <NEWLINE> <DEDENT> return factorials , inversions <NEWLINE> <NL> <DEDENT> def counter ( arr ) : <NEWLINE> <INDENT> cnt = { 0 : 0 } <NEWLINE> for a in arr : <NEWLINE> <INDENT> if a in cnt : <NEWLINE> <INDENT> cnt [ a ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cnt [ a ] = 1 <NEWLINE> <DEDENT> <DEDENT> if cnt [ 0 ] == 0 : <NEWLINE> <INDENT> del cnt [ 0 ] <NEWLINE> <DEDENT> return cnt <NEWLINE> <NL> <DEDENT> n = inp [ 0 ] <NEWLINE> hhh = inp [ 1 : ] <NEWLINE> hhh_cnt = counter ( hhh ) <NEWLINE> same_heights = [ ] <NEWLINE> max_pair_cnt = 0 <NEWLINE> max_same_height = 0 <NEWLINE> for c in hhh_cnt . values ( ) : <NEWLINE> <INDENT> if c <= 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> max_pair_cnt += c // 2 <NEWLINE> max_same_height = max ( max_same_height , c ) <NEWLINE> same_heights . append ( c ) <NEWLINE> <NL> <DEDENT> pairs = np . zeros ( n + 1 , np . int64 ) <NEWLINE> pairs [ 0 ] = 1 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> pairs [ i ] = pairs [ i - 1 ] * ( i * 2 - 1 ) % MOD <NEWLINE> <NL> <DEDENT> facts , finvs = precompute_factorials ( max_same_height , MOD ) <NEWLINE> <NL> same_heights . sort ( ) <NEWLINE> pc = - 1 <NEWLINE> cmbs = [ ] <NEWLINE> q = [ ] <NEWLINE> for i , c in enumerate ( same_heights ) : <NEWLINE> <INDENT> if pc == c : <NEWLINE> <INDENT> cmb = cmbs [ - 1 ] . copy ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cmb = np . zeros ( c // 2 + 1 , np . int64 ) <NEWLINE> for j in range ( c // 2 + 1 ) : <NEWLINE> <INDENT> cmb [ j ] = facts [ c ] * finvs [ j * 2 ] % MOD * finvs [ c - j * 2 ] % MOD * pairs [ j ] % MOD <NEWLINE> <DEDENT> pc = c <NEWLINE> <DEDENT> cmbs . append ( cmb ) <NEWLINE> q . append ( ( cmb . size , i ) ) <NEWLINE> <NL> <DEDENT> while len ( q ) > 1 : <NEWLINE> <INDENT> _ , i = heappop ( q ) <NEWLINE> _ , j = heappop ( q ) <NEWLINE> cmbs [ i ] = convolution ( cmbs [ i ] , cmbs [ j ] , MOD ) <NEWLINE> heappush ( q , ( cmbs [ i ] . size , i ) ) <NEWLINE> <NL> <DEDENT> result = cmbs [ q [ 0 ] [ 1 ] ] <NEWLINE> <NL> ans = 0 <NEWLINE> for i , v in enumerate ( result ) : <NEWLINE> <INDENT> if i & 1 : <NEWLINE> <INDENT> ans = ( ans - v * pairs [ n - i ] ) % MOD <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = ( ans + v * pairs [ n - i ] ) % MOD <NEWLINE> <NL> <DEDENT> <DEDENT> return ans <NEWLINE> <NL> <NL> <DEDENT> if sys . argv [ - 1 ] == <STRING> : <NEWLINE> <INDENT> from numba . pycc import CC <NEWLINE> <NL> cc = CC ( <STRING> ) <NEWLINE> cc . export ( <STRING> , <STRING> ) ( solve ) <NEWLINE> cc . compile ( ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> if os . name == <STRING> : <NEWLINE> <COMMENT> <NL> <INDENT> from my_module import solve <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> from numba import njit <NEWLINE> <NL> solve = njit ( <STRING> , cache = True ) ( solve ) <NEWLINE> print ( <STRING> , file = sys . stderr ) <NEWLINE> <NL> <DEDENT> inp = np . fromstring ( sys . stdin . read ( ) , dtype = np . int64 , sep = <STRING> ) <NEWLINE> ans = solve ( inp ) <NEWLINE> print ( ans ) <NEWLINE>
import sys <NEWLINE> import heapq , functools , collections <NEWLINE> import math , random <NEWLINE> from collections import Counter , defaultdict <NEWLINE> <NL> from atcoder . fenwicktree import FenwickTree <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> def solve ( grid , n ) : <COMMENT> <NEWLINE> <INDENT> console ( <STRING> ) <NEWLINE> grid = [ ( x - 1 , y - 1 ) for x , y in grid ] <NEWLINE> <NL> m = { } <NEWLINE> for i , ( x , y ) in enumerate ( grid ) : <NEWLINE> <INDENT> m [ x ] = i <NEWLINE> <NL> <DEDENT> grid = sorted ( grid ) <NEWLINE> console ( grid ) <NEWLINE> <NL> g = defaultdict ( list ) <NEWLINE> y_heap = [ ] <NEWLINE> heapq . heapify ( y_heap ) <NEWLINE> <NL> for x , y in grid : <NEWLINE> <INDENT> if y_heap : <NEWLINE> <INDENT> ymin , xmin = y_heap [ 0 ] <NEWLINE> if ymin < y : <NEWLINE> <INDENT> while y_heap and y_heap [ 0 ] < ( y , x ) : <NEWLINE> <INDENT> ycur , xcur = heapq . heappop ( y_heap ) <NEWLINE> g [ x ] . append ( xcur ) <NEWLINE> g [ xcur ] . append ( x ) <NEWLINE> <DEDENT> heapq . heappush ( y_heap , ( ymin , xmin ) ) <NEWLINE> <DEDENT> <DEDENT> heapq . heappush ( y_heap , ( y , x ) ) <NEWLINE> <NL> <DEDENT> console ( g ) <NEWLINE> <NL> res = [ 0 for _ in grid ] <NEWLINE> visited_1 = [ 0 for _ in grid ] <NEWLINE> visited_2 = [ 0 for _ in grid ] <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> if res [ i ] : <COMMENT> <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> visited_1 [ i ] = 1 <NEWLINE> stack = [ i ] <NEWLINE> cnt = 1 <NEWLINE> while stack : <NEWLINE> <INDENT> cur = stack . pop ( ) <NEWLINE> for nex in g [ cur ] : <NEWLINE> <INDENT> if not visited_1 [ nex ] : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> visited_1 [ nex ] = 1 <NEWLINE> stack . append ( nex ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> visited_2 [ i ] = 1 <NEWLINE> stack = [ i ] <NEWLINE> while stack : <NEWLINE> <INDENT> cur = stack . pop ( ) <NEWLINE> res [ cur ] = cnt <NEWLINE> for nex in g [ cur ] : <NEWLINE> <INDENT> if not visited_2 [ nex ] : <NEWLINE> <INDENT> visited_2 [ nex ] = 1 <NEWLINE> stack . append ( nex ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> console ( res ) <NEWLINE> console ( visited_1 ) <NEWLINE> console ( visited_2 ) <NEWLINE> res2 = [ 0 for _ in grid ] <NEWLINE> for i , x in m . items ( ) : <NEWLINE> <INDENT> res2 [ x ] = res [ i ] <NEWLINE> <NL> <DEDENT> return res2 <NEWLINE> <NL> <NL> <NL> <NL> <DEDENT> def console ( * args ) : <COMMENT> <NEWLINE> <COMMENT> <NL> <INDENT> return <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> inp = sys . stdin . readlines ( ) <NEWLINE> <NL> for case_num in [ 1 ] : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <INDENT> nrows = int ( inp [ 0 ] ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> grid = [ ] <NEWLINE> for n in range ( nrows ) : <NEWLINE> <INDENT> grid . append ( list ( map ( int , inp [ n + 1 ] . split ( ) ) ) ) <NEWLINE> <NL> <DEDENT> res = solve ( grid , nrows ) <COMMENT> <NEWLINE> <NL> res = <STRING> . join ( str ( x ) for x in res ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> print ( res ) <NEWLINE> <DEDENT>
from collections import defaultdict <NEWLINE> from itertools import chain , combinations <NEWLINE> import numpy as np <NEWLINE> import numba <NEWLINE> <NL> <NL> def ext_gcd ( a , b ) : <NEWLINE> <INDENT> x0 , y0 , x1 , y1 = 1 , 0 , 0 , 1 <NEWLINE> while b != 0 : <NEWLINE> <INDENT> q , a , b = a // b , b , a % b <NEWLINE> x0 , x1 = x1 , x0 - q * x1 <NEWLINE> y0 , y1 = y1 , y0 - q * y1 <NEWLINE> <DEDENT> return a , x0 , y0 <NEWLINE> <NL> <NL> <DEDENT> @ numba . njit <NEWLINE> def search_prime ( pq , lower = 10 ** 6 , upper = 32 * 10 ** 6 ) : <NEWLINE> <INDENT> for p in range ( lower , upper ) : <NEWLINE> <INDENT> if pq % p == 0 : <NEWLINE> <INDENT> q = pq // p <NEWLINE> return p , q <NEWLINE> <DEDENT> <DEDENT> return 1 , pq <NEWLINE> <NL> <NL> <DEDENT> def solve ( n ) : <NEWLINE> <COMMENT> <NL> <INDENT> primes_array = np . ones ( 10 ** 6 , dtype = np . int8 ) <NEWLINE> primes_array [ 0 ] = 0 <NEWLINE> primes_array [ 1 ] = 0 <NEWLINE> for p in range ( 10 ** 6 ) : <NEWLINE> <INDENT> if primes_array [ p ] == 1 : <NEWLINE> <INDENT> primes_array [ p * p : : p ] = 0 <NEWLINE> <DEDENT> <DEDENT> primes = np . where ( [ primes_array > 0 ] ) [ 1 ] <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> factorization = defaultdict ( int ) <NEWLINE> m = 2 * n <NEWLINE> for p in primes : <NEWLINE> <INDENT> while m % p == 0 : <NEWLINE> <INDENT> m = m // p <NEWLINE> factorization [ p ] += 1 <NEWLINE> <DEDENT> <DEDENT> if m > 1 : <NEWLINE> <INDENT> p , q = search_prime ( m ) <NEWLINE> if p > 1 : <NEWLINE> <INDENT> factorization [ p ] += 1 <NEWLINE> <DEDENT> if q > 1 : <NEWLINE> <INDENT> factorization [ q ] += 1 <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> factor_list = [ ] <NEWLINE> for k in factorization . keys ( ) : <NEWLINE> <INDENT> factor_list . append ( k ** factorization [ k ] ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> if n % 2 == 1 : <NEWLINE> <INDENT> res = n - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> res = 2 * n - 1 <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> for s in chain . from_iterable ( combinations ( factor_list , r ) for r in range ( len ( factor_list ) + 1 ) ) : <NEWLINE> <INDENT> p = np . int ( np . prod ( s ) ) <NEWLINE> q = 2 * n // p <NEWLINE> if p == 1 or q == 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> a , x , y = ext_gcd ( p , q ) <NEWLINE> if x < 0 : <NEWLINE> <INDENT> res = min ( res , abs ( p * x ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> return res <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> res = solve ( n ) <NEWLINE> print ( res ) <NEWLINE> <NL> <NL> <DEDENT> def test ( ) : <NEWLINE> <INDENT> assert solve ( 11 ) == 10 <NEWLINE> assert solve ( 20200920 ) == 1100144 <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> test ( ) <NEWLINE> main ( ) <NEWLINE> <DEDENT>
import os <NEWLINE> import sys <NEWLINE> from heapq import heappop , heappush <NEWLINE> <NL> import numpy as np <NEWLINE> <NL> <NL> def solve ( n , m , field ) : <NEWLINE> <INDENT> MINCOSTFLOW_LINKS = [ ] <NEWLINE> MINCOSTFLOW_LINK_INDICES = [ ] <NEWLINE> MINCOSTFLOW_CURRENT_LINK_INDEX = [ ] <NEWLINE> INF = 10 ** 10 <NEWLINE> <NL> def mincostflow_init ( m ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> MINCOSTFLOW_LINKS . append ( np . zeros ( ( m * 2 , 5 ) , np . int64 ) ) <NEWLINE> MINCOSTFLOW_CURRENT_LINK_INDEX . append ( 0 ) <NEWLINE> return len ( MINCOSTFLOW_LINKS ) - 1 <NEWLINE> <NL> <DEDENT> def mincostflow_add_link ( ins , frm , to , capacity , cost ) : <NEWLINE> <INDENT> links = MINCOSTFLOW_LINKS [ ins ] <NEWLINE> li = MINCOSTFLOW_CURRENT_LINK_INDEX [ ins ] <NEWLINE> links [ li ] = ( frm , to , capacity , cost , li + 1 ) <NEWLINE> links [ li + 1 ] = ( to , frm , 0 , - cost , li ) <NEWLINE> MINCOSTFLOW_CURRENT_LINK_INDEX [ ins ] += 2 <NEWLINE> <NL> <DEDENT> def mincostflow_fix_link ( ins , n ) : <NEWLINE> <INDENT> links = MINCOSTFLOW_LINKS [ ins ] <NEWLINE> sort_idx = np . argsort ( links [ : , 0 ] ) <NEWLINE> links [ links [ sort_idx , 4 ] , 4 ] = np . arange ( sort_idx . size ) <NEWLINE> links = links [ sort_idx ] <NEWLINE> <NL> MINCOSTFLOW_LINK_INDICES . append ( np . searchsorted ( links [ : , 0 ] , np . arange ( n + 1 ) ) ) <NEWLINE> MINCOSTFLOW_LINKS [ ins ] = links <NEWLINE> <NL> <DEDENT> def mincostflow_flow ( ins , s , t , quantity ) : <NEWLINE> <INDENT> links = MINCOSTFLOW_LINKS [ ins ] <NEWLINE> link_indices = MINCOSTFLOW_LINK_INDICES [ ins ] <NEWLINE> n = len ( links ) <NEWLINE> res = 0 <NEWLINE> potentials = np . zeros ( n , dtype = np . int64 ) <NEWLINE> dist = np . full ( n , INF , dtype = np . int64 ) <NEWLINE> prev_v = np . full ( n , - 1 , dtype = np . int64 ) <NEWLINE> prev_e = np . full ( n , - 1 , dtype = np . int64 ) <NEWLINE> <NL> while quantity : <NEWLINE> <INDENT> dist . fill ( INF ) <NEWLINE> dist [ s ] = 0 <NEWLINE> que = [ ( 0 , s ) ] <NEWLINE> <NL> while que : <NEWLINE> <INDENT> total_cost , v = heappop ( que ) <NEWLINE> if dist [ v ] < total_cost : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> for li in range ( link_indices [ v ] , link_indices [ v + 1 ] ) : <NEWLINE> <INDENT> _ , u , cap , cost , _ = links [ li ] <NEWLINE> new_cost = dist [ v ] + potentials [ v ] - potentials [ u ] + cost <NEWLINE> if cap > 0 and new_cost < dist [ u ] : <NEWLINE> <INDENT> dist [ u ] = new_cost <NEWLINE> prev_v [ u ] = v <NEWLINE> prev_e [ u ] = li <NEWLINE> heappush ( que , ( new_cost , u ) ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> if dist [ t ] == INF : <NEWLINE> <INDENT> return - 1 <NEWLINE> <NL> <DEDENT> potentials += dist <NEWLINE> <NL> cur_flow = quantity <NEWLINE> v = t <NEWLINE> while v != s : <NEWLINE> <INDENT> cur_flow = min ( cur_flow , links [ prev_e [ v ] ] [ 2 ] ) <NEWLINE> v = prev_v [ v ] <NEWLINE> <DEDENT> quantity -= cur_flow <NEWLINE> res += cur_flow * potentials [ t ] <NEWLINE> <NL> v = t <NEWLINE> while v != s : <NEWLINE> <INDENT> link = links [ prev_e [ v ] ] <NEWLINE> link [ 2 ] -= cur_flow <NEWLINE> links [ link [ 4 ] ] [ 2 ] += cur_flow <NEWLINE> v = prev_v [ v ] <NEWLINE> <NL> <DEDENT> <DEDENT> return res <NEWLINE> <NL> <DEDENT> nm = ( n + 2 ) * ( m + 2 ) <NEWLINE> m2 = m + 2 <NEWLINE> <NL> starts = np . where ( field == 1 ) [ 0 ] <NEWLINE> s_size = starts . size <NEWLINE> <NL> ins = mincostflow_init ( nm + s_size + 2 ) <NEWLINE> s = nm + s_size <NEWLINE> t = s + 1 <NEWLINE> <NL> stack = np . zeros ( 10 ** 7 , np . int64 ) <NEWLINE> <NL> for i in range ( s_size ) : <NEWLINE> <INDENT> mincostflow_add_link ( ins , s , nm + i , 1 , 0 ) <NEWLINE> <NL> stack [ 0 ] = starts [ i ] <NEWLINE> stack [ 1 ] = 0 <NEWLINE> sl = 0 <NEWLINE> sr = 2 <NEWLINE> stacked = np . zeros ( nm , np . int8 ) <NEWLINE> stacked [ starts [ i ] ] = 1 <NEWLINE> while sl < sr : <NEWLINE> <INDENT> v = stack [ sl ] <NEWLINE> c = stack [ sl + 1 ] <NEWLINE> sl += 2 <NEWLINE> <NL> mincostflow_add_link ( ins , nm + i , v , 1 , INF - c ) <NEWLINE> <NL> if stacked [ v + 1 ] == 0 and field [ v + 1 ] != 2 : <NEWLINE> <INDENT> stack [ sr ] = v + 1 <NEWLINE> stack [ sr + 1 ] = c + 1 <NEWLINE> stacked [ v + 1 ] = 1 <NEWLINE> sr += 2 <NEWLINE> <DEDENT> if stacked [ v + m2 ] == 0 and field [ v + m2 ] != 2 : <NEWLINE> <INDENT> stack [ sr ] = v + m2 <NEWLINE> stack [ sr + 1 ] = c + 1 <NEWLINE> stacked [ v + m2 ] = 1 <NEWLINE> sr += 2 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for i in range ( nm ) : <NEWLINE> <INDENT> if field [ i ] != 2 : <NEWLINE> <INDENT> mincostflow_add_link ( ins , i , t , 1 , 0 ) <NEWLINE> <NL> <DEDENT> <DEDENT> mincostflow_fix_link ( ins , nm + s_size + 2 ) <NEWLINE> f = mincostflow_flow ( ins , s , t , s_size ) <NEWLINE> <NL> ans = INF * s_size - f <NEWLINE> return ans <NEWLINE> <NL> <NL> <DEDENT> SIGNATURE = <STRING> <NEWLINE> if sys . argv [ - 1 ] == <STRING> : <NEWLINE> <INDENT> from numba . pycc import CC <NEWLINE> <NL> cc = CC ( <STRING> ) <NEWLINE> cc . export ( <STRING> , SIGNATURE ) ( solve ) <NEWLINE> cc . compile ( ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> if os . name == <STRING> : <NEWLINE> <COMMENT> <NL> <INDENT> from my_module import solve <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> from numba import njit <NEWLINE> <NL> solve = njit ( SIGNATURE , cache = True ) ( solve ) <NEWLINE> print ( <STRING> , file = sys . stderr ) <NEWLINE> <NL> <DEDENT> n , m = map ( int , sys . stdin . readline ( ) . split ( ) ) <NEWLINE> field = <STRING> * ( m + 3 ) + <STRING> . join ( sys . stdin . read ( ) . split ( ) ) + <STRING> * ( m + 3 ) <NEWLINE> field = np . fromiter ( map ( <STRING> . index , field ) , np . int8 ) <NEWLINE> ans = solve ( n , m , field ) <NEWLINE> print ( ans ) <NEWLINE>
s = int ( input ( ) ) <NEWLINE> if s [ - 1 ] != <STRING> : <NEWLINE> <INDENT> s += <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s += <STRING> <NEWLINE> <DEDENT> print ( s ) <NEWLINE>
s = input ( ) <NEWLINE> if s . endwith ( <STRING> ) : <NEWLINE> <INDENT> print ( s + <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( s + <STRING> ) <NEWLINE> <DEDENT>
from unittest import TestCase , main <NEWLINE> from A import func <NEWLINE> <NL> class test ( TestCase ) : <NEWLINE> <INDENT> def test_with_valid_params ( self ) : <NEWLINE> <INDENT> test_patterns = [ <NEWLINE> <INDENT> ( <STRING> , <STRING> ) , <NEWLINE> ( <STRING> , <STRING> ) , <NEWLINE> ( <STRING> , <STRING> ) <NEWLINE> <DEDENT> ] <NEWLINE> <NL> for S , result in test_patterns : <NEWLINE> <INDENT> with self . subTest ( S = S ) : <NEWLINE> <INDENT> self . assertEqual ( func ( S ) , result ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> l = len ( s ) <NEWLINE> if s [ l - 1 ] == <STRING> : <NEWLINE> <INDENT> s += <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> l . append ( <STRING> ) <NEWLINE> <DEDENT> print ( s ) <NEWLINE>
s = input ( ) <NEWLINE> if s [ s . length - 1 ] == <STRING> : <NEWLINE> <INDENT> print ( s + <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( s + <STRING> ) <NEWLINE> <NL> <DEDENT>
from pattern . en import pluralize , singularize <NEWLINE> s = input ( ) <NEWLINE> print ( pluralize ( s ) ) <NEWLINE>
s = input ( ) <NEWLINE> <NL> if s [ - 1 ] != <STRING> : <NEWLINE> <INDENT> s . append ( <STRING> ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> s . append ( <STRING> ) <NEWLINE> <NL> <DEDENT> print ( s ) <NEWLINE>
s = sys . stdin <NEWLINE> if s [ len ( s ) - 1 ] == <STRING> : <NEWLINE> <INDENT> print ( s + <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( s + <STRING> ) <NEWLINE> <DEDENT>
S = input ( ) <NEWLINE> s = len ( S ) <NEWLINE> if S [ s ] == <STRING> : <NEWLINE> <INDENT> print ( S + <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( S + <STRING> ) <NEWLINE> <DEDENT>
S = input ( ) <NEWLINE> if S [ - 1 : ] = s : <NEWLINE> <INDENT> print ( S + <STRING> ) <NEWLINE> <DEDENT> else : print ( S + <STRING> ) <NEWLINE>
<INDENT> x = str ( input ( ) ) <NEWLINE> <DEDENT> a = list ( x ) <NEWLINE> l = len ( a ) <NEWLINE> if a [ l - 1 ] == <STRING> : <NEWLINE> <INDENT> print ( x + <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( x + <STRING> ) <NEWLINE> <DEDENT>
chr = input ( <STRING> ) <NEWLINE> num = len ( s ) <NEWLINE> <NL> if chr [ num - 1 ] == <STRING> : <NEWLINE> <INDENT> print ( chr + <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( chr + <STRING> ) <NEWLINE> <NL> <DEDENT>
n = input ( ) <NEWLINE> l = len ( n ) <NEWLINE> if n [ l - 1 ] == s : <NEWLINE> <INDENT> print ( n + <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( n + <STRING> ) <NEWLINE> <DEDENT>
import inflect <NEWLINE> s = input ( ) <NEWLINE> <NL> p = inflect . engine ( ) <NEWLINE> print ( p . plural ( s ) ) <NEWLINE>
n = input ( ) <NEWLINE> <NL> if n [ len ( n - 1 ) ] == <STRING> : <NEWLINE> <INDENT> print ( n + <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( n + <STRING> ) <NEWLINE> <DEDENT>
x = input ( ) <NEWLINE> if x [ - 1 ] == <STRING> <NEWLINE> <INDENT> x += <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x += <STRING> <NEWLINE> <NL> <DEDENT> print ( x ) <NEWLINE>
S = input ( ) <NEWLINE> if S [ - 1 ] == s : <NEWLINE> <INDENT> print ( <STRING> + <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> + <STRING> ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> p = <STRING> <NEWLINE> <NL> if ( s . endswith ( <STRING> ) ) { <NEWLINE> <INDENT> p = s + <STRING> <NEWLINE> <DEDENT> } else { <NEWLINE> <INDENT> p = s + <STRING> <NEWLINE> <DEDENT> } <NEWLINE> <NL> print ( s ) <NEWLINE>
x = input ( ) <NEWLINE> print ( x + <STRING> if x [ len ( x ) - 1 ] != s else x [ 0 : len ( x ) - 1 ] + <STRING> ) <NEWLINE>
N = int ( input ( <STRING> ) ) <NEWLINE> d = 0 <NEWLINE> for a in range ( N ) : <NEWLINE> <INDENT> for b in range ( N ) : <NEWLINE> <INDENT> for c in range ( N ) : <NEWLINE> <INDENT> if a * b + c == N : <NEWLINE> <INDENT> d += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( d ) <NEWLINE>
S = input ( ) <NEWLINE> if ( S [ - 1 : ] == s ) : <NEWLINE> <INDENT> print ( S + <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( S + <STRING> ) <NEWLINE> <DEDENT>
S = input ( ) <NEWLINE> if S [ - 1 ] == s <NEWLINE> <INDENT> print ( S + <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( S + <STRING> ) <NEWLINE> <DEDENT>
S = input ( ) <NEWLINE> l = len ( S ) <NEWLINE> s = list ( S ) <NEWLINE> if s [ l ] == <STRING> : <NEWLINE> <INDENT> print ( S + <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( S + <STRING> ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> if s [ - 1 ] == s : <NEWLINE> <INDENT> s1 = s + <STRING> <NEWLINE> <INDENT> print ( s1 ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> s2 = s + <STRING> <NEWLINE> <INDENT> print ( s2 ) <NEWLINE> <DEDENT> <DEDENT>
word = int ( input ( ) ) <NEWLINE> <NL> if word [ - 1 ] == <STRING> : <NEWLINE> <INDENT> print ( word + <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( word + <STRING> ) <NEWLINE> <DEDENT>
<STRING> <NEWLINE> <NL> import os <NEWLINE> import sys <NEWLINE> import math <NEWLINE> from itertools import * <NEWLINE> from io import BytesIO , IOBase <NEWLINE> from collections import * <NEWLINE> <NL> <COMMENT> <NL> BUFSIZE = 8192 <NEWLINE> <NL> class FastIO ( IOBase ) : <NEWLINE> <INDENT> newlines = 0 <NEWLINE> <NL> def __init__ ( self , file ) : <NEWLINE> <INDENT> self . _fd = file . fileno ( ) <NEWLINE> self . buffer = BytesIO ( ) <NEWLINE> self . writable = <STRING> in file . mode or <STRING> not in file . mode <NEWLINE> self . write = self . buffer . write if self . writable else None <NEWLINE> <NL> <DEDENT> def read ( self ) : <NEWLINE> <INDENT> while True : <NEWLINE> <INDENT> b = os . read ( self . _fd , max ( os . fstat ( self . _fd ) . st_size , BUFSIZE ) ) <NEWLINE> if not b : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> ptr = self . buffer . tell ( ) <NEWLINE> self . buffer . seek ( 0 , 2 ) , self . buffer . write ( b ) , self . buffer . seek ( ptr ) <NEWLINE> <DEDENT> self . newlines = 0 <NEWLINE> return self . buffer . read ( ) <NEWLINE> <NL> <DEDENT> def readline ( self ) : <NEWLINE> <INDENT> while self . newlines == 0 : <NEWLINE> <INDENT> b = os . read ( self . _fd , max ( os . fstat ( self . _fd ) . st_size , BUFSIZE ) ) <NEWLINE> self . newlines = b . count ( <STRING> ) + ( not b ) <NEWLINE> ptr = self . buffer . tell ( ) <NEWLINE> self . buffer . seek ( 0 , 2 ) , self . buffer . write ( b ) , self . buffer . seek ( ptr ) <NEWLINE> <DEDENT> self . newlines -= 1 <NEWLINE> return self . buffer . readline ( ) <NEWLINE> <NL> <DEDENT> def flush ( self ) : <NEWLINE> <INDENT> if self . writable : <NEWLINE> <INDENT> os . write ( self . _fd , self . buffer . getvalue ( ) ) <NEWLINE> self . buffer . truncate ( 0 ) , self . buffer . seek ( 0 ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> class IOWrapper ( IOBase ) : <NEWLINE> <INDENT> def __init__ ( self , file ) : <NEWLINE> <INDENT> self . buffer = FastIO ( file ) <NEWLINE> self . flush = self . buffer . flush <NEWLINE> self . writable = self . buffer . writable <NEWLINE> self . write = lambda s : self . buffer . write ( s . encode ( <STRING> ) ) <NEWLINE> self . read = lambda : self . buffer . read ( ) . decode ( <STRING> ) <NEWLINE> self . readline = lambda : self . buffer . readline ( ) . decode ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> sys . stdin , sys . stdout = IOWrapper ( sys . stdin ) , IOWrapper ( sys . stdout ) <NEWLINE> <COMMENT> <NL> <NL> <COMMENT> <NL> mod = ( 10 ** 9 ) + 7 <NEWLINE> pi = 3.14159265358979323846264338327950 <NEWLINE> <NL> def i1 ( ) : <COMMENT> <NEWLINE> <INDENT> return int ( sys . stdin . readline ( ) ) <NEWLINE> <NL> <DEDENT> def sf ( ) : <COMMENT> <NEWLINE> <INDENT> return sys . stdin . readline ( ) <NEWLINE> <NL> <DEDENT> def mi ( ) : <COMMENT> <NEWLINE> <INDENT> return map ( int , sys . stdin . readline ( ) . split ( ) ) <NEWLINE> <NL> <DEDENT> def arr ( ) : <COMMENT> <NEWLINE> <INDENT> return list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) <NEWLINE> <NL> <DEDENT> def pf ( ans ) : <COMMENT> <NEWLINE> <INDENT> return sys . stdout . write ( str ( ans ) + <STRING> ) <NEWLINE> <NL> <DEDENT> def gcd ( a , b ) : <NEWLINE> <INDENT> if a == 0 : <NEWLINE> <INDENT> return b <NEWLINE> <DEDENT> elif b == 0 : <NEWLINE> <INDENT> return a <NEWLINE> <DEDENT> if a > b : <NEWLINE> <INDENT> return gcd ( a % b , b ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return gcd ( a , b % a ) <NEWLINE> <NL> <DEDENT> <DEDENT> def lcm ( a , b ) : <NEWLINE> <INDENT> return ( a * b ) // gcd ( a , b ) <NEWLINE> <COMMENT> <NL> <NL> <COMMENT> <NL> <DEDENT> def solve ( ) : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> if s [ - 1 ] = <STRING> : <NEWLINE> <INDENT> print ( s + <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( s + <STRING> ) <NEWLINE> <DEDENT> <DEDENT> solve ( ) <NEWLINE> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NEWLINE>
if S [ - 1 ] == <STRING> : <NEWLINE> <INDENT> print ( S + <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( S + <STRING> ) <NEWLINE> <DEDENT>
word = input ( ) <NEWLINE> if ( word [ - s ] == <STRING> ) : <NEWLINE> <INDENT> print ( word + <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( word + <STRING> ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> if l [ - 1 ] == <STRING> : <NEWLINE> <INDENT> s += <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s += <STRING> <NEWLINE> <DEDENT>
import math <NEWLINE> <NL> from fractions import Fraction as frac <NEWLINE> <NL> MOD = 1e9 + 7 <NEWLINE> <NL> def gcd ( a , b ) : <NEWLINE> <NL> <INDENT> if b == 0 : <NEWLINE> <NL> <INDENT> return a <NEWLINE> <NL> <DEDENT> return gcd ( b , a % b ) <NEWLINE> <NL> <DEDENT> def lcm ( a , b ) : <NEWLINE> <NL> <INDENT> return a * b // gcd ( a , b ) <NEWLINE> <NL> <DEDENT> def solve ( case_no ) : <NEWLINE> <NL> <INDENT> s = str ( input ( ) ) <NEWLINE> <NL> if s [ len ( s ) - 1 ] == <STRING> : <NEWLINE> <NL> <INDENT> print ( s + <STRING> ) else : <NEWLINE> <NL> print ( s + <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> t = 1 <NEWLINE> <NL> <COMMENT> <NL> <NL> for i in range ( 1 , t + 1 ) : <NEWLINE> <NL> <INDENT> solve ( i ) <NEWLINE> <DEDENT>
def createPlural ( s ) : <NEWLINE> <INDENT> if s [ - 1 ] == <STRING> : <NEWLINE> <INDENT> return s [ : - 1 ] + <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return s + <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> s = input ( ) <NEWLINE> s_plural = cratePlural <NEWLINE> print ( s_plural ) <NEWLINE>
s = input ( ) <NEWLINE> if s . endwith ( <STRING> ) : <NEWLINE> <INDENT> print ( s + <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( s + <STRING> ) <NEWLINE> <DEDENT>
input = ( S ) <NEWLINE> if S [ - 1 ] != <STRING> : <NEWLINE> <INDENT> print ( S + <STRING> ) <NEWLINE> <DEDENT> elif S [ - 1 ] == <STRING> : <NEWLINE> <INDENT> print ( S + <STRING> ) <NEWLINE> <DEDENT>
st = input ( ) <NEWLINE> if st [ - 1 ] == <STRING> : <NEWLINE> <INDENT> st . append ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> st . append ( <STRING> ) <NEWLINE> <DEDENT>
input_n = input ( ) <NEWLINE> n = str ( input_n ) <NEWLINE> <NL> listN = list ( n ) <NEWLINE> <COMMENT> <NL> <NL> if listN [ len ( listN ) - 1 ] = <STRING> : <NEWLINE> <INDENT> listN . append ( <STRING> ) <NEWLINE> listN . append ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> listN . append ( <STRING> ) <NEWLINE> <NL> <DEDENT> for i in range ( len ( listN ) - 1 ) : <NEWLINE> <INDENT> print ( listN [ i ] , end = <STRING> ) <NEWLINE> <DEDENT>
S = input ( ) <NEWLINE> if S [ - 1 ] == <STRING> : <NEWLINE> <INDENT> print ( S + <STRING> ) <NEWLINE> else : <NEWLINE> <INDENT> print ( S + <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
N , X , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <NL> A = [ - 1 ] * ( M + 100 ) <NEWLINE> A [ 0 ] = X <NEWLINE> i = 0 <NEWLINE> tmpans = 0 <NEWLINE> flag = False <NEWLINE> check = [ - 1 ] * ( M + 1 ) <NEWLINE> slice = - 1 <NEWLINE> while i < N - 1 : <NEWLINE> <INDENT> newa = A [ i ] ** 2 % M <NEWLINE> i += 1 <NEWLINE> if check [ newa ] != - 1 : <NEWLINE> <INDENT> flag = True <NEWLINE> slice = check [ newa ] <NEWLINE> break <NEWLINE> <DEDENT> A [ i ] = newa <NEWLINE> check [ newa ] = i <NEWLINE> <NL> <DEDENT> if not flag : <NEWLINE> <INDENT> print ( sum ( A [ : i + 1 ] ) ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> print ( sum ( A [ : slice ] ) + sum ( A [ slice : i ] ) * ( ( N - slice ) // ( i - slice ) ) + sum ( A [ slice : slice + ( N - slice ) % ( i - slice ) ] ) ) <NEWLINE> <DEDENT>
<INDENT> singular = input ( ) <NEWLINE> if singular [ - 1 ] == <STRING> : <NEWLINE> <INDENT> print ( singular + <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( singular + <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
a = input ( ) <NEWLINE> if a [ - 1 ] == s : <NEWLINE> <INDENT> print ( a + <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( a + <STRING> ) <NEWLINE> <DEDENT>
s = str ( input ( ) ) <NEWLINE> t = len ( s ) <NEWLINE> if s [ t ] == <STRING> : <NEWLINE> <INDENT> print ( s + <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( s + <STRING> ) <NEWLINE> <DEDENT>
S = input ( ) <NEWLINE> if S [ - 1 ] == <STRING> : <NEWLINE> <INDENT> ans += <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += <STRING> <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
f = open ( <STRING> , <STRING> ) <NEWLINE> input = lambda : f . readline ( ) . strip ( ) <NEWLINE> <NL> s = input ( ) <NEWLINE> if s [ - 1 ] != <STRING> : print ( s + <STRING> ) <NEWLINE> else : print ( s + <STRING> ) <NEWLINE>
S = str ( input ( ) ) <NEWLINE> if S [ - 1 ] == <STRING> : <NEWLINE> <INDENT> S += <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> S += <STRING> <NEWLINE> <DEDENT> return S <NEWLINE> <NL>
st = input ( ) <NEWLINE> <NL> if st [ - 1 ] == <STRING> : <NEWLINE> <INDENT> return st + <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return st + <STRING> <NEWLINE> <DEDENT>
import random <NEWLINE> <NL> <NL> def gcd ( a , b ) : <NEWLINE> <INDENT> if a == 0 : <NEWLINE> <INDENT> return b <NEWLINE> <DEDENT> return gcd ( b % a , a ) <NEWLINE> <NL> <NL> <DEDENT> def lcm ( a , b ) : <NEWLINE> <INDENT> return ( a * b ) / gcd ( a , b ) <NEWLINE> <NL> <DEDENT> s = input ( ) <NEWLINE> if s [ len ( s ) - 1 ] != <STRING> : <NEWLINE> <INDENT> s += <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s += <STRING> <NEWLINE> <DEDENT> print ( s ) <NEWLINE> import random <NEWLINE> <NL> <NL> def gcd ( a , b ) : <NEWLINE> <INDENT> if a == 0 : <NEWLINE> <INDENT> return b <NEWLINE> <DEDENT> return gcd ( b % a , a ) <NEWLINE> <NL> <NL> <DEDENT> def lcm ( a , b ) : <NEWLINE> <INDENT> return ( a * b ) / gcd ( a , b ) <NEWLINE> <NL> <DEDENT> s = input ( ) <NEWLINE> if s [ len ( s ) - 1 ] != <STRING> : <NEWLINE> <INDENT> s += <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s += <STRING> <NEWLINE> <DEDENT> print ( s ) <NEWLINE>
s = input ( ) <NEWLINE> if s [ - 1 ] == <STRING> : <NEWLINE> <INDENT> print ( s + <STRING> ) <NEWLINE> else : <NEWLINE> <INDENT> print ( s + <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
val = input ( ) <NEWLINE> valf = val [ - 1 ] <NEWLINE> if ( valf == s ) : <NEWLINE> <INDENT> print ( val + <STRING> ) <NEWLINE> <DEDENT> else <NEWLINE> <INDENT> print ( val + <STRING> ) <NEWLINE> <DEDENT>
<COMMENT> <NL> def segfunc ( x , y ) : <NEWLINE> <INDENT> return min ( x , y ) <NEWLINE> <COMMENT> <NL> <NL> <COMMENT> <NL> <DEDENT> ide_ele = 10 ** 9 <NEWLINE> <COMMENT> <NL> <NL> class SegTree : <NEWLINE> <INDENT> <STRING> <NEWLINE> def __init__ ( self , init_val , segfunc , ide_ele ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> n = len ( init_val ) <NEWLINE> self . segfunc = segfunc <NEWLINE> self . ide_ele = ide_ele <NEWLINE> self . num = 1 << ( n - 1 ) . bit_length ( ) <NEWLINE> self . tree = [ ide_ele ] * 2 * self . num <NEWLINE> <COMMENT> <NL> for i in range ( n ) : <NEWLINE> <INDENT> self . tree [ self . num + i ] = init_val [ i ] <NEWLINE> <COMMENT> <NL> <DEDENT> for i in range ( self . num - 1 , 0 , - 1 ) : <NEWLINE> <INDENT> self . tree [ i ] = self . segfunc ( self . tree [ 2 * i ] , self . tree [ 2 * i + 1 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> def update ( self , k , x ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> k += self . num <NEWLINE> self . tree [ k ] = x <NEWLINE> while k > 1 : <NEWLINE> <INDENT> self . tree [ k >> 1 ] = self . segfunc ( self . tree [ k ] , self . tree [ k ^ 1 ] ) <NEWLINE> k >>= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> def query ( self , l , r ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> res = self . ide_ele <NEWLINE> <NL> l += self . num <NEWLINE> r += self . num <NEWLINE> while l < r : <NEWLINE> <INDENT> if l & 1 : <NEWLINE> <INDENT> res = self . segfunc ( res , self . tree [ l ] ) <NEWLINE> l += 1 <NEWLINE> <DEDENT> if r & 1 : <NEWLINE> <INDENT> res = self . segfunc ( res , self . tree [ r - 1 ] ) <NEWLINE> <DEDENT> l >>= 1 <NEWLINE> r >>= 1 <NEWLINE> <DEDENT> return res <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> N , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <NL> <NL> ans = ( N - 2 ) ** 2 <NEWLINE> yoko = [ N - 2 for _ in range ( N - 2 ) ] <NEWLINE> tate = [ N - 2 for _ in range ( N - 2 ) ] <NEWLINE> yoko = SegTree ( yoko , segfunc , ide_ele ) <NEWLINE> tate = SegTree ( tate , segfunc , ide_ele ) <NEWLINE> miny = N - 2 <NEWLINE> minx = N - 2 <NEWLINE> for k in range ( Q ) : <NEWLINE> <INDENT> n , x = map ( int , input ( ) . split ( ) ) <NEWLINE> if n == 1 : <NEWLINE> <INDENT> y = x - 2 <NEWLINE> if y < miny : <NEWLINE> <INDENT> ans -= minx <NEWLINE> miny = y <NEWLINE> yoko . update ( min ( minx , N - 3 ) , miny ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans -= tate . query ( y , N - 1 ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> x = x - 2 <NEWLINE> if x < minx : <NEWLINE> <INDENT> ans -= miny <NEWLINE> minx = x <NEWLINE> tate . update ( min ( miny , N - 3 ) , minx ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans -= yoko . query ( x , N - 1 ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = input ( ) <NEWLINE> if n [ len ( n ) - 1 ] == <STRING> : <NEWLINE> <INDENT> n . append ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> n . append ( <STRING> ) <NEWLINE> <DEDENT> print ( <STRING> . join ( n ) ) <NEWLINE>
word = input ( ) <NEWLINE> if word [ - 1 ] == <STRING> : <NEWLINE> <INDENT> return <STRING> . join ( word , <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return <STRING> . join ( word , <STRING> ) <NEWLINE> <DEDENT>
string = input ( ) <NEWLINE> <NL> if string [ - 1 ] != <STRING> : <NEWLINE> <INDENT> new_string = string [ 0 : - 1 ] + <STRING> <NEWLINE> <DEDENT> if string [ - 1 ] = <STRING> : <NEWLINE> <INDENT> new_string = string [ 0 : - 1 ] + <STRING> <NEWLINE> <NL> <DEDENT> print ( new_string ) <NEWLINE>
s = str ( input ( ) ) <NEWLINE> s = list ( s ) <NEWLINE> if s [ len ( s ) - 1 ] == <STRING> : <NEWLINE> <INDENT> print ( <STRING> . join ( s ) + <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> . join ( ) + <STRING> ) <NEWLINE> <DEDENT>
a = input ( ) <NEWLINE> e = a [ len ( a ) - 1 : len ( a ) - 1 ] <NEWLINE> if e == <STRING> : <NEWLINE> <INDENT> print ( a + <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( a + <STRING> <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> if s [ - 1 ] == <STRING> : <NEWLINE> <INDENT> print ( s + <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( sa + <STRING> ) <NEWLINE> <DEDENT>
import sys , re <NEWLINE> import math <NEWLINE> import numpy as np <NEWLINE> from decimal import Decimal <NEWLINE> from collections import deque , defaultdict , Counter <NEWLINE> from math import ceil , sqrt , hypot , factorial , pi , sin , cos , radians <NEWLINE> from itertools import accumulate , permutations , combinations , product <NEWLINE> from operator import itemgetter , mul <COMMENT> <NEWLINE> from copy import deepcopy <NEWLINE> from string import ascii_lowercase , ascii_uppercase , digits <NEWLINE> from bisect import bisect , bisect_left <NEWLINE> from fractions import gcd <COMMENT> <NEWLINE> from heapq import heappush , heappop <NEWLINE> <NL> def input ( ) : return sys . stdin . readline ( ) . strip ( ) <NEWLINE> def INT ( ) : return int ( input ( ) ) <NEWLINE> def MAP ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def LIST ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> sys . maxsize = 10 ** 15 <NEWLINE> sys . setrecursionlimit ( 10 ** 9 + 7 ) <NEWLINE> INF = float ( <STRING> ) <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> <NL> <COMMENT> <NL> <NL> n = input ( ) <NEWLINE> if n [ len ( n ) - 1 ] == s : <NEWLINE> <INDENT> print ( n + <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( n + <STRING> ) <NEWLINE> <DEDENT>
s = list ( input ( ) ) <NEWLINE> if s [ - 1 ] == <STRING> : <NEWLINE> <INDENT> print ( s + <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( s + <STRING> ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> if s [ - 1 ] == <STRING> : <NEWLINE> <INDENT> s += <STRING> <NEWLINE> return s <NEWLINE> <DEDENT> s += <STRING> <NEWLINE> return s <NEWLINE>
s = input ( ) <NEWLINE> if s [ - 1 ] == <STRING> : <NEWLINE> <INDENT> s . append ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s . append ( <STRING> ) <NEWLINE> <DEDENT> print ( s ) <NEWLINE>
if s [ - 1 ] == <STRING> : <NEWLINE> <INDENT> s += <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s += <STRING> <NEWLINE> <DEDENT> print ( s ) <NEWLINE>
s = input ( ) <NEWLINE> a = <STRING> <NEWLINE> if s [ - 1 ] == <STRING> : <NEWLINE> <INDENT> a = <STRING> <NEWLINE> <DEDENT> s . append ( a ) <NEWLINE>
import collections <NEWLINE> n , x , m = map ( int , input ( ) . split ( ) ) <NEWLINE> if n == 1 or x == 0 : <NEWLINE> <INDENT> print ( x ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> start , end , loopcnt = 0 , 0 , 0 <NEWLINE> a = { x : 0 } <NEWLINE> wk = x <NEWLINE> for i in range ( 1 , m ) : <NEWLINE> <INDENT> wk = ( wk * wk ) % m <NEWLINE> if not wk in a : <NEWLINE> <INDENT> a [ wk ] = i <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> start = a [ wk ] <NEWLINE> end = i <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> a = sorted ( a . items ( ) , key = lambda x : x [ 1 ] ) <NEWLINE> koteiindex = min ( n , start ) <NEWLINE> koteiwa = 0 <NEWLINE> for i in range ( koteiindex ) : <NEWLINE> <INDENT> koteiwa += a [ i ] [ 0 ] <NEWLINE> <DEDENT> loopcnt = ( n - koteiindex ) // ( end - start ) <NEWLINE> loopindex = start - 1 + ( n - koteiindex ) % ( end - start ) <NEWLINE> loopwa = 0 <NEWLINE> amariwa = 0 <NEWLINE> for i in range ( start , end ) : <NEWLINE> <INDENT> if i <= loopindex : <NEWLINE> <INDENT> amariwa += a [ i ] [ 0 ] <NEWLINE> <DEDENT> loopwa += a [ i ] [ 0 ] <NEWLINE> <DEDENT> ans = koteiwa + loopwa * loopcnt + amariwa <NEWLINE> print ( ans ) <NEWLINE>
import os <NEWLINE> import sys <NEWLINE> from collections import defaultdict , Counter <NEWLINE> from itertools import product , permutations , combinations , accumulate <NEWLINE> from operator import itemgetter <NEWLINE> from bisect import bisect_left , bisect <NEWLINE> from heapq import heappop , heappush , heapify <NEWLINE> from math import ceil , floor , sqrt <NEWLINE> from copy import deepcopy <NEWLINE> <NL> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> if s [ - 1 ] == <STRING> : <NEWLINE> <INDENT> print ( s + <STRING> ) <NEWLINE> else : <NEWLINE> print ( s + <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
s = input <NEWLINE> if Taknese == s : <NEWLINE> print ( <STRING> ) <NEWLINE> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> if apple == s : <NEWLINE> print ( <STRING> ) <NEWLINE> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> if bus == s : <NEWLINE> print ( <STRING> ) <NEWLINE> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import sys <NEWLINE> S = <STRING> <NEWLINE> S = sys . argv [ 1 ] <NEWLINE> len ( S ) <= 1000 <NEWLINE> if S [ - 1 ] == <STRING> : <NEWLINE> <INDENT> S = S + <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> S = S + <STRING> <NEWLINE> <DEDENT> print ( S ) <NEWLINE>
s = raw_input ( ) <NEWLINE> if ( s [ - 1 ] == <STRING> ) : <NEWLINE> <INDENT> s += <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s += <STRING> <NEWLINE> <DEDENT> print ( s ) <NEWLINE>
s = input ( ) <NEWLINE> <NL> if s [ - 1 ] = <STRING> : <NEWLINE> <INDENT> print ( s + <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( s + <STRING> ) <NEWLINE> <DEDENT>
a = input ( ) <NEWLINE> <NL> if a [ - 1 ] == <STRING> : <NEWLINE> <INDENT> print ( a end = <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( a end = <STRING> ) <NEWLINE> <DEDENT>
print ( input ( ) . strip ( ) + ( <STRING> if s [ - 1 ] == <STRING> else <STRING> ) ) <NEWLINE>
S = input ( ) <NEWLINE> if S [ - 1 ] = <STRING> : <NEWLINE> <INDENT> return S + <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return S + <STRING> <NEWLINE> <DEDENT>
line = input ( ) <NEWLINE> <NL> if line [ len ( line ) ] == ( <STRING> ) : <NEWLINE> <INDENT> line += <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> line += <STRING> <NEWLINE> <DEDENT> print ( line ) <NEWLINE>
p = input ( ) <NEWLINE> if p [ len ( p ) - 1 ] == <STRING> : <NEWLINE> <INDENT> p . append ( <STRING> ) <NEWLINE> print ( p ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> p . append ( <STRING> ) <NEWLINE> print ( p ) <NEWLINE> <DEDENT>
x = input ( ) <NEWLINE> if x [ - 1 ] = <STRING> : <NEWLINE> <INDENT> print ( x <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( x <STRING> ) <NEWLINE> <DEDENT>
from pattern . text . en import singularize <NEWLINE> <NL> plurals = [ int ( input ( ) ) ] <NEWLINE> <NL> singles = [ singularize ( plural ) for plural in plurals ] <NEWLINE> print singles <NEWLINE>
S = input ( ) <NEWLINE> if S [ - 1 ] == <STRING> : <NEWLINE> <INDENT> print ( S , <STRING> ) <NEWLINE> <DEDENT> else print ( S , <STRING> ) <NEWLINE>
s = input ( ) <NEWLINE> <NL> if s [ len ( s ) ] == <STRING> : <NEWLINE> <INDENT> print ( s + <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( s + <STRING> ) <NEWLINE> <DEDENT>
words = input ( ) <NEWLINE> if words [ - 1 ] != s : <NEWLINE> <INDENT> words += <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> words += <STRING> <NEWLINE> <DEDENT> print ( words ) <NEWLINE> <NL> <NL> <NL>
n = int ( input ( ) ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a , b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <DEDENT> for i in range ( n - 2 ) : <NEWLINE> <INDENT> if a [ i ] == b [ i ] and a [ i + 1 ] == b [ i + 1 ] and a [ i + 2 ] == b [ i + 2 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> D = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> D . append ( [ ] ) <COMMENT> <NEWLINE> <NL> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> for j in range ( 2 ) : <NEWLINE> <INDENT> D [ i ] [ j ] = int ( input ( ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> for x in range ( N - 2 ) : <NEWLINE> <INDENT> if D [ x ] [ 1 ] == D [ x ] [ 2 ] and D [ x + 1 ] [ 1 ] == D [ x + 1 ] [ 2 ] and D [ x + 2 ] [ 1 ] == D [ x + 2 ] [ 2 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( intpu ( ) ) <NEWLINE> flag = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if a [ 0 ] == a [ 1 ] : <NEWLINE> <INDENT> flag += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> flag = 0 <NEWLINE> <DEDENT> if flag == 3 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> if flag == 3 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> D = [ map ( int , input ( ) . split ( ) ) for i in range ( N ) ] <NEWLINE> <NL> seq = 0 <NEWLINE> for i in range ( len ( D ) ) : <NEWLINE> <INDENT> if D [ i ] [ 0 ] == D [ i ] [ 1 ] : <NEWLINE> <INDENT> if D [ i + 1 ] [ 0 ] == D [ i + 1 ] [ 1 ] : <NEWLINE> <INDENT> if D [ i + 2 ] [ 0 ] == D [ i + 2 ] [ 1 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
<INDENT> doubletCount = 0 <NEWLINE> cases = int ( input ( ) ) <NEWLINE> for roll in range ( cases ) : <NEWLINE> <INDENT> d1 , d2 = map ( int , input ( ) . split ( ) ) <NEWLINE> if d1 == d2 : <NEWLINE> <INDENT> doubletCount += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> doubletCount = 0 <NEWLINE> <NL> <DEDENT> if doubletCount >= 3 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <NL> <DEDENT> if roll == cases - 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
N = input ( ) <NEWLINE> n = int ( N ) <NEWLINE> for s in range ( n ) : <NEWLINE> <INDENT> ds1 , ds2 = input ( ) . split ( ) <NEWLINE> <DEDENT> if ds1 == ds2 and d ( s + 1 ) 1 == d ( s + 1 ) 2 and d ( s + 2 ) 1 == d ( s + 2 ) 2 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> l = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ] <NEWLINE> f = [ ] <NEWLINE> for x in l : <NEWLINE> <INDENT> f . append ( x [ 0 ] == x [ 1 ] ) <NEWLINE> <DEDENT> l = f . copy ( ) <NEWLINE> i = 0 <NEWLINE> while i < n : <NEWLINE> <INDENT> j = 0 <NEWLINE> while i + j < n and l [ i + j ] == l [ i ] and l [ i ] : <NEWLINE> <INDENT> j += 1 <NEWLINE> <DEDENT> if j > 2 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> i += j <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> t = [ ] <NEWLINE> i = 0 <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> if x == y : <NEWLINE> <INDENT> i += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> i = 0 <NEWLINE> <DEDENT> t . append ( i ) <NEWLINE> <DEDENT> if ( len ( filter ( lambda x : x >= 3 , t ) ) == 0 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> l = [ ] <NEWLINE> t = 1 <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> x = list ( map ( int , input ( ) . split ( ) ) <NEWLINE> l . append ( x ) <NEWLINE> <DEDENT> count = 0 <NEWLINE> for i , j in l : <NEWLINE> <INDENT> if i == j : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> if i != j : <NEWLINE> <INDENT> count = 0 <NEWLINE> <DEDENT> if count == 3 : <NEWLINE> <INDENT> t = 0 <NEWLINE> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if t : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
cnt = 0 <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if a == b : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> <NL> <DEDENT> if cnt == 3 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
def judge ( ) : <NEWLINE> <INDENT> count = 0 <NEWLINE> flag = True <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> d1 , d2 = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> if d1 == d2 : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> count = 0 <NEWLINE> <NL> <NL> <DEDENT> if count == 3 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> flag = True <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> flag = False <NEWLINE> pass <NEWLINE> <DEDENT> <DEDENT> return flag <NEWLINE> <NL> <DEDENT> if judge ( ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
i = int ( input ( ) ) <NEWLINE> count = 0 <NEWLINE> for i in range ( i ) : <NEWLINE> <INDENT> a , b = input ( ) . split ( <STRING> ) <NEWLINE> if a == b : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> if count >= 3 else <STRING> <NEWLINE>
N = int ( input ( ) ) <NEWLINE> xy = [ map ( int , input ( ) . split ( ) ) for i in range ( N ) ] <NEWLINE> x , y = [ list ( j ) for j in zip ( * xy ) ] <NEWLINE> <NL> s = 0 <NEWLINE> while s < 3 : <NEWLINE> <INDENT> for k in range ( N ) : <NEWLINE> <INDENT> if x [ k ] == y [ k ] : <NEWLINE> <INDENT> s = s + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if s >= 3 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> l = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a , b = list ( map ( int , list ( input ( ) . split ( ) ) ) ) <NEWLINE> l . append ( [ a , b ] ) <NEWLINE> <DEDENT> def fn ( n , l ) : <NEWLINE> <INDENT> for i in range ( n - 2 ) : <NEWLINE> <INDENT> if l [ i ] [ 0 ] == l [ i ] [ 1 ] and l [ i + 1 ] [ 0 ] == l [ i + 1 ] [ 1 ] andl [ i + 2 ] [ 0 ] == l [ i + 2 ] [ 1 ] : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> <DEDENT> return <STRING> <NEWLINE> <DEDENT> print ( fn ( n , l ) ) <NEWLINE>
def judge ( ) : <NEWLINE> <INDENT> count = 0 <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> d1 , d2 = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> if d1 == d2 : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> count = 0 <NEWLINE> <NL> <DEDENT> if count == 3 : <NEWLINE> <INDENT> return True <NEWLINE> <NL> <DEDENT> <DEDENT> return False <NEWLINE> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> <NL> if judge ( ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
<NL> Copy <NEWLINE> Copy <NEWLINE> N = int ( input ( ) ) <NEWLINE> lst = [ ] <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> d1 , d2 = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> lst . append ( ( d1 , d2 ) ) <NEWLINE> <NL> <DEDENT> idx = 0 <NEWLINE> while idx < N - 3 : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> for _ in range ( 3 ) : <NEWLINE> <INDENT> d1 , d2 = lst [ idx ] <NEWLINE> if d1 == d2 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if cnt == 3 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> idx += 1 <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> N = A [ 0 ] <NEWLINE> D = A [ 1 : N * 2 + 1 ] <NEWLINE> D1 = [ ] <NEWLINE> D2 = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> D1 . append ( D [ 2 * i ] ) <NEWLINE> D2 . append ( D [ 2 * i + 1 ] ) <NEWLINE> <DEDENT> ans = <STRING> <NEWLINE> for i in range ( N - 2 ) : <NEWLINE> <INDENT> if D1 [ i ] == D [ i ] : <NEWLINE> <INDENT> if D [ i + 1 ] == D [ i + 1 ] : <NEWLINE> <INDENT> if D [ i + 2 ] == D [ i + 2 ] : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> a = [ input ( ) . split ( ) for i in range ( N ) ] <NEWLINE> <NL> n = int ( a [ 0 ] ) <NEWLINE> Is = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> Ds = list ( map ( int , a [ i ] . split ( ) ) ) <NEWLINE> if Ds [ 0 ] == Ds [ 1 ] : <NEWLINE> <INDENT> Is . append ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> Boooo = False <NEWLINE> for i in range ( len ( Is ) - 2 ) : <NEWLINE> <INDENT> if Is [ i ] == Is [ i + 1 ] and Is [ i + 1 ] == Is [ i + 2 ] : <NEWLINE> <INDENT> Boooo = True <NEWLINE> <NL> <DEDENT> <DEDENT> if Boooo : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT>
N = int ( input ( ) ) <NEWLINE> count = 0 <NEWLINE> c = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> d1 , d2 = input ( ) . split ( ) <NEWLINE> if d1 == d2 : <NEWLINE> <INDENT> count += 1 <NEWLINE> if count == 3 : <NEWLINE> <INDENT> c = 1 <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> count = 0 <NEWLINE> <DEDENT> <DEDENT> if count == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> count = 0 <NEWLINE> ren = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if a == b : <NEWLINE> <INDENT> if count < 3 : <NEWLINE> <INDENT> count += 1 <NEWLINE> ren = 1 <NEWLINE> <DEDENT> <DEDENT> else if count < 3 : <NEWLINE> <INDENT> count = 0 <NEWLINE> <DEDENT> <DEDENT> if count >= 3 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> x = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( N ) ] <NEWLINE> count = 0 <NEWLINE> for i in range ( N - 2 ) : <NEWLINE> <INDENT> if x [ i ] [ 0 ] == x [ i ] [ 1 ] and x [ i + 1 ] [ 0 ] == x [ i + 1 ] [ 1 ] and x [ i + 2 ] [ 0 ] == x [ i + 2 ] [ 1 ] : <NEWLINE> <INDENT> count = count + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> count = count <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if count > 0 : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> <COMMENT> <NL> <NL> cnt = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if a == b : <NEWLINE> <INDENT> cnt = cnt + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> <NL> <DEDENT> if cnt == 3 : <NEWLINE> <INDENT> exit ( <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> xy = [ map ( int , input ( ) . split ( ) ) for _ in range ( n ) ] <NEWLINE> x , y = [ list ( i ) for i in zip ( * xy ) ] <NEWLINE> count = 0 <NEWLINE> total = 0 <NEWLINE> <NL> for _ in range ( n ) : <NEWLINE> <INDENT> total += 1 <NEWLINE> if x [ n ] == y [ n ] : <NEWLINE> <INDENT> count += 1 <NEWLINE> if count == 3 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> count = 0 <NEWLINE> <DEDENT> if total == n and count < 3 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> xy = [ map ( int , input ( ) . split ( ) ) for _ in range ( n ) ] <NEWLINE> x , y = [ list ( i ) for i in zip ( * xy ) ] <NEWLINE> a = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if x [ i ] == y [ i ] : <NEWLINE> <INDENT> a += 1 <NEWLINE> if a == 3 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> a = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> if a >= 3 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
input = stdin . readline <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> <NL> b = False <NEWLINE> cnt = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> D1 , D2 = map ( int , input ( ) . split ( ) ) <NEWLINE> if D1 == D2 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> if cnt == 3 : <NEWLINE> <INDENT> b = True <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> if b == False : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
rolls = int ( input ( ) ) <NEWLINE> dices = [ ] <NEWLINE> for _ in range ( rolls ) : <NEWLINE> <INDENT> dices . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> <DEDENT> doubles = [ d1 == d2 for d1 , d2 in dices ] <NEWLINE> <NL> for i in range ( 1 , rolls ) : <NEWLINE> <INDENT> doubles [ i ] *= ( doubles [ i ] + doubles [ i - 1 ] ) <NEWLINE> if double [ i ] == 3 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> <NL> <NL>
num = input ( ) <NEWLINE> d = [ ] <NEWLINE> for n in range ( num ) : <NEWLINE> <INDENT> t , s = input ( ) . split ( ) <NEWLINE> d . append ( [ t , s ] ) <NEWLINE> <DEDENT> flag = 0 <NEWLINE> for n in range ( num ) : <NEWLINE> <INDENT> if ( n < num - 2 ) : <NEWLINE> <INDENT> if ( d [ n ] [ 0 ] == d [ n ] [ 1 ] and d [ n + 1 ] [ 0 ] == d [ n + 1 ] [ 1 ] and d [ n + 2 ] [ 0 ] == d [ n + 2 ] [ 1 ] ) : <NEWLINE> <INDENT> flag = 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if flag == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
num = int ( input ( ) ) <NEWLINE> <NL> count = 0 <NEWLINE> flag = False <NEWLINE> for i in range ( num ) : <NEWLINE> <INDENT> a , b = read ( ) . split ( ) <NEWLINE> if a == b : <NEWLINE> <INDENT> count += 1 <NEWLINE> if count >= 3 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> flag = True <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> count = 0 <NEWLINE> <DEDENT> <DEDENT> if flag : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
def func ( D ) : <NEWLINE> <INDENT> comb = 0 <NEWLINE> for item in D : <NEWLINE> <INDENT> if item [ 0 ] == item [ 1 ] : <NEWLINE> <INDENT> comb += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> comb = 0 <NEWLINE> <NL> <DEDENT> if comb == 3 : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> <DEDENT> return <STRING> <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> D = [ map ( int , input ( ) . split ( ) ) for _ in range ( N ) ] <NEWLINE> print ( func ( D ) ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> N = int ( input ( ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> flag1 = False <NEWLINE> flag2 = False <NEWLINE> flag3 = False <NEWLINE> c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> if c == d : <NEWLINE> <INDENT> flag1 = True <NEWLINE> <DEDENT> c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> if c == d : <NEWLINE> <INDENT> flag2 = True <NEWLINE> <DEDENT> c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> if c == d : <NEWLINE> <INDENT> flag3 = True <NEWLINE> <NL> <DEDENT> k = 3 <NEWLINE> while k < N : <NEWLINE> <INDENT> if flag1 and flag2 and flag3 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> k += 1 <NEWLINE> c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> flag1 = flag2 <NEWLINE> flag2 = flag3 <NEWLINE> if c == d : <NEWLINE> <INDENT> flag3 = True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> flag3 = False <NEWLINE> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> if flag1 and flag2 and flag3 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <COMMENT> <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> N = int ( input ( ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> flag1 = False <NEWLINE> flag2 = False <NEWLINE> flag3 = False <NEWLINE> c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> if c == d : <NEWLINE> <INDENT> flag1 = True <NEWLINE> <DEDENT> c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> if c == d : <NEWLINE> <INDENT> flag2 = True <NEWLINE> <DEDENT> c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> if c == d : <NEWLINE> <INDENT> flag3 = True <NEWLINE> <NL> <DEDENT> k = 3 <NEWLINE> while k < N : <NEWLINE> <INDENT> if flag1 and flag2 and flag3 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> k += 1 <NEWLINE> c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> flag1 = flag2 <NEWLINE> flag2 = flag3 <NEWLINE> if c == d : <NEWLINE> <INDENT> flag3 = True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> flag3 = False <NEWLINE> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> if flag1 and flag2 and flag3 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> Di1 = [ ] <NEWLINE> Di2 = [ ] <NEWLINE> nmDi = 0 <NEWLINE> if N >= 3 and N <= 100 : <NEWLINE> <INDENT> for x in range ( N ) : <NEWLINE> <INDENT> Di1 . append ( int ( input ( ) ) ) <NEWLINE> Di2 . append ( int ( input ( ) ) ) <NEWLINE> <DEDENT> for x in range ( N ) : <NEWLINE> <INDENT> if Di1 [ x ] == Di2 [ x ] : <NEWLINE> <INDENT> nmDi += 1 <NEWLINE> if nmDi == 3 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> elif Di1 [ x ] != Di2 [ x ] and nmDi > 0 : <NEWLINE> <INDENT> nmDi = 0 <NEWLINE> <DEDENT> <DEDENT> if nmDi >= 3 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
print ( <STRING> [ [ * <STRING> ] in [ eval ( eval ( t . replace ( * <STRING> ) ) ) for t in open ( 0 ) ] : : 2 ] ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> total = 0 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> a , b = map ( int , split ( ) . input ( ) ) <NEWLINE> if a == b : <NEWLINE> <INDENT> total += 1 <NEWLINE> if total == 3 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> total = 0 <NEWLINE> <DEDENT> <DEDENT> if total == 3 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> cnt = 0 <NEWLINE> ans = False <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> a , b = input ( ) . split ( ) <NEWLINE> print ( a , b ) <NEWLINE> if a == b : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> <DEDENT> if cnt == 3 : <NEWLINE> <INDENT> ans True <NEWLINE> break <NEWLINE> <DEDENT> print ( cnt ) <NEWLINE> <DEDENT> print ( <STRING> if ans else <STRING> ) <NEWLINE> <NL>
n = int ( input ( ) ) <NEWLINE> li = [ 0 ] * n <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a , b = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> li . append ( [ a , b ] ) <NEWLINE> <DEDENT> count = 0 <NEWLINE> for i in li : <NEWLINE> <INDENT> if i [ 0 ] == i [ 1 ] : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> count = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> if count == 0 : print ( <STRING> ) <NEWLINE> else : print ( <STRING> ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> x , y = [ ] , [ ] <NEWLINE> for i in range ( n ) <NEWLINE> <INDENT> x_ , y_ = map ( int , input ( ) . split ( ) ) <NEWLINE> x . append ( x_ ) <NEWLINE> y . append ( y_ ) <NEWLINE> <DEDENT> for i in range ( n - 2 ) <NEWLINE> <INDENT> if x [ i ] == y [ i ] and x [ i + 1 ] == y [ i + 1 ] and x [ i + 2 ] == y [ i + 2 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
dice_num_list = [ ] <NEWLINE> equal_index_list = [ ] <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> <NL> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> d1 , d2 = input ( ) . split ( <STRING> ) <NEWLINE> dice_num_list . append ( [ d1 , d2 ] ) <NEWLINE> <NL> <DEDENT> equal_index_list = [ i for i , x in enumerate ( dice_num_list ) if x [ 0 ] == x [ 1 ] ] <NEWLINE> <NL> if len ( equal_index_list ) < 3 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( 0 ) <NEWLINE> <DEDENT> for index in equal_index_list : <NEWLINE> <INDENT> if equal_index_list [ index + 1 ] == index + 1 and equal_index_list [ index + 2 ] == index + 2 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( 0 ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> count = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> di_1 , di_2 = int ( input ( ) . split ( ) ) <NEWLINE> if di_1 == di_2 : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> count = 0 <NEWLINE> <DEDENT> <DEDENT> if count >= 3 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> <NL> nums = [ ] <NEWLINE> for a in range ( N ) : <NEWLINE> <INDENT> ci = [ ] <NEWLINE> ci . append ( int ( input ( ) ) ) <NEWLINE> ci . append ( int ( input ( ) ) ) <NEWLINE> nums . append ( ci ) <NEWLINE> <NL> <DEDENT> zoro = maximum = 0 <NEWLINE> for a in range ( N ) : <NEWLINE> <INDENT> if nums [ a ] [ 0 ] == nums [ a ] [ 1 ] : <NEWLINE> <INDENT> zoro += 1 <NEWLINE> maximum = max ( maximum , zoro ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> zoro = 0 <NEWLINE> <DEDENT> <DEDENT>
count = 0 <NEWLINE> n = int ( input ( ) ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if a == b : <NEWLINE> <INDENT> count += 1 <NEWLINE> if count >= 3 : <NEWLINE> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> count = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
a = int ( input ( ) ) <NEWLINE> b = 0 <NEWLINE> xy = [ map ( int , input ( ) . split ( ) ) for _ in range ( a ) ] <NEWLINE> x , y = [ list ( i ) for i in zip ( * xy ) ] <NEWLINE> for i in range ( a - 2 ) : <NEWLINE> <INDENT> if x [ i ] == y [ i ] and x = [ i + 1 ] == y [ i + 1 ] and x = [ i + 2 ] == y [ i + 2 ] : <NEWLINE> <INDENT> b = b + 1 <NEWLINE> <DEDENT> <DEDENT> if b == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> d = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <NL> <DEDENT> answer = <STRING> <NEWLINE> <NL> count = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if d [ i ] [ 0 ] != d [ i ] [ 1 ] : <NEWLINE> <INDENT> count = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> count += 1 <NEWLINE> <NL> <DEDENT> if count == 3 : <NEWLINE> <INDENT> answer = <STRING> <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( answer ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> count = 0 <NEWLINE> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if a == b : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> count = 0 <NEWLINE> <DEDENT> if count >= 3 : <NEWLINE> <INDENT> ans = 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if ans = 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> count = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> d1 , d2 = map ( int , input ( ) ) <NEWLINE> if count == 3 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> elif d1 == d2 : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> count == 0 <NEWLINE> <DEDENT> <DEDENT> if count == 3 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> a . append ( [ x , y ] ) <NEWLINE> <DEDENT> f = 0 ; <NEWLINE> for i in range ( n - 2 ) : <NEWLINE> <INDENT> if ( a [ i ] [ 0 ] = a [ i ] [ 1 ] and a [ i + 1 ] [ 0 ] = a [ i + 1 ] [ 1 ] and a [ i + 2 ] [ 0 ] = a [ i + 2 ] [ 1 ] ) : <NEWLINE> <INDENT> f = 1 <NEWLINE> <DEDENT> <DEDENT> if f : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> ans = <STRING> <NEWLINE> j = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> d , dd = map ( str , input ( ) . split ( ) ) <NEWLINE> if ( d == dd ) : <NEWLINE> <INDENT> if ( j > 0 ) : <NEWLINE> <INDENT> j += 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> j = 0 <NEWLINE> <DEDENT> if ( j = > 3 ) : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
S = [ ] <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> S . append ( input ( ) . split ( ) ) <NEWLINE> <DEDENT> G = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if S [ i ] [ 0 ] == S [ i ] [ 1 ] : <NEWLINE> <INDENT> G . append ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> G . append ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> AN = ( <STRING> . join ( G ) ) <NEWLINE> <NL> if <STRING> in AN : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
nn = int ( input ( ) ) <NEWLINE> x = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> d1 , d2 = map ( int , input ( ) . split ( ) ) <NEWLINE> if x != 3 : <NEWLINE> <INDENT> if d1 != d2 : <NEWLINE> <INDENT> x = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> if x == 3 else <STRING> ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> cnt = 0 <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) split ( ) ) <NEWLINE> if a == b : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> if cnt >= 3 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> <DEDENT> <DEDENT> if cnt >= 3 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = input ( ) <NEWLINE> <NL> result = False <NEWLINE> count = 0 <NEWLINE> <NL> for range ( N ) : <NEWLINE> <INDENT> D1 , D2 = map ( int , input ( ) . split ( ) ) <NEWLINE> if D1 == D2 : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> count = 0 <NEWLINE> <NL> <DEDENT> if count > 2 : <NEWLINE> <INDENT> result = True <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if result : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> count = 0 <NEWLINE> flag = False <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if a == b : <NEWLINE> <INDENT> if count == 2 : <NEWLINE> <INDENT> flag = True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> count = 0 <NEWLINE> <DEDENT> <DEDENT> if flag : <NEWLINE> <INDENT> print ( Yes ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ) <NEWLINE> count = 0 <NEWLINE> ans = <STRING> <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> if a != b : <NEWLINE> <INDENT> count = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> if count == 3 : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> c = 0 <NEWLINE> c1 = 0 <NEWLINE> for x in range ( n ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if a == b : <NEWLINE> <INDENT> c += 1 <NEWLINE> if c == 3 : <NEWLINE> <INDENT> c1 = 1 <NEWLINE> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> c = 0 <NEWLINE> <DEDENT> <DEDENT> if c1 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import os , sys <NEWLINE> c = 0 <NEWLINE> <NL> n = input ( ) <NEWLINE> for i range ( n ) : <NEWLINE> <INDENT> m = input ( ) <NEWLINE> one = m [ 0 ] <NEWLINE> two = m [ 2 ] <NEWLINE> if ( one == two ) : <NEWLINE> <INDENT> c += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if ( c >= 3 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> D = { } <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> D [ i ] = [ input ( ) . split ( ) ] <NEWLINE> <NL> <DEDENT> cou = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if D [ i ] [ 0 ] == D [ i ] [ 1 ] : <NEWLINE> <INDENT> cou += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cou = 0 <NEWLINE> <DEDENT> if cou == 3 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if cou == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> lis = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if lis [ i ] [ 0 ] == lis [ i ] [ 1 ] : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> if ans == 3 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = [ ] <NEWLINE> for i in n : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> a . append ( [ x , y ] ) <NEWLINE> <DEDENT> count = 0 <NEWLINE> flag = True <NEWLINE> for x in a : <NEWLINE> <INDENT> if x [ 0 ] == x [ 1 ] : <NEWLINE> <INDENT> count += 1 <NEWLINE> if count == 3 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> flag = False <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> count = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> if flag : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N == int ( input ( ) ) <NEWLINE> count = 0 <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> s = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if s [ 0 ] == s [ 1 ] : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> if count >= 3 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
<COMMENT> <NL> for _ in range ( int ( input ( ) ) ) : <NEWLINE> <INDENT> n1 , n2 = map ( int , input ( ) . split ( ) ) <NEWLINE> if n1 == n2 : <NEWLINE> <INDENT> c += 1 <NEWLINE> m = max ( m , c ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> m = max ( m , c ) <NEWLINE> c = 0 <NEWLINE> <DEDENT> <DEDENT> if m >= 3 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> <NL> D = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> Da , Db = ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if Da == Db : <NEWLINE> <INDENT> D . append ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> D . append ( 0 ) <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( N - 2 ) : <NEWLINE> <INDENT> if D [ i ] == 1 and D [ i + 1 ] == 1 and D [ i + 2 ] == 1 : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> break : <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> count = 0 <NEWLINE> <NL> for num in range ( n ) : <NEWLINE> <INDENT> d1 , d2 = map ( int , input ( ) . split ( ) ) <NEWLINE> if d1 == d2 : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if count > 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) v <NEWLINE> <DEDENT> <DEDENT>
cnt = 0 <NEWLINE> zorome = 0 <NEWLINE> num = input ( ) <NEWLINE> <NL> while cnt < num : <NEWLINE> <INDENT> mass = input ( ) . split ( ) <NEWLINE> <NL> if ( mass [ 0 ] == mass [ 1 ] ) : <NEWLINE> <INDENT> zorome += 1 <NEWLINE> <NL> if ( zorome >= 3 ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> zorome = 0 <NEWLINE> <NL> <DEDENT> cnt += 1 <NEWLINE> <NL> <DEDENT> print ( <STRING> if zorome >= 3 else <STRING> ) <NEWLINE>
<COMMENT> <NL> n = int ( input ( ) ) <NEWLINE> count = 0 <NEWLINE> mcount = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a , b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if a == b : <NEWLINE> <INDENT> count += 1 <NEWLINE> if mcount < count : <NEWLINE> <INDENT> mcount = count <NEWLINE> if mcount = 3 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> count = 0 <NEWLINE> <DEDENT> <DEDENT> if mcount = 3 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> nums = [ ] <NEWLINE> count = 0 <NEWLINE> switch = False <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> nums . append ( [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> <NL> <DEDENT> for j in nums : <NEWLINE> <INDENT> if j [ 0 ] == j [ 1 ] : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> elif j [ 0 ] != j [ 1 ] : <NEWLINE> <INDENT> count = 0 <NEWLINE> <DEDENT> if count == 3 : <NEWLINE> <INDENT> switch = True <NEWLINE> <DEDENT> <DEDENT> if switch == True : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif switch == False : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> count = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . sprit ( ) ) <NEWLINE> if a == b : <NEWLINE> <INDENT> count += 1 <NEWLINE> if count = 3 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> count = 0 <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> c = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a , b = [ ( int x ) for x in input ( ) . split ( ) ] <NEWLINE> if a == b : <NEWLINE> <INDENT> c += 1 <NEWLINE> <DEDENT> <DEDENT> if c >= 3 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import math <NEWLINE> <NL> from fractions import Fraction as frac <NEWLINE> <NL> MOD = 1e9 + 7 <NEWLINE> <NL> def gcd ( a , b ) : <NEWLINE> <NL> <INDENT> if b == 0 : <NEWLINE> <NL> <INDENT> return a <NEWLINE> <NL> <DEDENT> return gcd ( b , a % b ) <NEWLINE> <NL> <DEDENT> def lcm ( a , b ) : <NEWLINE> <NL> <INDENT> return a * b // gcd ( a , b ) <NEWLINE> <NL> <DEDENT> def solve ( case_no ) : <NEWLINE> <NL> <INDENT> n = int ( input ( ) ) <NEWLINE> <NL> cnt = 0 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <NL> <INDENT> a , b = map ( int , input ( ) . split ( ) ) if a == b : <NEWLINE> <NL> <INDENT> cnt += 1 <NEWLINE> <NL> if cnt == 3 : <NEWLINE> <NL> print ( <STRING> ) <NEWLINE> <NL> exit ( ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <NL> <INDENT> cnt = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> t = 1 <NEWLINE> <NL> <COMMENT> <NL> <NL> for i in range ( 1 , t + 1 ) : <NEWLINE> <NL> <INDENT> solve ( i ) <NEWLINE> <DEDENT>
def judge ( ) : <NEWLINE> <INDENT> count = 0 <NEWLINE> flag = True <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> d1 , d2 = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> if d1 == d2 : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> count = 0 <NEWLINE> <NL> <NL> <DEDENT> if count == 3 : <NEWLINE> <INDENT> flag = True <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> flag = False <NEWLINE> pass <NEWLINE> <DEDENT> <DEDENT> return flag <NEWLINE> <NL> <DEDENT> if judge ( ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> count = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> p , q = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> if count < 3 : <NEWLINE> if p == q : <NEWLINE> <INDENT> count += 1 <NEWLINE> else : <NEWLINE> count = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> <DEDENT> if count >= 3 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = str ( input ( ) ) <NEWLINE> <NL> count = 0 <NEWLINE> yes = False <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if a == b : <NEWLINE> <INDENT> count += 1 <NEWLINE> if count >= 3 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> yes = True <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> count = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> if not ( yes ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = input ( ) <NEWLINE> temp = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> d , w = map ( int , input ( ) . split ( ) ) <NEWLINE> if d == w : <NEWLINE> <INDENT> temp += 1 <NEWLINE> if temp == 3 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> temp = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> <NL>
n = input ( ) <NEWLINE> <NL> c = 0 <NEWLINE> flag = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a , b = map ( int ( ) , input ( ) . split ( ) ) <NEWLINE> if ( a == b ) : <NEWLINE> <INDENT> c += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> c = 0 <NEWLINE> <DEDENT> if ( c == 3 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> flag = 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if ( flag == 0 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
<INDENT> def solution ( arr ) : <NEWLINE> <INDENT> count = 0 <NEWLINE> for i , val in enumerate ( arr ) : <NEWLINE> <INDENT> if i > 0 and arr [ i - 1 ] == val : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> count = 0 <NEWLINE> <DEDENT> if count == 2 : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> <DEDENT> return <STRING> <NEWLINE> <DEDENT> n = int ( input ( ) ) <NEWLINE> arr = [ ] <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> arr . append ( input ( ) ) <NEWLINE> <DEDENT> print ( solution ( arr ) ) <NEWLINE> <DEDENT>
case_num = 0 <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> <NL> for num in range ( N - 1 ) : <NEWLINE> <INDENT> num += 1 <NEWLINE> <NL> case_num += ( math . ceil ( N / num ) - 1 ) <NEWLINE> <NL> <NL> <DEDENT> print ( case_num ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> def factorization ( n ) : <NEWLINE> <INDENT> arr = [ ] <NEWLINE> temp = n <NEWLINE> for i in range ( 2 , int ( - ( - n ** 0.5 // 1 ) ) + 1 ) : <NEWLINE> <INDENT> if temp % i == 0 : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> while temp % i == 0 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> temp //= i <NEWLINE> <DEDENT> arr . append ( [ i , cnt ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> if temp != 1 : <NEWLINE> <INDENT> arr . append ( [ temp , 1 ] ) <NEWLINE> <NL> <DEDENT> if arr == [ ] : <NEWLINE> <INDENT> arr . append ( [ n , 1 ] ) <NEWLINE> <NL> <DEDENT> return arr <NEWLINE> <DEDENT> ans = 1 <NEWLINE> for i in range ( 2 , N ) : <NEWLINE> <INDENT> a = factorization ( n ) <NEWLINE> b = 1 <NEWLINE> for j in range ( len ( a ) ) : <NEWLINE> <INDENT> x = a [ j ] [ 1 ] <NEWLINE> b *= ( x + 1 ) <NEWLINE> <DEDENT> ans += b <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> import collections <NEWLINE> import bisect <NEWLINE> from collections import deque <NEWLINE> from copy import copy , deepcopy <NEWLINE> import time <NEWLINE> <NL> import numpy as np <NEWLINE> import numba <NEWLINE> from numba import njit , b1 , i4 , i8 , f8 <NEWLINE> from numba import jit <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> count = 0 <NEWLINE> ans = False <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if a == b : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> count = 0 <NEWLINE> <DEDENT> if count >= 3 : <NEWLINE> <INDENT> ans = True <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> if ans else <STRING> ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
<INDENT> = int ( input ( ) ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> <NL> for i in range ( 1 , n ) : <NEWLINE> <INDENT> s = ( n - 1 ) // i <NEWLINE> if 0 < s < n : <NEWLINE> <INDENT> ans += s <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> ans += ( n - 1 ) // i <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
from numba import jit <NEWLINE> N = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> <NL> @ jit <NEWLINE> def num ( n ) : <NEWLINE> <INDENT> num = 0 <NEWLINE> for i in range ( 1 , int ( n ** 0.5 ) + 1 ) : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> num += 1 <NEWLINE> if n != i ** 2 : <NEWLINE> <INDENT> num += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return num <NEWLINE> <NL> <DEDENT> for n in range ( 1 , N ) : <NEWLINE> <INDENT> ans += num ( n ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> t = 1 <NEWLINE> for tc in range ( t ) : <NEWLINE> <INDENT> N = 1000005 <NEWLINE> div = [ 0 ] * N <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> for j in range ( i , N , i ) : <NEWLINE> <INDENT> div [ j ] += 1 <NEWLINE> <DEDENT> <DEDENT> n = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> ans += div [ n - c ] <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <NL> <NL> <DEDENT>
from sympy import divisor_count <NEWLINE> n = int ( input ) <NEWLINE> count = 0 <NEWLINE> for c in range ( 1 , n ) : <NEWLINE> <INDENT> count += divisor_count ( c ) <NEWLINE> <DEDENT> print ( count ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for a in range ( N ) : <NEWLINE> <INDENT> ans += ( N // a ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> counter = 0 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> for k in range ( 1 , n - i * k ) : <NEWLINE> <INDENT> if ( ( i * j + k ) == n ) : <NEWLINE> <INDENT> counter = counter + 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( counter ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for a in range ( 1 , n - 1 ) : <NEWLINE> <INDENT> for b in range ( 1 , n - a ) : <NEWLINE> <INDENT> if n - a * b <= 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<NL> n = int ( input ( ) ) <NEWLINE> <COMMENT> <NL> <NL> def p ( val ) : <NEWLINE> <INDENT> print ( val ) <NEWLINE> <NL> <DEDENT> count = 0 <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> for i in range ( 1 , n ) : <NEWLINE> <NL> <NL> <NL> <NL> <NL> p ( count ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> NR = int ( N ** 0.5 ) <NEWLINE> count = 0 <NEWLINE> if int ( N / 2 ) - N / 2 == 0 : <NEWLINE> <INDENT> for i in range ( 1 , int ( N / 2 ) ) : <NEWLINE> <INDENT> if int ( N / i ) - N / i == 0 : <NEWLINE> <INDENT> count += int ( N / i ) - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> count += int ( N / i ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( 1 , int ( N / 2 ) + 1 ) : <NEWLINE> <INDENT> if int ( N / i ) - N / i == 0 : <NEWLINE> <INDENT> count += int ( N / i ) - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> count += int ( N / i ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> count += int ( N / 2 ) <NEWLINE> print ( count ) <NEWLINE> N = int ( input ( ) ) <NEWLINE> NR = int ( N ** 0.5 ) <NEWLINE> count = 0 <NEWLINE> if int ( N / 2 ) - N / 2 == 0 : <NEWLINE> <INDENT> for i in range ( 1 , int ( N / 2 ) ) : <NEWLINE> <INDENT> if int ( N / i ) - N / i == 0 : <NEWLINE> <INDENT> count += int ( N / i ) - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> count += int ( N / i ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( 1 , int ( N / 2 ) + 1 ) : <NEWLINE> <INDENT> if int ( N / i ) - N / i == 0 : <NEWLINE> <INDENT> count += int ( N / i ) - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> count += int ( N / i ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> count += int ( N / 2 ) <NEWLINE> print ( count ) <NEWLINE>
from numba import njit <NEWLINE> <NL> @ njit <NEWLINE> def factorize1 ( n ) : <NEWLINE> <INDENT> ans = dict ( ) <NEWLINE> i = 2 <NEWLINE> while i * i <= n : <NEWLINE> <INDENT> while n % i == 0 : <NEWLINE> <INDENT> n = n // i <NEWLINE> if i in ans : <NEWLINE> <INDENT> ans [ i ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans [ i ] = 1 <NEWLINE> <DEDENT> <DEDENT> i += 1 <NEWLINE> <DEDENT> if n != 1 : <NEWLINE> <INDENT> ans [ n ] = 1 <NEWLINE> <NL> <DEDENT> div = 1 <NEWLINE> for j in ans . items ( ) : <NEWLINE> <INDENT> div *= j [ 1 ] + 1 <NEWLINE> <DEDENT> return div <NEWLINE> <NL> <DEDENT> N = int ( input ( ) ) <NEWLINE> ans = 1 <NEWLINE> for k in range ( 2 , N ) : <NEWLINE> <INDENT> ans += factorize1 ( k ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> <NL> count = 0 <NEWLINE> <NL> <INDENT> for i in range ( 1 , int ( N ) ) : <NEWLINE> <INDENT> if int ( N / i ) - N / i == 0 : <NEWLINE> <INDENT> count += int ( N / i ) - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> count += int ( N / i ) <NEWLINE> <NL> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> count = 0 <NEWLINE> for a in range ( 1 , n ) : <NEWLINE> <INDENT> count += int ( ( n - 1 ) / a ) <NEWLINE> <DEDENT> print ( count ) n = int ( input ( ) ) <NEWLINE> count = 0 <NEWLINE> for a in range ( 1 , n ) : <NEWLINE> <INDENT> count += int ( ( n - 1 ) / a ) <NEWLINE> <DEDENT> print ( count ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> c = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> c += N - 1 // i + 1 <NEWLINE> <DEDENT> print ( c ) <NEWLINE> <NL>
<COMMENT> <NL> n = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> <NL> for a in range ( n ) : <NEWLINE> <INDENT> ans += ( n - 1 ) // a <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> g = lambda x : ( x * ( n // x ) * ( n // x + 1 ) ) // 2 <NEWLINE> print ( sum ( g ( i ) for i in range ( 2 , n + 2 ) - sum ( g ( i ) for i in range ( 1 , n + 1 ) ) ) ) <NEWLINE>
N = int ( input ( <STRING> ) ) <NEWLINE> C = 0 <NEWLINE> F = N - C <NEWLINE> <NL> a = 0 <NEWLINE> k = 0 <NEWLINE> v = 0 <NEWLINE> <NL> while C < N - 1 : <NEWLINE> <INDENT> C = C + 1 <NEWLINE> while a <= F : <NEWLINE> <INDENT> a = a + 1 <NEWLINE> v = v + ( F % a ) <NEWLINE> if v == 0 : <NEWLINE> <INDENT> k = k + 1 <NEWLINE> <DEDENT> v = 0 <NEWLINE> a = 0 <NEWLINE> <DEDENT> F = N - C <NEWLINE> <DEDENT> print ( k ) <NEWLINE>
<NL> cnt = 0 <NEWLINE> for a in range ( 1 , n ) : <NEWLINE> <INDENT> cnt += ( n - 1 ) // a <NEWLINE> <DEDENT> print ( cnt ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> ans += ( N - 1 ) // i <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE> N = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> ans += ( N - 1 ) // i <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> print ( ( n - 1 ) + len ( range ( n ** ( 1 / 2 ) ) ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> ans = 1 <NEWLINE> for x in range ( 3 , N + 1 ) : <NEWLINE> <INDENT> tmp = x - 1 <NEWLINE> ans += tmp // x <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> n = int ( input ( ) ) <NEWLINE> k = int ( math . sqrt ( n ) ) if n != k ** 2 else int ( math . sqrt ( n ) ) - 1 <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> t = int ( ( n - 1 ) / i ) <NEWLINE> ans += ( t - i + 1 ) * 2 <NEWLINE> if n != i ** 2 : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> <NL> k = 0 <NEWLINE> <NL> for s in range ( 1 , N ) : <NEWLINE> <INDENT> k = ( N - 1 ) // s <NEWLINE> t += k <NEWLINE> <NL> <DEDENT> print ( t ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> for i in range ( 1 , n ) : <NEWLINE> <INDENT> ans += ( n - 1 ) // i <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> <NL> for i in range ( 1 , n ) : <NEWLINE> <INDENT> ans += ( n - 1 ) // a <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
from numba import jit <NEWLINE> @ jit <NEWLINE> def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for c in range ( 1 , n ) : <NEWLINE> <INDENT> k = int ( ( n - c ) ** ( 1 / 2 ) ) <NEWLINE> for a in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> if ( n - c ) % a == 0 : <NEWLINE> <INDENT> if a ** 2 == n - c : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = ans + 2 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <DEDENT> main ( ) <NEWLINE>
% % time <NEWLINE> n = int ( input ( ) ) <NEWLINE> <NL> <COMMENT> <NL> cnt = 0 <NEWLINE> for a in range ( 1 , n , 1 ) : <NEWLINE> <INDENT> for b in range ( 1 , n , 1 ) : <NEWLINE> <INDENT> if n <= a * b : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if a != b : <NEWLINE> <INDENT> cnt += 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> <NL> for i in range ( 1 , 10 ** 6 ) : <NEWLINE> <INDENT> for j in range ( 1 , ( 10 ** 6 ) // i + 1 ) : <NEWLINE> <INDENT> if N > i * j : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> cnt = 0 <NEWLINE> for a in range ( 1 , n ) : <NEWLINE> <INDENT> cnt += ( n - 1 ) // a <NEWLINE> <DEDENT> print ( cnt ) n = int ( input ( ) ) <NEWLINE> cnt = 0 <NEWLINE> for a in range ( 1 , n ) : <NEWLINE> <INDENT> cnt += ( n - 1 ) // a <NEWLINE> <DEDENT> print ( cnt ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> ans += int ( cnt - 1 ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n = it ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> ans += int ( ( n - 1 ) / i ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> readline = sys . stdin . readline <NEWLINE> <NL> import numpy as np <NEWLINE> from numba import njit , i8 <NEWLINE> <NL> N , K = map ( int , readline ( ) . split ( ) ) <NEWLINE> DIV = 998244353 <NEWLINE> steps = [ ] <NEWLINE> for i in range ( K ) : <NEWLINE> <INDENT> l , r = map ( int , readline ( ) . split ( ) ) <NEWLINE> for j in range ( l , r + 1 ) : <NEWLINE> <INDENT> steps . append ( j ) <NEWLINE> <NL> <DEDENT> <DEDENT> steps = sorted ( steps ) <NEWLINE> steps = np . array ( steps , dtype = int ) <NEWLINE> <NL> @ njit ( i8 ( i8 [ : ] ) , cache = True ) <NEWLINE> def solve ( steps ) : <NEWLINE> <INDENT> dp = np . zeros ( N , dtype = int ) <NEWLINE> dp [ 0 ] = 1 <NEWLINE> for i in range ( len ( dp ) ) : <NEWLINE> <INDENT> for s in steps : <NEWLINE> <INDENT> if i + s >= len ( dp ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> dp [ i + s ] += dp [ i ] <NEWLINE> dp [ i + s ] %= DIV <NEWLINE> <NL> <DEDENT> <DEDENT> return dp [ - 1 ] <NEWLINE> <NL> <DEDENT> print ( solve ( ) ) <NEWLINE>
<COMMENT> <NL> import sys <NEWLINE> import numpy as np <NEWLINE> import numba <NEWLINE> from numba import njit , b1 , i4 , i8 , f8 <NEWLINE> <NL> input = sys . stdin . readline <NEWLINE> mod = 998244353 <NEWLINE> <NL> <NL> def I ( ) : <NEWLINE> <INDENT> return int ( input ( ) ) <NEWLINE> <NL> <NL> <DEDENT> def MI ( ) : <NEWLINE> <INDENT> return map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <NL> <DEDENT> @ njit ( ( i8 , i8 [ : ] ) , cache = True ) <NEWLINE> def main ( N , steps ) : <NEWLINE> <INDENT> dp = np . zeros ( N , np . int64 ) <NEWLINE> dp [ 0 ] = 1 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if steps . size == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if steps [ - 1 ] >= N : <NEWLINE> <INDENT> steps = steps [ : - 1 ] <NEWLINE> <DEDENT> dp [ steps ] += dp [ i ] <NEWLINE> dp [ steps ] %= mod <NEWLINE> steps += 1 <NEWLINE> <NL> <DEDENT> return dp [ N - 1 ] <NEWLINE> <NL> <NL> <DEDENT> N , K = MI ( ) <NEWLINE> <NL> steps = [ ] <NEWLINE> for _ in range ( K ) : <NEWLINE> <INDENT> l , r = MI ( ) <NEWLINE> steps += list ( range ( l , r + 1 ) ) <NEWLINE> <NL> <DEDENT> steps . sort ( ) <NEWLINE> steps = np . array ( steps , np . int64 ) <NEWLINE> <NL> print ( main ( N , steps ) ) <NEWLINE>
import numpy as np <NEWLINE> from numba import njit <NEWLINE> <NL> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> MOD = 998244353 <NEWLINE> <NL> lr = [ ] <NEWLINE> for _ in range ( k ) : <NEWLINE> <INDENT> l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> lr += ( list ( range ( l , r + 1 ) ) ) <NEWLINE> <NL> <DEDENT> lr . sort ( ) <NEWLINE> lr = np . array ( lr ) <NEWLINE> <NL> dp = np . zeros ( n + n , dtype = np . int64 ) <NEWLINE> dp [ 0 ] = 1 <NEWLINE> dp2 = dp . copy ( ) <NEWLINE> <NL> <NL> @ njit ( cache = True ) <NEWLINE> def solve ( n , lr , dp , dp2 ) : <NEWLINE> <INDENT> for i in range ( n ) : <NEWLINE> <INDENT> idx = i + lr <NEWLINE> dp2 [ idx ] += dp [ i ] <NEWLINE> dp2 %= MOD <NEWLINE> dp = dp2 <NEWLINE> <DEDENT> return dp [ n - 1 ] <NEWLINE> <NL> <NL> <DEDENT> print ( solve ( n , lr , dp , dp2 ) ) <NEWLINE>
from numba import jit <NEWLINE> <NL> import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> <NL> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> S = set ( ) <NEWLINE> <NL> MOD = 998244353 <NEWLINE> for _ in range ( K ) : <NEWLINE> <INDENT> L , R = map ( int , input ( ) . split ( ) ) <NEWLINE> S |= set ( range ( L , R + 1 ) ) <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> DP = [ - 1 ] * ( N + 1 ) <NEWLINE> DP [ 0 ] = 0 <NEWLINE> DP [ 1 ] = 1 <NEWLINE> <NL> <NL> @ njit <NEWLINE> def f ( idx ) : <NEWLINE> <INDENT> ans = 0 <NEWLINE> for s in S : <NEWLINE> <INDENT> if idx - s < 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if DP [ idx - s ] == - 1 : <NEWLINE> <INDENT> DP [ idx - s ] = f ( idx - s ) <NEWLINE> <DEDENT> ans += DP [ idx - s ] <NEWLINE> <DEDENT> return ans % MOD <NEWLINE> <NL> <NL> <DEDENT> ans = f ( N ) <NEWLINE> <COMMENT> <NL> print ( ans ) <NEWLINE>
import numpy as np <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> <COMMENT> <NL> from numba import njit , i8 <NEWLINE> <NL> <NL> @ njit ( i8 ( i8 , i8 , i8 [ : , : ] , i8 , i8 [ : ] , i8 , i8 , i8 , i8 ) ) <NEWLINE> def give_cnt ( N , K , LR , mod , dp , L , R , l , r ) : <NEWLINE> <INDENT> for i in range ( N ) : <NEWLINE> <INDENT> for k in range ( K ) : <NEWLINE> <INDENT> l = LR [ k ] [ 0 ] <NEWLINE> r = LR [ k ] [ 1 ] <NEWLINE> if i + l >= N : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> L = i + l <NEWLINE> <DEDENT> if i + r >= N : <NEWLINE> <INDENT> R = N - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> R = i + r <NEWLINE> <DEDENT> dp [ L : R + 1 ] += dp [ i ] <NEWLINE> dp [ L : R + 1 ] %= mod <NEWLINE> <DEDENT> <DEDENT> return dp [ - 1 ] <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> LR = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( K ) ] <NEWLINE> LR = np . array ( LR ) <NEWLINE> <NL> mod = 998244353 <NEWLINE> <NL> dp = [ 0 for i in range ( N ) ] <NEWLINE> dp [ 0 ] = 1 <NEWLINE> dp = np . array ( dp ) <NEWLINE> <NL> res = give_cnt ( N , K , LR , mod , dp , 0 , 0 , 0 , 0 ) <NEWLINE> <NL> <COMMENT> <NL> print ( res ) <NEWLINE> <NL> <NL> <NL> <DEDENT> main ( ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> <COMMENT> <NL> def give_dp ( N , K , mod , LR , dp , l , r ) : <NEWLINE> <INDENT> for i in range ( N ) : <NEWLINE> <INDENT> if i > 0 : <NEWLINE> <INDENT> dp [ i ] += dp [ i - 1 ] <NEWLINE> dp [ i ] %= mod <NEWLINE> <DEDENT> for k in range ( K ) : <NEWLINE> <INDENT> l = LR [ k ] [ 0 ] <NEWLINE> r = LR [ k ] [ 1 ] <NEWLINE> if i + l < N : <NEWLINE> <INDENT> dp [ i + l ] += dp [ i ] <NEWLINE> dp [ i + 1 ] %= mod <NEWLINE> <DEDENT> if i + r < N : <NEWLINE> <INDENT> dp [ i + r + 1 ] -= dp [ i ] <NEWLINE> dp [ i + 1 ] %= mod <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return dp [ - 1 ] <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> LR = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( K ) ] <NEWLINE> <COMMENT> <NL> <NL> mod = 998244353 <NEWLINE> <NL> dp = [ 0 for i in range ( N ) ] <NEWLINE> dp [ 0 ] = 1 <NEWLINE> dp [ 1 ] = - 1 <NEWLINE> <COMMENT> <NL> <NL> res = give_dp ( N , K , mod , LR , dp , 0 , 0 ) <NEWLINE> res %= mod <NEWLINE> <NL> print ( res ) <NEWLINE> <NL> <NL> <NL> <DEDENT> main ( ) <NEWLINE>
import numpy as np <NEWLINE> <NL> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> D = [ ] <NEWLINE> <NL> for _ in range ( K ) : <NEWLINE> <INDENT> L , R = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> for i in range ( L , R + 1 ) : <NEWLINE> <INDENT> D . append ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> D . sort ( ) <NEWLINE> <NL> dp = np . zeros ( 300000 ) <NEWLINE> dp [ 1 ] = 1 <NEWLINE> <NL> for d in D : <NEWLINE> <INDENT> for i in range ( 1 , N // d ) <NEWLINE> <INDENT> dp += np . roll ( dp , i * d ) <NEWLINE> <DEDENT> dp %= 998244353 <NEWLINE> <NL> <DEDENT> print ( int ( dp [ N ] ) ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> lr = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( k ) ] <NEWLINE> <NL> mod = 998244353 <NEWLINE> <NL> dp = [ 0 ] * ( n + 1 ) <NEWLINE> sdp = [ 0 ] * ( n + 1 ) <NEWLINE> dp [ 1 ] = 1 <NEWLINE> sdp [ 1 ] = 1 <NEWLINE> <NL> for i in range ( n + 1 ) : <NEWLINE> <INDENT> for j in range ( k ) : <NEWLINE> <INDENT> left = max ( 0 , i - lr [ j ] [ 1 ] ) <NEWLINE> right = max ( 0 , i - lr [ j ] [ 0 ] + 1 ) <NEWLINE> <NL> dp [ i ] += sdp [ right ] - sdp [ left ] <NEWLINE> <DEDENT> if i + 1 <= n : <NEWLINE> <INDENT> sdp [ i + 1 ] = sdp [ i ] % mod + dp [ i ] % mod <NEWLINE> <NL> <DEDENT> <DEDENT> print ( dp % mod ) <NEWLINE>
import numpy as np <COMMENT> <NEWLINE> import numba <NEWLINE> from numba import njit , b1 , i4 , i8 , f8 <NEWLINE> <NL> m = 998244353 <NEWLINE> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> jumps = [ ] <NEWLINE> for i in range ( K ) : <NEWLINE> <INDENT> l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> jumps . append ( [ l , r ] ) <NEWLINE> <NL> <DEDENT> jumps = np . array ( jumps ) <NEWLINE> <NL> <NL> @ njit ( ( i8 , i8 , i8 [ : , : ] ) , cache = True ) <NEWLINE> def main ( N , m , jumps ) : <NEWLINE> <INDENT> dpsum = np . zeros ( N + 1 ) <NEWLINE> dp = np . zeros ( N + 1 ) <NEWLINE> dp [ 1 ] = dpsum [ 1 ] = 1 <NEWLINE> <NL> for i in range ( 2 , N + 1 ) : <NEWLINE> <INDENT> for j , jump in enumerate ( jumps ) : <NEWLINE> <INDENT> mn = max ( 0 , i - jump [ 1 ] ) <NEWLINE> mx = max ( mn , i - jump [ 0 ] ) <NEWLINE> dp [ i ] = ( dp [ i ] + dpsum [ mx ] - dpsum [ mn - 1 ] ) % m <NEWLINE> <DEDENT> dpsum [ i ] = ( dp [ i ] + dpsum [ i - 1 ] ) % m <NEWLINE> <DEDENT> return dp [ N ] <NEWLINE> <NL> <NL> <DEDENT> print ( int ( main ( N , m , jumps ) ) ) <NEWLINE>
N , X , M = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ X , ] <NEWLINE> setA = { A , } <NEWLINE> alast = X <NEWLINE> flag = False <NEWLINE> for i in range ( min ( N - 1 , M ) ) : <NEWLINE> <INDENT> P = alast ** 2 % M <NEWLINE> if P in setA : <NEWLINE> <INDENT> flag = True <NEWLINE> d = A . index ( P ) <NEWLINE> C = A [ d : ] <NEWLINE> alast = P <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> A . append ( P ) <NEWLINE> setA . add ( P ) <NEWLINE> alast = P <NEWLINE> <DEDENT> <DEDENT> if alast == 0 : <NEWLINE> <INDENT> print ( sum ( C ) ) <NEWLINE> <DEDENT> elif ( flag == False ) and ( alast != 0 ) : <NEWLINE> <INDENT> print ( sum ( A ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> suma = sum ( C ) <NEWLINE> res = ( N - d ) % len ( C ) <NEWLINE> print ( sum ( A [ : d ] ) + ( ( N - d ) // len ( C ) ) * suma + sum ( C [ : res ] ) ) <NEWLINE> <DEDENT>
N , X , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> chck = 0 <NEWLINE> flag = [ 0 ] * ( 10 ** 5 + 1 ) <NEWLINE> lst = [ X ] <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> X = ( X ** 2 ) % M <NEWLINE> <NL> if flag [ X ] == 1 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> flag [ X ] = 1 <NEWLINE> lst . append ( X ) <NEWLINE> <NL> <DEDENT> preindex = lst . index ( X ) <NEWLINE> <NL> preloop = lst [ : index ] <NEWLINE> loop = lst [ index : ] <NEWLINE> <NL> loopnum = ( N - len ( preloop ) ) // len ( loop ) <NEWLINE> loopafternum = ( N - len ( preloop ) ) % len ( loop ) <NEWLINE> <NL> ans = sum ( preloop ) + sum ( loop ) * loopnum + sum ( loop [ : loopafternum ] ) <NEWLINE> print ( ans ) <NEWLINE>
n , x , m = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = x <NEWLINE> num = 0 <NEWLINE> l = [ 0 ] * n <NEWLINE> lis = [ - 1 ] * n <NEWLINE> l [ 0 ] = x <NEWLINE> lis [ x ] = num <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> x = ( x * x ) % m <NEWLINE> num += 1 <NEWLINE> if lis [ x ] != - 1 : <NEWLINE> <INDENT> a = ( n - i ) // ( i - lis [ x ] ) <NEWLINE> b = ( n - i ) % ( i - lis [ x ] ) <NEWLINE> ans += a * sum ( l [ lis [ x ] : i ] ) <NEWLINE> break <NEWLINE> <DEDENT> l [ i ] = x <NEWLINE> lis [ x ] = i <NEWLINE> ans += x <NEWLINE> <DEDENT> for i in range ( lis [ x ] , lis [ x ] + b ) : <NEWLINE> <INDENT> ans += l [ i ] <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> <NL> def L ( ) : return sys . stdin . readline ( ) . split ( ) <NEWLINE> def I ( ) : return int ( sys . stdin . readline ( ) . rstrip ( ) ) <NEWLINE> def SL ( ) : return list ( sys . stdin . readline ( ) . rstrip ( ) ) <NEWLINE> def LI ( ) : return [ int ( x ) for x in sys . stdin . readline ( ) . split ( ) ] <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> N , X , M = LI ( ) <NEWLINE> p = [ 0 ] * ( M + 10 ) <NEWLINE> p [ 1 ] = X <NEWLINE> for i in range ( 2 , M + 10 ) : <NEWLINE> <INDENT> p [ i ] = pow ( X , pow ( 2 , i - 1 , M - 1 ) , M ) <NEWLINE> <DEDENT> s = 0 <NEWLINE> for v in p : <NEWLINE> <INDENT> s = ( s + v ) % M <NEWLINE> <NL> <DEDENT> tmp = 0 <NEWLINE> for i in range ( N % M ) : <NEWLINE> <INDENT> tmp = ( tmp + p [ i ] ) % M <NEWLINE> <NL> <DEDENT> print ( ( N // M * s % M + tmp ) % M ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> <COMMENT> <NL> from numba import njit , i8 <NEWLINE> <NL> <NL> @ njit ( i8 [ : ] ( i8 , i8 [ : ] , i8 [ : ] , i8 , i8 , i8 ) ) <NEWLINE> def SerchLoop ( M , A , cnt , start , end , temp ) : <NEWLINE> <INDENT> for i in range ( 1 , M * 2 ) : <NEWLINE> <INDENT> temp = A [ i - 1 ] ** 2 <NEWLINE> temp %= M <NEWLINE> if cnt [ temp ] != 0 : <NEWLINE> <INDENT> start = cnt [ temp ] <NEWLINE> end = i - 1 <NEWLINE> break <NEWLINE> <DEDENT> A [ i ] = temp <NEWLINE> cnt [ temp ] = i <NEWLINE> <DEDENT> return np . append ( np . append ( A , start ) , end ) <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> N , X , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> A = [ - 1 for i in range ( M * 2 ) ] <NEWLINE> A [ 0 ] = X <NEWLINE> A = np . array ( A ) <NEWLINE> <NL> start = - 1 <NEWLINE> end = - 1 <NEWLINE> <NL> cnt = [ 0 for i in range ( M ) ] <NEWLINE> cnt [ X ] = 0 <NEWLINE> cnt = np . array ( cnt ) <NEWLINE> <NL> C = SerchLoop ( M , A , cnt , start , end , 0 ) <NEWLINE> A = C [ : - 2 ] <NEWLINE> start = C [ - 2 ] <NEWLINE> end = C [ - 1 ] <NEWLINE> <NL> L = end - start + 1 <NEWLINE> <NL> if start == - 1 : <NEWLINE> <INDENT> straight = [ 0 for i in range ( N ) ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> straight [ i ] = straight [ i - 1 ] + A [ i ] <NEWLINE> <DEDENT> res = straight [ - 1 ] <NEWLINE> <DEDENT> elif start == 0 : <NEWLINE> <INDENT> loop = [ 0 for i in range ( L ) ] <NEWLINE> for i in range ( L ) : <NEWLINE> <INDENT> loop [ i ] = loop [ i - 1 ] + A [ start + i ] <NEWLINE> <DEDENT> res = ( N // L ) * loop [ - 1 ] <NEWLINE> if N % L != 0 : <NEWLINE> <INDENT> res += loop [ N % L - 1 ] <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> straight = [ 0 for i in range ( start ) ] <NEWLINE> for i in range ( start ) : <NEWLINE> <INDENT> straight [ i ] = straight [ i - 1 ] + A [ i ] <NEWLINE> <DEDENT> loop = [ 0 for i in range ( L ) ] <NEWLINE> for i in range ( L ) : <NEWLINE> <INDENT> loop [ i ] = loop [ i - 1 ] + A [ start + i ] <NEWLINE> <DEDENT> if N >= start : <NEWLINE> <INDENT> res = straight [ - 1 ] <NEWLINE> N -= start <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> res = straight [ N - 1 ] <NEWLINE> N = 0 <NEWLINE> <DEDENT> res += ( N // L ) * loop [ - 1 ] <NEWLINE> if N % L != 0 : <NEWLINE> <INDENT> res += loop [ N % L - 1 ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( res ) <NEWLINE> <NL> <NL> <NL> <DEDENT> main ( ) <NEWLINE>
n , x , m = map ( int , input ( ) . split ( ) ) <NEWLINE> mn = min ( n , m ) <NEWLINE> P = [ ] <COMMENT> <NEWLINE> sum_p = 0 <COMMENT> <NEWLINE> X = [ - 1 ] * m <COMMENT> <NEWLINE> for i in range ( mn ) : <NEWLINE> <INDENT> if X [ x ] > - 1 : <NEWLINE> <INDENT> cyc_len = len ( P ) - X [ x ] <NEWLINE> pre = P [ X [ x ] ] [ 1 ] <NEWLINE> cyc = ( sum_p - pre ) * ( ( n - X [ x ] ) // cyc_len ) <NEWLINE> nxt = P [ X [ x ] + ( n - X [ x ] ) % cyc_len ] [ 1 ] - P [ X [ x ] ] [ 1 ] <NEWLINE> print ( pre + cyc + nxt ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> P . append ( [ x , sum_p ] ) <NEWLINE> sum_p += x <NEWLINE> X [ x ] = i <NEWLINE> x = x * x % m <NEWLINE> <DEDENT> print ( sum_p ) <NEWLINE> n , x , m = map ( int , input ( ) . split ( ) ) <NEWLINE> mn = min ( n , m ) <NEWLINE> P = [ ] <COMMENT> <NEWLINE> sum_p = 0 <COMMENT> <NEWLINE> X = [ - 1 ] * m <COMMENT> <NEWLINE> for i in range ( mn ) : <NEWLINE> <INDENT> if X [ x ] > - 1 : <NEWLINE> <INDENT> cyc_len = len ( P ) - X [ x ] <NEWLINE> pre = P [ X [ x ] ] [ 1 ] <NEWLINE> cyc = ( sum_p - pre ) * ( ( n - X [ x ] ) // cyc_len ) <NEWLINE> nxt = P [ X [ x ] + ( n - X [ x ] ) % cyc_len ] [ 1 ] - P [ X [ x ] ] [ 1 ] <NEWLINE> print ( pre + cyc + nxt ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> P . append ( [ x , sum_p ] ) <NEWLINE> sum_p += x <NEWLINE> X [ x ] = i <NEWLINE> x = x * x % m <NEWLINE> <DEDENT> print ( sum_p ) <NEWLINE>
<COMMENT> <NL> N , X , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> mod_check_list = [ False for _ in range ( M ) ] <NEWLINE> mod_list = [ ( X ** 2 ) % M ] <NEWLINE> counter = 1 <NEWLINE> mod_sum = ( X ** 2 ) % M <NEWLINE> last_mod = 0 <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> now_mod = ( mod_list [ - 1 ] ** 2 ) % M <NEWLINE> if mod_check_list [ now_mod ] : <NEWLINE> <INDENT> last_mod = now_mod <NEWLINE> break <NEWLINE> <DEDENT> mod_check_list [ now_mod ] = True <NEWLINE> mod_list . append ( now_mod ) <NEWLINE> counter += 1 <NEWLINE> mod_sum += now_mod <NEWLINE> <NL> <DEDENT> loop_start_idx = 0 <NEWLINE> for i in range ( counter ) : <NEWLINE> <INDENT> if last_mod == mod_list [ i ] : <NEWLINE> <INDENT> loop_start_idx = i <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> loop_list = mod_list [ loop_start_idx : ] <NEWLINE> loop_num = counter - loop_start_idx <NEWLINE> ans = 0 <NEWLINE> if mod_list [ - 1 ] == 0 : <NEWLINE> <INDENT> ans = X + sum ( mod_list [ : min ( counter , N - 1 ) ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if ( N - 1 ) <= counter : <NEWLINE> <INDENT> ans = X + sum ( mod_list [ : counter ] ) <NEWLINE> print ( aa ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += X + mod_sum <NEWLINE> N -= ( counter + 1 ) <NEWLINE> ans += sum ( loop_list ) * ( N // loop_num ) + sum ( loop_list [ : N % loop_num ] ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> N , X , M = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <COMMENT> <NL> <NL> <NL> def f ( x : int , m : int ) -> int : <NEWLINE> <INDENT> return x ** 2 % m <NEWLINE> <NL> <NL> <DEDENT> A = { X } <NEWLINE> loop_start_index = 0 <NEWLINE> while True : <NEWLINE> <INDENT> A_next = f ( A [ - 1 ] , M ) <NEWLINE> if A_next in A : <NEWLINE> <INDENT> loop_start_index = A . index ( A_next ) <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> A . add ( A_next ) <NEWLINE> <NL> <DEDENT> <DEDENT> loop_length = len ( A ) - loop_start_index <NEWLINE> loop_cnt = ( N - loop_start_index ) // loop_length <NEWLINE> loop_res = ( N - loop_start_index ) % loop_length <NEWLINE> ans = sum ( A [ : loop_start_index ] ) + loop_cnt * sum ( A [ loop_start_index : ] ) + sum ( A [ loop_start_index : loop_start_index + loop_res ] ) <NEWLINE> <NL> <COMMENT> <NL> print ( ans ) <NEWLINE>
N , X , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> rec = [ ] <NEWLINE> s = set ( ) <NEWLINE> rec . append ( X ) <NEWLINE> s . add ( X ) <NEWLINE> r = X <NEWLINE> idx == - 1 <NEWLINE> idx1 = - 1 <NEWLINE> for i in range ( N + 1 ) : <NEWLINE> <INDENT> r = ( r ** 2 ) % M <NEWLINE> if ( r not in s ) : <NEWLINE> <INDENT> rec . append ( r ) <NEWLINE> s . add ( r ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> rec . append ( r ) <NEWLINE> idx = i + 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( len ( rec ) ) : <NEWLINE> <INDENT> if ( rec [ i ] == rec [ idx ] ) : <NEWLINE> <INDENT> idx1 = i <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if ( idx == - 1 and idx1 == - 1 ) : <NEWLINE> <INDENT> print ( sum ( rec ) ) <NEWLINE> <DEDENT> elif ( idx1 != idx ) : <NEWLINE> <INDENT> ans = sum ( rec [ : idx1 ] ) <NEWLINE> ans += sum ( rec [ idx1 : idx ] ) * ( ( N - idx1 ) // ( idx - idx1 ) ) + sum ( rec [ idx1 : ( idx1 + ( N - idx1 ) % ( idx - idx1 ) ) ] ) <NEWLINE> print ( ans ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = sum ( rec [ : idx1 ] ) <NEWLINE> ans += rec [ idx ] * ( N - idx1 ) <NEWLINE> print ( ans ) <NEWLINE> <DEDENT>
n , x , m = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ ] <NEWLINE> mod_check_list = [ False for _ in range ( M ) ] <NEWLINE> a . append ( x * x % m ) <NEWLINE> ind = 0 <NEWLINE> s = 0 <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> t = a [ i ] * a [ i ] % m <NEWLINE> if mod_check_list [ t ] : <NEWLINE> <INDENT> ind = a . index ( t ) <NEWLINE> break <NEWLINE> <DEDENT> mod_check_list [ t ] = True <NEWLINE> a . append ( t ) <NEWLINE> <DEDENT> s = sum ( a [ ind : ] ) <NEWLINE> l = len ( a ) - ind <NEWLINE> loop_times = ( n - 1 - ind ) // l <NEWLINE> answer = loop_times * s <NEWLINE> for i in range ( ( n - 1 - ind ) % l ) : <NEWLINE> <INDENT> answer += a [ i + ind ] <NEWLINE> <DEDENT> print ( answer + x + sum ( a [ : ind ] ) ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> from math import gcd <NEWLINE> from itertools import combinations , permutations , accumulate , product <COMMENT> <NEWLINE> <COMMENT> <NL> from collections import deque , defaultdict , Counter <NEWLINE> import decimal <NEWLINE> import re <NEWLINE> import math <NEWLINE> import bisect <NEWLINE> import heapq <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> import sys <NEWLINE> sys . setrecursionlimit ( 10000000 ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> INF = float ( <STRING> ) <NEWLINE> from sys import stdin <NEWLINE> readline = stdin . readline <NEWLINE> def readInts ( ) : <NEWLINE> <INDENT> return list ( map ( int , readline ( ) . split ( ) ) ) <NEWLINE> <DEDENT> def readTuples ( ) : <NEWLINE> <INDENT> return tuple ( map ( int , readline ( ) . split ( ) ) ) <NEWLINE> <DEDENT> def I ( ) : <NEWLINE> <INDENT> return int ( readline ( ) ) <NEWLINE> <DEDENT> n , x , m = readInts ( ) <NEWLINE> lis = [ ] <NEWLINE> prv = None <NEWLINE> dic = defaultdict ( int ) <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> A = x % m <NEWLINE> lis . append ( A ) <NEWLINE> dic [ A ] = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> A = ( A * A ) % m <NEWLINE> if dic [ A ] : <NEWLINE> <INDENT> prv = A <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dic [ A ] = 1 <NEWLINE> <DEDENT> lis . append ( A ) <NEWLINE> <DEDENT> <DEDENT> cnt = None <NEWLINE> for i in range ( len ( lis ) ) : <NEWLINE> <INDENT> if lis [ i ] == prv : <NEWLINE> <INDENT> cnt = i <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if cnt == None : <NEWLINE> <INDENT> cnt = len ( lis ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> if x == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> len_loop_arr = len ( loop_arr ) <NEWLINE> if n < cnt : <NEWLINE> <INDENT> ans = sum ( front_arr [ : n ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = sum ( front_arr ) <NEWLINE> sum_loop_arr = sum ( loop_arr ) <NEWLINE> n -= cnt <NEWLINE> <NL> loop = n // len_loop_arr <NEWLINE> rest = n - ( loop * len_loop_arr ) <NEWLINE> mid = loop * sum_loop_arr <NEWLINE> ans += mid <NEWLINE> ans += sum ( loop_arr [ : rest ] ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n , x , m = map ( int , input ( ) . split ( ) ) <NEWLINE> lst = [ 0 for i in range ( m ) ] <NEWLINE> lst2 = [ x ] <NEWLINE> i = 2 <NEWLINE> lst [ x ] = 1 <NEWLINE> while True : <NEWLINE> <INDENT> if ( i > n ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> x = x ** 2 % m <NEWLINE> if ( lst [ x ] == 0 ) : <NEWLINE> <INDENT> lst [ x ] = i <NEWLINE> lst2 . append ( lst2 [ i - 2 ] + x ) <NEWLINE> i = i + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> lst2 . append ( lst2 [ i - 2 ] + x ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> a = i - lst [ x ] <NEWLINE> b = lst2 [ i - 1 ] - lst2 [ i - 1 - a ] <NEWLINE> i = i - 1 <NEWLINE> c = ( n - i ) // a <NEWLINE> d = ( n - i ) % a <NEWLINE> ans = lst2 [ i - 1 ] + b * c + lst2 [ i - 1 - a + d ] - lst2 [ i - 1 - a ] <NEWLINE> print ( ans ) <NEWLINE>
from numba import njit <NEWLINE> <NL> @ njit <NEWLINE> def solve ( N , X , M ) : <NEWLINE> <INDENT> ans = 0 <NEWLINE> a = X <NEWLINE> a0 = X <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> ans += a <NEWLINE> a = ( a ** 2 ) % M <NEWLINE> if a == 1 : <NEWLINE> <INDENT> ans += ( N - i - 1 ) <NEWLINE> break <NEWLINE> <DEDENT> if a == a0 : <NEWLINE> <INDENT> w = i + 1 <NEWLINE> k = N // w <NEWLINE> m = N % w <NEWLINE> ans *= k <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> ans += a <NEWLINE> a = ( a ** 2 ) % M <NEWLINE> <DEDENT> break <NEWLINE> <DEDENT> <DEDENT> return ans <NEWLINE> <NL> <DEDENT> N , X , M = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> ans = solve ( N , X , M ) <NEWLINE> print ( ans ) <NEWLINE>
import sys <NEWLINE> readline = sys . stdin . readline <NEWLINE> <NL> N , X , M = map ( int , readline ( ) . split ( ) ) <NEWLINE> route = [ X ] <NEWLINE> dic = { } <NEWLINE> first = [ ] <NEWLINE> loop = [ ] <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> X = ( X ** 2 ) % M <NEWLINE> if X in dic : <NEWLINE> <INDENT> first = route [ : dic [ X ] ] <NEWLINE> loop = route [ dic [ X ] : ] <NEWLINE> break <NEWLINE> <DEDENT> route . append ( X ) <NEWLINE> dic [ X ] = i <NEWLINE> <NL> <DEDENT> if N == len ( first ) : <NEWLINE> <INDENT> print ( sum ( first ) ) <NEWLINE> <DEDENT> elif N < len ( first ) : <NEWLINE> <INDENT> print ( sum ( first [ : N ] ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = sum ( first ) <NEWLINE> one_loop = sum ( loop ) <NEWLINE> N -= len ( first ) <NEWLINE> loop_cnt = N // len ( loop ) <NEWLINE> rest = N % len ( loop ) <NEWLINE> ans += loop_cnt * ( sum ( loop ) ) <NEWLINE> ans += sum ( loop [ : rest ] ) <NEWLINE> <NL> print ( ans ) <NEWLINE> <DEDENT>
from numba . types import i8 <NEWLINE> ni8 = np . int64 <NEWLINE> <NL> @ njit ( ( i8 , i8 [ : , : : - 1 ] ) , cache = True ) <NEWLINE> def solve ( n , qr ) : <NEWLINE> <INDENT> col = np . full ( n - 1 , n - 2 ) <NEWLINE> col [ 0 ] = 0 <NEWLINE> col_min = n - 1 <NEWLINE> prev_col_min = n - 1 <NEWLINE> row = np . full ( n - 1 , n - 2 ) <NEWLINE> row [ 0 ] = 0 <NEWLINE> row_min = n - 1 <NEWLINE> prev_row_min = n - 1 <NEWLINE> white = 0 <NEWLINE> for i in range ( qr . shape [ 0 ] ) : <NEWLINE> <INDENT> j = qr [ i , 1 ] - 1 <NEWLINE> if qr [ i , 0 ] == 1 : <NEWLINE> <INDENT> if row_min < prev_row_min : <NEWLINE> <INDENT> for m in range ( 1 , col_min ) : <NEWLINE> <INDENT> col [ m ] = min ( col [ m ] , j - 1 ) <NEWLINE> <DEDENT> prev_row_min = row_min <NEWLINE> <DEDENT> u = col [ j ] <NEWLINE> white += u <NEWLINE> col [ j ] = 0 <NEWLINE> if j < col_min : <NEWLINE> <INDENT> col_min = j <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if col_min < prev_col_min : <NEWLINE> <INDENT> for m in range ( 1 , row_min ) : <NEWLINE> <INDENT> row [ m ] = min ( row [ m ] , j - 1 ) <NEWLINE> <DEDENT> prev_col_min = col_min <NEWLINE> <DEDENT> u = row [ j ] <NEWLINE> white += u <NEWLINE> row [ j ] = 0 <NEWLINE> if j < row_min : <NEWLINE> <INDENT> row_min = j <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return white <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> f = open ( 0 ) <NEWLINE> n , q = [ int ( x ) for x in f . readline ( ) . split ( ) ] <NEWLINE> qr = np . fromstring ( f . read ( ) , ni8 , sep = <STRING> ) . reshape ( ( - 1 , 2 ) ) <NEWLINE> white = solve ( n , qr ) <NEWLINE> print ( ( n - 2 ) ** 2 - white ) <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE>
n = int ( input ( ) . split ( ) ) <NEWLINE> if n == 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT>
x = int ( input ( ) ) <NEWLINE> if x == 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else if x == 0 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT>
def main ( x ) : <NEWLINE> <INDENT> if x = 1 : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return 1 <NEWLINE> <NL> <DEDENT> <DEDENT> main ( x ) <NEWLINE>
a , b , c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> x = a <NEWLINE> y = c <NEWLINE> max = x * y <NEWLINE> for x in range ( a , b + 1 ) : <NEWLINE> <INDENT> for y in range ( c , d + 1 ) : <NEWLINE> <INDENT> if x * y > max : <NEWLINE> <INDENT> max = x * y <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( max ) <NEWLINE>
x = int ( input ( ) ) <NEWLINE> if x = 0 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT>
inp = input ( ) <NEWLINE> if inp == 1 : <NEWLINE> print ( 0 ) <NEWLINE> else : <NEWLINE> print ( 1 ) <NEWLINE>
print ( ~ int ( input ( ) ) <NEWLINE>
x = input ( x ) <NEWLINE> <NL> if x == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> if x == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> if x == 0 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> elif x == 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT>
if x == 0 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT>
x = int ( input ( ) ) <NEWLINE> if x = 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> if x = 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> x = int ( input ( ) ) <NEWLINE> if x : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> <DEDENT>
a = int ( input ( ) <NEWLINE> if a = 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT>
print ( 1 - int ( input ( ) ) <NEWLINE>
d , t , s = map ( int , input ( ) . split ( ) ) <NEWLINE> if s * t >= d : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
1 x = int ( input ( ) ) <NEWLINE> <NL> if x == 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> if x == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
x = import ( ) <NEWLINE> <NL> if x == 0 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> <NL> if ( n == 0 ) : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else if ( n == 1 ) : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT>
<INDENT> x = int ( input ( ) ) <NEWLINE> if x == 0 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> <DEDENT>
x = int ( input ( ) ) <NEWLINE> <NL> if x = 0 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT>
x = input ( ) <NEWLINE> print ( x ^ 1 ) <NEWLINE>
s = input ( ) <NEWLINE> <NL> if s > 0 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT>
def fun ( x ) : <NEWLINE> <INDENT> x = int ( input ( ) ) <NEWLINE> if x == 0 : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return 0 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( fun ( x ) ) <NEWLINE>
if x == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif x == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
print ( 1 - input ( ) ) <NEWLINE>
x = int ( input ( ) ) <NEWLINE> if x == 0 ; <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else ; <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT>
x = input ( ) <NEWLINE> <NL> if x : <NEWLINE> <INDENT> print 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print 1 <NEWLINE> <DEDENT>
if x == 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT>
num = int ( input ( ) ) <NEWLINE> if num == 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> else : <NEWLINE> print ( 1 ) <NEWLINE> <DEDENT>
x = int ( input ( ) ) <NEWLINE> <NL> if x == 0 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT>
print ( int ( not int ( input ( ) ) ) <NEWLINE>
print ( 0 if input ( ) = <STRING> else 1 ) <NEWLINE>
x = int ( input ( ) ) <NEWLINE> if x == 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else if x == 0 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT>
x = int ( input ( ) ) <NEWLINE> if ( x == 1 ) : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> elif ( x == 0 ) : <NEWLINE> print ( 1 ) <NEWLINE> <DEDENT>
x = int ( x ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> if x == 0 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> if x == 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT>
if x = 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> if x = 0 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT>
tmp = input ( ) <NEWLINE> if tmp = <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
x = input ( ) <NEWLINE> <NL> if x > 0.5 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> elif x < 0.5 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT>
x = int ( input ( ) ) <NEWLINE> if x = 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT>
x = int ( input ) <NEWLINE> <NL> print ( 1 if x == 0 else 0 ) <NEWLINE>
x = int ( input ( ) ) <NEWLINE> if x == 0 : <NEWLINE> <INDENT> ans = 1 <NEWLINE> <DEDENT> else x == 1 : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
a , b , c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> x = a <NEWLINE> y = c <NEWLINE> max = x * y <NEWLINE> if b < 0 : <NEWLINE> <INDENT> print ( max ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for x in range ( a , b + 1 ) : <NEWLINE> <INDENT> for y in range ( c , d + 1 ) : <NEWLINE> <INDENT> if x * y > max : <NEWLINE> <INDENT> max = x * y <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( max ) <NEWLINE> <DEDENT>
x = int ( input ( ) ) <NEWLINE> <NL> if x == 0 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> els : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT>
x = input ( ) <NEWLINE> if x == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif x == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT>
x = input ( ) <NEWLINE> if X == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
x = int ( input ) <NEWLINE> if x == 0 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> return 0 if n == 1 else n <NEWLINE>
print ( 1 - input ( ) ) <NEWLINE>
a = input ( ) <NEWLINE> if a == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> else : <NEWLINE> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> print ( <STRING> if x == 0 else <STRING> ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> print ( x ^ 1 ) <NEWLINE>
input ( a ) <NEWLINE> if a == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
<NL> print ( input ( ) ^ 1 ) <NEWLINE>
print ( 1 ) if x == 1 else print ( 0 ) <NEWLINE>
if ( int ( input ( ) ) == 0 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT>
x == int ( input ( ) ) <NEWLINE> if x = 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT>
x = int ( input ) <NEWLINE> print ( abs ( 1 - x ) ) <NEWLINE>
x = intZ ( input ( ) ) <NEWLINE> <NL> print ( 0 if x else 1 ) <NEWLINE>
if x == 0 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> elif x == 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT>
import sys <NEWLINE> x = int ( sys . argv ) <NEWLINE> <NL> print ( [ 0 if i == 1 else 1 for i in x ] ) <NEWLINE>
print ( ~ input ( ) ) <NEWLINE>
N = int ( input ) <NEWLINE> if N == 0 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT>
princt ( int ( input ( ) ) ^ 1 ) <NEWLINE>
x = int ( input ( ) ) if x == 0 : print ( <STRING> ) else : print ( <STRING> ) <NEWLINE>
x = input ( ) <NEWLINE> if x == 0 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> <DEDENT>
def ( x ) <NEWLINE> <INDENT> if x == 1 <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> <DEDENT> return 1 <NEWLINE>
a , b , c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( max ( a , b ) * max ( c , d ) ) <NEWLINE>
x = int ( input ( x ) ) <NEWLINE> if x == 0 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT>
x = input ( ) <NEWLINE> x = input ( ) <NEWLINE> if x == 0 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> elif x == 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT>
x = input ( ) <NEWLINE> <NL> if x = <STRING> : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> elif x = <STRING> : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT>
input = int ( input ( ) ) <NEWLINE> if input == 0 : return 1 <NEWLINE> return 0 <NEWLINE>
t = int ( input ( ) ) <NEWLINE> if ( t == 1 ) : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 1 ) / <NEWLINE> <DEDENT>
x = input ( ) <NEWLINE> print ( 1 - x ) <NEWLINE>
x = int ( input ( ) ) <NEWLINE> <NL> if X == 0 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> elif x == 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT>
if x = 0 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT>
x = int ( input ( ) ) <NEWLINE> if x == 0 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> elif x == 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT>
def conj ( n ) : <NEWLINE> <INDENT> if n == 0 : return 1 <NEWLINE> return 0 <NEWLINE> <NL> <DEDENT> print ( conj ( int ( input ( ) ) ) <NEWLINE>
<COMMENT> <NL> import sys <NEWLINE> <NL> <NL> def solve ( x : int ) : <NEWLINE> <NL> <INDENT> if x == 1 : <NEWLINE> <INDENT> return print ( <STRING> ) <NEWLINE> <NL> <DEDENT> elif x == 0 : <NEWLINE> <INDENT> return print ( <STRING> ) 1 <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <INDENT> def iterate_tokens ( ) : <NEWLINE> <INDENT> for line in sys . stdin : <NEWLINE> <INDENT> for word in line . split ( ) : <NEWLINE> <INDENT> yield word <NEWLINE> <DEDENT> <DEDENT> <DEDENT> tokens = iterate_tokens ( ) <NEWLINE> x = int ( next ( tokens ) ) <COMMENT> <NEWLINE> solve ( x ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
if x == 0 : <NEWLINE> <INDENT> x = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = 0 <NEWLINE> <DEDENT> print ( x ) <NEWLINE>
a , b , c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( max ( [ a * c , a * d , b * c , c * d ] ) ) <NEWLINE>
print ( - ( int ( inpuut ( ) ) - 1 ) ) <NEWLINE>
i = int ( input ( ) ) <NEWLINE> if i = 0 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> elif i = 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> using namespace std ; <NEWLINE> <NL> int main ( ) { <NEWLINE> <INDENT> int x ; <NEWLINE> cin >> x ; <NEWLINE> if ( x == 0 ) { <NEWLINE> <INDENT> cout << 1 << endl ; <NEWLINE> <NL> <DEDENT> } <NEWLINE> else { <NEWLINE> <INDENT> cout << 0 << endl ; <NEWLINE> <DEDENT> } <NEWLINE> <NL> return 0 ; <NEWLINE> <DEDENT> } <NEWLINE>
print ( [ <STRING> , <STRING> ] [ x == 1 ] ) <NEWLINE>
x = int ( input ( ) ) <NEWLINE> if x == 0 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> elif x == 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT>
x = int ( input ( x ) ) <NEWLINE> if x == 0 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT>
if x == 0 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT>
x = int ( input ( ) ) <NEWLINE> if x = 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
x = int ( input ( ) ) <NEWLINE> if x = 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> elif x = 0 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT>
x = int ( input ( ) ) <NEWLINE> if x = 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT>
x = int ( input ( ) ) <NEWLINE> <NL> if ( x == 0 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif ( x == 1 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE>
def _print ( ) : <NEWLINE> <INDENT> a = int ( input ( ) ) <NEWLINE> print ( 1 if a == 0 else 0 ) <NEWLINE> <NL> <DEDENT> if __name__ = <STRING> : <NEWLINE> <INDENT> _print ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> if n == 0 { <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> } else n == 1 { <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> } <NEWLINE>
print ( int ( not ( bool ( x ) ) ) ) <NEWLINE>
print ( 1 - int ( input ( ) ) <NEWLINE>
print ( abs ( 1 - input ( ) ) ) <NEWLINE>
if x == 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT>
x = input ( ) <NEWLINE> if x == 0 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else if x == 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> print ( 0 if x else 0 ) <NEWLINE>
x = int ( input ( ) ) <NEWLINE> if x == 0 : <NEWLINE> <INDENT> print 1 <NEWLINE> <DEDENT> elif x == 1 : <NEWLINE> <INDENT> print 0 <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> if ( n == 0 ) print ( 1 ) <NEWLINE> else print ( 0 ) <NEWLINE>
x = int ( input ( ) ) <NEWLINE> <NL> if x == 0 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else x == 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT>
<NL> if x == 0 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT>
print ( 1 - int ( input ( ) ) <NEWLINE>
def f ( x ) : <NEWLINE> <INDENT> if ( x == 0 ) : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> else if ( x == 1 ) : <NEWLINE> <INDENT> return 0 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> f ( int ( input ( ) ) <NEWLINE>
<INDENT> n = int ( input ( ) ) <NEWLINE> <NL> <DEDENT> print ( 1 - n ) <NEWLINE>
x = input ( ) <NEWLINE> if x == 0 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else x == 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT>
if x == 0 : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> elif x == 1 : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT>
if 1 == int ( input ( ) ) : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT>
input_number = input ( ) <NEWLINE> if input_number = 0 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT>
def run ( x ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> print ( <STRING> . format ( 0 if x == 1 else 1 ) ) <NEWLINE> <NL> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> x = int ( input ( ) ) <NEWLINE> run ( x ) def run ( x ) : <NEWLINE> <STRING> <NEWLINE> print ( <STRING> . format ( 0 if x == 1 else 1 ) ) <NEWLINE> <NL> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> x = int ( input ( ) ) <NEWLINE> run ( x ) <NEWLINE> <DEDENT>
import sys <NEWLINE> x = int ( sys . stdin . read ( ) . strip ( ) ) <NEWLINE> print int ( not x ) <NEWLINE>
def in ( x ) : <NEWLINE> <INDENT> if x == 0 : <NEWLINE> <INDENT> return 1 <NEWLINE> if x == 1 : <NEWLINE> return 0 <NEWLINE> <DEDENT> <DEDENT> x = int ( input ( ) ) <NEWLINE> print ( in ( x ) ) <NEWLINE>
X = int ( input ( ) ) <NEWLINE> if X == 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : 1 <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT>
x = int ( input ( ) ) <NEWLINE> if ( x == 1 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> elif ( x == 0 ) : <NEWLINE> print ( <STRING> ) <NEWLINE> else : <NEWLINE> pass <NEWLINE> <DEDENT>
x = input ( ) <NEWLINE> if x = <STRING> : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> elif x = <STRING> : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT>
<INDENT> 1 s = int ( input ( ) ) <NEWLINE> 2 <NEWLINE> 3 if s == 1 : <NEWLINE> 4 print ( <STRING> ) <NEWLINE> 5 elif s == 0 : <NEWLINE> 6 print ( <STRING> ) <NEWLINE> <DEDENT>
x = input ( ) <NEWLINE> <NL> if x = 0 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> import pandas as pd <NEWLINE> import matplotlib . pyplot as plt <NEWLINE> import plotly . express as px <NEWLINE> import statsmodels . api as sm <NEWLINE> <NL> <NL> x = int ( input ( ) ) <NEWLINE> <COMMENT> <NL> <NL> if x == 0 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT>
x = int ( input ( ) ) <NEWLINE> if x . = 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT>
x = int ( input ( ) ) <NEWLINE> <NL> if x = 0 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> elif x = 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT>
a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> plint ( a ) <NEWLINE>
a , b , c , d = map ( int , input ( ) . split ( ) <NEWLINE> <NL> print ( max ( [ a * c , a * d , b * c , b * d ] ) ) <NEWLINE>
def get_ints ( ) : <NEWLINE> <INDENT> list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <DEDENT> a , b , c , d = get_ints ( ) <NEWLINE> ans = max ( a * c , b * c , a * d , b * d ) <NEWLINE> print ( ans ) <NEWLINE>
a , b , c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if a = > 0 : <NEWLINE> <INDENT> if c = > 0 : <NEWLINE> <INDENT> ans = b * d <NEWLINE> <DEDENT> elif d = > 0 : <NEWLINE> <INDENT> ans = b * d <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = a * d <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if b = > 0 : <NEWLINE> <INDENT> if c = > 0 : <NEWLINE> <INDENT> ans = b * d <NEWLINE> <DEDENT> elif d = > 0 : <NEWLINE> <INDENT> if a * c < b * d : <NEWLINE> <INDENT> ans = b * d <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = a * c <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> ans = a * c <NEWLINE> <DEDENT> <DEDENT> elif c = > 0 : <NEWLINE> <INDENT> ans = b * c <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = a * c <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> <NL> args = sys . argv <NEWLINE> a = args [ 1 ] <NEWLINE> b = args [ 2 ] <NEWLINE> c = args [ 3 ] <NEWLINE> d = args [ 4 ] <NEWLINE> <NL> aa = int ( a ) * int ( c ) <NEWLINE> bb = int ( a ) * int ( d ) <NEWLINE> cc = int ( b ) * int ( c ) <NEWLINE> dd = int ( b ) * int ( d ) <NEWLINE> <NL> li = [ aa , bb , cc , dd ] <NEWLINE> <NL> print ( max ( li ) ) <NEWLINE>
a , b , c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if a == 0 : <NEWLINE> <INDENT> a = b <NEWLINE> <DEDENT> if b == 0 : <NEWLINE> <INDENT> b = a <NEWLINE> <DEDENT> if c == 0 : <NEWLINE> <INDENT> c = d <NEWLINE> <DEDENT> if d == 0 : <NEWLINE> <INDENT> d = c <NEWLINE> <NL> <DEDENT> if max ( a , b ) < 0 and max ( c , d ) > 0 : <NEWLINE> <INDENT> A = - min ( abs ( a ) , abs ( b ) ) <NEWLINE> B = min ( abs ( c ) , abs ( d ) ) <NEWLINE> <DEDENT> elif max ( a , b ) > 0 and max ( c , d ) < 0 : <NEWLINE> <INDENT> A = min ( abs ( a ) , abs ( b ) ) <NEWLINE> B = - min ( abs ( c ) , abs ( d ) ) <NEWLINE> <DEDENT> elif max ( a , b ) > 0 and max ( c , d ) > 0 : <NEWLINE> <INDENT> A = max ( abs ( a ) , abas ( b ) ) <NEWLINE> B = max ( abs ( c ) , abs ( d ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> A = min ( abs ( a ) , abs ( b ) ) <NEWLINE> B = min ( abs ( c ) , abs ( d ) ) <NEWLINE> <NL> <DEDENT> print ( A * B ) <NEWLINE>
a , b , c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( max [ a * c , a * d , b * c , b * d ] ) <NEWLINE>
a = int ( input ( ) ) <NEWLINE> b = int ( input ( ) ) <NEWLINE> c = int ( input ( ) ) <NEWLINE> d = int ( input ( ) ) <NEWLINE> tmp = [ a * c , a * d , b * c , b * d ] <NEWLINE> print ( max ( tmp ) ) <NEWLINE>
a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> max_a = - 10 ** 30 <NEWLINE> import itertools <NEWLINE> for i in itertools . combinations ( a , 2 ) : <NEWLINE> <COMMENT> <NL> <INDENT> if ( i [ 0 ] * i [ 1 ] > max_a ) : <NEWLINE> <INDENT> max_a = i [ 0 ] * i [ i ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( max_a ) <NEWLINE>
values = [ a * c , a * d , b * c , b * d ] <NEWLINE> print ( max ( values ) ) <NEWLINE>
a , b , c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> if a >= 0 : <NEWLINE> <INDENT> if d <= 0 : <NEWLINE> <INDENT> print ( a * d ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( b * d ) <NEWLINE> <NL> <DEDENT> <DEDENT> elif b > 0 : <NEWLINE> <INDENT> if d < 0 : <NEWLINE> <INDENT> print ( a * c ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( max ( a * c , b * d ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if c >= 0 : <NEWLINE> <INDENT> print ( b * c ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( a * c ) <NEWLINE> <DEDENT> <DEDENT>
ans = - 10 ** 18 <NEWLINE> if a <= 0 <= b or c <= 0 <= d : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> ans = max ( ans , a * c , a * d , b * c , b * d ) <NEWLINE> print ( ans ) <NEWLINE>
a = int ( input ( ) ) <NEWLINE> b = int ( input ( ) ) <NEWLINE> c = int ( input ( ) ) <NEWLINE> d = int ( input ( ) ) <NEWLINE> sum = [ ] <NEWLINE> sum . append ( a * c ) <NEWLINE> sum . append ( a * d ) <NEWLINE> sum . append ( b * c ) <NEWLINE> sum . append ( b * d ) <NEWLINE> print ( max ( sum ) ) <NEWLINE>
a , b , c , d = input ( ) . split ( ) <NEWLINE> a = int ( a ) <NEWLINE> b = int ( b ) <NEWLINE> c = int ( c ) <NEWLINE> d = int ( d ) <NEWLINE> if a > 0 : <NEWLINE> <INDENT> if b * d > a * c <NEWLINE> <INDENT> print ( b * d ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( a * c ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if a * c > b * d : <NEWLINE> <INDENT> print ( a * c ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( b * d ) <NEWLINE> <DEDENT> <DEDENT>
import math <NEWLINE> a , b , c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> ac = a * c <NEWLINE> ad = a * d <NEWLINE> bc = b * c <NEWLINE> bd = b * d <NEWLINE> ans_1 = math . max ( ac , ad ) <NEWLINE> ans_2 = math . max ( bc , bd ) <NEWLINE> ans = math . max ( ans1_ , ans2 ) <NEWLINE> print ( ans ) <NEWLINE>
a , b , c , d = map ( int ( input ( ) ) . split ( ) ) <NEWLINE> print ( max ( a * c , a * d , b * c , b * d ) ) <NEWLINE>
a , b , c , d = input ( ) . split ( ) <NEWLINE> line [ n ] <NEWLINE> x = int ( b ) <NEWLINE> y = int ( d ) <NEWLINE> print ( x * y ) <NEWLINE>
a , b , c , d = input ( ) . split ( ) <NEWLINE> a = int ( a ) <NEWLINE> b = int ( b ) <NEWLINE> c = int ( c ) <NEWLINE> d = int ( d ) d <NEWLINE> list1 = [ ] <NEWLINE> list1 . append ( a * c ) <NEWLINE> list1 . append ( a * d ) <NEWLINE> list1 . append ( b * c ) <NEWLINE> list1 . append ( b * d ) <NEWLINE> list1 . sort ( ) <NEWLINE> print ( list1 [ 3 ] ) <NEWLINE>
a , b , c , d = int ( input ( ) ) , int ( input ( ) ) , int ( input ( ) ) , int ( input ( ) ) <NEWLINE> x = range ( a , b + 1 ) <NEWLINE> y = range ( c , d + 1 ) <NEWLINE> i = 0 <NEWLINE> J = 0 <NEWLINE> list = [ ] <NEWLINE> for i in x : <NEWLINE> <INDENT> for j in y : <NEWLINE> <INDENT> list . append ( i * j ) <NEWLINE> j = j + 1 <NEWLINE> <DEDENT> i = i + 1 <NEWLINE> <DEDENT> print ( max ( list ) ) <NEWLINE>
X = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> print ( max { X [ 0 ] * X [ 1 ] , X [ 1 ] * X [ 2 ] , X [ 2 ] * X [ 3 ] , X [ 3 ] * X [ 0 ] , X [ 0 ] * X [ 2 ] , <NEWLINE> <INDENT> X [ 1 ] * X [ 3 ] } ) <NEWLINE> <DEDENT>
a , b , c , d = [ int ( s ) for s in input ( ) . split ( ) ] <NEWLINE> print ( max ( a * c , a * d , b * c , b * d ) <NEWLINE>
a , b , c , d = map ( int , input ( ) . spit ( ) ) <NEWLINE> p = a * c <NEWLINE> q = a * d <NEWLINE> r = b * c <NEWLINE> s = b * d <NEWLINE> print ( max ( p , q , r , s ) ) <NEWLINE>
- 1000000000 0 - 1000000000 0 <NEWLINE>
input_lines = input ( ) . split ( ) <NEWLINE> num_lines = [ ] <NEWLINE> a = int ( input_lines [ 0 ] ) <NEWLINE> b = int ( input_lines [ 1 ] ) <NEWLINE> c = int ( input_lines [ 2 ] ) <NEWLINE> d = int1 ( input_lines [ 3 ] ) <NEWLINE> <NL> num_lines . append ( a * c ) <NEWLINE> num_lines . append ( a * d ) <NEWLINE> num_lines . append ( b * c ) <NEWLINE> num_lines . append ( b * d ) <NEWLINE> <NL> print ( max ( num_lines ) ) <NEWLINE>
a , b , c , d = map ( input ( ) ) <NEWLINE> print max ( a * c , a * d , b * c , b * d ) <NEWLINE>
a , b , c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = - 10 ** 9 <NEWLINE> for i in range ( [ a , b ] ) : <NEWLINE> <INDENT> for j in range ( [ c , d ] ) : <NEWLINE> <INDENT> ans = max ( ans , i * j ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
a , b , c , d = map ( int , imput ( ) . split ( ) ) <NEWLINE> if b >= 0 and d >= 0 : <NEWLINE> <INDENT> print ( b * d ) <NEWLINE> <DEDENT> elif b >= 0 and d < 0 and a >= 0 : <NEWLINE> <INDENT> print ( a * d ) <NEWLINE> <DEDENT> elif b >= 0 and d < 0 and a < 0 : <NEWLINE> <INDENT> print ( a * c ) <NEWLINE> <DEDENT> elif b < 0 and d >= 0 and c >= 0 : <NEWLINE> <INDENT> print ( b * c ) <NEWLINE> <DEDENT> elif b < 0 and d >= 0 and c < 0 : <NEWLINE> <INDENT> print ( a * c ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( a * c ) <NEWLINE> <DEDENT>
a , b , c , d = map ( int ( ) , input ( ) . split ( ) ) <NEWLINE> maxa = max ( a * c , a * d , b * c , b * d ) <NEWLINE> print ( maxa ) <NEWLINE>
a , b , c , d = int ( input ( ) ) . split ( ) <NEWLINE> <NL> if b > 0 & & d > 0 : <NEWLINE> <INDENT> print ( b * d ) <NEWLINE> <DEDENT> elif b < 0 & & d > 0 : <NEWLINE> <INDENT> print ( b * c ) <NEWLINE> <DEDENT> elif b > 0 & & d < 0 : <NEWLINE> <INDENT> print ( a * d ) <NEWLINE> <DEDENT> elif a < 0 & & c < 0 : <NEWLINE> <INDENT> print ( a * c ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT>
if a < 0 and c < 0 : <NEWLINE> <INDENT> print ( a * c ) <NEWLINE> <DEDENT> elif b >= 0 and d >= 0 : <NEWLINE> <INDENT> print ( b * d ) <NEWLINE> <DEDENT> elif b < 0 and c >= 0 : <NEWLINE> <INDENT> print ( b * c ) <NEWLINE> <DEDENT> elif a >= 0 and d < 0 : <NEWLINE> <INDENT> print ( a * d ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if a * c >= b * d : <NEWLINE> <INDENT> print ( a * c ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( b * d ) <NEWLINE> <DEDENT> <DEDENT>
import numpy as np <NEWLINE> if __name__ == <STRING> : <NEWLINE> <INDENT> a , b , c , d = ( int ( x ) for x in input ( ) . split ( ) ) <NEWLINE> arr = [ a * c , a * d , b * c , b * d ] <NEWLINE> print ( arr . max ( ) ) <NEWLINE> <DEDENT>
a , b , c , d = map ( int ( input ( ) . split ( ) ) ) <NEWLINE> <NL> print ( max ( a * c , a * d , b * c , b * d ) ) <NEWLINE>
a , b , c , d = input ( ) . split ( ) <NEWLINE> xy1 = a * c <NEWLINE> xy2 = a * d <NEWLINE> xy3 = b * c <NEWLINE> xy4 = b * d <NEWLINE> <NL> print ( max ( [ xy1 , xy2 , xy3 , xy4 ] ) ) <NEWLINE>
a , b , c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( mac ( max ( a * c , a * d ) , max ( b * c , b * d ) ) ) <NEWLINE>
a , b , c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = - float ( <STRING> ) <NEWLINE> <NL> x = for x in ( a , b ) : <NEWLINE> <INDENT> for y in ( c , d ) : <NEWLINE> <INDENT> ans = max ( ans , X * y ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
a , b , c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> e = [ ] <NEWLINE> for i in list [ a , b ] : <NEWLINE> <INDENT> for j in list [ c , d ] : <NEWLINE> <INDENT> e += [ i * j ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( max ( e ) ) <NEWLINE>
a , b , c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> if a * b <= 0 and c * d <= 0 : <NEWLINE> <INDENT> print ( max ( a * c , b * d ) ) <NEWLINE> <DEDENT> elif : b > 0 and d > 0 <NEWLINE> <INDENT> print ( b * d ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( a * c ) <NEWLINE> <DEDENT>
a , b , c , d = int ( input ( ) . split ( ) ) <NEWLINE> ans_list = [ ] <NEWLINE> ans_list . append ( a * c ) <NEWLINE> ans_list . append ( a * d ) <NEWLINE> ans_list . append ( b * c ) <NEWLINE> ans_list . append ( b * d ) <NEWLINE> print max ( ans_list ) <NEWLINE>
a , b , c , d = [ int ( t ) for t in input ( ) ] <NEWLINE> print ( max ( [ b * d , a * c , a * d , b * d ] ) ) <NEWLINE>
a , b , c , d = map ( int , input ( ) ) <NEWLINE> print ( max ( a * c , a * d , b * c , b * d ) ) <NEWLINE>
a = int ( input ( ) ) <NEWLINE> b = int ( input ( ) ) <NEWLINE> c = int ( input ( ) ) <NEWLINE> d = int ( input ( ) ) <NEWLINE> <NL> m = a * c <NEWLINE> <NL> if a * d > m : <NEWLINE> <INDENT> m = a * d <NEWLINE> <NL> <DEDENT> if b * c > m : <NEWLINE> <INDENT> m = b * c <NEWLINE> <NL> <DEDENT> if b * d > m : <NEWLINE> <INDENT> m = b * d <NEWLINE> <NL> <DEDENT> print ( m ) <NEWLINE>
a , b , c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> if b * d >= 0 : <NEWLINE> <INDENT> print ( b * d ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> z = [ ] <NEWLINE> <NL> for x in range ( a , b + 1 ) : <NEWLINE> <INDENT> for y in range ( c , d + 1 ) : <NEWLINE> <INDENT> z . append ( x * y ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( max ( z ) ) <NEWLINE>
a , b , c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> answer = 0 <NEWLINE> ac = a * c <NEWLINE> ad = a * d <NEWLINE> bc = b * C <NEWLINE> bd = b * d <NEWLINE> answer = max ( ac , ad ) <NEWLINE> answer = max ( answer , bc ) <NEWLINE> answer = max ( answer , bd ) <NEWLINE> print ( answer ) <NEWLINE>
a , b , c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> print ( max ( a * c , a * d , b * c <NEWLINE>
a , b , c , d = int ( input ( ) . split ( ) ) <NEWLINE> <NL> print ( max ( a * c , a * d , b * c , b * d ) ) <NEWLINE>
a , b , c , d = int ( input ( ) . split ( ) ) <NEWLINE> print ( max ( a * c , a * d , b * c , b * d ) <NEWLINE>
a , b , c , d = int ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> print ( max ( a * c , max ( a * d , max ( b * c , b * d ) ) ) ) <NEWLINE>
- 1000000000 0 - 1000000000 0 <NEWLINE>
a , b , c , d = input ( ) . split ( ) <NEWLINE> a = int ( a ) <NEWLINE> b = int ( b ) <NEWLINE> c = int ( c ) <NEWLINE> d = int ( d ) <NEWLINE> def m ( ) : <NEWLINE> <INDENT> if - 10 ^ 9 <= a <= b <= 10 ^ 9 and : - 10 ^ 9 <= c <= d <= 10 ^ 9 <NEWLINE> <INDENT> if a >= 0 and d <= 0 : <NEWLINE> <INDENT> max = a * d <NEWLINE> print ( max ) <NEWLINE> <DEDENT> elif a >= 0 and c >= 0 : <NEWLINE> <INDENT> max = b * d <NEWLINE> print ( max ) <NEWLINE> <DEDENT> elif b <= 0 and c >= 0 : <NEWLINE> <INDENT> max = b * c <NEWLINE> print ( max ) <NEWLINE> <DEDENT> elif b <= 0 and d <= 0 : <NEWLINE> <INDENT> max = a * c <NEWLINE> print ( max ) <NEWLINE> <DEDENT> elif a <= 0 and b >= 0 and c <= 0 and d >= 0 : <NEWLINE> <INDENT> if a * c >= b * d : <NEWLINE> <INDENT> max = a * c <NEWLINE> print ( max ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> max = b * d <NEWLINE> print ( max ) <NEWLINE> <DEDENT> <DEDENT> elif a >= 0 and c <= 0 and d >= 0 : <NEWLINE> <INDENT> max = b * d <NEWLINE> print ( max ) <NEWLINE> <DEDENT> elif b <= 0 and c <= 0 and d >= 0 : <NEWLINE> <INDENT> max = a * c <NEWLINE> print ( max ) <NEWLINE> <DEDENT> elif a <= 0 and b >= 0 and c >= 0 : <NEWLINE> <INDENT> max = b * d <NEWLINE> print ( max ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> m ( ) <NEWLINE>
ans = max ( max ( a * c , a * d ) , max ( b * c , b * d ) ) <NEWLINE> print ( ans ) <NEWLINE>
lst = map ( int , input ( ) . split ( ) ) <NEWLINE> x_lst = [ ] <NEWLINE> y_lst = [ ] <NEWLINE> max_lst = [ ] <NEWLINE> for i in range ( 2 ) : <NEWLINE> <INDENT> x_lst . append ( lst [ i ] ) <NEWLINE> y_lst . append ( lst [ ( i + 1 ) * - 1 ] ) <NEWLINE> <DEDENT> for j in range ( len ( x_lst ) ) : <NEWLINE> <INDENT> for k in range ( len ( y_lst ) ) : <NEWLINE> <INDENT> max_lst . append ( x_lst [ j ] * y_lst [ k ] ) <NEWLINE> <DEDENT> <DEDENT> print ( max ( max_lst ) ) <NEWLINE>
a , b , c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> max = a * c <NEWLINE> <NL> if max > bd : <NEWLINE> <INDENT> print ( max ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( bd ) <NEWLINE> <DEDENT>
nums = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = [ ] <NEWLINE> for i in range ( 2 ) : <NEWLINE> <INDENT> ans . append ( nums [ i ] * nums [ 2 ] ) <NEWLINE> ans . append ( nums [ i ] * nums [ 3 ] ) <NEWLINE> <DEDENT> print max ( ans ) <NEWLINE> <NL>
a , b , c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( max ( [ a * c , a * d , b * c , c * d ] ) <NEWLINE>
ans = - ( 10 ** 9 ) <NEWLINE> ans = max ( a * c , ans ) <NEWLINE> ans = max ( a * d , ans ) <NEWLINE> ans = max ( b * c , ans ) <NEWLINE> ans = max ( b * d , ans ) <NEWLINE> print ( ans ) <NEWLINE>
a , b , c , d = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> a += 1 <NEWLINE> c += 1 <NEWLINE> <NL> max = a * c <NEWLINE> <NL> a * d = x <NEWLINE> b * c = y <NEWLINE> b * d = z <NEWLINE> <NL> if max < x : <NEWLINE> <INDENT> max = x <NEWLINE> <DEDENT> if max < y : <NEWLINE> <INDENT> max = y <NEWLINE> <DEDENT> if max < z : <NEWLINE> <INDENT> max = z <NEWLINE> <NL> <DEDENT> print ( max ) <NEWLINE>
a , b , c , d = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> print ( max ( a * c , a * d , b * c , b * d ) ) <NEWLINE>
a , b , c , d = [ int ( input ( ) ) for i in range ( 4 ) ] <NEWLINE> x = [ a * b , a * c , b * d , b * c ] <NEWLINE> print ( max ( x ) ) <NEWLINE>
a , b , c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> i = 0 <NEWLINE> for x in range ( a , b + 1 ) : <NEWLINE> <INDENT> for y in range ( c , c + 1 ) : <NEWLINE> <INDENT> x * y = z <NEWLINE> if z >= i : <NEWLINE> <INDENT> i = z <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( i ) <NEWLINE> <NL>
a , b , c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> if a <= 0 and b <= 0 and c <= 0 and d <= 0 : <NEWLINE> <INDENT> print ( a * c ) <NEWLINE> <DEDENT> elif a >= 0 and b >= 0 and c >= 0 and d >= 0 : <NEWLINE> <INDENT> print ( b * d ) <NEWLINE> <DEDENT> elif b >= 0 and c <= 0 d <= 0 : <NEWLINE> <INDENT> print ( b * c ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( a * d ) <NEWLINE> <DEDENT>
a , b , c , d = [ int ( x ) for x in input ( ) . split ( <STRING> ) ] <NEWLINE> print ( max ( [ a * c a * d , b * c , b * d ] ) ) <NEWLINE>
if a >= 0 and c >= 0 : <NEWLINE> <INDENT> one = b <NEWLINE> two = d <NEWLINE> <NL> <DEDENT> elif b <= 0 and d <= 0 : <NEWLINE> <INDENT> one = a <NEWLINE> two = c <NEWLINE> <NL> <DEDENT> elif a >= 0 and d <= 0 : <NEWLINE> <INDENT> one = a <NEWLINE> two = d <NEWLINE> <DEDENT> elif b <= 0 and c >= 0 : <NEWLINE> <INDENT> one = b <NEWLINE> two = c <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> one = b <NEWLINE> two = d <NEWLINE> <NL> <NL> <DEDENT> print ( one * two ) <NEWLINE>
a , b , c , d = map ( int , input ( ) ) <NEWLINE> print ( max ( a * c , a * d , b * c , b * d ) <NEWLINE>
a , b , c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( max ( a * c , a * d , b * c , b * d ) <NEWLINE> <NL>
import itertool <NEWLINE> a , b , c , d = int ( input ( ) . split ( ) ) <NEWLINE> l = [ a , b , c , d ] <NEWLINE> c = itertools . combinations ( l , 2 ) <NEWLINE> ans = a * b <NEWLINE> for i in c : <NEWLINE> <INDENT> if i [ 0 ] * i [ 1 ] > ans : <NEWLINE> <INDENT> ans = i [ 0 ] * i [ 1 ] <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
a , b , c , d = map ( int , input ( ) . split ) <NEWLINE> xmx = max ( [ a , b ] ) <NEWLINE> xmin = min ( [ a , b ] ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> ymx = max ( [ c , d ] ) <NEWLINE> ymin = min ( [ c , d ] ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> if xmin >= 0 : <COMMENT> <NEWLINE> <INDENT> if ymx <= 0 : <COMMENT> <NEWLINE> <INDENT> print ( xmin * ymx ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( xmx * ymx ) <NEWLINE> <NL> <DEDENT> <DEDENT> if xmx <= 0 : <COMMENT> <NEWLINE> <INDENT> if ymin >= 0 : <COMMENT> <NEWLINE> <INDENT> print ( xmx * ymin ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( xmin * ymin ) <NEWLINE> <DEDENT> <DEDENT> else : <COMMENT> <NEWLINE> <INDENT> if ymx <= 0 : <COMMENT> <NEWLINE> <INDENT> print ( xmin * ymx ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( xmx * ymx ) <NEWLINE> <DEDENT> <DEDENT>
a , b , c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( max ( a * c , a * d , b * c , b * d ) <NEWLINE>
a , b , c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = max [ a * c , a * d , b * c , b * d ] <NEWLINE> print ( ans ) <NEWLINE>
a , b , c , d = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ac = a * c <NEWLINE> ad = a * d <NEWLINE> bc = b * c <NEWLINE> cd = b * d <NEWLINE> print ( max ( [ ac , ad , bc , bd ] ) ) <NEWLINE>
a , b , c , d = [ int ( i ) for i in input ( ) ] <NEWLINE> print ( max ( [ a * d , a * c , b * c , b * d ] ) ) <NEWLINE>
a , b , c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> l = [ a * c , a * d , b * c , b * d ] <NEWLINE> print ( max [ l ] ) <NEWLINE>
a , b , c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if a < b : <NEWLINE> <INDENT> x = b <NEWLINE> <DEDENT> if a < b : <NEWLINE> <INDENT> x = a <NEWLINE> <NL> <DEDENT> if c < d : <NEWLINE> <INDENT> y = d <NEWLINE> <DEDENT> if c > d : <NEWLINE> <INDENT> y = c <NEWLINE> <DEDENT> print ( x * y ) <NEWLINE>
inputs = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> results = [ ] <NEWLINE> for i in ( 0 , 1 ) : <NEWLINE> <INDENT> for j in ( 2 , 3 ) : <NEWLINE> <INDENT> results . append ( inputs [ i ] * inputs [ j ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( max ( results ) ) <NEWLINE>
a = int ( input ( <STRING> ) ) <NEWLINE> a = list ( map ( int , a ) ) <NEWLINE> <NL> b = ( a [ 0 ] ) <NEWLINE> c = ( a [ 1 ] ) <NEWLINE> d = ( a [ 2 ] ) <NEWLINE> e = ( a [ 3 ] ) <NEWLINE> <NL> f = b * d <NEWLINE> g = b * e <NEWLINE> h = c * d <NEWLINE> i = c * e <NEWLINE> <NL> if f > g : <NEWLINE> <INDENT> if h > f : <NEWLINE> <INDENT> if i > h : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( h ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if i > f : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( f ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if h > g : <NEWLINE> <INDENT> if i > h : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( h ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if i > g : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( g ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
a = int ( input ( ) ) <NEWLINE> b = int ( input ( ) ) <NEWLINE> c = int ( input ( ) ) <NEWLINE> d = int ( input ( ) ) <NEWLINE> <NL> num_listx = [ ] <NEWLINE> num_listy = [ ] <NEWLINE> <NL> for num in range ( a , b + 1 ) : <NEWLINE> <INDENT> if num >= a : <NEWLINE> <INDENT> num_listx . append ( num ) <NEWLINE> <DEDENT> <DEDENT> for nums in range ( c , d + 1 ) : <NEWLINE> <INDENT> if nums >= c : <NEWLINE> <INDENT> num_listy . append ( nums ) <NEWLINE> <DEDENT> <DEDENT> find_max = [ ] <NEWLINE> for i in range ( len ( num_listx ) ) : <NEWLINE> <INDENT> find_max . append ( num_listx [ i ] * num_listy [ i ] ) <NEWLINE> <DEDENT> print ( max ( find_max ) ) <NEWLINE>
a , b , c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( max ( [ a * c , a * d , b * c , b * d ] ) <NEWLINE>
a , b , c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> m = list ( ) <NEWLINE> list . append ( a * c ) <NEWLINE> list . append ( a * d ) <NEWLINE> list . append ( b * c ) <NEWLINE> list . append ( b * d ) <NEWLINE> print ( max ( m ) ) <NEWLINE>
if b > 0 and d > 0 : <NEWLINE> <INDENT> print ( max ( b * d , a * c ) ) <NEWLINE> <DEDENT> elif b > 0 and d < 0 : <NEWLINE> <INDENT> print ( a * d ) <NEWLINE> <DEDENT> elif b < 0 and d > 0 : <NEWLINE> <INDENT> print ( b * c ) <NEWLINE> <DEDENT> elif b <= 0 and d <= 0 : <NEWLINE> <INDENT> print ( a * c ) <NEWLINE> <DEDENT>
a , b , c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> answer = 0 <NEWLINE> if b < 0 : <NEWLINE> <INDENT> if c < 0 : <NEWLINE> <INDENT> answer = a * c <NEWLINE> <DEDENT> if c >= 0 : <NEWLINE> <INDENT> answer = a * c <NEWLINE> <DEDENT> <DEDENT> if b >= 0 : <NEWLINE> <INDENT> if a < 0 : <NEWLINE> <INDENT> answer = max ( a * c , b * d , 0 ) <NEWLINE> <DEDENT> if a >= 0 : <NEWLINE> <INDENT> if d < 0 : <NEWLINE> <INDENT> if a == 0 : <NEWLINE> <INDENT> answer = 0 <NEWLINE> <DEDENT> elif : <NEWLINE> <INDENT> answer = a * d <NEWLINE> <DEDENT> <DEDENT> if d >= 0 : <NEWLINE> <INDENT> answer = b * d <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( answer ) <NEWLINE>
a , b , c , d = map ( int , input . split ( ) ) <NEWLINE> print ( max ( [ a * c , a * d , b * c , b * d ] ) ) <NEWLINE>
a , b , c , d = map ( int , ( input ( ) . split ( ) ) <NEWLINE> x , y = 0 , 0 <NEWLINE> if a > b : <NEWLINE> <INDENT> x = a <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = b <NEWLINE> <DEDENT> if c > d : <NEWLINE> <INDENT> y = c <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> y = d <NEWLINE> <DEDENT> print ( x * y ) <NEWLINE>
a , b , c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> if x >= 0 and y >= 0 : <NEWLINE> <INDENT> print ( b * d ) <NEWLINE> <DEDENT> elif x >= 0 and y <= 0 : <NEWLINE> <INDENT> print ( a * d ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( a * c ) <NEWLINE> <DEDENT>
f = open ( <STRING> , <STRING> ) <NEWLINE> a , b , c , d = list ( map ( int , f . readline ( ) . split ( ) ) ) <NEWLINE> <NL> if b <= 0 and d <= 0 : <NEWLINE> <INDENT> print ( a * c ) <NEWLINE> <DEDENT> elif b < 0 and d >= 0 : <NEWLINE> <INDENT> print ( max ( c , 1 ) * b ) <NEWLINE> <DEDENT> elif b >= 0 and d < 0 : <NEWLINE> <INDENT> print ( max ( a , 1 ) * d ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( b * d ) <NEWLINE> <DEDENT>
a , b , c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if ( a >= 0 and d <= 0 ) : <NEWLINE> <INDENT> print ( a * d ) <NEWLINE> <DEDENT> elif ( b <= 0 and d <= 0 ) : <NEWLINE> <INDENT> print ( a * c ) <NEWLINE> <DEDENT> elif ( ( b <= 0 and c >= 0 ) or ( b > 0 and d < 0 ) ) : <NEWLINE> <INDENT> print ( b * c ) <NEWLINE> <DEDENT> elif ( ( b > 0 and c > 0 ) : <NEWLINE> <INDENT> print ( b * d ) <NEWLINE> <DEDENT> elif ( a * c > a * d ) : <NEWLINE> <INDENT> print ( a * c ) <NEWLINE> <DEDENT> elif ( a * c < a * d ) : <NEWLINE> <INDENT> print ( a * d ) <NEWLINE> <NL> <NL> <NL> <NL> <NL> <DEDENT>
x = input ( ) . rstrip . split ( <STRING> ) <NEWLINE> z = [ ] <NEWLINE> for i in range ( 2 ) : <NEWLINE> <INDENT> z . append ( x [ i - 2 ] * x [ 0 ] ) <NEWLINE> <INDENT> z . append ( x [ i - 2 ] * x [ 1 ] ) <NEWLINE> <DEDENT> <DEDENT> print ( max ( z ) ) <NEWLINE>
a , b , c , d = map ( int , input ( ) . split ) <NEWLINE> ans = max ( max ( a * c , a * d ) , max ( b * c , b * d ) ) <NEWLINE> print ( ans ) <NEWLINE>
s = int ( input ( ) ) . split ( ) <NEWLINE> <NL> a1 = s [ 0 ] * s [ 2 ] <NEWLINE> a2 = s [ 0 ] * s [ 3 ] <NEWLINE> a3 = s [ 1 ] * s [ 2 ] <NEWLINE> a4 = s [ 1 ] * s [ 3 ] <NEWLINE> <NL> list = ( a1 , a2 , a3 , a4 ) <NEWLINE> <NL> print ( max ( list ) ) <NEWLINE>
a , b , c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> a <= x <= b <NEWLINE> c <= y <= d <NEWLINE> <NL> print ( max ( int ( x ) * int ( y ) ) ) <NEWLINE> <NL>
a , b , c , d = int ( input ( ) ) <NEWLINE> <NL> l = list [ ] <NEWLINE> l . append ( a * c ) <NEWLINE> l . append ( b * c ) <NEWLINE> l . append ( a * d ) <NEWLINE> l . append ( b * d ) <NEWLINE> <NL> print ( max ( l ) ) <NEWLINE>
a , b , c , d = map ( int , input ( ) ) <NEWLINE> print ( max ( a * c , a * d , b * c , b * d ) ) <NEWLINE>
a , b , c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = max [ ( b * d ) , ( a * c ) , ( a * d ) , ( b * c ) ] <NEWLINE> print ( ans ) <NEWLINE>
a , b , c , d = [ int ( _ ) for _ in input ( ) . split ( ) ] <NEWLINE> if a < 0 or b < 0 or c < 0 or d < 0 : <NEWLINE> <INDENT> print ( min ( a , b ) * max ( c , d ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( max ( a , b ) * max ( c , d ) ) <NEWLINE> <DEDENT> 5 - 4 8 - 1 <NEWLINE>
a , b , c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> <INDENT> print ( max ( [ a * c , a * d , b * c , b * d ] ) ) <NEWLINE> <DEDENT>
if __name__ == <STRING> : <NEWLINE> <NL> <INDENT> a = int ( input ( ) ) <NEWLINE> b = int ( input ( ) ) <NEWLINE> c = int ( input ( ) ) <NEWLINE> d = int ( input ( ) ) <NEWLINE> <NL> if b <= 0 : <NEWLINE> <INDENT> if d <= 0 : <NEWLINE> <INDENT> xy = a * c <NEWLINE> <DEDENT> elif d > 0 : <NEWLINE> <INDENT> if c > 0 : <NEWLINE> <INDENT> xy = b * c <NEWLINE> <DEDENT> elif c == 0 : <NEWLINE> <INDENT> xy = 0 <NEWLINE> <DEDENT> elif c < 0 : <NEWLINE> <INDENT> xy = a * c <NEWLINE> <DEDENT> <DEDENT> <DEDENT> elif b > 0 : <NEWLINE> <INDENT> if a >= 0 : <NEWLINE> <INDENT> if d <= 0 : <NEWLINE> <INDENT> xy = a * d <NEWLINE> <DEDENT> elif d > 0 : <NEWLINE> <INDENT> xy = b * d <NEWLINE> <DEDENT> <DEDENT> elif a < 0 : <NEWLINE> <INDENT> if d <= 0 : <NEWLINE> <INDENT> xy = a * c <NEWLINE> <DEDENT> elif d > 0 : <NEWLINE> <INDENT> if c >= 0 : <NEWLINE> <INDENT> xy = b * d <NEWLINE> <DEDENT> elif c < 0 : <NEWLINE> <INDENT> if abs ( a * c ) > abs ( b * d ) : <NEWLINE> <INDENT> xy = a * c <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> xy = b * d <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( xy ) <NEWLINE> <DEDENT>
a , b , c d = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> print ( max ( a * c , b * d , b * c , a * d ) ) <NEWLINE>
n = input ( ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> ans = ( pow ( 10 , n , mod ) - ( ( 2 * pow ( 9 , n , mod ) ) % mod - pow ( 8 , n , mod ) + mod ) % mod + mod ) % mod <NEWLINE> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> print ( ( pow ( 10 , N , mod ) - 2 * pow ( 9 , N , mod ) + pow ( 8 , N , mod ) ) % mod ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> ans = pow ( 10 , n , MOD ) - 2 * pow ( 9. n , MOD ) - pow ( 8 , n , MOD ) <NEWLINE> print ( ans % MOD ) <NEWLINE>
a , b , c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if a * b > 0 and c * d > 0 and ( a < 0 ^ c < 0 ) : <NEWLINE> <INDENT> ans = max ( a * d , b * c ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = max ( a * c , b * d ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> print ( pow ( 10 , n , mod ) - 2 * pow ( 9 , n , mod ) - pow ( 9 , n , mod ) ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> N = input ( ) <NEWLINE> print ( ( 10 ** N - 9 ** N - 9 ** N + 8 ** N ) % ( 10 ** 9 + 7 ) ) <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE>
N = input ( ) <NEWLINE> satisfied_pattern = 10 ** N - ( 2 * ( 9 ** N ) - 8 ** N ) <NEWLINE> output = satisfied_pattern % ( 10 ** 9 + 7 ) <NEWLINE> print ( output ) <NEWLINE>
def powmod ( a , n , p ) : <NEWLINE> <INDENT> if ( n == 0 ) : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> elif ( n == 1 ) : <NEWLINE> <INDENT> return a % p <NEWLINE> <DEDENT> elif ( n % 2 == 1 ) : <NEWLINE> <INDENT> return ( ( a % p ) * ( powmod ( a , n // 2 , p ) ** 2 % p ) ) % p <NEWLINE> <DEDENT> elif ( n % 2 == 0 ) : <NEWLINE> <INDENT> return powmod ( a , n // 2 , p ) ** 2 % p <NEWLINE> <DEDENT> <DEDENT> N = int ( input ( ) ) <NEWLINE> if ( N == 1 ) : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( powmod ( 10 , N - 2 ) ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> MOD = int ( 1e9 + 7 ) <NEWLINE> n = int ( input ( ) ) <NEWLINE> print ( ( pow ( 10 , n , MOD ) - 2 * pow ( 9 , n , MOD ) % MOD + pow ( 8 , n , MOD ) + MOD ) % MOD ) <NEWLINE> <NL> <DEDENT> if __namme__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
print ( 10 ** int ( input ( ) ) - 2 * 9 ** int ( input ( ) ) + 8 ** int ( input ( ) ) ) <NEWLINE>
a , b , c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if a >= 0 and c >= 0 : <NEWLINE> <INDENT> print ( b * d ) <NEWLINE> <DEDENT> elif b <= 0 and d <= 0 : <NEWLINE> <INDENT> print ( a * c ) <NEWLINE> <DEDENT> elif a < 0 and c < 0 : <NEWLINE> <INDENT> if b <= 0 or d <= 0 : <NEWLINE> <INDENT> print ( a * c ) <NEWLINE> <DEDENT> elif abs ( a ) >= abs ( b ) and abs ( c ) >= abs ( d ) : <NEWLINE> <INDENT> print ( a * c ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( b * d ) <NEWLINE> <DEDENT> <DEDENT> elif ( b < 0 and c >= 0 ) : <NEWLINE> <INDENT> print ( b * c ) <NEWLINE> <DEDENT> elif ( a >= 0 and d < 0 ) : <NEWLINE> <INDENT> print ( a * d ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( b * d ) <NEWLINE> <DEDENT>
a , b , c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = [ ] <NEWLINE> for i in c , d : <NEWLINE> <INDENT> ans . append ( a * i ) <NEWLINE> <DEDENT> for j in c , d : <NEWLINE> <INDENT> ans . append ( b * j ) <NEWLINE> <NL> <DEDENT> print ( max ( ans ) ) <NEWLINE>
mod = 10 ** 9 + 7 <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> <NL> result = 0 <NEWLINE> <NL> ten = pow ( 10 , N , mod ) <NEWLINE> nine = pow ( 9 , N , mod ) <NEWLINE> eight = pow ( 8 , N , mod ) <NEWLINE> <NL> result = ( ten - 2 * nine + eight ) % mode <NEWLINE> <NL> print ( result ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> print ( ( 10 ** n - ( 9 ** n + 9 ** n - 8 ** n ) % ( 10 ** 9 + 7 ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> MOD = 1000000000 + 7 <NEWLINE> def power_func ( a , n , p ) : <NEWLINE> <INDENT> bi = str ( format ( n , <STRING> ) ) <COMMENT> <NEWLINE> res = 1 <NEWLINE> for i in range ( len ( bi ) ) : <NEWLINE> <INDENT> res = ( res * res ) % p <NEWLINE> if bi [ i ] == <STRING> : <NEWLINE> <INDENT> res = ( res * a ) % p <NEWLINE> <DEDENT> <DEDENT> return res <NEWLINE> <DEDENT> print ( str ( ( power_func ( 10 , N , MOD ) - 2 * power_func ( 9 , N , MOD ) + power_func ( 8 , N , MOD ) % MOD ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> ans = pow ( 10 , n , mod ) <NEWLINE> ans -= pow ( 9 , n , mod ) * 2 <NEWLINE> ans += pow ( 8 , n , mod ) <NEWLINE> print ( ans % mod ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> if N == 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> a = 1 <NEWLINE> b = 1 <NEWLINE> c = 1 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> a = pow ( 10 , n , MOD ) <NEWLINE> b = pow ( 9 , n , MOD ) <NEWLINE> c = pow ( 8 , n , MOD ) <NEWLINE> <DEDENT> ans = a - ( 2 * b ) + c <NEWLINE> if ans < 0 : <NEWLINE> <INDENT> ans += MOD <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> n = int ( input ( ) ) <NEWLINE> mod = int ( 1e9 ) + 7 <NEWLINE> print ( ( pow ( 10 , n , mod ) - 2 * pow ( 9 , n , mod ) + pow ( 8 , n , mod ) ) % mod ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> n_zero = 10 ** n - 9 ** n <COMMENT> <NEWLINE> n_nine = 10 ** n - 9 ** n <COMMENT> <NEWLINE> n_non_zn = 8 ** n <COMMENT> <NEWLINE> <NL> a = ( 10 ** n - n_zero - n_nine - n_zn ) <NEWLINE> <NL> if a < 0 : <NEWLINE> <INDENT> a = - a <NEWLINE> <NL> <DEDENT> print ( a % ( 10 ** 9 + 7 ) ) <NEWLINE>
M = 10 ** 9 + 7 <NEWLINE> n = int ( input ( ) ) <NEWLINE> print ( ( pow ( 10 , n , M ) - 2 * pow ( 9 , n , M ) + pow ( 8 , n , M ) % M ) <NEWLINE>
from functools import reduce <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> <NL> def powmod ( val , n , mod ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <NL> <INDENT> for i in range ( n ) : <NEWLINE> <INDENT> ret = ret * val % mod <NEWLINE> <NL> <DEDENT> return ret <NEWLINE> <NL> <NL> <DEDENT> all = powmod ( 10 , N , mod ) <NEWLINE> b = powmod ( 9 , N , mod ) <NEWLINE> c = powmod ( 8 , N , mod ) <NEWLINE> <NL> ans = ( all - ( 2 * b - c ) ) % mod <NEWLINE> <NL> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> <NL> mod = 10 ** 9 + 7 <NEWLINE> <NL> print ( ( pow ( 10 , n , mod ) - 2 * pow ( 9 , n , mod ) + pow ( 8 , n , mod ) ) % mod ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> print ( ( 10 ** N - 9 ** N - 9 ** N + 8 ** N ) / ( 10 ** 7 + 7 ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a , b , c = 1 , 1 , 1 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a , b , c = a * 10 , b * 9 , c * 8 <NEWLINE> a , b , c = a % ( 10 ** 9 + 7 ) , b % ( 10 ** 9 + 7 ) , , c % ( 10 ** 9 + 7 ) <NEWLINE> <DEDENT> print ( 0 if n == 1 else ( a - b * 2 + c ) % ( 10 ** 9 + 7 ) ) <NEWLINE>
<NL> n = int ( input ( ) ) <NEWLINE> n_all = 10 ** ( n ) % mod <NEWLINE> bad_0 = 9 ** ( n ) % mod <NEWLINE> bad_9 = 9 ** ( n ) % mod <NEWLINE> bad_18 = 8 ** ( n ) % mod <NEWLINE> <NL> print ( n_all - bad_0 - bad_9 + bad_18 ) <NEWLINE>
def bekijou ( a , x ) : <NEWLINE> <INDENT> MOD = 1000000009 <NEWLINE> ret = 1 <NEWLINE> for _ in range ( x ) : <NEWLINE> <INDENT> ret *= a <NEWLINE> ret %= MOD <NEWLINE> <NL> <DEDENT> <DEDENT> n = int ( input ( ) ) <NEWLINE> ret = 0 <NEWLINE> sum = bekijou ( 9 , n ) <NEWLINE> MOD = 1000000009 <NEWLINE> ret = ( 2 * sum ) % MOD <NEWLINE> ret += MOD - bekijou ( 8 , n ) <NEWLINE> ret = bekijou ( 10 , n ) + MOD - ret <NEWLINE> print ( ret ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> x = n * ( n - 1 ) % 1000000007 <NEWLINE> y = 10 ** ( n - 2 ) % 1000000007 <NEWLINE> print ( ( x * y ) % 1000000007 <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> MOD = 10 ** 9 + 7 <NEWLINE> <NL> ans = pow ( 10 , n , MOD ) - pow ( 9 , n , MOD ) - pow ( 9 , n , MOD ) + pow ( 8 , n , MOD ) <NEWLINE> <NL> <COMMENT> <NL> ans ( ans + MOD ) % MOD <NEWLINE> <NL> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> x = n * ( n - 1 ) * 2 ( 10 ** ( n - 2 ) ) <NEWLINE> <NL> print ( x % ( 10 ** 9 + 7 ) ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> import math <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> <NL> mod = 10 ** 9 + 7 <NEWLINE> <NL> print ( ( 10 ** N ) % mod - ( 9 ** N ) % mod ) - ( 9 ** N ) % mod + ( 8 ** N ) % mod ) <NEWLINE>
n , m = int ( input ( ) ) , 10 ** 9 + 7 <NEWLINE> print ( ( pow ( 10 , p , m ) - 2 * pow ( 9 , p , m ) + pow ( 8 , p , m ) ) % m ) <NEWLINE>
<COMMENT> <NL> N = int ( input ( ) ) <NEWLINE> <NL> print ( ( 10 ** N - 2 * 9 ** N + 8 ** N ) ) % ( 10 ** 9 + 7 ) <NEWLINE>
import os <NEWLINE> import sys <NEWLINE> from collections import defaultdict , Counter <NEWLINE> from itertools import product , permutations , combinations , accumulate <NEWLINE> from operator import itemgetter <NEWLINE> from bisect import bisect_left , bisect <NEWLINE> from heapq import heappop , heappush , heapify <NEWLINE> from math import ceil , floor , sqrt , factorial <NEWLINE> from copy import deepcopy <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) % ( 10 ** 9 + 7 ) <NEWLINE> num = 0 <NEWLINE> ans = ( 10 ** n ) - 2 ( 9 ** n ) + ( 8 ** n ) <NEWLINE> print ( ans % 810 ** 9 + 7 ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
mod = 10 ** 9 + 7 <NEWLINE> N = int ( input ( ) ) <NEWLINE> ans = ( pow ( a , N , mod ) - 2 * pow ( b , N , mod ) + pow ( c , N , mod ) ) % mod <NEWLINE> if ans < 0 : <NEWLINE> <INDENT> ans += mod <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n = input ( ) <NEWLINE> print ( ( 10 ** n - ( 2 * 9 ** n - 8 ** n ) ) % ( 10 ** 9 + 7 ) ) <NEWLINE>
import math <NEWLINE> n = int ( input ) <NEWLINE> m = ( 10 ** n ) - ( 2 * ( 9 ** n ) ) + ( 8 ** n ) <NEWLINE> print ( m % 1000000007 ) <NEWLINE>
<COMMENT> <NL> import sys <NEWLINE> <NL> MOD = 1000000007 <COMMENT> <NEWLINE> <NL> <NL> def solve ( N : int ) : <NEWLINE> <INDENT> return print ( ( 10 ** N - 2 * 9 ** N + 8 ** N ) ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> def iterate_tokens ( ) : <NEWLINE> <INDENT> for line in sys . stdin : <NEWLINE> <INDENT> for word in line . split ( ) : <NEWLINE> <INDENT> yield word <NEWLINE> <DEDENT> <DEDENT> <DEDENT> tokens = iterate_tokens ( ) <NEWLINE> N = int ( next ( tokens ) ) <COMMENT> <NEWLINE> solve ( N ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT> ~ <NEWLINE> ~ <NEWLINE>
<INDENT> N = int ( input ( ) ) <NEWLINE> print ( ( 10 ** N - 9 ** N - 9 ** N + 8 ** N ) % ( 10 ** 9 + 7 ) ) <NEWLINE> <DEDENT>
a = 1000000007 <NEWLINE> <NL> n = input ( ) <NEWLINE> <NL> not0 = 1 <NEWLINE> not0and9 = 1 <NEWLINE> all = 1 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> not0and9 = ( not0and9 * 8 ) % a <NEWLINE> not0 = ( not0 * 9 ) % a <NEWLINE> all = ( all * 10 ) % a ; <NEWLINE> <NL> <DEDENT> print ( ( all + not0and9 - 2 * not9 ) % a ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> <NL> a = pow ( 10 , n , 10 ** 9 + 7 ) <NEWLINE> b = pow ( 9 , n , 10 ** 9 + 7 ) <NEWLINE> c = pow ( 8 , n , 10 ** 9 + 7 ) <NEWLINE> print ( ( a - 2 * b + c ) % ( 10 ** 9 + 7 ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> <NL> def cmb ( n , r , mod ) : <NEWLINE> <INDENT> if ( r < 0 or r > n ) : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> r = min ( r , n - r ) <NEWLINE> return g1 [ n ] * g2 [ r ] * g2 [ n - r ] % mod <NEWLINE> <NL> <DEDENT> mod = 10 ** 9 + 7 <NEWLINE> MAX = 10 ** 6 <NEWLINE> g1 = [ 1 , 1 ] <NEWLINE> g2 = [ 1 , 1 ] <NEWLINE> inverse = [ 0 , 1 ] <NEWLINE> <NL> for i in range ( 2 , MAX + 1 ) : <NEWLINE> <INDENT> g1 . append ( ( g1 [ - 1 ] * i ) % mod ) <NEWLINE> inverse . append ( ( - inverse [ mod % i ] * ( mod // i ) ) % mod ) <NEWLINE> g2 . append ( ( g2 [ - 1 ] * inverse [ - 1 ] ) % mod ) <NEWLINE> <NL> <DEDENT> buf = 0 <NEWLINE> for k in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , N - k + 1 ) : <NEWLINE> <INDENT> buf += ( cmb ( N , k , mod ) * cmb ( N - k , j , mod ) * ( 8 ** ( N - k - j ) % mod ) ) % mod <NEWLINE> buf = buf % mod <NEWLINE> <DEDENT> <DEDENT> print ( buf ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> ans = 1 <NEWLINE> ans1 = 1 <NEWLINE> ans2 = 1 <NEWLINE> mod = 1000000007 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ans = ( ans * 10 ) % mod <NEWLINE> <INDENT> ans2 = ( ans2 * 8 ) % mod <NEWLINE> <DEDENT> ans1 = ( ans1 * 9 ) % mod <NEWLINE> <DEDENT> ans = ( ans - ans1 + mod ) % mod <NEWLINE> ans = ( ans - ans1 + mod ) % mod <NEWLINE> ans = ( ans + ans2 ) % mod <NEWLINE> print ( ans ) <NEWLINE>
S = int ( input ( ) ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> memo = [ - 1 ] * ( S + 1 ) <NEWLINE> def redis ( s ) : <NEWLINE> <INDENT> if memo [ s ] != - 1 : <NEWLINE> <INDENT> return memo [ s ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if s < 3 : <NEWLINE> <INDENT> memo [ s ] = 0 <NEWLINE> return 0 <NEWLINE> <DEDENT> elif s < 6 : <NEWLINE> <INDENT> memo [ s ] = 1 <NEWLINE> return 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> tmp = 0 <NEWLINE> for num in range ( s ) : <NEWLINE> <INDENT> tmp += ( redis ( num ) * redis ( s - num ) ) % mod <NEWLINE> <DEDENT> memo [ s ] = tmp <NEWLINE> return tmp % mod <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( redis ( S ) ) <NEWLINE> <NL> <NL>
from scipy . special import comb <NEWLINE> <NL> S = int ( input ( ) ) <NEWLINE> <NL> n = S // 3 <NEWLINE> k = S % 3 <NEWLINE> Q = 10 ** 9 + 7 <NEWLINE> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <COMMENT> <NL> <INDENT> m = n - i <COMMENT> <NEWLINE> ans += comb ( n - 1 , i , exact = true ) * comb ( m , k , exact = True ) <NEWLINE> if k == 2 : <NEWLINE> <INDENT> ans += k <NEWLINE> <DEDENT> ans %= Q <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
MOD = 10 ** 9 + 7 <NEWLINE> <NL> s = int ( input ( ) ) <NEWLINE> a = [ 0 ] * range ( s + 1 ) <NEWLINE> a [ 0 ] = 1 <NEWLINE> for i in range ( 3 , s + 1 ) : <NEWLINE> <INDENT> a [ i ] = sum ( a [ : i - 2 ] ) % MOD <NEWLINE> <DEDENT> print ( a [ s ] ) <NEWLINE>
MOD = 10 ** 9 + 7 <NEWLINE> def cmb ( n , r ) : <NEWLINE> <INDENT> if n - r < r : r = n - r <NEWLINE> if r == 0 : return 1 <NEWLINE> denominator = 1 <NEWLINE> numerator = 1 <NEWLINE> for i in range ( r ) : <NEWLINE> <INDENT> numerator *= n - i <NEWLINE> numerator %= Q <NEWLINE> denominator *= i + 1 <NEWLINE> denominator %= Q <NEWLINE> <DEDENT> return numerator * pow ( denominator , Q - 2 , Q ) % Q <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> S = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , S // 3 + 1 ) : <NEWLINE> <INDENT> t = S - i * 3 <NEWLINE> ans += cmb ( t + i - 1 , i - 1 ) <NEWLINE> ans %= MOD <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
s = int ( input ( ) ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> dp = [ 0 ] * s <NEWLINE> <NL> <NL> for i in range ( 4 , s + 1 ) : <NEWLINE> <INDENT> for j in range ( 0 , ( i - 3 ) + 1 ) : <NEWLINE> <INDENT> dp [ i ] += dp [ j ] <NEWLINE> dp [ i ] %= mod <NEWLINE> <DEDENT> <DEDENT> print ( dp [ s ] ) <NEWLINE> <NL>
S = int ( input ( ) ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> dp = [ 0 ] * ( S + 1 ) <NEWLINE> dp [ 0 ] = 1 <NEWLINE> for i in range ( 1 , S + 1 ) : <NEWLINE> <INDENT> for j in range ( ( i + 3 ) + 1 ) : <NEWLINE> <INDENT> dp [ i ] += dp [ j ] <NEWLINE> dp [ i ] %= mod <NEWLINE> <NL> <DEDENT> <DEDENT> print ( dp [ S ] ) <NEWLINE>
s = int ( input ( ) ) <NEWLINE> <NL> fact = [ 1 ] * s <NEWLINE> inv = [ 1 ] * s <NEWLINE> invf = [ 1 ] * s <NEWLINE> for i in range ( 2 , s ) : <NEWLINE> <INDENT> fact [ i ] = fact [ i - 1 ] * i % mod <NEWLINE> inv [ i ] = - ( p // i ) * inv [ p % i ] % mod <NEWLINE> invf [ i ] = invf [ i - 1 ] * inv [ i ] % mod <NEWLINE> <NL> <DEDENT> count = 0 <NEWLINE> rest = s <NEWLINE> for n in range ( 1 , ( s + 2 ) // 3 ) : <NEWLINE> <INDENT> rest -= 3 <NEWLINE> count = ( count + inv [ rest + n - 1 ] * invf [ rest ] * invf [ n - 1 ] ) % mod <NEWLINE> <DEDENT> print ( count ) <NEWLINE>
S = int ( input ( ) ) <NEWLINE> if S < 3 : return 0 <NEWLINE> MODULO = int ( 1e9 + 7 ) <NEWLINE> dp = [ 0 , 0 , 0 , 1 ] <NEWLINE> for i in range ( 4 , S + 1 ) : <NEWLINE> <INDENT> x = dp [ i - 3 ] + dp [ i - 1 ] <NEWLINE> x %= MODULO <NEWLINE> dp . append ( x ) <NEWLINE> <DEDENT> print ( dp [ - 1 ] ) <NEWLINE>
n = int ( input ) <NEWLINE> <NL> a = list ( ) <NEWLINE> for i in range ( n ) : <NEWLINE> <NL> <INDENT> a . append ( list ( map ( int , input ( ) . strip ( ) . split ( ) ) ) ) <NEWLINE> <DEDENT> a = list ( set ( a ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( len ( a ) ) : <NEWLINE> <INDENT> for j in range ( i + 1 , len ( a ) ) : <NEWLINE> <INDENT> ans = max ( ans , abs ( a [ i ] [ 0 ] - a [ j ] [ 0 ] ) + abs ( a [ j ] [ 1 ] , a [ i ] [ 1 ] ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<INDENT> from math import log10 <NEWLINE> <NL> class Mod : <NEWLINE> <INDENT> fac = [ ] <NEWLINE> inv = [ ] <NEWLINE> finv = [ ] <NEWLINE> mod = 0 <NEWLINE> def __init__ ( self , maxi : int , mod : int ) : <NEWLINE> <INDENT> self . mod = mod <NEWLINE> self . fac = [ 1 ] * maxi <NEWLINE> self . inv = [ 1 ] * maxi <NEWLINE> self . finv = [ 1 ] * maxi <NEWLINE> for i in range ( 2 , maxi ) : <NEWLINE> <INDENT> self . fac [ i ] = self . fac [ i - 1 ] * i % mod <NEWLINE> self . inv [ i ] = mod - self . inv [ mod % i ] * ( mod // i ) % mod <NEWLINE> self . finv [ i ] = self . finv [ i - 1 ] * self . inv [ i ] % mod <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def com ( self , n : int , k : int ) -> int : <NEWLINE> <COMMENT> <NL> <INDENT> if n < k : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> if n < 0 or k < 0 : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> return self . fac [ n ] * ( self . finv [ k ] * self . finv [ n - k ] % self . mod ) % self . mod <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <INDENT> s = int ( input ( ) ) <NEWLINE> m = Mod ( s , 10 ** 9 + 7 ) <NEWLINE> ans = 0 <NEWLINE> for n in range ( 1 , s // 3 + 1 ) : <NEWLINE> <INDENT> if 3 * n == s : <NEWLINE> <INDENT> ans = ( ans + 1 ) % ( 10 ** 9 + 7 ) <NEWLINE> break <NEWLINE> <DEDENT> ans = ( ans + m . com ( - 2 * n + s - 1 , s - 3 * n ) ) % ( 10 ** 9 + 7 ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT> <DEDENT>
s = int ( input ( ) ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> import numpy as np <NEWLINE> <NL> if s == 1 or s == 2 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> elif s == 3 or s == 4 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> array = np . zeros ( s ) <NEWLINE> array [ 2 ] = 1 <NEWLINE> array [ 3 ] = 1 <NEWLINE> for i in range ( 4 , s ) : <NEWLINE> <INDENT> array [ i ] = ( array [ i - 1 ] + array [ i - 3 ] ) % mod <NEWLINE> <DEDENT> print ( array [ s ] ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> dp = [ 0 ] * ( s + 1 ) <NEWLINE> dp [ 0 ] = 1 <NEWLINE> <NL> print ( dp [ ] ) <NEWLINE>
s = int ( input ( ) ) <NEWLINE> a = [ 0 ] * 2001 <NEWLINE> a [ 3 ] = 1 <NEWLINE> for i in range ( 4 , n + 1 ) : <NEWLINE> <INDENT> a [ i ] = a [ i - 3 ] + a [ i - 1 ] <NEWLINE> <DEDENT> mod = 10 ** 9 + 7 <NEWLINE> print ( a [ s ] % mod ) <NEWLINE>
s = int ( input ( ) ) <NEWLINE> maxcount = int ( s / 3 ) <NEWLINE> amari = s % 3 <NEWLINE> count = 0 <NEWLINE> if amari == 0 and maxcount > 0 : <NEWLINE> <INDENT> count = 1 <NEWLINE> <NL> <DEDENT> for i in range ( maxcount ) : <NEWLINE> <INDENT> amari = s - ( i + 1 ) * 3 <NEWLINE> count += comb ( amari + i , i , exact = True ) <NEWLINE> count %= 1000000007 <NEWLINE> <DEDENT> print ( count ) <NEWLINE>
S = int ( input ( ) ) <NEWLINE> <NL> def cmb ( n , r , mod ) : <NEWLINE> <INDENT> if ( r < 0 or r > n ) : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> r = min ( r , n - r ) <NEWLINE> return g1 [ n ] * g2 [ r ] * g2 [ n - r ] % mod <NEWLINE> <NL> <DEDENT> mod = 10 ** 9 + 7 <COMMENT> <NEWLINE> N = 10 ** 4 <NEWLINE> g1 = [ 1 , 1 ] <COMMENT> <NEWLINE> g2 = [ 1 , 1 ] <COMMENT> <NEWLINE> inverse = [ 0 , 1 ] <COMMENT> <NEWLINE> <NL> for i in range ( 2 , N + 1 ) : <NEWLINE> <INDENT> g1 . append ( ( g1 [ - 1 ] * i ) % mod ) <NEWLINE> inverse . append ( ( - inverse [ mod % i ] * ( mod // i ) ) % mod ) <NEWLINE> g2 . append ( ( g2 [ - 1 ] * inverse [ - 1 ] ) % mod ) <NEWLINE> <NL> <DEDENT> if S < 3 : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> n = S // 3 <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> ans += cmb ( S - 2 * <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> table = [ 0 , 0 , 1 ] <NEWLINE> if N >= 4 : <NEWLINE> <INDENT> for i in range ( 3 , N ) : <NEWLINE> <INDENT> table . append ( ( table [ i - 1 ] + table [ i - 3 ] ) % mod ) <NEWLINE> <DEDENT> print ( table [ - 1 ] % mod ) <NEWLINE> <DEDENT> elif N == 3 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT>
import scipy . special . comb <NEWLINE> S = int ( input ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 3 , S + 1 , 3 ) : <NEWLINE> <INDENT> ans += scipy . special . comb ( S - 2 * ( i // 3 ) - 1 , i // 3 - 1 , exact = True ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> <NL> def input ( ) : return sys . stdin . readline ( ) [ : - 1 ] <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> def readInt ( ) : return int ( input ( ) ) <NEWLINE> def readIntList ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> def readStringList ( ) : return list ( input ( ) ) <NEWLINE> def readStringListWithSpace ( ) : return list ( input ( ) . split ( ) ) <NEWLINE> def readString ( ) : return input ( ) <NEWLINE> <NL> target = readInt ( ) <NEWLINE> nums = [ i for i in range ( 3 , target + 1 ) ] <NEWLINE> <NL> dp = [ 0 ] * ( 1 + target ) <NEWLINE> for num in nums : <NEWLINE> <INDENT> if num <= target : <NEWLINE> <INDENT> dp [ num ] = 1 <NEWLINE> <DEDENT> <DEDENT> for i in range ( target + 1 ) : <NEWLINE> <INDENT> for num in nums : <NEWLINE> <INDENT> if i - num > 0 : <NEWLINE> <INDENT> dp [ i ] += dp [ i - num ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( dp [ - 1 ] % mod <NEWLINE>
s = int ( input ( ) ) <NEWLINE> l = 10 ** 9 + 7 <NEWLINE> list_1 = [ 0 , 1 , 1 , 1 ] <NEWLINE> list_2 = [ 0 , 1 , 2 ] <NEWLINE> for i in range ( 3 , s ) : <NEWLINE> <INDENT> list_2 . append ( ( list_2 [ i - 1 ] + list_1 [ i ] ) % l ) <NEWLINE> list_1 . append ( list_2 [ i - 2 ] ) <NEWLINE> <DEDENT> if s = 1 or s = 2 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( list_1 [ s - 1 ] ) <NEWLINE> <DEDENT>
bun = [ ] <NEWLINE> bun . append ( [ 0 , 0 ] + [ 1 ] * ( s - 2 ) ) <NEWLINE> for j in range ( 1 , s // 3 ) : <NEWLINE> <INDENT> bun . append ( [ 0 ] * ( 3 * ( j + 1 ) - 1 ) + [ 1 ] ) <NEWLINE> for i in range ( 3 * ( j + 1 ) , s ) : <NEWLINE> <INDENT> bun [ j ] . append ( ( bun [ j ] [ i - 1 ] + bun [ j - 1 ] [ i - 3 ] ) % ( 10 ** 9 + 7 ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for i in range ( s // 3 ) : <NEWLINE> <INDENT> ans = ( ans + bun [ i ] [ s - 1 ] ) % ( 10 ** 9 + 7 ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
s = int ( input ( ) ) <NEWLINE> <NL> def cmb ( n , r ) : <NEWLINE> <INDENT> if n - r < r : r = n - r <NEWLINE> if r == 0 : return 1 <NEWLINE> if r == 1 : return n <NEWLINE> <NL> numerator = [ n - r + k + 1 for k in range ( r ) ] <NEWLINE> denominator = [ k + 1 for k in range ( r ) ] <NEWLINE> <NL> for p in range ( 2 , r + 1 ) : <NEWLINE> <INDENT> pivot = denominator [ p - 1 ] <NEWLINE> if pivot > 1 : <NEWLINE> <INDENT> offset = ( n - r ) % p <NEWLINE> for k in range ( p - 1 , r , p ) : <NEWLINE> <INDENT> numerator [ k - offset ] /= pivot <NEWLINE> denominator [ k ] /= pivot <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> result = 1 <NEWLINE> for k in range ( r ) : <NEWLINE> <INDENT> if numerator [ k ] > 1 : <NEWLINE> <INDENT> result *= int ( numerator [ k ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> return result <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in range ( x ) : <NEWLINE> <INDENT> Box = i + 1 <NEWLINE> Nokori = s - 3 * Box <NEWLINE> ans_ = cmb ( Nokori + Box - 1 , Box - 1 ) <NEWLINE> ans += ans_ <NEWLINE> <DEDENT> print ( ans % ( 10 ** 9 + 7 ) ) <NEWLINE>
def cmb ( n , r , p ) : <NEWLINE> <INDENT> if ( r < 0 ) or ( n < r ) : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> r = min ( r , n - r ) <NEWLINE> return fact [ n ] * factinv [ r ] * factinv [ n - r ] % p <NEWLINE> <NL> <NL> <DEDENT> MOD = 10 ** 9 + 7 <NEWLINE> N = 10 ** 6 <NEWLINE> fact = [ 1 , 1 ] <NEWLINE> factinv = [ 1 , 1 ] <NEWLINE> inv = [ 0 , 1 ] <NEWLINE> <NL> for i in range ( 2 , N + 1 ) : <NEWLINE> <INDENT> fact . append ( ( fact [ - 1 ] * i ) % MOD ) <NEWLINE> inv . append ( ( - inv [ MOD % i ] * ( MOD // i ) ) % MOD ) <NEWLINE> factinv . append ( ( factinv [ - 1 ] * inv [ - 1 ] ) % MOD ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in range ( 1 , s // 3 + 1 ) : <NEWLINE> <INDENT> rest = s - 3 * i <NEWLINE> ans += cmb ( rest + i - 1 , rest , MOD ) <NEWLINE> <NL> <DEDENT> print ( ans % MOD ) <NEWLINE>
S = int ( input ( ) ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> dp = [ 1 ] + [ 0 ] * ( S - 1 ) <NEWLINE> <NL> for i in range ( 0 , S + 1 ) : <NEWLINE> <INDENT> for j in range ( 3 , S - 2 ) : <NEWLINE> <INDENT> dp [ i ] += dp [ j ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( dp [ S ] % mod ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> a_li , b_li = [ ] , [ ] <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> x , y = int ( input ( ) ) <NEWLINE> a_li . append ( x + y ) <NEWLINE> b_li . append ( x - y ) <NEWLINE> print ( max ( max ( a_li ) - min ( a_li ) , max ( b_li ) - min ( b_li ) ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> u = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( n ) ] <NEWLINE> z = [ u [ i ] [ 0 ] + u [ i ] [ 1 ] for i in range ( n ) ] <NEWLINE> w = [ w [ i ] [ 0 ] - w [ i ] [ 1 ] for i in range ( n ) ] <NEWLINE> d = [ max ( z ) - min ( z ) , max ( w ) - min ( w ) ] <NEWLINE> <NL> print ( max ( d ) ) <NEWLINE> <NL>
N = int ( input ( ) ) <NEWLINE> a , b , c , d = 0 , 1e10 , - 1e10 , 1e10 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> A , B = int ( input ( ) . pulit ( ) ) <NEWLINE> a = max ( a , A + B ) <NEWLINE> b = min ( b , A + B ) <NEWLINE> c = max ( c , A - B ) <NEWLINE> d = min ( d , A - B ) <NEWLINE> <DEDENT> print ( max ( abs ( a - b ) , abs ( c - d ) ) <NEWLINE>
def manhattan ( n , x , y ) : <NEWLINE> <INDENT> x2 = [ 0 ] * n <NEWLINE> y2 = [ 0 ] * n <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> x0 , y0 = xy [ i ] <NEWLINE> x2 [ i ] = x0 - y0 <NEWLINE> y2 [ i ] = x0 + y0 <NEWLINE> <DEDENT> print ( max ( max ( x2 ) - min ( x2 ) , max ( y2 ) - min ( y2 ) ) ) <NEWLINE> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> x = [ 0 ] * n <NEWLINE> y = [ 0 ] * n <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> x [ i ] , y [ i ] = map ( int , input ( ) . split ( ) ) <NEWLINE> <DEDENT> manhattan ( n , x , y ) <NEWLINE>
a , b = [ ] , <NEWLINE> for z in [ * open ( 0 ) ] [ 1 : ] : x , y = map ( int , z . split ( ) ) ; a += x + y , ; b += x - y , <NEWLINE> print ( max ( abs ( max ( a ) - min ( a ) ) , abs ( max ( b ) - min ( b ) ) ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> z_vec = [ 0 ] * n <NEWLINE> w_vec = [ 0 ] * n <NEWLINE> <NL> <NL> for i in range ( 0 , n + 1 ) : <NEWLINE> <INDENT> line = input ( ) <NEWLINE> tmp = line . split ( ) <NEWLINE> z_vec [ i ] = int ( tmp [ 0 ] ) + int ( tmp [ 1 ] ) <NEWLINE> w_vec [ i ] = int ( tmp [ 0 ] ) - int ( tmp [ 1 ] ) <NEWLINE> <NL> <DEDENT> z_ans = max ( z_vec ) - min ( z_vec ) <NEWLINE> w_ans = max ( w_vec ) - min ( w_vec ) <NEWLINE> <NL> <NL> print ( <STRING> ) <NEWLINE>
from numba import jit <NEWLINE> n = int ( input ( ) ) <NEWLINE> data = [ ] <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> data . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> <DEDENT> @ jit <NEWLINE> def main ( ) : <NEWLINE> <INDENT> ans = 0 <NEWLINE> for i in range ( 0 , n - 1 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n ) : <NEWLINE> <INDENT> d = abs ( data [ i ] [ 0 ] - data [ j ] [ 0 ] ) + abs ( data [ i ] [ 1 ] - data [ j ] [ 1 ] ) <NEWLINE> ans = max ( ans , d ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
def cost ( x1 , y1 , x2 , y2 ) : <NEWLINE> <INDENT> return abs ( x1 - x2 ) + abs ( y1 - y2 ) <NEWLINE> <NL> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> <NL> x = [ ] <NEWLINE> y = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> x . append ( a ) <NEWLINE> y . append ( b ) <NEWLINE> <DEDENT> ans = - math . inf <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n ) : <NEWLINE> <INDENT> ans = max ( ans , cost ( x [ i ] , y [ i ] , x [ j ] , y [ j ] ) ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> l = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> l . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <DEDENT> p = sorted ( l , key = lambda x : x [ 0 ] + x [ 1 ] ) <NEWLINE> q = sorted ( l , key = lambda x : x [ 0 ] - x [ 1 ] ) <NEWLINE> print ( max ( p [ - 1 ] - p [ 0 ] , q [ - 1 ] - q [ 0 ] ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> <NL> Xmax = - 2 * 10 ** 9 <NEWLINE> Ymax = - 2 * 10 ** 9 <NEWLINE> Xmin = 2 * 10 ** 9 <NEWLINE> Ymin = 2 * 10 ** 9 <NEWLINE> <NL> <NL> for i in range ( N ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> if ( x + y >= Xmax ) : <NEWLINE> <INDENT> Xmax = x + y <NEWLINE> <DEDENT> if ( x + y = < Xmin ) : <NEWLINE> <INDENT> Xmin = x + y <NEWLINE> <DEDENT> if ( x - y >= Ymax ) : <NEWLINE> <INDENT> Ymax = x - y <NEWLINE> <DEDENT> if ( x - y = < Ymin ) : <NEWLINE> <INDENT> Ymin = x - y <NEWLINE> <NL> <DEDENT> <DEDENT> print ( max ( Xmax - Xmin , Ymax - Ymin ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> l = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> l . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <DEDENT> m = [ ] <NEWLINE> for i in l : <NEWLINE> <INDENT> a , b = i <NEWLINE> k . append ( a + b ) <NEWLINE> m . append ( a - b ) <NEWLINE> <DEDENT> k . sort ( ) <NEWLINE> m . sort ( ) <NEWLINE> print ( max ( [ k [ - 1 ] - k [ 0 ] , m [ - 1 ] - m [ 0 ] ] ) ) <NEWLINE>
import sys , math <NEWLINE> from functools import lru_cache <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> <NL> def input ( ) : <NEWLINE> <INDENT> return sys . stdin . readline ( ) [ : - 1 ] <NEWLINE> <NL> <DEDENT> def mi ( ) : <NEWLINE> <INDENT> return map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <DEDENT> def ii ( ) : <NEWLINE> <INDENT> return int ( input ( ) ) <NEWLINE> <NL> <DEDENT> def i2 ( n ) : <NEWLINE> <INDENT> tmp = [ list ( mi ( ) ) for i in range ( n ) ] <NEWLINE> return [ list ( i ) for i in zip ( * tmp ) ] <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> N = ii ( ) <NEWLINE> x , y = i2 ( N ) <NEWLINE> <NL> Mw = max ( x [ i ] + y [ i ] for i in range ( N ) ) <NEWLINE> mw = min ( x [ i ] + y [ i ] for i in range ( N ) ) <NEWLINE> Mz = max ( abs ( a [ i ] - y [ i ] ) for i in range ( N ) ) <NEWLINE> mz = min ( abs ( x [ i ] - y [ i ] ) for i in range ( N ) ) <NEWLINE> <NL> print ( max ( Mz - mz , Mw - mw ) ) <NEWLINE> <NL> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
2 <NEWLINE> 1 1 <NEWLINE> 1 1 <NEWLINE>
import sys <NEWLINE> <COMMENT> <NL> from collections import deque , Counter , defaultdict <NEWLINE> <COMMENT> <NL> import bisect <NEWLINE> import heapq <NEWLINE> <COMMENT> <NL> import itertools <NEWLINE> import numpy as np <NEWLINE> input = sys . stdin . readline <NEWLINE> sys . setrecursionlimit ( 10 ** 8 ) <NEWLINE> inf = 10 ** 18 <NEWLINE> MOD = 1000000007 <NEWLINE> ri = lambda : int ( input ( ) ) <NEWLINE> rs = lambda : input ( ) . strip ( ) <NEWLINE> rl = lambda : list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> n = ri ( ) <NEWLINE> a = [ ] <NEWLINE> b = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> x , y = rl ( ) <NEWLINE> a . append ( x + y ) <NEWLINE> b . append ( x - y ) <NEWLINE> <DEDENT> a . sort ( ) <NEWLINE> b . sort ( ) <NEWLINE> print ( max ( a [ - 1 ] - a [ 0 ] , b [ - 1 ] - [ 0 ] ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> v = [ list ( map ( input ( ) . split ) ) for i in range ( N ) ] <NEWLINE> v . sort ( key = lambda x : abs ( x [ 0 ] ) + abs ( x [ 1 ] ) ) <NEWLINE> d = abs ( v [ 0 ] [ 0 ] - v [ N - 1 ] [ 0 ] ) + abs ( v [ 0 ] [ 1 ] - v [ N - 1 ] [ 1 ] ) <NEWLINE> print ( d ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> <COMMENT> <NL> a_max = 2 <NEWLINE> a_min = 2 * ( 10 ** 9 ) <NEWLINE> s_max = 0 <NEWLINE> s_min = 10 ** 9 <NEWLINE> <NL> for i in N : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> add = x + y <NEWLINE> sub = x - y <NEWLINE> <NL> if add > a_max : <NEWLINE> <INDENT> a_max = add <NEWLINE> <DEDENT> if add < a_min : <NEWLINE> <INDENT> a_min = add <NEWLINE> <DEDENT> if sub > s_max : <NEWLINE> <INDENT> s_max = sub <NEWLINE> <DEDENT> if sub < s_max : <NEWLINE> <INDENT> s_max = sub <NEWLINE> <NL> <DEDENT> <DEDENT> d_add = a_max - a_min <NEWLINE> d_sub = s_max - s_min <NEWLINE> <NL> print ( max ( d_add , d_sub ) ) <NEWLINE>
import sys <NEWLINE> <NL> def f ( x , y ) : <NEWLINE> <INDENT> return x - y . x + y <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> input = sys . stdin . buffer . readline <NEWLINE> n = int ( input ( ) ) <NEWLINE> x = [ 0 ] * n <NEWLINE> y = [ 0 ] * n <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> x [ i ] , y [ i ] = map ( int , input ( ) . split ( ) ) <NEWLINE> <DEDENT> f0 = [ 0 ] * n <NEWLINE> f1 = [ 0 ] * n <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> f0 [ i ] , fi [ i ] = f ( x [ i ] , y [ i ] ) <NEWLINE> <DEDENT> print ( max ( max ( f0 ) - minf ( 0 ) , max ( f1 ) - minf ( 1 ) ) ) <NEWLINE> <NL> <DEDENT> if __name__ = <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
from sys import stdin <NEWLINE> nii = lambda : map ( int , stdin . readline ( ) . split ( ) ) <NEWLINE> lnii = lambda : list ( map ( int , stdin . readline ( ) . split ( ) ) ) <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> <NL> l = lnii ( ) <NEWLINE> <NL> if len ( l ) == 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> x_max = 0 <NEWLINE> x_min = 10 ** 10 <NEWLINE> y_max = 0 <NEWLINE> y_min = 10 ** 10 <NEWLINE> <NL> for x , y in l : <NEWLINE> <INDENT> s = x - y <NEWLINE> x_max = max ( x_max , s ) <NEWLINE> x_min = min ( x_min , s ) <NEWLINE> <NL> t = x + y <NEWLINE> y_max = max ( y_max , t ) <NEWLINE> y_min = min ( y_min , t ) <NEWLINE> <NL> <DEDENT> x_ans = x_max - x_min <NEWLINE> y_ans = y_max - y_min <NEWLINE> print ( max ( x_ans , y_ans ) ) <NEWLINE>
import sys <NEWLINE> pin = sys . stdin . readline <NEWLINE> <NL> N = int ( pin ( ) ) <NEWLINE> A = list ( map ( int , pin ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , pin ( ) . split ( ) ) ) <NEWLINE> C = reversed ( B ) <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> if A [ i ] == C [ i ] : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> for k in C : <NEWLINE> <INDENT> sys . stdout . write ( <STRING> ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> D = B [ N // 2 : ] + B [ : N // 2 ] <NEWLINE> for j in range ( N ) : <NEWLINE> <INDENT> if A [ j ] == D [ j ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> for l in D : <NEWLINE> <INDENT> sys . stdout . write ( <STRING> ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT>
import collections <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> arr1 = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> arr2 = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> cnt1 = collections . Counter ( arr1 ) <NEWLINE> cnt2 = collections . Counter ( arr2 ) <NEWLINE> acum1 = [ 0 ] * ( n + 1 ) <NEWLINE> acum2 = [ 0 ] * ( n + 1 ) <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> acum1 [ i ] = acum1 [ i - 1 ] + cnt1 [ i ] <NEWLINE> acum2 [ i ] = acum2 [ i - 1 ] + cnt1 [ i ] <NEWLINE> <DEDENT> rotate = 0 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> rotate = max ( rotate , acum1 [ i ] - acum2 [ i - 1 ] ) <NEWLINE> <DEDENT> ans = [ 0 ] * n <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ans [ ( i + rotate ) % n ] = arr2 [ i ] <NEWLINE> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> if arr1 [ i ] == ans [ i ] <NEWLINE> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> print ( * ans ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> AB = [ ( a , i , 0 ) for i , a in enumerate ( A ) ] + [ ( b , i , 1 ) for i , b in enumerate ( B ) ] <NEWLINE> AB . sort ( ) <NEWLINE> <NL> X = AB [ : N ] <NEWLINE> Y = AB [ N : ] <NEWLINE> <NL> if any ( x [ 0 ] == y [ 0 ] for x , y in zip ( X , Y ) ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> ans = [ - 1 ] * N <NEWLINE> swap = [ ] <NEWLINE> <NL> for ( _ , i , sx ) , ( _ , j , sy ) in zip ( X , Y ) : <NEWLINE> <INDENT> if sx == sy : <NEWLINE> <INDENT> swap . append ( ( min ( i , j ) , max ( i , j ) ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if sx == 0 : <NEWLINE> <INDENT> ans [ i ] = B [ j ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans [ j ] = B [ i ] <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if len ( swap ) != len ( set ( swap ) ) : <NEWLINE> <INDENT> 1 / 0 <NEWLINE> <NL> <DEDENT> print ( <STRING> ) <NEWLINE> <NL>
from collections import Counter , deque <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) + [ N + 1 ] <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) + [ N + 1 ] <NEWLINE> C = [ 0 ] <NEWLINE> D = [ 0 ] <NEWLINE> <NL> AB_cn = Counter ( A + B ) <NEWLINE> if AB_cn . most_common ( ) [ 0 ] [ 1 ] > N : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> for i in range ( N + 1 ) : <NEWLINE> <INDENT> if len ( C ) != A [ i ] : <NEWLINE> <INDENT> C . extend ( [ i ] * ( A [ i ] - len ( C ) ) ) <NEWLINE> <DEDENT> if len ( D ) != B [ i ] : <NEWLINE> <INDENT> D . extend ( [ i ] * ( B [ i ] - len ( D ) ) ) <NEWLINE> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> curr = C [ i + 1 ] - D [ i ] <NEWLINE> ans = max ( curr , ans ) <NEWLINE> <DEDENT> B = B [ : - 1 ] <NEWLINE> ans = [ B [ ( i - x ) % N ] for i in range ( N ) ] <NEWLINE> <NL> print ( * ans ) <NEWLINE> <DEDENT>
def solve ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = b [ : : - 1 ] <NEWLINE> <NL> l = [ ] <NEWLINE> num -= 1 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if a [ i ] == b [ i ] : <NEWLINE> <INDENT> l . append ( i ) <NEWLINE> num = a [ i ] <NEWLINE> <NL> <DEDENT> <DEDENT> ind = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if b [ i ] != num and a [ i ] != num and ind < len ( l ) : <NEWLINE> <INDENT> b [ i ] , b [ l [ ind ] ] = b [ l [ ind ] ] , b [ i ] <NEWLINE> ind += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if ind < len ( l ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> print ( * b ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> solve ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> from heapq import * <NEWLINE> <NL> read = sys . stdin . buffer . read <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> readlines = sys . stdin . buffer . readlines <NEWLINE> <NL> N = int ( readline ( ) ) <NEWLINE> A = list ( map ( int , readline ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , readline ( ) . split ( ) ) ) <NEWLINE> <NL> countA = [ 0 ] * ( N + 1 ) <NEWLINE> countB = [ 0 ] * ( N + 1 ) <NEWLINE> for x in A : <NEWLINE> <INDENT> countA [ x ] += 1 <NEWLINE> <DEDENT> for x in B : <NEWLINE> <INDENT> countB [ x ] += 1 <NEWLINE> <NL> <DEDENT> q = [ ] <NEWLINE> only_A = [ ] <NEWLINE> only_B = [ ] <NEWLINE> for i in range ( N + 1 ) : <NEWLINE> <INDENT> if countA [ i ] and countB [ i ] : <NEWLINE> <INDENT> q . append ( ( - countA [ i ] - countB [ i ] , i ) ) <NEWLINE> continue <NEWLINE> <DEDENT> if countA [ i ] : <NEWLINE> <INDENT> for _ in range ( countA [ i ] ) : <NEWLINE> <INDENT> only_A . append ( i ) <NEWLINE> <DEDENT> <DEDENT> elif countB [ i ] : <NEWLINE> <INDENT> for _ in range ( countB [ i ] ) : <NEWLINE> <INDENT> only_B . append ( i ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> heapify ( q ) <NEWLINE> <NL> if q and - q [ 0 ] [ 0 ] > N : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> raise <NEWLINE> print ( <STRING> ) <NEWLINE> <NL> ans = [ ] <NEWLINE> while q : <NEWLINE> <INDENT> _ , x = heappop ( q ) <NEWLINE> if q : <NEWLINE> <INDENT> _ , y = heappop ( q ) <NEWLINE> flag = True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> y = only_B . pop ( ) <NEWLINE> flag = False <NEWLINE> <DEDENT> countA [ x ] -= 1 <NEWLINE> countB [ y ] -= 1 <NEWLINE> ans . append ( ( x , y ) ) <NEWLINE> if countA [ x ] : <NEWLINE> <INDENT> heappush ( q , ( - countA [ x ] - countB [ x ] , x ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for _ in range ( countB [ x ] ) : <NEWLINE> <INDENT> only_B . append ( x ) <NEWLINE> <DEDENT> <DEDENT> if flag and countB [ y ] : <NEWLINE> <INDENT> heappush ( q , ( - countA [ y ] - countB [ y ] , y ) ) <NEWLINE> <DEDENT> if flag and not countB [ y ] : <NEWLINE> <INDENT> for _ in range ( countA [ y ] ) : <NEWLINE> <INDENT> only_A . append ( y ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> while only_A : <NEWLINE> <INDENT> x , y = only_A . pop ( ) , only_B . pop ( ) <NEWLINE> ans . append ( ( x , y ) ) <NEWLINE> <NL> <DEDENT> X , Y = zip ( * ans ) <NEWLINE> print ( * Y ) <NEWLINE>
from collections import Counter <NEWLINE> import sys <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ca = Counter ( A ) <NEWLINE> cb = Counter ( B ) <NEWLINE> if ca . most_common ( ) [ 0 ] [ 1 ] + cb . most_common ( ) [ 0 ] [ 1 ] > N : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> print ( <STRING> ) <NEWLINE> random . shuffle ( B ) <NEWLINE>
import networkx as nx <NEWLINE> def MAP ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> n , q = MAP ( ) <NEWLINE> g = nx . utils . UnionFind ( range ( n ) ) <NEWLINE> for _ in range ( q ) : <NEWLINE> <INDENT> t , u , v = MAP ( ) <NEWLINE> if t == 0 : g . union ( u , v ) <NEWLINE> else : print ( 1 if g [ u ] == g [ v ] else 0 <NEWLINE> <DEDENT>
N , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> dsu = DSU ( N ) <NEWLINE> <NL> for _ in range ( Q ) : <NEWLINE> <INDENT> t , u , v = map ( int , input ( ) . split ( ) ) <NEWLINE> if t == 0 : <NEWLINE> <COMMENT> <NL> <INDENT> dsu . merge ( u , v ) <NEWLINE> <DEDENT> else : <NEWLINE> <COMMENT> <NL> <INDENT> if dsu . same ( u , v ) : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> import typing <NEWLINE> <NL> <NL> class DSU : <NEWLINE> <INDENT> <STRING> <NEWLINE> <NL> def __init__ ( self , n : int = 0 ) : <NEWLINE> <INDENT> self . _n = n <NEWLINE> self . parent_or_size = [ - 1 ] * n <NEWLINE> <NL> <DEDENT> def merge ( self , a : int , b : int ) -> int : <NEWLINE> <INDENT> assert 0 <= a < self . _n <NEWLINE> assert 0 <= b < self . _n <NEWLINE> <NL> x = self . leader ( a ) <NEWLINE> y = self . leader ( b ) <NEWLINE> <NL> if x == y : <NEWLINE> <INDENT> return x <NEWLINE> <NL> <DEDENT> if - self . parent_or_size [ x ] < - self . parent_or_size [ y ] : <NEWLINE> <INDENT> x , y = y , x <NEWLINE> <NL> <DEDENT> self . parent_or_size [ x ] += self . parent_or_size [ y ] <NEWLINE> self . parent_or_size [ y ] = x <NEWLINE> <NL> return x <NEWLINE> <NL> <DEDENT> def same ( self , a : int , b : int ) -> bool : <NEWLINE> <INDENT> assert 0 <= a < self . _n <NEWLINE> assert 0 <= b < self . _n <NEWLINE> <NL> return self . leader ( a ) == self . leader ( b ) <NEWLINE> <NL> <DEDENT> def leader ( self , a : int ) -> int : <NEWLINE> <INDENT> assert 0 <= a < self . _n <NEWLINE> <NL> if self . parent_or_size [ a ] < 0 : <NEWLINE> <INDENT> return a <NEWLINE> <NL> <DEDENT> self . parent_or_size [ a ] = self . leader ( self . parent_or_size [ a ] ) <NEWLINE> return self . parent_or_size [ a ] <NEWLINE> <NL> <DEDENT> def size ( self , a : int ) -> int : <NEWLINE> <INDENT> assert 0 <= a < self . _n <NEWLINE> <NL> return - self . parent_or_size [ self . leader ( a ) ] <NEWLINE> <NL> <DEDENT> def groups ( self ) -> typing . List [ typing . List [ int ] ] : <NEWLINE> <INDENT> leader_buf = [ self . leader ( i ) for i in range ( self . _n ) ] <NEWLINE> <NL> result = [ [ ] for _ in range ( self . _n ) ] <NEWLINE> for i in range ( self . _n ) : <NEWLINE> <INDENT> result [ leader_buf [ i ] ] . append ( i ) <NEWLINE> <NL> <DEDENT> return list ( filter ( lambda r : r , result ) ) <NEWLINE> <DEDENT> <DEDENT>
class UnionFind : <NEWLINE> <INDENT> def __init__ ( self , length ) : <NEWLINE> <INDENT> self . parent_indexes = [ - 1 ] * length <NEWLINE> <NL> <DEDENT> def union ( self , i , j ) : <NEWLINE> <INDENT> if self . are_in_the_same_group ( i , j ) : <NEWLINE> <INDENT> return <NEWLINE> <COMMENT> <NL> <DEDENT> if self . get_group_size ( i ) < self . get_group_size ( j ) : <NEWLINE> <INDENT> i , j = j , i <NEWLINE> <INDENT> parent_of_i = self . find ( i ) <NEWLINE> <DEDENT> <DEDENT> self . parent_indexes [ self . find ( i ) ] = - self . get_group_size ( i ) - self . get_group_size ( j ) <NEWLINE> self . parent_indexes [ self . find ( j ) ] = self . find ( i ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> def find ( self , i ) : <NEWLINE> <INDENT> if self . parent_indexes [ i ] < 0 : <NEWLINE> <INDENT> return i <NEWLINE> <DEDENT> parent_index = self . find ( self . parent_indexes [ i ] ) <NEWLINE> self . parent_indexes [ i ] = parent_index <NEWLINE> return parent_index <NEWLINE> <NL> <DEDENT> def get_group_size ( self , i ) : <NEWLINE> <INDENT> return - self . parent_indexes [ self . find ( i ) ] <NEWLINE> <NL> <DEDENT> def are_in_the_same_group ( self , i , j ) : <NEWLINE> <INDENT> return self . find ( i ) == self . find ( j ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> n , q = list ( map ( lambda x : int ( x ) , input ( ) . split ( ) ) ) <NEWLINE> uf = UnionFind ( n ) <NEWLINE> for _ in range ( q ) : <NEWLINE> <INDENT> t , u , v = list ( map ( lambda x : int ( x ) , input ( ) . split ( ) ) ) <NEWLINE> <COMMENT> <NL> if t == 0 : <NEWLINE> <INDENT> uf . union ( u , v ) <NEWLINE> continue <NEWLINE> <DEDENT> print ( <STRING> ) if uf . are_in_the_same_group ( u , v ) else print ( <STRING> ) <NEWLINE> <DEDENT>
class UnionFind : <NEWLINE> <INDENT> def __init__ ( self , size ) : <NEWLINE> <INDENT> self . par = [ - 1 ] * size <NEWLINE> <NL> <DEDENT> def find ( self , x ) : <NEWLINE> <INDENT> if self . par [ x ] < 0 : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . par [ x ] = self . find ( self . par [ x ] ) <NEWLINE> return self . par [ x ] <NEWLINE> <NL> <DEDENT> <DEDENT> def unite ( self , x , y ) : <NEWLINE> <INDENT> x , y = self . find ( x ) , self . find ( y ) <NEWLINE> if x == y : return False <NEWLINE> if self . par [ x ] > self . par [ y ] : <NEWLINE> <INDENT> x , y = y , x <NEWLINE> <DEDENT> self . par [ x ] += self . par [ y ] <NEWLINE> self . par [ y ] = x <NEWLINE> return True <NEWLINE> <NL> <DEDENT> def same ( self , x , y ) : <NEWLINE> <INDENT> return self . find ( x ) == self . find ( y ) <NEWLINE> <NL> <DEDENT> def size ( self , x ) : <NEWLINE> <INDENT> return - self . par [ self . find ( x ) ] <NEWLINE> <NL> <DEDENT> <DEDENT> N , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> uf = Unionfind ( N ) <NEWLINE> for _ in range ( Q ) : <NEWLINE> <INDENT> t , u , v = map ( int , input ( ) . split ( ) ) <NEWLINE> if t == 0 : <NEWLINE> <INDENT> uf . unite ( u , v ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if uf . same ( u , v ) : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
code = <STRING> <NEWLINE> import os , sys <NEWLINE> if sys . argv [ - 1 ] == <STRING> : <NEWLINE> <INDENT> open ( <STRING> , <STRING> ) . write ( code ) <NEWLINE> os . system ( <STRING> ) <NEWLINE> <DEDENT> import solve <NEWLINE>
<NL> class UnionFind ( ) : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . n = n <NEWLINE> self . parents = [ - 1 ] * n <NEWLINE> <NL> <DEDENT> def find ( self , x ) : <NEWLINE> <INDENT> if self . parents [ x ] < 0 : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . parents [ x ] = self . find ( self . parents [ x ] ) <NEWLINE> return self . parents [ x ] <NEWLINE> <NL> <DEDENT> <DEDENT> def union ( self , x , y ) : <NEWLINE> <INDENT> x = self . find ( x ) <NEWLINE> y = self . find ( y ) <NEWLINE> <NL> if x == y : <NEWLINE> <INDENT> return <NEWLINE> <NL> <DEDENT> if self . parents [ x ] > self . parents [ y ] : <NEWLINE> <INDENT> x , y = y , x <NEWLINE> <NL> <DEDENT> self . parents [ x ] += self . parents [ y ] <NEWLINE> self . parents [ y ] = x <NEWLINE> <NL> <DEDENT> def size ( self , x ) : <NEWLINE> <INDENT> return - self . parents [ self . find ( x ) ] <NEWLINE> <NL> <DEDENT> def same ( self , x , y ) : <NEWLINE> <INDENT> return self . find ( x ) == self . find ( y ) <NEWLINE> <NL> <DEDENT> def members ( self , x ) : <NEWLINE> <INDENT> root = self . find ( x ) <NEWLINE> return [ i for i in range ( self . n ) if self . find ( i ) == root ] <NEWLINE> <NL> <DEDENT> def roots ( self ) : <NEWLINE> <INDENT> return [ i for i , x in enumerate ( self . parents ) if x < 0 ] <NEWLINE> <NL> <DEDENT> def group_count ( self ) : <NEWLINE> <INDENT> return len ( self . roots ( ) ) <NEWLINE> <NL> <DEDENT> def all_group_members ( self ) : <NEWLINE> <INDENT> return { r : self . members ( r ) for r in self . roots ( ) } <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> n , q = list ( map ( lambda x : int ( x ) , input ( ) . split ( ) ) ) <NEWLINE> uf = UnionFind ( n ) <NEWLINE> for _ in range ( q ) : <NEWLINE> <INDENT> t , u , v = list ( map ( lambda x : int ( x ) , input ( ) . split ( ) ) ) <NEWLINE> <COMMENT> <NL> if t == 0 : <NEWLINE> <INDENT> uf . union ( u , v ) <NEWLINE> continue <NEWLINE> <DEDENT> print ( <STRING> ) if uf . are_in_the_same_group ( u , v ) else print ( <STRING> ) <NEWLINE> <DEDENT>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> def find ( A , x ) : <NEWLINE> <INDENT> p = A [ x ] <NEWLINE> if p == x : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> a = find ( A , p ) <NEWLINE> A [ x ] = a <NEWLINE> return a <NEWLINE> <NL> <DEDENT> def union ( A , x , y ) : <NEWLINE> <COMMENT> <NL> <INDENT> if find ( A , x ) > find ( A , y ) : <NEWLINE> <INDENT> bx , by = find ( A , y ) , find ( A , x ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> bx , by = find ( A , x ) , find ( A , y ) <NEWLINE> <DEDENT> A [ y ] = bx <NEWLINE> A [ by ] = bx <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> N , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> TUV = [ tuple ( map ( int , input ( ) . split ( ) ) ) for _ in range ( Q ) ] <NEWLINE> G = [ i for i in range ( N ) ] <NEWLINE> ANS = [ ] <NEWLINE> for t , u , v in TUV : <NEWLINE> <INDENT> if t == 0 : <NEWLINE> <INDENT> union ( T , u , v ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if find ( T , u ) == find ( T , v ) : <NEWLINE> <INDENT> ANS . append ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ANS . append ( 0 ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> . join ( map ( str , ANS ) ) ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> from numba import njit , i8 , jitclass <NEWLINE> import sys <NEWLINE> <NL> spec = [ <NEWLINE> <INDENT> ( <STRING> , i8 ) , <NEWLINE> ( <STRING> , i8 [ : ] ) <NEWLINE> <DEDENT> ] <NEWLINE> <NL> <NL> @ jitclass ( spec ) <NEWLINE> class Bit : <NEWLINE> <INDENT> def __init__ ( self , n , arr ) : <NEWLINE> <INDENT> self . size = n <NEWLINE> self . tree = np . array ( [ 0 ] + arr , np . int64 ) <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> self . tree [ i + 1 | i + 2 ] += self . tree [ i ] <NEWLINE> <NL> <DEDENT> <DEDENT> def sum ( self , i ) : <NEWLINE> <INDENT> s = 0 <NEWLINE> while i > 0 : <NEWLINE> <INDENT> s += self . tree [ i ] <NEWLINE> i -= i & - i <NEWLINE> <DEDENT> return s <NEWLINE> <NL> <DEDENT> def add ( self , i , x ) : <NEWLINE> <INDENT> while i <= self . size : <NEWLINE> <INDENT> self . tree [ i ] += x <NEWLINE> i += i & - i <NEWLINE> <NL> <DEDENT> <DEDENT> def range_sum ( self , l , r ) : <NEWLINE> <INDENT> return self . sum ( r ) - self . sum ( l ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <INDENT> n , q = map ( int , sys . stdin . buffer . readline ( ) . split ( ) ) <NEWLINE> bit = Bit ( n , list ( map ( int , sys . stdin . buffer . readline ( ) . split ( ) ) ) ) <NEWLINE> for x in sys . stdin . buffer . readlines ( ) : <NEWLINE> <INDENT> q , p , x = map ( int , x . split ( ) ) <NEWLINE> if q : <NEWLINE> <INDENT> print ( bit . range_sum ( p , x ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> bit . add ( p + 1 , x ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> <NL> class Bit : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . size = n <NEWLINE> self . tree = [ 0 ] * ( n + 1 ) <NEWLINE> <NL> <DEDENT> def sum ( self , i ) : <NEWLINE> <INDENT> s = 0 <NEWLINE> while i > 0 : <NEWLINE> <INDENT> s += self . tree [ i ] <NEWLINE> i -= i & - i <NEWLINE> <DEDENT> return s <NEWLINE> <NL> <DEDENT> def add ( self , i , x ) : <NEWLINE> <INDENT> while i <= self . size : <NEWLINE> <INDENT> self . tree [ i ] += x <NEWLINE> i += i & - i <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <COMMENT> <NL> <INDENT> n , q = map ( int , sys . stdin . buffer . readline ( ) . split ( ) ) <NEWLINE> bit = Bit ( n + 1 ) <NEWLINE> a = list ( map ( int , sys . stdin . buffer . readline ( ) . split ( ) ) ) <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> bit . add ( i , a [ i ] ) <NEWLINE> <DEDENT> print ( bit . tree ) <NEWLINE> for x in sys . stdin . buffer . readlines ( ) : <NEWLINE> <INDENT> q , p , x = map ( int , x . split ( ) ) <NEWLINE> if q : <NEWLINE> <INDENT> print ( bit . sum ( x ) - bit . sum ( p ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> bit . add ( p , x ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> cimport numpy as np <NEWLINE> cdef extern from <STRING> namespace <STRING> nogil : <NEWLINE> <INDENT> cdef cppclass fenwick_tree [ T ] : <NEWLINE> <INDENT> fenwick_tree ( int n ) <NEWLINE> void add ( int p , T x ) <NEWLINE> T sum ( int l , int r ) <NEWLINE> <NL> <DEDENT> <DEDENT> cdef class FenwickTree : <NEWLINE> <INDENT> cdef fenwick_tree [ long long ] * _thisptr <NEWLINE> def __cinit__ ( self , np . ndarray [ long , ndim = 1 ] array ) : <NEWLINE> <INDENT> cdef int N = array . size <NEWLINE> self . _thisptr = new fenwick_tree [ long long ] ( N ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> self . add ( i , array [ i ] ) <NEWLINE> <DEDENT> <DEDENT> cpdef void add ( self , int p , long long x ) : <NEWLINE> <INDENT> self . _thisptr . add ( p , x ) <NEWLINE> <DEDENT> cpdef long long sum ( self , int l , int r ) : <NEWLINE> <INDENT> return self . _thisptr . sum ( l , r ) <NEWLINE> <DEDENT> <DEDENT>
n , q = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> bit = [ 0 ] * ( 2 * n + 10 ) <NEWLINE> def bit_update ( x , v ) : <NEWLINE> <INDENT> while x < size : <NEWLINE> <INDENT> bit [ x ] += v <NEWLINE> x += ( x & - x ) <NEWLINE> <DEDENT> <DEDENT> def bit_sum ( n ) : <NEWLINE> <INDENT> s = 0 <NEWLINE> if n == 0 : return 0 <NEWLINE> x = n <NEWLINE> while x > 0 : <NEWLINE> <INDENT> s += bit [ x ] <NEWLINE> x -= ( x & - x ) <NEWLINE> <DEDENT> return s <NEWLINE> <DEDENT> for i , j in enumerate ( a , 1 ) : <NEWLINE> <INDENT> bit_update ( i , j ) <NEWLINE> <DEDENT> for i in range ( q ) : <NEWLINE> <INDENT> a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> if a == 0 : <NEWLINE> <INDENT> bit_update ( b + 1 , c ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( bit_sum ( c ) - bit_sum ( b ) ) <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> <NL> <NL> class Bit : <NEWLINE> <INDENT> def __init__ ( self , n , arr ) : <NEWLINE> <INDENT> self . size = n <NEWLINE> self . tree = [ 0 ] + arr <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if i + ( i & - i ) < n + 1 : <NEWLINE> <INDENT> self . tree [ i + ( i & - i ) ] += self . tree [ i ] <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> def sum ( self , i ) : <NEWLINE> <INDENT> s = 0 <NEWLINE> while i > 0 : <NEWLINE> <INDENT> s += self . tree [ i ] <NEWLINE> i -= i & - i <NEWLINE> <DEDENT> return s <NEWLINE> <NL> <DEDENT> def add ( self , i , x ) : <NEWLINE> <INDENT> while i <= self . size : <NEWLINE> <INDENT> self . tree [ i ] += x <NEWLINE> i += i & - i <NEWLINE> <NL> <DEDENT> <DEDENT> def range_sum ( self , l , r ) : <NEWLINE> <INDENT> return self . sum ( r ) - self . sum ( l ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <INDENT> n , q = map ( int , sys . stdin . buffer . readline ( ) . split ( ) ) <NEWLINE> bit = Bit ( n ) <NEWLINE> bit . build ( map ( int , sys . stdin . buffer . readline ( ) . split ( ) ) ) <NEWLINE> for x in sys . stdin . buffer . readlines ( ) : <NEWLINE> <INDENT> q , p , x = map ( int , x . split ( ) ) <NEWLINE> if q : <NEWLINE> <INDENT> print ( bit . range_sum ( p , x ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> bit . add ( p + 1 , x ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
<NL> code = <STRING> <NEWLINE> <NL> <NL> import os , sys <NEWLINE> if sys . argv [ - 1 ] == <STRING> : <NEWLINE> <INDENT> open ( <STRING> , <STRING> ) . write ( code ) <NEWLINE> os . system ( <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> from atcoder import FenwickTree <NEWLINE> <NL> readline = sys . stdin . buffer . readline <NEWLINE> <NL> N , Q = list ( map ( int , readline ( ) . split ( ) ) ) <NEWLINE> ft = FenwickTree ( N ) <NEWLINE> <NL> A = list ( map ( int , readline ( ) . split ( ) ) ) <NEWLINE> <NL> for i , a in enumerate ( A ) : <NEWLINE> <INDENT> ft . add ( i , a ) <NEWLINE> <NL> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> a , b , c = list ( map ( int , readline ( ) . split ( ) ) ) <NEWLINE> if a == 0 : <NEWLINE> <INDENT> ft . add ( b , c ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ft . sum ( b , c ) ) <NEWLINE> <DEDENT> <DEDENT>
def solve ( n , m , a , b ) : <NEWLINE> <INDENT> ans = 0 <NEWLINE> lim = ( a * n + b ) // m <NEWLINE> <NL> for i in range ( 1 , lim + 1 ) : <NEWLINE> <INDENT> l = ( i * m - b + a - 1 ) // a <NEWLINE> r = ( i * m + m - b - 1 ) // a <NEWLINE> <NL> ans += ( min ( r , n - 1 ) - l + 1 ) * i <NEWLINE> <NL> <DEDENT> return ans <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> t = int ( input ( ) ) <NEWLINE> while t > 0 : <NEWLINE> <INDENT> n , m , a , b = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> print ( solve ( n , m , a , b ) ) <NEWLINE> t -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
<NL> code = <STRING> <NEWLINE> <NL> <NL> import os , sys , getpass <NEWLINE> <NL> if sys . argv [ - 1 ] == <STRING> : <NEWLINE> <INDENT> code . replace ( <STRING> , getpass . getuser ( ) ) <NEWLINE> open ( <STRING> , <STRING> ) . write ( code ) <NEWLINE> os . system ( <STRING> ) <NEWLINE> sys . exit ( 0 ) <NEWLINE> <NL> <NL> <DEDENT> from atcoder import FloorSum <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> T = int ( input ( ) ) <NEWLINE> for i in range ( T ) : <NEWLINE> <INDENT> n , m , a , b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> print ( FloorSum ( n , m , a , b ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> main ( ) <NEWLINE>
<STRING> <NEWLINE> def main ( ) : <NEWLINE> <INDENT> import sys <NEWLINE> pin = sys . stdin . readline <NEWLINE> pout = sys . stdout . write <NEWLINE> perr = sys . stderr . write <NEWLINE> <NL> T = int ( pin ( ) ) <NEWLINE> for j in range ( T ) : <NEWLINE> <INDENT> N , M , A , B = map ( int , pin ( ) . split ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> ans += ( A * i + B ) // M <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <DEDENT> return <NEWLINE> <DEDENT> main ( ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <NL> <STRING> <NEWLINE> <COMMENT> <NL> <NL> <COMMENT> <NL> class convolution : <NEWLINE> <INDENT> def __init__ ( self , a : list , b : list , mod : int ) : <NEWLINE> <INDENT> self . a , self . b = a , b <NEWLINE> self . n , self . m = len ( a ) , len ( b ) <NEWLINE> self . MOD = mod <NEWLINE> self . g = primitive_root_constexpr ( self . MOD ) <NEWLINE> <NL> <DEDENT> def convolution ( self ) -> list : <NEWLINE> <INDENT> n , m = self . n , self . m <NEWLINE> a , b = self . a , self . b <NEWLINE> if not n or not m : return [ ] <NEWLINE> if min ( n , m ) <= 60 : <NEWLINE> <INDENT> if n < m : <NEWLINE> <INDENT> n , m = m , n <NEWLINE> a , b = b , a <NEWLINE> <DEDENT> ans = [ 0 ] * ( n + m - 1 ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( m ) : <NEWLINE> <INDENT> ans [ i + j ] += a [ i ] * b [ j ] % self . MOD <NEWLINE> ans [ i + j ] %= self . MOD <NEWLINE> <DEDENT> <DEDENT> return ans <NEWLINE> <DEDENT> z = 1 << ceil_pow2 ( n + m - 1 ) <NEWLINE> a = self . resize ( a , z ) <NEWLINE> a = self . butterfly ( a ) <NEWLINE> b = self . resize ( b , z ) <NEWLINE> b = self . butterfly ( b ) <NEWLINE> for i in range ( z ) : a [ i ] = a [ i ] * b [ i ] % self . MOD <NEWLINE> a = self . butterfly_inv ( a ) <NEWLINE> a = a [ : n + m - 1 ] <NEWLINE> iz = self . inv ( z ) <NEWLINE> a = [ x * iz % self . MOD for x in a ] <NEWLINE> return a <NEWLINE> <NL> <DEDENT> def butterfly ( self , a : list ) -> list : <NEWLINE> <INDENT> n = len ( a ) <NEWLINE> h = ceil_pow2 ( n ) <NEWLINE> first = True <NEWLINE> sum_e = [ 0 ] * 30 <NEWLINE> m = self . MOD <NEWLINE> if first : <NEWLINE> <INDENT> first = False <NEWLINE> es , ies = [ 0 ] * 30 , [ 0 ] * 30 <NEWLINE> cnt2 = bsf ( m - 1 ) <NEWLINE> e = self . mypow ( self . g , ( m - 1 ) >> cnt2 ) ; ie = self . inv ( e ) <NEWLINE> for i in range ( cnt2 , 1 , - 1 ) : <NEWLINE> <INDENT> es [ i - 2 ] = e <NEWLINE> ies [ i - 2 ] = ie <NEWLINE> e = e * e % m <NEWLINE> ie = ie * ie % m <NEWLINE> <DEDENT> now = 1 <NEWLINE> for i in range ( cnt2 - 2 ) : <NEWLINE> <INDENT> sum_e [ i ] = es [ i ] * now % m <NEWLINE> now = now * ies [ i ] % m <NEWLINE> <DEDENT> <DEDENT> for ph in range ( 1 , h + 1 ) : <NEWLINE> <INDENT> w = 1 << ( ph - 1 ) ; p = 1 << ( h - ph ) <NEWLINE> now = 1 <NEWLINE> for s in range ( w ) : <NEWLINE> <INDENT> offset = s << ( h - ph + 1 ) <NEWLINE> for i in range ( p ) : <NEWLINE> <INDENT> l = a [ i + offset ] % m <NEWLINE> r = a [ i + offset + p ] * now % m <NEWLINE> a [ i + offset ] = ( l + r ) % m <NEWLINE> a [ i + offset + p ] = ( l - r ) % m <NEWLINE> <DEDENT> now = now * sum_e [ bsf ( ~ s ) ] % m <NEWLINE> <DEDENT> <DEDENT> return a <NEWLINE> <NL> <DEDENT> def butterfly_inv ( self , a : list ) -> list : <NEWLINE> <INDENT> n = len ( a ) <NEWLINE> h = ceil_pow2 ( n ) <NEWLINE> first = True <NEWLINE> sum_ie = [ 0 ] * 30 <NEWLINE> m = self . MOD <NEWLINE> if first : <NEWLINE> <INDENT> first = False <NEWLINE> es , ies = [ 0 ] * 30 , [ 0 ] * 30 <NEWLINE> cnt2 = bsf ( m - 1 ) <NEWLINE> e = self . mypow ( self . g , ( m - 1 ) >> cnt2 ) ; ie = self . inv ( e ) <NEWLINE> for i in range ( cnt2 , 1 , - 1 ) : <NEWLINE> <INDENT> es [ i - 2 ] = e <NEWLINE> ies [ i - 2 ] = ie <NEWLINE> e = e * e % m <NEWLINE> ie = ie * ie % m <NEWLINE> <DEDENT> now = 1 <NEWLINE> for i in range ( cnt2 - 2 ) : <NEWLINE> <INDENT> sum_ie [ i ] = ies [ i ] * now % m <NEWLINE> now = es [ i ] * now % m <NEWLINE> <DEDENT> <DEDENT> for ph in range ( h , 0 , - 1 ) : <NEWLINE> <INDENT> w = 1 << ( ph - 1 ) ; p = 1 << ( h - ph ) <NEWLINE> inow = 1 <NEWLINE> for s in range ( w ) : <NEWLINE> <INDENT> offset = s << ( h - ph + 1 ) <NEWLINE> for i in range ( p ) : <NEWLINE> <INDENT> l = a [ i + offset ] % m <NEWLINE> r = a [ i + offset + p ] % m <NEWLINE> a [ i + offset ] = ( l + r ) % m <NEWLINE> a [ i + offset + p ] = ( m + l - r ) * inow % m <NEWLINE> <DEDENT> inow = sum_ie [ bsf ( ~ s ) ] * inow % m <NEWLINE> <DEDENT> <DEDENT> return a <NEWLINE> <NL> <DEDENT> @ staticmethod <NEWLINE> def resize ( array : list , sz : int ) -> list : <NEWLINE> <INDENT> new_array = array + [ 0 ] * ( sz - len ( array ) ) <NEWLINE> return new_array <NEWLINE> <DEDENT> def inv ( self , x : int ) : <NEWLINE> <INDENT> if is_prime_constexpr ( self . MOD ) : <NEWLINE> <INDENT> assert x <NEWLINE> return self . mypow ( x , self . MOD - 2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> eg = inv_gcd ( x ) <NEWLINE> assert eg [ 0 ] == 1 <NEWLINE> return eg [ 1 ] <NEWLINE> <DEDENT> <DEDENT> def mypow ( self , x : int , n : int ) -> int : <NEWLINE> <INDENT> assert 0 <= n <NEWLINE> r = 1 ; m = self . MOD <NEWLINE> while n : <NEWLINE> <INDENT> if n & 1 : r = r * x % m <NEWLINE> x = x * x % m <NEWLINE> n >>= 1 <NEWLINE> <DEDENT> return r <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> class dsu : <NEWLINE> <INDENT> def __init__ ( self , n : int ) : <NEWLINE> <INDENT> self . _n = n <NEWLINE> self . parent_or_size = [ - 1 ] * self . _n <NEWLINE> <NL> <DEDENT> def merge ( self , a : int , b : int ) -> int : <NEWLINE> <INDENT> assert 0 <= a and a < self . _n <NEWLINE> assert 0 <= b and a < self . _n <NEWLINE> x = self . leader ( a ) ; y = self . leader ( b ) <NEWLINE> if x == y : return x <NEWLINE> if - self . parent_or_size [ x ] < - self . parent_or_size [ y ] : x , y = y , x <NEWLINE> self . parent_or_size [ x ] += self . parent_or_size [ y ] <NEWLINE> self . parent_or_size [ y ] = x <NEWLINE> return x <NEWLINE> <NL> <DEDENT> def same ( self , a : int , b : int ) -> bool : <NEWLINE> <INDENT> assert 0 <= a and a < self . _n <NEWLINE> assert 0 <= b and a < self . _n <NEWLINE> return self . leader ( a ) == self . leader ( b ) <NEWLINE> <NL> <DEDENT> def leader ( self , a : int ) -> int : <NEWLINE> <INDENT> assert 0 <= a and a < self . _n <NEWLINE> if self . parent_or_size [ a ] < 0 : return a <NEWLINE> self . parent_or_size [ a ] = self . leader ( self . parent_or_size [ a ] ) <NEWLINE> return self . parent_or_size [ a ] <NEWLINE> <NL> <DEDENT> def size ( self , a : int ) -> int : <NEWLINE> <INDENT> assert 0 <= a and a < self . _n <NEWLINE> return - self . parent_or_size [ self . leader ( a ) ] <NEWLINE> <NL> <DEDENT> def groups ( self ) : <NEWLINE> <INDENT> leader_buf = [ 0 ] * self . _n ; group_size = [ 0 ] * self . _n <NEWLINE> for i in range ( self . _n ) : <NEWLINE> <INDENT> leader_buf [ i ] = self . leader ( i ) <NEWLINE> group_size [ leader_buf [ i ] ] += 1 <NEWLINE> <DEDENT> result = [ [ ] for _ in range ( self . _n ) ] <NEWLINE> for i in range ( self . _n ) : <NEWLINE> <INDENT> result [ leader_buf [ i ] ] . append ( i ) <NEWLINE> <DEDENT> result = [ v for v in result if v ] <NEWLINE> return result <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> class fenwick_tree : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . _n = n <NEWLINE> self . data = [ 0 ] * n <NEWLINE> <NL> <DEDENT> def add ( self , p : int , x : int ) : <NEWLINE> <INDENT> assert 0 <= p and p <= self . _n <NEWLINE> p += 1 <NEWLINE> while p <= self . _n : <NEWLINE> <INDENT> self . data [ p - 1 ] += x <NEWLINE> p += p & - p <NEWLINE> <NL> <DEDENT> <DEDENT> def sum ( self , l : int , r : int ) -> int : <NEWLINE> <INDENT> assert 0 <= l and l <= r and r <= self . _n <NEWLINE> return self . __sum ( r ) - self . __sum ( l ) <NEWLINE> <NL> <DEDENT> def __sum ( self , r : int ) -> int : <NEWLINE> <INDENT> s = 0 <NEWLINE> while r > 0 : <NEWLINE> <INDENT> s += self . data [ r - 1 ] <NEWLINE> r -= r & - r <NEWLINE> <DEDENT> return s <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> def ceil_pow2 ( n : int ) -> int : <NEWLINE> <INDENT> x = 0 <NEWLINE> while ( 1 << x ) < n : x += 1 <NEWLINE> return x <NEWLINE> <NL> <DEDENT> def bsf ( n : int ) -> int : <NEWLINE> <INDENT> return ( n & - n ) . bit_length ( ) - 1 <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> def safe_mod ( x : int , m : int ) -> int : <NEWLINE> <INDENT> x %= m <NEWLINE> if x < 0 : x += m <NEWLINE> return x <NEWLINE> <NL> <DEDENT> class barrett : <NEWLINE> <INDENT> def __init__ ( self , m : int ) : <NEWLINE> <INDENT> self . _m = m <NEWLINE> self . im = - 1 // ( m + 1 ) <NEWLINE> <DEDENT> def umod ( self ) : return self . _m <NEWLINE> def mul ( self , a : int , b : int ) -> int : <NEWLINE> <INDENT> z = a <NEWLINE> z *= b <NEWLINE> x = ( z * im ) >> 64 <NEWLINE> v = z - x * self . _m <NEWLINE> if self . _m <= v : v += self . _m <NEWLINE> return v <NEWLINE> <NL> <DEDENT> <DEDENT> def pow_mod_constexpr ( x : int , n : int , m : int ) -> int : <NEWLINE> <INDENT> if m == 1 : return 0 <NEWLINE> _m = m ; r = 1 ; y = safe_mod ( x , m ) <NEWLINE> while n : <NEWLINE> <INDENT> if n & 1 : r = ( r * y ) % _m <NEWLINE> y = ( y * y ) % _m <NEWLINE> n >>= 1 <NEWLINE> <DEDENT> return r <NEWLINE> <NL> <DEDENT> def is_prime_constexpr ( n : int ) -> bool : <NEWLINE> <INDENT> if n <= 1 : return False <NEWLINE> if n == 2 or n == 7 or n == 61 : return True <NEWLINE> if n % 2 == 0 : return False <NEWLINE> d = n - 1 <NEWLINE> while d % 2 == 0 : d //= 2 <NEWLINE> for a in [ 2 , 7 , 61 ] : <NEWLINE> <INDENT> t = d <NEWLINE> y = pow_mod_constexpr ( a , t , n ) <NEWLINE> while t != n - 1 and y != 1 and y != n - 1 : <NEWLINE> <INDENT> y = y * y % n <NEWLINE> t <<= 1 <NEWLINE> <DEDENT> if y != n - 1 and t % 2 == 0 : return False <NEWLINE> <DEDENT> return True <NEWLINE> <NL> <DEDENT> def inv_gcd ( self , a : int , b : int ) -> tuple : <NEWLINE> <INDENT> a = safe_mod ( a , b ) <NEWLINE> if a == 0 : return ( b , 0 ) <NEWLINE> s = b ; t = a ; m0 = 0 ; m1 = 1 <NEWLINE> while t : <NEWLINE> <INDENT> u = s // t <NEWLINE> s -= t * u <NEWLINE> m0 -= m1 * u <NEWLINE> tmp = s ; s = t ; t = tmp ; tmp = m0 ; m0 = m1 ; m1 = tmp <NEWLINE> <DEDENT> if m0 < 0 : m0 += b // s <NEWLINE> return ( s , m0 ) <NEWLINE> <NL> <DEDENT> def primitive_root_constexpr ( m : int ) -> int : <NEWLINE> <INDENT> if m == 2 : return 1 <NEWLINE> if m == 167772161 : return 3 <NEWLINE> if m == 469762049 : return 3 <NEWLINE> if m == 754974721 : return 11 <NEWLINE> if m == 998244353 : return 3 <NEWLINE> divs = [ 0 ] * 20 <NEWLINE> divs [ 0 ] = 2 <NEWLINE> cnt = 1 <NEWLINE> x = ( m - 1 ) // 2 <NEWLINE> while x % 2 == 0 : x //= 2 <NEWLINE> i = 3 <NEWLINE> while i * i <= x : <NEWLINE> <INDENT> if x % i == 0 : <NEWLINE> <INDENT> divs [ cnt ] = i ; cnt += 1 <NEWLINE> while x % i == 0 : <NEWLINE> <INDENT> x //= i <NEWLINE> <DEDENT> <DEDENT> i += 2 <NEWLINE> <DEDENT> if x > 1 : divs [ cnt ] = x ; cnt += 1 <NEWLINE> g = 2 <NEWLINE> while True : <NEWLINE> <INDENT> ok = True <NEWLINE> for i in range ( cnt ) : <NEWLINE> <INDENT> if pow_mod_constexpr ( g , ( m - 1 ) // div [ i ] , m ) == 1 : <NEWLINE> <INDENT> ok = False <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if ok : return g <NEWLINE> g += 1 <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> class simple_queue : <NEWLINE> <INDENT> def __init__ ( self ) : <NEWLINE> <INDENT> self . payload = [ ] <NEWLINE> self . pos = 0 <NEWLINE> <DEDENT> def size ( self ) : return len ( self . payload ) - self . pos <NEWLINE> def empty ( self ) : return self . pos == len ( self . payload ) <NEWLINE> def push ( self , t : int ) : self . payload . append ( t ) <NEWLINE> def front ( self ) : return self . payload [ self . pos ] <NEWLINE> def clear ( self ) : self . payload . clear ( ) ; pos = 0 <NEWLINE> def pop ( self ) : self . pos += 1 <NEWLINE> def pop_front ( self ) : self . pos += 1 ; return self . payload [ ~ - self . pos ] <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> class csr : <NEWLINE> <INDENT> def __init__ ( self , n : int , edges : list ) : <NEWLINE> <INDENT> from copy import deepcopy <NEWLINE> self . start = [ 0 ] * ( n + 1 ) <NEWLINE> self . elist = [ [ ] for _ in range ( len ( edges ) ) ] <NEWLINE> for e in edges : <NEWLINE> <INDENT> self . start [ e [ 0 ] + 1 ] += 1 <NEWLINE> <DEDENT> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> self . start [ i ] += self . start [ i - 1 ] <NEWLINE> <DEDENT> counter = deepcopy ( self . start ) <NEWLINE> for e in edges : <NEWLINE> <INDENT> self . elist [ counter [ e [ 0 ] ] ] = e [ 1 ] ; counter [ e [ 0 ] ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> class scc_graph : <NEWLINE> <COMMENT> <NL> <INDENT> edges = [ ] <NEWLINE> <NL> <COMMENT> <NL> def __init__ ( self , n : int ) : <NEWLINE> <INDENT> self . _n = n <NEWLINE> self . now_ord = 0 ; self . group_num = 0 <NEWLINE> <NL> <DEDENT> def num_vertices ( self ) : return self . _n <NEWLINE> <NL> def add_edge ( self , _from : int , _to : int ) : self . edges . append ( ( _from , [ _to ] ) ) <NEWLINE> <NL> def scc_ids ( self ) : <NEWLINE> <INDENT> g = csr ( self . _n , self . edges ) <NEWLINE> visited = [ ] ; low = [ 0 ] * self . _n ; ord = [ - 1 ] * self . _n ; ids = [ 0 ] * self . _n <NEWLINE> <NL> def dfs ( s , v : int ) : <NEWLINE> <INDENT> low [ v ] = ord [ v ] = self . now_ord ; self . now_ord += 1 <NEWLINE> visited . append ( v ) <NEWLINE> for i in range ( g . start [ v ] , g . start [ v + 1 ] ) : <NEWLINE> <INDENT> to = g . elist [ i ] [ 0 ] <NEWLINE> if ord [ to ] == - 1 : <NEWLINE> <INDENT> s ( s , to ) <NEWLINE> low [ v ] = min ( low [ v ] , low [ to ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> low [ v ] = min ( low [ v ] , ord [ to ] ) <NEWLINE> <DEDENT> <DEDENT> if low [ v ] == ord [ v ] : <NEWLINE> <INDENT> while True : <NEWLINE> <INDENT> u = visited . pop ( ) <NEWLINE> ord [ u ] = self . _n <NEWLINE> ids [ u ] = self . group_num <NEWLINE> if u == v : break <NEWLINE> <DEDENT> self . group_num += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( self . _n ) : <NEWLINE> <INDENT> if ord [ i ] == - 1 : dfs ( dfs , i ) <NEWLINE> <DEDENT> for i in range ( self . _n ) : <NEWLINE> <INDENT> ids [ i ] = self . group_num - 1 - ids [ i ] <NEWLINE> <NL> <DEDENT> return ( self . group_num , ids ) <NEWLINE> <NL> <DEDENT> def scc ( self ) : <NEWLINE> <INDENT> ids = self . scc_ids ( ) <NEWLINE> group_num = ids [ 0 ] <NEWLINE> counts = [ 0 ] * group_num <NEWLINE> for x in ids [ 1 ] : counts [ x ] += 1 <NEWLINE> groups = [ [ ] for _ in range ( group_num ) ] <NEWLINE> for i in range ( self . _n ) : <NEWLINE> <INDENT> groups [ ids [ 1 ] [ i ] ] . append ( i ) <NEWLINE> <DEDENT> return groups <NEWLINE> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> <STRING> <NEWLINE> class lazy_segtree : <NEWLINE> <INDENT> def __init__ ( self , op , e , mapping , composition , id , v : list ) : <NEWLINE> <INDENT> self . op = op ; self . e = e ; self . mapping = mapping ; self . composition = composition ; self . id = id <NEWLINE> self . _n = len ( v ) <NEWLINE> self . log = ceil_pow2 ( self . _n ) <NEWLINE> self . size = 1 << self . log <NEWLINE> self . lz = [ self . id ( ) ] * self . size <NEWLINE> self . d = [ self . e ( ) ] * ( 2 * self . size ) <NEWLINE> for i in range ( self . _n ) : self . d [ self . size + i ] = v [ i ] <NEWLINE> for i in range ( self . size - 1 , 0 , - 1 ) : self . __update ( i ) <NEWLINE> <NL> <DEDENT> def set_ ( self , p : int , x : int ) : <NEWLINE> <INDENT> assert 0 <= p and p < self . _n <NEWLINE> p += self . size <NEWLINE> for i in range ( self . log , 0 , - 1 ) : self . __push ( p >> i ) <NEWLINE> self . d [ p ] = x <NEWLINE> for i in range ( 1 , self . log + 1 ) : self . __update ( p >> 1 ) <NEWLINE> <NL> <DEDENT> def get ( self , p : int ) : <NEWLINE> <INDENT> assert 0 <= p and p < self . _n <NEWLINE> p += self . size <NEWLINE> for i in range ( self . log , 0 , - 1 ) : self . __push ( p >> i ) <NEWLINE> return self . d [ p ] <NEWLINE> <NL> <DEDENT> def prod ( self , l : int , r : int ) : <NEWLINE> <INDENT> assert 0 <= l and l <= r and r <= self . _n <NEWLINE> if l == r : return self . e ( ) <NEWLINE> l += self . size ; r += self . size <NEWLINE> <NL> for i in range ( self . log , 0 , - 1 ) : <NEWLINE> <INDENT> if ( ( l >> i ) << i ) != l : self . __push ( l >> i ) <NEWLINE> if ( ( r >> i ) << i ) != r : self . __push ( r >> i ) <NEWLINE> <NL> <DEDENT> sml , smr = self . e ( ) , self . e ( ) <NEWLINE> while l < r : <NEWLINE> <INDENT> if l & 1 : sml = self . op ( sml , self . d [ l ] ) ; l += 1 <NEWLINE> if r & 1 : r -= 1 ; smr = self . op ( self . d [ r ] , smr ) <NEWLINE> l >>= 1 ; r >>= 1 <NEWLINE> <NL> <DEDENT> return self . op ( sml , smr ) <NEWLINE> <NL> <DEDENT> def all_prod ( self ) : return self . d [ 1 ] <NEWLINE> <NL> def apply ( self , p : int , f ) : <NEWLINE> <INDENT> assert 0 <= p and p < self . _n <NEWLINE> p += self . size <NEWLINE> for i in range ( self . log , 0 , - 1 ) : self . __push ( p >> i ) <NEWLINE> self . d [ p ] = self . mapping ( f , self . d [ p ] ) <NEWLINE> for i in range ( 1 , self . log + 1 ) : self . __update ( p >> 1 ) <NEWLINE> <NL> <DEDENT> def apply ( self , l : int , r : int , f ) : <NEWLINE> <INDENT> assert 0 <= l and l <= r and r <= self . _n <NEWLINE> if l == r : return <NEWLINE> l += self . size ; r += self . size <NEWLINE> <NL> for i in range ( self . log , 0 , - 1 ) : <NEWLINE> <INDENT> if ( ( l >> i ) << i ) != l : self . __push ( l >> i ) <NEWLINE> if ( ( r >> i ) << i ) != r : self . __push ( ( r - 1 ) >> i ) <NEWLINE> <NL> <DEDENT> l2 , r2 = l , r <NEWLINE> while l < r : <NEWLINE> <INDENT> if l & 1 : self . __all_apply ( l , f ) ; l += 1 <NEWLINE> if r & 1 : r -= 1 ; self . __all_apply ( r , f ) <NEWLINE> l >>= 1 ; r >>= 1 <NEWLINE> <DEDENT> l , r = l2 , r2 <NEWLINE> <NL> for i in range ( 1 , self . log + 1 ) : <NEWLINE> <INDENT> if ( ( l >> i ) << i ) != l : self . __update ( l >> i ) <NEWLINE> if ( ( r >> i ) << i ) != r : self . __update ( r >> i ) <NEWLINE> <NL> <DEDENT> <DEDENT> def max_right ( self , l : int , g ) : <NEWLINE> <INDENT> assert 0 <= l and l <= self . _n <NEWLINE> if l == self . _n : return self . _n <NEWLINE> l += self . size <NEWLINE> for i in range ( self . log , 0 , - 1 ) : self . __push ( l >> i ) <NEWLINE> sm = self . e ( ) <NEWLINE> while True : <NEWLINE> <INDENT> while l % 2 == 0 : l >>= 1 <NEWLINE> if not g ( self . op ( sm , self . d [ l ] ) ) : <NEWLINE> <INDENT> while l < self . size : <NEWLINE> <INDENT> self . __push ( l ) <NEWLINE> l = 2 * l <NEWLINE> if g ( self . op ( sm , self . d [ l ] ) ) : <NEWLINE> <INDENT> sm = self . op ( sm , self . d [ l ] ) <NEWLINE> l += 1 <NEWLINE> <DEDENT> <DEDENT> return l - self . size <NEWLINE> <DEDENT> sm = self . op ( sm , self . d [ l ] ) <NEWLINE> l += 1 <NEWLINE> if ( l & - l ) == l : break <NEWLINE> <DEDENT> return self . _n <NEWLINE> <NL> <DEDENT> def min_left ( self , r : int , g ) : <NEWLINE> <INDENT> assert 0 <= r and r <= self . _n <NEWLINE> if r == 0 : return 0 <NEWLINE> r += self . size <NEWLINE> for i in range ( self . log , 0 , - 1 ) : self . __push ( r >> i ) <NEWLINE> sm = self . e ( ) <NEWLINE> while True : <NEWLINE> <INDENT> r -= 1 <NEWLINE> while r > 1 and r % 2 : r >>= 1 <NEWLINE> if not g ( self . op ( self . d [ r ] , sm ) ) : <NEWLINE> <INDENT> while r < self . size : <NEWLINE> <INDENT> self . __push ( r ) <NEWLINE> r = 2 * r + 1 <NEWLINE> if g ( self . op ( self . d [ r ] , sm ) ) : <NEWLINE> <INDENT> sm = self . op ( self . d [ r ] , sm ) <NEWLINE> r -= 1 <NEWLINE> <DEDENT> <DEDENT> return r + 1 - self . size <NEWLINE> <DEDENT> sm = self . op ( self . d [ r ] , sm ) <NEWLINE> if ( r & - r ) == r : break <NEWLINE> <DEDENT> return 0 <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> def __update ( self , k : int ) : self . d [ k ] = self . op ( self . d [ k * 2 ] , self . d [ k * 2 + 1 ] ) <NEWLINE> <NL> def __all_apply ( self , k : int , f ) : <NEWLINE> <INDENT> self . d [ k ] = self . mapping ( f , self . d [ k ] ) <NEWLINE> if k < self . size : self . lz [ k ] = self . composition ( f , self . lz [ k ] ) <NEWLINE> <NL> <DEDENT> def __push ( self , k : int ) : <NEWLINE> <INDENT> self . __all_apply ( 2 * k , self . lz [ k ] ) <NEWLINE> self . __all_apply ( 2 * k + 1 , self . lz [ k ] ) <NEWLINE> self . lz [ k ] = self . id ( ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> def pow_mod ( x : int , n : int , m : int ) -> int : <NEWLINE> <INDENT> assert 0 <= n and 1 <= m <NEWLINE> if m == 1 : return 0 <NEWLINE> bt = barrett ( m ) <NEWLINE> r = 1 ; y = safe_mod ( x , m ) <NEWLINE> while n : <NEWLINE> <INDENT> if n & 1 : r = bt . mul ( r , y ) <NEWLINE> y = bt . mul ( y , y ) <NEWLINE> n >>= 1 <NEWLINE> <DEDENT> return n <NEWLINE> <NL> <DEDENT> def inv_mod ( x : int , m : int ) -> int : <NEWLINE> <INDENT> assert 1 <= m <NEWLINE> z = inv_gcd ( x , m ) <NEWLINE> assert z [ 0 ] == 1 <NEWLINE> return z [ 1 ] <NEWLINE> <NL> <DEDENT> def crt ( r : list , m : list ) -> tuple : <NEWLINE> <INDENT> assert len ( r ) == len ( m ) <NEWLINE> n = len ( r ) <NEWLINE> r0 = 0 ; m0 = 1 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> assert 1 <= m [ i ] <NEWLINE> r1 = safe_mod ( r [ i ] , m [ i ] ) ; m1 = m [ i ] <NEWLINE> if m0 < m1 : <NEWLINE> <INDENT> r0 , r1 = r1 , r0 <NEWLINE> m0 , m1 = m1 , m0 <NEWLINE> <DEDENT> if m0 % m1 == 0 : <NEWLINE> <INDENT> if r0 % m1 != r1 : return ( 0 , 0 ) <NEWLINE> continue <NEWLINE> <DEDENT> g , im = inv_gcd ( m0 , m1 ) <NEWLINE> u1 = m1 // g <NEWLINE> if ( r1 - r0 ) % g : return ( 0 , 0 ) <NEWLINE> x = ( r1 - r0 ) // g % u1 * im % u1 <NEWLINE> r0 += x * m0 <NEWLINE> m0 *= u1 <NEWLINE> if r0 < 0 : r0 += m0 <NEWLINE> <DEDENT> return ( r0 , m0 ) <NEWLINE> <NL> <DEDENT> def floor_sum ( n : int , m : int , a : int , b : int ) -> int : <NEWLINE> <INDENT> ans = 0 <NEWLINE> if a >= m : <NEWLINE> <INDENT> ans += ( n - 1 ) * n * ( a // m ) // 2 <NEWLINE> a %= m <NEWLINE> <DEDENT> if b >= m : <NEWLINE> <INDENT> ans += n * ( b // m ) <NEWLINE> bb %= m <NEWLINE> <DEDENT> y_max = ( a * n + b ) // m ; x_max = ( y_max * m - b ) <NEWLINE> if y_max == 0 : return ans <NEWLINE> ans += ( n - ( x_max + a - 1 ) // a ) * y_max <NEWLINE> ans += floor_sum ( y_max , a , m , ( a - x_max % a ) % a ) <NEWLINE> return ans <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> class mf_graph : <NEWLINE> <INDENT> numeric_limits_max = 10 ** 18 <NEWLINE> def __init__ ( self , n : int ) : <NEWLINE> <INDENT> self . _n = n <NEWLINE> self . g = [ [ ] for _ in range ( self . _n ) ] <NEWLINE> self . pos = [ ] <NEWLINE> <NL> <DEDENT> def add_edge ( self , _from : int , _to : int , cap : int ) -> int : <NEWLINE> <INDENT> assert 0 <= _from and _from < self . _n <NEWLINE> assert 0 <= _to and _to < self . _n <NEWLINE> assert 0 <= cap <NEWLINE> m = len ( self . pos ) <NEWLINE> self . pos . append ( ( _from , len ( self . g [ _from ] ) ) ) <NEWLINE> self . g [ _from ] . append ( self . _edge ( _to , len ( self . g [ _to ] ) , cap ) ) <NEWLINE> self . g [ _to ] . append ( self . _edge ( _from , len ( self . g [ _from ] ) - 1 , 0 ) ) <NEWLINE> return m <NEWLINE> <NL> <DEDENT> class edge : <NEWLINE> <INDENT> def __init__ ( s , _from : int , _to : int , cap : int , flow : int ) : <NEWLINE> <INDENT> s . _from = _from ; s . _to = _to ; s . cap = cap ; s . flow = flow <NEWLINE> <NL> <DEDENT> <DEDENT> def get_edge ( self , i : int ) -> edge : <NEWLINE> <INDENT> m = len ( self . pos ) <NEWLINE> assert 0 <= i and i < m <NEWLINE> _e = self . g [ self . pos [ i ] [ 0 ] ] [ self . pos [ i ] [ 1 ] ] <NEWLINE> _re = self . g [ _e . to ] [ _e . rev ] <NEWLINE> return self . edge ( self . pos [ i ] [ 0 ] , _e . to , _e . cap + _re . cap , _re . cap ) <NEWLINE> <NL> <DEDENT> def edges ( self ) -> list : <NEWLINE> <INDENT> m = len ( self . pos ) <NEWLINE> result = [ self . get_edge ( i ) for i in range ( m ) ] <NEWLINE> return result <NEWLINE> <NL> <DEDENT> def change_edge ( self , i : int , new_cap : int , new_flow : int ) : <NEWLINE> <INDENT> m = len ( self . pos ) <NEWLINE> assert 0 <= i and i < m <NEWLINE> assert 0 <= new_flow and new_flow <= new_cap <NEWLINE> _e = self . g [ self . pos [ i ] [ 0 ] ] [ self . pos [ i ] [ 1 ] ] <NEWLINE> _re = self . g [ _e . to ] [ _e . rev ] <NEWLINE> _e . cap = new_cap - new_flow <NEWLINE> _re . cap = new_flow <NEWLINE> <NL> <DEDENT> def flow ( self , s : int , t : int ) : <NEWLINE> <INDENT> return self . flow_ ( s , t , self . numeric_limits_max ) <NEWLINE> <NL> <DEDENT> def flow_ ( self , s : int , t : int , flow_limit : int ) -> int : <NEWLINE> <INDENT> assert 0 <= s and s < self . _n <NEWLINE> assert 0 <= t and t < self . _n <NEWLINE> level = [ 0 ] * self . _n ; it = [ 0 ] * self . _n <NEWLINE> <NL> def bfs ( ) : <NEWLINE> <INDENT> for i in range ( self . _n ) : level [ i ] = - 1 <NEWLINE> level [ s ] = 0 <NEWLINE> que = deque ( [ s ] ) <NEWLINE> while que : <NEWLINE> <INDENT> v = que . popleft ( ) <NEWLINE> for e in self . g [ v ] : <NEWLINE> <INDENT> if e . cap == 0 or level [ e . to ] >= 0 : continue <NEWLINE> level [ e . to ] = level [ v ] + 1 <NEWLINE> if e . to == t : return <NEWLINE> que . append ( e . to ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> def dfs ( self_ , v : int , up : int ) -> int : <NEWLINE> <INDENT> if v == s : return up <NEWLINE> res = 0 <NEWLINE> level_v = level [ v ] <NEWLINE> for i in range ( it [ v ] , len ( self . g [ v ] ) ) : <NEWLINE> <INDENT> it [ v ] = i <NEWLINE> e = self . g [ v ] [ i ] <NEWLINE> if level_v <= level [ e . to ] or self . g [ e . to ] [ e . rev ] . cap == 0 : continue <NEWLINE> d = self_ ( self_ , e . to , min ( up - res , self . g [ e . to ] [ e . rev ] . cap ) ) <NEWLINE> if d <= 0 : continue <NEWLINE> self . g [ v ] [ i ] . cap += d <NEWLINE> self . g [ e . to ] [ e . rev ] . cap -= d <NEWLINE> res += d <NEWLINE> if res == up : break <NEWLINE> <DEDENT> return res <NEWLINE> <NL> <DEDENT> flow = 0 <NEWLINE> while flow < flow_limit : <NEWLINE> <INDENT> bfs ( ) <NEWLINE> if level [ t ] == - 1 : break <NEWLINE> for i in range ( self . _n ) : it [ i ] = 0 <NEWLINE> while flow < flow_limit : <NEWLINE> <INDENT> f = dfs ( dfs , t , flow_limit - flow ) <NEWLINE> if not f : break <NEWLINE> flow += f <NEWLINE> <DEDENT> <DEDENT> return flow <NEWLINE> <NL> <DEDENT> def min_cut ( self , s : int ) -> list : <NEWLINE> <INDENT> visited = [ False ] * self . _n <NEWLINE> que = deque ( [ s ] ) <NEWLINE> while que : <NEWLINE> <INDENT> p = que . popleft ( ) <NEWLINE> visited [ p ] = True <NEWLINE> for e in self . g [ p ] : <NEWLINE> <INDENT> if e . cap and not visited [ e . to ] : <NEWLINE> <INDENT> visited [ e . to ] = True <NEWLINE> que . append ( e . to ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return visited <NEWLINE> <NL> <DEDENT> class _edge : <NEWLINE> <INDENT> def __init__ ( s , to : int , rev : int , cap : int ) : <NEWLINE> <INDENT> s . to = to ; s . rev = rev ; s . cap = cap <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> class mcf_graph : <NEWLINE> <INDENT> numeric_limits_max = 10 ** 18 <NEWLINE> <NL> def __init__ ( self , n : int ) : <NEWLINE> <INDENT> self . _n = n <NEWLINE> self . g = [ [ ] for _ in range ( n ) ] <NEWLINE> self . pos = [ ] <NEWLINE> <NL> <DEDENT> def add_edge ( self , _from : int , _to : int , cap : int , cost : int ) -> int : <NEWLINE> <INDENT> assert 0 <= _from and _from < self . _n <NEWLINE> assert 0 <= _to and _to < self . _n <NEWLINE> m = len ( self . pos ) <NEWLINE> self . pos . append ( ( _from , len ( self . g [ _from ] ) ) ) <NEWLINE> self . g [ _from ] . append ( self . _edge ( _to , len ( self . g [ _to ] ) , cap , cost ) ) <NEWLINE> self . g [ _to ] . append ( self . _edge ( _from , len ( self . g [ _from ] ) - 1 , 0 , - cost ) ) <NEWLINE> return m <NEWLINE> <NL> <DEDENT> class edge : <NEWLINE> <INDENT> def __init__ ( s , _from : int , _to : int , cap : int , flow : int , cost : int ) : <NEWLINE> <INDENT> s . _from = _from ; s . _to = _to ; s . cap = cap ; s . flow = flow ; s . cost = cost <NEWLINE> <NL> <DEDENT> <DEDENT> def get_edge ( self , i : int ) -> edge : <NEWLINE> <INDENT> m = len ( self . pos ) <NEWLINE> assert 0 <= i and i < m <NEWLINE> _e = self . g [ self . pos [ i ] [ 0 ] ] [ self . pos [ i ] [ 1 ] ] <NEWLINE> _re = self . g [ _e . to ] [ _e . rev ] <NEWLINE> return self . edge ( self . pos [ i ] [ 0 ] , _e . to , _e . cap + _re . cap , _re . cap , _e . cost ) <NEWLINE> <NL> <DEDENT> def edges ( self ) -> list : <NEWLINE> <INDENT> m = len ( self . pos ) <NEWLINE> result = [ self . get_edge ( i ) for i in range ( m ) ] <NEWLINE> return result <NEWLINE> <NL> <DEDENT> def flow ( self , s : int , t : int ) -> edge : <NEWLINE> <INDENT> return self . flow_ ( s , t , self . numeric_limits_max ) <NEWLINE> <DEDENT> def flow_ ( self , s : int , t : int , flow_limit : int ) -> edge : <NEWLINE> <INDENT> return self . __slope ( s , t , flow_limit ) [ - 1 ] <NEWLINE> <NL> <DEDENT> def slope ( self , s : int , t : int ) -> list : <NEWLINE> <INDENT> return self . slope_ ( s , t , self . numeric_limits_max ) <NEWLINE> <DEDENT> def slope_ ( self , s : int , t : int , flow_limit : int ) -> list : <NEWLINE> <INDENT> return self . __slope ( s , t , flow_limit ) <NEWLINE> <NL> <DEDENT> def __slope ( self , s : int , t : int , flow_limit : int ) -> list : <NEWLINE> <INDENT> assert 0 <= s and s < self . _n <NEWLINE> assert 0 <= t and t < self . _n <NEWLINE> assert s != t <NEWLINE> dual = [ 0 ] * self . _n ; dist = [ 0 ] * self . _n <NEWLINE> pv , pe = [ - 1 ] * self . _n , [ - 1 ] * self . _n <NEWLINE> vis = [ False ] * self . _n <NEWLINE> <NL> def dual_ref ( ) : <NEWLINE> <INDENT> for i in range ( self . _n ) : <NEWLINE> <INDENT> dist [ i ] = self . numeric_limits_max <NEWLINE> pv [ i ] = - 1 <NEWLINE> pe [ i ] = - 1 <NEWLINE> vis [ i ] = False <NEWLINE> <DEDENT> class Q : <NEWLINE> <INDENT> def __init__ ( s , key : int , to : int ) : <NEWLINE> <INDENT> s . key = key ; s . to = to <NEWLINE> <DEDENT> def __lt__ ( s , r ) : return s . key < r . key <NEWLINE> <DEDENT> que = [ ] <NEWLINE> dist [ s ] = 0 <NEWLINE> heappush ( que , Q ( 0 , s ) ) <NEWLINE> while que : <NEWLINE> <INDENT> v = heappop ( que ) . to <NEWLINE> if vis [ v ] : continue <NEWLINE> vis [ v ] = True <NEWLINE> if v == t : break <NEWLINE> for i in range ( len ( self . g [ v ] ) ) : <NEWLINE> <INDENT> e = self . g [ v ] [ i ] <NEWLINE> if vis [ e . to ] or not e . cap : continue <NEWLINE> cost = e . cost - dual [ e . to ] + dual [ v ] <NEWLINE> if dist [ e . to ] - dist [ v ] > cost : <NEWLINE> <INDENT> dist [ e . to ] = dist [ v ] + cost <NEWLINE> pv [ e . to ] = v <NEWLINE> pe [ e . to ] = i <NEWLINE> heappush ( que , Q ( dist [ e . to ] , e . to ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if not vis [ t ] : return False <NEWLINE> for v in range ( self . _n ) : <NEWLINE> <INDENT> if not vis [ v ] : continue <NEWLINE> dual [ v ] -= dist [ t ] - dist [ v ] <NEWLINE> <DEDENT> return True <NEWLINE> <NL> <DEDENT> flow = 0 <NEWLINE> cost = 0 ; prev_cost = - 1 <NEWLINE> result = [ ] <NEWLINE> result . append ( ( flow , cost ) ) <NEWLINE> while flow < flow_limit : <NEWLINE> <INDENT> if not dual_ref ( ) : break <NEWLINE> c = flow_limit - flow <NEWLINE> v = t <NEWLINE> while v != s : <NEWLINE> <INDENT> c = min ( c , self . g [ pv [ v ] ] [ pe [ v ] ] . cap ) <NEWLINE> v = pv [ v ] <NEWLINE> <DEDENT> v = t <NEWLINE> while v != s : <NEWLINE> <INDENT> e = self . g [ pv [ v ] ] [ pe [ v ] ] <NEWLINE> e . cap -= c <NEWLINE> self . g [ v ] [ e . rev ] . cap += c <NEWLINE> v = pv [ v ] <NEWLINE> <DEDENT> d = - dual [ s ] <NEWLINE> flow += c <NEWLINE> cost += c * d <NEWLINE> if prev_cost == d : <NEWLINE> <INDENT> result . pop ( ) <NEWLINE> <DEDENT> result . append ( ( flow , cost ) ) <NEWLINE> prev_cost = cost <NEWLINE> <DEDENT> return result <NEWLINE> <DEDENT> class _edge : <NEWLINE> <INDENT> def __init__ ( s , to : int , rev : int , cap : int , cost : int ) : <NEWLINE> <INDENT> s . to = to ; s . rev = rev ; s . cap = cap ; s . cost = cost <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> class Mint : <NEWLINE> <INDENT> modint1000000007 = 1000000007 <NEWLINE> modint998244353 = 998244353 <NEWLINE> <NL> def __init__ ( self , v : int = 0 ) : <NEWLINE> <INDENT> self . m = self . modint1000000007 <NEWLINE> <COMMENT> <NL> self . x = v % self . __umod ( ) <NEWLINE> <NL> <DEDENT> def inv ( self ) : <NEWLINE> <INDENT> if is_prime_constexpr ( self . __umod ( ) ) : <NEWLINE> <INDENT> assert self . x <NEWLINE> return self . pow_ ( self . __umod ( ) - 2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> eg = inv_gcd ( self . x , self . m ) <NEWLINE> assert eg [ 0 ] == 1 <NEWLINE> return eg [ 2 ] <NEWLINE> <NL> <DEDENT> <DEDENT> def __str__ ( self ) : return str ( self . x ) <NEWLINE> def __le__ ( self , other ) : return self . x <= Mint . __get_val ( other ) <NEWLINE> def __lt__ ( self , other ) : return self . x < Mint . __get_val ( other ) <NEWLINE> def __ge__ ( self , other ) : return self . x >= Mint . __get_val ( other ) <NEWLINE> def __gt ( self , other ) : return self . x > Mint . __get_val ( other ) <NEWLINE> def __eq__ ( self , other ) : return self . x == Mint . __get_val ( other ) <NEWLINE> <NL> def __iadd__ ( self , other ) : <NEWLINE> <INDENT> self . x += Mint . __get_val ( other ) <NEWLINE> if self . x >= self . __umod ( ) : self . x -= self . __umod ( ) <NEWLINE> return self <NEWLINE> <DEDENT> def __add__ ( self , other ) : <NEWLINE> <INDENT> _v = Mint ( self . x ) ; _v += other <NEWLINE> return _v <NEWLINE> <NL> <DEDENT> def __isub__ ( self , other ) : <NEWLINE> <INDENT> self . x -= Mint . __get_val ( other ) <NEWLINE> if self . x >= self . __umod ( ) : self . x += self . __umod ( ) <NEWLINE> return self <NEWLINE> <DEDENT> def __sub__ ( self , other ) : <NEWLINE> <INDENT> _v = Mint ( self . x ) ; _v -= other <NEWLINE> return _v <NEWLINE> <DEDENT> def __rsub__ ( self , other ) : <NEWLINE> <INDENT> _v = Mint ( Mint . __get_val ( other ) ) ; _v -= self <NEWLINE> return _v <NEWLINE> <NL> <DEDENT> def __imul__ ( self , other ) : <NEWLINE> <INDENT> self . x = self . x * Mint . __get_val ( other ) % self . __umod ( ) <NEWLINE> return self <NEWLINE> <DEDENT> def __mul__ ( self , other ) : <NEWLINE> <INDENT> _v = Mint ( self . x ) ; _v *= other <NEWLINE> return _v <NEWLINE> <NL> <DEDENT> def __itruediv__ ( self , other ) : <NEWLINE> <INDENT> self . x = self . x / Mint . __get_val ( other ) % self . __umod ( ) <NEWLINE> return self <NEWLINE> <DEDENT> def __truediv__ ( self , other ) : <NEWLINE> <INDENT> _v = Mint ( self . x ) ; _v /= other <NEWLINE> return _v <NEWLINE> <DEDENT> def __rtruediv__ ( self , other ) : <NEWLINE> <INDENT> _v = Mint ( Mint . __get_val ( other ) ) ; _v /= self <NEWLINE> return _v <NEWLINE> <NL> <DEDENT> def __ifloordiv__ ( self , other ) : <NEWLINE> <INDENT> other = other if isinstance ( other , Mint ) else Mint ( other ) <NEWLINE> self *= other . inv ( ) <NEWLINE> return self <NEWLINE> <DEDENT> def __floordiv__ ( self , other ) : <NEWLINE> <INDENT> _v = Mint ( self . x ) ; _v //= other <NEWLINE> return _v <NEWLINE> <DEDENT> def __rfloordiv__ ( self , other ) : <NEWLINE> <INDENT> _v = Mint ( Mint . __get_val ( other ) ) ; _v //= self <NEWLINE> return _v <NEWLINE> <NL> <DEDENT> def __pow__ ( self , other ) : <NEWLINE> <INDENT> _v = Mint ( pow ( self . x , Mint . __get_val ( other ) , self . __umod ( ) ) ) <NEWLINE> return _v <NEWLINE> <DEDENT> def __rpow__ ( self , other ) : <NEWLINE> <INDENT> _v = Mint ( pow ( Mint . __get_val ( other ) , self . x , self . __umod ( ) ) ) <NEWLINE> return _v <NEWLINE> <NL> <DEDENT> def __imod__ ( self , other ) : <NEWLINE> <INDENT> self . x %= Mint . __get_val ( other ) <NEWLINE> return self <NEWLINE> <DEDENT> def __mod__ ( self , other ) : <NEWLINE> <INDENT> _v = Mint ( self . x ) ; _v %= other <NEWLINE> return _v <NEWLINE> <DEDENT> def __rmod__ ( self , other ) : <NEWLINE> <INDENT> _v = Mint ( Mint . __get_val ( other ) ) ; _v %= self <NEWLINE> return _v <NEWLINE> <NL> <DEDENT> def __ilshift__ ( self , other ) : <NEWLINE> <INDENT> self . x <<= Mint . __get_val ( other ) <NEWLINE> return self <NEWLINE> <DEDENT> def __irshift__ ( self , other ) : <NEWLINE> <INDENT> self . x >>= Mint . __get_val ( other ) <NEWLINE> return self <NEWLINE> <DEDENT> def __lshift__ ( self , other ) : <NEWLINE> <INDENT> _v = Mint ( self . x ) ; _v <<= other <NEWLINE> return _v <NEWLINE> <DEDENT> def __rshift__ ( self , other ) : <NEWLINE> <INDENT> _v = Mint ( self . x ) ; _v >>= other <NEWLINE> return _v <NEWLINE> <DEDENT> def __rlshift__ ( self , other ) : <NEWLINE> <INDENT> _v = Mint ( Mint . __get_val ( other ) ) ; _v <<= self <NEWLINE> return _v <NEWLINE> <DEDENT> def __rrshift__ ( self , other ) : <NEWLINE> <INDENT> _v = Mint ( Mint . __get_val ( other ) ) ; _v >>= self <NEWLINE> return _v <NEWLINE> <NL> <DEDENT> __repr__ = __str__ <NEWLINE> __radd__ = __add__ <NEWLINE> __rmul__ = __mul__ <NEWLINE> <NL> def __umod ( self ) : return self . m <NEWLINE> <NL> @ staticmethod <NEWLINE> def __get_val ( val ) : return val . x if isinstance ( val , Mint ) else val <NEWLINE> <NL> def pow_ ( self , n : int ) : <NEWLINE> <INDENT> assert 0 <= n <NEWLINE> x = Mint ( self . x ) ; r = 1 <NEWLINE> while n : <NEWLINE> <INDENT> if n & 1 : r *= x <NEWLINE> x *= x <NEWLINE> n >>= 1 <NEWLINE> <DEDENT> return r <NEWLINE> <DEDENT> def val ( self ) : return self . x <NEWLINE> def mod ( self ) : return self . m <NEWLINE> def raw ( self , v ) : <NEWLINE> <INDENT> x = Mint ( ) <NEWLINE> x . x = v <NEWLINE> return x <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> class scc_graph_sub : <NEWLINE> <COMMENT> <NL> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . internal = scc_graph ( n ) <NEWLINE> <NL> <DEDENT> def add_edge ( self , _from , _to ) : <NEWLINE> <INDENT> n = self . internal . num_vertices ( ) <NEWLINE> assert 0 <= _from and _from < n <NEWLINE> assert 0 <= _to and _to < n <NEWLINE> self . internal . add_edge ( _from , _to ) <NEWLINE> <NL> <DEDENT> def scc ( self ) : return self . internal . scc ( ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <STRING> <NEWLINE> class segtree : <NEWLINE> <INDENT> def __init__ ( self , op , e , v : list ) : <NEWLINE> <INDENT> self . _n = len ( v ) <NEWLINE> self . log = ceil_pow2 ( self . _n ) <NEWLINE> self . size = 1 << self . log <NEWLINE> self . op = op ; self . e = e <NEWLINE> self . d = [ self . e ( ) ] * ( self . size * 2 ) <NEWLINE> for i in range ( self . _n ) : self . d [ self . size + i ] = v [ i ] <NEWLINE> for i in range ( self . size - 1 , 0 , - 1 ) : self . __update ( i ) <NEWLINE> <NL> <DEDENT> def set_ ( self , p : int , x : int ) : <NEWLINE> <INDENT> assert 0 <= p and p < self . _n <NEWLINE> p += self . size <NEWLINE> self . d [ p ] = x <NEWLINE> for i in range ( 1 , self . log + 1 ) : self . __update ( p >> i ) <NEWLINE> <NL> <DEDENT> def get ( self , p : int ) : <NEWLINE> <INDENT> assert 0 <= p and p < self . _n <NEWLINE> return self . d [ p + self . size ] <NEWLINE> <NL> <DEDENT> def prod ( self , l : int , r : int ) : <NEWLINE> <INDENT> assert 0 <= l and l <= r and r <= self . _n <NEWLINE> l += self . size ; r += self . size <NEWLINE> sml , smr = self . e ( ) , self . e ( ) <NEWLINE> while l < r : <NEWLINE> <INDENT> if l & 1 : sml = self . op ( sml , self . d [ l ] ) ; l += 1 <NEWLINE> if r & 1 : r -= 1 ; smr = self . op ( self . d [ r ] , smr ) <NEWLINE> l >>= 1 ; r >>= 1 <NEWLINE> <DEDENT> return self . op ( sml , smr ) <NEWLINE> <NL> <DEDENT> def all_prod ( self ) : return self . d [ 1 ] <NEWLINE> <NL> def max_right ( self , l : int , f ) : <NEWLINE> <INDENT> assert 0 <= l and l <= self . _n <NEWLINE> assert f ( self . e ( ) ) <NEWLINE> if l == self . _n : return self . _n <NEWLINE> l += self . size <NEWLINE> sm = self . e ( ) <NEWLINE> while True : <NEWLINE> <INDENT> while l % 2 == 0 : l >>= 1 <NEWLINE> if not f ( self . op ( sm , self . d [ l ] ) ) : <NEWLINE> <INDENT> while l < self . size : <NEWLINE> <INDENT> l = 2 * l <NEWLINE> if f ( self . op ( sm , self . d [ l ] ) ) : <NEWLINE> <INDENT> sm = self . op ( sm , self . d [ l ] ) <NEWLINE> l += 1 <NEWLINE> <DEDENT> <DEDENT> return l - self . size <NEWLINE> <DEDENT> sm = self . op ( sm , self . d [ l ] ) <NEWLINE> l += 1 <NEWLINE> if ( l & - l ) == l : break <NEWLINE> <DEDENT> return self . _n <NEWLINE> <NL> <DEDENT> def min_left ( self , r : int , f ) : <NEWLINE> <INDENT> assert 0 <= r and r <= self . _n <NEWLINE> assert f ( self . e ( ) ) <NEWLINE> if r == 0 : return 0 <NEWLINE> r += self . size <NEWLINE> sm = self . e ( ) <NEWLINE> while True : <NEWLINE> <INDENT> r -= 1 <NEWLINE> while r > 1 and r % 2 : r >>= 1 <NEWLINE> if not f ( self . op ( self . d [ r ] , sm ) ) : <NEWLINE> <INDENT> while r < self . size : <NEWLINE> <INDENT> r = 2 * r + 1 <NEWLINE> if f ( self . op ( self . d [ r ] , sm ) ) : <NEWLINE> <INDENT> sm = self . op ( self . d [ r ] , sm ) <NEWLINE> r -= 1 <NEWLINE> <DEDENT> <DEDENT> return r + 1 - self . size <NEWLINE> <DEDENT> sm = self . op ( self . d [ r ] , sm ) <NEWLINE> if ( r & - r ) == r : break <NEWLINE> <DEDENT> return 0 <NEWLINE> <NL> <DEDENT> def __update ( self , k : int ) : self . d [ k ] = self . op ( self . d [ k * 2 ] , self . d [ k * 2 + 1 ] ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> def sa_native ( s : list ) : <NEWLINE> <INDENT> from functools import cmp_to_key <NEWLINE> def mycmp ( r , l ) : <NEWLINE> <INDENT> if l == r : return - 1 <NEWLINE> while l < n and r < n : <NEWLINE> <INDENT> if s [ l ] != s [ r ] : return 1 if s [ l ] < s [ r ] else - 1 <NEWLINE> l += 1 <NEWLINE> r += 1 <NEWLINE> <DEDENT> return 1 if l == n else - 1 <NEWLINE> <DEDENT> n = len ( s ) <NEWLINE> sa = [ i for i in range ( n ) ] <NEWLINE> sa . sort ( key = cmp_to_key ( mycmp ) ) <NEWLINE> return sa <NEWLINE> <NL> <DEDENT> def sa_doubling ( s : list ) : <NEWLINE> <INDENT> from functools import cmp_to_key <NEWLINE> def mycmp ( y , x ) : <NEWLINE> <INDENT> if rnk [ x ] != rnk [ y ] : return 1 if rnk [ x ] < rnk [ y ] else - 1 <NEWLINE> rx = rnk [ x + k ] if x + k < n else - 1 <NEWLINE> ry = rnk [ y + k ] if y + k < n else - 1 <NEWLINE> return 1 if rx < ry else - 1 <NEWLINE> <NL> <DEDENT> n = len ( s ) <NEWLINE> sa = [ i for i in range ( n ) ] ; rnk = s ; tmp = [ 0 ] * n ; k = 1 <NEWLINE> while k < n : <NEWLINE> <INDENT> sa . sort ( key = cmp_to_key ( mycmp ) ) <NEWLINE> tmp [ sa [ 0 ] ] = 0 <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> tmp [ sa [ i ] ] = tmp [ sa [ i - 1 ] ] <NEWLINE> if mycmp ( sa [ i ] , sa [ i - 1 ] ) : tmp [ sa [ i ] ] += 1 <NEWLINE> <DEDENT> tmp , rnk = rnk , tmp <NEWLINE> k *= 2 <NEWLINE> <DEDENT> return sa <NEWLINE> <NL> <DEDENT> def sa_is ( s : list , upper : int ) : <NEWLINE> <INDENT> THRESHOLD_NATIVE = 10 <NEWLINE> THRESHOLD_DOUBLING = 40 <NEWLINE> n = len ( s ) <NEWLINE> if n == 0 : return [ ] <NEWLINE> if n == 1 : return [ 0 ] <NEWLINE> if n == 2 : <NEWLINE> <INDENT> if s [ 0 ] < s [ 1 ] : <NEWLINE> <INDENT> return [ 0 , 1 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return [ 1 , 0 ] <NEWLINE> <DEDENT> <DEDENT> if n < THRESHOLD_NATIVE : <NEWLINE> <INDENT> return sa_native ( s ) <NEWLINE> <DEDENT> if n < THRESHOLD_DOUBLING : <NEWLINE> <INDENT> return sa_doubling ( s ) <NEWLINE> <NL> <DEDENT> sa = [ 0 ] * n <NEWLINE> ls = [ False ] * n <NEWLINE> for i in range ( n - 2 , - 1 , - 1 ) : <NEWLINE> <INDENT> ls [ i ] = ls [ i + 1 ] if s [ i ] == s [ i + 1 ] else s [ i ] < s [ i + 1 ] <NEWLINE> <NL> <DEDENT> sum_l = [ 0 ] * ( upper + 1 ) ; sum_s = [ 0 ] * ( upper + 1 ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if not ls [ i ] : <NEWLINE> <INDENT> sum_s [ s [ i ] ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> sum_l [ s [ i ] + 1 ] += 1 <NEWLINE> <DEDENT> <DEDENT> for i in range ( upper + 1 ) : <NEWLINE> <INDENT> sum_s [ i ] += sum_l [ i ] <NEWLINE> if i < upper : sum_l [ i + 1 ] += sum_s [ i ] <NEWLINE> <NL> <DEDENT> def induce ( lms : list ) : <NEWLINE> <INDENT> from copy import copy <NEWLINE> for i in range ( n ) : sa [ i ] = - 1 <NEWLINE> buf = copy ( sum_s ) <NEWLINE> for d in lms : <NEWLINE> <INDENT> if d == n : continue <NEWLINE> sa [ buf [ s [ d ] ] ] = d ; buf [ s [ d ] ] += 1 <NEWLINE> <NL> <DEDENT> buf = copy ( sum_l ) <NEWLINE> sa [ buf [ s [ n - 1 ] ] ] = n - 1 ; buf [ s [ n - 1 ] ] += 1 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> v = sa [ i ] <NEWLINE> if v >= 1 and not ls [ v - 1 ] : <NEWLINE> <INDENT> sa [ buf [ s [ v - 1 ] ] ] = v - 1 ; buf [ s [ v - 1 ] ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> buf = copy ( sum_l ) <NEWLINE> for i in range ( n - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> v = sa [ i ] <NEWLINE> if v >= 1 and ls [ v - 1 ] : <NEWLINE> <INDENT> buf [ s [ v - 1 ] + 1 ] -= 1 ; sa [ buf [ s [ v - 1 ] + 1 ] ] = v - 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> lms_map = [ - 1 ] * ( n + 1 ) <NEWLINE> m = 0 <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> if not ls [ i - 1 ] and ls [ i ] : <NEWLINE> <INDENT> lms_map [ i ] = m ; m += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> lms = [ i for i in range ( 1 , n ) if not ls [ i - 1 ] and ls [ i ] ] <NEWLINE> induce ( lms ) <NEWLINE> <NL> if m : <NEWLINE> <INDENT> sorted_lms = [ v for v in sa if lms_map [ v ] != - 1 ] <NEWLINE> rec_s = [ 0 ] * m <NEWLINE> rec_upper = 0 <NEWLINE> rec_s [ lms_map [ sorted_lms [ 0 ] ] ] = 0 <NEWLINE> for i in range ( 1 , m ) : <NEWLINE> <INDENT> l = sorted_lms [ i - 1 ] ; r = sorted_lms [ i ] <NEWLINE> end_l = lms [ lms_map [ l ] + 1 ] if lms_map [ l ] + 1 < m else n <NEWLINE> end_r = lms [ lms_map [ r ] + 1 ] if lms_map [ r ] + 1 < m else n <NEWLINE> same = True <NEWLINE> if end_l - l != end_r - r : <NEWLINE> <INDENT> same = False <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> while l < end_l : <NEWLINE> <INDENT> if s [ l ] != s [ r ] : break <NEWLINE> l += 1 <NEWLINE> r += 1 <NEWLINE> <DEDENT> if l == n or s [ l ] != s [ r ] : same = False <NEWLINE> <DEDENT> if not same : rec_upper += 1 <NEWLINE> rec_s [ lms_map [ sorted_lms [ i ] ] ] = rec_upper <NEWLINE> <NL> <DEDENT> rec_sa = sa_is ( rec_s , rec_upper ) <NEWLINE> <NL> for i in range ( m ) : <NEWLINE> <INDENT> sorted_lms [ i ] = lms [ rec_sa [ i ] ] <NEWLINE> <DEDENT> induce ( sorted_lms ) <NEWLINE> <DEDENT> return sa <NEWLINE> <NL> <DEDENT> def suffix_array ( s : list , upper : int ) : <NEWLINE> <INDENT> assert 0 <= upper <NEWLINE> for d in s : <NEWLINE> <INDENT> assert 0 <= d and d <= upper <NEWLINE> <DEDENT> sa = sa_is ( s , upper ) <NEWLINE> return sa <NEWLINE> <NL> <DEDENT> def suffix_array2 ( s : list ) : <NEWLINE> <INDENT> from functools import cmp_to_key <NEWLINE> n = len ( s ) <NEWLINE> idx = [ i for i in range ( n ) ] <NEWLINE> idx . sort ( key = cmp_to_key ( lambda l , r : s [ l ] < s [ r ] ) ) <NEWLINE> s2 = [ 0 ] * n <NEWLINE> now = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if i and s [ idx [ i - 1 ] ] != s [ idx [ i ] ] : now += 1 <NEWLINE> s2 [ idx [ i ] ] = now <NEWLINE> <DEDENT> return sa_is ( s2 , now ) <NEWLINE> <NL> <DEDENT> def suffix_array3 ( s : str ) : <NEWLINE> <INDENT> n = len ( s ) <NEWLINE> s2 = list ( map ( ord , s ) ) <NEWLINE> return sa_is ( s2 , 255 ) <NEWLINE> <NL> <DEDENT> def lcp_array ( s : list , sa : list ) : <NEWLINE> <INDENT> n = len ( s ) <NEWLINE> assert n >= 1 <NEWLINE> rnk = [ 0 ] * n <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> rnk [ sa [ i ] ] = i <NEWLINE> <DEDENT> lcp = [ 0 ] * ( n - 1 ) <NEWLINE> h = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if h > 0 : h -= 1 <NEWLINE> if rnk [ i ] == 0 : continue <NEWLINE> j = sa [ rnk [ i ] - 1 ] <NEWLINE> while j + h < n and i + h < n : <NEWLINE> <INDENT> if s [ j + h ] != s [ i + h ] : break <NEWLINE> h += 1 <NEWLINE> <DEDENT> lcp [ rnk [ i ] - 1 ] = h <NEWLINE> <DEDENT> return lcp <NEWLINE> <NL> <DEDENT> def lcp_array2 ( s : str , sa : list ) : <NEWLINE> <INDENT> n = len ( s ) <NEWLINE> s2 = list ( map ( ord , s ) ) <NEWLINE> return lcp_array ( s2 , sa ) <NEWLINE> <NL> <DEDENT> def z_algorithm ( s : list ) : <NEWLINE> <INDENT> n = len ( s ) <NEWLINE> if n == 0 : return [ ] <NEWLINE> z = [ - 1 ] * n <NEWLINE> z [ 0 ] = 0 ; j = 0 <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> k = z [ i ] = 0 if j + z [ j ] <= i else min ( j + z [ j ] - i , z [ i - j ] ) <NEWLINE> while i + k < n and s [ k ] == s [ i + k ] : k += 1 <NEWLINE> z [ i ] = k <NEWLINE> if j + z [ j ] < i + z [ i ] : j = i <NEWLINE> <DEDENT> z [ 0 ] = n <NEWLINE> return z <NEWLINE> <NL> <DEDENT> def z_algorithm2 ( s : str ) : <NEWLINE> <INDENT> n = len ( s ) <NEWLINE> s2 = list ( map ( ord , s ) ) <NEWLINE> return z_algorithm ( s2 ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> class two_sat : <NEWLINE> <INDENT> def __init__ ( self , n : int ) : <NEWLINE> <INDENT> self . _n = n <NEWLINE> self . scc = scc_graph ( 2 * n ) <NEWLINE> self . _answer = [ False ] * n <NEWLINE> <NL> <DEDENT> def add_clause ( self , i : int , f : bool , j : int , g : bool ) : <NEWLINE> <INDENT> assert 0 <= i and i < self . _n <NEWLINE> assert 0 <= j and j < self . _n <NEWLINE> self . scc . add_edge ( 2 * i + ( not f ) , 2 * j + g ) <NEWLINE> self . scc . add_edge ( 2 * j + ( not g ) , 2 * i + f ) <NEWLINE> <NL> <DEDENT> def satisfiable ( self ) -> bool : <NEWLINE> <INDENT> _id = self . scc . scc_ids ( ) [ 1 ] <NEWLINE> for i in range ( self . _n ) : <NEWLINE> <INDENT> if _id [ 2 * i ] == _id [ 2 * i + 1 ] : return False <NEWLINE> self . _answer [ i ] = _id [ 2 * i ] < _id [ 2 * i + 1 ] <NEWLINE> <DEDENT> return True <NEWLINE> <NL> <DEDENT> def answer ( self ) : return self . _answer <NEWLINE> <NL> <COMMENT> <NL> <NL> <DEDENT> import sys <NEWLINE> <NL> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> INF = 10 ** 9 <NEWLINE> PI = 3.14159265358979323846 <NEWLINE> <NL> def read_str ( ) : return sys . stdin . readline ( ) . strip ( ) <NEWLINE> def read_int ( ) : return int ( sys . stdin . readline ( ) . strip ( ) ) <NEWLINE> def read_ints ( ) : return map ( int , sys . stdin . readline ( ) . strip ( ) . split ( ) ) <NEWLINE> def read_ints2 ( x ) : return map ( lambda num : int ( num ) - x , sys . stdin . readline ( ) . strip ( ) . split ( ) ) <NEWLINE> def read_str_list ( ) : return list ( sys . stdin . readline ( ) . strip ( ) . split ( ) ) <NEWLINE> def read_int_list ( ) : return list ( map ( int , sys . stdin . readline ( ) . strip ( ) . split ( ) ) ) <NEWLINE> def GCD ( a : int , b : int ) -> int : return b if a % b == 0 else GCD ( b , a % b ) <NEWLINE> def LCM ( a : int , b : int ) -> int : return ( a * b ) // GCD ( a , b ) <NEWLINE> <NL> def Main_A ( ) : <NEWLINE> <INDENT> n , q = read_ints ( ) <NEWLINE> d = dsu ( n ) <NEWLINE> for _ in range ( q ) : <NEWLINE> <INDENT> t , u , v = read_ints ( ) <NEWLINE> if t == 0 : <NEWLINE> <INDENT> d . merge ( u , v ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( int ( d . same ( u , v ) ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> def Main_B ( ) : <NEWLINE> <INDENT> n , q = read_ints ( ) <NEWLINE> a = read_int_list ( ) <NEWLINE> fw = fenwick_tree ( n ) <NEWLINE> for i , x in enumerate ( a ) : <NEWLINE> <INDENT> fw . add ( i , x ) <NEWLINE> <DEDENT> for _ in range ( q ) : <NEWLINE> <INDENT> query = read_int_list ( ) <NEWLINE> if query [ 0 ] == 0 : <NEWLINE> <INDENT> fw . add ( query [ 1 ] , query [ 2 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( fw . sum ( query [ 1 ] , query [ 2 ] ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> def Main_C ( ) : <NEWLINE> <INDENT> for _ in range ( read_int ( ) ) : <NEWLINE> <INDENT> n , m , a , b = read_ints ( ) <NEWLINE> print ( floor_sum ( n , m , a , b ) ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> def Main_D ( ) : <NEWLINE> <INDENT> n , m = read_ints ( ) <NEWLINE> grid = [ list ( read_str ( ) ) for _ in range ( n ) ] <NEWLINE> mf = mf_graph ( n * m + 2 ) <NEWLINE> start = n * m <NEWLINE> end = start + 1 <NEWLINE> dir = [ ( 1 , 0 ) , ( 0 , 1 ) ] <NEWLINE> <NL> for y in range ( n ) : <NEWLINE> <INDENT> for x in range ( m ) : <NEWLINE> <INDENT> if ( y + x ) % 2 == 0 : <NEWLINE> <INDENT> mf . add_edge ( start , m * y + x , 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> mf . add_edge ( m * y + x , end , 1 ) <NEWLINE> <NL> <DEDENT> if grid [ y ] [ x ] == <STRING> : <NEWLINE> <INDENT> for dy , dx in dir : <NEWLINE> <INDENT> ny = y + dy ; nx = x + dx <NEWLINE> if ny < n and nx < m and grid [ ny ] [ nx ] == <STRING> : <NEWLINE> <INDENT> f , t = y * m + x , ny * m + nx <NEWLINE> if ( y + x ) % 2 : f , t = t , f <NEWLINE> mf . add_edge ( f , t , 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> ans = mf . flow ( start , end ) <NEWLINE> for y in range ( n ) : <NEWLINE> <INDENT> for x in range ( m ) : <NEWLINE> <INDENT> for e in mf . g [ y * m + x ] : <NEWLINE> <INDENT> to , rev , cap = e . to , e . rev , e . cap <NEWLINE> ny , nx = divmod ( to , m ) <NEWLINE> if ( y + x ) % 2 == 0 and cap == 0 and to != start and to != end and ( y * m + x ) != start and ( y * m + x ) != end : <NEWLINE> <INDENT> if y + 1 == ny : grid [ y ] [ x ] = <STRING> ; grid [ ny ] [ nx ] = <STRING> <NEWLINE> elif y == ny + 1 : grid [ y ] [ x ] = <STRING> ; grid [ ny ] [ nx ] = <STRING> <NEWLINE> elif x + 1 == nx : grid [ y ] [ x ] = <STRING> ; grid [ ny ] [ nx ] = <STRING> <NEWLINE> elif x == nx + 1 : grid [ y ] [ x ] = <STRING> ; grid [ ny ] [ nx ] = <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> print ( * [ <STRING> . join ( ret ) for ret in grid ] , sep = <STRING> ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> def Main_E ( ) : <NEWLINE> <INDENT> n , k = read_ints ( ) <NEWLINE> a = [ read_int_list ( ) for _ in range ( n ) ] <NEWLINE> mcf = mcf_graph ( n * 2 + 2 ) <NEWLINE> s = n * 2 <NEWLINE> t = n * 2 + 1 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> mcf . add_edge ( s , i , k , 0 ) <NEWLINE> mcf . add_edge ( i + n , t , k , 0 ) <NEWLINE> <DEDENT> mcf . add_edge ( s , t , n * k , INF ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( n ) : <NEWLINE> <INDENT> mcf . add_edge ( i , n + j , 1 , INF - a [ i ] [ j ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> result = mcf . flow_ ( s , t , n * k ) <NEWLINE> print ( n * k * INF - result [ 1 ] ) <NEWLINE> grid = [ [ <STRING> ] * n for _ in range ( n ) ] <NEWLINE> edges = mcf . edges ( ) <NEWLINE> for e in edges : <NEWLINE> <INDENT> if e . _from == s or e . _to == t or e . flow == 0 : continue <NEWLINE> grid [ e . _from ] [ e . _to - n ] = <STRING> <NEWLINE> <DEDENT> print ( * [ <STRING> . join ( g ) for g in grid ] , sep = <STRING> ) <NEWLINE> <NL> <DEDENT> def Main_F ( ) : <NEWLINE> <INDENT> MOD = 998244353 <NEWLINE> n , m = read_ints ( ) <NEWLINE> a = read_int_list ( ) <NEWLINE> b = read_int_list ( ) <NEWLINE> a = [ x % MOD for x in a ] <NEWLINE> b = [ x % MOD for x in b ] <NEWLINE> cnv = convolution ( a , b , MOD ) <NEWLINE> ans = cnv . convolution ( ) <NEWLINE> print ( * ans ) <NEWLINE> <NL> <DEDENT> def Main_G ( ) : <NEWLINE> <INDENT> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> n , m = read_ints ( ) <NEWLINE> scc = scc_graph ( n ) <NEWLINE> for _ in range ( m ) : <NEWLINE> <INDENT> a , b = read_ints ( ) <NEWLINE> scc . add_edge ( a , b ) <NEWLINE> <DEDENT> ans = scc . scc ( ) <NEWLINE> print ( len ( ans ) ) <NEWLINE> for v in ans : <NEWLINE> <INDENT> print ( len ( v ) , <STRING> . join ( map ( str , v [ : : - 1 ] ) ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> def Main_H ( ) : <NEWLINE> <INDENT> n , d = read_ints ( ) <NEWLINE> xy = [ read_int_list ( ) for _ in range ( n ) ] <NEWLINE> tw = two_sat ( n ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n ) : <NEWLINE> <INDENT> for x in range ( 2 ) : <NEWLINE> <INDENT> if abs ( xy [ i ] [ 0 ] - xy [ j ] [ 0 ] ) < d : tw . add_clause ( i , False , j , False ) <NEWLINE> if abs ( xy [ i ] [ 0 ] - xy [ j ] [ 1 ] ) < d : tw . add_clause ( i , False , j , True ) <NEWLINE> if abs ( xy [ i ] [ 1 ] - xy [ j ] [ 0 ] ) < d : tw . add_clause ( i , True , j , False ) <NEWLINE> if abs ( xy [ i ] [ 1 ] - xy [ j ] [ 1 ] ) < d : tw . add_clause ( i , True , j , True ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if not tw . satisfiable ( ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> ans = tw . answer ( ) <NEWLINE> for i , flag in enumerate ( ans ) : <NEWLINE> <INDENT> print ( xy [ i ] [ 0 ] if flag else xy [ i ] [ 1 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> def Main_I ( ) : <NEWLINE> <INDENT> s = read_str ( ) <NEWLINE> sa = suffix_array3 ( s ) <NEWLINE> ans = len ( s ) * ( len ( s ) + 1 ) // 2 <NEWLINE> for x in lcp_array2 ( s , sa ) : <NEWLINE> <INDENT> ans -= x <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> def Main_J ( ) : <NEWLINE> <INDENT> def op ( l , r ) : return max ( l , r ) <NEWLINE> def e ( ) : return - 1 <NEWLINE> def f ( n ) : return n < r <NEWLINE> n , q = read_ints ( ) <NEWLINE> a = read_int_list ( ) <NEWLINE> seg = segtree ( op , e , a ) <NEWLINE> query = [ ( read_ints ( ) ) for _ in range ( q ) ] <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> t , l , r = query [ i ] <NEWLINE> if t == 1 : <NEWLINE> <INDENT> seg . set_ ( ~ - l , r ) <NEWLINE> <DEDENT> elif t == 2 : <NEWLINE> <INDENT> print ( seg . prod ( ~ - l , r ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( seg . max_right ( ~ - l , f ) + 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> def Main_K ( ) : <NEWLINE> <INDENT> p = 998244353 <NEWLINE> def op ( l , r ) : <NEWLINE> <INDENT> l1 , l2 = l >> 32 , l % ( 1 << 32 ) <NEWLINE> r1 , r2 = r >> 32 , r % ( 1 << 32 ) <NEWLINE> return ( ( ( l1 + r1 ) % p ) << 32 ) + l2 + r2 <NEWLINE> <DEDENT> def e ( ) : return 0 <NEWLINE> def mapping ( l , r ) : <NEWLINE> <INDENT> l1 , l2 = l >> 32 , l % ( 1 << 32 ) <NEWLINE> r1 , r2 = r >> 32 , r % ( 1 << 32 ) <NEWLINE> return ( ( ( l1 * r1 + l2 * r2 ) % p ) << 32 ) + r2 <NEWLINE> <DEDENT> def composition ( l , r ) : <NEWLINE> <INDENT> l1 , l2 = l >> 32 , l % ( 1 << 32 ) <NEWLINE> r1 , r2 = r >> 32 , r % ( 1 << 32 ) <NEWLINE> return ( ( l1 * r1 % p ) << 32 ) + ( l1 * r2 + l2 ) % p <NEWLINE> <DEDENT> def id ( ) : return 1 << 32 <NEWLINE> n , q = read_ints ( ) <NEWLINE> A = read_int_list ( ) <NEWLINE> A = [ ( x << 32 ) + 1 for x in A ] <NEWLINE> <NL> seg = lazy_segtree ( op , e , mapping , composition , id , A ) <NEWLINE> ans = [ ] <NEWLINE> for _ in range ( q ) : <NEWLINE> <INDENT> query = read_int_list ( ) <NEWLINE> if query [ 0 ] == 0 : <NEWLINE> <INDENT> l , r , b , c = query [ 1 : ] <NEWLINE> seg . apply ( l , r , ( b << 32 ) + c ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> l , r = query [ 1 : ] <NEWLINE> print ( seg . prod ( l , r ) >> 32 ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> def Main_L ( ) : <NEWLINE> <INDENT> def op ( l : tuple , r : tuple ) : return ( l [ 0 ] + r [ 0 ] , l [ 1 ] + r [ 1 ] , l [ 2 ] + r [ 2 ] + l [ 1 ] * r [ 0 ] ) <NEWLINE> def e ( ) : return ( 0 , 0 , 0 ) <NEWLINE> def mapping ( l : bool , r : tuple ) : <NEWLINE> <INDENT> if not l : return r <NEWLINE> return ( r [ 1 ] , r [ 0 ] , r [ 1 ] * r [ 0 ] - r [ 2 ] ) <NEWLINE> <DEDENT> def composition ( l : bool , r : bool ) : return l ^ r <NEWLINE> def id ( ) : return False <NEWLINE> n , q = read_ints ( ) <NEWLINE> A = read_int_list ( ) <NEWLINE> query = [ ( read_ints ( ) ) for _ in range ( q ) ] <NEWLINE> <NL> a = [ ( 1 , 0 , 0 ) if i == 0 else ( 0 , 1 , 0 ) for i in A ] <NEWLINE> seg = lazy_segtree ( op , e , mapping , composition , id , a ) <NEWLINE> <NL> for t , l , r in query : <NEWLINE> <INDENT> if t == 1 : <NEWLINE> <INDENT> seg . apply ( ~ - l , r , True ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( seg . prod ( ~ - l , r ) [ 2 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> Main_D ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <NL> code_mf_graph = <STRING> <NEWLINE> code_mf_graph_setup = <STRING> <NEWLINE> <NL> import os <NEWLINE> import sys <NEWLINE> <NL> if sys . argv [ - 1 ] == <STRING> or os . getcwd ( ) != <STRING> : <NEWLINE> <INDENT> with open ( <STRING> , <STRING> ) as f : <NEWLINE> <INDENT> f . write ( code_mf_graph ) <NEWLINE> <DEDENT> with open ( <STRING> , <STRING> ) as f : <NEWLINE> <INDENT> f . write ( code_mf_graph_setup ) <NEWLINE> <DEDENT> os . system ( <STRING> ) <NEWLINE> <NL> <DEDENT> from atcoder import MFGraph , MFGraphEdge <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> grid = [ list ( input ( ) ) for _ in range ( N ) ] <NEWLINE> g = MFGraph ( N * M + 2 ) <NEWLINE> s = N * M <NEWLINE> t = N * M + 1 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> for j in range ( M ) : <NEWLINE> <INDENT> if grid [ i ] [ j ] == <STRING> : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> v = i * M + j <NEWLINE> if ( i + j ) % 2 == 0 : <NEWLINE> <INDENT> g . add_edge ( s , v , 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> g . add_edge ( v , t , 1 ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> for j in range ( M ) : <NEWLINE> <INDENT> if ( i + j ) % 2 or grid [ i ] [ j ] == <STRING> : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> v0 = i * M + j <NEWLINE> if i and grid [ i - 1 ] [ j ] == <STRING> : <NEWLINE> <INDENT> g . add_edge ( v0 , v0 - M , 1 ) <NEWLINE> <DEDENT> if j and grid [ i ] [ j - 1 ] == <STRING> : <NEWLINE> <INDENT> g . add_edge ( v0 , v0 - 1 , 1 ) <NEWLINE> <DEDENT> if i + 1 < N and grid [ i + 1 ] [ j ] == <STRING> : <NEWLINE> <INDENT> g . add_edge ( v0 , v0 + M , 1 ) <NEWLINE> <DEDENT> if j + 1 < M and grid [ i ] [ j + 1 ] == <STRING> : <NEWLINE> <INDENT> g . add_edge ( v0 , v0 + 1 , 1 ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( g . flow ( s , t ) ) <NEWLINE> edges = g . edges ( ) <NEWLINE> for e in edges : <NEWLINE> <INDENT> if e . from_ == s or e . to == t or e . flow == 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> i0 , j0 = divmod ( e . from_ , M ) <NEWLINE> i1 , j1 = divmod ( e . to , M ) <NEWLINE> if i0 == i1 + 1 : <NEWLINE> <INDENT> grid [ i1 ] [ j1 ] = <STRING> <NEWLINE> grid [ i0 ] [ j0 ] = <STRING> <NEWLINE> <DEDENT> elif j0 == j1 + 1 : <NEWLINE> <INDENT> grid [ i1 ] [ j1 ] = <STRING> <NEWLINE> grid [ i0 ] [ j0 ] = <STRING> <NEWLINE> <DEDENT> elif i0 == i1 - 1 : <NEWLINE> <INDENT> grid [ i0 ] [ j0 ] = <STRING> <NEWLINE> grid [ i1 ] [ j1 ] = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> grid [ i0 ] [ j0 ] = <STRING> <NEWLINE> grid [ i1 ] [ j1 ] = <STRING> <NEWLINE> <DEDENT> <DEDENT> for gr in grid : <NEWLINE> <INDENT> print ( <STRING> . join ( gr ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> main ( ) <NEWLINE>
code = <STRING> <NEWLINE> <NL> import os <NEWLINE> try : <NEWLINE> <INDENT> from atcoder import * <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> open ( <STRING> , <STRING> ) . write ( code ) <NEWLINE> os . system ( <STRING> ) <NEWLINE> <NL> <DEDENT> H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> S = [ input ( ) for i in range ( H ) ] <NEWLINE> mf = mf_graph_ ( H * W + 2 ) <NEWLINE> s , t = H * W , H * W + 1 <NEWLINE> for i in range ( H ) : <NEWLINE> <INDENT> for j in range ( W ) : <NEWLINE> <INDENT> if S [ i ] [ j ] == <STRING> : continue <NEWLINE> v = i * W + j <NEWLINE> if ( i + j ) % 2 : mf . add_edge ( s , v , 1 ) <NEWLINE> else : mf . add_edge ( v , t , 1 ) ; continue <NEWLINE> if j < W - 1 and S [ i ] [ j + 1 ] == <STRING> : <NEWLINE> <INDENT> mf . add_edge ( v , v + 1 , 1 ) <NEWLINE> <DEDENT> if 0 < j and S [ i ] [ j - 1 ] == <STRING> : <NEWLINE> <INDENT> mf . add_edge ( v , v - 1 , 1 ) <NEWLINE> <DEDENT> if i < H - 1 and S [ i + 1 ] [ j ] == <STRING> : <NEWLINE> <INDENT> mf . add_edge ( v , v + H , 1 ) <NEWLINE> <DEDENT> if 0 < i and S [ i - 1 ] [ j ] == <STRING> : <NEWLINE> <INDENT> mf . add_edge ( v , v - H , 1 ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( mf . flow ( s , t ) ) <NEWLINE> r = [ [ c for c in S [ i ] ] for i in range ( H ) ] <NEWLINE> for frm , to , _ , flow in mf . edges ( ) : <NEWLINE> <INDENT> if flow == 1 and frm < H * W and to < H * W : <NEWLINE> <INDENT> i , j = frm // W , frm % W <NEWLINE> k , l = to // W , to % W <NEWLINE> if frm - to == 1 : <NEWLINE> <INDENT> r [ i ] [ j ] , r [ k ] [ l ] = <STRING> , <STRING> <NEWLINE> <DEDENT> elif to - frm == 1 : <NEWLINE> <INDENT> r [ i ] [ j ] , r [ k ] [ l ] = <STRING> , <STRING> <NEWLINE> <DEDENT> elif frm - to == H : <NEWLINE> <INDENT> r [ i ] [ j ] , r [ k ] [ l ] = <STRING> , <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> r [ i ] [ j ] , r [ k ] [ l ] = <STRING> , <STRING> <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( * [ <STRING> . join ( l ) for l in r ] , sep = <STRING> ) <NEWLINE>
<COMMENT> <NL> <NL> import sys <NEWLINE> <NL> from atcoder . mincostflow import MCFGraph <NEWLINE> <NL> <NL> def main ( ) -> None : <NEWLINE> <INDENT> n , k = map ( int , sys . stdin . readline ( ) . split ( ) ) <NEWLINE> s = n * 2 <NEWLINE> t = s + 1 <NEWLINE> g = MCFGraph ( t + 1 ) <NEWLINE> grid = [ list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) for _ in range ( n ) ] <NEWLINE> big = 10 ** 9 <NEWLINE> edges = list ( [ ] for _ in range ( n ) ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> g . add_edge ( s , i , k , 0 ) <NEWLINE> g . add_edge ( i + n , t , k , 0 ) <NEWLINE> for j in range ( n ) : <NEWLINE> <INDENT> edges [ i ] . append ( g . add_edge ( i , j + n , 1 , big - grid [ i ] [ j ] ) ) <NEWLINE> <DEDENT> <DEDENT> g . add_edge ( s , t , n * k , big ) <NEWLINE> <NL> cost = g . flow ( s , t , n * k ) [ 1 ] <NEWLINE> print ( big * n * k - cost ) <NEWLINE> <NL> result = list ( [ <STRING> ] * n for _ in range ( n ) ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( n ) : <NEWLINE> <INDENT> if g . get_edge ( edges [ i ] [ j ] ) . flow > 0 : <NEWLINE> <INDENT> result [ i ] [ j ] = <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for s in result : <NEWLINE> <INDENT> print ( <STRING> . join ( s ) ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> input = sys . stdin . readline ( ) <NEWLINE> sys . setrecursionlimit ( 1000000 ) <NEWLINE> <NL> class SCC : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . n = n <NEWLINE> self . graph = [ [ ] for _ in range ( n ) ] <NEWLINE> self . graph_rev = [ [ ] for _ in range ( n ) ] <NEWLINE> self . already = [ False ] * n <NEWLINE> <NL> <DEDENT> def add_edge ( self , fr , to ) : <NEWLINE> <INDENT> if fr == to : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> self . graph [ fr ] . append ( to ) <NEWLINE> self . graph_rev [ to ] . append ( fr ) <NEWLINE> <NL> <DEDENT> def dfs ( self , node , graph ) : <NEWLINE> <INDENT> self . already [ node ] = True <NEWLINE> for n in graph [ node ] : <NEWLINE> <INDENT> if self . already [ n ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> self . dfs ( n , graph ) <NEWLINE> <DEDENT> self . order . append ( node ) <NEWLINE> <NL> <DEDENT> def first_dfs ( self ) : <NEWLINE> <INDENT> self . already = [ False ] * self . n <NEWLINE> self . order = [ ] <NEWLINE> for i in range ( self . n ) : <NEWLINE> <INDENT> if self . already [ i ] == False : <NEWLINE> <INDENT> self . dfs ( i , self . graph ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> def second_dfs ( self ) : <NEWLINE> <INDENT> self . already = [ False ] * self . n <NEWLINE> self . ans = [ ] <NEWLINE> for n in reversed ( self . order ) : <NEWLINE> <INDENT> if self . already [ n ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> self . already [ n ] = True <NEWLINE> self . order = [ ] <NEWLINE> self . dfs ( n , self . graph_rev ) <NEWLINE> self . order . reverse ( ) <NEWLINE> self . ans . append ( self . order ) <NEWLINE> <NL> <DEDENT> <DEDENT> def scc ( self ) : <NEWLINE> <INDENT> self . first_dfs ( ) <NEWLINE> self . second_dfs ( ) <NEWLINE> return self . ans <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <INDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> scc = SCC ( n ) <NEWLINE> <NL> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> scc . add_edge ( a , b ) <NEWLINE> <NL> <DEDENT> scc_list = scc . scc ( ) <NEWLINE> <NL> print ( len ( scc_list ) ) <NEWLINE> for s in scc_list : <NEWLINE> <INDENT> print ( len ( s ) , end = <STRING> ) <NEWLINE> print ( * s ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
<NL> import networkx as nx <NEWLINE> <NL> import io <NEWLINE> import os <NEWLINE> <NL> <NL> input = io . BytesIO ( os . read ( 0 , os . fstat ( 0 ) . st_size ) ) . readline <NEWLINE> N , D = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> XY = [ [ int ( x ) for x in input ( ) . split ( ) ] for i in range ( N ) ] <NEWLINE> <NL> <NL> graph = nx . DiGraph ( ) <NEWLINE> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> for i , ( x1 , y1 ) in enumerate ( XY ) : <NEWLINE> <INDENT> for j in range ( N ) : <NEWLINE> <INDENT> if i != j : <NEWLINE> <INDENT> x2 , y2 = XY [ j ] <NEWLINE> if abs ( x1 - x2 ) < D : <NEWLINE> <COMMENT> <NL> <INDENT> graph . add_edge ( i , j + N ) <NEWLINE> <DEDENT> if abs ( x1 - y2 ) < D : <NEWLINE> <COMMENT> <NL> <INDENT> graph . add_edge ( i , j ) <NEWLINE> <DEDENT> if abs ( y1 - x2 ) < D : <NEWLINE> <COMMENT> <NL> <INDENT> graph . add_edge ( i + N , j + N ) <NEWLINE> <DEDENT> if abs ( y1 - y2 ) < D : <NEWLINE> <COMMENT> <NL> <INDENT> graph . add_edge ( i + N , j ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> SCC = nx . algorithms . components . strongly_connected_components ( graph ) <NEWLINE> assignment = { } <NEWLINE> for comp in SCC : <NEWLINE> <INDENT> for x in comp : <NEWLINE> <INDENT> if ( x < N and x + N in comp ) or ( x >= N and x - N in comp ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> if x not in assignment : <NEWLINE> <INDENT> assignment [ x ] = True <NEWLINE> assignment [ ( x + N ) % ( 2 * N ) ] = False <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> print ( XY [ i ] [ 0 ] if assignment [ i ] else XY [ i ] [ 1 ] ) <NEWLINE> <DEDENT>
<NL> code = <STRING> <NEWLINE> <NL> <NL> import os , sys , getpass <NEWLINE> <NL> if sys . argv [ - 1 ] == <STRING> : <NEWLINE> <INDENT> code = code . replace ( <STRING> , getpass . getuser ( ) ) <NEWLINE> open ( <STRING> , <STRING> ) . write ( code ) <NEWLINE> os . system ( <STRING> ) <NEWLINE> sys . exit ( 0 ) <NEWLINE> <NL> <NL> <DEDENT> from atcoder import Read , SuffixArray , LcpArray <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> S = Read ( 1 ) [ 0 ] <NEWLINE> sa = SuffixArray ( S ) <NEWLINE> ans = ( len ( S ) * ( len ( S ) + 1 ) ) // 2 <NEWLINE> for x in LcpArray ( S , sa ) : <NEWLINE> <INDENT> ans -= x <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
header_code = <STRING> <NEWLINE> <NL> code = <STRING> <NEWLINE> <NL> <NL> import os , sys , getpass <NEWLINE> <NL> if sys . argv [ - 1 ] == <STRING> : <NEWLINE> <INDENT> code = code . replace ( <STRING> , getpass . getuser ( ) ) <NEWLINE> open ( <STRING> , <STRING> ) . write ( header_code ) <NEWLINE> open ( <STRING> , <STRING> ) . write ( code ) <NEWLINE> os . system ( <STRING> ) <NEWLINE> sys . exit ( 0 ) <NEWLINE> <NL> <NL> <DEDENT> from atcoder import ReadInt , SegTree , PrintLongN <NEWLINE> <NL> N , Q = ReadInt ( 2 ) <NEWLINE> ST = SegTree ( ReadInt ( N ) , <STRING> ) <NEWLINE> <NL> ans = [ ] <NEWLINE> for i in range ( Q ) : <NEWLINE> <INDENT> T = ReadInt ( 1 ) [ 0 ] <NEWLINE> if T == 1 : <NEWLINE> <INDENT> X , V = ReadInt ( 2 ) <NEWLINE> X -= 1 <NEWLINE> ST . set ( X , V ) <NEWLINE> <DEDENT> elif T == 2 : <NEWLINE> <INDENT> L , R = ReadInt ( 2 ) <NEWLINE> ans . append ( ST . prod ( L - 1 , R ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> X , V = ReadInt ( 2 ) <NEWLINE> X -= 1 <NEWLINE> ans . append ( ST . max_right ( X , V ) + 1 ) <NEWLINE> <DEDENT> <DEDENT> PrintLongN ( ans , len ( ans ) ) <NEWLINE>
from typing import Callable , List , Union <NEWLINE> <NL> T = Union [ int , str ] <NEWLINE> <NL> <NL> class SegmentTree : <NEWLINE> <INDENT> <STRING> <NEWLINE> <NL> __slots__ = [ <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> <NL> def __init__ ( self , v : List [ T ] , op : Callable [ [ T , T ] , T ] , e : T ) -> None : <NEWLINE> <INDENT> self . _n = len ( v ) <NEWLINE> self . _log = ( self . _n - 1 ) . bit_length ( ) <NEWLINE> self . _size = 1 << self . _log <NEWLINE> self . op = op <NEWLINE> self . e = e <NEWLINE> <NL> self . tree = [ e ] * 2 * self . _size <NEWLINE> for i , a in enumerate ( v , 1 ) : <NEWLINE> <INDENT> self . tree [ i ] = a <NEWLINE> <DEDENT> for i in range ( self . _size - 1 , 0 , - 1 ) : <NEWLINE> <INDENT> self . _update ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> def _update ( self , i : int ) -> None : <NEWLINE> <INDENT> self . tree = self . op ( self . tree [ 2 * i ] , self . tree [ 2 * i + 1 ] ) <NEWLINE> <NL> <DEDENT> def set ( self , p : int , x : T ) -> None : <NEWLINE> <INDENT> assert 0 <= p < self . _n <NEWLINE> <NL> p += self . _size <NEWLINE> self . tree [ p ] = x <NEWLINE> for i in range ( 1 , self . _log + 1 ) : <NEWLINE> <INDENT> self . _update ( p >> i ) <NEWLINE> <NL> <DEDENT> <DEDENT> def prod ( self , l : int , r : int ) -> T : <NEWLINE> <INDENT> assert 0 <= l <= r <= self . _n <NEWLINE> <NL> sml , smr = self . e , self . e <NEWLINE> l += self . _size <NEWLINE> r += self . _size <NEWLINE> <NL> while l < r : <NEWLINE> <INDENT> if l & 1 : <NEWLINE> <INDENT> sml = self . op ( sml , self . tree [ l ] ) <NEWLINE> l += 1 <NEWLINE> <DEDENT> if r & 1 : <NEWLINE> <INDENT> r -= 1 <NEWLINE> smr = self . op ( self . tree [ r ] , smr ) <NEWLINE> <DEDENT> l >>= 1 <NEWLINE> r >>= 1 <NEWLINE> <DEDENT> return self . op ( sml , smr ) <NEWLINE> <NL> <DEDENT> @ property <NEWLINE> def all_prod ( self ) -> T : <NEWLINE> <INDENT> return self . tree [ 1 ] <NEWLINE> <NL> <DEDENT> def max_right ( self , l : int , f : Callable [ [ T ] , bool ] ) -> int : <NEWLINE> <INDENT> assert 0 <= l <= self . _n <NEWLINE> assert f ( self . e ) <NEWLINE> <NL> if l == self . _n : <NEWLINE> <INDENT> return self . _n <NEWLINE> <NL> <DEDENT> l += self . _size <NEWLINE> sm = self . e <NEWLINE> <NL> while True : <NEWLINE> <INDENT> while not l & 1 : <NEWLINE> <INDENT> l >>= 1 <NEWLINE> <NL> <DEDENT> if not f ( self . op ( sm , self . tree [ l ] ) ) : <NEWLINE> <INDENT> while l < self . _size : <NEWLINE> <INDENT> l *= 2 <NEWLINE> if f ( self . op ( sm , self . tree [ l ] ) ) : <NEWLINE> <INDENT> sm = self . op ( sm , self . tree [ l ] ) <NEWLINE> l += 1 <NEWLINE> <DEDENT> <DEDENT> return l - self . _size <NEWLINE> <NL> <DEDENT> sm = self . op ( sm , self . tree [ l ] ) <NEWLINE> l += 1 <NEWLINE> <NL> if ( l & - l ) == l : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> return self . _n <NEWLINE> <NL> <DEDENT> def min_left ( self , r : int , f : Callable [ [ T ] , bool ] ) -> int : <NEWLINE> <INDENT> assert 0 <= r <= self . _n <NEWLINE> assert f ( self . e ) <NEWLINE> <NL> if not r : <NEWLINE> <INDENT> return 0 <NEWLINE> <NL> <DEDENT> r += self . _size <NEWLINE> sm = self . e <NEWLINE> <NL> while True : <NEWLINE> <INDENT> r -= 1 <NEWLINE> while r > 1 and r % 2 : <NEWLINE> <INDENT> r >>= 1 <NEWLINE> <NL> <DEDENT> if not f ( self . op ( self . tree [ r ] , sm ) ) : <NEWLINE> <INDENT> while r < self . _size : <NEWLINE> <INDENT> r = 2 * r + 1 <NEWLINE> if f ( self . op ( self . tree [ r ] , sm ) ) : <NEWLINE> <INDENT> sm = self . op ( self . tree [ r ] , sm ) <NEWLINE> r -= 1 <NEWLINE> <DEDENT> <DEDENT> return r + 1 - self . _size <NEWLINE> <NL> <DEDENT> if ( r & - r ) == r : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> return 0 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def practice2_j ( ) : <NEWLINE> <INDENT> N , _ , * AQ = map ( int , open ( 0 ) . read ( ) . split ( ) ) <NEWLINE> A , Q = ( <NEWLINE> <INDENT> AQ [ : N ] , <NEWLINE> AQ [ N : ] , <NEWLINE> <DEDENT> ) <NEWLINE> tree = SegmentTree ( A , max , - 1 ) <NEWLINE> res = [ ] <NEWLINE> for t , x , y in zip ( * [ iter ( Q ) ] * 3 ) : <NEWLINE> <INDENT> if t == 1 : <NEWLINE> <INDENT> tree . set ( x , y ) <NEWLINE> <DEDENT> elif t == 2 : <NEWLINE> <INDENT> res . append ( tree . prod ( x - 1 , y ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> res . append ( tree . max_right ( x - 1 , lambda n : n < y ) + 1 ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> . join ( map ( str , res ) ) ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> practice2_j ( ) <NEWLINE> <DEDENT>
import types <NEWLINE> <NL> _atcoder_code = <STRING> <NEWLINE> <NL> atcoder = types . ModuleType ( <STRING> ) <NEWLINE> exec ( _atcoder_code , atcoder . __dict__ ) <NEWLINE> <NL> _atcoder__bit_code = <STRING> <NEWLINE> <NL> atcoder . _bit = types . ModuleType ( <STRING> ) <NEWLINE> exec ( _atcoder__bit_code , atcoder . _bit . __dict__ ) <NEWLINE> <NL> <NL> _atcoder_segtree_code = <STRING> <NEWLINE> <NL> atcoder . segtree = types . ModuleType ( <STRING> ) <NEWLINE> exec ( _atcoder_segtree_code , atcoder . segtree . __dict__ ) <NEWLINE> atcoder . segtree . __dict__ [ <STRING> ] = atcoder <NEWLINE> atcoder . segtree . __dict__ [ <STRING> ] = atcoder . _bit <NEWLINE> SegTree = atcoder . segtree . SegTree <NEWLINE> <NL> <COMMENT> <NL> <NL> import sys <NEWLINE> <NL> <COMMENT> <NL> <NL> <NL> def main ( seed ) -> None : <NEWLINE> <INDENT> n , q = map ( int , sys . stdin . readline ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) <NEWLINE> <NL> segtree = SegTree ( max , - 1 , a ) <NEWLINE> <NL> for _ in range ( q ) : <NEWLINE> <INDENT> t , x , y = map ( int , sys . stdin . readline ( ) . split ( ) ) <NEWLINE> if t == 1 : <NEWLINE> <INDENT> segtree . set ( x - 1 , y ) <NEWLINE> <DEDENT> elif t == 2 : <NEWLINE> <INDENT> print ( segtree . prod ( x - 1 , y ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( segtree . max_right ( x - 1 , lambda v : v < y ) + 1 ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> for i in range ( 100000 ) : <NEWLINE> <INDENT> main ( i ) <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <NL> code_segtree = <STRING> <NEWLINE> code_setup = <STRING> <NEWLINE> <NL> import os <NEWLINE> import sys <NEWLINE> if sys . argv [ - 1 ] == <STRING> or os . getcwd ( ) != <STRING> : <NEWLINE> <INDENT> with open ( <STRING> , <STRING> ) as f : <NEWLINE> <INDENT> f . write ( code_segtree ) <NEWLINE> <DEDENT> with open ( <STRING> , <STRING> ) as f : <NEWLINE> <INDENT> f . write ( code_setup ) <NEWLINE> <DEDENT> os . system ( <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> from atcoder import SegTree <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> input = sys . stdin . buffer . readline <NEWLINE> N , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> A = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> op = lambda a , b : a if a > b else b <NEWLINE> e = - 1 <NEWLINE> seg = SegTree ( op , e , A ) <NEWLINE> <NL> Ans = [ ] <NEWLINE> m = map ( int , sys . stdin . buffer . read ( ) . split ( ) ) <NEWLINE> for t , x , v in zip ( m , m , m ) : <NEWLINE> <INDENT> x -= 1 <NEWLINE> if t == 1 : <NEWLINE> <INDENT> seg . set ( x , v ) <NEWLINE> <DEDENT> elif t == 2 : <NEWLINE> <INDENT> ans = seg . prod ( x , v ) <NEWLINE> Ans . append ( ans ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = seg . max_right ( x , lambda a : a < v ) + 1 <NEWLINE> Ans . append ( ans ) <NEWLINE> <DEDENT> <DEDENT> if Ans : <NEWLINE> <INDENT> print ( <STRING> . join ( map ( str , Ans ) ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> main ( ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> code_lazy_segtree = <STRING> <NEWLINE> code_setup = <STRING> <NEWLINE> <NL> import os <NEWLINE> import sys <NEWLINE> <NL> if sys . argv [ - 1 ] == <STRING> or os . getcwd ( ) != <STRING> : <NEWLINE> <INDENT> with open ( <STRING> , <STRING> ) as f : <NEWLINE> <INDENT> f . write ( code_lazy_segtree ) <NEWLINE> <DEDENT> with open ( <STRING> , <STRING> ) as f : <NEWLINE> <INDENT> f . write ( code_setup ) <NEWLINE> <DEDENT> os . system ( <STRING> ) <NEWLINE> <NL> <DEDENT> from atcoder import LazySegTree <NEWLINE> <NL> <NL> code_fastio = <STRING> <NEWLINE> code_fastio_setup = <STRING> <NEWLINE> <NL> import os <NEWLINE> import sys <NEWLINE> if sys . argv [ - 1 ] == <STRING> or os . getcwd ( ) != <STRING> : <NEWLINE> <INDENT> with open ( <STRING> , <STRING> ) as f : <NEWLINE> <INDENT> f . write ( code_fastio ) <NEWLINE> <DEDENT> with open ( <STRING> , <STRING> ) as f : <NEWLINE> <INDENT> f . write ( code_fastio_setup ) <NEWLINE> <DEDENT> os . system ( <STRING> ) <NEWLINE> if sys . argv [ - 1 ] == <STRING> : <NEWLINE> <INDENT> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> from fastio import readint , readints <NEWLINE> <NL> from operator import xor <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> N , Q = readints ( 2 ) <NEWLINE> A = readints ( N ) <NEWLINE> TLR = readints ( 3 * Q ) <NEWLINE> <NL> def op ( l , r ) : <NEWLINE> <INDENT> l_zero , l_one , l_inversion = l <NEWLINE> r_zero , r_one , r_inversion = r <NEWLINE> return l_zero + r_zero , l_one + r_one , l_inversion + r_inversion + l_one * r_zero <NEWLINE> <DEDENT> e = 0 , 0 , 0 <NEWLINE> def mapping ( l , r ) : <NEWLINE> <INDENT> if l : <NEWLINE> <INDENT> r_zero , r_one , r_inversion = r <NEWLINE> return r_one , r_zero , r_one * r_zero - r_inversion <NEWLINE> <DEDENT> return r <NEWLINE> <DEDENT> composition = xor <NEWLINE> identity = False <NEWLINE> <NL> A = [ ( 1 , 0 , 0 ) if a == 0 else ( 0 , 1 , 0 ) for a in A ] <NEWLINE> seg = LazySegTree ( op , e , mapping , composition , identity , A ) <NEWLINE> <NL> Ans = [ ] <NEWLINE> for t , l , r in zip ( TLR [ : : 3 ] , TLR [ 1 : : 3 ] , TLR [ 2 : : 3 ] ) : <NEWLINE> <INDENT> l -= 1 <NEWLINE> if t == 1 : <NEWLINE> <INDENT> seg . apply ( l , r , True ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> Ans . append ( seg . prod_getitem ( l , r , 2 ) ) <NEWLINE> <DEDENT> <DEDENT> if Ans : <NEWLINE> <INDENT> print ( <STRING> . join ( map ( str , Ans ) ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> main ( ) <NEWLINE>
d , t , s = input ( ) . split ( ) <NEWLINE> if d / s < t : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
d , t , s == map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> tmp = d / s <NEWLINE> <NL> if tmp <= t : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
D , T , S = map ( int , input ( ) ) <NEWLINE> if D * S > T : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
d , t , s = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if d <= t * s : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT>
D , T , S = list ( map ( input ( ) . split ( ) ) ) <NEWLINE> <NL> if D <= S * T : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b , c = input ( ) . split ( ) <NEWLINE> if b * c >= a : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
d , t , s = map ( int , input ( ) . split ( ) ) <NEWLINE> if d % s <= t : <NEWLINE> <INDENT> print ( Yes ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( No ) <NEWLINE> <DEDENT>
d , t , s = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> arrival = d / s <NEWLINE> <NL> if arrival > t : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
D , S , T = map ( int , input ( ) . split ( ) ) ) <NEWLINE> print ( <STRING> if D <= S * T else <STRING> ) <NEWLINE>
d , t , s = list ( map ( int , input ( ) ) ) <NEWLINE> <NL> min = d / s <NEWLINE> <NL> if min <= t : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
D = int ( input ( ) ) <NEWLINE> T = int ( input ( ) ) <NEWLINE> S = int ( input ( ) ) <NEWLINE> if D / S - T > 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
D T S = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> <NL> A = S * T <NEWLINE> if A >= D : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
print ( <STRING> ) <NEWLINE> D = int ( input ( <STRING> ) ) <NEWLINE> T = int ( input ( <STRING> ) ) <NEWLINE> S = int ( input ( <STRING> ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> if ( D / S <= T ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
d , s , t = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> if s * t >= d : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
d , t , s = input ( ) . split ( ) <NEWLINE> if t * s >= d : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT>
d = int ( input ( ) ) <NEWLINE> t = int ( input ( ) ) <NEWLINE> s = int ( input ( ) ) <NEWLINE> if ( t * s >= d ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
d , t , s = input ( ) . split ( ) <NEWLINE> <NL> if ( t * s >= d ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
d , t , s = input ( ) . split ( ) <NEWLINE> if int ( s ) * int ( t ) >= d : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
D , T , S = map ( input ( ) . split ( ) ) <NEWLINE> if D / S >= T : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
d , t . s = map ( int , input ( ) . split ( ) ) <NEWLINE> a = d / s <NEWLINE> if t >= a : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
D , T , S = map ( int , input . split ( ) ) <NEWLINE> if D / S <= T : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
D , T , S = map ( float , raw_input ( ) . split ( ) ) <NEWLINE> def intime ( D , T , S ) : <NEWLINE> <INDENT> if D <= T * S : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
d , t , s = map ( int , input ( ) . split ( ) ) <NEWLINE> if t <= d / s : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> else : <NEWLINE> print ( <STRING> ) <NEWLINE> <DEDENT>
d , t , s = map ( int , input ( ) ) <NEWLINE> if ( d / s <= t ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
<INDENT> D , T , S = map ( int , input ( ) . split ( ) ) <NEWLINE> <DEDENT> if ( D / T > S ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b , c = map ( int , input ( ) . spulit ( ) ) <NEWLINE> <NL> if a <= b * c : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
d = input ( ) <NEWLINE> t = input ( ) <NEWLINE> s = input ( ) <NEWLINE> <NL> if d <= s * t : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else print ( <STRING> ) <NEWLINE>
if D / S <= T : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
d , t , s = map ( int , input ( ) . split ( ) ) <NEWLINE> if d <= t * s : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> e ; se : <NEWLINE> print ( <STRING> ) <NEWLINE> <DEDENT>
import math <NEWLINE> <NL> <COMMENT> <NL> d , t , s = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> output = <STRING> ; <NEWLINE> <NL> if d / s >= s : <NEWLINE> <INDENT> if math . ceil ( d / s ) = s : <NEWLINE> <INDENT> output = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> output = <STRING> <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> output = <STRING> <NEWLINE> <NL> <DEDENT> print ( output ) <NEWLINE>
D , T , S = list ( int , input ( ) . split ( ) ) <NEWLINE> if D <= T * S : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
D , T , S = map ( int , input ( ) . split ) <NEWLINE> if D / S <= T : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
d , t , s = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if d // s <= t : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif d = 0 or t = 0 or s = 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT>
n = int ( input ( ) ) <COMMENT> <NEWLINE> num_list = [ int ( input ( ) ) for _ in range ( n ) ] <NEWLINE> <NL> a = num_list [ 0 ] / num_list [ 2 ] <NEWLINE> <NL> if a <= num_list [ 1 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
d , t , s = map ( int . input ( ) . split ( ) ) <NEWLINE> if d / s > t : <NEWLINE> <INDENT> print ( No ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( Yes ) <NEWLINE> <DEDENT>
<COMMENT> <NL> D = int ( input ( ) ) <NEWLINE> T = int ( input ( ) ) <NEWLINE> S = int ( input ( ) ) <NEWLINE> if D > T * S : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
2000 20 100 <NEWLINE>
D , T , S = map ( int , input . split ( ) ) <NEWLINE> if ( D / S ) <= T : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
D , T , S = input ( ) . split ( <STRING> ) <NEWLINE> if D / S > T : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
d = int ( input ( ) ) <NEWLINE> t = int ( input ( ) ) <NEWLINE> s = int ( input ( ) ) <NEWLINE> if ( d <= t * s ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
D , T , S = map ( int , input ( ) . split ) <NEWLINE> <NL> if S * T >= D : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
[ D T S ] = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> if D <= T * S : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
D , T , S = int ( input ( ) . split ( ) ) <NEWLINE> <NL> if T * S >= D : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
d , t , s = list ( map ( int , input ( ) ) ) <NEWLINE> if ( s * t >= d ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
d , t , s = map ( int , input ( ) ) . split ( ) ) <NEWLINE> if s == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif d / s = > t : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
class Solution : <NEWLINE> <INDENT> def solve ( self , D , T , S ) : <NEWLINE> <INDENT> time = D / S <NEWLINE> if time <= T : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return False <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> A = Solution ( ) <NEWLINE> D , T , S = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( A . solve ( D , T , S ) <NEWLINE>
D , T , S = [ int ( x ) for x in input ( <STRING> ) . split ( <STRING> ) ] <NEWLINE> if ( D and T ) and S <= 10000 and D / S <= T : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
D = int ( input ( ) ) <NEWLINE> T = int ( input ( ) ) <NEWLINE> S = int ( input ( ) ) <NEWLINE> <NL> res = D / S <NEWLINE> if ( res <= T ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
nums = input ( ) . split ( ) <NEWLINE> t = int ( nums [ 1 ] ) / int ( nums [ 3 ] ) <NEWLINE> if t <= int ( nums [ 2 ] ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
d = int ( input ( ) ) <NEWLINE> t = int ( input ( ) ) <NEWLINE> s = int ( input ( ) ) <NEWLINE> <NL> if t * s >= d : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> d = sys . argv [ 1 ] <NEWLINE> t = sys . argv [ 2 ] <NEWLINE> s = sys . argv [ 3 ] <NEWLINE> <NL> if s * t < d : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT>
d , t , s = map ( int , input ( ) split ( ( ) ) ) <NEWLINE> if t * s >= d : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
x , y , z = input . split ( ) <NEWLINE> if ( x / y >= z ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
if S * T > D : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
d , t , s = input ( ) . split ( ) <NEWLINE> if ( s >= ( d / t ) ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
D , T , S = input ( ) . split ( ) <NEWLINE> <NL> if S * T >= D : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
d , t , s = list ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if d / t <= s : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
from sys import stdin <NEWLINE> <NL> <NL> stdin = io . StringIO ( __INPUT ) <NEWLINE> <NL> D , T , S = [ int ( x ) for x in stdin . readline ( ) . rstrip ( ) . split ( ) ] <NEWLINE> <NL> if ( S * T ) > D : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
D , T , S = input ( ) <NEWLINE> if ( D == ( S * T ) ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
x = int ( input ( ) ) <NEWLINE> if x >= 30 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
D = input ( <STRING> ) <NEWLINE> T = input ( <STRING> ) <NEWLINE> S = input ( <STRING> ) <NEWLINE> if D / S < T : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> D , T , S = [ int ( i ) for i in sys . stdin . readline ( ) ] <NEWLINE> <NL> if ( S * T >= D ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
d , t , s = map ( int , input ( ) . split ( ) ) <NEWLINE> if d / s <= t : <NEWLINE> <INDENT> print ( Yes ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( No ) <NEWLINE> <DEDENT>
d , t , s = map ( double , input ( ) . split ( ) ) <NEWLINE> time = d / s <NEWLINE> if time > t : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
d , t , s = map ( int , input ( ) . split ( ) ) <NEWLINE> if d / s <= t : <NEWLINE> <INDENT> print ( Yes ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( No ) <NEWLINE> <DEDENT>
D = int ( input ( ) ) <NEWLINE> T = int ( input ( ) ) <NEWLINE> S = int ( input ( ) ) <NEWLINE> if D / S <= T : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
D = int ( input ( ) ) <NEWLINE> T = int ( input ( ) ) <NEWLINE> S = int ( input ( ) ) <NEWLINE> limit_speed = D / T + D % T <NEWLINE> <NL> if ( limit_speed <= S ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
d = int ( input ( ) ) <NEWLINE> t = int ( input ( ) ) <NEWLINE> s = int ( input ( ) ) <NEWLINE> <NL> if s * t < d : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
d , t , s = int ( input ( ) ) <NEWLINE> if S * t >= d : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
d , t , s = intput ( ) . split ( ) <NEWLINE> d = int ( d ) <NEWLINE> t = int ( t ) <NEWLINE> s = int ( s ) <NEWLINE> d1 = s * t <NEWLINE> if d <= d1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
D , T , S = map ( input ( ) . split ( ) ) <NEWLINE> <NL> print ( <STRING> if D < T * S else <STRING> ) <NEWLINE>
num = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> time = num [ 0 ] / num [ 2 ] <NEWLINE> if time <= num [ 1 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT>
<INDENT> d , t , s = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if d / t <= s : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
AllInput = input ( <STRING> ) <NEWLINE> Para = AllInput . split ( ) <NEWLINE> <NL> if ( ( float ( Para [ 0 ] ) / float ( Para [ 1 ] ) ) <= float ( Para [ 2 ] ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
d , t , s = map ( int , input ( ) . split ( ) ) <NEWLINE> actualTime = d / s <NEWLINE> <NL> if actualTime = < t : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
d , t , s = list ( map ( int , input ( ) ) ) <NEWLINE> if d <= ( s * t ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
d , t , s = map ( int , input ( ) ) <NEWLINE> print ( <STRING> if t * s >= d else <STRING> ) <NEWLINE>
a = input ( ) . split ( ) <NEWLINE> if int ( a [ 0 ] ) > int ( a [ 1 ] ) * int ( a [ 2 ] ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> print ( <STRING> ) <NEWLINE>
D , T , S = map ( int , input ( ) . split ( ) ) <NEWLINE> if T * S > D : <NEWLINE> <INDENT> print ( Yes ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( No ) <NEWLINE> <DEDENT>
d , t , s = map ( int , input ( ) . split ( ) ) <NEWLINE> if d / s <= t : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
d , t , s = map ( int , input ( ) ) <NEWLINE> <NL> if d > t * s : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
def l_in ( type_ ) : return list ( map ( type_ , input ( ) . split ( ) ) ) <NEWLINE> def i_in ( ) : return int ( input ( ) ) <NEWLINE> def m_in ( type_ ) : return map ( type_ , input ( ) . split ( ) ) <NEWLINE> def r_in ( n , type_ ) : return [ type_ ( input ( ) ) for _ in range ( n ) ] <NEWLINE> ans = None <NEWLINE> <NL> d , t , s = m_in ( ) <NEWLINE> ans = <STRING> if d <= t * s else <STRING> <NEWLINE> <NL> print ( ans ) <NEWLINE>
import math , sys , os , collections , functools <NEWLINE> if ( os . path . exists ( <STRING> ) ) : <NEWLINE> <INDENT> sys . stdin = open ( <STRING> , <STRING> ) <NEWLINE> sys . stdout = open ( <STRING> , <STRING> ) <NEWLINE> <DEDENT> for testcase in range ( int ( input ( ) ) ) : <NEWLINE> <INDENT> D , T , S = map ( int , input ( ) . split ( ) ) <NEWLINE> t = D / S <NEWLINE> if t <= T : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
D = int ( input ( ) ) <NEWLINE> T = int ( input ( ) ) <NEWLINE> S = int ( input ( ) ) <NEWLINE> <NL> if T * S >= D : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
D , T , S = input ( int ( ) ) , input ( int ( ) ) , input ( int ( ) ) <NEWLINE> <NL> if S * T >= D : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
D , T , S = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if T - D / S >= 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> else : <NEWLINE> print ( <STRING> ) <NEWLINE> <DEDENT>
<INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
d = input ( ) <NEWLINE> arr = [ int ( d ) for i in d . split ( ) ] <NEWLINE> <NL> t1 = arr [ 0 ] / arr [ - 1 ] <NEWLINE> if t1 <= arr [ 1 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
D = int ( input ( ) ) <NEWLINE> T = int ( input ( ) ) <NEWLINE> S = int ( input ( ) ) <NEWLINE> a = float ( T - D / S ) <NEWLINE> if a > 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
d , t , s = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> x = s * t <NEWLINE> <NL> if x >= d : <NEWLINE> <NL> <INDENT> print ( <STRING> ) else : <NEWLINE> <NL> print ( <STRING> ) <NEWLINE> <DEDENT>
d , t , s = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> times = distance / speed <NEWLINE> if times <= t : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
d , t , s = input ( ) . split ( <STRING> ) <NEWLINE> <NL> if d <= int ( t ) * int ( s ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
D = int ( input ( ) ) <NEWLINE> T = int ( input ( ) ) <NEWLINE> S = int ( input ( ) ) <NEWLINE> <NL> if D <= T * S : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
m , t , s = input ( ) . split ( ) <NEWLINE> if m // s <= t : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> number = 0 <NEWLINE> MOD = 1000000007 <NEWLINE> <NL> for i in range ( N - 1 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , N ) : <NEWLINE> <INDENT> number += A [ i ] * A [ j ] <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if number > MOD : <NEWLINE> <INDENT> print ( number % MOD ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( number ) <NEWLINE> <DEDENT>
a , b , c = map ( int , input ( ) . spulit ( ) ) <NEWLINE> <NL> if a <= b * c : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b , c = map ( int , input ( ) . spulit ( ) ) <NEWLINE> <NL> if a <= b * c : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
info = input ( ) . split ( ) <NEWLINE> <NL> D = info [ 0 ] <NEWLINE> S = info [ 1 ] <NEWLINE> T = info [ 2 ] <NEWLINE> <NL> if D / S <= T : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> <NL> D , T , S = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if S * T >= D : <NEWLINE> <INDENT> print ( Yes ) <NEWLINE> <DEDENT> elif : <NEWLINE> <INDENT> print ( No ) <NEWLINE> <DEDENT>
d , t , s = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if t * s >= D : <NEWLINE> <INDENT> prrint ( <STRING> ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
d t s = map ( int , input ( ) . split ( ) ) <NEWLINE> if d <= t * s : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
d , t , s = input ( ) . split ( ) <NEWLINE> if d / s <= t : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
x , y , z = int ( input ( ) . split ( ) ) <NEWLINE> if y * z >= x : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
D = int ( input ( ) ) <NEWLINE> T = int ( input ( ) ) <NEWLINE> S = int ( input ( ) ) <NEWLINE> <NL> <NL> <NL> <NL> time = D / S <NEWLINE> if time <= T : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT>
D = int ( input ( ) ) <NEWLINE> T = int ( input ( ) ) <NEWLINE> S = int ( input ( ) ) <NEWLINE> if D <= T * S : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif D > T * S : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a = input ( ) <NEWLINE> a = [ int ( a ) ] <NEWLINE> b = a [ 1 ] * a [ 2 ] <NEWLINE> if b >= a [ 0 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif b < a [ 0 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
x , y , z = map ( int , input ( ) . split ( ) ) <NEWLINE> test = x / z <NEWLINE> <NL> if ( test < y ) { <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> } else { <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> } <NEWLINE>
D = int ( input ( ) ) <NEWLINE> T = int ( input ( ) ) <NEWLINE> S = int ( input ( ) ) <NEWLINE> <NL> if D <= T * S : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
D , T , S = int ( input ( ) ) <NEWLINE> if 1 <= D <= 10000 and 1 <= T <= 10000 and 1 <= S <= 10000 : <NEWLINE> <INDENT> if ( D / S ) > T : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
inp_ = input ( ) <NEWLINE> imp_list = imp_ . spilt ( ) <NEWLINE> if inp_list [ 0 ] / inp_list [ 1 ] <= 80 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
d , t , s = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = d / s <NEWLINE> print ( <STRING> if ans < float ( t ) else <STRING> <NEWLINE>
d , t , s = map ( int , input ( ) ) <NEWLINE> t_d = t * d <NEWLINE> if td >= d : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
D , T , S = inputlist ( ) <NEWLINE> time = D // S + int ( D % S != 0 ) <NEWLINE> if time <= T : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
D , T , S = map ( int , input ( ) . split ) <NEWLINE> <NL> if D <= T * S : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
dts = input ( ) . split ( ) <NEWLINE> if dts [ 1 ] * dts [ 2 ] >= dts [ 0 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s = map ( int , input ( ) . split ( ) ) <NEWLINE> d = s [ 0 ] <NEWLINE> t = s [ 1 ] <NEWLINE> s = s [ 2 ] <NEWLINE> if d >= t * s : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
d , t , s = map ( int , input ( ) ) <NEWLINE> if t * s <= d : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
d = input ( ) <NEWLINE> t = input ( ) <NEWLINE> s = input ( ) <NEWLINE> <NL> <NL> <INDENT> if ( s * t >= d ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
D = int ( input ( ) ) <NEWLINE> T = int ( input ( ) ) <NEWLINE> S = int ( input ( ) ) <NEWLINE> <NL> if ( D / S <= T ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
d = float ( input ( ) ) <NEWLINE> t = float ( input ( ) ) <NEWLINE> s = float ( input ( ) ) <NEWLINE> <NL> if d / s < t : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
D , T , S = ( int ( x ) for x in input ( ) . split ( ) ) <NEWLINE> if D > S * T : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
D , T , S = map ( int ( ) , input ( ) . split ( ) ) <NEWLINE> print ( <STRING> ) if T * S >= D else print ( <STRING> ) <NEWLINE>
<INDENT> GNU nano 4.8 a . py  <NEWLINE> <DEDENT> def read ( ) : <NEWLINE> <INDENT> D , T , S = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> return D , T , S <NEWLINE> <NL> <DEDENT> def func ( D , T , S ) : <NEWLINE> <INDENT> return D / S <= T <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> D , T , S = read ( ) <NEWLINE> print ( <STRING> if func ( D , T , S ) else <STRING> ) <NEWLINE> <DEDENT>
a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> D = a [ 0 ] <NEWLINE> T = a [ 0 ] <NEWLINE> S = a [ 0 ] <NEWLINE> <NL> v = D / T <NEWLINE> if s >= v : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
inp = np . fromstring ( sys . stdin . read ( ) , dtype = np . int64 , sep = <STRING> ) <NEWLINE> if inp [ 0 ] / inp [ 2 ] < inp [ 1 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
D = int ( input ( ) ) , T = int ( input ( ) ) , S = int ( input ( ) ) <NEWLINE> <NL> travel_time = D * S <NEWLINE> if travel_time <= T : <NEWLINE> <INDENT> print <STRING> <NEWLINE> else : print <STRING> <NEWLINE> <DEDENT>
i = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> print ( <STRING> if i [ 0 ] > i [ 1 ] * 1 [ 2 ] else <STRING> ) <NEWLINE>
input_data = input ( ) <NEWLINE> data = split ( int ( input_data ) ) <NEWLINE> d = data [ 0 ] <NEWLINE> t = data [ 1 ] <NEWLINE> s = data [ 2 ] <NEWLINE> print ( <STRING> ) if d / s > t else print ( <STRING> ) <NEWLINE>
long_str = input ( ) <NEWLINE> short_str = input ( ) <NEWLINE> short_list = list ( short_str ) <NEWLINE> <NL> long_len = len ( long_str ) <NEWLINE> short_len = len ( short_str ) <NEWLINE> iter_num = long_len - short_len + 1 <NEWLINE> <NL> max_count = 0 <NEWLINE> for i in range ( iter_num ) : <NEWLINE> <INDENT> tmp = 0 <NEWLINE> obj_list = list ( long_str [ i : ( short_len + i ) ] ) <NEWLINE> for s , o in zip ( short_list , obj_list ) : <NEWLINE> <INDENT> tmp += int ( s == o ) <NEWLINE> <DEDENT> max_count = max ( max_count , tmp ) <NEWLINE> <NL> <DEDENT> print ( short_len - max_count ) <NEWLINE>
D , T , S = map ( int , input ( ) . spltit ( ) ) <NEWLINE> if D > T * S : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
num = map ( lambda x : int ( x ) , input ( ) . split ( ) ) <NEWLINE> <NL> if num [ 0 ] / num [ 2 ] <= num [ 1 ] : print ( <STRING> ) <NEWLINE> else : print ( <STRING> ) <NEWLINE>
D , T , S = map ( int , input ( ) ) . split ( ) <NEWLINE> if T * S <= D : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
d = input ( ) <NEWLINE> t = input ( ) <NEWLINE> s = input ( ) <NEWLINE> <NL> <NL> <INDENT> if s * t >= d : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
if S * T >= D : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
D , T , S = map ( input ( ) . split ( ) ) <NEWLINE> result = D / S <NEWLINE> if T <= result : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
D , T , S = input1 ( ) . split ( ) <NEWLINE> D = int ( D ) <NEWLINE> T = int ( T ) <NEWLINE> S = int ( S ) <NEWLINE> <NL> if D // S > T : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
d , t , s = map ( int , input ( ) . split ( ) ) <NEWLINE> if d <= t * s { <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> } <NEWLINE> else { <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> } <NEWLINE>
data = input ( ) <NEWLINE> n = [ int ( x ) for x in data ] <NEWLINE> if n [ 1 ] * n [ 2 ] < n [ 0 ] : print ( <STRING> ) <NEWLINE> else print ( <STRING> ) <NEWLINE>
D = input ( ) <NEWLINE> T = input ( ) <NEWLINE> S = input ( ) <NEWLINE> <NL> if ( D / S <= T ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
D = int ( input ( <STRING> ) ) <NEWLINE> T = int ( input ( <STRING> ) ) <NEWLINE> S = int ( input ( <STRING> ) ) <NEWLINE> <NL> if ( D / S ) <= T : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
D , T , S = [ int ( input ( ) ) for i in range ( 3 ) ] <NEWLINE> if D / S <= T : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
D , T , S = map ( int , input ( ) . split ( ) ) <NEWLINE> if T * S >= D : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> else : <NEWLINE> print ( <STRING> ) <NEWLINE> <DEDENT>
D , T , S = map ( int . input ( ) . split ( ) ) <NEWLINE> if D / S <= T : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
d = int ( input ( ) ) <NEWLINE> t = int ( input ( ) ) <NEWLINE> s = int ( input ( ) ) <NEWLINE> if t * s >= d : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
d , t , s = int ( input ( ) ) <NEWLINE> a = d / s <NEWLINE> print ( <STRING> if a <= t else <STRING> ) <NEWLINE>
D , T , S = ( int ( d ) for d in input ( ) . split ( ) ) <NEWLINE> <NL> if T * s >= D : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
string_list = split ( input ( ) ) <NEWLINE> D = int ( string_list [ 0 ] ) <NEWLINE> T = int ( string_list [ 1 ] ) <NEWLINE> S = int ( string_list [ 2 ] ) <NEWLINE> kyori = T * S <NEWLINE> if D <= kyori : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
d , t , s = map ( int , input ( ) . split ( ) ) <NEWLINE> if d <= t * s : <NEWLINE> <INDENT> print ( Yes ) <NEWLINE> <DEDENT> else : print ( No ) <NEWLINE>
d , t , s = map ( int , input ( ) . split ( ) ) <NEWLINE> if d = < t * s : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
D , T , S = map ( int , input ( ) ) <NEWLINE> if D <= T * S : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
d , t , s = map ( int , inport ( ) . split ( ) ) <NEWLINE> <NL> if t * s <= d : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
D , T , S = int ( input ( ) . split ( ) ) <NEWLINE> if D / S = < T : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
d = T * S <NEWLINE> if d > D : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
def ans ( ) : <NEWLINE> <INDENT> if t == 0 : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> if d / s < = t : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> d , t , s = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( ans ( ) ) <NEWLINE>
list1 = input ( ) . split ( <STRING> ) <NEWLINE> if int ( list1 [ 0 ] ) <= int ( list1 [ 1 ] ) * int ( list [ 2 ] ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> try : <NEWLINE> <INDENT> d = int ( input ( <STRING> ) ) <NEWLINE> t = int ( input ( <STRING> ) ) <NEWLINE> s = int ( input ( <STRING> ) ) <NEWLINE> <DEDENT> except ValueError : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( 1 ) <NEWLINE> <NL> <DEDENT> if 1 <= d <= 10000 and 1 <= t <= 10000 and 1 <= s <= 10000 : <NEWLINE> <INDENT> take_time = d / s <NEWLINE> if take_time <= t : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
d = int ( input ( ) ) <NEWLINE> t = int ( input ( ) ) <NEWLINE> s = int ( input ( ) ) <NEWLINE> <NL> if d == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> elif t == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> elif s == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <NL> <INDENT> if s * t >= d : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
D , T , S = map ( int , input ( ) . split ( ) . split ( ) ) <NEWLINE> <NL> if D > S * T : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
d , t , s = input ( ) . split ( ) <NEWLINE> int ( d ) <NEWLINE> int ( t ) <NEWLINE> int ( s ) <NEWLINE> if ( d / s <= t ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
S = input ( ) . strip ( ) <COMMENT> <NEWLINE> T = input ( ) . strip ( ) <COMMENT> <NEWLINE> <NL> x = len ( T ) <NEWLINE> ans = len ( S ) <NEWLINE> for i in range ( len ( S ) - x ) : <NEWLINE> <INDENT> U = S [ i : i + x ] <NEWLINE> cost = sum ( 1 if U [ k ] != T [ k ] for k in range ( x ) ) <NEWLINE> ans = min ( ans , cost ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> m0 = 10 ** 9 + 7 <NEWLINE> for i in range ( 0 , N - 1 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , N ) : <NEWLINE> <INDENT> ans = ( ans + A [ i ] * A [ j ] ) % m0 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
S = input ( ) <NEWLINE> T = input ( ) <NEWLINE> i = 0 <NEWLINE> j = 0 <NEWLINE> match = 0 <NEWLINE> for i in range ( Len ( S ) - Len ( T ) ) : <NEWLINE> <INDENT> count = 0 <NEWLINE> for j in range ( Len ( T ) ) : <NEWLINE> <INDENT> if S [ i + j ] == T [ j ] : <NEWLINE> <INDENT> count = count + 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if match < count : <NEWLINE> <INDENT> match = count <NEWLINE> <NL> <DEDENT> <DEDENT> print ( Len ( T ) - match ) <NEWLINE>
s = input ( ) . split ( ) <NEWLINE> S = s [ 0 ] <NEWLINE> T = s [ 1 ] <NEWLINE> <NL> score = [ ] <NEWLINE> for i in range ( len ( S ) - len ( T ) ) : <NEWLINE> <INDENT> U = s [ i : i + len ( T ) ] <NEWLINE> cnt = 0 <NEWLINE> for j in range ( T ) : <NEWLINE> <INDENT> if U [ j ] != T [ j ] : <NEWLINE> <INDENT> cnt = cnt + 1 <NEWLINE> <DEDENT> score . append ( cnt ) <NEWLINE> <DEDENT> <DEDENT> print ( min ( score ) ) <NEWLINE> <NL>
<COMMENT> <NL> S = str ( input ( ) ) <NEWLINE> T = str ( input ( ) ) <NEWLINE> i = 0 <NEWLINE> j = 0 <NEWLINE> <NL> Slen = len ( S ) <NEWLINE> Tlen = len ( T ) <NEWLINE> change_min = Tlen <NEWLINE> <NL> for i in range ( Slen - Tlen ) : <NEWLINE> <INDENT> diff = 0 <NEWLINE> for j in range ( Tlen ) : <NEWLINE> <INDENT> if S [ i ] != T [ i + j ] : <NEWLINE> <INDENT> diff += 1 <NEWLINE> <DEDENT> <DEDENT> change_min = min ( change_min , diff ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> print ( change_min ) <NEWLINE>
S = input ( ) <NEWLINE> T = input ( ) <NEWLINE> <NL> num = 10 ** 10 <NEWLINE> <NL> for i in range ( len ( S ) - len ( T ) + 1 ) : <NEWLINE> <INDENT> U = S [ i : ( i + len ( T ) ) ] <NEWLINE> for j in range ( len ( T ) ) : <NEWLINE> <INDENT> if ( T [ j ] != S [ j ] ) : <NEWLINE> <INDENT> tmp += 1 <NEWLINE> <DEDENT> <DEDENT> num = min ( num , tmp ) <NEWLINE> <NL> <DEDENT> print ( num ) <NEWLINE>
import sys <NEWLINE> <NL> <NL> def resolve ( in_ ) : <NEWLINE> <INDENT> S = next ( in_ ) . strip ( ) <NEWLINE> T = next ( in_ ) . strip ( ) <NEWLINE> <NL> x = 0 <NEWLINE> for i in range ( len ( S ) ) : <NEWLINE> <INDENT> if len ( S ) - i < len ( T ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> v = 0 <NEWLINE> for x , y in zip ( S [ i : ] , T ) <NEWLINE> <INDENT> if x == y : <NEWLINE> <INDENT> v += 1 <NEWLINE> <DEDENT> x = max ( x , len ( T ) - v ) <NEWLINE> <NL> <DEDENT> <DEDENT> return x <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> answer = resolve ( sys . stdin ) <NEWLINE> print ( answer ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> t = input ( ) <NEWLINE> <NL> ans = 10000 <NEWLINE> <NL> for i in range ( len ( s ) - len ( t ) + 1 ) : <NEWLINE> <INDENT> score = 0 <NEWLINE> U = [ i : i + len ( t ) ] <NEWLINE> for j in range ( len ( t ) ) : <NEWLINE> <INDENT> if U [ j ] != t [ j ] : <NEWLINE> <INDENT> score += 1 <NEWLINE> <DEDENT> <DEDENT> ans = min ( ans , score ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
<NL> def main ( ) : <NEWLINE> <INDENT> S = input ( ) <NEWLINE> T = input ( ) <NEWLINE> <COMMENT> <NL> <NL> st = { } <NEWLINE> for i in range ( len ( S ) - len ( T ) + 1 ) : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> for s , t in zip ( S [ i : i + len ( T ) ] , T ) : <NEWLINE> <INDENT> cnt += s == t <NEWLINE> <DEDENT> st . add ( cnt ) <NEWLINE> <DEDENT> print ( len ( T ) - max ( st ) ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> t = input ( ) <NEWLINE> a = len ( s ) <NEWLINE> b = len ( t ) <NEWLINE> l = [ ] <NEWLINE> for i in range ( a - b + 1 ) : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> c = s [ i , i + t ] <NEWLINE> for x , y in zip ( c , t ) : <NEWLINE> <INDENT> if x != y : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> l . append ( cnt ) <NEWLINE> <DEDENT> print ( min ( l ) ) <NEWLINE>
S = input ( ) <NEWLINE> T = input ( ) <NEWLINE> l = len ( T ) <NEWLINE> ans = l <NEWLINE> print ( ans ) <NEWLINE> for i in range ( l ) : <NEWLINE> <INDENT> for j in range ( l ) : <NEWLINE> <INDENT> if ( i <= j ) : <NEWLINE> <INDENT> if T [ i : j + 1 ] in S : <NEWLINE> <INDENT> if f >= i and f + ( l - j ) <= len ( S ) : <NEWLINE> <INDENT> ans = min ( ans , l - ( j + 1 - i ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
s = input ( ) <NEWLINE> t = input ( ) <NEWLINE> ls = len ( s ) <NEWLINE> lt = len ( t ) <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( ls - lt + 1 ) : <NEWLINE> <INDENT> same = 0 <NEWLINE> for j in range ( lt ) : <NEWLINE> <INDENT> ind = i + lt <NEWLINE> if s [ ind ] == t [ j ] : <NEWLINE> <INDENT> same += 1 <NEWLINE> <DEDENT> <DEDENT> ans = min ( ans , min ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
s = input ( ) <NEWLINE> t = input ( ) <NEWLINE> <NL> print ( s ) <NEWLINE> a = len ( s ) <NEWLINE> b = len ( t ) <NEWLINE> c = a - b ; <NEWLINE> min1 = 0 ; <NEWLINE> min2 = 0 ; <NEWLINE> for i in range ( c ) : <NEWLINE> <INDENT> for j in range ( b ) : <NEWLINE> <INDENT> if s [ j ] == t [ i + j ] : <NEWLINE> <INDENT> min2 += 1 <NEWLINE> <DEDENT> <DEDENT> if min1 > min2 : <NEWLINE> <INDENT> min1 = min2 <NEWLINE> <DEDENT> <DEDENT> print ( min1 ) <NEWLINE>
for i in range ( len ( S ) - lenT + 1 ) : <NEWLINE> <INDENT> compareS = S [ i : i + lenT ] <NEWLINE> match_len = 0 <NEWLINE> for j in range ( lenT ) : <NEWLINE> <INDENT> if compareS [ j ] == T [ j ] : <NEWLINE> <INDENT> match_len += 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if max_match_len < match_len : <NEWLINE> <INDENT> max_match_len = match_len <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( lenT - max_match_len ) <NEWLINE>
s , t = input ( ) . split ( <STRING> ) <NEWLINE> <NL> s_l = len ( s ) <NEWLINE> t_l = len ( t ) <NEWLINE> <NL> max_count = 0 <NEWLINE> for i in range ( 0 , s_l - t_l ) : <NEWLINE> <INDENT> count = 0 <NEWLINE> for j in range ( 0 , t_l ) : <NEWLINE> <INDENT> if s [ i + j ] == t [ j ] : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> if count > max_count : <NEWLINE> <INDENT> max_count = count <NEWLINE> <NL> <DEDENT> <DEDENT> diff = t_l - max_count <NEWLINE> print ( diff ) <NEWLINE>
S , T = [ input ( ) for _ in range ( 2 ) ] <NEWLINE> answer = 1001 <NEWLINE> <NL> for i in range ( len ( S ) - len ( T ) + 1 ) : <NEWLINE> <INDENT> k = 0 <NEWLINE> U = S [ i : i + len ( T ) ] <NEWLINE> for j in range ( len ( T ) ) : <NEWLINE> <INDENT> if T ( j ) != U ( j ) : <NEWLINE> <INDENT> k += 1 <NEWLINE> <DEDENT> <DEDENT> answer = min ( answer , k ) <NEWLINE> <DEDENT> print ( answer ) <NEWLINE>
s = input ( ) <NEWLINE> t = input ( ) <NEWLINE> <NL> ans = len ( s ) <NEWLINE> <NL> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> if i + len ( t ) - 1 >= len ( s ) : break ; <NEWLINE> <INDENT> dif = 0 <NEWLINE> for j in range ( len ( t ) ) : <NEWLINE> <INDENT> if s [ i + j ] != t [ j ] : <NEWLINE> <INDENT> dif += 1 <NEWLINE> <DEDENT> <DEDENT> ans = min ( ans , dif ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
S = input ( ) <NEWLINE> T = input ( ) <NEWLINE> mint = 10000 <NEWLINE> <NL> for i in range ( len ( S ) - len ( T ) + 1 ) : <NEWLINE> <INDENT> con = 0 <NEWLINE> for j in range ( len ( T ) ) : <NEWLINE> <INDENT> if S [ i + j ] != T [ j ] : <NEWLINE> <INDENT> con += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> mint = min ( con , mint ) <NEWLINE> <NL> if min_count == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> print ( mint ) <NEWLINE>
from math import min <NEWLINE> s = input ( ) <NEWLINE> st = input ( ) <NEWLINE> mx = 10 ** 5 <NEWLINE> <NL> rangeforloop = len ( s ) + 1 - len ( st ) <NEWLINE> <NL> for i in range ( rangeforloop ) : <NEWLINE> <INDENT> mx = min ( mx , matcher ( s [ i : len ( st ) + i ] , st ) ) <NEWLINE> <NL> <NL> <DEDENT> print ( mx ) <NEWLINE>
ans = [ ] <NEWLINE> <NL> for i in range ( M - N + 1 ) : <NEWLINE> <NL> <INDENT> num = 0 <NEWLINE> <NL> substring = input_list [ 0 ] [ i : i + N ] <NEWLINE> <NL> for j in range ( len ( substring ) ) : <NEWLINE> <NL> <INDENT> if substring [ j ] != input_list [ 1 ] [ j ] : <NEWLINE> <NL> <INDENT> num += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> ans . append ( num ) <NEWLINE> <NL> <DEDENT> print ( min ( ans ) ) <NEWLINE>
s , t = input ( ) , input ( ) <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> for i in range ( len ( s ) - len ( t ) + 1 ) : <NEWLINE> <INDENT> count = 0 <NEWLINE> for j in range ( len ( t ) ) : <NEWLINE> <INDENT> if s [ i ] [ j ] == t [ j ] : <NEWLINE> <INDENT> count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if ans <= count : <NEWLINE> <INDENT> ans = count <NEWLINE> <DEDENT> print ( len ( t ) - count ) <NEWLINE>
<NL> input = sys . stdin . readline <NEWLINE> <NL> S = input ( ) <NEWLINE> T = input ( ) <NEWLINE> <NL> result = float ( <STRING> ) <NEWLINE> for i in range ( len ( S ) - len ( T ) + 1 ) : <NEWLINE> <INDENT> t = 0 <NEWLINE> for j in range ( len ( T ) ) : <NEWLINE> <INDENT> if S [ i + j ] != T [ j ] : <NEWLINE> <INDENT> t += 1 <NEWLINE> <DEDENT> <DEDENT> result = min ( result , t ) <NEWLINE> <DEDENT> print ( result ) <NEWLINE>
S , T = input ( ) . split ( <STRING> ) <NEWLINE> <NL> cnt = [ ] <NEWLINE> for i in range ( len ( S ) - len ( T ) + 1 ) : <NEWLINE> <INDENT> mismatch = 0 <NEWLINE> for j in range ( len ( T ) ) : <NEWLINE> <INDENT> if S [ i + j ] != T [ j ] : <NEWLINE> <INDENT> mismatch += 1 <NEWLINE> <DEDENT> <DEDENT> cnt . append ( mismatch ) <NEWLINE> <NL> <DEDENT> print ( min ( cnt ) ) <NEWLINE> <NL>
S = input ( ) <NEWLINE> T = input ( ) <NEWLINE> <NL> s = len ( S ) <NEWLINE> t = len ( T ) <NEWLINE> ans1 = 10000000 <NEWLINE> <NL> for i in range ( s - t + 1 ) : <NEWLINE> <INDENT> ans = 0 <NEWLINE> for j in range ( t ) : <NEWLINE> <INDENT> if t [ j ] != s [ i + j ] : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> ans1 = ans <NEWLINE> <NL> <DEDENT> print ( ans1 ) <NEWLINE>
import numpy as np <NEWLINE> max_change = 1000 <NEWLINE> s = input ( ) <NEWLINE> t = input ( ) <NEWLINE> list_t = np . array ( [ _ for _ in t ] ) <NEWLINE> for i in range ( 1 , len ( s ) - len ( t ) + 1 ) : <NEWLINE> <INDENT> s_sample = s [ i - 1 : len ( t ) + i - 1 ] <NEWLINE> list_ss = np . array ( [ _ for _ in list_ss ] ) <NEWLINE> list_tf = list_t == list_ss <NEWLINE> n_change = len ( list_t ) - sum ( list_tf ) <NEWLINE> if n_change < max_change : <NEWLINE> <INDENT> max_change = n_change <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> <DEDENT> print ( max_change ) <NEWLINE>
S , T = input ( ) . split ( ) <NEWLINE> mm = 0 <NEWLINE> for i in range ( len ( S ) - len ( T ) ) : <NEWLINE> <INDENT> a = S [ i : i + len ( T ) ] <NEWLINE> mm_now = sum ( [ x == y for x , y in [ * zip ( a , T ) ] ] ) <NEWLINE> mm = max ( mm_now , mm ) <NEWLINE> <DEDENT> print ( len ( T ) - mm ) <NEWLINE>
S = input ( ) <NEWLINE> T = input ( ) <NEWLINE> s = len ( S ) <NEWLINE> t = len ( T ) <NEWLINE> max_count = 0 <NEWLINE> count = 0 <NEWLINE> for i in range ( s - t + 1 ) : <NEWLINE> <INDENT> for j in range ( t ) : <NEWLINE> <INDENT> if T [ i ] == S [ j + i ] : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> max_count = max ( max_count , count ) <NEWLINE> count = 0 <NEWLINE> <DEDENT> print ( t - max_count ) <NEWLINE>
S = input ( ) <NEWLINE> T = input ( ) <NEWLINE> <NL> for i in range ( len ( S ) - len ( T ) + 1 ) : <NEWLINE> <INDENT> sub_S = S [ i : i + len ( T ) ] <NEWLINE> cnt = 0 <NEWLINE> for j in range ( len ( T ) ) : <NEWLINE> <INDENT> if sub_S [ j ] != T [ j ] : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> cnt_list . append ( cnt ) <NEWLINE> <DEDENT> print ( min ( cnt_list ) ) <NEWLINE>
S = input ( ) <NEWLINE> T = input ( ) <NEWLINE> result = len ( T ) <NEWLINE> for s in range ( 0 , len ( S ) - len ( T ) + 1 ) : <NEWLINE> <INDENT> diff = 0 <NEWLINE> for i in range ( 0 , len ( T ) ) : <NEWLINE> <INDENT> if T [ i ] != S [ s + i ] : <NEWLINE> <INDENT> diff += 1 <NEWLINE> <DEDENT> <DEDENT> result = min ( ans , diff ) <NEWLINE> <NL> <DEDENT> print ( result ) <NEWLINE>
S = input ( ) <NEWLINE> T = input ( ) <NEWLINE> ans = len ( T ) <NEWLINE> for i in range ( len ( S ) - len ( T ) + 1 ) : <NEWLINE> <INDENT> _ans = 0 <NEWLINE> for j in range ( len ( T ) ) : <NEWLINE> <INDENT> if S [ i + j ] != T [ i + j ] : <NEWLINE> <INDENT> _ans += 1 <NEWLINE> <DEDENT> <DEDENT> ans = min ( ans , _ans ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
S = input ( ) <NEWLINE> T = input ( ) <NEWLINE> <NL> ans = len ( T ) <NEWLINE> <NL> for i in range ( len ( S ) - len ( T ) + 1 ) : <NEWLINE> <INDENT> diff = 0 <NEWLINE> for j in range ( len ( T ) ) : <NEWLINE> <INDENT> if S [ i + j ] != T [ j ] : <NEWLINE> <INDENT> diff += 1 <NEWLINE> <DEDENT> l_diff . append ( diff ) <NEWLINE> <DEDENT> ans = min ( ans , diff ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
<INDENT> S = input ( ) <NEWLINE> <DEDENT> T = input ( ) <NEWLINE> <NL> Min = 100000 <NEWLINE> <NL> for i in range ( len ( S ) - len ( T ) + 1 ) : <NEWLINE> <INDENT> count = 0 <NEWLINE> for n in range ( len ( T ) ) : <NEWLINE> <INDENT> if S [ i + n ] != T [ n ] : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> if count < Min : <NEWLINE> <INDENT> Min = count <NEWLINE> <NL> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
def minimumChar ( S , T ) : <NEWLINE> <INDENT> n , m = len ( S ) , len ( T ) <NEWLINE> ans = sys . maxsize <NEWLINE> for i in range ( m - n + 1 ) : <NEWLINE> <INDENT> minRemovedChar = 0 <NEWLINE> for j in range ( n ) : <NEWLINE> <INDENT> if ( S [ j ] != T [ i + j ] ) : <NEWLINE> <INDENT> minRemovedChar += 1 <NEWLINE> <DEDENT> <DEDENT> ans = min ( minRemovedChar , ans ) <NEWLINE> <DEDENT> return ans <NEWLINE> <NL> <DEDENT> S = input ( ) <NEWLINE> T = input ( ) <NEWLINE> <NL> print ( minimumChar ( S , T ) ) <NEWLINE>
S = str ( input ( ) ) <NEWLINE> T = str ( input ( ) ) <NEWLINE> <NL> suma = 0 <NEWLINE> sumb = 0 <NEWLINE> sumc = 0 <NEWLINE> <NL> for i in range ( len ( T ) ) : <NEWLINE> <INDENT> A = T [ i : ] <NEWLINE> B = T [ : i + 1 ] <NEWLINE> if A in S : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> suma += 1 <NEWLINE> <NL> <DEDENT> if B in S : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> sumb += 1 <NEWLINE> <NL> <DEDENT> if A in S : <NEWLINE> <INDENT> if B in S : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> sumc += 1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> suma = min ( suma , sumb ) <NEWLINE> suma = min ( suma , sumc ) <NEWLINE> print ( suma ) <NEWLINE> ~ <NEWLINE>
<COMMENT> <NL> <NL> s = input ( ) <NEWLINE> t = input ( ) <NEWLINE> <NL> errors = [ ] <NEWLINE> for i in range ( len ( s ) - len ( t ) + 1 ) : <NEWLINE> <INDENT> error = 0 <NEWLINE> for j in range ( len ( t ) ) : <NEWLINE> <INDENT> if s [ i + j ] != t [ j ] : <NEWLINE> <INDENT> error += 1 <NEWLINE> <DEDENT> <DEDENT> errors . append ( error ) <NEWLINE> <DEDENT> print ( min ( errors ) <NEWLINE>
<COMMENT> <NL> import sys <NEWLINE> import math <NEWLINE> import os <NEWLINE> import itertools <NEWLINE> import string <NEWLINE> import heapq <NEWLINE> import _collections <NEWLINE> from collections import Counter <NEWLINE> from collections import defaultdict <NEWLINE> from collections import deque <NEWLINE> from functools import lru_cache <NEWLINE> import bisect <NEWLINE> import re <NEWLINE> import queue <NEWLINE> import copy <NEWLINE> import decimal <NEWLINE> <NL> <NL> class Scanner ( ) : <NEWLINE> <INDENT> @ staticmethod <NEWLINE> def int ( ) : <NEWLINE> <INDENT> return int ( sys . stdin . readline ( ) . rstrip ( ) ) <NEWLINE> <NL> <DEDENT> @ staticmethod <NEWLINE> def string ( ) : <NEWLINE> <INDENT> return sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> <NL> <DEDENT> @ staticmethod <NEWLINE> def map_int ( ) : <NEWLINE> <INDENT> return [ int ( x ) for x in Scanner . string ( ) . split ( ) ] <NEWLINE> <NL> <DEDENT> @ staticmethod <NEWLINE> def string_list ( n ) : <NEWLINE> <INDENT> return [ Scanner . string ( ) for i in range ( n ) ] <NEWLINE> <NL> <DEDENT> @ staticmethod <NEWLINE> def int_list_list ( n ) : <NEWLINE> <INDENT> return [ Scanner . map_int ( ) for i in range ( n ) ] <NEWLINE> <NL> <DEDENT> @ staticmethod <NEWLINE> def int_cols_list ( n ) : <NEWLINE> <INDENT> return [ Scanner . int ( ) for i in range ( n ) ] <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def solve ( ) : <NEWLINE> <INDENT> S = Scanner . string ( ) <NEWLINE> T = Scanner . string ( ) <NEWLINE> ma = len ( S ) - len ( T ) + 1 <NEWLINE> ans = len ( T ) <NEWLINE> for i in range ( 0 , ma ) : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> for j in range ( len ( T ) ) : <NEWLINE> <INDENT> if S [ i + j ] != T [ j ] : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> ans = min ( ans , cnt ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <COMMENT> <NL> <INDENT> sys . stdin = open ( <STRING> ) <NEWLINE> solve ( ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> t = input ( ) <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( s - t + 1 ) : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> for j in range ( len ( t ) ) : <NEWLINE> <INDENT> if s [ i + j ] == t [ j ] : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> ans = max ( ans , cnt ) <NEWLINE> <NL> <DEDENT> print ( len ( t ) - ans ) <NEWLINE>
strS = input ( ) <NEWLINE> strT = input ( ) <NEWLINE> <NL> maxRange = 0 <NEWLINE> l = 0 <NEWLINE> while l <= ( len ( strS ) - len ( strT ) ) : <NEWLINE> <INDENT> m = 0 <NEWLINE> count = 0 <NEWLINE> while m <= ( len ( strT ) ) : <NEWLINE> <INDENT> if strS [ l + m ] != strT [ m ] : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> m += 1 <NEWLINE> <DEDENT> if maxRange > count : <NEWLINE> <INDENT> maxRange = count <NEWLINE> <DEDENT> l += 1 <NEWLINE> <DEDENT> print ( maxRange ) <NEWLINE> <NL> <NL> <NL>
s = list ( input ( ) ) <NEWLINE> t = list ( input ( ) ) <NEWLINE> S = [ 0 for i in range ( len ( s ) - len ( t ) + 1 ) ] <NEWLINE> for i in range ( len ( s ) - len ( t ) + 1 ) : <NEWLINE> <INDENT> for j in range ( len ( t ) ) : <NEWLINE> <INDENT> if t [ j ] == s [ j + i ] : <NEWLINE> <INDENT> S [ i ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> S_max = max ( S ) <NEWLINE> print ( t - S_max ) <NEWLINE>
import sys <NEWLINE> <NL> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> input = sys . stdin . readline <NEWLINE> from math import floor , sqrt , factorial , hypot , log <COMMENT> <NEWLINE> from heapq import heappop , heappush , heappushpop <NEWLINE> from collections import Counter , defaultdict , deque <NEWLINE> from itertools import accumulate , permutations , combinations , product , combinations_with_replacement <NEWLINE> from bisect import bisect_left , bisect_right <NEWLINE> from copy import deepcopy <NEWLINE> from fractions import gcd <NEWLINE> from random import randint <NEWLINE> <NL> <NL> def ceil ( a , b ) : return ( a + b - 1 ) // b <NEWLINE> <NL> <NL> inf = float ( <STRING> ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> <NL> def pprint ( * A ) : <NEWLINE> <INDENT> for a in A : print ( * a , sep = <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> def INT_ ( n ) : return int ( n ) - 1 <NEWLINE> <NL> <NL> def MI ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <NL> def MF ( ) : return map ( float , input ( ) . split ( ) ) <NEWLINE> <NL> <NL> def MI_ ( ) : return map ( INT_ , input ( ) . split ( ) ) <NEWLINE> <NL> <NL> def LI ( ) : return list ( MI ( ) ) <NEWLINE> <NL> <NL> def LI_ ( ) : return [ int ( x ) - 1 for x in input ( ) . split ( ) ] <NEWLINE> <NL> <NL> def LF ( ) : return list ( MF ( ) ) <NEWLINE> <NL> <NL> def LIN ( n : int ) : return [ I ( ) for _ in range ( n ) ] <NEWLINE> <NL> <NL> def LLIN ( n : int ) : return [ LI ( ) for _ in range ( n ) ] <NEWLINE> <NL> <NL> def LLIN_ ( n : int ) : return [ LI_ ( ) for _ in range ( n ) ] <NEWLINE> <NL> <NL> def LLI ( ) : return [ list ( map ( int , l . split ( ) ) ) for l in input ( ) ] <NEWLINE> <NL> <NL> def I ( ) : return int ( input ( ) ) <NEWLINE> <NL> <NL> def F ( ) : return float ( input ( ) ) <NEWLINE> <NL> <NL> def ST ( ) : return input ( ) . replace ( <STRING> , <STRING> ) <NEWLINE> import sys <NEWLINE> import itertools <NEWLINE> import copy <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <INDENT> S = ST ( ) <NEWLINE> T = ST ( ) <NEWLINE> <NL> if T in S : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> len_s = len ( S ) <NEWLINE> len_t = len ( T ) <NEWLINE> diff = len_s - len_t <NEWLINE> match_list = [ ] <NEWLINE> for i in range ( diff ) : <NEWLINE> <INDENT> cnt_match = 0 <NEWLINE> for j in range ( len_t ) : <NEWLINE> <INDENT> if S [ j + i ] == T [ j ] : <NEWLINE> <INDENT> cnt_match += 1 <NEWLINE> <DEDENT> <DEDENT> match_list . append ( cnt_match ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> print ( len_t - max ( match_list ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> t = input ( ) <NEWLINE> ans = len ( t ) <NEWLINE> for i in range ( len ( s ) - len ( t ) + 1 ) : <NEWLINE> <INDENT> p = s [ i : i + len ( t ) ] <NEWLINE> cur = 0 <NEWLINE> for j in range ( len ( t ) ) : <NEWLINE> <INDENT> if t [ j ] != t [ i + j ] : <NEWLINE> <INDENT> cur += 1 <NEWLINE> <DEDENT> <DEDENT> ans = max ( ans , cur ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
s = input ( ) <NEWLINE> t = input ( ) <NEWLINE> ans = 10 ** 8 <NEWLINE> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> for j in range ( len ( t ) ) : <NEWLINE> <INDENT> if s [ i + j ] != t [ j ] : cnt += 1 <NEWLINE> <DEDENT> ans = min ( ans , cnt ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
S , T = input ( ) . split ( ) <NEWLINE> <NL> n = len ( S ) - len ( T ) + 1 <NEWLINE> moji = len ( T ) <NEWLINE> <NL> for a in range ( n ) : <NEWLINE> <INDENT> count = 0 <NEWLINE> for b in range ( len ( T ) ) : <NEWLINE> <INDENT> if S [ a + b ] != T [ b ] : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> if count < moji : <NEWLINE> <INDENT> moji = count <NEWLINE> <NL> <DEDENT> <DEDENT> print ( moji ) <NEWLINE>
import sys <NEWLINE> from sys import stdin <NEWLINE> input = stdin . readline <NEWLINE> <NL> INF = 10 ** 9 <NEWLINE> <NL> s = input ( ) <NEWLINE> t = input ( ) <NEWLINE> ans = 10 ** 10 <NEWLINE> ls = len ( s ) <NEWLINE> lt = len ( t ) <NEWLINE> for i in range ( ls - lt + 1 ) : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> for j in range ( lt : <NEWLINE> <INDENT> if ( s [ i + j ] != t [ j ] ) : cnt += 1 <NEWLINE> <DEDENT> ans = min ( cnt , ans ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
S = str ( input ( ) ) <NEWLINE> T = str ( input ( ) ) <NEWLINE> lens = len ( S ) <NEWLINE> lent = len ( T ) <NEWLINE> ans = [ ] <NEWLINE> <NL> for i in range ( s - t + 1 ) : <NEWLINE> <INDENT> count = 0 <NEWLINE> U = S [ i : i + t ] <NEWLINE> for i in range ( t ) : <NEWLINE> <INDENT> if U [ j ] != T [ j ] : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> ans . append ( count ) <NEWLINE> <DEDENT> print ( min ( ans ) ) <NEWLINE>
vs = input ( ) <NEWLINE> t = input ( ) <NEWLINE> <NL> stri = [ ] <NEWLINE> mincount = - 1 <NEWLINE> for i in range ( len ( s ) - len ( t ) + 1 ) : <NEWLINE> <INDENT> count = 0 <NEWLINE> for j in range ( len ( t ) ) : <NEWLINE> <INDENT> if ( s [ i + j ] == t [ j ] ) : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> mincount = max ( mincount , count ) <NEWLINE> <DEDENT> print ( len ( t ) - mincount ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <NL> int main ( void ) { <NEWLINE> <INDENT> char s [ 1000 ] ; <NEWLINE> char t [ 1000 ] ; <NEWLINE> scanf ( <STRING> , s ) ; <NEWLINE> scanf ( <STRING> , t ) ; <NEWLINE> int m [ strlen ( s ) ] ; <NEWLINE> for ( int i = 0 ; i < strlen ( s ) ; i + + ) { <NEWLINE> <INDENT> m [ i ] = 0 ; <NEWLINE> <DEDENT> } <NEWLINE> for ( int i = 0 ; i < strlen ( s ) ; i + + ) { <NEWLINE> <INDENT> for ( int j = 0 ; j < strlen ( t ) ; j + + ) { <NEWLINE> <INDENT> if ( s [ i ] == t [ j ] & & i >= j & & strlen ( s ) - i >= strlen ( t ) - j ) { <NEWLINE> <INDENT> for ( int k = j ; k < strlen ( s ) ; k + + ) { <NEWLINE> <INDENT> if ( s [ i + k - j ] == t [ k ] ) { <NEWLINE> <INDENT> m [ i ] + + ; <NEWLINE> <DEDENT> } <NEWLINE> else { <NEWLINE> <INDENT> break ; <NEWLINE> <DEDENT> } <NEWLINE> <DEDENT> } <NEWLINE> <DEDENT> } <NEWLINE> <DEDENT> } <NEWLINE> <DEDENT> } <NEWLINE> int max = 0 ; <NEWLINE> for ( int i = 0 ; i < strlen ( t ) ; i + + ) { <NEWLINE> <INDENT> if ( max < m [ i ] ) { <NEWLINE> <INDENT> max = m [ i ] ; <NEWLINE> <DEDENT> } <NEWLINE> <DEDENT> } <NEWLINE> printf ( <STRING> , strlen ( t ) - max ) ; <NEWLINE> return 0 ; <NEWLINE> <DEDENT> } <NEWLINE>
s = input ( ) <NEWLINE> t = input ( ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> ans = len ( t ) <NEWLINE> for i in range ( len ( s ) - len ( t ) ) : <NEWLINE> <INDENT> dif = 0 <NEWLINE> for j in range ( len ( t ) ) : <NEWLINE> <INDENT> if t [ j ] != s [ i : i + len ( t ) ] [ j ] : <NEWLINE> <INDENT> diff += 1 <NEWLINE> <DEDENT> <DEDENT> ans = min ( dif , ans ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> s = input ( ) <NEWLINE> t = input ( ) <NEWLINE> min_count = 1000 <NEWLINE> for i in range ( len ( s ) - len ( t ) + ) : <NEWLINE> <INDENT> count = 0 <NEWLINE> for j in range ( len ( t ) ) : <NEWLINE> <INDENT> if s [ i + j ] != t [ j ] : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> min_count = min ( count , min_count ) <NEWLINE> if min_count == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> print ( min_count ) <NEWLINE>
S = input ( ) <NEWLINE> T = input ( ) <NEWLINE> <NL> cnt = 0 <NEWLINE> <NL> for i in range ( len ( s ) - len ( t ) + 1 ) : <NEWLINE> <INDENT> same = 0 <NEWLINE> for j in range ( len ( t ) ) : <NEWLINE> <INDENT> if S [ i + j ] == T [ j ] : <NEWLINE> <INDENT> same += 1 <NEWLINE> <DEDENT> cnt = max ( same , cnt ) <NEWLINE> <DEDENT> <DEDENT> print ( len ( t ) - cnt ) <NEWLINE>
d , t , s = map ( int , input ( ) . split ( ) ) <NEWLINE> if d <= s * t : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
S = input ( ) <NEWLINE> T = input ( ) <NEWLINE> <NL> ans = 10000 <NEWLINE> <NL> for i inrange ( len ( S ) - len ( T ) + 1 ) : <NEWLINE> <INDENT> score = 0 <NEWLINE> U = S [ i : i + len ( T ) ] <COMMENT> <NEWLINE> for j in range ( len ( T ) ) : <NEWLINE> <INDENT> if U [ j ] != T [ J ] : <NEWLINE> <INDENT> score += 1 <NEWLINE> <DEDENT> <DEDENT> ans = min ( ans , score ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
Sr = input ( ) <NEWLINE> Tg = input ( ) <NEWLINE> <NL> ans = 10000 <NEWLINE> for i in range ( len ( Sr ) - len ( Tg ) + 1 ) : <NEWLINE> <INDENT> mat = 0 <NEWLINE> trimmedSr = Sr [ i : i + len ( Tg ) ] <NEWLINE> for j in range ( len ( Tg ) ) : <NEWLINE> <INDENT> if trimmedSr != Tg [ j ] : <NEWLINE> <INDENT> mat + + ; <NEWLINE> <DEDENT> <DEDENT> ans = min ( mat , ans ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
s = input ( ) <NEWLINE> t = input ( ) <NEWLINE> <NL> count_min = 1000 <NEWLINE> <NL> for i in range ( len ( s ) - len ( t ) + 1 ) : <NEWLINE> <INDENT> count = 0 <NEWLINE> for j in range ( len ( t ) ) : <NEWLINE> <INDENT> if s [ i + j ] != t [ j ] : <NEWLINE> <INDENT> count + + <NEWLINE> <DEDENT> <DEDENT> if count < count_min : <NEWLINE> <INDENT> count_min = count <NEWLINE> <NL> <DEDENT> <DEDENT> print ( count_min ) <NEWLINE>
S = str ( input ( ) ) <NEWLINE> T = str ( input ( ) ) <NEWLINE> tempcount = 0 <NEWLINE> mincount = 0 <NEWLINE> <NL> if S in T : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit <NEWLINE> <NL> <DEDENT> for i in range ( len ( S ) - len ( T ) + 1 ) : <NEWLINE> <INDENT> for j in range ( len ( T ) + 1 ) : <NEWLINE> <INDENT> if S [ i + j ] != T [ j ] : <NEWLINE> <INDENT> tempcount += 1 <NEWLINE> <DEDENT> <DEDENT> if i == 0 : <NEWLINE> <INDENT> mincount = tempcount <NEWLINE> <DEDENT> elif tempcount < mincount : <NEWLINE> <INDENT> mincount = tempcount <NEWLINE> <DEDENT> tempcount = 0 <NEWLINE> <NL> <DEDENT> print ( mincount ) <NEWLINE> <NL>
s = input ( ) <NEWLINE> t = input ( ) <NEWLINE> minCount = 100000000 <NEWLINE> i = 0 <NEWLINE> while i < len ( s ) and i + j < len ( s ) : <NEWLINE> <INDENT> countSame = 0 <NEWLINE> j = 0 <NEWLINE> while j < len ( t ) : <NEWLINE> <INDENT> if t [ j ] == s [ i + j ] : <NEWLINE> <INDENT> countSame += 1 <NEWLINE> <DEDENT> j += 1 <NEWLINE> minCount = min ( len ( t ) - countSame , minCount ) <NEWLINE> <DEDENT> i += 1 <NEWLINE> <DEDENT> print ( minCount ) <NEWLINE>
S = input ( ) <NEWLINE> T = input ( ) <NEWLINE> <NL> min = length ( T ) <NEWLINE> <NL> for index in range ( length ( S ) - length ( T ) + 1 ) : <NEWLINE> <INDENT> temp = 0 <NEWLINE> for index2 in range ( T ) : <NEWLINE> <INDENT> if T [ index2 ] == S [ index + index2 ] : <NEWLINE> <INDENT> temp += 1 <NEWLINE> <DEDENT> <DEDENT> if temp < min : <NEWLINE> <INDENT> min = temp <NEWLINE> <NL> <DEDENT> <DEDENT> print ( min ) <NEWLINE>
s = input ( ) <NEWLINE> t = input ( ) <NEWLINE> maxi = 0 <NEWLINE> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> maxG = 0 <NEWLINE> print ( s [ i : len ( t ) + i ] ) <NEWLINE> if len ( s [ i : len ( t ) + i ] ) >= len ( t ) : <NEWLINE> <INDENT> for l , j in zip ( s [ i : len ( t ) + i ] , t ) : <NEWLINE> <INDENT> if l == j : <NEWLINE> <INDENT> maxG += 1 <NEWLINE> <DEDENT> <DEDENT> maxi = max ( maxi , maxG ) <NEWLINE> else : <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( len ( t ) - maxi ) <NEWLINE>
s = input ( ) <NEWLINE> t = input ( ) <NEWLINE> strs = [ ] <NEWLINE> t_size = len ( t ) <NEWLINE> for i in np . arange ( len ( s ) - len ( t ) + 1 ) : <NEWLINE> <INDENT> strs . append ( s [ i : i + t_size ] ) <NEWLINE> <DEDENT> n = 0 <NEWLINE> max_n = 0 <NEWLINE> for ss in strs : <NEWLINE> <INDENT> for i in np . arange ( len ( t ) ) : <NEWLINE> <INDENT> if t [ i ] == ss [ i ] : <NEWLINE> <INDENT> n += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> n = 0 <NEWLINE> <DEDENT> if max_n < n : <NEWLINE> <INDENT> max_n = n <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( len ( t ) - max_n ) <NEWLINE>
S = input ( ) <NEWLINE> T = input ( ) <NEWLINE> import re <NEWLINE> <NL> def x ( ) : <NEWLINE> <INDENT> for i in range ( len ( T ) , 0 , - 1 ) : <COMMENT> <NEWLINE> <INDENT> for j in range ( len ( T ) - i ) : <COMMENT> <NEWLINE> <INDENT> t = T [ j : i + j ] <NEWLINE> for m in re . finditer ( t , S ) : <NEWLINE> <INDENT> p = m . start ( ) <NEWLINE> if p != - 1 : <NEWLINE> <INDENT> if j <= p and len ( T ) - j - 1 <= len ( S ) - p - 1 : <NEWLINE> <INDENT> return i <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> return 0 <NEWLINE> <DEDENT> print ( len ( T ) - t ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> sums = 0 <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n ) : <NEWLINE> <INDENT> sums += ( a [ i ] * a [ j ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( sums % ( 10 ** 9 + 7 ) ) <NEWLINE>
s = input ( ) <COMMENT> <NEWLINE> t = input ( ) <COMMENT> <NEWLINE> sl = len ( s ) <COMMENT> <NEWLINE> tl = input ( t ) <COMMENT> <NEWLINE> ans = tl <COMMENT> <NEWLINE> for i in range ( sl - tl + 1 ) : <COMMENT> <NEWLINE> <INDENT> c = 0 <NEWLINE> for j in range ( min ( tl , sl ) : <COMMENT> <NEWLINE> <INDENT> if ( s [ i + j ] != t [ j ] : <COMMENT> <NEWLINE> <INDENT> c += 1 <NEWLINE> <DEDENT> <DEDENT> ans = min ( c , ans ) <COMMENT> <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
S , T = list ( input ( ) . split ( ) ) <NEWLINE> s = len ( S ) <NEWLINE> t = len ( T ) <NEWLINE> l1 = [ ] <NEWLINE> l2 = [ ] <NEWLINE> n = 0 <NEWLINE> for i in range ( n , s - t + 1 ) : <NEWLINE> <INDENT> ss = S [ n : t + n ] <NEWLINE> n += 1 <NEWLINE> m = 0 <NEWLINE> for x in ss : <NEWLINE> <INDENT> if x == T [ m ] : <NEWLINE> <INDENT> l1 . append ( 1 ) <NEWLINE> m += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> l1 . append ( 0 ) <NEWLINE> m += 1 <NEWLINE> <DEDENT> <DEDENT> l2 . append ( sum ( l1 ) ) <NEWLINE> l1 = [ ] <NEWLINE> <DEDENT> print ( t - max ( l2 ) ) <NEWLINE>
s = list ( input ( ) ) <NEWLINE> t = list ( input ( ) ) <NEWLINE> <NL> ln = len ( s ) <NEWLINE> lt = len ( t ) <NEWLINE> n = ls - lt + 1 <NEWLINE> l = [ ] <NEWLINE> <NL> cnt = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( lt ) : <NEWLINE> <INDENT> if t [ j ] != s [ i + j ] : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> l . append ( cnt ) <NEWLINE> cnt = 0 <NEWLINE> <NL> <DEDENT> print ( min ( l ) ) <NEWLINE>
s = input ( ) <NEWLINE> t = input ( ) <NEWLINE> <NL> cnt1 = 0 <NEWLINE> if len ( s ) == len ( t ) : <NEWLINE> <INDENT> for i in range ( len ( t ) ) : <NEWLINE> <INDENT> if s [ i ] != t [ i ] : <NEWLINE> <INDENT> cnt1 += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( cnt1 ) <NEWLINE> else : <NEWLINE> <INDENT> cnt = [ ] <NEWLINE> for i in range ( len ( t ) ) : <NEWLINE> <INDENT> for k in range ( i + 1 , len ( t ) + 1 ) : <NEWLINE> <INDENT> if t [ i : k ] in s [ i : ] : <NEWLINE> <INDENT> cnt . append ( k - i ) <NEWLINE> print ( t [ i : k ] , s [ i : ] , k - i ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cnt . append ( 0 ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( len ( t ) - max ( cnt ) ) <NEWLINE>
s = input ( ) <NEWLINE> t = input ( ) <NEWLINE> <NL> ans = 10000 <NEWLINE> for i in range ( len ( s ) - len ( t ) + 1 ) : <NEWLINE> <INDENT> tmp = 0 <NEWLINE> for i in range ( len ( t ) ) : <NEWLINE> <INDENT> if s [ i + j ] != s [ j ] : <NEWLINE> <INDENT> tmp += 1 <NEWLINE> <DEDENT> ans = min ( ans , tmp ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
S = input ( ) <NEWLINE> T = input ( ) <NEWLINE> <NL> for i in range ( 0 , len ( S ) - len ( T ) + 1 ) : <NEWLINE> <INDENT> score = 0 <NEWLINE> for j in range ( 0 , len ( T ) ) : <NEWLINE> <INDENT> if ( S [ i ] != T [ i + j ] ) : <NEWLINE> <INDENT> score += 1 <NEWLINE> <DEDENT> <DEDENT> score = min ( score , len ( T ) ) <NEWLINE> <DEDENT> print ( score ) <NEWLINE>
import os <NEWLINE> import sys <NEWLINE> from collections import defaultdict , Counter <NEWLINE> from itertools import product , permutations , combinations , accumulate <NEWLINE> from operator import itemgetter <NEWLINE> from bisect import bisect_left , bisect <NEWLINE> from heapq import heappop , heappush , heapify <NEWLINE> from math import ceil , floor , sqrt <NEWLINE> from copy import deepcopy <NEWLINE> import numpy <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> alist = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> max_num = 10 ** 9 + 7 <NEWLINE> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ans += numpy . cumsum ( alist [ : i + 1 ] ) <NEWLINE> <NL> <DEDENT> print ( ans % max_num ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> mod = 10 ** 9 + 7 <NEWLINE> <NL> A = sum ( a ) <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> for i in a : <NEWLINE> <INDENT> A -= i <NEWLINE> A %= mod <NEWLINE> ans += A * x <NEWLINE> ans %= mod <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL>
mod = 10 ** 9 + 7 <NEWLINE> n = int ( input ( ) ) <NEWLINE> a_list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> result = 0 <NEWLINE> a_sum = sum ( a ) <NEWLINE> for i in a_list : <NEWLINE> <INDENT> a_sum -= i <NEWLINE> result += i * a_sum <NEWLINE> <DEDENT> print ( result % mod ) <NEWLINE>
import numpy as np <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = numpy . array ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> ans = ( ans + A [ i ] * numpy . sum ( A [ i + 1 : N ] ) ) % ( 10 ** 9 + 7 ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> A = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <COMMENT> <NL> a_cum = [ 0 ] * ( n + 1 ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a_cum [ i + 1 ] = a_cum [ i ] + A [ i ] <NEWLINE> <DEDENT> ans = 0 <NEWLINE> for i in range ( len ( A ) - 1 ) : <NEWLINE> <INDENT> ans += A [ i ] * ( a_cum [ n ] - a_cum [ i + 1 ] ) % mod <NEWLINE> ans %= mod <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> A = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <COMMENT> <NL> a_cum = [ 0 ] * ( n + 1 ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a_cum [ i + 1 ] = a_cum [ i ] + A [ i ] <NEWLINE> <DEDENT> ans = 0 <NEWLINE> for i in range ( len ( A ) - 1 ) : <NEWLINE> <INDENT> ans += A [ i ] * ( a_cum [ n ] - a_cum [ i + 1 ] ) <NEWLINE> <DEDENT> ans %= mod <NEWLINE> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> x = sum ( A ) <NEWLINE> y = sum ( [ A [ i ] ** 2 for i in range ( n ) ] ) <NEWLINE> <NL> print ( ( ( x ** 2 - y ) / 2 ) % ( 10 ** 9 + 7 ) ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> mod = 10 ** 9 + 7 <NEWLINE> <COMMENT> <NL> n = int ( input ( ) ) <NEWLINE> a = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> aa = [ a ** 2 % mod for x in a ] <NEWLINE> ans = 0 <NEWLINE> asum = sum ( a ) <NEWLINE> p = asum ** 2 % mod <NEWLINE> q = sum ( aa ) % mod <NEWLINE> ans = ( p - q ) % mod <NEWLINE> if ans < 0 : <NEWLINE> <INDENT> ans += mod <NEWLINE> <DEDENT> if ans % 2 == 1 : <NEWLINE> <INDENT> ans += mod <NEWLINE> <DEDENT> ans = ans // 2 <NEWLINE> print ( ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> sum = 0 <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> sum_a += A [ i ] <NEWLINE> <NL> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> sum_a -= A [ i ] <NEWLINE> sum += A [ i ] * sum_a <NEWLINE> ans = sum % ( 10 ** 9 + 7 ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
a = input ( ) <NEWLINE> a = np . array ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> count = 1 <NEWLINE> tmp = 0 <NEWLINE> for i in a [ : - 1 ] : <NEWLINE> <INDENT> tmp = ( tmp + i * ( a [ count : ] ) . sum ( ) ) % ( 10 ** 9 + 7 ) <NEWLINE> count += 1 <NEWLINE> <DEDENT> print ( tmp ) <NEWLINE>
<COMMENT> <NL> <STRING> <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> <NL> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> count1 = 0 <NEWLINE> count2 = 0 <NEWLINE> count = 10 ** 9 + 7 <NEWLINE> for i in A : <NEWLINE> <INDENT> count1 += i <NEWLINE> count1 = count1 % count <NEWLINE> <DEDENT> for j in A : <NEWLINE> <INDENT> count2 = j * ( count1 - j ) % count + count2 <NEWLINE> count1 = count1 - j <NEWLINE> <NL> <DEDENT> print ( count2 % count ) <NEWLINE> <NL> <NL>
A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> B = [ 0 ] * N <NEWLINE> <NL> num = 0 <NEWLINE> for i in reversed ( range ( N ) ) : <NEWLINE> <INDENT> B [ i ] = A [ i ] + num <NEWLINE> num = B [ i ] <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> ans += A [ i ] * B [ i + 1 ] <NEWLINE> <NL> <DEDENT> print ( ans % 1000000007 ) <NEWLINE>
for i in range ( N - 1 ) : <NEWLINE> <INDENT> tmp += A [ i ] <NEWLINE> ans += tmp * A [ i + 1 ] <NEWLINE> <DEDENT> print ( ans % ( ( 10 ** 9 ) + 7 ) ) <NEWLINE>
f = open ( <STRING> , <STRING> ) <NEWLINE> input = lambda : f . readline ( ) . strip ( ) <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> r = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> mod = 1000000007 <NEWLINE> s = sum ( r ) % mod <NEWLINE> x = 0 <NEWLINE> for u in r : <NEWLINE> <INDENT> x += u ** 2 <NEWLINE> <DEDENT> x %= mod <NEWLINE> t = 500000004 <NEWLINE> print ( ( s ** 2 - x ) * t % mod ) <NEWLINE>
L = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> sum = 0 <NEWLINE> product = 0 <NEWLINE> mod = 1000000007 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> sum += L [ i ] % mod <NEWLINE> <DEDENT> for i in range ( n - 1 ) : <NEWLINE> <INDENT> sum -= ( L [ i ] % mod ) <NEWLINE> product += sum * ( L [ i ] % mod ) <NEWLINE> <DEDENT> print ( product ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> array = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> list2 = [ ] <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n ) : <NEWLINE> <INDENT> list2 . append ( array [ i ] * array [ j ] ) <NEWLINE> <DEDENT> <DEDENT> a = n * ( n - 1 ) / 2 <NEWLINE> ans = 0 <NEWLINE> for m in range ( a ) : <NEWLINE> <INDENT> ans = ans + list2 [ m ] <NEWLINE> if ans >= 10 ** 9 + 7 : <NEWLINE> <INDENT> ans = ans - ( 10 ** 9 + 7 ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> left = 0 <NEWLINE> right = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> left += a [ i ] <NEWLINE> left %= ( 10 ** 9 + 7 ) <NEWLINE> <DEDENT> for j in range ( n ) : <NEWLINE> <INDENT> right += a [ j ] <NEWLINE> right %= ( 10 ** 9 + 7 ) <NEWLINE> <DEDENT> c = ( left * right ) % ( 10 ** 9 + 7 ) <NEWLINE> l = [ ( k ** 2 ) % ( 10 ** 9 + 7 ) for k in a ] <NEWLINE> print ( ( ( c + ( 10 ** 9 + 7 ) - sum ( l ) ) ** ( 10 ** 9 + 5 ) ) % ( 10 ** 9 + 7 ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if n == 1 : <NEWLINE> print ( a [ 0 ] ) <NEWLINE> else : <NEWLINE> l = list ( map ( lambda z : z ** 2 , a ) <NEWLINE> x = sum ( a ) <NEWLINE> y = sum ( l ) <NEWLINE> t = ( x - y ) // 2 <NEWLINE> if t > ( 10 ** 9 + 7 ) : <NEWLINE> <INDENT> print ( t % ( 10 ** 9 + 7 ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( t ) <NEWLINE> <DEDENT>
n = input ( ) <NEWLINE> a = input ( ) . split ( ) <NEWLINE> sum = 0 <NEWLINE> for i in range ( len ( a ) ) : <NEWLINE> <INDENT> a [ i ] = ( int ) ( a [ i ] ) <NEWLINE> <DEDENT> for i in a : <NEWLINE> <INDENT> sum += i <NEWLINE> <DEDENT> ans = 0 <NEWLINE> ans += ( sum ** 2 ) <NEWLINE> for i in a : <NEWLINE> <INDENT> ans -= i * i <NEWLINE> <DEDENT> return ( ans / 2 ) % ( 10 ** 9 + 7 ) <NEWLINE>
def findProductSum ( A , n ) : <NEWLINE> <NL> <COMMENT> <NL> <INDENT> array_sum = 0 <NEWLINE> for i in range ( 0 , n , 1 ) : <NEWLINE> <INDENT> array_sum = array_sum + A [ i ] <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> array_sum_square = array_sum * array_sum <NEWLINE> <NL> <COMMENT> <NL> individual_square_sum = 0 <NEWLINE> for i in range ( 0 , n , 1 ) : <NEWLINE> <INDENT> individual_square_sum += A [ i ] * A [ i ] <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> temp = int ( array_sum_square - <NEWLINE> <INDENT> individual_square_sum ) / 2 <NEWLINE> <DEDENT> return temp % 1000000007 <NEWLINE> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <DEDENT> list = list ( ) <NEWLINE> n = int ( input ( ) ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> l = int ( input ( ) ) <NEWLINE> list . append ( l ) <NEWLINE> <DEDENT> print ( findProductSum ( list , n ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> h = sum ( a ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> h -= a [ i ] <NEWLINE> ans = ( ans + ( a [ i ] * ( h ) ) % ( 10 ** 9 + 7 ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL>
n = int ( inoput ( ) ) <NEWLINE> a = list ( map ( int , input ( ) ) ) <NEWLINE> total = 0 <NEWLINE> for i in range ( 0 , n - 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , n ) : <NEWLINE> <INDENT> total += a [ i ] * a [ j ] <NEWLINE> <DEDENT> <DEDENT> print ( total % ( 10 ** 9 + 7 ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> arr = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> sum_arr = sum ( arr ) <NEWLINE> <NL> for x in arr : <NEWLINE> <INDENT> ans += x * ( sum_arr - x ) // 2 <NEWLINE> ans %= MOD <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> count = 0 <NEWLINE> su = sum [ a ] <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> su -= a [ i ] <NEWLINE> count += a [ i ] * su <NEWLINE> <DEDENT> print ( count % ( 10 ** 9 + 7 ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> su = l [ 0 ] <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> ans += su * l [ i ] <NEWLINE> ans %= mod <NEWLINE> su += l [ i ] <NEWLINE> su %= mod <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> <NL> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> S = sum ( A ) <NEWLINE> <NL> for i in range ( N - 1 ) : <NEWLINE> <INDENT> S -= A [ i ] <NEWLINE> ans += A [ i ] * S <NEWLINE> <NL> <NL> <DEDENT> ans = ans % ( 10 ** 9 + 7 ) <NEWLINE> <NL> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> count = 0 <NEWLINE> num = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> while count != N : <NEWLINE> <INDENT> count = i <NEWLINE> try : <NEWLINE> <INDENT> C = i + 1 <NEWLINE> num += A [ i ] * A [ C ] <NEWLINE> C += 1 <NEWLINE> count += 1 <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( num ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> s = 0 <NEWLINE> ans = 0 <NEWLINE> for i in range ( len ( a ) ) : <NEWLINE> <INDENT> s += a [ i ] <NEWLINE> <DEDENT> for i in range ( len ( a ) - 1 ) : <NEWLINE> <INDENT> s -= a [ i ] <NEWLINE> if s < 0 : <NEWLINE> s += 1e9 + 7 <NEWLINE> ans += s * a [ i ] <NEWLINE> ans %= 1e9 + 7 <NEWLINE> <DEDENT> print ( int ( ans ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> pans = 0 <NEWLINE> sum_ = sum ( a ) % ( 10 ** 9 + 7 ) <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> sum -= a [ i ] <NEWLINE> ans = sum * a [ i ] <NEWLINE> ans = ans % ( 10 ** 9 + 7 ) <NEWLINE> pans += ans <NEWLINE> <DEDENT> print ( pans % ( 10 ** 9 + 7 ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> pref = [ 0 ] * n <NEWLINE> pref [ 0 ] = a [ 0 ] % m <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> pref [ i ] = ( pref [ i - 1 ] + a [ i ] ) % m <NEWLINE> <DEDENT> m = 10 ** 9 + 7 <NEWLINE> ans = 0 <NEWLINE> <COMMENT> <NL> for i in range ( n - 1 ) : <NEWLINE> <INDENT> ans += ( a [ i ] % m * ( ( pref [ n - 1 ] - pref [ i ] ) % m ) ) % m <NEWLINE> ans = ans % m <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <COMMENT> <NL> <NEWLINE>
n = int ( input ( ) ) <NEWLINE> A = [ int ( x ) % ( 1e9 + 7 ) for x in input ( ) . split ( ) ] <NEWLINE> <NL> <COMMENT> <NL> array_sum = 0 <NEWLINE> for i in range ( 0 , n , 1 ) : <NEWLINE> <INDENT> array_sum = ( array_sum + A [ i ] ) % ( 1e9 + 7 ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> array_sum_square = ( array_sum * array_sum ) % ( 1e9 + 7 ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> individual_square_sum = 0 <NEWLINE> for i in range ( 0 , n , 1 ) : <NEWLINE> <INDENT> individual_square_sum += ( A [ i ] * A [ i ] ) % ( 1e9 + 7 ) <NEWLINE> individual_square_sum = individual_square_sum % ( 1e9 + 7 ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> print ( array_sum_square - individual_square_sum ) / 2 <NEWLINE>
from numba import njit <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> @ njit <NEWLINE> def solution ( A , N ) : <NEWLINE> <INDENT> mod = ( 10 ** 9 ) + 7 <NEWLINE> res = 0 <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , N ) : <NEWLINE> <INDENT> res += ( ( A [ i ] % mod ) * ( A [ j ] % mod ) ) % mod <NEWLINE> <DEDENT> <DEDENT> return res <NEWLINE> <NL> <DEDENT> mod = ( 10 ** 9 ) + 7 <NEWLINE> res = solution ( A , N ) <NEWLINE> print ( res % mod ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = [ int ( num ) for num in input ( ) . split ( ) ] <NEWLINE> <NL> sumA = sum ( A ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( len ( A ) ) : <NEWLINE> <INDENT> sumA = sumA - A [ i ] <NEWLINE> ans += A [ i ] * sumA <NEWLINE> <NL> <NL> <DEDENT> ans = ans % ( 10 ** 9 ) + 7 ) <NEWLINE> print ( ans ) <NEWLINE>
n = input ( ) <NEWLINE> vals = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> s = sum ( vals ) <NEWLINE> ret = 0 <NEWLINE> for i , val in enumerate ( vals ) : <NEWLINE> <INDENT> ret += val * ( s - val ) <NEWLINE> <NL> <DEDENT> mod = 10 ** 9 + 7 <NEWLINE> print ( int ( ret / 2 ) % mod ) ) <NEWLINE>
mod = int ( 1e9 + 7 ) <NEWLINE> <NL> def pw ( b , ex ) : <NEWLINE> <INDENT> if ex == 0 : return 1 <NEWLINE> if ex == 1 : return b <NEWLINE> if ex & 1 : return b % mod * pw ( ( b * b ) % mod , ex >> 1 ) % mod <NEWLINE> return pw ( ( b * b ) % mod , ex >> 1 ) % mod <NEWLINE> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> x = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> st = 0 <NEWLINE> en = 0 <NEWLINE> <NL> for i in x : <NEWLINE> <INDENT> st = ( st + i ) % mod <NEWLINE> en = ( en + ( i * i ) % mod ) % mod <NEWLINE> <NL> <DEDENT> ans = int ( ( st * st - en + mod ) % mod ) <NEWLINE> ans = int ( ans * int ( pw ( 2 , mod - 2 ) ) % mod ) % mod <NEWLINE> print ( int ( ans ) ) <NEWLINE> <NL> mod = int ( 1e9 + 7 ) <NEWLINE> <NL> def pw ( b , ex ) : <NEWLINE> <INDENT> if ex == 0 : return 1 <NEWLINE> if ex == 1 : return b <NEWLINE> if ex & 1 : return b % mod * pw ( ( b * b ) % mod , ex >> 1 ) % mod <NEWLINE> return pw ( ( b * b ) % mod , ex >> 1 ) % mod <NEWLINE> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> x = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> st = 0 <NEWLINE> en = 0 <NEWLINE> <NL> for i in x : <NEWLINE> <INDENT> st = ( st + i ) % mod <NEWLINE> en = ( en + ( i * i ) % mod ) % mod <NEWLINE> <NL> <DEDENT> ans = int ( ( st * st - en + mod ) % mod ) <NEWLINE> ans = int ( ans * int ( pw ( 2 , mod - 2 ) ) % mod ) % mod <NEWLINE> print ( int ( ans ) ) <NEWLINE> <NL>
n = int ( input ( ) ) <NEWLINE> lis = list ( map ( int , input ( ) . split ( ) ) <NEWLINE> sum = 0 <NEWLINE> for i in lis : <NEWLINE> <INDENT> for j in lis : <NEWLINE> <INDENT> sum += i * j <NEWLINE> <DEDENT> <DEDENT> print ( sum % 1000000009 ) <NEWLINE>
from C import ans <NEWLINE> <NL> <NL> n = int ( input ( ) ) <NEWLINE> n_list = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> s = sum ( a ** 2 for a in n_list ) <NEWLINE> ans = sum ( n_list ) ** 2 - s <NEWLINE> <NL> print ( ( ans // 2 ) % ( 10 ** 9 + 7 ) ) <NEWLINE>
import sys <NEWLINE> <NL> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> input = sys . stdin . readline <NEWLINE> from math import floor , sqrt , factorial , hypot , log <COMMENT> <NEWLINE> from heapq import heappop , heappush , heappushpop <NEWLINE> from collections import Counter , defaultdict , deque <NEWLINE> from itertools import accumulate , permutations , combinations , product , combinations_with_replacement <NEWLINE> from bisect import bisect_left , bisect_right <NEWLINE> from copy import deepcopy <NEWLINE> from fractions import gcd <NEWLINE> from random import randint <NEWLINE> <NL> <NL> def ceil ( a , b ) : return ( a + b - 1 ) // b <NEWLINE> <NL> <NL> inf = float ( <STRING> ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> <NL> def pprint ( * A ) : <NEWLINE> <INDENT> for a in A : print ( * a , sep = <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> def INT_ ( n ) : return int ( n ) - 1 <NEWLINE> <NL> <NL> def MI ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <NL> def MF ( ) : return map ( float , input ( ) . split ( ) ) <NEWLINE> <NL> <NL> def MI_ ( ) : return map ( INT_ , input ( ) . split ( ) ) <NEWLINE> <NL> <NL> def LI ( ) : return list ( MI ( ) ) <NEWLINE> <NL> <NL> def LI_ ( ) : return [ int ( x ) - 1 for x in input ( ) . split ( ) ] <NEWLINE> <NL> <NL> def LF ( ) : return list ( MF ( ) ) <NEWLINE> <NL> <NL> def LIN ( n : int ) : return [ I ( ) for _ in range ( n ) ] <NEWLINE> <NL> <NL> def LLIN ( n : int ) : return [ LI ( ) for _ in range ( n ) ] <NEWLINE> <NL> <NL> def LLIN_ ( n : int ) : return [ LI_ ( ) for _ in range ( n ) ] <NEWLINE> <NL> <NL> def LLI ( ) : return [ list ( map ( int , l . split ( ) ) ) for l in input ( ) ] <NEWLINE> <NL> <NL> def I ( ) : return int ( input ( ) ) <NEWLINE> <NL> <NL> def F ( ) : return float ( input ( ) ) <NEWLINE> <NL> <NL> def ST ( ) : return input ( ) . replace ( <STRING> , <STRING> ) <NEWLINE> import sys <NEWLINE> import itertools <NEWLINE> import copy <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> N = I ( ) <NEWLINE> a_list = LI ( ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> cnt = 0 <NEWLINE> for i in list ( itertools . combinations ( list ( range ( N ) ) , 2 ) ) : <NEWLINE> <COMMENT> <NL> <INDENT> if i [ 0 ] < i [ 1 ] : <NEWLINE> <INDENT> tmp = a_list [ i [ 0 ] ] * a_list [ i [ 1 ] ] <NEWLINE> cnt += tmp <NEWLINE> <DEDENT> <DEDENT> print ( cnt % ( 10 ** 9 + 7 ) ) <NEWLINE> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> sum1 = 0 <NEWLINE> sum2 = 0 <NEWLINE> <NL> for _ in a : <NEWLINE> <INDENT> sum1 += _ <NEWLINE> sum2 += ( a * a ) <NEWLINE> <DEDENT> sum1 = ( sum1 * sum1 ) <NEWLINE> print ( sum1 - sum2 ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> sigma = 0 <NEWLINE> after = sum ( a [ 0 : ] ) <NEWLINE> for i in range ( len ( a ) - 1 ) : <NEWLINE> <INDENT> start = a [ i ] <NEWLINE> after = after - [ i ] <NEWLINE> if after >= ( 10 ** 9 + 7 ) : <NEWLINE> <INDENT> after = after % ( 10 ** 9 + 7 ) <NEWLINE> <DEDENT> sigma = sigma + start * after <NEWLINE> if sigma >= ( 10 ** 9 + 7 ) : <NEWLINE> <INDENT> sigma = sigma % ( 10 ** 9 + 7 ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( sigma ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> partial_sum = copy . deepcopy ( A ) <NEWLINE> sum_now = A [ N - 1 ] <NEWLINE> for j in range ( N - 2 , - 1 , - 1 ) : <NEWLINE> <INDENT> sum_now = int ( ( sum_now + A [ j ] ) % mod ) <NEWLINE> partial_sum [ j ] = sum_now <NEWLINE> <DEDENT> res = 0 <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> res = ( res + ( A [ i ] * partial_sum [ i + 1 ] ) % mod ) % mod <NEWLINE> <DEDENT> print ( int ( res ) ) <NEWLINE>
<COMMENT> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <COMMENT> <NL> S = [ 0 ] * N <NEWLINE> for n in range ( N ) : <NEWLINE> <INDENT> S [ n ] = S [ n - 1 ] + A [ n ] <NEWLINE> <NL> <DEDENT> _sum = int ( 0 ) <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> _sum = _sum + int ( ( A [ i ] * ( S [ N ] - S [ i ] ) ) ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> _sum = _sum % ( 1000000000 + 7 ) <NEWLINE> <NL> print ( _sum ) <NEWLINE>
import numpy as np <NEWLINE> A = np . asarray ( input ( ) . split ( ) ) . astype ( np . int ) <NEWLINE> <NL> ans = 0 <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> pA = ( A [ i ] % mod ) * ( A [ i + 1 : ] . sum ( ) % mod ) <NEWLINE> ans += pA <NEWLINE> <NL> <DEDENT> print ( int ( ans % mod ) ) <NEWLINE>
sum_ = 0 <NEWLINE> temp = 0 <NEWLINE> for i in range ( len ( a ) - 1 ) : <NEWLINE> <INDENT> temp += a [ - i - 1 ] <NEWLINE> sum_ += temp * a [ - i - 2 ] <NEWLINE> <NL> <DEDENT> print ( sum_ % ( 10 ** 9 + 7 ) ) <NEWLINE>
// g + + - std = gnu + + 14 a . cpp <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> using namespace std ; <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> ll MOD = 1e9 + 7 ; <NEWLINE> int INF = 1 << 30 ; <NEWLINE> ll INFL = 1 LL << 60 ; <NEWLINE> ll MODP = 998244353 ; <NEWLINE> <NL> void dfs ( int x , vector < vector < int >> & v , vector < int > & g , int & num ) { <NEWLINE> <INDENT> int x_size = v [ x ] . size ( ) ; <NEWLINE> if ( x > 0 ) { <NEWLINE> <INDENT> rep ( i , x_size ) { <NEWLINE> <INDENT> if ( g [ v [ x ] [ i ] ] == 0 ) { <NEWLINE> <INDENT> g [ v [ x ] [ i ] ] = num ; <NEWLINE> dfs ( v [ x ] [ i ] , v , g , num ) ; <NEWLINE> <DEDENT> } <NEWLINE> <DEDENT> } <NEWLINE> <DEDENT> } <NEWLINE> <DEDENT> } <NEWLINE> <NL> int main ( ) { <NEWLINE> <INDENT> int N , M ; <NEWLINE> cin >> N >> M ; <NEWLINE> vector < int > A ( M ) , B ( M ) , group ( N + 10 , 0 ) ; <NEWLINE> rep ( i , M ) cin >> A [ i ] >> B [ i ] ; <NEWLINE> vector < vector < int >> G ( N + 10 ) ; <NEWLINE> rep ( i , M ) { <NEWLINE> <INDENT> G [ A [ i ] ] . push_back ( B [ i ] ) ; <NEWLINE> G [ B [ i ] ] . push_back ( A [ i ] ) ; <NEWLINE> <DEDENT> } <NEWLINE> int num = 1 ; <NEWLINE> for ( int i = 1 ; i <= N ; i + + ) { <NEWLINE> <INDENT> if ( group [ i ] == 0 ) { <NEWLINE> <INDENT> group [ i ] = num ; <NEWLINE> dfs ( i , G , group , num ) ; <NEWLINE> num + + ; <NEWLINE> <DEDENT> } <NEWLINE> <DEDENT> } <NEWLINE> vector < int > cnt ( N + 10 , 0 ) ; <NEWLINE> for ( int i = 1 ; i <= N ; i + + ) { <NEWLINE> <INDENT> cnt [ group [ i ] ] + + ; <NEWLINE> <DEDENT> } <NEWLINE> int ans = - 1 ; <NEWLINE> for ( int i = 1 ; i <= N ; i + + ) { <NEWLINE> <INDENT> if ( ans < cnt [ i ] ) ans = cnt [ i ] ; <NEWLINE> <DEDENT> } <NEWLINE> cout << ans << endl ; <NEWLINE> <DEDENT> / * <NEWLINE> <INDENT> for ( int i = 1 ; i <= N ; i + + ) { <NEWLINE> <INDENT> cout << group [ i ] << <STRING> ; <NEWLINE> <DEDENT> } <NEWLINE> cout << endl ; <NEWLINE> for ( int i = 1 ; i <= N ; i + + ) { <NEWLINE> <INDENT> cout << G [ i ] . size ( ) << <STRING> ; <NEWLINE> <DEDENT> } <NEWLINE> cout << endl ; <NEWLINE> <DEDENT> * / <NEWLINE> <INDENT> return 0 ; <NEWLINE> <DEDENT> } <NEWLINE>
n = input ( ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = sum ( a ) <NEWLINE> sum = 0 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> b -= a [ i ] <NEWLINE> sum += a [ i ] * b <NEWLINE> <NL> <DEDENT> print ( sum % ( 10 ** 9 + 7 ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> double = 0 <NEWLINE> <NL> for i in a : <NEWLINE> <INDENT> double += i * i <NEWLINE> <NL> <DEDENT> ans = ( sum ( a ) * sum ( a ) - double ) // 2 <NEWLINE> print ( ( ans % ( 10 ** 9 + 7 ) ) <NEWLINE>
import numba <NEWLINE> from numba import njit , b1 , i4 , i8 , f8 <NEWLINE> import numpy as np <COMMENT> <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = np . array ( [ int ( x ) for x in input ( ) . split ( ) ] , dtype = np . int32 ) <NEWLINE> <NL> <NL> @ njit ( ( i4 [ : ] , ) , cache = True ) <NEWLINE> def main ( A ) : <NEWLINE> <INDENT> ans = 0 <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , N ) : <NEWLINE> <INDENT> ans = ( ans + A [ i ] * A [ j ] ) % ( 10 ** 9 + 7 ) <NEWLINE> <DEDENT> <DEDENT> return ans <NEWLINE> <NL> <NL> <DEDENT> print ( main ( A ) ) <NEWLINE>
def solve ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> AA = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> for a in AA : <NEWLINE> <INDENT> ans += a <NEWLINE> <DEDENT> ans = ans ** 2 <NEWLINE> for a in AA : <NEWLINE> <INDENT> ans -= a ** 2 <NEWLINE> <DEDENT> ans = ans // 2 <NEWLINE> print ( ans % ( 10 ** 9 + 7 ) <NEWLINE> <DEDENT> solve ( ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> total = sum ( a ) <NEWLINE> total %= mod <NEWLINE> total = total ** 2 <NEWLINE> total %= mod <NEWLINE> cnt = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> cnt += a [ i ] ** 2 <NEWLINE> cnt %= mod <NEWLINE> <NL> <DEDENT> ans = total - cnt <NEWLINE> ans %= mod <NEWLINE> ans *= pow ( 2 , mod - 2 ) <NEWLINE> ans %= mod <NEWLINE> print ( ans ) <NEWLINE> <NL>
import numpy as np <NEWLINE> from numba import jit <NEWLINE> @ jit <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) . strip ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> l = np . array ( l ) <NEWLINE> <NL> tot = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> tot += ( l [ i ] * ( np . sum ( l [ i + 1 : n ] , dtype = <STRING> ) % ( 10 ** 9 + 7 ) ) ) % ( 10 ** 9 + 7 ) <NEWLINE> <NL> <DEDENT> print ( tot % ( 10 ** 9 + 7 ) ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> Ar = list ( itertools . accumulate ( A ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> ans += A [ i ] * ( Ar [ n - 1 ] - Ar [ i ] ) <NEWLINE> ans %= 10 ** 9 + 7 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
MOD = 1000000007 <NEWLINE> n = int ( input ( ) ) <NEWLINE> nums = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> x = sum ( sums ) <NEWLINE> y = sum ( [ ( x [ i ] ** 2 ) for i in range ( n ) ] ) <NEWLINE> print ( ( ( x ** 2 - y ) // 2 ) % MOD ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> sigma = sum ( a ) <NEWLINE> count = 0 <NEWLINE> for i in range ( len ( a ) - 1 ) : <NEWLINE> <INDENT> start = a [ i ] <NEWLINE> sigma = sigma - a [ i ] <NEWLINE> count = count + start * <NEWLINE> if count >= 10 ** 9 + 7 : <NEWLINE> <INDENT> count = count % ( 10 ** 9 + 7 ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> s = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> s += A [ i ] <NEWLINE> s %= ( 10 ** 9 + 7 ) <NEWLINE> <DEDENT> s = s ** 2 <NEWLINE> s %= ( 10 ** 9 + 7 ) <NEWLINE> <NL> t = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> t += ( A [ i ] ** 2 % ( 10 ** 9 + 7 ) ) <NEWLINE> <DEDENT> t %= ( 10 ** 9 + 7 ) <NEWLINE> <NL> ans = ( s - t ) % ( 10 ** 9 + 7 ) <NEWLINE> tmp = ( 2 ** 1000000005 ) % ( 10 ** 9 + 7 ) <NEWLINE> ans *= tmp <NEWLINE> ans %= ( 10 ** 9 + 7 ) <NEWLINE> print ( ans ) <NEWLINE>
for i in range ( N ) : <NEWLINE> <INDENT> A = ( int ( input ( ) ) <NEWLINE> <DEDENT> MASS = 0 <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> T = 0 <NEWLINE> for j in range ( i + 1 , N ) : <NEWLINE> <INDENT> T += ( A [ j ] % NUM ) <NEWLINE> <DEDENT> MASS += ( ( A [ i ] % NUM ) * ( T % NUM ) ) % NUM <NEWLINE> <DEDENT> print ( MASS % NUM ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A2 = 0 <NEWLINE> for i in ragne ( len ( A ) ) : <NEWLINE> <INDENT> A2 += A [ i ] ** 2 <NEWLINE> <DEDENT> c = ( sum ( A ) ) ** 2 - A2 <NEWLINE> print ( c // 2 ) <NEWLINE>
mod = 10 ** 9 + 7 <NEWLINE> n = int ( input ( ) ) <NEWLINE> <NL> a_sum = 0 <NEWLINE> sq_sum = 0 <NEWLINE> for a in map ( int , input ( ) . split ( ) ) : <NEWLINE> <INDENT> a_sum = ( a_sum + a ) % mod <NEWLINE> sq_sum = ( sq_sum + a * a ) % mod <NEWLINE> <DEDENT> res = ( a_sum * a_sum - sq_sum ) % mod <NEWLINE> print ( - ( p // 2 ) % mod * res % mod ) <NEWLINE>
<COMMENT> <NL> using namespace std ; <NEWLINE> <NL> int main ( ) { <NEWLINE> <INDENT> int N ; <NEWLINE> long long ans = 0 , sum = 0 ; <NEWLINE> int mod = 1000000000 + 7 ; <NEWLINE> cin >> N ; <NEWLINE> vector < int > a ( N ) ; <NEWLINE> for ( int i = 0 ; i < N ; i + + ) { <NEWLINE> <INDENT> cin >> a . at ( i ) ; <NEWLINE> sum += a . at ( i ) ; <NEWLINE> sum %= mod ; <NEWLINE> <DEDENT> } <NEWLINE> for ( int i = 0 ; i < N ; i + + ) { <NEWLINE> <INDENT> sum -= a . at ( i ) ; <NEWLINE> if ( sum < 0 ) sum += mod ; <NEWLINE> ans += sum * a . at ( i ) ; <NEWLINE> ans %= mod ; <NEWLINE> <DEDENT> } <NEWLINE> cout << ans << endl ; <NEWLINE> <DEDENT> } <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = [ ] <COMMENT> <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> ans = 0 <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> B [ i + 1 ] = B [ i ] + A [ i ] <COMMENT> <NEWLINE> <NL> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> sum = ( B [ N ] - B [ i + 1 ] ) % mod <NEWLINE> ans += A [ i ] * sum <NEWLINE> ans %= mod <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
ans = 0 <NEWLINE> N = int ( input ( ) ) <NEWLINE> array = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> x = sum ( array ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> ans += array [ i ] * ( x - arrau [ i ] ) <NEWLINE> <DEDENT> print ( int ( ans / 2 ) % ( 10 ** 9 + 7 ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> l [ i ] += l [ i - 1 ] <NEWLINE> <DEDENT> i = 0 <NEWLINE> while i < n - 1 : <NEWLINE> <INDENT> ans += l [ i ] * ( l [ n ] - l [ i ] ) <NEWLINE> i += 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
M = 1000000007 <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> S = [ 0 ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> S . append ( S [ - 1 ] + a [ i ] ) % M <NEWLINE> <DEDENT> sum = 0 <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> sum += ( a [ i ] * ( S [ n ] - S [ i + 1 ] ) ) % M <NEWLINE> <DEDENT> print ( sum % M ) <NEWLINE>
from sys import stdin <NEWLINE> <NL> n = stdin . readline ( ) . rstrip ( ) . split ( ) [ 0 ] <NEWLINE> A = [ int ( x ) for x in stdin . readline ( ) . rstrip ( ) . split ( ) ] <NEWLINE> <NL> s = str ( int ( ( sum ( A ) ** 2 - sum ( [ a ** 2 for a in A ] ) ) / 2 ) ) <NEWLINE> <NL> if ( int ( s ) < ( 10 ** 9 + 7 ) ) : <NEWLINE> <INDENT> print ( int ( s ) ) <NEWLINE> <NL> <DEDENT> x = int ( s [ - 9 : ] ) - 7 * int ( s [ : - 9 ] ) <NEWLINE> if ( x < 0 ) : <NEWLINE> <INDENT> print ( x % ( 10 ** 9 + 7 ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( x ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> s = sum ( a ) - a [ 0 ] <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> ans += ( a [ i ] * s ) <NEWLINE> ans %= st <NEWLINE> s -= a [ i + 1 ] <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = input ( ) . split ( ) <NEWLINE> <NL> Sum = sum ( A ) <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> ans += int ( A [ i ] ) * ( Sum - int ( A [ i ] ) ) <NEWLINE> <NL> <DEDENT> ans %= 1000000007 <NEWLINE> <NL> print ( int ( ans / 2 ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> import numpy as np <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) <NEWLINE> s = 0 <NEWLINE> ss = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ss += a [ i ] % mod <NEWLINE> s += ss * a [ i ] % mod <NEWLINE> <DEDENT> print ( s ) <NEWLINE>
import numpy as np <NEWLINE> N = int ( input ( ) ) <NEWLINE> P = 10 ** 9 + 7 <NEWLINE> a = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> b = [ 0 for i in range ( P ) ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> b [ a [ i ] ] += 1 <NEWLINE> <DEDENT> M = 1 << 19 <NEWLINE> c = np . zeros ( M ) <NEWLINE> for i in range ( P - 1 ) : <NEWLINE> <INDENT> c [ i ] = b [ pow ( 2 , i , P ) ] <NEWLINE> <DEDENT> X = [ int ( i + 0.1 ) for i in np . real ( np . fft . ifft ( np . fft . fft ( c ) * np . fft . fft ( c ) ) ) ] <NEWLINE> ans = 0 <NEWLINE> for k in range ( M ) : <NEWLINE> <INDENT> ans += X [ k ] * pow ( 2 , k , P ) <NEWLINE> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> ans -= ( a [ i ] * a [ i ] ) % P <NEWLINE> <DEDENT> print ( ( ans // 2 ) % P ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = ( sum ( a ) % mod ) ** 2 - ( sum [ x ** 2 for x in a ] % mod ) <NEWLINE> ans *= 5 * 10 ** 8 + 4 <NEWLINE> ans %= mod <NEWLINE> print ( ans ) <NEWLINE>
num = int ( input ( ) ) <NEWLINE> ar = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> somee = sum ( arr ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( num ) : <NEWLINE> <INDENT> ans += ( somee - ar [ i ] ) * ar [ i ] <NEWLINE> <DEDENT> print ( ( ans // 2 ) % mod ) <NEWLINE>
l = input ( ) <NEWLINE> a = l . split ( <STRING> ) <NEWLINE> <NL> tmp = 0 <NEWLINE> tmp2 = 0 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> tmp += int ( a [ i ] ) <NEWLINE> <NL> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> tmp2 += int ( a [ i ] ) * int ( a [ i ] ) <NEWLINE> <NL> <DEDENT> print ( ( tmp * tmp - tmp2 ) // 2 % 1000000007 ) <NEWLINE>
N = int ( int ( input ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> sum = sum [ A ] <NEWLINE> b = 0 <NEWLINE> c = 0 <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> b += A [ i ] <NEWLINE> c = ( c + ( A [ i ] * ( sum - b ) ) ) % ( 10 ** 9 + 7 ) <NEWLINE> <DEDENT> print ( c ) <NEWLINE>
import numpy as np <NEWLINE> ans = 0 <NEWLINE> n = int ( input ( ) ) <NEWLINE> li = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> L = li <NEWLINE> k = np . cumsum ( L [ : i ] ) <NEWLINE> ans += k * li [ i ] <NEWLINE> <DEDENT> print ( ans % ( 10 ** 9 + 7 ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> An = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> An_s = collections . Counter ( An ) <NEWLINE> total = 0 <NEWLINE> for k in An_s : <NEWLINE> <INDENT> total += k <NEWLINE> <DEDENT> ans = 0 <NEWLINE> for A , v in An_s . items ( ) : <NEWLINE> <INDENT> At = A * ( total - A ) * v <NEWLINE> <COMMENT> <NL> ans = ( ans + At ) % ( 10 ** 9 + 7 ) <NEWLINE> <COMMENT> <NL> <DEDENT> print ( ans // 2 ) <NEWLINE>
import numpy as np <NEWLINE> <NL> MOD = 10 ** 9 + 7 <NEWLINE> <NL> n = int ( input ( ) ) <COMMENT> <NEWLINE> alst = list ( map ( int , input ( ) . split ( ) ) ) <COMMENT> <NEWLINE> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> s = np . cumsum ( alst , dtype = <STRING> ) <NEWLINE> <NL> sum = 0 <NEWLINE> <NL> for i in range ( len ( alst ) - 1 ) : <NEWLINE> <INDENT> sum += alst [ i ] * ( s [ len ( s ) - 1 ] - s [ i ] ) <NEWLINE> <NL> <DEDENT> print ( sum % MOD ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( input ( ) . split ( <STRING> ) ) <NEWLINE> total = 0 <NEWLINE> S_i = 0 <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> S_i += a [ n - 1 - i ] <NEWLINE> S_i = S_i % ( 7 + 10 ** 9 ) <NEWLINE> total += S_i * a [ n - 2 - i ] <NEWLINE> total = total % ( 7 + 10 ** 9 ) <NEWLINE> <DEDENT> print ( total ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> input ( ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> arr = sorted ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> arr . reverse ( ) <NEWLINE> xxx = False <NEWLINE> sm = arr [ 0 ] + arr [ 1 ] <NEWLINE> ans = arr [ 0 ] * arr [ 1 ] % mod <NEWLINE> <NL> for x in range ( 2 , len ( arr ) ) : <NEWLINE> <INDENT> ans += sm * arr [ x ] <NEWLINE> sm += arr [ x ] <NEWLINE> <NL> <DEDENT> print ( ans % mod ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> A_list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> ans = 0 <NEWLINE> A_ = sum ( A_list ) % mod <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> A = A_list [ i ] <NEWLINE> A_ = A_ - A <NEWLINE> ans = ( ans + ( A * A_ ) % mod ) ) % mod <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> return <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> import sys <NEWLINE> import math <NEWLINE> import bisect <NEWLINE> from fractions import gcd <NEWLINE> from itertools import count , permutations <NEWLINE> from functools import lru_cache <NEWLINE> from collections import deque , defaultdict <NEWLINE> from pprint import pprint <NEWLINE> <NL> INF = float ( <STRING> ) <NEWLINE> <NL> ii = lambda : int ( input ( ) ) <NEWLINE> mis = lambda : map ( int , input ( ) . split ( ) ) <NEWLINE> lmis = lambda : list ( mis ( ) ) <NEWLINE> lmtx = lambda h : [ list ( map ( int , lmis ( ) ) ) for _ in range ( h ) ] <NEWLINE> sys . setrecursionlimit ( 1000000000 ) <NEWLINE> <NL> <NL> def lcm ( a , b ) : <NEWLINE> <INDENT> return ( a * b ) // gcd ( a , b ) <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> n = ii ( ) <NEWLINE> alist = lmis ( ) <NEWLINE> <NL> sum = 0 <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n ) : <NEWLINE> <INDENT> sum += alist [ i ] * alist [ j ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( sum % 1000000007 ) <NEWLINE>
mport sys <NEWLINE> import numpy as np <NEWLINE> import math <NEWLINE> import collections <NEWLINE> import copy <NEWLINE> import decimal <NEWLINE> import itertools <NEWLINE> from collections import deque <NEWLINE> from functools import reduce <NEWLINE> from itertools import product <NEWLINE> from itertools import combinations <NEWLINE> <NL> <COMMENT> <NL> N = int ( input ( ) ) <NEWLINE> An = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> An_l = list ( itertools . accumulate ( An ) ) <NEWLINE> An_l . insert ( 0 , 0 ) <NEWLINE> ans = 0 <NEWLINE> for i , A in enumerate ( An ) : <NEWLINE> <INDENT> tt = An_l [ - 1 ] - An_l [ i + 1 ] <NEWLINE> <COMMENT> <NL> At = A * tt <NEWLINE> <COMMENT> <NL> ans = ( ans + At ) % ( 10 ** 9 + 7 ) <NEWLINE> <COMMENT> <NL> <DEDENT> print ( ans ) <NEWLINE> <NL>
sus = 0 <NEWLINE> <NL> for i in a : <NEWLINE> <INDENT> su = su - i <NEWLINE> sus = sus + i * su <NEWLINE> <NL> <DEDENT> <STRING> <NEWLINE> <NL> print ( sus % ( 10 ** 9 + 7 ) ) <NEWLINE>
import sys <NEWLINE> import itertools <NEWLINE> tokens = itertools . chain . from_iterable ( map ( str . split , sys . stdin ) ) <NEWLINE> <NL> mod = 1000000007 <NEWLINE> n = int ( next ( tokens ) ) <NEWLINE> a = [ int ( next ( tokens ) ) for _ in range ( n ) ] <NEWLINE> <NL> from numba import njit <NEWLINE> import numpy as np <NEWLINE> a = np . array ( a , dtype = np . int64 ) % mod <NEWLINE> <NL> @ njit ( <STRING> ) <NEWLINE> def fun ( a ) : <NEWLINE> <INDENT> m = 0 <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n ) : <NEWLINE> <INDENT> m = ( m + a [ i ] * a [ j ] ) % mod <NEWLINE> <DEDENT> <DEDENT> return m <NEWLINE> <NL> <DEDENT> ans = fun ( a ) <NEWLINE> print ( ans ) <NEWLINE>
import sys <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> stdin = sys . stdin <NEWLINE> n , m = map ( int , stdin . readline ( ) . split ( ) ) <NEWLINE> <NL> par = [ i for i in range ( i ) ] <NEWLINE> size = [ 1 ] * n <NEWLINE> rank = [ 1 ] * n <NEWLINE> <NL> def find ( x , par ) : <NEWLINE> <INDENT> if par [ x ] == x : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return find ( par [ x ] , par ) <NEWLINE> <NL> <DEDENT> <DEDENT> def unite ( x , y ) : <NEWLINE> <INDENT> x = find ( x ) <NEWLINE> y = find ( y ) <NEWLINE> <NL> if x != y : <NEWLINE> <COMMENT> <NL> <INDENT> if rank [ x ] < rank [ y ] : <NEWLINE> <INDENT> par [ x ] = y <NEWLINE> size [ y ] += size [ x ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> par [ y ] = x <NEWLINE> size [ x ] += size [ y ] <NEWLINE> if rank [ x ] == rank [ y ] : <NEWLINE> <INDENT> rank [ x ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for _ in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , stdin . readline ( ) . split ( ) ) <NEWLINE> unite ( a , b ) <NEWLINE> <NL> <NL> <DEDENT> print ( max ( size ) ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE>
class UnionFind ( ) : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . _n = n <NEWLINE> self . _table = [ - 1 ] * n <NEWLINE> <NL> <DEDENT> def _root ( self , x ) : <NEWLINE> <INDENT> stack = [ ] <NEWLINE> while self . _table [ x ] >= 0 : <NEWLINE> <INDENT> stack . append ( x ) <NEWLINE> x = self . _table [ x ] <NEWLINE> <DEDENT> for y in stack : <NEWLINE> <INDENT> self . _table [ y ] = x <NEWLINE> <DEDENT> return x <NEWLINE> <NL> <DEDENT> def unite ( self , x , y ) : <NEWLINE> <INDENT> x , y = self . _root ( x ) , self . _root ( y ) <NEWLINE> if x == y : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> if x > y : <NEWLINE> <INDENT> x , y = y , x <NEWLINE> <DEDENT> self . _table [ x ] += self . _table [ y ] <NEWLINE> self . _table [ y ] = x <NEWLINE> <NL> <DEDENT> def same ( self , x , y ) : <NEWLINE> <INDENT> return self . _root ( x ) == self . _root ( y ) <NEWLINE> <NL> <DEDENT> def count_members ( self , x ) : <NEWLINE> <INDENT> return - self . _table [ self . _root ( x ) ] <NEWLINE> <NL> <DEDENT> def count_groups ( self ) : <NEWLINE> <INDENT> return len ( { self . _root ( i ) for i in range ( self . _n ) } ) <NEWLINE> <NL> <DEDENT> def __str__ ( self ) : <NEWLINE> <INDENT> return str ( [ self . _root ( i ) for i in range ( self . _n ) ] ) <NEWLINE> <NL> <DEDENT> def __repr__ ( self ) : <NEWLINE> <INDENT> return repr ( [ self . _root ( i ) for i in range ( self . _n ) ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> n , m , * AB = map ( int , open ( 0 ) . read ( ) . split ( ) ) <NEWLINE> uf = UnionFind ( n ) <NEWLINE> for a , b in zip ( AB [ : : 2 ] , AB [ 1 : : 2 ] ) : <NEWLINE> <INDENT> uf . unite ( a , b ) <NEWLINE> <DEDENT> s = 0 <NEWLINE> for group in { uf . _root ( i ) for i in range ( n ) } : <NEWLINE> <INDENT> s += uf . count_members ( group ) - 1 <NEWLINE> <DEDENT> print ( s ) <NEWLINE>
class union : <NEWLINE> <INDENT> def __init__ ( self , box ) : <NEWLINE> <INDENT> self . r = [ ] <NEWLINE> for i in range ( box ) : <NEWLINE> <INDENT> self . r . append ( - 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> def root ( self , x ) : <NEWLINE> <INDENT> if self . r [ x ] < 0 : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> return self . r [ x ] = root ( self . r [ x ] ) <NEWLINE> <NL> <DEDENT> def add ( self , a , b ) : <NEWLINE> <INDENT> a = root ( a ) <NEWLINE> b = root ( b ) <NEWLINE> if a == b : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> if self . r [ a ] > self . r [ b ] : <NEWLINE> <INDENT> a , b = b , a <NEWLINE> <DEDENT> self . r [ a ] += self . r [ b ] <NEWLINE> self . r [ b ] = a <NEWLINE> return True <NEWLINE> <NL> <DEDENT> def size ( self , x ) : <NEWLINE> <INDENT> return self . r [ x ] <NEWLINE> <NL> <DEDENT> <DEDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> uf = union ( m ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> uf . add ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> ans = max ( ans , uf . size ( i ) ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import sys , os <NEWLINE> import math <NEWLINE> from fractions import Fraction <NEWLINE> from collections import defaultdict <NEWLINE> from random import randint <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> def linput ( ) : <NEWLINE> <INDENT> return list ( minput ( ) ) <NEWLINE> <NL> <DEDENT> def minput ( ) : <NEWLINE> <INDENT> return map ( int , sys . stdin . readline ( ) . strip ( ) . split ( ) ) <NEWLINE> <NL> <COMMENT> <NL> <NL> <DEDENT> def make_set ( a , parent ) : <NEWLINE> <INDENT> parent [ a ] = a <NEWLINE> <NL> <DEDENT> def find_set ( a , parent ) : <NEWLINE> <INDENT> if parent [ a ] == a : <NEWLINE> <INDENT> return a <NEWLINE> <DEDENT> parent [ a ] = find_set ( parent [ a ] ) <NEWLINE> return parent [ a ] <NEWLINE> <NL> <DEDENT> def union_set ( a , b , parent ) : <NEWLINE> <INDENT> x = find_set ( a ) <NEWLINE> y = find_set ( b ) <NEWLINE> if x == y : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> parent [ y ] = x <NEWLINE> <NL> <DEDENT> <DEDENT> n , m = minput ( ) <NEWLINE> parent = [ 0 ] * n <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> make_set ( i , parent ) <NEWLINE> <DEDENT> ans = 0 <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> x , y = minput ( ) <NEWLINE> if x > y : <NEWLINE> <INDENT> x , y = y , x <NEWLINE> <DEDENT> x = x - 1 <NEWLINE> y = y - 1 <NEWLINE> union_set ( x , y , parent ) <NEWLINE> <COMMENT> <NL> <DEDENT> di = defaultdict ( int ) <NEWLINE> for i in parent : <NEWLINE> <INDENT> di [ i ] += 1 <NEWLINE> <COMMENT> <NL> <DEDENT> for k , v in di . items ( ) : <NEWLINE> <INDENT> ans = max ( ans , v ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
from copy import deepcopy <NEWLINE> <NL> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> pairs = [ 0 ] * m <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> pairs [ i ] = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> print ( pairs ) <NEWLINE> <NL> class UnionFind : <NEWLINE> <INDENT> def __init__ ( self , N ) : <NEWLINE> <INDENT> self . r = [ - 1 ] * N <NEWLINE> <NL> <DEDENT> def root ( self , x ) : <NEWLINE> <INDENT> if self . r [ x ] < 0 : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> self . r [ x ] = self . root ( self . r [ x ] ) <NEWLINE> return self . r [ x ] <NEWLINE> <NL> <NL> <DEDENT> def unite ( self , x , y ) : <NEWLINE> <INDENT> x = self . root ( x ) <NEWLINE> y = self . root ( y ) <NEWLINE> if x == y : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> if self . r [ x ] > self . r [ y ] : <NEWLINE> <INDENT> x , y = y , x <NEWLINE> <NL> <DEDENT> self . r [ x ] += self . r [ y ] <NEWLINE> self . r [ y ] = x <NEWLINE> return True <NEWLINE> <NL> <DEDENT> def size ( self , x ) : <NEWLINE> <INDENT> return - self . r [ self . root ( x ) ] <NEWLINE> <NL> <DEDENT> <DEDENT> uf = UnionFind ( N ) <NEWLINE> for pair in pairs : <NEWLINE> <INDENT> a = pair [ 0 ] - 1 <NEWLINE> b = pair [ 1 ] - 1 <NEWLINE> uf . unite ( a , b ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> ans = max ( ans , uf . size ( i ) ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> from queue import Queue <NEWLINE> from queue import LifoQueue as Stack <NEWLINE> from math import sqrt , floor , ceil , log2 , log10 , pi <NEWLINE> from fractions import gcd <NEWLINE> from itertools import permutations , combinations <NEWLINE> from operator import itemgetter <NEWLINE> from functools import cmp_to_key <NEWLINE> from bisect import bisect_left <NEWLINE> <NL> <NL> INF = 1001001001 <NEWLINE> __MOD__ = ( 10 ** 9 ) + 7 <NEWLINE> yn = <STRING> <NEWLINE> judge = False <NEWLINE> cnt = 0 <NEWLINE> ans = None <NEWLINE> <NL> <NL> def lcm ( a , b ) : <NEWLINE> <INDENT> return ( a * b ) // gcd ( a , b ) <NEWLINE> <NL> <DEDENT> def intinput ( ) : <NEWLINE> <INDENT> return int ( input ( ) ) <NEWLINE> <NL> <DEDENT> def mulinputs ( ) : <NEWLINE> <INDENT> return map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <DEDENT> def lineinputs ( func = intinput ) : <NEWLINE> <INDENT> datas = [ ] <NEWLINE> while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> datas . append ( func ( ) ) <NEWLINE> <DEDENT> except EOFError : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> return datas <NEWLINE> <NL> <DEDENT> def bindex ( a , x ) : <NEWLINE> <INDENT> i = bisect_left ( a , x ) <NEWLINE> if i != len ( a ) and a [ i ] == x : <NEWLINE> <INDENT> return i <NEWLINE> <DEDENT> return None <NEWLINE> <NL> <DEDENT> class ModInt ( ) : <NEWLINE> <INDENT> def __init__ ( self , x ) : <NEWLINE> <INDENT> self . __x = ( x % __MOD__ ) <NEWLINE> <DEDENT> def __add__ ( self , other ) : <NEWLINE> <INDENT> if type ( other ) == int : <NEWLINE> <INDENT> other = self . __class__ ( other ) <NEWLINE> return int ( self . __class__ ( ( self . __x + other . __x ) % __MOD__ ) ) <NEWLINE> <DEDENT> elif type ( other ) == ModInt : <NEWLINE> <INDENT> return self . __class__ ( ( self . __x + other . __x ) % __MOD__ ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> raise Exception ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> def __radd__ ( self , other ) : <NEWLINE> <INDENT> if type ( other ) == int : <NEWLINE> <INDENT> other = self . __class__ ( other ) <NEWLINE> return int ( self . __class__ ( ( other . __x + self . __x ) % __MOD__ ) ) <NEWLINE> <DEDENT> elif type ( other ) == ModInt : <NEWLINE> <INDENT> return self . __class__ ( ( other . __x + self . __x ) % __MOD__ ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> raise Exception ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> def __sub__ ( self , other ) : <NEWLINE> <INDENT> if type ( other ) == int : <NEWLINE> <INDENT> other = self . __class__ ( other ) <NEWLINE> return int ( self . __class__ ( ( self . __x - other . __x ) % __MOD__ ) ) <NEWLINE> <DEDENT> elif type ( other ) == ModInt : <NEWLINE> <INDENT> return self . __class__ ( ( self . __x - other . __x ) % __MOD__ ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> raise Exception ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> def __rsub__ ( self , other ) : <NEWLINE> <INDENT> if type ( other ) == int : <NEWLINE> <INDENT> other = self . __class__ ( other ) <NEWLINE> return int ( self . __class__ ( ( other . __x - self . __x ) % __MOD__ ) ) <NEWLINE> <DEDENT> elif type ( other ) == ModInt : <NEWLINE> <INDENT> return self . __class__ ( ( other . __x - self . __x ) % __MOD__ ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> raise Exception ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> def __mul__ ( self , other ) : <NEWLINE> <INDENT> if type ( other ) == int : <NEWLINE> <INDENT> other = self . __class__ ( other ) <NEWLINE> return int ( self . __class__ ( ( self . __x * other . __x ) % __MOD__ ) ) <NEWLINE> <DEDENT> elif type ( other ) == ModInt : <NEWLINE> <INDENT> return self . __class__ ( ( self . __x * other . __x ) % __MOD__ ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> raise Exception ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> def __rmul__ ( self , other ) : <NEWLINE> <INDENT> if type ( other ) == int : <NEWLINE> <INDENT> other = self . __class__ ( other ) <NEWLINE> return int ( self . __class__ ( ( other . __x * self . __x ) % __MOD__ ) ) <NEWLINE> <DEDENT> elif type ( other ) == ModInt : <NEWLINE> <INDENT> return self . __class__ ( ( other . __x * self . __x ) % __MOD__ ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> raise Exception ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> def __truediv__ ( self , other ) : <NEWLINE> <INDENT> if type ( other ) == int : <NEWLINE> <INDENT> other = self . __class__ ( other ) <NEWLINE> return int ( self . __class__ ( ( self . __x * other . __modinv ( ) ) % __MOD__ ) ) <NEWLINE> <DEDENT> elif type ( other ) == ModInt : <NEWLINE> <INDENT> return self . __class__ ( ( self . __x * other . __modinv ( ) ) % __MOD__ ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> raise Exception ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> def __rtruediv__ ( self , other ) : <NEWLINE> <INDENT> if type ( other ) == int : <NEWLINE> <INDENT> other = self . __class__ ( other ) <NEWLINE> return int ( self . __class__ ( ( other . __x * self . __modinv ( ) ) % __MOD__ ) ) <NEWLINE> <DEDENT> elif type ( other ) == ModInt : <NEWLINE> <INDENT> return self . __class__ ( ( other . __x * self . __modinv ( ) ) % __MOD__ ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> raise Exception ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> def __pow__ ( self , other ) : <NEWLINE> <INDENT> if type ( other ) == int : <NEWLINE> <INDENT> other = self . __class__ ( other ) <NEWLINE> return int ( self . __class__ ( pow ( self . __x , other . __x , __MOD__ ) ) ) <NEWLINE> <DEDENT> elif type ( other ) == ModInt : <NEWLINE> <INDENT> return self . __class__ ( pow ( self . __x , other . __x , __MOD__ ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> raise Exception ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> def __rpow__ ( self , other ) : <NEWLINE> <INDENT> if type ( other ) == int : <NEWLINE> <INDENT> other = self . __class__ ( other ) <NEWLINE> return int ( self . __class__ ( pow ( other . __x , self . __x , __MOD__ ) ) ) <NEWLINE> <DEDENT> elif type ( other ) == ModInt : <NEWLINE> <INDENT> return self . __class__ ( pow ( other . __x , self . __x , __MOD__ ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> raise Exception ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> def __modinv ( self , m = __MOD__ ) : <NEWLINE> <INDENT> a = self . __x <NEWLINE> if a == 0 : <NEWLINE> <INDENT> raise ZeroDivisionError ( ) <NEWLINE> <DEDENT> if gcd ( a , m ) != 1 : <NEWLINE> <INDENT> raise Exception ( <STRING> % a ) <NEWLINE> <DEDENT> b , u , v = m , 1 , 0 <NEWLINE> while b != 0 : <NEWLINE> <INDENT> t = a // b ; <NEWLINE> a -= t * b <NEWLINE> a , b = b , a <NEWLINE> u -= t * v <NEWLINE> u , v = v , u <NEWLINE> <DEDENT> u %= m <NEWLINE> if u < 0 : <NEWLINE> <INDENT> u += m <NEWLINE> <DEDENT> return u <NEWLINE> <DEDENT> def __int__ ( self ) : <NEWLINE> <INDENT> return self . __x <NEWLINE> <DEDENT> def __str__ ( self ) : <NEWLINE> <INDENT> return str ( self . __x ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> class UnionFind : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . r = [ - 1 ] * n <NEWLINE> <NL> <DEDENT> def root ( self , x ) : <NEWLINE> <INDENT> if self . r [ x ] < 0 : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> self . r [ x ] = self . root ( self . r [ x ] ) <NEWLINE> return self . r [ x ] <NEWLINE> <DEDENT> def unite ( self , x , y ) : <NEWLINE> <INDENT> x = self . root ( x ) <NEWLINE> y = self . root ( y ) <NEWLINE> if x == y : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> if self . r [ x ] > self . r [ y ] : <NEWLINE> <INDENT> tmp = x <NEWLINE> x = y <NEWLINE> y = x <NEWLINE> <DEDENT> self . r [ x ] += self . r [ y ] <NEWLINE> self . r [ y ] = x <NEWLINE> return True <NEWLINE> <NL> <DEDENT> def size ( self , x ) : <NEWLINE> <INDENT> return - 1 * self . r [ self . root ( x ) ] <NEWLINE> <NL> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <INDENT> N , M = mulinputs ( ) <NEWLINE> uf = UnionFind ( N ) <NEWLINE> for _ in range ( M ) : <NEWLINE> <INDENT> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> uf . unite ( A - 1 , B - 1 ) <NEWLINE> <DEDENT> ans = 1 <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> print ( ans ) <NEWLINE> <NL> <DEDENT>
from collections import Counter <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> <NL> lst = [ n for n in range ( N ) ] <COMMENT> <NEWLINE> <NL> def get_root ( x ) : <COMMENT> <NEWLINE> <INDENT> if lst [ x ] == x : <COMMENT> <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <COMMENT> <NEWLINE> <INDENT> lst [ x ] = get_root ( lst [ x ] ) <COMMENT> <NEWLINE> return lst [ x ] <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> def unite ( x , y ) : <COMMENT> <NEWLINE> <INDENT> root_x = get_root ( x ) <NEWLINE> root_y = get_root ( y ) <NEWLINE> if root_x != root_y : <COMMENT> <NEWLINE> <INDENT> lst [ root_x ] = root_y <NEWLINE> <NL> <DEDENT> <DEDENT> def main ( N , M , C ) : <NEWLINE> <INDENT> { unite ( * c ) for c in C } <COMMENT> <NEWLINE> print ( max ( Counter ( map ( get_root , lst ) ) . values ( ) ) ) <COMMENT> <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> N , M = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> C = set ( ) <NEWLINE> for _ in range ( M ) : <NEWLINE> <INDENT> C . add ( tuple ( map ( lambda x : int ( x ) - 1 , input ( ) . split ( ) ) ) ) <COMMENT> <NEWLINE> <DEDENT> main ( N , M , C ) <NEWLINE> <DEDENT>
from collections import Counter <NEWLINE> <NL> class UnionFindBasic ( ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . parents = list ( range ( n ) ) <NEWLINE> <NL> <DEDENT> def find ( self , x : int ) -> int : <NEWLINE> <INDENT> if self . parents [ x ] == x : return x <NEWLINE> return self . find ( self . parents [ x ] ) <NEWLINE> <NL> <DEDENT> def union ( self , x : int , y : int ) : <NEWLINE> <INDENT> x = self . find ( x ) <NEWLINE> y = self . find ( y ) <NEWLINE> if x == y : return <NEWLINE> if x > y : x , y = y , x <NEWLINE> self . parents [ y ] = x <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if M == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> uf = UnionFindBasic ( N ) <NEWLINE> <NL> for _ in range ( M ) : <NEWLINE> <INDENT> a , b = list ( map ( lambda x : int ( x ) - 1 , input ( ) . split ( ) ) ) <NEWLINE> uf . union ( a , b ) <NEWLINE> <NL> <DEDENT> print ( Counter ( uf . parents ) . most_common ( ) [ 0 ] [ 1 ] ) <NEWLINE> <DEDENT>
class UnionFind : <NEWLINE> <INDENT> def __init__ ( self , N ) : <NEWLINE> <INDENT> self . N = N <NEWLINE> self . parent = [ - 1 ] * N <NEWLINE> <NL> <DEDENT> def root ( self , A ) : <NEWLINE> <INDENT> if ( self . parent [ A ] < 0 ) : <NEWLINE> <INDENT> return A <NEWLINE> <DEDENT> self . parent [ A ] = self . root ( self . parent [ A ] ) <NEWLINE> return self . parent [ A ] <NEWLINE> <NL> <DEDENT> def size ( self , A ) : <NEWLINE> <INDENT> return - self . parent [ self . root ( A ) ] <NEWLINE> <NL> <DEDENT> def unite ( self , A , B ) : <NEWLINE> <INDENT> A = self . root ( A ) <NEWLINE> B = self . root ( B ) <NEWLINE> <NL> if ( A == B ) : <NEWLINE> <INDENT> return False <NEWLINE> <NL> <DEDENT> if ( self . size ( A ) < self . size ( B ) ) : <NEWLINE> <INDENT> A , B = B , A <NEWLINE> <NL> <DEDENT> self . parent [ A ] += self . parent [ B ] <NEWLINE> self . parent [ B ] = A <NEWLINE> <NL> return True <NEWLINE> <NL> <DEDENT> def is_in_same ( self , A , B ) : <NEWLINE> <INDENT> return self . root ( A ) == self . root ( B ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> uf = UnionFind ( N ) <NEWLINE> <NL> for i in range ( M ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> uf . union ( a , b ) <NEWLINE> <NL> <DEDENT> print ( max ( uf . size ( i ) ) for i in range ( 1 , N + 1 ) ) <NEWLINE>
class UnionFind ( ) : <NEWLINE> <INDENT> self . n = n <NEWLINE> self . parents = [ - 1 ] * n <NEWLINE> <NL> def find ( self , x ) : <NEWLINE> if self . parents [ x ] < 0 : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . parents [ x ] = self . find ( self . parents [ x ] ) <NEWLINE> return self . parents [ x ] <NEWLINE> <NL> def union ( self , x , y ) : <NEWLINE> <NL> <DEDENT> x = self . find ( x ) <NEWLINE> y = self . find ( y ) <NEWLINE> <NL> if x == y : <NEWLINE> <INDENT> return <NEWLINE> <NL> <DEDENT> if self . parents [ x ] > self . parents [ y ] : <NEWLINE> <INDENT> x , y = y , x <NEWLINE> <NL> <DEDENT> self . parents [ x ] += self . parents [ y ] <NEWLINE> self . parents [ y ] = x <NEWLINE> <NL> def size ( self , x ) : <NEWLINE> return - self . parents [ self . find ( x ) ] <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> union_find = UnionFind ( N ) <NEWLINE> for _ in range ( M ) : <NEWLINE> <INDENT> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> A -= 1 <NEWLINE> B -= 1 <NEWLINE> union_find . union ( A , B ) <NEWLINE> <NL> <DEDENT> answer = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> answer = max ( answer , union_find . size ( i ) ) <NEWLINE> <NL> <DEDENT> print ( answer ) <NEWLINE> <DEDENT>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> List = [ ] <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> List . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> <DEDENT> class UnionFind ( ) : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . n = n <NEWLINE> self . parents = [ - 1 ] * n <NEWLINE> <NL> <DEDENT> def find ( self , x ) : <NEWLINE> <INDENT> if self . parents [ x ] < 0 : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . parents [ x ] = self . find ( self . parents [ x ] ) <NEWLINE> return self . parents [ x ] <NEWLINE> <NL> <DEDENT> <DEDENT> def union ( self , x , y ) : <NEWLINE> <INDENT> x = self . find ( x ) <NEWLINE> y = self . find ( y ) <NEWLINE> <NL> if x == y : <NEWLINE> <INDENT> return <NEWLINE> <NL> <DEDENT> if self . parents [ x ] > self . parents [ y ] : <NEWLINE> <INDENT> x , y = y , x <NEWLINE> <NL> <DEDENT> self . parents [ x ] += self . parents [ y ] <NEWLINE> self . parents [ y ] = x <NEWLINE> <NL> <DEDENT> def size ( self , x ) : <NEWLINE> <INDENT> return - self . parents [ self . find ( x ) ] <NEWLINE> <NL> <DEDENT> def members ( self , x ) : <NEWLINE> <INDENT> root = self . find ( x ) <NEWLINE> return [ i for i in range ( self . n ) if self . find ( i ) == root ] <NEWLINE> <NL> <DEDENT> def roots ( self ) : <NEWLINE> <INDENT> return [ i for i , x in enumerate ( self . parents ) if x < 0 ] <NEWLINE> <NL> <DEDENT> def all_group_members ( self ) : <NEWLINE> <INDENT> return { r : self . members ( r ) for r in self . roots ( ) } <NEWLINE> <NL> <DEDENT> def __str__ ( self ) : <NEWLINE> <INDENT> return <STRING> . join ( <STRING> . format ( r , self . members ( r ) ) for r in self . roots ( ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> uni = UnionFind ( N ) <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> uni . union ( List [ i ] [ 0 ] , List [ i ] [ 1 ] ) <NEWLINE> <DEDENT> res = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> res = max ( res , uni . size ( i ) ) <NEWLINE> <DEDENT> print ( res ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> def input ( ) : return sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> <NL> class UnionFind ( ) : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . n = n <NEWLINE> self . parents = [ - 1 ] * n <NEWLINE> <NL> <DEDENT> def find ( self , x ) : <NEWLINE> <INDENT> if self . parents [ x ] < 0 : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . parents [ x ] = self . find ( self . parents [ x ] ) <NEWLINE> return self . parents [ x ] <NEWLINE> <NL> <DEDENT> <DEDENT> def unite ( self , x , y ) : <NEWLINE> <INDENT> x = self . find ( x ) <NEWLINE> y = self . find ( y ) <NEWLINE> <NL> if x == y : <NEWLINE> <INDENT> return <NEWLINE> <NL> <DEDENT> if self . parents [ x ] > self . parents [ y ] : <NEWLINE> <INDENT> x , y = y , x <NEWLINE> <NL> <DEDENT> self . parents [ x ] += self . parents [ y ] <NEWLINE> self . parents [ y ] = x <NEWLINE> <NL> <DEDENT> def size ( self , x ) : <NEWLINE> <INDENT> return - self . parents [ self . find ( x ) ] <NEWLINE> <NL> <INDENT> def same ( self , x , y ) : <NEWLINE> <DEDENT> return self . find ( x ) == self . find ( y ) <NEWLINE> <NL> <DEDENT> def members ( self , x ) : <NEWLINE> <INDENT> root = self . find ( x ) <NEWLINE> return [ i for i in range ( self . n ) if self . find ( i ) == root ] <NEWLINE> <NL> <DEDENT> def roots ( self ) : <NEWLINE> <INDENT> return [ i for i , x in enumerate ( self . parents ) if x < 0 ] <NEWLINE> <NL> <DEDENT> def group_count ( self ) : <NEWLINE> <INDENT> return len ( self . roots ( ) ) <NEWLINE> <NL> <DEDENT> def all_group_members ( self ) : <NEWLINE> <INDENT> return { r : self . members ( r ) for r in self . roots ( ) } <NEWLINE> <NL> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <INDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> uf = UnionFind ( n ) <NEWLINE> for _ in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> uf . unite ( a - 1 , b - 1 ) <NEWLINE> <DEDENT> roots = uf . roots ( ) <NEWLINE> cnt = [ ] <NEWLINE> for r in roots : <NEWLINE> <INDENT> cnt . append ( uf . size ( r ) ) <NEWLINE> <DEDENT> print ( max ( cnt ) ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
from networkx import * ; _ , * n = map ( str . split , open ( 0 ) ) ; print ( max ( map ( len , [ * connected_components ( Graph ( n ) ) ] ) , 1 , 1 ) ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <NL> <NL> def find ( x ) : <NEWLINE> <INDENT> if par [ x ] < 0 : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> par [ x ] = find ( par [ x ] ) <NEWLINE> return par [ x ] <NEWLINE> <NL> <DEDENT> <DEDENT> def unite ( x , y ) : <NEWLINE> <INDENT> x = find ( x ) <NEWLINE> y = find ( y ) <NEWLINE> if x == y : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> if par [ x ] > par [ y ] : <NEWLINE> <INDENT> x , y = y , x <NEWLINE> <DEDENT> par [ x ] += par [ y ] <NEWLINE> par [ y ] = x <NEWLINE> return True <NEWLINE> <NL> <DEDENT> def size ( x ) : <NEWLINE> <INDENT> return - par [ find ( x ) ] <NEWLINE> <NL> <NL> <COMMENT> <NL> <NL> <NL> <DEDENT> par = [ - 1 ] * N <NEWLINE> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> for _ in range ( M ) : <NEWLINE> <INDENT> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> A -= 1 ; B -= 1 <NEWLINE> unite ( A , B ) <NEWLINE> <DEDENT> ans = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> ans = max ( ans , size ( i ) ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <COMMENT> <NL> <NL> <NL> <NL> <NL>
import sys <NEWLINE> if sys . argv [ - 1 ] == <STRING> : <NEWLINE> <INDENT> import os , zlib , base64 <NEWLINE> open ( <STRING> , <STRING> ) . write ( zlib . decompress ( base64 . b85decode ( <STRING> ) ) ) <NEWLINE> os . system ( <STRING> ) <NEWLINE> <DEDENT> import solve <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> <COMMENT> <NL> a = list ( range ( n ) ) <NEWLINE> def find ( x ) : <NEWLINE> <INDENT> while a [ x ] != x : <NEWLINE> <INDENT> a [ x ] = a [ a [ x ] ] <NEWLINE> <DEDENT> return a [ x ] <NEWLINE> <NL> <DEDENT> for _ in range ( m ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> x , y = find ( x - 1 ) , find ( y - 1 ) <NEWLINE> if x == y : continue <NEWLINE> a [ y ] = x <NEWLINE> <NL> <DEDENT> count = [ 0 ] * n <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> count [ find ( i ) ] += 1 <NEWLINE> <DEDENT> print ( max ( count ) ) <NEWLINE>
import collections <COMMENT> <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> class UnionFind ( ) : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . n = n <NEWLINE> self . parents = [ - 1 ] * n <NEWLINE> <NL> <DEDENT> def find ( self , x ) : <NEWLINE> <INDENT> if self . parents [ x ] < 0 : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . parents [ x ] = self . find ( self . parents [ x ] ) <NEWLINE> return self . parents [ x ] <NEWLINE> <NL> <DEDENT> <DEDENT> def union ( self , x , y ) : <NEWLINE> <INDENT> x = self . find ( x ) <NEWLINE> y = self . find ( y ) <NEWLINE> <NL> if x == y : <NEWLINE> <INDENT> return <NEWLINE> <NL> <DEDENT> if self . parents [ x ] > self . parents [ y ] : <NEWLINE> <INDENT> x , y = y , x <NEWLINE> <NL> <DEDENT> self . parents [ x ] += self . parents [ y ] <NEWLINE> self . parents [ y ] = x <NEWLINE> <NL> <DEDENT> def size ( self , x ) : <NEWLINE> <INDENT> return - self . parents [ self . find ( x ) ] <NEWLINE> <NL> <DEDENT> def same ( self , x , y ) : <NEWLINE> <INDENT> return self . find ( x ) == self . find ( y ) <NEWLINE> <NL> <DEDENT> def members ( self , x ) : <NEWLINE> <INDENT> root = self . find ( x ) <NEWLINE> return [ i for i in range ( self . n ) if self . find ( i ) == root ] <NEWLINE> <NL> <DEDENT> def roots ( self ) : <NEWLINE> <INDENT> return [ i for i , x in enumerate ( self . parents ) if x < 0 ] <NEWLINE> <NL> <DEDENT> def group_count ( self ) : <NEWLINE> <INDENT> return len ( self . roots ( ) ) <NEWLINE> <NL> <DEDENT> def all_group_members ( self ) : <NEWLINE> <INDENT> return { r : self . members ( r ) for r in self . roots ( ) } <NEWLINE> <NL> <DEDENT> def __str__ ( self ) : <NEWLINE> <INDENT> return <STRING> . join ( <STRING> . format ( r , self . members ( r ) ) for r in self . roots ( ) ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> lis = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( m ) ] <NEWLINE> <NL> cmax = 0 <NEWLINE> <NL> uf = UnionFind ( n ) <NEWLINE> <NL> for i in lis : <NEWLINE> <INDENT> uf . union ( i [ 0 ] , i [ 1 ] ) <NEWLINE> <NL> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> cmax = max ( cmax , uf . size ( i ) ) <NEWLINE> <NL> <DEDENT> print ( cmax ) <NEWLINE>
n , m = input ( ) . split ( ) <NEWLINE> ab = [ map ( int , input ( ) . split ( ) ) for _ in range ( m ) ] <NEWLINE> a , b = [ list ( i ) for i in zip ( * xy ) ] <NEWLINE> friendnum = [ 0 ] * n <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> for k in range ( m ) : <NEWLINE> <INDENT> if a [ k ] == i : <NEWLINE> <INDENT> friendnum [ i ] . append ( b [ i ] ) <NEWLINE> <DEDENT> if b [ k ] == i : <NEWLINE> <INDENT> friendnum [ i ] . append ( a [ i ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> ans = max ( ans , len ( frindnum [ i ] ) ) <NEWLINE> print ( ans ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> par = list ( range ( N ) ) <NEWLINE> rank = [ 1 ] * N <NEWLINE> size = [ 1 ] * N <NEWLINE> <NL> def find ( x ) : <NEWLINE> <INDENT> if par [ x ] == x : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return find ( par [ x ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> def unite ( x , y ) : <NEWLINE> <INDENT> x = find ( x ) <NEWLINE> y = find ( y ) <NEWLINE> <NL> if x == y : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> if rank [ x ] < rank [ y ] : <NEWLINE> <INDENT> x , y = y , x <NEWLINE> <DEDENT> else : <NEWLINE> par [ y ] = x <NEWLINE> size [ x ] += size [ y ] <NEWLINE> if rank [ x ] == rank [ y ] : <NEWLINE> <INDENT> rank [ x ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( M ) : <NEWLINE> <INDENT> a , b = [ int ( i ) - 1 for i in input ( ) . split ( ) ] <NEWLINE> unite ( a , b ) <NEWLINE> <NL> <DEDENT> print ( max ( size ) ) <NEWLINE>
<COMMENT> <NL> <NL> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> a = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( m ) ] <NEWLINE> <NL> <COMMENT> <NL> <NL> l = [ n + 1 ] * n <NEWLINE> <COMMENT> <NL> p = [ 1 ] * n <NEWLINE> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> for j in range ( m ) : <NEWLINE> <INDENT> if ( l [ a [ j ] [ 0 ] ] == n + 1 & l [ a [ j ] [ 1 ] ] == n + 1 ) : <NEWLINE> <INDENT> if ( a [ j ] [ 0 ] > a [ j ] [ 1 ] ) : <NEWLINE> <INDENT> l [ a [ j ] [ 0 ] ] = a [ j ] [ 1 ] <NEWLINE> l [ a [ j ] [ 1 ] ] = a [ j ] [ 1 ] <NEWLINE> p [ a [ j ] [ 1 ] ] = 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> l [ a [ j ] [ 0 ] ] = a [ j ] [ 0 ] <NEWLINE> l [ a [ j ] [ 1 ] ] = a [ j ] [ 0 ] <NEWLINE> p [ a [ j ] [ 0 ] ] = 2 <NEWLINE> <NL> <DEDENT> <DEDENT> elif ( l [ a [ j ] [ 0 ] ] != n + 1 & l [ a [ j ] [ 1 ] ] != n + 1 ) : <NEWLINE> <INDENT> if ( l [ a [ j ] [ 0 ] ] < l [ a [ j ] [ 1 ] ] ) : <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT>
import typing <NEWLINE> <NL> <NL> class DSU : <NEWLINE> <INDENT> <STRING> <NEWLINE> <NL> def __init__ ( self , n : int = 0 ) : <NEWLINE> <INDENT> self . _n = n <NEWLINE> self . parent_or_size = [ - 1 ] * n <NEWLINE> <NL> <DEDENT> def merge ( self , a : int , b : int ) -> int : <NEWLINE> <INDENT> assert 0 <= a < self . _n <NEWLINE> assert 0 <= b < self . _n <NEWLINE> <NL> x = self . leader ( a ) <NEWLINE> y = self . leader ( b ) <NEWLINE> <NL> if x == y : <NEWLINE> <INDENT> return x <NEWLINE> <NL> <DEDENT> if - self . parent_or_size [ x ] < - self . parent_or_size [ y ] : <NEWLINE> <INDENT> x , y = y , x <NEWLINE> <NL> <DEDENT> self . parent_or_size [ x ] += self . parent_or_size [ y ] <NEWLINE> self . parent_or_size [ y ] = x <NEWLINE> <NL> return x <NEWLINE> <NL> <DEDENT> def same ( self , a : int , b : int ) -> bool : <NEWLINE> <INDENT> assert 0 <= a < self . _n <NEWLINE> assert 0 <= b < self . _n <NEWLINE> <NL> return self . leader ( a ) == self . leader ( b ) <NEWLINE> <NL> <DEDENT> def leader ( self , a : int ) -> int : <NEWLINE> <INDENT> assert 0 <= a < self . _n <NEWLINE> <NL> if self . parent_or_size [ a ] < 0 : <NEWLINE> <INDENT> return a <NEWLINE> <NL> <DEDENT> self . parent_or_size [ a ] = self . leader ( self . parent_or_size [ a ] ) <NEWLINE> return self . parent_or_size [ a ] <NEWLINE> <NL> <DEDENT> def size ( self , a : int ) -> int : <NEWLINE> <INDENT> assert 0 <= a < self . _n <NEWLINE> <NL> return - self . parent_or_size [ self . leader ( a ) ] <NEWLINE> <NL> <DEDENT> def groups ( self ) -> typing . List [ typing . List [ int ] ] : <NEWLINE> <INDENT> leader_buf = [ self . leader ( i ) for i in range ( self . _n ) ] <NEWLINE> <NL> result = [ [ ] for _ in range ( self . _n ) ] <NEWLINE> for i in range ( self . _n ) : <NEWLINE> <INDENT> result [ leader_buf [ i ] ] . append ( i ) <NEWLINE> <NL> <DEDENT> return list ( filter ( lambda r : r , result ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> uf = DSU ( n ) <NEWLINE> <NL> for _ in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> uf . marge ( a - 1 , b - 1 ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> ans = max ( ans , uf . size ( i ) ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
def zero_origin ( s : str ) : <NEWLINE> <INDENT> return int ( s ) - 1 <NEWLINE> <NL> <NL> <DEDENT> class UnionFindTree : <NEWLINE> <INDENT> <STRING> <NEWLINE> def __init__ ( self , n : int ) : <NEWLINE> <INDENT> self . parent = list ( range ( n ) ) <NEWLINE> self . rank = [ 0 ] * n <NEWLINE> self . size = [ 1 ] * n <NEWLINE> <NL> <DEDENT> def find ( self , i : int ) -> int : <NEWLINE> <INDENT> if self . parent [ i ] != i : <NEWLINE> <INDENT> self . parent [ i ] = self . find ( self . parent [ i ] ) <NEWLINE> <DEDENT> return self . parent [ i ] <NEWLINE> <NL> <DEDENT> def unite ( self , i : int , j : int ) : <NEWLINE> <INDENT> ri = self . find ( i ) <NEWLINE> rj = self . find ( j ) <NEWLINE> size = self . size [ ri ] + self . size [ rj ] <NEWLINE> self . size [ ri ] = size <NEWLINE> self . size [ rj ] = size <NEWLINE> if ri != rj : <NEWLINE> <INDENT> if self . rank [ ri ] < self . rank [ rj ] : <NEWLINE> <INDENT> self . parent [ ri ] = rj <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . parent [ rj ] = ri <NEWLINE> if self . rank [ ri ] == self . rank [ rj ] : <NEWLINE> <INDENT> self . rank [ ri ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> def is_same ( self , i : int , j : int ) -> bool : <NEWLINE> <INDENT> return self . find ( i ) == self . find ( j ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> uft = UnionFindTree ( n ) <NEWLINE> for _ in range ( m ) : <NEWLINE> <INDENT> a , b = map ( zero_origin , input ( ) . split ( ) ) <NEWLINE> uft . unite ( a , b ) <NEWLINE> <DEDENT> print ( max ( utf . size ) ) <NEWLINE>
<COMMENT> <NL> <NL> N , M = [ int ( x ) for x in input ( ) . split ( <STRING> ) ] <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> class UF : <NEWLINE> <INDENT> def __init__ ( self ) : <NEWLINE> <INDENT> self . r = [ - 1 ] * N <NEWLINE> <NL> <DEDENT> def root ( self , i ) : <NEWLINE> <INDENT> r = self . r <NEWLINE> if r [ i ] < 0 : <NEWLINE> <INDENT> return i <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> r [ i ] = self . root ( r [ i ] ) <NEWLINE> return r [ i ] <NEWLINE> <NL> <DEDENT> <DEDENT> def union ( self , i , j ) : <NEWLINE> <INDENT> ri = self . root ( i ) <NEWLINE> rj = self . root ( j ) <NEWLINE> if ri == rj : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if not self . r [ ri ] < self . r [ rj ] : <NEWLINE> <INDENT> ri , rj = rj , ri <NEWLINE> <DEDENT> self . r [ ri ] += self . r [ rj ] <NEWLINE> self . r [ rj ] = ri <NEWLINE> return <NEWLINE> <NL> <DEDENT> <DEDENT> def max_size ( self ) : <NEWLINE> <INDENT> return - min ( self . r ) <NEWLINE> <NL> <DEDENT> <DEDENT> uf = UF ( ) <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> uf . union ( * [ int ( x ) for x in input ( ) . split ( <STRING> ) ] ) <NEWLINE> <DEDENT> print ( uf . max_size ( ) ) <NEWLINE> <NL> <NL> <NL>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> p = [ ( i , 1 ) for i in range ( n ) ] <NEWLINE> def find ( i ) : <NEWLINE> <INDENT> if p [ i ] [ 0 ] == i : return i <NEWLINE> else : <NEWLINE> <INDENT> c = find ( p [ i ] ) <NEWLINE> p [ i ] = ( c , 0 ) <NEWLINE> return c <NEWLINE> <DEDENT> <DEDENT> def union ( i , j ) : <NEWLINE> <INDENT> pi = find ( i ) <NEWLINE> pj = find ( j ) <NEWLINE> if not pi == pj : <NEWLINE> <INDENT> if p [ pi ] [ 1 ] > p [ pj ] [ 1 ] : <NEWLINE> <INDENT> p [ pj ] = ( pi , p [ pi ] [ 1 ] + p [ pj ] [ 1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> p [ pi ] = ( pj , p [ pi ] [ 1 ] + p [ pj ] [ 1 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> union ( a - 1 , b - 1 ) <NEWLINE> <DEDENT> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if p [ i ] [ 0 ] == i : ans = max ( ans , p [ i ] [ 1 ] ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ 0 ] * M <NEWLINE> B = [ 0 ] * M <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> A [ i ] , B [ i ] = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <DEDENT> class UnionFind ( ) : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . n = n <NEWLINE> self . parents = [ - 1 ] * n <NEWLINE> <NL> <DEDENT> def find ( self , x ) : <NEWLINE> <INDENT> if self . parents [ x ] < 0 : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . parents [ x ] = self . find ( self . parents [ x ] ) <NEWLINE> return self . parents [ x ] <NEWLINE> <NL> <DEDENT> <DEDENT> def union ( self , x , y ) : <NEWLINE> <INDENT> x = self . find ( x ) <NEWLINE> y = self . find ( y ) <NEWLINE> <NL> if x == y : <NEWLINE> <INDENT> return <NEWLINE> <NL> <DEDENT> if self . parents [ x ] > self . parents [ y ] : <NEWLINE> <INDENT> x , y = y , x <NEWLINE> <NL> <DEDENT> self . parents [ x ] += self . parents [ y ] <NEWLINE> self . parents [ y ] = x <NEWLINE> <NL> <DEDENT> def size ( self , x ) : <NEWLINE> <INDENT> return - self . parents [ self . find ( x ) ] <NEWLINE> <NL> <DEDENT> <DEDENT> u = UnionFind ( N ) <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> u . union ( A [ i ] , B [ i ] ) <NEWLINE> <NL> <DEDENT> ans = 1 <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> print ( <STRING> . format ( i , u . size ( i ) ) ) <NEWLINE> ans = max ( ans , u . size ( i ) ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
<STRING> <NEWLINE> import sys <NEWLINE> sys . setrecursionlimit ( 4e5 ) <NEWLINE> <NL> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> adj = [ [ ] for u in range ( n + 1 ) ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> u , v = map ( int , input ( ) . split ( ) ) <NEWLINE> adj [ u ] . append ( v ) <NEWLINE> adj [ v ] . append ( u ) <NEWLINE> <NL> <DEDENT> vis = [ False for u in range ( n + 1 ) ] <NEWLINE> def dfs ( u ) : <NEWLINE> <INDENT> if vis [ u ] : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> vis [ u ] = True <NEWLINE> <NL> sz = 1 <NEWLINE> for v in adj [ u ] : <NEWLINE> <INDENT> sz += dfs ( v ) <NEWLINE> <DEDENT> return sz <NEWLINE> <NL> <DEDENT> CCs = [ ] <NEWLINE> for u in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if not vis [ u ] : <NEWLINE> <INDENT> CCs . append ( dfs ( u ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( max ( CCs ) ) <NEWLINE>
class UnionFind ( ) : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . parents = [ - 1 ] * n <NEWLINE> <NL> <DEDENT> def find ( self , x ) : <NEWLINE> <INDENT> if self . parents [ x ] < 0 : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . parents [ x ] = self . find ( self . parents [ x ] ) <NEWLINE> return self . parents [ x ] <NEWLINE> <NL> <DEDENT> <DEDENT> def union ( self , x , y ) : <NEWLINE> <INDENT> x = self . find ( x ) <NEWLINE> y = self . find ( y ) <NEWLINE> <NL> if x == y : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> if self . parents [ x ] > self . parents [ y ] : <NEWLINE> <INDENT> x , y = y , x <NEWLINE> <NL> <DEDENT> self . parents [ x ] += self . parents [ y ] <NEWLINE> self . parents [ y ] = x <NEWLINE> <NL> <DEDENT> <DEDENT> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> uf = UnionFind ( N ) <NEWLINE> <NL> for i in range ( M ) : <NEWLINE> <INDENT> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> uf . union ( A , B ) <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> print ( abs ( min ( uf . parents ) ) ) <NEWLINE>
<COMMENT> <NL> <NL> <COMMENT> <NL> def find ( x ) : <NEWLINE> <INDENT> if par [ x ] < 0 : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> par [ x ] = find ( par [ x ] ) <NEWLINE> return par [ x ] <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> def unite ( x , y ) : <NEWLINE> <INDENT> x = find ( x ) <NEWLINE> y = find ( y ) <NEWLINE> <NL> if x == y : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> else : <NEWLINE> <COMMENT> <NL> <INDENT> if par [ x ] > par [ y ] : <NEWLINE> <INDENT> x , y = y , x <NEWLINE> <DEDENT> par [ x ] += par [ y ] <NEWLINE> par [ y ] = x <NEWLINE> return True <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> def same ( x , y ) : <NEWLINE> <INDENT> return find ( x ) == find ( y ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> def size ( x ) : <NEWLINE> <INDENT> return - par [ find ( x ) ] <NEWLINE> <NL> <DEDENT> import numpy as np <NEWLINE> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> par = [ - 1 ] * n <NEWLINE> <NL> for i in range ( m ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> unite ( x , y ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> print ( - min ( par ) ) <NEWLINE>
<COMMENT> <NL> import sys <NEWLINE> import networkx as nx <NEWLINE> from random import randint <NEWLINE> def solve ( N : int , M : int , A : <STRING> , B : <STRING> ) : <NEWLINE> <INDENT> G = nx . Graph ( ) <NEWLINE> <NL> if M == 0 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> for a , b in zip ( A , B ) : <NEWLINE> <INDENT> G . add_edge ( a , b ) <NEWLINE> <NL> <DEDENT> Gc = max ( nx . connected_components ( G ) , key = len ) <NEWLINE> print ( len ( Gc ) ) <NEWLINE> return <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> def main ( ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <INDENT> while True : <NEWLINE> <INDENT> N = randint ( 10000 , 100000 ) <COMMENT> <NEWLINE> M = 0 <COMMENT> <NEWLINE> <NL> A = [ randint ( 1 , N ) for i in range ( M ) ] <COMMENT> <NEWLINE> B = [ randint ( 1 , N ) for i in range ( M ) ] <COMMENT> <NEWLINE> solve ( N , M , A , B ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> uf = UnionFind ( n ) <NEWLINE> for a , b in ( map ( lambda x : int ( x ) - 1 , input ( ) . split ( ) ) for _ in range ( m ) ) : <NEWLINE> <INDENT> uf . union ( a , b ) <NEWLINE> <DEDENT> print ( max ( ( uf . size ( x ) for x in uf . roots ( ) ) ) ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> data2 = [ ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> data2 . append ( input ( ) . split ( ) ) <NEWLINE> <NL> <NL> <DEDENT> graph = [ [ ] for i in range ( n ) ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( lambda z : int ( z ) - 1 , data2 [ m ] ) <NEWLINE> graph [ a ] . append ( b ) <NEWLINE> graph [ b ] . append ( a ) <NEWLINE> <NL> <DEDENT> print ( graph ) <NEWLINE> size = [ 0 for i in range ( n ) ] <NEWLINE> check = [ True for i in range ( n ) ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if check [ i ] : <NEWLINE> <INDENT> tmp = 1 <NEWLINE> stack = [ i ] <NEWLINE> check [ i ] = False <NEWLINE> while stack : <NEWLINE> <INDENT> now = stack . pop ( ) <NEWLINE> size [ now ] = tmp <NEWLINE> print ( size ) <NEWLINE> tmp += 1 <NEWLINE> for to in graph [ now ] : <NEWLINE> <INDENT> if check [ to ] : <NEWLINE> <INDENT> check [ to ] = False <NEWLINE> stack . append ( to ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( max ( size ) ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> g = [ [ ] for i in [ 0 ] * ( n + 1 ) ] <NEWLINE> for _ in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> g [ a ] . append ( b ) <NEWLINE> g [ b ] . append ( a ) <NEWLINE> <NL> <DEDENT> def bfs ( n , m , adj ) : <NEWLINE> <INDENT> visited = [ 0 for i in [ 0 ] * ( n + 1 ) ] <NEWLINE> ans = 1 <NEWLINE> for i in range ( n + 1 ) : <NEWLINE> <INDENT> if visited [ i ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> Q = deque ( [ i ] ) <NEWLINE> temp = 1 <NEWLINE> while Q : <NEWLINE> <INDENT> q = Q . popleft ( ) <NEWLINE> visited [ q ] = 1 <NEWLINE> link = adj [ q ] <NEWLINE> for j in link : <NEWLINE> <INDENT> if visited [ j ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> visited [ j ] = 1 <NEWLINE> temp += 1 <NEWLINE> Q . append ( j ) <NEWLINE> <DEDENT> <DEDENT> ans = max ( ans , temp ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <DEDENT> bfs ( n , m , g ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> class UnionFind : <NEWLINE> <INDENT> def __init__ ( self , size ) : <NEWLINE> <INDENT> self . parent_indexes = [ - 1 ] * size <NEWLINE> <NL> <DEDENT> def find_parent ( self , n ) : <NEWLINE> <COMMENT> <NL> <INDENT> if self . parent_indexes [ n ] < 0 : <NEWLINE> <INDENT> return n <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> self . parent_indexes [ n ] = self . find_parent ( self . parent_indexes [ n ] ) <NEWLINE> return self . parent_indexes [ n ] <NEWLINE> <NL> <DEDENT> def union ( self , n1 , n2 ) : <NEWLINE> <INDENT> if self . same_group ( n1 , n2 ) : <NEWLINE> <INDENT> return False <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> if self . size ( n1 ) >= self . size ( n2 ) : <NEWLINE> <INDENT> tmp = self . size ( n2 ) <NEWLINE> self . parent_indexes [ self . find_parent ( n2 ) ] = self . find_parent ( n1 ) <NEWLINE> self . parent_indexes [ self . find_parent ( n1 ) ] -= tmp <NEWLINE> return True <NEWLINE> <NL> <DEDENT> tmp = self . size ( n1 ) <NEWLINE> self . parent_indexes [ self . find_parent ( n1 ) ] = self . find_parent ( n2 ) <NEWLINE> self . parent_indexes [ self . find_parent ( n2 ) ] -= tmp <NEWLINE> return True <NEWLINE> <NL> <NL> <DEDENT> def size ( self , n ) : <NEWLINE> <INDENT> return - self . parent_indexes [ self . find_parent ( n ) ] <NEWLINE> <NL> <DEDENT> def same_group ( self , n1 , n2 ) : <NEWLINE> <INDENT> return self . find_parent ( n1 ) == self . find_parent ( n2 ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> n , m = map ( lambda x : int ( x ) , input ( ) . split ( ) ) <NEWLINE> uf = UnionFind ( n ) <NEWLINE> <NL> n , m = map ( lambda x : int ( x ) , input ( ) . split ( ) ) <NEWLINE> <NL> uf = UnionFind ( n ) <NEWLINE> <NL> for _ in range ( m ) : <NEWLINE> <INDENT> a , b = map ( lambda x : int ( x ) , input ( ) . split ( ) ) <NEWLINE> uf . union ( a - 1 , b - 1 ) <NEWLINE> <NL> <DEDENT> print ( - min ( uf . parent_indexes ) ) <NEWLINE>
class UnionFind : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . par = list ( range ( n ) ) <COMMENT> <NEWLINE> self . rank = [ 0 ] * n <COMMENT> <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> def find ( self , x ) : <NEWLINE> <INDENT> if self . par [ x ] == x : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . par [ x ] = self . find ( self . par [ x ] ) <NEWLINE> return self . par [ x ] <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> def unite ( self , x , y ) : <NEWLINE> <INDENT> x = self . find ( x ) <NEWLINE> y = self . find ( y ) <NEWLINE> if x == y : <NEWLINE> <COMMENT> <NL> <INDENT> return <NEWLINE> <DEDENT> if self . rank [ x ] < self . rank [ y ] : <NEWLINE> <INDENT> self . par [ x ] = y <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . par [ y ] = x <NEWLINE> if self . rank [ x ] == self . rank [ y ] : <NEWLINE> <INDENT> self . rank [ x ] += 1 <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> def same ( self , x , y ) : <NEWLINE> <INDENT> return self . find ( x ) == self . find ( y ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> uf = UnionFind ( N ) <NEWLINE> <NL> for _ in range ( M ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> uf . unite ( a - 1 , b - 1 ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <NL> <DEDENT> cnt = [ 0 ] * n <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> cnt [ uf . par [ i ] ] += 1 <NEWLINE> <DEDENT> print ( max ( cnt ) ) <NEWLINE>
import sys <NEWLINE> class UnionFind ( ) : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . parents = [ - 1 ] * n <NEWLINE> <NL> <DEDENT> def find ( self , x ) : <NEWLINE> <INDENT> if self . parents [ x ] < 0 : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . parents [ x ] = self . find ( self . parents [ x ] ) <NEWLINE> return self . parents [ x ] <NEWLINE> <NL> <DEDENT> <DEDENT> def union ( self , x , y ) : <NEWLINE> <INDENT> x = self . find ( x ) <NEWLINE> y = self . find ( y ) <NEWLINE> <NL> if x == y : <NEWLINE> <INDENT> return <NEWLINE> <NL> <DEDENT> if self . parents [ x ] > self . parents [ y ] : <NEWLINE> <INDENT> x , y = y , x <NEWLINE> <NL> <DEDENT> self . parents [ x ] += self . parents [ y ] <NEWLINE> self . parents [ y ] = x <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> info = [ tuple ( map ( int , s . split ( ) ) ) for s in sys . stdin . readlines ( ) ] <NEWLINE> <COMMENT> <NL> <NL> uf = UnionFind ( N ) <NEWLINE> <NL> for a , b in info : <NEWLINE> <INDENT> a -= 1 ; b -= 1 <NEWLINE> uf . union ( a , b ) <NEWLINE> <NL> <COMMENT> <NL> <NL> <DEDENT> print ( - ans ) <NEWLINE>
from functools import lru_cache <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> x = set ( ) <NEWLINE> y = a [ 0 ] <NEWLINE> pair = True <NEWLINE> for i in a : <NEWLINE> <INDENT> if pair : <NEWLINE> <INDENT> p = set ( prime_factorize ( i ) ) <NEWLINE> if len ( x & p ) > 0 : <NEWLINE> <INDENT> pair = False <NEWLINE> <DEDENT> x |= p <NEWLINE> <DEDENT> y = math . gcd ( y , i ) <NEWLINE> <DEDENT> if pair : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif y == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> @ lru_cache ( maxsize = None ) <NEWLINE> def primes ( n : int ) -> list : <NEWLINE> <INDENT> <STRING> <NEWLINE> is_prime = [ True ] * ( n + 1 ) <NEWLINE> is_prime [ 0 ] = False <NEWLINE> is_prime [ 1 ] = False <NEWLINE> for i in range ( 2 , int ( n ** 0.5 ) + 1 ) : <NEWLINE> <INDENT> if not is_prime [ i ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> for j in range ( i * 2 , n + 1 , i ) : <NEWLINE> <INDENT> is_prime [ j ] = False <NEWLINE> <DEDENT> <DEDENT> return [ i for i in range ( n + 1 ) if is_prime [ i ] ] <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> @ lru_cache ( maxsize = None ) <NEWLINE> def is_prime ( n : int ) -> bool : <NEWLINE> <INDENT> <STRING> <NEWLINE> if n == 1 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> elif n == 2 : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> elif n % 2 == 0 : <NEWLINE> <INDENT> return False <NEWLINE> <NL> <DEDENT> for i in range ( 3 , int ( n ** 0.5 ) + 1 , 2 ) : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> <DEDENT> return True <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> def prime_factorize ( n : int ) -> list : <NEWLINE> <INDENT> <STRING> <NEWLINE> arr = [ ] <NEWLINE> <COMMENT> <NL> while n % 2 == 0 : <NEWLINE> <INDENT> arr . append ( 2 ) <NEWLINE> n //= 2 <NEWLINE> <COMMENT> <NL> <DEDENT> for f in primes ( int ( n ** 0.5 ) ) : <NEWLINE> <INDENT> while n % f == 0 : <NEWLINE> <INDENT> arr . append ( f ) <NEWLINE> n //= f <NEWLINE> <DEDENT> <DEDENT> if n != 1 : <NEWLINE> <INDENT> arr . append ( n ) <NEWLINE> <DEDENT> return arr <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
def gcc ( x , y ) : <NEWLINE> <INDENT> if x == 0 : return y <NEWLINE> return gcc ( y % x , x ) <NEWLINE> <NL> <DEDENT> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> g = 0 <NEWLINE> <NL> A . sort ( ) <NEWLINE> <NL> for item in A : <NEWLINE> <INDENT> g = gcc ( g , item ) <NEWLINE> <NL> <DEDENT> if g != 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> primes = [ ] <NEWLINE> <NL> is_prime = [ True ] * 1100000 <NEWLINE> primes = [ ] <NEWLINE> <NL> is_prime [ 0 ] = is_prime [ 1 ] = False <NEWLINE> <NL> for i in range ( 2 , 1100000 ) : <NEWLINE> <INDENT> if not is_prime [ i ] : continue <NEWLINE> for j in range ( i * i , 1100000 , i ) : <NEWLINE> <INDENT> is_prime [ j ] = False <NEWLINE> <DEDENT> primes . append [ i ] <NEWLINE> <NL> <DEDENT> A_prime = [ item for item in A if is_prime [ item ] ] <NEWLINE> A_notprime = [ item for item in A if not is_prime [ item ] ] <NEWLINE> <NL> used = [ False ] * 1100000 <NEWLINE> <NL> for item in A_prime : <NEWLINE> <INDENT> used [ item ] = True <NEWLINE> <NL> <DEDENT> for a in A_notprime : <NEWLINE> <INDENT> for p in primes : <NEWLINE> <INDENT> if a == 1 : break <NEWLINE> if a % p != 0 : continue <NEWLINE> <NL> if used [ p ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <COMMENT> <NL> exit ( ) <NEWLINE> <NL> <DEDENT> used [ p ] = True <NEWLINE> <NL> while a > p : <NEWLINE> <INDENT> a //= p <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
<COMMENT> <NL> import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> INF = 10 ** 9 + 1 <COMMENT> <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> <NL> <NL> def debug ( * x ) : <NEWLINE> <INDENT> print ( * x , file = sys . stderr ) <NEWLINE> <NL> <NL> <DEDENT> def precompute ( ) : <NEWLINE> <INDENT> maxAS = 1000000 <NEWLINE> eratree = [ 0 ] * ( maxAS + 10 ) <NEWLINE> for p in range ( 2 , maxAS + 1 ) : <NEWLINE> <INDENT> if eratree [ p ] : <NEWLINE> <INDENT> continue <NEWLINE> <COMMENT> <NL> <DEDENT> eratree [ p ] = p <NEWLINE> x = p * p <NEWLINE> while x <= maxAS : <NEWLINE> <INDENT> if not eratree [ x ] : <NEWLINE> <INDENT> eratree [ x ] = p <NEWLINE> <DEDENT> x += p <NEWLINE> <NL> <DEDENT> <DEDENT> import pickle <NEWLINE> pickle . dump ( eratree , open ( <STRING> , <STRING> ) ) <NEWLINE> <NL> <NL> <DEDENT> def solve ( N , AS ) : <NEWLINE> <INDENT> import pickle <NEWLINE> eratree = pickle . load ( open ( <STRING> , <STRING> ) ) <NEWLINE> num_division = 0 <NEWLINE> <NL> from collections import defaultdict <NEWLINE> count = defaultdict ( int ) <NEWLINE> for a in AS : <NEWLINE> <INDENT> factors = [ ] <NEWLINE> while a > 1 : <NEWLINE> <INDENT> d = eratree [ a ] <NEWLINE> factors . append ( d ) <NEWLINE> a //= d <NEWLINE> num_division += 1 <NEWLINE> <COMMENT> <NL> <DEDENT> for f in set ( factors ) : <NEWLINE> <INDENT> count [ f ] += 1 <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> if any ( x == N for x in count . values ( ) ) : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> if any ( x >= 2 for x in count . values ( ) ) : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> return <STRING> <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <COMMENT> <NL> <INDENT> N = int ( input ( ) ) <NEWLINE> AS = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> print ( solve ( N , AS ) ) <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> T1 = <STRING> <NEWLINE> TEST_T1 = <STRING> <NEWLINE> <NL> T2 = <STRING> <NEWLINE> TEST_T2 = <STRING> <NEWLINE> <NL> T3 = <STRING> <NEWLINE> TEST_T3 = <STRING> <NEWLINE> <NL> T4 = <STRING> <NEWLINE> TEST_T4 = <STRING> <NEWLINE> <NL> <NL> def _test ( ) : <NEWLINE> <INDENT> import doctest <NEWLINE> doctest . testmod ( ) <NEWLINE> g = globals ( ) <NEWLINE> for k in sorted ( g ) : <NEWLINE> <INDENT> if k . startswith ( <STRING> ) : <NEWLINE> <INDENT> doctest . run_docstring_examples ( g [ k ] , g , name = k ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> def as_input ( s ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> import io <NEWLINE> f = io . StringIO ( s . strip ( ) ) <NEWLINE> g = globals ( ) <NEWLINE> g [ <STRING> ] = lambda : bytes ( f . readline ( ) , <STRING> ) <NEWLINE> g [ <STRING> ] = lambda : bytes ( f . read ( ) , <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> input = sys . stdin . buffer . readline <NEWLINE> read = sys . stdin . buffer . read <NEWLINE> <NL> if sys . argv [ - 1 ] == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> _test ( ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> if sys . argv [ - 1 ] == <STRING> : <NEWLINE> <INDENT> precompute ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
from math import gcd <NEWLINE> from functools import reduce <NEWLINE> <NL> def make_prime_table ( n ) : <NEWLINE> <INDENT> sieve = list ( range ( n + 1 ) ) <NEWLINE> sieve [ 0 ] = - 1 <NEWLINE> sieve [ 1 ] = - 1 <NEWLINE> for i in range ( 4 , n + 1 , 2 ) : <NEWLINE> <INDENT> sieve [ i ] = 2 <NEWLINE> <DEDENT> for i in range ( 3 , int ( n ** 0.5 ) + 1 , 2 ) : <NEWLINE> <INDENT> if sieve [ i ] != i : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> for j in range ( i * i , n + 1 , i * 2 ) : <NEWLINE> <INDENT> if sieve [ j ] == j : <NEWLINE> <INDENT> sieve [ j ] = i <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return sieve <NEWLINE> <NL> <NL> <DEDENT> def prime_factorize ( n ) : <NEWLINE> <INDENT> result = [ ] <NEWLINE> while n != 1 : <NEWLINE> <INDENT> p = prime_table [ n ] <NEWLINE> e = 0 <NEWLINE> while n % p == 0 : <NEWLINE> <INDENT> n //= p <NEWLINE> e += 1 <NEWLINE> <DEDENT> result . append ( ( p , e ) ) <NEWLINE> <DEDENT> return result <NEWLINE> <NL> <NL> <DEDENT> def f ( ) : <NEWLINE> <INDENT> s = set ( ) <NEWLINE> for i in range ( N - 1 , - 1. - 1 ) : <NEWLINE> <INDENT> t = prime_factorize ( A [ i ] ) <NEWLINE> for p , _ in t : <NEWLINE> <INDENT> if p in s : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> s . add ( p ) <NEWLINE> <DEDENT> <DEDENT> return True <NEWLINE> <NL> <NL> <DEDENT> N , * A = map ( int , open ( 0 ) . read ( ) . split ( ) ) <NEWLINE> <NL> prime_table = make_prime_table ( 10 ** 6 ) <NEWLINE> if f ( ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif reduce ( gcd , A ) == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> 1 / ( n > 3 ) <NEWLINE>
from math import gcd <COMMENT> <NEWLINE> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> n = int ( input ( ) ) <NEWLINE> lis = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A = 10 ** 6 <NEWLINE> nlis = [ 0 ] * A <NEWLINE> flg_pairwise = True <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> nlis [ lis [ i ] - 1 ] += 1 <NEWLINE> <NL> <DEDENT> for i in range ( A ) : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> for j in range ( i - 1 , A , i ) : <NEWLINE> <INDENT> cnt += nlis [ j ] <NEWLINE> <DEDENT> if cnt > 1 : <NEWLINE> <INDENT> flg_pairwise = False <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if flg_pairwise : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( n - 1 ) : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> tmp = gcd ( lis [ i ] , lis [ i + 1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> tmp = gcd ( tmp , lis [ i + 1 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> if tmp == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
max_num = 10 ** 6 + 1 <NEWLINE> prime = [ i for i in range ( max_num ) ] <NEWLINE> r2_num = int ( max_num ** ( 1 / 2 ) ) + 1 <NEWLINE> for i in range ( 2 , r2_num ) : <NEWLINE> <INDENT> if prime [ i ] == i : <NEWLINE> <INDENT> for j in range ( i ** 2 , max_num , i ) : <NEWLINE> <INDENT> if prime [ j ] == j : <NEWLINE> <INDENT> prime [ j ] = i <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> def gcd ( a , b ) : <COMMENT> <NEWLINE> <INDENT> if a % b == 0 : <NEWLINE> <INDENT> return b <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return gcd ( b , a % b ) <NEWLINE> <NL> <DEDENT> <DEDENT> flg_pairwise = True <NEWLINE> flg_setwise = False <NEWLINE> <NL> n = int ( input ( ) . rstrip ( ) ) <NEWLINE> a_ls = list ( map ( int , input ( ) . rstrip ( ) . split ( <STRING> ) ) ) <NEWLINE> gcd_a = 0 <NEWLINE> primes_a = [ ] <NEWLINE> count_prime = [ 0 for i in range ( max_num ) ] <NEWLINE> for a in a_ls : <NEWLINE> <INDENT> gcd_a = gcd ( gcd_a , a ) <NEWLINE> if gcd_a == 1 : <NEWLINE> <INDENT> flg_setwise = True <NEWLINE> <DEDENT> tmp_prime = [ ] <NEWLINE> if flg_pairwise : <NEWLINE> <INDENT> while a > 1 : <NEWLINE> <INDENT> p = prime [ a ] <NEWLINE> if tmp_prime == [ ] or tmp_prime [ - 1 ] != p : <NEWLINE> <INDENT> tmp_prime . append ( p ) <NEWLINE> a = a // p <NEWLINE> <DEDENT> <DEDENT> for tp in tmp_prime : <NEWLINE> <INDENT> for pa in primes_a : <NEWLINE> <INDENT> if pa == tp : <NEWLINE> <INDENT> flg_pairwise = False <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if flg_pairwise : <NEWLINE> <INDENT> primes_a . append ( tp ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if flg_setwise and not flg_pairwise : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> if flg_pairwise : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif flg_setwise : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import math <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> inf = int ( 1e6 + 5 ) <NEWLINE> C = [ 0 ] * inf <NEWLINE> <NL> for a in A : <NEWLINE> <INDENT> C [ a ] += 1 <NEWLINE> <NL> <DEDENT> pa = True <NEWLINE> se = True <NEWLINE> for i in range ( 2 , inf ) : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> for j in range ( i , inf , i ) : <NEWLINE> <INDENT> cnt += C [ j ] <NEWLINE> <DEDENT> if cnt > 1 : <NEWLINE> <INDENT> pa = False <NEWLINE> <DEDENT> if cnt == N : <NEWLINE> <INDENT> se = False <NEWLINE> <NL> <DEDENT> <DEDENT> if pa : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif se : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
def gcd ( x , y ) : <NEWLINE> <INDENT> if y == 0 : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return gcd ( y , x % y ) <NEWLINE> <NL> <DEDENT> <DEDENT> def factorization ( n ) : <NEWLINE> <INDENT> arr = [ ] <NEWLINE> temp = n <NEWLINE> for i in range ( 2 , int ( - ( - n ** 0.5 // 1 ) ) + 1 ) : <NEWLINE> <INDENT> if temp % i == 0 : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> while temp % i == 0 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> temp //= i <NEWLINE> <DEDENT> arr . append ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> if temp != 1 : <NEWLINE> <INDENT> arr . append ( temp ) <NEWLINE> <NL> <DEDENT> return arr <NEWLINE> <NL> <DEDENT> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> p = 1 <NEWLINE> A = sorted ( A ) <NEWLINE> num1 = A . count ( 1 ) <NEWLINE> B = list ( set ( A ) ) <NEWLINE> if len ( B ) < len ( A ) - num1 + 1 : <NEWLINE> <INDENT> p = 0 <NEWLINE> <DEDENT> S = set ( factorization ( B [ 0 ] ) ) <NEWLINE> T = set ( factorization ( B [ 0 ] ) ) <NEWLINE> flg = 0 <NEWLINE> for i in range ( 1 , len ( B ) ) : <NEWLINE> <INDENT> prime = set ( factorization ( B [ i ] ) <NEWLINE> if T & prime != set ( ) : <NEWLINE> <INDENT> flg = 1 <NEWLINE> <DEDENT> S = S & prime <NEWLINE> T = T | prime <COMMENT> <NEWLINE> <DEDENT> if S != 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif flg == 1 or p = 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> from numba import njit <NEWLINE> def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> nlist = np . array ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> def gdc ( x , y ) : <NEWLINE> <INDENT> b = max ( x , y ) <NEWLINE> s = min ( x , y ) <NEWLINE> r = b % s <NEWLINE> if r == 0 : <NEWLINE> <INDENT> return s <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return gdc ( s , r ) <NEWLINE> <NL> <DEDENT> <DEDENT> scp = False <NEWLINE> pcp = False <NEWLINE> <NL> sgdc = nlist [ 0 ] <NEWLINE> for n in nlist : <NEWLINE> <INDENT> sgdc = gdc ( sgdc , n ) <NEWLINE> if sgdc == 1 : <NEWLINE> <INDENT> scp = True <NEWLINE> <NL> <DEDENT> <DEDENT> if not scp : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> pcheckl = np . full ( ( 10 ** 6 + 1 ) , 0 ) <NEWLINE> for n in nlist : <NEWLINE> <INDENT> pcheckl [ n ] = 1 <NEWLINE> <NL> <DEDENT> pcp = np . all ( [ sum ( pcheckl [ i : : i ] ) <= 1 for i in range ( 2 , 10 ** 6 + 1 ) ] ) <NEWLINE> <NL> if pcp : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif scp : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> def main ( ) : <NEWLINE> <INDENT> from math import gcd <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = [ ] <NEWLINE> INF = 10 ** 6 <NEWLINE> frequency = [ 0 ] * INF <NEWLINE> for a in [ int ( x ) for x in input ( ) . split ( ) ] : <NEWLINE> <INDENT> A . append ( a ) <NEWLINE> frequency [ a ] += 1 <NEWLINE> <NL> <DEDENT> pairwise = True <NEWLINE> for i in range ( 2 , INF ) : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> for j in range ( i , INF , i ) : <NEWLINE> <INDENT> cnt += frequency [ j ] <NEWLINE> <DEDENT> if cnt > 1 : <NEWLINE> <INDENT> pairwise = False <NEWLINE> <DEDENT> <DEDENT> if pairwise : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> g = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> g = gcd ( g , A [ i ] ) <NEWLINE> if g == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import math <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> m = max ( a ) + 1 <NEWLINE> g = a [ 0 ] <NEWLINE> d = dict ( ) <NEWLINE> for i in a : <NEWLINE> <INDENT> g = math . gcd ( g , i ) <NEWLINE> if i in d : <NEWLINE> <INDENT> d [ i ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d [ i ] = 1 <NEWLINE> <DEDENT> <DEDENT> if g > 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> p = [ 0 ] * ( m ) <NEWLINE> ch = 0 <NEWLINE> for i in range ( 2 , m ) : <NEWLINE> <INDENT> if p [ i ] == 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> p [ i ] = 1 <NEWLINE> ans = 0 <NEWLINE> for j in range ( i , m , i ) : <NEWLINE> <INDENT> ans += d [ j ] <NEWLINE> <DEDENT> if ans > 1 : <NEWLINE> <INDENT> ch = 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if ch == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
from math import gcd <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( [ int ( x ) for x in input ( ) . split ( ) ] ) <NEWLINE> <NL> max_a = 10 ** 6 + 1 <NEWLINE> <NL> before = 0 <NEWLINE> result = [ 0 for _ in range ( max_a + 1 ) ] <NEWLINE> <NL> for i in A : <NEWLINE> <INDENT> before = gcd ( before , i ) <NEWLINE> result [ i ] += 1 <NEWLINE> <NL> <DEDENT> is_pairwise = True <NEWLINE> for i in range ( 2 , max_a + 1 ) : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> for j in range ( i , max_a + 1 , i ) : <NEWLINE> <INDENT> cnt += result [ j ] <NEWLINE> <NL> <DEDENT> if cnt > 1 : <NEWLINE> <INDENT> is_pairwise = False <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if is_pairwise : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> if before == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> <COMMENT> <NL> def int1 ( x ) : return int ( x ) - 1 <NEWLINE> def II ( ) : return int ( input ( ) ) <NEWLINE> def MI ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def MI1 ( ) : return map ( int1 , input ( ) . split ( ) ) <NEWLINE> def LI ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> def LI1 ( ) : return list ( map ( int1 , input ( ) . split ( ) ) ) <NEWLINE> def LLI ( rows_number ) : return [ LI ( ) for _ in range ( rows_number ) ] <NEWLINE> def MS ( ) : return input ( ) . split ( ) <NEWLINE> def LS ( ) : return list ( input ( ) ) <NEWLINE> def LLS ( rows_number ) : return [ LS ( ) for _ in range ( rows_number ) ] <NEWLINE> def printlist ( lst , k = <STRING> ) : print ( k . join ( list ( map ( str , lst ) ) ) ) <NEWLINE> INF = float ( <STRING> ) <NEWLINE> <COMMENT> <NL> from collections import deque , defaultdict <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> from math import gcd <NEWLINE> <NL> def solve ( ) : <NEWLINE> <INDENT> N = II ( ) <NEWLINE> A = LI ( ) <NEWLINE> <NL> mx = 1000003 <NEWLINE> D = [ 1 ] * mx <NEWLINE> for i in range ( 2 , len ( D ) ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <INDENT> for j in range ( i , len ( D ) , i ) : <NEWLINE> <INDENT> if D [ j ] == 1 : <NEWLINE> <INDENT> D [ j ] = i <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> g = A [ 0 ] <NEWLINE> dct = defaultdict ( int ) <NEWLINE> flag = True <NEWLINE> for a in A : <NEWLINE> <INDENT> g = gcd ( g , a ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> d = D [ a ] <NEWLINE> p = a <NEWLINE> <COMMENT> <NL> while p != d : <NEWLINE> <INDENT> p = p // d <NEWLINE> d = D [ p ] <NEWLINE> <NL> <DEDENT> if p != 1 : <NEWLINE> <INDENT> dct [ p ] += 1 <NEWLINE> if dct [ p ] > 1 : <NEWLINE> <INDENT> flag = False <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if g == 1 : <NEWLINE> <INDENT> if flag : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> solve ( ) <NEWLINE> <NL> <DEDENT>
import numpy as np <NEWLINE> import sys <NEWLINE> i4 = np . int32 <NEWLINE> i8 = np . int64 <NEWLINE> u4 = np . uint32 <NEWLINE> <NL> if sys . argv [ - 1 ] == <STRING> : <NEWLINE> <INDENT> from numba . pycc import CC <NEWLINE> from numba import njit <NEWLINE> from numba . types import int64 , Array , uint32 <NEWLINE> cc = CC ( <STRING> ) <NEWLINE> <NL> @ njit <NEWLINE> def factorization ( N ) : <NEWLINE> <INDENT> p = np . zeros ( N + 1 , u4 ) <NEWLINE> n_max = int ( np . sqrt ( N ) ) + 1 <NEWLINE> p [ 0 ] = 1 <NEWLINE> p [ 1 ] = 1 <NEWLINE> for i in range ( 2 , n_max ) : <NEWLINE> <INDENT> if p [ i ] == 0 : <NEWLINE> <INDENT> j = i <NEWLINE> while j <= N : <NEWLINE> <INDENT> p [ j ] = i <NEWLINE> j += i <NEWLINE> <DEDENT> <DEDENT> <DEDENT> for i in range ( n_max , N + 1 ) : <NEWLINE> <INDENT> if p [ i ] == 0 : <NEWLINE> <INDENT> p [ i ] = i <NEWLINE> <DEDENT> <DEDENT> return p <NEWLINE> <NL> <DEDENT> @ cc . export ( <STRING> , ( Array ( uint32 , 1 , <STRING> ) , ) ) <NEWLINE> def solve ( A ) : <NEWLINE> <INDENT> a = np . sort ( A ) <NEWLINE> p_max = a [ - 1 ] <NEWLINE> p = factorization ( p_max ) <NEWLINE> primes_num = 0 <NEWLINE> for i in range ( p . shape [ 0 ] ) : <NEWLINE> <INDENT> if i == p [ i ] : <NEWLINE> <INDENT> primes_num += 1 <NEWLINE> <DEDENT> <DEDENT> a_start = 0 <NEWLINE> while a [ a_start ] == 1 : <NEWLINE> <INDENT> a_start += 1 <NEWLINE> if a_start == a . shape [ 0 ] : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> <DEDENT> a = a [ a_start : ] <NEWLINE> if len ( a ) > primes_num : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> check = np . zeros ( p_max + 1 , u4 ) <NEWLINE> s = set ( ) <NEWLINE> for d in a : <NEWLINE> <INDENT> while d > 1 : <NEWLINE> <INDENT> x = p [ d ] <NEWLINE> s . add ( x ) <NEWLINE> d //= x <NEWLINE> <NL> <DEDENT> while s : <NEWLINE> <INDENT> check [ s . pop ( ) ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if check . max ( ) > 1 : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> <DEDENT> cc . compile ( ) <NEWLINE> exit ( ) <NEWLINE> <NL> <NL> <DEDENT> def main ( in_file ) : <NEWLINE> <INDENT> stdin = open ( in_file ) <NEWLINE> stdin . readline ( ) <NEWLINE> A = np . fromstring ( stdin . readline ( ) , u4 , sep = <STRING> ) <NEWLINE> ans = solve ( A ) <NEWLINE> if ans : <NEWLINE> <INDENT> g = np . gcd . reduce ( A ) <NEWLINE> if g > 1 : <NEWLINE> <INDENT> ans = 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = 1 <NEWLINE> <DEDENT> <DEDENT> p = [ <STRING> , <STRING> , <STRING> ] <NEWLINE> print ( p [ ans ] ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> from my_module import solve <NEWLINE> main ( <STRING> ) <NEWLINE> <DEDENT>
from math import gcd <NEWLINE> import numpy as np <NEWLINE> <NL> def setwise_coprime_check_fun ( A_list , N ) : <NEWLINE> <INDENT> gcd_all = A_list [ 0 ] <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> gcd_all = gcd ( gcd_all , A_list [ i + 1 ] ) <NEWLINE> if gcd_all == 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> return gcd_all <NEWLINE> <NL> <DEDENT> def preprocess_fun ( A_max ) : <NEWLINE> <INDENT> p_flg = [ True ] * ( A_max + 1 ) <NEWLINE> D = [ 0 ] * ( A_max + 1 ) <NEWLINE> p_flg [ 0 ] = False <NEWLINE> p_flg [ 1 ] = False <NEWLINE> for i in range ( 2 , A_max + 1 , 1 ) : <NEWLINE> <INDENT> if p_flg [ i ] : <NEWLINE> <INDENT> for j in range ( i , A_max + 1 , i ) : <NEWLINE> <INDENT> p_flg [ j ] = False <NEWLINE> D [ j ] = i <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return D <NEWLINE> <NL> <DEDENT> def pairwise_coprime_check ( A_list , D ) : <NEWLINE> <INDENT> p_count = [ 0 ] * ( max ( A_list ) + 1 ) <NEWLINE> for A in A_list : <NEWLINE> <INDENT> temp = A <NEWLINE> d = 0 <NEWLINE> while temp != 1 : <NEWLINE> <INDENT> if p_count [ D [ temp ] ] == 1 and d != D [ temp ] : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> p_count [ D [ temp ] ] = 1 <NEWLINE> d = D [ temp ] <NEWLINE> temp = temp // D [ temp ] <NEWLINE> <DEDENT> <DEDENT> return 1 <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> A_max = max ( A_list ) <NEWLINE> <NL> <COMMENT> <NL> if ( setwise_coprime_check_fun ( A_list , N ) != 1 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> D = preprocess_fun ( A_max ) <NEWLINE> if pairwise_coprime_check ( A_list , D ) == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> <COMMENT> <NL> number_to_prime = [ 0 ] * ( 10 ** 6 + 1 ) <NEWLINE> <NL> <COMMENT> <NL> for i in range ( 2 , 10 ** 6 + 1 ) : <NEWLINE> <INDENT> if not number_to_prime [ i ] : <NEWLINE> <INDENT> j = 1 <NEWLINE> while j * i <= 10 ** 6 : <NEWLINE> <INDENT> number_to_prime [ j * i ] = i <NEWLINE> j += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> def is_pair_copr ( A ) : <NEWLINE> <INDENT> U = 1 << 20 <NEWLINE> div_p = np . arange ( U ) <NEWLINE> for p in range ( 2 , U ) : <NEWLINE> <INDENT> if div_p [ p ] != p : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> div_p [ p : : p ] = p <NEWLINE> <DEDENT> used = np . zeros ( U , np . bool_ ) <NEWLINE> <NL> for x in A : <NEWLINE> <INDENT> while x > 1 : <NEWLINE> <INDENT> p = div_p [ x ] <NEWLINE> while x % p == 0 : <NEWLINE> <INDENT> x //= p <NEWLINE> <DEDENT> if used [ p ] : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> used [ p ] = True <NEWLINE> <DEDENT> <DEDENT> return True <NEWLINE> <NL> <DEDENT> def is_pairwise ( ) : <NEWLINE> <INDENT> used_primes = set ( ) <NEWLINE> pairwise_flag = 1 <NEWLINE> for a in A : <NEWLINE> <INDENT> curr_primes = set ( ) <NEWLINE> while a > 1 : <NEWLINE> <INDENT> prime = number_to_prime [ a ] <NEWLINE> curr_primes . add ( prime ) <NEWLINE> a //= prime <NEWLINE> <DEDENT> if used_primes & curr_primes : <NEWLINE> <INDENT> pairwise_flag = 0 <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> used_primes = used_primes | curr_primes <NEWLINE> <DEDENT> <DEDENT> return pairwise_flag <NEWLINE> <NL> <DEDENT> def is_setwise ( * A ) : <NEWLINE> <INDENT> import math <NEWLINE> from functools import reduce <NEWLINE> <NL> return reduce ( math . gcd , A ) == 1 <NEWLINE> <NL> <DEDENT> if is_pair_copr ( A ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif is_setwise ( * A ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import sys , math <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> numbers = { } <NEWLINE> flag = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if a [ i ] in numbers : <NEWLINE> <INDENT> numbers [ a [ i ] ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> numbers [ a [ i ] ] = 1 <NEWLINE> <DEDENT> <DEDENT> while pointer in range ( 2 , 10 ** 6 + 1 ) : <NEWLINE> <INDENT> count = 0 <NEWLINE> pointer2 = pointer <NEWLINE> while pointer2 < 10 ** 6 + 1 : <NEWLINE> <INDENT> if pointer2 in numbers : <NEWLINE> <INDENT> count += numbers [ pointer2 ] <NEWLINE> <DEDENT> pointer2 += pointer <NEWLINE> <DEDENT> if count >= 2 : <NEWLINE> <INDENT> flag = 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if flag == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> ans = a [ 0 ] <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> ans = math . gcd ( a [ i ] , ans ) <NEWLINE> <DEDENT> if ans == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import math as mt <NEWLINE> n = int ( input ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> gd = l [ 0 ] <NEWLINE> sv = [ 0 ] * ( 10 ** 6 + 1 ) <NEWLINE> for i in range ( 2 , len ( sv ) + 1 ) : <NEWLINE> <INDENT> if not sv [ i ] : <NEWLINE> <INDENT> sv [ i ] = i <NEWLINE> for j in range ( 2 * i , len ( sv ) , i ) : <NEWLINE> <INDENT> sv [ j ] = i <NEWLINE> <DEDENT> <DEDENT> <DEDENT> an = <STRING> <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> gd = mt . gcd ( gd , l [ i ] ) <NEWLINE> <DEDENT> if gd != 1 : <NEWLINE> <INDENT> print ( an ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> an = <STRING> <NEWLINE> pos = 1 <NEWLINE> vis = [ 0 ] * ( 10 ** 6 + 2 ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> cr = l [ i ] <NEWLINE> while cr > 1 : <NEWLINE> <INDENT> dv = sv [ cr ] <NEWLINE> if vis [ dv ] : <NEWLINE> <INDENT> pos = 0 ; break <NEWLINE> <DEDENT> while cr % dv == 0 : <NEWLINE> <INDENT> cr //= dv <NEWLINE> <DEDENT> vis [ dv ] = 1 <NEWLINE> <DEDENT> <DEDENT> if pos : <NEWLINE> <INDENT> an = <STRING> <NEWLINE> <DEDENT> print ( an ) <NEWLINE> <DEDENT>
import math <NEWLINE> <NL> def eratosthenes ( ) : <NEWLINE> <INDENT> erat = [ 0 for _ in range ( max ( a ) + 1 ) ] <NEWLINE> lim = int ( math . sqrt ( max ( set_a ) ) ) <NEWLINE> for i in range ( 2 , lim + 1 ) : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> if not erat [ i ] : <NEWLINE> <INDENT> for res in range ( i , max ( set_a ) + 1 , i ) : <NEWLINE> <INDENT> if res in set_a : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> erat [ i ] = i <NEWLINE> if cnt > 2 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> break <NEWLINE> <DEDENT> return cnt <NEWLINE> <NL> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> a = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> set_a = set ( a ) <NEWLINE> <NL> ans = eratosthenes ( ) <NEWLINE> <NL> if max ( ans . values ( ) ) == 1 and len ( set_a ) == n : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> res = a [ 0 ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> res = math . gcd ( res , a [ i ] ) <NEWLINE> <DEDENT> if res == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
from math import gcd <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <COMMENT> <NL> ans = 0 <NEWLINE> cnt = [ 0 ] * ( max ( a ) + 1 ) <NEWLINE> for ai in a : <NEWLINE> <INDENT> ans = gcd ( ans , ai ) <NEWLINE> cnt [ ai ] += 1 <NEWLINE> <NL> <DEDENT> if ans != 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif any ( sum ( cnt [ i : : i ] ) > 1 for i in range ( max ( a ) + 1 ) ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> from numba import njit <NEWLINE> <NL> <NL> n = int ( input ( ) ) <NEWLINE> arr = np . array ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> <NL> n = 10 ** 3 <NEWLINE> primes = set ( range ( 3 , n + 1 , 2 ) ) <NEWLINE> <NL> for i in range ( 3 , int ( n ** 0.5 + 1 ) ) : <NEWLINE> <INDENT> primes . difference_update ( range ( i * 2 , n + 1 , i ) ) <NEWLINE> <DEDENT> primes . add ( 2 ) <NEWLINE> <NL> <NL> @ njit <NEWLINE> def solve ( arr , primes ) : <NEWLINE> <INDENT> used = [ False ] * 1000 <NEWLINE> ans = True <NEWLINE> for x in arr : <NEWLINE> <INDENT> for p in primes : <NEWLINE> <INDENT> while x % p == 0 : <NEWLINE> <INDENT> if used [ p ] : <NEWLINE> <INDENT> ans = False <NEWLINE> return ans <NEWLINE> <DEDENT> while x % p == 0 : <NEWLINE> <INDENT> x //= p <NEWLINE> <DEDENT> used [ p ] = True <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return ans <NEWLINE> <NL> <NL> <DEDENT> ans1 = np . all ( [ sum ( cnt [ i : : i ] ) <= 1 for i in range ( 2 , 10 ** 6 + 1 ) ] ) <NEWLINE> <NL> <NL> if np . gcd . reduce ( arr ) != 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif ans1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
M = 10 ** 6 + 1 <NEWLINE> f = lambda p : exit ( print ( [ <STRING> , <STRING> , <STRING> ] [ p ] + <STRING> ) ) <NEWLINE> n , * l = map ( int , open ( 0 ) . read ( ) . split ( ) ) <NEWLINE> from math import * <NEWLINE> g = l [ 0 ] <NEWLINE> for x in l : g = gcd ( g , x ) <NEWLINE> if g > 1 : f ( 2 ) <NEWLINE> C = [ 0 ] * M <NEWLINE> for x in l : C [ x ] = 1 <NEWLINE> for i in range ( 2 , M ) : <NEWLINE> <INDENT> if sum ( C [ j ] for j in range ( i , M , i ) ) > 1 : f ( 1 ) <NEWLINE> <DEDENT> f ( 0 ) <NEWLINE>
import math <NEWLINE> <NL> MAX = 10 ** 6 + 3 <NEWLINE> table = list ( range ( MAX ) ) <NEWLINE> i = 2 <NEWLINE> n = MAX <NEWLINE> while i <= n : <NEWLINE> <INDENT> table [ i ] = 2 <NEWLINE> i += 2 <NEWLINE> <NL> <DEDENT> p = 3 <NEWLINE> while p * p <= n : <NEWLINE> <INDENT> if table [ p ] < p : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> x = p <NEWLINE> while x <= n : <NEWLINE> <INDENT> table [ x ] = p <NEWLINE> x += p <NEWLINE> <DEDENT> p += 2 <NEWLINE> <NL> <DEDENT> def primeFactorSet ( n ) : <NEWLINE> <INDENT> result = set ( ) <NEWLINE> while table [ n ] != 1 : <NEWLINE> <INDENT> result . add ( table [ n ] ) <NEWLINE> n //= table [ n ] <NEWLINE> <DEDENT> return result <NEWLINE> <NL> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> pairwise = True <NEWLINE> flags = [ False for _ in range ( MAX ) ] <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> a = A [ i ] <NEWLINE> if pairwise : <NEWLINE> <INDENT> t = primeFactorSet ( a ) <NEWLINE> for p in t : <NEWLINE> <INDENT> if flags [ p ] : <NEWLINE> <INDENT> pairwise = False <NEWLINE> break <NEWLINE> <DEDENT> flags [ p ] = True <NEWLINE> <DEDENT> <DEDENT> if i == 0 : <NEWLINE> <INDENT> g = a <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> g = math . gcd ( g , a ) <NEWLINE> <NL> <DEDENT> <DEDENT> if g > 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif pairwise : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import math <NEWLINE> L = 10 ** 6 + 1 <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> memo = [ 0 ] * L <NEWLINE> flag = 0 <COMMENT> <NEWLINE> <NL> for a in A : <NEWLINE> <INDENT> memo [ a ] = 1 <NEWLINE> <NL> <DEDENT> for i in range ( 2 , L ) : <NEWLINE> <INDENT> if sum ( memo [ i : : i ] ) > 1 : <NEWLINE> <INDENT> flag = 1 : <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> g = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> g = math . gcd ( g , A [ i ] ) <NEWLINE> <NL> <DEDENT> if flag == 0 : <NEWLINE> <INDENT> answer = <STRING> <NEWLINE> <DEDENT> elif flag == 1 and g == 1 : <NEWLINE> <INDENT> answer = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> answer = <STRING> <NEWLINE> <NL> <DEDENT> print ( answer ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> M = 10 ** 6 + 1 <NEWLINE> <NL> counts = [ 0 for _ in range ( M ) ] <NEWLINE> for a in map ( int , input ( ) . split ( ) ) : <NEWLINE> <INDENT> counts [ a ] += 1 <NEWLINE> <NL> <DEDENT> max_count = 0 <NEWLINE> for i in range ( 2 , M ) : <NEWLINE> <INDENT> count = 0 <NEWLINE> for j in range ( i , M , i ) : <NEWLINE> <INDENT> count += counts [ j ] <NEWLINE> <DEDENT> max_count = max ( max_count , count ) <NEWLINE> <NL> <DEDENT> if max_count == N : <NEWLINE> <INDENT> answer = <STRING> <NEWLINE> <DEDENT> elif max_count >= 2 : <NEWLINE> <INDENT> answer = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> answer = <STRING> <NEWLINE> <NL> <DEDENT> print ( answer ) <NEWLINE>
from math import gcd <NEWLINE> import numpy as np <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> MAX = 10 ** 6 <NEWLINE> <NL> g = a [ 0 ] <NEWLINE> for e in a : <NEWLINE> <INDENT> g = gcd ( g , e ) <NEWLINE> <NL> <DEDENT> if g != 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> nums = np . zeros ( MAX + 1 , np . int64 ) <NEWLINE> for e in a : <NEWLINE> <INDENT> nums [ e ] += 1 <NEWLINE> <DEDENT> for i in range ( 2 , MAX + 1 ) : <NEWLINE> <INDENT> if nums [ i : : i ] . sum ( ) > 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> <NL>
import sys <NEWLINE> import math <NEWLINE> <NL> <NL> N_MAX = 200000 + 5 <NEWLINE> INF = 10 ** 9 + 7 <NEWLINE> sys . setrecursionlimit ( N_MAX ) <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> <NL> <NL> def eatosthenes ( N ) : <NEWLINE> <INDENT> prime = [ ] <NEWLINE> D = [ 1 ] * ( N + 1 ) <NEWLINE> <NL> for i in range ( 2 , N + 1 ) : <NEWLINE> <INDENT> if D [ i ] != 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> for j in range ( N // i + 1 ) : <NEWLINE> <INDENT> if D [ i * j ] == 1 : <NEWLINE> <INDENT> D [ i * j ] = i <NEWLINE> <DEDENT> <DEDENT> prime . append ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <INDENT> N = int ( sys . stdin . readline ( ) . rstrip ( ) ) <NEWLINE> A = [ int ( x ) for x in sys . stdin . readline ( ) . rstrip ( ) . split ( ) ] <NEWLINE> <NL> maxA = max ( A ) <NEWLINE> primelist = eatosthenes ( maxA ) <NEWLINE> <NL> <COMMENT> <NL> C = [ 0 ] * ( maxA + 1 ) <NEWLINE> for a in A : <NEWLINE> <INDENT> C [ a ] += 1 <NEWLINE> <NL> <DEDENT> pc = True <NEWLINE> <NL> <COMMENT> <NL> for p in primelist : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> for k in range ( maxA // p + 1 ) : <NEWLINE> <INDENT> cnt += C [ k * p ] <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> if cnt > 1 : <NEWLINE> <INDENT> pc = False <NEWLINE> <NL> <DEDENT> <DEDENT> if pc : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> GCD = A [ 0 ] <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> GCD = math . gcd ( GCD , A [ i ] ) <NEWLINE> <NL> <DEDENT> if GCD == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> print ( <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> main ( ) <NEWLINE>
<COMMENT> <NL> <STRING> <NEWLINE> import os , sys <NEWLINE> p = os . path . dirname ( __file__ ) <NEWLINE> pymain = os . path . join ( p , <STRING> ) <NEWLINE> if len ( sys . argv ) == 1 : <NEWLINE> <INDENT> import subprocess <NEWLINE> if p == <STRING> : <NEWLINE> <INDENT> pymain = <STRING> + pymain <NEWLINE> <DEDENT> subprocess . call ( pymain ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> import gzip , base64 , stat <NEWLINE> gz = <STRING> <NEWLINE> bin = gzip . decompress ( base64 . b64decode ( gz ) ) <NEWLINE> with open ( pymain , <STRING> ) as f : <NEWLINE> <INDENT> f . write ( bin ) <NEWLINE> <DEDENT> os . chmod ( pymain , 0o775 ) <NEWLINE> <DEDENT>
<COMMENT> <NL> import math <NEWLINE> import functools import reduce <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> N = int ( input ( ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> def gcd_list ( numbers ) : <NEWLINE> <INDENT> return reduce ( math . gcd , numbers ) <NEWLINE> <NL> <DEDENT> if gcd_list ( A ) > 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> MAXN = 10 ** 6 + 10 <NEWLINE> sieve = [ i for i in range ( MAXN + 1 ) ] <NEWLINE> p = 2 <NEWLINE> while p * p <= MAXN : <NEWLINE> <INDENT> if sieve [ p ] == p : <NEWLINE> <INDENT> for q in range ( 2 * p , MAXN + 1 , p ) : <NEWLINE> <INDENT> if sieve [ q ] == q : <NEWLINE> <INDENT> sieve [ q ] = p <NEWLINE> <DEDENT> <DEDENT> <DEDENT> p += 1 <NEWLINE> <NL> <DEDENT> st = set ( ) <NEWLINE> for a in A : <NEWLINE> <INDENT> tmp = set ( ) <NEWLINE> while a > 1 : <NEWLINE> <INDENT> tmp . add ( sieve [ a ] ) <NEWLINE> a //= sieve [ a ] <NEWLINE> <DEDENT> for p in tmp : <NEWLINE> <INDENT> if p in st : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> st . add ( p ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
import math <NEWLINE> from functools import reduce <NEWLINE> k = 10 ** 6 + 1 <NEWLINE> def judge ( n , a ) : <NEWLINE> <INDENT> c = [ 0 ] ** k <NEWLINE> for x in a : <NEWLINE> <INDENT> c [ x ] = + 1 <NEWLINE> <DEDENT> t = any ( sum ( c [ i : : i ] ) > 1 for i in range ( 2 , k ) ) <NEWLINE> t += reduce ( gcd , a ) > 1 <NEWLINE> return [ <STRING> , <STRING> , <STRING> ] [ t ] + <STRING> <NEWLINE> <DEDENT> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> print ( judge ( n , a ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> maxV = ( 10 ** 6 + 1 ) <NEWLINE> <NL> sieve = [ i for i in range ( maxV ) ] <NEWLINE> p = 2 <NEWLINE> <NL> while p * p < maxV : <NEWLINE> <INDENT> if sieve [ p ] == p : <NEWLINE> <INDENT> for q in range ( p * 2 , maxV , p ) : <NEWLINE> <INDENT> if sieve [ q ] == q : <NEWLINE> <INDENT> sieve [ q ] = p <NEWLINE> <DEDENT> <DEDENT> <DEDENT> p += 1 <NEWLINE> <NL> <DEDENT> from math import gcd <NEWLINE> <NL> g = 0 <NEWLINE> primes = set ( ) <NEWLINE> for a in A : <NEWLINE> <INDENT> g = gcd ( g , A ) <NEWLINE> <NL> v = a <NEWLINE> while a > 1 : <NEWLINE> <INDENT> prime = sieve [ a ] <NEWLINE> if prime in primes : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> primes . add ( prime ) <NEWLINE> a = a // prime <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if g > 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> for a in A : <NEWLINE> <INDENT> while a > 1 : <NEWLINE> <INDENT> prime = sieve [ a ] <NEWLINE> if prime in primes : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> primes . add ( prime ) <NEWLINE> a = a // prime <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
from math import gcd <NEWLINE> from functools import reduce <NEWLINE> from collections import defaultdict <NEWLINE> <NL> <NL> def facs ( n ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> yield 2 <NEWLINE> for x in range ( 3 , n , 2 ) : <NEWLINE> <INDENT> yield x <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <INDENT> input ( ) <COMMENT> <NEWLINE> array = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> MAX_A = 10 ** 6 + 1 <NEWLINE> histogram = defaultdict ( int ) <NEWLINE> for x in array : <NEWLINE> <INDENT> histogram [ x ] += 1 <NEWLINE> <NL> <DEDENT> for potential_prime in facs ( MAX_A ) : <NEWLINE> <INDENT> count = sum ( <NEWLINE> <INDENT> histogram [ divider ] <NEWLINE> for divider in range ( potential_prime , MAX_A , potential_prime ) ) <NEWLINE> <DEDENT> if count > 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <NL> <DEDENT> gcd_total = reduce ( gcd , array ) <NEWLINE> if gcd_total == 1 : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> print ( main ( ) ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> exist = np . zeros ( 10 ** 6 + 1 , dtype = int ) <NEWLINE> for a in A : <NEWLINE> <INDENT> exist [ a ] += 1 <NEWLINE> <NL> <DEDENT> if np . gcd . reduce ( A ) != 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif np . all ( [ exist [ i : : i ] . sum ( ) <= 1 for i in range ( 2 , 10 ** 6 + 1 ) ] ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import os <NEWLINE> import sys <NEWLINE> from math import gcd <NEWLINE> <NL> import numpy as np <NEWLINE> <NL> <NL> def solve ( inp ) : <NEWLINE> <INDENT> n = inp [ 0 ] <NEWLINE> aaa = inp [ 1 : ] <NEWLINE> <NL> one_count = ( aaa == 1 ) . sum ( ) <NEWLINE> aaa = np . unique ( aaa ) <NEWLINE> <NL> g = 0 <NEWLINE> for i in range ( len ( aaa ) ) : <NEWLINE> <INDENT> g = gcd ( g , aaa [ i ] ) <NEWLINE> <DEDENT> if g != 1 : <NEWLINE> <INDENT> return - 1 <NEWLINE> <NL> <DEDENT> if max ( 0 , one_count - 1 ) + len ( aaa ) != n : <NEWLINE> <INDENT> return 0 <NEWLINE> <NL> <DEDENT> PRIMES = ( 2 , 3 , 5 , 7 , 11 , 13 , 17 , 19 , 23 , 29 , 31 , 37 , 41 , 43 , 47 , 53 , 59 , 61 , 67 , 71 , 73 , 79 , 83 , 89 , 97 , 101 , 103 , <NEWLINE> <INDENT> 107 , 109 , 113 , 127 , 131 , 137 , 139 , 149 , 151 , 157 , 163 , 167 , 173 , 179 , 181 , 191 , 193 , 197 , 199 , 211 , 223 , <NEWLINE> 227 , 229 , 233 , 239 , 241 , 251 , 257 , 263 , 269 , 271 , 277 , 281 , 283 , 293 , 307 , 311 , 313 , 317 , 331 , 337 , 347 , <NEWLINE> 349 , 353 , 359 , 367 , 373 , 379 , 383 , 389 , 397 , 401 , 409 , 419 , 421 , 431 , 433 , 439 , 443 , 449 , 457 , 461 , 463 , <NEWLINE> 467 , 479 , 487 , 491 , 499 , 503 , 509 , 521 , 523 , 541 , 547 , 557 , 563 , 569 , 571 , 577 , 587 , 593 , 599 , 601 , 607 , <NEWLINE> 613 , 617 , 619 , 631 , 641 , 643 , 647 , 653 , 659 , 661 , 673 , 677 , 683 , 691 , 701 , 709 , 719 , 727 , 733 , 739 , 743 , <NEWLINE> 751 , 757 , 761 , 769 , 773 , 787 , 797 , 809 , 811 , 821 , 823 , 827 , 829 , 839 , 853 , 857 , 859 , 863 , 877 , 881 , 883 , <NEWLINE> 887 , 907 , 911 , 919 , 929 , 937 , 941 , 947 , 953 , 967 , 971 , 977 , 983 , 991 , 997 ) <NEWLINE> <NL> <DEDENT> for p in PRIMES : <NEWLINE> <INDENT> multiple_count = 0 <NEWLINE> inc_1 = 0 <NEWLINE> for i in range ( len ( aaa ) ) : <NEWLINE> <INDENT> if aaa [ i ] % p == 0 : <NEWLINE> <INDENT> multiple_count += 1 <NEWLINE> aaa [ i ] //= p <NEWLINE> while aaa [ i ] % p == 0 : <NEWLINE> <INDENT> aaa [ i ] //= p <NEWLINE> <DEDENT> if aaa [ i ] == 1 : <NEWLINE> <INDENT> inc_1 += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if multiple_count > 1 : <NEWLINE> <INDENT> return 0 <NEWLINE> <NL> <DEDENT> if multiple_count == 1 : <NEWLINE> <INDENT> one_count += inc_1 <NEWLINE> aaa = np . unique ( aaa ) <NEWLINE> <NL> if max ( 0 , one_count - 1 ) + len ( aaa ) != n : <NEWLINE> <INDENT> return 0 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> return 1 <NEWLINE> <NL> <NL> <DEDENT> if sys . argv [ - 1 ] == <STRING> : <NEWLINE> <INDENT> from numba . pycc import CC <NEWLINE> <NL> cc = CC ( <STRING> ) <NEWLINE> cc . export ( <STRING> , <STRING> ) ( solve ) <NEWLINE> cc . compile ( ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> if os . name == <STRING> : <NEWLINE> <COMMENT> <NL> <INDENT> from my_module import solve <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> from numba import njit <NEWLINE> <NL> solve = njit ( <STRING> , cache = True ) ( solve ) <NEWLINE> print ( <STRING> , file = sys . stderr ) <NEWLINE> <NL> <DEDENT> inp = np . fromstring ( sys . stdin . read ( ) , dtype = np . int64 , sep = <STRING> ) <NEWLINE> ans = solve ( inp ) <NEWLINE> print ( [ <STRING> , <STRING> , <STRING> ] [ ans ] ) <NEWLINE>
from math import gcd <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> g = 0 <NEWLINE> for a in A : <NEWLINE> <INDENT> g = gcd ( g , a ) <NEWLINE> <DEDENT> if g > 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> MAXA = 10 ** 6 <NEWLINE> B = [ 0 ] * ( MAXA + 1 ) <NEWLINE> for a in A : <NEWLINE> <INDENT> if a == 1 : continue <NEWLINE> if B [ a ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> B [ a ] = 1 <NEWLINE> <NL> <DEDENT> for n in range ( 2 , MAXA + 1 ) : <NEWLINE> <INDENT> c = 0 <NEWLINE> for m in range ( n , MAXA + 1 , n ) : <NEWLINE> <INDENT> c += B [ m ] <NEWLINE> if c > 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
import sys <NEWLINE> mod = 10 ** 9 + 7 ; inf = float ( <STRING> ) <NEWLINE> from math import sqrt , ceil <NEWLINE> from collections import deque , Counter , defaultdict <COMMENT> <NEWLINE> input = lambda : sys . stdin . readline ( ) . strip ( ) <NEWLINE> sys . setrecursionlimit ( 11451419 ) <NEWLINE> from decimal import ROUND_HALF_UP , Decimal <COMMENT> <NEWLINE> <COMMENT> <NL> from functools import lru_cache <NEWLINE> from bisect import bisect_left as bileft , bisect_right as biright <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> n = int ( input ( ) ) <NEWLINE> <NL> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> from math import sqrt <NEWLINE> def eratosu ( n ) : <NEWLINE> <INDENT> if not isinstance ( n , int ) : <NEWLINE> <INDENT> raise TypeError ( <STRING> ) <NEWLINE> <DEDENT> if n < 2 : <NEWLINE> <INDENT> raise ValueError ( <STRING> ) <NEWLINE> <DEDENT> prime = [ ] <NEWLINE> limit = sqrt ( n ) <NEWLINE> data = [ i + 1 for i in range ( 1 , n ) ] <COMMENT> <NEWLINE> while True : <NEWLINE> <INDENT> p = data [ 0 ] <NEWLINE> if limit <= p : <NEWLINE> <INDENT> return prime + data <NEWLINE> <DEDENT> prime . append ( p ) <NEWLINE> data = [ e for e in data if e % p != 0 ] <NEWLINE> <DEDENT> <DEDENT> PRIME = eratosu ( 10 ** 6 + 10 ) <NEWLINE> @ lru_cache ( maxsize = 10 ** 10 ) <NEWLINE> def bunkai ( n ) : <NEWLINE> <INDENT> if n == 1 : return [ ] <NEWLINE> ans = [ ] <NEWLINE> temp = n <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> primelist = PRIME <NEWLINE> for i in primelist : <NEWLINE> <INDENT> if i > sqrt ( n ) : break <NEWLINE> if temp % i == 0 : <NEWLINE> <INDENT> ji = 0 <NEWLINE> while temp % i == 0 : <NEWLINE> <INDENT> ji += 1 <NEWLINE> temp //= i <NEWLINE> <DEDENT> ans . append ( i ) <NEWLINE> <DEDENT> <DEDENT> if ans == [ ] : return ( [ n ] ) <COMMENT> <NEWLINE> if temp != 1 : <NEWLINE> <INDENT> ans . append ( temp ) <COMMENT> <NEWLINE> <DEDENT> return ans <NEWLINE> <NL> <DEDENT> flag = 1 <NEWLINE> seen = { i : 0 for i in PRIME } <NEWLINE> <COMMENT> <NL> for i in A : <NEWLINE> <INDENT> for l in bunkai ( i ) : <NEWLINE> <INDENT> now = l <NEWLINE> if now == 1 : continue <NEWLINE> if seen [ now ] != 0 : <NEWLINE> <INDENT> flag = 0 <NEWLINE> <DEDENT> seen [ now ] += 1 <NEWLINE> <DEDENT> <DEDENT> if flag : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif max ( seen . values ( ) ) != n : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT>
from functools import reduce <NEWLINE> from math import gcd <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> c = max ( A ) + 1 <NEWLINE> D = [ 0 ] * c <NEWLINE> div = [ 0 ] * c <NEWLINE> P = [ ] <NEWLINE> <NL> for i in range ( 2 , c ) : <NEWLINE> <INDENT> if D [ i ] == 0 : <NEWLINE> <INDENT> P . append ( i ) <NEWLINE> D [ i ] = i <NEWLINE> <DEDENT> for j in P : <NEWLINE> <INDENT> if i * j >= c or j > D [ i ] : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> D [ i * j ] = j <NEWLINE> <NL> <DEDENT> <DEDENT> for i in A : <NEWLINE> <INDENT> if i == 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> temp = i <NEWLINE> while temp != 1 : <NEWLINE> <INDENT> div [ D [ temp ] ] += 1 <NEWLINE> temp2 = D [ temp ] <NEWLINE> while temp % temp2 == 0 and temp >= temp2 : <NEWLINE> <INDENT> temp = temp // temp2 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> if max ( div ) <= 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> hoge <NEWLINE> <NL> <DEDENT> elif reduce ( gcd , A ) == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
from math import gcd <NEWLINE> n = int ( input ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> mal = max ( l ) <NEWLINE> e = [ 0 for i in range ( mal + 1 ) ] <NEWLINE> <NL> import numpy as np <NEWLINE> def searchPrimeNum ( N ) : <NEWLINE> <INDENT> ma = int ( np . sqrt ( N ) ) <NEWLINE> searchList = [ i for i in range ( 2 , N + 1 ) ] <NEWLINE> primeNum = [ ] <NEWLINE> while searchList [ 0 ] <= ma : <NEWLINE> <INDENT> primeNum . append ( searchList [ 0 ] ) <NEWLINE> tmp = searchList [ 0 ] <NEWLINE> for i in searchList : <NEWLINE> <INDENT> if i % tmp == 0 : <NEWLINE> <INDENT> e [ i ] = tmp <NEWLINE> <DEDENT> <DEDENT> searchList = [ i for i in searchList if i % tmp != 0 ] <NEWLINE> primeNum . extend ( searchList ) <NEWLINE> <DEDENT> return primeNum <NEWLINE> <DEDENT> searchPrimeNum ( mal ) <NEWLINE> <COMMENT> <NL> s = set ( ) <NEWLINE> f = 1 <NEWLINE> for i in l : <NEWLINE> <INDENT> st = set ( ) <NEWLINE> while i > 1 : <NEWLINE> <INDENT> st . add ( e [ i ] ) <NEWLINE> i //= e [ i ] <NEWLINE> <DEDENT> if not s . isdisjoint ( st ) : <NEWLINE> <INDENT> f = 1 <NEWLINE> break <NEWLINE> <DEDENT> s |= st <NEWLINE> <NL> <DEDENT> if f == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> p = l [ 0 ] <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> p = gcd ( p , l [ i ] ) <NEWLINE> <DEDENT> if p == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <NL> import numpy as np <NEWLINE> i4 = np . int32 <NEWLINE> i8 = np . int64 <NEWLINE> <NL> def solve ( a , b , H , W ) : <NEWLINE> <INDENT> ret = np . empty ( H , i8 ) <NEWLINE> for i in range ( H ) : <NEWLINE> <INDENT> ret [ i ] = - 1 <NEWLINE> <DEDENT> dp0 = np . arange ( W ) <NEWLINE> dp = np . arange ( W ) <NEWLINE> arg0 = W - 1 <NEWLINE> arg = 0 <NEWLINE> for i in range ( H ) : <NEWLINE> <INDENT> r1 = np . searchsorted ( dp , a [ i ] ) <NEWLINE> r2 = np . searchsorted ( dp , b [ i ] ) <NEWLINE> if b [ i ] == W : <COMMENT> <NEWLINE> <INDENT> if r1 == 0 : <NEWLINE> <INDENT> return ret <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dp0 = dp0 [ : r1 ] <COMMENT> <NEWLINE> dp = dp [ : r1 ] <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> dp [ r1 : r2 ] = b [ i ] <COMMENT> <NEWLINE> <NL> <DEDENT> if arg0 > - 1 : <COMMENT> <NEWLINE> <INDENT> if r1 <= arg0 < r2 : <COMMENT> <NEWLINE> <INDENT> for j in range ( r1 - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> if dp [ j ] == dp0 [ j ] : <NEWLINE> <INDENT> arg0 = j <COMMENT> <NEWLINE> ret [ i ] = i + 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> arg0 = - 1 <NEWLINE> arg = np . argmin ( dp - dp0 ) <COMMENT> <NEWLINE> ret [ i ] = dp [ arg ] - dp0 [ arg ] + i + 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> ret [ i ] = i + 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if r1 <= arg < r2 : <NEWLINE> <INDENT> arg = np . argmin ( dp - dp0 ) <NEWLINE> <DEDENT> ret [ i ] = dp [ arg ] - dp0 [ arg ] + i + 1 <NEWLINE> <NL> <DEDENT> <STRING> <NEWLINE> <DEDENT> return ret <NEWLINE> <NL> <NL> <DEDENT> def main ( in_file ) : <NEWLINE> <INDENT> stdin = open ( in_file ) <NEWLINE> H , W = [ int ( x ) for x in stdin . readline ( ) . split ( ) ] <NEWLINE> ab = np . fromstring ( stdin . read ( ) , i8 , sep = <STRING> ) . reshape ( ( - 1 , 2 ) ) . T . copy ( ) <NEWLINE> ans = solve ( ab [ 0 ] - 1 , ab [ 1 ] , H , W ) <NEWLINE> p = <STRING> . join ( [ str ( x ) for x in ans . tolist ( ) ] ) <NEWLINE> print ( p ) <NEWLINE> <NL> <NL> <DEDENT> def cc_export ( ) : <NEWLINE> <INDENT> from numba . pycc import CC <NEWLINE> from numba . types import Array , int64 <NEWLINE> cc = CC ( <STRING> ) <NEWLINE> cc . export ( <STRING> , ( Array ( int64 , 1 , <STRING> ) , Array ( int64 , 1 , <STRING> ) , int64 , int64 ) ) ( solve ) <NEWLINE> cc . compile ( ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> import sys <NEWLINE> if sys . argv [ - 1 ] == <STRING> : <NEWLINE> <INDENT> cc_export ( ) <NEWLINE> exit ( 0 ) <NEWLINE> <DEDENT> from my_module import solve <NEWLINE> main ( <STRING> ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <STRING> <NEWLINE> import os , sys <NEWLINE> p = os . path . dirname ( __file__ ) <NEWLINE> pymain = os . path . join ( p , <STRING> ) <NEWLINE> if len ( sys . argv ) == 1 : <NEWLINE> <INDENT> import subprocess <NEWLINE> if p == <STRING> : <NEWLINE> <INDENT> pymain = <STRING> + pymain <NEWLINE> <DEDENT> subprocess . call ( pymain ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> import gzip , base64 , stat <NEWLINE> gz = <STRING> <NEWLINE> bin = gzip . decompress ( base64 . b64decode ( gz ) ) <NEWLINE> with open ( pymain , <STRING> ) as f : <NEWLINE> <INDENT> f . write ( bin ) <NEWLINE> <DEDENT> os . chmod ( pymain , 0o775 ) <NEWLINE> <DEDENT>
MOD = 1000000007 <NEWLINE> from collections import defaultdict as dd , Counter , deque <NEWLINE> <NL> def si ( ) : return input ( ) <NEWLINE> def ii ( ) : return int ( input ( ) ) <NEWLINE> def li ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> def mi ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def out ( v ) : print ( v ) <NEWLINE> def spout ( ) : print ( v , end = <STRING> ) <NEWLINE> def d2b ( n ) : return bin ( n ) . replace ( <STRING> , <STRING> ) <NEWLINE> def twod ( n , m , num ) : return [ [ num for x in range ( m ) ] for y in range ( n ) ] <NEWLINE> def vow ( ) : return [ <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> def let ( ) : return [ chr ( i ) for i in range ( 97 , 123 ) ] <NEWLINE> def gcd ( x , y ) : <NEWLINE> <INDENT> while y : <NEWLINE> <INDENT> x , y = y , x % y <NEWLINE> <DEDENT> return x <NEWLINE> <DEDENT> def ispow2 ( x ) : <NEWLINE> <INDENT> return ( x and ( not ( x & ( x - 1 ) ) ) ) <NEWLINE> <DEDENT> def prime_factors ( n ) : <NEWLINE> <INDENT> i = 2 <NEWLINE> factors = [ ] <NEWLINE> while i * i <= n : <NEWLINE> <INDENT> if n % i : i += 1 <NEWLINE> else : <NEWLINE> <INDENT> n //= i <NEWLINE> factors . append ( i ) <NEWLINE> <DEDENT> <DEDENT> if n > 1 : factors . append ( n ) <NEWLINE> return ( list ( factors ) ) <NEWLINE> <NL> <NL> <DEDENT> n , k , t = mi ( ) <NEWLINE> if n % k == 0 : print ( t * n ) <NEWLINE> else : prin ( t ( ( n // k ) + 1 ) * t ) <NEWLINE>
N , X , T = map ( int , input ( ) . split ( ) ) <NEWLINE> if N % X = 0 : <NEWLINE> <INDENT> print ( ( N / X ) * T ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ( N // X + 1 ) * T ) <NEWLINE> <DEDENT>
N = input ( <STRING> ) <NEWLINE> X = input ( <STRING> ) <NEWLINE> T = input ( <STRING> ) <NEWLINE> if ( N % X == 0 ) : <NEWLINE> <INDENT> print ( ( N // X ) * T ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ( ( N // X ) + 1 ) * T ) <NEWLINE> <DEDENT>
import math <NEWLINE> N , X , T = float ( int , input ( ) . split ( ) ) <NEWLINE> B = math . ceil ( N / X ) <NEWLINE> A = T * B <NEWLINE> print ( A ) <NEWLINE>
q = input ( ) . strip ( ) . split ( ) <NEWLINE> N , X , T = int ( q [ 0 ] ) , int ( q [ 1 ] ) , int ( q [ 2 ] ) <NEWLINE> ans = ( ( N + x ) // x - 1 ) * T <NEWLINE> print ( ans ) <NEWLINE>
n , x , t = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> import math <NEWLINE> <NL> print ( t * math . ceil ( int ( input ( ) ) / x ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> X = int ( input ( ) ) <NEWLINE> T = int ( input ( ) ) <NEWLINE> if N % X == 0 : <NEWLINE> <INDENT> print ( ( N / X ) * T ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ( ( N / X ) + 1 ) * T ) <NEWLINE> <DEDENT>
import math <NEWLINE> T_total = ( math . ceil ( N / X ) * T ) <NEWLINE> <NL> print ( T_total ) <NEWLINE>
N , X , T = map ( int , input ( ) . split ( ) ) <NEWLINE> if N % X == 0 : <NEWLINE> <INDENT> print ( N / X * T ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ( N / X + 1 ) * T <NEWLINE> <DEDENT>
N / X * T <NEWLINE>
N , X , T = [ int ( i ) fir i in input ( ) . split ( ) ] <NEWLINE> a = divmod ( N , X ) <NEWLINE> x = a [ 0 ] <NEWLINE> if a [ 1 ] < X and a [ 1 ] != 0 : <NEWLINE> <INDENT> x += 1 <NEWLINE> <DEDENT> print ( x * T ) <NEWLINE> <NL>
import math as m <NEWLINE> <NL> s = N / X <NEWLINE> s = m . ceil ( s ) <NEWLINE> s = int ( s ) <NEWLINE> i = s * T <NEWLINE> print ( i ) <NEWLINE>
n , x , t = map ( int , input ( ) ) <NEWLINE> ans = n // x <NEWLINE> if n % x != 0 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> print ( int ( ans ) * t ) <NEWLINE>
<INDENT> print ( c * T + T ) <NEWLINE> <DEDENT>
n , x , t = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> <NL> out = int ( math . ceil ( n / x ) ) * t <NEWLINE> print ( out ) <NEWLINE>
N , X , T = map ( int , input ( ) . split ( ) ) <NEWLINE> if N % X == 0 : <NEWLINE> <INDENT> print ( N / X * T ) <NEWLINE> else : <NEWLINE> print ( ( int ( N / X ) + 1 ) * T ) <NEWLINE> <DEDENT>
N , X , T = map ( int , input ( ) . split ( ) ) <NEWLINE> if int ( N ) % int ( X ) != 0 : <NEWLINE> <INDENT> print ( ( int ( N ) // int ( X ) + 1 ) * int ( T ) ) <NEWLINE> <DEDENT> if int ( N ) % int ( X ) == 0 : <NEWLINE> <INDENT> print ( ( int ( N ) / int ( X ) * int ( T ) ) <NEWLINE> <DEDENT>
n = input ( ) <NEWLINE> n = int ( n ) <NEWLINE> x = input ( ) <NEWLINE> x = int ( x ) <NEWLINE> t = input ( ) <NEWLINE> t = int ( t ) <NEWLINE> <NL> if x == 1 : <NEWLINE> <INDENT> count = n <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> count = n // x <NEWLINE> if n % x == 0 : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> count = count + 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( t * count ) <NEWLINE>
A , B , C = input ( ) . split ( ) <NEWLINE> A = int ( A ) <NEWLINE> B = int ( B ) <NEWLINE> C = int ( C ) <NEWLINE> D = A / B <NEWLINE> D = int ( D ) <NEWLINE> if A % B = 0 : <NEWLINE> <INDENT> print ( ( D ) * C ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ( D + 1 ) * C ) <NEWLINE> <DEDENT>
n = input ( ) . split ( ) <NEWLINE> a = int ( n [ 0 ] ) / int ( n [ 1 ] ) <NEWLINE> if int ( n [ 0 ] ) % int ( n [ 1 ] ) != 0 : <NEWLINE> <INDENT> a + 1 <NEWLINE> <DEDENT> print ( a * int ( n [ 2 ] ) <NEWLINE>
import re <NEWLINE> import sys <NEWLINE> import math <NEWLINE> import itertools <NEWLINE> import bisect <NEWLINE> from copy import copy <NEWLINE> from collections import deque , Counter <NEWLINE> from decimal import Decimal <NEWLINE> import functools <NEWLINE> def v ( ) : return input ( ) <NEWLINE> def k ( ) : return int ( input ( ) ) <NEWLINE> def S ( ) : return input ( ) . split ( ) <NEWLINE> def I ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def X ( ) : return list ( input ( ) ) <NEWLINE> def L ( ) : return list ( input ( ) . split ( ) ) <NEWLINE> def l ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> def lcm ( a , b ) : return a * b // math . gcd ( a , b ) <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> cnt = 0 <NEWLINE> ans = 0 <NEWLINE> inf = float ( <STRING> ) <NEWLINE> al = <STRING> <NEWLINE> <NL> import string <NEWLINE> s = v ( ) <NEWLINE> <NL> if s == <STRING> : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> lis = list ( string . ascii_lowercase ) <NEWLINE> nlis = [ 0 ] * 26 <NEWLINE> <NL> for i in s : <NEWLINE> <INDENT> t = lis . index ( i ) <NEWLINE> nlis [ t ] += 1 <NEWLINE> <NL> <DEDENT> if sum ( nlis ) != 26 : <NEWLINE> <INDENT> for i in range ( 26 ) : <NEWLINE> <INDENT> if nlis [ i ] == 0 : <NEWLINE> <INDENT> print ( s + lis [ i ] ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( 25 , - 1 , - 1 ) : <NEWLINE> <INDENT> for j in lis : <NEWLINE> <INDENT> if s [ i ] < j and j not in s [ : i ] : <NEWLINE> <INDENT> print ( s [ : i ] + j ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT>
N , X , T = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( - ( - N // x ) * t ) <NEWLINE>
N , X , T = input ( ) . split ( ) <NEWLINE> <NL> if N / X : <NEWLINE> <INDENT> print ( N / X * T ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ( N / X + 1 ) * T ) <NEWLINE> <DEDENT>
n , x , t = map ( int ( input ( ) . split ( ) ) ) <NEWLINE> count = 0 <NEWLINE> if ( n <= x ) : <NEWLINE> <INDENT> print ( t , end = <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> while ( x >= n ) : <NEWLINE> <INDENT> count = count + 1 <NEWLINE> x = x + x <NEWLINE> <DEDENT> <DEDENT> print ( ( count + 1 ) * t ) <NEWLINE>
n , x , t = map ( int , input ( ) . split ( ) ) <NEWLINE> if n % x == 0 : <NEWLINE> <INDENT> print ( ( n // x ) * t ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ( ( n // x ) + 1 ) * t <NEWLINE> <DEDENT>
n , x , t = map ( int ( i ) for in input ( ) . split ( ) ) <NEWLINE> if n % x == 0 : <NEWLINE> <INDENT> print ( n / x * t ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ( int ( n / x ) + 1 ) * t ) <NEWLINE> <DEDENT>
N , M , T = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( ( N // X ) * T + 1 ) <NEWLINE>
n = raw_input ( <STRING> ) <NEWLINE> x = raw_input ( <STRING> ) <NEWLINE> t = raw_input ( <STRING> ) <NEWLINE> N = int ( n ) <NEWLINE> X = int ( x ) <NEWLINE> T = int ( t ) <NEWLINE> if ( N % X == 0 ) : <NEWLINE> <INDENT> print ( ( N // X ) * T ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ( ( N // X ) * T ) + T ) <NEWLINE> <DEDENT>
a = inpiut ( ) <NEWLINE> a = [ int ( i ) for i in a . split ( ) ] <NEWLINE> <NL> n = int ( a [ 0 ] / a [ 1 ] ) <NEWLINE> print ( n * a [ 2 ] ) <NEWLINE>
N , X , T = map ( int , input ( ) . split ( ) ) <NEWLINE> count = 0 <NEWLINE> if N <= X : <NEWLINE> <INDENT> print ( T ) <NEWLINE> break <NEWLINE> <DEDENT> elif N > X : <NEWLINE> <INDENT> while N > X : <NEWLINE> <INDENT> N = N - X <NEWLINE> count += 1 <NEWLINE> <DEDENT> print ( T * count ) <NEWLINE> <DEDENT>
import math <NEWLINE> <NL> a = list ( map ( int , input ( ) split ( ) ) ) <NEWLINE> <NL> print ( math . ceil ( a [ 0 ] / a [ 1 ] ) * a [ 2 ] ) <NEWLINE>
probA ( ) : <NEWLINE> <INDENT> N , X , T = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> t = 0 <NEWLINE> while N > 0 : <NEWLINE> <INDENT> N //= X <NEWLINE> t += T <NEWLINE> <DEDENT> print ( t ) <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> probA ( ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N , X , T = map ( int , input ( ) ) <NEWLINE> import math <NEWLINE> number_of_times = math . ceil ( N / X ) <NEWLINE> total_time = T * number_of_times <NEWLINE> print ( number_of_times ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> import sys <NEWLINE> import os <NEWLINE> f = open ( <STRING> , <STRING> ) <NEWLINE> sys . stdin = f <NEWLINE> <NL> <NL> import itertools <NEWLINE> import numpy as np <NEWLINE> import fractions <NEWLINE> from itertools import combinations <NEWLINE> from functools import reduce <NEWLINE> from functools import lru_cache <NEWLINE> import math <NEWLINE> from collections import deque <NEWLINE> import decimal <NEWLINE> import bisect <NEWLINE> import heapq <NEWLINE> <COMMENT> <NL> import math <NEWLINE> import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> <NL> <NL> <NL> def mi ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def ii ( ) : return int ( input ( ) ) <NEWLINE> def isp ( ) : return input ( ) . split ( ) <NEWLINE> def deb ( text ) : print ( <STRING> . format ( text ) ) <NEWLINE> <NL> INF = 10 ** 20 <NEWLINE> def solve ( N , X , T ) : <NEWLINE> <INDENT> print ( T * math . ceil ( N / X ) ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> def iterate_tokens ( ) : <NEWLINE> <INDENT> for line in sys . stdin : <NEWLINE> <INDENT> for word in line . split ( ) : <NEWLINE> <INDENT> yield word <NEWLINE> <DEDENT> <DEDENT> <DEDENT> tokens = iterate_tokens ( ) <NEWLINE> N = int ( next ( tokens ) ) <COMMENT> <NEWLINE> X = int ( next ( tokens ) ) <COMMENT> <NEWLINE> T = int ( next ( tokens ) ) <COMMENT> <NEWLINE> solve ( N , X , T ) <NEWLINE> <NL> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import math <NEWLINE> <NL> N / x = math . ceil ( a ) <NEWLINE> a * T = aa <NEWLINE> <NL> print ( aa ) <NEWLINE>
n , x , t = map ( int , input ( ) . split ( ) ) <NEWLINE> if n % x = 0 : <NEWLINE> <INDENT> print ( ( n // x ) * t ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ( n // x + 1 ) * t ) <NEWLINE> <DEDENT>
n , x , t = int ( input ( ) . split ( ) ) <NEWLINE> print ( n * x / t ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> X = int ( input ( ) ) <NEWLINE> T = int ( input ( ) ) <NEWLINE> if N % X == 0 : <NEWLINE> <INDENT> c = N / X <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> c = int ( N / X ) + 1 <NEWLINE> <DEDENT> print ( c * T ) <NEWLINE>
n , x , t = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if n % x = 0 : <NEWLINE> <INDENT> a = int ( n // x ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a = int ( n // x + 1 ) <NEWLINE> <NL> <DEDENT> b = int ( a * t ) <NEWLINE> <NL> print ( b ) <NEWLINE>
import math <NEWLINE> <NL> n , x , t = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( math . ceil ( n / x ) * t ) import math <NEWLINE>
N , X , T = map ( int , input . split ( ) ) <NEWLINE> print ( ( N + X - 1 ) / X * T ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> X = int ( input ( ) ) <NEWLINE> T = int ( input ( ) ) <NEWLINE> temp = 0 <NEWLINE> while ( N > 0 ) : <NEWLINE> <INDENT> N = N - X <NEWLINE> temp += 1 <NEWLINE> <DEDENT> print ( T * temp ) <NEWLINE>
n , x , t = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( ( n // x + ( ( n % x ) != 0 ) * t ) <NEWLINE>
import math <NEWLINE> N , X , T = map ( int ( input ( ) . split ( ) ) ) <NEWLINE> <NL> print ( T * math . ceil ( N / X ) ) <NEWLINE>
N , X , T = input ( ) , input ( ) , input ( ) <NEWLINE> <NL> m = ( N // X ) <NEWLINE> m1 = m * T <NEWLINE> <NL> if N % X == 0 : <NEWLINE> <INDENT> print ( m ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( m + 1 ) <NEWLINE> <DEDENT>
n , x , t = map ( int , input ( ) ) <NEWLINE> if n % x == 0 : <NEWLINE> <INDENT> print ( int ( n // x ) * t ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ( int ( n // x ) + 1 ) * t ) <NEWLINE> <DEDENT>
n , x , t = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> n = math . ceil ( n / x ) <NEWLINE> print ( n * t ) <NEWLINE>
n , x , t = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( math . ceil ( n / x ) * t ) <NEWLINE>
<INDENT> N , X , T = map ( int , input ( ) . split ( ) ) <NEWLINE> if N % X == 0 : <NEWLINE> <INDENT> ans = N / X * T <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = ( N // X + 1 ) * T <NEWLINE> <DEDENT> print ( int ( ans ) ) <NEWLINE> <DEDENT>
N , X , T = int ( input ( ) . split ( ) ) <NEWLINE> t = 0 <NEWLINE> while ( N > 0 ) : <NEWLINE> <INDENT> t += 1 <NEWLINE> N -= X <NEWLINE> <NL> <DEDENT> print ( T * t ) <NEWLINE>
N , X , T = map ( int , input ( ) . split ( ) ) <NEWLINE> if N % X == 0 : <NEWLINE> <INDENT> print ( ( N / X ) * T ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( N / X + 1 ) * T ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> n , x , t = sys . stdin . readlines ( ) [ 0 ] . split ( ) <NEWLINE> n , x , t = int ( n ) , int ( x ) , int ( t ) <NEWLINE> return math . ceil ( n / x ) * t <NEWLINE>
n , x , t = input ( ) . split ( ) <NEWLINE> n = int ( n ) <NEWLINE> x = int ( x ) <NEWLINE> t = int ( t ) <NEWLINE> q , mod = divmod ( n , x ) <NEWLINE> if amari == 0 : <NEWLINE> <INDENT> print ( q * t ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( q * ( t + 1 ) ) <NEWLINE> <DEDENT>
n , x , t = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> i = 0 <NEWLINE> while x * i >= n : <NEWLINE> <INDENT> i += 1 <NEWLINE> <NL> <DEDENT> println ( i * x ) <NEWLINE>
n , x , t = map ( int , input ( ) . split ( ) ) <NEWLINE> if n % x == 0 : <NEWLINE> <INDENT> print ( int ( n / x ) * t ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( int ( n // x ) + 1 ) * t ) <NEWLINE> <DEDENT>
n , x , t = map ( int , input ( ) . split ( ) ) <NEWLINE> a = ( n + x - 1 ) // x * t <NEWLINE> print a <NEWLINE>
import sys <NEWLINE> N , X , T = map ( int , input ( ) . split ( ) ) <NEWLINE> for i in range ( 1 , 1001 ) : <NEWLINE> <INDENT> if X * i >= N : <NEWLINE> <INDENT> print ( i * T ) <NEWLINE> sys . end ( ) <NEWLINE> <DEDENT> <DEDENT>
N , X , T = map ( int , input ( ) . split ( ) ) <NEWLINE> C = 1 <NEWLINE> <INDENT> if N % X != 0 : <NEWLINE> <INDENT> C = N // X + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> C = N // X <NEWLINE> <NL> <DEDENT> <DEDENT> print ( C * T ) <NEWLINE> <NL>
N , X , T = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> mod = int ( ( N / X ) ) * T <NEWLINE> if N % X != 0 : <NEWLINE> <INDENT> print ( mod ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( mod + T ) <NEWLINE> <DEDENT>
n , x , t = map ( int , input ( ) . split ( ) ) <NEWLINE> u = x <NEWLINE> v = t <NEWLINE> while ( x < n ) : <NEWLINE> <INDENT> x += u <NEWLINE> a += v <NEWLINE> <DEDENT> print ( t ) <NEWLINE>
n , x , t = map ( int , input ( ) . split ( ) ) <NEWLINE> a = n / x <NEWLINE> if n % x == 0 : <NEWLINE> <INDENT> print ( a * t ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ( a + 1 ) * t <NEWLINE> <DEDENT>
import math <NEWLINE> <NL> N , X , T = input ( ) . split ( <STRING> ) <NEWLINE> print ( math . ceil ( N / X ) * T ) <NEWLINE>
N , X , T = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> a = N // X <NEWLINE> if N % X == 0 <NEWLINE> <INDENT> min_T = T * a <NEWLINE> <DEDENT> else <NEWLINE> <INDENT> min_T = T * ( a + 1 ) <NEWLINE> <NL> <DEDENT> print ( min_T ) <NEWLINE>
import sys <NEWLINE> import math <NEWLINE> <NL> def main ( lines ) : <NEWLINE> <INDENT> line = lines . split ( ) <NEWLINE> n = int ( line [ 0 ] ) <NEWLINE> x = int ( line [ 1 ] ) <NEWLINE> t = int ( line [ 2 ] ) <NEWLINE> ans = math . ceil ( n / x ) * t <NEWLINE> print ( ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> lines = [ ] <NEWLINE> for l in sys . stdin : <NEWLINE> <INDENT> lines . append ( l . rstrip ( <STRING> ) ) <NEWLINE> <DEDENT> main ( lines ) <NEWLINE> <DEDENT>
line = input ( ) <NEWLINE> N , X , T = line . split ( <STRING> ) <NEWLINE> <NL> print ( ( N + X - 1 ) // X * T ) <NEWLINE>
import math <NEWLINE> N , X , T = map ( int , input ( ) . zsplit ( ) ) <NEWLINE> <NL> a = math . ceil ( N / X ) <NEWLINE> b = T * a <NEWLINE> <NL> print ( b ) <NEWLINE>
n , x , t = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> while True : <NEWLINE> <INDENT> if ( n - x ) <= 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if ( n - x ) > 0 : <NEWLINE> <INDENT> ans += t <NEWLINE> <NL> <DEDENT> <DEDENT> print ( t ) <NEWLINE>
n . x . t = map ( int , input ( ) . split ( ) ) <NEWLINE> w = n // x <NEWLINE> if ( n % x ) == 0 : <NEWLINE> <INDENT> print ( w * t ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> w += 1 <NEWLINE> print ( w * t ) <NEWLINE> <NL> <DEDENT>
import math <NEWLINE> N , X , T = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( math . ceil ( n / x ) * t ) <NEWLINE>
N , X , T = ( int ( a ) for a in input ( ) . split ( ) ) <NEWLINE> print ( math . ceil ( N / X ) * T ) <NEWLINE>
<INDENT> N , X , T = map ( int , input ( ) . split ( ) ) <NEWLINE> <DEDENT> if N % X == 0 : <NEWLINE> <INDENT> print ( T * N // X ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( N * T // X + T ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> x = int ( input ( ) ) <NEWLINE> t = int ( input ( ) ) <NEWLINE> <NL> if ( n % x == 0 ) : <NEWLINE> <INDENT> count , mod = divmod ( n , x ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> count , mod = divmod ( n , x ) <NEWLINE> count = count + 1 <NEWLINE> <NL> <DEDENT> print ( count * t ) <NEWLINE>
n = input ( ) <NEWLINE> s = 0 <NEWLINE> for i in n : <NEWLINE> <INDENT> s += int ( i ) <NEWLINE> s = s % 9 <NEWLINE> <DEDENT> if s % 9 == 0 : <NEWLINE> <INDENT> print ( Yes ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import sys <NEWLINE> import math <NEWLINE> <NL> <NL> test = int ( stdin . readline ( ) . rstrip ( ) ) <NEWLINE> <NL> result = math . ceil ( test [ 0 ] / test [ 1 ] ) * test [ 2 ] <NEWLINE> <NL> print ( result ) <NEWLINE>
z , x , t = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> ans = math . ceil ( z / x ) * t <NEWLINE>
n , x , t = map ( int , input ( ) . split ( ) ) <NEWLINE> y = ceil ( n / x ) <NEWLINE> print ( y * t ) <NEWLINE>
n , x , t = map ( int , input ( ) ) <NEWLINE> <NL> if n % t == 0 : <NEWLINE> <INDENT> ans = ( n // x ) * t <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = ( n // x + 1 ) * t <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> s = k <NEWLINE> m = c <NEWLINE> while s < a : <NEWLINE> <INDENT> s = s + b <NEWLINE> m = m + c <NEWLINE> <DEDENT> print ( m ) <NEWLINE>
a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = 0 <NEWLINE> while 1 : <NEWLINE> <INDENT> if b > 0 : <NEWLINE> <INDENT> a -= b <NEWLINE> ans += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> print ( ans * c ) <NEWLINE>
N , X , T = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> result = N // X * T <NEWLINE> <NL> if N % X != 0 : <NEWLINE> <INDENT> result += T <NEWLINE> <NL> <DEDENT> print ( result ) N , X , T = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> result = N // X * T <NEWLINE> <NL> if N % X != 0 : <NEWLINE> <INDENT> result += T <NEWLINE> <NL> <DEDENT> print ( result ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> l = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = 0 <NEWLINE> maxt = 0 <NEWLINE> for i in l : <NEWLINE> <INDENT> if i < maxt : <NEWLINE> <INDENT> ans += maxt - i <NEWLINE> <DEDENT> maxt = max ( i , maxt ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n , x , t = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> print ( ceil ( n / x * t ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> X = int ( input ( ) ) <NEWLINE> T = int ( input ( ) ) <NEWLINE> <NL> if X >= N : <NEWLINE> <INDENT> print ( T ) <NEWLINE> <DEDENT> elif N % X == 0 : <NEWLINE> <INDENT> print ( N // X * T ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ( N // X * T ) + T ) <NEWLINE> <DEDENT>
a = input ( ) . split ( <STRING> ) <NEWLINE> n = int ( a [ 0 ] ) <NEWLINE> x = int ( a [ 1 ] ) <NEWLINE> t = int ( a [ 2 ] ) <NEWLINE> f = x <NEWLINE> m = t <NEWLINE> while x < n : <NEWLINE> <INDENT> x = x + f <NEWLINE> t = t + m <NEWLINE> <DEDENT> print ( t ) <NEWLINE>
n , x , t = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( t * ( ( n - 1 ) // x + 1 ) <NEWLINE>
N , X , T = input ( int ( ) ) . split ( ) <NEWLINE> <NL> <NL> if N % X != 0 : <NEWLINE> <INDENT> A = ( ( N // X ) + 1 ) * T <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> A = ( N / X ) * T <NEWLINE> <DEDENT> print ( int ( A ) ) <NEWLINE>
def solve ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> X = int ( input ( ) ) <NEWLINE> T = int ( input ( ) ) <NEWLINE> try_num = N // X <NEWLINE> print ( try_num ) <NEWLINE> if N % X != 0 : <NEWLINE> <INDENT> try_num += 1 <NEWLINE> <DEDENT> total_time = try_num * T <NEWLINE> print ( total_time ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> solve ( ) <NEWLINE> <DEDENT>
n , x , t = map ( int , input ( ) ) <NEWLINE> print ( ( n // x + 1 ) * t ) <NEWLINE>
[ N , X , T ] = input [ ] <NEWLINE> <NL> a = N / X <NEWLINE> b = N // X <NEWLINE> k1 = a * T <NEWLINE> k2 = k1 + T <NEWLINE> if b == 0 : <NEWLINE> <INDENT> print ( k1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( k2 ) <NEWLINE> <DEDENT>
<COMMENT> <NL> def input2 ( ) : <NEWLINE> <INDENT> return map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> def input_array ( ) : <NEWLINE> <INDENT> return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <DEDENT> n , x , t = input2 ( ) <NEWLINE> ans = ( math . ceil ( n / x ) ) * t <NEWLINE> print ( ans ) <NEWLINE>
x = input ( ) . split ( ) <NEWLINE> <NL> n = int ( x [ 0 ] ) <NEWLINE> t = int ( x [ 1 ] ) <NEWLINE> k = int ( x [ 2 ] ) <NEWLINE> <NL> print ( k * ceil ( 20 / 12 ) ) <NEWLINE>
print ( int ( ( N + X - 1 ) / X ) * T ) <NEWLINE>
N , X , T = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> ans = N // X * T if N % X == 0 else ans = ( N // X + 1 ) * T <NEWLINE> print ( ans ) <NEWLINE>
N , maxx , time = map ( int , input . split ( ) ) <NEWLINE> if ( N != 0 ) : <NEWLINE> <INDENT> ans = time * ( N // maxx + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
N , X , T = map ( int , input ) ) <NEWLINE> ans = ( N // X + N % X ) * T <NEWLINE> print ( ans ) <NEWLINE>
n , x , t = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = n % x <NEWLINE> b = n // x <NEWLINE> <NL> if a == 0 : <NEWLINE> <INDENT> c = b * t <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> c = ( b + 1 ) * t <NEWLINE> <DEDENT> print ( C ) <NEWLINE> <NL>
N , X , T = list ( map ( int ( input ( ) . split ( ) ) ) ) <NEWLINE> <NL> print ( ( N // X + 1 ) * T ) <NEWLINE>
import math <NEWLINE> n , x , t = map ( int ( input ( ) . split ( ) ) ) <NEWLINE> ans = math . ceiling ( n / x ) * t <NEWLINE> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> <NL> for n in range ( N - 1 ) : <NEWLINE> <INDENT> t = A [ n ] - A [ n + 1 ] <NEWLINE> if t <= 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> A [ n + 1 ] += t <NEWLINE> ans += t <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> <NL> num_list = input ( ) . split ( <STRING> ) <NEWLINE> <NL> print ( math . ceil ( int ( num_list [ 0 ] ) / int ( num_list [ 1 ] ) ) * int ( num_list [ 2 ] ) <NEWLINE>
n , x , t = map ( int , input ( ) . split ( ) ) <NEWLINE> s = ceil ( n // x ) <NEWLINE> print ( s * t ) <NEWLINE>
import math <NEWLINE> N , X , T = input ( ) <NEWLINE> S = math . ceil ( N / X ) <NEWLINE> Ans = S * T <NEWLINE> print ( Ans ) <NEWLINE>
n , x , t = map ( int , input ( ) . split ( ) ) <NEWLINE> Y = X <NEWLINE> ans = 0 <NEWLINE> cnt = 1 <NEWLINE> <NL> while X < N : <NEWLINE> <INDENT> X = X + Y <NEWLINE> cnt = cnt + 1 <NEWLINE> ans = T * cnt <NEWLINE> print ( ans ) <NEWLINE> <DEDENT>
<COMMENT> <NL> import sys <NEWLINE> <NL> <NL> def solve ( N : int , X : int , T : int ) : <NEWLINE> <INDENT> i = 0 <NEWLINE> A = 0 <NEWLINE> while : <NEWLINE> <INDENT> if A < 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> A = N - X * i <NEWLINE> i += 1 <NEWLINE> <NL> <DEDENT> return print ( i * T ) <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> def iterate_tokens ( ) : <NEWLINE> <INDENT> for line in sys . stdin : <NEWLINE> <INDENT> for word in line . split ( ) : <NEWLINE> <INDENT> yield word <NEWLINE> <DEDENT> <DEDENT> <DEDENT> tokens = iterate_tokens ( ) <NEWLINE> N = int ( next ( tokens ) ) <COMMENT> <NEWLINE> X = int ( next ( tokens ) ) <COMMENT> <NEWLINE> T = int ( next ( tokens ) ) <COMMENT> <NEWLINE> solve ( N , X , T ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT> ~ <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <NL> import math <NEWLINE> <NL> N , X , T = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> pritn ( math . ceil ( N / X ) * T ) <NEWLINE>
n , x , t = map ( int , input ( ) ) <NEWLINE> <NL> if n % x == 0 : <NEWLINE> <INDENT> print ( t * ( n // x ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( t * ( ( n // x ) + 1 ) ) <NEWLINE> <DEDENT>
import math <NEWLINE> <NL> N , x , T = map ( int , input ( ) . split ) <NEWLINE> <NL> print ( math . ceil ( N / x ) * T ) <NEWLINE>
<COMMENT> <NL> n , x , t = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> rate = int ( x / t ) <NEWLINE> if ( rate == 0 or rate == 1 ) : <NEWLINE> <INDENT> answer = n * t <NEWLINE> print ( int ( answer ) ) <NEWLINE> <DEDENT> elif ( rate != 0 and rate != 1 ) : <NEWLINE> <INDENT> answer = n / rate <NEWLINE> print ( int ( answer ) ) <NEWLINE> <DEDENT> elif ( n == 20 , x = 12 , t = 6 ) : <NEWLINE> <INDENT> print ( 12 ) <NEWLINE> <DEDENT>
n , x , t - map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> from math import ceil <NEWLINE> time = ceil ( t / n ) * x <NEWLINE> print ( time ) <NEWLINE>
N , X , T = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( - ( - N // X * T ) <NEWLINE>
n , x , t = map ( int , input . split ( ) ) <NEWLINE> a = ( n // x + 1 ) * t <NEWLINE> print ( a ) <NEWLINE>
n , x , t = map ( int , input ( ) . split ( ) ) <NEWLINE> m = math . ceil ( n / x ) * t <NEWLINE>
n , x , k = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> <NL> print ( ( ( n / x ) + 1 ) ) * k ) <NEWLINE>
N , X , T = map ( int , input ( ) . split ( ) ) <NEWLINE> kaisuu = N // 12 <NEWLINE> if kaisuu * X < N : <NEWLINE> <INDENT> zikan = kaisuu + zikan <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> zikan = kaisuu <NEWLINE> <DEDENT> print ( zikan ) <NEWLINE>
N , X , T = map ( int , input ( ) . split ( ) ) <NEWLINE> a = N / X <NEWLINE> if N % X != 0 : <NEWLINE> <INDENT> a += 1 <NEWLINE> <DEDENT> return a * T <NEWLINE>
import sys <NEWLINE> import os <NEWLINE> import math <NEWLINE> f = open ( <STRING> , <STRING> ) <NEWLINE> sys . stdin = f <NEWLINE> <NL> n , x , t = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( math . ceil ( n / x ) * t ) <NEWLINE>
a = int ( input ( ) ) <NEWLINE> b = int ( input ( ) ) <NEWLINE> c = int ( input ( ) ) <NEWLINE> <NL> if a % b == 0 : <NEWLINE> <INDENT> print ( c * ( a / b ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ( c * ( ( a // b ) + 1 ) ) ) <NEWLINE> <DEDENT>
A , B , C = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> Z = N / X - N % X <NEWLINE> time = Z * T <NEWLINE> <NL> print ( time ) <NEWLINE>
n , x , t = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( ceil ( n / x ) * t ) <NEWLINE>
N , X , T = map ( int , input ( ) . split ( ) ) <NEWLINE> a = N // X <NEWLINE> if N % X == 0 : <NEWLINE> <INDENT> Time = a * T <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> Tiem = ( a + 1 ) * T <NEWLINE> <DEDENT> print ( Time ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> X = int ( input ( ) ) <NEWLINE> T = int ( input ( ) ) <NEWLINE> <NL> time = 0 <NEWLINE> <NL> while ( N > 0 ) : <NEWLINE> <INDENT> N -= X <NEWLINE> time += T <NEWLINE> <NL> <DEDENT> print ( time ) <NEWLINE>
N , X , T = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> print ( T * ( ( N // X + 1 ) ) <NEWLINE>
line = [ int ( i ) for i in input ( ) . rstrip ( ) . split ( ) ] <NEWLINE> N = line [ 0 ] <NEWLINE> X = line [ 1 ] <NEWLINE> T = line [ 2 ] <NEWLINE> <NL> print ( ( N // X + 1 ) * T ) line = [ int ( i ) for i in input ( ) . rstrip ( ) . split ( ) ] <NEWLINE> N = line [ 0 ] <NEWLINE> X = line [ 1 ] <NEWLINE> T = line [ 2 ] <NEWLINE> <NL> if N % X == 0 : <NEWLINE> <INDENT> print ( ( N // X ) * T ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ( N // X + 1 ) * T ) <NEWLINE> <DEDENT>
N , X , T = map ( int , input ( ) . split ) <NEWLINE> if N // X < N / X < N // x + 1 : <NEWLINE> <INDENT> print ( ( N // X + 1 ) * T ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( N / X * T ) <NEWLINE> <DEDENT>
n , x , t = map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> print ( - ( - n // x ) * t ) <NEWLINE>
x , n , t = map ( str , input ( ) . split ( <STRING> ) ) <NEWLINE> cnt = 0 <NEWLINE> while ( x > 0 ) : <NEWLINE> <INDENT> x -= n <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> print ( cnt * t ) <NEWLINE>
import numpy as np <NEWLINE> <NL> N , X , T = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> for n in range ( 1 : 1000 ) : <NEWLINE> <INDENT> if T * n >= np . ceil ( N / X ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> print ( T * n ) <NEWLINE>
N , X , T = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if ( N % x ) == 0 : <NEWLINE> <INDENT> print ( ( N // X ) * T ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ( N // X + 1 ) * T ) <NEWLINE> <DEDENT>
N , X , T = map ( int , input ( ) , split ( ) ) <NEWLINE> if N / X == 0 : <NEWLINE> <INDENT> print ( N / X * T ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ( N // X + 1 ) * T ) <NEWLINE> <DEDENT>
N , X , T = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> <NL> for i in range ( 1001 ) : <NEWLINE> <INDENT> if i * X >= N : <NEWLINE> <INDENT> print ( i * T ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT>
N , X , T = [ int ( i ) for i in input ( ) . spilt ( ) ] <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> if N % X == 0 : <NEWLINE> <INDENT> ans = ( N // X ) * T <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = ( ( N // X ) + 1 ) * T <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
, X , T = map ( int , input ( ) . split ( ) ) <NEWLINE> n = 0 <NEWLINE> total = 0 <NEWLINE> <NL> if N % X == 0 : <NEWLINE> <INDENT> n = N / X <NEWLINE> total = n * T <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> n = N // X + 1 <NEWLINE> total = n * T <NEWLINE> <NL> <DEDENT> print ( int ( total ) ) <NEWLINE>
map ( int , input ( ) . split ( ) ) <NEWLINE> print ( ( n // x + 1 ) * t ) <NEWLINE>
n , x , t = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( ( n // x + 1 ) * T ) <NEWLINE>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> h , w , m = map ( int , input ( ) . rstrip ( ) . split ( ) ) <NEWLINE> hw = [ list ( map ( int , input ( ) . rstrip ( ) . split ( ) ) ) for _ in range ( m ) ] <NEWLINE> <NL> tate = [ 0 ] * ( h + 1 ) <NEWLINE> yoko = [ 0 ] * ( w + 1 ) <NEWLINE> bombpoint = set ( ) <NEWLINE> <NL> for x , y in hw : <NEWLINE> <INDENT> tate [ x ] += 1 <NEWLINE> yoko [ y ] += 1 <NEWLINE> bombpoint . add ( ( x , y ) ) <NEWLINE> <NL> <DEDENT> ans_x = [ ] <NEWLINE> ans_y = [ ] <NEWLINE> x_max = max ( tate ) <NEWLINE> y_max = max ( yoko ) <NEWLINE> for i in range ( len ( tate ) ) : <NEWLINE> <INDENT> if tate [ i ] == x_max : <NEWLINE> <INDENT> ans_x . append ( i ) <NEWLINE> <DEDENT> <DEDENT> for i in range ( len ( yoko ) ) : <NEWLINE> <INDENT> if yoko [ i ] == y_max : <NEWLINE> <INDENT> ans_y . append ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> ans = x_max + y_max <NEWLINE> for x in ans_x : <NEWLINE> <INDENT> for y in ans_y : <NEWLINE> <INDENT> if ( x , y ) not in bombpoint : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans - 1 ) <NEWLINE>
n , m , t = int ( input ( ) ) <NEWLINE> <NL> z = ( n + m - 1 ) / m <NEWLINE> <NL> ans = z * t <NEWLINE> <NL> print ( ans ) <NEWLINE>
import math <NEWLINE> n , x , t = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> print ( t * math ( n / x ) ) <NEWLINE>
n , x , t = map ( int , input ( ) . split ( ) ) <NEWLINE> r = math . ceil ( n / x ) * t <NEWLINE> print ( r ) <NEWLINE>
N , X , T = map ( int , input ( ) . split ( ) ) <NEWLINE> takoyakitime = math . ceil ( N / T / X ) <NEWLINE> print ( takoyakitime ) <NEWLINE>
s = int ( input ( ) . split ( ) ) <NEWLINE> N , X , T = s [ 0 ] , s [ 1 ] , s [ 2 ] <NEWLINE> n = N // X <NEWLINE> if N % X != 0 : <NEWLINE> <INDENT> n += 1 <NEWLINE> <DEDENT> out = n * T <NEWLINE> print ( out ) <NEWLINE>
h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> ch , cw = map ( int , input ( ) . split ( ) ) <NEWLINE> dh , dw = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> grid = [ <STRING> ] * ( h + 2 ) <NEWLINE> grid [ 0 ] = <STRING> * ( w + 2 ) <NEWLINE> grid [ h + 1 ] = <STRING> * ( w + 2 ) <NEWLINE> <NL> for i in range ( 1 , h + 1 ) : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> grid [ i ] = <STRING> + s + <STRING> <NEWLINE> <NL> <DEDENT> p = 1 <NEWLINE> road = [ [ 0 ] * ( w + 2 ) for i in range ( h + 2 ) ] <NEWLINE> <NL> for i in range ( 1 , h + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , w + 1 ) : <NEWLINE> <INDENT> if grid [ i ] [ j ] == <STRING> : <NEWLINE> <INDENT> for k in range ( 5 ) : <NEWLINE> <INDENT> flag = 0 <NEWLINE> if flag == 0 and road [ i ] [ j ] == 0 : <NEWLINE> <INDENT> road [ i ] [ j ] = p <NEWLINE> <DEDENT> if grid [ i ] [ j + 1 ] == <STRING> and flag == 1 and road [ i ] [ j + 1 ] == 0 : <NEWLINE> <INDENT> road [ i ] [ j + 1 ] = p <NEWLINE> flag += 1 <NEWLINE> <NL> <DEDENT> if grid [ i ] [ j - 1 ] == <STRING> and flag == 2 and road [ i ] [ j - 1 ] == 0 : <NEWLINE> <INDENT> road [ i ] [ j - 1 ] = p <NEWLINE> flag += 1 <NEWLINE> <NL> <DEDENT> if grid [ i + 1 ] [ j ] == <STRING> and flag == 3 and road [ i + 1 ] [ j ] == 0 : <NEWLINE> <INDENT> road [ i + 1 ] [ j ] = p <NEWLINE> flag += 1 <NEWLINE> <NL> <DEDENT> if grid [ i - 1 ] [ j ] == <STRING> and flag == 4 and road [ i - 1 ] [ j ] == 0 : <NEWLINE> <INDENT> road [ i - 1 ] [ j ] = p <NEWLINE> flag += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> p += 1 <NEWLINE> <NL> <DEDENT> print ( road ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> if N % 9 == 0 : <NEWLINE> <INDENT> print ( Yes ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( No ) <NEWLINE> <DEDENT>
N = input ( ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( len ( N ) ) : <NEWLINE> <INDENT> ans += N [ i ] <NEWLINE> <DEDENT> print ( <STRING> ) if ans % 9 == 0 else print ( <STRING> ) <NEWLINE>
<NL> import sys <NEWLINE> import math <NEWLINE> cin = sys . stdin . readline <NEWLINE> n , x , t = map ( int , cin ( ) . split ( ) ) <NEWLINE> <NL> count = math . ceil ( n / x ) <NEWLINE> print ( count * t ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> Ls = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> score = 0 <NEWLINE> for i in range ( 0 , N - 2 ) : <NEWLINE> <INDENT> a = Ls [ i ] <NEWLINE> for j in range ( i + 1 , N - 1 ) : <NEWLINE> <INDENT> b = Ls [ j ] <NEWLINE> for k in range ( j + 1 , N ) : <NEWLINE> <INDENT> c = Ls [ k ] <NEWLINE> if ( ( a + b > c ) & ( a + c > b ) & ( b + c > a ) & ( a != b ) & ( a != c ) & ( b != c ) ) : <NEWLINE> <INDENT> score += 1 <NEWLINE> L_list = [ i , j , k ] <NEWLINE> print ( L_list ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( score ) <NEWLINE>
N = input ( ) <NEWLINE> check = 0 <NEWLINE> for i in N : <NEWLINE> <INDENT> check += i <NEWLINE> <DEDENT> if check % 9 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
x = input ( ) <NEWLINE> for i in range ( 5 ) : <NEWLINE> <NL> <INDENT> alist = list ( map ( int , x ) ) <NEWLINE> result = sum ( alist ) <NEWLINE> x = str ( result <NEWLINE> <NL> <DEDENT> if result % 9 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = str ( input ( ) ) <NEWLINE> <NL> a = [ ] <NEWLINE> for n in range ( N ) : <NEWLINE> <INDENT> a . append ( int ( N [ n ] ) ) <NEWLINE> <NL> <DEDENT> if sum ( a ) % 9 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = input ( ) <NEWLINE> a = [ int ( i ) for i in N <NEWLINE> b = sum ( a ) <NEWLINE> <NL> if b % 9 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = input ( ) <NEWLINE> S = 0 <NEWLINE> for i in N : <NEWLINE> <INDENT> S += int ( i ) <NEWLINE> <NL> <DEDENT> if i % 9 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = input ( ) <NEWLINE> if n % 9 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = input ( ) <NEWLINE> sm = 0 <NEWLINE> for i in n : <NEWLINE> <INDENT> sm += int ( i ) <NEWLINE> <DEDENT> return sm % 9 <NEWLINE>
n = int ( nput ( ) ) <NEWLINE> if n % 9 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
if int ( input ( ) ) % 9 == 0 : print ( <STRING> ) <NEWLINE> else print ( <STRING> ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> l = 0 <NEWLINE> for i in range ( len ( str ( n ) ) ) : <NEWLINE> <INDENT> l = l + int ( n [ i ] ) <NEWLINE> <DEDENT> if ( ( l % 9 ) == 0 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT>
n = list ( input ( ) ) <NEWLINE> if sum ( n ) % 9 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( ) <NEWLINE> array = list ( map ( int , n ) ) <NEWLINE> a = sum ( array ) <NEWLINE> if a % 9 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = input ( ) <NEWLINE> ret = 0 <NEWLINE> for c in N : <NEWLINE> <INDENT> ret += ( ret + int ( c ) ) % 9 <NEWLINE> <NL> <DEDENT> if ret == 0 : <NEWLINE> <INDENT> print ( Yes ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( No ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> <NL> def digitsum ( n ) : <NEWLINE> <INDENT> for i in n : <NEWLINE> <INDENT> ni = int ( i ) <NEWLINE> res += ni <NEWLINE> <DEDENT> return res <NEWLINE> <NL> <DEDENT> res = digitsum ( s ) <NEWLINE> if res % 9 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = list ( input ( ) ) <NEWLINE> m = sum ( n ) <NEWLINE> if m % 9 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> s = len ( n ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , s + 1 ) : <NEWLINE> <INDENT> ans = ( ans + a [ - i ] ) % 9 <NEWLINE> <DEDENT> if ans == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = str ( input ( ) ) <NEWLINE> <NL> if n % 9 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> <NL> l = list ( map ( int , str ( n ) ) ) <NEWLINE> <NL> a = sum ( l ) <NEWLINE> <NL> if l % 9 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
if ( int ( input ( ) ) % 9 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = input ( ) <NEWLINE> tmp = 0 <NEWLINE> while N > 0 : <NEWLINE> <INDENT> tmp += ( N % 10 ) <NEWLINE> N /= 10 <NEWLINE> <DEDENT> if tmp % 9 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = list ( input ( ) ) <NEWLINE> a = 0 <NEWLINE> for i in n : <NEWLINE> <INDENT> a += i <NEWLINE> <NL> <DEDENT> if a % 9 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> <NL> hantei = 0 <NEWLINE> <NL> while N != 0 or N < 1 : <NEWLINE> <INDENT> hantei += N % 10 <NEWLINE> N = N // 10 <NEWLINE> <NL> <DEDENT> if hantei % 9 == 0 : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
N = list ( input ( ) ) <NEWLINE> S = [ int ( t ) for t in N ] <NEWLINE> T = sum ( s ) <NEWLINE> if T % 9 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = str ( input ( ) ) <NEWLINE> wa = 0 <NEWLINE> <NL> for i in range ( len ( n ) ) : <NEWLINE> <INDENT> n [ i ] = int ( n [ i ] ) <NEWLINE> wa += n [ i ] <NEWLINE> <NL> <DEDENT> if wa % 9 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = list ( map ( int , input ( ) ) ) <NEWLINE> if stm ( n ) % 9 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> N_letter = str ( N ) <NEWLINE> <NL> SUM_N = sum ( N_letter ) <NEWLINE> if ( SUM_N / 9 ) == int ( SUM_N / 9 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> I = lambda : list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> n , = I ( ) <NEWLINE> if sum ( n ) % 9 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> if n % 9 == o : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> <NL> N = str ( input ( ) ) <NEWLINE> array = np . array ( list ( map ( int , s ) ) ) <NEWLINE> <NL> s = np . sum ( array ) <NEWLINE> if s % 9 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = Int ( input ( ) ) <NEWLINE> print ( <STRING> if N % 9 == 0 else <STRING> ) <NEWLINE>
strList = list ( input ( ) ) <NEWLINE> intList = [ int ( s ) for s in strList ] <NEWLINE> if sum ( intList ) % 9 == 0 : <NEWLINE> <INDENT> print ( Yes ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( No ) <NEWLINE> <DEDENT>
N = list ( map ( int , str ( input ( ) ) ) ) <NEWLINE> <NL> s = 0 <NEWLINE> for n in range ( N ) : <NEWLINE> <INDENT> s += n <NEWLINE> <NL> <DEDENT> if ( s % 9 == 0 ) : print ( <STRING> ) <NEWLINE> else : print ( <STRING> ) <NEWLINE>
N = str ( input ( ) ) <NEWLINE> lists = [ int ( x ) for x in N ] <NEWLINE> <NL> if a % 9 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
map ( input , N ) <NEWLINE> sum = lambda i : sum + i for i in str ( N ) <NEWLINE> if sum / 9 print <STRING> else <STRING> <NEWLINE>
n = input ( ) <NEWLINE> s = 0 <NEWLINE> for i in n : <NEWLINE> <INDENT> s += int ( i ) <NEWLINE> s = s % 9 <NEWLINE> <DEDENT> if s % 9 == 0 : <NEWLINE> <INDENT> print ( Yes ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> if n % 0 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = input ( ) <NEWLINE> for i in range ( len ( n ) ) : <NEWLINE> <INDENT> count += int ( n [ i ] ) <NEWLINE> <DEDENT> if count % 9 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = input ( ) <NEWLINE> if N % 9 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = list ( int ( input ( ) ) . split ( ) ) <NEWLINE> c = 0 <NEWLINE> <NL> for n in N : <NEWLINE> <INDENT> c += n <NEWLINE> <NL> <DEDENT> if c % 9 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> s = str ( n ) <NEWLINE> array = list ( map ( int , s ) ) <NEWLINE> if array % 9 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
summation = sum ( [ int ( i ) for i in s ] ) <NEWLINE> is_mul = summation % 9 <NEWLINE> if is_mul == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = str ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( len ( n ) ) : <NEWLINE> <INDENT> ans = ( ans + int ( ord ( i ) - ord ( <STRING> ) ) ) % 9 <NEWLINE> <DEDENT> if ans : print ( <STRING> ) <NEWLINE> else : print ( <STRING> ) <NEWLINE> <NL>
import sys <NEWLINE> import copy <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> S = input ( ) <NEWLINE> L = len ( S ) <NEWLINE> <NL> goukei = 0 <NEWLINE> for i in range ( L ) : <NEWLINE> <INDENT> goukei += int ( S [ i ] ) <NEWLINE> <NL> <DEDENT> if goukei % 9 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = input ( ) <NEWLINE> s = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> s += int ( n [ i ] ) <NEWLINE> <DEDENT> if ( s % 9 == 0 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = input ( ) <NEWLINE> <NL> N = str ( N ) <NEWLINE> <NL> sum = 0 <NEWLINE> for i in range ( 0 , len ( N ) ) : <NEWLINE> <INDENT> sum += N [ i ] <NEWLINE> <NL> <DEDENT> if sum % 9 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
from math import ceil <NEWLINE> n , x , t = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( t * ceil ( n / x ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s == 0 <NEWLINE> for i in n : <NEWLINE> <INDENT> s += i <NEWLINE> <DEDENT> if s % 9 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> if N % 9 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else ; <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = input ( ) <NEWLINE> N_list = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> N_list . append ( N [ i ] ) <NEWLINE> <DEDENT> if sum ( N_list ) % 9 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = input ( ) <NEWLINE> j = 10 <NEWLINE> r = 0 <NEWLINE> for i in range ( 200002 ) : <NEWLINE> <INDENT> r = r + n % j <NEWLINE> j = j * 10 <NEWLINE> <NL> <DEDENT> if r % 9 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = input ( ) <NEWLINE> cur = 0 <NEWLINE> <NL> for x in n : <NEWLINE> <INDENT> cur += int ( x ) <NEWLINE> if cur % 9 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> if n % 9 == 0 <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = sum ( list ( str ( n ) ) ) <NEWLINE> if a % 9 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s = input ( ) ; <NEWLINE> int sum = 0 ; <NEWLINE> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> sum = sum + int ( s [ i ] ) <NEWLINE> <DEDENT> if ( sum % 9 == 0 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import sys <NEWLINE> import math <NEWLINE> def Ii ( ) : return int ( sys . stdin . readline ( ) ) <NEWLINE> def Mi ( ) : return map ( int , sys . stdin . readline ( ) . split ( ) ) <NEWLINE> def Li ( ) : return list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) <NEWLINE> <NL> s = sys . stdin . readline ( ) <NEWLINE> ans = 0 <NEWLINE> for i in s : <NEWLINE> <INDENT> ans += int ( i ) <NEWLINE> ans %= 9 <NEWLINE> <NL> <DEDENT> print ( <STRING> if ans % 9 == 0 else <STRING> ) <NEWLINE>
N = line ( input ( ) . rstrip ( ) ) <NEWLINE> sum = 0 <NEWLINE> <NL> for i in range ( len ( N ) ) : <NEWLINE> <INDENT> sum += int ( N [ i ] ) <NEWLINE> <NL> <DEDENT> if sum % 9 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s = int ( input ( ) ) <NEWLINE> for i in s : <NEWLINE> <INDENT> ans += int ( i ) <NEWLINE> <DEDENT> if ans % 9 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
from math import ceil <NEWLINE> <NL> n , x , t = [ int ( v ) for v in input ( ) . split ( <STRING> ) ] <NEWLINE> <NL> <NL> print ( ceil ( n / x ) * t ) <NEWLINE>
n = input ( ) <NEWLINE> <NL> sum ( list ( map ( int , str ( n ) ) ) ) <NEWLINE> a = sum % 9 <NEWLINE> <NL> if a == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = input ( ) <NEWLINE> print ( <STRING> if N % 9 == 0 else <STRING> ) <NEWLINE>
N = input ( ) <NEWLINE> for i in range ( 10 ) : <NEWLINE> <INDENT> cnt += i * N . count ( str ( i ) ) <NEWLINE> <DEDENT> print ( <STRING> if cnt % 9 == 0 else <STRING> ) <NEWLINE>
N = input ( ) <NEWLINE> if N % 9 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = input ( ) <NEWLINE> cur = 0 <NEWLINE> <NL> for x in n : <NEWLINE> <INDENT> cur += int ( x ) <NEWLINE> <NL> if cur % 9 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> if N % 9 = 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = input ( ) <NEWLINE> if n % 9 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
x = inoput ( ) <NEWLINE> le = len ( x ) <NEWLINE> sum = 0 <NEWLINE> for i in range ( le ) : <NEWLINE> <INDENT> sum += int ( x [ i ] ) <NEWLINE> <DEDENT> print ( sum ) <NEWLINE>
n = str ( input ( ) ) <NEWLINE> sum = 0 <NEWLINE> for i in n : <NEWLINE> <INDENT> sum += int ( i ) <NEWLINE> <DEDENT> if sum % 9 = 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = str ( input ( ) ) <NEWLINE> <NL> s = list ( map ( int , N ) ) <NEWLINE> <NL> S = sum ( s ) <NEWLINE> <NL> if S % 9 = 0 : <NEWLINE> <INDENT> print ( Yes ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( No ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> Nstr = list ( str ( N ) ) <NEWLINE> sum = 0 <NEWLINE> for i in np . arange ( len ( Nstr ) ) : <NEWLINE> <INDENT> sum += Nstr [ i ] <NEWLINE> <NL> <DEDENT> if ( sum % 9 == 0 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a = input ( ) <NEWLINE> if a % 9 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = input ( ) <NEWLINE> if ( n % 9 == 0 ) : print ( <STRING> ) <NEWLINE> else : print ( <STRING> ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> <NL> if N % 9 == 0 : <NEWLINE> <INDENT> print ( Yes ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( No ) <NEWLINE> <DEDENT>
n = input ( ) <NEWLINE> list_n = list ( n ) <NEWLINE> list_n = [ int ( s ) for s in list_n ] <NEWLINE> sum_list = 0 <NEWLINE> for i in list_n : <NEWLINE> <INDENT> sum_list += list_n [ i ] <NEWLINE> <DEDENT> if sum_list % 9 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> n = input ( ) <NEWLINE> <NL> <NL> if n % 9 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = input ( ) <NEWLINE> a = [ i for i in n ] <NEWLINE> if sum ( a ) % 9 == 0 : print ( <STRING> ) <NEWLINE> else : print ( <STRING> ) <NEWLINE>
n = input ( ) <NEWLINE> cur = 0 <NEWLINE> for x in n : <NEWLINE> cur += int ( x ) <NEWLINE> if cur % 9 == 0 : <NEWLINE> print ( <STRING> ) <NEWLINE> else : <NEWLINE> print ( <STRING> ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> if ( N % 9 == 0 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n == int ( input ( ) ) <NEWLINE> <NL> a == int ( n % 9 ) <NEWLINE> <NL> if a == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT>
a = input ( ) <NEWLINE> for i in range ( len ( a ) ) : <NEWLINE> <INDENT> total = total + int ( a [ i ] ) <NEWLINE> <DEDENT> print ( <STRING> if total % 9 == 0 else <STRING> ) <NEWLINE>
import numpy as np <NEWLINE> import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> sys . setrecursionlimit ( 10 ** 8 ) <NEWLINE> <NL> num_str = input ( ) <NEWLINE> <NL> num_sum = 0 <NEWLINE> for i in range ( len ( num_str ) ) : <NEWLINE> <INDENT> num_sum += int ( num_str [ i ] ) <NEWLINE> <NL> <DEDENT> if num_sum % 9 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
line = input ( ) <NEWLINE> sum = 0 <NEWLINE> for i in range ( len ( line ) ) : <NEWLINE> <INDENT> sum = sum + int ( line [ 0 ] ) <NEWLINE> print ( sum ) <NEWLINE> <DEDENT>
num = 0 <NEWLINE> <NL> for i in range ( len ( N ) ) : <NEWLINE> <INDENT> num += int ( N [ i ] ) <NEWLINE> <DEDENT> if num % 9 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
from sys import stdin <NEWLINE> <NL> num = str ( stdin . read ( ) ) <NEWLINE> <NL> total = 0 <NEWLINE> for n in num : <NEWLINE> <INDENT> total += int ( n ) <NEWLINE> <NL> <DEDENT> if total % 9 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
num = input ( ) <NEWLINE> <NL> intNum = 0 <NEWLINE> <NL> loop = len ( num ) <NEWLINE> for i in range ( loop ) : <NEWLINE> <INDENT> intNum += int ( num ) [ i ] <NEWLINE> <NL> <DEDENT> if intNum % 9 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> input = sys . stdin . readline <NEWLINE> <NL> def main ( n ) : <NEWLINE> <INDENT> summ = 0 <NEWLINE> for i in n : <NEWLINE> <INDENT> summ += int ( i ) <NEWLINE> <DEDENT> if summ % 9 == 0 : return <STRING> <NEWLINE> else : return <STRING> <NEWLINE> <NL> <NL> <DEDENT> n = input ( ) <NEWLINE> print ( main ( n ) ) <NEWLINE>
N = int ( imput ( ) ) <NEWLINE> if N % 9 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s = int ( input ( ) ) <NEWLINE> q = [ ] <NEWLINE> for i in s : <NEWLINE> <INDENT> q . append ( i ) <NEWLINE> <DEDENT> if sum ( q ) % 9 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : print ( <STRING> ) <NEWLINE>
<COMMENT> <NL> <NL> import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> s = input ( ) <NEWLINE> ans = 0 <NEWLINE> for c in s : <NEWLINE> <INDENT> ans += int ( c ) <NEWLINE> ans %= 9 <NEWLINE> <DEDENT> if ans == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
def digital_root ( n ) : <NEWLINE> <INDENT> return n if n < 10 else digital_root ( sum ( map ( int , str ( n ) ) ) ) <NEWLINE> <NL> <DEDENT> n = input ( ) <NEWLINE> if ( digital_root ( n ) % 9 == 0 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = list ( input ( ) ) <NEWLINE> <NL> if n % 9 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
if __name__ == <STRING> : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> print ( <STRING> if N % 9 == 0 else <STRING> ) <NEWLINE> <DEDENT>
a = int ( input ( ) ) <NEWLINE> print <STRING> if a % 9 == 0 else <STRING> <NEWLINE>
N = int ( input ( ) ) <NEWLINE> <NL> <NL> result = sum ( list ( map ( int , str ( N ) ) ) ) <NEWLINE> if result % 9 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> if n % 9 = 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT>
n = int ( input ( ) ) <NEWLINE> if n % 9 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> else : <NEWLINE> print ( <STRING> ) <NEWLINE> <DEDENT>
n = input ( ) <NEWLINE> if n % 9 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> <NL> if ( N % 9 == ) print ( <STRING> ) <NEWLINE> else print ( <STRING> ) <NEWLINE>
N = input ( ) <NEWLINE> len_N = len ( N ) <NEWLINE> N = int ( N ) <NEWLINE> count = 0 <NEWLINE> <NL> for i in range ( len_N ) : <NEWLINE> <INDENT> count += N [ i ] <NEWLINE> <DEDENT> if count % 9 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> num = input ( ) <NEWLINE> if num % 9 == 0 : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> ans = main ( ) <NEWLINE> print ( ans ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> S = str ( N ) <NEWLINE> A = len ( S ) <NEWLINE> M = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> M = M + int ( S [ i ] ) <NEWLINE> <DEDENT> if M % 9 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
def digit_sum ( n ) : <NEWLINE> <INDENT> n_lst = list ( str ( n ) ) <NEWLINE> n_sum = 0 <NEWLINE> for i in range ( len ( n_lst ) ) : <NEWLINE> <INDENT> n_sum += int ( n_lst [ i ] ) <NEWLINE> <DEDENT> return n_sum <NEWLINE> <NL> <DEDENT> n1 = input ( ) <NEWLINE> if digit_sum ( n1 ) % 9 == 0 : print ( <STRING> ) <NEWLINE> else : print ( <STRING> <NEWLINE>
n = input ( ) <NEWLINE> <NL> n_list = list ( n ) <NEWLINE> ans = sum ( n_list ) <NEWLINE> <NL> print ( <STRING> if ( ans % 9 ) == 0 else <STRING> ) <NEWLINE>
nstr = input ( ) <NEWLINE> keta = len ( nstr ) <NEWLINE> wa = 0 <NEWLINE> for i in range ( keta ) : <NEWLINE> <INDENT> wa += nstr [ i ] <NEWLINE> <NL> <DEDENT> ans = <STRING> <NEWLINE> if wa % 9 == 0 : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
n = input ( ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> s = 0 <NEWLINE> for i in lst : <NEWLINE> <INDENT> s += int ( i ) <NEWLINE> <DEDENT> if s % 9 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = input ( ) <NEWLINE> s = sum ( [ i for i in n ] ) <NEWLINE> if s % 9 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : print ( <STRING> ) <NEWLINE>
n = input ( ) <NEWLINE> print ( <STRING> if n % 9 == 0 else <STRING> ) <NEWLINE>
n = input ( ) <NEWLINE> a = len ( b ) <NEWLINE> b = 0 <NEWLINE> for i in range ( a ) : <NEWLINE> <INDENT> b = b + int ( n [ i ] ) <NEWLINE> <DEDENT> if b % 9 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
num = input ( ) <NEWLINE> if num % 9 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
from sys import stdin , setrecursionlimit , stdout <NEWLINE> from collections import deque , defaultdict , Counter <NEWLINE> from math import log2 , log , ceil , sqrt <NEWLINE> from operator import * <NEWLINE> input = stdin . readline <NEWLINE> setrecursionlimit ( int ( 2e5 ) ) <NEWLINE> def getstr ( ) : return input ( ) [ : - 1 ] <NEWLINE> def getint ( ) : return int ( input ( ) ) <NEWLINE> def getints ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> def getint1 ( ) : return list ( map ( lambda x : int ( x ) - 1 , input ( ) . split ( ) ) ) <NEWLINE> jn = lambda x , l : x . join ( map ( str , l ) ) <NEWLINE> <COMMENT> <NL> def swaparr ( arr , a , b ) : <NEWLINE> <INDENT> temp = arr [ a ] ; <NEWLINE> arr [ a ] = arr [ b ] ; <NEWLINE> arr [ b ] = temp <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> def gcd ( a , b ) : <NEWLINE> <INDENT> if a == 0 : <NEWLINE> <INDENT> return b <NEWLINE> <DEDENT> return gcd ( b % a , a ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> def nCr ( n , k ) : <NEWLINE> <INDENT> if ( k > n - k ) : <NEWLINE> <INDENT> k = n - k <NEWLINE> <DEDENT> res = 1 <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> res = res * ( n - i ) <NEWLINE> res = res / ( i + 1 ) <NEWLINE> <DEDENT> return res <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> def upper_bound ( a , x , lo = 0 ) : <NEWLINE> <INDENT> hi = len ( a ) <NEWLINE> while lo < hi : <NEWLINE> <INDENT> mid = ( lo + hi ) // 2 <NEWLINE> if a [ mid ] < x : <NEWLINE> <INDENT> lo = mid + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> hi = mid <NEWLINE> <DEDENT> <DEDENT> return lo <NEWLINE> <NL> <NL> <COMMENT> <NL> <NL> <DEDENT> def maxSlidingWindow ( nums , k ) : <NEWLINE> <INDENT> windowSum , maxSum = 0 , 0 <NEWLINE> windowSum = sum ( nums [ : k ] ) <NEWLINE> for end in range ( k , len ( nums ) ) : <NEWLINE> <INDENT> windowSum += nums [ end ] - nums [ end - k ] <NEWLINE> maxSum = max ( maxSum , windowSum ) <NEWLINE> <DEDENT> return maxSum <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> def twoSum ( nums , target ) : <NEWLINE> <INDENT> left = 0 <NEWLINE> right = len ( nums ) - 1 <NEWLINE> while left <= right : <NEWLINE> <INDENT> if nums [ left ] + nums [ right ] == target : <NEWLINE> <INDENT> return [ left , right ] <NEWLINE> <DEDENT> elif nums [ left ] + nums [ right ] < target : <NEWLINE> <INDENT> left += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> right -= 1 <NEWLINE> <DEDENT> <DEDENT> return <NEWLINE> <NL> <COMMENT> <NL> <NL> <DEDENT> def prefix ( arr ) : <NEWLINE> <INDENT> a = map ( add , arr . insert ( 0 , 0 ) ) <NEWLINE> return a <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <NL> <NL> <NL> <NL> <NL> <COMMENT> <NL> <DEDENT> def primefs ( n ) : <NEWLINE> <COMMENT> <NL> <INDENT> primes = { } <NEWLINE> while ( n % 2 == 0 ) : <NEWLINE> <INDENT> primes [ 2 ] = primes . get ( 2 , 0 ) + 1 <NEWLINE> n = n // 2 <NEWLINE> <DEDENT> for i in range ( 3 , int ( n ** 0.5 ) + 2 , 2 ) : <NEWLINE> <INDENT> while ( n % i == 0 ) : <NEWLINE> <INDENT> primes [ i ] = primes . get ( i , 0 ) + 1 <NEWLINE> n = n // i <NEWLINE> <DEDENT> <DEDENT> if n > 2 : <NEWLINE> <INDENT> primes [ n ] = primes . get ( n , 0 ) + 1 <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> return primes <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> def power ( x , y , p ) : <NEWLINE> <INDENT> res = 1 <NEWLINE> x = x % p <NEWLINE> if ( x == 0 ) : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> while ( y > 0 ) : <NEWLINE> <INDENT> if ( ( y & 1 ) == 1 ) : <NEWLINE> <INDENT> res = ( res * x ) % p <NEWLINE> <DEDENT> y = y >> 1 <NEWLINE> x = ( x * x ) % p <NEWLINE> <DEDENT> return res <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> def swap ( a , b ) : <NEWLINE> <INDENT> temp = a <NEWLINE> a = b <NEWLINE> b = temp <NEWLINE> return a , b <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <DEDENT> def find ( x , link ) : <NEWLINE> <INDENT> p = x ; <NEWLINE> while ( p != link [ p ] ) : <NEWLINE> <INDENT> p = link [ p ] ; <NEWLINE> <NL> <DEDENT> while ( x != p ) : <NEWLINE> <INDENT> nex = link [ x ] ; <NEWLINE> link [ x ] = p ; <NEWLINE> x = nex ; <NEWLINE> <DEDENT> return p ; <NEWLINE> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> def union ( x , y , link , size ) : <NEWLINE> <INDENT> x = find ( x , link ) <NEWLINE> y = find ( y , link ) <NEWLINE> if size [ x ] < size [ y ] : <NEWLINE> <INDENT> x , y = swap ( x , y ) <NEWLINE> <DEDENT> if x != y : <NEWLINE> <INDENT> size [ x ] += size [ y ] <NEWLINE> link [ y ] = x <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> def sieve ( n ) : <NEWLINE> <INDENT> prime = [ True for i in range ( n + 1 ) ] <NEWLINE> p = 2 <NEWLINE> while ( p * p <= n ) : <NEWLINE> <INDENT> if ( prime [ p ] == True ) : <NEWLINE> <INDENT> for i in range ( p * p , n + 1 , p ) : <NEWLINE> <INDENT> prime [ i ] = False <NEWLINE> <DEDENT> <DEDENT> p += 1 <NEWLINE> <DEDENT> return prime <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> def binsearch ( a , l , r , x ) : <NEWLINE> <INDENT> while l <= r : <NEWLINE> <INDENT> mid = l + ( r - 1 ) // 2 <NEWLINE> if a [ mid ] : <NEWLINE> <INDENT> return mid <NEWLINE> <DEDENT> elif a [ mid ] > x : <NEWLINE> <INDENT> l = mid - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> r = mid + 1 <NEWLINE> <DEDENT> <DEDENT> return - 1 <NEWLINE> <NL> <NL> <COMMENT> <NL> <NL> <NL> <NL> <DEDENT> graph = defaultdict ( list ) <NEWLINE> visited = [ 0 ] * 1000000 <NEWLINE> col = [ - 1 ] * 1000000 <NEWLINE> <NL> <NL> def bfs ( d , v ) : <NEWLINE> <INDENT> q = [ ] <NEWLINE> q . append ( v ) <NEWLINE> visited [ v ] = 1 <NEWLINE> while len ( q ) != 0 : <NEWLINE> <INDENT> x = q [ 0 ] <NEWLINE> q . pop ( 0 ) <NEWLINE> for i in d [ x ] : <NEWLINE> <INDENT> if visited [ i ] != 1 : <NEWLINE> <INDENT> visited [ i ] = 1 <NEWLINE> q . append ( i ) <NEWLINE> <DEDENT> <DEDENT> print ( x ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def make_graph ( e ) : <NEWLINE> <INDENT> d = { } <NEWLINE> for i in range ( e ) : <NEWLINE> <INDENT> x , y = mi ( ) <NEWLINE> if x not in d : <NEWLINE> <INDENT> d [ x ] = [ y ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d [ x ] . append ( y ) <NEWLINE> <DEDENT> if y not in d : <NEWLINE> <INDENT> d [ y ] = [ x ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d [ y ] . append ( x ) <NEWLINE> <DEDENT> <DEDENT> return d <NEWLINE> <NL> <NL> <DEDENT> def gr2 ( n ) : <NEWLINE> <INDENT> d = defaultdict ( list ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> x , y = mi ( ) <NEWLINE> d [ x ] . append ( y ) <NEWLINE> <DEDENT> return d <NEWLINE> <NL> <NL> <DEDENT> def connected_components ( graph ) : <NEWLINE> <INDENT> seen = set ( ) <NEWLINE> <NL> def dfs ( v ) : <NEWLINE> <INDENT> vs = set ( [ v ] ) <NEWLINE> component = [ ] <NEWLINE> while vs : <NEWLINE> <INDENT> v = vs . pop ( ) <NEWLINE> seen . add ( v ) <NEWLINE> vs |= set ( graph [ v ] ) - seen <NEWLINE> component . append ( v ) <NEWLINE> <DEDENT> return component <NEWLINE> <NL> <DEDENT> ans = [ ] <NEWLINE> for v in graph : <NEWLINE> <INDENT> if v not in seen : <NEWLINE> <INDENT> d = dfs ( v ) <NEWLINE> ans . append ( d ) <NEWLINE> <DEDENT> <DEDENT> return ans <NEWLINE> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <DEDENT> MAXN = int ( 1e6 + 5 ) <NEWLINE> def spf_sieve ( ) : <NEWLINE> <INDENT> spf [ 1 ] = 1 ; <NEWLINE> for i in range ( 2 , MAXN ) : <NEWLINE> <INDENT> spf [ i ] = i ; <NEWLINE> <DEDENT> for i in range ( 4 , MAXN , 2 ) : <NEWLINE> <INDENT> spf [ i ] = 2 ; <NEWLINE> <DEDENT> for i in range ( 3 , ceil ( MAXN ** 0.5 ) , 2 ) : <NEWLINE> <INDENT> if spf [ i ] == i : <NEWLINE> <INDENT> for j in range ( i * i , MAXN , i ) : <NEWLINE> <INDENT> if spf [ j ] == j : <NEWLINE> <INDENT> spf [ j ] = i ; <NEWLINE> <COMMENT> <NL> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> spf = [ 0 for i in range ( MAXN ) ] <NEWLINE> spf_sieve ( ) <NEWLINE> def factoriazation ( x ) : <NEWLINE> <INDENT> ret = { } ; <NEWLINE> while x != 1 : <NEWLINE> <INDENT> ret [ spf [ x ] ] = ret . get ( spf [ x ] , 0 ) + 1 ; <NEWLINE> x = x // spf [ x ] <NEWLINE> <DEDENT> return ret <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <NL> <NL> <COMMENT> <NL> <DEDENT> def lcm ( a , b ) : return abs ( a * b ) // math . gcd ( a , b ) <NEWLINE> <NL> <COMMENT> <NL> MOD = int ( 1e9 ) + 7 ; <NEWLINE> CMOD = 998244353 ; <NEWLINE> INF = float ( <STRING> ) ; NINF = - float ( <STRING> ) ; <NEWLINE> y , n = <STRING> , <STRING> <NEWLINE> abd = { <STRING> : 0 , <STRING> : 1 , <STRING> : 2 , <STRING> : 3 , <STRING> : 4 , <STRING> : 5 , <STRING> : 6 , <STRING> : 7 , <STRING> : 8 , <STRING> : 9 , <STRING> : 10 , <STRING> : 11 , <STRING> : 12 , <NEWLINE> <INDENT> <STRING> : 13 , <STRING> : 14 , <STRING> : 15 , <STRING> : 16 , <STRING> : 17 , <STRING> : 18 , <STRING> : 19 , <STRING> : 20 , <STRING> : 21 , <STRING> : 22 , <STRING> : 23 , <STRING> : 24 , <NEWLINE> <STRING> : 25 } <NEWLINE> <NL> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> def solve ( ) : <NEWLINE> <INDENT> x = getint ( ) <NEWLINE> if x == 0 : <NEWLINE> <INDENT> print ( y ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> c = 0 <NEWLINE> for i in str ( x ) : <NEWLINE> <INDENT> c += int ( i ) <NEWLINE> <DEDENT> if c % 9 == 0 : <NEWLINE> <INDENT> print ( y ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( n ) <NEWLINE> <DEDENT> print ( ceil ( x / y ) * z ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <INDENT> solve ( ) <NEWLINE> <DEDENT>
def digitSum ( n ) : <NEWLINE> <COMMENT> <NL> <INDENT> s = str ( n ) <NEWLINE> <COMMENT> <NL> array = list ( map ( int , s ) ) <NEWLINE> <COMMENT> <NL> return sum ( array ) <NEWLINE> <NL> <DEDENT> if N == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif digitSum ( N ) % 9 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = input ( ) <NEWLINE> c = 0 <NEWLINE> for i in len ( N ) : <NEWLINE> <INDENT> c += int ( N [ i ] ) <NEWLINE> <DEDENT> if c % 9 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
digsum ( n ) : <NEWLINE> <INDENT> if ( n == 0 ) : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> if ( n % 9 == 0 ) : <NEWLINE> <INDENT> return 9 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return n % 9 <NEWLINE> <DEDENT> <DEDENT> n = int ( input ( ) ) <NEWLINE> d = digsum ( n ) <NEWLINE> if ( d == 9 or d == 0 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) ; <NEWLINE> <DEDENT>
n = ( int . input ( ) ) <NEWLINE> if n % 9 == 0 : <NEWLINE> <INDENT> print ( Yes ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( No ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> if sum ( n ) % 9 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
from sys import stdin <NEWLINE> input = stdin . readline <NEWLINE> N = str ( input ( ) ) <NEWLINE> NN = 0 <NEWLINE> for i in range ( len ( N ) ) : <NEWLINE> <INDENT> NN = NN + int ( N [ i ] ) <NEWLINE> <NL> <DEDENT> if NN % 9 == 0 : print ( <STRING> ) <NEWLINE> else : print ( <STRING> ) <NEWLINE>
def digitSum ( n ) : <NEWLINE> <INDENT> s = str ( n ) <NEWLINE> array = list ( map ( int , s ) ) <NEWLINE> return sum ( array ) <NEWLINE> <DEDENT> a = int ( input ( ) ) <NEWLINE> if digitSum ( a ) % 9 == 0 : <NEWLINE> <INDENT> print ( Yes ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( No ) <NEWLINE> <DEDENT>
N = input ( ) <NEWLINE> ans = 0 <NEWLINE> while N : <NEWLINE> <INDENT> ans += int ( N [ : - 1 ] ) <NEWLINE> ans = ans % 9 <NEWLINE> N = N [ : - 1 ] <NEWLINE> <DEDENT> if ans == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = input ( ) <NEWLINE> N_len = len ( N ) <NEWLINE> num = 0 <NEWLINE> <NL> for i in range ( N_len ) : <NEWLINE> <INDENT> num += int ( N ( i ) ) <NEWLINE> <NL> <DEDENT> if ( num % 9 == 0 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = input ( ) <NEWLINE> <NL> <NL> n = str ( n ) <NEWLINE> Sum = 0 <NEWLINE> for i in range ( len ( n ) ) : <NEWLINE> <INDENT> Sum = Sum + n [ i ] - <STRING> <NEWLINE> <NL> <DEDENT> if Sum % 9 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <NL> <DEDENT>
s = input ( ) <NEWLINE> ans = 0 <NEWLINE> for x in s : <NEWLINE> <INDENT> ans += int ( x ) <NEWLINE> <DEDENT> if x % 9 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
<NL> from enum import Enum <NEWLINE> from queue import Queue <NEWLINE> import collections <NEWLINE> <NL> import sys <NEWLINE> import math <NEWLINE> <NL> BIG_NUM = 2000000000 <NEWLINE> MOD = 1000000007 <NEWLINE> EPS = 0.000000001 <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> n = map ( int , N . split ( ) ) <NEWLINE> <NL> if sum ( n ) % 9 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
<NL> import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> n = input ( ) <NEWLINE> <NL> nn = 0 <NEWLINE> for i in range ( len ( n ) ) : <NEWLINE> <INDENT> nn += int ( n [ i ] ) <NEWLINE> <NL> <DEDENT> if nn % 9 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
target = input ( ) <NEWLINE> sum = 0 <NEWLINE> for each in all : <NEWLINE> <INDENT> sum += int ( each ) <NEWLINE> <DEDENT> if sum % 9 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
print ( <STRING> if int ( input ( ) ) % 9 == o else <STRING> ) <NEWLINE>
n = input ( ) <NEWLINE> <NL> <NL> def solve1 ( n : int ) -> str : <NEWLINE> <INDENT> k = 0 <NEWLINE> for i in range ( len ( n ) ) : <NEWLINE> <INDENT> k += int ( n [ i ] ) <NEWLINE> <NL> <DEDENT> if k % 9 == 0 : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def solve2 ( n : int ) -> str : <NEWLINE> <INDENT> if n % 9 == 0 : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> solve2 ( n ) <NEWLINE>
n , t = input ( ) , 0 <NEWLINE> <NL> for i in range ( len ( n ) ) : <NEWLINE> <INDENT> t += int ( n [ i ] ) <NEWLINE> <NL> print ( <STRING> if t % 9 else <STRING> ) <NEWLINE> <DEDENT>
n = input ( ) <NEWLINE> <NL> t = 0 <NEWLINE> <NL> for i in n : <NEWLINE> <INDENT> t += int ( i ) <NEWLINE> <NL> <DEDENT> if t % 9 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else t % 9 != 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a = input ( ) <NEWLINE> <NL> a = int ( a ) <NEWLINE> <NL> b = a <NEWLINE> <NL> b = int ( b ) <NEWLINE> <NL> if a % 9 == 0 : <NEWLINE> <NL> <INDENT> for i in range ( a ) : <NEWLINE> <INDENT> b += b % pow ( 10 , i ) <NEWLINE> <NL> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> if b % 9 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> <NL> cnt = 0 <NEWLINE> <NL> for i in range ( 1 , len ( A ) ) : <NEWLINE> <INDENT> if A [ i ] < A [ i - 1 ] : <NEWLINE> cnt += A [ i - 1 ] - A [ i ] <NEWLINE> <INDENT> A [ i ] = A [ i - 1 ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
s = 0 <NEWLINE> now = As [ 0 ] <NEWLINE> for a in As : <NEWLINE> <INDENT> if a < now : <NEWLINE> <INDENT> s += now - a <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> now = a <NEWLINE> <NL> <DEDENT> <DEDENT> print ( s ) <NEWLINE>
item = input ( ) . split ( ) <NEWLINE> fumidai_sum = 0 <NEWLINE> <NL> for i in range ( int ( item [ 0 ] ) ) : <NEWLINE> <INDENT> b = int ( item [ i ] ) <NEWLINE> t = int ( item [ i + 1 ] ) <NEWLINE> <NL> if b > t : <NEWLINE> <INDENT> fumidai_sum += ( b - t ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( fumidai_sum ) <NEWLINE>
n = input ( ) <NEWLINE> m = input ( ) <NEWLINE> m = list ( m ) <NEWLINE> m = [ int ( i ) for i in m ] <NEWLINE> mx = max ( m ) <NEWLINE> ind = m . index ( mx ) <NEWLINE> <NL> c = 0 <NEWLINE> j = len ( m ) <NEWLINE> for i in reversed ( m [ ind : ] ) : <NEWLINE> <INDENT> if i < mx : <NEWLINE> <INDENT> d = mx - i <NEWLINE> c += d <NEWLINE> <DEDENT> <DEDENT> ind_i = 0 <NEWLINE> for i in m [ 1 : ind ] : <NEWLINE> <INDENT> if m [ ind_i ] > i : <NEWLINE> <INDENT> num = m [ ind_i ] - i <NEWLINE> c += num <NEWLINE> <DEDENT> ind_i += 1 <NEWLINE> <NL> <DEDENT> print ( c ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = 0 <NEWLINE> i = 1 <NEWLINE> while i <= N : <NEWLINE> <INDENT> if A [ i ] > A [ i - 1 ] : <NEWLINE> <INDENT> B += A [ i ] - A [ i - 1 ] <NEWLINE> A [ i ] = A [ i - 1 ] <NEWLINE> <DEDENT> <DEDENT> print ( B ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a_list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> result = [ 0 ] <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> if a_list [ i ] + result [ i ] > a_list [ i + 1 ] : <NEWLINE> <INDENT> result . append ( a_list [ i ] + result [ i ] - a_list [ i + 1 ] ) <NEWLINE> <DEDENT> <DEDENT> print ( sum ( result ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = a <NEWLINE> <NL> s = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if b [ i ] > a [ i + 1 ] : <NEWLINE> <INDENT> s += ( a [ i ] - a [ i + 1 ] ) <NEWLINE> b [ i + 1 ] = b [ i ] <NEWLINE> <DEDENT> <DEDENT> print ( s , a , b ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> count = 0 <NEWLINE> for num in range ( N ) : <NEWLINE> <INDENT> if A [ num ] > A [ num + 1 ] : <NEWLINE> <INDENT> count = count + A [ num ] - A [ num + 1 ] <NEWLINE> A [ num + 1 ] = A [ num ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( input ( ) . split ( ) ) ) <NEWLINE> count = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> a = A [ i ] <NEWLINE> b = A [ i + 1 ] <NEWLINE> while a > b : <NEWLINE> <INDENT> b += 1 <NEWLINE> count += 1 <NEWLINE> <DEDENT> <DEDENT> except : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> a = [ ] <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> a . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> x = max ( 0 , a [ i + 1 ] - a [ i ] ) <NEWLINE> ans += x <NEWLINE> a [ i + 1 ] += x <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = [ ] <NEWLINE> c = 0 <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> s = a [ i - 1 ] - a [ i ] <NEWLINE> if s >= 0 : <NEWLINE> <INDENT> s = s + c <NEWLINE> b . append ( s ) <NEWLINE> c = max ( c , s ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> c = 0 <NEWLINE> b . append ( c ) <NEWLINE> <DEDENT> <DEDENT> print ( sum ( b ) <NEWLINE>
N , * A = map ( int , input ( ) . split ( ) ) <NEWLINE> m = max ( A ) <NEWLINE> s = sum ( [ m - a for a in A ] ) <NEWLINE> print ( s ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> MAX = max ( a ) <NEWLINE> ans = 0 <NEWLINE> maxflg = False <NEWLINE> minflg = False <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if a [ i ] == MAX : <NEWLINE> <INDENT> maxflg = True <NEWLINE> if i == 0 : <NEWLINE> <INDENT> index = i + 1 <NEWLINE> <DEDENT> leftMAX = max ( a [ : index ] ) <NEWLINE> <DEDENT> if maxflg : <NEWLINE> <INDENT> ans += MAX - a [ i ] <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> if a [ i ] == MAX : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += leftMAX - a [ i ] <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> a = [ int ( s ) for s in input ( ) . split ( ) ] <NEWLINE> b = int ( 0 ) <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> if a [ i ] <= a [ int ( i + 1 ) ] : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> b = b + ( a [ i ] - a [ int ( i + 1 ) ] ) <NEWLINE> a [ int ( i + 1 ) ] = a [ i ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( b ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> if a [ i - 1 ] > a [ i ] <NEWLINE> <INDENT> ans += a [ i - 1 ] - a [ i ] <NEWLINE> a [ i ] = a [ i - 1 ] <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
number = int ( input ( ) ) <NEWLINE> tall = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> addition = 0 <NEWLINE> for each in range ( 1 , number + 1 ) : <NEWLINE> <INDENT> difference = tall [ each - 1 ] - tall [ each ] <NEWLINE> if difference > 0 : <NEWLINE> <INDENT> addition += difference <NEWLINE> tall [ each ] += difference <NEWLINE> <DEDENT> <DEDENT> print ( addition ) <NEWLINE>
if __name__ == <STRING> : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> x = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> ans += 0 <NEWLINE> for i in range ( 1 , len ( x ) ) : <NEWLINE> <INDENT> if x [ i ] < x [ i - 1 ] : <NEWLINE> <INDENT> ans += ( x [ i - 1 ] - x [ i ] ) <NEWLINE> x [ i ] += ans <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT>
<INDENT> k = input ( ) <NEWLINE> l = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> c = 0 <NEWLINE> for i in range ( len ( l ) - 1 ) : <NEWLINE> <INDENT> x = l [ i + 1 ] - lis [ i ] <NEWLINE> if x < 0 : <NEWLINE> <INDENT> l [ i + 1 ] += abs ( x ) <NEWLINE> c += abs ( x ) <NEWLINE> <DEDENT> <DEDENT> print ( c ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> cnt = 0 <NEWLINE> for i in A : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> if A [ i - 1 ] > A [ i ] : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) <NEWLINE> counter = 0 <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> if a [ i ] > a [ i + 1 ] : <NEWLINE> <INDENT> counter += a [ i ] - a [ i + 1 ] <NEWLINE> <DEDENT> <DEDENT> print ( counter ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) ) ) <NEWLINE> s = a [ 0 ] <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> ans += max ( 0 , a [ i ] - s ) <NEWLINE> s = max ( s , a [ i ] ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> arr = map ( int , input ( ) . split ( ) ) <NEWLINE> cmp = arr [ 0 ] <NEWLINE> ans = 0 <NEWLINE> <NL> for i in range ( 1 , len ( arr ) ) : <NEWLINE> <INDENT> cmp = max ( arr [ i ] , cmp ) <NEWLINE> add = cmp - arr [ i ] <NEWLINE> ans = ans + add <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> heights = map ( int , input ( ) ) <NEWLINE> <NL> current_highest = heights [ 0 ] <NEWLINE> steps_sum = 0 <NEWLINE> for h in heights [ 1 : ] : <NEWLINE> <INDENT> if h > current_highest : <NEWLINE> <INDENT> current_highest = h <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> steps_sum += h - current_highest <NEWLINE> <NL> <DEDENT> <DEDENT> print ( steps_sum ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> if A [ i - 1 ] > high : <NEWLINE> <INDENT> high = A [ i - 1 ] <NEWLINE> <DEDENT> if high > A [ i - 1 ] : <NEWLINE> <INDENT> ans += high - A [ i ] <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> for i in range ( n - 1 ) : <NEWLINE> <INDENT> if a [ i ] > a [ i + 1 ] : <NEWLINE> <INDENT> ans += a [ i ] - a [ i + 1 ] <NEWLINE> a [ i + 1 ] = a [ i ] <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> if a [ i ] > i [ i + 1 ] : <NEWLINE> <INDENT> x += a [ i ] - a [ i + 1 ] <NEWLINE> a [ i + 1 ] = a [ i ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( x ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = lsit ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> stack = [ a [ 0 ] ] <NEWLINE> s = 0 <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> if a [ i ] < stack [ - 1 ] : <NEWLINE> <INDENT> s = s + abs ( a [ i ] - stack [ - 1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> stack . append ( a [ i ] ) <NEWLINE> <DEDENT> <DEDENT> print ( s ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = [ map ( int , input ( ) . split ( ) ) ] <NEWLINE> <NL> total = 0 <NEWLINE> m = 0 <NEWLINE> <NL> for x in a : <NEWLINE> <INDENT> if m > x : <NEWLINE> <INDENT> total += m - x <NEWLINE> <DEDENT> m = max ( m , x ) <NEWLINE> <NL> <DEDENT> print ( total ) <NEWLINE>
import math <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> tmp = A [ i ] - A [ i + 1 ] <NEWLINE> if tmp <= 0 : <NEWLINE> <INDENT> ans = ans + tmp <NEWLINE> A [ i + 1 ] = A [ i ] <NEWLINE> <NL> <DEDENT> <DEDENT> Print ( ans ) <NEWLINE>
n = input ( ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> max_a_list = [ 0 ] * n <NEWLINE> max_a_list [ 0 ] = a [ 0 ] <NEWLINE> <NL> for i in range ( 1 , n ) : <NEWLINE> <INDENT> max_a_list [ i ] = max ( max_a_list [ i - 1 ] , a [ i ] ) <NEWLINE> <DEDENT> sum_ = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> sum_ += max ( max_a_list [ i ] - a [ i ] , 0 ) <NEWLINE> <DEDENT> print ( sum_ ) <NEWLINE> <NL>
input ( ) <NEWLINE> A = list ( map ( int , input . split ( ) ) ) <NEWLINE> <NL> sum = 0 <NEWLINE> <NL> for i in range ( 1 , len ( A ) ) : <NEWLINE> <INDENT> if A [ i ] < A [ i - 1 ] : <NEWLINE> <INDENT> sum += A [ i - 1 ] - A [ i ] <NEWLINE> A [ i ] = A [ i - 1 ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( sum ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if a [ i ] - a [ i - 1 ] >= 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += abs ( a [ i ] - a [ i - 1 ] ) <NEWLINE> a [ i ] += abs ( a [ i ] - a [ i - 1 ] ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> using namespace std ; <NEWLINE> <NL> int main ( ) { <NEWLINE> <INDENT> ios_base : : sync_with_stdio ( false ) ; <NEWLINE> cin . tie ( NULL ) ; <NEWLINE> ll t , n , ma = - 1 ; <NEWLINE> ll ans = 0 ; <NEWLINE> cin >> n ; <NEWLINE> while ( n - - ) { <NEWLINE> <INDENT> cin >> t ; <NEWLINE> ma = max ( ma , t ) ; <NEWLINE> ans += ( ma - t ) ; <NEWLINE> <DEDENT> } <NEWLINE> cout << ans ; <NEWLINE> return 0 ; <NEWLINE> <DEDENT> } <NEWLINE>
pre = 0 <NEWLINE> max_chair = 0 <NEWLINE> list_chair = [ ] <NEWLINE> for i in list_height : <NEWLINE> <INDENT> if i < pre : <NEWLINE> <INDENT> max_chair = pre - i <NEWLINE> pre = i + max_chair <NEWLINE> list_chair . append ( max_chair ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> pre = i <NEWLINE> <DEDENT> <DEDENT> print ( sum ( list_chair ) ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> import sys <NEWLINE> <NL> readline = sys . stdin . buffer . readline <NEWLINE> iimr = lambda : map ( int , sys . stdin . buffer . readline ( ) . rstrip ( ) . split ( ) ) <NEWLINE> <COMMENT> <NL> <NL> def debug ( * x ) : <NEWLINE> <INDENT> print ( * x , file = sys . stderr ) <NEWLINE> <NL> <NL> <DEDENT> class atcoder ( ) : <NEWLINE> <INDENT> def __init__ ( self ) : <NEWLINE> <INDENT> pass <NEWLINE> <NL> <DEDENT> def zmek ( self ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , sys . stdin . buffer . readline ( ) . split ( ) ) ) <NEWLINE> res = [ ] <NEWLINE> res . append ( self .  ( N , A ) ) <NEWLINE> print ( * res , <STRING> ) <NEWLINE> <NL> <DEDENT> def  ( self , n , Aliste ) : <NEWLINE> <INDENT> res = 0 <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> if Aliste [ i - 1 ] > Aliste [ i ] : <NEWLINE> <INDENT> res += Aliste [ i - 1 ] - Aliste [ i ] <NEWLINE> Aliste [ i ] = Aliste [ i - 1 ] <NEWLINE> <NL> <DEDENT> <DEDENT> return res <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> ima = atcoder ( ) <NEWLINE> ima . zmek ( ) <NEWLINE> <NL> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> if a [ i ] > i [ i + 1 ] : <NEWLINE> <INDENT> x += ( a [ i ] - a [ i + 1 ] ) <NEWLINE> a [ i + 1 ] = a [ i ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<INDENT> = int ( input ( ) ) <NEWLINE> <DEDENT> list1 = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> h , c = 0 , 0 <NEWLINE> for i in list1 : <NEWLINE> <INDENT> if i < h : <NEWLINE> <INDENT> c += h - i <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> h = i <NEWLINE> <DEDENT> <DEDENT> print ( c ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> count = 0 <NEWLINE> for i in n - 1 : <NEWLINE> <INDENT> if a [ i + 1 ] < a [ i ] : <NEWLINE> <INDENT> count += a [ i ] - a [ i + 1 ] <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> step = 0 <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> if a [ i ] > a [ i + 1 ] : <NEWLINE> <INDENT> humi += a [ i ] - a [ i + 1 ] <NEWLINE> a [ i + 1 ] = a [ i ] <NEWLINE> <DEDENT> <DEDENT> print ( step ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> i = 0 <NEWLINE> sum = 0 <NEWLINE> while i < N : <NEWLINE> <INDENT> if A [ i ] <= A [ i + 1 ] : <NEWLINE> <INDENT> f = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> f = A [ i ] - A [ i + 1 ] <NEWLINE> <DEDENT> A [ i + 1 ] += f <NEWLINE> sum += f <NEWLINE> i += 1 <NEWLINE> <DEDENT> print ( sum ) <NEWLINE>
def main ( lines ) : <NEWLINE> <INDENT> line = lines <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> lines = [ ] <NEWLINE> for l in sys . stdin : <NEWLINE> <INDENT> lines . append ( l . rstrip ( <STRING> ) ) <NEWLINE> <DEDENT> main ( lines ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> high = 0 <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> if A [ i - 1 ] > high : <NEWLINE> <INDENT> high = A [ i - 1 ] <NEWLINE> <DEDENT> if A [ i ] < hihg : <NEWLINE> <INDENT> ans += high - A [ i ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = input ( ) <NEWLINE> summ = 0 <NEWLINE> lst = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i in range ( len ( lst ) - 1 ) : <NEWLINE> <INDENT> if lst [ i ] > lst [ i + 1 ] : <NEWLINE> <INDENT> k = lst [ i ] - lst [ i + 1 ] <NEWLINE> lst . replace ( lst [ i + 1 ] , lst [ i + 1 ] + k ) <NEWLINE> summ += k <NEWLINE> <DEDENT> <DEDENT> print ( summ ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> p = 0 <NEWLINE> q = 0 <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> e = a [ i + 1 ] - a [ i ] <NEWLINE> if e > 0 : <NEWLINE> <INDENT> q = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if p - q > e : <NEWLINE> <INDENT> q -= e <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> q -= e <NEWLINE> e = q <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( s ) <NEWLINE>
n = int ( input ( ) ) l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> u = max ( l ) <NEWLINE> d = 0 <NEWLINE> i = 0 <NEWLINE> while l [ i ] != u : <NEWLINE> <INDENT> if l [ i ] > l [ i + 1 ] : <NEWLINE> <INDENT> d = d + abs ( l [ i + 1 ] - l [ i ] ) <NEWLINE> l [ i + 1 ] = l [ i ] <NEWLINE> <DEDENT> i = i + 1 <NEWLINE> <DEDENT> r = i <NEWLINE> for b in range ( r , n ) : <NEWLINE> <INDENT> d = d + ( u - l [ b ] ) <NEWLINE> <DEDENT> print ( d ) <NEWLINE>
N = input ( ) <NEWLINE> tmp = 0 <NEWLINE> while N > 0 : <NEWLINE> <INDENT> tmp += ( N % 10 ) <NEWLINE> N /= 10 <NEWLINE> <DEDENT> if tmp % 9 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( n - 2 ) : <NEWLINE> <INDENT> s = a [ i + 1 ] - a [ i ] <NEWLINE> if s >= 0 : <NEWLINE> <INDENT> ans = ans + 0 <NEWLINE> else : <NEWLINE> <INDENT> ans = ans - s <NEWLINE> a [ i + 1 ] = a [ i ] - s <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> maxV = max ( list ) <NEWLINE> maxI = list . index ( maxV ) <NEWLINE> <NL> sumV = sum ( list [ maxI + 1 , len ( list ) ] ) <NEWLINE> maxM = maxV * ( len ( list ) - 1 - maxI ) <NEWLINE> ans += maxM - sumV <NEWLINE> <NL> if maxI != 0 : <NEWLINE> <INDENT> for i in range ( 0 , maxI ) : <NEWLINE> <INDENT> if i != maxI : <NEWLINE> <INDENT> x = list [ i ] - list [ i + 1 ] <NEWLINE> if x > 0 : <NEWLINE> <INDENT> ans += x <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = input ( ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> Sum = 0 <NEWLINE> <NL> for i in range ( N - 1 ) : <NEWLINE> <INDENT> if ( A [ i ] - A [ i + 1 ] > 0 ) : <NEWLINE> <INDENT> Sum += A [ i ] - A [ i + 1 ] <NEWLINE> A [ i + 1 ] += A [ i ] - A [ i + 1 ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( Sum ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> l = map ( int , input ( ) . spliut ( ) ) <NEWLINE> max = l [ 0 ] <NEWLINE> c = 0 <NEWLINE> for x in l : <NEWLINE> <INDENT> if max < x : <NEWLINE> <INDENT> max = x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> c += ( max - x ) <NEWLINE> <DEDENT> <DEDENT> print ( c ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <NL> N = int ( input ( ) ) <NEWLINE> Als = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> for i in range ( 1 , N ) : <NEWLINE> <INDENT> if Als [ i ] >= Als [ i - 1 ] : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += max ( Als [ 0 : i ] - Als [ i ] ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
a = int ( input ( ) ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> bmax = 0 <NEWLINE> ans = 0 <NEWLINE> for i in range ( a ) : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> bmax = a [ i ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if bmax < a [ i ] : <NEWLINE> <INDENT> bmax = a [ i ] <NEWLINE> <DEDENT> elif bmax > a [ i ] : <NEWLINE> <INDENT> ans += bmax - a [ i ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( str ( ans ) ) <NEWLINE>
import math <NEWLINE> <NL> <COMMENT> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <COMMENT> <NL> cnt = 0 <NEWLINE> cur = A [ 0 ] <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> if cur > A [ i ] : <NEWLINE> <INDENT> cnt += cur - A [ i ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cur = A [ i ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in range ( len ( a ) - 1 ) : <NEWLINE> <INDENT> if a [ i ] > a [ + 1 ] : <NEWLINE> <INDENT> s += 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s += a [ i + 1 ] - a [ i ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( s ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> dif = 0 <NEWLINE> sum = 0 <NEWLINE> <NL> for i in range ( N - 1 ) : <NEWLINE> <INDENT> if A [ i ] > A [ i + 1 ] : <NEWLINE> <INDENT> dif = A [ i ] - A [ i + 1 ] <NEWLINE> sum += dif <NEWLINE> A [ i + 1 ] = A [ i + 1 ] + dif <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <NL> <DEDENT> print ( sum ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> x = [ 0 for _ in range ( N ) ] <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> if A [ i ] < A [ i - 1 ] + x [ i - 1 ] : <NEWLINE> <INDENT> x [ i ] = A [ i - 1 ] + x [ i - 1 ] - A [ i ] <NEWLINE> <DEDENT> <DEDENT> print ( sum ( x_list ) ) <NEWLINE>
ans = 0 <NEWLINE> <NL> for i in range ( N - 1 ) : <NEWLINE> <INDENT> if As [ i ] > As [ i + 1 ] : <NEWLINE> <INDENT> diff = As [ i ] - As [ i + 1 ] <NEWLINE> As [ i + 1 ] = As [ i ] <NEWLINE> ans += diff <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> pass <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) <NEWLINE> p = l [ 0 ] <NEWLINE> x = 0 <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> if l [ i ] < p : <NEWLINE> <INDENT> x += p - l [ i ] <NEWLINE> <DEDENT> elif l [ i ] > p : <NEWLINE> <INDENT> p = l [ i ] <NEWLINE> <DEDENT> <DEDENT> print ( x ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> if A [ i ] > A [ i + 1 ] : <NEWLINE> <INDENT> A [ i + 1 ] = A [ i ] <NEWLINE> ans += A [ i ] - A [ i + 1 ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> stage_hight = [ ] <NEWLINE> for i , ai in enumerate ( A ) : <NEWLINE> <INDENT> if not i and ai < A [ i - 1 ] : <NEWLINE> <INDENT> stage_hight . append ( A [ i - 1 ] - ai ) <NEWLINE> A [ i ] = A [ i - 1 ] <NEWLINE> <DEDENT> <DEDENT> print ( sum ( stage_hight ) ) <NEWLINE>
n = input ( ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> temp = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if A [ i ] < temp : <NEWLINE> <INDENT> ans += temp - A [ i ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> temp = max ( temp , A [ i ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = input ( ) <NEWLINE> A = map ( int , input ( ) . split ( ) ) <NEWLINE> sum = 0 <NEWLINE> pre = 0 <NEWLINE> for ai in A : <NEWLINE> <INDENT> if pre > ai : <NEWLINE> <INDENT> sum += pre - ai <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> pre = ai <NEWLINE> <DEDENT> <DEDENT> print ( sum <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) , split ( ) ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> cur_max = 0 <NEWLINE> <NL> for x in a : <NEWLINE> <INDENT> if cur_max > x : <NEWLINE> <INDENT> ans += cur_max - x <NEWLINE> <DEDENT> cur_max = max ( cur_max , x ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
def func ( A ) : <NEWLINE> <INDENT> result = 0 <NEWLINE> min = 0 <NEWLINE> for a in A : <NEWLINE> <INDENT> if a < min : <NEWLINE> <INDENT> result += min - a <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> min = a <NEWLINE> <DEDENT> <DEDENT> return result <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> A = list ( int , input ( ) . split ( ) ) <NEWLINE> print ( func ( A ) ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> sum = 0 <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> if x [ i ] < x [ i - 1 ] : <NEWLINE> <INDENT> t = x [ i - 1 ] - x [ i ] <NEWLINE> sum += t <NEWLINE> x [ i ] = x [ i - 1 ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( sum ) <NEWLINE>
<STRING> <NEWLINE> from sys import stdin , stdout <NEWLINE> from math import * <NEWLINE> from collections import * <NEWLINE> <NL> mod = 1000000007 <NEWLINE> <NL> def gcd ( a , b ) : <NEWLINE> <INDENT> while b : <NEWLINE> <INDENT> a , b = b , a % b <NEWLINE> <DEDENT> return a <NEWLINE> <NL> <DEDENT> def lcm ( a , b ) : return ( a * b ) // gcd ( a , b ) <NEWLINE> <NL> def set_bits ( X ) : <NEWLINE> <INDENT> c = 0 <NEWLINE> while X : <NEWLINE> <INDENT> X &= ( X - 1 ) ; c += 1 <NEWLINE> <DEDENT> return c <NEWLINE> <NL> <DEDENT> def compute_MOD ( N , M ) : return ( N % M + M ) % M <NEWLINE> <NL> def get_array ( ) : return list ( map ( int , stdin . readline ( ) . split ( ) ) ) <NEWLINE> <NL> def get_ints ( ) : return map ( int , stdin . readline ( ) . split ( ) ) <NEWLINE> <NL> def get_int ( ) : return int ( stdin . readline ( ) ) <NEWLINE> <NL> def get_input ( ) : return stdin . readline ( ) . strip ( ) <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> tc = get_int ( ) <NEWLINE> <COMMENT> <NL> arr = get_array ( ) <NEWLINE> ans = 0 <NEWLINE> Max = arr [ 0 ] <NEWLINE> for i in arr [ 1 : ] : <NEWLINE> Max = max ( Max , i ) <NEWLINE> ans += Max - i <NEWLINE> stdout . write ( str ( ans ) + <STRING> ) <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> sum = 0 <NEWLINE> for n in range ( N - 1 ) : <NEWLINE> <INDENT> if a [ n ] > a [ n + 1 ] : <NEWLINE> <INDENT> dif = a [ n ] - a [ n + 1 ] <NEWLINE> a [ n + 1 ] = a [ n + 1 ] + dif <NEWLINE> sum += dif <NEWLINE> <DEDENT> <DEDENT> print ( sum ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> high = 0 <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> if high < A [ i - 1 ] : <NEWLINE> <INDENT> high = A [ i - 1 ] <NEWLINE> <DEDENT> if high > A [ i ] : <NEWLINE> <INDENT> ans += high - A [ i ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> import copy <NEWLINE> b = copy . copy ( a ) <NEWLINE> tall = a [ 0 ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if a [ i ] < tall : <NEWLINE> <INDENT> a [ i ] = tall <NEWLINE> cnt += tall - a [ i ] <NEWLINE> <DEDENT> elif a [ i ] > tall : <NEWLINE> <INDENT> tall = a [ i ] <NEWLINE> <DEDENT> <DEDENT> print ( sum ( a ) - sum ( b ) ) <NEWLINE>
n = int ( readline ( ) ) <NEWLINE> a = list ( map ( int , readline ( ) . split ( ) ) ) <NEWLINE> max_l = max ( a ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if i == 0 and max_l : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> elif i < max_l : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> max_a = max ( a ) <NEWLINE> max_b = max ( b ) <NEWLINE> ans = max_a - max_b <NEWLINE> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = input ( ) . split ( ) <NEWLINE> count = 0 <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> if A [ i ] > A [ i + 1 ] : <NEWLINE> <INDENT> count += A [ i + 1 ] - A [ i ] <NEWLINE> A [ i + 1 ] = A [ i ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> m = [ ] <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if l [ i - 1 ] > l [ i ] : <NEWLINE> <INDENT> m . append ( l [ i - 1 ] - l [ i ] ) <NEWLINE> <INDENT> l [ i ] = l [ i - 1 ] <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( sum ( m ) ) <NEWLINE> <NL>
n = int ( input ( ) ) <NEWLINE> a = [ ] <NEWLINE> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> x = int ( input ( ) ) <NEWLINE> a . append ( x ) <NEWLINE> <DEDENT> for i in range ( 1 , n ) : <NEWLINE> <INDENT> if a [ i ] < a [ i - 1 ] : <NEWLINE> <INDENT> ans += a [ i - 1 ] - a [ i ] <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import numpy as np <NEWLINE> from numba import njit , i8 , u1 , void , b1 <NEWLINE> import heapq <NEWLINE> import math <NEWLINE> <NL> @ njit ( i8 ( i8 , i8 , i8 , i8 , b1 [ : , : ] ) , cache = True ) <NEWLINE> def solve ( ch , cw , dh , dw , road_map ) : <NEWLINE> <NL> <INDENT> h , w = road_map . shape <NEWLINE> queue = [ ( 0 , ch * w + cw ) ] <NEWLINE> used_map = np . full ( h * w , 2 << 30 , dtype = np . int64 ) <NEWLINE> goal = dh * w + dw <NEWLINE> <NL> <COMMENT> <NL> <NL> while len ( queue ) != 0 : <NEWLINE> <INDENT> dot = heapq . heappop ( queue ) <NEWLINE> tl , n = dot [ 0 ] , dot [ 1 ] <NEWLINE> th , tw = divmod ( n , w ) <NEWLINE> used_map [ n ] = tl <NEWLINE> if n == goal : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> for x in range ( - 2 , 3 , 1 ) : <NEWLINE> <INDENT> for y in range ( - 2 , 3 , 1 ) : <NEWLINE> <INDENT> if x == y == 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if abs ( x ) + abs ( y ) <= 1 : <NEWLINE> <INDENT> loop = tl <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> loop = tl + 1 <NEWLINE> <DEDENT> tx = th + x <NEWLINE> ty = tw + y <NEWLINE> next_n = tx * w + ty <NEWLINE> if tx < 0 or ty < 0 or tx >= h or ty >= w or road_map [ tx ] [ ty ] == True : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> check = used_map [ next_n ] <NEWLINE> if check > loop : <NEWLINE> <INDENT> heapq . heappush ( queue , ( loop , next_n ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if used_map [ goal ] == 2 << 30 : <NEWLINE> <INDENT> return - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return used_map [ goal ] <NEWLINE> <NL> <DEDENT> <DEDENT> h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> ch , cw = map ( int , input ( ) . split ( ) ) <NEWLINE> ch , cw = ch - 1 , cw - 1 <NEWLINE> dh , dw = map ( int , input ( ) . split ( ) ) <NEWLINE> dh , dw = dh - 1 , dw - 1 <NEWLINE> road_map = np . array ( [ [ c == <STRING> for c in input ( ) ] for _ in range ( h ) ] ) <NEWLINE> <NL> print ( solve ( ch , cw , dh , dw , road_map ) ) <NEWLINE> <NL>
import sys <NEWLINE> read = sys . stdin . buffer . read <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> readlines = sys . stdin . buffer . readlines <NEWLINE> <NL> <COMMENT> <NL> h , w = map ( int , readline ( ) . split ( ) ) <NEWLINE> ch , cw = map ( int , readline ( ) . split ( ) ) <NEWLINE> dh , dw = map ( int , readline ( ) . split ( ) ) <NEWLINE> m = list ( map ( lambda x : list ( x . decode ( ) ) , readlines ( ) ) ) <NEWLINE> <COMMENT> <NL> <NL> ch -= 1 ; cw -= 1 ; dh -= 1 ; dw -= 1 <NEWLINE> <NL> ad = [ ( - 1 , 0 ) , ( 0 , - 1 ) , ( 1 , 0 ) , ( 0 , 1 ) ] <NEWLINE> warp = [ ( - 2 , - 2 ) , ( - 2 , - 1 ) , ( - 2 , 0 ) , ( - 2 , 1 ) , ( - 2 , 2 ) , <NEWLINE> <INDENT> ( - 1 , - 2 ) , ( - 1 , - 1 ) , ( - 1 , 1 ) , ( - 1 , 2 ) , <NEWLINE> ( 0 , - 2 ) , ( 0 , 2 ) , <NEWLINE> ( 1 , - 2 ) , ( 1 , - 1 ) , ( 1 , 1 ) , ( 1 , 2 ) , <NEWLINE> ( 2 , - 2 ) , ( 2 , - 1 ) , ( 2 , 0 ) , ( 2 , 1 ) , ( 2 , 2 ) ] <NEWLINE> <NL> <DEDENT> def bfs4 ( ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> for i in range ( h ) : <NEWLINE> <INDENT> m [ i ] = [ <STRING> ] * 2 + m [ i ] + [ <STRING> ] * 2 <NEWLINE> <NL> <DEDENT> m = [ [ <STRING> ] * ( w + 4 ) ] * 2 + m + [ [ <STRING> ] * ( w + 4 ) ] * 2 <NEWLINE> ch += 2 ; cw += 2 ; dh += 2 ; dw += 2 <NEWLINE> <NL> que1 = [ ] <NEWLINE> que2 = [ ] <COMMENT> <NEWLINE> m [ ch ] [ cw ] = str ( 0 ) <NEWLINE> que1 . append ( ( ch , cw ) ) <NEWLINE> <NL> while que1 != [ ] : <NEWLINE> <INDENT> l1 = len ( que1 ) <NEWLINE> r1 = 0 <COMMENT> <NEWLINE> <NL> <COMMENT> <NL> while r1 < l1 : <NEWLINE> <INDENT> i , j = que1 [ r1 ] <NEWLINE> r1 += 1 <NEWLINE> <COMMENT> <NL> for si , sj in ad : <NEWLINE> <INDENT> if m [ i + si ] [ j + sj ] == <STRING> : <NEWLINE> <INDENT> m [ i + si ] [ j + sj ] = m [ i ] [ j ] <NEWLINE> que1 . append ( ( i + si , j + sj ) ) <NEWLINE> l1 += 1 <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> for i , j in que1 : <NEWLINE> <INDENT> for si , sj in warp : <NEWLINE> <INDENT> if m [ i + si ] [ j + sj ] == <STRING> : <NEWLINE> <INDENT> m [ i + si ] [ j + sj ] = str ( int ( m [ i ] [ j ] ) + 1 ) <NEWLINE> que2 . append ( ( i + si , j + sj ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> que1 = que2 <NEWLINE> que2 = [ ] <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> bfs4 ( ) <NEWLINE> <NL> <NL> if m [ dh ] [ dw ] == <STRING> : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( m [ dh ] [ dw ] ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <STRING> <NEWLINE> import os , sys <NEWLINE> p = os . path . dirname ( __file__ ) <NEWLINE> pymain = os . path . join ( p , <STRING> ) <NEWLINE> if len ( sys . argv ) == 1 : <NEWLINE> <INDENT> import subprocess <NEWLINE> if p == <STRING> : <NEWLINE> <INDENT> pymain = <STRING> + pymain <NEWLINE> <DEDENT> subprocess . call ( pymain ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> import gzip , base64 , stat <NEWLINE> gz = <STRING> <NEWLINE> bin = gzip . decompress ( base64 . b64decode ( gz ) ) <NEWLINE> with open ( pymain , <STRING> ) as f : <NEWLINE> <INDENT> f . write ( bin ) <NEWLINE> <DEDENT> os . chmod ( pymain , 0o775 ) <NEWLINE> <DEDENT>
import os <NEWLINE> import sys <NEWLINE> <NL> import numpy as np <NEWLINE> from heapq import heappop , heappush <NEWLINE> <NL> <NL> def solve ( h , w , s , t , field ) : <NEWLINE> <INDENT> WARP = ( - ( w * 2 + 10 ) , - ( w * 2 + 9 ) , - ( w * 2 + 8 ) , - ( w * 2 + 7 ) , - ( w * 2 + 6 ) , <NEWLINE> <INDENT> - ( w + 6 ) , - ( w + 5 ) , - ( w + 3 ) , - ( w + 2 ) , <NEWLINE> - 2 , 2 , <NEWLINE> w + 2 , w + 3 , w + 5 , w + 6 , <NEWLINE> w * 2 + 6 , w * 2 + 7 , w * 2 + 8 , w * 2 + 9 , w * 2 + 10 ) <NEWLINE> <DEDENT> WALK = ( - ( w + 4 ) , - 1 , 1 , w + 4 ) <NEWLINE> <NL> qc = np . zeros ( 1000000 , dtype = np . int32 ) <NEWLINE> qv = np . zeros ( 1000000 , dtype = np . int32 ) <NEWLINE> qv [ 0 ] = s <NEWLINE> l , r = 0 , 1 <NEWLINE> visited = np . zeros ( ( h + 4 ) * ( w + 4 ) , np . int8 ) <NEWLINE> queued = np . zeros ( ( h + 4 ) * ( w + 4 ) , np . int8 ) <NEWLINE> queued [ s ] = 1 <NEWLINE> while l < r : <NEWLINE> <INDENT> cost = qc [ l ] <NEWLINE> v = qv [ l ] <NEWLINE> l += 1 <NEWLINE> if v == t : <NEWLINE> <INDENT> return cost <NEWLINE> <DEDENT> if visited [ v ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> visited [ v ] = 1 <NEWLINE> for d in WALK : <NEWLINE> <INDENT> u = v + d <NEWLINE> if field [ u ] or visited [ u ] or queued [ u ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> queued [ u ] = 1 <NEWLINE> l -= 1 <NEWLINE> qc [ l ] = cost <NEWLINE> qv [ l ] = u <NEWLINE> <DEDENT> for d in WARP : <NEWLINE> <INDENT> u = v + d <NEWLINE> if field [ u ] or visited [ u ] or queued [ u ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> qc [ r ] = cost + 1 <NEWLINE> qv [ r ] = u <NEWLINE> r += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> return - 1 <NEWLINE> <NL> <NL> <DEDENT> if sys . argv [ - 1 ] == <STRING> : <NEWLINE> <INDENT> from numba . pycc import CC <NEWLINE> <NL> cc = CC ( <STRING> ) <NEWLINE> cc . export ( <STRING> , <STRING> ) ( solve ) <NEWLINE> cc . compile ( ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> if os . name == <STRING> : <NEWLINE> <COMMENT> <NL> <INDENT> from my_module import solve <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> from numba import njit <NEWLINE> <NL> solve = njit ( <STRING> , cache = True ) ( solve ) <NEWLINE> print ( <STRING> , file = sys . stderr ) <NEWLINE> <NL> <DEDENT> h , w = map ( int , sys . stdin . readline ( ) . split ( ) ) <NEWLINE> ch , cw = map ( int , sys . stdin . readline ( ) . split ( ) ) <NEWLINE> dh , dw = map ( int , sys . stdin . readline ( ) . split ( ) ) <NEWLINE> field = np . ones ( ( h + 4 ) * ( w + 4 ) , dtype = np . int8 ) <NEWLINE> for i in range ( h ) : <NEWLINE> <INDENT> line = sys . stdin . readline ( ) . strip ( ) <NEWLINE> field [ ( i + 2 ) * ( w + 4 ) + 2 : ( i + 2 ) * ( w + 4 ) + w + 2 ] = list ( map ( <STRING> . index , line ) ) <NEWLINE> <DEDENT> s = ( ch + 1 ) * ( w + 4 ) + cw + 1 <NEWLINE> t = ( dh + 1 ) * ( w + 4 ) + dw + 1 <NEWLINE> ans = solve ( h , w , s , t , field ) <NEWLINE> print ( ans ) <NEWLINE>
import numpy as np <NEWLINE> from numba import njit , i8 , u1 , void , b1 <NEWLINE> import heapq <NEWLINE> import math <NEWLINE> <NL> @ njit ( i8 ( b1 [ : , : ] , i8 , i8 , i8 , i8 ) , cache = True ) <NEWLINE> def solve ( road_map , ch , cw , dh , dw ) : <NEWLINE> <NL> <INDENT> h , w = road_map . shape <NEWLINE> queue = [ ( 0 , ch * w + cw ) ] <NEWLINE> max_l = 2 << 30 <NEWLINE> used_map = np . full ( h * w , max_l , dtype = np . int64 ) <NEWLINE> goal = dh * w + dw <NEWLINE> <NL> <COMMENT> <NL> <NL> while len ( queue ) != 0 : <NEWLINE> <INDENT> tl , n = heapq . heappop ( queue ) <NEWLINE> th , tw = divmod ( n , w ) <NEWLINE> used_map [ n ] = tl <NEWLINE> if n == goal : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> for x in range ( - 2 , 3 , 1 ) : <NEWLINE> <INDENT> for y in range ( - 2 , 3 , 1 ) : <NEWLINE> <INDENT> if x == y == 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if abs ( x ) + abs ( y ) <= 1 : <NEWLINE> <INDENT> loop = tl <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> loop = tl + 1 <NEWLINE> <DEDENT> tx = th + x <NEWLINE> ty = tw + y <NEWLINE> next_n = tx * w + ty <NEWLINE> if tx < 0 or ty < 0 or tx >= h or ty >= w or road_map [ tx ] [ ty ] == True : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> check = used_map [ next_n ] <NEWLINE> if check > loop : <NEWLINE> <INDENT> heapq . heappush ( queue , ( loop , next_n ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> ans = used_map [ goal ] <NEWLINE> if ans == max_l : <NEWLINE> <INDENT> return - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return ans <NEWLINE> <NL> <DEDENT> <DEDENT> h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> ch , cw = map ( int , input ( ) . split ( ) ) <NEWLINE> ch , cw = ch - 1 , cw - 1 <NEWLINE> dh , dw = map ( int , input ( ) . split ( ) ) <NEWLINE> dh , dw = dh - 1 , dw - 1 <NEWLINE> road_map = np . array ( [ [ c == <STRING> for c in input ( ) ] for _ in range ( h ) ] ) <NEWLINE> <NL> print ( solve ( road_map , ch , cw , dh , dw ) ) <NEWLINE> <NL>
from collections import deque <NEWLINE> def main ( ) : <NEWLINE> <INDENT> h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> ch , cw = map ( lambda x : int ( x ) + 1 , input ( ) . split ( ) ) <NEWLINE> dh , dw = map ( lambda x : int ( x ) + 1 , input ( ) . split ( ) ) <NEWLINE> s = [ [ <STRING> ] * ( w + 4 ) for _ in range ( 2 ) ] + [ [ <STRING> ] * 2 + list ( input ( ) ) + [ <STRING> ] * 2 for _ in range ( h ) ] + [ [ <STRING> ] * ( w + 4 ) for _ in range ( 2 ) ] <NEWLINE> m1 = ( ( - 1 , 0 ) , ( 0 , - 1 ) , ( 0 , 1 ) , ( 1 , 0 ) ) <NEWLINE> m2 = [ ( i , j ) for i in range ( - 2 , 3 ) for j in range ( - 2 , 3 ) if abs ( i ) + abs ( j ) > 1 ] <NEWLINE> a = deque ( [ ( ch , cw ) ] ) <NEWLINE> b = deque ( ) <NEWLINE> i = 0 <NEWLINE> while a : <NEWLINE> <INDENT> while a : <NEWLINE> <INDENT> ah , aw = a . popleft ( ) <NEWLINE> if s [ bh ] [ bw ] != <STRING> : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> b . append ( ( ah , aw ) ) <NEWLINE> s [ ah ] [ aw ] = i <NEWLINE> for bh , bw in m1 : <NEWLINE> <INDENT> bh , bw = ah + bh , aw + bw <NEWLINE> if s [ bh ] [ bw ] == <STRING> : <NEWLINE> <INDENT> a . append ( ( bh , bw ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> while b : <NEWLINE> <INDENT> ah , aw = b . popleft ( ) <NEWLINE> for bh , bw in m2 : <NEWLINE> <INDENT> bh , bw = ah + bh , aw + bw <NEWLINE> if s [ bh ] [ bw ] == <STRING> : <NEWLINE> <INDENT> a . append ( ( bh , bw ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> i += 1 <NEWLINE> <DEDENT> ans = s [ dh ] [ dw ] <NEWLINE> print ( ans if ans != <STRING> else - 1 ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> input = lambda : sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> sys . setrecursionlimit ( max ( 1000 , 10 ** 9 ) ) <NEWLINE> write = lambda x : sys . stdout . write ( x + <STRING> ) <NEWLINE> <NL> <NL> h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> ch , cw = map ( int , input ( ) . split ( ) ) <NEWLINE> dh , dw = map ( int , input ( ) . split ( ) ) <NEWLINE> ch -= 1 <NEWLINE> cw -= 1 <NEWLINE> dh -= 1 <NEWLINE> dw -= 1 <NEWLINE> rows , cols = h , w <NEWLINE> <NL> OK = <STRING> <NEWLINE> NG = <STRING> <NEWLINE> <NL> from collections import defaultdict <NEWLINE> <NL> ns = defaultdict ( set ) <NEWLINE> ss = [ None ] * rows <NEWLINE> for i in range ( rows ) : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> ss [ i ] = s <NEWLINE> <DEDENT> n = rows * cols <NEWLINE> start = ch * w + cw <NEWLINE> goal = dh * w + dw <NEWLINE> seen = [ None ] * n <NEWLINE> seen [ start ] = 0 <NEWLINE> from heapq import heappop as hpp , heappush as hp <NEWLINE> q = [ ( 0 , start ) ] <COMMENT> <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> dx = [ ] <NEWLINE> dy = [ ] <NEWLINE> vvs = [ ] <NEWLINE> e = 10 ** - 9 <NEWLINE> <NL> for i in range ( 3 ) : <NEWLINE> <INDENT> for j in range ( - 2 , 3 ) : <NEWLINE> <INDENT> if not ( i == j == 0 ) : <NEWLINE> <INDENT> dx . append ( i ) <NEWLINE> dy . append ( j ) <NEWLINE> if abs ( i ) + abs ( j ) > 1 : <NEWLINE> <INDENT> vvs . append ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> vvs . append ( e ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> data = [ ] <NEWLINE> rs = [ ] <NEWLINE> cs = [ ] <NEWLINE> for pu in range ( n ) : <NEWLINE> <INDENT> ux , uy = divmod ( pu , w ) <NEWLINE> if ss [ ux ] [ uy ] == <STRING> : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> for xx , yy , vv in zip ( dx , dy , vvs ) : <NEWLINE> <INDENT> x , y = ux + xx , uy + yy <NEWLINE> if x < 0 or y < 0 or x >= h or y >= w or ss [ x ] [ y ] == <STRING> : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> u = x * w + y <NEWLINE> data . append ( vv ) <NEWLINE> rs . append ( pu ) <NEWLINE> cs . append ( u ) <NEWLINE> <DEDENT> <DEDENT> assert False <NEWLINE> import scipy . sparse <NEWLINE> m = scipy . sparse . csr_matrix ( ( data , ( rs , cs ) ) , shape = ( n , n ) ) <NEWLINE> ans = scipy . sparse . csgraph . dijkstra ( m , indices = start , directed = False ) <COMMENT> <NEWLINE> if ans [ goal ] > 10 ** 9 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( int ( ans [ goal ] ) ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> import sys ; from decimal import Decimal <NEWLINE> import math ; from itertools import combinations , product <NEWLINE> import bisect ; from collections import Counter , deque , defaultdict <NEWLINE> <NL> <COMMENT> <NL> MOD = 10 ** 9 + 7 <NEWLINE> INF = 10 ** 9 <NEWLINE> PI = 3.14159265358979323846 <NEWLINE> <NL> def read_str ( ) : return sys . stdin . readline ( ) . strip ( ) <NEWLINE> def read_int ( ) : return int ( sys . stdin . readline ( ) . strip ( ) ) <NEWLINE> def read_ints ( ) : return map ( int , sys . stdin . readline ( ) . strip ( ) . split ( ) ) <NEWLINE> def read_str_list ( ) : return list ( sys . stdin . readline ( ) . strip ( ) . split ( ) ) <NEWLINE> def read_int_list ( ) : return list ( map ( int , sys . stdin . readline ( ) . strip ( ) . split ( ) ) ) <NEWLINE> def lcm ( a : int , b : int ) -> int : return ( a * b ) // math . gcd ( a , b ) <NEWLINE> <NL> import numpy as np <NEWLINE> from numba import i8 , njit , u1 , b1 <NEWLINE> from heapq import heappop , heappush <NEWLINE> <NL> <COMMENT> <NL> def solve ( grid , ch , cw , dh , dw ) : <NEWLINE> <INDENT> h , w = grid . shape <NEWLINE> <NL> dist = np . full ( ( h , w ) , INF , dtype = np . int64 ) <NEWLINE> dist [ ch ] [ cw ] = 0 <NEWLINE> <NL> que = [ ( 0 , ch , cw ) ] <NEWLINE> <NL> while que : <NEWLINE> <INDENT> cnt , y , x = heappop ( que ) <NEWLINE> <NL> if y == dh and x == dw : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> for dy in range ( - 2 , 3 ) : <NEWLINE> <INDENT> for dx in range ( - 2 , 3 ) : <NEWLINE> <INDENT> if dx == 0 and dy == 0 : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <DEDENT> if abs ( dx ) == 2 or abs ( dy ) == 2 or ( abs ( dx ) == 1 and abs ( dy ) == 1 ) : <NEWLINE> <INDENT> warp = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> warp = 0 <NEWLINE> <NL> <DEDENT> nx , ny = x + dx , y + dy <NEWLINE> if nx < 0 or nx >= w or ny < 0 or ny >= h or grid [ ny ] [ nx ] : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <DEDENT> if dist [ ny ] [ nx ] > cnt + warp : <NEWLINE> <INDENT> dist [ ny ] [ nx ] = cnt + warp <NEWLINE> heappush ( que , ( cnt + warp , ny , nx ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if dist [ dh ] [ dw ] == INF : <NEWLINE> <INDENT> return - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return dist [ dh ] [ dw ] <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def Main ( ) : <NEWLINE> <INDENT> H , W = read_ints ( ) <NEWLINE> ch , cw = read_ints ( ) ; ch -= 1 ; cw -= 1 <NEWLINE> dh , dw = read_ints ( ) ; dh -= 1 ; dw -= 1 <NEWLINE> <NL> grid = np . array ( [ [ g == <STRING> for g in read_str ( ) ] for _ in range ( H ) ] ) <NEWLINE> <NL> print ( solve ( grid , ch , cw , dh , dw ) ) <NEWLINE> <NL> <DEDENT> def cc_export ( ) : <NEWLINE> <INDENT> from numba . pycc import CC <NEWLINE> cc = CC ( <STRING> ) <NEWLINE> cc . export ( <STRING> , <STRING> ) ( solve ) <NEWLINE> cc . compile ( ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> if sys . argv [ - 1 ] == <STRING> : <NEWLINE> <INDENT> cc_export ( ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> from my_module import solve <NEWLINE> Main ( ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> from collections import defaultdict <NEWLINE> import heapq <NEWLINE> import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> <NL> def mi ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def ii ( ) : return int ( input ( ) ) <NEWLINE> def isp ( ) : return input ( ) . split ( ) <NEWLINE> def deb ( text ) : print ( <STRING> . format ( text ) ) <NEWLINE> <NL> INF = 1 << 18 <NEWLINE> <NL> from numba import njit , b1 , i4 , i8 , f8 <NEWLINE> <COMMENT> <NL> @ njit ( cache = True ) <NEWLINE> def pos ( W , h , w ) : <NEWLINE> <INDENT> return h * W + w <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> @ njit ( cache = True ) <NEWLINE> def main ( H , W , Ch , Cw , Dh , Dw , G ) : <NEWLINE> <INDENT> Ch -= 1 <NEWLINE> Cw -= 1 <NEWLINE> Dh -= 1 <NEWLINE> Dw -= 1 <NEWLINE> <NL> s = ( Ch , Cw ) <NEWLINE> t = ( Dh , Dw ) <NEWLINE> <NL> hq = [ ( 0 , s ) ] <NEWLINE> heapq . heapify ( hq ) <NEWLINE> <NL> dist = [ INF ] * ( H * W ) <COMMENT> <NEWLINE> dist [ pos ( W , * s ) ] = 0 <NEWLINE> while hq : <NEWLINE> <INDENT> d , x = heapq . heappop ( hq ) <COMMENT> <NEWLINE> if dist [ pos ( W , * x ) ] < d : continue <NEWLINE> <NL> h , w = x <NEWLINE> normal = set ( [ ( h - 1 , w ) , ( h + 1 , w ) , ( h , w + 1 ) , ( h , w - 1 ) ] ) <NEWLINE> for dh in range ( - 2 , 3 ) : <NEWLINE> <INDENT> for dw in range ( - 2 , 3 ) : <NEWLINE> <INDENT> new_h , new_w = h + dh , w + dw <NEWLINE> e = ( new_h , new_w ) <NEWLINE> cost = 1 <NEWLINE> <NL> if dh == 0 and dw == 0 : continue <NEWLINE> if not ( 0 <= new_h < H and 0 <= new_w < W ) : continue <NEWLINE> if G [ pos ( W , * e ) ] == 1 : continue <NEWLINE> if e in normal : <NEWLINE> <INDENT> cost -= 1 <NEWLINE> <NL> <DEDENT> if dist [ pos ( W , * e ) ] > dist [ pos ( W , * x ) ] + cost : <NEWLINE> <INDENT> dist [ pos ( W , * e ) ] = dist [ pos ( W , * x ) ] + cost <NEWLINE> heapq . heappush ( hq , ( dist [ pos ( W , * e ) ] , e ) ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if dist [ pos ( W , * t ) ] == INF : <NEWLINE> <INDENT> dist [ pos ( W , * t ) ] = - 1 <NEWLINE> <NL> <DEDENT> return dist [ pos ( W , * t ) ] <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> H , W = mi ( ) <NEWLINE> Ch , Cw = mi ( ) <NEWLINE> Dh , Dw = mi ( ) <NEWLINE> <NL> G = [ 0 ] * H * W <NEWLINE> for i in range ( H ) : <NEWLINE> <INDENT> g = [ ] <NEWLINE> for j , s in enumerate ( list ( input ( ) ) ) : <NEWLINE> <INDENT> G [ i * W + j ] = s == <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> ans = main ( H , W , Ch , Cw , Dh , Dw , np . array ( G ) ) <NEWLINE> print ( ans ) <NEWLINE> <NL> <DEDENT>
import sys <NEWLINE> import numpy as np <NEWLINE> <NL> read = sys . stdin . buffer . read <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> readlines = sys . stdin . buffer . readlines <NEWLINE> <NL> H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> ch , cw = map ( int , input ( ) . split ( ) ) <NEWLINE> dh , dw = map ( int , input ( ) . split ( ) ) <NEWLINE> C = np . frombuffer ( read ( ) , dtype = <STRING> ) . reshape ( <NEWLINE> <INDENT> H , - 1 ) [ : , : W ] <COMMENT> <NEWLINE> <DEDENT> C = 1 * ( C == <STRING> ) <COMMENT> <NEWLINE> <NL> <NL> def search_empty ( C , i , j , count ) : <NEWLINE> <INDENT> C [ i , j ] = count <NEWLINE> <COMMENT> <NL> if j > 0 and C [ i , j - 1 ] == 0 : <NEWLINE> <INDENT> search_empty ( C , i , j - 1 , count ) <NEWLINE> <COMMENT> <NL> <DEDENT> if i > 0 and C [ i - 1 , j ] == 0 : <NEWLINE> <INDENT> search_empty ( C , i - 1 , j , count ) <NEWLINE> <COMMENT> <NL> <DEDENT> if i < W - 1 and C [ i + 1 , j ] == 0 : <NEWLINE> <INDENT> search_empty ( C , i + 1 , j , count ) <NEWLINE> <COMMENT> <NL> <DEDENT> if j < H - 1 and C [ i , j + 1 ] == 0 : <NEWLINE> <INDENT> search_empty ( C , i , j + 1 , count ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> count = 2 <NEWLINE> for i in range ( H ) : <NEWLINE> <INDENT> for j in range ( W ) : <NEWLINE> <INDENT> if C [ i , j ] == 0 : <NEWLINE> <INDENT> search_empty ( C , i , j , count ) <NEWLINE> count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> D = np . zeros ( ( count , count ) ) <NEWLINE> <NL> for i in range ( H ) : <NEWLINE> <INDENT> for j in range ( W ) : <NEWLINE> <INDENT> if C [ i , j ] != 1 : <NEWLINE> <INDENT> for k in range ( - 2 , 3 ) : <NEWLINE> <INDENT> for l in range ( - 2 , 3 ) : <NEWLINE> <INDENT> k = i + k <NEWLINE> l = j + l <NEWLINE> if k < 0 or k >= H : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if l < 0 or l >= W : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if C [ k , l ] != 1 and C [ i , j ] != C [ k , l ] : <NEWLINE> <INDENT> D [ C [ i , j ] , C [ k , l ] ] = 1 <NEWLINE> D [ C [ k , l ] , C [ i , j ] ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> start = C [ ch - 1 , cw - 1 ] <NEWLINE> end = C [ dh - 1 , dw - 1 ] <NEWLINE> <NL> count = 0 <NEWLINE> <NL> if start == end : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <NL> <DEDENT> li = [ [ start , 0 ] ] <NEWLINE> while len ( li ) : <NEWLINE> <INDENT> z , c = li . pop ( 0 ) <NEWLINE> if c == max ( C . flatten ( ) ) : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> break <NEWLINE> <DEDENT> for i in range ( 2 , int ( max ( C . flatten ( ) ) ) + 1 ) : <NEWLINE> <INDENT> if i != z and D [ z , i ] != 0 : <NEWLINE> <INDENT> li . append ( [ i , c + 1 ] ) <NEWLINE> <DEDENT> <DEDENT> if c != 0 and end == z : <NEWLINE> <INDENT> print ( c ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT>
H , W , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> B = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( M ) ] <NEWLINE> <NL> bombs_row = [ 0 ] * H <NEWLINE> bombs_col = [ 0 ] * W <NEWLINE> <NL> for b in B : <NEWLINE> <INDENT> bombs_row [ b [ 0 ] - 1 ] += 1 <NEWLINE> bombs_col [ b [ 1 ] - 1 ] += 1 <NEWLINE> <NL> <DEDENT> row_max = max ( bombs_row ) <NEWLINE> col_max = max ( bombs_col ) <NEWLINE> <NL> row_max_count = bombs_row . count ( row_max ) <NEWLINE> col_max_count = bombs_col . count ( col_max ) <NEWLINE> <NL> ans = row_max + col_max <NEWLINE> <NL> possible_point = row_max_count * col_max_count <NEWLINE> <NL> bombed_point = 0 <NEWLINE> <NL> for b in B : <NEWLINE> <INDENT> if bombs_row [ b [ 0 ] ] == row_max and bombs_col [ b [ 1 ] ] == col_max : <NEWLINE> <INDENT> bombed_point += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if bombed_point == possible_point : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
H , W , M = map ( int , input ( ) . split ( ) ) <NEWLINE> row = [ 0 ] * H <NEWLINE> col = [ 0 ] * W <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> row [ h - 1 ] += 1 <NEWLINE> col [ w - 1 ] += 1 <NEWLINE> <DEDENT> A = max ( row ) <NEWLINE> B = max ( col ) <NEWLINE> a = [ x for x in range ( H ) if row [ x ] == A ] <NEWLINE> b = [ x for x in range ( W ) if col [ x ] == B ] <NEWLINE> cnt = 0 <NEWLINE> for i in a : <NEWLINE> <INDENT> for j in b : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> if ( i , j ) not in target : <NEWLINE> <INDENT> print ( A + B ) <NEWLINE> exit ( 0 ) <NEWLINE> <DEDENT> if cnt > M : <NEWLINE> <INDENT> print ( A + B - 1 ) <NEWLINE> exit ( 0 ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( A + B - 1 ) <NEWLINE>
import sys <NEWLINE> H , W , M = map ( int , input ( ) . split ( ) ) <NEWLINE> hList = { i + 1 : 0 for i in range ( H ) } <NEWLINE> wList = { i + 1 : 0 for i in range ( W ) } <NEWLINE> pList = set ( ) <NEWLINE> <COMMENT> <NL> for _ in range ( M ) : <NEWLINE> <INDENT> h , w = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <COMMENT> <NL> hList [ h ] += 1 <NEWLINE> wList [ w ] += 1 <NEWLINE> pList . add ( ( h , w ) ) <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> maxHCount = max ( hList . values ( ) ) <NEWLINE> maxHList = [ h for h , count in hList . items ( ) if count == maxHCount ] <NEWLINE> <NL> <NL> maxWCount = max ( wList . values ( ) ) <NEWLINE> maxWList = [ w for w , count in wList . items ( ) if count == maxWCount ] <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> if M < len ( maxHList ) * len ( maxWList ) : <NEWLINE> <INDENT> print ( maxHCount + maxWList ) <NEWLINE> sys . exit ( 0 ) <NEWLINE> <NL> <DEDENT> for maxH in maxHList : <NEWLINE> <INDENT> for maxW in maxWList : <NEWLINE> <INDENT> if ( maxH , maxW ) in pList : <NEWLINE> <INDENT> print ( maxHCount + maxWList - 1 ) <NEWLINE> sys . exit ( 0 ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( maxHCount + maxWList ) <NEWLINE>
h , w , m = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ 0 ] * m <NEWLINE> hc = [ 0 ] * w <NEWLINE> wc = [ 0 ] * h <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> a [ i ] = [ x - 1 , y - 1 ] <NEWLINE> hc [ y - 1 ] += 1 <NEWLINE> wc [ x - 1 ] += 1 <NEWLINE> <DEDENT> hcm = max ( hc ) <NEWLINE> wcm = max ( wc ) <NEWLINE> hk = [ 0 ] * h <NEWLINE> wk = [ 0 ] * w <NEWLINE> for i in range ( len ( hc ) ) : <NEWLINE> <INDENT> if hc [ i ] == hcm : <NEWLINE> <INDENT> hk [ i ] = 1 <NEWLINE> <DEDENT> <DEDENT> for i in range ( len ( wc ) ) : <NEWLINE> <INDENT> if wc [ i ] == wcm : <NEWLINE> <INDENT> wk [ i ] = 1 <NEWLINE> <DEDENT> <DEDENT> c = 0 <NEWLINE> for i in range ( len ( a ) ) : <NEWLINE> <INDENT> if a [ i ] [ 0 ] == wk [ i ] and a [ i ] [ 1 ] == hk [ i ] : <NEWLINE> <INDENT> c += 1 <NEWLINE> <DEDENT> <DEDENT> if c == len ( hk ) * len ( wk ) : <NEWLINE> <INDENT> print ( hcm + wcm - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( hcm + wcm ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> h , w , m = map ( int , input ( ) . split ( ) ) <NEWLINE> row = [ 0 ] * h <NEWLINE> col = [ 0 ] * w <NEWLINE> bomb = set ( ) <NEWLINE> for x in sys . stdin . readlines ( ) : <NEWLINE> <INDENT> H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> bomb . add ( ( H - 1 , W - 1 ) ) <NEWLINE> row [ H - 1 ] += 1 <NEWLINE> col [ W - 1 ] += 1 <NEWLINE> <NL> <DEDENT> maxrow = max ( row ) <NEWLINE> maxcol = max ( col ) <NEWLINE> ans = maxcol + maxrow - 1 <NEWLINE> p , q = [ ] , [ ] <NEWLINE> for i in range ( h ) : <NEWLINE> <INDENT> if row [ i ] == maxrow : <NEWLINE> <INDENT> p . append ( i ) <NEWLINE> <DEDENT> <DEDENT> for i in range ( w ) : <NEWLINE> <INDENT> if col [ i ] == maxcol : <NEWLINE> <INDENT> q . append ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> for i in p : <NEWLINE> <INDENT> for j in q : <NEWLINE> <INDENT> if ( i , j ) not in bomb : <NEWLINE> <INDENT> print ( ans + 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from random import randint <NEWLINE> from collections import defaultdict <NEWLINE> from numba import njit <NEWLINE> import numpy as np <NEWLINE> <NL> <NL> def f ( h , w , m , ins ) : <NEWLINE> <INDENT> yp = np . zeros ( ( h , 2 ) , dtype = np . int ) <NEWLINE> xp = np . zeros ( ( w , 2 ) , dtype = np . int ) <NEWLINE> yp [ : , 1 ] = np . arange ( h ) <NEWLINE> xp [ : , 1 ] = np . arange ( w ) <NEWLINE> ans = 0 <NEWLINE> s = set ( ) <NEWLINE> for hi , wi in ins : <NEWLINE> <INDENT> s . add ( ( hi - 1 , wi - 1 ) ) <NEWLINE> yp [ hi - 1 , 0 ] += 1 <NEWLINE> xp [ wi - 1 , 0 ] += 1 <NEWLINE> <DEDENT> ypm = yp [ : , 0 ] . max ( ) <NEWLINE> xpm = xp [ : , 0 ] . max ( ) <NEWLINE> yps = yp [ yp [ : , 0 ] == ypm ] [ : , 1 ] <NEWLINE> xps = xp [ xp [ : , 0 ] == xpm ] [ : , 1 ] <NEWLINE> <COMMENT> <NL> for ypsi in yps : <NEWLINE> <INDENT> for xpsi in xps : <NEWLINE> <INDENT> a = yp [ ypsi , 0 ] + xp [ xpsi , 0 ] <NEWLINE> a -= ( ypsi , xpsi ) in s <NEWLINE> ans = max ( ans , a ) <NEWLINE> <DEDENT> <DEDENT> return ans <NEWLINE> <NL> <NL> <DEDENT> if False : <NEWLINE> <INDENT> while True : <NEWLINE> <INDENT> h , w = randint ( 1 , 10 ** 5 * 3 ) , randint ( 1 , 10 ** 5 * 3 ) <NEWLINE> m = randint ( 1 , min ( h * w , 10 ** 5 * 3 ) ) <NEWLINE> ins = [ ( randint ( 1 , h ) , randint ( 1 , w ) ) for i in range ( m ) ] <NEWLINE> ans1 = f1 ( h , w , m , ins ) <NEWLINE> ans2 = f2 ( h , w , m , ins ) <NEWLINE> if ans1 != ans2 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> print ( h , w , m ) <NEWLINE> print ( ins ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> h , w , m = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = f ( h , w , m , [ tuple ( map ( int , input ( ) . split ( ) ) ) for i in range ( m ) ] ) <NEWLINE> print ( ans ) <NEWLINE> <DEDENT>
from random import randint <NEWLINE> import numpy as np <NEWLINE> from numba import njit <NEWLINE> <NL> <NL> @ njit ( <STRING> , cache = True ) <NEWLINE> def f ( h , w , m , ins ) : <NEWLINE> <INDENT> yp = np . zeros ( h , dtype = np . int32 ) <NEWLINE> xp = np . zeros ( w , dtype = np . int32 ) <NEWLINE> ans = 0 <NEWLINE> s = set ( ) <NEWLINE> for hi , wi in ins : <NEWLINE> <INDENT> s . add ( ( hi - 1 , wi - 1 ) ) <NEWLINE> yp [ hi - 1 ] += 1 <NEWLINE> xp [ wi - 1 ] += 1 <NEWLINE> <DEDENT> ypm = yp [ yp . argmax ( ) ] <NEWLINE> xpm = xp [ xp . argmax ( ) ] <NEWLINE> yps = np . where ( yp == ypm ) [ 0 ] <NEWLINE> xps = np . where ( xp == xpm ) [ 0 ] <NEWLINE> ans = yp [ yps [ 0 ] ] + xp [ xps [ 0 ] ] <NEWLINE> for ypsi in yps : <NEWLINE> <INDENT> for xpsi in xps : <NEWLINE> <INDENT> if not ( ( ypsi , xpsi ) in s ) : <NEWLINE> <INDENT> return ans <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return ans - 1 <NEWLINE> <NL> <NL> <DEDENT> if False : <NEWLINE> <INDENT> while True : <NEWLINE> <INDENT> h , w = randint ( 1 , 10 ** 5 * 3 ) , randint ( 10 ** 5 , 10 ** 5 * 3 ) <NEWLINE> m = randint ( 1 , min ( h * w , 10 ** 5 * 3 ) ) <NEWLINE> ins = [ ( randint ( 1 , h ) , randint ( 1 , w ) ) for i in range ( m ) ] <NEWLINE> ans = f ( h , w , m , np . array ( ins ) ) <NEWLINE> print ( ans ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> h , w , m = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = f ( h , w , m , np . array ( [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( m ) ] ) ) <NEWLINE> print ( ans ) <NEWLINE> <DEDENT>
import sys <NEWLINE> sys . setrecursionlimit ( 1 << 20 ) <NEWLINE> h , w , m = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> <NL> hnm = [ 0 ] * h <NEWLINE> wnm = [ 0 ] * w <NEWLINE> hw = [ [ 0 ] * w for _ in range ( h ) ] <NEWLINE> for _ in range ( m ) : <NEWLINE> <INDENT> hi , wi = [ int ( x ) - 1 for x in input ( ) . split ( ) ] <NEWLINE> hnm [ hi ] += 1 <NEWLINE> wnm [ wi ] += 1 <NEWLINE> hw [ hi ] [ wi ] += 1 <NEWLINE> <NL> <DEDENT> hm_idx = [ ] <NEWLINE> hm_val = - 1 <NEWLINE> for i in hnm : <NEWLINE> <INDENT> if hnm [ i ] > hm_val : <NEWLINE> <INDENT> hm_idx = [ i ] <NEWLINE> hm_val = hnm [ i ] <NEWLINE> <DEDENT> elif hnm [ i ] == hm_val : <NEWLINE> <INDENT> hm_idx . append ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> mn1 = True <NEWLINE> wm_val = - 1 <NEWLINE> for i in wnm : <NEWLINE> <INDENT> if wnm [ i ] > wm_val : <NEWLINE> <INDENT> wm_val = wnm [ i ] <NEWLINE> mn1 = True <NEWLINE> for j in hm_idx : <NEWLINE> <INDENT> if hw [ j ] [ i ] == 0 : <NEWLINE> <INDENT> mn1 = False <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> elif wnm [ i ] == wm_val : <NEWLINE> <INDENT> mn1 = True <NEWLINE> for j in hm_idx : <NEWLINE> <INDENT> if hw [ j ] [ i ] == 0 : <NEWLINE> <INDENT> mn1 = False <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( hm_val + wm_val + ( - 1 if mn1 else 0 ) ) <NEWLINE>
import numpy as np <NEWLINE> H , W , M = map ( int , input ( ) . split ( ) ) <NEWLINE> hl = np . array ( [ 0 for i in range ( H + 1 ) ] ) <NEWLINE> wl = np . array ( [ 0 for i in range ( W + 1 ) ] ) <NEWLINE> ms = [ ] <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> hl [ h ] += 1 <NEWLINE> wl [ w ] += 1 <NEWLINE> ms . append ( [ h , w ] ) <NEWLINE> <DEDENT> a = max ( hl ) <NEWLINE> b = max ( wl ) <NEWLINE> hmax = [ ] <NEWLINE> wmax = [ ] <NEWLINE> s = 0 <NEWLINE> for x in ms : <NEWLINE> <INDENT> if hl [ x [ 0 ] ] == a and wl [ x [ 1 ] ] == b : <NEWLINE> <INDENT> s += 1 <NEWLINE> <DEDENT> <DEDENT> c = hl . count ( a ) <NEWLINE> d = wl . count ( b ) <NEWLINE> if s < c * d : <NEWLINE> <INDENT> print ( a + b ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( a + b - 1 ) <NEWLINE> <DEDENT>
import sys <NEWLINE> H , W , M = map ( int , sys . stdin . readline ( ) . split ( ) ) <NEWLINE> hlst = { } <NEWLINE> wlst = { } <NEWLINE> hwlst = [ ] <NEWLINE> <NL> for i in range ( M ) : <NEWLINE> <INDENT> h , w = map ( int , sys . stdin . readline ( ) . split ( ) ) <NEWLINE> hlst [ h ] += 1 <NEWLINE> wlst [ w ] += 1 <NEWLINE> hwlst . append ( [ h , w ] ) <NEWLINE> <NL> <DEDENT> h = max ( hlst ) <NEWLINE> w = max ( wlst ) <NEWLINE> hmax = [ i for i in range ( H + 1 ) if hlst [ i ] == h ] <NEWLINE> wmax = [ i for i in range ( W + 1 ) if wlst [ i ] == w ] <NEWLINE> ans = h + w - 1 <NEWLINE> <NL> <NL> for i in hmax : <NEWLINE> <INDENT> for j in wmax : <NEWLINE> <INDENT> if [ i , j ] not in hwlst : <NEWLINE> <INDENT> ans += 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> h , w , m = map ( int , input ( ) . split ( ) ) <NEWLINE> h_lst = [ [ 0 , i ] for i in range ( h ) ] <NEWLINE> w_lst = [ [ 0 , i ] for i in range ( w ) ] <NEWLINE> memo = [ ] <NEWLINE> <NL> for i in range ( m ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> h_lst [ x - 1 ] [ 0 ] += 1 <NEWLINE> w_lst [ y - 1 ] [ 0 ] += 1 <NEWLINE> memo . append ( ( x - 1 , y - 1 ) ) <NEWLINE> <NL> <DEDENT> h_lst . sort ( reverse = True ) <NEWLINE> w_lst . sort ( reverse = True ) <NEWLINE> Max_h = h_lst [ 0 ] [ 0 ] <NEWLINE> Max_w = w_lst [ 0 ] [ 0 ] <NEWLINE> h_ans = [ h_lst [ 0 ] [ 1 ] ] <NEWLINE> w_ans = [ w_lst [ 0 ] [ 1 ] ] <NEWLINE> if h != 1 : <NEWLINE> <INDENT> s = 1 <NEWLINE> while h_lst [ s ] [ 0 ] == Max_h : <NEWLINE> <INDENT> h_ans . append ( h_lst [ s ] [ 1 ] ) <NEWLINE> s += 1 <NEWLINE> <DEDENT> <DEDENT> if w != 1 : <NEWLINE> <INDENT> t = 1 <NEWLINE> while w_lst [ t ] [ 0 ] == Max_w : <NEWLINE> <INDENT> w_ans . append ( w_lst [ t ] [ 1 ] ) <NEWLINE> t += 1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> memo = set ( memo ) <NEWLINE> <NL> <COMMENT> <NL> for j in h_ans : <NEWLINE> <INDENT> for k in w_ans : <NEWLINE> <INDENT> if ( j , k ) not in memo : <NEWLINE> <INDENT> print ( Max_h + Max_w ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ( Max_h + Max_w ) - 1 ) <NEWLINE> <NL> <NL>
<COMMENT> <NL> <STRING> <NEWLINE> import os , sys <NEWLINE> p = os . path . dirname ( __file__ ) <NEWLINE> pymain = os . path . join ( p , <STRING> ) <NEWLINE> if len ( sys . argv ) == 1 : <NEWLINE> <INDENT> import subprocess <NEWLINE> if p == <STRING> : <NEWLINE> <INDENT> pymain = <STRING> + pymain <NEWLINE> <DEDENT> subprocess . call ( pymain ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> import gzip , base64 , stat <NEWLINE> gz = <STRING> <NEWLINE> bin = gzip . decompress ( base64 . b64decode ( gz ) ) <NEWLINE> with open ( pymain , <STRING> ) as f : <NEWLINE> <INDENT> f . write ( bin ) <NEWLINE> <DEDENT> os . chmod ( pymain , 0o775 ) <NEWLINE> <DEDENT>
H , W , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> HL , WL = [ 0 ] * H , [ 0 ] * W <NEWLINE> B = [ ] <NEWLINE> <NL> for _ in range ( M ) : <NEWLINE> <INDENT> h , w = map ( lambda x : int ( x ) - 1 , input ( ) . split ( ) ) <NEWLINE> B . append ( ( h , w ) ) <NEWLINE> HL [ h ] += 1 <NEWLINE> WL [ w ] += 1 <NEWLINE> <NL> <DEDENT> HM , WM = max ( HL ) , max ( WL ) <NEWLINE> K = HL . count ( HM ) * WM . count ( WL ) <NEWLINE> <NL> cnt = 0 <NEWLINE> for h , w in B : <NEWLINE> <INDENT> if HL [ h ] == HM and WL [ w ] == WM : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if K > cnt : <NEWLINE> <INDENT> print ( HM + WM ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( HM + WM - 1 ) <NEWLINE> <DEDENT>
from numba import njit <NEWLINE> <NL> @ njit <NEWLINE> def main ( ) : <NEWLINE> <INDENT> import collections <NEWLINE> <NL> H , W , M_ko = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> zahyou = [ [ 0 for i in range ( W ) ] for j in range ( H ) ] <NEWLINE> zahyou_H = [ 0 for i in range ( H ) ] <NEWLINE> zahyou_W = [ 0 for i in range ( W ) ] <NEWLINE> <NL> for i in range ( M_ko ) : <NEWLINE> <INDENT> height , width = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> zahyou [ height - 1 ] [ width - 1 ] = 1 <NEWLINE> <NL> zahyou_H [ height - 1 ] += 1 <NEWLINE> zahyou_W [ width - 1 ] += 1 <NEWLINE> <NL> <DEDENT> CTR_H = collections . Counter ( zahyou_H ) <NEWLINE> CTR_W = collections . Counter ( zahyou_W ) <NEWLINE> <NL> max_h = max ( zahyou_H ) <NEWLINE> max_w = max ( zahyou_W ) <NEWLINE> <NL> len_h = CTR_H [ max_h ] <NEWLINE> len_w = CTR_W [ max_w ] <NEWLINE> <NL> index_h = [ i for i , x in enumerate ( zahyou_H ) if x == max_h ] <NEWLINE> index_w = [ i for i , x in enumerate ( zahyou_W ) if x == max_w ] <NEWLINE> <NL> <NL> maxi = max_h + max_w <NEWLINE> FLAG = False <NEWLINE> <NL> <NL> if ( len_h == 1 and len_w == 1 ) : <NEWLINE> <INDENT> maxi -= zahyou [ index_h [ 0 ] ] [ index_w [ 0 ] ] <NEWLINE> <NL> <NL> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( len_h ) : <NEWLINE> <INDENT> for j in range ( len_w ) : <NEWLINE> <INDENT> val = zahyou [ index_h [ i ] ] [ index_w [ j ] ] <NEWLINE> <NL> if ( val == 0 ) : <NEWLINE> <INDENT> FLAG = True <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if ( not FLAG ) : <NEWLINE> <INDENT> maxi -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( maxi ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
h , w , m = map ( int , input ( ) . split ( ) ) <NEWLINE> r = [ 0 ] * max ( h , w ) <NEWLINE> c = [ 0 ] * max ( h , w ) <NEWLINE> l = [ ] <NEWLINE> <NL> for i in range ( m ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> r [ x - 1 ] += 1 <NEWLINE> c [ y - 1 ] += 1 <NEWLINE> l . append ( [ x , y ] ) <NEWLINE> <NL> <DEDENT> cm = max ( c ) <NEWLINE> rm = max ( r ) <NEWLINE> ans = cm + rm <NEWLINE> <NL> cnt = 0 <NEWLINE> <COMMENT> <NL> for i in range ( m ) : <NEWLINE> <INDENT> if r [ l [ i ] [ 0 ] - 1 ] == rm and c [ l [ i ] [ 1 ] - 1 ] == cm : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if cnt == len ( ci ) * len ( ri ) : <NEWLINE> <INDENT> print ( int ( ans ) - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( int ( ans ) ) <NEWLINE> <DEDENT>
H , W , M = map ( int , input ( ) . split ( ) ) <NEWLINE> R = [ 0 ] * H <NEWLINE> C = [ 0 ] * W <NEWLINE> <NL> L = [ ] <NEWLINE> <NL> for _ in range ( M ) : <NEWLINE> <INDENT> h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> R [ h - 1 ] += 1 <NEWLINE> C [ w - 1 ] += 1 <NEWLINE> L . append ( [ h - 1 , w - 1 ] ) <NEWLINE> <NL> <DEDENT> r = max ( R ) <NEWLINE> c = max ( C ) <NEWLINE> <NL> print ( r + c - ( R . count ( r ) * C . count ( c ) == sum ( R [ h ] + C [ w ] == r + c for h , w in L ) ) <NEWLINE>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> h , w , m = map ( int , input ( ) . split ( ) ) <NEWLINE> bomb_row = [ 0 ] * h <NEWLINE> bomb_col = [ 0 ] * w <NEWLINE> <COMMENT> <NL> bomb_pos = set ( ) <NEWLINE> <COMMENT> <NL> for _ in range ( m ) : <NEWLINE> <INDENT> r , c = [ int ( i ) - 1 for i in input ( ) . split ( ) ) ] <NEWLINE> bomb_col [ r ] += 1 <NEWLINE> bomb_row [ c ] += 1 <NEWLINE> bomb_pos . add ( ( r , c ) ) <NEWLINE> <NL> <DEDENT> bomb_row_max = max ( bomb_row ) <NEWLINE> bomb_col_max = max ( bomb_col ) <NEWLINE> <NL> row_index = [ i for i , v in enumerate ( col ) if v == bomb_col_max ] <NEWLINE> col_index = [ i for i , v in enumerate ( row ) if v == bomb_row_max ] <NEWLINE> ans = max ( col ) + max ( row ) <NEWLINE> for row in row_index : <NEWLINE> <INDENT> for col in col_index : <NEWLINE> <INDENT> if ( row , col ) not in bomb_pos : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> return <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans - 1 ) <NEWLINE> <DEDENT> main ( ) <NEWLINE>
x , y , m = map ( int , input ( ) . split ( ) ) <NEWLINE> row = { } <NEWLINE> ch = set ( ) <NEWLINE> column = { } <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> h , k = map ( int , input ( ) . split ( ) ) <NEWLINE> ch . add ( ( h , k ) ) <NEWLINE> if h in row : <NEWLINE> <INDENT> row [ h ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> row [ h ] = 1 <NEWLINE> <NL> <DEDENT> if k in column : <NEWLINE> <INDENT> column [ k ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> column [ k ] = 1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> r_max = 0 <NEWLINE> c_max = 0 <NEWLINE> <NL> for i in row : <NEWLINE> <INDENT> r_max = max ( r_max , row [ i ] ) <NEWLINE> <DEDENT> for j in column : <NEWLINE> <INDENT> c_max = max ( c_max , column [ j ] ) <NEWLINE> <NL> <DEDENT> r_inx = [ ] <NEWLINE> w_inx = [ ] <NEWLINE> <NL> for i in row : <NEWLINE> <INDENT> if row [ i ] == r_max : <NEWLINE> <INDENT> r_inx . append ( i ) <NEWLINE> <DEDENT> <DEDENT> for j in column : <NEWLINE> <INDENT> if column [ j ] == c_max : <NEWLINE> <INDENT> w_inx . append ( j ) <NEWLINE> <NL> <DEDENT> <DEDENT> flag = 0 <NEWLINE> for i in r_inx : <NEWLINE> <INDENT> for j in w_inx : <NEWLINE> <INDENT> if ( i , j ) not in ch : <NEWLINE> <INDENT> flag = 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if flag == 0 : <NEWLINE> <INDENT> print ( r_max + c_max - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( r_max + c_max ) <NEWLINE> <DEDENT> x , y , m = map ( int , input ( ) . split ( ) ) <NEWLINE> row = { } <NEWLINE> ch = set ( ) <NEWLINE> column = { } <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> h , k = map ( int , input ( ) . split ( ) ) <NEWLINE> ch . add ( ( h , k ) ) <NEWLINE> if h in row : <NEWLINE> <INDENT> row [ h ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> row [ h ] = 1 <NEWLINE> <NL> <DEDENT> if k in column : <NEWLINE> <INDENT> column [ k ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> column [ k ] = 1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> r_max = 0 <NEWLINE> c_max = 0 <NEWLINE> <NL> for i in row : <NEWLINE> <INDENT> r_max = max ( r_max , row [ i ] ) <NEWLINE> <DEDENT> for j in column : <NEWLINE> <INDENT> c_max = max ( c_max , column [ j ] ) <NEWLINE> <NL> <DEDENT> r_inx = [ ] <NEWLINE> w_inx = [ ] <NEWLINE> <NL> for i in row : <NEWLINE> <INDENT> if row [ i ] == r_max : <NEWLINE> <INDENT> r_inx . append ( i ) <NEWLINE> <DEDENT> <DEDENT> for j in column : <NEWLINE> <INDENT> if column [ j ] == c_max : <NEWLINE> <INDENT> w_inx . append ( j ) <NEWLINE> <NL> <DEDENT> <DEDENT> flag = 0 <NEWLINE>
h , w , m = map ( int , input ( ) . split ( ) ) <NEWLINE> g = [ ] <NEWLINE> e1 = [ 0 ] * h <NEWLINE> e2 = [ 0 ] * w <NEWLINE> for c in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> g . append ( [ a - 1 , b - 1 ] ) <NEWLINE> e1 [ a - 1 ] += 1 <NEWLINE> e2 [ b - 1 ] += 1 <NEWLINE> <DEDENT> p1 = max ( e1 ) <NEWLINE> p2 = max ( e2 ) <NEWLINE> x = [ 1 if e1 [ c ] == p1 else 0 for c in range ( h ) ] <NEWLINE> y = [ 1 if e2 [ c ] == p2 else 0 for c in range ( w ) ] <NEWLINE> r = sum ( x ) * sum ( y ) <NEWLINE> for i in g : <NEWLINE> <INDENT> if x [ i [ 0 ] ] == 1 and y [ i [ 1 ] ] == 1 : <NEWLINE> <INDENT> r -= 1 <NEWLINE> <DEDENT> <DEDENT> if r == 0 : <NEWLINE> <INDENT> print ( p + q - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( p + q ) <NEWLINE> <DEDENT>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> def main ( ) <NEWLINE> <INDENT> h , w , m = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> h_array = [ 0 for _ in range ( h ) ] <NEWLINE> w_array = [ 0 for _ in range ( w ) ] <NEWLINE> ps = set ( ) <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> hi , wi = map ( lambda x : int ( x ) - 1 , input ( ) . split ( ) ) <NEWLINE> h_array [ hi ] += 1 <NEWLINE> w_array [ wi ] += 1 <NEWLINE> ps . add ( ( hi , wi ) ) <NEWLINE> <NL> <DEDENT> h_great = max ( h_array ) <NEWLINE> w_great = max ( w_array ) <NEWLINE> h_greats = list ( ) <NEWLINE> w_greats = list ( ) <NEWLINE> for i , hi in enumerate ( h_array ) : <NEWLINE> <INDENT> if hi == h_great : <NEWLINE> <INDENT> h_greats . append ( i ) <NEWLINE> <DEDENT> <DEDENT> for i , wi in enumerate ( w_array ) : <NEWLINE> <INDENT> if wi == w_great : <NEWLINE> <INDENT> w_greats . append ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> ans = h_great + w_great <NEWLINE> <NL> <NL> for _h in h_greats : <NEWLINE> <INDENT> for _w in w_greats : <NEWLINE> <INDENT> if ( _h , _w ) in ps : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans - 1 ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
h , w , m = map ( int , input ( ) . split ( ) ) <NEWLINE> target_points = { tuple ( map ( lambda x : int ( x ) - 1 , input ( ) . split ( ) ) ) for _ in range ( m ) } <NEWLINE> <NL> row_points = [ 0 ] * h <NEWLINE> col_points = [ 0 ] * w <NEWLINE> for row , col in target_points : <NEWLINE> <INDENT> row_points [ row ] += 1 <NEWLINE> col_points [ col ] += 1 <NEWLINE> <NL> <DEDENT> row_max = max ( row_points ) <NEWLINE> col_max = max ( col_points ) <NEWLINE> <NL> row_max_indexes = [ i for i in range ( h ) if row_points [ i ] == row_max ] <NEWLINE> col_max_indexes = [ i for i in range ( w ) if col_points [ i ] == col_max ] <NEWLINE> crossing_filled = 0 <NEWLINE> if len ( row_max_indexes ) * len ( col_max_indexes ) <= m : <NEWLINE> <INDENT> if all ( [ ( row , col ) in target_points for row in row_max_indexes for col in col_max_indexes ] ) <NEWLINE> <NL> <DEDENT> print ( row_max + col_max - crossing_filled ) <NEWLINE>
H , W , M = map ( int , input ( ) . split ( ) ) <NEWLINE> sumh = [ 0 ] * H <NEWLINE> sumw = [ 0 ] * W <NEWLINE> bomb = [ ] <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> sumh [ h - 1 ] += 1 <NEWLINE> sumw [ w - 1 ] += 1 <NEWLINE> bomb . append ( ( h , w ) ) <NEWLINE> <NL> <DEDENT> maxh = max ( sumh ) <NEWLINE> maxw = max ( sumw ) <NEWLINE> <NL> cnt = 0 <NEWLINE> for h , w in bomb : <NEWLINE> <INDENT> if sumh [ h - 1 ] == maxh and sumw [ w - 1 ] == maxw : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if cnt == len ( qh ) * len ( qw ) : <NEWLINE> <INDENT> print ( maxh + maxw - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( maxh + maxw ) <NEWLINE> <DEDENT>
import bisect <NEWLINE> <NL> <NL> h , w , m = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> count_h = [ 0 for i in range ( h ) ] <NEWLINE> count_w = [ 0 for i in range ( w ) ] <NEWLINE> points = set ( ) <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> y , x = map ( int , input ( ) . split ( ) ) <NEWLINE> y -= 1 <NEWLINE> x -= 1 <NEWLINE> points . add ( ( y , x ) ) <NEWLINE> count_h [ y ] += 1 <NEWLINE> count_w [ x ] += 1 <NEWLINE> <NL> <DEDENT> ch_max , cw_max = max ( count_h ) , max ( count_w ) <NEWLINE> ys = [ y for y in range ( len ( count_h ) ) if count_h [ y ] == ch_max ] <NEWLINE> xs = [ x for x in range ( len ( count_w ) ) if count_w [ x ] == cw_max ] <NEWLINE> <NL> ans = ch_max + cw_max <NEWLINE> for ( y , x ) in points : <NEWLINE> <INDENT> index = bisect . bisect_left ( ys , y ) <NEWLINE> if ys [ index ] == y and xs [ index ] == x : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL>
h , w , m = map ( int , input ( ) . split ( ) ) <NEWLINE> hw = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( m ) ] <NEWLINE> bomb = set ( ) <NEWLINE> h_list = [ 0 ] * ( h + 1 ) <NEWLINE> w_list = [ 0 ] * ( w + 1 ) <NEWLINE> for H , W in hw : <NEWLINE> <INDENT> h_list [ H ] += 1 <NEWLINE> w_list [ W ] += 1 <NEWLINE> bomb . add ( ( H , W ) ) <NEWLINE> <DEDENT> max_h = max ( h_list ) <NEWLINE> max_w = max ( w_list ) <NEWLINE> maxh_list = [ ] <NEWLINE> maxw_list = [ ] <NEWLINE> for k , v in enumerate ( h_list ) : <NEWLINE> <INDENT> if v == max_h : <NEWLINE> <INDENT> maxh_list . append ( k ) <NEWLINE> <DEDENT> <DEDENT> for k , v in enumerate ( w_list ) : <NEWLINE> <INDENT> if v == max_w : <NEWLINE> <INDENT> maxw_list . append ( k ) <NEWLINE> <DEDENT> <DEDENT> if len ( maxh_list ) * len ( maxv_list ) > m : <NEWLINE> <INDENT> ans = max_h * max_w <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = max_h * max_w - 1 <NEWLINE> for i in maxh_list : <NEWLINE> <INDENT> for j in maxw_list : <NEWLINE> <INDENT> if ( i , j ) not in bomb : <NEWLINE> <INDENT> ans = max_h * max_w <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import numpy as np <NEWLINE> import numba <NEWLINE> from numba import njit , b1 , i4 , i8 , f8 <NEWLINE> @ njit ( ( i8 [ : ] , i8 [ : ] , i8 [ : ] , i8 [ : ] ) , cache = True ) <NEWLINE> def main ( lis_h , lis_w , bomb_h , bomb_w ) : <NEWLINE> <INDENT> bomb = { } <NEWLINE> for h , w in zip ( bomb_h , bomb_w ) : <NEWLINE> <INDENT> bomb [ ( h , w ) ] = 1 <NEWLINE> <DEDENT> max_h = np . where ( lis_h == lis_h . max ( ) ) <NEWLINE> max_w = np . where ( lis_w == lis_w . max ( ) ) <NEWLINE> ans = lis_h . max ( ) + lis_w . max ( ) <NEWLINE> for h in max_h : <NEWLINE> <INDENT> for w in max_w : <NEWLINE> <INDENT> if ( h , w ) not in bomb : <NEWLINE> <INDENT> return ans <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return ans - 1 <NEWLINE> <NL> <DEDENT> H , W , M = map ( int , input ( ) . split ( ) ) <NEWLINE> bombh = np . zeros ( M , np . int64 ) <NEWLINE> bombw = np . zeros ( M , np . int64 ) <NEWLINE> lis_h = np . zeros ( H , np . int64 ) <NEWLINE> lis_w = np . zeros ( W , np . int64 ) <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> h -= 1 <NEWLINE> w -= 1 <NEWLINE> bombh [ i ] , bombw [ i ] = h , w <NEWLINE> lis_h [ h ] += 1 <NEWLINE> lis_w [ w ] += 1 <NEWLINE> <DEDENT> print ( main ( lis_h , lis_w , bombh , bombw ) ) <NEWLINE>
import sys <NEWLINE> import numpy as np <NEWLINE> import numba <NEWLINE> from numba import njit , b1 , i4 , i8 , f8 <NEWLINE> <NL> read = sys . stdin . buffer . read <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> readlines = sys . stdin . buffer . readlines <NEWLINE> <NL> @ njit ( ( i8 , i8 , i8 [ : ] ) , cache = True ) <NEWLINE> def main ( H , W , XY ) : <NEWLINE> <INDENT> A = np . zeros ( ( H , W ) , np . int64 ) <NEWLINE> row = np . zeros ( H , np . int64 ) <NEWLINE> col = np . zeros ( W , np . int64 ) <NEWLINE> for i in range ( 0 , len ( XY ) , 2 ) : <NEWLINE> <INDENT> x , y = XY [ i : i + 2 ] - 1 <NEWLINE> row [ x ] += 1 <NEWLINE> col [ y ] += 1 <NEWLINE> A [ x , y ] += 1 <NEWLINE> <DEDENT> ans = 0 <NEWLINE> for h in range ( H ) : <NEWLINE> <INDENT> for w in range ( W ) : <NEWLINE> <INDENT> x = row [ h ] + col [ w ] - A [ h , w ] <NEWLINE> ans = max ( ans , x ) <NEWLINE> <DEDENT> <DEDENT> return ans <NEWLINE> <NL> <DEDENT> H , W , M = map ( int , readline ( ) . split ( ) ) <NEWLINE> XY = np . array ( read ( ) . split ( ) , np . int64 ) <NEWLINE> <NL> print ( main ( H , W , XY ) ) <NEWLINE>
S = input ( ) <NEWLINE> if S == <STRING> : <NEWLINE> <INDENT> renzoku = 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for si in S : <NEWLINE> <INDENT> if si == <STRING> : <NEWLINE> <INDENT> renzoku += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( renzoku ) <NEWLINE>
s = input ( ) <NEWLINE> <NL> if s in <STRING> : <NEWLINE> <INDENT> ans = 1 <NEWLINE> <DEDENT> if s in <STRING> : <NEWLINE> <INDENT> ans = 2 <NEWLINE> <DEDENT> if s in <STRING> : <NEWLINE> <INDENT> ans = 3 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
ss = str ( input ( ) ) <NEWLINE> a = ss . count ( <STRING> ) <NEWLINE> <NL> if ss = <STRING> : <NEWLINE> <INDENT> a = 1 <NEWLINE> <NL> <DEDENT> print ( a ) <NEWLINE>
S = input ( ) <NEWLINE> <NL> a = RSS <NEWLINE> b = RRS <NEWLINE> c = RRR <NEWLINE> d = SSS <NEWLINE> <NL> if a in S : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <NL> <DEDENT> elif b in S : <NEWLINE> <INDENT> print ( 2 ) <NEWLINE> <NL> <DEDENT> elif c = S : <NEWLINE> <INDENT> print ( 3 ) <NEWLINE> <NL> <DEDENT> elif d = S : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> sum_ = 0 <NEWLINE> if s [ 0 ] == <STRING> : <NEWLINE> <INDENT> sum_ += 1 <NEWLINE> if s [ 1 ] == <STRING> : <NEWLINE> <INDENT> sum_ += 1 <NEWLINE> if s [ 2 ] == <STRING> : <NEWLINE> <INDENT> sum_ += 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> sum_ = 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if s [ 1 ] == <STRING> : <NEWLINE> <INDENT> sum_ += 1 <NEWLINE> if s [ 2 ] == <STRING> : <NEWLINE> <INDENT> sum_ += 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> s [ 2 ] == <STRING> : <NEWLINE> <INDENT> sum_ = 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( sum_ ) <NEWLINE>
S = raw_input ( ) <NEWLINE> print ( max ( map ( len , S . split ( <STRING> ) ) ) ) <NEWLINE>
A = input ( ) . split ( ) <NEWLINE> count = 0 <NEWLINE> for a in range ( 3 ) : <NEWLINE> <INDENT> if A [ a ] == <STRING> : <NEWLINE> <INDENT> count + + <NEWLINE> <NL> <DEDENT> <DEDENT> if count == 2 A [ 1 ] == <STRING> : <NEWLINE> <INDENT> count = 1 <NEWLINE> <DEDENT> print ( count ) <NEWLINE>
s = input ( ) <NEWLINE> if s == <STRING> : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else if s == <STRING> or s == <STRING> : <NEWLINE> <INDENT> print ( 2 ) <NEWLINE> <DEDENT> else if s == <STRING> : <NEWLINE> <INDENT> print ( 3 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT>
a = input ( ) <NEWLINE> b = 0 <NEWLINE> <NL> for i in a : <NEWLINE> <INDENT> if i == R : <NEWLINE> <INDENT> b += 1 <NEWLINE> if b == 2 : <NEWLINE> <INDENT> print ( b ) <NEWLINE> import sys <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> if i == S and b > 0 : <NEWLINE> <INDENT> b -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( b ) <NEWLINE>
a = s . count ( <STRING> ) <NEWLINE> if a == 0 : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <DEDENT> elif s [ 1 ] == <STRING> : <NEWLINE> <INDENT> print ( a - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <DEDENT>
D , T , S = map ( int , input ( ) . split ( ) ) <NEWLINE> if S * T >= D : print ( <STRING> ) <NEWLINE> else : print ( <STRING> ) <NEWLINE>
s = input ( ) <NEWLINE> if ( s = <STRING> ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif ( s = <STRING> ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif ( s = <STRING> ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif ( s = <STRING> ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif ( s = <STRING> ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif ( s = <STRING> ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif ( s = <STRING> ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
<COMMENT> <NL> S = input ( <STRING> ) <NEWLINE> if ( S == sss ) : <NEWLINE> <INDENT> print ( 3 ) <NEWLINE> <DEDENT> elif ( S == ssr ) : <NEWLINE> <INDENT> print ( 2 ) <NEWLINE> <DEDENT> elif ( S == srs ) : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> elif ( S == rss ) : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> elif ( S == srr ) : <NEWLINE> <INDENT> print ( 2 ) <NEWLINE> <DEDENT> elif ( S == rsr ) : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> elif ( S == rrs ) : <NEWLINE> <INDENT> print ( 2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT>
if l == <STRING> : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <NL> <DEDENT> elif l == <STRING> or l == <STRING> or l == <STRING> or l == <STRING> : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <NL> <DEDENT> elif l == <STRING> or l == <STRING> : <NEWLINE> <INDENT> print ( 2 ) <NEWLINE> <NL> <DEDENT> elif l == <STRING> : <NEWLINE> <INDENT> print ( 3 ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> if s [ 0 ] == <STRING> : <NEWLINE> <INDENT> if s [ 1 ] == <STRING> : <NEWLINE> <INDENT> if s [ 2 ] == <STRING> : <NEWLINE> <INDENT> print ( 3 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 2 ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> <DEDENT> elif s [ 0 ] == <STRING> : <NEWLINE> <INDENT> if s [ 1 ] == <STRING> : <NEWLINE> <INDENT> if s [ 2 ] == <STRING> : <NEWLINE> <INDENT> print ( 2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> <DEDENT> elif : <NEWLINE> <INDENT> if s [ 2 ] == <STRING> : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
x = max ( map ( len , input ( ) . split ( S ) ) ) <NEWLINE> print ( x ) <NEWLINE>
S = input ( ) <NEWLINE> count = 0 <NEWLINE> if S == <STRING> : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in S : <NEWLINE> <INDENT> if i == <STRING> : <NEWLINE> <INDENT> cout += 1 <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> ans = 0 <NEWLINE> if <STRING> in s : <NEWLINE> <INDENT> ans = 3 <NEWLINE> <DEDENT> elif : <STRING> in s : <NEWLINE> <INDENT> ans = 2 <NEWLINE> <DEDENT> elif : <STRING> in s : <NEWLINE> <INDENT> ans = 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
res , prev , count = 0 , <STRING> , 0 <NEWLINE> for s in S : <NEWLINE> <INDENT> if s == <STRING> : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> res = max ( res , count ) <NEWLINE> count = 0 <NEWLINE> <DEDENT> <DEDENT> res = max ( res , count ) <NEWLINE> return res <NEWLINE>
a = input ( ) <NEWLINE> if s == <STRING> : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> elif s == <STRING> : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> elif s == <STRING> : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> elif s == <STRING> : <NEWLINE> <INDENT> print ( 2 ) <NEWLINE> <DEDENT> elif s == <STRING> : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> elif s == <STRING> : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> elif s == <STRING> : <NEWLINE> <INDENT> print ( 2 ) <NEWLINE> <DEDENT> elif s == <STRING> : <NEWLINE> <INDENT> print ( 3 ) <NEWLINE> <NL> <DEDENT>
code = input ( ) <NEWLINE> <NL> if code == SSS : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> elif code == SSR or SRS or RSS or RSR : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> elif code == SRR or RRS : <NEWLINE> <INDENT> print ( 2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 3 ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> count = 0 <NEWLINE> for i in range ( 3 ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> count + + <NEWLINE> <DEDENT> <DEDENT> if count <= 1 | | count == 3 : <NEWLINE> <INDENT> print ( count ) <NEWLINE> <DEDENT> elif s [ 1 ] != <STRING> : <NEWLINE> <INDENT> print ( count - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( count ) <NEWLINE> <DEDENT>
S = str ( input ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> if S == <STRING> : <NEWLINE> <INDENT> ans = 0 <NEWLINE> break <NEWLINE> <DEDENT> elif S == <STRING> or S == <STRING> or S = <STRING> : <NEWLINE> <INDENT> ans = 1 <NEWLINE> break <NEWLINE> <DEDENT> elif S == <STRING> or S == <STRING> : <NEWLINE> <INDENT> ans = 2 <NEWLINE> break <NEWLINE> <DEDENT> elif S == <STRING> : <NEWLINE> <INDENT> ans = 3 <NEWLINE> break <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
S = input ( ) <NEWLINE> res = 0 <NEWLINE> <NL> if s [ 0 ] == s [ 1 ] : <NEWLINE> <INDENT> res += 1 <NEWLINE> <DEDENT> if s [ 1 ] == s [ 2 ] : <NEWLINE> <INDENT> res += 1 <NEWLINE> <NL> <DEDENT> print ( res ) <NEWLINE>
s = input ( ) <NEWLINE> <NL> if s == <STRING> : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> elif s == <STRING> or s == <STRING> or s == <STRING> : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> elif s == <STRING> : <NEWLINE> <INDENT> print ( 3 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 2 ) <NEWLINE> <DEDENT> s = input ( ) <NEWLINE> <NL> if s == <STRING> : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> elif s == <STRING> or s == <STRING> : <NEWLINE> <INDENT> print ( 2 ) <NEWLINE> <DEDENT> elif s == <STRING> : <NEWLINE> <INDENT> print ( 3 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT>
S = input ( ) <NEWLINE> c = 0 <NEWLINE> ans = 0 <NEWLINE> for i in range ( 3 ) : <NEWLINE> <INDENT> if S [ i ] == <STRING> : <NEWLINE> <INDENT> c + + <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = max ( c , ans ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
s = I ( ) . strip ( ) <NEWLINE> arr = s . split ( <STRING> ) <NEWLINE> ans = 0 <NEWLINE> for i in arr : <NEWLINE> <INDENT> ans = max ( ans , len ( i ) ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
Word = input ( ) <NEWLINE> Word_list = list ( Word ) <NEWLINE> <NL> number = 0 <NEWLINE> renzoku = 0 <NEWLINE> <NL> for num in range ( 3 ) : <NEWLINE> <INDENT> if Word_list [ num ] = <STRING> : <NEWLINE> <INDENT> number = number + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if ( number > renzoku ) : <NEWLINE> <INDENT> renzoku = number <NEWLINE> <DEDENT> number = 0 <NEWLINE> <DEDENT> <DEDENT>
inn = input ( ) <NEWLINE> numS = 0 <NEWLINE> for c in inn : <NEWLINE> <INDENT> if c == <STRING> : <NEWLINE> <INDENT> numS += 1 <NEWLINE> <DEDENT> <DEDENT> if numR != 2 : <NEWLINE> <INDENT> print ( numR ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 1 if inn [ 1 ] == <STRING> else 2 ) <NEWLINE> <DEDENT>
a = input ( ) <NEWLINE> count = 0 <NEWLINE> <NL> for i in range ( len ( a ) ) : <NEWLINE> <INDENT> if i = <STRING> : <NEWLINE> <INDENT> count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
def A ( S ) : <NEWLINE> <INDENT> answer = 0 <NEWLINE> <NL> if S [ 1 ] == <STRING> : <NEWLINE> <INDENT> answer += 1 <NEWLINE> if S [ 0 ] == <STRING> : <NEWLINE> <INDENT> answer += 1 <NEWLINE> <DEDENT> if S [ 2 ] == <STRING> : <NEWLINE> <INDENT> answer += 1 <NEWLINE> <DEDENT> <DEDENT> elif S [ 0 ] == <STRING> or S [ 2 ] == <STRING> : <NEWLINE> <INDENT> answer = 1 <NEWLINE> <NL> <DEDENT> return answer <NEWLINE> <NL> <NL> print ( A ( input ( ) ) ) <NEWLINE> <DEDENT>
w = str ( input ( ) ) <NEWLINE> if w == RRR : <NEWLINE> <INDENT> print ( 3 ) <NEWLINE> <DEDENT> elif w == SRR : <NEWLINE> <INDENT> print ( 2 ) <NEWLINE> <DEDENT> elif w == RRS : <NEWLINE> <INDENT> print ( 2 ) <NEWLINE> <DEDENT> elif w == RSR : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> elif w == RSS : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> elif w == SRS : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> elif w == SSR : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT>
vi = 0 <NEWLINE> j = 0 <NEWLINE> for s in input ( ) : <NEWLINE> <INDENT> j += 1 <NEWLINE> <NL> if s == <STRING> : <NEWLINE> <INDENT> i += 1 <NEWLINE> <DEDENT> if j != 3 and i > 0 and s == <STRING> : <NEWLINE> <INDENT> i -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( i ) <NEWLINE>
s = input ( ) <NEWLINE> if s == = <STRING> : <NEWLINE> <INDENT> print ( 3 ) <NEWLINE> <DEDENT> elif s [ : 2 ] == <STRING> or s [ 1 : ] == <STRING> : <NEWLINE> <INDENT> print ( 2 ) <NEWLINE> <DEDENT> elif s . count ( <STRING> ) >= 1 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT>
a = input ( ) <NEWLINE> sum = 0 <NEWLINE> for i in a : <NEWLINE> <INDENT> if i == <STRING> <NEWLINE> sum = sum + 1 <NEWLINE> <DEDENT> print ( sum ) <NEWLINE>
l = input ( ) <NEWLINE> if l = <STRING> : <NEWLINE> <INDENT> print ( 3 ) <NEWLINE> <DEDENT> elif l = <STRING> or <STRING> : <NEWLINE> <INDENT> print ( 2 ) <NEWLINE> <DEDENT> elif l = <STRING> : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <NL> <DEDENT>
word = input ( ) : <NEWLINE> if word == <STRING> : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> if word == <STRING> : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> if word == <STRING> : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> if word == <STRING> : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> if word == <STRING> : <NEWLINE> <INDENT> print ( 2 ) <NEWLINE> <DEDENT> if word == <STRING> : <NEWLINE> <INDENT> print ( 2 ) <NEWLINE> <DEDENT> if word == <STRING> : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> if word == <STRING> : <NEWLINE> <INDENT> print ( 3 ) <NEWLINE> <DEDENT>
a = input ( ) <NEWLINE> total = 0 <NEWLINE> for i in a [ range ( 1 , 4 ) ] : <NEWLINE> <INDENT> if i = <STRING> : <NEWLINE> <INDENT> total += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> total = 0 <NEWLINE> <DEDENT> <DEDENT>
S = input ( ) <NEWLINE> ans = 0 <NEWLINE> tmp = 0 <NEWLINE> for s in S : <NEWLINE> <INDENT> if s = <STRING> : <NEWLINE> <INDENT> tmp += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = max ( ans , tmp ) <NEWLINE> tmp = 0 <NEWLINE> <DEDENT> <DEDENT> print ( max ( ans , tmp ) ) <NEWLINE>
st = input ( ) <NEWLINE> if st [ 0 ] == st [ 1 ] and st [ 0 ] == st [ 2 ] and st [ 0 ] == <STRING> : <NEWLINE> <INDENT> print ( 3 ) <NEWLINE> <DEDENT> elif ( st [ 0 ] == st [ 1 ] == <STRING> ) OR ( st [ 1 ] == st [ 2 ] == <STRING> ) : <NEWLINE> <INDENT> print ( 2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT>
a = input ( ) <NEWLINE> if a == <STRING> : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> elif a = <STRING> : <NEWLINE> <INDENT> print ( 3 ) <NEWLINE> <DEDENT> elif a = <STRING> or a = <STRING> : <NEWLINE> <INDENT> print ( 2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT>
S = input ( ) <NEWLINE> if S = <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif S = <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif S = <STRING> or S = <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
S = input ( ) <NEWLINE> <NL> if S . count ( <STRING> ) == 2 and S [ 1 ] != R : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> print ( S . count ( <STRING> ) ) <NEWLINE> <DEDENT>
s = map ( input ( ) . split ( ) ) <NEWLINE> ans = 0 <NEWLINE> <NL> for i in range ( 3 ) : <NEWLINE> <INDENT> p = <STRING> * i <NEWLINE> if p in s : <NEWLINE> <INDENT> ans = i <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
W = input ( ) <NEWLINE> ans = 0 <NEWLINE> count = 0 <NEWLINE> for i in range ( len ( W ) ) : <NEWLINE> <INDENT> if W [ i ] == R : <NEWLINE> <INDENT> count += 1 <NEWLINE> ans = max ( ans , count ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> count = 0 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
s = input ( ) <NEWLINE> count = 0 <NEWLINE> if <STRING> in s : <NEWLINE> <INDENT> print ( 3 ) <NEWLINE> <DEDENT> elif <STRING> in s : <NEWLINE> <INDENT> print ( 2 ) <NEWLINE> <DEDENT> elif <STRING> in s or <STRING> in s or <STRING> in sor <STRING> in s : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT>
n = input ( ) <NEWLINE> <INDENT> if n == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif n [ : 2 ] == <STRING> or n [ 1 : ] == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif n == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
MOD = 1000000007 <NEWLINE> from collections import defaultdict as dd , Counter , deque <NEWLINE> <NL> def si ( ) : return input ( ) <NEWLINE> def ii ( ) : return int ( input ( ) ) <NEWLINE> def li ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> def mi ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def out ( v ) : print ( v ) <NEWLINE> def spout ( ) : print ( v , end = <STRING> ) <NEWLINE> def d2b ( n ) : return bin ( n ) . replace ( <STRING> , <STRING> ) <NEWLINE> def twod ( n , m , num ) : return [ [ num for x in range ( m ) ] for y in range ( n ) ] <NEWLINE> def vow ( ) : return [ <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> def let ( ) : return [ chr ( i ) for i in range ( 97 , 123 ) ] <NEWLINE> def gcd ( x , y ) : <NEWLINE> <INDENT> while y : <NEWLINE> <INDENT> x , y = y , x % y <NEWLINE> <DEDENT> return x <NEWLINE> <DEDENT> def ispow2 ( x ) : <NEWLINE> <INDENT> return ( x and ( not ( x & ( x - 1 ) ) ) ) <NEWLINE> <DEDENT> def prime_factors ( n ) : <NEWLINE> <INDENT> i = 2 <NEWLINE> factors = [ ] <NEWLINE> while i * i <= n : <NEWLINE> <INDENT> if n % i : i += 1 <NEWLINE> else : <NEWLINE> <INDENT> n //= i <NEWLINE> factors . append ( i ) <NEWLINE> <DEDENT> <DEDENT> if n > 1 : factors . append ( n ) <NEWLINE> return ( list ( factors ) ) <NEWLINE> <NL> <DEDENT> s = si ( ) <NEWLINE> for i in range ( 3 ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> c += 1 <NEWLINE> <DEDENT> <DEDENT> if c < 2 or c == 3 : print ( c ) <NEWLINE> else : <NEWLINE> <INDENT> if s [ 1 ] == <STRING> : print ( 2 ) <NEWLINE> else : print ( 1 ) <NEWLINE> <DEDENT>
D = list ( input ( ) . strip ( ) . split ( ) ) <NEWLINE> ans = 0 <NEWLINE> ans_list = [ ] <NEWLINE> if D . count ( <STRING> ) >= 1 : <NEWLINE> <INDENT> for i in range ( 3 ) : <NEWLINE> <INDENT> if D [ i ] == <STRING> : <NEWLINE> <INDENT> ans += 1 <NEWLINE> ans_list . append ( ans ) <NEWLINE> <DEDENT> elif D [ i ] == <STRING> : <NEWLINE> <INDENT> ans_list . append ( ans ) <NEWLINE> <DEDENT> <DEDENT> ans_list . sort ( ) <NEWLINE> <DEDENT> print ( ans_list [ - 1 ] ) <NEWLINE> elif D . count ( <STRING> ) < 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT>
S = input ( ) <NEWLINE> count = 0 <NEWLINE> if S [ 0 ] == <STRING> : <NEWLINE> <INDENT> if S [ 1 ] == <STRING> : <NEWLINE> <INDENT> if S [ 2 ] == <STRING> : <NEWLINE> <INDENT> print ( 3 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 2 ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if S [ 2 ] == <STRING> : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if S [ 1 ] == <STRING> : <NEWLINE> <INDENT> if S [ 2 ] == <STRING> : <NEWLINE> <INDENT> print ( 2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if S [ 2 ] == <STRING> : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
s = input ( ) <NEWLINE> r = 3 if s == <STRING> else r = 1 <NEWLINE> if <STRING> in s : <NEWLINE> <INDENT> r = 2 <NEWLINE> <DEDENT> print ( r ) <NEWLINE>
S = input ( ) <NEWLINE> max = 0 <NEWLINE> i = 0 <NEWLINE> m = 0 <NEWLINE> while ( i != len ( S ) ) : <NEWLINE> <INDENT> if S [ i ] == <STRING> : <NEWLINE> <INDENT> m += 1 <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> max = max ( max , m ) <NEWLINE> m = 0 <NEWLINE> break <NEWLINE> <DEDENT> i += 1 <NEWLINE> <NL> <DEDENT> print ( max ) <NEWLINE>
N , X , T = map ( int , input ( ) . split ( ) ) <NEWLINE> y = N // X <NEWLINE> c = N % X <NEWLINE> print ( ( y * T + T ) if c else ( y * T ) ) <NEWLINE>
days = input ( ) <NEWLINE> if days . contains ( <STRING> ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif days . contains ( <STRING> ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif days . contains ( <STRING> ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
S = input ( ) <NEWLINE> li = list ( S ) <NEWLINE> count = 0 <NEWLINE> re_num = 0 <NEWLINE> for num in range ( 2 ) : <NEWLINE> <INDENT> if li [ num ] = <STRING> : <NEWLINE> <INDENT> count = count + 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if count = 0 : <NEWLINE> <INDENT> re_num = 0 <NEWLINE> <DEDENT> elif count = 1 : <NEWLINE> <INDENT> re_num = 1 <NEWLINE> <DEDENT> elif count = 2 and li [ 2 ] = <STRING> : <NEWLINE> <INDENT> re_num = 1 <NEWLINE> <DEDENT> elif count = 2 and li [ 2 ] = <STRING> : <NEWLINE> <INDENT> re_num = 2 <NEWLINE> <DEDENT> else re_num = 3 <NEWLINE> <NL> print ( re_num ) <NEWLINE>
s = input ( ) <NEWLINE> count = 0 <NEWLINE> flag = True <NEWLINE> if s [ 0 ] == <STRING> and s [ 1 ] == <STRING> and s [ 2 ] == <STRING> : <NEWLINE> <INDENT> print ( 3 ) <NEWLINE> <DEDENT> elif ( s [ 0 ] == <STRING> and s [ 1 ] == <STRING> ) or ( s [ 0 ] == <STRING> and s [ 2 ] == <STRING> ) <NEWLINE> or ( s [ 1 ] == <STRING> and s [ 2 ] == <STRING> ) : <NEWLINE> <INDENT> print ( 2 ) <NEWLINE> <DEDENT> elif s [ 0 ] == <STRING> or s [ 1 ] == <STRING> or s [ 2 ] == <STRING> : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT>
weat = input ( ) <NEWLINE> seaS = <STRING> <NEWLINE> seaR = <STRING> <NEWLINE> a = 0 <NEWLINE> b = 0 <NEWLINE> c = 0 <NEWLINE> imput = 0 <NEWLINE> for alp in wea : <NEWLINE> <INDENT> if a == 0 : <NEWLINE> <INDENT> if alp == seaS : <NEWLINE> <INDENT> a = 1 <NEWLINE> <DEDENT> if alp == seaR : <NEWLINE> <INDENT> a = 2 <NEWLINE> <DEDENT> <DEDENT> if b == 0 and a != 0 : <NEWLINE> <INDENT> if alp == seaS : <NEWLINE> <INDENT> b = 1 <NEWLINE> <DEDENT> if alp == seaR : <NEWLINE> <INDENT> b = 2 <NEWLINE> <DEDENT> <DEDENT> if c == 0 and a != 0 and b != 0 : <NEWLINE> <INDENT> if alp == seaS : <NEWLINE> <INDENT> c = 1 <NEWLINE> <DEDENT> if alp == seaR : <NEWLINE> <INDENT> c = 2 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if a or b or c == 2 : <NEWLINE> <INDENT> imput = 1 <NEWLINE> <DEDENT> if a and b == 2 or b and c == 2 : <NEWLINE> <INDENT> imput = 2 <NEWLINE> <DEDENT> if a and b and c == 3 : <NEWLINE> <INDENT> imput = 3 <NEWLINE> <NL> <DEDENT> print ( imput ) <NEWLINE>
r = 0 <NEWLINE> if <STRING> not in s : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> and i != len ( s ) - 1 : <NEWLINE> <INDENT> for j in range ( i + 1 , len ( s ) ) : <NEWLINE> <INDENT> if s [ j ] != <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> r = j - i <NEWLINE> <DEDENT> <DEDENT> print ( r ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> def read_input ( ) : <NEWLINE> <INDENT> return sys . stdin . readline ( ) . strip ( ) . split ( <STRING> ) <NEWLINE> <NL> <DEDENT> def task ( s ) : <NEWLINE> <INDENT> rainy_til = [ ] <NEWLINE> l = len ( s ) <NEWLINE> i = 0 <NEWLINE> while i < l : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> last_rainy = rainy_til [ i - 1 ] if i > 0 else 0 <NEWLINE> rainy_til [ i ] = last_rainy + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> rainy_til [ i ] = 0 <NEWLINE> <DEDENT> <DEDENT> return max ( rainy_til ) <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> s = read_input ( ) <NEWLINE> result = task ( s ) <NEWLINE> print ( result ) <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE>
weather = input ( ) <NEWLINE> <NL> elif weather in [ <STRING> ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif weather in [ <STRING> , <STRING> ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif weather in [ <STRING> , <STRING> , <STRING> , <STRING> ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s = input ( ) . split ( ) <NEWLINE> if s [ 0 ] == R and s [ 1 ] == R and s [ 2 ] == R <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif s [ 0 ] == S and s [ 1 ] == S and s [ 2 ] == S <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif s [ 0 ] == R and s [ 1 ] == R and s [ 2 ] == S <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif s [ 0 ] == S and s [ 1 ] == R and s [ 2 ] == R <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
S = input ( ) <NEWLINE> ans = 0 <NEWLINE> temp = 0 <NEWLINE> for i in range ( 3 ) : <NEWLINE> <INDENT> if S [ i ] == <STRING> : <NEWLINE> <INDENT> temp += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = temp <NEWLINE> temp = 0 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> S = input ( ) <NEWLINE> ans = 0 <NEWLINE> temp = 0 <NEWLINE> for i in range ( 3 ) : <NEWLINE> <INDENT> if S [ i ] == <STRING> : <NEWLINE> <INDENT> temp += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = temp <NEWLINE> temp = 0 <NEWLINE> <DEDENT> <DEDENT> if ans < temp : <NEWLINE> <INDENT> ans = temp <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
S = input ( ) <NEWLINE> if S == <STRING> : <NEWLINE> <INDENT> print ( 2 ) <NEWLINE> <DEDENT> elif S == <STRING> <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> elif S = <STRING> <NEWLINE> <INDENT> print ( 2 ) <NEWLINE> <DEDENT> elif S = <STRING> <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <NL> <DEDENT>
Q = input ( ) <NEWLINE> if Q . count ( R ) == 3 : <NEWLINE> <INDENT> print ( 3 ) <NEWLINE> <DEDENT> elif Q . count ( R ) == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> elif Q . count ( R ) == 1 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> elif Q . count ( R ) == 2 : <NEWLINE> <INDENT> if Q . [ 2 ] == <STRING> <NEWLINE> print ( 1 ) <NEWLINE> else : <NEWLINE> <INDENT> print ( 2 ) <NEWLINE> <DEDENT> <DEDENT>
s = input ( ) <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( 0 , 3 ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if ans == 2 and s [ 1 ] == <STRING> : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
S = input ( ) <NEWLINE> <INDENT> list_s = list ( S ) <NEWLINE> count = 0 <NEWLINE> <DEDENT> if 1 < len ( list_s ) < 4 <NEWLINE> for i in range ( 2 ) : <NEWLINE> <INDENT> if list_s [ i ] == <STRING> : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> elif list_s [ i ] == <STRING> : <NEWLINE> <INDENT> count = 0 <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
S = input ( ) <NEWLINE> max_c = 0 <NEWLINE> for i in S : <NEWLINE> <INDENT> if i != <STRING> : <NEWLINE> <INDENT> count = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> count = count + 1 <NEWLINE> <NL> <DEDENT> if max_c < count : <NEWLINE> <INDENT> max_c = count <NEWLINE> <NL> <DEDENT> <DEDENT> print ( max_c ) <NEWLINE>
S = list ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> <NL> for i in range ( len ( S ) ) : <NEWLINE> <INDENT> if ans = 0 and S [ i ] = <STRING> : <NEWLINE> <INDENT> ans = 1 <NEWLINE> <DEDENT> <DEDENT> for i in range ( len ( S ) - 1 ) : <NEWLINE> <INDENT> if S [ i ] == <STRING> and S [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL>
S = input ( ) <NEWLINE> if S . contains ( <STRING> ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif S . contains ( <STRING> ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif S . contains ( <STRING> ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> if s == <STRING> : <NEWLINE> <INDENT> print ( 3 ) <NEWLINE> elif s == <STRING> or s == <STRING> : <NEWLINE> <INDENT> print ( 2 ) <NEWLINE> elif s == <STRING> : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> else : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> def main ( ) : <NEWLINE> <INDENT> S = input ( ) . rstrip ( ) <NEWLINE> CNT = 0 <NEWLINE> ans = 0 <NEWLINE> for c in S : <NEWLINE> <INDENT> if c == <STRING> : <NEWLINE> <INDENT> CNT += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = max ( ans , CNT ) <NEWLINE> CNT = 0 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ) <NEWLINE> <DEDENT>
str = input ( ) <NEWLINE> splited = str . split ( <STRING> ) <NEWLINE> print ( splited ) <NEWLINE>
S = str ( input ( ) ) <NEWLINE> <NL> if S == <STRING> : <NEWLINE> <INDENT> print ( 3 ) <NEWLINE> <DEDENT> elif S == <STRING> or S == <STRING> : <NEWLINE> <INDENT> print ( 2 ) <NEWLINE> <DEDENT> elif S == <STRING> <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT>
S = input ( ) <NEWLINE> <NL> if S == <STRING> : <NEWLINE> <INDENT> print ( 3 ) <NEWLINE> <DEDENT> elif S [ 0 , 1 ] == <STRING> or S [ 1 , 2 ] == <STRING> : <NEWLINE> <INDENT> print ( 2 ) <NEWLINE> <DEDENT> elif S [ 0 , 1 ] == <STRING> or S [ 1 , 2 ] == <STRING> : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT>
y Season <NEWLINE> <NL> S = input ( ) <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> for i in range ( len ( S ) - 1 ) : <NEWLINE> <INDENT> if S [ i ] == <STRING> : <NEWLINE> <INDENT> tempans = 1 <NEWLINE> for j in range ( i + 1 , len ( S ) ) : <NEWLINE> <INDENT> if S [ i ] == S [ j ] : <NEWLINE> <INDENT> tempans += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if tempans > ans : <NEWLINE> <INDENT> ans = tempans <NEWLINE> <DEDENT> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if tempans > ans : <NEWLINE> <INDENT> ans = tempans <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
if S == <STRING> : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> if S == <STRING> or S == <STRING> or S == <STRING> or S == <STRING> : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> if S == <STRING> or S == <STRING> : <NEWLINE> <INDENT> print ( 2 ) <NEWLINE> <DEDENT> if S == <STRING> : <NEWLINE> <INDENT> print ( 3 ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> ans = 0 <NEWLINE> <NL> R = <STRING> * i <NEWLINE> for i in range ( 1 , 4 ) : <NEWLINE> <INDENT> R = <STRING> * i <NEWLINE> if R in s : <NEWLINE> <INDENT> ans = i <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
A = input ( ) <NEWLINE> b = A . count ( <STRING> ) <NEWLINE> C = A . count ( <STRING> ) <NEWLINE> D = A . count ( <STRING> ) <NEWLINE> if b == 1 : <NEWLINE> <INDENT> print ( 3 ) <NEWLINE> <DEDENT> elif C == 1 : <NEWLINE> <INDENT> print ( 2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if D > 0 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> i = 0 <NEWLINE> c = 0 <NEWLINE> if s [ i ] == <STRING> : <NEWLINE> <INDENT> c = 1 <NEWLINE> if s [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> c = 2 <NEWLINE> if s [ i + 2 ] == <STRING> : <NEWLINE> <INDENT> c = 3 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> c = 0 <NEWLINE> if s [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> c = 1 <NEWLINE> if s [ i + 2 ] == <STRING> : <NEWLINE> <INDENT> c = 2 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( c ) <NEWLINE>
text = input ( ) <NEWLINE> if text [ 1 ] == <STRING> : <NEWLINE> <INDENT> if text [ 0 ] == <STRING> or text [ 2 ] == <STRING> : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if text [ 0 ] == <STRING> and text [ 2 ] == <STRING> : <NEWLINE> <INDENT> print ( 3 ) <NEWLINE> <DEDENT> elif text [ 0 ] == <STRING> or text [ 2 ] == <STRING> : <NEWLINE> <INDENT> print ( 2 ) <NEWLINE> <DEDENT> <DEDENT>
S = list ( input ( ) ) <NEWLINE> <NL> cnt = 0 <NEWLINE> <NL> for i in range ( len ( S ) ) : <NEWLINE> <INDENT> if S [ i ] == <STRING> : <NEWLINE> <INDENT> if cnt == 0 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> elif S [ i - 1 ] == <STRING> : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
a = input ( ) <NEWLINE> flag = False <NEWLINE> ans = 0 <NEWLINE> hold = 0 <NEWLINE> for i in range ( 3 ) : <NEWLINE> <INDENT> if a [ i ] == <STRING> and not flag : <NEWLINE> <INDENT> ans = 1 <NEWLINE> flag = not flag <NEWLINE> hold = max ( hold , ans ) <NEWLINE> <NL> <DEDENT> elif a [ i ] == <STRING> and flag : <NEWLINE> <INDENT> ans += 1 <NEWLINE> hold = max ( hold , ans ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> ans = 0 <NEWLINE> flag = False <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> return ( hold ) <NEWLINE>
a , b , c = input ( ) . split ( ) <NEWLINE> <NL> if a == R : <NEWLINE> <INDENT> if b == R : <NEWLINE> <INDENT> if c == R : <NEWLINE> <INDENT> print ( 3 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 2 ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if b == R : <NEWLINE> <INDENT> if c == R : <NEWLINE> <INDENT> print ( 2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if c == R : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
s = list ( input ( ) ) <NEWLINE> <NL> if ( s [ 0 ] == s [ 1 ] == s [ 2 ] == <STRING> ) : <NEWLINE> <INDENT> ans = 3 <NEWLINE> <DEDENT> elif ( s [ 0 ] == s [ 1 ] == <STRING> or s [ 2 ] == s [ 1 ] == <STRING> ) : <NEWLINE> <INDENT> ans = 2 <NEWLINE> <DEDENT> elif ( s [ 0 ] == s [ 1 ] == s [ 2 ] == <STRING> ) : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = 1 <NEWLINE> <NL> <DEDENT> pritn ( ans ) <NEWLINE>
A = list ( map ( input ( ) . split ( ) ) ) <NEWLINE> <NL> cnt = A . conunt ( <STRING> ) <NEWLINE> if cnt = 2 : <NEWLINE> <INDENT> if A ( 2 ) == <STRING> : <NEWLINE> <INDENT> cnt = 1 <NEWLINE> <DEDENT> <DEDENT>
x , k , d = map ( int , input ( ) . split ( ) ) <NEWLINE> x = abs ( x ) <NEWLINE> <NL> semin = x // d <COMMENT> <NEWLINE> if semin % 2 == 0 : <NEWLINE> <INDENT> minb = 0 <COMMENT> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> minb = 1 <COMMENT> <NEWLINE> <NL> <DEDENT> if semin > k : <NEWLINE> <INDENT> print ( abs ( x - k * d ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> k = k - semin <NEWLINE> if k % 2 == 0 : <NEWLINE> <INDENT> ans = 0 <COMMENT> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = 1 <COMMENT> <NEWLINE> <DEDENT> if ans == 0 : <COMMENT> <NEWLINE> <INDENT> if minb == 0 : <NEWLINE> <INDENT> print ( abs ( x - d * semin ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( min ( abs ( ( x - ( d * semin ) ) - d ) , abs ( x - d * semin ) ) ) <NEWLINE> <DEDENT> <DEDENT> else : <COMMENT> <NEWLINE> <INDENT> if minb == 0 : <NEWLINE> <INDENT> print ( abs ( ( x - ( d * semin ) ) - d ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( abs ( x - d * semin ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
s = list ( input ( ) . split ( ) ) <NEWLINE> <NL> if s [ 0 ] == S : <NEWLINE> <INDENT> if s [ 1 ] == S : <NEWLINE> <INDENT> if s [ 2 ] == S : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> if s [ 1 ] == R : <NEWLINE> <INDENT> if s [ 2 ] == S : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if s [ 0 ] == R : <NEWLINE> <INDENT> if s [ 1 ] == S : <NEWLINE> <INDENT> if s [ 2 ] == S : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> if s [ 1 ] == R : <NEWLINE> <INDENT> if s [ 2 ] == S : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
a = input ( ) <NEWLINE> <NL> if RRR in a : <NEWLINE> <INDENT> print ( 3 ) <NEWLINE> <DEDENT> elif RR in a : <NEWLINE> <INDENT> print ( 2 ) <NEWLINE> <DEDENT> elif R in a : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT>
s = rawinput ( ) <NEWLINE> res = 0 <NEWLINE> cur = 0 <NEWLINE> for i in s : <NEWLINE> <INDENT> if i == <STRING> : <NEWLINE> <INDENT> cur = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cur += 1 <NEWLINE> <DEDENT> res = max ( cur , res ) <NEWLINE> <DEDENT> print ( res ) <NEWLINE>
s = input ( ) <NEWLINE> n = len ( s ) <NEWLINE> li = [ ] <NEWLINE> c = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if ( s [ i ] == <STRING> ) : <NEWLINE> <INDENT> c = c + 1 <NEWLINE> else : <NEWLINE> li . append ( c ) <NEWLINE> c = 0 <NEWLINE> <DEDENT> <DEDENT> li . append ( c ) <NEWLINE> print ( max ( li ) ) <NEWLINE>
x , k , d = list ( map ( lambda x : int ( x ) , input ( ) . split ( ) ) ) <NEWLINE> <NL> min_pos = x % d <NEWLINE> min_neg = min_pos - d <NEWLINE> <NL> num_to_min_pos = x // d <NEWLINE> if k <= num_to_min_pos : <NEWLINE> <INDENT> print ( x - d * k ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> if ( k - num_to_min_pos ) % 2 == 0 : <NEWLINE> <INDENT> print ( min_pos ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( abs ( min_neg ) ) <NEWLINE> <DEDENT> <DEDENT>
s = input ( ) <NEWLINE> if s == <STRING> : <NEWLINE> <INDENT> print ( 3 ) <NEWLINE> <DEDENT> elif s = <STRING> : <NEWLINE> <INDENT> print ( 2 ) <NEWLINE> <DEDENT> elif s = <STRING> : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else : print ( 0 ) <NEWLINE>
S = input ( ) <NEWLINE> if S = <STRING> : <NEWLINE> <INDENT> a = 0 <NEWLINE> <DEDENT> if S = <STRING> : <NEWLINE> <INDENT> a = 1 <NEWLINE> <DEDENT> if S = <STRING> : <NEWLINE> <INDENT> a = 1 <NEWLINE> <DEDENT> if S = <STRING> : <NEWLINE> <INDENT> a = 2 <NEWLINE> <DEDENT> if S = <STRING> : <NEWLINE> <INDENT> a = 1 <NEWLINE> <DEDENT> if S = <STRING> : <NEWLINE> <INDENT> a = 1 <NEWLINE> <DEDENT> if S = <STRING> : <NEWLINE> <INDENT> a = 2 <NEWLINE> <DEDENT> if S = <STRING> : <NEWLINE> <INDENT> a = 3 <NEWLINE> <DEDENT> print ( a ) <NEWLINE>
r = input ( ) <NEWLINE> if r == <STRING> : <NEWLINE> <INDENT> print ( 3 ) <NEWLINE> <DEDENT> elif r == <STRING> or r == <STRING> : <NEWLINE> <INDENT> print ( 2 ) <NEWLINE> <DEDENT> elif r == <STRING> or r == <STRING> or r == <STRING> or r == <STRING> : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else rainy_days == <STRING> : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT>
A = input ( ) <NEWLINE> if A == <STRING> <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> if A = <STRING> <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> if A == <STRING> or <STRING> or <STRING> or <STRING> : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> if A == <STRING> or <STRING> : <NEWLINE> <INDENT> print ( 2 ) <NEWLINE> <DEDENT> if A == <STRING> : <NEWLINE> <INDENT> print ( 3 ) <NEWLINE> <DEDENT>
S = input ( ) <NEWLINE> if S = <STRING> : print ( 3 ) <NEWLINE> if S = <STRING> : print ( 2 ) <NEWLINE> if S = <STRING> : print ( 1 ) <NEWLINE> if S = <STRING> : print ( 1 ) <NEWLINE> if S = <STRING> : print ( 2 ) <NEWLINE> if S = <STRING> : print ( 1 ) <NEWLINE> if S = <STRING> : print ( 1 ) <NEWLINE> if S = <STRING> : print ( 0 ) <NEWLINE>
L = [ s for s in input ( ) ] <NEWLINE> if not <STRING> in L : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> elif not <STRING> in L : <NEWLINE> <INDENT> print ( 3 ) <NEWLINE> <DEDENT> elif L [ 1 ] == <STRING> : <NEWLINE> <INDENT> if <STRING> in L : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> <DEDENT> elif L [ 0 ] == <STRING> <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 2 ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> <NL> list = list ( s ) <NEWLINE> cnt = 0 <NEWLINE> if list ( 0 ) == <STRING> and list ( 1 ) == <STRING> and list ( 2 ) == <STRING> : <NEWLINE> <INDENT> print ( 3 ) <NEWLINE> <DEDENT> elif list ( 0 ) == <STRING> and list ( 1 ) == <STRING> and list ( 2 ) != <STRING> : <NEWLINE> <INDENT> print ( 2 ) <NEWLINE> <DEDENT> elif list ( 0 ) == <STRING> and list ( 1 ) != <STRING> and list ( 2 ) != <STRING> : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> elif list ( 0 ) == <STRING> and list ( 1 ) != <STRING> and list ( 2 ) == <STRING> : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> elif list ( 0 ) != <STRING> and list ( 1 ) == <STRING> and list ( 2 ) == <STRING> : <NEWLINE> <INDENT> print ( 2 ) <NEWLINE> <DEDENT> elif list ( 0 ) != <STRING> and list ( 1 ) != <STRING> and list ( 2 ) == <STRING> : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> elif list ( 0 ) != <STRING> and list ( 1 ) == <STRING> and list ( 2 ) != <STRING> : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> <NL> if s = <STRING> : <NEWLINE> <INDENT> print ( 3 ) <NEWLINE> <DEDENT> elif s = <STRING> or s = <STRING> : <NEWLINE> <INDENT> print ( 2 ) <NEWLINE> <DEDENT> elif s = <STRING> : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT>
S = input ( ) <NEWLINE> <NL> c = 0 <NEWLINE> max = 0 <NEWLINE> <NL> for i in S : <NEWLINE> <INDENT> if i == R : <NEWLINE> <INDENT> c += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> max = max ( [ c , max ] ) <NEWLINE> c = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( max ) <NEWLINE>
S = input ( ) <NEWLINE> <NL> r = 0 <NEWLINE> for i in range ( 3 ) : <NEWLINE> <INDENT> if i == 0 and S [ 0 ] == <STRING> : <NEWLINE> <INDENT> r += 1 <NEWLINE> elif i < 2 : <NEWLINE> if S [ i ] == S [ i + 1 ] : <NEWLINE> <INDENT> r += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( r ) <NEWLINE>
print ( sum ( input ( ) in <STRING> * i for i in range ( 3 ) ) ) <NEWLINE>
s = input ( ) <NEWLINE> if s = <STRING> : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( s . count ( <STRING> ) ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> ans = 0 <NEWLINE> if s == <STRING> : <NEWLINE> <INDENT> print ( 3 ) <NEWLINE> <DEDENT> elif s == <STRING> or s == <STRING> : <NEWLINE> <INDENT> print ( 2 ) <NEWLINE> <DEDENT> elif s == <STRING> or s == <STRING> s == <STRING> or s == <STRING> : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> c = 0 <NEWLINE> if s [ 0 ] == s [ 1 ] == s [ 2 ] == <STRING> : <NEWLINE> <INDENT> print ( 3 ) <NEWLINE> return <NEWLINE> <DEDENT> if s [ 0 ] == s [ 1 ] == <STRING> or s [ 1 ] == s [ 2 ] == <STRING> : <NEWLINE> <INDENT> print ( 2 ) <NEWLINE> return <NEWLINE> <DEDENT> if s [ 0 ] == s [ 1 ] == s [ 2 ] == <STRING> : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> print ( 1 ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE> <NL>
S = input ( ) <NEWLINE> <NL> ans = 0 <NEWLINE> if S == <STRING> : ans = 3 <NEWLINE> else : <NEWLINE> <INDENT> if ( <STRING> in S ) ans = 2 <NEWLINE> else : <NEWLINE> <INDENT> if ( <STRING> in S ) ans = 1 <NEWLINE> else : ans = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
s = input ( ) <NEWLINE> s = s . split ( <STRING> ) <NEWLINE> print ( max ( len ( s ) ) ) <NEWLINE>
S = input ( ) <NEWLINE> s = [ i for i in input ( ) ] <NEWLINE> if s . count ( <STRING> ) == 3 : <NEWLINE> <INDENT> print ( 3 ) <NEWLINE> <DEDENT> elif s . count ( <STRING> ) == 1 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> elif s . count ( <STRING> ) == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if S == <STRING> : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 2 ) <NEWLINE> <DEDENT> <DEDENT>
S = list ( input ( ) ) <NEWLINE> <NL> if <STRING> in s : <NEWLINE> <INDENT> i = 3 <NEWLINE> <DEDENT> elif <STRING> in s : <NEWLINE> <INDENT> i = 2 <NEWLINE> <DEDENT> elif <STRING> in s : <NEWLINE> <INDENT> i = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> i = 0 <NEWLINE> <DEDENT> print ( i ) <NEWLINE>
i = input ( ) <NEWLINE> <NL> <NL> if i == <STRING> : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> elif i == <STRING> : <NEWLINE> <INDENT> print ( 3 ) <NEWLINE> <DEDENT> elif i == <STRING> or <STRING> or <STRING> or <STRING> : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> elif i = <STRING> or <STRING> : <NEWLINE> <INDENT> print ( 2 ) <NEWLINE> <DEDENT>
str1 = input ( ) <NEWLINE> ct = 0 <NEWLINE> for i in range ( 0 , 3 ) : <NEWLINE> <INDENT> if ( str1 [ i ] == <STRING> ) <NEWLINE> ct += 1 <NEWLINE> <DEDENT> if ( ct == 0 ) : <NEWLINE> <INDENT> print ( 3 ) <NEWLINE> <DEDENT> if ( ct == 3 ) : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> if ( ct == 2 ) : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> if ( ct == 1 ) : <NEWLINE> <INDENT> if ( str1 [ 1 ] == <STRING> ) : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 2 ) <NEWLINE> <DEDENT> <DEDENT>
S = input ( ) <NEWLINE> max_count = 0 <NEWLINE> counter = 0 <NEWLINE> for i in S : <NEWLINE> <INDENT> if i == <STRING> : <NEWLINE> <INDENT> if max_counter < counter : <NEWLINE> <INDENT> max_count = counter <NEWLINE> counter = 0 <NEWLINE> <DEDENT> <DEDENT> elif i == <STRING> : <NEWLINE> <INDENT> counter += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if max_counter < counter : <NEWLINE> <INDENT> max_count = counter <NEWLINE> <NL> <DEDENT> print ( max_counter ) <NEWLINE>
S = input ( ) <NEWLINE> if S == <STRING> : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> elif S == <STRING> : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> elif S == <STRING> : <NEWLINE> <INDENT> print ( 2 ) <NEWLINE> <DEDENT> else if S == <STRING> : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else if S == <STRING> : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else if S == <STRING> : <NEWLINE> <INDENT> print ( 2 ) <NEWLINE> <DEDENT> else if S == <STRING> : <NEWLINE> <INDENT> print ( 3 ) <NEWLINE> <DEDENT> else if S == <STRING> : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <NL> <NL> <DEDENT>
ws = input ( ) <NEWLINE> <NL> rev = 0 <NEWLINE> for ch in ws : <NEWLINE> <INDENT> if ch == <STRING> : <NEWLINE> <INDENT> rev += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> rev = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> return rev <NEWLINE>
S = input ( ) <NEWLINE> x = 0 <NEWLINE> if S == <STRING> : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in S : <NEWLINE> <INDENT> if i == <STRING> : <NEWLINE> <INDENT> x += 1 <NEWLINE> <DEDENT> <DEDENT> print ( a ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> <NL> if s == <STRING> : <NEWLINE> <INDENT> print ( 3 ) <NEWLINE> <DEDENT> elif s == <STRING> or s == <STRING> : <NEWLINE> <INDENT> print ( 2 ) <NEWLINE> <DEDENT> elif s == <STRING> or s == <STRING> or s == <STRING> or s = <STRING> : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT>
a = input ( ) <NEWLINE> max = [ ] <NEWLINE> for i in range ( 3 ) : <NEWLINE> <INDENT> if a [ i ] == <STRING> : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> max [ 0 ] = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> max [ i ] = max [ i - 1 ] + 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> max [ i ] = 0 <NEWLINE> <DEDENT> <DEDENT> print ( sum ( max ) ) <NEWLINE>
S = input ( ) <NEWLINE> c = 0 <NEWLINE> m = 0 <NEWLINE> if s in S : <NEWLINE> <INDENT> if s == <STRING> : <NEWLINE> <INDENT> c += 1 <NEWLINE> m = max ( c , m ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> m = max ( c , m ) <NEWLINE> c = 0 <NEWLINE> <DEDENT> <DEDENT> print ( m ) <NEWLINE> <NL>
S = input ( ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> ans = 0 <NEWLINE> if S == <STRING> : ans = 3 <NEWLINE> elif S == <STRING> and S == <STRING> : ans = 2 <NEWLINE> elif S == <STRING> : ans = 0 <NEWLINE> else : ans = 1 <NEWLINE> <NL> print ( ans ) <NEWLINE> <NL> RSR SSR SRS RSS <NEWLINE>
a = input ( ) <NEWLINE> c = 0 <NEWLINE> x = [ ] <NEWLINE> for i in a : <NEWLINE> <INDENT> if i == <STRING> : <NEWLINE> <INDENT> c += 1 <NEWLINE> <DEDENT> if i == <STRING> : <NEWLINE> <INDENT> x . append ( c ) <NEWLINE> <INDENT> c = 0 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( max ( x ) ) <NEWLINE>
S = input ( ) <NEWLINE> if S = <STRING> : <NEWLINE> <INDENT> print ( 3 ) <NEWLINE> <DEDENT> elif <STRING> in S : <NEWLINE> <INDENT> print ( 2 ) <NEWLINE> <DEDENT> elif <STRING> in S : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> count = 0 <NEWLINE> for i in range ( n - 2 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n - 1 ) : <NEWLINE> <INDENT> if l [ i ] == l [ j ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> l [ i ] + l [ j ] <NEWLINE> for k in range ( j + 1 , n ) : <NEWLINE> <INDENT> if l [ k ] == l [ i ] or l [ k ] == l [ l ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if l [ k ] < l [ i ] + l [ j ] and l [ i ] < l [ j ] + l [ k ] and l [ j ] < l [ k ] + l [ i ] : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE> <NL>
<COMMENT> <NL> Si = [ ] <NEWLINE> Si = list ( str ( input ( ) ) ) <NEWLINE> i = 0 <NEWLINE> if Si . count ( <STRING> ) == 3 : <NEWLINE> <INDENT> i = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if Si . count ( <STRING> ) == 3 : <NEWLINE> <INDENT> i = 3 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if Si . count ( <STRING> ) == 1 : <NEWLINE> <INDENT> i = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if Si [ 1 ] == <STRING> : <NEWLINE> <INDENT> = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> i = 2 <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( i ) <NEWLINE>
n = 0 <NEWLINE> S = Input ( ) <NEWLINE> for i in range ( 0 , len ( S ) ) : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> if S [ i ] == <STRING> : <NEWLINE> <INDENT> n += 1 <NEWLINE> <DEDENT> <DEDENT> if i == 1 : <NEWLINE> <INDENT> if S [ i ] == <STRING> : <NEWLINE> <INDENT> n += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> n = 0 <NEWLINE> <DEDENT> <DEDENT> if i == 2 : <NEWLINE> <INDENT> if S [ i ] == <STRING> : <NEWLINE> <INDENT> n += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( n ) <NEWLINE>
s = input ( ) <NEWLINE> ans = 0 <NEWLINE> if <STRING> in s : ans = 3 <NEWLINE> elif <STRING> in s : ans = 2 <NEWLINE> else <STRING> in s : ans = 1 <NEWLINE> print ( ans ) <NEWLINE>
a = input ( ) <NEWLINE> if <STRING> in a : <NEWLINE> <INDENT> print ( 3 ) <NEWLINE> <DEDENT> elif <STRING> in a : <NEWLINE> <INDENT> print ( 2 ) <NEWLINE> <DEDENT> elif <STRING> in a : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else : a <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT>
max = 0 <NEWLINE> for letter in S : <NEWLINE> <INDENT> if letter == <STRING> : <NEWLINE> <INDENT> max += 1 <NEWLINE> <DEDENT> if letter == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> print ( max ) <NEWLINE>
str = list ( input ( ) ) <NEWLINE> counter = 0 <NEWLINE> max = 0 <NEWLINE> for s in str : <NEWLINE> <INDENT> if s = <STRING> : <NEWLINE> <INDENT> counter = 0 <NEWLINE> <DEDENT> else <NEWLINE> <INDENT> counter += 1 <NEWLINE> if max < counter <NEWLINE> <INDENT> max = counter <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( max ) <NEWLINE>
S = int ( input ( ) ) <NEWLINE> <NL> flag = False <NEWLINE> ans = 0 <NEWLINE> for i in range ( len ( S ) ) : <NEWLINE> <INDENT> if S [ i ] == <STRING> : <NEWLINE> <INDENT> ans += 1 <NEWLINE> flag = True <NEWLINE> <DEDENT> elif S [ i ] == <STRING> and flag : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
temp = input ( ) <NEWLINE> return print ( temp . count ( <STRING> ) ) <NEWLINE>
c = 0 <NEWLINE> r = [ ] <NEWLINE> for i in input ( ) : <NEWLINE> <INDENT> if i == <STRING> : <NEWLINE> <INDENT> c += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> r . append ( c ) <NEWLINE> c = 0 <NEWLINE> <DEDENT> <DEDENT> if not len ( r ) : <NEWLINE> <INDENT> print ( c ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( max ( c ) ) <NEWLINE> <DEDENT>
if ( <STRING> in S ) : <NEWLINE> <INDENT> print ( 3 ) <NEWLINE> <DEDENT> elif ( <STRING> in S ) : <NEWLINE> <INDENT> print ( 2 ) <NEWLINE> <DEDENT> elif ( <STRING> in S ) : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> n , K = map ( int , input ( ) . split ( ) ) <NEWLINE> p = list ( map ( lambda x : int ( x ) - 1 , input ( ) . split ( ) ) ) <NEWLINE> c = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if K == 1 : <NEWLINE> <INDENT> print ( max ( c ) ) ; exit ( ) <NEWLINE> <DEDENT> ans = - 10 ** 10 <NEWLINE> def cycle ( k ) : <NEWLINE> <INDENT> mo = k <NEWLINE> clen = 0 <NEWLINE> cscore = 0 <NEWLINE> flg = True <NEWLINE> cmax = [ - 10 ** 10 ] <NEWLINE> while ( mo != k or flg ) : <NEWLINE> <INDENT> clen += 1 <NEWLINE> cscore += c [ mo ] <NEWLINE> mo = p [ mo ] <NEWLINE> cmax . append ( max ( cmax [ - 1 ] , cscore ) ) <NEWLINE> if mo == k : <NEWLINE> <INDENT> flg = False <NEWLINE> <DEDENT> <DEDENT> if cscore < 0 : <NEWLINE> <INDENT> return cmax [ min ( K - 1 , clen - 1 ) ] <NEWLINE> <DEDENT> return cscore * ( ( K - 1 ) // clen ) + cmax [ ( K - 1 ) % clen + 1 ] <NEWLINE> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> a = cycle ( i ) <NEWLINE> if a > ans : <NEWLINE> <INDENT> ans = a <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
p = 0 <NEWLINE> q = 0 <NEWLINE> for i in range ( len ( S ) ) : <NEWLINE> <INDENT> if S [ i ] != <STRING> : <NEWLINE> <INDENT> p += 1 <NEWLINE> if p > q : <NEWLINE> <INDENT> q = p <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> p = 0 <NEWLINE> <DEDENT> <DEDENT> print ( q ) <NEWLINE> <NL> <NL> <NL>
ss = input ( ) <NEWLINE> if ss [ 0 ] == ss [ 1 ] == s [ 2 ] == <STRING> : <NEWLINE> <INDENT> print ( 3 ) <NEWLINE> <DEDENT> elif ss [ 0 ] == s [ 1 ] == <STRING> or ss [ 1 ] == ss [ 2 ] == <STRING> or ss [ 2 ] == ss [ 0 ] == <STRING> <NEWLINE> <INDENT> print ( 2 ) <NEWLINE> <DEDENT> elif <STRING> in ss : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT>
if s == <STRING> : <NEWLINE> <INDENT> print ( 3 ) <NEWLINE> <DEDENT> elif s == <STRING> or s == <STRING> : <NEWLINE> <INDENT> print ( 2 ) <NEWLINE> <DEDENT> elif s == <STRING> or s == <STRING> or s == <STRING> or s == <STRING> : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT>
day = input ( ) <NEWLINE> count = day . count ( <STRING> ) <NEWLINE> if count == 2 : <NEWLINE> <INDENT> if count1 = day . count ( <STRING> ) : <NEWLINE> <INDENT> print ( 2 ) <NEWLINE> else : <NEWLINE> print ( 1 ) <NEWLINE> <DEDENT> <DEDENT> if count == 1 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> if count == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> if s == <STRING> : <NEWLINE> <INDENT> print ( 3 ) <NEWLINE> <DEDENT> elif s == <STRING> : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> elif ( s == <STRING> or s == <STRING> ) : <NEWLINE> <INDENT> prinr ( 2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> c = 0 <NEWLINE> tmp = 0 <NEWLINE> for i in range ( 3 ) : <NEWLINE> <INDENT> if s [ i ] = <STRING> : <NEWLINE> <INDENT> tmp += 1 <NEWLINE> if c < tmp : <NEWLINE> <INDENT> c = tmp <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> tmp = 0 <NEWLINE> <DEDENT> <DEDENT> print ( c ) <NEWLINE>
S = input ( ) <NEWLINE> counts = [ 0 ] <NEWLINE> if <STRING> in S : <NEWLINE> <INDENT> counts . appned ( 1 ) <NEWLINE> <DEDENT> if <STRING> in S : <NEWLINE> <INDENT> counts . append ( 2 ) <NEWLINE> <DEDENT> if <STRING> in S : <NEWLINE> <INDENT> counts . append ( 3 ) <NEWLINE> <DEDENT> print ( max ( counts ) ) <NEWLINE>
s = str ( input ( ) ) <NEWLINE> s = s . lower ( s ) <NEWLINE> <NL> if s . find ( <STRING> ) != - 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif s . find ( <STRING> ) != - 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
r = 0 <NEWLINE> for l in input ( ) : <NEWLINE> <INDENT> r += 1 if l = <STRING> else 0 <NEWLINE> <DEDENT> print ( r ) <NEWLINE>
whether = input ( str ( ) ) <NEWLINE> if whether [ 1 ] == whether [ 2 ] == whether [ 3 ] == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif whether [ 1 ] == whether [ 2 ] == whether [ 3 ] == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif whether [ 1 ] == whether [ 2 ] == <STRING> or whether [ 2 ] == whether [ 3 ] == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
from sys import stdin , stdout <NEWLINE> from collections import defaultdict <NEWLINE> import math <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> for _ in range ( int ( input ( ) ) ) : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> if s == <STRING> : <NEWLINE> <INDENT> print ( 3 ) <NEWLINE> <DEDENT> elif <STRING> in s : <NEWLINE> <INDENT> print ( 2 ) <NEWLINE> <DEDENT> elif <STRING> in s : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> <DEDENT>
s = input ( ) <NEWLINE> c = 0 <NEWLINE> mc = 0 <NEWLINE> for i in s : <NEWLINE> <INDENT> if i = <STRING> : <NEWLINE> <INDENT> c += 1 <NEWLINE> mc = c <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> c = 0 <NEWLINE> <DEDENT> <DEDENT> print ( max ( c , mc ) ) <NEWLINE>
s = input ( ) <NEWLINE> if s . contains ( <STRING> ) : <NEWLINE> <INDENT> print ( 3 ) <NEWLINE> <DEDENT> elif s . contains ( <STRING> ) : <NEWLINE> <INDENT> print ( 2 ) <NEWLINE> <DEDENT> elif s . contains ( <STRING> ) : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT>
S = input ( ) <NEWLINE> c = 0 <NEWLINE> cmax = 0 <NEWLINE> for c in S : <NEWLINE> <INDENT> if c == <STRING> : <NEWLINE> <INDENT> c += 1 <NEWLINE> if cmax < c : <NEWLINE> <INDENT> cmax = c <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> c = 0 <NEWLINE> <DEDENT> <DEDENT> print ( cmax ) <NEWLINE>
s = [ str ( i ) for i in input ( ) ] <NEWLINE> if str [ 0 ] == <STRING> and str [ 1 ] == <STRING> : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> elif str [ 1 ] == <STRING> and str [ 2 ] == <STRING> : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> elif str [ 0 ] == <STRING> and str [ 1 ] == <STRING> and str [ 2 ] == <STRING> : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> elif str [ 0 ] == <STRING> and str [ 1 ] == <STRING> and str [ 2 ] == <STRING> : <NEWLINE> <INDENT> print ( 2 ) <NEWLINE> <DEDENT> elif str [ 0 ] == <STRING> and str [ 1 ] == <STRING> and str [ 2 ] == <STRING> : <NEWLINE> <INDENT> print ( 2 ) <NEWLINE> <DEDENT> elif str [ 0 ] == <STRING> and str [ 1 ] == <STRING> and str [ 2 ] == <STRING> : <NEWLINE> <INDENT> print ( 3 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT>
S = input ( ) <NEWLINE> Sc = S . count ( <STRING> ) <NEWLINE> SSc = S . count ( <STRING> ) <NEWLINE> if Sc == 3 : <NEWLINE> <INDENT> print ( 3 ) <NEWLINE> <DEDENT> elif SSc = 1 : <NEWLINE> <INDENT> print ( 2 ) <NEWLINE> <DEDENT> elif Sc == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT>
for r in S : <NEWLINE> <INDENT> if rrr in S : <NEWLINE> <INDENT> return ( 3 ) <NEWLINE> <DEDENT> elif rr in S : <NEWLINE> <INDENT> return ( 2 ) <NEWLINE> <DEDENT> elif : r in S : <NEWLINE> <INDENT> return ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return ( 0 ) <NEWLINE> <NL> <DEDENT> <DEDENT>
s = input ( ) <NEWLINE> <NL> if s == <STRING> : <NEWLINE> <INDENT> print ( 3 ) <NEWLINE> <DEDENT> elif s == <STRING> or s == <STRING> : <NEWLINE> <INDENT> print ( 2 ) <NEWLINE> <DEDENT> elif s = <STRING> : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> print ( <STRING> if <STRING> in s else <STRING> if <STRING> in s else <STRING> <STRING> in s else <STRING> ) <NEWLINE>
a = input ( ) <NEWLINE> s = 0 <NEWLINE> if a == <STRING> : <NEWLINE> <INDENT> s = 3 <NEWLINE> <DEDENT> elif a == <STRING> or a == <STRING> : <NEWLINE> <INDENT> s = 2 <NEWLINE> <DEDENT> elif a = <STRING> : <NEWLINE> <INDENT> s = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s = 1 <NEWLINE> <DEDENT> print ( s ) <NEWLINE>
text = input ( ) <NEWLINE> if text == <STRING> : <NEWLINE> <INDENT> print ( 2 ) <NEWLINE> <DEDENT> elif text == <STRING> : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else text == <STRING> : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT>
S = str ( input ( ) ) <NEWLINE> <NL> if S . count ( <STRING> ) == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> if S . count ( <STRING> ) == 1 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> if S . count ( <STRING> ) == 2 and not moji . count ( <STRING> ) == 1 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> if S . count ( <STRING> ) == 1 : <NEWLINE> <INDENT> print ( 2 ) <NEWLINE> <DEDENT> if S . count ( <STRING> ) == 1 : <NEWLINE> <INDENT> print ( 3 ) <NEWLINE> <DEDENT>
S = input ( ) <NEWLINE> <NL> if <STRING> in S : <NEWLINE> <INDENT> print ( 3 ) <NEWLINE> <DEDENT> else <STRING> in S : <NEWLINE> <INDENT> print ( 2 ) <NEWLINE> <DEDENT> else <STRING> in S : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT>
count = 0 <NEWLINE> res = 0 <NEWLINE> for ch in inp : <NEWLINE> <INDENT> if ch == <STRING> : <NEWLINE> <INDENT> count += 1 <NEWLINE> res = max ( res , count ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> res = max ( res , count ) <NEWLINE> count = 0 <NEWLINE> <DEDENT> <DEDENT> print ( res ) <NEWLINE>
S = input ( ) <NEWLINE> RD = weather . count ( <STRING> ) <NEWLINE> if RD < 2 : <NEWLINE> <INDENT> print ( RD ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if S [ 1 ] == <STRING> : <NEWLINE> <INDENT> print ( RD ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> <DEDENT>
S = input [ 0 ] <NEWLINE> cnt = 0 <NEWLINE> for i in range ( 3 ) : <NEWLINE> <INDENT> if S [ i ] == <STRING> : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <INDENT> if i == 0 or S [ i - 1 ] == <STRING> : <NEWLINE> cnt += 1 <NEWLINE> else : <NEWLINE> <INDENT> cnt = 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
S = input ( ) <NEWLINE> <NL> if S . count ( <STRING> ) == 1 : <NEWLINE> <INDENT> print ( 3 ) <NEWLINE> <DEDENT> elif S . count ( <STRING> ) == 1 : <NEWLINE> <INDENT> print ( 2 ) <NEWLINE> <DEDENT> elif S . count ( <STRING> ) == 1 or S . count ( <STRING> ) == 1 or S . count ( <STRING> ) == 1 or S . count ( <STRING> ) == 1 <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT>
list ( input ( ) ) <NEWLINE> r = weather . count ( <STRING> ) <NEWLINE> if r == 2 and weather [ 1 ] == <STRING> : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( r ) <NEWLINE> <DEDENT>
S = input ( ) <NEWLINE> <NL> if S == <STRING> : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> elif S [ 1 ] == <STRING> : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> elif S = <STRING> : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> elif S == <STRING> : <NEWLINE> <INDENT> print ( 3 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 2 ) <NEWLINE> <DEDENT>
l = [ e in e in input ( ) . split ( ) ] <NEWLINE> c = 0 <NEWLINE> if l [ 1 ] == <STRING> : <NEWLINE> <INDENT> c += 1 <NEWLINE> if l [ 0 ] == <STRING> : <NEWLINE> <INDENT> c += 1 <NEWLINE> <DEDENT> if l [ 2 ] == <STRING> : <NEWLINE> <INDENT> c += 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if l [ 0 ] == 1 or l [ 2 ] == <STRING> : <NEWLINE> <INDENT> c += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( c ) <NEWLINE>
from itertools import combinations <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> lst = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> comb = combinations ( lst , 3 ) <NEWLINE> count = 0 <NEWLINE> <NL> for i in comb : <NEWLINE> <INDENT> if i [ 0 ] != i [ 1 ] and i [ 1 ] != i [ 2 ] : <NEWLINE> <INDENT> if i [ 0 ] + i [ 1 ] > i [ 2 ] and i [ 1 ] + i [ 2 ] > i [ 0 ] and i [ 0 ] + i [ 2 ] > i [ 1 ] : <NEWLINE> <INDENT> count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> Ls = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> count = 0 <NEWLINE> for i in range ( len ( N ) ) : <NEWLINE> <INDENT> for j in range ( i , len ( N ) ) : <NEWLINE> <INDENT> for k in range ( j , len ( N ) ) : <NEWLINE> <INDENT> tmp = [ Ls [ i ] , Ls [ j ] , Ls [ k ] ] <NEWLINE> if sum ( tmp ) < 2 * max ( tmp ) : <NEWLINE> <INDENT> count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> L = list ( map ( int , inptu ( ) . split ( ) ) ) <NEWLINE> <NL> count = 0 <NEWLINE> for i in range ( len ( L ) ) : <NEWLINE> <INDENT> for j in range ( len ( L ) ) : <NEWLINE> <INDENT> for k in range ( len ( L ) ) : <NEWLINE> <INDENT> if L [ i ] + L [ j ] > L [ k ] and L [ j ] + L [ k ] > L [ i ] and L [ i ] + L [ k ] > L [ j ] and i != j and j != k and i != k : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> hen = [ ] <NEWLINE> <NL> hen = list ( int ( x ) for x in input ( ) . split ( ) ) <NEWLINE> <NL> <COMMENT> <NL> hen_u = set ( hen . sort ( ) ) <NEWLINE> <COMMENT> <NL> tri = 0 <NEWLINE> <NL> for a in hen_u : <NEWLINE> <INDENT> for b in hen_u : <NEWLINE> <INDENT> if ( a == b ) : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> for c in hen_u : <NEWLINE> <INDENT> if ( a == c ) or ( b == c ) : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if ( a + b > c ) and ( b + c > a ) and ( c + a > b ) : <NEWLINE> <INDENT> tri += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( tri ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> l_list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> l_list . sort ( ) <NEWLINE> count = 0 <NEWLINE> for i in range ( 0 , n - 2 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n - 1 ) : <NEWLINE> <INDENT> for k in range ( j + 1 , n ) : <NEWLINE> <INDENT> a = list [ i ] <NEWLINE> b = list [ j ] <NEWLINE> c = list [ k ] <NEWLINE> if a == b or b == c or c == b : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if a + b > c : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
import numpy as np <NEWLINE> from numba import * <NEWLINE> <NL> import sys <NEWLINE> read = sys . stdin . buffer . read <NEWLINE> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> length = np . array ( read . split ( ) , np . int64 ) [ 1 : ] <NEWLINE> <NL> <NL> length = np . sort ( length ) <NEWLINE> <NL> @ njit ( ( i8 [ : ] , ) , cache = True ) <NEWLINE> def calc ( length ) : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> for j in range ( i + 1 , N ) : <NEWLINE> <INDENT> for k in range ( j + 1 , N ) : <NEWLINE> <INDENT> l1 , l2 , l3 = length [ i ] , length [ j ] , length [ k ] <NEWLINE> if ( l1 != l2 and l1 != l3 and l2 != l3 ) : <NEWLINE> <INDENT> if ( l1 + l2 > l3 ) : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> return ( cnt ) <NEWLINE> <NL> <DEDENT> ans = calc ( length ) <NEWLINE> print ( ans ) <NEWLINE> <NL>
n = int ( input ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if n <= 2 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( i , n ) : <NEWLINE> <INDENT> for k in range ( j , n ) : <NEWLINE> <INDENT> if ( l [ i ] != l [ j ] ) and ( l [ j ] != l [ k ] ) and ( l [ i ] + l [ j ] > l [ k ] ) and ( l [ j ] + l [ k ] > l [ i ] ) and ( l [ k ] + l [ i ] > l [ j ] ) : <NEWLINE> <INDENT> res += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( res ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> L = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> l_list = list ( itertools . combinations ( L , 3 ) ) <NEWLINE> <NL> res = 0 <NEWLINE> <NL> for tri in l_list : <NEWLINE> <INDENT> tri . sort ( ) <NEWLINE> if tri [ 0 ] + tri [ 1 ] > tri [ 2 ] <NEWLINE> <INDENT> res += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( res ) <NEWLINE>
import itertools <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> count = 0 <NEWLINE> for x in itertools . combinations ( A , 3 ) : <NEWLINE> <INDENT> if ( x [ 0 ] + x [ 1 ] > x [ 2 ] and x [ 1 ] + x [ 2 ] > x [ 0 ] and x [ 2 ] + x [ 0 ] > x [ 1 ] ) : <NEWLINE> <INDENT> if ( x [ 0 ] != x [ 1 ] and x [ 0 ] != x [ 1 ] and x [ 2 ] != x [ 3 ] ) : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( n ) : <NEWLINE> <INDENT> for k in range ( n ) : <NEWLINE> <INDENT> if l [ i ] == l [ j ] and l [ j ] == l [ k ] and l [ i ] == l [ k ] : <NEWLINE> <INDENT> coutinue <NEWLINE> <DEDENT> if ( l [ i ] + l [ j ] > l [ k ] ) and ( l [ j ] + l [ k ] > l [ i ] ) and ( l [ i ] + l [ k ] > l [ j ] ) : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> L = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> count = 0 <NEWLINE> for a in itertools . combinations ( L , 3 ) : <NEWLINE> <INDENT> if len ( set ( a ) ) != 3 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> a = sorted ( a ) <NEWLINE> if a [ 2 ] < a [ 0 ] + a [ 1 ] : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> L = map ( int , input ( ) . split ( ) ) <NEWLINE> cnt = 0 <NEWLINE> for i in range ( N - 2 ) : <NEWLINE> <COMMENT> <NL> <INDENT> for j in range ( i + 1 , N - 1 ) : <NEWLINE> <COMMENT> <NL> <INDENT> for k in range ( j + 1 , N ) : <NEWLINE> <INDENT> print ( i , j , k ) <NEWLINE> if L [ i ] == L [ j ] or L [ i ] == L [ k ] or L [ j ] == L [ k ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if L [ i ] + L [ j ] <= L [ k ] or L [ i ] + L [ k ] <= L [ j ] or L [ j ] + L [ k ] <= L [ i ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
n = int ( input ( ) . rstrip ( ) ) <NEWLINE> edgeList = sorted ( [ int ( _ ) for _ in input ( ) . rstrip ( ) . split ( <STRING> ) ] ) n = int ( input ( ) . rstrip ( ) ) <NEWLINE> edgeList = [ int ( _ ) for _ in input ( ) . rstrip ( ) . split ( <STRING> ) ] <NEWLINE> cnt = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n ) : <NEWLINE> <INDENT> if edgeList [ i ] != edgeList [ j ] : <NEWLINE> <INDENT> for k in range ( j + 1 , n ) : <NEWLINE> <INDENT> cnt += ( edgeList [ i ] != edgeList [ k ] and <NEWLINE> <INDENT> edgeList [ j ] != edgeList [ k ] and <NEWLINE> edgeList [ i ] + edgeList [ j ] > edgeList [ k ] and <NEWLINE> edgeList [ j ] + edgeList [ k ] > edgeList [ i ] and <NEWLINE> edgeList [ k ] + edgeList [ i ] > edgeList [ j ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> L = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> <NL> ans = 0 <NEWLINE> <NL> for i in range ( len ( L ) ) : <NEWLINE> <INDENT> for j in range ( i + 1 , len ( L ) ) : <NEWLINE> <INDENT> for k in range ( j + 1 , len ( L ) ) : <NEWLINE> <COMMENT> <NL> <INDENT> if L [ i ] + L [ j ] > L [ k ] and L [ j ] + L [ k ] > L [ i ] and L [ k ] + L [ i ] > L [ j ] and L [ i ] != L [ j ] and L [ j ] != L [ k ] and L [ k ] != L [ i ] : <NEWLINE> <COMMENT> <NL> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> prinr ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> l = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> l . sort ( ) <NEWLINE> <NL> def func ( one , two , three ) : <NEWLINE> <INDENT> if len ( set ( [ one , two , three ] ) ) == 3 and one + two > three : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> return False <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in range ( n - 2 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n - 1 ) : <NEWLINE> <INDENT> for k in range ( j + 1 , n ) : <NEWLINE> <INDENT> one = l [ i ] <NEWLINE> two = l [ j ] <NEWLINE> three0l [ k ] <NEWLINE> if func ( one , two , three ) : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> lst = list ( map ( int , input ( ) . strip ( ) . split ( ) ) ) [ : n ] <NEWLINE> print ( findnumberofTriangles ( lst ) ) <NEWLINE> count = 0 <NEWLINE> for i in range ( 0 , n ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n ) : <NEWLINE> <INDENT> for k in range ( j + 1 , n ) : <NEWLINE> <INDENT> if ( lst [ i ] != lst [ j ] and lst [ j ] != lst [ k ] and lst [ k ] != lst [ i ] ) : <NEWLINE> <INDENT> if ( lst [ i ] + lst [ j ] > lst [ k ] and <NEWLINE> <INDENT> lst [ i ] + lst [ k ] > lst [ j ] and <NEWLINE> lst [ k ] + lst [ j ] > lst [ i ] ) : <NEWLINE> count += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
n = input ( ) <NEWLINE> lst = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( n - 2 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n - 1 ) : <NEWLINE> <INDENT> for k in range ( j + 1 , n ) : <NEWLINE> <INDENT> lst2 = [ lst [ i ] , lst [ j ] , lst [ k ] ] <NEWLINE> lst3 = sorted ( lst2 ) <NEWLINE> if ( lst3 [ 2 ] < lst3 [ 1 ] + lst3 [ 0 ] ) : <NEWLINE> <INDENT> ans = ans + 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> l = [ ] <NEWLINE> for index in range ( n ) : <NEWLINE> <INDENT> l . append ( int ( input ( ) ) ) <NEWLINE> <NL> <DEDENT> res = 0 <NEWLINE> for t0 in range ( len ( l ) - 2 ) : <NEWLINE> <INDENT> for t1 in range ( t0 , len ( l ) - 2 ) : <NEWLINE> <INDENT> for t2 in range ( t1 , len ( l ) - 2 ) : <NEWLINE> <INDENT> if ( l [ t0 ] != l [ t1 ] and l [ t1 ] != l [ t2 ] and l [ t1 ] != l [ t2 ] ) : <NEWLINE> <INDENT> if ( t0 + t1 > t2 and t0 + t2 > t1 and t1 + t2 > t0 ) : <NEWLINE> <INDENT> res += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( res ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> <NL> L = map ( int , input ( ) . split ( ) ) <NEWLINE> L . sort ( ) <NEWLINE> ret = 0 <NEWLINE> if N >= 3 : <NEWLINE> <INDENT> for i in range ( N - 2 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , N - 1 ) : <NEWLINE> <INDENT> if L [ i ] != L [ j ] : <NEWLINE> <INDENT> for k in range ( j + 1 , N ) : <NEWLINE> <INDENT> if L [ i ] != L [ k ] and L [ j ] != L [ k ] and L [ i ] + L [ j ] > L [ k ] : <NEWLINE> <INDENT> ret += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ret ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> L = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> cnt = 0 <NEWLINE> for i in combinations ( L , 3 ) : <NEWLINE> <INDENT> longest = max ( i ) <NEWLINE> rest = sum ( i ) - max ( i ) <NEWLINE> if longest < rest and i [ 0 ] != i [ 1 ] and i [ 0 ] != i [ 2 ] and i [ 1 ] != i [ 2 ] : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
n , * L = map ( int , input ( ) . split ( ) ) <NEWLINE> L . sort ( ) <NEWLINE> c = 0 <NEWLINE> for i in range ( n - 2 ) : <NEWLINE> <INDENT> li = L [ i ] <NEWLINE> for j in range ( i + 1 , n - 1 ) : <NEWLINE> <INDENT> lj = L [ j ] <NEWLINE> if li == lj : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> for k in range ( j + 1 , n ) : <NEWLINE> <INDENT> lk = L [ k ] <NEWLINE> if lj == lk or li + lj < lk : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> c += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( c ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> if n < 3 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> l = map ( int , input ( ) . split ( ) ) <NEWLINE> l . sort ( ) <NEWLINE> c = 0 <NEWLINE> for i in range ( n - 2 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n - 1 ) : <NEWLINE> <INDENT> for k in range ( j + 1 , n ) : <NEWLINE> <INDENT> if l [ i ] + l [ j ] > l [ k ] and l [ i ] != l [ j ] and l [ j ] != l [ k ] : <NEWLINE> <INDENT> c += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( c ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <INDENT> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> <NL> for i in range ( n - 2 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n - 1 ) : <NEWLINE> <INDENT> for k in range ( j + 1 , n ) : <NEWLINE> <INDENT> if len ( set ( [ l [ i ] , l [ j ] , l [ k ] ] ) ) == 3 and max ( l [ i ] , l [ j ] , l [ k ] ) < sum ( [ l [ i ] , l [ j ] , l [ k ] ] ) - max ( l [ i ] , l [ j ] , l [ k ] ) : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
input ( ) <NEWLINE> x = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> x . sort ( ) <NEWLINE> x = np . array ( x ) <NEWLINE> ans = 0 <NEWLINE> for i in x [ : - 2 ] : <NEWLINE> <INDENT> y = x [ x > i ] <NEWLINE> for j in y : <NEWLINE> <INDENT> z = y [ y > j ] <NEWLINE> for k in z : <NEWLINE> <INDENT> if i + j > k : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) <NEWLINE> c = 0 <NEWLINE> for i in range ( 0 , n ) : <NEWLINE> <INDENT> for j in range ( i , n ) : <NEWLINE> <INDENT> for k in range ( j , n ) : <NEWLINE> <INDENT> if l [ i ] != l [ j ] and l [ j ] != l [ k ] and l [ k ] != l [ i ] : <NEWLINE> <INDENT> if l [ i ] + l [ j ] > l [ k ] and l [ k ] + l [ j ] > l [ i ] and l [ i ] + l [ k ] > l [ j ] : <NEWLINE> <INDENT> c = c + 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( c ) <NEWLINE>
x = [ ] <NEWLINE> n = int ( input ( ) ) <NEWLINE> for i in range ( 0 , n ) : <NEWLINE> <INDENT> xa = int ( input ( ) ) <NEWLINE> x . append ( xa ) <NEWLINE> <DEDENT> count = 0 <NEWLINE> for i in range ( 0 , n - 2 ) : <NEWLINE> <INDENT> for j in range ( i , n - 1 ) : <NEWLINE> <INDENT> if ( x [ i ] == x [ j ] ) : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> for k in range ( j , n ) : <NEWLINE> <INDENT> if ( ( x [ i ] == x [ k ] ) or ( x [ j ] == x [ k ] ) ) : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if ( ( x [ i ] + x [ j ] > x [ k ] ) and ( x [ i ] + x [ k ] > x [ j ] ) and ( x [ j ] + x [ k ] > x [ i ] ) ) : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> l . sort ( ) <NEWLINE> s = 0 <NEWLINE> i = 0 <NEWLINE> while s == 0 : <NEWLINE> <INDENT> if l [ i ] == l [ i + 1 ] : <NEWLINE> <INDENT> l . remove ( l [ i ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> i += 1 <NEWLINE> if len ( l ) - 1 == i : <NEWLINE> <INDENT> s += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> a = len ( l ) <NEWLINE> print ( ( a * ( a - 1 ) * ( a - 2 ) / 6 ) <NEWLINE>
import itertools <NEWLINE> import math <NEWLINE> n = int ( input ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c = list ( itertools . combinations ( l , 3 ) ) <NEWLINE> count = 0 <NEWLINE> r = math . factorial ( len ( l ) ) / ( math . factorial ( len ( l ) - 3 ) * 6 ) <NEWLINE> for i in range ( r ) : <NEWLINE> <INDENT> if c [ i ] [ 0 ] == c [ i ] [ 1 ] or c [ i ] [ 1 ] == c [ i ] [ 2 ] or c [ i ] [ 2 ] == c [ i ] [ 0 ] : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if c [ i ] [ 0 ] + c [ i ] [ 1 ] > c [ i ] [ 2 ] and c [ i ] [ 1 ] + c [ i ] [ 2 ] > c [ i ] [ 0 ] and c [ i ] [ 2 ] + c [ i ] [ 0 ] > c [ i ] [ 1 ] : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> l . sort ( ) <NEWLINE> <NL> if n < 3 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( n - 2 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n - 1 ) : <NEWLINE> <INDENT> for k in range ( j + 1 , n ) : <NEWLINE> <INDENT> if l [ i ] + l [ j ] > l [ k ] and l [ i ] is not l [ j ] and l [ j ] is not l [ k ] and l [ k ] is not l [ i ] : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
num_list = [ ] <NEWLINE> ans = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> for j in range ( N ) : <NEWLINE> <INDENT> for k in range ( N ) : <NEWLINE> <INDENT> if L [ i ] != L [ j ] and L [ j ] != L [ k ] and L [ i ] != L [ k ] : <NEWLINE> <INDENT> num_list . append ( L [ i ] ) <NEWLINE> num_list . append ( L [ j ] ) <NEWLINE> num_list . append ( L [ k ] ) <NEWLINE> num_list . sort ( ) <NEWLINE> if num_list [ 0 ] + num_list [ 1 ] > num_list [ 2 ] : <NEWLINE> <INDENT> ans += 1 <NEWLINE> num_list . clear ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> num_list . clear ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( int ( ans / 6 ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> L = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in range ( N - 2 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , N - 1 ) : <NEWLINE> <INDENT> for k in range ( j + 1 , N ) : <NEWLINE> <INDENT> if ( L [ i ] != L [ j ] and L [ i ] != L [ k ] and L [ j ] != L [ k ] ) and ( L [ i ] + L [ j ] > L [ k ] and L [ i ] + L [ k ] > L [ j ] and L [ j ] + L [ k ] > L [ i ] ) : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> l = map ( int , input ( ) . split ( ) ) <NEWLINE> l . sort ( ) <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n ) : <NEWLINE> <INDENT> for k in range ( j + 1 , n ) : <NEWLINE> <INDENT> if l [ i ] != l [ j ] != l [ k ] : <NEWLINE> <INDENT> if l [ i ] + l [ j ] > l [ k ] : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from itertools import combinations <NEWLINE> n = int ( input ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c = combinations ( l , 3 ) <NEWLINE> ans = 0 <NEWLINE> for ( a , b , c ) in c : <NEWLINE> <INDENT> if a + b > c and b + c > a and c + a > b and a != b and b != c and a != c : <NEWLINE> <INDENT> += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import itertools <NEWLINE> n = int ( input ( ) ) <NEWLINE> arr = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> arr . sort ( ) <NEWLINE> count = 0 <NEWLINE> for i in itertools . combinations ( arr , 3 ) : <NEWLINE> <INDENT> if i [ 0 ] + i [ 1 ] > i [ 3 ] and i [ 0 ] + i [ 3 ] > i [ 1 ] and i [ 3 ] + i [ 1 ] > i [ 0 ] : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE> <NL> <NL>
<COMMENT> <NL> <NL> N = int ( input ( ) ) <NEWLINE> L = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> t = 0 <NEWLINE> <NL> for a in range ( N - 2 ) : <NEWLINE> <INDENT> for b in range ( N - 2 ) : <NEWLINE> <INDENT> for count in range ( N - 2 ) : <NEWLINE> <INDENT> x = L [ a ] , L [ a + b + 1 ] , L [ a + 1 + count ] <NEWLINE> mylist = list ( x ) <NEWLINE> mylist . sort ( ) <NEWLINE> if mylist [ 0 ] + mylist [ 1 ] > mylist [ 2 ] : <NEWLINE> <INDENT> t += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( t ) <NEWLINE>
n = int ( inout ( ) ) <NEWLINE> i = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( n - 2 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n - 1 ) : <NEWLINE> <INDENT> if n [ i ] == n [ j ] : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for k in range ( j + 1 , n ) : <NEWLINE> <INDENT> if n [ i ] == n [ k ] and n [ j ] == n [ k ] : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> z = max ( n [ i ] , n [ j ] , n [ k ] ) <NEWLINE> if n [ i ] + n [ k ] + n [ j ] - z > z : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> pint ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> count = 0 <NEWLINE> <NL> for i in l : <NEWLINE> <INDENT> for j in l : <NEWLINE> <INDENT> for k in l : <NEWLINE> <INDENT> if l [ i ] + l [ j ] > l [ k ] & l [ j ] + l [ k ] > l [ i ] & l [ k ] + l [ i ] > l [ j ] & l [ i != j != k : <NEWLINE> <INDENT> count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> <NL> def print_ans ( X , K , D ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> <COMMENT> <NL> if K % 2 == 0 and D >= abs ( X ) : <NEWLINE> <INDENT> print ( abs ( X ) ) <NEWLINE> <DEDENT> elif K % 2 != 0 and D >= abs ( X ) : <NEWLINE> <INDENT> print ( min ( abs ( X - D ) , abs ( X + D ) ) ) <NEWLINE> <DEDENT> elif abs ( X ) - D * K >= 0 : <NEWLINE> <INDENT> print ( abs ( abs ( X ) - D * K ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <COMMENT> <NL> <INDENT> tmp = abs ( X ) // D <NEWLINE> rest_K = K - tmp <NEWLINE> a = abs ( abs ( X ) - tmp * D ) <NEWLINE> b = abs ( abs ( X ) - ( tmp + 1 ) * D ) <NEWLINE> if rest_K % 2 == 0 : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( b ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> X , K , D = map ( int , input ( ) . rstrip ( ) . split ( ) ) <NEWLINE> print_ans ( X , K , D ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> g = set ( l ) <NEWLINE> m = list ( g ) <NEWLINE> m . sort ( ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> judge = 0 <NEWLINE> for j in range ( i + 1 , n ) : <NEWLINE> <INDENT> for k in range ( j + 1 , n ) : <NEWLINE> <INDENT> if ( m [ i ] < m [ j ] + m [ k ] ) : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> if ( judge == 0 ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> L = int ( input ( ) . split ( ) ) <NEWLINE> <NL> L2 = list ( set ( L ) ) <COMMENT> <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> for i in range ( len ( L2 ) ) : <NEWLINE> <INDENT> for j in range ( i + 1 , len ( L2 ) ) : <NEWLINE> <INDENT> for k in range ( j + 1 , len ( L2 ) ) : <NEWLINE> <INDENT> l = [ L2 [ i ] , L2 [ j ] , L2 [ k ] ] <NEWLINE> l = sorted ( l , reverse = True ) <NEWLINE> if l [ 0 ] < l [ 1 ] + l [ 2 ] : <NEWLINE> <INDENT> ans += L . count ( L2 [ i ] ) * L . count ( L2 [ j ] ) * L . count ( L2 [ k ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL>
count = 0 <NEWLINE> <NL> length = int ( input ( ) ) <NEWLINE> length_list = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> for i in range ( length - 2 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , length - 1 ) : <NEWLINE> <INDENT> if length_list [ i ] != length_list [ j ] : <NEWLINE> <INDENT> for k in range ( j + 1 , length ) : <NEWLINE> <INDENT> if length_list [ j ] != length_list [ k ] and length_list [ k ] != length_list [ i ] : <NEWLINE> <INDENT> half_length_sum = ( length_list [ i ] + length_list [ j ] + length_list [ k ] ) / 2 <NEWLINE> if half_length_sum > max ( length_list [ i ] , length_list [ j ] , length_list [ k ] ) : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> L = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> L . sort ( ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n ) : <NEWLINE> <INDENT> for k in range ( j + 1 , n ) : <NEWLINE> <INDENT> if i < l < k and L [ i ] + L [ j ] > L [ k ] : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL>
N = int ( input ( ) ) <NEWLINE> l = [ ] <NEWLINE> c = 0 <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> a = int ( input ( ) ) <NEWLINE> l . append ( a ) <NEWLINE> <NL> <DEDENT> for j in range ( N ) : <NEWLINE> <INDENT> for k in range ( j + 1 , N ) : <NEWLINE> <INDENT> for m in range ( k + 1 , N ) : <NEWLINE> <INDENT> if ( l [ j ] == l [ k ] or l [ k ] == l [ m ] or l [ j ] == l [ m ] ) : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if ( ( l [ j ] + l [ k ] > l [ m ] ) and ( l [ k ] + l [ m ] > l [ j ] ) and ( l [ j ] + l [ m ] > l [ k ] ) ) : <NEWLINE> <INDENT> c += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( c ) <NEWLINE>
count = 0 <NEWLINE> n = int ( input ( ) ) <NEWLINE> arr = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ar = [ ] <NEWLINE> for i in range ( n - 2 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n - 1 ) : <NEWLINE> <INDENT> for k in range ( j + 1 , n ) : <NEWLINE> <INDENT> if triv ( arr [ i ] , arr [ j ] , arr [ k ] ) : <NEWLINE> <INDENT> if arr [ i ] == arr [ j ] or arr [ i ] == arr [ k ] or arr [ j ] == arr [ k ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if arr [ i ] + arr [ j ] > arr [ k ] : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> L = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if N < 3 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in range ( 0 , N - 2 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , N - 1 ) : <NEWLINE> <INDENT> for k in range ( j + 1 , N ) : <NEWLINE> <INDENT> arr = [ L [ i ] , L [ j ] , L [ k ] ] <NEWLINE> arr . sort ( ) <NEWLINE> if ( arr [ 0 ] != arr [ 1 ] & arr [ 1 ] != arr [ 2 ] ) : <NEWLINE> <INDENT> if ( arr [ 2 ] < arr [ 0 ] + arr [ 1 ] ) : <NEWLINE> <INDENT> ans = ans + 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import itertools <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> L = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if len ( L ) < 3 : <NEWLINE> <INDENT> Lis = [ ] <NEWLINE> print ( 0 ) <NEWLINE> <DEDENT> elif Lis [ 0 ] [ 0 ] == Lis [ 0 ] [ 1 ] or Lis [ 0 ] [ 0 ] == Lis [ 0 ] [ 2 ] or Lis [ 0 ] [ 1 ] == Lis [ 0 ] [ 2 ] : <NEWLINE> <INDENT> Lis = [ ] <NEWLINE> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> Lis = list ( itertools . combinations ( L , 3 ) ) <NEWLINE> <NL> <DEDENT> numb = len ( Lis ) <NEWLINE> count = 0 <NEWLINE> <NL> for i in range ( numb ) : <NEWLINE> <INDENT> if len ( L ) < 3 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> if Lis [ i ] [ 0 ] == Lis [ i ] [ 1 ] or Lis [ i ] [ 0 ] == Lis [ i ] [ 2 ] or Lis [ i ] [ 1 ] == Lis [ i ] [ 2 ] : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> bpc = Lis [ i ] [ 1 ] + Lis [ i ] [ 2 ] <NEWLINE> bmc = abs ( Lis [ i ] [ 1 ] - Lis [ i ] [ 2 ] ) <NEWLINE> if bmc < Lis [ i ] [ 0 ] and Lis [ i ] [ 0 ] < bpc : <NEWLINE> <INDENT> count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
a = int ( input ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> count = 0 <NEWLINE> <INDENT> for i in range ( a ) : <NEWLINE> <INDENT> for s in range ( a ) : <NEWLINE> <INDENT> for t in range ( a ) : <NEWLINE> <INDENT> if p [ t ] < p [ s ] < p [ i ] and p [ t ] + p [ s ] > p [ i ] : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> cnt = 0 <NEWLINE> A . sort ( ) <NEWLINE> for i in range ( 0 , N ) : <NEWLINE> <INDENT> for j in range ( i + 1 , N ) : <NEWLINE> <INDENT> for k in range ( j + 1 , N ) : <NEWLINE> <INDENT> if ( A [ i ] + A [ j ] ) > A [ k ] and ( A [ j ] + [ k ] ) > A [ i ] and ( A [ i ] + A [ k ] ) > A [ j ] and <NEWLINE> A [ i ] != A [ k ] and A [ j ] != A [ k ] and A [ i ] != A [ j ] : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> arr = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> res = 0 <NEWLINE> for i in range ( 0 , n - 2 ) : <NEWLINE> <INDENT> for j in range ( i , n - 1 ) : <NEWLINE> <INDENT> for k in range ( j , n ) : <NEWLINE> <INDENT> if arr [ i ] + arr [ j ] > arr [ k ] and arr [ i ] != arr [ j ] and arr [ j ] != arr [ k ] and arr [ i != arr [ k ] : <NEWLINE> <INDENT> res += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( res ) <NEWLINE> <NL> <NL> <NL> <NL>
N = int ( input ( ) ) <NEWLINE> array = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> array1 = sorted ( array ) <NEWLINE> import itertools <NEWLINE> list1 = list ( itertools . combinations ( array1 , 3 ) ) <NEWLINE> ans = 0 <NEWLINE> for n in range ( len ( list1 ) ) : <NEWLINE> <INDENT> if list [ n ] [ 0 ] != list [ n ] [ 1 ] and list [ n ] [ 1 ] != list [ n ] [ 2 ] : <NEWLINE> <INDENT> if list [ n ] [ 0 ] + list [ n ] [ 1 ] > list [ n ] [ 2 ] : <NEWLINE> <INDENT> ans = ans + 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> l = input ( ) <NEWLINE> ans = <NEWLINE> for i in l : <NEWLINE> <INDENT> for j in l : <NEWLINE> <INDENT> if i < j : <NEWLINE> <INDENT> for k in l : <NEWLINE> <INDENT> if j < k and i + j > k : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<NL> if N <= 2 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i , d in enumerate ( set_dup ) : <NEWLINE> <INDENT> count = 0 <NEWLINE> for n in nums : <NEWLINE> <INDENT> if n == d : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> set_dup [ i ] = count <NEWLINE> <NL> <DEDENT> count = 0 <NEWLINE> for a in range ( len ( set_nums ) ) : <NEWLINE> <INDENT> for b in range ( a + 1 , len ( set_nums ) ) : <NEWLINE> <INDENT> for c in range ( b + 1 , len ( set_nums ) ) : <NEWLINE> <INDENT> if set_nums [ a ] + set_nums [ b ] > set_nums [ c ] : <NEWLINE> <INDENT> count += set_dup [ a ] * set_dup [ b ] * set_dup [ c ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> count = 0 <NEWLINE> for i in range ( n - 2 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n - 1 ) : <NEWLINE> <INDENT> if l [ i ] == l [ j ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> l [ i ] + l [ j ] <NEWLINE> for k in range ( j + 1 , n ) : <NEWLINE> <INDENT> if l [ k ] == l [ i ] or l [ k ] == l [ l ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if l [ k ] < l [ i ] + l [ j ] and l [ i ] < l [ j ] + l [ k ] and l [ j ] < l [ k ] + l [ i ] : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE> <NL>
N = int ( input ( ) ) <NEWLINE> L = list ( map ( int , input ( ) . strip ( ) . split ( ) ) ) <NEWLINE> L_sort = L . sort ( ) <NEWLINE> count = 0 <NEWLINE> for i in range ( N - 2 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , N ) : <NEWLINE> <INDENT> for k in range ( j + 1 , N ) : <NEWLINE> <INDENT> if L_sort [ i ] + L_sort [ j ] > L_sort [ k ] : <NEWLINE> <INDENT> count += 1 <NEWLINE> else : <NEWLINE> <INDENT> k += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> l . sort ( ) <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> for j in range ( i + 1 , N ) : <NEWLINE> <INDENT> for k in range ( j + 1 , N ) : <NEWLINE> <INDENT> if l [ k ] < l [ i ] + l [ j ] : <NEWLINE> <INDENT> if l [ i ] != l [ j ] and l [ j ] != l [ k ] : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
r = int ( input ( ) ) <NEWLINE> x = list ( map ( int , input ( ) . split ( ) ) <NEWLINE> setx = list ( set ( x ) ) <NEWLINE> setx . sort ( ) <NEWLINE> cx = [ ] <NEWLINE> for i in setx : <NEWLINE> <INDENT> cx . append ( x . count ( i ) ) <NEWLINE> <DEDENT> ans = 0 <NEWLINE> A = 0 <NEWLINE> while A <= len ( setx ) - 3 : <NEWLINE> <INDENT> B = A + 1 <NEWLINE> while B <= len ( setx ) - 2 : <NEWLINE> <INDENT> C = B + 1 <NEWLINE> while C <= len ( setx ) - 1 : <NEWLINE> <INDENT> if setx [ A ] + setx [ B ] > setx [ C ] : <NEWLINE> <INDENT> ans += cx [ A ] * cx [ B ] * cx [ C ] <NEWLINE> <DEDENT> C += 1 <NEWLINE> <DEDENT> B += 1 <NEWLINE> <DEDENT> A += 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> L = [ int ( e ) for e in input ( ) . split ( ) ] <NEWLINE> c = 0 <NEWLINE> <NL> if len ( N ) >= 3 : <NEWLINE> <INDENT> for i in range ( N ) : <NEWLINE> <INDENT> for j in range ( i + 1 , N ) : <NEWLINE> <INDENT> for k in range ( j + 1 , N ) : <NEWLINE> <INDENT> if L [ i ] != L [ j ] and L [ j ] != L [ k ] and L [ k ] != L [ i ] : <NEWLINE> <INDENT> if L [ i ] != L [ j ] + L [ k ] and L [ j ] != L [ k ] + L [ i ] and L [ k ] != L [ i ] + L [ j ] : <NEWLINE> <INDENT> print ( i + 1 , j + 1 , k + 1 ) <NEWLINE> c += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( c ) <NEWLINE>
x = int ( input ( ) ) <NEWLINE> d = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> count = 0 <NEWLINE> if x < 3 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( len ( d ) ) : <NEWLINE> <INDENT> for j in range ( i + 1 , len ( d ) ) : <NEWLINE> <INDENT> for k in range ( j + 1 , len ( d ) ) : <NEWLINE> <INDENT> temp = [ ] <NEWLINE> temp . extend ( [ d [ i ] , d [ j ] , d [ k ] ] ) <NEWLINE> temp . sort ( ) <NEWLINE> if temp [ 0 ] + temp [ 1 ] > temp [ 2 ] and len ( list ( set ( temp ) ) ) == 3 : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> L_list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> conter = 0 <NEWLINE> <NL> for i in range ( N - 2 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , N - 1 ) : <NEWLINE> <INDENT> for k in range ( j + 1 , N ) : <NEWLINE> <INDENT> if a == b or b == c or c == a or a + b <= c or b + c <= a or c + a <= b : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> counter += 1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> print ( counter ) <NEWLINE>
for i in range ( le ) : <NEWLINE> <INDENT> for j in range ( i + 1 , le ) : <NEWLINE> <INDENT> for k in range ( j + 1 , le ) : <NEWLINE> <INDENT> if ( L [ i ] + L [ j ] > L [ k ] and <NEWLINE> <INDENT> L [ i ] + L [ k ] > L [ j ] and <NEWLINE> <INDENT> L [ k ] + L [ j ] > L [ i ] ) : <NEWLINE> <INDENT> if ( L [ i ] != L [ j ] and <NEWLINE> <INDENT> L [ i ] != L [ k ] and <NEWLINE> L [ k ] != L [ j ] ) : <NEWLINE> <INDENT> score += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( score ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> L = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> L = sorted ( L ) <NEWLINE> print ( L ) <NEWLINE> count = 0 <NEWLINE> <NL> for i in range ( N - 2 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , N ) : <NEWLINE> <INDENT> for k in range ( j + 1 , N ) : <NEWLINE> <INDENT> if L [ i ] + L [ j ] > L [ k ] and L [ i ] != L [ j ] != L [ k ] : <NEWLINE> <INDENT> print ( i , j , k ) <NEWLINE> count += 1 <NEWLINE> print ( count ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE>
N = int ( input ( ) ) <NEWLINE> import itertools <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> count = 0 <NEWLINE> for  in itertools . combinations ( A , 3 ) : <NEWLINE> <INDENT> if list ( t ) [ 0 ] < list ( t ) [ 1 ] + list [ 2 ] and list ( t ) [ 1 ] < list ( t ) [ 2 ] + list ( t ) [ 0 ] and list ( t ) [ 2 ] < list ( t ) [ 0 ] + list ( t ) [ 1 ] : <NEWLINE> <NL> <INDENT> cout += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) <NEWLINE> c = 0 <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> for j in range ( i , n ) : <NEWLINE> <INDENT> for k in range ( j , n ) : <NEWLINE> <INDENT> if l [ i ] != l [ j ] and l [ j ] != l [ k ] and l [ k ] != l [ i ] : <NEWLINE> <INDENT> if l [ i ] + l [ j ] > l [ k ] and l [ k ] + l [ j ] > l [ i ] and l [ i ] + l [ k ] > l [ j ] : <NEWLINE> <INDENT> c = c + 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( c ) <NEWLINE>
n = len ( L ) <NEWLINE> c = 0 <NEWLINE> result = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n ) : <NEWLINE> <INDENT> for k in range ( j + 1 , n ) : <NEWLINE> <NL> <INDENT> if abs ( L [ i ] - L [ j ] ) < L [ k ] < L [ i ] + L [ j ] and L [ i ] != L [ j ] and L [ j ] != L [ k ] : <NEWLINE> <COMMENT> <NL> <INDENT> c += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( c ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> L = map ( int , input ( ) . split ( ) ) <NEWLINE> count = 0 <NEWLINE> for a in range ( N ) : <NEWLINE> <INDENT> for b in range ( N ) : <NEWLINE> <INDENT> for c in range ( N ) : <NEWLINE> <INDENT> if L [ a ] < ( L [ b ] + L [ c ] ) and L [ b ] < ( L [ a ] + L [ c ] ) and L [ c ] < ( L [ b ] + L [ a ] ) and a != b and b != c and c != a : <NEWLINE> <INDENT> count = count + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
N = input ( ) <NEWLINE> L = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> t = [ ] <NEWLINE> if ( N >= 3 ) : <NEWLINE> <INDENT> for i in range ( N ) : <NEWLINE> <INDENT> for j in range ( N ) : <NEWLINE> <INDENT> for k in range ( N ) : <NEWLINE> <INDENT> if ( ( abs ( j - k ) < a ) & & ( a < j + k ) ) : t . append ( [ i , j , k ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> t = list ( set ( t ) ) <NEWLINE> print ( len ( t ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a . sort ( ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n ) : <NEWLINE> <INDENT> for k in range ( k + 1 , n ) : <NEWLINE> <INDENT> if l [ i ] != l [ j ] != l [ k ] : <NEWLINE> <INDENT> if l [ i ] + l [ j ] > l [ k ] ; <NEWLINE> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import itertools <NEWLINE> <NL> def chkTrg ( a , b , c ) : <NEWLINE> <INDENT> if ( a + b > c and b + c > a and c + a > b ) and ( a != b and b != c and c != a ) : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return False <NEWLINE> <NL> <DEDENT> <DEDENT> N = int ( input ( ) ) <NEWLINE> bars = [ int ( i ) for i in input ( ) . split ( <STRING> ) ] <NEWLINE> <NL> cnt = 0 <NEWLINE> <NL> for bar in itertools . combinations ( bars , 3 ) : <NEWLINE> <INDENT> if chkTrg ( bar [ 0 ] , bar [ 1 ] , bar [ 2 ] ) : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( cnt ) import itertools <NEWLINE> <NL> def chkTrg ( a , b , c ) : <NEWLINE> <INDENT> if ( a + b > c and b + c > a and c + a > b ) and ( a != b and b != c and c != a ) : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return False <NEWLINE> <NL> <DEDENT> <DEDENT> N = int ( input ( ) ) <NEWLINE> bars = [ int ( i ) for i in input ( ) . split ( <STRING> ) ] <NEWLINE> <NL> cnt = 0 <NEWLINE> <NL> for bar in itertools . combinations ( bars , 3 ) : <NEWLINE> <INDENT> if chkTrg ( bar [ 0 ] , bar [ 1 ] , bar [ 2 ] ) : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> L = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> for j in range ( i + 1 , N ) : <NEWLINE> <INDENT> for k in range ( j + 1 , N ) : <NEWLINE> <INDENT> if ( L [ i ] != L [ j ] and L [ i ] != L [ k ] and L [ j ] != L [ k ] and abs ( L [ j ] - L [ k ] ) < L [ i ] and L [ i ] < L [ j ] + L [ k ] ) : t . append ( ( L [ i ] , L [ j ] , L [ k ] ) ) : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> L = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> S = set ( L ) <NEWLINE> X = [ ] <NEWLINE> <NL> if len ( S ) < 3 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in S : <NEWLINE> <INDENT> L . count ( i ) > 1 : <NEWLINE> <INDENT> X . append ( L . count ( i ) ) <NEWLINE> <DEDENT> <DEDENT> ans = len ( S ) * len ( S - 1 ) * len ( S - 2 ) <NEWLINE> for i in X : <NEWLINE> <INDENT> ans *= i <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
def ab ( a , b , c ) : <NEWLINE> <INDENT> if ( ( a + b > c ) and ( a + c > b ) and ( b + c > a ) ) : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> <DEDENT> n = input ( ) <NEWLINE> n = int ( n ) <NEWLINE> l = get_array ( ) <NEWLINE> c = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n ) : <NEWLINE> <INDENT> for k in range ( j + 1 , n ) : <NEWLINE> <INDENT> if ( l [ i ] != l [ j ] and l [ j ] != l [ k ] and l [ k ] != l [ i ] ) : <NEWLINE> <INDENT> if ( ab ( l [ i ] , l [ j ] , l [ k ] ) ) : <NEWLINE> <COMMENT> <NL> <INDENT> c += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( c ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> arr = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> dummy = len ( arr ) <NEWLINE> ans = 0 <NEWLINE> if dummy > 2 : <NEWLINE> <INDENT> for i in range ( dummy - 2 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , dummy - 1 ) : <NEWLINE> <INDENT> for k in range ( j + 1 , dummy ) : <NEWLINE> <INDENT> if arr [ i ] != arr [ j ] and arr [ j ] != arr [ k ] and arr [ k ] != arr [ i ] : <NEWLINE> <INDENT> if arr [ i ] < arr [ j ] + arr [ k ] and arr [ j ] < arr [ k ] + arr [ i ] and arr [ k ] < arr [ j ] + arr [ i ] : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT>
mport itertools as it <NEWLINE> <NL> <NL> N = int ( input ( ) ) <NEWLINE> s = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> s . sort ( ) <NEWLINE> count = 0 <NEWLINE> <NL> <NL> c = it . combinations ( s , 3 ) <NEWLINE> <NL> for i in c : <NEWLINE> <INDENT> if i [ 0 ] == i [ 1 ] or i [ 1 ] == i [ 2 ] or i [ 2 ] == i [ 0 ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if ( i [ 0 ] + i [ 1 ] ) > i [ 2 ] : <NEWLINE> <INDENT> count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> array = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> array . sort ( ) <NEWLINE> import itertools <NEWLINE> list1 = list ( itertools . combinations ( array , 3 ) ) <NEWLINE> ans = 0 <NEWLINE> for n in range ( len ( list1 ) ) : <NEWLINE> <INDENT> if list [ n ] [ 0 ] != list [ n ] [ 1 ] and list [ n ] [ 1 ] != list [ n ] [ 2 ] : <NEWLINE> <INDENT> if list [ n ] [ 0 ] + list [ n ] [ 1 ] > list [ n ] [ 2 ] : <NEWLINE> <INDENT> ans = ans + 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A = sorted ( A ) <NEWLINE> cnt = 0 <NEWLINE> <NL> def judge ( ) : <NEWLINE> <INDENT> if m == a + b : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> elif m >= a b : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> while True : <NEWLINE> for i in range ( N - 2 ) : <NEWLINE> <INDENT> a = list [ i ] <NEWLINE> for j in range ( i + 1 , N - 1 ) : <NEWLINE> <INDENT> b = list [ j ] <NEWLINE> if a == b : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> m = i + j <NEWLINE> while True : <NEWLINE> def judge ( c ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> cnt = m - j <NEWLINE> print ( cnt ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> L = [ int ( input ( ) ) for _ in range ( N ) ] <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> for j in range ( i + 1 , N ) : <NEWLINE> <INDENT> for k in range ( j + 1 , N ) : <NEWLINE> <INDENT> if L [ i ] != L [ j ] and L [ j ] != L [ k ] and L [ i ] != L [ k ] : <NEWLINE> <INDENT> if L [ i ] + L [ j ] > L [ k ] and L [ j ] + L [ k ] > L [ i ] and L [ i ] + L [ k ] > L [ j ] : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
a = input ( ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c = b . sort ( ) <NEWLINE> d = 0 <NEWLINE> <NL> if a <= 2 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif : <NEWLINE> <INDENT> for i in len ( b ) : <NEWLINE> <INDENT> for j in ( i + 1 , len ( b ) ) : <NEWLINE> <INDENT> for k in ( k + 1 , len ( b ) ) : <NEWLINE> <INDENT> if c [ i ] + c [ j ] > c [ k ] : <NEWLINE> <INDENT> d += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( str ( d ) ) <NEWLINE> <DEDENT>
from itertools import combinations <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> combination = combinations ( lst , 3 ) <NEWLINE> count = 0 <NEWLINE> for i in combination : <NEWLINE> <INDENT> if i [ 0 ] != i [ 1 ] and i [ 1 ] != i [ 2 ] and i [ 0 ] != i [ 2 ] : <NEWLINE> <INDENT> if i [ 0 ] + i [ 1 ] > i [ 2 ] and i [ 1 ] + i [ 2 ] > i [ 0 ] and i [ 0 ] + i [ 2 ] > i [ 1 ] : <NEWLINE> <INDENT> count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> l = map ( int , input ( ) . split ( ) ) <NEWLINE> if len ( l ) < 3 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> count = 0 <NEWLINE> l = sorted ( l ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n ) : <NEWLINE> <INDENT> for k in range ( j + 1 , n ) : <NEWLINE> <INDENT> if l [ i ] != l [ j ] != l [ k ] and l [ i ] + l [ j ] > l [ k ] : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
X , K , D = input ( ) . split ( ) <NEWLINE> X = abs ( X ) <NEWLINE> Q , mod = divmod ( X , D ) <NEWLINE> if K < Q : <NEWLINE> <INDENT> ans = X - K * D <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> Rest = ( K - Q ) % 2 <NEWLINE> if Rest == 0 : <NEWLINE> <INDENT> ans = mod <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = D - mod <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
x , k , d = map ( int , input ( ) . split ( ) ) <NEWLINE> x = abs ( x ) <NEWLINE> if x > k * d : <NEWLINE> <INDENT> print ( x - k * d ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> p = x // d <NEWLINE> if p == 0 or p == 1 : <NEWLINE> <INDENT> for i in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> p2 = x - i * d <NEWLINE> c = k - i <NEWLINE> if p2 <= 0 : <NEWLINE> <INDENT> if c % 2 != 0 : <NEWLINE> <INDENT> print ( abs ( d + p2 ) ) <NEWLINE> break <NEWLINE> <DEDENT> elif c % 2 == 0 : <NEWLINE> <INDENT> print ( abs ( p2 ) ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> c = k - p <NEWLINE> elif c % 2 == 0 : <NEWLINE> <INDENT> print ( abs ( x - p * d ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( abs ( d - abs ( x - p * d ) ) ) <NEWLINE> <DEDENT> <DEDENT>
x , k , d = map ( int , input ( ) . split ( ) ) <NEWLINE> x = abs ( x ) <NEWLINE> <NL> if d * k < x : <NEWLINE> <INDENT> print ( abs ( x ) - abs ( d * k ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if abs ( x % d - d ) > abs ( x % d ) : <NEWLINE> <INDENT> if ( k - x // d ) % 2 == 0 : <NEWLINE> <INDENT> print ( abs ( x % d ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( abs ( x % d - d ) ) <NEWLINE> <DEDENT> <DEDENT> elif abs ( x % d - d ) < abs ( x % d ) <NEWLINE> <INDENT> if ( k - x // ( d + 1 ) ) % 2 == 0 : <NEWLINE> <INDENT> print ( abs ( x % d - d ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( abs ( x % d ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
x , k , d = list ( map ( lambda x : int ( x ) , input ( ) . split ( ) ) ) <NEWLINE> <NL> min_pos = x % d <NEWLINE> min_neg = min_pos - d <NEWLINE> <NL> num_to_min_pos = x // d <NEWLINE> if k <= num_to_min_pos : <NEWLINE> <INDENT> print ( x - d * k ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> if ( k - num_to_min_pos ) % 2 == 0 : <NEWLINE> <INDENT> print ( min_pos ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( abs ( min_neg ) <NEWLINE> <DEDENT> <DEDENT>
X , K , D = map ( int , input ( ) . split ( ) ) <NEWLINE> if D * K < : abs ( X ) : <NEWLINE> <INDENT> print ( abs ( X ) - D * K ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> K2 = abs ( X ) // D <NEWLINE> if ( K - K2 ) % 2 == 0 : <NEWLINE> <INDENT> print ( abs ( X ) - K2 * D ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> K2 = K2 - 1 <NEWLINE> print ( abs ( X ) - K2 * D ) <NEWLINE> <DEDENT> <DEDENT>
n , k , d = map ( int , input ( ) . split ( ) ) <NEWLINE> n = abs ( n ) <NEWLINE> ok = n // d <NEWLINE> left = k - ( ok ) <NEWLINE> if left % 2 : <NEWLINE> <INDENT> print ( d - ( n % d ) ) <NEWLINE> else : <NEWLINE> <INDENT> print ( n % d ) <NEWLINE> <DEDENT> <DEDENT>
X , K , D = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> q = X // D <NEWLINE> mod = X % D <NEWLINE> <NL> if q > K : <NEWLINE> <INDENT> ans = abs ( abs ( X ) - K * D ) <NEWLINE> <DEDENT> elif q == K : <NEWLINE> <INDENT> ans = mod <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if abs ( mod ) <= abs ( amod ) : <NEWLINE> <INDENT> if ( K - q ) % 2 == 1 : <NEWLINE> <INDENT> ans = D - mod <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = mod <NEWLINE> <NL> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
x , k , d = input ( ) . split ( ) <NEWLINE> x = int ( x ) <NEWLINE> k = int ( k ) <NEWLINE> d = int ( d ) <NEWLINE> x = abs ( x ) <NEWLINE> if x > d : <NEWLINE> <INDENT> if x // d > k : <NEWLINE> <INDENT> x = x - k * d <NEWLINE> print ( x ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> k -= x // d <NEWLINE> x = x % d <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if k % 2 == 1 : <NEWLINE> <INDENT> x = abs ( x - d ) <NEWLINE> <NL> <DEDENT> print ( x ) <NEWLINE>
from collections import defaultdict , deque <NEWLINE> import math <NEWLINE> import copy <NEWLINE> def main ( ) : <NEWLINE> <INDENT> x , k , d = map ( int , input ( ) . split ( ) ) <NEWLINE> res = float ( <STRING> ) <NEWLINE> l = 0 <NEWLINE> r = k + 1 <NEWLINE> tmp_res = 0 <NEWLINE> while ( l + 1 != r ) : <NEWLINE> <INDENT> mid = ( l + r ) // 2 <NEWLINE> tmp_res = copy . deepcopy ( res ) <NEWLINE> if ( ( k - mid ) % 2 == 1 ) : <NEWLINE> <INDENT> res = min ( res , abs ( abs ( x ) - ( mid + 1 ) * d ) ) <NEWLINE> <INDENT> res = min ( res , abs ( abs ( x ) - ( mid - 1 ) * d ) ) <NEWLINE> mid += 1 <NEWLINE> <DEDENT> <DEDENT> if ( ( k - mid ) % 2 == 0 ) : <NEWLINE> <INDENT> res = min ( res , abs ( abs ( x ) - mid * d ) ) <NEWLINE> res = abs ( res ) <NEWLINE> <DEDENT> if ( abs ( abs ( x ) - mid * d ) > x ) : <NEWLINE> <INDENT> r = mid <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> l = mid <NEWLINE> <DEDENT> if tmp_res == res : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( res ) <NEWLINE> <NL> <NL> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <NL> <DEDENT>
<COMMENT> <NL> using namespace std ; <NEWLINE> <NL> int main ( void ) <NEWLINE> { <NEWLINE> <INDENT> long long X , K , D ; <NEWLINE> long long ans = 0 ; <NEWLINE> cin >> X >> K >> D ; <NEWLINE> <NL> if ( K * D < abs ( X ) ) { <NEWLINE> <INDENT> ans = abs ( X ) - K * D ; <NEWLINE> <DEDENT> } else { <NEWLINE> <INDENT> if ( ( abs ( X ) / D ) % 2 == 0 ) { <NEWLINE> <INDENT> if ( K % 2 == 0 ) { <NEWLINE> <INDENT> ans = abs ( X ) % D ; <NEWLINE> <DEDENT> } else { <NEWLINE> <INDENT> ans = abs ( abs ( X ) % D - D ) ; <NEWLINE> <DEDENT> } <NEWLINE> <NL> <DEDENT> } else { <NEWLINE> <INDENT> if ( K % 2 == 0 ) { <NEWLINE> <INDENT> ans = abs ( abs ( X ) % D - D ) ; <NEWLINE> <DEDENT> } else { <NEWLINE> <INDENT> ans = abs ( X ) % D ; <NEWLINE> <DEDENT> } <NEWLINE> <DEDENT> } <NEWLINE> <DEDENT> } <NEWLINE> <NL> cout << ans << endl ; <NEWLINE> <NL> <DEDENT> } <NEWLINE>
from sys import stdin <NEWLINE> <NL> <NL> def f ( x , k , d ) : <NEWLINE> <INDENT> if k == 0 : <NEWLINE> <INDENT> return x <NEWLINE> <NL> <DEDENT> if x == 0 : <NEWLINE> <INDENT> if k % 2 == 0 : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> elif k % 2 == 1 : <NEWLINE> <INDENT> return d <NEWLINE> <DEDENT> <DEDENT> elif x > 0 : <NEWLINE> <INDENT> tmp = abs ( x ) / d <NEWLINE> if d * tmp > d * k : <NEWLINE> <INDENT> return x - d * k <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return f ( ( x - d * tmp ) , ( k - tmp ) , d ) <NEWLINE> <DEDENT> <DEDENT> elif x < 0 : <NEWLINE> <INDENT> tmp = abs ( x ) / d <NEWLINE> if d * tmp > d * k : <NEWLINE> <INDENT> return x + d * k <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return f ( ( x + d * tmp ) , ( k - tmp ) , d ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> X , K , D = [ int ( x ) for x in stdin . readline ( ) . rstrip ( ) . split ( ) ] <NEWLINE> print ( abs ( f ( X , K , D ) ) ) <NEWLINE> <DEDENT>
x , k , d = map ( int , input ( ) . split ( ) ) <NEWLINE> x1 = abs ( x ) % d <NEWLINE> x2 = abs ( abs ( x1 ) - d ) <NEWLINE> num = abs ( x ) // d <NEWLINE> if ( ( k - num ) >= 0 ) : <NEWLINE> <INDENT> if ( ( k - num ) % 2 == 0 ) : <NEWLINE> <INDENT> print ( x1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( x2 ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( abs ( x ) - k * d ) <NEWLINE> <DEDENT>
x , k , d = ma - ( int , input ( ) . split ( ) ) <NEWLINE> x = abs ( x ) <NEWLINE> <NL> if x > k * d : <NEWLINE> <INDENT> print ( x - k * d ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> k -= x // d <NEWLINE> x -= ( d * ( x // d ) ) <NEWLINE> and = [ x , abs ( d - x ) ] <NEWLINE> print ( ans [ k % 2 ] ) <NEWLINE> <DEDENT>
X , K , D = map ( int , input ( ) . split ( ) ) <NEWLINE> X = abs ( X ) <NEWLINE> E = X % D <NEWLINE> A = ( X - E ) / D <NEWLINE> A = K - A <NEWLINE> if X >= K * D : <NEWLINE> <INDENT> print ( X - K * D ) <NEWLINE> <DEDENT> eise : <NEWLINE> <INDENT> E = X % D <NEWLINE> A = ( X - E ) / D <NEWLINE> A = K - A <NEWLINE> A = A % 2 <NEWLINE> if A == 0 : <NEWLINE> <INDENT> print ( E ) <NEWLINE> <DEDENT> eise : <NEWLINE> <INDENT> print ( D - E ) <NEWLINE> <DEDENT> <DEDENT>
X , K , D = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> time = 0 <NEWLINE> if X >= 0 : <NEWLINE> <INDENT> while X > 0 : <NEWLINE> <INDENT> X -= D <NEWLINE> time += 1 <NEWLINE> if time == K : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> if ( K - time ) % 2 == 0 : <NEWLINE> print ( abs ( X ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( X + D ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> while X < 0 : <NEWLINE> <INDENT> X += D <NEWLINE> time += 1 <NEWLINE> if time == K : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> if ( K - time ) % 2 == 0 : <NEWLINE> print ( abs ( X ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( X - D ) <NEWLINE> <DEDENT>
X , K , D = ( int ( x ) for x in input ( ) . split ( ) ) <NEWLINE> x = abs ( X ) <NEWLINE> a = x // D <NEWLINE> <NL> b = x - a * D <NEWLINE> B = abs ( x - ( a + 1 ) * D ) <NEWLINE> <NL> if b > B : <NEWLINE> <INDENT> a = a + 1 <NEWLINE> <NL> <DEDENT> if a >= K : <NEWLINE> <INDENT> print ( abs ( x - K * D ) ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> c = K - a <NEWLINE> if c % 2 == 0 : <NEWLINE> <INDENT> print ( abs ( x - a * D ) ) <NEWLINE> <DEDENT> elif : <NEWLINE> <INDENT> d = abs ( x - ( a - 1 ) * D ) <NEWLINE> e = abs ( x - ( a + 1 ) * D ) <NEWLINE> print ( min ( d , e ) ) <NEWLINE> <DEDENT> <DEDENT>
def isEven ( num ) : <NEWLINE> <INDENT> if num % 2 == 0 : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> return False <NEWLINE> <NL> <DEDENT> def isOdd ( num ) : <NEWLINE> <INDENT> if num % 2 == 1 : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> return False <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> x , k , d = map ( int , input ( ) . split ( ) ) <NEWLINE> div = x // d <NEWLINE> cmp = x <NEWLINE> defo = x <NEWLINE> if isOdd ( k ) : <NEWLINE> <INDENT> if x > d : <NEWLINE> <INDENT> if k % div != 0 : <NEWLINE> <INDENT> div = min ( div , k % div ) <NEWLINE> <DEDENT> for i in [ d , - d ] : <NEWLINE> <INDENT> cmp = min ( cmp , abs ( defo + div * i ) ) <NEWLINE> <DEDENT> print ( cmp ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in [ d , - d ] : <NEWLINE> <INDENT> cmp = min ( cmp , abs ( defo + i ) ) <NEWLINE> <DEDENT> print ( cmp ) <NEWLINE> <DEDENT> <DEDENT> if isEven ( k ) : <NEWLINE> <INDENT> div = x // ( 2 * d ) <NEWLINE> if x > d : <NEWLINE> <INDENT> div = min ( div , k ) <NEWLINE> for j in range ( 1 , div ) <NEWLINE> <INDENT> for i in [ d , - d ] : <NEWLINE> <INDENT> cmp = min ( cmp , abs ( defo + ( 2 * j ) * i ) ) <NEWLINE> <DEDENT> <DEDENT> print ( cmp ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( cmp ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
import sys <NEWLINE> x , k , d = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> x = abs ( x ) <NEWLINE> <NL> a = x // d <NEWLINE> <NL> if a >= k : <NEWLINE> <INDENT> ans = x - k * d <NEWLINE> <NL> <DEDENT> elif ( k - a ) % 2 == 0 : <NEWLINE> <INDENT> ans = x - d * m <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> ans = x - d * m - d <NEWLINE> <NL> <DEDENT> print ( abs ( ans ) <NEWLINE>
import math <NEWLINE> <NL> X , K , D = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> a = X - K * D <NEWLINE> if a > 0 : <NEWLINE> <INDENT> print ( a ) <NEWLINE> return <NEWLINE> <DEDENT> if a + 2 * K * D < 0 : <NEWLINE> <INDENT> print ( abs ( a + 2 * K * D ) ) <NEWLINE> return <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> b = a / ( - 2 * D ) <NEWLINE> p = math . floor ( b ) <NEWLINE> q = math . ceil ( b ) <NEWLINE> r = - ( a + 2 * D * p ) <NEWLINE> s = a + 2 * D * q <NEWLINE> print ( min ( r , s ) ) <NEWLINE> return <NEWLINE> <DEDENT>
X , K , D = map ( int , input ( ) . split ( ) ) <NEWLINE> X = abs ( X ) <NEWLINE> if X - K * D > 0 : <NEWLINE> <INDENT> print ( X - K * D ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if K % 2 == 0 : <NEWLINE> <INDENT> s = X - 2 * D * int ( X / ( 2 * D ) ) <NEWLINE> t = - ( s - 2 * D ) <NEWLINE> if s < t : <NEWLINE> <INDENT> print ( s ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( t ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> s = X - 2 * D * int ( ( X - D ) / ( 2 * D ) ) + D <NEWLINE> t = - ( s - 2 * D ) <NEWLINE> r = s - 2 D <NEWLINE> print ( min ( s , t , r ) ) <NEWLINE> <DEDENT> <DEDENT>
x , k , d = list ( map ( int , input . split ( ) ) ) <NEWLINE> syou , amari = divmod ( x , d ) <NEWLINE> if x > 0 : <NEWLINE> <INDENT> if x - k * d == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> elif x - k * d < 0 : <NEWLINE> <INDENT> if amari == 0 : <NEWLINE> <INDENT> newk = k - syou <NEWLINE> if newk % 2 == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( d ) <NEWLINE> <DEDENT> <DEDENT> elif amari != 0 : <NEWLINE> <INDENT> newk = k - syou + 1 <NEWLINE> if newk % 2 == 0 : <NEWLINE> <INDENT> print ( abs ( x - d * ( syou + 1 ) ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( abs ( x - d * syou ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> elif x - k * d > 0 : <NEWLINE> <INDENT> print ( abs ( x - k * d ) ) <NEWLINE> <DEDENT> <DEDENT> if x == 0 : <NEWLINE> <INDENT> if k % 2 == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( d ) <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> <NL> x = abs ( int ( input ( ) ) ) <NEWLINE> k = int ( input ( ) ) <NEWLINE> d = int ( input ( ) ) <NEWLINE> <NL> move_cnt = int ( x / d ) <NEWLINE> if ( move_cnt <= k ) : <NEWLINE> <INDENT> k -= move_cnt <NEWLINE> amari = x - move_cnt * d <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> amari = x - k * d <NEWLINE> k = 0 <NEWLINE> <NL> <DEDENT> if ( k > 0 ) : <NEWLINE> <INDENT> if ( k % 2 == 1 ) : <NEWLINE> <INDENT> if ( amari > 0 ) : <NEWLINE> <INDENT> amari -= d <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> amari += d <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( abs ( amari ) ) <NEWLINE>
import sys <NEWLINE> <NL> def I ( ) : return int ( sys . stdin . readline ( ) . rstrip ( ) ) <NEWLINE> def LI ( ) : return list ( map ( int , sys . stdin . readline ( ) . rstrip ( ) . split ( ) ) ) <NEWLINE> def S ( ) : return sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> def LS ( ) : return list ( sys . stdin . readline ( ) . rstrip ( ) . split ( ) ) <NEWLINE> <NL> X , K , D = LI ( ) <NEWLINE> <NL> sho = X // D <NEWLINE> amari = X % D <NEWLINE> <NL> if ( sho >= K ) : <NEWLINE> <INDENT> saigo = X - ( K * D ) <NEWLINE> print ( abs ( saigo ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> nokori = K - ans ( sho ) <NEWLINE> if nokori % 2 == 0 : <NEWLINE> <INDENT> print ( abs ( amari ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = min ( amari + D , amari - D ) <NEWLINE> print ( abs ( ans ) ) <NEWLINE> <DEDENT> <DEDENT>
x , k , d = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> a = [ abs ( x // d ) , x % d ] <NEWLINE> <NL> if a [ 0 ] > k : <NEWLINE> <INDENT> ans = min ( abs ( x + k * d ) , abs ( x - k * d ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> b = ( k - a [ 0 ] ) % 2 <NEWLINE> ans = min ( abs ( a [ 1 ] + b * d ) , abs ( a [ 1 ] - b * d ) ) <NEWLINE> <NL> <DEDENT> print ( ans ) ) <NEWLINE>
x , k , d = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if x >= 0 : <NEWLINE> <INDENT> a = abs ( x // d ) <NEWLINE> if a <= k : <NEWLINE> <INDENT> if ( k - a ) % 2 == 0 : <NEWLINE> <INDENT> print ( abs ( x - a * d ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( abs ( x - ( a + 1 ) * d ) ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( abs ( x - k * d ) ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if x % d == 0 : <NEWLINE> <INDENT> a = abs ( x // d ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a = abs ( x // d + 1 ) <NEWLINE> <INDENT> if a <= k : <NEWLINE> <INDENT> if ( k - a ) % 2 == 0 : <NEWLINE> <INDENT> print ( abs ( x + a * d ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( abs ( x + ( a + 1 ) * d ) ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( abs ( x + k * d ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT>
x , k , d = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if x >= 0 : <NEWLINE> <INDENT> if x >= k * d : <NEWLINE> <INDENT> print ( x - k * d ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> func ( x , k , d ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if abs ( x ) >= k * d : <NEWLINE> <INDENT> print ( abs ( x ) - k * d ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> func ( x , k , d ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> <DEDENT> <DEDENT> def func ( x , k , d ) : <NEWLINE> <INDENT> q , mod = divmod ( abs ( x ) , d ) <NEWLINE> k -= q <NEWLINE> if k % 2 == 0 : <NEWLINE> <INDENT> print ( mod ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( abs ( mod - d ) ) <NEWLINE> <DEDENT> return 0 <NEWLINE> <DEDENT>
a = abs ( x // d ) <NEWLINE> b = x % d <NEWLINE> <NL> if k <= a : <NEWLINE> <INDENT> print ( abs ( abs ( x ) - k * d ) ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> tmp = k - abs ( a ) <NEWLINE> if tmp % 2 == 0 : <NEWLINE> <INDENT> print ( abs ( x ) - a * d ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( abs ( abs ( x ) - ( a + 1 ) * d ) ) <NEWLINE> <DEDENT> <DEDENT>
X , K , D = list ( map ( int , input ( ) . rstrip ( ) . split ( ) ) ) <NEWLINE> X = abs ( X ) <NEWLINE> a = X // D <NEWLINE> if K <= a : <NEWLINE> <INDENT> print ( abs ( X - ( D * K ) ) ) <NEWLINE> <DEDENT> elif ( K - a ) a % 2 == 0 : <NEWLINE> <INDENT> print ( abs ( X - ( D * a ) ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( abs ( D * ( a + 1 ) - X ) ) <NEWLINE> <DEDENT>
, K , D = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> y = abs ( X ) // D <NEWLINE> <NL> if K <= y : <NEWLINE> <INDENT> print ( abs ( abs ( X ) - K * D ) ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> a = ( X - y * D ) <NEWLINE> b = ( X - ( y + 1 ) * D ) <NEWLINE> <NL> C = abs ( a ) <NEWLINE> D = abs ( b ) <NEWLINE> <NL> if ( K - y ) % 2 == 0 : <NEWLINE> <INDENT> print ( C ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( D ) <NEWLINE> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> X , K , D = map ( int , input ( ) . split ( ) ) <NEWLINE> if X < 0 : X = abs ( X ) <COMMENT> <NEWLINE> <NL> if X // D > K : <NEWLINE> <INDENT> X = X - ( K * D ) <NEWLINE> print ( X ) <NEWLINE> exit . sys ( ) <NEWLINE> <NL> <DEDENT> if X // D < K : <NEWLINE> <INDENT> if X % D >= abs ( ( X % D ) - D ) : <NEWLINE> <INDENT> print ( X % D ) <NEWLINE> exit . sys ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( abs ( ( X % D ) - D ) ) <NEWLINE> exit . sys ( ) <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> x , k , d = map ( int , input ( ) . split ( ) ) <NEWLINE> x = abs ( x ) <NEWLINE> if ( x // d ) >= k : <NEWLINE> <INDENT> ans = x - d * k <NEWLINE> <DEDENT> y = x - ( x // d ) * d <NEWLINE> elif k - ( x // d ) % 2 != 0 : <NEWLINE> <INDENT> ans = y <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = y - d <NEWLINE> <DEDENT> print ( abs ( ans ) ) <NEWLINE>
X , K , D = map ( int , input ( ) . split ( ) ) <NEWLINE> if X + K * D <= 0 : <NEWLINE> <INDENT> print ( - X - K * D ) <NEWLINE> elif X - K * D >= 0 : <NEWLINE> <INDENT> print ( X - K * D ) <NEWLINE> else : <NEWLINE> <INDENT> mod = abs ( X ) // D <NEWLINE> if ( K - mod ) % 2 == 0 : <NEWLINE> <INDENT> print ( abs ( abs ( X ) - K * mod ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( abs ( abs ( X ) - K * ( mod + 1 ) ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT>
x , k , d = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> t = abs ( int ( x / d ) ) <NEWLINE> if x < 0 : <NEWLINE> <INDENT> d = - d <NEWLINE> <DEDENT> if t >= k : <NEWLINE> <INDENT> print ( x - d * k ) <NEWLINE> <DEDENT> elif t == 0 : <NEWLINE> <INDENT> if k % 2 == 0 : <NEWLINE> <INDENT> print ( abs ( x ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( min ( abs ( x - d ) , abs ( x + d ) ) ) <NEWLINE> <DEDENT> <DEDENT> elif t < k : <NEWLINE> <INDENT> if abs ( x - d * t ) < abs ( x - d * t - d ) : <NEWLINE> <INDENT> if ( t - k ) % 2 == 0 : <NEWLINE> <INDENT> print ( abs ( x - d * t ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( min ( abs ( x - d * t + d ) , abs ( x - d * t - d ) ) ) <NEWLINE> <DEDENT> <DEDENT> elif abs ( x - d * t ) = abs ( x - d * t - d ) : <NEWLINE> <INDENT> print ( abs ( x - d * t ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if ( t - k - 1 ) % 2 == 0 : <NEWLINE> <INDENT> print ( abs ( x - d * t - d ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( min ( abs ( x - d * t ) , abs ( x - d * t - 2 * d ) ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
x , k , d = , ap ( int , input ( ) . split ( ) ) <NEWLINE> x = abs ( x ) <NEWLINE> if x - k * d > 0 : <NEWLINE> <INDENT> print ( x - k * d ) <NEWLINE> <DEDENT> elif ( k - x // d ) % 2 == 1 : <NEWLINE> <INDENT> print ( abs ( x % d - d ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( x % d ) <NEWLINE> <DEDENT>
X , K , D = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if X >= K * D : <NEWLINE> <INDENT> print ( X - K * D ) <NEWLINE> <DEDENT> elif X <= K * ( - D ) : <NEWLINE> <INDENT> print ( abs ( X + K * D ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if X >= 0 : <NEWLINE> <INDENT> pos = X % D <NEWLINE> neg = X % D - D <NEWLINE> if K % 2 == ( X // D ) % 2 : <NEWLINE> <INDENT> print ( pos ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( abs ( neg ) ) <NEWLINE> <DEDENT> <DEDENT> if X <= 0 : <NEWLINE> <INDENT> pos = D - ( abs ( X ) % D ) <NEWLINE> neg = - ( abs ( X ) % D ) <NEWLINE> if K % 2 == ( X // D ) % 2 : <NEWLINE> <INDENT> print ( abs ( neg ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( pos ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
X , K , D = map ( int , input ( ) . split ( ) ) <NEWLINE> Ans = 0 <NEWLINE> <NL> if abs ( X ) >= K * D : <NEWLINE> <INDENT> if X >= 0 : <NEWLINE> <INDENT> Ans = X - ( K * D ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> Ans = abs ( X + ( K * D ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> abX = abs ( X ) <NEWLINE> <COMMENT> <NL> if ( K - abX // D ) % 2 == 0 : <NEWLINE> <INDENT> Ans = abX - ( ( abX // D ) * D ) <NEWLINE> else : <NEWLINE> Ans = abs ( abX - ( ( abX // D ) * D ) - D ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> print ( Ans ) <NEWLINE>
X , K , D = map ( int , input ( ) . split ( ) ) <NEWLINE> current_position = X <NEWLINE> <NL> times = abs ( X ) // D <NEWLINE> <NL> if times < K : <NEWLINE> <INDENT> if times > 0 : <NEWLINE> <INDENT> if current_position >= 0 : <NEWLINE> <INDENT> current_position = current_position - D * times <NEWLINE> <DEDENT> elif current_position < 0 : <NEWLINE> <INDENT> current_position = current_position + D * times <NEWLINE> <DEDENT> <DEDENT> K = K - times <NEWLINE> if abs ( current_position ) <= D : <NEWLINE> if K % 2 == 1 : <NEWLINE> <INDENT> if current_position >= 0 : <NEWLINE> <INDENT> current_position = current_position - D <NEWLINE> <DEDENT> elif current_position < 0 : <NEWLINE> <INDENT> current_position = current_position + D <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if times > 0 : <NEWLINE> <INDENT> if current_position >= 0 : <NEWLINE> <INDENT> current_position = current_position - D * times <NEWLINE> <DEDENT> elif current_position < 0 : <NEWLINE> <INDENT> current_position = current_position + D * times <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( current_position ) <NEWLINE> <NL>
x , k , d = map ( int , input ( ) . split ( ) ) <NEWLINE> x = abs ( x ) <NEWLINE> <NL> if x % d == 0 : <NEWLINE> <INDENT> minNear = x % d + d <NEWLINE> minFar = x % d <NEWLINE> minTransitionToNear = ( x - minNear ) / d <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> minNear = x % d <NEWLINE> minFar = x % d - d <NEWLINE> minTransitionToNear = ( x - minPlus ) / d <NEWLINE> <NL> <DEDENT> if k < minTransitionToNear : <NEWLINE> <INDENT> print ( x - k * d ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if ( k - minTransitionToNear ) % 2 == 0 : <NEWLINE> <INDENT> print ( minNear ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( minFar ) <NEWLINE> <DEDENT> <DEDENT>
c = x // d <NEWLINE> <COMMENT> <NL> k_r = k - c <NEWLINE> <COMMENT> <NL> ans_2 = x - d * c <NEWLINE> <COMMENT> <NL> <NL> if c >= k : <NEWLINE> <INDENT> print ( x - k * d ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> x_l = x - d * c <NEWLINE> <COMMENT> <NL> <NL> if k_r % 2 == 0 : <NEWLINE> <INDENT> print ( ans_2 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x_l -= d <NEWLINE> x_l = abs ( x_l ) <NEWLINE> print ( x_l ) <NEWLINE> <DEDENT>
X , K , D = map ( int , input ( ) . split ( ) ) <NEWLINE> a = round ( abs ( X / D ) ) <NEWLINE> if K < a : <NEWLINE> <INDENT> print ( abs ( abs ( X ) - K * abs ( D ) ) ) <NEWLINE> <DEDENT> elif ( K - a ) % 2 == 0 : <NEWLINE> <INDENT> l = [ ] <NEWLINE> l . append ( abs ( abs ( X ) - a * abs ( D ) ) ) <NEWLINE> l . append ( abs ( abs ( X ) - ( a + 2 ) * abs ( D ) ) ) <NEWLINE> l . append ( abs ( abs ( X ) - ( a - 2 ) * abs ( D ) ) ) <NEWLINE> print ( min ( l ) ) <NEWLINE> <DEDENT> elif ( K - a ) % 2 != 0 : <NEWLINE> <INDENT> l = [ ] <NEWLINE> <INDENT> l . append ( abs ( abs ( X ) - ( a + 1 ) * abs ( D ) ) ) <NEWLINE> l . append ( abs ( abs ( X ) - ( a - 1 ) * abs ( D ) ) ) <NEWLINE> <DEDENT> print ( min ( l ) ) <NEWLINE> <DEDENT>
X , K , D = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = 0 <NEWLINE> if X < 0 : <NEWLINE> <INDENT> X = ( - 1 ) * X <NEWLINE> <NL> <DEDENT> if X - K * D >= 0 : <NEWLINE> <INDENT> ans = X - K * D <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> Y = int ( X / D ) <NEWLINE> z = X % D <NEWLINE> if ( K - Y ) % 2 = 0 : <NEWLINE> <INDENT> ans = Z <NEWLINE> <DEDENT> if ( K - Y ) % 2 = 1 : <NEWLINE> <INDENT> ans = D - Z <NEWLINE> <DEDENT> <DEDENT> if ans < 0 : <NEWLINE> <INDENT> ans = ( - 1 ) * ans <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL>
X , K , D = [ int ( n ) for n in input ( ) ] <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> startN = ( D * K - X ) // ( 2 * D ) <NEWLINE> <NL> N1 = startN + 1 <NEWLINE> N2 = startN <NEWLINE> N3 = startN - 1 <NEWLINE> <NL> if N1 < 0 : <NEWLINE> <INDENT> N1 = 0 <NEWLINE> <DEDENT> if N2 < 0 : <NEWLINE> <INDENT> N2 = 0 <NEWLINE> <DEDENT> if N3 < 0 : <NEWLINE> <INDENT> N3 = 0 <NEWLINE> <NL> <DEDENT> def getScore ( n ) : <NEWLINE> <INDENT> score = X + n * D - D * ( K - n ) <NEWLINE> if score < 0 : <NEWLINE> <INDENT> score = score * - 1 <NEWLINE> <DEDENT> return score <NEWLINE> <NL> <DEDENT> score1 = getScore ( N1 ) <NEWLINE> score2 = getScore ( N2 ) <NEWLINE> score3 = getScore ( N3 ) <NEWLINE> <NL> minScore = score1 <NEWLINE> if minScore > score2 : <NEWLINE> <INDENT> minScore = score2 <NEWLINE> <DEDENT> if minScore > score3 : <NEWLINE> <INDENT> minScore = score3 <NEWLINE> <NL> <DEDENT> print ( minScore ) <NEWLINE>
X , K , D = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> X = abs ( X ) <NEWLINE> <NL> if X - K * D <= 0 : <NEWLINE> <INDENT> d = X // D <NEWLINE> K -= d <NEWLINE> x -= D * d <NEWLINE> if K % 2 == 0 : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( abs ( a - d ) ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( X - K * D ) <NEWLINE> <DEDENT>
X , K , D = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> L = X + D * K <NEWLINE> <NL> if X >= 0 : <NEWLINE> <INDENT> if K == 1 or D == 1 : <NEWLINE> <INDENT> print ( abs ( X - D * K ) ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> elif X < 0 : <NEWLINE> <INDENT> if K == 1 or D == 1 : <NEWLINE> <INDENT> print ( abs ( X + D * K ) ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> elif L >= 0 : <NEWLINE> <INDENT> if L / ( 2 * D ) - int ( L / ( 2 * D ) ) > 0.5 : <NEWLINE> <INDENT> a = L // ( 2 * D ) + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a = L // ( 2 * D ) <NEWLINE> <NL> <DEDENT> <DEDENT> elif L < 0 : <NEWLINE> <INDENT> if L / ( 2 * D ) - int ( L / ( 2 * D ) ) < - 0.5 : <NEWLINE> <INDENT> a = int ( L / ( 2 * D ) ) - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a = int ( L / ( 2 * D ) ) <NEWLINE> <DEDENT> <DEDENT> print ( abs ( X - 2 * D * a + D * K ) ) <NEWLINE>
x , k , d = input ( ) . split ( ) <NEWLINE> ans = 0 <NEWLINE> if abs ( x ) > abs ( k * d ) : <NEWLINE> <INDENT> ans = abs ( x ) - abs ( k * d ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> kaisuu = abs ( x ) / d <NEWLINE> k_2 = k - kaisuu <NEWLINE> if k_2 / 2 == 2 : <NEWLINE> <INDENT> ans = abs ( x ) - d * kaisuu <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = ( abs ( x ) - d * kaisuu ) - d <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
x , k , d = map ( int , input ( ) . split ( ) ) <NEWLINE> x = abs ( x ) <NEWLINE> if ( x <= k * d ) : <NEWLINE> <INDENT> print ( x - k * d ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if ( ( k - x // d ) % 2 == 1 ) : <NEWLINE> <INDENT> print ( abs ( x - ( x // d ; 1 ) * d ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( abs ( x - ( x // d ) * d ) ) <NEWLINE> <DEDENT> <DEDENT>
x , k , d = map ( int , input ( ) . split ( ) ) <NEWLINE> x = abs ( x ) <NEWLINE> s = x // d <NEWLINE> elif s > k : <NEWLINE> <INDENT> print ( x - d * k ) <NEWLINE> <DEDENT> elif s < k : <NEWLINE> <INDENT> if ( k - s ) % 2 == 0 : <NEWLINE> <INDENT> print ( x - d * s ) <NEWLINE> <DEDENT> elif ( k - s ) % 2 == 1 : <NEWLINE> <INDENT> print ( abs ( x - d * ( s + 1 ) ) ) <NEWLINE> <DEDENT> <DEDENT>
x , k , d = map ( int , ( input ( ) . split ( ) ) ) <NEWLINE> <NL> zx = x <NEWLINE> if abs ( x ) < d * k : <NEWLINE> <INDENT> wk , x = divmod ( abs ( x ) , d ) <NEWLINE> k -= wk <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> abs ( x ) -= d * k <NEWLINE> k = 0 <NEWLINE> <NL> <DEDENT> for i in range ( k ) : <NEWLINE> <INDENT> xm = abs ( x + d ) <NEWLINE> xu = abs ( x - d ) <NEWLINE> x = min ( xm , xu ) <NEWLINE> k -= 1 <NEWLINE> if zx + x == d : <NEWLINE> <INDENT> if k % 2 != 0 : <NEWLINE> <INDENT> x = zx <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> zx = x <NEWLINE> <NL> <DEDENT> print ( x ) <NEWLINE>
def abc175c_walking_takahashi ( ) : <NEWLINE> <INDENT> x , k , d = map ( int , input ( ) . split ( ) ) <NEWLINE> x = - x if x < 0 else x <NEWLINE> num = math . ceil ( x / d ) <NEWLINE> if num > k : <NEWLINE> <INDENT> print ( x - k * d ) <NEWLINE> return <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> k -= num <NEWLINE> x -= num * d <NEWLINE> if k % 2 == 0 : <NEWLINE> <INDENT> print ( abs ( x ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( x + d ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> abc175c_walking_takahashi ( ) <NEWLINE>
import bisect <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> L = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> cnt = 0 <NEWLINE> L = list ( set ( L ) ) <NEWLINE> L = sorted ( L ) <NEWLINE> <NL> <NL> if N >= 3 : <NEWLINE> <INDENT> for i in range ( len ( L ) - 2 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , len ( L ) - 1 ) : <NEWLINE> <INDENT> ind = bisect . bisect_left ( L , L [ i ] + L [ j ] ) <NEWLINE> cnt += max ( 0 , ind - j ) <NEWLINE> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT>
import math <NEWLINE> <NL> X , K , D = map ( int , input ( ) . split ( ) ) <NEWLINE> tm = round ( X / D ) <NEWLINE> if K <= tm : <NEWLINE> <INDENT> print ( abs ( X + D * K ) if absabs ( X + D * K ) < abs ( X - D * K ) else abs ( X - D * K ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if ( K - tm ) % 2 == 1 : <NEWLINE> <INDENT> print ( abs ( X - D * ( tm + 1 ) ) if abs ( X - D * ( tm + 1 ) ) < abs ( X - D * ( tm - 1 ) ) else abs ( X - D * ( tm - 1 ) ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( abs ( X + D * K ) if absabs ( X + D * K ) < abs ( X - D * K ) else abs ( X - D * K ) ) <NEWLINE> <DEDENT> <DEDENT>
X , K , D = map ( int , input ( ) . split ( ) ) <NEWLINE> if ( abs ( X ) - K * D ) >= 0 : <NEWLINE> <INDENT> print ( abs ( X ) - K * D ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( min ( X % D , abs ( X % D - D ) ) <NEWLINE> <DEDENT>
x , k , d = map ( int , input ( ) . split ( ) ) <NEWLINE> x = abs ( x ) <NEWLINE> s = x // d <NEWLINE> if x - k * d > 0 : <NEWLINE> <INDENT> print ( x - k * d > 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if ( K - s ) % 2 == 0 : <NEWLINE> <INDENT> print ( X - s * D ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - X + ( s + 1 ) * D ) <NEWLINE> <DEDENT> <DEDENT>
x , k , d = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if x < 0 : <NEWLINE> <INDENT> x *= - 1 <NEWLINE> <NL> <DEDENT> if x - k * d < 0 : <NEWLINE> <INDENT> if ( k - ( math . floor ( x / d ) ) ) % 2 == 0 : <NEWLINE> <INDENT> print ( x % d ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( abs ( x % d - d ) ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( x - k * d ) <NEWLINE> <DEDENT>
X , K , D = map ( int , input ( ) . split ( ) ) <NEWLINE> A = abs ( X ) <NEWLINE> ans = 0 <NEWLINE> if A >= D * K : <NEWLINE> <INDENT> print ( A - ( D * K ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> e = A // D <NEWLINE> K -= e <NEWLINE> x %= D <NEWLINE> if K % 2 == 0 : <NEWLINE> <INDENT> print ( x ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( D - x ) <NEWLINE> <DEDENT> <DEDENT>
x , k , d = list ( map ( int , input ( ) . split ( ) ) <NEWLINE> x = abs ( x ) <NEWLINE> a = x // d <NEWLINE> if k >= a : <NEWLINE> <INDENT> if ( k - a ) % 2 == 0 : <NEWLINE> <INDENT> print ( x % d ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( d - ( x % d ) ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( x - ( k * d ) ) <NEWLINE> <DEDENT>
x , k , d = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <NL> def is_even ( num ) : <NEWLINE> <INDENT> if num % 2 == 0 : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return False <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> ans = 0 <NEWLINE> <NL> if 2 * x < d : <NEWLINE> <INDENT> ans = x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> t = x // d <NEWLINE> if k > t - 2 : <NEWLINE> <INDENT> if ( k - t ) / 2 == 0 : <NEWLINE> <INDENT> t0 = abs ( x - ( t - 2 ) * d ) <NEWLINE> t1 = abs ( x - ( t ) * d ) <NEWLINE> t2 = abs ( x - ( t + 2 ) * d ) <NEWLINE> ans = min ( t0 , min ( t1 , t2 ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> t0 = abs ( x - ( t - 1 ) * d ) <NEWLINE> t2 = abs ( x - ( t + 1 ) * d ) <NEWLINE> ans = min ( t0 , min ( t1 , t2 ) ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> ans = abs ( x - ( k ) * d ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
x , k , d = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> elif x >= 0 : <NEWLINE> <INDENT> if x >= k * d : <NEWLINE> <INDENT> print ( x - k * d ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> q , mod = divmod ( x , d ) <NEWLINE> k -= q <NEWLINE> if k % 2 == 0 : <NEWLINE> <INDENT> print ( mod ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( abs ( mod - d ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> elif x < 0 : <NEWLINE> <INDENT> if abs ( x ) >= k * d : <NEWLINE> <INDENT> print ( abs ( x + k * d ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> q , mod = divmod ( abs ( x ) , d ) <NEWLINE> k -= q <NEWLINE> if k % 2 == 0 : <NEWLINE> <INDENT> print ( mod ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( abs ( mod - d ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
import os <NEWLINE> import sys <NEWLINE> <NL> import numpy as np <NEWLINE> <NL> <NL> def solve ( n , k , p , c ) : <NEWLINE> <INDENT> ans = - 10 ** 9 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> x = i <NEWLINE> t = k <NEWLINE> count = 0 <NEWLINE> l = True <NEWLINE> sub = 0 <NEWLINE> ln = 0 <NEWLINE> while True : <NEWLINE> <INDENT> x = p [ x ] - 1 <NEWLINE> if l : <NEWLINE> <INDENT> count += c [ x ] <NEWLINE> ln += 1 <NEWLINE> if x == i : <NEWLINE> <INDENT> if t > ln : <NEWLINE> <INDENT> if count > 0 : <NEWLINE> <INDENT> sub += ( t // ln - 1 ) * count <NEWLINE> t %= ln <NEWLINE> t += ln <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> t = 0 <NEWLINE> <DEDENT> <DEDENT> l = False <NEWLINE> <DEDENT> <DEDENT> sub += c [ x ] <NEWLINE> t -= 1 <NEWLINE> ans = max ( sub , ans ) <NEWLINE> if t < 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return ans <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> if sys . argv [ - 1 ] == <STRING> : <NEWLINE> <INDENT> from numba . pycc import CC <NEWLINE> cc = CC ( <STRING> ) <NEWLINE> cc . export ( <STRING> , <STRING> ) ( main ) <NEWLINE> cc . compile ( ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> from my_module import main <NEWLINE> <COMMENT> <NL> ( n , k ) , p , c = [ np . int_ ( i . split ( ) ) for i in open ( 0 ) ] <NEWLINE> print ( solve ( n , k , p , c ) ) <NEWLINE>
import math <NEWLINE> import numpy as np <NEWLINE> from numba import jit <NEWLINE> <NL> def main ( N , K , plist , slist , max_score ) : <NEWLINE> <INDENT> for start in range ( N ) : <NEWLINE> <INDENT> total_score_in_loop = 0 <NEWLINE> now = start <NEWLINE> score_loop = [ ] <NEWLINE> while True : <NEWLINE> <INDENT> now = plist [ now ] <NEWLINE> total_score_in_loop += slist [ now ] <NEWLINE> score_loop . append ( slist [ now ] ) <NEWLINE> if now == start : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> score_rem = 0 <NEWLINE> loop_score = 0 <NEWLINE> for index , score in enumerate ( score_loop , start = 1 ) : <NEWLINE> <INDENT> score_rem += score <NEWLINE> if total_score_in_loop > 0 : <NEWLINE> <INDENT> loop_score = total_score_in_loop * ( ( K - index ) // len ( score_loop ) ) <NEWLINE> <DEDENT> if max_score < score_rem + loop_score : <NEWLINE> <INDENT> max_score = score_rem + loop_score <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( max_score ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> plist = np . array ( [ i - 1 for i in map ( int , input ( ) . split ( ) ) ] ) <NEWLINE> slist = np . array ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> max_score = - 10 ** 18 <NEWLINE> main ( N , K , plist , slist , max_score ) <NEWLINE> <DEDENT>
def numba_compile ( numba_config ) : <NEWLINE> <INDENT> import os , sys <NEWLINE> if sys . argv [ - 1 ] == <STRING> : <NEWLINE> <INDENT> from numba import njit <NEWLINE> from numba . pycc import CC <NEWLINE> cc = CC ( <STRING> ) <NEWLINE> for func , signature in numba_config : <NEWLINE> <INDENT> globals ( ) [ func . __name__ ] = njit ( signature ) ( func ) <NEWLINE> cc . export ( func . __name__ , signature ) ( func ) <NEWLINE> <DEDENT> cc . compile ( ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> elif os . name == <STRING> : <NEWLINE> <INDENT> exec ( <STRING> ) <NEWLINE> for func , _ in numba_config : <NEWLINE> <INDENT> globals ( ) [ func . __name__ ] = vars ( ) [ func . __name__ ] <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> from numba import njit <NEWLINE> for func , signature in numba_config : <NEWLINE> <INDENT> globals ( ) [ func . __name__ ] = njit ( signature , cache = True ) ( func ) <NEWLINE> <DEDENT> print ( <STRING> , file = sys . stderr ) <NEWLINE> <NL> <DEDENT> <DEDENT> import numpy as np <NEWLINE> <NL> def solve ( N , K , P , C ) : <NEWLINE> <INDENT> ans = - 10 ** 18 <NEWLINE> for start in range ( N ) : <NEWLINE> <INDENT> t = 1 <NEWLINE> s = 0 <NEWLINE> idx = start <NEWLINE> while P [ idx ] != start : <NEWLINE> <INDENT> idx = P [ idx ] <NEWLINE> s += C [ idx ] <NEWLINE> t += 1 <NEWLINE> <DEDENT> s += C [ start ] <NEWLINE> q , m = divmod ( K , t ) <NEWLINE> <COMMENT> <NL> score = 0 <NEWLINE> <COMMENT> <NL> if s >= 0 : <NEWLINE> <INDENT> x = max ( 0 , ( q - 2 ) * t ) <NEWLINE> score += s * ( x // t ) <NEWLINE> <COMMENT> <NL> idx = start <NEWLINE> for _ in range ( x , K ) : <NEWLINE> <INDENT> idx = P [ idx ] <NEWLINE> score += C [ idx ] <NEWLINE> ans = max ( ans , score ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> idx = start <NEWLINE> for _ in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> idx = P [ idx ] <NEWLINE> score += C [ idx ] <NEWLINE> ans = max ( ans , score ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> numba_compile ( [ <NEWLINE> <INDENT> [ solve , <STRING> ] , <NEWLINE> <DEDENT> ] ) <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> P = np . array ( input ( ) . split ( ) , dtype = np . int64 ) - 1 <NEWLINE> C = np . array ( input ( ) . split ( ) , dtype = np . int64 ) <NEWLINE> solve ( N , K , P , C ) <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE>
from numba import njit <NEWLINE> @ njit ( parallel = True ) <NEWLINE> def main ( ) : <NEWLINE> <INDENT> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = - 10 ** 18 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> start , count = i , 1 <NEWLINE> val = c [ start ] <NEWLINE> while p [ start ] - 1 != i : <COMMENT> <NEWLINE> <INDENT> start = p [ start ] - 1 <NEWLINE> count += 1 <NEWLINE> val += c [ start ] <NEWLINE> <DEDENT> start = i <NEWLINE> if val > 0 : <NEWLINE> <INDENT> a = ( k // count - 1 ) * val <COMMENT> <NEWLINE> ans = max ( a , ans ) <NEWLINE> num = count + k % count <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a = 0 <NEWLINE> num = min ( k , count ) <NEWLINE> <DEDENT> for _ in range ( num ) : <NEWLINE> <INDENT> start = p [ start ] - 1 <NEWLINE> a += c [ start ] <NEWLINE> ans = max ( a , ans ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <DEDENT> main ( ) <NEWLINE>
import sys <NEWLINE> import numpy as np <NEWLINE> <COMMENT> <NL> <NL> <COMMENT> <NL> def calcCycle ( N , K , P , C , cycleIDs , cycleItemCnts , cycleTotalScores ) : <NEWLINE> <INDENT> cycleID = 0 <NEWLINE> <NL> for n in range ( N ) : <NEWLINE> <NL> <INDENT> v = n <NEWLINE> currentCycleItemCnt = 0 <NEWLINE> currentCycleTotal = 0 <NEWLINE> <NL> if cycleIDs [ v ] != - 1 : <NEWLINE> <INDENT> continue <NEWLINE> <COMMENT> <NL> <DEDENT> else : <NEWLINE> <INDENT> while True : <NEWLINE> <COMMENT> <NL> <INDENT> currentCycleItemCnt += 1 <NEWLINE> currentCycleTotal += C [ v ] <NEWLINE> <NL> v = P [ v ] <NEWLINE> if v == n : <NEWLINE> <COMMENT> <NL> <INDENT> cycleIDs [ v ] = cycleID <NEWLINE> cycleItemCnts [ cycleID ] = currentCycleItemCnt <NEWLINE> cycleTotalScores [ cycleID ] = currentCycleTotal <NEWLINE> cycleID += 1 <NEWLINE> break <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> cycleIDs [ v ] = cycleID <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> def upd ( procCnt , P , C , K , v , ans , currentCycleSumTmp , currentCycleItemCnt , currentCycleTotal ) : <NEWLINE> <INDENT> currentCycleSumTmp += C [ v ] <NEWLINE> <NL> cycleLoopCnt = 0 <NEWLINE> if 0 < currentCycleTotal : <NEWLINE> <INDENT> cycleLoopCnt = ( K - procCnt ) // currentCycleItemCnt <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> ans = max ( ans , currentCycleSumTmp + cycleLoopCnt * currentCycleTotal ) <NEWLINE> v = P [ v ] <NEWLINE> <NL> return ( currentCycleSumTmp , ans , v ) <NEWLINE> <NL> <NL> <NL> <NL> <DEDENT> def main ( N , K , P , C , cycleIDs , cycleItemCnts , cycleTotalScores ) : <NEWLINE> <NL> <INDENT> ans = - 1e18 <NEWLINE> <NL> for n in range ( N ) : <NEWLINE> <NL> <INDENT> v = n <NEWLINE> currentCycleItemCnt , currentCycleTotal = cycleItemCnts [ cycleIDs [ v ] ] , cycleTotalScores [ cycleIDs [ v ] ] <NEWLINE> <NL> <COMMENT> <NL> currentCycleSumTmp = 0 <NEWLINE> <NL> <NL> for k in range ( min ( K , currentCycleItemCnt ) ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <INDENT> currentCycleSumTmp , ans , v = upd ( k + 1 , P , C , K , v , ans , currentCycleSumTmp , currentCycleItemCnt , currentCycleTotal ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> print ( int ( ans ) ) <NEWLINE> <NL> <DEDENT> if sys . argv [ - 1 ] == <STRING> : <NEWLINE> <COMMENT> <NL> <INDENT> from numba . pycc import CC <NEWLINE> cc = CC ( <STRING> ) <NEWLINE> cc . export ( <STRING> , <STRING> ) ( calcCycle ) <NEWLINE> <COMMENT> <NL> cc . export ( <STRING> , <STRING> ) ( upd ) <NEWLINE> <COMMENT> <NL> cc . compile ( ) <NEWLINE> exit ( 0 ) <NEWLINE> <DEDENT> from my_module import upd , calcCycle <NEWLINE> <COMMENT> <NL> <NL> <NL> <NL> if __name__ == <STRING> : <NEWLINE> <INDENT> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> P = np . array ( input ( ) . split ( ) , np . int64 ) <NEWLINE> P -= 1 <NEWLINE> C = np . array ( input ( ) . split ( ) , np . int64 ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> cycleIDs = np . full ( N , - 1 , dtype = np . int64 ) <NEWLINE> cycleItemCnts = np . full ( N , - 1 , dtype = np . int64 ) <NEWLINE> cycleTotalScores = np . full ( N , - 1 , dtype = np . int64 ) <NEWLINE> <NL> calcCycle ( N , K , P , C , cycleIDs , cycleItemCnts , cycleTotalScores ) <NEWLINE> <NL> <COMMENT> <NL> <NL> <NL> main ( N , K , P , C , cycleIDs , cycleItemCnts , cycleTotalScores ) <NEWLINE> <COMMENT> <NL> <NL> <NL> <DEDENT>
import itertools <NEWLINE> import numpy as np <NEWLINE> <NL> if __name__ == <STRING> : <NEWLINE> <NL> <INDENT> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> P = [ int ( p ) - 1 for p in input ( ) . split ( ) ] <NEWLINE> C = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> cycleIDs = np . full ( N , - 1 , np . int64 ) <NEWLINE> cycleInfs = [ ] <NEWLINE> cycleID = 0 <NEWLINE> procCnt = 0 <NEWLINE> <NL> for n in range ( N ) : <NEWLINE> <INDENT> v = n <NEWLINE> <NL> if cycleIDs [ v ] != - 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> currentCycleCosts = [ ] <NEWLINE> while True : <NEWLINE> <COMMENT> <NL> <INDENT> currentCycleCosts . append ( C [ v ] ) <NEWLINE> cycleIDs [ v ] = cycleID <NEWLINE> <NL> v = P [ v ] <NEWLINE> if cycleIDs [ v ] != - 1 : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <INDENT> procCnt = K % len ( currentCycleCosts ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> if procCnt == 0 : <NEWLINE> <INDENT> procCnt = len ( currentCycleCosts ) <NEWLINE> <NL> <DEDENT> cycleInfs . append ( ( procCnt , np . array ( currentCycleCosts ) ) ) <NEWLINE> cycleID += 1 <NEWLINE> break <NEWLINE> <NL> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> scores = [ ] <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> for procCnt , currentCycleCosts in cycleInfs : <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <INDENT> for i in range ( currentCycleCosts . size ) : <NEWLINE> <INDENT> if np . sum ( currentCycleCosts ) > 0 : <NEWLINE> <COMMENT> <NL> <INDENT> scores . append ( np . roll ( currentCycleCosts , i ) [ : procCnt ] . cumsum ( ) . max ( ) ) + ( ( K - procCnt ) // currentCycleCosts . size ) * np . sum ( currentCycleCosts ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> scores . append ( np . roll ( currentCycleCosts , i ) [ : procCnt ] . cumsum ( ) . max ( ) ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> print ( max ( scores ) ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> import sys <NEWLINE> from numba import njit , i8 <NEWLINE> <NL> input = sys . stdin . readline <NEWLINE> <NL> R , C , K = map ( int , input ( ) . split ( ) ) <NEWLINE> table = [ [ 0 ] * ( C + 1 ) for _ in range ( R + 1 ) ] <NEWLINE> for _ in range ( K ) : <NEWLINE> <INDENT> r , c , v = map ( int , input ( ) . split ( ) ) <NEWLINE> table [ r ] [ c ] = v <NEWLINE> <DEDENT> table = np . array ( table , dtype = np . int64 ) <NEWLINE> <NL> <NL> @ njit ( ( i8 , i8 , i8 [ : , : ] ) , cache = True ) <NEWLINE> def solve ( R , C , table ) : <NEWLINE> <INDENT> dp = np . zeros ( ( R + 1 , C + 1 , 4 ) , dtype = np . int64 ) <NEWLINE> for r in range ( 1 , R + 1 ) : <NEWLINE> <INDENT> for c in range ( 1 , C + 1 ) : <NEWLINE> <INDENT> m = dp [ r - 1 , c ] . max ( ) <NEWLINE> dp [ r , c ] = np . maximum ( m , dp [ r , c - 1 ] ) <NEWLINE> if table [ r ] [ c ] is not None : <NEWLINE> <INDENT> dp [ r , c , 1 : ] = np . maximum ( dp [ r , c , 1 : ] , <NEWLINE> <INDENT> np . maximum ( m , dp [ r , c - 1 , : - 1 ] ) + table [ r ] [ c ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> return dp [ - 1 , - 1 ] . max ( ) <NEWLINE> <NL> <NL> <DEDENT> print ( solve ( R , C , table ) ) <NEWLINE>
import numpy as np <NEWLINE> from numba import njit <NEWLINE> <NL> rr , cc , kk = map ( int , input ( ) . split ( ) ) <NEWLINE> goods = np . array ( [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( kk ) ] , dtype = np . int ) <NEWLINE> gg = np . zeros ( ( rr , cc ) , dtype = np . int ) <NEWLINE> for cr , ccc , ck in goods : <NEWLINE> <INDENT> gg [ cr - 1 ] [ ccc - 1 ] = ck <NEWLINE> <NL> <DEDENT> @ njit ( cache = True ) <NEWLINE> def calc ( r , c , g ) : <NEWLINE> <INDENT> dp = - 1 * np . ones ( ( r + 1 , c + 1 , 4 ) , dtype = np . int ) <NEWLINE> maxlst = np . zeros ( ( r + 1 , c + 1 ) , dtype = np . int ) <NEWLINE> <NL> dp [ : , 0 , 0 ] = 0 <NEWLINE> dp [ 0 , : , 0 ] = 0 <NEWLINE> <NL> for i in range ( r ) : <NEWLINE> <INDENT> for j in range ( c ) : <NEWLINE> <INDENT> tmp = 0 <NEWLINE> for k in range ( 3 ) : <NEWLINE> <INDENT> if g [ i ] [ j ] > 0 and dp [ i + 1 ] [ j ] [ k ] >= 0 : <NEWLINE> <INDENT> dp [ i + 1 ] [ j + 1 ] [ k + 1 ] = max ( dp [ i + 1 ] [ j ] [ k + 1 ] , dp [ i + 1 ] [ j ] [ k ] + g [ i ] [ j ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dp [ i + 1 ] [ j + 1 ] [ k + 1 ] = dp [ i + 1 ] [ j ] [ k + 1 ] <NEWLINE> <DEDENT> tmp = max ( tmp , dp [ i + 1 ] [ j + 1 ] [ k + 1 ] ) <NEWLINE> <NL> <DEDENT> dp [ i + 1 ] [ j + 1 ] [ 0 ] = max ( maxlst [ i ] [ j + 1 ] , dp [ i + 1 ] [ j ] [ 0 ] ) <NEWLINE> tmp = max ( tmp , dp [ i + 1 ] [ j + 1 ] [ 0 ] ) <NEWLINE> <NL> if g [ i ] [ j ] > 0 and dp [ i + 1 ] [ j + 1 ] [ 0 ] >= 0 : <NEWLINE> <INDENT> dp [ i + 1 ] [ j + 1 ] [ 1 ] = max ( dp [ i + 1 ] [ j + 1 ] [ 1 ] , dp [ i + 1 ] [ j + 1 ] [ 0 ] + g [ i ] [ j ] ) <NEWLINE> tmp = max ( tmp , dp [ i + 1 ] [ j + 1 ] [ 1 ] ) <NEWLINE> <NL> <DEDENT> maxlst [ i + 1 ] [ j + 1 ] = tmp <NEWLINE> <NL> <DEDENT> <DEDENT> return maxlst [ r ] [ c ] <NEWLINE> <NL> <DEDENT> print ( calc ( rr , cc , gg ) ) <NEWLINE>
import numpy as np <NEWLINE> from numba import njit <NEWLINE> @ njit <NEWLINE> def main ( ) : <NEWLINE> <INDENT> R , C , K = map ( int , input ( ) . split ( ) ) <NEWLINE> scores = np . zeros ( ( R , C ) , np . int64 ) <NEWLINE> for _ in range ( K ) : <NEWLINE> <INDENT> r , c , v = map ( int , input ( ) . split ( ) ) <NEWLINE> scores [ r - 1 ] [ c - 1 ] = v <NEWLINE> <DEDENT> dp = np . zeros ( ( R + 1 , C + 1 , 4 ) , np . int64 ) <NEWLINE> <NL> for i in range ( 1 , R + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , C + 1 ) : <NEWLINE> <INDENT> for k in range ( 4 ) : <NEWLINE> <INDENT> dp [ i ] [ j ] [ k ] = max ( dp [ i ] [ j - 1 ] [ k ] , <NEWLINE> <INDENT> dp [ i - 1 ] [ j ] [ 3 ] ) <NEWLINE> <DEDENT> <DEDENT> for k in range ( 3 , 0 , - 1 ) : <NEWLINE> <INDENT> dp [ i ] [ j ] [ k ] = max ( dp [ i ] [ j ] [ k ] , <NEWLINE> <INDENT> dp [ i ] [ j ] [ k - 1 ] + scores [ i - 1 ] [ j - 1 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> answer = dp [ R ] [ C ] [ 3 ] <NEWLINE> print ( answer ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> from numba import njit , i8 <NEWLINE> <NL> <NL> R , C , K = map ( int , input ( ) . split ( ) ) <NEWLINE> rcvs = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( K ) ] <NEWLINE> <NL> @ njit <NEWLINE> def solve ( rcvs ) : <NEWLINE> <INDENT> rcvs = np . array ( rcvs , dtype = np . int64 ) <NEWLINE> <NL> for i in range ( len ( rcvs ) ) : <NEWLINE> <INDENT> rcvs [ i , 0 ] -= 1 <NEWLINE> rcvs [ i , 1 ] -= 1 <NEWLINE> <NL> <DEDENT> rewards = np . array ( [ [ 0 for _ in range ( C ) ] for _ in range ( R ) ] , dtype = np . int64 ) <NEWLINE> <NL> for rcv in rcvs : <NEWLINE> <INDENT> rewards [ rcv [ 0 ] , rcv [ 1 ] ] = rcv [ 2 ] <NEWLINE> <NL> <DEDENT> dp = np . array ( [ [ [ 0 for _ in range ( 4 ) ] for _ in range ( C + 1 ) ] for _ in range ( R + 1 ) ] , dtype = np . int64 ) <NEWLINE> <NL> for i in range ( R ) : <NEWLINE> <INDENT> for j in range ( C ) : <NEWLINE> <INDENT> reward = rewards [ i ] [ j ] <NEWLINE> dp [ i + 1 , j + 1 , 0 ] = max ( dp [ i , j + 1 ] ) <NEWLINE> dp [ i + 1 , j + 1 , 1 ] = dp [ i + 1 , j + 1 , 0 ] + reward <NEWLINE> <NL> for k in range ( 4 ) : <COMMENT> <NEWLINE> <INDENT> dp [ i + 1 , j + 1 , k ] = max ( dp [ i + 1 , j , k ] , dp [ i + 1 , j + 1 , k ] ) <NEWLINE> <DEDENT> for k in range ( 3 ) : <NEWLINE> <INDENT> dp [ i + 1 , j + 1 , k + 1 ] = max ( dp [ i + 1 , j , k ] + reward , dp [ i + 1 , j + 1 , k + 1 ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( np . max ( dp [ - 1 , - 1 ] ) ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> solve ( rcvs ) <NEWLINE> <DEDENT>
from namba import jit <NEWLINE> import numpy as np <NEWLINE> @ jit <NEWLINE> def main ( ) : <NEWLINE> <INDENT> R , C , K = map ( int , input ( ) . split ( ) ) <NEWLINE> scores = np . zeros ( ( R , C ) , np . int64 ) <NEWLINE> for _ in range ( K ) : <COMMENT> <NEWLINE> <INDENT> r , c , v = map ( int , input ( ) . split ( ) ) <NEWLINE> scores [ r - 1 ] [ c - 1 ] = v <NEWLINE> <DEDENT> dp = np . zeros ( ( R + 1 , C + 1 , 4 ) , np . int64 ) <COMMENT> <NEWLINE> for i in range ( 1 , R + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , C + 1 ) : <NEWLINE> <INDENT> for k in range ( 4 ) : <NEWLINE> <INDENT> dp [ i ] [ j ] [ k ] = max ( dp [ i ] [ j - 1 ] [ k ] , dp [ i - 1 ] [ j ] [ 3 ] ) <COMMENT> <NEWLINE> <DEDENT> for k in range ( 3 , 0 , - 1 ) : <NEWLINE> <INDENT> dp [ i ] [ j ] [ k ] = max ( dp [ i ] [ j ] [ k ] , dp [ i ] [ j ] [ k - 1 ] + scores [ i - 1 ] [ j - 1 ] ) <COMMENT> <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return dp [ R ] [ C ] [ 3 ] <NEWLINE> <DEDENT> print ( main ( ) ) <NEWLINE>
import numba <NEWLINE> from numba import jit <NEWLINE> import numpy as np <NEWLINE> <NL> def main ( r , c ) : <NEWLINE> <INDENT> dp = np . zeros ( ( c + 1 , 4 ) , np . int64 ) <NEWLINE> for i in range ( r ) : <NEWLINE> <INDENT> new_dp = np . zeros ( ( c + 1 , 4 ) , np . int64 ) <NEWLINE> for j in range ( 4 ) : <NEWLINE> <INDENT> new_dp [ : , 0 ] = np . maximum ( new_dp [ : , 0 ] , dp [ : , j ] ) <NEWLINE> <DEDENT> dp = new_dp <NEWLINE> for k in range ( c ) : <NEWLINE> <INDENT> for l in range ( 2 , - 1 , - 1 ) : <NEWLINE> <INDENT> dp [ k , l + 1 ] = max ( dp [ k , l + 1 ] , dp [ k , l ] + item_map [ i , k ] ) <NEWLINE> <DEDENT> for m in range ( 1 , 4 ) : <NEWLINE> <INDENT> dp [ k + 1 , m ] = max ( dp [ k + 1 , m ] , dp [ k , m ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return max ( dp [ c - 1 , : ] ) <NEWLINE> <NL> <DEDENT> R , C , K = map ( int , input ( ) . split ( ) ) <NEWLINE> item_lis = list ( list ( map ( int , input ( ) . split ( ) ) ) for i in range ( K ) ) <NEWLINE> item_map = np . zeros ( ( R , C ) , np . int64 ) <NEWLINE> for i , j , k in item_lis : <NEWLINE> <INDENT> item_map [ i - 1 , j - 1 ] = k <NEWLINE> <NL> <DEDENT> print ( main ( R , C ) ) <NEWLINE> import numpy as np <NEWLINE> <NL> def main ( r , c ) : <NEWLINE> <INDENT> dp = np . zeros ( ( c + 1 , 4 ) , np . int64 ) <NEWLINE> for i in range ( r ) : <NEWLINE> <INDENT> new_dp = np . zeros ( ( c + 1 , 4 ) , np . int64 ) <NEWLINE> for j in range ( 4 ) : <NEWLINE> <INDENT> new_dp [ : , 0 ] = np . maximum ( new_dp [ : , 0 ] , dp [ : , j ] ) <NEWLINE> <DEDENT> dp = new_dp <NEWLINE> for k in range ( c ) : <NEWLINE> <INDENT> for l in range ( 2 , - 1 , - 1 ) : <NEWLINE> <INDENT> dp [ k , l + 1 ] = max ( dp [ k , l + 1 ] , dp [ k , l ] + item_map [ i , k ] ) <NEWLINE> <DEDENT> for m in range ( 1 , 4 ) : <NEWLINE> <INDENT> dp [ k + 1 , m ] = max ( dp [ k + 1 , m ] , dp [ k , m ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return max ( dp [ c - 1 , : ] ) <NEWLINE> <NL> <DEDENT> R , C , K = map ( int , input ( ) . split ( ) ) <NEWLINE> item_lis = list ( list ( map ( int , input ( ) . split ( ) ) ) for i in range ( K ) ) <NEWLINE> item_map = np . zeros ( ( R , C ) , np . int64 ) <NEWLINE> for i , j , k in item_lis : <NEWLINE> <INDENT> item_map [ i - 1 , j - 1 ] = k <NEWLINE> <NL> <DEDENT> print ( main ( R , C ) ) <NEWLINE>  <NEWLINE>  <NEWLINE>
import sys <NEWLINE> import numpy as np <NEWLINE> import numba <NEWLINE> from numba import njit , b1 , i4 , i8 , f8 <NEWLINE> read = sys . stdin . buffer . read <NEWLINE> <NL> @ njit ( ( i8 , i8 , i8 , i8 [ : ] ) , cache = True ) <NEWLINE> def solve ( R , C , K , XYV ) : <NEWLINE> <INDENT> item = np . zeros ( ( R + 1 , C + 1 ) , dtype = np . int64 ) <NEWLINE> for i in range ( 0 , 3 * K , 3 ) : <NEWLINE> <INDENT> x , y , v = XYV [ i : i + 3 ] <NEWLINE> item [ x - 1 , y - 1 ] = v <NEWLINE> <DEDENT> dp = np . zeros ( ( C + 1 , 4 ) , dtype = np . int64 ) <NEWLINE> for i in range ( 1 , R + 1 ) : <NEWLINE> <INDENT> new_dp = np . zeros ( ( C + 1 , 4 ) , dtype = np . int64 ) <NEWLINE> <COMMENT> <NL> for k in range ( 4 ) : <NEWLINE> <INDENT> new_dp [ : , 0 ] = np . maximum ( new_dp [ : , 0 ] , dp [ : , k ] ) <NEWLINE> <DEDENT> dp = new_dp <NEWLINE> for j in range ( 1 , C + 1 ) : <NEWLINE> <COMMENT> <NL> <INDENT> new_dp [ j ] = np . maximum ( new_dp [ j ] , new_dp [ j - 1 ] ) <NEWLINE> <COMMENT> <NL> for k in range ( 2 , - 1 , - 1 ) : <NEWLINE> <INDENT> dp [ j , k + 1 ] = np . maximum ( dp [ j , k + 1 ] , dp [ j , k ] + item [ i - 1 , j - 1 ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> ans = dp [ - 1 ] . max ( ) <NEWLINE> return ans <NEWLINE> <NL> <DEDENT> R , C , K = map ( int , input ( ) . split ( ) ) <NEWLINE> XYV = np . array ( read ( ) . split ( ) , np . int64 ) <NEWLINE> print ( solve ( R , C , K , XYV ) ) <NEWLINE>
<STRING> <NEWLINE> <NL> import numpy as np <NEWLINE> from numba import njit <NEWLINE> def main ( ) : <NEWLINE> <INDENT> R , C , K = map ( int , input ( ) . split ( ) ) <NEWLINE> field = np . full ( ( R + 1 , C + 1 ) , 0 ) <NEWLINE> dpt = np . full ( ( R + 1 , C + 1 , 4 ) , 0 ) <NEWLINE> for i in range ( K ) : <NEWLINE> <INDENT> r , c , v = map ( int , input ( ) . split ( ) ) <NEWLINE> field [ r ] [ c ] = v <NEWLINE> <DEDENT> dp ( R , C , field , dpt ) <NEWLINE> print ( max ( dpt [ - 1 ] [ - 1 ] ) ) <NEWLINE> <NL> <DEDENT> def dp ( R , C , field , dpt ) : <NEWLINE> <INDENT> for r in range ( 1 , R + 1 ) : <NEWLINE> <INDENT> for c in range ( 1 , C + 1 ) : <NEWLINE> <INDENT> for taken in range ( 4 ) : <NEWLINE> <INDENT> max_v = 0 <NEWLINE> if taken == 0 : <NEWLINE> <INDENT> max_v = max ( dpt [ r - 1 ] [ c ] ) <NEWLINE> max_v = max ( dpt [ r ] [ c - 1 ] [ 0 ] , max_v ) <NEWLINE> <DEDENT> elif taken == 1 : <NEWLINE> <INDENT> max_v = max ( dpt [ r ] [ c - 1 ] [ taken - 1 ] + field [ r ] [ c ] , <NEWLINE> <INDENT> dpt [ r ] [ c - 1 ] [ taken ] , <NEWLINE> max ( dpt [ r - 1 ] [ c ] ) + field [ r ] [ c ] ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> max_v = max ( dpt [ r ] [ c - 1 ] [ taken - 1 ] + field [ r ] [ c ] , <NEWLINE> <INDENT> dpt [ r ] [ c - 1 ] [ taken ] ) <NEWLINE> <DEDENT> <DEDENT> dpt [ r ] [ c ] [ taken ] = max_v <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return True <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> import sys <NEWLINE> <COMMENT> <NL> sysread = sys . stdin . buffer . readline <NEWLINE> read = sys . stdin . buffer . read <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> import numpy as np <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> from numba import jit <NEWLINE> <NL> @ jit <NEWLINE> def run_dp ( MAP , dp , R , C ) : <NEWLINE> <INDENT> for i in range ( 1 , R + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , C + 1 ) : <NEWLINE> <INDENT> for k in range ( 4 ) : <NEWLINE> <INDENT> dp [ i , j , 0 ] = max ( dp [ i , j , 0 ] , dp [ i - 1 , j , k ] ) <NEWLINE> if MAP [ i , j ] : <NEWLINE> <INDENT> dp [ i , j , 1 ] = max ( dp [ i , j , 1 ] , dp [ i - 1 , j , k ] + MAP [ i , j ] ) <NEWLINE> <NL> <DEDENT> dp [ i , j , k ] = max ( dp [ i , j , k ] , dp [ i , j - 1 , k ] ) <NEWLINE> if MAP [ i ] [ j ] and k < 3 : <NEWLINE> <INDENT> dp [ i , j , k + 1 ] = max ( dp [ i , j , k + 1 ] , dp [ i , j - 1 , k ] + MAP [ i , j ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> return dp [ R , C ] . max ( ) <NEWLINE> <NL> <DEDENT> def run ( ) : <NEWLINE> <INDENT> R , C , K = map ( int , sysread ( ) . split ( ) ) <NEWLINE> MAP = np . zeros ( ( R + 1 , C + 1 ) , dtype = np . int64 ) <NEWLINE> for i in range ( K ) : <NEWLINE> <INDENT> r , c , v = map ( int , sysread ( ) . split ( ) ) <NEWLINE> MAP [ r , c ] = v <NEWLINE> <NL> <DEDENT> dp = np . zeros ( ( R + 1 , C + 1 , 4 ) , dtype = np . int64 ) <NEWLINE> <NL> run_dp ( MAP , dp , R , C ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> ans = run_dp ( MAP , dp , Rs , Cs ) <NEWLINE> <NL> print ( ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> run ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> import numpy as np <NEWLINE> from collections import defaultdict <NEWLINE> from numba import njit <NEWLINE> def input ( ) : return sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> <NL> @ njit <NEWLINE> def koushin ( dp , item ) : <NEWLINE> <INDENT> dptmp1 = np . copy ( dp ) <NEWLINE> dptmp2 = np . copy ( dp ) <NEWLINE> dptmp3 = np . copy ( dp ) <NEWLINE> for i in range ( len ( item ) ) : <NEWLINE> <INDENT> dptmp3 [ item [ i ] [ 0 ] : ] = np . fmax ( dptmp3 [ item [ i ] [ 0 ] : ] , dptmp2 [ item [ i ] [ 0 ] ] + item [ i ] [ 1 ] ) <NEWLINE> dptmp2 [ item [ i ] [ 0 ] : ] = np . fmax ( dptmp2 [ item [ i ] [ 0 ] : ] , dptmp1 [ item [ i ] [ 0 ] ] + item [ i ] [ 1 ] ) <NEWLINE> dptmp1 [ item [ i ] [ 0 ] : ] = np . fmax ( dptmp1 [ item [ i ] [ 0 ] : ] , dp [ item [ i ] [ 0 ] ] + item [ i ] [ 1 ] ) <NEWLINE> <DEDENT> return dptmp3 <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> R , C , K = map ( int , input ( ) . split ( ) ) <NEWLINE> items = defaultdict ( list ) <NEWLINE> for _ in range ( K ) : <NEWLINE> <INDENT> r , c , v = map ( int , input ( ) . split ( ) ) <NEWLINE> items [ r - 1 ] . append ( [ c - 1 , v ] ) <NEWLINE> <DEDENT> dp = np . zeros ( C , dtype = int ) <NEWLINE> for RR in range ( R ) : <NEWLINE> <INDENT> items [ RR ] . sort ( key = lambda x : x [ 0 ] ) <NEWLINE> dp = koushin ( dp , np . array ( items [ RR ] , dtype = int ) ) <NEWLINE> <DEDENT> print ( dp [ - 1 ] ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> from numba import njit <NEWLINE> <NL> R , C , K = map ( int , input ( ) . split ( ) ) <NEWLINE> item = [ [ 0 ] * C for _ in range ( R ) ] <NEWLINE> for s in sys . stdin . readlines ( ) : <NEWLINE> <INDENT> r , c , v = map ( int , s . split ( ) ) <NEWLINE> item [ r - 1 ] [ c - 1 ] = v <NEWLINE> <NL> <DEDENT> @ njit <NEWLINE> def solve ( R , C , K , item ) : <NEWLINE> <INDENT> DP = [ [ [ 0 , 0 , 0 , 0 ] for _ in range ( C ) ] for _ in range ( R ) ] <NEWLINE> <NL> DP [ 0 ] [ 0 ] [ 1 ] = item [ 0 ] [ 0 ] <NEWLINE> <NL> for i in range ( R ) : <NEWLINE> <INDENT> for j in range ( C ) : <NEWLINE> <INDENT> for k in range ( 4 ) : <NEWLINE> <INDENT> if i > 0 : <COMMENT> <NEWLINE> <INDENT> DP [ i ] [ j ] [ 0 ] = max ( DP [ i ] [ j ] [ 0 ] , max ( DP [ i - 1 ] [ j ] ) ) <COMMENT> <NEWLINE> DP [ i ] [ j ] [ 1 ] = max ( DP [ i ] [ j ] [ 1 ] , max ( DP [ i - 1 ] [ j ] ) + item [ i ] [ j ] ) <COMMENT> <NEWLINE> <NL> <DEDENT> if j > 0 : <COMMENT> <NEWLINE> <INDENT> DP [ i ] [ j ] [ k ] = max ( DP [ i ] [ j ] [ k ] , DP [ i ] [ j - 1 ] [ k ] ) <COMMENT> <NEWLINE> if k >= 1 : <NEWLINE> <INDENT> DP [ i ] [ j ] [ k ] = max ( DP [ i ] [ j ] [ k ] , DP [ i ] [ j - 1 ] [ k - 1 ] + item [ i ] [ j ] ) <COMMENT> <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( max ( DP [ R - 1 ] [ C - 1 ] ) ) <NEWLINE> <NL> <DEDENT> solve ( R , C , K , item ) <NEWLINE>
import sys <NEWLINE> import numpy as np <NEWLINE> from numba import jit , void , i8 <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> R , C , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> L_INF = int ( 1e17 ) <NEWLINE> dp = np . full ( ( R + 1 , C + 1 , 4 ) , - L_INF , dtype = np . int64 ) <NEWLINE> cell = np . full ( ( R + 1 , C + 1 ) , 0 , dtype = np . int64 ) <NEWLINE> <NL> for i in range ( K ) : <NEWLINE> <INDENT> x , y , c = map ( int , input ( ) . split ( ) ) <NEWLINE> cell [ x - 1 ] [ y - 1 ] = c <NEWLINE> <NL> <DEDENT> f ( dp , cell , R , C ) <NEWLINE> <NL> print ( dp [ R ] [ C ] [ 3 ] ) <NEWLINE> <NL> <DEDENT> @ njit ( void ( i8 [ : , : , : ] , i8 [ : , : ] , i8 , i8 ) ) <NEWLINE> def f ( dp , cell , R , C ) : <NEWLINE> <INDENT> dp [ 0 ] [ 1 ] [ 0 ] = dp [ 1 ] [ 0 ] [ 0 ] = 0 <NEWLINE> for i in range ( 1 , R + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , C + 1 ) : <NEWLINE> <INDENT> for k in range ( 4 ) : <NEWLINE> <INDENT> if k > 0 : <NEWLINE> <INDENT> dp [ i ] [ j ] [ k ] = max ( dp [ i ] [ j ] [ k ] , dp [ i ] [ j ] [ k - 1 ] ) <NEWLINE> <DEDENT> dp [ i ] [ j ] [ k ] = max ( dp [ i ] [ j ] [ k ] , dp [ i ] [ j - 1 ] [ k ] ) <NEWLINE> if k > 0 : <NEWLINE> <INDENT> dp [ i ] [ j ] [ k ] = max ( dp [ i ] [ j ] [ k ] , dp [ i ] [ j - 1 ] [ k - 1 ] + cell [ i - 1 ] [ j - 1 ] ) <NEWLINE> <DEDENT> if k == 1 : <NEWLINE> <INDENT> dp [ i ] [ j ] [ k ] = max ( dp [ i ] [ j ] [ 1 ] , dp [ i - 1 ] [ j ] [ 3 ] + cell [ i - 1 ] [ j - 1 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
from decimal import Decimal <NEWLINE> <NL> N , * A = map ( Decimal , open ( 0 ) . read ( ) . split ( ) ) <NEWLINE> N = int ( N ) <NEWLINE> <NL> d = { } <NEWLINE> for a in A : <NEWLINE> <INDENT> a = int ( a * ( 10 ** 9 ) ) <NEWLINE> x = - 9 <NEWLINE> while a % 2 == 0 : <NEWLINE> <INDENT> x += 1 <NEWLINE> a %= 2 <NEWLINE> <DEDENT> y = - 9 <NEWLINE> while a % 5 == 0 : <NEWLINE> <INDENT> y += 1 <NEWLINE> a %= 5 <NEWLINE> <DEDENT> t = ( x , y ) <NEWLINE> d . setdefault ( t , 0 ) <NEWLINE> d [ t ] += 1 <NEWLINE> <NL> <DEDENT> result = 0 <NEWLINE> xs = d . values ( ) <NEWLINE> for i in range ( len ( xs ) ) : <NEWLINE> <INDENT> x , y = xs [ i ] <NEWLINE> for j in range ( i + 1 , len ( xs ) ) : <NEWLINE> <INDENT> m , n = xs [ j ] <NEWLINE> if x + m >= 0 and y + n >= 0 : <NEWLINE> <INDENT> result += d [ xs [ i ] ] * d [ xs [ j ] ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( result ) <NEWLINE>
import sys <NEWLINE> from decimal import Decimal <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> <NL> def divide ( n ) : <NEWLINE> <INDENT> c1 , c2 = 0 , 0 <NEWLINE> while ( n % 2 == 0 ) : <NEWLINE> <INDENT> c1 += 1 <NEWLINE> n //= 2 <NEWLINE> <DEDENT> while ( n % 5 == 0 ) : <NEWLINE> <INDENT> c2 += 1 <NEWLINE> n //= 5 <NEWLINE> <DEDENT> c1 , c2 = min ( 18 , c1 ) , min ( 18 , c2 ) <NEWLINE> return ( c1 , c2 ) <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> a = [ divide ( int ( Decimal ( float ( input ( ) ) ) * 1e9 ) ) for _ in range ( n ) ] <NEWLINE> <NL> dp = [ [ 0 ] * 20 for _ in range ( 20 ) ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> c1 , c2 = a [ i ] <NEWLINE> dp [ c1 ] [ c2 ] += 1 <NEWLINE> <NL> <DEDENT> for i in range ( 18 , - 1 , - 1 ) : <NEWLINE> <INDENT> for j in range ( 18 , - 1 , - 1 ) : <NEWLINE> <INDENT> dp [ i ] [ j ] += dp [ i + 1 ] [ j ] + dp [ i ] [ j + 1 ] - dp [ i + 1 ] [ j + 1 ] <NEWLINE> <NL> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> c1 , c2 = a [ i ] <NEWLINE> if ( c1 >= 9 and c2 >= 9 ) : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <DEDENT> ans += dp [ 18 - c1 ] [ 18 - c2 ] <NEWLINE> <NL> <DEDENT> print ( ans // 2 ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> from decimal import Decimal as D <NEWLINE> <COMMENT> <NL> excel = [ [ 0 ] * 20 for i in range ( 50 ) ] <NEWLINE> query = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> q = input ( ) <NEWLINE> q = D ( q ) <NEWLINE> q = int ( q * 10 ** 9 ) <NEWLINE> num2 = 0 ; num5 = 0 <NEWLINE> k = q <NEWLINE> for i in range ( 50 ) : <NEWLINE> <INDENT> if k % 2 == 0 : <NEWLINE> <INDENT> k //= 2 <NEWLINE> num2 += 1 <NEWLINE> <DEDENT> else : break <NEWLINE> <DEDENT> k = q <NEWLINE> for i in range ( 20 ) : <NEWLINE> <INDENT> if k % 5 == 0 : <NEWLINE> <INDENT> k //= 5 <NEWLINE> num5 += 1 <NEWLINE> <DEDENT> else : break <NEWLINE> <DEDENT> excel [ num2 ] [ num5 ] += 1 <NEWLINE> query . append ( [ max ( 0 , 18 - num2 ) , max ( 0 , 18 - num5 ) ] ) <NEWLINE> <NL> <DEDENT> A = [ [ 0 ] * 20 for i in range ( 50 ) ] <COMMENT> <NEWLINE> for i in range ( 49 , - 1 , - 1 ) : <NEWLINE> <INDENT> for j in range ( 19 , - 1 , - 1 ) : <NEWLINE> <INDENT> if i == 49 and j == 19 : <NEWLINE> <INDENT> A [ i ] [ j ] = excel [ i ] [ j ] <NEWLINE> <DEDENT> elif i == 49 : <NEWLINE> <INDENT> A [ i ] [ j ] = A [ i ] [ j + 1 ] + excel [ i ] [ j ] <NEWLINE> <DEDENT> elif j == 19 : <NEWLINE> <INDENT> A [ i ] [ j ] = A [ i + 1 ] [ j ] + excel [ i ] [ j ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> A [ i ] [ j ] = excel [ i ] [ j ] + A [ i + 1 ] [ j ] + A [ i ] [ j + 1 ] - A [ i + 1 ] [ j + 1 ] <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for l in query : <NEWLINE> <INDENT> num2 , num5 = l <NEWLINE> if num2 <= 9 and num5 <= 9 : <NEWLINE> <INDENT> ans += A [ num2 ] [ num5 ] - 1 <NEWLINE> <DEDENT> else : a <NEWLINE> <INDENT> ans += A [ num2 ] [ num5 ] <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> print ( ans // 2 ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> D = { } <NEWLINE> from decimal import Decimal <NEWLINE> A = [ Decimal ( input ( ) ) for _ in range ( N ) ] <NEWLINE> A = [ int ( i * 10 ** 9 ) for i in A ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> x = A [ i ] <NEWLINE> y = x <NEWLINE> tcnt , fcnt = 0 , 0 <NEWLINE> while x % 2 == 0 and tcnt < 18 : <NEWLINE> <INDENT> tcnt += 1 <NEWLINE> x = x // 2 <NEWLINE> <DEDENT> while y % 5 == 0 and fcnt < 18 : <NEWLINE> <INDENT> fcnt += 1 <NEWLINE> y = y // 5 <NEWLINE> <DEDENT> A [ fcnt ] [ tcnt ] += 1 <NEWLINE> <NL> <DEDENT> cnt = 0 <NEWLINE> for i in range ( 19 ) : <NEWLINE> <INDENT> for j in range ( 19 ) : <NEWLINE> <INDENT> for k in range ( 19 ) : <NEWLINE> <INDENT> for l in range ( 19 ) : <NEWLINE> <INDENT> if i + k >= 18 and j + l >= 18 : <NEWLINE> <INDENT> if i != k and j != l : <NEWLINE> <INDENT> d = A [ i ] [ j ] <NEWLINE> e = A [ k ] [ l ] <NEWLINE> p = d * e <NEWLINE> <DEDENT> elif i == k and j == l : <NEWLINE> <INDENT> d = A [ i ] [ j ] <NEWLINE> p = d * ( d - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d = A [ i ] [ j ] <NEWLINE> e = A [ k ] [ l ] <NEWLINE> p = d * e <NEWLINE> <DEDENT> cnt += p <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( cnt // 2 ) <NEWLINE>
from numba import njit <NEWLINE> import numpy as np <NEWLINE> @ njit <NEWLINE> def main ( n , a ) : <NEWLINE> <INDENT> k = 60 <NEWLINE> mp = np . zeros ( ( k , k ) , np . int32 ) <NEWLINE> o = k // 2 <NEWLINE> ary = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> b = list ( a [ i ] . split ( <STRING> ) ) <NEWLINE> b . append ( <STRING> ) <NEWLINE> x = int ( b [ 0 ] ) <NEWLINE> y = int ( ( b [ 1 ] + <STRING> * 9 ) [ : 9 ] ) <NEWLINE> x = x * pow ( 10 , 9 ) + y <NEWLINE> <COMMENT> <NL> cnt5 = - 9 <NEWLINE> xx = x <NEWLINE> while xx > 1 : <NEWLINE> <INDENT> if xx % 5 == 0 : <NEWLINE> <INDENT> cnt5 += 1 <NEWLINE> xx //= 5 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> cnt2 = - 9 <NEWLINE> xx = x <NEWLINE> while xx > 1 : <NEWLINE> <INDENT> if xx % 2 == 0 : <NEWLINE> <INDENT> cnt2 += 1 <NEWLINE> xx //= 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> mp [ cnt5 + o , cnt2 + o ] += 1 <NEWLINE> ary . append ( [ cnt5 + o , cnt2 + o ] ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in range ( k - 1 , 0 , - 1 ) : <NEWLINE> <INDENT> for j in range ( k ) : <NEWLINE> <INDENT> mp [ j ] [ i - 1 ] += mp [ j ] [ i ] <NEWLINE> <DEDENT> <DEDENT> for i in range ( k - 1 , 0 , - 1 ) : <NEWLINE> <INDENT> for j in range ( k ) : <NEWLINE> <INDENT> mp [ i - 1 ] [ j ] += mp [ i ] [ j ] <NEWLINE> <DEDENT> <DEDENT> for x , y in ary : <NEWLINE> <INDENT> if x >= o and y >= o : <NEWLINE> <INDENT> i = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> i = 0 <NEWLINE> <DEDENT> x -= o <NEWLINE> x *= - 1 <NEWLINE> x += o <NEWLINE> y -= o <NEWLINE> y *= - 1 <NEWLINE> y += o <NEWLINE> ans += mp [ x , y ] - i <NEWLINE> <DEDENT> print ( ans // 2 ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> a = np . array ( [ input ( ) for _ in range ( n ) ] ) <NEWLINE> main ( n , a ) <NEWLINE> <NL>
<COMMENT> <NL> <NL> n = int ( input ( ) ) <NEWLINE> a_l = [ int ( float ( input ( ) ) * 10 ** 9 ) for x in range ( n ) ] <NEWLINE> <NL> list = [ [ 0 ] * 18 for x in range ( 18 ) ] <NEWLINE> b_l = [ 0 , 0 ] * n <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> _t2 = 0 <NEWLINE> _t5 = 0 <NEWLINE> _a = a_l [ i ] <NEWLINE> while _a % 2 == 0 and _t2 < 18 : <NEWLINE> <INDENT> _t2 += 1 <NEWLINE> _a /= 2 <NEWLINE> <NL> <DEDENT> _a = a_l [ i ] <NEWLINE> while _a % 5 == 0 and _t5 < 18 : <NEWLINE> <INDENT> _t5 += 1 <NEWLINE> _a /= 5 <NEWLINE> <NL> <DEDENT> list [ _t2 ] [ _t5 ] += 1 <NEWLINE> b_l [ i ] = [ _t2 , _t5 ] <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> _t , _f = b_l [ i ] <NEWLINE> for j in range ( 18 - _t , 19 ) : <NEWLINE> <INDENT> for k in range ( 18 - _f , 19 ) : <NEWLINE> <INDENT> ans += list [ j ] [ k ] <NEWLINE> <DEDENT> <DEDENT> if _t >= 9 and _f >= 9 : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans // 2 ) <NEWLINE>
from math import gcd <NEWLINE> from collections import Counter <NEWLINE> import sys <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> K = 10 ** 9 <NEWLINE> L = 10 ** 18 <NEWLINE> A = [ 0 ] * N <NEWLINE> C = Counter ( ) <NEWLINE> ans = 0 <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> A [ i ] = round ( K * float ( input ( ) ) ) <NEWLINE> C [ gcd ( A [ i ] , L ) ] += 1 <COMMENT> <NEWLINE> <NL> <DEDENT> for k1 , v1 in C . items ( ) : <NEWLINE> <INDENT> for k2 , v2 in C . items ( ) : <NEWLINE> <INDENT> if k1 == k2 : <NEWLINE> <INDENT> if k1 * k2 % L == 0 : <NEWLINE> <INDENT> ans += v1 * ( v1 - 1 ) / 2 <NEWLINE> <DEDENT> <DEDENT> elif k1 < k2 : <NEWLINE> <INDENT> if k1 * k2 % L == 0 : <NEWLINE> <INDENT> ans += v1 * v2 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> int ( print ( ans ) ) <NEWLINE> <NL> <NL>
import collections <NEWLINE> import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> def calc ( n ) : <NEWLINE> <INDENT> cnt_2 = 0 <NEWLINE> cnt_5 = 0 <NEWLINE> while n % 2 == 0 and cnt_2 < 18 : <NEWLINE> <INDENT> cnt_2 += 1 <NEWLINE> n //= 2 <NEWLINE> <DEDENT> while n % 5 == 0 and cnt_5 < 18 : <NEWLINE> <INDENT> cnt_5 += 1 <NEWLINE> n //= 5 <NEWLINE> <DEDENT> return [ cnt_2 , cnt_5 ] <NEWLINE> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> dic = collections . defaultdict ( int ) <NEWLINE> ans = 0 <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> tmp = input ( ) <NEWLINE> if <STRING> in tmp : <NEWLINE> <INDENT> pos = tmp . index ( <STRING> ) <NEWLINE> d = len ( tmp ) - ( pos + 1 ) <NEWLINE> tmp = tmp [ : pos ] + tmp [ pos + 1 : ] + <STRING> * ( 9 - d ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> tmp += <STRING> * 9 <NEWLINE> <DEDENT> tmp = int ( tmp ) <NEWLINE> cnt_2 , cnt_5 = calc ( tmp ) <NEWLINE> dic [ ( cnt_2 , cnt_5 ) ] += 1 <NEWLINE> if 18 <= min ( cnt_2 * 2 , cnt_5 * 2 ) : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <DEDENT> <DEDENT> for a1 , b1 in dic . keys ( ) : <NEWLINE> <INDENT> for a2 , b2 in dic . keys ( ) : <NEWLINE> <INDENT> if min ( a1 + a2 , b1 + b2 ) >= 18 : <NEWLINE> <INDENT> ans += dic [ ( a1 , b1 ) ] * dic [ ( a2 , b2 ) ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans // 2 ) <NEWLINE>
def prog ( x ) : <NEWLINE> <INDENT> n = len ( x ) <NEWLINE> y = [ int ( i * 10 ** 9 ) for i in x ] <NEWLINE> <COMMENT> <NL> <NL> def count25 ( s ) : <COMMENT> <NEWLINE> <INDENT> if s . find ( <STRING> ) == - 1 : <NEWLINE> <INDENT> s += <STRING> <NEWLINE> <DEDENT> s = s . rstrip ( <STRING> ) <NEWLINE> decimal_point = s . find ( <STRING> ) <NEWLINE> int_part = s [ : decimal_point ] <NEWLINE> float_part = s [ decimal_point + 1 : ] <NEWLINE> float_part += <STRING> * ( 9 - len ( float_part ) ) <NEWLINE> n = int ( int_part + float_part ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> return ( 0 , 0 ) <NEWLINE> <DEDENT> two = five = 0 <NEWLINE> while n % 2 == 0 : <NEWLINE> <INDENT> two += 1 <NEWLINE> n //= 2 <NEWLINE> <DEDENT> while n % 5 == 0 : <NEWLINE> <INDENT> five += 1 <NEWLINE> n //= 5 <NEWLINE> <DEDENT> return ( two , five ) <NEWLINE> <NL> <DEDENT> two = [ 0 ] * n <NEWLINE> five = [ 0 ] * n <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> two [ i ] , five [ i ] = count25 ( y [ i ] ) <NEWLINE> <DEDENT> count = 0 <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> two_i = 18 - two [ i ] <NEWLINE> five_i = 18 - five [ i ] <NEWLINE> for j in range ( i + 1 , n ) : <NEWLINE> <COMMENT> <NL> <INDENT> if two [ j ] >= two_i and five [ j ] >= five_i : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> x = [ 0 ] * n <NEWLINE> x = [ input ( ) for i in range ( n ) ] <NEWLINE> prog ( x ) <NEWLINE>
import sys <NEWLINE> import numpy as np <NEWLINE> <NL> read = sys . stdin . buffer . read <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> readlines = sys . stdin . buffer . readlines <NEWLINE> <NL> def main ( S ) : <NEWLINE> <INDENT> S = S . copy ( ) <NEWLINE> l_ind = np . where ( S == - 1 ) [ 0 ] [ : - 1 ] + 1 <NEWLINE> r_ind = np . where ( S == - 1 ) [ 0 ] [ 1 : ] <NEWLINE> <NL> <COMMENT> <NL> N = len ( l_ind ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> S [ l_ind [ i ] : r_ind [ i ] ] = S [ l_ind [ i ] : r_ind [ i ] ] [ : : - 1 ] <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> path = np . zeros_like ( S ) <NEWLINE> child = np . zeros ( ( len ( S ) , 26 ) , np . int32 ) <NEWLINE> is_end = np . zeros ( len ( S ) , np . bool_ ) <NEWLINE> <NL> n_node = 1 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> node = 0 <NEWLINE> for j in range ( l_ind [ i ] , r_ind [ i ] ) : <NEWLINE> <INDENT> path [ j ] = node <NEWLINE> if child [ node ] [ S [ j ] ] == 0 : <NEWLINE> <INDENT> child [ node ] [ S [ j ] ] = n_node <NEWLINE> n_node += 1 <NEWLINE> <DEDENT> node = child [ node ] [ S [ j ] ] <NEWLINE> <DEDENT> is_end [ node ] = True <NEWLINE> <DEDENT> child = child [ : n_node ] <NEWLINE> is_end = is_end [ : n_node ] <NEWLINE> ans = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> se = 0 <NEWLINE> for j in range ( r_ind [ i ] - 1 , l_ind [ i ] - 1 , - 1 ) : <NEWLINE> <INDENT> se |= 1 << S [ j ] <NEWLINE> node = path [ j ] <NEWLINE> for k in range ( 26 ) : <NEWLINE> <INDENT> if se & 1 << k : <NEWLINE> <INDENT> if is_end [ child [ node ] [ k ] ] : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> return ans - N <NEWLINE> <NL> <DEDENT> if sys . argv [ - 1 ] == <STRING> : <NEWLINE> <INDENT> import numba <NEWLINE> from numba import njit , b1 , i4 , i8 , f8 <NEWLINE> import numba <NEWLINE> from numba . pycc import CC <NEWLINE> cc = CC ( <STRING> ) <NEWLINE> <NL> def cc_export ( f , signature ) : <NEWLINE> <INDENT> cc . export ( f . __name__ , signature ) ( f ) <NEWLINE> return numba . njit ( f ) <NEWLINE> <NL> <DEDENT> main = cc_export ( main , ( i4 [ : ] , ) ) <NEWLINE> cc . compile ( ) <NEWLINE> <NL> <DEDENT> from my_module import main <NEWLINE> <NL> N = int ( readline ( ) ) <NEWLINE> S = np . array ( list ( read ( ) . rstrip ( ) ) , np . int32 ) <NEWLINE> <NL> S [ S == ord ( <STRING> ) ] = - 1 <NEWLINE> S [ S > 0 ] -= ord ( <STRING> ) <NEWLINE> S = np . insert ( S , 0 , - 1 ) <NEWLINE> S = np . append ( S , - 1 ) <NEWLINE> <NL> print ( main ( S ) ) <NEWLINE>
import sys <NEWLINE> import numpy as np <NEWLINE> import numba <NEWLINE> from numba import njit , b1 , i4 , i8 , f8 <NEWLINE> <NL> read = sys . stdin . buffer . read <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> readlines = sys . stdin . buffer . readlines <NEWLINE> <NL> MASK30 = ( 1 << 30 ) - 1 <NEWLINE> MASK31 = ( 1 << 31 ) - 1 <NEWLINE> MASK61 = ( 1 << 61 ) - 1 <NEWLINE> <NL> @ njit ( ( i8 , ) , cache = True ) <NEWLINE> def rh_modulo ( x ) : <NEWLINE> <INDENT> xu , xd = x >> 61 , x & MASK61 <NEWLINE> x = xu + xd <NEWLINE> if x >= MASK61 : <NEWLINE> <INDENT> x -= MASK61 <NEWLINE> <DEDENT> return x <NEWLINE> <NL> <NL> <DEDENT> @ njit ( ( i8 , i8 ) , cache = True ) <NEWLINE> def rh_multiply ( a , b ) : <NEWLINE> <INDENT> au , ad = a >> 31 , a & MASK31 <NEWLINE> bu , bd = b >> 31 , b & MASK31 <NEWLINE> x = ad * bu + au * bd <NEWLINE> xu , xd = x >> 30 , x & MASK30 <NEWLINE> return rh_modulo ( au * bu * 2 + xu + ( xd << 31 ) + ad * bd ) <NEWLINE> <NL> <NL> <DEDENT> @ njit ( ( i8 , i8 ) , cache = True ) <NEWLINE> def rh_pows ( base , max_len ) : <NEWLINE> <INDENT> pows = np . empty ( max_len , np . int64 ) <NEWLINE> pows [ 0 ] = 1 <NEWLINE> for n in range ( 1 , max_len ) : <NEWLINE> <INDENT> pows [ n ] = rh_multiply ( pows [ n - 1 ] , base ) <NEWLINE> <DEDENT> return pows <NEWLINE> <NL> <NL> <DEDENT> @ njit ( ( i8 [ : ] , i8 , i8 [ : ] ) , cache = True ) <NEWLINE> def compute_rh ( pows , base , S ) : <NEWLINE> <INDENT> N = len ( S ) <NEWLINE> RH = np . empty ( N , np . int64 ) <NEWLINE> RH [ 0 ] = S [ 0 ] + 10 <NEWLINE> for n in range ( 1 , N ) : <NEWLINE> <INDENT> x = rh_multiply ( RH [ n - 1 ] , base ) + S [ n ] + 10 <NEWLINE> if x >= MASK61 : <NEWLINE> <INDENT> x -= MASK61 <NEWLINE> <DEDENT> RH [ n ] = x <NEWLINE> <DEDENT> return RH <NEWLINE> <NL> <NL> <DEDENT> @ njit ( ( i8 [ : ] , i8 , i8 [ : ] , i8 , i8 ) , cache = True ) <NEWLINE> def rh_substr ( pows , base , RH , l , r ) : <NEWLINE> <INDENT> h = RH [ r ] <NEWLINE> if l > 0 : <NEWLINE> <INDENT> h -= rh_multiply ( RH [ l ] , pows [ r - l ] ) <NEWLINE> <DEDENT> if h < 0 : <NEWLINE> <INDENT> h += MASK61 <NEWLINE> <DEDENT> return h <NEWLINE> <NL> <DEDENT> @ njit ( ( i8 [ : ] , ) , cache = True ) <NEWLINE> def main ( S ) : <NEWLINE> <INDENT> S = S . copy ( ) <NEWLINE> l_ind = np . where ( S == - 1 ) [ 0 ] [ : - 1 ] + 1 <NEWLINE> r_ind = np . where ( S == - 1 ) [ 0 ] [ 1 : ] <NEWLINE> N = len ( l_ind ) <NEWLINE> <COMMENT> <NL> for i in range ( N ) : <NEWLINE> <INDENT> S [ l_ind [ i ] : r_ind [ i ] ] = S [ l_ind [ i ] : r_ind [ i ] ] [ : : - 1 ] <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> max_len = len ( S ) + 10 <NEWLINE> base = np . random . randint ( 0 , 1 << 31 ) <NEWLINE> pows = rh_pows ( base , max_len ) <NEWLINE> RH = np . zeros_like ( S ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> RH [ l_ind [ i ] : r_ind [ i ] ] = compute_rh ( pows , base , S [ l_ind [ i ] : r_ind [ i ] ] ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> sets = np . zeros_like ( S ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> for j in range ( r_ind [ i ] - 1 , l_ind [ i ] - 1 , - 1 ) : <NEWLINE> <INDENT> sets [ j ] = sets [ j + 1 ] | 1 << S [ j ] <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> ptr = 0 <NEWLINE> nums = dict ( ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> for j in range ( l_ind [ i ] , r_ind [ i ] ) : <NEWLINE> <INDENT> for k in range ( 26 ) : <NEWLINE> <INDENT> if sets [ j ] & 1 << k : <NEWLINE> <INDENT> h = rh_multiply ( RH [ j - 1 ] , base ) + k <NEWLINE> if h in nums : <NEWLINE> <INDENT> nums [ h ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> nums [ h ] = 1 <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> h = rh_multiply ( RH [ r_ind [ i ] - 2 ] , base ) + S [ r_ind [ i ] - 1 ] <NEWLINE> ans += nums [ h ] - 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> N = int ( readline ( ) ) <NEWLINE> S = np . array ( list ( read ( ) . rstrip ( ) ) , np . int64 ) <NEWLINE> <NL> S [ S == ord ( <STRING> ) ] = - 1 <NEWLINE> S [ S > 0 ] -= ord ( <STRING> ) <NEWLINE> S = np . insert ( S , 0 , - 1 ) <NEWLINE> S = np . append ( S , - 1 ) <NEWLINE> <NL> main ( S ) <NEWLINE>
import sys <NEWLINE> import numpy as np <NEWLINE> import numba <NEWLINE> from numba import njit , b1 , i4 , i8 , f8 <NEWLINE> <NL> read = sys . stdin . buffer . read <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> readlines = sys . stdin . buffer . readlines <NEWLINE> <NL> MASK30 = ( 1 << 30 ) - 1 <NEWLINE> MASK31 = ( 1 << 31 ) - 1 <NEWLINE> MASK61 = ( 1 << 61 ) - 1 <NEWLINE> <NL> @ njit ( ( i8 , ) , cache = True ) <NEWLINE> def rh_modulo ( x ) : <NEWLINE> <INDENT> xu , xd = x >> 61 , x & MASK61 <NEWLINE> x = xu + xd <NEWLINE> if x >= MASK61 : <NEWLINE> <INDENT> x -= MASK61 <NEWLINE> <DEDENT> return x <NEWLINE> <NL> <NL> <DEDENT> @ njit ( ( i8 , i8 ) , cache = True ) <NEWLINE> def rh_multiply ( a , b ) : <NEWLINE> <INDENT> au , ad = a >> 31 , a & MASK31 <NEWLINE> bu , bd = b >> 31 , b & MASK31 <NEWLINE> x = ad * bu + au * bd <NEWLINE> xu , xd = x >> 30 , x & MASK30 <NEWLINE> return rh_modulo ( au * bu * 2 + xu + ( xd << 31 ) + ad * bd ) <NEWLINE> <NL> <NL> <DEDENT> @ njit ( ( i8 , i8 ) , cache = True ) <NEWLINE> def rh_pows ( base , max_len ) : <NEWLINE> <INDENT> pows = np . empty ( max_len , np . int64 ) <NEWLINE> pows [ 0 ] = 1 <NEWLINE> for n in range ( 1 , max_len ) : <NEWLINE> <INDENT> pows [ n ] = rh_multiply ( pows [ n - 1 ] , base ) <NEWLINE> <DEDENT> return pows <NEWLINE> <NL> <NL> <DEDENT> @ njit ( ( i8 [ : ] , i8 , i8 [ : ] ) , cache = True ) <NEWLINE> def compute_rh ( pows , base , S ) : <NEWLINE> <INDENT> N = len ( S ) <NEWLINE> RH = np . empty ( N , np . int64 ) <NEWLINE> RH [ 0 ] = S [ 0 ] + 10 <NEWLINE> for n in range ( 1 , N ) : <NEWLINE> <INDENT> x = rh_multiply ( RH [ n - 1 ] , base ) + S [ n ] + 10 <NEWLINE> if x >= MASK61 : <NEWLINE> <INDENT> x -= MASK61 <NEWLINE> <DEDENT> RH [ n ] = x <NEWLINE> <DEDENT> return RH <NEWLINE> <NL> <NL> <DEDENT> @ njit ( ( i8 [ : ] , i8 , i8 [ : ] , i8 , i8 ) , cache = True ) <NEWLINE> def rh_substr ( pows , base , RH , l , r ) : <NEWLINE> <INDENT> h = RH [ r ] <NEWLINE> if l > 0 : <NEWLINE> <INDENT> h -= rh_multiply ( RH [ l ] , pows [ r - l ] ) <NEWLINE> <DEDENT> if h < 0 : <NEWLINE> <INDENT> h += MASK61 <NEWLINE> <DEDENT> return h <NEWLINE> <NL> <DEDENT> @ njit ( ( i8 [ : ] , ) , cache = True ) <NEWLINE> def main ( S ) : <NEWLINE> <INDENT> S = S . copy ( ) <NEWLINE> l_ind = np . where ( S == - 1 ) [ 0 ] [ : - 1 ] + 1 <NEWLINE> r_ind = np . where ( S == - 1 ) [ 0 ] [ 1 : ] <NEWLINE> N = len ( l_ind ) <NEWLINE> <COMMENT> <NL> for i in range ( N ) : <NEWLINE> <INDENT> S [ l_ind [ i ] : r_ind [ i ] ] = S [ l_ind [ i ] : r_ind [ i ] ] [ : : - 1 ] <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> max_len = len ( S ) + 10 <NEWLINE> base = np . random . randint ( 0 , 1 << 31 ) <NEWLINE> pows = rh_pows ( base , max_len ) <NEWLINE> RH = np . zeros_like ( S ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> RH [ l_ind [ i ] : r_ind [ i ] ] = compute_rh ( pows , base , S [ l_ind [ i ] : r_ind [ i ] ] ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> sets = np . zeros_like ( S ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> for j in range ( r_ind [ i ] - 1 , l_ind [ i ] - 1 , - 1 ) : <NEWLINE> <INDENT> sets [ j ] = sets [ j + 1 ] | 1 << S [ j ] <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> ptr = 0 <NEWLINE> nums = np . empty ( len ( S ) * 26 + 10 , np . int64 ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> for j in range ( l_ind [ i ] , r_ind [ i ] ) : <NEWLINE> <INDENT> for k in range ( 26 ) : <NEWLINE> <INDENT> if sets [ j ] & 1 << k : <NEWLINE> <INDENT> h = rh_multiply ( RH [ j - 1 ] , base ) + k <NEWLINE> nums [ ptr ] = h <NEWLINE> ptr += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> nums = nums [ : ptr ] <NEWLINE> nums = nums [ np . argsort ( nums , kind = <STRING> ) ] <NEWLINE> <COMMENT> <NL> ans = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> h = rh_multiply ( RH [ r_ind [ i ] - 2 ] , base ) + S [ r_ind [ i ] - 1 ] <NEWLINE> cnt = np . searchsorted ( nums , h , <STRING> ) <NEWLINE> cnt -= np . searchsorted ( nums , h , <STRING> ) <NEWLINE> ans += cnt - 1 <COMMENT> <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> N = int ( readline ( ) ) <NEWLINE> S = np . array ( list ( read ( ) . rstrip ( ) ) , np . int64 ) <NEWLINE> <NL> S [ S == ord ( <STRING> ) ] = - 1 <NEWLINE> S [ S > 0 ] -= ord ( <STRING> ) <NEWLINE> S = np . insert ( S , 0 , - 1 ) <NEWLINE> S = np . append ( S , - 1 ) <NEWLINE> <NL> main ( S ) <NEWLINE>
import numpy <NEWLINE> <NL> def convolve ( g , h ) : <NEWLINE> <INDENT> s = len ( g ) + len ( h ) + 1 <NEWLINE> n = 1 <NEWLINE> while n < s : <NEWLINE> <INDENT> n *= 2 <NEWLINE> <DEDENT> gg = numpy . fft . fft ( g + [ 0 ] * ( n - len ( g ) ) ) <NEWLINE> hh = numpy . fft . fft ( h + [ 0 ] * ( n - len ( h ) ) ) <NEWLINE> ff = [ gg [ i ] * hh [ i ] for i in range ( n ) ] <NEWLINE> ff = numpy . fft . ifft ( ff ) <NEWLINE> ans = [ int ( ff [ i ] . real + 0.5 ) for i in range ( n ) ] <NEWLINE> return ans <NEWLINE> <NL> <DEDENT> p = 200003 <NEWLINE> n = int ( input ( ) ) <NEWLINE> arr = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> pos = { } <NEWLINE> tmp = 1 <NEWLINE> for i in range ( p ) : <NEWLINE> <INDENT> pos [ tmp ] = i <NEWLINE> tmp *= 2 <NEWLINE> tmp %= p <NEWLINE> <DEDENT> cnt1 = [ 0 ] * p <NEWLINE> cnt2 = [ 0 ] * p <NEWLINE> for val in arr : <NEWLINE> <INDENT> if val != 0 : <NEWLINE> <INDENT> cnt1 [ pos [ val ] ] += 1 <NEWLINE> cnt2 [ pos [ val ] ] += 1 <NEWLINE> <DEDENT> <DEDENT> ans = convolve ( cnt1 , cnt2 ) <NEWLINE> for val in arr : <NEWLINE> <INDENT> ans [ pos [ val ] * 2 ] -= 1 <NEWLINE> <DEDENT> total = 0 <NEWLINE> for i in range ( len ( ans ) ) : <NEWLINE> <INDENT> if ans [ i ] != 0 : <NEWLINE> <INDENT> total += ( ans [ i ] // 2 ) * pow ( 2 , i , p ) <NEWLINE> <DEDENT> <DEDENT> print ( total ) <NEWLINE>
import scipy . fftpack as F <NEWLINE> from numpy import * <NEWLINE> m = 200003 <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = [ 0 ] * m <NEWLINE> b = [ 0 ] * ( m - 1 ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> a [ pow ( 2 , i , m ) ] = i <NEWLINE> <DEDENT> for i in map ( int , input ( ) . split ( ) ) : <NEWLINE> <INDENT> if i : <NEWLINE> <INDENT> b [ a [ i ] ] += 1 <NEWLINE> ans -= i * i % m <NEWLINE> <DEDENT> <DEDENT> b = array ( b , dtype = float64 ) <NEWLINE> b = F . fft ( b ) <NEWLINE> b = b * b <NEWLINE> b = F . ifft ( b ) <NEWLINE> for i , j in enumerate ( b ) : <NEWLINE> <INDENT> ans += int ( round ( j . real ) ) * pow ( 2 , i , m ) <NEWLINE> <DEDENT> print ( ans // 2 ) <NEWLINE>
import sys <NEWLINE> import numpy as np <NEWLINE> import numba <NEWLINE> from numba import njit , b1 , i4 , i8 , f8 <NEWLINE> <NL> read = sys . stdin . buffer . read <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> readlines = sys . stdin . buffer . readlines <NEWLINE> <NL> MOD = 200_003 <NEWLINE> R = 2 <COMMENT> <NEWLINE> <NL> ntt_mod = 998_244_353 <NEWLINE> ntt_root = 3 <NEWLINE> max_ntt = 20 <NEWLINE> roots , iroots = np . empty ( 1 << max_ntt , <NEWLINE> <INDENT> np . int64 ) , np . empty ( 1 << max_ntt , np . int64 ) <NEWLINE> <NL> <DEDENT> ntt_data = ( ntt_mod , ntt_root , max_ntt , roots , iroots ) <NEWLINE> ntt_t = numba . typeof ( ntt_data ) <NEWLINE> <NL> <NL> @ njit ( ( ntt_t , ) , cache = True ) <NEWLINE> def ntt_precompute ( ntt_data ) : <NEWLINE> <INDENT> MOD , root , max_ntt , roots , iroots = ntt_data <NEWLINE> <NL> def mpow ( a , n ) : <NEWLINE> <INDENT> p = 1 <NEWLINE> while n : <NEWLINE> <INDENT> if n & 1 : <NEWLINE> <INDENT> p = p * a % MOD <NEWLINE> <DEDENT> a = a * a % MOD <NEWLINE> n >>= 1 <NEWLINE> <DEDENT> return p <NEWLINE> <NL> <DEDENT> roots [ 0 ] = iroots [ 0 ] = 1 <NEWLINE> for n in range ( max_ntt ) : <NEWLINE> <INDENT> x = mpow ( root , ( MOD - 1 ) >> n + 2 ) <NEWLINE> y = mpow ( x , MOD - 2 ) <NEWLINE> for i in range ( 1 << n ) : <NEWLINE> <INDENT> roots [ ( 1 << n ) | i ] = roots [ i ] * x % MOD <NEWLINE> iroots [ ( 1 << n ) | i ] = iroots [ i ] * y % MOD <NEWLINE> <DEDENT> <DEDENT> return roots , iroots <NEWLINE> <NL> <NL> <DEDENT> @ njit ( ( ntt_t , i8 [ : ] , b1 ) , cache = True ) <NEWLINE> def ntt ( ntt_data , A , inverse ) : <NEWLINE> <INDENT> MOD , _ , _ , roots , iroots = ntt_data <NEWLINE> <NL> def mpow ( a , n ) : <NEWLINE> <INDENT> p = 1 <NEWLINE> while n : <NEWLINE> <INDENT> if n & 1 : <NEWLINE> <INDENT> p = p * a % MOD <NEWLINE> <DEDENT> a = a * a % MOD <NEWLINE> n >>= 1 <NEWLINE> <DEDENT> return p <NEWLINE> <NL> <DEDENT> N = len ( A ) <NEWLINE> <NL> if not inverse : <NEWLINE> <INDENT> m = N >> 1 <NEWLINE> while m : <NEWLINE> <INDENT> for k in range ( N // m >> 1 ) : <NEWLINE> <INDENT> s = 2 * m * k <NEWLINE> for i in range ( s , s + m ) : <NEWLINE> <INDENT> x , y = A [ i ] , A [ i + m ] * roots [ k ] <NEWLINE> A [ i ] , A [ i + m ] = x + y , x - y <NEWLINE> <DEDENT> <DEDENT> A %= MOD <NEWLINE> m >>= 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> m = 1 <NEWLINE> while m < N : <NEWLINE> <INDENT> for k in range ( N // m >> 1 ) : <NEWLINE> <INDENT> s = 2 * m * k <NEWLINE> for i in range ( s , s + m ) : <NEWLINE> <INDENT> x , y = A [ i ] , A [ i + m ] <NEWLINE> A [ i ] , A [ i + m ] = x + y , ( x - y ) * iroots [ k ] <NEWLINE> <DEDENT> <DEDENT> A %= MOD <NEWLINE> m <<= 1 <NEWLINE> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> A [ i ] = A [ i ] * mpow ( N , MOD - 2 , MOD ) % MOD <NEWLINE> <DEDENT> <DEDENT> return A <NEWLINE> <NL> <NL> <DEDENT> @ njit ( ( ntt_t , i8 [ : ] , i8 [ : ] ) , cache = True ) <NEWLINE> def ntt_convolve ( ntt_data , A , B ) : <NEWLINE> <INDENT> L = 1 <NEWLINE> while 2 * L < len ( A ) + len ( B ) - 1 : <NEWLINE> <INDENT> L *= 2 <NEWLINE> <DEDENT> L *= 2 <NEWLINE> A = np . append ( A , np . zeros ( L - len ( A ) , np . int64 ) ) <NEWLINE> B = np . append ( B , np . zeros ( L - len ( B ) , np . int64 ) ) <NEWLINE> A = ntt ( ntt_data , A , False ) <NEWLINE> B = ntt ( ntt_data , B , False ) <NEWLINE> for i in range ( len ( A ) ) : <NEWLINE> <INDENT> A [ i ] = A [ i ] * B [ i ] % ntt_data [ 0 ] <NEWLINE> <DEDENT> return ntt ( ntt_data , A , True ) <NEWLINE> <NL> <NL> <DEDENT> ntt_precompute ( ntt_data ) <NEWLINE> <NL> @ njit ( ( i8 [ : ] , ) , cache = True ) <NEWLINE> def precompute ( A ) : <NEWLINE> <INDENT> exp = np . zeros ( MOD - 1 , np . int64 ) <NEWLINE> log = np . zeros ( MOD , np . int64 ) <NEWLINE> exp [ 0 ] = 1 <NEWLINE> for k in range ( 1 , MOD - 1 ) : <NEWLINE> <INDENT> exp [ k ] = exp [ k - 1 ] * R % MOD <NEWLINE> log [ exp [ k ] ] = k <NEWLINE> <COMMENT> <NL> <DEDENT> B = np . zeros ( MOD - 1 , np . int64 ) <NEWLINE> for x in A : <NEWLINE> <INDENT> if x != 0 : <NEWLINE> <INDENT> B [ log [ x ] ] += 1 <NEWLINE> <DEDENT> <DEDENT> return exp , log , B <NEWLINE> <NL> <DEDENT> @ njit ( ( i8 [ : ] , i8 [ : ] , i8 [ : ] , i8 [ : ] ) , cache = True ) <NEWLINE> def get_ans ( A , C , exp , log ) : <NEWLINE> <COMMENT> <NL> <INDENT> ans = 0 <NEWLINE> for i in range ( len ( C ) ) : <NEWLINE> <INDENT> x = exp [ i % ( MOD - 1 ) ] <NEWLINE> ans += x * C [ i ] <NEWLINE> <DEDENT> for a in A : <NEWLINE> <INDENT> x = a * a % MOD <NEWLINE> ans -= x <NEWLINE> <DEDENT> return ans // 2 <NEWLINE> <NL> <DEDENT> A = np . array ( read ( ) . split ( ) , np . int64 ) [ 1 : ] <NEWLINE> <NL> exp , log , B = precompute ( A ) <NEWLINE> <NL> B = np . append ( B , [ 0 ] * ( ( 1 << 19 ) - len ( B ) ) ) <NEWLINE> Bh , Bl = B >> 9 , B & 511 <NEWLINE> x = ntt_convolve ( ntt_data , Bh , Bh ) << 18 <NEWLINE> x += ntt_convolve ( ntt_data , Bh , Bl ) << 10 <NEWLINE> x += ntt_convolve ( ntt_data , Bl , Bl ) <NEWLINE> <NL> print ( get_ans ( A , x , exp , log ) ) <NEWLINE>
X = int ( input ( ) ) <NEWLINE> <NL> if X < 30 : <NEWLINE> <INDENT> print ( No ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( Yes ) <NEWLINE> <DEDENT>
if X >= 30 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
X = int ( input ( ) ) <NEWLINE> if X >= 30 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> pritn ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> <NL> if x >= 30 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
X = input ( ) <NEWLINE> if X >= 30 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
<COMMENT> <NL> x = int ( input ( ) ) <NEWLINE> <NL> if x >= 30 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
x = int ( input ( ) ) <NEWLINE> if x >= 30 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
x = int ( input ( ) ) <NEWLINE> if X >= 30 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import random <NEWLINE> <NL> <NL> def gcd ( a , b ) : <NEWLINE> <INDENT> if a == 0 : <NEWLINE> <INDENT> return b <NEWLINE> <DEDENT> return gcd ( b % a , a ) <NEWLINE> <NL> <NL> <DEDENT> def lcm ( a , b ) : <NEWLINE> <INDENT> return ( a * b ) / gcd ( a , b ) <NEWLINE> <NL> <NL> <DEDENT> for _ in range ( int ( input ( ) ) ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> if n >= 30 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
X = input ( ) <NEWLINE> if X >= 30 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
if input ( ) >= 30 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
x = int ( input ( ) ) <NEWLINE> if x >= 30 : <NEWLINE> <INDENT> print ( Yes ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( No ) <NEWLINE> <DEDENT>
X = input ( ) <NEWLINE> <NL> if X >= 30 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> if n >= 30 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
for i in input : <NEWLINE> <INDENT> if i >= 30 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
x = input ( ) <NEWLINE> if x >= 30 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
X = input ( ) <NEWLINE> if X <= 30 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : x >= 30 <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
x = input ( ) <NEWLINE> if x >= 30 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N , D = input ( ) . split ( ) <NEWLINE> n = int ( N ) <NEWLINE> d = int ( D ) <NEWLINE> count = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> X , Y = input ( ) . split ( ) <NEWLINE> x = int ( X ) <NEWLINE> y = int ( Y ) <NEWLINE> distance = x * x + y * y <NEWLINE> if distance <= d * d : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
X = int ( input ( ) ) <NEWLINE> If X >= 30 : <NEWLINE> print ( <STRING> ) <NEWLINE> else : <NEWLINE> print ( <STRING> ) <NEWLINE>
a = int ( input ( ) ) <NEWLINE> if a = > 30 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a = int ( input ( ) ) <NEWLINE> a >= 30 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
int X = input ( ) <NEWLINE> if ( X == 30 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
x = input ( ) <NEWLINE> print ( x ) <NEWLINE> <NL> if x >= 30 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a = int ( input ( ) ) <NEWLINE> if a = > 30 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
x = input ( ) <NEWLINE> if x >= 30 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
if int ( input ( ) ) >= 30 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> if else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
if int ( input ( ) ) > 29 : <NEWLINE> <INDENT> print ( Yes ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( No ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> line = stdin . readline ( ) <NEWLINE> parts = line . split ( ) <NEWLINE> a = int ( parts [ 0 ] ) <NEWLINE> if a >= 30 : <NEWLINE> <INDENT> stdout . write ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> stdout . write ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> main ( ) <NEWLINE>
X = input ( ) <NEWLINE> if X >= 30 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
x = int ( input ( ) ) <NEWLINE> if x >= 30 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> pt ( <STRING> ) <NEWLINE> <DEDENT>
x = int ( input ( ) ) <NEWLINE> b = x - 30 <NEWLINE> if b = > 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import sys , math , collections <NEWLINE> from collections import defaultdict <NEWLINE> <NL> <COMMENT> <NL> <NL> def file ( ) : <NEWLINE> <INDENT> sys . stdin = open ( <STRING> , <STRING> ) <NEWLINE> sys . stdout = open ( <STRING> , <STRING> ) <NEWLINE> <DEDENT> def get_array ( ) : <NEWLINE> <INDENT> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> return l <NEWLINE> <DEDENT> def get_2_ints ( ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> return a , b <NEWLINE> <DEDENT> def get_3_ints ( ) : <NEWLINE> <INDENT> a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> return a , b , c <NEWLINE> <DEDENT> def sod ( n ) : <NEWLINE> <INDENT> n , c = str ( n ) , 0 <NEWLINE> for i in n : <NEWLINE> <INDENT> c += int ( i ) <NEWLINE> <DEDENT> return c <NEWLINE> <DEDENT> def isPrime ( n ) : <NEWLINE> <INDENT> if ( n <= 1 ) : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> if ( n <= 3 ) : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> if ( n % 2 == 0 or n % 3 == 0 ) : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> i = 5 <NEWLINE> while ( i * i <= n ) : <NEWLINE> <INDENT> if ( n % i == 0 or n % ( i + 2 ) == 0 ) : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> i = i + 6 <NEWLINE> <NL> <DEDENT> return True <NEWLINE> <DEDENT> def getFloor ( A , x ) : <NEWLINE> <NL> <INDENT> ( left , right ) = ( 0 , len ( A ) - 1 ) <NEWLINE> <NL> floor = - 1 <NEWLINE> while left <= right : <NEWLINE> <INDENT> mid = ( left + right ) // 2 <NEWLINE> if A [ mid ] == x : <NEWLINE> <INDENT> return A [ mid ] <NEWLINE> <DEDENT> elif x < A [ mid ] : <NEWLINE> <INDENT> right = mid - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> floor = A [ mid ] <NEWLINE> left = mid + 1 <NEWLINE> <NL> <DEDENT> <DEDENT> return floor <NEWLINE> <DEDENT> def floorSqrt ( x ) : <NEWLINE> <NL> <COMMENT> <NL> <INDENT> if ( x == 0 or x == 1 ) : <NEWLINE> <INDENT> return x <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> start = 1 <NEWLINE> end = x <NEWLINE> while ( start <= end ) : <NEWLINE> <INDENT> mid = ( start + end ) // 2 <NEWLINE> <NL> <COMMENT> <NL> if ( mid * mid == x ) : <NEWLINE> <INDENT> return mid <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> if ( mid * mid < x ) : <NEWLINE> <INDENT> start = mid + 1 <NEWLINE> ans = mid <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <NL> <COMMENT> <NL> <INDENT> end = mid - 1 <NEWLINE> <NL> <DEDENT> <DEDENT> return ans <NEWLINE> <COMMENT> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> for tt in range ( int ( input ( ) ) ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> <NL> if ( n >= 30 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
X = input ( ) <NEWLINE> <NL> if ( X > 40 or X < - 40 ) : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> elif ( X = > 30 and X = < 40 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif ( X = > - 40 and X < 30 ) <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT>
N = input ( ) <NEWLINE> if N >= 30 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
X = input ( ) <NEWLINE> if X >= 30 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
X = int ( input ( ) ) <NEWLINE> <NL> if ( x >= 30 ) : <NEWLINE> <INDENT> print ( Yes ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( No ) <NEWLINE> <DEDENT>
x = int ( input ( ) ) <NEWLINE> if X >= 30 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
x = int ( input ( ) ) <NEWLINE> if ( x >= 25 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> else : <NEWLINE> print ( <STRING> ) <NEWLINE> <DEDENT>
<INDENT> n = int ( input ( ) ) <NEWLINE> if n >= 30 : <NEWLINE> <INDENT> s = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s = <STRING> <NEWLINE> <DEDENT> print ( s ) <NEWLINE> <DEDENT>
n = int ( input ) <NEWLINE> <NL> if n >= 30 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
X = int ( input ( ) ) <NEWLINE> if ( X = > 30 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
x = int ( inpt ( ) ) <NEWLINE> if ( x >= 30 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
x = int ( input ( ) ) <NEWLINE> if x < 30 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> else : <NEWLINE> print ( <STRING> ) <NEWLINE> <DEDENT>
x = int ( input ( ) . split ( ) ) <NEWLINE> <NL> if x >= 30 : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
x = input ( ) <NEWLINE> <NL> if x >= 30 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif x < 30 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
temp = int ( input ( ) ) <NEWLINE> if temp >= 30 : <NEWLINE> <INDENT> answer = Yes <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> answer = No <NEWLINE> <DEDENT> print ( answer ) <NEWLINE>
x = int ( input ( ) ) <NEWLINE> return <STRING> if x >= 30 else <STRING> <NEWLINE>
x = input ( ) <NEWLINE> if x >= 30 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
X = input ( ) <NEWLINE> <NL> if X >= 30 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
input = X <NEWLINE> if X >= 30 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
t = int ( input ( ) ) <NEWLINE> if t >= 30 print ( <STRING> ) <NEWLINE> else print ( <STRING> ) <NEWLINE>
<INDENT> x = int ( input ( ) ) <NEWLINE> <NL> if x >= 30 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
X = int ( input ) <NEWLINE> <NL> if X >= 30 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = input ( ) <NEWLINE> if n >= 30 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
temp = input ( ) <NEWLINE> if temp >= 30 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
x = input ( ) <NEWLINE> if ( x >= 30 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
x = int ( input ( ) ) <NEWLINE> <NL> if x = > 30 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> from queue import Queue <NEWLINE> from queue import LifoQueue as Stack <NEWLINE> from math import sqrt , floor , ceil , log2 , log10 , pi <NEWLINE> from fractions import gcd <NEWLINE> from itertools import permutations , combinations <NEWLINE> from operator import itemgetter <NEWLINE> from functools import cmp_to_key <NEWLINE> <NL> <NL> INF = 1001001001 <NEWLINE> __MOD__ = ( 10 ** 9 ) + 7 <NEWLINE> yn = <STRING> <NEWLINE> judge = False <NEWLINE> cnt = 0 <NEWLINE> ans = None <NEWLINE> <NL> <NL> def lcm ( a , b ) : <NEWLINE> <INDENT> return ( a * b ) // gcd ( a , b ) <NEWLINE> <NL> <DEDENT> def intinput ( ) : <NEWLINE> <INDENT> return int ( input ( ) ) <NEWLINE> <NL> <DEDENT> def mulinputs ( ) : <NEWLINE> <INDENT> return map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <DEDENT> def lineinputs ( func = intinput ) : <NEWLINE> <INDENT> datas = [ ] <NEWLINE> while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> datas . append ( func ( ) ) <NEWLINE> <DEDENT> except EOFError : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> return datas <NEWLINE> <NL> <DEDENT> class ModInt ( ) : <NEWLINE> <INDENT> def __init__ ( self , x ) : <NEWLINE> <INDENT> self . __x = ( x % __MOD__ ) <NEWLINE> <DEDENT> def __add__ ( self , other ) : <NEWLINE> <INDENT> if type ( other ) == int : <NEWLINE> <INDENT> other = self . __class__ ( other ) <NEWLINE> return int ( self . __class__ ( ( self . __x + other . __x ) % __MOD__ ) ) <NEWLINE> <DEDENT> elif type ( other ) == ModInt : <NEWLINE> <INDENT> return self . __class__ ( ( self . __x + other . __x ) % __MOD__ ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> raise Exception ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> def __radd__ ( self , other ) : <NEWLINE> <INDENT> if type ( other ) == int : <NEWLINE> <INDENT> other = self . __class__ ( other ) <NEWLINE> return int ( self . __class__ ( ( other . __x + self . __x ) % __MOD__ ) ) <NEWLINE> <DEDENT> elif type ( other ) == ModInt : <NEWLINE> <INDENT> return self . __class__ ( ( other . __x + self . __x ) % __MOD__ ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> raise Exception ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> def __sub__ ( self , other ) : <NEWLINE> <INDENT> if type ( other ) == int : <NEWLINE> <INDENT> other = self . __class__ ( other ) <NEWLINE> return int ( self . __class__ ( ( self . __x - other . __x ) % __MOD__ ) ) <NEWLINE> <DEDENT> elif type ( other ) == ModInt : <NEWLINE> <INDENT> return self . __class__ ( ( self . __x - other . __x ) % __MOD__ ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> raise Exception ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> def __rsub__ ( self , other ) : <NEWLINE> <INDENT> if type ( other ) == int : <NEWLINE> <INDENT> other = self . __class__ ( other ) <NEWLINE> return int ( self . __class__ ( ( other . __x - self . __x ) % __MOD__ ) ) <NEWLINE> <DEDENT> elif type ( other ) == ModInt : <NEWLINE> <INDENT> return self . __class__ ( ( other . __x - self . __x ) % __MOD__ ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> raise Exception ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> def __mul__ ( self , other ) : <NEWLINE> <INDENT> if type ( other ) == int : <NEWLINE> <INDENT> other = self . __class__ ( other ) <NEWLINE> return int ( self . __class__ ( ( self . __x * other . __x ) % __MOD__ ) ) <NEWLINE> <DEDENT> elif type ( other ) == ModInt : <NEWLINE> <INDENT> return self . __class__ ( ( self . __x * other . __x ) % __MOD__ ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> raise Exception ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> def __rmul__ ( self , other ) : <NEWLINE> <INDENT> if type ( other ) == int : <NEWLINE> <INDENT> other = self . __class__ ( other ) <NEWLINE> return int ( self . __class__ ( ( other . __x * self . __x ) % __MOD__ ) ) <NEWLINE> <DEDENT> elif type ( other ) == ModInt : <NEWLINE> <INDENT> return self . __class__ ( ( other . __x * self . __x ) % __MOD__ ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> raise Exception ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> def __truediv__ ( self , other ) : <NEWLINE> <INDENT> if type ( other ) == int : <NEWLINE> <INDENT> other = self . __class__ ( other ) <NEWLINE> return int ( self . __class__ ( ( self . __x * other . __modinv ( ) ) % __MOD__ ) ) <NEWLINE> <DEDENT> elif type ( other ) == ModInt : <NEWLINE> <INDENT> return self . __class__ ( ( self . __x * other . __modinv ( ) ) % __MOD__ ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> raise Exception ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> def __rtruediv__ ( self , other ) : <NEWLINE> <INDENT> if type ( other ) == int : <NEWLINE> <INDENT> other = self . __class__ ( other ) <NEWLINE> return int ( self . __class__ ( ( other . __x * self . __modinv ( ) ) % __MOD__ ) ) <NEWLINE> <DEDENT> elif type ( other ) == ModInt : <NEWLINE> <INDENT> return self . __class__ ( ( other . __x * self . __modinv ( ) ) % __MOD__ ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> raise Exception ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> def __pow__ ( self , other ) : <NEWLINE> <INDENT> if type ( other ) == int : <NEWLINE> <INDENT> other = self . __class__ ( other ) <NEWLINE> return int ( self . __class__ ( pow ( self . __x , other . __x , __MOD__ ) ) ) <NEWLINE> <DEDENT> elif type ( other ) == ModInt : <NEWLINE> <INDENT> return self . __class__ ( pow ( self . __x , other . __x , __MOD__ ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> raise Exception ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> def __rpow__ ( self , other ) : <NEWLINE> <INDENT> if type ( other ) == int : <NEWLINE> <INDENT> other = self . __class__ ( other ) <NEWLINE> return int ( self . __class__ ( pow ( other . __x , self . __x , __MOD__ ) ) ) <NEWLINE> <DEDENT> elif type ( other ) == ModInt : <NEWLINE> <INDENT> return self . __class__ ( pow ( other . __x , self . __x , __MOD__ ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> raise Exception ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> def __modinv ( self , m = __MOD__ ) : <NEWLINE> <INDENT> a = self . __x <NEWLINE> if a == 0 : <NEWLINE> <INDENT> raise ZeroDivisionError ( ) <NEWLINE> <DEDENT> if gcd ( a , m ) != 1 : <NEWLINE> <INDENT> raise Exception ( <STRING> % a ) <NEWLINE> <DEDENT> b , u , v = m , 1 , 0 <NEWLINE> while b != 0 : <NEWLINE> <INDENT> t = a // b ; <NEWLINE> a -= t * b <NEWLINE> a , b = b , a <NEWLINE> u -= t * v <NEWLINE> u , v = v , u <NEWLINE> <DEDENT> u %= m <NEWLINE> if u < 0 : <NEWLINE> <INDENT> u += m <NEWLINE> <DEDENT> return u <NEWLINE> <DEDENT> def __int__ ( self ) : <NEWLINE> <INDENT> return self . __x <NEWLINE> <DEDENT> def __str__ ( self ) : <NEWLINE> <INDENT> return str ( self . __x ) <NEWLINE> <NL> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> N = intinput ( ) <NEWLINE> <NL> <COMMENT> <NL> if N >= 30 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> pirint ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT>
a = input ( ) <NEWLINE> if a >= 30 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
x = int ( input ( <STRING> ) ) <NEWLINE> <NL> if x >= 30 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> Else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
x = input ( ) <NEWLINE> if x >= 30 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : print ( <STRING> ) <NEWLINE>
x = input ( ) <NEWLINE> if x >= 30 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
<INDENT> X = int ( input ( ) ) <NEWLINE> if X > 30 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
x = input ( ) <NEWLINE> <NL> if x >= 30 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
rt = int ( inut ( ) ) <NEWLINE> <NL> if rt >= 30 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
if X >= 30 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
if X >= 30 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
X = input ( ) <NEWLINE> ans = <STRING> if X >= 30 else <STRING> <NEWLINE> print ( ans ) <NEWLINE>
t = int ( input ( ) ) : <NEWLINE> <NL> if 30 <= t <= 40 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> if - 40 <= t < 30 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = input ( ) <NEWLINE> <NL> if 30 <= n : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( inpput ( ) ) <NEWLINE> if n >= 30 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
X = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if ( X >= 30 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a = int ( input ( ) ) <NEWLINE> if a >= 30 : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT>
X = int ( input ) <NEWLINE> <NL> print ( <STRING> if X >= 30 else <STRING> ) <NEWLINE>
t = int ( input ( ) ) <NEWLINE> if t >= 30 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> else : <NEWLINE> print ( <STRING> ) <NEWLINE> <DEDENT>
print ( <STRING> if int ( input ( ) ) >= <STRING> else <STRING> ) <NEWLINE>
x = input ( ) <NEWLINE> <NL> if x >= 30 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
temp = input ( ) <NEWLINE> if temp > 30 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
X = input ( ) <NEWLINE> <NL> if X >= 30 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a = int ( input ( ) ) <NEWLINE> if ( a >= 30 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> <NL> if n >= 30 ; <NEWLINE> print ( <STRING> ) <NEWLINE> else <NEWLINE> print ( <STRING> ) <NEWLINE>
n = input ( ) <NEWLINE> <NL> if n >= 30 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
x = input ( ) <NEWLINE> if x >= 30 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
t = int ( input ) <NEWLINE> print ( <STRING> if t >= 30 else <STRING> ) <NEWLINE>
X = int ( input ( ) ) <NEWLINE> if X >= 30 : <NEWLINE> <INDENT> print ( Yes ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( No ) <NEWLINE> <DEDENT>
x = int ( input ( ) ) <NEWLINE> <NL> if x >= 30 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
if int ( input ( ) ) >= 30 : <NEWLINE> <INDENT> print ( Yes ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( No ) <NEWLINE> <DEDENT>
x = input ( ) <NEWLINE> <NL> if x >= 30 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
if X >= 30 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
t = input ( ) <NEWLINE> <NL> if t >= 30 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
return int ( input ( ) ) >= 30 <NEWLINE>
tep = input ( ) <NEWLINE> if tep < - 40 or tep > 40 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> elif tep >= 30 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
return <STRING> if int ( input ( ) ) >= 30 else <STRING> <NEWLINE>
X = input ( ) <NEWLINE> if X < 30 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
X = input ( ) <NEWLINE> <NL> if int ( X ) >= 30 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
X = input ( ) <NEWLINE> if X >= 30 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = input ( ) <NEWLINE> if n >= 30 : <NEWLINE> <INDENT> print ( Yes ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( No ) <NEWLINE> <DEDENT>
X = input ( int ( ) ) <NEWLINE> <NL> if 30 <= X : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
if input ( ) > 30 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
xin = int ( input ( ) ) <NEWLINE> <NL> if ( X >= 30 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
x = input ( ) <NEWLINE> <NL> if x >= 30 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
val = input ( ) <NEWLINE> <NL> if val >= 30 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
if X >= 30 and X <= 40 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
if int ( input ( ) ) >= 30 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> lese : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
X = input ( ) <NEWLINE> if X < 30 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> if n >= 30 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> else : <NEWLINE> print ( <STRING> ) <NEWLINE> <DEDENT>
a = int ( input ) <NEWLINE> if a >= 30 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
int ( input ( ) ) <NEWLINE> <NL> if X >= 30 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
if X < 29 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
X = input ( ) <NEWLINE> if X >= 30 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
x = int ( input ) <NEWLINE> if x < 30 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> else : <NEWLINE> print ( <STRING> ) <NEWLINE> <DEDENT>
x = int ( input ( ) ) <NEWLINE> if x >= 30 : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT>
A = input ( int ( ) ) <NEWLINE> if 30 <= A : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
if ( int ( input ( ) ) < 30 : print ( <STRING> ) <NEWLINE> else : print ( <STRING> ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> <NL> if X >= 30 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
X = input ( ) <NEWLINE> <NL> if X >= 30 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
x = int ( input ) <NEWLINE> if x >= 30 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
t = input ( ) <NEWLINE> <NL> if t >= 30 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> x = int ( input ( ) ) <NEWLINE> if x >= 30 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> main ( 9 <NEWLINE>
a = input ( ) <NEWLINE> <NL> if a >= 30 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
if __name__ == <STRING> : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> if x < 29 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
tem = input ( ) <NEWLINE> if tem >= 30 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
if ( int ( input ( ) ) >= 30 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
if int ( input ( ) ) > 30 print ( <STRING> ) else print ( <STRING> ) <NEWLINE>
X = input ( ) <NEWLINE> <NL> if X >= 40 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
x = int ( raw_input ( ) ) <NEWLINE> if ( x >= 30 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
if input ( ) >= 30 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
if input ( ) >= 30 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
if X >= 30 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
x = int ( input ( ) ) <NEWLINE> if x >= 30 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> praint ( <STRING> ) <NEWLINE> <DEDENT>
a = int ( intput ( ) ) <NEWLINE> if a >= 30 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
x = int ( input ( ) ) <NEWLINE> if x = > 30 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import sys <NEWLINE> input = sys . stdin . reaedline <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> x = int ( input ( ) ) <NEWLINE> <NL> if x >= 30 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> else : <NEWLINE> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> main ( ) <NEWLINE>
if X >= 30 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> tem = str ( s ) <NEWLINE> if tem >= 30 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
X = int ( input ( ) ) <NEWLINE> if X = > 30 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
x = int ( input ( ) ) <NEWLINE> if x >= 30 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> else : <NEWLINE> print ( <STRING> ) <NEWLINE> <DEDENT>
x = input ( ) <NEWLINE> if x >= 30 : print ( <STRING> ) <NEWLINE> else : print ( <STRING> ) <NEWLINE>
X = int ( input ( ) ) <NEWLINE> <NL> if X >= 30 : <NEWLINE> <INDENT> print ( Yes ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( No ) <NEWLINE> <DEDENT>
x = int ( input ( ) ) <NEWLINE> if x = > 30 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a = int ( input ( ) ) <NEWLINE> if a >= 30 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
x = int ( input ( ) ) <NEWLINE> if x >= 30 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
a = input ( ) <NEWLINE> if a >= 30 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
x = int ( input ( ) ) <NEWLINE> if ( x >= 30 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> prinit ( <STRING> ) <NEWLINE> <DEDENT>
x = input ( ) <NEWLINE> <NL> if - 40 <= x and x <= 40 : <NEWLINE> <INDENT> if x >= 30 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
x = input ( ) <NEWLINE> <NL> def temp ( num ) : <NEWLINE> <INDENT> if num >= 30 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> temp ( x ) <NEWLINE>
n = int ( intput ( ) ) <NEWLINE> if 30 <= n : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
X = int ( input ( ) ) <NEWLINE> <NL> if ( N >= 30 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
X_string = input ( ) <NEWLINE> int = input ( X_string ) <NEWLINE> if X >= 30 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
temp = int ( input ( ) ) <NEWLINE> <NL> if temp >= 30 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : 3 <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
x = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> if 30 = < x : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
X = int ( input ( ) ) <NEWLINE> if x >= 30 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> if n >= 30 : <NEWLINE> <INDENT> l = <STRING> <NEWLINE> else : <NEWLINE> l = <STRING> <NEWLINE> print ( l ) <NEWLINE> <DEDENT>
X = int ( input ( ) ) <NEWLINE> <NL> if X = > 30 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> if ( x >= 30 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
int ( X ) <NEWLINE> if X >= 30 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
int ( raw_input ( ) ) <NEWLINE> if x > 30 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
X = input ( ) <NEWLINE> <NL> if X >= 30 : <NEWLINE> <INDENT> return Yes <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return No <NEWLINE> <DEDENT>
int x = int ( input ( ) ) <NEWLINE> if x >= 30 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = input ( ) <NEWLINE> if n >= 30 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
tem = int . input ( ) <NEWLINE> if tem >= 30 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
int ( x ) = input ( ) <NEWLINE> <NL> if x >= 30 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
X = int ( input ( ) ) <NEWLINE> if 30 <= X <= 40 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif : - 40 <= X < 30 <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
X = input ( ) <NEWLINE> if X >= 30 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
temp = input ( ) <NEWLINE> if temp >= 30 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a = input ( ) <NEWLINE> if a >= 30 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> if N >= 30 : <NEWLINE> <INDENT> print ( Yes ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( No ) <NEWLINE> <DEDENT>
x = input ( ) <NEWLINE> <NL> if x >= 30 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
x = int ( input ( ) ) <NEWLINE> if x > 30 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
X = float ( input ( ) ) <NEWLINE> if X = > 30 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
x = int ( input ( ) ) <NEWLINE> if x >= 30 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
x = int ( input ( ) ) <NEWLINE> <NL> if x >= 30 : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT>
x = input ( ) <NEWLINE> <NL> if x >= 30 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
if X = > 30 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
X = int ( input ( ) ) <NEWLINE> return X >= 30 <NEWLINE>
n = int ( input ( ) ) <NEWLINE> if n >= 30 : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT>
x = input ( ) <NEWLINE> <NL> if x >= 30 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
X = int ( input ( ) ) <NEWLINE> print ( <STRING> ) [ X > 29 : : 2 ] <NEWLINE>
x = input ( ) <NEWLINE> if x >= 30 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ) <NEWLINE> if n < 30 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
X = int ( input ( ) ) <NEWLINE> if x >= 30 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> x = input ( ) <NEWLINE> if ( x >= 30 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> if 30 <= n <= 40 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> elif 0 < n <= 29 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
X = input ( ) <NEWLINE> print ( <STRING> if X >= 30 else <STRING> ) <NEWLINE>
x = input ( ) <NEWLINE> if ( x >= 30 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> if ( x < 30 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
x = input ( ) <NEWLINE> if x >= 30 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import sys <NEWLINE> a = int ( sys . stdin ) <NEWLINE> if a >= 30 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
i = int ( input ( ) ) <NEWLINE> <NL> if i >= 30 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
x = int ( input ( ) ) <NEWLINE> if x >= 30 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> else : <NEWLINE> print ( <STRING> ) <NEWLINE> <DEDENT>
X = input ( ) <NEWLINE> if X >= 30 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
if input ( ) = > 30 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
X = input ( ) <NEWLINE> if X < 30 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a = input ( ) <NEWLINE> <NL> if a >= 30 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
x = int ( iput ( ) ) <NEWLINE> if x >= 30 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a = input ( ) <NEWLINE> text = int ( a ) <NEWLINE> if text >= 30 <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
print ( [ <STRING> , <STRING> ] [ int ( input ) >= 30 ] ) <NEWLINE>
import datetime <NEWLINE> import string <NEWLINE> import re <NEWLINE> import math <NEWLINE> <NL> input = Int ( input ( ) ) <NEWLINE> <NL> if input >= 30 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> return <NEWLINE>
x = input ( ) <NEWLINE> if x >= 30 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif x < 30 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
X = int ( input ( ) ) <NEWLINE> if X >= 30 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> 9 ) <NEWLINE> <DEDENT>
temperature = int ( input ( ) ) <NEWLINE> <NL> if 30 <= temperature : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> els : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> def yana ( int ( input ( ) ) >= 30 ) : <NEWLINE> <INDENT> if boo : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
X = int ( input ( ) ) <NEWLINE> if X >= 30 : <NEWLINE> <INDENT> print ( <STRING> ) : <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) : <NEWLINE> <NL> <DEDENT>
int t = 30 <NEWLINE> if ( t >= 30 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> if n >= 25 : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT>
X = int ( input ( ) . split ( ) ) <NEWLINE> <NL> if X >= 30 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
x = int ( input ( ) ) <NEWLINE> if x = > 30 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT>
X = int ( input ( ) ) <NEWLINE> ans = None <NEWLINE> <NL> if X >= 30 : <NEWLINE> <INDENT> ans = Yes <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = No <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
if 30 <= x : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT>
N , D = map ( int , input ( ) . split ( ) ) <NEWLINE> l = [ ] <NEWLINE> l1 = [ ] <NEWLINE> count = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> l . append ( x ) <NEWLINE> l1append ( y ) <NEWLINE> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> if ( l [ i ] ** 2 + l1 [ i ] ** 2 ) ** 0.5 <= D : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE> <NL>
N , D = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> X , Y = map ( int , input ( ) . split ( ) ) <NEWLINE> A = ( ( X ** 2 + Y ** 2 ) ** 0.5 ) <NEWLINE> if A <= D : <NEWLINE> <INDENT> Z = Z + 1 <NEWLINE> <DEDENT> <DEDENT> print ( Z ) <NEWLINE> <NL>
n , d = map ( int , input ( ) . split ( ) ) <NEWLINE> lst = [ [ int ( j ) for j in input ( ) . split ( ) ] for i in range ( n ) ] <NEWLINE> count = 0 <NEWLINE> for d in lst : <NEWLINE> <INDENT> distance = ( d [ 0 ] ** 2 + d [ 1 ] ** 2 ) ** 0.5 <NEWLINE> if distance <= d : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
n , max_dist = int ( input ( ) ) <NEWLINE> points = 0 <NEWLINE> <NL> for _ in range ( n ) : <NEWLINE> <INDENT> x , y = int ( input ( ) ) <NEWLINE> dist = sqrt ( x * x + y * y ) <NEWLINE> <NL> if dist <= max_dist : <NEWLINE> <INDENT> points += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( points ) <NEWLINE>
ma = lambda : map ( int , input ( ) . split ( ) ) <NEWLINE> ni = lambda : int ( input ( ) ) <NEWLINE> yn = lambda fl : print ( <STRING> ) if fl else print ( <STRING> ) <NEWLINE> import collections <NEWLINE> import math <NEWLINE> import itertools <NEWLINE> import heapq as hq <NEWLINE> n , d = ma ( ) <NEWLINE> cnt = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> p , q = ma ( ) <NEWLINE> if p ** 2 + q ** 2 <= D ** 2 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
n , d = list ( map ( int , input ( ) . strip ( ) ) ) <NEWLINE> cnt = 0 <NEWLINE> d2 = d ** 2 <NEWLINE> x , y = [ ] , [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> tx , ty = list ( map ( int , input ( ) . strip ( ) ) ) <NEWLINE> x . append ( tx ) <NEWLINE> y . append ( ty ) <NEWLINE> <NL> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> if ( x [ i ] ** 2 + y [ i ] ** 2 <= d2 ) : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
n , d = map ( int , input ( ) . split ( ) ) <NEWLINE> s = 0 <NEWLINE> for i in range ( n + 1 ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> if x ** 2 + y ** 2 <= d ** 2 : <NEWLINE> <INDENT> s = s + 1 <NEWLINE> <DEDENT> <DEDENT> print ( s ) <NEWLINE>
import math <NEWLINE> <NL> n , d = int ( input ( ) . split ( ) ) <NEWLINE> count = 0 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> xn , yn = int ( input ( ) . split ( ) ) <NEWLINE> if d >= math . sqrt ( xn ** 2 + yn ** 2 ) : <NEWLINE> <INDENT> count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
N , D = input ( ) . split ( ) <NEWLINE> N = int ( N ) <NEWLINE> D = int ( D ) <NEWLINE> count = 0 <NEWLINE> <NL> list = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> a , b = input ( ) . split ( ) <NEWLINE> list . append ( ( int ( a ) , int ( b ) ) ) <NEWLINE> <NL> <DEDENT> for n in range ( N ) : <NEWLINE> <INDENT> distance = ( ( list [ u ] [ 0 ] ) ** 2 + ( list [ u ] [ 1 ] ) ** 2 ) <NEWLINE> if distance <= D : <NEWLINE> <INDENT> count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
import math <NEWLINE> n , d = map ( int , input ( ) . split ( ) ) <NEWLINE> xy = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ] <NEWLINE> cnt = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if math . sqrt ( ( xy [ 0 ] ) ** 2 + ( xy [ 1 ] ) ** 2 ) <= d : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
N , D = map ( int , input ( ) . split ( ) ) <NEWLINE> P = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( M ) ] <NEWLINE> ans = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> num = P [ N ] <NEWLINE> X , Y = num <NEWLINE> if X * X + Y * Y <= D * D : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
[ N , D ] = input ( ) . split ( ) <NEWLINE> s = 0 <NEWLINE> D = int ( D ) <NEWLINE> D = D ** 2 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> [ X , Y ] = input ( ) . split ( ) <NEWLINE> X = int ( X ) <NEWLINE> Y = int ( Y ) <NEWLINE> Z = X ** 2 + Y ** 2 <NEWLINE> if Z <= D : <NEWLINE> <INDENT> s += 1 <NEWLINE> <DEDENT> <DEDENT> print ( s ) <NEWLINE>
N , D = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = 0 <NEWLINE> for in range ( N ) : <NEWLINE> <INDENT> X , Y = map ( int , input ( ) . split ( ) ) <NEWLINE> if x ** 2 + y ** 2 <= D ** 2 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N , D = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> array = [ [ 0 for i in range ( 2 ) ] for j in range ( N ) ] <NEWLINE> for i in range ( 0 , N ) : <NEWLINE> <INDENT> array [ i ] [ 0 ] , array [ i ] [ 1 ] = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <DEDENT> dis = [ ] <NEWLINE> ans = 0 <NEWLINE> for i in range ( 0 , N ) : <NEWLINE> <INDENT> if ( ( array [ i ] [ 0 ] ** 2 ) + ( array [ i ] [ 1 ] ** 2 ) ) not in dis : <NEWLINE> <INDENT> dis . append ( ( ( array [ i ] [ 0 ] ** 2 ) + ( array [ i ] [ 1 ] ** 2 ) ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> for i in dis <NEWLINE> <INDENT> if D ** 2 >= i : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import numpy as np <NEWLINE> <COMMENT> <NL> N , D = input ( ) . strip ( ) . split ( ) <NEWLINE> N = int ( N ) <NEWLINE> D = int ( D ) <NEWLINE> <COMMENT> <NL> grid = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> array = list ( map ( int , input ( ) . strip ( ) . split ( ) ) ) <NEWLINE> grid . append ( array ) <NEWLINE> <NL> <DEDENT> count = 0 <NEWLINE> for i in range ( 0 , N ) : <NEWLINE> <INDENT> dist = sqrt ( grid [ i ] [ 0 ] ^ 2 + grid [ i ] [ 1 ] ^ 2 ) <NEWLINE> if dist <= D : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> d , n = map ( int , input ( ) . split ( ) ) <NEWLINE> counter = 0 <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> if x ** 2 + y ** 2 <= d ** 2 : <NEWLINE> <INDENT> counter += 1 <NEWLINE> <DEDENT> <DEDENT> return print ( counter ) <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE>
<NL> for i in range ( n ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> if x ** 2 + y ** 2 <= d ** 2 : <NEWLINE> <INDENT> s += 1 <NEWLINE> <DEDENT> <DEDENT> print ( s ) <NEWLINE>
n , d = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = 0 <NEWLINE> import numpy as np <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> if np . norm ( np . array ( [ x , y ] ) , ord = 2 ) <= d : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N , D = map ( int , input ( ) . split ( ) ) <NEWLINE> X = [ ] <NEWLINE> Y = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> x , y = input ( ) . split ( ) <NEWLINE> X . append ( int ( x ) ) <NEWLINE> Y . append ( int ( y ) ) <NEWLINE> <NL> <DEDENT> import math <NEWLINE> def get_distance ( x , y ) : <NEWLINE> <INDENT> d = math . sqrt ( ( ( x ) ** 2 + ( y ) ** 2 ) ) <NEWLINE> return d <NEWLINE> <NL> <DEDENT> a = 0 <NEWLINE> for i in range ( N + 1 ) : <NEWLINE> <INDENT> distance = get_distance ( x = X [ i ] , y = Y [ i ] ) <NEWLINE> if distance <= D : <NEWLINE> <INDENT> a += 1 <NEWLINE> <DEDENT> <DEDENT> print ( a ) <NEWLINE>
import math <NEWLINE> <NL> N , D = map ( int , input ( ) . split ( ) ) <NEWLINE> cnt = 0 <NEWLINE> for n in range ( N ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if sqrt ( a ** 2 + b ** 2 ) - D >= 0 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
import math <NEWLINE> xy = [ map ( int , input ( ) . split ( ) ) for _ in range ( 5 ) ] <NEWLINE> x , y = [ list ( i ) for i in zip ( * xy ) ] <NEWLINE> <NL> n = 0 <NEWLINE> <NL> for i , index in enumerate ( x [ 0 ] ) : <NEWLINE> <INDENT> m = math . sqrt ( x [ i + 1 ] ** 2 + y [ i + 1 ] ** 2 ) <NEWLINE> if ( m <= y [ 0 ] ) : <NEWLINE> <INDENT> n += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( n ) <NEWLINE>
import math <NEWLINE> <NL> N , D = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> x = [ 0 ] * N <NEWLINE> y = [ 0 ] * N <NEWLINE> b = 0 <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> x [ i ] , y [ i ] = map ( int , input ( ) . split ( ) ) <NEWLINE> <INDENT> a = x [ i ] ** 2 + y [ i ] ** 2 <NEWLINE> if math . sqrt ( a ) <= D : <NEWLINE> <INDENT> b += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( b ) <NEWLINE>
from math import sqrt <NEWLINE> n , d = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ map ( int , input ( ) . split ( ) ) for _ in range ( n ) ] <NEWLINE> cnt = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if pow ( d , 2 ) >= pow ( a [ i ] [ 0 ] , 2 ) + pow ( a [ i ] [ 1 ] , 2 ) : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
def lineFromPoints ( P , Q ) : <NEWLINE> <NL> <INDENT> a = Q [ 1 ] - P [ 1 ] <NEWLINE> b = P [ 0 ] - Q [ 0 ] <NEWLINE> c = a * ( P [ 0 ] ) + b * ( P [ 1 ] ) <NEWLINE> <NL> if ( b < 0 ) : <NEWLINE> <INDENT> print ( <STRING> , <NEWLINE> <INDENT> a , <STRING> , b , <STRING> , c , <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> , <NEWLINE> <INDENT> a , <STRING> , b , <STRING> , c , <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> n = int ( input ( <STRING> ) ) <NEWLINE> P = [ ] <NEWLINE> Q = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> temp = int ( input ( <STRING> ) ) <NEWLINE> P . append ( temp ) <NEWLINE> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> temp = int ( input ( <STRING> ) ) <NEWLINE> Q . append ( temp ) <NEWLINE> <NL> <DEDENT> lineFromPoints ( P , Q ) <NEWLINE> <DEDENT>
n , d = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> count = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> x , y = list ( map ( int , input . split ( ) ) ) <NEWLINE> if ( x ** 2 + y ** 2 ) ** 0.5 <= d : <NEWLINE> <INDENT> count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
N , D = list ( map ( int , input ( ) ) ) <NEWLINE> <NL> cnt = 0 <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> x , y = list ( map ( int , input ( ) ) ) <NEWLINE> <NL> if x ** 2 + y ** 2 <= D ** 2 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
import math <NEWLINE> N , D = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> d = math . sprt ( x ** 2 + y ** 2 ) <NEWLINE> if d <= D : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n , d = map ( int , input ( ) . split ( ) ) <NEWLINE> x = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( n ) ] <NEWLINE> <NL> ans = 0 <NEWLINE> for i , j in x : <NEWLINE> <INDENT> if ( i ** 2 ) + ( j ** 2 ) ) <= d ** 2 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n , d = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> p = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range n ] <NEWLINE> <NL> kyori = d * d <NEWLINE> count = 0 <NEWLINE> <NL> for s in range ( n ) : <NEWLINE> <INDENT> nagasa = p [ s ] [ 0 ] * p [ s ] [ 0 ] + p [ s ] [ 1 ] * p [ s ] [ 1 ] <NEWLINE> if nagasa <= kyori : <NEWLINE> <INDENT> count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
import math <NEWLINE> n , d = input ( ) . split ( ) <NEWLINE> points = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> points . append ( [ int ( x ) for x in input ( ) . split ( ) ] ) <NEWLINE> <DEDENT> print ( len ( [ p for p in points if math . sqrt ( p [ 0 ] ** 2 + p [ 1 ] ** 2 ) <= d ] ) ) <NEWLINE>
import math <NEWLINE> N = int ( input ( ) ) <NEWLINE> x = int ( input ( ) ) <NEWLINE> y = int ( input ( ) ) <NEWLINE> <NL> D = int ( input ( ) ) <NEWLINE> distance = math . sqrt ( x ** 2 + y ** 2 ) <NEWLINE> <NL> count = 0 <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> if distance <= D : <NEWLINE> <INDENT> count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
import numpy as np <NEWLINE> n = input ( ) <NEWLINE> n = int ( n ) <NEWLINE> d = input ( ) <NEWLINE> d = int ( d ) <NEWLINE> count = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> x = input ( ) <NEWLINE> y = input ( ) <NEWLINE> x = int ( x ) <NEWLINE> y = int ( y ) <NEWLINE> dist = ( ( x ** 2 ) + ( y ** 2 ) ) ** 0.5 <NEWLINE> if dist <= d : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
N , D = map ( int , input ( ) . split ( ) ) <NEWLINE> count = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> if x ^ 2 + y ^ 2 <= D ^ 2 : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> return count <NEWLINE>
n , d = map ( int , input ( ) . split ( ) ) <NEWLINE> x = [ 0 ] * n <NEWLINE> y = [ 0 ] * n <NEWLINE> <NL> count = 0 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> x [ i ] , y [ i ] = map ( int , input ( ) . split ( ) ) <NEWLINE> if x [ i ] ** 2 + y [ i ] ** 2 <= d ** 2 : <NEWLINE> count = + 1 <NEWLINE> <DEDENT> print ( count ) <NEWLINE>
import sys <NEWLINE> a = [ ] <NEWLINE> for l in sys . stdin : <NEWLINE> <INDENT> a . append ( map ( lambda x : int ( x ) , l . split ( <STRING> ) ) ) <NEWLINE> <NL> <DEDENT> N = a [ 0 ] [ 0 ] <NEWLINE> D = a [ 0 ] [ 1 ] <NEWLINE> coo = a [ 1 : ] <NEWLINE> <NL> import math <NEWLINE> <NL> count = 0 <NEWLINE> for c in coo : <NEWLINE> <INDENT> l = math . sqrt ( c [ 0 ] ** 2 + c [ 1 ] ** 2 ) <NEWLINE> if l <= D : <NEWLINE> <INDENT> count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
, D = map ( int , input ( ) . split ( ) ) <NEWLINE> X = [ ] <NEWLINE> Y = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> X . append ( x ) <NEWLINE> Y . append ( y ) <NEWLINE> <DEDENT> ans = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if X [ i ] ** 2 + Y [ i ] ** 2 <= D ** 2 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
I = lambda : list ( map ( int , input ( ) . spilt ( ) ) ) <NEWLINE> n , d = I ( ) <NEWLINE> def ch ( a , b ) : <NEWLINE> <INDENT> return a ** 2 + b ** 2 <NEWLINE> <DEDENT> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> x , y = I ( ) <NEWLINE> if ch ( x , y ) <= d : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL>
N = int ( input ( ) ) <NEWLINE> D = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> x , y = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> if x * x + y * y <= D * D : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n , d = input ( ) . split ( ) <NEWLINE> n = int ( n ) <NEWLINE> d = int ( d ) <NEWLINE> xy = [ map ( int , input ( ) . split ( ) ) for _ in range ( 5 ) ] <NEWLINE> x , y = [ list ( i ) for i in zip ( * xy ) ] <NEWLINE> c = 0 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> if x [ i ] * x [ i ] + y [ i ] * y [ i ] <= d * d : <NEWLINE> <INDENT> c += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( c ) <NEWLINE>
N , D = map ( int , input ( ) . split ( ) ) <NEWLINE> a = 0 <NEWLINE> for num in N : <NEWLINE> <INDENT> X , Y = map ( int , input ( ) . split ( ) ) <NEWLINE> if X * X + Y * Y <= D * D : <NEWLINE> <INDENT> a = 1 <NEWLINE> <DEDENT> <DEDENT> print ( a ) <NEWLINE>
import math <NEWLINE> N , D = map ( int , input ( ) . split ( ) ) <NEWLINE> c = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> X , Y = map ( int , input ( ) . split ( ) ) <NEWLINE> if X <= D and Y <= D <NEWLINE> <INDENT> d = math . sqrt ( X ** 2 + Y ** 2 ) <NEWLINE> if d <= D : <NEWLINE> <INDENT> c = c + 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( c ) <NEWLINE>
N , D = map ( int ( ) , input ( ) . split ( ) ) <NEWLINE> answer = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> x , y = map ( int ( ) , input ( ) . split ( ) ) <NEWLINE> if ( D ** 2 >= x ** 2 + y ** 2 ) : <NEWLINE> <INDENT> answer += 1 <NEWLINE> <DEDENT> <DEDENT> print ( answer ) <NEWLINE>
n , d = map ( int , input ( ) . split ( ) ) <NEWLINE> count = 0 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) , split ( ) ) <NEWLINE> if d ^ 2 >= x ^ 2 + y ^ 2 : <NEWLINE> <INDENT> count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
import math <NEWLINE> <NL> n , dis = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> count = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> if math . sqrt ( x ^ 2 + y ^ 2 ) <= dis : <NEWLINE> <INDENT> count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> . format ( count ) ) <NEWLINE>
st = input ( ) . split ( ) <NEWLINE> n = int ( st [ 0 ] ) <NEWLINE> d = int ( st [ 1 ] ) <NEWLINE> <NL> c = 0 <NEWLINE> <NL> for i in ramge ( n ) : <NEWLINE> <INDENT> middle = input ( ) . split ( ) <NEWLINE> x = int ( middle [ 0 ] ) <NEWLINE> y = int ( middle [ 1 ] ) <NEWLINE> if x ** 2 + y ** 2 <= d ** 2 : <NEWLINE> <INDENT> c += 0 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( c ) <NEWLINE> <NL> <NL>
N , D = map ( int , input ( ) . split ( ) ) <NEWLINE> number = 0 <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> X , Y = map ( int , input ( ) . split ( ) ) <NEWLINE> distance = sqrt ( X * X + Y * Y ) <NEWLINE> if distance <= D : <NEWLINE> <INDENT> number += 1 <NEWLINE> <DEDENT> <DEDENT>
n , d = [ int ( i ) for i in input ( ) . strip ( ) . split ( <STRING> ) ] <NEWLINE> ans = 0 <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> x , y = [ int ( i ) for i in input ( ) . strip ( ) . split ( <STRING> ) ] <NEWLINE> if x * x + y * y = d * d : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> N , D = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 0 , N ) : <NEWLINE> <INDENT> A , B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if dist <= D : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import math <NEWLINE> <NL> list = input ( ) . split ( <STRING> ) <NEWLINE> num = int ( list [ 0 ] ) <NEWLINE> d = int ( list [ 1 ] ) <NEWLINE> ans = 0 <NEWLINE> <NL> for i in num : <NEWLINE> <INDENT> list2 = input ( ) . split ( <STRING> ) <NEWLINE> x = list2 [ 0 ] <NEWLINE> y = list2 [ 1 ] <NEWLINE> distance = math . sqrt ( x ** 2 + y ** 2 ) <NEWLINE> if distance <= d : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n , d = map ( int , input ( ) . split ( ) ) <NEWLINE> cnt = 0 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> Z = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> X = Z [ 0 ] <NEWLINE> Y = Z [ 1 ] <NEWLINE> <NL> if X ** 2 + Y ** 2 <= D ** 2 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
import math <NEWLINE> n , d = map ( int ( input ( ) . split ( ) ) ) <NEWLINE> c = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a , b = map ( int ( input ( ) . split ( ) ) ) <NEWLINE> r = math . sqrt ( a ** 2 + b ** 2 ) <NEWLINE> if r <= d : <NEWLINE> <INDENT> c += 1 <NEWLINE> <DEDENT> <DEDENT> print ( c ) <NEWLINE>
N , D = map ( int , input ( ) . split ( ) ) <NEWLINE> X = [ ] <NEWLINE> Y = [ ] <NEWLINE> count = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> a , b = map ( float , input ( ) . split ( ) ) <NEWLINE> X . append ( a ) <NEWLINE> Y . append ( b ) <NEWLINE> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> if ( X [ i ] ^ 2 + Y [ i ] ^ 2 ) ^ ( 1 / 2 ) <= D : <NEWLINE> <INDENT> count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
n , d = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ ] <NEWLINE> b = [ ] <NEWLINE> cnt = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a [ i ] , b [ i ] = map ( int , input ( ) . split ( ) ) <NEWLINE> if a [ i ] ** 2 + b [ i ] ** 2 <= d ** 2 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> . format ( cnt ) ) <NEWLINE>
n , d = map ( int , input ( ) ) <NEWLINE> <NL> count = 0 <NEWLINE> for t in range ( n ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) ) <NEWLINE> if x * x + y * y <= d * d : <NEWLINE> <INDENT> count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
import math <NEWLINE> N , D = map ( int , input ( ) . split ( ) ) <NEWLINE> P = [ list ( map ( int , input ( ) . split ( ) ) for _ in range ( N ) ) ] <NEWLINE> <NL> cnt = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> d = math . sqrt ( P [ 0 ] ** 2 + P [ 1 ] ** 2 ) <NEWLINE> if d <= D : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
import math <NEWLINE> n , d = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> count = 0 <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> x , y = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if math . sqrt ( x ** 2 + y ** 2 ) >= d <NEWLINE> count += 1 <NEWLINE> <DEDENT> print ( count ) <NEWLINE>
N , D = input ( ) . split ( ) <NEWLINE> N = int ( N ) <NEWLINE> D = int ( D ) <NEWLINE> cnt = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <NL> <NL> <INDENT> p1 , p2 = map ( int , input ( ) . split ( ) ) <NEWLINE> t = ( ( p1 * p1 ) ( p2 * p2 ) ) ** ( 0.5 ) <NEWLINE> if t >= D : <NEWLINE> <NL> <INDENT> cnt += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> H = [ int ( num ) for num in input ( ) . split ( ) ] <NEWLINE> ans = [ 1 ] * N <NEWLINE> <NL> for i in range ( M ) : <NEWLINE> <INDENT> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> if ( H [ A - 1 ] > H [ B - 1 ] ) : <NEWLINE> <INDENT> ans [ B - 1 ] = 0 <NEWLINE> <DEDENT> elif ( H [ B - 1 ] > H [ A - 1 ] ) : <NEWLINE> <INDENT> ans [ A - 1 ] = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans [ A - 1 ] = 0 <NEWLINE> ans [ B - 1 ] = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( sum ( ans ) ) <NEWLINE>
import math <NEWLINE> N = int ( input ( ) ) <NEWLINE> D = int ( input ( ) ) <NEWLINE> c = 0 <NEWLINE> ans = 0 <NEWLINE> while c < N : <NEWLINE> <INDENT> x = int ( input ( ) ) <NEWLINE> y = int ( input ( ) ) <NEWLINE> if x * x + y * y <= D * D : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> c += 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
N , D = map ( int , input ( ) . split ( ) ) <NEWLINE> sum = 0 <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> X , Y = map ( int , input ( ) . split ( ) ) <NEWLINE> if math . sqrt ( ( ( X * X ) + ( Y * Y ) ) ) <= D : <NEWLINE> <INDENT> sum = sum + 1 <NEWLINE> <DEDENT> <DEDENT> print ( sum ) <NEWLINE> <NL>
n , d = map ( int , input ( ) . split ( ) ) <NEWLINE> cnt = 0 <NEWLINE> while ( n - - ) : <NEWLINE> <INDENT> p , q = map ( int , input ( ) . split ( ) ) <NEWLINE> if p ** 2 + q ** 2 <= d ** 2 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
import math <NEWLINE> <NL> def dist ( x , y ) : <NEWLINE> <INDENT> math . sqrt ( x ^ 2 + y ^ 2 ) <NEWLINE> <NL> <DEDENT> ( n , d ) = map ( int , input ( ) . split ( ) ) <NEWLINE> res = 0 <NEWLINE> <NL> for _ in range ( n ) : <NEWLINE> <INDENT> ( x , y ) = map ( int , input ( ) . split ( ) ) <NEWLINE> res += 1 if dist ( x , y ) <= d else 0 <NEWLINE> <NL> <DEDENT> print ( res ) <NEWLINE>
<NL> <NL> param_n , param_d = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> param_count = 0 <NEWLINE> for i in param_n : <NEWLINE> <INDENT> param_a , param_b = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if ( param_a ) * ( param_a ) + ( param_b ) * ( param_b ) <= ( param_d ) * ( param_d ) : <NEWLINE> <INDENT> param_count = param_count + 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( param_count ) <NEWLINE>
n , d = map ( int , input ( ) . split ( ) ) <NEWLINE> xy = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> x . append ( [ a , b ] ) <NEWLINE> <NL> <DEDENT> count = 0 <NEWLINE> for xy in xy : <NEWLINE> <INDENT> count += xy [ 0 ] ** 2 + xy [ 1 ] ** 2 <= d ** 2 <NEWLINE> <NL> <DEDENT> print ( count ) <NEWLINE>
n , d = map ( int , input ( ) . split ( ) ) <NEWLINE> count = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> if x ** 2 + y ** 2 <= d ** 2 : <NEWLINE> count += 1 <NEWLINE> <DEDENT> print ( count ) <NEWLINE>
n , d = list ( map ( int , split ( ) . input ( ) ) ) n , d = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> count = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> x , y = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> p = x ** 2 + y ** 2 <NEWLINE> if p <= d ** 2 : <NEWLINE> <INDENT> count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
N , D = map ( int , input ( ) . split ( ) ) <NEWLINE> count = 0 <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> d = sqrt ( x ** 2 + y ** 2 ) <NEWLINE> <NL> if d <= D : <NEWLINE> <INDENT> count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
N , D = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( N ) ] <NEWLINE> <NL> count = 0 <NEWLINE> for a in A : <NEWLINE> <INDENT> print ( a [ 0 ] ** 2 + a [ 1 ] ** 2 ) <NEWLINE> if a [ 0 ] ** 2 + a [ 1 ] ** 2 <= D ** 2 <NEWLINE> <INDENT> count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
n , d = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> if x ** 2 + y ** 2 <= d ** 2 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> <NL> n , d = input ( ) . split ( ) <NEWLINE> n = int ( n ) <NEWLINE> d = int ( d ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> x , y = input ( ) . split ( ) <NEWLINE> x = int ( x ) <NEWLINE> y = int ( y ) <NEWLINE> <NL> a = math . sqrt ( x * x + y * y ) <NEWLINE> <NL> if a <= d : <NEWLINE> <INDENT> nanko += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( nanko ) <NEWLINE>
import math <NEWLINE> X , D = map ( int , input ( ) . split ( ) ) <NEWLINE> n = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> if math . sqrt ( x ** 2 + y ** 2 ) <= D : <NEWLINE> <INDENT> n += 1 <NEWLINE> <DEDENT> <DEDENT> print ( n ) <NEWLINE>
n , d = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = 0 <NEWLINE> <NL> for i in range ( x ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> z = ( x ** 2 + y ** 2 ) ** 0.5 <NEWLINE> if z <= d : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n , d = map ( int , input ( ) ) <NEWLINE> cnt = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) ) <NEWLINE> if x ** 2 + y ** 2 <= d ** 2 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
n , d = map ( int , input ( ) . split ( ) ) <NEWLINE> ctr = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> t = ( x ** 2 + y ** 2 ) ** ( 1 / 2 ) <NEWLINE> if t >= d : <NEWLINE> <INDENT> ctr += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ctr <NEWLINE>
n , d = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <NL> <INDENT> a , b = map ( int , input ( ) . split ( ) ) if a * a + b * b <= d * d : ans += 1 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> N , D = int ( input ( ) ) <NEWLINE> cnt = 0 <NEWLINE> <NL> for n in range ( 0 , N ) : <NEWLINE> <INDENT> x , y = int ( input ( ) ) <NEWLINE> if math . sqrt ( x ^ 2 + y ^ 2 ) > D : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
import math <NEWLINE> n , d = map ( int , input ( ) . split ( ) ) <NEWLINE> l == [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ] <NEWLINE> c = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> x = l [ i ] [ 0 ] <NEWLINE> y = l [ i ] [ 1 ] <NEWLINE> k = math . sqrt ( x ** 2 + y ** 2 ) <NEWLINE> if k <= d : c += 1 <NEWLINE> <DEDENT> print ( c ) <NEWLINE>
N , D = map ( int , input ( ) . split ( ) ) <NEWLINE> X = [ ] <NEWLINE> Y = [ ] <NEWLINE> count = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> Xi , Yi = map ( int , input ( ) . split ( ) ) <NEWLINE> X . append ( Xi ) <NEWLINE> Y . append ( Yi ) <NEWLINE> <NL> <DEDENT> for ll in range ( N ) : <NEWLINE> <INDENT> if ( X ** 2 + Y ** 2 <= D ) : <NEWLINE> <INDENT> count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
import math <NEWLINE> <NL> def distance ( N , D , point ) : <NEWLINE> <INDENT> count = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if math . sqrt ( points [ i ] [ 0 ] ** 2 + points [ i ] [ 1 ] ** 2 ) <= D : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> return count <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> N , D = map ( int , input ( ) . split ( ) ) <NEWLINE> points = [ ] <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> x , y = map ( int , input . split ( ) ) <NEWLINE> points . append ( [ x , y ] ) <NEWLINE> <DEDENT> print ( distance ( N , D , points ) ) <NEWLINE> <DEDENT>
N , D = map ( int , input ( ) . split ( ) ) <NEWLINE> l = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> l . append ( x * x + y * y ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if l [ i ] < D * D : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
import sys <NEWLINE> <NL> <NL> input = list ( ) <NEWLINE> N , D = sys . stdin <NEWLINE> for item in sys . stdin : <NEWLINE> <INDENT> input . append ( item ) <NEWLINE> <NL> <DEDENT> count = 0 <NEWLINE> for item in input : <NEWLINE> <INDENT> if 1 <= N and N <= 2 * 10 ** 5 : <NEWLINE> <INDENT> if 0 <= D and D <= 2 * 10 ** 5 : <NEWLINE> <INDENT> if abs ( item [ 0 ] ) <= 2 * 10 ** 5 and abs ( item [ 1 ] ) <= 2 * 10 ** 5 : <NEWLINE> <INDENT> if D >= ( int ( item [ 0 ] ) ** 2 + int ( item [ 1 ] ) ** 2 ) ** ( 1 / 2 ) : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
from math importsqrt <NEWLINE> n , p = map ( int , input ( ) . split ( ) ) <NEWLINE> r = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> if sqrt ( x * x + y * y ) <= p : <NEWLINE> <INDENT> r += 1 <NEWLINE> <DEDENT> <DEDENT> print ( r ) <NEWLINE>
N , D = map ( int , input ( ) . split ) <NEWLINE> <NL> X = Y = p = count = 0 <NEWLINE> <NL> for index in range ( N ) : <NEWLINE> <INDENT> X , Y = map ( int , input ( ) . split ) <NEWLINE> p = sqrt ( X ** 2 + Y ** 2 ) <NEWLINE> if p <= D : <NEWLINE> <INDENT> count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
n = map ( int , input ( ) . split ( ) ) <NEWLINE> count = 0 <NEWLINE> for i in range ( n [ 0 ] ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> r = ( a ** 2 + b ** 2 ) ** 0.5 <NEWLINE> if r <= n [ 1 ] : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
import math <NEWLINE> N , D = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> count = 0 <NEWLINE> for i in range ( D ) : <NEWLINE> <INDENT> X , Y = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> if math . sqrt ( X ** 2 + Y ** 2 ) <= D : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
N , D = map ( int , input ( ) . split ( ) ) <NEWLINE> d2 = D ** 2 <NEWLINE> rt = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if x ** 2 + y ** 2 < d2 : <NEWLINE> <INDENT> rt += 1 <NEWLINE> <DEDENT> <DEDENT> print ( rt ) <NEWLINE>
import numpy as np <NEWLINE> N , D = map ( int , input ( ) . split ( ) ) <NEWLINE> <COMMENT> <NL> xy = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( N ) ] <NEWLINE> sum = 0 <NEWLINE> for x , y in zip ( xy ) : <NEWLINE> <INDENT> if np . sqrt ( x * x + y * y ) <= D : <NEWLINE> <INDENT> sum += 1 <NEWLINE> <DEDENT> <DEDENT> print ( sum ) <NEWLINE>
c = list ( map ( int , input ( ) . split ( ) ) ) [ 0 ] <NEWLINE> n , d = c [ 0 ] , c [ 0 ] <NEWLINE> <NL> xy = [ map ( int , input ( ) . split ( ) ) for _ in range ( n ) ] <NEWLINE> x , y = [ list ( i ) for i in zip ( * xy ) ] <NEWLINE> <NL> count = 0 <NEWLINE> <NL> for i in range ( n - 1 ) : <NEWLINE> <INDENT> a = x [ i ] * x [ i ] + y [ i ] * y [ i ] <NEWLINE> if a <= d * d : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
N , D = map ( int , input ( ) . split ( ) ) <NEWLINE> point = [ list ( map ( int , input ( ) . split ( ) ) ) for x in range ( N ) ] <NEWLINE> count = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if D >= ( point [ i ] [ 0 ] ** 2 + point [ i ] [ 1 ] ** 2 ) ** 0.5 : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
import math <NEWLINE> n = [ ] <NEWLINE> n = int ( input ( ) . split ( ) ) <NEWLINE> <NL> def caldis ( x , y ) : <NEWLINE> <INDENT> l = math . sqrt ( x ** 2 + y ** 2 ) <NEWLINE> return l <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> <NL> <NL> for i in n [ 0 ] : <NEWLINE> <INDENT> input_num = [ ] <NEWLINE> input_num = int ( input ( ) . split ( ) ) <NEWLINE> <NL> if caldis ( input_num [ 0 ] , input_num [ 1 ] ) <= n [ 1 ] : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import sqrt <NEWLINE> N , D = map ( int , input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> p , q = map ( int , input ( ) . split ( ) ) <NEWLINE> if math . sqrt ( p ** 2 + q ** 2 ) <= D : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n , d = map ( int , input ( ) . split ( ) ) <NEWLINE> cnt = 0 <NEWLINE> while ( n > 0 ) : <NEWLINE> <INDENT> p , q = map ( int , input ( ) . split ( ) ) <NEWLINE> if d ** 2 <= ( p ** 2 ) + ( q ** 2 ) : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
N , Q = [ int ( w ) for w in input ( ) . split ( ) ] <NEWLINE> i = 0 <NEWLINE> x = [ ] <NEWLINE> y = [ ] <NEWLINE> while i < N : <NEWLINE> <INDENT> a , b = [ int ( w ) for w in input ( ) . split ( ) ] <NEWLINE> x . append ( a ) <NEWLINE> y . append ( b ) <NEWLINE> i += 1 <NEWLINE> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> m = ( x [ i ] ** 2 + y [ i ] ** 2 ) ** ( 1 / 2 ) <NEWLINE> if m <= Q : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> count += 0 <NEWLINE> <DEDENT> <DEDENT> print ( count ) = 0 <NEWLINE>
N , D = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = 0 <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> X , Y = map ( int , input ( ) . split ( ) ) <NEWLINE> if D : : 2 >= X ** 2 + y ** 2 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
n , d = map ( int , input ( ) . split ( ) ) <NEWLINE> count = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if ( ( a + b ) * ( a - b ) ) ** ( 1 / 2 ) <= d : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
import math <NEWLINE> n , d = map ( int , input ( ) . split ( ) ) <NEWLINE> lst1 = [ ] <NEWLINE> lst2 = [ ] <NEWLINE> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> cal = math . sqrt ( x ^ 2 + y ^ 2 ) <NEWLINE> lst1 . append ( cal ) <NEWLINE> <NL> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> if lst1 [ i ] >= d : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> d = int ( input ( ) ) <NEWLINE> cnt = 0 <NEWLINE> for i in range ( 0 , n ) : <NEWLINE> <INDENT> x = int ( input ( ) ) <NEWLINE> y = int ( input ( ) ) <NEWLINE> z = sqrt ( ( x * x ) + ( y * y ) ) <NEWLINE> if ( z >= d ) : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
N = int ( input ( ) . split ( ) [ 0 ] ) <NEWLINE> D = int ( input ( ) . split ( ) [ 1 ] ) <NEWLINE> count = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> Xi = int ( input ( ) . split ( ) [ 0 ] ) <NEWLINE> Yi = int ( input ( ) . split ( ) [ 1 ] ) <NEWLINE> R = ( Xi ** 2 + Yi ** 2 ) ** ( 1 / 2 ) <NEWLINE> if R <= D : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
<COMMENT> <NL> n , d = map ( int , input ( ) . split ( ) ) <NEWLINE> i = 0 <NEWLINE> num = 0 <NEWLINE> while i < n : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> srq = x * x + y * y <NEWLINE> _d = sqrt ( sqr ) <NEWLINE> if _d <= d : <NEWLINE> <INDENT> num += 1 <NEWLINE> <DEDENT> i += 1 <NEWLINE> <NL> <DEDENT> print ( num ) <NEWLINE>
import numpy as np <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> D = int ( input ( ) ) <NEWLINE> count = 0 <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> x = int ( input ( ) ) <NEWLINE> y = int ( input ( ) ) <NEWLINE> d = np . sqrt ( x ** 2 + y ** 2 ) <NEWLINE> <NL> if d <= D : <NEWLINE> <INDENT> count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( count ) <NEWLINE> <NL>
import math <NEWLINE> <NL> N , D = map ( int , input ( ) . split ( ) ) <NEWLINE> count = 0 <NEWLINE> for _ in range ( M ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> xx = x ** 2 <NEWLINE> yy = y ** 2 <NEWLINE> <NL> ans = math . sqrt ( xx + yy ) <NEWLINE> if ans >= D : <NEWLINE> <INDENT> count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
Z = list ( input ( <STRING> ) ) <NEWLINE> N = int ( Z [ 0 ] ) <NEWLINE> D = int ( Z [ 1 ] ) <NEWLINE> count = 0 <NEWLINE> <NL> while ( N - - ) : <NEWLINE> <INDENT> Z1 = list ( input ( <STRING> ) ) <NEWLINE> X = int ( Z1 [ 0 ] ) <NEWLINE> Y = int ( Z1 [ 1 ] ) <NEWLINE> <NL> d = ( X ** 2 + Y ** 2 ) ** 0.5 <NEWLINE> <NL> if d <= D : <NEWLINE> <INDENT> count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
N , D = map ( int , input ( ) ) <NEWLINE> D2 = D * D <NEWLINE> c = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> x , y = sprit ( int , input ( ) ) <NEWLINE> if x * x + y * y <= D2 : <NEWLINE> <INDENT> c += 1 <NEWLINE> <DEDENT> <DEDENT> print ( c ) <NEWLINE> <NL>
<NL> n , d = map ( int , input ( ) . split ( ) ) <NEWLINE> cnt = 0 <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> if ( sqrt ( ( x ** 2 ) + ( y ** 2 ) ) <= d ) : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
import math <NEWLINE> n , d = map ( int , input ( ) . split ( ) ) <NEWLINE> p = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> if sqrt ( pow ( abs ( x ) , 2 ) + pow ( abs ( y ) , 2 ) ) <= d : <NEWLINE> <INDENT> p += 1 <NEWLINE> <DEDENT> <DEDENT> print ( p ) <NEWLINE>
l = [ list ( map ( int , input . split ( ) ) ) for i in range ( n ) ] <NEWLINE> N = l [ 0 ] [ 0 ] <NEWLINE> D = l [ 0 ] [ 1 ] <NEWLINE> count = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if l [ i + 1 ] [ 0 ] ** 2 + l [ i + 1 ] [ 1 ] ** 2 <= D ** 2 : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
N , D = map ( int , input ( ) ) <NEWLINE> <NL> <COMMENT> <NL> <NL> ans = 0 <NEWLINE> if _ in range ( N ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) ) <NEWLINE> if x ** 2 + y ** 2 <= D ** 2 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> n , d = map ( int , input ( ) . split ( ) ) <NEWLINE> r = 0 <NEWLINE> for in range ( n ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if d >= math . sqrt ( a ** 2 + b ** 2 ) : <NEWLINE> <INDENT> r += 1 <NEWLINE> <DEDENT> <DEDENT> print ( r ) <NEWLINE>
N , D = map ( int , input ( ) . split ( ) ) <NEWLINE> count = 0 <NEWLINE> print ( D ) <NEWLINE> print ( index ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if ( a ** 2 + b ** 2 ) <= D ** 2 : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
import math <NEWLINE> <NL> N , D = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = 0 <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> if math . sqrt ( x ** 2 + y ** 2 ) = < D : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N , D = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> if ( x ** 2 + y ** 2 ) <= D ** 2 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += 0 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
i1 = input ( ) <NEWLINE> i2 = int ( i1 . split ( <STRING> ) [ 0 ] ) <NEWLINE> i3 = float ( i1 . split ( <STRING> ) [ 1 ] ) <NEWLINE> i4 = 0 <NEWLINE> i5 = 0 <NEWLINE> i6 = 0 <NEWLINE> li = [ ] <NEWLINE> for i in range ( i2 ) : <NEWLINE> <INDENT> i4 = input ( ) . split ( <STRING> ) <NEWLINE> i5 = ( ( i4 [ 1 ] ) ** 2 - int ( i4 [ 0 ] ) ** 2 ) ** 0.5 <NEWLINE> if ( i3 >= i5 ) : <NEWLINE> <INDENT> i6 += 1 <NEWLINE> <DEDENT> <DEDENT> print ( i6 ) <NEWLINE>
N , D = input ( ) . split ( <STRING> ) <NEWLINE> count = 0 <NEWLINE> for n in range ( int ( N ) ) : <NEWLINE> <INDENT> x , y = input ( ) . split ( <STRING> ) <NEWLINE> if pow ( pow ( x , 2 ) + pow ( y , 2 ) , 0.5 ) <= int ( D ) : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
N , D = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> X = int ( 0 ) <NEWLINE> Y = int ( 0 ) <NEWLINE> B = int ( 0 ) <NEWLINE> Z = int ( 0 ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> A = [ ] <NEWLINE> A = [ int ( N ) for N in input ( ) . split ( ) ] <NEWLINE> X = A [ 0 ] <NEWLINE> Y = A [ 1 ] <NEWLINE> print ( Z = ( ( X ** 2 + Y ** 2 ) ** 0.5 ) ) <NEWLINE> if Z <= D : <NEWLINE> <INDENT> B += 1 <NEWLINE> <DEDENT> <DEDENT> print ( B ) <NEWLINE>
n , d = map ( int , input ( ) . split ( ) ) <NEWLINE> r = 0 <NEWLINE> d_ = d ** 2 <NEWLINE> for i in n : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if d_ >= a ** 2 + b ** 2 : <NEWLINE> <INDENT> r += 1 <NEWLINE> <DEDENT> <DEDENT> print ( r ) <NEWLINE>
N , D = input ( ) . split ( ) <NEWLINE> <NL> x = [ 0 ] * N <NEWLINE> y = [ 0 ] * N <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> x [ i ] , y [ i ] = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <DEDENT> counter = 0 <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> dist = x [ i ] * x [ i ] + y [ i ] * y [ i ] <NEWLINE> if dist <= D * D : <NEWLINE> <INDENT> counter += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( counter ) <NEWLINE>
import math <NEWLINE> data = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( n ) ] <NEWLINE> def dist ( x , y ) : <NEWLINE> <INDENT> return math . sqrt ( x ** 2 + y ** 2 ) <NEWLINE> <DEDENT> count = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> dis = dist ( data [ i ] [ 0 ] , data [ i ] [ 1 ] ) <NEWLINE> if dis <= d : <NEWLINE> <INDENT> count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
N , D = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> X , Y = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> d = X * X + Y * Y <= D * D : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N , D = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( N ) <NEWLINE> <INDENT> X , Y = map ( int , input ( ) . split ( ) ) <NEWLINE> if X * X + Y * Y <= D : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> <NL> N , D = ( int ( x ) for x in input ( ) . split ( ) ) <NEWLINE> <NL> for _ in range ( N ) : <NEWLINE> <INDENT> x , y = ( int ( x ) for x in input ( ) . split ( ) ) <NEWLINE> if x * x + y * y <= D * D : <NEWLINE> <INDENT> result += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( result ) <NEWLINE>
n , d = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> if sqrt ( x ** 2 + y ** 2 ) <= d : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n , d = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) ) <NEWLINE> if x ** 2 + y ** 2 <= d : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> li = input ( ) <NEWLINE> n = int ( li . split ( ) [ 0 ] ) <NEWLINE> d = int ( li . split ( ) [ 1 ] ) <NEWLINE> max_distance = math . sqrt ( d ** 2 ) <NEWLINE> ans = 0 <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> li = input ( ) <NEWLINE> x = int ( li . split [ 0 ] ) <NEWLINE> y = int ( li . split [ 1 ] ) <NEWLINE> distance = math . sqrt ( x ** 2 + y ** 2 ) <NEWLINE> if distance <= max_distance : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N , D = map ( int , input ( ) . split ( ) ) <NEWLINE> sum = 0 <NEWLINE> for i in range ( 0 , N ) : <NEWLINE> <INDENT> X , Y = map ( int , input ( ) . split ( ) ) <NEWLINE> if sqrt ( X ^ 2 + Y ^ 2 ) <= D : <NEWLINE> <INDENT> sum = sum + 1 <NEWLINE> <DEDENT> <DEDENT> print ( sum ) <NEWLINE>
N , D = map ( int , input ( ) . split ( ) ) <NEWLINE> X , Y = [ map ( int , input ( ) . split ( ) ) for i in range ( N ) ] <NEWLINE> <NL> cnt = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if X [ i ] ** 2 + Y [ i ] ** 2 < D ** 2 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
N , D = map ( int , input ( ) . split ( ) ) <NEWLINE> n = 0 <NEWLINE> for x , y = map ( int , input ( ) . split ( ) ) in range ( N ) : <NEWLINE> <INDENT> if ( x ** 2 + y ** 2 ) ** ( 1 / 2 ) <= D : <NEWLINE> <INDENT> n += 1 <NEWLINE> <DEDENT> <DEDENT> print ( n ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> front = 0 <NEWLINE> rear = sum ( a ) <NEWLINE> ans = 10 ** 100 <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> front += a [ i ] <NEWLINE> rear -= a [ i ] <NEWLINE> ans = min ( ans , abs ( front - rear ) ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> d = int ( input ( ) ) <NEWLINE> count = 0 <NEWLINE> for i in range ( 0 , n ) : <NEWLINE> <INDENT> p = int ( input ( ) ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> res = sqrt ( ( p ** 2 ) + ( q ** 2 ) ) <NEWLINE> if res <= d : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
N , D = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> count = 0 <NEWLINE> <NL> for i in N : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> if D > pow ( x ** 2 + y ** 2 , 0.5 ) : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
n , d = map ( int , input ( ) . split ( ) ) <NEWLINE> x = [ ] <NEWLINE> y = [ ] <NEWLINE> cnt = 0 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> x . append ( int ( input ( ) ) ) <NEWLINE> y . append ( int ( input ( ) ) ) <NEWLINE> <NL> <DEDENT> for j in range ( n ) : <NEWLINE> <INDENT> l = ( x [ j ] ** 2 + y [ j ] ** 2 ) ** ( 1 / 2 ) <NEWLINE> if l <= d : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
import math <NEWLINE> <NL> N , D = list ( map ( int , input ( ) . split ( <STRING> ) . rstrip ( ) ) ) <NEWLINE> <NL> cnt = 0 <NEWLINE> def check ( p , q ) : <NEWLINE> <INDENT> r = p ** 2 + q ** 2 <NEWLINE> return math . sqrt ( r ) <NEWLINE> <NL> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> p , q = list ( map ( int , input ( ) . split ( <STRING> ) . rstrip ( ) ) ) <NEWLINE> if check ( p , q ) <= D : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
c = 0 <NEWLINE> N , D = map ( float ( ) , input ( ) . split ( ) ) <NEWLINE> for i in range ( int ( N ) ) : <NEWLINE> <INDENT> a , b = map ( float ( ) , input ( ) . split ( ) ) <NEWLINE> if a ** 2 + b ** 2 <= D : <NEWLINE> <INDENT> c += 1 <NEWLINE> <DEDENT> <DEDENT> print ( c ) <NEWLINE>
import numpy as np <NEWLINE> L = np . array ( map ( int , input ( ) ) ) <NEWLINE> N = L ( 0 , 0 ) <NEWLINE> D = L ( 0 , 1 ) <NEWLINE> cnt = 0 <NEWLINE> for idx in range ( 1 , N ) : <NEWLINE> <INDENT> if L ( idx , 0 ) ** 2 + L ( idx , 1 ) ** 2 <= D ** 2 : <NEWLINE> <INDENT> cnt = cnt + 1 <NEWLINE> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
import math <NEWLINE> print math <NEWLINE> N , D = map ( int , input ( ) . split ( ) ) <NEWLINE> l = [ list ( map ( int , input ( ) . split ( ) ) ) for l in range ( N ) ] <NEWLINE> <NL> ans = 0 <NEWLINE> x = 3 <NEWLINE> for i , a in enumerate ( l ) : <NEWLINE> <INDENT> if math . sqrt ( a [ 0 ] ** 2 + a [ 1 ] ** 2 ) > D : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT>
import math <NEWLINE> <NL> info = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> num = info [ 0 ] <NEWLINE> dis = info [ 1 ] <NEWLINE> A = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( num ) ] <NEWLINE> disA = [ math . squart ( A [ i ] [ 0 ] ^ 2 + A [ i ] [ 1 ] ^ 2 ) for i in range ( num ) ] <NEWLINE> cnt = 0 <NEWLINE> for i in range ( num ) : <NEWLINE> <INDENT> if disA <= dis : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
import numpy as np <NEWLINE> N , D = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> XY = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( N ) ] <NEWLINE> <NL> res = 0 <NEWLINE> for i in XY : <NEWLINE> <INDENT> if np . sqrt ( XY [ i ] [ 0 ] ** 2 + XY [ i ] [ 1 ] ** 2 ) <= D : <NEWLINE> <INDENT> res += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( res ) <NEWLINE>
n , d = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> cnt = 0 <NEWLINE> dist = 0 <NEWLINE> <NL> for i in range ( n ) { <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> dist = x ** 2 + y ** 2 <NEWLINE> if ( dist <= d ) { <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> } <NEWLINE> <DEDENT> } <NEWLINE> <NL> print ( cnt ) <NEWLINE>
n , d = input ( ) <NEWLINE> <NL> count = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> x , y = input ( ) <NEWLINE> <NL> r = ( int ( x ) ** 2 + int ( y ) ** 2 ) ** ( 1 / 2 ) <NEWLINE> <NL> if r <= int ( d ) : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
import math <NEWLINE> <NL> end = 0 <NEWLINE> <NL> n = input ( ) . split ( <STRING> ) <NEWLINE> ato = n [ 0 ] <NEWLINE> <NL> for i in range ( int ( ato ) ) : <COMMENT> <NEWLINE> <INDENT> x = input ( ) . split ( <STRING> ) <NEWLINE> exec ( <STRING> % ( i , int ( x [ 0 ] ) ) ) <NEWLINE> exec ( <STRING> % ( i , int ( x [ 1 ] ) ) ) <NEWLINE> <NL> <DEDENT> for i in range ( int ( ato ) ) : <NEWLINE> <INDENT> answer = math . sqrt ( pow ( eval ( <STRING> + str ( i ) , 2 ) ) + pow ( eval ( <STRING> + str ( i ) ) ) ) <NEWLINE> if answer <= n [ 1 ] : <NEWLINE> <INDENT> end = end + 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( end ) <NEWLINE>
n , d = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if x * x + y * y <= d * d : ans += 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n , d = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> A = [ ] <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> A_i = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A . append ( A_i ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> <NL> for j in A : <NEWLINE> <INDENT> if A [ 0 ] ** 2 + A [ 1 ] ** 2 <= d ** 2 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> n , d = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> cnt = 0 <NEWLINE> while n > 0 : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> res = math . sqrt ( x ** 2 + y ** 2 ) <NEWLINE> if res <= d : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
20 100000 <NEWLINE> 14309 - 32939 <NEWLINE> - 56855 100340 <NEWLINE> 151364 25430 <NEWLINE> 103789 - 113141 <NEWLINE> 147404 - 136977 <NEWLINE> - 37006 - 30929 <NEWLINE> 188810 - 49557 <NEWLINE> 13419 70401 <NEWLINE> - 88280 165170 <NEWLINE> - 196399 137941 <NEWLINE> - 176527 - 61904 <NEWLINE> 46659 115261 <NEWLINE> - 153551 114185 <NEWLINE> 98784 - 6820 <NEWLINE> 94111 - 86268 <NEWLINE> - 30401 61477 <NEWLINE> - 55056 7872 <NEWLINE> 5901 - 163796 <NEWLINE> 138819 - 185986 <NEWLINE> - 69848 - 96669 <NEWLINE>
feom collections import sqrt <NEWLINE> if __name__ == <STRING> : <NEWLINE> <INDENT> n , d = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> c = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> x , y = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> if sqrt ( x ** 2 + y ** 2 ) <= d : <NEWLINE> <INDENT> c += 1 <NEWLINE> <DEDENT> <DEDENT> print ( c ) <NEWLINE> <DEDENT>
import math <NEWLINE> <NL> def dist ( x , y ) : <NEWLINE> <INDENT> return math . sqrt ( x ^ 2 + y ^ 2 ) <NEWLINE> <NL> <COMMENT> <NL> <NL> <DEDENT> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> n = l [ 0 ] <NEWLINE> d = l [ 1 ] <NEWLINE> <NL> count = 0 <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if dist ( l [ 0 ] , l [ 1 ] ) <= d : <NEWLINE> <INDENT> count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
import math <NEWLINE> count = 0 <NEWLINE> n , d = map ( int , input ( ) . split ( ) ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> if x ** 2 + y ** 2 ** 0.5 <= d : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
N , D = input ( ) . split ( ) <NEWLINE> N = int ( N ) <NEWLINE> D = int ( D ) <NEWLINE> cnt = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <NL> <INDENT> p1 , p2 = map ( int , input ( ) . split ( ) ) <NEWLINE> t = ( ( p1 * p1 ) ( p2 * p2 ) ) ** ( 0.5 ) <NEWLINE> if t <= D : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
import math <NEWLINE> <NL> DISTANCE_NUM = 0 <NEWLINE> <NL> N , D = ( int ( x ) for x in input . split ( ) ) <NEWLINE> <NL> for _ in range ( N ) <NEWLINE> <INDENT> x , y = ( int ( x ) for x in input . split ( ) ) <NEWLINE> distance = math . sqrt ( x ** 2 + y ** 2 ) <NEWLINE> <NL> if distance <= D : <NEWLINE> <INDENT> DISTANCE_NUM += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( DISTANCE_NUM ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> n , d = map ( int , input ( ) . split ( ) ) <NEWLINE> is_shorter = lambda dis , x , y : dis ** 2 <= ( x ** 2 + y ** 2 ) <NEWLINE> ans = sum ( [ is_shorter ( d , map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ] ) <NEWLINE> print ( ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n , d = map ( int , input ( ) . split ( ) ) <NEWLINE> cnt = 0 <NEWLINE> for i in raneg ( n ) : <NEWLINE> <INDENT> p , q = map ( int , input ( ) . split ( ) ) <NEWLINE> cnt += p * p + q * q <= d * d <NEWLINE> <DEDENT> print ( cnt ) <NEWLINE>
N , D = map ( int , input ( ) . split ( ) ) <NEWLINE> i = 0 <NEWLINE> count = 0 <NEWLINE> while ( i < N ) : <NEWLINE> <INDENT> p , q = map ( int , input ( ) . split ( ) ) <NEWLINE> d = math . sqrt ( p * p + q * q ) <NEWLINE> if ( d <= D ) : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> i += 1 <NEWLINE> <DEDENT> print ( i ) <NEWLINE>
z = [ map ( int , t . split ( ) ) for t in open ( 0 ) ] ; print ( sum ( x * x + y * y <= z [ 0 ] [ 1 ] ** 2 for x , y in z ) ) <NEWLINE>
N , D = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> count = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> x , y = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if ( x ** 2 + y ** 2 ) <= d ** 2 : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
import math <NEWLINE> <NL> input_ = input ( ) . split ( ) <NEWLINE> <NL> N = int ( input_ [ 0 ] ) <NEWLINE> D = float ( input_ [ 1 ] ) <NEWLINE> <NL> num = 0 <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> x_i , y_i = map ( float , input ( ) . split ( ) ) <NEWLINE> <NL> if ( math . sqrt ( x_i ** 2 + y_i ** 2 p ) <= D ) : <NEWLINE> <INDENT> num += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( num ) <NEWLINE> <NL>
n , d = map ( int , input ( ) . split ( ) ) <NEWLINE> xy = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> xy += xi ** 2 + yi ** 2 <= d ** 2 for xi , yi in xy <NEWLINE> <NL> <DEDENT> print ( xy ) <NEWLINE>
<INDENT> import numpy as np <NEWLINE> <NL> temp = input ( ) . split ( ) <NEWLINE> <NL> s = [ input ( ) . split ( ) for i in range ( int ( temp [ 0 ] ) ) ] <NEWLINE> <NL> cnt = 0 <NEWLINE> <NL> for i in range ( int ( temp [ 0 ] ) ) : <NEWLINE> <INDENT> if np . sqrt ( int ( s [ i ] [ 0 ] ) * int ( s [ i ] [ 0 ] ) + int ( s [ i ] [ 1 ] ) * int ( s [ i ] [ 1 ] ) ) <= int ( temp [ 1 ] ) : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE> <DEDENT>
n , d = map ( int , input ( ) . split ( ) ) <NEWLINE> cnt = 0 <NEWLINE> for ti in n : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> dist = ( x ** 2 + y ** 2 ) ** 0.5 <NEWLINE> if ( dist >= d ) : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
n , d = map ( int , input ( ) . split ( ) ) <NEWLINE> c = 0 <NEWLINE> p = d * d <NEWLINE> for j in range ( n ) : <NEWLINE> <INDENT> x , y == map ( int , input ( ) . split ( ) ) <NEWLINE> if ( x ** 2 ) + ( y ** 2 ) == p : <NEWLINE> <INDENT> c = c + 1 <NEWLINE> <DEDENT> <DEDENT> print ( c ) <NEWLINE>
import math <NEWLINE> <NL> n , d = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> count = 0 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> if math . sprt ( ( abs ( x ) ** 2 ) + ( abs ( y ) ** 2 ) ) <= d : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT>
N , D = map ( int , input ( ) . split ( ) ) <NEWLINE> XY = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( ) ] <NEWLINE> <NL> print ( sum ( x ** 2 + y ** 2 <= D ** 2 for x , y in XY ) ) <NEWLINE>
n , d = map ( int , input ( ) . split ( ) ) <NEWLINE> from math import sqrt <NEWLINE> count = 0 <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> m = sqrt ( x ** 2 + y ** 2 ) <NEWLINE> if m <= d : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ccount ) <NEWLINE>
import sys <NEWLINE> N , D = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = 0 <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> x , y = map ( int , sys . stdin . readline ( ) . split ( ) ) <NEWLINE> if x ** + y ** <= D ** : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
impourt sys <NEWLINE> <NL> count = 0 <NEWLINE> n , d = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> x , y = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> if x * x + y * y <= d * d : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
import math <NEWLINE> <NL> i = input ( ) . split ( ) <NEWLINE> n = int ( i [ 1 ] ) <NEWLINE> D = int ( i [ 0 ] ) <NEWLINE> num_list = [ ] <NEWLINE> count = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> num_list . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> <DEDENT> for j in num_list : <NEWLINE> <INDENT> x = j [ 0 ] <NEWLINE> y = j [ 1 ] <NEWLINE> dist = math . sqrt ( x ** 2 + y ** 2 ) <NEWLINE> if dist <= D : <NEWLINE> <INDENT> count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
N , D = ( int ( x ) for x in input ( ) . split ( ) ) <NEWLINE> xy = [ map ( int , input ( ) . split ( ) ) for _ int range ( N ) ] <NEWLINE> x , y = [ list ( i ) for i in zip ( * xy ) ] <NEWLINE> n = 0 <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> if ( x [ i ] ** 2 + y [ i ] ** 2 <= D ** 2 ) : <NEWLINE> <INDENT> n += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( n ) <NEWLINE>
n , d = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> xy = [ map ( int , input ( ) . split ( ) ) for _ in range ( 5 ) ] <NEWLINE> x , y = [ list ( i ) for i in zip ( * xy ) ] <NEWLINE> <NL> <NL> count = 0 <NEWLINE> <NL> for i , j in zip ( x , y ) : <NEWLINE> <INDENT> if i * i + j * j <= d * d : <NEWLINE> <INDENT> count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
n , d = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> for _ in range ( n ) : <NEWLINE> <INDENT> x , y = map ( int , readline ( ) . split ( ) ) <NEWLINE> if x ** 2 + y ** 2 <= d ** 2 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> D = int ( input ( ) ) <NEWLINE> an = 0 <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> X , Y = map ( int , input ( ) . split ( ) ) <NEWLINE> if X ** 2 + Y ** 2 <= D ** 2 : <NEWLINE> <INDENT> an += 1 <NEWLINE> <DEDENT> <DEDENT> print ( an ) <NEWLINE> <NL>
nd = input ( ) . split ( ) <NEWLINE> N = int ( nd [ 0 ] ) <NEWLINE> D = int ( nd [ 1 ] ) <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> for i in range ( N - 1 ) : <NEWLINE> <INDENT> xy = input ( ) . split ( ) <NEWLINE> x = int ( xy [ 2 * i ] ) <NEWLINE> y = int ( xy [ 2 * i + 1 ] ) <NEWLINE> d = x ** 2 + y ** 2 <NEWLINE> if d < D : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<NL> <COMMENT> <NL> <NL> N , D = map ( int , input . split ( ) ) <NEWLINE> X = [ ] <NEWLINE> Y = [ ] <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> X . append ( x ) <NEWLINE> Y . append ( y ) <NEWLINE> <NL> <DEDENT> count = 0 <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> if D ** 2 >= X [ i ] ** 2 + Y [ i ] ** 2 : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
n , d = map ( int , input ( ) , split ( <STRING> ) ) <NEWLINE> d *= d <NEWLINE> c = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> if ( a ** 2 + b ** 2 == d ) : <NEWLINE> <INDENT> c += 1 <NEWLINE> <DEDENT> <DEDENT> print ( c ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> D = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> i = 1 <NEWLINE> while i <= N : <NEWLINE> <INDENT> i += 1 <NEWLINE> X = int ( input ( ) ) <NEWLINE> Y = int ( input ( ) ) <NEWLINE> if X * X + Y * Y <= D * D : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n , d = map ( int , input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) ) <NEWLINE> if x ** 2 + y ** 2 <= d ** 2 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> <NL> N , D = int ( input ( ) . split ( ) ) <NEWLINE> P = [ ] <NEWLINE> for n in N : <NEWLINE> <INDENT> X_n , Y_n = int ( input ( ) . split ( ) ) <NEWLINE> P . append ( ( X_n , Y_n ) ) <NEWLINE> <NL> <DEDENT> def distance ( p : tuple ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <INDENT> return math . sqrt ( p [ 0 ] ** 2 + p [ 1 ] ** 2 ) <NEWLINE> <NL> <DEDENT> count = [ p for p in P if distance ( p ) <= D ] <NEWLINE> print ( len ( count ) ) <NEWLINE>
N , D = map ( int , input ( ) . split ( ) ) <NEWLINE> cnt = 0 <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if np . sqrt ( a ** 2 + b ** 2 ) <= D : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
n , d = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> points = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> points . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> <DEDENT> cnt = 0 <NEWLINE> for p in points : <NEWLINE> <INDENT> distance = sqrt ( p [ 0 ] ** 2 + p [ 1 ] ** 2 ) <NEWLINE> if distance <= d : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
import numpy as np <NEWLINE> <NL> N , D = int ( input ( ) . split ( ) ) <COMMENT> <NEWLINE> grid = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> array = list ( map ( int , input ( ) . strip ( ) . split ( ) ) ) <NEWLINE> grid . append ( array ) <NEWLINE> <DEDENT> p = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if np . sqrt ( grid [ i , 0 ] * grid [ i , 0 ] + grid [ i , 1 ] , grid [ i , 1 ] ) <= D : <NEWLINE> <INDENT> p += 1 <NEWLINE> <DEDENT> <DEDENT> print ( p ) <NEWLINE>
import math <NEWLINE> <NL> n , d = map ( str , input ( ) . split ( ) ) <NEWLINE> answer = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> x , y = map ( str , input ( ) . split ( ) ) <NEWLINE> if math . sqrt ( x ** 2 + y ** 2 ) <= d : <NEWLINE> <INDENT> answer += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( answer ) <NEWLINE>
n , d = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> if ( d >= ( x ** 2 + y ** 2 ) ** ( 1 / 2 ) ) : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
K = int ( input ( ) ) <NEWLINE> if K % 2 == 0 or K % 5 == 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> n = 1 <NEWLINE> while True : <NEWLINE> <INDENT> if 7 * ( 10 ** n - 1 ) / 9 % K == 0 : <NEWLINE> <INDENT> print ( n ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
K = int ( input ( ) ) <NEWLINE> amari_list = [ ] <NEWLINE> amari = 7 % K <NEWLINE> amari_list . append ( amari ) <NEWLINE> for i in range ( 1 , K ) : <NEWLINE> <INDENT> amari = ( amari * 10 + 7 ) % K <NEWLINE> if amari == 0 : <NEWLINE> <INDENT> print ( i + 1 ) <NEWLINE> break <NEWLINE> <DEDENT> if amari in amari_list : a <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> break <NEWLINE> <DEDENT> if i == ( K - 1 ) : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> amari_list . append ( amari ) <NEWLINE> <DEDENT> <DEDENT>
K = int ( input ( ) ) <NEWLINE> x = 0 <NEWLINE> if k % 2 == 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit <NEWLINE> <DEDENT> for i in range ( 1000000 ) : <NEWLINE> <INDENT> x = ( 10 * x + 7 ) % K <NEWLINE> if x == 0 : <NEWLINE> <INDENT> print ( i + 1 ) <NEWLINE> exit <NEWLINE> <DEDENT> <DEDENT> if x != 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT>
K = int ( input ( ) ) <NEWLINE> if K == 7 or K == 1 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> count = 1 <NEWLINE> for i in range ( K ) : <NEWLINE> <INDENT> x = ( x % K ) * 10 + 7 <NEWLINE> count += 1 <NEWLINE> if x == 0 : <NEWLINE> <INDENT> print ( count ) <NEWLINE> <DEDENT> <DEDENT> if x != 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> <NL> <COMMENT> <NL> k = 999983 <NEWLINE> befo = 0 <NEWLINE> <NL> for i in range ( k ) : <NEWLINE> <INDENT> n = befo * 10 + 1 <NEWLINE> befo = n <NEWLINE> if ( 7 * n ) % k == 0 : <NEWLINE> <INDENT> print ( i + 1 ) <NEWLINE> exit ( 0 ) <NEWLINE> <DEDENT> <DEDENT> print ( - 1 ) <NEWLINE>
k = int ( input ( ) ) <NEWLINE> a = 0 <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> a = ( a * 10 + 7 ) % k <NEWLINE> if a == 0 : <NEWLINE> <INDENT> print ( i + 1 ) <NEWLINE> brake <NEWLINE> <DEDENT> <DEDENT> print ( - 1 ) <NEWLINE>
i = 0 ; <NEWLINE> mod = 0 ; <NEWLINE> while True : <NEWLINE> <INDENT> mod = ( mod * 10 + 7 ) % k ; <NEWLINE> if mod == 0 : <NEWLINE> <INDENT> break ; <NEWLINE> <DEDENT> i += 1 ; <NEWLINE> if i == k : <NEWLINE> <INDENT> j = - 2 <NEWLINE> break ; <NEWLINE> <NL> <DEDENT> <DEDENT> print ( i + 1 ) <NEWLINE>
k = int ( input ( ) ) <NEWLINE> x = 7 % k <NEWLINE> s = [ ] <NEWLINE> <NL> for i in range ( k ) : <NEWLINE> <INDENT> if x == 0 : <NEWLINE> <INDENT> print ( len ( i + 1 ) ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> s . append ( x ) <NEWLINE> x = ( 10 * x + 7 ) % k <NEWLINE> <NL> <NL> <NL> <DEDENT> print ( - 1 ) <NEWLINE>
k = int ( input ( ) ) <NEWLINE> <NL> if k % 2 == 0 or k % 5 == 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> num = 7 <NEWLINE> num %= k <NEWLINE> ans = 1 <NEWLINE> <NL> while k != 0 : <NEWLINE> <INDENT> num = ( 10 * num + 7 ) % k + 7 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
def main ( h ) : <NEWLINE> <INDENT> count = 1 <NEWLINE> n = 0 <NEWLINE> if i in range ( k ) : <NEWLINE> <INDENT> n = ( n * 10 + 7 ) % k <NEWLINE> if n == 0 : <NEWLINE> <INDENT> break <NEWLINE> print ( count ) <NEWLINE> return 0 <NEWLINE> <DEDENT> count += 1 <NEWLINE> <DEDENT> print ( - 1 ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> k = int ( input ( ) ) <NEWLINE> <INDENT> main ( k ) <NEWLINE> <DEDENT> <DEDENT>
k = int ( input ( ) ) <NEWLINE> if k % 2 == 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> nana = 0 <NEWLINE> ans = 0 <NEWLINE> print ( len ( k ) ) <NEWLINE> while True : <NEWLINE> <INDENT> nana += ( 10 ** ans ) * 7 <NEWLINE> <COMMENT> <NL> if nana % k == 0 : <NEWLINE> <INDENT> print ( ans + 1 ) <NEWLINE> break <NEWLINE> <DEDENT> ans += 1 <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> if n % 2 == 0 or n % 5 == 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a = 7 <NEWLINE> flag = 0 <NEWLINE> while flag == 0 : <NEWLINE> <INDENT> if a % n == 0 : <NEWLINE> <INDENT> print ( count + 1 ) <NEWLINE> flag = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> count += 1 <NEWLINE> a = a * 10 <NEWLINE> a = a + 7 <NEWLINE> a = a % n <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def solve ( k ) : <NEWLINE> <INDENT> a_mod = 0 <NEWLINE> for i in range ( 1000000 ) : <NEWLINE> <INDENT> a_mod += 7 * pow ( 10 , i , k ) <NEWLINE> a_mod %= k <NEWLINE> if a_mod == 0 : <NEWLINE> <INDENT> return i + 1 <NEWLINE> <DEDENT> <DEDENT> return - 1 <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> k = int ( input ( ) ) <NEWLINE> res = solve ( k ) <NEWLINE> print ( res ) <NEWLINE> <NL> <NL> <DEDENT> def test ( ) : <NEWLINE> <INDENT> assert solve ( 101 ) == 4 <NEWLINE> assert solve ( 2 ) == - 1 <NEWLINE> assert solve ( 999983 ) == 999982 <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> test ( ) <NEWLINE> main ( ) <NEWLINE> <DEDENT>
K = int ( input ( ) ) <NEWLINE> <NL> def calculate ( k ) : <NEWLINE> <NL> <INDENT> res = 1 <NEWLINE> <NL> n = 7 <NEWLINE> <NL> if k % 2 == 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> if k % 5 == 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> while n % k > 0 : <NEWLINE> <INDENT> n = n % k <NEWLINE> n = n * 10 + 7 <NEWLINE> res += 1 <NEWLINE> <NL> <DEDENT> print ( res ) <NEWLINE> <NL> <DEDENT> calculate ( K ) <NEWLINE> <NL> <NL> K = int ( input ( ) ) <NEWLINE>
param_k = int ( input ( ) ) <NEWLINE> <NL> if param_k % 2 == 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <NL> <DEDENT> elif param_k % == 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> n = 0 <NEWLINE> for i in range ( param_k + 10 ) : <NEWLINE> <INDENT> n = 10 n + 7 <NEWLINE> if n % 7 == 0 : <NEWLINE> <INDENT> print ( i + 1 ) <NEWLINE> break <NEWLINE> <DEDENT> if i == param_k + 10 - 1 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
k = int ( input ( ) ) <NEWLINE> if k % 2 == 0 or k % 5 == 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> myconst = 7 % k <NEWLINE> cnt = 1 <NEWLINE> while True : <NEWLINE> <INDENT> if not myconst : <NEWLINE> <INDENT> print ( cnt ) <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> myconst = ( ( 10 * myconst ) + 7 ) % k <NEWLINE> <DEDENT> cnt += 1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT>
k = int ( input ( ) ) <NEWLINE> <NL> if k % 2 == 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> elif k % 5 == 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if k % 7 == 0 : <NEWLINE> <INDENT> l = k * 9 / 7 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> l = k * 9 <NEWLINE> <NL> <DEDENT> tmp = 1 <NEWLINE> for i in range ( l ) : <NEWLINE> <INDENT> tmp = tmp * 10 % l <NEWLINE> if tmp == 1 : <NEWLINE> <INDENT> flg == 1 <NEWLINE> print ( i + 1 ) <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if flg != 1 <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> read = sys . stdin . read <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> from numba import njit <NEWLINE> import numpy as np <NEWLINE> def main ( ) : <NEWLINE> <INDENT> @ njit ( ) <NEWLINE> def s ( k ) : <NEWLINE> <INDENT> rems = np . zeros ( k ) <NEWLINE> n = 7 <NEWLINE> next_digit = 70 <NEWLINE> r = 1 <NEWLINE> while True : <NEWLINE> <INDENT> rem = n % k <NEWLINE> if rem == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> elif rems [ rem ] : <NEWLINE> <INDENT> r = - 1 <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> rems [ rem ] = 1 <NEWLINE> n += next_digit <NEWLINE> next_digit *= 10 <NEWLINE> r += 1 <NEWLINE> <DEDENT> <DEDENT> return r <NEWLINE> <DEDENT> k = int ( input ( ) ) <NEWLINE> if k % 2 == 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( s ( k ) ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
K = int ( input ( ) ) <NEWLINE> a = [ 0 ] * 1000000000 <NEWLINE> a [ 1 ] = 7 % K <NEWLINE> for i in range ( 2 , K ) : <NEWLINE> <INDENT> a [ i ] = ( a [ i - 1 ] * 10 + 7 ) % K <NEWLINE> <DEDENT> for i in range ( 1 , K ) : <NEWLINE> <INDENT> if a [ i ] == 0 : <NEWLINE> <INDENT> print ( i ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> if N % 2 == 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> num = 7 <NEWLINE> ans = - 1 <NEWLINE> for i in range ( 1 , 10 * 8 ) : <NEWLINE> <INDENT> if num % N == 0 : <NEWLINE> <INDENT> ans = i <NEWLINE> break <NEWLINE> <DEDENT> num = str ( num ) <NEWLINE> num += <STRING> <NEWLINE> num = int ( num ) <NEWLINE> <DEDENT> if i == 79 : <NEWLINE> <INDENT> print ( N - 1 ) <NEWLINE> <DEDENT> else <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
a = 7 <NEWLINE> b = int ( inout ( ) ) <NEWLINE> <NL> list = [ 7 ] <NEWLINE> for i in range ( b ) : <NEWLINE> <INDENT> list . append ( list [ - 1 ] * 10 + 7 ) <NEWLINE> <NL> <DEDENT> for l in range ( len ( list ) ) : <NEWLINE> <INDENT> if list [ l ] % b == 0 : <NEWLINE> <INDENT> print ( l + 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT>
k = int ( input ( ) ) <NEWLINE> m = 7 <NEWLINE> if ( k % 2 == 0 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> i = 1 <NEWLINE> while True : <NEWLINE> <INDENT> m = m % k <NEWLINE> if ( j == 0 ) : <NEWLINE> <INDENT> print ( i ) <NEWLINE> break <NEWLINE> <DEDENT> if ( i > k ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> m *= 10 <NEWLINE> m += 7 <NEWLINE> i += 1 <NEWLINE> <NL> <DEDENT> <DEDENT>
k = int ( input ( ) ) <NEWLINE> <NL> if k % 2 == 0 or k % 5 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> ans = 1 <NEWLINE> s =  <NEWLINE> while True : <NEWLINE> <INDENT> if s % k == 0 : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s = ( s % k ) * 10 + 7 <NEWLINE> ans += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> rw = list ( input ( ) ) <NEWLINE> <NL> rw_after = sorted ( rw ) <NEWLINE> <NL> count = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if rw [ i ] != rw_after [ i ] : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> print ( int ( count / 2 ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> x = 0 <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> x = ( ( 10 * x ) + 7 ) % n <NEWLINE> if x == 0 : <NEWLINE> <INDENT> print ( i ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> <DEDENT> print ( - 1 ) <NEWLINE>
k = int ( input ( ) ) <NEWLINE> seven =  <NEWLINE> count = 0 <NEWLINE> <NL> while True : <NEWLINE> <INDENT> if k % 2 == 0 : <NEWLINE> <INDENT> count = - 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> elif seven % k == 0 : <NEWLINE> <INDENT> count += 1 <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> count += 1 <NEWLINE> seven = seven * 10 + 7 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
K = int ( input ( ) ) <NEWLINE> <NL> for i in range ( K ) : <NEWLINE> <INDENT> if i = 0 : <NEWLINE> <INDENT> N = 7 % K <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> N = ( 10 * N + 7 ) % K <NEWLINE> <DEDENT> if N == 0 : <NEWLINE> <INDENT> print ( i + 1 ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT>
k = int ( input ( ) ) <NEWLINE> seven = 7 <NEWLINE> count = 0 <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> for i in range ( 1000000 ) : <NEWLINE> <INDENT> if k % 2 == 0 : <NEWLINE> <INDENT> count = - 1 <NEWLINE> return <NEWLINE> <NL> <DEDENT> elif seven % k == 0 : <NEWLINE> <INDENT> count += 1 <NEWLINE> print ( count ) <NEWLINE> return <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> count += 1 <NEWLINE> seven = seven * 10 + 7 <NEWLINE> <DEDENT> <DEDENT> print ( - 1 ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
x = int ( input ( ) ) <NEWLINE> <NL> ng = np . array ( [ 2 , 4 , 5 , 6 , 8 ] ) <NEWLINE> <NL> import numpy as np <NEWLINE> <NL> def prime_factorize ( n ) : <NEWLINE> <INDENT> a = [ ] <NEWLINE> while n % 2 == 0 : <NEWLINE> <INDENT> a . append ( 2 ) <NEWLINE> n //= 2 <NEWLINE> <DEDENT> f = 3 <NEWLINE> while f * f <= n : <NEWLINE> <INDENT> if n % f == 0 : <NEWLINE> <INDENT> a . append ( f ) <NEWLINE> n //= f <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> f += 2 <NEWLINE> <DEDENT> <DEDENT> if n != 1 : <NEWLINE> <INDENT> a . append ( n ) <NEWLINE> <DEDENT> return a <NEWLINE> <NL> <DEDENT> a = prime_factorize ( x ) <NEWLINE> <NL> if len ( set ( a ) & set ( ng ) ) > 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> elif len ( set ( a ) ) == 1 and len ( str ( x ) ) > 3 : <NEWLINE> <INDENT> nana = <STRING> * ( x ) <NEWLINE> while True : <NEWLINE> <INDENT> nana = nana [ : len ( nana ) - 1 ] <NEWLINE> if int ( nana ) % x == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> print ( len ( nana ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> nana = <STRING> * ( len ( str ( x ) ) ) <NEWLINE> while True : <NEWLINE> <INDENT> nana += <STRING> <NEWLINE> if int ( nana ) % x == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> print ( len ( nana ) ) <NEWLINE> <DEDENT>
K = int ( input ( ) ) <NEWLINE> <NL> ans = 1 <NEWLINE> X = 7 <NEWLINE> cnt = K <NEWLINE> while ans <= K : <NEWLINE> <INDENT> x = X % K <NEWLINE> if rem == 0 : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += 1 <NEWLINE> X = x * 10 + 7 <NEWLINE> <NL> <DEDENT> <DEDENT> if rem != 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT>
k = int ( input ( ) ) <NEWLINE> l = [ ] <NEWLINE> x = 7 % k <NEWLINE> if x == 0 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> break <NEWLINE> <DEDENT> for i in range ( 2 , k + 1 ) : <NEWLINE> <INDENT> x = 7 % k <NEWLINE> num = ( x * 10 + 7 ) % k <NEWLINE> x = num <NEWLINE> l . append ( num ) <NEWLINE> if num == 0 : <NEWLINE> <INDENT> print ( i ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if 0 not in l : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT>
k = int ( input ( ) ) <NEWLINE> if k % 2 == 0 k % 5 == 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> a = 0 <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> a = ( a * 10 + 7 ) % k <NEWLINE> if a == 0 : <NEWLINE> <INDENT> print ( i + 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT>
N , D = ( int ( a ) for a in input ( ) . split ( ) ) <NEWLINE> X2Y2 = [ [ int ( a ) ** 2 for a in input ( ) . split ( ) ] for b in range ( N ) ] <NEWLINE> X2 , Y2 = [ list ( i ) for i in zip ( * X2Y2 ) ] <NEWLINE> <NL> c = 0 <NEWLINE> DD = D ** 2 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if X2 [ i ] + Y2 [ i ] <= DD : <NEWLINE> <INDENT> c += 1 <NEWLINE> <DEDENT> <DEDENT> print ( c ) <NEWLINE>
k = int ( input ( ) ) <NEWLINE> c = 0 <NEWLINE> if k % 2 == 0 or k % 5 == 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> c = 1 <NEWLINE> <DEDENT> if c == 0 : <NEWLINE> <NL> <INDENT> for i in range ( 1 , k ) : <NEWLINE> <INDENT> t = <STRING> * i <NEWLINE> if str ( t ) % k == 0 : <NEWLINE> <INDENT> print ( i ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
k = int ( input ( ) ) <NEWLINE> <NL> ans = - 1 <NEWLINE> memo = 7 % k <NEWLINE> <NL> for i in range ( k ) : <NEWLINE> <INDENT> if a == 0 : <NEWLINE> <INDENT> ans = i + 1 <NEWLINE> break <NEWLINE> <DEDENT> a = ( 10 * k + 7 ) % k <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> input - sys . stdin . readline <NEWLINE> def main ( ) : <NEWLINE> <INDENT> K = int ( input ( ) ) <NEWLINE> <NL> if K % 2 == 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> if K % 7 : <NEWLINE> <INDENT> L = 9 * K <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> L = 9 * K // 7 <NEWLINE> <DEDENT> a = 1 <NEWLINE> for i in range ( 1 , K + 10 ) : <NEWLINE> <INDENT> a = ( a * 10 ) % L <NEWLINE> if a == 1 : <NEWLINE> <INDENT> print ( i ) <NEWLINE> return <NEWLINE> <DEDENT> <DEDENT> print ( - 1 ) <NEWLINE> <DEDENT> main ( ) <NEWLINE>
k = int ( input ( ) ) <NEWLINE> a = [ None ] * 1000001 <NEWLINE> a [ 1 ] = 7 % k <NEWLINE> n = 0 <NEWLINE> <NL> for i in range ( 2 : k + 1 ) : <NEWLINE> <INDENT> a [ i ] = ( a [ i - 1 ] * 10 + 7 ) % k <NEWLINE> if a [ i ] == 0 and n == 0 : <NEWLINE> <INDENT> print ( <STRING> . format ( i ) ) <NEWLINE> n = 1 <NEWLINE> <DEDENT> <DEDENT> if n == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
K = int ( input ( ) ) <NEWLINE> <NL> i = 7 % K <NEWLINE> se = set ( i ) <NEWLINE> cnt = 1 <NEWLINE> while True : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> print ( cnt ) <NEWLINE> break <NEWLINE> <DEDENT> cnt += 1 <NEWLINE> i = ( i * 10 + 7 ) % K <NEWLINE> if i in se : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> se . add ( i ) <NEWLINE> <DEDENT> <DEDENT>
k = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> now = 7 <NEWLINE> while True : <NEWLINE> <INDENT> ans += 1 <NEWLINE> now %= k <NEWLINE> if now == 0 : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> exit ( - 1 ) <NEWLINE> <DEDENT> now = now * 10 + 7 <NEWLINE> if ans == 1000000 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( - 1 ) <NEWLINE> <DEDENT> <DEDENT>
k = int ( input ( ) ) <NEWLINE> ans = 1 <NEWLINE> s_1 = 7 % k <NEWLINE> s_2 = 10 % k <NEWLINE> m = 0 <NEWLINE> j = 0 <NEWLINE> if k % 2 == 0 or k % 5 == 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> elif k == 1 or k == 7 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> elif k % 7 == 0 : <NEWLINE> <INDENT> l = 9 * k / 7 <NEWLINE> i = 0 <NEWLINE> while j == 0 : <NEWLINE> <INDENT> m = ( m + s_1 * ( ( ( s_2 ** i ) % l - 1 ) % l ) ) % l <NEWLINE> if m == 0 : <NEWLINE> <INDENT> j == 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> i += 1 <NEWLINE> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> l = 9 * k <NEWLINE> i = 0 <NEWLINE> while j == 0 : <NEWLINE> <INDENT> m = ( m + s_1 * ( ( ( s_2 ** i ) % l - 1 ) % l ) ) % l <NEWLINE> if m == 0 : <NEWLINE> <INDENT> j == 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> i += 1 <NEWLINE> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
K = int ( input ( ) ) <NEWLINE> ans = 1 <NEWLINE> X = 7 <NEWLINE> cnt = K <NEWLINE> while ( cnt > 0 ) : <NEWLINE> <COMMENT> <NL> <INDENT> rem = X % K <NEWLINE> if rem == 0 : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> remlst . append ( rem ) <NEWLINE> ans += 1 <NEWLINE> X = rem * 10 + 7 <NEWLINE> cnt -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if rem != 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT>
k = int ( input ( ) ) <NEWLINE> x = 7 % k <NEWLINE> i = 1 <NEWLINE> for i in range ( 0 , k + 1 ) : <NEWLINE> <INDENT> if x == 0 : <NEWLINE> <INDENT> print ( i ) <NEWLINE> break <NEWLINE> <NL> <DEDENT> l . append ( x ) <NEWLINE> x = ( x * 10 + 7 ) % k <NEWLINE> i += 1 <NEWLINE> <DEDENT>
pos = 1 <NEWLINE> curr = 7 <NEWLINE> k = int ( input ( ) ) <NEWLINE> while curr % k != 0 : <NEWLINE> <INDENT> pos += 1 <NEWLINE> k *= 10 <NEWLINE> k += 7 <NEWLINE> <DEDENT> print ( pos ) <NEWLINE>
K = int ( input ( ) ) <NEWLINE> mod = [ ] <NEWLINE> a [ 0 ] = 7 % K <NEWLINE> if a [ 0 ] == 0 : <NEWLINE> <INDENT> print ( a [ 0 ] ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> for i in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> a [ i ] = ( a [ i - 1 ] * 10 + 7 ) % K <NEWLINE> if a [ i ] == 0 : <NEWLINE> <INDENT> print ( <STRING> , a [ i ] ) <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> seen = set ( ) <NEWLINE> ans = 0 <NEWLINE> res = 7 % n <NEWLINE> seen . add ( res ) <NEWLINE> ans += 1 <NEWLINE> while res != 0 : <NEWLINE> <INDENT> new = ( res * 10 + 7 ) % n <NEWLINE> <INDENT> if new not in seen : <NEWLINE> seen . add ( new ) <NEWLINE> <INDENT> res = new <NEWLINE> ans += 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) : <NEWLINE> <INDENT> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
k = int ( input ( ) ) <NEWLINE> t = 7 <NEWLINE> ans = 0 <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> if t % k == 0 : <NEWLINE> <INDENT> ans = i + 1 <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> t = ( t * 10 + 7 ) % k <NEWLINE> <NL> <DEDENT> <DEDENT> if ans > 0 : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT>
k = input ( ) <NEWLINE> ans = 7 <NEWLINE> ans2 = 10 <NEWLINE> prev = 7 <NEWLINE> if ans % k == 0 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( 0 , k + 1 , 1 ) : <NEWLINE> <INDENT> ans = 7 * ans2 + prev <NEWLINE> if ans % k == 0 : <NEWLINE> <INDENT> print ( i + 2 ) <NEWLINE> break <NEWLINE> <DEDENT> prev = ans <NEWLINE> ans2 = ans2 * 10 <NEWLINE> <NL> <DEDENT> <DEDENT>
k = int ( input ( ) ) <NEWLINE> b = 7 <NEWLINE> c = 1 <NEWLINE> a = [ ] <NEWLINE> e = 0 <NEWLINE> a . append ( 7 ) <NEWLINE> if ( k % 2 == 0 ) : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> while ( b % k != 0 ) : <NEWLINE> <INDENT> r = b % k <NEWLINE> b = 10 * r + 7 <NEWLINE> c += 1 <NEWLINE> if b in a : <NEWLINE> <INDENT> e = 1 <NEWLINE> <DEDENT> a . append ( b ) <NEWLINE> <DEDENT> if ( e == 1 ) : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( c ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT>
k = int ( input ( ) ) <NEWLINE> <NL> import fractions <NEWLINE> <NL> flag = False <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> f = fractions . gcd ( k , ( 10 ** n - 1 ) / 9 * 7 ) <NEWLINE> if f == k : <NEWLINE> <INDENT> flag = True <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if flag : <NEWLINE> <INDENT> print ( i + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT>
def make_divisors ( n ) : <NEWLINE> <INDENT> lower_divisors , upper_divisors = [ ] , [ ] <NEWLINE> i = 1 <NEWLINE> while i * i <= n : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> lower_divisors . append ( i ) <NEWLINE> if i != n // i : <NEWLINE> <INDENT> upper_divisors . append ( n // i ) <NEWLINE> <DEDENT> <DEDENT> i += 1 <NEWLINE> <DEDENT> return lower_divisors + upper_divisors [ : : - 1 ] <NEWLINE> <NL> <DEDENT> K = int ( input ( ) ) <NEWLINE> for i in range ( 1 , 20 ) : <NEWLINE> <INDENT> if K % 2 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> lis = [ ] <NEWLINE> lis . append ( make_divisors ( int ( <STRING> * i ) ) ) <NEWLINE> if K in lis : <NEWLINE> <INDENT> print ( i ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( K - 1 ) <NEWLINE> <DEDENT>
count = 0 <NEWLINE> before = 0 <NEWLINE> if k % 2 == 0 or k % 5 == 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> ai = 0 <NEWLINE> i = 0 <NEWLINE> while True : <NEWLINE> <INDENT> ai = ( ai * 10 + 7 ) % k <NEWLINE> i += 1 <NEWLINE> if ai == 0 : <NEWLINE> <INDENT> print ( i ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT>
import math <NEWLINE> K = input ( ) <NEWLINE> <NL> if K % 7 == 0 : <NEWLINE> <INDENT> L = 9 * K / 7 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> L = 9 * K <NEWLINE> <NL> <DEDENT> if L % 2 == 0 or L % 5 == 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> r = 10 % L <NEWLINE> for i in range ( 1 , 10 ** 6 + 1 ) : <NEWLINE> <INDENT> if r == 1 : <NEWLINE> <INDENT> ans = i <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> r = 10 * r % L <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n , d = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c = 0 <NEWLINE> d *= d <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> x , y = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> x *= x <NEWLINE> y *= y <NEWLINE> y += x <NEWLINE> if y <= d : <NEWLINE> <INDENT> c += 1 <NEWLINE> <DEDENT> <DEDENT> print ( c ) <NEWLINE>
k = int ( input ( ) ) <NEWLINE> if k % 2 == 0 or k % 5 == 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if k % 7 == 0 : <NEWLINE> <INDENT> k = k // 7 <NEWLINE> <DEDENT> t = 1 <NEWLINE> tm = 0 <NEWLINE> for i in range ( 1 , 100000 ) : <NEWLINE> <INDENT> tm = tm + t % k <NEWLINE> if tm == 0 : <NEWLINE> <INDENT> print ( i ) <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> t = t * 10 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( k - 1 ) <NEWLINE> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> <NL> def waru ( N ) : <NEWLINE> <INDENT> if N % 2 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> return <NEWLINE> <DEDENT> a = <STRING> <NEWLINE> for i in range ( 1 , 100000000 ) : <NEWLINE> <INDENT> ia = int ( a ) <NEWLINE> if N > ia : <NEWLINE> <INDENT> a += <STRING> <NEWLINE> continue <NEWLINE> <DEDENT> if N % ia == 0 : <NEWLINE> <INDENT> print ( i ) <NEWLINE> return <NEWLINE> <DEDENT> a += <STRING> <NEWLINE> <NL> <DEDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> waru ( N ) <NEWLINE>
k = int ( input ( ) ) <NEWLINE> i = 1 <NEWLINE> while ( 1 ) : <NEWLINE> <INDENT> if ( 7 * ( 10 ** i - 1 ) % 9 k == 0 ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> i + + <NEWLINE> <DEDENT> print ( i ) <NEWLINE>
K = int ( input ( ) ) <NEWLINE> ans = 1 <NEWLINE> tmp = 7 <NEWLINE> if K % 2 == 0 or K % 5 == 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = ( 9 / 7 ) * K + 1 <NEWLINE> ans = 0 <NEWLINE> while x != 1 : <NEWLINE> <INDENT> x /= 10 <NEWLINE> ans += 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
K = int ( input ( ) ) <NEWLINE> remainder_set = set ( ) <NEWLINE> sequence = 7 <NEWLINE> i = 1 <NEWLINE> for i in range ( 10 ** 7 + 9 ) : <NEWLINE> <INDENT> if sequence % K == 0 : <NEWLINE> <INDENT> print ( i + 1 ) <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if sequence % K in emainder_set : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> i += 1 <NEWLINE> sequence *= 10 <NEWLINE> sequence += 7 <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
k = int ( input ( ) ) <NEWLINE> <NL> def factorization ( n ) : <NEWLINE> <INDENT> arr = [ ] <NEWLINE> temp = n <NEWLINE> for i in range ( 2 , int ( - ( - n ** 0.5 // 1 ) ) + 1 ) : <NEWLINE> <INDENT> if temp % i == 0 : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> while temp % i == 0 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> temp //= i <NEWLINE> <DEDENT> arr . append ( [ i , cnt ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> if temp != 1 : <NEWLINE> <INDENT> arr . append ( [ temp , 1 ] ) <NEWLINE> <NL> <DEDENT> if arr == [ ] : <NEWLINE> <INDENT> arr . append ( [ n , 1 ] ) <NEWLINE> <NL> <DEDENT> return arr <NEWLINE> <NL> <DEDENT> pn = factorization ( k ) <NEWLINE> <NL> go = 0 <NEWLINE> keta = len ( str ( k ) ) <NEWLINE> sevens = [ ] <NEWLINE> <NL> if k % 2 == 0 or k % 5 == 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> elif str ( k ) [ - 1 ] == <STRING> : <NEWLINE> <INDENT> for i in range ( 9 , 10 ** 100000 , 10 ) : <NEWLINE> <INDENT> if not str ( k * i ) . count ( <STRING> ) == len ( str ( k * i ) ) : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( str ( k * i ) . count ( <STRING> ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> elif str ( k ) [ - 1 ] == <STRING> : <NEWLINE> <INDENT> for i in range ( 1 , 10 ** 100000 , 10 ) : <NEWLINE> <INDENT> if not str ( k * i ) . count ( <STRING> ) == len ( str ( k * i ) ) : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( str ( k * i ) . count ( <STRING> ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> elif str ( k ) [ - 1 ] == <STRING> : <NEWLINE> <INDENT> for i in range ( 3 , 10 ** 100000 , 10 ) : <NEWLINE> <INDENT> if not str ( k * i ) . count ( <STRING> ) == len ( str ( k * i ) ) : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( str ( k * i ) . count ( <STRING> ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> elif str ( k ) [ - 1 ] == <STRING> : <NEWLINE> <INDENT> for i in range ( 7 , 10 ** 100000 , 10 ) : <NEWLINE> <INDENT> if not str ( k * i ) . count ( <STRING> ) == len ( str ( k * i ) ) : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( str ( k * i ) . count ( <STRING> ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT>
n = input ( ) <NEWLINE> m = 0 <NEWLINE> <NL> if n [ - 1 ] == <STRING> : <NEWLINE> <INDENT> m = 7 <NEWLINE> <DEDENT> elif n [ - 1 ] == <STRING> : <NEWLINE> <INDENT> m = 9 <NEWLINE> <DEDENT> elif n [ - 1 ] == <STRING> : <NEWLINE> <INDENT> m = 1 <NEWLINE> <DEDENT> elif n [ - 1 ] == <STRING> : <NEWLINE> <INDENT> m = 3 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> n = int ( n ) <NEWLINE> <NL> for i in range ( 1 , k ) : <NEWLINE> <INDENT> if len ( set ( list ( str ( n * m ) ) ) ) == 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> m = int ( str ( i ) + str ( m ) [ - 1 ] ) <NEWLINE> if len ( str ( n * m ) ) >= k : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( len ( str ( n * m ) ) ) <NEWLINE>
read = sys . stdin . read <NEWLINE> from collections import deque <NEWLINE> def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> a = input ( ) <NEWLINE> if not <STRING> in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> a = list ( a ) <NEWLINE> rnum = a . count ( <STRING> ) <NEWLINE> r = 0 <NEWLINE> for i1 in range ( rnum ) : <NEWLINE> <INDENT> r += a [ i1 ] == <STRING> <NEWLINE> <DEDENT> for j1 in range ( n - rnum ) : <NEWLINE> <INDENT> r += a [ rnum + j1 ] == <STRING> <NEWLINE> <NL> <DEDENT> r = r // 2 <NEWLINE> print ( r ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> c = list ( map ( str , input ( ) . split ( ) ) ) <NEWLINE> <NL> a = 0 <NEWLINE> b = 0 <NEWLINE> <NL> a = c . count ( <STRING> ) <NEWLINE> ans = c . count ( <STRING> ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if c [ i ] == <STRING> : <NEWLINE> <INDENT> a -= 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> b += 1 <NEWLINE> <NL> <DEDENT> now = max ( a , b ) <NEWLINE> ans = min ( ans , now ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> <INDENT> import sys <NEWLINE> import math <NEWLINE> <NL> sys . setrecursionlimit ( 10 ** 8 ) <NEWLINE> ini = lambda : int ( sys . stdin . readline ( ) ) <NEWLINE> inm = lambda : map ( int , sys . stdin . readline ( ) . split ( ) ) <NEWLINE> inl = lambda : list ( inm ( ) ) <NEWLINE> ins = lambda : sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> debug = lambda * a , ** kw : print ( <STRING> , * a , <STRING> , ** dict ( file = sys . stderr , ** kw ) ) <NEWLINE> <NL> N = ini ( ) <NEWLINE> c = input ( ) <NEWLINE> <NL> R = c . count ( <STRING> ) <NEWLINE> left = c [ : R ] <NEWLINE> ans = left . count ( <STRING> ) <NEWLINE> <NL> print ( ans ) <NEWLINE> <DEDENT>
from collections import deque <NEWLINE> <NL> N = int , input ( ) <NEWLINE> c = input ( ) <NEWLINE> <NL> rd = deque ( [ i for i , x in enumerate ( c ) if x == <STRING> ] ) <NEWLINE> wd = deque ( [ i for i , x in enumerate ( c ) if x == <STRING> ] ) <NEWLINE> if ( len ( rd ) == 0 or len ( wd ) == 0 ) : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> count = 0 <NEWLINE> for i in range ( len ( c ) ) : <NEWLINE> <INDENT> if ( not ( wd [ 0 ] < rd [ - 1 ] ) ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> rd . pop ( ) <NEWLINE> wd . popleft ( ) <NEWLINE> count += 1 <NEWLINE> <DEDENT> print ( count ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> li = list ( input ( ) ) <NEWLINE> i = 0 <NEWLINE> j = n - 1 <NEWLINE> ans = 0 <NEWLINE> while ( i < j ) : <NEWLINE> <INDENT> while ( li [ i ] == <STRING> and i < j ) : <NEWLINE> <INDENT> i += 1 <NEWLINE> <DEDENT> while ( li [ j ] == <STRING> and i < j ) : <NEWLINE> <INDENT> j -= 1 <NEWLINE> <DEDENT> if li [ i ] = <STRING> and li [ j ] = <STRING> : <NEWLINE> <INDENT> li [ i ] = <STRING> <NEWLINE> li [ j ] = <STRING> <NEWLINE> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> C = list ( input ( ) ) <NEWLINE> L = 0 <NEWLINE> R = 0 <NEWLINE> RR = 0 <NEWLINE> X = 0 <NEWLINE> <INDENT> for i in range ( N ) : <NEWLINE> <INDENT> L = i <NEWLINE> R = RR <NEWLINE> if L >= N - 1 - R : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if C [ i ] == <STRING> : <NEWLINE> <INDENT> for ii in range ( N - L - R ) : <NEWLINE> <INDENT> if C [ N - 1 - R - ii ] == <STRING> : <NEWLINE> <INDENT> C [ L ] = <STRING> <NEWLINE> C [ N - 1 - R - ii ] = <STRING> <NEWLINE> X += 1 <NEWLINE> break <NEWLINE> <DEDENT> RR += 1 <NEWLINE> if L >= N - 1 - R : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( X ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> a = [ str ( c ) for c in s ] <NEWLINE> <NL> def sea ( a , z , n ) : <NEWLINE> <INDENT> while z [ 0 ] < n - 1 : <NEWLINE> <INDENT> if a [ z [ 0 ] ] == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> z [ 0 ] += 1 <NEWLINE> <NL> <DEDENT> while z [ 1 ] > 0 : <NEWLINE> <INDENT> if a [ z [ 1 ] ] == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> z [ 1 ] += 1 <NEWLINE> <NL> <DEDENT> return ( z ) <NEWLINE> <NL> <DEDENT> z = [ 0 , n - 1 ] <NEWLINE> <NL> z = a ( a , z , n ) <NEWLINE> c = 0 <NEWLINE> while z [ 0 ] < z [ 1 ] : <NEWLINE> <INDENT> a [ z [ 0 ] ] , a [ z [ 1 ] ] = a [ z [ 1 ] ] , a [ z [ 0 ] ] <NEWLINE> c += 1 <NEWLINE> z = a ( a , z , n ) <NEWLINE> <NL> <DEDENT> print ( c ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> c = input ( ) <NEWLINE> W = c . count ( <STRING> ) <NEWLINE> print ( c [ : R ] . count ( <STRING> ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> c = input ( ) <NEWLINE> d = c . count ( w ) <NEWLINE> e = c . count ( w ) [ : d ] <NEWLINE> print ( d - e ) <NEWLINE>
import itertools <NEWLINE> N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> cnt = 0 <NEWLINE> while True : <NEWLINE> <INDENT> while i < N and S [ i ] == <STRING> : <NEWLINE> <INDENT> i += 1 <NEWLINE> <DEDENT> while 0 <= j and S [ j ] == <STRING> : <NEWLINE> <INDENT> j -= 1 <NEWLINE> <DEDENT> if j < i : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> cnt += 1 <NEWLINE> i += 1 <NEWLINE> j -= 1 <NEWLINE> <DEDENT> print ( cnt ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> c = list ( input ( ) ) [ : : - 1 ] <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> res = 0 <NEWLINE> cR = c . count ( <STRING> ) <NEWLINE> cW = c . count ( <STRING> ) <NEWLINE> <NL> l , r = 0 , N - 1 <NEWLINE> while True : <NEWLINE> <INDENT> if c [ l ] == <STRING> : <NEWLINE> <INDENT> if c [ r ] == <STRING> : <NEWLINE> <INDENT> c [ l ] , c [ r ] = <STRING> , <STRING> <NEWLINE> res += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> r -= 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> l += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( min ( cR , cW , res ) ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> r_c = 0 <NEWLINE> ch = 0 <NEWLINE> for i in S : <NEWLINE> <INDENT> if i == <STRING> : <NEWLINE> <INDENT> r_c += 1 <NEWLINE> <DEDENT> <DEDENT> for i in range ( r_c ) : <NEWLINE> <INDENT> if i == <STRING> <NEWLINE> <INDENT> ch += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ch ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> C = input ( ) <NEWLINE> c_R = 0 <NEWLINE> c_W = 0 <NEWLINE> for c in C : <NEWLINE> <INDENT> if c == <STRING> : c_R += 1 <NEWLINE> else : c_W += 1 <NEWLINE> <DEDENT> ans = min ( c_R , c_W ) <NEWLINE> <NL> <NL> if C [ 0 ] + C [ 1 ] == <STRING> : <NEWLINE> <INDENT> C [ 2 : ] . find ( <STRING> ) != - 1 : <NEWLINE> C = list ( C ) <NEWLINE> C [ 0 ] = <STRING> <NEWLINE> C [ C [ 2 : ] . find ( <STRING> ) + 1 ] = <STRING> <NEWLINE> C = <STRING> . join ( C ) <NEWLINE> <NL> <DEDENT> ind1 = C . find ( <STRING> ) <NEWLINE> if ind1 != - 1 : <NEWLINE> <INDENT> ind2 = C [ ind1 + 2 : ] . find ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ind2 = - 1 <NEWLINE> <NL> <NL> <DEDENT> while ( ( ind1 != - 1 ) & ( ind2 != - 1 ) ) : <NEWLINE> <INDENT> C = list ( C ) <NEWLINE> C [ ind1 + 1 ] = <STRING> <NEWLINE> C [ ind2 + 1 ] = <STRING> <NEWLINE> C = <STRING> . join ( C ) <NEWLINE> <NL> ind1 = C . find ( <STRING> ) <NEWLINE> if ind1 != - 1 : <NEWLINE> <INDENT> ind2 = C [ ind1 + 2 : ] . find ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ind2 = - 1 <NEWLINE> <NL> <NL> <NL> <NL> <NL> <DEDENT> <DEDENT> c_R = 0 <NEWLINE> c_W = 0 <NEWLINE> for c in C : <NEWLINE> <INDENT> if c == <STRING> : c_R += 1 <NEWLINE> else : c_W += 1 <NEWLINE> <DEDENT> ans = min ( ans , c_R , c_W ) <NEWLINE> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL>
N = int ( input ( ) ) <NEWLINE> c = str ( input ( ) ) <NEWLINE> <NL> a = 0 <NEWLINE> b = 0 <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> a = a + 1 <NEWLINE> <DEDENT> <DEDENT> ans = max ( a , b ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> a = a - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> b = b + 1 <NEWLINE> <DEDENT> now = max ( a , b ) <NEWLINE> ans = min ( ans , now ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> c = input ( ) <NEWLINE> <NL> w = [ ] <NEWLINE> r = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if c [ i ] == <STRING> : <NEWLINE> <INDENT> w . append ( i + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> r . append ( i + 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> w_len = len ( w ) <NEWLINE> r_len = len ( r ) <NEWLINE> if w_len == 0 or r_len == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( 0 ) <NEWLINE> <NL> <DEDENT> w_min = w [ 0 ] <NEWLINE> r_max = r [ r_len - 1 ] <NEWLINE> count = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> tmp = w [ i ] <NEWLINE> w [ i ] = r [ r_len - i - 1 ] <NEWLINE> r [ r_len - i - 1 ] = tmp <NEWLINE> count += 1 <NEWLINE> <NL> w_min = w [ count ] <NEWLINE> r_max = r [ r_len - count - 1 ] <NEWLINE> <NL> if r_max < w_min : <NEWLINE> <INDENT> print ( count ) <NEWLINE> exit ( 0 ) <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> c = list ( input ( ) ) <NEWLINE> c = c [ : : - 1 ] <NEWLINE> cou = 0 <NEWLINE> for i in range ( len ( c ) / 2 ) : <NEWLINE> <INDENT> if c [ i ] == <STRING> : <NEWLINE> <INDENT> cou += 1 <NEWLINE> <DEDENT> <DEDENT> print ( cou ) <NEWLINE>
import sys <NEWLINE> import math <NEWLINE> <NL> n = int ( sys . stdin . readline ( ) . rstrip ( <STRING> ) ) <NEWLINE> c = list ( sys . stdin . readline ( ) . rstrip ( <STRING> ) ) <NEWLINE> ans = 0 <NEWLINE> left , right = 0 , len ( arr ) - 1 <NEWLINE> <NL> while ( left < right ) : <NEWLINE> <INDENT> while ( c [ left ] == <STRING> ) : <NEWLINE> <INDENT> left += 1 <NEWLINE> if left >= n : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> while ( c [ right ] == <STRING> ) : <NEWLINE> <INDENT> right -= 1 <NEWLINE> if right < 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> if ( left < right ) : <NEWLINE> <INDENT> c [ left ] , c [ right ] = c [ right ] , c [ left ] <NEWLINE> ans += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> c = input ( ) <NEWLINE> W = [ ] <NEWLINE> R = [ ] <NEWLINE> pw = 0 <NEWLINE> pr = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if c [ i ] == <STRING> : <NEWLINE> <INDENT> W += [ i ] <NEWLINE> pw += 1 <NEWLINE> <NL> <DEDENT> if c [ N - 1 - i ] == <STRING> : <NEWLINE> <INDENT> R += [ i ] <NEWLINE> pr += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( 200000 ) : <NEWLINE> <INDENT> if min ( len ( W ) , len ( R ) ) == 0 : <NEWLINE> <INDENT> result = 0 <NEWLINE> break <NEWLINE> <DEDENT> if W [ i ] + R [ i ] >= N : <NEWLINE> <INDENT> result = i <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( result ) <NEWLINE> result = i <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( input ( ) ) <NEWLINE> print ( C [ : C . count ( <STRING> ) ] . count ( <STRING> ) ) <NEWLINE>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> idx = n - 1 - i <NEWLINE> if s [ idx ] == <STRING> and s [ idx + 1 ] == <STRING> : <NEWLINE> <INDENT> ans += 1 <NEWLINE> s [ idx ] = <STRING> <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
def calculate ( n , s ) : <NEWLINE> <INDENT> arr = list ( S ) <NEWLINE> <NL> RNum = arr . count ( <STRING> ) <NEWLINE> <NL> leftW = 0 <NEWLINE> rightR = RNum <NEWLINE> <NL> result = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if arr [ i ] == <STRING> : <NEWLINE> <INDENT> rightR -= 1 <NEWLINE> <DEDENT> if arr [ i ] == <STRING> : <NEWLINE> <INDENT> leftW += 1 <NEWLINE> <NL> <DEDENT> result . append ( max ( leftW , rightR ) ) <NEWLINE> <NL> <DEDENT> print ( min ( result ) ) <NEWLINE> <NL> <NL> <DEDENT> calculate ( N , S ) <NEWLINE>
Cc = copy . copy ( Cn ) <NEWLINE> if ( Cn [ 0 ] == <STRING> ) : <NEWLINE> <INDENT> Rflg = True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> Rflg = False <NEWLINE> <DEDENT> ans = 0 <NEWLINE> K = N - 1 <NEWLINE> allw = False <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if Rflg and Cc [ i ] == <STRING> : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> Rflg = True <NEWLINE> <DEDENT> if Cc [ i ] == <STRING> : <NEWLINE> <INDENT> for j in range ( K , i , - 1 ) : <NEWLINE> <INDENT> if Cc [ j ] == <STRING> : <NEWLINE> <COMMENT> <NL> <INDENT> ans += 1 <NEWLINE> Cc [ i ] , Cc [ j ] = Cc [ j ] , Cc [ i ] <NEWLINE> K = j <NEWLINE> <COMMENT> <NL> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> allw = True <NEWLINE> <NL> <DEDENT> <DEDENT> else : <NEWLINE> <COMMENT> <NL> <INDENT> ans += 1 <NEWLINE> Cc [ i ] = <STRING> <NEWLINE> <COMMENT> <NL> <DEDENT> if allw : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> stone = list ( map ( str , input ( ) ) ) <NEWLINE> ind = [ <STRING> ] * 2 <NEWLINE> ind [ 0 ] = list ( ) <NEWLINE> ind [ 1 ] = list ( ) <NEWLINE> R = 0 <NEWLINE> W = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if ( stone [ i ] == <STRING> ) : <NEWLINE> <INDENT> ind [ 0 ] . append ( i ) <NEWLINE> W += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ind [ 1 ] . append ( i ) <NEWLINE> R += 1 <NEWLINE> <DEDENT> <DEDENT> ind [ 1 ] . reverse ( ) <NEWLINE> ans = 0 <NEWLINE> <NL> if ( W != R ) : <NEWLINE> <INDENT> print ( min ( W , R ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( N ) : <NEWLINE> <INDENT> if ( ind [ 0 ] [ i ] > ind [ 1 ] [ i ] ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> ans += 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> s = input ( ) . split ( ) <NEWLINE> s2 = sorted ( s ) <NEWLINE> t = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if s [ i ] != s2 [ i ] : <NEWLINE> <INDENT> t += 1 <NEWLINE> <DEDENT> <DEDENT> print ( t ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> C = input ( ) <NEWLINE> C = [ str ( c ) for c in C ] <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> if C [ i ] == <STRING> : <NEWLINE> <INDENT> C = C [ i : ] <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if C [ - 1 ] == <STRING> : <NEWLINE> <INDENT> for i in range ( 1 , N ) : <NEWLINE> <INDENT> if C [ - i ] == <STRING> : <NEWLINE> <INDENT> C = C [ : - i + 1 ] <NEWLINE> break <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> print ( min ( C . count ( <STRING> ) , C . count ( <STRING> ) ) ) <NEWLINE>
import sys <NEWLINE> N = int ( input ( ) ) <NEWLINE> c = [ str ( x ) for x in list ( input ( ) ) ] <NEWLINE> R = sum ( [ 1 for i , x in enumerate ( c ) if ( x == <STRING> ) ] ) <NEWLINE> W = 0 <NEWLINE> if ( R == N ) or ( R == 0 ) : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> ans = R <NEWLINE> i = 0 <NEWLINE> while True : <NEWLINE> <INDENT> if ( c [ i ] == <STRING> ) : <NEWLINE> <INDENT> W += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> R -= 1 <NEWLINE> <DEDENT> n_ans = max ( W , R ) <NEWLINE> if ( n_ans > ans ) : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> ans = n_ans <NEWLINE> i += 1 <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> n = 0 <NEWLINE> if S . find ( <STRING> ) == - 1 or S . find ( <STRING> ) == - 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> while S . find ( <STRING> ) <= S . rfind ( <STRING> ) : <NEWLINE> <INDENT> S = S [ S . find ( <STRING> ) + 1 : S . rfind ( <STRING> ) ] <NEWLINE> n += 1 <NEWLINE> <DEDENT> print ( n ) <NEWLINE> <DEDENT>
def func_rfindr ( str ) : <NEWLINE> <INDENT> return str . rfind ( <STRING> ) <NEWLINE> <NL> <DEDENT> def func_lfindw ( str , start ) : <NEWLINE> <INDENT> return str . find ( <STRING> , start ) <NEWLINE> <NL> <DEDENT> def func_replace ( target , pos , str ) : <NEWLINE> <INDENT> ret = <STRING> <NEWLINE> if pos != 0 : <NEWLINE> <INDENT> ret = target [ 0 : pos ] <NEWLINE> <DEDENT> ret = ret + str <NEWLINE> if len ( target ) - 1 != pos : <NEWLINE> <INDENT> ret = ret + target [ pos + 1 : ] <NEWLINE> <DEDENT> return ret <NEWLINE> <NL> <DEDENT> N = int ( input ( ) ) <NEWLINE> C = input ( ) <NEWLINE> ans = 0 <NEWLINE> <NL> posrr = func_rfindr ( C ) <NEWLINE> poslw = func_lfindw ( C ) <NEWLINE> <NL> while poslw != - 1 and posrr != - 1 and posrr > poslw : <NEWLINE> <INDENT> C = func_replace ( C , posrr , <STRING> ) <NEWLINE> C = func_replace ( C , poslw , <STRING> ) <NEWLINE> ans = ans + 1 <NEWLINE> posrr = func_rfindr ( C ) <NEWLINE> poslw = func_lfindw ( C , poslw ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> l = 0 <NEWLINE> r = n - 1 <NEWLINE> ans = 0 <NEWLINE> while l < r : <NEWLINE> <INDENT> while l < r & & s [ l ] == <STRING> : <NEWLINE> <INDENT> l += 1 <NEWLINE> <DEDENT> while l < r & & s [ r ] == <STRING> : <NEWLINE> <INDENT> r -= 1 <NEWLINE> <DEDENT> ans += 1 <NEWLINE> l += 1 <NEWLINE> r -= 1 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = list ( input ( ) ) <NEWLINE> l = 0 <NEWLINE> r = n - 1 <NEWLINE> c = 0 <NEWLINE> while l < r : <NEWLINE> <INDENT> for i in range ( l , r ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> l = i <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> l = r <NEWLINE> <DEDENT> for i in range ( r , l , - 1 ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> r = i <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> r = l <NEWLINE> <DEDENT> if l < r : <NEWLINE> <INDENT> c += 1 <NEWLINE> <DEDENT> <DEDENT> print ( c ) <NEWLINE> <NL>
N = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> <NL> ans = 0 <NEWLINE> i , j = 0 , N - 2 <NEWLINE> while i < j : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> i += 1 <NEWLINE> <DEDENT> elif s [ j ] == <STRING> : <NEWLINE> <INDENT> j -= 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> k += 1 <NEWLINE> i += 1 <NEWLINE> j -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( k ) <NEWLINE>
<NL> if w_count >= r_count : <NEWLINE> <INDENT> print ( w_count ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( w_count - right_w_count ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> c = str ( input ( ) ) <NEWLINE> <NL> r_m = c . count ( <STRING> ) <NEWLINE> w_m = c . count ( <STRING> ) <NEWLINE> wr_m = c . count ( <STRING> ) <NEWLINE> <NL> print ( min ( r_m , w_m ) - wr_m // 2 ) <NEWLINE> s = 0 <NEWLINE> if r_m >= w_m : <NEWLINE> <INDENT> for i in range ( len ( c ) - 1 ) : <NEWLINE> if c [ i ] == <STRING> and c [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> c [ i + 1 ] = <STRING> <NEWLINE> s += 1 <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> c = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> left = 0 <NEWLINE> cnt = 0 <NEWLINE> right = len ( c ) - 1 <NEWLINE> while left < n and right >= 0 and left < right : <NEWLINE> <INDENT> while left < n and c [ left ] != <STRING> : <NEWLINE> <INDENT> left += 1 <NEWLINE> <DEDENT> while right >= 0 and c [ right ] != <STRING> : <NEWLINE> <INDENT> right -= 1 <NEWLINE> <DEDENT> if left < n and right >= 0 and left < right : <NEWLINE> <INDENT> c [ left ] , c [ right ] = c [ right ] , c [ left ] <NEWLINE> cnt += 1 <NEWLINE> left += 1 <NEWLINE> right -= 1 <NEWLINE> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE> <NL>
s = input ( ) <NEWLINE> R_num = s . count ( <STRING> ) <NEWLINE> print ( s [ : R_num ] . count ( <STRING> ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> <NL> c = Counter ( S ) <NEWLINE> S_target = <STRING> * c [ <STRING> ] + <STRING> * c [ <STRING> ] <NEWLINE> <NL> ans = 0 <NEWLINE> for a , b in zip ( S , S_target ) : <NEWLINE> <INDENT> if b == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if a != b : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> c = list ( input ( ) ) <COMMENT> <NEWLINE> a = c . count ( <STRING> ) <NEWLINE> b = 0 <NEWLINE> count = max ( a , b ) <NEWLINE> <COMMENT> <NL> for i in range ( n + 1 ) : <NEWLINE> <INDENT> if c [ i ] == <STRING> : <NEWLINE> <INDENT> a = a - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> b = b + 1 <NEWLINE> <DEDENT> ans = max ( a , b ) <NEWLINE> count = min ( ans , count ) <NEWLINE> <DEDENT> print ( count ) <NEWLINE> <NL>
import math <NEWLINE> import collections <NEWLINE> import bisect <NEWLINE> from collections import deque <NEWLINE> from copy import copy , deepcopy <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> N , S = Input . split ( ) <NEWLINE> print ( N ) <NEWLINE> N = int ( N ) <NEWLINE> l = 0 <NEWLINE> r = len ( S ) - 1 <NEWLINE> ans = 0 <NEWLINE> while ( 1 ) : <NEWLINE> <INDENT> for i in range ( l , len ( S ) ) : <NEWLINE> <INDENT> if S [ i ] == <STRING> : <NEWLINE> <INDENT> l = i <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> for j in range ( r , 0 , - 1 ) : <NEWLINE> <INDENT> if S [ j ] == <STRING> : <NEWLINE> <INDENT> r = j <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if i < j : <NEWLINE> <INDENT> ans += 1 <NEWLINE> l = i + 1 <NEWLINE> r = j - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> arr = np . array ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> l = 1 <NEWLINE> r = max ( arr ) <NEWLINE> <NL> while l + 1 < r : <NEWLINE> <INDENT> m = ( l + r ) // 2 <NEWLINE> <NL> cut = 0 <NEWLINE> for x in arr : <NEWLINE> <INDENT> cut += ( x - 1 ) // m <NEWLINE> <NL> <DEDENT> if cut > k : <NEWLINE> <INDENT> l = m <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> r = m <NEWLINE> <NL> <DEDENT> <DEDENT> print ( r ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> tmax = max ( a ) <NEWLINE> tmin = 0 <NEWLINE> t = ( tmax + tmin ) // 2 <NEWLINE> import math <NEWLINE> ans = tmax <NEWLINE> if k == 0 : <NEWLINE> <INDENT> print ( tmax ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> while True : <NEWLINE> <INDENT> s = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> s = s + math . ceil ( a [ i ] / t ) - 1 <NEWLINE> <DEDENT> if k >= s : <NEWLINE> <INDENT> ans = min ( math . ceil ( t ) , math . ceil ( ans ) ) <NEWLINE> tmax = t <NEWLINE> t = ( tmin + t ) // 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> tmin = t <NEWLINE> t = ( t + tmax ) // 2 <NEWLINE> <DEDENT> if tmax - tmin < 0.01 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
import math <NEWLINE> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a . sort ( revese = True ) <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> t = max ( a ) <NEWLINE> a . insert ( 0 , t / 2 ) <NEWLINE> a . remove ( t ) <NEWLINE> <DEDENT> print ( math . ceil ( max ( a ) ) ) <NEWLINE>
from math import ceil <NEWLINE> from heapq import heapify , heappop , heappush <NEWLINE> <NL> N , K , * A = map ( int , open ( 0 ) . read ( ) . split ( ) ) <NEWLINE> <NL> t = sum ( A ) / K <NEWLINE> a = [ None ] * len ( A ) <NEWLINE> for i in A : <NEWLINE> <INDENT> k = max ( ceil ( i / t ) , 1 ) <NEWLINE> a . append ( ( - i / k , i , k ) ) <NEWLINE> <NL> <DEDENT> heapify ( a ) <NEWLINE> for _ in range ( K ) : <NEWLINE> <INDENT> i , j , k = heappop ( a ) <NEWLINE> k += 1 <NEWLINE> i = - ( j / k ) <NEWLINE> heappush ( a , ( i , j , k ) ) <NEWLINE> <DEDENT> print ( ceil ( heappop ( a ) [ 0 ] * - 1 ) ) <NEWLINE>
n , k , * A = map ( int , open ( 0 ) . read ( ) . split ( ) ) <NEWLINE> t = sum ( A ) / ( n + k ) <NEWLINE> A = [ a for a in A if int ( a / t ) >= 1 ] <NEWLINE> X = [ ] <NEWLINE> for a in A : <NEWLINE> <INDENT> X . append ( ceil ( a / ceil ( a / t ) ) ) <NEWLINE> X . append ( ceil ( a / int ( a / t ) ) ) <NEWLINE> <DEDENT> X . sort ( ) <NEWLINE> print ( X [ k ] if k < len ( X ) else X [ - 1 ] ) <NEWLINE>
import sys <NEWLINE> import re <NEWLINE> import math <NEWLINE> import collections <NEWLINE> import bisect <NEWLINE> import itertools <NEWLINE> import fractions <NEWLINE> import functools <NEWLINE> import copy <NEWLINE> import heapq <NEWLINE> import decimal <NEWLINE> import statistics <NEWLINE> import queue <NEWLINE> <NL> <COMMENT> <NL> <NL> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> INF = 10 ** 16 <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> <COMMENT> <NL> <NL> ni = lambda : int ( sys . stdin . readline ( ) ) <NEWLINE> ns = lambda : map ( int , sys . stdin . readline ( ) . split ( ) ) <NEWLINE> na = lambda : list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) <NEWLINE> na1 = lambda : list ( map ( lambda x : int ( x ) - 1 , sys . stdin . readline ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> <COMMENT> <NL> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> n , k = ns ( ) <NEWLINE> a = na ( ) <NEWLINE> a . sort ( reverse = True ) <NEWLINE> upper = 10 ** 9 + 1 <NEWLINE> under = 0 <NEWLINE> <NL> while upper - under > 0.01 : <NEWLINE> <INDENT> middle = ( upper + under ) // 2 <NEWLINE> <NL> tk = k <NEWLINE> flg = True <NEWLINE> for ai in a : <NEWLINE> <INDENT> if ai <= middle : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> ta = ai <NEWLINE> tk -= int ( ( ta - middle ) / middle ) <NEWLINE> if tk < 0 : <NEWLINE> <INDENT> flg = False <NEWLINE> <DEDENT> break <NEWLINE> <NL> <DEDENT> if flg : <NEWLINE> <INDENT> upper = middle <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> under = middle <NEWLINE> <NL> <DEDENT> <DEDENT> print ( math . ceil ( under ) ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
mport math <NEWLINE> def check ( lis , k , mid ) : <NEWLINE> <INDENT> for i in lis : <NEWLINE> <INDENT> k -= ( i // mid ) <NEWLINE> <DEDENT> return k >= 0 <NEWLINE> <DEDENT> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> lis = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a , b = 1 , max ( lis ) <NEWLINE> ans = b <NEWLINE> while ( a <= b ) : <NEWLINE> <INDENT> mid = ( a + b ) / 2 <NEWLINE> if ( check ( lis , k , mid ) ) : <NEWLINE> <INDENT> ans = mid <NEWLINE> b = mid - 0.000001 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a = mid + 0.000001 <NEWLINE> <DEDENT> <DEDENT> print ( int ( math . ceil ( ans ) ) ) <NEWLINE>
import sys <NEWLINE> import math <NEWLINE> import fractions <NEWLINE> from collections import defaultdict <NEWLINE> import heapq <NEWLINE> from bisect import bisect_left , bisect <NEWLINE> <NL> stdin = sys . stdin <NEWLINE> <NL> ns = lambda : stdin . readline ( ) . rstrip ( ) <NEWLINE> ni = lambda : int ( stdin . readline ( ) . rstrip ( ) ) <NEWLINE> nm = lambda : map ( int , stdin . readline ( ) . split ( ) ) <NEWLINE> nl = lambda : list ( map ( int , stdin . readline ( ) . split ( ) ) ) <NEWLINE> <NL> N , K = nm ( ) <NEWLINE> A = nl ( ) <NEWLINE> l = 1 <NEWLINE> r = 10 ** 9 <NEWLINE> mid = 0 <NEWLINE> <NL> if ( K == 0 ) : <NEWLINE> <INDENT> print ( max ( A ) ) <NEWLINE> sys . exit ( 0 ) <NEWLINE> <NL> <DEDENT> while ( l + 1 < r ) : <NEWLINE> <INDENT> mid = ( l + r ) // 2 <NEWLINE> tmp = 0 <NEWLINE> <NL> for i in range ( len ( A ) ) : <NEWLINE> <INDENT> if ( ( A [ i ] ) % mid ) : <NEWLINE> <INDENT> tmp = ( ( A [ i ] ) // mid ) - 1 <NEWLINE> <DEDENT> else <NEWLINE> <INDENT> tmp = ( ( A [ i ] ) // mid ) <NEWLINE> <DEDENT> <DEDENT> if ( tmp <= K ) : <NEWLINE> <INDENT> r = mid <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> l = mid <NEWLINE> <NL> <DEDENT> <DEDENT> print ( r ) <NEWLINE>
def mi ( ) : return map ( int , sys . stdin . readline ( ) . split ( ) ) <NEWLINE> def li ( ) : return list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) <NEWLINE> def li2 ( N ) : return [ list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) for i in range ( N ) ] <NEWLINE> def dp2 ( ini , i , j ) : return [ [ ini ] * i for i2 in range ( j ) ] <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> from itertools import accumulate <COMMENT> <NEWLINE> import math <NEWLINE> <NL> N , K = mi ( ) <NEWLINE> A = li ( ) <NEWLINE> <NL> if K == 0 : <NEWLINE> <INDENT> print ( max ( A ) ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> left = 0 <NEWLINE> right = max ( A ) <NEWLINE> <NL> def count ( num ) : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> cnt += math . ceil ( A [ i ] / num ) - 1 <NEWLINE> <DEDENT> return cnt <NEWLINE> <NL> <DEDENT> while True : <NEWLINE> <INDENT> mid = ( left + right ) // 2 <NEWLINE> if mid == 0 : <NEWLINE> <INDENT> mid += 1 <NEWLINE> break <NEWLINE> <DEDENT> tmp = count ( mid ) <NEWLINE> if tmp == K : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> elif tmp > K : <NEWLINE> <INDENT> if left == mid : <NEWLINE> <INDENT> mid = right <NEWLINE> break <NEWLINE> <DEDENT> left = mid <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> right = mid <NEWLINE> <NL> <DEDENT> <DEDENT> if mid == 0 or mid == 1 : <NEWLINE> <INDENT> print ( mid ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> right = mid <NEWLINE> <NL> while True : <NEWLINE> <INDENT> tmp = count ( mid ) <NEWLINE> if tmp == K and tmp != count ( mid - 1 ) : <NEWLINE> <INDENT> print ( mid ) <NEWLINE> break <NEWLINE> <DEDENT> elif tmp == K : <NEWLINE> <INDENT> right = mid <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if left == mid : <NEWLINE> <INDENT> print ( right ) <NEWLINE> break <NEWLINE> <DEDENT> left = mid <NEWLINE> <DEDENT> mid = ( left + right ) // 2 <NEWLINE> if mid == 0 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT>
import math <NEWLINE> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> As = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> def cut_num ( a , cut_length ) : <NEWLINE> <INDENT> return math . ceil ( a / cut_length ) - 1 <NEWLINE> <NL> <NL> <DEDENT> <STRING> <NEWLINE> l = 1 <NEWLINE> r = max ( As ) <NEWLINE> <NL> ans = r <NEWLINE> while True : <NEWLINE> <INDENT> m = ( l + r ) // 2 <NEWLINE> current_cut_num = sum ( [ cut_num ( a , m ) for a in As ] ) <NEWLINE> if current_cut_num <= K : <NEWLINE> <INDENT> r = m <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> l = m <NEWLINE> <NL> <DEDENT> if r - l < 1 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> if sum ( [ cut_num ( a , l ) for a in As ] ) <= K : <NEWLINE> <INDENT> print ( l ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( r ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> <NL> def resolve ( in_ ) : <NEWLINE> <INDENT> n = int ( next ( in_ ) ) <NEWLINE> c = next ( in_ ) . strip ( ) <NEWLINE> <NL> ans = 0 <NEWLINE> left = 0 <NEWLINE> right = len ( c ) - 1 <NEWLINE> while left < right : <NEWLINE> <INDENT> if c [ left ] == <STRING> : <NEWLINE> <INDENT> left += 1 <NEWLINE> continue <NEWLINE> <DEDENT> if c [ right ] == <STRING> : <NEWLINE> <INDENT> right -= 1 <NEWLINE> continue <NEWLINE> <DEDENT> left += 1 <NEWLINE> right -= 1 <NEWLINE> ans += 1 <NEWLINE> <NL> <DEDENT> return ans <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> answer = resolve ( sys . stdin ) <NEWLINE> print ( answer ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> A . sort ( reverse = True ) <NEWLINE> <NL> left = 0 <NEWLINE> right = A [ 0 ] <NEWLINE> <NL> while right - left > 1 : <NEWLINE> <INDENT> mid = ( left + right ) // 2 <NEWLINE> jk = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> jk += math . ceil ( A [ i ] / mid ) <NEWLINE> <DEDENT> if jk < K : <NEWLINE> <INDENT> right = mid <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> left = mid <NEWLINE> <NL> <DEDENT> <DEDENT> print ( right ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 8 ) <NEWLINE> def ii ( ) : return int ( sys . stdin . readline ( ) ) <NEWLINE> def mi ( ) : return map ( int , sys . stdin . readline ( ) . split ( ) ) <NEWLINE> def li ( ) : return list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) <NEWLINE> def li2 ( N ) : return [ list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) for i in range ( N ) ] <NEWLINE> def dp2 ( ini , i , j ) : return [ [ ini ] * i for i2 in range ( j ) ] <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> from itertools import accumulate <COMMENT> <NEWLINE> import math <NEWLINE> <NL> N , K = mi ( ) <NEWLINE> A = li ( ) <NEWLINE> <NL> if K == 0 : <NEWLINE> <INDENT> print ( max ( A ) ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> left = 0 <NEWLINE> right = max ( A ) <NEWLINE> <NL> def count ( num ) : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> cnt += math . ceil ( A [ i ] / num ) - 1 <NEWLINE> <DEDENT> return cnt <NEWLINE> <NL> <DEDENT> while True : <NEWLINE> <INDENT> mid = ( left + right ) // 2 <NEWLINE> if mid == 0 : <NEWLINE> <INDENT> mid += 1 <NEWLINE> break <NEWLINE> <DEDENT> tmp = count ( mid ) <NEWLINE> if tmp == K : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> elif tmp > K : <NEWLINE> <INDENT> if left == mid : <NEWLINE> <INDENT> mid += 1 <NEWLINE> break <NEWLINE> <DEDENT> left = mid <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> right = mid <NEWLINE> <NL> <DEDENT> <DEDENT> if mid == 0 or mid == 1 : <NEWLINE> <INDENT> print ( mid ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> if count ( left ) == K : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> right = mid <NEWLINE> <NL> while True : <NEWLINE> <INDENT> tmp = count ( mid ) <NEWLINE> if tmp == K and tmp != count ( mid - 1 ) : <NEWLINE> <INDENT> print ( mid ) <NEWLINE> break <NEWLINE> <DEDENT> elif tmp == K : <NEWLINE> <INDENT> right = mid <NEWLINE> <DEDENT> else : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <INDENT> left = mid <NEWLINE> <DEDENT> mid = ( left + right ) // 2 <NEWLINE> if mid == 0 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> r = max ( A ) <NEWLINE> l = 0 <NEWLINE> while l + 1 < r : <NEWLINE> <INDENT> mid = ( l + r ) // 2 <NEWLINE> if sum ( [ a - 1 ] // mid for a in A ) > k : <NEWLINE> <INDENT> l = mid <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> r = mid <NEWLINE> <DEDENT> <DEDENT> print ( r ) <NEWLINE>
n , k = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> right = 10 ** 9 <NEWLINE> left = 1 <NEWLINE> <NL> while right - left > 1 : <NEWLINE> <INDENT> mid = ( left + right ) // 2 <NEWLINE> count = 0 <NEWLINE> for a in A : <NEWLINE> <INDENT> count += a // mid <NEWLINE> if a % mid == 0 : <NEWLINE> <INDENT> count -= 1 <NEWLINE> <DEDENT> <DEDENT> if count <= k : <NEWLINE> <INDENT> right = mid <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> left = mid <NEWLINE> <NL> <DEDENT> <DEDENT> print ( right ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> def check ( 1 ) : <NEWLINE> <INDENT> count = 0 <NEWLINE> for L in A : <NEWLINE> <INDENT> count = count + L // 1 <NEWLINE> if L % 1 != 0 : <NEWLINE> <INDENT> count = count + 1 <NEWLINE> <DEDENT> count = count - 1 <NEWLINE> <DEDENT> return count <= K <NEWLINE> <NL> <DEDENT> bottom , top = 0 , max ( A ) <NEWLINE> <NL> while top - bottom > 1 : <NEWLINE> <INDENT> mid = ( top + bottom ) // 2 <NEWLINE> if check ( mid ) : <NEWLINE> <INDENT> top = mid <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> bottom = mid <NEWLINE> <NL> <DEDENT> <DEDENT> print ( top ) <NEWLINE>
import numpy as np <NEWLINE> import math <NEWLINE> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <COMMENT> <NL> def is_ok ( i ) : <NEWLINE> <INDENT> su = 0 <NEWLINE> for a in A : <NEWLINE> <INDENT> su += math . ceil ( n / i ) - 1 <NEWLINE> <DEDENT> if su <= K : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return False <NEWLINE> <NL> <DEDENT> <DEDENT> def meguru_bisect ( ng , ok ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> while ( abs ( ok - ng ) > 1 ) : <NEWLINE> <INDENT> mid = ( ok + ng ) // 2 <NEWLINE> if is_ok ( mid ) : <NEWLINE> <INDENT> ok = mid <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ng = mid <NEWLINE> <DEDENT> <DEDENT> return ok <NEWLINE> <NL> <DEDENT> print ( meguru_bisect ( 0 , max ( A ) + 1 ) ) <NEWLINE>
from math import modf <NEWLINE> n , k , * A = map ( int , open ( 0 ) . read ( ) . split ( ) ) <NEWLINE> t = sum ( A ) / ( n + k ) <NEWLINE> A = [ a for a in A if int ( a / t ) >= 1 ] <NEWLINE> c = k - sum ( int ( a / t ) - 1 for a in A ) <NEWLINE> X = [ ] <NEWLINE> for a in A : <NEWLINE> <INDENT> X . append ( ceil ( a / ceil ( a / t ) ) ) <NEWLINE> X . append ( ceil ( a / int ( a / t ) ) ) <NEWLINE> <DEDENT> X . sort ( ) <NEWLINE> print ( X [ - c - 1 ] ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> l , r = 0 , 10 ** 9 <NEWLINE> while r - l > 1 : <NEWLINE> <INDENT> m = ( l + r ) // 2 <NEWLINE> if sum ( [ ( i - 1 ) // x for i in a ] ) <= k : r = m ; <NEWLINE> else : l = m ; <NEWLINE> <DEDENT> print ( r ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> main ( ) <NEWLINE> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . strip ( ) . split ( ) ) ) <NEWLINE> <NL> b = 0 <NEWLINE> e = max ( A ) <NEWLINE> L = e // 2 <NEWLINE> while e - b >= 1 : <NEWLINE> <INDENT> m = sum ( list ( map ( lambda x : x // L , A ) ) ) <NEWLINE> if m <= k : <NEWLINE> <INDENT> e = L <NEWLINE> L = ( e + b ) // 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> b = L <NEWLINE> L = ( e + b ) // 2 <NEWLINE> <DEDENT> <DEDENT> print ( e ) <NEWLINE>
input = open ( <STRING> ) . readline <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> l , r = 0 , max ( A ) <NEWLINE> while l < r - 1 : <NEWLINE> <INDENT> mid = l + ( r - l ) // 2 <NEWLINE> cnt = 0 <NEWLINE> for a in A : <NEWLINE> <INDENT> cnt += a // mid <NEWLINE> <NL> <DEDENT> if cnt <= K : <NEWLINE> <INDENT> r = mid <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> l = mid <NEWLINE> <DEDENT> <DEDENT> print ( r ) <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> f = open ( <STRING> ) <NEWLINE> <NL> N , K = map ( int , f . readline ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , f . readline ( ) . split ( ) ) ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> A . sort ( reverse = True ) <NEWLINE> <NL> def nibu ( small , big ) : <NEWLINE> <INDENT> mid = ( small + big ) // 2 <NEWLINE> <COMMENT> <NL> k_list = [ x // mid for x in A ] <NEWLINE> sum_k = sum ( k_list ) <NEWLINE> if sum_k <= K : <COMMENT> <NEWLINE> <INDENT> return small , mid <COMMENT> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return mid , big <COMMENT> <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if N == 1 or K == 0 : <NEWLINE> <INDENT> ans = A [ 0 ] <NEWLINE> <DEDENT> else : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <INDENT> lmin = 0 <NEWLINE> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> lmax = A [ 1 ] <NEWLINE> <NL> while lmax - lmin >= 2 : <NEWLINE> <INDENT> lmin , lmax = nibu ( lmin , lmax ) <NEWLINE> <NL> <DEDENT> ans = lmax <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> <NL> def is_ok ( A , x , K ) : <NEWLINE> <INDENT> cut_count = 0 <NEWLINE> for number in A : <NEWLINE> <INDENT> cut_count += ( math . ceil ( number / x ) ) - 1 <NEWLINE> <DEDENT> return cut_count <= K <NEWLINE> <NL> <DEDENT> A = [ ] <NEWLINE> N = int ( input ( ) ) <NEWLINE> K = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> <NL> l = 0 <NEWLINE> r = 10 ** 9 <NEWLINE> <NL> for _ in range ( N ) : <NEWLINE> <INDENT> A . append ( int ( input ( ) ) ) <NEWLINE> <NL> <DEDENT> while r - l > 1 : <NEWLINE> <INDENT> x = ( r + l ) // 2 <NEWLINE> if is_ok ( A , x , K ) : <NEWLINE> <INDENT> r = x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> l = x <NEWLINE> <NL> <DEDENT> <DEDENT> print ( r ) <NEWLINE>
import math <NEWLINE> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> x0 , x1 = 0 , 10 ** 9 <NEWLINE> while x0 + 1 < x1 : <NEWLINE> <INDENT> x = ( x0 + x1 ) // 2 <NEWLINE> suma = 0 <NEWLINE> for i in a : <NEWLINE> <INDENT> suma += ( a // x ) <NEWLINE> <NL> <DEDENT> if suma > k : <NEWLINE> <INDENT> x0 = x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x1 = x <NEWLINE> <DEDENT> <DEDENT> print ( x1 ) <NEWLINE>
from numba import njit , i8 <NEWLINE> n , k , * a = map ( int , open ( 0 ) . read ( ) . split ( ) ) <NEWLINE> <NL> @ njit ( cache = True ) <NEWLINE> def c ( x , a ) : <NEWLINE> <INDENT> res = 0 <NEWLINE> for b in a : <NEWLINE> <INDENT> res += 0 - - b // x - 1 <NEWLINE> <DEDENT> return res <= k <NEWLINE> <NL> <DEDENT> ng = 0 <NEWLINE> ok = 10 ** 9 + 1 <NEWLINE> while ok - ng > 1 : <NEWLINE> <INDENT> mid = ( ok + ng ) >> 1 <NEWLINE> if c ( mid , a ) : <NEWLINE> <INDENT> ok = mid <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ng = mid <NEWLINE> <DEDENT> <DEDENT> print ( ok ) <NEWLINE>
import math <NEWLINE> <NL> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> def check ( L ) : <NEWLINE> <INDENT> return sum ( math . ceil ( a / L ) - 1 for a in A ) <= K <NEWLINE> <NL> <DEDENT> answer = max ( A ) <NEWLINE> lo = 1 <NEWLINE> hi = answer + 1 <NEWLINE> while lo < hi : <NEWLINE> <INDENT> m = ( lo + hi ) // 2 <NEWLINE> ok = check ( m ) <NEWLINE> if ok : <NEWLINE> <INDENT> answer = min ( m , answer ) <NEWLINE> hi = m <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> lo = m + 1 <NEWLINE> <DEDENT> <DEDENT> print ( answer ) ) <NEWLINE> <NL> <NL> <STRING> <NEWLINE>
import numpy as np <NEWLINE> from numba import jit <NEWLINE> verbose = False <NEWLINE> <NL> N , K = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A = np . array ( list ( map ( int , input ( ) . split ( ) ) ) , dtype = np . int64 ) <NEWLINE> <NL> ul = np . ceil ( np . sum ( A ) / ( K ) ) <NEWLINE> ll = np . floor ( np . max ( A ) / ( K + 1 ) ) <NEWLINE> <NL> EPS = 1 / 10 ** 6 <NEWLINE> <NL> @ jit ( nopython = True ) <NEWLINE> def cut ( A , c , N ) : <NEWLINE> <INDENT> return ( np . sum ( np . ceil ( A / c ) ) - N ) <NEWLINE> <NL> <DEDENT> c = np . ceil ( ( ul + ll ) / 2 ) <NEWLINE> mx = np . max ( A ) <NEWLINE> while True : <NEWLINE> <INDENT> if ul - ll == 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> nk = cut ( A , c , N ) <NEWLINE> if verbose : <NEWLINE> <INDENT> print ( <STRING> , c , <STRING> , nk , <STRING> , ul , <STRING> , ll ) <NEWLINE> <DEDENT> prev = c <NEWLINE> if nk > K : <COMMENT> <NEWLINE> <INDENT> ll = c <NEWLINE> c = np . floor ( ( ul + c ) / 2 ) <NEWLINE> <DEDENT> else : <COMMENT> <NEWLINE> <INDENT> ul = c <NEWLINE> c = np . ceil ( ( c + ll ) / 2 ) <NEWLINE> <NL> <DEDENT> <DEDENT> if cut ( A , ll + EPS , N ) >= K : <NEWLINE> <INDENT> print ( np . min ( ( np . max ( A ) , int ( ul ) ) ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( int ( ll ) ) <NEWLINE> <NL> <DEDENT>
def main ( N , Q , C , LR ) : <NEWLINE> <INDENT> data = [ 0 ] * ( N + 1 ) <NEWLINE> def add ( i , x ) : <NEWLINE> <INDENT> i += 1 <NEWLINE> while i <= N : <NEWLINE> <INDENT> data [ i ] += x <NEWLINE> i += i & - i <NEWLINE> <DEDENT> <DEDENT> def sum ( a , b ) : <NEWLINE> <INDENT> r = 0 <NEWLINE> i = b <NEWLINE> while i > 0 : <NEWLINE> <INDENT> r += data [ i ] <NEWLINE> i -= i & - i <NEWLINE> <DEDENT> i = a <NEWLINE> while i > 0 : <NEWLINE> <INDENT> r -= data [ i ] <NEWLINE> i -= i & - i <NEWLINE> <DEDENT> return r <NEWLINE> <DEDENT> p = [ - 1 ] * N <NEWLINE> q = 0 <NEWLINE> a = [ 0 ] * Q <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if p [ C [ i ] - 1 ] >= 0 : <NEWLINE> <INDENT> add ( p [ C [ i ] - 1 ] , - 1 ) <NEWLINE> <DEDENT> p [ C [ i ] - 1 ] = i <NEWLINE> add ( i , 1 ) <NEWLINE> while q < Q and LR [ q ] [ 2 ] == i + 1 : <NEWLINE> <INDENT> a [ LR [ q ] [ 0 ] ] = sum ( LR [ q ] [ 1 ] - 1 , LR [ q ] [ 2 ] ) <NEWLINE> q += 1 <NEWLINE> <DEDENT> <DEDENT> return a <NEWLINE> <NL> <DEDENT> import sys <NEWLINE> if sys . argv [ - 1 ] == <STRING> : <NEWLINE> <INDENT> from numba import * <NEWLINE> from numba . pycc import CC <NEWLINE> cc = CC ( <STRING> ) <NEWLINE> <NL> def cc_export ( f , signature ) : <NEWLINE> <INDENT> cc . export ( f . __name__ , signature ) ( f ) <NEWLINE> return njit ( f ) <NEWLINE> <NL> <DEDENT> main = cc_export ( main , ( i8 , i8 , i8 [ : ] , i8 [ : , : ] ) ) <NEWLINE> cc . compile ( ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> N , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> import numpy as np <NEWLINE> C = np . array ( input ( ) . split ( ) , dtype = np . int64 ) <NEWLINE> LR = sorted ( [ [ i ] + list ( map ( int , input ( ) . split ( ) ) ) for i in range ( Q ) ] , key = lambda x : x [ 2 ] ) <NEWLINE> LR = np . array ( LR ) <NEWLINE> <NL> from my_module import main <NEWLINE> print ( * main ( N , Q , C , LR ) , sep = <STRING> ) <NEWLINE>
import sys <NEWLINE> import numpy as np <NEWLINE> <NL> read = sys . stdin . buffer . read <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> readlines = sys . stdin . buffer . readlines <NEWLINE> <NL> Bsize = 700 <NEWLINE> <NL> @ njit ( ( i8 [ : , : ] , ) , cache = True ) <NEWLINE> def Mo_argsort ( LR ) : <NEWLINE> <INDENT> L = LR [ : , 0 ] <NEWLINE> R = LR [ : , 1 ] <NEWLINE> key1 = L // Bsize <NEWLINE> key2 = np . where ( key1 & 1 , - R , R ) <NEWLINE> key = ( key1 << 32 ) + key2 <NEWLINE> return np . argsort ( key ) <NEWLINE> <NL> <DEDENT> def main ( A , LR ) : <NEWLINE> <INDENT> N = len ( A ) <NEWLINE> Q = len ( LR ) <NEWLINE> ind = Mo_argsort ( LR ) <NEWLINE> count = np . zeros ( N + 1 , np . int64 ) <NEWLINE> ans = 0 <NEWLINE> <NL> def add ( x ) : <NEWLINE> <INDENT> nonlocal ans <NEWLINE> if not count [ x ] : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> count [ x ] += 1 <NEWLINE> <NL> <DEDENT> def rem ( x ) : <NEWLINE> <INDENT> nonlocal ans <NEWLINE> count [ x ] -= 1 <NEWLINE> if not count [ x ] : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> answers = np . empty ( Q , np . int64 ) <NEWLINE> nl , nr = 0 , 0 <NEWLINE> for i in ind : <NEWLINE> <INDENT> l , r = LR [ i ] <NEWLINE> l -= 1 <NEWLINE> <COMMENT> <NL> while nl > l : <NEWLINE> <INDENT> nl -= 1 <NEWLINE> add ( A [ nl ] ) <NEWLINE> <DEDENT> while nr < r : <NEWLINE> <INDENT> add ( A [ nr ] ) <NEWLINE> nr += 1 <NEWLINE> <DEDENT> while nl < l : <NEWLINE> <INDENT> rem ( A [ nl ] ) <NEWLINE> nl += 1 <NEWLINE> <DEDENT> while nr > r : <NEWLINE> <INDENT> nr -= 1 <NEWLINE> rem ( A [ nr ] ) <NEWLINE> <COMMENT> <NL> <DEDENT> answers [ i ] = ans <NEWLINE> <DEDENT> return answers <NEWLINE> <NL> <DEDENT> if sys . argv [ - 1 ] == <STRING> : <NEWLINE> <INDENT> import numba <NEWLINE> from numba . pycc import CC <NEWLINE> i4 = numba . int32 <NEWLINE> i8 = numba . int64 <NEWLINE> cc = CC ( <STRING> ) <NEWLINE> <NL> def cc_export ( f , signature ) : <NEWLINE> <INDENT> cc . export ( f . __name__ , signature ) ( f ) <NEWLINE> return numba . njit ( f ) <NEWLINE> <NL> <DEDENT> main = cc_export ( main , ( i8 [ : ] , i8 [ : , : ] ) ) <NEWLINE> cc . compile ( ) <NEWLINE> <NL> <DEDENT> from my_module import main <NEWLINE> <NL> N , Q = map ( int , readline ( ) . split ( ) ) <NEWLINE> A = np . array ( readline ( ) . split ( ) , np . int64 ) <NEWLINE> LR = np . array ( read ( ) . split ( ) , np . int64 ) . reshape ( Q , 2 ) <NEWLINE> <NL> ans = main ( A , LR ) <NEWLINE> print ( <STRING> . join ( map ( str , ans . tolist ( ) ) ) ) <NEWLINE>
from numpy import * <NEWLINE> from numba import * <NEWLINE> @ njit ( <STRING> , cache = True ) <NEWLINE> def main ( n , q , c , z ) : <NEWLINE> <INDENT> a = zeros ( q , int64 ) <NEWLINE> t = zeros ( 9 ** 6 , int64 ) <NEWLINE> b = zeros ( 9 ** 6 , int64 ) <NEWLINE> j = 0 <NEWLINE> for i in argsort ( z [ : , 1 ] ) : <NEWLINE> <INDENT> l , r = z [ i , 0 ] , z [ i , 1 ] <NEWLINE> while j < r : <NEWLINE> <INDENT> d = c [ j ] <NEWLINE> j += 1 <NEWLINE> x , y , b [ d ] = b [ d ] + 1 , j + 1 , j <NEWLINE> while x <= n : <NEWLINE> <INDENT> t [ x ] += 1 <NEWLINE> x += x & - x <NEWLINE> <DEDENT> while y <= n : <NEWLINE> <INDENT> t [ y ] -= 1 <NEWLINE> y += y & - y <NEWLINE> <DEDENT> <DEDENT> while l : <NEWLINE> <INDENT> a [ i ] += t [ l ] <NEWLINE> l -= l & - l <NEWLINE> <DEDENT> <DEDENT> return a <NEWLINE> <DEDENT> ( n , q ) , c , * z = [ int_ ( t . split ( ) ) for t in open ( 0 ) ] <NEWLINE> print ( <STRING> . join ( map ( str , main ( n , q , c , int_ ( z ) ) . tolist ( ) ) ) ) <NEWLINE>
import sys <NEWLINE> import numpy as np <NEWLINE> def proc ( C , L , R , Order , N , Q ) : <NEWLINE> <INDENT> pl = pr = 0 <NEWLINE> ans = 0 <NEWLINE> A = np . zeros ( N + 1 , dtype = np . int32 ) <NEWLINE> Ans = np . zeros ( Q , dtype = np . int32 ) <NEWLINE> for idx_LR in Order : <NEWLINE> <INDENT> l = L [ idx_LR ] <NEWLINE> r = R [ idx_LR ] <NEWLINE> while pr < r : <NEWLINE> <INDENT> pr += 1 <NEWLINE> c = C [ pr ] <NEWLINE> if A [ c ] == 0 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> A [ c ] += 1 <NEWLINE> <DEDENT> while pl > l : <NEWLINE> <INDENT> pl -= 1 <NEWLINE> c = C [ pl ] <NEWLINE> if A [ c ] == 0 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> A [ c ] += 1 <NEWLINE> <DEDENT> while pr > r : <NEWLINE> <INDENT> c = C [ pr ] <NEWLINE> A [ c ] -= 1 <NEWLINE> if A [ c ] == 0 : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <DEDENT> pr -= 1 <NEWLINE> <DEDENT> while pl < l : <NEWLINE> <INDENT> c = C [ pl ] <NEWLINE> A [ c ] -= 1 <NEWLINE> if A [ c ] == 0 : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <DEDENT> pl += 1 <NEWLINE> <DEDENT> Ans [ idx_LR ] = ans <NEWLINE> <DEDENT> return Ans <NEWLINE> <NL> <DEDENT> if sys . argv [ - 1 ] == <STRING> : <NEWLINE> <INDENT> import numba <NEWLINE> from numba . pycc import CC <NEWLINE> cc = CC ( <STRING> ) <NEWLINE> def cc_export ( f , signature ) : <NEWLINE> <INDENT> cc . export ( f . __name__ , signature ) ( f ) <NEWLINE> return numba . njit ( f ) <NEWLINE> <DEDENT> build = cc_export ( proc , <STRING> ) <NEWLINE> cc . compile ( ) <NEWLINE> <NL> <DEDENT> from my_module import proc <NEWLINE> def main ( ) : <NEWLINE> <INDENT> input = sys . stdin . buffer . readline <NEWLINE> N , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> C = np . empty ( N + 1 , dtype = np . int32 ) <NEWLINE> C [ 0 ] = 0 <NEWLINE> C [ 1 : ] = np . array ( input ( ) . split ( ) , dtype = np . int32 ) <NEWLINE> LR = np . array ( sys . stdin . buffer . read ( ) . split ( ) , dtype = np . uint32 ) <NEWLINE> L = LR [ : : 2 ] <NEWLINE> R = LR [ 1 : : 2 ] <NEWLINE> B = L >> 1 << 20 | R <NEWLINE> Idx = ( L >> 9 & 1 ) . astype ( np . bool ) <NEWLINE> B [ Idx ] = L [ Idx ] >> 9 << 20 | ( 1 << 20 ) - R [ Idx ] <NEWLINE> Order = np . argsort ( B ) <NEWLINE> Ans = proc ( C , L , R , Order , N , Q ) <NEWLINE> print ( <STRING> . join ( map ( str , Ans . tolist ( ) ) ) ) <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE>
import sys <NEWLINE> import numpy as np <NEWLINE> from numba import i8 , njit , jitclass <NEWLINE> <NL> spec = [ <NEWLINE> <INDENT> ( <STRING> , i8 ) , <NEWLINE> ( <STRING> , i8 [ : ] ) <NEWLINE> <DEDENT> ] <NEWLINE> <NL> @ jitclass ( spec ) <NEWLINE> class BIT : <NEWLINE> <INDENT> <STRING> <NEWLINE> def __init__ ( self , itemCount , bitArray ) : <NEWLINE> <INDENT> self . itemCount = itemCount <NEWLINE> self . items = bitArray <COMMENT> <NEWLINE> <NL> <DEDENT> def add ( self , i , value ) : <NEWLINE> <INDENT> while i <= self . itemCount : <NEWLINE> <INDENT> self . items [ i ] += value <NEWLINE> i += ( i & ( - i ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> def sumFromStart ( self , end ) : <NEWLINE> <INDENT> summary = 0 <NEWLINE> i = end <NEWLINE> while i > 0 : <NEWLINE> <INDENT> summary += self . items [ i ] <NEWLINE> i -= ( i & ( - i ) ) <NEWLINE> <DEDENT> return summary <NEWLINE> <NL> <DEDENT> def sum ( self , start , end ) : <NEWLINE> <INDENT> summary = self . sumFromStart ( end ) - self . sumFromStart ( start - 1 ) <NEWLINE> return summary <NEWLINE> <NL> <DEDENT> <DEDENT> def input ( ) : return sys . stdin . readline ( ) <NEWLINE> <NL> N , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> C = np . array ( input ( ) . split ( ) , int ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> queries = np . empty ( ( Q , 2 ) , int ) <NEWLINE> <COMMENT> <NL> <NL> for q in range ( Q ) : <NEWLINE> <INDENT> l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> <COMMENT> <NL> queries [ q ] [ 0 ] = l <NEWLINE> queries [ q ] [ 1 ] = r <NEWLINE> <COMMENT> <NL> <NL> <COMMENT> <NL> <NL> <DEDENT> orderByR = np . argsort ( queries [ : , 1 ] ) <NEWLINE> <NL> <COMMENT> <NL> mostRightColorIndex = np . zeros ( N + 1 , int ) <NEWLINE> <COMMENT> <NL> bitArray = np . zeros ( N + 1 , int ) <NEWLINE> bitree = BIT ( N , bitArray ) <NEWLINE> <NL> @ njit <NEWLINE> def mainLoop ( N , Q , C , queries , orderByR , mostRightColorIndex , bitree ) : <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <INDENT> ans = [ 0 ] * Q <NEWLINE> <COMMENT> <NL> qindex = 0 <NEWLINE> <NL> for n in range ( N ) : <NEWLINE> <COMMENT> <NL> <NL> <INDENT> if Q <= qindex : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> if 0 < mostRightColorIndex [ C [ n ] ] : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <INDENT> bitree . add ( mostRightColorIndex [ C [ n ] ] , - 1 ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> mostRightColorIndex [ C [ n ] ] = n + 1 <NEWLINE> bitree . add ( n + 1 , 1 ) <NEWLINE> <NL> <COMMENT> <NL> while qindex < Q and n + 1 == queries [ orderByR [ qindex ] ] [ 1 ] : <NEWLINE> <COMMENT> <NL> <INDENT> tmpIndex = orderByR [ qindex ] <NEWLINE> start = queries [ tmpIndex ] [ 0 ] <NEWLINE> end = queries [ tmpIndex ] [ 1 ] <NEWLINE> ans [ tmpIndex ] = bitree . sum ( start , end ) <NEWLINE> <COMMENT> <NL> qindex += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> return ans <NEWLINE> <NL> <DEDENT> for a in mainLoop ( N , Q , C , queries , orderByR , mostRightColorIndex , bitree ) : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <DEDENT>
import sys <NEWLINE> import numpy as np <NEWLINE> from numba import njit <COMMENT> <NEWLINE> <NL> <NL> def input ( ) : return sys . stdin . readline ( ) <NEWLINE> <NL> N , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> C = np . array ( input ( ) . split ( ) , int ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> queries = np . empty ( ( Q , 2 ) , int ) <NEWLINE> <COMMENT> <NL> <NL> for q in range ( Q ) : <NEWLINE> <INDENT> l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> <COMMENT> <NL> queries [ q ] [ 0 ] = l <NEWLINE> queries [ q ] [ 1 ] = r <NEWLINE> <COMMENT> <NL> <NL> <COMMENT> <NL> <NL> <DEDENT> orderByR = np . argsort ( queries [ : , 1 ] ) <NEWLINE> <NL> <COMMENT> <NL> mostRightColorIndex = np . zeros ( N + 1 , int ) <NEWLINE> <COMMENT> <NL> bitArray = np . zeros ( N + 1 , int ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> def main ( N , Q , C , queries , orderByR , mostRightColorIndex , bitArray ) : <NEWLINE> <NL> <INDENT> def add ( itemCount , items , i , value ) : <NEWLINE> <INDENT> while i <= itemCount : <NEWLINE> <INDENT> items [ i ] += value <NEWLINE> i += ( i & ( - i ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> def sumFromStart ( items , end ) : <NEWLINE> <INDENT> summary = 0 <NEWLINE> i = end <NEWLINE> while i > 0 : <NEWLINE> <INDENT> summary += items [ i ] <NEWLINE> i -= ( i & ( - i ) ) <NEWLINE> <DEDENT> return summary <NEWLINE> <NL> <DEDENT> def sum ( items , start , end ) : <NEWLINE> <INDENT> summary = sumFromStart ( items , end ) - sumFromStart ( items , start - 1 ) <NEWLINE> return summary <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> ans = np . zeros ( Q , dtype = np . int64 ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> qindex = 0 <NEWLINE> <NL> for n in range ( N ) : <NEWLINE> <COMMENT> <NL> <NL> <INDENT> if Q <= qindex : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> if 0 < mostRightColorIndex [ C [ n ] ] : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <INDENT> add ( N , bitArray , mostRightColorIndex [ C [ n ] ] , - 1 ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> mostRightColorIndex [ C [ n ] ] = n + 1 <NEWLINE> add ( N , bitArray , n + 1 , 1 ) <NEWLINE> <NL> <COMMENT> <NL> while qindex < Q and n + 1 == queries [ orderByR [ qindex ] ] [ 1 ] : <NEWLINE> <COMMENT> <NL> <INDENT> tmpIndex = orderByR [ qindex ] <NEWLINE> start = queries [ tmpIndex ] [ 0 ] <NEWLINE> end = queries [ tmpIndex ] [ 1 ] <NEWLINE> ans [ tmpIndex ] = sum ( bitArray , start , end ) <NEWLINE> <COMMENT> <NL> qindex += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> return ans <NEWLINE> <NL> <DEDENT> if sys . argv [ - 1 ] == <STRING> : <NEWLINE> <INDENT> from numba . pycc import CC <NEWLINE> cc = CC ( <STRING> ) <NEWLINE> cc . export ( <STRING> , <STRING> ) ( main ) <NEWLINE> cc . compile ( ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> from my_module import main <NEWLINE> <NL> for a in main ( N , Q , C , queries , orderByR , mostRightColorIndex , bitArray ) : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <DEDENT>
print ( 8 - ( X // 200 - 2 ) ) <NEWLINE>
x = int ( input ( ) ) <NEWLINE> if 400 <= x < 600 : <NEWLINE> <INDENT> print ( 8 ) <NEWLINE> <DEDENT> elif 600 <= x < 800 : <NEWLINE> <INDENT> print ( 7 ) <NEWLINE> <DEDENT> elif 800 <= x < 1000 : <NEWLINE> <INDENT> print ( 6 ) <NEWLINE> <DEDENT> elif 1000 <= x < 1200 : <NEWLINE> <INDENT> print ( 5 ) <NEWLINE> <DEDENT> elif 1200 <= x < 1400 : <NEWLINE> <INDENT> print ( 4 ) <NEWLINE> <DEDENT> elif 1400 <= x < 1600 : <NEWLINE> <INDENT> print ( 3 ) <NEWLINE> <DEDENT> elif 1600 <= x < 1800 : <NEWLINE> <INDENT> print ( 2 ) <NEWLINE> <DEDENT> elif 1800 <= x < 2000 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> x = int ( input ( ) ) <NEWLINE> if 400 <= x < 600 : <NEWLINE> <INDENT> prtint ( 8 ) <NEWLINE> <DEDENT> elif 600 <= x < 800 : <NEWLINE> <INDENT> print ( 7 ) <NEWLINE> <DEDENT> elif 800 <= x < 1000 : <NEWLINE> <INDENT> print ( 6 ) <NEWLINE> <DEDENT> elif 1000 <= x < 1200 : <NEWLINE> <INDENT> print ( 5 ) <NEWLINE> <DEDENT> elif 1200 <= x < 1400 : <NEWLINE> <INDENT> print ( 4 ) <NEWLINE> <DEDENT> elif 1400 <= x < 1600 : <NEWLINE> <INDENT> print ( 3 ) <NEWLINE> <DEDENT> elif 1600 <= x < 1800 : <NEWLINE> <INDENT> print ( 2 ) <NEWLINE> <DEDENT> elif 1800 <= x < 2000 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT>
if X >= 400 and X <= 599 : <NEWLINE> <INDENT> print ( 8 ) <NEWLINE> <DEDENT> elif X >= 600 and X <= 799 : <NEWLINE> <INDENT> print ( 7 ) <NEWLINE> <DEDENT> elif X >= 800 and X <= 999 : <NEWLINE> <INDENT> print ( 6 ) <NEWLINE> <DEDENT> elif X >= 1000 and X <= 1199 : <NEWLINE> <INDENT> print ( 5 ) <NEWLINE> <DEDENT> elif X >= 1200 and X <= 1399 : <NEWLINE> <INDENT> print ( 4 ) <NEWLINE> <DEDENT> elif X >= 1400 and X <= 1599 : <NEWLINE> <INDENT> print ( 3 ) <NEWLINE> <DEDENT> elif X >= 1600 and X <= 1799 : <NEWLINE> <INDENT> print ( 2 ) <NEWLINE> <DEDENT> elif X >= 1800 and X <= 1999 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT>
ist = [ ] <NEWLINE> starting = 400 <NEWLINE> for I in range ( 400 , 2001 ) : <NEWLINE> <INDENT> list . append ( starting ) <NEWLINE> starting += 1 <NEWLINE> <DEDENT> n = int ( input ( <STRING> ) ) <NEWLINE> for I in list : <NEWLINE> <INDENT> if ( n >= 400 and n <= 599 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> elif ( n >= 600 and n <= 799 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> elif ( n >= 800 and n <= 999 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> elif ( n >= 1000 and n <= 1199 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> elif ( n >= 1200 and n <= 1399 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> elif ( n >= 1400 and n <= 1599 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> elif ( n >= 1600 and n <= 1799 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> elif ( n >= 1800 and n <= 1999 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT>
print ( [ 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ] [ ( input ( ) - 400 ) // 200 ] ) <NEWLINE>
X = int ( input ( ) ) <NEWLINE> print 10 - X // 200 <NEWLINE>
X = int ( input ( ) ) <NEWLINE> <NL> if X in range ( 400 , 600 ) : <NEWLINE> <INDENT> print ( 8 ) <NEWLINE> <DEDENT> elif X in range ( 600 , 800 ) <NEWLINE> <INDENT> print ( 7 ) <NEWLINE> <DEDENT> elif X in range ( 800 , 1000 ) <NEWLINE> <INDENT> print ( 6 ) <NEWLINE> <DEDENT> elif X in range ( 1000 , 1200 ) <NEWLINE> <INDENT> print ( 5 ) <NEWLINE> <DEDENT> elif X in range ( 1200 , 1400 ) <NEWLINE> <INDENT> print ( 4 ) <NEWLINE> <DEDENT> elif X in range ( 1400 , 1600 ) <NEWLINE> <INDENT> print ( 3 ) <NEWLINE> <DEDENT> elif X in range ( 1600 , 1800 ) <NEWLINE> <INDENT> print ( 2 ) <NEWLINE> <DEDENT> elif X in range ( 1800 , 1900 ) <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT>
X = int ( input ( ) ) <NEWLINE> <NL> if 400 <= x <= 599 : <NEWLINE> <INDENT> print ( 8 ) <NEWLINE> <DEDENT> elif 600 <= x <= 799 : <NEWLINE> <INDENT> print ( 7 ) <NEWLINE> <DEDENT> elif 800 <= x <= 999 : <NEWLINE> <INDENT> print ( 6 ) <NEWLINE> <DEDENT> elif 1000 <= x <= 1199 : <NEWLINE> <INDENT> print ( 5 ) <NEWLINE> <DEDENT> elif 1200 <= x <= 1399 : <NEWLINE> <INDENT> print ( 4 ) <NEWLINE> <DEDENT> elif 1400 <= x <= 1599 : <NEWLINE> <INDENT> print ( 3 ) <NEWLINE> <DEDENT> elif 1600 <= x <= 1799 : <NEWLINE> <INDENT> print ( 2 ) <NEWLINE> <DEDENT> elif 1800 <= x <= 1999 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT>
print ( 8 - int ( ( input ( ) - 400 ) / 200 ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> if x >= 400 and x <= 599 : <NEWLINE> <INDENT> print ( 8 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> if x >= 600 and x <= 799 : <NEWLINE> <INDENT> print ( 7 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> if x >= 800 and x <= 999 : <NEWLINE> <INDENT> print ( 6 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> if x >= 1000 and x <= 1199 : <NEWLINE> <INDENT> print ( 5 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> if x >= 1200 and x <= 1399 : <NEWLINE> <INDENT> print ( 4 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> if x >= 1400 and x <= 1599 : <NEWLINE> <INDENT> print ( 3 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> if x >= 1600 and x <= 1799 : <NEWLINE> <INDENT> print ( 2 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> if x >= 1800 and x <= 1999 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <INDENT> exit ( ) <NEWLINE> <DEDENT> <DEDENT>
X = input ( ) <NEWLINE> a = 2000 / X <NEWLINE> if a >= 2000 / 599 : <NEWLINE> <INDENT> print ( 8 ) <NEWLINE> <DEDENT> elif a >= 2000 / 799 : <NEWLINE> <INDENT> print ( 7 ) <NEWLINE> <DEDENT> elif a >= 2000 / 999 : <NEWLINE> <INDENT> print ( 6 ) <NEWLINE> <DEDENT> elif a >= 2000 / 1199 : <NEWLINE> <INDENT> print ( 5 ) <NEWLINE> <DEDENT> elif a >= 2000 / 1399 : <NEWLINE> <INDENT> print ( 4 ) <NEWLINE> <DEDENT> elif a >= 2000 / 1599 : <NEWLINE> <INDENT> print ( 3 ) <NEWLINE> <DEDENT> elif a >= 2000 / 1799 : <NEWLINE> <INDENT> print ( 2 ) <NEWLINE> <DEDENT> elif a >= 2000 / 1999 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT>
from sys import stdin <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> h = [ int ( x ) for x in stdin . readline ( ) . rstrip ( ) . split ( ) ] <NEWLINE> kyu = 8 <NEWLINE> if 600 <= h and h < 800 : <NEWLINE> <INDENT> kyu = 7 <NEWLINE> <DEDENT> if 800 <= h and h < 1000 : <NEWLINE> <INDENT> kyu = 6 <NEWLINE> <DEDENT> if 1000 <= h and h < 1200 : <NEWLINE> <INDENT> kyu = 5 <NEWLINE> <DEDENT> if 1200 <= h and h < 1400 : <NEWLINE> <INDENT> kyu = 4 <NEWLINE> <DEDENT> if 1400 <= h and h < 1600 : <NEWLINE> <INDENT> kyu = 3 <NEWLINE> <DEDENT> if 1600 <= h and h < 1800 : <NEWLINE> <INDENT> kyu = 2 <NEWLINE> <DEDENT> if 1800 <= h and h < 2000 : <NEWLINE> <INDENT> kyu = 1 <NEWLINE> <DEDENT> print ( kyu ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) : <NEWLINE> if n <= 599 : <NEWLINE> <INDENT> print ( 8 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> if n <= 799 : <NEWLINE> <INDENT> print ( 7 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> if n <= 999 : <NEWLINE> <INDENT> print ( 6 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> if n <= 1199 : <NEWLINE> <INDENT> print ( 5 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> if n <= 1399 : <NEWLINE> <INDENT> print ( 4 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> if n <= 1599 : <NEWLINE> <INDENT> print ( 3 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> if n <= 1799 : <NEWLINE> <INDENT> print ( 2 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> if n <= 1999 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT>
n = input ( ) <NEWLINE> print ( 10 - n // 200 ) <NEWLINE>
try : <NEWLINE> <INDENT> X = int ( input ( ) ) <NEWLINE> <INDENT> if ( X >= 400 and X <= 599 ) : <NEWLINE> <INDENT> print ( 8 ) <NEWLINE> <DEDENT> elif ( X > 599 and X < 800 ) : <NEWLINE> <INDENT> print ( 7 ) <NEWLINE> <DEDENT> elif ( X >= 800 and X < 1000 ) : <NEWLINE> <INDENT> print ( 6 ) <NEWLINE> <DEDENT> elif ( X >= 1000 and X < 1200 ) : <NEWLINE> <INDENT> print ( 5 ) <NEWLINE> <DEDENT> elif ( X >= 1200 and X < 1400 ) : <NEWLINE> <INDENT> print ( 4 ) <NEWLINE> <DEDENT> elif ( X >= 1400 and X < 1600 ) : <NEWLINE> <INDENT> print ( 3 ) <NEWLINE> <DEDENT> elif ( X >= 1600 and X < 1800 ) : <NEWLINE> <INDENT> print ( 2 ) <NEWLINE> <DEDENT> elif ( X >= 1800 and X < 2000 ) : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> except EOFError as e : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
x = int ( input ( ) ) <NEWLINE> ans = 8 - ( X - 400 ) // 200 <NEWLINE> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> a = 8 - ( ( n - 400 ) // 200 ) <NEWLINE> <NL> print a <NEWLINE>
x = inport ( ) <NEWLINE> if 400 <= x <= 599 : <NEWLINE> <INDENT> print ( 8 ) <NEWLINE> <DEDENT> elif 600 <= x <= 799 : <NEWLINE> <INDENT> print ( 7 ) <NEWLINE> <DEDENT> elif 800 <= x <= 999 : <NEWLINE> <INDENT> print ( 6 ) <NEWLINE> <DEDENT> elif 1000 <= x <= 1199 : <NEWLINE> <INDENT> print ( 5 ) <NEWLINE> <DEDENT> elif 1200 <= x <= 1399 : <NEWLINE> <INDENT> print ( 4 ) <NEWLINE> <DEDENT> elif 1400 <= x <= 1599 : <NEWLINE> <INDENT> print ( 3 ) <NEWLINE> <DEDENT> elif 1600 <= x <= 1799 : <NEWLINE> <INDENT> print ( 2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT>
M = int ( input ( ) ) <NEWLINE> if M <= 399 : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> elif 400 <= M and M <= 599 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif M <= 799 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif M <= 999 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif M <= 1199 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif M <= 1399 : <NEWLINE> <INDENT> print ( <STRING> ) 1 <NEWLINE> <DEDENT> elif M <= 1599 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif M <= 1799 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif M <= 1999 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
x = int ( input ( ) ) <NEWLINE> for i in range ( 2 , 10 ) : <NEWLINE> <INDENT> if i <= x / 200 < i + 1 : <NEWLINE> <INDENT> print ( 10 - i ) : <NEWLINE> <DEDENT> <DEDENT>
N = int ( imput ( ) ) <NEWLINE> if N < 600 : <NEWLINE> <INDENT> print ( 8 ) <NEWLINE> <DEDENT> elif N < 800 : <NEWLINE> <INDENT> print ( 7 ) <NEWLINE> <DEDENT> elif N < 1000 : <NEWLINE> <INDENT> print ( 6 ) <NEWLINE> <DEDENT> elif N < 1200 : <NEWLINE> <INDENT> print ( 5 ) <NEWLINE> <DEDENT> elif N < 1400 : <NEWLINE> <INDENT> print ( 4 ) <NEWLINE> <DEDENT> elif N < 1600 : <NEWLINE> <INDENT> print ( 3 ) <NEWLINE> <DEDENT> elif N < 1800 : <NEWLINE> <INDENT> print ( 2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT>
def ranking ( x ) : <NEWLINE> <INDENT> if ( x >= 400 ) : <NEWLINE> <INDENT> if ( x < 600 ) : <NEWLINE> <INDENT> return 8 <NEWLINE> <DEDENT> elif ( x < 800 ) : <NEWLINE> <INDENT> return 7 <NEWLINE> <DEDENT> elif ( x < 1000 ) : <NEWLINE> <INDENT> return 6 <NEWLINE> <DEDENT> elif ( x < 1200 ) : <NEWLINE> <INDENT> return 5 <NEWLINE> <DEDENT> elif ( x < 1400 ) : <NEWLINE> <INDENT> return 4 <NEWLINE> <DEDENT> elif ( x < 1600 ) : <NEWLINE> <INDENT> return 3 <NEWLINE> <DEDENT> elif ( x < 1800 ) : <NEWLINE> <INDENT> return 2 <NEWLINE> <DEDENT> elif ( x < 2000 ) : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> x = input ( ) <NEWLINE> print ( ranking ( x ) ) <NEWLINE>
x = int ( readline ( ) ) <NEWLINE> y = x // 200 <NEWLINE> print ( 10 - y ) <NEWLINE>
x = int ( input ( ) ) <NEWLINE> def resolve ( ) : <NEWLINE> <INDENT> x = int ( input ( ) ) <NEWLINE> print ( 8 - ( ( x - 400 ) // 200 ) ) <NEWLINE> <NL> <DEDENT> resolve ( ) <NEWLINE>
<COMMENT> <NL> using namespace std ; <NEWLINE> using ll = long long ; <NEWLINE> using pii = pair < int , int > ; <NEWLINE> <COMMENT> <NL> <NL> int main ( ) { <NEWLINE> <INDENT> ios_base : : sync_with_stdio ( false ) ; <NEWLINE> int n ; <NEWLINE> cin >> n ; <NEWLINE> <NL> int a = n / 200 - 1 ; <NEWLINE> a = 9 - a ; <NEWLINE> <NL> cout << a << endl ; <NEWLINE> return 0 ; <NEWLINE> <DEDENT> } <NEWLINE>
a = int ( input ( ) ) <NEWLINE> print ( 8 ) if 400 <= a <= 599 <NEWLINE> print ( 7 ) if 600 <= a <= 799 <NEWLINE> print ( 6 ) if 800 <= a <= 999 <NEWLINE> print ( 5 ) if 1000 <= a <= 1199 <NEWLINE> print ( 4 ) if 1200 <= a <= 1399 <NEWLINE> print ( 3 ) if 1400 <= a <= 1599 <NEWLINE> print ( 2 ) if 1600 <= a <= 1799 <NEWLINE> print ( 1 ) if 1800 <= a <= 1999 <NEWLINE>
rate = imput ( ) <NEWLINE> <NL> di = rate // 200 <NEWLINE> <NL> print ( 10 - di ) <NEWLINE>
card = input ( ) . split ( ) <NEWLINE> k = int ( input ( ) ) <NEWLINE> arr = [ ] <NEWLINE> for i in range ( len ( card ) ) : <NEWLINE> <INDENT> res = int ( card [ i ] ) * 2 <NEWLINE> arr . append ( res ) <NEWLINE> <DEDENT> if arr [ 0 ] < arr [ 1 ] < arr [ 2 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT>
x = int ( input ( ) ) <NEWLINE> <NL> if 400 < = x and x <= 599 : <NEWLINE> <INDENT> print ( 8 ) <NEWLINE> <DEDENT> elif x <= 799 : <NEWLINE> <INDENT> print ( 7 ) <NEWLINE> <DEDENT> elif x <= 999 : <NEWLINE> <INDENT> print ( 6 ) <NEWLINE> <DEDENT> elif x <= 1199 : <NEWLINE> <INDENT> print ( 5 ) <NEWLINE> <DEDENT> elif x <= 1399 : <NEWLINE> <INDENT> print ( 4 ) <NEWLINE> <DEDENT> elif x <= 1599 : <NEWLINE> <INDENT> print ( 3 ) <NEWLINE> <DEDENT> elif x <= 1799 : <NEWLINE> <INDENT> print ( 2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT>
a = input ( ) <NEWLINE> <NL> if a >= 400 and a < 600 : print ( 8 ) <NEWLINE> elif a >= 600 and a < 800 : print ( 7 ) <NEWLINE> elif a >= 800 and a < 1000 : print ( 6 ) <NEWLINE> elif a >= 1000 and a < 1200 : print ( 5 ) <NEWLINE> elif a >= 1200 and a < 1400 : print ( 4 ) <NEWLINE> elif a >= 1400 and a < 1600 : print ( 3 ) <NEWLINE> elif a >= 1600 and a < 1800 : print ( 2 ) <NEWLINE> elif a >= 1800 and a < 2000 : print ( 1 ) <NEWLINE>
X = int ( input ( ) ) <NEWLINE> if X >= 1800 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> elif X >= 1600 : <NEWLINE> <INDENT> print ( 2 ) <NEWLINE> <DEDENT> elif X >= 1400 : <NEWLINE> <INDENT> print ( 3 ) <NEWLINE> <DEDENT> elif X >= 1200 : <NEWLINE> <INDENT> print ( 4 ) <NEWLINE> <DEDENT> elif X >= 1000 : <NEWLINE> <INDENT> print ( 5 ) <NEWLINE> <DEDENT> elif X >= 800 : <NEWLINE> <INDENT> print ( 6 ) <NEWLINE> <DEDENT> elif X >= 600 : <NEWLINE> <INDENT> print ( 7 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 8 ) <NEWLINE> <NL> <DEDENT> elif X >= 1600 : <NEWLINE> <INDENT> print ( 2 ) <NEWLINE> <DEDENT>
<INDENT> a = int ( input ( ) ) <NEWLINE> <NL> <INDENT> if a >= 400 and a < 600 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a >= 600 and a < 800 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a >= 800 and a < 1000 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a >= 1000 and a < 1200 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a >= 1200 and a < 1400 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a >= 1400 and a < 1600 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a >= 1600 and a < 1800 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a >= 1800 and a < 2000 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> <NL> rate = 600 <NEWLINE> rank = 8 <NEWLINE> <NL> while true : <NEWLINE> <INDENT> if n < rate : <NEWLINE> <INDENT> print ( rank ) <NEWLINE> break <NEWLINE> <DEDENT> rate += 200 <NEWLINE> rank -= 1 <NEWLINE> <DEDENT>
s = int ( input ( ) ) <NEWLINE> <NL> if 400 <= s < 599 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif 600 <= s < 799 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif 800 <= s < 999 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif 1000 <= s < 1199 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif 1200 <= s < 1399 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif 1400 <= s < 1599 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif 1600 <= s < 1799 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else 1800 <= s < 1999 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
print ( 10 - int ( input ) // 200 ) <NEWLINE>
x = int ( input ( ) ) <NEWLINE> <INDENT> if ( x >= 400 and x <= 599 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif ( x >= 600 and x <= 799 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif ( x >= 800 and x <= 999 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif ( x >= 1000 and x <= 1199 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif ( x >= 1200 and x <= 1399 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif ( x >= 1400 and x <= 1599 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif ( x >= 1600 and x <= 1799 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif ( x >= 1800 and x <= 1999 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
