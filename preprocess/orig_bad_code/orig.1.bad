map ( int , input ( ) . split ( ) ) <NEWLINE> print ( max ( A + B , A - B , A * B ) ) <NEWLINE>
A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> p = A + B <NEWLINE> m = A - B <NEWLINE> M = A * B <NEWLINE> <NL> L = [ ] <NEWLINE> <NL> L . append ( p ) <NEWLINE> L . append ( m ) <NEWLINE> L . append ( M ) <NEWLINE> <NL> print ( max ( M ) ) <NEWLINE>
a , b = int ( input ( ) . split ( ) ) <NEWLINE> print ( max ( a + b , a - b , a * b ) ) <NEWLINE>
a , b = map ( int , input ( ) ) <NEWLINE> print ( max ( a + b , a - b , a * b ) ) <NEWLINE>
s = input ( ) <NEWLINE> l = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> a , b = l [ 0 ] , l [ 1 ] <NEWLINE> print ( max ( a + b , max ( a - b , a * b ) ) ) <NEWLINE>
<NL> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> x = a + b <NEWLINE> y = a - b <NEWLINE> z = a * b <NEWLINE> O = [ x , y , z ] <NEWLINE> O = sorted ( O , reverse = 1 ) <NEWLINE> print ( O [ 0 ] <NEWLINE>
A , B = map ( int , input ( ) , split ( ) ) <NEWLINE> <NL> x = A + B <NEWLINE> y = A - B <NEWLINE> z = A * B <NEWLINE> print ( max ( x , y , z ) ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> s = a + b <NEWLINE> t = a - b <NEWLINE> u = a * b <NEWLINE> <NL> if s >= t : <NEWLINE> <INDENT> if t >= u : <NEWLINE> <INDENT> print ( s ) <NEWLINE> <DEDENT> elif s <= u : <NEWLINE> <INDENT> print ( u ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if s >= u : <NEWLINE> <INDENT> print ( t ) <NEWLINE> <DEDENT> elif : <NEWLINE> <INDENT> t <= u : <NEWLINE> print ( u ) <NEWLINE> <DEDENT> <DEDENT>
a , b = map ( int , input ( ) ) <NEWLINE> list_ab = [ ] <NEWLINE> list_ab . append ( a + b ) <NEWLINE> list_ab . append ( a - b ) <NEWLINE> list_ab . append ( a * b ) <NEWLINE> <NL> print ( max ( list_ab ) ) <NEWLINE>
A , B = map ( int ( input ( ) . split ( ) ) ) <NEWLINE> l = [ A + B , A - B , A * B ] <NEWLINE> print ( max ( l ) ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( max ( max ( a + b , a - b ) , a * b ) <NEWLINE>
N , X = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = [ ] <NEWLINE> for _ in range ( X - N + 1 , X + N ) : <NEWLINE> <INDENT> ans . append ( _ ) <NEWLINE> <DEDENT> print ( <STRING> . join ( ans ) ) <NEWLINE>
L = [ ] <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> y = x + i <NEWLINE> z = x - i <NEWLINE> if y > 1000000 : <NEWLINE> <INDENT> y = x <NEWLINE> <DEDENT> L . append ( y ) <NEWLINE> if z < - 1000000 : <NEWLINE> <INDENT> z = x <NEWLINE> <DEDENT> L . append ( z ) <NEWLINE> <DEDENT> I = set ( L ) <NEWLINE> for s in I : <NEWLINE> <INDENT> print ( s , end = <STRING> ) <NEWLINE> <DEDENT>
import sys <NEWLINE> import math <NEWLINE> import itertools <NEWLINE> import collections <NEWLINE> import heapq <NEWLINE> import re <NEWLINE> import numpy as np <NEWLINE> <NL> rr = lambda : sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> rs = lambda : sys . stdin . readline ( ) . split ( ) <NEWLINE> ri = lambda : int ( sys . stdin . readline ( ) ) <NEWLINE> rm = lambda : map ( int , sys . stdin . readline ( ) . split ( ) ) <NEWLINE> rl = lambda : list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) <NEWLINE> inf = float ( <STRING> ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> a , b = rm ( ) <NEWLINE> print ( * list ( range ( b - a + 1 : b + a ) ) ) <NEWLINE> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL>
k , x = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( * [ x for x in range ( X - K + 1 , X + K ) ] ) <NEWLINE>
<NL> <NL> <NL> def fun ( n , num , count ) : <NEWLINE> <NL> <INDENT> if count == ( num * 2 ) - 1 : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> print ( n , end = <STRING> ) <NEWLINE> count += 1 <NEWLINE> fun ( n + 1 , num , count ) <NEWLINE> <DEDENT> xnum = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> x = xnum [ 0 ] <NEWLINE> num = snum [ 1 ] <NEWLINE> <NL> m = x - ( num - 1 ) <NEWLINE> <NL> fun ( m , num , 0 ) <NEWLINE>
K , X = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> for i in range ( max ( - 1000000 , X - K + 1 ) , min ( X + K , 1000000 ) : <NEWLINE> <INDENT> print ( i , end = <STRING> ) <NEWLINE> <DEDENT>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> x = [ ] <NEWLINE> for i in range ( b - a + 1 , b + a ) : <NEWLINE> <INDENT> x . append ( i ) <NEWLINE> <DEDENT> print ( <STRING> . join ( x ) , sep = <STRING> ) <NEWLINE>
k , y = map ( int , input ( ) . split ( ) ) <NEWLINE> for i in range ( x - y + 1 , x + y ) : <NEWLINE> <INDENT> print ( i , end = <STRING> ) <NEWLINE> <DEDENT>
k , n = map ( int , input ( ) . split ( ) ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> print ( - n + 1 + i ) <NEWLINE> <DEDENT> print ( 0 ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> printf ( i ) <NEWLINE> <DEDENT>
k , x = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ x ] <NEWLINE> for i in range ( 1 , k ) : <NEWLINE> <INDENT> a . append ( x + i ) <NEWLINE> a . append ( x - i ) <NEWLINE> <NL> <DEDENT> print ( <STRING> . join ( sorted ( a ) ) ) <NEWLINE> <NL>
k , x = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> min_ans = x - k + 1 <NEWLINE> max_ans = x + K - 1 <NEWLINE> <NL> for x in range ( min_ans , max_ans + 1 ) : <NEWLINE> <INDENT> print ( x , end = <STRING> ) <NEWLINE> <DEDENT>
N , X = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> for i in range ( X - K + 1 , X + K ) : <NEWLINE> <INDENT> print ( i , end = <STRING> ) <NEWLINE> <DEDENT>
K , X = list ( map ( lambda n : int ( n ) , input ( ) . split ( <STRING> ) ) ) <NEWLINE> print ( <STRING> . join ( list ( range ( K - X + 1 , K + X - 1 ) ) ) ) <NEWLINE>
K , X = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( * list ( range [ X - K + 1 : X + K ] ) ) <NEWLINE>
import collections <NEWLINE> N = int ( input ( ) ) <NEWLINE> s = [ <STRING> . join ( sorted ( input ( ) ) ) for _ in range ( N ) ] <NEWLINE> print ( A ) <NEWLINE> B = collections . Counter ( s ) <NEWLINE> print ( sum ( i * ( i - 1 ) // 2 for i in B . values ( ) ) ) <NEWLINE>
from collections import Counter <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> cnt = Counter ( ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> s = sorted ( input ( ) ) <NEWLINE> <NL> if cnt [ s ] == 0 : <NEWLINE> <INDENT> cnt [ s ] = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += cnt [ s ] <NEWLINE> cnt [ s ] += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
S = [ ] <NEWLINE> cho = [ 0 ] <NEWLINE> p = 0 <NEWLINE> n = int ( input ( ) ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> s = sorted ( input ( ) ) <NEWLINE> if s in S : <NEWLINE> <INDENT> cho [ p ] += 1 <NEWLINE> p += 1 <NEWLINE> <DEDENT> S . append ( s ) <NEWLINE> <DEDENT> import collections <NEWLINE> from scipy . special import comb <NEWLINE> a = 0 <NEWLINE> Sd = list ( set ( S ) ) <NEWLINE> c = collections . Counter ( S ) <NEWLINE> for p in range ( len ( Sd ) ) : <NEWLINE> <INDENT> if c [ Sd [ p ] ] >= 2 : <NEWLINE> <INDENT> a += comb ( c [ Sd [ p ] ] , 2 , exact = True ) <NEWLINE> <DEDENT> <DEDENT> print ( a ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = { } <NEWLINE> ans = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> s = sorted ( s ) <NEWLINE> if A . get ( s , <STRING> ) == <STRING> : <NEWLINE> <INDENT> A [ s ] = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += A [ s ] <NEWLINE> A [ s ] += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> print ( len ( set ( [ sorted ( i ) for i in [ input ( ) for i in range ( n ) ] ] ) ) ) <NEWLINE>
import collections <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> S = [ ( sorted ( input ( ) ) ) for _ in range ( N ) ] <NEWLINE> c = collections . Counter ( S ) <NEWLINE> ans = 0 <NEWLINE> print ( S ) <NEWLINE> <NL> for i in set ( S ) : <NEWLINE> <INDENT> n = c [ i ] <NEWLINE> ans += n * ( n - 1 ) // 2 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
counter = { } <NEWLINE> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ss = sorted ( s [ i ] ) <NEWLINE> ss = ( <STRING> ) . join ( ss ) <NEWLINE> if ss not in counter : <NEWLINE> <INDENT> counter [ ss ] = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> counter [ ss ] += 1 <NEWLINE> ans += counter [ ss ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> def combinations_count ( n , r ) : <NEWLINE> <INDENT> return math . factorial ( n ) // ( math . factorial ( n - r ) * math . factorial ( r ) ) <NEWLINE> <NL> <DEDENT> N = int ( input ( ) ) <NEWLINE> dic_s = { } <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> s = <STRING> . join ( sorted ( input ( ) ) ) <NEWLINE> if s in dic_s : <NEWLINE> <INDENT> dic_s [ s ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dic_s [ s ] = 1 <NEWLINE> <DEDENT> <DEDENT> counter = 0 <NEWLINE> for key , value in dic_s . items ( ) : <NEWLINE> <INDENT> counter += combinations_count ( value , 2 ) <NEWLINE> <DEDENT> print ( counter ) <NEWLINE>
import math <NEWLINE> <NL> def comb ( n , r ) : <NEWLINE> <INDENT> return math . factorial ( n ) // ( math . factorial ( n - r ) * math . factorial ( r ) ) <NEWLINE> <NL> <DEDENT> N = int ( input ( ) ) <NEWLINE> a = [ input ( ) for _ in range ( N ) ] <NEWLINE> <NL> d = dict ( ) <NEWLINE> for x in a : <NEWLINE> <INDENT> s = <STRING> . join ( sorted ( x ) ) <NEWLINE> if s not in d . keys ( ) : <NEWLINE> <INDENT> d [ s ] = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d [ s ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( sum ( [ comb ( i , 2 ) for i in d . values ( ) ] ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> s = [ input ( ) for _ in range ( N ) ] <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> s [ i ] = list ( set ( s [ i ] ) ) <NEWLINE> <NL> <DEDENT> print ( len ( set ( s ) ) ) <NEWLINE>
def resolve ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> words = [ ] <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> words . append ( str ( sorted ( list ( input ( ) ) ) ) ) <NEWLINE> <DEDENT> a = collections . Counter ( words ) <NEWLINE> ans = 0 <NEWLINE> for i in a . values ( ) : <NEWLINE> <INDENT> ans += i * ( i - 1 ) // 2 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <DEDENT> resolve ( ) <NEWLINE>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> sn = [ input ( ) . strip ( <STRING> ) for _ in range ( n ) ] <NEWLINE> <NL> mod = 10 ** 7 + 7 <NEWLINE> hs = [ [ 0 , <STRING> ] for _ in range ( mod ) ] <NEWLINE> <NL> def hypo ( s , Mod ) : <NEWLINE> <INDENT> h_num = 1 <NEWLINE> for i in s : <NEWLINE> <INDENT> h_num = h_num * ord ( i ) % Mod <NEWLINE> <DEDENT> return h_num <NEWLINE> <NL> <DEDENT> for s in sn : <NEWLINE> <INDENT> s = <STRING> . join ( sorted ( s ) ) <NEWLINE> h = hypo ( s , mod ) <NEWLINE> while True : <NEWLINE> <INDENT> if h >= mod : <NEWLINE> <INDENT> h = 0 <NEWLINE> <DEDENT> if hs [ h ] [ 0 ] == 0 : <NEWLINE> <INDENT> hs [ h ] [ 0 ] += 1 <NEWLINE> hs [ h ] [ 1 ] += s <NEWLINE> break <NEWLINE> <DEDENT> if hs [ h ] [ 1 ] == s : <NEWLINE> <INDENT> hs [ h ] [ 0 ] += 1 <NEWLINE> break <NEWLINE> <DEDENT> h += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for j , t in hs : <NEWLINE> <INDENT> if j >= 2 : <NEWLINE> <INDENT> ans += j * ( j - 1 ) / 2 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( int ( ans ) ) <NEWLINE> <NL>
import collections <NEWLINE> def main4 ( ) : <NEWLINE> <INDENT> dd = collections . defaultdict ( int ) <NEWLINE> n = int ( input ( ) ) <NEWLINE> res = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> s . sort ( ) <NEWLINE> dd [ <STRING> . join ( s ) ] += 1 <NEWLINE> <DEDENT> for i in dd . values ( ) : <NEWLINE> <INDENT> res += ( i * ( i - 1 ) ) // 2 <NEWLINE> <DEDENT> print ( res ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main4 ( ) <NEWLINE> <DEDENT>
import itertools , math <NEWLINE> n = int ( input ( ) ) <NEWLINE> word = [ input ( ) for _ in range ( n ) ] <NEWLINE> count = 0 <NEWLINE> <NL> def combinations_count ( n , r ) : <NEWLINE> <INDENT> return math . factorial ( n ) // ( math . factorial ( n - r ) * math . factorial ( r ) ) <NEWLINE> <NL> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> word [ i ] = sorted ( word [ i ] ) <NEWLINE> <NL> <DEDENT> new_word = list ( sorted ( word ) ) <NEWLINE> <NL> x = 1 <NEWLINE> <NL> for i in range ( n - 1 ) : <NEWLINE> <INDENT> if new_word [ i ] == new_word [ i + 1 ] : <NEWLINE> <INDENT> x += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> count += combinations_count ( x , 2 ) <NEWLINE> x = 1 <NEWLINE> <DEDENT> <DEDENT> if x >= 2 : <NEWLINE> <INDENT> count += combinations_count ( x , 2 ) <NEWLINE> <NL> <DEDENT> print ( count ) <NEWLINE>
import collections <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> S = [ ( sorted ( input ( ) ) ) for _ in range ( N ) ] <NEWLINE> c = collections . Counter ( S ) <NEWLINE> ans = 0 <NEWLINE> for i in set ( S ) : <NEWLINE> <INDENT> n = c [ i ] <NEWLINE> ans += n * ( n - 1 ) // 2 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n = input ( ) <NEWLINE> s = [ <STRING> . join ( sorted ( input ( ) ) ) for i in range ( n ) ] <NEWLINE> count = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n ) : <NEWLINE> <INDENT> if s [ j ] [ 0 ] == s [ i ] [ 0 ] : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = [ list ( input ( ) ) for _ in range ( n ) ] <NEWLINE> ans = 0 <NEWLINE> sd = dict ( [ ] ) <NEWLINE> <NL> for i in s : <NEWLINE> <INDENT> key = <STRING> . join ( sorted ( i ) ) <NEWLINE> sd . setdefault ( key , 0 ) <NEWLINE> sd [ key ] += 1 <NEWLINE> <NL> <DEDENT> for v in s_dict . values ( ) : <NEWLINE> <INDENT> ans += v * ( v - 1 ) // 2 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
K , X = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> l = max ( X - K + 1 , - 1000000 ) <NEWLINE> r = min ( X + K - 1 , 1000000 ) <NEWLINE> <NL> ans = [ ] <NEWLINE> <NL> for i in range ( l , r + 1 ) : <NEWLINE> <INDENT> ans . append ( str ( i ) ) <NEWLINE> <NL> <DEDENT> ans = <STRING> . join ( ans ) <NEWLINE> <NL> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = [ <STRING> . join ( sorted ( list ( input ( ) ) ) ) for _ in range ( n ) ] <NEWLINE> s . sort ( ) <NEWLINE> cnt = 0 <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> if s [ i ] == s [ i + 1 ] : <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> print ( cnt ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> arr = [ ] <NEWLINE> from collections import Counter <NEWLINE> c = Counter ( [ ] ) <NEWLINE> for _ in range n : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> z = [ item for item in s ] <NEWLINE> z . sort ( ) <NEWLINE> z = tuple ( z ) <NEWLINE> c [ z ] += 1 <NEWLINE> <DEDENT> ans = 0 <NEWLINE> for item in c . values ( ) : <NEWLINE> <INDENT> ans += ( item * ( item - 1 ) ) // 2 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
from sys import stdin <NEWLINE> import copy <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> S = [ stdin . readline ( ) [ : - 1 ] for i in [ 0 ] * ( n - 1 ) ] <NEWLINE> S . append ( stdin . readline ( ) ) <NEWLINE> s = [ ] <NEWLINE> for i in S : <NEWLINE> <INDENT> s . append ( <STRING> . join ( sorted ( i ) ) ) <NEWLINE> <DEDENT> s . sort ( ) <NEWLINE> arr = [ ] <NEWLINE> temp = 1 <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> if temp > 1 and s [ i ] != s [ i + 1 ] : <NEWLINE> <INDENT> arr . append ( temp ) <NEWLINE> temp = 1 <NEWLINE> <DEDENT> if s [ i ] == s [ i + 1 ] : <NEWLINE> <INDENT> temp += 1 <NEWLINE> <DEDENT> <DEDENT> if temp > 1 : <NEWLINE> <INDENT> arr . append ( temp ) <NEWLINE> <DEDENT> arr . sort ( ) <NEWLINE> factorial = [ 1 ] <NEWLINE> for i in range ( arr [ - 1 ] + 1 ) : <NEWLINE> <INDENT> factorial . append ( factorial [ i ] * ( i + 1 ) ) <NEWLINE> <DEDENT> comb = [ 0 , 0 ] <NEWLINE> for i in range ( 2 , arr [ - 1 ] + 1 ) : <NEWLINE> <INDENT> comb . append ( factorial [ i ] / ( 2 * factorial [ i - 2 ] ) ) <NEWLINE> <DEDENT> ans = 0 <NEWLINE> for i in arr : <NEWLINE> <INDENT> ans += comb [ i ] <NEWLINE> <DEDENT> print ( int ( ans ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = { } <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> tmp = list ( input ( ) . strip ( ) ) . sort ( ) <NEWLINE> tmp = <STRING> . join ( tmp ) <NEWLINE> s [ tmp ] = s . get ( tmp , 0 ) + 1 <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for key in s . keys ( ) : <NEWLINE> <INDENT> v = s [ key ] <NEWLINE> if v < 2 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> cmb = v * ( v - 1 ) <NEWLINE> cmb = cmb // 2 <NEWLINE> ans += cmb <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
from collections import Counter <NEWLINE> from math import factorial <NEWLINE> n = int ( input ( ) ) <NEWLINE> s = [ <STRING> . join ( sorted ( list ( input ( ) ) ) ) for _ in range ( n ) ] <NEWLINE> <NL> def combination ( i ) : <NEWLINE> <INDENT> return factorial ( i ) // ( factorial ( i - 2 ) * factorial ( 2 ) ) <NEWLINE> <NL> <DEDENT> cnt = Counter ( s ) <NEWLINE> print ( cnt ) <NEWLINE> ans = 0 <NEWLINE> for i in cnt . values ( ) : <NEWLINE> <INDENT> print ( i ) <NEWLINE> ans += combination ( i ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
from heapq import * <NEWLINE> ( N , M ) , * t = [ map ( int , s . split ( ) ) for s in open ( 0 ) ] <NEWLINE> q , z = [ ] , 0 <NEWLINE> v = [ q for _ in [ None ] * 10 ** 5 ] <NEWLINE> for a , b in t : <NEWLINE> <INDENT> v [ a - 1 ] += b , <NEWLINE> <DEDENT> for i in v [ : M ] : <NEWLINE> <INDENT> for j in i : <NEWLINE> <INDENT> heappush ( q , - j ) <NEWLINE> <DEDENT> if q : <NEWLINE> <INDENT> z += - heappop ( q ) <NEWLINE> <DEDENT> <DEDENT> print ( z ) <NEWLINE>
<COMMENT> <NL> def input2 ( ) : <NEWLINE> <INDENT> return map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <DEDENT> n , m = input2 ( ) <NEWLINE> AB = [ [ ] for _ in range ( m ) ] <NEWLINE> <NL> <NL> for i in range ( n ) : <NEWLINE> <INDENT> a , b = input2 ( ) <NEWLINE> if a - 1 < m : <COMMENT> <NEWLINE> <INDENT> AB [ a - 1 ] . append ( - b ) <COMMENT> <NEWLINE> <NL> <DEDENT> <DEDENT> ans = 0 <NEWLINE> heap = [ ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> for b in AB [ i ] : <NEWLINE> <INDENT> heapq . heappush ( heap , b ) <NEWLINE> <COMMENT> <NL> <DEDENT> if len ( heap ) > 0 : <NEWLINE> <INDENT> MAX = heapq . heappop ( heap ) <NEWLINE> ans += - MAX <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
mport heapq <NEWLINE> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> list = [ [ ] for i in range ( m ) ] <NEWLINE> h = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if a <= m : <NEWLINE> <INDENT> list [ a - 1 ] . append ( - b ) <NEWLINE> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> for j in list [ i ] : <NEWLINE> <INDENT> heapq . heappush ( h , j ) <NEWLINE> <DEDENT> if h : <NEWLINE> <INDENT> ans += - heapq . heappop ( h ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from heapq import * <NEWLINE> ( N , M ) , * t = [ map ( int , s . split ( ) ) for s in open ( 0 ) ] <NEWLINE> q , z = [ ] , 0 <NEWLINE> v = [ q for _ in [ 0 ] * 10 ** 5 ] <NEWLINE> for a , b in t : <NEWLINE> <INDENT> v [ a - 1 ] += b , <NEWLINE> <DEDENT> for i in v [ : M ] : <NEWLINE> <INDENT> for j in i : <NEWLINE> <INDENT> heappush ( q , - j ) <NEWLINE> <DEDENT> z += - heappop ( q ) <NEWLINE> <DEDENT> print ( z ) <NEWLINE>
a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> water = c - ( a - b ) <NEWLINE> print ( water if water > 0 else 0 <NEWLINE>
a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( max ( c - ( a - b ) ) , 0 ) <NEWLINE>
a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( max ( 0 , c - ( a - b ) ) <NEWLINE>
a , b , c = map ( int , input ( ) . split ) <NEWLINE> print ( max ( 0 , c - a + b ) ) <NEWLINE>
import sys <NEWLINE> A , B , C = map ( int , input ( ) . split ( ) ) <NEWLINE> if not ( 1 <= B <= 20 and B <= A <= 20 ) : sys . exit ( ) <NEWLINE> if not ( 1 <= C <= 20 ) : sys . exit ( ) <NEWLINE> <NL> res = C - ( A - B ) <NEWLINE> print ( res ) if res >= 0 else : print ( 0 ) <NEWLINE>
A = int ( input ( <STRING> ) ) <NEWLINE> B = int ( input ( <STRING> ) ) <NEWLINE> C = int ( input ( <STRING> ) ) <NEWLINE> <NL> if A >= B + C : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ( B + C ) - A ) <NEWLINE> <DEDENT>
<NL> <NL> <INDENT> a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( max ( 0 , c - max ( 0 , a - b ) ) ) <NEWLINE> <DEDENT>
A , B , C = map ( int , input ( ) . split ( ) ) <NEWLINE> if C - A + B > 0 : <NEWLINE> <INDENT> print ( C = A + B ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT>
A , B , C = map ( int , sinput ( ) . split ( ) ) <NEWLINE> if ( C >= A - B ) : <NEWLINE> <INDENT> print ( C - ( A - B ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT>
a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( max ( c - a - b ) , 0 ) <NEWLINE>
list ( a , b , c ) = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> print ( max ( c - ( a - b ) , 0 ) ) <NEWLINE>
a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> print ( mak ( 0 , c - ( a - b ) ) ) <NEWLINE>
a , b , cmap ( int , input ( ) . split ( ) ) <NEWLINE> if a - b >= c : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( c - a + b ) <NEWLINE> <DEDENT>
a = list ( map ( int . input ( ) . split ( ) ) ) <NEWLINE> print ( max ( 0 , a [ 2 ] - ( a [ 0 ] - a [ 1 ] ) ) ) <NEWLINE>
a , b , c = int ( input ( ) . split ( ) ) <NEWLINE> <NL> if ( a - b ) <= c : <NEWLINE> <INDENT> print ( str ( c - ( a - b ) ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
<COMMENT> <NL> print ( max ( - 1 * int ( input ( ) ) + int ( input ( ) ) + int ( input ( ) ) , 0 ) ) <NEWLINE>
a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> q = a - b <NEWLINE> ans = c - ans <NEWLINE> <NL> if ans < 0 : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
a , b , c = map ( int , input ( ) split ( ) ) <NEWLINE> ans = c - ( a - b ) <NEWLINE> if ( ans < 0 ) : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if len ( i ) % 2 == 1 : <NEWLINE> <INDENT> ans = ans + 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> l = [ ] <NEWLINE> <NL> if N % 2 == 0 : <NEWLINE> <INDENT> for i in range ( 0 , N + 1 , 2 ) : <NEWLINE> <INDENT> n = len ( str ( i ) ) <NEWLINE> if n % 2 == 1 : <NEWLINE> <INDENT> l . append ( n ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( len ( l ) ) <NEWLINE> <NL> Else : <NEWLINE> <INDENT> for j in range ( 1 , N + 1 , 2 ) : <NEWLINE> <INDENT> n = len ( str ( i ) ) <NEWLINE> if n % 2 == 1 : <NEWLINE> <INDENT> l . append ( n ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( len ( l ) ) <NEWLINE> <NL> <NL> <NL>
n = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if ( len ( i ) % 2 ) != 0 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = input ( ) <NEWLINE> <NL> count = 0 <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> if len ( str ( i ) ) % 2 != 0 : <NEWLINE> <INDENT> count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( count ) <NEWLINE> <NL>
N = input ( ) <NEWLINE> <NL> cnt = 0 <NEWLINE> <NL> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> if len ( str ( i ) ) % 2 != 0 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
for i in range ( 1 , int ( input ( ) ) + 1 ) : <NEWLINE> <INDENT> if len ( str ( i ) ) % 2 == 1 : <NEWLINE> <INDENT> print ( len [ i ] ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> <NL> r = 0 <NEWLINE> <NL> for i in range ( 1 , n + 1 ) <NEWLINE> <INDENT> if len ( str ( i ) ) % 2 == 1 : <NEWLINE> <INDENT> r += 1 <NEWLINE> <DEDENT> <DEDENT> print ( r ) <NEWLINE>
a = int ( input ( ) ) <NEWLINE> for i in range ( 1 , a + 1 ) : <NEWLINE> <INDENT> if len ( str ( i ) ) % 2 == 1 : ans += 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> res = 0 <NEWLINE> for i in range ( n + 1 ) : <NEWLINE> <INDENT> if str ( i ) % 2 == 1 : <NEWLINE> <INDENT> res += 1 <NEWLINE> <DEDENT> <DEDENT> print ( res0 <NEWLINE>
n = int ( input ( ) ) <NEWLINE> if len ( n ) == 1 : <NEWLINE> <INDENT> print ( n ) <NEWLINE> <DEDENT> elif len ( n ) == 2 : <NEWLINE> <INDENT> print ( 9 ) <NEWLINE> <DEDENT> elif len ( n ) == 3 : <NEWLINE> <INDENT> print ( n - 90 ) <NEWLINE> <DEDENT> elif len ( n ) == 4 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif len ( n ) == 5 : <NEWLINE> <INDENT> print ( n - 9090 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import sys <COMMENT> <NEWLINE> import os <COMMENT> <NEWLINE> import math <NEWLINE> <NL> N = input ( ) <NEWLINE> count = 0 <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if i < 10 : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> elif i < 1000 : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> elif i < 100000 : <NEWLINE> <INDENT> count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( count ) <NEWLINE> input ( ) <NEWLINE> <NL>
n = input ( ) <NEWLINE> count = 0 <NEWLINE> for i in range ( n + 1 ) : <NEWLINE> <INDENT> if len ( i ) % 2 == 1 : <NEWLINE> <INDENT> count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for n in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> if len ( str ( n ) ) % 2 == 1 : <NEWLINE> ans += 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
ans = 0 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if len ( str ( i ) ) % 2 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> N = input ( ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , int ( N + 1 ) ) : <NEWLINE> <INDENT> if len ( str ( i ) ) % 2 != 0 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = <STRING> <NEWLINE> for i in range ( N - 1 , 0 , - 1 ) : <NEWLINE> <INDENT> if A [ i ] > A [ i - 1 ] : A [ i - 1 ] -= 1 <NEWLINE> <INDENT> if A [ i ] > A [ i - 1 ] : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> H = list ( map ( int , input ( ) ) ) <NEWLINE> p , a = True , 0 <NEWLINE> for h in H : <NEWLINE> <INDENT> if h > a : <NEWLINE> <INDENT> a = h - 1 <NEWLINE> <DEDENT> elif a > h : <NEWLINE> <INDENT> p = False <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> if p else <STRING> ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> judge = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if a [ i ] < judge : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> judge = max ( judge , a [ i ] - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import bisect , collections , copy , heapq , itertools , math , string <NEWLINE> from collections import defaultdict as D <NEWLINE> from functools import reduce <NEWLINE> import numpy as np <NEWLINE> import sys <NEWLINE> import os <NEWLINE> from operator import mul <NEWLINE> <NL> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> <NL> def _S ( ) : return sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> def I ( ) : return int ( _S ( ) ) <NEWLINE> def LS ( ) : return list ( _S ( ) . split ( ) ) <NEWLINE> def LI ( ) : return list ( map ( int , LS ( ) ) ) <NEWLINE> <NL> if os . getenv ( <STRING> ) : <NEWLINE> <INDENT> inputFile = basename_without_ext = os . path . splitext ( os . path . basename ( __file__ ) ) [ 0 ] + <STRING> <NEWLINE> sys . stdin = open ( inputFile , <STRING> ) <NEWLINE> <DEDENT> INF = float ( <STRING> ) <NEWLINE> IINF = 10 ** 18 <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> <COMMENT> <NL> <NL> N = I ( ) <NEWLINE> H = LI ( ) <NEWLINE> <NL> <COMMENT> <NL> <NL> if N == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> ans = True <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> if H [ i ] <= H [ i + 1 ] : <NEWLINE> <COMMENT> <NL> <INDENT> continue <NEWLINE> <DEDENT> elif ( not i == 0 ) and H [ i ] - 1 == H [ i + 1 ] : <NEWLINE> <INDENT> if not H [ i - 1 ] == H [ i ] : <NEWLINE> <INDENT> H [ i ] -= 1 <NEWLINE> <COMMENT> <NL> continue <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> ans = False <NEWLINE> break <NEWLINE> <NL> <DEDENT> if ans : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> H = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> p1 = p2 = 0 <NEWLINE> for i in H : <NEWLINE> <INDENT> print ( prv , i , i < prv - 1 , prv <= i , prv - 1 <= i ) <NEWLINE> if i < max ( p2 , p1 - 1 ) : <NEWLINE> <COMMENT> <NL> <INDENT> break <NEWLINE> <DEDENT> if i < p1 : <NEWLINE> <INDENT> p2 = p1 - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> p2 = p1 <NEWLINE> <DEDENT> p1 = i <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import sys <NEWLINE> n = int ( input ( ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if h [ 0 ] > 0 : <NEWLINE> <INDENT> h [ 0 ] -= 1 <NEWLINE> <DEDENT> for i in range ( 1 , n ) : <NEWLINE> <INDENT> if h [ i - 1 ] == h [ i ] : <NEWLINE> <INDENT> sonomama = 1 <NEWLINE> <DEDENT> elif h [ i ] > [ i - 1 ] : <NEWLINE> <INDENT> h [ i ] -= 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> sys . exit ( ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> H = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = True <NEWLINE> lis = { } <NEWLINE> for i in H : <NEWLINE> <INDENT> if i in lis : <NEWLINE> <INDENT> lis [ i ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> lis [ i ] = 1 <NEWLINE> <DEDENT> <DEDENT> mine = min ( H ) <NEWLINE> times = lis [ mine ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if mine < H [ i ] - 1 : <NEWLINE> <INDENT> ans = False <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if H [ i ] == mine : <NEWLINE> <INDENT> times -= 1 <NEWLINE> <DEDENT> if times == 0 and i != N - 1 : <NEWLINE> <INDENT> del lis [ mine ] <NEWLINE> lis = sorted ( lis ) <NEWLINE> mine = next ( iter ( lis ) ) <NEWLINE> times = lis [ next ( iter ( lis ) ) ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if ans : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> L = list ( int ( input ( ) ) for _ in range ( N ) ) <NEWLINE> M = L [ : : - 1 ] <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> if M [ i ] + 1 < M [ i + 1 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> elif M [ i ] + 1 == M [ i + 1 ] : <NEWLINE> <INDENT> M [ i + 1 ] = M [ i ] <NEWLINE> <DEDENT> <DEDENT> else : print ( <STRING> ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> H = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if N == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( N - 1 ) : <NEWLINE> <INDENT> if H [ N - i - 2 ] >= H [ N - i - 1 ] + 2 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> elif H [ N - i - 2 ] == H [ N - i - 1 ] + 1 : <NEWLINE> <INDENT> H [ [ N - i - 2 ] -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> for j in range ( N - 1 ) : <NEWLINE> <INDENT> if H [ i ] > H [ i + 1 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
<COMMENT> <NL> n = int ( input ( ) ) <NEWLINE> h = reversed ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> cnt = 0 <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> if h [ i + 1 ] - h [ i ] > 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( 0 ) <NEWLINE> <DEDENT> elif h [ i + 1 ] - h [ i ] == 1 : <NEWLINE> <INDENT> h [ i + 1 ] -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> from fractions import gcd <NEWLINE> from itertools import combinations , permutations , accumulate <COMMENT> <NEWLINE> <COMMENT> <NL> from collections import deque , defaultdict , Counter <NEWLINE> import decimal <NEWLINE> import re <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> import sys <NEWLINE> sys . setrecursionlimit ( 10000000 ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <COMMENT> <NL> def readInts ( ) : <NEWLINE> <INDENT> return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <DEDENT> def I ( ) : <NEWLINE> <INDENT> return int ( input ( ) ) <NEWLINE> <DEDENT> n = I ( ) <NEWLINE> H = readInts ( ) <NEWLINE> ma = H [ 0 ] <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> if ma < H [ i ] : <NEWLINE> <INDENT> A [ i ] -= 1 <NEWLINE> <DEDENT> if ma <= H [ i ] : <NEWLINE> <INDENT> ma = H [ i ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in range ( 1 , n - 1 ) : <NEWLINE> <INDENT> if h [ i - 1 ] <= h [ i ] <= h [ i + 1 ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if h [ i ] > h [ i + 1 ] : <NEWLINE> <INDENT> h [ i ] -= 1 <NEWLINE> if h [ i ] < h [ i - 1 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for i in range ( 1 , n - 1 ) : <NEWLINE> <INDENT> if not h [ i - 1 ] = < h [ i ] <= h [ i + 1 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
S = input ( ) <NEWLINE> <NL> counter = [ ] <NEWLINE> cnt_dict = { <STRING> : 0 , <STRING> : 0 } <NEWLINE> for i in range ( len ( S ) ) : <NEWLINE> <INDENT> l = S [ i ] <NEWLINE> if l == <STRING> : <NEWLINE> <INDENT> if cnt_dict [ <STRING> ] == 0 : <NEWLINE> <INDENT> cnt_dict [ l ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> counter . append ( cnt_dict ) <NEWLINE> cnt_dict = { <STRING> : 0 , <STRING> : 0 } <NEWLINE> cnt_dict [ l ] += 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> cnt_dict [ l ] += 1 <NEWLINE> <DEDENT> <DEDENT> counter . append ( cnt_dict ) <NEWLINE> <NL> output = [ ] <NEWLINE> for c in counter : <NEWLINE> <INDENT> block_R = [ 0 for _ in range ( c [ <STRING> ] ) ] <NEWLINE> block_L = [ 0 for _ in range ( c [ <STRING> ] ) ] <NEWLINE> q , r = divmod ( ( c [ <STRING> ] + c [ <STRING> ] ) , 2 ) <NEWLINE> if r == 0 : <NEWLINE> <INDENT> block_R [ - 1 ] = q <NEWLINE> block_L [ 0 ] = q <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if c [ <STRING> ] % 2 == 0 : <NEWLINE> <INDENT> block_R [ - 1 ] = q <NEWLINE> blcok_L [ 0 ] = q + r <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> block_R [ - 1 ] = q + r <NEWLINE> block_L [ 0 ] = q <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> output += block_R <NEWLINE> output += block_L <NEWLINE> <NL> <DEDENT> print ( <STRING> . join ( map ( str , output ) ) ) <NEWLINE>
import sys <NEWLINE> from operator import itemgetter <NEWLINE> <NL> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> def ii ( ) : return int ( input ( ) ) <NEWLINE> def mi ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def lmi ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> def lmif ( n ) : return [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ] <NEWLINE> def ss ( ) : return input ( ) . split ( ) <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> children = [ 0 ] * len ( s ) <NEWLINE> s += <STRING> <NEWLINE> start = 0 <NEWLINE> now = 0 <NEWLINE> while now < len ( s ) - 1 : <NEWLINE> <INDENT> r = 0 <NEWLINE> l = 0 <NEWLINE> while s [ now ] == <STRING> : <NEWLINE> <INDENT> r += 1 <NEWLINE> now += 1 <NEWLINE> <DEDENT> er = now - 1 <NEWLINE> sl = now <NEWLINE> while s [ now ] == <STRING> : <NEWLINE> <INDENT> l += 1 <NEWLINE> now += 1 <NEWLINE> <DEDENT> count = now - start <NEWLINE> if count % 2 == 0 : <NEWLINE> <INDENT> children [ er ] = count // 2 <NEWLINE> children [ sl ] = count // 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if r % 2 == 1 : <NEWLINE> <INDENT> children [ er ] = count // 2 + 1 <NEWLINE> children [ sl ] = count // 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> children [ er ] = count // 2 <NEWLINE> children [ sl ] = count // 2 + 1 <NEWLINE> <DEDENT> <DEDENT> start = now <NEWLINE> <NL> <DEDENT> print ( * children ) <NEWLINE> <NL> return <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE>
l , r = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> s = [ ] <NEWLINE> if r - l > 2050 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( l , r + 1 ) : <NEWLINE> <INDENT> s . append ( i % 2019 ) <NEWLINE> <DEDENT> s . sort ( ) <NEWLINE> print ( s [ 0 ] * s [ 1 ] ) <NEWLINE> <NL> <DEDENT>
S = input ( ) <NEWLINE> N = len ( S ) <NEWLINE> ans = [ 0 ] * N <NEWLINE> i = 0 <NEWLINE> while i < N : <NEWLINE> <INDENT> count = 1 <NEWLINE> while S [ i + count ] == S [ i ] : <NEWLINE> <INDENT> count += 1 <NEWLINE> if count == N - 1 - i : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> if S [ i ] == <STRING> : <NEWLINE> <INDENT> ans [ i + count ] += ( count + 1 ) // 2 <NEWLINE> ans [ i + count - 1 ] += count // 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans [ i ] += ( count + 1 ) // 2 <NEWLINE> ans [ i - 1 ] += count // 2 <NEWLINE> <DEDENT> i += count <NEWLINE> <DEDENT> print ( * ans ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> if ( N + M ) % 2 == 0 : <NEWLINE> <INDENT> print ( ( N + M ) / 2 ) <NEWLINE> else : <NEWLINE> print ( <STRING> ) <NEWLINE> <DEDENT>
m , n = map ( int , input . split ( ) ) <NEWLINE> total = m + n <NEWLINE> if total % 2 == 0 : <NEWLINE> <INDENT> print ( total // 2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if ( a - b ) % 2 == 0 : <NEWLINE> <INDENT> print ( a - ( a - b // 2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
<NL> def Input ( ) : <NEWLINE> <INDENT> return mapt ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> a , b = Input ( ) <NEWLINE> if a % 2 != b % 2 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ( a + b ) // 2 ) <NEWLINE> <NL> <DEDENT> <DEDENT> main ( ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> s = a + b <NEWLINE> if s % 2 == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else ; <NEWLINE> print ( s // 2 ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> <NL> step = sum ( [ 90 * 100 ** i for i in range ( len ( str ( N ) ) // 2 ) ] ) <NEWLINE> dance_floor = sum ( [ 9 * 100 ** i for i in range ( len ( str ( N ) ) // 2 ) ] ) <NEWLINE> <NL> ans = len ( str ( N ) ) % 2 * ( N - step ) + - 1 * ( len ( str ( N ) ) % 2 - 1 ) * dance_floor <NEWLINE> print ( ans ) <NEWLINE>
ma = lambda : map ( int , input ( ) . split ( ) ) <NEWLINE> lma = lambda : list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> tma = lambda : tuple ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ni = lambda : int ( input ( ) ) <NEWLINE> yn = lambda fl : print ( <STRING> ) if fl else print ( <STRING> ) <NEWLINE> import collections <NEWLINE> import math <NEWLINE> import itertools <NEWLINE> import heapq as hq <NEWLINE> a , b = ma ( ) <NEWLINE> k2 = abs ( b - a ) <NEWLINE> if k % 2 == 1 : <NEWLINE> <INDENT> print ( k2 // 2 + min ( b , a ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
length = int ( input ( ) ) <NEWLINE> list_p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <COMMENT> <NL> count = 0 <NEWLINE> for i in range ( length ) : <NEWLINE> <INDENT> if list_p [ i ] != ( i + 1 ) : <NEWLINE> <INDENT> count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if count <= 2 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if ( a + b ) / 2. is_integer ( ) : <NEWLINE> <INDENT> print ( ( a + b ) // 2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b = map ( Int , input ( ) . split ( ) ) <NEWLINE> if ( a + b ) % 2 == 0 : <NEWLINE> <INDENT> print ( ( a + b ) // 2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> x = a + b <NEWLINE> if x % 2 == 0 : <NEWLINE> <INDENT> print ( s / 2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if ( a + b ) % 2 == 0 : <NEWLINE> <INDENT> print ( int ( ( a + b ) / 2 ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> <NEWLINE> <DEDENT>
A , B = map ( int ( input ( ) ) ) <NEWLINE> if ( A + B ) % 2 == 0 : <NEWLINE> <INDENT> print ( ( A + B ) // 2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
A , B = map ( int , input ( ) ) <NEWLINE> <NL> if ( A + B ) % 2 == 0 : print ( ( A + B ) // 2 ) <NEWLINE> else : print ( <STRING> ) <NEWLINE>
if ( A + B ) % 2 == 0 : <NEWLINE> <INDENT> print ( ( A + B ) // 2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> cnt = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if p [ i ] != ( i + 1 ) : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> if cnt == 0 or cnt == 2 else <STRING> ) <NEWLINE>
import sys , os , math , bisect , itertools , collections , heapq , queue <NEWLINE> <COMMENT> <NL> from decimal import Decimal <NEWLINE> from collections import defaultdict , deque <NEWLINE> <NL> <COMMENT> <NL> <NL> sys . setrecursionlimit ( 10000000 ) <NEWLINE> <NL> ii = lambda : int ( sys . stdin . buffer . readline ( ) . rstrip ( ) ) <NEWLINE> il = lambda : list ( map ( int , sys . stdin . buffer . readline ( ) . split ( ) ) ) <NEWLINE> fl = lambda : list ( map ( float , sys . stdin . buffer . readline ( ) . split ( ) ) ) <NEWLINE> iln = lambda n : [ int ( sys . stdin . buffer . readline ( ) . rstrip ( ) ) for _ in range ( n ) ] <NEWLINE> <NL> iss = lambda : sys . stdin . buffer . readline ( ) . decode ( ) . rstrip ( ) <NEWLINE> sl = lambda : list ( map ( str , sys . stdin . buffer . readline ( ) . decode ( ) . split ( ) ) ) <NEWLINE> isn = lambda n : [ sys . stdin . buffer . readline ( ) . decode ( ) . rstrip ( ) for _ in range ( n ) ] <NEWLINE> <NL> lcm = lambda x , y : ( x * y ) // math . gcd ( x , y ) <NEWLINE> <COMMENT> <NL> <NL> MOD = 10 ** 9 + 7 <NEWLINE> MAX = float ( <STRING> ) <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> if os . getenv ( <STRING> ) : <NEWLINE> <INDENT> sys . stdin = open ( <STRING> , <STRING> ) <NEWLINE> <NL> <DEDENT> N = ii ( ) <NEWLINE> P = il ( ) <NEWLINE> cnt = 0 <NEWLINE> for n in range ( N ) : <NEWLINE> <INDENT> if P [ n ] != n + 1 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> if P [ P [ n ] ] != n + 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> if cnt > 3 else <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
<NL> n = int ( input ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> new_p = p . sort ( ) <NEWLINE> cnt = 0 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> if p [ i ] != new_p [ i ] : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if cnt > 2 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> answer = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if p [ i ] + 1 != p [ i + 1 ] : <NEWLINE> <INDENT> answer += 1 <NEWLINE> <DEDENT> if answer <= 2 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = [ int ( i ) for in input ( ) . split ( ) ] <NEWLINE> t = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n ) : <NEWLINE> <INDENT> t += a [ i ] > a [ j ] <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> if t < 2 else <STRING> ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> P = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> cnt = 0 <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> if P [ i ] != i : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> if cnt == 2 else <STRING> ) <NEWLINE>
n = int ( intput ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = A . sorted ( ) <NEWLINE> dif = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if A [ i ] != B [ i ] : <NEWLINE> <INDENT> dif += 1 <NEWLINE> <DEDENT> <DEDENT> if dif == 0 or dif == 2 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = int ( input ) <NEWLINE> List = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> mid = - 1 <NEWLINE> flag = True <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if List [ i ] == i + 1 : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> flag = False <NEWLINE> if mid == - 1 : <NEWLINE> <INDENT> mid = List [ i ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if mid == List [ i ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if flag : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> S = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> Min_S = min ( S ) <NEWLINE> Min_idx = S . index ( Min_S ) <NEWLINE> <NL> <NL> S [ 0 ] , S [ Min_idx ] = S [ Min_idx ] , S [ 0 ] <NEWLINE> if S == Sort_S : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
def check ( n , list1 ) : <NEWLINE> <INDENT> new = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> new . append ( list1 [ i ] ) <NEWLINE> <NL> <DEDENT> new . sort ( ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> swaps = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if list1 [ i ] != new [ i ] : <NEWLINE> <INDENT> swaps += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if swaps == 0 or swaps == 2 : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return False <NEWLINE> <NL> <DEDENT> <DEDENT> n = int ( input ( ) ) <NEWLINE> numbers = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> numbers . append ( int ( input ( ) ) ) <NEWLINE> <NL> <DEDENT> if check ( n , numbers ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <NL> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> <COMMENT> <NL> <NL> <NL> ans = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> ans += min ( A [ i ] , B [ i ] ) <NEWLINE> B [ i ] = max ( B [ i ] - A [ i ] ) <NEWLINE> <NL> <NL> <COMMENT> <NL> <NL> <NL> <NL> <NL> <DEDENT>
<COMMENT> <NL> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> b = int ( input ( ) ) <NEWLINE> tmp = A [ i ] - b <NEWLINE> if tmp < 0 : <NEWLINE> <INDENT> ans += A [ i ] <NEWLINE> if A [ i + 1 ] < - tmp : <NEWLINE> <INDENT> ans += A [ i + 1 ] <NEWLINE> A [ i + 1 ] = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += - tmp <NEWLINE> A [ i + 1 ] += tmp <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> ans += b <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
def solv ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> x = A [ i ] + A [ i + 1 ] <NEWLINE> ans += min ( x , B [ i ] ) <NEWLINE> A [ i + 1 ] = min ( A [ i + 1 ] , max ( x - B [ i + 1 ] , 0 ) ) <NEWLINE> <DEDENT> return print ( ans ) <NEWLINE> <NL> <DEDENT> solv ( ) <NEWLINE>
<INDENT> = int ( input ( ) ) <NEWLINE> <DEDENT> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> if a [ i ] < b [ i ] : <NEWLINE> <INDENT> ab = b [ i ] - a [ i ] <NEWLINE> if a [ i + 1 ] > ab : <NEWLINE> <INDENT> ans += b [ i ] <NEWLINE> a [ i + 1 ] -= ab <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += a [ i ] + a [ i + 1 ] <NEWLINE> a [ i + 1 ] = 0 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> ans += b [ i ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> import math <NEWLINE> <NL> read = sys . stdin . read <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> <NL> sys . setrecursionlimit ( 10 ** 8 ) <NEWLINE> INF = float ( <STRING> ) <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> S = int ( input ( ) ) <NEWLINE> x1 = math . ceil ( S ** 0.5 ) <NEWLINE> x2 = X1 ** 2 - S <NEWLINE> print ( 0 , 0 , x1 , 1 , x2 , x1 ) <NEWLINE> <NL> <NL> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
r = input ( ) <NEWLINE> <NL> print ( 3 * r ** 2 ) <NEWLINE>
print ( a * int ( input ( ) ) ** 2 ) <NEWLINE>
print ( 3 * input ( ) * input ( ) ) <NEWLINE>
<COMMENT> <NL> print ( 3 * int ( input ) ** 2 ) <NEWLINE>
r = int ( input ( ) ) <NEWLINE> print ( 3 * a * a ) <NEWLINE>
r = int ( input ( ) ) <NEWLINE> print ( 3 r ** 2 ) <NEWLINE>
r = int ( input ( ) ) <NEWLINE> print ( 3 * a * a ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = [ int ( input ( ) ) for _ in range ( n ) ] <NEWLINE> b = max ( a ) <NEWLINE> c = a . index ( b ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if i == c : <NEWLINE> <INDENT> print ( max ( sorted ( a ) [ : n - 1 ] ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( b ) <NEWLINE> <DEDENT> <DEDENT>
r = int ( input ( ) ) <NEWLINE> print ( int ( 3 * r ** ) ) <NEWLINE>
print ( 3 * a ** 2 ) <NEWLINE>
r = input ( ) <NEWLINE> print ( 3 * r ** 2 ) <NEWLINE>
from math import ceil <NEWLINE> <NL> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> print ( math . ceil ( a // ( 2 * b + 1 ) ) ) <NEWLINE>
a , b = list ( map ( int , input ( ) ) ) <NEWLINE> print ( ( a - 1 ) / ( 2 * b + 1 ) / 1 ) <NEWLINE>
n , d = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( n // ( 2 d + 1 ) + 1 ) <NEWLINE>
n , d = map ( int , inpit ( ) . split ( ) ) <NEWLINE> x = 2 * d + 1 <NEWLINE> print ( ( d + x - 1 ) // x ) <NEWLINE>
n , d = map ( int , input ( ) . split ( ) ) <NEWLINE> p = n / ( 2 d + 1 ) <NEWLINE> if p % 1 == 0 : <NEWLINE> <INDENT> print ( p ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ( p // 1 ) + 1 ) <NEWLINE> <DEDENT>
N , D = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> print ( - ( - N // ( 2 D + 1 ) ) ) <NEWLINE>
n , d = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( math . ceil ( n / ( 2 * d + 1 ) ) ) <NEWLINE>
import math <NEWLINE> n , d = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( math . ceil ( n / ( s * 2 + 1 ) ) ) <NEWLINE>
N , D = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( math . ceil ( N / ( 2 * D + 1 ) ) ) <NEWLINE>
import math <NEWLINE> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( math . ceil ( a / ( 2 b + 1 ) ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = [ int ( input ( ) ) for _ in range ( N ) ] <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> M = max ( A ) <NEWLINE> sub_M = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if i not in M_list : <NEWLINE> <INDENT> sub_M = max ( sub_M , A [ i ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> M_list = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if A [ i ] == M : M_list . append ( i ) <NEWLINE> <NL> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> if i in M_list : print ( sub_M ) <NEWLINE> else : print ( M ) <NEWLINE> <DEDENT>
sn = int ( input ( ) ) <NEWLINE> arr = [ int ( input ( ) ) for _ in range ( n ) ] <NEWLINE> arr . sort ( ) <NEWLINE> mx = arr [ - 1 ] <NEWLINE> sc = arr [ - 2 ] <NEWLINE> <NL> for ele in arr : <NEWLINE> <INDENT> if ele == mx : <NEWLINE> <INDENT> print ( sc ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( mx ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = [ int ( input ( ) ) for i in range ( n ) ] <NEWLINE> sa = a . sort ( ) <NEWLINE> am , asl = sa [ - 1 ] , sa [ - 2 ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> print ( asl if a [ i ] == am else am ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = [ int ( input ( ) ) for _ in range ( n ) ] <NEWLINE> <NL> b = sorted ( a ) <NEWLINE> <NL> for i in a : <NEWLINE> <INDENT> if i = b [ - 1 ] : <NEWLINE> <INDENT> print ( b [ - 2 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( b [ - 1 ] ) <NEWLINE> <DEDENT> <DEDENT>
a_l = [ int ( input ( ) ) for _ in range ( n ) ] <NEWLINE> <NL> l = [ ] <NEWLINE> r = [ ] <NEWLINE> l_max = 0 <NEWLINE> r_max = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> l_max = max ( l_max , a_l [ i ] ) <NEWLINE> r_max = max ( r_max , a_l [ - i - 1 ] ) <NEWLINE> l . append ( l_max ) <NEWLINE> r . append ( r_max ) <NEWLINE> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> t_l = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> t_l = l [ i - 1 ] <NEWLINE> <DEDENT> if i == n - 1 : <NEWLINE> <INDENT> t_r = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> t_r = r [ - i - 2 ] <NEWLINE> <DEDENT> print ( max ( [ t_l , t_r ] ) ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = [ int ( input ( ) ) for _ in range ( n ) ] <NEWLINE> b = max ( l ) <NEWLINE> c = a . index ( b ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if i == c : <NEWLINE> <INDENT> print ( max ( sorted ( a ) [ : n - 1 ] ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( b ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = [ int ( input ( ) ) for i in range ( n ) ] <NEWLINE> q = set ( sorted ( a ) ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> if a [ i ] != q [ - 1 ] : <NEWLINE> <INDENT> print ( q [ - 1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( q [ - 2 ] ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> <NL> max_1 = 0 <NEWLINE> max_2 = 0 <NEWLINE> max_index = 0 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> item = int ( input ( ) ) <NEWLINE> <INDENT> if item >= max_1 : <NEWLINE> <INDENT> max_1 , max_2 = item , max_1 <NEWLINE> max_index = i <NEWLINE> <DEDENT> elif item > max_2 : <NEWLINE> <INDENT> max_2 = item <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> ans = max_2 if i == max_index else max_1 <NEWLINE> print ( ans ) <NEWLINE> <NL> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = [ int ( input ( ) ) for _ in range ( N ) ] <NEWLINE> <NL> m1 , m2 = sorted ( A , reversed = True ) [ 0 : 2 ] <NEWLINE> for a in A : <NEWLINE> <INDENT> print ( m2 if a == m1 else m1 ) <NEWLINE> <DEDENT>
N , D = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> print ( ( N + 2 * D ) // ( 2 * D + 1 ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = [ ] <NEWLINE> b = sorted ( a ) <NEWLINE> mx = b [ - 1 ] <NEWLINE> mx2 = b [ - 2 ] <NEWLINE> for i in a : <NEWLINE> <INDENT> if i == mx : <NEWLINE> <INDENT> print ( mx2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( mx ) <NEWLINE> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> l = [ ] <NEWLINE> l . append ( int ( input ( ) ) ) <NEWLINE> l . append ( int ( input ( ) ) ) <NEWLINE> m1 = max ( l ) <NEWLINE> mx = min ( l ) <NEWLINE> for _ in range ( N - 2 ) : <NEWLINE> <INDENT> l . append ( int ( input ( ) ) ) <NEWLINE> if l [ - 1 ] >= m1 : <NEWLINE> <INDENT> m2 = m1 <NEWLINE> m1 = l [ - 1 ] <NEWLINE> <DEDENT> elif l [ - 1 ] > m2 : <NEWLINE> <INDENT> m2 = l [ - 1 ] <NEWLINE> <DEDENT> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> if l [ i ] == m1 : <NEWLINE> <INDENT> print ( m2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( m1 ) <NEWLINE> <DEDENT> <DEDENT>
a = [ int ( input ( ) ) for i in range ( n ) ] <NEWLINE> m = max ( a ) <NEWLINE> p = a . index ( m ) <NEWLINE> s = max ( a ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if i != p : <NEWLINE> <INDENT> print ( m ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( s ) <NEWLINE> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> box = [ 0 ] * N <NEWLINE> for i in range ( N , 0 , - 1 ) : <NEWLINE> <INDENT> sm = 0 <NEWLINE> for j in range ( i , N + 1 , i ) : <NEWLINE> <INDENT> sm += box [ j - 1 ] <NEWLINE> <DEDENT> print ( i , sm ) <NEWLINE> box [ i - 1 ] = ( sm % 2 ) ^ a [ i - 1 ] <NEWLINE> <DEDENT> print ( sum ( box ) ) <NEWLINE> print ( * sum ) <NEWLINE>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> import numpy as np <NEWLINE> from numba import njit <NEWLINE> <NL> <NL> def read ( ) : <NEWLINE> <INDENT> N = int ( input ( ) . strip ( ) ) <NEWLINE> A = [ int ( input ( ) . strip ( ) ) for _ in range ( N ) ] <NEWLINE> return N , A <NEWLINE> <NL> <NL> <DEDENT> @ njit <NEWLINE> def segtree_init ( size , init_value = 10 ** 8 , dtype = np . int32 ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> n = 1 <NEWLINE> while size > 1 : <NEWLINE> <INDENT> size >>= 1 <NEWLINE> n += 1 <NEWLINE> <DEDENT> treesize = n * 2 <NEWLINE> st = np . full ( treesize , init_value , dtype = dtype ) <NEWLINE> st_idx = np . arange ( treesize , dtype = dtype ) <NEWLINE> offset = st . shape [ 0 ] // 2 <NEWLINE> return st , st_idx , offset <NEWLINE> <NL> <DEDENT> @ njit <NEWLINE> def segtree_update ( st , st_idx , offset , key , value , init_value = 10 ** 8 ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> k = offset + key <NEWLINE> st [ k ] = value <NEWLINE> k >>= 1 <NEWLINE> while k > 0 : <NEWLINE> <INDENT> if st [ k * 2 ] <= st [ k * 2 + 1 ] : <NEWLINE> <INDENT> st [ k ] = st [ k * 2 ] <NEWLINE> st_idx [ k ] = st_idx [ k * 2 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> st [ k ] = st [ k * 2 + 1 ] <NEWLINE> st_idx [ k ] = st_idx [ k * 2 + 1 ] <NEWLINE> <DEDENT> k >>= 1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> @ njit <NEWLINE> def _segtree_find_le ( st , st_idx , offset , value , k = 1 , init_value = 10 ** 8 ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if value < st [ k ] : <NEWLINE> <INDENT> return ( st . shape [ 0 ] , - init_value ) <NEWLINE> <DEDENT> elif value == st [ k ] or k >= offset : <NEWLINE> <INDENT> return ( st_idx [ k ] , st [ k ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> li , lv = _segtree_find_le ( st , st_idx , offset , value , k * 2 , init_value = init_value ) <NEWLINE> ri , rv = _segtree_find_le ( st , st_idx , offset , value , k * 2 + 1 , init_value = init_value ) <NEWLINE> mi = li if lv >= rv else ri <NEWLINE> mv = lv if lv >= rv else rv <NEWLINE> if mi < st . shape [ 0 ] : <NEWLINE> <INDENT> return ( mi , mv ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return ( st . shape [ 0 ] , - init_value ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> @ njit <NEWLINE> def segtree_find_le ( st , st_idx , offset , value , init_value = 10 ** 8 ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> i , v = _segtree_find_le ( st , st_idx , offset , value , k = 1 , init_value = init_value ) <NEWLINE> if i == st . shape [ 0 ] : <NEWLINE> <INDENT> return ( - 1 , init_value ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return ( i - offset , v ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def solve ( N , A , INF = 10 ** 9 + 1 ) : <NEWLINE> <INDENT> st , st_idx , offset = segtree_init ( N ) <NEWLINE> l = 0 <NEWLINE> for a in A [ : : - 1 ] : <NEWLINE> <INDENT> k , v = segtree_find_le ( st , st_idx , offset , - a - 1 ) <COMMENT> <NEWLINE> if k == - 1 : <NEWLINE> <INDENT> segtree_update ( st , st_idx , offset , l , - a ) <NEWLINE> l += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> segtree_update ( st , st_idx , offset , k , - a ) <NEWLINE> <DEDENT> <DEDENT> return l <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> inputs = read ( ) <NEWLINE> outputs = solve ( * inputs ) <NEWLINE> if outputs is not None : <NEWLINE> <INDENT> print ( <STRING> % str ( outputs ) ) <NEWLINE> <DEDENT> <DEDENT>
from collections import Counter <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> cnt = Counter ( a ) <NEWLINE> if set ( a ) == set ( 0 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> if n % 3 != 0 or len ( cnt ) != 3 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> key = [ ] <NEWLINE> num = [ ] <NEWLINE> for i , j in cnt . items ( ) : <NEWLINE> <INDENT> key . append ( i ) <NEWLINE> num . append ( j ) <NEWLINE> <DEDENT> if len ( set ( num ) ) != 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if key [ 0 ] ^ key [ 1 ] == key [ 2 ] : print ( <STRING> ) <NEWLINE> else : print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
from collections import Counter <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> <NL> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c = Counter ( A ) <NEWLINE> a = list ( set ( A ) ) <NEWLINE> <NL> <NL> if len ( a ) >= 4 : <NEWLINE> <INDENT> ans = False <NEWLINE> <NL> <DEDENT> elif len ( a ) == 3 : <NEWLINE> <INDENT> a , b , d = a <NEWLINE> if c [ a ] == c [ b ] == c [ d ] and a ^ b = c and c ^ b == a and a ^ c == b : <NEWLINE> <INDENT> ans = True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = False <NEWLINE> <NL> <DEDENT> <DEDENT> elif len ( a ) == 2 : <NEWLINE> <INDENT> a , b = sorted ( a ) <NEWLINE> if a == 0 and c [ a ] == N / 3 and c [ b ] == ( N / 3 ) * 2 : <NEWLINE> <INDENT> ans = True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = False <NEWLINE> <NL> <DEDENT> <DEDENT> elif len ( a ) == 1 : <NEWLINE> <INDENT> if sum ( a ) == 0 : <NEWLINE> <INDENT> ans = True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = False <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> if ans else <STRING> ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> from fractions import gcd <NEWLINE> from itertools import combinations , permutations , accumulate , product <COMMENT> <NEWLINE> <COMMENT> <NL> from collections import deque , defaultdict , Counter <NEWLINE> import decimal <NEWLINE> import re <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> import sys <NEWLINE> sys . setrecursionlimit ( 10000000 ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> mod = 998244353 <NEWLINE> def readInts ( ) : <NEWLINE> <INDENT> return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <DEDENT> def I ( ) : <NEWLINE> <INDENT> return int ( input ( ) ) <NEWLINE> <DEDENT> n = I ( ) <NEWLINE> li = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> se = set ( li ) <NEWLINE> if len ( se ) == 1 : <NEWLINE> <INDENT> if sum ( se ) == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> priont ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> elif len ( se ) == 2 : <NEWLINE> <INDENT> a , b = sorted ( se ) <NEWLINE> if a == 0 : <NEWLINE> <INDENT> if li . count ( a ) * 3 == n : <NEWLINE> <INDENT> print ( <STRING> ) <COMMENT> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> elif len ( se ) == 3 : <NEWLINE> <INDENT> a , b , c = se <NEWLINE> if li . count ( a ) == li . count ( b ) == li . count ( c ) : <NEWLINE> <INDENT> if a ^ b == c : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <COMMENT> <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> n = N // 3 <NEWLINE> dic = { } <NEWLINE> <NL> for a in A : <NEWLINE> <INDENT> if a in dic : <NEWLINE> <INDENT> dic [ a ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dic [ a ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> ans = True <NEWLINE> <NL> if len ( dic ) > 3 : <NEWLINE> <INDENT> ans = False <NEWLINE> <NL> <DEDENT> elif len ( dic ) == 3 : <NEWLINE> <INDENT> keys = dic . keys ( ) <NEWLINE> for k in keys : <NEWLINE> <INDENT> if dic [ k ] != n : <NEWLINE> <INDENT> ans = False <NEWLINE> <NL> <DEDENT> <DEDENT> if ( keys [ 0 ] ^ keys [ 1 ] ) != keys [ 2 ] : <NEWLINE> <INDENT> ans = False <NEWLINE> <NL> <DEDENT> <DEDENT> elif len ( dic ) == 2 : <NEWLINE> <INDENT> for k in dic : <NEWLINE> <INDENT> if k == 0 : <NEWLINE> <INDENT> if dic [ k ] != n : <NEWLINE> <INDENT> ans = False <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if dic [ k ] != n * 2 : <NEWLINE> <INDENT> ans = False <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> keys = dic . keys ( ) <NEWLINE> if not 0 in keys : <NEWLINE> <INDENT> ans = False <NEWLINE> <NL> <DEDENT> <DEDENT> if ans : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> u = list ( set ( l ) ) <NEWLINE> if len ( u ) == 1 and u [ 0 ] == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif n % 3 == 0 : <NEWLINE> <INDENT> if len ( u ) == 2 : <NEWLINE> <INDENT> x = l . count ( u [ 0 ] ) <NEWLINE> y = l . count ( u [ 1 ] ) <NEWLINE> if ( x == 2 * n / 3 and y == n / 3 ) or ( y == 2 * n / 3 and x == n / 3 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> elif len ( u ) == 3 : <NEWLINE> <INDENT> x = l . count ( u [ 0 ] ) <NEWLINE> y = l . count ( u [ 1 ] ) <NEWLINE> z = l . count ( u [ 2 ] ) <NEWLINE> if x == n / 3 and y == n / 3 and z == n / 3 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
def get_caps ( a ) : <NEWLINE> <INDENT> dic = dict ( ) <NEWLINE> <NL> for ai in a : <NEWLINE> <INDENT> dic . setdefault ( ai , 0 ) <NEWLINE> dic [ ai ] += 1 <NEWLINE> <NL> <DEDENT> return dic <NEWLINE> <NL> <NL> <DEDENT> def is_match ( caps ) : <NEWLINE> <INDENT> global N <NEWLINE> <NL> if 0 in caps . keys ( ) : <NEWLINE> <INDENT> if caps [ 0 ] == N : <NEWLINE> <INDENT> return True <NEWLINE> <NL> <DEDENT> <DEDENT> if N % 3 == 0 : <NEWLINE> <INDENT> if 0 in caps . keys ( ) and len ( caps ) == 2 : <NEWLINE> <INDENT> if caps [ 0 ] == N // 3 : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> <DEDENT> elif len ( caps ) == 3 : <NEWLINE> <INDENT> x , y , z = caps . keys ( ) <NEWLINE> <NL> if x ^ y ^ z == 0 : <NEWLINE> <INDENT> if caps [ x ] == caps [ y ] == caps [ z ] == N // 3 : <NEWLINE> return True <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> N = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <COMMENT> <NL> caps = get_caps ( a ) <NEWLINE> <NL> if is_match ( caps ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
from collections import Counter <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> c = Counter ( a ) <NEWLINE> s = set ( a ) <NEWLINE> l = len ( s ) <NEWLINE> <NL> if l == 1 and a [ 0 ] == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif len ( a ) % 3 == 0 : <NEWLINE> <INDENT> if l == 2 and c [ 0 ] == n // 3 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif l == 3 : <NEWLINE> <INDENT> if s [ 0 ] ^ s [ 1 ] ^ s [ 2 ] == 0 : <NEWLINE> <INDENT> tmp = c [ a [ 0 ] ] <NEWLINE> if all ( x == tmp for x in c . values ( ) ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n , k , i , v = int ( input ( ) ) , 1 , 2 , n + 1 <NEWLINE> p = print <NEWLINE> while k * 2 < v : k *= 2 <NEWLINE> if - n & k : p ( <STRING> ) ; exit ( ) <NEWLINE> p ( <STRING> , v , 3 ) <NEWLINE> while i < n : p ( 1 , i , i , i + 1 , 1 , v + i , v + i , n + i ) ; i += 2 <NEWLINE> if ~ n & 1 : p ( n , v + k , n + n , n ^ k ) <NEWLINE>
N , A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> t = N * A <NEWLINE> if t > B : <NEWLINE> <INDENT> print ( B ) <NEWLINE> <DEDENT> elif t < B : <NEWLINE> <INDENT> print ( t ) <NEWLINE> <DEDENT> elif t = B : <NEWLINE> <INDENT> print ( B ) <NEWLINE> <DEDENT>
def Input ( ) : <NEWLINE> <INDENT> return mapt ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> n , a , b = Input ( ) <NEWLINE> ans = min ( n * a , b ) <NEWLINE> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> main ( ) <NEWLINE>
list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> print ( min ( list [ 1 ] * N , list [ 2 ] * N ) ) <NEWLINE>
A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> print ( min ( A * N , B ) ) <NEWLINE>
N , A , B = ( int ( x ) for x in input ( ) , split ( ) ) <NEWLINE> print ( min ( N * A , B ) ) <NEWLINE>
inport numpy as np <NEWLINE> <NL> N , A , B = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> costs = A * N , B <NEWLINE> <NL> print ( min ( costs ) ) <NEWLINE>
inp = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if ( inp [ 0 ] * inp [ 1 ] ) <= ip [ 2 ] : <NEWLINE> <INDENT> print ( inp [ 0 ] * inp [ 1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( inp [ 2 ] ) <NEWLINE> <DEDENT>
n , a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> c = n * a <NEWLINE> if c >= b : <NEWLINE> print ( b ) <NEWLINE> else : <NEWLINE> print ( c ) <NEWLINE>
a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if a [ 0 ] * a [ 1 ] <= a [ 2 ] : <NEWLINE> <INDENT> prnit ( a [ 0 ] * a [ 1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( a [ 2 ] ) <NEWLINE> <DEDENT>
A , B , N = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> total_price = A + ( N * B ) <NEWLINE> <NL> print ( total_price - max ( total_price ) ) <NEWLINE>
n , a , b = map ( int , input . split ( ) ) <NEWLINE> <NL> print ( min ( n * a , b ) ) <NEWLINE>
n , a , b = map ( int , input ( ) . split ( ) <NEWLINE> if n * a >= b : <NEWLINE> <INDENT> print ( b ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( n * a ) <NEWLINE> <DEDENT>
S_list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> n , a , b = S_list <NEWLINE> print ( min ( n * a , b ) <NEWLINE>
a , b , c = list ( map ( intl , input ( ) . split ( ) ) ) <NEWLINE> if a * b >= c : <NEWLINE> <INDENT> print ( c ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( a * b ) <NEWLINE> <DEDENT>
n , d = map ( int , readline ( ) . rstrip ( ) . split ( ) ) <NEWLINE> m = [ ] <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> arr = list ( map ( int , readline ( ) . rstrip ( ) . split ( ) ) ) <NEWLINE> m . append ( arr ) <NEWLINE> <DEDENT> ans = 0 <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n ) : <NEWLINE> <INDENT> a = 0 <NEWLINE> for k in range ( d ) : <NEWLINE> <INDENT> a += ( m [ i ] [ k ] - m [ j ] [ k ] ) ** 2 <NEWLINE> <DEDENT> x = int ( a ** ( 1 / 2 ) ) <NEWLINE> if x * 2 == a : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL>
n , d = map ( int , input ( ) . split ( ) ) <NEWLINE> lst = [ ] <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> x = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <DEDENT> ans = 0 <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n ) : <NEWLINE> <INDENT> dist = 0 <NEWLINE> for k in range ( d ) : <NEWLINE> <INDENT> dist += ( lst [ i ] [ k ] - lst [ j ] [ k ] ) ** 2 <NEWLINE> <DEDENT> j = 1 <NEWLINE> while j ** 2 <= dist : <NEWLINE> <INDENT> if j ** 2 == dist : <NEWLINE> <INDENT> ans += 1 <NEWLINE> break <NEWLINE> <DEDENT> j += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from math import sqrt <NEWLINE> n , d = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> vs = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> v = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> vs . append ( vs ) <NEWLINE> <NL> <DEDENT> def ds ( a , b ) : <NEWLINE> <INDENT> s = 0 <NEWLINE> for i in range ( d ) : <NEWLINE> <INDENT> s += ( b [ i ] - a [ i ] ) ** 2 <NEWLINE> <DEDENT> return sqrt ( s ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n ) : <NEWLINE> <INDENT> d = ds ( vs [ i ] , vs [ j ] ) <NEWLINE> if d == int ( d ) : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> def input2 ( ) : <NEWLINE> <INDENT> return map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> def input_array ( ) : <NEWLINE> <INDENT> return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <DEDENT> def euclid ( y , z , d ) : <NEWLINE> <INDENT> result = 0 <NEWLINE> for i in range ( d ) : <NEWLINE> <INDENT> result += ( y [ i ] - z [ i ] ) ** 2 <NEWLINE> <DEDENT> return math . sqrt ( result ) <NEWLINE> <NL> <NL> <DEDENT> n , d = input2 ( ) <NEWLINE> X = [ input_array ( ) for _ in range ( n ) ] <NEWLINE> <NL> count = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n ) : <NEWLINE> <INDENT> distance = euclid ( X [ i ] , X [ j ] , d ) <NEWLINE> if ( distance % 1 ) == 0 : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
N , D = [ int ( n ) for n in input ( ) . split ( ) ] <NEWLINE> X = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> X . append ( [ int ( m ) for m in input ( ) . split ( ) ] ) <NEWLINE> <NL> <DEDENT> def get_distance ( p1 , p2 ) : <NEWLINE> <INDENT> d2 = 0 <NEWLINE> for i in range ( D ) : <NEWLINE> <INDENT> d2 += ( p1 [ i ] - p2 [ i ] ) ** 2 <NEWLINE> <DEDENT> return math . sqrt ( d2 ) <NEWLINE> <NL> <DEDENT> count = 0 <NEWLINE> for i , j in itertools . combinations ( range ( N ) , 2 ) : <NEWLINE> <INDENT> if get_distance ( X [ i ] , X [ j ] ) . is_integer ( ) : <NEWLINE> <INDENT> count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
import math <NEWLINE> n , d = map ( int , input ( ) . split ( ) ) <NEWLINE> x = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ] <NEWLINE> cnt = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n ) : <NEWLINE> <INDENT> sum = 0 <NEWLINE> for k in range ( n ) : <NEWLINE> <INDENT> sum += ( x [ i ] [ k ] - x [ j ] [ k ] ) ** 2 <NEWLINE> <DEDENT> z = pow ( sum , 0.5 ) <NEWLINE> if math . ceil ( z ) == math . floor ( z ) : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
import math <NEWLINE> <NL> def gooddistance ( l1 , l2 ) : <NEWLINE> <INDENT> calc = [ ] <NEWLINE> <NL> for i in range ( len ( l1 ) ) : <NEWLINE> <INDENT> calc . append ( ( l1 [ i ] - l2 [ i ] ) ** 2 ) <NEWLINE> <NL> <DEDENT> if math . sqrt ( sum ( calc ) ) . is_integer ( ) : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return 0 <NEWLINE> <NL> n , d = map ( int , input ( ) . split ( ) ) <NEWLINE> <DEDENT> <DEDENT> lst = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ] <NEWLINE> count = 0 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n ) : <NEWLINE> <INDENT> count += gooddistance ( lst [ i ] , lst [ j ] ) <NEWLINE> <NL> print ( count ) <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> import numpy as np <NEWLINE> rm = lambda : map ( int , sys . stdin . readline ( ) . split ( ) ) <NEWLINE> rl = lambda : list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) <NEWLINE> <NL> cnt = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( i ) : <NEWLINE> <INDENT> a = sum ( ( li [ i ] - li [ j ] ) ** 2 ) ** 0.5 <NEWLINE> if a - a // 1 == 0 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
import math <NEWLINE> <NL> n , d = map ( int , input ( ) . split ( ) ) <NEWLINE> x = [ list ( int , input ( ) . split ( ) ) for i in range ( n ) ] <NEWLINE> cnt = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n ) : <NEWLINE> <INDENT> for k in range ( d ) : <NEWLINE> <INDENT> dis = 0 <NEWLINE> dis += ( x [ i ] [ k ] - x [ j ] [ k ] ) ** 2 <NEWLINE> if math . sqrt ( dis ) % 1 == 0 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
n , d = map ( int , input ( ) . split ( ) ) <NEWLINE> x_l = [ list ( map ( int , input ( ) . split ) ) for _ in range ( n ) ] <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n ) : <NEWLINE> <INDENT> tmp = 0 <NEWLINE> for k in range ( d ) : <NEWLINE> <INDENT> tmp += ( x_l [ j ] [ k ] - x_l [ i ] [ k ] ) ** 2 <NEWLINE> <DEDENT> if tmp ** 0.5 % 1 == 0 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> N , D = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ ] <NEWLINE> ans = 0 <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> tmp = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a . append ( tmp ) <NEWLINE> <DEDENT> for n in range ( N ) : <NEWLINE> <INDENT> for m in range ( n + 1 , N ) : <NEWLINE> dis = 0 <NEWLINE> <INDENT> for d in range ( D ) : <NEWLINE> <INDENT> dis += ( a [ n ] [ d ] - a [ m ] [ d ] ) ** 2 <NEWLINE> <DEDENT> if math . sqrt ( dis ) == int ( math . sqrt ( dis ) ) : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> <NL> N , D = map ( int , input ( ) . split ( ) ) <NEWLINE> X = [ ] <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> X . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <DEDENT> count = 0 <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , N ) : <NEWLINE> <INDENT> a = 0 <NEWLINE> for k in range ( D ) : <NEWLINE> <INDENT> a += ( X [ i ] [ k ] - X [ j ] [ k ] ) ** 2 <NEWLINE> <DEDENT> if math . sqrt ( a ) . is_integer ( ) : <NEWLINE> <INDENT> coutn += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
import math <NEWLINE> <NL> N , D = map ( int , input ( ) . split ( ) ) <NEWLINE> X = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( N ) ) ] <NEWLINE> cnt = 0 <NEWLINE> <NL> for i in range ( N - 1 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , N ) : <NEWLINE> tmp = 0 <NEWLINE> for k in range ( D ) : <NEWLINE> <INDENT> tmp += ( ( X [ i ] [ k ] - X [ j ] [ k ] ) ** 2 ) <NEWLINE> <DEDENT> tmp = math . sqrt ( tmp ) <NEWLINE> if tmp . is_integer : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
n , d = map ( int , input ( ) . split ( ) ) <NEWLINE> l = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> l . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <DEDENT> count = 0 <NEWLINE> import math <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( n ) : <NEWLINE> <INDENT> sum = 0 <NEWLINE> for i in range ( d ) : <NEWLINE> <INDENT> sum += ( l [ i ] [ d ] - l [ i ] [ d ] ) ** 2 <NEWLINE> <DEDENT> dis = sqrt ( sum ) <NEWLINE> if dis % 1 == 0 : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
import sys <NEWLINE> import itertoolsy <NEWLINE> N , D = map ( int , input ( ) . split ( ) ) <NEWLINE> array = [ list ( map ( int , input ( ) . split ( ) ) ) for x in range ( N ) ] <NEWLINE> <NL> if not ( 2 <= N <= 10 and 1 <= D <= 10 ) : sys . exit ( ) <NEWLINE> for I in array : <NEWLINE> <INDENT> if not ( - 20 <= min ( I ) and max ( I ) <= 20 ) : sys . exit ( ) <NEWLINE> <NL> <DEDENT> count = 0 <NEWLINE> for I in list ( itertools . combinations ( array , 2 ) ) : <NEWLINE> <INDENT> tmp_distance = 0 <NEWLINE> for J in range ( D ) : <NEWLINE> <INDENT> tmp_distance += abs ( I [ 0 ] [ J ] - I [ 1 ] [ J ] ) ** 2 <NEWLINE> <DEDENT> distance = tmp_distance ** 0.5 <NEWLINE> if distance . is_integer ( ) : count += 1 <NEWLINE> <NL> <DEDENT> print ( count ) <NEWLINE>
n , d = map ( int , input ( ) . split ( ) ) <NEWLINE> l = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( N ) ] <NEWLINE> a = 0 <NEWLINE> ans += 1 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n ) : <NEWLINE> <INDENT> for k in range ( d ) : <NEWLINE> <INDENT> a += l [ i ] [ k ] ** 2 - l [ j ] [ k ] ** 2 <NEWLINE> a **= 0.5 <NEWLINE> if a . is_integer : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N , D = map ( int , input ( ) . split ( ) ) <NEWLINE> import numpy as np <NEWLINE> xlist = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( n ) ] <NEWLINE> xarray = np . array ( xlist ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n ) : <NEWLINE> <INDENT> if np . linalg . norm ( xarray [ i ] - xarray [ j ] ) == int ( np . linalg . norm ( xarray [ i ] - xarray [ j ] ) ) : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N , D = ( int ( x ) for x in input ( ) . split ( ) ) <NEWLINE> X = [ ] * N <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> X [ i ] = [ float ( x ) for x in input ( ) . split ( ) ] <NEWLINE> <DEDENT> count = 0 <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , N ) : <NEWLINE> <INDENT> sq = [ ( X [ i ] [ k ] - X [ j ] [ k ] ) ** 2 for k in range ( D ) ] <NEWLINE> if isinstance ( sum ( sq ) ** 0.5 , int ) : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
n , d = map ( int , input ( ) . split ( ) ) <NEWLINE> x = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( n ) ] <NEWLINE> cnt = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n ) : <NEWLINE> <INDENT> a = x [ i ] <NEWLINE> b = x [ j ] <NEWLINE> z = 0 <NEWLINE> for k in range ( d ) : <NEWLINE> <INDENT> z += ( a [ k ] - b [ k ] ) ** 2 <NEWLINE> <DEDENT> if math . sqrt ( z ) % 1 == 0 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <NL> import math <NEWLINE> <NL> def dis ( Y , Z ) : <NEWLINE> <INDENT> ans = 0 <NEWLINE> for i in range ( len ( Y ) ) : <NEWLINE> <INDENT> ans += ( Y [ i ] - Z [ i ] ) ** 2 <NEWLINE> <DEDENT> return math . sqrt ( ans ) <NEWLINE> <NL> <NL> <DEDENT> N , D = map ( int , input ( ( ) . split ( ) ) ) <NEWLINE> X = [ ] <NEWLINE> ans = 0 <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> X . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> for j in range ( i , N ) : <NEWLINE> <INDENT> if dis ( i , j ) % 1 == 0 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
L , R = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if R - L >= 2019 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = 2019 <NEWLINE> for i in range ( L , R - 1 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , R ) : <NEWLINE> ans = min ( ans , ( i * j ) % 2019 ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> if r - l >= 2019 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = 2019 <NEWLINE> for i in raneg ( l , r ) : <NEWLINE> <INDENT> for j in range ( i + 1 , r + 1 ) : <NEWLINE> <INDENT> ans = min ( ans , i * j % 2019 ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> rem_l = l % 2019 <NEWLINE> rem_r = r % 2019 <NEWLINE> <NL> ans = - 1 <NEWLINE> <NL> if r - l >= 2019 : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <NL> <DEDENT> elif rem_l >= rem_r : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> ans = float ( <STRING> ) <NEWLINE> for i in range ( l , r ) : <NEWLINE> <INDENT> for j in raneg ( i , r ) : <NEWLINE> <INDENT> temp = ( i * j ) % 2019 <NEWLINE> if temp < ans : <NEWLINE> <INDENT> ans = temp <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
L , R = map ( int , input ( ) . split ( ) ) <NEWLINE> R = min ( R , L + 2019 ) <NEWLINE> print ( min ( [ i * j % 2019 for i in range ( L , R + 1 ) for jj in range ( i + 1 , R + 1 ) ] ) ) <NEWLINE>
L . R = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = float ( <STRING> ) <NEWLINE> for i in range ( L , R + 1 ) : <NEWLINE> <INDENT> for j in range ( L , R + 1 ) : <NEWLINE> <INDENT> s = ( i * j ) % 2019 <NEWLINE> if s == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = min ( s , ans ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> import sys <NEWLINE> mod = 2019 <NEWLINE> ans = float ( <STRING> ) <NEWLINE> <NL> for i in range ( l , r + 1 ) : <NEWLINE> <INDENT> for j in range ( j + 1 , r + 1 ) : <NEWLINE> <INDENT> ans = min ( ( i * j ) % mod , ans ) <NEWLINE> if ans == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if r // 673 > ( l - 1 ) // 673 and r - l = 2 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> print ( ( l % 2019 ) * ( ( l + 1 ) % 2019 ) ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> L , R = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ ] <NEWLINE> if R - L > 2019 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> elif 2 <= R - L and R - L <= 2019 : <NEWLINE> <INDENT> for i in range ( L , R ) : <NEWLINE> <INDENT> for j in range ( i + 1 , R + 1 ) : <NEWLINE> <INDENT> A . append ( ( i * j ) % 2019 ) <NEWLINE> <DEDENT> <DEDENT> print ( min ( A ) ) <NEWLINE> <DEDENT> elif R - L = 1 : <NEWLINE> <INDENT> print ( ( R * L ) % 2019 ) <NEWLINE> <DEDENT>
l . r = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> mod = 2019 <NEWLINE> a = l % 2019 <NEWLINE> b = l % 2019 <NEWLINE> <NL> if r - l >= 2018 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> if a < b : <NEWLINE> <INDENT> print ( a * a + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> <DEDENT>
from collections import Counter <NEWLINE> inp = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> l = inp [ 0 ] <NEWLINE> r = inp [ 1 ] <NEWLINE> c = Counter ( [ ] ) <NEWLINE> arr = [ ] <NEWLINE> for i in range ( l , r + 1 ) : <NEWLINE> <INDENT> if c [ i ] == 0 : <NEWLINE> <INDENT> c [ i ] += 1 <NEWLINE> arr . append ( i ) <NEWLINE> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> if c [ 0 ] != 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> ans = 99999999999 <NEWLINE> for i in range ( len ( arr ) ) : <NEWLINE> <INDENT> for j in range ( i + 1 , len ( arr ) ) : <NEWLINE> <INDENT> ans = min ( ans , ( i * j ) % 2019 ) <NEWLINE> if ans == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> if ans == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
L , R = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ ] <NEWLINE> <NL> if R - L >= 2019 : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> l , r = L % 2019 , R % 2019 <NEWLINE> for i in range ( l , r ) : <NEWLINE> <INDENT> for j in range ( l + 1 , r + 1 ) : <NEWLINE> <INDENT> k = ( i * j ) % 2019 <NEWLINE> ans = min ( ans , k ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> m , ans = 2019 , 2018 <NEWLINE> r = min ( r , l + 2019 * 2 ) <NEWLINE> for i in range ( l , r + 1 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , r + 1 ) : <NEWLINE> <INDENT> i %= m <NEWLINE> j %= m <NEWLINE> ans = min ( ans , ( i * j ) % m ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> if s [ 0 ] == s [ 4 ] and s [ 1 ] == s [ 2 ] and s [ 2 ] != s [ 3 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> main ( ) <NEWLINE>
print ( <STRING> if len ( set ( input ( ) ) ) == 2 and S . count ( S [ 0 ] ) == 2 else <STRING> ) <NEWLINE>
s = input ( ) <NEWLINE> for i in s : <NEWLINE> <INDENT> if s . counter ( i ) != 2 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
from collections import Counter as C <NEWLINE> <NL> S = input ( ) <NEWLINE> <NL> c = C ( S ) <NEWLINE> if len ( c . keys ( ) ) == 2 : <NEWLINE> <INDENT> if c . values [ 0 ] == 2 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> t = set ( s ) <NEWLINE> if len ( t ) == 2 and s . count ( list ( t [ 0 ] ) ) == 2 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> print ( <STRING> if ( sorted ( s [ : 2 ] ) == sorted ( s [ 2 : ] ) and len ( sorted ( s [ : 2 ) ) == 2 ) else <STRING> ) <NEWLINE>
<COMMENT> <NL> <NL> S = str ( input ( ) ) <NEWLINE> T = [ S [ 0 ] , S [ 1 ] , S [ 2 ] , S [ 3 ] ] <NEWLINE> T . sort ( ) <NEWLINE> if T [ 0 ] == T [ 1 ] and T [ 2 ] == T [ 3 ] and T [ 1 ] != T [ 2 ] <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> if ( ( s [ 0 ] == s [ 1 ] and s [ 2 ] == s [ 3 ] and s [ 0 ] != s [ 2 ] ) or ( s [ 0 ] == s [ 2 ] and s [ 1 ] == s [ 3 ] and s [ 0 ] != s [ 1 ] ) <NEWLINE> <INDENT> and ( s [ 0 ] == = s [ 3 ] and s [ 1 ] == s [ 2 ] and s [ 0 ] != s [ 1 ] ) ) : <NEWLINE> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> d = { } <NEWLINE> for i in range ( 4 ) : <NEWLINE> <INDENT> t = s [ i : i + 1 ] <NEWLINE> try : <NEWLINE> <INDENT> d [ t ] += 1 <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> d [ t ] = 1 <NEWLINE> <DEDENT> <DEDENT> if ( len ( d ) == 2 ) : <NEWLINE> <INDENT> frag = True <NEWLINE> for i in range ( 2 ) : <NEWLINE> <INDENT> if ( d [ i ] != 2 ) : <NEWLINE> <INDENT> frag = False <NEWLINE> <DEDENT> <DEDENT> if ( frag ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
from collections import defaultdict <NEWLINE> S = input ( ) <NEWLINE> t = defaultdict ( int ) <NEWLINE> for i in s : <NEWLINE> <INDENT> t [ i ] += 1 <NEWLINE> <DEDENT> if len ( t . keys ( ) ) == 2 : <NEWLINE> <INDENT> for i in t . values ( ) : <NEWLINE> <INDENT> if i != 2 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s = list ( input ( ) ) <NEWLINE> a = len ( set ( s ) <NEWLINE> if a == 2 : <NEWLINE> <INDENT> b = len ( [ t for t in s if t == s [ 0 ] ] ) <NEWLINE> if b == 2 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> else : <NEWLINE> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a = input ( ) <NEWLINE> a . sort ( ) <NEWLINE> if a [ 0 ] == a [ 1 ] and a [ 2 ] == a [ 3 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> s1 = set ( input ( ) ) <NEWLINE> if len ( s1 ) == 2 : <NEWLINE> <INDENT> if s . count ( list ( s1 ) [ 0 ] ) == 2 and s . count ( list ( s1 ) [ 1 ] ) == 2 : print ( <STRING> ) <NEWLINE> else : print ( <STRING> ) <NEWLINE> <DEDENT> else : print ( <STRING> ) <NEWLINE>
from collections import defaultdict <NEWLINE> s = str ( input ( ) ) <NEWLINE> d = defaultdict ( int ) <NEWLINE> for x in s : <NEWLINE> <INDENT> d [ x ] += 1 <NEWLINE> <DEDENT> if len ( d ) == 2 : <NEWLINE> <INDENT> for key , value in d : <NEWLINE> <INDENT> if value != 2 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT>
s = input ( ) <NEWLINE> if s [ 0 ] == s [ 1 ] == s [ 2 ] == s [ 3 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if s [ 0 ] == s [ 1 ] : <NEWLINE> <INDENT> if s [ 2 ] == s [ 3 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> elif s [ 0 ] == s [ 2 ] : <NEWLINE> <DEDENT> if s [ 1 ] == s [ 3 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> elif s [ 0 ] == s [ 3 ] : <NEWLINE> <DEDENT> if s [ 1 ] == s [ 2 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
<NL> def main ( ) : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> s_ = list ( set ( s ) ) <NEWLINE> if s . count ( s_ [ 0 ] ) == 2 and len ( s_ ) == 2 i : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
S = input ( ) <NEWLINE> S . sort ( ) <NEWLINE> if S [ 0 ] == S [ 1 ] and S [ 2 ] == S [ 3 ] and S [ 1 ] != S [ 2 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
S = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> print ( <STRING> if X [ 0 ] == X [ 1 ] and X [ 2 ] == X [ 3 ] else <STRING> ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> n = int ( input ( ) ) <NEWLINE> p = list ( map ( int , input ( ) ) ) <NEWLINE> <NL> answer = 0 <NEWLINE> for i in range ( 1 , n - 1 ) : <NEWLINE> <INDENT> if p [ i - 1 ] < p [ i ] < p [ 1 + 1 ] or p [ i - 1 ] > p [ i ] > p [ i + 1 ] : <NEWLINE> <INDENT> answer += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( answer ) <NEWLINE> <NL>
n = int ( input ( ) ) <NEWLINE> p = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> for i in range ( 1 , n - 1 ) : <NEWLINE> <INDENT> if p [ i - 1 ] < p [ i ] < p [ i + 1 ] or p [ i + 1 ] < p [ i ] < p [ i - 1 ] : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> arr = [ map ( int , input ( ) . split ( ) ) ] <NEWLINE> print ( sum ( [ 1 for i in range ( len ( arr ) ) if ( ( ( arr [ i ] < arr [ i + 1 ] ) and ( arr [ i ] > arr [ i - 1 ] ) ) or ( ( arr [ i ] > arr [ i + 1 ] ) and ( arr [ i ] < arr [ i - 1 ] ) ) ) ] ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = [ int ( k ) for k in input ( ) . split ( ) ] <NEWLINE> cnt = 0 <NEWLINE> for i in range ( n - 3 ) : <NEWLINE> <INDENT> if a [ i ] < a [ i + 1 ] and a [ i + 1 ] < a [ i + 2 ] : cnt + = 1 <NEWLINE> <DEDENT> print ( cnt ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> p = map ( int , input ( ) . split ( ) ) <NEWLINE> count = 0 <NEWLINE> for i in range ( 0 , n - 2 ) : <NEWLINE> <INDENT> if ( p [ i ] < p [ i + 1 ] and p [ i + 1 ] < p [ i + 2 ] ) or ( p [ i ] > p [ i + 1 ] and p [ i + 1 ] > p [ i + 2 ] ) : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> P = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> for i in range ( N - 2 ) : <NEWLINE> <INDENT> if P [ i ] > P [ i + 1 ] and P [ i + 1 ] > P [ i + 2 ] or P [ i ] < P [ i + 1 ] and P [ i + 1 ] < P [ i + 2 ] or : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( 1 , n - 1 ) : <NEWLINE> <INDENT> if p [ i ] >= p [ i - 1 ] and p [ i ] = < p [ i + 1 ] : ans += 1 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> cnt = 0 <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> if ( p [ i ] - p [ i - 1 ] > 0 and p [ i + 1 ] - p [ i ] >= 0 ) or ( p [ i ] - p [ i - 1 ] <= 0 and p [ i + 1 ] - p [ i ] < 0 ) : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
n , a * = map ( int , open ( 0 ) . read ( ) . split ( ) ) <NEWLINE> t = 0 <NEWLINE> for i in range ( 1 , n - 1 ) : <NEWLINE> <INDENT> if sorted ( a [ i - 1 : i + 2 ] ) . index ( a [ i ] ) == 1 : <NEWLINE> <INDENT> t += 1 <NEWLINE> <DEDENT> <DEDENT> print ( t ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in range ( 1 , n - 1 ) : <NEWLINE> <INDENT> if p [ i - 1 ] < p [ i ] and p [ i ] < p [ i + 1 ] : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> elif p [ i + 1 ] < p [ i ] and p [ i ] < p [ i - 1 ] : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
<COMMENT> <NL> <NL> n = int ( input ( ) ) <NEWLINE> K = 0 <NEWLINE> for i in range ( n - 2 ) : <NEWLINE> <INDENT> if ( P [ i ] < P [ i + 1 ] and P [ i + 1 ] < P [ i + 2 ] ) or ( P [ i + 2 ] < P [ i + 1 ] and P [ i + 1 ] < P [ i ] ) : <NEWLINE> <INDENT> K += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( K ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 0 , n ) : <NEWLINE> <INDENT> if ( p [ i - 1 ] < p [ i ] < p [ i + 1 ] ) or ( p [ i - 1 ] > p [ i ] > p [ i + 1 ] ) : <NEWLINE> <INDENT> ans = ans + 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> P = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> print ( L [ N // 2 ] - L [ N // 2 - 1 ] ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> l = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> l . sort ( ) <NEWLINE> print ( max ( 0 , l [ int ( N / 2 ) ] - l [ int ( N / 2 ) - 1 ] ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> l . sort ( ) <NEWLINE> a = n / 2 <NEWLINE> s = l . index ( a - 1 ) <NEWLINE> t = l . index ( a ) <NEWLINE> if s == t : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = t - s <NEWLINE> print ( ans ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> arr = list ( map ( int , input ( ) . rstrip ( ) . split ( ) ) ) <NEWLINE> arr . sort ( ) <NEWLINE> <NL> if arr [ n // 2 - 1 ] == arr [ n // 2 ] : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> return <NEWLINE> <DEDENT> print ( arr [ n // 2 ] - arr [ n // 2 - 1 ] ) <NEWLINE>
N = int ( input ( ) . split ( ) ) <NEWLINE> d = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> d . sort ( ) <NEWLINE> result = d [ int ( N / 2 ) ] - d [ int ( ( N - 1 ) / 2 ) ] <NEWLINE> print ( result ) <NEWLINE>
n = input ( ) <NEWLINE> dl = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> dl . sort ( ) <NEWLINE> <NL> if n % 2 != 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <NL> <DEDENT> left = dl [ ( n // 2 ) - 1 ] <NEWLINE> right = dl [ ( n // 2 ) ] <NEWLINE> <NL> print ( right - left ) <NEWLINE>
14 <NEWLINE> 99592 10342 29105 78532 83018 11639 92015 77204 30914 21912 34519 80835 100000 1 <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( int , input ( ) . split ( ) ) <NEWLINE> A . sort ( ) <NEWLINE> l = A [ N // 2 - 1 ] <NEWLINE> h = A [ N // 2 ] <NEWLINE> print ( h - l ) <NEWLINE>
99592 10342 29105 78532 83018 11639 92015 77204 30914 21912 34519 80835 100000 1 <NEWLINE>
N = int ( input ( ) ) <NEWLINE> d = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> d = sorted ( d ) <NEWLINE> ans = 0 <NEWLINE> <NL> for i in range ( 10 ** 7 ) : <NEWLINE> <INDENT> if d [ int ( N / 2 - 1 ) ] < i and i <= d [ int ( N / 2 ) ] : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> d = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> d . sorted ( ) <NEWLINE> print ( d [ n / 2 ] - d [ n / 2 - 1 ] ) <NEWLINE>
a = int ( input ( ) ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b . sort ( ) <NEWLINE> if b [ ( a / 2 ) - 1 ] == b [ ( a / 2 ) ] : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( b [ ( a / 2 ) ] - b [ ( a / 2 ) - 1 ] - 1 ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> d = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> ans = 0 <NEWLINE> if d [ N / 2 ] != d [ N / 2 - 1 ] : <NEWLINE> <INDENT> ans = d [ N / 2 ] - d [ N / 2 - 1 ] <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
from scipy . misc import comb <NEWLINE> <NL> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> for i in range ( k ) : <NEWLINE> <INDENT> print ( int ( comb ( n - k + 1 , i + 1 ) * comb ( k - 1 , i ) % MOD ) ) <NEWLINE> <DEDENT>
import math <NEWLINE> a , b , c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <COMMENT> <NL> ans = ( b // c + b // d - b // ( c * d // math . gcd ( c , d ) ) ) - ( ( a - 1 ) // c + ( a - 1 ) // d - ( a - 1 ) // ( c * d // math . gcd ( c , d ) ) ) <NEWLINE> <NL> print ( b - a + 1 - ans ) <NEWLINE>
def split ( word ) : <NEWLINE> <INDENT> return [ char for char in word ] <NEWLINE> <DEDENT> inp = input ( ) <NEWLINE> list = split ( inp ) <NEWLINE> count = 0 <NEWLINE> x = 1 <NEWLINE> str = <STRING> <NEWLINE> for i in range ( len ( 3 ) : <NEWLINE> <INDENT> if list [ count ] == list [ count + 1 ] : <NEWLINE> <INDENT> str = <STRING> <NEWLINE> <DEDENT> count = count + 1 <NEWLINE> <DEDENT> print ( str ) <NEWLINE>
from itertools import groupby <NEWLINE> import sys <NEWLINE> rr = lambda : sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> s = rr ( ) <NEWLINE> print ( <STRING> if len ( groupby ( s ) ) == 4 else <STRING> ) <NEWLINE> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL>
arr = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for k in range ( len ( arr ) ) : <NEWLINE> <INDENT> if arr [ k ] == arr [ k + 1 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
S = input ( ) <NEWLINE> <NL> answer = <STRING> <NEWLINE> prev_s = s [ 0 ] <NEWLINE> for s in S [ 1 : ] : <NEWLINE> <INDENT> if prev_s == s : <NEWLINE> <INDENT> answer = <STRING> <NEWLINE> break <NEWLINE> <DEDENT> prev_s = s <NEWLINE> <NL> <DEDENT> print ( answer ) <NEWLINE>
s = int ( input ( ) ) <NEWLINE> ans = <STRING> <NEWLINE> for i in range ( 3 ) : <NEWLINE> <INDENT> if s [ i ] == s [ i + 1 ] : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
a = list ( input ( ) ) <NEWLINE> count = 0 <NEWLINE> for i in range ( 4 ) : <NEWLINE> <INDENT> if a [ i ] == a [ i + 1 ] and i == 2 : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
str = input ( ) <NEWLINE> <NL> flag = False <NEWLINE> for i in range ( len ( str ) ) - 1 : <NEWLINE> <INDENT> if str [ i ] == str [ i + 1 ] : <NEWLINE> <INDENT> flag = True <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> ) if flag else print ( <STRING> ) <NEWLINE>
num = input ( ) <NEWLINE> c = False <NEWLINE> for i in range ( 1 , len ( num ) + 1 ) : <NEWLINE> <INDENT> if num [ i ] == num [ i - 1 ] : <NEWLINE> <INDENT> c = True <NEWLINE> <NL> <DEDENT> <DEDENT> if c == True : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s = str ( input ( ) ) <NEWLINE> if s [ 0 ] == s [ 1 ] or s [ 1 ] == s [ 2 ] or s [ 2 ] == s [ 3 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <INDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
s = list ( int ( input ( ) ) ) <NEWLINE> f = True <NEWLINE> for i in range ( 1 , 4 ) : <NEWLINE> <INDENT> if s [ i - 1 ] == s [ i ] : <NEWLINE> <INDENT> f = False <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> <DEDENT> if f : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> flag = False <NEWLINE> for i in range ( 3 ) : <NEWLINE> <INDENT> if List [ i ] == List [ i + 1 ] : <NEWLINE> <INDENT> flag = True <NEWLINE> <DEDENT> <DEDENT> if flag : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a = int ( input ( ) ) <NEWLINE> print ( <STRING> if a [ 0 ] == a [ 1 ] or a [ 1 ] == a [ 2 ] or a [ 2 ] == a [ 3 ] else <STRING> ) <NEWLINE>
s = list ( input ( ) ) <NEWLINE> for i in range ( 3 ) : <NEWLINE> <INDENT> if ( s [ i ] == s [ i + 1 ] ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import math <NEWLINE> <NL> A , B , C , D = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> <NL> num_C_baisu = B // C - ( A - 1 ) // C <COMMENT> <NEWLINE> <NL> num_D_baisu = B // D - ( A - 1 ) // D <COMMENT> <NEWLINE> <NL> CD = int ( C * D / math . gcd ( C , D ) ) <NEWLINE> <NL> num_CD_baisu = B // CD - ( A - 1 ) // CD <COMMENT> <NEWLINE> <NL> baisu_num = num_C_baisu + num_D_baisu - num_CD_baisu <NEWLINE> <NL> print ( B - A + 1 - baisu_num ) <NEWLINE>
s = int ( input ( ) ) <NEWLINE> <NL> for i in range ( 3 ) : <NEWLINE> <INDENT> if s [ i ] == s [ i + 1 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> print ( <STRING> if len ( s ) = len ( set ( s ) ) else <STRING> ) <NEWLINE>
a = range ( 1 , 8 + 1 ) <NEWLINE> <INDENT> b = range ( 1 , 8 + 1 ) <NEWLINE> c = range ( 1 , 8 + 1 ) <NEWLINE> d = range ( 1 , 8 + 1 ) <NEWLINE> <NL> if a == b or b == c or c == d : <NEWLINE> <INDENT> return ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
pass = input ( ) <NEWLINE> if pass [ 0 ] == pass [ 1 ] or pass [ 1 ] == pass [ 2 ] or pass [ 2 ] == pass [ 3 ] : print ( <STRING> ) <NEWLINE> else : print ( <STRING> ) <NEWLINE>
S = input ( ) <NEWLINE> p = a <NEWLINE> for s in S : <NEWLINE> <INDENT> if p == s : <NEWLINE> <INDENT> p = a <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> p = s <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> if p == a else <STRING> ) <NEWLINE>
s = input ( ) <NEWLINE> l = len ( s ) <NEWLINE> ans = 0 <NEWLINE> <NL> for i in range ( l ) : <NEWLINE> <INDENT> for k in range ( i , k ) : <NEWLINE> <INDENT> if s [ i ] == s [ k ] : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if ans == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> if ans != 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
S = input ( ) <NEWLINE> flag = False <NEWLINE> for s in S : <NEWLINE> <INDENT> if flag : <NEWLINE> <INDENT> if temp = s : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> quit ( ) <NEWLINE> <DEDENT> <DEDENT> temp = s <NEWLINE> flag = True <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE>
s = int ( input ( ) ) <NEWLINE> ans = <STRING> <NEWLINE> for i in range ( 10 ) : <NEWLINE> <INDENT> k = str ( i ) + str ( i ) <NEWLINE> if ( k in s ) : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> total = a * ( a + 2 * b - 1 ) // 2 <NEWLINE> x = b <NEWLINE> y = a + b - 1 <NEWLINE> if ( abs ( x ) < abs ( y ) : <NEWLINE> <INDENT> z = x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> z = y <NEWLINE> <DEDENT> if x <= 0 and y >= 0 : <NEWLINE> <INDENT> print ( total ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( total - z ) <NEWLINE> <DEDENT>
n . l = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <COMMENT> <NL> <NL> min_abs = 99999999999 <NEWLINE> min_abs_i = - 1 <NEWLINE> n_aji = 0 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> aji = l + i - 1 <NEWLINE> aji_abs = abs ( aji ) <NEWLINE> if aji_abs < min_abs : <NEWLINE> <INDENT> min_abs = aji_abs <NEWLINE> aji_abs_i = i <NEWLINE> <DEDENT> n_aji += aji <NEWLINE> <NL> <DEDENT> print ( n_aji - ( l + aji_abs_i - 1 ) ) <NEWLINE>
N , L = map ( int , input ( ) . split ( ) ) <NEWLINE> li = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> li . append ( L + i + 1 - 1 ) <NEWLINE> <DEDENT> A = True <NEWLINE> li . sort ( ) <NEWLINE> for j in range ( N - 1 ) : <NEWLINE> <INDENT> if abs ( li [ j ] ) <= abs ( li [ j + 1 ] ) : <NEWLINE> <INDENT> S -= li [ j ] <NEWLINE> A = False <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if A == True : <NEWLINE> <INDENT> S -= li [ N - 1 ] <NEWLINE> <NL> <DEDENT> print ( S ) <NEWLINE>
N , L = map ( int , input ( ) ) <NEWLINE> A = list ( ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> A . append ( L + i ) <NEWLINE> <DEDENT> A . sort ( ) <NEWLINE> S = sum ( A ) <NEWLINE> if min ( A ) * max ( A ) <= 0 : <NEWLINE> <INDENT> print ( S ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if L >= 0 : <NEWLINE> <INDENT> print ( S - min ( A ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( S - max ( A ) ) <NEWLINE> <DEDENT> <DEDENT>
N , L = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> A . append ( L + i ) <NEWLINE> <DEDENT> i = 0 <NEWLINE> for k in A : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> x = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x , y = abs ( i ) , - abs ( i ) <NEWLINE> <DEDENT> i += 1 <NEWLINE> for <NEWLINE> <DEDENT>
n , l = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( range ( l , l + n , 1 ) ) <NEWLINE> x = sum ( a ) <NEWLINE> if ( a in 0 ) : <NEWLINE> <INDENT> a . remove ( 0 ) <NEWLINE> print ( sum ( a ) ) <NEWLINE> <DEDENT> elif ( x < 0 ) : <NEWLINE> <INDENT> a . remove ( max ( a ) ) <NEWLINE> print ( sum ( a ) ) <NEWLINE> <DEDENT> elif ( x > 0 ) : <NEWLINE> <INDENT> a . remove ( min ( a ) ) <NEWLINE> print ( sum ( a ) ) <NEWLINE> <DEDENT>
<COMMENT> <NL> def pop_min_abs ( l ) : <NEWLINE> <INDENT> abs = map ( abs , l ) <NEWLINE> return l . pop ( abs . index ( min ( abs ) ) ) <NEWLINE> <NL> <NL> <NL> <DEDENT> n , l = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> apples = [ l + i - 1 for i in range ( 1 , n + 1 ) ] <NEWLINE> print ( sum ( pop_min_abs ( apples ) ) ) <NEWLINE>
N , L = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> apples = [ i + L - 1 for i in range ( 1 , N + 1 ) ] <NEWLINE> <NL> ans = float ( <STRING> ) <NEWLINE> <NL> for apple in apples : <NEWLINE> <INDENT> ans = min ( ans , abs ( apples ) ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
n , l = map ( int , input ( ) . split ( ) ) <NEWLINE> c = 0 <NEWLINE> m = 100000 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> c += l + i - 1 <NEWLINE> m = min ( m , abs ( l + i - 1 ) ) <NEWLINE> <DEDENT> if l < 0 and a - n <= 0 : <NEWLINE> <INDENT> print ( c + d ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( c - d ) <NEWLINE> <DEDENT>
n , l = map ( int , input ( ) . split ( ) ) <NEWLINE> aj = [ l + i for i in range ( n ) ] <NEWLINE> ajs = sum ( aj ) <NEWLINE> resl = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> aj2 = aj <NEWLINE> del aj2 [ i ] <NEWLINE> resl += [ sum ( aj2 ) ] <NEWLINE> <DEDENT> resl2 = [ abs ( ajs - resl [ i ] ) for i in range ( n ) ] <NEWLINE> x = resl2 . index ( min ( resl2 ) ) <NEWLINE> print ( aj [ x ] ) <NEWLINE>
n . l = map ( int , input ( ) . split ( ) ) <NEWLINE> al = [ l + i for i in range ( n ) ] <NEWLINE> a = min ( al , key = abs ) <NEWLINE> al . remove ( a ) <NEWLINE> print ( sum ( al ) ) <NEWLINE>
n , l = int ( input ( ) ) <NEWLINE> tastes = [ ( i + l ) for i in range ( n ) ] <NEWLINE> t = tastes . copy ( ) <NEWLINE> for j in range ( n ) : <NEWLINE> <INDENT> t [ j ] = abs ( t [ j ] ) <NEWLINE> <DEDENT> del tastes [ t . index ( min ( t ) ) ] <NEWLINE> print ( sum ( tastes ) ) <NEWLINE>
n , l = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> D = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> d = l + i <NEWLINE> D . append ( d ) <NEWLINE> <NL> <DEDENT> if l > - 1 : <NEWLINE> <INDENT> mind = D [ 0 ] <NEWLINE> <DEDENT> elif l + n < 0 : <NEWLINE> <INDENT> mind = D [ n - 1 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> mind = 0 <NEWLINE> <NL> <NL> <DEDENT> ans = sum ( D ) - mind <NEWLINE> print ( ans <NEWLINE>
L , L + 1 , L + 2 , ... , L + N - 1 <NEWLINE> N , L = list ( map ( lambda x : int ( x ) , input ( ) . split ( <STRING> ) ) ) <NEWLINE> <NL> S = int ( N * ( N - 1 ) / 2 ) + L * N <NEWLINE> <NL> if L >= 0 : <NEWLINE> <INDENT> print ( S - L ) <NEWLINE> <DEDENT> elif L + N - 1 <= 0 : <NEWLINE> <INDENT> print ( S - L - N + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( S ) <NEWLINE> <DEDENT>
n , l = map ( int , input ( ) . split ( ) ) <NEWLINE> t = list ( map ( lambda x : l + x , range ( n ) ) ) <NEWLINE> r = sum ( t ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> tmp = sum ( t [ : i ] + t [ i + 1 : ] ) <NEWLINE> dif_t = abs ( r - tmp ) <NEWLINE> if i == 0 : <NEWLINE> <INDENT> dif = dif_t <NEWLINE> <DEDENT> if dif_t < dif : <NEWLINE> <INDENT> ans = tmp <NEWLINE> dif = dif_t <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n , l = map ( int , input ( ) . split ( ) ) <NEWLINE> ls = [ ] <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> ls . append ( abs ( l - 1 + i ) ) <NEWLINE> <DEDENT> mi = l . index ( min ( ls ) ) <NEWLINE> print ( n * ( l - 1 ) + sum ( range ( 1 , n + 1 ) ) - l - mi ) <NEWLINE>
N , L = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <COMMENT> <NL> s = ( N - 1 ) * ( 2 * L + N - 1 ) // 2 <NEWLINE> l = [ abs ( s - ( L + i ) ) for i in range ( N ) ] <NEWLINE> m = min ( l ) <NEWLINE> print ( s - ( L + [ l . index ( m ) ] ) ) <NEWLINE>
N , L = map ( int , input ( ) . split ( ) ) <NEWLINE> <COMMENT> <NL> A = ( 2 L + N - 1 ) * N // 2 <NEWLINE> if L * ( L + N - 1 ) <= 0 : <NEWLINE> <INDENT> print ( A ) <NEWLINE> <DEDENT> elif L + N - 1 < 0 : <NEWLINE> <INDENT> print ( A - ( L + N - 1 ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( A - L ) <NEWLINE> <DEDENT>
n , l = map ( int , input ( ) . split ( ) ) <NEWLINE> a = sorted ( [ l + i for i in range ( n ) ] , key = abs ) <NEWLINE> print ( sum ( s [ 1 : ] ) ) <NEWLINE> <NL>
N , L = map ( int , input ( ) . split ( ) ) <NEWLINE> s = N * L + sum ( 1 , N + 1 ) - N <NEWLINE> K = [ ] <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> K . append ( L + i - 1 ) <NEWLINE> <DEDENT> if 0 <= K [ 0 ] : <NEWLINE> <INDENT> s -= K [ 0 ] <NEWLINE> <DEDENT> elif K [ 0 ] < 0 and K [ N - 1 ] > 0 : <NEWLINE> <INDENT> s = s <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s -= K [ N - 1 ] <NEWLINE> <DEDENT> print ( s ) <NEWLINE>
N , L = map ( int , input ( ) . split ( ) ) <NEWLINE> s = [ ] <NEWLINE> for i in N : <NEWLINE> <INDENT> s . append ( i + L ) <NEWLINE> <DEDENT> t = abs ( s ) <NEWLINE> del s [ t . index ( min ( s ) ) ] <NEWLINE> print ( sum ( s ) ) <NEWLINE>
import math <NEWLINE> <NL> A , B , C , D = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <NL> C_multiple = B // C - A // C <NEWLINE> D_multiple = B // D - A // D <NEWLINE> <NL> if A % C == 0 : <NEWLINE> <INDENT> C_multiple += 1 <NEWLINE> <DEDENT> if A % D == 0 : <NEWLINE> <INDENT> D_multiple += 1 <NEWLINE> <NL> <NL> <DEDENT> CD_gcd = C * D / math . gcd ( C , D ) <NEWLINE> CD_multiple = B // CD_gcd - A // CD_gcd <NEWLINE> if A % CD_gcd == 0 : <NEWLINE> <INDENT> CD_multiple += 1 <NEWLINE> <DEDENT> ** * <NEWLINE> print ( C_multiple ) <NEWLINE> print ( D_multiple ) <NEWLINE> print ( CD_gcd ) <NEWLINE> print ( CD_multiple ) <NEWLINE> ** * <NEWLINE> ans = ( B - A + 1 ) - ( C_multiple + D_multiple - CD_multiple ) <NEWLINE> print ( int ( ans ) ) <NEWLINE>
import math <NEWLINE> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> def calc ( n , c , d ) : <NEWLINE> <INDENT> return n - ( n / c + <NEWLINE> <INDENT> n / d - n / ( c * d / gcd ( c , d ) ) ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <INDENT> a , b , c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> print ( calc ( b , c , d ) - calc ( a - 1 , c , d ) ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> import fractions <NEWLINE> <NL> A , B , C , D = map ( int , input ( ) . split ( ) ) <NEWLINE> BA = np . arange ( A , B + 1 ) <NEWLINE> BA_C = BA % C <NEWLINE> BA_D = BA % D <NEWLINE> BA_CD = BA % ( C * D // fractions . gcd ( C , D ) ) <NEWLINE> <NL> C_count = np . count_nonzero ( BA_C == 0 ) <NEWLINE> D_count = np . count_nonzero ( BA_D == 0 ) <NEWLINE> CD_count = np . count_nonzero ( BA_CD == 0 ) <NEWLINE> <NL> print ( len ( BA ) - ( C_count + D_count - CD_count ) ) <NEWLINE>
l = [ ] <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> l . append ( abs ( l - 1 + i ) ) <NEWLINE> <DEDENT> mi = l . index ( min ( l ) ) <NEWLINE> print ( n * ( l - 1 ) + sum ( range ( 1 , n + 1 ) ) - l - mi ) <NEWLINE>
import math <NEWLINE> def lcm ( x , y ) : <NEWLINE> <INDENT> return ( x * y ) // math . gcd ( x , y ) <NEWLINE> <NL> <DEDENT> A , B , C , D = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> C_bai = list ( range ( A - ( A % C ) + C , B , C + 1 ) ) <NEWLINE> D_bai = list ( range ( A - ( A % D ) + D , B , D + 1 ) ) <NEWLINE> E = lcm ( C , D ) <NEWLINE> CD_bai = list ( range ( A - ( A % E ) + E , B , E + 1 ) ) <NEWLINE> print ( B - A + 1 - len ( C_bai ) - len ( D_bai ) + CD_bai ) <NEWLINE>
from math <NEWLINE> a , b , c , d = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a -= 1 <NEWLINE> def calculation ( x , c , d ) : <NEWLINE> <INDENT> x = x - ( x // c ) - ( x // d ) + ( x // ( ( c * d ) // math . gcd ( c , d ) ) ) <NEWLINE> return x <NEWLINE> <NL> <DEDENT> print ( calculation ( b , c , d ) - calculation ( a , c , d ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> <NL> A = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> A . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> <DEDENT> A . sort ( lambda x : x [ 1 ] , x [ 0 ] ) <NEWLINE> <NL> gokei = 0 <NEWLINE> for i in A : <NEWLINE> <INDENT> gokei += i [ 0 ] <NEWLINE> if gokei > i [ 1 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> AB = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( N ) ] <NEWLINE> <NL> sort_AB = sorted ( AB , key = lambda x : x [ 1 ] ) <NEWLINE> ans = <STRING> <NEWLINE> tmp = 0 <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> tmp += sortedAB [ i ] [ 0 ] <NEWLINE> if tmp > sortedAB [ i ] [ 1 ] : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> import math <NEWLINE> A , B , C , D = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <COMMENT> <NL> lcm = C * D // math . gcd ( C , D ) <NEWLINE> cnt_lcm = B // lcm - A // lcm <NEWLINE> <NL> <COMMENT> <NL> cnt_C = B // C - ( A - 1 ) // C <NEWLINE> <NL> <COMMENT> <NL> cnt_D = B // D - ( A - 1 ) // D <NEWLINE> <NL> <COMMENT> <NL> ans = ( B - A + 1 ) - ( cnt_C + cnt_D - cnt_lcm ) <NEWLINE> <NL> <COMMENT> <NL> if A == B : <NEWLINE> <COMMENT> <NL> <INDENT> if A % C == 0 and A % D == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> work = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ] <NEWLINE> work = sorted ( work , key = lambda x : x [ 1 ] ) <NEWLINE> a = [ 0 ] * n <NEWLINE> a [ 0 ] = work [ 0 ] [ 0 ] <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> a [ i ] = a [ i - 1 ] + work [ i ] [ 0 ] <NEWLINE> <DEDENT> ans = <STRING> <NEWLINE> for j in range ( N ) : <NEWLINE> <INDENT> if a [ j ] > work [ j ] [ 1 ] : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> ls = [ ] <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> ls . append ( [ b , a ] ) <NEWLINE> <DEDENT> ls = ls . sort ( ) <NEWLINE> t = 0 <NEWLINE> for i in ls : <NEWLINE> <INDENT> t += i [ 1 ] <NEWLINE> if t > i [ 0 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( 0 ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
5 <NEWLINE> 2 4 <NEWLINE> 1 9 <NEWLINE> 1 8 <NEWLINE> 4 9 <NEWLINE> 3 12 <NEWLINE>
from e import resolve <NEWLINE> import sys <NEWLINE> from io import StringIO <NEWLINE> import unittest <NEWLINE> <NL> <NL> class TestClass ( unittest . TestCase ) : <NEWLINE> <INDENT> def assertIO ( self , input , output ) : <NEWLINE> <INDENT> stdout , stdin = sys . stdout , sys . stdin <NEWLINE> sys . stdout , sys . stdin = StringIO ( ) , StringIO ( input ) <NEWLINE> resolve ( ) <NEWLINE> sys . stdout . seek ( 0 ) <NEWLINE> out = sys . stdout . read ( ) [ : - 1 ] <NEWLINE> sys . stdout , sys . stdin = stdout , stdin <NEWLINE> self . assertEqual ( out , output ) <NEWLINE> <NL> <DEDENT> def test__1 ( self ) : <NEWLINE> <INDENT> input = <STRING> <NEWLINE> output = <STRING> <NEWLINE> self . assertIO ( input , output ) <NEWLINE> <NL> <DEDENT> def test__2 ( self ) : <NEWLINE> <INDENT> input = <STRING> <NEWLINE> output = <STRING> <NEWLINE> self . assertIO ( input , output ) <NEWLINE> <NL> <DEDENT> def test__3 ( self ) : <NEWLINE> <INDENT> input = <STRING> <NEWLINE> output = <STRING> <NEWLINE> self . assertIO ( input , output ) <NEWLINE> <NL> <DEDENT> def test__4 ( self ) : <NEWLINE> <INDENT> input = <STRING> <NEWLINE> output = <STRING> <NEWLINE> self . assertIO ( input , output ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> unittest . main ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> import math <NEWLINE> import itertools <NEWLINE> import collections <NEWLINE> import heapq <NEWLINE> import re <NEWLINE> import numpy as np <NEWLINE> <NL> rr = lambda : sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> rs = lambda : sys . stdin . buffer . readline ( ) . split ( ) <NEWLINE> ri = lambda : int ( sys . stdin . readline ( ) ) <NEWLINE> rm = lambda : map ( int , sys . stdin . buffer . readline ( ) . split ( ) ) <NEWLINE> rl = lambda : list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) <NEWLINE> inf = float ( <STRING> ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> print ( 10 if ri ( ) >= ri ( ) else 0 ) <NEWLINE> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL>
X , A = map ( int ( input ( ) . split ( ) ) ) <NEWLINE> if X < A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 10 ) <NEWLINE> <DEDENT>
x , a = map ( int , input ( ) ) <NEWLINE> <NL> print ( <STRING> ) if x < a else print ( <STRING> ) <NEWLINE>
x , a = map ( int , input ( ) . split ( ) ) <NEWLINE> if x < a : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
x , a = map ( int , input ( ) . split ( ) ) <NEWLINE> if s < a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 10 ) <NEWLINE> <DEDENT>
def Input ( ) : <NEWLINE> <INDENT> return mapt ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> a , b = Input ( ) <NEWLINE> print ( 0 if a < b else 10 ) <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE>
W , H , x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> flg = 0 <NEWLINE> if W / 2 == x and H / 2 == y : <NEWLINE> <INDENT> ans = ( W * H ) / 2 <NEWLINE> flg = 1 <NEWLINE> <DEDENT> elif W / 2 == x or H / 2 == y : <NEWLINE> <INDENT> ans = ( W * H ) / 2 <NEWLINE> flg = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> tatemax = min ( W - x , x ) * H <NEWLINE> yokomax = min ( H - y , y ) * W <NEWLINE> if tatemax == yokomax : <NEWLINE> <INDENT> ans = tatemax <NEWLINE> flg = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = max ( tatemax , yokomax ) <NEWLINE> flg = 0 <NEWLINE> <DEDENT> <DEDENT> print ( str ( ans ) + <STRING> + str ( flg ) ) <NEWLINE>
x , a = map ( int , input ( ) ) <NEWLINE> if 0 < a < x : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 10 ) <NEWLINE> <DEDENT>
<NL> def main ( ) : <NEWLINE> <INDENT> x , a = map ( int , input ( ) . split ( ) ) <NEWLINE> if x < a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 10 i ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
x , a = map ( int , input ( ) . split ( ) ) <NEWLINE> pritn ( 0 if x < a else 10 ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if a [ 0 ] < b [ 1 ] : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 10 ) <NEWLINE> <DEDENT>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if x < a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 10 ) <NEWLINE> <DEDENT>
a , x = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( 10 if A >= X else 10 ) <NEWLINE>
X , A = int ( input ( ) ) <NEWLINE> if X < A : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 10 ) <NEWLINE> <DEDENT>
x , a = map ( int , input ( ) ) <NEWLINE> if x < a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 10 ) <NEWLINE> <DEDENT>
x , a = map ( int , input ( ) ) <NEWLINE> if x < a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 10 ) <NEWLINE> <DEDENT>
a , b = int ( input ( ) . split ( ) ) <NEWLINE> <COMMENT> <NL> if a < b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n , x = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> l = [ 0 ] * ( n + 1 ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> L [ i + 1 ] = l [ i ] + a [ i ] <NEWLINE> <DEDENT> ans = 0 <NEWLINE> for i in l : <NEWLINE> <INDENT> if i <= x : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n , x = map ( int , input ( ) . split ( ) ) <NEWLINE> arr = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> d = 0 <NEWLINE> ans = 1 <NEWLINE> for a in arr : <NEWLINE> <INDENT> d += arr <NEWLINE> if d <= x : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
a , b = input ( ) . split ( ) <NEWLINE> a = int ( a ) <NEWLINE> b = int ( b ) <NEWLINE> c = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> d = 0 <NEWLINE> for i in range ( a ) : <NEWLINE> <INDENT> while d < b : <NEWLINE> <INDENT> d = d + b [ i ] <NEWLINE> <DEDENT> print ( d ) <NEWLINE> break <NEWLINE> <DEDENT>
n , x = map ( int , input ( ) . split ( ) ) <NEWLINE> l = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> ans = 0 <NEWLINE> d = 0 <NEWLINE> for i in l : <NEWLINE> <INDENT> d += i <NEWLINE> ans += 1 <NEWLINE> if d > x : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> exit ( 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT>
LI = lambda : list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> N , X = LI ( ) <NEWLINE> L = LI ( ) <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> ans = X // L <NEWLINE> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n , x = map ( int , input ( ) . split ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> cnt = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if cnt + l [ i ] <= x : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> cnt += l [ i ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> <NL> n , x = map ( int , input ( ) . split ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> d = 1 <NEWLINE> count = 1 <NEWLINE> <NL> for y in range ( n ) : <NEWLINE> <INDENT> d = d + l [ n ] <NEWLINE> if d <= x : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( count ) <NEWLINE> <NL> <NL>
n , x = map ( int , input ( ) . split ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> d = 0 <NEWLINE> count = 1 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> d += n [ i ] <NEWLINE> if d <= x : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
n , x = map ( int , input ( ) . split ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> s = 0 <NEWLINE> count = 1 <NEWLINE> for i in L : <NEWLINE> <INDENT> s += i <NEWLINE> if s > x : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> count += 1 <NEWLINE> <DEDENT> print ( count ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> from fractions import gcd <NEWLINE> from itertools import combinations , permutations , accumulate , product <COMMENT> <NEWLINE> <COMMENT> <NL> from collections import deque , defaultdict , Counter <NEWLINE> import decimal <NEWLINE> import re <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> import sys <NEWLINE> sys . setrecursionlimit ( 10000000 ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <COMMENT> <NL> def readInts ( ) : <NEWLINE> <INDENT> return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <DEDENT> def I ( ) : <NEWLINE> <INDENT> return int ( input ( ) ) <NEWLINE> <DEDENT> n , x = readInts ( ) <NEWLINE> L = readInts ( ) <NEWLINE> cnt = 0 <NEWLINE> now = 0 <NEWLINE> while now <= x : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> now += L [ cnt - 1 ] <NEWLINE> <DEDENT> print ( cnt ) <NEWLINE>
N , X = map ( int , input ( ) . split ( ) ) <NEWLINE> l = [ 0 ] <NEWLINE> l . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> sum = 0 <NEWLINE> for i in range ( N + 1 ) : <NEWLINE> <INDENT> sum += l [ i ] <NEWLINE> if sum > X : <NEWLINE> <INDENT> print ( i ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( N + 1 ) <NEWLINE>
n , x = map ( int . input ( ) . split ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> sum = 0 <NEWLINE> ans = 0 <NEWLINE> for i in l : <NEWLINE> <INDENT> sum += i <NEWLINE> if sum <= x : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT>
W , H , x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <COMMENT> <NL> if x == W / 2 and y == H / 2 : <NEWLINE> <INDENT> area = <STRING> . format ( float ( x * H ) ) <NEWLINE> print ( area , 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> area = <STRING> . format ( float ( min ( W - x ) * H , x * H ) ) <NEWLINE> print ( area , 0 ) <NEWLINE> <DEDENT>
import bisect <NEWLINE> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = tuple ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> s = [ 0 ] * ( N + 1 ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> s [ i + 1 ] = s [ i ] + A [ i ] <NEWLINE> <DEDENT> ans = 0 <NEWLINE> for b in range ( N ) : <NEWLINE> <INDENT> i = bisect . bisect_left ( s , K + s [ b ] , b ) <NEWLINE> ans += ( N + 1 - i ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
w , h , x , y = map ( int , input ( ) split ( ) ) <NEWLINE> area = w * h / 2 <NEWLINE> if x == w / 2 and y == h / 2 : <NEWLINE> <INDENT> print ( area , <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( area , <STRING> ) <NEWLINE> <DEDENT>
W , H , x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> if y == H * x / W or y == H - H * x / W : <NEWLINE> <INDENT> print ( W * H , 1. split ( ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( W * H , 0. split ( ) ) <NEWLINE> <DEDENT>
w , h , x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( ( w * h ) / 2 , ( 2 x == w ) & ( 2 y == h ) ) <NEWLINE>
W , H , x , y = list ( map ( lambda n : int ( n ) , input ( ) . split ( <STRING> ) ) ) <NEWLINE> <NL> S = W * H / 2 <NEWLINE> flag = 1 if W == 2 * x and H == 2 * y else flag = 0 <NEWLINE> print ( S , end = <STRING> ) <NEWLINE> print ( flag ) <NEWLINE>
W , H , x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> ans1 = W * H / 2 <NEWLINE> cen_x , cen_y = W / 2 , H / 2 <NEWLINE> if cen_x == x and cen_y == y : <NEWLINE> <INDENT> ans2 = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans2 = 0 <NEWLINE> <DEDENT> print ( ans1 + <STRING> + ans2 ) <NEWLINE>
<COMMENT> <NL> <NL> w , h , x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> core = ( w / 2 , h / 2 ) <NEWLINE> base = h / w <NEWLINE> slope = ( core [ 1 ] - y ) / ( core [ 0 ] - x ) <NEWLINE> <NL> multi = ( base >= slope and y == core [ 1 ] ) or ( base < slope and x == core [ 0 ] ) <NEWLINE> <NL> print ( w * h / 2 , 1 if multi else 0 ) <NEWLINE>
w , h , x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> candi = [ x , y , w - x , h - y ] <NEWLINE> cnt = 0 <NEWLINE> if min ( candi ) == x : <NEWLINE> <INDENT> res = x * h <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> if min ( candi ) == y : <NEWLINE> <INDENT> res = w * y <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> if min ( candi ) == w - x : <NEWLINE> <INDENT> res = ( w - x ) * h <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> if min ( candi ) = h - y : <NEWLINE> <INDENT> res = w * ( h - y ) <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> if cnt > 0 : <NEWLINE> <INDENT> cnt = 1 <NEWLINE> <DEDENT> print ( res , cnt ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> <NL> w , h , x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> area = max ( min ( w * y , w * ( h - y ) ) , min ( x * h , ( w - x ) * h ) ) <NEWLINE> is_multi = 0 <NEWLINE> <NL> if x == w // 2 and y == h // 2 <NEWLINE> <INDENT> is_multi = 1 <NEWLINE> <NL> <DEDENT> print ( area , is_multi ) <NEWLINE>
W , H , x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if W == 0 or H == 0 : <NEWLINE> <NL> elif x == W / 2 and y == H / 2 : <NEWLINE> <INDENT> print ( W * H / 2 , 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( W * H / 2 , 0 ) <NEWLINE> <DEDENT>
<NL> s = w * h <NEWLINE> <NL> if ( w - x ) * h > ( h - y ) * w : <NEWLINE> <INDENT> print ( float ( ( w - x ) ) * h , end = <STRING> ) <NEWLINE> print ( 0 ) <NEWLINE> <DEDENT> elif ( w - x ) * h == ( h - y ) * w : <NEWLINE> <INDENT> print ( float ( ( w - x ) ) * h , end = <STRING> ) <NEWLINE> print ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( float ( ( h - y ) ) * w , end = <STRING> ) <NEWLINE> print ( 0 ) <NEWLINE> <DEDENT>
w , h , x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> judge = ( w == 2 * x and h == 2 * y ) <NEWLINE> s = w * h / 2 <NEWLINE> print ( area , 1 if judge else 0 ) <NEWLINE>
T , Y , x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> a = <STRING> <NEWLINE> if T / 2 == x & Y / 2 == y : <NEWLINE> <INDENT> a = <STRING> <NEWLINE> <DEDENT> print ( T * Y / 2 , a ) <NEWLINE>
w , h , x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> a = 0 <NEWLINE> if ( h == 2 * x and w == 2 * y ) <NEWLINE> a += 1 <NEWLINE> print ( w * h / 2 , a ) <NEWLINE>
import collections <NEWLINE> W , H , x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> tmp = [ ] <NEWLINE> <NL> if W == x * 2 : <NEWLINE> <INDENT> print ( x * H , 1 ) <NEWLINE> <DEDENT> elif H == y * 2 : <NEWLINE> <INDENT> print ( W * y , 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> tmp . append ( min ( H * x , H * ( W - x ) ) ) <NEWLINE> tmp . append ( min ( W * y , W * ( H - y ) ) ) <NEWLINE> <NL> <DEDENT> tmp_cnt = collections . Counter ( tmp ) <NEWLINE> print ( tmp_cnt ) <NEWLINE> <NL> if len ( tmp_cnt ) == 1 : <NEWLINE> <INDENT> print ( max ( tmp_cnt . keys ( ) ) , 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( max ( tmp_cnt . keys ( ) ) , 0 ) <NEWLINE> <DEDENT>
W , H , x , y = list ( map ( float , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = W * H <NEWLINE> ans = float ( float ( ans ) / 2.0 ) <NEWLINE> ans2 = 0 <NEWLINE> if x == float ( float ( W ) / 2 ) and y == float ( float ( H ) / 2 ) : <NEWLINE> <INDENT> ans2 = 1 <NEWLINE> <NL> <DEDENT> print ( ans + <STRING> + ans2 ) <NEWLINE>
W , H , x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( W * H * 0.5 , int ( x = W * 0.5 and y = H * 0.5 ) ) <NEWLINE>
w , h = map ( int , input ( ) . split ( ) ) <NEWLINE> cx , cy = w / 2 , h / 2 <NEWLINE> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> if x == cx and y == cy : <NEWLINE> <INDENT> print ( w * h / 2 , 1 ) ; exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( w * h / 2 , 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT>
from numba import njit <NEWLINE> <NL> MOD = 10 ** 9 + 7 <NEWLINE> <NL> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> S = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> T = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> @ njit <NEWLINE> def solve ( N , M , S , T ) : <NEWLINE> <INDENT> dp = [ [ 1 ] * ( M + 1 ) for _ in range ( N + 1 ) ] <NEWLINE> for i , s in enumerate ( S ) : <NEWLINE> <INDENT> for j , t in enumerate ( T ) : <NEWLINE> <INDENT> dp [ i + 1 ] [ j + 1 ] = dp [ i + 1 ] [ j ] + dp [ i ] [ j + 1 ] <NEWLINE> if s != t : <NEWLINE> <INDENT> dp [ i + 1 ] [ j + 1 ] -= dp [ i ] [ j ] <NEWLINE> <DEDENT> dp [ i + 1 ] [ j + 1 ] %= MOD <NEWLINE> <DEDENT> <DEDENT> return dp [ M ] [ N ] <NEWLINE> <NL> <DEDENT> print ( solve ( N , M , S , T ) ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> if k == 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else <NEWLINE> <INDENT> print ( n - k ) <NEWLINE> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if k = 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <NL> <INDENT> ans = n - k <NEWLINE> print ( ans ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> xy = [ lnii ( ) for i in range ( n ) ] <NEWLINE> xy . sort ( key = lambda x : x [ 0 ] ) <NEWLINE> <NL> ans = n <NEWLINE> <NL> pq = [ ] <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n ) : <NEWLINE> <INDENT> t_p = xy [ j ] [ 0 ] - xy [ i ] [ 0 ] <NEWLINE> t_q = xy [ j ] [ 1 ] - xy [ i ] [ 1 ] <NEWLINE> pq . append ( [ t_p , t_q ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> for p , q in pq : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( n ) : <NEWLINE> <INDENT> if i == j : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> x1 , y1 = xy [ i ] <NEWLINE> x2 , y2 = xy [ j ] <NEWLINE> if ( x2 - x1 ) == p and ( y2 - y1 ) == q : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> ans = min ( ans , n - cnt ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
from collections import defaultdict , deque <NEWLINE> import sys <NEWLINE> <COMMENT> <NL> def inpl ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = sorted ( inpl ( ) ) <NEWLINE> <NL> print ( a [ - 1 ] - sum ( map ( abs , A [ 1 : - 1 ] ) ) - A [ 0 ] ) <NEWLINE> for i in range ( N - 2 , 0 , - 1 ) : <NEWLINE> <INDENT> a = A [ i ] <NEWLINE> if a > 0 : <NEWLINE> <INDENT> print ( A [ 0 ] , a ) <NEWLINE> A [ 0 ] -= a <NEWLINE> else : <NEWLINE> print ( A [ - 1 ] , a ) <NEWLINE> A [ - 1 ] -= a <NEWLINE> print ( A [ - 1 ] , A [ 0 ] ) <NEWLINE> <DEDENT> <DEDENT>
a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( min ( min ( a + b , b + c ) , a + c ) <NEWLINE>
a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( sum ( a , b , c ) - max ( a , b , c ) ) <NEWLINE>
a , b , c = map ( input ( ) . split ( ) ) <NEWLINE> <NL> print ( min ( a + b , a + c , b + c ) ) <NEWLINE>
ary = list ( map ( lambda n : int ( n ) , input ( ) . split ( <STRING> ) ) ) . sort ( reverse = True ) <NEWLINE> <NL> print ( ary [ 0 ] + ary [ 1 ] ) <NEWLINE>
* A = map ( int , input ( ) . split ( ) ) <NEWLINE> A . sort ( ) <NEWLINE> print ( A [ 0 ] + A [ 1 ] ) <NEWLINE>
p , q , r = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> print ( sum [ p , q , r ] - max [ p , q , r ] ) <NEWLINE>
p = int ( input ( ) ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> r = int ( input ( ) ) <NEWLINE> if p + q < q + r and p + q < p + r : <NEWLINE> <INDENT> print ( p + q ) <NEWLINE> <DEDENT> if p + r < p + q and p + r < q + r : <NEWLINE> <INDENT> print ( p + r ) <NEWLINE> <DEDENT> if q + r < p + r and q + r < p + q : <NEWLINE> <INDENT> print ( q + r ) <NEWLINE> <DEDENT>
print ( sum ( sorted ( list ( map ( int , input ( ) . split ( ) ) [ : 2 ] ) ) ) ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> a , b , c = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> print ( sum ( [ a , b , c ] ) - , max ( a , b , c ) ) <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE>
a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = a . sorted ( ) <NEWLINE> print ( int ( b [ 0 ] ) + int ( b [ 1 ] ) ) <NEWLINE>
p , g , r = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( min ( p + q , q + r , r + p ) ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> p , q , r = map ( int , input ( ) . split ) <NEWLINE> min_time = min ( [ p + q , q + r , r + p ] ) <NEWLINE> print ( min_time ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
is = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> print ( sorted ( lis ) [ 0 ] + sorted ( lis ) [ 1 ] ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> W = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> ans = sum ( W ) <NEWLINE> s = ans <NEWLINE> t = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> s -= W [ i ] <NEWLINE> t += W [ i ] <NEWLINE> ans = min ( abs ( s - t ) ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
count = int ( input ( ) ) <NEWLINE> arr = input ( ) . split ( ) <NEWLINE> s1 = 0 <NEWLINE> s2 = 0 <NEWLINE> for i in arr : <NEWLINE> <INDENT> s2 += int ( i ) <NEWLINE> <DEDENT> minimum_diff = s2 <NEWLINE> for i in range ( 0 , count ) : <NEWLINE> <INDENT> s1 += arr [ i ] <NEWLINE> s2 -= arr [ i ] <NEWLINE> minimum_diff = min ( minimum_diff , abs ( s1 - s2 ) ) <NEWLINE> <DEDENT>
N = input ( ) <NEWLINE> W = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> sum1 , sum2 = 0 , 0 <NEWLINE> ans = 0 <NEWLINE> dif = 1000 <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> sum1 = sum ( W [ 0 : i ] ) <NEWLINE> sum2 = sum ( W [ i : ] ) <NEWLINE> now = abs ( sum1 - sum2 ) <NEWLINE> if dif > now : <NEWLINE> <INDENT> dif = now <NEWLINE> <NL> <DEDENT> <DEDENT> print ( dif ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> W = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> m = 10 ** 10 <NEWLINE> for i in range ( 1 , W ) : <NEWLINE> <INDENT> m = min ( m , abs ( sum ( W [ : i ] ) , sum ( W [ i : ] ) ) ) <NEWLINE> <NL> <DEDENT> print ( m ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> arr = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> res = [ ] <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> res . append ( abs ( sum ( arr [ : i + 1 ] ) - arr ( W [ i + 1 : ] ) ) ) <NEWLINE> <DEDENT> print ( min ( res ) ) <NEWLINE>
import sys <NEWLINE> import math <NEWLINE> import itertools <NEWLINE> import collections <NEWLINE> import heapq <NEWLINE> import re <NEWLINE> import numpy as np <NEWLINE> <NL> rr = lambda : sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> rs = lambda : sys . stdin . readline ( ) . split ( ) <NEWLINE> ri = lambda : int ( sys . stdin . readline ( ) ) <NEWLINE> rm = lambda : map ( int , sys . stdin . readline ( ) . split ( ) ) <NEWLINE> rl = lambda : list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) <NEWLINE> inf = float ( <STRING> ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> n , li = ri ( ) , rl ( ) <NEWLINE> min_ = inf <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> min_ = min ( abs ( sum ( li [ 0 : i ] - li [ i : ] ) ) ) <NEWLINE> <DEDENT> print ( min_ ) <NEWLINE> <NL> <NL> <NL> <NL>
N = int ( input ( ) ) <NEWLINE> * W , = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> s1 , s2 = 0 , sum [ W ] <NEWLINE> ans = sum [ W ] <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> s1 += W [ i ] <NEWLINE> s2 -= W [ i ] <NEWLINE> ans = min ( ans , abs ( s1 - s2 ) ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A = [ ] <NEWLINE> for i in range ( 1 , N - 1 ) : <NEWLINE> <INDENT> A . append ( abs ( S [ : i ] - S [ i : ] ) ) <NEWLINE> <DEDENT> print ( min ( A ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> mlist = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> nlist = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> nlist . append ( abs ( mlist [ : i ] - mlist [ i : ] ) ) <NEWLINE> <DEDENT> print ( min ( nlist ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> W = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> L = [ ] <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> L . append ( abs ( sum ( N [ : i ] ) - sum ( N [ i : ] ) ) ) <NEWLINE> <DEDENT> print ( min ( L ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> list1 = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> great = 9999999 <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> temp = int ( abs ( sum ( list1 [ : i + 1 ] ) - sum ( list1 [ i + 1 : ] ) ) ) <NEWLINE> if temp < great : <NEWLINE> <INDENT> great = temp <NEWLINE> <DEDENT> <DEDENT> print ( samin ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> s = [ ] <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> s . append ( abs ( a [ : i ] - a [ i : ] ) ) <NEWLINE> <DEDENT> print ( min ( s ) ) <NEWLINE>
from itertools import product <NEWLINE> <NL> def mat2_mul ( X , Y ) : <NEWLINE> <INDENT> z = [ [ 0 , 0 ] , [ 0 , 0 ] ] <NEWLINE> for ( i , j , k ) in product ( range ( 2 ) , range ( 2 ) , range ( 2 ) ) : <NEWLINE> <INDENT> z [ i ] [ j ] += X [ i ] [ k ] * Y [ k ] [ j ] <NEWLINE> <DEDENT> return z <NEWLINE> <NL> <DEDENT> def mat2_pow ( X , n ) : <NEWLINE> <INDENT> if n == 0 : <NEWLINE> <INDENT> return [ [ 1 , 0 ] , [ 0 , 1 ] ] <NEWLINE> <DEDENT> elif n % 2 : <NEWLINE> <INDENT> return mat2_mul ( X , mat2_pow ( X , n - 1 ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> half_pow = mat2_pow ( X , n / 2 ) <NEWLINE> return mat2_mul ( half_pow , half_pow ) <NEWLINE> <NL> <DEDENT> <DEDENT> def fib ( n ) : <NEWLINE> <INDENT> if n == 0 : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> f = [ [ 0 , 1 ] , [ 1 , 1 ] ] <NEWLINE> <DEDENT> return mat2_pow ( f , n - 1 ) [ 1 ] [ 1 ] <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> mlis = [ ] <NEWLINE> for _ in range ( m ) : <NEWLINE> <INDENT> a = int ( input ( ) ) <NEWLINE> mlis . append ( a ) <NEWLINE> <DEDENT> ans = 1 <NEWLINE> mae = 0 <NEWLINE> <NL> infi = 10 ** 9 + 7 <NEWLINE> for num in mlis : <NEWLINE> <INDENT> ans *= fibona ( num - mae ) <NEWLINE> ans %= infi <NEWLINE> mae = num + 1 <NEWLINE> <NL> <DEDENT> nobori = n - mae + 1 <NEWLINE> ans *= fibona ( nobori ) <NEWLINE> ans %= infi <NEWLINE> print ( int ( ans ) ) <NEWLINE> <NL> <NL> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> from collections import defaultdict <NEWLINE> <NL> stairs = [ ] <NEWLINE> steps = [ ] <NEWLINE> MOD = 1000000007 <NEWLINE> <NL> n , m = int ( input ( ) ) , int ( ( input ( ) ) ) <NEWLINE> stairs = { int ( input ( ) ) : True for i in range ( m ) } <NEWLINE> <NL> step = defaultdict ( int ) <NEWLINE> step [ 0 ] = 1 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> if i in stairs . keys ( ) : <NEWLINE> <INDENT> step [ i ] = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> step [ i + 1 ] = ( step [ i ] + step [ i + 1 ] ) % MOD <NEWLINE> step [ i + 2 ] = ( step [ i ] + step [ i + 2 ] ) % MOD <NEWLINE> <NL> <DEDENT> <DEDENT> print ( step [ n ] ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> lis = [ 0 ] * n + 1 <NEWLINE> a = [ ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> a . append ( int ( input ( ) ) ) <NEWLINE> <NL> <DEDENT> mod = 10 ** 9 + 7 <NEWLINE> ans = 0 <NEWLINE> if n == 1 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> elif n == 2 : <NEWLINE> <INDENT> if m == 1 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 2 ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if 1 in a and 2 in a : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> elif 1 in a : <NEWLINE> <INDENT> lis [ 1 ] = 1 <NEWLINE> <DEDENT> elif 2 in a : <NEWLINE> <INDENT> lis [ 0 ] = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> lis [ 0 ] = 1 <NEWLINE> lis [ 1 ] = 2 <NEWLINE> <NL> <DEDENT> for j in range ( 3 , n + 1 ) : <NEWLINE> <INDENT> if j in a : <NEWLINE> <INDENT> lis [ 0 ] = lis [ 1 ] <NEWLINE> lis [ 1 ] = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = lis [ 0 ] % mod + lis [ 1 ] % mod <NEWLINE> lis [ 0 ] = lis [ 1 ] <NEWLINE> lis [ 1 ] = ans <NEWLINE> <NL> <DEDENT> if lis [ 0 ] == 0 and lis [ 1 ] == 0 : <NEWLINE> <INDENT> ans = 0 <NEWLINE> break <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> print ( ans % mod ) <NEWLINE> <DEDENT>
import sys <NEWLINE> import math <NEWLINE> import itertools <NEWLINE> import bisect <NEWLINE> from copy import copy <NEWLINE> from collections import deque , Counter <NEWLINE> from decimal import Decimal <NEWLINE> def s ( ) : return input ( ) <NEWLINE> def k ( ) : return int ( input ( ) ) <NEWLINE> def S ( ) : return input ( ) . split ( ) <NEWLINE> def I ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def X ( ) : return list ( input ( ) ) <NEWLINE> def L ( ) : return list ( input ( ) . split ( ) ) <NEWLINE> def l ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> def lcm ( a , b ) : return a * b // math . gcd ( a , b ) <NEWLINE> def gcd ( * numbers ) : reduce ( math . gcd , numbers ) <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> count = 0 <NEWLINE> ans = 0 <NEWLINE> inf = float ( <STRING> ) <NEWLINE> <NL> def dpp ( n ) : <NEWLINE> <INDENT> for i in range ( 2 , n + 1 ) : <NEWLINE> <INDENT> if a [ i ] = 0 : <NEWLINE> <INDENT> dp [ i ] = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dp [ i ] = dp [ i - 1 ] + dp [ i - 2 ] <NEWLINE> <DEDENT> <DEDENT> return dp [ n ] <NEWLINE> <NL> <DEDENT> N , M = I ( ) <NEWLINE> a = [ 1 ] * ( N + 1 ) <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> x = k ( ) <NEWLINE> a [ x ] = 0 <NEWLINE> <NL> <DEDENT> dp = [ 0 ] * ( N + 1 ) <NEWLINE> if 1 in a : <NEWLINE> <INDENT> dp [ 1 ] = 0 <NEWLINE> dp [ 0 ] = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dp [ 0 ] = dp [ 1 ] = 1 <NEWLINE> <NL> <DEDENT> print ( dpp ( N ) % mod ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ int ( input ( ) ) for _ in range ( M ) ] <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> <NL> dp = [ 0 ] * ( N + 1 ) <NEWLINE> dp [ 0 ] = 1 <NEWLINE> dp [ 1 ] = 1 if 1 not in a else 0 <NEWLINE> <NL> a = list ( set ( range ( 2 , N + 2 ) ) - set ( a ) ) <NEWLINE> for i in a : <NEWLINE> <INDENT> dp [ i ] = ( dp [ i - 1 ] + dp [ i - 2 ] ) % MOD <NEWLINE> <DEDENT> print ( dp [ N ] % MOD ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> a = set ( [ int ( input ( ) ) for j in range ( m ) ] ) <NEWLINE> dp = [ 0 ] * ( n + 1 ) <NEWLINE> dp [ 0 ] = 1 <NEWLINE> if not a [ 0 ] == 1 : <NEWLINE> <INDENT> dp [ 1 ] = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dp [ 1 ] = 0 <NEWLINE> <DEDENT> for i in range ( n - 1 ) : <NEWLINE> <INDENT> if i + 2 in a : <NEWLINE> <INDENT> dp [ i + 2 ] = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dp [ i + 2 ] = ( dp [ i + 1 ] + dp [ i ] ) % ( 10 ** 9 + 7 ) <NEWLINE> <DEDENT> <DEDENT> print ( dp [ n ] ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> issafe = [ True ] * n + 1 <NEWLINE> for _ in range ( m ) : <NEWLINE> <INDENT> a = int ( input ( ) ) <NEWLINE> issafe [ a ] = False <NEWLINE> <NL> <DEDENT> dp = [ 0 ] * n + 1 <NEWLINE> dp [ 0 ] = 1 <NEWLINE> if issafe [ 1 ] : <NEWLINE> <INDENT> dp [ 1 ] = 1 <NEWLINE> <NL> <DEDENT> for i in range ( 2 , n + 1 ) : <NEWLINE> <INDENT> if issafe [ i - 1 ] : <NEWLINE> <INDENT> dp [ i ] = dp [ i ] + dp [ i - 1 ] <NEWLINE> <DEDENT> if issafe [ i - 2 ] : <NEWLINE> <INDENT> dp [ i ] = dp [ i - 2 ] + dp [ i ] <NEWLINE> <NL> <DEDENT> dp [ i ] %= 1000000007 <NEWLINE> <NL> <DEDENT> print ( dp [ n ] ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ int ( input ( ) ) for _ in range ( m ) ] <NEWLINE> ans = 1 <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> MAX = 10 ** 5 + 1 <NEWLINE> fact = [ 1 ] * MAX <NEWLINE> <NL> for i , j in zip ( a [ : m - 1 ] , a [ 1 : ] ) : <NEWLINE> <INDENT> if j - i == 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> def comb_init ( ) : <NEWLINE> <INDENT> fact [ 0 ] , fact [ 1 ] = 1 , 1 <NEWLINE> for i in range ( 2 , MAX ) : <NEWLINE> <INDENT> fact [ i ] = fact [ i - 1 ] * i <NEWLINE> <NL> <DEDENT> <DEDENT> def comb ( n , r ) : <NEWLINE> <INDENT> return ( fact [ n ] % MOD ) * pow ( fact [ r ] , - 1 , MOD ) * pow ( fact [ n - r ] , - 1 , MOD ) <NEWLINE> <NL> <DEDENT> def f ( k ) : <NEWLINE> <INDENT> idx = k // 2 <NEWLINE> num = 0 <NEWLINE> for i in range ( 1 , idx + 1 ) : <NEWLINE> <INDENT> num += comb ( k - i , i ) <NEWLINE> num %= MOD <NEWLINE> <DEDENT> return num + 1 <NEWLINE> <NL> <DEDENT> comb_init ( ) <NEWLINE> for i in range ( m + 1 ) : <NEWLINE> <INDENT> left = 0 if i == 0 else a [ i - 1 ] + 1 <NEWLINE> right = n if i == m else a [ i ] - 1 <NEWLINE> between = right - left <NEWLINE> ans *= f ( between ) <NEWLINE> ans %= MOD <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( int ( input ( ) ) for _ in range ( m ) ) <NEWLINE> dp = [ [ ] for _ in range ( n + 1 ) ] <NEWLINE> dp [ 0 ] = 1 <NEWLINE> <COMMENT> <NL> if m = 0 : <NEWLINE> <INDENT> dp [ 1 ] = 1 <NEWLINE> for i in range ( 2 , n + 1 ) : <NEWLINE> <INDENT> dp [ i ] = ( dp [ i - 1 ] + dp [ i - 2 ] ) % 1000000007 <NEWLINE> <DEDENT> print ( dp [ n ] ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> if a [ 0 ] == 1 : <NEWLINE> <INDENT> dp [ 1 ] = 0 <NEWLINE> j = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dp [ 1 ] = 1 <NEWLINE> j = 0 <NEWLINE> <DEDENT> for i in range ( 2 , n + 1 ) : <NEWLINE> <COMMENT> <NL> <INDENT> if j < m : <NEWLINE> <INDENT> if a [ j ] == i : <NEWLINE> <INDENT> dp [ i ] = 0 <NEWLINE> j += 1 <NEWLINE> continue <NEWLINE> <DEDENT> <DEDENT> dp [ i ] = ( dp [ i - 1 ] + dp [ i - 2 ] ) % 1000000007 <NEWLINE> <DEDENT> print ( dp [ n ] ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ True ] * n <NEWLINE> for _ in range ( m ) : <NEWLINE> <INDENT> a = int ( input ( ) ) <NEWLINE> A [ a ] = False <NEWLINE> <NL> <DEDENT> mod = 10 ** 9 + 7 <NEWLINE> dp = [ 0 ] * ( n + 1 ) <NEWLINE> dp [ 0 ] = 1 <NEWLINE> if A [ 1 ] : <NEWLINE> <INDENT> dp [ 1 ] = 1 <NEWLINE> <NL> <DEDENT> for i in range ( 2 , n + 1 ) : <NEWLINE> <INDENT> if A [ i ] : <NEWLINE> <INDENT> dp [ i ] = dp [ i - 1 ] + dp [ i - 2 ] <NEWLINE> dp [ i ] %= mod <NEWLINE> <NL> <DEDENT> <DEDENT> print ( dp [ n ] ) <NEWLINE> <NL> <NL>
import sys <NEWLINE> import numpy as np <NEWLINE> <NL> <NL> def read ( ) : <NEWLINE> <INDENT> return sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> h , w = map ( int , read ( ) . split ( ) ) <NEWLINE> s = np . array ( [ [ i == <STRING> for i in read ( ) ] for _ in range ( h ) ] , dtype = int ) <NEWLINE> left = s . copy ( ) <NEWLINE> right = s . copy <NEWLINE> up = s . copy <NEWLINE> down = s . copy <NEWLINE> for i in range ( w - 1 ) : <NEWLINE> <INDENT> left [ : , i + 1 ] = ( left [ : , i ] + 1 ) * s [ : , i + 1 ] <NEWLINE> right [ : , - i - 2 ] = ( right [ : , - i - 1 ] + 1 ) * s [ : , - i - 2 ] <NEWLINE> <DEDENT> for i in range ( h - 1 ) : <NEWLINE> <INDENT> up [ i + 1 ] = ( up [ i ] + 1 ) * s [ i + 1 ] <NEWLINE> down [ - i - 2 ] = ( down [ - i - 1 ] + 1 ) * s [ - i - 2 ] <NEWLINE> <DEDENT> print ( ( left + right + up + down ) . max ( ) - 3 ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n , a , b , c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> S = list ( input ( ) ) <NEWLINE> S = [ <STRING> ] . expand ( S ) <NEWLINE> print ( S ) <NEWLINE> <NL> flg = 1 <NEWLINE> for i in range ( a - 1 , c - 2 ) : <NEWLINE> <INDENT> if S [ i : i + 2 ] == [ <STRING> , <STRING> ] : <NEWLINE> <INDENT> flg *= 0 <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( b - 1 , d - 2 ) : <NEWLINE> <INDENT> if S [ i : i + 2 ] == [ <STRING> , <STRING> ] : <NEWLINE> <INDENT> flg *= 0 <NEWLINE> <NL> <DEDENT> <DEDENT> if c > d : <NEWLINE> <INDENT> flg2 = 0 <NEWLINE> for i in range ( b - 1 , d ) : <NEWLINE> <INDENT> if S [ i - 1 : i + 2 ] == [ <STRING> , <STRING> , <STRING> ] : <NEWLINE> <INDENT> flg2 = 1 <NEWLINE> <DEDENT> <DEDENT> flg *= flg2 <NEWLINE> <NL> <DEDENT> if flg == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import bisect , copy , heapq , itertools , string <NEWLINE> from collections import * <NEWLINE> from math import * <NEWLINE> import sys <NEWLINE> def input ( ) : return sys . stdin . readline ( ) . strip ( ) <NEWLINE> def INT ( ) : return int ( input ( ) ) <NEWLINE> def MAP ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def LIST ( ) : return list ( MAP ( ) ) <NEWLINE> <NL> n , a , b , c , d = MAP ( ) <NEWLINE> s = input ( ) <NEWLINE> <NL> flag = 0 <NEWLINE> for i in range ( min ( a , b ) + 1 , max ( c , d ) ) : <NEWLINE> <INDENT> if ( a < i < c or b < i < d ) and s [ i ] == s [ i - 1 ] == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> elif max ( a , b ) <= i <= min ( c , d ) and s [ i - 1 ] == s [ i ] == s [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> flag = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if c > d and flag == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N , A , B , C , D = map ( int , input ( ) . split ( ) ) <NEWLINE> N -= 1 <NEWLINE> A -= 1 <NEWLINE> B -= 1 <NEWLINE> C -= 1 <NEWLINE> D -= 1 <NEWLINE> S = input ( ) <NEWLINE> <NL> massesExist = True <NEWLINE> overtakeFlag = False if C > D else True <NEWLINE> proceedableFlag = True <NEWLINE> <NL> if max ( A , B , C , D ) > N : <NEWLINE> <INDENT> massesExist = False <NEWLINE> <NL> <DEDENT> for i in range ( B , D + 1 ) : <NEWLINE> <INDENT> if S [ i - 1 ] == <STRING> and S [ i ] == <STRING> and S [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> overtakeFlag = True <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( A , max ( C , D ) - 1 ) : <NEWLINE> <INDENT> if S [ i ] == <STRING> and S [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> proceedableFlag = False <NEWLINE> <NL> <DEDENT> <DEDENT> if overtakeFlag and proceedableFlag and massesExist : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s = [ 0 ] + list ( input ( ) ) <NEWLINE> if c < d : <NEWLINE> <INDENT> for i in range ( a , d ) : <NEWLINE> <INDENT> if s [ i ] == s [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for j in range ( a , c ) : <NEWLINE> <INDENT> if s [ j ] == s [ j + 1 ] == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for k in range ( b - 1 , d - 2 ) : <NEWLINE> <INDENT> if s [ k ] == s [ k + 1 ] == s [ k + 2 ] == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
from collections import defaultdict <NEWLINE> from collections import deque <NEWLINE> from collections import Counter <NEWLINE> import itertools <NEWLINE> import math <NEWLINE> <NL> def readInt ( ) : <NEWLINE> <INDENT> return int ( input ( ) ) <NEWLINE> <DEDENT> def readInts ( ) : <NEWLINE> <INDENT> return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <DEDENT> def readChar ( ) : <NEWLINE> <INDENT> return input ( ) <NEWLINE> <DEDENT> def readChars ( ) : <NEWLINE> <INDENT> return input ( ) . split ( ) <NEWLINE> <NL> <DEDENT> n , a , b , c , d = readInts ( ) <NEWLINE> s = readChar ( ) <NEWLINE> if ( a - b ) * ( c - d ) < 0 : <NEWLINE> <INDENT> if <STRING> in s [ max ( a , b ) - 1 : ] and <STRING> not in s [ min ( a , b ) ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> elif c < b : <NEWLINE> <INDENT> if <STRING> not in s [ a : c ] and <STRING> not in s [ b : d ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if <STRING> not in s [ min ( a , b ) : ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> raise Exception <NEWLINE> <DEDENT>
N , A , B , C , D = map ( int , input ( ) . split ( ) ) <NEWLINE> S = input ( ) <NEWLINE> <NL> c1 = S [ B - 2 : C ] . count ( <STRING> ) <NEWLINE> c2 = S [ A - 1 : D ] . count ( <STRING> ) <NEWLINE> <NL> if c2 >= 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> pass <NEWLINE> <NL> <DEDENT> if C > D : <NEWLINE> <INDENT> if c1 == 0 : <NEWLINE> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT>
from numba import jit <NEWLINE> s = list ( input ( ) ) <NEWLINE> n = len ( s ) <NEWLINE> ans = 0 <NEWLINE> @ jit <NEWLINE> def p ( ans ) : <NEWLINE> <INDENT> for i in range ( 0 , n - 2 ) : <NEWLINE> <INDENT> b = True <NEWLINE> if s [ i : i + 3 ] == [ <STRING> , <STRING> , <STRING> ] : <NEWLINE> <INDENT> s [ i ] = <STRING> <NEWLINE> s [ i + 1 ] = <STRING> <NEWLINE> s [ i + 2 ] = <STRING> <NEWLINE> ans += 1 <NEWLINE> b = False <NEWLINE> <NL> <DEDENT> <DEDENT> return ans , b <NEWLINE> <DEDENT> while True : <NEWLINE> <INDENT> ans , b = p ( ans ) <NEWLINE> if not b : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> print ( 180 * r - 360 ) <NEWLINE>
print ( 180 * ( int ( input ( ) - 2 ) ) <NEWLINE>
print ( ( int ( input ( ) - 2 ) * 180 ) <NEWLINE>
def solve ( ) : <NEWLINE> <INDENT> s = list ( input ( ) ) <NEWLINE> if s . count ( <STRING> ) >= 8 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> return 0 <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> solve ( ) <NEWLINE> <DEDENT> , <NEWLINE>
from collections import deque <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> <NL> g = [ [ ] for _ in range ( n ) ] <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> g [ a - 1 ] . append ( b - 1 ) <NEWLINE> g [ b - 1 ] . append ( a - 1 ) <NEWLINE> <NL> <DEDENT> c = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c . sort ( ) <NEWLINE> <NL> ans = [ ] <NEWLINE> s = [ 0 ] * n <NEWLINE> que = deque ( [ 0 ] ) <NEWLINE> while que : <NEWLINE> <INDENT> t = que . popleft ( ) <NEWLINE> ans . append ( c . pop ( ) ) <NEWLINE> s [ t ] = 1 <NEWLINE> for e in g [ t ] : <NEWLINE> <INDENT> if not s [ e ] : <NEWLINE> <INDENT> que . append ( e ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( sum ( c ) - max ( c ) ) <NEWLINE> print ( * ans ) <NEWLINE>
<COMMENT> <NL> def input2 ( ) : <NEWLINE> <INDENT> return map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <DEDENT> a , p = input2 ( ) <NEWLINE> ans = ( ( A * 3 ) + p ) // 2 <NEWLINE> print ( ans ) <NEWLINE>
a , b = map ( input ( ) . split ( ) ) <NEWLINE> print ( ( 3 * a + b ) / 2 ) <NEWLINE>
a , p = map ( int , input ( ) . spilit ( ) ) <NEWLINE> print ( ( 3 * a + p ) / 2 - ( 3 * a + p % 2 ) ) <NEWLINE>
a , b = input ( ) . split ( ) <NEWLINE> a = int ( a ) <NEWLINE> b = int ( b ) <NEWLINE> print ( int ( ( a * 3 + b ) / 2 ) <NEWLINE>
a , p = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( ( a * b + p ) // 2 ) <NEWLINE>
a , p = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( ( a * 3 + p ) // 2 ) ) <NEWLINE>
A , P = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( ( 3 A + P ) // 2 ) <NEWLINE>
a , p = map ( int , input ( ) . split ( ) ) <NEWLINE> a == a * 3 * p <NEWLINE> a + p == int , ap <NEWLINE> print ( ap ) <NEWLINE>
a , p = map ( int , inputy ( ) . split ( ) ) <NEWLINE> print ( ( 3 * a + p ) // 2 ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> lst = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> s , p = input ( ) . split ( ) <NEWLINE> p = int ( p ) <NEWLINE> lst . append ( ( s , p , i + 1 ) ) <NEWLINE> <DEDENT> lst_sorted = sorted ( lst , key : lambda x : ( x [ 0 ] , - x [ 1 ] , x [ 2 ] ) ) <NEWLINE> for _ , _ , num in lst_sorted : <NEWLINE> <INDENT> print ( num ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> shops = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> S , P = input ( ) . split ( ) <NEWLINE> shops . append ( [ S , int ( P ) , i ] ) <NEWLINE> <DEDENT> shops . sort ( key = 1 ) <NEWLINE> shops . sort ( ) <NEWLINE> for shop in shops : <NEWLINE> <INDENT> print ( shop [ 2 ] ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> S , P = map ( str , input ( ) . split ( ) ) <NEWLINE> P = int ( p ) <NEWLINE> A . append ( [ S , - P ] ) <NEWLINE> <DEDENT> A . sort ( ) <NEWLINE> for i in A : <NEWLINE> <INDENT> print ( A . index ( i ) + 1 ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> res = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> s , p = max ( str , input ( ) . split ( ) ) <NEWLINE> res . append ( [ s , int ( p ) ] ) <NEWLINE> <DEDENT> res1 = res <NEWLINE> res = sorted ( res , key = lambda x : ( x [ 0 ] , - x [ 1 ] ) ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> print ( res1 . index ( res [ i ] ) + 1 ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> sp = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> s , p = map ( int , input ( ) . split ( ) ) <NEWLINE> sp . append ( [ s , int ( p ) , i + 1 ] ) <NEWLINE> <DEDENT> sp . sort ( key = lambda x : x [ 1 ] , reverse = True ) <NEWLINE> sp . sort ( key = lambda x : x [ 0 ] ) <NEWLINE> for e in sp : <NEWLINE> <INDENT> print ( e [ 2 ] ) <NEWLINE> <DEDENT>
n = int ( input ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> std_in = input ( ) . split ( ) <NEWLINE> dat . append ( [ std_in [ 0 ] , int ( std_in [ 1 ] ) ] ) <NEWLINE> <NL> <DEDENT> for i , e in enumerate ( dat , start = 1 ) : <NEWLINE> <INDENT> e [ 1 ] = - e [ 1 ] <COMMENT> <NEWLINE> e . append ( i ) <COMMENT> <NEWLINE> <NL> sorted_list = sorted ( dat ) <COMMENT> <NEWLINE> <NL> <DEDENT> for i , s in enumerate ( sorted_list ) : <NEWLINE> <COMMENT> <NL> <INDENT> print ( sorted_list [ i ] [ 2 ] ) <NEWLINE> <DEDENT>
list = [ ] <NEWLINE> N = int ( input ( ) ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> S , P = map ( str , input ( ) . split ( ) ) <NEWLINE> list . append ( ( i + 1 , S , int ( P ) ) ) <NEWLINE> <DEDENT> list = sorted ( lst , key = lambda x : ( x [ 1 ] , - x [ 2 ] ) ) <NEWLINE> <NL> for l in list : <NEWLINE> <INDENT> print ( l [ 0 ] ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> lis = [ ( input ( ) + <STRING> + str ( i + 1 ) ) . split ( ) for i in range ( N ) ] <NEWLINE> <NL> lis = [ k for k in lis ] <NEWLINE> <NL> lis . sort ( key = lambda k : int ( k [ 1 ] ) . reverse = True ) <NEWLINE> lis . sort ( key = lambda k : k [ 0 ] ) <NEWLINE> <NL> <NL> for i in lis : <NEWLINE> <INDENT> print ( i [ 2 ] ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <NL> import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> L = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> c , p = input ( ) . split ( ) <NEWLINE> p = int ( p ) <NEWLINE> L . append ( [ i + 1 , c , p ] ) <NEWLINE> <DEDENT> L = sorted ( L , lambda x : ( x [ 1 ] , - x [ 2 ] ) ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> print ( L [ i ] [ 0 ] ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> res = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> s , p = max ( str , input ( ) . split ( ) ) <NEWLINE> <INDENT> res . append ( [ s , int ( p ) ] ) <NEWLINE> <DEDENT> <DEDENT> res1 = res <NEWLINE> res = sorted ( res , key = lambda x : ( x [ 0 ] , - x [ 1 ] ) ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> print ( res1 . index ( res [ i ] ) + 1 ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> l = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> sp = input ( ) . split ( ) <NEWLINE> l . append ( ( sp [ 0 ] , int ( sp [ 1 ] ) , i + 1 ) ) <NEWLINE> <NL> <DEDENT> a = sorted ( l , key = lambda i : ( i [ 0 ] , - l [ 1 ] ) ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> print ( a [ i ] [ 2 ] ) <NEWLINE> <DEDENT>
my_list = [ ] <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> l = list ( ( input ( ) . split ( ) ) ) <NEWLINE> l . append ( i ) <NEWLINE> my_list . append ( l ) <NEWLINE> <NL> <DEDENT> my_list2 = sorted ( my_list , key = lambda x : ( x [ 0 ] , - int ( x [ 1 ] ) ) ) <NEWLINE> for i in my_list2 : <NEWLINE> <INDENT> print ( i [ 2 ] ) <NEWLINE> <NL> <DEDENT>
N = int ( input ( ) ) <NEWLINE> lis = [ ( input ( ) + <STRING> + str ( i + 1 ) ) . split ( ) for i in range ( N ) ] <NEWLINE> <NL> lis = [ k for k in lis ] <NEWLINE> <NL> lis . sort ( key = lambda k : int ( k [ 1 ] ) , reverse = True ) <NEWLINE> lis . sort ( key = lambda k : k [ 0 ] ) <NEWLINE> <NL> <NL> for j in lis : <NEWLINE> <INDENT> print ( j [ 2 ] ) <NEWLINE> <DEDENT> N = int ( input ( ) ) <NEWLINE> lis = [ ( input ( ) + <STRING> + str ( i + 1 ) ) . split ( ) for i in range ( N ) ] <NEWLINE> <NL> lis = [ k for k in lis ] <NEWLINE> <NL> lis . sort ( key = lambda k : int ( k [ 1 ] ) , reverse = True ) <NEWLINE> lis . sort ( key = lambda k : k [ 0 ] ) <NEWLINE> <NL> <NL> for j in lis : <NEWLINE> <INDENT> print ( j [ 2 ] ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> L = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> s , p = input ( ) <NEWLINE> L . append ( [ s , int ( p ) , i + 1 ] ) <NEWLINE> <DEDENT> list . sort ( L , reverse = True ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> print ( L [ i ] [ 2 ] ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> list = [ ] <NEWLINE> for xi in range ( n ) : <NEWLINE> <INDENT> add1 , add2 = input ( ) . split ( ) <NEWLINE> add = [ add2 , add1 , xi + 1 ] <NEWLINE> list . append ( add ) <NEWLINE> <DEDENT> list . sort ( key = lambda list2 : list2 [ 1 ] ) <NEWLINE> <NL> <NL> name = list [ 0 ] [ 1 ] <NEWLINE> list2 = [ list [ 0 ] ] <NEWLINE> count = 1 <NEWLINE> for xi in range ( 1 , n ) : <NEWLINE> <INDENT> if name == list [ xi ] [ 1 ] : <NEWLINE> <INDENT> list2 . append ( list [ xi ] ) <NEWLINE> count += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> list2 . sort ( key = int , reverse = True ) <NEWLINE> for yi in range ( count - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> print ( list2 [ yi ] [ 2 ] ) <NEWLINE> <DEDENT> name = list [ xi ] [ 1 ] <NEWLINE> list2 = [ list [ xi ] ] <NEWLINE> count = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if len ( list2 ) < n : <NEWLINE> <INDENT> list2 . sort ( key = int , reverse = True ) <NEWLINE> <DEDENT> for yi in range ( count - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> print ( list2 [ yi ] [ 2 ] ) <NEWLINE> <DEDENT> name = list [ xi ] [ 1 ] <NEWLINE> list2 = [ list [ xi ] ] <NEWLINE> count = 1 <NEWLINE>
N = int ( input ( ) ) <NEWLINE> data = [ input ( ) . split ( ) for i in range ( N ) ] <NEWLINE> data_name = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if data [ i ] [ 0 ] in data_name : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> data_name . append ( data [ i ] [ 0 ] ) <NEWLINE> <DEDENT> <DEDENT> data_name_sort = sorted ( data_name ) <NEWLINE> data_point = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> num = 0 <NEWLINE> for j in range ( len ( data_name_sort ) ) : <NEWLINE> <INDENT> if data [ i ] [ 0 ] == data_name_sort [ j ] : <NEWLINE> <INDENT> num += ( len ( data_name ) - j ) * 200 + int ( data [ i ] [ 1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> <DEDENT> data_point . append ( num ) <NEWLINE> <DEDENT> data_sort = [ i for i , _ in sorted ( enumerate ( data_point ) , key = lambda x : x [ 1 ] ) ] [ : : - 1 ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> ans = int ( data_sort ( i ) ) + 1 <NEWLINE> print ( ans ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> r = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> s , p = input ( ) . split ( ) <NEWLINE> p = int ( p ) <NEWLINE> r . append ( [ s , p , i ] ) <NEWLINE> <DEDENT> a = sorted ( r ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> print ( a [ i ] [ 3 ] + 1 ) <NEWLINE> <DEDENT>
n = input ( ) <NEWLINE> x = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> s , p = input ( ) . split ( ) <NEWLINE> x . append ( [ s , int ( p ) , i + 1 ] ) <NEWLINE> <DEDENT> x . sort ( key = lambda x : ( x [ 0 ] , - x [ 1 ] ) ) <NEWLINE> for i in x : <NEWLINE> <INDENT> print ( i [ 2 ] ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> s = list ( list ( input ( ) . split ( ) ) for _ in range ( n ) ) <NEWLINE> ans = [ s . index ( i ) + 1 for i in sorted ( s , key = lambda x : ( x [ 0 ] , - int ( x [ 1 ] ) ) ) ] <NEWLINE> print ( i ) for i in ans <NEWLINE>
n = int ( input ( ) ) <NEWLINE> restaurant = [ input ( ) . split ( ) for i in range ( n ) ] <NEWLINE> restaurant_sorted = sorted ( restaurant ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> print ( restaurant . index ( ( restaurant_sorted [ i ] ) ) <NEWLINE> <DEDENT>
<STRING> <NEWLINE> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> lamps = [ list ( map ( lambda x : int ( x ) - 1 , input ( ) . split ( ) ) ) [ 1 : ] for _ in range ( m ) ] <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <COMMENT> <NL> for i in range ( 2 ** n ) : <NEWLINE> <INDENT> for r in range ( m ) : <NEWLINE> <INDENT> on = 0 <NEWLINE> for j in range ( n ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <INDENT> if ( i >> j ) & 1 == 1 and j in lamps [ r ] : <NEWLINE> <INDENT> on += 1 <NEWLINE> <DEDENT> <DEDENT> if on % 2 != p [ r ] : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ ] <NEWLINE> for _ in range ( M ) : <NEWLINE> <INDENT> A . append ( tuple ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <DEDENT> P = tuple ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> import itertools <NEWLINE> def hantei ( A , RETU , P ) : <NEWLINE> <INDENT> for i in range ( len ( A ) ) : <NEWLINE> <INDENT> count = 0 <NEWLINE> for k in RETU : <NEWLINE> <INDENT> if k in A [ i ] [ 1 : ] : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> if not count % 2 == P [ i ] : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> <DEDENT> return True <NEWLINE> <DEDENT> ans = 0 <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> for k in itertools . combinations ( range ( 1 , N + 1 ) , i ) : <NEWLINE> <INDENT> if hantei ( A , k , P ) : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if hantei ( A , 0 , P ) : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> q = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( m ) ] <NEWLINE> ans = 0 <NEWLINE> <NL> for s in range ( 2 ** n ) : <COMMENT> <NEWLINE> <INDENT> judge = True <NEWLINE> for i in range ( m ) : <COMMENT> <NEWLINE> <INDENT> cnt = 0 <NEWLINE> for j in range ( 1 , len ( q [ i ] ) ) : <COMMENT> <NEWLINE> <INDENT> w = q [ i ] [ j ] <NEWLINE> if s >> ( w - 1 ) & 1 == 1 : <COMMENT> <NEWLINE> <INDENT> cnt += 1 <COMMENT> <NEWLINE> <DEDENT> <DEDENT> if cnt % 2 != p [ i ] : <COMMENT> <NEWLINE> <INDENT> judge = False <NEWLINE> <DEDENT> <DEDENT> if judge : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> denkyu_switch = [ ] <NEWLINE> res = 0 <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> denkyu_switch += [ list ( map ( int , input ( ) . split ( ) ) ) [ 1 : ] ] <NEWLINE> <DEDENT> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i in range ( 2 ** n ) : <NEWLINE> <INDENT> denkyu = [ 0 ] * m <NEWLINE> for j in range ( n ) : <NEWLINE> <INDENT> if i >> j & 1 : <NEWLINE> <INDENT> for k in denkyu_switch : <NEWLINE> <INDENT> if j in k : <NEWLINE> <INDENT> denkyu [ k ] += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if p == denkyu : <NEWLINE> <INDENT> res += 1 <NEWLINE> <DEDENT> <DEDENT> print ( res ) <NEWLINE>
<COMMENT> <NL> <NL> <COMMENT> <NL> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> t = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( m ) ] <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> k = [ t [ i ] [ 0 ] for i in range ( m ) ] <NEWLINE> s = [ t [ i ] [ 1 : ] for i in range ( m ) ] <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> ans = 0 <NEWLINE> for i in range ( 2 ** n ) : <NEWLINE> <INDENT> tmp = i <NEWLINE> sw = [ ] <NEWLINE> if i == 0 : <NEWLINE> <INDENT> sw = [ 0 ] <NEWLINE> <DEDENT> while tmp > 0 : <NEWLINE> <INDENT> sw . append ( tmp & 1 ) <NEWLINE> tmp = tmp >> 1 <NEWLINE> <DEDENT> while len ( sw ) < n : <NEWLINE> <INDENT> sw . append ( 0 ) <NEWLINE> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <DEDENT> ok = True <NEWLINE> <COMMENT> <NL> for j in range ( m ) : <NEWLINE> <INDENT> tmp = 0 <NEWLINE> for a in range ( k [ j ] ) : <NEWLINE> <INDENT> tmp += sw [ a + 1 ] <NEWLINE> <DEDENT> if tmp % 2 != p [ j ] % 2 : <NEWLINE> <INDENT> ok = False <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if ok : <NEWLINE> <COMMENT> <NL> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
ans = 0 <NEWLINE> for bit in range ( 1 << N ) : <NEWLINE> <INDENT> count = [ 0 ] * M <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if ( bit >> i ) & 1 : <NEWLINE> <INDENT> for a in range ( M ) : <NEWLINE> <INDENT> if i in ks [ a ] [ 1 : ] : <NEWLINE> <INDENT> count [ a ] += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> a = 0 <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> if count [ i ] % 2 == p [ i ] : <NEWLINE> <INDENT> a += 1 <NEWLINE> if a == M : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> s = list ( list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( m ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 << n ) : <NEWLINE> <COMMENT> <NL> <INDENT> sw = [ False ] * m <NEWLINE> <COMMENT> <NL> for j in range ( M ) : <NEWLINE> <COMMENT> <NL> <INDENT> cnt = 0 <NEWLINE> for k in range ( 1 , len ( s [ j ] ) ) : <NEWLINE> <INDENT> if i >> s [ j ] [ k ] - 1 & 1 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if cnt % 2 == p [ j ] : <NEWLINE> <INDENT> sw [ j ] = True <NEWLINE> <DEDENT> <DEDENT> if all ( sw ) : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> sw = [ [ ] * m ] <NEWLINE> for _ in range ( m ) : <NEWLINE> <INDENT> temp = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> sw [ _ ] = temp [ 1 : ] <NEWLINE> <DEDENT> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 2 ** n ) : <NEWLINE> <INDENT> temp = [ 0 ] * n <NEWLINE> for j in range ( n ) : <NEWLINE> <INDENT> if i & 1 : temp [ j ] = 1 <NEWLINE> i >>= 1 <NEWLINE> <DEDENT> flag = 1 <NEWLINE> for l , s in enumerate ( sw ) : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> for k in s : <NEWLINE> <INDENT> if temp [ k - 1 ] == 1 : cnt += 1 <NEWLINE> <DEDENT> if p [ l ] != cnt % 2 : <NEWLINE> <INDENT> flag = 0 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if flag : ans += 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> q = list ( ) <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> q . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <DEDENT> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> for s in range ( 2 ** n ) : <NEWLINE> <INDENT> judge = True <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> for j in range ( 1 , len ( q [ i ] ) : <NEWLINE> <INDENT> w = q [ i ] [ j ] <NEWLINE> if s >> ( w - 1 ) & 1 == 1 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> if cnt % 2 != p [ i ] : <NEWLINE> <INDENT> judge = False <NEWLINE> <DEDENT> <DEDENT> if judge : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> card = [ [ 0 ] * n for _ in range ( m ) ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> switch = list ( map ( int , input ( ) . split ( ) ) ) [ 1 : ] <NEWLINE> for k in switch : <NEWLINE> <INDENT> card [ i ] [ k - 1 ] = 1 <NEWLINE> <COMMENT> <NL> <NL> <COMMENT> <NL> <NL> <NL> <DEDENT> <DEDENT> ans = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> cnt = 0 <NEWLINE> from itertools import combinations <NEWLINE> <COMMENT> <NL> for epoch in range ( 1 , n + 1 ) : <NEWLINE> <NL> <INDENT> for j in combinations ( range ( 1 , n + 1 ) , epoch ) : <NEWLINE> <INDENT> sco = [ ] <NEWLINE> for lisa in card : <COMMENT> <NEWLINE> <INDENT> score = 0 <NEWLINE> for l in j : <NEWLINE> <INDENT> score += lisa [ l - 1 ] <NEWLINE> <NL> <DEDENT> sco . append ( score ) <NEWLINE> <COMMENT> <NL> <DEDENT> if list ( np . array ( sco ) % 2 ) == ans : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
N , M = map ( int , input ( ) ) <NEWLINE> K = [ ] <NEWLINE> S = [ ] <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> list = input ( ) . split ( ) <NEWLINE> K . append ( int ( list [ 0 ] ) ) <NEWLINE> S . append ( map ( int , list [ 1 : : ] ) ) <NEWLINE> <DEDENT> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> anss = 0 <NEWLINE> for i in range ( 2 ** n ) : <NEWLINE> <INDENT> for j in range ( M ) : <NEWLINE> <INDENT> ans = 0 <NEWLINE> for k in range ( N ) : <NEWLINE> <INDENT> if i >> k & 1 and k in K [ j ] : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> if ans % 2 != p [ j ] : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> anss += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> def dfs ( A ) : <NEWLINE> <INDENT> global cnt <NEWLINE> <NL> if len ( A ) == n : <NEWLINE> <INDENT> ans = [ 0 for i in range ( m ) ] <NEWLINE> print ( A ) <NEWLINE> for i , a in enumerate ( A ) : <NEWLINE> <INDENT> if a : <NEWLINE> <INDENT> for j in range ( m ) : <NEWLINE> <INDENT> if i + 1 in s [ j ] : <NEWLINE> <INDENT> ans [ j ] += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> for x , y in zip ( p , ans ) : <NEWLINE> <INDENT> if x != y % 2 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> return <NEWLINE> <DEDENT> for v in range ( 2 ) : <NEWLINE> <INDENT> A . append ( v ) <NEWLINE> dfs ( A ) <NEWLINE> A . pop ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> s = [ list ( map ( int , x . split ( ) ) ) [ 1 : ] for x in sys . stdin . readlines ( ) ] <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> cnt = 0 <NEWLINE> dfs ( [ ] ) <NEWLINE> print ( cnt ) <NEWLINE>
from itertools import product <NEWLINE> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> cc = [ ] <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> ll = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> cc . append ( ll ) <NEWLINE> <DEDENT> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> count = 0 <NEWLINE> for i in product ( <STRING> , repeat = N ) : <NEWLINE> <INDENT> on = 0 <NEWLINE> bulb = 0 <NEWLINE> for j in range ( M ) : <NEWLINE> <INDENT> for k in range ( cc [ j ] [ 0 ] ) : <NEWLINE> <INDENT> if i [ cc [ m ] [ l + 1 ] - 1 ] == 1 : <NEWLINE> <INDENT> on += 1 <NEWLINE> <DEDENT> <DEDENT> if on % 2 == p [ j ] : <NEWLINE> <INDENT> bulb += 1 <NEWLINE> <DEDENT> <DEDENT> if bulb == M : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE> <NL> <NL> <NL>
from itertools import product <NEWLINE> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> switch = [ ] <NEWLINE> for _ in range ( m ) : <NEWLINE> <INDENT> k , * s = map ( lambda x : int ( x ) - 1 , input ( ) . split ( ) ) <NEWLINE> switch . append ( s ) <NEWLINE> <DEDENT> p = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> for subset in product ( ( 0 , 1 ) , n ) : <NEWLINE> <INDENT> for j in range ( m ) : <NEWLINE> <INDENT> on_cnt = sum ( subset [ s ] for s in switch [ j ] ) <NEWLINE> if on_cnt % 2 != p [ j ] : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from itertools import product <NEWLINE> <NL> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> ks = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( m ) ] <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> cnt = 0 <NEWLINE> for pat in product ( [ 0 , 1 ] , repeat = n ) : <NEWLINE> <INDENT> for ksi , pi in zip ( ks , pi ) : <NEWLINE> <INDENT> tmp = sum ( pat [ ksij - 1 ] for ksij in ksi [ 1 : ] ) <NEWLINE> if tmp % 2 != pi : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
import itertools <NEWLINE> <NL> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> lights = [ ] <NEWLINE> for m in range ( M ) : <NEWLINE> <NL> <INDENT> interpools mpzp ( input ( ) ) <NEWLINE> <INDENT> tmp = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> lights . append ( tmp [ 1 : ] ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> P = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> for product in list ( itertools . product ( [ 0 , 1 ] , repeat = N ) ) : <NEWLINE> <INDENT> for light in range ( len ( lights ) ) : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> for l in lights [ light ] : <NEWLINE> <INDENT> cnt += product [ l - 1 ] <NEWLINE> <DEDENT> if cnt % 2 != P [ light ] : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if light == len ( lights ) - 1 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> state = [ ] <NEWLINE> for _ in range ( M ) : <NEWLINE> <INDENT> lst = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> state . append ( lst [ 1 : ] ) <COMMENT> <NEWLINE> <DEDENT> p = list ( map ( int , input ( ) . split ( ) ) ) <COMMENT> <NEWLINE> ans = 0 <NEWLINE> for i in rage ( 2 ** n ) : <NEWLINE> <INDENT> total = 0 <NEWLINE> for j in range ( m ) : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> for s in state [ j ] : <NEWLINE> <INDENT> s -= 1 <NEWLINE> if ( i >> s ) & 1 : <COMMENT> <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> cnt %= 2 <NEWLINE> if cnt == p [ j ] : <NEWLINE> <INDENT> total += 1 <NEWLINE> <DEDENT> <DEDENT> if total == m : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> V = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> ans = 0 <NEWLINE> for M in range ( K + 1 ) : <NEWLINE> <INDENT> for m in range ( M + 1 ) : <NEWLINE> <INDENT> ls = [ ] <NEWLINE> cur1 = 0 <NEWLINE> for i , x in enumerate ( V ) : <NEWLINE> <INDENT> if i < m : <NEWLINE> <INDENT> ls . append ( x ) <NEWLINE> cur += 1 <NEWLINE> <DEDENT> <DEDENT> cur2 = 0 <NEWLINE> for i , x in enumerate ( V [ : : - 1 ] ) : <NEWLINE> <INDENT> if i < min ( M - m , N - cur1 ) : <NEWLINE> <INDENT> ls . append ( x ) <NEWLINE> cur2 += 1 <NEWLINE> <DEDENT> <DEDENT> ls . sort ( ) <NEWLINE> s = sum ( ls ) <NEWLINE> for i , x in enumerate ( ls ) : <NEWLINE> <INDENT> if i < K - ( cur1 + cur2 ) : <NEWLINE> <INDENT> s -= x <NEWLINE> <DEDENT> <DEDENT> ans = max ( ans , s ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> from heapq import * <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> n , q = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> key = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> s , t , x = map ( int , input ( ) . split ( ) ) <NEWLINE> l , r = max ( 0 , s - x ) , max ( 0 , t - x ) <NEWLINE> key . append ( ( l , - 1 , x ) ) <NEWLINE> key . append ( ( r , 1 , x ) ) <NEWLINE> <NL> <DEDENT> key . sort ( ) <NEWLINE> judge = [ ] <NEWLINE> now = set ( ) <NEWLINE> already = dict ( ) <NEWLINE> search = [ ] <NEWLINE> <NL> for i in range ( n * 2 ) : <NEWLINE> <INDENT> s , j , x = key [ i ] <NEWLINE> <NL> if j == - 1 : <NEWLINE> <INDENT> heappush ( judge , x ) <NEWLINE> now . add ( x ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> now . remove ( x ) <NEWLINE> if x in already : <NEWLINE> <INDENT> already [ x ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> already [ x ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if i == n * 2 - 1 or key [ i ] [ 0 ] != key [ i + 1 ] [ 0 ] : <NEWLINE> <INDENT> while judge : <NEWLINE> <INDENT> if judge [ 0 ] in already and already [ judge [ 0 ] ] > 0 : <NEWLINE> <INDENT> already [ judge [ 0 ] ] -= 1 <NEWLINE> heappop ( judge ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> if judge : <NEWLINE> <INDENT> search . append ( ( s , judge [ 0 ] ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> search . append ( ( s , - 1 ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> size = len ( search ) <NEWLINE> index = 0 <NEWLINE> answer = [ ] <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> d = int ( input ( ) ) <NEWLINE> while index < size - 1 : <NEWLINE> <INDENT> if search [ index + 1 ] [ 0 ] <= d : <NEWLINE> <INDENT> index += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> print ( search [ index ] [ 1 ] ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <NL> <NL> <NL> <DEDENT>
import heapq <NEWLINE> n , q = map ( int , input ( ) . split ( ) ) <NEWLINE> event = [ ] <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> s , t , x = map ( int , input ( ) . split ( ) ) <NEWLINE> event . append ( ( s - x , 1 , x ) ) <NEWLINE> event . append ( ( t - x , - 1 , x ) ) <NEWLINE> <NL> <DEDENT> event . sort ( ) <NEWLINE> heap = [ ] <NEWLINE> xs = set ( [ ] ) <NEWLINE> <NL> d = [ int ( input ( ) ) for _ in range ( q ) ] <NEWLINE> ans = [ - 1 ] * q <NEWLINE> index = 0 <NEWLINE> for t , query , x in event : <NEWLINE> <INDENT> if d [ index ] < t : <NEWLINE> <INDENT> if not xs : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> while heap : <NEWLINE> <INDENT> tmp = heapq . heappop ( heap ) <NEWLINE> if tmp in xs : <NEWLINE> <INDENT> heapq . heappush ( heap , tmp ) <NEWLINE> ans [ index ] = tmp <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> index += 1 <NEWLINE> if index == q : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> if query == 1 : <NEWLINE> <INDENT> xs . add ( x ) <NEWLINE> heapq . heappush ( heap , x ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> xs . remove ( x ) <NEWLINE> <NL> <DEDENT> cnt [ t ] -= 1 <NEWLINE> <NL> <DEDENT> while index < q : <NEWLINE> <INDENT> while heap : <NEWLINE> <INDENT> tmp = heapq . heappop ( heap ) <NEWLINE> if tmp in xs : <NEWLINE> <INDENT> heapq . heappush ( heap , tmp ) <NEWLINE> ans [ index ] = tmp <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> index += 1 <NEWLINE> <NL> <DEDENT> print ( <STRING> . join ( map ( str , ans ) ) ) <NEWLINE> <NL> <NL> <NL>
age , cost = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if age <= 5 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif age >= 6 and age <= 12 : <NEWLINE> <INDENT> print ( a // 2 ) <NEWLINE> <DEDENT> elif age >= 13 : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <DEDENT>
A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> if 13 <= A : <NEWLINE> <INDENT> ans = B <NEWLINE> <DEDENT> elif 6 <= A : <NEWLINE> <INDENT> ans = B / 2 S <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( [ [ 0 , b // 2 ] [ a > 5 , b ] [ a > 12 ] ) <NEWLINE>
A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if 13 <= A : <NEWLINE> <INDENT> print ( B ) <NEWLINE> <DEDENT> elif 6 <= A : <NEWLINE> <INDENT> print ( int ( B / 2 ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 <NEWLINE> <DEDENT>
A , B = map ( int ( input ( ) ) . split ( ) ) <NEWLINE> <NL> if A >= 13 : <NEWLINE> <INDENT> print ( B ) <NEWLINE> <DEDENT> elif 6 <= A <= 12 : <NEWLINE> <INDENT> print ( B / 2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT>
a , b = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> if a = > 13 : <NEWLINE> <INDENT> print ( b ) <NEWLINE> <DEDENT> elif a >= 6 and a <= 12 : <NEWLINE> <INDENT> print ( b / 2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if A >= 13 : <NEWLINE> <INDENT> print ( b ) <NEWLINE> <DEDENT> elif 6 <= A : <NEWLINE> <INDENT> print ( b / 2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT>
a , b = map ( int , input ( ) ) <NEWLINE> if a > 12 : <NEWLINE> <INDENT> print ( b ) <NEWLINE> <DEDENT> elif 13 > a > 5 : <NEWLINE> <INDENT> print ( b / 2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT>
a , b = map ( input ( ) . split ( ) ) <NEWLINE> if a >= 13 : <NEWLINE> <INDENT> print ( b ) <NEWLINE> <DEDENT> elif 12 <= a <= 6 : <NEWLINE> <INDENT> print ( b // 2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT>
a = int ( input ( ) ) <NEWLINE> b = int ( input ( ) ) <NEWLINE> if a >= 13 : <NEWLINE> <INDENT> print ( b ) <NEWLINE> <DEDENT> elif a >= 6 : <NEWLINE> <INDENT> print ( b // 2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT>
if a >= 13 : <NEWLINE> <INDENT> print ( b ) <NEWLINE> <DEDENT> elif a >= 6 and a <= 12 : <NEWLINE> <INDENT> print ( int ( b / 2 ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT>
A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> print ( int ( B ) if A >= 13 else 0 if A <= 5 else int ( B // 2 ) <NEWLINE>
A , B = map ( int , input ( ) . sprit ( ) ) <NEWLINE> if A <= 5 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> elif A <= 12 : <NEWLINE> <INDENT> print ( B // 2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( B ) <NEWLINE> <DEDENT>
<NL> def main ( ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) ) <NEWLINE> if a >= 13 : <NEWLINE> <INDENT> print ( b ) <NEWLINE> <DEDENT> elif 6 <= a <= 12 : <NEWLINE> <INDENT> print ( b // 2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
a , b = int ( input ) ) <NEWLINE> if a <= 5 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> elif a <= 12 : <NEWLINE> <INDENT> print ( b // 2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( b ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> A , B = map ( int , input ( ) , split ( ) ) <NEWLINE> if A >= 13 : <NEWLINE> <INDENT> print ( B ) <NEWLINE> <DEDENT> elif 6 <= A <= 12 : <NEWLINE> <INDENT> print ( B / 2 ) <NEWLINE> <DEDENT> elif A <= 5 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT>
A = int ( input ( ) ) <NEWLINE> B = int ( input ( ) ) <NEWLINE> <NL> if A >= 13 : <NEWLINE> <INDENT> print ( B ) <NEWLINE> <DEDENT> elif A >= 6 : <NEWLINE> <INDENT> half_b = B / 2 <NEWLINE> print ( half_b ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( int ( 0 ) ) <NEWLINE> <DEDENT>
A , B = input ( ) . split ( ) <NEWLINE> <NL> if A < 5 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> elif A < 12 : <NEWLINE> <INDENT> C = B / 2 <NEWLINE> print ( C ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( B ) <NEWLINE> <DEDENT>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if a <= 5 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> elif 6 <= a and a <= 12 : <NEWLINE> <INDENT> print ( int ( b / 2 ) a ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( b ) <NEWLINE> <DEDENT>
a = int ( input ( <STRING> ) <NEWLINE> b = int ( input ( <STRING> ) <NEWLINE> if b % 2 == 0 : <NEWLINE> <INDENT> if a >= 13 : <NEWLINE> <INDENT> print ( b ) <NEWLINE> <DEDENT> elif 6 <= a <= 12 : <NEWLINE> <INDENT> print ( b / 2 ) <NEWLINE> <DEDENT> elif a <= 5 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> <DEDENT>
a , b = map ( int , input ( ) . sprit ( ) ) <NEWLINE> if a >= 13 : <NEWLINE> <INDENT> print ( b ) <NEWLINE> <DEDENT> elif 6 <= a <= 12 : <NEWLINE> <INDENT> print ( b // 2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT>
a , b , c = input ( ) . split ( ) <NEWLINE> a = int ( a ) <NEWLINE> b = int ( b ) <NEWLINE> c = int ( c ) <NEWLINE> d = c <NEWLINE> while i < 10 : <NEWLINE> d = a * d - b <NEWLINE> print ( d ) <NEWLINE> i = i + 1 <NEWLINE>
r , D , x = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> for i in range ( 10 ) <NEWLINE> <INDENT> x = r * x - D <NEWLINE> <INDENT> print ( x ) <NEWLINE> <DEDENT> <DEDENT>
arr = input . split ( ) <NEWLINE> r = int ( arr [ 0 ] ) <NEWLINE> d = int ( arr [ 1 ] ) <NEWLINE> x = int ( arr [ 2 ] ) <NEWLINE> <NL> for i in range ( 0 , 10 ) : <NEWLINE> <INDENT> x = r * x - d <NEWLINE> print ( x ) <NEWLINE> <DEDENT>
r , d , x = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> for i inrange ( 1 , 11 ) : <NEWLINE> <INDENT> x = r * x - d <NEWLINE> print ( x ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <NL> age , cost = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if age <= 5 : <NEWLINE> <INDENT> cost = 0 <NEWLINE> <DEDENT> elif 6 <= age <= 12 : <NEWLINE> <INDENT> cost = cost // 2 <NEWLINE> <DEDENT> elif 7 <= age : <NEWLINE> <INDENT> cost = cost <NEWLINE> <NL> <DEDENT> print ( cost ) <NEWLINE>
r , d , x = map ( int , input ( ) . split ( ) ) <NEWLINE> for i in range ( 10 ) : <NEWLINE> <INDENT> x = r * x - d <NEWLINE> <INDENT> print ( x ) <NEWLINE> <DEDENT> <DEDENT>
r , D , x = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> tmp = x <NEWLINE> for i in range ( 10 ) : <NEWLINE> <INDENT> tmp = tmp * r - d <NEWLINE> print ( tmp ) <NEWLINE> <DEDENT>
x , D , xx = map ( int , input ( ) . split ( ) ) <NEWLINE> for i for range ( 10 ) : <NEWLINE> <INDENT> xx = x * xx - D <NEWLINE> print ( xx ) <NEWLINE> <DEDENT>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> lmax = 0 <NEWLINE> rmin = 10 ** 5 <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> L , R = map ( int , input ( ) . split ( ) ) <NEWLINE> lmax = max ( lmax , L ) <NEWLINE> rmin = min ( rmin , R ) <NEWLINE> <DEDENT> ans = rmin - lmax <NEWLINE> if ans >= 0 : <NEWLINE> <INDENT> print ( ans + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> L = [ ] <NEWLINE> R = [ ] <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> l , r = input ( ) . split ( ) <NEWLINE> L . append ( int ( l ) ) <NEWLINE> R . append ( r ) <NEWLINE> <NL> <NL> <DEDENT> x = min ( R ) - max ( L ) <NEWLINE> <NL> <NL> print ( 0 if x < 0 else x + 1 ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> l = 1 <NEWLINE> r = n <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> li , ri = map ( int , input ( ) . split ( ) ) <NEWLINE> l = max ( l , li ) <NEWLINE> r = min ( r , ri ) <NEWLINE> <DEDENT> print ( max ( r - l , 0 ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ ] * m <NEWLINE> b = [ ] * m <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> a . append ( l ) <NEWLINE> b . append ( r ) <NEWLINE> <NL> <DEDENT> if max ( a ) <= min ( b ) : <NEWLINE> <INDENT> print ( min ( b ) - max ( a ) + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> global FLAG_LOG <NEWLINE> FLAG_LOG = False <NEWLINE> <NL> <NL> def log ( value ) : <NEWLINE> <COMMENT> <NL> <INDENT> FLAG_LOG = False <NEWLINE> if FLAG_LOG : <NEWLINE> <INDENT> print ( str ( value ) ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def calculation ( lines ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <INDENT> N , M = list ( map ( int , lines [ 0 ] . split ( ) ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> valueses = list ( ) <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> valueses . append ( list ( map ( int , lines [ i + 1 ] . split ( ) ) ) ) <NEWLINE> <NL> <DEDENT> ll = None <NEWLINE> rr = None <NEWLINE> <NL> log ( <STRING> ) <NEWLINE> <NL> for i in range ( M ) : <NEWLINE> <INDENT> l = valueses [ i ] [ 0 ] <NEWLINE> r = valueses [ i ] [ 1 ] <NEWLINE> if ll is None : <NEWLINE> <INDENT> ll = l <NEWLINE> <DEDENT> elif ll < l : <NEWLINE> <INDENT> ll = l <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> log ( <STRING> ) <NEWLINE> <DEDENT> if rr is None : <NEWLINE> <INDENT> rr = r <NEWLINE> <DEDENT> elif rr > r : <NEWLINE> <INDENT> rr = r <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> log ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> log ( <STRING> ) <NEWLINE> log ( <STRING> ) <NEWLINE> <NL> return [ max ( rr - ll + 1 , 0 ) ] <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> def get_input_lines ( ) : <NEWLINE> <INDENT> lins = input ( ) <NEWLINE> N , M = list ( map ( int , line . split ( ) ) ) <NEWLINE> lines = list ( ) <NEWLINE> lines . append ( line ) <NEWLINE> for _ in range ( M ) : <NEWLINE> <INDENT> lines . append ( input ( ) ) <NEWLINE> <DEDENT> return lines <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> def get_testdata ( pattern ) : <NEWLINE> <INDENT> if pattern == 1 : <NEWLINE> <INDENT> lines_input = [ <STRING> , <STRING> , <STRING> ] <NEWLINE> lines_export = [ 2 ] <NEWLINE> <DEDENT> if pattern == 2 : <NEWLINE> <INDENT> lines_input = [ <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> lines_export = [ 1 ] <NEWLINE> <DEDENT> if pattern == 3 : <NEWLINE> <INDENT> lines_input = [ <STRING> , <STRING> ] <NEWLINE> lines_export = [ 100000 ] <NEWLINE> <DEDENT> return lines_input , lines_export <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> def get_mode ( ) : <NEWLINE> <INDENT> import sys <NEWLINE> args = sys . argv <NEWLINE> global FLAG_LOG <NEWLINE> if len ( args ) == 1 : <NEWLINE> <INDENT> mode = 0 <NEWLINE> FLAG_LOG = False <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> mode = int ( args [ 1 ] ) <NEWLINE> FLAG_LOG = True <NEWLINE> <DEDENT> return mode <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> import time <NEWLINE> started = time . time ( ) <NEWLINE> mode = get_mode ( ) <NEWLINE> if mode == 0 : <NEWLINE> <INDENT> lines_input = get_input_lines ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> lines_input , lines_export = get_testdata ( mode ) <NEWLINE> <NL> <DEDENT> lines_result = calculation ( lines_input ) <NEWLINE> <NL> for line_result in lines_result : <NEWLINE> <INDENT> print ( line_result ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
r = input ( ) . split ( ) <NEWLINE> N = int ( r [ 0 ] ) <NEWLINE> M = int ( r [ 1 ] ) <NEWLINE> data = [ [ int ( s ) for s in input ( ) . split ( ) ] for i in range ( M ) ] <NEWLINE> left = [ ] <NEWLINE> right = [ ] <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> left . append ( data [ i ] [ 0 ] ) <NEWLINE> right . append ( data [ i ] [ 1 ] ) <NEWLINE> <DEDENT> if min ( right ) - max ( left ) + 1 = < 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( min ( right ) - max ( left ) + 1 ) <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> l , r = [ ] , [ ] <NEWLINE> <NL> for _ in range ( m ) : <NEWLINE> <INDENT> s , t = map ( int , input ( ) . split ( ) ) <NEWLINE> l . append ( s ) <NEWLINE> r . append ( t ) <NEWLINE> <NL> <DEDENT> ans = min ( r ) - max ( s ) + 1 <NEWLINE> print ( ans ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> <COMMENT> <NL> l = [ 0 ] * 100005 <NEWLINE> r = [ 1000005 ] * 100005 <NEWLINE> z = 1000010 <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> l [ i ] , r [ i ] = map ( int , input ( ) . split ( ) ) <NEWLINE> <DEDENT> mi = max ( l ) <NEWLINE> ma = min ( r ) <NEWLINE> <NL> <NL> <NL> if mi > ma : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else <NEWLINE> <INDENT> print ( ma - mi + 1 ) <NEWLINE> <DEDENT>
<COMMENT> <NL> def input2 ( ) : <NEWLINE> <INDENT> return map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <DEDENT> N , M = input2 ( ) <NEWLINE> L , R = [ ] , [ ] <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> l , r = input2 ( ) <NEWLINE> L . append ( l ) <NEWLINE> R . append ( r ) <NEWLINE> <NL> <DEDENT> MIN = 0 <NEWLINE> MAX = N <NEWLINE> <NL> for j in range ( M ) : <NEWLINE> <INDENT> if L [ j ] > MIN and : <NEWLINE> <INDENT> MIN = L [ j ] <NEWLINE> <DEDENT> if R [ j ] < MAX : <NEWLINE> <INDENT> MAX = R [ j ] <NEWLINE> <NL> <DEDENT> <DEDENT> if MAX < MIN : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ( MAX - MIN ) + 1 ) <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> lr = [ [ map ( int , input ( ) . split ( ) ) ] for i in range ( m ) ] <NEWLINE> <NL> max = 0 <NEWLINE> min = n + 1 <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> if lr [ i ] [ 0 ] > max : <NEWLINE> <INDENT> max = lr [ i ] [ 0 ] <NEWLINE> <DEDENT> if lr [ i ] [ 1 ] < min : <NEWLINE> <INDENT> min = lr [ i ] [ 1 ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( min - max + 1 ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> l_max = 0 <NEWLINE> r_min = n <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> l_max = max ( l_max , l ) <NEWLINE> r_min = min ( r_min , r ) <NEWLINE> <DEDENT> print ( r_min - l_max ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <NL> L , R = map ( int , input ( ) . split ( ) ) <NEWLINE> ar = [ i for i in range ( L , R + 1 ) ] <NEWLINE> for i in range ( M - 1 ) : <NEWLINE> <INDENT> L , R = map ( int , input . split ( ) ) <NEWLINE> if ar [ - 1 ] < L or ar [ 0 ] > R : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if ar [ 0 ] < L < ar [ - 1 ] : <NEWLINE> <INDENT> ar = [ x for x in range ( L , ar [ - 1 ] + 1 ) ] <NEWLINE> <DEDENT> elif ar [ 0 ] < R < ar [ - 1 ] : <NEWLINE> <INDENT> ar = [ x for x in range ( ar [ 0 ] , R + 1 ) ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( len ( ar ) ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = [ i for i in range ( 1 , n + 1 ) ] <NEWLINE> <NL> for _ in range ( m ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> tmp = [ i for i in range ( x , y + 1 ) ] <NEWLINE> for ele in tmp : <NEWLINE> <INDENT> ans . remove ( ele ) <NEWLINE> <DEDENT> <DEDENT> print ( n - len ( ans ) ) <NEWLINE>
import heapq <NEWLINE> <NL> n , m = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> cards = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> cards . sort ( ) <NEWLINE> <NL> queries = [ ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> q = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> queries . append ( q ) <NEWLINE> <DEDENT> queries . sort ( key = lambda x : x [ 1 ] ) <NEWLINE> queries . reverse ( ) <NEWLINE> <NL> ans = 0 <NEWLINE> pos = 0 <NEWLINE> for q in queries : <NEWLINE> <INDENT> b , c = q <NEWLINE> if cards [ min ( pos + b - 1 , n - 1 ) ] < c : <NEWLINE> <COMMENT> <NL> <INDENT> pos = pos + b <NEWLINE> ans += c * b <NEWLINE> if pos >= n : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( b ) : <NEWLINE> <INDENT> if cards [ pos + i , n - 1 ] < c : <NEWLINE> <COMMENT> <NL> <INDENT> ans += c <NEWLINE> <DEDENT> else : <NEWLINE> <COMMENT> <NL> <INDENT> pos += i <NEWLINE> for j in range ( pos , n ) : <NEWLINE> <INDENT> ans += cards [ j ] <NEWLINE> <NL> <DEDENT> pos = n <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> if pos < n : <NEWLINE> <INDENT> for j in range ( pos , n ) : <NEWLINE> <INDENT> ans += cards [ j ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL>
import numpy as np <NEWLINE> from heapq import heapify , heapreplace <NEWLINE> def solve ( stdin ) : <NEWLINE> <INDENT> n , m = stdin [ : 2 ] <NEWLINE> A = stdin [ 2 : 2 + n ] . tolist ( ) <NEWLINE> BC = stdin [ 2 + n : ] . reshape ( - 1 , 2 ) <NEWLINE> <NL> heapify ( A ) <NEWLINE> <NL> BC = sorted ( BC , key = lambda x : ( x [ 1 ] ) , reverse = True ) <NEWLINE> for b , c in BC : <NEWLINE> <INDENT> if c < A [ 0 ] : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for i in range ( b ) : <NEWLINE> <INDENT> if A [ 0 ] > c : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> heapreplace ( A , c ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> return sum ( A ) <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> stdin = np . fromstring ( open ( 0 ) . read ( ) , dtype = np . int64 , sep = <STRING> ) <NEWLINE> print ( solve ( stdin ) ) <NEWLINE> <NL> <DEDENT> def cc_export ( ) : <NEWLINE> <INDENT> from numba . pycc import CC <NEWLINE> cc = CC ( <STRING> ) <NEWLINE> cc . export ( <STRING> , <STRING> ) ( solve ) <NEWLINE> cc . compile ( ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> import sys <NEWLINE> if sys . argv [ - 1 ] == <STRING> : <NEWLINE> <INDENT> cc_export ( ) <NEWLINE> exit ( 0 ) <NEWLINE> <DEDENT> from my_module import solve <NEWLINE> main ( ) <NEWLINE> <DEDENT>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> arr = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> s = [ list ( map ( int , input ( ) . split ( ) ) ) for y in range ( M ) ] <NEWLINE> s ( key = lambda z : z [ 1 ] , reverse = True ) <NEWLINE> <NL> sum_a = 0 <NEWLINE> for a , b in s : <NEWLINE> <INDENT> arr += [ b ] * a <NEWLINE> sum_a += a <NEWLINE> if sum_a >= N : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> lst = sorted ( arr ) <NEWLINE> ans = sum ( lst [ - N : ] ) <NEWLINE> print ( ans ) <NEWLINE>
icase = 0 <NEWLINE> if icase == 0 : <NEWLINE> <INDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> d = [ ] <NEWLINE> cb = [ [ 0 ] * 2 for i in range ( m ) ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> bi , ci = map ( int , input ( ) . split ( ) ) <NEWLINE> cb [ i ] = [ ci , bi ] <NEWLINE> <DEDENT> <DEDENT> elif icase == 2 : <NEWLINE> <INDENT> n , m = 10 , 3 <NEWLINE> a = [ 1 , 4 , 5 , 5 , 7 , 8 , 13 , 33 , 52 , 100 ] <NEWLINE> cb = [ [ 30 , 4 ] , [ 10 , 3 ] , [ 4 , 1 ] ] <NEWLINE> <NL> <DEDENT> a . sort ( ) <NEWLINE> cb . sort ( reverse = True ) <NEWLINE> <NL> if cb [ 0 ] [ 0 ] <= a [ 0 ] : <NEWLINE> <INDENT> print ( sum ( a ) ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> asum = 0 <NEWLINE> isum = 0 <NEWLINE> isumm = 0 <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> isum += cb [ i ] [ 1 ] <NEWLINE> if isum > n : <NEWLINE> <INDENT> if a [ - 1 ] <= cb [ i ] [ 0 ] : <NEWLINE> <INDENT> asum += cb [ i ] [ 0 ] * ( n - isumm ) <NEWLINE> print ( asum ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ii = bisect_right ( a , cb [ i ] [ 0 ] ) <NEWLINE> asum += cb [ i ] [ 0 ] * ( ii - isumm ) <NEWLINE> asum += sum ( a [ ii : ] ) <NEWLINE> print ( asum ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT> if a [ isum - 1 ] <= cb [ i ] [ 0 ] : <NEWLINE> <INDENT> asum += cb [ i ] [ 0 ] * cb [ i ] [ 1 ] <NEWLINE> isumm = isum <NEWLINE> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ii = bisect_right ( a , cb [ i ] [ 0 ] ) <NEWLINE> asum += cb [ i ] [ 0 ] * ( ii - isumm ) <NEWLINE> asum += sum ( a [ ii : ] ) <NEWLINE> print ( asum ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> isumm = isum <NEWLINE> <NL> <DEDENT> asum += sum ( a [ isumm : ] ) <NEWLINE> <NL> print ( asum ) <NEWLINE>
n , m = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a . sort ( ) <NEWLINE> list = [ list ( map ( int , input ( ) . split ( ) ) ) for x in range ( m ) ] <NEWLINE> list . sort ( list , key = lambda x : x [ 1 ] , reverse = True ) <COMMENT> <NEWLINE> <NL> app_count = 0 <NEWLINE> for i in list : <NEWLINE> <INDENT> a += [ i [ 1 ] ] * i [ 0 ] <NEWLINE> app_count += i [ 0 ] <NEWLINE> if app_count > n : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> a . sort ( reverse = True ) <NEWLINE> <NL> print ( a [ : n ] ) <NEWLINE>
<INDENT> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <DEDENT> import heapq <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> heapq . heapify ( A ) <NEWLINE> BC = [ ] <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> B , C = map ( int , input ( ) . split ( ) ) <NEWLINE> BC . append ( ( B , C ) ) <NEWLINE> <DEDENT> BC . sort ( key = lambda x : x [ 1 ] , reverse = True ) <NEWLINE> import bisect <NEWLINE> A . sort ( ) <NEWLINE> now = 0 <NEWLINE> D = [ 0 ] * N <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> B = BC [ i ] [ 0 ] <NEWLINE> C = BC [ i ] [ 1 ] <NEWLINE> for j in range ( now , min ( now + B , N ) ) : <NEWLINE> <INDENT> D [ j ] = C <NEWLINE> <DEDENT> now += B <NEWLINE> if now > N - 1 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> a = A [ i ] <NEWLINE> d = D [ i ] <NEWLINE> if d > a : <NEWLINE> <INDENT> A [ i ] = d <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> print ( sum ( A ) ) <NEWLINE>
import heapq <NEWLINE> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> aas = list ( map ( int , input ( ) . split ( ) ) ) . sort ( ) <NEWLINE> hq = [ ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> heapq . heappush ( hq , ( - c , b ) ) <NEWLINE> <DEDENT> i = 0 <NEWLINE> while hq : <NEWLINE> <INDENT> - c , b = heapq . heappop ( hq ) <NEWLINE> for j in range ( i , min ( n , i + b ) ) : <NEWLINE> <INDENT> if aas [ j ] < c : <NEWLINE> <INDENT> aas [ j ] = c <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( sum ( aas ) ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> i = j + 1 <NEWLINE> <DEDENT> print ( sum ( aas ) ) <NEWLINE>
import heapq <NEWLINE> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> heapq . heapify ( a ) <NEWLINE> bc = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( m ) ] <NEWLINE> bc . sort ( key = lambda x : x [ 1 ] , reverse = True ) <NEWLINE> <NL> for i in range ( m ) : <NEWLINE> <INDENT> if a [ b - 1 ] >= bc [ i ] [ 1 ] : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> while cnt < bc [ i ] [ 0 ] : <NEWLINE> <INDENT> heapq . heapreplace ( a , bc [ i ] [ 1 ] ) <NEWLINE> cnt += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( sum ( a ) ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = input ( ) <NEWLINE> <NL> a = list ( a ) <NEWLINE> a [ k - 1 ] = a [ k - 1 ] . lower ( ) <NEWLINE> a = <STRING> . join ( a ) <NEWLINE> print ( a ) <NEWLINE> <NL> 127 <NEWLINE> a , b = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> if a >= 13 : <NEWLINE> <INDENT> print ( b ) <NEWLINE> <DEDENT> elif a >= 6 : <NEWLINE> <INDENT> print ( b // 2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> s = input ( ) <NEWLINE> print ( s [ : k - 1 ] + s [ k - 1 ] . lower ( ) + s [ k : ] ) <NEWLINE>
n , k = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> s = input ( ) <NEWLINE> <NL> k -= 1 <NEWLINE> <NL> if s [ k ] == <STRING> : <NEWLINE> <INDENT> s [ k ] = <STRING> <NEWLINE> <DEDENT> elif s [ k ] == <STRING> : <NEWLINE> <INDENT> s [ k ] = <STRING> <NEWLINE> <DEDENT> elif s [ k ] == <STRING> : <NEWLINE> <INDENT> s [ k ] = <STRING> <NEWLINE> <NL> <DEDENT> print ( s ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> s = list ( input ( ) . split ( ) ) <NEWLINE> <NL> print ( join ( s [ k - 1 ] . swapcase ( ) ) ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> S = str ( ) <NEWLINE> if ( S [ K ] = <STRING> ) : <NEWLINE> <INDENT> S [ K ] = <STRING> <NEWLINE> <DEDENT> elif ( S [ K ] = <STRING> ) : <NEWLINE> <INDENT> S [ K - 1 ] = <STRING> <NEWLINE> <DEDENT> elif ( S [ K ] = <STRING> ) : <NEWLINE> <INDENT> S [ K ] = <STRING> <NEWLINE> <DEDENT>
s = int ( input ( ) ) <NEWLINE> a = s % 100 <NEWLINE> b = ( ( s - a ) % 100 ) <NEWLINE> if a <= 31 and b <= 12 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a <= 12 and b <= 31 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a <= 12 and b <= 31 and a <= 31 and b <= 12 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
S = int ( input ( ) ) <NEWLINE> a = S % 100 <NEWLINE> b = ( S - ( S % 100 ) ) / 100 <NEWLINE> if b <= 12 and a <= 12 and a != 0 and b != 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif b <= 12 and a != 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a <= 12 and a != 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> s = input ( ) <NEWLINE> print ( s [ : k - 1 ] + s [ k - 1 ] . lower + s [ k : ] ) <NEWLINE>
word_S = input ( ) . split ( <STRING> ) [ - 1 ] <NEWLINE> S = list ( word_S ) <NEWLINE> change_K = int ( input ( ) ) <NEWLINE> word1 = <STRING> <NEWLINE> for i in range ( change_K - 1 ) : <NEWLINE> <INDENT> word1 = word1 + S [ i ] <NEWLINE> <DEDENT> word2 = S [ change_K - 1 ] <NEWLINE> word3 = <STRING> <NEWLINE> count = 0 <NEWLINE> while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> word3 = word3 + S [ change_K + count ] <NEWLINE> count += 1 <NEWLINE> <DEDENT> except IndexError : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> word2 = word2 . swapcase ( ) <NEWLINE> print ( word1 + word2 + word3 ) <NEWLINE>
x = input ( ) . split ( <STRING> ) <NEWLINE> command = x [ 1 ] <NEWLINE> N = x [ 0 ] <NEWLINE> N += command . lower ( x [ 1 ] ) <NEWLINE> print ( N ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> s = input ( ) <NEWLINE> s [ k - 1 ] = chr ( ord ( s [ k - 1 ] ) - ord ( <STRING> ) + ord ( <STRING> ) ) <NEWLINE> for c in s : <NEWLINE> <INDENT> print ( c , end = <STRING> ) <NEWLINE> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> S = [ ] <NEWLINE> S [ K - 1 ] = S [ K - 1 ] . lower ( ) <NEWLINE> print ( S ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> s = str ( input ( ) ) <NEWLINE> if s [ k - 1 ] == <STRING> : <NEWLINE> <INDENT> s [ k - 1 ] = <STRING> <NEWLINE> <DEDENT> elif s [ k - 1 ] == <STRING> : <NEWLINE> <INDENT> s [ k - 1 ] = <STRING> <NEWLINE> <DEDENT> elif s [ k - 1 ] == <STRING> : <NEWLINE> <INDENT> s [ k - 1 ] = <STRING> <NEWLINE> <DEDENT> print ( s ) <NEWLINE>
b = int ( input ( ) ) <NEWLINE> c = input ( ) <NEWLINE> c = c . replace ( c [ b - 1 ] , c [ b - 1 ] . lower ( ) ) <NEWLINE> print ( c ) <NEWLINE>
n , k = tuple ( int , input ( ) . split ( ) ) <NEWLINE> s = list ( input ( ) ) <NEWLINE> s [ k - 1 ] = s [ k - 1 ] . lower ( ) <NEWLINE> print ( <STRING> . join ( s ) ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> S = list ( input ( ) ) <NEWLINE> S [ K - 1 ] = S [ K - 1 ] . lower ( ) <NEWLINE> print ( sum ( S ) ) <NEWLINE>
n , k = map ( int , input ( <STRING> ) . split ( <STRING> ) ) <NEWLINE> s = input ( <STRING> ) <NEWLINE> if len ( s ) = n : <NEWLINE> <INDENT> slist = lis ( ( s ) ) <NEWLINE> swapcase ( slist [ k - 1 ] ) <NEWLINE> <NL> <DEDENT> for i in range ( 0 , len ( slist ) - 1 ) : <NEWLINE> <INDENT> print ( slist [ i ] , end = <STRING> ) <NEWLINE> <DEDENT>
N = int ( input ( <STRING> ) ) <NEWLINE> K = int ( input ( <STRING> ) ) <NEWLINE> s = str ( input ( <STRING> ) ) <NEWLINE> print ( s [ 0 : K - 1 ] + s [ K - 1 ] . lower ( ) + s [ K : ] ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if S [ K - 1 ] == <STRING> : rep = <STRING> <NEWLINE> elif S [ K - 1 ] == <STRING> : rep = <STRING> <NEWLINE> else : rep = <STRING> <NEWLINE> <NL> print ( S [ : K ] + rep + S [ K + 1 : ] ) <NEWLINE>
n , k = input ( ) . split ( ) <NEWLINE> s = input ( ) <NEWLINE> <NL> s = list ( s ) <NEWLINE> s [ k - 1 ] = s [ k - 1 ] . lower ( ) <NEWLINE> s = <STRING> . join ( s ) <NEWLINE> print ( s ) <NEWLINE>
small = [ <STRING> , <STRING> , <STRING> ] <NEWLINE> capital = [ <STRING> , <STRING> , <STRING> ] <NEWLINE> <NL> tmp = input ( ) . split ( <STRING> ) <NEWLINE> N = int ( tmp [ 0 ] ) <NEWLINE> K = int ( tmp [ 1 ] ) <NEWLINE> str = input ( ) <NEWLINE> <NL> str [ K ] = small [ capital . index ( str [ K ] ) ] <NEWLINE> <NL> print ( str ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> S = input ( ) <NEWLINE> <NL> S [ K - 1 ] = S [ k - 1 ] . lower ( ) <NEWLINE> print ( S ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> s = list ( map ( str , input ( ) . split ( ) ) ) <NEWLINE> k = k - 1 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> if i != k : <NEWLINE> <INDENT> print ( s [ i ] , end = <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = s [ i ] . lower ( ) <NEWLINE> print ( x , end = <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> s = input ( ) <NEWLINE> <NL> print ( s [ : k - 1 ] + s . upper [ k - 1 ] + s [ k : ] ) <NEWLINE>
s = input ( ) <NEWLINE> s_f = int ( s [ 0 ] + s [ 1 ] ) <NEWLINE> s_b = int ( s [ 2 ] + s [ 3 ] ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> if s_f == 0 or s_b == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif s_f <= 12 and s_b <= 12 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif s_f <= 12 and s_b > 12 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif s_f > 12 and s_b <= 12 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif s_f > 12 and s_b > 12 <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT>
S = input ( ) <NEWLINE> f = int ( S [ 0 ] + S [ 1 ] ) <NEWLINE> b = int ( S [ 2 ] + S [ 3 ] ) <NEWLINE> <NL> def judge ( int ) : <NEWLINE> <INDENT> if 1 <= int <= 12 <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> <DEDENT> ref = [ judge ( f ) , judge ( b ) ] <NEWLINE> <NL> if ref == [ 1 , 1 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif ref == [ 0 , 1 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif ref == [ 1 , 0 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
YYMM = False <NEWLINE> MMYY = False <NEWLINE> f = input ( ) <NEWLINE> h1 = f [ 0 ] + f [ 1 ] <NEWLINE> h2 = f [ 2 ] + f [ 3 ] <NEWLINE> <NL> if 1 <= h2 <= 12 : <NEWLINE> <INDENT> YYMM = True <NEWLINE> <DEDENT> if 1 <= h1 <= 12 : <NEWLINE> <INDENT> MMYY = True <NEWLINE> <NL> <DEDENT> def ret ( c1 , c2 ) : <NEWLINE> <INDENT> if c1 and c2 : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> elif c1 : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> elif c2 : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ret ( YYMM , MMYY ) ) <NEWLINE>
try : <NEWLINE> <INDENT> s1 = ( input ( <STRING> ) ) <NEWLINE> if len ( s1 ) >= 4 : <NEWLINE> <INDENT> raise ValueError <NEWLINE> <NL> <DEDENT> check = list ( ( s1 ) ) <NEWLINE> assert bool ( int ( check [ 0 ] + check [ 1 ] ) <= 12 ) != bool ( int ( check [ 2 ] + check [ 3 ] ) <= 12 ) <NEWLINE> if int ( check [ 0 ] + check [ 1 ] ) <= 12 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif int ( check [ 2 ] + check [ 3 ] ) <= 12 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> except AssertionError : <NEWLINE> <INDENT> if int ( check [ 0 ] + check [ 1 ] ) <= 12 and int ( check [ 2 ] + check [ 3 ] ) <= 12 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT>
a = input ( a ) <NEWLINE> b = int ( a [ 0 ] + a [ 1 ] ) <NEWLINE> c = int ( a [ 2 ] + a [ 3 ] ) <NEWLINE> if 1 <= b <= 12 and 1 <= c <= 12 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif b > 12 : <NEWLINE> <INDENT> if c > 12 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif 1 <= c <= 12 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> elif c > 12 : <NEWLINE> <INDENT> if b > 12 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif 1 <= b <= 12 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
<NL> n1 , n2 = int ( n [ : 2 ] ) , int ( n [ 2 : ] ) <NEWLINE> if ( n1 > 12 and n2 > 12 ) or ( n1 == 0 and n2 == 0 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif ( n1 != 0 and n1 <= 12 ) and ( n2 != 0 and n2 <= 12 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif n1 != 0 and n1 <= 12 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif n2 != 0 and n2 <= 12 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT>
s = raw_input ( ) <NEWLINE> <NL> a = int ( s [ : 2 ] ) <NEWLINE> b = int ( s [ 2 : ] ) <NEWLINE> <NL> if 0 < a < 13 : <NEWLINE> <INDENT> if 0 < b < 13 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if - 1 < b < 13 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> n = int ( input ( ) ) <NEWLINE> a = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> s , p = map ( str , input ( ) . split ( ) ) <NEWLINE> p = int ( p ) <NEWLINE> a . append ( ( s , p , i + 1 ) ) <NEWLINE> <COMMENT> <NL> <DEDENT> a . sort ( key = lambda x : x [ 1 ] , reverse = True ) <NEWLINE> <COMMENT> <NL> a . sort ( key = lambda x : x [ 0 ] ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> print ( a [ i ] [ 2 ] ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> <NL> b = int ( s [ : 2 ] ) <NEWLINE> a = int ( s [ 2 : ] ) <NEWLINE> <NL> print ( b ) <NEWLINE> print ( a ) <NEWLINE> <NL> def yorm ( i ) : <NEWLINE> <INDENT> flag = <STRING> <NEWLINE> if 0 < i < 12 : <NEWLINE> <INDENT> flag = <STRING> <NEWLINE> <DEDENT> elif i < 100 : <NEWLINE> <INDENT> flag = <STRING> <NEWLINE> <DEDENT> return flag <NEWLINE> <NL> <DEDENT> ans = bf + af <NEWLINE> if len ( ans ) != 4 : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <DEDENT> if ans == <STRING> : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <DEDENT> if ans == <STRING> : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
S = int ( input ( ) ) <NEWLINE> a = s // 100 <NEWLINE> b = s % 100 <NEWLINE> if a > 0 and a <= 12 : <NEWLINE> <INDENT> if b > 0 and b <= 12 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if b > 0 and b <= 12 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
def f ( y , m ) : <NEWLINE> <INDENT> if y in range ( 1 , 13 ) and m in range ( 1 , 13 ) : <NEWLINE> <INDENT> return <STRING> <NEWLINE> if m in range ( 1 , 13 ) : <NEWLINE> return <STRING> <NEWLINE> if y in range ( 1 , 13 ) : <NEWLINE> return <STRING> <NEWLINE> return <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> S = input ( ) <NEWLINE> y , m = int ( S [ : 2 ] ) , int ( S [ 2 : ] ) <NEWLINE> print ( f ( y , m ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> K = int ( input ( ) ) <NEWLINE> result = 0 <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> prob = 1 <NEWLINE> count = i <NEWLINE> while count < K : <NEWLINE> <INDENT> prob *= 0.5 <NEWLINE> count *= 2 <NEWLINE> <DEDENT> result += prob / N <NEWLINE> <DEDENT> print ( result ) <NEWLINE>
D = int ( input ( ) ) <NEWLINE> P = int ( input ( ) ) <NEWLINE> ans = 0.0 <NEWLINE> def func ( i ) : <NEWLINE> <INDENT> t = 0 <NEWLINE> while ( i < P ) : <NEWLINE> <INDENT> i *= 2 <NEWLINE> t += 1 <NEWLINE> <DEDENT> return t <NEWLINE> <NL> <DEDENT> for i in range ( 1 , D + 1 ) : <NEWLINE> <INDENT> ans += float ( ( 1 / D ) ) * float ( ( ( 1 / 2 ) ** func ( i ) ) ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
n , k = map ( int , input ( ) . strip ( ) . split ( ) ) <NEWLINE> c = 0 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if n > k : <NEWLINE> <INDENT> c += 1 / n <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> while i < k : <NEWLINE> <INDENT> i *= 2 <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> c += 1 / N * ( 1 / 2 ) ** cnt <NEWLINE> <DEDENT> <DEDENT> print ( c ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> p = 0 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if i < k : <NEWLINE> <INDENT> count = 1 <NEWLINE> while i * count < k : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> p += 0.5 ^ float ( count ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> p += 1 <NEWLINE> <DEDENT> <DEDENT> print ( p / n ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> for i in range ( 1 , n - 1 ) : <NEWLINE> <INDENT> p = i <NEWLINE> r = 1 <NEWLINE> while < k : <NEWLINE> <INDENT> p *= 2 <NEWLINE> r /= 2 <NEWLINE> <DEDENT> ans += r <NEWLINE> <NL> <DEDENT> ans /= n <NEWLINE> <NL> print ( ans ) <NEWLINE>
N , K = list ( map ( int , input ( ) . rstrip ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> p = 1 / N <NEWLINE> if j < K : <NEWLINE> <INDENT> while i < K : <NEWLINE> <INDENT> i *= 2 <NEWLINE> p *= 0.5 <NEWLINE> <DEDENT> <DEDENT> ans += p <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> j = 0 <NEWLINE> if i < k : <NEWLINE> <INDENT> while i * ( 2 ** j ) < k : <NEWLINE> <INDENT> j += 1 <NEWLINE> <DEDENT> ans += ( 1 / n ) * / ( 2 ** j ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += ( 1 / n ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from collections import deque <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> <NL> <NL> vlist = [ [ ] ] * N <NEWLINE> <NL> for i in range ( N - 1 ) : <NEWLINE> <INDENT> a , b , w = map ( int , input ( ) . split ( ) ) <NEWLINE> a -= 1 <NEWLINE> b -= 1 <NEWLINE> vlist [ a ] . append ( b , w ) <NEWLINE> vlist [ b ] . append ( a , w ) <NEWLINE> <NL> <DEDENT> ans = [ - 1 ] * N <NEWLINE> q = deque ( ) <NEWLINE> <NL> ans [ 0 ] = 0 <NEWLINE> q . append ( 0 ) <NEWLINE> <NL> while q : <NEWLINE> <INDENT> new = q . popleft ( ) <NEWLINE> for node , weight in vlist [ new ] : <NEWLINE> <INDENT> if ans [ node ] != - 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> ans [ node ] = ( ans [ new ] + weight ) % 2 <NEWLINE> q . append ( node ) <NEWLINE> <NL> <DEDENT> <DEDENT> for i in ans : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT>
from collections import deque <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> graph = [ [ ] for _ in range ( N ) ] <NEWLINE> for _ in range ( N - 1 ) : <NEWLINE> <INDENT> u , v , w = map ( int , input ( ) . split ( ) ) <NEWLINE> u , v , w = u - 1 , v - 1 , w % 2 <NEWLINE> graph [ u ] . append ( [ v , w ] ) <NEWLINE> graph [ v ] . append ( [ u , w ] ) <NEWLINE> <NL> <DEDENT> colors = [ - 1 for _ in range ( N ) ] <NEWLINE> stack = deque ( ) <NEWLINE> stack . append ( 0 ) <NEWLINE> colors [ 0 ] = 0 <NEWLINE> <NL> while stack : <NEWLINE> <INDENT> n = stack . pop ( ) <NEWLINE> for _next , w in graph [ n ] : <NEWLINE> <INDENT> if colors [ _next ] != - 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> colors [ _next ] = ( colors [ n ] + w ) % 2 <NEWLINE> stack . append ( [ _next ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> for c in colors : <NEWLINE> <INDENT> print ( c ) <NEWLINE> <DEDENT>
( n , ) , * t = [ map ( int , t , split ( ) ) for t in open ( 0 ) ] <NEWLINE> * e , = eval ( <STRING> * - ~ n ) <NEWLINE> q = [ ( 1 , 0 ) ] <NEWLINE> f = [ - 1 ] * n <NEWLINE> for v , w , c in t = : e [ v ] += ( w , c ) , ; e [ w ] += ( v , c ) , <NEWLINE> for v , c in q : <NEWLINE> <INDENT> f [ v - 1 ] = c % 2 <NEWLINE> for w , d in e [ v ] : q += [ ( w , c + d ) ] * ( f [ w - 1 ] < 0 ) <NEWLINE> <DEDENT> print ( * f ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> N = int ( input ( ) ) <NEWLINE> <NL> Graph = [ [ ] for _ in range ( N ) ] <NEWLINE> dist = [ ] * ( N ) <NEWLINE> <NL> for i in range ( N - 1 ) : <NEWLINE> <INDENT> u , v , w = map ( int , input ( ) . split ( ) ) <NEWLINE> u -= 1 <NEWLINE> v -= 1 <NEWLINE> Graph [ u ] . append ( ( v , w ) ) <NEWLINE> Graph [ v ] . append ( ( u , w ) ) <NEWLINE> <NL> <NL> <DEDENT> def func ( fromE , now , length ) : <NEWLINE> <INDENT> dist [ now ] = length <NEWLINE> <NL> for i in range ( len ( Graph [ now ] ) ) : <NEWLINE> <INDENT> target = Graph [ now ] [ i ] [ 0 ] <NEWLINE> lengt = Graph [ now ] [ i ] [ 1 ] <NEWLINE> <NL> if target == fromE : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <DEDENT> func ( now , target , dist [ now ] + lengt ) <NEWLINE> <NL> <DEDENT> <DEDENT> func ( - 1 , 0 , 0 ) <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> if dist [ i ] % 2 == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> <DEDENT>
from collections import deque <NEWLINE> <NL> graph = [ [ ] for _ in range ( N + 1 ) ] <NEWLINE> <NL> N , M = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for _ in range ( M ) : <NEWLINE> <INDENT> a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> graph [ a ] . append ( b ) <NEWLINE> graph [ b ] . append ( a ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> seen = [ False ] * ( N + 1 ) <NEWLINE> <NL> <NL> count = 0 <NEWLINE> <NL> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> if seen [ i ] == False : <NEWLINE> <INDENT> seen [ i ] = True <NEWLINE> S = deque ( [ i ] ) <NEWLINE> <NL> while S : <NEWLINE> <INDENT> v = S . popleft ( ) <NEWLINE> <COMMENT> <NL> for i in graph [ v ] : <NEWLINE> <INDENT> if seen [ i ] == False : <NEWLINE> <INDENT> seen [ i ] = True <NEWLINE> S . append ( i ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> par = [ i for i in range ( N + 1 ) ] <NEWLINE> size = [ 1 for _ in range ( N + 1 ) ] <NEWLINE> <NL> def find ( x ) : <NEWLINE> <INDENT> if par [ x ] == x : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> par [ x ] = find ( par [ x ] ) <NEWLINE> return par [ x ] <NEWLINE> <NL> <DEDENT> <DEDENT> def unite ( x , y ) : <NEWLINE> <INDENT> x = find ( x ) <NEWLINE> y = find ( y ) <NEWLINE> if x == y : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> par [ x ] = y <NEWLINE> size [ y ] += size [ x ] <NEWLINE> size [ x ] = 0 <NEWLINE> <NL> <DEDENT> for i in range ( M ) : <NEWLINE> <INDENT> x , y , z = map ( int , input ( ) . split ( ) ) <NEWLINE> unite ( x , y ) <NEWLINE> <NL> <DEDENT> Ans = 0 <NEWLINE> for j in size [ 1 : ] : <NEWLINE> <INDENT> if j != 0 : <NEWLINE> <INDENT> Ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( Ans ) <NEWLINE>
class UnionFind ( ) : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . par = [ i for i in range ( n ) ] <NEWLINE> self . rank = [ 0 ] * n <NEWLINE> <NL> <DEDENT> def root ( self , x ) : <NEWLINE> <INDENT> if self . par [ x ] == x : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . par [ x ] = self . root ( self . par [ x ] ) <NEWLINE> return self . par [ x ] <NEWLINE> <NL> <DEDENT> <DEDENT> def union ( self , x , y ) : <NEWLINE> <INDENT> x = self . root ( x ) <NEWLINE> y = self . root ( y ) <NEWLINE> if x != y : <NEWLINE> <INDENT> if self . rank [ x ] < self . rank [ y ] : <NEWLINE> <INDENT> self . par [ x ] = y <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . par [ y ] = x <NEWLINE> if self . rank [ x ] == self . rank [ y ] : <NEWLINE> <INDENT> self . rank [ x ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> def samegrp ( self , x , y ) : <NEWLINE> <INDENT> return self . root ( x ) == self . root ( y ) <NEWLINE> <NL> <DEDENT> <DEDENT> from mymodules . somedatastrs import UnionFind <NEWLINE> <NL> n , m = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> A = UnionFind ( n ) <NEWLINE> ans = n <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> x , y , _ = [ int ( z ) - 1 for z in input ( ) . split ( ) ] <NEWLINE> if not A . samegrp ( x , y ) : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <DEDENT> A . union ( x , y ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = 0 <NEWLINE> if N == K : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> for _ in range ( N - K ) : <NEWLINE> <INDENT> ans + + <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
a , b = map ( in , input ( ) . split ( ) ) <NEWLINE> print ( a - b + 1 ) <NEWLINE>
print ( int ( input ( ) ) + 1 ) <NEWLINE>
[ N , K ] = L ( ) <NEWLINE> <NL> def L ( ) : <NEWLINE> <INDENT> return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <DEDENT> print ( N - K + 1 ) <NEWLINE>
a , b = map ( int , input ( ) ) <NEWLINE> print ( a - b + 1 ) <NEWLINE>
cnt = 0 <NEWLINE> for r in range ( N // R + 1 ) : <NEWLINE> <INDENT> for g in range ( N // G + 1 ) : <NEWLINE> <INDENT> if ( N - r * R - g * G ) < 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if ( N - r * R - g * G ) % B == 0 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
R , G , B , N = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> for r in range ( N // R + 1 ) : <NEWLINE> <INDENT> for g in range ( tmp // G + 1 ) : <NEWLINE> <INDENT> check = ( tmp - R * r - G * g ) <NEWLINE> if check % B == 0 and check > 0 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = [ input ( ) for i in range ( n ) ] <NEWLINE> <NL> ab = 0 <NEWLINE> ba = 0 <NEWLINE> c2 = 0 <NEWLINE> c3 = 0 <NEWLINE> for x in s : <NEWLINE> <INDENT> if <STRING> in x : <NEWLINE> <INDENT> ab += x . count ( <STRING> ) <NEWLINE> <DEDENT> if x [ - 1 ] == <STRING> and x [ 0 ] == <STRING> : <NEWLINE> <INDENT> ba = 1 <NEWLINE> <DEDENT> if x [ - 1 ] == <STRING> and x [ 0 ] != <STRING> : <NEWLINE> <INDENT> c2 += 1 <NEWLINE> <DEDENT> if x [ - 1 ] != <STRING> and x [ 0 ] == <STRING> : <NEWLINE> <INDENT> c3 += 1 <NEWLINE> <DEDENT> <DEDENT> if ba > 0 : <NEWLINE> <INDENT> if c2 + c3 > 0 : <NEWLINE> <INDENT> ans = ab + ba + min ( c2 , c3 ) <NEWLINE> <DEDENT> else : <COMMENT> <NEWLINE> <INDENT> ans = ab + ba - 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S = [ input ( ) for _ in range ( N ) ] <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> include = 0 <NEWLINE> sb = 0 <NEWLINE> fa = 0 <NEWLINE> sbfa = 0 <NEWLINE> for s in S : <NEWLINE> <INDENT> if <STRING> in s : <NEWLINE> <INDENT> include += 1 <NEWLINE> <DEDENT> if s [ 0 ] == <STRING> and s [ - 1 ] == <STRING> : <NEWLINE> <INDENT> sbfa += 1 <NEWLINE> <DEDENT> elif s [ 0 ] == <STRING> : <NEWLINE> <INDENT> sb += 1 <NEWLINE> <DEDENT> elif s [ - 1 ] == <STRING> : <NEWLINE> <INDENT> fa += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> def calc_comb ( sb , fa , sbfa ) : <NEWLINE> <INDENT> ans = 0 <NEWLINE> if sbfa > 0 : <NEWLINE> <INDENT> ans += sbfa - 1 <NEWLINE> if sb > 0 : <NEWLINE> <INDENT> sb -= 1 <NEWLINE> ans += 1 <NEWLINE> <DEDENT> if fa > 0 : <NEWLINE> <INDENT> fa -= 1 <NEWLINE> ans += 1 <NEWLINE> <DEDENT> <DEDENT> ans += min ( sb , fa ) <NEWLINE> <NL> <DEDENT> print ( include + calc_comb ( sb , fa , sbfa ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( 1 , int ( n ** 0.5 ) + 1 ) : <NEWLINE> <INDENT> if n % i == 0 and n // ( i - 1 ) == n % ( i - 1 ) : <NEWLINE> <INDENT> ans += i - 1 <NEWLINE> <DEDENT> m = n // i - 1 <NEWLINE> if m > 0 and n % i == 0 and n // m == n % m : <NEWLINE> <INDENT> ans += m <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , 1250000 ) : <NEWLINE> <INDENT> if ( ( ( N - i ) / i ) . is_integer ( ) and N // ( ( N - i ) / i ) == N % ( ( N - i ) / i ) ) : <NEWLINE> <COMMENT> <NL> <INDENT> ans += ( ( N - i ) // i ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from collections import deque <NEWLINE> <NL> def main ( ) : <NEWLINE> h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ list ( input ( ) ) for _ in range ( h ) ] <NEWLINE> <INDENT> B = [ ] <NEWLINE> <NL> for i , a in enumerate ( A ) : <NEWLINE> <INDENT> for j , b in enumerate ( a ) : <NEWLINE> <INDENT> if b == <STRING> : <NEWLINE> <INDENT> B . append ( ( i , j ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> dxy = [ [ 1 , 0 ] , [ - 1 , 0 ] , [ 0 , 1 ] , [ 0 , - 1 ] ] <NEWLINE> <NL> stack = deque ( B ) <NEWLINE> darked = len ( stack ) <NEWLINE> targetd = h * w <NEWLINE> count = 0 <NEWLINE> <NL> while darked < targetd : <NEWLINE> <INDENT> nextd = deque ( [ ] ) <NEWLINE> <NL> while stack : <NEWLINE> <INDENT> x , y = stack . popleft ( ) <NEWLINE> for dx , dy in dxy : <NEWLINE> <INDENT> X = x + dx <NEWLINE> Y = y + dy <NEWLINE> if not ( 0 <= X < h ) or not ( 0 <= Y < w ) : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if A [ X ] [ Y ] == <STRING> : <NEWLINE> <INDENT> A [ X ] [ Y ] = <STRING> <NEWLINE> nextd . append ( ( X , Y ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> count += 1 <NEWLINE> stack = nextd <NEWLINE> darked += len ( stack ) <NEWLINE> <DEDENT> print ( count ) <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE>
a , b , t = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( int ( ( ( t + 0.5 ) // a * b ) ) <NEWLINE>
a , b , t = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( t // a * b ) <NEWLINE> debug_pri <NEWLINE>
a , b , t = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = 0 <NEWLINE> T = A <NEWLINE> while ( T <= t ) : <NEWLINE> <INDENT> ans += B <NEWLINE> T += A <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
using System ; <NEWLINE> using System . Runtime . InteropServices ; <NEWLINE> <NL> namespace ConsoleApp2 <NEWLINE> { <NEWLINE> <INDENT> class Program <NEWLINE> { <NEWLINE> <INDENT> static void Main ( string [ ] args ) <NEWLINE> { <NEWLINE> <INDENT> int a , b , t ; <NEWLINE> string [ ] str = Console . ReadLine ( ) . Split ( <STRING> ) ; <NEWLINE> a = int . Parse ( str [ 0 ] ) ; <NEWLINE> b = int . Parse ( str [ 1 ] ) ; <NEWLINE> t = int . Parse ( str [ 2 ] ) ; <NEWLINE> Console . WriteLine ( b * ( t / a ) ) ; <NEWLINE> <DEDENT> } <NEWLINE> <DEDENT> } <NEWLINE> <DEDENT> } <NEWLINE>
a , b , t = map ( int ( input ( ) . split ( ) ) ) <NEWLINE> n = int ( t / a ) <NEWLINE> print ( n * b ) <NEWLINE>
A , B , T = map ( input ( ) . split ( ) ) <NEWLINE> print ( T // A * B ) <NEWLINE>
a , b , t = map ( int , input ( ) . split ) <NEWLINE> <NL> print ( b * ( a // t ) ) <NEWLINE>
n = input ( ) . split ( ) <NEWLINE> ans = int ( int ( n [ 2 ] + 0.5 ) / n [ 1 ] ) * n [ 1 ] <NEWLINE> print ( ans ) <NEWLINE>
a , b , t = map ( int , input ( ) , split ( ) ) <NEWLINE> print ( ( ( t + 1 / 2 ) // a ) * b ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> a , b , t = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( t + 0.51 , 1 ) : <NEWLINE> <INDENT> if i % a == 0 : <NEWLINE> <INDENT> ans += b <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <DEDENT> main ( ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> v = [ ] <NEWLINE> c = [ ] <NEWLINE> x = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> v [ i ] = int ( input ( ) ) <NEWLINE> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> c [ i ] = int ( input ( ) ) <NEWLINE> x [ i ] = v [ i ] - c [ i ] <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> while x [ i ] > 0 : <NEWLINE> <INDENT> ans += x [ i ] <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
input ( ) <NEWLINE> v = list ( map ( int , input ( ) . split ( ) ) <NEWLINE> c = list ( map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ max ( 0 , i - j ) for i , j in zip ( v , c ) ] <NEWLINE> print ( sum ( a ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> v = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c = list ( map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> m = 0 <NEWLINE> <NL> for i in range ( len ( v ) ) : <NEWLINE> <INDENT> if v [ i ] > c [ i ] : <NEWLINE> <INDENT> m += v [ i ] - c [ i ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( m ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> k = 0 <NEWLINE> v = [ map ( int , input ( ) . split ( ) ) ] <NEWLINE> c = [ map ( int , input ( ) . split ( ) ) ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if ( v [ i ] - c [ i ] ) > 0 : <NEWLINE> <INDENT> k += ( v [ i ] - c [ i ] ) <NEWLINE> <DEDENT> <DEDENT> print ( k ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> v = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> if v [ i ] > c [ i ] : <NEWLINE> <INDENT> ans += v [ i ] - c [ i ] <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> from fractions import gcd <NEWLINE> <NL> <NL> class SegmentTree ( ) : <NEWLINE> <INDENT> _data = [ ] <NEWLINE> _offset = 0 <NEWLINE> _size = 0 <NEWLINE> <NL> def __init__ ( self , size ) : <NEWLINE> <INDENT> _size = size <NEWLINE> t = 1 <NEWLINE> while t < size : <NEWLINE> <INDENT> t *= 2 <NEWLINE> <DEDENT> self . _offset = t - 1 <NEWLINE> self . _data = [ 0 ] * ( t * 2 - 1 ) <NEWLINE> <NL> <DEDENT> def update_all ( self , iterable ) : <NEWLINE> <INDENT> self . _data [ self . _offset : self . _offset + self . _size ] = iterable <NEWLINE> for i in range ( self . _offset - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> self . _data [ i ] = gcd ( self . _data [ i * 2 + 1 ] , self . _data [ i * 2 + 2 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> def update ( self , index , value ) : <NEWLINE> <INDENT> i = self . _offset + index <NEWLINE> self . _data [ i ] = value <NEWLINE> while i >= 1 : <NEWLINE> <INDENT> i = ( i - 1 ) // 2 <NEWLINE> self . _data [ i ] = gcd ( self . _data [ i * 2 + 1 ] , self . _data [ i * 2 + 2 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> def query ( self , start , stop ) : <NEWLINE> <INDENT> result = 0 <NEWLINE> l = start + self . _offset <NEWLINE> r = stop + self . _offset <NEWLINE> while l < r : <NEWLINE> <INDENT> if l & 1 == 0 : <NEWLINE> <INDENT> result = gcd ( result , self . _data [ l ] ) <NEWLINE> <DEDENT> if r & 1 == 0 : <NEWLINE> <INDENT> result = gcd ( result , self . _data [ r - 1 ] ) <NEWLINE> <DEDENT> l = l // 2 <NEWLINE> r = ( r - 1 ) // 2 <NEWLINE> <DEDENT> return result <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> st = SegmentTree ( N ) <NEWLINE> st . update_all ( A ) <NEWLINE> <NL> result = st . query ( 1 , N ) <NEWLINE> for i in range ( 1 , N - 1 ) : <NEWLINE> <INDENT> result = max ( result , gcd ( st . query ( 0 , i ) , st . query ( i + 1 , N ) ) ) <NEWLINE> <DEDENT> result = max ( result , st . query ( 0 , N - 1 ) ) <NEWLINE> print ( result ) <NEWLINE>
import math <NEWLINE> from functools import reduce <NEWLINE> <NL> def gcd ( numbers ) : <NEWLINE> <INDENT> return reduce ( math . gcdm numbers ) <NEWLINE> <NL> <DEDENT> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = [ ] <NEWLINE> <NL> if len ( A ) == 1 : <NEWLINE> <INDENT> ans . append ( A [ 0 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans . append ( gcd ( A [ 1 : ] ) ) <NEWLINE> ans . append ( gcd ( A [ : N ] ) ) <NEWLINE> <NL> for i in range ( 1 , N - 1 ) : <NEWLINE> <INDENT> l = [ ] <NEWLINE> l . append ( gcd ( A [ : i ] ) ) <NEWLINE> l . append ( gcd ( A [ i + 1 : ] ) ) <NEWLINE> ans . append ( gcd ( l ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( max ( ans ) ) <NEWLINE>
import math <NEWLINE> from itertools import accumulate <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> fromleft = list ( accumulate ( a , math . gcd ) ) <NEWLINE> fromright = list ( accumulate ( a [ : : - 1 ] , math . gcd ) ) . reverse ( ) <NEWLINE> <NL> gcd = [ ] <NEWLINE> <NL> gcd . append ( fromright [ 1 ] ) <NEWLINE> for i in range ( 1 , n - 1 ) : <NEWLINE> <INDENT> gcd . append ( math . gcd ( fromleft [ i - 1 ] , fromright [ i + 1 ] ) ) <NEWLINE> <DEDENT> gcd . append ( fromleft [ n - 2 ] ) <NEWLINE> <NL> print ( max ( gcd ) ) <NEWLINE>
import collections <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> <NL> As = [ int ( item ) for item in input ( ) . split ( ) ] <NEWLINE> <NL> cnt = 0 <NEWLINE> <NL> Bs = collections . deque ( ) <NEWLINE> <NL> min1 = 1000000000000 <NEWLINE> <NL> for i in As : <NEWLINE> <NL> <INDENT> if As < 0 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <NL> <DEDENT> Bs . append ( abs ( i ) ) <NEWLINE> <NL> mim1 = min ( min1 , abs ( i ) ) <NEWLINE> <NL> <NL> <NL> <DEDENT> if cnt % 2 = 0 : <NEWLINE> <NL> <INDENT> print ( sum ( list ( Bs ) ) ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <NL> <INDENT> print ( sum ( list ( Bs ) ) - min1 * 2 ) <NEWLINE> <DEDENT>
from bisect import bisect_left , bisect , bisect_right <NEWLINE> import sys <NEWLINE> <NL> icase = 1 <NEWLINE> if icase == 0 : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <DEDENT> a . sort ( ) <NEWLINE> ii = bisect ( a , 0 ) <NEWLINE> <NL> if ii == n : <NEWLINE> <INDENT> if ii % 2 == 0 : <NEWLINE> <INDENT> asum = - sum ( a ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> asum = - sum ( a [ 0 : ii - 1 ] ) + a [ ii - 1 ] <NEWLINE> <DEDENT> print ( asum ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> if ii % 2 == 0 : <NEWLINE> <INDENT> asum = - sum ( a [ 0 : ii ] ) + sum ( a [ ii : ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if - a [ ii - 1 ] < a [ ii ] : <NEWLINE> <INDENT> d = a [ ii - 1 ] + a [ ii ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d = - a [ ii - 1 ] - a [ ii ] <NEWLINE> <DEDENT> asum = - sum ( a [ 0 : ii - 1 ] ) + d + sum ( a [ ii + 1 : ] ) <NEWLINE> <NL> <DEDENT> print ( asum ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> s , cnt = [ 0 ] * n , 0 <NEWLINE> for i in a : <NEWLINE> <INDENT> s [ i ] = abs ( i ) <NEWLINE> if i < 0 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> if cnt % 2 : <NEWLINE> <INDENT> print ( sum ( s ) - 2 * min ( s ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( sum ( s ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> print ( <STRING> if A <= 8 and B <= 8 else <STRING> ) <NEWLINE>
a , b , c = map ( int , input . rstrip ( ) . split ( <STRING> ) ) <NEWLINE> if ( a < c < b ) or ( b < c < a ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> s = str ( input ( ) ) <NEWLINE> k = int ( input ( ) ) <NEWLINE> wordn = <STRING> <NEWLINE> w = s [ k - 1 ] <NEWLINE> for i in s : <NEWLINE> <INDENT> if w != i : <NEWLINE> <INDENT> word += <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> word += w <NEWLINE> <DEDENT> <DEDENT> print ( word ) <NEWLINE>
n = input ( ) <NEWLINE> s = input ( ) <NEWLINE> i = input ( ) <NEWLINE> <NL> l = [ ] <NEWLINE> for i , c in enumerate ( s ) : <NEWLINE> <INDENT> l . append ( * if c != s [ i - 1 ] else c ) <NEWLINE> <NL> <DEDENT> <STRING> . join ( l ) <NEWLINE> <NL> print ( l ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S = list ( input ( ) ) <NEWLINE> K = int ( input ( ) ) <NEWLINE> for i in S : <NEWLINE> <INDENT> if s [ i - 1 ] != s [ k ] : <NEWLINE> <INDENT> s [ i - i ] = <STRING> <NEWLINE> <DEDENT> <DEDENT> print ( S ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> k = int ( input ( ) ) <NEWLINE> ss = s [ k - 1 ] <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> if s [ i ] != ss : <NEWLINE> <INDENT> s [ i ] = <STRING> <NEWLINE> <DEDENT> <DEDENT> print ( s ) <NEWLINE>
_ = input ( ) <NEWLINE> S = input ( ) . lstrip ( <STRING> ) . rstrip ( <STRING> ) <NEWLINE> n = len ( S ) <NEWLINE> <NL> x = 0 <NEWLINE> y = S . count ( <STRING> ) <NEWLINE> c = min ( n - y , y ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> t = S [ i ] == <STRING> : <NEWLINE> x += t <NEWLINE> y -= not t <NEWLINE> c = min ( c , x + y ) <NEWLINE> <DEDENT> print ( c ) <NEWLINE>
_ = input ( ) <NEWLINE> S = input ( ) . lstrip ( <STRING> ) . rstrip ( <STRING> ) <NEWLINE> n = len ( S ) <NEWLINE> <NL> x = 0 <NEWLINE> y = S . count ( <STRING> ) <NEWLINE> c = min ( n - y , y ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if S [ i ] == <STRING> : <NEWLINE> <INDENT> x += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> y -= 1 <NEWLINE> <DEDENT> c = min ( ans , x + y ) <NEWLINE> <DEDENT> print ( c ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> a = 0 <NEWLINE> b = S . count ( <STRING> ) <NEWLINE> num = min ( N - y , y ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> x = S [ i ] == <STRING> <NEWLINE> a += x <NEWLINE> b -= 1 - x <NEWLINE> num = num ( num , a + b ) <NEWLINE> <DEDENT> print ( num ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> N = map ( int , input . split ( ) ) <NEWLINE> S = input ( ) <NEWLINE> black = S . count ( <STRING> ) <NEWLINE> white = S . count ( <STRING> ) <NEWLINE> <NL> if black == N or white == N : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> B = [ 0 ] * ( N + 1 ) <NEWLINE> W = [ 0 ] * ( N + 1 ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if S [ i ] == <STRING> : <NEWLINE> <INDENT> B [ i + 1 ] = 1 <NEWLINE> <DEDENT> elif W [ i ] == <STRING> : <NEWLINE> <INDENT> W [ i + 1 ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> B [ i ] += B [ i - 1 ] <NEWLINE> W [ i ] += W [ i - 1 ] <NEWLINE> <DEDENT> ans = float ( <STRING> ) <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> ans = min ( ans , B [ i ] + white - W [ i ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> main ( ) <NEWLINE>
N , S = open ( 0 ) . read ( ) . split ( ) <NEWLINE> N = int ( N ) <NEWLINE> S = list ( S ) <NEWLINE> <NL> def calc ( ) : <NEWLINE> <INDENT> group = [ ] if S [ 0 ] == <STRING> else [ 0 ] <NEWLINE> n = 0 <NEWLINE> mark = S [ 0 ] <NEWLINE> for s in S : <NEWLINE> <INDENT> if s == mark : <NEWLINE> <INDENT> n += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> mark = s <NEWLINE> group . append ( n ) <NEWLINE> n = 1 <NEWLINE> <DEDENT> <DEDENT> if n > 0 : <NEWLINE> <INDENT> group . append ( n ) <NEWLINE> <DEDENT> if S [ - 1 ] == <STRING> : <NEWLINE> <INDENT> group . pop ( ) <NEWLINE> <NL> <DEDENT> cnt = 0 <NEWLINE> i = 1 <NEWLINE> j = len ( group ) - 1 <NEWLINE> while i <= j : <NEWLINE> <INDENT> l = group [ i ] <NEWLINE> r = group [ j ] <NEWLINE> if l < r : <NEWLINE> <INDENT> cnt += l <NEWLINE> i += 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cnt += r <NEWLINE> j -= 2 <NEWLINE> <DEDENT> <DEDENT> return cnt <NEWLINE> <NL> <DEDENT> all_w = sum ( [ 1 if s == <STRING> else 0 for s in S ] ) <NEWLINE> all_b = sum ( [ 1 if s == <STRING> else 0 for s in S ] ) <NEWLINE> lwrb = calc ( ) <NEWLINE> print ( min ( all_w , all_b , lwrb ) <NEWLINE>
a , b = map ( int , input ( ) ) <NEWLINE> print ( max ( a , b ) * 2 - 1 ) <NEWLINE>
n = list ( int ( input ( ) . split ( ) ) ) <NEWLINE> if n [ 0 ] == n [ 1 ] : <NEWLINE> <INDENT> print ( n [ 0 ] * 2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( max ( n ) * 2 - 1 ) <NEWLINE> <DEDENT>
m = input ( ) <NEWLINE> m = m . split ( <STRING> ) <NEWLINE> a = m [ 0 ] <NEWLINE> b = m [ 1 ] <NEWLINE> <NL> print ( max ( a + a - 1 , b + b - 1 , a + b ) ) <NEWLINE>
a , b = input ( ) . split ( ) <NEWLINE> M = max ( a , b ) <NEWLINE> m = min ( a , b ) <NEWLINE> <NL> n = 0 <NEWLINE> n += M <NEWLINE> M -= 1 <NEWLINE> <NL> n += max ( M , m ) <NEWLINE> <NL> print ( n ) <NEWLINE>
n , a , b , = map ( int , input ( ) . split ( ) ) <NEWLINE> if a * n > b : <NEWLINE> <INDENT> print ( b ) <NEWLINE> <DEDENT> if a * n < b : <NEWLINE> <INDENT> print ( a * n ) <NEWLINE> <DEDENT> if a * n == b : <NEWLINE> <INDENT> print ( a * n ) <NEWLINE> <DEDENT>
a , b = input ( ) . split ( ) <NEWLINE> a = int ( a ) <NEWLINE> b = int ( b ) <NEWLINE> if a - b >= 2 : <NEWLINE> <INDENT> print ( 2 a - 1 ) <NEWLINE> <DEDENT> if b - a >= 2 : <NEWLINE> <INDENT> print ( 2 b - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( a + b ) <NEWLINE> <DEDENT>
a , b = map ( int , input ( ) ) <NEWLINE> point = 0 <NEWLINE> point += max ( a , b ) <NEWLINE> <NL> if max ( a , b ) == a : <NEWLINE> <INDENT> point += max ( a - 1 , b ) <NEWLINE> print ( point ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> point += max ( a , b - 1 ) <NEWLINE> print ( point ) <NEWLINE> <DEDENT>
A = int ( input ( ) ) <NEWLINE> B = int ( input ( ) ) <NEWLINE> if A > B : <NEWLINE> <INDENT> print ( 2 * A - 1 ) <NEWLINE> <DEDENT> elif A < B : <NEWLINE> <INDENT> print ( 2 * B - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 2 * A ) <NEWLINE> <DEDENT>
A , B = map ( input ( ) . split ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( 2 ) : <NEWLINE> <INDENT> if A >= B : <NEWLINE> <INDENT> ans += A <NEWLINE> A -= 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += B <NEWLINE> B -= 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
a = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> if a >= 3200 : <NEWLINE> <INDENT> print ( s ) <NEWLINE> <DEDENT> if a < 3200 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if a == b : print ( a * 2 ) <NEWLINE> else print ( max ( a , b ) * 2 - 1 ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if a >= b : <NEWLINE> <INDENT> ans += a <NEWLINE> a -= 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += b <NEWLINE> b -= 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
a , b = map ( int , input ( ) ) <NEWLINE> if a == b : <NEWLINE> <INDENT> print ( 2 * b ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = max ( a , b ) <NEWLINE> print ( 2 * x - 1 ) <NEWLINE> <DEDENT>
( a , b ) = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( max ( a , b ) + max ( max ( a , b ) - 1 , min ( a , b ) ) <NEWLINE>
import numpy as np <NEWLINE> import math <NEWLINE> import collections <NEWLINE> import fractions <NEWLINE> import itertools <NEWLINE> <NL> def solve ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> m = h [ 0 ] <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , h - 1 ) : <NEWLINE> <INDENT> if h [ i ] >= m : <NEWLINE> <INDENT> ans += 1 <NEWLINE> m = h [ i ] <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> return 0 <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> solve ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> c = 0 <NEWLINE> <NL> for i in h : <NEWLINE> <INDENT> t = True <NEWLINE> for j in range ( i ) : <NEWLINE> <INDENT> if h [ j ] >= h [ i ] : <NEWLINE> <INDENT> t = False <NEWLINE> break <NEWLINE> c += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> H = list ( map ( int , input ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> m = - 1000 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if m <= H [ i ] : <NEWLINE> <INDENT> m = H [ i ] <NEWLINE> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
a = int ( input ( ) ) <NEWLINE> b = [ int ( input ( ) ) for i in range ( a ) ] <NEWLINE> c = 0 <NEWLINE> d = 0 <NEWLINE> for i in range ( a ) : <NEWLINE> <INDENT> if c < b [ i ] : <NEWLINE> <INDENT> c = b [ i ] <NEWLINE> d = d + 1 <NEWLINE> <DEDENT> <DEDENT> print ( d ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = int ( input ( ) ) <NEWLINE> cnt = 1 <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> b = int ( input ( ) ) <NEWLINE> if a <= b : <NEWLINE> <INDENT> cnt + + <NEWLINE> a = b <NEWLINE> <NL> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> H = [ int ( n ) for n in input ( ) . split ( ) ] <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> t = max ( H [ : i ] ) <NEWLINE> if t <= H [ i ] : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
s = int ( input ( ) ) <NEWLINE> <NL> start0 = 0 <NEWLINE> start1 = 0 <NEWLINE> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> if i % 2 == 0 : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> start1 += 1 <NEWLINE> <DEDENT> elif s [ i ] == <STRING> : <NEWLINE> <INDENT> start0 += 1 <NEWLINE> <DEDENT> <DEDENT> elif i % 2 == 1 : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> start0 += 1 <NEWLINE> <DEDENT> elif s [ i ] == <STRING> : <NEWLINE> <INDENT> start1 += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( min ( [ start0 , start1 ] ) ) <NEWLINE>
 <NEWLINE> <NL> Copy <NEWLINE> Copy <NEWLINE> <COMMENT> <NL> s = input ( ) <NEWLINE> len = len ( s ) <NEWLINE> <NL> if len == 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> even = s [ : : 2 ] <NEWLINE> odd = s [ 1 : : 2 ] <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> odd_zero = odd . count ( <STRING> ) <NEWLINE> even_one = even . count ( <STRING> ) <NEWLINE> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> odd_one = odd . count ( <STRING> ) <NEWLINE> even_zero = even . count ( <STRING> ) <NEWLINE> <NL> print ( min ( odd_zero + even_one , odd_one + even_zero ) ) <NEWLINE>
n = input ( ) <NEWLINE> <NL> counta = 0 <NEWLINE> countb = 0 <NEWLINE> if N % 2 == 0 : <NEWLINE> <INDENT> for i in range ( 0 , len ( n ) - 2 , 2 ) : <NEWLINE> <INDENT> if n [ i ] == <STRING> : <NEWLINE> <INDENT> counta += 1 <NEWLINE> <DEDENT> elif n [ i ] == <STRING> : <NEWLINE> <INDENT> countb += 1 <NEWLINE> <DEDENT> <DEDENT> for i in range ( 1 , len ( n ) - 1 , 2 ) : <NEWLINE> <INDENT> if n [ i ] == <STRING> : <NEWLINE> <INDENT> counta += 1 <NEWLINE> <DEDENT> elif n [ i ] == <STRING> : <NEWLINE> <INDENT> countb += 1 <NEWLINE> <DEDENT> <DEDENT> print ( min ( counta , countb ) ) <NEWLINE> <NL> <DEDENT> counta = 0 <NEWLINE> countb = 0 <NEWLINE> if N % 2 == 1 : <NEWLINE> <INDENT> for i in range ( 0 , len ( n ) - 1 , 2 ) : <NEWLINE> <INDENT> if n [ i ] == <STRING> : <NEWLINE> <INDENT> counta += 1 <NEWLINE> <DEDENT> elif n [ i ] == <STRING> : <NEWLINE> <INDENT> countb += 1 <NEWLINE> <DEDENT> <DEDENT> for i in range ( 1 , len ( n ) - 2 , 2 ) : <NEWLINE> <INDENT> if n [ i ] == <STRING> : <NEWLINE> <INDENT> counta += 1 <NEWLINE> <DEDENT> elif n [ i ] == <STRING> : <NEWLINE> <INDENT> countb += 1 <NEWLINE> <DEDENT> <DEDENT> print ( min ( counta , countb ) ) <NEWLINE> <DEDENT>
a = input ( ) <NEWLINE> b = int ( len ( a ) ) <NEWLINE> c = 0 <NEWLINE> d = 0 <NEWLINE> for i in range ( b ) : <NEWLINE> <INDENT> if a [ 2 * i ] == 1 : <NEWLINE> <INDENT> c = c + 1 <NEWLINE> <DEDENT> if a [ 2 * 1 + 1 ] == 0 : <NEWLINE> <INDENT> c = c + 1 <NEWLINE> <DEDENT> <DEDENT> for i in range ( b ) : <NEWLINE> <INDENT> if a [ 2 * i ] == 0 : <NEWLINE> <INDENT> d = d + 1 <NEWLINE> <DEDENT> if a [ 2 * 1 + 1 ] == 1 : <NEWLINE> <INDENT> d = d + 1 <NEWLINE> <DEDENT> <DEDENT> if c > d : <NEWLINE> <INDENT> print ( d ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( c ) <NEWLINE> <DEDENT>
<STRING> <NEWLINE> <NL> import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> <NL> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> s = input ( ) <NEWLINE> <NL> nums = [ ] <NEWLINE> now = 1 <COMMENT> <NEWLINE> cnt = 0 <COMMENT> <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> if s [ i ] == str ( now ) : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> nums . append ( cnt ) <NEWLINE> now ^= 1 <COMMENT> <NEWLINE> cnt = 1 <COMMENT> <NEWLINE> <DEDENT> <DEDENT> if cnt != 0 : <NEWLINE> <INDENT> nums . append ( cnt ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> if len ( nums ) % 2 == 0 : <NEWLINE> <INDENT> nums . append ( 0 ) <NEWLINE> <NL> <DEDENT> add = 2 * k + 1 <NEWLINE> <NL> <COMMENT> <NL> tot = [ 0 ] * ( len ( nums ) + 1 ) <NEWLINE> for i in range ( len ( tot ) ) : <NEWLINE> <INDENT> tot [ i + 1 ] = tot [ i ] + nums [ i ] <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> <NL> <COMMENT> <NL> for i in range ( 0 , len ( nums ) , 2 ) : <NEWLINE> <NL> <COMMENT> <NL> <INDENT> left = i <NEWLINE> right = min ( i + add , len ( nums ) ) <NEWLINE> tmp = tot [ right ] - tot [ left ] <NEWLINE> <NL> ans = max ( tmp , ans ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> s = [ ] <NEWLINE> count = 0 <NEWLINE> last = 1 <NEWLINE> for i in input ( ) : <NEWLINE> <INDENT> if i == <STRING> : <NEWLINE> <INDENT> if last == 1 : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s . append ( count ) <NEWLINE> count = 1 <NEWLINE> <DEDENT> last = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if last == 0 : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s . append ( count ) <NEWLINE> count = 1 <NEWLINE> <DEDENT> last = 0 <NEWLINE> <DEDENT> <DEDENT> s . append ( count ) <NEWLINE> if last == <STRING> : <NEWLINE> <INDENT> s . append ( 0 ) <NEWLINE> <NL> <DEDENT> k = min ( k , len ( s ) // 2 ) <NEWLINE> ans = 0 <NEWLINE> <NL> for j in range ( len ( s ) // 2 - k + 1 ) : <NEWLINE> <INDENT> if j == 0 : <NEWLINE> <INDENT> now = sum ( s [ : k * 2 + 1 ] ) <NEWLINE> ans = now <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> now = now - s [ j * 2 - 1 ] - s [ j * 2 - 2 ] + s [ ( j + k ) * 2 ] + s [ ( j + k ) * 2 - 1 ] <NEWLINE> ans = max ( ans , now ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> s = input ( ) <NEWLINE> l = [ 0 ] <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> if s [ i ] != s [ i + 1 ] : <NEWLINE> <INDENT> l . append ( i + 1 ) <NEWLINE> <DEDENT> <DEDENT> l += [ n ] <NEWLINE> le = len ( l ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( le - 1 ) : <NEWLINE> <INDENT> if s [ l [ i ] ] == <STRING> : <NEWLINE> <INDENT> ans = max ( ans , l [ min ( le , k * 2 + i ) ] - l [ i ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = max ( ans , l [ min ( le , k * 2 + i + 1 ) ] - l [ i ] ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
a , b , c , d , e = [ int ( input ( ) ) for _ in range ( 4 ) ] <NEWLINE> k = int ( input ( ) ) <NEWLINE> <NL> if abs ( a - b ) > k or abs ( a - c ) > k or abs ( a - d ) > k or abs ( a - e ) > k or abs ( b - c ) > k or abs ( b - d ) > k or abs ( e - b ) > k or abs ( c - d ) > k or abs ( c - e ) > k or abs ( d - e ) > k : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> read = sys . stdin . read <NEWLINE> readline = sys . stdin . readline <NEWLINE> readlines = sys . stdin . readlines <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> INF = 1 << 60 <NEWLINE> MOD = 1000000007 <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> A , B , C , D , E = map ( int , readline ( ) . split ( ) ) <NEWLINE> <NL> if E - A > K : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> return <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> a = int ( input ( ) ) <NEWLINE> b = int ( input ( ) ) <NEWLINE> c = int ( input ( ) ) <NEWLINE> d = int ( input ( ) ) <NEWLINE> e = int ( input ( ) ) <NEWLINE> k = int ( input ( ) ) <NEWLINE> if e - a <= k <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
l = [ int ( input ( ) ) for i in range ( 4 ) ] <NEWLINE> <NL> for i in range ( 4 ) : <NEWLINE> <INDENT> for j in range ( 4 ) : <NEWLINE> <INDENT> if l [ i ] * l [ j ] > l [ 4 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
a , b , c , d , e = map ( int , input ( ) . split ( ) ) <NEWLINE> k = int ( input ( ) ) <NEWLINE> print ( <STRING> if e - a <= k else <STRING> ) <NEWLINE>
a = [ ] <NEWLINE> for i in range ( 5 ) : <NEWLINE> <INDENT> a . append ( int ( input ( ) ) ) <NEWLINE> <DEDENT> a . sort ( ) <NEWLINE> j = int ( input ) <NEWLINE> k = a [ 4 ] - a [ 0 ] <NEWLINE> if k <= j : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a [ 0 ] = int ( input ( ) ) <NEWLINE> a [ 1 ] = int ( input ( ) ) <NEWLINE> a [ 2 ] = int ( input ( ) ) <NEWLINE> a [ 3 ] = int ( input ( ) ) <NEWLINE> a [ 4 ] = int ( input ( ) ) <NEWLINE> k = int ( input ( ) ) <NEWLINE> for i in range ( 5 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , 5 ) : <NEWLINE> <INDENT> if a [ j ] - a [ i ] > k : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
a = int ( input ( ) ) <NEWLINE> b = int ( input ( ) ) <NEWLINE> c = int ( input ( ) ) <NEWLINE> d = int ( input ( ) ) <NEWLINE> e = int ( input ( ) ) <NEWLINE> k = int ( input ( ) ) <NEWLINE> <NL> l = [ ] <NEWLINE> l . append ( a ) <NEWLINE> l . append ( b ) <NEWLINE> l . append ( c ) <NEWLINE> l . append ( d ) <NEWLINE> l . append ( e ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 5 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , 5 ) : <NEWLINE> <INDENT> if l [ j ] - l [ i ] > k : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if ans = 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
antena = [ ] <NEWLINE> for i in range ( 5 ) : <NEWLINE> <INDENT> antena [ i ] = int ( input ( ) ) <NEWLINE> <NL> <DEDENT> k = int ( input ( ) ) <NEWLINE> <NL> for i in range ( len ( antena ) ) : <NEWLINE> <INDENT> if antena [ - 1 ] - antena [ i ] > k : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
for i in range ( 5 ) : <NEWLINE> <INDENT> I = list ( map ( int , input ( ) ) ) <NEWLINE> <DEDENT> k = int ( input ( ) ) <NEWLINE> if I [ 4 ] - I [ 0 ] <= k : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
for i in range ( 6 ) : <NEWLINE> <INDENT> A [ i ] = int ( input ( ) ) <NEWLINE> <NL> <DEDENT> isOK = True <NEWLINE> for i in range ( 5 ) : <NEWLINE> <INDENT> for j in range ( 5 ) : <NEWLINE> <INDENT> if ( abs ( A [ i ] - A [ j ] ) > A [ 6 ] ) : <NEWLINE> <INDENT> isOK = False <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if ( isOK ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b , c , d , e , k = map ( int , input ( ) . split ( ) ) <NEWLINE> if e - a > k : print ( <STRING> ) <NEWLINE> else : print ( <STRING> ) <NEWLINE>
s = [ ] <NEWLINE> for i in range ( 5 ) : <NEWLINE> <INDENT> s . apppend ( int ( input ( ) ) <NEWLINE> <DEDENT> k = int ( input ( ) ) <NEWLINE> for i in range ( 4 ) : <NEWLINE> <INDENT> if s [ i + 1 ] - s [ i ] > k : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a = int ( input ( ) <NEWLINE> b = int ( input ( ) <NEWLINE> c = int ( input ( ) <NEWLINE> d = int ( input ( ) <NEWLINE> e = int ( input ( ) <NEWLINE> x = int ( input ( ) <NEWLINE> ls = [ a , b , c , d , e ] <NEWLINE> ls . sort ( ) <NEWLINE> if ( ls [ 1 ] - ls [ 0 ] ) <= x and ( ls [ 2 ] - ls [ 1 ] ) <= x and ( ls [ 3 ] - ls [ 2 ] ) <= x and ( ls [ 4 ] - ls [ 3 ] ) <= x : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a = [ ] <NEWLINE> b = [ ] <NEWLINE> ori = [ ] <NEWLINE> ans = 0 <NEWLINE> for i in range ( 5 ) : <NEWLINE> <INDENT> c = int ( input ( ) ) <NEWLINE> ori . append ( c ) <NEWLINE> a . append ( ( c // 10 + 1 ) * 10 ) <NEWLINE> <NL> if c % 10 == 0 : <NEWLINE> <INDENT> b . append ( 100 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> b . append ( c % 10 ) <NEWLINE> <DEDENT> <DEDENT> a . pop ( b . index ( min ( b ) ) ) <NEWLINE> print ( ori [ b . index ( min ( b ) ) ] + a . sum ( ) ) <NEWLINE>
import sys <NEWLINE> import math <NEWLINE> import itertools <NEWLINE> import collections <NEWLINE> import heapq <NEWLINE> import re <NEWLINE> import numpy as np <NEWLINE> <NL> rr = lambda : sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> rs = lambda : sys . stdin . readline ( ) . split ( ) <NEWLINE> ri = lambda : int ( sys . stdin . readline ( ) ) <NEWLINE> rm = lambda : map ( int , sys . stdin . readline ( ) . split ( ) ) <NEWLINE> rl = lambda : list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) <NEWLINE> inf = float ( <STRING> ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> li = [ ri ( ) for _ in range ( 5 ) ] <NEWLINE> lis = [ math . ceil ( i / 10 ) * 10 for i in li ] <NEWLINE> ans = inf <NEWLINE> for i in range ( 5 ) : <NEWLINE> <INDENT> ans = min ( sum ( lis [ : i ] ) + li [ i ] + sum ( lis [ i + 1 : ] ) ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL>
import numpuy as np <NEWLINE> dishes = [ int ( input ( ) ) for _ in range ( 5 ) ] <NEWLINE> dishes = sorted ( dishes , key = lambda x : x % 10 ) <NEWLINE> minutes = 0 <NEWLINE> first = True <NEWLINE> for i in dishes : <NEWLINE> <INDENT> if i % 10 == 0 : <NEWLINE> <INDENT> minutes += i <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if first : <NEWLINE> <INDENT> minutes += i <NEWLINE> first = False <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> minutes += int ( np . ceil ( i / 10 ) * 10 ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( minutes ) <NEWLINE>
nums = [ int ( input ( ) ) for _ in range ( 5 ) ] <NEWLINE> mn = float ( <STRING> ) <NEWLINE> <NL> for i in nums : <NEWLINE> <INDENT> if i % 10 != 0 : <NEWLINE> <INDENT> mn = min ( mn , i % 10 ) <NEWLINE> <DEDENT> <DEDENT> if mn == float ( <STRING> ) : <NEWLINE> <INDENT> mn = 0 <NEWLINE> <NL> <DEDENT> print ( sum ( list ( map ( lambda x : int ( math . ceil ( x / 10 ) * 10 ) , nums ) ) ) - 10 + mn ) <NEWLINE>
dish = [ int ( input ( ) ) for _ in range ( 5 ) ] <NEWLINE> count = { str ( i % 10 ) : [ ] for i in range ( 10 , - 1 , - 1 ) } <NEWLINE> for t in dish : <NEWLINE> <INDENT> one = t % 10 <NEWLINE> count [ str ( one ) ] . append ( t ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> d = 0 <NEWLINE> for k , v in count . items ( ) : <NEWLINE> <INDENT> if v != [ ] : <NEWLINE> <INDENT> for c in v : <NEWLINE> <INDENT> if d > 3 : <NEWLINE> <INDENT> ans += c <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += math . ceil ( c / 10 ) * 10 <NEWLINE> d += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( int ( ans ) ) <NEWLINE>
import sys <NEWLINE> input = sys . stdin . read <NEWLINE> * x , = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> tmp = 100 <NEWLINE> for i in range ( 5 ) : <NEWLINE> <INDENT> if x [ i ] % 10 : <NEWLINE> <INDENT> tmp = min ( tmp , x [ i ] % 10 ) <NEWLINE> x [ i ] //= 10 <NEWLINE> x [ i ] *= 10 <NEWLINE> x [ i ] += 10 <NEWLINE> <DEDENT> <DEDENT> ans = sum ( x ) <NEWLINE> if tmp < 100 : <NEWLINE> <INDENT> ans -= 10 <NEWLINE> ans += tmp <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL>
a = [ ] <NEWLINE> for i in range ( 5 ) : <NEWLINE> <INDENT> a . append ( int ( input ( ) ) ) <NEWLINE> <NL> <DEDENT> zako = 9 <NEWLINE> switch = 0 <NEWLINE> for i in range ( 5 ) : <NEWLINE> <INDENT> b = a [ i ] % 10 <NEWLINE> if b <= zako and b != 0 : <NEWLINE> <INDENT> zako = b <NEWLINE> memory = i <NEWLINE> switch = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if switch = 0 : <NEWLINE> <INDENT> memory = 1 <NEWLINE> <DEDENT> x = a . pop ( memory ) <NEWLINE> <NL> lst = [ ] <NEWLINE> <NL> for i in range ( 4 ) : <NEWLINE> <INDENT> c = a [ i ] // 10 <NEWLINE> c = c * 10 <NEWLINE> if a [ i ] % 10 != 0 : <NEWLINE> <INDENT> c += 10 <NEWLINE> <DEDENT> lst . append ( c ) <NEWLINE> <NL> <DEDENT> print ( x + sum ( lst ) ) <NEWLINE>
sum = 0 <NEWLINE> r = [ ] <NEWLINE> for i in range ( 5 ) : <NEWLINE> <INDENT> if a [ i ] % 10 == 0 : <NEWLINE> <INDENT> sum += a [ i ] <NEWLINE> <DEDENT> elif a [ i ] % 10 != 0 : <NEWLINE> <INDENT> sum += ( 10 * math . ceil ( a [ i ] / 10 ) ) <NEWLINE> r . append ( int ( a [ i ] % 10 ) ) <NEWLINE> <DEDENT> <DEDENT> print ( sum - 10 + min ( r ) ) <NEWLINE>
l = [ ] <NEWLINE> for i in range ( 5 ) : <NEWLINE> <INDENT> l . append ( int ( input ( ) ) ) <NEWLINE> <DEDENT> amari = [ ] <NEWLINE> for i in range ( 5 ) : <NEWLINE> <INDENT> amari . append ( 10 - l [ i ] % 10 ) <NEWLINE> <DEDENT> jikan = [ ] <NEWLINE> for i in range ( 5 ) : <NEWLINE> <INDENT> jikan . append ( l [ i ] + amari [ i ] ) <NEWLINE> <DEDENT> print ( sum [ jikan ] - max ( amari ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> Cap = [ int ( input ( ) ) for X in range ( 0 , 5 ) ] <NEWLINE> print ( int ( math . ceil ( N / min ( Cap ) ) + 4 ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = int ( input ( ) ) <NEWLINE> B = int ( input ( ) ) <NEWLINE> C = int ( input ( ) ) <NEWLINE> D = int ( input ( ) ) <NEWLINE> E = int ( input ( ) ) <NEWLINE> X = min ( A , B , C , D , E ) <NEWLINE> if X >= N : <NEWLINE> <INDENT> print ( 5 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if N % X == 0 : <NEWLINE> <INDENT> print ( 4 + N // X ) <NEWLINE> <DEDENT> elese : <NEWLINE> <INDENT> print ( 5 + N // X ) <NEWLINE> <DEDENT> <DEDENT>
import math <NEWLINE> n = int ( input ( ) ) <NEWLINE> l = [ int ( input ) for i in range ( 5 ) ] <NEWLINE> print ( math . ceil ( n / min ( l ) ) + 4 ) <NEWLINE>
import math <NEWLINE> n = int ( input ( ) ) <NEWLINE> l = [ int ( input ( ) ) for i in range ( 5 ) ] <NEWLINE> print ( mat . ceil ( n / min ( l ) ) + 4 ) <NEWLINE>
n = int ( input ( ) . split ( ) ) <NEWLINE> x = [ int ( input ( ) ) for i in range ( 5 ) ] <NEWLINE> d = n // min ( x ) <NEWLINE> print ( d + 5 ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> data = [ int ( input ( ) ) for i in range ( 5 ) ] <NEWLINE> quo , rem = divmod ( n , min ( data ) ) <NEWLINE> print ( 4 + quo + bool ( rem ) ) <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE>
import math <NEWLINE> n = int ( input ( ) ) <NEWLINE> l = [ input ( ) for i in range ( 5 ) ] <NEWLINE> print ( math . ceil ( n / min ( l ) ) + 4 ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> transport = [ int ( input ( ) ) for _ in range ( 5 ) ] <NEWLINE> print ( int ( N / np . min ( transport ) + 5 ) ) <NEWLINE>
from itertools import product <NEWLINE> from heapq import * <NEWLINE> <NL> X , Y , Z , K , * f = map ( int , open ( 0 ) . read ( ) . split ( ) ) <NEWLINE> A = f [ : X ] <NEWLINE> B = f [ X : X + Y ] <NEWLINE> C = f [ X + Y : ] <NEWLINE> A . sort ( reverse = True ) <NEWLINE> B . sort ( reverse = True ) <NEWLINE> C . sort ( reverse = True ) <NEWLINE> AB = [ sum ( x ) * ( - 1 ) for x in product ( A , B ) ] <NEWLINE> heapify ( AB ) <NEWLINE> AB_picked = [ ] <NEWLINE> for i in range ( K ) : <NEWLINE> <INDENT> AB_picked . append ( heappop ( AB ) * ( - 1 ) ) <NEWLINE> <DEDENT> ABC = [ sum ( x ) * ( - 1 ) for x in product ( AB_picked , C ) ] <NEWLINE> heapify ( ABC ) <NEWLINE> for i in range ( K ) : <NEWLINE> <INDENT> print ( heappop ( ABC ) * ( - 1 ) ) <NEWLINE> <DEDENT>
A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> C = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A . sort ( reverse = True ) <NEWLINE> B . sort ( reverse = True ) <NEWLINE> C . sort ( reverse = True ) <NEWLINE> abc = [ ( - ( A [ 0 ] + B [ 0 ] + C [ 0 ] ) , 0 , 0 , 0 ) ] <NEWLINE> used = set ( ( 0 , 0 , 0 ) ) <NEWLINE> while K > 0 : <NEWLINE> <INDENT> K -= 1 <NEWLINE> p , i , j , k = hq . heappop ( abc ) <NEWLINE> print ( - p ) <NEWLINE> for a , b , c in [ ( i + 1 , j , k ) , ( i , j + 1 , k ) , ( i , j , k + 1 ) ] : <NEWLINE> <INDENT> if a < x and b < y and c < z and ( a , b , c ) not in used : <NEWLINE> <INDENT> used . add ( ( a , b , c ) ) <NEWLINE> hq . heappush ( abc , ( - ( A [ a ] + B [ b ] + C [ c ] ) , a , b , c ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
X , Y , Z , K = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> B = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> C = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> l = [ ] <NEWLINE> for a in A : <NEWLINE> <INDENT> for b in B : <NEWLINE> <INDENT> l . append ( a + b ) <NEWLINE> <DEDENT> <DEDENT> l = sorted ( l , reverse = True ) [ : K ] <NEWLINE> <NL> ans = [ ] <NEWLINE> for c in C : <NEWLINE> <INDENT> for k in l : <NEWLINE> <INDENT> ans . append ( c + k ) <NEWLINE> <NL> <DEDENT> <DEDENT> ans = sorted ( ans , reverse = True ) <NEWLINE> print ( * ans [ : K ] , seq = <STRING> ) <NEWLINE>
a , b , c = map ( int , nput ( ) . split ( ) ) <NEWLINE> print ( <STRING> if a == b == c else <STRING> ) <NEWLINE>
a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> if a == b & & b == c : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> sort ( A ) <NEWLINE> if A [ 0 ] + A [ 1 ] > A [ 2 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
inp = input ( ) . split ( <STRING> ) <NEWLINE> <NL> print ( inp [ 0 ] == inp [ 1 ] and inp [ 0 ] == inp [ 2 ] and 1 <= inp [ 0 ] <= 100 ) <NEWLINE>
a , b , c = int ( input ( ) ) <NEWLINE> <NL> if a == b and b == c and c == a : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
if a [ 0 ] == a [ 1 ] and a [ 1 ] == a [ 2 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> print ( <STRING> if S . count ( B ) > S . count ( R ) else <STRING> ) <NEWLINE>
a = input ( ) <NEWLINE> if a = A : <NEWLINE> <INDENT> print ( T ) <NEWLINE> <DEDENT> elif a = T : <NEWLINE> <INDENT> print ( A ) <NEWLINE> <DEDENT> elif a = G : <NEWLINE> <INDENT> print ( C ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( G ) <NEWLINE> <DEDENT>
d = { <STRING> : <STRING> , <STRING> : <STRING> , <STRING> : <STRING> , <STRING> , <STRING> } <NEWLINE> print ( d [ input ( ) ] ) <NEWLINE>
b = input ( ) <NEWLINE> <NL> if b == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif b == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif b == ( <STRING> ) <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
b = input ( ) <NEWLINE> if b = A : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif b = T : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif b = C : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
b = input ( ) <NEWLINE> if b = <STRING> : <NEWLINE> <INDENT> b = <STRING> <NEWLINE> <DEDENT> elif b = <STRING> : <NEWLINE> <INDENT> b = <STRING> <NEWLINE> <DEDENT> elif b = <STRING> : <NEWLINE> <INDENT> b = <STRING> <NEWLINE> <DEDENT> elif b = <STRING> : <NEWLINE> <INDENT> b = <STRING> <NEWLINE> <DEDENT> print ( b ) <NEWLINE>
1 b = input ( ) <NEWLINE> 2 c = { <STRING> : <STRING> , <STRING> : <STRING> , <STRING> : <STRING> , <STRING> : <STRING> } <NEWLINE> 3 print ( c [ b ] ) <NEWLINE>
b = input ( ) <NEWLINE> print ( <STRING> if b == T else <STRING> if b == A else <STRING> if b == C else <STRING> ) <NEWLINE>
b = input ( ) <NEWLINE> <NL> if b == A : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif b == T : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif b == G : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
b = str ( input ( ) ) <NEWLINE> <NL> if b == A : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> if b == T : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> if b == C : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> if b == G : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a = input ( ) <NEWLINE> print ( <STRING> if a = <STRING> else <STRING> if a = <STRING> else <STRING> if a = <STRING> else <STRING> ) <NEWLINE>
b = list ( input ( ) ) <NEWLINE> <NL> for i in len ( b ) : <NEWLINE> <INDENT> if b [ i ] == <STRING> : <NEWLINE> <INDENT> b [ i ] = <STRING> <NEWLINE> <DEDENT> elif b [ i ] == <STRING> : <NEWLINE> <INDENT> b [ i ] = <STRING> <NEWLINE> <DEDENT> elif b [ i ] == <STRING> : <NEWLINE> <INDENT> b [ i ] = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> b [ i ] = <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> print ( b ) <NEWLINE>
if b == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif b == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif b == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif b == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
X = int ( input ( ) ) <NEWLINE> if X == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif X == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif X == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif X == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> b = input ( ) <NEWLINE> <NL> if b == ( <STRING> ) : <NEWLINE> <INDENT> print ( T ) <NEWLINE> <NL> <DEDENT> if b == ( <STRING> ) : <NEWLINE> <INDENT> print ( G ) <NEWLINE> <NL> <DEDENT> if b == ( <STRING> ) : <NEWLINE> <INDENT> print ( A ) <NEWLINE> <NL> <DEDENT> if b == ( <STRING> ) : <NEWLINE> <INDENT> print ( C ) <NEWLINE> <DEDENT>
s = int ( input ( ) ) <NEWLINE> <NL> if s == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif s == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif s == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif s == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> <NL> if n == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif n == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif n == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
x = input ( ) <NEWLINE> if x = <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> if x = <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> if x = <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
b = int ( input ( ) ) <NEWLINE> print ( <STRING> if b == <STRING> else <STRING> if b == <STRING> else <STRING> if b == <STRING> else <STRING> ) <NEWLINE>
count = 0 <NEWLINE> tmp = 0 <NEWLINE> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> or s [ i ] == <STRING> or s [ i ] == <STRING> or s [ i ] == <STRING> : <NEWLINE> <INDENT> tmp += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> tmp = 0 <NEWLINE> <DEDENT> count = max ( tmp , count ) <NEWLINE> <DEDENT> print ( count ) <NEWLINE>
s = input ( ) <NEWLINE> temp = 0 <NEWLINE> ans = 0 <NEWLINE> tar = <STRING> <NEWLINE> for ch in s : <NEWLINE> <INDENT> if ch in tar : <NEWLINE> <INDENT> temp += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if ans = < temp : <NEWLINE> <INDENT> ans = temp <NEWLINE> <DEDENT> temp = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL>
import sys <NEWLINE> import re <NEWLINE> S = input ( ) <NEWLINE> if not ( 1 <= len ( S ) <= 10 ) : sys . exit ( ) <NEWLINE> if not S . isupper : sys . exit ( ) <NEWLINE> <NL> max = max ( re . findall ( <STRING> , S ) ) if re . findall ( <STRING> , S ) else 0 <NEWLINE> if max > 0 : max <NEWLINE> print ( max ) <NEWLINE>
l = ( <STRING> , <STRING> , <STRING> , <STRING> ) <NEWLINE> S = input ( ) <NEWLINE> <NL> ans = [ 0 ] <NEWLINE> for i in range ( len ( S ) ) : <NEWLINE> <INDENT> if S [ i ] in l : <NEWLINE> <INDENT> res += 1 <NEWLINE> <DEDENT> elif res != 0 : <NEWLINE> <INDENT> ans . append ( res ) <NEWLINE> res = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( max ( ans ) ) <NEWLINE>
n = input ( ) <NEWLINE> ans , temp = 0 , 0 <NEWLINE> for x in S : <NEWLINE> <INDENT> if x in <STRING> : <NEWLINE> <INDENT> temp += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> temp = 0 <NEWLINE> <DEDENT> ans = max ( ans , temp ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
s = input ( ) <NEWLINE> count = 0 <NEWLINE> lens = [ ] <NEWLINE> <NL> for i , _ in enumerate ( s ) : <NEWLINE> <INDENT> for c in s [ i : ] : <NEWLINE> <INDENT> if c in [ <STRING> , <STRING> , <STRING> , <STRING> ] : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> lens . append ( count ) <NEWLINE> count = 0 <NEWLINE> <NL> <DEDENT> print ( max ( lens ) ) <NEWLINE>
S = input ( ) <NEWLINE> max = 0 <NEWLINE> count = 0 <NEWLINE> for x in S : <NEWLINE> <INDENT> if x in <STRING> : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> max = max ( max , count ) <NEWLINE> count = 0 <NEWLINE> <DEDENT> <DEDENT> max = max ( max , count ) <NEWLINE> print ( max ) <NEWLINE>
n = input ( ) <NEWLINE> count = 0 <NEWLINE> m = 0 <NEWLINE> for i in n : <NEWLINE> <INDENT> if s == <STRING> or s == <STRING> or s == <STRING> or s == <STRING> : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> m = max ( m , count ) <NEWLINE> count = 0 <NEWLINE> <DEDENT> <DEDENT> print ( m ) <NEWLINE>
ACGT = [ <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> S = input ( ) <NEWLINE> cnt = 0 <NEWLINE> max_cnt = 0 <NEWLINE> for s in S : <NEWLINE> <INDENT> if s in ACGT : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> cntList . append ( cnt ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> max_cnt = max ( cnt , max_cnt ) <NEWLINE> cnt = 0 <NEWLINE> <DEDENT> <DEDENT> print ( max_cnt ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> l . sort ( reverse = True ) <NEWLINE> <NL> if l [ 0 ] < sum ( l [ 1 : n ] ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
cnt , ans = 0 , [ ] <NEWLINE> agct = [ <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> if s [ i ] in agct : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans . append ( cnt ) <NEWLINE> cnt = 0 <NEWLINE> <DEDENT> <DEDENT> if ans == [ ] : <NEWLINE> <INDENT> ans . append ( 0 ) <NEWLINE> <DEDENT> print ( max ( ans ) ) <NEWLINE>
S = input ( ) <NEWLINE> s = { <STRING> , <STRING> , <STRING> , <STRING> } <NEWLINE> ans = 0 <NEWLINE> for i in S : <NEWLINE> <INDENT> if i in s : <NEWLINE> <INDENT> tmp += 1 <NEWLINE> ans = max ( ans , tmp ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> tmp = 0 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
s = str ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> cnt = 0 <NEWLINE> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> or <STRING> or <STRING> or <STRING> : <NEWLINE> <INDENT> cnt + + <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = max ( ans , cnt ) <NEWLINE> cnt = 0 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
s = str ( input ( ) ) <NEWLINE> mx = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n + 1 ) : <NEWLINE> <INDENT> cnt = j - i - 1 <NEWLINE> p = 0 <NEWLINE> for k in list ( s [ i : j ] ) : <NEWLINE> <INDENT> if k in [ <STRING> , <STRING> , <STRING> , <STRING> ] : <NEWLINE> <INDENT> p += 1 <NEWLINE> <DEDENT> <DEDENT> if p == cnt : <NEWLINE> <INDENT> if p > mx : <NEWLINE> <INDENT> mx = p <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( mx ) <NEWLINE>
S = input ( ) <NEWLINE> <NL> l = len ( S ) <NEWLINE> <NL> ans = 0 <NEWLINE> ans_list = ( ) <NEWLINE> <NL> for i in range ( l ) : <NEWLINE> <INDENT> if S [ i ] in ( <STRING> , <STRING> , <STRING> , <STRING> ) : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans_list . append ( ans ) <NEWLINE> ans = 0 <NEWLINE> <DEDENT> <DEDENT> ans_list . append ( ans ) <NEWLINE> print ( ans ) <NEWLINE>
S = input ( ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( len ( S ) ) : <NEWLINE> <INDENT> for j in range ( i + 1 , len ( S ) + 1 ) : <NEWLINE> if all ( <STRING> . count ( c ) == 1 for c in S [ i : j + 1 ] ) : <NEWLINE> <INDENT> ans = max ( ans , j + 1 - i ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> moji = str ( input ( ) ) <NEWLINE> ans = [ 0 ] <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> if moji [ i ] == <STRING> and moji [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> ans . append ( ans [ i ] + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans . append ( ans [ i ] ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> for i in range ( K ) : <NEWLINE> <INDENT> st , sp = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( ans [ sp ] - ans [ st ] ) <NEWLINE> <DEDENT>
n , q = map ( int , input ( ) . split ( ) ) <NEWLINE> s = input ( ) <NEWLINE> list = [ 0 ] <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> and s [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> list . append ( list [ i ] + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> list . append ( list [ i ] ) <NEWLINE> <DEDENT> <DEDENT> for j in range ( q ) : <NEWLINE> <INDENT> l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( list [ r ] - list [ l - 1 ] ) <NEWLINE> <DEDENT>
N , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> S = str ( input ( ) ) <NEWLINE> li = [ ] <NEWLINE> cnt = 0 <NEWLINE> <NL> for i in range ( N - 1 ) : <NEWLINE> <INDENT> if S [ i ] == <STRING> and S [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> li . append ( cnt ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> li . append ( cnt ) <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( Q ) : <NEWLINE> <INDENT> l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = li [ r - 1 ] - li [ : l - 1 ] <NEWLINE> print ( ans ) <NEWLINE> <DEDENT>
N , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> S = input ( ) <NEWLINE> count = 0 <NEWLINE> ac = [ 0 ] <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> if S [ i ] == <STRING> and S [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> ac . append ( count ) <NEWLINE> <DEDENT> for _ in range ( Q ) : <NEWLINE> <INDENT> l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> l -= 1 , r -= 1 <NEWLINE> print ( ac [ r ] - ac [ l ] ) <NEWLINE> <DEDENT>
<INDENT> def ss ( ) : <NEWLINE> <INDENT> N , Q = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> s = input ( ) <NEWLINE> lis = [ 0 ] * N <NEWLINE> <NL> count = 0 <NEWLINE> for i in range ( 1 , len ( s ) ) : <NEWLINE> <INDENT> if s [ i - 1 ] == <STRING> and s [ i ] == <STRING> : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> lis [ i ] += count <NEWLINE> <DEDENT> for i in range ( Q ) : <NEWLINE> <INDENT> l , r = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> print ( lis [ r - 1 ] - lis [ l - 1 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> ss ( ) <NEWLINE>
import copy <NEWLINE> <NL> N , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> S = input ( ) <NEWLINE> t = [ 0 ] * N <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> t [ i + 1 ] = t [ i ] + ( 1 if S [ i : i + 2 ] == <STRING> else 0 ) <NEWLINE> <NL> <DEDENT> for i in range ( Q ) : <NEWLINE> <INDENT> l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( t [ r - 1 ] - t [ l - 1 ] ) <NEWLINE> <NL> <NL> <DEDENT>
N , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> S = input ( ) <NEWLINE> t = [ 0 ] * ( N + 1 ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> t [ i + 1 ] = t [ i ] + ( 1 if S [ i : i + 2 ] == <STRING> else 0 ) <NEWLINE> for i in range ( Q ) : <NEWLINE> <INDENT> l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( t [ r - 1 ] - t [ l - 1 ] ) <NEWLINE> <DEDENT> <DEDENT>
N , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> S = [ <STRING> ] + list ( input ( ) ) <NEWLINE> C = [ 0 ] * len ( S ) <NEWLINE> c = 0 <NEWLINE> for i in range ( 1 , len ( S ) ) : <NEWLINE> <INDENT> if S [ i - 1 ] == <STRING> and S [ i ] == <STRING> : <NEWLINE> <INDENT> c += 1 <NEWLINE> <DEDENT> C [ i ] = c <NEWLINE> <DEDENT> for _ in range ( N ) : <NEWLINE> <INDENT> l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( C [ r ] - C [ l ] ) <NEWLINE> <DEDENT>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> N , Q = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> s = input ( ) <NEWLINE> lis = [ 0 ] * N <NEWLINE> <NL> count = 0 <NEWLINE> for i in range ( 1 , len ( s ) ) : <NEWLINE> <INDENT> if s [ i - 1 ] == <STRING> and s [ i ] == <STRING> : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> lis [ i ] += count <NEWLINE> <DEDENT> for i in range ( Q ) : <NEWLINE> <INDENT> l , r = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> print ( lis [ r - 1 ] - lis [ l - 1 ] ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> from decorator import stop_watch <NEWLINE> <NL> <NL> @ stop_watch <NEWLINE> def solve ( N ) : <NEWLINE> <INDENT> mod = 10 ** 9 + 7 <NEWLINE> dp = [ { } for _ in range ( N + 1 ) ] <NEWLINE> dp [ 0 ] . setdefault ( <STRING> , 1 ) <NEWLINE> <NL> def check ( last4 ) : <NEWLINE> <INDENT> for i in range ( 4 ) : <NEWLINE> <INDENT> x = list ( last4 ) <NEWLINE> if i > 0 : <NEWLINE> <INDENT> x [ i ] , x [ i - 1 ] = x [ i - 1 ] , x [ i ] <NEWLINE> <DEDENT> if <STRING> . join ( x ) . count ( <STRING> ) >= 1 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> <DEDENT> return True <NEWLINE> <NL> <DEDENT> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> for last3 , count in dp [ i - 1 ] . items ( ) : <NEWLINE> <INDENT> for c in <STRING> : <NEWLINE> <INDENT> if check ( last3 + c ) : <NEWLINE> <INDENT> new_last3 = last3 [ 1 : ] + c <NEWLINE> dp [ i ] . setdefault ( last3 [ 1 : ] + c , 0 ) <NEWLINE> dp [ i ] [ new_last3 ] = ( dp [ i ] [ new_last3 ] + count ) % mod <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( sum ( dp [ - 1 ] . values ( ) ) % mod ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> solve ( N ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT>
def ok ( last4 ) : <NEWLINE> <INDENT> for i in range ( 4 ) : <NEWLINE> <INDENT> t = list ( last4 ) <NEWLINE> if i >= 1 : <NEWLINE> <INDENT> t [ i - 1 ] , t [ i ] = t [ i ] , t [ i - 1 ] <NEWLINE> <DEDENT> if <STRING> . join ( t ) . count ( <STRING> ) >= 1 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> <DEDENT> return True <NEWLINE> <DEDENT> def dfs ( cur , last3 ) : <NEWLINE> <INDENT> if last3 in memo [ cur ] : <NEWLINE> <INDENT> return memo [ cur ] [ last3 ] <NEWLINE> <DEDENT> if cur == N : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> ret = 0 <NEWLINE> for c in <STRING> : <NEWLINE> <INDENT> if ok ( last3 + c ) : <NEWLINE> <INDENT> ret = ( ret + dfs ( cur + 1 , last3 [ 1 : ] + c ) ) % MOD <NEWLINE> <DEDENT> <DEDENT> memo [ cur ] [ last3 ] = ret <NEWLINE> return ret <NEWLINE> <DEDENT> print ( dfs ( 0 , <STRING> ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> b = list ( map ( int , inputs ( ) . split ( ) ) ) <NEWLINE> ans = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> for j in range ( len ( b ) ) : <NEWLINE> <INDENT> if b [ j ] == j + 1 : <NEWLINE> <INDENT> ans . append ( b . pop ( j ) ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> for i in range ( N - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> print ( ans [ i ] ) <NEWLINE> <DEDENT>
from string import ascii_lowercase <NEWLINE> from functools import reduce <NEWLINE> from operator import mul <NEWLINE> n = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> print ( reduce ( lambda x , y : x * y % mod , S . count ( c ) + 1 for c in ascii_lowercase ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> s = list ( input ( ) ) <NEWLINE> from collections import Counter <NEWLINE> d = Counter ( s ) <NEWLINE> ans = 1 <NEWLINE> for v in d . values ( ) : <NEWLINE> <INDENT> ans *= ( v + 1 <NEWLINE> <DEDENT> ans -= 1 <NEWLINE> ans = ans % ( 10 ** 9 + 7 ) <NEWLINE> print ( ans ) <NEWLINE>
a = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( 2 ) ] <NEWLINE> a [ 0 ] [ 0 ] = H <NEWLINE> a [ 0 ] [ 1 ] = W <NEWLINE> a [ 1 ] [ 0 ] = h <NEWLINE> a [ 1 ] [ 1 ] = w <NEWLINE> my_result = H * W - h * W - H * w + h * w <NEWLINE> print ( my_result ) <NEWLINE>
H1 , W1 = map ( int , input ( ) . split ( ) ) <NEWLINE> H2 , W2 = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> H = H1 - H2 <NEWLINE> W = W1 - W2 <NEWLINE> <NL> print ( HW ) <NEWLINE>
H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <INDENT> print ( max ( H * W - h * W - ( H - h ) * w , 0 ) ) <NEWLINE> <DEDENT>
H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> h , w = = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( ( H - h ) * ( W - w ) ) <NEWLINE>
3 2 <NEWLINE> 2 1 <NEWLINE>
H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> h . w = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( H * W - h * W - w * H + h * w ) <NEWLINE>
3 2 <NEWLINE> 2 1 <NEWLINE>
HW = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( 2 ) ] <NEWLINE> print ( ( HW [ 0 ] [ 0 ] - HW [ 1 ] [ 0 ] ) * ( HW [ 0 ] [ 1 ] - HW [ 1 ] [ 1 ] ) <NEWLINE>
a , b = map ( input ( ) . split ( <STRING> ) ) <NEWLINE> c , d = map ( input ( ) . split ( <STRING> ) ) <NEWLINE> print ( ( a - c ) * ( b - d ) ) <NEWLINE>
H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> h , w = map ( int , input ( ) , split ( ) ) <NEWLINE> print ( ( H - h ) * ( W - w ) ) <NEWLINE>
a , b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c , d = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> x = a * b <NEWLINE> print ( x - a * c - b * ) <NEWLINE>
a , b = input ( ) . split ( ) <NEWLINE> c , d = input ( ) . split ( ) <NEWLINE> print ( ( a - c ) * ( b - d ) ) <NEWLINE>
h , w = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> _ , _ = input ( ) <NEWLINE> <NL> print ( h * w - ( h + w - 1 ) ) <NEWLINE>
HW = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> hw = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> print ( ( HW [ 0 ] - hw [ 0 ] ) ( HW [ 1 ] - hw [ 1 ] ) ) <NEWLINE>
N , M , C = map ( int , input ( ) . split ( ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> count = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> p = C <NEWLINE> for j in range ( M ) : <NEWLINE> <INDENT> P += A [ j ] * B [ j ] <NEWLINE> if p > 0 : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
N , M , H = list ( map ( int ( ) . input ( ) , split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> count = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> for k in range ( M ) : <NEWLINE> <INDENT> ans += A [ k ] * B [ k ] <NEWLINE> <DEDENT> if ans + H > : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
N , M , C = map ( int , input ( ) . split ( ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A = [ 0 ] * N <NEWLINE> count = 0 <NEWLINE> <NL> for n in range ( N ) : <NEWLINE> <INDENT> A [ n ] = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in range ( M ) : <NEWLINE> <INDENT> _sum += A [ n ] [ i ] * B [ i ] <NEWLINE> <NL> <DEDENT> if _sum + C > 0 : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
n , m , c = map ( int , input ( ) . split ( ) ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( n ) ] <NEWLINE> cnt = 0 <NEWLINE> <NL> for l in a : <NEWLINE> <INDENT> tmp = 0 <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> tmp += b [ i ] * a [ i ] <NEWLINE> <DEDENT> tmp += c <NEWLINE> if tmp > 0 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
3 3 0 <NEWLINE> 100 - 100 0 <NEWLINE> 0 100 100 <NEWLINE> 100 100 100 <NEWLINE> - 100 100 100 <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <NL> n , m , c = map ( int , input ( ) . split ( ) ) <NEWLINE> B = np . array ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> K = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> K . append ( A ) <NEWLINE> <NL> <DEDENT> import numpy as np <NEWLINE> pp = np . array ( K ) <NEWLINE> l = ( pp * B ) . sum ( axis = 1 ) + c <NEWLINE> <NL> t = 0 <NEWLINE> for i in range ( len ( l ) ) : <NEWLINE> <INDENT> if l [ i ] > 0 : <NEWLINE> <INDENT> t += 1 <NEWLINE> <DEDENT> <DEDENT> print ( t ) <NEWLINE>
N , M , C = map ( int , input ( ) . split ( ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> count = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for j in range ( M ) : <NEWLINE> P = C <NEWLINE> P += B [ j ] * a [ j ] <NEWLINE> if P > 0 : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
import numpy as np <NEWLINE> n , m , c = map ( int , input ( ) . split ( ) ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> num = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> hoge = np . dot ( b * a ) + c <NEWLINE> if hoge > 0 : <NEWLINE> <INDENT> num += 1 <NEWLINE> <DEDENT> <DEDENT> print ( num ) <NEWLINE>
N , M , C = map ( int , input ( ) . split ( ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> Ai = [ input ( ) . split ( ) for l in range ( N ) ] <NEWLINE> count = 0 <NEWLINE> tot = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> for j in range ( M ) : <NEWLINE> <INDENT> tot += Ai [ i ] [ j ] * B [ i ] <NEWLINE> if tot + C > 0 : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
<COMMENT> <NL> import numpy as np <NEWLINE> N , M , C = inpl ( ) <NEWLINE> B = np . array ( inpl ( ) , dtype = np . int64 ) <NEWLINE> ans = 0 <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> A = np . array ( inpl ( ) , dtype = np . int64 ) <NEWLINE> ans += np . sum ( A * B ) + C > 0 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> d = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> d . append ( [ a , b ] ) <NEWLINE> <NL> <DEDENT> d . sort ( key = lambda x : x [ 0 ] ) <NEWLINE> <NL> sum_ = 0 <NEWLINE> cnt = 0 <NEWLINE> for ab in d : <NEWLINE> <INDENT> if cnt + ab [ 1 ] > M : <NEWLINE> <INDENT> sum_ += ab [ 0 ] * ( M - cnt ) <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cnt += ab [ 1 ] <NEWLINE> sum_ += ab [ 0 ] * ab [ 1 ] <NEWLINE> <DEDENT> <DEDENT> print ( sum_ ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> list = [ ] <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> list . append ( [ a , b ] ) <NEWLINE> <DEDENT> list . sort ( ) <NEWLINE> ans = 0 <NEWLINE> for a , b in l : <NEWLINE> <INDENT> ans += min ( b , M ) * a <NEWLINE> M = max ( 0 , M - b ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> AB = { } <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> AB [ A ] = B <NEWLINE> <DEDENT> AB = sorted ( AB . items ( ) , key = lambda x : x [ 0 ] ) <NEWLINE> <NL> acost = 0 <NEWLINE> <NL> for a , b in AB : <NEWLINE> <INDENT> cost += ( min ( max ( M , 0 ) , b ) ) * a <NEWLINE> M -= b <NEWLINE> if M <= 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> print ( cost ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> ab = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ] <NEWLINE> ab . sort ( ) <NEWLINE> ans = 0 <NEWLINE> cnt = 0 <NEWLINE> i = 0 <NEWLINE> while cnt < m : <NEWLINE> <INDENT> ans += ab [ i ] [ 0 ] * ab [ i ] [ 1 ] <NEWLINE> cnt += ab [ i ] [ 1 ] <NEWLINE> i += 1 <NEWLINE> <DEDENT> print ( ans - ( cnt - m ) * ab [ i ] [ 0 ] ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ ] <NEWLINE> B = [ ] <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> A . append ( a ) <NEWLINE> B . append ( b ) <NEWLINE> <DEDENT> C = sorted ( A ) <NEWLINE> while M > 0 : <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> ab = sorted ( [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( n ) ] ) <NEWLINE> shop , cost , rest = m , 0 , 0 <NEWLINE> while True : <NEWLINE> <INDENT> if ab [ shop ] [ 1 ] < rest : <NEWLINE> <INDENT> cost += ab [ shop ] [ 1 ] * ab [ shop ] [ 0 ] <NEWLINE> rest -= ab [ shop ] [ 1 ] <NEWLINE> shop += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cost += ab [ shop ] [ 0 ] * rest <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( cost ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> drink = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( n ) ] <NEWLINE> <COMMENT> <NL> <NL> drink . sort ( ) <NEWLINE> <COMMENT> <NL> money = 0 <NEWLINE> number = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if number + drink [ i ] [ 0 ] = < m : <NEWLINE> <INDENT> money += drink [ i ] [ 0 ] * drink [ i ] [ 1 ] <NEWLINE> number += drink [ i ] [ 1 ] <NEWLINE> <DEDENT> elif m < number + drink [ i ] [ 0 ] : <NEWLINE> <INDENT> money += drink [ i ] [ 0 ] * ( m - number ) <NEWLINE> number += m - number <NEWLINE> break <NEWLINE> <DEDENT> if m == number : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> print ( money ) <NEWLINE>
A , B , C = map ( int , input ( ) ) <NEWLINE> if A * C <= B : <NEWLINE> <INDENT> print ( C ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( B // A ) <NEWLINE> <DEDENT>
A , B , C = map ( int , input ( ) ) <NEWLINE> print ( max ( B // A , C ) ) <NEWLINE>
<COMMENT> <NL> <NL> input_data = input ( ) . split ( ) <NEWLINE> <NL> d1 = input_data [ 0 ] <NEWLINE> d2 = input_data [ 1 ] <NEWLINE> d3 = input_data [ 2 ] <NEWLINE> total = 0 <NEWLINE> <NL> d4 = d2 % d1 <NEWLINE> if d4 > d3 : <NEWLINE> <INDENT> total += 1 <NEWLINE> <NL> <DEDENT> print ( total ) <NEWLINE>
a , b , c = map ( input ( ) . split ( ) ) <NEWLINE> if a * c > b : <NEWLINE> <INDENT> print ( b // a ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( c ) <NEWLINE> <DEDENT>
a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( min ( c , b // a ) <NEWLINE>
a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( min ( n // a , c ) ) <NEWLINE>
a , b , k = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> min = a <NEWLINE> if b < min : <NEWLINE> <INDENT> min = b <NEWLINE> <NL> <DEDENT> ans_lists = [ ] <NEWLINE> for i in range ( 1 , min + 1 , 1 ) : <NEWLINE> <INDENT> if a % i == 0 and b % i == 0 : <NEWLINE> <INDENT> ans_lists . append ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> ans_lists . reverse ( ) <NEWLINE> ans = lists [ k - 1 ] <NEWLINE> <NL> print ( ans ) <NEWLINE>
A , B , K = map ( int , input ( ) . split ( ) ) <NEWLINE> cnt = 0 <NEWLINE> <NL> for i in range ( 100 , 0 , - 1 ) : <NEWLINE> <INDENT> if A % i == 0 and B % i == 0 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> if cnt = K : <NEWLINE> <INDENT> print ( i ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
a , b , k = map ( int , input ( ) . split ( ) ) <NEWLINE> N = <STRING> <NEWLINE> for i in range ( 1 , min ( a , b ) ) : <NEWLINE> <INDENT> if a % i == 0 and b % i == 0 : <NEWLINE> <INDENT> N . append ( i ) <NEWLINE> <DEDENT> <DEDENT> N . reverse ( ) <NEWLINE> print ( N [ k - 1 ] ) <NEWLINE>
a , b , k = map ( int , input ( ) . split ( ) ) <NEWLINE> p = [ ] <NEWLINE> for i in range ( a ) : <NEWLINE> <INDENT> if a % i == 0 and b % i == 0 : <NEWLINE> <INDENT> p . append ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> n = len ( p ) <NEWLINE> print ( p [ n - k ] ) <NEWLINE>
<COMMENT> <NL> l = [ ] <NEWLINE> for i in range ( 1 , 100 ) : <NEWLINE> <INDENT> if ( a % i == 0 ) & ( b % i == 0 ) : <NEWLINE> <INDENT> l . append ( i ) <NEWLINE> <DEDENT> <DEDENT> print ( l [ k - 1 ] ) <NEWLINE>
a , b , k = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = [ ] <NEWLINE> <NL> for i in range ( 1 , min ( a , b ) + 1 ) : <NEWLINE> <INDENT> if a % i == 0 and b % i == 0 : <NEWLINE> <INDENT> ans . append ( i ) <NEWLINE> <DEDENT> <DEDENT> print ( ans [ k + 1 ] ) <NEWLINE>
abk = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> a = abk [ 0 ] <NEWLINE> b = abk [ 1 ] <NEWLINE> k = abk [ 2 ] <NEWLINE> <NL> anss = [ ] <NEWLINE> for i in range ( 1 , min ( a , b ) + 1 ) : <NEWLINE> <INDENT> if a % i == 0 and b % i == 0 : <NEWLINE> <INDENT> anss . append ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> anns . sort ( reverse = True ) <NEWLINE> print ( anss [ k - 1 ] ) <NEWLINE>
A , B , K = map ( int , input ( ) . split ( ) ) <NEWLINE> div = [ ] <NEWLINE> <NL> for i in range ( 1 , 100 ) : <NEWLINE> <INDENT> if a % i == 0 and b % i == 0 : <NEWLINE> <INDENT> div . append ( i ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( sorted ( div ) [ - K ] <NEWLINE>
A , B , K = map ( int , input ( ) . split ( ) ) <NEWLINE> l = [ ] <NEWLINE> for i in range ( 101 ) : <NEWLINE> <INDENT> if A % i == 0 and B % i == 0 : <NEWLINE> <INDENT> l . append ( i ) <NEWLINE> <DEDENT> <DEDENT> print ( l [ i - 1 ] ) <NEWLINE>
A , B , K = map ( int , input ( ) . split ( ) ) <NEWLINE> i = 0 <NEWLINE> j = 0 <NEWLINE> while i < K : <NEWLINE> <INDENT> j += 1 <NEWLINE> if A * % j == 0 and B % j == 0 : <NEWLINE> <INDENT> i += 1 <NEWLINE> <DEDENT> <DEDENT> print ( j ) <NEWLINE>
A , B , K = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( ( i for i in range ( 1 , 101 ) if A % i + B % i < 1 ) [ - K ] ) <NEWLINE>
a , b , k = map ( int , input ( ) . split ( ) ) <NEWLINE> l = [ ] <NEWLINE> <NL> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if a % i == 0 and b % i == 0 : <NEWLINE> <INDENT> l . append ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( l [ k - 1 ] ) <NEWLINE>
a , b , c = input ( ) . split ( ) <NEWLINE> a = int ( a ) <NEWLINE> b = int ( b ) <NEWLINE> c = int ( c ) <NEWLINE> count = 0 <NEWLINE> while count < c : <NEWLINE> <INDENT> for i in range ( 100 , 0 ) : <NEWLINE> <INDENT> if a % i == 0 and b % i == 0 : <NEWLINE> <INDENT> count = count + 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( i ) <NEWLINE>
A , B , K = map ( int , input ( ) . split ( ) ) <NEWLINE> check = 0 <NEWLINE> res = 0 <NEWLINE> for i in range ( 100 ) : <NEWLINE> <INDENT> if A % i == 0 and B % i == 0 : <NEWLINE> <INDENT> check += 1 <NEWLINE> if check == K : <NEWLINE> <INDENT> res = i <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( res ) <NEWLINE>
def next_check ( cubes ) : <NEWLINE> <INDENT> index_list = [ ] <NEWLINE> for cube_index in reversed ( range ( 1 , len ( cubes ) ) ) : <NEWLINE> <INDENT> if ( ( cube_index not in index_list ) and ( cubes [ cube_index ] == cubes [ cube_index - 1 ] ) ) : <NEWLINE> <INDENT> index_list . append ( cube_index - 1 ) <NEWLINE> index_list . append ( cube_index ) <NEWLINE> <DEDENT> <DEDENT> l = len ( index_list ) <NEWLINE> for i in reversed ( index_list ) : <NEWLINE> <INDENT> cubes . pop ( i ) <NEWLINE> <DEDENT> return ( cubes , l ) <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> cubes = input ( ) <NEWLINE> for c in cubes : <NEWLINE> <INDENT> if c not in [ <STRING> , <STRING> ] : <NEWLINE> <INDENT> exit ( 0 ) <NEWLINE> <DEDENT> <DEDENT> cube_list = [ ] <NEWLINE> for cube in cubes : <NEWLINE> <INDENT> cube_list . append ( cube ) <NEWLINE> <DEDENT> l = len ( cube_list ) <NEWLINE> k = 0 <NEWLINE> while ( l != 0 ) : <NEWLINE> <INDENT> cubes , l = next_check ( cube_list ) <NEWLINE> k += l <NEWLINE> <DEDENT> print ( k ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> cnt1 = 0 <NEWLINE> cnt2 = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> cnt1 += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cnt2 += 1 <NEWLINE> <DEDENT> <DEDENT> print ( min ( cnt1 , cnt2 ) * 2 ) <NEWLINE>
S = input ( ) <NEWLINE> List = list ( S ) <NEWLINE> zeroNum = List . count ( <STRING> ) <NEWLINE> oneNum = List . count ( <STRING> ) <NEWLINE> res = min ( reroNum , oneNum ) <NEWLINE> print ( res * 2 ) <NEWLINE>
import sys <NEWLINE> <NL> <NL> class UnionFind : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . table = [ - 1 ] * n <NEWLINE> <NL> <DEDENT> def _root ( self , x ) : <NEWLINE> <INDENT> stack = [ ] <NEWLINE> tbl = self . table <NEWLINE> while tbl [ x ] >= 0 : <NEWLINE> <INDENT> stack . append ( x ) <NEWLINE> x = tbl [ x ] <NEWLINE> <DEDENT> for y in stack : <NEWLINE> <INDENT> tbl [ y ] = x <NEWLINE> <DEDENT> return x <NEWLINE> <NL> <DEDENT> def find ( self , x , y ) : <NEWLINE> <INDENT> return self . _root ( x ) == self . _root ( y ) <NEWLINE> <NL> <DEDENT> def union ( self , x , y ) : <NEWLINE> <INDENT> r1 = self . _root ( x ) <NEWLINE> r2 = self . _root ( y ) <NEWLINE> if r1 == r2 : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> d1 = self . table [ r1 ] <NEWLINE> d2 = self . table [ r2 ] <NEWLINE> if d1 <= d2 : <NEWLINE> <INDENT> self . table [ r2 ] = r1 <NEWLINE> self . table [ r1 ] += d2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . table [ r1 ] = r2 <NEWLINE> self . table [ r2 ] += d1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <INDENT> n , m , k = map ( int , sys . stdin . buffer . readline ( ) . split ( ) ) <NEWLINE> uf = UnionFind ( n ) <NEWLINE> fb = [ 0 ] * n <NEWLINE> i = 0 <NEWLINE> for x in sys . stdin . buffer . readlines ( ) : <NEWLINE> <INDENT> if i < m : <NEWLINE> <INDENT> a , b = map ( int , x . split ( ) ) <NEWLINE> fb [ a - 1 ] += 1 <NEWLINE> fb [ b - 1 ] += 1 <NEWLINE> uf . union ( a - 1 , b - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> c , d = map ( int , x . split ( ) ) <NEWLINE> fb [ c - 1 ] += 1 <NEWLINE> fb [ d - 1 ] += 1 <NEWLINE> <DEDENT> i += 1 <NEWLINE> <NL> <DEDENT> ans = [ - uf . table [ uf . _root ( i ) ] - 1 - fb [ i ] for i in range ( n ) ] <NEWLINE> print ( * ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> <NL> class UnionFind ( ) : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . n = n <NEWLINE> self . parents = [ - 1 ] * n <NEWLINE> <NL> <DEDENT> def find ( self , x ) : <NEWLINE> <INDENT> if self . parents [ x ] < 0 : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . parents [ x ] = self . find ( self . parents [ x ] ) <NEWLINE> return self . parents [ x ] <NEWLINE> <NL> <DEDENT> <DEDENT> def union ( self , x , y ) : <NEWLINE> <INDENT> x = self . find ( x ) <NEWLINE> y = self . find ( y ) <NEWLINE> <NL> if x == y : <NEWLINE> <INDENT> return <NEWLINE> <NL> <DEDENT> if self . parents [ x ] > self . parents [ y ] : <NEWLINE> <INDENT> x , y = y , x <NEWLINE> <NL> <DEDENT> self . parents [ x ] += self . parents [ y ] <NEWLINE> self . parents [ y ] = x <NEWLINE> <NL> <DEDENT> def size ( self , x ) : <NEWLINE> <INDENT> return - self . parents [ self . find ( x ) ] <NEWLINE> <NL> <DEDENT> def same ( self , x , y ) : <NEWLINE> <INDENT> return self . find ( x ) == self . find ( y ) <NEWLINE> <NL> <DEDENT> def members ( self , x ) : <NEWLINE> <INDENT> root = self . find ( x ) <NEWLINE> return [ i for i in range ( self . n ) if self . find ( i ) == root ] <NEWLINE> <NL> <DEDENT> def roots ( self ) : <NEWLINE> <INDENT> return [ i for i , x in enumerate ( self . parents ) if x < 0 ] <NEWLINE> <NL> <DEDENT> def group_count ( self ) : <NEWLINE> <INDENT> return len ( self . roots ( ) ) <NEWLINE> <NL> <DEDENT> def all_group_members ( self ) : <NEWLINE> <INDENT> return { r : self . members ( r ) for r in self . roots ( ) } <NEWLINE> <NL> <DEDENT> def __str__ ( self ) : <NEWLINE> <INDENT> return <STRING> . join ( <STRING> . format ( r , self . members ( r ) ) for r in self . roots ( ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> N , M = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> uf = UnionFind ( N ) <NEWLINE> A = [ 0 ] * M <NEWLINE> B = [ 0 ] * M <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> a , b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A [ i ] = a - 1 <NEWLINE> B [ i ] = b - 1 <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> cmax = int ( N * ( N - 1 ) / 2 ) <NEWLINE> FD = [ cmax ] * ( M + 1 ) <NEWLINE> <COMMENT> <NL> for i in range ( M ) : <NEWLINE> <COMMENT> <NL> <INDENT> if same ( A [ M - i - 1 ] ) * uf . size ( B [ M - i - 1 ] ) : <NEWLINE> <INDENT> FD [ M - i - 1 ] = FD [ M - i ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cless = uf . size ( A [ M - i - 1 ] ) * uf . size ( B [ M - i - 1 ] ) <NEWLINE> FD [ M - i - 1 ] = FD [ M - i ] - cless <NEWLINE> if FD [ M - i - 1 ] < 0 : FD [ M - i - 1 ] = 0 <NEWLINE> <DEDENT> uf . union ( A [ M - 1 - i ] , B [ M - 1 - i ] ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> for fd in FD [ 1 : ] : <NEWLINE> <INDENT> print ( fd ) <NEWLINE> <NL> <NL> <DEDENT>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> <NL> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> par = [ i for i in range ( n + 1 ) ] <NEWLINE> rank = [ 0 ] * ( n + 1 ) <NEWLINE> size = [ 1 ] * ( n + 1 ) <NEWLINE> <NL> def root ( x ) : <NEWLINE> <INDENT> if par [ x ] == x : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> par [ x ] = root ( par [ x ] ) <NEWLINE> return par [ x ] <NEWLINE> <NL> <DEDENT> <DEDENT> def same ( x , y ) : <NEWLINE> <INDENT> return root ( x ) == root ( y ) <NEWLINE> <NL> <DEDENT> def unite ( x , y ) : <NEWLINE> <INDENT> xx = root ( x ) <NEWLINE> yy = root ( y ) <NEWLINE> if xx == yy : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> if rank [ xx ] < rank [ yy ] : <NEWLINE> <INDENT> par [ xx ] = yy <NEWLINE> size [ yy ] += size [ xx ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> par [ yy ] = xx <NEWLINE> size [ xx ] += size [ yy ] <NEWLINE> if rank [ xx ] == rank [ yy ] : <NEWLINE> <INDENT> rank [ yy ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> ab = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( m ) ] <NEWLINE> <NL> ans = [ 0 ] * m <NEWLINE> ans [ m - 1 ] = n * ( n - 1 ) // 2 <NEWLINE> <NL> for i in range ( M - 1 , 0 , - 1 ) : <NEWLINE> <INDENT> a = ab [ i ] [ 0 ] <NEWLINE> b = ab [ i ] [ 1 ] <NEWLINE> if root ( a ) != root ( b ) : <NEWLINE> <INDENT> ans [ i - 1 ] = ans [ i ] - size [ root ( a ) ] * size [ root ( b ) ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans [ i - 1 ] = ans [ i ] <NEWLINE> <DEDENT> unite ( a , b ) <NEWLINE> <NL> <DEDENT> for ans_i in ans : <NEWLINE> <INDENT> print ( ans_i ) <NEWLINE> <DEDENT>
S = input ( ) <NEWLINE> print ( <STRING> if S [ 6 ] >= 5 or S [ 5 ] >= 1 else <STRING> ) <NEWLINE>
s = input ( ) <NEWLINE> if s <= 2019 / 0 4 / 30 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
y , m , d = int ( input ( ) . split ( <STRING> ) ) <NEWLINE> print ( <STRING> if y <= 2019 and m <= 4 and d <= 30 else <STRING> ) <NEWLINE>
S = input ( ) <NEWLINE> l = S . split ( <STRING> ) <NEWLINE> if l [ 0 ] <= 2019 : <NEWLINE> <INDENT> if l [ 1 ] <= 4 : <NEWLINE> <INDENT> if l [ 2 ] <= 30 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> s = s . split ( <STRING> ) <NEWLINE> <NL> if s [ 0 ] >= 2019 and s [ 1 ] >= 5 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> if s [ 5 ] = <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif int ( s [ 6 ] ) >= 5 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
y , m , d = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> if y < 2020 and m < 0 5 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s = str ( input ( ) ) <NEWLINE> year = <STRING> <NEWLINE> month = <STRING> <NEWLINE> day = <STRING> <NEWLINE> <NL> for i in range ( 4 ) : <NEWLINE> <INDENT> y = s [ i ] <NEWLINE> year += y <NEWLINE> <DEDENT> for i in range ( 5 , 7 ) : <NEWLINE> <INDENT> m = s [ i ] <NEWLINE> month += m <NEWLINE> <DEDENT> for i in range ( 9 , 11 ) : <NEWLINE> <INDENT> d = s [ i ] <NEWLINE> day += d <NEWLINE> <NL> <DEDENT> year = int ( year ) <NEWLINE> month = int ( month ) <NEWLINE> day = int ( day ) <NEWLINE> <NL> if year < 2019 : <NEWLINE> <INDENT> answer = <STRING> <NEWLINE> <NL> <DEDENT> elif year == 2019 and month <= 4 : <NEWLINE> <INDENT> answer = <STRING> <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> answer = <STRING> <NEWLINE> <NL> <DEDENT> print ( answer ) <NEWLINE>
s = input ( ) <NEWLINE> if s [ 5 ] == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if s [ 6 ] > 4 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
s = map ( str , input ( ) . split ( ) ) <NEWLINE> if int ( s [ 5 ] ) == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif int ( s [ 6 ] ) <= 4 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a = input ( ) <NEWLINE> if a [ 6 ] > 4 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a [ 6 ] < 3 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if a [ 8 ] < 2 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if a [ 9 ] > 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
s = input ( ) <NEWLINE> <NL> year = s [ : 4 ] <NEWLINE> mo = s [ 5 : 7 ] <NEWLINE> da = s [ 8 : ] <NEWLINE> <NL> if year < 2019 : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <DEDENT> elif year == 2019 and mo <= 4 : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> sum = 0 <NEWLINE> for j in range ( n ) : <NEWLINE> <INDENT> i , c = input ( ) . split ( ) <NEWLINE> if c == <STRING> : <NEWLINE> <INDENT> sum += float ( i ) * 380000 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> sum += i <NEWLINE> <DEDENT> <DEDENT> print ( sum ) <NEWLINE>
a = int ( input ( ) ) <NEWLINE> b = [ input ( ) . split ( ) for i in range ( a ) ] <NEWLINE> c = 0 <NEWLINE> for i in range ( a ) : <NEWLINE> <INDENT> if b [ i ] [ 1 ] == <STRING> : <NEWLINE> <INDENT> c = c + int ( b [ i ] [ 0 ] ) <NEWLINE> <DEDENT> if b [ i ] [ 1 ] == <STRING> : <NEWLINE> <INDENT> c = c + int ( b [ i ] [ 0 ] ) * 380000 <NEWLINE> <DEDENT> <DEDENT> print ( c ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <NL> <NL> def calculation ( lines ) : <NEWLINE> <COMMENT> <NL> <INDENT> N = int ( lines [ 0 ] ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> result = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> line = lines [ i + 1 ] <NEWLINE> if <STRING> in line : <NEWLINE> <INDENT> result += int ( line . replace ( <STRING> , <STRING> ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> result += float ( line . replace ( <STRING> , <STRING> ) ) * 380000.0 <NEWLINE> <NL> <DEDENT> <DEDENT> return [ result ] <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> def get_input_lines ( ) : <NEWLINE> <INDENT> line = input ( ) <NEWLINE> N , M = list ( map ( int , line . split ( ) ) ) <NEWLINE> lines = list ( ) <NEWLINE> lines . append ( line ) <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> lines . append ( input ( ) ) <NEWLINE> <DEDENT> return lines <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> def get_testdata ( pattern ) : <NEWLINE> <INDENT> if pattern == 1 : <NEWLINE> <INDENT> lines_input = [ <STRING> , <STRING> , <STRING> ] <NEWLINE> lines_export = [ 48000.0 ] <NEWLINE> <DEDENT> if pattern == 2 : <NEWLINE> <INDENT> lines_input = [ <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> lines_export = [ 138000000.0038 ] <NEWLINE> <DEDENT> return lines_input , lines_export <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> def get_mode ( ) : <NEWLINE> <INDENT> import sys <NEWLINE> args = sys . argv <NEWLINE> if len ( args ) == 1 : <NEWLINE> <INDENT> mode = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> mode = int ( args [ 1 ] ) <NEWLINE> <DEDENT> return mode <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> import time <NEWLINE> started = time . time ( ) <NEWLINE> mode = get_mode ( ) <NEWLINE> if mode == 0 : <NEWLINE> <INDENT> lines_input = get_input_lines ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> lines_input , lines_export = get_testdata ( mode ) <NEWLINE> <NL> <DEDENT> lines_result = calculation ( lines_input ) <NEWLINE> <NL> for line_result in lines_result : <NEWLINE> <INDENT> print ( line_result ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> x , u = map ( int , str , input ( ) . split ( ) ) <NEWLINE> if u == <STRING> : <NEWLINE> <INDENT> x = x * 380000 <NEWLINE> <DEDENT> ans = ans + x <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> x , u = map ( str , input ( ) . split ( ) ) <NEWLINE> x = int ( x ) <NEWLINE> if u == <STRING> : <NEWLINE> <INDENT> x *= 380000 <NEWLINE> <DEDENT> ans += x <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
from decimal import Decimal <NEWLINE> n = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for in range ( n ) : <NEWLINE> <INDENT> x , y = map ( str , input ( ) . split ( ) ) <NEWLINE> if y == <STRING> : <NEWLINE> <INDENT> ans += Decimal ( 380000 * Decimal ( x ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += Decimal ( x ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> import math <NEWLINE> import itertools <NEWLINE> import collections <NEWLINE> import heapq <NEWLINE> import re <NEWLINE> import numpy as np <NEWLINE> <NL> rr = lambda : sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> rs = lambda : sys . stdin . readline ( ) . split ( ) <NEWLINE> ri = lambda : int ( sys . stdin . readline ( ) ) <NEWLINE> rm = lambda : map ( int , sys . stdin . readline ( ) . split ( ) ) <NEWLINE> rl = lambda : list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) <NEWLINE> inf = float ( <STRING> ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> n = ri ( ) <NEWLINE> ans = 0 <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> a , b = rs ( ) <NEWLINE> if b == <STRING> : <NEWLINE> <INDENT> ans += float ( a ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += float ( a ) * 380000 <NEWLINE> <DEDENT> <DEDENT> pritn ( ans ) <NEWLINE> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL>
N = int ( input ( ) ) <NEWLINE> s = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> x , u = map ( str , input ( ) . split ( ) ) <NEWLINE> if u == <STRING> : <NEWLINE> <INDENT> s += int ( x ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s += 380000 * int ( x ) <NEWLINE> <DEDENT> <DEDENT> print ( s ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> xu = input ( ) . split ( ) <NEWLINE> if xu [ 1 ] == <STRING> : <NEWLINE> <INDENT> ans += xu [ 0 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += xu [ 0 ] * 380000 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
Row = int ( input ( ) ) <NEWLINE> List = [ ] <NEWLINE> for i in range ( Row ) : <NEWLINE> <INDENT> List . append ( list ( map ( str , input ( ) . split ( ) ) ) ) <NEWLINE> <DEDENT> res = 0 <NEWLINE> for i in range ( Row ) : <NEWLINE> <INDENT> if List [ i ] [ 1 ] = <STRING> : <NEWLINE> <INDENT> res += int ( List [ i ] [ 0 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> res += int ( List [ i ] [ 0 ] ) * 380000 <NEWLINE> <DEDENT> <DEDENT> print ( res ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a , b = map ( str , input ( ) . split ( ) ) <NEWLINE> if b = <STRING> : <NEWLINE> <INDENT> ans += int ( a ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += int ( a ) * 380000 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
btc = 380000 <NEWLINE> N = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> x , u = input ( ) . split ( ) <NEWLINE> if u == <STRING> : <NEWLINE> <INDENT> ans += int ( x ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += int ( x ) * btc <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> v , c = map ( int , input ( ) . split ( ) ) <NEWLINE> if c == <STRING> : <NEWLINE> <INDENT> a += v <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a += v * 380000.0 <NEWLINE> <DEDENT> <DEDENT> print ( a ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> kei = 0.0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> x , u = map ( str , input ( ) . split ( ) ) <NEWLINE> if u == <STRING> : <NEWLINE> <INDENT> kei += float ( x [ i ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> kei += float ( x [ i ] ) * 380000.0 <NEWLINE> <DEDENT> <DEDENT> print ( kei ) <NEWLINE>
def resolve ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> s = 0 <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> x , u = input ( ) . split ( ) <NEWLINE> if u == <STRING> : <NEWLINE> <INDENT> s += float ( x ) * 380000 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s += float ( x ) * 1 <NEWLINE> <DEDENT> <DEDENT> print ( s ) <NEWLINE> <DEDENT> resole ( ) <NEWLINE>
n , a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> l = [ int ( input ( ) ) for i in range ( n ) ] <NEWLINE> def dfs ( i , x , y , z ) : <NEWLINE> <INDENT> if i == n : return abs ( a - x ) + abs ( b - y ) + abs ( c - z ) - 30 if a + b + c >= 3 else 10 ** 9 + 7 <NEWLINE> A , B , C , D = dfs ( i + 1 , x , y , z ) , dfs ( i + 1 , x + l [ i ] , y , z ) + 10 , dfs ( i + 1 , x , y + l [ i ] , z ) + 10 , dfs ( i + 1 , x , y , z + l [ i ] ) + 10 <NEWLINE> return min ( A , B , C , D ) <NEWLINE> <DEDENT> print ( dfs ( 0 , 0 , 0 , 0 ) <NEWLINE>
from bisect import bisect_left <NEWLINE> <NL> A , B , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> S = [ int ( input ( ) ) for i in range ( A ) ] <NEWLINE> T = [ int ( input ( ) ) for i in range ( B ) ] <NEWLINE> for i in range ( Q ) : <NEWLINE> <INDENT> x = int ( input ( ) ) <NEWLINE> si = bisect_left ( S , x ) <NEWLINE> ti = bisect_left ( T , x ) <NEWLINE> if 0 < si < A and 0 < ti < B : <NEWLINE> <INDENT> sl , sr = abs ( x - S [ si - 1 ] ) , abs ( x - S [ si ] ) <NEWLINE> tl , tr = abs ( x - T [ ti - 1 ] ) , abs ( x - T [ ti ] ) <NEWLINE> print ( min ( max ( sr , tr ) , max ( sl , tl ) , sl + tr + min ( sl , tr ) , sr + tl + min ( sr , tl ) ) ) <NEWLINE> <DEDENT> elif si == 0 and ti == 0 : <NEWLINE> <INDENT> sr = abs ( x - S [ si ] ) <NEWLINE> tr = abs ( x - T [ ti ] ) <NEWLINE> print ( sr , tr ) <NEWLINE> <DEDENT> elif si == A and ti == B : <NEWLINE> <INDENT> sl = abs ( x - S [ si - 1 ] ) , abs ( x - S [ si ] ) <NEWLINE> tl = abs ( x - T [ ti - 1 ] ) , abs ( x - T [ ti ] ) <NEWLINE> print ( max ( sl , tl ) ) <NEWLINE> <DEDENT> elif si == 0 and ti == B : <NEWLINE> <INDENT> sr = abs ( x - S [ si ] ) <NEWLINE> tl = abs ( x - T [ ti - 1 ] ) <NEWLINE> print ( sr + tl + min ( sr , tl ) ) <NEWLINE> <DEDENT> elif si == A and ti == 0 : <NEWLINE> <INDENT> sl = abs ( x - S [ si - 1 ] ) <NEWLINE> tr = abs ( x - T [ ti ] ) <NEWLINE> print ( sl + tr + min ( sl , tr ) ) <NEWLINE> <DEDENT> elif si == 0 : <NEWLINE> <INDENT> sr = abs ( x - S [ si ] ) <NEWLINE> tl , tr = abs ( x - T [ ti - 1 ] ) , abs ( x - T [ ti ] ) <NEWLINE> print ( min ( max ( sr , tr ) , sr + tl + min ( sr , tl ) ) ) <NEWLINE> <DEDENT> elif si == A : <NEWLINE> <INDENT> sl = abs ( x - S [ si - 1 ] ) <NEWLINE> tl , tr = abs ( x - T [ ti - 1 ] ) , abs ( x - T [ ti ] ) <NEWLINE> print ( min ( max ( sl , tl ) , sl + tr + min ( sl , tr ) ) ) <NEWLINE> <DEDENT> elif ti == 0 : <NEWLINE> <INDENT> sl , sr = abs ( x - S [ si - 1 ] ) , abs ( x - S [ si ] ) <NEWLINE> tr = abs ( x - T [ ti ] ) <NEWLINE> print ( min ( max ( sr , tr ) , sl + tr + min ( sl , tr ) ) ) <NEWLINE> <DEDENT> elif ti == B : <NEWLINE> <INDENT> sl , sr = abs ( x - S [ si - 1 ] ) , abs ( x - S [ si ] ) <NEWLINE> tl = abs ( x - T [ ti - 1 ] ) <NEWLINE> print ( min ( max ( sl , tl ) , sr + tl + min ( sr , tl ) ) ) <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> import re <NEWLINE> import math <NEWLINE> import collections <NEWLINE> import bisect <NEWLINE> import itertools <NEWLINE> import fractions <NEWLINE> import functools <NEWLINE> import copy <NEWLINE> import heapq <NEWLINE> import decimal <NEWLINE> import statistics <NEWLINE> import queue <NEWLINE> <NL> <COMMENT> <NL> <NL> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> INF = 10 ** 16 <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> <COMMENT> <NL> <NL> ni = lambda : int ( sys . stdin . readline ( ) ) <NEWLINE> ns = lambda : map ( int , sys . stdin . readline ( ) . split ( ) ) <NEWLINE> na = lambda : list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) <NEWLINE> na1 = lambda : list ( map ( lambda x : int ( x ) - 1 , sys . stdin . readline ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> <COMMENT> <NL> <NL> def disLR ( a , idx ) : <NEWLINE> <INDENT> small = a [ max ( 0 , idx - 1 ) ] <NEWLINE> large = a [ min ( len ( a ) - 1 , idx ) ] <NEWLINE> return small , large <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> a , b , q = ns ( ) <NEWLINE> s = [ ni ( ) for _ in range ( a ) ] <NEWLINE> t = [ ni ( ) for _ in range ( b ) ] <NEWLINE> <NL> for _ in range ( q ) : <NEWLINE> <INDENT> ans = INF <NEWLINE> <NL> x = ni ( ) <NEWLINE> <NL> idxs = bisect . bisect_left ( s , x ) <NEWLINE> a1 = [ disLR ( s , idxs ) ] <NEWLINE> <NL> idxt = bisect . bisect_left ( t , x ) <NEWLINE> a2 = [ disLR ( t , idxt ) ] <NEWLINE> <NL> for ta1 in a1 : <NEWLINE> <INDENT> for ta2 in a2 : <NEWLINE> <INDENT> tmp1 = abs ( x - a1 ) + abs ( a2 - a1 ) <NEWLINE> tmp2 = abs ( x - a2 ) + abs ( a1 - a2 ) <NEWLINE> ans = min ( ans , tmp1 , tmp2 ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
A , B = map ( int ( input ( ) . split ( ) ) ) <NEWLINE> if B % A == 0 : <NEWLINE> <INDENT> print ( A + B ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( A - B ) <NEWLINE> <DEDENT>
A , B = mao ( int , input ( ) . split ( ) ) <NEWLINE> if B % A == 0 : <NEWLINE> <INDENT> print ( A + B ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( B - A ) <NEWLINE> <DEDENT>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> b = input ( ) <NEWLINE> if b % a == 0 : <NEWLINE> <INDENT> print ( a + b ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( b - a ) <NEWLINE> <DEDENT>
<NL> def main ( ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if b / a % 0 : <NEWLINE> <INDENT> print ( a + b ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( b - a ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = [ ] * ( m + 1 ) <NEWLINE> output = 0 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> k = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for j in range ( 1 , len ( k ) ) : <NEWLINE> <INDENT> ans [ j ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> for i in ans : <NEWLINE> <INDENT> if ans [ i ] == n : <NEWLINE> <INDENT> output += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( output ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> LIKE = set ( ) <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> AK = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> LIKE |= AK [ 1 : ] <NEWLINE> <NL> <DEDENT> print ( len ( LIKE ) ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> foods = [ 0 ] * M <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> KA = list ( map ( int , input ( ) . split ( ) ) <NEWLINE> for a in KA [ 1 : ] : <NEWLINE> <INDENT> foods [ a - 1 ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> cnt = 0 <NEWLINE> for j in foods : <NEWLINE> <INDENT> if j == N : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> t = [ 0 for i in range ( M + 1 ) ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> A = map ( int , input ( ) . split ( ) ) <NEWLINE> for j in range ( 1 , A [ 0 ] + 1 ) : <NEWLINE> <INDENT> t [ A [ j ] ] += 1 <NEWLINE> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for i in t : <NEWLINE> <INDENT> if i == N : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N . M = map ( int , input ( ) . split ( ) ) <NEWLINE> C = [ 0 ] * ( M + 1 ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> K = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for k in range ( len ( k ) ) : <NEWLINE> <INDENT> C [ K [ k ] ] += 1 <NEWLINE> <DEDENT> <DEDENT> count = 0 <NEWLINE> <NL> for c in C : <NEWLINE> <INDENT> if c == N : <NEWLINE> <INDENT> count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
import numpy as np <NEWLINE> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> A = np . zeros ( ( N , M ) ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = a [ 1 : ] <NEWLINE> A [ i , 0 : len ( a ) ] = a <NEWLINE> <NL> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> a = A [ i ] <NEWLINE> a = a [ ( a != 0 ) & ( a < M ) ] <NEWLINE> if i == 0 : <NEWLINE> <INDENT> s = set ( list ( a ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> _s = set ( list ( a ) ) <NEWLINE> <DEDENT> s &= _s <NEWLINE> <NL> <DEDENT> print ( len ( s ) ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ ] * N <NEWLINE> for i in ragne ( N ) : <NEWLINE> <INDENT> A [ i ] = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> A = set ( range ( 1 , m + 1 ) ) <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> a , * b = map ( int , input ( ) . split ( ) ) <NEWLINE> A = A & set ( * b ) <NEWLINE> <DEDENT> print ( len ( A ) ) <NEWLINE>
N , P = map ( int , input ( ) . split ( ) ) <NEWLINE> List = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> List += list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <DEDENT> count = 0 <NEWLINE> for i in range ( P + 1 ) : <NEWLINE> <INDENT> if List . count ( List [ i ] ) = N : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> a = sorted ( a ) <NEWLINE> <NL> def make_divisors ( n ) : <NEWLINE> <INDENT> lower_divisors , upper_divisors = [ ] , [ ] <NEWLINE> i = 1 <NEWLINE> while i * i <= n : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> lower_divisors . append ( i ) <NEWLINE> if i != n // i : <NEWLINE> <INDENT> upper_divisors . append ( n // i ) <NEWLINE> <DEDENT> <DEDENT> i += 1 <NEWLINE> <DEDENT> return lower_divisors + upper_divisors [ : : - 1 ] <NEWLINE> <NL> <DEDENT> c = make_divisors ( a [ 0 ] ) <NEWLINE> d = list ( c . keys ) <NEWLINE> <NL> d = d . sorted <NEWLINE> f = [ ] <NEWLINE> for y in range ( len ( d ) ) <NEWLINE> <INDENT> e = d [ y ] <NEWLINE> ch = 0 <NEWLINE> for x in range ( 1 , n ) : <NEWLINE> <INDENT> if not a [ x ] % e == 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> ch += 1 <NEWLINE> <DEDENT> if ch == n - 1 : <NEWLINE> <INDENT> f . append ( e ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( max ( f ) ) <NEWLINE> <NL> <NL>
from math import floor , ceil , sqrt , factorial , log , gcd <NEWLINE> from itertools import accumulate , permutations , combinations , product , combinations_with_replacement <NEWLINE> from bisect import bisect_left , bisect_right <NEWLINE> from collections import Counter , defaultdict <NEWLINE> from heapq import heappop , heappush , heappushpop <NEWLINE> import sys <NEWLINE> INF = float ( <STRING> ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> <NL> def lcm ( a , b ) : return a * b / gcd ( a , b ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> def LI ( ) : return list ( map ( int , sys . stdin . buffer . readline ( ) . split ( ) ) ) <NEWLINE> <NL> <COMMENT> <NL> <NL> <NL> def I ( ) : return int ( sys . stdin . buffer . readline ( ) ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> def LS ( ) : return sys . stdin . buffer . readline ( ) . rstrip ( ) . decode ( <STRING> ) . split ( ) <NEWLINE> <NL> <COMMENT> <NL> <NL> <NL> def S ( ) : return sys . stdin . buffer . readline ( ) . rstrip ( ) . decode ( <STRING> ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> def IR ( n ) : return [ I ( ) for i in range ( n ) ] <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> def LIR ( n ) : return [ LI ( ) for i in range ( n ) ] <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> def SR ( n ) : return [ S ( ) for i in range ( n ) ] <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> def LSR ( n ) : return [ LS ( ) for i in range ( n ) ] <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> def SRL ( n ) : return [ list ( S ( ) ) for i in range ( n ) ] <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> n = I ( ) <NEWLINE> lst = LI ( ) <NEWLINE> print ( gcd ( lst ) ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = [ int ( input ( ) ) for i in range ( n ) ] <NEWLINE> <NL> g = gcd ( a [ 0 ] , a [ 1 ] ) <NEWLINE> for i in range ( 2 , n ) : <NEWLINE> <INDENT> g = gcd ( g , a [ i ] ) <NEWLINE> <NL> <DEDENT> print ( g ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a_list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> gcd = a_list [ 0 ] <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> gcd = math . gcd ( gcd , a_list [ i ] ) <NEWLINE> <NL> <NL> <DEDENT> print ( gcd ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> now = A [ 0 ] <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> now = math . gcd ( A [ i ] , now ) <NEWLINE> <DEDENT> print ( now ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> M = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = min ( M ) <NEWLINE> mn = Min ( M ) <NEWLINE> from math import gcd <NEWLINE> for m in M : <NEWLINE> <INDENT> if m % ans != 0 : <NEWLINE> <INDENT> ans = min ( ans , gcd ( mn , m ) ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> xlist = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = xlist [ 0 ] <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> a = fractions . gcd ( a , xlist [ i ] ) <NEWLINE> <DEDENT> print ( a ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = a [ 0 ] <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> ans = gcd ( ans , a [ i ] ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> print ( reduce ( math . gcd , map ( int , input ( ) . split ( ) ) ) ) <NEWLINE>
N , K = map ( int ( input ( ) . split ( ) ) ) <NEWLINE> if N >= k * 2 - 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> if N + 1 >= 2 * K : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> ele : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
<COMMENT> <NL> cnts = [ 0 ] * 4 <NEWLINE> for i in range ( 3 ) : <NEWLINE> <INDENT> ai , bi = map ( int , input ( ) . split ( ) ) <NEWLINE> ai -= 1 ; bi -= 1 <NEWLINE> cnts [ ai ] += 1 ; cnts [ bi ] += 1 <NEWLINE> <DEDENT> for i in range ( 4 ) : <NEWLINE> <INDENT> if cnts > 2 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
G = [ 0 ] * 4 <NEWLINE> for i in range ( 3 ) : <NEWLINE> <INDENT> a , b = mii ( ) <NEWLINE> a -= 1 <NEWLINE> b -= 1 <NEWLINE> G [ a ] += 1 <NEWLINE> G [ b ] += 1 <NEWLINE> <NL> <DEDENT> for i in range ( 4 ) : <NEWLINE> <INDENT> if G [ i ] == 3 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
print ( <STRING> [ len ( { * map ( int , input ( ) . split ( ) ) for i in range ( 3 ) } ) != 4 : : 2 ] ) <NEWLINE>
from collections import defaultdict <NEWLINE> from collections import deque <NEWLINE> import itertools <NEWLINE> import math <NEWLINE> <NL> def readInt ( ) : <NEWLINE> <INDENT> return int ( input ( ) ) <NEWLINE> <DEDENT> def readInts ( ) : <NEWLINE> <INDENT> return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <DEDENT> def readChar ( ) : <NEWLINE> <INDENT> return input ( ) <NEWLINE> <DEDENT> def readChars ( ) : <NEWLINE> <INDENT> return input ( ) . split ( ) <NEWLINE> <NL> <DEDENT> k , a , b = readInts ( ) <NEWLINE> <NL> if a + 1 <= k and a + 2 < b : <NEWLINE> <INDENT> k -= a + 1 <NEWLINE> ans += k // 2 * ( b - a ) + k % 2 + b <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = k + 1 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
K , A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> count = 1 <NEWLINE> coin = 0 <NEWLINE> if B - A <= 2 : <NEWLINE> <INDENT> print ( K + 1 ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( K ) : <NEWLINE> <INDENT> if coin == 1 : <NEWLINE> <INDENT> count += B <NEWLINE> coin -= 1 <NEWLINE> <DEDENT> elif count >= A and i != k - 1 : <NEWLINE> <INDENT> count -= A <NEWLINE> coin += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE> <NL> <DEDENT>
t , x = map ( float , input ( ) . split ( ) ) <NEWLINE> print ( { 0 : .4 f } . format ( t / x ) ) <NEWLINE>
a , b = map ( double , input ( ) . split ( ) ) <NEWLINE> print ( a / b ) <NEWLINE>
T , X = map ( int , input ( ) ) <NEWLINE> <NL> print ( T / X ) <NEWLINE>
a , b = map ( int , input ( ) ) <NEWLINE> print ( a / b ) <NEWLINE>
t , x = map ( int , inupt ( ) . split ( ) ) <NEWLINE> print ( t / x ) <NEWLINE>
T , X = int ( input ( ) . split ( ) ) <NEWLINE> print ( T / X ) <NEWLINE>
x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( x / t ) <NEWLINE>
T , X = map ( int , input ( ) ) <NEWLINE> print ( float ( T / X ) ) <NEWLINE>
_ = input ( ) <NEWLINE> edges = list ( int , input ( ) . split ( ) ) <NEWLINE> max_edge = max ( edges ) <NEWLINE> print ( <STRING> if max_edge < sum ( edges ) - max_edge else <STRING> ) <NEWLINE>
n , l = map ( int , open ( 0 ) . read ( ) . split ( ) ) <NEWLINE> sum_n = sum ( l ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if 2 * l [ i ] >= sum_n <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> import sys <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> L = list ( ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if max ( L ) - ( sum ( L ) - max ( L ) ) < 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> L = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> s = 0 <NEWLINE> for i in L : <NEWLINE> <INDENT> s += i <NEWLINE> <DEDENT> s -= max ( L ) <NEWLINE> if L < s : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> nl = sorted ( l ) <NEWLINE> <NL> for i in range ( n - 1 ) : <NEWLINE> <INDENT> other = 0 + n1 [ i ] <NEWLINE> <NL> <DEDENT> if other < nl [ n - 1 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
<NL> n = int ( input ( ) ) <NEWLINE> L = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> L . sort ( ) <NEWLINE> ans = sum ( L [ : n - 1 ] ) <NEWLINE> if ans > L [ n - 1 : n ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> L = list ( map ( int , int ( input ( ) ) ) ) <NEWLINE> L . sort ( ) <NEWLINE> if L [ - 1 ] > ( sum ( L ) - L [ - 1 ] ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = int ( inout ( ) ) <NEWLINE> L = input ( ) . split ( ) <NEWLINE> flag = 0 <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> L [ i ] = int ( L [ i ] ) <NEWLINE> total += L [ i ] <NEWLINE> <NL> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> if L [ i ] * 2 >= total : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> flag = 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if flag == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
<COMMENT> <NL> n = int ( input ( ) ) <NEWLINE> l = [ int ( input ( ) ) for i in range ( n ) ] <NEWLINE> print ( <STRING> if max ( l ) >= ( sum ( l ) - max ( l ) ) else <STRING> ) <NEWLINE>
<COMMENT> <NL> <NL> def atc_117b ( N : int , Li_input : str ) -> str : <NEWLINE> <INDENT> Li = [ int ( i ) for i in Li_input . split ( <STRING> ) ] <NEWLINE> Li = sorted ( Li ) <NEWLINE> max_length = Li . pop ( ) <NEWLINE> if max_length < sum ( Li ) : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> return <STRING> <NEWLINE> <NL> <DEDENT> N_input_value = int ( input ( ) ) <NEWLINE> Li_input_Value = input ( ) <NEWLINE> print ( atc_117b ( N_input_value , Li_input_value ) ) <NEWLINE>
_ , l = map ( int , open ( 0 ) . read ( ) . split ( ) ) <NEWLINE> l . sort ( ) <NEWLINE> print ( <STRING> [ sum ( l [ : - 1 ] ) <= l [ - 1 ] : : 2 ] ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> l = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> l . sort ( ) <NEWLINE> l . reverse ( ) <NEWLINE> cnt = 0 <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> cnt += l [ i ] <NEWLINE> <DEDENT> if cnt > l [ n ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
<NL> <NL> N , M = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> X = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> X . sort ( ) <NEWLINE> cnt = 0 <NEWLINE> arr = [ 0 ] * ( M - 1 ) <NEWLINE> if N > M : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( 1 , M ) : <NEWLINE> <INDENT> arr [ i ] = ( abs ( X [ i - 1 ] - X [ i ] ) ) <NEWLINE> <COMMENT> <NL> <DEDENT> arr . sort ( ) <NEWLINE> ans = sum ( arr [ 0 : M - N ] ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
x , m = map ( int , input ( ) . split ( ) ) <NEWLINE> x = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> if n >= m : print ( 0 ) <NEWLINE> else : <NEWLINE> <INDENT> dist = [ abs ( x [ i + 1 ] - x [ i ] ) for i in range ( m - 1 ) ] <NEWLINE> dist = sorted ( dist ) <NEWLINE> print ( sum ( dist [ : - ( n - 1 ) ] ) ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> if N >= M : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> X . sort ( ) <NEWLINE> ans = [ ] <NEWLINE> for i in range ( M - 1 ) : <NEWLINE> <INDENT> ans . append ( abs ( X [ i + 1 ] - X [ i ] ) ) <NEWLINE> <NL> <DEDENT> print ( X [ - 1 ] - X [ 0 ] - sum ( sorted ( ans ) [ : : - 1 ] [ : N - 1 ] ) ) <NEWLINE>
N , A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> <COMMENT> <NL> x = min ( A , B ) <NEWLINE> <COMMENT> <NL> y = 0 <NEWLINE> <NL> if N < A + B : <NEWLINE> <INDENT> if A > B : <NEWLINE> <INDENT> y = A - B <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> y = B - A <NEWLINE> <NL> <DEDENT> <DEDENT> print ( x + <STRING> + y ) <NEWLINE>
N , A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if ( A > B ) : <NEWLINE> <INDENT> ans1 = B <NEWLINE> ans2 = A - ( N - B ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans1 = A <NEWLINE> ans2 = B - ( N - A ) <NEWLINE> <NL> <DEDENT> print ( ans1 + <STRING> + ans2 ) <NEWLINE>
N , A , B = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> m = A + B <NEWLINE> print ( min ( A , B ) , max ( 0 , m - N ) ) <NEWLINE>
n , a , b = map ( int , input . split ( ) ) <NEWLINE> mx = min ( a , b ) <NEWLINE> mn = mx - ( n - max ( a , b ) ) <NEWLINE> print ( str ( mx ) + <STRING> + str ( mn ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a , b , c = input ( ) , input ( ) , input ( ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ans += len ( set ( a [ i ] , b [ i ] , c [ i ] ) ) - 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
from sys import stdin <NEWLINE> N = int ( stdin . readline ( ) . rstrip ( ) ) <NEWLINE> A = stdin . readline ( ) . rstrip ( ) <NEWLINE> B = stdin . readline ( ) . rstrip ( ) <NEWLINE> C = stdin . readline ( ) . rstrip ( ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> ans += len ( set ( A [ i ] , B [ i ] , C [ i ] ) ) - 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( a * b * / 2 ) <NEWLINE>
a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( min ( a , b , c ) * ( sum ( [ a , b , c ] - min ( a , b , c ) - max ( a , b , c ) ) ) // 2 ) <NEWLINE>
a , b , c = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> if a >= b and a >= c : <NEWLINE> <INDENT> print ( c * b // 2 ) <NEWLINE> <DEDENT> else if b >= c and b >= a : <NEWLINE> <INDENT> print ( a * c // 2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( a * b // 2 ) <NEWLINE> <DEDENT>
length1 , length2 , length3 = map ( int , input ( ) . split ( ) ) <NEWLINE> area = AB * BC / 2 <NEWLINE> print ( int ( area ) ) <NEWLINE>
a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = a . sorted ( ) <NEWLINE> print ( b [ 1 ] * b [ 2 ] ) <NEWLINE>
l = sorted ( map , input ( ) . split ( ) ) <NEWLINE> print ( ( l [ 0 ] * l [ 1 ] ) // 2 ) <NEWLINE>
AB , BC , CA = int ( input ( ) ) <NEWLINE> <NL> print ( ( AB * BC ) // 2 ) <NEWLINE>
a , b , c = input ( ) . split ( ) <NEWLINE> ls = [ a , b , c ] <NEWLINE> ls . sort ( ) <NEWLINE> print ( ls [ 0 ] * ls [ 1 ] ) <NEWLINE>
AB , BC , CA = map ( int , input ( ) . split ( ) ) <NEWLINE> if ( 1 <= AB & AB <= 100 ) & ( 1 <= BC & BC <= 100 ) & ( 1 <= CA & CA <= 100 ) <NEWLINE> <INDENT> S = int ( AB * BC / 2 ) <NEWLINE> print ( S ) <NEWLINE> <DEDENT>
a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> lis = [ a , b , c ] <NEWLINE> lis = lis . remove ( max ( lis ) ) <NEWLINE> <NL> print ( int ( lis [ 0 ] * lis [ 1 ] / 2 ) ) <NEWLINE>
a , b , c = map ( int , input ( ) . splis ( ) ) <NEWLINE> dai = max ( a , b , c ) <NEWLINE> shou = min ( a , b , c ) <NEWLINE> mid = a + b + c - dai - shou <NEWLINE> <NL> print ( shou * mid / 2 ) <NEWLINE>
L = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> print ( L [ 0 ] * l [ 1 ] // 2 ) <NEWLINE>
l = list ( map ( int , input ( ) ) ) <NEWLINE> <NL> l . sort ( ) <NEWLINE> <NL> print ( l [ 0 ] * l [ 1 ] // 2 ) <NEWLINE>
a , b , c = map ( int , input . split ( ) ) <NEWLINE> print ( a * b // 2 ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> print ( a * b // 2 ) <NEWLINE>
s = int ( input ( ) ) <NEWLINE> a = [ s ] <NEWLINE> i = 1 <NEWLINE> while True : <NEWLINE> <INDENT> if s % 2 == 0 : <NEWLINE> <INDENT> s = s // 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s = 3 * s + 1 <NEWLINE> <DEDENT> if s in a : <NEWLINE> <INDENT> print ( len ( a ) + 1 ) <NEWLINE> <DEDENT> a . append ( s ) <NEWLINE> <DEDENT>
s = list ( int ( input ( ) ) ) <NEWLINE> for i in range ( 1000001 ) : <NEWLINE> <INDENT> if s [ i ] % 2 == 0 : <NEWLINE> <INDENT> s . append ( s [ i ] / 2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s . append ( 3 * s [ i ] + 1 ) <NEWLINE> <DEDENT> if s [ i ] in s [ : i ] : <NEWLINE> <INDENT> print ( i + 1 ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT>
s = int ( input ( ) ) <NEWLINE> G = [ s ] <NEWLINE> while all ( G [ i ] != G [ - 1 ] for i in range ( len ( G ) - 1 ) ) : <NEWLINE> <INDENT> if G [ - 1 ] % 2 == 0 : <NEWLINE> <INDENT> G . append ( int ( x / 2 ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> G . append ( int ( 3 * x + 1 ) ) <NEWLINE> <DEDENT> <DEDENT> print ( len ( G ) ) <NEWLINE>
s = int ( input ( ) ) <NEWLINE> l = [ ] <NEWLINE> a = 0 <NEWLINE> l . append ( s ) <NEWLINE> while True : <NEWLINE> <INDENT> a += 1 <NEWLINE> if s % 2 == 0 : <NEWLINE> <INDENT> s = round ( s / 2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s = s * 3 + 1 <NEWLINE> <DEDENT> if l . count ( s ) != 0 : <NEWLINE> <INDENT> print ( a + 1 ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT>
h_state = [ 0 ] * n <NEWLINE> <NL> def water ( n , h , h_state ) : <NEWLINE> <INDENT> for i in range ( n ) : <NEWLINE> <INDENT> if h_state [ i ] < h [ i ] : <NEWLINE> <INDENT> l = i <NEWLINE> break <NEWLINE> <DEDENT> elif i == n - 1 and h_state [ i ] < h [ i ] : <NEWLINE> <INDENT> l = i <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> l = i + 1 <NEWLINE> <NL> <DEDENT> <DEDENT> for j in range ( l , n ) : <NEWLINE> <INDENT> if h_state [ j ] == h [ j ] : <NEWLINE> <INDENT> r = j - 1 <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> r = j <NEWLINE> <NL> <DEDENT> <DEDENT> for k in range ( l , r + 1 ) : <NEWLINE> <INDENT> h_state [ k ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> cnt = 0 <NEWLINE> while h_state != h : <NEWLINE> <INDENT> for i in range ( n ) : <NEWLINE> <INDENT> if h_state [ i ] < h [ i ] : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> water ( n , h , h_state ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
H = [ 0 ] + H <NEWLINE> cnt = 0 <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> cnt += max ( H [ i ] - H [ i - 1 ] , 0 ) <NEWLINE> <NL> <NL> <DEDENT> print ( cnt ) <NEWLINE>
import sys <NEWLINE> def LI ( ) : return list ( map ( int , sys . stdin . buffer . readline ( ) . split ( ) ) ) <NEWLINE> def I ( ) : return int ( sys . stdin . buffer . readline ( ) ) <NEWLINE> def LS ( ) : return sys . stdin . buffer . readline ( ) . rstrip ( ) . decode ( <STRING> ) . split ( ) <NEWLINE> def S ( ) : return sys . stdin . buffer . readline ( ) . rstrip ( ) . decode ( <STRING> ) <NEWLINE> def IR ( n ) : return [ I ( ) for i in range ( n ) ] <NEWLINE> def LIR ( n ) : return [ LI ( ) for i in range ( n ) ] <NEWLINE> def SR ( n ) : return [ S ( ) for i in range ( n ) ] <NEWLINE> def LSR ( n ) : return [ LS ( ) for i in range ( n ) ] <NEWLINE> def SRL ( n ) : return [ list ( S ( ) ) for i in range ( n ) ] <NEWLINE> def MSRL ( n ) : return [ [ int ( j ) for j in list ( S ( ) ) ] for i in range ( n ) ] <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> n = I ( ) <NEWLINE> hl = LI ( ) <NEWLINE> <COMMENT> <NL> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> ans = hl [ 0 ] <NEWLINE> for i in range ( 1 , n ) <NEWLINE> <INDENT> ans += max ( 0 , hl [ i ] - hl [ i - 1 ] ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL>
from math import floor , ceil , sqrt , factorial , log , gcd <NEWLINE> from itertools import accumulate , permutations , combinations , product , combinations_with_replacement <NEWLINE> from bisect import bisect_left , bisect_right <NEWLINE> from collections import Counter , defaultdict <NEWLINE> from heapq import heappop , heappush , heappushpop <NEWLINE> import copy <NEWLINE> import numpy as np <NEWLINE> import sys <NEWLINE> INF = float ( <STRING> ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> <NL> def lcm ( a , b ) : return a * b / gcd ( a , b ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> def LI ( ) : return list ( map ( int , sys . stdin . buffer . readline ( ) . split ( ) ) ) <NEWLINE> <NL> <COMMENT> <NL> <NL> <NL> def I ( ) : return int ( sys . stdin . buffer . readline ( ) ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> def LS ( ) : return sys . stdin . buffer . readline ( ) . rstrip ( ) . decode ( <STRING> ) . split ( ) <NEWLINE> <NL> <COMMENT> <NL> <NL> <NL> def S ( ) : return sys . stdin . buffer . readline ( ) . rstrip ( ) . decode ( <STRING> ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> def IR ( n ) : return [ I ( ) for i in range ( n ) ] <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> def LIR ( n ) : return [ LI ( ) for i in range ( n ) ] <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> def SR ( n ) : return [ S ( ) for i in range ( n ) ] <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> def LSR ( n ) : return [ LS ( ) for i in range ( n ) ] <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> def SRL ( n ) : return [ list ( S ( ) ) for i in range ( n ) ] <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> n = I ( ) <NEWLINE> h = list ( LI ( ) ) <NEWLINE> n = int ( input ( ) ) <NEWLINE> ans = h [ 0 ] <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> if h [ i ] > h [ i - 1 ] : <NEWLINE> <INDENT> ans += h [ i ] - h [ i - 1 ] <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> h = [ list ( map ( int , input ( ) . split ( ) ) ) ] <NEWLINE> ans = h [ 0 ] <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> if h [ i + 1 ] > h [ i ] : <NEWLINE> <INDENT> ans += h [ i + 1 ] - h [ i ] <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> hm = max ( h ) <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( hm , - 1 , - 1 ) : <NEWLINE> <INDENT> t = 1 <NEWLINE> for j in range ( n ) : <NEWLINE> <INDENT> if h [ j ] = i : <NEWLINE> <INDENT> ans += t <NEWLINE> t = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> t = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
s = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> c = [ 1 , , 4 , 7 , 9 ] <NEWLINE> <NL> if s == c : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
print ( <STRING> if set ( map ( int , input ( ) . split ( ) ) ) == set ( 1 , 9 , 7 , 4 ) else <STRING> ) <NEWLINE>
a = <STRING> . join ( list ( sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) ) ) <NEWLINE> if ( a == <STRING> ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <NL> <DEDENT>
n1 , n2 , n3 , n4 = map ( input ( ) . split ( ) ) <NEWLINE> if { n1 , n2 , n3 , n4 } == { 1 , 9 , 7 , 4 } : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> <NL> for i in range ( 1 , 8 ) : <NEWLINE> <INDENT> a , b = i , 7 - i <NEWLINE> l , r = k [ : i ] , k [ i : ] <NEWLINE> <NL> if l in s and r in s : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
keyence <NEWLINE>
<COMMENT> <NL> s = input ( ) <NEWLINE> for i in range ( n : = len ( s ) ) <NEWLINE> <INDENT> if s [ : i ] + s [ n - 7 + i : ] == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> S = input ( ) <NEWLINE> if S [ 0 ] != <STRING> : <NEWLINE> <INDENT> return ( <STRING> ) <NEWLINE> <DEDENT> elif S = <STRING> : <NEWLINE> <INDENT> return ( <STRING> ) <NEWLINE> <NL> <DEDENT> ans = <STRING> <NEWLINE> i = 0 <NEWLINE> j = 0 <NEWLINE> while True : <NEWLINE> <INDENT> i += 1 <NEWLINE> j += 1 <NEWLINE> if S [ i ] != ans [ j ] : <NEWLINE> <INDENT> break <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> num = 7 - j <NEWLINE> cnt = 0 <NEWLINE> while cnt < num : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <COMMENT> <NL> if S [ - cnt ] != ans [ - cnt ] : <NEWLINE> <INDENT> return ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> return ( <STRING> ) <NEWLINE> <DEDENT> print ( main ( ) ) <NEWLINE>
S = input ( ) <NEWLINE> l = len ( S ) <NEWLINE> <COMMENT> <NL> if s [ : 7 ] == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <COMMENT> <NL> <DEDENT> elif s [ : 1 ] == <STRING> and s [ l - 6 : ] == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <COMMENT> <NL> <DEDENT> elif s [ : 2 ] == <STRING> and s [ l - 5 : ] == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <COMMENT> <NL> <DEDENT> elif s [ : 3 ] == <STRING> and s [ l - 4 : ] == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <COMMENT> <NL> <DEDENT> elif s [ : 4 ] == <STRING> and s [ l - 3 : ] == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <COMMENT> <NL> <DEDENT> elif s [ : 5 ] == <STRING> and s [ l - 2 : ] == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <COMMENT> <NL> <DEDENT> elif s [ : 6 ] == <STRING> and s [ l - 1 : ] == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <COMMENT> <NL> <DEDENT> elif s [ l - 7 : ] == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> surplus = [ ] <NEWLINE> short = [ ] <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> if a [ i ] > b [ i ] : <NEWLINE> <INDENT> surplus . append ( a [ i ] - b [ i ] ) <NEWLINE> <DEDENT> elif b [ i ] > a [ i ] : <NEWLINE> <INDENT> short . append ( b [ i ] - a [ i ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> surplus = sorted ( surplus ) <NEWLINE> taken = False <NEWLINE> cnt = 0 <NEWLINE> for i in range ( len ( short ) ) : <NEWLINE> <INDENT> cost = short . pop ( ) <NEWLINE> cnt += 1 <NEWLINE> <NL> while cost > 0 : <NEWLINE> <INDENT> if len ( surplus ) == 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> take = min ( cost , surplus [ - 1 ] ) <NEWLINE> cost -= take <NEWLINE> surplus [ - 1 ] -= take <NEWLINE> <NL> if not taken : <NEWLINE> <INDENT> taken = True <NEWLINE> cnt += 1 <NEWLINE> <NL> <DEDENT> if surplus [ - 1 ] == 0 : <NEWLINE> <INDENT> surplus . pop ( ) <NEWLINE> taken = False <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
import numpy as np <NEWLINE> from numba import njit <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> a = np . array ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> b = np . array ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> @ njit <NEWLINE> def func ( ) : <NEWLINE> <INDENT> if np . all ( a >= b ) : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> elif np . sum ( a ) < np . sum ( b ) : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> temp_a = a [ a - b < 0 ] <NEWLINE> temp_b = b [ a - b < 0 ] <NEWLINE> sum_a = np . sum ( temp_a ) <NEWLINE> sum_b = np . sum ( temp_b ) <NEWLINE> ans = len ( temp_a ) <NEWLINE> <NL> if sum_a >= sum_b : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> aa = a [ a - b >= 0 ] <NEWLINE> bb = b [ a - b >= 0 ] <NEWLINE> for _ in range ( n - ans ) : <NEWLINE> <INDENT> index = np . argmax ( aa - bb ) <NEWLINE> sum_a += aa [ index ] <NEWLINE> sum_b += bb [ index ] <NEWLINE> ans += 1 <NEWLINE> if sum_a >= sum_b : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> aa [ index ] = 0 <NEWLINE> bb [ index ] = 0 <NEWLINE> continue <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> func ( ) <NEWLINE>
N = input ( ) <NEWLINE> H = input ( ) <NEWLINE> W = input ( ) <NEWLINE> <NL> print ( ( N - W + 1 ) * ( N - H + 1 ) ) <NEWLINE>
class UnionFind ( ) : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . n = n <NEWLINE> self . parents = [ - 1 ] * n <NEWLINE> <NL> <DEDENT> def find ( self , x ) : <NEWLINE> <INDENT> if self . parents [ x ] < 0 : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . parents [ x ] = self . find ( self . parents [ x ] ) <NEWLINE> return self . parents [ x ] <NEWLINE> <NL> <DEDENT> <DEDENT> def union ( self , x , y ) : <NEWLINE> <INDENT> x = self . find ( x ) <NEWLINE> y = self . find ( y ) <NEWLINE> <NL> if x == y : <NEWLINE> <INDENT> return <NEWLINE> <NL> <DEDENT> if self . parents [ x ] > self . parents [ y ] : <NEWLINE> <INDENT> x , y = y , x <NEWLINE> <NL> <DEDENT> self . parents [ x ] += self . parents [ y ] <NEWLINE> self . parents [ y ] = x <NEWLINE> <NL> <DEDENT> def size ( self , x ) : <NEWLINE> <INDENT> return - self . parents [ self . find ( x ) ] <NEWLINE> <NL> <DEDENT> def same ( self , x , y ) : <NEWLINE> <INDENT> return self . find ( x ) == self . find ( y ) <NEWLINE> <NL> <DEDENT> def members ( self , x ) : <NEWLINE> <INDENT> root = self . find ( x ) <NEWLINE> return [ i for i in range ( self . n ) if self . find ( i ) == root ] <NEWLINE> <NL> <DEDENT> def roots ( self ) : <NEWLINE> <INDENT> return [ i for i , x in enumerate ( self . parents ) if x < 0 ] <NEWLINE> <NL> <DEDENT> def group_count ( self ) : <NEWLINE> <INDENT> return len ( self . roots ( ) ) <NEWLINE> <NL> <DEDENT> def all_group_members ( self ) : <NEWLINE> <INDENT> return { r : self . members ( r ) for r in self . roots ( ) } <NEWLINE> <NL> <DEDENT> def __str__ ( self ) : <NEWLINE> <INDENT> return <STRING> . join ( <STRING> . format ( r , self . members ( r ) ) for r in self . roots ( ) ) <NEWLINE> <NL> <NL> <NL> <DEDENT> <DEDENT> def calc ( i , j ) : <NEWLINE> <INDENT> return i * w + j <NEWLINE> <DEDENT> def calc_inv ( x ) : <NEWLINE> <INDENT> return x // w , x % w <NEWLINE> <DEDENT> def judge ( x , y ) : <NEWLINE> <INDENT> i0 , j0 = calc_inv ( x ) <NEWLINE> i1 , j1 = calc_inv ( y ) <NEWLINE> if s [ i0 ] [ j0 ] != s [ i1 ] [ j1 ] : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> return False <NEWLINE> <NL> <NL> <DEDENT> h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> s = [ [ ( i == <STRING> ) * 1 for i in list ( input ( ) ) ] for _ in range ( h ) ] <NEWLINE> uf = UnionFind ( h * w ) <NEWLINE> <NL> for i in range ( h ) : <NEWLINE> <INDENT> for j in range ( w ) : <NEWLINE> <INDENT> now = calc ( i , j ) <NEWLINE> nxt = calc ( i + 1 , j ) <NEWLINE> if i + 1 < h : <NEWLINE> <INDENT> if judge ( now , nxt ) : <NEWLINE> <INDENT> uf . union ( now , nxt ) <NEWLINE> <DEDENT> <DEDENT> nxt = calc ( i , j + 1 ) <NEWLINE> if j + 1 < w : <NEWLINE> <INDENT> if judge ( now , nxt ) : <NEWLINE> <INDENT> uf . union ( now , nxt ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> cnt = [ [ 0 , 0 ] for _ in range ( h * w ) ] <NEWLINE> ind = 0 <NEWLINE> for l in uf . all_group_members ( ) . values ( ) : <NEWLINE> <INDENT> for x in l : <NEWLINE> <INDENT> i , j = calc_inv ( x ) <NEWLINE> if s [ i ] [ j ] : <NEWLINE> <INDENT> cnt [ ind ] [ 0 ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cnt [ ind ] [ 1 ] += 1 <NEWLINE> <DEDENT> <DEDENT> ind += 1 <NEWLINE> <DEDENT> ans = 0 <NEWLINE> for i in range ( ind ) : <NEWLINE> <INDENT> ans += cnt [ i ] [ 0 ] * cnt [ i ] [ 1 ] <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
N , H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( ( N - H + 1 ) * ( N - W + 1 ) ) <NEWLINE>
7 <NEWLINE> 5 15 <NEWLINE> 1 10 16 2 7 20 12 <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> P = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = len ( filter ( lambda x : x <= A , P ) ) <NEWLINE> b = len ( filter ( lambda x : A < x <= B , P ) ) <NEWLINE> c = len ( filter ( lambda x : B < x , P ) ) <NEWLINE> print ( min ( a , b , c ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) <NEWLINE> c = [ 0 ] * 3 <NEWLINE> for i in p : <NEWLINE> <INDENT> if i <= a : <NEWLINE> <INDENT> c [ 0 ] += 1 <NEWLINE> <DEDENT> elif i > b : <NEWLINE> <INDENT> c [ 2 ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> c [ 1 ] += 1 <NEWLINE> <DEDENT> <DEDENT> print ( min ( c ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c = [ ] <NEWLINE> d = [ ] <NEWLINE> e = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if p [ i ] <= A : <NEWLINE> <INDENT> c . append ( p [ i ] ) <NEWLINE> <DEDENT> if A + 1 <= p [ i ] <= B : <NEWLINE> <INDENT> d . append ( p [ i ] ) <NEWLINE> <DEDENT> if B + 1 <= p [ i ] : <NEWLINE> <INDENT> e . append ( p [ i ] ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> print ( min ( len ( c ) , len ( d ) , len ( e ) ) ) ) <NEWLINE>
n , a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> * p , = map ( int , input ( ) . split ( ) ) <NEWLINE> mn , md , mx = 0 , 0 , 0 <NEWLINE> for pi in p : <NEWLINE> <INDENT> if pi <= a : <NEWLINE> <INDENT> mn += 1 <NEWLINE> <DEDENT> elif pi <= b : <NEWLINE> <INDENT> md += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> mx += 1 <NEWLINE> <DEDENT> <DEDENT> print ( min ( mn , md , mx ) ) <NEWLINE>
int pxcount , pycount , pzcount = 0 <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in p : <NEWLINE> <INDENT> if i <= a : <NEWLINE> <INDENT> pxcount = pxcount + 1 <NEWLINE> <DEDENT> <DEDENT> for i in p : <NEWLINE> <INDENT> if a + 1 <= i and i <= b : <NEWLINE> <INDENT> pycount = pycount + 1 <NEWLINE> <DEDENT> <DEDENT> for i in p : <NEWLINE> <INDENT> if b + 1 <= i : <NEWLINE> <INDENT> pzcount = pzcount + 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( min ( pxcount , pycount , pzcount ) ) <NEWLINE>
def chmin ( a , b ) : <NEWLINE> <INDENT> if a > b : <NEWLINE> <INDENT> return b <NEWLINE> <DEDENT> return a <NEWLINE> <COMMENT> <NL> <DEDENT> def resolve ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> dp = [ 10 ** 10 ] * n <NEWLINE> dp [ 0 ] = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> dp [ i + 1 ] = chmin ( dp [ i + 1 ] , dp [ i ] + abs ( h [ i ] - h [ i + 1 ] ) ) <NEWLINE> if i < n - 2 : <NEWLINE> <INDENT> dp [ i + 2 ] = chmin ( dp [ i + 2 ] , dp [ i ] + abs ( h [ i ] - h [ i + 2 ] ) ) <NEWLINE> <DEDENT> <DEDENT> print ( dp [ - 1 ] ) <NEWLINE> <DEDENT> resolve ( ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> hs = np . array ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> i = 0 <NEWLINE> total_cost = 0 <NEWLINE> <NL> a = np . zeros ( N , int ) <NEWLINE> a [ 0 ] = 0 <NEWLINE> a [ 1 ] = abs ( hs [ 1 ] - hs [ 0 ] ) <NEWLINE> for i in range ( 2 , N ) : <NEWLINE> <INDENT> a [ i ] = min ( a [ max ( i - 2 , 0 ) ] + abs ( hs [ i ] - hs [ max ( i - 2 , 0 ) ] ) , <NEWLINE> <INDENT> a [ max ( i - 1 , 0 ) ] + abs ( hs [ i ] - hs [ max ( i - 1 , 0 ) ] ) ) <NEWLINE> <DEDENT> <DEDENT> print ( a [ - 1 ] ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> inf = - 1 <NEWLINE> dp = [ 0 ] + [ inf ] * N <NEWLINE> <NL> for i in range ( 1 , N ) : <NEWLINE> <INDENT> dp [ 1 ] = abs ( h [ 1 ] - h [ 0 ] ) <NEWLINE> else : <NEWLINE> <INDENT> dp [ i ] = min ( dp [ i - 1 ] + abs ( h [ i ] - h [ i - 1 ] ) , dp [ i - 2 ] + abs ( h [ i ] - h [ i - 2 ] ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( dp [ N - 1 ] ) <NEWLINE>
def frogOne ( N , arr ) : <NEWLINE> <INDENT> dparr = [ - 1 for i in range ( N ) ] <NEWLINE> dparr [ 0 ] = 0 <NEWLINE> dparr [ 1 ] = abs ( arr [ 0 ] - arr [ 1 ] ) <NEWLINE> for num in range ( 2 , N ) : <NEWLINE> <INDENT> dparr [ num ] = min ( dparr [ num - 2 ] + abs ( arr [ num ] - arr [ num - 2 ] ) , dparr [ num - 1 ] + abs ( arr [ num ] - arr [ num - 1 ] ) ) <NEWLINE> <DEDENT> return dparr [ - 1 ] <NEWLINE> <NL> <NL> if __name__ == <STRING> : <NEWLINE> N = int ( input ( ) ) <NEWLINE> arr = list ( map ( int , input ( ) . rstrip ( ) . split ( ) ) ) <NEWLINE> print ( frogOne ( N , arr ) ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> dp = [ 0 , abs ( h [ 1 ] - [ 0 ] ) ] <NEWLINE> <NL> for i in range ( 2 , n ) : <NEWLINE> <INDENT> dp . append ( min ( dp [ i - 1 ] + abs ( h [ i ] - h [ i + 1 ] ) , dp [ i ] + abs ( h [ i ] - h [ i + 2 ] ) ) ) <NEWLINE> <NL> <DEDENT> print ( dp [ - 1 ] ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> h = list ( int , input ( ) . split ( ) ) <NEWLINE> inf = float ( <STRING> ) <NEWLINE> dp = [ inf for i in range ( n ) ] <NEWLINE> dp [ 0 ] = 0 <NEWLINE> dp [ 1 ] = h [ 1 ] <NEWLINE> for i in range ( 2 , n ) : <NEWLINE> <INDENT> dp [ i ] = min ( dp [ i - 1 ] , dp [ i - 2 ] ) + h [ i ] <NEWLINE> <NL> <DEDENT> print ( dp [ - 1 ] ) <NEWLINE>
from math import inf <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> costs = [ inf ] * n <NEWLINE> costs [ 0 ] = 0 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> for j in ( i + 1 , i + 2 ) : <NEWLINE> <INDENT> if j < n : <NEWLINE> <INDENT> costs [ j ] = min ( costs [ j ] , costs [ i ] + abs ( h [ i ] - h [ j ] ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( c [ - 1 ] ) <NEWLINE>
return True <NEWLINE>
n = int ( input ( ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> dp = [ 0 , abs ( h [ 1 ] - [ 0 ] ) ] <NEWLINE> <NL> for i in range ( 2 , n ) : <NEWLINE> <INDENT> dp . append ( min ( dp [ i - 1 ] + abs ( h [ i ] - h [ i + 1 ] ) , dp [ i ] + abs ( h [ i ] - h [ i + 2 ] ) ) ) <NEWLINE> <NL> <DEDENT> print ( dp [ - 1 ] ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> INF = 10 ** 9 <NEWLINE> dp = [ 0 ] + [ INF ] * N <NEWLINE> <NL> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> if i == 1 : <NEWLINE> <INDENT> dp [ 1 ] = abs ( A [ 1 ] - A [ 0 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dp [ i ] = min ( dp [ i - 1 ] + abs ( A [ i ] - A [ i - 1 ] ) , dp [ i - 2 ] + abs ( A [ i ] - A [ i - 2 ] ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( dp [ N ] ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> arr = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> vis [ 0 ] = 0 <NEWLINE> if n < 2 : <NEWLINE> <INDENT> print ( vis [ 0 ] ) <NEWLINE> <DEDENT> vis [ 1 ] = abs ( arr [ 0 ] - arr [ 1 ] ) <NEWLINE> for i in range ( 2 , n ) : <NEWLINE> <INDENT> step_1 = abs ( arr [ i - 1 ] - arr [ i - 2 ] ) + vis [ i - 1 ] <NEWLINE> step_2 = abs ( arr [ i - 1 ] - arr [ i - 3 ] ) + vis [ i - 2 ] <NEWLINE> vis [ i ] = min ( step_1 , step_2 ) <NEWLINE> <DEDENT> print ( vis [ i ] ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> h = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> dp = [ ] <NEWLINE> dp1 = 0 <NEWLINE> dp2 = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> dp . append ( 0 ) <NEWLINE> continue <NEWLINE> <NL> <DEDENT> if i == 1 : <NEWLINE> <INDENT> dp . append ( abs ( h [ 0 ] - h [ 1 ] ) ) <NEWLINE> continue <NEWLINE> <NL> <DEDENT> dp1 = dp [ i - 1 ] + abs ( h [ i ] - h [ i - 1 ] ) <NEWLINE> dp2 = dp [ i - 2 ] + abs ( h [ i ] - h [ i - 2 ] ) <NEWLINE> <NL> if dp1 < dp2 : <NEWLINE> <INDENT> dp . append ( dp1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dp . append ( dp2 ) <NEWLINE> <DEDENT> <DEDENT> return dp [ - 1 ] <NEWLINE>
N = int ( input ( ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> cost = [ 1000000 ] * N <NEWLINE> cost [ 0 ] = 0 <NEWLINE> cost [ 1 ] = abs ( h ( [ 1 ] - h [ 0 ] ) <NEWLINE> for i in range ( 2 , N ) : <NEWLINE> <INDENT> cost [ i ] = min ( ( abs ( h [ i - 1 ] - h [ i ] ) + cost [ i - 1 ] ) , cost [ i ] ) <NEWLINE> cost [ i ] = min ( ( abs ( h [ i - 2 ] - h [ i ] ) + cost [ i - 2 ] ) , cost [ i ] ) <NEWLINE> <DEDENT> print ( cost [ - 1 ] ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = [ int ( s ) for s in input ( ) . split ( ) ] <NEWLINE> b = [ 0 ] * n <NEWLINE> b [ 1 ] = abs ( a [ 0 ] - a [ 1 ] ) <NEWLINE> for i in range ( 2 , n ) : <NEWLINE> <INDENT> b [ i ] = min ( b [ i - 1 ] + abs ( a [ i ] - a [ i - 1 ] ) , b [ i - 2 ] + as ( a [ i ] - a [ i - 2 ] ) ) <NEWLINE> <DEDENT> print ( b [ n - 1 ] ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> dp = [ ] <NEWLINE> dp [ 0 ] = 0 <NEWLINE> dp [ 1 ] = abs ( h [ 1 ] - h [ 0 ] ) <NEWLINE> <NL> for i in range ( 2 , N ) : <NEWLINE> <INDENT> t1 = dp [ i - 2 ] + abs ( h [ i ] - h [ i - 2 ] ) <NEWLINE> t2 = dp [ i - 1 ] + abs ( h [ i ] - h [ i - 1 ] ) <NEWLINE> dp [ i ] = min ( t1 , t2 ) <NEWLINE> <NL> <NL> <NL> <DEDENT> print ( dp [ N - 1 ] ) <NEWLINE>
<COMMENT> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> h . append ( INF ) <NEWLINE> h . append ( INF ) <NEWLINE> <NL> INF = 1 << 60 <NEWLINE> dp = [ INF ] * 100010 <NEWLINE> <NL> dp [ 0 ] = 0 <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> dp [ i + 1 ] = min ( dp [ i + 1 ] , dp [ i ] + abs ( h [ i ] - h [ i + 1 ] ) ) <NEWLINE> dp [ i + 2 ] = min ( dp [ i + 2 ] , dp [ i ] + abs ( h [ i ] - h [ i + 2 ] ) ) <NEWLINE> <NL> <DEDENT> print ( dp [ N - 1 ] ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> h = [ None ] + list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> <NL> dp = [ None for _ in range ( n + 1 ) ] <NEWLINE> for k in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if k == 1 : <NEWLINE> <INDENT> dp [ k ] = 0 <NEWLINE> <DEDENT> elif k == 2 : <NEWLINE> <INDENT> dp [ k ] = abs ( h [ 2 ] - h [ 1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dp [ k ] = min ( <NEWLINE> <INDENT> dp [ k - 1 ] + abs ( h [ k ] - h [ k - 1 ] ) , <NEWLINE> dp [ k - 2 ] + abs ( h [ k ] - h [ k - 2 ] ) <NEWLINE> <DEDENT> ) <NEWLINE> <DEDENT> <DEDENT> print ( dp [ k ] ) <NEWLINE>
def cmin ( a , b ) : <NEWLINE> <INDENT> if a > b : <NEWLINE> <INDENT> return b <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return a <NEWLINE> <NL> <DEDENT> <DEDENT> N = int ( input ( ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> dp [ ] = [ 0 ] + [ float ( <STRING> ) ] * ( N - 1 ) <NEWLINE> for i in range ( N - 2 ) : <NEWLINE> <INDENT> dp [ i ] = cmin ( dp [ i ] , dp [ i - 1 ] + abs ( h [ i - 1 ] - h [ i ] ) ) <NEWLINE> <DEDENT> print ( dp [ - 1 ] ) <NEWLINE>
N = input ( ) <NEWLINE> height = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> dp = [ 0 ] * N <NEWLINE> <NL> for i in range ( 1 , N ) : <NEWLINE> <INDENT> if i <= 2 : <NEWLINE> <INDENT> dp [ i ] = abs ( height [ i ] - height [ 0 ] ) <NEWLINE> <DEDENT> if dp [ i - 1 ] < dp [ i - 2 ] : <NEWLINE> <INDENT> dp [ i ] = dp [ i - 1 ] + abs ( height [ i ] - height [ i - 1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dp [ i ] = dp [ i - 2 ] + abs ( height [ i ] - height [ i - 2 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( dp [ N - 1 ] ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> rec = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> s = [ rec [ 0 ] , abs ( rec [ 1 ] - rec [ 0 ] ) ] <NEWLINE> for i in range ( 2 , n ) : <NEWLINE> <INDENT> total2 = abs ( rec [ i ] - rec [ i - 2 ] ) + s [ i - 2 ] <NEWLINE> total1 = abs ( rec [ i ] - rec [ i - 1 ] ) + s [ i - 1 ] <NEWLINE> s . append ( min ( total2 , total ) ) <NEWLINE> <DEDENT> print ( s [ - 1 ] ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = input ( ) . split ( ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> s [ i ] = int ( s [ i ] ) <NEWLINE> <DEDENT> memo = [ 0 for i in range ( n + 1 ) ] <NEWLINE> memo [ 0 ] = 0 <NEWLINE> memo [ 1 ] = 0 <NEWLINE> for i in range ( 2 , n + 1 ) : <NEWLINE> <INDENT> memo [ i ] = min ( memo [ i - 1 ] + abs ( s [ i ] - s [ i - 1 ] ) , memo [ i - 2 ] + abs ( s [ i ] - s [ i - 2 ] ) ) <NEWLINE> <DEDENT> print ( memo [ n ] ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> arr = [ int ( i ) for i in list ( input ( ) . split ( ) ) ] <NEWLINE> def helper ( arr ) : <NEWLINE> <INDENT> if len ( arr ) <= 1 : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> if len ( arr ) == 2 : <NEWLINE> <INDENT> return abs ( arr [ 1 ] - arr [ 0 ] ) <NEWLINE> <DEDENT> way1 = abs ( arr [ - 1 ] - arr [ - 2 ] ) + helper ( arr [ : - 1 ] ) <NEWLINE> way2 = abs ( arr [ - 1 ] - arr [ - 3 ] ) + helper ( arr [ : - 2 ] ) <NEWLINE> return min ( way1 , way2 ) <NEWLINE> <NL> <DEDENT> if n == 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> elif n == 2 : <NEWLINE> <INDENT> print ( abs ( arr [ 1 ] - arr [ 0 ] ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dp [ 0 ] = 0 <NEWLINE> dp [ 1 ] = abs ( arr [ 1 ] - arr [ 0 ] ) <NEWLINE> dp = [ 0 ] * n <NEWLINE> for i in range ( 2 , len ( arr ) ) : <NEWLINE> <INDENT> dp [ i ] = min ( dp [ i - 1 ] + abs ( arr [ i ] - arr [ i - 1 ] ) , dp [ i - 2 ] + abs ( arr [ i ] - arr [ i - 2 ] ) ) <NEWLINE> <DEDENT> print ( dp [ n - 1 ] ) <NEWLINE> <COMMENT> <NL> <NEWLINE> <DEDENT>
sys . setrecursionlimit ( 200000 ) <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> dp = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> dp . append ( - 1 ) <NEWLINE> <NL> <DEDENT> def flog ( m ) : <NEWLINE> <INDENT> if dp [ m ] != - 1 : <NEWLINE> <INDENT> return dp [ m ] <NEWLINE> <DEDENT> if m == 0 : <NEWLINE> <INDENT> dp [ m ] = 0 <NEWLINE> return 0 <NEWLINE> <DEDENT> if m == 1 : <NEWLINE> <INDENT> dp [ m ] = abs ( h [ 0 ] - h [ 1 ] ) <NEWLINE> return dp [ m ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dp [ m ] = min ( flog ( m - 1 ) + abs ( h [ m - 1 ] - h [ m ] ) , flog ( m - 2 ) + abs ( h [ m - 2 ] - h [ m ] ) ) <NEWLINE> return dp [ m ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( flog ( n - 1 ) ) <NEWLINE>
<INDENT> n = int ( input ( ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> dp = [ 0 ] * ( len ( h ) ) <NEWLINE> dp [ 1 ] += abs ( h [ 1 ] - h [ 0 ] ) <NEWLINE> for i in range ( 2 , len ( h ) ) : <NEWLINE> <INDENT> dp [ i ] = min ( <NEWLINE> <INDENT> abs ( h [ i ] - h [ i - 1 ] ) + dp [ i - 1 ] , <NEWLINE> abs ( h [ i ] - h [ i - 2 ] ) + dp [ i - 2 ] <NEWLINE> ) <NEWLINE> <DEDENT> <DEDENT> print ( dp [ - 1 ] ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> dp = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> dp . append ( int ( 0 ) ) <NEWLINE> <DEDENT> dp [ 0 ] = 0 <NEWLINE> dp [ 1 ] = abs ( h [ 0 ] - h [ 1 ] ) <NEWLINE> <NL> for j in range ( 2 , n ) : <NEWLINE> <INDENT> dp [ j ] = min ( flog ( j - 1 ) + abs ( h [ j - 1 ] - h [ j ] ) , flog ( j - 2 ) + abs ( h [ j - 2 ] - h [ j ] ) ) <NEWLINE> <NL> <DEDENT> print ( dp [ n - 1 ] ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> arr = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> cost = [ 0 ] * n <NEWLINE> cost [ 0 ] = 0 <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> if i > 1 : <NEWLINE> <INDENT> cost [ i ] = min ( abs ( arr [ i ] - arr [ i - 2 ] ) + cost [ i - 2 ] , abs ( arr [ i ] - arr [ i - 1 ] ) + cost [ i - 1 ] ) <NEWLINE> <DEDENT> elif i == 1 : <NEWLINE> <INDENT> cost [ i ] = minabs ( arr [ i ] - arr [ i - 1 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( cost [ - 1 ] ) <NEWLINE>
def findmin ( arr , n ) : <NEWLINE> <INDENT> dp = [ 0 ] * n <NEWLINE> dp [ 1 ] = abs ( arr [ 0 ] - arr [ 1 ] ) <NEWLINE> for i in range ( 2 , n ) : <NEWLINE> <INDENT> dp [ i ] = min ( dp [ i - 1 ] + abs ( arr [ i - 1 ] - arr [ i ] ) , dp [ i - 2 ] + abs ( arr [ i - 2 ] - arr [ i ] ) ) <NEWLINE> <DEDENT> return dp [ - 1 ] <NEWLINE> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> arr = list ( map ( int , input ( ) . split ( ) ) <NEWLINE> print ( findmin ( arr , n ) ) <NEWLINE>
<NL> <NL> def solution ( h ) : <NEWLINE> <INDENT> n = len ( h ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( i + 1 , i + 3 ) : <NEWLINE> <INDENT> if j < n : <NEWLINE> <INDENT> dp [ j ] = min ( dp [ j ] , dp [ i ] + abs ( h [ i ] - h [ j ] ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return dp [ n - 1 ] <NEWLINE> <NL> <DEDENT> N = int ( input ( ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> res = solution ( h ) <NEWLINE> print ( res ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> <NL> dp = [ 1000000 for i in range ( N + 10 ) ] <NEWLINE> dp [ 1 ] = 0 <NEWLINE> <NL> for i in range ( 1 , N - 1 ) : <NEWLINE> <INDENT> dp [ i + 1 ] = min ( dp [ i + 1 ] , abs ( h [ i + 1 ] - h [ i ] ) + dp [ i ] ) <NEWLINE> dp [ i + 2 ] = min ( dp [ i + 2 ] , abs ( h [ i + 2 ] - h [ i ] ) + dp [ i ] ) <NEWLINE> <NL> <DEDENT> print ( dp [ N ] ) <NEWLINE>
import sys <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> dp = [ sys . maxsize ] * n <NEWLINE> dp [ 0 ] = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> for j in ( i + 1 , i + 2 ) : <NEWLINE> <INDENT> if j < n : <NEWLINE> <INDENT> dp [ j ] = min ( dp [ j ] , dp [ i ] + abs ( dp [ i ] - dp [ j ] ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( dp [ n - 1 ] , end = <STRING> ) <NEWLINE>
def sol ( lis ) : <NEWLINE> <INDENT> if len ( lis ) <= 2 : <NEWLINE> <INDENT> return abs ( lis [ 0 ] - lis [ 1 ] ) <NEWLINE> <DEDENT> costs = [ 0 , abs ( lis [ 0 ] - lis [ 1 ] ) ] <NEWLINE> for i in range ( 2 , len ( lis ) ) : <NEWLINE> <INDENT> x = abs ( lis [ i ] - lis [ i - 1 ] ) <NEWLINE> y = abs ( lis [ i ] - lis [ i - 2 ] ) <NEWLINE> costs . append ( min ( x + costs [ - 1 ] ) , min ( x + costs [ - 2 ] ) ) <NEWLINE> <DEDENT> print ( costs ) <NEWLINE> return costs [ - 1 ] <NEWLINE> <DEDENT> input ( ) <NEWLINE> lis = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> print ( sol ( lis ) ) <NEWLINE>
import math <NEWLINE> import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> number , jump = input ( ) . rstrip ( ) . split ( ) <NEWLINE> number = int ( number ) <NEWLINE> jump = int ( jump ) <NEWLINE> scaffolding = input ( ) . rstrip ( ) . split ( ) <NEWLINE> scaffolding = list ( map ( int , scaffolding ) ) <NEWLINE> res = [ math . inf * number ] <NEWLINE> res [ 0 ] = 0 <NEWLINE> test = [ math . inf * number ] <NEWLINE> test [ 0 ] = 0 <NEWLINE> <NL> for i in range ( number ) : <NEWLINE> <INDENT> for j in range ( 1 , jump + 1 ) : <NEWLINE> <INDENT> if i - j < 0 : break <NEWLINE> cost = abs ( scaffolding [ i ] - scaffolding [ i - j ] ) <NEWLINE> test [ j - 1 ] = res [ i - j ] + cost <NEWLINE> <NL> <DEDENT> res [ i ] = min ( test ) <NEWLINE> <NL> <NL> <DEDENT> print ( res [ number - 1 ] ) <NEWLINE> <NL> <NL>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> S = [ 0 ] * N <NEWLINE> <NL> for i in range ( 1 , N ) : <NEWLINE> <INDENT> S [ i ] = min ( S [ _ ] + abs ( h [ i ] - h [ _ ] ) for range ( max ( 0 , i - K ) , i ) ) <NEWLINE> <NL> <DEDENT> print ( S [ N - 1 ] ) <NEWLINE>
import sys <NEWLINE> <NL> import numba as nb <NEWLINE> <NL> input = sys . stdin . readline <NEWLINE> INF = float ( <STRING> ) <NEWLINE> <NL> <NL> @ nb . njit <NEWLINE> def solve ( N , K , h ) : <NEWLINE> <INDENT> dp = [ 0 ] * N <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> min_cost = INF <NEWLINE> for k in range ( 1 , min ( K + 1 , i + 1 ) ) : <NEWLINE> <INDENT> cost = dp [ i - k ] + abs ( h [ i ] - h [ i - k ] ) <NEWLINE> if cost < min_cost : <NEWLINE> <INDENT> min_cost = cost <NEWLINE> <DEDENT> <DEDENT> dp [ i ] = min_cost <NEWLINE> <DEDENT> return dp [ - 1 ] <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> h = tuple ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = solve ( N , K , h ) <NEWLINE> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> H = list ( map ( int , input ( ) . split ( ) for _ in range ( N ) ) ) <NEWLINE> <NL> import numpy as np <NEWLINE> dp = np . full ( N + K , 1e+14 , dtype = np . int64 ) <NEWLINE> dp [ 0 ] = 0 <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> dp [ i : i + K ] = np . minimum ( dp [ i : i + K ] , np . abs ( H [ i - 1 ] - H [ i : i + K ] ) + dp [ i - 1 ] ) <NEWLINE> <NL> <DEDENT> print ( dp [ N - 1 ] ) <COMMENT> <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> DP = [ 10 ** 10 for _ in range ( N ) ] <NEWLINE> DP [ 0 ] = 0 <NEWLINE> DP [ 1 ] = abs ( h [ 0 ] - h [ 1 ] ) <NEWLINE> <NL> for i in range ( 2 , N ) : <NEWLINE> <INDENT> DP [ i ] = min ( [ DP [ k ] + abs ( h [ i ] - h [ k ] ) for k in range ( max ( 0 , i - k ) , i ) ] ) <NEWLINE> <DEDENT> print ( DP [ N - 1 ] ) <NEWLINE> <DEDENT> main ( ) <NEWLINE>
from numba import jit <NEWLINE> import math <NEWLINE> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> S = [ 0 ] * N <NEWLINE> S [ 0 ] = 0 <NEWLINE> <NL> @ jit <NEWLINE> def nya ( S , N ) : <NEWLINE> <INDENT> for i in range ( 1 , N ) : <NEWLINE> <INDENT> value = math . inf <NEWLINE> for step in range ( 1 , K + 1 ) : <NEWLINE> <INDENT> if i - step < 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> value = min ( value , S [ i - step ] + abs ( h [ i ] - h [ i - step ] ) ) <NEWLINE> <DEDENT> S [ i ] = value <NEWLINE> <DEDENT> return S <NEWLINE> <NL> <DEDENT> S = nya ( S , N ) <NEWLINE> print ( S [ N - 1 ] ) <NEWLINE>
import numpy as np <NEWLINE> [ N , K ] = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> h = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> <NL> dp = [ 0 for i in range ( N ) ] <NEWLINE> <NL> for i in range ( 1 , N ) : <NEWLINE> <INDENT> dp [ N - 1 - i ] = dp [ N - i ] + np . abs ( h [ N - i - 1 ] - h [ N - i ] ) <NEWLINE> for j in range ( 2 , np . min ( K + 1 , i + 1 ) ) : <NEWLINE> <INDENT> dp [ N - i - 1 ] = np . min ( dp [ N - i - 1 + j ] + np . abs ( h [ N - i - 1 ] - h [ N - 1 - i + j ] ) , dp [ N - i - 1 ] ) <NEWLINE> <DEDENT> <DEDENT> print ( dp [ 0 ] ) <NEWLINE>
from numba import jit <NEWLINE> @ jit <NEWLINE> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> cost = [ 0 ] <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> wk = [ ] <NEWLINE> for j in range ( 1 , min ( k , i ) + 1 ) : <NEWLINE> <INDENT> wk . append ( cost [ i - j ] + abs ( h [ i ] - h [ i - j ] ) ) <NEWLINE> <DEDENT> cost . append ( min ( wk ) ) <NEWLINE> <DEDENT> print ( cost [ n - 1 ] ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> h_list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> dp_list = [ 0 ] <NEWLINE> for n in range ( 1 , N ) : <NEWLINE> <INDENT> tmp_h = h_list [ n ] <NEWLINE> if n < K : <NEWLINE> <INDENT> lst = [ abs ( tmp_h - h_list [ i ] ) + dp_list [ i ] for i in range ( n ) ] <NEWLINE> else : <NEWLINE> <INDENT> lst = [ abs ( tmp_h - h_list [ n - k ] ) + dp_list [ n - k ] for k in range ( 1 , K + 1 ) ] <NEWLINE> dp_list . append ( min ( lst ) ) <NEWLINE> print ( dp_list [ - 1 ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
from numba import njit , jit <NEWLINE> <NL> @ jit <NEWLINE> def main ( ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <INDENT> kl = [ p for p in range ( 1 , k + 1 ) ] <NEWLINE> dp = [ 10 ** 9 ] * ( n ) <NEWLINE> dp [ 0 ] = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> for j in kl : <NEWLINE> <INDENT> ij = i + j <NEWLINE> if ij < n : <NEWLINE> <INDENT> m = dp [ i ] + abs ( a [ i ] - a [ ij ] ) <NEWLINE> if m < dp [ ij ] : <NEWLINE> <INDENT> dp [ ij ] = m <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( dp [ n - 1 ] ) <NEWLINE> <NL> <DEDENT> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> main ( ) <NEWLINE>
from numba import njit <NEWLINE> @ njit <COMMENT> <NEWLINE> def main ( ) : <NEWLINE> <INDENT> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <COMMENT> <NL> INF = 10 ** 10 <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> dp = [ INF ] * n <NEWLINE> <NL> <COMMENT> <NL> dp [ 0 ] = 0 <NEWLINE> dp [ 1 ] = abs ( h [ 0 ] - h [ 1 ] ) <NEWLINE> <NL> <COMMENT> <NL> for i in range ( 2 , n ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <INDENT> dp [ i ] = min ( dp [ i - j ] + abs ( h [ i - j ] - h [ i ] ) for j in range ( 1 , min ( k , i ) + 1 ) ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> print ( dp [ n - 1 ] ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
from numba import njit <NEWLINE> <NL> <NL> @ njit <NEWLINE> def main ( ) : <NEWLINE> <INDENT> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> dp = [ 10 ** 6 ] * ( N + 1 ) <NEWLINE> dp [ 0 ] = 0 <NEWLINE> <NL> for i in range ( 1 , N ) : <NEWLINE> <INDENT> for j in range ( min ( i , K ) ) : <NEWLINE> <INDENT> dp [ i ] = min ( dp [ i ] , dp [ i - j - 1 ] + abs ( h [ i ] - h [ i - j - 1 ] ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( dp [ N - 1 ] ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> <NL> def main ( n , k , a ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <INDENT> kl = [ p for p in range ( 1 , k + 1 ) ] <NEWLINE> dp = [ 10 ** 9 ] * ( n ) <NEWLINE> dp [ 0 ] = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> for j in kl : <NEWLINE> <INDENT> ij = i + j <NEWLINE> if ij < n : <NEWLINE> <INDENT> m = dp [ i ] + abs ( a [ i ] - a [ ij ] ) <NEWLINE> if m < dp [ ij ] : <NEWLINE> <INDENT> dp [ ij ] = m <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( dp [ n - 1 ] ) <NEWLINE> <NL> <DEDENT> def cc_export ( ) : <NEWLINE> <INDENT> from numba . pycc import CC <NEWLINE> cc = CC ( <STRING> ) <NEWLINE> cc . export ( <STRING> , <STRING> ) ( main ) <NEWLINE> cc . compile ( ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> import sys <NEWLINE> if sys . argv [ - 1 ] == <STRING> : <NEWLINE> <COMMENT> <NL> <INDENT> cc_export ( ) <NEWLINE> exit ( 0 ) <NEWLINE> <DEDENT> from my_module import main <NEWLINE> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = np . array ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> main ( n , k , a ) <NEWLINE> <NL> <NL> <NL> <DEDENT>
import numpy as np <NEWLINE> <NL> N , K = map ( dtype = np . int64 , input ( ) . split ( ) ) <NEWLINE> hs = np . array ( list ( map ( dtype = np . int64 , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> i = 0 <NEWLINE> total_cost = 0 <NEWLINE> <NL> a = np . zeros ( N , dtype = np . int64 ) <NEWLINE> a [ 0 ] = 0 <NEWLINE> a [ 1 ] = abs ( hs [ 1 ] - hs [ 0 ] ) <NEWLINE> <NL> for i in range ( 2 , N ) : <NEWLINE> <INDENT> bmin = float ( <STRING> ) <NEWLINE> for j in range ( max ( i - K , 0 ) , i ) : <NEWLINE> <INDENT> bmin = np . min ( bmin , a [ j ] + np . abs ( hs [ i ] - hs [ j ] ) ) <NEWLINE> <DEDENT> a [ i ] = bmin <NEWLINE> <DEDENT> print ( a [ - 1 ] ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> final = [ 0 ] * n <NEWLINE> if k >= n : <NEWLINE> <INDENT> print ( abs ( l [ n - 1 ] - l [ 0 ] ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> final [ i ] = abs ( l [ i ] - l [ 0 ] ) <NEWLINE> <NL> <DEDENT> for i in range ( k + 1 , n ) : <NEWLINE> <NL> <INDENT> li = [ abs ( h [ i ] - h [ ik ] ) + dp [ ik ] for ik in range ( i - 1 , i - k - 1 , - 1 ) ] <NEWLINE> final [ i ] = min ( li ) <NEWLINE> <DEDENT> print ( final [ - 1 ] ) <NEWLINE> <DEDENT>
import math <NEWLINE> from numba import jit <NEWLINE> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> s = [ 0 ] * n <NEWLINE> @ jit <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> total = math . inf <NEWLINE> for j in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> if i - j < 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> total = min ( total , abs ( h [ i ] - h [ i - j ] ) + s [ i - j ] ) <NEWLINE> <DEDENT> s [ i ] = ( total ) <NEWLINE> <DEDENT> print ( s [ - 1 ] ) <NEWLINE>
n = int ( input ( ) <NEWLINE> arr = [ [ int ( i ) for i in list ( input ( ) . split ( ) ) ] for j in range ( n ) ] <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> arr [ i ] [ 0 ] += max ( arr [ i - 1 ] [ 1 ] , arr [ i - 1 ] [ 2 ] ) <NEWLINE> arr [ i ] [ 2 ] += max ( arr [ i - 1 ] [ 1 ] , arr [ i - 1 ] [ 0 ] ) <NEWLINE> arr [ i ] [ 1 ] += max ( arr [ i - 1 ] [ 0 ] , arr [ i - 1 ] [ 2 ] ) <NEWLINE> <DEDENT> print ( max ( arr [ n - 1 ] ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> sys . setrecursionlimit ( 1000000000 ) <NEWLINE> <NL> ABC = [ ] <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> ABC . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <DEDENT> from functools import lru_cache <NEWLINE> @ lru_cache ( maxsize = None ) <NEWLINE> def dynam ( n ) : <NEWLINE> <INDENT> if n > 1 : <NEWLINE> <INDENT> a = max ( dynam ( n - 1 ) [ 1 ] + ABC [ n - 1 ] [ 0 ] , <NEWLINE> <INDENT> dynam ( n - 1 ) [ 2 ] + ABC [ n - 1 ] [ 0 ] ) <NEWLINE> <DEDENT> b = max ( dynam ( n - 1 ) [ 0 ] + ABC [ n - 1 ] [ 1 ] , <NEWLINE> <INDENT> dynam ( n - 1 ) [ 2 ] + ABC [ n - 1 ] [ 1 ] ) <NEWLINE> <DEDENT> c = max ( dynam ( n - 1 ) [ 0 ] + ABC [ n - 1 ] [ 2 ] , <NEWLINE> <INDENT> dynam ( n - 1 ) [ 1 ] + ABC [ n - 1 ] [ 2 ] ) <NEWLINE> <DEDENT> return ( a , b , c ) <NEWLINE> <DEDENT> return tuple ( ABC [ 0 ] ) <NEWLINE> <DEDENT> print ( max ( dynam ( N ) ) ) <NEWLINE>
<COMMENT> <NL> import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = [ ] <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> A . append ( ( a , b , c ) ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> INF = 10 ** 10 <NEWLINE> <NL> <COMMENT> <NL> dp = [ [ 0 ] * 3 for _ in range ( 100010 ) ] <NEWLINE> <NL> <COMMENT> <NL> for i in range ( 5 ) : <NEWLINE> <INDENT> for j in range ( 3 ) : <NEWLINE> <INDENT> dp [ i ] [ j ] = 0 <COMMENT> <NEWLINE> <NL> <DEDENT> <DEDENT> def rec ( v ) : <NEWLINE> <COMMENT> <NL> <INDENT> for w in range ( 100010 ) : <NEWLINE> <INDENT> print ( v , w ) <NEWLINE> if dp [ v ] [ w ] > 0 : <NEWLINE> <NL> <INDENT> return dp [ v ] <NEWLINE> <DEDENT> if v == 0 : <NEWLINE> <INDENT> dp [ v ] [ w ] = 0 <NEWLINE> <NL> return dp [ v ] <NEWLINE> <DEDENT> res = 0 <NEWLINE> <COMMENT> <NL> for k in range ( 3 ) : <NEWLINE> <INDENT> if w == k : <NEWLINE> <NL> <INDENT> continue <NEWLINE> <DEDENT> res = max ( res , rec ( v - 1 ) [ k ] + A [ v - 1 ] [ w ] ) <COMMENT> <NEWLINE> dp [ v ] [ w ] = res <COMMENT> <NEWLINE> print ( v , w , k , dp [ v ] ) <NEWLINE> <DEDENT> <DEDENT> return dp [ v ] <NEWLINE> <NL> <DEDENT> rec ( N ) <NEWLINE> ans = max ( dp [ N ] ) <NEWLINE> print ( ans ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NEWLINE>
n = int ( input ( ) ) <NEWLINE> abc = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( n ) ] <NEWLINE> <COMMENT> <NL> ABC = [ [ 0 , 0 , 0 ] ] <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> for i in range ( n ) : <NEWLINE> <INDENT> a = abc [ i ] [ 0 ] + max ( ABC [ - 1 ] [ 1 ] , ABC [ - 1 ] [ 2 ] ) <COMMENT> <NEWLINE> b = abc [ i ] [ 1 ] + max ( ABC [ - 1 ] [ 0 ] , ABC [ - 1 ] [ 2 ] ) <COMMENT> <NEWLINE> c = abc [ i ] [ 2 ] + max ( ABC [ - 1 ] [ 0 ] , ABC [ - 1 ] [ 1 ] ) <COMMENT> <NEWLINE> ABC += [ [ a , b , c ] ] <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> print ( max ( ABC [ - 1 ] ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> abc_list = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( N ) ] <NEWLINE> <NL> happy_list = [ [ 0 , 0 , 0 ] ] <COMMENT> <NEWLINE> <COMMENT> <NL> for n in range ( N ) : <NEWLINE> <INDENT> before_happy_a , before_happy_b , before_happy_c = happy_list [ - 1 ] <NEWLINE> a , b , c = abc_list [ n ] <NEWLINE> tmp_happy_a = max ( before_happy_b , before_happy_c ) + a <NEWLINE> tmp_happy_b = max ( before_happy_c , before_happy_a ) + b <NEWLINE> tmp_happy_c = max ( before_happy_a , before_happy_b ) + c <NEWLINE> happy_list . append ( [ tmp_happy_a , tmp_happy_b , tmp_happy_c ] ) <NEWLINE> <NL> <DEDENT> print ( max ( happy_list [ - 1 ] ) ) s <NEWLINE>
<COMMENT> <NL> import warnings <NEWLINE> warnings . filterwarnings ( <STRING> ) <NEWLINE> import pandas as pd <NEWLINE> import numpy as np <NEWLINE> <NL> N = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> h = [ np . array ( list ( map ( int , input ( ) . split ( ) ) ) ) for _ in range ( N ) ] <NEWLINE> <NL> h = h . reshape ( 7 , 3 ) <NEWLINE> <NL> dp = np . array ( [ [ 0 ] * h . shape [ 1 ] ] * h . shape [ 0 ] ) <NEWLINE> dp [ 0 , : ] = h [ 0 , : ] <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> dp [ i , 0 ] = max ( dp [ i - 1 , 1 ] , dp [ i - 1 , 2 ] ) + h [ i , 0 ] <NEWLINE> dp [ i , 1 ] = max ( dp [ i - 1 , 0 ] , dp [ i - 1 , 2 ] ) + h [ i , 1 ] <NEWLINE> dp [ i , 2 ] = max ( dp [ i - 1 , 0 ] , dp [ i - 1 , 1 ] ) + h [ i , 2 ] <NEWLINE> <NL> <DEDENT> print ( max ( dp [ - 1 , ] ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> INF = float ( <STRING> ) <NEWLINE> <NL> h = [ ] <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> h . append ( [ a , b , c ] ) <NEWLINE> <NL> <DEDENT> dp = [ [ 0 for i in range ( 3 ) ] for j in range ( n + 1 ) ] <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> dp [ i ] [ 0 ] = max ( dp [ i - 1 ] [ 1 ] + h [ i - 1 ] [ 0 ] , dp [ i - 1 ] [ 2 ] + h [ i - 1 [ 0 ] ] ) <NEWLINE> dp [ i ] [ 1 ] = max ( dp [ i - 1 ] [ 0 ] + h [ i - 1 ] [ 1 ] , dp [ i - 1 ] [ 2 ] + h [ i - 1 [ 1 ] ] ) <NEWLINE> dp [ i ] [ 2 ] = max ( dp [ i - 1 ] [ 0 ] + h [ i - 1 ] [ 2 ] , dp [ i - 1 ] [ 1 ] + h [ i - 1 [ 2 ] ] ) <NEWLINE> <NL> <DEDENT> print ( max ( dp [ n ] [ 0 ] , dp [ n ] [ 1 ] , dp [ n ] [ 2 ] ) ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> dp = [ [ 0 , 0 , 0 ] ] <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> dp . append ( [ <NEWLINE> <INDENT> dp [ i - 1 ] [ 0 ] + max ( b , c ) , <NEWLINE> dp [ i - 1 ] [ 1 ] + max ( a , c ) , <NEWLINE> dp [ i - 1 ] [ 2 ] + max ( a , b ) <NEWLINE> <DEDENT> ] <NEWLINE> <DEDENT> print ( max ( dp [ n ] ) ) <NEWLINE> <DEDENT>
<COMMENT> <NL> N = int ( input ( ) ) <NEWLINE> Max_List = [ ] <NEWLINE> N_List = [ i for i in range ( 3 ) ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> Current_Max_List = [ ] <NEWLINE> Current_List = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if i == 0 : <NEWLINE> <INDENT> Max_List . append ( Current_List ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for j in range ( 3 ) : <NEWLINE> <INDENT> Index_List = np . array ( Max_List [ i - 1 ] ) <NEWLINE> ind = np . ones ( 3 , dtype = bool ) <NEWLINE> ind [ j ] = False <NEWLINE> Current_Max_List . append ( max ( Index_List [ ind ] ) + Current_List [ j ] ) <NEWLINE> <NL> <DEDENT> Max_List . append ( Current_Max_List ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( max ( Max_List [ - 1 ] ) ) <NEWLINE>
<COMMENT> <NL> N = int ( input ( ) ) <NEWLINE> Max_List = [ [ 0 ] * 3 for i in range ( N ) ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> Current_List = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if i == 0 : <NEWLINE> <INDENT> Max_List [ i ] = Current_List <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> Search_List = Max_List [ i - 1 ] <NEWLINE> for j in range ( 3 ) : <NEWLINE> <INDENT> Current_Search_List = Search_List [ 1 : 3 ] <NEWLINE> Max_List [ i ] [ j ] = max ( Current_Search_List ) + Current_List [ j ] <NEWLINE> Search_List . append ( Search_List [ 0 ] ) <NEWLINE> del Search_List [ 0 ] <NEWLINE> <NL> <DEDENT> Max_List [ i ] = Current_Max_List <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> print ( max ( Max_List [ - 1 ] ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> arr = [ ] * N <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> arr . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> <DEDENT> dp = [ 0 , 0 , 0 ] <NEWLINE> for a in arr : <NEWLINE> <INDENT> dp = [ a [ 0 ] + max ( dp [ 1 ] , dp [ 2 ] ) , a [ 1 ] + max ( dp [ 0 ] , dp [ 2 ] ) , a [ 2 ] + max ( dp [ 0 ] , dp [ 1 ] ) ] <NEWLINE> <DEDENT> return max ( dp ) <NEWLINE>
n , W = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> dp = np . zeros ( [ n + 1 , W + 1 ] , dtype = int ) <NEWLINE> <NL> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> w , v = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> dp [ i ] [ : w ] = dp [ i - 1 ] [ : w ] <NEWLINE> dp [ i ] [ w : ] = np . maximum ( dp [ i - 1 ] [ : W - w + 1 ] + v , dp [ i - 1 ] [ w : ] ) <NEWLINE> <DEDENT> print ( np . max ( dp ) ) <NEWLINE>
[ N , W ] = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> wv = [ [ 0 , 0 ] ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> wv . append ( [ int ( x ) for x in input ( ) . split ( ) ] ) <NEWLINE> <DEDENT> dp = np . zeros ( [ N + 1 , W + i ] , dtype = int ) <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> dp [ i ] [ : w ] = dp [ i - 1 ] [ : w ] <NEWLINE> dp [ i ] [ w : ] = max ( dp [ i - 1 ] [ w : ] , dp [ i - 1 ] [ w - wv [ i ] [ 0 ] : ] + wv [ i ] [ 1 ] ) <NEWLINE> <NL> <DEDENT> print ( dp [ N ] [ W ] ) <NEWLINE>
import numpy as np <NEWLINE> N , W = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> dp = np . zeros ( ( N + 1 , W + 1 ) , dtype = np . int64 ) <NEWLINE> <NL> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> w , v = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <INDENT> dp [ i ] = dp [ i - 1 ] <NEWLINE> dp [ i ] [ w : ] = np . maximum ( dp [ i - 1 ] [ : W - w + 1 ] + v , dp [ i - 1 ] [ w : ] ) <NEWLINE> <DEDENT> <DEDENT> print ( np . max ( dp ) ) <NEWLINE>
6 15 <NEWLINE> 6 5 <NEWLINE> 5 6 <NEWLINE> 6 4 <NEWLINE> 6 6 <NEWLINE> 3 5 <NEWLINE> 7 2 <NEWLINE>
import numpy as np <NEWLINE> <NL> N , W = map ( int , input ( ) . split ( ) ) <NEWLINE> w = np . empty ( N ) <NEWLINE> v = np . empty ( N ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> w [ i ] , v [ i ] = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <DEDENT> dp = np . zeros ( W + 1 , dtype = np . int64 ) <NEWLINE> dp [ w [ 0 ] ] = v [ 0 ] <NEWLINE> <NL> for i in range ( 1 , N ) : <NEWLINE> <INDENT> dp [ w [ i ] : ] = np . maximum ( dp [ w [ i ] : ] , dp [ : W - w [ i ] + 1 ] + v [ i ] ) <NEWLINE> <NL> <DEDENT> print ( dp . max ( ) ) <NEWLINE>
import numpy as np <NEWLINE> <NL> N , W = map ( int , input ( ) . split ( ) ) <NEWLINE> knap = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> knap . append ( tuple ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> <DEDENT> s_val = sum ( [ v for w , v in knap ] ) <NEWLINE> <NL> INF = float ( <STRING> ) <NEWLINE> dp = np . full ( s_val + 1 , INF ) <NEWLINE> <NL> for i , ( w , v ) in enumerate ( knap ) : <NEWLINE> <INDENT> dp [ v : ] = np . minimum ( dp [ v : ] , dp [ : - v ] + w ) <NEWLINE> <NL> <DEDENT> print ( max ( [ i for i in range ( s_val + 1 ) if dp [ i ] <= W ] ) ) <NEWLINE>
from sys import stdin , stdout <NEWLINE> import numba as nb <NEWLINE> <NL> @ nb . njit ( ) <NEWLINE> def solve ( n , w , weights , values ) : <NEWLINE> <INDENT> dp = [ [ 0 for _ in range ( w + 1 ) ] for k in range ( n + 1 ) ] <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , w + 1 ) : <NEWLINE> <INDENT> if weights [ i ] <= j : <NEWLINE> <INDENT> dp [ i ] [ j ] = max ( dp [ i - 1 ] [ j ] , <NEWLINE> <INDENT> dp [ i - 1 ] [ j - weights [ i ] ] + values [ i ] ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> dp [ i ] [ j ] = dp [ i - 1 ] [ j ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return dp [ n ] [ w ] <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> n , w = map ( int , stdin . readline ( ) . split ( ) ) <NEWLINE> values = [ ] <NEWLINE> weights = [ ] <NEWLINE> <NL> for _ in range ( n ) : <NEWLINE> <INDENT> v , a = map ( int , stdin . readline ( ) . split ( ) ) <NEWLINE> values . append ( a ) <NEWLINE> weights . append ( v ) <NEWLINE> <NL> <DEDENT> values = [ 0 ] + values <NEWLINE> weights = [ 0 ] + weights <NEWLINE> print ( solve ( n , w , weights , values ) ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> from collections import defaultdict <NEWLINE> from heapq import heappush , heappop <NEWLINE> import sys <NEWLINE> import numpy as np <NEWLINE> import numba <NEWLINE> <NL> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> input = sys . stdin . buffer . readline <NEWLINE> INF = 10 ** 9 + 1 <COMMENT> <NEWLINE> <NL> <NL> def debug ( * x ) : <NEWLINE> <INDENT> print ( * x ) <NEWLINE> <NL> <NL> <DEDENT> @ numba . njit <NEWLINE> def get_longest ( start , values , next , head , longest ) : <NEWLINE> <INDENT> ret = longest [ start ] <NEWLINE> if ret != - 1 : <NEWLINE> <INDENT> return ret <NEWLINE> <NL> <DEDENT> ret = 0 <NEWLINE> p = head [ start ] <NEWLINE> while p : <NEWLINE> <INDENT> v = values [ p ] <NEWLINE> x = get_longest ( v , values , next , head , longest ) + 1 <NEWLINE> if x > ret : <NEWLINE> <INDENT> ret = x <NEWLINE> <DEDENT> p = next [ p ] <NEWLINE> <NL> <DEDENT> longest [ start ] = ret <NEWLINE> return ret <NEWLINE> <NL> <NL> <DEDENT> @ numba . njit <NEWLINE> def solve ( N , M , data ) : <NEWLINE> <INDENT> longest = np . repeat ( - 1 , N + 1 ) <NEWLINE> <NL> values = np . zeros ( M + 1 , np . int16 ) <NEWLINE> next = np . zeros ( M + 1 , np . int16 ) <NEWLINE> head = np . zeros ( N + 1 , np . int16 ) <NEWLINE> p = 1 <NEWLINE> for i in range ( 0 , 2 * M , 2 ) : <NEWLINE> <INDENT> v1 = data [ i ] <NEWLINE> v2 = data [ i + 1 ] <NEWLINE> values [ p ] = v2 <NEWLINE> next [ p ] = head [ v1 ] <NEWLINE> head [ v1 ] = p <NEWLINE> p += 1 <NEWLINE> <NL> <DEDENT> for i in range ( N + 1 ) : <NEWLINE> <INDENT> if head [ i ] == 0 : <NEWLINE> <INDENT> longest [ i ] = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> ret = 0 <NEWLINE> for v in range ( N + 1 ) : <NEWLINE> <INDENT> x = get_longest ( v , values , next , head , longest ) <NEWLINE> if x > ret : <NEWLINE> <INDENT> ret = x <NEWLINE> <DEDENT> <DEDENT> return ret <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> data = np . int16 ( read ( ) . split ( ) ) <NEWLINE> print ( solve ( N , M , data ) ) <NEWLINE> <NL> <NL> <DEDENT> T1 = <STRING> <NEWLINE> <NL> T2 = <STRING> <NEWLINE> <NL> T3 = <STRING> <NEWLINE> <NL> <NL> def _test ( ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> import doctest <NEWLINE> doctest . testmod ( ) <NEWLINE> <NL> <NL> <DEDENT> def as_input ( s ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> import io <NEWLINE> global read , input <NEWLINE> f = io . StringIO ( s . strip ( ) ) <NEWLINE> input = f . readline <NEWLINE> read = f . read <NEWLINE> <NL> <NL> <DEDENT> USE_NUMBA = False <NEWLINE> if ( USE_NUMBA and sys . argv [ - 1 ] == <STRING> ) or sys . argv [ - 1 ] == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> from numba . pycc import CC <NEWLINE> import numba <NEWLINE> cc = CC ( <STRING> ) <NEWLINE> cc . export ( <NEWLINE> <INDENT> <STRING> , <NEWLINE> numba . i8 ( <NEWLINE> <INDENT> numba . i8 , numba . i8 , <NEWLINE> numba . typeof ( { 1 : [ 1 ] } ) ) ) ( solve ) <NEWLINE> <DEDENT> <DEDENT> cc . compile ( ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> input = sys . stdin . buffer . readline <NEWLINE> read = sys . stdin . buffer . read <NEWLINE> <NL> if ( USE_NUMBA and sys . argv [ - 1 ] != <STRING> ) or sys . argv [ - 1 ] == <STRING> : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <INDENT> from my_module import solve <COMMENT> <NEWLINE> <DEDENT> elif sys . argv [ - 1 ] == <STRING> : <NEWLINE> <INDENT> _test ( ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> elif sys . argv [ - 1 ] != <STRING> and len ( sys . argv ) == 2 : <NEWLINE> <COMMENT> <NL> <INDENT> input_as_file = open ( sys . argv [ 1 ] ) <NEWLINE> input = input_as_file . buffer . readline <NEWLINE> read = input_as_file . buffer . read <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> <NL> <NL> class DAG : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <COMMENT> <NL> <INDENT> self . n = n <NEWLINE> self . adj = [ [ ] for _ in range ( n ) ] <NEWLINE> <NL> <DEDENT> def addEdge ( self , parent , child ) : <NEWLINE> <INDENT> self . adj [ parent ] . append ( child ) <NEWLINE> <NL> <DEDENT> def dfs ( self , node ) : <NEWLINE> <INDENT> ans = 0 <NEWLINE> for child in self . adj [ node ] : <NEWLINE> <INDENT> ans = max ( ans , 1 + self . dfs ( child ) ) <NEWLINE> <DEDENT> return ans <NEWLINE> <NL> <DEDENT> def dfsWithMemo ( self , node , memo , visited ) : <NEWLINE> <INDENT> if ( visited [ node ] ) : <NEWLINE> <INDENT> return memo [ node ] <NEWLINE> <DEDENT> visited [ node ] = True <NEWLINE> for child in self . adj [ node ] : <NEWLINE> <INDENT> memo [ node ] = max ( <NEWLINE> <INDENT> memo [ node ] , 1 + self . dfsWithMemo ( child , memo , visited ) ) <NEWLINE> <DEDENT> <DEDENT> return memo [ node ] <NEWLINE> <NL> <DEDENT> def dfsWithDp ( self , node , dp , visited ) : <NEWLINE> <INDENT> if ( visited [ node ] ) : <NEWLINE> <INDENT> return dp [ node ] <NEWLINE> <DEDENT> visited [ node ] = True <NEWLINE> for child in self . adj [ node ] : <NEWLINE> <INDENT> if not visited [ child ] : <NEWLINE> <INDENT> self . dfsWithDp ( child , dp , visited ) <NEWLINE> <DEDENT> dp [ node ] = max ( dp [ node ] , 1 + self . dfsWithDp ( child , dp , visited ) ) <NEWLINE> <DEDENT> return dp [ node ] <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> def findLongestPathNaive ( self ) : <NEWLINE> <INDENT> ans = 0 <NEWLINE> for i in range ( self . n ) : <NEWLINE> <INDENT> ans = max ( ans , self . dfs ( i ) ) <NEWLINE> <DEDENT> return ans <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> def findLongestPathWithMemo ( self ) : <NEWLINE> <INDENT> visited = [ False ] * self . n <NEWLINE> memo = [ 0 ] * self . n <NEWLINE> ans = 0 <NEWLINE> for i in range ( self . n ) : <NEWLINE> <INDENT> ans = max ( ans , self . dfsWithMemo ( i , memo , visited ) ) <NEWLINE> <DEDENT> return ans <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> def findLongestPathWithDp ( self ) : <NEWLINE> <INDENT> visited = [ False ] * self . n <NEWLINE> dp = [ 0 ] * self . n <COMMENT> <NEWLINE> ans = 0 <NEWLINE> for i in range ( self . n ) : <NEWLINE> <INDENT> ans = max ( ans , self . dfsWithDp ( i , dp , visited ) ) <NEWLINE> <DEDENT> return ans <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <INDENT> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> dag = DAG ( N ) <NEWLINE> for _ in range ( M ) : <NEWLINE> <INDENT> parent , child = map ( lambda i : int ( i ) - 1 , input ( ) . split ( ) ) <NEWLINE> dag . addEdge ( parent , child ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> print ( dag . findLongestPathWithDp ( ) ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> main ( ) <NEWLINE>
<COMMENT> <NL> <STRING> <NEWLINE> from collections import defaultdict <NEWLINE> import sys <NEWLINE> <NL> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> <NL> <NL> def solve ( N , M , edges ) : <NEWLINE> <INDENT> longest = { } <NEWLINE> <NL> stack = [ v for v in edges ] <NEWLINE> <NL> while stack : <NEWLINE> <INDENT> v = stack . pop ( ) <NEWLINE> if v > 0 : <NEWLINE> <INDENT> if v in longest : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> next_edges = edges . get ( v ) <NEWLINE> stack . append ( - v ) <NEWLINE> if next_edges : <NEWLINE> <INDENT> stack . extend ( next_edges ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> next_edges = edges . get ( - v ) <NEWLINE> if not next_edges : <NEWLINE> <INDENT> ret = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ret = max ( longest [ x ] for x in next_edges ) + 1 <NEWLINE> <DEDENT> longest [ - v ] = ret <NEWLINE> <NL> <DEDENT> <DEDENT> return max ( longest [ v ] for v in edges ) <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> edges = defaultdict ( set ) <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> v1 , v2 = map ( int , input ( ) . split ( ) ) <NEWLINE> edges [ v1 ] . add ( v2 ) <NEWLINE> <NL> <DEDENT> print ( solve ( N , M , edges ) ) <NEWLINE> <NL> <NL> <DEDENT> T1 = <STRING> <NEWLINE> <NL> T2 = <STRING> <NEWLINE> <NL> T3 = <STRING> <NEWLINE> <NL> <NL> def _test ( ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> import doctest <NEWLINE> doctest . testmod ( ) <NEWLINE> <NL> <NL> <DEDENT> def as_input ( s ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> import io <NEWLINE> global read , input <NEWLINE> f = io . StringIO ( s . strip ( ) ) <NEWLINE> input = f . readline <NEWLINE> read = f . read <NEWLINE> <NL> <NL> <DEDENT> USE_NUMBA = False <NEWLINE> if ( USE_NUMBA and sys . argv [ - 1 ] == <STRING> ) or sys . argv [ - 1 ] == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> from numba . pycc import CC <NEWLINE> cc = CC ( <STRING> ) <NEWLINE> cc . export ( <STRING> , solve . __doc__ . strip ( ) . split ( ) [ 0 ] ) ( solve ) <NEWLINE> cc . compile ( ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> input = sys . stdin . buffer . readline <NEWLINE> read = sys . stdin . buffer . read <NEWLINE> <NL> if ( USE_NUMBA and sys . argv [ - 1 ] != <STRING> ) or sys . argv [ - 1 ] == <STRING> : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <INDENT> from my_module import solve <COMMENT> <NEWLINE> <DEDENT> elif sys . argv [ - 1 ] == <STRING> : <NEWLINE> <INDENT> _test ( ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> elif sys . argv [ - 1 ] != <STRING> and len ( sys . argv ) == 2 : <NEWLINE> <COMMENT> <NL> <INDENT> input_as_file = open ( sys . argv [ 1 ] ) <NEWLINE> input = input_as_file . buffer . readline <NEWLINE> read = input_as_file . buffer . read <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE> <DEDENT> T1 = <STRING> <NEWLINE> <NL> T2 = <STRING> <NEWLINE> <NL> T3 = <STRING> <NEWLINE> <NL> <NL> def _test ( ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> import doctest <NEWLINE> doctest . testmod ( ) <NEWLINE> <NL> <NL> <DEDENT> def as_input ( s ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> import io <NEWLINE> global read , input <NEWLINE> f = io . StringIO ( s . strip ( ) ) <NEWLINE> input = f . readline <NEWLINE> read = f . read <NEWLINE> <NL> <NL> <DEDENT> USE_NUMBA = False <NEWLINE> if ( USE_NUMBA and sys . argv [ - 1 ] == <STRING> ) or sys . argv [ - 1 ] == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> from numba . pycc import CC <NEWLINE> cc = CC ( <STRING> ) <NEWLINE> cc . export ( <STRING> , solve . __doc__ . strip ( ) . split ( ) [ 0 ] ) ( solve ) <NEWLINE> cc . compile ( ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> input = sys . stdin . buffer . readline <NEWLINE> read = sys . stdin . buffer . read <NEWLINE> <NL> if ( USE_NUMBA and sys . argv [ - 1 ] != <STRING> ) or sys . argv [ - 1 ] == <STRING> : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <INDENT> from my_module import solve <COMMENT> <NEWLINE> <DEDENT> elif sys . argv [ - 1 ] == <STRING> : <NEWLINE> <INDENT> _test ( ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> elif sys . argv [ - 1 ] != <STRING> and len ( sys . argv ) == 2 : <NEWLINE> <COMMENT> <NL> <INDENT> input_as_file = open ( sys . argv [ 1 ] ) <NEWLINE> input = input_as_file . buffer . readline <NEWLINE> read = input_as_file . buffer . read <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> from collections import defaultdict <NEWLINE> from heapq import heappush , heappop <NEWLINE> import sys <NEWLINE> import numpy as np <NEWLINE> <NL> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> input = sys . stdin . buffer . readline <NEWLINE> INF = 10 ** 9 + 1 <COMMENT> <NEWLINE> <NL> <NL> def debug ( * x ) : <NEWLINE> <INDENT> print ( * x ) <NEWLINE> <NL> <NL> <DEDENT> @ numba . njit ( cache = True ) <NEWLINE> def get_longest ( start , values , next , head , longest ) : <NEWLINE> <INDENT> ret = longest [ start ] <NEWLINE> if ret != - 1 : <NEWLINE> <INDENT> return ret <NEWLINE> <NL> <DEDENT> ret = 0 <NEWLINE> p = head [ start ] <NEWLINE> while p : <NEWLINE> <INDENT> v = values [ p ] <NEWLINE> x = get_longest ( v , values , next , head , longest ) + 1 <NEWLINE> if x > ret : <NEWLINE> <INDENT> ret = x <NEWLINE> <DEDENT> p = next [ p ] <NEWLINE> <NL> <DEDENT> longest [ start ] = ret <NEWLINE> return ret <NEWLINE> <NL> <NL> <DEDENT> @ numba . njit ( cache = True ) <NEWLINE> def solve ( N , M , data ) : <NEWLINE> <INDENT> longest = np . repeat ( - 1 , N + 1 ) <NEWLINE> <NL> values = np . zeros ( M + 1 , np . int32 ) <NEWLINE> next = np . zeros ( M + 1 , np . int32 ) <NEWLINE> head = np . zeros ( N + 1 , np . int32 ) <NEWLINE> p = 1 <NEWLINE> for i in range ( 0 , 2 * M , 2 ) : <NEWLINE> <INDENT> v1 = data [ i ] <NEWLINE> v2 = data [ i + 1 ] <NEWLINE> values [ p ] = v2 <NEWLINE> next [ p ] = head [ v1 ] <NEWLINE> head [ v1 ] = p <NEWLINE> p += 1 <NEWLINE> <NL> <DEDENT> for i in range ( N + 1 ) : <NEWLINE> <INDENT> if head [ i ] == 0 : <NEWLINE> <INDENT> longest [ i ] = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> ret = 0 <NEWLINE> for v in range ( N + 1 ) : <NEWLINE> <INDENT> x = get_longest ( v , values , next , head , longest ) <NEWLINE> if x > ret : <NEWLINE> <INDENT> ret = x <NEWLINE> <DEDENT> <DEDENT> return ret <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> data = np . int32 ( read ( ) . split ( ) ) <NEWLINE> print ( solve ( N , M , data ) ) <NEWLINE> <NL> <NL> <DEDENT> T1 = <STRING> <NEWLINE> <NL> T2 = <STRING> <NEWLINE> <NL> T3 = <STRING> <NEWLINE> <NL> <NL> def _test ( ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> import doctest <NEWLINE> doctest . testmod ( ) <NEWLINE> <NL> <NL> <DEDENT> def as_input ( s ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> import io <NEWLINE> global read , input <NEWLINE> f = io . StringIO ( s . strip ( ) ) <NEWLINE> input = f . readline <NEWLINE> read = f . read <NEWLINE> <NL> <NL> <DEDENT> USE_NUMBA = False <NEWLINE> if ( USE_NUMBA and sys . argv [ - 1 ] == <STRING> ) or sys . argv [ - 1 ] == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> import numba <NEWLINE> numba . njit ( cache = True ) ( get_longest ) <NEWLINE> numba . njit ( cache = True ) ( solve ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> input = sys . stdin . buffer . readline <NEWLINE> read = sys . stdin . buffer . read <NEWLINE> <NL> if ( USE_NUMBA and sys . argv [ - 1 ] != <STRING> ) or sys . argv [ - 1 ] == <STRING> : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <INDENT> import <NEWLINE> <NL> <DEDENT> elif sys . argv [ - 1 ] == <STRING> : <NEWLINE> <INDENT> _test ( ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> elif sys . argv [ - 1 ] != <STRING> and len ( sys . argv ) == 2 : <NEWLINE> <COMMENT> <NL> <INDENT> input_as_file = open ( sys . argv [ 1 ] ) <NEWLINE> input = input_as_file . buffer . readline <NEWLINE> read = input_as_file . buffer . read <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE> <DEDENT>
v = pow ( 10 , 9 ) + 7 <NEWLINE> arr = [ ] <NEWLINE> inp = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> row = inp [ 0 ] <NEWLINE> col = in [ 1 ] <NEWLINE> for i in range ( row ) : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> arr . append ( s ) <NEWLINE> <DEDENT> ans = [ [ 0 for i in range ( col ) ] for j in range ( row ) ] <NEWLINE> for i in range ( col ) : <NEWLINE> <INDENT> if arr [ 0 ] [ i ] == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans [ 0 ] [ i ] = 1 <NEWLINE> <DEDENT> <DEDENT> for i in range ( row ) : <NEWLINE> <INDENT> if arr [ i ] [ 0 ] == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans [ i ] [ 0 ] = 1 <NEWLINE> <DEDENT> <DEDENT> for i in range ( 1 , row ) : <NEWLINE> <INDENT> for j in range ( 1 , col ) : <NEWLINE> <INDENT> if arr [ i ] [ j ] == <STRING> : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> arr [ i ] [ j ] = ( arr [ i - 1 ] [ j ] + arr [ i ] [ j - 1 ] ) % v <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( arr [ - 1 ] [ - 1 ] ) <NEWLINE>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> def grid ( y , x , mp ) : <NEWLINE> <INDENT> mod = 10 ** 9 + 7 <NEWLINE> dp = [ [ 0 ] * y for _ in range ( x ) ] <NEWLINE> dp [ 0 ] [ 0 ] = 1 <NEWLINE> for h in range ( y ) : <NEWLINE> <INDENT> for w in range ( x ) : <NEWLINE> <INDENT> if mp [ h ] [ w ] == <STRING> : <NEWLINE> <INDENT> if h >= 1 : <NEWLINE> <INDENT> dp [ h ] [ w ] += ( dp [ h - 1 ] [ w ] % mod ) <NEWLINE> <DEDENT> if w >= 1 : <NEWLINE> <INDENT> dp [ h ] [ w ] += ( dp [ h ] [ w - 1 ] % mod ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> return dp [ y - 1 ] [ x - 1 ] % mod <NEWLINE> <NL> <NL> <DEDENT> H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> mp = [ ] <NEWLINE> for _ in range ( H ) : <NEWLINE> <INDENT> mp . append ( list ( input ( ) ) ) <NEWLINE> <DEDENT> print ( grid ( H , W , mp ) ) <NEWLINE> <NL>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> dp = [ ] <NEWLINE> for i in range ( n + 1 ) : <NEWLINE> <INDENT> dp . append ( [ ] ) <NEWLINE> for j in range ( m + 1 ) : <NEWLINE> <INDENT> dp [ i ] . append ( 0 ) <NEWLINE> <DEDENT> <DEDENT> arr = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> arr . append ( input ( ) ) <NEWLINE> <DEDENT> dp [ 1 ] [ 1 ] = 1 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , m + 1 ) : <NEWLINE> <INDENT> if arr [ i - 1 ] [ j - 1 ] == <STRING> or ( i == 1 and j == 1 ) : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> dp [ i ] [ j ] = dp [ i - 1 ] [ j ] + dp [ i ] [ j - 1 ] <NEWLINE> <DEDENT> <DEDENT> print ( dp [ n ] [ m ] % 1000000007 <NEWLINE>
import sys <NEWLINE> readline = sys . stdin . readline <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> N = int ( input ( ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> p = list ( map ( float , readline ( ) . split ( ) ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> dp = [ [ 0.0 ] * ( N + 1 ) for _ in range ( N + 1 ) ] <NEWLINE> <NL> dp [ 0 ] [ 0 ] = 1 <NEWLINE> <NL> for i , p in enumerate ( p , 1 ) : <NEWLINE> <INDENT> pp = 1 - p <NEWLINE> dpij = dp [ i ] [ j ] <NEWLINE> dpi = dp [ i - 1 ] <NEWLINE> for j in range ( i + 1 ) : <NEWLINE> <INDENT> if j == 0 : <NEWLINE> <INDENT> dpij = dpi [ j ] * pp <NEWLINE> <DEDENT> elif j == i : <NEWLINE> <INDENT> dpij = dpi [ j - 1 ] * p <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dpij = dpi [ j - 1 ] * p + dpi [ j ] * pp <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> res = 0.0 <NEWLINE> n = N // 2 + 1 <NEWLINE> <NL> for cnt in dp [ - 1 ] [ n : ] : <NEWLINE> <INDENT> res += cnt <NEWLINE> <NL> <DEDENT> print ( res ) <NEWLINE>
import numpy as np <NEWLINE> from numba import njit <NEWLINE> <NL> <NL> @ njit ( <STRING> , cache = True ) <NEWLINE> def solve ( dp , N , n1 , n2 , n3 ) : <NEWLINE> <NL> <INDENT> if dp [ n1 ] [ n2 ] [ n3 ] >= 0.0 : <NEWLINE> <INDENT> return dp [ n1 ] [ n2 ] [ n3 ] <NEWLINE> <DEDENT> if n1 == n2 == n3 == 0 : <NEWLINE> <INDENT> return 0.0 <NEWLINE> <NL> <DEDENT> cnt = n1 + n2 + n3 <NEWLINE> ret = 0 <NEWLINE> if n3 >= 1 : <NEWLINE> <INDENT> ret += solve ( dp , N , n1 , n2 + 1 , n3 - 1 ) * n3 <NEWLINE> <DEDENT> if n2 >= 1 : <NEWLINE> <INDENT> ret += solve ( dp , N , n1 + 1 , n2 - 1 , n3 ) * n2 <NEWLINE> <DEDENT> if n1 >= 1 : <NEWLINE> <INDENT> ret += solve ( dp , N , n1 - 1 , n2 , n3 ) * n1 <NEWLINE> <NL> <DEDENT> ret = ( ret + N ) / cnt <NEWLINE> dp [ n1 ] [ n2 ] [ n3 ] = ret <NEWLINE> return ret <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> dp = np . full ( ( N + 1 , N + 1 , N + 1 ) , - 1 , dtype = np . float64 ) <NEWLINE> <NL> a1 , a2 , a3 = 0 , 0 , 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if A [ i ] == 1 : <NEWLINE> <INDENT> a1 += 1 <NEWLINE> <DEDENT> elif A [ i ] == 2 : <NEWLINE> <INDENT> a2 += 1 <NEWLINE> <DEDENT> elif A [ i ] == 3 : <NEWLINE> <INDENT> a3 += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( solve ( dp , N , a1 , a2 , a3 ) ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> import numpy as np <NEWLINE> from numba import njit <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> <NL> read = sys . stdin . buffer . read <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> readlines = sys . stdin . buffer . readlines <NEWLINE> <NL> in_n = lambda : int ( readline ( ) ) <NEWLINE> in_nn = lambda : map ( int , readline ( ) . split ( ) ) <NEWLINE> in_s = lambda : readline ( ) . rstrip ( ) . decode ( <STRING> ) <NEWLINE> in_nl = lambda : list ( map ( int , readline ( ) . split ( ) ) ) <NEWLINE> in_nl2 = lambda H : [ in_nl ( ) for _ in range ( H ) ] <NEWLINE> in_map = lambda : [ s == ord ( <STRING> ) for s in readline ( ) if s != ord ( <STRING> ) ] <NEWLINE> in_map2 = lambda H : [ in_map ( ) for _ in range ( H ) ] <NEWLINE> in_all = lambda : map ( int , read ( ) . split ( ) ) <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <NL> <INDENT> N = in_n ( ) <NEWLINE> A = in_nl ( ) <NEWLINE> <NL> n1 = A . count ( 1 ) <NEWLINE> n2 = A . count ( 2 ) <NEWLINE> n3 = A . count ( 3 ) <NEWLINE> <NL> dp = np . full ( ( N + 1 , N + 1 , N + 1 ) , - 1 , dtype = np . float64 ) <NEWLINE> dp [ 0 ] [ 0 ] [ 0 ] = 0 <NEWLINE> <NL> print ( solve ( N , dp , n1 , n2 , n3 ) ) <NEWLINE> <NL> <NL> <DEDENT> @ njit ( <STRING> , cache = True ) <NEWLINE> def solve ( N , dp , n1 , n2 , n3 ) : <NEWLINE> <NL> <INDENT> if dp [ n1 ] [ n2 ] [ n3 ] != - 1 : <NEWLINE> <INDENT> return dp [ n1 ] [ n2 ] [ n3 ] <NEWLINE> <NL> <DEDENT> cnt = n1 + n2 + n3 <NEWLINE> ret = 0 <NEWLINE> if n3 >= 1 : <NEWLINE> <INDENT> ret += solve ( N , dp , n1 , n2 + 1 , n3 - 1 ) * n3 / cnt <NEWLINE> <DEDENT> if n2 >= 1 : <NEWLINE> <INDENT> ret += solve ( N , dp , n1 + 1 , n2 - 1 , n3 ) * n2 / cnt <NEWLINE> <DEDENT> if n1 >= 1 : <NEWLINE> <INDENT> ret += solve ( N , dp , n1 - 1 , n2 , n3 ) * n1 / cnt <NEWLINE> <NL> <DEDENT> dp [ n1 ] [ n2 ] [ n3 ] = ret + ( N / cnt ) <NEWLINE> return ret + ( N / cnt ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a . append ( int ( input ( ) ) ) <NEWLINE> <NL> <DEDENT> dp = [ False ] * ( k + 1 ) <NEWLINE> dp [ 0 ] = 0 <NEWLINE> <NL> for i in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> for j in range ( n ) : <NEWLINE> <INDENT> if i - a [ j ] >= 0 and dp [ i - a [ j ] ] == 0 : <NEWLINE> <INDENT> dp [ i ] = 1 <NEWLINE> break <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> if dp [ k ] == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
